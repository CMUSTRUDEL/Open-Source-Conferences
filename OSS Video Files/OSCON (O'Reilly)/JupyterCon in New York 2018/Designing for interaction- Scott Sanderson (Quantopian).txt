Title: Designing for interaction- Scott Sanderson (Quantopian)
Publication date: 2018-09-21
Playlist: JupyterCon in New York 2018
Description: 
	One of the defining features of Python is its flexibility: it can be used interactively, and it can also be used as the principal development language for large standalone applications. While this flexibility is a major reason for Pythonâ€™s popularity, it also presents a unique challenge for library authors, because the wants and needs of interactive users often conflict with the wants and needs of application developers.

Scott Sanderson explores how interactivity can and should influence the design of software libraries, details how the needs of interactive users differ from the needs of application developers, and shares techniques for improving the usability of libraries in interactive environments without sacrificing robustness in noninteractive environments. Scott uses Python in his examples, but the general principles are applicable to any programming language that supports both interactive use and standalone application development.

Topics include:

How the needs of interactive users can diverge from the needs of application developers
Ease of typing versus clarity of behavior
Robustness versus error forgiveness
Tolerance for global state
How to make your libraryâ€™s functions and classes work well with Jupyter
Interactive documentation
Completions
Custom display formats
IPython Magics
How to organize modules to be discoverable in interactive sessions

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on: 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Instagram: https://www.instagram.com/oreillymedia
LinkedIn: https://www.linkedin.com/company-beta/8459/
Captions: 
	00:00:02,170 --> 00:00:07,689
alright it is 5 o'clock so I think we're

00:00:05,590 --> 00:00:10,230
gonna get started thank you all for

00:00:07,689 --> 00:00:14,080
sticking around to the bitter end here

00:00:10,230 --> 00:00:15,930
let a couple more people file in my name

00:00:14,080 --> 00:00:19,900
is Scott Sanderson this talk is

00:00:15,930 --> 00:00:23,230
designing for interaction and yeah

00:00:19,900 --> 00:00:26,349
thanks thanks for coming out so kind of

00:00:23,230 --> 00:00:29,199
the the thing that prompted me to want

00:00:26,349 --> 00:00:31,179
to give this talk is actually seeing

00:00:29,199 --> 00:00:34,149
another talk by Brian Cantrell who's the

00:00:31,179 --> 00:00:36,789
CEO or the CTO at giants which is a sort

00:00:34,149 --> 00:00:38,140
of cloud company and there are sort of

00:00:36,789 --> 00:00:41,100
most famous as the people who originally

00:00:38,140 --> 00:00:43,570
develop nodejs and then later having a

00:00:41,100 --> 00:00:46,989
somewhat sort of acrimonious breakup

00:00:43,570 --> 00:00:48,789
with no js' and in 2017 Brian gave a

00:00:46,989 --> 00:00:51,340
talk kind of about how that came to pass

00:00:48,789 --> 00:00:53,469
and essentially the thesis of his talk

00:00:51,340 --> 00:00:55,570
was that what they realized was that the

00:00:53,469 --> 00:00:56,859
node.js community had different values

00:00:55,570 --> 00:00:59,800
for what they cared about in their

00:00:56,859 --> 00:01:01,510
software and that over time Joyent and

00:00:59,800 --> 00:01:02,890
the node community had had sort of

00:01:01,510 --> 00:01:04,390
drifted apart in what they are actually

00:01:02,890 --> 00:01:06,280
really they had never been aligned and

00:01:04,390 --> 00:01:08,770
they eventually realized that they had

00:01:06,280 --> 00:01:10,270
different values so that's sort of the

00:01:08,770 --> 00:01:11,680
leading context so one of the things

00:01:10,270 --> 00:01:13,960
that Brian says early in that tell uses

00:01:11,680 --> 00:01:15,579
values are what's important to you and

00:01:13,960 --> 00:01:17,140
we all believe that we have the same

00:01:15,579 --> 00:01:18,340
things that are important to us because

00:01:17,140 --> 00:01:20,439
they're important to us so of course

00:01:18,340 --> 00:01:22,329
they're important to you but that's not

00:01:20,439 --> 00:01:24,040
the tape not the case

00:01:22,329 --> 00:01:26,439
we always talk about the right tool for

00:01:24,040 --> 00:01:27,970
the job but when it comes to choosing a

00:01:26,439 --> 00:01:29,560
software platform it's not really the

00:01:27,970 --> 00:01:32,530
right tool for the job it's the right

00:01:29,560 --> 00:01:33,610
values for the job and so in the context

00:01:32,530 --> 00:01:35,860
of this talk he's talking about this

00:01:33,610 --> 00:01:38,049
idea that the kinds of tools the things

00:01:35,860 --> 00:01:39,579
they cared about it joy it turned out to

00:01:38,049 --> 00:01:41,680
be not the values of node and so they

00:01:39,579 --> 00:01:44,140
ended up kind of drifting apart

00:01:41,680 --> 00:01:46,689
and so what I want to think about is

00:01:44,140 --> 00:01:47,950
that how does that apply to Python so

00:01:46,689 --> 00:01:49,719
obviously he's talking about language

00:01:47,950 --> 00:01:51,850
choices and we tend to think that within

00:01:49,719 --> 00:01:53,770
a language we kind of have a single

00:01:51,850 --> 00:01:55,539
coherent set of values but I'm gonna

00:01:53,770 --> 00:01:57,219
make the claim that even that's not true

00:01:55,539 --> 00:01:59,079
and I think it's sort of uniquely not

00:01:57,219 --> 00:02:00,939
true in an interesting way in Python so

00:01:59,079 --> 00:02:03,969
kind of the thesis of this talk is that

00:02:00,939 --> 00:02:06,039
Python library design has some kind of

00:02:03,969 --> 00:02:07,930
unique challenges because code is used

00:02:06,039 --> 00:02:11,890
by different communities with divergent

00:02:07,930 --> 00:02:12,849
technical values and that's not a bad

00:02:11,890 --> 00:02:14,960
thing that's not like there's a group

00:02:12,849 --> 00:02:16,550
that's wrong and a group that's right

00:02:14,960 --> 00:02:18,440
argue that that value divergence is a

00:02:16,550 --> 00:02:20,270
natural product of the different modes

00:02:18,440 --> 00:02:22,880
of interaction that different users have

00:02:20,270 --> 00:02:24,440
with code that's written in Python so

00:02:22,880 --> 00:02:27,260
that's sort of the sub thesis and then

00:02:24,440 --> 00:02:28,610
the sub sub thesis is data science and

00:02:27,260 --> 00:02:30,500
traditional engineering teams often

00:02:28,610 --> 00:02:32,630
struggle to collaborate because of this

00:02:30,500 --> 00:02:33,650
divergence so the Pat the fact that data

00:02:32,630 --> 00:02:35,240
science teams and traditional

00:02:33,650 --> 00:02:37,190
engineering teams work with Python code

00:02:35,240 --> 00:02:38,750
in different ways is I think at the root

00:02:37,190 --> 00:02:40,730
of a lot of the struggles that those

00:02:38,750 --> 00:02:43,220
teams often have to collaborate or to

00:02:40,730 --> 00:02:45,980
say move models from design to

00:02:43,220 --> 00:02:48,290
deployment so what are the goals for

00:02:45,980 --> 00:02:51,440
this talk one is I want to sort of talk

00:02:48,290 --> 00:02:53,270
about in an explicit way how interactive

00:02:51,440 --> 00:02:54,770
and non interactive development can

00:02:53,270 --> 00:02:57,230
cultivate these different software

00:02:54,770 --> 00:02:59,450
values I want to help us try to identify

00:02:57,230 --> 00:03:01,790
design decisions we're making where I

00:02:59,450 --> 00:03:04,490
think in a lot of cases we implicitly

00:03:01,790 --> 00:03:06,080
make decisions that are geared towards

00:03:04,490 --> 00:03:08,540
one set of values or another set of

00:03:06,080 --> 00:03:10,040
values that are usually rooted in the

00:03:08,540 --> 00:03:11,180
kinds of work that we do sort of

00:03:10,040 --> 00:03:13,010
day-to-day as developers I want to help

00:03:11,180 --> 00:03:14,270
us sort of identify and make those

00:03:13,010 --> 00:03:16,850
decisions a little bit more consciously

00:03:14,270 --> 00:03:18,080
a little bit more explicitly and then

00:03:16,850 --> 00:03:19,580
finally I want to try to conclude with

00:03:18,080 --> 00:03:21,380
some advice for structuring code in a

00:03:19,580 --> 00:03:24,650
way that affords both interactive and

00:03:21,380 --> 00:03:26,540
non interactive use a little bit about

00:03:24,650 --> 00:03:27,590
me to sort of give context for why you

00:03:26,540 --> 00:03:29,210
might want to listen to what I have to

00:03:27,590 --> 00:03:31,220
say about any of this so I'm a principal

00:03:29,210 --> 00:03:34,000
engineer at quanto pium quant opine is

00:03:31,220 --> 00:03:36,620
an online platform for developing

00:03:34,000 --> 00:03:39,020
financial analyses and quantitative

00:03:36,620 --> 00:03:40,580
trading strategy so we have a big hosted

00:03:39,020 --> 00:03:42,410
online platform where we have a whole

00:03:40,580 --> 00:03:43,790
bunch of financial data people can come

00:03:42,410 --> 00:03:45,200
in work interactively and Jupiter

00:03:43,790 --> 00:03:48,020
notebooks to analyze that data as well

00:03:45,200 --> 00:03:49,220
as design trading strategies live trade

00:03:48,020 --> 00:03:50,600
them enter them in contests and

00:03:49,220 --> 00:03:53,600
ultimately our business model is trying

00:03:50,600 --> 00:03:55,670
to fund well written algorithms and

00:03:53,600 --> 00:03:57,950
offer those users capital allocations so

00:03:55,670 --> 00:03:59,240
we we have both sort of an interactive

00:03:57,950 --> 00:04:01,370
Jupiter environment as well as a whole

00:03:59,240 --> 00:04:03,110
host of sort of more I donno if I want

00:04:01,370 --> 00:04:06,260
to say traditional but sort of large non

00:04:03,110 --> 00:04:08,750
interactive applications built for for

00:04:06,260 --> 00:04:10,790
working in this same domain I'm into a

00:04:08,750 --> 00:04:12,050
particular by my responsibility sort of

00:04:10,790 --> 00:04:14,480
leading the team that's responsible for

00:04:12,050 --> 00:04:16,880
both the back testing API is as well as

00:04:14,480 --> 00:04:18,620
the Jupiter based research api's and

00:04:16,880 --> 00:04:20,810
what that means is sort of day to day my

00:04:18,620 --> 00:04:21,859
work is mostly out there API design or

00:04:20,810 --> 00:04:23,540
what I would call like data

00:04:21,859 --> 00:04:24,890
infrastructure so sort of figuring out

00:04:23,540 --> 00:04:27,800
how we're going to get data from

00:04:24,890 --> 00:04:28,100
wherever it is to a users terminal or

00:04:27,800 --> 00:04:29,750
use

00:04:28,100 --> 00:04:31,760
Jupiter notebook or users backtest in a

00:04:29,750 --> 00:04:33,020
way that's performant and coherent and

00:04:31,760 --> 00:04:35,300
sort of makes sense of the messy world

00:04:33,020 --> 00:04:37,100
of financial data so the code that I

00:04:35,300 --> 00:04:38,510
commits you know that I'm writing and

00:04:37,100 --> 00:04:41,210
sort of pushing and code reviewing is

00:04:38,510 --> 00:04:42,590
sort of traditional application code but

00:04:41,210 --> 00:04:44,360
I actually do a lot of exploratory

00:04:42,590 --> 00:04:45,890
analysis because we make this big

00:04:44,360 --> 00:04:47,660
Jupiter hosted Jupiter notebook platform

00:04:45,890 --> 00:04:48,920
and also as we're integrating new

00:04:47,660 --> 00:04:50,110
datasets or bringing new data on the

00:04:48,920 --> 00:04:52,070
platform there's a lot of sort of

00:04:50,110 --> 00:04:53,480
exploratory analysis to understand

00:04:52,070 --> 00:04:54,440
whether that data is correct what that

00:04:53,480 --> 00:04:56,360
data means whether there's weird

00:04:54,440 --> 00:04:57,920
anomalies with the data so I kind of

00:04:56,360 --> 00:04:59,450
have a little bit of a foot in both

00:04:57,920 --> 00:05:00,890
camps in terms of the traditional

00:04:59,450 --> 00:05:03,950
application development as well as

00:05:00,890 --> 00:05:05,560
interactive development so there's

00:05:03,950 --> 00:05:08,000
that's kind of context for the talk so

00:05:05,560 --> 00:05:10,850
backing out to kind of the 10,000 foot

00:05:08,000 --> 00:05:13,760
view what is it that makes a piece of

00:05:10,850 --> 00:05:16,070
software well designed I think anyone

00:05:13,760 --> 00:05:17,450
who asks you or who asks a question like

00:05:16,070 --> 00:05:20,060
this that sort of this open-ended and

00:05:17,450 --> 00:05:23,360
tries to give you a direct answer is is

00:05:20,060 --> 00:05:24,800
lying or is wrong so the like the only

00:05:23,360 --> 00:05:27,440
answer I can really give to that is it

00:05:24,800 --> 00:05:30,620
depends right so well you might ask okay

00:05:27,440 --> 00:05:36,620
on what like what does it depend on and

00:05:30,620 --> 00:05:37,760
then sort of mumble mumble context let's

00:05:36,620 --> 00:05:40,340
dig in a little bit more into what

00:05:37,760 --> 00:05:42,350
context means in the context of software

00:05:40,340 --> 00:05:44,270
design so one thing that context might

00:05:42,350 --> 00:05:46,310
mean is language features and language

00:05:44,270 --> 00:05:48,200
design so a design that's good and one

00:05:46,310 --> 00:05:49,550
programming language might not be a good

00:05:48,200 --> 00:05:51,590
design another language so things like

00:05:49,550 --> 00:05:52,670
the type system the object model the

00:05:51,590 --> 00:05:54,230
runtime whether you have garbage

00:05:52,670 --> 00:05:56,000
collection which your concurrency model

00:05:54,230 --> 00:05:57,710
is whether you have a compiler all these

00:05:56,000 --> 00:05:59,660
things can make a design sort of useful

00:05:57,710 --> 00:06:01,730
and natural and ergonomic in one

00:05:59,660 --> 00:06:03,640
language and not so in another language

00:06:01,730 --> 00:06:05,480
or vice versa

00:06:03,640 --> 00:06:07,250
another thing that affects whether a

00:06:05,480 --> 00:06:09,200
design is sort of a good design is the

00:06:07,250 --> 00:06:10,850
ecosystem of packages that exist in that

00:06:09,200 --> 00:06:12,620
language so that includes things like

00:06:10,850 --> 00:06:14,690
the standard library which in Python

00:06:12,620 --> 00:06:15,800
we're sort of fortunate of having by the

00:06:14,690 --> 00:06:18,650
way most of them going to talk about

00:06:15,800 --> 00:06:19,970
today's Python but much of one going to

00:06:18,650 --> 00:06:21,380
talk about does apply to other languages

00:06:19,970 --> 00:06:23,420
but I do think Python count has some

00:06:21,380 --> 00:06:25,490
unique interesting challenges but anyway

00:06:23,420 --> 00:06:27,110
so things like the standard library as

00:06:25,490 --> 00:06:28,610
well as third-party packages so if

00:06:27,110 --> 00:06:30,350
you're say working in the numerical

00:06:28,610 --> 00:06:31,670
Python ecosystem it's probably important

00:06:30,350 --> 00:06:33,350
for you that your library integrates

00:06:31,670 --> 00:06:35,510
well with with packages like numpy and

00:06:33,350 --> 00:06:37,160
pandas and maybe site pyar so I couldn't

00:06:35,510 --> 00:06:39,229
learn so the the fact that there's other

00:06:37,160 --> 00:06:40,700
other libraries and the code that your

00:06:39,229 --> 00:06:41,729
code is going to interact with should

00:06:40,700 --> 00:06:44,879
influence how you design

00:06:41,729 --> 00:06:46,439
your code another thing that influences

00:06:44,879 --> 00:06:47,999
you know weather weather code is well

00:06:46,439 --> 00:06:49,680
design is how it can interact with other

00:06:47,999 --> 00:06:51,180
tools so things like compilers and

00:06:49,680 --> 00:06:53,939
linters and test frameworks and

00:06:51,180 --> 00:06:55,169
packaging tools one of the things that

00:06:53,939 --> 00:06:57,270
we should be considering as we're

00:06:55,169 --> 00:06:59,699
designing our software is how well can

00:06:57,270 --> 00:07:03,509
the way the code written in the way that

00:06:59,699 --> 00:07:05,430
we're writing it be improved or be be

00:07:03,509 --> 00:07:07,319
made easier to work with through these

00:07:05,430 --> 00:07:08,849
kinds of tools some kinds of tools or

00:07:07,319 --> 00:07:12,900
some kinds of designs are more amenable

00:07:08,849 --> 00:07:14,490
to say static analysis or to linting or

00:07:12,900 --> 00:07:16,409
to compilation or other things like that

00:07:14,490 --> 00:07:18,360
and then another thing is just for

00:07:16,409 --> 00:07:19,860
documentation standards how is it housed

00:07:18,360 --> 00:07:20,729
I'm gonna learn about your library it

00:07:19,860 --> 00:07:24,120
might affect how you're going to

00:07:20,729 --> 00:07:25,620
structure your library and I think these

00:07:24,120 --> 00:07:28,169
are the kinds of things that Brian

00:07:25,620 --> 00:07:29,999
Cantrell was talking about in his his

00:07:28,169 --> 00:07:32,069
talk where he's talking about nodejs and

00:07:29,999 --> 00:07:34,349
and the kinds of things that affect at

00:07:32,069 --> 00:07:35,999
the language level the community and the

00:07:34,349 --> 00:07:36,930
values and what what's things become a

00:07:35,999 --> 00:07:39,330
reflection of the values of that

00:07:36,930 --> 00:07:41,819
community one thing that I think is

00:07:39,330 --> 00:07:43,979
unique about Python is that we also have

00:07:41,819 --> 00:07:45,479
these different modes of use and I think

00:07:43,979 --> 00:07:47,490
pythons somewhat unique in that we have

00:07:45,479 --> 00:07:50,370
such a diversity of modes of use for the

00:07:47,490 --> 00:07:53,159
language so there's folks who write sort

00:07:50,370 --> 00:07:55,310
of traditional standalone servers in

00:07:53,159 --> 00:07:58,259
Python there's command line applications

00:07:55,310 --> 00:07:59,909
there's people whose primary interface

00:07:58,259 --> 00:08:01,409
with the language is repple and then

00:07:59,909 --> 00:08:02,639
there's also you know a large and

00:08:01,409 --> 00:08:04,289
growing community people whose primary

00:08:02,639 --> 00:08:06,149
interface with the language is Jupiter

00:08:04,289 --> 00:08:08,189
notebooks and one of the things that I

00:08:06,149 --> 00:08:10,409
want to point out here is that there are

00:08:08,189 --> 00:08:12,959
a fair amount of languages like R or

00:08:10,409 --> 00:08:14,129
MATLAB or Julia where people do

00:08:12,959 --> 00:08:15,479
interactive development and their

00:08:14,129 --> 00:08:17,219
primary interface to the language is

00:08:15,479 --> 00:08:19,770
interactive development and there's lots

00:08:17,219 --> 00:08:22,110
of languages like C or C++ or you know

00:08:19,770 --> 00:08:23,249
c-sharp or Java that people wear

00:08:22,110 --> 00:08:24,779
people's primary interface to the

00:08:23,249 --> 00:08:25,680
language is sort of standalone

00:08:24,779 --> 00:08:28,050
application development

00:08:25,680 --> 00:08:29,550
I think pythons somewhat unique in the

00:08:28,050 --> 00:08:30,930
in it being the case that there's large

00:08:29,550 --> 00:08:32,669
communities that do both of those kinds

00:08:30,930 --> 00:08:33,990
of activities in the language and I

00:08:32,669 --> 00:08:36,930
think that sort of imposes some unique

00:08:33,990 --> 00:08:37,919
challenges on the language so you can

00:08:36,930 --> 00:08:39,719
think about this as kind of being on

00:08:37,919 --> 00:08:41,880
this sort of spectrum of interaction you

00:08:39,719 --> 00:08:44,430
can see my very fancy diagram here of

00:08:41,880 --> 00:08:46,380
ASCII text so you know all the way on

00:08:44,430 --> 00:08:47,790
the interactive side use just writing in

00:08:46,380 --> 00:08:49,199
a repple where you're purely just

00:08:47,790 --> 00:08:50,760
working in this environment

00:08:49,199 --> 00:08:52,829
all the way on the right you might have

00:08:50,760 --> 00:08:53,850
something like a system daemon which it

00:08:52,829 --> 00:08:54,990
was running persistently in the

00:08:53,850 --> 00:08:55,670
background forever and you don't even

00:08:54,990 --> 00:08:58,070
interact with

00:08:55,670 --> 00:08:58,880
as an end user somewhere in the middle

00:08:58,070 --> 00:09:00,830
you might have something like a web

00:08:58,880 --> 00:09:02,210
service where you know the server is

00:09:00,830 --> 00:09:03,470
running somewhere but at least you can

00:09:02,210 --> 00:09:05,840
interact with the program sort of

00:09:03,470 --> 00:09:07,520
indirectly by you know it feeds you a UI

00:09:05,840 --> 00:09:09,680
or you can make requests to it or

00:09:07,520 --> 00:09:11,030
something like that and then sort of

00:09:09,680 --> 00:09:12,110
further on the repple spectrum is

00:09:11,030 --> 00:09:14,930
something like the jupiter notebook

00:09:12,110 --> 00:09:16,640
where the workflow is an awful lot like

00:09:14,930 --> 00:09:18,560
what you're doing in a Ruppel but you

00:09:16,640 --> 00:09:20,570
have kind of a persistent long

00:09:18,560 --> 00:09:22,400
long-standing document that's a record

00:09:20,570 --> 00:09:24,260
of the work that you've done and so

00:09:22,400 --> 00:09:25,190
python kind of spans this whole spectrum

00:09:24,260 --> 00:09:27,170
of the different kinds of work that

00:09:25,190 --> 00:09:28,490
people do with the language and that

00:09:27,170 --> 00:09:31,640
that affects the way that they think

00:09:28,490 --> 00:09:33,320
about and work in the language so I want

00:09:31,640 --> 00:09:35,450
to point out some particular features

00:09:33,320 --> 00:09:36,920
that I notice at least when I'm doing

00:09:35,450 --> 00:09:38,270
interactive development and in contrast

00:09:36,920 --> 00:09:40,070
them to the kinds of things that I

00:09:38,270 --> 00:09:41,840
noticed when I'm doing non interactive

00:09:40,070 --> 00:09:44,720
development so what I'm doing

00:09:41,840 --> 00:09:46,210
interactive development most often I

00:09:44,720 --> 00:09:48,110
find that the things that I'm doing are

00:09:46,210 --> 00:09:49,790
independent of code that I've written

00:09:48,110 --> 00:09:51,620
previously if I'm if I'm loading up a

00:09:49,790 --> 00:09:53,090
Jupiter notebook or I'm loading up a

00:09:51,620 --> 00:09:55,010
repple you know I'm not necessarily

00:09:53,090 --> 00:09:56,660
building on a large corpus of code that

00:09:55,010 --> 00:09:58,430
exists that it existed previously I'm

00:09:56,660 --> 00:09:59,930
you know taking the new data that just

00:09:58,430 --> 00:10:00,860
showed up today and pulling it in and

00:09:59,930 --> 00:10:04,670
trying to understand what's wrong with

00:10:00,860 --> 00:10:06,320
it or you know I'm trying to understand

00:10:04,670 --> 00:10:08,180
like the logs coming out of my machine

00:10:06,320 --> 00:10:09,140
but it's sort of independent little

00:10:08,180 --> 00:10:11,000
units of code and they're not

00:10:09,140 --> 00:10:14,300
necessarily part of a long persistent

00:10:11,000 --> 00:10:15,590
large code base another I think sort of

00:10:14,300 --> 00:10:17,720
distinctive feature of interactive

00:10:15,590 --> 00:10:19,610
element is that the author the end user

00:10:17,720 --> 00:10:20,930
and the operator of code that's written

00:10:19,610 --> 00:10:23,000
interactively are often all the same

00:10:20,930 --> 00:10:23,990
person so you know obviously I'm the one

00:10:23,000 --> 00:10:25,850
writing the code when I'm doing

00:10:23,990 --> 00:10:27,440
interactive work I'm also the one who's

00:10:25,850 --> 00:10:29,480
gonna consume the outputs of my code

00:10:27,440 --> 00:10:31,190
most of the time and I'm also the only

00:10:29,480 --> 00:10:32,450
one sort of operating or having to work

00:10:31,190 --> 00:10:34,280
with the code that I'm writing there and

00:10:32,450 --> 00:10:35,410
that's gonna be in contrast to some of

00:10:34,280 --> 00:10:37,550
other things I'm going to talk about

00:10:35,410 --> 00:10:38,450
another I think really important thing

00:10:37,550 --> 00:10:40,250
is that when you're doing interactive

00:10:38,450 --> 00:10:41,930
result or interactive work your results

00:10:40,250 --> 00:10:44,060
are directly visible to you right so you

00:10:41,930 --> 00:10:46,940
run a piece of code you do PD dot you

00:10:44,060 --> 00:10:48,200
know group by dot whatever indexing with

00:10:46,940 --> 00:10:49,400
something and you immediately get to see

00:10:48,200 --> 00:10:51,200
the result and if it's something you

00:10:49,400 --> 00:10:53,180
didn't expect you can immediately look

00:10:51,200 --> 00:10:55,910
at that and see and try to understand

00:10:53,180 --> 00:10:57,620
you know more directly well what what

00:10:55,910 --> 00:10:59,300
what went wrong in that computation but

00:10:57,620 --> 00:11:01,160
you have this immediate feedback loop of

00:10:59,300 --> 00:11:03,080
here's what I did here's what I got was

00:11:01,160 --> 00:11:06,290
it what I expected and then you can

00:11:03,080 --> 00:11:07,460
proceed from there sort of going along

00:11:06,290 --> 00:11:09,040
with the author and the end user the

00:11:07,460 --> 00:11:10,570
operator all being the same

00:11:09,040 --> 00:11:12,670
even in the case of notebook so you you

00:11:10,570 --> 00:11:13,870
don't because we still have things like

00:11:12,670 --> 00:11:15,430
notebooks you can have more than one

00:11:13,870 --> 00:11:16,960
author but in my experience you usually

00:11:15,430 --> 00:11:18,040
have relatively few authors you might

00:11:16,960 --> 00:11:19,690
have a couple people working on a

00:11:18,040 --> 00:11:21,730
notebook but you tend not to have you

00:11:19,690 --> 00:11:25,180
know a 30 person and engineering team

00:11:21,730 --> 00:11:26,590
working on a notebook and finally I

00:11:25,180 --> 00:11:27,550
think one of the key distinctive

00:11:26,590 --> 00:11:28,720
features of interactive element is that

00:11:27,550 --> 00:11:29,710
you often don't know what it is that

00:11:28,720 --> 00:11:31,510
you're building when you're doing

00:11:29,710 --> 00:11:32,860
interactive work and part of one of the

00:11:31,510 --> 00:11:34,060
advantages of interactive work is

00:11:32,860 --> 00:11:35,980
because of things like the direct

00:11:34,060 --> 00:11:38,140
feedback that you get it's really useful

00:11:35,980 --> 00:11:39,940
mode of development when you're trying

00:11:38,140 --> 00:11:41,560
to explore what it is that you're trying

00:11:39,940 --> 00:11:43,090
to do to begin with before you actually

00:11:41,560 --> 00:11:46,240
go and do sort of more traditional

00:11:43,090 --> 00:11:47,670
development um so I want to contrast

00:11:46,240 --> 00:11:51,310
some of the things that I just said with

00:11:47,670 --> 00:11:54,300
application development so where as an

00:11:51,310 --> 00:11:57,220
interactive work we're mostly sort of

00:11:54,300 --> 00:11:58,690
creating new work from full cloth most

00:11:57,220 --> 00:12:00,850
application development in my experience

00:11:58,690 --> 00:12:02,710
is modifying an existing code base where

00:12:00,850 --> 00:12:04,690
you have some long-running you know

00:12:02,710 --> 00:12:07,720
server project or some long-running

00:12:04,690 --> 00:12:08,890
library and you're adding new things to

00:12:07,720 --> 00:12:09,970
that you're changing things that are

00:12:08,890 --> 00:12:11,560
you're fixing bugs in that but you're

00:12:09,970 --> 00:12:14,290
making changes within the context of an

00:12:11,560 --> 00:12:15,670
existing code base going along with that

00:12:14,290 --> 00:12:17,620
the author and the end user and the

00:12:15,670 --> 00:12:19,930
operator often are usually not the same

00:12:17,620 --> 00:12:20,880
person for a traditional application one

00:12:19,930 --> 00:12:23,020
person is going to write the code

00:12:20,880 --> 00:12:24,640
another person is going to be the person

00:12:23,020 --> 00:12:25,750
actually interacting with that code when

00:12:24,640 --> 00:12:27,700
it's running in the wild so if I write a

00:12:25,750 --> 00:12:29,200
web server for example it's usually so

00:12:27,700 --> 00:12:31,660
that someone else can see the web pages

00:12:29,200 --> 00:12:33,040
served by that server and finally that

00:12:31,660 --> 00:12:34,780
usually a third person is the person

00:12:33,040 --> 00:12:36,310
who's actually going to deploy that

00:12:34,780 --> 00:12:39,130
server into production and is going to

00:12:36,310 --> 00:12:41,950
monitor it and you know yell at me at

00:12:39,130 --> 00:12:43,480
2:00 a.m. if it breaks or you know watch

00:12:41,950 --> 00:12:44,650
the logs and gather metrics and do all

00:12:43,480 --> 00:12:45,790
the things that you know actually have

00:12:44,650 --> 00:12:50,320
to happen to make sure that the server

00:12:45,790 --> 00:12:51,820
continues to run in production another

00:12:50,320 --> 00:12:54,130
feature of application moment is that

00:12:51,820 --> 00:12:55,240
our results or our sort of intermediate

00:12:54,130 --> 00:12:56,950
results as the application is running

00:12:55,240 --> 00:12:58,630
are not directly visible to us and the

00:12:56,950 --> 00:12:59,830
way that they are in a repple so you

00:12:58,630 --> 00:13:00,940
know we can log things in our

00:12:59,830 --> 00:13:02,680
application but then someone has to

00:13:00,940 --> 00:13:03,850
actually go look at the logs there's not

00:13:02,680 --> 00:13:05,650
a person sort of sitting there

00:13:03,850 --> 00:13:07,540
constantly tale I hope at least there's

00:13:05,650 --> 00:13:09,730
no one sitting there constantly tailing

00:13:07,540 --> 00:13:12,010
the logs of your servers to see you know

00:13:09,730 --> 00:13:13,510
what the intermediate value of X was in

00:13:12,010 --> 00:13:17,740
every single function in your

00:13:13,510 --> 00:13:19,840
application we also as part of the idea

00:13:17,740 --> 00:13:21,640
of modifying existing work we really

00:13:19,840 --> 00:13:22,120
have many authors for first Anolon

00:13:21,640 --> 00:13:23,650
application

00:13:22,120 --> 00:13:25,630
and that changes some of the things that

00:13:23,650 --> 00:13:27,100
we care about and finally we generally

00:13:25,630 --> 00:13:28,540
know ahead of time what it is that we're

00:13:27,100 --> 00:13:30,240
building if we're at the point where we

00:13:28,540 --> 00:13:32,230
want to create you know a standalone

00:13:30,240 --> 00:13:33,880
traditional application we usually know

00:13:32,230 --> 00:13:38,020
more or less what it is that we're

00:13:33,880 --> 00:13:40,240
building and so because of these

00:13:38,020 --> 00:13:41,950
features that I talked about I'm gonna

00:13:40,240 --> 00:13:44,560
claim that we care about we have

00:13:41,950 --> 00:13:45,670
different software values when we're

00:13:44,560 --> 00:13:47,170
developing these different kinds of

00:13:45,670 --> 00:13:49,480
applications or these different kinds of

00:13:47,170 --> 00:13:50,860
code so what are the things that I care

00:13:49,480 --> 00:13:52,960
about when I'm building an application

00:13:50,860 --> 00:13:53,820
so probably first and foremost the

00:13:52,960 --> 00:13:56,050
things that I care about is

00:13:53,820 --> 00:13:57,850
maintainability of that application and

00:13:56,050 --> 00:13:59,860
by that what I mean is essentially how

00:13:57,850 --> 00:14:01,620
easily can I change the application and

00:13:59,860 --> 00:14:04,690
be confident that that change is correct

00:14:01,620 --> 00:14:06,220
and sort of the the corollary that is

00:14:04,690 --> 00:14:07,570
how how come phenomena that someone else

00:14:06,220 --> 00:14:09,550
can also come along and change that

00:14:07,570 --> 00:14:12,460
application and I can be confident that

00:14:09,550 --> 00:14:13,390
their change is correct another

00:14:12,460 --> 00:14:14,920
important thing that goes along with

00:14:13,390 --> 00:14:16,900
maintainability is testability so how

00:14:14,920 --> 00:14:18,370
easily can I test individual components

00:14:16,900 --> 00:14:19,870
of my application in isolation

00:14:18,370 --> 00:14:21,190
can I run the application without access

00:14:19,870 --> 00:14:22,750
to production systems can I do without

00:14:21,190 --> 00:14:24,279
access to the Internet even that's a

00:14:22,750 --> 00:14:25,570
really nice feature to have for an

00:14:24,279 --> 00:14:28,150
application that you're trying to test

00:14:25,570 --> 00:14:29,620
in a comprehensive way and finally sort

00:14:28,150 --> 00:14:33,490
of how long does it take to do all that

00:14:29,620 --> 00:14:35,470
can be very important again sort of oh

00:14:33,490 --> 00:14:37,150
these are these values aren't totally

00:14:35,470 --> 00:14:38,560
orthogonal in a lot of cases but they

00:14:37,150 --> 00:14:41,230
build on one another and they reinforce

00:14:38,560 --> 00:14:42,790
one another so another piece of this is

00:14:41,230 --> 00:14:44,230
modularity so how easily can I replace

00:14:42,790 --> 00:14:46,150
different components of the application

00:14:44,230 --> 00:14:47,709
can I swap out my database for a

00:14:46,150 --> 00:14:49,120
different database or can I swap out my

00:14:47,709 --> 00:14:51,279
logging engine for another long engine

00:14:49,120 --> 00:14:53,200
something like that and how easy can I

00:14:51,279 --> 00:14:54,670
reuse components of my application in

00:14:53,200 --> 00:14:57,270
the context of another application or in

00:14:54,670 --> 00:14:59,410
another part of the application

00:14:57,270 --> 00:15:02,560
robustness how well does my application

00:14:59,410 --> 00:15:03,400
handle errors or unexpected errors or

00:15:02,560 --> 00:15:05,529
even how well does the application

00:15:03,400 --> 00:15:07,690
detect that they were unexpected errors

00:15:05,529 --> 00:15:09,730
or unexpected inputs and that's that's a

00:15:07,690 --> 00:15:11,620
little bit of a different virtue than

00:15:09,730 --> 00:15:12,610
handling unexpected errors is realizing

00:15:11,620 --> 00:15:13,180
that there's unexpected input in the

00:15:12,610 --> 00:15:14,920
first place

00:15:13,180 --> 00:15:17,020
I mean this can have the implications

00:15:14,920 --> 00:15:18,910
for things like security where one form

00:15:17,020 --> 00:15:22,810
of unexpected or erroneous inputs are

00:15:18,910 --> 00:15:25,060
explicitly malicious inputs and finally

00:15:22,810 --> 00:15:27,970
operability how easy for is it me is it

00:15:25,060 --> 00:15:31,000
to deploy or upgrade my application how

00:15:27,970 --> 00:15:32,589
easy can a non-expert see that something

00:15:31,000 --> 00:15:33,850
has gone wrong with my application who

00:15:32,589 --> 00:15:35,710
didn't work on that application and

00:15:33,850 --> 00:15:38,740
realize that something's gone wrong and

00:15:35,710 --> 00:15:40,090
and recover from failures and one more

00:15:38,740 --> 00:15:43,180
thing is performance and performance

00:15:40,090 --> 00:15:44,800
isn't necessarily solely the purview I

00:15:43,180 --> 00:15:46,840
think of applications as distinguished

00:15:44,800 --> 00:15:48,880
from interactive use but I think we care

00:15:46,840 --> 00:15:51,970
about performance in different ways for

00:15:48,880 --> 00:15:54,610
for interactive use versus application

00:15:51,970 --> 00:15:55,900
development where you know if I if I

00:15:54,610 --> 00:15:57,160
have something that takes 150

00:15:55,900 --> 00:15:59,590
milliseconds interactively that's

00:15:57,160 --> 00:16:00,940
basically free for me but if I'm doing

00:15:59,590 --> 00:16:02,260
something that takes 150 milliseconds

00:16:00,940 --> 00:16:03,850
10,000 times in a loop in my application

00:16:02,260 --> 00:16:05,260
now I'd not care about that quite a lot

00:16:03,850 --> 00:16:07,000
so the ways that we care about

00:16:05,260 --> 00:16:10,210
performance can often change between

00:16:07,000 --> 00:16:11,290
different kinds of applications so again

00:16:10,210 --> 00:16:12,460
to contrast that what are the things

00:16:11,290 --> 00:16:14,380
that I care about when I'm working

00:16:12,460 --> 00:16:17,710
interactively so I think sort of the

00:16:14,380 --> 00:16:18,760
thing that I care about most is it's

00:16:17,710 --> 00:16:20,560
kind of a silly thing but it's actually

00:16:18,760 --> 00:16:22,630
like how easy is it for me to physically

00:16:20,560 --> 00:16:24,820
type the things that I want to do like

00:16:22,630 --> 00:16:27,580
can I get the ideas out of my brain and

00:16:24,820 --> 00:16:28,810
onto the page you know as quickly as

00:16:27,580 --> 00:16:30,310
possible and with and with as little

00:16:28,810 --> 00:16:32,620
friction as possible and part of that is

00:16:30,310 --> 00:16:34,810
just you know is the API super verbose

00:16:32,620 --> 00:16:36,700
does it require me to think about you

00:16:34,810 --> 00:16:37,840
know things in a way I don't want to but

00:16:36,700 --> 00:16:39,310
another feature this that I think is

00:16:37,840 --> 00:16:40,750
often overlooked as things like how well

00:16:39,310 --> 00:16:43,000
does the library work with tools like

00:16:40,750 --> 00:16:45,640
autocomplete errs because is the tool or

00:16:43,000 --> 00:16:47,350
is the library amenable to being aided

00:16:45,640 --> 00:16:48,520
by whatever tools I can bring to my

00:16:47,350 --> 00:16:50,140
disposal I think this is one of the

00:16:48,520 --> 00:16:52,090
reasons why people who are aesthetic

00:16:50,140 --> 00:16:53,320
typing advocates for example one of the

00:16:52,090 --> 00:16:55,930
benefits that they'll tell from that is

00:16:53,320 --> 00:17:00,300
that statically typed languages can be

00:16:55,930 --> 00:17:02,320
aided by tools you know in in this way

00:17:00,300 --> 00:17:04,300
another interesting feature that I think

00:17:02,320 --> 00:17:05,830
I tend to care about more for

00:17:04,300 --> 00:17:08,050
interactive work versus application

00:17:05,830 --> 00:17:09,459
development is discoverability so how if

00:17:08,050 --> 00:17:10,510
I'm learning a new library or if I'm

00:17:09,459 --> 00:17:12,820
trying to do something in a new library

00:17:10,510 --> 00:17:15,160
interactively how easily can I find the

00:17:12,820 --> 00:17:16,750
things that I need and how how easily

00:17:15,160 --> 00:17:17,890
can I learn to use those things so

00:17:16,750 --> 00:17:19,300
there's one thing to sort of to get a

00:17:17,890 --> 00:17:21,550
listing of all the functions or all the

00:17:19,300 --> 00:17:24,010
classes available on a library but then

00:17:21,550 --> 00:17:26,740
also can I you know from just working

00:17:24,010 --> 00:17:28,450
with the application can I are working

00:17:26,740 --> 00:17:31,180
with the library can I get documentation

00:17:28,450 --> 00:17:33,010
or can I can the API design teach me how

00:17:31,180 --> 00:17:34,960
to use the language or how to use the

00:17:33,010 --> 00:17:36,460
library just in virtue of say the names

00:17:34,960 --> 00:17:39,400
of the functions or the the names of

00:17:36,460 --> 00:17:40,540
classes or what what it does and can I

00:17:39,400 --> 00:17:41,860
do all those things without disrupting

00:17:40,540 --> 00:17:43,300
my train of thought so obviously we can

00:17:41,860 --> 00:17:45,190
always have you know externally hosted

00:17:43,300 --> 00:17:47,530
documentation but especially for

00:17:45,190 --> 00:17:49,180
interactive work if I can learn these

00:17:47,530 --> 00:17:49,670
things if the tool can teach itself to

00:17:49,180 --> 00:17:51,200
me with

00:17:49,670 --> 00:17:53,270
me having to break my train of thought

00:17:51,200 --> 00:17:57,290
and go somewhere else that can be really

00:17:53,270 --> 00:17:58,190
valuable another thing that I care about

00:17:57,290 --> 00:17:59,990
when I'm working interactively is

00:17:58,190 --> 00:18:01,910
flexibility so usually when I'm doing

00:17:59,990 --> 00:18:03,590
interactive work I'm doing sort of a new

00:18:01,910 --> 00:18:05,420
but slightly different thing every time

00:18:03,590 --> 00:18:08,030
and so a thing that's valuable to me is

00:18:05,420 --> 00:18:10,310
to be able to tweak and reuse the tool

00:18:08,030 --> 00:18:12,410
in different ways things like you know

00:18:10,310 --> 00:18:14,810
I'm loading a file that has a different

00:18:12,410 --> 00:18:16,670
delimiter or you know I'm I wanna be

00:18:14,810 --> 00:18:20,720
able to move move around where things

00:18:16,670 --> 00:18:22,160
are on disk in general because when I'm

00:18:20,720 --> 00:18:23,300
doing interactive work I don't know what

00:18:22,160 --> 00:18:24,590
it is that I'm doing ahead of time it's

00:18:23,300 --> 00:18:26,900
use it's important for the tool to be

00:18:24,590 --> 00:18:30,320
able to adapt to whatever whatever needs

00:18:26,900 --> 00:18:31,850
that I have kind of going along with

00:18:30,320 --> 00:18:33,560
with ergonomic saz this notion of

00:18:31,850 --> 00:18:35,420
intuitive it so does the libraries model

00:18:33,560 --> 00:18:36,980
of its domain match my mental model and

00:18:35,420 --> 00:18:38,060
again this is this is useful everywhere

00:18:36,980 --> 00:18:39,890
all of these things that I'm going to

00:18:38,060 --> 00:18:41,440
talk about both for application

00:18:39,890 --> 00:18:44,150
development and interactive moment are

00:18:41,440 --> 00:18:46,730
important across both context but I

00:18:44,150 --> 00:18:48,530
think they're more or less important in

00:18:46,730 --> 00:18:50,540
different context depending on what it

00:18:48,530 --> 00:18:52,520
is that we're doing so I might be if a

00:18:50,540 --> 00:18:54,350
library has kind of a weird way of

00:18:52,520 --> 00:18:55,880
modeling its domain when I'm doing

00:18:54,350 --> 00:18:57,530
interactive element I'm usually not

00:18:55,880 --> 00:18:58,850
working with that library all that often

00:18:57,530 --> 00:18:59,960
and it's not that big of a deal or I can

00:18:58,850 --> 00:19:00,890
sort of stash it behind a helper

00:18:59,960 --> 00:19:02,630
function and I have to think about

00:19:00,890 --> 00:19:04,550
anymore if I'm working with the library

00:19:02,630 --> 00:19:06,080
regularly interactively I have to be

00:19:04,550 --> 00:19:07,400
sort of constantly interacting with this

00:19:06,080 --> 00:19:09,560
thing that doesn't match my mental model

00:19:07,400 --> 00:19:10,580
so I think that becomes more important

00:19:09,560 --> 00:19:14,180
to me when I'm doing interactive

00:19:10,580 --> 00:19:17,030
development so so to kind of summarize

00:19:14,180 --> 00:19:19,040
the the contrast there when I'm working

00:19:17,030 --> 00:19:20,930
on an application I find that I'm mostly

00:19:19,040 --> 00:19:22,730
concerned with minimizing the long-term

00:19:20,930 --> 00:19:25,700
costs of maintaining and operating the

00:19:22,730 --> 00:19:27,860
application and in contrast to that when

00:19:25,700 --> 00:19:29,450
I'm working interactively I'm mostly

00:19:27,860 --> 00:19:31,820
concerned with essentially getting ideas

00:19:29,450 --> 00:19:33,670
out of my brain as quickly as possible

00:19:31,820 --> 00:19:36,680
and with as little friction as possible

00:19:33,670 --> 00:19:38,420
and those aren't by themselves

00:19:36,680 --> 00:19:40,730
inherently intention but what I want to

00:19:38,420 --> 00:19:41,990
what I want to claim is that often in

00:19:40,730 --> 00:19:44,780
practice when we're making design

00:19:41,990 --> 00:19:47,060
decisions in our code were we're forced

00:19:44,780 --> 00:19:48,590
to make choices about which of these

00:19:47,060 --> 00:19:52,460
values we're going to prioritize in the

00:19:48,590 --> 00:19:53,810
given decision right so when it's often

00:19:52,460 --> 00:19:54,920
the case that design decisions force us

00:19:53,810 --> 00:20:00,440
to choose between these conflicting

00:19:54,920 --> 00:20:01,820
values and I think we we tend to make

00:20:00,440 --> 00:20:02,870
these decisions sort of implicitly or

00:20:01,820 --> 00:20:05,570
automatically without thinking

00:20:02,870 --> 00:20:06,830
them carefully and so I want to and and

00:20:05,570 --> 00:20:08,390
this can make it harder for us to

00:20:06,830 --> 00:20:10,100
understand why people disagree with us

00:20:08,390 --> 00:20:11,900
if we if someone doesn't like the way we

00:20:10,100 --> 00:20:13,100
wrote an application it's easy to just

00:20:11,900 --> 00:20:14,120
say a lot that person is wrong right

00:20:13,100 --> 00:20:15,170
that person doesn't understand what

00:20:14,120 --> 00:20:17,720
they're doing or that person is a bad

00:20:15,170 --> 00:20:20,120
bad program or a bad engineer and I

00:20:17,720 --> 00:20:21,350
think more often it's the case that when

00:20:20,120 --> 00:20:22,820
we disagree with one another it's

00:20:21,350 --> 00:20:24,200
usually because we disagree over what's

00:20:22,820 --> 00:20:27,200
important or what's valuable about the

00:20:24,200 --> 00:20:28,460
software that we're writing so I want to

00:20:27,200 --> 00:20:31,580
talk through a couple cases where I

00:20:28,460 --> 00:20:34,640
think trade offs or design decisions

00:20:31,580 --> 00:20:36,440
that we make in our software can sort of

00:20:34,640 --> 00:20:37,640
benefit or detract from some of the

00:20:36,440 --> 00:20:39,740
different values that I just talked

00:20:37,640 --> 00:20:41,090
about so one example that I think comes

00:20:39,740 --> 00:20:43,040
up a lot is optional arguments so

00:20:41,090 --> 00:20:45,380
optional arguments in Python allow you

00:20:43,040 --> 00:20:46,580
to ignore rarely needed parameters right

00:20:45,380 --> 00:20:47,630
I can have a function with a bunch of

00:20:46,580 --> 00:20:50,240
arguments or class with a bunch

00:20:47,630 --> 00:20:51,679
arguments and I can make it so that

00:20:50,240 --> 00:20:52,790
people don't need to pass those

00:20:51,679 --> 00:20:55,429
arguments unless they want to change

00:20:52,790 --> 00:20:57,200
something about the function so this is

00:20:55,429 --> 00:20:58,610
a win for ergonomics right I don't

00:20:57,200 --> 00:21:00,650
always have to pass this argument so

00:20:58,610 --> 00:21:02,270
it's less typing for me and it's also a

00:21:00,650 --> 00:21:03,770
win for flexibility it makes it easy for

00:21:02,270 --> 00:21:06,200
me to write a function with lots of wood

00:21:03,770 --> 00:21:07,760
lots of options and without sort of

00:21:06,200 --> 00:21:08,929
paying the ergonomic burden of someone

00:21:07,760 --> 00:21:11,809
having to pass lots of options to my

00:21:08,929 --> 00:21:13,309
function on the other hand this this is

00:21:11,809 --> 00:21:14,780
a loss for a lot of the things that I

00:21:13,309 --> 00:21:15,860
think we care about in application

00:21:14,780 --> 00:21:17,240
development so it can be a loss for a

00:21:15,860 --> 00:21:19,010
robustness and that if we have a

00:21:17,240 --> 00:21:19,970
function with many default arguments but

00:21:19,010 --> 00:21:22,790
some of those arguments are really

00:21:19,970 --> 00:21:24,440
important to get right then by having

00:21:22,790 --> 00:21:25,970
lots of defaults we can mask errors

00:21:24,440 --> 00:21:27,710
where when we refactor a piece of code

00:21:25,970 --> 00:21:29,750
and we forget to pass an argument if

00:21:27,710 --> 00:21:30,770
that argument were required then that

00:21:29,750 --> 00:21:31,940
would become a hard error and it would

00:21:30,770 --> 00:21:34,370
probably cause our test suite to fail

00:21:31,940 --> 00:21:36,140
but if we have a default then we can

00:21:34,370 --> 00:21:38,090
often sort of silently continue on and

00:21:36,140 --> 00:21:40,280
either fail in a more confusing waylay

00:21:38,090 --> 00:21:41,330
way later or even worse sort of get all

00:21:40,280 --> 00:21:43,880
the way to production before we realize

00:21:41,330 --> 00:21:45,470
something's gone wrong it can also be

00:21:43,880 --> 00:21:46,730
lost for testability so if we have a we

00:21:45,470 --> 00:21:48,740
have these you know big functions with

00:21:46,730 --> 00:21:49,760
lots of default arguments it's very hard

00:21:48,740 --> 00:21:51,230
for us to test all possible

00:21:49,760 --> 00:21:52,820
configurations of those functions and so

00:21:51,230 --> 00:21:55,370
it can be very hard for us to be sort of

00:21:52,820 --> 00:21:56,510
confident that all of the you know all

00:21:55,370 --> 00:21:58,250
the behaviors that we care about are

00:21:56,510 --> 00:22:00,380
correct and it can be lost for

00:21:58,250 --> 00:22:02,030
maintainability because often when we

00:22:00,380 --> 00:22:03,559
have defaults for some function we have

00:22:02,030 --> 00:22:05,120
sort of families of related functions

00:22:03,559 --> 00:22:06,710
that should share the same defaults and

00:22:05,120 --> 00:22:07,880
if we update one of those defaults we

00:22:06,710 --> 00:22:08,960
have to remember to go update all those

00:22:07,880 --> 00:22:10,160
different places and there's there's

00:22:08,960 --> 00:22:12,050
ways we can structure our code to get

00:22:10,160 --> 00:22:14,960
around that but it can be an extra

00:22:12,050 --> 00:22:16,310
mental tax on on how we have to think

00:22:14,960 --> 00:22:17,720
about and maintain that code

00:22:16,310 --> 00:22:20,150
and one more point I want to make about

00:22:17,720 --> 00:22:22,130
optional arguments is that having lots

00:22:20,150 --> 00:22:23,570
of options can often excu what the

00:22:22,130 --> 00:22:26,360
obscure what the expected production

00:22:23,570 --> 00:22:29,540
code path is for a piece of code we're

00:22:26,360 --> 00:22:31,460
actually in production mostly you know

00:22:29,540 --> 00:22:33,710
or always we're gonna run something in a

00:22:31,460 --> 00:22:36,050
particular way but for interactive usage

00:22:33,710 --> 00:22:37,910
or for sort of standalone other contexts

00:22:36,050 --> 00:22:40,040
we can run this with you know overridden

00:22:37,910 --> 00:22:41,150
defaults and so having all these

00:22:40,040 --> 00:22:43,070
defaults can actually make it hard for

00:22:41,150 --> 00:22:44,780
us to know how would we expect this to

00:22:43,070 --> 00:22:48,650
be called in particular context or in

00:22:44,780 --> 00:22:49,940
particular ways another example of a

00:22:48,650 --> 00:22:52,580
case where I think we often make

00:22:49,940 --> 00:22:54,320
trade-offs between interactive usage and

00:22:52,580 --> 00:22:56,210
application moment is with globally

00:22:54,320 --> 00:22:58,400
visible configuration so what I mean by

00:22:56,210 --> 00:23:00,650
that is configuration that essentially

00:22:58,400 --> 00:23:01,880
any part of your codebase can access

00:23:00,650 --> 00:23:04,340
without having to be passed it

00:23:01,880 --> 00:23:07,160
explicitly as a parameter and this is

00:23:04,340 --> 00:23:09,140
sort of the the inverse in some of the

00:23:07,160 --> 00:23:10,640
dual of optional parameters and that

00:23:09,140 --> 00:23:12,080
these are this allows us to aware as

00:23:10,640 --> 00:23:13,310
optional parameters allowed us to avoid

00:23:12,080 --> 00:23:15,620
passing things that we didn't usually

00:23:13,310 --> 00:23:16,850
want to pass global configuration that's

00:23:15,620 --> 00:23:18,370
available everywhere it allows us to not

00:23:16,850 --> 00:23:21,620
pass things that we always want to pass

00:23:18,370 --> 00:23:23,630
and that's useful as long as we really

00:23:21,620 --> 00:23:25,130
do always want to pass those things and

00:23:23,630 --> 00:23:26,570
that my experience turns out to be

00:23:25,130 --> 00:23:28,250
actually very rarely the true at least

00:23:26,570 --> 00:23:30,350
forever or very rarely true at least in

00:23:28,250 --> 00:23:31,670
application development so again this is

00:23:30,350 --> 00:23:33,740
wind for ergonomics right if I've got

00:23:31,670 --> 00:23:34,610
some big you know pile of data that

00:23:33,740 --> 00:23:36,620
needs to connect to three different

00:23:34,610 --> 00:23:37,970
databases and two file systems and needs

00:23:36,620 --> 00:23:39,800
of you know permissions and all these

00:23:37,970 --> 00:23:41,120
other things then if that's all in a

00:23:39,800 --> 00:23:42,440
config file that's just magically

00:23:41,120 --> 00:23:44,000
available to me then I don't have to

00:23:42,440 --> 00:23:46,490
type all that stuff out in my notebook

00:23:44,000 --> 00:23:47,870
or in my repple session but again it can

00:23:46,490 --> 00:23:49,130
be a loss for maintainability so it

00:23:47,870 --> 00:23:50,720
makes it harder for us to know what

00:23:49,130 --> 00:23:53,570
parts of our codebase depend on what

00:23:50,720 --> 00:23:55,430
external resources it can be a loss for

00:23:53,570 --> 00:23:57,920
testability because if functions all

00:23:55,430 --> 00:23:59,570
over our codebase are depending on sort

00:23:57,920 --> 00:24:01,490
of globally available configuration then

00:23:59,570 --> 00:24:03,170
if we want to test in isolation without

00:24:01,490 --> 00:24:04,550
talking to real production systems then

00:24:03,170 --> 00:24:05,930
we have to monkey patch those things or

00:24:04,550 --> 00:24:07,190
we have to have different versions of

00:24:05,930 --> 00:24:08,630
them it makes it harder for us to test

00:24:07,190 --> 00:24:10,220
things and be confident that we that our

00:24:08,630 --> 00:24:12,530
system works without talking to the real

00:24:10,220 --> 00:24:14,360
production system and it can be lost for

00:24:12,530 --> 00:24:15,830
modularity because it means that if I

00:24:14,360 --> 00:24:18,590
have a unit of code that depends on

00:24:15,830 --> 00:24:20,240
global configuration then I can't use

00:24:18,590 --> 00:24:21,680
that code unless I have that global

00:24:20,240 --> 00:24:22,880
configuration available so it's harder

00:24:21,680 --> 00:24:24,710
for me to move that piece of code to

00:24:22,880 --> 00:24:25,790
another part of my application or to a

00:24:24,710 --> 00:24:27,470
different application that doesn't

00:24:25,790 --> 00:24:29,639
provide the same set of global

00:24:27,470 --> 00:24:31,730
configuration

00:24:29,639 --> 00:24:34,950
so I'm an example of this it's actually

00:24:31,730 --> 00:24:38,789
taken from an internal project at quant

00:24:34,950 --> 00:24:41,610
OPM and people read that okay is that a

00:24:38,789 --> 00:24:43,470
reasonable file size right so on the

00:24:41,610 --> 00:24:45,389
Left I have a version of a function

00:24:43,470 --> 00:24:47,789
called get algo that was originally

00:24:45,389 --> 00:24:49,559
written in a notebook and essentially

00:24:47,789 --> 00:24:52,320
what this what this is doing is trying

00:24:49,559 --> 00:24:53,610
to load some results from an algorithm

00:24:52,320 --> 00:24:55,620
back test so it's an algorithm that's

00:24:53,610 --> 00:24:56,789
run it simulated placing a bunch of

00:24:55,620 --> 00:24:58,350
orders and then it's gonna fetch the

00:24:56,789 --> 00:25:00,480
performance metrics of that algorithm

00:24:58,350 --> 00:25:01,590
and we can see that this is like pulling

00:25:00,480 --> 00:25:03,210
things from a whole bunch of different

00:25:01,590 --> 00:25:04,950
external databases so we've got like a

00:25:03,210 --> 00:25:06,870
metadata database in a results database

00:25:04,950 --> 00:25:08,009
we've got a Cassandra database or

00:25:06,870 --> 00:25:09,590
something else you can tell the system's

00:25:08,009 --> 00:25:11,370
kind of grown organically over time

00:25:09,590 --> 00:25:12,870
we've got this thing called the data

00:25:11,370 --> 00:25:15,419
portal that provides an interface to all

00:25:12,870 --> 00:25:16,950
of our pricing data and this function

00:25:15,419 --> 00:25:18,690
that was sort of extracted out of a

00:25:16,950 --> 00:25:21,149
notebook was originally designed to be

00:25:18,690 --> 00:25:23,129
called both interactively and form sort

00:25:21,149 --> 00:25:25,169
of a long-running batch processing job

00:25:23,129 --> 00:25:26,669
and we can see that because that it's

00:25:25,169 --> 00:25:28,649
got all these default arguments where

00:25:26,669 --> 00:25:29,940
you don't have to pass all the different

00:25:28,649 --> 00:25:32,039
database connections to it and if you

00:25:29,940 --> 00:25:33,450
don't pass them that it'll go import a

00:25:32,039 --> 00:25:34,830
configuration object and make a new

00:25:33,450 --> 00:25:37,110
database connection and then it'll use

00:25:34,830 --> 00:25:38,730
that for the the context of the run and

00:25:37,110 --> 00:25:40,259
that's really useful when you're using

00:25:38,730 --> 00:25:41,759
this interactively in a notebook where I

00:25:40,259 --> 00:25:43,470
just want to say you know here's here's

00:25:41,759 --> 00:25:45,230
the ID please fetch these results for me

00:25:43,470 --> 00:25:48,090
and let me let me analyze this back test

00:25:45,230 --> 00:25:50,340
but it can make it really hard to test

00:25:48,090 --> 00:25:51,929
this function reliably because if I ever

00:25:50,340 --> 00:25:54,000
accidentally forget to pass one of these

00:25:51,929 --> 00:25:55,950
arguments this thing's gonna immediately

00:25:54,000 --> 00:25:57,330
grab the configuration often from my

00:25:55,950 --> 00:25:58,230
local developer credentials which means

00:25:57,330 --> 00:26:00,240
I can accidentally end up running

00:25:58,230 --> 00:26:02,159
against you know an externally shared

00:26:00,240 --> 00:26:03,480
system which fortunately this is

00:26:02,159 --> 00:26:04,950
read-only in this case so the worst case

00:26:03,480 --> 00:26:06,570
scenario there isn't too bad but you

00:26:04,950 --> 00:26:07,590
know you hear horror stories every now

00:26:06,570 --> 00:26:09,090
and then where someone runs their test

00:26:07,590 --> 00:26:10,799
suite against a production system or a

00:26:09,090 --> 00:26:13,409
staging system and then their test suite

00:26:10,799 --> 00:26:15,240
teardown runs and I drop the database so

00:26:13,409 --> 00:26:16,500
you wanna if you're a paranoid about

00:26:15,240 --> 00:26:17,940
these things and you should be paranoid

00:26:16,500 --> 00:26:19,230
about these things you want to make it

00:26:17,940 --> 00:26:20,940
really hard to accidentally run your

00:26:19,230 --> 00:26:22,110
test suite against production systems

00:26:20,940 --> 00:26:23,759
and one of the best ways you can do that

00:26:22,110 --> 00:26:24,809
is make your test suite totally

00:26:23,759 --> 00:26:26,429
independent of whatever sort of

00:26:24,809 --> 00:26:30,450
developer level level configuration you

00:26:26,429 --> 00:26:31,620
have and so anyway so this is a system

00:26:30,450 --> 00:26:33,210
that was developed you know

00:26:31,620 --> 00:26:34,919
interactively in prototype and then

00:26:33,210 --> 00:26:37,200
eventually it got sort of moved into a

00:26:34,919 --> 00:26:38,700
more robust production setting and on

00:26:37,200 --> 00:26:40,139
the right you can see what ended up

00:26:38,700 --> 00:26:41,250
happening happening to this function so

00:26:40,139 --> 00:26:42,450
the first thing you'll notice is has got

00:26:41,250 --> 00:26:44,159
no default arguments anymore

00:26:42,450 --> 00:26:46,080
and the second thing you noticed that

00:26:44,159 --> 00:26:47,489
the actual direct database connections

00:26:46,080 --> 00:26:49,049
have been sort of abstracted behind

00:26:47,489 --> 00:26:50,970
these like reader objects and now we

00:26:49,049 --> 00:26:52,499
don't just work directly with the

00:26:50,970 --> 00:26:54,570
database we've got like a metadata

00:26:52,499 --> 00:26:57,090
reader and a back test results reader

00:26:54,570 --> 00:26:58,470
and those can be swapped out with you

00:26:57,090 --> 00:27:00,840
know real database connections or sort

00:26:58,470 --> 00:27:03,330
of mock and memory versions of them and

00:27:00,840 --> 00:27:04,980
they allow us to write programs against

00:27:03,330 --> 00:27:06,899
these interfaces without having to sort

00:27:04,980 --> 00:27:08,730
of have direct connections to the

00:27:06,899 --> 00:27:11,129
databases and so I think this is sort of

00:27:08,730 --> 00:27:13,350
a useful example of cases where designs

00:27:11,129 --> 00:27:14,850
that where you're useful and helpful and

00:27:13,350 --> 00:27:17,549
productive for initial interactive

00:27:14,850 --> 00:27:18,659
development sort of where liability when

00:27:17,549 --> 00:27:20,129
we had to take them into production and

00:27:18,659 --> 00:27:23,119
so we ended up having to make

00:27:20,129 --> 00:27:26,369
substantial changes of the code so

00:27:23,119 --> 00:27:29,129
that's one example another case where I

00:27:26,369 --> 00:27:32,850
think we often find ourselves running

00:27:29,129 --> 00:27:34,590
into challenges that are or running into

00:27:32,850 --> 00:27:35,970
tricky design questions because of the

00:27:34,590 --> 00:27:38,399
tension between interactive and non

00:27:35,970 --> 00:27:40,139
interactive code is what should we do

00:27:38,399 --> 00:27:42,509
when there's an ambiguous input to one

00:27:40,139 --> 00:27:44,730
of our functions and the Zen of Python

00:27:42,509 --> 00:27:45,809
is sort of this whole Zen Zen koan that

00:27:44,730 --> 00:27:47,639
comes with the language and one of the

00:27:45,809 --> 00:27:49,649
lines in the Zen of Python is in the

00:27:47,639 --> 00:27:52,169
face of ambiguity reviews the temptation

00:27:49,649 --> 00:27:53,759
to guess and I sort of particularly like

00:27:52,169 --> 00:27:55,590
the the phrase of the temptation to

00:27:53,759 --> 00:27:57,539
guess here because it feels like you're

00:27:55,590 --> 00:27:59,220
doing a good thing for your user we're

00:27:57,539 --> 00:28:01,080
just like oh I I knew what you meant

00:27:59,220 --> 00:28:02,639
when when you pass me a string instead

00:28:01,080 --> 00:28:04,139
of an integer and so I'm just gonna you

00:28:02,639 --> 00:28:05,759
know call int on the string before I do

00:28:04,139 --> 00:28:09,720
whatever else whatever else I did with

00:28:05,759 --> 00:28:11,759
it and so I think I'm not totally sure

00:28:09,720 --> 00:28:13,950
why this is the case but I I think it's

00:28:11,759 --> 00:28:15,899
often the case that the temptation to

00:28:13,950 --> 00:28:17,730
guess becomes really strong for code

00:28:15,899 --> 00:28:19,440
that's used interactively I think it's

00:28:17,730 --> 00:28:22,320
because as a user you're looking at a

00:28:19,440 --> 00:28:25,200
piece of code and you see you know get

00:28:22,320 --> 00:28:26,970
index of the string 2014 and you're like

00:28:25,200 --> 00:28:29,369
you knew what I meant there because

00:28:26,970 --> 00:28:30,480
you're looking at it right there but and

00:28:29,369 --> 00:28:31,859
you're not thinking about how in the

00:28:30,480 --> 00:28:33,299
context of a larger system that can

00:28:31,859 --> 00:28:36,119
accidentally sort of mask errors or

00:28:33,299 --> 00:28:38,070
cause unexpected outputs to happen

00:28:36,119 --> 00:28:40,470
so from an interactive users perspective

00:28:38,070 --> 00:28:41,789
it sort of feels pedantic for a piece of

00:28:40,470 --> 00:28:43,409
code to throw an error on an unexpected

00:28:41,789 --> 00:28:45,899
input that seems like it has sort of an

00:28:43,409 --> 00:28:47,220
obvious interpretation and so sort of

00:28:45,899 --> 00:28:49,259
every user is like come on you know what

00:28:47,220 --> 00:28:51,409
I mean here when when I passed you you

00:28:49,259 --> 00:28:54,450
know the string instead of the integer

00:28:51,409 --> 00:28:55,740
but we see libraries all over the place

00:28:54,450 --> 00:28:59,190
you know who

00:28:55,740 --> 00:29:01,730
have in the name of convenience you know

00:28:59,190 --> 00:29:04,559
given in to the temptation to guess say

00:29:01,730 --> 00:29:07,470
so an example that I worked with quite a

00:29:04,559 --> 00:29:10,679
lot is pandas so and I by the way and in

00:29:07,470 --> 00:29:13,140
all these examples I I'll talk about

00:29:10,679 --> 00:29:15,630
this later actually I want to say I'm

00:29:13,140 --> 00:29:19,100
not denigrating pandas or trying to dunk

00:29:15,630 --> 00:29:21,300
on pandas I use pandas enough that I've

00:29:19,100 --> 00:29:23,510
gotten angry at it and that means it's

00:29:21,300 --> 00:29:26,929
solved real problems for me

00:29:23,510 --> 00:29:29,760
but anyway so as an example of this

00:29:26,929 --> 00:29:30,990
pandas has a data frame class and if I

00:29:29,760 --> 00:29:33,480
have a data frame here and I can have a

00:29:30,990 --> 00:29:35,010
date time index and usually the way that

00:29:33,480 --> 00:29:38,220
you get values out of a date time index

00:29:35,010 --> 00:29:44,910
is you do like DF lok of PG dot

00:29:38,220 --> 00:29:46,470
timestamp you know 2014 o 102 and that

00:29:44,910 --> 00:29:48,330
says give me the values associated with

00:29:46,470 --> 00:29:51,120
the row with that index and that's great

00:29:48,330 --> 00:29:52,980
that's super useful but it also has this

00:29:51,120 --> 00:29:54,660
sort of interesting behavior that I can

00:29:52,980 --> 00:29:58,800
do you know just look up with a string

00:29:54,660 --> 00:30:00,120
right so I can do 2014 Oh 102 and I'll

00:29:58,800 --> 00:30:01,440
get that same result so I didn't have to

00:30:00,120 --> 00:30:03,179
give it a timestamp I can give it a

00:30:01,440 --> 00:30:04,800
string and it says oh okay that probably

00:30:03,179 --> 00:30:08,280
means what you wanted was the timestamp

00:30:04,800 --> 00:30:09,840
of that string that's not too bad like I

00:30:08,280 --> 00:30:11,040
you know I don't feel too bad about it

00:30:09,840 --> 00:30:12,240
doing that and that's it's super

00:30:11,040 --> 00:30:14,070
convenient in the repple when you've got

00:30:12,240 --> 00:30:15,960
a data frame and it's you know annoying

00:30:14,070 --> 00:30:18,630
to have to type a PD timestamp of all

00:30:15,960 --> 00:30:20,370
this thing all over the place but it

00:30:18,630 --> 00:30:23,309
gets even more convenient actually so I

00:30:20,370 --> 00:30:24,600
can do P that timestamp 2014 oh 1 and

00:30:23,309 --> 00:30:27,929
that says give me all the things for

00:30:24,600 --> 00:30:29,460
just the month of January which again if

00:30:27,929 --> 00:30:31,050
you know that's if that's what you meant

00:30:29,460 --> 00:30:33,480
and that's what you wanted it to do this

00:30:31,050 --> 00:30:34,500
is super convenient and super useful and

00:30:33,480 --> 00:30:36,390
you can even all the way go all the way

00:30:34,500 --> 00:30:39,559
back to 2014 just a year and that says

00:30:36,390 --> 00:30:41,460
give me all the values from this year so

00:30:39,559 --> 00:30:42,510
when you're working interactively and

00:30:41,460 --> 00:30:44,670
this is what you meant is super

00:30:42,510 --> 00:30:46,500
convenient I have personally been bitten

00:30:44,670 --> 00:30:48,300
by this behavior at least twice where I

00:30:46,500 --> 00:30:51,510
transpose two arguments in a function

00:30:48,300 --> 00:30:52,980
somewhere and I had a string and I had a

00:30:51,510 --> 00:30:54,270
timestamp and I passed the wrong one and

00:30:52,980 --> 00:30:55,530
then I got the wrong behavior and then I

00:30:54,270 --> 00:30:58,260
got a cryptic error message and it took

00:30:55,530 --> 00:31:00,210
me you know 15 20 minutes to debug that

00:30:58,260 --> 00:31:03,750
or whatever but I was you know briefly

00:31:00,210 --> 00:31:05,370
very confused about that another example

00:31:03,750 --> 00:31:08,910
that's that's I think more pernicious

00:31:05,370 --> 00:31:09,750
here actually is the behavior that

00:31:08,910 --> 00:31:12,400
pandas has

00:31:09,750 --> 00:31:14,280
coercion z' of different d types so for

00:31:12,400 --> 00:31:18,580
example i've got a data frame here and

00:31:14,280 --> 00:31:20,530
i've got a data frame with some integer

00:31:18,580 --> 00:31:21,850
columns in it right so the the data I've

00:31:20,530 --> 00:31:25,690
you know I've just got X and x squared

00:31:21,850 --> 00:31:28,300
from 0 to 10 or 0 to 9 and I've got 2 in

00:31:25,690 --> 00:31:30,070
64 arrays if you know kind of what pin

00:31:28,300 --> 00:31:31,810
is internal data model is you know that

00:31:30,070 --> 00:31:34,960
these basically boil down to sort of sea

00:31:31,810 --> 00:31:36,190
level 64-bit integers just laid out in

00:31:34,960 --> 00:31:37,960
memory right next to each other and one

00:31:36,190 --> 00:31:38,920
of the things that pandas and numpy that

00:31:37,960 --> 00:31:40,390
it's built on top and we're trying to do

00:31:38,920 --> 00:31:41,950
is enable really efficient

00:31:40,390 --> 00:31:44,740
high-performance computation with this

00:31:41,950 --> 00:31:46,480
kind of stuff and so that's that's all

00:31:44,740 --> 00:31:48,940
great that's all well and good so now

00:31:46,480 --> 00:31:50,710
what I'm gonna do is assign a value into

00:31:48,940 --> 00:31:53,230
a location in this array and so I've got

00:31:50,710 --> 00:31:54,520
you know I've for demonstration purposes

00:31:53,230 --> 00:31:56,620
here I've got ten values in this data

00:31:54,520 --> 00:31:59,260
frame but this could easily be you know

00:31:56,620 --> 00:32:00,970
ten thousand or ten million rows and now

00:31:59,260 --> 00:32:03,700
what I'm going to do is just assign a

00:32:00,970 --> 00:32:06,070
new integer a new integer into this

00:32:03,700 --> 00:32:08,650
array except I'm not going to assign an

00:32:06,070 --> 00:32:12,520
integer I'm gonna assign a float and so

00:32:08,650 --> 00:32:14,890
now if I assign 5.0 to this location in

00:32:12,520 --> 00:32:16,900
the data frame then what I'm gonna find

00:32:14,890 --> 00:32:20,920
is that the entire column has been

00:32:16,900 --> 00:32:21,820
coerced to float from ant and so what

00:32:20,920 --> 00:32:23,110
that means particular is that I've

00:32:21,820 --> 00:32:25,150
actually just now made it and made a

00:32:23,110 --> 00:32:26,620
copy of all of the data that I had there

00:32:25,150 --> 00:32:28,390
and so this was a huge data frame and I

00:32:26,620 --> 00:32:29,560
was doing this repeatedly this could

00:32:28,390 --> 00:32:31,330
become a really big performance

00:32:29,560 --> 00:32:32,650
bottleneck for me where what I meant to

00:32:31,330 --> 00:32:33,970
do was load this big data frame and then

00:32:32,650 --> 00:32:35,770
edit a single cell and I accidentally

00:32:33,970 --> 00:32:38,680
just copied you know half of the data

00:32:35,770 --> 00:32:41,110
that I had here and again this is this

00:32:38,680 --> 00:32:42,880
is a real bug that I've been bit in bit

00:32:41,110 --> 00:32:44,560
bit by both from a performance

00:32:42,880 --> 00:32:45,790
perspective as well from a corrective as

00:32:44,560 --> 00:32:48,130
well as from a correctness perspective

00:32:45,790 --> 00:32:49,720
where you know I assigned none in and

00:32:48,130 --> 00:32:50,980
got a man when really actually that

00:32:49,720 --> 00:32:53,860
should have been an error from somewhere

00:32:50,980 --> 00:32:55,990
else in my program and so probably about

00:32:53,860 --> 00:33:03,700
once a month I send this gift to

00:32:55,990 --> 00:33:05,530
somebody in slack and I I want to

00:33:03,700 --> 00:33:07,990
emphasize here that I'm not like I I

00:33:05,530 --> 00:33:10,210
send this gift out of out of love and

00:33:07,990 --> 00:33:12,880
because I've used pandas so much and

00:33:10,210 --> 00:33:14,920
gotten so much value out of it that I've

00:33:12,880 --> 00:33:16,840
built enough systems on it that I get

00:33:14,920 --> 00:33:18,700
angry at it every now and then but I

00:33:16,840 --> 00:33:20,740
think it's you know a useful reflection

00:33:18,700 --> 00:33:22,360
of this feeling of it was trying to be

00:33:20,740 --> 00:33:22,860
helpful was trying to do something for

00:33:22,360 --> 00:33:24,690
me

00:33:22,860 --> 00:33:26,490
but really I just want it to tell me

00:33:24,690 --> 00:33:27,990
like no like please put an integer in

00:33:26,490 --> 00:33:29,640
there if that's what you meant or you

00:33:27,990 --> 00:33:33,750
know have some way of saying it's okay

00:33:29,640 --> 00:33:36,390
for you to coerce here and so you know

00:33:33,750 --> 00:33:39,510
to to bring back to this kind of wins

00:33:36,390 --> 00:33:40,710
and losses so handling ambiguous inputs

00:33:39,510 --> 00:33:42,780
like this can be a really big win for

00:33:40,710 --> 00:33:45,179
ergonomics right interpreting strings as

00:33:42,780 --> 00:33:47,850
timestamps or interpreting floats as

00:33:45,179 --> 00:33:49,110
integers is really great when you're

00:33:47,850 --> 00:33:50,100
just sort of working in a repple or

00:33:49,110 --> 00:33:51,270
you're working interactively and you

00:33:50,100 --> 00:33:53,250
just want to grab a slice of your data

00:33:51,270 --> 00:33:54,660
frame and it can be a win for

00:33:53,250 --> 00:33:56,370
intuitiveness where especially if you're

00:33:54,660 --> 00:33:58,230
not sort of super well-versed in like

00:33:56,370 --> 00:34:00,179
the machine level representations of

00:33:58,230 --> 00:34:02,100
integers and floats you might not

00:34:00,179 --> 00:34:03,809
immediately know why you know five zero

00:34:02,100 --> 00:34:05,700
versus five getting a sign into that

00:34:03,809 --> 00:34:06,660
data frame you know one of those is

00:34:05,700 --> 00:34:09,419
throwing an error and the other one is

00:34:06,660 --> 00:34:11,220
in another hand this can be a loss for

00:34:09,419 --> 00:34:13,919
robustness right it can hide bugs by

00:34:11,220 --> 00:34:15,470
causing the the library to accept inputs

00:34:13,919 --> 00:34:17,700
that we never really wanted it to accept

00:34:15,470 --> 00:34:18,869
it can be lost for performance in some

00:34:17,700 --> 00:34:20,310
cases where something that should have

00:34:18,869 --> 00:34:23,129
been an error condition actually it gets

00:34:20,310 --> 00:34:25,800
accepted but has some significant

00:34:23,129 --> 00:34:27,240
runtime cost and this is both for things

00:34:25,800 --> 00:34:29,100
like you know the implicit array

00:34:27,240 --> 00:34:30,690
coercion but it also can be the case

00:34:29,100 --> 00:34:32,190
that can it can harm micro performance

00:34:30,690 --> 00:34:33,750
because the library has to often do a

00:34:32,190 --> 00:34:35,520
bunch of work to figure out what we

00:34:33,750 --> 00:34:37,730
meant and so there's cases where we'd

00:34:35,520 --> 00:34:40,020
rather not pay that performance overhead

00:34:37,730 --> 00:34:42,000
and finally I think this can be a loss

00:34:40,020 --> 00:34:43,679
for operability where you know at some

00:34:42,000 --> 00:34:45,030
point a lot of those examples I

00:34:43,679 --> 00:34:46,740
mentioned we're gonna crash

00:34:45,030 --> 00:34:48,030
later down the road but now instead of

00:34:46,740 --> 00:34:50,609
crashing at the point where I made the

00:34:48,030 --> 00:34:51,750
mistake they crashed somewhere else you

00:34:50,609 --> 00:34:53,730
know with a strange error about like

00:34:51,750 --> 00:34:54,780
having an unexpected detai or having an

00:34:53,730 --> 00:34:56,960
array that was much longer than I

00:34:54,780 --> 00:34:59,070
expected

00:34:56,960 --> 00:35:00,570
I've got just sort of some other smaller

00:34:59,070 --> 00:35:03,330
examples so one one example that comes

00:35:00,570 --> 00:35:05,640
up for me a decent amount is flat versus

00:35:03,330 --> 00:35:07,650
nested API services so as an interactive

00:35:05,640 --> 00:35:09,600
user it's really useful for me for a

00:35:07,650 --> 00:35:11,250
library to export most of the

00:35:09,600 --> 00:35:13,109
functionality that provides sort of in

00:35:11,250 --> 00:35:15,060
its top-level namespace so I can do you

00:35:13,109 --> 00:35:17,400
know import pandas as PD and then do PD

00:35:15,060 --> 00:35:20,280
tab and see you know the plethora of

00:35:17,400 --> 00:35:21,660
options that PD provides for me but one

00:35:20,280 --> 00:35:23,190
cost of that that's I think a little bit

00:35:21,660 --> 00:35:25,290
subtle is that that means that if I

00:35:23,190 --> 00:35:26,550
import pandas to import everything else

00:35:25,290 --> 00:35:27,869
that pandas has and so if you're doing

00:35:26,550 --> 00:35:30,119
things like command line applications

00:35:27,869 --> 00:35:32,100
that can slow down your load times and

00:35:30,119 --> 00:35:33,420
this this affects us in zip line which

00:35:32,100 --> 00:35:35,520
is the open source spec testing tool

00:35:33,420 --> 00:35:36,720
where we we have this big back testing

00:35:35,520 --> 00:35:38,609
tool and we've got a bunch of

00:35:36,720 --> 00:35:40,200
some of them run sort of big financial

00:35:38,609 --> 00:35:42,510
simulations where it's not a big deal to

00:35:40,200 --> 00:35:43,800
have a second of lag but you know I've

00:35:42,510 --> 00:35:45,060
also got ones that just like log a

00:35:43,800 --> 00:35:46,740
little bit of data and so you either

00:35:45,060 --> 00:35:48,090
have to have like lazy imports or you

00:35:46,740 --> 00:35:50,190
have to do all these weird workarounds

00:35:48,090 --> 00:35:53,280
to avoid importing packages that are

00:35:50,190 --> 00:35:55,109
doing this another case that I see a lot

00:35:53,280 --> 00:35:56,640
of notebooks is sort of automatic or

00:35:55,109 --> 00:35:59,190
unbounded caching where you're pulling a

00:35:56,640 --> 00:36:00,359
lot of results out of a database and you

00:35:59,190 --> 00:36:01,500
know you're calling the same function

00:36:00,359 --> 00:36:02,550
and you don't really want to have to

00:36:01,500 --> 00:36:04,260
think about like whether or not you've

00:36:02,550 --> 00:36:06,119
already loaded it you're doing some

00:36:04,260 --> 00:36:08,040
interactive analysis and so you throw

00:36:06,119 --> 00:36:10,320
like funk tools that LRU cache on top of

00:36:08,040 --> 00:36:11,910
a function somewhere and if you're just

00:36:10,320 --> 00:36:13,470
working with an ephemeral notebook

00:36:11,910 --> 00:36:14,820
that's fine because your note your

00:36:13,470 --> 00:36:16,440
memory which is gonna grow and grow and

00:36:14,820 --> 00:36:18,150
grow and maybe every now and then you

00:36:16,440 --> 00:36:19,349
notice and you you hit you know restart

00:36:18,150 --> 00:36:21,030
all or whatever and it's fine

00:36:19,349 --> 00:36:22,109
but if you take that code and put in an

00:36:21,030 --> 00:36:24,060
application now you've got a big memory

00:36:22,109 --> 00:36:26,640
leak so there's just sort of other

00:36:24,060 --> 00:36:28,230
examples of cases where in the name of

00:36:26,640 --> 00:36:29,640
ergonomics or in the name of easier

00:36:28,230 --> 00:36:31,530
interactive ailment I think we often

00:36:29,640 --> 00:36:35,609
make our lives harder in application

00:36:31,530 --> 00:36:37,800
development so I want to sort of make it

00:36:35,609 --> 00:36:40,290
clear that I'm not trying to argue that

00:36:37,800 --> 00:36:43,160
like pandas is bad or pandas is wrong or

00:36:40,290 --> 00:36:45,660
these other other language choices are

00:36:43,160 --> 00:36:47,400
making the incorrect choice I think like

00:36:45,660 --> 00:36:50,339
honestly in the date-time case I think

00:36:47,400 --> 00:36:51,900
in the balance of values what pen is

00:36:50,339 --> 00:36:54,570
behavior there's is probably right

00:36:51,900 --> 00:36:57,480
because even though when I run into that

00:36:54,570 --> 00:36:58,619
bug in my local you know development

00:36:57,480 --> 00:37:00,390
environment and I have to spend half an

00:36:58,619 --> 00:37:02,070
hour figuring out that I transpose to

00:37:00,390 --> 00:37:03,119
arguments the amount of value I've

00:37:02,070 --> 00:37:04,890
gotten from just being able to quickly

00:37:03,119 --> 00:37:06,510
type something out in the command-line I

00:37:04,890 --> 00:37:09,330
think on the balance actually makes it

00:37:06,510 --> 00:37:10,410
worth it there so it's not necessarily

00:37:09,330 --> 00:37:12,720
one of these things is better or worse

00:37:10,410 --> 00:37:14,580
but that for different users in

00:37:12,720 --> 00:37:16,020
different contexts we're we have to

00:37:14,580 --> 00:37:18,180
sometimes choose to prioritize these

00:37:16,020 --> 00:37:19,470
values in different ways and again these

00:37:18,180 --> 00:37:21,180
these difference in values are driven

00:37:19,470 --> 00:37:23,010
primarily by differences in modes of

00:37:21,180 --> 00:37:24,560
work where depending on the kind of work

00:37:23,010 --> 00:37:26,430
that I'm doing I care about different

00:37:24,560 --> 00:37:29,640
different virtues of a library

00:37:26,430 --> 00:37:30,660
differently so you know ergonomics

00:37:29,640 --> 00:37:33,450
matters more when we're starting from

00:37:30,660 --> 00:37:35,400
scratch robustus and operability matter

00:37:33,450 --> 00:37:37,200
a lot less when we're when our results

00:37:35,400 --> 00:37:39,570
are immediately visible to us so you

00:37:37,200 --> 00:37:41,550
know in in the data frame case where

00:37:39,570 --> 00:37:42,839
we're indexing with 2014 when I'm

00:37:41,550 --> 00:37:44,280
working interactively and I see the data

00:37:42,839 --> 00:37:47,010
frame and that didn't do what I expected

00:37:44,280 --> 00:37:48,330
I know I can sort of see that

00:37:47,010 --> 00:37:49,980
immediately and I can respond to that

00:37:48,330 --> 00:37:50,550
whereas if that happens in the bowels of

00:37:49,980 --> 00:37:52,770
my application

00:37:50,550 --> 00:37:54,180
somewhere I don't necessarily get that

00:37:52,770 --> 00:37:55,860
immediate feedback if something's gone

00:37:54,180 --> 00:37:58,140
wrong

00:37:55,860 --> 00:37:58,980
and you know going along with the theme

00:37:58,140 --> 00:38:00,450
of we don't necessarily know where

00:37:58,980 --> 00:38:02,640
building yet and interactive element

00:38:00,450 --> 00:38:03,720
testability is only really useful if you

00:38:02,640 --> 00:38:10,230
know what it is that you should be

00:38:03,720 --> 00:38:13,020
testing so so what do we do with kind of

00:38:10,230 --> 00:38:15,270
these observations so what one thing I

00:38:13,020 --> 00:38:17,220
do think is true is that most

00:38:15,270 --> 00:38:19,800
interactively developments off Philips

00:38:17,220 --> 00:38:21,180
software either stops being used and

00:38:19,800 --> 00:38:22,530
honestly that's probably the majority of

00:38:21,180 --> 00:38:23,910
interactively developments develop

00:38:22,530 --> 00:38:25,770
software and most stuff is a repla

00:38:23,910 --> 00:38:26,880
session somewhere or a quick notebook

00:38:25,770 --> 00:38:30,210
that gets sketched out and then thrown

00:38:26,880 --> 00:38:32,130
away so most of our either stops being

00:38:30,210 --> 00:38:34,260
used in which case we don't really care

00:38:32,130 --> 00:38:36,780
about the the maintenance costs of some

00:38:34,260 --> 00:38:37,950
of these changes that we've made or it

00:38:36,780 --> 00:38:39,900
gets integrated into a larger

00:38:37,950 --> 00:38:41,760
application we tend not to have

00:38:39,900 --> 00:38:43,740
notebooks that just kind of live forever

00:38:41,760 --> 00:38:45,570
and get developed forever maybe that

00:38:43,740 --> 00:38:46,710
happens sometimes but in my experience

00:38:45,570 --> 00:38:47,670
if a notebook lives long enough it's

00:38:46,710 --> 00:38:48,660
because it's important enough that at

00:38:47,670 --> 00:38:51,600
some point something's gonna want to put

00:38:48,660 --> 00:38:53,010
it in production and so we've got these

00:38:51,600 --> 00:38:54,780
interactive values that are mostly

00:38:53,010 --> 00:38:56,430
velocity oriented and they're primarily

00:38:54,780 --> 00:38:58,110
aiming to minimize the cost of

00:38:56,430 --> 00:38:59,490
exploration and new development we've

00:38:58,110 --> 00:39:00,870
got these non-interactive values that

00:38:59,490 --> 00:39:02,850
are mostly production oriented that are

00:39:00,870 --> 00:39:06,270
aiming to minimize the total cost of

00:39:02,850 --> 00:39:08,250
development over the long run and so for

00:39:06,270 --> 00:39:09,300
the software that stops being used I

00:39:08,250 --> 00:39:11,250
think it makes sense for us to optimize

00:39:09,300 --> 00:39:12,690
for these velocity oriented values where

00:39:11,250 --> 00:39:14,970
we want to be able to get ideas out of

00:39:12,690 --> 00:39:16,230
our head as fast as possible and for

00:39:14,970 --> 00:39:17,490
software that's used for a long time I

00:39:16,230 --> 00:39:18,720
think it makes sense to optimize for

00:39:17,490 --> 00:39:20,160
these production oriented values where

00:39:18,720 --> 00:39:22,710
we're minimizing sort of the long term

00:39:20,160 --> 00:39:24,030
integrated cost of development the

00:39:22,710 --> 00:39:25,710
problem is it's hard to tell which

00:39:24,030 --> 00:39:27,150
something is going to be ahead of time

00:39:25,710 --> 00:39:29,010
right if I'm working on a notebook I

00:39:27,150 --> 00:39:30,690
don't necessarily know whether this is

00:39:29,010 --> 00:39:32,340
gonna be a one-off throwaway sketch of

00:39:30,690 --> 00:39:33,570
something or it's gonna be something

00:39:32,340 --> 00:39:36,270
that I'm gonna want to turn into a

00:39:33,570 --> 00:39:39,450
service or put a server behind or run in

00:39:36,270 --> 00:39:42,000
production you know every day so what do

00:39:39,450 --> 00:39:45,090
we do about that fact so I think one way

00:39:42,000 --> 00:39:47,580
that we can try to kind of hedge against

00:39:45,090 --> 00:39:49,470
this this problem is to try to get the

00:39:47,580 --> 00:39:50,700
best of both worlds what we can and one

00:39:49,470 --> 00:39:52,230
of the ways that I think we can get the

00:39:50,700 --> 00:39:54,330
best of both worlds is to organize our

00:39:52,230 --> 00:39:56,970
software into layers and so you know

00:39:54,330 --> 00:40:01,500
like Shrek says ogres have layers onions

00:39:56,970 --> 00:40:03,210
have layers software has layers so I

00:40:01,500 --> 00:40:03,790
think one way that we can get a lot of

00:40:03,210 --> 00:40:05,980
the benefit

00:40:03,790 --> 00:40:08,350
of sort of both interactive and

00:40:05,980 --> 00:40:10,720
application development is to build kind

00:40:08,350 --> 00:40:12,370
of a core layer of code that's optimized

00:40:10,720 --> 00:40:15,430
for these production oriented values

00:40:12,370 --> 00:40:17,230
that you know uses default sparingly

00:40:15,430 --> 00:40:19,420
that doesn't depend on global state that

00:40:17,230 --> 00:40:21,550
passes values explicitly that's not

00:40:19,420 --> 00:40:23,350
necessarily you know that's that's being

00:40:21,550 --> 00:40:25,810
robust in its error checking or robust

00:40:23,350 --> 00:40:27,520
and it's its input validation and then

00:40:25,810 --> 00:40:29,470
it's often the case that I think we can

00:40:27,520 --> 00:40:33,130
build sort of friendly interactive

00:40:29,470 --> 00:40:35,100
layers on top of that core layer and so

00:40:33,130 --> 00:40:37,750
again sort of show you my really nice

00:40:35,100 --> 00:40:39,250
diagrams you can kind of have this core

00:40:37,750 --> 00:40:41,800
layer of abstraction that's shared

00:40:39,250 --> 00:40:43,420
across your stack and then you can have

00:40:41,800 --> 00:40:45,610
an interactive layer that's designed to

00:40:43,420 --> 00:40:47,650
provide from an interactive friendly API

00:40:45,610 --> 00:40:49,060
on top of your core and you can build

00:40:47,650 --> 00:40:50,830
your applications on top of that core

00:40:49,060 --> 00:40:51,820
and then you can loops you can write

00:40:50,830 --> 00:40:53,050
your notebooks on top of that

00:40:51,820 --> 00:40:54,220
interactive layer as well or you can

00:40:53,050 --> 00:40:54,640
write your repple sessions on top of it

00:40:54,220 --> 00:40:56,560
as well

00:40:54,640 --> 00:40:58,270
one thing that I've had a lot of success

00:40:56,560 --> 00:41:00,820
with in this regard is putting ipython

00:40:58,270 --> 00:41:01,960
profiles in source so most people sort

00:41:00,820 --> 00:41:03,850
of have an eye height on profile if you

00:41:01,960 --> 00:41:05,020
used ipython a lot it allows you to have

00:41:03,850 --> 00:41:06,850
kind of snippets of code that you want

00:41:05,020 --> 00:41:08,920
to get automatically loaded into your

00:41:06,850 --> 00:41:10,030
environment and most people I think use

00:41:08,920 --> 00:41:11,440
that for kind of their own little

00:41:10,030 --> 00:41:13,090
personal snippets or whatnot

00:41:11,440 --> 00:41:15,370
but a thing you can do is if you've got

00:41:13,090 --> 00:41:16,840
an application with a useful core

00:41:15,370 --> 00:41:18,790
library that's not necessarily designed

00:41:16,840 --> 00:41:20,710
for interactive use you can put all of

00:41:18,790 --> 00:41:22,780
your little helper functions for getting

00:41:20,710 --> 00:41:24,510
you know an instance of your data portal

00:41:22,780 --> 00:41:27,010
class or whatever it is that you call it

00:41:24,510 --> 00:41:28,210
you can put that in source control so

00:41:27,010 --> 00:41:31,330
that anyone who's working with your

00:41:28,210 --> 00:41:33,730
application can do you know dot slash my

00:41:31,330 --> 00:41:35,050
ipython and immediately have a nice

00:41:33,730 --> 00:41:36,220
interactive console to all the

00:41:35,050 --> 00:41:40,630
facilities that your application

00:41:36,220 --> 00:41:42,250
provides so I think this this sort of

00:41:40,630 --> 00:41:44,230
layered architecture pattern has

00:41:42,250 --> 00:41:47,020
applications at many different scales of

00:41:44,230 --> 00:41:49,390
code organization so at the module level

00:41:47,020 --> 00:41:50,560
a level at the library level I you know

00:41:49,390 --> 00:41:52,120
there's lots of examples of libraries

00:41:50,560 --> 00:41:55,330
that do this so for example h5 PI the

00:41:52,120 --> 00:41:57,040
hdf5 library has like a high level API

00:41:55,330 --> 00:41:58,960
that's you know written and pure Python

00:41:57,040 --> 00:42:00,520
is designed for interact abuse as well

00:41:58,960 --> 00:42:02,020
as a low level API that's essentially

00:42:00,520 --> 00:42:04,090
auto-generated psyphon bindings for the

00:42:02,020 --> 00:42:05,950
C API and so depending on what you're

00:42:04,090 --> 00:42:07,480
doing you can use the high level API

00:42:05,950 --> 00:42:09,010
when you want it but you can also drop

00:42:07,480 --> 00:42:11,290
into that lower level API if you if you

00:42:09,010 --> 00:42:13,120
care about the performance trio and

00:42:11,290 --> 00:42:14,650
cryptography have this concept of hazmat

00:42:13,120 --> 00:42:16,480
modules as sort of the lower level

00:42:14,650 --> 00:42:17,560
primitives that the high level user

00:42:16,480 --> 00:42:20,590
facing tools are built

00:42:17,560 --> 00:42:22,090
in terms of and then finally a newer

00:42:20,590 --> 00:42:23,170
example that I like that's sort of very

00:42:22,090 --> 00:42:24,910
explicit about this there's a library

00:42:23,170 --> 00:42:26,830
called Tsar which is a data storage

00:42:24,910 --> 00:42:28,240
library that's kind of a trying to be a

00:42:26,830 --> 00:42:30,250
replacement for hdf5 and they actually

00:42:28,240 --> 00:42:31,660
have it explicit so our dot convenience

00:42:30,250 --> 00:42:33,040
module that exports a bunch of stuff

00:42:31,660 --> 00:42:36,520
that's designed for using interactive

00:42:33,040 --> 00:42:37,990
use you also can get this I think this

00:42:36,520 --> 00:42:39,610
sort of fractally nests at different

00:42:37,990 --> 00:42:40,960
parts of your application so another

00:42:39,610 --> 00:42:42,730
place where you can get this as classes

00:42:40,960 --> 00:42:44,710
where I've got some class that takes

00:42:42,730 --> 00:42:45,880
lots of complex parameters I think often

00:42:44,710 --> 00:42:47,110
the temptation is to put lots of

00:42:45,880 --> 00:42:48,070
defaults on those things so it's easy to

00:42:47,110 --> 00:42:50,500
construct an instance of that class

00:42:48,070 --> 00:42:52,960
dynamically and I think often a better a

00:42:50,500 --> 00:42:54,580
better pattern is to make the

00:42:52,960 --> 00:42:57,130
constructor of my object just take all

00:42:54,580 --> 00:42:58,390
of the explicit values which allows the

00:42:57,130 --> 00:43:00,280
constructor to be really simple just

00:42:58,390 --> 00:43:02,110
assigning values or assigning attributes

00:43:00,280 --> 00:43:03,580
to self and then you can provide these

00:43:02,110 --> 00:43:04,990
sort of smart constructors these helper

00:43:03,580 --> 00:43:07,060
constructors as class methods where I

00:43:04,990 --> 00:43:08,920
can say make an instance of my complex

00:43:07,060 --> 00:43:10,630
object from a configuration file or from

00:43:08,920 --> 00:43:11,800
some other resource that's easy to

00:43:10,630 --> 00:43:14,410
construct in the repple and this allows

00:43:11,800 --> 00:43:15,610
us to have the simplicity of not having

00:43:14,410 --> 00:43:17,620
to do with default handling all over the

00:43:15,610 --> 00:43:19,050
place nor application but still have the

00:43:17,620 --> 00:43:20,620
convenience of the higher-level

00:43:19,050 --> 00:43:24,790
application or a higher-level

00:43:20,620 --> 00:43:27,040
interactive use case and I've got some

00:43:24,790 --> 00:43:29,320
other stuff about functions and I'm

00:43:27,040 --> 00:43:31,600
gonna skip over here but I want to says

00:43:29,320 --> 00:43:32,620
this is not a silver bullet one of the

00:43:31,600 --> 00:43:34,870
cost of this is you've got more API

00:43:32,620 --> 00:43:36,310
surface to maintain it might be more

00:43:34,870 --> 00:43:37,420
work in the short term though often I

00:43:36,310 --> 00:43:39,100
think it's work that you were gonna do

00:43:37,420 --> 00:43:41,500
anyway so if you have that lower-level

00:43:39,100 --> 00:43:43,840
core interface already it's usually not

00:43:41,500 --> 00:43:46,540
that much more work to build the the

00:43:43,840 --> 00:43:48,340
interactive layer on top of it it's

00:43:46,540 --> 00:43:50,080
still harder to test those interactive

00:43:48,340 --> 00:43:52,300
friendly layers but you probably weren't

00:43:50,080 --> 00:43:53,590
testing them before and it's probably

00:43:52,300 --> 00:43:54,910
easier than it would have been before

00:43:53,590 --> 00:43:58,120
anyway so I think it still ends up being

00:43:54,910 --> 00:43:59,530
a win in a lot of cases so to wrap up

00:43:58,120 --> 00:44:03,100
because I think I'm running low on time

00:43:59,530 --> 00:44:04,330
here one thing I wanted is that if you

00:44:03,100 --> 00:44:06,520
disagree with the design of a piece of

00:44:04,330 --> 00:44:08,440
code I think it's a useful exercise to

00:44:06,520 --> 00:44:10,390
try to understand the ways that the

00:44:08,440 --> 00:44:13,870
software values the author that code

00:44:10,390 --> 00:44:15,790
might differ from yours and in

00:44:13,870 --> 00:44:17,500
particular to think about whether the

00:44:15,790 --> 00:44:18,940
way that that user or that author

00:44:17,500 --> 00:44:19,810
expects to interact with that code might

00:44:18,940 --> 00:44:22,300
differ from the way that you would

00:44:19,810 --> 00:44:23,620
expect to use it another thing to think

00:44:22,300 --> 00:44:25,270
about is that if you're designing code

00:44:23,620 --> 00:44:26,760
that will you know maybe not immediately

00:44:25,270 --> 00:44:28,840
but eventually be used in application

00:44:26,760 --> 00:44:29,800
consider the app the implications of

00:44:28,840 --> 00:44:31,269
your decisions for things like

00:44:29,800 --> 00:44:33,179
maintainability for tests

00:44:31,269 --> 00:44:35,829
ability for modularity for robustness

00:44:33,179 --> 00:44:36,969
and sort of take the other side of that

00:44:35,829 --> 00:44:38,559
if you're designing code that might be

00:44:36,969 --> 00:44:39,459
used interactively consider the

00:44:38,559 --> 00:44:41,589
implications for things like economic

00:44:39,459 --> 00:44:44,229
for discoverability for flexibility you

00:44:41,589 --> 00:44:46,449
know can if I do dot tab and tab

00:44:44,229 --> 00:44:47,979
complete on the main class in my module

00:44:46,449 --> 00:44:50,199
or the main the top-level module do I

00:44:47,979 --> 00:44:51,609
get useful information can a user easily

00:44:50,199 --> 00:44:53,349
navigate this thing can I use the

00:44:51,609 --> 00:44:55,089
application in a reasonable way without

00:44:53,349 --> 00:44:59,140
up having to construct 15 intermediate

00:44:55,089 --> 00:45:00,669
objects finally I want to say that when

00:44:59,140 --> 00:45:03,459
we're faced with trade-offs between

00:45:00,669 --> 00:45:04,899
these divergent values one useful

00:45:03,459 --> 00:45:06,549
technique can be to separate your code

00:45:04,899 --> 00:45:08,049
into layers that can cater to different

00:45:06,549 --> 00:45:09,729
modes of usage you can have a

00:45:08,049 --> 00:45:11,439
foundational core layer that can be

00:45:09,729 --> 00:45:12,699
built upon for applications and you can

00:45:11,439 --> 00:45:15,249
build sort of interactive friendly

00:45:12,699 --> 00:45:17,169
layers on top of that right so we can

00:45:15,249 --> 00:45:18,579
organize modules into these core and

00:45:17,169 --> 00:45:19,929
convenience layers we can consider

00:45:18,579 --> 00:45:22,209
adding smart constructors as class

00:45:19,929 --> 00:45:23,919
methods of our objects we can often

00:45:22,209 --> 00:45:26,919
write helper functions to make sort of

00:45:23,919 --> 00:45:28,719
common patterns more ergonomic and with

00:45:26,919 --> 00:45:35,829
that I think I'm just about out of time

00:45:28,719 --> 00:45:38,049
so thank you all for your time and I do

00:45:35,829 --> 00:45:40,179
have a link to the slides up here they

00:45:38,049 --> 00:45:41,259
are not up there yet so don't don't go

00:45:40,179 --> 00:45:42,609
trying to look at them immediately but

00:45:41,259 --> 00:45:44,859
those will get posted sometime later

00:45:42,609 --> 00:45:46,449
this afternoon and if I think we're the

00:45:44,859 --> 00:45:48,339
last session so I don't know that we've

00:45:46,449 --> 00:45:50,679
got a hard deadline so if there's any

00:45:48,339 --> 00:45:53,309
questions or comments or anything like

00:45:50,679 --> 00:45:53,309
that I'm happy to answer

00:46:36,710 --> 00:46:43,230
yeah so so I think one assumption there

00:46:41,070 --> 00:46:44,280
that I that I agree with to some extent

00:46:43,230 --> 00:46:46,500
but also want to challenge is to believe

00:46:44,280 --> 00:46:47,820
that if I'm using pandas that I'm some

00:46:46,500 --> 00:46:49,560
sort of somehow like transitively

00:46:47,820 --> 00:46:54,030
infected by these convenience features

00:46:49,560 --> 00:46:56,270
that they've added and that's true to

00:46:54,030 --> 00:46:58,380
some extent but I think you can also

00:46:56,270 --> 00:47:00,840
restrict yourself to the way that you

00:46:58,380 --> 00:47:05,670
use you know those libraries in ways

00:47:00,840 --> 00:47:06,870
that allow you to you know to get kind

00:47:05,670 --> 00:47:10,260
of the robustness guarantees that you'd

00:47:06,870 --> 00:47:13,200
want you'd want to get out of them but

00:47:10,260 --> 00:47:15,570
yeah I mean I don't know that I have an

00:47:13,200 --> 00:47:17,760
immediate answer for that beyond like I

00:47:15,570 --> 00:47:19,740
think testing is is a good way to do

00:47:17,760 --> 00:47:21,630
this like the worry of depending on

00:47:19,740 --> 00:47:22,950
something that uses you know that

00:47:21,630 --> 00:47:24,980
provides these convenience features or

00:47:22,950 --> 00:47:27,510
provides these features that are

00:47:24,980 --> 00:47:30,690
primarily geared for interactive use is

00:47:27,510 --> 00:47:32,250
that you know you're gonna get bitten by

00:47:30,690 --> 00:47:33,600
one of these when you didn't expect it

00:47:32,250 --> 00:47:36,060
or when you didn't want the convenience

00:47:33,600 --> 00:47:37,620
convenient feature and so I think the

00:47:36,060 --> 00:47:40,860
best way that I know how to do that is

00:47:37,620 --> 00:47:41,970
just sort of like good test coverage of

00:47:40,860 --> 00:47:44,250
the code that you care about and that

00:47:41,970 --> 00:47:45,780
you know you're making sure that you're

00:47:44,250 --> 00:47:48,630
validating whatever inputs that you care

00:47:45,780 --> 00:47:50,100
about or in some cases like you're

00:47:48,630 --> 00:47:51,720
you're willing to live with the fact

00:47:50,100 --> 00:47:53,040
that you might get an unexplained use

00:47:51,720 --> 00:47:54,510
you an unexpected input than you might

00:47:53,040 --> 00:47:56,850
produce an unexpected output like I

00:47:54,510 --> 00:47:58,260
think that will it's hard especially my

00:47:56,850 --> 00:48:04,640
language like Python to totally defend

00:47:58,260 --> 00:48:04,640
yourself from something like that yep

00:48:41,840 --> 00:48:46,050
yeah and so just for the recording the

00:48:44,970 --> 00:48:48,390
suggestion was a library called

00:48:46,050 --> 00:48:54,000
properties is the name of it that's for

00:48:48,390 --> 00:48:55,890
like argument validation or okay okay

00:48:54,000 --> 00:48:57,420
yeah yeah we've actually we've developed

00:48:55,890 --> 00:48:58,590
a very similar library that's internal

00:48:57,420 --> 00:49:00,480
ins apply and called like supplying that

00:48:58,590 --> 00:49:02,640
utils that input validation with

00:49:00,480 --> 00:49:04,350
decorators for that sort of thing yeah I

00:49:02,640 --> 00:49:06,360
suspect lots of libraries in the

00:49:04,350 --> 00:49:08,070
ecosystem have their own sort of little

00:49:06,360 --> 00:49:10,590
sub module tucked away somewhere for the

00:49:08,070 --> 00:49:12,420
decorator for like tourist strings to

00:49:10,590 --> 00:49:14,160
this or course file paths to whatever

00:49:12,420 --> 00:49:17,220
file format you cared about or all that

00:49:14,160 --> 00:49:18,390
sort of thing but yeah so so another way

00:49:17,220 --> 00:49:21,390
that you can sort of at least be a

00:49:18,390 --> 00:49:23,280
little bit more rigorous about these

00:49:21,390 --> 00:49:25,230
kinds of convenience features is you

00:49:23,280 --> 00:49:27,330
know if you can have kind of a principle

00:49:25,230 --> 00:49:28,800
a principled approach to doing coercion

00:49:27,330 --> 00:49:30,420
x' where you've got you know a standard

00:49:28,800 --> 00:49:31,890
set of decorators for coercing from

00:49:30,420 --> 00:49:34,380
thing a to thing B then that at least

00:49:31,890 --> 00:49:35,910
give you some degree of belief that it's

00:49:34,380 --> 00:50:03,900
not just ad hoc scattered all over your

00:49:35,910 --> 00:50:06,150
codebase sorry sit so your the question

00:50:03,900 --> 00:50:08,040
is about the the data frame that

00:50:06,150 --> 00:50:09,450
describe method which I think the belief

00:50:08,040 --> 00:50:11,070
the the behavior that that had that

00:50:09,450 --> 00:50:13,620
gives you like summary statistics for

00:50:11,070 --> 00:50:16,020
min Max and percentiles for and I

00:50:13,620 --> 00:50:17,430
believe it only works for numeric inputs

00:50:16,020 --> 00:50:18,360
and it'll just silently ignore any

00:50:17,430 --> 00:50:21,360
columns that are not

00:50:18,360 --> 00:50:23,190
Eric I thought it actually supported

00:50:21,360 --> 00:50:26,460
date/time stuff as very single ace but I

00:50:23,190 --> 00:50:30,510
could be wrong about that but yeah it is

00:50:26,460 --> 00:50:32,010
it's sort of I think Panda is more so

00:50:30,510 --> 00:50:32,940
than many libraries and again it's I

00:50:32,010 --> 00:50:34,200
don't even this so no that it's

00:50:32,940 --> 00:50:36,570
incorrect to be doing this but pandas

00:50:34,200 --> 00:50:39,810
tries very hard to not throw errors and

00:50:36,570 --> 00:50:42,300
it will it will give you a result back

00:50:39,810 --> 00:50:43,980
even if it's even if it's maybe not a

00:50:42,300 --> 00:50:47,490
reasonable result or it's not the result

00:50:43,980 --> 00:50:49,380
that you expected yeah so yeah it is

00:50:47,490 --> 00:50:51,150
definitely like I've we've got a whole

00:50:49,380 --> 00:50:52,710
bunch of special case code and zip line

00:50:51,150 --> 00:50:54,090
for like handling data frames of length

00:50:52,710 --> 00:50:56,250
of zero for example there's a bunch of

00:50:54,090 --> 00:50:57,870
things that are that are not parametric

00:50:56,250 --> 00:50:59,790
over length zero so there's like special

00:50:57,870 --> 00:51:04,860
case where if not land of data frame but

00:50:59,790 --> 00:51:06,270
yeah yeah but yeah so like it's another

00:51:04,860 --> 00:51:08,400
another pattern that we've had and a lot

00:51:06,270 --> 00:51:10,770
of places in zip line is will have a

00:51:08,400 --> 00:51:12,900
parameter with a default actually

00:51:10,770 --> 00:51:14,490
usually that's like what to do in an

00:51:12,900 --> 00:51:15,840
error condition and the options we

00:51:14,490 --> 00:51:18,720
usually have are other log warned or

00:51:15,840 --> 00:51:20,370
ignore so it's either you know it

00:51:18,720 --> 00:51:22,470
ignores whatever the default behavior is

00:51:20,370 --> 00:51:23,760
log or like log of warning or fire are

00:51:22,470 --> 00:51:26,040
warning set warning and then error will

00:51:23,760 --> 00:51:27,330
actually raise an exception so we do

00:51:26,040 --> 00:51:28,680
that for like the quanto pian api is

00:51:27,330 --> 00:51:30,450
where we've got like a team of people

00:51:28,680 --> 00:51:31,980
whose job it is to curate those api's or

00:51:30,450 --> 00:51:33,750
at least we've got me who's very

00:51:31,980 --> 00:51:35,970
pedantic about these things to do that

00:51:33,750 --> 00:51:39,360
but it's hard to sort of extend that to

00:51:35,970 --> 00:51:42,530
every possible place in your in your

00:51:39,360 --> 00:51:44,610
library and a principled way so yeah

00:51:42,530 --> 00:51:45,560
yeah i think to answer your media

00:51:44,610 --> 00:51:49,410
question like yeah it's that's

00:51:45,560 --> 00:51:50,400
surprising to me it would be nice you

00:51:49,410 --> 00:51:51,480
know i don't know if they're wrong to

00:51:50,400 --> 00:51:52,890
not throw an error there it would be

00:51:51,480 --> 00:51:54,240
nice for them to like log something it's

00:51:52,890 --> 00:51:56,250
like hey I dropped this column like

00:51:54,240 --> 00:51:58,290
you're not crazy you had this column

00:51:56,250 --> 00:51:59,130
it's just that you know it's timestamp

00:51:58,290 --> 00:52:00,950
and I don't know what it means to

00:51:59,130 --> 00:52:05,060
describe a timestamp column right

00:52:00,950 --> 00:52:05,060
something else other questions yeah

00:52:12,869 --> 00:52:17,010
so the question is about what scale of

00:52:14,670 --> 00:52:21,780
data have I worked with when I'm working

00:52:17,010 --> 00:52:24,540
with pandas so pretty diverse scale I

00:52:21,780 --> 00:52:26,580
would say ranging down to like you know

00:52:24,540 --> 00:52:28,410
a couple megabytes and probably the

00:52:26,580 --> 00:52:33,930
largest thing that I've used didn't use

00:52:28,410 --> 00:52:38,400
pandas for is like our minute pricing

00:52:33,930 --> 00:52:40,410
data set is like 60 gigs compressed and

00:52:38,400 --> 00:52:41,369
much larger than that uncompressed I

00:52:40,410 --> 00:52:44,609
don't know that I've ever loaded all

00:52:41,369 --> 00:52:45,720
that into a data frame at once

00:52:44,609 --> 00:52:47,520
that's certainly I wouldn't be able to

00:52:45,720 --> 00:52:51,510
that on my laptop I'm a big a less

00:52:47,520 --> 00:52:54,210
instance for that or something but yeah

00:52:51,510 --> 00:52:55,680
most of our a lot of what my job as bad

00:52:54,210 --> 00:52:58,680
is figuring out how to allow people to

00:52:55,680 --> 00:53:01,320
do financial analysis on moderately

00:52:58,680 --> 00:53:02,910
constrained resources so like our target

00:53:01,320 --> 00:53:05,460
deployment environment for a research

00:53:02,910 --> 00:53:08,160
environment is like 8 to 10 gigs and

00:53:05,460 --> 00:53:09,810
like a single-core but we're trying to

00:53:08,160 --> 00:53:11,250
allow people to do analyses on you know

00:53:09,810 --> 00:53:12,570
tens or hundreds of gigabytes of data

00:53:11,250 --> 00:53:16,100
and so it's an interesting challenge to

00:53:12,570 --> 00:53:16,100
do computation on that efficiently

00:53:28,549 --> 00:53:34,499
yeah so we we I don't know if you'd call

00:53:33,029 --> 00:53:36,089
it clever we've definitely done a bunch

00:53:34,499 --> 00:53:38,789
of tools for for doing sort of streaming

00:53:36,089 --> 00:53:40,380
analysis on data frames we have there's

00:53:38,789 --> 00:53:42,239
a whole sub API and zip line called the

00:53:40,380 --> 00:53:43,709
pipeline API that's about sort of doing

00:53:42,239 --> 00:53:48,119
these rolling window of financial

00:53:43,709 --> 00:53:51,089
transformations yeah cool any other

00:53:48,119 --> 00:53:51,670
questions before I head out thank you

00:53:51,089 --> 00:53:59,219
all so much

00:53:51,670 --> 00:53:59,219

YouTube URL: https://www.youtube.com/watch?v=HzhHGoqN_kw


