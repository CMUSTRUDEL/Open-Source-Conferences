Title: Orchestrating chaos: Applying database research in the wild - Peter Alvaro (UC Santa Cruz)
Publication date: 2017-06-22
Playlist: Velocity 2017 - San Jose, California
Description: 
	Lineage-driven fault injection (LDFI), a novel approach to automating failure testing, can greatly reduce the number of faults that must be explored via fault injection. Peter Alvaro explores LDFIâ€™s theoretical roots in the database research notion of provenance and presents early results from the field and opportunities for near- and long-term future research.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Google: http://plus.google.com/+oreillymedia
Captions: 
	00:00:00,560 --> 00:00:06,390
so if I had time I would talk about a

00:00:04,200 --> 00:00:08,570
second myth which is also in its sunset

00:00:06,390 --> 00:00:11,219
the myth of formally verified

00:00:08,570 --> 00:00:13,469
distributed components and sort of the

00:00:11,219 --> 00:00:15,660
TLDR of this is that we're not going to

00:00:13,469 --> 00:00:17,460
be able to model check or formally

00:00:15,660 --> 00:00:19,110
verify our systems for the same reasons

00:00:17,460 --> 00:00:21,960
that we can't rely on experts because

00:00:19,110 --> 00:00:24,950
it's not possible to compose fault

00:00:21,960 --> 00:00:28,380
tolerance out of pieces okay

00:00:24,950 --> 00:00:30,390
we couldn't model check all of Netflix

00:00:28,380 --> 00:00:31,890
the state space is too large so our best

00:00:30,390 --> 00:00:33,150
hope would be to model check the pieces

00:00:31,890 --> 00:00:35,280
and put them together and as I already

00:00:33,150 --> 00:00:37,230
argued that didn't work and so industry

00:00:35,280 --> 00:00:39,210
and academia alike have raced on this

00:00:37,230 --> 00:00:43,050
trade-off space from the left which is

00:00:39,210 --> 00:00:47,100
sort of exhaustive but intractable

00:00:43,050 --> 00:00:48,870
approaches to the right incremental but

00:00:47,100 --> 00:00:50,579
arguably unprincipled approaches that

00:00:48,870 --> 00:00:53,040
combine well-understood testing

00:00:50,579 --> 00:00:54,540
methodologies with fault injection we

00:00:53,040 --> 00:00:55,649
run our integration tests and while

00:00:54,540 --> 00:00:59,329
we're running our integration tests

00:00:55,649 --> 00:01:01,350
right we crash it we see what happens I

00:00:59,329 --> 00:01:04,290
think this is an interesting shift

00:01:01,350 --> 00:01:06,719
because it's a fundamental shift towards

00:01:04,290 --> 00:01:08,969
understanding how our systems behave not

00:01:06,719 --> 00:01:10,799
from the inside as an expert would

00:01:08,969 --> 00:01:12,479
understand them or a model checker would

00:01:10,799 --> 00:01:14,249
understand them but from the outside

00:01:12,479 --> 00:01:16,469
accepting the fact that in the limit

00:01:14,249 --> 00:01:19,530
these systems must be treated as black

00:01:16,469 --> 00:01:21,359
boxes but black boxes whose inputs and

00:01:19,530 --> 00:01:22,889
outputs are very well understood so

00:01:21,359 --> 00:01:25,679
instead of shining a spotlight in the

00:01:22,889 --> 00:01:27,749
Box we walk around the box and we watch

00:01:25,679 --> 00:01:29,459
it take in inputs and produce outputs

00:01:27,749 --> 00:01:31,770
and we formulate hypotheses about its

00:01:29,459 --> 00:01:34,920
functionality based on its behavior

00:01:31,770 --> 00:01:37,799
that's actually kind of cool

00:01:34,920 --> 00:01:39,840
right now of course we can't just test

00:01:37,799 --> 00:01:41,009
how our system works under every fault

00:01:39,840 --> 00:01:43,829
because there's too many faults right if

00:01:41,009 --> 00:01:45,539
I have a application involving 100

00:01:43,829 --> 00:01:47,789
communicating entities there are a

00:01:45,539 --> 00:01:49,319
hundred different and it was same we're

00:01:47,789 --> 00:01:51,119
just looking at crash failures there are

00:01:49,319 --> 00:01:53,939
a hundred different things that can go

00:01:51,119 --> 00:01:55,259
wrong to one thing right 3 million

00:01:53,939 --> 00:01:57,479
things that can go wrong with four

00:01:55,259 --> 00:01:59,130
things it's sixteen billion things that

00:01:57,479 --> 00:02:02,219
can go wrong with seven things and for

00:01:59,130 --> 00:02:04,020
all 100 guys that's 2 to the 100 that's

00:02:02,219 --> 00:02:05,520
a 1 with like 30 zeros after we can't

00:02:04,020 --> 00:02:07,200
actually perform all those experiments

00:02:05,520 --> 00:02:09,299
we need a smart way to search this space

00:02:07,200 --> 00:02:11,909
that we could sort of stab into the

00:02:09,299 --> 00:02:12,720
space randomly as early chaos approaches

00:02:11,909 --> 00:02:13,920
did

00:02:12,720 --> 00:02:15,480
we're not going to cover the space very

00:02:13,920 --> 00:02:17,250
well or get any confidence that we're

00:02:15,480 --> 00:02:19,800
exercising the right faults it's

00:02:17,250 --> 00:02:22,290
tempting to ask clear up some genius on

00:02:19,800 --> 00:02:24,120
it could we exploit the intuitions of

00:02:22,290 --> 00:02:27,030
people who understand the systems under

00:02:24,120 --> 00:02:28,860
test to take a sort of genius guided

00:02:27,030 --> 00:02:32,430
walk through this space visiting only

00:02:28,860 --> 00:02:33,740
the interesting failures but of course

00:02:32,430 --> 00:02:37,200
this should give us the heebie-jeebies

00:02:33,740 --> 00:02:40,200
because it requires a genius in the loop

00:02:37,200 --> 00:02:41,970
now two giants have emerged in this

00:02:40,200 --> 00:02:43,610
space of principled approaches to

00:02:41,970 --> 00:02:46,020
testing combined with fault injection

00:02:43,610 --> 00:02:48,030
chaos engineering over on the left is

00:02:46,020 --> 00:02:49,890
exemplified by Norah Jones formerly a

00:02:48,030 --> 00:02:52,470
jet now at Netflix Kaos engineer

00:02:49,890 --> 00:02:55,440
extraordinaire and Jepsen testing is

00:02:52,470 --> 00:02:56,820
exemplified by Kyle Kingsbury the

00:02:55,440 --> 00:02:58,860
creator of Jepsen and as far as I know

00:02:56,820 --> 00:03:01,620
the only Jepsen tester in the universe

00:02:58,860 --> 00:03:02,490
and these things are different okay and

00:03:01,620 --> 00:03:04,110
I've written down some of the

00:03:02,490 --> 00:03:05,700
differences here but but I think that we

00:03:04,110 --> 00:03:07,830
can gloss over them right they apply to

00:03:05,700 --> 00:03:09,420
systems at different scales with

00:03:07,830 --> 00:03:11,250
different challenges with respect to

00:03:09,420 --> 00:03:12,750
availability of source code and

00:03:11,250 --> 00:03:14,580
obviously a different gold standard of

00:03:12,750 --> 00:03:16,830
what it means to be correct but if we

00:03:14,580 --> 00:03:18,959
ignore these minor distinctions they are

00:03:16,830 --> 00:03:20,910
the same thing right they involve a

00:03:18,959 --> 00:03:25,519
combination of principled observations

00:03:20,910 --> 00:03:28,220
and targeted fault injection right but

00:03:25,519 --> 00:03:30,750
they were law they require the

00:03:28,220 --> 00:03:33,360
acquisition and retention not just of

00:03:30,750 --> 00:03:36,720
super users but of like ultra users of

00:03:33,360 --> 00:03:40,160
one-of-a-kind irreplaceable geniuses

00:03:36,720 --> 00:03:40,160

YouTube URL: https://www.youtube.com/watch?v=QVRlXwHE9AA


