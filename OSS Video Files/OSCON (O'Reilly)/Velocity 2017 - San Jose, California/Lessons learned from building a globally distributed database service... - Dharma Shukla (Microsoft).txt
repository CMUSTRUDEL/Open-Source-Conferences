Title: Lessons learned from building a globally distributed database service... - Dharma Shukla (Microsoft)
Publication date: 2017-06-23
Playlist: Velocity 2017 - San Jose, California
Description: 
	Dharma Shukla explores Azure Cosmos DB, discussing the internals of the system design and the various design trade-offs Azure had to make while building the service. Dharma also shares his experience and lessons learned operating a globally distributed database service worldwide while maintaining comprehensive service level agreements.

Subscribe to O'Reilly on YouTube: http://goo.gl/n3QSYi

Follow O'Reilly on 
Twitter: http://twitter.com/oreillymedia
Facebook: http://facebook.com/OReilly
Google: http://plus.google.com/+oreillymedia
Captions: 
	00:00:02,060 --> 00:00:08,250
cosmos TV project started as project

00:00:04,620 --> 00:00:09,839
Florence back in 2010 back in 2010 there

00:00:08,250 --> 00:00:11,730
were a number of large internet scale

00:00:09,839 --> 00:00:14,700
applications within Microsoft like

00:00:11,730 --> 00:00:17,460
Windows Office Xbox they were all

00:00:14,700 --> 00:00:20,279
looking for a database system that meets

00:00:17,460 --> 00:00:22,380
their requirements the requirements were

00:00:20,279 --> 00:00:23,670
very precise their pain points were very

00:00:22,380 --> 00:00:26,460
clear that was the good thing that

00:00:23,670 --> 00:00:28,740
happened back then they had following

00:00:26,460 --> 00:00:31,320
requirements they wanted a database to

00:00:28,740 --> 00:00:33,499
be globally distributed in a turnkey

00:00:31,320 --> 00:00:35,339
manner the database should be able to

00:00:33,499 --> 00:00:38,519
automatically distribute the data

00:00:35,339 --> 00:00:40,139
wherever the users are such that the

00:00:38,519 --> 00:00:43,139
database can provide low latency

00:00:40,139 --> 00:00:45,149
guarantees at the 99th percentile also

00:00:43,139 --> 00:00:47,010
guarantee high availability and when a

00:00:45,149 --> 00:00:49,620
database tries to balance those

00:00:47,010 --> 00:00:51,929
trade-offs they have to choose between

00:00:49,620 --> 00:00:54,179
degree of consistency as less we talked

00:00:51,929 --> 00:00:55,589
about so they also wanted developers

00:00:54,179 --> 00:00:58,199
within Microsoft also wanted

00:00:55,589 --> 00:01:00,239
programmable consistency model they

00:00:58,199 --> 00:01:02,579
wanted to scale throughput and storage

00:01:00,239 --> 00:01:04,350
elastically and independently all over

00:01:02,579 --> 00:01:07,170
the world and they wanted all of these

00:01:04,350 --> 00:01:09,689
capabilities to be available at really

00:01:07,170 --> 00:01:11,700
low cost now none of these requirements

00:01:09,689 --> 00:01:14,520
are unique to applications within

00:01:11,700 --> 00:01:16,649
Microsoft so as we build the system and

00:01:14,520 --> 00:01:18,509
as we got the constant feedback and

00:01:16,649 --> 00:01:21,329
validation from these applications and

00:01:18,509 --> 00:01:23,520
developers within Microsoft we realize

00:01:21,329 --> 00:01:26,280
that we have robust foundation and then

00:01:23,520 --> 00:01:29,399
we released it for all the developers on

00:01:26,280 --> 00:01:31,530
Azure and that became cosmos DB along

00:01:29,399 --> 00:01:34,950
the course of these years and for some

00:01:31,530 --> 00:01:38,039
of us even before 2010 we learned many

00:01:34,950 --> 00:01:42,719
lessons so I'm going to talk about three

00:01:38,039 --> 00:01:45,770
or four of these lessons and and then we

00:01:42,719 --> 00:01:48,869
will dive deep into each of those areas

00:01:45,770 --> 00:01:51,270
so the most important realization that

00:01:48,869 --> 00:01:52,950
we had early on was the fact that if

00:01:51,270 --> 00:01:55,170
you're building a database that is

00:01:52,950 --> 00:01:57,329
designed for cloud then it has to

00:01:55,170 --> 00:01:59,850
exploit the fundamental properties of

00:01:57,329 --> 00:02:01,889
cloud you'll be surprised when I

00:01:59,850 --> 00:02:03,869
describe these properties that how many

00:02:01,889 --> 00:02:07,079
databases today expose this and exploit

00:02:03,869 --> 00:02:08,850
these properties number one property

00:02:07,079 --> 00:02:12,599
that the cloud enables is a global

00:02:08,850 --> 00:02:14,879
distribution cloud like azure is it

00:02:12,599 --> 00:02:15,840
encompasses the entire planet Earth it

00:02:14,879 --> 00:02:17,580
is 40 region

00:02:15,840 --> 00:02:20,069
and it's constantly growing in its

00:02:17,580 --> 00:02:21,840
regional footprint so if you're an

00:02:20,069 --> 00:02:25,290
application developer and deploying your

00:02:21,840 --> 00:02:27,000
app on Azure you get instant ability to

00:02:25,290 --> 00:02:29,520
instantly deploy your application

00:02:27,000 --> 00:02:32,190
instances all around the world closer to

00:02:29,520 --> 00:02:34,590
where the users are but the data that

00:02:32,190 --> 00:02:37,019
the application instances interact with

00:02:34,590 --> 00:02:39,239
or the database they interact with it's

00:02:37,019 --> 00:02:43,200
confined to a single region perhaps the

00:02:39,239 --> 00:02:45,840
database enables dr and so has backup

00:02:43,200 --> 00:02:48,540
copies or other replicas in couple of

00:02:45,840 --> 00:02:50,310
other regions for the purposes of dr but

00:02:48,540 --> 00:02:52,019
that's not quite the same as a globally

00:02:50,310 --> 00:02:53,880
distributed database a globally

00:02:52,019 --> 00:02:56,010
distributed database intrinsically it

00:02:53,880 --> 00:02:57,750
replicates all of the data wherever the

00:02:56,010 --> 00:02:59,640
users are wherever those application

00:02:57,750 --> 00:03:02,190
instances are running around the world

00:02:59,640 --> 00:03:04,920
such that each application instance gets

00:03:02,190 --> 00:03:06,900
gets its local copy of data by what

00:03:04,920 --> 00:03:09,299
you're doing that it gives guaranteed

00:03:06,900 --> 00:03:11,280
low latency everywhere around the world

00:03:09,299 --> 00:03:14,180
it gives high availability it's a side

00:03:11,280 --> 00:03:16,830
effect of global distribution design and

00:03:14,180 --> 00:03:18,569
when a database does that it has to

00:03:16,830 --> 00:03:20,579
navigate the speed of light in steady

00:03:18,569 --> 00:03:23,370
state and has to confront the cap

00:03:20,579 --> 00:03:26,160
theorem when failures occur so it has to

00:03:23,370 --> 00:03:28,200
provide some notion of programmable

00:03:26,160 --> 00:03:30,420
consistency so that developers can write

00:03:28,200 --> 00:03:33,359
meaningful applications on top of it

00:03:30,420 --> 00:03:34,769
the second capability which is second

00:03:33,359 --> 00:03:37,680
property which is fundamental to the

00:03:34,769 --> 00:03:39,930
cloud is that of elastic and unlimited

00:03:37,680 --> 00:03:42,060
scalability if a database is designed

00:03:39,930 --> 00:03:45,150
for cloud it better be horizontally

00:03:42,060 --> 00:03:48,299
partition such that it can it can scale

00:03:45,150 --> 00:03:49,859
storage and throughput independently the

00:03:48,299 --> 00:03:52,859
third and perhaps the most important

00:03:49,859 --> 00:03:55,079
property that cloud has is that of cost

00:03:52,859 --> 00:03:56,630
efficiencies by what's your fine-grained

00:03:55,079 --> 00:03:59,730
multi-tenancy

00:03:56,630 --> 00:04:01,079
cloud enables unparalleled cost

00:03:59,730 --> 00:04:03,690
efficiencies so if you're building a

00:04:01,079 --> 00:04:06,660
database that is designed for cloud you

00:04:03,690 --> 00:04:08,609
would pack hundreds of customers and

00:04:06,660 --> 00:04:10,980
their data and their workloads on a

00:04:08,609 --> 00:04:12,180
single machine to optimally utilize the

00:04:10,980 --> 00:04:14,760
resources that are available on a

00:04:12,180 --> 00:04:17,669
machine you pack thousands of customers

00:04:14,760 --> 00:04:19,440
within a cluster of machines and you

00:04:17,669 --> 00:04:20,910
utilize the cluster wide resources

00:04:19,440 --> 00:04:22,620
efficiently you could do the same

00:04:20,910 --> 00:04:24,020
progressively at higher degrees of

00:04:22,620 --> 00:04:27,450
abstraction you can have multiple

00:04:24,020 --> 00:04:29,680
utilize clause your data center wide

00:04:27,450 --> 00:04:32,889
capacity by utilization of

00:04:29,680 --> 00:04:35,350
asteroid capacity and and and and and so

00:04:32,889 --> 00:04:37,600
on and so on all of these properties

00:04:35,350 --> 00:04:39,580
cannot be you cannot build a database

00:04:37,600 --> 00:04:42,009
system that uses these properties as an

00:04:39,580 --> 00:04:43,419
after as an afterthought these have to

00:04:42,009 --> 00:04:46,690
be fundamentally designed from the

00:04:43,419 --> 00:04:49,509
ground up also many of these properties

00:04:46,690 --> 00:04:51,669
compose and they yield interesting new

00:04:49,509 --> 00:04:53,979
capabilities so for example you can

00:04:51,669 --> 00:04:55,930
compose elastic scalability by virtue of

00:04:53,979 --> 00:04:58,479
horizontal partitioning and global

00:04:55,930 --> 00:05:00,820
distribution such that as a database you

00:04:58,479 --> 00:05:02,349
can scale throughput not just in the

00:05:00,820 --> 00:05:04,710
time dimension you can not just

00:05:02,349 --> 00:05:07,570
horizontally scale throughput over time

00:05:04,710 --> 00:05:09,669
elastically but also can do it in the

00:05:07,570 --> 00:05:11,259
spatial dimension by virtue of scaling

00:05:09,669 --> 00:05:13,720
throughput at different parts of the

00:05:11,259 --> 00:05:15,430
world differently again elastically so

00:05:13,720 --> 00:05:18,900
that's composition of horizontal

00:05:15,430 --> 00:05:18,900

YouTube URL: https://www.youtube.com/watch?v=TarQf8nuqcw


