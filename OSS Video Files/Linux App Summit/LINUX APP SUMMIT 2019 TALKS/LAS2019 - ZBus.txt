Title: LAS2019 - ZBus
Publication date: 2019-12-23
Playlist: LINUX APP SUMMIT 2019 TALKS
Description: 
	ZBus

Zeeshan Ali
Captions: 
	00:00:00,000 --> 00:00:10,200
um yeah so I had the same talk in West

00:00:07,620 --> 00:00:14,549
fest which happened in Barcelona just a

00:00:10,200 --> 00:00:18,060
few days ago well it's kind of relevant

00:00:14,549 --> 00:00:20,550
to Linux desktop in general a bit too

00:00:18,060 --> 00:00:23,400
apps because maps use T bus to connect

00:00:20,550 --> 00:00:26,070
your services and stuff and you will

00:00:23,400 --> 00:00:30,840
probably use this API over time talking

00:00:26,070 --> 00:00:34,020
about if you are developing an app you

00:00:30,840 --> 00:00:36,180
know any app for Linux desktop first of

00:00:34,020 --> 00:00:39,719
all Who am I well my name is Anna Lee

00:00:36,180 --> 00:00:41,640
worked for Red Hat but my job is in the

00:00:39,719 --> 00:00:44,100
cloud stuff cloud infrastructure stuff

00:00:41,640 --> 00:00:48,539
so all this that I'm talking about is my

00:00:44,100 --> 00:00:51,360
spare time stuff right now work with

00:00:48,539 --> 00:00:53,430
Faust's been doing genome stuff and

00:00:51,360 --> 00:00:57,570
other false related things for a long

00:00:53,430 --> 00:01:01,890
time and I like flying and I have cat

00:00:57,570 --> 00:01:07,260
and like cats so a background story for

00:01:01,890 --> 00:01:09,570
this talk I have a project called geo

00:01:07,260 --> 00:01:12,930
clue it's a component of the Linux

00:01:09,570 --> 00:01:15,000
desktop which tells you where you are

00:01:12,930 --> 00:01:17,189
but it doesn't tell you directly but the

00:01:15,000 --> 00:01:18,900
apps use the service to to ask where

00:01:17,189 --> 00:01:23,159
where you are and use the different

00:01:18,900 --> 00:01:26,119
sources to find that out it's like a

00:01:23,159 --> 00:01:28,439
security service and it's written in C

00:01:26,119 --> 00:01:30,600
I've been a maintainer since your clue

00:01:28,439 --> 00:01:35,159
to where it was a completely rewrite

00:01:30,600 --> 00:01:37,290
with a lot of different ideas and that

00:01:35,159 --> 00:01:42,979
was two thousand thirteen or fourteen so

00:01:37,290 --> 00:01:45,299
it's been many years but I had an idea

00:01:42,979 --> 00:01:48,240
this year the beginning of this year

00:01:45,299 --> 00:01:51,799
last year that that's oxidize it which

00:01:48,240 --> 00:01:58,259
means to convert it into trust from C

00:01:51,799 --> 00:02:00,329
but why you ask well first of all it's

00:01:58,259 --> 00:02:01,799
in C I have a lot of experience with C

00:02:00,329 --> 00:02:05,700
programming I'm really comfortable

00:02:01,799 --> 00:02:08,220
writing C but I'm a human being I make

00:02:05,700 --> 00:02:11,190
mistakes and that means that there's

00:02:08,220 --> 00:02:13,440
crash reports like memory problems every

00:02:11,190 --> 00:02:15,300
now and then even if I use like

00:02:13,440 --> 00:02:17,550
tools that help me with that they will

00:02:15,300 --> 00:02:19,440
still be mistakes because sees a

00:02:17,550 --> 00:02:24,690
language that makes it very easy to make

00:02:19,440 --> 00:02:26,280
mistakes and also like location is the

00:02:24,690 --> 00:02:29,700
one of the most sensitive data about a

00:02:26,280 --> 00:02:33,630
user you can have so if you have memory

00:02:29,700 --> 00:02:37,260
issues that you know it can be you know

00:02:33,630 --> 00:02:39,930
you can use that attacker can use that

00:02:37,260 --> 00:02:43,890
to get your location information and we

00:02:39,930 --> 00:02:46,890
don't want that and most importantly I

00:02:43,890 --> 00:02:48,210
love rust I it's been a it's a language

00:02:46,890 --> 00:02:50,400
that I've been looking for for a very

00:02:48,210 --> 00:02:57,450
long time an efficient language that is

00:02:50,400 --> 00:02:59,220
also explained by design but before I do

00:02:57,450 --> 00:03:01,620
go oxidize your clue there are some

00:02:59,220 --> 00:03:05,010
challenges first of all that I was most

00:03:01,620 --> 00:03:09,060
worried about was the build system a lot

00:03:05,010 --> 00:03:12,030
of the desktop and Barretts services

00:03:09,060 --> 00:03:14,070
nowadays they use Mason which is a build

00:03:12,030 --> 00:03:18,000
system and configuration and build

00:03:14,070 --> 00:03:19,709
system however you call it and that has

00:03:18,000 --> 00:03:21,930
support for rust but it doesn't have

00:03:19,709 --> 00:03:23,610
support for cargo which is the build

00:03:21,930 --> 00:03:26,850
system that is used with with rust

00:03:23,610 --> 00:03:28,770
everywhere and the support for rust

00:03:26,850 --> 00:03:30,930
without support for cargo is not very

00:03:28,770 --> 00:03:33,170
useful in the end you really want to use

00:03:30,930 --> 00:03:36,840
cargo if you want to we are doing rust

00:03:33,170 --> 00:03:39,860
projects unless it's a very simple stuff

00:03:36,840 --> 00:03:44,810
and then you can just use Mason directly

00:03:39,860 --> 00:03:48,470
and the others challenge was Debus the

00:03:44,810 --> 00:03:51,330
inter process which is very efficient

00:03:48,470 --> 00:03:53,280
interprocess communication protocol used

00:03:51,330 --> 00:03:55,950
on the desktop I don't know if I need to

00:03:53,280 --> 00:04:01,170
tell this audience what that is but just

00:03:55,950 --> 00:04:02,670
for ya it's a very famous and just not

00:04:01,170 --> 00:04:04,680
just in desktop world but also an

00:04:02,670 --> 00:04:07,260
embedded world you use it it's used a

00:04:04,680 --> 00:04:12,150
lot for a PC

00:04:07,260 --> 00:04:19,770
there was a Debus library for rust it is

00:04:12,150 --> 00:04:22,800
not was and it's using d-bus lib divas

00:04:19,770 --> 00:04:25,289
which is a sea library so all the actual

00:04:22,800 --> 00:04:26,630
work is happening in in an unsafe

00:04:25,289 --> 00:04:29,000
language and

00:04:26,630 --> 00:04:30,560
was my whole point to do things in the

00:04:29,000 --> 00:04:32,750
safe language especially things that

00:04:30,560 --> 00:04:34,550
handle you know inter process

00:04:32,750 --> 00:04:36,110
communication and stuff that that would

00:04:34,550 --> 00:04:37,880
be very nice to have it in a safe

00:04:36,110 --> 00:04:41,150
language all of it

00:04:37,880 --> 00:04:42,950
but still I thought like even though it

00:04:41,150 --> 00:04:45,610
has I'm not just that issue but many

00:04:42,950 --> 00:04:48,140
other issues I still decided to use it

00:04:45,610 --> 00:04:50,120
and not just use it but also I

00:04:48,140 --> 00:04:56,420
contributed fat first and I thought like

00:04:50,120 --> 00:04:58,910
yeah I can really use that library but

00:04:56,420 --> 00:04:59,420
then in May we had a rescue gnome

00:04:58,910 --> 00:05:02,150
hackfest

00:04:59,420 --> 00:05:04,580
and I decided to actually started

00:05:02,150 --> 00:05:06,740
porting geo clue and I realized that

00:05:04,580 --> 00:05:10,460
Mason bit that I was afraid of is very

00:05:06,740 --> 00:05:13,790
easy to work around with and the main

00:05:10,460 --> 00:05:16,220
problem that happened was the deepest RS

00:05:13,790 --> 00:05:18,260
API was really over complicated

00:05:16,220 --> 00:05:19,760
especially the parts that I needed now

00:05:18,260 --> 00:05:21,350
they were really hard to decipher even

00:05:19,760 --> 00:05:24,470
how to use it

00:05:21,350 --> 00:05:26,960
so I was like what should I do I tried

00:05:24,470 --> 00:05:30,160
like I spent like a day or two just just

00:05:26,960 --> 00:05:32,600
trying to decipher how to use that API

00:05:30,160 --> 00:05:34,910
and I was like maybe I should just

00:05:32,600 --> 00:05:36,950
rewrite my auntie was great and it's

00:05:34,910 --> 00:05:40,730
like from scratch not using lip Debus so

00:05:36,950 --> 00:05:43,700
that the api is nicer and not just for

00:05:40,730 --> 00:05:45,740
me but for others as well and this idea

00:05:43,700 --> 00:05:48,740
has been around like quite a few people

00:05:45,740 --> 00:05:51,260
are I realized later that have tried

00:05:48,740 --> 00:05:53,660
creating a devious library from scratch

00:05:51,260 --> 00:05:56,750
and Russ but they lost interest at some

00:05:53,660 --> 00:06:01,190
point all of them I was like how hard

00:05:56,750 --> 00:06:03,470
can it be that I really wanted an answer

00:06:01,190 --> 00:06:06,530
to that no it wasn't just like no it

00:06:03,470 --> 00:06:09,800
can't be hard so I looked into the

00:06:06,530 --> 00:06:11,900
deepest back and see to see what's

00:06:09,800 --> 00:06:16,340
involved and to decide if I can do it or

00:06:11,900 --> 00:06:22,490
not so on the low level it's just a

00:06:16,340 --> 00:06:24,170
message passing protocol and it's it

00:06:22,490 --> 00:06:26,120
doesn't matter what transport mechanism

00:06:24,170 --> 00:06:28,340
you use you can you even do it on TCP

00:06:26,120 --> 00:06:31,160
but of course it's not secure

00:06:28,340 --> 00:06:35,419
well usually typically on desktops you

00:06:31,160 --> 00:06:38,180
use you do it through UNIX sockets local

00:06:35,419 --> 00:06:39,650
UNIX sockets which is specific to your

00:06:38,180 --> 00:06:42,920
domain or

00:06:39,650 --> 00:06:46,520
user so you can have some kind of

00:06:42,920 --> 00:06:49,820
security there and it has a wire

00:06:46,520 --> 00:06:52,610
protocol which is kind of also known as

00:06:49,820 --> 00:06:53,060
known as G variant because when it was

00:06:52,610 --> 00:06:55,240
created

00:06:53,060 --> 00:06:59,450
G live was one of the first users of it

00:06:55,240 --> 00:07:03,110
and they created this API called G

00:06:59,450 --> 00:07:06,200
variant which is basically to Debus wire

00:07:03,110 --> 00:07:08,420
protocol and you can use it outside of

00:07:06,200 --> 00:07:13,520
Debus contact as well and a lot of

00:07:08,420 --> 00:07:16,670
people do that and so yeah I looked into

00:07:13,520 --> 00:07:18,650
that and it's basically a bunch of data

00:07:16,670 --> 00:07:22,540
types and their encoding that's what the

00:07:18,650 --> 00:07:27,230
spec defines and they have a natural

00:07:22,540 --> 00:07:32,500
alignment so if you have like a four

00:07:27,230 --> 00:07:32,500
byte integer it's aligned on a four byte

00:07:32,830 --> 00:07:41,060
address so mostly it's quite natural and

00:07:37,580 --> 00:07:43,570
it's seems logical and each data type

00:07:41,060 --> 00:07:45,770
you have that the spec defiance has a

00:07:43,570 --> 00:07:47,570
something called signature which is a

00:07:45,770 --> 00:07:50,840
string that defines what the data is

00:07:47,570 --> 00:07:53,300
every simple type has a one letter of

00:07:50,840 --> 00:07:56,350
course and then you create the container

00:07:53,300 --> 00:08:01,360
data types by combining the containers

00:07:56,350 --> 00:08:05,090
signature and contained type signature

00:08:01,360 --> 00:08:07,940
and the basic types actually quite map

00:08:05,090 --> 00:08:10,550
quite nicely to the rust basic data

00:08:07,940 --> 00:08:14,090
types that these are actually examples

00:08:10,550 --> 00:08:17,110
of rust data types and the deepest types

00:08:14,090 --> 00:08:19,250
are exactly the same so that's easy

00:08:17,110 --> 00:08:22,460
containers that's a bit complicated

00:08:19,250 --> 00:08:25,160
array is you know just in the rest we

00:08:22,460 --> 00:08:26,600
have a data type called vector it

00:08:25,160 --> 00:08:28,550
perhaps nicely to the we also have an

00:08:26,600 --> 00:08:31,070
array but vector is most used because

00:08:28,550 --> 00:08:36,170
it's dynamically allocated and it can

00:08:31,070 --> 00:08:38,690
grow and shrink dynamically so yeah and

00:08:36,170 --> 00:08:41,570
structure is like just like a struct in

00:08:38,690 --> 00:08:44,540
C or rust or many programming languages

00:08:41,570 --> 00:08:45,820
and we have a bunch of data that is put

00:08:44,540 --> 00:08:47,920
together

00:08:45,820 --> 00:08:50,410
so it's that's all so easy not so

00:08:47,920 --> 00:08:52,480
difficult and victory is also like it's

00:08:50,410 --> 00:08:54,610
in rust there is a in the standard

00:08:52,480 --> 00:08:56,800
library there is a data type called hash

00:08:54,610 --> 00:08:58,420
map and another programming languages

00:08:56,800 --> 00:09:00,520
you have something similar dictionary

00:08:58,420 --> 00:09:04,420
some dictionary or hash map and it maps

00:09:00,520 --> 00:09:05,740
nicely there and we have a bit difficult

00:09:04,420 --> 00:09:08,290
one we will see later

00:09:05,740 --> 00:09:12,210
it's called variant data type which is a

00:09:08,290 --> 00:09:15,580
generic data type in rust sorry in Debus

00:09:12,210 --> 00:09:17,680
and which means it's you have the

00:09:15,580 --> 00:09:20,260
signature of the data that you have

00:09:17,680 --> 00:09:23,560
inside and the actual data in there so

00:09:20,260 --> 00:09:25,960
you can put any kind of data data in in

00:09:23,560 --> 00:09:27,730
this variant so if you want to transfer

00:09:25,960 --> 00:09:31,660
it in a generic any data in a generic

00:09:27,730 --> 00:09:33,010
way you put it in a variant so that's

00:09:31,660 --> 00:09:35,920
the low level it seems pretty simple

00:09:33,010 --> 00:09:37,840
right and high level you have objects

00:09:35,920 --> 00:09:40,750
when you can when you connect to a

00:09:37,840 --> 00:09:43,120
service you talk to a specific object or

00:09:40,750 --> 00:09:46,120
objects and that service that it expose

00:09:43,120 --> 00:09:49,990
these are the ones for geo clue that you

00:09:46,120 --> 00:09:52,090
talk to and they these objects implement

00:09:49,990 --> 00:09:54,190
something all interfaces it's very

00:09:52,090 --> 00:09:57,700
similar to interface concept in

00:09:54,190 --> 00:10:01,540
programming languages and the API you

00:09:57,700 --> 00:10:04,930
have is on on the interfaces and basic

00:10:01,540 --> 00:10:06,820
API has methods when signal signal is

00:10:04,930 --> 00:10:10,720
just a method but in the other direction

00:10:06,820 --> 00:10:13,780
that you get a event from the service in

00:10:10,720 --> 00:10:18,210
terms of signal and method is something

00:10:13,780 --> 00:10:21,190
usually a app calls on the service and

00:10:18,210 --> 00:10:24,190
properties like you can these can be

00:10:21,190 --> 00:10:26,440
read only or read write as well and

00:10:24,190 --> 00:10:28,300
these are all on interfaces and objects

00:10:26,440 --> 00:10:31,840
implement those interfaces and they have

00:10:28,300 --> 00:10:33,550
those the API is then so I looked at all

00:10:31,840 --> 00:10:35,830
this and I was like this doesn't seem

00:10:33,550 --> 00:10:40,180
that difficult as I thought it would be

00:10:35,830 --> 00:10:43,210
so let's give it a shot so well I was at

00:10:40,180 --> 00:10:46,330
the HEC fest and a few days after I was

00:10:43,210 --> 00:10:48,910
I had like three days and I started

00:10:46,330 --> 00:10:50,350
putting something together and after

00:10:48,910 --> 00:10:53,140
three days I was able to establish a

00:10:50,350 --> 00:10:54,970
connection and I was able to call a

00:10:53,140 --> 00:10:57,400
method like a simple method but still

00:10:54,970 --> 00:10:58,889
able to successfully call it and like

00:10:57,400 --> 00:11:01,889
parse the return value

00:10:58,889 --> 00:11:03,600
stuff so I was like cool let's let's

00:11:01,889 --> 00:11:08,040
really do this because it doesn't seem

00:11:03,600 --> 00:11:09,779
that difficult so that's when I created

00:11:08,040 --> 00:11:17,369
this project called C bus which is just

00:11:09,779 --> 00:11:19,470
a rust crate for doing divas so I was

00:11:17,369 --> 00:11:21,660
like let's start with a simple part not

00:11:19,470 --> 00:11:24,149
simple but the the basic part the

00:11:21,660 --> 00:11:26,459
low-level for a bit and if I get that

00:11:24,149 --> 00:11:31,069
right then the high level stuff is cheb

00:11:26,459 --> 00:11:35,209
easy and so I came up with this trait

00:11:31,069 --> 00:11:37,910
anyone knows and what is a trait in rust

00:11:35,209 --> 00:11:41,369
can you raise your hands if you know

00:11:37,910 --> 00:11:44,910
okay most people don't know sorry

00:11:41,369 --> 00:11:48,689
so trait is like an interface in many

00:11:44,910 --> 00:11:53,220
like object-oriented languages you you

00:11:48,689 --> 00:11:55,470
define our API in in that trait and then

00:11:53,220 --> 00:11:58,319
any data type can implement that trait

00:11:55,470 --> 00:12:01,769
and then it has to provide all the API

00:11:58,319 --> 00:12:04,619
in that trade so this is like a trait

00:12:01,769 --> 00:12:10,139
for anything that can be encoded and

00:12:04,619 --> 00:12:12,360
decoded into Debus bar format so as you

00:12:10,139 --> 00:12:16,199
can see it has like signature every any

00:12:12,360 --> 00:12:20,489
type that you claims that it can go on

00:12:16,199 --> 00:12:22,290
d-bus it has to provide like what's the

00:12:20,489 --> 00:12:25,139
signature what's the alignment what's

00:12:22,290 --> 00:12:27,119
the how to it has to provide a method to

00:12:25,139 --> 00:12:27,809
encode it it has a provide a method to

00:12:27,119 --> 00:12:30,660
decode it

00:12:27,809 --> 00:12:32,910
don't bother will extract slice it's too

00:12:30,660 --> 00:12:35,790
much to explain right now and of course

00:12:32,910 --> 00:12:37,769
the signature that Lala's method which

00:12:35,790 --> 00:12:39,290
is the signature is actually four simple

00:12:37,769 --> 00:12:43,439
types it will be the same as the

00:12:39,290 --> 00:12:46,889
constant that you have because they just

00:12:43,439 --> 00:12:49,860
have one letter but for complex types it

00:12:46,889 --> 00:12:53,189
would the the method would return

00:12:49,860 --> 00:12:55,009
something that has the signature of the

00:12:53,189 --> 00:13:00,509
contained types as well not just

00:12:55,009 --> 00:13:04,079
container so I like start like this

00:13:00,509 --> 00:13:08,850
trait on simple basic types which was

00:13:04,079 --> 00:13:11,519
super easy and then container types as I

00:13:08,850 --> 00:13:11,950
said we have a vector vector can have

00:13:11,519 --> 00:13:16,090
some

00:13:11,950 --> 00:13:17,470
generics in interest if you want to

00:13:16,090 --> 00:13:20,650
define something where generic you can

00:13:17,470 --> 00:13:23,890
use these generic parameters but you can

00:13:20,650 --> 00:13:27,010
have bounds on these generic parameters

00:13:23,890 --> 00:13:28,660
or so for example here the back in the

00:13:27,010 --> 00:13:31,030
standard library is already defined as

00:13:28,660 --> 00:13:35,680
something that can keep any kind of data

00:13:31,030 --> 00:13:38,920
in it but I in here had constraint on it

00:13:35,680 --> 00:13:42,100
that for this one it has to be a variant

00:13:38,920 --> 00:13:44,350
type something that can be encoded to 2d

00:13:42,100 --> 00:13:46,720
bus as well the contain type and then

00:13:44,350 --> 00:13:50,380
the rest is just you know putting it

00:13:46,720 --> 00:13:53,650
together structure it doesn't map

00:13:50,380 --> 00:13:57,010
exactly to the struct in in rust but the

00:13:53,650 --> 00:13:58,750
thing is that's more static and what we

00:13:57,010 --> 00:14:01,390
need to send on D bus we need to prepare

00:13:58,750 --> 00:14:03,490
and put together is more dynamic so I

00:14:01,390 --> 00:14:06,910
needed a separate API so I had to create

00:14:03,490 --> 00:14:09,790
a separate data type and methods on that

00:14:06,910 --> 00:14:12,420
data type to create it and to to parse

00:14:09,790 --> 00:14:15,790
it and then of course the variant type

00:14:12,420 --> 00:14:18,310
trait was implemented on it and then the

00:14:15,790 --> 00:14:19,810
variant bit which is as I said it keeps

00:14:18,310 --> 00:14:22,360
the signature of what is contained

00:14:19,810 --> 00:14:25,060
inside and it keeps the actual and coded

00:14:22,360 --> 00:14:27,430
value in inside it

00:14:25,060 --> 00:14:31,930
which is why I thought is a good idea

00:14:27,430 --> 00:14:36,810
but later turns out it's not and this is

00:14:31,930 --> 00:14:40,920
the API in use it's my test unit tests

00:14:36,810 --> 00:14:44,560
you can create like since I 64 type

00:14:40,920 --> 00:14:48,400
implements variant type it can be put in

00:14:44,560 --> 00:14:52,810
a variant and yeah basic stuff like you

00:14:48,400 --> 00:14:56,380
encode it and you can then decode it can

00:14:52,810 --> 00:15:01,600
I do this yeah well this is this is

00:14:56,380 --> 00:15:06,400
decoding from raw data and yeah you get

00:15:01,600 --> 00:15:08,110
the same thing again back so but the

00:15:06,400 --> 00:15:10,750
thing is I lied before in my previous

00:15:08,110 --> 00:15:15,420
slide the trait that I showed is not as

00:15:10,750 --> 00:15:18,450
simple as I looked it had to has

00:15:15,420 --> 00:15:22,870
something called lifetimes in in rust

00:15:18,450 --> 00:15:24,920
you use lifetime parameters to tell the

00:15:22,870 --> 00:15:27,410
compiler what is the lifetimes of

00:15:24,920 --> 00:15:30,350
of the parameters and the return value

00:15:27,410 --> 00:15:33,170
and you associate the lifetimes of the

00:15:30,350 --> 00:15:35,510
parameters passed to a function - to the

00:15:33,170 --> 00:15:38,590
return value and also like you define

00:15:35,510 --> 00:15:42,710
lifetimes on the inner value of structs

00:15:38,590 --> 00:15:45,860
so yeah so we'd like ten it looks like

00:15:42,710 --> 00:15:48,610
this I'm not a fan of lifetime syntax in

00:15:45,860 --> 00:15:52,390
rust either but it's just the syntax

00:15:48,610 --> 00:15:56,300
that this makes things a bit harder

00:15:52,390 --> 00:15:59,780
although I was going for efficiency and

00:15:56,300 --> 00:16:02,120
lifetimes was the only way to keep

00:15:59,780 --> 00:16:05,270
things efficient so that I don't have to

00:16:02,120 --> 00:16:08,000
copy data I can just say okay whatever

00:16:05,270 --> 00:16:13,270
is passed to decoder the the slice of

00:16:08,000 --> 00:16:17,450
data that's lifetime is now the same as

00:16:13,270 --> 00:16:19,910
when you slice it and also the when you

00:16:17,450 --> 00:16:24,380
return something from the decoder so it

00:16:19,910 --> 00:16:27,650
has the same lifetime but well for a bit

00:16:24,380 --> 00:16:31,250
but I've ran into a lot of problems each

00:16:27,650 --> 00:16:34,100
time I change anything in the API in

00:16:31,250 --> 00:16:37,390
anyway lifetimes comes on the way and

00:16:34,100 --> 00:16:40,190
have to make sure that they are all ok

00:16:37,390 --> 00:16:42,980
if you haven't played with rust and ever

00:16:40,190 --> 00:16:44,930
it's very strict language that's the

00:16:42,980 --> 00:16:47,270
strength of it and also a bit of a

00:16:44,930 --> 00:16:49,910
problem then you first start coding in

00:16:47,270 --> 00:16:53,450
rust compiler complains a lot about

00:16:49,910 --> 00:16:55,130
everything and you hate yourself but

00:16:53,450 --> 00:16:57,950
when you get it to compile then your

00:16:55,130 --> 00:17:00,230
code works just fine like you you don't

00:16:57,950 --> 00:17:02,090
have to debug anything so that feeling

00:17:00,230 --> 00:17:04,610
is worth the trouble

00:17:02,090 --> 00:17:06,110
so yeah but in this case I had too much

00:17:04,610 --> 00:17:07,660
trouble and I don't think the shilling

00:17:06,110 --> 00:17:11,660
was worth it

00:17:07,660 --> 00:17:12,740
so back to T was right how does it look

00:17:11,660 --> 00:17:15,050
for Debus

00:17:12,740 --> 00:17:17,330
I have only basic stuff on the high

00:17:15,050 --> 00:17:20,750
level implemented like establishing a

00:17:17,330 --> 00:17:25,000
connection and calling a method based on

00:17:20,750 --> 00:17:29,690
the variants that I have defined you

00:17:25,000 --> 00:17:31,340
when you have a connection you just you

00:17:29,690 --> 00:17:33,770
know say it which service you want to

00:17:31,340 --> 00:17:37,130
use e which which objects you want to

00:17:33,770 --> 00:17:38,060
operate on and what's the interface name

00:17:37,130 --> 00:17:40,400
and then the

00:17:38,060 --> 00:17:42,410
method name and you can pass parameters

00:17:40,400 --> 00:17:45,530
and this is a simple case so there's no

00:17:42,410 --> 00:17:49,040
parameters to pass and then you get a

00:17:45,530 --> 00:17:51,560
reply and you can parse the reply body

00:17:49,040 --> 00:17:53,360
as a variant and then you can if you

00:17:51,560 --> 00:17:56,810
know you should know the type of what

00:17:53,360 --> 00:17:59,390
you are expecting so you say I want data

00:17:56,810 --> 00:18:02,150
and you give it the type exact type and

00:17:59,390 --> 00:18:03,710
you get the exact data of that type and

00:18:02,150 --> 00:18:09,430
then you can do whatever you want with

00:18:03,710 --> 00:18:11,570
it and I was like okay I can use the

00:18:09,430 --> 00:18:13,370
define all the variants that would

00:18:11,570 --> 00:18:16,370
create it for all the data types that

00:18:13,370 --> 00:18:18,920
are in Debus and I can call methods with

00:18:16,370 --> 00:18:23,090
it and stuff so I was like well maybe

00:18:18,920 --> 00:18:25,700
I'm done now I it's all done and hoping

00:18:23,090 --> 00:18:28,250
to put the variant in a separate crate

00:18:25,700 --> 00:18:29,930
first documented and stuff but then I

00:18:28,250 --> 00:18:32,120
realized something

00:18:29,930 --> 00:18:34,850
I added the last data type I added was

00:18:32,120 --> 00:18:38,840
the hash map and the test cases that I

00:18:34,850 --> 00:18:40,640
added were a bit extensive so they were

00:18:38,840 --> 00:18:43,610
failing and I thought maybe I'm it's a

00:18:40,640 --> 00:18:46,310
mistake in implementation or the audio

00:18:43,610 --> 00:18:49,220
test cases themselves I was looking at

00:18:46,310 --> 00:18:51,260
it for days and I realized that no that

00:18:49,220 --> 00:18:55,010
wasn't it it was like much something

00:18:51,260 --> 00:18:56,720
much much worse variant alignment was

00:18:55,010 --> 00:18:58,880
all wrong at that time the man had

00:18:56,720 --> 00:19:03,230
implemented and it only came out in that

00:18:58,880 --> 00:19:08,270
task is it turns out Debus has a strange

00:19:03,230 --> 00:19:10,370
few rules it's not all great the first

00:19:08,270 --> 00:19:11,780
first rule is alignment is based on the

00:19:10,370 --> 00:19:13,160
position in the message so if you have a

00:19:11,780 --> 00:19:16,010
message and you're putting different

00:19:13,160 --> 00:19:18,560
data in it the alignment of that each

00:19:16,010 --> 00:19:20,690
data is based on what's the position in

00:19:18,560 --> 00:19:24,440
the whole message not just a container

00:19:20,690 --> 00:19:27,710
what it's in which is fine it's not a

00:19:24,440 --> 00:19:30,470
big problem is easy to solve that as I

00:19:27,710 --> 00:19:32,690
showed you in the beginning the end code

00:19:30,470 --> 00:19:35,450
method and decode matter they don't take

00:19:32,690 --> 00:19:36,710
care of this day you just give it you

00:19:35,450 --> 00:19:39,110
just tell it like yeah and code yourself

00:19:36,710 --> 00:19:42,430
and you get a you got the pipe so you

00:19:39,110 --> 00:19:45,830
don't get any padding for the alignment

00:19:42,430 --> 00:19:48,340
but this is easy to solve you just add

00:19:45,830 --> 00:19:50,570
another parameter which I did later on

00:19:48,340 --> 00:19:51,260
until that like this these many bytes

00:19:50,570 --> 00:19:53,650
are before

00:19:51,260 --> 00:19:56,630
you and it aligns itself based on that

00:19:53,650 --> 00:19:59,150
but then there's another rule variant

00:19:56,630 --> 00:20:02,300
and the contain value the variant

00:19:59,150 --> 00:20:04,940
datatype I mentioned the generic one it

00:20:02,300 --> 00:20:08,410
does not need any alignment for itself

00:20:04,940 --> 00:20:12,140
and for the data that it contains

00:20:08,410 --> 00:20:14,770
however it can grandchildren do so if

00:20:12,140 --> 00:20:17,330
you have like a hash map inside variant

00:20:14,770 --> 00:20:19,970
but not the variant and the hash map

00:20:17,330 --> 00:20:21,890
does not need alignment but the keys and

00:20:19,970 --> 00:20:24,380
the values in it don't need an alignment

00:20:21,890 --> 00:20:27,680
and that makes things really difficult

00:20:24,380 --> 00:20:32,210
because when I then pass the whole

00:20:27,680 --> 00:20:34,910
information to do the encoding in there

00:20:32,210 --> 00:20:37,010
that oh you are inside you shouldn't be

00:20:34,910 --> 00:20:40,190
aligning yourself but you should be only

00:20:37,010 --> 00:20:42,050
allowing your children so yeah and that

00:20:40,190 --> 00:20:46,760
the current API doesn't take care of

00:20:42,050 --> 00:20:49,520
that so one this was one month ago about

00:20:46,760 --> 00:20:52,040
that I came across this issue and I

00:20:49,520 --> 00:20:55,760
still haven't fully solved it and the

00:20:52,040 --> 00:21:00,230
main reason is that lifetimes are are

00:20:55,760 --> 00:21:02,420
held to work with and I've learned a

00:21:00,230 --> 00:21:05,780
lesson through this whole thing and that

00:21:02,420 --> 00:21:07,850
is that efficiency is not a religion you

00:21:05,780 --> 00:21:09,680
shouldn't take it so religiously and I

00:21:07,850 --> 00:21:13,250
realized that what I was doing I got

00:21:09,680 --> 00:21:21,260
over we went overboard with efficiency

00:21:13,250 --> 00:21:24,560
so the the compromises that I'll make in

00:21:21,260 --> 00:21:27,020
C that I'll be fine with doing in C I

00:21:24,560 --> 00:21:29,990
was not okay with doing the the same in

00:21:27,020 --> 00:21:32,720
rust because I was trying to make it so

00:21:29,990 --> 00:21:35,210
efficient like it's it's not worth it

00:21:32,720 --> 00:21:36,980
there's api's that you can use to share

00:21:35,210 --> 00:21:40,430
data between different parts of record

00:21:36,980 --> 00:21:44,750
safely they are not as efficient as if

00:21:40,430 --> 00:21:46,400
you would just pass pointers around but

00:21:44,750 --> 00:21:47,680
they are not so inefficient after all

00:21:46,400 --> 00:21:50,570
actually they are more efficient than

00:21:47,680 --> 00:21:53,510
when you would do it in C for example

00:21:50,570 --> 00:21:56,210
and C in g oq i use something called g

00:21:53,510 --> 00:21:59,300
objects and the objects are reference

00:21:56,210 --> 00:22:01,820
counted by default and and that

00:21:59,300 --> 00:22:03,350
reference counting because the capi does

00:22:01,820 --> 00:22:04,730
not know if you will be using it in a

00:22:03,350 --> 00:22:08,150
multi-threaded environment or no

00:22:04,730 --> 00:22:11,780
so the reference counting is atomic by

00:22:08,150 --> 00:22:13,100
default and that that's not cheap if it

00:22:11,780 --> 00:22:14,630
depends on how many objects you have of

00:22:13,100 --> 00:22:18,230
course but if you have a lot of objects

00:22:14,630 --> 00:22:22,700
and it can be quite inefficient to have

00:22:18,230 --> 00:22:24,500
it atomic but rust has different data

00:22:22,700 --> 00:22:27,350
types for using in a single thread and

00:22:24,500 --> 00:22:29,480
multi-threaded environment the it's

00:22:27,350 --> 00:22:31,340
called RC it's called reference counted

00:22:29,480 --> 00:22:33,140
type you can it's just a container type

00:22:31,340 --> 00:22:36,530
you can put your data in it and then you

00:22:33,140 --> 00:22:39,050
can share it around in your code and

00:22:36,530 --> 00:22:41,090
it's not atomic so it's pretty efficient

00:22:39,050 --> 00:22:46,250
it's more efficient then I'll do it and

00:22:41,090 --> 00:22:48,170
see human I do it so first of all I need

00:22:46,250 --> 00:22:49,640
to solve this problem but before I solve

00:22:48,170 --> 00:22:52,040
this problem I have to kill the life

00:22:49,640 --> 00:22:54,380
times and do it tightly and efficiently

00:22:52,040 --> 00:23:03,410
but make the code a lot more easier to

00:22:54,380 --> 00:23:05,480
to change and so after that once I'm

00:23:03,410 --> 00:23:07,400
done with that I want to put the variant

00:23:05,480 --> 00:23:10,600
credit separately as I said people use

00:23:07,400 --> 00:23:13,580
this G variants in the wire format

00:23:10,600 --> 00:23:17,810
outside of Debus context as well so they

00:23:13,580 --> 00:23:20,090
can use it for that and then of course

00:23:17,810 --> 00:23:21,800
simple things that are Debus related

00:23:20,090 --> 00:23:24,170
receiving messages that I only can send

00:23:21,800 --> 00:23:25,730
right now signals which is pretty

00:23:24,170 --> 00:23:28,940
trivial once we have the sending and

00:23:25,730 --> 00:23:32,060
receiving messages and it's synchronous

00:23:28,940 --> 00:23:36,170
API so I want to have my API very

00:23:32,060 --> 00:23:38,540
synchronous because it's IO of course so

00:23:36,170 --> 00:23:42,200
you want it not to block the threads and

00:23:38,540 --> 00:23:45,200
stuff so far in rust world the async

00:23:42,200 --> 00:23:47,780
story was a bit in a limbo but recently

00:23:45,200 --> 00:23:50,630
it got all stable like there's this

00:23:47,780 --> 00:23:54,560
table API is for doing async and there

00:23:50,630 --> 00:23:56,930
is now a stable library called async STD

00:23:54,560 --> 00:23:59,840
which is the same as a standard library

00:23:56,930 --> 00:24:01,850
but async version of that and which

00:23:59,840 --> 00:24:04,010
looks really cool and I'm very looking

00:24:01,850 --> 00:24:08,330
forward to using that to prepare provide

00:24:04,010 --> 00:24:11,660
async api's and then once I have the

00:24:08,330 --> 00:24:13,850
low-level stuff done high level should

00:24:11,660 --> 00:24:16,160
be straight for you and of course core

00:24:13,850 --> 00:24:17,630
generation everyone I know that uses

00:24:16,160 --> 00:24:22,039
diva's usually use

00:24:17,630 --> 00:24:24,320
cogeneration Toyota dealer divas there

00:24:22,039 --> 00:24:25,669
are some communities where that's what

00:24:24,320 --> 00:24:28,220
they always tell you like if you have

00:24:25,669 --> 00:24:30,919
any problem at the leave us to directly

00:24:28,220 --> 00:24:33,410
handling divas they'll say why are you

00:24:30,919 --> 00:24:35,210
not using cogeneration so it's taken

00:24:33,410 --> 00:24:39,020
kind of for granted so I need to Ford

00:24:35,210 --> 00:24:41,419
that and also maybe macros that the rust

00:24:39,020 --> 00:24:44,150
has really powerful macro system you can

00:24:41,419 --> 00:24:46,940
do a lot with it and some things can be

00:24:44,150 --> 00:24:50,780
simpler if I provide macros for those

00:24:46,940 --> 00:24:55,010
things to handle and a lot of these

00:24:50,780 --> 00:25:03,650
things have easy stuff that I'm so

00:24:55,010 --> 00:25:05,630
that's it for me we have like two

00:25:03,650 --> 00:25:12,190
minutes for questions so does anybody

00:25:05,630 --> 00:25:21,190
have a question no no not really

00:25:12,190 --> 00:25:21,190
okay are you sure probably isn't there

00:25:22,210 --> 00:25:30,669
maybe I'm wrong isn't there already a G

00:25:26,480 --> 00:25:34,340
variant like the thing in gt2 RS used

00:25:30,669 --> 00:25:36,409
yeah but that's Anjali it's yeah since

00:25:34,340 --> 00:25:39,260
this is a library again yeah I know you

00:25:36,409 --> 00:25:41,870
don't want but now I want a purist over

00:25:39,260 --> 00:25:46,700
for sale like I want to have safe code

00:25:41,870 --> 00:25:49,490
for dealing with divas okay and as I

00:25:46,700 --> 00:25:51,770
said like that in that's actually at sea

00:25:49,490 --> 00:25:53,690
it will be more inefficient code that

00:25:51,770 --> 00:25:59,020
I'll be using so I want to give an

00:25:53,690 --> 00:26:01,120
official thank you for the talk is this

00:25:59,020 --> 00:26:02,240
is something that can be built

00:26:01,120 --> 00:26:06,049
reproducibly

00:26:02,240 --> 00:26:07,909
I appreciate you using cargo and so in

00:26:06,049 --> 00:26:09,830
my experience that pulls in the latest

00:26:07,909 --> 00:26:12,289
and greatest of everything every time

00:26:09,830 --> 00:26:15,530
you build and it makes it hard to do

00:26:12,289 --> 00:26:20,600
reproducible builds you mean like a lot

00:26:15,530 --> 00:26:23,750
of projects they're using unstable no my

00:26:20,600 --> 00:26:25,340
like at least right now I'm not using a

00:26:23,750 --> 00:26:27,140
lot of dependencies anyway like there

00:26:25,340 --> 00:26:29,130
are only three dependencies and they are

00:26:27,140 --> 00:26:31,740
all stable

00:26:29,130 --> 00:26:34,770
I thought like I have to use the

00:26:31,740 --> 00:26:36,750
unstable async stuff but now it got

00:26:34,770 --> 00:26:38,990
stabilized so I don't need to even for

00:26:36,750 --> 00:26:43,289
that I don't need to use any unstable

00:26:38,990 --> 00:26:46,679
stuff yeah so I'm going to do the nice

00:26:43,289 --> 00:26:51,419
thing and answer instead of asked with

00:26:46,679 --> 00:26:53,280
cargo one thing you can do so the idea

00:26:51,419 --> 00:26:56,400
is to semantic versioning so you have

00:26:53,280 --> 00:26:59,280
major minor patch level you can specify

00:26:56,400 --> 00:27:02,820
your dependency as only major or major

00:26:59,280 --> 00:27:06,539
minor or down to the patch level which

00:27:02,820 --> 00:27:07,559
then pins to the varying degrees of I

00:27:06,539 --> 00:27:11,130
want reproducible

00:27:07,559 --> 00:27:14,460
or I want latest and greatest and next

00:27:11,130 --> 00:27:16,350
to the cargo punk tunnel thingy they use

00:27:14,460 --> 00:27:20,130
for configuration there's also a cargo

00:27:16,350 --> 00:27:21,780
dot lock that gets generated and yes I'm

00:27:20,130 --> 00:27:23,159
not quite sure how it works usually it

00:27:21,780 --> 00:27:25,730
gets overwritten but there's some

00:27:23,159 --> 00:27:29,850
mechanism to actually lock that down and

00:27:25,730 --> 00:27:32,640
you could basically as distribution say

00:27:29,850 --> 00:27:35,220
keep the state around and the next time

00:27:32,640 --> 00:27:37,590
I want to rebuild use exactly those

00:27:35,220 --> 00:27:41,909
versions you've got that that point in

00:27:37,590 --> 00:27:44,309
time so cargo has support for it for it

00:27:41,909 --> 00:27:47,520
but I think most projects just go the

00:27:44,309 --> 00:27:49,770
major maybe minor but patch level just

00:27:47,520 --> 00:27:52,650
get the latest and greatest yeah but

00:27:49,770 --> 00:27:55,440
that's more using like the upstream what

00:27:52,650 --> 00:27:57,630
they want done a problem of cargo yeah

00:27:55,440 --> 00:27:59,880
but even with if you specify a version

00:27:57,630 --> 00:28:03,840
even if it's you just specify I'm

00:27:59,880 --> 00:28:06,750
sticking to this major version still it

00:28:03,840 --> 00:28:09,179
will get only the releases like it will

00:28:06,750 --> 00:28:11,130
download the release version not not

00:28:09,179 --> 00:28:12,690
from the git master unless you say it

00:28:11,130 --> 00:28:15,870
like I won't give some good master of

00:28:12,690 --> 00:28:19,250
this dependence okay we're out of time

00:28:15,870 --> 00:28:23,059
for questions so thank you

00:28:19,250 --> 00:28:23,059

YouTube URL: https://www.youtube.com/watch?v=FIIC-hCoH3Q


