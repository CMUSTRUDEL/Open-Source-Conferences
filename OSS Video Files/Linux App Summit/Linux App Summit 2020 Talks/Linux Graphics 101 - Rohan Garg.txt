Title: Linux Graphics 101 - Rohan Garg
Publication date: 2020-11-15
Playlist: Linux App Summit 2020 Talks
Description: 
	The ever growing popularity of ARM devices has meant a new market for Linux apps. However, unlike conventional platforms where we enjoy the stability of a well tested graphics stack, platforms based on the ARM architecture tend to be quirkier.

In this talk, I'll be talking about the basics of how the Linux Graphics stack works touching on how technologies such as DRM, DRI, and Mesa interact with each other and the history behind how we've come to the current Gallium design in mesa.

At the end of the talk attendees should have a better understanding of what goes on behind the scenes in the graphics world and a high level understanding of the Mesa/DRM architecture.

Furthermore, this should help Linux app developers gain a better understanding of mesa and allow for faster debugging of graphics issues on ARM devices.
Captions: 
	00:00:10,160 --> 00:00:14,240
all right

00:00:10,880 --> 00:00:15,519
uh hey everyone i am rohan i'm going to

00:00:14,240 --> 00:00:18,480
be talking about

00:00:15,519 --> 00:00:19,760
the next the next graphics stack i'm a

00:00:18,480 --> 00:00:21,359
consultant software engineer at

00:00:19,760 --> 00:00:24,720
collabora

00:00:21,359 --> 00:00:24,720
and let's get started

00:00:28,400 --> 00:00:33,120
so before we get into this presentation

00:00:31,119 --> 00:00:33,920
i am not yet an experienced graphics

00:00:33,120 --> 00:00:35,840
developer

00:00:33,920 --> 00:00:37,600
and i would recommend that you take my

00:00:35,840 --> 00:00:41,120
words with grain of salt

00:00:37,600 --> 00:00:41,120
and let me know if i'm wrong

00:00:42,480 --> 00:00:46,559
so since we're at linux apps summit the

00:00:44,879 --> 00:00:49,840
goal takes away from this talk

00:00:46,559 --> 00:00:51,840
for you as application developers uh

00:00:49,840 --> 00:00:53,680
should be an understanding of how the

00:00:51,840 --> 00:00:57,920
linux graphics stack

00:00:53,680 --> 00:00:58,879
works and the various components

00:00:57,920 --> 00:01:02,079
involved

00:00:58,879 --> 00:01:03,760
in in the graphics stack and as an

00:01:02,079 --> 00:01:07,040
application developer how can you

00:01:03,760 --> 00:01:09,760
help debug issues

00:01:07,040 --> 00:01:11,040
while developing your applications on on

00:01:09,760 --> 00:01:12,880
this stack

00:01:11,040 --> 00:01:15,280
this presentation is not going to be

00:01:12,880 --> 00:01:19,520
about how to use graphics apis

00:01:15,280 --> 00:01:22,400
or explaining what gpu drive gpus are

00:01:19,520 --> 00:01:24,080
or how to develop a gpu driver that's

00:01:22,400 --> 00:01:24,560
kind of the big agenda that i'd like to

00:01:24,080 --> 00:01:27,840
kind of

00:01:24,560 --> 00:01:27,840
talk about here

00:01:29,360 --> 00:01:33,200
all right so the linux graphics stack

00:01:32,560 --> 00:01:36,400
has

00:01:33,200 --> 00:01:40,000
essentially three major components to it

00:01:36,400 --> 00:01:42,479
uh as application developers you will

00:01:40,000 --> 00:01:44,560
be interacting with the graphics apis

00:01:42,479 --> 00:01:47,680
which are the first component

00:01:44,560 --> 00:01:48,240
underneath the graphics apis are the gpu

00:01:47,680 --> 00:01:50,399
drivers

00:01:48,240 --> 00:01:52,399
which are switched into user space and

00:01:50,399 --> 00:01:54,960
kernel space

00:01:52,399 --> 00:01:57,520
within the linux ecosystem the graphics

00:01:54,960 --> 00:01:58,960
api implementations as well as the use

00:01:57,520 --> 00:02:02,079
space drivers

00:01:58,960 --> 00:02:03,840
live in the mesa 3d software project

00:02:02,079 --> 00:02:06,840
uh whereas the current space drivers

00:02:03,840 --> 00:02:09,679
live in the linuxcon

00:02:06,840 --> 00:02:12,000
uh as as

00:02:09,679 --> 00:02:14,160
as application developers you will most

00:02:12,000 --> 00:02:16,080
often be interacting with

00:02:14,160 --> 00:02:17,360
either in the linux ecosystem you will

00:02:16,080 --> 00:02:21,280
be either interacting with

00:02:17,360 --> 00:02:24,319
opengl or the vulcan ecosystem

00:02:21,280 --> 00:02:26,480
uh on on windows system for example you

00:02:24,319 --> 00:02:29,840
would be interacting with direct3d

00:02:26,480 --> 00:02:29,840
i'm not going to be talking about that

00:02:30,560 --> 00:02:36,080
so the graphics api so what exactly does

00:02:33,760 --> 00:02:38,160
the graphics api give you

00:02:36,080 --> 00:02:39,519
a graphics api is an entry point for

00:02:38,160 --> 00:02:40,800
apple graphics applications and

00:02:39,519 --> 00:02:43,200
libraries

00:02:40,800 --> 00:02:46,400
it allows for extraction of the gpu

00:02:43,200 --> 00:02:49,280
pipeline configuration manipulation

00:02:46,400 --> 00:02:50,720
part of this pipeline is programmable

00:02:49,280 --> 00:02:52,640
and part of this program

00:02:50,720 --> 00:02:54,400
out of this power flying pipeline is

00:02:52,640 --> 00:02:57,519
configurable

00:02:54,400 --> 00:03:02,560
and you have the choice of either opengl

00:02:57,519 --> 00:03:02,560
or vulcan on linux ecosystem in the next

00:03:02,840 --> 00:03:05,680
ecosystem as i mentioned before part of

00:03:05,360 --> 00:03:09,200
the

00:03:05,680 --> 00:03:10,400
pipeline is programmable and the way you

00:03:09,200 --> 00:03:15,280
program this pipeline

00:03:10,400 --> 00:03:17,920
is through either glsl or hlsl

00:03:15,280 --> 00:03:19,920
and these programs are passed as part of

00:03:17,920 --> 00:03:22,720
the pipeline configuration

00:03:19,920 --> 00:03:24,799
and are compiled by the drivers to

00:03:22,720 --> 00:03:25,840
generate hardware specific bytecode

00:03:24,799 --> 00:03:28,319
these are the drive these are the

00:03:25,840 --> 00:03:33,840
user-based drivers i talked about

00:03:28,319 --> 00:03:33,840
just just a couple slides ago

00:03:34,480 --> 00:03:37,760
so there are two philosophies when it

00:03:36,080 --> 00:03:40,319
comes to the

00:03:37,760 --> 00:03:42,560
graphics apis one of them is opengl and

00:03:40,319 --> 00:03:45,920
the other one is falcon

00:03:42,560 --> 00:03:48,319
opengl is the more traditional way of

00:03:45,920 --> 00:03:52,400
doing things where it tries to hide as

00:03:48,319 --> 00:03:54,720
much as possible about the gpu internals

00:03:52,400 --> 00:03:56,480
whereas welcome provides much finer

00:03:54,720 --> 00:03:58,959
grade control

00:03:56,480 --> 00:04:00,480
essentially what this leads to is that

00:03:58,959 --> 00:04:01,680
welcome applications are much more

00:04:00,480 --> 00:04:03,840
verbose

00:04:01,680 --> 00:04:05,599
and more work for the developer but less

00:04:03,840 --> 00:04:08,799
work for the cpu

00:04:05,599 --> 00:04:10,560
this leads to better performances on cpu

00:04:08,799 --> 00:04:12,959
bound workloads

00:04:10,560 --> 00:04:16,159
this also means that drive bulk drivers

00:04:12,959 --> 00:04:16,159
are a lot more simpler

00:04:17,919 --> 00:04:24,560
so since gpu is a fairly complex piece

00:04:22,079 --> 00:04:27,040
we have the drivers for them are fairly

00:04:24,560 --> 00:04:29,840
complex as well

00:04:27,040 --> 00:04:29,840
and

00:04:32,000 --> 00:04:35,759
not all of the code that you need to

00:04:34,160 --> 00:04:38,160
write to run on a gpu

00:04:35,759 --> 00:04:39,680
needs to be run in a privileged context

00:04:38,160 --> 00:04:42,880
for this reason we

00:04:39,680 --> 00:04:45,600
split it we split the code between

00:04:42,880 --> 00:04:46,320
user space and kernel space this also

00:04:45,600 --> 00:04:48,000
leads to

00:04:46,320 --> 00:04:51,759
easier debugging since debugging in the

00:04:48,000 --> 00:04:51,759
user space is a lot more easier

00:04:54,160 --> 00:04:58,560
so first i'm going to be talking about

00:04:55,600 --> 00:04:58,560
the kernel drivers

00:04:58,639 --> 00:05:02,400
there are a couple of responsibilities

00:05:00,160 --> 00:05:05,759
that the kernel driver deals with

00:05:02,400 --> 00:05:07,120
such as memory command stream submission

00:05:05,759 --> 00:05:10,720
and scheduling

00:05:07,120 --> 00:05:11,440
interrupts and signaling these kernel

00:05:10,720 --> 00:05:13,759
drivers

00:05:11,440 --> 00:05:15,360
with open source user space drivers live

00:05:13,759 --> 00:05:18,720
in the linus tree

00:05:15,360 --> 00:05:22,479
and they are in driver's gpu

00:05:18,720 --> 00:05:24,639
drm whereas kernel is a plus

00:05:22,479 --> 00:05:27,039
close source user space drivers are out

00:05:24,639 --> 00:05:27,039
of trade

00:05:28,720 --> 00:05:32,160
the so the first thing that current

00:05:30,720 --> 00:05:33,759
drivers that

00:05:32,160 --> 00:05:36,720
their current gpu drivers need to deal

00:05:33,759 --> 00:05:38,479
with are is memory management

00:05:36,720 --> 00:05:41,120
in order to perform memory management in

00:05:38,479 --> 00:05:42,880
the kernel we in order to perform

00:05:41,120 --> 00:05:44,479
any sort of graphics related tasks in

00:05:42,880 --> 00:05:46,240
the kernel we have something called the

00:05:44,479 --> 00:05:48,560
drm framework

00:05:46,240 --> 00:05:49,840
within the drm framework there is a

00:05:48,560 --> 00:05:51,520
memory management framework

00:05:49,840 --> 00:05:52,960
called there are a couple of memory

00:05:51,520 --> 00:05:53,360
management framework frameworks called

00:05:52,960 --> 00:05:57,280
gem

00:05:53,360 --> 00:05:59,440
and dpm before we get into german ttm

00:05:57,280 --> 00:06:00,960
there are a couple of technologies that

00:05:59,440 --> 00:06:02,400
terminology that i'd like you to be

00:06:00,960 --> 00:06:04,960
comfortable with

00:06:02,400 --> 00:06:06,639
uh a buffer object for example is a

00:06:04,960 --> 00:06:09,919
region of memory to upload

00:06:06,639 --> 00:06:11,840
gpu data such as textures vertexes

00:06:09,919 --> 00:06:13,840
just treat it as a region of memory

00:06:11,840 --> 00:06:15,919
essentially for now

00:06:13,840 --> 00:06:18,840
and ioptral is the most common way for

00:06:15,919 --> 00:06:20,080
applications to interfere with device

00:06:18,840 --> 00:06:22,639
drivers

00:06:20,080 --> 00:06:24,800
and a command stream is a set of

00:06:22,639 --> 00:06:27,280
commands compromising a full job on the

00:06:24,800 --> 00:06:27,280
gpu

00:06:27,360 --> 00:06:35,840
everything good with that everyone good

00:06:28,880 --> 00:06:35,840
with that so far

00:06:38,080 --> 00:06:40,479
all right

00:06:41,199 --> 00:06:48,000
so ttm is the older frame

00:06:45,039 --> 00:06:49,360
well dtm is only used by one gpu driver

00:06:48,000 --> 00:06:52,400
that i'm aware of which is

00:06:49,360 --> 00:06:53,520
vm graphics where most other kernel

00:06:52,400 --> 00:06:57,280
drivers

00:06:53,520 --> 00:06:58,960
current gpu drivers will be using gem

00:06:57,280 --> 00:07:02,720
so that's that's the only one i want to

00:06:58,960 --> 00:07:05,759
be talking about so

00:07:02,720 --> 00:07:10,720
gpu drivers using gem expose

00:07:05,759 --> 00:07:13,120
eye off tools to do memory management

00:07:10,720 --> 00:07:15,360
tasks such as allocating buffer objects

00:07:13,120 --> 00:07:18,240
releasing buffer objects

00:07:15,360 --> 00:07:19,520
uh mapping buffer objects into gpu

00:07:18,240 --> 00:07:22,400
memory

00:07:19,520 --> 00:07:23,039
and so on and so forth they also provide

00:07:22,400 --> 00:07:26,400
a way to do

00:07:23,039 --> 00:07:28,160
cache maintenance and they also

00:07:26,400 --> 00:07:31,039
guarantee that buffer objects are

00:07:28,160 --> 00:07:33,759
referenced by a gpu job

00:07:31,039 --> 00:07:35,680
are properly mapped on the gpu side of

00:07:33,759 --> 00:07:36,960
things

00:07:35,680 --> 00:07:39,680
on the right you'll see a couple of

00:07:36,960 --> 00:07:41,520
examples of these eye octals

00:07:39,680 --> 00:07:43,280
so you can see there's one which creates

00:07:41,520 --> 00:07:46,560
buffer objects

00:07:43,280 --> 00:07:48,240
map stuffer objects and get the buffer

00:07:46,560 --> 00:07:51,599
object offset or the offset

00:07:48,240 --> 00:07:51,599
in memory essentially

00:07:54,720 --> 00:07:58,080
the next part of a gpu the next

00:07:57,360 --> 00:08:01,840
responsibility

00:07:58,080 --> 00:08:01,840
of the gpu driver is scheduling

00:08:02,560 --> 00:08:06,720
typically when you submit a gpu job it

00:08:05,680 --> 00:08:09,759
does not mean it will

00:08:06,720 --> 00:08:10,800
be executed immediately there might be

00:08:09,759 --> 00:08:13,680
several processes

00:08:10,800 --> 00:08:15,280
using the gpu in parallel and the gpu

00:08:13,680 --> 00:08:16,319
might just be busy when the request

00:08:15,280 --> 00:08:18,240
comes in

00:08:16,319 --> 00:08:19,919
so essentially submission means that you

00:08:18,240 --> 00:08:21,680
queue the command stream

00:08:19,919 --> 00:08:24,319
and each driver has an eye optim for

00:08:21,680 --> 00:08:26,080
that since these jobs can have

00:08:24,319 --> 00:08:27,759
in the commands interior command stream

00:08:26,080 --> 00:08:30,879
dependencies and user space

00:08:27,759 --> 00:08:33,760
the use phase driver knows that those

00:08:30,879 --> 00:08:35,279
uh the kernel space scheduler needs to

00:08:33,760 --> 00:08:37,599
know that as well

00:08:35,279 --> 00:08:38,320
and the rm provides a generic scheduling

00:08:37,599 --> 00:08:42,000
framework

00:08:38,320 --> 00:08:43,839
called drm shed which which allows you

00:08:42,000 --> 00:08:46,560
to pass that information from user space

00:08:43,839 --> 00:08:46,560
to kernel space

00:08:49,040 --> 00:08:52,640
so now that you have your memory now

00:08:51,680 --> 00:08:55,839
that you have your

00:08:52,640 --> 00:08:57,519
job submitted to the gpu how do you

00:08:55,839 --> 00:08:58,959
synchronize between the kernel space and

00:08:57,519 --> 00:09:01,839
the use space

00:08:58,959 --> 00:09:03,519
uh what happens essentially is on gpe

00:09:01,839 --> 00:09:05,360
side of things a interrupt

00:09:03,519 --> 00:09:07,200
is fired and this interrupt gets

00:09:05,360 --> 00:09:10,399
reported from the kernel space

00:09:07,200 --> 00:09:13,600
into user space uh in order to

00:09:10,399 --> 00:09:15,279
prove in order to propagate this

00:09:13,600 --> 00:09:16,880
information from kernel space to use

00:09:15,279 --> 00:09:20,160
space we use

00:09:16,880 --> 00:09:23,600
sync objects and pencils uh

00:09:20,160 --> 00:09:27,040
sensors allow for one job to reach

00:09:23,600 --> 00:09:28,880
another and sync objects allow for user

00:09:27,040 --> 00:09:32,320
space to be notified

00:09:28,880 --> 00:09:32,320
when a job has been completed

00:09:35,519 --> 00:09:39,040
all right everyone get so far with the

00:09:38,240 --> 00:09:41,279
kernel space

00:09:39,040 --> 00:09:51,839
side of things if you have any questions

00:09:41,279 --> 00:09:51,839
let me know in the chat

00:09:55,600 --> 00:10:05,839
all right

00:10:06,560 --> 00:10:19,839
a couple of questions coming in on the

00:10:07,920 --> 00:10:19,839
shared notes i'll just wait for that

00:10:25,200 --> 00:10:29,360
right so command streams are submission

00:10:27,760 --> 00:10:29,760
so the question is how is the command

00:10:29,360 --> 00:10:32,399
stream

00:10:29,760 --> 00:10:32,880
submitted does it also live in a buffer

00:10:32,399 --> 00:10:36,240
or is

00:10:32,880 --> 00:10:39,360
it sent via eye options uh so

00:10:36,240 --> 00:10:42,480
the command stream is submitted via ios

00:10:39,360 --> 00:10:46,640
uh essentially there is a structure

00:10:42,480 --> 00:10:49,600
that you fill out with a list of

00:10:46,640 --> 00:10:51,839
commands and submissions by the eye

00:10:49,600 --> 00:10:53,630
offers to the gpu to the kernel which

00:10:51,839 --> 00:10:56,750
submits it which should use it on the

00:10:53,630 --> 00:10:56,750
[Music]

00:10:58,839 --> 00:11:03,920
gpu

00:11:00,320 --> 00:11:04,959
all right so moving on to the user space

00:11:03,920 --> 00:11:06,800
driver

00:11:04,959 --> 00:11:08,800
a couple of roles of the user space

00:11:06,800 --> 00:11:11,440
driver are

00:11:08,800 --> 00:11:14,320
exposing one or several of graphics apis

00:11:11,440 --> 00:11:16,480
such as opengl or vulcan

00:11:14,320 --> 00:11:18,399
it also maintains which involves

00:11:16,480 --> 00:11:19,680
maintaining the api specific state

00:11:18,399 --> 00:11:22,240
machines

00:11:19,680 --> 00:11:23,360
uh managing any kind of rendering

00:11:22,240 --> 00:11:26,399
context

00:11:23,360 --> 00:11:28,160
compiling shaders the ones that we just

00:11:26,399 --> 00:11:30,480
talked about in earlier which were like

00:11:28,160 --> 00:11:31,680
which are written and opened in hlsl or

00:11:30,480 --> 00:11:34,880
glsl

00:11:31,680 --> 00:11:36,800
into hardware specific bytecode uh

00:11:34,880 --> 00:11:38,640
creating and populating and submitting

00:11:36,800 --> 00:11:41,279
command strings

00:11:38,640 --> 00:11:43,600
interacting with the windows system and

00:11:41,279 --> 00:11:46,079
synchronizing on renderer operations

00:11:43,600 --> 00:11:47,279
and essentially most of the

00:11:46,079 --> 00:11:51,040
functionality

00:11:47,279 --> 00:11:53,760
that you will be you will end up using

00:11:51,040 --> 00:11:53,760
in user space

00:11:54,560 --> 00:12:01,120
so there's a couple of graphics apis

00:11:57,680 --> 00:12:05,040
that that are provided by mesa

00:12:01,120 --> 00:12:07,600
so the first one is opengl and

00:12:05,040 --> 00:12:08,320
this is it provides it provides the

00:12:07,600 --> 00:12:12,000
front end

00:12:08,320 --> 00:12:14,000
for opengl and gles

00:12:12,000 --> 00:12:15,279
the modern day drivers make use of

00:12:14,000 --> 00:12:17,519
something called gallium which is a

00:12:15,279 --> 00:12:21,279
state tracker within mesa

00:12:17,519 --> 00:12:23,279
and the drivers are shared libraries

00:12:21,279 --> 00:12:25,760
that are loaded on demand

00:12:23,279 --> 00:12:27,839
whereas when it comes to vulcan chronos

00:12:25,760 --> 00:12:28,959
has its own driver loader that is open

00:12:27,839 --> 00:12:31,360
source

00:12:28,959 --> 00:12:33,279
mesa only provides the vulcan drivers

00:12:31,360 --> 00:12:36,480
and there are no abstractions

00:12:33,279 --> 00:12:40,720
for vulcan drivers or state tracking and

00:12:36,480 --> 00:12:40,720
code sharing is done through libraries

00:12:42,240 --> 00:12:46,160
so let's get into maker state tracking

00:12:44,079 --> 00:12:50,079
this is the pipeline configuration part

00:12:46,160 --> 00:12:50,079
of the gpu pipeline

00:12:50,240 --> 00:12:53,440
i'm not going to be talking about

00:12:51,680 --> 00:12:56,160
pre-gallium days

00:12:53,440 --> 00:12:57,600
uh a bunch of drivers such as i-965 and

00:12:56,160 --> 00:13:01,680
i'm n15

00:12:57,600 --> 00:13:04,959
use this but uh they are more or less on

00:13:01,680 --> 00:13:08,079
the way on their way out in favor of

00:13:04,959 --> 00:13:10,160
gallium so what

00:13:08,079 --> 00:13:12,560
exactly is gallium gallium is a state

00:13:10,160 --> 00:13:13,600
tractor that allows for tracking opengl

00:13:12,560 --> 00:13:16,399
stage

00:13:13,600 --> 00:13:17,839
and allows for easier driver development

00:13:16,399 --> 00:13:20,560
essentially

00:13:17,839 --> 00:13:21,839
what happens is that mesa will implement

00:13:20,560 --> 00:13:25,200
the opengl

00:13:21,839 --> 00:13:27,600
and opengl on top of gallium

00:13:25,200 --> 00:13:28,639
and galvin consumes functionality

00:13:27,600 --> 00:13:32,240
provided by

00:13:28,639 --> 00:13:34,720
device drivers which further consume

00:13:32,240 --> 00:13:36,959
functionality provided by kernels the

00:13:34,720 --> 00:13:40,000
kernel space device drivers

00:13:36,959 --> 00:13:44,480
this allows for

00:13:40,000 --> 00:13:47,680
much more easier creation of

00:13:44,480 --> 00:13:50,959
command streams and jobs

00:13:47,680 --> 00:13:52,720
as well as making sure any buffers that

00:13:50,959 --> 00:13:56,240
need to be synchronized

00:13:52,720 --> 00:13:57,760
get synchronized properly and it takes

00:13:56,240 --> 00:14:03,839
off a lot of work

00:13:57,760 --> 00:14:03,839
out of developing a driver

00:14:04,639 --> 00:14:08,480
when it comes to vulcan vulcan doesn't

00:14:07,839 --> 00:14:11,760
have

00:14:08,480 --> 00:14:14,399
gallium it only simply interacts with

00:14:11,760 --> 00:14:16,560
the kernel space drivers directly

00:14:14,399 --> 00:14:18,000
all of the state tracking for example

00:14:16,560 --> 00:14:21,199
will be left to

00:14:18,000 --> 00:14:21,199
an application developer

00:14:23,680 --> 00:14:27,760
right the next part is the the share

00:14:26,480 --> 00:14:29,680
compilation pass

00:14:27,760 --> 00:14:33,680
this is the pipeline manipulation part

00:14:29,680 --> 00:14:33,680
or the programmable part of the pipeline

00:14:34,480 --> 00:14:38,639
so shader compilation usually follows a

00:14:37,199 --> 00:14:42,839
couple of steps

00:14:38,639 --> 00:14:46,079
what essentially means is that the

00:14:42,839 --> 00:14:48,000
a language such as glsl or hlsl gets

00:14:46,079 --> 00:14:52,240
converted into a generic

00:14:48,000 --> 00:14:55,600
ir this ir gets

00:14:52,240 --> 00:14:58,639
optimized by the by the

00:14:55,600 --> 00:15:00,720
by mesa over a couple of passes

00:14:58,639 --> 00:15:02,880
and then this generic ir gets converted

00:15:00,720 --> 00:15:04,880
into gpu specific ir

00:15:02,880 --> 00:15:05,920
and then the gpu driver performs

00:15:04,880 --> 00:15:09,519
optimization

00:15:05,920 --> 00:15:10,880
in the gpu specific ir space and then we

00:15:09,519 --> 00:15:13,120
have the bytecode generation which

00:15:10,880 --> 00:15:16,240
essentially compiles this gpu specific

00:15:13,120 --> 00:15:18,399
ir into byte code so what does this

00:15:16,240 --> 00:15:21,839
actually look like

00:15:18,399 --> 00:15:23,600
kind of like this so let's say you have

00:15:21,839 --> 00:15:26,399
a glsl program

00:15:23,600 --> 00:15:29,759
and the way it will work is that the

00:15:26,399 --> 00:15:33,680
glsl will be converted into gls aliyah

00:15:29,759 --> 00:15:34,079
or scurvy for example this glsl ir will

00:15:33,680 --> 00:15:38,000
then

00:15:34,079 --> 00:15:40,160
be converted into tgsi or near

00:15:38,000 --> 00:15:42,320
and between each of these parcels

00:15:40,160 --> 00:15:43,279
there's also an optimization pass going

00:15:42,320 --> 00:15:47,199
on

00:15:43,279 --> 00:15:49,600
so once you convert glsl into glsl ir

00:15:47,199 --> 00:15:52,079
it'll be it'll have an optimization pass

00:15:49,600 --> 00:15:54,800
and then if you convert it into near

00:15:52,079 --> 00:15:55,680
it will also have an optimization path

00:15:54,800 --> 00:15:58,720
this snare

00:15:55,680 --> 00:15:59,759
then might be converted into midgar ir

00:15:58,720 --> 00:16:02,959
for example

00:15:59,759 --> 00:16:04,560
by the by the device driver itself which

00:16:02,959 --> 00:16:06,800
will then be further optimized

00:16:04,560 --> 00:16:08,399
and then convert then finally converted

00:16:06,800 --> 00:16:11,040
into bytecode

00:16:08,399 --> 00:16:13,279
this is one of the most tricky parts of

00:16:11,040 --> 00:16:16,560
writing a gpu driver

00:16:13,279 --> 00:16:19,680
from what i've seen simply because

00:16:16,560 --> 00:16:22,800
on gpus such as

00:16:19,680 --> 00:16:24,880
the mali gpus there is no there's

00:16:22,800 --> 00:16:28,800
actually no available documentation

00:16:24,880 --> 00:16:31,519
on how to convert this

00:16:28,800 --> 00:16:33,120
this new or intermediate representation

00:16:31,519 --> 00:16:36,720
into

00:16:33,120 --> 00:16:39,199
gpu byte code this is where the bulk

00:16:36,720 --> 00:16:40,480
of your development efforts gets spent

00:16:39,199 --> 00:16:43,040
on essentially

00:16:40,480 --> 00:16:44,000
uh it also has a big impact on driver

00:16:43,040 --> 00:16:47,120
performance

00:16:44,000 --> 00:16:50,720
so we really want to make sure that

00:16:47,120 --> 00:16:54,880
we the driver com like this by compiler

00:16:50,720 --> 00:16:54,880
is as optimized as it can be

00:16:55,920 --> 00:17:00,639
so debugging tips as as application

00:16:58,959 --> 00:17:01,040
developers this is probably one of the

00:17:00,639 --> 00:17:05,839
most

00:17:01,040 --> 00:17:05,839
useful parts of the presentation for you

00:17:06,240 --> 00:17:12,799
so gdp is your friend

00:17:09,280 --> 00:17:15,039
get comfortable with it uh

00:17:12,799 --> 00:17:16,839
essentially if you hit if you've done

00:17:15,039 --> 00:17:19,439
any sort of opengl programming in the

00:17:16,839 --> 00:17:21,360
past uh

00:17:19,439 --> 00:17:22,640
you will you will recognize that there's

00:17:21,360 --> 00:17:24,849
something called gl get

00:17:22,640 --> 00:17:26,319
error which allows you to

00:17:24,849 --> 00:17:28,640
[Music]

00:17:26,319 --> 00:17:29,919
to get errors from the opengl

00:17:28,640 --> 00:17:32,000
implementation

00:17:29,919 --> 00:17:33,760
within mesa this is implemented with the

00:17:32,000 --> 00:17:34,720
underscore mesa underscore error

00:17:33,760 --> 00:17:37,440
function

00:17:34,720 --> 00:17:39,520
and if you essentially break on this

00:17:37,440 --> 00:17:40,160
function you will have a back trace of

00:17:39,520 --> 00:17:43,039
exactly

00:17:40,160 --> 00:17:44,799
where mesa stopped executing or where

00:17:43,039 --> 00:17:48,480
exactly mesa

00:17:44,799 --> 00:17:49,280
through an error if you use a particular

00:17:48,480 --> 00:17:53,760
gl

00:17:49,280 --> 00:17:56,559
gl functions such as gl gen textures

00:17:53,760 --> 00:17:57,440
uh the equivalent mesa function for that

00:17:56,559 --> 00:18:02,240
entry point is

00:17:57,440 --> 00:18:02,240
underscore mesa underscore pool

00:18:02,400 --> 00:18:06,240
you can break on any of these functions

00:18:04,320 --> 00:18:08,640
to start stepping

00:18:06,240 --> 00:18:10,480
into the mesa implementation of a gl

00:18:08,640 --> 00:18:12,799
call

00:18:10,480 --> 00:18:14,640
while you're debugging enabling asserts

00:18:12,799 --> 00:18:17,200
is also a great way to ensure

00:18:14,640 --> 00:18:18,320
that all the conditions are being met

00:18:17,200 --> 00:18:21,679
and satisfied

00:18:18,320 --> 00:18:24,080
in the code you can also set the mesa

00:18:21,679 --> 00:18:26,799
debug environment variable

00:18:24,080 --> 00:18:28,720
and you can check out each every single

00:18:26,799 --> 00:18:30,080
driver has its own environment variables

00:18:28,720 --> 00:18:31,360
for debugging as well

00:18:30,080 --> 00:18:33,600
and i would recommend that you go to

00:18:31,360 --> 00:18:35,520
this to the link that's mentioned

00:18:33,600 --> 00:18:37,360
in the pres in the slides to for a

00:18:35,520 --> 00:18:40,240
complete list

00:18:37,360 --> 00:18:40,720
piglets the thing tests are some of the

00:18:40,240 --> 00:18:43,440
best

00:18:40,720 --> 00:18:44,640
are one of the best ways for you to an

00:18:43,440 --> 00:18:45,840
application developer to either

00:18:44,640 --> 00:18:49,600
understand

00:18:45,840 --> 00:18:53,280
a particular feature or a gl call uh

00:18:49,600 --> 00:18:57,200
piglet tests mesa has a comprehensive

00:18:53,280 --> 00:19:00,799
has a comprehensive test coverage and

00:18:57,200 --> 00:19:02,480
simply using gdp on one of the tests

00:19:00,799 --> 00:19:04,559
and breaking on any of the functions

00:19:02,480 --> 00:19:05,919
that that you need to debug or

00:19:04,559 --> 00:19:09,039
understand

00:19:05,919 --> 00:19:11,200
is a great way to have a minimal test

00:19:09,039 --> 00:19:13,760
case or a minimal entry point

00:19:11,200 --> 00:19:13,760
essentially

00:19:14,880 --> 00:19:22,080
all right so

00:19:18,320 --> 00:19:22,960
the gpu topic is quite big and it can be

00:19:22,080 --> 00:19:24,880
intimidating

00:19:22,960 --> 00:19:26,559
i have been working on this for the last

00:19:24,880 --> 00:19:30,480
year and a half

00:19:26,559 --> 00:19:32,720
and i still definitely

00:19:30,480 --> 00:19:33,520
am alone i just definitely have a lot to

00:19:32,720 --> 00:19:35,120
learn

00:19:33,520 --> 00:19:37,600
so i would recommend that you start

00:19:35,120 --> 00:19:40,480
small and choose a driver

00:19:37,600 --> 00:19:42,320
and stick with it till you understand

00:19:40,480 --> 00:19:45,360
large parts of it

00:19:42,320 --> 00:19:47,919
or the larger theme of the driver maybe

00:19:45,360 --> 00:19:50,640
find a feature that's missing or buggy

00:19:47,919 --> 00:19:52,880
and just don't give up just keep at it

00:19:50,640 --> 00:19:53,919
and come hang out with us on irc ask

00:19:52,880 --> 00:19:56,880
questions

00:19:53,919 --> 00:19:58,559
there's a whole bunch of nice people uh

00:19:56,880 --> 00:20:00,080
who will help you and try to kind of get

00:19:58,559 --> 00:20:03,280
things working

00:20:00,080 --> 00:20:04,559
things take a while but if you just keep

00:20:03,280 --> 00:20:07,840
at it

00:20:04,559 --> 00:20:07,840
you'll you'll do great

00:20:09,760 --> 00:20:13,120
this is a couple of good uh resources

00:20:12,480 --> 00:20:16,320
that i would

00:20:13,120 --> 00:20:18,640
recommend that you read just get a

00:20:16,320 --> 00:20:22,159
general overview of how

00:20:18,640 --> 00:20:24,400
opengl works or how gpu works

00:20:22,159 --> 00:20:27,520
or to get a better understanding of the

00:20:24,400 --> 00:20:29,280
drm framework in the linux kernel

00:20:27,520 --> 00:20:31,600
and also go check out my colleagues

00:20:29,280 --> 00:20:35,120
stock

00:20:31,600 --> 00:20:37,120
at there's a whole bunch of talks that

00:20:35,120 --> 00:20:40,000
come out at elc

00:20:37,120 --> 00:20:41,200
that are great resources to learn

00:20:40,000 --> 00:20:45,039
specific things

00:20:41,200 --> 00:20:48,320
about the gpu driver

00:20:45,039 --> 00:20:51,360
community uh i would say uh so go check

00:20:48,320 --> 00:20:51,360
those out on youtube

00:20:52,559 --> 00:21:03,840
and that's it from my side uh does

00:20:54,480 --> 00:21:03,840
anyone have any other questions

00:21:45,840 --> 00:21:49,039
all right so one of the questions is

00:21:47,840 --> 00:21:51,360
which page of the framework is

00:21:49,039 --> 00:21:53,760
responsible for shaders

00:21:51,360 --> 00:21:54,960
and where do they get injected so

00:21:53,760 --> 00:21:58,559
shaders essentially

00:21:54,960 --> 00:22:01,679
are programs that application

00:21:58,559 --> 00:22:04,960
drivers application

00:22:01,679 --> 00:22:08,559
developers will write uh

00:22:04,960 --> 00:22:08,559
let me see if i can go back a couple of

00:22:10,840 --> 00:22:16,499
slides

00:22:13,410 --> 00:22:16,499
[Music]

00:22:16,799 --> 00:22:22,400
all right so shaders

00:22:20,000 --> 00:22:23,919
are written at the application layer

00:22:22,400 --> 00:22:27,919
over here

00:22:23,919 --> 00:22:29,600
and they get passed to galleon

00:22:27,919 --> 00:22:31,919
and then they got it passed to the

00:22:29,600 --> 00:22:34,960
use-based drivers

00:22:31,919 --> 00:22:38,240
and these are essentially programs like

00:22:34,960 --> 00:22:40,559
c or c there's c like programs

00:22:38,240 --> 00:22:42,400
and they get compiled just like you

00:22:40,559 --> 00:22:44,480
would compile for example a c program

00:22:42,400 --> 00:22:48,159
they have a compiler

00:22:44,480 --> 00:22:50,080
and except in this case every single

00:22:48,159 --> 00:22:53,280
driver has a compiler

00:22:50,080 --> 00:22:55,840
uh there isn't a standard gcc compiler

00:22:53,280 --> 00:22:55,840
and

00:22:56,640 --> 00:23:00,559
and in order to compile these programs

00:22:58,559 --> 00:23:04,240
you first have to convert

00:23:00,559 --> 00:23:07,440
them from this c like format to a

00:23:04,240 --> 00:23:10,159
ir format such as near or

00:23:07,440 --> 00:23:10,159
dgsi

00:23:10,880 --> 00:23:14,240
does that answer your question

00:23:21,840 --> 00:23:26,640
awesome one of the other questions was

00:23:27,280 --> 00:23:31,440
i think someone asked why are nvidia

00:23:29,120 --> 00:23:34,320
drivers so buggy jonathan

00:23:31,440 --> 00:23:35,360
i have no clue uh i think writing

00:23:34,320 --> 00:23:39,120
drivers is

00:23:35,360 --> 00:23:39,120
i think writing gpu drivers is

00:23:39,520 --> 00:23:43,510
pretty difficult uh especially when as a

00:23:42,320 --> 00:23:44,960
company you have to

00:23:43,510 --> 00:23:46,880
[Music]

00:23:44,960 --> 00:23:48,000
support a wide range of products across

00:23:46,880 --> 00:23:51,200
a vibration right

00:23:48,000 --> 00:23:54,240
wide range of platforms

00:23:51,200 --> 00:23:55,600
we as mesa developers have a slightly

00:23:54,240 --> 00:23:59,200
easier job

00:23:55,600 --> 00:24:00,000
slightly easier job uh that we only have

00:23:59,200 --> 00:24:03,360
to kind of support

00:24:00,000 --> 00:24:04,880
the next at the moment and the fact that

00:24:03,360 --> 00:24:06,080
we have such a large and active

00:24:04,880 --> 00:24:09,360
community

00:24:06,080 --> 00:24:11,279
also definitely helps uh i think it's

00:24:09,360 --> 00:24:13,200
nbc kind of wants to come join us

00:24:11,279 --> 00:24:15,440
in the in the mesa world they should

00:24:13,200 --> 00:24:19,919
they should definitely come do that

00:24:15,440 --> 00:24:19,919
maybe maybe we can learn from each other

00:24:38,960 --> 00:24:42,880
so the next question is what is the

00:24:40,960 --> 00:24:46,960
status of vulcan integration

00:24:42,880 --> 00:24:50,000
in mesa

00:24:46,960 --> 00:24:50,000
let's see so

00:24:50,480 --> 00:24:53,679
that's a very that's a tricky question

00:24:52,080 --> 00:24:56,159
to answer essentially because of the

00:24:53,679 --> 00:24:59,360
fact that there are

00:24:56,159 --> 00:25:01,440
new standards uh uh coming out ev

00:24:59,360 --> 00:25:02,720
every single time you have a new opengl

00:25:01,440 --> 00:25:04,000
standard coming out there is new

00:25:02,720 --> 00:25:06,240
functionality that needs to be

00:25:04,000 --> 00:25:08,320
implemented implemented

00:25:06,240 --> 00:25:10,880
the answer would be it's never going to

00:25:08,320 --> 00:25:10,880
be complete

00:25:11,450 --> 00:25:16,640
[Music]

00:25:13,200 --> 00:25:18,720
and so at the moment i don't really know

00:25:16,640 --> 00:25:20,320
how what percentage of the tests are

00:25:18,720 --> 00:25:21,039
passing what percentage of the pigment

00:25:20,320 --> 00:25:23,520
tests for

00:25:21,039 --> 00:25:26,799
vulcan are passing that is something

00:25:23,520 --> 00:25:26,799
that i will i will need to go and look

00:25:26,840 --> 00:25:32,720
out

00:25:29,679 --> 00:25:36,159
but from my understanding

00:25:32,720 --> 00:25:37,520
it is in a pretty good shape

00:25:36,159 --> 00:25:40,840
there i'm definitely i've definitely

00:25:37,520 --> 00:25:43,840
seen games running on vulcan on linux

00:25:40,840 --> 00:25:57,840
so decently complete

00:25:43,840 --> 00:25:57,840
enough enough to run again complete

00:26:07,440 --> 00:26:11,840
thank you so much rohan

00:26:12,080 --> 00:26:16,159
we still have a couple more minutes in

00:26:13,679 --> 00:26:19,840
case anyone wants to add another

00:26:16,159 --> 00:26:22,960
question otherwise

00:26:19,840 --> 00:26:24,799
thank you so very much um and i hope

00:26:22,960 --> 00:26:26,400
you enjoy the rest of the conference and

00:26:24,799 --> 00:26:29,520
you're able to stay in

00:26:26,400 --> 00:26:29,520
and watch with us

00:26:32,320 --> 00:26:36,320
absolutely and if you have any more

00:26:34,000 --> 00:26:36,720
questions i am shade slayer on irc you

00:26:36,320 --> 00:26:39,840
can

00:26:36,720 --> 00:26:39,840
throw those questions over there

00:26:40,080 --> 00:26:47,520
we have a bunch of irc channels

00:26:43,760 --> 00:26:47,520

YouTube URL: https://www.youtube.com/watch?v=9STbHrrHpDw


