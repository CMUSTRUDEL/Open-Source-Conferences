Title: Netdev 0x14 - Tutorial: XDP and the cloud : Using XDP on hosts and VMs
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Instructor: David Ahern

More info: https://netdevconf.info/0x14/session.html?tutorial-XDP-and-the-cloud

Date: Friday, August 14, 2020

David Ahern gives a tutorial on integrating XDP in
a cloud deployment with VMs and containers.
The tutorial is interactive with source dissection and live demos
(with the source code available later from github).

David will look at the current state of XDP through the lens of
cloud hosting, discussing the advantages, trade-offs, and limitations
of using XDP on the host with the v5.4 kernel (latest LTS).

This tutorial covers:
- configuration of the host,
- walks through an L2 forwarding program,
- management of the fdb and device maps using bpftool,
- simple per-VM/container ACL via eBPF,
- XDP forwarding in the egress path, and
- using XDP in VMs running on the host.
Captions: 
	00:00:03,120 --> 00:00:06,879
all right

00:00:03,679 --> 00:00:09,840
so my name is david ahern and

00:00:06,879 --> 00:00:11,040
i joined digitalocean last what last

00:00:09,840 --> 00:00:13,759
august

00:00:11,040 --> 00:00:14,880
and almost immediately started looking

00:00:13,759 --> 00:00:17,920
at

00:00:14,880 --> 00:00:18,720
how to replace kind of a legacy bridge

00:00:17,920 --> 00:00:21,760
model for

00:00:18,720 --> 00:00:24,720
networking with xdp

00:00:21,760 --> 00:00:26,080
and hit a lot of roadblocks a lot of

00:00:24,720 --> 00:00:28,400
lessons learned

00:00:26,080 --> 00:00:29,679
and i thought you know why not give a

00:00:28,400 --> 00:00:31,359
tutorial

00:00:29,679 --> 00:00:32,880
share the code that i've created that

00:00:31,359 --> 00:00:35,840
shows how to do

00:00:32,880 --> 00:00:36,880
an equivalent setup like an obs

00:00:35,840 --> 00:00:38,320
networking

00:00:36,880 --> 00:00:40,960
and then also share all the lessons

00:00:38,320 --> 00:00:43,040
learned that the the kind of the

00:00:40,960 --> 00:00:44,000
pain points that i picked up during that

00:00:43,040 --> 00:00:46,960
time of working on this

00:00:44,000 --> 00:00:48,480
code so that's kind of the premise of

00:00:46,960 --> 00:00:51,680
the tutorial

00:00:48,480 --> 00:00:52,079
and then set some context on what i mean

00:00:51,680 --> 00:00:54,480
by

00:00:52,079 --> 00:00:55,440
you know hypervisor networking this is

00:00:54,480 --> 00:00:59,199
what a standard

00:00:55,440 --> 00:01:01,600
a typical setup is for for a host

00:00:59,199 --> 00:01:02,719
host networking where you've got two

00:01:01,600 --> 00:01:05,920
ingress necks

00:01:02,719 --> 00:01:08,479
into an lacp bond and then

00:01:05,920 --> 00:01:09,600
the bond and all the tap devices for the

00:01:08,479 --> 00:01:11,840
virtual machines

00:01:09,600 --> 00:01:14,080
so the virtual machines are using

00:01:11,840 --> 00:01:16,240
virtionet with tap plus vhost

00:01:14,080 --> 00:01:18,240
to have accelerated networking and then

00:01:16,240 --> 00:01:21,520
all those tap devices plug into

00:01:18,240 --> 00:01:25,119
a bridge whether it's linux bridge or

00:01:21,520 --> 00:01:27,920
obs and so the idea is that

00:01:25,119 --> 00:01:30,000
packets coming in from the wire most of

00:01:27,920 --> 00:01:32,159
them can go to the virtual machines

00:01:30,000 --> 00:01:33,840
maybe a few show up to host processes

00:01:32,159 --> 00:01:36,880
for prometheus

00:01:33,840 --> 00:01:38,400
or system system needs

00:01:36,880 --> 00:01:40,159
and so you want to get those packets

00:01:38,400 --> 00:01:41,040
from the network into the virtual

00:01:40,159 --> 00:01:43,200
machines

00:01:41,040 --> 00:01:44,799
with the least overhead as possible

00:01:43,200 --> 00:01:46,479
right so the intent is you want all the

00:01:44,799 --> 00:01:49,040
host cycles to be spent

00:01:46,479 --> 00:01:52,799
running virtual machines as opposed to

00:01:49,040 --> 00:01:52,799
processing packets for those vms

00:01:53,119 --> 00:01:56,880
so those of us who have been following

00:01:55,920 --> 00:02:00,159
net dab know i

00:01:56,880 --> 00:02:01,600
am an advocate for coexistence

00:02:00,159 --> 00:02:03,439
um i don't think that everything should

00:02:01,600 --> 00:02:06,960
be rewritten in ebpf

00:02:03,439 --> 00:02:09,520
i think you do the fast parts in xdp

00:02:06,960 --> 00:02:10,319
and you use the full stack for things

00:02:09,520 --> 00:02:13,680
like learning

00:02:10,319 --> 00:02:14,800
or um bum traffic any kind of you know

00:02:13,680 --> 00:02:17,840
whatever you want to label as

00:02:14,800 --> 00:02:19,599
unknown multicast broadcast traffic um

00:02:17,840 --> 00:02:23,840
have that use the full stack to figure

00:02:19,599 --> 00:02:23,840
out where it needs to go

00:02:24,000 --> 00:02:30,560
all right so packet processing with xdp

00:02:27,520 --> 00:02:33,120
xdp essentially bypasses

00:02:30,560 --> 00:02:35,040
all the networking stack so the idea is

00:02:33,120 --> 00:02:38,640
you're running a program

00:02:35,040 --> 00:02:40,239
in the driver for that nick and

00:02:38,640 --> 00:02:42,000
the program can do something like a

00:02:40,239 --> 00:02:44,720
redirect to

00:02:42,000 --> 00:02:45,920
send the packet straight to a tap device

00:02:44,720 --> 00:02:47,680
so the virtual machine is going to

00:02:45,920 --> 00:02:50,239
receive that packet

00:02:47,680 --> 00:02:51,360
how that redirect decision is made is

00:02:50,239 --> 00:02:53,920
really up to

00:02:51,360 --> 00:02:55,280
the ebpf program or the system architect

00:02:53,920 --> 00:02:56,400
that's doing the networking for that

00:02:55,280 --> 00:03:00,159
node

00:02:56,400 --> 00:03:03,200
so one thing you could do is have an fdb

00:03:00,159 --> 00:03:06,720
so essentially tap into the bridge fdb

00:03:03,200 --> 00:03:08,080
and have it say this mac address and

00:03:06,720 --> 00:03:10,640
this vlan

00:03:08,080 --> 00:03:11,840
goes to this next device and have a

00:03:10,640 --> 00:03:15,040
redirect

00:03:11,840 --> 00:03:17,280
or you could use slash 32 host routing

00:03:15,040 --> 00:03:19,200
and use the fill lookup helper that was

00:03:17,280 --> 00:03:21,360
added a few years ago

00:03:19,200 --> 00:03:23,599
to look at the network address and say

00:03:21,360 --> 00:03:27,280
oh well this packet goes to

00:03:23,599 --> 00:03:29,680
this virtual machine so the

00:03:27,280 --> 00:03:31,120
l2 kind of lookup doesn't exist today

00:03:29,680 --> 00:03:34,480
there's an rfc for it

00:03:31,120 --> 00:03:36,159
as a way to tap into the bridge fdb so

00:03:34,480 --> 00:03:38,239
for this tutorial i'm just going to make

00:03:36,159 --> 00:03:42,080
use of a map

00:03:38,239 --> 00:03:43,360
and after creating this

00:03:42,080 --> 00:03:46,239
and seeing some of the performance

00:03:43,360 --> 00:03:47,519
numbers i really think the map is going

00:03:46,239 --> 00:03:49,840
to outperform

00:03:47,519 --> 00:03:51,519
anything that you can do by exporting a

00:03:49,840 --> 00:03:54,560
bridge helper

00:03:51,519 --> 00:03:56,799
and there's going to be use cases where

00:03:54,560 --> 00:03:58,239
you need the bridge to do the learning

00:03:56,799 --> 00:04:00,959
to do the aging

00:03:58,239 --> 00:04:02,879
and there's going to be use cases where

00:04:00,959 --> 00:04:05,439
you're in control of the hv

00:04:02,879 --> 00:04:06,879
you know what vms you're running on it

00:04:05,439 --> 00:04:08,080
you know their network address you know

00:04:06,879 --> 00:04:10,480
their mac address

00:04:08,080 --> 00:04:12,080
so you don't need learning so which case

00:04:10,480 --> 00:04:13,280
a static map to me

00:04:12,080 --> 00:04:17,040
seems like it's going to make the most

00:04:13,280 --> 00:04:19,440
sense for something like a cloud host

00:04:17,040 --> 00:04:21,359
so for those who aren't familiar with uh

00:04:19,440 --> 00:04:24,240
with xdp or bpf

00:04:21,359 --> 00:04:25,600
this is a per packet and per vm decision

00:04:24,240 --> 00:04:28,240
so

00:04:25,600 --> 00:04:28,800
each packet that comes into the driver

00:04:28,240 --> 00:04:30,320
this pro

00:04:28,800 --> 00:04:32,960
you know whatever program is attached to

00:04:30,320 --> 00:04:35,440
that net device gets run on each packet

00:04:32,960 --> 00:04:38,560
individually

00:04:35,440 --> 00:04:41,440
uh and also vms are untrusted

00:04:38,560 --> 00:04:42,400
so a part of what you want to do in xdp

00:04:41,440 --> 00:04:44,560
is not just say

00:04:42,400 --> 00:04:46,560
well packet showed up at the hv i'm

00:04:44,560 --> 00:04:48,479
going to send it to this virtual machine

00:04:46,560 --> 00:04:49,680
you also need to validate what those vms

00:04:48,479 --> 00:04:51,680
are sending

00:04:49,680 --> 00:04:53,680
so that keeps them from spoofing source

00:04:51,680 --> 00:04:57,440
address source max for example

00:04:53,680 --> 00:04:59,520
and polluting switches or

00:04:57,440 --> 00:05:00,720
pretending to be some other host on your

00:04:59,520 --> 00:05:04,639
on your network

00:05:00,720 --> 00:05:04,639
so part of what i'll get into is

00:05:04,720 --> 00:05:10,639
doing some validation of what packets of

00:05:07,120 --> 00:05:14,479
vms are sending

00:05:10,639 --> 00:05:16,240
okay so the host that i'm using

00:05:14,479 --> 00:05:18,080
when i wrote the description for this

00:05:16,240 --> 00:05:20,320
tutorial back in like december i was

00:05:18,080 --> 00:05:22,080
going to do 5.4 kernel

00:05:20,320 --> 00:05:23,919
since the the tutorial the conference

00:05:22,080 --> 00:05:25,440
got delayed tutorials delayed it's a

00:05:23,919 --> 00:05:29,199
little more developed

00:05:25,440 --> 00:05:30,240
and the 5.8 kernel has a feature in it

00:05:29,199 --> 00:05:33,039
that

00:05:30,240 --> 00:05:34,880
i need for this so i shipped it over to

00:05:33,039 --> 00:05:38,160
the 5.8 kernel

00:05:34,880 --> 00:05:39,199
it's a stock ubuntu 1804 um operating

00:05:38,160 --> 00:05:42,639
system

00:05:39,199 --> 00:05:44,240
the nics are melanox connect x4

00:05:42,639 --> 00:05:46,080
uh it's a typical host network

00:05:44,240 --> 00:05:47,440
configuration like i mentioned for the

00:05:46,080 --> 00:05:50,560
the full stack

00:05:47,440 --> 00:05:51,600
and then for the virtual machines they

00:05:50,560 --> 00:05:53,520
can be on

00:05:51,600 --> 00:05:54,800
two different two different networks so

00:05:53,520 --> 00:05:55,440
for example they can have a public

00:05:54,800 --> 00:05:57,919
address

00:05:55,440 --> 00:05:59,039
or they can have a private address in

00:05:57,919 --> 00:06:00,479
which case

00:05:59,039 --> 00:06:02,960
you're typically doing some kind of

00:06:00,479 --> 00:06:05,840
encapsulation like a vxlan

00:06:02,960 --> 00:06:07,759
and those packets would only go to other

00:06:05,840 --> 00:06:08,800
vms in that tenant for that for that

00:06:07,759 --> 00:06:10,319
tenant

00:06:08,800 --> 00:06:12,720
and then of course the networking is tap

00:06:10,319 --> 00:06:15,520
plus vhost

00:06:12,720 --> 00:06:17,199
so before i get into some of the details

00:06:15,520 --> 00:06:20,560
i want to remind everyone

00:06:17,199 --> 00:06:21,120
the directions for tap device when a tap

00:06:20,560 --> 00:06:23,440
device

00:06:21,120 --> 00:06:24,400
is transmitting a packet or the tx path

00:06:23,440 --> 00:06:26,319
for a tap device

00:06:24,400 --> 00:06:27,759
that's a packet going to the virtual

00:06:26,319 --> 00:06:30,479
machine so from the host

00:06:27,759 --> 00:06:32,319
being transmitted to the vm and then the

00:06:30,479 --> 00:06:33,759
rx path for a tap device

00:06:32,319 --> 00:06:36,000
is a packet coming from the virtual

00:06:33,759 --> 00:06:38,319
machine coming into the host and so the

00:06:36,000 --> 00:06:39,680
tap device is receiving it

00:06:38,319 --> 00:06:41,520
so that gets important when you start

00:06:39,680 --> 00:06:44,800
thinking about um

00:06:41,520 --> 00:06:44,800
what you're attaching and where

00:06:45,520 --> 00:06:49,759
all right so let's start by looking at

00:06:47,919 --> 00:06:51,120
host and grass traffic

00:06:49,759 --> 00:06:53,360
so what i'm going to do first is i'm

00:06:51,120 --> 00:06:54,319
going to describe some of the problem to

00:06:53,360 --> 00:06:55,680
be solved

00:06:54,319 --> 00:06:58,000
and then i'm going to switch screens and

00:06:55,680 --> 00:07:00,400
go into the code

00:06:58,000 --> 00:07:02,160
that you know i written as a prototype

00:07:00,400 --> 00:07:04,560
for how to do some of the stuff

00:07:02,160 --> 00:07:06,160
and then when i get through the three

00:07:04,560 --> 00:07:08,880
different descriptions

00:07:06,160 --> 00:07:10,080
jump into an actual demo so i'll have a

00:07:08,880 --> 00:07:11,840
host on our

00:07:10,080 --> 00:07:14,319
internal development network running all

00:07:11,840 --> 00:07:14,319
this code

00:07:14,840 --> 00:07:18,479
okay so layer two forwarding so the

00:07:17,120 --> 00:07:21,280
first thing you gotta do

00:07:18,479 --> 00:07:23,360
packets coming into the host is you're

00:07:21,280 --> 00:07:25,120
gonna attach a program onto each zero

00:07:23,360 --> 00:07:28,000
and each one so that's the

00:07:25,120 --> 00:07:29,280
the base um ingress mix so you can't do

00:07:28,000 --> 00:07:30,319
this on the bond because the bond

00:07:29,280 --> 00:07:32,720
doesn't do

00:07:30,319 --> 00:07:34,240
x dp you want to do this on those

00:07:32,720 --> 00:07:36,240
ingress next

00:07:34,240 --> 00:07:38,080
we're going to attach a program which is

00:07:36,240 --> 00:07:41,199
going to use an fdb

00:07:38,080 --> 00:07:42,080
and a ports mount so the fdb is going to

00:07:41,199 --> 00:07:45,039
have a bunch of

00:07:42,080 --> 00:07:46,639
entries in it that are the vlan and dmac

00:07:45,039 --> 00:07:47,759
destination mac

00:07:46,639 --> 00:07:49,919
and then the value that's going to

00:07:47,759 --> 00:07:53,120
return back is going to be

00:07:49,919 --> 00:07:57,520
a device index so which

00:07:53,120 --> 00:07:59,599
which net device is this packet going to

00:07:57,520 --> 00:08:01,360
so the code for this it's going to be

00:07:59,599 --> 00:08:04,080
super simple

00:08:01,360 --> 00:08:06,319
um packet comes in you look at the

00:08:04,080 --> 00:08:08,160
ethernet header you pull out the vlan

00:08:06,319 --> 00:08:10,720
you pull out the destination mac that's

00:08:08,160 --> 00:08:12,560
your key look up in the ftb map

00:08:10,720 --> 00:08:13,759
and then the ports map is used for two

00:08:12,560 --> 00:08:16,800
reasons

00:08:13,759 --> 00:08:18,560
one of those is the redirect and

00:08:16,800 --> 00:08:20,720
the bulking effects that you get with it

00:08:18,560 --> 00:08:23,440
as well as the error handling

00:08:20,720 --> 00:08:25,360
and the second one is going to be you

00:08:23,440 --> 00:08:28,720
can now as a 5.8

00:08:25,360 --> 00:08:31,280
attach programs to devmap entries

00:08:28,720 --> 00:08:32,719
so that you can on the redirect run

00:08:31,280 --> 00:08:35,519
another program

00:08:32,719 --> 00:08:40,560
that is specific to the device going to

00:08:35,519 --> 00:08:43,279
receive the packet

00:08:40,560 --> 00:08:44,399
all right so the basic premise here is

00:08:43,279 --> 00:08:48,240
you're only doing

00:08:44,399 --> 00:08:50,320
fast path takes xdp slow traffic

00:08:48,240 --> 00:08:52,480
goes up the full stack and you got to

00:08:50,320 --> 00:08:54,480
define known traffic and so for me i'm

00:08:52,480 --> 00:08:56,720
defining known traffic as

00:08:54,480 --> 00:08:58,000
an entry exists in the fdb i'm gonna do

00:08:56,720 --> 00:09:02,560
a redirect

00:08:58,000 --> 00:09:04,080
and if i can get almost all the traffic

00:09:02,560 --> 00:09:06,399
that's going to virtual machines to

00:09:04,080 --> 00:09:09,040
bypass the host stack

00:09:06,399 --> 00:09:10,800
it's a huge amazing difference in

00:09:09,040 --> 00:09:12,880
performance in terms of

00:09:10,800 --> 00:09:13,839
the cpu cycles that the host has to

00:09:12,880 --> 00:09:16,320
spend

00:09:13,839 --> 00:09:18,160
moving that packet up and i actually

00:09:16,320 --> 00:09:19,200
have a blog post that i should finish up

00:09:18,160 --> 00:09:20,880
this weekend

00:09:19,200 --> 00:09:22,560
and get published which has some data

00:09:20,880 --> 00:09:27,120
that shows what the

00:09:22,560 --> 00:09:27,120
the reduction in cpu cycles is

00:09:27,200 --> 00:09:31,680
okay so we've got this program it's

00:09:30,399 --> 00:09:34,800
going to tap into

00:09:31,680 --> 00:09:37,920
a map the fdb is a hash map

00:09:34,800 --> 00:09:39,760
so that's a bpf map type hash you know i

00:09:37,920 --> 00:09:42,000
said before the the key is going to be

00:09:39,760 --> 00:09:43,600
the vlan and the dmacc and then the

00:09:42,000 --> 00:09:44,720
value that comes back from that if an

00:09:43,600 --> 00:09:47,440
entry is found

00:09:44,720 --> 00:09:48,720
is going to be an index so you have a

00:09:47,440 --> 00:09:51,440
user space component

00:09:48,720 --> 00:09:54,480
user space program which is going to for

00:09:51,440 --> 00:09:57,519
example as a vm get started

00:09:54,480 --> 00:10:00,240
the a shell script or some agent can

00:09:57,519 --> 00:10:01,040
populate the fdb that says here's a new

00:10:00,240 --> 00:10:03,440
vm

00:10:01,040 --> 00:10:05,519
it has this tap device it expects

00:10:03,440 --> 00:10:08,560
traffic going to this destination mac

00:10:05,519 --> 00:10:08,560
and on this vlan

00:10:09,839 --> 00:10:13,680
another the other map that we're using

00:10:11,760 --> 00:10:18,240
is a ports map

00:10:13,680 --> 00:10:19,120
and prior to i think it's 5.4 the only

00:10:18,240 --> 00:10:22,560
option you had

00:10:19,120 --> 00:10:24,959
was devnop so bpfmap type devmap

00:10:22,560 --> 00:10:28,480
and it was required at that time to have

00:10:24,959 --> 00:10:28,480
a map to do the redirect

00:10:28,560 --> 00:10:32,399
so the program returns xdp redirect it

00:10:31,120 --> 00:10:34,480
uses this map

00:10:32,399 --> 00:10:36,959
as the acceleration piece of it the

00:10:34,480 --> 00:10:39,760
bulking

00:10:36,959 --> 00:10:41,360
one problem that the devmap has so this

00:10:39,760 --> 00:10:45,200
is something you're going to hit

00:10:41,360 --> 00:10:45,200
5.4 before 5.4

00:10:45,360 --> 00:10:49,200
you have to declare your map size ahead

00:10:46,959 --> 00:10:51,360
of time so

00:10:49,200 --> 00:10:52,560
if you think you're going to have 200

00:10:51,360 --> 00:10:54,399
vms running on

00:10:52,560 --> 00:10:57,279
a host for example then you would want

00:10:54,399 --> 00:11:00,160
to declare a map size of 200

00:10:57,279 --> 00:11:02,079
but unfortunately the index grows over

00:11:00,160 --> 00:11:02,880
time so tap devices for example coming

00:11:02,079 --> 00:11:06,000
and going

00:11:02,880 --> 00:11:08,640
would grow over time and so if you used

00:11:06,000 --> 00:11:09,279
your devmap index as your net device

00:11:08,640 --> 00:11:13,120
index

00:11:09,279 --> 00:11:14,959
you would overflow it so that 201st

00:11:13,120 --> 00:11:17,680
virtual machine gets started you

00:11:14,959 --> 00:11:20,240
suddenly can't add that map entry

00:11:17,680 --> 00:11:22,320
so for dev maps you kind of have to use

00:11:20,240 --> 00:11:25,680
an intermediary map index

00:11:22,320 --> 00:11:28,160
where the fdb map doesn't return the map

00:11:25,680 --> 00:11:29,120
doesn't return the device index it has

00:11:28,160 --> 00:11:30,959
to return

00:11:29,120 --> 00:11:32,880
the map index so that's going to be the

00:11:30,959 --> 00:11:36,079
index that goes into the dev map

00:11:32,880 --> 00:11:38,320
which then returns the correct device so

00:11:36,079 --> 00:11:39,839
really what i'm saying here is the

00:11:38,320 --> 00:11:42,320
devmap

00:11:39,839 --> 00:11:43,360
was the first one and it has it has some

00:11:42,320 --> 00:11:44,640
management

00:11:43,360 --> 00:11:46,560
aspects to it which make it a little

00:11:44,640 --> 00:11:48,560
more complicated to use

00:11:46,560 --> 00:11:50,000
and that was the motivation for the

00:11:48,560 --> 00:11:53,440
devmap hash

00:11:50,000 --> 00:11:54,880
which came along in 5.4 and so over here

00:11:53,440 --> 00:11:56,880
you don't need to do this

00:11:54,880 --> 00:11:58,399
intermediary mapping anymore you can

00:11:56,880 --> 00:12:00,800
just use that device index

00:11:58,399 --> 00:12:01,519
so the ftb map can return the device

00:12:00,800 --> 00:12:03,279
index

00:12:01,519 --> 00:12:04,959
which is just the index into the dev map

00:12:03,279 --> 00:12:08,000
that the kernel is going to use

00:12:04,959 --> 00:12:10,720
to do the redirect

00:12:08,000 --> 00:12:12,560
and then of course 5.6 some more work

00:12:10,720 --> 00:12:14,079
done by toke which was

00:12:12,560 --> 00:12:16,720
getting rid of the need for the map all

00:12:14,079 --> 00:12:18,000
together and now you can just use bpf

00:12:16,720 --> 00:12:20,800
redirect directly

00:12:18,000 --> 00:12:21,680
no map variant needed no map part of it

00:12:20,800 --> 00:12:23,279
needed

00:12:21,680 --> 00:12:26,079
although there is a little bit of loss

00:12:23,279 --> 00:12:26,079
in error recording

00:12:26,959 --> 00:12:30,480
all right so now let's kick over and

00:12:29,440 --> 00:12:34,399
look at

00:12:30,480 --> 00:12:35,120
what does it mean to write an l2 virtual

00:12:34,399 --> 00:12:39,200
switch

00:12:35,120 --> 00:12:41,760
in ebpf so all of this code

00:12:39,200 --> 00:12:43,600
is available on github um i guess i

00:12:41,760 --> 00:12:44,160
should first ask is this font size large

00:12:43,600 --> 00:12:47,360
enough

00:12:44,160 --> 00:12:47,360
is it coming across okay

00:12:48,880 --> 00:12:54,800
anyone looking good to me okay

00:12:53,279 --> 00:12:58,000
all right so all of this code is

00:12:54,800 --> 00:13:00,720
available on github it's in uh

00:12:58,000 --> 00:13:02,639
my account is dsa hearn and then there's

00:13:00,720 --> 00:13:05,200
a bpf progs

00:13:02,639 --> 00:13:06,240
repository and so all of all this code

00:13:05,200 --> 00:13:06,959
that i'm going to show you here is

00:13:06,240 --> 00:13:12,000
available

00:13:06,959 --> 00:13:13,760
on that site um so to walk through this

00:13:12,000 --> 00:13:15,040
uh usual kind of headers that you have

00:13:13,760 --> 00:13:17,600
to declare where things are

00:13:15,040 --> 00:13:18,800
defined so the first thing we have here

00:13:17,600 --> 00:13:22,000
is our port map

00:13:18,800 --> 00:13:23,760
and so again since i'm on a 5.8 kernel

00:13:22,000 --> 00:13:25,680
i'm going to use a devmap hash i'm going

00:13:23,760 --> 00:13:26,639
to make my life easy

00:13:25,680 --> 00:13:30,160
not having to deal with these

00:13:26,639 --> 00:13:33,839
intermediary intermediary indexes

00:13:30,160 --> 00:13:35,279
i size it at 512 that's way more than i

00:13:33,839 --> 00:13:37,760
think we would need

00:13:35,279 --> 00:13:39,199
but i'm also having i'm also going to

00:13:37,760 --> 00:13:43,040
allow two different

00:13:39,199 --> 00:13:45,600
um net devs per virtual machine so

00:13:43,040 --> 00:13:48,800
a size 512 really means i'm allowing up

00:13:45,600 --> 00:13:50,720
to about 250

00:13:48,800 --> 00:13:53,279
virtual machines with both a public and

00:13:50,720 --> 00:13:55,040
a private interface

00:13:53,279 --> 00:13:56,639
and then the same with the fdb it's

00:13:55,040 --> 00:13:57,440
going to have that same size allowing

00:13:56,639 --> 00:14:00,079
individual

00:13:57,440 --> 00:14:00,079
mac entries

00:14:01,120 --> 00:14:04,880
moving into the program so the first

00:14:03,199 --> 00:14:08,000
thing you have to do

00:14:04,880 --> 00:14:12,079
so for xdp programs the context that the

00:14:08,000 --> 00:14:14,320
program is passed is called xtpmd

00:14:12,079 --> 00:14:15,839
and that defines yep definitions in

00:14:14,320 --> 00:14:18,560
there for the packet start and the

00:14:15,839 --> 00:14:18,560
packet end

00:14:18,639 --> 00:14:23,760
and you always have to verify

00:14:21,680 --> 00:14:24,959
that a particular point in the packet

00:14:23,760 --> 00:14:28,880
exists

00:14:24,959 --> 00:14:32,639
and so that's what down here at line 52

00:14:28,880 --> 00:14:35,199
i'm setting oops sorry

00:14:32,639 --> 00:14:37,680
uh i defined the ethernet header to be

00:14:35,199 --> 00:14:40,399
at the start of the packet

00:14:37,680 --> 00:14:41,519
and the next header is going to be the

00:14:40,399 --> 00:14:43,279
the

00:14:41,519 --> 00:14:45,279
point in the packet right after that

00:14:43,279 --> 00:14:48,720
ethernet header and so

00:14:45,279 --> 00:14:51,920
in line 53 i have to check that yes

00:14:48,720 --> 00:14:53,120
that next header exists that's greater

00:14:51,920 --> 00:14:55,199
than the end of the packet

00:14:53,120 --> 00:14:56,160
so that my ethernet header exists so at

00:14:55,199 --> 00:14:58,320
this point

00:14:56,160 --> 00:14:59,440
i know that i can dereference the proto

00:14:58,320 --> 00:15:00,639
and the dmacc

00:14:59,440 --> 00:15:03,279
and pull those out of the ethernet

00:15:00,639 --> 00:15:05,600
header and if i didn't do that check

00:15:03,279 --> 00:15:07,120
the verifier would reject the program

00:15:05,600 --> 00:15:10,399
saying it's it's an unknown

00:15:07,120 --> 00:15:13,120
basically out of bounds checks so you

00:15:10,399 --> 00:15:15,360
always have to verify something exists

00:15:13,120 --> 00:15:17,600
in a bpf program before you actually

00:15:15,360 --> 00:15:20,959
access it

00:15:17,600 --> 00:15:21,519
um so in my case i expect all the

00:15:20,959 --> 00:15:23,440
packets

00:15:21,519 --> 00:15:25,360
destined for a virtual machine to be

00:15:23,440 --> 00:15:27,040
vlan tagged

00:15:25,360 --> 00:15:28,399
so in this case if it's not a vlan

00:15:27,040 --> 00:15:29,759
tagged packet

00:15:28,399 --> 00:15:31,279
i don't need to pay attention to it so

00:15:29,759 --> 00:15:32,720
the program can immediately just ignore

00:15:31,279 --> 00:15:34,399
it and let the packet go up the full

00:15:32,720 --> 00:15:38,160
stack

00:15:34,399 --> 00:15:41,600
so since i expect a vlan header

00:15:38,160 --> 00:15:46,480
i then use define a vlan struct so

00:15:41,600 --> 00:15:49,040
v header is construct vlan header

00:15:46,480 --> 00:15:49,839
so again i have to make sure that the

00:15:49,040 --> 00:15:52,399
vlan header

00:15:49,839 --> 00:15:54,639
exists in the packet before i can look

00:15:52,399 --> 00:15:56,320
into it

00:15:54,639 --> 00:15:58,000
if it's not there i'm gonna drop the

00:15:56,320 --> 00:15:59,839
packet because

00:15:58,000 --> 00:16:02,000
it seems like the pack of email form for

00:15:59,839 --> 00:16:08,000
it to show up with

00:16:02,000 --> 00:16:11,199
ethernet yep is there a question

00:16:08,000 --> 00:16:13,199
okay um

00:16:11,199 --> 00:16:14,639
so yeah it would be a malformed packet

00:16:13,199 --> 00:16:16,000
if it had an ethernet header but not the

00:16:14,639 --> 00:16:19,519
vlan header behind it

00:16:16,000 --> 00:16:20,959
if the the type is vlan um

00:16:19,519 --> 00:16:24,320
so i can just do the drop here and let

00:16:20,959 --> 00:16:27,040
me upload the full stack seat at all

00:16:24,320 --> 00:16:29,440
again with bpf you have to initialize

00:16:27,040 --> 00:16:32,639
everything before you access it

00:16:29,440 --> 00:16:35,440
so i'm going to clear out the key

00:16:32,639 --> 00:16:36,000
and then i'm going to set the vlan key

00:16:35,440 --> 00:16:39,519
vlan

00:16:36,000 --> 00:16:42,560
part of the key to be um

00:16:39,519 --> 00:16:45,519
the tci the vlan part of the tci out of

00:16:42,560 --> 00:16:45,519
that vlan header

00:16:45,680 --> 00:16:50,720
and if again if the vlan is not set

00:16:48,880 --> 00:16:52,560
i know that's an invalid config for what

00:16:50,720 --> 00:16:53,120
i'm doing in which case i can just

00:16:52,560 --> 00:16:56,720
return

00:16:53,120 --> 00:16:58,800
and let it go up the full stack

00:16:56,720 --> 00:16:59,839
after that i'm going to copy the

00:16:58,800 --> 00:17:02,959
destination mac

00:16:59,839 --> 00:17:06,000
because my fdb is based off of vlan dmac

00:17:02,959 --> 00:17:08,959
copy that into the key

00:17:06,000 --> 00:17:08,959
and then do a lookout

00:17:09,039 --> 00:17:13,280
if there's an entry in the map i can

00:17:11,839 --> 00:17:14,480
there's not an entry in the map i can

00:17:13,280 --> 00:17:16,799
just return and again

00:17:14,480 --> 00:17:18,000
let it go up the full stack or if the

00:17:16,799 --> 00:17:19,760
device index hasn't been

00:17:18,000 --> 00:17:21,439
set i can let it just go up the full

00:17:19,760 --> 00:17:25,120
stack and let the kernel

00:17:21,439 --> 00:17:27,839
stack take care of it so then after that

00:17:25,120 --> 00:17:28,960
i did find an entry and i'm going to

00:17:27,839 --> 00:17:32,080
make sure that my

00:17:28,960 --> 00:17:35,600
ports map has an entry for this device

00:17:32,080 --> 00:17:37,679
index if it doesn't again full stack

00:17:35,600 --> 00:17:39,520
so this is where it gets into keeping

00:17:37,679 --> 00:17:42,400
the xdp program

00:17:39,520 --> 00:17:43,120
extremely simple and refined on fast

00:17:42,400 --> 00:17:46,480
path

00:17:43,120 --> 00:17:48,720
packet processing only in any kind of

00:17:46,480 --> 00:17:51,679
unexpected conditions just let the full

00:17:48,720 --> 00:17:51,679
stack take care of it

00:17:52,160 --> 00:17:57,360
all right so my view my virtual machines

00:17:55,760 --> 00:17:58,480
don't know anything about vlans they

00:17:57,360 --> 00:17:59,600
don't know that they're actually

00:17:58,480 --> 00:18:02,559
separated by

00:17:59,600 --> 00:18:03,600
by vlans so since this program is being

00:18:02,559 --> 00:18:05,120
done in xdp

00:18:03,600 --> 00:18:07,280
and i'm going to redirect that packet to

00:18:05,120 --> 00:18:08,240
the vm i've got to strip that header

00:18:07,280 --> 00:18:10,480
myself

00:18:08,240 --> 00:18:13,520
so that's what this next part is doing

00:18:10,480 --> 00:18:16,320
is removing the vlan header

00:18:13,520 --> 00:18:18,080
and this is effectively doing what the

00:18:16,320 --> 00:18:19,039
kernel has to do if vlan acceleration is

00:18:18,080 --> 00:18:22,320
not on

00:18:19,039 --> 00:18:25,679
which is moving that header um

00:18:22,320 --> 00:18:28,160
forward and then at the end

00:18:25,679 --> 00:18:28,720
doing the redirect handing out that

00:18:28,160 --> 00:18:30,960
packet

00:18:28,720 --> 00:18:32,080
to the kernel to do some bulking

00:18:30,960 --> 00:18:33,760
internally

00:18:32,080 --> 00:18:35,200
to send this packet to this net to this

00:18:33,760 --> 00:18:38,640
uh netdev

00:18:35,200 --> 00:18:40,240
so that's it 90 98 lines

00:18:38,640 --> 00:18:42,000
including headers and everything else

00:18:40,240 --> 00:18:47,360
definitions to

00:18:42,000 --> 00:18:47,360
have a simple l2 switch within xdp

00:18:48,080 --> 00:18:52,240
so this is not a lining switch right but

00:18:50,960 --> 00:18:52,799
it could be pretty triggered by the

00:18:52,240 --> 00:18:56,320
lining

00:18:52,799 --> 00:18:57,679
uh into this i say it again

00:18:56,320 --> 00:19:00,160
it's not a landing switch like it

00:18:57,679 --> 00:19:03,360
doesn't update its ftp table

00:19:00,160 --> 00:19:03,919
no no it's not learning at all so it

00:19:03,360 --> 00:19:05,919
could be

00:19:03,919 --> 00:19:07,360
it should be easy to add it should be

00:19:05,919 --> 00:19:10,880
easy to add yeah

00:19:07,360 --> 00:19:14,799
um it depends on how you want to do

00:19:10,880 --> 00:19:17,280
your management so for example someone

00:19:14,799 --> 00:19:21,360
posted patches to tap into

00:19:17,280 --> 00:19:22,960
the linux bridges fdb table and

00:19:21,360 --> 00:19:24,720
part of that got into a discussion about

00:19:22,960 --> 00:19:25,200
how is it how does the learning part

00:19:24,720 --> 00:19:28,320
happen

00:19:25,200 --> 00:19:29,919
in the aging part happen in my case what

00:19:28,320 --> 00:19:33,120
i was saying earlier is

00:19:29,919 --> 00:19:33,840
this is a virtual machine host it's not

00:19:33,120 --> 00:19:36,160
some

00:19:33,840 --> 00:19:38,160
random traffic forwarder in this case i

00:19:36,160 --> 00:19:42,160
know exactly which vms are running

00:19:38,160 --> 00:19:45,280
on this host i can calculate my fdb

00:19:42,160 --> 00:19:48,080
precisely so you updated before

00:19:45,280 --> 00:19:49,520
uh there's some i guess yeah separate

00:19:48,080 --> 00:19:53,120
tool they're not using uh

00:19:49,520 --> 00:19:55,760
the bridge tool to update or not link to

00:19:53,120 --> 00:19:56,880
it's not a shared table no uh you didn't

00:19:55,760 --> 00:19:58,400
show that but there's

00:19:56,880 --> 00:20:00,320
i'm assuming there's a tool that updates

00:19:58,400 --> 00:20:02,640
the tables

00:20:00,320 --> 00:20:04,159
yeah i've got a demo coming up where i

00:20:02,640 --> 00:20:05,440
will walk through

00:20:04,159 --> 00:20:07,679
so like you can start the virtual

00:20:05,440 --> 00:20:10,320
machine and pause it

00:20:07,679 --> 00:20:11,919
in a pause state which allows the libert

00:20:10,320 --> 00:20:12,799
code for example to create the tap

00:20:11,919 --> 00:20:15,600
device

00:20:12,799 --> 00:20:16,720
pass it over to qmu but the vm is not

00:20:15,600 --> 00:20:18,480
running yet

00:20:16,720 --> 00:20:20,080
and then you can have management scripts

00:20:18,480 --> 00:20:21,200
that come in and say now that i have the

00:20:20,080 --> 00:20:23,360
tap device

00:20:21,200 --> 00:20:24,240
i already know the mac address and the

00:20:23,360 --> 00:20:26,320
network address

00:20:24,240 --> 00:20:27,520
being assigned to this virtual machine i

00:20:26,320 --> 00:20:30,559
can now create that

00:20:27,520 --> 00:20:33,120
ftb entry so david with the

00:20:30,559 --> 00:20:33,919
patches that are been floating on net

00:20:33,120 --> 00:20:37,120
next

00:20:33,919 --> 00:20:39,440
the helper with static entries

00:20:37,120 --> 00:20:40,720
will work for you i'm just curious if

00:20:39,440 --> 00:20:42,960
your other depo program

00:20:40,720 --> 00:20:44,400
actually yes yeah it could it could

00:20:42,960 --> 00:20:46,960
right okay

00:20:44,400 --> 00:20:48,000
i strongly suspect for something like

00:20:46,960 --> 00:20:51,120
this use case

00:20:48,000 --> 00:20:53,840
where everything is known that the map

00:20:51,120 --> 00:20:55,840
is going to perform way better than

00:20:53,840 --> 00:20:58,640
tapping into the linux bridge

00:20:55,840 --> 00:21:00,000
api okay but at the end of the day it

00:20:58,640 --> 00:21:03,200
comes down to testing so

00:21:00,000 --> 00:21:04,640
when the person working on that bridge

00:21:03,200 --> 00:21:07,760
part of it

00:21:04,640 --> 00:21:10,400
when he gets that that working

00:21:07,760 --> 00:21:12,240
i can always update my my experiments

00:21:10,400 --> 00:21:15,120
because i have both side by side

00:21:12,240 --> 00:21:16,320
and i can flip out ovs go to linux

00:21:15,120 --> 00:21:18,400
bridge

00:21:16,320 --> 00:21:20,320
run one set of tasks with linux bridge

00:21:18,400 --> 00:21:23,039
and then run another set of tests with

00:21:20,320 --> 00:21:24,799
with the fdb based um and it's just a

00:21:23,039 --> 00:21:26,320
matter of switching out the ftp program

00:21:24,799 --> 00:21:29,520
that's on there

00:21:26,320 --> 00:21:32,559
cool so yeah it's yeah

00:21:29,520 --> 00:21:33,600
we'll find out in time is this super

00:21:32,559 --> 00:21:36,720
simple

00:21:33,600 --> 00:21:39,840
um xdp style you know

00:21:36,720 --> 00:21:40,640
using a hash map static hash map faster

00:21:39,840 --> 00:21:42,880
or slower

00:21:40,640 --> 00:21:44,000
you know or negligible if it's

00:21:42,880 --> 00:21:45,600
negligible

00:21:44,000 --> 00:21:47,120
there are benefits to using the linux

00:21:45,600 --> 00:21:48,880
bridge so

00:21:47,120 --> 00:21:51,200
just happened it and let it do the

00:21:48,880 --> 00:21:51,200
learning

00:21:56,559 --> 00:22:00,799
all right so that was that's a virtual

00:22:00,240 --> 00:22:03,120
switch

00:22:00,799 --> 00:22:04,240
so now we've got packets came into the

00:22:03,120 --> 00:22:07,360
host

00:22:04,240 --> 00:22:09,679
go up to the vm but

00:22:07,360 --> 00:22:11,280
we have a problem and for those who are

00:22:09,679 --> 00:22:12,000
at the xcp workshop i'm sure you heard

00:22:11,280 --> 00:22:14,640
me complaining about

00:22:12,000 --> 00:22:14,640
this yesterday

00:22:15,360 --> 00:22:21,120
if your nic supports vlan acceleration

00:22:19,200 --> 00:22:22,240
the vlan tag is getting stripped by the

00:22:21,120 --> 00:22:24,559
hardware

00:22:22,240 --> 00:22:25,280
so all you're getting is ethernet frame

00:22:24,559 --> 00:22:28,000
and then

00:22:25,280 --> 00:22:29,200
when it creates an skb it sets the tag

00:22:28,000 --> 00:22:32,880
separately

00:22:29,200 --> 00:22:35,520
well what's passed to your xtp program

00:22:32,880 --> 00:22:36,159
is the packet so you've lost the vlan

00:22:35,520 --> 00:22:38,159
information

00:22:36,159 --> 00:22:41,760
so you can't make you can't make a vlan

00:22:38,159 --> 00:22:45,440
based decision um

00:22:41,760 --> 00:22:49,360
without with vlan acceleration on

00:22:45,440 --> 00:22:52,960
so you got to strip you got to turn off

00:22:49,360 --> 00:22:56,320
the vlan acceleration so that you keep

00:22:52,960 --> 00:22:58,080
the tag in the packet so essentially

00:22:56,320 --> 00:23:00,720
rxplan off is what you have to do for

00:22:58,080 --> 00:23:03,039
the devices that have it enabled

00:23:00,720 --> 00:23:04,559
but then that means the program itself

00:23:03,039 --> 00:23:06,400
has to strip the vlan header

00:23:04,559 --> 00:23:08,159
but i showed that in my l2 forwarding

00:23:06,400 --> 00:23:11,440
program earlier

00:23:08,159 --> 00:23:12,320
so that's also i guess in my demo script

00:23:11,440 --> 00:23:14,400
that's kind of a

00:23:12,320 --> 00:23:16,080
hidden behind the scenes thing but that

00:23:14,400 --> 00:23:19,440
is one of those gotchas

00:23:16,080 --> 00:23:20,960
that you will be looking at tcp dump

00:23:19,440 --> 00:23:21,760
output you're like none of these packets

00:23:20,960 --> 00:23:24,400
to this host

00:23:21,760 --> 00:23:26,000
should show up on tcp dump on the bond

00:23:24,400 --> 00:23:27,280
and yet they're there

00:23:26,000 --> 00:23:29,360
so you start questioning whether your

00:23:27,280 --> 00:23:31,520
program is doing anything well it's just

00:23:29,360 --> 00:23:33,200
because the vlan's missing

00:23:31,520 --> 00:23:36,799
so keep that one in mind if you're in a

00:23:33,200 --> 00:23:39,840
vlan environment all right

00:23:36,799 --> 00:23:40,320
so the next thing is packets came into

00:23:39,840 --> 00:23:44,559
the host

00:23:40,320 --> 00:23:48,320
getting redirected to the vm and often

00:23:44,559 --> 00:23:51,360
um at least for our case people running

00:23:48,320 --> 00:23:52,960
virtual machines on our hosts they want

00:23:51,360 --> 00:23:54,559
an acl implemented they don't even want

00:23:52,960 --> 00:23:57,200
to see packets

00:23:54,559 --> 00:23:59,120
certain kinds of packets so for example

00:23:57,200 --> 00:24:00,960
if it's not running a web server

00:23:59,120 --> 00:24:02,320
there's no reason to send a packet

00:24:00,960 --> 00:24:04,240
destined to port 80

00:24:02,320 --> 00:24:06,400
to the vm there's no reason to even wake

00:24:04,240 --> 00:24:08,960
it up or make the guest os deal with it

00:24:06,400 --> 00:24:09,840
and so you want to have this ability to

00:24:08,960 --> 00:24:13,279
do

00:24:09,840 --> 00:24:16,840
on a per vm basis a set of rules

00:24:13,279 --> 00:24:19,840
which can limit traffic coming into that

00:24:16,840 --> 00:24:19,840
vm

00:24:21,520 --> 00:24:29,840
and another thing you could do um

00:24:26,080 --> 00:24:31,360
is validate the packet data so so far

00:24:29,840 --> 00:24:33,600
we've only looked at the destination mac

00:24:31,360 --> 00:24:35,440
address and the fact that it's going to

00:24:33,600 --> 00:24:38,240
this tap device means that

00:24:35,440 --> 00:24:40,320
the dmacc and the tap the vlan and the

00:24:38,240 --> 00:24:42,240
dmac show up as a known entry

00:24:40,320 --> 00:24:43,919
but it doesn't mean the network address

00:24:42,240 --> 00:24:44,720
or other elements of the packet are

00:24:43,919 --> 00:24:47,600
valid

00:24:44,720 --> 00:24:48,400
so if you wanted to you could tap into

00:24:47,600 --> 00:24:50,320
that

00:24:48,400 --> 00:24:51,919
into the network header aspect of the

00:24:50,320 --> 00:24:54,080
packet and say

00:24:51,919 --> 00:24:55,919
is the destination address the expected

00:24:54,080 --> 00:24:58,960
network address for this vm

00:24:55,919 --> 00:25:00,559
and if it's not drop the packet to keep

00:24:58,960 --> 00:25:03,039
unknown traffic from showing up to the

00:25:00,559 --> 00:25:03,039
vms

00:25:03,600 --> 00:25:07,279
so this was something that

00:25:07,520 --> 00:25:11,440
this capability was something i added in

00:25:09,600 --> 00:25:13,440
the 5.8 kernel

00:25:11,440 --> 00:25:14,640
so the tx path for the tab device

00:25:13,440 --> 00:25:16,640
remember these are packets being

00:25:14,640 --> 00:25:19,360
transmitted to the virtual machine

00:25:16,640 --> 00:25:20,400
there is no xdp option when you add an

00:25:19,360 --> 00:25:23,679
xtp program

00:25:20,400 --> 00:25:26,720
to a net device it's being run on

00:25:23,679 --> 00:25:28,240
on the rx side so

00:25:26,720 --> 00:25:31,120
to get around this you know after

00:25:28,240 --> 00:25:34,159
looking at trying to do an egress option

00:25:31,120 --> 00:25:34,559
for xdp the sqb path kept blowing things

00:25:34,159 --> 00:25:37,600
up

00:25:34,559 --> 00:25:38,559
and daniel pushed us over to well let's

00:25:37,600 --> 00:25:42,159
just do a program

00:25:38,559 --> 00:25:45,440
entry attach a program to the devmap

00:25:42,159 --> 00:25:46,240
entry as a way to have these per virtual

00:25:45,440 --> 00:25:51,120
machine or

00:25:46,240 --> 00:25:51,120
per net device type of programs

00:25:52,720 --> 00:25:56,320
uh let's see i think i just covered all

00:25:55,600 --> 00:25:59,039
of that

00:25:56,320 --> 00:26:00,320
so one one benefit i i reason why i was

00:25:59,039 --> 00:26:03,600
pushing this direction

00:26:00,320 --> 00:26:07,120
is the clean up side of it um

00:26:03,600 --> 00:26:09,279
you could stack all these programs up on

00:26:07,120 --> 00:26:11,200
the ingress so instead of just having a

00:26:09,279 --> 00:26:13,919
simple l2 switch

00:26:11,200 --> 00:26:15,039
on each zero and each one you could have

00:26:13,919 --> 00:26:17,200
it

00:26:15,039 --> 00:26:20,400
do a tail map a tail call into another

00:26:17,200 --> 00:26:23,600
program which is a vm specific

00:26:20,400 --> 00:26:26,080
i don't like that method because um

00:26:23,600 --> 00:26:28,000
the management of it is more complicated

00:26:26,080 --> 00:26:28,880
and you don't get any kind of automated

00:26:28,000 --> 00:26:31,600
cleanup

00:26:28,880 --> 00:26:32,240
where if you attach a program to a

00:26:31,600 --> 00:26:36,480
devmap

00:26:32,240 --> 00:26:38,799
entry the program ref count is tied to

00:26:36,480 --> 00:26:40,400
the device and when the device is

00:26:38,799 --> 00:26:41,840
cleaned up the entry is removed from the

00:26:40,400 --> 00:26:43,600
dev map by the kernel

00:26:41,840 --> 00:26:45,440
which means the program ref count is

00:26:43,600 --> 00:26:46,960
also dropped so you're getting some

00:26:45,440 --> 00:26:49,760
cleanup for free

00:26:46,960 --> 00:26:50,960
by associating a program that is unique

00:26:49,760 --> 00:26:54,000
to a vm

00:26:50,960 --> 00:26:54,480
attach it to that vm's tap device so

00:26:54,000 --> 00:26:56,880
that

00:26:54,480 --> 00:26:59,200
is a benefit for the devmap entries

00:26:56,880 --> 00:27:03,279
approach

00:26:59,200 --> 00:27:07,039
all right and so back to some more code

00:27:03,279 --> 00:27:10,559
um i think it's this one

00:27:07,039 --> 00:27:11,200
yeah okay so same thing all those codes

00:27:10,559 --> 00:27:14,400
available on

00:27:11,200 --> 00:27:14,799
the github site in this case what i've

00:27:14,400 --> 00:27:18,000
got

00:27:14,799 --> 00:27:21,120
is a hashmap again

00:27:18,000 --> 00:27:24,559
for the acl entries

00:27:21,120 --> 00:27:27,200
the acl key is

00:27:24,559 --> 00:27:28,159
i think i have that defined in this

00:27:27,200 --> 00:27:35,840
header

00:27:28,159 --> 00:27:35,840
no no that's in a user space header

00:27:47,200 --> 00:27:51,440
here we go all right i always get to

00:27:50,480 --> 00:27:55,520
open up windows

00:27:51,440 --> 00:27:57,120
so the key is the port and protocol

00:27:55,520 --> 00:27:58,559
and again this is there's a lot of

00:27:57,120 --> 00:28:01,840
shortcomings to this approach

00:27:58,559 --> 00:28:03,200
so just take this as a very simplistic

00:28:01,840 --> 00:28:05,760
acl

00:28:03,200 --> 00:28:06,880
um i actually need to restructure it a

00:28:05,760 --> 00:28:08,480
bit because i was getting annoyed with

00:28:06,880 --> 00:28:10,080
something i was doing

00:28:08,480 --> 00:28:12,159
but at the moment what it's doing is

00:28:10,080 --> 00:28:14,240
saying

00:28:12,159 --> 00:28:16,080
what is the transport protocol or the

00:28:14,240 --> 00:28:18,720
next protocol after the network

00:28:16,080 --> 00:28:19,440
and then is there a destination port or

00:28:18,720 --> 00:28:21,840
a port

00:28:19,440 --> 00:28:22,640
in this case it's the destination port

00:28:21,840 --> 00:28:24,320
um

00:28:22,640 --> 00:28:26,159
so that's going to be the key that you

00:28:24,320 --> 00:28:27,840
would look up into this map

00:28:26,159 --> 00:28:30,720
and then if there's an entry it'll

00:28:27,840 --> 00:28:32,960
return this value which is going to be

00:28:30,720 --> 00:28:35,679
maybe there's a source address set that

00:28:32,960 --> 00:28:37,279
says the source address has to match

00:28:35,679 --> 00:28:39,600
maybe there's a destination address

00:28:37,279 --> 00:28:41,919
match and in my case

00:28:39,600 --> 00:28:43,919
my acl was actually used on the rx side

00:28:41,919 --> 00:28:44,799
and the tx side which is why there's two

00:28:43,919 --> 00:28:46,000
different

00:28:44,799 --> 00:28:48,480
source address and the destination

00:28:46,000 --> 00:28:51,919
address entries the

00:28:48,480 --> 00:28:53,440
family for that address the flags gets

00:28:51,919 --> 00:28:56,480
into these

00:28:53,440 --> 00:28:58,880
up here and it's really because of ibv6

00:28:56,480 --> 00:29:01,279
i don't do that comparison unless i know

00:28:58,880 --> 00:29:03,760
that it's been set so that's kind of

00:29:01,279 --> 00:29:04,799
optimization on it and then this is the

00:29:03,760 --> 00:29:07,360
other end of that port

00:29:04,799 --> 00:29:07,919
so in this case it would be the source

00:29:07,360 --> 00:29:11,200
port

00:29:07,919 --> 00:29:11,200
if i was checking on that

00:29:11,520 --> 00:29:15,919
okay so that's the definition of the acl

00:29:14,320 --> 00:29:19,120
hash map

00:29:15,919 --> 00:29:23,440
this other map here is vm info

00:29:19,120 --> 00:29:26,640
and so multiple programs

00:29:23,440 --> 00:29:27,600
need to have access to information about

00:29:26,640 --> 00:29:30,000
the virtual machine

00:29:27,600 --> 00:29:31,279
so for example the mac address the

00:29:30,000 --> 00:29:34,399
network address

00:29:31,279 --> 00:29:35,840
ipv4 ipv6 and i didn't want to replicate

00:29:34,399 --> 00:29:38,640
that information

00:29:35,840 --> 00:29:40,399
across each one of these programs so

00:29:38,640 --> 00:29:43,760
what i'm doing is creating

00:29:40,399 --> 00:29:48,480
a static map pinned into csfs

00:29:43,760 --> 00:29:50,960
and it'll contain that information once

00:29:48,480 --> 00:29:52,840
and then that map will get referenced by

00:29:50,960 --> 00:29:54,000
all the other programs that need that

00:29:52,840 --> 00:29:55,360
information

00:29:54,000 --> 00:29:57,679
so i'll get to that this part of the

00:29:55,360 --> 00:29:57,679
demo

00:29:58,000 --> 00:30:06,720
uh from the code side of this

00:30:02,399 --> 00:30:10,960
so one benefit to this evpf approach is

00:30:06,720 --> 00:30:14,080
an xdp you can have a program for xtp

00:30:10,960 --> 00:30:16,320
and a program for tc's classifier

00:30:14,080 --> 00:30:17,120
both referencing as you can see here

00:30:16,320 --> 00:30:20,000
there's some

00:30:17,120 --> 00:30:22,720
tiny differences in the context but you

00:30:20,000 --> 00:30:25,840
can have the same logic

00:30:22,720 --> 00:30:26,320
being executed from both an xtv path and

00:30:25,840 --> 00:30:29,679
a tc

00:30:26,320 --> 00:30:31,520
path so for example if i wanted this acl

00:30:29,679 --> 00:30:34,880
to exist

00:30:31,520 --> 00:30:36,240
in one map but being referenced by two

00:30:34,880 --> 00:30:37,679
different code places

00:30:36,240 --> 00:30:39,840
and attached to different places but

00:30:37,679 --> 00:30:41,279
it's still the same information in the

00:30:39,840 --> 00:30:44,799
same code

00:30:41,279 --> 00:30:47,600
this is a way to do that so for example

00:30:44,799 --> 00:30:49,520
the full stack instead of having obs

00:30:47,600 --> 00:30:52,480
take care of some of these matchings

00:30:49,520 --> 00:30:52,799
and limitations or restrictions on what

00:30:52,480 --> 00:30:56,000
what

00:30:52,799 --> 00:30:56,960
traffic can flow up i can have the acl

00:30:56,000 --> 00:30:58,880
done

00:30:56,960 --> 00:31:00,080
for the slow path have it done through a

00:30:58,880 --> 00:31:01,200
tc filter

00:31:00,080 --> 00:31:04,080
right and so that way i'm not

00:31:01,200 --> 00:31:06,320
duplicating anything from a

00:31:04,080 --> 00:31:07,679
data perspective so that's what this

00:31:06,320 --> 00:31:10,480
part is

00:31:07,679 --> 00:31:11,279
but we're going to do the xtp part of it

00:31:10,480 --> 00:31:13,279
and

00:31:11,279 --> 00:31:14,559
it's the same thing where you have your

00:31:13,279 --> 00:31:18,399
xtp md

00:31:14,559 --> 00:31:20,159
is your context you got a

00:31:18,399 --> 00:31:23,600
local variables for both the beginning

00:31:20,159 --> 00:31:27,200
and end of the packet area

00:31:23,600 --> 00:31:30,799
so this is this is a

00:31:27,200 --> 00:31:34,000
an entry on the redirect and so because

00:31:30,799 --> 00:31:37,360
this is a dev map entry i have access to

00:31:34,000 --> 00:31:39,760
the egress index which is going to be

00:31:37,360 --> 00:31:41,279
the device that i'm going to so really

00:31:39,760 --> 00:31:43,200
the context in this case is going to

00:31:41,279 --> 00:31:45,200
have both i know the ingress device and

00:31:43,200 --> 00:31:46,080
i know the egress device so i get to see

00:31:45,200 --> 00:31:48,240
where it came from

00:31:46,080 --> 00:31:50,720
and where it's going to inside this

00:31:48,240 --> 00:31:53,440
inside this program

00:31:50,720 --> 00:31:53,760
um the first thing i do here is i look

00:31:53,440 --> 00:31:55,760
up

00:31:53,760 --> 00:31:56,960
in that vm info map and i say do i have

00:31:55,760 --> 00:31:58,720
an entry

00:31:56,960 --> 00:32:00,240
because if i don't have an entry

00:31:58,720 --> 00:32:01,760
something's not right and i'm gonna let

00:32:00,240 --> 00:32:03,440
this go up the full stack

00:32:01,760 --> 00:32:04,799
so that if the program is doing any

00:32:03,440 --> 00:32:06,159
validation

00:32:04,799 --> 00:32:07,360
the full stack can take care of it

00:32:06,159 --> 00:32:08,799
because i don't have the information

00:32:07,360 --> 00:32:11,760
here

00:32:08,799 --> 00:32:13,120
and then after that i'm gonna my generic

00:32:11,760 --> 00:32:14,880
drop packet hook

00:32:13,120 --> 00:32:16,640
for deciding if the pack this packet

00:32:14,880 --> 00:32:19,200
needs to be dropped or does it continue

00:32:16,640 --> 00:32:21,600
on its path to the virtual machine

00:32:19,200 --> 00:32:22,880
and then the difference here for the tc

00:32:21,600 --> 00:32:26,080
and xtv pads

00:32:22,880 --> 00:32:28,559
are the return codes shot versus drop

00:32:26,080 --> 00:32:31,840
from the xtp side of it

00:32:28,559 --> 00:32:35,039
so the drop path drop packet

00:32:31,840 --> 00:32:38,960
piece of that um is

00:32:35,039 --> 00:32:41,039
in this so it's an acl so

00:32:38,960 --> 00:32:42,720
i don't like duplicated code and so

00:32:41,039 --> 00:32:43,279
anytime i'm referencing code from two

00:32:42,720 --> 00:32:45,360
different

00:32:43,279 --> 00:32:46,640
programs i tend to put it in header

00:32:45,360 --> 00:32:49,440
files

00:32:46,640 --> 00:32:50,559
and so that's what this acl vm common is

00:32:49,440 --> 00:32:53,600
it's

00:32:50,559 --> 00:32:55,600
the actual logic piece of it that's

00:32:53,600 --> 00:32:58,000
being used from both the rx and the tx

00:32:55,600 --> 00:32:58,000
pads

00:32:58,240 --> 00:33:05,760
all right and let's see this

00:33:02,399 --> 00:33:09,039
this here is where it starts

00:33:05,760 --> 00:33:10,880
and the rest of that code up above is

00:33:09,039 --> 00:33:15,200
things like just helper functions for

00:33:10,880 --> 00:33:15,200
comparing ipv6 addresses for example

00:33:15,760 --> 00:33:18,880
so the first thing you have to do again

00:33:17,039 --> 00:33:20,799
is you got to check and say

00:33:18,880 --> 00:33:21,919
does the data exist because if it

00:33:20,799 --> 00:33:23,679
doesn't exist

00:33:21,919 --> 00:33:25,120
then you have a malcolm packet and the

00:33:23,679 --> 00:33:28,880
verifier is going to

00:33:25,120 --> 00:33:31,600
reject the program so once i verify that

00:33:28,880 --> 00:33:32,880
the header after the ethernet header

00:33:31,600 --> 00:33:34,480
exists

00:33:32,880 --> 00:33:36,320
then i can go ahead and use it i can

00:33:34,480 --> 00:33:38,000
start referencing things like

00:33:36,320 --> 00:33:39,279
inside the ethernet address i can

00:33:38,000 --> 00:33:40,640
reference the source mac or the

00:33:39,279 --> 00:33:43,440
destination mac

00:33:40,640 --> 00:33:45,519
where i'm verifying that in fact and

00:33:43,440 --> 00:33:47,760
again this is common code so

00:33:45,519 --> 00:33:49,200
that's why it's being seen somewhat

00:33:47,760 --> 00:33:50,840
duplicate to

00:33:49,200 --> 00:33:52,640
verify when i've already done it on the

00:33:50,840 --> 00:33:55,120
redirect um

00:33:52,640 --> 00:33:57,279
but again it's being run from possibly

00:33:55,120 --> 00:33:59,279
from an xtp path and a tc path

00:33:57,279 --> 00:34:01,919
and then an rx and tx side of it all

00:33:59,279 --> 00:34:03,840
sharing the same same code

00:34:01,919 --> 00:34:06,960
so compare the mac address it's what i

00:34:03,840 --> 00:34:10,639
expect in the packet look at

00:34:06,960 --> 00:34:11,280
the oh making sure i stripped off any

00:34:10,639 --> 00:34:14,879
ethernet

00:34:11,280 --> 00:34:17,599
any vlan headers and then i get into

00:34:14,879 --> 00:34:19,040
a packet parsing so this was something

00:34:17,599 --> 00:34:20,960
else that came up

00:34:19,040 --> 00:34:23,520
recently was someone i think it was at

00:34:20,960 --> 00:34:26,560
intel was talking about

00:34:23,520 --> 00:34:27,280
giving access to the kernel slo-di

00:34:26,560 --> 00:34:32,399
sector

00:34:27,280 --> 00:34:32,399
from bpf programs and i've got

00:34:33,040 --> 00:34:36,639
a packet parsing code in my repository

00:34:35,679 --> 00:34:38,960
here which

00:34:36,639 --> 00:34:40,720
it's modeled after the flow detector but

00:34:38,960 --> 00:34:43,919
it's trying to be

00:34:40,720 --> 00:34:45,599
a modular for xdp so that you can always

00:34:43,919 --> 00:34:48,240
keep track of

00:34:45,599 --> 00:34:48,800
if you're not doing ipv6 for example

00:34:48,240 --> 00:34:51,520
compile

00:34:48,800 --> 00:34:53,119
ipv6 if you're not doing you're not

00:34:51,520 --> 00:34:55,440
interested in transport header

00:34:53,119 --> 00:34:56,800
information then you can not parse that

00:34:55,440 --> 00:34:59,599
piece of the packet

00:34:56,800 --> 00:35:00,640
so i'm going to jump over here to this

00:34:59,599 --> 00:35:03,280
next screen

00:35:00,640 --> 00:35:04,320
all right just to that point dave yeah

00:35:03,280 --> 00:35:06,400
so um

00:35:04,320 --> 00:35:07,760
so i think that's a good great idea to

00:35:06,400 --> 00:35:09,359
only have

00:35:07,760 --> 00:35:10,880
only what you need to use right if

00:35:09,359 --> 00:35:12,720
you're just you're not interested in

00:35:10,880 --> 00:35:15,760
vlans what why the heck are you

00:35:12,720 --> 00:35:17,839
passing vlans or right which the flow

00:35:15,760 --> 00:35:19,200
dissector doesn't know how to do

00:35:17,839 --> 00:35:21,040
uh and that's that's one thing that

00:35:19,200 --> 00:35:23,440
makes flowers slower actually

00:35:21,040 --> 00:35:25,280
uh on the ingress path because it does

00:35:23,440 --> 00:35:26,640
generic full packet personally it does

00:35:25,280 --> 00:35:28,480
the whole god damn thing

00:35:26,640 --> 00:35:31,040
and then they use that as a key to to do

00:35:28,480 --> 00:35:34,320
a lookup the

00:35:31,040 --> 00:35:36,320
question to you is uh

00:35:34,320 --> 00:35:37,440
could this have been the city downloaded

00:35:36,320 --> 00:35:40,800
as a

00:35:37,440 --> 00:35:42,839
an extension program say an ebpf program

00:35:40,800 --> 00:35:46,560
that

00:35:42,839 --> 00:35:49,599
uh just password all i need

00:35:46,560 --> 00:35:49,920
as opposed to maybe i should wait until

00:35:49,599 --> 00:35:53,760
i see

00:35:49,920 --> 00:35:56,800
your code first so this is where you

00:35:53,760 --> 00:35:59,839
start doing ebpf it's got to be

00:35:56,800 --> 00:36:01,040
one continuous flow all right

00:35:59,839 --> 00:36:03,119
and so it's got to be a standalone

00:36:01,040 --> 00:36:04,720
program you can do a tail call where you

00:36:03,119 --> 00:36:07,760
jump to another program

00:36:04,720 --> 00:36:10,960
but again it's going to be a linear flow

00:36:07,760 --> 00:36:11,839
so this idea of having generic library

00:36:10,960 --> 00:36:15,119
code that you would call

00:36:11,839 --> 00:36:15,920
into it and come back um as far as i

00:36:15,119 --> 00:36:19,119
know

00:36:15,920 --> 00:36:21,200
it has it doesn't exist yet

00:36:19,119 --> 00:36:22,880
yeah there's a lot of talk about it yeah

00:36:21,200 --> 00:36:25,359
so that's why i was making this

00:36:22,880 --> 00:36:26,560
as a kind of a generic struct again

00:36:25,359 --> 00:36:29,520
modeled after

00:36:26,560 --> 00:36:30,640
but i want to have all of the enable

00:36:29,520 --> 00:36:33,520
pieces in here

00:36:30,640 --> 00:36:35,200
so that for example you can include this

00:36:33,520 --> 00:36:38,480
flow.h header file

00:36:35,200 --> 00:36:39,760
in your code your your specific targeted

00:36:38,480 --> 00:36:42,640
program

00:36:39,760 --> 00:36:43,520
and then that targeted program would

00:36:42,640 --> 00:36:46,000
enable

00:36:43,520 --> 00:36:48,560
some of these features right so if it

00:36:46,000 --> 00:36:50,000
didn't care if it did want ipv6

00:36:48,560 --> 00:36:52,320
then it would do this defined to make

00:36:50,000 --> 00:36:53,839
sure the ipv6 code is included

00:36:52,320 --> 00:36:55,280
if it didn't care about it then it

00:36:53,839 --> 00:36:56,640
wouldn't define it and it wouldn't be

00:36:55,280 --> 00:36:56,960
bothered with it right so it's keeping

00:36:56,640 --> 00:36:58,720
it

00:36:56,960 --> 00:37:00,160
it won't be compiled in is that what it

00:36:58,720 --> 00:37:05,200
is right exactly

00:37:00,160 --> 00:37:09,520
okay exactly so if you go back to this

00:37:05,200 --> 00:37:13,440
um acl program right so it includes

00:37:09,520 --> 00:37:16,960
the aclvm common and then common

00:37:13,440 --> 00:37:19,599
includes the flow and so

00:37:16,960 --> 00:37:20,640
theoretically right here theoretically

00:37:19,599 --> 00:37:22,880
right before this

00:37:20,640 --> 00:37:25,040
i just got kind of lazy in my when i

00:37:22,880 --> 00:37:27,760
started adding the enable functions

00:37:25,040 --> 00:37:29,359
um right here at line 27 is where it

00:37:27,760 --> 00:37:31,280
should be saying

00:37:29,359 --> 00:37:33,119
these are the things i want from this

00:37:31,280 --> 00:37:34,400
flow.h

00:37:33,119 --> 00:37:36,640
right that's the direction i want to see

00:37:34,400 --> 00:37:38,880
the code go and so that

00:37:36,640 --> 00:37:40,640
when this acl program is compiled for a

00:37:38,880 --> 00:37:44,480
specific use case

00:37:40,640 --> 00:37:44,480
it only includes what it needs

00:37:46,240 --> 00:37:49,680
and it's really going after again that

00:37:47,920 --> 00:37:52,079
xtp notion of

00:37:49,680 --> 00:37:53,119
xdp is about advanced networking and

00:37:52,079 --> 00:37:55,920
it's about

00:37:53,119 --> 00:37:57,200
you only do what you know you need for

00:37:55,920 --> 00:38:00,640
that use case

00:37:57,200 --> 00:38:02,240
right so if you're not doing any kind of

00:38:00,640 --> 00:38:03,520
policy routing if you're not doing any

00:38:02,240 --> 00:38:05,359
kind of

00:38:03,520 --> 00:38:07,520
you know ipv6 or training whatever the

00:38:05,359 --> 00:38:08,079
code is you're strictly focused on what

00:38:07,520 --> 00:38:11,839
you need

00:38:08,079 --> 00:38:11,839
to make it as fast and light as possible

00:38:12,640 --> 00:38:17,839
yeah i mean that's uh the appliance

00:38:15,839 --> 00:38:19,440
model

00:38:17,839 --> 00:38:21,440
you just build the appliance you want

00:38:19,440 --> 00:38:23,280
not to have it more yes

00:38:21,440 --> 00:38:25,200
but you can do it through modular code

00:38:23,280 --> 00:38:28,480
so again like this

00:38:25,200 --> 00:38:30,640
this flow code here um it's set up

00:38:28,480 --> 00:38:33,200
generically to enable this

00:38:30,640 --> 00:38:35,119
and then you do the if daft you define

00:38:33,200 --> 00:38:37,760
the the things you want in

00:38:35,119 --> 00:38:38,240
right and so when the program's compiled

00:38:37,760 --> 00:38:40,640
it's

00:38:38,240 --> 00:38:41,599
just what you want that's what i would

00:38:40,640 --> 00:38:43,599
like to see

00:38:41,599 --> 00:38:47,680
from from what i when i call modular

00:38:43,599 --> 00:38:52,160
code that's what i'm referring to

00:38:47,680 --> 00:38:53,599
so the acl code was calling parsepacket

00:38:52,160 --> 00:38:55,280
and it's going to fill in this flow

00:38:53,599 --> 00:38:56,880
struct

00:38:55,280 --> 00:38:58,960
and the first thing it's going to look

00:38:56,880 --> 00:39:01,280
at is that ethernet protocol to say well

00:38:58,960 --> 00:39:03,119
what is it in this case let's say it's

00:39:01,280 --> 00:39:05,839
an ipv4 packet

00:39:03,119 --> 00:39:06,640
it's going to jump to the parse ipv4

00:39:05,839 --> 00:39:09,680
parse ipv

00:39:06,640 --> 00:39:12,000
ipv4 is now the ipv4

00:39:09,680 --> 00:39:12,880
specific code that you're going to get

00:39:12,000 --> 00:39:16,480
into

00:39:12,880 --> 00:39:18,800
and so again you always have to verify

00:39:16,480 --> 00:39:21,520
does the ip header exist before i can

00:39:18,800 --> 00:39:23,760
dereference it

00:39:21,520 --> 00:39:25,520
um i always do some sanity checks on

00:39:23,760 --> 00:39:27,760
packets you know don't believe

00:39:25,520 --> 00:39:28,720
what showed up on the wire so yes it's

00:39:27,760 --> 00:39:31,200
ipv4

00:39:28,720 --> 00:39:33,599
it's a version 4 packet the header link

00:39:31,200 --> 00:39:35,760
is what i expect

00:39:33,599 --> 00:39:37,760
and then start filling in that flow

00:39:35,760 --> 00:39:40,960
information

00:39:37,760 --> 00:39:43,599
and so again allowing things like

00:39:40,960 --> 00:39:45,599
i don't care about transports right so

00:39:43,599 --> 00:39:47,119
if you had a use case that said

00:39:45,599 --> 00:39:48,880
you only want the source address or the

00:39:47,119 --> 00:39:51,599
destination address you would stop

00:39:48,880 --> 00:39:53,680
parsing the packet right there in return

00:39:51,599 --> 00:39:55,200
because whoever called this flow parser

00:39:53,680 --> 00:39:58,560
was only interested

00:39:55,200 --> 00:40:00,320
in that one specific set of data meaning

00:39:58,560 --> 00:40:03,760
the trend the next protocol the source

00:40:00,320 --> 00:40:03,760
address the destination address

00:40:04,880 --> 00:40:11,040
uh let's see so if it were to continue

00:40:09,200 --> 00:40:12,319
then again you got to move that next

00:40:11,040 --> 00:40:16,880
header pointer

00:40:12,319 --> 00:40:20,400
beyond the ipv ipv4 header

00:40:16,880 --> 00:40:21,920
and of course well then i'm going to

00:40:20,400 --> 00:40:23,200
jump to the parse transport code but

00:40:21,920 --> 00:40:24,160
it's going to the first thing it has to

00:40:23,200 --> 00:40:28,880
do

00:40:24,160 --> 00:40:31,680
is validate that the header exists

00:40:28,880 --> 00:40:32,319
so in this case the transport can be tcp

00:40:31,680 --> 00:40:36,079
udp

00:40:32,319 --> 00:40:37,680
icmp or icp v6

00:40:36,079 --> 00:40:39,200
i clearly have some defines that are

00:40:37,680 --> 00:40:41,280
missing anyway

00:40:39,200 --> 00:40:42,880
tcp header for example first thing you

00:40:41,280 --> 00:40:44,960
have to do is again

00:40:42,880 --> 00:40:47,119
make sure that the header exists in the

00:40:44,960 --> 00:40:48,079
packet before you go and look into the

00:40:47,119 --> 00:40:51,040
header

00:40:48,079 --> 00:40:52,640
um entries to make sure they exit make

00:40:51,040 --> 00:40:55,119
sure the header exists

00:40:52,640 --> 00:40:56,400
and then that right now is all i have

00:40:55,119 --> 00:40:58,400
for

00:40:56,400 --> 00:40:59,520
parsing tcp udp it's just pulling out

00:40:58,400 --> 00:41:02,079
the ports

00:40:59,520 --> 00:41:03,680
right so if other people want to pick

00:41:02,079 --> 00:41:04,640
this up and continue extending it and

00:41:03,680 --> 00:41:06,560
again making it that

00:41:04,640 --> 00:41:08,160
modular piece i would like to see

00:41:06,560 --> 00:41:12,880
something like this

00:41:08,160 --> 00:41:12,880
over tapping into kernel code

00:41:13,839 --> 00:41:20,000
all right so just an interjection

00:41:17,280 --> 00:41:21,440
so tom tom hubbard has a talk on monday

00:41:20,000 --> 00:41:23,920
where he

00:41:21,440 --> 00:41:25,359
is probably gonna i haven't seen the

00:41:23,920 --> 00:41:27,040
paper or anything but this is

00:41:25,359 --> 00:41:29,040
the kind of stuff he wants to make

00:41:27,040 --> 00:41:32,640
module

00:41:29,040 --> 00:41:33,839
now i anyway

00:41:32,640 --> 00:41:36,640
that would be a good discussion to have

00:41:33,839 --> 00:41:39,040
there okay

00:41:36,640 --> 00:41:41,599
all right so now we go we went down this

00:41:39,040 --> 00:41:43,440
rabbit hole of parsing the packet

00:41:41,599 --> 00:41:45,520
and that's what this function was here

00:41:43,440 --> 00:41:47,599
this call here so now i have a flow

00:41:45,520 --> 00:41:51,520
struct

00:41:47,599 --> 00:41:54,800
and like i said my my key to my acl map

00:41:51,520 --> 00:41:58,960
is a simple protocol destination port

00:41:54,800 --> 00:42:01,359
and create the key do a map lookup

00:41:58,960 --> 00:42:02,160
do i have an entry if i don't have an

00:42:01,359 --> 00:42:06,160
entry

00:42:02,160 --> 00:42:08,079
nothing to do move along um

00:42:06,160 --> 00:42:09,200
so again everything below here it's

00:42:08,079 --> 00:42:11,839
basically just saying

00:42:09,200 --> 00:42:12,800
am i dropping the packet or keeping it i

00:42:11,839 --> 00:42:16,000
can't say i really

00:42:12,800 --> 00:42:18,960
like where it exists today but

00:42:16,000 --> 00:42:20,400
it's it's a thought it's an idea so

00:42:18,960 --> 00:42:22,640
again if people have

00:42:20,400 --> 00:42:23,520
better ideas on how to do an acl you

00:42:22,640 --> 00:42:26,560
know

00:42:23,520 --> 00:42:31,119
certainly send patches

00:42:26,560 --> 00:42:32,960
all right so i think at that point

00:42:31,119 --> 00:42:34,960
we've parsed the packet we've decided if

00:42:32,960 --> 00:42:36,160
there's an acl entry for it

00:42:34,960 --> 00:42:38,319
we're going to return back whether we're

00:42:36,160 --> 00:42:39,760
keeping it or dropping it and then that

00:42:38,319 --> 00:42:42,000
decides what the program is going to do

00:42:39,760 --> 00:42:45,040
from a drop or a pass perspective

00:42:42,000 --> 00:42:47,040
if it's pass then it goes on to

00:42:45,040 --> 00:42:49,280
um in this case since it's a redirect

00:42:47,040 --> 00:42:53,599
path it's going to

00:42:49,280 --> 00:42:55,680
be added to the bulking um

00:42:53,599 --> 00:42:57,200
cue inside the kernel and then when

00:42:55,680 --> 00:43:00,480
that's flushed all those packets get

00:42:57,200 --> 00:43:00,480
pushed up to the time device

00:43:01,839 --> 00:43:08,560
all right i think that was it for

00:43:05,920 --> 00:43:08,560
this path

00:43:10,560 --> 00:43:14,480
okay so we've packets have come in to

00:43:12,640 --> 00:43:15,599
the host been redirected to the virtual

00:43:14,480 --> 00:43:17,680
machine

00:43:15,599 --> 00:43:19,200
the other piece of that is going to be

00:43:17,680 --> 00:43:20,720
from a host perspective

00:43:19,200 --> 00:43:23,839
is traffic coming out of the virtual

00:43:20,720 --> 00:43:27,280
machine and going out of the host

00:43:23,839 --> 00:43:30,560
so like i said before virtual machines

00:43:27,280 --> 00:43:32,560
are untrusted um entities

00:43:30,560 --> 00:43:34,400
so every packet coming out of that needs

00:43:32,560 --> 00:43:35,920
to have source mac checked

00:43:34,400 --> 00:43:38,720
network address check to make sure that

00:43:35,920 --> 00:43:41,920
they're not trying to spoof something

00:43:38,720 --> 00:43:43,359
again allowing um for some kind of an

00:43:41,920 --> 00:43:45,359
egress aco

00:43:43,359 --> 00:43:46,960
in this case it's going to be more like

00:43:45,359 --> 00:43:49,200
a cloud provider saying

00:43:46,960 --> 00:43:50,880
i don't need people using my vms or my

00:43:49,200 --> 00:43:53,520
hosts to

00:43:50,880 --> 00:43:54,720
send junk mail so for example maybe you

00:43:53,520 --> 00:43:57,920
don't want to allow

00:43:54,720 --> 00:44:00,000
smt traffic smtp traffic so which case

00:43:57,920 --> 00:44:01,680
the host has this this acl that applies

00:44:00,000 --> 00:44:03,599
to anything coming out of the vm

00:44:01,680 --> 00:44:05,200
that would just say if this is if this

00:44:03,599 --> 00:44:08,160
is smtp just drop it

00:44:05,200 --> 00:44:09,599
i don't need to deal with it um and then

00:44:08,160 --> 00:44:12,000
everything passes whatever

00:44:09,599 --> 00:44:13,599
checks the host wants to do then

00:44:12,000 --> 00:44:17,520
redirect that traffic

00:44:13,599 --> 00:44:19,839
packets over to um the host egress nick

00:44:17,520 --> 00:44:20,560
but now one problem we have here is the

00:44:19,839 --> 00:44:24,400
bond

00:44:20,560 --> 00:44:26,480
and i'll get to that in a few minutes um

00:44:24,400 --> 00:44:27,520
if it's an unknown destination mac

00:44:26,480 --> 00:44:29,200
address again

00:44:27,520 --> 00:44:30,400
allow us to take the slow path to go

00:44:29,200 --> 00:44:31,040
through the bridge and the bond to

00:44:30,400 --> 00:44:34,319
figure out

00:44:31,040 --> 00:44:38,319
what needs to happen with it and as

00:44:34,319 --> 00:44:40,640
with the devmap entry in this case

00:44:38,319 --> 00:44:41,520
the evpf program is going to be attached

00:44:40,640 --> 00:44:44,319
to

00:44:41,520 --> 00:44:46,000
tap device itself so this is a normal

00:44:44,319 --> 00:44:49,359
device attachment for xd

00:44:46,000 --> 00:44:50,240
xdp and it's the rx path again packets

00:44:49,359 --> 00:44:53,280
being received

00:44:50,240 --> 00:44:54,560
by the host from the virtual machine

00:44:53,280 --> 00:44:57,359
and then when that tap device gets

00:44:54,560 --> 00:44:58,880
deleted the vm's program gets deleted so

00:44:57,359 --> 00:45:01,200
i really i really like that cleanup

00:44:58,880 --> 00:45:01,200
model

00:45:02,640 --> 00:45:09,040
okay so the bond bond doesn't do a

00:45:05,839 --> 00:45:11,760
xdp and you have to tell

00:45:09,040 --> 00:45:13,760
an actual egress device right you have

00:45:11,760 --> 00:45:18,640
to direct either to e0 or eth1

00:45:13,760 --> 00:45:21,599
in this setup so which leg do you use

00:45:18,640 --> 00:45:24,160
so i looked at the bond policy and

00:45:21,599 --> 00:45:27,920
trying to create a bpf helper for it

00:45:24,160 --> 00:45:30,480
and for simple ones like active backup

00:45:27,920 --> 00:45:32,160
it was easy to export a helper to say

00:45:30,480 --> 00:45:33,040
you know let it tell you which leg to

00:45:32,160 --> 00:45:36,960
use

00:45:33,040 --> 00:45:40,640
but for l3 l4 hashing it meant

00:45:36,960 --> 00:45:42,480
converting an xtp frame into an skb

00:45:40,640 --> 00:45:44,640
equivalent like someone was proposing

00:45:42,480 --> 00:45:47,920
for um

00:45:44,640 --> 00:45:50,800
the hash access or

00:45:47,920 --> 00:45:51,119
just replicate the code and or i'm sorry

00:45:50,800 --> 00:45:53,920
or

00:45:51,119 --> 00:45:55,040
modify the bond code to work with xcp

00:45:53,920 --> 00:45:56,480
frames

00:45:55,040 --> 00:45:58,160
and after looking at that for a couple

00:45:56,480 --> 00:46:00,240
of days i'm like that's there's no

00:45:58,160 --> 00:46:01,920
return on the investment so what i

00:46:00,240 --> 00:46:03,760
really figured out was you know it's not

00:46:01,920 --> 00:46:05,520
that complicated of a code

00:46:03,760 --> 00:46:07,119
just easier to replicate that algorithm

00:46:05,520 --> 00:46:08,720
in uepf

00:46:07,119 --> 00:46:10,560
and so while i don't like duplicating

00:46:08,720 --> 00:46:12,319
kernel code i would prefer to have

00:46:10,560 --> 00:46:14,240
helpers

00:46:12,319 --> 00:46:16,079
i think this is one of those areas where

00:46:14,240 --> 00:46:18,000
it's when you're trying to pick what is

00:46:16,079 --> 00:46:20,319
the best long-term solution

00:46:18,000 --> 00:46:21,440
it was just easier to replicate that

00:46:20,319 --> 00:46:23,520
code

00:46:21,440 --> 00:46:25,839
in vpf and i'll show that in a few

00:46:23,520 --> 00:46:25,839
minutes

00:46:26,720 --> 00:46:30,319
uh the other thing to remember about

00:46:28,560 --> 00:46:34,079
this egress path

00:46:30,319 --> 00:46:35,920
um you don't get v-line acceleration so

00:46:34,079 --> 00:46:37,440
you got to insert the vlan tag yourself

00:46:35,920 --> 00:46:38,000
the vlan header yourself onto that

00:46:37,440 --> 00:46:43,040
packet

00:46:38,000 --> 00:46:46,319
before you do the redirect and

00:46:43,040 --> 00:46:47,119
offloads yeah they don't work so if the

00:46:46,319 --> 00:46:50,319
virtual machine

00:46:47,119 --> 00:46:51,760
is expecting to be able to use tso

00:46:50,319 --> 00:46:53,839
or check some offload or any of those

00:46:51,760 --> 00:46:56,319
kind of things it doesn't work

00:46:53,839 --> 00:46:58,079
so what you have to do is you can either

00:46:56,319 --> 00:47:00,160
tell the guest hey please turn this off

00:46:58,079 --> 00:47:03,040
if you want your networking to work

00:47:00,160 --> 00:47:03,920
or you go into live verts config and you

00:47:03,040 --> 00:47:05,440
say

00:47:03,920 --> 00:47:08,160
here's the things you need to turn off

00:47:05,440 --> 00:47:09,920
so that the vm doesn't even know exists

00:47:08,160 --> 00:47:11,599
right so it's going to do this detection

00:47:09,920 --> 00:47:12,560
and go well i can't rely on hardware

00:47:11,599 --> 00:47:15,920
offloads

00:47:12,560 --> 00:47:18,400
i will take care of this myself so

00:47:15,920 --> 00:47:19,920
one of those lessons learned about why

00:47:18,400 --> 00:47:23,839
does ping work but

00:47:19,920 --> 00:47:27,520
ssh sessions into the vm drops

00:47:23,839 --> 00:47:30,720
uh another gotcha for the egress path

00:47:27,520 --> 00:47:34,559
is cpus so

00:47:30,720 --> 00:47:36,800
on large systems so with xdp

00:47:34,559 --> 00:47:38,319
the way the queues work is it's per cpu

00:47:36,800 --> 00:47:41,680
to keep it lockless

00:47:38,319 --> 00:47:45,359
and the redirect is going to happen

00:47:41,680 --> 00:47:47,839
on some cpu and it goes into an xtpq

00:47:45,359 --> 00:47:48,800
inside the nic driver but if the neck

00:47:47,839 --> 00:47:51,200
driver doesn't have

00:47:48,800 --> 00:47:52,880
a cue for that cpu it just drops the

00:47:51,200 --> 00:47:55,520
packet

00:47:52,880 --> 00:47:59,119
so it's a smaller system and you've got

00:47:55,520 --> 00:48:00,800
like the melanox card with 64 or 63 cues

00:47:59,119 --> 00:48:02,160
you're probably doing okay you just got

00:48:00,800 --> 00:48:04,079
to make sure you have

00:48:02,160 --> 00:48:06,319
the number of queues set up properly

00:48:04,079 --> 00:48:09,440
which the tool commands are there

00:48:06,319 --> 00:48:10,960
um but if you have more than 64 you got

00:48:09,440 --> 00:48:12,079
to be very careful about where the v

00:48:10,960 --> 00:48:14,800
host threads

00:48:12,079 --> 00:48:15,359
are running and i can tell you again

00:48:14,800 --> 00:48:17,680
from

00:48:15,359 --> 00:48:19,599
it's baffling to figure out everything's

00:48:17,680 --> 00:48:21,119
working fine with that virtual machine

00:48:19,599 --> 00:48:23,520
and then all of a sudden traffic just

00:48:21,119 --> 00:48:25,040
stops and then it'll start working again

00:48:23,520 --> 00:48:26,640
and it's strictly because the vehicle's

00:48:25,040 --> 00:48:28,079
threads are being moved around by the

00:48:26,640 --> 00:48:30,640
process scheduler

00:48:28,079 --> 00:48:31,520
so there's not really a good solution to

00:48:30,640 --> 00:48:33,359
this one

00:48:31,520 --> 00:48:35,440
you got to go look up through proc

00:48:33,359 --> 00:48:38,880
interrupts

00:48:35,440 --> 00:48:42,000
where the cpu which cpus

00:48:38,880 --> 00:48:43,920
have cues associated with it and then a

00:48:42,000 --> 00:48:46,480
feed the v-host threads to those set of

00:48:43,920 --> 00:48:46,480
cpus

00:48:47,359 --> 00:48:51,520
all right so going back to code

00:48:53,680 --> 00:48:57,440
it's this one all right

00:48:57,760 --> 00:49:03,119
so similar to the program that was

00:49:01,040 --> 00:49:06,240
attached to e01

00:49:03,119 --> 00:49:07,920
you got to have a device map

00:49:06,240 --> 00:49:10,240
which tells you which ports you can

00:49:07,920 --> 00:49:12,880
redirect to

00:49:10,240 --> 00:49:15,119
anytime you see an underscore underscore

00:49:12,880 --> 00:49:17,839
in one of my programs

00:49:15,119 --> 00:49:19,440
there's a potential that i have a shell

00:49:17,839 --> 00:49:22,079
script that's going to overload it

00:49:19,440 --> 00:49:24,480
so essentially what's happening is and

00:49:22,079 --> 00:49:26,880
i'll get to this in my demo script

00:49:24,480 --> 00:49:28,240
bpf tool is going to create a map and

00:49:26,880 --> 00:49:31,599
pin it

00:49:28,240 --> 00:49:34,000
and then it's going to when i load the

00:49:31,599 --> 00:49:36,800
program using again bpf tool

00:49:34,000 --> 00:49:37,599
um it's going to replace this map

00:49:36,800 --> 00:49:39,760
definition

00:49:37,599 --> 00:49:41,440
with this global one so that everybody

00:49:39,760 --> 00:49:42,400
can use the same map and i don't have to

00:49:41,440 --> 00:49:44,160
have these

00:49:42,400 --> 00:49:48,240
multiple dev maps running around i can

00:49:44,160 --> 00:49:48,240
have one that defines everything

00:49:48,880 --> 00:49:55,680
same thing goes here with this acl map

00:49:52,400 --> 00:49:56,400
one set of code for all the virtual

00:49:55,680 --> 00:49:59,200
machines

00:49:56,400 --> 00:50:00,640
but then each instance of the program

00:49:59,200 --> 00:50:03,280
can have its own map

00:50:00,640 --> 00:50:05,280
and so again i'll i will use vpf tool to

00:50:03,280 --> 00:50:07,119
create a map and pin it

00:50:05,280 --> 00:50:08,800
so you can have access to it to add

00:50:07,119 --> 00:50:13,040
entries and remove entries

00:50:08,800 --> 00:50:15,280
and then attach that map that instance

00:50:13,040 --> 00:50:16,079
to the to the program unload so that i

00:50:15,280 --> 00:50:19,200
can

00:50:16,079 --> 00:50:19,200
have unique instances

00:50:19,280 --> 00:50:23,920
um so anyway devmap hash again because

00:50:21,680 --> 00:50:27,520
you're going to be doing redirects

00:50:23,920 --> 00:50:30,880
the acl very it's exact exact same code

00:50:27,520 --> 00:50:32,319
for the rx or

00:50:30,880 --> 00:50:33,920
traffic coming out this is where it gets

00:50:32,319 --> 00:50:35,760
really confusing with that tap device

00:50:33,920 --> 00:50:38,000
because tx means to the vm

00:50:35,760 --> 00:50:39,440
rx means from the vm but really we're

00:50:38,000 --> 00:50:42,800
talking about traffic that's going

00:50:39,440 --> 00:50:44,800
out of the host but anyway

00:50:42,800 --> 00:50:46,319
the acl code is exactly the same so i'm

00:50:44,800 --> 00:50:48,640
not going to go over that again

00:50:46,319 --> 00:50:49,520
and the same with this vm info the exact

00:50:48,640 --> 00:50:52,960
same

00:50:49,520 --> 00:50:54,079
map that was set up earlier so unique to

00:50:52,960 --> 00:50:57,599
this vm egress

00:50:54,079 --> 00:50:58,559
path is this bond hash um as i mentioned

00:50:57,599 --> 00:51:01,520
earlier

00:50:58,559 --> 00:51:02,400
tapping into the kernel's code for the

00:51:01,520 --> 00:51:04,960
bond

00:51:02,400 --> 00:51:05,520
got to be a bit painful and as you can

00:51:04,960 --> 00:51:07,040
see here

00:51:05,520 --> 00:51:08,960
the algorithm is really not that

00:51:07,040 --> 00:51:12,319
complicated to

00:51:08,960 --> 00:51:14,720
if you use the float sector to

00:51:12,319 --> 00:51:16,000
get the addresses and get the ports just

00:51:14,720 --> 00:51:23,760
do the quick hash on it

00:51:16,000 --> 00:51:27,200
and pick a leg based on that

00:51:23,760 --> 00:51:30,000
uh terms of the program itself

00:51:27,200 --> 00:51:31,920
again it looks up in that vm info map

00:51:30,000 --> 00:51:35,760
that says

00:51:31,920 --> 00:51:37,520
is this virtual machine known to this

00:51:35,760 --> 00:51:39,119
global map that so i can validate

00:51:37,520 --> 00:51:41,359
information

00:51:39,119 --> 00:51:43,359
uh because that that uh vm info was

00:51:41,359 --> 00:51:46,800
passed to the drop packet program

00:51:43,359 --> 00:51:48,880
which i went over earlier um

00:51:46,800 --> 00:51:50,400
a quick catch on any kind of broadcast

00:51:48,880 --> 00:51:51,520
frames like i don't want art packets to

00:51:50,400 --> 00:51:55,520
get redirected

00:51:51,520 --> 00:51:58,880
let's send those down the slow path

00:51:55,520 --> 00:52:00,960
um and then i got to push my vlan tag on

00:51:58,880 --> 00:52:02,640
since this is an xtv program can't rely

00:52:00,960 --> 00:52:05,520
on on the

00:52:02,640 --> 00:52:06,000
hardware acceleration piece of that pick

00:52:05,520 --> 00:52:09,359
the leg

00:52:06,000 --> 00:52:12,720
based on the hash bond hash

00:52:09,359 --> 00:52:15,040
and then do the redirect so this egress

00:52:12,720 --> 00:52:16,240
program has a lot of similarities with

00:52:15,040 --> 00:52:19,680
the ingress

00:52:16,240 --> 00:52:22,800
in the sense of uh parsing the packet

00:52:19,680 --> 00:52:24,400
um doing an acl check

00:52:22,800 --> 00:52:26,079
in this case pushing a vln header

00:52:24,400 --> 00:52:28,160
instead of stripping the vlan header

00:52:26,079 --> 00:52:29,920
and then doing the redirect to a

00:52:28,160 --> 00:52:33,839
specific um

00:52:29,920 --> 00:52:33,839
net device

00:52:38,079 --> 00:52:43,680
all right demo time i guess i didn't

00:52:41,359 --> 00:52:45,920
have to come back to uh

00:52:43,680 --> 00:52:46,880
to keynote just for that so now i'm

00:52:45,920 --> 00:52:49,200
going to flip over

00:52:46,880 --> 00:52:49,200
to

00:52:51,040 --> 00:52:57,440
this is a server in our

00:52:54,800 --> 00:53:01,839
development lab so again i'll ask is

00:52:57,440 --> 00:53:01,839
this font size big enough

00:53:03,200 --> 00:53:09,440
okay i will take that as a yes

00:53:06,480 --> 00:53:11,440
same thing the the demo script is inside

00:53:09,440 --> 00:53:16,319
this repository

00:53:11,440 --> 00:53:21,520
so you can if you're on github now

00:53:16,319 --> 00:53:24,079
you can see it it's right here

00:53:21,520 --> 00:53:24,559
um it has a bunch of print statements in

00:53:24,079 --> 00:53:27,040
here so

00:53:24,559 --> 00:53:28,000
as i walk through this program it'll

00:53:27,040 --> 00:53:29,839
i'll describe

00:53:28,000 --> 00:53:31,040
what's going on but if you want to see

00:53:29,839 --> 00:53:33,839
the whole thing it's

00:53:31,040 --> 00:53:34,640
again right there on github all right so

00:53:33,839 --> 00:53:37,920
let's go through

00:53:34,640 --> 00:53:41,920
the script and i do want to show

00:53:37,920 --> 00:53:44,559
this so this is going to be tcp dump

00:53:41,920 --> 00:53:47,359
running on the bond device

00:53:44,559 --> 00:53:48,720
and you'll be able to see when the vm

00:53:47,359 --> 00:53:51,920
gets started

00:53:48,720 --> 00:53:52,960
uh you'll be able to see none of the

00:53:51,920 --> 00:53:55,119
packets are going through

00:53:52,960 --> 00:53:57,440
it when i log into the virtual machine

00:53:55,119 --> 00:53:59,119
so kind of showing that it's the xcp

00:53:57,440 --> 00:54:02,240
fast path going around

00:53:59,119 --> 00:54:05,280
the bridge and the bond oops all right

00:54:02,240 --> 00:54:05,280
so let's start the script

00:54:05,839 --> 00:54:13,599
so the first thing i'm doing is showing

00:54:10,160 --> 00:54:16,240
uh all right so it cleaned up

00:54:13,599 --> 00:54:17,760
there were some leftovers from my uh

00:54:16,240 --> 00:54:20,319
previous attempt to make sure

00:54:17,760 --> 00:54:22,400
the stimulus doesn't fail it's never

00:54:20,319 --> 00:54:24,079
failed yet when i've done it

00:54:22,400 --> 00:54:25,440
um but you always got to be careful

00:54:24,079 --> 00:54:27,440
about it okay

00:54:25,440 --> 00:54:30,240
so the first time i invoked it it reset

00:54:27,440 --> 00:54:34,480
the system it made sure vxlan

00:54:30,240 --> 00:54:35,760
rxvx rx vlan is disabled in hardware

00:54:34,480 --> 00:54:37,599
and made sure none of the programs were

00:54:35,760 --> 00:54:40,319
loaded and that kind of stuff

00:54:37,599 --> 00:54:40,960
so that's what i'm showing here is i've

00:54:40,319 --> 00:54:43,680
got no

00:54:40,960 --> 00:54:45,359
xtv programs no tc programs none of

00:54:43,680 --> 00:54:46,799
those maps i was discussing earlier

00:54:45,359 --> 00:54:49,280
exist now and so i'm going to walk

00:54:46,799 --> 00:54:49,280
through those

00:54:49,440 --> 00:54:53,760
all right so the first thing i do is

00:54:50,799 --> 00:54:57,040
create that virtual machine

00:54:53,760 --> 00:54:57,520
the virtual machine map that's what this

00:54:57,040 --> 00:55:00,240
is

00:54:57,520 --> 00:55:02,319
so it gets a little tough with a font

00:55:00,240 --> 00:55:06,559
size

00:55:02,319 --> 00:55:07,599
and sharing okay so the first thing it's

00:55:06,559 --> 00:55:09,839
doing is creating that

00:55:07,599 --> 00:55:10,799
virtual machine info map and it's that

00:55:09,839 --> 00:55:14,720
global map

00:55:10,799 --> 00:55:17,599
that's pinned in sysfs

00:55:14,720 --> 00:55:19,119
and by the way i'm using bpf tool here

00:55:17,599 --> 00:55:22,240
because it's easy to show

00:55:19,119 --> 00:55:22,240
kind of a step by step

00:55:22,480 --> 00:55:26,480
in reality i wouldn't use this if i was

00:55:24,319 --> 00:55:28,480
making this to be a production system

00:55:26,480 --> 00:55:30,319
i would have all of these things done

00:55:28,480 --> 00:55:31,440
internally by some agent running on the

00:55:30,319 --> 00:55:33,599
box

00:55:31,440 --> 00:55:35,280
but that's kind of a boring demo let me

00:55:33,599 --> 00:55:37,760
just say look here's a process

00:55:35,280 --> 00:55:40,000
and then all of a sudden xdp is running

00:55:37,760 --> 00:55:41,599
so the point of the bpf tool steps here

00:55:40,000 --> 00:55:44,799
is we have to walk you through

00:55:41,599 --> 00:55:47,119
step by step what's happening okay

00:55:44,799 --> 00:55:49,359
so like i said creating the vm info map

00:55:47,119 --> 00:55:51,280
and

00:55:49,359 --> 00:55:52,640
500 entries it's going to be all that

00:55:51,280 --> 00:55:54,000
global information about the virtual

00:55:52,640 --> 00:55:58,160
machines

00:55:54,000 --> 00:55:59,920
creating the devmap entries the devmap

00:55:58,160 --> 00:56:02,640
which allows me to

00:55:59,920 --> 00:56:03,119
forward or redirect packets from ingress

00:56:02,640 --> 00:56:05,680
next

00:56:03,119 --> 00:56:07,359
on the host up to the tab device or from

00:56:05,680 --> 00:56:09,680
the tap device down to

00:56:07,359 --> 00:56:11,200
the uh the hostnext so that's what the

00:56:09,680 --> 00:56:14,839
xcp forward ports map

00:56:11,200 --> 00:56:17,440
is and you can see those with this map

00:56:14,839 --> 00:56:20,240
show it's listing both of those maps

00:56:17,440 --> 00:56:22,480
with their ids

00:56:20,240 --> 00:56:23,599
and then since again i'm using this to

00:56:22,480 --> 00:56:26,400
redirect vm

00:56:23,599 --> 00:56:27,680
traffic i go ahead and add entries into

00:56:26,400 --> 00:56:31,440
the forward ports map

00:56:27,680 --> 00:56:34,319
for both each zero index 2 and eth1

00:56:31,440 --> 00:56:37,200
which is index 3 which again this is

00:56:34,319 --> 00:56:38,880
another reason why

00:56:37,200 --> 00:56:40,880
you'd want to do this to an agent as

00:56:38,880 --> 00:56:43,920
opposed to vpf tool because

00:56:40,880 --> 00:56:46,480
having to go manually hard code index

00:56:43,920 --> 00:56:47,680
two is easy zero and index three is equ1

00:56:46,480 --> 00:56:49,599
you'd really want to do that through

00:56:47,680 --> 00:56:52,720
lookups as opposed to having to hard

00:56:49,599 --> 00:56:52,720
code the hex values there

00:56:53,359 --> 00:56:59,839
loading the program that xtp

00:56:56,559 --> 00:57:02,240
l2 forward program it's been compiled

00:56:59,839 --> 00:57:03,520
and in my repository i have things in

00:57:02,240 --> 00:57:08,480
k-source object

00:57:03,520 --> 00:57:08,480
and then source bin is the other path um

00:57:09,040 --> 00:57:14,559
it's this is where it's going to pin or

00:57:11,359 --> 00:57:17,520
load the program to this point in sysfs

00:57:14,559 --> 00:57:19,920
this is what i meant by redoing those

00:57:17,520 --> 00:57:19,920
maps

00:57:20,319 --> 00:57:24,640
so i've created that global map and now

00:57:22,559 --> 00:57:28,400
this is going to be what attaches

00:57:24,640 --> 00:57:32,799
that global instance to this program's

00:57:28,400 --> 00:57:32,799
reference of a forward quartz map

00:57:34,000 --> 00:57:39,760
the next thing i do is attach that

00:57:37,680 --> 00:57:41,520
l2 forward program to both eat zero and

00:57:39,760 --> 00:57:45,280
eat one

00:57:41,520 --> 00:57:45,280
you can see the map listings

00:57:45,760 --> 00:57:52,720
now you can see the ftp map show up

00:57:49,280 --> 00:57:55,920
you can see the program the xp

00:57:52,720 --> 00:57:58,240
xdp l2 forward program shows up

00:57:55,920 --> 00:58:00,079
and it's referencing both that fdb map

00:57:58,240 --> 00:58:03,440
which is id 50

00:58:00,079 --> 00:58:06,400
and the forward ports map which is 47.

00:58:03,440 --> 00:58:07,119
and the last thing this is showing is

00:58:06,400 --> 00:58:10,240
yep

00:58:07,119 --> 00:58:13,760
that program 61 is attached to

00:58:10,240 --> 00:58:13,760
each zero and eth1

00:58:15,839 --> 00:58:19,520
next thing i do is i start the virtual

00:58:17,280 --> 00:58:22,400
machine if you remember i said

00:58:19,520 --> 00:58:24,160
i need the tap device to be able to do

00:58:22,400 --> 00:58:27,040
vm specific entries

00:58:24,160 --> 00:58:28,319
in the fdb for example and the forward

00:58:27,040 --> 00:58:29,760
ports map

00:58:28,319 --> 00:58:31,599
but i don't want the vm to be able to

00:58:29,760 --> 00:58:34,400
send traffic until i'm ready for it

00:58:31,599 --> 00:58:35,680
so start it paused that gives me the tap

00:58:34,400 --> 00:58:38,160
device

00:58:35,680 --> 00:58:39,760
at that point i can add an entry into

00:58:38,160 --> 00:58:44,160
that vminfo map

00:58:39,760 --> 00:58:46,720
that says for this id

00:58:44,160 --> 00:58:47,920
which is a unique thing to to

00:58:46,720 --> 00:58:51,040
digitalocean

00:58:47,920 --> 00:58:53,200
it has this tap device it's on this vlan

00:58:51,040 --> 00:58:54,960
with this mac address has this network

00:58:53,200 --> 00:58:57,040
address for ipv4

00:58:54,960 --> 00:58:58,480
and this network address for ipv6 so all

00:58:57,040 --> 00:59:00,000
that information goes into this global

00:58:58,480 --> 00:59:03,280
map

00:59:00,000 --> 00:59:07,040
and my virtual machine also has

00:59:03,280 --> 00:59:08,079
a vpc tap device so now i have a second

00:59:07,040 --> 00:59:11,440
entry

00:59:08,079 --> 00:59:12,880
um unique to it and so if i print that

00:59:11,440 --> 00:59:14,880
virtual machine info map

00:59:12,880 --> 00:59:16,480
i can get that information back so yep

00:59:14,880 --> 00:59:20,240
everything looks good

00:59:16,480 --> 00:59:23,839
from from that map's perspective

00:59:20,240 --> 00:59:26,240
next is to create that so the acl that's

00:59:23,839 --> 00:59:30,839
going packets going to the vm

00:59:26,240 --> 00:59:34,079
i create this virtual machine specific

00:59:30,839 --> 00:59:34,640
map i'm pinning it in cisfs just so i

00:59:34,079 --> 00:59:36,319
can

00:59:34,640 --> 00:59:38,720
get access to it later when i load the

00:59:36,319 --> 00:59:38,720
program

00:59:41,040 --> 00:59:44,960
and so now at this point i've got a map

00:59:42,880 --> 00:59:47,280
for both rx and tx

00:59:44,960 --> 00:59:48,880
and i can start adding entries these are

00:59:47,280 --> 00:59:52,000
unique entries

00:59:48,880 --> 00:59:55,200
specific to this virtual machine

00:59:52,000 --> 00:59:56,640
so just to give some examples of that

00:59:55,200 --> 01:00:00,240
in this case like i said earlier about

00:59:56,640 --> 01:00:03,680
blocking smt traffic smtp traffic

01:00:00,240 --> 01:00:05,760
um just for giggles

01:00:03,680 --> 01:00:07,760
blocking port 80 going into the virtual

01:00:05,760 --> 01:00:10,960
machine

01:00:07,760 --> 01:00:12,960
and then same thing on

01:00:10,960 --> 01:00:14,400
alright sorry this is coming out of the

01:00:12,960 --> 01:00:16,160
virtual machine

01:00:14,400 --> 01:00:19,119
and then the next one down here is

01:00:16,160 --> 01:00:21,440
traffic going to the virtual machine

01:00:19,119 --> 01:00:23,839
so both of these entries are preventing

01:00:21,440 --> 01:00:26,960
a virtual machine some processing the vm

01:00:23,839 --> 01:00:28,480
from talking to port 80 on the web

01:00:26,960 --> 01:00:31,440
and then the same thing something on the

01:00:28,480 --> 01:00:33,359
web can't come in and point to port 80

01:00:31,440 --> 01:00:35,599
on this virtual machine and again this

01:00:33,359 --> 01:00:38,559
is just kind of examples of how to do

01:00:35,599 --> 01:00:38,559
acl entries

01:00:38,880 --> 01:00:43,200
all right and that was a lot of data so

01:00:41,440 --> 01:00:46,240
next up

01:00:43,200 --> 01:00:46,640
is loading the acl programs that are

01:00:46,240 --> 01:00:49,040
going to

01:00:46,640 --> 01:00:51,280
reference those maps i just created and

01:00:49,040 --> 01:00:55,200
then attaching those

01:00:51,280 --> 01:00:58,319
programs to this vm's tap device

01:00:55,200 --> 01:01:01,520
so again using vpf tool this is the

01:00:58,319 --> 01:01:04,480
object file that it's loading

01:01:01,520 --> 01:01:05,280
it's going to pin it to this point in

01:01:04,480 --> 01:01:08,720
the sysfs

01:01:05,280 --> 01:01:10,960
directory if you remember that vm info

01:01:08,720 --> 01:01:12,640
name that underscore underscore it's

01:01:10,960 --> 01:01:16,000
getting replaced by

01:01:12,640 --> 01:01:17,040
this real map that exists okay so this

01:01:16,000 --> 01:01:20,480
is where

01:01:17,040 --> 01:01:22,319
the object code has a reference to a map

01:01:20,480 --> 01:01:24,000
but i'm going to override that with one

01:01:22,319 --> 01:01:26,640
out of one that already

01:01:24,000 --> 01:01:27,440
exists and then the same thing with the

01:01:26,640 --> 01:01:29,920
tx map

01:01:27,440 --> 01:01:30,559
i'm going to take the program's

01:01:29,920 --> 01:01:32,079
reference

01:01:30,559 --> 01:01:33,599
and swap it out with one that i've

01:01:32,079 --> 01:01:37,040
already created

01:01:33,599 --> 01:01:37,040
and populated with entries

01:01:37,280 --> 01:01:41,440
and then similarly with the vm egress

01:01:40,000 --> 01:01:44,640
program

01:01:41,440 --> 01:01:47,760
i load that program pin it in csfs

01:01:44,640 --> 01:01:51,520
swap out some of these maps

01:01:47,760 --> 01:01:54,000
so instead of it pointing to a specific

01:01:51,520 --> 01:01:56,480
program specific map i'm going to have

01:01:54,000 --> 01:02:01,760
it point to this global now

01:01:56,480 --> 01:02:01,760
same thing with the vm info and the acl

01:02:03,440 --> 01:02:06,720
so at this point all these programs are

01:02:06,319 --> 01:02:09,440
ready

01:02:06,720 --> 01:02:11,200
they i can attach them to this vm's tap

01:02:09,440 --> 01:02:15,039
device

01:02:11,200 --> 01:02:18,079
and this is

01:02:15,039 --> 01:02:21,039
a map listing which is going to show

01:02:18,079 --> 01:02:23,039
the tx map has been created the rx map

01:02:21,039 --> 01:02:24,960
has been created

01:02:23,039 --> 01:02:26,400
and i need to figure out why that's

01:02:24,960 --> 01:02:28,640
created and created that shouldn't be

01:02:26,400 --> 01:02:28,640
there

01:02:30,480 --> 01:02:34,960
okay the next thing it's showing is the

01:02:33,200 --> 01:02:36,960
program listing

01:02:34,960 --> 01:02:39,839
so remember earlier this was the program

01:02:36,960 --> 01:02:42,960
attached to each zero and each one

01:02:39,839 --> 01:02:42,960
and then i showed you the

01:02:44,160 --> 01:02:47,680
acl program that's getting loaded as a

01:02:46,319 --> 01:02:51,119
devmap entry

01:02:47,680 --> 01:02:52,880
has both an xtp and a tc

01:02:51,119 --> 01:02:55,039
hooked to it and so that's what those

01:02:52,880 --> 01:02:57,280
entries are here from a program listing

01:02:55,039 --> 01:03:00,160
and you can see that it's referencing

01:02:57,280 --> 01:03:04,400
maps 46 and 51.

01:03:00,160 --> 01:03:08,400
so 46 is that vm info map

01:03:04,400 --> 01:03:13,359
and 51 is this vm's

01:03:08,400 --> 01:03:13,359
specific tx acl mount

01:03:13,920 --> 01:03:19,119
and then similarly for the packets

01:03:17,200 --> 01:03:20,640
coming from the virtual machine this xdp

01:03:19,119 --> 01:03:24,480
egress program

01:03:20,640 --> 01:03:25,680
this instance is referencing maps 46 52

01:03:24,480 --> 01:03:29,200
and 47

01:03:25,680 --> 01:03:31,760
which again become the global vm info

01:03:29,200 --> 01:03:36,240
map

01:03:31,760 --> 01:03:39,520
the vm specific rcl acl rx map

01:03:36,240 --> 01:03:42,720
and the redirect map to the forwarding

01:03:39,520 --> 01:03:43,680
forward ports mount and when i do the

01:03:42,720 --> 01:03:46,880
net show now

01:03:43,680 --> 01:03:49,680
from vpf tool i see each zeros

01:03:46,880 --> 01:03:50,960
map each zero has a program loaded each

01:03:49,680 --> 01:03:52,720
one has the program loaded

01:03:50,960 --> 01:03:55,039
and now this tap device has a program

01:03:52,720 --> 01:03:55,039
loaded

01:03:55,599 --> 01:03:59,760
at that point the vm can be released it

01:03:57,599 --> 01:04:03,520
can finish spinning up

01:03:59,760 --> 01:04:06,960
and i add

01:04:03,520 --> 01:04:10,559
the devmap entry so this is the fdb

01:04:06,960 --> 01:04:12,160
entry sorry this is the devmap entry

01:04:10,559 --> 01:04:14,319
so when the packets are coming into the

01:04:12,160 --> 01:04:15,680
host and they get redirected this tap

01:04:14,319 --> 01:04:18,799
device

01:04:15,680 --> 01:04:21,119
this is the f yeah this is the ftb

01:04:18,799 --> 01:04:22,319
entry sorry getting all these things

01:04:21,119 --> 01:04:25,359
confused

01:04:22,319 --> 01:04:28,480
um and then it's gonna run

01:04:25,359 --> 01:04:32,160
this program on that redirect

01:04:28,480 --> 01:04:33,359
and so when i take my user space program

01:04:32,160 --> 01:04:36,160
which can dump

01:04:33,359 --> 01:04:36,880
the ftb entries this is what it's going

01:04:36,160 --> 01:04:39,280
to show

01:04:36,880 --> 01:04:41,520
this is what it has for the fdb which is

01:04:39,280 --> 01:04:44,880
the vlan and destination mac

01:04:41,520 --> 01:04:48,640
goes to this vm's tap device

01:04:44,880 --> 01:04:51,520
and then when i dump the xtp ports map

01:04:48,640 --> 01:04:52,880
i can see that it has an entry for e0

01:04:51,520 --> 01:04:55,920
eth1

01:04:52,880 --> 01:04:59,520
and the vm's tap device with

01:04:55,920 --> 01:05:00,160
a program attached to it so any reader x

01:04:59,520 --> 01:05:03,280
to two

01:05:00,160 --> 01:05:05,280
and three don't have a program any

01:05:03,280 --> 01:05:08,880
redirects to this tap device

01:05:05,280 --> 01:05:12,319
will have program 67 run on it

01:05:08,880 --> 01:05:14,240
all right and so now

01:05:12,319 --> 01:05:15,520
we can see some traffic coming through

01:05:14,240 --> 01:05:19,119
this 67

01:05:15,520 --> 01:05:23,839
is that vm's address

01:05:19,119 --> 01:05:23,839
and so i'm going to log into that vm

01:05:28,240 --> 01:05:35,760
didn't test this earlier

01:05:31,280 --> 01:05:39,839
all right this is where you oops

01:05:35,760 --> 01:05:39,839
away because i forgot to go in and

01:05:40,799 --> 01:05:46,640
disable the um check some offloads on

01:05:44,880 --> 01:05:51,839
the virtual machine

01:05:46,640 --> 01:05:51,839
so i will have to do that manually here

01:06:14,319 --> 01:06:18,160
now let's see if i can spell each tool

01:06:16,160 --> 01:06:21,280
all right

01:06:18,160 --> 01:06:22,880
so now i can log in and so you get that

01:06:21,280 --> 01:06:23,760
validation that i wasn't kidding about

01:06:22,880 --> 01:06:29,119
the

01:06:23,760 --> 01:06:33,280
the offloads so if you don't have those

01:06:29,119 --> 01:06:35,440
if you're letting the guests expect the

01:06:33,280 --> 01:06:36,400
the hardware offloads to kick in it's

01:06:35,440 --> 01:06:38,319
going to fail

01:06:36,400 --> 01:06:39,599
and you see where i had to go in and

01:06:38,319 --> 01:06:41,920
disable those

01:06:39,599 --> 01:06:44,079
to be able to log into the virtual

01:06:41,920 --> 01:06:45,359
machine

01:06:44,079 --> 01:06:47,520
so one of the things i mentioned was

01:06:45,359 --> 01:06:50,559
blocking port 80.

01:06:47,520 --> 01:06:53,760
so if i were to try to

01:06:50,559 --> 01:06:56,240
go to google.com for example it's going

01:06:53,760 --> 01:06:56,240
to fail

01:06:57,359 --> 01:07:03,119
and go to 43 or 443 so the https version

01:07:00,640 --> 01:07:06,880
of that but i can't get to

01:07:03,119 --> 01:07:08,319
um the acl and the host is blocking me

01:07:06,880 --> 01:07:12,079
from getting out

01:07:08,319 --> 01:07:12,079
going out to straight up port 80.

01:07:12,839 --> 01:07:15,839
uh

01:07:28,319 --> 01:07:35,920
so just to show you that it works

01:07:32,559 --> 01:07:35,920
so i'm going to undo

01:07:36,799 --> 01:07:41,520
i'm going to remove that fdb entry from

01:07:39,920 --> 01:07:43,839
the map

01:07:41,520 --> 01:07:45,200
and so now when i print this there's

01:07:43,839 --> 01:07:46,640
nothing there

01:07:45,200 --> 01:07:49,599
and you're going to start seeing yeah

01:07:46,640 --> 01:07:52,880
you see this traffic going to the vm

01:07:49,599 --> 01:07:55,119
right so showing you that when there's

01:07:52,880 --> 01:07:57,359
an ftb entry

01:07:55,119 --> 01:07:58,400
it takes a fast path when i remove that

01:07:57,359 --> 01:08:00,160
ftb entry

01:07:58,400 --> 01:08:04,160
it's taking the slow path and going

01:08:00,160 --> 01:08:04,160
through going through the bond

01:08:08,400 --> 01:08:13,599
all right anybody have questions on the

01:08:10,559 --> 01:08:16,799
the demo side of that

01:08:13,599 --> 01:08:16,799
that all seem straightforward

01:08:21,600 --> 01:08:26,560
it seems there's a question on the chat

01:08:23,120 --> 01:08:26,560
line by antone

01:08:28,719 --> 01:08:31,759
anthony wants to talk or you can there

01:08:30,799 --> 01:08:33,839
you go i can read

01:08:31,759 --> 01:08:33,839
it

01:08:36,239 --> 01:08:44,239
does it handle connection tracking um

01:08:39,279 --> 01:08:46,080
no that is an open item is to figure out

01:08:44,239 --> 01:08:48,480
what the best course of action is for

01:08:46,080 --> 01:08:52,319
connection tracking

01:08:48,480 --> 01:08:55,759
one option would be to tap into

01:08:52,319 --> 01:08:56,159
that filter um another option would be

01:08:55,759 --> 01:08:58,960
to

01:08:56,159 --> 01:09:00,640
kind of write your own um i know there's

01:08:58,960 --> 01:09:01,279
been a few people who have looked into

01:09:00,640 --> 01:09:05,120
it

01:09:01,279 --> 01:09:07,759
to kind of figure out what a good way to

01:09:05,120 --> 01:09:09,520
have connection tracking within xtp i

01:09:07,759 --> 01:09:12,159
don't think there's any consensus on how

01:09:09,520 --> 01:09:12,159
to do that yet

01:09:13,040 --> 01:09:18,080
i think the question may be what is uh

01:09:16,480 --> 01:09:20,000
what is connection tracking is this

01:09:18,080 --> 01:09:24,080
right is it if you kept

01:09:20,000 --> 01:09:26,560
if you kept uh source destination ip

01:09:24,080 --> 01:09:28,159
protocol state which you can learn very

01:09:26,560 --> 01:09:30,480
easily you can create a hash map that

01:09:28,159 --> 01:09:33,359
stores it

01:09:30,480 --> 01:09:34,319
right dynamically yeah learns lands

01:09:33,359 --> 01:09:36,080
basically

01:09:34,319 --> 01:09:38,799
is that good enough or do you need all

01:09:36,080 --> 01:09:40,000
that uh fancy thing looking at tcp acts

01:09:38,799 --> 01:09:43,359
and all that stuff

01:09:40,000 --> 01:09:45,759
right so yeah this is where

01:09:43,359 --> 01:09:47,040
we've had discussions about what a good

01:09:45,759 --> 01:09:50,000
way to do

01:09:47,040 --> 01:09:52,000
connection tracking or even have a

01:09:50,000 --> 01:09:55,120
fancier acl

01:09:52,000 --> 01:09:55,679
it's i've been focusing more on what was

01:09:55,120 --> 01:09:58,239
needed

01:09:55,679 --> 01:09:59,840
from getting the efficient forwarding

01:09:58,239 --> 01:10:02,400
paths going

01:09:59,840 --> 01:10:04,000
and also the cleanup aspects of it that

01:10:02,400 --> 01:10:07,600
i haven't spent a whole lot of time

01:10:04,000 --> 01:10:08,719
getting into um a proper acl

01:10:07,600 --> 01:10:10,560
implementation

01:10:08,719 --> 01:10:11,840
so i get what you're saying now about

01:10:10,560 --> 01:10:13,280
you want to allow

01:10:11,840 --> 01:10:15,040
all the outbound traffic but you only

01:10:13,280 --> 01:10:17,520
want to allow inbound

01:10:15,040 --> 01:10:18,400
ssh sessions for example it's completely

01:10:17,520 --> 01:10:20,159
doable

01:10:18,400 --> 01:10:22,640
it's just a matter of how you'd express

01:10:20,159 --> 01:10:24,880
that from an acl perspective

01:10:22,640 --> 01:10:27,679
so for example the flow parser could

01:10:24,880 --> 01:10:31,280
easily look at

01:10:27,679 --> 01:10:34,480
tcp headers and look and

01:10:31,280 --> 01:10:36,560
mark packets that are sends and allow

01:10:34,480 --> 01:10:39,679
those through

01:10:36,560 --> 01:10:42,400
and then for port 22 but then block

01:10:39,679 --> 01:10:42,400
everything else

01:10:42,960 --> 01:10:46,080
or you could have full-blown connection

01:10:45,360 --> 01:10:49,679
tracking

01:10:46,080 --> 01:10:50,400
where you keep track of what connections

01:10:49,679 --> 01:10:51,760
exist and

01:10:50,400 --> 01:10:54,000
you know only allow new connections to

01:10:51,760 --> 01:10:55,760
port 22. you know all that it's doable i

01:10:54,000 --> 01:10:56,080
mean we have it for netfilter we have it

01:10:55,760 --> 01:10:58,719
in

01:10:56,080 --> 01:11:00,880
other other places um it's just a matter

01:10:58,719 --> 01:11:03,440
of someone

01:11:00,880 --> 01:11:05,280
either writing it themselves in evpf or

01:11:03,440 --> 01:11:08,560
figuring out how to tap into the

01:11:05,280 --> 01:11:10,239
existing kernel facilities to do it

01:11:08,560 --> 01:11:12,159
i i'm not sure if you need counting

01:11:10,239 --> 01:11:14,640
facilities to answer what uh

01:11:12,159 --> 01:11:16,800
he needs if you can track if you can

01:11:14,640 --> 01:11:18,560
share the table between the ingress and

01:11:16,800 --> 01:11:20,719
the egress

01:11:18,560 --> 01:11:22,239
and then populate the table of outgoing

01:11:20,719 --> 01:11:24,880
packets

01:11:22,239 --> 01:11:26,560
and then ingress looks uses that you

01:11:24,880 --> 01:11:27,679
know your aqua table looked very simple

01:11:26,560 --> 01:11:29,040
but

01:11:27,679 --> 01:11:30,719
if you could you could break it down and

01:11:29,040 --> 01:11:31,440
make it something that gets populated at

01:11:30,719 --> 01:11:34,239
runtime

01:11:31,440 --> 01:11:35,360
by outgoing packets right yeah on

01:11:34,239 --> 01:11:39,199
incoming you you

01:11:35,360 --> 01:11:41,280
use a key source destination ipod

01:11:39,199 --> 01:11:42,880
and only allow it if a packet has come

01:11:41,280 --> 01:11:45,760
out of the host right

01:11:42,880 --> 01:11:47,840
yeah and the xdp program can also you

01:11:45,760 --> 01:11:51,520
know you could have a bigger

01:11:47,840 --> 01:11:53,679
hash map for the different acls

01:11:51,520 --> 01:11:55,840
and you could have the xp program itself

01:11:53,679 --> 01:11:57,520
say i've seen this packet i'm going to

01:11:55,840 --> 01:12:00,719
log an entry here

01:11:57,520 --> 01:12:01,440
and deny others you know like you can do

01:12:00,719 --> 01:12:04,480
that all that

01:12:01,440 --> 01:12:05,520
within edp app and using the maps it's

01:12:04,480 --> 01:12:07,360
just a question of

01:12:05,520 --> 01:12:08,640
yeah i think you really get someone

01:12:07,360 --> 01:12:11,280
sitting down and figuring out what the

01:12:08,640 --> 01:12:11,280
right way to do

01:12:12,080 --> 01:12:17,600
so there was a question about disabling

01:12:14,480 --> 01:12:17,600
tso on the guest

01:12:18,560 --> 01:12:23,040
remember what comments i have coming up

01:12:21,280 --> 01:12:26,719
so the workshop yesterday

01:12:23,040 --> 01:12:29,040
i can tell you that oh

01:12:26,719 --> 01:12:30,400
i will get into that i get into a

01:12:29,040 --> 01:12:31,360
different there's two different problems

01:12:30,400 --> 01:12:34,320
coming up

01:12:31,360 --> 01:12:35,600
so in this case it's the disabling c

01:12:34,320 --> 01:12:37,679
texoman tso

01:12:35,600 --> 01:12:39,120
for gas so it can't rely on the hardware

01:12:37,679 --> 01:12:42,560
to segment stuff

01:12:39,120 --> 01:12:45,760
i have played around with melanox driver

01:12:42,560 --> 01:12:48,400
and enabled the checksum

01:12:45,760 --> 01:12:50,000
options so that it always took care of

01:12:48,400 --> 01:12:52,560
this on its own

01:12:50,000 --> 01:12:54,080
and it's possible so again this is

01:12:52,560 --> 01:12:54,800
something i brought up yesterday which

01:12:54,080 --> 01:12:56,719
is

01:12:54,800 --> 01:12:57,920
people need to spend more time thinking

01:12:56,719 --> 01:13:01,760
about

01:12:57,920 --> 01:13:04,000
um the tx path of it

01:13:01,760 --> 01:13:06,080
and what's needed to leverage some of

01:13:04,000 --> 01:13:09,520
the hardware acceleration pieces

01:13:06,080 --> 01:13:11,520
um it is kind of a hard sell to

01:13:09,520 --> 01:13:13,280
have to disable hardware acceleration

01:13:11,520 --> 01:13:14,239
features to use a software acceleration

01:13:13,280 --> 01:13:17,120
feature

01:13:14,239 --> 01:13:17,600
i think that's why right now i see the

01:13:17,120 --> 01:13:21,120
biggest

01:13:17,600 --> 01:13:23,040
gains for packets going to a vm

01:13:21,120 --> 01:13:25,040
and i think once we get the checksum and

01:13:23,040 --> 01:13:27,199
the tso piece which jasper's referencing

01:13:25,040 --> 01:13:29,440
the multi multi-buffer work

01:13:27,199 --> 01:13:30,239
once that side goes in i think you'll

01:13:29,440 --> 01:13:34,080
start seeing

01:13:30,239 --> 01:13:37,199
much much a bigger improvement

01:13:34,080 --> 01:13:39,920
on host cycles when you can keep

01:13:37,199 --> 01:13:41,360
all this hardware stuff on as opposed to

01:13:39,920 --> 01:13:42,400
what you do today which case you don't

01:13:41,360 --> 01:13:45,280
see that much

01:13:42,400 --> 01:13:47,760
additional gain from the tx path from

01:13:45,280 --> 01:13:49,600
the vm egress path

01:13:47,760 --> 01:13:50,960
so i guess the short answer there is

01:13:49,600 --> 01:13:54,960
some more work is needed

01:13:50,960 --> 01:13:54,960
to really get the full benefit of it

01:13:58,000 --> 01:14:03,120
um so the throughput trade-off i haven't

01:14:01,040 --> 01:14:06,239
done a whole lot of tests yet

01:14:03,120 --> 01:14:09,280
when packets coming out of the vm

01:14:06,239 --> 01:14:11,440
so right now i've been focusing on

01:14:09,280 --> 01:14:12,719
the benefits of packets being delivered

01:14:11,440 --> 01:14:14,719
to a virtual machine

01:14:12,719 --> 01:14:16,159
and using xdp to go around the host

01:14:14,719 --> 01:14:18,880
stack so

01:14:16,159 --> 01:14:20,000
your answer about disabling guest tso

01:14:18,880 --> 01:14:21,520
trade-off

01:14:20,000 --> 01:14:23,679
i think we'll find that out hopefully

01:14:21,520 --> 01:14:25,520
within you know

01:14:23,679 --> 01:14:27,440
what there's multi-buffer support it's

01:14:25,520 --> 01:14:29,760
been proposed

01:14:27,440 --> 01:14:31,120
if we can get that usable and start

01:14:29,760 --> 01:14:35,040
doing some benchmarks on it

01:14:31,120 --> 01:14:36,400
to get that data preserve offloads if

01:14:35,040 --> 01:14:41,120
we're running this in tc

01:14:36,400 --> 01:14:43,280
ingress yes but

01:14:41,120 --> 01:14:45,120
you don't get the full benefit if you're

01:14:43,280 --> 01:14:47,199
using the tc hooks

01:14:45,120 --> 01:14:49,360
and that's part of why i started

01:14:47,199 --> 01:14:50,560
changing all my programs to do both tc

01:14:49,360 --> 01:14:53,199
and xdp

01:14:50,560 --> 01:14:54,239
was so that i can do performance tests

01:14:53,199 --> 01:14:57,040
again same code

01:14:54,239 --> 01:14:57,760
same logic same everything but i get the

01:14:57,040 --> 01:15:00,960
test

01:14:57,760 --> 01:15:04,640
xdp gains versus the tc

01:15:00,960 --> 01:15:05,679
um classifier path and it's just not as

01:15:04,640 --> 01:15:07,360
much

01:15:05,679 --> 01:15:09,679
you know there's not as much of a of a

01:15:07,360 --> 01:15:13,199
kick from going to uvpf route

01:15:09,679 --> 01:15:13,199
at least from what i've seen so far

01:15:18,880 --> 01:15:23,280
all right i think i just have a couple

01:15:20,719 --> 01:15:26,960
of more slides here

01:15:23,280 --> 01:15:28,480
and the last area i want to touch on is

01:15:26,960 --> 01:15:30,239
and this is where i got confused by that

01:15:28,480 --> 01:15:32,640
question about the tsoc sum because

01:15:30,239 --> 01:15:34,719
there's another problem coming up

01:15:32,640 --> 01:15:36,159
you want to run xdp inside the virtual

01:15:34,719 --> 01:15:36,880
machines right so this is another part

01:15:36,159 --> 01:15:40,880
of the

01:15:36,880 --> 01:15:43,840
bigger cloud host problem with xdp

01:15:40,880 --> 01:15:44,560
there are two major problems for using

01:15:43,840 --> 01:15:47,440
xdp

01:15:44,560 --> 01:15:48,719
inside of a virtual machine when the kvm

01:15:47,440 --> 01:15:52,880
is using virtio net

01:15:48,719 --> 01:15:56,560
as the nik type

01:15:52,880 --> 01:15:59,360
so if you try to attach a program

01:15:56,560 --> 01:16:02,880
and you get this error message back xcp

01:15:59,360 --> 01:16:04,480
expects header data in a single page

01:16:02,880 --> 01:16:05,840
odds are and i'm not going to say this

01:16:04,480 --> 01:16:06,960
is always the case but it's been the

01:16:05,840 --> 01:16:09,199
case for

01:16:06,960 --> 01:16:10,880
the ones i've had control of and can go

01:16:09,199 --> 01:16:13,120
look at the host side

01:16:10,880 --> 01:16:15,040
your machine type is too old so for

01:16:13,120 --> 01:16:18,640
example live bert is using

01:16:15,040 --> 01:16:20,560
a 1.5 machine model and if you bump that

01:16:18,640 --> 01:16:24,239
up to 4.1

01:16:20,560 --> 01:16:26,800
you will get past that error message

01:16:24,239 --> 01:16:27,440
and you will actually get to the next

01:16:26,800 --> 01:16:30,080
problem

01:16:27,440 --> 01:16:31,360
which is you try to load a program and

01:16:30,080 --> 01:16:34,400
it says too few

01:16:31,360 --> 01:16:35,679
tx rings available the problem is you

01:16:34,400 --> 01:16:38,000
have to have a multi-cue

01:16:35,679 --> 01:16:40,000
neck for the virtual machine and what

01:16:38,000 --> 01:16:42,320
that means is

01:16:40,000 --> 01:16:43,199
however many virtual cpus the machine

01:16:42,320 --> 01:16:46,000
has

01:16:43,199 --> 01:16:46,560
you need twice that many cues on that

01:16:46,000 --> 01:16:48,560
neck

01:16:46,560 --> 01:16:51,280
if you expect to load an xtp program to

01:16:48,560 --> 01:16:55,360
it and that applies to every tap device

01:16:51,280 --> 01:16:55,360
that you want to load a bpf program on

01:16:58,080 --> 01:17:02,640
another problem that comes in so let's

01:17:01,040 --> 01:17:04,080
say you get past that you have the right

01:17:02,640 --> 01:17:07,679
machine model

01:17:04,080 --> 01:17:10,159
you have the right um number of cues

01:17:07,679 --> 01:17:11,040
that goes with the the virtual machine

01:17:10,159 --> 01:17:13,360
um

01:17:11,040 --> 01:17:16,400
the next problem you're gonna hit is the

01:17:13,360 --> 01:17:17,600
guest performance dramatically drops

01:17:16,400 --> 01:17:20,320
so for example as a lot of this

01:17:17,600 --> 01:17:22,159
benchmark testing i've done

01:17:20,320 --> 01:17:23,679
i want to drop packets in the host as

01:17:22,159 --> 01:17:25,280
soon as possible because the only thing

01:17:23,679 --> 01:17:27,040
i want to measure is

01:17:25,280 --> 01:17:29,120
what it takes to get a packet from the

01:17:27,040 --> 01:17:30,560
wire into the vm and then have the guest

01:17:29,120 --> 01:17:32,159
drop it

01:17:30,560 --> 01:17:34,880
the problem is as soon as i loaded an

01:17:32,159 --> 01:17:38,719
xtv program inside the vm

01:17:34,880 --> 01:17:41,280
everything changed because vertionette

01:17:38,719 --> 01:17:42,000
is telling qmu i think it's i think this

01:17:41,280 --> 01:17:45,600
is the path

01:17:42,000 --> 01:17:46,480
that tells qmu to disable tso and tx

01:17:45,600 --> 01:17:49,360
checksum

01:17:46,480 --> 01:17:50,719
on the tap device so these packets are

01:17:49,360 --> 01:17:53,679
coming in

01:17:50,719 --> 01:17:55,360
and as soon as it hits the tap device

01:17:53,679 --> 01:17:56,719
the host has some extra work to do

01:17:55,360 --> 01:17:58,400
before it can actually push those

01:17:56,719 --> 01:17:59,760
packets up to the vm

01:17:58,400 --> 01:18:02,640
and so the performance measurements

01:17:59,760 --> 01:18:02,640
completely changed

01:18:03,040 --> 01:18:06,640
so something to keep in mind and i don't

01:18:05,679 --> 01:18:08,239
know why

01:18:06,640 --> 01:18:11,360
i was really surprised by this one i

01:18:08,239 --> 01:18:14,480
don't know why it has to disable that

01:18:11,360 --> 01:18:17,360
because if i'm doing xdp for example

01:18:14,480 --> 01:18:17,360
for the redirects

01:18:18,400 --> 01:18:24,159
i shouldn't have to disable that and if

01:18:21,199 --> 01:18:27,040
i'm doing skb is coming up

01:18:24,159 --> 01:18:29,199
that's a normal path up the stack so why

01:18:27,040 --> 01:18:31,840
does an xtv program

01:18:29,199 --> 01:18:32,560
inside the vm affect what has to happen

01:18:31,840 --> 01:18:34,239
on the host

01:18:32,560 --> 01:18:36,239
so if someone has an answer to that i

01:18:34,239 --> 01:18:37,760
was really confused

01:18:36,239 --> 01:18:39,360
but i'm just throwing this out here as

01:18:37,760 --> 01:18:42,960
that warning to others about

01:18:39,360 --> 01:18:42,960
what's what's happening behind your back

01:18:43,520 --> 01:18:48,480
all right so like i mentioned earlier

01:18:46,800 --> 01:18:50,000
i'm writing a blog post

01:18:48,480 --> 01:18:51,679
i've been working on this for a while

01:18:50,000 --> 01:18:52,800
i'm going to finally i publish it this

01:18:51,679 --> 01:18:54,960
weekend

01:18:52,800 --> 01:18:56,000
this is kind of a telling graph behind

01:18:54,960 --> 01:18:58,719
it

01:18:56,000 --> 01:19:00,320
so this data is collected using that

01:18:58,719 --> 01:19:02,239
demo script where it's

01:19:00,320 --> 01:19:04,000
putting the forwarding program on need

01:19:02,239 --> 01:19:06,080
zero week one

01:19:04,000 --> 01:19:08,080
doing the acl entries so it's parsing

01:19:06,080 --> 01:19:09,679
the packet from a flow perspective

01:19:08,080 --> 01:19:11,360
to look for acl entries to do

01:19:09,679 --> 01:19:15,040
verifications

01:19:11,360 --> 01:19:18,400
and when you look at the amount of work

01:19:15,040 --> 01:19:20,800
that the host has to do to push packets

01:19:18,400 --> 01:19:21,600
from the wire into a virtual machine you

01:19:20,800 --> 01:19:24,719
can see

01:19:21,600 --> 01:19:26,880
that with xdp it is much

01:19:24,719 --> 01:19:28,640
less than any kind of full stack like

01:19:26,880 --> 01:19:32,400
obs has to do

01:19:28,640 --> 01:19:33,120
so in this case with xdp i actually hit

01:19:32,400 --> 01:19:36,000
the limits

01:19:33,120 --> 01:19:37,040
of my packet generating setup as opposed

01:19:36,000 --> 01:19:39,040
to ovs

01:19:37,040 --> 01:19:40,480
where i could saturate it and couldn't

01:19:39,040 --> 01:19:41,840
do anything more like packets were

01:19:40,480 --> 01:19:44,880
getting dropped on either

01:19:41,840 --> 01:19:48,719
host ingress vm ingress

01:19:44,880 --> 01:19:48,719
or what was the other one

01:19:48,880 --> 01:19:52,239
i forget now but anyway packers are

01:19:50,800 --> 01:19:53,120
getting dropped everywhere with obs

01:19:52,239 --> 01:19:53,920
because it was just completely

01:19:53,120 --> 01:19:56,719
saturating

01:19:53,920 --> 01:19:58,159
the cpu with with uh handling all the

01:19:56,719 --> 01:20:01,360
packets coming in

01:19:58,159 --> 01:20:02,880
so xcp has its huge benefits and i'm

01:20:01,360 --> 01:20:03,760
sure jasper could probably answer this

01:20:02,880 --> 01:20:06,480
one but

01:20:03,760 --> 01:20:07,199
there is this sweet spot around 50k to

01:20:06,480 --> 01:20:09,760
500k

01:20:07,199 --> 01:20:11,040
packets where xdp seemed to be almost

01:20:09,760 --> 01:20:13,520
flatlined

01:20:11,040 --> 01:20:14,800
and doing perf reports for example it

01:20:13,520 --> 01:20:16,239
just seemed like there was i don't know

01:20:14,800 --> 01:20:17,520
if it's bulking efficiencies or

01:20:16,239 --> 01:20:19,199
something's kicking in

01:20:17,520 --> 01:20:20,960
where the kernel didn't it wasn't

01:20:19,199 --> 01:20:23,520
continuing to take on more and more work

01:20:20,960 --> 01:20:25,840
as it took on more and more packets

01:20:23,520 --> 01:20:27,840
and it's super repeatable so i would

01:20:25,840 --> 01:20:29,600
expect anyone

01:20:27,840 --> 01:20:31,360
who wants to play around with with this

01:20:29,600 --> 01:20:33,360
could take my scripts

01:20:31,360 --> 01:20:35,679
download that repository compile it on

01:20:33,360 --> 01:20:38,960
your kernel version

01:20:35,679 --> 01:20:40,239
update the vm information in the top of

01:20:38,960 --> 01:20:41,520
that demo script

01:20:40,239 --> 01:20:44,880
it should be able to run it on your

01:20:41,520 --> 01:20:48,000
local machine and see the same kinds of

01:20:44,880 --> 01:20:48,880
um see the same setup that i'm doing on

01:20:48,000 --> 01:20:50,800
this machine here

01:20:48,880 --> 01:20:52,080
at least that was the point of this this

01:20:50,800 --> 01:20:55,600
demo and the tutorial

01:20:52,080 --> 01:20:58,880
and pushing everything to github so

01:20:55,600 --> 01:21:00,960
one final set of comments um

01:20:58,880 --> 01:21:03,920
things people have to keep in mind about

01:21:00,960 --> 01:21:06,719
bypassing the full stack with xtp

01:21:03,920 --> 01:21:08,080
um you are losing things like some of

01:21:06,719 --> 01:21:09,360
the software

01:21:08,080 --> 01:21:11,440
features that have been put in over the

01:21:09,360 --> 01:21:13,120
years like rps

01:21:11,440 --> 01:21:15,840
so the packet steering where you're

01:21:13,120 --> 01:21:19,040
distributing packets across all the cpus

01:21:15,840 --> 01:21:21,120
for for handling and also

01:21:19,040 --> 01:21:22,639
part of that's the flow steering and any

01:21:21,120 --> 01:21:24,880
kind of advanced or

01:21:22,639 --> 01:21:26,239
accelerated flow steering with that

01:21:24,880 --> 01:21:27,120
which is the hardware offload piece of

01:21:26,239 --> 01:21:30,960
that

01:21:27,120 --> 01:21:33,679
so with xdp you are 100 relying on

01:21:30,960 --> 01:21:35,760
packet distribution within the hardware

01:21:33,679 --> 01:21:38,080
if that matters to you

01:21:35,760 --> 01:21:39,120
and then as we as we discussed earlier

01:21:38,080 --> 01:21:41,920
um

01:21:39,120 --> 01:21:43,280
you're bypassing the bridge so if bridge

01:21:41,920 --> 01:21:46,080
learning is relevant

01:21:43,280 --> 01:21:46,719
then maybe this bpf helper that that

01:21:46,080 --> 01:21:49,040
someone was

01:21:46,719 --> 01:21:50,000
was looking into might be a better

01:21:49,040 --> 01:21:53,280
solution for you

01:21:50,000 --> 01:21:56,480
than doing something like a static map

01:21:53,280 --> 01:21:58,800
where you're hard coding the entries

01:21:56,480 --> 01:22:01,600
and then the other one that was

01:21:58,800 --> 01:22:03,360
unfortunate with xdp

01:22:01,600 --> 01:22:05,679
we don't have access to hardware

01:22:03,360 --> 01:22:07,199
timestamps so for example i've written a

01:22:05,679 --> 01:22:10,000
program where

01:22:07,199 --> 01:22:10,880
the hardware timestamps the packets and

01:22:10,000 --> 01:22:13,440
i look at how long

01:22:10,880 --> 01:22:14,880
it takes like latencies to deliver those

01:22:13,440 --> 01:22:18,080
packets to

01:22:14,880 --> 01:22:21,199
the ton it's a handoff

01:22:18,080 --> 01:22:22,880
to the ton driver or the

01:22:21,199 --> 01:22:24,239
socket side of the tundra we're sending

01:22:22,880 --> 01:22:26,560
it off to the virtual machine

01:22:24,239 --> 01:22:28,480
to get a sense of what latency the host

01:22:26,560 --> 01:22:31,360
stack is introducing

01:22:28,480 --> 01:22:33,440
and with xdp you lose access to those

01:22:31,360 --> 01:22:34,639
ptp timestamps to be able to do those

01:22:33,440 --> 01:22:36,159
kinds of analysis

01:22:34,639 --> 01:22:38,159
i know that was brought up yesterday as

01:22:36,159 --> 01:22:40,400
well as something we got to figure out

01:22:38,159 --> 01:22:43,280
how to get those kind of capabilities in

01:22:40,400 --> 01:22:46,480
into the metadata i guess

01:22:43,280 --> 01:22:49,679
and that was all i had so

01:22:46,480 --> 01:22:50,840
any questions you a bunch of the chat

01:22:49,679 --> 01:22:53,840
line

01:22:50,840 --> 01:22:53,840
okay

01:22:58,400 --> 01:23:07,840
all right um 10x

01:23:02,080 --> 01:23:07,840
okay see

01:23:08,800 --> 01:23:15,040
okay uh

01:23:11,840 --> 01:23:16,239
yeah definitely on the the eppf programs

01:23:15,040 --> 01:23:19,199
and the acls

01:23:16,239 --> 01:23:20,800
uh like i said i have spent minimal time

01:23:19,199 --> 01:23:22,080
looking at the acl side of it i've been

01:23:20,800 --> 01:23:24,080
more focused on

01:23:22,080 --> 01:23:25,679
forwarding and getting features and and

01:23:24,080 --> 01:23:28,960
data from that side of it

01:23:25,679 --> 01:23:30,560
but also knowing that acl is going to

01:23:28,960 --> 01:23:32,719
require things like

01:23:30,560 --> 01:23:34,960
packet parsing and so i want this to be

01:23:32,719 --> 01:23:37,840
a little bit of a fair comparison

01:23:34,960 --> 01:23:39,520
with obs in the sense of i want the

01:23:37,840 --> 01:23:41,199
programs to

01:23:39,520 --> 01:23:43,520
do something so that's why i added in

01:23:41,199 --> 01:23:45,520
the flow the flow parsing

01:23:43,520 --> 01:23:46,560
and the acl lookups was to have the

01:23:45,520 --> 01:23:48,159
programs

01:23:46,560 --> 01:23:49,600
doing some extra work to make it a

01:23:48,159 --> 01:23:52,639
little better obs

01:23:49,600 --> 01:23:52,639
xcp comparison

01:23:58,400 --> 01:24:01,600
and the comment about verdio net

01:23:59,920 --> 01:24:03,760
disabling offloads

01:24:01,600 --> 01:24:04,719
yeah what's confusing to me is the fact

01:24:03,760 --> 01:24:06,480
that

01:24:04,719 --> 01:24:07,920
these are packets that are coming

01:24:06,480 --> 01:24:11,440
through the host and going

01:24:07,920 --> 01:24:12,480
to the vm so why does that part need to

01:24:11,440 --> 01:24:15,120
be disabled

01:24:12,480 --> 01:24:15,679
just because there's an xtp program on

01:24:15,120 --> 01:24:18,080
on the top

01:24:15,679 --> 01:24:19,760
or on the neck inside the guest the host

01:24:18,080 --> 01:24:22,320
already has the packet

01:24:19,760 --> 01:24:23,679
the host is already ready to deliver it

01:24:22,320 --> 01:24:25,920
um

01:24:23,679 --> 01:24:26,719
i guess the tso side of that would be to

01:24:25,920 --> 01:24:30,639
keep it from

01:24:26,719 --> 01:24:34,560
having large packets coming in

01:24:30,639 --> 01:24:37,520
um i guess that would get into the 1 500

01:24:34,560 --> 01:24:38,719
mtu limitation or 4k limitation that

01:24:37,520 --> 01:24:43,120
exists today for xtv

01:24:38,719 --> 01:24:46,159
programs um the checksum piece of that

01:24:43,120 --> 01:24:48,320
yeah okay yeah i guess i could explain

01:24:46,159 --> 01:24:48,320
it

01:24:50,880 --> 01:24:56,080
all right there any other any other

01:24:56,840 --> 01:24:59,840
questions

01:25:07,600 --> 01:25:11,760
all right so again codes on github

01:25:10,719 --> 01:25:15,360
please

01:25:11,760 --> 01:25:17,280
you know take a look at it try it out um

01:25:15,360 --> 01:25:19,440
you know maybe maybe andre i see you're

01:25:17,280 --> 01:25:22,159
attending uh

01:25:19,440 --> 01:25:22,960
do something equivalent to the route

01:25:22,159 --> 01:25:25,120
base

01:25:22,960 --> 01:25:26,000
where you did some experiments showing

01:25:25,120 --> 01:25:28,719
you know the benefits

01:25:26,000 --> 01:25:30,639
of an xtp based router this was really

01:25:28,719 --> 01:25:34,719
looking at it from an l2 perspective

01:25:30,639 --> 01:25:40,400
and you know i think you see similar

01:25:34,719 --> 01:25:42,639
results for that

01:25:40,400 --> 01:25:42,639
yes

01:25:47,120 --> 01:25:52,560
all right and again it's on github so uh

01:25:51,120 --> 01:25:54,400
if you anybody has suggestions on

01:25:52,560 --> 01:25:57,040
changes feel free to propose it send

01:25:54,400 --> 01:25:57,040
pull requests

01:25:57,199 --> 01:26:00,159
yeah i hope you find it here

01:26:00,239 --> 01:26:03,840

YouTube URL: https://www.youtube.com/watch?v=l9C-ANkN1-Q


