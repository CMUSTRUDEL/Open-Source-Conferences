Title: Netdev 0x14 - Performance optimization using AI
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Marta Plantykow, Piotr Raczynski, Maciej Machnikowski, Pawel Szymanski

More info: https://netdevconf.info/0x14/session.html?talk-performance-optimization-using-artificial-intelligence-methods

Date: Friday, August 14, 2020

In this moonshot talk Marta Plantykow, Piotr Raczynski,
Maciej Machnikowski and Pawel Szymanski will discuss an approach
to optimize networking performance alongside CPU utilization
with ML.
Marta et al propose an approach which will use ML to study RSS
patterns and the CPU spread and then react dynamically to
modify RSS hash parameters to improve CPU spread.

The authors will go over the challenges they overcame, show some
performance numbers and solicit feedback.
Captions: 
	00:00:00,799 --> 00:00:04,080
hi my name is marta

00:00:04,799 --> 00:00:08,639
hi my name is matic and my name is

00:00:07,600 --> 00:00:12,160
pierce and

00:00:08,639 --> 00:00:14,240
we would like to present our idea

00:00:12,160 --> 00:00:17,119
and the results of the research how

00:00:14,240 --> 00:00:19,840
you'd like to optimize

00:00:17,119 --> 00:00:20,800
network performance using artificial

00:00:19,840 --> 00:00:23,199
intelligence

00:00:20,800 --> 00:00:23,199
methods

00:00:27,359 --> 00:00:32,960
so first of all our

00:00:30,480 --> 00:00:35,040
problem statement and the goal so the

00:00:32,960 --> 00:00:38,399
problem statement is that we

00:00:35,040 --> 00:00:39,280
were identified that under certain

00:00:38,399 --> 00:00:42,480
conditions

00:00:39,280 --> 00:00:45,600
a traffic coming to a system

00:00:42,480 --> 00:00:46,879
can be unevenly balanced even with all

00:00:45,600 --> 00:00:50,559
the features

00:00:46,879 --> 00:00:53,199
in working to spread the traffic

00:00:50,559 --> 00:00:53,600
between the cpus so you would like to

00:00:53,199 --> 00:00:57,199
find

00:00:53,600 --> 00:01:01,840
an efficient way to

00:00:57,199 --> 00:01:05,040
to spread the given ipv4 traffic evenly

00:01:01,840 --> 00:01:08,799
amongst the cpus in the system

00:01:05,040 --> 00:01:11,280
using our receive site scaling

00:01:08,799 --> 00:01:12,320
so first of all we'll go over briefly

00:01:11,280 --> 00:01:15,920
what's uh

00:01:12,320 --> 00:01:18,560
what's rss what are the problem how it

00:01:15,920 --> 00:01:20,640
works what are the problems with rss and

00:01:18,560 --> 00:01:22,880
i would like to show you how you would

00:01:20,640 --> 00:01:26,400
like to optimize

00:01:22,880 --> 00:01:30,320
key key generation for

00:01:26,400 --> 00:01:30,320
rss using ai

00:01:30,880 --> 00:01:38,479
first of all rss stands for

00:01:34,479 --> 00:01:41,840
receive site scaling and it's a

00:01:38,479 --> 00:01:47,280
technology used in modern network cards

00:01:41,840 --> 00:01:50,640
that allows the received packets to be

00:01:47,280 --> 00:01:53,040
redirected to and balanced to

00:01:50,640 --> 00:01:55,200
uh between the queues and between the

00:01:53,040 --> 00:01:57,920
cpus in the system

00:01:55,200 --> 00:02:00,320
so it enables efficient distribution of

00:01:57,920 --> 00:02:03,360
network packets

00:02:00,320 --> 00:02:07,040
between the cores and

00:02:03,360 --> 00:02:09,599
it also produces a delay

00:02:07,040 --> 00:02:12,480
with in the processing because the the

00:02:09,599 --> 00:02:15,680
traffic is spread amongst

00:02:12,480 --> 00:02:18,959
cpus uh it can also optimize

00:02:15,680 --> 00:02:22,080
the software processing the

00:02:18,959 --> 00:02:24,640
packets since the uh

00:02:22,080 --> 00:02:26,000
all the packets of a particular collect

00:02:24,640 --> 00:02:29,440
connection or a flow

00:02:26,000 --> 00:02:29,920
are redirected to the same cpu that will

00:02:29,440 --> 00:02:32,720
be

00:02:29,920 --> 00:02:33,200
processing the packets and usually the

00:02:32,720 --> 00:02:36,480
same

00:02:33,200 --> 00:02:38,720
cpu and will process the packets in the

00:02:36,480 --> 00:02:42,400
user space as well so we can

00:02:38,720 --> 00:02:45,920
have the locality of the packet

00:02:42,400 --> 00:02:49,040
from a given uh flow also

00:02:45,920 --> 00:02:51,519
what's worth to mention is that rss

00:02:49,040 --> 00:02:52,959
while spreading and balancing the

00:02:51,519 --> 00:02:56,560
packets between the

00:02:52,959 --> 00:02:59,280
cpus it also

00:02:56,560 --> 00:03:01,200
does not break by itself in order

00:02:59,280 --> 00:03:04,879
processing

00:03:01,200 --> 00:03:08,879
so the way the packets are processed

00:03:04,879 --> 00:03:11,920
in the network card which is done

00:03:08,879 --> 00:03:15,040
in order while the rss

00:03:11,920 --> 00:03:19,440
is spreading those packets among cpus

00:03:15,040 --> 00:03:22,400
it keeps the in order processing so

00:03:19,440 --> 00:03:24,239
uh we don't have reordering uh

00:03:22,400 --> 00:03:28,000
introduced by

00:03:24,239 --> 00:03:32,480
rss and also rss is

00:03:28,000 --> 00:03:36,560
not meant to uh

00:03:32,480 --> 00:03:39,040
um to direct the packet to a specific

00:03:36,560 --> 00:03:40,480
cpu that the user would like to by

00:03:39,040 --> 00:03:43,440
default it just

00:03:40,480 --> 00:03:44,879
it's limited to just spread the packets

00:03:43,440 --> 00:03:48,640
and

00:03:44,879 --> 00:03:52,799
balance the load over the cpus

00:03:48,640 --> 00:03:55,840
in the system so

00:03:52,799 --> 00:03:59,519
the quick look how it works

00:03:55,840 --> 00:04:02,239
so network card extracts some data

00:03:59,519 --> 00:04:03,920
from the from the packet some correct

00:04:02,239 --> 00:04:06,400
characteristic data

00:04:03,920 --> 00:04:08,560
from the packet that will that can help

00:04:06,400 --> 00:04:11,920
to identify a flow

00:04:08,560 --> 00:04:15,200
those are usually ap addresses

00:04:11,920 --> 00:04:17,199
for ipv4 and some additional information

00:04:15,200 --> 00:04:20,239
depending on the protocol like source

00:04:17,199 --> 00:04:20,239
and destination port

00:04:20,479 --> 00:04:24,240
and those are given to the hashing

00:04:23,040 --> 00:04:28,560
function

00:04:24,240 --> 00:04:31,040
which also takes a initial value

00:04:28,560 --> 00:04:32,450
as a hash key and then as a result we

00:04:31,040 --> 00:04:33,840
have a

00:04:32,450 --> 00:04:38,639
[Music]

00:04:33,840 --> 00:04:42,240
a hash value which then the number of

00:04:38,639 --> 00:04:42,880
lower significant bits of the of the

00:04:42,240 --> 00:04:46,320
hash

00:04:42,880 --> 00:04:48,320
is taken and

00:04:46,320 --> 00:04:49,840
lookup is being made in the indirection

00:04:48,320 --> 00:04:53,360
table to

00:04:49,840 --> 00:04:57,840
specify the queue and eventually the cpu

00:04:53,360 --> 00:04:57,840
that will that will get the packet

00:04:58,000 --> 00:05:07,120
so for tcp over

00:05:01,919 --> 00:05:07,120
ipv4 the input set itself

00:05:07,199 --> 00:05:12,560
is contains both destination and source

00:05:11,520 --> 00:05:16,400
ip addresses

00:05:12,560 --> 00:05:21,199
and destination and source

00:05:16,400 --> 00:05:24,880
ports which totals with 12 bytes

00:05:21,199 --> 00:05:28,080
of the input set for ipv4

00:05:24,880 --> 00:05:32,880
compared to ipv6 which is

00:05:28,080 --> 00:05:32,880
for the same type of protocol it's

00:05:33,120 --> 00:05:39,050
36 bytes extracted from the incoming

00:05:37,600 --> 00:05:40,639
packet

00:05:39,050 --> 00:05:43,440
[Music]

00:05:40,639 --> 00:05:43,440
for rss

00:05:43,840 --> 00:05:49,120
so machi will go over and detail how the

00:05:47,039 --> 00:05:52,560
hashing function

00:05:49,120 --> 00:05:55,440
works okay

00:05:52,560 --> 00:05:55,840
so now that we've extracted the input

00:05:55,440 --> 00:05:58,800
set

00:05:55,840 --> 00:05:59,919
we need to run it through some hashing

00:05:58,800 --> 00:06:03,199
function

00:05:59,919 --> 00:06:06,880
the most popular one is stop leads hash

00:06:03,199 --> 00:06:07,840
and as a first step we wanted to

00:06:06,880 --> 00:06:10,960
understand

00:06:07,840 --> 00:06:13,520
better how this hashing method works

00:06:10,960 --> 00:06:15,199
and because that's crucial for key

00:06:13,520 --> 00:06:18,080
optimization

00:06:15,199 --> 00:06:18,479
the principle of top leads hash is that

00:06:18,080 --> 00:06:21,759
for

00:06:18,479 --> 00:06:23,039
every one bit in the input set the hash

00:06:21,759 --> 00:06:26,560
value is

00:06:23,039 --> 00:06:30,000
xor with the masked part of the key

00:06:26,560 --> 00:06:32,800
that corresponds to that bit

00:06:30,000 --> 00:06:34,479
so for the sake of presentation let's

00:06:32,800 --> 00:06:37,680
assume we are lazy

00:06:34,479 --> 00:06:41,120
and we've only extracted four bits

00:06:37,680 --> 00:06:44,560
for the input set and we used the

00:06:41,120 --> 00:06:48,319
so-called standard key for the

00:06:44,560 --> 00:06:51,520
hash function as a first step

00:06:48,319 --> 00:06:55,919
we need to mask

00:06:51,520 --> 00:06:58,720
30 to most significant bits of the key

00:06:55,919 --> 00:07:01,360
and check the bit in the input set in

00:06:58,720 --> 00:07:04,400
this case it's one so we need to

00:07:01,360 --> 00:07:07,440
xor the previous hashing result with the

00:07:04,400 --> 00:07:08,000
masked part of the key and save that

00:07:07,440 --> 00:07:11,120
value

00:07:08,000 --> 00:07:13,520
as a hashing result and

00:07:11,120 --> 00:07:16,080
as a second step we need to shift the

00:07:13,520 --> 00:07:19,120
key left or the mask right

00:07:16,080 --> 00:07:21,199
and check the next input bit set in this

00:07:19,120 --> 00:07:25,840
case it's zero so we don't do

00:07:21,199 --> 00:07:28,880
any action and we just move the mask

00:07:25,840 --> 00:07:29,599
to the next part of the key and in this

00:07:28,880 --> 00:07:32,800
case

00:07:29,599 --> 00:07:35,120
the input set we have value of 1

00:07:32,800 --> 00:07:36,800
which means we need to xor the previous

00:07:35,120 --> 00:07:40,560
hashing result with the

00:07:36,800 --> 00:07:43,919
masked key and in the end

00:07:40,560 --> 00:07:46,319
we get the hashing result and as a last

00:07:43,919 --> 00:07:49,440
step we need to

00:07:46,319 --> 00:07:52,800
we have moved the mask forward

00:07:49,440 --> 00:07:56,319
and but the input set value is

00:07:52,800 --> 00:08:00,160
zero the bit is zero which means we

00:07:56,319 --> 00:08:02,720
skip the xor operation and as a result

00:08:00,160 --> 00:08:06,080
we get the hashing result

00:08:02,720 --> 00:08:09,520
which then we need to run

00:08:06,080 --> 00:08:13,120
over the indirection table

00:08:09,520 --> 00:08:13,919
the in direction table is in this case

00:08:13,120 --> 00:08:18,000
is a simple

00:08:13,919 --> 00:08:20,879
4-bit indirection table

00:08:18,000 --> 00:08:23,440
so we use the for least significant bits

00:08:20,879 --> 00:08:26,639
of the hash value to select the index

00:08:23,440 --> 00:08:29,520
in the indirection table since we

00:08:26,639 --> 00:08:29,919
in this example only assumed two queues

00:08:29,520 --> 00:08:32,880
and

00:08:29,919 --> 00:08:35,760
mapped the queues alternately which is

00:08:32,880 --> 00:08:38,240
the default way of programming the table

00:08:35,760 --> 00:08:41,279
we can see that our incoming pocket will

00:08:38,240 --> 00:08:44,159
go to the queue number one

00:08:41,279 --> 00:08:46,240
we can also see that many different

00:08:44,159 --> 00:08:48,480
hashes will actually go to the same

00:08:46,240 --> 00:08:48,480
queue

00:08:48,959 --> 00:08:53,200
and yeah this is actually the end of the

00:08:51,600 --> 00:08:55,600
rss operation

00:08:53,200 --> 00:08:57,200
and now the nic will start processing

00:08:55,600 --> 00:08:59,839
the next packet

00:08:57,200 --> 00:09:01,360
so the key take os from how the top

00:08:59,839 --> 00:09:04,959
leads hash works

00:09:01,360 --> 00:09:06,959
are first one is that we can

00:09:04,959 --> 00:09:08,800
immediately see that there is a

00:09:06,959 --> 00:09:09,519
connection between the parts of the

00:09:08,800 --> 00:09:12,560
input set

00:09:09,519 --> 00:09:13,120
and the parts of the key this means that

00:09:12,560 --> 00:09:15,680
we can

00:09:13,120 --> 00:09:18,000
clearly distinct which part of the key

00:09:15,680 --> 00:09:21,279
will change the hash value for

00:09:18,000 --> 00:09:22,399
source ip address those are bytes 0 to

00:09:21,279 --> 00:09:24,880
8.

00:09:22,399 --> 00:09:27,200
for destination ip address those are

00:09:24,880 --> 00:09:30,240
bytes 4 to 12

00:09:27,200 --> 00:09:31,760
and so on for source port and the

00:09:30,240 --> 00:09:34,000
destination port

00:09:31,760 --> 00:09:36,000
and also we can clearly see that some

00:09:34,000 --> 00:09:38,320
parts of the key

00:09:36,000 --> 00:09:39,040
are used for more than one part of the

00:09:38,320 --> 00:09:41,360
input set

00:09:39,040 --> 00:09:43,120
for example bytes four to eight are used

00:09:41,360 --> 00:09:47,279
for both source ip

00:09:43,120 --> 00:09:49,600
and the destination ip addresses

00:09:47,279 --> 00:09:50,560
and the other problem of the top leads

00:09:49,600 --> 00:09:54,160
hash

00:09:50,560 --> 00:09:55,120
is that in fact we are not using the

00:09:54,160 --> 00:09:57,760
whole key

00:09:55,120 --> 00:09:58,160
we only are using a part of the key for

00:09:57,760 --> 00:10:02,240
our

00:09:58,160 --> 00:10:05,200
hash calculation and the size of the key

00:10:02,240 --> 00:10:07,040
depends on the length of the input set

00:10:05,200 --> 00:10:10,880
for example

00:10:07,040 --> 00:10:14,399
for ip over tcp over ipv4

00:10:10,880 --> 00:10:18,000
we use 16 bytes of the key and for

00:10:14,399 --> 00:10:21,200
tcp over ipv6 we only use 40 bytes

00:10:18,000 --> 00:10:22,880
of the input key which is usually around

00:10:21,200 --> 00:10:26,079
54 or 56

00:10:22,880 --> 00:10:29,760
bytes long and since

00:10:26,079 --> 00:10:31,040
topless hash is based on the xor

00:10:29,760 --> 00:10:32,959
operation

00:10:31,040 --> 00:10:36,160
and the fact that more than one hash

00:10:32,959 --> 00:10:39,120
value is associated with the same queue

00:10:36,160 --> 00:10:39,600
it's not easy to find and predict where

00:10:39,120 --> 00:10:42,720
will

00:10:39,600 --> 00:10:48,160
our packet land after the key change

00:10:42,720 --> 00:10:48,160
and that makes predicting this very hard

00:10:48,320 --> 00:10:55,279
now go back to theatre uh yeah so um

00:10:52,240 --> 00:10:58,000
so rss has has some problems

00:10:55,279 --> 00:10:58,000
so as

00:10:58,640 --> 00:11:03,120
if the incoming traffic has little

00:11:01,920 --> 00:11:06,800
entropy

00:11:03,120 --> 00:11:09,920
in the input set itself we can

00:11:06,800 --> 00:11:14,160
we can have poor balancing between

00:11:09,920 --> 00:11:17,360
between the cpus for example with an app

00:11:14,160 --> 00:11:19,120
where we can have a node

00:11:17,360 --> 00:11:22,079
in the network that is receiving the

00:11:19,120 --> 00:11:24,880
packets and it's behind the knob then

00:11:22,079 --> 00:11:25,440
most of the most of the pack or all the

00:11:24,880 --> 00:11:28,880
packets

00:11:25,440 --> 00:11:32,480
directed to the to this system are

00:11:28,880 --> 00:11:36,160
have the same destination ip

00:11:32,480 --> 00:11:37,360
so the active input set that takes part

00:11:36,160 --> 00:11:39,600
in the

00:11:37,360 --> 00:11:40,720
in the hash calculation that will

00:11:39,600 --> 00:11:45,279
differentiate the

00:11:40,720 --> 00:11:48,320
hash value from different flows is even

00:11:45,279 --> 00:11:50,399
less than the input set itself and then

00:11:48,320 --> 00:11:51,680
the other example can be a web server

00:11:50,399 --> 00:11:54,839
which also receives

00:11:51,680 --> 00:11:56,079
traffic with the same destination ip and

00:11:54,839 --> 00:11:59,360
destination

00:11:56,079 --> 00:11:59,360
port so

00:11:59,920 --> 00:12:03,760
again we can have depending on the

00:12:02,639 --> 00:12:07,600
traffic pattern

00:12:03,760 --> 00:12:12,399
we can have poor traffic balancing

00:12:07,600 --> 00:12:17,120
between the queues and then and the cpus

00:12:12,399 --> 00:12:20,800
um and also

00:12:17,120 --> 00:12:23,680
if we have um a lot of zeros

00:12:20,800 --> 00:12:25,040
and uh much you mentioned it briefly if

00:12:23,680 --> 00:12:27,279
we have a lot of zeros in the

00:12:25,040 --> 00:12:29,600
significant part of the key

00:12:27,279 --> 00:12:30,880
by the nature of the of the extra

00:12:29,600 --> 00:12:34,480
operation

00:12:30,880 --> 00:12:35,360
uh zero doesn't effectively do anything

00:12:34,480 --> 00:12:39,040
with x or

00:12:35,360 --> 00:12:39,760
operation so the more zeros we have the

00:12:39,040 --> 00:12:43,360
less

00:12:39,760 --> 00:12:46,959
alternation we have in the in the

00:12:43,360 --> 00:12:48,880
final hash value and then uh

00:12:46,959 --> 00:12:51,360
due to the nature of the indirection

00:12:48,880 --> 00:12:54,560
table and

00:12:51,360 --> 00:12:57,680
since more than one

00:12:54,560 --> 00:13:01,680
indirection index can

00:12:57,680 --> 00:13:05,680
can end up with the same q id

00:13:01,680 --> 00:13:08,959
for a for different flows

00:13:05,680 --> 00:13:11,760
the traffic can be bunched together

00:13:08,959 --> 00:13:12,639
and many flows can be directed to the

00:13:11,760 --> 00:13:15,040
same

00:13:12,639 --> 00:13:15,040
queue

00:13:16,079 --> 00:13:19,440
we can we can actually try to fix this

00:13:18,320 --> 00:13:21,279
by

00:13:19,440 --> 00:13:22,480
modifying the indirection table but

00:13:21,279 --> 00:13:25,760
anyway

00:13:22,480 --> 00:13:29,040
it needs a intervention

00:13:25,760 --> 00:13:32,240
from the user to to fix that

00:13:29,040 --> 00:13:35,279
and then what's even more

00:13:32,240 --> 00:13:38,240
more complicated is that

00:13:35,279 --> 00:13:40,399
some traffic can end up with with

00:13:38,240 --> 00:13:43,440
different hash value but

00:13:40,399 --> 00:13:44,880
since we only take a portion of the of

00:13:43,440 --> 00:13:48,000
the

00:13:44,880 --> 00:13:50,000
hash to point

00:13:48,000 --> 00:13:51,040
to the entry in the indirection table

00:13:50,000 --> 00:13:54,320
then

00:13:51,040 --> 00:13:57,360
it means that we can end up with uh

00:13:54,320 --> 00:13:59,440
more flows or more connections

00:13:57,360 --> 00:14:01,279
that will have the same lower

00:13:59,440 --> 00:14:03,199
significant bits of the

00:14:01,279 --> 00:14:04,720
of the hash so those will end up on the

00:14:03,199 --> 00:14:08,000
same queue

00:14:04,720 --> 00:14:08,000
and we won't be able to

00:14:08,079 --> 00:14:11,120
simply modify the indirection table to

00:14:10,160 --> 00:14:14,880
split those

00:14:11,120 --> 00:14:18,000
flows from the from this particular

00:14:14,880 --> 00:14:19,199
cube because we will move all of them at

00:14:18,000 --> 00:14:21,839
once and

00:14:19,199 --> 00:14:22,720
probably for such a situation we would

00:14:21,839 --> 00:14:26,320
like to

00:14:22,720 --> 00:14:27,199
somehow split them to uh to bounce the

00:14:26,320 --> 00:14:30,639
traffic between

00:14:27,199 --> 00:14:34,399
uh between the uh different queues

00:14:30,639 --> 00:14:36,880
also rss itself can have some issues

00:14:34,399 --> 00:14:38,240
with uh tunnel and encapsulated

00:14:36,880 --> 00:14:42,240
encapsulated traffic

00:14:38,240 --> 00:14:45,519
depending on the hardware

00:14:42,240 --> 00:14:48,079
capabilities and the the

00:14:45,519 --> 00:14:49,120
not all hardware can look at the

00:14:48,079 --> 00:14:52,000
innermost

00:14:49,120 --> 00:14:53,519
header to identify the

00:14:52,000 --> 00:14:57,279
[Music]

00:14:53,519 --> 00:15:01,680
input set in the innermost header

00:14:57,279 --> 00:15:01,680
uh by itself

00:15:01,839 --> 00:15:09,760
so we can try to improve

00:15:06,000 --> 00:15:10,800
rss and we have couple we have a few

00:15:09,760 --> 00:15:12,480
options we can

00:15:10,800 --> 00:15:15,199
we can modify like i mentioned we can

00:15:12,480 --> 00:15:17,920
modify the indirection table itself

00:15:15,199 --> 00:15:18,880
so we can split and balance the traffic

00:15:17,920 --> 00:15:20,720
a little bit

00:15:18,880 --> 00:15:22,639
this will help if the traffic has the

00:15:20,720 --> 00:15:25,279
same

00:15:22,639 --> 00:15:26,399
lower section bits of the of the hash

00:15:25,279 --> 00:15:29,120
because

00:15:26,399 --> 00:15:30,079
like i said before uh we won't be able

00:15:29,120 --> 00:15:33,680
to split those

00:15:30,079 --> 00:15:36,079
uh flows to um

00:15:33,680 --> 00:15:37,040
on a peripheral basis because we'll move

00:15:36,079 --> 00:15:38,720
all of them

00:15:37,040 --> 00:15:40,959
and then we will break another

00:15:38,720 --> 00:15:44,160
processing for modified indirection

00:15:40,959 --> 00:15:46,560
for modified indirection table values

00:15:44,160 --> 00:15:48,000
and the other option is to modify the

00:15:46,560 --> 00:15:50,160
key itself

00:15:48,000 --> 00:15:51,839
uh this will help to like i said this

00:15:50,160 --> 00:15:54,880
will help to split

00:15:51,839 --> 00:15:55,519
the traffic which has the same hash

00:15:54,880 --> 00:15:58,880
value

00:15:55,519 --> 00:16:01,920
itself the problem is that this will

00:15:58,880 --> 00:16:06,959
also result in a overflow

00:16:01,920 --> 00:16:09,279
reassociation to different cpus probably

00:16:06,959 --> 00:16:10,160
because we will change the hash values

00:16:09,279 --> 00:16:13,199
for probably

00:16:10,160 --> 00:16:16,480
all of the flows

00:16:13,199 --> 00:16:20,639
and also we can we can we will break

00:16:16,480 --> 00:16:20,639
in order processing of incoming packets

00:16:21,360 --> 00:16:24,560
and we can also modify the input set

00:16:23,279 --> 00:16:27,839
itself but it's

00:16:24,560 --> 00:16:29,839
usually uh well it depends on the if the

00:16:27,839 --> 00:16:34,079
hardware is capable of doing that

00:16:29,839 --> 00:16:38,639
and it's not easy to identify uh

00:16:34,079 --> 00:16:42,160
the input set correctly to to do the

00:16:38,639 --> 00:16:42,880
uh fur balancing so now martha will go

00:16:42,160 --> 00:16:45,360
over the

00:16:42,880 --> 00:16:46,210
ways that we would like to use to

00:16:45,360 --> 00:16:48,000
optimize the

00:16:46,210 --> 00:16:52,480
[Music]

00:16:48,000 --> 00:16:52,480
key modification for rsf

00:16:53,759 --> 00:16:57,040
um so as theatre and might say mentioned

00:16:56,160 --> 00:16:59,279
before

00:16:57,040 --> 00:17:00,639
packet flies may not be spread equally

00:16:59,279 --> 00:17:03,920
between cpu cores

00:17:00,639 --> 00:17:05,039
by the rss under certain conditions but

00:17:03,920 --> 00:17:07,760
at the same time

00:17:05,039 --> 00:17:08,640
a different key used by tablets hash

00:17:07,760 --> 00:17:10,720
function

00:17:08,640 --> 00:17:12,160
can potentially fix this problem and it

00:17:10,720 --> 00:17:14,400
can be easily modified

00:17:12,160 --> 00:17:16,079
using one of the standard driver

00:17:14,400 --> 00:17:18,559
functionalities

00:17:16,079 --> 00:17:19,919
it's necessary to keep in mind that each

00:17:18,559 --> 00:17:22,880
key change

00:17:19,919 --> 00:17:24,079
will mainly change the flow of the core

00:17:22,880 --> 00:17:26,000
affinity and

00:17:24,079 --> 00:17:27,120
as a result might degrade the

00:17:26,000 --> 00:17:29,039
performance

00:17:27,120 --> 00:17:31,840
because the application must be

00:17:29,039 --> 00:17:33,600
rescheduled to a different cpu core

00:17:31,840 --> 00:17:36,400
ethernet in general

00:17:33,600 --> 00:17:37,120
deals with this but with the performance

00:17:36,400 --> 00:17:39,360
penalty

00:17:37,120 --> 00:17:42,000
it's obvious that we should avoid it

00:17:39,360 --> 00:17:45,440
doing this too often

00:17:42,000 --> 00:17:48,559
so we start our journey

00:17:45,440 --> 00:17:49,919
to find the best key with changing the

00:17:48,559 --> 00:17:52,799
key to a different

00:17:49,919 --> 00:17:54,960
random case the same method is currently

00:17:52,799 --> 00:17:56,720
used by the linux driver

00:17:54,960 --> 00:17:58,240
and the random key value is injected

00:17:56,720 --> 00:17:59,840
with every boot

00:17:58,240 --> 00:18:01,440
it shouldn't be surprising that the

00:17:59,840 --> 00:18:04,960
results were also

00:18:01,440 --> 00:18:07,440
mostly random so in the next

00:18:04,960 --> 00:18:09,520
step we've analyzed the results returned

00:18:07,440 --> 00:18:11,760
by the genetic algorithm

00:18:09,520 --> 00:18:13,679
which is commonly used to generate high

00:18:11,760 --> 00:18:14,080
quality solutions to optimization and

00:18:13,679 --> 00:18:16,799
search

00:18:14,080 --> 00:18:19,360
problems by relying on biologically

00:18:16,799 --> 00:18:22,000
inspired operators such as notation

00:18:19,360 --> 00:18:23,200
crossover and selection analysts write

00:18:22,000 --> 00:18:25,679
many combinations

00:18:23,200 --> 00:18:26,559
and options with surprisingly good

00:18:25,679 --> 00:18:28,799
results for

00:18:26,559 --> 00:18:30,559
pickup files containing limited number

00:18:28,799 --> 00:18:33,280
of handcrafted flies

00:18:30,559 --> 00:18:33,919
which emulated annuity traffic and only

00:18:33,280 --> 00:18:37,280
differed

00:18:33,919 --> 00:18:38,320
in source ap addresses unfortunately

00:18:37,280 --> 00:18:41,840
this solution

00:18:38,320 --> 00:18:44,240
proved not to be scalable and when we

00:18:41,840 --> 00:18:47,360
tried to use it in bigger like

00:18:44,240 --> 00:18:50,320
real-life pickup dumps we got stuck

00:18:47,360 --> 00:18:51,200
and we were not able to find the key in

00:18:50,320 --> 00:18:55,039
a very long

00:18:51,200 --> 00:18:58,160
like week-long friends and

00:18:55,039 --> 00:19:00,960
at this point we decided to try

00:18:58,160 --> 00:19:03,120
these akisona key bits which are more

00:19:00,960 --> 00:19:06,080
significant than the others to narrow

00:19:03,120 --> 00:19:07,919
down the scope of calculations

00:19:06,080 --> 00:19:10,400
that's why we started working on markov

00:19:07,919 --> 00:19:12,799
decision process implementation

00:19:10,400 --> 00:19:14,559
and i really don't want to dive deep

00:19:12,799 --> 00:19:18,880
into technical details

00:19:14,559 --> 00:19:20,799
of this um implementation um

00:19:18,880 --> 00:19:22,799
but at some point we just get an

00:19:20,799 --> 00:19:24,720
impression that we are going to deep and

00:19:22,799 --> 00:19:27,440
maybe it's time to

00:19:24,720 --> 00:19:29,520
try something less complicated like

00:19:27,440 --> 00:19:32,320
neural networks

00:19:29,520 --> 00:19:34,480
and that may sound a bit scary but the

00:19:32,320 --> 00:19:37,120
final solution which we believe may help

00:19:34,480 --> 00:19:38,799
is described as bayesian optimization

00:19:37,120 --> 00:19:41,600
algorithm with the usage of

00:19:38,799 --> 00:19:43,039
on policy prediction and with

00:19:41,600 --> 00:19:45,679
approximation

00:19:43,039 --> 00:19:46,160
so i really don't think we have enough

00:19:45,679 --> 00:19:48,160
time

00:19:46,160 --> 00:19:49,520
to go into artificial intelligence

00:19:48,160 --> 00:19:52,000
details

00:19:49,520 --> 00:19:53,520
and we would love to discuss it so if

00:19:52,000 --> 00:19:56,080
anyone has any comments

00:19:53,520 --> 00:19:56,720
or questions you can simply reach us

00:19:56,080 --> 00:19:59,600
using

00:19:56,720 --> 00:20:00,320
for example my email address but just

00:19:59,600 --> 00:20:02,400
for now

00:20:00,320 --> 00:20:03,919
i will try to describe the idea behind

00:20:02,400 --> 00:20:08,720
this fancy name

00:20:03,919 --> 00:20:08,720
in a friendly way so

00:20:10,559 --> 00:20:16,400
proposed solution at this stage uses

00:20:13,919 --> 00:20:18,960
pre-collected pickup file

00:20:16,400 --> 00:20:20,799
and a resource software emulator to

00:20:18,960 --> 00:20:23,039
evaluate collected data

00:20:20,799 --> 00:20:24,960
and then this data will be used to train

00:20:23,039 --> 00:20:27,039
a neural network based model of an

00:20:24,960 --> 00:20:30,480
objective function

00:20:27,039 --> 00:20:32,320
and using this we'll be able to

00:20:30,480 --> 00:20:35,520
determine the best possible

00:20:32,320 --> 00:20:37,919
rss hush key at this stage neural

00:20:35,520 --> 00:20:41,520
network will be trained manually

00:20:37,919 --> 00:20:43,600
by engineers and it's important that one

00:20:41,520 --> 00:20:46,080
of the assumption is that the solution

00:20:43,600 --> 00:20:48,080
works offline in user space

00:20:46,080 --> 00:20:49,200
and it's not interrupting platform

00:20:48,080 --> 00:20:52,480
standard operating

00:20:49,200 --> 00:20:55,600
mode until a satisfying key was found or

00:20:52,480 --> 00:20:56,799
established time passed or process was

00:20:55,600 --> 00:20:59,600
interrupted

00:20:56,799 --> 00:21:01,520
and then later user may choose to inject

00:20:59,600 --> 00:21:04,720
new key to his system

00:21:01,520 --> 00:21:07,039
improving traffic balance or or just

00:21:04,720 --> 00:21:10,240
fight with it

00:21:07,039 --> 00:21:12,559
but in a destination solution

00:21:10,240 --> 00:21:15,440
everything will be automated and will

00:21:12,559 --> 00:21:19,360
happens in cycles

00:21:15,440 --> 00:21:22,960
in each cycle uh we will like to

00:21:19,360 --> 00:21:26,960
evaluate each net previously evaluated

00:21:22,960 --> 00:21:30,000
uh hash key using rss software

00:21:26,960 --> 00:21:32,640
emulator then we would like to check

00:21:30,000 --> 00:21:33,200
if any of those keys is good enough if

00:21:32,640 --> 00:21:36,880
yes

00:21:33,200 --> 00:21:39,919
then we are done if no i

00:21:36,880 --> 00:21:42,640
would like to use all the data

00:21:39,919 --> 00:21:45,120
to train neural network based model of

00:21:42,640 --> 00:21:47,600
an objective function using the idea of

00:21:45,120 --> 00:21:49,679
automated neural networks and it's used

00:21:47,600 --> 00:21:50,480
to search for the best architecture for

00:21:49,679 --> 00:21:53,760
given

00:21:50,480 --> 00:21:54,640
purpose in the data then we can use this

00:21:53,760 --> 00:21:59,760
model

00:21:54,640 --> 00:22:03,360
to find next keys which should be

00:21:59,760 --> 00:22:04,720
checked in a next cycle it's also

00:22:03,360 --> 00:22:08,159
important to mention

00:22:04,720 --> 00:22:12,799
that to reduce the computation time

00:22:08,159 --> 00:22:15,840
model which will be used for initial

00:22:12,799 --> 00:22:16,320
for each initial program will be pretend

00:22:15,840 --> 00:22:18,880
during

00:22:16,320 --> 00:22:21,840
uh research process and this is a very

00:22:18,880 --> 00:22:21,840
popular approach

00:22:24,840 --> 00:22:29,840
saying um so i'd like to answer for a

00:22:28,799 --> 00:22:32,720
question

00:22:29,840 --> 00:22:34,400
why artificial intelligence and to

00:22:32,720 --> 00:22:36,080
answer for this question

00:22:34,400 --> 00:22:38,320
we have to realize that this is a

00:22:36,080 --> 00:22:40,240
standard optimization problem

00:22:38,320 --> 00:22:42,000
of balancing the lights among the

00:22:40,240 --> 00:22:44,720
server's cpu cars

00:22:42,000 --> 00:22:45,679
and it's described but as follows on a

00:22:44,720 --> 00:22:48,880
slide

00:22:45,679 --> 00:22:51,919
where n stands for number of cars and

00:22:48,880 --> 00:22:56,000
l i stands for current load in

00:22:51,919 --> 00:22:59,280
la uh represents the average

00:22:56,000 --> 00:23:01,760
for a lot and now when we know

00:22:59,280 --> 00:23:03,679
that this is a standard optimization

00:23:01,760 --> 00:23:04,400
problem we can just connect the dots

00:23:03,679 --> 00:23:06,400
case

00:23:04,400 --> 00:23:08,880
complex optimization problems that

00:23:06,400 --> 00:23:11,600
cannot be tracked

00:23:08,880 --> 00:23:13,360
that cannot be solved yet traditional

00:23:11,600 --> 00:23:16,240
mathematical programming

00:23:13,360 --> 00:23:19,200
are commonly solved with artificial

00:23:16,240 --> 00:23:21,520
intelligence based solution approaches

00:23:19,200 --> 00:23:22,559
and this approaches provide optimal

00:23:21,520 --> 00:23:25,919
solutions

00:23:22,559 --> 00:23:29,039
avoiding consuming many computed

00:23:25,919 --> 00:23:30,240
computational resources but on the other

00:23:29,039 --> 00:23:32,720
hand

00:23:30,240 --> 00:23:34,720
they often find local minimums or

00:23:32,720 --> 00:23:40,000
maximums but in many cases

00:23:34,720 --> 00:23:43,679
it's still significant improvement

00:23:40,000 --> 00:23:47,360
so currently we are working on

00:23:43,679 --> 00:23:50,400
a model on this artificial intelligence

00:23:47,360 --> 00:23:53,440
site so we don't have any hard data

00:23:50,400 --> 00:23:55,919
to show yet but

00:23:53,440 --> 00:23:57,120
i hope that soon we'll get back with

00:23:55,919 --> 00:23:59,600
some

00:23:57,120 --> 00:24:01,760
results maybe in a form of a paper or

00:23:59,600 --> 00:24:04,320
another presentation

00:24:01,760 --> 00:24:06,000
um but when we're done with the model in

00:24:04,320 --> 00:24:09,039
the next steps

00:24:06,000 --> 00:24:12,320
we would like to uh think about

00:24:09,039 --> 00:24:14,000
more key generated generators like maybe

00:24:12,320 --> 00:24:17,120
it will be worth to add

00:24:14,000 --> 00:24:20,320
some randomness and maybe to reuse

00:24:17,120 --> 00:24:23,039
already prepared genetic algorithm

00:24:20,320 --> 00:24:24,000
then we will work in automation

00:24:23,039 --> 00:24:26,960
measurements

00:24:24,000 --> 00:24:27,520
and support for hd6 because currently we

00:24:26,960 --> 00:24:31,840
are

00:24:27,520 --> 00:24:34,960
dealing only with ipv4

00:24:31,840 --> 00:24:38,159
this is everything from my side thank

00:24:34,960 --> 00:24:39,919
you very much for your attention

00:24:38,159 --> 00:24:42,720
yeah thank you very much for your time

00:24:39,919 --> 00:24:46,559
we we realized that this is a

00:24:42,720 --> 00:24:49,360
work in progress but this is our lead in

00:24:46,559 --> 00:24:51,360
and basically would like to stimulate a

00:24:49,360 --> 00:24:52,240
discussion so if you have any feedback

00:24:51,360 --> 00:24:54,559
comments

00:24:52,240 --> 00:24:55,440
please reach out and all feedback will

00:24:54,559 --> 00:25:01,840
be

00:24:55,440 --> 00:25:01,840
appreciated thank you

00:25:02,559 --> 00:25:09,840
okay turn on my video

00:25:07,360 --> 00:25:11,440
so let's see uh what the questions look

00:25:09,840 --> 00:25:14,640
like

00:25:11,440 --> 00:25:17,679
uh not a whole lot um so i made a couple

00:25:14,640 --> 00:25:20,080
of points and it's interesting that

00:25:17,679 --> 00:25:22,320
packet reordering seems to be coming up

00:25:20,080 --> 00:25:25,039
uh time and time again

00:25:22,320 --> 00:25:26,720
i think uh there must be an obvious

00:25:25,039 --> 00:25:29,520
reason for this is trending on people's

00:25:26,720 --> 00:25:32,880
minds but clearly

00:25:29,520 --> 00:25:35,520
if we change the rss key

00:25:32,880 --> 00:25:36,960
or assist mappings continuously yes that

00:25:35,520 --> 00:25:38,960
would generate a lot of

00:25:36,960 --> 00:25:42,640
packet reordering but i'm assuming in

00:25:38,960 --> 00:25:44,480
this case we would only do it

00:25:42,640 --> 00:25:46,559
intermittently

00:25:44,480 --> 00:25:47,679
and hopefully there's some some hold

00:25:46,559 --> 00:25:50,000
down periods

00:25:47,679 --> 00:25:52,640
but i don't think it's reasonable to to

00:25:50,000 --> 00:25:54,840
say we can never change the key because

00:25:52,640 --> 00:25:56,000
we want to avoid out of order packets

00:25:54,840 --> 00:25:58,640
completely

00:25:56,000 --> 00:26:01,360
and i know that in some circumstances

00:25:58,640 --> 00:26:05,360
what we've seen in the past was

00:26:01,360 --> 00:26:07,200
a customer would basically run a test

00:26:05,360 --> 00:26:07,760
and if they saw even one out of order

00:26:07,200 --> 00:26:09,919
packet

00:26:07,760 --> 00:26:11,120
it would be flagged in the test as as a

00:26:09,919 --> 00:26:14,000
problem

00:26:11,120 --> 00:26:14,400
uh even if it wasn't even if it if it

00:26:14,000 --> 00:26:17,200
was an

00:26:14,400 --> 00:26:18,720
improvement in overall latency uh they

00:26:17,200 --> 00:26:20,240
test for this so there's some

00:26:18,720 --> 00:26:21,679
assumptions

00:26:20,240 --> 00:26:23,440
i think incorrect assumptions in the

00:26:21,679 --> 00:26:24,080
industry that i.t is supposed to be

00:26:23,440 --> 00:26:27,760
somehow

00:26:24,080 --> 00:26:29,679
in order and and there's reasons there's

00:26:27,760 --> 00:26:33,279
valid reasons why it isn't not just

00:26:29,679 --> 00:26:38,480
because of network so

00:26:33,279 --> 00:26:41,520
uh there was a question

00:26:38,480 --> 00:26:45,120
have you compared this approach with

00:26:41,520 --> 00:26:48,240
rss plus plus paper presented

00:26:45,120 --> 00:26:48,240
in 2019

00:26:49,039 --> 00:26:52,480
yes we have actually analyzed rss plus

00:26:52,000 --> 00:26:56,000
plus

00:26:52,480 --> 00:26:57,440
as well but this approach is not solving

00:26:56,000 --> 00:27:01,120
all the problems because in

00:26:57,440 --> 00:27:04,720
some of the examples that we mentioned

00:27:01,120 --> 00:27:05,360
in the talk like the push pop gateways

00:27:04,720 --> 00:27:08,880
for not

00:27:05,360 --> 00:27:08,880
networks and stuff like this

00:27:08,960 --> 00:27:13,919
are not really the change of the buckets

00:27:11,919 --> 00:27:16,640
that rss plus plus

00:27:13,919 --> 00:27:17,279
suggests is not enough there because if

00:27:16,640 --> 00:27:19,840
you

00:27:17,279 --> 00:27:21,679
have the wrong key you basically don't

00:27:19,840 --> 00:27:25,679
have don't use the entropy

00:27:21,679 --> 00:27:27,919
correctly and as a result you

00:27:25,679 --> 00:27:29,200
no matter how you change the buckets you

00:27:27,919 --> 00:27:32,720
will not get

00:27:29,200 --> 00:27:34,559
better balance of the traffic

00:27:32,720 --> 00:27:36,640
so uh could could you or someone else

00:27:34,559 --> 00:27:38,320
give a short description of what rss

00:27:36,640 --> 00:27:41,919
plus plus is

00:27:38,320 --> 00:27:43,919
yeah rss plus plus generally tries to

00:27:41,919 --> 00:27:47,200
modify the redirection table

00:27:43,919 --> 00:27:49,360
and try to

00:27:47,200 --> 00:27:50,480
check which flows in the red direction

00:27:49,360 --> 00:27:52,720
tables gets

00:27:50,480 --> 00:27:55,360
most of the hits and if there are some

00:27:52,720 --> 00:27:58,480
flows that can be rebalanced

00:27:55,360 --> 00:28:01,840
the rss plus plus changes the affinity

00:27:58,480 --> 00:28:04,080
of the bucket to the core to the queue

00:28:01,840 --> 00:28:07,120
or core

00:28:04,080 --> 00:28:10,399
and basically it's also this way

00:28:07,120 --> 00:28:14,240
i see uh yet another spin

00:28:10,399 --> 00:28:17,440
on um package turn yep

00:28:14,240 --> 00:28:20,080
uh so there was a question uh is a

00:28:17,440 --> 00:28:23,520
patent involved yet with this approach

00:28:20,080 --> 00:28:26,880
um not sure that's a technical question

00:28:23,520 --> 00:28:28,399
maybe if um maybe you can

00:28:26,880 --> 00:28:30,799
describe a little bit about what what

00:28:28,399 --> 00:28:32,640
the plan is or or how you intend to move

00:28:30,799 --> 00:28:34,960
forward and what the reality is

00:28:32,640 --> 00:28:34,960
of this

00:28:37,840 --> 00:28:45,679
move forward with this uh idea yeah

00:28:41,840 --> 00:28:48,720
yeah we generally plan to train the

00:28:45,679 --> 00:28:51,760
network and we are looking for

00:28:48,720 --> 00:28:52,720
some real-life traffic that we can use

00:28:51,760 --> 00:28:55,360
for that

00:28:52,720 --> 00:28:56,840
so if anyone can share some pickup files

00:28:55,360 --> 00:29:00,000
it would be

00:28:56,840 --> 00:29:01,360
awesome because we were mostly training

00:29:00,000 --> 00:29:04,480
on some

00:29:01,360 --> 00:29:09,919
trying to to run our algorithm

00:29:04,480 --> 00:29:09,919
on some completely artificial

00:29:10,000 --> 00:29:13,520
pickup files that we generated to

00:29:12,159 --> 00:29:15,840
actually simulate the

00:29:13,520 --> 00:29:18,399
issues that we have seen in the real

00:29:15,840 --> 00:29:21,360
like that users reported in the real

00:29:18,399 --> 00:29:21,360
life scenarios

00:29:22,159 --> 00:29:26,320
so when this is running the inference i

00:29:25,360 --> 00:29:29,760
assume it's

00:29:26,320 --> 00:29:33,120
it's adaptive but it's still based on

00:29:29,760 --> 00:29:36,000
the original learning or does it do

00:29:33,120 --> 00:29:36,000
continuous learning

00:29:36,640 --> 00:29:44,320
we plan to do the continuous learning

00:29:40,880 --> 00:29:47,200
it's not the ones off we rather

00:29:44,320 --> 00:29:49,039
the plan is to actually when you see the

00:29:47,200 --> 00:29:52,880
imbalance you can run the

00:29:49,039 --> 00:29:53,120
script and it will recapture the packets

00:29:52,880 --> 00:29:56,480
and

00:29:53,120 --> 00:29:59,200
re-learn and read and change the key

00:29:56,480 --> 00:29:59,200
accordingly

00:30:00,880 --> 00:30:04,640
okay so so my impression and like i

00:30:03,120 --> 00:30:08,279
mentioned at the beginning

00:30:04,640 --> 00:30:11,279
this is a great case of a

00:30:08,279 --> 00:30:14,640
parametrization that

00:30:11,279 --> 00:30:16,240
we know it's really hard in practice to

00:30:14,640 --> 00:30:18,240
to find the right answer and there may

00:30:16,240 --> 00:30:20,960
not be any one right answer

00:30:18,240 --> 00:30:22,159
so we've seen even simpler case simple

00:30:20,960 --> 00:30:26,080
cases like how many

00:30:22,159 --> 00:30:28,640
how many cues should we use on a system

00:30:26,080 --> 00:30:30,399
uh depending on on the number of queues

00:30:28,640 --> 00:30:32,559
if used too many

00:30:30,399 --> 00:30:34,799
uh that creates problems if you use too

00:30:32,559 --> 00:30:36,480
few that create some problems but

00:30:34,799 --> 00:30:38,240
we always have to take into account what

00:30:36,480 --> 00:30:39,440
the system is used for what the load is

00:30:38,240 --> 00:30:42,799
used for

00:30:39,440 --> 00:30:44,880
and i imagine this sort of of

00:30:42,799 --> 00:30:47,120
concept where we have to parameterize

00:30:44,880 --> 00:30:50,320
based on on real loading

00:30:47,120 --> 00:30:53,440
and real um world

00:30:50,320 --> 00:30:55,039
heuristics probably scales to to

00:30:53,440 --> 00:30:58,080
different areas

00:30:55,039 --> 00:31:02,080
so i suspect that

00:30:58,080 --> 00:31:05,279
um as this as this sort of

00:31:02,080 --> 00:31:08,960
mentality goes forward we would

00:31:05,279 --> 00:31:08,960
continuously expand the

00:31:09,039 --> 00:31:12,880
hopefully the data set but it seems like

00:31:11,679 --> 00:31:14,799
at some point you need to take into

00:31:12,880 --> 00:31:16,960
account more than just the pcap file

00:31:14,799 --> 00:31:20,960
we'd also have to consider

00:31:16,960 --> 00:31:22,480
somehow to measure user user experience

00:31:20,960 --> 00:31:26,480
and

00:31:22,480 --> 00:31:29,360
latency and usability

00:31:26,480 --> 00:31:30,240
so that's just a comment um i think this

00:31:29,360 --> 00:31:32,480
is uh

00:31:30,240 --> 00:31:33,679
i think we're on the on the precipice of

00:31:32,480 --> 00:31:37,919
a a large

00:31:33,679 --> 00:31:37,919
um work in this area hopefully

00:31:38,880 --> 00:31:45,039
okay do we have any other anything

00:31:42,080 --> 00:31:45,360
oh uh joel go ahead hey how's it going

00:31:45,039 --> 00:31:47,679
so

00:31:45,360 --> 00:31:49,440
regarding the approaches actually i

00:31:47,679 --> 00:31:52,640
think it's a pretty good and

00:31:49,440 --> 00:31:54,080
uh we haven't done a similar like like

00:31:52,640 --> 00:31:55,840
we haven't used machine learning

00:31:54,080 --> 00:31:58,320
for this approach but we have been doing

00:31:55,840 --> 00:31:58,640
like some testing with the hash keys as

00:31:58,320 --> 00:32:00,080
well

00:31:58,640 --> 00:32:01,919
because some of the things that some of

00:32:00,080 --> 00:32:02,880
the challenges that i'm facing from time

00:32:01,919 --> 00:32:04,720
to time

00:32:02,880 --> 00:32:06,880
are around the network security

00:32:04,720 --> 00:32:10,480
monitoring tools like ids

00:32:06,880 --> 00:32:12,320
ips and things like this and

00:32:10,480 --> 00:32:13,679
it's very important to kind of keep the

00:32:12,320 --> 00:32:16,559
flows stitched properly

00:32:13,679 --> 00:32:18,320
and together and parallel that flow as

00:32:16,559 --> 00:32:20,320
much as possible so you can actually

00:32:18,320 --> 00:32:21,840
do as much work as you can on a single

00:32:20,320 --> 00:32:24,399
sensor node

00:32:21,840 --> 00:32:25,440
rather than scaling uh two multiple

00:32:24,399 --> 00:32:28,799
server architectures

00:32:25,440 --> 00:32:30,399
as for multiple servers and so one thing

00:32:28,799 --> 00:32:31,679
i was curious about is like

00:32:30,399 --> 00:32:33,120
um you did mention that you're

00:32:31,679 --> 00:32:35,200
handcrafting your packets or you're

00:32:33,120 --> 00:32:38,000
using uh generated packets

00:32:35,200 --> 00:32:38,559
um i had like uh i personally have been

00:32:38,000 --> 00:32:40,159
using

00:32:38,559 --> 00:32:42,399
um i'll just call it like you know

00:32:40,159 --> 00:32:43,200
breaking point as a solution um to

00:32:42,399 --> 00:32:45,679
generate

00:32:43,200 --> 00:32:47,440
um you know data center traffic and try

00:32:45,679 --> 00:32:48,240
to figure out like you know whether or

00:32:47,440 --> 00:32:51,279
not

00:32:48,240 --> 00:32:52,159
um the balancing on rss is working

00:32:51,279 --> 00:32:55,200
properly

00:32:52,159 --> 00:32:56,559
and you know if so like you know um i

00:32:55,200 --> 00:32:58,640
actually checked the rss queues to see

00:32:56,559 --> 00:33:00,159
if they're properly balanced or not

00:32:58,640 --> 00:33:02,000
and sometimes it's not the case because

00:33:00,159 --> 00:33:03,760
it's all based off of like the cash flow

00:33:02,000 --> 00:33:05,039
and so if you're getting more data from

00:33:03,760 --> 00:33:08,640
like you know one

00:33:05,039 --> 00:33:10,880
uh particular um client versus another

00:33:08,640 --> 00:33:11,760
client they actually may be scaled to

00:33:10,880 --> 00:33:14,159
like different

00:33:11,760 --> 00:33:15,919
cues how are you actually like

00:33:14,159 --> 00:33:17,679
determining whether or not the balancing

00:33:15,919 --> 00:33:19,600
is working appropriately and things like

00:33:17,679 --> 00:33:22,480
that

00:33:19,600 --> 00:33:24,240
all right sir i hi i'm martin i think i

00:33:22,480 --> 00:33:27,760
can answer for this question

00:33:24,240 --> 00:33:30,960
so basically we are just um for now the

00:33:27,760 --> 00:33:34,480
only metric is we are just checking for

00:33:30,960 --> 00:33:37,200
uh like the approximate

00:33:34,480 --> 00:33:37,679
number of packets hitting one of the

00:33:37,200 --> 00:33:42,080
queues

00:33:37,679 --> 00:33:42,080
and counting the um

00:33:46,559 --> 00:33:50,399
yeah we basically wrote an rss emulator

00:33:49,919 --> 00:33:53,600
that

00:33:50,399 --> 00:33:56,880
run over the pickup file and then we

00:33:53,600 --> 00:33:58,880
try to find the average number of

00:33:56,880 --> 00:34:00,240
packets like average then the number

00:33:58,880 --> 00:34:03,760
over the queues that

00:34:00,240 --> 00:34:06,960
we assigned which means we just

00:34:03,760 --> 00:34:07,519
checked the you know how well what was

00:34:06,960 --> 00:34:10,800
the

00:34:07,519 --> 00:34:14,960
average square root mean square

00:34:10,800 --> 00:34:17,599
error between the e q's

00:34:14,960 --> 00:34:18,240
oh god it got everything to minimize

00:34:17,599 --> 00:34:20,879
well

00:34:18,240 --> 00:34:21,599
that makes sense um because the number

00:34:20,879 --> 00:34:24,159
of flows

00:34:21,599 --> 00:34:25,119
generated by the client server pairs is

00:34:24,159 --> 00:34:27,760
going to greatly like

00:34:25,119 --> 00:34:30,879
you know impact what that interaction

00:34:27,760 --> 00:34:30,879
table kind of looks like right

00:34:31,520 --> 00:34:35,359
what do you mean by how in direction

00:34:34,000 --> 00:34:37,359
table looks like

00:34:35,359 --> 00:34:38,560
because you're going to be hashing off

00:34:37,359 --> 00:34:40,079
i'm assuming you're hashing off of the

00:34:38,560 --> 00:34:42,960
four tuples ip

00:34:40,079 --> 00:34:43,440
um source destination port all those

00:34:42,960 --> 00:34:46,800
things

00:34:43,440 --> 00:34:48,399
and so um if you have more

00:34:46,800 --> 00:34:50,320
oh i see so if you're having like more

00:34:48,399 --> 00:34:55,520
packets come from a specific

00:34:50,320 --> 00:34:57,359
um uh from a particular client

00:34:55,520 --> 00:34:58,960
i'm wondering if it'll stay balanced if

00:34:57,359 --> 00:35:00,640
it'll actually shift over to like more

00:34:58,960 --> 00:35:02,720
towards like one queue than another

00:35:00,640 --> 00:35:04,079
um how are you like kind of breaking

00:35:02,720 --> 00:35:06,720
that down like like you mentioned web

00:35:04,079 --> 00:35:09,359
server traffic as an example

00:35:06,720 --> 00:35:10,240
well if you have one big connection and

00:35:09,359 --> 00:35:13,200
one

00:35:10,240 --> 00:35:15,359
client running a lot of traffic then you

00:35:13,200 --> 00:35:18,400
don't really have any entropy in this

00:35:15,359 --> 00:35:21,680
flow so you can't really rebalance that

00:35:18,400 --> 00:35:24,640
it's more for when you run the web

00:35:21,680 --> 00:35:25,359
server and you for example your system

00:35:24,640 --> 00:35:28,480
generated

00:35:25,359 --> 00:35:31,599
on the boot the key that is not doing a

00:35:28,480 --> 00:35:35,839
good use of the entropy in the

00:35:31,599 --> 00:35:38,320
source ip addresses for example

00:35:35,839 --> 00:35:40,960
and then you can rerun this yeah cool

00:35:38,320 --> 00:35:45,839
thank you we appreciate it great work

00:35:40,960 --> 00:35:45,839

YouTube URL: https://www.youtube.com/watch?v=vP5KNhYYtkQ


