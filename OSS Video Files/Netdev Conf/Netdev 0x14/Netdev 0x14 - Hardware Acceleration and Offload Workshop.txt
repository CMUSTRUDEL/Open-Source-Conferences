Title: Netdev 0x14 - Hardware Acceleration and Offload Workshop
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Chair: Tom Herbert

More info: https://netdevconf.info/0x14/session.html?workshop-hardware-acceleration-and-offload

Date: Thursday, August 13, 2020

This workshop continues discussions on several 
topics in the area of hardware acceleration and 
hardware offload in NICs.

Topics include:
    - New work in checksum and segmentation offloads
    - TC flower offload
    - XDP hints
    - XDP/eBPF offload
    - Receive packet steering
    - Netfilter offload
    - OVS offload
    - Application specific hardware queues
Captions: 
	00:00:01,760 --> 00:00:07,919
welcome everyone to

00:00:03,760 --> 00:00:09,679
uh netdev 20.

00:00:07,919 --> 00:00:11,120
and i hope everybody had safe travels

00:00:09,679 --> 00:00:14,320
getting here

00:00:11,120 --> 00:00:15,920
so uh today uh this is the hardware

00:00:14,320 --> 00:00:20,720
acceleration and offload

00:00:15,920 --> 00:00:24,480
workshop and we have a few presentations

00:00:20,720 --> 00:00:27,599
but hopefully most of this will be some

00:00:24,480 --> 00:00:31,279
open discussion if you have any

00:00:27,599 --> 00:00:33,760
agenda items so we had one uh

00:00:31,279 --> 00:00:34,399
one come up for my um request on the

00:00:33,760 --> 00:00:36,719
list

00:00:34,399 --> 00:00:37,760
if you have any agenda items or

00:00:36,719 --> 00:00:40,160
questions

00:00:37,760 --> 00:00:41,920
uh start by putting them on the chat i

00:00:40,160 --> 00:00:46,079
think we'll have

00:00:41,920 --> 00:00:49,440
plenty of time to get to

00:00:46,079 --> 00:00:51,280
any of those questions so we have three

00:00:49,440 --> 00:00:54,480
uh three presenters uh

00:00:51,280 --> 00:00:55,360
we'll talk about xdp hence uh this has

00:00:54,480 --> 00:00:57,760
been

00:00:55,360 --> 00:00:59,280
something that we've talked about before

00:00:57,760 --> 00:01:01,520
so i'm really looking forward to

00:00:59,280 --> 00:01:02,320
seeing um what progress we're making

00:01:01,520 --> 00:01:05,040
there

00:01:02,320 --> 00:01:06,640
angela would talk about some of uh some

00:01:05,040 --> 00:01:08,080
other thoughts on acceleration and

00:01:06,640 --> 00:01:11,040
offload

00:01:08,080 --> 00:01:12,240
i'm going to present a problem in the

00:01:11,040 --> 00:01:17,280
area that i think the

00:01:12,240 --> 00:01:21,200
community can potentially address

00:01:17,280 --> 00:01:24,840
mate had a question

00:01:21,200 --> 00:01:27,520
posed in the area of requirements around

00:01:24,840 --> 00:01:31,040
acceleration and as i mentioned

00:01:27,520 --> 00:01:33,759
uh we're opening other topics

00:01:31,040 --> 00:01:34,720
uh and we have an open mic so one thing

00:01:33,759 --> 00:01:37,360
i should mention is

00:01:34,720 --> 00:01:38,159
uh this work group or workshop is a

00:01:37,360 --> 00:01:43,439
little bit

00:01:38,159 --> 00:01:44,960
um loosely formed uh it was kind of

00:01:43,439 --> 00:01:46,479
uh redundant with some of the

00:01:44,960 --> 00:01:48,560
presentations

00:01:46,479 --> 00:01:50,640
uh you might notice uh clearly there are

00:01:48,560 --> 00:01:52,159
some other xdp accelerations

00:01:50,640 --> 00:01:54,320
so so bear that in mind there will be

00:01:52,159 --> 00:01:56,560
other opportunities

00:01:54,320 --> 00:01:57,439
for discussion along these lines but the

00:01:56,560 --> 00:02:00,479
real goal here

00:01:57,439 --> 00:02:02,640
is to to be a little less formal than

00:02:00,479 --> 00:02:04,880
the normal presentations

00:02:02,640 --> 00:02:09,440
and i'm hoping we can get some good

00:02:04,880 --> 00:02:13,200
discussion on where he wants that

00:02:09,440 --> 00:02:13,200
any questions so far

00:02:19,520 --> 00:02:25,040
okay so with that uh saeed are you

00:02:34,840 --> 00:02:37,840
present

00:02:44,560 --> 00:02:51,840
i don't see the sight don't okay uh

00:02:47,360 --> 00:02:51,840
anjali are you present

00:02:57,519 --> 00:03:03,920
tom i think angeli hasn't died in

00:03:00,959 --> 00:03:06,400
yet okay so let me let me go ahead and

00:03:03,920 --> 00:03:08,239
start it uh hopefully they're doing

00:03:06,400 --> 00:03:10,560
um i assume since this is the first

00:03:08,239 --> 00:03:12,480
session uh

00:03:10,560 --> 00:03:15,360
we're probably having a little bit of a

00:03:12,480 --> 00:03:15,360
learning experience

00:03:17,200 --> 00:03:33,840
so bear with me one moment

00:03:40,080 --> 00:03:45,840
okay so um

00:03:43,840 --> 00:03:47,760
i want to talk about something that i've

00:03:45,840 --> 00:03:50,799
been pondering for a while

00:03:47,760 --> 00:03:53,120
um and in this particular area of

00:03:50,799 --> 00:03:56,319
accelerations offloads

00:03:53,120 --> 00:03:57,040
the relationship between hardware

00:03:56,319 --> 00:04:00,560
offload

00:03:57,040 --> 00:04:04,000
hardware features software stacks

00:04:00,560 --> 00:04:05,920
uh smartnics and programmable

00:04:04,000 --> 00:04:07,680
programmable devices so i think it's

00:04:05,920 --> 00:04:10,959
pretty clear that

00:04:07,680 --> 00:04:12,879
as an industry we we want to move in

00:04:10,959 --> 00:04:16,000
this direction we want to

00:04:12,879 --> 00:04:16,880
have advanced hardware features we want

00:04:16,000 --> 00:04:20,320
to

00:04:16,880 --> 00:04:21,840
offload virtual switch and advanced

00:04:20,320 --> 00:04:24,560
filtering capabilities

00:04:21,840 --> 00:04:26,080
and we want it to obviously be highly

00:04:24,560 --> 00:04:29,280
programmable

00:04:26,080 --> 00:04:31,199
extremely flexible and yet

00:04:29,280 --> 00:04:32,800
somehow get all the performance and run

00:04:31,199 --> 00:04:37,040
at hardware speeds

00:04:32,800 --> 00:04:40,240
so this is whatever number you see

00:04:37,040 --> 00:04:43,120
there is an end of quarter number so by

00:04:40,240 --> 00:04:43,120
the end of quarter

00:04:46,240 --> 00:04:49,360
i'm sorry was that a question

00:04:50,880 --> 00:04:57,840
no okay so can can you mute if you're

00:04:53,840 --> 00:04:57,840
not speaking please

00:04:59,680 --> 00:05:06,000
okay so here's the the first question

00:05:02,880 --> 00:05:06,639
um and this i might have raised before i

00:05:06,000 --> 00:05:10,560
don't know

00:05:06,639 --> 00:05:13,840
if if it was in a context like this but

00:05:10,560 --> 00:05:16,000
if you look at what we've really shipped

00:05:13,840 --> 00:05:18,960
in terms of of hardware and hardware

00:05:16,000 --> 00:05:18,960
vendors and nics

00:05:19,440 --> 00:05:25,680
while there's been enormous effort on

00:05:22,560 --> 00:05:28,560
various forms of offload in reality

00:05:25,680 --> 00:05:30,639
very few of these actually are really

00:05:28,560 --> 00:05:31,199
ubiquitous across almost all the nicks

00:05:30,639 --> 00:05:34,400
and

00:05:31,199 --> 00:05:36,080
and the other known favorites so clearly

00:05:34,400 --> 00:05:37,440
uh transmit and receive checks on

00:05:36,080 --> 00:05:41,120
offload

00:05:37,440 --> 00:05:42,800
this is implemented across a

00:05:41,120 --> 00:05:44,960
wide variety of nicks it's been

00:05:42,800 --> 00:05:49,120
implemented that way for a while

00:05:44,960 --> 00:05:52,000
rss we've made great headway with we see

00:05:49,120 --> 00:05:52,880
side scaling so this is really good for

00:05:52,000 --> 00:05:55,120
reducing

00:05:52,880 --> 00:05:57,919
or improving the load balancing on a

00:05:55,120 --> 00:05:57,919
multi cpu

00:05:58,160 --> 00:06:02,639
tso is also one uh transmit segmentation

00:06:01,600 --> 00:06:05,280
offload

00:06:02,639 --> 00:06:06,080
that we've done a good job on so that's

00:06:05,280 --> 00:06:09,039
the idea that

00:06:06,080 --> 00:06:09,919
we take a large uh tcp packet greater

00:06:09,039 --> 00:06:13,199
than mtu

00:06:09,919 --> 00:06:14,560
break it up into smaller chunks so they

00:06:13,199 --> 00:06:17,440
can be sent in the neck and

00:06:14,560 --> 00:06:18,880
the advantage there is we get economies

00:06:17,440 --> 00:06:20,560
of scale because the stack only had a

00:06:18,880 --> 00:06:23,360
process one packet

00:06:20,560 --> 00:06:25,600
there is sort of a cognate on the

00:06:23,360 --> 00:06:28,240
receive side called lro

00:06:25,600 --> 00:06:29,759
larger seed off load this one's been a

00:06:28,240 --> 00:06:32,319
little less

00:06:29,759 --> 00:06:34,000
ubiquitous i think the obvious reason is

00:06:32,319 --> 00:06:37,360
that it requires

00:06:34,000 --> 00:06:38,800
the device to be able to parse packets

00:06:37,360 --> 00:06:41,919
on receive

00:06:38,800 --> 00:06:45,600
and it also requires the device to

00:06:41,919 --> 00:06:48,400
implement some kind of logic

00:06:45,600 --> 00:06:49,440
about about this since there is state

00:06:48,400 --> 00:06:51,680
involved

00:06:49,440 --> 00:06:54,560
so in order to do lro we need to

00:06:51,680 --> 00:06:56,800
coalesce packets that are being received

00:06:54,560 --> 00:06:57,919
and once we start doing that that means

00:06:56,800 --> 00:07:02,160
we have to on a per

00:06:57,919 --> 00:07:05,680
flow basis collect packets buffer them

00:07:02,160 --> 00:07:07,759
and receive them in the stack and then

00:07:05,680 --> 00:07:09,520
of course that means we also have to

00:07:07,759 --> 00:07:11,120
account for the possibility that

00:07:09,520 --> 00:07:13,840
not all the packets are received there

00:07:11,120 --> 00:07:16,240
could be holes so we have to have timers

00:07:13,840 --> 00:07:16,880
and if you follow this what it means is

00:07:16,240 --> 00:07:21,360
it's

00:07:16,880 --> 00:07:23,680
a non-work conserving

00:07:21,360 --> 00:07:25,280
model and this is going to be true with

00:07:23,680 --> 00:07:26,400
with a lot of the offloads especially

00:07:25,280 --> 00:07:28,240
received

00:07:26,400 --> 00:07:30,639
and in fact is going to be one of the

00:07:28,240 --> 00:07:33,599
reasons why

00:07:30,639 --> 00:07:35,440
it's so difficult to to make offline

00:07:33,599 --> 00:07:39,039
ubiquitous

00:07:35,440 --> 00:07:42,720
beyond that though there has been some

00:07:39,039 --> 00:07:45,520
implementations of ipsec tls offload

00:07:42,720 --> 00:07:46,879
is one of the newer ones obviously tc

00:07:45,520 --> 00:07:51,120
flower offload

00:07:46,879 --> 00:07:54,400
has made some progress switch dev

00:07:51,120 --> 00:07:56,960
uh so all of these are

00:07:54,400 --> 00:07:59,599
at various levels i think different

00:07:56,960 --> 00:08:02,479
vendors uh push different things

00:07:59,599 --> 00:08:03,520
uh some of them are useful but it's not

00:08:02,479 --> 00:08:06,479
clear to me that

00:08:03,520 --> 00:08:07,599
they're universally useful at this point

00:08:06,479 --> 00:08:08,960
and

00:08:07,599 --> 00:08:11,280
a lot of this has to do with the

00:08:08,960 --> 00:08:13,360
complexities of how do you interact with

00:08:11,280 --> 00:08:15,919
the host software stack

00:08:13,360 --> 00:08:17,360
uh and the device some of these have to

00:08:15,919 --> 00:08:19,039
do with

00:08:17,360 --> 00:08:21,360
maintaining state in the device and the

00:08:19,039 --> 00:08:24,560
complexities of that so for instance tls

00:08:21,360 --> 00:08:26,000
uh requires a lot of state especially

00:08:24,560 --> 00:08:29,360
received so we hit some of those

00:08:26,000 --> 00:08:29,360
received problems that i mentioned

00:08:30,080 --> 00:08:35,279
so one um kind of digression before we

00:08:33,599 --> 00:08:38,800
get into the the actual problem

00:08:35,279 --> 00:08:39,919
i want to make an attempt to clarify the

00:08:38,800 --> 00:08:43,279
definition between

00:08:39,919 --> 00:08:45,920
acceleration and offload a lot of times

00:08:43,279 --> 00:08:49,200
they seem to be used interchangeably

00:08:45,920 --> 00:08:51,519
and uh previously i had mentioned

00:08:49,200 --> 00:08:53,120
a definition and i wanted to refine that

00:08:51,519 --> 00:08:55,040
a little bit so the earlier definition

00:08:53,120 --> 00:08:57,120
of something along the lines of

00:08:55,040 --> 00:08:58,880
offload is something that the host deck

00:08:57,120 --> 00:09:01,920
wants that a device

00:08:58,880 --> 00:09:03,519
wants to a device to do um

00:09:01,920 --> 00:09:05,680
so the device acts on behalf of the

00:09:03,519 --> 00:09:08,240
offload and acceleration

00:09:05,680 --> 00:09:10,000
uh previous definition was that anything

00:09:08,240 --> 00:09:12,560
that speeds up

00:09:10,000 --> 00:09:13,360
um any offline that speeds up the

00:09:12,560 --> 00:09:16,320
processing

00:09:13,360 --> 00:09:17,120
would be considered acceleration so uh

00:09:16,320 --> 00:09:19,440
those device

00:09:17,120 --> 00:09:20,800
those definitions really aren't aren't

00:09:19,440 --> 00:09:23,360
great um

00:09:20,800 --> 00:09:23,920
and i think uh when we look at the wider

00:09:23,360 --> 00:09:26,160
problem

00:09:23,920 --> 00:09:28,080
if we could distinguish these in a

00:09:26,160 --> 00:09:32,080
certain way it might be helpful

00:09:28,080 --> 00:09:34,839
so offload is specifically the host

00:09:32,080 --> 00:09:38,399
stack request

00:09:34,839 --> 00:09:40,800
operations um from the device

00:09:38,399 --> 00:09:43,360
associated with either the act of

00:09:40,800 --> 00:09:46,800
transmitting or receiving a packet

00:09:43,360 --> 00:09:49,200
and this fits the canonical use of the

00:09:46,800 --> 00:09:51,440
term offload and check some offload and

00:09:49,200 --> 00:09:52,800
transmit segmentation offload tls

00:09:51,440 --> 00:09:55,600
offload

00:09:52,800 --> 00:09:56,480
where for instance on transmit we

00:09:55,600 --> 00:09:59,360
arrange

00:09:56,480 --> 00:10:00,640
all of the information that the device

00:09:59,360 --> 00:10:04,240
needs in order to do

00:10:00,640 --> 00:10:07,360
the the work for instance to do the

00:10:04,240 --> 00:10:09,120
texas muffler we arrange that a priori

00:10:07,360 --> 00:10:10,480
in the case of checksum offload usually

00:10:09,120 --> 00:10:13,920
it's just as simple as putting

00:10:10,480 --> 00:10:15,279
information in the transmit descriptor

00:10:13,920 --> 00:10:16,959
receive is kind of similar on the

00:10:15,279 --> 00:10:18,880
receive side

00:10:16,959 --> 00:10:20,480
when packets are received the device

00:10:18,880 --> 00:10:23,839
kind of autonomously

00:10:20,480 --> 00:10:26,000
performs uh configured operations such

00:10:23,839 --> 00:10:29,120
as computing the checksum

00:10:26,000 --> 00:10:31,920
or decrypting the packet and all of that

00:10:29,120 --> 00:10:32,640
happens before it sends it to the host

00:10:31,920 --> 00:10:34,560
and again

00:10:32,640 --> 00:10:36,240
when the packet is sent to the host in

00:10:34,560 --> 00:10:38,079
the receive descriptor

00:10:36,240 --> 00:10:40,079
the device indicates what it actually

00:10:38,079 --> 00:10:43,279
did so it would indicate for instance

00:10:40,079 --> 00:10:46,079
the the checksum packet checksum if

00:10:43,279 --> 00:10:49,680
we're doing generic checksum offline

00:10:46,079 --> 00:10:52,240
so in both these cases it's kind of

00:10:49,680 --> 00:10:53,600
a disassociation between the host stack

00:10:52,240 --> 00:10:56,640
and the device so

00:10:53,600 --> 00:10:59,600
in transmit we create these

00:10:56,640 --> 00:11:00,000
transmit descriptors and everything that

00:10:59,600 --> 00:11:02,720
we want

00:11:00,000 --> 00:11:04,160
the device to do has to be put into that

00:11:02,720 --> 00:11:05,680
descriptor and the device has to

00:11:04,160 --> 00:11:07,440
understand it for

00:11:05,680 --> 00:11:08,640
for the packet to be sent correctly so

00:11:07,440 --> 00:11:10,240
for instance if we have multiple

00:11:08,640 --> 00:11:15,200
operations

00:11:10,240 --> 00:11:16,079
like we're doing uh tls over tcp

00:11:15,200 --> 00:11:18,800
we have to do that with the

00:11:16,079 --> 00:11:21,040
understanding that we're offloading

00:11:18,800 --> 00:11:22,240
the tls operation so that's sort of one

00:11:21,040 --> 00:11:25,360
command

00:11:22,240 --> 00:11:28,079
and then we're offloading the checksum

00:11:25,360 --> 00:11:29,440
of the tcp so that's another command

00:11:28,079 --> 00:11:30,240
obviously that they could be paired

00:11:29,440 --> 00:11:33,839
together

00:11:30,240 --> 00:11:35,839
but we can imagine scenarios where uh it

00:11:33,839 --> 00:11:37,600
gets more complex like than that so for

00:11:35,839 --> 00:11:41,519
instance we could have

00:11:37,600 --> 00:11:45,200
um rdma over g

00:11:41,519 --> 00:11:47,360
i wore over tls over tcp

00:11:45,200 --> 00:11:49,200
over udp encapsulation so you could have

00:11:47,360 --> 00:11:51,120
multiple checksums

00:11:49,200 --> 00:11:53,120
uh multiple encryptions that could even

00:11:51,120 --> 00:11:55,440
be over ipsec

00:11:53,120 --> 00:11:57,360
uh and obviously the hardware can't

00:11:55,440 --> 00:12:01,360
support all that but the point here is

00:11:57,360 --> 00:12:04,880
that the permutations could become

00:12:01,360 --> 00:12:05,839
almost combinatorial and it's up to the

00:12:04,880 --> 00:12:09,120
device

00:12:05,839 --> 00:12:10,560
to to expose the interfaces

00:12:09,120 --> 00:12:12,560
to which of those combinations can

00:12:10,560 --> 00:12:14,240
support but it's also up to the host to

00:12:12,560 --> 00:12:15,440
understand which of those combinations

00:12:14,240 --> 00:12:17,120
can support

00:12:15,440 --> 00:12:20,079
one of the one of the major problems

00:12:17,120 --> 00:12:24,240
i'll look to this later on

00:12:20,079 --> 00:12:27,920
is that when we have an offload

00:12:24,240 --> 00:12:28,560
on transmit the device has to under or

00:12:27,920 --> 00:12:30,160
the

00:12:28,560 --> 00:12:31,920
device driver and the host have to

00:12:30,160 --> 00:12:33,279
understand what the capabilities of the

00:12:31,920 --> 00:12:36,399
device are

00:12:33,279 --> 00:12:39,360
very very precisely

00:12:36,399 --> 00:12:41,920
you can imagine if the host tries to

00:12:39,360 --> 00:12:44,160
offload a checksum

00:12:41,920 --> 00:12:45,200
and for whatever reason the device

00:12:44,160 --> 00:12:48,320
doesn't understand

00:12:45,200 --> 00:12:51,040
how to how to offload that particular

00:12:48,320 --> 00:12:53,519
texan maybe the packet headers it

00:12:51,040 --> 00:12:57,040
doesn't understand and it's doing

00:12:53,519 --> 00:12:59,519
um protocol specific checksum offline

00:12:57,040 --> 00:13:01,680
if it doesn't understand that then the

00:12:59,519 --> 00:13:05,200
packet cannot be transmitted correctly

00:13:01,680 --> 00:13:08,160
and we have we have a bug so

00:13:05,200 --> 00:13:09,440
offloads are inherently complicated uh

00:13:08,160 --> 00:13:12,880
receive side's a little

00:13:09,440 --> 00:13:15,200
easier because uh it's optional so for

00:13:12,880 --> 00:13:18,240
instance if the device

00:13:15,200 --> 00:13:19,760
can't compute a checksum for a packet it

00:13:18,240 --> 00:13:20,880
sends it up to the host and just

00:13:19,760 --> 00:13:22,480
doesn't provide the checks of

00:13:20,880 --> 00:13:23,760
information the host does they checks

00:13:22,480 --> 00:13:25,200
them itself

00:13:23,760 --> 00:13:27,680
so that's kind of offload now

00:13:25,200 --> 00:13:30,959
acceleration

00:13:27,680 --> 00:13:33,120
uh is a similar respect

00:13:30,959 --> 00:13:34,000
the we have hardware that can perform

00:13:33,120 --> 00:13:36,959
operations

00:13:34,000 --> 00:13:38,959
on behalf of the host but what i propose

00:13:36,959 --> 00:13:42,320
for acceleration is this is more of an

00:13:38,959 --> 00:13:45,360
inline data path

00:13:42,320 --> 00:13:46,720
element so for instance in the case of

00:13:45,360 --> 00:13:49,760
checksum

00:13:46,720 --> 00:13:50,560
offload check some acceleration would be

00:13:49,760 --> 00:13:52,959
something more

00:13:50,560 --> 00:13:55,360
like the host stack decides that it

00:13:52,959 --> 00:13:59,360
needs to compute a checksum

00:13:55,360 --> 00:14:01,279
so we want to call a function uh

00:13:59,360 --> 00:14:03,440
please do a high performance checksum

00:14:01,279 --> 00:14:07,519
over this block

00:14:03,440 --> 00:14:08,240
and the actual work for instance of

00:14:07,519 --> 00:14:10,000
putting in

00:14:08,240 --> 00:14:11,920
the checksum into the packet could could

00:14:10,000 --> 00:14:14,880
be done in the cpu

00:14:11,920 --> 00:14:16,880
but the expensive operation which is

00:14:14,880 --> 00:14:18,320
really what we went out of hardware the

00:14:16,880 --> 00:14:21,360
transform

00:14:18,320 --> 00:14:22,320
that could be done uh in the hardware so

00:14:21,360 --> 00:14:24,639
we have a couple of

00:14:22,320 --> 00:14:26,399
examples of this certainly uh the aes

00:14:24,639 --> 00:14:30,399
instructions

00:14:26,399 --> 00:14:33,839
and modern cpus approach this

00:14:30,399 --> 00:14:38,079
they as we get higher higher and higher

00:14:33,839 --> 00:14:40,320
um vectorized instructions uh more width

00:14:38,079 --> 00:14:41,120
these become more like accelerations

00:14:40,320 --> 00:14:44,560
than just

00:14:41,120 --> 00:14:48,480
uh simple cpu arithmetic instructions

00:14:44,560 --> 00:14:50,480
uh clearly gpus are really good at this

00:14:48,480 --> 00:14:51,920
the programming model is specifically

00:14:50,480 --> 00:14:53,760
that

00:14:51,920 --> 00:14:55,600
we we code up a program that runs in the

00:14:53,760 --> 00:14:58,720
cpu but

00:14:55,600 --> 00:15:00,720
whenever we can we accelerate uh

00:14:58,720 --> 00:15:02,240
whatever operations we can matrix

00:15:00,720 --> 00:15:04,320
operations so

00:15:02,240 --> 00:15:06,000
matrix multiply for instance is much

00:15:04,320 --> 00:15:09,519
easier to do

00:15:06,000 --> 00:15:10,000
um in the device but it's different than

00:15:09,519 --> 00:15:12,000
offload

00:15:10,000 --> 00:15:14,240
we don't we don't necessarily tell the

00:15:12,000 --> 00:15:15,440
gpu everything we need to do with this

00:15:14,240 --> 00:15:18,240
video frame

00:15:15,440 --> 00:15:20,880
we can actually program it in steps um

00:15:18,240 --> 00:15:23,040
and have the advantages of that

00:15:20,880 --> 00:15:24,399
so just think of the difference here as

00:15:23,040 --> 00:15:27,680
offload is

00:15:24,399 --> 00:15:31,120
uh kind of fire and forget the

00:15:27,680 --> 00:15:35,040
the interface between the

00:15:31,120 --> 00:15:37,120
host and the device is kind of a one-off

00:15:35,040 --> 00:15:38,160
uh we're transmitting a packet here's

00:15:37,120 --> 00:15:40,000
everything

00:15:38,160 --> 00:15:41,600
you need to do device or receiving a

00:15:40,000 --> 00:15:42,720
packet here's everything i know about

00:15:41,600 --> 00:15:44,480
this packet

00:15:42,720 --> 00:15:46,160
acceleration kind of breaks it down and

00:15:44,480 --> 00:15:48,560
can be more granular

00:15:46,160 --> 00:15:49,839
okay so we want to do uh this operation

00:15:48,560 --> 00:15:51,279
i'm going to do this checksum like i

00:15:49,839 --> 00:15:52,480
have a function for that we want to get

00:15:51,279 --> 00:15:55,120
this acceleration

00:15:52,480 --> 00:15:57,680
function for that we want to do this

00:15:55,120 --> 00:16:00,639
state lookup have a function for that

00:15:57,680 --> 00:16:02,880
hash etc so it really breaks it down

00:16:00,639 --> 00:16:06,480
into the elements

00:16:02,880 --> 00:16:06,480
so let's look at the

00:16:06,880 --> 00:16:10,000
traditional stack driver device model i

00:16:09,360 --> 00:16:14,240
think this

00:16:10,000 --> 00:16:17,839
is well known uh we have host stacks

00:16:14,240 --> 00:16:19,920
that linux dpdk

00:16:17,839 --> 00:16:22,720
obviously freebsd microsoft everybody

00:16:19,920 --> 00:16:26,480
has sort of this model

00:16:22,720 --> 00:16:27,759
usually there's a common api into device

00:16:26,480 --> 00:16:29,680
drivers

00:16:27,759 --> 00:16:31,839
so the advantage there is since it's

00:16:29,680 --> 00:16:34,000
common that we can write one

00:16:31,839 --> 00:16:36,079
networking stack that works with a whole

00:16:34,000 --> 00:16:36,560
bunch of different devices because the

00:16:36,079 --> 00:16:39,120
driver

00:16:36,560 --> 00:16:41,440
basically forms an adaptation layer and

00:16:39,120 --> 00:16:45,199
the role of the driver is to

00:16:41,440 --> 00:16:48,720
convert the that common api into

00:16:45,199 --> 00:16:50,800
device-specific commands and information

00:16:48,720 --> 00:16:52,399
and a typical model that's done over the

00:16:50,800 --> 00:16:55,759
pcie bus

00:16:52,399 --> 00:16:59,040
and a proprietary api into the device

00:16:55,759 --> 00:17:01,279
so in this model the driver exposes

00:16:59,040 --> 00:17:02,480
on the north side exposes uh interfaces

00:17:01,279 --> 00:17:05,199
to the host

00:17:02,480 --> 00:17:07,199
this common interfaces on the south side

00:17:05,199 --> 00:17:08,799
the device exposes its proprietary

00:17:07,199 --> 00:17:10,480
interfaces to the driver

00:17:08,799 --> 00:17:13,280
assuming the driver understands both of

00:17:10,480 --> 00:17:16,839
these it it can translate between them

00:17:13,280 --> 00:17:18,559
and that's how we accomplish uh

00:17:16,839 --> 00:17:21,039
communications

00:17:18,559 --> 00:17:22,240
so as i mentioned on the transmit side

00:17:21,039 --> 00:17:25,439
this is done with

00:17:22,240 --> 00:17:26,480
uh a transmit descriptor which is

00:17:25,439 --> 00:17:28,319
basically

00:17:26,480 --> 00:17:30,720
an indication of the packet to be

00:17:28,319 --> 00:17:33,520
transmitted the actual bytes

00:17:30,720 --> 00:17:34,480
and some ancillary information which

00:17:33,520 --> 00:17:37,679
describes

00:17:34,480 --> 00:17:39,360
additional commands or

00:17:37,679 --> 00:17:40,720
characteristics about the packet for

00:17:39,360 --> 00:17:44,000
transmit

00:17:40,720 --> 00:17:46,559
so there's also a second

00:17:44,000 --> 00:17:48,400
case uh which is on the more on the

00:17:46,559 --> 00:17:51,200
receive side

00:17:48,400 --> 00:17:52,880
where the device annotates packets as

00:17:51,200 --> 00:17:54,480
they come in so again the device can

00:17:52,880 --> 00:17:57,760
indicate a check zone

00:17:54,480 --> 00:18:01,600
uh xdp hints would be a case where

00:17:57,760 --> 00:18:04,799
the device is extra information

00:18:01,600 --> 00:18:06,240
um maybe off offset ip headers tcp

00:18:04,799 --> 00:18:07,360
headers things like that

00:18:06,240 --> 00:18:09,760
and i could put in that and receive

00:18:07,360 --> 00:18:13,520
descriptor for consumption

00:18:09,760 --> 00:18:16,559
by by the driver commands

00:18:13,520 --> 00:18:18,000
also include sort of configuration or

00:18:16,559 --> 00:18:19,919
programming commands so we have things

00:18:18,000 --> 00:18:22,240
like tc flower

00:18:19,919 --> 00:18:24,320
rte flow might might be familiar with

00:18:22,240 --> 00:18:26,720
some of the dptk folks

00:18:24,320 --> 00:18:28,799
these allow setting up flow state in the

00:18:26,720 --> 00:18:32,240
device or configuration

00:18:28,799 --> 00:18:34,240
but particularly useful on receive

00:18:32,240 --> 00:18:35,840
when we want to classify packets and the

00:18:34,240 --> 00:18:38,320
device can provide

00:18:35,840 --> 00:18:42,320
the classification result to the host

00:18:38,320 --> 00:18:45,039
via the descriptors

00:18:42,320 --> 00:18:46,960
okay so now let's get into a couple of

00:18:45,039 --> 00:18:50,640
problems that i think we have with this

00:18:46,960 --> 00:18:52,640
model the first one is what i call the

00:18:50,640 --> 00:18:55,679
narrow waist

00:18:52,640 --> 00:18:57,919
and this is an artifact that

00:18:55,679 --> 00:18:59,440
if we look at that interface between the

00:18:57,919 --> 00:19:02,640
driver and the device

00:18:59,440 --> 00:19:06,240
which is typically over pcie bus

00:19:02,640 --> 00:19:09,360
it is really limiting to us

00:19:06,240 --> 00:19:12,160
in several ways first of all we have to

00:19:09,360 --> 00:19:14,480
do uh pcie messages

00:19:12,160 --> 00:19:15,440
the the descriptors that i've mentioned

00:19:14,480 --> 00:19:17,600
they are usually

00:19:15,440 --> 00:19:18,559
quite limited to the amount of data they

00:19:17,600 --> 00:19:21,840
can

00:19:18,559 --> 00:19:22,880
expose this came up for instance in xvp

00:19:21,840 --> 00:19:25,840
hence

00:19:22,880 --> 00:19:27,520
where we realized if if the device wants

00:19:25,840 --> 00:19:30,080
to provide

00:19:27,520 --> 00:19:30,640
say full ipv6 addresses and a whole

00:19:30,080 --> 00:19:34,480
bunch of

00:19:30,640 --> 00:19:37,520
other information the proportion of data

00:19:34,480 --> 00:19:40,720
going across a pcie bus that's overhead

00:19:37,520 --> 00:19:42,000
that overhead could eclipse the actual

00:19:40,720 --> 00:19:45,440
data

00:19:42,000 --> 00:19:48,480
so it's a little bit of a um

00:19:45,440 --> 00:19:49,600
conundrum so we have to assume that we

00:19:48,480 --> 00:19:52,320
don't get this for free

00:19:49,600 --> 00:19:53,919
anytime we move data it's expensive so

00:19:52,320 --> 00:19:57,679
moving data across the bus

00:19:53,919 --> 00:20:00,000
is is kind of pricey so that that's one

00:19:57,679 --> 00:20:03,120
problem but the other problem is

00:20:00,000 --> 00:20:04,960
uh anytime we deal with state and we

00:20:03,120 --> 00:20:06,320
have a stateful device for instance flow

00:20:04,960 --> 00:20:08,720
state

00:20:06,320 --> 00:20:10,320
those flow states have to be maintained

00:20:08,720 --> 00:20:11,840
and they have to be maintained across

00:20:10,320 --> 00:20:14,799
the same interface

00:20:11,840 --> 00:20:16,799
so what we've seen in the past is a

00:20:14,799 --> 00:20:19,200
application that has a very high

00:20:16,799 --> 00:20:20,080
connection turnover rate if we're trying

00:20:19,200 --> 00:20:22,080
to keep up

00:20:20,080 --> 00:20:24,159
this so-called shadow state in the

00:20:22,080 --> 00:20:27,200
device to keep it current

00:20:24,159 --> 00:20:28,880
then that's additional messages uh going

00:20:27,200 --> 00:20:32,000
across the bus

00:20:28,880 --> 00:20:34,240
so again additional overhead so the

00:20:32,000 --> 00:20:35,919
upshot of all of this is

00:20:34,240 --> 00:20:37,360
this kind of forms a narrow waste of

00:20:35,919 --> 00:20:40,320
functionality

00:20:37,360 --> 00:20:41,760
where even if the device driver or the

00:20:40,320 --> 00:20:44,559
device has

00:20:41,760 --> 00:20:46,320
really elaborate functionality we still

00:20:44,559 --> 00:20:46,960
need a way for it to expose that in the

00:20:46,320 --> 00:20:50,000
host

00:20:46,960 --> 00:20:51,760
and not to overwhelm us with

00:20:50,000 --> 00:20:53,360
with the necessary information to

00:20:51,760 --> 00:20:57,039
program or configure

00:20:53,360 --> 00:20:59,520
so it is a bit of a uh trick to to get

00:20:57,039 --> 00:20:59,520
this right

00:20:59,679 --> 00:21:03,760
so the second problem is what i call the

00:21:01,919 --> 00:21:07,120
black box problem

00:21:03,760 --> 00:21:10,240
and this is simply that

00:21:07,120 --> 00:21:11,039
um from the host stack point of view and

00:21:10,240 --> 00:21:14,000
even sometimes

00:21:11,039 --> 00:21:14,559
even the driver point of view the device

00:21:14,000 --> 00:21:16,799
uh

00:21:14,559 --> 00:21:18,559
is something of a black box and this is

00:21:16,799 --> 00:21:22,159
especially true from

00:21:18,559 --> 00:21:22,640
from the host stack for instance i

00:21:22,159 --> 00:21:27,360
mentioned

00:21:22,640 --> 00:21:30,080
lro um if a device supports lro

00:21:27,360 --> 00:21:30,559
that doesn't necessarily mean that that

00:21:30,080 --> 00:21:32,720
would be

00:21:30,559 --> 00:21:33,679
appropriate for for what the host stack

00:21:32,720 --> 00:21:35,200
needs

00:21:33,679 --> 00:21:36,720
uh there's a whole bunch of other

00:21:35,200 --> 00:21:38,159
additional information you need for

00:21:36,720 --> 00:21:40,480
elerator working

00:21:38,159 --> 00:21:42,000
we would need timers for instance and

00:21:40,480 --> 00:21:44,880
they need to be configured

00:21:42,000 --> 00:21:45,760
we need to understand all the algorithms

00:21:44,880 --> 00:21:48,960
uh

00:21:45,760 --> 00:21:51,919
how they work those unfortunately

00:21:48,960 --> 00:21:52,640
are are more along the black box but

00:21:51,919 --> 00:21:54,960
even then

00:21:52,640 --> 00:21:55,919
there's actually really simple cases

00:21:54,960 --> 00:21:59,919
that have come across

00:21:55,919 --> 00:22:03,840
recently where we don't actually know

00:21:59,919 --> 00:22:05,520
what we're getting from a device and

00:22:03,840 --> 00:22:07,440
one of the one of the best examples i

00:22:05,520 --> 00:22:10,960
think is the

00:22:07,440 --> 00:22:13,679
topless hash that we get out of

00:22:10,960 --> 00:22:14,720
you know several devices at this point

00:22:13,679 --> 00:22:17,200
and it's quite useful

00:22:14,720 --> 00:22:18,320
to to the stack if we can get a four

00:22:17,200 --> 00:22:20,880
tuple

00:22:18,320 --> 00:22:22,799
packet hash from the device the same one

00:22:20,880 --> 00:22:24,880
that's used in rss

00:22:22,799 --> 00:22:26,320
we can actually use that as the sk buff

00:22:24,880 --> 00:22:28,640
hash and

00:22:26,320 --> 00:22:29,600
the advantage of that is we get the hash

00:22:28,640 --> 00:22:31,919
which is used for

00:22:29,600 --> 00:22:33,360
in several different algorithms in the

00:22:31,919 --> 00:22:36,080
host stack

00:22:33,360 --> 00:22:38,559
but we get the hash in a sense for free

00:22:36,080 --> 00:22:40,240
the hash actually does

00:22:38,559 --> 00:22:42,080
is sort of expensive to compete on the

00:22:40,240 --> 00:22:43,039
house we have to parse the packet on

00:22:42,080 --> 00:22:45,120
receive

00:22:43,039 --> 00:22:46,240
we have to extract the transport uh

00:22:45,120 --> 00:22:48,640
ports usually

00:22:46,240 --> 00:22:51,120
and then we have to perform uh uh

00:22:48,640 --> 00:22:54,159
jenkins has said patch or top

00:22:51,120 --> 00:22:56,480
uh some hash algorithm so that's cycles

00:22:54,159 --> 00:22:59,039
and if we can get this from the device

00:22:56,480 --> 00:23:00,080
that's that's fantastic but the problem

00:22:59,039 --> 00:23:02,159
is

00:23:00,080 --> 00:23:04,880
we don't necessarily know what we're

00:23:02,159 --> 00:23:07,120
actually getting from the device

00:23:04,880 --> 00:23:08,799
and some of this stems from the fact

00:23:07,120 --> 00:23:12,240
that

00:23:08,799 --> 00:23:15,200
linux unlike windows

00:23:12,240 --> 00:23:17,120
we really don't specify device

00:23:15,200 --> 00:23:19,440
requirements

00:23:17,120 --> 00:23:21,360
uh and and there's some historical

00:23:19,440 --> 00:23:24,640
reasons for that there's also

00:23:21,360 --> 00:23:26,880
some we don't want to we don't want to

00:23:24,640 --> 00:23:27,679
have have to write what they call it in

00:23:26,880 --> 00:23:29,840
windows the

00:23:27,679 --> 00:23:31,520
wqls or whatever we don't have to write

00:23:29,840 --> 00:23:33,039
that specification

00:23:31,520 --> 00:23:35,679
we don't want to have to pigeonhole what

00:23:33,039 --> 00:23:37,200
the device drivers device artists do

00:23:35,679 --> 00:23:39,360
device vendors do we want them to

00:23:37,200 --> 00:23:42,640
innovate and on the other hand

00:23:39,360 --> 00:23:44,159
uh in the case of the rss hash there are

00:23:42,640 --> 00:23:46,880
cases where

00:23:44,159 --> 00:23:48,960
the the algorithm used by the device may

00:23:46,880 --> 00:23:50,559
not actually

00:23:48,960 --> 00:23:52,240
fit the characteristics that the host

00:23:50,559 --> 00:23:53,279
requires and the host requires the

00:23:52,240 --> 00:23:56,559
following it

00:23:53,279 --> 00:23:58,400
we need a 32-bit hash

00:23:56,559 --> 00:24:00,159
it has to be based on for tuple

00:23:58,400 --> 00:24:02,960
information

00:24:00,159 --> 00:24:04,000
it has to be a uniform hash it has to

00:24:02,960 --> 00:24:06,880
have good waterfall

00:24:04,000 --> 00:24:09,600
properties and it has to have the full

00:24:06,880 --> 00:24:12,640
32 bits of entropy

00:24:09,600 --> 00:24:14,000
we have a working model of that in flow

00:24:12,640 --> 00:24:17,039
dissector and sk

00:24:14,000 --> 00:24:19,520
skb hash and software

00:24:17,039 --> 00:24:22,400
uh it's probably the most complete

00:24:19,520 --> 00:24:23,760
software model to do this however

00:24:22,400 --> 00:24:26,320
it would be really expensive to put in

00:24:23,760 --> 00:24:27,760
the hardware so we assume that hardware

00:24:26,320 --> 00:24:30,480
typically wants to do something lighter

00:24:27,760 --> 00:24:32,559
weight but the trade-off there is

00:24:30,480 --> 00:24:34,320
sometimes hardware may not fit those

00:24:32,559 --> 00:24:36,159
characteristics and we really don't have

00:24:34,320 --> 00:24:38,320
an easy way to validate that

00:24:36,159 --> 00:24:41,120
so for instance uh i've seen one case

00:24:38,320 --> 00:24:43,440
where there's a proposal

00:24:41,120 --> 00:24:45,440
uh to kind of skimp on the number of

00:24:43,440 --> 00:24:47,760
bits for the hash

00:24:45,440 --> 00:24:49,679
uh in the receive descriptor because

00:24:47,760 --> 00:24:51,760
it's expensive real estate

00:24:49,679 --> 00:24:52,960
and every bit we use in the receive

00:24:51,760 --> 00:24:54,640
descriptor potentially

00:24:52,960 --> 00:24:57,039
makes every script we just we see a

00:24:54,640 --> 00:24:59,440
descriptor larger so we want to

00:24:57,039 --> 00:25:02,480
compress these as much as possible it's

00:24:59,440 --> 00:25:04,640
really hard to compress a hash because

00:25:02,480 --> 00:25:05,600
any bit we take out we lose lee's

00:25:04,640 --> 00:25:08,640
information

00:25:05,600 --> 00:25:11,840
so when we compress that to 32 bits

00:25:08,640 --> 00:25:15,520
we're effectively losing 12 bits of

00:25:11,840 --> 00:25:20,080
entropy and that can create problems

00:25:15,520 --> 00:25:22,240
uh if we for instance we just take those

00:25:20,080 --> 00:25:23,200
20 bits and we put those into 32-bit

00:25:22,240 --> 00:25:27,840
hash

00:25:23,200 --> 00:25:30,960
with a 12 upper 12 bits or zero

00:25:27,840 --> 00:25:32,880
we do normal um rfs or

00:25:30,960 --> 00:25:34,720
or rps that's fine because usually we

00:25:32,880 --> 00:25:36,159
only look at the lower bits

00:25:34,720 --> 00:25:38,320
but there are some other algorithms

00:25:36,159 --> 00:25:42,240
where we do look at the upper bits like

00:25:38,320 --> 00:25:44,240
accelerated rfs would do that so

00:25:42,240 --> 00:25:46,400
this is kind of kind of an example use

00:25:44,240 --> 00:25:48,240
case um generally the devices of black

00:25:46,400 --> 00:25:49,200
box we're hoping that some of this gets

00:25:48,240 --> 00:25:52,159
fixed with

00:25:49,200 --> 00:25:53,760
the ability to program these devices for

00:25:52,159 --> 00:25:56,559
instance in the case of

00:25:53,760 --> 00:25:57,919
of the rss hash if we could actually

00:25:56,559 --> 00:25:59,600
program the device and make sure that

00:25:57,919 --> 00:26:02,799
we're getting the full 32 bits on

00:25:59,600 --> 00:26:06,080
toplets that might be useful

00:26:02,799 --> 00:26:07,039
so the outcome of this model is the the

00:26:06,080 --> 00:26:09,520
narrow

00:26:07,039 --> 00:26:10,799
waste and the black box it really does

00:26:09,520 --> 00:26:12,480
force offloads as opposed to

00:26:10,799 --> 00:26:14,720
acceleration

00:26:12,480 --> 00:26:16,640
uh you can imagine in the current model

00:26:14,720 --> 00:26:18,799
even trying to accelerate across the

00:26:16,640 --> 00:26:20,159
pcie bus where we're calling individual

00:26:18,799 --> 00:26:23,120
function blocks

00:26:20,159 --> 00:26:25,760
out of the device uh is would be quite a

00:26:23,120 --> 00:26:27,520
accomplishment really difficult to do

00:26:25,760 --> 00:26:29,919
i mentioned the main maintain

00:26:27,520 --> 00:26:33,360
maintenance of shadow state

00:26:29,919 --> 00:26:37,200
so thinking about shadow state

00:26:33,360 --> 00:26:39,760
it's a pretty big load on this system

00:26:37,200 --> 00:26:42,400
and we know that we already own a host

00:26:39,760 --> 00:26:45,120
we already have connection states

00:26:42,400 --> 00:26:45,679
and the host can have millions because

00:26:45,120 --> 00:26:47,440
host

00:26:45,679 --> 00:26:49,039
is usually just limited by its memory

00:26:47,440 --> 00:26:51,600
which can be quite large

00:26:49,039 --> 00:26:52,080
so anytime we try to establish the

00:26:51,600 --> 00:26:53,919
shadow

00:26:52,080 --> 00:26:56,400
state connection state inside the

00:26:53,919 --> 00:26:59,600
network or even inside the device

00:26:56,400 --> 00:27:02,640
invariably it's a subset a proper subset

00:26:59,600 --> 00:27:05,600
of what's on the host that creates a

00:27:02,640 --> 00:27:08,880
whole myriad of problems

00:27:05,600 --> 00:27:10,720
if the shadow state becomes a cache

00:27:08,880 --> 00:27:12,559
of connection states and as we know

00:27:10,720 --> 00:27:14,799
caches and the network

00:27:12,559 --> 00:27:17,600
are then susceptible to denominator

00:27:14,799 --> 00:27:20,880
service attacks on

00:27:17,600 --> 00:27:23,600
on the internet uh we also know that

00:27:20,880 --> 00:27:24,559
uh if the cash missed rate becomes too

00:27:23,600 --> 00:27:26,559
high

00:27:24,559 --> 00:27:28,240
then actually having the cash may end up

00:27:26,559 --> 00:27:29,679
being worse and not having the cash so

00:27:28,240 --> 00:27:31,440
it's a whole bunch of things and

00:27:29,679 --> 00:27:33,840
obviously there's been a lot of

00:27:31,440 --> 00:27:35,840
research into this but um i don't think

00:27:33,840 --> 00:27:38,399
we've actually solved this one

00:27:35,840 --> 00:27:39,200
so the other athlete or outcome as i

00:27:38,399 --> 00:27:41,440
mentioned

00:27:39,200 --> 00:27:43,360
we only have a few offloads that really

00:27:41,440 --> 00:27:45,679
became ubiquitous

00:27:43,360 --> 00:27:47,840
and these are ones that are well suited

00:27:45,679 --> 00:27:51,760
uh check some

00:27:47,840 --> 00:27:52,799
is great but um even that's elusive to

00:27:51,760 --> 00:27:55,840
get right

00:27:52,799 --> 00:27:57,120
so we've had a long uh standing request

00:27:55,840 --> 00:27:59,840
from the vendors to

00:27:57,120 --> 00:28:02,080
to provide check some generic offloads

00:27:59,840 --> 00:28:04,480
as opposed to cycling specific

00:28:02,080 --> 00:28:06,399
uh we're getting improvements on that

00:28:04,480 --> 00:28:10,399
but uh there's still a lot of

00:28:06,399 --> 00:28:13,360
checks on specific offloads out there

00:28:10,399 --> 00:28:15,440
the the other thing this drives is least

00:28:13,360 --> 00:28:19,200
common denominator

00:28:15,440 --> 00:28:21,039
uh when when we have this scenario when

00:28:19,200 --> 00:28:24,159
we're trying to support

00:28:21,039 --> 00:28:26,960
uh so many drivers across this model

00:28:24,159 --> 00:28:29,600
it does kind of support the least common

00:28:26,960 --> 00:28:32,880
denominator makes it harder to innovate

00:28:29,600 --> 00:28:32,880
harder to add to the stack

00:28:32,960 --> 00:28:35,520
and that's

00:28:36,000 --> 00:28:42,960
that's kind of tricky so

00:28:39,760 --> 00:28:45,360
i have a couple of general

00:28:42,960 --> 00:28:49,360
i don't want to call them solutions but

00:28:45,360 --> 00:28:49,360
possibilities for solution spaces

00:28:49,679 --> 00:28:57,120
so excuse me one concept is

00:28:53,279 --> 00:29:00,799
what i call split plane acceleration

00:28:57,120 --> 00:29:04,000
so this is the manifestation

00:29:00,799 --> 00:29:06,640
of how to get acceleration

00:29:04,000 --> 00:29:07,840
at a lower level and what it really

00:29:06,640 --> 00:29:11,039
requires is

00:29:07,840 --> 00:29:12,559
a tighter coupling between the low-level

00:29:11,039 --> 00:29:16,240
software

00:29:12,559 --> 00:29:17,919
and the hardware directly so

00:29:16,240 --> 00:29:19,679
i i don't think we can necessarily do

00:29:17,919 --> 00:29:22,080
this in the current model

00:29:19,679 --> 00:29:23,120
and um really going to be hard to do on

00:29:22,080 --> 00:29:24,399
servers

00:29:23,120 --> 00:29:26,799
but thinking about something like

00:29:24,399 --> 00:29:32,640
smartnix where

00:29:26,799 --> 00:29:34,480
the the devices closed environment

00:29:32,640 --> 00:29:36,559
we can address it as domain specific

00:29:34,480 --> 00:29:38,159
architecture which means we could

00:29:36,559 --> 00:29:40,640
could in fact break down some of these

00:29:38,159 --> 00:29:42,960
barriers so would not necessarily stuck

00:29:40,640 --> 00:29:44,960
for instance between the application

00:29:42,960 --> 00:29:47,600
cpus and the smartnic

00:29:44,960 --> 00:29:49,279
and the co-located hardware we're not

00:29:47,600 --> 00:29:52,159
necessarily stuck with the

00:29:49,279 --> 00:29:54,320
canonical device driver interface we

00:29:52,159 --> 00:29:57,039
could actually do something different

00:29:54,320 --> 00:29:58,960
and we could actually allow more of a

00:29:57,039 --> 00:30:02,799
functional interface

00:29:58,960 --> 00:30:07,120
uh where the hardware exposes

00:30:02,799 --> 00:30:08,880
the blocks and the low-level software

00:30:07,120 --> 00:30:10,399
could be programmable consume that

00:30:08,880 --> 00:30:12,080
information

00:30:10,399 --> 00:30:13,600
and because it is like something like a

00:30:12,080 --> 00:30:16,159
smart nic they're still

00:30:13,600 --> 00:30:18,080
we're still exposed to the host uh using

00:30:16,159 --> 00:30:21,440
the normal interfaces

00:30:18,080 --> 00:30:22,399
but and this way and this also supports

00:30:21,440 --> 00:30:25,360
um

00:30:22,399 --> 00:30:25,840
more of a device data path programming

00:30:25,360 --> 00:30:28,000
model

00:30:25,840 --> 00:30:30,320
in this way we could uh get some more of

00:30:28,000 --> 00:30:32,240
the advantages of acceleration

00:30:30,320 --> 00:30:33,760
at least at a lower level player and

00:30:32,240 --> 00:30:37,360
reduce

00:30:33,760 --> 00:30:41,039
the um the load

00:30:37,360 --> 00:30:42,799
so in order to do this uh we would want

00:30:41,039 --> 00:30:45,440
to kind of split this between

00:30:42,799 --> 00:30:47,600
uh control plane and data plane uh i use

00:30:45,440 --> 00:30:50,880
those terms reluctantly because

00:30:47,600 --> 00:30:52,720
uh the second we we say uh oh connection

00:30:50,880 --> 00:30:53,360
setup that's a control plane function

00:30:52,720 --> 00:30:54,799
and then

00:30:53,360 --> 00:30:56,640
somebody comes along and shows that we

00:30:54,799 --> 00:30:58,799
have a tcp syn attack

00:30:56,640 --> 00:31:01,200
so it turns out uh the connection

00:30:58,799 --> 00:31:03,760
setup's actually data plane

00:31:01,200 --> 00:31:05,840
meaning it's fast path but we still have

00:31:03,760 --> 00:31:08,640
some concept of this so for instance

00:31:05,840 --> 00:31:10,640
tcp timers and what have you could be

00:31:08,640 --> 00:31:13,120
running more of a control plane

00:31:10,640 --> 00:31:15,279
and then the data plane data path would

00:31:13,120 --> 00:31:18,480
be more of an optimized

00:31:15,279 --> 00:31:19,840
um data path so if we want to get to the

00:31:18,480 --> 00:31:21,760
hundreds of millions of packets per

00:31:19,840 --> 00:31:23,919
second going through tcp

00:31:21,760 --> 00:31:26,559
we really need uh this sort of

00:31:23,919 --> 00:31:29,600
optimizations and tcp to take advantage

00:31:26,559 --> 00:31:33,440
directly of hardware accelerations

00:31:29,600 --> 00:31:33,919
between these we would really want to

00:31:33,440 --> 00:31:38,720
have

00:31:33,919 --> 00:31:38,720
a tightly coupled almost

00:31:38,880 --> 00:31:43,039
asynchronous multi-processing system so

00:31:41,760 --> 00:31:46,080
between the control and

00:31:43,039 --> 00:31:47,120
the data plane have that shared state so

00:31:46,080 --> 00:31:50,559
this eliminates

00:31:47,120 --> 00:31:53,279
the uh problem of shadow state

00:31:50,559 --> 00:31:54,960
so control and data share the same tcp

00:31:53,279 --> 00:31:56,320
state for instance and they both can

00:31:54,960 --> 00:31:58,399
operate on it

00:31:56,320 --> 00:32:00,559
but there are different parts of the

00:31:58,399 --> 00:32:02,640
same stack

00:32:00,559 --> 00:32:04,880
optimize for different aspects of the

00:32:02,640 --> 00:32:06,720
stack and then that gets us into the

00:32:04,880 --> 00:32:07,360
need for message queues between these

00:32:06,720 --> 00:32:10,240
and

00:32:07,360 --> 00:32:11,919
other other sorts of cues so a lot of

00:32:10,240 --> 00:32:13,760
this i think could be

00:32:11,919 --> 00:32:15,919
also hardware accelerated for instance

00:32:13,760 --> 00:32:18,720
message queues would be nice to have

00:32:15,919 --> 00:32:18,720
have accelerated

00:32:19,760 --> 00:32:24,159
so the result of this uh this creates a

00:32:22,559 --> 00:32:27,519
much wider waist

00:32:24,159 --> 00:32:30,720
so the hardware can

00:32:27,519 --> 00:32:34,320
um provide access to granular ip

00:32:30,720 --> 00:32:36,320
block so now if it has a crypto function

00:32:34,320 --> 00:32:38,480
the data data plane for instance can

00:32:36,320 --> 00:32:41,360
call that crypto function directly

00:32:38,480 --> 00:32:43,360
if it provides some sort of hash

00:32:41,360 --> 00:32:46,640
acceleration

00:32:43,360 --> 00:32:48,080
computation the data plane can call that

00:32:46,640 --> 00:32:51,200
um etc

00:32:48,080 --> 00:32:52,480
so we've we've accomplished that uh and

00:32:51,200 --> 00:32:54,159
since we're moving the hardware

00:32:52,480 --> 00:32:57,279
interface much lower

00:32:54,159 --> 00:33:00,640
that also means removing the software

00:32:57,279 --> 00:33:01,679
which potentially is accessible to the

00:33:00,640 --> 00:33:05,360
stack

00:33:01,679 --> 00:33:08,559
much lower also so a lot of the

00:33:05,360 --> 00:33:10,159
things that we've talked about that a

00:33:08,559 --> 00:33:12,080
device would do for instance going back

00:33:10,159 --> 00:33:15,279
to the elder road case

00:33:12,080 --> 00:33:18,320
if we were able to program lro

00:33:15,279 --> 00:33:19,840
in simple c code uh but it runs at

00:33:18,320 --> 00:33:21,200
hardware speed that that's a huge

00:33:19,840 --> 00:33:22,799
advantage because now

00:33:21,200 --> 00:33:24,559
the stack can actually see what the

00:33:22,799 --> 00:33:26,799
algorithms are can see

00:33:24,559 --> 00:33:28,960
how the timers work and see how we deal

00:33:26,799 --> 00:33:30,640
with with packet holes

00:33:28,960 --> 00:33:33,519
has control over that when there's a bug

00:33:30,640 --> 00:33:34,799
we fix it so there's a huge advantage

00:33:33,519 --> 00:33:37,120
and i think a lot of this is already

00:33:34,799 --> 00:33:38,000
known through through the efforts to

00:33:37,120 --> 00:33:40,799
make devices more

00:33:38,000 --> 00:33:41,600
programmable but i think one aspect of

00:33:40,799 --> 00:33:44,720
that is we

00:33:41,600 --> 00:33:46,080
we eliminate this black box and once we

00:33:44,720 --> 00:33:48,720
do that that will open up

00:33:46,080 --> 00:33:51,440
more of the device capabilities to the

00:33:48,720 --> 00:33:51,440
rest of the stack

00:33:51,519 --> 00:33:59,039
uh with that um are there any questions

00:33:55,279 --> 00:34:02,480
okay uh so i did see one question

00:33:59,039 --> 00:34:07,279
white box approach uh only

00:34:02,480 --> 00:34:10,000
works with smartnix i think that's

00:34:07,279 --> 00:34:11,119
for the time being that's the obvious um

00:34:10,000 --> 00:34:13,599
entry point

00:34:11,119 --> 00:34:15,200
uh because smart necks um create this

00:34:13,599 --> 00:34:17,679
closed system

00:34:15,200 --> 00:34:19,119
but the the thing about the canonical

00:34:17,679 --> 00:34:22,639
and device driver model

00:34:19,119 --> 00:34:27,119
um it really is like 50 years old

00:34:22,639 --> 00:34:29,440
and we based ttys on it way back when

00:34:27,119 --> 00:34:30,560
so we've kind of evolved that model it's

00:34:29,440 --> 00:34:33,200
quite embedded

00:34:30,560 --> 00:34:34,079
and it does have a lot of usefulness

00:34:33,200 --> 00:34:36,399
because it

00:34:34,079 --> 00:34:37,760
it does allow us to support so many so

00:34:36,399 --> 00:34:40,800
many drivers

00:34:37,760 --> 00:34:43,119
fundamentally changing that model on the

00:34:40,800 --> 00:34:49,520
server side is going to be

00:34:43,119 --> 00:34:51,200
really uh really tricky

00:34:49,520 --> 00:34:53,359
what kind of functional interface we

00:34:51,200 --> 00:34:55,919
want to use memory map dma for user

00:34:53,359 --> 00:34:58,560
space app

00:34:55,919 --> 00:35:00,560
and move all hardware specific code to

00:34:58,560 --> 00:35:03,440
user app

00:35:00,560 --> 00:35:05,920
that's an interesting question and i

00:35:03,440 --> 00:35:05,920
think there's

00:35:06,000 --> 00:35:13,359
a couple of ways to to look at that

00:35:09,920 --> 00:35:16,000
so hardware specific code

00:35:13,359 --> 00:35:17,200
let's assume that means the programming

00:35:16,000 --> 00:35:20,480
for device

00:35:17,200 --> 00:35:25,440
of some fashion whether that be

00:35:20,480 --> 00:35:28,640
some sort of c code offload dbpf p4

00:35:25,440 --> 00:35:29,280
that is clearly the code itself is

00:35:28,640 --> 00:35:31,599
written

00:35:29,280 --> 00:35:33,680
by by users and we want the model where

00:35:31,599 --> 00:35:36,160
the users can download

00:35:33,680 --> 00:35:37,760
uh the code into the hardware do it and

00:35:36,160 --> 00:35:40,480
safely provide the environment and the

00:35:37,760 --> 00:35:40,480
hooks for that

00:35:40,880 --> 00:35:47,839
so i don't think it's necessarily a

00:35:44,640 --> 00:35:49,839
memory mapping from user space

00:35:47,839 --> 00:35:51,200
but it's more there could be a download

00:35:49,839 --> 00:35:52,560
function so the assumption there is

00:35:51,200 --> 00:35:55,440
programming

00:35:52,560 --> 00:35:57,040
is is not a continuous thing we don't

00:35:55,440 --> 00:35:58,720
have to reprogram the device for every

00:35:57,040 --> 00:36:01,680
new flow for instance

00:35:58,720 --> 00:36:02,720
so if we can program the device once

00:36:01,680 --> 00:36:05,920
that works

00:36:02,720 --> 00:36:05,920
but we do need still

00:36:06,160 --> 00:36:09,200
some high performance interfaces between

00:36:08,320 --> 00:36:12,079
the

00:36:09,200 --> 00:36:13,280
the host and the device i'm hoping that

00:36:12,079 --> 00:36:16,240
that cxl

00:36:13,280 --> 00:36:18,560
um the emergence of cxl devices help

00:36:16,240 --> 00:36:18,560
with that

00:36:18,800 --> 00:36:22,480
can you give an example of a function on

00:36:20,640 --> 00:36:25,520
our facebook accelerators

00:36:22,480 --> 00:36:29,440
uh yes

00:36:25,520 --> 00:36:32,640
so i will be talking about uh bp4

00:36:29,440 --> 00:36:34,880
on monday and

00:36:32,640 --> 00:36:36,560
that is uh write c code and get it

00:36:34,880 --> 00:36:37,839
accelerated that's that's kind of the

00:36:36,560 --> 00:36:40,000
goal

00:36:37,839 --> 00:36:40,880
um and it has to be a little more than c

00:36:40,000 --> 00:36:44,079
code it

00:36:40,880 --> 00:36:47,440
it needs to be c code designed

00:36:44,079 --> 00:36:51,200
for that sort acceleration

00:36:47,440 --> 00:36:52,079
and the the code can be written by the

00:36:51,200 --> 00:36:55,839
user

00:36:52,079 --> 00:36:59,760
or or not uh what we will need there is

00:36:55,839 --> 00:37:01,760
sort of a common common interface into

00:36:59,760 --> 00:37:04,400
these device functions

00:37:01,760 --> 00:37:06,160
and what i'm hoping there is that if we

00:37:04,400 --> 00:37:08,560
can get this to be a software problem

00:37:06,160 --> 00:37:12,000
where we're writing code

00:37:08,560 --> 00:37:12,640
that it really becomes a compiler

00:37:12,000 --> 00:37:14,960
problem

00:37:12,640 --> 00:37:16,480
in order to translate that code into

00:37:14,960 --> 00:37:20,560
what the hardware

00:37:16,480 --> 00:37:23,760
accelerates and completely eliminate

00:37:20,560 --> 00:37:27,599
the need for like sdks

00:37:23,760 --> 00:37:28,880
and even the npu model so we have the

00:37:27,599 --> 00:37:31,200
the compiler handles

00:37:28,880 --> 00:37:31,920
that so we write a plain somewhat

00:37:31,200 --> 00:37:35,359
generic c

00:37:31,920 --> 00:37:36,960
code that is specialized for the

00:37:35,359 --> 00:37:40,079
networking problem

00:37:36,960 --> 00:37:43,760
with things like acceleration and when

00:37:40,079 --> 00:37:46,560
the compiler uh sees for instance uh

00:37:43,760 --> 00:37:47,839
a call to the encrypt data block

00:37:46,560 --> 00:37:49,680
function

00:37:47,839 --> 00:37:51,280
i can map that into whatever

00:37:49,680 --> 00:37:55,119
instructions it needs to

00:37:51,280 --> 00:37:56,880
uh in the target are you promoting

00:37:55,119 --> 00:37:58,240
different device types that connect to

00:37:56,880 --> 00:37:59,280
and bypass different layers of the

00:37:58,240 --> 00:38:02,400
kernel stack

00:37:59,280 --> 00:38:05,839
uh not really um

00:38:02,400 --> 00:38:08,000
i think uh this this has a little less

00:38:05,839 --> 00:38:11,119
to do with a kernel stack

00:38:08,000 --> 00:38:13,520
um it really is i think we need to think

00:38:11,119 --> 00:38:16,240
in terms of the stack

00:38:13,520 --> 00:38:18,400
so for instance in the control plane

00:38:16,240 --> 00:38:22,000
data plane

00:38:18,400 --> 00:38:25,040
model if we prefer split in those

00:38:22,000 --> 00:38:25,760
uh if if you followed for instance tcp

00:38:25,040 --> 00:38:28,560
offload

00:38:25,760 --> 00:38:30,000
engines and why they basically failed it

00:38:28,560 --> 00:38:32,400
was because

00:38:30,000 --> 00:38:33,839
they tried to hard code a full tcp stack

00:38:32,400 --> 00:38:37,440
in the hardware

00:38:33,839 --> 00:38:40,480
uh had nothing to do with any normal

00:38:37,440 --> 00:38:43,200
c stacks or or networking stacks and

00:38:40,480 --> 00:38:44,880
became very much

00:38:43,200 --> 00:38:47,119
kind of proprietary so we couldn't

00:38:44,880 --> 00:38:50,400
change them we couldn't program them

00:38:47,119 --> 00:38:51,359
so if i was doing this i obviously want

00:38:50,400 --> 00:38:54,320
to leverage

00:38:51,359 --> 00:38:54,720
the linux tcp stack as much as possible

00:38:54,320 --> 00:38:56,320
so

00:38:54,720 --> 00:38:58,560
all of the work we've done in congestion

00:38:56,320 --> 00:39:01,520
control

00:38:58,560 --> 00:39:02,720
connection management statistics i'd

00:39:01,520 --> 00:39:04,880
want to leverage that

00:39:02,720 --> 00:39:07,280
but what i want is i want to take out

00:39:04,880 --> 00:39:11,280
kind of the the fast data path

00:39:07,280 --> 00:39:13,599
um for tcp the the part where

00:39:11,280 --> 00:39:15,119
back in the 1990s van jacobson had a

00:39:13,599 --> 00:39:16,480
famous

00:39:15,119 --> 00:39:19,040
blurb where he said he could he could

00:39:16,480 --> 00:39:20,960
implement tcp receive and 30 cpu

00:39:19,040 --> 00:39:23,280
instructions

00:39:20,960 --> 00:39:24,800
take that out abstract that out that's

00:39:23,280 --> 00:39:27,280
the fast data path so

00:39:24,800 --> 00:39:29,200
so when packets are coming in order

00:39:27,280 --> 00:39:31,599
without a problem

00:39:29,200 --> 00:39:34,880
then we can fly we can do our 100

00:39:31,599 --> 00:39:38,079
million packets per second over tcp

00:39:34,880 --> 00:39:41,119
that presumes that we have a

00:39:38,079 --> 00:39:44,720
high speed connection lookup we have uh

00:39:41,119 --> 00:39:46,240
high-speed parsers uh it does assume a

00:39:44,720 --> 00:39:47,200
lot a lot of different things but in the

00:39:46,240 --> 00:39:48,960
end of the day

00:39:47,200 --> 00:39:51,040
we still retain the fact that this is

00:39:48,960 --> 00:39:52,880
still part of the linux stack in some

00:39:51,040 --> 00:39:55,040
fashion

00:39:52,880 --> 00:39:57,839
um even if it's even if it's kind of

00:39:55,040 --> 00:40:00,960
co-located on different cpu

00:39:57,839 --> 00:40:02,560
it still interacts with that but the the

00:40:00,960 --> 00:40:06,240
model allows us to

00:40:02,560 --> 00:40:10,560
to put the code in such that um

00:40:06,240 --> 00:40:13,599
it is accelerated and there was uh

00:40:10,560 --> 00:40:16,240
some kind of pointers to this um

00:40:13,599 --> 00:40:18,240
a while back i posed a thing called txtp

00:40:16,240 --> 00:40:20,240
transport xdp

00:40:18,240 --> 00:40:21,440
where the idea was that we push some of

00:40:20,240 --> 00:40:25,119
the

00:40:21,440 --> 00:40:28,160
uh transport functionality down into xdp

00:40:25,119 --> 00:40:31,040
but also that we expose

00:40:28,160 --> 00:40:32,960
the the output from something like xdp

00:40:31,040 --> 00:40:35,760
at a much higher layer

00:40:32,960 --> 00:40:37,200
so for instance in the case of tcp i'd

00:40:35,760 --> 00:40:40,880
like to see that

00:40:37,200 --> 00:40:43,440
in the device in a programmable device

00:40:40,880 --> 00:40:43,920
we can do all of the ip processing on

00:40:43,440 --> 00:40:46,480
the

00:40:43,920 --> 00:40:47,520
packet we can do all the tcp processing

00:40:46,480 --> 00:40:51,200
we can actually do

00:40:47,520 --> 00:40:54,400
the connection lookup and get the result

00:40:51,200 --> 00:40:57,359
all of that can be done without needing

00:40:54,400 --> 00:41:00,480
any state without any needing any of the

00:40:57,359 --> 00:41:02,160
advanced tcp protocol algorithms once we

00:41:00,480 --> 00:41:04,319
have all the information

00:41:02,160 --> 00:41:05,280
i'd like to jump straight into the stack

00:41:04,319 --> 00:41:07,680
processing

00:41:05,280 --> 00:41:09,359
at the receive tcp packet in an

00:41:07,680 --> 00:41:11,440
established state

00:41:09,359 --> 00:41:13,040
the device gave us everything if we can

00:41:11,440 --> 00:41:16,560
trust the device because

00:41:13,040 --> 00:41:18,000
it's white box we can trust that it gave

00:41:16,560 --> 00:41:19,359
us the right thing and and

00:41:18,000 --> 00:41:21,200
it's part of the stack so we don't have

00:41:19,359 --> 00:41:24,319
to worry about the the

00:41:21,200 --> 00:41:25,440
um trust model so i think that from that

00:41:24,319 --> 00:41:27,520
point of view that's what i'd like to

00:41:25,440 --> 00:41:30,800
see

00:41:27,520 --> 00:41:32,560
uh so yeah uh so i'm very familiar with

00:41:30,800 --> 00:41:35,920
uh the metronome models

00:41:32,560 --> 00:41:39,680
uh p4 and c uh like i said uh let's

00:41:35,920 --> 00:41:41,440
um also talk about bp4 i think it's uh

00:41:39,680 --> 00:41:43,280
in some sense it kind of combines the

00:41:41,440 --> 00:41:46,720
best with these

00:41:43,280 --> 00:41:47,200
what was that thomas i think it was next

00:41:46,720 --> 00:41:50,480
actually

00:41:47,200 --> 00:41:51,839
before that question okay okay so can i

00:41:50,480 --> 00:41:53,359
make i don't know how much how are you

00:41:51,839 --> 00:41:54,640
doing on time i can ask a question or

00:41:53,359 --> 00:41:56,640
just let it off

00:41:54,640 --> 00:41:59,520
uh i think i i need to wrap it up and

00:41:56,640 --> 00:42:02,720
once maybe one more question

00:41:59,520 --> 00:42:05,040
uh yeah so in regards to the you

00:42:02,720 --> 00:42:05,839
you mentioned this hash i think you saw

00:42:05,040 --> 00:42:08,400
those patches

00:42:05,839 --> 00:42:10,480
on the list uh first of all there's a

00:42:08,400 --> 00:42:14,880
talk tomorrow the tcu workshop on this

00:42:10,480 --> 00:42:17,119
it's a very interesting uh approach

00:42:14,880 --> 00:42:18,319
what it ends up looking like is you have

00:42:17,119 --> 00:42:20,319
a hierarchical model

00:42:18,319 --> 00:42:21,760
the nick is you can look at the nick as

00:42:20,319 --> 00:42:25,200
a totally different host

00:42:21,760 --> 00:42:27,760
or different node in the in the graph

00:42:25,200 --> 00:42:28,800
of packet processing you have to program

00:42:27,760 --> 00:42:30,319
it differently

00:42:28,800 --> 00:42:33,119
if you're programming you have to know

00:42:30,319 --> 00:42:34,400
what that 32-bit hash means

00:42:33,119 --> 00:42:36,560
when uh when you receive it in the

00:42:34,400 --> 00:42:37,839
kernel if it says what what does one two

00:42:36,560 --> 00:42:39,760
three four mean

00:42:37,839 --> 00:42:41,920
will depend on what computation happened

00:42:39,760 --> 00:42:43,760
in this on the nick

00:42:41,920 --> 00:42:45,040
if cpr says that's probably well

00:42:43,760 --> 00:42:47,119
understood

00:42:45,040 --> 00:42:49,280
uh even with rss you can probably mix up

00:42:47,119 --> 00:42:51,760
the salt or whatever the uh

00:42:49,280 --> 00:42:53,200
the keys are and one two three four

00:42:51,760 --> 00:42:55,839
could have very different meanings as to

00:42:53,200 --> 00:42:59,760
what tuple is actually being matched

00:42:55,839 --> 00:43:02,720
so i i think the model to scale

00:42:59,760 --> 00:43:03,280
uh you you'd have to do the separation

00:43:02,720 --> 00:43:06,480
and

00:43:03,280 --> 00:43:07,200
a hierarchical model uh with a different

00:43:06,480 --> 00:43:09,359
computer

00:43:07,200 --> 00:43:10,480
just think of it as a network basically

00:43:09,359 --> 00:43:13,200
you know

00:43:10,480 --> 00:43:14,800
uh to reduce the amount of effort or

00:43:13,200 --> 00:43:15,599
computational effort to be done on the

00:43:14,800 --> 00:43:19,119
host

00:43:15,599 --> 00:43:20,640
you need to um to

00:43:19,119 --> 00:43:22,560
tell the smart nick what you want it to

00:43:20,640 --> 00:43:23,760
match give you a 32-bit idea that is

00:43:22,560 --> 00:43:27,839
much faster look up

00:43:23,760 --> 00:43:27,839
or parsing on

00:43:28,079 --> 00:43:35,760
so i do have so with regards to tc

00:43:32,800 --> 00:43:37,760
workshop i do have some concepts about

00:43:35,760 --> 00:43:40,800
generic tc flower

00:43:37,760 --> 00:43:41,839
which i can bring up there which extends

00:43:40,800 --> 00:43:43,200
this work

00:43:41,839 --> 00:43:45,520
so one of the one of the problems that

00:43:43,200 --> 00:43:48,960
we have with tc flower is

00:43:45,520 --> 00:43:52,319
it's based on the kernel flow detector

00:43:48,960 --> 00:43:54,720
which as we know is quite fixed and

00:43:52,319 --> 00:43:56,240
one of the side effects especially bp4 i

00:43:54,720 --> 00:43:59,200
want to undo that

00:43:56,240 --> 00:44:00,880
um staticness and make it make it more

00:43:59,200 --> 00:44:03,280
dynamic

00:44:00,880 --> 00:44:04,800
on the hash that's an interesting

00:44:03,280 --> 00:44:07,920
problem in itself

00:44:04,800 --> 00:44:08,800
it's one of the requests that we had in

00:44:07,920 --> 00:44:13,119
some of the

00:44:08,800 --> 00:44:15,440
xdp advanced xdp discussions

00:44:13,119 --> 00:44:17,599
it would be really nice if the device

00:44:15,440 --> 00:44:20,839
could return not just a hash

00:44:17,599 --> 00:44:24,960
but could return a unique token per

00:44:20,839 --> 00:44:27,680
flow and and i think thinking about it

00:44:24,960 --> 00:44:28,720
the the obvious way to do that is well

00:44:27,680 --> 00:44:31,920
we need to create

00:44:28,720 --> 00:44:36,400
a flow state in the device and then

00:44:31,920 --> 00:44:39,920
associate that flow state with um maybe

00:44:36,400 --> 00:44:40,960
uh maybe a random value or it could even

00:44:39,920 --> 00:44:42,800
be

00:44:40,960 --> 00:44:46,160
the uh the pointer to the connection

00:44:42,800 --> 00:44:48,400
block um state on on the host

00:44:46,160 --> 00:44:49,359
that that would work but that gets us

00:44:48,400 --> 00:44:51,680
another problem

00:44:49,359 --> 00:44:52,560
we have to have all this flow state so i

00:44:51,680 --> 00:44:53,760
was actually thinking

00:44:52,560 --> 00:44:56,160
there might be an opportunity to do

00:44:53,760 --> 00:44:57,760
something simple here which i haven't

00:44:56,160 --> 00:44:59,280
had time to work on but what if we just

00:44:57,760 --> 00:45:02,000
simply

00:44:59,280 --> 00:45:04,480
went instead of using 32-bit hashes went

00:45:02,000 --> 00:45:06,880
to 64-bit hashes

00:45:04,480 --> 00:45:09,520
in the device so if we have a full

00:45:06,880 --> 00:45:12,720
64-bit hash

00:45:09,520 --> 00:45:15,839
and we give that to the host

00:45:12,720 --> 00:45:17,119
the odds of a collision between two

00:45:15,839 --> 00:45:19,599
flows

00:45:17,119 --> 00:45:20,720
that too unrelated flows with a 64-bit

00:45:19,599 --> 00:45:24,319
hash

00:45:20,720 --> 00:45:25,839
becomes like once every 100 years or

00:45:24,319 --> 00:45:28,240
something like that

00:45:25,839 --> 00:45:29,760
whereas with the 32-bit hash it was once

00:45:28,240 --> 00:45:31,520
every month

00:45:29,760 --> 00:45:34,079
um assuming like a million flows per

00:45:31,520 --> 00:45:37,440
device so basically we hit the birthday

00:45:34,079 --> 00:45:39,119
birthday paradox so uh

00:45:37,440 --> 00:45:40,800
i'm kind of i'm kind of still wondering

00:45:39,119 --> 00:45:42,800
about that if

00:45:40,800 --> 00:45:44,000
if we can get away with uh doubling the

00:45:42,800 --> 00:45:45,680
hash size

00:45:44,000 --> 00:45:47,440
that substantially increases the

00:45:45,680 --> 00:45:48,079
uniqueness of these such that we might

00:45:47,440 --> 00:45:51,520
be actually

00:45:48,079 --> 00:45:54,800
able to use these as like

00:45:51,520 --> 00:45:56,880
almost guaranteed unique uh identifiers

00:45:54,800 --> 00:45:58,560
of the connection up to maybe some

00:45:56,880 --> 00:46:00,480
most secure secure applications

00:45:58,560 --> 00:46:01,839
obviously but

00:46:00,480 --> 00:46:03,680
so yeah i think there's a lot of

00:46:01,839 --> 00:46:06,480
generally a lot of opportunity here

00:46:03,680 --> 00:46:08,160
the topic that we want to talk about is

00:46:06,480 --> 00:46:11,280
um

00:46:08,160 --> 00:46:15,359
uh you know

00:46:11,280 --> 00:46:17,119
some uh different view on switchdev

00:46:15,359 --> 00:46:18,480
and portrait presenters and stuff like

00:46:17,119 --> 00:46:21,839
that

00:46:18,480 --> 00:46:23,200
uh and and this idea came to us

00:46:21,839 --> 00:46:25,280
from the feedback that we got from

00:46:23,200 --> 00:46:27,920
community uh on

00:46:25,280 --> 00:46:28,640
certain patches that were posted like in

00:46:27,920 --> 00:46:32,400
the last

00:46:28,640 --> 00:46:35,440
month or so i would say um and so

00:46:32,400 --> 00:46:37,920
um you know we first want to explain

00:46:35,440 --> 00:46:39,280
what is the challenge that we are having

00:46:37,920 --> 00:46:43,119
and then

00:46:39,280 --> 00:46:44,330
the solution space um

00:46:43,119 --> 00:46:49,520
uh steve next slide

00:46:44,330 --> 00:46:52,480
[Music]

00:46:49,520 --> 00:46:54,160
okay so um with that i'm going to let

00:46:52,480 --> 00:46:54,800
steve do the talking here and then i

00:46:54,160 --> 00:46:58,240
will

00:46:54,800 --> 00:47:00,800
come back a little later uh with some

00:46:58,240 --> 00:47:00,800
discussion

00:47:02,079 --> 00:47:05,839
okay so uh i'll first like recap the

00:47:05,280 --> 00:47:08,400
problem

00:47:05,839 --> 00:47:09,119
we were freezing because that's all the

00:47:08,400 --> 00:47:12,800
old

00:47:09,119 --> 00:47:16,319
and basic uh before we sending the patch

00:47:12,800 --> 00:47:19,200
and so if we are revisiting the problem

00:47:16,319 --> 00:47:19,760
we were facing um mainly we have three

00:47:19,200 --> 00:47:22,480
problems

00:47:19,760 --> 00:47:24,079
so the first of all is we are trying to

00:47:22,480 --> 00:47:26,400
enable the device for some

00:47:24,079 --> 00:47:28,720
work workload and the workload is

00:47:26,400 --> 00:47:31,200
typically to steering the traffic

00:47:28,720 --> 00:47:31,920
and so we know we we want to offload the

00:47:31,200 --> 00:47:33,520
flow

00:47:31,920 --> 00:47:36,000
uh like program of the flow on the

00:47:33,520 --> 00:47:39,520
device and the steering traffic

00:47:36,000 --> 00:47:40,079
but the traffic is uh uh like uh it's a

00:47:39,520 --> 00:47:43,040
uh

00:47:40,079 --> 00:47:45,440
it's very telecom protocols and even

00:47:43,040 --> 00:47:47,599
some protocols is customized protocols

00:47:45,440 --> 00:47:49,680
which means that that is not uncertain

00:47:47,599 --> 00:47:52,800
that's the uncertain particles

00:47:49,680 --> 00:47:56,000
and there um so yeah as tom said

00:47:52,800 --> 00:47:57,040
so in the linux tc support fix uh fixed

00:47:56,000 --> 00:48:00,480
fields

00:47:57,040 --> 00:48:02,880
but that means that we need upgraded or

00:48:00,480 --> 00:48:03,680
updates or modified kind of frequently

00:48:02,880 --> 00:48:07,599
and they're

00:48:03,680 --> 00:48:10,640
enforced to uh update the kernel

00:48:07,599 --> 00:48:12,480
because our application needs to need

00:48:10,640 --> 00:48:15,359
that function

00:48:12,480 --> 00:48:18,400
and the last one is even um because it's

00:48:15,359 --> 00:48:18,400
going to address some

00:48:18,480 --> 00:48:22,400
data plan functions so but you know in

00:48:21,440 --> 00:48:24,720
terms of their

00:48:22,400 --> 00:48:26,480
flow offload you know um they plan

00:48:24,720 --> 00:48:29,440
function need to resolve their

00:48:26,480 --> 00:48:30,160
slow pass exception and then update the

00:48:29,440 --> 00:48:33,760
flow

00:48:30,160 --> 00:48:34,720
so the flow update rate becomes higher

00:48:33,760 --> 00:48:37,839
and higher

00:48:34,720 --> 00:48:40,240
then that comes about the third problems

00:48:37,839 --> 00:48:41,119
so that's the three fundamental problem

00:48:40,240 --> 00:48:44,480
we are facing

00:48:41,119 --> 00:48:46,079
if we want to upload photos and then we

00:48:44,480 --> 00:48:49,680
try to solve this right

00:48:46,079 --> 00:48:52,400
and there are uh in history also like

00:48:49,680 --> 00:48:53,119
the the most straightforward way is we

00:48:52,400 --> 00:48:56,720
we take

00:48:53,119 --> 00:48:59,839
the entire device uh from kernel like um

00:48:56,720 --> 00:49:02,800
like we are using dbk to uh

00:48:59,839 --> 00:49:03,359
like take the full functional pf and

00:49:02,800 --> 00:49:06,319
enable

00:49:03,359 --> 00:49:08,640
everything data pass control parts and

00:49:06,319 --> 00:49:10,400
forward workload to enable that

00:49:08,640 --> 00:49:12,240
that is a good playground for us to

00:49:10,400 --> 00:49:15,359
explore the common patterns

00:49:12,240 --> 00:49:16,000
and the summarized sites but there's uh

00:49:15,359 --> 00:49:18,720
the most

00:49:16,000 --> 00:49:19,119
significant cause is uh you we all lose

00:49:18,720 --> 00:49:21,520
their

00:49:19,119 --> 00:49:22,480
holster network connect uh connection

00:49:21,520 --> 00:49:25,520
manageability

00:49:22,480 --> 00:49:26,000
and the stable access so this is not

00:49:25,520 --> 00:49:29,040
good

00:49:26,000 --> 00:49:31,119
for for any of the production so

00:49:29,040 --> 00:49:32,319
we are trying uh trying that better

00:49:31,119 --> 00:49:35,599
solution is like we

00:49:32,319 --> 00:49:38,640
always uh like uh you know have their

00:49:35,599 --> 00:49:41,200
color uh to take over the pf

00:49:38,640 --> 00:49:41,839
and their application so here the

00:49:41,200 --> 00:49:44,480
control

00:49:41,839 --> 00:49:46,559
application is relative so this is not a

00:49:44,480 --> 00:49:50,160
really control plan application

00:49:46,559 --> 00:49:53,440
when we have a data application

00:49:50,160 --> 00:49:55,440
when we offload the flows sharing and

00:49:53,440 --> 00:49:57,920
the forwarding logic into hardware

00:49:55,440 --> 00:49:59,440
then the application remains application

00:49:57,920 --> 00:50:01,760
is take over the exception

00:49:59,440 --> 00:50:04,000
and handle the slow pass so on that

00:50:01,760 --> 00:50:06,640
perspective we will call this

00:50:04,000 --> 00:50:06,640
control plan

00:50:07,920 --> 00:50:12,319
we we need we try to limit that

00:50:10,319 --> 00:50:15,920
application only on the vf

00:50:12,319 --> 00:50:18,640
on the trust vf but we expect it to

00:50:15,920 --> 00:50:19,920
program the steering flow for others

00:50:18,640 --> 00:50:22,720
because we want to

00:50:19,920 --> 00:50:23,440
redirect flows for the workloads for the

00:50:22,720 --> 00:50:26,559
other

00:50:23,440 --> 00:50:29,839
other vmf so

00:50:26,559 --> 00:50:32,880
um and there uh if we doing that

00:50:29,839 --> 00:50:36,160
so it shows that uh so any pro

00:50:32,880 --> 00:50:38,640
uh pre program the flows for pf traffic

00:50:36,160 --> 00:50:39,359
uh we will enforce it to infrastructure

00:50:38,640 --> 00:50:42,400
management

00:50:39,359 --> 00:50:45,119
and that will share kernel with other

00:50:42,400 --> 00:50:46,720
hoster applications agents and etc

00:50:45,119 --> 00:50:48,880
that's for the management

00:50:46,720 --> 00:50:50,160
infrastructure management and then we

00:50:48,880 --> 00:50:53,440
expect the problem

00:50:50,160 --> 00:50:56,400
uh to program that advanced

00:50:53,440 --> 00:50:57,359
flows for um from that assigned the

00:50:56,400 --> 00:51:00,720
trust vf

00:50:57,359 --> 00:51:04,559
uh for those uh cross-function traffic

00:51:00,720 --> 00:51:08,880
that's for uh network applications

00:51:04,559 --> 00:51:10,400
and their monster processing hardware

00:51:08,880 --> 00:51:14,400
assistant

00:51:10,400 --> 00:51:17,040
and that is how each cooperative

00:51:14,400 --> 00:51:18,319
problems we we do want to kind of to

00:51:17,040 --> 00:51:22,319
manage the device

00:51:18,319 --> 00:51:24,720
and maintain their uh like stability

00:51:22,319 --> 00:51:26,079
manageability but we want to launch our

00:51:24,720 --> 00:51:29,040
network application

00:51:26,079 --> 00:51:30,000
the application is for like uh for the

00:51:29,040 --> 00:51:33,599
next slice like

00:51:30,000 --> 00:51:36,319
i take up like this as a quick sample so

00:51:33,599 --> 00:51:36,880
uh this is not like their gateway in

00:51:36,319 --> 00:51:40,319
their

00:51:36,880 --> 00:51:40,800
uh wireless edge so basically this is

00:51:40,319 --> 00:51:44,240
our

00:51:40,800 --> 00:51:48,079
like multi uh uh uh multi

00:51:44,240 --> 00:51:51,280
service uh edge computing so so on that

00:51:48,079 --> 00:51:53,839
part we see there's a node our network

00:51:51,280 --> 00:51:54,800
meter box which is a upf upfaster

00:51:53,839 --> 00:51:56,960
gateway

00:51:54,800 --> 00:51:59,040
and then it will redirect traffic so

00:51:56,960 --> 00:52:02,480
there's a different kind of traffic so

00:51:59,040 --> 00:52:05,520
for the control plan uh nodes it's m4

00:52:02,480 --> 00:52:08,800
and then n6 is our typical uh

00:52:05,520 --> 00:52:12,319
for the data network and then

00:52:08,800 --> 00:52:15,280
it locally they have a local uh

00:52:12,319 --> 00:52:16,480
local data uh network local era data

00:52:15,280 --> 00:52:18,640
network to host

00:52:16,480 --> 00:52:20,559
a lot of applications this application

00:52:18,640 --> 00:52:22,160
not necessarily being a narrow function

00:52:20,559 --> 00:52:23,839
it could be a normal application for

00:52:22,160 --> 00:52:27,280
media processing for for

00:52:23,839 --> 00:52:27,920
video and etc so upfs are getting extra

00:52:27,280 --> 00:52:31,599
gateway

00:52:27,920 --> 00:52:32,400
so when on the mec platform comes to uh

00:52:31,599 --> 00:52:34,800
like

00:52:32,400 --> 00:52:36,640
when anyone takes our mec platform this

00:52:34,800 --> 00:52:39,040
is a normal nv platform you have

00:52:36,640 --> 00:52:40,559
an infrastructure for computing for

00:52:39,040 --> 00:52:42,559
networking for storage

00:52:40,559 --> 00:52:44,400
then you launch our launcher network

00:52:42,559 --> 00:52:45,599
narwhal application this is a upf

00:52:44,400 --> 00:52:50,400
gateway

00:52:45,599 --> 00:52:53,760
um then actually the entire platform

00:52:50,400 --> 00:52:56,400
delegates the data plan to the upf so

00:52:53,760 --> 00:52:57,119
when the ups start to like offload the

00:52:56,400 --> 00:52:59,599
flow to the

00:52:57,119 --> 00:53:00,640
to the hardware it needs to update the

00:52:59,599 --> 00:53:04,400
flow

00:53:00,640 --> 00:53:04,880
so the flow uh is not only to handle the

00:53:04,400 --> 00:53:08,480
packet

00:53:04,880 --> 00:53:11,359
belong to udpf itself um

00:53:08,480 --> 00:53:12,480
but also need to uh steering traffic

00:53:11,359 --> 00:53:15,920
across different

00:53:12,480 --> 00:53:18,720
uh notes none knows different center box

00:53:15,920 --> 00:53:19,599
to different applications in the sandbox

00:53:18,720 --> 00:53:23,200
so this is the

00:53:19,599 --> 00:53:26,960
like one example so um if we this upf

00:53:23,200 --> 00:53:29,440
um given our if we give our vf and

00:53:26,960 --> 00:53:32,559
assign a vf to this upf

00:53:29,440 --> 00:53:36,240
but these now functions

00:53:32,559 --> 00:53:40,240
need to program the traffic cluster

00:53:36,240 --> 00:53:42,800
so what uh you know we are bringing up

00:53:40,240 --> 00:53:46,000
here is uh you know

00:53:42,800 --> 00:53:47,920
steve explained the problem uh you know

00:53:46,000 --> 00:53:49,920
uh the discussion started on this patch

00:53:47,920 --> 00:53:52,480
series uh where

00:53:49,920 --> 00:53:54,079
uh you know uh we took a little bit of a

00:53:52,480 --> 00:53:56,800
different approach first

00:53:54,079 --> 00:54:00,319
and from that we brought in some

00:53:56,800 --> 00:54:00,319
learning as to like what we want to do

00:54:00,480 --> 00:54:03,599
we did not really introduce in this

00:54:02,640 --> 00:54:06,720
patch series

00:54:03,599 --> 00:54:08,720
any impact to the common framework uh pf

00:54:06,720 --> 00:54:10,800
kernel driver still remains

00:54:08,720 --> 00:54:12,400
the device has the device ownership and

00:54:10,800 --> 00:54:14,559
resolves any conflict

00:54:12,400 --> 00:54:17,040
and it just supports the negotiation of

00:54:14,559 --> 00:54:18,960
advanced flow programming capabilities

00:54:17,040 --> 00:54:20,079
uh and and uh you know talking to the

00:54:18,960 --> 00:54:24,000
device using

00:54:20,079 --> 00:54:25,040
sideband messages but you know uh you

00:54:24,000 --> 00:54:26,800
know based on

00:54:25,040 --> 00:54:28,160
the feedback we got from jakob there

00:54:26,800 --> 00:54:30,240
were some uh

00:54:28,160 --> 00:54:31,839
you know learnings that we took back and

00:54:30,240 --> 00:54:35,760
incorporated those

00:54:31,839 --> 00:54:38,799
uh what we believe is um uh

00:54:35,760 --> 00:54:42,480
if we were to take this and

00:54:38,799 --> 00:54:46,000
uh problem and uh you know

00:54:42,480 --> 00:54:48,079
run switch dev and uh tc framework on

00:54:46,000 --> 00:54:50,799
top of a trusted vf

00:54:48,079 --> 00:54:51,599
uh it will solve at least few of our

00:54:50,799 --> 00:54:54,640
problems

00:54:51,599 --> 00:54:57,760
so as follows right so um

00:54:54,640 --> 00:55:00,400
we will be able to i'll go from bottom

00:54:57,760 --> 00:55:01,760
because the third one is what gets

00:55:00,400 --> 00:55:03,280
addressed

00:55:01,760 --> 00:55:05,040
which is separation of the control plane

00:55:03,280 --> 00:55:06,960
kernel from hosting kernel

00:55:05,040 --> 00:55:08,960
which provides the independence and

00:55:06,960 --> 00:55:10,640
different rate of change

00:55:08,960 --> 00:55:12,640
uh between the two kernels because we

00:55:10,640 --> 00:55:15,760
want a stable kernel for the

00:55:12,640 --> 00:55:18,720
for the hosting uh purposes

00:55:15,760 --> 00:55:19,760
uh and and you know the hypervisor

00:55:18,720 --> 00:55:22,240
running there

00:55:19,760 --> 00:55:23,440
but we want a much higher rate of change

00:55:22,240 --> 00:55:26,400
on the kernel

00:55:23,440 --> 00:55:27,440
uh you know taking the latest kernel

00:55:26,400 --> 00:55:30,480
patches

00:55:27,440 --> 00:55:32,319
for where the slow path or the exception

00:55:30,480 --> 00:55:34,319
path data plane runs and the control

00:55:32,319 --> 00:55:37,680
application runs um

00:55:34,319 --> 00:55:39,760
i mean as tom uh pointed out it's still

00:55:37,680 --> 00:55:41,760
data plane there it's not really

00:55:39,760 --> 00:55:43,520
a control plane it's just the control

00:55:41,760 --> 00:55:46,160
plane application that is running in

00:55:43,520 --> 00:55:46,160
that kernel

00:55:46,319 --> 00:55:51,280
so that definitely gets solved um

00:55:49,359 --> 00:55:53,599
if we run the switch dev and portrait

00:55:51,280 --> 00:55:57,119
presenter on top of a trusted vf

00:55:53,599 --> 00:56:00,319
uh what doesn't get solved is um

00:55:57,119 --> 00:56:02,319
uh you know right now we are

00:56:00,319 --> 00:56:03,599
using tc flower in conjunction with

00:56:02,319 --> 00:56:07,280
switchdev and dc

00:56:03,599 --> 00:56:11,119
which relies on named fields uh does not

00:56:07,280 --> 00:56:12,240
really help with uh the new or unknown

00:56:11,119 --> 00:56:15,839
protocol problem

00:56:12,240 --> 00:56:19,200
and i think uh you know as uh

00:56:15,839 --> 00:56:21,920
tom proposes uh his tc generic

00:56:19,200 --> 00:56:23,599
uh solution in the later presentation i

00:56:21,920 --> 00:56:26,000
think that would be a good way

00:56:23,599 --> 00:56:27,040
to kind of uh move forward to address

00:56:26,000 --> 00:56:29,680
that problem

00:56:27,040 --> 00:56:30,559
uh so that uh you know the kernel kind

00:56:29,680 --> 00:56:33,680
of

00:56:30,559 --> 00:56:37,680
um uh the flow does this sector

00:56:33,680 --> 00:56:40,960
can actually be not fixed but

00:56:37,680 --> 00:56:43,520
adapts better uh to the to the

00:56:40,960 --> 00:56:46,240
you know different new protocols that

00:56:43,520 --> 00:56:50,480
that are being used

00:56:46,240 --> 00:56:53,839
and uh yeah name fields with tc flower

00:56:50,480 --> 00:56:57,440
is puts us in a very protocol

00:56:53,839 --> 00:57:00,799
dependent flow dress dissector and

00:56:57,440 --> 00:57:04,160
that can really hinder with um

00:57:00,799 --> 00:57:07,040
you know in in certain areas where

00:57:04,160 --> 00:57:07,520
protocol innovation is the key uh and

00:57:07,040 --> 00:57:11,119
then

00:57:07,520 --> 00:57:13,440
um there is the the

00:57:11,119 --> 00:57:14,640
the second problem which is really high

00:57:13,440 --> 00:57:17,839
flow programming rate

00:57:14,640 --> 00:57:18,640
from control plane um and this one is

00:57:17,839 --> 00:57:21,520
still not

00:57:18,640 --> 00:57:23,119
uh solved as far as we can see there are

00:57:21,520 --> 00:57:26,079
a lot of efforts going on

00:57:23,119 --> 00:57:26,400
uh and as far as i'm aware there is you

00:57:26,079 --> 00:57:30,400
know

00:57:26,400 --> 00:57:32,960
the afx dp for control plane there is uh

00:57:30,400 --> 00:57:34,480
enhance you know uh some work that was

00:57:32,960 --> 00:57:38,240
done in the last two years with

00:57:34,480 --> 00:57:40,079
uh you know from lots of folks to

00:57:38,240 --> 00:57:43,280
improve the dc performance itself

00:57:40,079 --> 00:57:45,119
for for uh for flow programming rate but

00:57:43,280 --> 00:57:48,319
it is still nowhere close to

00:57:45,119 --> 00:57:49,440
what is expected in these uh telco like

00:57:48,319 --> 00:57:51,680
environments where

00:57:49,440 --> 00:57:52,960
the rate of programming expectation is 1

00:57:51,680 --> 00:57:56,400
to 10 million flows

00:57:52,960 --> 00:57:59,760
uh flow rates and on uh you know from

00:57:56,400 --> 00:58:02,559
uh uh you know couple of cores

00:57:59,760 --> 00:58:03,359
and so so that's that's the you know

00:58:02,559 --> 00:58:06,720
still

00:58:03,359 --> 00:58:08,079
the area that we need to uh uh

00:58:06,720 --> 00:58:09,839
you know as a community we need to

00:58:08,079 --> 00:58:11,599
innovate uh

00:58:09,839 --> 00:58:13,119
uh but at the same time like you know we

00:58:11,599 --> 00:58:16,480
at least think this

00:58:13,119 --> 00:58:18,000
addresses uh the proposal addresses the

00:58:16,480 --> 00:58:20,160
separating the control plane

00:58:18,000 --> 00:58:22,640
or separating the slow path data plane

00:58:20,160 --> 00:58:25,359
from the fast path

00:58:22,640 --> 00:58:26,480
and and you know gives them different

00:58:25,359 --> 00:58:29,599
speeds of

00:58:26,480 --> 00:58:32,319
growth in terms of uh

00:58:29,599 --> 00:58:33,040
innovation because the innovation on the

00:58:32,319 --> 00:58:36,240
uh

00:58:33,040 --> 00:58:39,680
the control plane side is a lot uh

00:58:36,240 --> 00:58:41,920
higher than what is happening on the the

00:58:39,680 --> 00:58:44,559
hosting side where you know you you want

00:58:41,920 --> 00:58:47,760
more stability

00:58:44,559 --> 00:58:51,200
um steve let's go to the next slide

00:58:47,760 --> 00:58:53,119
so this is this is uh pretty much

00:58:51,200 --> 00:58:54,640
the separation that we are hoping so

00:58:53,119 --> 00:58:56,799
there is a switch dev

00:58:54,640 --> 00:58:58,240
and portrait present on top of a trusted

00:58:56,799 --> 00:59:00,160
vf

00:58:58,240 --> 00:59:01,359
and this is running either in a separate

00:59:00,160 --> 00:59:04,640
kernel or

00:59:01,359 --> 00:59:07,760
you know uh some other kind of isolation

00:59:04,640 --> 00:59:11,359
separate kernel really helps as i said

00:59:07,760 --> 00:59:12,240
um and and then we have uh the stable

00:59:11,359 --> 00:59:15,839
kernel

00:59:12,240 --> 00:59:20,000
which is uh uh you know providing

00:59:15,839 --> 00:59:23,280
uh you know the vms for uh

00:59:20,000 --> 00:59:25,119
either service appliances or for hosting

00:59:23,280 --> 00:59:28,400
purposes itself

00:59:25,119 --> 00:59:29,040
um and uh you know what is not really

00:59:28,400 --> 00:59:32,480
shown here

00:59:29,040 --> 00:59:33,440
is uh you know the stable host

00:59:32,480 --> 00:59:37,040
management

00:59:33,440 --> 00:59:40,640
pf uh the traffic rules for those

00:59:37,040 --> 00:59:43,200
are pre-programmed uh so that it is

00:59:40,640 --> 00:59:44,160
you always have your connectivity to the

00:59:43,200 --> 00:59:47,599
um

00:59:44,160 --> 00:59:50,799
to the host uh but the rest of the

00:59:47,599 --> 00:59:51,119
flow steering is is programmed through

00:59:50,799 --> 00:59:54,960
this

00:59:51,119 --> 00:59:58,319
uh trusted vf uh so that it can be

00:59:54,960 --> 01:00:01,119
uh quite flexible uh to decide what kind

00:59:58,319 --> 01:00:05,839
of traffic is going to the other vf's

01:00:01,119 --> 01:00:05,839
uh uh next slide steve

01:00:08,640 --> 01:00:15,200
okay so in conclusion uh what we want to

01:00:12,160 --> 01:00:17,520
say is delegate switch tab to trusted vf

01:00:15,200 --> 01:00:18,559
that runs separate control plane uh

01:00:17,520 --> 01:00:21,440
kernel

01:00:18,559 --> 01:00:21,760
or app uh plus application responsible

01:00:21,440 --> 01:00:23,440
for

01:00:21,760 --> 01:00:24,799
hardware offloading or using hardware

01:00:23,440 --> 01:00:28,079
acceleration

01:00:24,799 --> 01:00:30,960
um for both uh

01:00:28,079 --> 01:00:32,240
you know exception handling as well as

01:00:30,960 --> 01:00:36,480
for

01:00:32,240 --> 01:00:36,480
you know control plane rule programming

01:00:38,960 --> 01:00:45,119
and then

01:00:42,720 --> 01:00:46,079
uh we need to definitely address the

01:00:45,119 --> 01:00:49,040
performance and

01:00:46,079 --> 01:00:50,799
flexibility problem with kernel uh and

01:00:49,040 --> 01:00:53,200
uh

01:00:50,799 --> 01:00:54,880
as i mentioned xdp and ebpf efforts have

01:00:53,200 --> 01:00:58,720
helped for sure

01:00:54,880 --> 01:01:00,319
uh but that is not enough to solve the

01:00:58,720 --> 01:01:02,480
nf performance problem

01:01:00,319 --> 01:01:03,760
you know because as i said there is

01:01:02,480 --> 01:01:06,160
still um

01:01:03,760 --> 01:01:07,920
you know a magnitude of difference that

01:01:06,160 --> 01:01:12,480
is there over there

01:01:07,920 --> 01:01:12,480
and um uh

01:01:12,720 --> 01:01:16,880
the other part that i want to mention is

01:01:14,319 --> 01:01:19,599
uh you know although we say

01:01:16,880 --> 01:01:21,680
it's a control plane separation it's

01:01:19,599 --> 01:01:23,359
actually a separation of

01:01:21,680 --> 01:01:26,079
the data plane the data plane that is in

01:01:23,359 --> 01:01:30,240
the device and the data plane that is

01:01:26,079 --> 01:01:34,400
uh you know in the uh

01:01:30,240 --> 01:01:36,480
the kernel that is running on top of the

01:01:34,400 --> 01:01:38,319
in the vm that is running on top of the

01:01:36,480 --> 01:01:42,079
trusted bf

01:01:38,319 --> 01:01:44,640
so and that even though we call it a

01:01:42,079 --> 01:01:46,799
slow path it's kind of a

01:01:44,640 --> 01:01:48,000
oxymoron that's where the performance

01:01:46,799 --> 01:01:50,720
actually is needed

01:01:48,000 --> 01:01:52,000
so it's not really a slow path it's an

01:01:50,720 --> 01:01:55,280
exception path for sure

01:01:52,000 --> 01:01:58,400
and and that's the split data plane uh

01:01:55,280 --> 01:01:59,520
one that is going directly to the uh to

01:01:58,400 --> 01:02:03,039
the

01:01:59,520 --> 01:02:04,880
uh the vm uh from the device and the

01:02:03,039 --> 01:02:08,240
other that is going through

01:02:04,880 --> 01:02:09,039
uh these cores that are dedicated to

01:02:08,240 --> 01:02:11,520
this vm

01:02:09,039 --> 01:02:12,799
where your control plane application is

01:02:11,520 --> 01:02:16,400
running

01:02:12,799 --> 01:02:18,160
um yeah and

01:02:16,400 --> 01:02:20,559
the last named fields with these flower

01:02:18,160 --> 01:02:23,760
did not help in the space

01:02:20,559 --> 01:02:26,160
so generic dc i think you know tom is

01:02:23,760 --> 01:02:29,119
going to talk about it

01:02:26,160 --> 01:02:31,119
so our request is basically create a

01:02:29,119 --> 01:02:34,559
pathway first

01:02:31,119 --> 01:02:35,760
for supporting this model and then

01:02:34,559 --> 01:02:37,839
you know that will really help us

01:02:35,760 --> 01:02:41,599
contribute back to colonel uh

01:02:37,839 --> 01:02:44,160
when we have this pathway um

01:02:41,599 --> 01:02:44,799
to build upon so yeah so definitely the

01:02:44,160 --> 01:02:48,480
feedback

01:02:44,799 --> 01:02:51,680
really helped but then you know

01:02:48,480 --> 01:02:54,799
i think we still need uh

01:02:51,680 --> 01:02:57,440
parts of those patches to implement the

01:02:54,799 --> 01:02:57,440
separation

01:03:01,440 --> 01:03:04,880
uh that's pretty much it uh we can move

01:03:04,400 --> 01:03:07,359
to

01:03:04,880 --> 01:03:07,359
questions

01:03:08,079 --> 01:03:14,160
okay i'll set an example okay

01:03:11,599 --> 01:03:15,039
go ahead mute and then you turn on your

01:03:14,160 --> 01:03:18,960
video so that

01:03:15,039 --> 01:03:22,000
uh you can record it on youtube uh

01:03:18,960 --> 01:03:24,319
if i understand it correctly uh

01:03:22,000 --> 01:03:26,319
you are proposing this trusted vf

01:03:24,319 --> 01:03:28,000
there's only going to be one on the host

01:03:26,319 --> 01:03:31,119
or this

01:03:28,000 --> 01:03:32,880
what if you have multiple tenants yeah

01:03:31,119 --> 01:03:34,240
so i think for now the

01:03:32,880 --> 01:03:36,640
what we're looking at is a single

01:03:34,240 --> 01:03:40,000
trusted vf because

01:03:36,640 --> 01:03:43,119
we want uh you know single traffic

01:03:40,000 --> 01:03:46,000
controller let's just say that way

01:03:43,119 --> 01:03:48,319
there can be a case where you may have

01:03:46,000 --> 01:03:51,440
active failure work kind of situation

01:03:48,319 --> 01:03:53,280
uh but then at a time this is uh this is

01:03:51,440 --> 01:03:54,480
basically saying a single traffic

01:03:53,280 --> 01:03:57,680
controller

01:03:54,480 --> 01:04:01,200
is is is is uh less confusion and

01:03:57,680 --> 01:04:03,119
less skills i i was actually going to

01:04:01,200 --> 01:04:05,119
just make one comment to add to where

01:04:03,119 --> 01:04:06,240
jamal said right like in the case of a

01:04:05,119 --> 01:04:08,240
nick i think

01:04:06,240 --> 01:04:09,839
the one controller model makes a lot of

01:04:08,240 --> 01:04:11,839
sense but if you

01:04:09,839 --> 01:04:12,880
since this is in the switchdev context

01:04:11,839 --> 01:04:14,160
and you

01:04:12,880 --> 01:04:16,559
if you really are going to have a

01:04:14,160 --> 01:04:17,920
controlling vf which really is a pf

01:04:16,559 --> 01:04:19,839
function so it's sort of

01:04:17,920 --> 01:04:21,680
you want to delegate so you want to do a

01:04:19,839 --> 01:04:22,960
vf i get that but then i think you have

01:04:21,680 --> 01:04:25,359
to create that

01:04:22,960 --> 01:04:27,599
just like you have a vf to pf mapping

01:04:25,359 --> 01:04:30,559
function i think you will have to

01:04:27,599 --> 01:04:30,880
do much more and create a controlling bf

01:04:30,559 --> 01:04:33,760
to

01:04:30,880 --> 01:04:34,240
control vf mapping function and it could

01:04:33,760 --> 01:04:36,240
be a

01:04:34,240 --> 01:04:38,160
it has to be an end to end right it

01:04:36,240 --> 01:04:40,400
can't be one to n

01:04:38,160 --> 01:04:41,359
yeah so definitely that feedback is

01:04:40,400 --> 01:04:44,480
valid uh

01:04:41,359 --> 01:04:46,480
uh srjeet uh

01:04:44,480 --> 01:04:48,720
what we are doing right now i think it

01:04:46,480 --> 01:04:52,079
helps us to keep one controller

01:04:48,720 --> 01:04:55,280
but you know it it is something that

01:04:52,079 --> 01:04:58,160
uh we need to consider for you know uh

01:04:55,280 --> 01:04:59,119
future use cases where uh you know you

01:04:58,160 --> 01:05:02,240
might want to

01:04:59,119 --> 01:05:06,720
separate your uh traffic control

01:05:02,240 --> 01:05:10,160
functionality into uh you know uh

01:05:06,720 --> 01:05:13,280
you know multiple such um

01:05:10,160 --> 01:05:16,319
vms or containers whatever that uh

01:05:13,280 --> 01:05:20,240
do their pieces right so so yeah so

01:05:16,319 --> 01:05:21,680
i mean that's good feedback i will you

01:05:20,240 --> 01:05:22,880
know we'll have to think through it if

01:05:21,680 --> 01:05:25,599
there is a need

01:05:22,880 --> 01:05:25,599
for doing that

01:05:26,400 --> 01:05:29,599
so one other point on switchdev is that

01:05:29,200 --> 01:05:32,720
we

01:05:29,599 --> 01:05:36,079
are trying to not use the pf

01:05:32,720 --> 01:05:38,559
as a host in that device anymore

01:05:36,079 --> 01:05:40,319
it has its representer part so that it

01:05:38,559 --> 01:05:42,799
can be configured

01:05:40,319 --> 01:05:44,160
but that's the uplink part that's the

01:05:42,799 --> 01:05:47,920
cable part itself

01:05:44,160 --> 01:05:50,319
and not on that device on the host side

01:05:47,920 --> 01:05:52,400
if the host needs networking out of a

01:05:50,319 --> 01:05:55,039
switchdev it should be using a vf

01:05:52,400 --> 01:05:55,039
for itself

01:05:56,480 --> 01:06:00,400
you're saying reverse set the pf should

01:05:59,520 --> 01:06:02,240
be the one who

01:06:00,400 --> 01:06:03,520
which should be running the switch step

01:06:02,240 --> 01:06:07,280
and uh

01:06:03,520 --> 01:06:09,280
another vf should be uh providing the

01:06:07,280 --> 01:06:10,799
host connectivity is that

01:06:09,280 --> 01:06:12,880
did you say that sorry maybe i

01:06:10,799 --> 01:06:16,400
misunderstand

01:06:12,880 --> 01:06:17,920
if i got you right yes okay okay so i'll

01:06:16,400 --> 01:06:19,440
answer the question right why we cannot

01:06:17,920 --> 01:06:20,880
do that it's a chicken neck problem

01:06:19,440 --> 01:06:21,839
right if i use a vf for host

01:06:20,880 --> 01:06:25,280
connectivity

01:06:21,839 --> 01:06:25,839
the vf comes later than the pf and and

01:06:25,280 --> 01:06:28,640
and so

01:06:25,839 --> 01:06:30,400
uh i i the stable connectivity can only

01:06:28,640 --> 01:06:33,200
be achieved through a pf

01:06:30,400 --> 01:06:33,680
that exists before uh you know the egg

01:06:33,200 --> 01:06:35,760
is

01:06:33,680 --> 01:06:37,119
is born so the chicken has to be there

01:06:35,760 --> 01:06:40,400
so so so

01:06:37,119 --> 01:06:42,960
uh yeah so i we need that pf and we need

01:06:40,400 --> 01:06:44,319
fixed rules for directing the traffic to

01:06:42,960 --> 01:06:47,599
the pf so that

01:06:44,319 --> 01:06:49,359
you know uh it's its connectivity is

01:06:47,599 --> 01:06:52,160
always maintained

01:06:49,359 --> 01:06:54,319
and then the vf itself uh provides the

01:06:52,160 --> 01:06:55,359
flexibility of steering packets to other

01:06:54,319 --> 01:06:58,480
vf's

01:06:55,359 --> 01:07:00,160
right so so and and this uh you know the

01:06:58,480 --> 01:07:00,960
the issue with the control plane

01:07:00,160 --> 01:07:04,000
application

01:07:00,960 --> 01:07:06,240
is also this that as i said it iterates

01:07:04,000 --> 01:07:07,039
much faster rate than the rest of the

01:07:06,240 --> 01:07:10,160
stuff which

01:07:07,039 --> 01:07:13,200
needs to be stable plus uh you know you

01:07:10,160 --> 01:07:15,280
also have things like you know

01:07:13,200 --> 01:07:16,720
you want to do updates on that control

01:07:15,280 --> 01:07:20,079
plane application

01:07:16,720 --> 01:07:22,160
and for that uh reason it can have

01:07:20,079 --> 01:07:23,599
you know microseconds or milliseconds of

01:07:22,160 --> 01:07:25,200
uh you know

01:07:23,599 --> 01:07:27,200
new connectivity and that's perfectly

01:07:25,200 --> 01:07:29,359
okay for certain systems but

01:07:27,200 --> 01:07:31,440
losing connectivity to the server itself

01:07:29,359 --> 01:07:35,599
or the other vms is

01:07:31,440 --> 01:07:35,599
is not an option in most cases

01:07:40,720 --> 01:07:47,839
okay so um let's move on

01:07:44,559 --> 01:07:52,480
to uh some of the ques uh

01:07:47,839 --> 01:07:56,000
questions and open um mike

01:07:52,480 --> 01:07:58,240
so uh uh mache posed a question

01:07:56,000 --> 01:08:00,720
i can i can repeat it i think that it's

01:07:58,240 --> 01:08:03,280
pretty uh interesting

01:08:00,720 --> 01:08:05,200
so someone will answer the question what

01:08:03,280 --> 01:08:07,200
are the absolute minimum offloads a

01:08:05,200 --> 01:08:08,160
network adapter must support for good

01:08:07,200 --> 01:08:11,280
udp

01:08:08,160 --> 01:08:14,000
tcp performance

01:08:11,280 --> 01:08:16,319
i'm assuming that receive transmit

01:08:14,000 --> 01:08:19,679
checksum offload

01:08:16,319 --> 01:08:23,920
and scattergather optionally tso

01:08:19,679 --> 01:08:24,960
and more optionally hardware grow

01:08:23,920 --> 01:08:27,440
but it would be nice to get an

01:08:24,960 --> 01:08:29,520
explanation for why we still have

01:08:27,440 --> 01:08:30,640
brand new wi-fi chipsets with no

01:08:29,520 --> 01:08:33,040
offloads

01:08:30,640 --> 01:08:34,159
so i think there's a couple of um a

01:08:33,040 --> 01:08:38,080
couple of points there

01:08:34,159 --> 01:08:40,480
and i think the community um

01:08:38,080 --> 01:08:43,520
can answer a lot of that uh for the

01:08:40,480 --> 01:08:45,440
first part of that question

01:08:43,520 --> 01:08:46,960
um it's kind of a loaded question in a

01:08:45,440 --> 01:08:49,440
sense right so

01:08:46,960 --> 01:08:51,279
what is the minimal offload the network

01:08:49,440 --> 01:08:52,799
must support for good tcp

01:08:51,279 --> 01:08:55,520
performance i mean first thing is what's

01:08:52,799 --> 01:08:58,319
good tc perform tcp performance

01:08:55,520 --> 01:09:00,880
so we have to realize that that's um

01:08:58,319 --> 01:09:04,319
heavily dependent on the environment

01:09:00,880 --> 01:09:06,000
and then what do you what are you trying

01:09:04,319 --> 01:09:09,759
to optimize in that is this

01:09:06,000 --> 01:09:12,960
uh throughput is it latency is a

01:09:09,759 --> 01:09:14,480
connection um setup teardown is it power

01:09:12,960 --> 01:09:17,759
on the device

01:09:14,480 --> 01:09:18,799
so uh there's a lot a lot to that

01:09:17,759 --> 01:09:20,960
obviously

01:09:18,799 --> 01:09:22,400
um going back to my presentation it's

01:09:20,960 --> 01:09:24,000
pretty clear that

01:09:22,400 --> 01:09:26,000
there are a few checks you know a few

01:09:24,000 --> 01:09:29,520
offloads like textile muffler that

01:09:26,000 --> 01:09:32,159
we consider to be critical but

01:09:29,520 --> 01:09:33,040
um whether or not there's other forms of

01:09:32,159 --> 01:09:36,159
offloads

01:09:33,040 --> 01:09:39,839
that that help this

01:09:36,159 --> 01:09:42,799
then that's an interesting question

01:09:39,839 --> 01:09:43,279
um the the part about wi-fi chipsets

01:09:42,799 --> 01:09:46,480
with no

01:09:43,279 --> 01:09:48,640
no offloads uh that's also kind of

01:09:46,480 --> 01:09:51,679
interesting because

01:09:48,640 --> 01:09:53,440
one of the applications that i don't

01:09:51,679 --> 01:09:54,480
know if this is actually happening but

01:09:53,440 --> 01:09:58,080
what i've heard about

01:09:54,480 --> 01:10:01,199
is on a

01:09:58,080 --> 01:10:03,040
mobile device the

01:10:01,199 --> 01:10:04,800
biggest problem there isn't actually

01:10:03,040 --> 01:10:05,679
performance in terms of packets per

01:10:04,800 --> 01:10:08,960
second or

01:10:05,679 --> 01:10:10,960
throughput or latency it's power and the

01:10:08,960 --> 01:10:14,239
question there becomes how can we

01:10:10,960 --> 01:10:15,360
offload tcp functionality to improve

01:10:14,239 --> 01:10:18,400
power

01:10:15,360 --> 01:10:20,239
and one of the ideas and i think um eric

01:10:18,400 --> 01:10:21,440
dumas might have some work on this and

01:10:20,239 --> 01:10:26,239
his

01:10:21,440 --> 01:10:29,679
uh sins and xdp 10 processing and xvp

01:10:26,239 --> 01:10:32,880
uh if we can offload things like

01:10:29,679 --> 01:10:34,719
receiving send or tcp keep alive if we

01:10:32,880 --> 01:10:36,480
can push those down into xvp

01:10:34,719 --> 01:10:37,840
and then subsequently push those down to

01:10:36,480 --> 01:10:40,320
the device

01:10:37,840 --> 01:10:40,880
once you push those down to the device

01:10:40,320 --> 01:10:42,480
then

01:10:40,880 --> 01:10:44,960
we should be able to process packets in

01:10:42,480 --> 01:10:48,000
the tcp data path completely

01:10:44,960 --> 01:10:50,400
without even waking up the cpu

01:10:48,000 --> 01:10:52,159
so i think the answer to this question

01:10:50,400 --> 01:10:55,120
is um

01:10:52,159 --> 01:10:55,360
there's a lot of answers and uh you know

01:10:55,120 --> 01:10:57,199
i

01:10:55,360 --> 01:11:00,880
open it up if anyone else in the

01:10:57,199 --> 01:11:00,880
community has uh points about this

01:11:02,000 --> 01:11:08,400
tom i i have uh you know some generic um

01:11:05,920 --> 01:11:10,080
uh you know thoughts that i captured

01:11:08,400 --> 01:11:11,840
when um

01:11:10,080 --> 01:11:13,120
you were presenting and maybe i'll try

01:11:11,840 --> 01:11:16,159
to talk to that

01:11:13,120 --> 01:11:18,080
so uh you know we did talk about

01:11:16,159 --> 01:11:20,000
offloads and acceleration i just want to

01:11:18,080 --> 01:11:23,920
add to that there is

01:11:20,000 --> 01:11:25,440
real good um value to the generic

01:11:23,920 --> 01:11:28,239
offloads and and

01:11:25,440 --> 01:11:28,880
and uh you know it's it's really key and

01:11:28,239 --> 01:11:30,400
i think

01:11:28,880 --> 01:11:32,000
you have been emphasizing that for a

01:11:30,400 --> 01:11:35,360
very long time

01:11:32,000 --> 01:11:36,719
where uh you know all the generic check

01:11:35,360 --> 01:11:38,640
some offload or

01:11:36,719 --> 01:11:41,360
uh generic segmentation offload or

01:11:38,640 --> 01:11:41,360
whatever

01:11:41,920 --> 01:11:46,400
so in my in uh from from my point of

01:11:44,960 --> 01:11:49,440
view generic

01:11:46,400 --> 01:11:52,840
uh you know equals something which is

01:11:49,440 --> 01:11:54,719
protocol agnostic and there is no fixed

01:11:52,840 --> 01:11:58,000
configuration

01:11:54,719 --> 01:11:59,600
in hardware that controlling software

01:11:58,000 --> 01:12:02,719
cannot change

01:11:59,600 --> 01:12:05,199
so that's how i kind of think about

01:12:02,719 --> 01:12:08,239
generic

01:12:05,199 --> 01:12:08,800
and they're re needed both on the host

01:12:08,239 --> 01:12:12,320
side

01:12:08,800 --> 01:12:14,960
and on the switch side not just um

01:12:12,320 --> 01:12:16,400
you know uh whenever we kind of talk

01:12:14,960 --> 01:12:19,440
about generic offers we

01:12:16,400 --> 01:12:21,600
pretty much uh you know limit to what

01:12:19,440 --> 01:12:23,440
you mentioned which is uh from matches

01:12:21,600 --> 01:12:26,960
angle you know the

01:12:23,440 --> 01:12:30,080
the checksum of load or hash or uh

01:12:26,960 --> 01:12:33,520
segmentation of load or uh policing

01:12:30,080 --> 01:12:35,040
or you know uh things of that nature but

01:12:33,520 --> 01:12:36,000
i think there are a lot of generic

01:12:35,040 --> 01:12:37,520
offloads

01:12:36,000 --> 01:12:40,080
that are needed on the switch side as

01:12:37,520 --> 01:12:41,040
well um and and they might be a

01:12:40,080 --> 01:12:43,920
different set

01:12:41,040 --> 01:12:45,520
than you know the 405 that we talk about

01:12:43,920 --> 01:12:48,840
uh most of the time

01:12:45,520 --> 01:12:51,840
uh and then there is also the importance

01:12:48,840 --> 01:12:54,000
of generic blocks in the pipe

01:12:51,840 --> 01:12:55,520
uh ultimately you know the hardware

01:12:54,000 --> 01:12:58,480
design for

01:12:55,520 --> 01:12:59,679
packet processing there is uh you know

01:12:58,480 --> 01:13:03,840
just

01:12:59,679 --> 01:13:06,080
two kind of things that are going on one

01:13:03,840 --> 01:13:06,080
is

01:13:06,640 --> 01:13:11,920
you know memory optimizations and when i

01:13:09,679 --> 01:13:14,960
say memory optimizations

01:13:11,920 --> 01:13:16,960
basically doing a very context-aware

01:13:14,960 --> 01:13:19,360
algorithms to kind of decide what is in

01:13:16,960 --> 01:13:22,800
near memory and what is in far memory

01:13:19,360 --> 01:13:26,320
uh you know and and and that is

01:13:22,800 --> 01:13:29,760
that is a key and that is uh you know

01:13:26,320 --> 01:13:33,280
uh knowledge about

01:13:29,760 --> 01:13:34,960
what uh the networking flows might look

01:13:33,280 --> 01:13:36,719
like or

01:13:34,960 --> 01:13:38,080
you know the nature of those flows or

01:13:36,719 --> 01:13:39,760
whatever

01:13:38,080 --> 01:13:41,920
you know and that's where most of the

01:13:39,760 --> 01:13:45,040
innovation from a hardware

01:13:41,920 --> 01:13:47,760
window comes from in deciding a

01:13:45,040 --> 01:13:48,400
the sizes of those near and far memory

01:13:47,760 --> 01:13:50,960
and

01:13:48,400 --> 01:13:52,719
the you know algorithms that decides

01:13:50,960 --> 01:13:53,120
what remains in the new memory versus

01:13:52,719 --> 01:13:56,000
what

01:13:53,120 --> 01:13:56,880
goes to the far memory um of course i

01:13:56,000 --> 01:13:59,360
mean this this

01:13:56,880 --> 01:14:00,080
comes into play only if we assume there

01:13:59,360 --> 01:14:02,640
is

01:14:00,080 --> 01:14:03,760
you know flows that are offloaded into

01:14:02,640 --> 01:14:05,440
the hardware

01:14:03,760 --> 01:14:07,280
unlike uh the model that you were

01:14:05,440 --> 01:14:09,280
talking about where you know you would

01:14:07,280 --> 01:14:10,400
rather have a larger hash which is

01:14:09,280 --> 01:14:13,679
stateless

01:14:10,400 --> 01:14:14,400
then you know have a flow rule in the

01:14:13,679 --> 01:14:15,840
hardware

01:14:14,400 --> 01:14:17,760
but you know in some cases it's

01:14:15,840 --> 01:14:20,000
unavoidable but i mean i

01:14:17,760 --> 01:14:21,440
i really like a larger hash thing

01:14:20,000 --> 01:14:24,880
because it's so much more

01:14:21,440 --> 01:14:28,000
scalable uh and scalability is

01:14:24,880 --> 01:14:30,800
is is is ultimately what

01:14:28,000 --> 01:14:31,600
decides everything uh for a data center

01:14:30,800 --> 01:14:34,880
right so

01:14:31,600 --> 01:14:37,280
uh so um uh

01:14:34,880 --> 01:14:38,880
and the second part that i said uh you

01:14:37,280 --> 01:14:42,640
know for a hardware

01:14:38,880 --> 01:14:44,560
uh vendor memory optimization is one

01:14:42,640 --> 01:14:47,120
part and the second part is

01:14:44,560 --> 01:14:48,719
network or io atomic operations and i

01:14:47,120 --> 01:14:49,440
think you covered that one as well which

01:14:48,719 --> 01:14:51,840
is like

01:14:49,440 --> 01:14:52,960
we really need some of these stateless i

01:14:51,840 --> 01:14:55,360
o uh

01:14:52,960 --> 01:14:56,800
operations you know checksum or crc32 or

01:14:55,360 --> 01:14:59,920
hash or whatever

01:14:56,800 --> 01:15:01,440
um and then there is there are some

01:14:59,920 --> 01:15:03,440
which are stateful like crypto and

01:15:01,440 --> 01:15:05,040
compression and whatnot

01:15:03,440 --> 01:15:07,679
and we'll have to look into those as

01:15:05,040 --> 01:15:07,679
well um

01:15:08,320 --> 01:15:14,320
the other key factors for uh for

01:15:11,840 --> 01:15:16,960
for hardware design or hardware off-load

01:15:14,320 --> 01:15:20,239
acceleration design is modularity

01:15:16,960 --> 01:15:23,280
just like um there is in software

01:15:20,239 --> 01:15:24,000
um and and and and you know the good

01:15:23,280 --> 01:15:27,360
part is

01:15:24,000 --> 01:15:28,320
um and and i i can speak from my

01:15:27,360 --> 01:15:30,480
experience

01:15:28,320 --> 01:15:31,840
doing software first and then going into

01:15:30,480 --> 01:15:34,880
hardware design

01:15:31,840 --> 01:15:36,560
uh you know uh

01:15:34,880 --> 01:15:38,400
coming from the same thought process

01:15:36,560 --> 01:15:40,640
that you know

01:15:38,400 --> 01:15:43,199
that modularity needs to be maintained

01:15:40,640 --> 01:15:46,320
uh throughout the pipe whether it is

01:15:43,199 --> 01:15:48,000
it is uh the pipeline data plane

01:15:46,320 --> 01:15:49,920
pipeline running in software versus in

01:15:48,000 --> 01:15:52,800
hardware

01:15:49,920 --> 01:15:53,600
that really decides whether you're

01:15:52,800 --> 01:15:56,880
building

01:15:53,600 --> 01:16:01,120
a hardware that is going to last

01:15:56,880 --> 01:16:01,120
two three years or many more years

01:16:01,520 --> 01:16:08,000
and then the other angle that i

01:16:05,600 --> 01:16:08,880
i would say from a hardware vendor's

01:16:08,000 --> 01:16:12,400
perspective

01:16:08,880 --> 01:16:13,360
perspective is um a quality of a

01:16:12,400 --> 01:16:16,400
hardware

01:16:13,360 --> 01:16:20,159
i mean we pretty much

01:16:16,400 --> 01:16:24,480
uh look at it in a very short term

01:16:20,159 --> 01:16:26,159
or in a very uh you know um

01:16:24,480 --> 01:16:28,320
the tests that we have designed like the

01:16:26,159 --> 01:16:31,440
you know test kits and everything or

01:16:28,320 --> 01:16:32,239
uh or um uh benchmarks that we've

01:16:31,440 --> 01:16:35,120
designed

01:16:32,239 --> 01:16:37,120
uh they're they are designed in a way

01:16:35,120 --> 01:16:41,840
that they focus on

01:16:37,120 --> 01:16:44,320
uh uh a given deployed protocol

01:16:41,840 --> 01:16:45,280
right and and and hardware vendors can

01:16:44,320 --> 01:16:48,480
take shortcuts

01:16:45,280 --> 01:16:52,239
and optimize just for that protocol

01:16:48,480 --> 01:16:52,719
but that and yeah so so for the sake of

01:16:52,239 --> 01:16:55,280
time

01:16:52,719 --> 01:16:56,080
um i'm i'm going to have to interrupt

01:16:55,280 --> 01:16:59,280
you here

01:16:56,080 --> 01:17:03,199
uh so the second part of um

01:16:59,280 --> 01:17:06,640
master's question basically asking

01:17:03,199 --> 01:17:10,000
about aggregation what to do about it

01:17:06,640 --> 01:17:12,480
uh both cellular and usb adapters

01:17:10,000 --> 01:17:14,719
appear to often mem copy everything to

01:17:12,480 --> 01:17:19,199
do non-gso style

01:17:14,719 --> 01:17:21,520
packet aggregation degradation

01:17:19,199 --> 01:17:24,000
so this is this is obviously a

01:17:21,520 --> 01:17:26,800
long-standing topic

01:17:24,000 --> 01:17:27,440
we have really good capabilities in

01:17:26,800 --> 01:17:31,440
software

01:17:27,440 --> 01:17:34,880
to do gso and gro

01:17:31,440 --> 01:17:36,719
um even even before we talk about

01:17:34,880 --> 01:17:37,840
hardware there's a lot of value in just

01:17:36,719 --> 01:17:40,800
having that in software

01:17:37,840 --> 01:17:41,920
it actually solves a large percentage of

01:17:40,800 --> 01:17:43,679
the problem

01:17:41,920 --> 01:17:45,679
and like i said even something like like

01:17:43,679 --> 01:17:46,880
tso and lro are difficult to do in

01:17:45,679 --> 01:17:49,600
hardware

01:17:46,880 --> 01:17:50,880
uh but the interesting question is and i

01:17:49,600 --> 01:17:52,719
think we're gonna get to this and some

01:17:50,880 --> 01:17:55,679
other topics

01:17:52,719 --> 01:17:57,440
um what about other other forms of

01:17:55,679 --> 01:18:00,400
batching

01:17:57,440 --> 01:18:01,040
and batching is is a little broader

01:18:00,400 --> 01:18:03,840
topic

01:18:01,040 --> 01:18:04,640
where if we collect packets together can

01:18:03,840 --> 01:18:07,280
we

01:18:04,640 --> 01:18:08,000
operate on them as a single entity even

01:18:07,280 --> 01:18:13,040
if they're not

01:18:08,000 --> 01:18:16,320
exactly the same flow or same um

01:18:13,040 --> 01:18:16,719
same connection and we can look at some

01:18:16,320 --> 01:18:18,239
other

01:18:16,719 --> 01:18:21,120
i mean there's been some work here i

01:18:18,239 --> 01:18:23,679
think xdp batching has been

01:18:21,120 --> 01:18:25,600
a topic that we've talked about a lot

01:18:23,679 --> 01:18:29,440
but there's also something interesting

01:18:25,600 --> 01:18:30,640
in vpp and dpdk i'm not entirely

01:18:29,440 --> 01:18:32,880
convinced that

01:18:30,640 --> 01:18:34,159
that that's for the linux for instance

01:18:32,880 --> 01:18:35,840
but it does have some interesting

01:18:34,159 --> 01:18:38,560
aspects on

01:18:35,840 --> 01:18:40,080
batching packets together that kind of

01:18:38,560 --> 01:18:43,840
have similar characteristics

01:18:40,080 --> 01:18:45,840
but aren't exactly the same flow so uh

01:18:43,840 --> 01:18:47,679
maybe if uh if anyone wants to comment

01:18:45,840 --> 01:18:49,840
on this uh topic

01:18:47,679 --> 01:18:51,120
tom there's also cases of batching when

01:18:49,840 --> 01:18:54,159
we do the defrag

01:18:51,120 --> 01:18:55,120
um especially especially in the telco

01:18:54,159 --> 01:18:58,640
cases

01:18:55,120 --> 01:19:01,760
where you know it

01:18:58,640 --> 01:19:05,520
it is not always avoidable the

01:19:01,760 --> 01:19:06,400
you know fragmentation right i guess the

01:19:05,520 --> 01:19:09,520
question

01:19:06,400 --> 01:19:10,800
more is along the lines what what can

01:19:09,520 --> 01:19:13,120
what's the direction for hardware

01:19:10,800 --> 01:19:14,400
acceleration in this if we want to go

01:19:13,120 --> 01:19:16,080
beyond

01:19:14,400 --> 01:19:17,520
well assuming that we get the basic

01:19:16,080 --> 01:19:20,960
segmentation offloads

01:19:17,520 --> 01:19:24,320
reasonably accelerated okay so

01:19:20,960 --> 01:19:28,000
uh with that it's now uh 9 30

01:19:24,320 --> 01:19:29,679
time flies um uh i'd like to thank the

01:19:28,000 --> 01:19:32,480
organizers i think uh

01:19:29,679 --> 01:19:34,080
this this was pretty good uh obviously

01:19:32,480 --> 01:19:34,880
we'll have to fine-tune the question and

01:19:34,080 --> 01:19:38,480
answer the bit

01:19:34,880 --> 01:19:46,560
um how we deal with that but with that

01:19:38,480 --> 01:19:46,560

YouTube URL: https://www.youtube.com/watch?v=y4Q5B2RGsB4


