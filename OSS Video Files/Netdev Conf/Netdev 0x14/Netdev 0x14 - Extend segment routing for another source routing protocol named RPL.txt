Title: Netdev 0x14 - Extend segment routing for another source routing protocol named RPL
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Alexander Aring, Stefan Schmidt, Michael Richardson

More info: https://netdevconf.info/0x14/session.html?talk-extend-segment-routing-for-RPL

Date: Thursday, August 13, 2020

RPL is an IPv6 Routing Protocol for Low-Power and Lossy Networks defined
in RFC 6550.

In this talk Alexander Aring et al will discuss an implementation
that uses "non-storing" mode (RFC 6554). While there are several other
RPL open source implementations, they all implement RPL using
the "storing" mode which propagates routes via ICMPv6.
In the storing mode, route propagation is done via the IPv6 Routing Header.
Aring et al discuss the architecture, interface approach, challenges that they
overcame and future work.
Captions: 
	00:00:03,600 --> 00:00:09,920
hello welcome to my talk um

00:00:06,160 --> 00:00:13,440
about ripple it's a ip 56

00:00:09,920 --> 00:00:14,559
arctic protocol for lossy low power and

00:00:13,440 --> 00:00:17,039
lossy networks

00:00:14,559 --> 00:00:17,920
that's what the acronym is standing for

00:00:17,039 --> 00:00:21,279
that end

00:00:17,920 --> 00:00:23,840
my name is alexander haring stefan smith

00:00:21,279 --> 00:00:26,720
schmidt is not here but he also leading

00:00:23,840 --> 00:00:28,320
the iot workshop

00:00:26,720 --> 00:00:30,080
at this conference and michael

00:00:28,320 --> 00:00:33,440
richardson he is

00:00:30,080 --> 00:00:37,600
part of the iitf world group which

00:00:33,440 --> 00:00:41,040
develops this routing protocol and

00:00:37,600 --> 00:00:42,879
what i was doing is a necessary part for

00:00:41,040 --> 00:00:46,000
the dean of kernel

00:00:42,879 --> 00:00:47,920
to have a specific handling there which

00:00:46,000 --> 00:00:50,800
cannot be handled

00:00:47,920 --> 00:00:50,800
in the user space

00:00:51,199 --> 00:00:57,520
yeah so uh next slide

00:00:54,800 --> 00:00:58,000
it's what's ripple yeah i already

00:00:57,520 --> 00:01:03,120
mentioned

00:00:58,000 --> 00:01:05,600
it is a routing protocol for ipv6 only

00:01:03,120 --> 00:01:06,880
it's for low power and lossy networks

00:01:05,600 --> 00:01:10,080
it's like for

00:01:06,880 --> 00:01:13,040
iot devices small

00:01:10,080 --> 00:01:13,680
sensor networks and so on there's our

00:01:13,040 --> 00:01:16,960
itf

00:01:13,680 --> 00:01:21,040
or outing protocol working group

00:01:16,960 --> 00:01:25,119
which is role which specified this

00:01:21,040 --> 00:01:26,990
logic protocol and what is my talk about

00:01:25,119 --> 00:01:28,240
it is more about i want to

00:01:26,990 --> 00:01:32,720
[Music]

00:01:28,240 --> 00:01:36,240
give you a small overview how it works

00:01:32,720 --> 00:01:39,600
i'm sure there is a little bit more

00:01:36,240 --> 00:01:42,880
complex behind it uh

00:01:39,600 --> 00:01:44,399
we simplificate we make a simplification

00:01:42,880 --> 00:01:47,600
about authority protocol

00:01:44,399 --> 00:01:50,720
it is only when you it is

00:01:47,600 --> 00:01:54,159
it has a tree like topology

00:01:50,720 --> 00:01:56,880
with a root node and to know

00:01:54,159 --> 00:01:59,119
the notes in this topology have only one

00:01:56,880 --> 00:02:04,560
parent

00:01:59,119 --> 00:02:04,560
and nodes can have n childs there's a

00:02:04,960 --> 00:02:08,080
a lot of out of scope things which are

00:02:07,200 --> 00:02:09,840
not handled

00:02:08,080 --> 00:02:11,280
in this presentation is like

00:02:09,840 --> 00:02:13,840
self-healing of this

00:02:11,280 --> 00:02:15,840
marching protocol it is not handling

00:02:13,840 --> 00:02:20,480
floating road node that means when

00:02:15,840 --> 00:02:23,040
i'm not can switch to become the root

00:02:20,480 --> 00:02:25,040
and the root becomes a node or you have

00:02:23,040 --> 00:02:26,959
also multiple road nodes this is also

00:02:25,040 --> 00:02:29,120
not handled in this

00:02:26,959 --> 00:02:30,160
presentation and there's also security

00:02:29,120 --> 00:02:33,519
features and

00:02:30,160 --> 00:02:37,200
a lot of things more so

00:02:33,519 --> 00:02:41,120
what ripley defines

00:02:37,200 --> 00:02:45,360
upward mounts and downward rods

00:02:41,120 --> 00:02:49,120
and two kinds of nodes modes

00:02:45,360 --> 00:02:52,160
this is drawing and non-storing mode

00:02:49,120 --> 00:02:55,680
so i will talk about these

00:02:52,160 --> 00:02:55,680
two modes

00:02:55,840 --> 00:02:59,200
which are the different because in the

00:02:58,159 --> 00:03:01,840
linux

00:02:59,200 --> 00:03:02,879
view boss airways there was always the

00:03:01,840 --> 00:03:04,959
possibility to

00:03:02,879 --> 00:03:07,040
handle the storing mode but not the

00:03:04,959 --> 00:03:10,080
non-storing mode i will talk about

00:03:07,040 --> 00:03:14,640
this later why it was not handled

00:03:10,080 --> 00:03:18,239
before into the name of current

00:03:14,640 --> 00:03:21,599
so to talk about the upward route

00:03:18,239 --> 00:03:23,519
in this specific two modes it works the

00:03:21,599 --> 00:03:25,920
same

00:03:23,519 --> 00:03:27,280
in regarding of the upwards route but

00:03:25,920 --> 00:03:30,560
our upward vote

00:03:27,280 --> 00:03:33,440
that uh what the name already propagated

00:03:30,560 --> 00:03:33,840
it is how the nodes can reach the wood

00:03:33,440 --> 00:03:36,400
node

00:03:33,840 --> 00:03:37,360
for example we can see on the left side

00:03:36,400 --> 00:03:40,640
uh

00:03:37,360 --> 00:03:42,959
very basic simple topology and on the

00:03:40,640 --> 00:03:46,640
right side you can see

00:03:42,959 --> 00:03:47,680
a tree like topology which maybe ripple

00:03:46,640 --> 00:03:50,720
can build up

00:03:47,680 --> 00:03:54,319
and upward route means when we see

00:03:50,720 --> 00:03:55,200
for example the node six how it can

00:03:54,319 --> 00:03:57,760
reach

00:03:55,200 --> 00:03:59,040
the wood node especially in the wood

00:03:57,760 --> 00:04:03,439
node you have

00:03:59,040 --> 00:04:07,040
something like a border router

00:04:03,439 --> 00:04:10,080
note which makes uh

00:04:07,040 --> 00:04:11,200
in sense of six loop and you it makes a

00:04:10,080 --> 00:04:14,400
translation

00:04:11,200 --> 00:04:18,560
from a six lowpan ipv6 network to our

00:04:14,400 --> 00:04:22,720
real ipv6 world you can imagine that the

00:04:18,560 --> 00:04:22,720
root note one here

00:04:22,880 --> 00:04:26,400
have a connection to the internet

00:04:26,880 --> 00:04:34,320
and all other things is your private

00:04:31,280 --> 00:04:34,320
sensor networks

00:04:35,280 --> 00:04:39,440
for example the upward route there

00:04:38,160 --> 00:04:43,280
exists a

00:04:39,440 --> 00:04:46,320
special mechanism in ripple

00:04:43,280 --> 00:04:47,680
which is named parent selection i make

00:04:46,320 --> 00:04:50,880
it here at a

00:04:47,680 --> 00:04:54,240
route at the node 4.

00:04:50,880 --> 00:04:55,199
you can see it can decide if it wants to

00:04:54,240 --> 00:04:58,479
have a parent

00:04:55,199 --> 00:05:01,600
2 or 3 to reach

00:04:58,479 --> 00:05:04,720
the root note in this example

00:05:01,600 --> 00:05:08,080
it choose the 2 the note 2

00:05:04,720 --> 00:05:09,360
to reach the note note but it can also

00:05:08,080 --> 00:05:11,759
be the

00:05:09,360 --> 00:05:12,639
three note or it can also select the

00:05:11,759 --> 00:05:14,960
five note

00:05:12,639 --> 00:05:16,080
there's a little bit more handling

00:05:14,960 --> 00:05:18,720
according it

00:05:16,080 --> 00:05:20,479
has how to do something with is the hop

00:05:18,720 --> 00:05:23,600
count to the root note

00:05:20,479 --> 00:05:26,720
but uh if you have uh

00:05:23,600 --> 00:05:30,560
specific selection like in four

00:05:26,720 --> 00:05:32,960
it has also more

00:05:30,560 --> 00:05:34,639
information are collected like the

00:05:32,960 --> 00:05:37,520
liquidity between nodes

00:05:34,639 --> 00:05:39,600
when it's a wireless net network or the

00:05:37,520 --> 00:05:42,000
account of the dropping of packets

00:05:39,600 --> 00:05:43,759
and something like that however there

00:05:42,000 --> 00:05:47,440
exists a parent selection

00:05:43,759 --> 00:05:50,880
and the parent selection will be done

00:05:47,440 --> 00:05:54,240
over some icmp b6 message

00:05:50,880 --> 00:05:57,600
which defines to select apparent

00:05:54,240 --> 00:06:00,560
regarding to the upward routes

00:05:57,600 --> 00:06:01,039
so the downward routes in stowing mode

00:06:00,560 --> 00:06:04,319
now

00:06:01,039 --> 00:06:07,919
there's a difference between

00:06:04,319 --> 00:06:08,639
storing and storing mode is that every

00:06:07,919 --> 00:06:10,880
shot

00:06:08,639 --> 00:06:10,880
have

00:06:11,919 --> 00:06:17,280
a vr route for example

00:06:17,840 --> 00:06:23,440
the root note knows

00:06:20,880 --> 00:06:26,800
all the shrines how to reach all side

00:06:23,440 --> 00:06:26,800
notes over a specific

00:06:27,120 --> 00:06:29,919
vr out

00:06:30,400 --> 00:06:36,880
for example 6 the wood note 6

00:06:33,520 --> 00:06:40,800
from the node

00:06:36,880 --> 00:06:44,000
1 from the view of the node 1

00:06:40,800 --> 00:06:48,000
is reachable over 2 but

00:06:44,000 --> 00:06:51,280
also all sub nodes which are apparent

00:06:48,000 --> 00:06:51,759
has also in their routing table how to

00:06:51,280 --> 00:06:57,039
reach

00:06:51,759 --> 00:06:59,520
every node in the subtree

00:06:57,039 --> 00:07:01,039
for example two knows how to reach also

00:06:59,520 --> 00:07:04,240
the six

00:07:01,039 --> 00:07:08,720
over five and then

00:07:04,240 --> 00:07:12,479
everybody then the whole network can be

00:07:08,720 --> 00:07:16,160
reached um

00:07:12,479 --> 00:07:16,800
this has only the uh a big problem that

00:07:16,160 --> 00:07:21,520
it's

00:07:16,800 --> 00:07:21,520
highly maintained able because if the

00:07:21,759 --> 00:07:25,360
topology will be changed

00:07:25,520 --> 00:07:32,800
um you need to update every

00:07:29,440 --> 00:07:35,120
routing table and your sub nodes

00:07:32,800 --> 00:07:36,319
in two and five and something like that

00:07:35,120 --> 00:07:38,720
and every node

00:07:36,319 --> 00:07:41,199
need to store a lot of walls in their

00:07:38,720 --> 00:07:43,199
routing table

00:07:41,199 --> 00:07:46,960
this is the difference in non-storing

00:07:43,199 --> 00:07:46,960
mode in non-storing mode

00:07:47,520 --> 00:07:54,800
the download routes is

00:07:51,680 --> 00:07:58,080
done only that the

00:07:54,800 --> 00:08:01,680
good note knows how to reach

00:07:58,080 --> 00:08:05,039
the ship nodes by placing

00:08:01,680 --> 00:08:05,039
a source routing header

00:08:05,199 --> 00:08:12,319
um into the actual ipv6

00:08:08,400 --> 00:08:15,919
packet and for example

00:08:12,319 --> 00:08:19,520
how one can reach um

00:08:15,919 --> 00:08:21,280
six it is only placed this information

00:08:19,520 --> 00:08:24,639
is only placed in the wood node

00:08:21,280 --> 00:08:26,879
all other nodes has only a default route

00:08:24,639 --> 00:08:30,479
for the upward route

00:08:26,879 --> 00:08:30,479
and for example the

00:08:30,720 --> 00:08:37,440
one can be six can be reached over

00:08:33,839 --> 00:08:40,800
two five six let's then hear this

00:08:37,440 --> 00:08:44,240
path and over the downward roads

00:08:40,800 --> 00:08:44,240
everybody can um

00:08:44,399 --> 00:08:51,200
reach the node so all together with not

00:08:47,440 --> 00:08:54,480
non downward routes and upward routes

00:08:51,200 --> 00:08:57,600
in non-slowing mode it looks like this

00:08:54,480 --> 00:08:59,440
everybody can reach the node the wood

00:08:57,600 --> 00:09:02,720
node

00:08:59,440 --> 00:09:05,120
over its um upward route

00:09:02,720 --> 00:09:06,160
it's a default route when it doesn't

00:09:05,120 --> 00:09:09,360
know it then

00:09:06,160 --> 00:09:12,480
it just sends it to the parent

00:09:09,360 --> 00:09:12,480
and um

00:09:13,279 --> 00:09:19,839
the queen arrows here

00:09:16,480 --> 00:09:20,800
are the downward routes which are only

00:09:19,839 --> 00:09:24,080
placed by the

00:09:20,800 --> 00:09:27,680
root node for example when 4 wants to

00:09:24,080 --> 00:09:30,880
reach 6 then it goes

00:09:27,680 --> 00:09:34,959
over the over 2

00:09:30,880 --> 00:09:37,839
and then from 2 to 1 and

00:09:34,959 --> 00:09:38,399
one knows how to reach that's the root

00:09:37,839 --> 00:09:40,720
note

00:09:38,399 --> 00:09:42,160
you would not knows everything about the

00:09:40,720 --> 00:09:46,480
topology

00:09:42,160 --> 00:09:49,519
and it placed the sulfora header to

00:09:46,480 --> 00:09:52,959
reach six which is over two five

00:09:49,519 --> 00:09:56,959
and six the big advantage here is

00:09:52,959 --> 00:10:00,480
that every sub note has only one

00:09:56,959 --> 00:10:03,920
route to be set which is the parent

00:10:00,480 --> 00:10:04,399
selection round to reach the wood node

00:10:03,920 --> 00:10:07,839
and

00:10:04,399 --> 00:10:11,680
it is unless of maintenance because

00:10:07,839 --> 00:10:16,079
we don't need to update every um

00:10:11,680 --> 00:10:19,360
subtree every sub node

00:10:16,079 --> 00:10:23,120
to update how to reach other nodes in

00:10:19,360 --> 00:10:27,920
in chain when the topology is changed

00:10:23,120 --> 00:10:27,920
the root nodes need only to be updated

00:10:28,240 --> 00:10:34,560
so the source ordering header is

00:10:31,440 --> 00:10:37,440
what i already said it's only

00:10:34,560 --> 00:10:39,200
the only root note which is in case here

00:10:37,440 --> 00:10:42,640
the one

00:10:39,200 --> 00:10:46,720
note one will be insert

00:10:42,640 --> 00:10:49,680
the um the sorting header

00:10:46,720 --> 00:10:51,600
and what i already said is uh it's ipv6

00:10:49,680 --> 00:10:54,480
only

00:10:51,600 --> 00:10:55,680
all other nodes need to be handled the

00:10:54,480 --> 00:10:59,760
source watching header

00:10:55,680 --> 00:11:03,360
like two four six four three acceptance

00:10:59,760 --> 00:11:06,720
they need to forwarding the

00:11:03,360 --> 00:11:08,880
ipv6 header on ipv6 package

00:11:06,720 --> 00:11:10,720
according to the source routing

00:11:08,880 --> 00:11:13,360
information which is done by

00:11:10,720 --> 00:11:16,800
doing some address mapping and it has

00:11:13,360 --> 00:11:16,800
also our loop detection

00:11:18,240 --> 00:11:25,120
by just checking if the same if

00:11:21,440 --> 00:11:28,720
in the address segment

00:11:25,120 --> 00:11:30,079
in the if the address in the intro

00:11:28,720 --> 00:11:32,800
segment

00:11:30,079 --> 00:11:34,880
are assigned on the root node i

00:11:32,800 --> 00:11:36,480
implemented a fancy function there if

00:11:34,880 --> 00:11:39,760
somebody is interesting

00:11:36,480 --> 00:11:42,720
and that you can look into address

00:11:39,760 --> 00:11:44,240
let's see to check on such function and

00:11:42,720 --> 00:11:47,600
yeah of course

00:11:44,240 --> 00:11:51,600
it also for little

00:11:47,600 --> 00:11:54,639
sensor networks and also do

00:11:51,600 --> 00:11:56,480
some compression i wouldn't

00:11:54,639 --> 00:11:58,959
this compression are goodness mainly

00:11:56,480 --> 00:11:58,959
because

00:11:59,120 --> 00:12:07,760
they share mostly the same ipv6

00:12:02,399 --> 00:12:07,760
prefix and then in the segments

00:12:08,320 --> 00:12:14,720
you can compress a lot of bites there

00:12:11,680 --> 00:12:19,440
to reduce the pain a lot

00:12:14,720 --> 00:12:19,440
if you reducing the payload you also

00:12:20,320 --> 00:12:28,160
it's a lot of low power not

00:12:23,519 --> 00:12:32,160
sending more bytes and also

00:12:28,160 --> 00:12:34,240
such things so

00:12:32,160 --> 00:12:35,519
yeah and the compression is more

00:12:34,240 --> 00:12:38,639
according

00:12:35,519 --> 00:12:40,000
the it's according the set in the

00:12:38,639 --> 00:12:43,040
segment area of the

00:12:40,000 --> 00:12:45,680
ipv6 uh routing header

00:12:43,040 --> 00:12:47,920
a source watching header and the

00:12:45,680 --> 00:12:48,959
combustion is according the destination

00:12:47,920 --> 00:12:52,000
address which is

00:12:48,959 --> 00:12:56,160
inside of the ip fix

00:12:52,000 --> 00:12:58,639
ipv6 header um and this

00:12:56,160 --> 00:13:00,320
it basically works that it can align the

00:12:58,639 --> 00:13:05,040
same prefix

00:13:00,320 --> 00:13:07,680
by just saying which bytes are the same

00:13:05,040 --> 00:13:10,160
so how i implemented it for the linux

00:13:07,680 --> 00:13:10,160
scheduler

00:13:10,480 --> 00:13:15,120
it is more because we needed to

00:13:13,519 --> 00:13:17,120
implement

00:13:15,120 --> 00:13:20,480
the source routing functionality and

00:13:17,120 --> 00:13:23,600
there exists already our ipv6 segment

00:13:20,480 --> 00:13:27,120
routing which is outside south launching

00:13:23,600 --> 00:13:30,160
protocol for ipv6 and we

00:13:27,120 --> 00:13:32,320
just did the same thing it just has a

00:13:30,160 --> 00:13:34,560
different use case for

00:13:32,320 --> 00:13:35,519
sensor networks uh because the

00:13:34,560 --> 00:13:37,440
compression

00:13:35,519 --> 00:13:40,160
and a lot of the loop detection is a

00:13:37,440 --> 00:13:43,360
little bit different

00:13:40,160 --> 00:13:46,839
um we also was using late

00:13:43,360 --> 00:13:51,040
night with tunnel implementation it's in

00:13:46,839 --> 00:13:54,079
um inside the ipv6

00:13:51,040 --> 00:13:57,440
implementation of the linux kernel then

00:13:54,079 --> 00:14:00,639
what you can do is just say here

00:13:57,440 --> 00:14:02,800
for example here are

00:14:00,639 --> 00:14:04,639
when you are in the point of view of the

00:14:02,800 --> 00:14:07,360
root note you can just say

00:14:04,639 --> 00:14:08,639
for destination six here are the

00:14:07,360 --> 00:14:12,240
segments

00:14:08,639 --> 00:14:15,680
it just works like the uh

00:14:12,240 --> 00:14:20,000
other ipv6 segment routing

00:14:15,680 --> 00:14:23,760
and what we currently only support

00:14:20,000 --> 00:14:27,360
is inline header that means

00:14:23,760 --> 00:14:30,639
we don't support ip encapsulation yet

00:14:27,360 --> 00:14:33,120
but the protocol

00:14:30,639 --> 00:14:34,000
has some use case for this where this is

00:14:33,120 --> 00:14:38,480
necessary

00:14:34,000 --> 00:14:41,839
but we have don't support this right now

00:14:38,480 --> 00:14:43,760
and yeah the forward boarding is always

00:14:41,839 --> 00:14:46,720
enabled by

00:14:43,760 --> 00:14:48,720
it is compiled in of the in inside the

00:14:46,720 --> 00:14:52,480
linux kernel you just need to enable it

00:14:48,720 --> 00:14:55,600
over the cfs configuration

00:14:52,480 --> 00:14:58,639
and there's just a

00:14:55,600 --> 00:15:03,839
little helper file cripple.c in

00:14:58,639 --> 00:15:07,279
ipv6 to offer some compression helpers

00:15:03,839 --> 00:15:10,240
to compress and uncompress the crypto

00:15:07,279 --> 00:15:13,519
source routing header

00:15:10,240 --> 00:15:15,519
so according to user space

00:15:13,519 --> 00:15:17,440
there exists a experimental very

00:15:15,519 --> 00:15:20,480
experimental user-based demon

00:15:17,440 --> 00:15:20,480
to just um

00:15:20,639 --> 00:15:28,560
prove my work that it works it's

00:15:24,240 --> 00:15:32,399
exchange ipv icmp with the sixth

00:15:28,560 --> 00:15:35,360
message this is what ripple is using to

00:15:32,399 --> 00:15:37,519
um share all these information about

00:15:35,360 --> 00:15:39,839
what is the parent selection of

00:15:37,519 --> 00:15:42,240
four and it's loading the network with

00:15:39,839 --> 00:15:45,920
some information

00:15:42,240 --> 00:15:50,160
um and

00:15:45,920 --> 00:15:53,199
when every how it basically

00:15:50,160 --> 00:15:55,759
works is that the root node stores

00:15:53,199 --> 00:15:57,199
three data structure to represent the

00:15:55,759 --> 00:16:00,399
topology

00:15:57,199 --> 00:16:04,320
so in this case uh

00:16:00,399 --> 00:16:06,560
the root note knows everything about

00:16:04,320 --> 00:16:08,320
how the topology is built and how to

00:16:06,560 --> 00:16:12,639
reach every node

00:16:08,320 --> 00:16:15,519
and the d is actually holding a

00:16:12,639 --> 00:16:17,839
tree data structure to represent the

00:16:15,519 --> 00:16:20,399
topology

00:16:17,839 --> 00:16:22,320
and according this data structure it

00:16:20,399 --> 00:16:26,959
also inserts

00:16:22,320 --> 00:16:26,959
the source routing information

00:16:28,160 --> 00:16:35,519
and how it works is basically that

00:16:32,160 --> 00:16:38,560
every node is first creating

00:16:35,519 --> 00:16:41,759
all upward modes to reach the node

00:16:38,560 --> 00:16:43,600
and then every node will

00:16:41,759 --> 00:16:45,440
tell about the root node what's the

00:16:43,600 --> 00:16:49,600
apparent

00:16:45,440 --> 00:16:54,079
and then the wood node knows every node

00:16:49,600 --> 00:16:54,079
parents note and

00:16:54,480 --> 00:16:58,880
which node was telling that it can

00:16:57,079 --> 00:17:01,519
reconstruct the tree

00:16:58,880 --> 00:17:02,480
struck the topology in a tree data

00:17:01,519 --> 00:17:05,679
structure

00:17:02,480 --> 00:17:10,400
and then insert the source routing

00:17:05,679 --> 00:17:10,400
information according to that

00:17:10,559 --> 00:17:18,079
so and um important to say is that

00:17:15,039 --> 00:17:18,559
the upward fault is only a a default

00:17:18,079 --> 00:17:21,679
route

00:17:18,559 --> 00:17:25,360
to the parent and yeah

00:17:21,679 --> 00:17:30,320
it's only a default round

00:17:25,360 --> 00:17:34,480
so um now we coming to a demo

00:17:30,320 --> 00:17:37,760
i want to show you so uh my demo

00:17:34,480 --> 00:17:38,559
it is this um it uses the make a tunnel

00:17:37,760 --> 00:17:41,760
00:17:38,559 --> 00:17:45,280
hw simulator which can

00:17:41,760 --> 00:17:46,000
produce such topology mesh topology

00:17:45,280 --> 00:17:49,520
which you saw

00:17:46,000 --> 00:17:53,600
in the on the left side on the slides

00:17:49,520 --> 00:17:58,000
here it works over names namespaces

00:17:53,600 --> 00:18:01,280
i named the namespace according

00:17:58,000 --> 00:18:03,840
the note id one

00:18:01,280 --> 00:18:06,320
is for example the root note and

00:18:03,840 --> 00:18:09,440
everybody else on the childs

00:18:06,320 --> 00:18:14,160
just somewhere in the topology

00:18:09,440 --> 00:18:17,440
now i want to show you

00:18:14,160 --> 00:18:20,080
the auditing table of the

00:18:17,440 --> 00:18:20,080
root note

00:18:20,640 --> 00:18:29,840
and for example

00:18:24,160 --> 00:18:32,000
i simplificate it here that um

00:18:29,840 --> 00:18:34,799
that the mac address is according the

00:18:32,000 --> 00:18:38,160
node id for example

00:18:34,799 --> 00:18:43,679
4 is the node id

00:18:38,160 --> 00:18:47,200
4 and this is the prefix which

00:18:43,679 --> 00:18:50,160
everybody shares the same and

00:18:47,200 --> 00:18:51,039
um you can already see when i'm typing

00:18:50,160 --> 00:18:54,640
this command

00:18:51,039 --> 00:18:59,919
i want to show you what i did here so

00:18:54,640 --> 00:19:04,160
i'm just doing our ip net nsx ip6 route

00:18:59,919 --> 00:19:07,520
and you can see on node 4

00:19:04,160 --> 00:19:07,520
we have two segments

00:19:08,400 --> 00:19:14,799
that this is in point of

00:19:11,840 --> 00:19:15,600
this in the view of the root node you

00:19:14,799 --> 00:19:18,799
can reach

00:19:15,600 --> 00:19:22,320
the node at e4 over the

00:19:18,799 --> 00:19:25,919
two segments three

00:19:22,320 --> 00:19:29,919
and then four and for example

00:19:25,919 --> 00:19:34,320
so the note id four is over four

00:19:29,919 --> 00:19:38,559
um there need to be the note id again

00:19:34,320 --> 00:19:42,000
and um

00:19:38,559 --> 00:19:42,000
segment to have a loopback

00:19:44,640 --> 00:19:51,760
so um for example for six which is uh

00:19:49,520 --> 00:19:53,919
a more difficult route you can reach it

00:19:51,760 --> 00:19:58,720
over the

00:19:53,919 --> 00:20:02,559
three and four five and then six again

00:19:58,720 --> 00:20:07,840
so you can also see

00:20:02,559 --> 00:20:07,840
we only using link local addresses for

00:20:08,159 --> 00:20:13,360
the segment that's what is using because

00:20:10,799 --> 00:20:17,840
in combination also with six loop and

00:20:13,360 --> 00:20:21,360
is very fully aligned addresses

00:20:17,840 --> 00:20:25,600
they are not showing up in the

00:20:21,360 --> 00:20:29,039
header and this actually worked because

00:20:25,600 --> 00:20:29,039
link local is not

00:20:29,200 --> 00:20:37,120
route but every not roundable but

00:20:33,440 --> 00:20:40,720
every note is their direct neighbor so

00:20:37,120 --> 00:20:43,840
this still works and we're using

00:20:40,720 --> 00:20:43,840
full addresses here

00:20:46,000 --> 00:20:52,799
this is how the wood note works it has

00:20:49,520 --> 00:20:56,000
all these um green

00:20:52,799 --> 00:20:59,200
arrows how to reach every

00:20:56,000 --> 00:21:02,799
sub node what i show

00:20:59,200 --> 00:21:06,480
want to show you as next is one

00:21:02,799 --> 00:21:10,159
note address and we only see

00:21:06,480 --> 00:21:13,120
here the default out which is

00:21:10,159 --> 00:21:14,080
the parent selection in this case this

00:21:13,120 --> 00:21:17,919
note

00:21:14,080 --> 00:21:21,919
has apparent selection which is three

00:21:17,919 --> 00:21:26,080
how to reach the root note when we

00:21:21,919 --> 00:21:26,080
um also want to

00:21:26,400 --> 00:21:31,840
look how three can reach

00:21:34,640 --> 00:21:42,240
the root note and it's already say

00:21:38,159 --> 00:21:46,159
from node to three the parent selection

00:21:42,240 --> 00:21:49,679
is one so it's directly connected a test

00:21:46,159 --> 00:21:51,760
would not as parent

00:21:49,679 --> 00:21:54,159
so what i wanted to show you guys next

00:21:51,760 --> 00:21:59,200
is a trace route

00:21:54,159 --> 00:22:03,120
you can see for example for

00:21:59,200 --> 00:22:03,120
for reaching two which i just

00:22:03,679 --> 00:22:07,679
want to show you that let's say again

00:22:06,320 --> 00:22:11,120
from point of view

00:22:07,679 --> 00:22:14,480
is the note id for and trace out to

00:22:11,120 --> 00:22:17,919
two we see that it's first

00:22:14,480 --> 00:22:21,280
the first four hop is three one so

00:22:17,919 --> 00:22:25,760
it's going upward and then downward

00:22:21,280 --> 00:22:28,799
again to two which is the

00:22:25,760 --> 00:22:28,799
next um

00:22:29,120 --> 00:22:32,559
which is which has apparent the root

00:22:32,080 --> 00:22:35,679
note

00:22:32,559 --> 00:22:38,799
because it has one

00:22:35,679 --> 00:22:42,720
because it's the one

00:22:38,799 --> 00:22:44,799
hog only and what i wanted to say

00:22:42,720 --> 00:22:46,400
here it's it's a little bit buggy right

00:22:44,799 --> 00:22:50,640
now how to reach

00:22:46,400 --> 00:22:55,840
four to six um but it is working

00:22:50,640 --> 00:22:55,840
i can say afterwards when it works

00:22:57,520 --> 00:23:02,240
it just stops at at the node itself i

00:23:00,880 --> 00:23:05,520
need to look into that

00:23:02,240 --> 00:23:06,080
but in this example we can see it goes

00:23:05,520 --> 00:23:10,159
over

00:23:06,080 --> 00:23:13,200
three then it's going to the root note

00:23:10,159 --> 00:23:17,039
and then down again to three and then

00:23:13,200 --> 00:23:20,320
four which doesn't show up here and then

00:23:17,039 --> 00:23:23,360
five and six and the

00:23:20,320 --> 00:23:27,840
reason why it works is because i

00:23:23,360 --> 00:23:30,720
i i can still ping this guy but i think

00:23:27,840 --> 00:23:32,640
what i saw in my implementation is that

00:23:30,720 --> 00:23:37,200
the traceroute implementation of

00:23:32,640 --> 00:23:40,159
ip utils is a little bit buggy in

00:23:37,200 --> 00:23:41,039
taking the next header chain there's

00:23:40,159 --> 00:23:44,080
some

00:23:41,039 --> 00:23:47,360
it only works on a specific

00:23:44,080 --> 00:23:51,279
um source mod i

00:23:47,360 --> 00:23:54,960
i need to fix the patches are still

00:23:51,279 --> 00:23:57,679
pending to fix traceroute against this

00:23:54,960 --> 00:23:59,760
because the next header chain evaluation

00:23:57,679 --> 00:24:02,480
is a little bit

00:23:59,760 --> 00:24:02,480
it doesn't work

00:24:02,960 --> 00:24:09,360
i did ugly to make it work

00:24:06,080 --> 00:24:12,720
and um

00:24:09,360 --> 00:24:13,360
yes that's everything what i wanted to

00:24:12,720 --> 00:24:16,240
show

00:24:13,360 --> 00:24:17,360
the big disadvantage of of course from

00:24:16,240 --> 00:24:19,520
south routing

00:24:17,360 --> 00:24:21,039
for non-stowing mode which using source

00:24:19,520 --> 00:24:24,400
routing

00:24:21,039 --> 00:24:28,159
is that every traffic goes

00:24:24,400 --> 00:24:30,240
over the root node in storing mode this

00:24:28,159 --> 00:24:34,720
is not necessary because

00:24:30,240 --> 00:24:37,679
every sub-node can reach

00:24:34,720 --> 00:24:38,640
other nodes directly because every

00:24:37,679 --> 00:24:41,679
sub-node

00:24:38,640 --> 00:24:44,840
has its own

00:24:41,679 --> 00:24:46,240
routing table which knows about all the

00:24:44,840 --> 00:24:50,080
subtree

00:24:46,240 --> 00:24:54,080
or in non-story mode only the root note

00:24:50,080 --> 00:24:57,440
knows that so the disadvantage here is

00:24:54,080 --> 00:25:00,080
you have a lot of more traffic but so

00:24:57,440 --> 00:25:03,600
far i heard from michael richardson he

00:25:00,080 --> 00:25:06,640
is working on a combination

00:25:03,600 --> 00:25:08,480
mode where you can combine non-storing

00:25:06,640 --> 00:25:11,039
mode and storing mode

00:25:08,480 --> 00:25:12,960
when it maybe comes a little bit more

00:25:11,039 --> 00:25:16,159
complex to deal all with

00:25:12,960 --> 00:25:19,919
all with all ipv6

00:25:16,159 --> 00:25:23,200
routing tables in a note and

00:25:19,919 --> 00:25:23,600
the case here why people want to use

00:25:23,200 --> 00:25:26,799
that

00:25:23,600 --> 00:25:29,600
is that they don't need to store all

00:25:26,799 --> 00:25:33,360
these words in there

00:25:29,600 --> 00:25:37,120
in their nodes because in case of iot

00:25:33,360 --> 00:25:40,320
and six loop pan you have small embedded

00:25:37,120 --> 00:25:43,360
devices which doesn't have a lot of

00:25:40,320 --> 00:25:47,520
storage storage

00:25:43,360 --> 00:25:51,840
to store all these things and

00:25:47,520 --> 00:25:55,279
in this non-storing mode

00:25:51,840 --> 00:25:57,279
you give this information

00:25:55,279 --> 00:25:59,120
on the wood node and the wood node can

00:25:57,279 --> 00:26:03,360
be a

00:25:59,120 --> 00:26:07,760
device which runs linux

00:26:03,360 --> 00:26:09,600
so and why was it necessary to change

00:26:07,760 --> 00:26:10,159
something in the kernel because all

00:26:09,600 --> 00:26:13,440
these

00:26:10,159 --> 00:26:14,960
for routing and to place the ipv6 source

00:26:13,440 --> 00:26:19,279
routing header

00:26:14,960 --> 00:26:22,880
then it need to be handled in the kernel

00:26:19,279 --> 00:26:26,159
to make it at this point when the

00:26:22,880 --> 00:26:30,000
kernel creates the ipv6

00:26:26,159 --> 00:26:33,279
header like segment routing

00:26:30,000 --> 00:26:35,520
as well and the

00:26:33,279 --> 00:26:36,799
storing mode was always possible because

00:26:35,520 --> 00:26:39,840
that's just

00:26:36,799 --> 00:26:39,840
adding more

00:26:41,679 --> 00:26:45,039
out into the notes

00:26:46,400 --> 00:26:54,480
so in the future work i would say

00:26:50,799 --> 00:26:58,000
we also want to improve the current

00:26:54,480 --> 00:27:01,360
ripple implementation that is not just

00:26:58,000 --> 00:27:04,559
very experimental

00:27:01,360 --> 00:27:07,279
um there's a lot of

00:27:04,559 --> 00:27:09,039
traffic currently to exchange a lot of

00:27:07,279 --> 00:27:12,720
this routing

00:27:09,039 --> 00:27:15,440
information over icmp

00:27:12,720 --> 00:27:16,240
with six message a lot of overhead is

00:27:15,440 --> 00:27:20,000
there

00:27:16,240 --> 00:27:23,200
this can be reduced and um

00:27:20,000 --> 00:27:27,840
but this is nothing this is everything

00:27:23,200 --> 00:27:29,360
user space um we don't need to sh

00:27:27,840 --> 00:27:31,440
but future work in the current

00:27:29,360 --> 00:27:34,880
implementation is still making the

00:27:31,440 --> 00:27:36,960
encapsulation support which is uh

00:27:34,880 --> 00:27:38,399
not there right now we maybe can look up

00:27:36,960 --> 00:27:42,720
this in ipv6

00:27:38,399 --> 00:27:46,720
segment routing and there's a lot of

00:27:42,720 --> 00:27:47,200
different uh specific things which maybe

00:27:46,720 --> 00:27:50,799
need to

00:27:47,200 --> 00:27:53,440
also be handled in the kernel at least

00:27:50,799 --> 00:27:55,520
there's also a hop by hop option but if

00:27:53,440 --> 00:27:58,960
this is now necessary

00:27:55,520 --> 00:28:01,440
to create it i don't know um

00:27:58,960 --> 00:28:03,360
mike richardson said something that it's

00:28:01,440 --> 00:28:06,399
not necessary anymore but maybe

00:28:03,360 --> 00:28:11,120
somebody use it and then at least

00:28:06,399 --> 00:28:11,120
need to be passed but

00:28:11,200 --> 00:28:17,679
how these

00:28:14,840 --> 00:28:21,600
um

00:28:17,679 --> 00:28:22,399
these routes getting placed into the

00:28:21,600 --> 00:28:25,919
kernel over

00:28:22,399 --> 00:28:28,960
a p route it is

00:28:25,919 --> 00:28:28,960
now supported

00:28:29,039 --> 00:28:35,279
by just making uh by just

00:28:32,480 --> 00:28:36,080
saying encapsulation and kept this

00:28:35,279 --> 00:28:39,200
little

00:28:36,080 --> 00:28:42,240
of a key

00:28:39,200 --> 00:28:45,360
out and then you can add your segments

00:28:42,240 --> 00:28:49,760
for this specific

00:28:45,360 --> 00:28:49,760
note and

00:29:00,399 --> 00:29:05,679
okay hello everybody um

00:29:03,600 --> 00:29:07,039
okay great i see always there are two

00:29:05,679 --> 00:29:10,159
questions coming in

00:29:07,039 --> 00:29:12,399
um alexander can you

00:29:10,159 --> 00:29:13,760
answer them here so you have to unmute

00:29:12,399 --> 00:29:16,000
yourself

00:29:13,760 --> 00:29:17,600
and then i think we could have like five

00:29:16,000 --> 00:29:18,960
to ten minutes for questions and then we

00:29:17,600 --> 00:29:23,120
can go to the rest of the

00:29:18,960 --> 00:29:27,840
session can you hear me

00:29:23,120 --> 00:29:27,840
yes okay

00:29:32,080 --> 00:29:37,279
do you see the two question chat window

00:29:38,840 --> 00:29:43,600
or

00:29:41,279 --> 00:29:43,600
yes

00:29:47,840 --> 00:29:52,640
so the first question what is special in

00:29:52,840 --> 00:29:58,000
ellen

00:29:55,760 --> 00:29:58,799
low power and lossy networks that makes

00:29:58,000 --> 00:30:02,320
is not

00:29:58,799 --> 00:30:05,600
suitable for standard routing protocols

00:30:02,320 --> 00:30:08,640
i think you can

00:30:05,600 --> 00:30:11,840
always use the standard

00:30:08,640 --> 00:30:11,840
routing protocols

00:30:14,320 --> 00:30:18,399
but it's always

00:30:19,440 --> 00:30:25,120
it's to have a lot of

00:30:22,799 --> 00:30:25,120
things

00:30:27,760 --> 00:30:32,240
to let me let me jump in there so one of

00:30:31,200 --> 00:30:33,840
the problems is that

00:30:32,240 --> 00:30:36,240
um with all these wireless central

00:30:33,840 --> 00:30:38,480
networks is that a lot of these things

00:30:36,240 --> 00:30:40,159
are really mobile and you don't have

00:30:38,480 --> 00:30:40,880
really a lot of memory storage or

00:30:40,159 --> 00:30:43,520
anything

00:30:40,880 --> 00:30:44,159
on the nodes to keep track on all the

00:30:43,520 --> 00:30:46,880
different

00:30:44,159 --> 00:30:48,240
um nodes you might connect to so that is

00:30:46,880 --> 00:30:50,480
one of the problems to have like

00:30:48,240 --> 00:30:51,440
a traditional routing protocol another

00:30:50,480 --> 00:30:54,080
one is that

00:30:51,440 --> 00:30:54,480
it's a lossy network so a lot of frames

00:30:54,080 --> 00:30:56,320
like

00:30:54,480 --> 00:30:58,960
might get dropped because they're

00:30:56,320 --> 00:31:00,799
because of the mobility or other aspects

00:30:58,960 --> 00:31:02,000
so um that is one of the reasons why

00:31:00,799 --> 00:31:03,919
ripple was

00:31:02,000 --> 00:31:05,600
designed in a way that it's better

00:31:03,919 --> 00:31:07,120
suited for for something of

00:31:05,600 --> 00:31:08,720
for some of these scenarios you can

00:31:07,120 --> 00:31:11,279
actually go and use other

00:31:08,720 --> 00:31:13,279
routing protocols there i think um

00:31:11,279 --> 00:31:15,200
something like open sweat use

00:31:13,279 --> 00:31:16,320
parts of some traditional routing

00:31:15,200 --> 00:31:18,320
protocols

00:31:16,320 --> 00:31:20,159
and adjusted them to their own needs as

00:31:18,320 --> 00:31:20,960
well i don't know the details about that

00:31:20,159 --> 00:31:23,279
right now but

00:31:20,960 --> 00:31:25,840
it is possible but you might have higher

00:31:23,279 --> 00:31:25,840
packet loss

00:31:30,840 --> 00:31:36,000
um

00:31:32,159 --> 00:31:38,640
yeah and thank you

00:31:36,000 --> 00:31:38,640
it's also

00:31:39,760 --> 00:31:44,480
because the memory it's also the thing

00:31:42,559 --> 00:31:47,600
that i heard so far that

00:31:44,480 --> 00:31:50,640
the non storing mode is

00:31:47,600 --> 00:31:50,640
the wider

00:31:51,279 --> 00:31:56,240
used mode outside especially in the

00:31:56,720 --> 00:32:00,000
center networks because they have they

00:31:59,360 --> 00:32:03,039
don't need to

00:32:00,000 --> 00:32:06,399
store a lot of information into their

00:32:03,039 --> 00:32:08,320
memory and the second

00:32:06,399 --> 00:32:10,159
is what is are the main difference

00:32:08,320 --> 00:32:11,840
between the ripple and the already

00:32:10,159 --> 00:32:15,279
existing ipv6

00:32:11,840 --> 00:32:16,799
source watering here yeah um i asked me

00:32:15,279 --> 00:32:18,640
the same question

00:32:16,799 --> 00:32:20,080
i talked with michael richardson about

00:32:18,640 --> 00:32:23,200
it so

00:32:20,080 --> 00:32:25,840
the he answered a little bit

00:32:23,200 --> 00:32:27,039
funny because you need to ask you need

00:32:25,840 --> 00:32:30,080
to swap it around

00:32:27,039 --> 00:32:31,279
because the source voting header for

00:32:30,080 --> 00:32:35,440
ripple was

00:32:31,279 --> 00:32:38,640
at first there and then the other thing

00:32:35,440 --> 00:32:43,600
was there

00:32:38,640 --> 00:32:46,960
the ipv6 was voting

00:32:43,600 --> 00:32:49,200
was there what's coming up

00:32:46,960 --> 00:32:49,200
and

00:32:50,320 --> 00:32:58,880
he he told me they have a kind of

00:32:54,080 --> 00:32:58,880
different use cases you saw in my

00:32:59,919 --> 00:33:03,679
example i don't use any

00:33:03,840 --> 00:33:11,840
prefix i for the destination for the

00:33:06,960 --> 00:33:11,840
routing destination i don't use any

00:33:13,279 --> 00:33:19,840
prefix i always used a full

00:33:16,399 --> 00:33:23,039
address and

00:33:19,840 --> 00:33:23,919
you can also do that with the routing

00:33:23,039 --> 00:33:27,360
thing and

00:33:23,919 --> 00:33:27,360
it has a specific

00:33:28,960 --> 00:33:35,440
handling also for the compression

00:33:33,200 --> 00:33:36,840
of the source watching header that just

00:33:35,440 --> 00:33:40,080
doesn't exist

00:33:36,840 --> 00:33:40,080
in the

00:33:40,799 --> 00:33:45,360
other ipv6 south routing

00:33:46,080 --> 00:33:52,080
protocol and it

00:33:50,399 --> 00:33:54,320
also handles things a little bit

00:33:52,080 --> 00:33:57,840
different but i already said

00:33:54,320 --> 00:34:01,440
in the talk with the loop detection

00:33:57,840 --> 00:34:04,559
i don't thought that in the

00:34:01,440 --> 00:34:07,600
other implementation

00:34:04,559 --> 00:34:14,720
it's kind of different

00:34:07,600 --> 00:34:14,720

YouTube URL: https://www.youtube.com/watch?v=P9ho9j0L1mQ


