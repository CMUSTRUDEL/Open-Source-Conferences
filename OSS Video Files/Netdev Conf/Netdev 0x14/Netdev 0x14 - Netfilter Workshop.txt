Title: Netdev 0x14 - Netfilter Workshop
Publication date: 2020-11-05
Playlist: Netdev 0x14
Description: 
	Chair: Pablo Neira

More info: https://netdevconf.info/0x14/session.html?workshop-netfilter

Date: Thursday, August 13, 2020

This workshop covers updates in the Netfilter land 
since the last NetDev conference such as:

    * Summary of assorted updates.

    * Updates on the next generation packet 
      classification framework.

    * Connection tracking support for bridge.

    * Hardware offloads.
Captions: 
	00:00:05,120 --> 00:00:08,000
my name is pablo and i'm going to make a

00:00:06,799 --> 00:00:10,960
quick summary of the

00:00:08,000 --> 00:00:11,920
updates that have happened in in the net

00:00:10,960 --> 00:00:14,719
filter landscape

00:00:11,920 --> 00:00:17,359
in the last since the last net filter

00:00:14,719 --> 00:00:20,640
since the last that conference

00:00:17,359 --> 00:00:22,480
it's been already one year since that so

00:00:20,640 --> 00:00:23,760
um i'm going to talk i'm going to make a

00:00:22,480 --> 00:00:27,119
brief summary

00:00:23,760 --> 00:00:30,640
on upstream updates um

00:00:27,119 --> 00:00:34,320
on iptables ipsec contract

00:00:30,640 --> 00:00:38,320
ipvs the new flow table infrastructure

00:00:34,320 --> 00:00:41,200
nf tables and nft lb and

00:00:38,320 --> 00:00:41,840
just add one single slide to to discuss

00:00:41,200 --> 00:00:46,000
a few

00:00:41,840 --> 00:00:48,640
more items that are pending so

00:00:46,000 --> 00:00:49,920
what's new on the ip tables and i would

00:00:48,640 --> 00:00:54,079
say i know they said

00:00:49,920 --> 00:00:56,480
um landscape so not not much actually

00:00:54,079 --> 00:00:58,160
in epi tables there there just one

00:00:56,480 --> 00:01:01,280
single target extension

00:00:58,160 --> 00:01:04,000
that came that came new

00:01:01,280 --> 00:01:05,760
it's basically this idle timer version

00:01:04,000 --> 00:01:07,840
one this is a new revision

00:01:05,760 --> 00:01:10,240
so this idle timer target was already

00:01:07,840 --> 00:01:13,840
available but there is a new alarm

00:01:10,240 --> 00:01:17,360
mode and it's quite expensive it's

00:01:13,840 --> 00:01:18,000
it it has a very very um specific use

00:01:17,360 --> 00:01:19,759
case

00:01:18,000 --> 00:01:21,360
basically just to continue to run even

00:01:19,759 --> 00:01:24,240
when the cpu is suspended

00:01:21,360 --> 00:01:24,880
in suspended state so it's a very very

00:01:24,240 --> 00:01:26,880
small

00:01:24,880 --> 00:01:28,000
incremental update on existing idle

00:01:26,880 --> 00:01:30,560
timer target

00:01:28,000 --> 00:01:32,840
and what we have in users base was three

00:01:30,560 --> 00:01:35,840
releases from

00:01:32,840 --> 00:01:40,079
1.83 to 1.85

00:01:35,840 --> 00:01:43,119
so mostly user space updates

00:01:40,079 --> 00:01:46,479
and those updates has been covering

00:01:43,119 --> 00:01:47,920
um basically improving the integration

00:01:46,479 --> 00:01:51,520
with the new

00:01:47,920 --> 00:01:54,159
um nf tables backend so just to make to

00:01:51,520 --> 00:01:55,040
allow users to run iptables command

00:01:54,159 --> 00:01:58,320
seemly

00:01:55,040 --> 00:02:00,640
seamlessly using the nf tables

00:01:58,320 --> 00:02:02,640
um back-end infrastructure so most of

00:02:00,640 --> 00:02:05,200
those changes went went into these

00:02:02,640 --> 00:02:06,159
these ip tables to nf tables back in

00:02:05,200 --> 00:02:09,200
support

00:02:06,159 --> 00:02:12,000
so it's just also incremental updates to

00:02:09,200 --> 00:02:14,400
including many bug fixes and improving

00:02:12,000 --> 00:02:18,480
improving the user space code base

00:02:14,400 --> 00:02:21,520
um then in ipsec um just a few

00:02:18,480 --> 00:02:22,800
updates basically on the kernel side um

00:02:21,520 --> 00:02:25,680
the garbage collector

00:02:22,800 --> 00:02:26,959
was um updated to run in a work hue

00:02:25,680 --> 00:02:30,879
instead of running

00:02:26,959 --> 00:02:34,400
from um bottom half context

00:02:30,879 --> 00:02:37,519
for the hash set types and then

00:02:34,400 --> 00:02:39,440
the wildcard support for the neti phase

00:02:37,519 --> 00:02:40,800
set that is basically a set that allows

00:02:39,440 --> 00:02:44,160
you to combine

00:02:40,800 --> 00:02:46,800
uh network addresses with um interfaces

00:02:44,160 --> 00:02:48,239
so and then what else we had the

00:02:46,800 --> 00:02:51,680
destination mac address

00:02:48,239 --> 00:02:54,640
uh that is now um that can be

00:02:51,680 --> 00:02:55,280
now used from the from the hash ip mac

00:02:54,640 --> 00:02:58,239
sets

00:02:55,280 --> 00:02:58,879
and in users base there were four

00:02:58,239 --> 00:03:03,760
releases

00:02:58,879 --> 00:03:07,360
in ap set set 7. from 7.2 to 7.5

00:03:03,760 --> 00:03:09,040
to 7.6 sorry so um

00:03:07,360 --> 00:03:10,720
what do we have in the connection

00:03:09,040 --> 00:03:14,080
tracking

00:03:10,720 --> 00:03:18,000
area is basically a new support for

00:03:14,080 --> 00:03:21,440
the bridge there is a new module that is

00:03:18,000 --> 00:03:24,560
nf contract bridge it's registering

00:03:21,440 --> 00:03:27,680
um two new hooks it's

00:03:24,560 --> 00:03:29,280
registering the the from the bridge for

00:03:27,680 --> 00:03:30,480
routing hooks it's registering nf

00:03:29,280 --> 00:03:32,879
contract in

00:03:30,480 --> 00:03:33,519
this function is basically um allocating

00:03:32,879 --> 00:03:35,760
the contract

00:03:33,519 --> 00:03:37,760
object and registering into the contract

00:03:35,760 --> 00:03:40,000
table and then you have the bridge post

00:03:37,760 --> 00:03:42,959
routing hook that is confirming this

00:03:40,000 --> 00:03:44,400
connection tracking entry in case of the

00:03:42,959 --> 00:03:46,560
packet went through the

00:03:44,400 --> 00:03:47,440
through all the hooks in the bridge uh

00:03:46,560 --> 00:03:49,840
later

00:03:47,440 --> 00:03:52,000
and there were no rule actually drop in

00:03:49,840 --> 00:03:52,879
this packet then then the entry is

00:03:52,000 --> 00:03:55,439
confirmed

00:03:52,879 --> 00:03:58,080
there is also um since connection

00:03:55,439 --> 00:04:01,519
tracking requires to integrate with

00:03:58,080 --> 00:04:03,360
um with required cc packets

00:04:01,519 --> 00:04:05,760
already the fragmented packets you have

00:04:03,360 --> 00:04:07,920
to you have to um

00:04:05,760 --> 00:04:09,280
collect all the fragments and then pass

00:04:07,920 --> 00:04:12,080
them through

00:04:09,280 --> 00:04:12,879
and the bridge layer so contract sees

00:04:12,080 --> 00:04:16,400
all the

00:04:12,879 --> 00:04:17,120
fragments in one go we also had to

00:04:16,400 --> 00:04:19,600
update the

00:04:17,120 --> 00:04:21,040
the fragmentation the defragment

00:04:19,600 --> 00:04:24,080
infrastructure

00:04:21,040 --> 00:04:27,120
and to to make it work for bridge and

00:04:24,080 --> 00:04:28,080
what was done is basically an

00:04:27,120 --> 00:04:32,000
incremental update

00:04:28,080 --> 00:04:35,120
that that tries not to alter geometry in

00:04:32,000 --> 00:04:37,919
in in in a best effort approach so

00:04:35,120 --> 00:04:39,600
it's whenever it's possible packets

00:04:37,919 --> 00:04:42,479
packet geometry is

00:04:39,600 --> 00:04:43,440
respected so it's left is it is left

00:04:42,479 --> 00:04:46,800
untouched

00:04:43,440 --> 00:04:49,280
but if um in under some

00:04:46,800 --> 00:04:51,520
circumstances that is not possible so

00:04:49,280 --> 00:04:54,720
then then geometry is lost

00:04:51,520 --> 00:04:58,800
the situations where geometry is lost

00:04:54,720 --> 00:05:01,199
are quite um quite specific

00:04:58,800 --> 00:05:02,320
cases basically when combining bridge

00:05:01,199 --> 00:05:04,639
with with the

00:05:02,320 --> 00:05:06,000
net filter queue for example or we're

00:05:04,639 --> 00:05:09,120
combining

00:05:06,000 --> 00:05:11,919
um the bridge layer with contract and

00:05:09,120 --> 00:05:13,360
um connection tracking helpers also

00:05:11,919 --> 00:05:14,160
because connection tracking helpers they

00:05:13,360 --> 00:05:17,199
need to see

00:05:14,160 --> 00:05:19,039
a packet in a linear area

00:05:17,199 --> 00:05:21,120
because many of the connection tracking

00:05:19,039 --> 00:05:23,120
helpers they do button matching to to

00:05:21,120 --> 00:05:24,639
basically basically they are doing layer

00:05:23,120 --> 00:05:26,400
seven um

00:05:24,639 --> 00:05:28,000
parsing and they need to find the packet

00:05:26,400 --> 00:05:30,560
in a lady or

00:05:28,000 --> 00:05:32,960
in a linear fashion so in those cases

00:05:30,560 --> 00:05:35,600
the geometry information is lost

00:05:32,960 --> 00:05:36,320
and there is no um and we would need to

00:05:35,600 --> 00:05:38,240
keep that

00:05:36,320 --> 00:05:40,240
context information around in some way

00:05:38,240 --> 00:05:42,400
to to rebuild to rebuild

00:05:40,240 --> 00:05:43,919
the fragments after leaving the bridge

00:05:42,400 --> 00:05:46,560
um for those cases and

00:05:43,919 --> 00:05:48,880
that i mentioned um but that is not it's

00:05:46,560 --> 00:05:51,280
probably too much effort and it was not

00:05:48,880 --> 00:05:53,680
it was not work that worked that work

00:05:51,280 --> 00:05:57,039
was not done so it's something to be

00:05:53,680 --> 00:05:57,600
to be done in the future um how do you

00:05:57,039 --> 00:06:00,160
enable

00:05:57,600 --> 00:06:01,759
the the connection tracking bridge

00:06:00,160 --> 00:06:05,360
support it's basically just

00:06:01,759 --> 00:06:07,759
whatever you use the city state

00:06:05,360 --> 00:06:09,919
selector internet tables from the bridge

00:06:07,759 --> 00:06:10,800
firmly automatically it's registering

00:06:09,919 --> 00:06:12,400
these hooks

00:06:10,800 --> 00:06:14,400
and the connection tracking bridge

00:06:12,400 --> 00:06:16,479
support is kicking so it's

00:06:14,400 --> 00:06:18,319
this module does not you don't have to

00:06:16,479 --> 00:06:20,240
explicitly load this module to

00:06:18,319 --> 00:06:23,039
to get it working it says whenever you

00:06:20,240 --> 00:06:24,160
have one single user i mean in this case

00:06:23,039 --> 00:06:26,960
the user is

00:06:24,160 --> 00:06:27,919
one rule that specifies the city state

00:06:26,960 --> 00:06:30,400
then

00:06:27,919 --> 00:06:31,840
um the connection tracking bridge

00:06:30,400 --> 00:06:34,400
support is enabled

00:06:31,840 --> 00:06:36,400
this infrastructure is aiming to replace

00:06:34,400 --> 00:06:37,520
br underscore net filter vr on this

00:06:36,400 --> 00:06:40,960
coordinate filter

00:06:37,520 --> 00:06:43,360
or also known as bridge and filter is

00:06:40,960 --> 00:06:44,160
an infrastructure that basically makes

00:06:43,360 --> 00:06:47,199
packets

00:06:44,160 --> 00:06:49,520
make bridge frames um

00:06:47,199 --> 00:06:51,520
make them it makes them look like

00:06:49,520 --> 00:06:53,919
they're real ipip packets

00:06:51,520 --> 00:06:55,440
but they are actually not so it's

00:06:53,919 --> 00:06:58,639
basically injecting

00:06:55,440 --> 00:07:03,039
the bridge frames into the ip

00:06:58,639 --> 00:07:06,400
hooks so um you can use ip tables

00:07:03,039 --> 00:07:09,360
to to filter um

00:07:06,400 --> 00:07:10,319
bridge traffic um this was an idea

00:07:09,360 --> 00:07:13,680
coming

00:07:10,319 --> 00:07:14,160
coming uh probably 10 20 i think it was

00:07:13,680 --> 00:07:17,440
00:07:14,160 --> 00:07:19,919
years ago and it it's it

00:07:17,440 --> 00:07:21,520
seems to be like like yes this is

00:07:19,919 --> 00:07:22,479
something very interesting but actually

00:07:21,520 --> 00:07:24,319
what we found

00:07:22,479 --> 00:07:25,840
in in all this time is that we had lots

00:07:24,319 --> 00:07:26,880
of problem with this vr net photo

00:07:25,840 --> 00:07:30,880
infrastructure

00:07:26,880 --> 00:07:33,919
because um many of the ip tables um

00:07:30,880 --> 00:07:37,440
extensions are not actually not working

00:07:33,919 --> 00:07:40,800
because the bridge frames it

00:07:37,440 --> 00:07:43,599
don't exactly look like um

00:07:40,800 --> 00:07:44,879
can kind of kind of always be you cannot

00:07:43,599 --> 00:07:47,919
always make them look like

00:07:44,879 --> 00:07:49,680
like real ip ip packets and

00:07:47,919 --> 00:07:51,199
and there is also a few corner cases

00:07:49,680 --> 00:07:52,160
when there is information that is

00:07:51,199 --> 00:07:55,360
lacking

00:07:52,160 --> 00:07:58,800
and so this this results in

00:07:55,360 --> 00:07:59,919
in in in problems that that cannot be

00:07:58,800 --> 00:08:02,639
easily fixed

00:07:59,919 --> 00:08:04,479
so so while while the br net filter

00:08:02,639 --> 00:08:05,599
infrastructure is allowing you to use ib

00:08:04,479 --> 00:08:08,720
tables from the bridge

00:08:05,599 --> 00:08:10,720
it is still having many many it is

00:08:08,720 --> 00:08:12,639
having design problems that are not

00:08:10,720 --> 00:08:12,940
easily that cannot be easily fixed

00:08:12,639 --> 00:08:16,000
um

00:08:12,940 --> 00:08:19,520
[Music]

00:08:16,000 --> 00:08:22,000
the the kernel side

00:08:19,520 --> 00:08:23,440
um the kernel side sitting at the

00:08:22,000 --> 00:08:25,599
infrastructure code also

00:08:23,440 --> 00:08:26,960
on that linked up filtering this

00:08:25,599 --> 00:08:31,199
infrastructure allows you to

00:08:26,960 --> 00:08:33,919
filter the net link dump operation

00:08:31,199 --> 00:08:35,360
from from the kernel this is quite

00:08:33,919 --> 00:08:37,360
useful operation

00:08:35,360 --> 00:08:39,039
when you have millions of entries in the

00:08:37,360 --> 00:08:42,320
connection tracking

00:08:39,039 --> 00:08:44,880
table um so you can just specify the

00:08:42,320 --> 00:08:46,959
filtering criteria from user space

00:08:44,880 --> 00:08:47,920
and then the kernel is going to to get

00:08:46,959 --> 00:08:51,519
is is going to

00:08:47,920 --> 00:08:52,640
um dump only um the the entries that you

00:08:51,519 --> 00:08:55,680
are interested on

00:08:52,640 --> 00:08:59,040
so that's another update on that is

00:08:55,680 --> 00:09:01,600
also the ip ips hardware upload bit

00:08:59,040 --> 00:09:03,519
this new status paid for contract allows

00:09:01,600 --> 00:09:06,450
you to identify

00:09:03,519 --> 00:09:07,600
connection dragging entries that are um

00:09:06,450 --> 00:09:10,320
[Music]

00:09:07,600 --> 00:09:12,000
in hardware so this is this is something

00:09:10,320 --> 00:09:14,640
that with with it with the

00:09:12,000 --> 00:09:15,839
new flow table infrastructure that has

00:09:14,640 --> 00:09:19,120
been added

00:09:15,839 --> 00:09:21,360
um it's useful to identify

00:09:19,120 --> 00:09:22,720
what entries went into the hardware so

00:09:21,360 --> 00:09:25,600
this new shutter speed

00:09:22,720 --> 00:09:26,480
um just tells the users that this

00:09:25,600 --> 00:09:28,640
android is not

00:09:26,480 --> 00:09:30,160
it's not in in the hosts is not in

00:09:28,640 --> 00:09:32,640
software

00:09:30,160 --> 00:09:34,560
and there is also an enhancement in the

00:09:32,640 --> 00:09:37,440
class resolution code

00:09:34,560 --> 00:09:39,279
basically to deal with dns flow packets

00:09:37,440 --> 00:09:41,040
there is a race that would that was

00:09:39,279 --> 00:09:44,080
triggering quite easily

00:09:41,040 --> 00:09:47,920
with dns when performing

00:09:44,080 --> 00:09:51,120
a parallel ipv4 and ipv6 lookups

00:09:47,920 --> 00:09:53,600
and it was it was resulting in in in the

00:09:51,120 --> 00:09:56,480
packet losing rays to be dropped

00:09:53,600 --> 00:09:57,200
and this is now this is now solved there

00:09:56,480 --> 00:10:00,160
is now

00:09:57,200 --> 00:10:01,760
a class resolution routine that is is

00:10:00,160 --> 00:10:03,519
dealing with this case so there is no

00:10:01,760 --> 00:10:06,880
packet drops anymore

00:10:03,519 --> 00:10:10,320
for this case um

00:10:06,880 --> 00:10:13,519
in the ipva's in the in ipvs

00:10:10,320 --> 00:10:16,800
the the updates are also

00:10:13,519 --> 00:10:17,360
um just a few of them it's actually not

00:10:16,800 --> 00:10:19,279
much

00:10:17,360 --> 00:10:20,720
it's on the map on demand hook

00:10:19,279 --> 00:10:24,399
registration

00:10:20,720 --> 00:10:26,240
so the the net filter hooks or the ipvs

00:10:24,399 --> 00:10:28,320
net filter hooks are registered only

00:10:26,240 --> 00:10:30,399
when they are used

00:10:28,320 --> 00:10:33,200
before this they were always registered

00:10:30,399 --> 00:10:36,399
there is a small performance penalty

00:10:33,200 --> 00:10:39,600
in in registering the um

00:10:36,399 --> 00:10:41,519
the the hooks for every case even if you

00:10:39,600 --> 00:10:44,880
don't have any single configuration

00:10:41,519 --> 00:10:47,519
in fpvs so now now this is this is only

00:10:44,880 --> 00:10:49,920
impacting performance only when when you

00:10:47,519 --> 00:10:53,680
request ipvs to be used

00:10:49,920 --> 00:10:56,240
um there is a also some small change to

00:10:53,680 --> 00:10:59,040
fall back to the connection tracking tcp

00:10:56,240 --> 00:11:01,519
um to the connection to the contract tcp

00:10:59,040 --> 00:11:02,240
tracker to handle connection reuse in

00:11:01,519 --> 00:11:05,120
fpvs

00:11:02,240 --> 00:11:06,720
and also to queue delayed work to expire

00:11:05,120 --> 00:11:08,160
connections when when

00:11:06,720 --> 00:11:10,320
when they they don't have destination

00:11:08,160 --> 00:11:10,720
basically to to clean to clean tables

00:11:10,320 --> 00:11:12,880
much

00:11:10,720 --> 00:11:14,240
much faster when the destination is not

00:11:12,880 --> 00:11:16,000
available anymore the

00:11:14,240 --> 00:11:17,440
back-end server is not available anymore

00:11:16,000 --> 00:11:20,720
so it's just a few

00:11:17,440 --> 00:11:24,959
um updates on that area in the in the

00:11:20,720 --> 00:11:28,000
um um regarding the flow tables

00:11:24,959 --> 00:11:30,320
um this infrastructure allows you to

00:11:28,000 --> 00:11:31,920
accelerate packet forwarding basically

00:11:30,320 --> 00:11:35,839
by registering

00:11:31,920 --> 00:11:38,560
a a table a flow table

00:11:35,839 --> 00:11:40,880
in the in the net filter increase hook

00:11:38,560 --> 00:11:42,160
and this flow table is making a five

00:11:40,880 --> 00:11:44,399
tuple exact

00:11:42,160 --> 00:11:45,279
matching and if you find an entry in the

00:11:44,399 --> 00:11:47,519
flow table

00:11:45,279 --> 00:11:48,399
then there is a hit and you follow the

00:11:47,519 --> 00:11:50,079
fast path

00:11:48,399 --> 00:11:52,000
that is basically placed in this packet

00:11:50,079 --> 00:11:54,480
in the neighbor x meet path

00:11:52,000 --> 00:11:56,560
so it's it's it's by passing the halo

00:11:54,480 --> 00:11:59,760
classic forwarding path

00:11:56,560 --> 00:12:00,079
um so so basically the idea is that if

00:11:59,760 --> 00:12:01,839
you

00:12:00,079 --> 00:12:03,920
if the packet doesn't does not find an

00:12:01,839 --> 00:12:05,680
entry then that packet follows the

00:12:03,920 --> 00:12:07,839
classic forwarding path

00:12:05,680 --> 00:12:09,680
but if you find if the packet finds an

00:12:07,839 --> 00:12:10,800
entry in the flow table then it follows

00:12:09,680 --> 00:12:13,040
this fast path

00:12:10,800 --> 00:12:14,079
so basically the idea is that only a few

00:12:13,040 --> 00:12:16,320
packets

00:12:14,079 --> 00:12:18,240
just the initial packets of overflow

00:12:16,320 --> 00:12:21,279
they follow the classic forwarding path

00:12:18,240 --> 00:12:25,200
and and then basically

00:12:21,279 --> 00:12:28,639
the the after the second packet is seen

00:12:25,200 --> 00:12:30,160
then it's going to it's going to add an

00:12:28,639 --> 00:12:31,839
entry to the flow table the first packet

00:12:30,160 --> 00:12:32,560
never never adds an entry to the flow

00:12:31,839 --> 00:12:34,320
table it's

00:12:32,560 --> 00:12:36,240
starting from the second packet and the

00:12:34,320 --> 00:12:37,680
the second packet of the flow creates an

00:12:36,240 --> 00:12:39,360
entry and the third packet is going to

00:12:37,680 --> 00:12:41,120
find the entry in the flow table so it's

00:12:39,360 --> 00:12:43,760
basically one first packet

00:12:41,120 --> 00:12:45,600
follows classic forwarding path second

00:12:43,760 --> 00:12:47,040
packet creates the entry in the flow

00:12:45,600 --> 00:12:49,440
table and the third packet

00:12:47,040 --> 00:12:50,639
it's finding the entry in the flow table

00:12:49,440 --> 00:12:53,680
so it's following the

00:12:50,639 --> 00:12:55,519
the fast path so and all packets

00:12:53,680 --> 00:12:56,320
following after the third packet it's

00:12:55,519 --> 00:12:58,320
they they always

00:12:56,320 --> 00:13:00,079
follow this fastback this passpad is a

00:12:58,320 --> 00:13:03,600
software fast path

00:13:00,079 --> 00:13:04,959
so um it was lacking ipvs support that

00:13:03,600 --> 00:13:06,800
is now available

00:13:04,959 --> 00:13:09,360
and it was also lacking hardware outlaw

00:13:06,800 --> 00:13:12,480
support which is now available with the

00:13:09,360 --> 00:13:14,720
melanox connect five and specifically

00:13:12,480 --> 00:13:16,320
specifically integrating this

00:13:14,720 --> 00:13:19,519
infrastructure with the

00:13:16,320 --> 00:13:21,120
recently added dc cd support

00:13:19,519 --> 00:13:22,480
and there were also a bunch of fixes

00:13:21,120 --> 00:13:25,120
that went into this flow table

00:13:22,480 --> 00:13:25,120
infrastructure

00:13:25,760 --> 00:13:29,680
um regarding nf tables um so we got

00:13:29,200 --> 00:13:32,000
quite a

00:13:29,680 --> 00:13:34,480
quite quite a bunch of commit updates

00:13:32,000 --> 00:13:38,639
since march 2019

00:13:34,480 --> 00:13:41,920
it's basically a bit more the phone 400

00:13:38,639 --> 00:13:45,360
six releases from zero

00:13:41,920 --> 00:13:46,880
nine one two zero nine six and

00:13:45,360 --> 00:13:48,480
and then they are coming zero night

00:13:46,880 --> 00:13:51,120
seven coming soon

00:13:48,480 --> 00:13:52,160
then uh we got contributions from from

00:13:51,120 --> 00:13:55,920
32 unique

00:13:52,160 --> 00:13:58,720
um developers and

00:13:55,920 --> 00:14:00,399
the the main updates of going into nf

00:13:58,720 --> 00:14:02,399
tables are basically new features

00:14:00,399 --> 00:14:06,240
available up to the linux kernel

00:14:02,399 --> 00:14:08,320
5.9 and many many bug fixes

00:14:06,240 --> 00:14:09,839
and now let's follow up with a quick

00:14:08,320 --> 00:14:14,560
quick summary on on

00:14:09,839 --> 00:14:16,880
all these updates so the um

00:14:14,560 --> 00:14:18,800
the first thing that that it's worth

00:14:16,880 --> 00:14:22,240
mentioning is this packet this

00:14:18,800 --> 00:14:26,480
this payload matching um

00:14:22,240 --> 00:14:29,519
for uh for matching on transport header

00:14:26,480 --> 00:14:32,639
port information so um

00:14:29,519 --> 00:14:33,600
this this new th keyword it's transport

00:14:32,639 --> 00:14:35,839
header

00:14:33,600 --> 00:14:36,880
so dh stands for transport header is

00:14:35,839 --> 00:14:38,800
telling you

00:14:36,880 --> 00:14:41,360
uh it's allowing you to match on the

00:14:38,800 --> 00:14:44,160
destination or source port regardless

00:14:41,360 --> 00:14:44,639
uh what transport protocol you have so

00:14:44,160 --> 00:14:47,120
these

00:14:44,639 --> 00:14:48,560
source and destination ports are usually

00:14:47,120 --> 00:14:50,880
on this are always

00:14:48,560 --> 00:14:52,320
on the same offset from many layer for

00:14:50,880 --> 00:14:55,199
transport protocols so

00:14:52,320 --> 00:14:56,800
um matching addit at this offset allows

00:14:55,199 --> 00:14:58,480
you to generalize rules a bit more to

00:14:56,800 --> 00:15:02,079
consolidate your rule set

00:14:58,480 --> 00:15:04,240
so the example there that you can see um

00:15:02,079 --> 00:15:06,000
the first line it's basically telling

00:15:04,240 --> 00:15:09,199
you to um

00:15:06,000 --> 00:15:11,440
it's matching on on um

00:15:09,199 --> 00:15:14,320
on the ap protocol field in the header

00:15:11,440 --> 00:15:16,320
for tcp and udp

00:15:14,320 --> 00:15:20,399
packets and then all packets going to

00:15:16,320 --> 00:15:23,279
destination for 3053 are accepted

00:15:20,399 --> 00:15:23,920
so before this update you you need you

00:15:23,279 --> 00:15:27,519
needed to

00:15:23,920 --> 00:15:31,440
to specify two rules or to use the um

00:15:27,519 --> 00:15:35,600
raw um the raw payload expression

00:15:31,440 --> 00:15:37,360
which is not so um so easy to

00:15:35,600 --> 00:15:39,040
to to read when when looking at the

00:15:37,360 --> 00:15:39,519
rules if you use quite a bunch of them

00:15:39,040 --> 00:15:40,880
so

00:15:39,519 --> 00:15:43,759
that's why we introduced it we

00:15:40,880 --> 00:15:46,240
introduced this shortcut this th keyword

00:15:43,759 --> 00:15:48,240
and you're going to also combine the th

00:15:46,240 --> 00:15:49,199
keyword with with concatenation so

00:15:48,240 --> 00:15:51,759
basically

00:15:49,199 --> 00:15:53,120
building a tuple of three three

00:15:51,759 --> 00:15:54,079
components it's basically the

00:15:53,120 --> 00:15:57,680
destination address

00:15:54,079 --> 00:15:58,720
the protocol um the the transfer

00:15:57,680 --> 00:16:00,639
protocol and then the

00:15:58,720 --> 00:16:01,759
the destination port and then consult

00:16:00,639 --> 00:16:05,519
this it

00:16:01,759 --> 00:16:07,759
find a matching in in the my set um

00:16:05,519 --> 00:16:09,279
existing set in in the in your rule set

00:16:07,759 --> 00:16:10,639
so in case that you found a match you

00:16:09,279 --> 00:16:12,560
accept that traffic

00:16:10,639 --> 00:16:14,240
there is now also support for matching

00:16:12,560 --> 00:16:17,279
on ipv4 app options

00:16:14,240 --> 00:16:18,240
specifically um these four that you can

00:16:17,279 --> 00:16:22,320
see there

00:16:18,240 --> 00:16:23,600
um so the syntax is it's like um

00:16:22,320 --> 00:16:26,079
it's like you can see there it's

00:16:23,600 --> 00:16:27,440
basically ip option and then you specify

00:16:26,079 --> 00:16:29,920
the ip option

00:16:27,440 --> 00:16:31,199
that you are interested in and then you

00:16:29,920 --> 00:16:33,120
can specify exist

00:16:31,199 --> 00:16:34,800
just to check if that option is saved

00:16:33,120 --> 00:16:36,880
exists and then you

00:16:34,800 --> 00:16:38,560
you can specify some actions like drop

00:16:36,880 --> 00:16:41,759
count or counter or

00:16:38,560 --> 00:16:45,440
anything you you need and

00:16:41,759 --> 00:16:47,680
you can also inspect the the fields of

00:16:45,440 --> 00:16:50,880
these ipv4 options

00:16:47,680 --> 00:16:55,759
you can specify you can specify the type

00:16:50,880 --> 00:16:58,000
and then the the the type number

00:16:55,759 --> 00:16:58,000
so

00:16:59,839 --> 00:17:07,120
what else are coming coming next is

00:17:03,519 --> 00:17:09,679
the meta extension so um enough tables

00:17:07,120 --> 00:17:12,559
now learned how to match on

00:17:09,679 --> 00:17:13,919
um on time so you can specify time

00:17:12,559 --> 00:17:16,079
ranges

00:17:13,919 --> 00:17:17,520
and this time ranges allow you allows

00:17:16,079 --> 00:17:19,760
you to just to to

00:17:17,520 --> 00:17:21,120
apply some some specific policy to

00:17:19,760 --> 00:17:24,559
packets matching on that

00:17:21,120 --> 00:17:26,079
range the range can be a full date

00:17:24,559 --> 00:17:29,200
including year month

00:17:26,079 --> 00:17:32,240
uh day and time but it can be just

00:17:29,200 --> 00:17:33,600
just time in in terms of meta hours so

00:17:32,240 --> 00:17:37,039
you can specify a range of

00:17:33,600 --> 00:17:37,760
hours the starting and the the closing

00:17:37,039 --> 00:17:41,679
time

00:17:37,760 --> 00:17:42,880
and then you can also specify days so

00:17:41,679 --> 00:17:45,440
this is basically providing a

00:17:42,880 --> 00:17:48,640
replacement for the ip tables

00:17:45,440 --> 00:17:52,480
time match and then then

00:17:48,640 --> 00:17:54,960
on the segmar um

00:17:52,480 --> 00:17:58,160
on the segment support sigma support was

00:17:54,960 --> 00:18:00,400
added to nf tables is ct segment

00:17:58,160 --> 00:18:01,360
that can you can use to cons to to to

00:18:00,400 --> 00:18:04,799
check for

00:18:01,360 --> 00:18:08,160
um for the cd segment value um

00:18:04,799 --> 00:18:10,720
you can you can um assign a

00:18:08,160 --> 00:18:11,760
a sec mark to your connection tracking

00:18:10,720 --> 00:18:14,320
entry

00:18:11,760 --> 00:18:16,720
the this exactly is setting the the

00:18:14,320 --> 00:18:18,320
segmar based on the meter mark on the

00:18:16,720 --> 00:18:21,360
sec mark that is available in the

00:18:18,320 --> 00:18:23,679
in the packet and you can also restore

00:18:21,360 --> 00:18:25,200
uh the connection tracking second mark

00:18:23,679 --> 00:18:28,559
and on the

00:18:25,200 --> 00:18:29,280
on the packet and by by using meters

00:18:28,559 --> 00:18:31,840
like marseille

00:18:29,280 --> 00:18:34,080
city sick mark so it's basically allows

00:18:31,840 --> 00:18:36,000
you to store the segment on the contact

00:18:34,080 --> 00:18:36,799
on the contract object and restore it on

00:18:36,000 --> 00:18:40,799
the packet

00:18:36,799 --> 00:18:42,480
which is a very common operation um

00:18:40,799 --> 00:18:44,240
there there's not also support to match

00:18:42,480 --> 00:18:46,640
on the bridge vlan

00:18:44,240 --> 00:18:48,160
filtering metadata that is also this is

00:18:46,640 --> 00:18:50,559
a metadata that is all a

00:18:48,160 --> 00:18:51,679
very specific bridge of the bridge

00:18:50,559 --> 00:18:55,520
family

00:18:51,679 --> 00:18:58,559
so you can just use the ibr pvid

00:18:55,520 --> 00:19:01,679
um to match on the vlan id and the vlan

00:18:58,559 --> 00:19:04,559
proto of these

00:19:01,679 --> 00:19:04,559
bridge interface

00:19:05,039 --> 00:19:12,480
extensions for for sets and maps include

00:19:09,280 --> 00:19:15,200
uh range in concatenations um

00:19:12,480 --> 00:19:16,480
so you can now if you specify when

00:19:15,200 --> 00:19:19,679
defining your set

00:19:16,480 --> 00:19:23,520
or your map the the type is

00:19:19,679 --> 00:19:24,320
is um is a tuple that is composed of

00:19:23,520 --> 00:19:27,120
several

00:19:24,320 --> 00:19:27,760
um data types like in this case if you

00:19:27,120 --> 00:19:31,679
specify

00:19:27,760 --> 00:19:34,720
also the the flag interval

00:19:31,679 --> 00:19:36,960
then um you can you can define

00:19:34,720 --> 00:19:38,480
uh concatenations that include ranges

00:19:36,960 --> 00:19:41,840
like the one you can see there

00:19:38,480 --> 00:19:44,480
so um the

00:19:41,840 --> 00:19:45,600
rule does not need to be updated it's

00:19:44,480 --> 00:19:48,960
it's exactly

00:19:45,600 --> 00:19:51,919
like like other concatenations

00:19:48,960 --> 00:19:53,360
where you you combine a bunch of

00:19:51,919 --> 00:19:56,640
selectors and then you

00:19:53,360 --> 00:19:57,039
use the add keyword and the name of the

00:19:56,640 --> 00:20:01,280
set

00:19:57,039 --> 00:20:01,280
to to perform a look at on that set

00:20:01,360 --> 00:20:05,440
so it's just that from user space the

00:20:03,600 --> 00:20:07,360
only update in case you want to use this

00:20:05,440 --> 00:20:09,280
feature is that you have to specify when

00:20:07,360 --> 00:20:11,440
defining your set that that you have

00:20:09,280 --> 00:20:14,080
intervals and then then you can do so

00:20:11,440 --> 00:20:20,400
with the flux interval

00:20:14,080 --> 00:20:23,120
option um

00:20:20,400 --> 00:20:24,240
what else um you can use you can also

00:20:23,120 --> 00:20:26,559
combine this with

00:20:24,240 --> 00:20:27,280
uh type off the type of keyword is new

00:20:26,559 --> 00:20:29,440
it's

00:20:27,280 --> 00:20:30,320
um you can use it to define sets in a

00:20:29,440 --> 00:20:34,159
more

00:20:30,320 --> 00:20:37,200
handy way um every selector

00:20:34,159 --> 00:20:38,000
has a data type and users has to keep in

00:20:37,200 --> 00:20:40,640
mind what

00:20:38,000 --> 00:20:41,440
what what what what is the data type for

00:20:40,640 --> 00:20:44,559
for this

00:20:41,440 --> 00:20:45,360
um for this key specifically so you have

00:20:44,559 --> 00:20:49,039
to remember

00:20:45,360 --> 00:20:53,600
that for ip source address

00:20:49,039 --> 00:20:56,640
the data type is um ip4 underscore

00:20:53,600 --> 00:20:57,840
addr right so keeping all these data

00:20:56,640 --> 00:21:01,039
types in mine is

00:20:57,840 --> 00:21:01,440
is not handy so this new type off allows

00:21:01,039 --> 00:21:03,600
you to

00:21:01,440 --> 00:21:04,799
just to specify the key name the

00:21:03,600 --> 00:21:07,360
deselector

00:21:04,799 --> 00:21:08,640
and and use it to use it to define your

00:21:07,360 --> 00:21:10,880
set so you use

00:21:08,640 --> 00:21:12,000
instead of using as before instead of

00:21:10,880 --> 00:21:15,280
using

00:21:12,000 --> 00:21:18,159
type ipv4 address type ib

00:21:15,280 --> 00:21:19,200
for address and i need service instead

00:21:18,159 --> 00:21:22,240
of that you just type

00:21:19,200 --> 00:21:23,120
off and you specify the these selectors

00:21:22,240 --> 00:21:25,200
that you want to

00:21:23,120 --> 00:21:28,080
you want to use for your set for the set

00:21:25,200 --> 00:21:28,080
that you are defining

00:21:28,840 --> 00:21:35,679
um what else um

00:21:31,919 --> 00:21:38,000
the restoration of of expiration time

00:21:35,679 --> 00:21:38,799
is something that was missing it's now

00:21:38,000 --> 00:21:41,600
available

00:21:38,799 --> 00:21:42,880
in in enctables using space on also

00:21:41,600 --> 00:21:44,799
kernel side

00:21:42,880 --> 00:21:46,880
basically this allows you to restore the

00:21:44,799 --> 00:21:49,760
expiration time when you create a set

00:21:46,880 --> 00:21:50,320
an element well i said you can specify

00:21:49,760 --> 00:21:53,760
that

00:21:50,320 --> 00:21:54,720
all entries have a timeout so after that

00:21:53,760 --> 00:21:56,799
time

00:21:54,720 --> 00:21:58,320
they they expire and they are removed

00:21:56,799 --> 00:22:01,039
from from this head

00:21:58,320 --> 00:22:02,080
so what you could do in this case is

00:22:01,039 --> 00:22:04,720
that

00:22:02,080 --> 00:22:06,320
um when when if you have to reboot your

00:22:04,720 --> 00:22:07,280
system for example and you you want you

00:22:06,320 --> 00:22:09,760
would like to keep that

00:22:07,280 --> 00:22:10,320
stateful information around then what

00:22:09,760 --> 00:22:14,159
you could

00:22:10,320 --> 00:22:15,919
what what is uh what is what what can be

00:22:14,159 --> 00:22:17,200
what you can use is that you can store

00:22:15,919 --> 00:22:19,200
your ruleset including this

00:22:17,200 --> 00:22:21,120
stateful information in a file and then

00:22:19,200 --> 00:22:21,840
what you when when your system puts up

00:22:21,120 --> 00:22:24,840
again

00:22:21,840 --> 00:22:26,799
you can just restore these this stateful

00:22:24,840 --> 00:22:29,919
information and

00:22:26,799 --> 00:22:31,760
so so the entries the entries resume

00:22:29,919 --> 00:22:34,720
from from where they were

00:22:31,760 --> 00:22:35,520
right so um this was not possible so far

00:22:34,720 --> 00:22:38,240
to restore this

00:22:35,520 --> 00:22:40,159
this information um the workaround so

00:22:38,240 --> 00:22:41,919
far was to use the minus s

00:22:40,159 --> 00:22:44,400
option for nft that is basically

00:22:41,919 --> 00:22:45,520
removing the stateful information from

00:22:44,400 --> 00:22:47,840
your listing

00:22:45,520 --> 00:22:50,159
and and while this this workaround is

00:22:47,840 --> 00:22:53,200
not it's not needed anymore you can just

00:22:50,159 --> 00:22:54,880
restore the exp the inspiration that is

00:22:53,200 --> 00:22:57,919
basically telling you how much time

00:22:54,880 --> 00:23:02,080
left to to expire um

00:22:57,919 --> 00:23:05,919
this entry has right and um

00:23:02,080 --> 00:23:07,760
and that's it so these the the next

00:23:05,919 --> 00:23:08,799
feature is the set element deletion from

00:23:07,760 --> 00:23:10,880
the packet path so

00:23:08,799 --> 00:23:11,840
in your rules you can specify the delete

00:23:10,880 --> 00:23:15,360
keyword and then

00:23:11,840 --> 00:23:18,720
add and a specific set and these

00:23:15,360 --> 00:23:21,200
um this you can use it to to delete

00:23:18,720 --> 00:23:22,880
entries that are basically composed of

00:23:21,200 --> 00:23:25,200
the the the

00:23:22,880 --> 00:23:27,600
the tuple the specific tuple or just one

00:23:25,200 --> 00:23:30,480
single selector that you specify

00:23:27,600 --> 00:23:31,360
um so basically allowing you to remove

00:23:30,480 --> 00:23:34,400
entries from

00:23:31,360 --> 00:23:36,080
from from the packet path in in a

00:23:34,400 --> 00:23:39,280
specific set

00:23:36,080 --> 00:23:42,799
um you can you can use comments

00:23:39,280 --> 00:23:45,279
uh in sets now which is something that

00:23:42,799 --> 00:23:47,440
users might like to have if you have a

00:23:45,279 --> 00:23:48,240
large bunch of set and you would like to

00:23:47,440 --> 00:23:50,240
keep

00:23:48,240 --> 00:23:51,360
information context information around

00:23:50,240 --> 00:23:54,960
to allow

00:23:51,360 --> 00:23:57,120
someone else or yourself to to remember

00:23:54,960 --> 00:23:59,520
uh what is what was the purpose of this

00:23:57,120 --> 00:24:01,679
set if if the name is not

00:23:59,520 --> 00:24:03,200
explicit enough right so you can just

00:24:01,679 --> 00:24:06,960
specify

00:24:03,200 --> 00:24:10,240
comment and and then a string

00:24:06,960 --> 00:24:13,679
between code quotes there is now a

00:24:10,240 --> 00:24:16,559
minus t option the um

00:24:13,679 --> 00:24:18,559
and this minus t option allows you to

00:24:16,559 --> 00:24:21,760
exclude sets from the listing

00:24:18,559 --> 00:24:22,480
it's a way to shorten your listing if

00:24:21,760 --> 00:24:25,440
you have

00:24:22,480 --> 00:24:27,360
many sets and those sets have lots of uh

00:24:25,440 --> 00:24:31,919
set elements

00:24:27,360 --> 00:24:34,000
so um and it can be also very useful in

00:24:31,919 --> 00:24:35,600
case you have dynamic sets sets that are

00:24:34,000 --> 00:24:37,360
updated from the packet path that gets

00:24:35,600 --> 00:24:38,000
many entries and those entries are not

00:24:37,360 --> 00:24:41,039
relevant

00:24:38,000 --> 00:24:42,000
in for for your listing so just you just

00:24:41,039 --> 00:24:44,559
specify this

00:24:42,000 --> 00:24:46,159
minus t option it's basically the same

00:24:44,559 --> 00:24:47,360
the same minus the option that you have

00:24:46,159 --> 00:24:49,360
in ap set

00:24:47,360 --> 00:24:50,960
so now it is also available in the

00:24:49,360 --> 00:24:54,080
tables

00:24:50,960 --> 00:24:55,440
so what else internet tables um there is

00:24:54,080 --> 00:25:00,000
support now for

00:24:55,440 --> 00:25:03,200
um the set counters so if you specify

00:25:00,000 --> 00:25:05,919
counters in in your set definition

00:25:03,200 --> 00:25:08,100
the the elements are going to get a

00:25:05,919 --> 00:25:09,440
packet and byte counter

00:25:08,100 --> 00:25:12,080
[Music]

00:25:09,440 --> 00:25:12,559
so whenever you list it you you can

00:25:12,080 --> 00:25:14,000
check

00:25:12,559 --> 00:25:16,320
you can check the values of these

00:25:14,000 --> 00:25:19,360
counters so

00:25:16,320 --> 00:25:19,919
and there is this it's this if you save

00:25:19,360 --> 00:25:23,520
these

00:25:19,919 --> 00:25:24,240
counter values to uh if you list your

00:25:23,520 --> 00:25:28,000
rule set

00:25:24,240 --> 00:25:30,640
and you store this listing in a file and

00:25:28,000 --> 00:25:31,520
and you would like to restore these

00:25:30,640 --> 00:25:33,440
values again

00:25:31,520 --> 00:25:35,440
for a situation where for example you

00:25:33,440 --> 00:25:37,919
have to reboot your system

00:25:35,440 --> 00:25:39,679
then it's it is possible to restore

00:25:37,919 --> 00:25:41,520
these counters from the file so this

00:25:39,679 --> 00:25:44,159
stateful information can be a store in a

00:25:41,520 --> 00:25:47,279
file and you can restore it whenever you

00:25:44,159 --> 00:25:50,480
you need to so

00:25:47,279 --> 00:25:54,000
um in terms of not updates there

00:25:50,480 --> 00:25:55,919
there is now you can now combine um

00:25:54,000 --> 00:25:57,200
you can now you can now combine the the

00:25:55,919 --> 00:26:00,720
concatenation feature

00:25:57,200 --> 00:26:04,080
in dna so um

00:26:00,720 --> 00:26:07,440
you can um specify the

00:26:04,080 --> 00:26:09,120
nat that is going to be performed based

00:26:07,440 --> 00:26:12,159
on the

00:26:09,120 --> 00:26:14,480
on the on whatever criteria you have in

00:26:12,159 --> 00:26:18,159
this example there you can see it's dna

00:26:14,480 --> 00:26:21,360
ipv ipd address and port

00:26:18,159 --> 00:26:24,640
so it's going to do the dna um

00:26:21,360 --> 00:26:26,880
uh it's going to set a new destination

00:26:24,640 --> 00:26:29,039
address and port for this packet

00:26:26,880 --> 00:26:30,240
and that's going to be based on the

00:26:29,039 --> 00:26:32,400
source address so

00:26:30,240 --> 00:26:35,120
if the packet is coming from the ip

00:26:32,400 --> 00:26:37,520
address 1.1.1.1

00:26:35,120 --> 00:26:40,640
then this packet is going to get a

00:26:37,520 --> 00:26:42,720
destination address 2.2.2.2 and the

00:26:40,640 --> 00:26:48,240
destination port is going to be

00:26:42,720 --> 00:26:52,720
uh four four four four three so 443

00:26:48,240 --> 00:26:54,159
um so it's yes allowing you to um

00:26:52,720 --> 00:26:56,320
do to make more fine grains

00:26:54,159 --> 00:26:56,880
configurations to the destination to to

00:26:56,320 --> 00:26:58,960
to do

00:26:56,880 --> 00:27:00,400
source nad or dna because this feature

00:26:58,960 --> 00:27:04,400
also works for

00:27:00,400 --> 00:27:07,200
source not and um

00:27:04,400 --> 00:27:09,360
there is also now support for um you can

00:27:07,200 --> 00:27:11,600
also combine this with name sets

00:27:09,360 --> 00:27:13,200
so you only have to on the left and the

00:27:11,600 --> 00:27:16,320
right hand side of the

00:27:13,200 --> 00:27:20,159
uh the map definition

00:27:16,320 --> 00:27:22,399
you have um you have to specify the data

00:27:20,159 --> 00:27:25,840
type of the

00:27:22,399 --> 00:27:27,360
of the of the key value right

00:27:25,840 --> 00:27:28,960
in this case of the value that you have

00:27:27,360 --> 00:27:31,600
in the map so

00:27:28,960 --> 00:27:32,840
if you specify a concatenation then this

00:27:31,600 --> 00:27:36,240
map

00:27:32,840 --> 00:27:39,600
stores um this

00:27:36,240 --> 00:27:40,720
uh ip and destination port that is going

00:27:39,600 --> 00:27:43,210
to be used for the

00:27:40,720 --> 00:27:46,479
for the mangling

00:27:43,210 --> 00:27:46,479
[Music]

00:27:47,279 --> 00:27:54,399
you can also uh combine this with um

00:27:51,200 --> 00:27:58,000
that is also now support for prefix um

00:27:54,399 --> 00:28:00,799
the prefix knacked or um

00:27:58,000 --> 00:28:02,640
also known in ip tables as netmap right

00:28:00,799 --> 00:28:04,320
netmap is probably a more popular

00:28:02,640 --> 00:28:06,000
concept if you are familiar with iv

00:28:04,320 --> 00:28:06,640
tables right so the way to implement

00:28:06,000 --> 00:28:09,600
netmap

00:28:06,640 --> 00:28:11,440
in in nf tables is to use this new uh

00:28:09,600 --> 00:28:14,840
prefix prefix keyword that you can

00:28:11,440 --> 00:28:17,200
combine with with s nad or dnat

00:28:14,840 --> 00:28:20,720
um so basically

00:28:17,200 --> 00:28:23,760
uh you have to you have to um

00:28:20,720 --> 00:28:25,840
you have to type it's not ip prefix so

00:28:23,760 --> 00:28:29,120
the prefix of the

00:28:25,840 --> 00:28:30,159
the source address is going to to be to

00:28:29,120 --> 00:28:33,520
be mangled

00:28:30,159 --> 00:28:34,640
right and and the remaining bytes are

00:28:33,520 --> 00:28:37,760
going to be left

00:28:34,640 --> 00:28:40,880
untouched right so you can just perform

00:28:37,760 --> 00:28:41,200
prefix prefix mangling of the source of

00:28:40,880 --> 00:28:44,080
the

00:28:41,200 --> 00:28:45,120
destination address you to specify this

00:28:44,080 --> 00:28:48,799
is to specify

00:28:45,120 --> 00:28:52,080
a address and and ace a

00:28:48,799 --> 00:28:54,159
net mask and you can also

00:28:52,080 --> 00:28:55,520
combine there was amazing feature here

00:28:54,159 --> 00:28:57,760
also too that i

00:28:55,520 --> 00:29:00,559
just skipped that is basically that you

00:28:57,760 --> 00:29:03,840
can use prefix and ranges in that

00:29:00,559 --> 00:29:07,039
it's um if you specify as now or dina

00:29:03,840 --> 00:29:08,880
to a range then you are telling the net

00:29:07,039 --> 00:29:12,080
engine

00:29:08,880 --> 00:29:15,200
the source nod or destination not um

00:29:12,080 --> 00:29:18,480
can basically select um the

00:29:15,200 --> 00:29:19,039
whatever ip address in in these in this

00:29:18,480 --> 00:29:22,880
prefix

00:29:19,039 --> 00:29:25,600
or or in a range uh uh please

00:29:22,880 --> 00:29:26,159
that can confuse with the prefix keyword

00:29:25,600 --> 00:29:29,760
and the

00:29:26,159 --> 00:29:31,600
the range and the under usual uh range

00:29:29,760 --> 00:29:33,600
configuration the the usual

00:29:31,600 --> 00:29:35,760
range configurations with no prefix

00:29:33,600 --> 00:29:38,640
keyword it's basically telling the nar

00:29:35,760 --> 00:29:39,279
engine to select to pick one ip address

00:29:38,640 --> 00:29:42,320
from that

00:29:39,279 --> 00:29:44,399
range and then if you specify prefix

00:29:42,320 --> 00:29:47,200
then the prefix is is

00:29:44,399 --> 00:29:47,760
is left untouched so it's it's just no

00:29:47,200 --> 00:29:50,320
sorry

00:29:47,760 --> 00:29:51,919
it's the opposite the prefix is mangled

00:29:50,320 --> 00:29:54,320
and it's only the remaining the

00:29:51,919 --> 00:29:58,159
remaining bytes are

00:29:54,320 --> 00:30:00,080
actually left as is they they are not

00:29:58,159 --> 00:30:01,360
they are not modified so

00:30:00,080 --> 00:30:03,679
it's basically allowing you to make

00:30:01,360 --> 00:30:05,670
one-to-one mappings right

00:30:03,679 --> 00:30:07,360
so what else um

00:30:05,670 --> 00:30:10,559
[Music]

00:30:07,360 --> 00:30:14,320
you can also uh combine this with

00:30:10,559 --> 00:30:17,360
with not intervals um so you could

00:30:14,320 --> 00:30:22,799
specify you could specify an

00:30:17,360 --> 00:30:25,600
interval and and from a um

00:30:22,799 --> 00:30:27,520
an explicit map or set definition in

00:30:25,600 --> 00:30:28,880
this case it's some explicit map

00:30:27,520 --> 00:30:32,880
definition and this map

00:30:28,880 --> 00:30:36,640
definition is um

00:30:32,880 --> 00:30:40,720
it's allowing you to to uh to specify

00:30:36,640 --> 00:30:43,440
that um the interval of possible

00:30:40,720 --> 00:30:44,240
source uh address that is going to be

00:30:43,440 --> 00:30:48,320
used for

00:30:44,240 --> 00:30:52,679
for the net is belongs to the range of

00:30:48,320 --> 00:30:57,039
um of 192

00:30:52,679 --> 00:30:59,679
168 2.2 from 2.2 to 2.4 basically

00:30:57,039 --> 00:31:01,039
so all packets coming from this network

00:30:59,679 --> 00:31:05,919
the

00:31:01,039 --> 00:31:09,200
10 141 then 0

00:31:05,919 --> 00:31:11,679
24 are going to be mangled to

00:31:09,200 --> 00:31:12,559
to any of these ip addresses so so all

00:31:11,679 --> 00:31:14,320
packets leaving

00:31:12,559 --> 00:31:15,840
this network are going to share i'm

00:31:14,320 --> 00:31:18,240
going to use this for

00:31:15,840 --> 00:31:19,279
this actually too it's three two three

00:31:18,240 --> 00:31:22,559
four yes three

00:31:19,279 --> 00:31:23,360
three these three ip addresses for 4d

00:31:22,559 --> 00:31:26,640
net

00:31:23,360 --> 00:31:28,799
so this is in case that you

00:31:26,640 --> 00:31:30,159
you would like to to use the interval

00:31:28,799 --> 00:31:33,279
feature from

00:31:30,159 --> 00:31:35,440
explicit map definition

00:31:33,279 --> 00:31:37,360
uh there is now also support in for sim

00:31:35,440 --> 00:31:40,240
proxy in nf tables so

00:31:37,360 --> 00:31:40,799
the classic the it supports for the

00:31:40,240 --> 00:31:43,360
classic

00:31:40,799 --> 00:31:44,240
approach that is basically mapping one

00:31:43,360 --> 00:31:46,480
to one to

00:31:44,240 --> 00:31:48,159
two ip tables this mapping one two one

00:31:46,480 --> 00:31:51,840
two ap tables have

00:31:48,159 --> 00:31:54,960
limitations basically if you have um

00:31:51,840 --> 00:31:57,679
multiple uh sim proxy configurations

00:31:54,960 --> 00:31:59,760
and you will you will have to add one

00:31:57,679 --> 00:32:02,480
rule for every backend depending

00:31:59,760 --> 00:32:05,360
if if that that back-end has different

00:32:02,480 --> 00:32:08,000
mss windows scale and timestamp values

00:32:05,360 --> 00:32:09,679
so depending on on the diversity the

00:32:08,000 --> 00:32:12,080
amount of different

00:32:09,679 --> 00:32:12,880
um back-ends that you have you might end

00:32:12,080 --> 00:32:16,480
up with with

00:32:12,880 --> 00:32:19,760
lots of rules in ap tables one for each

00:32:16,480 --> 00:32:22,799
um back at back-end configuration right

00:32:19,760 --> 00:32:24,960
so so um to

00:32:22,799 --> 00:32:26,080
to to overcome this limitation and if

00:32:24,960 --> 00:32:28,480
tables provide

00:32:26,080 --> 00:32:29,279
a sim proxy support basically allowing

00:32:28,480 --> 00:32:32,399
you to find

00:32:29,279 --> 00:32:34,000
sim proxy objects that specify this in

00:32:32,399 --> 00:32:37,279
proxy configuration

00:32:34,000 --> 00:32:40,480
one for each kind of backend you have

00:32:37,279 --> 00:32:42,240
one one for each tcpa identity basically

00:32:40,480 --> 00:32:45,279
in the back end you have

00:32:42,240 --> 00:32:47,840
um this tcp information is useful to to

00:32:45,279 --> 00:32:51,440
be included in the scenic packet that is

00:32:47,840 --> 00:32:55,039
uh sent from the firewall to um

00:32:51,440 --> 00:32:58,240
to um on behave of on the on behalf of

00:32:55,039 --> 00:32:59,840
of the back end right so um

00:32:58,240 --> 00:33:01,279
in in case that this connection is the

00:32:59,840 --> 00:33:02,880
intimate right we need to store a

00:33:01,279 --> 00:33:04,799
connection that is that is containing

00:33:02,880 --> 00:33:06,320
all the tcp extensions performing

00:33:04,799 --> 00:33:06,799
extensions that allows this connection

00:33:06,320 --> 00:33:10,320
to

00:33:06,799 --> 00:33:13,519
to evolve fine right while um

00:33:10,320 --> 00:33:15,360
mitigating the the same fluid right

00:33:13,519 --> 00:33:17,120
so well do you basically specify the

00:33:15,360 --> 00:33:20,320
configurations or for your

00:33:17,120 --> 00:33:21,039
the different uh same proxy back-ends

00:33:20,320 --> 00:33:23,760
you have the

00:33:21,039 --> 00:33:25,760
different tcp identities you have and

00:33:23,760 --> 00:33:29,360
based on these combining these with

00:33:25,760 --> 00:33:33,519
maps you can just set the sim proxy

00:33:29,360 --> 00:33:35,600
policy based on on on whatever

00:33:33,519 --> 00:33:38,080
you would like in this example there

00:33:35,600 --> 00:33:40,080
it's based on the source ip address so

00:33:38,080 --> 00:33:43,840
based on the source ip address

00:33:40,080 --> 00:33:47,440
if it's coming from network 1.0 slash 24

00:33:43,840 --> 00:33:48,480
then the https in proxy policy is used

00:33:47,440 --> 00:33:52,240
or otherwise

00:33:48,480 --> 00:33:55,600
in case that it's the 2.0 then other

00:33:52,240 --> 00:33:58,159
sim proxy is used so

00:33:55,600 --> 00:33:59,679
so it's it's instead of in ip tables you

00:33:58,159 --> 00:34:04,240
you need to add one

00:33:59,679 --> 00:34:07,039
one single rule for each uh for each

00:34:04,240 --> 00:34:09,119
network in this case you use a map and

00:34:07,039 --> 00:34:12,480
the map is going to find

00:34:09,119 --> 00:34:14,000
in o1 the the correspondence in proxy

00:34:12,480 --> 00:34:16,560
policy

00:34:14,000 --> 00:34:17,119
so there is also support for custom

00:34:16,560 --> 00:34:20,399
contract

00:34:17,119 --> 00:34:24,159
expectations um you can define

00:34:20,399 --> 00:34:27,040
a custom con expectation um

00:34:24,159 --> 00:34:27,520
expectations are basically um allows you

00:34:27,040 --> 00:34:30,399
to

00:34:27,520 --> 00:34:32,320
uh to tell the firewall that you there

00:34:30,399 --> 00:34:34,639
will be a packet matching what you

00:34:32,320 --> 00:34:38,079
define in the expectation

00:34:34,639 --> 00:34:40,480
in in a in a given time frame

00:34:38,079 --> 00:34:41,280
so in the example there it's defining

00:34:40,480 --> 00:34:44,399
the my

00:34:41,280 --> 00:34:47,119
expect expectation and my expect

00:34:44,399 --> 00:34:47,679
is is basically what we are expecting is

00:34:47,119 --> 00:34:50,800
a tcp

00:34:47,679 --> 00:34:54,720
packet on destination port um

00:34:50,800 --> 00:34:58,160
five four three two and and in one hour

00:34:54,720 --> 00:35:00,880
and um an amount a maximum amount of

00:34:58,160 --> 00:35:02,000
12 expectations can be created so

00:35:00,880 --> 00:35:06,560
basically packets

00:35:02,000 --> 00:35:10,240
if if if a packet a new packet

00:35:06,560 --> 00:35:13,760
uh coming to port um 888

00:35:10,240 --> 00:35:16,160
um is seen

00:35:13,760 --> 00:35:17,760
it's um it's going to create an

00:35:16,160 --> 00:35:19,920
expectation so

00:35:17,760 --> 00:35:21,680
so this is useful for example for for

00:35:19,920 --> 00:35:24,880
knocking or there are also different

00:35:21,680 --> 00:35:27,440
use cases for this um um

00:35:24,880 --> 00:35:30,079
where you would like to uh when you see

00:35:27,440 --> 00:35:31,920
traffic coming to one port and then you

00:35:30,079 --> 00:35:34,400
are expecting to see

00:35:31,920 --> 00:35:36,640
packets coming in in another new port

00:35:34,400 --> 00:35:40,160
and and you would like those packets to

00:35:36,640 --> 00:35:43,040
to to get through by

00:35:40,160 --> 00:35:43,520
by by means of the city state related

00:35:43,040 --> 00:35:46,160
right

00:35:43,520 --> 00:35:47,200
the city state the related state in the

00:35:46,160 --> 00:35:50,240
connection dragon is

00:35:47,200 --> 00:35:50,720
is basically a state that is catching

00:35:50,240 --> 00:35:54,000
for

00:35:50,720 --> 00:35:57,040
packets that are related to to some

00:35:54,000 --> 00:35:57,520
some existing some existing flow right

00:35:57,040 --> 00:35:59,359
this is

00:35:57,520 --> 00:36:00,720
used for foreign connection tracking

00:35:59,359 --> 00:36:03,119
helpers for example

00:36:00,720 --> 00:36:04,800
in case where in ftp when you have

00:36:03,119 --> 00:36:07,119
control and data

00:36:04,800 --> 00:36:09,119
flows separated flow control and and

00:36:07,119 --> 00:36:13,040
data flows and the control flow

00:36:09,119 --> 00:36:14,000
it's announcing where the data flow is

00:36:13,040 --> 00:36:16,240
coming right

00:36:14,000 --> 00:36:17,680
so these packets um the connection

00:36:16,240 --> 00:36:21,280
tracking helper is creating an

00:36:17,680 --> 00:36:24,400
expectation for you and then um it's

00:36:21,280 --> 00:36:28,800
basically tracking that

00:36:24,400 --> 00:36:30,640
packets go into the data uh to the data

00:36:28,800 --> 00:36:32,160
in the data flow are are much in this

00:36:30,640 --> 00:36:35,359
expectation and so they

00:36:32,160 --> 00:36:36,720
those packets are are let um they can go

00:36:35,359 --> 00:36:40,160
through the firewall

00:36:36,720 --> 00:36:42,960
with no problem um so

00:36:40,160 --> 00:36:43,920
it's it's just a this is a way to define

00:36:42,960 --> 00:36:45,440
lazy

00:36:43,920 --> 00:36:48,079
lazy connection tracking helpers

00:36:45,440 --> 00:36:48,640
basically so without without the need of

00:36:48,079 --> 00:36:51,280
adding

00:36:48,640 --> 00:36:53,040
any specific uh connection tracking

00:36:51,280 --> 00:36:53,440
helper right you don't have to you can

00:36:53,040 --> 00:36:55,280
just

00:36:53,440 --> 00:36:56,720
add this rule define the expectation

00:36:55,280 --> 00:36:58,640
policy and and if it

00:36:56,720 --> 00:37:00,079
if you find a matching that creates the

00:36:58,640 --> 00:37:01,599
expectation and

00:37:00,079 --> 00:37:03,359
and that packet is going to go through

00:37:01,599 --> 00:37:06,720
the related state

00:37:03,359 --> 00:37:07,440
so um there is now support of to reject

00:37:06,720 --> 00:37:11,040
packet for

00:37:07,440 --> 00:37:13,200
vlan from the bridge firmly um

00:37:11,040 --> 00:37:16,240
so in case that you do the packet is is

00:37:13,200 --> 00:37:19,280
is is is covered by

00:37:16,240 --> 00:37:21,680
it's in is encapsulated in a in a vlan

00:37:19,280 --> 00:37:24,480
attack in a vegan

00:37:21,680 --> 00:37:26,960
um you can just reject those packets and

00:37:24,480 --> 00:37:27,440
they react the tcp reset packet that is

00:37:26,960 --> 00:37:29,200
going to be

00:37:27,440 --> 00:37:31,040
to be sent back to realitying is going

00:37:29,200 --> 00:37:34,560
to also include the same

00:37:31,040 --> 00:37:37,440
vlan header um

00:37:34,560 --> 00:37:41,440
and there is also um support for

00:37:37,440 --> 00:37:43,599
rejecting traffic from pre-routing

00:37:41,440 --> 00:37:45,200
um which is which allows you to reject

00:37:43,599 --> 00:37:48,000
traffic um

00:37:45,200 --> 00:37:48,960
earlier than than ib tables ip tables

00:37:48,000 --> 00:37:52,640
allows you to

00:37:48,960 --> 00:37:54,800
create traffic from input or or forward

00:37:52,640 --> 00:37:56,320
for routing support was not available so

00:37:54,800 --> 00:37:58,160
now this is this is available

00:37:56,320 --> 00:37:59,860
it's an extra feature in a table that is

00:37:58,160 --> 00:38:02,839
not

00:37:59,860 --> 00:38:04,079
[Music]

00:38:02,839 --> 00:38:07,839
um

00:38:04,079 --> 00:38:11,920
the updates regarding the net family

00:38:07,839 --> 00:38:12,960
are basically um the multi-device chain

00:38:11,920 --> 00:38:16,839
support hardware

00:38:12,960 --> 00:38:20,320
upload and and

00:38:16,839 --> 00:38:22,800
um and these two basically and this

00:38:20,320 --> 00:38:26,320
the multi-device chain in net dev allows

00:38:22,800 --> 00:38:29,520
you to specify multi multiple devices

00:38:26,320 --> 00:38:31,119
so this chain uh in in

00:38:29,520 --> 00:38:33,599
this example chain that you can see

00:38:31,119 --> 00:38:36,960
there it's basically creating a chain

00:38:33,599 --> 00:38:40,079
y and this chain y is

00:38:36,960 --> 00:38:40,480
um register in the ingress hook and you

00:38:40,079 --> 00:38:43,680
have

00:38:40,480 --> 00:38:44,720
eth0 and eph1 that all packets kicking

00:38:43,680 --> 00:38:47,119
in into these two

00:38:44,720 --> 00:38:49,200
interfaces are going to i'm going to

00:38:47,119 --> 00:38:52,320
walk through this chain

00:38:49,200 --> 00:38:53,440
um so this allows you to consolidate

00:38:52,320 --> 00:38:55,839
your rule set so

00:38:53,440 --> 00:38:57,119
you don't have to before this feature

00:38:55,839 --> 00:39:00,160
you have to define

00:38:57,119 --> 00:39:03,200
one uh non-based chain

00:39:00,160 --> 00:39:05,280
with a common roots head for eth0 on one

00:39:03,200 --> 00:39:08,400
and then add a roof to jump from

00:39:05,280 --> 00:39:10,240
it from the adh00 chain to this

00:39:08,400 --> 00:39:11,760
non-base chain and the same thing for an

00:39:10,240 --> 00:39:13,440
adh1 so this is allowed

00:39:11,760 --> 00:39:15,760
allowing you to consolidate your rules a

00:39:13,440 --> 00:39:16,560
bit more by specifying these this a rai

00:39:15,760 --> 00:39:20,880
of

00:39:16,560 --> 00:39:22,240
devices for for this ingress hook

00:39:20,880 --> 00:39:23,839
there is no support for the hardware

00:39:22,240 --> 00:39:26,320
upload as i mentioned before this

00:39:23,839 --> 00:39:29,359
hardware offload support

00:39:26,320 --> 00:39:32,480
it needs to be turned on in it tool

00:39:29,359 --> 00:39:34,720
um there is a toggle to enable it

00:39:32,480 --> 00:39:36,480
in the future we are planning to

00:39:34,720 --> 00:39:40,240
basically

00:39:36,480 --> 00:39:42,480
um um turn on this if tool toggle

00:39:40,240 --> 00:39:43,680
without requiring the user to make it

00:39:42,480 --> 00:39:45,520
explicitly

00:39:43,680 --> 00:39:47,680
because in internet tables you have this

00:39:45,520 --> 00:39:49,440
this flag offload that is placed

00:39:47,680 --> 00:39:51,839
bolt in in the presentation that you can

00:39:49,440 --> 00:39:52,720
see there this flag offload is telling

00:39:51,839 --> 00:39:54,960
you that this

00:39:52,720 --> 00:39:56,000
rule set this this rule set in the

00:39:54,960 --> 00:39:59,200
ingress chain is not

00:39:56,000 --> 00:40:01,920
actually going to run in software in in

00:39:59,200 --> 00:40:05,440
first place it will run in hardware

00:40:01,920 --> 00:40:06,480
and so the filtering is happening in in

00:40:05,440 --> 00:40:09,359
hardware so

00:40:06,480 --> 00:40:10,720
there all packets go into ip address

00:40:09,359 --> 00:40:14,079
00:40:10,720 --> 00:40:18,560
are going to be drop in case that

00:40:14,079 --> 00:40:21,040
um so it's basically providing you

00:40:18,560 --> 00:40:22,720
an alternative to the existing pc

00:40:21,040 --> 00:40:25,040
hardware upload support for filtering

00:40:22,720 --> 00:40:26,880
traffic from nf tables

00:40:25,040 --> 00:40:28,720
um this is this is this packet is

00:40:26,880 --> 00:40:30,800
dropping the nic so it's it's an it's a

00:40:28,720 --> 00:40:33,920
real hardware offload

00:40:30,800 --> 00:40:37,920
um support for um for the

00:40:33,920 --> 00:40:38,560
family is is um relatively limited at

00:40:37,920 --> 00:40:40,079
this point

00:40:38,560 --> 00:40:42,240
is basically you can match your packet

00:40:40,079 --> 00:40:44,560
header fields and only in the meta

00:40:42,240 --> 00:40:46,319
information the input interface

00:40:44,560 --> 00:40:47,760
and then actions available are

00:40:46,319 --> 00:40:49,359
acceptable drop

00:40:47,760 --> 00:40:51,359
and then you can also duplicate the

00:40:49,359 --> 00:40:52,640
packet or mirror mid-road the packet to

00:40:51,359 --> 00:40:55,359
a given port through

00:40:52,640 --> 00:40:56,000
forward or duplicate the packet through

00:40:55,359 --> 00:40:59,040
through the

00:40:56,000 --> 00:41:00,560
dope action uh one

00:40:59,040 --> 00:41:02,160
important thing to mention about the

00:41:00,560 --> 00:41:04,839
hardware offload is that

00:41:02,160 --> 00:41:06,400
chain priority needs to be set between

00:41:04,839 --> 00:41:09,839
one and

00:41:06,400 --> 00:41:12,960
and two pow uh 2016

00:41:09,839 --> 00:41:14,079
um this is something that has been

00:41:12,960 --> 00:41:16,160
inherited from

00:41:14,079 --> 00:41:17,599
from the tc infrastructure that is

00:41:16,160 --> 00:41:21,440
basically only having

00:41:17,599 --> 00:41:24,720
this amount of priorities and and once

00:41:21,440 --> 00:41:26,640
drivers are updated to support or if

00:41:24,720 --> 00:41:28,640
hardware support more priorities it

00:41:26,640 --> 00:41:30,560
should be possible to remove these

00:41:28,640 --> 00:41:32,000
this limitation so in case you give a

00:41:30,560 --> 00:41:34,640
test to

00:41:32,000 --> 00:41:35,839
to the hardware offload infrastructure

00:41:34,640 --> 00:41:36,640
just make sure that your chain

00:41:35,839 --> 00:41:39,040
definition

00:41:36,640 --> 00:41:39,920
when you set the set on the flag offload

00:41:39,040 --> 00:41:43,680
is between

00:41:39,920 --> 00:41:45,920
1 and 2016 i've been testing this with

00:41:43,680 --> 00:41:49,200
the milnox connect x5 card and it's

00:41:45,920 --> 00:41:51,380
it's working quite quite fine it's

00:41:49,200 --> 00:41:52,880
um what else um

00:41:51,380 --> 00:41:56,480
[Music]

00:41:52,880 --> 00:41:58,960
enough tables flow tables um

00:41:56,480 --> 00:42:01,599
now have content support so you have to

00:41:58,960 --> 00:42:04,880
explicitly tell that you would like to

00:42:01,599 --> 00:42:06,720
to to account for um

00:42:04,880 --> 00:42:08,800
for packets and byte following the fast

00:42:06,720 --> 00:42:09,680
path you only have to when defining the

00:42:08,800 --> 00:42:13,040
flow table

00:42:09,680 --> 00:42:14,319
you have to specify that this counter

00:42:13,040 --> 00:42:16,319
keyword

00:42:14,319 --> 00:42:18,319
and you can list these counters through

00:42:16,319 --> 00:42:21,760
contract minus l

00:42:18,319 --> 00:42:24,079
there is also support for updating

00:42:21,760 --> 00:42:25,839
uh flow table devices this support for

00:42:24,079 --> 00:42:28,400
updating flow table devices allows you

00:42:25,839 --> 00:42:29,359
to add new devices to an existing float

00:42:28,400 --> 00:42:32,640
table this is very

00:42:29,359 --> 00:42:33,040
useful for dynamic interfaces if you

00:42:32,640 --> 00:42:36,480
have

00:42:33,040 --> 00:42:37,839
a pvp interface or or some kind of

00:42:36,480 --> 00:42:40,400
interface that is dynamically

00:42:37,839 --> 00:42:41,599
created then you can add these devices

00:42:40,400 --> 00:42:45,440
to

00:42:41,599 --> 00:42:48,400
to your floor table through just nft

00:42:45,440 --> 00:42:50,240
add flow table and specify the new

00:42:48,400 --> 00:42:51,920
devices that you would like to see

00:42:50,240 --> 00:42:53,359
to be part of of the flow table

00:42:51,920 --> 00:42:55,760
definition so

00:42:53,359 --> 00:42:56,640
now now there is support for updating

00:42:55,760 --> 00:42:59,520
flow tables

00:42:56,640 --> 00:43:00,480
and there is the descriptive

00:42:59,520 --> 00:43:03,760
capabilities of

00:43:00,480 --> 00:43:08,160
the tables has been enhanced

00:43:03,760 --> 00:43:10,880
um variables can be

00:43:08,160 --> 00:43:12,480
now used in in chain definitions and you

00:43:10,880 --> 00:43:15,680
if you would like to have a

00:43:12,480 --> 00:43:16,960
variable to define the default policy

00:43:15,680 --> 00:43:19,480
for your chain

00:43:16,960 --> 00:43:21,280
you can just use it the same thing for

00:43:19,480 --> 00:43:22,960
priorities

00:43:21,280 --> 00:43:26,000
uh some people like to keep all this

00:43:22,960 --> 00:43:29,040
variable in some common

00:43:26,000 --> 00:43:33,040
dot nft file and then have

00:43:29,040 --> 00:43:36,079
some column um some common

00:43:33,040 --> 00:43:39,359
rule set for for different boxes

00:43:36,079 --> 00:43:40,240
and and just update the the variables

00:43:39,359 --> 00:43:43,520
according to

00:43:40,240 --> 00:43:47,119
your needs or what to to

00:43:43,520 --> 00:43:49,200
um yes basically that so the empty sets

00:43:47,119 --> 00:43:50,400
in variables it's something that allows

00:43:49,200 --> 00:43:53,040
you to

00:43:50,400 --> 00:43:55,119
to refer to variables that contains null

00:43:53,040 --> 00:43:57,680
entries um

00:43:55,119 --> 00:43:58,640
well the actually the the in this

00:43:57,680 --> 00:44:01,440
example there

00:43:58,640 --> 00:44:03,599
you have to you have to make sure that

00:44:01,440 --> 00:44:05,359
at least one of the variables

00:44:03,599 --> 00:44:07,119
contain one single entry it's not

00:44:05,359 --> 00:44:11,040
possible to use a

00:44:07,119 --> 00:44:13,680
full empty set definition

00:44:11,040 --> 00:44:15,280
in the rule so if you specify tcpd port

00:44:13,680 --> 00:44:17,760
and curly brace and then

00:44:15,280 --> 00:44:19,200
closing curly brace that will not work

00:44:17,760 --> 00:44:21,520
so but in this case

00:44:19,200 --> 00:44:23,839
the nf table is merging these two

00:44:21,520 --> 00:44:26,079
variable definitions that contain sets

00:44:23,839 --> 00:44:28,079
and it's since the set is not empty

00:44:26,079 --> 00:44:30,000
there is no no problem so

00:44:28,079 --> 00:44:31,920
here just in case you you would like to

00:44:30,000 --> 00:44:34,800
have a way to

00:44:31,920 --> 00:44:35,359
to extend the the base a load incoming

00:44:34,800 --> 00:44:37,680
tcp

00:44:35,359 --> 00:44:39,040
ports you can just specify this this

00:44:37,680 --> 00:44:42,560
empty

00:44:39,040 --> 00:44:45,839
set definition so it's something that um

00:44:42,560 --> 00:44:47,920
yes usability it's usability enhancement

00:44:45,839 --> 00:44:50,240
more usability enhancement

00:44:47,920 --> 00:44:52,560
regarding the use of variables in nft

00:44:50,240 --> 00:44:55,200
you can

00:44:52,560 --> 00:44:57,599
you can specify now variables in in log

00:44:55,200 --> 00:45:00,319
prefix so in case that you have

00:44:57,599 --> 00:45:02,640
some login action according to some

00:45:00,319 --> 00:45:05,680
criteria

00:45:02,640 --> 00:45:06,480
to match packets uh so you can you can

00:45:05,680 --> 00:45:10,240
use these

00:45:06,480 --> 00:45:12,720
this um these

00:45:10,240 --> 00:45:13,839
variables um there is also variables

00:45:12,720 --> 00:45:17,040
that you can use in

00:45:13,839 --> 00:45:19,200
in device um

00:45:17,040 --> 00:45:20,220
in device names and device definitions

00:45:19,200 --> 00:45:21,520
in in

00:45:20,220 --> 00:45:24,000
[Music]

00:45:21,520 --> 00:45:25,920
in case that you you have an ingress

00:45:24,000 --> 00:45:29,440
chain

00:45:25,920 --> 00:45:34,079
um and one new feature

00:45:29,440 --> 00:45:34,400
coming in in since 5.9 is the definition

00:45:34,079 --> 00:45:36,319
of

00:45:34,400 --> 00:45:38,240
implicit chain bindings the implicit

00:45:36,319 --> 00:45:41,280
chain bindings allows you

00:45:38,240 --> 00:45:46,480
to group multiple rules

00:45:41,280 --> 00:45:48,480
into um into one single implicit chain

00:45:46,480 --> 00:45:49,520
this implicit chain well as you can see

00:45:48,480 --> 00:45:52,720
there you can

00:45:49,520 --> 00:45:56,640
you can specify jump or go to as usual

00:45:52,720 --> 00:45:59,119
um and then basically um

00:45:56,640 --> 00:45:59,680
you are restricting the jump to to

00:45:59,119 --> 00:46:02,560
whatever

00:45:59,680 --> 00:46:03,280
selector uh that comes before in this

00:46:02,560 --> 00:46:05,119
case

00:46:03,280 --> 00:46:07,359
there in the example you can see that

00:46:05,119 --> 00:46:10,640
this destination tcp

00:46:07,359 --> 00:46:12,319
or 22 uh so all packets going to the

00:46:10,640 --> 00:46:14,000
destination port are going to jump to

00:46:12,319 --> 00:46:15,440
this implicit chain and there you can

00:46:14,000 --> 00:46:17,520
keep the

00:46:15,440 --> 00:46:18,480
the the rules are going to to be

00:46:17,520 --> 00:46:20,880
evaluated

00:46:18,480 --> 00:46:22,240
it's another and and usability

00:46:20,880 --> 00:46:24,640
enhancement

00:46:22,240 --> 00:46:26,800
um of course if you prefer to define

00:46:24,640 --> 00:46:28,800
explicit chains you can just define

00:46:26,800 --> 00:46:31,040
an explicit change and jump to this

00:46:28,800 --> 00:46:35,760
change the implicit chains cannot be

00:46:31,040 --> 00:46:38,319
updated so it's something that

00:46:35,760 --> 00:46:39,680
once defined you have to remove the rule

00:46:38,319 --> 00:46:43,839
or replace the rule to

00:46:39,680 --> 00:46:47,599
to update it

00:46:43,839 --> 00:46:48,480
um there is now descriptions for data

00:46:47,599 --> 00:46:50,720
types so

00:46:48,480 --> 00:46:51,599
you could use nft described before you

00:46:50,720 --> 00:46:55,599
could use it for

00:46:51,599 --> 00:46:59,520
selectors so you can do nft describe ip

00:46:55,599 --> 00:47:03,040
as add artist for to describe the

00:46:59,520 --> 00:47:06,079
the the ip source address

00:47:03,040 --> 00:47:08,000
keyword the ib source address selector

00:47:06,079 --> 00:47:09,599
now you can also use it for data types

00:47:08,000 --> 00:47:12,720
if you specify ip

00:47:09,599 --> 00:47:15,280
for underscore adr

00:47:12,720 --> 00:47:17,040
then it's going to describe the the the

00:47:15,280 --> 00:47:18,000
kind of data type this is and telling

00:47:17,040 --> 00:47:21,200
you how many

00:47:18,000 --> 00:47:22,240
bits are expected and if there is a name

00:47:21,200 --> 00:47:24,240
for it

00:47:22,240 --> 00:47:26,240
and if there is any kind of base type in

00:47:24,240 --> 00:47:29,359
this case integer

00:47:26,240 --> 00:47:29,920
um there is now also support for line

00:47:29,359 --> 00:47:33,119
noise

00:47:29,920 --> 00:47:35,280
uh as a replacement for a

00:47:33,119 --> 00:47:37,440
lip red line in case you would like you

00:47:35,280 --> 00:47:38,079
would like to compile enough tables some

00:47:37,440 --> 00:47:41,520
people

00:47:38,079 --> 00:47:44,720
um like to use this this

00:47:41,520 --> 00:47:48,000
alternative um in

00:47:44,720 --> 00:47:50,559
in embedded environments where

00:47:48,000 --> 00:47:51,200
there are restrictions or of the the

00:47:50,559 --> 00:47:53,760
limitations

00:47:51,200 --> 00:47:54,800
in terms of storage and you would like

00:47:53,760 --> 00:47:57,280
to have a

00:47:54,800 --> 00:47:58,160
a lightweight ammo lightweight um

00:47:57,280 --> 00:48:01,380
library for

00:47:58,160 --> 00:48:03,040
auto completion and and for the

00:48:01,380 --> 00:48:04,960
[Music]

00:48:03,040 --> 00:48:07,119
uh basically for the for the interactive

00:48:04,960 --> 00:48:08,800
mode of nft that you can you can invoke

00:48:07,119 --> 00:48:12,240
when when calling nft

00:48:08,800 --> 00:48:14,800
with minus i it's like anything uh

00:48:12,240 --> 00:48:16,160
minus i gets you into the native and a

00:48:14,800 --> 00:48:20,160
tables shell

00:48:16,160 --> 00:48:22,319
and and and that that is using the the

00:48:20,160 --> 00:48:24,400
red line library and also the line noise

00:48:22,319 --> 00:48:27,599
so there is also

00:48:24,400 --> 00:48:31,920
a few updates on nft lb

00:48:27,599 --> 00:48:35,119
so um two releases 0.5 and 0.6

00:48:31,920 --> 00:48:38,480
the 0.6 this

00:48:35,119 --> 00:48:39,200
nftlb is is the nf table load balancer

00:48:38,480 --> 00:48:42,720
it's a

00:48:39,200 --> 00:48:43,920
software that you can configure for load

00:48:42,720 --> 00:48:46,240
balancing

00:48:43,920 --> 00:48:48,400
the main updates that you have in these

00:48:46,240 --> 00:48:50,880
releases are basically the contract

00:48:48,400 --> 00:48:53,200
offload support through flow tables and

00:48:50,880 --> 00:48:54,960
now the flow table can be enabled from

00:48:53,200 --> 00:48:57,920
nft lp

00:48:54,960 --> 00:49:00,839
um there is ingress support for funds

00:48:57,920 --> 00:49:03,839
there is also dual stack dsr and

00:49:00,839 --> 00:49:06,800
statelessnet uh the improved

00:49:03,839 --> 00:49:08,720
back-end health checks just basically to

00:49:06,800 --> 00:49:09,680
make sure that the the back-ends are

00:49:08,720 --> 00:49:12,800
still available

00:49:09,680 --> 00:49:15,200
and and there is a rest api that you can

00:49:12,800 --> 00:49:17,359
use to to send incremental updates to

00:49:15,200 --> 00:49:20,480
your nft lb configurations

00:49:17,359 --> 00:49:25,200
that has been also extended

00:49:20,480 --> 00:49:25,200
and then yes last but not least

00:49:25,359 --> 00:49:29,119
is the just a discussion about some

00:49:28,160 --> 00:49:31,520
topics that

00:49:29,119 --> 00:49:33,200
have uh come up in the mailing list

00:49:31,520 --> 00:49:36,559
regarding the egress hook

00:49:33,200 --> 00:49:38,559
and the ifp ingress hook so

00:49:36,559 --> 00:49:40,640
basically regarding the erase hook there

00:49:38,559 --> 00:49:44,319
is there is um

00:49:40,640 --> 00:49:47,520
there is a number of use cases where um

00:49:44,319 --> 00:49:49,280
this new hook can be very useful for for

00:49:47,520 --> 00:49:51,359
us we've been discussing this internally

00:49:49,280 --> 00:49:53,599
in the in the core team

00:49:51,359 --> 00:49:56,400
and it's something that we would really

00:49:53,599 --> 00:49:58,079
like to have the concepts that have been

00:49:56,400 --> 00:49:59,839
right so far on the main list are

00:49:58,079 --> 00:50:03,520
focused on performance

00:49:59,839 --> 00:50:08,160
um keeping keeping the hook behind

00:50:03,520 --> 00:50:10,160
behind the static key is actually um

00:50:08,160 --> 00:50:12,960
it's actually hiding hiding any

00:50:10,160 --> 00:50:15,040
performance impact on this so it's

00:50:12,960 --> 00:50:16,480
it's basically it's actually very hard

00:50:15,040 --> 00:50:19,920
to measure

00:50:16,480 --> 00:50:24,079
um if there is anything any any

00:50:19,920 --> 00:50:27,200
real impact on this it's

00:50:24,079 --> 00:50:29,040
um so this this all this

00:50:27,200 --> 00:50:31,440
benchmarking was done already when

00:50:29,040 --> 00:50:33,359
introducing the ingress hook

00:50:31,440 --> 00:50:35,200
and the conclusion the conclusion was

00:50:33,359 --> 00:50:37,920
that performance was not an issue

00:50:35,200 --> 00:50:39,040
and if you don't use it you don't get

00:50:37,920 --> 00:50:41,680
any

00:50:39,040 --> 00:50:43,200
any any impact and then the other

00:50:41,680 --> 00:50:46,960
concern was about

00:50:43,200 --> 00:50:48,400
um interactions with other software

00:50:46,960 --> 00:50:50,319
but this is something that can be easily

00:50:48,400 --> 00:50:53,760
debunked by the user and

00:50:50,319 --> 00:50:54,400
if the user as we discussed so far is

00:50:53,760 --> 00:50:56,480
like

00:50:54,400 --> 00:50:57,839
if the user does don't like don't like

00:50:56,480 --> 00:50:58,800
to don't like that and filter

00:50:57,839 --> 00:51:00,880
infrastructure i

00:50:58,800 --> 00:51:02,960
would like to prefer will like would

00:51:00,880 --> 00:51:04,319
like to or would prefer to use any

00:51:02,960 --> 00:51:07,839
anything else

00:51:04,319 --> 00:51:09,680
um so it's just a matter of compiling

00:51:07,839 --> 00:51:11,520
out the next photo support or just

00:51:09,680 --> 00:51:13,839
making sure that

00:51:11,520 --> 00:51:15,680
it the user installs no software they

00:51:13,839 --> 00:51:16,720
use that filter so that's not a problem

00:51:15,680 --> 00:51:19,040
at all so

00:51:16,720 --> 00:51:20,079
there are different several possible

00:51:19,040 --> 00:51:24,480
solutions and

00:51:20,079 --> 00:51:27,440
in any case the the um

00:51:24,480 --> 00:51:28,480
the outcome is that if the user does not

00:51:27,440 --> 00:51:31,520
use this new hook

00:51:28,480 --> 00:51:32,640
there is no uh the performance impact is

00:51:31,520 --> 00:51:34,480
negligible is

00:51:32,640 --> 00:51:36,160
is actually very hard to measure there

00:51:34,480 --> 00:51:39,599
is another

00:51:36,160 --> 00:51:41,680
ifp ingress hook for some use case

00:51:39,599 --> 00:51:44,079
that has been has brought my uh has

00:51:41,680 --> 00:51:47,680
attracted my attention basically just to

00:51:44,079 --> 00:51:51,599
um to allow you to um

00:51:47,680 --> 00:51:54,079
to combine shaping both for um

00:51:51,599 --> 00:51:55,119
for ingress and egress and it's

00:51:54,079 --> 00:51:57,440
something that also

00:51:55,119 --> 00:51:59,280
i might i might also post patches

00:51:57,440 --> 00:52:02,319
regarding to to include this

00:51:59,280 --> 00:52:05,200
this ifp grasshook support so that's

00:52:02,319 --> 00:52:08,559
basically all what i have

00:52:05,200 --> 00:52:10,000
thank you so much for attending this

00:52:08,559 --> 00:52:13,119
presentation

00:52:10,000 --> 00:52:19,839
and that's basically

00:52:13,119 --> 00:52:19,839
all i have

00:52:28,160 --> 00:52:30,240

YouTube URL: https://www.youtube.com/watch?v=GqGGo4svj7s


