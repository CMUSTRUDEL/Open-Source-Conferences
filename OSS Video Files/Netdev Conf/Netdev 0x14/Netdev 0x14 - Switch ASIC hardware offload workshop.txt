Title: Netdev 0x14 - Switch ASIC hardware offload workshop
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Chairs: Roopa Prabhu and Jiri Pirko

More info: https://netdevconf.info/0x14/session.html?workshop-switch-ASIC-hardware-offload

Date: Friday, August 14, 2020

Roopa Prabhu and Jiri Pirko chair the netdev 0x14 Switch ASIC hardware
offload workshop.

Network Operating Systems(NOS) based on Linux-native hardware offload
for network switching ASICs continue to gain traction.
Recent inductees includes the announced project DENT [1] that brings
together switch ASIC vendors, distributors, system integrators and users.

This workshop is similar to previous netdevconf switchdev workshops
with a larger focus on community discussions around building an
Open Linux kernel switchdev based Network Operating System.

Workshop topics (Work in progress):

- Discuss switchdev driver updates since last netdev0x13:
          - Mellanox mlxsw driver updates
- New Networking features and use-cases
- Open issues and challenges
- New vendors
- Supporting new features down the pike:
      - Eg: EVPN-MH, port security, dynamic NAT and others
- Operationalizing Linux networking
       Automation and DevOps

[1] https://www.linuxfoundation.org/press-release/2019/12/dent-launches-to-simplify-enterprise-edge-networking-software/
Captions: 
	00:00:03,439 --> 00:00:07,440
so hi

00:00:04,240 --> 00:00:11,519
um my name is ido i co-maintain the

00:00:07,440 --> 00:00:17,119
lxsw driver together with uh jerry pilko

00:00:11,519 --> 00:00:20,640
working at nvidia previously menolox

00:00:17,119 --> 00:00:24,080
so this presentation is divided into two

00:00:20,640 --> 00:00:27,199
planned features and recently added

00:00:24,080 --> 00:00:28,720
features that are already upstream

00:00:27,199 --> 00:00:30,800
so i want to start with the plan

00:00:28,720 --> 00:00:33,430
features because i think it's a better

00:00:30,800 --> 00:00:34,800
use of our time

00:00:33,430 --> 00:00:37,120
[Music]

00:00:34,800 --> 00:00:37,120
right

00:00:37,840 --> 00:00:40,960
okay so the first thing i want to talk

00:00:39,840 --> 00:00:44,399
about is a

00:00:40,960 --> 00:00:47,920
device metrics this is the outcome

00:00:44,399 --> 00:00:50,800
of uh two day hackathon we recently had

00:00:47,920 --> 00:00:51,600
in the company on monday and tuesday

00:00:50,800 --> 00:00:53,199
something

00:00:51,600 --> 00:00:55,760
i worked on together with amit and

00:00:53,199 --> 00:00:59,359
daniel from our team

00:00:55,760 --> 00:01:00,960
so the problem we are trying to solve is

00:00:59,359 --> 00:01:03,280
that

00:01:00,960 --> 00:01:06,720
we want to improve the debuggability and

00:01:03,280 --> 00:01:10,240
visibility of our hardware under linux

00:01:06,720 --> 00:01:11,760
now the issue is is that most of the

00:01:10,240 --> 00:01:13,920
metrics today in the networking

00:01:11,760 --> 00:01:15,360
subsystem are

00:01:13,920 --> 00:01:18,640
negative centric which means that they

00:01:15,360 --> 00:01:20,640
are teleport and not tell device

00:01:18,640 --> 00:01:21,840
uh and they are usually exposed via

00:01:20,640 --> 00:01:25,439
either ultimately

00:01:21,840 --> 00:01:27,280
or eth2 in addition there are

00:01:25,439 --> 00:01:28,799
usually not configurable which means

00:01:27,280 --> 00:01:32,079
that you can't enable

00:01:28,799 --> 00:01:32,720
or disable these metrics uh which can

00:01:32,079 --> 00:01:35,840
become an

00:01:32,720 --> 00:01:38,479
issue if enabling this metrics

00:01:35,840 --> 00:01:39,439
adds latency or consume hardware

00:01:38,479 --> 00:01:42,479
resources

00:01:39,439 --> 00:01:42,479
such as counters

00:01:43,360 --> 00:01:49,520
and also we

00:01:47,040 --> 00:01:51,439
at least in the spectrum asics we have

00:01:49,520 --> 00:01:55,520
instagram agents that

00:01:51,439 --> 00:01:58,640
allows us to sample various parameters

00:01:55,520 --> 00:02:00,640
such as txq like over

00:01:58,640 --> 00:02:02,320
1 million times per second and then we

00:02:00,640 --> 00:02:06,240
can get

00:02:02,320 --> 00:02:08,560
a histogram of the length of the tx skew

00:02:06,240 --> 00:02:09,520
and this is something that you can

00:02:08,560 --> 00:02:12,000
probably achieve

00:02:09,520 --> 00:02:12,959
in the software data path using bpf

00:02:12,000 --> 00:02:14,959
because

00:02:12,959 --> 00:02:16,239
each time you send a packet you get an

00:02:14,959 --> 00:02:17,440
event and you can calculate the

00:02:16,239 --> 00:02:18,879
histograms

00:02:17,440 --> 00:02:20,879
but we don't have the stability with

00:02:18,879 --> 00:02:23,599
hardware offload because the cpu does

00:02:20,879 --> 00:02:26,959
not see the packets

00:02:23,599 --> 00:02:30,319
um and another thing is that

00:02:26,959 --> 00:02:32,560
the metrics are usually hardware

00:02:30,319 --> 00:02:35,680
specific and they are not mapped into

00:02:32,560 --> 00:02:38,959
any relevant software objects

00:02:35,680 --> 00:02:39,360
so for example uh in a spectrum asic we

00:02:38,959 --> 00:02:42,959
have

00:02:39,360 --> 00:02:45,200
a single hardware vita which is able

00:02:42,959 --> 00:02:46,720
doing encapsulation and encapsulation of

00:02:45,200 --> 00:02:49,599
the exam packets

00:02:46,720 --> 00:02:50,160
and it is and it has metrics of its own

00:02:49,599 --> 00:02:52,400
and

00:02:50,160 --> 00:02:53,200
but this feature is is logically mapped

00:02:52,400 --> 00:02:57,040
by the

00:02:53,200 --> 00:02:59,440
driver into various weak slanted devices

00:02:57,040 --> 00:03:00,400
so exposing the metrics of this single

00:02:59,440 --> 00:03:03,519
hardware reader

00:03:00,400 --> 00:03:06,560
via multiple uh

00:03:03,519 --> 00:03:08,480
that devices would be uh both inaccurate

00:03:06,560 --> 00:03:10,000
and confusing

00:03:08,480 --> 00:03:11,519
another example is something we have in

00:03:10,000 --> 00:03:14,159
spectrum 2 which is

00:03:11,519 --> 00:03:14,560
an algorithmic tcam so you know we have

00:03:14,159 --> 00:03:17,760
this

00:03:14,560 --> 00:03:20,720
nice user interface to push

00:03:17,760 --> 00:03:23,280
filters to the kernel dc filters and

00:03:20,720 --> 00:03:23,280
remove them

00:03:23,519 --> 00:03:31,440
but underneath it's completely

00:03:28,400 --> 00:03:33,360
it's very complicated so

00:03:31,440 --> 00:03:34,720
in inspector one we we have an actual

00:03:33,360 --> 00:03:37,840
circuit tcam

00:03:34,720 --> 00:03:40,239
to which we push this uh acl loads but

00:03:37,840 --> 00:03:40,959
in spectrum two in order to improve the

00:03:40,239 --> 00:03:43,120
scale

00:03:40,959 --> 00:03:44,840
and reduce the power consumption we have

00:03:43,120 --> 00:03:48,239
an algorithm

00:03:44,840 --> 00:03:49,920
and it's very it's relatively complex

00:03:48,239 --> 00:03:52,560
and currently we have like zero

00:03:49,920 --> 00:03:54,640
visibility into

00:03:52,560 --> 00:03:56,560
uh if what we are doing is correct or

00:03:54,640 --> 00:03:58,000
incorrect or efficient or inefficient so

00:03:56,560 --> 00:03:59,840
we have this metrics that

00:03:58,000 --> 00:04:03,280
we need to be able to expose the user

00:03:59,840 --> 00:04:05,280
space in order to debug our code

00:04:03,280 --> 00:04:08,400
and the fair example is histograms which

00:04:05,280 --> 00:04:08,400
i already explained

00:04:08,720 --> 00:04:12,400
so if you are a candle developer you

00:04:11,439 --> 00:04:14,400
would usually say

00:04:12,400 --> 00:04:15,519
okay so just expose it using debug

00:04:14,400 --> 00:04:18,079
effects right

00:04:15,519 --> 00:04:19,359
but if you are a networking person you

00:04:18,079 --> 00:04:22,720
know this is

00:04:19,359 --> 00:04:25,360
unacceptable uh and i think

00:04:22,720 --> 00:04:26,800
rightfully so uh first of all if we do

00:04:25,360 --> 00:04:28,960
it using debug effects it's

00:04:26,800 --> 00:04:31,600
driver specific which means any other

00:04:28,960 --> 00:04:34,240
drivers needs to

00:04:31,600 --> 00:04:35,199
for example expose some hardware

00:04:34,240 --> 00:04:38,560
instagram agents

00:04:35,199 --> 00:04:40,880
is going to duplicate the same interface

00:04:38,560 --> 00:04:42,560
and it's also not a stable interface it

00:04:40,880 --> 00:04:45,280
can come and go and you can see

00:04:42,560 --> 00:04:48,390
david miller saying that he wants to

00:04:45,280 --> 00:04:49,840
remove some debug fsn for himself

00:04:48,390 --> 00:04:53,040
[Music]

00:04:49,840 --> 00:04:56,880
so this is a quote from david miller

00:04:53,040 --> 00:04:57,919
our leader that he instead would like to

00:04:56,880 --> 00:05:00,639
see

00:04:57,919 --> 00:05:01,360
uh a web type and generic interface to

00:05:00,639 --> 00:05:04,880
expose

00:05:01,360 --> 00:05:07,199
uh this stuff to user space and

00:05:04,880 --> 00:05:08,880
i i think that our proposed solution

00:05:07,199 --> 00:05:11,919
answer this

00:05:08,880 --> 00:05:15,199
so the overall overview is that we

00:05:11,919 --> 00:05:18,320
extended the kernel to allow

00:05:15,199 --> 00:05:21,280
device drivers to create and destroy

00:05:18,320 --> 00:05:22,160
i mean to register the metrics with

00:05:21,280 --> 00:05:25,199
devlin

00:05:22,160 --> 00:05:26,880
which as you know is a subsystem within

00:05:25,199 --> 00:05:29,360
the linux kernel to

00:05:26,880 --> 00:05:30,880
manage devices as opposed to individual

00:05:29,360 --> 00:05:34,960
ports

00:05:30,880 --> 00:05:38,560
uh and then devlink is exposing uh

00:05:34,960 --> 00:05:41,520
this metrics over net link to user space

00:05:38,560 --> 00:05:44,080
so we extended uh ipl 2 then

00:05:41,520 --> 00:05:47,120
specifically the dev link executable

00:05:44,080 --> 00:05:48,000
to query and configure this metrics from

00:05:47,120 --> 00:05:50,880
the kernel

00:05:48,000 --> 00:05:52,240
and we also wrote a prometeuse exporter

00:05:50,880 --> 00:05:54,800
that exposed that

00:05:52,240 --> 00:05:56,400
exports this metrics over http to

00:05:54,800 --> 00:05:59,680
committees

00:05:56,400 --> 00:06:03,280
so to give more details

00:05:59,680 --> 00:06:03,759
um at the top is the proposed interface

00:06:03,280 --> 00:06:06,800
what we

00:06:03,759 --> 00:06:08,880
currently have implemented and

00:06:06,800 --> 00:06:11,280
probably next week i will clean up the

00:06:08,880 --> 00:06:13,919
code and i will send an rfc

00:06:11,280 --> 00:06:16,319
uh in case you have comments so

00:06:13,919 --> 00:06:18,840
currently the the only type of metrics

00:06:16,319 --> 00:06:21,520
is a counter

00:06:18,840 --> 00:06:22,560
but in the future we would like to add

00:06:21,520 --> 00:06:25,680
also histograms

00:06:22,560 --> 00:06:29,840
so you can uh query the metrics and

00:06:25,680 --> 00:06:32,319
you can also group them together and

00:06:29,840 --> 00:06:32,880
the reason that we added this grouping

00:06:32,319 --> 00:06:35,840
is

00:06:32,880 --> 00:06:36,479
that so later on you could uh ask the

00:06:35,840 --> 00:06:38,800
kernel

00:06:36,479 --> 00:06:40,240
for a filtered dumb like let's say you

00:06:38,800 --> 00:06:42,319
have a lot of counter so you don't want

00:06:40,240 --> 00:06:44,319
to send multiple networking requests

00:06:42,319 --> 00:06:46,080
give me this counter leave me this

00:06:44,319 --> 00:06:47,680
metric this method this metric and then

00:06:46,080 --> 00:06:50,639
get multiple responses

00:06:47,680 --> 00:06:51,280
you want to send one request and get a

00:06:50,639 --> 00:06:53,520
single

00:06:51,280 --> 00:06:55,919
network message with all the relevant

00:06:53,520 --> 00:06:55,919
methods

00:06:56,080 --> 00:07:00,240
so in bold at the bottom

00:07:00,479 --> 00:07:03,520
yeah at the bottom so we're involved we

00:07:02,720 --> 00:07:06,639
have the

00:07:03,520 --> 00:07:10,319
future extensions that we would like to

00:07:06,639 --> 00:07:11,199
eventually do so first of all to enable

00:07:10,319 --> 00:07:14,319
or disable

00:07:11,199 --> 00:07:16,000
a certain metric in order to reduce

00:07:14,319 --> 00:07:18,639
latency or

00:07:16,000 --> 00:07:19,599
not consume hardware resources uh when

00:07:18,639 --> 00:07:23,440
possible

00:07:19,599 --> 00:07:26,319
and also to be able to configure

00:07:23,440 --> 00:07:27,199
hardware histogram agents whether they

00:07:26,319 --> 00:07:29,440
are linear or

00:07:27,199 --> 00:07:30,240
exponential what is the mean value max

00:07:29,440 --> 00:07:32,319
value

00:07:30,240 --> 00:07:33,680
number of buckets in case it's

00:07:32,319 --> 00:07:38,080
configurable

00:07:33,680 --> 00:07:38,080
and obviously the sampling interval

00:07:40,240 --> 00:07:44,000
so this is a screenshot showing the

00:07:43,520 --> 00:07:46,720
interface

00:07:44,000 --> 00:07:48,639
the composed interface again this is not

00:07:46,720 --> 00:07:51,440
upstream

00:07:48,639 --> 00:07:53,039
so you can query the metrics then you

00:07:51,440 --> 00:07:56,160
can

00:07:53,039 --> 00:07:57,199
create a specific metric or group them

00:07:56,160 --> 00:08:00,400
together

00:07:57,199 --> 00:08:02,400
and ask for a filter dump

00:08:00,400 --> 00:08:05,440
from their camera for only these uh

00:08:02,400 --> 00:08:05,440
specific methods

00:08:05,759 --> 00:08:13,039
and yeah i have a typography it should

00:08:09,360 --> 00:08:16,479
be canon canon um

00:08:13,039 --> 00:08:19,599
so in order not to

00:08:16,479 --> 00:08:22,240
make this a huge mess like eth tool

00:08:19,599 --> 00:08:23,039
where you have a lot of different

00:08:22,240 --> 00:08:24,720
counters

00:08:23,039 --> 00:08:26,240
and you have no idea what they are doing

00:08:24,720 --> 00:08:30,879
what they are counting

00:08:26,240 --> 00:08:33,120
so from from the get-go we would like to

00:08:30,879 --> 00:08:34,640
make sure that every single metric we

00:08:33,120 --> 00:08:38,159
add to the candle is

00:08:34,640 --> 00:08:40,320
uh documented in the calendar

00:08:38,159 --> 00:08:41,519
specifically under the diving

00:08:40,320 --> 00:08:44,159
documentation

00:08:41,519 --> 00:08:46,320
so this is an example of what we already

00:08:44,159 --> 00:08:46,320
have

00:08:47,440 --> 00:08:53,920
uh questions this was the first topic

00:08:51,920 --> 00:08:54,959
so you plan to standardize on the names

00:08:53,920 --> 00:08:58,160
right either

00:08:54,959 --> 00:09:00,080
um this is what you're saying you plan

00:08:58,160 --> 00:09:03,600
to standardize on these names

00:09:00,080 --> 00:09:06,839
and it will be a standard

00:09:03,600 --> 00:09:10,480
it's not it's not unlike heath tool it's

00:09:06,839 --> 00:09:12,880
not driver defined you're saying

00:09:10,480 --> 00:09:14,240
so actually it is but i want it to be

00:09:12,880 --> 00:09:16,959
documented so each

00:09:14,240 --> 00:09:19,600
device driver will will document the

00:09:16,959 --> 00:09:22,000
metrics that it is exposing

00:09:19,600 --> 00:09:24,320
okay i'm not sure we can make this stuff

00:09:22,000 --> 00:09:27,760
generic

00:09:24,320 --> 00:09:29,920
okay yeah understood

00:09:27,760 --> 00:09:30,959
yeah because at least in spectrum you

00:09:29,920 --> 00:09:33,440
know we have like

00:09:30,959 --> 00:09:34,800
stuff that is specific to spectrum how

00:09:33,440 --> 00:09:37,519
the hardware is designed

00:09:34,800 --> 00:09:38,800
uh and like we have metrics that the

00:09:37,519 --> 00:09:42,080
algorithm designers

00:09:38,800 --> 00:09:42,080
thought it would be good to have

00:09:42,720 --> 00:09:45,760
so perhaps we can do it in the same way

00:09:44,720 --> 00:09:49,040
we

00:09:45,760 --> 00:09:51,200
we do that for params where we have like

00:09:49,040 --> 00:09:53,120
uh generic ramps which

00:09:51,200 --> 00:09:54,959
work for all the drivers and then we

00:09:53,120 --> 00:09:57,200
have something which is uh

00:09:54,959 --> 00:09:59,360
fiber-specific so i think it should work

00:09:57,200 --> 00:10:01,440
like that as well

00:09:59,360 --> 00:10:03,200
yeah so i think maybe at least in this

00:10:01,440 --> 00:10:06,560
example that the vxlan the

00:10:03,200 --> 00:10:08,000
m-cap and d-cup counters very maybe even

00:10:06,560 --> 00:10:11,040
the l's and this cards

00:10:08,000 --> 00:10:13,680
like nothing nothing special

00:10:11,040 --> 00:10:15,440
so the for this specific example for the

00:10:13,680 --> 00:10:18,160
vxlan end cap and d-cap

00:10:15,440 --> 00:10:19,360
uh how is it different from say stats on

00:10:18,160 --> 00:10:22,959
a vxlan device

00:10:19,360 --> 00:10:24,959
if it's so it's not different but

00:10:22,959 --> 00:10:26,240
in hardware like i mentioned in the

00:10:24,959 --> 00:10:29,279
beginning maybe i'll

00:10:26,240 --> 00:10:33,040
show you so

00:10:29,279 --> 00:10:36,399
again so we have a single twitter

00:10:33,040 --> 00:10:37,360
in in spectrum but the driver logically

00:10:36,399 --> 00:10:40,640
maps it into

00:10:37,360 --> 00:10:43,920
various leagues devices so

00:10:40,640 --> 00:10:47,040
if like we sorry

00:10:43,920 --> 00:10:50,160
sorry it's only global yeah it's global

00:10:47,040 --> 00:10:50,640
and if i expose it for each device it

00:10:50,160 --> 00:10:53,839
would be

00:10:50,640 --> 00:10:57,600
inaccurate yeah

00:10:53,839 --> 00:11:00,800
i i am aware of your of your model

00:10:57,600 --> 00:11:02,880
with a single v extended device in which

00:11:00,800 --> 00:11:05,360
we multiplex multiple vnis

00:11:02,880 --> 00:11:06,399
and in this case we could actually

00:11:05,360 --> 00:11:10,399
exposing

00:11:06,399 --> 00:11:13,680
expose it using the net device yeah

00:11:10,399 --> 00:11:16,079
got it so when you

00:11:13,680 --> 00:11:17,279
showed the example here with groups your

00:11:16,079 --> 00:11:20,399
group seemed to be

00:11:17,279 --> 00:11:23,680
a number whereas text something like

00:11:20,399 --> 00:11:28,959
vtan or algorithmic

00:11:23,680 --> 00:11:32,320
uh tcam would be much more user-friendly

00:11:28,959 --> 00:11:35,760
so the maybe i wasn't clear the grouping

00:11:32,320 --> 00:11:36,480
is by default when the device driver is

00:11:35,760 --> 00:11:38,399
registering

00:11:36,480 --> 00:11:40,240
its metrics with everything then they

00:11:38,399 --> 00:11:44,240
are all in the default group of

00:11:40,240 --> 00:11:46,880
zero and the purpose of grouping is

00:11:44,240 --> 00:11:48,959
so that you as the user could define

00:11:46,880 --> 00:11:50,240
which metrics you want to group in order

00:11:48,959 --> 00:11:53,360
to query them

00:11:50,240 --> 00:11:54,800
more or less atomically now i understand

00:11:53,360 --> 00:11:58,639
that he

00:11:54,800 --> 00:11:59,920
also suggest having like another level

00:11:58,639 --> 00:12:03,440
of grouping so that

00:11:59,920 --> 00:12:04,480
user will know which metrics are

00:12:03,440 --> 00:12:08,399
logically

00:12:04,480 --> 00:12:08,399
connected yep

00:12:09,200 --> 00:12:13,440
um so we can either do it in the user

00:12:12,800 --> 00:12:17,040
api

00:12:13,440 --> 00:12:19,440
or maybe just document it

00:12:17,040 --> 00:12:19,440
not sure

00:12:20,639 --> 00:12:26,160
i mean i can add another column here

00:12:24,160 --> 00:12:29,279
i'm just thinking of the typical use

00:12:26,160 --> 00:12:31,839
case you're generally interested in

00:12:29,279 --> 00:12:32,320
just one block of hardware in the device

00:12:31,839 --> 00:12:36,399
not

00:12:32,320 --> 00:12:36,399
all blocks of hardware in the device

00:12:36,720 --> 00:12:40,560
so being able to easily just get the

00:12:39,680 --> 00:12:44,000
vitam

00:12:40,560 --> 00:12:47,120
vcam uh the t cam or just get

00:12:44,000 --> 00:12:52,000
the vlan stuff would be

00:12:47,120 --> 00:12:55,040
probably nice yeah i understand

00:12:52,000 --> 00:12:56,079
also i think if you're wrapping some

00:12:55,040 --> 00:12:58,560
sort of snmp

00:12:56,079 --> 00:13:00,399
mid round this this is also probably

00:12:58,560 --> 00:13:03,200
going to be

00:13:00,399 --> 00:13:03,200
different mibs

00:13:04,839 --> 00:13:09,120
yeah uh okay so i think uh maybe we can

00:13:08,240 --> 00:13:11,680
extend it

00:13:09,120 --> 00:13:14,079
so that the device driver will also say

00:13:11,680 --> 00:13:16,240
which metrics are logically

00:13:14,079 --> 00:13:19,120
uh related and then we can expose it

00:13:16,240 --> 00:13:23,279
like this to user space

00:13:19,120 --> 00:13:26,079
okay okay before you move on

00:13:23,279 --> 00:13:27,760
um jamal says there is a raised hand and

00:13:26,079 --> 00:13:28,959
i'm not sure how to steal the raised

00:13:27,760 --> 00:13:32,839
hand

00:13:28,959 --> 00:13:34,959
um i had mine raised is my does my mic

00:13:32,839 --> 00:13:37,920
work

00:13:34,959 --> 00:13:39,360
yes oh okay i was just wondering i i

00:13:37,920 --> 00:13:40,560
don't know if this is a crazy idea but

00:13:39,360 --> 00:13:42,399
does it make sense to

00:13:40,560 --> 00:13:45,040
expose these metrics under the assist

00:13:42,399 --> 00:13:45,040
file system

00:13:48,399 --> 00:13:52,480
i'm more of a bsd guy so i'm you know

00:13:50,320 --> 00:13:54,000
i'm more a recent linux person so maybe

00:13:52,480 --> 00:13:56,720
that's a crazy

00:13:54,000 --> 00:13:58,399
yeah suggestion it's not going to fly in

00:13:56,720 --> 00:14:01,519
the networking subsystem

00:13:58,399 --> 00:14:02,480
yeah okay yeah christian there's a

00:14:01,519 --> 00:14:05,440
recent thread on

00:14:02,480 --> 00:14:06,639
net dev about somebody asking the same

00:14:05,440 --> 00:14:08,240
thing

00:14:06,639 --> 00:14:09,680
maybe it's just not an efficient way to

00:14:08,240 --> 00:14:12,000
do it yeah

00:14:09,680 --> 00:14:12,720
exactly well we are actually trying to

00:14:12,000 --> 00:14:15,600
shift

00:14:12,720 --> 00:14:17,199
from the system as much as possible in

00:14:15,600 --> 00:14:20,880
for cases like

00:14:17,199 --> 00:14:22,720
this so yeah i mean when you're using a

00:14:20,880 --> 00:14:25,040
user application like bpp

00:14:22,720 --> 00:14:26,880
right it's a shared memory which is

00:14:25,040 --> 00:14:29,600
super efficient but

00:14:26,880 --> 00:14:30,720
i don't think that it can be done here

00:14:29,600 --> 00:14:32,880
yeah

00:14:30,720 --> 00:14:34,800
okay so i see that i'm already the

00:14:32,880 --> 00:14:37,839
foreign market

00:14:34,800 --> 00:14:40,880
um so i want to move to the next topic

00:14:37,839 --> 00:14:42,880
um so first of all here

00:14:40,880 --> 00:14:44,880
unlike the previous one we are still at

00:14:42,880 --> 00:14:47,920
the hand waving phase

00:14:44,880 --> 00:14:51,600
i don't have anything concrete

00:14:47,920 --> 00:14:55,920
um just to be perfectly clear

00:14:51,600 --> 00:14:58,639
um okay so resilient hashing

00:14:55,920 --> 00:15:01,040
so as you all know we have ecmp support

00:14:58,639 --> 00:15:04,320
in the kernel

00:15:01,040 --> 00:15:07,760
in calves in case we want to

00:15:04,320 --> 00:15:10,240
route pocket via different

00:15:07,760 --> 00:15:10,240
counters

00:15:11,360 --> 00:15:16,959
but we don't have support for resilient

00:15:14,480 --> 00:15:19,680
hashing or resiliency simply

00:15:16,959 --> 00:15:20,560
so what we have in the camera actually

00:15:19,680 --> 00:15:22,079
is

00:15:20,560 --> 00:15:23,920
i mean the multi-path algorithm is

00:15:22,079 --> 00:15:26,000
called hash threshold and

00:15:23,920 --> 00:15:27,120
it's working like this for both ipv4 and

00:15:26,000 --> 00:15:29,920
ipv6

00:15:27,120 --> 00:15:31,440
so if you look in this uh picture that i

00:15:29,920 --> 00:15:34,480
took from rfc

00:15:31,440 --> 00:15:36,959
you can see that we have um five

00:15:34,480 --> 00:15:37,839
next stops and these are logical next

00:15:36,959 --> 00:15:40,959
stops

00:15:37,839 --> 00:15:44,480
and in case of easing if

00:15:40,959 --> 00:15:45,600
equal cost then they are equally

00:15:44,480 --> 00:15:49,199
distributed

00:15:45,600 --> 00:15:52,240
in the key space which in our case is

00:15:49,199 --> 00:15:54,399
in the calendar is 32 bit so we have

00:15:52,240 --> 00:15:56,800
the first bucket the second bucket and

00:15:54,399 --> 00:16:00,399
up until the fifth bucket

00:15:56,800 --> 00:16:03,759
now let's say uh that next stop

00:16:00,399 --> 00:16:07,360
three goes down okay

00:16:03,759 --> 00:16:09,920
so ideally we wouldn't want any

00:16:07,360 --> 00:16:12,079
flows that are currently hashed to the

00:16:09,920 --> 00:16:14,639
first bucket or any other bucket that is

00:16:12,079 --> 00:16:18,880
not free to be affected by this

00:16:14,639 --> 00:16:22,079
um because in certain cases when you

00:16:18,880 --> 00:16:24,000
don't have the packet to the same uh

00:16:22,079 --> 00:16:26,000
destination via different path but

00:16:24,000 --> 00:16:27,920
you're using ecmp to actually

00:16:26,000 --> 00:16:29,600
distribute the traffic between different

00:16:27,920 --> 00:16:33,360
servers

00:16:29,600 --> 00:16:36,560
then uh you want the a specific flow to

00:16:33,360 --> 00:16:40,560
still go to the same server whenever the

00:16:36,560 --> 00:16:43,759
even whenever the next group changes

00:16:40,560 --> 00:16:47,120
so you can see that like flows that are

00:16:43,759 --> 00:16:50,639
currently uh hashed to the second bucket

00:16:47,120 --> 00:16:52,720
uh in i mean near the border with the

00:16:50,639 --> 00:16:53,839
first bucket will actually transition to

00:16:52,720 --> 00:16:56,160
the first bucket

00:16:53,839 --> 00:16:57,279
after next three goes down which means

00:16:56,160 --> 00:16:58,720
that uh

00:16:57,279 --> 00:17:01,279
the current algorithm we have in the

00:16:58,720 --> 00:17:04,319
kernel is not resilient

00:17:01,279 --> 00:17:06,400
um another algorithm which is

00:17:04,319 --> 00:17:08,319
relatively simple is called the module n

00:17:06,400 --> 00:17:11,600
where you just take the

00:17:08,319 --> 00:17:13,600
hash result of the flow and do modulo n

00:17:11,600 --> 00:17:16,319
where n is the number of next stores

00:17:13,600 --> 00:17:16,959
so obviously if an extra is added or

00:17:16,319 --> 00:17:19,280
removed

00:17:16,959 --> 00:17:23,280
then all the flows are affected and this

00:17:19,280 --> 00:17:23,280
is a relatively disruptive algorithm

00:17:23,600 --> 00:17:26,640
and we would like to add resilient

00:17:25,280 --> 00:17:29,440
hashing support

00:17:26,640 --> 00:17:31,520
question is to do it in the kernel or in

00:17:29,440 --> 00:17:35,120
user

00:17:31,520 --> 00:17:36,240
one space so in order to explain the

00:17:35,120 --> 00:17:39,280
problem better i took

00:17:36,240 --> 00:17:40,960
uh figures from the uh actually coders

00:17:39,280 --> 00:17:43,679
documentation which is very good

00:17:40,960 --> 00:17:43,679
now in the video

00:17:44,320 --> 00:17:47,600
so i mean resilient touching is nothing

00:17:46,640 --> 00:17:50,640
uh special

00:17:47,600 --> 00:17:54,080
it's like regular ecmp but

00:17:50,640 --> 00:17:57,440
it's simply a clever way of populating

00:17:54,080 --> 00:17:58,720
the the hash buckets uh with the logical

00:17:57,440 --> 00:18:02,320
next stops

00:17:58,720 --> 00:18:05,200
so um in this example we have like 12

00:18:02,320 --> 00:18:06,799
hash buckets instead of n where n is the

00:18:05,200 --> 00:18:08,880
number of next stops so we have

00:18:06,799 --> 00:18:10,000
like four logic connect stops and they

00:18:08,880 --> 00:18:12,840
are distributed

00:18:10,000 --> 00:18:14,400
using groudombit between uh 12 hash

00:18:12,840 --> 00:18:16,640
buckets

00:18:14,400 --> 00:18:17,600
and so you can see that for example in

00:18:16,640 --> 00:18:21,600
the

00:18:17,600 --> 00:18:24,799
second figure if next to b goes down

00:18:21,600 --> 00:18:27,200
uh it allows us to immediately

00:18:24,799 --> 00:18:28,480
so first of all the size of the group

00:18:27,200 --> 00:18:31,520
does not change

00:18:28,480 --> 00:18:34,640
and other next stops

00:18:31,520 --> 00:18:36,000
uh populated space take its place so if

00:18:34,640 --> 00:18:38,080
we only had like

00:18:36,000 --> 00:18:40,480
four buckets then one next stop would

00:18:38,080 --> 00:18:42,880
get twice the traffic as

00:18:40,480 --> 00:18:45,600
other next stop so it wouldn't be equal

00:18:42,880 --> 00:18:45,600
cost anyway

00:18:46,799 --> 00:18:50,160
but this way the graphic is still

00:18:48,799 --> 00:18:51,840
equally distributed between all the

00:18:50,160 --> 00:18:52,640
logical next stops between the three

00:18:51,840 --> 00:18:56,880
remaining

00:18:52,640 --> 00:18:59,919
logic and next and obviously

00:18:56,880 --> 00:19:03,440
all the traffic that went to uh

00:18:59,919 --> 00:19:06,000
next stop other than b

00:19:03,440 --> 00:19:10,880
is unaffected by the fact that next to b

00:19:06,000 --> 00:19:12,960
was removed the second flow

00:19:10,880 --> 00:19:14,640
which is more problematic is when you

00:19:12,960 --> 00:19:17,520
want to add a next stop

00:19:14,640 --> 00:19:18,000
to a group let's say we have four next

00:19:17,520 --> 00:19:20,320
stops

00:19:18,000 --> 00:19:22,320
and we want to add next stop e fifth

00:19:20,320 --> 00:19:26,320
next

00:19:22,320 --> 00:19:29,919
so the correct way to do it would be to

00:19:26,320 --> 00:19:31,600
check the activity of each hash bucket

00:19:29,919 --> 00:19:33,039
so that you make sure that when you

00:19:31,600 --> 00:19:35,760
replace

00:19:33,039 --> 00:19:37,039
an existing next stop with the with the

00:19:35,760 --> 00:19:39,679
new next stop

00:19:37,039 --> 00:19:41,039
then you are not impacting existing

00:19:39,679 --> 00:19:44,080
traffic you are not doing the

00:19:41,039 --> 00:19:48,480
replacement on an active bucket

00:19:44,080 --> 00:19:51,840
uh when possible so

00:19:48,480 --> 00:19:52,640
in this case you can see that the purple

00:19:51,840 --> 00:19:55,840
flow

00:19:52,640 --> 00:19:58,000
and the blue flow were not affected

00:19:55,840 --> 00:20:00,240
uh they still go to next stop a and next

00:19:58,000 --> 00:20:02,559
stop d respectively

00:20:00,240 --> 00:20:07,840
but the red flow did change from next to

00:20:02,559 --> 00:20:07,840
b to next c

00:20:09,360 --> 00:20:15,840
um okay so

00:20:12,640 --> 00:20:19,440
as you know i don't know like in the

00:20:15,840 --> 00:20:22,000
last year david m added the

00:20:19,440 --> 00:20:23,600
the great next stop api which basically

00:20:22,000 --> 00:20:27,280
breaks the

00:20:23,600 --> 00:20:28,720
um the route the routes on the next stop

00:20:27,280 --> 00:20:31,760
so you can

00:20:28,720 --> 00:20:32,880
uh program the two differently you can

00:20:31,760 --> 00:20:34,720
poke up the next stop

00:20:32,880 --> 00:20:36,400
and then you can add it out and say this

00:20:34,720 --> 00:20:40,400
points to next id

00:20:36,400 --> 00:20:41,919
x now we have two proposals for

00:20:40,400 --> 00:20:44,000
resilient hashing

00:20:41,919 --> 00:20:46,840
first one in user space and the second

00:20:44,000 --> 00:20:50,960
one in counter space

00:20:46,840 --> 00:20:53,360
um so the user space proposal was

00:20:50,960 --> 00:20:55,600
very appealing to me at first because

00:20:53,360 --> 00:20:57,919
personally i would like to

00:20:55,600 --> 00:20:59,520
keep the kernel as boring as possible

00:20:57,919 --> 00:21:02,320
and if we can do something

00:20:59,520 --> 00:21:03,039
using dpf or in user space then i would

00:21:02,320 --> 00:21:06,640
prefer

00:21:03,039 --> 00:21:09,679
to do it this way but thinking

00:21:06,640 --> 00:21:11,440
about it more i i'm not sure this is

00:21:09,679 --> 00:21:12,400
actually achievable that will explain

00:21:11,440 --> 00:21:14,840
why

00:21:12,400 --> 00:21:17,760
i mean it gets really complicated really

00:21:14,840 --> 00:21:20,799
fast

00:21:17,760 --> 00:21:21,679
so the key point here is that the next

00:21:20,799 --> 00:21:24,880
stop ids

00:21:21,679 --> 00:21:27,919
are no longer logical next stops

00:21:24,880 --> 00:21:30,720
but they are the hash buckets

00:21:27,919 --> 00:21:32,480
which means that we lose the ability to

00:21:30,720 --> 00:21:33,520
share a next stop between multiple

00:21:32,480 --> 00:21:35,600
groups

00:21:33,520 --> 00:21:37,120
so it immediately increases the memory

00:21:35,600 --> 00:21:40,240
of it which

00:21:37,120 --> 00:21:44,960
i believe was one of david's main

00:21:40,240 --> 00:21:47,280
goals for this api um

00:21:44,960 --> 00:21:48,480
and user space will be able to control

00:21:47,280 --> 00:21:50,880
the number of

00:21:48,480 --> 00:21:52,400
buckets in each group and the mapping of

00:21:50,880 --> 00:21:54,400
the logical next stops

00:21:52,400 --> 00:21:56,559
meaning the gateway and the device to

00:21:54,400 --> 00:21:59,200
the bucket

00:21:56,559 --> 00:22:01,840
and also obviously how to do the

00:21:59,200 --> 00:22:01,840
replacement

00:22:02,400 --> 00:22:05,760
now the two flows that we previously

00:22:04,000 --> 00:22:06,720
mentioned the next stop removal and

00:22:05,760 --> 00:22:09,760
edition

00:22:06,720 --> 00:22:12,320
uh so the removal

00:22:09,760 --> 00:22:12,799
is partially addressed by the rfc that

00:22:12,320 --> 00:22:15,919
david

00:22:12,799 --> 00:22:16,799
sent back in june with the active backup

00:22:15,919 --> 00:22:18,880
groups

00:22:16,799 --> 00:22:19,840
and i will explain why partially in a

00:22:18,880 --> 00:22:22,960
minute

00:22:19,840 --> 00:22:26,000
but basically this uh api which i think

00:22:22,960 --> 00:22:28,000
which i still think is a great addition

00:22:26,000 --> 00:22:29,120
allows you to define a new group with

00:22:28,000 --> 00:22:31,600
only two next stops

00:22:29,120 --> 00:22:34,000
where one is primary and the second is

00:22:31,600 --> 00:22:34,000
active

00:22:35,120 --> 00:22:40,400
and so is are you

00:22:38,400 --> 00:22:42,240
when you say user space are you talking

00:22:40,400 --> 00:22:43,360
about a control plane like a friend yes

00:22:42,240 --> 00:22:46,480
yes

00:22:43,360 --> 00:22:51,039
okay yeah good point

00:22:46,480 --> 00:22:51,919
uh so we as it's important to emphasize

00:22:51,039 --> 00:22:53,760
that

00:22:51,919 --> 00:22:55,360
for at least for the user space solution

00:22:53,760 --> 00:22:57,919
you do need some

00:22:55,360 --> 00:23:01,039
very clever daemon running in user space

00:22:57,919 --> 00:23:02,799
uh in order to get the name fashion

00:23:01,039 --> 00:23:05,280
which is not linked with the current

00:23:02,799 --> 00:23:05,280
solution

00:23:05,360 --> 00:23:09,919
um okay and for next stop edition like i

00:23:08,480 --> 00:23:12,480
previously explained

00:23:09,919 --> 00:23:14,080
and we need uh activity information from

00:23:12,480 --> 00:23:16,960
the kernel in order to know

00:23:14,080 --> 00:23:19,039
which next top id meaning which hash

00:23:16,960 --> 00:23:20,720
bucket we can populate with the new

00:23:19,039 --> 00:23:22,240
next stop and this is currently

00:23:20,720 --> 00:23:23,919
something we do not have we don't have

00:23:22,240 --> 00:23:27,679
activity information

00:23:23,919 --> 00:23:29,520
uh from the camera regarding next stops

00:23:27,679 --> 00:23:31,440
so even if we go with this solution it

00:23:29,520 --> 00:23:34,840
doesn't mean that uh

00:23:31,440 --> 00:23:37,440
kernel can support it without

00:23:34,840 --> 00:23:40,799
modifications

00:23:37,440 --> 00:23:42,000
so the initial state let's take the

00:23:40,799 --> 00:23:45,200
previous example

00:23:42,000 --> 00:23:48,320
we only have 12 hash buckets uh

00:23:45,200 --> 00:23:51,919
these are presented here using uh

00:23:48,320 --> 00:23:55,840
next stops 101 to 112

00:23:51,919 --> 00:24:00,000
and the ecmp group itself has the id

00:23:55,840 --> 00:24:03,520
of 1001

00:24:00,000 --> 00:24:05,360
and all the uh buckets of are mentally

00:24:03,520 --> 00:24:09,039
stroke

00:24:05,360 --> 00:24:14,000
now the buckets themselves

00:24:09,039 --> 00:24:17,279
are active backup and extra groups

00:24:14,000 --> 00:24:18,799
why so that whenever a next stop is

00:24:17,279 --> 00:24:21,360
removed the size

00:24:18,799 --> 00:24:22,640
of the ecmd group does not change so

00:24:21,360 --> 00:24:25,440
let's say that next to b

00:24:22,640 --> 00:24:26,640
was removed like in this example you can

00:24:25,440 --> 00:24:30,840
see that the size

00:24:26,640 --> 00:24:32,559
of the ecmp group is still still 12

00:24:30,840 --> 00:24:34,400
buckets

00:24:32,559 --> 00:24:37,039
now the reason i said that this is

00:24:34,400 --> 00:24:39,919
partially addressed by the active backup

00:24:37,039 --> 00:24:40,720
api is that this does handle correctly

00:24:39,919 --> 00:24:44,640
the case where

00:24:40,720 --> 00:24:47,520
only one next stop is removed but

00:24:44,640 --> 00:24:48,640
if more than one next stop is removed

00:24:47,520 --> 00:24:52,240
then we will start

00:24:48,640 --> 00:24:54,559
to the camera will start to delete uh

00:24:52,240 --> 00:24:55,360
the hash buckets that have zero active

00:24:54,559 --> 00:24:58,960
and extra

00:24:55,360 --> 00:25:02,400
neck stops and then the the size of the

00:24:58,960 --> 00:25:02,400
ecmp group will change

00:25:03,679 --> 00:25:10,400
so i don't have a good solution for this

00:25:06,960 --> 00:25:10,400
if they use a space suggestion

00:25:12,720 --> 00:25:16,000
addition of the next stop uh can be done

00:25:15,520 --> 00:25:19,200
by

00:25:16,000 --> 00:25:21,679
replacing the individual

00:25:19,200 --> 00:25:21,679
buckets

00:25:23,039 --> 00:25:26,799
so like i previously mentioned we do

00:25:24,880 --> 00:25:29,279
need some activity indication

00:25:26,799 --> 00:25:30,080
from the kernel in order to know which

00:25:29,279 --> 00:25:31,919
buckets

00:25:30,080 --> 00:25:33,760
which next up ids we can remove and

00:25:31,919 --> 00:25:37,919
which we cannot

00:25:33,760 --> 00:25:40,559
so i have two proposals for this um but

00:25:37,919 --> 00:25:42,480
but this is the details if we decide to

00:25:40,559 --> 00:25:44,799
go with the user space approach

00:25:42,480 --> 00:25:48,000
so i want to skip this part and go to

00:25:44,799 --> 00:25:48,000
the canon suggestion

00:25:49,600 --> 00:25:54,640
i mean we can discuss this later either

00:25:52,240 --> 00:25:58,640
in a meeting or over the mailing list

00:25:54,640 --> 00:25:58,640
no no problem so

00:25:59,679 --> 00:26:03,440
uh the the use of space suggestion it

00:26:02,080 --> 00:26:06,960
gets really complicated

00:26:03,440 --> 00:26:09,200
really fast and uh it's

00:26:06,960 --> 00:26:11,600
i see i think it's basically an abuse of

00:26:09,200 --> 00:26:14,159
the next stop api

00:26:11,600 --> 00:26:15,440
because instead of managing managing

00:26:14,159 --> 00:26:18,080
logical next stops

00:26:15,440 --> 00:26:19,679
you say no now it's actually hash

00:26:18,080 --> 00:26:22,559
buckets and you cannot share

00:26:19,679 --> 00:26:23,360
a next stop id between multiple groups

00:26:22,559 --> 00:26:27,200
which i think

00:26:23,360 --> 00:26:29,520
is is quite weird so

00:26:27,200 --> 00:26:30,799
the camera suggestion also relies on the

00:26:29,520 --> 00:26:34,240
new next stop api

00:26:30,799 --> 00:26:38,000
which hopefully everyone will migrate to

00:26:34,240 --> 00:26:41,120
one day and

00:26:38,000 --> 00:26:44,640
it is about adding a new group type

00:26:41,120 --> 00:26:47,520
that says this next stop group

00:26:44,640 --> 00:26:50,840
is not a regular multipath next to group

00:26:47,520 --> 00:26:53,600
it's for resilient hashing

00:26:50,840 --> 00:26:56,400
um and

00:26:53,600 --> 00:26:57,679
then we we we keep the abstraction where

00:26:56,400 --> 00:27:00,400
the next stop

00:26:57,679 --> 00:27:01,200
id is a logic connect stops the logical

00:27:00,400 --> 00:27:03,440
next stop

00:27:01,200 --> 00:27:06,559
and we add uh parameters that are

00:27:03,440 --> 00:27:09,840
relevant for this

00:27:06,559 --> 00:27:10,799
new multipath group such as the number

00:27:09,840 --> 00:27:14,240
of buckets

00:27:10,799 --> 00:27:18,320
and some timers that i will explain soon

00:27:14,240 --> 00:27:20,799
and then the kernel is the one who is

00:27:18,320 --> 00:27:22,080
managing the the individual buckets

00:27:20,799 --> 00:27:25,440
let's say you can have

00:27:22,080 --> 00:27:27,360
an extra group with four next stops

00:27:25,440 --> 00:27:28,520
but you say that the number of buckets

00:27:27,360 --> 00:27:32,480
is i don't know

00:27:28,520 --> 00:27:35,360
256 or fake and then the kernel

00:27:32,480 --> 00:27:36,480
is doing the mapping between the logical

00:27:35,360 --> 00:27:39,679
next stops

00:27:36,480 --> 00:27:39,679
and the number of buckets

00:27:40,490 --> 00:27:44,399
[Music]

00:27:42,799 --> 00:27:46,399
so first of all we need to implement

00:27:44,399 --> 00:27:48,559
this

00:27:46,399 --> 00:27:50,559
resilient algorithm inside the camera

00:27:48,559 --> 00:27:53,600
and then we can also use it

00:27:50,559 --> 00:27:54,159
for other offloading case you are doing

00:27:53,600 --> 00:27:55,520
the

00:27:54,159 --> 00:27:57,120
in case your hardware is doing the

00:27:55,520 --> 00:27:58,240
switching the routing instead of the

00:27:57,120 --> 00:28:00,159
camera

00:27:58,240 --> 00:28:02,240
but at least it gave it gives us like

00:28:00,159 --> 00:28:05,600
feature quality it's not like

00:28:02,240 --> 00:28:07,919
this feature is specific to hardware

00:28:05,600 --> 00:28:10,960
you get both resilient touching in

00:28:07,919 --> 00:28:13,200
software and in hardware

00:28:10,960 --> 00:28:14,240
and we do need some extensions for the

00:28:13,200 --> 00:28:16,960
camera we need

00:28:14,240 --> 00:28:18,240
new attributes uh like the number of

00:28:16,960 --> 00:28:21,520
buckets we need uh

00:28:18,240 --> 00:28:24,480
timers so that um yeah

00:28:21,520 --> 00:28:24,480
someone has a question

00:28:25,679 --> 00:28:30,399
okay um quick time check either

00:28:33,919 --> 00:28:37,919
i will not reach the recently added

00:28:35,600 --> 00:28:40,720
features but uh

00:28:37,919 --> 00:28:41,919
basically i did want to float around

00:28:40,720 --> 00:28:45,120
this uh

00:28:41,919 --> 00:28:47,520
kernel solution to see if anyone has an

00:28:45,120 --> 00:28:47,520
opinion

00:28:47,919 --> 00:28:52,960
uh i guess mainly david no that seems

00:28:51,279 --> 00:28:54,559
fine to me so far

00:28:52,960 --> 00:28:58,640
um i do think it's going to be really

00:28:54,559 --> 00:29:01,679
tricky with the activity monitor

00:28:58,640 --> 00:29:03,039
you mean the user space approach just in

00:29:01,679 --> 00:29:07,039
general keeping track of

00:29:03,039 --> 00:29:08,640
if it's being used or not um

00:29:07,039 --> 00:29:11,200
and that seems to be the trickiest part

00:29:08,640 --> 00:29:13,360
to the whole resilient hashing problem

00:29:11,200 --> 00:29:14,880
why does the user space care about

00:29:13,360 --> 00:29:17,360
whether the particular hash is being

00:29:14,880 --> 00:29:20,159
used or not

00:29:17,360 --> 00:29:22,640
so you're talking about the calendar

00:29:20,159 --> 00:29:22,640
solution

00:29:22,880 --> 00:29:26,320
or the user space solution i could've

00:29:24,559 --> 00:29:27,919
sworn you were i maybe i misheard you

00:29:26,320 --> 00:29:29,600
then i could have sworn you

00:29:27,919 --> 00:29:31,120
said that the user space would need to

00:29:29,600 --> 00:29:33,679
track that as well

00:29:31,120 --> 00:29:35,760
yeah if if you need if we are going with

00:29:33,679 --> 00:29:36,720
the user space proposal but if we are

00:29:35,760 --> 00:29:39,039
going with the kernel

00:29:36,720 --> 00:29:40,000
proposal then then you sepharam you

00:29:39,039 --> 00:29:43,840
don't need to do anything

00:29:40,000 --> 00:29:44,240
special just say uh this multiple group

00:29:43,840 --> 00:29:45,600
is

00:29:44,240 --> 00:29:47,600
is for resilient hashing this is the

00:29:45,600 --> 00:29:49,360
number of buckets and that's it

00:29:47,600 --> 00:29:51,919
and you get the rest of the service from

00:29:49,360 --> 00:29:53,600
the camera but i do want to extend the

00:29:51,919 --> 00:29:56,640
the next stop api

00:29:53,600 --> 00:29:58,159
so that it can expose the mapping

00:29:56,640 --> 00:30:02,080
between the logical id

00:29:58,159 --> 00:30:02,080
and the packet so that we can debug this

00:30:02,159 --> 00:30:09,039
but it's like read-only yeah

00:30:05,360 --> 00:30:11,200
so just to uh to update you

00:30:09,039 --> 00:30:13,200
like i think next week i'm going to

00:30:11,200 --> 00:30:14,640
start working more seriously about the

00:30:13,200 --> 00:30:17,840
next stop stuff

00:30:14,640 --> 00:30:18,480
and i i will keep this stuff in mind so

00:30:17,840 --> 00:30:21,600
that

00:30:18,480 --> 00:30:22,880
we design the we design it correctly

00:30:21,600 --> 00:30:24,640
i mean the interface starts with the

00:30:22,880 --> 00:30:26,480
device drivers and

00:30:24,640 --> 00:30:27,840
i will probably ping you over the

00:30:26,480 --> 00:30:31,440
mailing list again

00:30:27,840 --> 00:30:31,440
with a more concrete proposal

00:30:31,520 --> 00:30:35,760
cool so you're first adding the next

00:30:34,159 --> 00:30:39,840
stop group support and then

00:30:35,760 --> 00:30:42,640
moving on yes yes

00:30:39,840 --> 00:30:44,559
cool we are given that far also has

00:30:42,640 --> 00:30:47,600
support now upstream

00:30:44,559 --> 00:30:48,880
hopefully david it'll all be yeah next

00:30:47,600 --> 00:30:50,960
year

00:30:48,880 --> 00:30:53,120
it was added there too soon and the

00:30:50,960 --> 00:30:55,440
support front

00:30:53,120 --> 00:30:57,200
i know david is here to check whether

00:30:55,440 --> 00:31:00,880
it's being used or not

00:30:57,200 --> 00:31:00,880
it's being used instead

00:31:03,360 --> 00:31:10,240
okay so i guess you are next

00:31:06,559 --> 00:31:10,880
so this is a update on project dent i'm

00:31:10,240 --> 00:31:14,240
not sure

00:31:10,880 --> 00:31:16,000
if people are aware or heard of it um

00:31:14,240 --> 00:31:18,080
but i will talk i'll give some

00:31:16,000 --> 00:31:20,159
introduction so if you're plugged into

00:31:18,080 --> 00:31:23,200
the world of network operating systems

00:31:20,159 --> 00:31:26,799
uh you will definitely know how many

00:31:23,200 --> 00:31:30,000
kinds there are and how many are still

00:31:26,799 --> 00:31:32,000
popping up so and many of them are part

00:31:30,000 --> 00:31:34,799
of linux foundation

00:31:32,000 --> 00:31:36,320
but they unlike a unlike the server

00:31:34,799 --> 00:31:37,760
world where everything is standardized

00:31:36,320 --> 00:31:39,200
and the offload model is mostly

00:31:37,760 --> 00:31:43,440
standardized

00:31:39,200 --> 00:31:45,600
it's a mix of plays in the open network

00:31:43,440 --> 00:31:47,519
operating systems world and when i use

00:31:45,600 --> 00:31:48,080
the word open network operating systems

00:31:47,519 --> 00:31:50,559
it means

00:31:48,080 --> 00:31:52,240
a open net distribution linux

00:31:50,559 --> 00:31:53,919
distribution that goes on a network

00:31:52,240 --> 00:31:57,120
switch or router

00:31:53,919 --> 00:31:58,320
okay so cumulus linux uh is just first

00:31:57,120 --> 00:32:01,519
in the list there because

00:31:58,320 --> 00:32:03,919
it was started way uh early because when

00:32:01,519 --> 00:32:06,320
the open networking revolution started

00:32:03,919 --> 00:32:08,159
what we're talking about here is when

00:32:06,320 --> 00:32:11,519
the boxes became open

00:32:08,159 --> 00:32:13,279
uh disaggregated uh cisco's and aristas

00:32:11,519 --> 00:32:15,120
and other vendors had their own

00:32:13,279 --> 00:32:17,519
closed operating systems and then they

00:32:15,120 --> 00:32:19,200
became open and kimless was one of them

00:32:17,519 --> 00:32:20,880
so what cumulus does is it's a

00:32:19,200 --> 00:32:23,440
deviant-based distribution

00:32:20,880 --> 00:32:25,120
it standardizes on the linux api but it

00:32:23,440 --> 00:32:25,760
has an abstraction to convert between

00:32:25,120 --> 00:32:29,279
linux

00:32:25,760 --> 00:32:30,080
api to the vendor sdk api user space

00:32:29,279 --> 00:32:33,279
sdks

00:32:30,080 --> 00:32:36,480
and most of the asics in the space have

00:32:33,279 --> 00:32:39,120
a user space driver

00:32:36,480 --> 00:32:39,919
and an sdk for application development

00:32:39,120 --> 00:32:41,840
on

00:32:39,919 --> 00:32:44,640
writing directly to that asic that's how

00:32:41,840 --> 00:32:46,640
it's been for years or decades

00:32:44,640 --> 00:32:48,000
okay sonic is another one you must have

00:32:46,640 --> 00:32:50,000
heard about sonic there's i think

00:32:48,000 --> 00:32:52,640
there's also a talk on monday

00:32:50,000 --> 00:32:53,519
it standardizes the user space sdk api

00:32:52,640 --> 00:32:55,760
and this was

00:32:53,519 --> 00:32:56,960
a project that microsoft started because

00:32:55,760 --> 00:33:00,720
they wanted a

00:32:56,960 --> 00:33:03,279
api to access the hardware the switch is

00:33:00,720 --> 00:33:05,279
easier query metrics and so on so that

00:33:03,279 --> 00:33:07,840
standardizes the sdk api

00:33:05,279 --> 00:33:08,799
it's a user space sdk api i have

00:33:07,840 --> 00:33:10,799
pointers to

00:33:08,799 --> 00:33:12,799
links to anybody who wants to know about

00:33:10,799 --> 00:33:16,000
these danos is another one

00:33:12,799 --> 00:33:17,279
which was started by atnd uh it is under

00:33:16,000 --> 00:33:19,440
linux foundation

00:33:17,279 --> 00:33:20,960
but it's used in mostly the telecom

00:33:19,440 --> 00:33:24,640
space

00:33:20,960 --> 00:33:27,760
again it's it's a mix of offload

00:33:24,640 --> 00:33:28,080
similar to sonic they're leveraging the

00:33:27,760 --> 00:33:31,679
psi

00:33:28,080 --> 00:33:33,760
api and so on melanox linux switch

00:33:31,679 --> 00:33:36,000
this is a product from melanox which is

00:33:33,760 --> 00:33:37,840
based on switch dev driver

00:33:36,000 --> 00:33:39,200
it allows you to pick a linux

00:33:37,840 --> 00:33:41,919
distribution and

00:33:39,200 --> 00:33:43,760
use their switched up driver it is not a

00:33:41,919 --> 00:33:47,760
complete nas offering by itself

00:33:43,760 --> 00:33:51,120
but it is there for open uh

00:33:47,760 --> 00:33:53,840
operating systems on a switch onl

00:33:51,120 --> 00:33:54,240
uh open networking linux this is another

00:33:53,840 --> 00:33:57,519
one

00:33:54,240 --> 00:34:00,880
which provides the base for

00:33:57,519 --> 00:34:03,360
platform abstraction of an open nos

00:34:00,880 --> 00:34:05,120
and it's not a nos complete nos by

00:34:03,360 --> 00:34:07,360
itself it's just a platform

00:34:05,120 --> 00:34:08,399
abstraction and many other nozzles are

00:34:07,360 --> 00:34:11,599
based on onl

00:34:08,399 --> 00:34:15,440
so you'll see onl a lot more uh in

00:34:11,599 --> 00:34:18,159
context of other noises so dent

00:34:15,440 --> 00:34:19,679
distributed enterprise is the loss that

00:34:18,159 --> 00:34:22,879
amazon

00:34:19,679 --> 00:34:24,720
is starting with the seed code amazon go

00:34:22,879 --> 00:34:28,159
to be

00:34:24,720 --> 00:34:31,599
specific there the retail space and

00:34:28,159 --> 00:34:33,040
it is a linux foundation project

00:34:31,599 --> 00:34:35,200
there's a link there on the linux

00:34:33,040 --> 00:34:38,320
foundation press release it is

00:34:35,200 --> 00:34:40,480
targeted towards the network edge and

00:34:38,320 --> 00:34:45,119
retail and campus deployments

00:34:40,480 --> 00:34:47,599
these are slightly lower end hardwares

00:34:45,119 --> 00:34:49,520
like one gig boxes cost effective

00:34:47,599 --> 00:34:52,560
solution for these retail markets

00:34:49,520 --> 00:34:54,320
okay now note that den does not itself

00:34:52,560 --> 00:34:55,119
the os itself does not put restrictions

00:34:54,320 --> 00:34:58,000
on

00:34:55,119 --> 00:35:00,079
what uh the software can do or the os

00:34:58,000 --> 00:35:02,880
can do or what packages it can go in

00:35:00,079 --> 00:35:03,920
it can be for data center tomorrow but

00:35:02,880 --> 00:35:08,000
it's starting with

00:35:03,920 --> 00:35:10,800
uh the seed code for um for this space

00:35:08,000 --> 00:35:13,599
so founding members the list is there

00:35:10,800 --> 00:35:15,520
and the seed code is coming from amazon

00:35:13,599 --> 00:35:18,079
standardizes on the linux api and uses

00:35:15,520 --> 00:35:20,640
switch tab for offload or to switch asic

00:35:18,079 --> 00:35:22,800
so it very much is in context of this

00:35:20,640 --> 00:35:27,200
the space that we're talking about

00:35:22,800 --> 00:35:29,280
um so this architecture with switchdev

00:35:27,200 --> 00:35:31,440
is used multiple times i'm not going to

00:35:29,280 --> 00:35:32,240
go detail into it but basically the

00:35:31,440 --> 00:35:35,359
control plane

00:35:32,240 --> 00:35:37,440
is a linux server control plane

00:35:35,359 --> 00:35:39,599
you can say with a routing stack and

00:35:37,440 --> 00:35:40,480
everything talks linux api net link api

00:35:39,599 --> 00:35:42,160
to the kernel

00:35:40,480 --> 00:35:45,839
and the kernel talks to the driver and

00:35:42,160 --> 00:35:45,839
the driver uploads it to the asex

00:35:45,920 --> 00:35:51,359
okay so the hardware

00:35:49,040 --> 00:35:52,960
there is a long list of hardware uh

00:35:51,359 --> 00:35:56,079
monies also on the call

00:35:52,960 --> 00:35:58,079
can probably list it down but uh

00:35:56,079 --> 00:35:59,760
in the interest of time this i'm not

00:35:58,079 --> 00:36:03,760
going to go detailed into this

00:35:59,760 --> 00:36:06,160
but one is from wnc with the marvel asic

00:36:03,760 --> 00:36:07,119
and the other one is a delta box with a

00:36:06,160 --> 00:36:09,440
melanox

00:36:07,119 --> 00:36:10,560
spectrum asic when i say melanox

00:36:09,440 --> 00:36:13,440
spectrum it means an

00:36:10,560 --> 00:36:15,920
oxfordshire driver that edo and erie

00:36:13,440 --> 00:36:15,920
work on

00:36:16,320 --> 00:36:22,720
so what are the components of this os

00:36:19,440 --> 00:36:24,960
it starts from onl onl the

00:36:22,720 --> 00:36:26,560
base system which is a debian based and

00:36:24,960 --> 00:36:28,480
onl is under ocp

00:36:26,560 --> 00:36:30,960
if people are not aware of ocp it's the

00:36:28,480 --> 00:36:34,320
open compute

00:36:30,960 --> 00:36:37,839
foundation started by facebook and it is

00:36:34,320 --> 00:36:39,440
a um it has a huge community for

00:36:37,839 --> 00:36:40,000
hardware vendors for open hardware

00:36:39,440 --> 00:36:44,079
vendors

00:36:40,000 --> 00:36:46,400
both servers nics and switches

00:36:44,079 --> 00:36:47,839
ol is part of that it was initially it

00:36:46,400 --> 00:36:50,320
initially came from big switch

00:36:47,839 --> 00:36:50,880
which got bought over by arista and some

00:36:50,320 --> 00:36:53,280
of our

00:36:50,880 --> 00:36:54,240
is maintaining this so the reason for

00:36:53,280 --> 00:36:56,640
picking up

00:36:54,240 --> 00:36:57,359
dent was uh onl for dentos mainly

00:36:56,640 --> 00:37:00,880
because

00:36:57,359 --> 00:37:03,280
it's already available base um

00:37:00,880 --> 00:37:04,079
and people can start using it the other

00:37:03,280 --> 00:37:07,200
thing that

00:37:04,079 --> 00:37:11,040
comes here is onlp onlp is

00:37:07,200 --> 00:37:13,760
not a linux api based but the community

00:37:11,040 --> 00:37:14,320
of onl or open hardware has grown so

00:37:13,760 --> 00:37:17,359
much

00:37:14,320 --> 00:37:17,920
that most of these vendors do have an

00:37:17,359 --> 00:37:21,839
onl

00:37:17,920 --> 00:37:23,599
driver and onl p compatible api

00:37:21,839 --> 00:37:26,320
okay then the next component is of

00:37:23,599 --> 00:37:29,680
course switched up drivers

00:37:26,320 --> 00:37:31,839
the platform drivers

00:37:29,680 --> 00:37:33,520
can be linux platform drivers and i'll i

00:37:31,839 --> 00:37:36,640
have a example to one

00:37:33,520 --> 00:37:39,040
uh by mellanox and onlp

00:37:36,640 --> 00:37:40,800
drivers will work too but the goal of

00:37:39,040 --> 00:37:42,720
the project is to actually

00:37:40,800 --> 00:37:44,880
move towards linux platform drivers

00:37:42,720 --> 00:37:47,040
where available

00:37:44,880 --> 00:37:48,240
software and control plane uh usual

00:37:47,040 --> 00:37:50,640
debian ecosystem

00:37:48,240 --> 00:37:51,520
fr for the control plane many packages

00:37:50,640 --> 00:37:53,599
from debian

00:37:51,520 --> 00:37:55,119
including uh iphone 2 for interface

00:37:53,599 --> 00:37:57,119
configuration

00:37:55,119 --> 00:37:59,520
additional capabilities in this

00:37:57,119 --> 00:38:01,920
particular space is power over ethernet

00:37:59,520 --> 00:38:03,280
and surprisingly again the power over

00:38:01,920 --> 00:38:07,200
ethernet

00:38:03,280 --> 00:38:10,400
is controlled by a bunch of user space

00:38:07,200 --> 00:38:11,920
commands or you know sdks so this is

00:38:10,400 --> 00:38:15,040
something

00:38:11,920 --> 00:38:19,839
um there is not an open

00:38:15,040 --> 00:38:19,839
um standard api for it

00:38:20,320 --> 00:38:24,480
so linux platform drivers i do want to

00:38:23,040 --> 00:38:27,200
touch upon this a little bit

00:38:24,480 --> 00:38:28,640
uh when during the inception of dent i

00:38:27,200 --> 00:38:32,560
am on the dent tse

00:38:28,640 --> 00:38:34,720
and it's hard to say

00:38:32,560 --> 00:38:36,160
when you when you tell people oh linux

00:38:34,720 --> 00:38:38,880
has platform drivers

00:38:36,160 --> 00:38:39,520
api and you know it's just uh csfs you

00:38:38,880 --> 00:38:43,359
can you

00:38:39,520 --> 00:38:45,200
use it right so and the only

00:38:43,359 --> 00:38:46,880
documentation structured documentation

00:38:45,200 --> 00:38:49,920
around it i found was

00:38:46,880 --> 00:38:50,800
or the dent team found was on a melanox

00:38:49,920 --> 00:38:54,000
implementation

00:38:50,800 --> 00:38:55,839
i have a link there but you can

00:38:54,000 --> 00:38:57,680
develop platform linux platform drivers

00:38:55,839 --> 00:39:02,640
for this using the linux api

00:38:57,680 --> 00:39:02,640
and so on so the example has been

00:39:02,800 --> 00:39:06,079
we have been trying to talk to people

00:39:04,800 --> 00:39:09,040
hardware vendors to move

00:39:06,079 --> 00:39:11,040
to this api but if you think about the

00:39:09,040 --> 00:39:14,480
future in the space i think

00:39:11,040 --> 00:39:16,160
acpi would be better if the hardware

00:39:14,480 --> 00:39:18,880
supports it

00:39:16,160 --> 00:39:20,960
one such effort was started long ago by

00:39:18,880 --> 00:39:22,240
cumulus under the ocp project it was

00:39:20,960 --> 00:39:26,240
called apd

00:39:22,240 --> 00:39:28,079
but i think that would be an easier way

00:39:26,240 --> 00:39:30,240
given servers use it as well

00:39:28,079 --> 00:39:32,400
to standardize some of these platform

00:39:30,240 --> 00:39:35,440
drivers

00:39:32,400 --> 00:39:37,359
um the switch ac offload drivers again

00:39:35,440 --> 00:39:39,280
called switch shift drivers melanox has

00:39:37,359 --> 00:39:41,280
had one mlx sw the edo

00:39:39,280 --> 00:39:42,640
just talked about it's been there in the

00:39:41,280 --> 00:39:44,880
tree for

00:39:42,640 --> 00:39:46,400
several versions of the kernel and the

00:39:44,880 --> 00:39:47,040
new switch up driver that is being

00:39:46,400 --> 00:39:49,599
submitted

00:39:47,040 --> 00:39:53,200
is by marvel and it is in its fourth

00:39:49,599 --> 00:39:53,200
version and going through reviews

00:39:55,359 --> 00:40:01,119
okay where to find dent the code is not

00:39:59,040 --> 00:40:01,599
public yet because the seed code needs

00:40:01,119 --> 00:40:04,640
to be

00:40:01,599 --> 00:40:08,560
a bit tested and integrated and then

00:40:04,640 --> 00:40:11,599
uh published there is a mailing list

00:40:08,560 --> 00:40:14,000
seed code will be out sometime soon

00:40:11,599 --> 00:40:14,880
there is a talk at oneis and this year

00:40:14,000 --> 00:40:18,960
we expect

00:40:14,880 --> 00:40:22,319
more workshops for this

00:40:18,960 --> 00:40:23,040
and given its use in onl i'm pretty sure

00:40:22,319 --> 00:40:26,000
it's going to be

00:40:23,040 --> 00:40:27,520
talked about in the ocp communities as

00:40:26,000 --> 00:40:31,440
well

00:40:27,520 --> 00:40:32,800
okay so i have a question actually

00:40:31,440 --> 00:40:35,839
regarding the code

00:40:32,800 --> 00:40:40,079
i'm having troubles to understand

00:40:35,839 --> 00:40:43,680
what exactly is the nature of this code

00:40:40,079 --> 00:40:46,240
i mean i understand that the

00:40:43,680 --> 00:40:47,040
the distribution is based on debian and

00:40:46,240 --> 00:40:49,280
there's

00:40:47,040 --> 00:40:51,040
apparently something on top of that what

00:40:49,280 --> 00:40:54,319
is that exactly

00:40:51,040 --> 00:40:57,440
so so onl is

00:40:54,319 --> 00:40:59,440
a debian derivative right like

00:40:57,440 --> 00:41:00,720
uh it has its build system and it comes

00:40:59,440 --> 00:41:03,680
with its own

00:41:00,720 --> 00:41:04,960
layer of olp which is an api library for

00:41:03,680 --> 00:41:08,640
platform

00:41:04,960 --> 00:41:09,359
and um and on top of that is just the

00:41:08,640 --> 00:41:11,280
kernel it

00:41:09,359 --> 00:41:12,720
onl allows you to pick any kernel that

00:41:11,280 --> 00:41:16,640
you want

00:41:12,720 --> 00:41:17,920
so for example right now it's an uh 5.6

00:41:16,640 --> 00:41:21,200
is being talked about

00:41:17,920 --> 00:41:22,160
to be picked up for dent uh other than

00:41:21,200 --> 00:41:24,319
that it's a

00:41:22,160 --> 00:41:25,359
combination of packages it's basically a

00:41:24,319 --> 00:41:29,119
distribution

00:41:25,359 --> 00:41:32,160
picking versions that it

00:41:29,119 --> 00:41:33,280
is needed and tested and the whole goal

00:41:32,160 --> 00:41:35,280
of the project is to put this

00:41:33,280 --> 00:41:39,040
distribution out there

00:41:35,280 --> 00:41:41,680
and put a hardware compatibility list

00:41:39,040 --> 00:41:43,760
does that answer your question i don't

00:41:41,680 --> 00:41:45,839
think so i i still i'm still missing the

00:41:43,760 --> 00:41:47,280
the what is the code about i mean what

00:41:45,839 --> 00:41:49,520
do you describe this uh

00:41:47,280 --> 00:41:51,119
basically any distribution the set of

00:41:49,520 --> 00:41:52,640
packages and the versions and stuff like

00:41:51,119 --> 00:41:55,920
that but

00:41:52,640 --> 00:41:58,640
there is some code which is not

00:41:55,920 --> 00:41:59,040
published yet but i have really no clue

00:41:58,640 --> 00:42:01,920
what

00:41:59,040 --> 00:42:03,200
this is about yeah the code is just

00:42:01,920 --> 00:42:06,319
basically the debian

00:42:03,200 --> 00:42:08,160
um the oil distribution the build system

00:42:06,319 --> 00:42:11,200
it's just like sonic right sonic

00:42:08,160 --> 00:42:12,800
is a if you go to sonic.com you will

00:42:11,200 --> 00:42:14,000
find a way to build the entire

00:42:12,800 --> 00:42:17,200
distribution

00:42:14,000 --> 00:42:17,839
and you will know that the project the

00:42:17,200 --> 00:42:20,319
listed

00:42:17,839 --> 00:42:21,520
hcl or hardware compatibility list that

00:42:20,319 --> 00:42:23,440
the project

00:42:21,520 --> 00:42:24,560
is talking about when you build a

00:42:23,440 --> 00:42:26,160
distribution with the

00:42:24,560 --> 00:42:27,839
instructions it will work on that

00:42:26,160 --> 00:42:29,200
hardware and it will come with that

00:42:27,839 --> 00:42:33,040
hardware

00:42:29,200 --> 00:42:35,359
drivers so when

00:42:33,040 --> 00:42:37,359
it's when you're talking about code of a

00:42:35,359 --> 00:42:38,319
distribution it is basically building

00:42:37,359 --> 00:42:40,079
that

00:42:38,319 --> 00:42:41,680
combination of packages and building

00:42:40,079 --> 00:42:44,319
that image

00:42:41,680 --> 00:42:47,359
of the operating system that can be

00:42:44,319 --> 00:42:49,680
installed via oni for example

00:42:47,359 --> 00:42:50,880
it's a start point yeah start point for

00:42:49,680 --> 00:42:52,240
writing your own knots

00:42:50,880 --> 00:42:54,000
so it takes care of some common

00:42:52,240 --> 00:42:57,040
packaging and common

00:42:54,000 --> 00:43:00,480
um platform driver needs

00:42:57,040 --> 00:43:01,839
for certain hardware okay can you hear

00:43:00,480 --> 00:43:05,599
me

00:43:01,839 --> 00:43:08,319
yeah i think that there are like two

00:43:05,599 --> 00:43:09,920
important things here one is the basic

00:43:08,319 --> 00:43:12,800
fact that

00:43:09,920 --> 00:43:14,880
building an only binary is something

00:43:12,800 --> 00:43:19,200
that people find challenging

00:43:14,880 --> 00:43:23,200
and this is done by oni like by nature

00:43:19,200 --> 00:43:24,960
and the second thing is like this huge

00:43:23,200 --> 00:43:26,400
heavy lifting that people need to do

00:43:24,960 --> 00:43:28,800
when they just want to

00:43:26,400 --> 00:43:32,000
introduce their new protocol or their

00:43:28,800 --> 00:43:34,560
new networking stack or whatever

00:43:32,000 --> 00:43:35,920
and they have this option for

00:43:34,560 --> 00:43:38,880
[Music]

00:43:35,920 --> 00:43:40,319
you know to start from something so it's

00:43:38,880 --> 00:43:43,440
it's just there and it's

00:43:40,319 --> 00:43:46,640
it's not trivial but it's useful

00:43:43,440 --> 00:43:49,440
yeah so if you compare it with sonic

00:43:46,640 --> 00:43:54,640
sonic is also like that today

00:43:49,440 --> 00:43:58,480
the um sonic project actually

00:43:54,640 --> 00:44:00,160
has a list of drivers that it supports

00:43:58,480 --> 00:44:01,920
or has a list of vendors that have

00:44:00,160 --> 00:44:03,440
contributed drivers so when you're

00:44:01,920 --> 00:44:05,760
building sonic you know that

00:44:03,440 --> 00:44:08,640
whatever comes out of it as a starting

00:44:05,760 --> 00:44:10,079
point you will have these particular

00:44:08,640 --> 00:44:12,560
drivers or it will work

00:44:10,079 --> 00:44:14,400
and the image that you can build an

00:44:12,560 --> 00:44:17,520
image only compatible image

00:44:14,400 --> 00:44:17,520
like what he was talking about

00:44:19,680 --> 00:44:25,839
okay and onl by the way oil is

00:44:22,800 --> 00:44:27,520
uh used uh

00:44:25,839 --> 00:44:29,280
rupa there's a bunch of questions people

00:44:27,520 --> 00:44:31,119
have raised their hands including me but

00:44:29,280 --> 00:44:34,839
uh

00:44:31,119 --> 00:44:37,839
you wanna look at those how do i see

00:44:34,839 --> 00:44:37,839
that

00:44:40,079 --> 00:44:47,119
i see jamal moni and rubens

00:44:44,160 --> 00:44:47,119
are raising the hands

00:44:47,760 --> 00:44:51,280
oh jamal and i don't see any raised

00:44:50,240 --> 00:44:54,079
hands

00:44:51,280 --> 00:44:56,240
are there any messages she's pretty in

00:44:54,079 --> 00:44:58,880
total

00:44:56,240 --> 00:45:00,160
i think that money just spoke so we can

00:44:58,880 --> 00:45:05,839
cross him out and

00:45:00,160 --> 00:45:05,839
rubens is next i guess

00:45:13,839 --> 00:45:21,119
um can you can you all hear me yeah

00:45:17,280 --> 00:45:24,000
okay um so regarding this um

00:45:21,119 --> 00:45:24,560
one challenge we found is to actually

00:45:24,000 --> 00:45:26,880
get uh

00:45:24,560 --> 00:45:28,160
platform code from from the vendor so

00:45:26,880 --> 00:45:30,319
from

00:45:28,160 --> 00:45:32,160
from the various vendors is there any

00:45:30,319 --> 00:45:35,520
work as well ongoing

00:45:32,160 --> 00:45:37,680
with this dent project to

00:45:35,520 --> 00:45:41,520
find an easier solution to actually get

00:45:37,680 --> 00:45:41,520
platform code and platform um

00:45:41,599 --> 00:45:48,079
information from the vendors yeah so

00:45:45,280 --> 00:45:49,280
what i have found is uh it's been hard

00:45:48,079 --> 00:45:53,440
to get them to

00:45:49,280 --> 00:45:56,640
adopt the linux model uh to

00:45:53,440 --> 00:45:57,680
build the drivers but if you look at onl

00:45:56,640 --> 00:46:00,880
and onlp

00:45:57,680 --> 00:46:05,040
most of these hardware vendors do have

00:46:00,880 --> 00:46:07,599
drivers and even the hardware specs i

00:46:05,040 --> 00:46:08,000
think ocp is the best place to get all

00:46:07,599 --> 00:46:10,000
the

00:46:08,000 --> 00:46:11,839
hardware specs for most of this hardware

00:46:10,000 --> 00:46:14,800
because the hardware is mostly common

00:46:11,839 --> 00:46:16,880
most of these vendors they submit to cpp

00:46:14,800 --> 00:46:18,640
they submit to

00:46:16,880 --> 00:46:20,800
the death project the sonic project and

00:46:18,640 --> 00:46:23,920
so on

00:46:20,800 --> 00:46:26,079
okay but so that help and

00:46:23,920 --> 00:46:27,520
yeah i guess so yeah but there's no

00:46:26,079 --> 00:46:29,760
there's no one effort

00:46:27,520 --> 00:46:32,160
just to centralize it as much as

00:46:29,760 --> 00:46:32,160
possible

00:46:32,319 --> 00:46:37,280
yeah no i i would say no

00:46:37,760 --> 00:46:43,920
that's why i comment there and it's like

00:46:42,640 --> 00:46:45,359
like how it's done in the server world

00:46:43,920 --> 00:46:47,680
would probably be the best long-term

00:46:45,359 --> 00:46:47,680
solution

00:46:48,480 --> 00:46:51,359
any other questions

00:46:53,040 --> 00:46:58,079
yeah so most of these

00:46:56,400 --> 00:46:59,440
type of distros i don't know i've heard

00:46:58,079 --> 00:47:01,760
of this nlp thing

00:46:59,440 --> 00:47:03,839
but do they uh how do they have

00:47:01,760 --> 00:47:06,000
dependencies their patches in the canal

00:47:03,839 --> 00:47:07,839
and their own drivers or their own

00:47:06,000 --> 00:47:11,599
patches nothing is upstream

00:47:07,839 --> 00:47:15,359
friendly right or is this different

00:47:11,599 --> 00:47:17,680
yes yeah many of them are out

00:47:15,359 --> 00:47:18,400
out of tree i think only melanox has

00:47:17,680 --> 00:47:21,680
entry

00:47:18,400 --> 00:47:24,880
drivers yeah

00:47:21,680 --> 00:47:28,720
and they probably have some patches that

00:47:24,880 --> 00:47:28,720
will never ever make it upstream

00:47:28,800 --> 00:47:33,200
yeah so i mean this is very unappealing

00:47:31,920 --> 00:47:35,280
if that's a right

00:47:33,200 --> 00:47:37,440
good english word it's not very

00:47:35,280 --> 00:47:39,359
appealing to have all these

00:47:37,440 --> 00:47:42,640
uh so you want to upgrade you start

00:47:39,359 --> 00:47:45,040
putting a lot of patches basically

00:47:42,640 --> 00:47:45,839
right you want to use your own kernel

00:47:45,040 --> 00:47:49,119
right

00:47:45,839 --> 00:47:52,240
yeah that's true but

00:47:49,119 --> 00:47:54,480
on the other hand i think that

00:47:52,240 --> 00:47:55,520
like there are projects which prove that

00:47:54,480 --> 00:47:58,480
this can work

00:47:55,520 --> 00:47:59,520
long term and eventually they can uh it

00:47:58,480 --> 00:48:02,720
can evolve like

00:47:59,520 --> 00:48:04,960
if you look at open wrt for example they

00:48:02,720 --> 00:48:06,000
they basically have had same thing and

00:48:04,960 --> 00:48:08,559
they're they are pushing

00:48:06,000 --> 00:48:10,079
things back and uh basically changing

00:48:08,559 --> 00:48:13,119
things upstream as well so

00:48:10,079 --> 00:48:16,160
it can work it can work in a certain uh

00:48:13,119 --> 00:48:17,520
space yeah and i think platforms is

00:48:16,160 --> 00:48:19,359
something that we should talk about in

00:48:17,520 --> 00:48:21,920
the linux communities as well so i

00:48:19,359 --> 00:48:23,119
i i think the difference with open wrt

00:48:21,920 --> 00:48:26,160
uh if i mean

00:48:23,119 --> 00:48:26,640
uh is it's mostly for consumer devices

00:48:26,160 --> 00:48:27,839
where

00:48:26,640 --> 00:48:29,520
you know i just want to run into my

00:48:27,839 --> 00:48:31,200
router i'm not interested in adding some

00:48:29,520 --> 00:48:33,119
extra feature

00:48:31,200 --> 00:48:34,640
whereas i think this will this code

00:48:33,119 --> 00:48:36,400
probably works on a few boxes you

00:48:34,640 --> 00:48:40,079
mentioned a melanox

00:48:36,400 --> 00:48:44,079
switch and a marvel i think right so

00:48:40,079 --> 00:48:45,839
right now it may not okay i i'm very

00:48:44,079 --> 00:48:46,720
skeptical about this i've suffered

00:48:45,839 --> 00:48:48,640
through

00:48:46,720 --> 00:48:50,880
crap that comes from broadcom i'm sorry

00:48:48,640 --> 00:48:54,240
if there's any broadcom people on there

00:48:50,880 --> 00:48:56,319
uh where they have all kinds i just want

00:48:54,240 --> 00:48:57,520
to build a kernel and it's hell

00:48:56,319 --> 00:49:00,319
i know because they have all these

00:48:57,520 --> 00:49:02,079
patches their own version of pcc

00:49:00,319 --> 00:49:03,920
their own brushes of the linker you

00:49:02,079 --> 00:49:04,960
can't use anything other than what they

00:49:03,920 --> 00:49:06,480
provide you and if

00:49:04,960 --> 00:49:08,160
it doesn't work you can't find the right

00:49:06,480 --> 00:49:10,559
person to answer the questions

00:49:08,160 --> 00:49:12,000
so but i think if you think see the open

00:49:10,559 --> 00:49:14,079
networking world i mean it's going to be

00:49:12,000 --> 00:49:16,559
a slow progress and it's come a long way

00:49:14,079 --> 00:49:17,119
i mean right now the trend that i see

00:49:16,559 --> 00:49:20,640
between

00:49:17,119 --> 00:49:24,720
norses sonic and um others

00:49:20,640 --> 00:49:27,839
i mean people are using uh technologies

00:49:24,720 --> 00:49:29,680
the recent one i uh s flow

00:49:27,839 --> 00:49:31,920
s float sample that was added to p

00:49:29,680 --> 00:49:32,640
sampling that was added for linux is now

00:49:31,920 --> 00:49:35,680
being used

00:49:32,640 --> 00:49:37,680
on most even on sonic so we

00:49:35,680 --> 00:49:39,040
do see cross pollination these days and

00:49:37,680 --> 00:49:41,920
hopefully things will

00:49:39,040 --> 00:49:43,280
rub in the right direction and hopefully

00:49:41,920 --> 00:49:47,200
we'll be talking about

00:49:43,280 --> 00:49:49,920
it in good terms next

00:49:47,200 --> 00:49:49,920
following years

00:49:52,559 --> 00:49:58,400
yeah i think documentation is key i'm

00:49:55,760 --> 00:49:58,960
on platform drivers especially like the

00:49:58,400 --> 00:50:01,359
debug

00:49:58,960 --> 00:50:02,240
fs common that edo made so there's a lot

00:50:01,359 --> 00:50:05,440
of csfs

00:50:02,240 --> 00:50:07,359
file stuff that many vendors do as well

00:50:05,440 --> 00:50:10,880
which is not standardized right the

00:50:07,359 --> 00:50:14,319
usual cfs thermal monitoring and

00:50:10,880 --> 00:50:14,800
many other things so yeah i think we'll

00:50:14,319 --> 00:50:19,119
have a

00:50:14,800 --> 00:50:22,960
deeper discussion probably in the next

00:50:19,119 --> 00:50:27,440
workshop so i've got a question in that

00:50:22,960 --> 00:50:30,079
area in your previous attempts with acpi

00:50:27,440 --> 00:50:31,839
did you get the linux acpi maintenance

00:50:30,079 --> 00:50:34,160
involved or the ufa

00:50:31,839 --> 00:50:35,200
or was it just your own personal work no

00:50:34,160 --> 00:50:37,760
i think russell

00:50:35,200 --> 00:50:38,800
russell king was the uh or i'm getting

00:50:37,760 --> 00:50:41,839
the name wrong

00:50:38,800 --> 00:50:42,720
wasn't he the yeah i'll send you

00:50:41,839 --> 00:50:46,400
pointers uh

00:50:42,720 --> 00:50:46,960
andrew i think you are the best person

00:50:46,400 --> 00:50:51,359
to

00:50:46,960 --> 00:50:53,359
uh tell us if that can be taken further

00:50:51,359 --> 00:50:55,839
actually i'm the wrong person because i

00:50:53,359 --> 00:50:58,960
clearly say i know nothing about scpi

00:50:55,839 --> 00:51:02,559
and i defer to the ac api maintainers

00:50:58,960 --> 00:51:02,559
and they don't want to get involved

00:51:02,720 --> 00:51:07,599
which is i'll come on to that a little

00:51:04,400 --> 00:51:12,160
bit in my part of the presentation

00:51:07,599 --> 00:51:15,119
sounds good so i think i will

00:51:12,160 --> 00:51:17,680
end this and i'll try to cover my next

00:51:15,119 --> 00:51:20,800
networking updates in

00:51:17,680 --> 00:51:20,800
say five minutes

00:51:21,359 --> 00:51:24,160
let me share

00:51:27,520 --> 00:51:32,240
but uh on a ending on a positive note

00:51:30,480 --> 00:51:34,160
jamal for you too i think

00:51:32,240 --> 00:51:36,000
there is interest in moving to the

00:51:34,160 --> 00:51:37,599
platform drivers and upstream drivers i

00:51:36,000 --> 00:51:40,400
think it's going to take some time i

00:51:37,599 --> 00:51:42,480
think marvel is also working on it

00:51:40,400 --> 00:51:44,559
okay i'm actually pleasantly surprised i

00:51:42,480 --> 00:51:45,440
had marvel had a switch dave driver that

00:51:44,559 --> 00:51:48,480
was good

00:51:45,440 --> 00:51:51,520
there's progress being there yeah yeah

00:51:48,480 --> 00:51:54,480
all that layer 2 switches are switch dev

00:51:51,520 --> 00:51:58,720
drivers via dsa

00:51:54,480 --> 00:52:00,559
oh cool yeah

00:51:58,720 --> 00:52:01,920
so i see all those nice patches but i

00:52:00,559 --> 00:52:04,400
wonder if there's a

00:52:01,920 --> 00:52:06,640
commodity hardware i can buy and test it

00:52:04,400 --> 00:52:06,640
out

00:52:07,839 --> 00:52:11,760
do you say 10's been more used in

00:52:09,839 --> 00:52:19,839
industrial settings and not

00:52:11,760 --> 00:52:19,839
black box layer 2 switches

00:52:20,400 --> 00:52:24,480
okay so yeah interest of time i'm just

00:52:24,079 --> 00:52:28,559
going to

00:52:24,480 --> 00:52:31,839
start and try to run through this

00:52:28,559 --> 00:52:33,839
this work so basically

00:52:31,839 --> 00:52:35,119
is similar to the lines of what you

00:52:33,839 --> 00:52:38,000
covered it's basically

00:52:35,119 --> 00:52:38,880
the um patches that are going in

00:52:38,000 --> 00:52:40,800
upstream to

00:52:38,880 --> 00:52:42,800
support networking more networking

00:52:40,800 --> 00:52:44,800
features on uh switch asic

00:52:42,800 --> 00:52:46,160
so one key thing or one important thing

00:52:44,800 --> 00:52:49,200
that has happened in

00:52:46,160 --> 00:52:50,800
recent times is the

00:52:49,200 --> 00:52:52,720
fire multi-homing it still i think the

00:52:50,800 --> 00:52:56,480
code is mostly upstream

00:52:52,720 --> 00:53:00,240
but fr will become the

00:52:56,480 --> 00:53:01,040
open implementation of any multi-homing

00:53:00,240 --> 00:53:04,960
protocol

00:53:01,040 --> 00:53:06,640
and if you

00:53:04,960 --> 00:53:08,400
don't know what i'm talking about it's

00:53:06,640 --> 00:53:10,319
basically connected to two switches

00:53:08,400 --> 00:53:12,400
there is a software running a protocol

00:53:10,319 --> 00:53:15,599
running between the switches to actually

00:53:12,400 --> 00:53:17,920
keep that sessions alive

00:53:15,599 --> 00:53:18,960
right there is failover there is uh

00:53:17,920 --> 00:53:21,359
filtering that is

00:53:18,960 --> 00:53:22,400
duplicate packet handling and basically

00:53:21,359 --> 00:53:25,119
a backup each

00:53:22,400 --> 00:53:26,400
switch acts as a backup to the other and

00:53:25,119 --> 00:53:28,400
this is a traditional multi-homing

00:53:26,400 --> 00:53:29,839
solution and um

00:53:28,400 --> 00:53:32,480
what i'm going to talk about is an open

00:53:29,839 --> 00:53:35,599
implementation or open standard protocol

00:53:32,480 --> 00:53:36,240
but uh prior to this uh there has been

00:53:35,599 --> 00:53:38,160
no

00:53:36,240 --> 00:53:40,640
such protocol everybody every vendor has

00:53:38,160 --> 00:53:44,400
had their own proprietary implementation

00:53:40,640 --> 00:53:47,280
um yeah so

00:53:44,400 --> 00:53:48,319
what is the open um multi-homing

00:53:47,280 --> 00:53:50,960
solution it's

00:53:48,319 --> 00:53:51,440
on the expand overlay it's called evpn

00:53:50,960 --> 00:53:52,960
if you

00:53:51,440 --> 00:53:54,880
you'll probably hear a lot about this on

00:53:52,960 --> 00:53:59,119
the fr mailing lists

00:53:54,880 --> 00:54:02,400
um the idea is it's a bgp based

00:53:59,119 --> 00:54:04,880
evpn multi-homing control plane um

00:54:02,400 --> 00:54:06,400
you connect your server to multiple

00:54:04,880 --> 00:54:08,400
switches there is no limitation of two

00:54:06,400 --> 00:54:11,440
right now and there is it can move to

00:54:08,400 --> 00:54:12,240
any number redundant switches and the

00:54:11,440 --> 00:54:13,760
switches

00:54:12,240 --> 00:54:16,000
instead of having a dedicated link

00:54:13,760 --> 00:54:18,480
between them they use the vxlan overlay

00:54:16,000 --> 00:54:20,880
to you know do whatever is required to

00:54:18,480 --> 00:54:24,559
keep that

00:54:20,880 --> 00:54:28,000
redundancy alive

00:54:24,559 --> 00:54:30,720
so the one thing that um

00:54:28,000 --> 00:54:32,400
a feature that went into recently is the

00:54:30,720 --> 00:54:34,720
use of fdb

00:54:32,400 --> 00:54:35,920
ecmp next-door groups so i'll mention

00:54:34,720 --> 00:54:39,119
david here again

00:54:35,920 --> 00:54:42,160
since he's here um so david

00:54:39,119 --> 00:54:44,240
uh like you mentioned he added the route

00:54:42,160 --> 00:54:45,599
next stop group support and that was

00:54:44,240 --> 00:54:47,119
perfect for this

00:54:45,599 --> 00:54:49,280
i'm glad that his patches went in

00:54:47,119 --> 00:54:52,799
earlier otherwise it would have been

00:54:49,280 --> 00:54:55,839
a yeah huge project

00:54:52,799 --> 00:54:56,799
so what this means is vxlan since now

00:54:55,839 --> 00:55:00,000
vxlan

00:54:56,799 --> 00:55:01,599
can talk to okay let me take a step back

00:55:00,000 --> 00:55:05,280
now you're talking to

00:55:01,599 --> 00:55:08,319
multiple multi-homing peers switch peers

00:55:05,280 --> 00:55:11,520
over vxlan and you can have two

00:55:08,319 --> 00:55:13,200
or more redundant uh pairs and you want

00:55:11,520 --> 00:55:16,799
to basically ecmp

00:55:13,200 --> 00:55:18,559
some of the uh forwarding to them

00:55:16,799 --> 00:55:20,480
right because the hosts are connected

00:55:18,559 --> 00:55:23,520
from all the three all the

00:55:20,480 --> 00:55:25,680
participating switches and the

00:55:23,520 --> 00:55:27,920
example here basically shows a vxlan fdb

00:55:25,680 --> 00:55:30,640
entry which points to an extra group and

00:55:27,920 --> 00:55:34,240
the next stop group

00:55:30,640 --> 00:55:34,960
is uh created by the nextrop group uh

00:55:34,240 --> 00:55:38,799
api

00:55:34,960 --> 00:55:38,799
that david uh added

00:55:39,200 --> 00:55:42,880
thanks for the review and support there

00:55:40,559 --> 00:55:44,720
david um

00:55:42,880 --> 00:55:46,559
so another set of challenges uh

00:55:44,720 --> 00:55:50,240
supporting such a multi-homing protocol

00:55:46,559 --> 00:55:52,720
is basically on the switches since we

00:55:50,240 --> 00:55:55,119
use the linux networking stack

00:55:52,720 --> 00:55:56,640
along with the control plane protocol

00:55:55,119 --> 00:55:59,359
and

00:55:56,640 --> 00:56:01,280
the control plane is understands the

00:55:59,359 --> 00:56:04,000
distributed

00:56:01,280 --> 00:56:05,599
neighbor and ip relationships of hosts

00:56:04,000 --> 00:56:08,240
from all other switches

00:56:05,599 --> 00:56:09,839
but at the same time it is relying on

00:56:08,240 --> 00:56:12,720
the linux kernel bridge

00:56:09,839 --> 00:56:14,720
and the linux kernel neighbor database

00:56:12,720 --> 00:56:17,760
to

00:56:14,720 --> 00:56:20,240
understand or to uh learn

00:56:17,760 --> 00:56:21,200
local entries locally connected entries

00:56:20,240 --> 00:56:23,920
okay

00:56:21,200 --> 00:56:24,799
it understands stuff from the vxlan

00:56:23,920 --> 00:56:28,079
because it

00:56:24,799 --> 00:56:31,520
via the protocol but what we found is

00:56:28,079 --> 00:56:32,960
and uh if our team has come has

00:56:31,520 --> 00:56:36,319
had approached us with a bunch of

00:56:32,960 --> 00:56:36,319
requests on how to

00:56:36,720 --> 00:56:40,240
make this easier on the control plane

00:56:39,359 --> 00:56:42,319
basically

00:56:40,240 --> 00:56:44,079
colonel is racing to colonel just

00:56:42,319 --> 00:56:46,880
received a packet because the host

00:56:44,079 --> 00:56:49,440
moved and okay one step back again this

00:56:46,880 --> 00:56:52,319
is mostly these race conditions involve

00:56:49,440 --> 00:56:52,720
uh mac moves when a host moves from

00:56:52,319 --> 00:56:55,040
being

00:56:52,720 --> 00:56:57,280
a local locally collect connected host

00:56:55,040 --> 00:56:59,200
to you know it moves over the vxlan to

00:56:57,280 --> 00:57:01,280
another rack

00:56:59,200 --> 00:57:02,559
so what we are talking about here is

00:57:01,280 --> 00:57:05,920
kernel just learning

00:57:02,559 --> 00:57:07,920
a neighbor locally when bgp is not still

00:57:05,920 --> 00:57:09,280
understood and bgb is trying to update

00:57:07,920 --> 00:57:11,280
the kernel and

00:57:09,280 --> 00:57:13,599
there could be a race between the net

00:57:11,280 --> 00:57:17,599
link api and the kernel itself

00:57:13,599 --> 00:57:19,520
learning that object through a packet

00:57:17,599 --> 00:57:20,640
and some of the api extensions here were

00:57:19,520 --> 00:57:24,000
done to

00:57:20,640 --> 00:57:26,240
ease that possibility of races

00:57:24,000 --> 00:57:27,839
one is the bridge notify which nikolai

00:57:26,240 --> 00:57:31,040
um nikolai added

00:57:27,839 --> 00:57:33,119
this is to indicate to

00:57:31,040 --> 00:57:34,240
the control plane that hey this mac is

00:57:33,119 --> 00:57:36,880
particularly

00:57:34,240 --> 00:57:38,480
is look has become locally active it's

00:57:36,880 --> 00:57:40,240
it generates a net link notification

00:57:38,480 --> 00:57:43,599
asynchronous notification

00:57:40,240 --> 00:57:44,160
to indicate that oh this neighbor which

00:57:43,599 --> 00:57:46,160
was

00:57:44,160 --> 00:57:47,280
static or which was considered

00:57:46,160 --> 00:57:49,839
previously

00:57:47,280 --> 00:57:52,000
not locally active is now locally active

00:57:49,839 --> 00:57:55,200
and then the local timers kick in

00:57:52,000 --> 00:57:56,720
similarly in the neighbor entry there is

00:57:55,200 --> 00:57:58,799
a patch pending we have not have

00:57:56,720 --> 00:58:01,200
streamed it yet but there is a

00:57:58,799 --> 00:58:04,240
new flag to indicate that a particular

00:58:01,200 --> 00:58:06,319
neighbor is seen by my peer switch

00:58:04,240 --> 00:58:07,280
but i also want to know if you are

00:58:06,319 --> 00:58:10,960
seeing it

00:58:07,280 --> 00:58:11,760
again to converge faster in a case of a

00:58:10,960 --> 00:58:14,880
mac

00:58:11,760 --> 00:58:14,880
or of a host move

00:58:15,359 --> 00:58:20,480
so in general miscellaneous updates

00:58:18,559 --> 00:58:21,839
there is a proto-down reason that went

00:58:20,480 --> 00:58:24,640
in it's a small patch

00:58:21,839 --> 00:58:26,440
it's uh but there was a huge request for

00:58:24,640 --> 00:58:29,599
it from most of the network

00:58:26,440 --> 00:58:33,520
operating people or operators

00:58:29,599 --> 00:58:35,520
uh on why doesn't linux support a way to

00:58:33,520 --> 00:58:37,760
indicate a link was brought down by a

00:58:35,520 --> 00:58:41,520
protocol and existence of multiple

00:58:37,760 --> 00:58:44,079
users of that proto-down flag

00:58:41,520 --> 00:58:46,240
so proto-town is basically a net device

00:58:44,079 --> 00:58:47,760
flag it just puts the interface down on

00:58:46,240 --> 00:58:49,839
request of a control plane

00:58:47,760 --> 00:58:51,440
it brings the carrier down because the

00:58:49,839 --> 00:58:53,680
administrator does not know about it

00:58:51,440 --> 00:58:55,520
because the protocol has to put it down

00:58:53,680 --> 00:58:56,960
and the reasons for this the main reason

00:58:55,520 --> 00:58:58,960
is in a multi-homing protocol

00:58:56,960 --> 00:59:00,559
where you know you have to put a link

00:58:58,960 --> 00:59:01,520
down and the control plane knows better

00:59:00,559 --> 00:59:04,319
because you don't

00:59:01,520 --> 00:59:06,079
want packets looping or duplicate

00:59:04,319 --> 00:59:10,400
packets to the hosts

00:59:06,079 --> 00:59:13,839
and vrp uses it today also to indicate a

00:59:10,400 --> 00:59:19,599
backup backup

00:59:13,839 --> 00:59:21,599
switch and so on so the idea is here and

00:59:19,599 --> 00:59:24,799
this goes hand in hand with the

00:59:21,599 --> 00:59:27,280
uh eath tool uh extended link state

00:59:24,799 --> 00:59:28,720
that was added recently by uh melanox

00:59:27,280 --> 00:59:29,520
and i think edo was going to talk about

00:59:28,720 --> 00:59:33,040
it but

00:59:29,520 --> 00:59:35,680
he ran out of time as well but this

00:59:33,040 --> 00:59:36,240
these are the reasons for why a link is

00:59:35,680 --> 00:59:40,000
down

00:59:36,240 --> 00:59:42,480
and that could be yeah um

00:59:40,000 --> 00:59:44,799
this actually the link each tool

00:59:42,480 --> 00:59:46,319
extended state could also have a proto

00:59:44,799 --> 00:59:48,160
down okay this reason

00:59:46,319 --> 00:59:49,920
it's because of the proton that needs to

00:59:48,160 --> 00:59:53,200
be added

00:59:49,920 --> 00:59:53,839
so in other um other switch off load

00:59:53,200 --> 00:59:56,799
stuff

00:59:53,839 --> 00:59:57,280
uh this is not supported by a switched

00:59:56,799 --> 01:00:01,839
up drive

00:59:57,280 --> 01:00:01,839
but just an update

01:00:08,720 --> 01:00:14,720
[Music]

01:00:11,599 --> 01:00:16,319
basically you and this is the main

01:00:14,720 --> 01:00:17,839
thing is about dynamic nat where you

01:00:16,319 --> 01:00:19,599
need to collaborate with the kernel and

01:00:17,839 --> 01:00:21,280
the hardware to actually

01:00:19,599 --> 01:00:22,960
get the nat rules and hardware the

01:00:21,280 --> 01:00:26,559
dynamically learned nat rules

01:00:22,960 --> 01:00:28,559
and this is uh iptables dynamic entry

01:00:26,559 --> 01:00:30,960
trap the first packet to cpu matching

01:00:28,559 --> 01:00:32,079
the nat entry and then contract does its

01:00:30,960 --> 01:00:35,520
usual job

01:00:32,079 --> 01:00:37,119
and the switch asic driver will listen

01:00:35,520 --> 01:00:40,240
to the net link notification

01:00:37,119 --> 01:00:42,079
and program be dynamically created route

01:00:40,240 --> 01:00:44,079
by contract into hardware

01:00:42,079 --> 01:00:45,599
and from then the nat happens in

01:00:44,079 --> 01:00:48,799
hardware so this was

01:00:45,599 --> 01:00:49,920
another uh example of how easily the

01:00:48,799 --> 01:00:52,480
kernel data plane

01:00:49,920 --> 01:00:55,200
and hardware can work together on

01:00:52,480 --> 01:00:58,160
something like this

01:00:55,200 --> 01:00:59,440
okay so i i raised my hand uh i don't

01:00:58,160 --> 01:01:02,480
know if you saw that

01:00:59,440 --> 01:01:05,599
if you want on that slide right

01:01:02,480 --> 01:01:07,520
so yes yes

01:01:05,599 --> 01:01:09,520
uh why why do you need a contract in

01:01:07,520 --> 01:01:11,119
this case i'm assuming that whatever

01:01:09,520 --> 01:01:12,720
that is in hardware is probably very

01:01:11,119 --> 01:01:14,400
stateless right

01:01:12,720 --> 01:01:16,880
you don't need common tracking you just

01:01:14,400 --> 01:01:20,319
need to probably pay the translate

01:01:16,880 --> 01:01:20,799
uh ip address to ip address yeah unless

01:01:20,319 --> 01:01:22,480
you are

01:01:20,799 --> 01:01:24,559
saying you can also do quotes or you

01:01:22,480 --> 01:01:27,280
only do ipi destroy the address

01:01:24,559 --> 01:01:27,680
yes so this is dynamic nat where you

01:01:27,280 --> 01:01:30,160
give

01:01:27,680 --> 01:01:31,760
a range of ip addresses and ports and

01:01:30,160 --> 01:01:34,880
you

01:01:31,760 --> 01:01:37,359
want to kernel will allocate a pick a

01:01:34,880 --> 01:01:40,480
particular

01:01:37,359 --> 01:01:42,240
address from that range to snap and dnat

01:01:40,480 --> 01:01:44,400
and create the contract entry and that

01:01:42,240 --> 01:01:48,480
entry is what you want to really

01:01:44,400 --> 01:01:50,000
uh add it into the uh no i mean i mean

01:01:48,480 --> 01:01:52,319
this is a bit heavy which is what i'm

01:01:50,000 --> 01:01:56,400
saying right you you basically

01:01:52,319 --> 01:01:57,760
are listening to contracting

01:01:56,400 --> 01:01:59,520
and you're running contracting on the

01:01:57,760 --> 01:02:00,799
switch just so you can add an ad

01:01:59,520 --> 01:02:03,599
unless you have other users with a

01:02:00,799 --> 01:02:07,200
contract yes on the switch

01:02:03,599 --> 01:02:10,480
could you not have used you see

01:02:07,200 --> 01:02:11,440
yes of course i know that i have the pc

01:02:10,480 --> 01:02:13,920
in there

01:02:11,440 --> 01:02:15,680
yes yes it has not but it's only state

01:02:13,920 --> 01:02:16,400
statelessnet which is what you need i

01:02:15,680 --> 01:02:18,799
think which maps

01:02:16,400 --> 01:02:22,079
much better to hydra because all you

01:02:18,799 --> 01:02:26,079
have to do is uh basically inject uh

01:02:22,079 --> 01:02:29,760
net link right into the kernel yes

01:02:26,079 --> 01:02:31,440
so yes dc is in the exploration part uh

01:02:29,760 --> 01:02:35,760
jamal as you know we are still using ip

01:02:31,440 --> 01:02:37,119
tables and we are looking at pc as well

01:02:35,760 --> 01:02:38,500
okay i won't give you a hard time

01:02:37,119 --> 01:02:42,120
grouper yes please

01:02:38,500 --> 01:02:42,120
[Laughter]

01:02:44,160 --> 01:02:47,680
i'm going to quick status update on

01:02:46,160 --> 01:02:50,960
what's happened on

01:02:47,680 --> 01:02:54,240
dsa which is basically layer 2 switches

01:02:50,960 --> 01:03:03,839
and the layer 1 part of

01:02:54,240 --> 01:03:03,839
the linux kernel so next slide please

01:03:04,400 --> 01:03:11,680
so dsa currently supports

01:03:07,599 --> 01:03:13,839
around 100 layer 2 switches

01:03:11,680 --> 01:03:16,400
and that's totally in the kernel no

01:03:13,839 --> 01:03:18,880
binary blobs or anything you can just

01:03:16,400 --> 01:03:18,880
use it

01:03:19,200 --> 01:03:24,400
dsa causes confusion because people

01:03:21,839 --> 01:03:26,480
don't realize that dsa is a wrap around

01:03:24,400 --> 01:03:30,559
switch dev so that's a hundred

01:03:26,480 --> 01:03:33,359
switch dev switches are supported

01:03:30,559 --> 01:03:33,359
at layer 2.

01:03:34,559 --> 01:03:38,880
this year it seems like microchip have

01:03:37,119 --> 01:03:42,000
been quite busy

01:03:38,880 --> 01:03:45,599
in terms of all these ksd devices

01:03:42,000 --> 01:03:46,880
atheros also one of their switches was

01:03:45,599 --> 01:03:50,079
supported

01:03:46,880 --> 01:03:51,359
on felix felix is a bit of a funny one

01:03:50,079 --> 01:03:54,960
because it's from

01:03:51,359 --> 01:03:56,839
micro semi which got bought by

01:03:54,960 --> 01:04:00,400
micro chip so it's actually another

01:03:56,839 --> 01:04:02,880
microchip device

01:04:00,400 --> 01:04:04,400
generally the vendors themselves are not

01:04:02,880 --> 01:04:07,680
supporting these devices

01:04:04,400 --> 01:04:10,799
it's the community and in the case of

01:04:07,680 --> 01:04:12,559
felix it's actually embedded in an nxp

01:04:10,799 --> 01:04:15,280
device and it's nxp

01:04:12,559 --> 01:04:17,200
that have done all the work so it's

01:04:15,280 --> 01:04:19,599
quite a complex relationship between

01:04:17,200 --> 01:04:22,559
vendors contributors people just doing

01:04:19,599 --> 01:04:22,559
it for whatever fun

01:04:24,240 --> 01:04:30,160
the core itself of dsa is pretty stable

01:04:27,760 --> 01:04:31,280
there's not been many changes a few bug

01:04:30,160 --> 01:04:34,640
fixes

01:04:31,280 --> 01:04:38,079
q and q was recently added but no

01:04:34,640 --> 01:04:40,000
new big features basically it does what

01:04:38,079 --> 01:04:42,960
people want it to do

01:04:40,000 --> 01:04:43,520
so basically if you're at the layer 2

01:04:42,960 --> 01:04:46,559
linux

01:04:43,520 --> 01:04:48,480
probably supports what you need

01:04:46,559 --> 01:04:49,920
it's just a case of is the specific

01:04:48,480 --> 01:04:52,480
switch you're interested in

01:04:49,920 --> 01:04:52,480
supported

01:04:52,960 --> 01:04:57,680
so anything that's marvel anything it's

01:04:54,799 --> 01:05:00,799
broadcom atla 2

01:04:57,680 --> 01:05:01,920
microchip microsemi some atheros devices

01:05:00,799 --> 01:05:03,680
etc etc

01:05:01,920 --> 01:05:06,160
yeah there's pretty good support at

01:05:03,680 --> 01:05:06,160
layer2

01:05:07,200 --> 01:05:10,400
okay next slide please

01:05:11,839 --> 01:05:15,520
yo mike's muted rupert

01:05:19,599 --> 01:05:25,920
sorry my lip reading is not so good okay

01:05:22,880 --> 01:05:26,720
sorry no you said community supported

01:05:25,920 --> 01:05:30,319
drivers

01:05:26,720 --> 01:05:32,799
i so broadcom and marvel i do see

01:05:30,319 --> 01:05:33,760
submissions from them so they are

01:05:32,799 --> 01:05:36,960
whether to the

01:05:33,760 --> 01:05:37,520
upstream do they deploy they tend to be

01:05:36,960 --> 01:05:40,319
doing

01:05:37,520 --> 01:05:41,039
more layer 3 stuff there's never been a

01:05:40,319 --> 01:05:45,839
patch from

01:05:41,039 --> 01:05:50,079
marvel for marvel layer 2

01:05:45,839 --> 01:05:51,680
and the layer 3 stuff the bobcat and all

01:05:50,079 --> 01:05:54,799
that stuff that's come now

01:05:51,680 --> 01:05:56,319
has come in directly via another company

01:05:54,799 --> 01:05:59,039
i know there's some sort of sponsorship

01:05:56,319 --> 01:06:02,319
deal there but marvel themselves

01:05:59,039 --> 01:06:04,400
tend to be not involved directly

01:06:02,319 --> 01:06:07,359
okay broadcom yeah you've got a bit of

01:06:04,400 --> 01:06:09,680
support from florian

01:06:07,359 --> 01:06:11,280
so yeah there's a bit there and it

01:06:09,680 --> 01:06:12,319
varies microchip tends to be a little

01:06:11,280 --> 01:06:15,599
bit involved

01:06:12,319 --> 01:06:17,760
but generally the vendors themselves

01:06:15,599 --> 01:06:20,480
are at harm's length they're not really

01:06:17,760 --> 01:06:23,680
involved in producing the drivers

01:06:20,480 --> 01:06:26,240
there's been a general move in this

01:06:23,680 --> 01:06:28,480
segment of the market towards multi-gig

01:06:26,240 --> 01:06:32,079
so 2.5 gig five gig

01:06:28,480 --> 01:06:34,880
10 gig and that's required more c45

01:06:32,079 --> 01:06:35,440
support and that's been maturing over

01:06:34,880 --> 01:06:37,280
the last

01:06:35,440 --> 01:06:38,640
year so there's a lot more

01:06:37,280 --> 01:06:41,920
infrastructure in place

01:06:38,640 --> 01:06:45,440
for c45 multi gigs that

01:06:41,920 --> 01:06:46,000
follow the standard the older devices

01:06:45,440 --> 01:06:47,760
actually didn't

01:06:46,000 --> 01:06:49,200
follow the standard so they're causing

01:06:47,760 --> 01:06:52,640
issues but the new ones

01:06:49,200 --> 01:06:52,640
yeah they're pretty okay

01:06:52,960 --> 01:06:56,559
what's also taken landed in the next

01:06:55,280 --> 01:06:59,680
last few months

01:06:56,559 --> 01:07:01,359
is the new east tool used netlink

01:06:59,680 --> 01:07:03,119
that took a long time to actually come

01:07:01,359 --> 01:07:06,400
but now it's there

01:07:03,119 --> 01:07:08,000
there's a few compatibility issues where

01:07:06,400 --> 01:07:09,599
it doesn't do quite the same as the

01:07:08,000 --> 01:07:12,319
ioctl interface

01:07:09,599 --> 01:07:13,440
but they're also being sorting out and

01:07:12,319 --> 01:07:16,079
they expect soon

01:07:13,440 --> 01:07:18,160
new features will start being added

01:07:16,079 --> 01:07:19,680
which you can't do with the iocto

01:07:18,160 --> 01:07:22,720
interface but netlink

01:07:19,680 --> 01:07:25,599
does and one good example that is the

01:07:22,720 --> 01:07:28,960
work i did with cable testing

01:07:25,599 --> 01:07:31,760
so there's now cable testing support for

01:07:28,960 --> 01:07:34,400
the marvel fights the broadcom fires and

01:07:31,760 --> 01:07:37,520
the atheros 5's

01:07:34,400 --> 01:07:40,240
only one gig at the moment the

01:07:37,520 --> 01:07:41,119
marvel 10 gig fight should also support

01:07:40,240 --> 01:07:42,799
it

01:07:41,119 --> 01:07:44,559
but nobody's written the driver code for

01:07:42,799 --> 01:07:47,839
it yet and i'm sure that

01:07:44,559 --> 01:07:48,559
other vendors fires can do it as well

01:07:47,839 --> 01:07:51,760
certainly

01:07:48,559 --> 01:07:54,799
the aquantea now marvel

01:07:51,760 --> 01:07:57,920
files have cable test support

01:07:54,799 --> 01:08:02,240
so over time we can expect more

01:07:57,920 --> 01:08:02,240
fis to start sporting cable test

01:08:02,559 --> 01:08:07,440
the marvel 5 is a bit unique in that it

01:08:05,280 --> 01:08:10,400
gives you access to the raw

01:08:07,440 --> 01:08:11,839
tdr data the time division reflectometer

01:08:10,400 --> 01:08:13,599
data

01:08:11,839 --> 01:08:16,080
whereas all the others just give you

01:08:13,599 --> 01:08:19,279
result the pair is broken the cash

01:08:16,080 --> 01:08:22,480
pair is shorted or everything's okay

01:08:19,279 --> 01:08:26,480
when you're lucky i've got a screenshot

01:08:22,480 --> 01:08:26,480
coming up later of what that looks like

01:08:26,880 --> 01:08:33,120
there's also been interest in acpi

01:08:29,920 --> 01:08:36,640
at layer one how you

01:08:33,120 --> 01:08:39,839
describe the file the sfps

01:08:36,640 --> 01:08:43,359
all the gpios etc in

01:08:39,839 --> 01:08:44,719
more system-on-chip setups unfortunately

01:08:43,359 --> 01:08:47,359
that was pretty much

01:08:44,719 --> 01:08:48,239
dead on arrival because the acpi

01:08:47,359 --> 01:08:50,239
maintainers

01:08:48,239 --> 01:08:52,239
don't want to get involved they won't

01:08:50,239 --> 01:08:54,080
act the patches they won't knock the

01:08:52,239 --> 01:08:57,040
patches

01:08:54,080 --> 01:08:57,040
they're just not helpful

01:08:57,199 --> 01:09:02,880
it really needs the vendors to start

01:09:00,960 --> 01:09:06,960
writing standards the ventus

01:09:02,880 --> 01:09:10,480
does to go to uf it and get this part of

01:09:06,960 --> 01:09:13,679
the sapi standards

01:09:10,480 --> 01:09:17,040
really the issue here is that when arm

01:09:13,679 --> 01:09:20,239
standardized on scpi they standardized

01:09:17,040 --> 01:09:23,440
how you do

01:09:20,239 --> 01:09:26,560
disks so sata how you do pci

01:09:23,440 --> 01:09:29,679
how you do serial ports etc etc

01:09:26,560 --> 01:09:31,040
but they totally forgot about networking

01:09:29,679 --> 01:09:34,319
other made the assumption that

01:09:31,040 --> 01:09:37,199
networking is going to be pcie

01:09:34,319 --> 01:09:38,640
whereas silicon vendors many of them are

01:09:37,199 --> 01:09:41,920
incorporating

01:09:38,640 --> 01:09:45,040
nicks on their silicon and there's no

01:09:41,920 --> 01:09:45,759
nice way to describe the complexity of a

01:09:45,040 --> 01:09:49,920
nic

01:09:45,759 --> 01:09:52,880
using sapi at the moment so it needs

01:09:49,920 --> 01:09:54,640
really the seop standard to start

01:09:52,880 --> 01:09:57,199
working on standardizing how you

01:09:54,640 --> 01:09:59,760
describe this sort of hardware

01:09:57,199 --> 01:10:01,120
and that why it was i was why i was

01:09:59,760 --> 01:10:03,520
interested in what

01:10:01,120 --> 01:10:05,440
rupa dun said about earlier and whether

01:10:03,520 --> 01:10:09,199
that actually had any traction

01:10:05,440 --> 01:10:12,000
with linux maintainers and uaf itself

01:10:09,199 --> 01:10:13,440
that's good to know this history is good

01:10:12,000 --> 01:10:15,679
i didn't know how much

01:10:13,440 --> 01:10:16,960
acpi was used on the networking side

01:10:15,679 --> 01:10:20,080
from the hosts

01:10:16,960 --> 01:10:22,719
so my knowledge about the history or

01:10:20,080 --> 01:10:23,520
is a bit trusted but what we did was we

01:10:22,719 --> 01:10:25,760
did try to go

01:10:23,520 --> 01:10:26,560
through ocp and the patches were

01:10:25,760 --> 01:10:29,199
discussed i

01:10:26,560 --> 01:10:31,280
do have pointers to these patches that's

01:10:29,199 --> 01:10:34,159
i'll share with you and then we'll see

01:10:31,280 --> 01:10:35,760
but exactly what you're talking about l1

01:10:34,159 --> 01:10:37,679
sfp

01:10:35,760 --> 01:10:39,120
describing it in acpi and having the

01:10:37,679 --> 01:10:41,760
driver just

01:10:39,120 --> 01:10:43,840
use the acpi subsystem to actually get

01:10:41,760 --> 01:10:47,280
all that information was

01:10:43,840 --> 01:10:49,679
really cleaner instead of the sisfest

01:10:47,280 --> 01:10:51,520
eprom strap

01:10:49,679 --> 01:10:54,080
yeah and device 3 has had this for a

01:10:51,520 --> 01:10:57,600
long time so i'm always recommending

01:10:54,080 --> 01:11:00,080
if you've got an advanced configuration

01:10:57,600 --> 01:11:03,760
management interface use device tree

01:11:00,080 --> 01:11:06,560
if you've got something simple use acpi

01:11:03,760 --> 01:11:08,239
yeah but that tends to go against the

01:11:06,560 --> 01:11:09,520
vendors who are all trying to push

01:11:08,239 --> 01:11:12,400
towards

01:11:09,520 --> 01:11:13,600
um servers and they want a cpi and they

01:11:12,400 --> 01:11:16,640
don't like being told

01:11:13,600 --> 01:11:19,840
don't use atpi use device tree

01:11:16,640 --> 01:11:19,840
but that's the way it is at the moment

01:11:20,800 --> 01:11:24,840
i've also seen growing interest in ptp

01:11:23,600 --> 01:11:27,280
on macsec

01:11:24,840 --> 01:11:31,920
offload so there's a number of phi

01:11:27,280 --> 01:11:34,400
drivers and mac drivers doing that now

01:11:31,920 --> 01:11:36,400
which is interesting i don't really know

01:11:34,400 --> 01:11:38,640
what segment of the industry wants that

01:11:36,400 --> 01:11:42,239
i'm guessing it's

01:11:38,640 --> 01:11:44,640
industrial ethernet but i don't know

01:11:42,239 --> 01:11:47,199
you will see more of this in the context

01:11:44,640 --> 01:11:49,600
of i think mlx sw and the switch a6 also

01:11:47,199 --> 01:11:52,320
maxic is becoming really

01:11:49,600 --> 01:11:53,040
really important for uh because most of

01:11:52,320 --> 01:11:56,320
the switch

01:11:53,040 --> 01:11:57,760
asics they do support it and there's a

01:11:56,320 --> 01:11:59,360
current

01:11:57,760 --> 01:12:01,280
we were wondering for cumulus linux

01:11:59,360 --> 01:12:04,320
whether we should just use the

01:12:01,280 --> 01:12:04,960
maxsec current recent updates to offload

01:12:04,320 --> 01:12:08,640
and the

01:12:04,960 --> 01:12:10,960
maxic driver yeah and

01:12:08,640 --> 01:12:12,239
many phi support this as well again it's

01:12:10,960 --> 01:12:13,440
something that's been there in the

01:12:12,239 --> 01:12:16,719
silicon

01:12:13,440 --> 01:12:18,239
for a long time just nobody uses it

01:12:16,719 --> 01:12:22,400
so i expect that's going to change with

01:12:18,239 --> 01:12:24,320
time as well yep

01:12:22,400 --> 01:12:26,080
and there's probably advantages of doing

01:12:24,320 --> 01:12:28,000
it the fine in terms of

01:12:26,080 --> 01:12:30,239
it's totally transparent there's low

01:12:28,000 --> 01:12:31,679
latency

01:12:30,239 --> 01:12:32,960
where if you've got your mac involved

01:12:31,679 --> 01:12:34,840
and it's having to offload it to some

01:12:32,960 --> 01:12:37,120
hardware et cetera et cetera it's not so

01:12:34,840 --> 01:12:39,840
nice

01:12:37,120 --> 01:12:41,280
anyway did you review the uh maksec

01:12:39,840 --> 01:12:44,960
offload patches as well

01:12:41,280 --> 01:12:44,960
are you in the loop with double

01:12:45,199 --> 01:12:49,440
i took a quick look at them i talked to

01:12:47,600 --> 01:12:50,800
the guy in plumber's conference last

01:12:49,440 --> 01:12:53,760
year

01:12:50,800 --> 01:12:55,520
but i didn't really get that involved

01:12:53,760 --> 01:12:56,239
apart from just making sure the locking

01:12:55,520 --> 01:12:59,760
was correct

01:12:56,239 --> 01:13:01,360
with the filer which sometimes gets

01:12:59,760 --> 01:13:04,159
people

01:13:01,360 --> 01:13:05,760
so here's an example of what you can do

01:13:04,159 --> 01:13:08,239
with the cable testing

01:13:05,760 --> 01:13:09,280
on the marvels you can get at the raw

01:13:08,239 --> 01:13:11,440
tdr data

01:13:09,280 --> 01:13:13,040
and you can get interesting graphs like

01:13:11,440 --> 01:13:16,080
this

01:13:13,040 --> 01:13:18,320
in this case the red pair you'll see

01:13:16,080 --> 01:13:19,120
the pulse is negative meaning it was

01:13:18,320 --> 01:13:21,520
shorted

01:13:19,120 --> 01:13:22,640
whereas the other ones is a positive

01:13:21,520 --> 01:13:25,760
pulse which means

01:13:22,640 --> 01:13:27,520
it's open circuit so i just took a 15

01:13:25,760 --> 01:13:29,679
meter cable and i shorted

01:13:27,520 --> 01:13:32,159
a pair across and there's nothing

01:13:29,679 --> 01:13:34,880
plugged into the other end

01:13:32,159 --> 01:13:35,280
this tool is probably going to be open

01:13:34,880 --> 01:13:39,280
so

01:13:35,280 --> 01:13:39,280
soon i don't think it's yet available

01:13:39,679 --> 01:13:42,719
and you actually made a comment at the

01:13:41,840 --> 01:13:45,360
beginning

01:13:42,719 --> 01:13:47,600
about it would be nice to make use of

01:13:45,360 --> 01:13:50,480
this cable testing in switches

01:13:47,600 --> 01:13:52,719
it is using switches because marvel

01:13:50,480 --> 01:13:55,360
switches use marvel vise

01:13:52,719 --> 01:13:57,360
and all this just works so i actually

01:13:55,360 --> 01:14:01,840
did most of my development work

01:13:57,360 --> 01:14:01,840
on a marvel find a marvel switch

01:14:02,480 --> 01:14:06,560
what you'll have problems is if you're

01:14:04,560 --> 01:14:10,320
not using

01:14:06,560 --> 01:14:12,800
uh file link and fidef because

01:14:10,320 --> 01:14:14,159
this is all in the lower layers if you

01:14:12,800 --> 01:14:16,080
if you've got everything in firmware

01:14:14,159 --> 01:14:17,199
yet you'll need to add a bit more glue

01:14:16,080 --> 01:14:19,679
in to

01:14:17,199 --> 01:14:20,719
allow the mac to access all this but

01:14:19,679 --> 01:14:23,600
it's just glue

01:14:20,719 --> 01:14:23,600
it shouldn't be an issue

01:14:25,199 --> 01:14:30,480
and then next slide please and then just

01:14:28,719 --> 01:14:34,320
looking forward what do i think's going

01:14:30,480 --> 01:14:36,239
to come soon with my crystal ball

01:14:34,320 --> 01:14:38,159
connecting the mac and the fire is

01:14:36,239 --> 01:14:40,320
getting more and more complex there's

01:14:38,159 --> 01:14:42,880
these cedars getting in the way there's

01:14:40,320 --> 01:14:45,600
all the link training etc etc

01:14:42,880 --> 01:14:47,280
and various system-on-chip vendors are

01:14:45,600 --> 01:14:51,280
starting to expose this

01:14:47,280 --> 01:14:51,280
rather than hide it away in firmware

01:14:52,320 --> 01:14:56,000
particularly nxp so i see there's going

01:14:55,360 --> 01:14:58,640
to be work

01:14:56,000 --> 01:15:00,640
on the pcs layer getting some of that

01:14:58,640 --> 01:15:01,760
some of it is nicely standardized so

01:15:00,640 --> 01:15:03,840
hopefully we can get some

01:15:01,760 --> 01:15:06,719
re-implementation some reuse of some of

01:15:03,840 --> 01:15:06,719
this driver work

01:15:06,960 --> 01:15:12,719
leds has been an issue for a long time

01:15:10,239 --> 01:15:15,199
how do you get the file it is blinking

01:15:12,719 --> 01:15:17,840
to show what you want them

01:15:15,199 --> 01:15:19,120
in the dt world there's three different

01:15:17,840 --> 01:15:20,800
ways of doing it

01:15:19,120 --> 01:15:22,719
it's not so nice if you're not using

01:15:20,800 --> 01:15:23,600
device tree there's no way to configure

01:15:22,719 --> 01:15:26,480
it

01:15:23,600 --> 01:15:27,199
so at last somebody stepped up to do

01:15:26,480 --> 01:15:30,239
some

01:15:27,199 --> 01:15:33,520
generic work on this where the phy

01:15:30,239 --> 01:15:34,400
leds just become standard linux leds you

01:15:33,520 --> 01:15:38,159
control them

01:15:34,400 --> 01:15:39,840
as normal linux leds and you can blink

01:15:38,159 --> 01:15:42,880
them on the heartbeat pattern you can

01:15:39,840 --> 01:15:46,000
make it sure link up and link down

01:15:42,880 --> 01:15:49,760
whatever you want using standard

01:15:46,000 --> 01:15:51,520
linux leds which is great i'm using e3

01:15:49,760 --> 01:15:54,719
i'm assuming right

01:15:51,520 --> 01:15:58,400
no no there's an ether

01:15:54,719 --> 01:16:01,280
identify at the moment that's missing

01:15:58,400 --> 01:16:03,120
at the moment standard linux leds goes

01:16:01,280 --> 01:16:05,600
via the csfs this class

01:16:03,120 --> 01:16:06,239
leds and then there's a direct report

01:16:05,600 --> 01:16:08,000
led

01:16:06,239 --> 01:16:11,360
and then you can set its brightness you

01:16:08,000 --> 01:16:14,719
can set its trigger and things like that

01:16:11,360 --> 01:16:17,120
it could be we link these two in because

01:16:14,719 --> 01:16:20,080
of the naming issues

01:16:17,120 --> 01:16:21,679
fines have pretty horrible names and

01:16:20,080 --> 01:16:26,239
it's hard to link that back

01:16:21,679 --> 01:16:28,880
to each one or emp2 s0 or whatever

01:16:26,239 --> 01:16:30,159
so it could be we put some code into

01:16:28,880 --> 01:16:32,800
each tool

01:16:30,159 --> 01:16:33,440
just to make it easier to use but the

01:16:32,800 --> 01:16:38,239
real

01:16:33,440 --> 01:16:38,239
kernel api will be via this class leds

01:16:38,800 --> 01:16:42,400
okay yeah i think that i think that what

01:16:40,560 --> 01:16:44,320
rupa mentioned is that

01:16:42,400 --> 01:16:46,719
the the the indication that which is

01:16:44,320 --> 01:16:49,199
supported in eth2 i think it's uh

01:16:46,719 --> 01:16:50,640
it's it's a different story that's a

01:16:49,199 --> 01:16:52,320
different story and that's something

01:16:50,640 --> 01:16:55,600
which

01:16:52,320 --> 01:16:57,600
we should be able to implement a generic

01:16:55,600 --> 01:17:01,679
way of doing that

01:16:57,600 --> 01:17:05,840
which any file which implements phi leds

01:17:01,679 --> 01:17:08,159
we can just make it blink but setting it

01:17:05,840 --> 01:17:10,960
for other uses is going to go via cis

01:17:08,159 --> 01:17:10,960
class leds

01:17:11,679 --> 01:17:16,080
and then my last gazing into a glass

01:17:15,440 --> 01:17:18,960
bowl

01:17:16,080 --> 01:17:19,520
acpi i don't think it really is dead i

01:17:18,960 --> 01:17:21,760
think

01:17:19,520 --> 01:17:23,679
if the vendors get together and do the

01:17:21,760 --> 01:17:25,760
work it could still come back

01:17:23,679 --> 01:17:28,640
it could be a phoenix that raises from

01:17:25,760 --> 01:17:28,640
the burnt ashes

01:17:29,360 --> 01:17:32,640
yeah the vendors are the key

01:17:32,960 --> 01:17:36,960
the vendors and going to ufa

01:17:40,400 --> 01:17:45,840
it certainly won't be driven by the fine

01:17:42,840 --> 01:17:45,840
maintainers

01:17:48,480 --> 01:17:53,440
cool any questions any questions

01:17:53,840 --> 01:17:58,560
uh yeah i have a small question

01:17:56,880 --> 01:18:02,159
can you please elaborate a little bit

01:17:58,560 --> 01:18:04,080
about power over internet support

01:18:02,159 --> 01:18:06,159
same problem as everybody else nobody

01:18:04,080 --> 01:18:09,600
does it there's no

01:18:06,159 --> 01:18:10,960
kernel support either it's

01:18:09,600 --> 01:18:12,640
it's something that would actually be

01:18:10,960 --> 01:18:15,600
interesting to put into

01:18:12,640 --> 01:18:17,440
the fine layer or it's maybe not the

01:18:15,600 --> 01:18:20,880
file layer it's a new subsystem

01:18:17,440 --> 01:18:23,360
as a whole because it also probably

01:18:20,880 --> 01:18:25,199
needs to link into the power

01:18:23,360 --> 01:18:26,560
management code because if you're

01:18:25,199 --> 01:18:28,400
pulling too much power out and the

01:18:26,560 --> 01:18:32,000
device is getting too hot

01:18:28,400 --> 01:18:36,239
you might need to turn off the power

01:18:32,000 --> 01:18:36,239
yeah there's a control needed

01:18:36,960 --> 01:18:40,000
but i'm not anywhere i'm not aware of

01:18:38,800 --> 01:18:43,760
anybody doing any

01:18:40,000 --> 01:18:46,320
open work on this in the kernel

01:18:43,760 --> 01:18:49,679
yeah i've not seen it either i was

01:18:46,320 --> 01:18:52,159
looking for it the other day also

01:18:49,679 --> 01:18:54,480
but that's would be something i think

01:18:52,159 --> 01:18:56,960
microsemi also has these

01:18:54,480 --> 01:18:58,400
poe controllers right there's a few

01:18:56,960 --> 01:19:00,159
different vendors in the networking

01:18:58,400 --> 01:19:03,520
space so micro semi

01:19:00,159 --> 01:19:04,239
maximum and a few others but they all

01:19:03,520 --> 01:19:08,640
tend to be

01:19:04,239 --> 01:19:10,880
sdks and there's no standardization

01:19:08,640 --> 01:19:10,880
yep

01:19:12,719 --> 01:19:16,560
any other questions so jamal is raising

01:19:15,600 --> 01:19:19,199
hands

01:19:16,560 --> 01:19:19,199
you have a question

01:19:20,080 --> 01:19:25,600
no i forgot to lower my hand before

01:19:23,679 --> 01:19:26,719
sorry thank you for the question there

01:19:25,600 --> 01:19:30,159
is christian

01:19:26,719 --> 01:19:33,199
is another one christian yeah um

01:19:30,159 --> 01:19:34,640
hi i this is sort of a maybe a naive

01:19:33,199 --> 01:19:36,320
question but

01:19:34,640 --> 01:19:38,880
we were building a project with these

01:19:36,320 --> 01:19:42,080
macchiato bins which are marvel based

01:19:38,880 --> 01:19:43,760
and we had uh we they wouldn't work uh

01:19:42,080 --> 01:19:45,280
and we actually gave up on the devices

01:19:43,760 --> 01:19:46,159
because we couldn't get them to work

01:19:45,280 --> 01:19:49,199
back to back

01:19:46,159 --> 01:19:51,040
like so if we plug them back to back um

01:19:49,199 --> 01:19:52,880
you know and it's and so we but we

01:19:51,040 --> 01:19:54,400
puzzled to ourselves was this because

01:19:52,880 --> 01:19:56,159
like they were overpowered you know

01:19:54,400 --> 01:19:58,239
there was no way to adjust

01:19:56,159 --> 01:20:00,239
you know the sfp power and stuff so i'm

01:19:58,239 --> 01:20:00,880
wondering if what you're talking about

01:20:00,239 --> 01:20:03,280
here is

01:20:00,880 --> 01:20:05,199
is this about getting access to

01:20:03,280 --> 01:20:06,960
diagnostics on the sfp

01:20:05,199 --> 01:20:08,800
like so that we could have like gone in

01:20:06,960 --> 01:20:10,080
and looked and seen you know is there

01:20:08,800 --> 01:20:12,480
too much laser power

01:20:10,080 --> 01:20:15,199
going or you know that's been there for

01:20:12,480 --> 01:20:18,960
a long time if you used hwmon

01:20:15,199 --> 01:20:20,880
we export what the sfp module is

01:20:18,960 --> 01:20:24,159
reporting in terms of

01:20:20,880 --> 01:20:24,880
its laser power its transmit power its

01:20:24,159 --> 01:20:28,560
voltage

01:20:24,880 --> 01:20:30,840
its temperature it's all ins in exported

01:20:28,560 --> 01:20:34,239
in the standard linux way

01:20:30,840 --> 01:20:37,360
um if if

01:20:34,239 --> 01:20:40,960
russell king knows more about this

01:20:37,360 --> 01:20:42,320
specific hardware suddenly i've had no

01:20:40,960 --> 01:20:46,239
issues

01:20:42,320 --> 01:20:48,480
with one meter fibre links

01:20:46,239 --> 01:20:49,360
you don't need a 10 kilometer fibre link

01:20:48,480 --> 01:20:51,120
um

01:20:49,360 --> 01:20:52,480
no i mean it worked when we plugged them

01:20:51,120 --> 01:20:54,080
into intel nicks

01:20:52,480 --> 01:20:55,679
and when we plugged them into switches

01:20:54,080 --> 01:20:56,719
just not back to back they wouldn't talk

01:20:55,679 --> 01:21:00,000
to each other which was

01:20:56,719 --> 01:21:02,080
bizarre but yeah

01:21:00,000 --> 01:21:03,120
i did i did try twisting the fiber too

01:21:02,080 --> 01:21:08,880
like you know just

01:21:03,120 --> 01:21:10,719
introducing uh you know around a pencil

01:21:08,880 --> 01:21:12,719
so i don't know what it was but okay so

01:21:10,719 --> 01:21:16,639
it's already there that whatever this in

01:21:12,719 --> 01:21:19,280
given sfp is giving out is already in hw

01:21:16,639 --> 01:21:20,159
thank you yeah the issue could be the

01:21:19,280 --> 01:21:23,440
sfp

01:21:20,159 --> 01:21:26,800
in terms of sfp vendors are

01:21:23,440 --> 01:21:30,159
terrible at following standards

01:21:26,800 --> 01:21:31,920
and if they don't implement it correctly

01:21:30,159 --> 01:21:34,000
which most of them don't you don't get

01:21:31,920 --> 01:21:35,760
the information exported or they put it

01:21:34,000 --> 01:21:37,440
in the wrong place or they get the

01:21:35,760 --> 01:21:40,400
checksums wrong or

01:21:37,440 --> 01:21:42,320
et cetera et cetera et cetera right so

01:21:40,400 --> 01:21:46,480
we've had lots of issues with

01:21:42,320 --> 01:21:49,040
sfps which simply don't work properly

01:21:46,480 --> 01:21:51,360
okay it's worth spending a bit more

01:21:49,040 --> 01:21:56,320
money in getting a good quality one

01:21:51,360 --> 01:21:58,560
right thanks okay

01:21:56,320 --> 01:21:59,760
i think that we are out of time aren't

01:21:58,560 --> 01:22:02,080
we yeah

01:21:59,760 --> 01:22:03,280
yeah jamal do we have time or i think

01:22:02,080 --> 01:22:06,239
we're out of time

01:22:03,280 --> 01:22:06,239
it's 11 15.

01:22:07,520 --> 01:22:12,080
jamal when is the next session starting

01:22:10,960 --> 01:22:12,400
so i was wondering whether we should

01:22:12,080 --> 01:22:15,360
give

01:22:12,400 --> 01:22:15,920
uh in in five minutes in five minutes

01:22:15,360 --> 01:22:17,040
and it's

01:22:15,920 --> 01:22:18,639
you basically you can either take a

01:22:17,040 --> 01:22:20,639
break or just wait here if you're

01:22:18,639 --> 01:22:22,239
waiting for dave's uh

01:22:20,639 --> 01:22:23,840
david our hands session which is

01:22:22,239 --> 01:22:27,920
starting soon

01:22:23,840 --> 01:22:31,600
excuse me but uh

01:22:27,920 --> 01:22:36,800
can i have questions yes yes please yes

01:22:31,600 --> 01:22:36,800
sorry so can i ask questions about sfp

01:22:37,040 --> 01:22:44,239
sure so yeah

01:22:40,719 --> 01:22:47,520
so um the kernels

01:22:44,239 --> 01:22:50,719
sfp states are attracted by gpio

01:22:47,520 --> 01:22:54,360
pins right but uh what

01:22:50,719 --> 01:22:58,239
if we have um a lot of saps

01:22:54,360 --> 01:23:01,600
connected not to the soc pins

01:22:58,239 --> 01:23:04,880
but through the for example cpa pld

01:23:01,600 --> 01:23:08,080
which sits on the i2c

01:23:04,880 --> 01:23:11,679
bus of course we can

01:23:08,080 --> 01:23:14,960
write a driver and implement the gpio

01:23:11,679 --> 01:23:19,280
controller and make this

01:23:14,960 --> 01:23:22,960
wrapping but it will be

01:23:19,280 --> 01:23:26,159
maybe some improvement to have some

01:23:22,960 --> 01:23:29,840
organic possibility to

01:23:26,159 --> 01:23:33,040
register ring like

01:23:29,840 --> 01:23:36,159
driver to handle this states

01:23:33,040 --> 01:23:36,159
of models

01:23:38,080 --> 01:23:42,880
um i would personally just write a gpio

01:23:42,080 --> 01:23:46,239
driver

01:23:42,880 --> 01:23:47,280
for your cpld you

01:23:46,239 --> 01:23:49,440
if you want to go the different

01:23:47,280 --> 01:23:50,639
direction submit patches and see what

01:23:49,440 --> 01:23:54,080
russell king says

01:23:50,639 --> 01:23:56,800
okay thank you okay so

01:23:54,080 --> 01:23:57,199
um i we might have two three minutes i

01:23:56,800 --> 01:24:00,840
think

01:23:57,199 --> 01:24:05,760
so i know edo had some other slides

01:24:00,840 --> 01:24:08,080
on more features that he

01:24:05,760 --> 01:24:09,840
recently added features okay so we

01:24:08,080 --> 01:24:13,600
recently added the

01:24:09,840 --> 01:24:14,840
extended link state to eth2 this is work

01:24:13,600 --> 01:24:18,400
done by anything

01:24:14,840 --> 01:24:22,239
peter we usually get

01:24:18,400 --> 01:24:25,440
bulky bolts about uh cables not working

01:24:22,239 --> 01:24:29,840
coming up so the idea is to

01:24:25,440 --> 01:24:31,840
expose two new attributes via the new

01:24:29,840 --> 01:24:35,360
ethnic eth tool backend

01:24:31,840 --> 01:24:37,280
the user space one is the extended state

01:24:35,360 --> 01:24:42,080
and the second one is the extended

01:24:37,280 --> 01:24:44,719
sub state so you can

01:24:42,080 --> 01:24:46,320
get for example like no cable is

01:24:44,719 --> 01:24:48,320
connected this way this is why the link

01:24:46,320 --> 01:24:50,480
is not coming up

01:24:48,320 --> 01:24:51,360
uh and there are a bunch of other

01:24:50,480 --> 01:24:53,520
reasons

01:24:51,360 --> 01:24:55,120
uh all documented in cameron so they

01:24:53,520 --> 01:24:59,760
should

01:24:55,120 --> 01:25:02,639
reflect most of the states um recently

01:24:59,760 --> 01:25:02,960
mentioned the the portal down reason

01:25:02,639 --> 01:25:07,040
that

01:25:02,960 --> 01:25:08,960
can be added later on and

01:25:07,040 --> 01:25:10,960
adding support in device drivers is

01:25:08,960 --> 01:25:13,440
relatively simple

01:25:10,960 --> 01:25:15,199
you just need to implement a new eth

01:25:13,440 --> 01:25:18,880
tool up

01:25:15,199 --> 01:25:18,880
and that's it

01:25:20,000 --> 01:25:24,960
and thanks andrew for reviewing the

01:25:22,639 --> 01:25:27,199
patches

01:25:24,960 --> 01:25:28,320
okay so the second topic is uh kyodisk

01:25:27,199 --> 01:25:31,360
event added by

01:25:28,320 --> 01:25:34,239
um peter instantly

01:25:31,360 --> 01:25:35,440
so as you know in tc you can match on

01:25:34,239 --> 01:25:39,199
certain pocket

01:25:35,440 --> 01:25:42,239
pockets using the classifier some action

01:25:39,199 --> 01:25:44,159
but if you i mean you touch the

01:25:42,239 --> 01:25:46,000
classifiers to key disks but

01:25:44,159 --> 01:25:47,520
if you think about it the qrisks

01:25:46,000 --> 01:25:50,159
themselves also do

01:25:47,520 --> 01:25:51,199
classification for example the red q

01:25:50,159 --> 01:25:54,000
risks

01:25:51,199 --> 01:25:55,040
uh decides to early drop the pocket of

01:25:54,000 --> 01:25:59,280
market and

01:25:55,040 --> 01:26:02,719
fifoculist decides to take off a pocket

01:25:59,280 --> 01:26:06,080
and we wanted to be able to mirror

01:26:02,719 --> 01:26:07,600
such packets either to the local cpu or

01:26:06,080 --> 01:26:10,320
to a different station

01:26:07,600 --> 01:26:11,040
so that our users will have visibility

01:26:10,320 --> 01:26:14,400
into these

01:26:11,040 --> 01:26:15,600
buffer groups so better will do it even

01:26:14,400 --> 01:26:18,800
more generically

01:26:15,600 --> 01:26:23,199
and you can basically run

01:26:18,800 --> 01:26:26,639
whatever tc filters on these um

01:26:23,199 --> 01:26:29,040
dropped pockets or acn market markets

01:26:26,639 --> 01:26:30,400
in our case we just yeah sorry i think

01:26:29,040 --> 01:26:32,080
we're over

01:26:30,400 --> 01:26:34,239
over now and i think we'll probably be

01:26:32,080 --> 01:26:37,760
getting uh the other

01:26:34,239 --> 01:26:40,320
david's audience okay good luck

01:26:37,760 --> 01:26:42,239
people wanting to learn about xtp or

01:26:40,320 --> 01:26:43,679
seeing extended state stuff and q desk

01:26:42,239 --> 01:26:45,679
events

01:26:43,679 --> 01:26:47,120
okay i would like to thanks every thanks

01:26:45,679 --> 01:26:49,120
everybody thanks edward

01:26:47,120 --> 01:26:56,719
thanks andrew for presenting thanks siri

01:26:49,120 --> 01:26:56,719

YouTube URL: https://www.youtube.com/watch?v=NAVNxbC2Kcc


