Title: Netdev 0x14 - Implementation of IPv6 IOAM in Linux Kernel
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Justin Iurman, Benoit Donnet, Frank Brockners

More info: https://netdevconf.info/0x14/session.html?talk-implementation-of-IPv6-IOAM-in-linux-kernel

Date: Thursday, August 20, 2020

Operations, Administration, and Maintenance (OAM)
refers to a set of techniques and mechanisms for performing
fault detection, isolation and performance measurements.
Classical approaches such are traceroute, ping, etc can now be
improved by collecting more granular and precise per-packet telemetry.
The IETF is currently in the process of standardizing In-situ OAM (IOAM)
to allow collecting operational information along a path.

In this talk Justin Iurman discusses an implementation of IOAM
for the Linux kernel with IPv6 as the encapsulation protocol.
They will discuss the details of their approach and demonstrate
evaluation results.
Captions: 
	00:00:01,839 --> 00:00:07,040
hi everyone this is justine

00:00:04,160 --> 00:00:07,680
from the university of liege and thank

00:00:07,040 --> 00:00:10,880
you for

00:00:07,680 --> 00:00:11,599
attending this presentation on iom and

00:00:10,880 --> 00:00:14,160
on its

00:00:11,599 --> 00:00:17,600
implementation with ipv6 as an

00:00:14,160 --> 00:00:19,119
encapsulation protocol

00:00:17,600 --> 00:00:21,039
if you don't know about iom don't be

00:00:19,119 --> 00:00:23,199
afraid and please don't go

00:00:21,039 --> 00:00:25,840
because i'm going to introduce you to it

00:00:23,199 --> 00:00:25,840
just right now

00:00:26,160 --> 00:00:31,359
so what is iom i hope you're still there

00:00:28,880 --> 00:00:34,480
and you didn't leave

00:00:31,359 --> 00:00:36,559
so iom means in situ operations

00:00:34,480 --> 00:00:39,680
administration and maintenance

00:00:36,559 --> 00:00:42,960
so basically this is just an ncu oam

00:00:39,680 --> 00:00:44,879
technique and the term insidu here

00:00:42,960 --> 00:00:47,680
refers to the fact that data are

00:00:44,879 --> 00:00:50,960
recorded within packets

00:00:47,680 --> 00:00:51,760
so data are part of headers not part of

00:00:50,960 --> 00:00:54,480
the payload

00:00:51,760 --> 00:00:55,039
all right and you can insert a lot of

00:00:54,480 --> 00:00:58,320
data

00:00:55,039 --> 00:01:02,079
such as node id the idea of the ingress

00:00:58,320 --> 00:01:05,119
or egress interface a timestamp

00:01:02,079 --> 00:01:08,479
transit delay queue length

00:01:05,119 --> 00:01:11,119
buffer occupancy and so on

00:01:08,479 --> 00:01:12,560
and you could consider iom as something

00:01:11,119 --> 00:01:15,200
hybrid because

00:01:12,560 --> 00:01:16,560
it can either be an active or a passive

00:01:15,200 --> 00:01:19,600
oem type

00:01:16,560 --> 00:01:22,560
which means that actually you could just

00:01:19,600 --> 00:01:23,360
generate dedicated traffic for iam or

00:01:22,560 --> 00:01:27,840
you could choose to

00:01:23,360 --> 00:01:29,960
inject an iom inside in flight traffic

00:01:27,840 --> 00:01:31,200
and currently iom is under

00:01:29,960 --> 00:01:34,320
standardization

00:01:31,200 --> 00:01:37,280
in the ietf and more specifically

00:01:34,320 --> 00:01:39,119
in the ippm working group where i am

00:01:37,280 --> 00:01:42,000
involved

00:01:39,119 --> 00:01:43,200
and there are a lot of drafts uh related

00:01:42,000 --> 00:01:45,520
to iom

00:01:43,200 --> 00:01:48,000
uh so for instance the first bullet on

00:01:45,520 --> 00:01:51,360
the slide you have the iom data draft

00:01:48,000 --> 00:01:54,880
which is a more important one

00:01:51,360 --> 00:01:57,280
and this drive defines actually

00:01:54,880 --> 00:01:59,280
every kind of data that can be inserted

00:01:57,280 --> 00:02:03,119
and also iom namespaces

00:01:59,280 --> 00:02:06,880
i will talk about it later you have also

00:02:03,119 --> 00:02:06,880
a draft on irm flags

00:02:07,439 --> 00:02:11,039
that right now we have uh up to three

00:02:10,000 --> 00:02:13,200
flights

00:02:11,039 --> 00:02:14,239
i won't go too much into details but

00:02:13,200 --> 00:02:18,000
there are

00:02:14,239 --> 00:02:21,360
uh the loop back flag sorry

00:02:18,000 --> 00:02:23,040
the active flag and uh i don't even

00:02:21,360 --> 00:02:25,520
remember the third one

00:02:23,040 --> 00:02:26,160
well that's not important and you have

00:02:25,520 --> 00:02:29,280
also

00:02:26,160 --> 00:02:32,000
a lot more drive drafts uh one

00:02:29,280 --> 00:02:34,239
for each encapsulation protocol so

00:02:32,000 --> 00:02:37,280
obviously in this talk we will focus on

00:02:34,239 --> 00:02:40,560
the ipv6 protocol

00:02:37,280 --> 00:02:43,440
you have also um yang

00:02:40,560 --> 00:02:44,080
a young draft so for configuration

00:02:43,440 --> 00:02:46,000
purpose

00:02:44,080 --> 00:02:49,200
you have some profiles that are also

00:02:46,000 --> 00:02:52,319
defined in a flag in a draft

00:02:49,200 --> 00:02:54,239
and so on and so on so

00:02:52,319 --> 00:02:55,680
one thing important to notice is that

00:02:54,239 --> 00:02:58,720
the iem data is

00:02:55,680 --> 00:02:59,920
actually uh going through its uh second

00:02:58,720 --> 00:03:02,959
working group last call

00:02:59,920 --> 00:03:04,640
so it's really mature and

00:03:02,959 --> 00:03:07,200
hopefully it's gonna be soon

00:03:04,640 --> 00:03:08,959
standardized

00:03:07,200 --> 00:03:11,040
so now that you have a big picture of

00:03:08,959 --> 00:03:14,560
iom let's focus on

00:03:11,040 --> 00:03:17,120
ipv6 as the encapsulation protocol

00:03:14,560 --> 00:03:20,560
and as i said there is a specific draft

00:03:17,120 --> 00:03:23,440
for that which is the iom ipv6 options

00:03:20,560 --> 00:03:25,760
and basically this draft defines two new

00:03:23,440 --> 00:03:28,959
tlvs

00:03:25,760 --> 00:03:32,879
one for a by op extension header and

00:03:28,959 --> 00:03:35,440
one for destination extension header

00:03:32,879 --> 00:03:36,640
those two new values have already been

00:03:35,440 --> 00:03:38,560
allocated

00:03:36,640 --> 00:03:40,799
by ins so you can find them on their

00:03:38,560 --> 00:03:42,959
website or inside the patch

00:03:40,799 --> 00:03:45,599
i have submitted so you can see that in

00:03:42,959 --> 00:03:49,120
a few slides

00:03:45,599 --> 00:03:52,799
iom options requirements uh

00:03:49,120 --> 00:03:55,360
are an alignment of 4n so that

00:03:52,799 --> 00:03:57,120
each iom data is aligned on its natural

00:03:55,360 --> 00:04:00,000
boundary

00:03:57,120 --> 00:04:01,200
there exists four different iam option

00:04:00,000 --> 00:04:04,640
types

00:04:01,200 --> 00:04:07,280
the two first ones are pre-allocated

00:04:04,640 --> 00:04:10,000
trace and the incremental trace

00:04:07,280 --> 00:04:11,920
they are similar the only difference is

00:04:10,000 --> 00:04:14,239
that obviously in pre-allocated trace

00:04:11,920 --> 00:04:15,360
the first note will just pre-locate all

00:04:14,239 --> 00:04:18,400
the space

00:04:15,360 --> 00:04:20,799
for each node on the path and

00:04:18,400 --> 00:04:22,160
as for the incremental trace each node

00:04:20,799 --> 00:04:25,360
is responsible for

00:04:22,160 --> 00:04:27,440
its own allocation and it's to insert

00:04:25,360 --> 00:04:29,360
its data

00:04:27,440 --> 00:04:31,360
the third one is the proof of transit

00:04:29,360 --> 00:04:31,680
option right so basically you will use

00:04:31,360 --> 00:04:33,680
it

00:04:31,680 --> 00:04:35,040
if you want to make sure that you have

00:04:33,680 --> 00:04:38,320
followed

00:04:35,040 --> 00:04:41,040
a specific pass and each node was

00:04:38,320 --> 00:04:42,000
intended to to be there and the last one

00:04:41,040 --> 00:04:44,800
which is more for

00:04:42,000 --> 00:04:45,280
a destination extension error is the h2h

00:04:44,800 --> 00:04:47,919
so

00:04:45,280 --> 00:04:48,479
this is a scenario where you want to

00:04:47,919 --> 00:04:50,479
have

00:04:48,479 --> 00:04:53,680
an exchange of iom data between the

00:04:50,479 --> 00:04:55,840
source and the destination only

00:04:53,680 --> 00:04:56,800
so why is it pre-allocated trace

00:04:55,840 --> 00:05:00,080
involved because

00:04:56,800 --> 00:05:01,280
we will focus only on this option here

00:05:00,080 --> 00:05:02,960
because

00:05:01,280 --> 00:05:04,639
obviously this is the only one that was

00:05:02,960 --> 00:05:06,800
implemented in the patch

00:05:04,639 --> 00:05:08,000
for many reasons i want to expand on

00:05:06,800 --> 00:05:10,160
that

00:05:08,000 --> 00:05:12,639
so on the right you have uh the

00:05:10,160 --> 00:05:14,639
structure of the packet

00:05:12,639 --> 00:05:16,800
so the first line we can skip it because

00:05:14,639 --> 00:05:19,840
it's basically the extension header

00:05:16,800 --> 00:05:22,320
header following with uh two

00:05:19,840 --> 00:05:23,520
octets of padding to align the arm

00:05:22,320 --> 00:05:27,759
option

00:05:23,520 --> 00:05:30,800
then you have the tl of the iom option

00:05:27,759 --> 00:05:31,680
iom type refers to the to the iom

00:05:30,800 --> 00:05:33,919
options i

00:05:31,680 --> 00:05:35,039
set it just before so in this case

00:05:33,919 --> 00:05:37,680
pre-allocated trace

00:05:35,039 --> 00:05:39,680
is zero so im type field should be zero

00:05:37,680 --> 00:05:42,000
here

00:05:39,680 --> 00:05:43,520
the two next lines are actually the

00:05:42,000 --> 00:05:47,600
pre-allocated trace

00:05:43,520 --> 00:05:50,160
header and here the namespace id is

00:05:47,600 --> 00:05:51,360
the iom namespace so it has nothing to

00:05:50,160 --> 00:05:54,320
do with

00:05:51,360 --> 00:05:55,680
what you know in linux like network

00:05:54,320 --> 00:05:59,039
namespace

00:05:55,680 --> 00:06:02,080
so here im namespaces uh are useful

00:05:59,039 --> 00:06:04,720
to bring some context to iom data

00:06:02,080 --> 00:06:05,199
and also it allows us to have multiple

00:06:04,720 --> 00:06:08,080
same

00:06:05,199 --> 00:06:08,880
options same iom options inside the same

00:06:08,080 --> 00:06:11,360
packet

00:06:08,880 --> 00:06:11,919
so you can see that as a unique id

00:06:11,360 --> 00:06:15,840
between

00:06:11,919 --> 00:06:17,280
the iom type and the namespace id

00:06:15,840 --> 00:06:19,120
following the namespace you have the

00:06:17,280 --> 00:06:23,280
nodeland and remain england

00:06:19,120 --> 00:06:25,759
so this is just two

00:06:23,280 --> 00:06:26,400
two values that allows the node to know

00:06:25,759 --> 00:06:30,400
the length

00:06:26,400 --> 00:06:33,440
of the data it has to insert and what

00:06:30,400 --> 00:06:34,160
what space is left the flags so i

00:06:33,440 --> 00:06:36,319
mentioned

00:06:34,160 --> 00:06:38,560
the flags that you have you have for

00:06:36,319 --> 00:06:42,160
instance the overflow flag

00:06:38,560 --> 00:06:45,919
which is uh used to notify

00:06:42,160 --> 00:06:48,000
uh next nodes uh if the flag is set

00:06:45,919 --> 00:06:49,840
to tell the nodes that you have no space

00:06:48,000 --> 00:06:52,240
to insert so you can skip it so it's

00:06:49,840 --> 00:06:52,240
faster

00:06:52,400 --> 00:06:55,599
the iom trace type is actually defined

00:06:54,720 --> 00:06:59,199
in the im

00:06:55,599 --> 00:07:00,800
data draft so it this is a bit filled so

00:06:59,199 --> 00:07:05,520
each bit corresponds to

00:07:00,800 --> 00:07:08,639
an iom data option defined in that draft

00:07:05,520 --> 00:07:12,080
so that the node knows

00:07:08,639 --> 00:07:15,280
what option it has to insert or not

00:07:12,080 --> 00:07:16,479
and then you have each block of data for

00:07:15,280 --> 00:07:19,520
each node

00:07:16,479 --> 00:07:22,000
so for instance this is inserted

00:07:19,520 --> 00:07:24,000
from bottom to left to to top sorry so

00:07:22,000 --> 00:07:26,720
this is just like a stack

00:07:24,000 --> 00:07:27,199
and for instance here after the rm trace

00:07:26,720 --> 00:07:29,919
type

00:07:27,199 --> 00:07:31,039
the first data node is the last one on

00:07:29,919 --> 00:07:33,280
the path

00:07:31,039 --> 00:07:34,240
and so on until the first node on the

00:07:33,280 --> 00:07:37,360
pass

00:07:34,240 --> 00:07:41,280
all right so let's review some

00:07:37,360 --> 00:07:43,680
interesting use cases for ipv6 and iom

00:07:41,280 --> 00:07:45,520
the first one is actually a fast failure

00:07:43,680 --> 00:07:47,199
detection and isolation

00:07:45,520 --> 00:07:48,800
so you're gonna tell me hey we have

00:07:47,199 --> 00:07:49,120
already traced it for that for instance

00:07:48,800 --> 00:07:52,000
but

00:07:49,120 --> 00:07:52,879
yeah trace route is slow and the big

00:07:52,000 --> 00:07:56,560
difference here

00:07:52,879 --> 00:07:58,400
is that we actually are making the same

00:07:56,560 --> 00:08:01,120
thing as tourist route but here we

00:07:58,400 --> 00:08:02,080
only need one packet so we send one

00:08:01,120 --> 00:08:04,080
packet

00:08:02,080 --> 00:08:05,599
and each node on the path will reply

00:08:04,080 --> 00:08:08,639
with one packet containing

00:08:05,599 --> 00:08:11,199
iom data so you are

00:08:08,639 --> 00:08:12,400
using n packets where traceroute would

00:08:11,199 --> 00:08:14,479
use two

00:08:12,400 --> 00:08:16,240
end packets so there is a big difference

00:08:14,479 --> 00:08:20,479
and you have only one packet and one

00:08:16,240 --> 00:08:23,120
run to a time to grab back the data

00:08:20,479 --> 00:08:25,360
the second one is a smart service

00:08:23,120 --> 00:08:27,280
selection and load balancing

00:08:25,360 --> 00:08:29,039
so you can see i'm sorry for the quality

00:08:27,280 --> 00:08:30,639
of this image but you can see

00:08:29,039 --> 00:08:34,159
somewhere in the middle there is

00:08:30,639 --> 00:08:37,519
something called anycast server

00:08:34,159 --> 00:08:41,200
and actually the client will just ask

00:08:37,519 --> 00:08:43,680
the server to contact a service

00:08:41,200 --> 00:08:44,880
and the server so the amenica server is

00:08:43,680 --> 00:08:47,360
responsible

00:08:44,880 --> 00:08:48,480
for choosing the best one at that moment

00:08:47,360 --> 00:08:52,399
so you can have

00:08:48,480 --> 00:08:55,519
a lot of criteria and to decide this

00:08:52,399 --> 00:08:58,880
it will use iom and it will contact

00:08:55,519 --> 00:09:01,760
every uh service that is

00:08:58,880 --> 00:09:03,839
available i forgot to mention that each

00:09:01,760 --> 00:09:06,720
service is a duplication of the order so

00:09:03,839 --> 00:09:09,839
that's why the load balancing right

00:09:06,720 --> 00:09:10,399
once the the server has chosen uh the

00:09:09,839 --> 00:09:12,800
best

00:09:10,399 --> 00:09:14,000
service at that moment it will combine

00:09:12,800 --> 00:09:17,519
iom with

00:09:14,000 --> 00:09:19,680
segment routing so that the client will

00:09:17,519 --> 00:09:21,600
steer the traffic to the service

00:09:19,680 --> 00:09:24,080
directly

00:09:21,600 --> 00:09:25,760
so the client will directly communicate

00:09:24,080 --> 00:09:27,680
with the service in that case

00:09:25,760 --> 00:09:30,320
and it corresponds to the best the best

00:09:27,680 --> 00:09:33,760
service for the client

00:09:30,320 --> 00:09:35,680
and another killer use case

00:09:33,760 --> 00:09:38,000
there are more but i will focus on those

00:09:35,680 --> 00:09:40,480
three this one we have called it

00:09:38,000 --> 00:09:41,519
cross layer telemetry so for those who

00:09:40,480 --> 00:09:44,399
know about

00:09:41,519 --> 00:09:47,519
uh tracer and interesting tools like

00:09:44,399 --> 00:09:51,040
jagger and open telemetry etc

00:09:47,519 --> 00:09:55,360
well you know that we have a visibility

00:09:51,040 --> 00:09:58,399
on layer five six and seven

00:09:55,360 --> 00:10:01,519
so the goal here is to use iom to

00:09:58,399 --> 00:10:05,920
correlate trace ids

00:10:01,519 --> 00:10:07,839
with network brackets so that we can

00:10:05,920 --> 00:10:10,640
regroup everything and have a total

00:10:07,839 --> 00:10:13,680
visible visibility on the network stack

00:10:10,640 --> 00:10:16,959
so here thanks to iom we inject

00:10:13,680 --> 00:10:18,560
the trace and span ids of the tracing

00:10:16,959 --> 00:10:21,120
tool and

00:10:18,560 --> 00:10:22,000
at the end we have a total visibility on

00:10:21,120 --> 00:10:25,120
the stack

00:10:22,000 --> 00:10:26,079
from a layer 2 to layer 7. so this is a

00:10:25,120 --> 00:10:29,120
huge

00:10:26,079 --> 00:10:30,720
improvement because if you have already

00:10:29,120 --> 00:10:34,399
used such tools

00:10:30,720 --> 00:10:38,800
for instance if you want to debug an sql

00:10:34,399 --> 00:10:41,839
request usually you have layer 5 to 7

00:10:38,800 --> 00:10:43,519
info and now if you have something that

00:10:41,839 --> 00:10:46,560
is going wrong on the link or

00:10:43,519 --> 00:10:49,040
below layer 5 well

00:10:46,560 --> 00:10:49,839
you could wait to to to determine the

00:10:49,040 --> 00:10:52,480
end of the problem

00:10:49,839 --> 00:10:53,040
so now you can directly check what's

00:10:52,480 --> 00:10:56,480
going on

00:10:53,040 --> 00:11:00,160
and and apply

00:10:56,480 --> 00:11:03,120
an action for that so feel free to visit

00:11:00,160 --> 00:11:04,160
my repo the link is on the slide there

00:11:03,120 --> 00:11:06,720
is a

00:11:04,160 --> 00:11:09,600
video video demonstration for that and i

00:11:06,720 --> 00:11:09,600
think you'll like it

00:11:10,320 --> 00:11:18,880
right so let's go to the implementation

00:11:14,560 --> 00:11:21,920
on the top of the slide i've put a link

00:11:18,880 --> 00:11:23,920
actually this is the the thread of the

00:11:21,920 --> 00:11:25,920
patch i have submitted so this is the

00:11:23,920 --> 00:11:27,680
first version of the patch

00:11:25,920 --> 00:11:28,959
and there are a lot of discussion with

00:11:27,680 --> 00:11:32,560
tom erbert

00:11:28,959 --> 00:11:35,839
and i think they are interesting to read

00:11:32,560 --> 00:11:40,000
so quickly the patch includes

00:11:35,839 --> 00:11:42,000
a new hash table for iom namespaces

00:11:40,000 --> 00:11:44,160
in extension headers uh i have

00:11:42,000 --> 00:11:47,839
implemented processing of iom

00:11:44,160 --> 00:11:49,040
uh by sorry iom uh prerogated trace

00:11:47,839 --> 00:11:53,040
options inside the

00:11:49,040 --> 00:11:55,200
object the insertion of iom data

00:11:53,040 --> 00:11:56,240
if the iom namespace is known so this is

00:11:55,200 --> 00:11:58,639
a configuration

00:11:56,240 --> 00:12:00,160
that is made through netlink generic

00:11:58,639 --> 00:12:03,760
link netting sorry

00:12:00,160 --> 00:12:06,880
and the user tool is ipro2

00:12:03,760 --> 00:12:07,680
and also another new feature which is to

00:12:06,880 --> 00:12:10,000
remove

00:12:07,680 --> 00:12:11,839
an am option so basically it is just

00:12:10,000 --> 00:12:14,959
removing a tlv from

00:12:11,839 --> 00:12:15,360
an extension header and so talking about

00:12:14,959 --> 00:12:18,240
that

00:12:15,360 --> 00:12:19,440
we have a big discussion with them again

00:12:18,240 --> 00:12:22,839
on this because

00:12:19,440 --> 00:12:24,320
this is not com compliant with the rfc

00:12:22,839 --> 00:12:27,680
00:12:24,320 --> 00:12:27,680
and i agree with him

00:12:27,920 --> 00:12:34,639
so my response to that was to say hey

00:12:31,120 --> 00:12:38,320
maybe we could just have it

00:12:34,639 --> 00:12:41,680
for freedom towards users

00:12:38,320 --> 00:12:45,600
because it may not happen

00:12:41,680 --> 00:12:47,680
anytime so it depends totally on the

00:12:45,600 --> 00:12:50,720
operator configuration

00:12:47,680 --> 00:12:52,639
so it could be possible that the

00:12:50,720 --> 00:12:54,000
operator configures it so that you don't

00:12:52,639 --> 00:12:57,440
have to remove

00:12:54,000 --> 00:12:59,200
on the pass a tlv so we still need to

00:12:57,440 --> 00:13:02,720
discuss it on the ietf

00:12:59,200 --> 00:13:04,079
and maybe there is something to improve

00:13:02,720 --> 00:13:06,560
here

00:13:04,079 --> 00:13:07,360
and also the last point is actually just

00:13:06,560 --> 00:13:12,320
an anonymous

00:13:07,360 --> 00:13:12,320
encapsulation of an ipv6906 tunnel

00:13:13,440 --> 00:13:20,560
right so um a small explanation

00:13:16,800 --> 00:13:23,600
on why i have assumed by default

00:13:20,560 --> 00:13:26,720
a 8n boundary

00:13:23,600 --> 00:13:30,240
when i remove options

00:13:26,720 --> 00:13:32,480
so on the left you have an example

00:13:30,240 --> 00:13:34,000
that works and on the right an example

00:13:32,480 --> 00:13:37,040
that wouldn't work

00:13:34,000 --> 00:13:40,240
so let's assume an option x

00:13:37,040 --> 00:13:42,480
which is two and aligned a y

00:13:40,240 --> 00:13:43,839
option that is four nine and a z option

00:13:42,480 --> 00:13:47,360
that is a

00:13:43,839 --> 00:13:49,600
eighth and aligned so again on the left

00:13:47,360 --> 00:13:51,279
if you remove the option so this is

00:13:49,600 --> 00:13:53,680
obviously option to be removed

00:13:51,279 --> 00:13:54,639
if you remove it y option is still for

00:13:53,680 --> 00:13:57,839
an aligned and

00:13:54,639 --> 00:14:00,880
the option is still eight and a nine

00:13:57,839 --> 00:14:02,079
however on the right if you remove again

00:14:00,880 --> 00:14:05,760
the option

00:14:02,079 --> 00:14:08,959
y is still for unaligned but this time

00:14:05,760 --> 00:14:10,079
z is for an aligned so that's a big

00:14:08,959 --> 00:14:12,880
problem because

00:14:10,079 --> 00:14:13,680
actually you don't want to reorder and

00:14:12,880 --> 00:14:16,079
restricture

00:14:13,680 --> 00:14:16,800
every possible option after the removed

00:14:16,079 --> 00:14:18,959
one

00:14:16,800 --> 00:14:20,639
because from a performance point of view

00:14:18,959 --> 00:14:23,279
it's not acceptable

00:14:20,639 --> 00:14:24,000
so the compromise here is to just assume

00:14:23,279 --> 00:14:27,920
by default

00:14:24,000 --> 00:14:30,880
an 8n alignment

00:14:27,920 --> 00:14:32,079
and the price to pay if i can call that

00:14:30,880 --> 00:14:34,000
that way

00:14:32,079 --> 00:14:36,399
this is small price but the price to pay

00:14:34,000 --> 00:14:39,519
is that you may have

00:14:36,399 --> 00:14:41,440
at most four octets of padding that

00:14:39,519 --> 00:14:43,120
would be useless

00:14:41,440 --> 00:14:45,440
and i think this is quite acceptable

00:14:43,120 --> 00:14:47,839
because it's the fastest processor

00:14:45,440 --> 00:14:48,560
but again maybe we won't need this it

00:14:47,839 --> 00:14:51,920
depends on

00:14:48,560 --> 00:14:54,320
if we keep uh the removing of an option

00:14:51,920 --> 00:14:54,320
or not

00:14:55,040 --> 00:14:58,160
so now the control plane implementation

00:14:57,199 --> 00:15:01,120
this is not

00:14:58,160 --> 00:15:01,120
part of the draft

00:15:02,959 --> 00:15:06,880
so this part is compliant with the rfc

00:15:05,760 --> 00:15:09,279
00:15:06,880 --> 00:15:10,560
because we we are covering the two

00:15:09,279 --> 00:15:12,959
scenarios

00:15:10,560 --> 00:15:14,639
the first one is ingress to ingress

00:15:12,959 --> 00:15:17,279
ingress to egress sorry

00:15:14,639 --> 00:15:18,639
so we use the encapsulation and for the

00:15:17,279 --> 00:15:22,079
us to ask

00:15:18,639 --> 00:15:26,320
scenario we are directly inserting iom

00:15:22,079 --> 00:15:28,480
data so this is the inline insertion

00:15:26,320 --> 00:15:29,680
there is a representation uh on the

00:15:28,480 --> 00:15:34,560
graphic below

00:15:29,680 --> 00:15:36,560
uh of an iom buffer which is

00:15:34,560 --> 00:15:38,160
this there is no magic this is just uh

00:15:36,560 --> 00:15:38,959
the representation of an extension

00:15:38,160 --> 00:15:42,800
header

00:15:38,959 --> 00:15:47,120
in this case buy up with iom options

00:15:42,800 --> 00:15:50,000
next to each other so my question is

00:15:47,120 --> 00:15:51,440
this is the open question right now what

00:15:50,000 --> 00:15:53,759
should we do with that

00:15:51,440 --> 00:15:54,639
so currently in my personal

00:15:53,759 --> 00:15:58,720
implementation

00:15:54,639 --> 00:16:01,120
i have it stored in network devices

00:15:58,720 --> 00:16:03,759
directly so there is a new field in that

00:16:01,120 --> 00:16:05,920
device structure

00:16:03,759 --> 00:16:07,600
but again i'm not sure this is the best

00:16:05,920 --> 00:16:09,519
choice so

00:16:07,600 --> 00:16:11,920
here are some choices i could think

00:16:09,519 --> 00:16:15,519
about the first one would be to use

00:16:11,920 --> 00:16:19,360
lightweight thunders and root net link

00:16:15,519 --> 00:16:23,040
so that i remember the iron buffer

00:16:19,360 --> 00:16:25,279
would be attached to a root

00:16:23,040 --> 00:16:28,160
that could be discussed because i'm not

00:16:25,279 --> 00:16:30,639
totally convinced that

00:16:28,160 --> 00:16:31,199
having a buffer the iron buffer attached

00:16:30,639 --> 00:16:36,480
per

00:16:31,199 --> 00:16:38,720
root would be meaningful i don't know

00:16:36,480 --> 00:16:39,680
we have also the possibility to use

00:16:38,720 --> 00:16:42,800
generic left link

00:16:39,680 --> 00:16:45,759
so as for the first part

00:16:42,800 --> 00:16:46,160
and there we could store as it is right

00:16:45,759 --> 00:16:49,440
now

00:16:46,160 --> 00:16:51,759
directly inside the structure of

00:16:49,440 --> 00:16:52,959
that device or we could store it

00:16:51,759 --> 00:16:56,800
somewhere else

00:16:52,959 --> 00:16:58,800
so i'm all here if you have id

00:16:56,800 --> 00:17:00,959
and there is also a third possibility

00:16:58,800 --> 00:17:03,279
which i didn't mention on the slide

00:17:00,959 --> 00:17:04,160
which is another solution if you have

00:17:03,279 --> 00:17:06,079
another one

00:17:04,160 --> 00:17:08,079
so again if you have an intuition or

00:17:06,079 --> 00:17:11,120
something feel free to speak

00:17:08,079 --> 00:17:14,400
and i'll be glad to hear you

00:17:11,120 --> 00:17:17,039
let's review some early results

00:17:14,400 --> 00:17:18,799
from a performance point of view and i

00:17:17,039 --> 00:17:22,079
guess that tolkien fans

00:17:18,799 --> 00:17:25,120
will appreciate the test bed

00:17:22,079 --> 00:17:28,000
so gimli uh on the extreme left

00:17:25,120 --> 00:17:30,080
is the traffic generator and lee glass

00:17:28,000 --> 00:17:32,960
is the traffic receiver

00:17:30,080 --> 00:17:34,240
mary and pippen are respectively the

00:17:32,960 --> 00:17:37,679
ingress and the

00:17:34,240 --> 00:17:38,400
egress of the iem domain and sam is just

00:17:37,679 --> 00:17:42,160
an iom

00:17:38,400 --> 00:17:42,480
node on the past so what happens here is

00:17:42,160 --> 00:17:45,360
that

00:17:42,480 --> 00:17:46,720
mary will receive traffic from gaming it

00:17:45,360 --> 00:17:50,400
will encapsulate it

00:17:46,720 --> 00:17:53,200
so we have now an outer ipv6 header

00:17:50,400 --> 00:17:54,080
and an inner ipv6 setter so we don't

00:17:53,200 --> 00:17:57,840
touch

00:17:54,080 --> 00:18:01,520
the user traffic and the irm data will

00:17:57,840 --> 00:18:03,760
be inserted inside the outer header

00:18:01,520 --> 00:18:06,000
and then mary sum and pipen will insert

00:18:03,760 --> 00:18:08,480
their data

00:18:06,000 --> 00:18:10,559
after each one and the pen finally will

00:18:08,480 --> 00:18:12,960
decapsulate the packet and so legolas

00:18:10,559 --> 00:18:16,160
will receive the packet untouched

00:18:12,960 --> 00:18:19,600
so this is the scenario we measured here

00:18:16,160 --> 00:18:23,120
and obviously on the left graph

00:18:19,600 --> 00:18:27,120
you can see that with big packets so

00:18:23,120 --> 00:18:30,400
in this case it was mtu sized packets

00:18:27,120 --> 00:18:34,320
1500 byte packets actually

00:18:30,400 --> 00:18:36,960
it is um 12 36 byte packets but

00:18:34,320 --> 00:18:37,520
when we insert iom data it's the mtu

00:18:36,960 --> 00:18:40,320
size

00:18:37,520 --> 00:18:41,440
so with big packets there is no such

00:18:40,320 --> 00:18:44,880
high drop

00:18:41,440 --> 00:18:46,640
but with small packets 78 byte packets

00:18:44,880 --> 00:18:49,120
you can see the variations

00:18:46,640 --> 00:18:50,799
so it's logical because the kernel is

00:18:49,120 --> 00:18:54,240
more stressed

00:18:50,799 --> 00:18:57,679
so we will use it as a base so small

00:18:54,240 --> 00:19:01,520
packets has a base because you can see

00:18:57,679 --> 00:19:01,919
what's going on better and we are going

00:19:01,520 --> 00:19:04,960
to

00:19:01,919 --> 00:19:08,840
vary some parameters and on the right

00:19:04,960 --> 00:19:10,480
graph we first vary the frequency of iom

00:19:08,840 --> 00:19:13,679
insertion so

00:19:10,480 --> 00:19:15,280
obviously having a hundred percent of

00:19:13,679 --> 00:19:18,080
insertion is not good

00:19:15,280 --> 00:19:19,760
so that means that you insert iom at

00:19:18,080 --> 00:19:22,000
every packet you see

00:19:19,760 --> 00:19:23,039
and we have the same test for 50 so one

00:19:22,000 --> 00:19:26,799
over two

00:19:23,039 --> 00:19:32,000
25 10 5 etc etc

00:19:26,799 --> 00:19:36,720
so from the graph you could tell that

00:19:32,000 --> 00:19:38,799
10 or 25 percent would be acceptable

00:19:36,720 --> 00:19:40,000
so that could be an advice to an

00:19:38,799 --> 00:19:42,320
operator

00:19:40,000 --> 00:19:45,039
but again that depends of a lot of

00:19:42,320 --> 00:19:45,039
parameters

00:19:46,160 --> 00:19:49,679
on the next two graphs we vary the

00:19:48,720 --> 00:19:52,799
number of

00:19:49,679 --> 00:19:55,760
iom options and then on the right we

00:19:52,799 --> 00:19:59,840
vary the number of ium name spaces

00:19:55,760 --> 00:20:03,360
so a namespace brings more overhead than

00:19:59,840 --> 00:20:04,559
an option so on the left you can see

00:20:03,360 --> 00:20:07,360
that

00:20:04,559 --> 00:20:09,039
until the eighth option it's okay we

00:20:07,360 --> 00:20:12,159
don't lose anything

00:20:09,039 --> 00:20:13,840
and up to the nine we start dropping

00:20:12,159 --> 00:20:15,200
so there is a logical explanation to

00:20:13,840 --> 00:20:18,840
that and

00:20:15,200 --> 00:20:22,080
we are around an overhead of uh 200

00:20:18,840 --> 00:20:24,799
bytes and

00:20:22,080 --> 00:20:25,840
my intuition is that it's actually

00:20:24,799 --> 00:20:28,159
because of an

00:20:25,840 --> 00:20:29,600
implicit reallocation of the circuit

00:20:28,159 --> 00:20:32,400
buffer

00:20:29,600 --> 00:20:34,000
because there is no space anymore to

00:20:32,400 --> 00:20:37,360
insert the data

00:20:34,000 --> 00:20:40,720
and that would explain such high drop

00:20:37,360 --> 00:20:42,159
starting from the ninth option and we

00:20:40,720 --> 00:20:45,120
could have the same reasoning

00:20:42,159 --> 00:20:46,480
for uh the graph on the right so when we

00:20:45,120 --> 00:20:49,760
vary the number of

00:20:46,480 --> 00:20:51,520
iron name namespaces and let me count

00:20:49,760 --> 00:20:54,799
one two three four five six

00:20:51,520 --> 00:20:57,280
it starts dropping um

00:20:54,799 --> 00:20:59,200
starting from the sixth ones and

00:20:57,280 --> 00:21:00,960
especially after the six months

00:20:59,200 --> 00:21:03,360
so it corresponds actually to the same

00:21:00,960 --> 00:21:04,240
overhead we have observed previously on

00:21:03,360 --> 00:21:08,080
the

00:21:04,240 --> 00:21:10,799
left graph which is around 200 bytes

00:21:08,080 --> 00:21:11,600
so i guess this is this is the

00:21:10,799 --> 00:21:14,559
explanation

00:21:11,600 --> 00:21:15,679
and i will try to dig deeper to see if

00:21:14,559 --> 00:21:18,159
there is something more

00:21:15,679 --> 00:21:20,559
actually there is another explanation

00:21:18,159 --> 00:21:22,880
but i don't think this is a problem

00:21:20,559 --> 00:21:24,000
for each namespace there is a lookup in

00:21:22,880 --> 00:21:26,080
the hash table

00:21:24,000 --> 00:21:27,120
so the more namespaces you have the more

00:21:26,080 --> 00:21:30,400
lookups you have

00:21:27,120 --> 00:21:31,600
but again should be one operation

00:21:30,400 --> 00:21:34,799
because

00:21:31,600 --> 00:21:38,240
the hash table is optimized for that and

00:21:34,799 --> 00:21:38,240
shouldn't be any collision so

00:21:38,480 --> 00:21:41,840
that's the explanation for now from

00:21:40,400 --> 00:21:44,240
those results

00:21:41,840 --> 00:21:44,880
we could advise operators to have a mix

00:21:44,240 --> 00:21:48,159
which is

00:21:44,880 --> 00:21:50,640
uh more real for a

00:21:48,159 --> 00:21:51,200
more real example for real life so we

00:21:50,640 --> 00:21:54,559
could have

00:21:51,200 --> 00:21:55,840
for instance a frequency of one or two

00:21:54,559 --> 00:21:59,600
percent

00:21:55,840 --> 00:22:03,360
with five or six options with

00:21:59,600 --> 00:22:07,039
four or five name spaces it would work

00:22:03,360 --> 00:22:10,880
and this is a

00:22:07,039 --> 00:22:14,000
representation uh during uh line rate so

00:22:10,880 --> 00:22:16,240
the server was under heavy load

00:22:14,000 --> 00:22:17,600
so you could also adapt the the

00:22:16,240 --> 00:22:19,440
frequency of insertion

00:22:17,600 --> 00:22:20,960
depending on the traffic you you are

00:22:19,440 --> 00:22:22,559
seeing at that moment so

00:22:20,960 --> 00:22:25,840
you can have a dynamic tracer for

00:22:22,559 --> 00:22:28,960
instance that's an

00:22:25,840 --> 00:22:29,600
so as a conclusion i think that having

00:22:28,960 --> 00:22:32,480
iom

00:22:29,600 --> 00:22:33,360
inside the kernel would be a nice

00:22:32,480 --> 00:22:36,240
feature to have

00:22:33,360 --> 00:22:36,799
so from an industry point of view i

00:22:36,240 --> 00:22:38,960
think

00:22:36,799 --> 00:22:40,159
that it would be nice to have it so that

00:22:38,960 --> 00:22:42,320
operators

00:22:40,159 --> 00:22:43,600
could choose the linux kernel and not

00:22:42,320 --> 00:22:45,760
have to choose something else to have

00:22:43,600 --> 00:22:48,240
iom

00:22:45,760 --> 00:22:49,360
i just think about bypassing frameworks

00:22:48,240 --> 00:22:52,240
and

00:22:49,360 --> 00:22:53,520
everything like that so it's kind of

00:22:52,240 --> 00:22:57,280
boring so

00:22:53,520 --> 00:23:01,120
let's try to make linux kernel famous

00:22:57,280 --> 00:23:01,520
like it is already um again i'm putting

00:23:01,120 --> 00:23:04,480
the

00:23:01,520 --> 00:23:05,120
the link to the data patch i submitted

00:23:04,480 --> 00:23:08,559
around

00:23:05,120 --> 00:23:09,360
a month or so so you can throw down the

00:23:08,559 --> 00:23:14,559
tread and

00:23:09,360 --> 00:23:17,520
read interesting discussion with tom

00:23:14,559 --> 00:23:18,400
so again uh what do we choose for the

00:23:17,520 --> 00:23:21,120
control plane

00:23:18,400 --> 00:23:24,159
where should we store the iom buffer

00:23:21,120 --> 00:23:24,159
what's the best choice

00:23:24,480 --> 00:23:32,480
again i'm all here and

00:23:28,799 --> 00:23:36,640
the final world on the ietf

00:23:32,480 --> 00:23:37,600
we have already run a project on iom and

00:23:36,640 --> 00:23:40,400
ipv6

00:23:37,600 --> 00:23:40,960
during uh the academy last year with

00:23:40,400 --> 00:23:44,240
thumb

00:23:40,960 --> 00:23:47,039
and it was actually fun and a success

00:23:44,240 --> 00:23:47,679
so we could eventually make another one

00:23:47,039 --> 00:23:50,960
so

00:23:47,679 --> 00:23:52,240
if we do let's let's have fun together

00:23:50,960 --> 00:23:55,440
so feel free to join

00:23:52,240 --> 00:23:55,840
and we may have requirement for some

00:23:55,440 --> 00:23:59,840
help

00:23:55,840 --> 00:24:04,159
on some details so for instance uh

00:23:59,840 --> 00:24:07,760
in ibm data we have uh to retrieve um

00:24:04,159 --> 00:24:11,039
the queue length of the egress interface

00:24:07,760 --> 00:24:14,320
so until now i didn't succeed it

00:24:11,039 --> 00:24:16,159
so maybe we can help you can help me

00:24:14,320 --> 00:24:17,520
and we could work on everything and

00:24:16,159 --> 00:24:20,720
improve everything

00:24:17,520 --> 00:24:20,720
so feel free to join

00:24:21,120 --> 00:24:24,240
so i guess i was a bit fast no it's okay

00:24:23,440 --> 00:24:26,799
so thank you

00:24:24,240 --> 00:24:28,000
again um feel free to contact me there

00:24:26,799 --> 00:24:33,440
is my address

00:24:28,000 --> 00:24:38,000
um and feel free to ask me directly live

00:24:33,440 --> 00:24:38,000
just now thank you again bye-bye

00:24:39,840 --> 00:24:44,880
okay uh thanks justin

00:24:42,880 --> 00:24:46,320
um someone one comment i'd like to make

00:24:44,880 --> 00:24:49,760
on the

00:24:46,320 --> 00:24:51,360
appeal to get people to work on this and

00:24:49,760 --> 00:24:54,799
the ietf hackathons

00:24:51,360 --> 00:24:55,679
i would point out that for those of you

00:24:54,799 --> 00:24:58,840
who

00:24:55,679 --> 00:25:01,679
might be kind of newbies to lanex

00:24:58,840 --> 00:25:04,159
development um and want to get into it

00:25:01,679 --> 00:25:04,799
this this is a sort of project is really

00:25:04,159 --> 00:25:07,200
good for that

00:25:04,799 --> 00:25:08,000
it's somewhat standalone but it also

00:25:07,200 --> 00:25:11,200
leverages

00:25:08,000 --> 00:25:13,679
uh several of the apis and it raises

00:25:11,200 --> 00:25:17,679
some interesting questions like the

00:25:13,679 --> 00:25:18,400
iom buffer we have several techniques

00:25:17,679 --> 00:25:20,159
and

00:25:18,400 --> 00:25:22,480
and this is a case where finding that

00:25:20,159 --> 00:25:25,360
right technique actually requires

00:25:22,480 --> 00:25:26,559
interaction with the community so it's

00:25:25,360 --> 00:25:27,520
it's a really good project for that

00:25:26,559 --> 00:25:30,159
point of view so i do

00:25:27,520 --> 00:25:31,200
encourage people looking to get into

00:25:30,159 --> 00:25:34,960
development

00:25:31,200 --> 00:25:36,799
this is a really good project for that

00:25:34,960 --> 00:25:38,559
uh that being said we do have some

00:25:36,799 --> 00:25:40,320
questions

00:25:38,559 --> 00:25:42,240
so first of all and i think there was

00:25:40,320 --> 00:25:46,000
some discussion on this but but how is

00:25:42,240 --> 00:25:46,000
the loopback flag actually used

00:25:46,640 --> 00:25:52,960
well mainly for the faster traceroute

00:25:51,039 --> 00:25:54,480
so you could imagine having some some

00:25:52,960 --> 00:25:57,520
other use case i don't know

00:25:54,480 --> 00:26:00,480
but here it's mainly for the

00:25:57,520 --> 00:26:00,480
faster traceroute

00:26:01,760 --> 00:26:06,080
so when when we're using this does this

00:26:03,760 --> 00:26:11,200
run the risk of

00:26:06,080 --> 00:26:13,520
any sort of packet amplification attacks

00:26:11,200 --> 00:26:14,799
yeah as i said this is still under a

00:26:13,520 --> 00:26:17,760
discussion uh

00:26:14,799 --> 00:26:18,480
in the working group so uh that every

00:26:17,760 --> 00:26:21,840
aspect

00:26:18,480 --> 00:26:23,440
of security is covered because

00:26:21,840 --> 00:26:25,840
there were there were some problems with

00:26:23,440 --> 00:26:25,840
that

00:26:26,159 --> 00:26:30,480
so currently this is not used in

00:26:28,000 --> 00:26:34,080
implementation right now

00:26:30,480 --> 00:26:37,600
so i just would clarify so the in-situ

00:26:34,080 --> 00:26:39,279
part of iom means that this is really

00:26:37,600 --> 00:26:42,559
in-band data so we're

00:26:39,279 --> 00:26:44,799
annotating the actual packets carrying

00:26:42,559 --> 00:26:45,840
the data and there are alternatives

00:26:44,799 --> 00:26:50,080
being proposed

00:26:45,840 --> 00:26:52,799
um obviously if we're putting

00:26:50,080 --> 00:26:55,200
data into packets for measurement that's

00:26:52,799 --> 00:26:58,400
affecting the size of the packets

00:26:55,200 --> 00:26:59,279
and people do notice that and one thing

00:26:58,400 --> 00:27:02,799
we're seeing

00:26:59,279 --> 00:27:05,840
is iom segment routing

00:27:02,799 --> 00:27:07,840
these potentially are really big headers

00:27:05,840 --> 00:27:10,960
and that starts to become a problem

00:27:07,840 --> 00:27:13,679
especially for hardware devices that

00:27:10,960 --> 00:27:14,320
are aren't able to process those headers

00:27:13,679 --> 00:27:15,919
and

00:27:14,320 --> 00:27:17,600
we also have other problems along these

00:27:15,919 --> 00:27:18,080
lines so even getting extension headers

00:27:17,600 --> 00:27:19,520
through

00:27:18,080 --> 00:27:22,720
a device has been a little bit of a

00:27:19,520 --> 00:27:24,880
challenge uh fortunately iom is

00:27:22,720 --> 00:27:28,320
usually constrained to a closed domain

00:27:24,880 --> 00:27:28,320
where we can control things like that

00:27:31,279 --> 00:27:36,720
okay so i didn't want to comment on i

00:27:33,440 --> 00:27:36,720
thought it was a question actually

00:27:36,880 --> 00:27:43,919
well let me comment on the

00:27:40,080 --> 00:27:47,360
extension header insertion so this is

00:27:43,919 --> 00:27:50,080
a much larger topic than just io am

00:27:47,360 --> 00:27:52,559
what happened was the segment routing

00:27:50,080 --> 00:27:56,960
proponents

00:27:52,559 --> 00:27:58,720
specifically cisco wanted to insert

00:27:56,960 --> 00:28:00,640
extension headers into packets on the

00:27:58,720 --> 00:28:02,320
fly without changing

00:28:00,640 --> 00:28:04,080
the ip header or without doing

00:28:02,320 --> 00:28:07,120
encapsulation

00:28:04,080 --> 00:28:09,039
and this created a well for lack of a

00:28:07,120 --> 00:28:10,960
better word a very animated discussion

00:28:09,039 --> 00:28:14,399
with in ietf

00:28:10,960 --> 00:28:15,760
because rfc 8200 which defines the ipv6

00:28:14,399 --> 00:28:19,039
specification

00:28:15,760 --> 00:28:20,640
clearly says that intermediate devices

00:28:19,039 --> 00:28:23,919
are not supposed to

00:28:20,640 --> 00:28:25,039
insert or change things like extension

00:28:23,919 --> 00:28:26,159
headers

00:28:25,039 --> 00:28:29,039
and there are some practical

00:28:26,159 --> 00:28:31,279
considerations in this that we point out

00:28:29,039 --> 00:28:33,279
so for instance if i increase the size

00:28:31,279 --> 00:28:34,880
of a packet in the middle of the network

00:28:33,279 --> 00:28:37,120
that runs the risk that that packet

00:28:34,880 --> 00:28:40,159
might be dropped by a later node

00:28:37,120 --> 00:28:43,200
because mtu's exceed it

00:28:40,159 --> 00:28:44,000
and it's possible in certain conditions

00:28:43,200 --> 00:28:47,679
that

00:28:44,000 --> 00:28:51,440
path mtu or getting a pack get too big

00:28:47,679 --> 00:28:56,159
actually wouldn't solve the problem so

00:28:51,440 --> 00:28:58,880
the other one was anytime we modify

00:28:56,159 --> 00:29:00,559
the packet in a non-standard way if it's

00:28:58,880 --> 00:29:03,520
covered by the ip

00:29:00,559 --> 00:29:05,600
um extent or authentication header now

00:29:03,520 --> 00:29:09,360
we run the risk of the

00:29:05,600 --> 00:29:11,520
packet being dropped um and again

00:29:09,360 --> 00:29:12,960
the device in the middle of the network

00:29:11,520 --> 00:29:14,320
would have no idea

00:29:12,960 --> 00:29:17,039
that the package dropped because it's

00:29:14,320 --> 00:29:19,520
being dropped by later downstream node

00:29:17,039 --> 00:29:20,240
so there's been a ton of discussion on

00:29:19,520 --> 00:29:22,720
this

00:29:20,240 --> 00:29:24,559
and one of the outcomes was uh i tried

00:29:22,720 --> 00:29:26,799
to propose

00:29:24,559 --> 00:29:28,480
a kind of a fix for this where we would

00:29:26,799 --> 00:29:30,640
allow

00:29:28,480 --> 00:29:33,039
nodes to insert the sort of data

00:29:30,640 --> 00:29:35,600
extension headers without encapsulation

00:29:33,039 --> 00:29:37,440
however they have to identify the data

00:29:35,600 --> 00:29:39,840
that's been inserted

00:29:37,440 --> 00:29:41,120
and they have to identify basically who

00:29:39,840 --> 00:29:43,840
inserted it so we have

00:29:41,120 --> 00:29:44,799
attribution so um that's what that's

00:29:43,840 --> 00:29:46,799
about

00:29:44,799 --> 00:29:48,640
and the stat state of that is i do want

00:29:46,799 --> 00:29:49,679
to take this to become a working group

00:29:48,640 --> 00:29:51,520
item

00:29:49,679 --> 00:29:54,080
and i think it's a good compromise

00:29:51,520 --> 00:29:57,279
between on one hand we have the the

00:29:54,080 --> 00:29:58,799
zealots of ietf who

00:29:57,279 --> 00:30:01,279
will jump up and down whenever we're

00:29:58,799 --> 00:30:02,960
violating a full internet standard which

00:30:01,279 --> 00:30:06,720
rfc 8200 is

00:30:02,960 --> 00:30:08,880
versus a pretty large contingent of

00:30:06,720 --> 00:30:10,480
vendors and operators who want to do

00:30:08,880 --> 00:30:12,640
this and there are some valid reasons

00:30:10,480 --> 00:30:14,799
actually i think iom is

00:30:12,640 --> 00:30:16,880
a much more valid reason than even

00:30:14,799 --> 00:30:20,320
segment routing for some reasons

00:30:16,880 --> 00:30:22,799
so i'm hoping to push that and

00:30:20,320 --> 00:30:25,919
subsequently get some patches upstream

00:30:22,799 --> 00:30:28,000
so i think i just i think it is possible

00:30:25,919 --> 00:30:29,039
um but we have to do this in the right

00:30:28,000 --> 00:30:32,159
way uh

00:30:29,039 --> 00:30:34,480
and the thing here is this isn't really

00:30:32,159 --> 00:30:36,159
just about linux what we have to be

00:30:34,480 --> 00:30:39,600
careful of is setting the president

00:30:36,159 --> 00:30:40,559
and we don't want um the router vendors

00:30:39,600 --> 00:30:42,799
pointing to us and say

00:30:40,559 --> 00:30:44,240
if they're doing it we can do it so we

00:30:42,799 --> 00:30:47,440
really want to

00:30:44,240 --> 00:30:49,760
do things right in linux and um that's

00:30:47,440 --> 00:30:53,679
why i think we need to be careful about

00:30:49,760 --> 00:30:56,320
slipping in patches that circumvent

00:30:53,679 --> 00:30:57,519
rc 8200 and all fairness segment routing

00:30:56,320 --> 00:31:00,640
already does this but

00:30:57,519 --> 00:31:00,640
we'd also have to fix that

00:31:01,360 --> 00:31:05,360
well as a side note um maybe we could

00:31:03,600 --> 00:31:10,080
just remove

00:31:05,360 --> 00:31:10,080
the feature to to remove an aom option

00:31:10,320 --> 00:31:14,159
so we could avoid this problem uh anyway

00:31:13,440 --> 00:31:17,919
i think your

00:31:14,159 --> 00:31:19,039
solution your draft could be useful uh

00:31:17,919 --> 00:31:21,360
maybe for the

00:31:19,039 --> 00:31:22,720
incremental trace because each node

00:31:21,360 --> 00:31:25,440
would have to

00:31:22,720 --> 00:31:26,320
increase the space of the extension

00:31:25,440 --> 00:31:29,600
header

00:31:26,320 --> 00:31:33,200
so we could have something like a new

00:31:29,600 --> 00:31:36,720
option in your draft so i think this is

00:31:33,200 --> 00:31:36,720
something useful interesting

00:31:37,039 --> 00:31:40,399
okay so i think in the short term that

00:31:38,799 --> 00:31:40,799
would be good but i don't want to get

00:31:40,399 --> 00:31:42,640
this

00:31:40,799 --> 00:31:44,000
in the long term because i think there's

00:31:42,640 --> 00:31:47,440
value in it

00:31:44,000 --> 00:31:48,240
so uh about the question you proposed to

00:31:47,440 --> 00:31:50,159
the community

00:31:48,240 --> 00:31:52,159
um thank you for proposing questions i

00:31:50,159 --> 00:31:55,919
think that's really good

00:31:52,159 --> 00:31:56,480
uh i guess my question in response to

00:31:55,919 --> 00:31:59,600
that is

00:31:56,480 --> 00:32:02,720
um what's the best way to to proceed

00:31:59,600 --> 00:32:06,080
so we can either have you can either

00:32:02,720 --> 00:32:07,919
have individuals reach out to you um

00:32:06,080 --> 00:32:09,440
if if it warrants it and we have enough

00:32:07,919 --> 00:32:13,600
interest we could do uh

00:32:09,440 --> 00:32:17,120
maybe a breakout session on this um

00:32:13,600 --> 00:32:18,159
or uh the other alternative that that's

00:32:17,120 --> 00:32:23,039
worked before is

00:32:18,159 --> 00:32:25,760
um do rcs for various solutions and

00:32:23,039 --> 00:32:26,559
uh post them upstream uh sometimes it is

00:32:25,760 --> 00:32:29,039
hard to get

00:32:26,559 --> 00:32:29,679
good interest on rfcs but if you find

00:32:29,039 --> 00:32:31,760
that

00:32:29,679 --> 00:32:33,120
one one person who happens to be

00:32:31,760 --> 00:32:35,279
interested in then it works out really

00:32:33,120 --> 00:32:35,279
well

00:32:37,760 --> 00:32:43,840
okay so i'm checking for any more

00:32:39,279 --> 00:32:43,840
questions um

00:32:45,279 --> 00:32:53,679
all right so i uh

00:32:49,600 --> 00:32:53,679

YouTube URL: https://www.youtube.com/watch?v=4cwnje-KThk


