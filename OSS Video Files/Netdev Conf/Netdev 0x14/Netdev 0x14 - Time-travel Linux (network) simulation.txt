Title: Netdev 0x14 - Time-travel Linux (network) simulation
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Johannes Berg, Richard Weinberger

More info: https://netdevconf.info/0x14/session.html?talk-time-travel-linux-network-simulation

Date: Tuesday, August 18, 2020

In this talk Johannes Berg introduces a
mechanism to do "time travel" in User Mode Linux(UML) with a
virtual clock. One motivation for this feature is to test the
802.11 stack under Linux.

The time travel mode allows for reproducible testing at significantly
faster test execution times; as an example, on a relatively slow
machine:
two simulated machines in such a setup can simulate 61 pings,
at a default 1 second interval, in about 1.6 seconds real time
(as opposed to 61 seconds).
Captions: 
	00:00:01,199 --> 00:00:07,359
okay i'm here today to talk about

00:00:03,919 --> 00:00:08,559
linux time travel mode um i get into

00:00:07,359 --> 00:00:12,719
what that is and

00:00:08,559 --> 00:00:15,360
how to apply it to network simulation so

00:00:12,719 --> 00:00:16,800
what here's my introduction let's talk

00:00:15,360 --> 00:00:19,119
about time travel first

00:00:16,800 --> 00:00:21,199
the the term was coined on mailing list

00:00:19,119 --> 00:00:22,800
discussions we

00:00:21,199 --> 00:00:24,480
don't really have time travel in the

00:00:22,800 --> 00:00:25,680
sense that we can go back in time or

00:00:24,480 --> 00:00:27,599
something like that

00:00:25,680 --> 00:00:28,880
but we do skip time forward when the

00:00:27,599 --> 00:00:30,960
system is idle

00:00:28,880 --> 00:00:33,840
so that kind of the system travels

00:00:30,960 --> 00:00:36,399
through time much faster than real time

00:00:33,840 --> 00:00:37,520
and all of this is implemented on user

00:00:36,399 --> 00:00:40,000
mode linux

00:00:37,520 --> 00:00:41,680
which is a kind of virtual machine i

00:00:40,000 --> 00:00:42,399
don't know if everyone is familiar with

00:00:41,680 --> 00:00:44,800
it

00:00:42,399 --> 00:00:45,520
but it's a port of linux to its own user

00:00:44,800 --> 00:00:47,680
space

00:00:45,520 --> 00:00:49,360
so it runs as it runs the kernel as a

00:00:47,680 --> 00:00:51,280
user space process

00:00:49,360 --> 00:00:53,360
and then any process running inside of

00:00:51,280 --> 00:00:55,760
the kernel it's just a normal process

00:00:53,360 --> 00:01:00,320
that the user remote linux p traces

00:00:55,760 --> 00:01:02,719
to be able to intercept the system calls

00:01:00,320 --> 00:01:04,559
so why would we want to do this really

00:01:02,719 --> 00:01:05,840
the the main motivation for this is

00:01:04,559 --> 00:01:07,920
testing and

00:01:05,840 --> 00:01:09,200
that's in different ways testing here it

00:01:07,920 --> 00:01:11,840
applies in different ways

00:01:09,200 --> 00:01:12,640
so you might want to use it for speed

00:01:11,840 --> 00:01:14,400
because

00:01:12,640 --> 00:01:16,080
if you have time travel then anything

00:01:14,400 --> 00:01:18,320
that you're waiting for

00:01:16,080 --> 00:01:19,920
basically could collapse down to nothing

00:01:18,320 --> 00:01:22,320
we have some examples there

00:01:19,920 --> 00:01:24,320
where two minutes wait um just kind of

00:01:22,320 --> 00:01:26,080
collapse to a second or so

00:01:24,320 --> 00:01:28,080
or maybe you have something that you

00:01:26,080 --> 00:01:30,320
want to test that doesn't exist yet so

00:01:28,080 --> 00:01:32,479
you have a simulation for the device

00:01:30,320 --> 00:01:33,600
but your simulation is slower than real

00:01:32,479 --> 00:01:37,439
time

00:01:33,600 --> 00:01:39,600
and if it's slower than real time then

00:01:37,439 --> 00:01:40,960
your virtual machine might get timeouts

00:01:39,600 --> 00:01:42,240
or something like that if it's talking

00:01:40,960 --> 00:01:43,759
to the device

00:01:42,240 --> 00:01:45,680
or you might have something that you

00:01:43,759 --> 00:01:47,119
can't reproduce because you don't have

00:01:45,680 --> 00:01:49,439
the network topology

00:01:47,119 --> 00:01:51,360
you don't have a way of testing a very

00:01:49,439 --> 00:01:53,280
long latency link because you would have

00:01:51,360 --> 00:01:55,280
to actually build a very long latency

00:01:53,280 --> 00:01:58,240
link which usually implies a very long

00:01:55,280 --> 00:02:00,159
distance so all these kinds of things

00:01:58,240 --> 00:02:03,200
might be things that you don't have

00:02:00,159 --> 00:02:05,520
unless you're simulating the system or

00:02:03,200 --> 00:02:07,200
you might have things where you're when

00:02:05,520 --> 00:02:09,280
you don't have enough cpu speed

00:02:07,200 --> 00:02:11,200
to do what you want to do you might want

00:02:09,280 --> 00:02:12,560
to log everything or trace everything

00:02:11,200 --> 00:02:14,080
you might want to enable all kinds of

00:02:12,560 --> 00:02:16,160
kernel debug options

00:02:14,080 --> 00:02:18,000
and when you do that your tests time out

00:02:16,160 --> 00:02:19,280
because certain things don't happen fast

00:02:18,000 --> 00:02:20,800
enough

00:02:19,280 --> 00:02:23,760
or you might want to do some manual

00:02:20,800 --> 00:02:25,520
debugging where you don't know

00:02:23,760 --> 00:02:27,200
exactly what's happening in the system

00:02:25,520 --> 00:02:28,560
so you want to attach the debugger but

00:02:27,200 --> 00:02:29,200
you don't want everything else to keep

00:02:28,560 --> 00:02:32,160
running

00:02:29,200 --> 00:02:33,920
so when you're using this mode time will

00:02:32,160 --> 00:02:36,720
stop you can go to lunch and pick up

00:02:33,920 --> 00:02:38,239
exactly where you left off and

00:02:36,720 --> 00:02:40,000
nothing else will have happened in the

00:02:38,239 --> 00:02:42,239
system neither in the one

00:02:40,000 --> 00:02:43,840
machine or another machine or any device

00:02:42,239 --> 00:02:45,519
that you're simulating or the network

00:02:43,840 --> 00:02:47,440
that you're simulating

00:02:45,519 --> 00:02:48,800
so that's really the the motivation all

00:02:47,440 --> 00:02:51,360
of it is around

00:02:48,800 --> 00:02:52,000
testing being able to reproduce certain

00:02:51,360 --> 00:02:53,200
things

00:02:52,000 --> 00:02:54,640
it's also it can be a lot more

00:02:53,200 --> 00:02:55,760
reproducible because you're not

00:02:54,640 --> 00:02:57,360
dependent on

00:02:55,760 --> 00:02:59,040
you know maybe we're applying this to

00:02:57,360 --> 00:03:00,800
wireless network so

00:02:59,040 --> 00:03:02,400
if everything would depend on how your

00:03:00,800 --> 00:03:04,720
medium access works how much other

00:03:02,400 --> 00:03:06,560
devices are around you

00:03:04,720 --> 00:03:08,560
and here that doesn't apply it's all in

00:03:06,560 --> 00:03:10,720
a simulation everything is

00:03:08,560 --> 00:03:12,720
basically deterministic there's some

00:03:10,720 --> 00:03:14,800
leaks of determinism because you still

00:03:12,720 --> 00:03:17,200
have random numbers in the device

00:03:14,800 --> 00:03:18,319
in the virtual machine you still have

00:03:17,200 --> 00:03:20,319
the real time

00:03:18,319 --> 00:03:22,319
when the system started in the virtual

00:03:20,319 --> 00:03:23,040
machine so things are slightly different

00:03:22,319 --> 00:03:26,239
every run

00:03:23,040 --> 00:03:28,959
but mostly it's deterministic

00:03:26,239 --> 00:03:30,239
so how do we how do we implement this

00:03:28,959 --> 00:03:33,040
first of all we wanted

00:03:30,239 --> 00:03:34,159
this time travel so we implemented in

00:03:33,040 --> 00:03:37,200
user mode linux

00:03:34,159 --> 00:03:39,599
three time travel modes one is just

00:03:37,200 --> 00:03:40,560
basically time called time travel this

00:03:39,599 --> 00:03:42,080
is on

00:03:40,560 --> 00:03:43,840
actually the command line argument you

00:03:42,080 --> 00:03:45,760
have to give to user mode linux

00:03:43,840 --> 00:03:47,920
in this mode it will skip time forward

00:03:45,760 --> 00:03:49,599
if it's possible if it gets to idle

00:03:47,920 --> 00:03:51,519
but it will never be slower than real

00:03:49,599 --> 00:03:52,319
time so it would actually arm some

00:03:51,519 --> 00:03:54,319
timers

00:03:52,319 --> 00:03:55,519
so that you get every 10 milliseconds

00:03:54,319 --> 00:03:57,040
you could get a tick

00:03:55,519 --> 00:03:59,040
i'm not going to go into the details

00:03:57,040 --> 00:04:00,400
here because a lot of the advantages

00:03:59,040 --> 00:04:02,080
that i mentioned before

00:04:00,400 --> 00:04:03,840
don't apply in this mode you still get

00:04:02,080 --> 00:04:07,040
time ticking even if you're stopping in

00:04:03,840 --> 00:04:08,720
the debugger or something like that

00:04:07,040 --> 00:04:10,319
and then the second one is an extension

00:04:08,720 --> 00:04:13,120
kind of to this

00:04:10,319 --> 00:04:13,760
where you have time travel equals inft

00:04:13,120 --> 00:04:16,239
cpu

00:04:13,760 --> 00:04:17,359
in this mode we're simulating infinite

00:04:16,239 --> 00:04:20,320
cpu speed

00:04:17,359 --> 00:04:23,120
so time doesn't change until we get into

00:04:20,320 --> 00:04:24,320
an idle state or into a delay

00:04:23,120 --> 00:04:26,160
in this mode we don't have any

00:04:24,320 --> 00:04:27,360
preemption so if you have an infinite

00:04:26,160 --> 00:04:29,440
loop or something like that will

00:04:27,360 --> 00:04:31,120
certainly hang the entire system

00:04:29,440 --> 00:04:32,800
the simulation will just stop there

00:04:31,120 --> 00:04:34,639
because it's trying to simulate

00:04:32,800 --> 00:04:36,080
finishing that because it's an infinite

00:04:34,639 --> 00:04:38,720
cpu speed

00:04:36,080 --> 00:04:39,280
and then go back to idle but it's very

00:04:38,720 --> 00:04:42,080
advanced

00:04:39,280 --> 00:04:42,800
it has big advantages when you're doing

00:04:42,080 --> 00:04:45,040
the

00:04:42,800 --> 00:04:47,040
simulation because you can intercept it

00:04:45,040 --> 00:04:48,080
you can look at it you can do whatever

00:04:47,040 --> 00:04:50,160
you want with it

00:04:48,080 --> 00:04:51,680
without really affecting the time inside

00:04:50,160 --> 00:04:54,000
of the simulation

00:04:51,680 --> 00:04:55,199
and then an extension to that to the in

00:04:54,000 --> 00:04:57,280
cpu mode

00:04:55,199 --> 00:04:59,040
is the extension extended mode where

00:04:57,280 --> 00:04:59,840
we're extending this out to multiple

00:04:59,040 --> 00:05:02,320
machines

00:04:59,840 --> 00:05:04,560
or multiple parts that are simulated

00:05:02,320 --> 00:05:07,759
multiple devices multiple machines

00:05:04,560 --> 00:05:10,479
and that has time travel x connecting to

00:05:07,759 --> 00:05:12,479
a given controller socket

00:05:10,479 --> 00:05:14,400
but let's talk about time travel itself

00:05:12,479 --> 00:05:16,560
first before we connect it out to some

00:05:14,400 --> 00:05:18,720
other machine

00:05:16,560 --> 00:05:19,759
so the underlying mechanisms we really

00:05:18,720 --> 00:05:22,400
need are

00:05:19,759 --> 00:05:24,000
four things that the kernel relies on so

00:05:22,400 --> 00:05:26,320
the first thing is

00:05:24,000 --> 00:05:27,199
what time is it obviously it has to know

00:05:26,320 --> 00:05:29,039
this is

00:05:27,199 --> 00:05:30,960
called the clock source struck clock

00:05:29,039 --> 00:05:33,440
storage in linux

00:05:30,960 --> 00:05:35,680
the second thing is please wake me up in

00:05:33,440 --> 00:05:39,360
a certain amount of nanoseconds

00:05:35,680 --> 00:05:40,720
so when you when the when the system has

00:05:39,360 --> 00:05:42,080
nothing to do or when the schedule is

00:05:40,720 --> 00:05:43,759
ticking it will tell you and please wake

00:05:42,080 --> 00:05:45,520
me up in 10 milliseconds but if someone

00:05:43,759 --> 00:05:47,120
armed the timer it might be please make

00:05:45,520 --> 00:05:48,560
wake me up in one millisecond or

00:05:47,120 --> 00:05:50,880
something like that

00:05:48,560 --> 00:05:52,639
but in the kernel sometimes drivers

00:05:50,880 --> 00:05:53,440
might do something like end delay or m

00:05:52,639 --> 00:05:55,840
delay

00:05:53,440 --> 00:05:57,520
or even cpu relax so we also need weight

00:05:55,840 --> 00:05:59,120
just a little without scheduling

00:05:57,520 --> 00:06:00,960
if we're not scheduling we just need to

00:05:59,120 --> 00:06:02,720
wait a little bit of time

00:06:00,960 --> 00:06:04,000
significantly less than the scheduler

00:06:02,720 --> 00:06:05,840
tick which is

00:06:04,000 --> 00:06:08,800
10 milliseconds with contracts equals

00:06:05,840 --> 00:06:10,880
100 but here it might just be

00:06:08,800 --> 00:06:12,479
wait a couple of nanoseconds and then

00:06:10,880 --> 00:06:14,479
most importantly for the whole time

00:06:12,479 --> 00:06:17,039
travel is when there's nothing to do

00:06:14,479 --> 00:06:19,440
right arc cpu idle that's where we get

00:06:17,039 --> 00:06:22,160
when the system has nothing to do

00:06:19,440 --> 00:06:23,039
so how do we do all these four first

00:06:22,160 --> 00:06:25,039
what time is it

00:06:23,039 --> 00:06:26,240
normally in user mode linux this just

00:06:25,039 --> 00:06:28,800
asks the host

00:06:26,240 --> 00:06:29,759
it says clock get time what time is it

00:06:28,800 --> 00:06:32,000
for the host

00:06:29,759 --> 00:06:34,000
and that's it in time travel mode it's

00:06:32,000 --> 00:06:36,160
even simpler we just read the current

00:06:34,000 --> 00:06:38,160
internal time it's the u64 that's

00:06:36,160 --> 00:06:40,479
tracking the current time in

00:06:38,160 --> 00:06:41,280
nanoseconds and that's it we have to

00:06:40,479 --> 00:06:43,280
make this

00:06:41,280 --> 00:06:45,120
cost a little bit of time just the act

00:06:43,280 --> 00:06:46,960
of asking the question what time is it

00:06:45,120 --> 00:06:49,680
has to cost a little bit of time

00:06:46,960 --> 00:06:51,759
because of boundary conditions in in

00:06:49,680 --> 00:06:56,400
some user space applications

00:06:51,759 --> 00:06:56,400
but that's just a little caveat there

00:06:56,479 --> 00:07:00,160
please wake me in normally and use

00:06:58,960 --> 00:07:02,880
remote linux

00:07:00,160 --> 00:07:04,400
this just does timer set time so then

00:07:02,880 --> 00:07:06,400
when the timer expires

00:07:04,400 --> 00:07:07,840
you will get a signal the process will

00:07:06,400 --> 00:07:10,479
be interrupted and you will know

00:07:07,840 --> 00:07:13,120
to trigger this as an interrupt into the

00:07:10,479 --> 00:07:14,800
linux system that's being simulated

00:07:13,120 --> 00:07:17,120
in time travel mode we really don't have

00:07:14,800 --> 00:07:21,120
to do anything except remember

00:07:17,120 --> 00:07:21,120
when that wake up should actually be

00:07:22,080 --> 00:07:27,360
waiting a little bit normally in user

00:07:24,800 --> 00:07:29,680
mode linux has no special implementation

00:07:27,360 --> 00:07:32,560
we just delay for the normal loops per

00:07:29,680 --> 00:07:34,560
jiffy that's calculated at system boot

00:07:32,560 --> 00:07:36,639
um and so if you want to delay 1

00:07:34,560 --> 00:07:38,560
nanoseconds with an end delay it will

00:07:36,639 --> 00:07:40,479
calculate how many loops it has to take

00:07:38,560 --> 00:07:42,400
and do these this many loops

00:07:40,479 --> 00:07:44,240
or if you have cpu relax it might be a

00:07:42,400 --> 00:07:46,240
knob or something like that

00:07:44,240 --> 00:07:48,720
in time travel mode we can't work that

00:07:46,240 --> 00:07:51,680
way because time doesn't change

00:07:48,720 --> 00:07:51,919
when we're just spinning on the cpu this

00:07:51,680 --> 00:07:53,840
is

00:07:51,919 --> 00:07:55,520
simulating an infinite cpu speed so

00:07:53,840 --> 00:07:57,120
whatever loops per jiffy or something

00:07:55,520 --> 00:07:58,960
that we're doing however many loops

00:07:57,120 --> 00:08:01,199
we're doing is taking zero time

00:07:58,960 --> 00:08:03,039
so here in time travel mode this must

00:08:01,199 --> 00:08:04,319
actually move time by an appropriate

00:08:03,039 --> 00:08:06,000
number of nanoseconds

00:08:04,319 --> 00:08:07,759
for end delay that's pretty simple m

00:08:06,000 --> 00:08:08,879
delay also we can calculate how many

00:08:07,759 --> 00:08:11,199
nanoseconds

00:08:08,879 --> 00:08:14,639
and right now for cpu relax that just

00:08:11,199 --> 00:08:16,800
takes always one nanosecond

00:08:14,639 --> 00:08:18,639
and finally the most important thing

00:08:16,800 --> 00:08:20,879
when there's nothing to do

00:08:18,639 --> 00:08:22,479
normally user mode linux will just sleep

00:08:20,879 --> 00:08:25,039
for one second

00:08:22,479 --> 00:08:26,400
so then that never actually happens

00:08:25,039 --> 00:08:28,160
because it will be interrupted by the

00:08:26,400 --> 00:08:31,599
timer that it was

00:08:28,160 --> 00:08:34,479
armed before when the

00:08:31,599 --> 00:08:34,959
clocks clock event source requested it

00:08:34,479 --> 00:08:37,680
um

00:08:34,959 --> 00:08:39,599
this doesn't happen in time travel mode

00:08:37,680 --> 00:08:40,640
in time travel mode we also sleep for up

00:08:39,599 --> 00:08:42,240
to a second

00:08:40,640 --> 00:08:44,080
but only in the sense that we move the

00:08:42,240 --> 00:08:46,399
clock forward by

00:08:44,080 --> 00:08:48,160
either one second or the next wake up

00:08:46,399 --> 00:08:48,720
time again the one second doesn't really

00:08:48,160 --> 00:08:50,240
happen

00:08:48,720 --> 00:08:52,399
because there's always a next wake up

00:08:50,240 --> 00:08:54,800
time for the internal

00:08:52,399 --> 00:08:56,399
tick for for linux and then it will

00:08:54,800 --> 00:08:58,160
trigger the timer interrupt

00:08:56,399 --> 00:09:00,000
so usually this is with config hertz

00:08:58,160 --> 00:09:01,680
equals 100 this would be

00:09:00,000 --> 00:09:03,519
every 10 milliseconds so you would go

00:09:01,680 --> 00:09:04,560
into idle move time forward by 10

00:09:03,519 --> 00:09:06,480
milliseconds

00:09:04,560 --> 00:09:08,560
break out trigger the time interrupt go

00:09:06,480 --> 00:09:10,160
back into the scheduler maybe figure out

00:09:08,560 --> 00:09:12,640
that there's nothing to do and go back

00:09:10,160 --> 00:09:14,399
into the loop again

00:09:12,640 --> 00:09:15,920
so this is the four things that we need

00:09:14,399 --> 00:09:18,399
for like the

00:09:15,920 --> 00:09:19,760
basic time travel mode what can we do

00:09:18,399 --> 00:09:21,760
with that

00:09:19,760 --> 00:09:24,560
so really we can do it without only a

00:09:21,760 --> 00:09:26,320
single machine but we can speed up tests

00:09:24,560 --> 00:09:28,480
this is very useful we've had it for

00:09:26,320 --> 00:09:30,320
quite a while and

00:09:28,480 --> 00:09:32,000
we've converted the supplicant tests

00:09:30,320 --> 00:09:33,680
upstream to use it and it gives them

00:09:32,000 --> 00:09:34,560
more than six times speed up for the

00:09:33,680 --> 00:09:36,080
tests

00:09:34,560 --> 00:09:38,480
like i mentioned before there's an

00:09:36,080 --> 00:09:40,880
example of the dfs tests where

00:09:38,480 --> 00:09:42,399
there's 120 seconds to two minutes where

00:09:40,880 --> 00:09:44,320
we have to wait for an event

00:09:42,399 --> 00:09:45,920
just by regulatory reasons and we don't

00:09:44,320 --> 00:09:46,640
want to just hack out that code for

00:09:45,920 --> 00:09:48,640
testing

00:09:46,640 --> 00:09:50,800
so we wait for two minutes for an event

00:09:48,640 --> 00:09:52,959
that can never happen in simulation

00:09:50,800 --> 00:09:54,160
but here that doesn't take nearly that

00:09:52,959 --> 00:09:55,600
long because all we're doing is

00:09:54,160 --> 00:09:58,480
simulating waiting for

00:09:55,600 --> 00:10:00,160
two minutes and so that just wakes up

00:09:58,480 --> 00:10:00,560
every 10 milliseconds for those two

00:10:00,160 --> 00:10:02,240
minutes

00:10:00,560 --> 00:10:05,440
sees that there's nothing to do and goes

00:10:02,240 --> 00:10:08,320
back to the next 10 milliseconds

00:10:05,440 --> 00:10:10,000
or another thing that used to be very

00:10:08,320 --> 00:10:11,760
problematic in the supplicant test

00:10:10,000 --> 00:10:13,360
if you enabled all the kernel debug

00:10:11,760 --> 00:10:15,200
options it would cause user space to

00:10:13,360 --> 00:10:16,480
eventually time out if your cpu isn't

00:10:15,200 --> 00:10:18,880
fast enough

00:10:16,480 --> 00:10:20,800
now with in simulating infinite cpu

00:10:18,880 --> 00:10:22,079
speed we don't care we can enable

00:10:20,800 --> 00:10:25,120
whatever we want

00:10:22,079 --> 00:10:27,040
we can debug and trace whatever we want

00:10:25,120 --> 00:10:29,680
it's not really taking any time as far

00:10:27,040 --> 00:10:31,200
as the the supplicant and the

00:10:29,680 --> 00:10:33,440
other programs running inside of the

00:10:31,200 --> 00:10:36,800
simulation are concerned

00:10:33,440 --> 00:10:38,640
so also that means it's disconnected

00:10:36,800 --> 00:10:40,079
from real time and we can oversubscribe

00:10:38,640 --> 00:10:41,920
the cpus if something else

00:10:40,079 --> 00:10:44,079
starts up on this system that we're

00:10:41,920 --> 00:10:45,600
running the test on

00:10:44,079 --> 00:10:47,600
while we're running the test we don't

00:10:45,600 --> 00:10:48,079
really need to care before it used to be

00:10:47,600 --> 00:10:49,680
that

00:10:48,079 --> 00:10:51,440
you can only load the system to a

00:10:49,680 --> 00:10:54,000
certain extent until

00:10:51,440 --> 00:10:55,839
tests are timing out so very useful but

00:10:54,000 --> 00:10:58,480
also kind of limited and of course we

00:10:55,839 --> 00:11:00,079
want more

00:10:58,480 --> 00:11:02,240
so the first thing that we want is

00:11:00,079 --> 00:11:03,920
multiple machines

00:11:02,240 --> 00:11:05,760
for multiple machines we have to make

00:11:03,920 --> 00:11:07,600
some modifications

00:11:05,760 --> 00:11:09,440
we have to do some cooperative

00:11:07,600 --> 00:11:11,200
scheduling between the instances and we

00:11:09,440 --> 00:11:14,079
created a simple protocol

00:11:11,200 --> 00:11:15,920
that's declared in um time travel that

00:11:14,079 --> 00:11:17,279
where one machine can request runtime

00:11:15,920 --> 00:11:19,040
wait for its turn

00:11:17,279 --> 00:11:20,560
get the current time update the current

00:11:19,040 --> 00:11:22,800
time if necessary

00:11:20,560 --> 00:11:24,320
and get a signal that it's able to run

00:11:22,800 --> 00:11:25,600
when it's being when it when it has

00:11:24,320 --> 00:11:27,360
waited for its turn

00:11:25,600 --> 00:11:29,120
it will get the signal to run and

00:11:27,360 --> 00:11:30,959
there's an optimization there if no one

00:11:29,120 --> 00:11:31,839
has anything to do there's a free until

00:11:30,959 --> 00:11:35,200
where you can

00:11:31,839 --> 00:11:37,600
run without communication for some time

00:11:35,200 --> 00:11:39,920
and this plugs into all of the four

00:11:37,600 --> 00:11:42,000
areas that i mentioned before

00:11:39,920 --> 00:11:43,120
and now when we get to idle or some kind

00:11:42,000 --> 00:11:45,760
of delay

00:11:43,120 --> 00:11:46,560
we basically don't just skip time

00:11:45,760 --> 00:11:48,480
forward or

00:11:46,560 --> 00:11:50,560
to the next event that we had we

00:11:48,480 --> 00:11:52,720
actually have to ask

00:11:50,560 --> 00:11:53,920
the controller so we have to ask the

00:11:52,720 --> 00:11:57,440
controller

00:11:53,920 --> 00:11:58,800
what what we can do or we have to ask

00:11:57,440 --> 00:12:00,079
the controller what we want to do

00:11:58,800 --> 00:12:02,000
basically

00:12:00,079 --> 00:12:03,600
and then we wait until it's our turn and

00:12:02,000 --> 00:12:06,000
then when we're told to run we run

00:12:03,600 --> 00:12:08,000
until completion when we get back to the

00:12:06,000 --> 00:12:10,880
next delay or the next idle and then

00:12:08,000 --> 00:12:11,680
we repeat the whole thing over and over

00:12:10,880 --> 00:12:13,920
so for this

00:12:11,680 --> 00:12:14,720
we need a controller application which

00:12:13,920 --> 00:12:18,959
basically

00:12:14,720 --> 00:12:20,880
contains only really a kind of calendar

00:12:18,959 --> 00:12:22,959
that keeps track of each participant's

00:12:20,880 --> 00:12:25,120
next event so everyone requests some

00:12:22,959 --> 00:12:26,720
time when it once when they want to run

00:12:25,120 --> 00:12:28,320
and the controller keeps track of which

00:12:26,720 --> 00:12:29,360
one is next and which one should be

00:12:28,320 --> 00:12:31,279
running

00:12:29,360 --> 00:12:32,959
and then then when one of them goes to

00:12:31,279 --> 00:12:34,720
wait state

00:12:32,959 --> 00:12:36,320
the one that's next will be notified

00:12:34,720 --> 00:12:38,000
that it's able to run

00:12:36,320 --> 00:12:39,839
the controller also has to distribute

00:12:38,000 --> 00:12:41,360
the time updates because if one of them

00:12:39,839 --> 00:12:44,160
ran

00:12:41,360 --> 00:12:44,560
then time would have moved a little bit

00:12:44,160 --> 00:12:46,639
um

00:12:44,560 --> 00:12:48,480
and then when the next one runs it has

00:12:46,639 --> 00:12:50,320
to be told what time it is now

00:12:48,480 --> 00:12:52,160
i'm working to release all of this as

00:12:50,320 --> 00:12:54,160
open source including the device

00:12:52,160 --> 00:12:57,360
simulation that i will talk about

00:12:54,160 --> 00:13:00,639
but it's not been released yet

00:12:57,360 --> 00:13:02,720
so now if we have multiple machines

00:13:00,639 --> 00:13:04,480
that's nice but it's not very useful

00:13:02,720 --> 00:13:05,760
because for multiple machines to be

00:13:04,480 --> 00:13:08,240
useful they have to be able to

00:13:05,760 --> 00:13:11,360
communicate with each other somehow

00:13:08,240 --> 00:13:14,079
so we need devices

00:13:11,360 --> 00:13:14,800
and devices are sort of conceptually

00:13:14,079 --> 00:13:16,240
simple

00:13:14,800 --> 00:13:18,079
they really just need to communicate

00:13:16,240 --> 00:13:18,959
with the time controller but we just had

00:13:18,079 --> 00:13:21,440
a protocol

00:13:18,959 --> 00:13:23,040
where they can we just created a

00:13:21,440 --> 00:13:24,720
protocol where they can they can just

00:13:23,040 --> 00:13:25,760
behave just like a virtual machine and a

00:13:24,720 --> 00:13:28,160
request run time

00:13:25,760 --> 00:13:29,760
wait for their turn to run and then they

00:13:28,160 --> 00:13:31,360
get a signal to run and then they run

00:13:29,760 --> 00:13:33,120
for some time etc

00:13:31,360 --> 00:13:35,200
so that part is simple and they need to

00:13:33,120 --> 00:13:37,279
communicate with the device driver

00:13:35,200 --> 00:13:39,199
normally a device might communicate with

00:13:37,279 --> 00:13:42,399
the device driver using

00:13:39,199 --> 00:13:43,360
pci express or usb or something but of

00:13:42,399 --> 00:13:45,199
course here

00:13:43,360 --> 00:13:46,839
we don't have that in user mode linux

00:13:45,199 --> 00:13:48,800
there are in fact none of these are

00:13:46,839 --> 00:13:52,320
implemented

00:13:48,800 --> 00:13:54,560
so but for virtualization we already

00:13:52,320 --> 00:13:57,360
have standards right so we have

00:13:54,560 --> 00:13:59,440
virtio we have v host user that extends

00:13:57,360 --> 00:14:01,760
that out so virtio is very useful

00:13:59,440 --> 00:14:03,279
for virtualization it's a standard model

00:14:01,760 --> 00:14:05,600
it has existing drivers

00:14:03,279 --> 00:14:06,959
existing infrastructure basically all we

00:14:05,600 --> 00:14:08,639
want

00:14:06,959 --> 00:14:10,399
but then we need to implement the device

00:14:08,639 --> 00:14:11,920
in the hypervisor and here in user mode

00:14:10,399 --> 00:14:14,399
linux the hypervisor

00:14:11,920 --> 00:14:16,000
is basically the same as linux so we

00:14:14,399 --> 00:14:18,480
would have to link our application

00:14:16,000 --> 00:14:19,120
our device application against linux if

00:14:18,480 --> 00:14:22,880
it's just

00:14:19,120 --> 00:14:25,199
raw just simple word io but qmu

00:14:22,880 --> 00:14:26,959
designed a vhost user protocol that

00:14:25,199 --> 00:14:28,639
pulls the device implementation out of

00:14:26,959 --> 00:14:31,760
the hypervisor

00:14:28,639 --> 00:14:33,519
and so we can use this protocol to pull

00:14:31,760 --> 00:14:35,519
out our device implementation

00:14:33,519 --> 00:14:37,040
out of the hypervisor and the linux just

00:14:35,519 --> 00:14:37,680
makes the linux instance that we're

00:14:37,040 --> 00:14:39,519
running

00:14:37,680 --> 00:14:41,440
user mode linux just makes a connection

00:14:39,519 --> 00:14:43,760
to the device over the unix domain

00:14:41,440 --> 00:14:45,760
socket that this protocol uses

00:14:43,760 --> 00:14:47,120
so we implemented vo's user support in

00:14:45,760 --> 00:14:51,199
user mode linux

00:14:47,120 --> 00:14:51,199
and then feels like we should be done

00:14:52,880 --> 00:14:56,639
but it's not really that simple because

00:14:54,880 --> 00:14:59,760
we're trying to simulate

00:14:56,639 --> 00:15:01,360
and in a normal v host user model let's

00:14:59,760 --> 00:15:02,079
say we want to transmit the network

00:15:01,360 --> 00:15:04,160
frame

00:15:02,079 --> 00:15:06,240
the host will put a frame on the vert

00:15:04,160 --> 00:15:07,920
queue the host will then notify the

00:15:06,240 --> 00:15:09,120
device that there is something on the

00:15:07,920 --> 00:15:11,680
vert queue using

00:15:09,120 --> 00:15:13,279
an event ft and then the device will get

00:15:11,680 --> 00:15:15,920
the signal and handle the frame

00:15:13,279 --> 00:15:16,880
very simple but if we look at it in the

00:15:15,920 --> 00:15:19,040
simulation

00:15:16,880 --> 00:15:19,920
it starts to break down because we are

00:15:19,040 --> 00:15:22,560
not actually

00:15:19,920 --> 00:15:23,440
running both of the applications in

00:15:22,560 --> 00:15:25,120
parallel

00:15:23,440 --> 00:15:26,639
both of the applications are connected

00:15:25,120 --> 00:15:28,560
to the time controller

00:15:26,639 --> 00:15:30,639
and they have to request runtime and get

00:15:28,560 --> 00:15:33,440
their runtime share etc

00:15:30,639 --> 00:15:35,759
so what we have to do in this model for

00:15:33,440 --> 00:15:36,240
the virtio for the vios user protocol is

00:15:35,759 --> 00:15:37,839
that

00:15:36,240 --> 00:15:39,600
the host again it puts the frame in the

00:15:37,839 --> 00:15:42,720
vert q as it used to be

00:15:39,600 --> 00:15:43,279
but then the host notifies the device

00:15:42,720 --> 00:15:45,839
using an

00:15:43,279 --> 00:15:47,360
inband signal if we use an out-of-band

00:15:45,839 --> 00:15:48,959
signal

00:15:47,360 --> 00:15:50,399
then we don't have any feedback of when

00:15:48,959 --> 00:15:52,000
that signal is processed

00:15:50,399 --> 00:15:53,519
and here we need so we need an invent

00:15:52,000 --> 00:15:55,440
signal here because then

00:15:53,519 --> 00:15:57,440
the device needs to ask the controller

00:15:55,440 --> 00:15:58,079
for time to run so maybe it wants to

00:15:57,440 --> 00:16:01,199
simulate

00:15:58,079 --> 00:16:03,199
a 10 nanosecond interrupt latency

00:16:01,199 --> 00:16:05,040
so it would ask for 10 nanoseconds in

00:16:03,199 --> 00:16:07,360
the future i want to run

00:16:05,040 --> 00:16:09,360
so that i can process the interrupt the

00:16:07,360 --> 00:16:10,639
controller will

00:16:09,360 --> 00:16:12,320
then actually talk to some other

00:16:10,639 --> 00:16:13,759
participants in the simulation it might

00:16:12,320 --> 00:16:14,639
have to update them it might have to do

00:16:13,759 --> 00:16:17,040
some other things

00:16:14,639 --> 00:16:18,560
but it will eventually put that event 10

00:16:17,040 --> 00:16:20,560
nanoseconds in the future

00:16:18,560 --> 00:16:22,399
onto the calendar that it maintains for

00:16:20,560 --> 00:16:24,079
the device then it will return back to

00:16:22,399 --> 00:16:25,759
the device and say yes you've got that

00:16:24,079 --> 00:16:27,360
slot on the calendar

00:16:25,759 --> 00:16:29,040
then the device will return back to the

00:16:27,360 --> 00:16:29,839
host send an acknowledgement back to the

00:16:29,040 --> 00:16:33,600
host

00:16:29,839 --> 00:16:36,320
using the vios user reply arc extension

00:16:33,600 --> 00:16:38,160
so that the host knows okay now the

00:16:36,320 --> 00:16:39,839
device knows that it needs to run and

00:16:38,160 --> 00:16:41,199
it's requested runtime now the host can

00:16:39,839 --> 00:16:43,600
continue running

00:16:41,199 --> 00:16:44,880
until it gets to some kind of idle state

00:16:43,600 --> 00:16:47,120
or delay state

00:16:44,880 --> 00:16:48,959
or whatever it needs to do maybe it

00:16:47,120 --> 00:16:50,800
needs to send another packet to the

00:16:48,959 --> 00:16:52,399
device until the queue is full or

00:16:50,800 --> 00:16:53,680
something so it will continue running

00:16:52,399 --> 00:16:55,279
and this may happen again

00:16:53,680 --> 00:16:56,800
but eventually the host will hit some

00:16:55,279 --> 00:16:58,800
kind of idle state

00:16:56,800 --> 00:17:00,639
and will tell the controller that it's

00:16:58,800 --> 00:17:01,440
finished running will wait for its next

00:17:00,639 --> 00:17:02,800
turn

00:17:01,440 --> 00:17:04,640
but now the controller instead of

00:17:02,800 --> 00:17:05,679
telling the host the virtual machine

00:17:04,640 --> 00:17:07,760
that it can run

00:17:05,679 --> 00:17:09,679
will presumably tell the device to run

00:17:07,760 --> 00:17:10,959
so that now the device can finally

00:17:09,679 --> 00:17:13,039
handle the frame

00:17:10,959 --> 00:17:14,160
and handling the frame will usually

00:17:13,039 --> 00:17:16,880
incur some other

00:17:14,160 --> 00:17:18,480
logic it might simulate some network

00:17:16,880 --> 00:17:20,079
latency

00:17:18,480 --> 00:17:22,959
and so request more runtime from the

00:17:20,079 --> 00:17:27,360
controller in the future to actually

00:17:22,959 --> 00:17:30,559
send the frame out to the recipients etc

00:17:27,360 --> 00:17:33,039
this is very feels very complex but

00:17:30,559 --> 00:17:34,480
luckily it's all handled by the virtio

00:17:33,039 --> 00:17:37,039
code that we put into

00:17:34,480 --> 00:17:38,720
user remote linux that connects out over

00:17:37,039 --> 00:17:41,520
the vios user protocol

00:17:38,720 --> 00:17:43,440
and on the device side this part where

00:17:41,520 --> 00:17:44,000
you get the signal but you don't really

00:17:43,440 --> 00:17:46,000
run

00:17:44,000 --> 00:17:47,520
the interrupt until you get time from

00:17:46,000 --> 00:17:50,400
the controller etc

00:17:47,520 --> 00:17:51,679
is all encapsulated in the used user

00:17:50,400 --> 00:17:54,160
library code

00:17:51,679 --> 00:17:57,039
that's part of the framework that we're

00:17:54,160 --> 00:17:57,039
planning to release

00:17:57,360 --> 00:18:01,919
so let's do something with it right

00:17:59,760 --> 00:18:05,840
we've that was theory

00:18:01,919 --> 00:18:07,280
for a wireless device we used to already

00:18:05,840 --> 00:18:08,720
have hardware sim

00:18:07,280 --> 00:18:10,640
where on a single machine you can

00:18:08,720 --> 00:18:12,720
simulate mini radios and this is what

00:18:10,640 --> 00:18:14,160
the supplicant uses for the tests that i

00:18:12,720 --> 00:18:16,320
mentioned before

00:18:14,160 --> 00:18:18,080
the supplicant will simulate any number

00:18:16,320 --> 00:18:19,919
of radios that it needs for its test

00:18:18,080 --> 00:18:21,360
inside a single virtual machine and they

00:18:19,919 --> 00:18:23,679
will communicate

00:18:21,360 --> 00:18:24,480
we also used to already have w medium d

00:18:23,679 --> 00:18:27,120
which is running

00:18:24,480 --> 00:18:28,000
inside of that same virtual machine or

00:18:27,120 --> 00:18:31,600
the same system

00:18:28,000 --> 00:18:34,559
as the hardware sim to simulate the

00:18:31,600 --> 00:18:34,559
network in a more

00:18:34,799 --> 00:18:38,960
in a more capable way so w medium d can

00:18:37,679 --> 00:18:42,240
simulate other things that

00:18:38,960 --> 00:18:44,480
hardware sim by itself cannot simulate

00:18:42,240 --> 00:18:45,520
path laws or things that happen in the

00:18:44,480 --> 00:18:48,720
wireless medium

00:18:45,520 --> 00:18:50,240
can be simulated with wbdmd so now we

00:18:48,720 --> 00:18:53,840
want to pull w medium d

00:18:50,240 --> 00:18:55,360
which is sitting inside the same virtual

00:18:53,840 --> 00:18:57,120
machine

00:18:55,360 --> 00:18:59,440
as hardware sim we want to pull it out

00:18:57,120 --> 00:19:02,240
to be to sit side by side as another

00:18:59,440 --> 00:19:05,919
application so that multiple instances

00:19:02,240 --> 00:19:09,200
of hardware sim can connect to

00:19:05,919 --> 00:19:12,640
the same w medium d with from multiple

00:19:09,200 --> 00:19:14,880
vms so we extended that protocol that

00:19:12,640 --> 00:19:16,080
hardware sim already has it's a net link

00:19:14,880 --> 00:19:17,840
based protocol

00:19:16,080 --> 00:19:19,760
we basically just extended that to be

00:19:17,840 --> 00:19:21,840
transported over vert io

00:19:19,760 --> 00:19:22,799
instead of over net link inside the

00:19:21,840 --> 00:19:24,559
machine so now

00:19:22,799 --> 00:19:26,400
instead of being inside the machine in

00:19:24,559 --> 00:19:28,000
that link it's going outside of the

00:19:26,400 --> 00:19:30,080
machine over vertio

00:19:28,000 --> 00:19:32,480
and then w medium d just has to be the

00:19:30,080 --> 00:19:34,160
device implementation for this protocol

00:19:32,480 --> 00:19:36,160
but it already knows the protocol so

00:19:34,160 --> 00:19:39,679
it's really just a different transport

00:19:36,160 --> 00:19:42,320
that it has to know about and so then

00:19:39,679 --> 00:19:44,000
it has to have it creates a device for

00:19:42,320 --> 00:19:44,400
every socket connection that you make to

00:19:44,000 --> 00:19:46,400
it

00:19:44,400 --> 00:19:47,440
and those devices plug into the existing

00:19:46,400 --> 00:19:50,559
system of

00:19:47,440 --> 00:19:53,440
frame forwarding etc all of w medium d

00:19:50,559 --> 00:19:55,360
was ported to this framework and all of

00:19:53,440 --> 00:19:57,200
this is also already upstream

00:19:55,360 --> 00:19:58,880
but the controller application wasn't

00:19:57,200 --> 00:20:01,039
part here

00:19:58,880 --> 00:20:02,159
so now with that we can actually

00:20:01,039 --> 00:20:05,840
simulate

00:20:02,159 --> 00:20:09,280
multiple devices multiple instances

00:20:05,840 --> 00:20:11,919
multiple hosts multiple virtual machines

00:20:09,280 --> 00:20:13,280
each with a radio talking to each other

00:20:11,919 --> 00:20:16,000
over a w medium d

00:20:13,280 --> 00:20:16,480
that's running separately so now we can

00:20:16,000 --> 00:20:18,799
have

00:20:16,480 --> 00:20:20,000
really have multiple instances of linux

00:20:18,799 --> 00:20:21,679
rather than just everything

00:20:20,000 --> 00:20:23,679
having having everything in a single

00:20:21,679 --> 00:20:26,240
instance of linux

00:20:23,679 --> 00:20:28,480
so let's see how that works in the demo

00:20:26,240 --> 00:20:31,280
i have a script

00:20:28,480 --> 00:20:33,280
that starts four things we'll start the

00:20:31,280 --> 00:20:34,320
time controller which includes a very

00:20:33,280 --> 00:20:38,480
simple virdio

00:20:34,320 --> 00:20:41,360
ethernet device switch

00:20:38,480 --> 00:20:43,200
the it starts w medium d offering

00:20:41,360 --> 00:20:44,720
hardware's inverted io devices and of

00:20:43,200 --> 00:20:47,760
course connecting them on

00:20:44,720 --> 00:20:49,679
a virtual air together and it runs two

00:20:47,760 --> 00:20:50,720
instances of linux one goes into the

00:20:49,679 --> 00:20:53,600
background and one

00:20:50,720 --> 00:20:54,880
that we can see on the first machine

00:20:53,600 --> 00:20:58,480
that we can see it will run

00:20:54,880 --> 00:21:02,480
then run a script that sets up an ad hoc

00:20:58,480 --> 00:21:04,799
or ibss network connects using ssh to

00:21:02,480 --> 00:21:06,320
the second machine to also set it up

00:21:04,799 --> 00:21:07,919
and when they're connected it will ping

00:21:06,320 --> 00:21:10,080
from the first to the second machine

00:21:07,919 --> 00:21:10,960
over the simulated wireless that goes to

00:21:10,080 --> 00:21:14,320
w medium d

00:21:10,960 --> 00:21:16,720
etc to show

00:21:14,320 --> 00:21:18,400
to show that around the whole script i'm

00:21:16,720 --> 00:21:21,520
running ts

00:21:18,400 --> 00:21:23,840
to show how much time elapsed and inside

00:21:21,520 --> 00:21:26,640
on the ping it will also run

00:21:23,840 --> 00:21:28,320
ts from the script to show how much time

00:21:26,640 --> 00:21:29,440
elapsed there because i'm pinging once

00:21:28,320 --> 00:21:31,919
every minute

00:21:29,440 --> 00:21:33,919
and on the outside i'm i can see how

00:21:31,919 --> 00:21:38,960
much faster it goes

00:21:33,919 --> 00:21:38,960
so let's run it it's starting up

00:21:39,039 --> 00:21:43,280
and now it's connecting and now it's

00:21:41,280 --> 00:21:45,200
already pinging

00:21:43,280 --> 00:21:47,360
so you can see inside it's pinging once

00:21:45,200 --> 00:21:49,200
every minute

00:21:47,360 --> 00:21:50,480
and outside it takes about one second

00:21:49,200 --> 00:21:52,960
for every ping the

00:21:50,480 --> 00:21:54,720
reason it takes one second to simulate

00:21:52,960 --> 00:21:56,640
one minute is that

00:21:54,720 --> 00:21:58,559
you have two machines and both machines

00:21:56,640 --> 00:22:00,320
aren't really idle we still need to wake

00:21:58,559 --> 00:22:01,919
up for the linux kernel tick these are

00:22:00,320 --> 00:22:04,640
configured to config

00:22:01,919 --> 00:22:06,640
hertz equals 100 and synchronize that

00:22:04,640 --> 00:22:09,280
across the machines

00:22:06,640 --> 00:22:11,280
and go you know only one of them is

00:22:09,280 --> 00:22:13,840
running at a time because of the time

00:22:11,280 --> 00:22:15,360
simulation and so it takes some time if

00:22:13,840 --> 00:22:17,360
you add more machines it goes

00:22:15,360 --> 00:22:19,520
significantly slower

00:22:17,360 --> 00:22:21,440
but with a few machines it's reasonable

00:22:19,520 --> 00:22:24,080
and you can see that it's

00:22:21,440 --> 00:22:24,960
simulating one minute pretty much every

00:22:24,080 --> 00:22:29,200
one second

00:22:24,960 --> 00:22:30,720
maybe a little less and

00:22:29,200 --> 00:22:32,880
of course if you have a lot of network

00:22:30,720 --> 00:22:34,640
traffic then simulation will be a lot

00:22:32,880 --> 00:22:36,080
slower because the network traffic also

00:22:34,640 --> 00:22:39,120
has to go hit

00:22:36,080 --> 00:22:40,480
the time simulation all the time so

00:22:39,120 --> 00:22:43,679
that's the

00:22:40,480 --> 00:22:45,679
easy demo um i don't have a demo for

00:22:43,679 --> 00:22:48,400
any other devices but here we already

00:22:45,679 --> 00:22:50,240
showed we already saw

00:22:48,400 --> 00:22:51,760
an ethernet device which was kind of in

00:22:50,240 --> 00:22:53,360
the background with the ssh that

00:22:51,760 --> 00:22:56,640
controlled it and the

00:22:53,360 --> 00:22:59,679
wireless device the devices that we

00:22:56,640 --> 00:23:03,039
that we did the ping on so let's

00:22:59,679 --> 00:23:05,039
summarize what we've done with just raw

00:23:03,039 --> 00:23:07,280
time travel mode we can disconnect real

00:23:05,039 --> 00:23:10,080
time from simulated time

00:23:07,280 --> 00:23:10,799
and so we can run faster or slower than

00:23:10,080 --> 00:23:14,159
real time

00:23:10,799 --> 00:23:16,640
our simulation might be cpu bound but

00:23:14,159 --> 00:23:18,480
we will always be cpu bound really but

00:23:16,640 --> 00:23:20,480
depending on the simulation complexity

00:23:18,480 --> 00:23:21,440
we can be faster or slower than real

00:23:20,480 --> 00:23:23,840
time

00:23:21,440 --> 00:23:26,400
this for a single machine we already use

00:23:23,840 --> 00:23:28,159
for testing host apd and supplicant

00:23:26,400 --> 00:23:29,760
and it's great because it makes things a

00:23:28,159 --> 00:23:31,679
lot faster

00:23:29,760 --> 00:23:33,840
now if we want to extend this to be able

00:23:31,679 --> 00:23:35,039
to simulate networks or multiple

00:23:33,840 --> 00:23:38,400
machines or

00:23:35,039 --> 00:23:40,480
some other things then we have this

00:23:38,400 --> 00:23:42,159
um time travel protocol and the

00:23:40,480 --> 00:23:45,120
controller application

00:23:42,159 --> 00:23:47,200
to be able to do that but if we don't

00:23:45,120 --> 00:23:50,240
have any devices that's not very useful

00:23:47,200 --> 00:23:52,720
so we extended the vios user protocol

00:23:50,240 --> 00:23:55,039
with the in-band signaling extension

00:23:52,720 --> 00:23:55,919
and also use the replyac protocol

00:23:55,039 --> 00:23:58,880
extension

00:23:55,919 --> 00:24:00,960
to be able to simulate devices within

00:23:58,880 --> 00:24:03,120
the time simulation

00:24:00,960 --> 00:24:04,880
and that we already have for ethernet

00:24:03,120 --> 00:24:05,840
very simple as part of the controller

00:24:04,880 --> 00:24:08,159
application

00:24:05,840 --> 00:24:09,440
because we need to have a virtual kind

00:24:08,159 --> 00:24:11,840
of lab network

00:24:09,440 --> 00:24:13,440
where you have the ability to connect

00:24:11,840 --> 00:24:15,600
between the different machines

00:24:13,440 --> 00:24:18,240
before wi-fi is brought up and we did it

00:24:15,600 --> 00:24:21,200
for wi-fi and w medium d

00:24:18,240 --> 00:24:24,159
so that we have the ability to simulate

00:24:21,200 --> 00:24:26,480
wireless networks with multiple machines

00:24:24,159 --> 00:24:29,120
and at intel we also use this already

00:24:26,480 --> 00:24:31,360
for real firmware testing so we've

00:24:29,120 --> 00:24:33,520
compiled the real firmware in a way that

00:24:31,360 --> 00:24:34,480
it can use virtio we've added virtio to

00:24:33,520 --> 00:24:36,799
our driver

00:24:34,480 --> 00:24:37,840
and so that it can communicate with all

00:24:36,799 --> 00:24:39,440
these pieces

00:24:37,840 --> 00:24:41,520
so the firmware can also communicate

00:24:39,440 --> 00:24:43,360
with hardware sim and we can test

00:24:41,520 --> 00:24:46,400
hardware zoom being the access point for

00:24:43,360 --> 00:24:48,720
instance connecting to w medium d

00:24:46,400 --> 00:24:49,679
and then our firmware also connecting to

00:24:48,720 --> 00:24:52,000
w medium d

00:24:49,679 --> 00:24:53,360
and this separate user mode linux

00:24:52,000 --> 00:24:55,679
instance

00:24:53,360 --> 00:24:57,760
with our real driver running there

00:24:55,679 --> 00:25:00,640
driving the firmware api

00:24:57,760 --> 00:25:02,880
and doing testing like that again this

00:25:00,640 --> 00:25:04,320
might be slower or faster than real time

00:25:02,880 --> 00:25:06,320
depending on what we do

00:25:04,320 --> 00:25:08,000
you saw in the demo we saw that it can

00:25:06,320 --> 00:25:09,200
be a lot faster than real time if not

00:25:08,000 --> 00:25:10,880
nothing happens

00:25:09,200 --> 00:25:13,279
but if there's a lot happening it might

00:25:10,880 --> 00:25:15,120
actually be slower than real time

00:25:13,279 --> 00:25:18,159
and that's it i am hoping that we will

00:25:15,120 --> 00:25:20,159
release all of the necessary code soon

00:25:18,159 --> 00:25:23,039
and i'm hoping also that i won't be the

00:25:20,159 --> 00:25:28,240
only one using it

00:25:23,039 --> 00:25:31,760
thank you

00:25:28,240 --> 00:25:32,880
okay um thanks johannes uh do we have

00:25:31,760 --> 00:25:36,799
any questions

00:25:32,880 --> 00:25:40,320
let's see hey go through this

00:25:36,799 --> 00:25:42,880
okay uh from the top

00:25:40,320 --> 00:25:46,000
uh does time travel guarantee the

00:25:42,880 --> 00:25:46,000
ordering of events

00:25:50,640 --> 00:25:53,520
it might be muted

00:25:55,200 --> 00:25:59,600
yep sorry they muted me um

00:25:58,240 --> 00:26:01,120
i'm not even sure i understand the

00:25:59,600 --> 00:26:01,760
question correctly if you if you could

00:26:01,120 --> 00:26:04,159
elaborate

00:26:01,760 --> 00:26:05,840
i mean the the ordering of events kind

00:26:04,159 --> 00:26:06,559
of goes back to what your scheduler is

00:26:05,840 --> 00:26:09,440
doing and

00:26:06,559 --> 00:26:10,000
how your timers were um were triggered

00:26:09,440 --> 00:26:11,279
and if you have

00:26:10,000 --> 00:26:13,279
incoming packages or something it

00:26:11,279 --> 00:26:14,720
depends on what your what your device is

00:26:13,279 --> 00:26:18,159
simulating

00:26:14,720 --> 00:26:19,360
oh wow so so any any time so it's my

00:26:18,159 --> 00:26:23,360
question and

00:26:19,360 --> 00:26:26,000
um what else so timers i assume

00:26:23,360 --> 00:26:26,400
that even if timers are different

00:26:26,000 --> 00:26:29,440
different

00:26:26,400 --> 00:26:32,480
by one microsecond they are ordered

00:26:29,440 --> 00:26:34,559
so that is maintained

00:26:32,480 --> 00:26:37,039
uh but are there any other sort of

00:26:34,559 --> 00:26:40,400
events in the system

00:26:37,039 --> 00:26:43,600
that we implicitly order because of

00:26:40,400 --> 00:26:46,960
these delays that might um become

00:26:43,600 --> 00:26:48,559
unordered in this case i can't really

00:26:46,960 --> 00:26:49,200
think of any way that would happen i

00:26:48,559 --> 00:26:51,279
mean once

00:26:49,200 --> 00:26:52,320
one thing also to notice that user mode

00:26:51,279 --> 00:26:54,720
linux isn't

00:26:52,320 --> 00:26:56,640
smp at this point so you're not really

00:26:54,720 --> 00:27:00,080
doing anything in paradigm

00:26:56,640 --> 00:27:01,360
and so um if if you have to even

00:27:00,080 --> 00:27:02,799
events that were meant to be in a

00:27:01,360 --> 00:27:04,400
certain order and they have some kind of

00:27:02,799 --> 00:27:05,440
time constraint between them in a

00:27:04,400 --> 00:27:07,840
certain order then

00:27:05,440 --> 00:27:09,600
that should be preserved it's just the

00:27:07,840 --> 00:27:11,600
the way the scheduler would

00:27:09,600 --> 00:27:13,200
work right and if something is actually

00:27:11,600 --> 00:27:15,120
going to do an end today or something

00:27:13,200 --> 00:27:17,360
then the cpu is busy at that point

00:27:15,120 --> 00:27:19,120
now i i did mention that we don't have

00:27:17,360 --> 00:27:20,880
preempt here right so if you have some

00:27:19,120 --> 00:27:22,799
long running loop and you expect that

00:27:20,880 --> 00:27:24,720
loop to spit out events

00:27:22,799 --> 00:27:26,399
every once in a while and something else

00:27:24,720 --> 00:27:28,559
would um

00:27:26,399 --> 00:27:30,320
would something else would consume them

00:27:28,559 --> 00:27:32,240
then this probably wouldn't work right

00:27:30,320 --> 00:27:34,880
right it's if it's cpu bound or

00:27:32,240 --> 00:27:35,440
something that actually takes cpu time

00:27:34,880 --> 00:27:39,120
to

00:27:35,440 --> 00:27:39,120
to create events in a certain order

00:27:39,200 --> 00:27:44,000
okay uh the question from david poole

00:27:42,240 --> 00:27:46,399
this may be a little more about

00:27:44,000 --> 00:27:47,679
uml but is uml still on interactive

00:27:46,399 --> 00:27:49,919
development

00:27:47,679 --> 00:27:51,679
the mailing list is very quiet what do

00:27:49,919 --> 00:27:54,000
we know about that

00:27:51,679 --> 00:27:55,679
yeah it's i mean richard is the

00:27:54,000 --> 00:27:56,640
maintainer and he hasn't been merging as

00:27:55,679 --> 00:27:59,440
much as i like

00:27:56,640 --> 00:28:01,520
um and i don't know it's kind of half

00:27:59,440 --> 00:28:02,159
active i guess i've been fixing it up

00:28:01,520 --> 00:28:04,080
anton

00:28:02,159 --> 00:28:05,919
another contributor there has been

00:28:04,080 --> 00:28:09,279
working on network drivers so

00:28:05,919 --> 00:28:11,600
clearly he's using that also um

00:28:09,279 --> 00:28:13,279
i did look at he was doing this on kvm

00:28:11,600 --> 00:28:13,919
initially but it's much much much more

00:28:13,279 --> 00:28:16,159
complex

00:28:13,919 --> 00:28:17,440
so user mode linux was kind of a cheap

00:28:16,159 --> 00:28:19,200
way out

00:28:17,440 --> 00:28:21,600
um we'll see how that works out in the

00:28:19,200 --> 00:28:23,120
future i can't really say it's actively

00:28:21,600 --> 00:28:24,080
maintained we've been trying to do

00:28:23,120 --> 00:28:26,399
things here and there

00:28:24,080 --> 00:28:28,240
someone's been doing ka sun support but

00:28:26,399 --> 00:28:29,440
it didn't go anywhere yet because it has

00:28:28,240 --> 00:28:32,720
some issues

00:28:29,440 --> 00:28:34,960
and um i would say for now it works

00:28:32,720 --> 00:28:37,279
but it has still has issues i fixed that

00:28:34,960 --> 00:28:40,720
blocked up some time ago for it

00:28:37,279 --> 00:28:40,720
so i would be able to test it

00:28:41,120 --> 00:28:45,840
okay a question from eric jones um have

00:28:44,320 --> 00:28:48,320
you used clone new time

00:28:45,840 --> 00:28:49,760
looks like you kind of answered but um

00:28:48,320 --> 00:28:52,240
yeah not really i mean

00:28:49,760 --> 00:28:54,799
this is running a complete virtual

00:28:52,240 --> 00:28:57,600
machine in a sense right and so

00:28:54,799 --> 00:29:00,720
new time is within the system um so no

00:28:57,600 --> 00:29:00,720
it's not really related

00:29:03,360 --> 00:29:07,279
uh be great if you could share the

00:29:05,440 --> 00:29:09,840
script

00:29:07,279 --> 00:29:11,279
yeah that would be nice i think that's

00:29:09,840 --> 00:29:15,279
probably going to be true of

00:29:11,279 --> 00:29:18,799
presentations obviously scripts and

00:29:15,279 --> 00:29:18,799
open source we always want to share

00:29:19,440 --> 00:29:23,039
yeah journey restriction of drivers or

00:29:21,840 --> 00:29:25,279
applications

00:29:23,039 --> 00:29:26,240
which we have to modify code to simulate

00:29:25,279 --> 00:29:28,399
overtime travel

00:29:26,240 --> 00:29:29,360
that's a good question yeah that's a

00:29:28,399 --> 00:29:31,760
good question so

00:29:29,360 --> 00:29:33,120
um we found a number of bugs in

00:29:31,760 --> 00:29:35,120
applications this way

00:29:33,120 --> 00:29:36,480
because if you if you simulate infinite

00:29:35,120 --> 00:29:37,919
cpu speed

00:29:36,480 --> 00:29:39,600
then you will find that some

00:29:37,919 --> 00:29:42,640
applications are just trying to eat

00:29:39,600 --> 00:29:44,399
as much cpu time as they can get and um

00:29:42,640 --> 00:29:46,000
those kinds of simulations you can't use

00:29:44,399 --> 00:29:46,960
under this mode because you will never

00:29:46,000 --> 00:29:49,120
move time forward

00:29:46,960 --> 00:29:50,480
right we've actually found bugs in some

00:29:49,120 --> 00:29:52,799
applications where

00:29:50,480 --> 00:29:54,320
even w medium d that i mentioned had a

00:29:52,799 --> 00:29:55,760
bucket wasn't doing some timing thing

00:29:54,320 --> 00:29:57,919
right and so it was sitting there in a

00:29:55,760 --> 00:30:00,799
busy loop that no one ever noticed

00:29:57,919 --> 00:30:02,159
um rather than going into its event loop

00:30:00,799 --> 00:30:03,840
into its select loop

00:30:02,159 --> 00:30:06,159
it was just sitting there in a busy loop

00:30:03,840 --> 00:30:06,640
so those are the kinds of things that we

00:30:06,159 --> 00:30:09,760
found

00:30:06,640 --> 00:30:12,000
um so yeah it may not run

00:30:09,760 --> 00:30:14,080
every application but as far as the

00:30:12,000 --> 00:30:15,440
wi-fi stack up and down everything we've

00:30:14,080 --> 00:30:17,600
tested so far

00:30:15,440 --> 00:30:19,279
it's concerned the applications are

00:30:17,600 --> 00:30:21,120
event driven they're not doing

00:30:19,279 --> 00:30:24,320
cpu-based polling or something like that

00:30:21,120 --> 00:30:27,360
so that works

00:30:24,320 --> 00:30:29,039
question from steve josiero if the

00:30:27,360 --> 00:30:32,559
controller application isn't

00:30:29,039 --> 00:30:35,200
oss yet can we do the hswam

00:30:32,559 --> 00:30:37,919
host apd test as described in the

00:30:35,200 --> 00:30:39,520
wireless workshop last week

00:30:37,919 --> 00:30:41,840
yes because they run only in a single

00:30:39,520 --> 00:30:41,840
machine

00:30:42,399 --> 00:30:45,440
how hard was it to get your driver to

00:30:44,320 --> 00:30:47,840
run an uml

00:30:45,440 --> 00:30:49,440
except from jesse that was actually

00:30:47,840 --> 00:30:52,080
really simple we just ported it to

00:30:49,440 --> 00:30:54,559
verdio we had a transport abstraction

00:30:52,080 --> 00:30:56,240
and that was the easiest part really the

00:30:54,559 --> 00:30:57,760
harder part it was on the device side to

00:30:56,240 --> 00:31:00,080
get the device to

00:30:57,760 --> 00:31:01,919
to run in a user space environment to

00:31:00,080 --> 00:31:05,840
get the device from where to

00:31:01,919 --> 00:31:07,519
work there question from borget

00:31:05,840 --> 00:31:09,840
at what resolution is scheduling

00:31:07,519 --> 00:31:09,840
happening

00:31:10,880 --> 00:31:13,919
so so the time traveler works at

00:31:12,480 --> 00:31:15,600
nanosecond resolution

00:31:13,919 --> 00:31:19,279
um because that's the underlying

00:31:15,600 --> 00:31:19,279
mechanisms that linux

00:31:20,720 --> 00:31:24,080
so that's also the scheduling of the vms

00:31:22,799 --> 00:31:26,159
and stuff um

00:31:24,080 --> 00:31:27,919
but of course you know your jiffy's

00:31:26,159 --> 00:31:30,840
based timers or something in the kernel

00:31:27,919 --> 00:31:33,840
are still going to happen at that

00:31:30,840 --> 00:31:33,840
resolution

00:31:34,080 --> 00:31:37,440
um another question about uml seems to

00:31:36,559 --> 00:31:39,840
be an interesting

00:31:37,440 --> 00:31:41,360
side topic uh can uml run hardware

00:31:39,840 --> 00:31:44,000
drivers

00:31:41,360 --> 00:31:45,440
you know basically no that's why we did

00:31:44,000 --> 00:31:48,720
the video you don't have

00:31:45,440 --> 00:31:50,720
um you don't have i o memory or anything

00:31:48,720 --> 00:31:53,200
like that that you can simulate

00:31:50,720 --> 00:31:55,200
so um maybe it would be possible i

00:31:53,200 --> 00:31:56,240
looked at it simulating the pci layer at

00:31:55,200 --> 00:31:57,919
some point but

00:31:56,240 --> 00:32:00,159
it's just so much work that going to

00:31:57,919 --> 00:32:02,399
verteo is much much simpler

00:32:00,159 --> 00:32:03,279
so normal hardware drivers won't really

00:32:02,399 --> 00:32:05,120
be able to run

00:32:03,279 --> 00:32:06,320
that's another reason i looked at kvm

00:32:05,120 --> 00:32:08,320
initially um

00:32:06,320 --> 00:32:09,840
but then kvm you have like three four

00:32:08,320 --> 00:32:11,760
different clock sources in the in the

00:32:09,840 --> 00:32:12,799
system and you have smp to worry with

00:32:11,760 --> 00:32:16,720
worry about

00:32:12,799 --> 00:32:16,720
and it gets a lot more complex

00:32:17,039 --> 00:32:21,039
okay so i think um let's go ahead and

00:32:20,399 --> 00:32:23,080
move on

00:32:21,039 --> 00:32:26,080
to the next presentation thank you

00:32:23,080 --> 00:32:26,080

YouTube URL: https://www.youtube.com/watch?v=t3LHSVh1kwA


