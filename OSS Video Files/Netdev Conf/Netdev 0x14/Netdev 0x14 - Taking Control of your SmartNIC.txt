Title: Netdev 0x14 - Taking Control of your SmartNIC
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Or Gerlitz, Andy Gospodarek

More info: https://netdevconf.info/0x14/session.html?talk-taking-control-of-your-SmartNIC

Date: Monday, August 17, 2020

SmartNICs are introducing a new paradigm in hardware
offload/acceleration - that of introducing additional
general purpose processors in the NIC. So visualize
the NIC as almost its own machine connected to your host.
Meaning you can, for example, move your control plane to
the NIC.

In this talk, Or Gerlitz and Andy Gospodarek start
by describing high level view of this class of NICs
They will then explore common common deployment methods
and models and help us understand this new class of NICs
 by exploring:

- what is out there in terms of networking open
  source code/features
- automation recipes and scripts to onboard
  software infra 
- common kernel offload techniques in use
- upstream kernel and distro SoC support

Or and Andy will iterate a few working examples
that are available for use across devices from
multiple, open SmartNIC vendors. They will also
discuss approaches of integrating into known
cloud orchestration systems like OpenStack
and Kubernetes.
Captions: 
	00:00:01,680 --> 00:00:06,799
hello everyone i'm andy gaspidarik

00:00:03,760 --> 00:00:09,599
from broadcom and i'm here today with

00:00:06,799 --> 00:00:11,200
i am org ellis from melanox and today

00:00:09,599 --> 00:00:16,560
we're going to talk about taking control

00:00:11,200 --> 00:00:18,560
of your smart deck

00:00:16,560 --> 00:00:20,320
so an important point to think about

00:00:18,560 --> 00:00:23,840
when we spray this conversation

00:00:20,320 --> 00:00:23,840
is what is a smart deck

00:00:24,000 --> 00:00:29,119
it's an often often a confused term

00:00:27,199 --> 00:00:31,039
and we wanted thought it was important

00:00:29,119 --> 00:00:33,680
to define so first of all let's talk

00:00:31,039 --> 00:00:37,200
about what a smartnic is not

00:00:33,680 --> 00:00:38,960
it is not a nick with that only has

00:00:37,200 --> 00:00:41,120
fixed function hardware

00:00:38,960 --> 00:00:43,280
it might be capable of stateful or

00:00:41,120 --> 00:00:46,320
stateless offloads

00:00:43,280 --> 00:00:49,760
for example vlan tunnel offload

00:00:46,320 --> 00:00:50,879
low offload might be found on a lot of

00:00:49,760 --> 00:00:52,960
network a6

00:00:50,879 --> 00:00:54,800
this is not what we're calling a smart

00:00:52,960 --> 00:00:57,680
deck

00:00:54,800 --> 00:00:59,280
we're also not calling a smart nic a

00:00:57,680 --> 00:01:02,320
nick with a programmable

00:00:59,280 --> 00:01:06,320
data path written using a very specific

00:01:02,320 --> 00:01:08,240
language for example ebpf or p4

00:01:06,320 --> 00:01:12,560
or maybe a hardware description language

00:01:08,240 --> 00:01:14,240
these are not smart next

00:01:12,560 --> 00:01:16,080
what we are talking about when we say a

00:01:14,240 --> 00:01:18,479
smartnic

00:01:16,080 --> 00:01:20,000
is a device that allows a server

00:01:18,479 --> 00:01:22,960
operator or owner

00:01:20,000 --> 00:01:25,040
to move control plane applications

00:01:22,960 --> 00:01:27,280
directly to general purpose

00:01:25,040 --> 00:01:30,880
cores that live on this nick or

00:01:27,280 --> 00:01:30,880
sometimes we might call it an soc

00:01:31,439 --> 00:01:35,040
in a practical sense today this is

00:01:33,759 --> 00:01:37,280
exclusively

00:01:35,040 --> 00:01:38,479
arm-based devices that aura and i will

00:01:37,280 --> 00:01:40,479
be talking about today

00:01:38,479 --> 00:01:42,000
in the future companies might choose to

00:01:40,479 --> 00:01:44,479
use risk 5

00:01:42,000 --> 00:01:46,399
or other instruction sets but the

00:01:44,479 --> 00:01:49,280
architecture primarily used today

00:01:46,399 --> 00:01:50,159
is armed so when you hear us say arm or

00:01:49,280 --> 00:01:52,079
soc

00:01:50,159 --> 00:01:55,360
we're talking about those special cores

00:01:52,079 --> 00:01:57,119
that live directly on the net

00:01:55,360 --> 00:01:59,439
we want to think about a previous

00:01:57,119 --> 00:02:01,439
presentation done at ietf 105

00:01:59,439 --> 00:02:02,960
about how nics worked today a

00:02:01,439 --> 00:02:03,920
presentation that was worked on by

00:02:02,960 --> 00:02:07,119
myself

00:02:03,920 --> 00:02:08,479
or tom herbert and simon horman

00:02:07,119 --> 00:02:10,479
this smart nic would fall into the

00:02:08,479 --> 00:02:12,800
category of a programmable nic

00:02:10,479 --> 00:02:14,800
with a general purpose processor that in

00:02:12,800 --> 00:02:18,720
this case of course at netdev

00:02:14,800 --> 00:02:20,879
runs linux in addition

00:02:18,720 --> 00:02:22,080
to being able to offload these these

00:02:20,879 --> 00:02:25,040
control plane cores

00:02:22,080 --> 00:02:26,640
of course these are all part of the same

00:02:25,040 --> 00:02:27,599
family of chips that are available in

00:02:26,640 --> 00:02:30,959
the regular next

00:02:27,599 --> 00:02:32,959
that both broadcom and melanox make so

00:02:30,959 --> 00:02:34,239
in addition to control plane being

00:02:32,959 --> 00:02:36,080
offloaded to

00:02:34,239 --> 00:02:38,160
these arm cores we might actually be

00:02:36,080 --> 00:02:41,680
able to offload the data pack

00:02:38,160 --> 00:02:43,840
to this fixed function asic as well

00:02:41,680 --> 00:02:45,200
so there's a lot of a lot of things

00:02:43,840 --> 00:02:46,800
happening on these devices

00:02:45,200 --> 00:02:48,080
a lot of really cool things a lot of

00:02:46,800 --> 00:02:48,800
really neat features we want to talk

00:02:48,080 --> 00:02:52,160
about

00:02:48,800 --> 00:02:52,160
and talk about how to manage them

00:02:52,879 --> 00:02:57,120
one other key component to a smart nic

00:02:54,959 --> 00:03:00,400
over a standard nic what some people my

00:02:57,120 --> 00:03:02,000
company call a performance nick

00:03:00,400 --> 00:03:03,680
is that further packet processing

00:03:02,000 --> 00:03:04,720
through hardware offload capabilities

00:03:03,680 --> 00:03:08,000
like crypto

00:03:04,720 --> 00:03:10,159
compression maybe pattern matching these

00:03:08,000 --> 00:03:11,680
these could be applied to you know linux

00:03:10,159 --> 00:03:15,519
frameworks kernel

00:03:11,680 --> 00:03:17,680
uh maybe dpdk and and nikkors can

00:03:15,519 --> 00:03:19,120
offload those things using frameworks

00:03:17,680 --> 00:03:20,720
those applications to frameworks

00:03:19,120 --> 00:03:23,120
available on this hardware

00:03:20,720 --> 00:03:24,959
in many cases what we're actually seeing

00:03:23,120 --> 00:03:27,120
is that fixed function devices are

00:03:24,959 --> 00:03:30,159
defined

00:03:27,120 --> 00:03:31,200
excuse me seeing is that fixed function

00:03:30,159 --> 00:03:32,959
devices

00:03:31,200 --> 00:03:34,400
are fairly limited right now in terms of

00:03:32,959 --> 00:03:36,080
their offload capabilities

00:03:34,400 --> 00:03:38,080
we're seeing a rapid expansion the

00:03:36,080 --> 00:03:39,120
offload capabilities and hardware assist

00:03:38,080 --> 00:03:41,519
abilities

00:03:39,120 --> 00:03:44,239
exclusively in what we're labeling today

00:03:41,519 --> 00:03:44,239
as smart mix

00:03:45,120 --> 00:03:48,239
we talk about what the smartnic

00:03:46,879 --> 00:03:50,400
architecture might look like

00:03:48,239 --> 00:03:52,080
there's a fantastic presentation at

00:03:50,400 --> 00:03:54,959
sidcom last year

00:03:52,080 --> 00:03:56,400
that discussed uh what a smartnic might

00:03:54,959 --> 00:03:57,040
look like and what some of the units

00:03:56,400 --> 00:03:58,480
might be

00:03:57,040 --> 00:04:00,319
the functional blocks that would be in

00:03:58,480 --> 00:04:03,200
that smart neck

00:04:00,319 --> 00:04:03,920
obviously we have a pci card here excuse

00:04:03,200 --> 00:04:06,560
me pci

00:04:03,920 --> 00:04:08,720
express card here that has the ability

00:04:06,560 --> 00:04:09,200
to communicate over a pci interface to a

00:04:08,720 --> 00:04:11,040
host

00:04:09,200 --> 00:04:12,799
and included on that would be these

00:04:11,040 --> 00:04:14,400
computing units

00:04:12,799 --> 00:04:16,239
well again we're talking mostly about

00:04:14,400 --> 00:04:18,160
multi-core arm processors

00:04:16,239 --> 00:04:20,639
uh accelerators that could be available

00:04:18,160 --> 00:04:21,759
for doing packet processing or assist

00:04:20,639 --> 00:04:25,440
with packet processing

00:04:21,759 --> 00:04:28,720
crypto compression regex etc

00:04:25,440 --> 00:04:30,400
some onboard memory that obviously these

00:04:28,720 --> 00:04:31,919
memory needs to be available for running

00:04:30,400 --> 00:04:32,720
an operating system and receiving

00:04:31,919 --> 00:04:34,639
extended

00:04:32,720 --> 00:04:36,479
packets and then possibly some traffic

00:04:34,639 --> 00:04:39,759
control infrastructure

00:04:36,479 --> 00:04:39,759
or maybe an embedded switch

00:04:40,720 --> 00:04:44,960
at this same sig com presentation are

00:04:43,280 --> 00:04:48,320
some great pictures that describe

00:04:44,960 --> 00:04:49,840
two basic types of smartnics

00:04:48,320 --> 00:04:51,280
so we're going to call these these the

00:04:49,840 --> 00:04:51,840
names that were used here were the on

00:04:51,280 --> 00:04:54,320
path

00:04:51,840 --> 00:04:57,840
and the off path smart mix we can see

00:04:54,320 --> 00:04:57,840
pictures of the architecture here

00:04:59,040 --> 00:05:03,120
so we want to break these down and

00:05:00,400 --> 00:05:06,479
explain them in a little bit more detail

00:05:03,120 --> 00:05:10,000
so the name as you might

00:05:06,479 --> 00:05:13,680
surmise comes from the fact that if it

00:05:10,000 --> 00:05:16,479
is an onpath smartnic the nik cores are

00:05:13,680 --> 00:05:17,039
always on the packet path so that means

00:05:16,479 --> 00:05:19,600
that

00:05:17,039 --> 00:05:20,880
any frames that come into the device as

00:05:19,600 --> 00:05:22,560
pictured on the left

00:05:20,880 --> 00:05:24,639
might go through a traffic management

00:05:22,560 --> 00:05:25,520
layer but they're processed by the nic

00:05:24,639 --> 00:05:27,919
cores

00:05:25,520 --> 00:05:29,919
possibly transformed in some capacity

00:05:27,919 --> 00:05:31,280
may be decapped maybe encrypted may be

00:05:29,919 --> 00:05:33,680
decrypted

00:05:31,280 --> 00:05:35,680
and then those those packets are passed

00:05:33,680 --> 00:05:39,199
on to the host course

00:05:35,680 --> 00:05:42,479
so this means that the nikkors

00:05:39,199 --> 00:05:44,800
have direct access

00:05:42,479 --> 00:05:46,080
to the packets every single one of them

00:05:44,800 --> 00:05:48,240
and

00:05:46,080 --> 00:05:49,680
you can have fairly low latency packet

00:05:48,240 --> 00:05:52,400
processing here

00:05:49,680 --> 00:05:54,320
caveat being every time a packet comes

00:05:52,400 --> 00:05:56,479
in a nuke core

00:05:54,320 --> 00:05:58,880
an arm core in this case would have to

00:05:56,479 --> 00:05:58,880
touch it

00:05:59,199 --> 00:06:03,039
the off path architecture however is

00:06:01,199 --> 00:06:06,319
different at the center

00:06:03,039 --> 00:06:08,080
of all of this is a embedded switch

00:06:06,319 --> 00:06:09,680
or a fixed function asic as we've talked

00:06:08,080 --> 00:06:12,160
about this

00:06:09,680 --> 00:06:13,759
asic hardware allows packets to possibly

00:06:12,160 --> 00:06:16,960
skip the nic cores

00:06:13,759 --> 00:06:18,000
so there is an off chance that those

00:06:16,960 --> 00:06:20,160
packets

00:06:18,000 --> 00:06:21,600
will be off path and go directly to the

00:06:20,160 --> 00:06:23,440
host scores

00:06:21,600 --> 00:06:25,039
this could be advantageous when packets

00:06:23,440 --> 00:06:27,360
that should be directed to the host

00:06:25,039 --> 00:06:27,360
cores

00:06:27,600 --> 00:06:31,840
that are are directed appropriately or

00:06:30,400 --> 00:06:33,280
it could be that

00:06:31,840 --> 00:06:35,280
certain hardware functions can be

00:06:33,280 --> 00:06:37,120
performed and there's no need once

00:06:35,280 --> 00:06:40,000
once a connection is validated to send

00:06:37,120 --> 00:06:40,000
it to the net course

00:06:41,840 --> 00:06:47,199
so why does it really matter this on

00:06:43,919 --> 00:06:49,759
path versus off path architecture

00:06:47,199 --> 00:06:52,319
so onpath smartnics typically expose a

00:06:49,759 --> 00:06:54,560
very low level programming api

00:06:52,319 --> 00:06:56,080
you might use an sdk some other

00:06:54,560 --> 00:06:58,240
low-level interface

00:06:56,080 --> 00:07:00,840
access hardware hardware blocks to

00:06:58,240 --> 00:07:03,680
access packets on a smartnet

00:07:00,840 --> 00:07:04,720
and since you're interacting with a very

00:07:03,680 --> 00:07:08,240
specific

00:07:04,720 --> 00:07:10,720
implementation different vendor

00:07:08,240 --> 00:07:12,240
problem different vendors packages would

00:07:10,720 --> 00:07:14,639
likely require a different software

00:07:12,240 --> 00:07:17,680
implementation

00:07:14,639 --> 00:07:20,800
off path smartnics however tend to be

00:07:17,680 --> 00:07:21,840
more flexible and more programmable they

00:07:20,800 --> 00:07:24,560
typically use

00:07:21,840 --> 00:07:26,319
the same data plane drivers that are

00:07:24,560 --> 00:07:29,440
used on a on a regular nick

00:07:26,319 --> 00:07:32,319
and on the smartnic because they both

00:07:29,440 --> 00:07:33,360
share access to this nick block that's

00:07:32,319 --> 00:07:35,599
included

00:07:33,360 --> 00:07:37,280
and used for both the host side

00:07:35,599 --> 00:07:42,160
typically x86

00:07:37,280 --> 00:07:42,160
and the smartnick side typically armed

00:07:42,960 --> 00:07:47,680
with this common driver capability and

00:07:45,759 --> 00:07:49,599
common hardware api and

00:07:47,680 --> 00:07:52,160
common hardware everything we like to

00:07:49,599 --> 00:07:53,680
think a hardware vendor can give third

00:07:52,160 --> 00:07:56,000
parties or others

00:07:53,680 --> 00:07:58,400
an operating system and users can have

00:07:56,000 --> 00:08:01,440
complete control over their own destiny

00:07:58,400 --> 00:08:01,440
there's no need to

00:08:01,520 --> 00:08:06,000
the requirement in most cases to have

00:08:04,479 --> 00:08:10,240
access to

00:08:06,000 --> 00:08:10,960
a very specific sdk or specific use case

00:08:10,240 --> 00:08:14,240
in order to

00:08:10,960 --> 00:08:17,280
satisfy this we do our job then

00:08:14,240 --> 00:08:18,639
it's easy for everyone to use the focus

00:08:17,280 --> 00:08:21,599
on ours of this talk

00:08:18,639 --> 00:08:22,639
for both orr and i will be on off path

00:08:21,599 --> 00:08:24,879
smart knicks

00:08:22,639 --> 00:08:26,960
because broadcom's stingray smartnik and

00:08:24,879 --> 00:08:28,400
the melanix blue melanox bluefield

00:08:26,960 --> 00:08:32,240
smartnix excuse me

00:08:28,400 --> 00:08:32,240
are both off paths martinique

00:08:33,599 --> 00:08:36,560
now i'm going to turn it over to orr

00:08:35,039 --> 00:08:38,880
he's going to talk about some of the

00:08:36,560 --> 00:08:42,000
data path models that exist for off path

00:08:38,880 --> 00:08:43,919
smart decks yes thank you andy

00:08:42,000 --> 00:08:45,839
so once we did the distinction between

00:08:43,919 --> 00:08:47,440
on pass smart link and off past now i

00:08:45,839 --> 00:08:47,920
think we'll dive a bit into those off

00:08:47,440 --> 00:08:50,320
past

00:08:47,920 --> 00:08:51,120
smartnics and we'd like to introduce two

00:08:50,320 --> 00:08:53,680
models for

00:08:51,120 --> 00:08:54,880
uh or mention two models for packet

00:08:53,680 --> 00:08:56,720
processing

00:08:54,880 --> 00:08:58,080
or more generally io processing later

00:08:56,720 --> 00:08:59,120
you'll see that we expand it beyond

00:08:58,080 --> 00:09:01,120
networking

00:08:59,120 --> 00:09:02,959
so the first one we call it we refer to

00:09:01,120 --> 00:09:04,720
it as storing forward

00:09:02,959 --> 00:09:06,800
we call it storing forward because each

00:09:04,720 --> 00:09:11,279
packet goes from the network

00:09:06,800 --> 00:09:12,959
to the soc and only then to the host

00:09:11,279 --> 00:09:14,720
the packet comes from the network goes

00:09:12,959 --> 00:09:15,440
through the link interface to the soc

00:09:14,720 --> 00:09:18,160
and then

00:09:15,440 --> 00:09:19,279
somehow maybe through pci or through the

00:09:18,160 --> 00:09:24,160
nick again

00:09:19,279 --> 00:09:26,080
to the host this this has um

00:09:24,160 --> 00:09:27,440
this sort of performance compromise as

00:09:26,080 --> 00:09:29,600
you'll see for the next

00:09:27,440 --> 00:09:31,440
model and the performance would be

00:09:29,600 --> 00:09:33,600
limited to some extent

00:09:31,440 --> 00:09:36,800
by the characteristics of the soc such

00:09:33,600 --> 00:09:39,360
as caches core speeds and such

00:09:36,800 --> 00:09:41,040
on the other hand because the soc in

00:09:39,360 --> 00:09:41,680
off-pass martinique runs the general

00:09:41,040 --> 00:09:43,839
purpose

00:09:41,680 --> 00:09:46,080
linux operating system you can

00:09:43,839 --> 00:09:49,040
practically run every packet processing

00:09:46,080 --> 00:09:50,000
workload that you have it would be both

00:09:49,040 --> 00:09:53,600
the control plane

00:09:50,000 --> 00:09:56,720
and the data plane on your smart nic

00:09:53,600 --> 00:10:00,640
common examples are like open vswitch

00:09:56,720 --> 00:10:02,480
xdp ebpf is fully available on all

00:10:00,640 --> 00:10:04,079
architectures so it can be either

00:10:02,480 --> 00:10:09,440
directly edpf or through

00:10:04,079 --> 00:10:11,680
xdp af af xdp vpp and such

00:10:09,440 --> 00:10:13,519
this is the store and forward model the

00:10:11,680 --> 00:10:17,519
next model we refer to it

00:10:13,519 --> 00:10:20,079
as inline could you move this slide

00:10:17,519 --> 00:10:21,120
thank you so the in in the inline in the

00:10:20,079 --> 00:10:23,360
inline forwarding

00:10:21,120 --> 00:10:24,800
model as the name suggests the packets

00:10:23,360 --> 00:10:26,720
go directly

00:10:24,800 --> 00:10:28,079
through the nick without going through

00:10:26,720 --> 00:10:30,160
the soc

00:10:28,079 --> 00:10:32,079
so we have a control plane and a data

00:10:30,160 --> 00:10:33,040
plane the data plane fully goes through

00:10:32,079 --> 00:10:34,880
the nic

00:10:33,040 --> 00:10:36,640
there's no additional copy and no

00:10:34,880 --> 00:10:39,920
performance compromise

00:10:36,640 --> 00:10:41,360
um the control the control plane on the

00:10:39,920 --> 00:10:44,640
other hand runs

00:10:41,360 --> 00:10:45,760
still runs on the soc and and the

00:10:44,640 --> 00:10:47,839
challenge for comp

00:10:45,760 --> 00:10:48,959
for control place applications is to

00:10:47,839 --> 00:10:51,440
offload

00:10:48,959 --> 00:10:52,240
offload the data paths to the hardware

00:10:51,440 --> 00:10:55,519
typical

00:10:52,240 --> 00:10:57,440
um thickness characteristics of those

00:10:55,519 --> 00:11:00,480
uh what you would need to offload would

00:10:57,440 --> 00:11:03,519
be of course obviously matching action

00:11:00,480 --> 00:11:05,839
uh we see also encryption coming up

00:11:03,519 --> 00:11:08,000
and uh the next thing the next two two

00:11:05,839 --> 00:11:11,120
guys in line that we see are compression

00:11:08,000 --> 00:11:13,600
and regular expressions all all these uh

00:11:11,120 --> 00:11:14,880
all these modifications or

00:11:13,600 --> 00:11:16,480
transformations

00:11:14,880 --> 00:11:18,640
are applied on packet processing

00:11:16,480 --> 00:11:20,880
workloads that we see today

00:11:18,640 --> 00:11:22,399
and more and more of them are already

00:11:20,880 --> 00:11:25,440
available by

00:11:22,399 --> 00:11:28,560
nine by 2020 to be offloaded by

00:11:25,440 --> 00:11:31,440
um with a rich open source uh

00:11:28,560 --> 00:11:32,079
um if ecosystem that we'll discuss in a

00:11:31,440 --> 00:11:34,959
minute

00:11:32,079 --> 00:11:36,079
in a minute so let's look on some

00:11:34,959 --> 00:11:39,279
examples

00:11:36,079 --> 00:11:41,519
um restoring forward as we said you just

00:11:39,279 --> 00:11:43,600
you just take your ovs this is example

00:11:41,519 --> 00:11:46,399
for ovs so obs

00:11:43,600 --> 00:11:46,959
runs on the arm we have the representer

00:11:46,399 --> 00:11:49,519
model

00:11:46,959 --> 00:11:50,880
for the linux nik switch the

00:11:49,519 --> 00:11:54,000
architecture that we

00:11:50,880 --> 00:11:57,680
kind of described in previous conference

00:11:54,000 --> 00:11:59,279
but all everything goes through the soc

00:11:57,680 --> 00:12:00,959
both the control plane and the dead

00:11:59,279 --> 00:12:02,000
appliance so all packets goes from the

00:12:00,959 --> 00:12:04,000
host

00:12:02,000 --> 00:12:06,240
through this switching component then to

00:12:04,000 --> 00:12:07,760
the arm and then outside to the network

00:12:06,240 --> 00:12:10,560
and the other way around

00:12:07,760 --> 00:12:13,040
so this is ovs and forward the next

00:12:10,560 --> 00:12:13,040
example

00:12:14,639 --> 00:12:18,480
would be um something which involves

00:12:17,519 --> 00:12:22,000
routing

00:12:18,480 --> 00:12:24,560
like uh with fr or your own b3f

00:12:22,000 --> 00:12:25,040
with router but the concept is the same

00:12:24,560 --> 00:12:26,959
the

00:12:25,040 --> 00:12:28,320
the packet processing workload is fully

00:12:26,959 --> 00:12:30,000
programmed on the arm

00:12:28,320 --> 00:12:31,760
every packet goes from the host through

00:12:30,000 --> 00:12:32,560
the switching component of the neck to

00:12:31,760 --> 00:12:34,800
the arm

00:12:32,560 --> 00:12:35,600
and then the multiplication can run

00:12:34,800 --> 00:12:38,399
there and uh

00:12:35,600 --> 00:12:38,880
one usage is let's say ecmp running ecmp

00:12:38,399 --> 00:12:40,959
on your

00:12:38,880 --> 00:12:44,079
host but then you do the ecmp work on

00:12:40,959 --> 00:12:44,079
your smart link and such

00:12:45,680 --> 00:12:49,680
uh if we go to the inline model this is

00:12:48,639 --> 00:12:52,240
something that we

00:12:49,680 --> 00:12:53,519
is maybe more natural to this to the net

00:12:52,240 --> 00:12:55,839
dev crowd

00:12:53,519 --> 00:12:58,399
but this time the obvious offloads runs

00:12:55,839 --> 00:13:01,200
uh is programmed from the smartening

00:12:58,399 --> 00:13:02,480
so we have the ovs with the representer

00:13:01,200 --> 00:13:05,200
architecture

00:13:02,480 --> 00:13:07,120
and though both companies like broadcom

00:13:05,200 --> 00:13:09,120
have drew flow and in melanox were

00:13:07,120 --> 00:13:12,079
branded at asap but both these

00:13:09,120 --> 00:13:13,279
products or brands if you like are based

00:13:12,079 --> 00:13:16,320
on the concept of

00:13:13,279 --> 00:13:18,000
offloading ovs in a very similar manner

00:13:16,320 --> 00:13:19,200
that you would do it on the horse but do

00:13:18,000 --> 00:13:22,880
it on the arm

00:13:19,200 --> 00:13:26,639
because the arm is managing the e-switch

00:13:22,880 --> 00:13:29,279
if we look um next slide

00:13:26,639 --> 00:13:30,560
if we look on the open source ecosystem

00:13:29,279 --> 00:13:33,519
which is needed for this

00:13:30,560 --> 00:13:34,000
in-line processing so what we see is

00:13:33,519 --> 00:13:37,200
that

00:13:34,000 --> 00:13:40,800
um as

00:13:37,200 --> 00:13:43,440
andy mentioned the the arm uh has a nick

00:13:40,800 --> 00:13:44,720
interface this means that it's it's

00:13:43,440 --> 00:13:47,600
actually practically

00:13:44,720 --> 00:13:49,839
identical identical interface as what

00:13:47,600 --> 00:13:52,959
the host sees to some

00:13:49,839 --> 00:13:55,279
in in a large manner so

00:13:52,959 --> 00:13:57,199
the same apis and drivers that you would

00:13:55,279 --> 00:13:58,320
use on your host you can use on your

00:13:57,199 --> 00:14:01,040
smart nic to just

00:13:58,320 --> 00:14:02,000
access the nic and manage the switch of

00:14:01,040 --> 00:14:03,680
the nic

00:14:02,000 --> 00:14:05,360
this means that the transition from

00:14:03,680 --> 00:14:08,399
running on the host and

00:14:05,360 --> 00:14:11,680
running on smart deck is relatively easy

00:14:08,399 --> 00:14:12,800
we have a data pass offload in a kernel

00:14:11,680 --> 00:14:15,199
fashion

00:14:12,800 --> 00:14:16,880
via tc flower also recently with

00:14:15,199 --> 00:14:19,839
connection tracking technology also

00:14:16,880 --> 00:14:22,639
through net net filter and for the dpdk

00:14:19,839 --> 00:14:25,040
based data paths through rte flow

00:14:22,639 --> 00:14:26,880
again as we said further our hardware

00:14:25,040 --> 00:14:30,000
accelerators are introduced by

00:14:26,880 --> 00:14:33,040
by smart leak vendors and as

00:14:30,000 --> 00:14:35,199
exposed via apis

00:14:33,040 --> 00:14:37,360
so the first two we see kind of ready in

00:14:35,199 --> 00:14:40,639
the line are the crypto ones

00:14:37,360 --> 00:14:44,160
for instance ktls and ipsec can be made

00:14:40,639 --> 00:14:45,360
to run inline already today and what we

00:14:44,160 --> 00:14:48,240
see coming up

00:14:45,360 --> 00:14:50,160
is the need to define those api and

00:14:48,240 --> 00:14:52,720
offload them for compression and regular

00:14:50,160 --> 00:14:52,720
expression

00:14:56,839 --> 00:14:59,519
matching

00:14:58,240 --> 00:15:02,079
so the next thing we think about

00:14:59,519 --> 00:15:04,639
whenever we talk about a smart nic is

00:15:02,079 --> 00:15:05,600
how am i going to use this so users will

00:15:04,639 --> 00:15:08,000
wonder

00:15:05,600 --> 00:15:10,720
what are the benefits or more to the

00:15:08,000 --> 00:15:13,519
point how do i deploy this

00:15:10,720 --> 00:15:14,800
so we took a look at uh openstack

00:15:13,519 --> 00:15:17,600
smartnic integration

00:15:14,800 --> 00:15:18,959
so in in a legacy installation which is

00:15:17,600 --> 00:15:20,639
what i'm now calling everything that's

00:15:18,959 --> 00:15:23,600
not a smart nic

00:15:20,639 --> 00:15:24,639
nova or compute and networking or

00:15:23,600 --> 00:15:26,480
neutron

00:15:24,639 --> 00:15:27,920
those those agents are both going to run

00:15:26,480 --> 00:15:30,000
on the host

00:15:27,920 --> 00:15:31,199
but in a smartnic installation as or has

00:15:30,000 --> 00:15:33,120
already discussed

00:15:31,199 --> 00:15:34,959
neutron is going to run on the arm

00:15:33,120 --> 00:15:36,800
course or more to the point the data

00:15:34,959 --> 00:15:40,320
path is going to run on the armed force

00:15:36,800 --> 00:15:42,720
so neutron should be there too

00:15:40,320 --> 00:15:44,399
but nova needs to stay on the server now

00:15:42,720 --> 00:15:45,839
there are some that don't do that

00:15:44,399 --> 00:15:48,480
typically nova needs to stay on the

00:15:45,839 --> 00:15:50,800
server so what we've done

00:15:48,480 --> 00:15:51,759
so far is we have users who have done

00:15:50,800 --> 00:15:53,759
this

00:15:51,759 --> 00:15:54,959
but quite honestly more testing is

00:15:53,759 --> 00:15:58,240
needed to validate

00:15:54,959 --> 00:15:59,279
that nova and neutron can live and any

00:15:58,240 --> 00:16:01,440
other dependent

00:15:59,279 --> 00:16:03,759
agents can live happily ever after on

00:16:01,440 --> 00:16:05,519
separate cpu cores

00:16:03,759 --> 00:16:07,279
and though as i mentioned there are

00:16:05,519 --> 00:16:08,880
people who have deployed openstack

00:16:07,279 --> 00:16:12,160
successfully with smartnix

00:16:08,880 --> 00:16:14,560
and separated different components

00:16:12,160 --> 00:16:15,440
into different cpu complexes arm versus

00:16:14,560 --> 00:16:17,360
host

00:16:15,440 --> 00:16:19,440
there's currently no turnkey openstack

00:16:17,360 --> 00:16:22,320
solution

00:16:19,440 --> 00:16:25,680
you see the frown face and this is kind

00:16:22,320 --> 00:16:25,680
of disappointing in some ways

00:16:25,759 --> 00:16:30,560
but this is a fact and this is the way

00:16:27,920 --> 00:16:30,560
it is today

00:16:31,600 --> 00:16:35,440
one of the things i look towards and

00:16:34,079 --> 00:16:36,800
when i think about how

00:16:35,440 --> 00:16:38,959
there might be better integration in the

00:16:36,800 --> 00:16:41,279
future as i look at the fact that

00:16:38,959 --> 00:16:44,240
neutron with the networking ovn plug-in

00:16:41,279 --> 00:16:48,000
is gaining lots of popularity

00:16:44,240 --> 00:16:49,600
so if you look at fundamentally the ovn

00:16:48,000 --> 00:16:52,880
architecture which is pictured

00:16:49,600 --> 00:16:54,399
on the right we can see that openstack

00:16:52,880 --> 00:16:55,440
now only needs to communicate with a

00:16:54,399 --> 00:16:59,199
single database

00:16:55,440 --> 00:17:00,880
the ovn northbound db that database

00:16:59,199 --> 00:17:02,320
will communicate with a daemon that will

00:17:00,880 --> 00:17:06,160
ultimately push

00:17:02,320 --> 00:17:09,919
config to the ovn southbound db

00:17:06,160 --> 00:17:12,240
now any given host that is running

00:17:09,919 --> 00:17:13,919
obs will also be running an ovn

00:17:12,240 --> 00:17:15,039
controller app that will read from the

00:17:13,919 --> 00:17:18,480
southbound db

00:17:15,039 --> 00:17:21,439
and appropriately populate the local

00:17:18,480 --> 00:17:22,640
ovs database and make sure that flows

00:17:21,439 --> 00:17:24,400
can be

00:17:22,640 --> 00:17:26,319
programmed correctly either to hardware

00:17:24,400 --> 00:17:29,919
or to a software data plane

00:17:26,319 --> 00:17:32,400
this architecture is exactly

00:17:29,919 --> 00:17:34,080
the kind of distributed model it really

00:17:32,400 --> 00:17:36,000
benefits from smart decks

00:17:34,080 --> 00:17:37,760
so will we get better openstack smartnic

00:17:36,000 --> 00:17:40,960
in the future

00:17:37,760 --> 00:17:43,360
uh smart integration in the future

00:17:40,960 --> 00:17:44,400
that's it's a good question uh a lot of

00:17:43,360 --> 00:17:46,480
will depend on interest

00:17:44,400 --> 00:17:48,799
and a lot of will depend on the desires

00:17:46,480 --> 00:17:50,880
of those continuing to deploy openstack

00:17:48,799 --> 00:17:52,559
and probably whether or not my company

00:17:50,880 --> 00:17:56,400
and horse company decide to invest

00:17:52,559 --> 00:17:56,400
significant amount in making that happen

00:17:57,200 --> 00:18:00,320
the next infrastructure that's so

00:17:58,720 --> 00:18:03,280
important to think about and

00:18:00,320 --> 00:18:04,400
is at every every conference that even

00:18:03,280 --> 00:18:06,799
isn't just kubecon

00:18:04,400 --> 00:18:07,919
is kubernetes so this decoupled

00:18:06,799 --> 00:18:11,200
architecture

00:18:07,919 --> 00:18:13,039
and in general the the um the model of

00:18:11,200 --> 00:18:13,440
kubernetes might be a better fit for

00:18:13,039 --> 00:18:15,520
smart

00:18:13,440 --> 00:18:17,200
fix now openstack is distributed but

00:18:15,520 --> 00:18:20,400
kubernetes seems to be a little bit

00:18:17,200 --> 00:18:21,360
more it just seems to be different it

00:18:20,400 --> 00:18:22,720
seems like there are a lot more

00:18:21,360 --> 00:18:25,679
application choices

00:18:22,720 --> 00:18:28,080
and a lot a lot of different

00:18:25,679 --> 00:18:29,600
applications that people might use one

00:18:28,080 --> 00:18:31,840
example

00:18:29,600 --> 00:18:33,039
in this sort of nominal case q proxy is

00:18:31,840 --> 00:18:35,600
there to

00:18:33,039 --> 00:18:36,880
perform iptables rules do filtering and

00:18:35,600 --> 00:18:38,480
make sure that

00:18:36,880 --> 00:18:40,640
things get to the right application as

00:18:38,480 --> 00:18:42,880
needed this could be a prime candidate

00:18:40,640 --> 00:18:45,039
to move to a smart name

00:18:42,880 --> 00:18:46,160
if the processing of forwarding and

00:18:45,039 --> 00:18:48,640
filtering rules

00:18:46,160 --> 00:18:50,320
could be done there and an application

00:18:48,640 --> 00:18:52,480
simply

00:18:50,320 --> 00:18:54,320
had a interface that was a vf or

00:18:52,480 --> 00:18:57,360
interface that was a vlan interface

00:18:54,320 --> 00:18:59,760
some way to delineate how this container

00:18:57,360 --> 00:19:01,679
netdev gets what it needs this could

00:18:59,760 --> 00:19:03,919
really be a good option

00:19:01,679 --> 00:19:05,840
another good option would actually be to

00:19:03,919 --> 00:19:07,120
move an ingress controller all the way

00:19:05,840 --> 00:19:09,520
to a smartnet

00:19:07,120 --> 00:19:11,120
and this is exactly what we've done so

00:19:09,520 --> 00:19:12,160
we've undergone some testing in the last

00:19:11,120 --> 00:19:15,200
few weeks

00:19:12,160 --> 00:19:18,559
to see more than that to move

00:19:15,200 --> 00:19:20,799
envoy down to a arm-based smart neck

00:19:18,559 --> 00:19:21,919
and test what it would be like to pass

00:19:20,799 --> 00:19:24,480
traffic between

00:19:21,919 --> 00:19:27,360
two applications running on a host if

00:19:24,480 --> 00:19:31,520
they have to go through

00:19:27,360 --> 00:19:31,520
envoy running on arm cores so

00:19:31,600 --> 00:19:36,000
you can see from the diagram a packet

00:19:33,440 --> 00:19:38,240
would would leave application one

00:19:36,000 --> 00:19:39,039
traverse through the e-switch could

00:19:38,240 --> 00:19:40,960
probably not

00:19:39,039 --> 00:19:43,120
do much other than look at the proper

00:19:40,960 --> 00:19:44,160
mac address to see it arrive on an mdev

00:19:43,120 --> 00:19:47,280
representer

00:19:44,160 --> 00:19:49,120
on the arm course this representer would

00:19:47,280 --> 00:19:50,720
uh in turn pass the packets to the

00:19:49,120 --> 00:19:52,400
ingress envoy proxy because it would be

00:19:50,720 --> 00:19:54,320
listening on that device

00:19:52,400 --> 00:19:55,840
that envoy proxy would say oh it should

00:19:54,320 --> 00:19:57,679
go over here

00:19:55,840 --> 00:19:59,200
and ultimately the routing table would

00:19:57,679 --> 00:20:02,000
move it to a different mdev

00:19:59,200 --> 00:20:06,320
and that packet would would proceed back

00:20:02,000 --> 00:20:08,320
to the other application on the host

00:20:06,320 --> 00:20:10,000
one of the reasons we decided to address

00:20:08,320 --> 00:20:11,679
this situation and understand if this is

00:20:10,000 --> 00:20:15,919
a viable option

00:20:11,679 --> 00:20:17,520
is that much like cases where obs

00:20:15,919 --> 00:20:19,360
in the past was seen as consuming a

00:20:17,520 --> 00:20:21,520
significant significant number of cores

00:20:19,360 --> 00:20:24,559
in virtualization installation

00:20:21,520 --> 00:20:27,600
we're now seeing ingress proxies

00:20:24,559 --> 00:20:29,440
or other service mesh

00:20:27,600 --> 00:20:30,799
type data planes using a significant

00:20:29,440 --> 00:20:33,280
number of cores

00:20:30,799 --> 00:20:34,320
on x86 servers there are lots of

00:20:33,280 --> 00:20:36,799
optimizations

00:20:34,320 --> 00:20:36,799
lots of

00:20:37,760 --> 00:20:41,520
packages or lots of projects lots of

00:20:40,080 --> 00:20:42,400
companies built around making this

00:20:41,520 --> 00:20:43,919
better

00:20:42,400 --> 00:20:46,480
we decided to take the approach of what

00:20:43,919 --> 00:20:48,480
if we move on way to the smart map

00:20:46,480 --> 00:20:51,440
in this case what we found is that if

00:20:48,480 --> 00:20:53,919
you on a standard

00:20:51,440 --> 00:20:54,799
fairly generic x86 server recent

00:20:53,919 --> 00:20:57,360
generation

00:20:54,799 --> 00:20:58,000
you're using around five or six cores

00:20:57,360 --> 00:21:01,840
worth

00:20:58,000 --> 00:21:05,679
of cpu time just processing

00:21:01,840 --> 00:21:07,120
traffic via envoy you could successfully

00:21:05,679 --> 00:21:10,799
offload that traffic

00:21:07,120 --> 00:21:13,679
to and stingray smartnic

00:21:10,799 --> 00:21:15,679
and successfully relieve that system

00:21:13,679 --> 00:21:18,640
from having to consume those cores

00:21:15,679 --> 00:21:20,320
doing nothing but processing packets and

00:21:18,640 --> 00:21:22,720
moving them to the right container

00:21:20,320 --> 00:21:24,799
so we're going to continue to just to do

00:21:22,720 --> 00:21:27,280
this experimentation and do this testing

00:21:24,799 --> 00:21:28,080
and i expect more to be reported on this

00:21:27,280 --> 00:21:29,360
in the future

00:21:28,080 --> 00:21:30,559
but these are the types of things we're

00:21:29,360 --> 00:21:33,120
thinking about when we think about

00:21:30,559 --> 00:21:33,120
integration

00:21:33,280 --> 00:21:36,400
another piece to consider is that maybe

00:21:35,120 --> 00:21:39,919
you don't want to use

00:21:36,400 --> 00:21:42,400
a large framework like openstack or

00:21:39,919 --> 00:21:44,400
kubernetes so in this case in a true

00:21:42,400 --> 00:21:45,600
open source model you just want to

00:21:44,400 --> 00:21:47,039
everything to get out of your way and

00:21:45,600 --> 00:21:49,200
you want to manage your device the way

00:21:47,039 --> 00:21:52,159
you want to manage your device

00:21:49,200 --> 00:21:52,880
many people will will want to do that in

00:21:52,159 --> 00:21:54,559
this case

00:21:52,880 --> 00:21:56,080
because we're running linux and we're

00:21:54,559 --> 00:21:58,080
able to run

00:21:56,080 --> 00:22:00,000
any stand you know standard standard

00:21:58,080 --> 00:22:03,039
linux if you like

00:22:00,000 --> 00:22:06,000
traditional tools that are used on other

00:22:03,039 --> 00:22:08,240
uh distributions or any distribution for

00:22:06,000 --> 00:22:11,360
configuration or management

00:22:08,240 --> 00:22:13,280
can be used uh this is also

00:22:11,360 --> 00:22:15,039
by the way is independent management

00:22:13,280 --> 00:22:16,960
extremely popular in the world

00:22:15,039 --> 00:22:19,120
of bare metal server deployments and

00:22:16,960 --> 00:22:21,840
this is something that the smart neck

00:22:19,120 --> 00:22:24,080
has really enabled having these separate

00:22:21,840 --> 00:22:25,919
cores that can do processing

00:22:24,080 --> 00:22:27,440
are really a benefit to those wanting to

00:22:25,919 --> 00:22:30,400
deploy bare metal servers and or i'll

00:22:27,440 --> 00:22:31,679
talk about that in a few minutes

00:22:30,400 --> 00:22:32,960
before he does i'm going to talk about a

00:22:31,679 --> 00:22:35,280
couple more tests we did and some

00:22:32,960 --> 00:22:38,480
examples that we demonstrate

00:22:35,280 --> 00:22:39,200
so if you were a typical provider of

00:22:38,480 --> 00:22:41,200
systems

00:22:39,200 --> 00:22:42,320
for someone and a particular provider of

00:22:41,200 --> 00:22:45,120
vms

00:22:42,320 --> 00:22:45,760
you might decide that you want to use a

00:22:45,120 --> 00:22:47,440
vnf

00:22:45,760 --> 00:22:49,200
in your infrastructure so one of your

00:22:47,440 --> 00:22:51,200
your vms that you're running

00:22:49,200 --> 00:22:53,280
is actually doing nothing but either

00:22:51,200 --> 00:22:56,480
forwarding or packet transformation

00:22:53,280 --> 00:22:58,559
possibly security and in this case this

00:22:56,480 --> 00:23:01,679
is something that's consuming cores

00:22:58,559 --> 00:23:03,280
and makes your systems less usable for

00:23:01,679 --> 00:23:05,440
applications because cores are being

00:23:03,280 --> 00:23:08,960
consumed by this vnf

00:23:05,440 --> 00:23:10,880
well we have taken the

00:23:08,960 --> 00:23:12,559
the fairly obvious idea of running this

00:23:10,880 --> 00:23:15,840
vnf for arm

00:23:12,559 --> 00:23:19,520
in a vm on the stingray smartnic and

00:23:15,840 --> 00:23:20,480
this can be done so we have example

00:23:19,520 --> 00:23:23,760
scripts

00:23:20,480 --> 00:23:25,440
uh and we have full examples in the

00:23:23,760 --> 00:23:27,200
github link that should be that will be

00:23:25,440 --> 00:23:28,480
available on the slides

00:23:27,200 --> 00:23:30,480
and what we've done in this case is

00:23:28,480 --> 00:23:31,600
provided a sample vm that just has a

00:23:30,480 --> 00:23:33,679
dpdk

00:23:31,600 --> 00:23:35,039
a simple test pmd app that we use for

00:23:33,679 --> 00:23:38,720
this testing

00:23:35,039 --> 00:23:42,080
and this creates an ubuntu cloud-based

00:23:38,720 --> 00:23:43,679
uh vm that runs on the smart nic

00:23:42,080 --> 00:23:46,400
can be deployed gives you the same

00:23:43,679 --> 00:23:48,720
benefits that a vnf might give you

00:23:46,400 --> 00:23:50,799
on a server but now on the smart nic so

00:23:48,720 --> 00:23:51,919
now if you look at our x86 hostess

00:23:50,799 --> 00:23:54,799
listed here

00:23:51,919 --> 00:23:56,400
we are freed up to do nothing but

00:23:54,799 --> 00:23:59,039
application develop

00:23:56,400 --> 00:24:00,559
so we can be sure if our vnf is correct

00:23:59,039 --> 00:24:02,080
and is running on the smartnic

00:24:00,559 --> 00:24:05,360
that it has filtered what we need to

00:24:02,080 --> 00:24:08,480
filter and the x86 host is free to just

00:24:05,360 --> 00:24:08,480
host its applications

00:24:08,799 --> 00:24:12,400
additionally we provided an example of

00:24:10,720 --> 00:24:14,640
being able to perform some simple smart

00:24:12,400 --> 00:24:17,760
net configuration with ansible

00:24:14,640 --> 00:24:19,440
again standard linux running ansible

00:24:17,760 --> 00:24:22,240
works great

00:24:19,440 --> 00:24:23,120
so a full example of this fairly simple

00:24:22,240 --> 00:24:26,559
solution

00:24:23,120 --> 00:24:29,200
of running obs on the arm course

00:24:26,559 --> 00:24:31,120
and having a host that's running vms is

00:24:29,200 --> 00:24:32,720
shown here

00:24:31,120 --> 00:24:33,919
also in this picture over to the far

00:24:32,720 --> 00:24:34,720
right we see there's just a simple

00:24:33,919 --> 00:24:36,640
controller

00:24:34,720 --> 00:24:38,000
that's somewhere else on the network

00:24:36,640 --> 00:24:39,279
it's able to uh

00:24:38,000 --> 00:24:42,320
enter the smart nic perform

00:24:39,279 --> 00:24:46,400
configuration do setup of ovs

00:24:42,320 --> 00:24:48,000
and uh and and forward traffic

00:24:46,400 --> 00:24:49,440
between the wire and between the

00:24:48,000 --> 00:24:51,200
appropriate vms

00:24:49,440 --> 00:24:53,200
full example of this also available on

00:24:51,200 --> 00:24:54,240
the link i think it's important to not

00:24:53,200 --> 00:24:56,159
just

00:24:54,240 --> 00:24:58,159
talk about what's possible but actually

00:24:56,159 --> 00:25:00,400
show some things that are possible

00:24:58,159 --> 00:25:01,360
with the stingray smartening so we

00:25:00,400 --> 00:25:05,039
provided those

00:25:01,360 --> 00:25:06,240
here today so now i'll turn it over to

00:25:05,039 --> 00:25:06,960
orr and he's going to talk a little bit

00:25:06,240 --> 00:25:10,320
more about

00:25:06,960 --> 00:25:10,960
smartnix and bare metal clouds thank you

00:25:10,320 --> 00:25:12,720
andy

00:25:10,960 --> 00:25:15,679
the next thing i wanted to we wanted to

00:25:12,720 --> 00:25:17,840
look on is take a further steps

00:25:15,679 --> 00:25:19,919
and think about situations that we refer

00:25:17,840 --> 00:25:22,559
to them as birmingham clouds

00:25:19,919 --> 00:25:24,640
when what's what's available is a server

00:25:22,559 --> 00:25:27,520
that you don't know what's running there

00:25:24,640 --> 00:25:29,039
it could be a legacy server or legacy

00:25:27,520 --> 00:25:31,279
storage appliance

00:25:29,039 --> 00:25:33,279
that may maybe have an older operations

00:25:31,279 --> 00:25:34,320
system or even a special made operating

00:25:33,279 --> 00:25:36,320
system

00:25:34,320 --> 00:25:37,600
and doesn't have all the fancy and new

00:25:36,320 --> 00:25:40,840
things we have on

00:25:37,600 --> 00:25:44,240
linux for example in this case

00:25:40,840 --> 00:25:47,200
um what what comes into the

00:25:44,240 --> 00:25:47,760
into the picture is the ability of smart

00:25:47,200 --> 00:25:49,840
nick

00:25:47,760 --> 00:25:52,080
using uh software of the transon the

00:25:49,840 --> 00:25:55,120
smartthing and hardware capabilities

00:25:52,080 --> 00:25:57,919
to expose uh common hardware functions

00:25:55,120 --> 00:26:00,159
to to this legacy server and this way

00:25:57,919 --> 00:26:03,200
this server does not need to run

00:26:00,159 --> 00:26:05,919
latest technology uh drivers and such

00:26:03,200 --> 00:26:07,120
in the uh for the nic so we're talking

00:26:05,919 --> 00:26:08,640
about i o so i i

00:26:07,120 --> 00:26:10,240
typically is made of networking and

00:26:08,640 --> 00:26:12,640
storage and

00:26:10,240 --> 00:26:14,320
in the next side of thing something

00:26:12,640 --> 00:26:17,760
which you see coming up

00:26:14,320 --> 00:26:18,559
is um a virtual hardware function being

00:26:17,760 --> 00:26:22,640
planted

00:26:18,559 --> 00:26:26,240
by the smartnik on the on the pci bus

00:26:22,640 --> 00:26:29,360
of the of the server

00:26:26,240 --> 00:26:30,240
in the storage case uh we see a case we

00:26:29,360 --> 00:26:33,600
see a case of

00:26:30,240 --> 00:26:36,400
nvme pc high disk being

00:26:33,600 --> 00:26:38,000
emulated to the server in this case the

00:26:36,400 --> 00:26:39,600
server does not need to have local

00:26:38,000 --> 00:26:41,760
storage anymore

00:26:39,600 --> 00:26:43,120
and all that and also they don't need to

00:26:41,760 --> 00:26:45,360
have the latest

00:26:43,120 --> 00:26:46,240
uh nvme fabrics driver because they

00:26:45,360 --> 00:26:47,760
would use

00:26:46,240 --> 00:26:50,240
for the virtual case they would use the

00:26:47,760 --> 00:26:53,039
virtual net driver which available

00:26:50,240 --> 00:26:55,600
virtually all operating systems and the

00:26:53,039 --> 00:26:57,039
nvme pci driver which is also available

00:26:55,600 --> 00:27:00,000
on the operating system

00:26:57,039 --> 00:27:00,400
and you can also boot from for the nic

00:27:00,000 --> 00:27:02,080
for the

00:27:00,400 --> 00:27:04,240
for the smart link operator there's a

00:27:02,080 --> 00:27:05,440
rich open source facilities to integrate

00:27:04,240 --> 00:27:09,600
with

00:27:05,440 --> 00:27:12,799
in virtuo we are talking about the vdpa

00:27:09,600 --> 00:27:15,120
infrastructure for both kernel and dpdk

00:27:12,799 --> 00:27:17,679
and in storage we talk about the kernel

00:27:15,120 --> 00:27:19,840
stack or spdk

00:27:17,679 --> 00:27:20,960
let's move to see a concrete example

00:27:19,840 --> 00:27:24,240
with melanox

00:27:20,960 --> 00:27:26,080
bluefield in the next slide

00:27:24,240 --> 00:27:28,080
we have something we call snap which

00:27:26,080 --> 00:27:31,039
stands for search defined networking

00:27:28,080 --> 00:27:33,279
accelerated process processing and snap

00:27:31,039 --> 00:27:34,559
is a framework to emulate nvme local

00:27:33,279 --> 00:27:37,600
storage

00:27:34,559 --> 00:27:39,600
on hypervisor on the server and rem and

00:27:37,600 --> 00:27:42,000
connect it to remote storage

00:27:39,600 --> 00:27:43,520
if we look on the chart we can see that

00:27:42,000 --> 00:27:46,960
on the right side of the chart

00:27:43,520 --> 00:27:50,320
the stack the server sees and

00:27:46,960 --> 00:27:52,159
an nvme pcids and they would run an nvme

00:27:50,320 --> 00:27:54,720
standard driver

00:27:52,159 --> 00:27:55,919
those nvme pci transactions that would

00:27:54,720 --> 00:27:59,200
be applied

00:27:55,919 --> 00:28:02,159
by the by the server are translated

00:27:59,200 --> 00:28:03,279
um into a data pass that runs in the

00:28:02,159 --> 00:28:06,000
smart pic

00:28:03,279 --> 00:28:06,720
and here again we have two choices two

00:28:06,000 --> 00:28:09,600
choices

00:28:06,720 --> 00:28:11,600
the first one is inline in this case the

00:28:09,600 --> 00:28:15,520
hardware can translate

00:28:11,600 --> 00:28:17,679
nvme pci to nvme over rdma

00:28:15,520 --> 00:28:19,600
without going through the through the

00:28:17,679 --> 00:28:21,120
nicoles without going through the soc

00:28:19,600 --> 00:28:22,399
directly to the network

00:28:21,120 --> 00:28:25,200
after the initial connection

00:28:22,399 --> 00:28:27,919
establishment the other case

00:28:25,200 --> 00:28:29,600
which is more common is where the

00:28:27,919 --> 00:28:31,520
smartlink operator would like to

00:28:29,600 --> 00:28:35,039
intervene to intercept

00:28:31,520 --> 00:28:36,559
to modify uh the the storage traffic of

00:28:35,039 --> 00:28:38,960
the server

00:28:36,559 --> 00:28:40,880
let's take a case where the fabric the

00:28:38,960 --> 00:28:44,000
fabric operator or the smartic operator

00:28:40,880 --> 00:28:45,440
they would want to use nvme over tcp

00:28:44,000 --> 00:28:47,120
because that's the storage

00:28:45,440 --> 00:28:50,080
infrastructure for instance

00:28:47,120 --> 00:28:50,640
so we call it a snap proxy and this

00:28:50,080 --> 00:28:52,720
would be

00:28:50,640 --> 00:28:54,000
store and forward because the nvme

00:28:52,720 --> 00:28:56,240
traffic then

00:28:54,000 --> 00:28:57,520
the emulated nvme pci traffic would go

00:28:56,240 --> 00:28:59,360
to the soc

00:28:57,520 --> 00:29:01,200
and then a target would run and we

00:28:59,360 --> 00:29:04,720
translate it to initiator

00:29:01,200 --> 00:29:06,880
of nvme tcp a storage proxy

00:29:04,720 --> 00:29:08,960
on the left side we see a melanox nick

00:29:06,880 --> 00:29:10,880
but in the more general case as i said

00:29:08,960 --> 00:29:12,880
it could be a virtuonic

00:29:10,880 --> 00:29:14,880
it could be either the vendor nick or

00:29:12,880 --> 00:29:17,440
vdpa with virto yo

00:29:14,880 --> 00:29:18,080
and again in the in this case it can be

00:29:17,440 --> 00:29:21,279
either

00:29:18,080 --> 00:29:22,320
later stern forward or inline but in the

00:29:21,279 --> 00:29:23,919
end of the day

00:29:22,320 --> 00:29:26,240
we have this component that andy

00:29:23,919 --> 00:29:28,559
mentioned the embedded switch

00:29:26,240 --> 00:29:30,480
of this of the nic which have to deal

00:29:28,559 --> 00:29:32,080
with all the traffic so here comes the

00:29:30,480 --> 00:29:33,039
software model that we've been building

00:29:32,080 --> 00:29:34,399
over the last years of the

00:29:33,039 --> 00:29:37,120
representatives

00:29:34,399 --> 00:29:39,039
and then you have storage traffic tcp

00:29:37,120 --> 00:29:39,279
traffic but it's all ethernet frames and

00:29:39,039 --> 00:29:41,200
an

00:29:39,279 --> 00:29:42,880
old switch inside and it's inside

00:29:41,200 --> 00:29:44,960
outside and inside

00:29:42,880 --> 00:29:46,320
this is actually quite a complex

00:29:44,960 --> 00:29:54,960
configuration

00:29:46,320 --> 00:29:57,600
but we find we find it very compelling

00:29:54,960 --> 00:29:58,159
now to conclude our uh presentation

00:29:57,600 --> 00:30:00,799
today

00:29:58,159 --> 00:30:03,440
uh i would like to again highlight uh

00:30:00,799 --> 00:30:05,840
the last part of bare metal provisioning

00:30:03,440 --> 00:30:07,120
which look promising both to users and

00:30:05,840 --> 00:30:10,480
also force

00:30:07,120 --> 00:30:12,080
for sma to users semantic operators

00:30:10,480 --> 00:30:14,399
and nick vendor to express their

00:30:12,080 --> 00:30:17,200
excellency and their

00:30:14,399 --> 00:30:19,600
highly performance hardware offload

00:30:17,200 --> 00:30:22,399
through those provisioning

00:30:19,600 --> 00:30:24,080
which will be simple for the host to use

00:30:22,399 --> 00:30:24,720
because the host will only run some

00:30:24,080 --> 00:30:28,080
legacy

00:30:24,720 --> 00:30:31,279
uh driver we see

00:30:28,080 --> 00:30:32,399
two two major use cases a case where the

00:30:31,279 --> 00:30:34,159
server operators

00:30:32,399 --> 00:30:36,000
call to control the smart nic i think

00:30:34,159 --> 00:30:38,320
people call it the virtualization use

00:30:36,000 --> 00:30:40,159
case and there's the case when the

00:30:38,320 --> 00:30:41,279
author network operator control the

00:30:40,159 --> 00:30:45,760
smart mix

00:30:41,279 --> 00:30:49,760
this is the bare metal now to you randy

00:30:45,760 --> 00:30:52,799
nice or so the key for both

00:30:49,760 --> 00:30:54,720
broadcom stingray and melanox blue field

00:30:52,799 --> 00:30:56,480
is that we want these nicks to be open

00:30:54,720 --> 00:30:57,519
programmable nicks that are simple to

00:30:56,480 --> 00:30:59,440
use

00:30:57,519 --> 00:31:01,760
they must be capable of running open

00:30:59,440 --> 00:31:03,120
source operating systems

00:31:01,760 --> 00:31:05,200
they must be capable of running open

00:31:03,120 --> 00:31:07,120
source applications

00:31:05,200 --> 00:31:08,880
use of standard automation tools so

00:31:07,120 --> 00:31:11,519
people can do whatever they want to

00:31:08,880 --> 00:31:12,640
with them is a requirement and

00:31:11,519 --> 00:31:15,159
ultimately

00:31:12,640 --> 00:31:17,120
either full integration or at least

00:31:15,159 --> 00:31:20,559
complementary

00:31:17,120 --> 00:31:23,039
applications for openstack kubernetes

00:31:20,559 --> 00:31:24,240
really does aid the adoption and these

00:31:23,039 --> 00:31:27,279
distributed

00:31:24,240 --> 00:31:28,640
frameworks are really really just

00:31:27,279 --> 00:31:30,720
the right way to go when you're

00:31:28,640 --> 00:31:31,679
considering distributing your system

00:31:30,720 --> 00:31:34,960
even further

00:31:31,679 --> 00:31:38,640
by adding a server inside your server

00:31:34,960 --> 00:31:40,480
if you will so the nature of these maybe

00:31:38,640 --> 00:31:43,120
doesn't make it so that there's a

00:31:40,480 --> 00:31:45,600
going to be an instant requirement or

00:31:43,120 --> 00:31:48,640
full turnkey system for it

00:31:45,600 --> 00:31:50,240
but we really feel like going forward

00:31:48,640 --> 00:31:50,960
there are lots of different ways to use

00:31:50,240 --> 00:31:55,600
these open

00:31:50,960 --> 00:31:59,679
programmable smartnics in in ways to aid

00:31:55,600 --> 00:32:03,679
your data center performance and

00:31:59,679 --> 00:32:05,840
really find better ways to use those uh

00:32:03,679 --> 00:32:07,919
those precious cores for doing uh

00:32:05,840 --> 00:32:14,480
important work

00:32:07,919 --> 00:32:17,200
thank you thank you

00:32:14,480 --> 00:32:18,480
we have some questions i see taurus has

00:32:17,200 --> 00:32:20,960
a question

00:32:18,480 --> 00:32:20,960
are you ready

00:32:22,799 --> 00:32:28,000
yes uh so uh basically what what seems

00:32:26,159 --> 00:32:31,519
to me that we are taking the

00:32:28,000 --> 00:32:35,039
uh first and saying you can have some

00:32:31,519 --> 00:32:35,039
extra course somewhere else

00:32:36,000 --> 00:32:43,840
okay hang on personally can you mute

00:32:49,840 --> 00:32:53,679
yes so it seems that we are taking the

00:32:51,840 --> 00:32:54,720
general purpose course and putting them

00:32:53,679 --> 00:32:57,120
on a special

00:32:54,720 --> 00:32:58,720
pcie card and sync you can or you can

00:32:57,120 --> 00:33:02,640
run your own application

00:32:58,720 --> 00:33:04,399
and uh offload or do some processing on

00:33:02,640 --> 00:33:05,679
those cores that because that might be

00:33:04,399 --> 00:33:08,159
more efficient

00:33:05,679 --> 00:33:09,039
what do you think can we ever be in the

00:33:08,159 --> 00:33:12,240
position

00:33:09,039 --> 00:33:13,519
that the those kind of accelerators we

00:33:12,240 --> 00:33:16,799
can tell like that

00:33:13,519 --> 00:33:20,080
will have that some uh standard level

00:33:16,799 --> 00:33:22,640
of management because i've seen

00:33:20,080 --> 00:33:23,600
that in one example we can have the ssh

00:33:22,640 --> 00:33:26,720
to the nik

00:33:23,600 --> 00:33:27,120
or we can use ansible what do you think

00:33:26,720 --> 00:33:29,360
about

00:33:27,120 --> 00:33:31,279
internal stuff for example i wrote an

00:33:29,360 --> 00:33:34,000
ebpf or i know i wrote

00:33:31,279 --> 00:33:34,000
i want to do

00:33:34,640 --> 00:33:40,399
some other new protocol maybe not new

00:33:38,000 --> 00:33:41,279
but existing one uh processing on those

00:33:40,399 --> 00:33:43,519
scores

00:33:41,279 --> 00:33:44,399
and so i'm taking the either broadcom or

00:33:43,519 --> 00:33:46,240
melanocynic

00:33:44,399 --> 00:33:47,760
and that just works from kernel do you

00:33:46,240 --> 00:33:50,480
think it can ever happen

00:33:47,760 --> 00:33:52,320
or this is just i should always use some

00:33:50,480 --> 00:33:54,640
user space

00:33:52,320 --> 00:33:56,320
maybe proprietary open source tools to

00:33:54,640 --> 00:33:58,080
do whatever i want but specifically for

00:33:56,320 --> 00:33:59,760
my case

00:33:58,080 --> 00:34:01,440
uh yeah i think it's possible because

00:33:59,760 --> 00:34:04,880
it's possible today

00:34:01,440 --> 00:34:05,440
so you can run right now you can run

00:34:04,880 --> 00:34:08,079
anything

00:34:05,440 --> 00:34:09,839
after 420 and it'll boot on stingray and

00:34:08,079 --> 00:34:11,440
i think uh orr has mentioned that all of

00:34:09,839 --> 00:34:13,919
the patches for their

00:34:11,440 --> 00:34:14,960
uh melanox bluefield nick is also

00:34:13,919 --> 00:34:17,520
available

00:34:14,960 --> 00:34:20,320
um open source and i think they have one

00:34:17,520 --> 00:34:22,240
or two more i think he said uh

00:34:20,320 --> 00:34:23,440
blocks soc blocks that need to be pushed

00:34:22,240 --> 00:34:24,800
upstream but

00:34:23,440 --> 00:34:26,879
i mean right right now you could go

00:34:24,800 --> 00:34:28,800
build a system right now

00:34:26,879 --> 00:34:30,560
i'm gonna say right now a few more times

00:34:28,800 --> 00:34:32,000
you could go build a completely open

00:34:30,560 --> 00:34:34,720
source solution

00:34:32,000 --> 00:34:36,240
and run it on these cards and control

00:34:34,720 --> 00:34:39,679
your own destiny i mean my

00:34:36,240 --> 00:34:40,000
my job is to have no sdks none of this

00:34:39,679 --> 00:34:43,040
stuff

00:34:40,000 --> 00:34:44,399
so yeah and you can run bpf on it now so

00:34:43,040 --> 00:34:46,480
if you want to do that that's that's a

00:34:44,399 --> 00:34:48,480
that's a thing

00:34:46,480 --> 00:34:50,560
so there's a couple more questions along

00:34:48,480 --> 00:34:52,800
those lines i think the summary question

00:34:50,560 --> 00:34:54,320
andy is not whether you can run it or

00:34:52,800 --> 00:34:56,639
not it's the fact that

00:34:54,320 --> 00:34:58,560
from a model perspective if i run

00:34:56,639 --> 00:35:00,880
everything on host curves

00:34:58,560 --> 00:35:02,079
offloading it we can argue whether or

00:35:00,880 --> 00:35:04,560
not it gives you the benefit

00:35:02,079 --> 00:35:05,200
or not because in the net it may not but

00:35:04,560 --> 00:35:06,960
maybe

00:35:05,200 --> 00:35:09,200
topically and separation of concerns it

00:35:06,960 --> 00:35:10,160
might but it does introduce new

00:35:09,200 --> 00:35:12,000
complexities

00:35:10,160 --> 00:35:13,520
in terms of the evp of that used to run

00:35:12,000 --> 00:35:16,000
on the kernel now it's running

00:35:13,520 --> 00:35:17,599
maybe split or maybe somewhere else but

00:35:16,000 --> 00:35:19,280
also there are some very specific

00:35:17,599 --> 00:35:22,240
questions from salil and

00:35:19,280 --> 00:35:23,680
somebody else about uh sergey about vm

00:35:22,240 --> 00:35:25,440
migration and

00:35:23,680 --> 00:35:27,520
and the complexity that it comes with

00:35:25,440 --> 00:35:30,720
because srd already has that

00:35:27,520 --> 00:35:32,560
wouldn't this make it worse

00:35:30,720 --> 00:35:35,200
yeah and you know the example we

00:35:32,560 --> 00:35:38,640
provided definitely used sriov

00:35:35,200 --> 00:35:40,480
for uh we're talking about the the vnf

00:35:38,640 --> 00:35:42,160
there but there's no actual compelling

00:35:40,480 --> 00:35:44,079
reason why you had to use

00:35:42,160 --> 00:35:45,839
sriov if you didn't want to i mean you

00:35:44,079 --> 00:35:47,359
could it's clearly there's going to be

00:35:45,839 --> 00:35:49,520
some efficiency gain there you're not

00:35:47,359 --> 00:35:50,720
spending time just switching packets but

00:35:49,520 --> 00:35:53,040
i mean we haven't tested this

00:35:50,720 --> 00:35:54,560
extensively the the challenge right now

00:35:53,040 --> 00:35:55,280
i think that exists with smartnix is

00:35:54,560 --> 00:35:58,079
that

00:35:55,280 --> 00:35:59,040
they're they're heavily used in the

00:35:58,079 --> 00:36:02,079
clouds

00:35:59,040 --> 00:36:02,880
let's say so and this is not a

00:36:02,079 --> 00:36:05,359
fabrication

00:36:02,880 --> 00:36:06,720
this is real so the question becomes

00:36:05,359 --> 00:36:07,280
does everyone else want to gain those

00:36:06,720 --> 00:36:09,040
same

00:36:07,280 --> 00:36:11,119
benefits that that clearly people who

00:36:09,040 --> 00:36:14,320
are using them in clouds are getting

00:36:11,119 --> 00:36:15,839
and both the

00:36:14,320 --> 00:36:17,280
the nick that broadcom has and the nick

00:36:15,839 --> 00:36:18,079
that melanox has gives people that

00:36:17,280 --> 00:36:21,680
chance

00:36:18,079 --> 00:36:23,440
so um i get the management aspect not

00:36:21,680 --> 00:36:24,480
only from the individuals or iov based

00:36:23,440 --> 00:36:27,280
things i get

00:36:24,480 --> 00:36:28,320
the idea that things will be split a

00:36:27,280 --> 00:36:31,280
little bit differently

00:36:28,320 --> 00:36:31,280
than they might have been

00:36:31,359 --> 00:36:34,640
and that's a legit concern and we need

00:36:32,880 --> 00:36:40,480
to address those as they become harder

00:36:34,640 --> 00:36:44,000
for people to use

00:36:40,480 --> 00:36:46,400
okay um i'm uh

00:36:44,000 --> 00:36:48,320
not seeing any questions that i think

00:36:46,400 --> 00:36:49,680
you haven't addressed anybody who thinks

00:36:48,320 --> 00:36:51,520
there is something that we haven't

00:36:49,680 --> 00:36:54,079
talked about yet i tried to type fast

00:36:51,520 --> 00:36:56,160
during the yeah yeah exactly so we need

00:36:54,079 --> 00:36:58,000
to we need to keep moving so maybe we'll

00:36:56,160 --> 00:37:01,920
move along and

00:36:58,000 --> 00:37:06,800
uh just just one question if you sure

00:37:01,920 --> 00:37:10,320
so is linux the right os for this

00:37:06,800 --> 00:37:12,960
was that jamal it's somebody

00:37:10,320 --> 00:37:15,280
masquerading as jamal the real person is

00:37:12,960 --> 00:37:16,400
linux what are you going to run down

00:37:15,280 --> 00:37:21,359
there why loop

00:37:16,400 --> 00:37:24,480
dpdk netbsd

00:37:21,359 --> 00:37:24,480
are you going to run tc

00:37:25,200 --> 00:37:30,160
you certainly can i mean no i mean like

00:37:28,640 --> 00:37:32,240
honestly like

00:37:30,160 --> 00:37:34,000
the same ip block that for networking

00:37:32,240 --> 00:37:34,960
for both of these cards that's used on

00:37:34,000 --> 00:37:37,680
x86

00:37:34,960 --> 00:37:39,200
so if there's tc flower support for mlx5

00:37:37,680 --> 00:37:40,320
and there's tc flower support for bn

00:37:39,200 --> 00:37:43,040
xten

00:37:40,320 --> 00:37:44,400
then yeah you can run you could run

00:37:43,040 --> 00:37:45,680
offload or if you just want to run

00:37:44,400 --> 00:37:46,560
straight tc and do everything in

00:37:45,680 --> 00:37:50,000
software

00:37:46,560 --> 00:37:53,200
or i mean i don't know i'm not sure

00:37:50,000 --> 00:37:54,640
so my basically my concern is do you

00:37:53,200 --> 00:37:56,400
i would think this would be very high

00:37:54,640 --> 00:38:00,480
performance in order to offload the host

00:37:56,400 --> 00:38:02,480
right so you don't want to go and run a

00:38:00,480 --> 00:38:03,760
full server software there you probably

00:38:02,480 --> 00:38:06,240
just need

00:38:03,760 --> 00:38:07,440
something that uh processes real fast

00:38:06,240 --> 00:38:08,800
and uses the offload

00:38:07,440 --> 00:38:11,599
capabilities as opposed to writing

00:38:08,800 --> 00:38:11,599
things on you

00:38:11,839 --> 00:38:15,440
that's the point with the off pass

00:38:15,920 --> 00:38:20,400
i think you maybe missed that so if you

00:38:18,320 --> 00:38:22,160
are an on path smartnic

00:38:20,400 --> 00:38:23,520
means that every packet goes through

00:38:22,160 --> 00:38:26,640
your cpu maybe

00:38:23,520 --> 00:38:28,240
linux or maybe you think about um a bare

00:38:26,640 --> 00:38:29,440
metal environment in your smartley

00:38:28,240 --> 00:38:31,520
because you don't want to

00:38:29,440 --> 00:38:32,480
you think the operating system is too

00:38:31,520 --> 00:38:34,560
heavy

00:38:32,480 --> 00:38:35,760
to process a packet like you do an npu

00:38:34,560 --> 00:38:39,040
right but

00:38:35,760 --> 00:38:40,480
in this model of off pass the packets do

00:38:39,040 --> 00:38:42,880
not go

00:38:40,480 --> 00:38:44,960
through the smart nic course and that's

00:38:42,880 --> 00:38:46,079
kind of the essence of our presentation

00:38:44,960 --> 00:38:49,200
today

00:38:46,079 --> 00:38:51,839
um that you can

00:38:49,200 --> 00:38:53,520
you are you have a you have a you have a

00:38:51,839 --> 00:38:55,599
you have a certain sets of hardware

00:38:53,520 --> 00:38:58,400
offloads that you program

00:38:55,599 --> 00:38:59,599
and i accept tom's comment that control

00:38:58,400 --> 00:39:02,880
pass and

00:38:59,599 --> 00:39:02,880
data paths are maybe less

00:39:03,440 --> 00:39:06,640
different than we maybe comes from this

00:39:05,280 --> 00:39:08,160
presentation uh

00:39:06,640 --> 00:39:09,920
and they also refer to that in the chat

00:39:08,160 --> 00:39:12,720
and also myself but

00:39:09,920 --> 00:39:15,119
but you have a certain set of hardware

00:39:12,720 --> 00:39:17,440
knobs you can program you have a switch

00:39:15,119 --> 00:39:19,119
uh and hardware switch that is

00:39:17,440 --> 00:39:20,240
programmed to deal with the packets and

00:39:19,119 --> 00:39:22,400
you have a

00:39:20,240 --> 00:39:24,960
crypto offload and compression offload

00:39:22,400 --> 00:39:27,280
and regex and who knows what's coming up

00:39:24,960 --> 00:39:30,320
and you are programming all those guys

00:39:27,280 --> 00:39:32,560
to handle the packets they're of course

00:39:30,320 --> 00:39:33,920
typically not running operating systems

00:39:32,560 --> 00:39:36,720
those hardware

00:39:33,920 --> 00:39:36,720
pieces right

00:39:38,320 --> 00:39:43,119
i think we're gonna stop here right i

00:39:40,839 --> 00:39:44,320
think we are we are getting into a

00:39:43,119 --> 00:39:45,920
philosophical question there are

00:39:44,320 --> 00:39:49,280
advantages of

00:39:45,920 --> 00:39:50,800
all of the above right um and and there

00:39:49,280 --> 00:39:52,800
are benefits to i mean running

00:39:50,800 --> 00:39:55,040
embedded lightweight linux because you

00:39:52,800 --> 00:39:56,720
can move applications around there is

00:39:55,040 --> 00:39:58,320
benefits running something much tighter

00:39:56,720 --> 00:40:00,320
so let's take that

00:39:58,320 --> 00:40:02,160
since we have happy hour which may not

00:40:00,320 --> 00:40:02,640
actually be an hour anymore maybe more

00:40:02,160 --> 00:40:05,520
like

00:40:02,640 --> 00:40:07,520
10 seconds but uh we are currently one

00:40:05,520 --> 00:40:10,800
entire presentation behind so let's keep

00:40:07,520 --> 00:40:10,800

YouTube URL: https://www.youtube.com/watch?v=IZ84h1Uh_tM


