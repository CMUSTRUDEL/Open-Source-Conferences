Title: Netdev 0x14 - Keynote: Nick McKeown Creating an end-to-end programming model for packet forwarding
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	In this keynote on the 28th of July 2020 at the Netdev 0x14 conference
Nick McKeown describes his vision on how we can work together to realize a world
where owners of large networks can express the behavior they want in their network
using a high-level language, and then seamlessly compile and deploy it across
all their various network devices.

More info:
https://netdevconf.info/0x14/session.html?keynote-mckeown
Captions: 
	00:00:02,399 --> 00:00:05,120
so uh

00:00:03,120 --> 00:00:06,640
thanks so much for inviting me here

00:00:05,120 --> 00:00:08,960
today it's a it's a great

00:00:06,640 --> 00:00:10,719
honor to to be here having worked in

00:00:08,960 --> 00:00:13,920
networking for over 30 years

00:00:10,719 --> 00:00:16,640
um i've witnessed how unix originally

00:00:13,920 --> 00:00:19,359
bsd mostly and then linux shaped

00:00:16,640 --> 00:00:19,840
almost every aspect of networking that

00:00:19,359 --> 00:00:22,160
we

00:00:19,840 --> 00:00:23,920
that we do today and how networking is

00:00:22,160 --> 00:00:26,000
done it shaped how we teach

00:00:23,920 --> 00:00:28,160
our undergraduates at stanford the

00:00:26,000 --> 00:00:31,519
software infrastructure of linux is

00:00:28,160 --> 00:00:33,680
a an amazing example of networking at

00:00:31,519 --> 00:00:35,040
its best that we show to our students

00:00:33,680 --> 00:00:35,920
and we try to give them an experience

00:00:35,040 --> 00:00:39,040
getting there

00:00:35,920 --> 00:00:41,680
getting their hands hands dirty uh uh

00:00:39,040 --> 00:00:42,879
using it and um i feel like i'm coming

00:00:41,680 --> 00:00:46,559
home to the

00:00:42,879 --> 00:00:48,559
to the home of where networking is done

00:00:46,559 --> 00:00:50,079
i see that netdev is growing from

00:00:48,559 --> 00:00:52,000
strength to strength

00:00:50,079 --> 00:00:54,000
uh i don't know if whether it's the

00:00:52,000 --> 00:00:57,520
increased interest in

00:00:54,000 --> 00:00:59,600
in open source or whether uh

00:00:57,520 --> 00:01:01,920
nobody has anything to do during the the

00:00:59,600 --> 00:01:04,799
pandemic but i noticed that you had your

00:01:01,920 --> 00:01:07,200
your most emails in a month uh in may

00:01:04,799 --> 00:01:08,400
not over 9000 emails on your on your

00:01:07,200 --> 00:01:10,080
listserv so

00:01:08,400 --> 00:01:13,040
i guess that uh that beats all the

00:01:10,080 --> 00:01:16,720
records in in by quite a way

00:01:13,040 --> 00:01:20,320
but seriously i i really applaud the

00:01:16,720 --> 00:01:21,119
devotion to open source i'm a huge

00:01:20,320 --> 00:01:22,960
believer

00:01:21,119 --> 00:01:24,720
in the open source community for

00:01:22,960 --> 00:01:28,080
networking um

00:01:24,720 --> 00:01:30,479
ever since it was uh it was not quite so

00:01:28,080 --> 00:01:32,400
so fashionable or successful uh in my

00:01:30,479 --> 00:01:34,159
group at stanford we put all of our work

00:01:32,400 --> 00:01:37,040
into the public domain

00:01:34,159 --> 00:01:38,159
and all of our software goes into open

00:01:37,040 --> 00:01:40,400
source

00:01:38,159 --> 00:01:41,680
and i really believe that open source is

00:01:40,400 --> 00:01:45,680
one of the biggest

00:01:41,680 --> 00:01:47,360
new unsung forces in networking

00:01:45,680 --> 00:01:50,000
you know despite all the buzzwords like

00:01:47,360 --> 00:01:51,439
sdn and nfe and disaggregation and all

00:01:50,000 --> 00:01:53,759
of that over the last

00:01:51,439 --> 00:01:54,640
10 years i think the real revolution in

00:01:53,759 --> 00:01:57,280
networking

00:01:54,640 --> 00:01:58,079
has been the coming of age of open

00:01:57,280 --> 00:02:01,520
source

00:01:58,079 --> 00:02:02,159
as a trustworthy infrastructure for how

00:02:01,520 --> 00:02:03,680
we run

00:02:02,159 --> 00:02:06,880
and operate networks because if you

00:02:03,680 --> 00:02:08,879
think about it 10 12 years ago

00:02:06,880 --> 00:02:10,479
everybody used vertically integrated

00:02:08,879 --> 00:02:12,400
closed proprietary

00:02:10,479 --> 00:02:14,400
networking equipment there was no other

00:02:12,400 --> 00:02:15,280
choice and then the cloud service

00:02:14,400 --> 00:02:17,440
providers

00:02:15,280 --> 00:02:18,560
and now more recently the internet

00:02:17,440 --> 00:02:21,040
service providers

00:02:18,560 --> 00:02:22,000
and some mobile operators are starting

00:02:21,040 --> 00:02:24,239
investing very heavily

00:02:22,000 --> 00:02:25,760
the top 10 data centers in the world the

00:02:24,239 --> 00:02:26,480
top largest data centers in the world

00:02:25,760 --> 00:02:28,640
today

00:02:26,480 --> 00:02:29,520
all run entirely off software that was

00:02:28,640 --> 00:02:33,440
homegrown

00:02:29,520 --> 00:02:35,920
mostly open source mostly linux based

00:02:33,440 --> 00:02:37,599
and one of the reasons i love this is

00:02:35,920 --> 00:02:40,720
not just because of the open source

00:02:37,599 --> 00:02:41,200
for the sake of it but it helps networks

00:02:40,720 --> 00:02:42,959
become

00:02:41,200 --> 00:02:44,480
increasingly programmable by their

00:02:42,959 --> 00:02:46,319
owners by the owners and

00:02:44,480 --> 00:02:47,840
operators because essentially what

00:02:46,319 --> 00:02:49,680
they've done is

00:02:47,840 --> 00:02:51,519
over the last few years the owners and

00:02:49,680 --> 00:02:53,599
operators of large networks have stepped

00:02:51,519 --> 00:02:54,400
in and taken control over how their

00:02:53,599 --> 00:02:57,519
networks

00:02:54,400 --> 00:02:59,519
are run it allows

00:02:57,519 --> 00:03:00,640
those who own and operate networks to

00:02:59,519 --> 00:03:03,120
differentiate

00:03:00,640 --> 00:03:04,800
and introduce new ideas for themselves

00:03:03,120 --> 00:03:05,760
and i think that has to be good for

00:03:04,800 --> 00:03:09,040
networking

00:03:05,760 --> 00:03:09,040
in the in the future

00:03:11,200 --> 00:03:15,760
so a quick outline this is a rough

00:03:14,000 --> 00:03:18,640
outline a rough path through

00:03:15,760 --> 00:03:19,200
uh what i'm going to be saying today

00:03:18,640 --> 00:03:20,959
through the

00:03:19,200 --> 00:03:22,879
through the works of the this this group

00:03:20,959 --> 00:03:26,319
express data path ebpf

00:03:22,879 --> 00:03:27,360
has now let us program very fast

00:03:26,319 --> 00:03:30,480
forwarding behavior

00:03:27,360 --> 00:03:32,959
into the kernel and in parallel

00:03:30,480 --> 00:03:33,920
we're seeing new sort of a new class of

00:03:32,959 --> 00:03:35,760
programmable

00:03:33,920 --> 00:03:38,239
usually p4 programmable forwarding

00:03:35,760 --> 00:03:38,720
pipelines hardware accelerators smart

00:03:38,239 --> 00:03:42,799
knicks

00:03:38,720 --> 00:03:46,000
and and switches so how can we bring

00:03:42,799 --> 00:03:47,920
these benefits together end to end are

00:03:46,000 --> 00:03:50,480
they mutually exclusive

00:03:47,920 --> 00:03:51,280
are they in opposition to each other can

00:03:50,480 --> 00:03:53,200
we actually

00:03:51,280 --> 00:03:54,799
find a way to have the benefits of both

00:03:53,200 --> 00:03:55,120
and i hope that we decide to figure this

00:03:54,799 --> 00:03:57,519
out

00:03:55,120 --> 00:03:58,640
together because i think that separately

00:03:57,519 --> 00:04:01,200
um this will

00:03:58,640 --> 00:04:02,959
this will only confuse developers and

00:04:01,200 --> 00:04:03,680
and users so if we can figure out how to

00:04:02,959 --> 00:04:05,439
do this

00:04:03,680 --> 00:04:06,959
i think that networking will be much

00:04:05,439 --> 00:04:07,920
better off for it and that's why i'm

00:04:06,959 --> 00:04:09,760
here today

00:04:07,920 --> 00:04:11,200
to talk about that let me start with a

00:04:09,760 --> 00:04:14,959
little bit of my own

00:04:11,200 --> 00:04:18,400
journey um this is actually uh uh

00:04:14,959 --> 00:04:18,959
all the way back to 1990 uh the story

00:04:18,400 --> 00:04:21,199
i'd like you

00:04:18,959 --> 00:04:22,880
to to share with you was uh when i was a

00:04:21,199 --> 00:04:26,720
graduate student at berkeley

00:04:22,880 --> 00:04:28,720
um just down the corridor from where um

00:04:26,720 --> 00:04:30,240
my carol and and van jacobson were

00:04:28,720 --> 00:04:32,800
working on uh

00:04:30,240 --> 00:04:34,560
i guess at that time 4.4 bsd the

00:04:32,800 --> 00:04:35,040
internet was still called the nsf net

00:04:34,560 --> 00:04:36,800
and

00:04:35,040 --> 00:04:38,080
routers were called cisco boxes if you

00:04:36,800 --> 00:04:42,000
can believe it uh

00:04:38,080 --> 00:04:44,400
cisco was building routers based on cpus

00:04:42,000 --> 00:04:45,040
that were connected to each other over a

00:04:44,400 --> 00:04:47,919
vme

00:04:45,040 --> 00:04:49,600
backbone a backplane and uh they could

00:04:47,919 --> 00:04:51,600
process a whopping 10

00:04:49,600 --> 00:04:52,960
000 packets per second i remember when

00:04:51,600 --> 00:04:55,440
the first 10 000

00:04:52,960 --> 00:04:56,639
packet per second router was uh was

00:04:55,440 --> 00:04:58,560
announced

00:04:56,639 --> 00:05:00,160
and as as graduate students we were kind

00:04:58,560 --> 00:05:01,520
of fearless and didn't really know what

00:05:00,160 --> 00:05:02,880
we were doing so we thought it'd be fun

00:05:01,520 --> 00:05:05,680
to try and build a

00:05:02,880 --> 00:05:06,880
multi-port fddi router which we called

00:05:05,680 --> 00:05:09,919
the bay bridge

00:05:06,880 --> 00:05:11,680
and this bay bridge shown here uh had

00:05:09,919 --> 00:05:13,919
the intent of trying to

00:05:11,680 --> 00:05:15,199
kind of one-up the commercial device

00:05:13,919 --> 00:05:16,639
commercial systems

00:05:15,199 --> 00:05:18,880
there were these new programmable logic

00:05:16,639 --> 00:05:22,240
devices called cpl cplds

00:05:18,880 --> 00:05:23,680
complex uh programmable logic devices

00:05:22,240 --> 00:05:25,520
and they were a little bit like the the

00:05:23,680 --> 00:05:26,800
precursor to the fpga and they they

00:05:25,520 --> 00:05:28,800
could they contained about 10

00:05:26,800 --> 00:05:30,639
000 logic gates and so we set out to

00:05:28,800 --> 00:05:32,720
build a hardware accelerator

00:05:30,639 --> 00:05:33,680
um that could accelerate the core of a

00:05:32,720 --> 00:05:35,600
router and we can

00:05:33,680 --> 00:05:37,919
controlled it from the s bus of the sun

00:05:35,600 --> 00:05:40,160
workstation um this is the uh

00:05:37,919 --> 00:05:42,000
hardware in the middle here uh that was

00:05:40,160 --> 00:05:44,560
actually doing the packet processing

00:05:42,000 --> 00:05:46,400
um and then at the top here is the sun

00:05:44,560 --> 00:05:48,880
workstation that we were using to

00:05:46,400 --> 00:05:50,400
to control them and the packets were

00:05:48,880 --> 00:05:50,880
processed in hardware in something that

00:05:50,400 --> 00:05:54,000
we call

00:05:50,880 --> 00:05:55,759
the protocol converter so we developed

00:05:54,000 --> 00:05:57,199
our own microcode language

00:05:55,759 --> 00:05:59,199
it seemed seemed like the right thing to

00:05:57,199 --> 00:06:00,479
do at the time for expressing how the

00:05:59,199 --> 00:06:02,800
packets should be

00:06:00,479 --> 00:06:04,319
should be processed the good news was

00:06:02,800 --> 00:06:06,000
that this made it very fast for the time

00:06:04,319 --> 00:06:07,440
it could process uh

00:06:06,000 --> 00:06:09,280
over a hundred thousand packets per

00:06:07,440 --> 00:06:10,560
second about ten times the fastest

00:06:09,280 --> 00:06:11,919
commercial routers at the time

00:06:10,560 --> 00:06:14,080
not that surprising because they were

00:06:11,919 --> 00:06:17,440
built from from cpus and not

00:06:14,080 --> 00:06:19,440
particularly optimized for performance

00:06:17,440 --> 00:06:21,759
um it sat on the the berkeley campus

00:06:19,440 --> 00:06:24,560
fddi ring for about five years

00:06:21,759 --> 00:06:25,840
uh and we went off to do other things i

00:06:24,560 --> 00:06:27,759
that we were at the time we were

00:06:25,840 --> 00:06:30,240
interested in zero copy

00:06:27,759 --> 00:06:32,080
uh stacks the memory mapped interfaces

00:06:30,240 --> 00:06:34,319
that were inspired by van jacobson's

00:06:32,080 --> 00:06:34,960
work on the witless driver that some of

00:06:34,319 --> 00:06:37,840
you may

00:06:34,960 --> 00:06:39,280
remember and so we were trying to figure

00:06:37,840 --> 00:06:39,840
out how to do that we went away for a

00:06:39,280 --> 00:06:42,080
while

00:06:39,840 --> 00:06:43,680
and then we came back and we came back

00:06:42,080 --> 00:06:46,240
because we wanted to add some features

00:06:43,680 --> 00:06:49,840
to this to this router

00:06:46,240 --> 00:06:53,199
and this was my first wake-up call on

00:06:49,840 --> 00:06:55,759
the rapid obsolescence not only of

00:06:53,199 --> 00:06:57,520
microcode that uh that you've had to

00:06:55,759 --> 00:06:58,319
struggle over to try and get the machine

00:06:57,520 --> 00:07:00,319
to work

00:06:58,319 --> 00:07:02,479
but the obsolescence of brain cells

00:07:00,319 --> 00:07:05,199
because we couldn't remember

00:07:02,479 --> 00:07:07,199
how to program it and so it took us

00:07:05,199 --> 00:07:09,520
longer to add a simple feature

00:07:07,199 --> 00:07:10,880
i think it was just doing an acl than it

00:07:09,520 --> 00:07:13,199
had done to then

00:07:10,880 --> 00:07:14,240
taken us to originally program the base

00:07:13,199 --> 00:07:17,039
behavior

00:07:14,240 --> 00:07:18,319
so this this lesson struck we stuck with

00:07:17,039 --> 00:07:19,599
me for many years

00:07:18,319 --> 00:07:22,000
so having something that was

00:07:19,599 --> 00:07:24,000
programmable that was a vliw

00:07:22,000 --> 00:07:24,639
microcontroller it seemed super clever

00:07:24,000 --> 00:07:28,160
at the

00:07:24,639 --> 00:07:31,360
at the time but um it it made me

00:07:28,160 --> 00:07:32,800
very skeptical of the idea of hardware

00:07:31,360 --> 00:07:34,560
accelerators things that you would

00:07:32,800 --> 00:07:38,000
program in microcode

00:07:34,560 --> 00:07:40,720
for whether that's switches or necks

00:07:38,000 --> 00:07:41,440
so when the when the term npu or network

00:07:40,720 --> 00:07:44,960
processor

00:07:41,440 --> 00:07:47,599
started to be used in the late 1990s

00:07:44,960 --> 00:07:50,240
i was extremely skeptical i would debate

00:07:47,599 --> 00:07:52,560
and argue on panels with mpu designers

00:07:50,240 --> 00:07:54,800
that mpus just weren't the right

00:07:52,560 --> 00:07:58,000
solution for the problem

00:07:54,800 --> 00:08:01,599
mpus such as the ixp were basically

00:07:58,000 --> 00:08:03,919
an array of cpu cores thrown onto a die

00:08:01,599 --> 00:08:05,360
that's a little harsh but it wasn't as

00:08:03,919 --> 00:08:08,080
though they had stepped back

00:08:05,360 --> 00:08:09,680
and said what is the right way to build

00:08:08,080 --> 00:08:11,039
a domain specific processor for

00:08:09,680 --> 00:08:13,440
processing

00:08:11,039 --> 00:08:14,479
packet headers incoming packets were

00:08:13,440 --> 00:08:16,240
sent to a core

00:08:14,479 --> 00:08:18,319
and then they had a process to go to to

00:08:16,240 --> 00:08:21,599
a run to completion model

00:08:18,319 --> 00:08:24,240
um it struck me as as is a little bit

00:08:21,599 --> 00:08:26,240
lazy actually because

00:08:24,240 --> 00:08:28,080
you you were using the same instruction

00:08:26,240 --> 00:08:30,560
set the same

00:08:28,080 --> 00:08:31,280
model of parallelism that was on a cpu

00:08:30,560 --> 00:08:33,360
that wasn't

00:08:31,280 --> 00:08:34,560
actually designed for networking in the

00:08:33,360 --> 00:08:36,719
in the first place

00:08:34,560 --> 00:08:39,120
networking as we know the process

00:08:36,719 --> 00:08:41,519
packets at high speed we need

00:08:39,120 --> 00:08:42,719
extremely deep pipelines and very very

00:08:41,519 --> 00:08:44,640
fast i o

00:08:42,719 --> 00:08:46,720
neither of which is present whether it's

00:08:44,640 --> 00:08:50,399
a single single single cpu

00:08:46,720 --> 00:08:50,399
or an array of cores

00:08:51,120 --> 00:08:54,399
and they are real pain in the to program

00:08:53,680 --> 00:08:55,760
too

00:08:54,399 --> 00:08:57,680
if you've ever tried programming one you

00:08:55,760 --> 00:08:58,959
know when i you know what i mean

00:08:57,680 --> 00:09:01,519
you couldn't get the right the code to

00:08:58,959 --> 00:09:03,440
run deterministically you had to start

00:09:01,519 --> 00:09:05,600
basically start over each time you

00:09:03,440 --> 00:09:07,519
wanted to add a new new feature

00:09:05,600 --> 00:09:08,640
so networking customers as we know and

00:09:07,519 --> 00:09:10,880
ben and and

00:09:08,640 --> 00:09:12,000
industry benchmarks kind of demand that

00:09:10,880 --> 00:09:14,800
we have

00:09:12,000 --> 00:09:15,519
reliable line rate deterministic

00:09:14,800 --> 00:09:17,600
processing

00:09:15,519 --> 00:09:19,760
of packets so it just struck me as kind

00:09:17,600 --> 00:09:22,240
of the wrong way of approaching it

00:09:19,760 --> 00:09:25,040
so i continue to be a big skeptic of

00:09:22,240 --> 00:09:27,279
mpus and programmable approaches fpgas

00:09:25,040 --> 00:09:30,399
etc for forwarding

00:09:27,279 --> 00:09:32,399
whether it was in the cpu or not and i

00:09:30,399 --> 00:09:35,040
would i got into the habit of including

00:09:32,399 --> 00:09:36,480
this slide in many of my many of my

00:09:35,040 --> 00:09:38,160
talks

00:09:36,480 --> 00:09:40,240
it may be a bit of a cheap shot but it

00:09:38,160 --> 00:09:41,920
compares the speed of switch chips i've

00:09:40,240 --> 00:09:44,560
extended it since out until

00:09:41,920 --> 00:09:46,480
today in 2020 but it compares the speed

00:09:44,560 --> 00:09:48,399
of switch chips for which today we're at

00:09:46,480 --> 00:09:50,640
about 12.8 terabits per second

00:09:48,399 --> 00:09:52,080
and go and buy a switch chip from two or

00:09:50,640 --> 00:09:55,360
three different vendors

00:09:52,080 --> 00:09:59,839
uh with 128 ports of 100 gig

00:09:55,360 --> 00:10:01,279
um on them and uh as as a consequence

00:09:59,839 --> 00:10:03,760
you know you really have to ask the

00:10:01,279 --> 00:10:04,560
question of what would it take for a cpu

00:10:03,760 --> 00:10:05,920
to keep up

00:10:04,560 --> 00:10:07,360
if i look at the sort of the hero

00:10:05,920 --> 00:10:08,880
experiments that have been done we can

00:10:07,360 --> 00:10:10,000
debate and argue about the particular

00:10:08,880 --> 00:10:13,440
numbers on here

00:10:10,000 --> 00:10:15,279
this is roughly how the

00:10:13,440 --> 00:10:16,640
sort of two or three protocols being

00:10:15,279 --> 00:10:19,040
processed uh

00:10:16,640 --> 00:10:19,760
in the in whether it's in the kernel or

00:10:19,040 --> 00:10:23,040
or in

00:10:19,760 --> 00:10:24,000
in user space or on bare metal on a on a

00:10:23,040 --> 00:10:25,920
cpu

00:10:24,000 --> 00:10:27,920
and and when i started collecting this

00:10:25,920 --> 00:10:28,880
graph back in about 2000 the difference

00:10:27,920 --> 00:10:34,079
in speed was about

00:10:28,880 --> 00:10:34,079
5x between the two now it's over 100x

00:10:34,800 --> 00:10:41,680
so i came to the conclusion that it was

00:10:39,279 --> 00:10:43,680
inevitable that for the very highest

00:10:41,680 --> 00:10:46,000
performance we would always use

00:10:43,680 --> 00:10:47,360
something that was fixed that was the

00:10:46,000 --> 00:10:50,399
conclusion i came to the

00:10:47,360 --> 00:10:53,040
at the time that would be based on

00:10:50,399 --> 00:10:54,000
a deep pipeline high-speed io and a

00:10:53,040 --> 00:10:56,160
fixed sequence

00:10:54,000 --> 00:10:57,920
of operations that corresponded to

00:10:56,160 --> 00:11:00,959
standard protocols this would give us

00:10:57,920 --> 00:11:03,519
the lowest power the most likely that we

00:11:00,959 --> 00:11:07,920
could fit it onto a single die

00:11:03,519 --> 00:11:07,920
and therefore the lowest overall cost

00:11:08,640 --> 00:11:13,200
just to make a comparison today you can

00:11:11,600 --> 00:11:14,079
buy a switch chip that will do roughly

00:11:13,200 --> 00:11:16,880
10 10

00:11:14,079 --> 00:11:19,279
terabits per second uh process 40

00:11:16,880 --> 00:11:22,000
protocols for about 400 watts

00:11:19,279 --> 00:11:23,920
round numbers if you wanted to do 10

00:11:22,000 --> 00:11:26,160
terabits per second on cpus

00:11:23,920 --> 00:11:28,079
and only four protocols it would require

00:11:26,160 --> 00:11:30,160
about 25 kilowatts

00:11:28,079 --> 00:11:32,160
so the difference doesn't make the the

00:11:30,160 --> 00:11:33,360
cpu an alternative for the very highest

00:11:32,160 --> 00:11:35,360
performance and why is this

00:11:33,360 --> 00:11:37,519
the cpu is optimized for memory load

00:11:35,360 --> 00:11:39,600
store and locality in caches

00:11:37,519 --> 00:11:40,560
the switch asic is optimized for i o and

00:11:39,600 --> 00:11:42,000
d pipelining

00:11:40,560 --> 00:11:44,000
corresponding to the problem that it's

00:11:42,000 --> 00:11:45,200
trying to address so my takeaway is that

00:11:44,000 --> 00:11:46,720
switches will be asics for the

00:11:45,200 --> 00:11:48,800
foreseeable future

00:11:46,720 --> 00:11:50,720
and i got into the habit of of of

00:11:48,800 --> 00:11:52,480
quoting this and in fact i think i may

00:11:50,720 --> 00:11:53,600
be the one that originally said it

00:11:52,480 --> 00:11:56,079
so i don't think that makes it a

00:11:53,600 --> 00:11:57,760
conventional wisdom but it was

00:11:56,079 --> 00:12:00,000
it was something that i think was very

00:11:57,760 --> 00:12:02,880
much on many people's mind at the time

00:12:00,000 --> 00:12:04,560
that programmable switches run 10 to 100

00:12:02,880 --> 00:12:08,639
times slower consume more

00:12:04,560 --> 00:12:10,639
power and cost more inherently

00:12:08,639 --> 00:12:11,760
the industry went the direction of fixed

00:12:10,639 --> 00:12:13,760
pipelines

00:12:11,760 --> 00:12:15,600
uh and this is a sort of a cartoon

00:12:13,760 --> 00:12:17,040
picture of what the majority of the

00:12:15,600 --> 00:12:19,440
insides of a switch asic

00:12:17,040 --> 00:12:20,079
uh look like today packets would arrive

00:12:19,440 --> 00:12:21,839
on the red

00:12:20,079 --> 00:12:23,600
in on the red lines on the left hand

00:12:21,839 --> 00:12:25,600
side of the of the slide

00:12:23,600 --> 00:12:27,200
go through a parser which has been fixed

00:12:25,600 --> 00:12:29,360
and baked into hardware that tells it

00:12:27,200 --> 00:12:33,120
the protocols that it's expected to see

00:12:29,360 --> 00:12:34,720
and how to split apart or or type the

00:12:33,120 --> 00:12:37,120
the header fields that it will find and

00:12:34,720 --> 00:12:38,880
then go along a pipeline so that

00:12:37,120 --> 00:12:40,240
multiple packets are being processed

00:12:38,880 --> 00:12:42,160
in parallel at the same time at

00:12:40,240 --> 00:12:44,560
different processing stages

00:12:42,160 --> 00:12:45,440
all with fixed functions and the reason

00:12:44,560 --> 00:12:47,839
for the pipeline

00:12:45,440 --> 00:12:48,480
is the parallelism that it gives but

00:12:47,839 --> 00:12:50,639
also

00:12:48,480 --> 00:12:52,000
uh the the because there's a little bit

00:12:50,639 --> 00:12:54,160
of serial dependency

00:12:52,000 --> 00:12:55,440
in in header processing it kind of helps

00:12:54,160 --> 00:12:56,240
you to have it in a pipeline so you can

00:12:55,440 --> 00:12:58,560
do one thing

00:12:56,240 --> 00:13:00,720
after another and eventually the packets

00:12:58,560 --> 00:13:03,040
are sent out along their way

00:13:00,720 --> 00:13:04,320
the limitations of this are obviously

00:13:03,040 --> 00:13:07,920
pretty clear

00:13:04,320 --> 00:13:09,519
if you have a a a router or a switch for

00:13:07,920 --> 00:13:10,800
which you've got some functionality that

00:13:09,519 --> 00:13:14,079
you want to

00:13:10,800 --> 00:13:17,839
um that you want to show

00:13:14,079 --> 00:13:19,920
you've got some something like ospf bgp

00:13:17,839 --> 00:13:22,240
other routing protocols on the top and

00:13:19,920 --> 00:13:23,920
then a switch os which is controlling a

00:13:22,240 --> 00:13:24,399
pipeline underneath as packets come

00:13:23,920 --> 00:13:27,760
through

00:13:24,399 --> 00:13:27,760
headers are processed like this

00:13:27,839 --> 00:13:31,360
and as those as those headers are being

00:13:30,639 --> 00:13:35,279
processed

00:13:31,360 --> 00:13:38,320
in that pipeline makes sense to to ask

00:13:35,279 --> 00:13:41,600
can i add new functionality so

00:13:38,320 --> 00:13:44,800
um as an example back in 2010

00:13:41,600 --> 00:13:47,839
there was a desire to add vxlan as a new

00:13:44,800 --> 00:13:48,480
packet header field vxlan was i think

00:13:47,839 --> 00:13:50,560
originally

00:13:48,480 --> 00:13:52,320
proposed by vmware and cisco for the

00:13:50,560 --> 00:13:53,600
purpose of identifying different tenants

00:13:52,320 --> 00:13:57,040
within a multi-tenant

00:13:53,600 --> 00:13:58,800
data center so if you wanted to add the

00:13:57,040 --> 00:14:00,160
software it was essentially adding a new

00:13:58,800 --> 00:14:02,639
table to the software

00:14:00,160 --> 00:14:04,959
uh the top at the top and being able to

00:14:02,639 --> 00:14:06,240
index into that table as packets arrived

00:14:04,959 --> 00:14:08,160
but because it required a new packet

00:14:06,240 --> 00:14:09,760
header that the chips didn't know about

00:14:08,160 --> 00:14:11,680
it required the addition of a new

00:14:09,760 --> 00:14:13,440
pipeline stage

00:14:11,680 --> 00:14:14,720
so whereas adding the software at the

00:14:13,440 --> 00:14:17,440
top probably took

00:14:14,720 --> 00:14:18,160
a few weeks maybe a month or two to to

00:14:17,440 --> 00:14:21,040
add

00:14:18,160 --> 00:14:22,880
it was four years before the first

00:14:21,040 --> 00:14:25,680
merchant switching silicon showed up

00:14:22,880 --> 00:14:27,360
that had this part of the pipeline now

00:14:25,680 --> 00:14:28,480
you could say it's a kind of an esoteric

00:14:27,360 --> 00:14:31,519
feature but it wasn't

00:14:28,480 --> 00:14:33,600
it was the most

00:14:31,519 --> 00:14:34,959
sought after feature in the most

00:14:33,600 --> 00:14:37,120
profitable part of

00:14:34,959 --> 00:14:38,720
networking at the time and it took four

00:14:37,120 --> 00:14:40,240
years to add a new feature

00:14:38,720 --> 00:14:42,320
i know it takes a long time to add new

00:14:40,240 --> 00:14:44,160
things to the kernel but even at four

00:14:42,320 --> 00:14:46,560
years this is uh this is kind of pretty

00:14:44,160 --> 00:14:47,680
uh pretty crazy and so just it just

00:14:46,560 --> 00:14:50,000
strikes me that

00:14:47,680 --> 00:14:51,360
we have the wrong development model when

00:14:50,000 --> 00:14:54,399
it comes to

00:14:51,360 --> 00:14:55,279
changing modifying upgrading adding new

00:14:54,399 --> 00:14:57,839
ideas to

00:14:55,279 --> 00:14:58,720
the way that we process packets in in

00:14:57,839 --> 00:15:00,480
networks

00:14:58,720 --> 00:15:02,800
and it's not surprising that the sort of

00:15:00,480 --> 00:15:05,920
the the way that we process packets

00:15:02,800 --> 00:15:06,800
has moved very slowly and stagnated and

00:15:05,920 --> 00:15:08,399
at the end of the day

00:15:06,800 --> 00:15:13,839
it's determined by chip designers and

00:15:08,399 --> 00:15:13,839
chip designers don't operate networks

00:15:14,000 --> 00:15:17,120
so the first programmable switches that

00:15:15,519 --> 00:15:21,199
came along um

00:15:17,120 --> 00:15:22,639
were in terms of the approach there were

00:15:21,199 --> 00:15:25,199
separate logic devices like the one i

00:15:22,639 --> 00:15:27,279
showed you earlier or fpgas npus

00:15:25,199 --> 00:15:29,279
and sort of some asics for example

00:15:27,279 --> 00:15:31,120
fulcrum easy chip x client and the cisco

00:15:29,279 --> 00:15:33,839
doppler there are a few more too

00:15:31,120 --> 00:15:35,279
that were around um but none made it

00:15:33,839 --> 00:15:37,519
really very easy

00:15:35,279 --> 00:15:38,639
to write for developers to write code

00:15:37,519 --> 00:15:42,160
for themselves

00:15:38,639 --> 00:15:43,040
um they they usually had sort of fairly

00:15:42,160 --> 00:15:45,519
complex

00:15:43,040 --> 00:15:47,600
uh programming models internally and so

00:15:45,519 --> 00:15:49,279
therefore they had to rely on the

00:15:47,600 --> 00:15:51,040
developers had to rely on the device

00:15:49,279 --> 00:15:53,600
manufacturer to write the code

00:15:51,040 --> 00:15:55,519
and as i say device manufacturers don't

00:15:53,600 --> 00:15:56,959
operate large networks chip designers

00:15:55,519 --> 00:15:58,480
don't operate large networks so they're

00:15:56,959 --> 00:16:00,079
not quite sure what to add they're not

00:15:58,480 --> 00:16:03,279
going to be the ones to innovate

00:16:00,079 --> 00:16:07,279
so they tend to fall back to just

00:16:03,279 --> 00:16:09,759
implementing existing standards and

00:16:07,279 --> 00:16:10,480
that means that everything is specified

00:16:09,759 --> 00:16:12,560
bottom up

00:16:10,480 --> 00:16:14,480
from the way that the chip is designed

00:16:12,560 --> 00:16:16,399
and it's very hard to introduce

00:16:14,480 --> 00:16:19,199
new ideas and everything kind of tends

00:16:16,399 --> 00:16:19,199
to stagnate

00:16:20,079 --> 00:16:25,600
so what what would work as a

00:16:23,279 --> 00:16:27,120
as an alternative approach and and kind

00:16:25,600 --> 00:16:29,440
of what was needed

00:16:27,120 --> 00:16:31,120
uh they were there were a bunch of us

00:16:29,440 --> 00:16:34,399
that were kind of looking over the wall

00:16:31,120 --> 00:16:37,199
into other areas of compute uh

00:16:34,399 --> 00:16:38,720
and wondering what was being done there

00:16:37,199 --> 00:16:40,560
we're all familiar with this model of

00:16:38,720 --> 00:16:43,279
course we write in a high-level language

00:16:40,560 --> 00:16:45,279
compiled down to run on a cpu and it's

00:16:43,279 --> 00:16:46,959
general purpose cpu kind of optimized to

00:16:45,279 --> 00:16:47,839
be able to accept a general purpose

00:16:46,959 --> 00:16:50,079
program

00:16:47,839 --> 00:16:51,519
graphics uh has been one of the most

00:16:50,079 --> 00:16:54,959
successful

00:16:51,519 --> 00:16:57,120
creations of both a domain specific

00:16:54,959 --> 00:16:59,600
processor and a domain specific language

00:16:57,120 --> 00:17:01,040
to to program it we know the model we

00:16:59,600 --> 00:17:03,920
write programs at a high level

00:17:01,040 --> 00:17:04,799
we compile them down to run very fast on

00:17:03,920 --> 00:17:07,280
that hardware

00:17:04,799 --> 00:17:08,959
the key thing about that device is it

00:17:07,280 --> 00:17:10,880
has an instruction set that's optimized

00:17:08,959 --> 00:17:12,799
for graphics and rendering etc and it

00:17:10,880 --> 00:17:14,640
turned out for machine learning as well

00:17:12,799 --> 00:17:16,720
and it has a good model of parallelism

00:17:14,640 --> 00:17:17,600
that allows these programs to run very

00:17:16,720 --> 00:17:18,799
fast

00:17:17,600 --> 00:17:20,720
for those who remember the digital

00:17:18,799 --> 00:17:21,360
signal processors that were originally

00:17:20,720 --> 00:17:24,000
designed

00:17:21,360 --> 00:17:25,280
way back in the sort of the 1980s 1990s

00:17:24,000 --> 00:17:28,480
the same model again

00:17:25,280 --> 00:17:29,440
and then more recently the the tpu for

00:17:28,480 --> 00:17:31,440
machine learning

00:17:29,440 --> 00:17:32,720
so this high-level language compiled

00:17:31,440 --> 00:17:35,360
down to

00:17:32,720 --> 00:17:36,559
a a device which has been optimized from

00:17:35,360 --> 00:17:37,520
an instruction set and a model of

00:17:36,559 --> 00:17:39,039
parallelism

00:17:37,520 --> 00:17:40,720
seems to be the way that we're going and

00:17:39,039 --> 00:17:42,720
it never really happened in network

00:17:40,720 --> 00:17:45,360
networking we didn't have the language

00:17:42,720 --> 00:17:47,840
that allowed you to express the behavior

00:17:45,360 --> 00:17:48,640
that would lend itself to running a very

00:17:47,840 --> 00:17:52,320
high speed

00:17:48,640 --> 00:17:54,799
in a unrolled feed-forward path

00:17:52,320 --> 00:17:56,080
on on a hardware accelerator and we

00:17:54,799 --> 00:17:59,200
didn't have the devices

00:17:56,080 --> 00:18:01,360
upon which they would run so stepping

00:17:59,200 --> 00:18:04,400
back in about 2010

00:18:01,360 --> 00:18:06,799
uh a a few of us started to ask the

00:18:04,400 --> 00:18:09,440
question what would it take to design

00:18:06,799 --> 00:18:12,480
a new domain specific processor that was

00:18:09,440 --> 00:18:14,400
optimized for processing packet headers

00:18:12,480 --> 00:18:17,919
that was easy for network owners and

00:18:14,400 --> 00:18:19,520
operators to program for themselves

00:18:17,919 --> 00:18:21,440
and could be programmed using a

00:18:19,520 --> 00:18:23,600
high-level language that was independent

00:18:21,440 --> 00:18:26,559
of the hardware

00:18:23,600 --> 00:18:27,919
such that the compiled code always runs

00:18:26,559 --> 00:18:28,720
at line rate you don't have to think

00:18:27,919 --> 00:18:30,880
about it

00:18:28,720 --> 00:18:32,640
without compromising power performance

00:18:30,880 --> 00:18:33,520
or error what what would it take to do

00:18:32,640 --> 00:18:35,039
that

00:18:33,520 --> 00:18:37,120
now i wasn't going to be able to figure

00:18:35,039 --> 00:18:40,160
this one out on my own

00:18:37,120 --> 00:18:42,320
so i teamed up with a group of folks at

00:18:40,160 --> 00:18:44,559
texas instruments and we started a a

00:18:42,320 --> 00:18:47,440
project between stanford and ti

00:18:44,559 --> 00:18:48,720
at that time and uh when ti got out of

00:18:47,440 --> 00:18:51,200
the big asic business

00:18:48,720 --> 00:18:52,160
we uh moved this into what became

00:18:51,200 --> 00:18:54,000
barefoot networks

00:18:52,160 --> 00:18:55,760
and i was lucky to work with both pat

00:18:54,000 --> 00:18:58,320
bossart and martin izzard

00:18:55,760 --> 00:18:58,880
on the creation of of barefoot and some

00:18:58,320 --> 00:19:01,919
of these

00:18:58,880 --> 00:19:03,600
ideas and the basic idea was to try and

00:19:01,919 --> 00:19:07,360
identify that language

00:19:03,600 --> 00:19:10,320
and that that processor we were

00:19:07,360 --> 00:19:11,280
became they're interested in the the p4

00:19:10,320 --> 00:19:14,880
language

00:19:11,280 --> 00:19:16,799
and helping to uh sort of establish that

00:19:14,880 --> 00:19:18,640
that movement around a language for

00:19:16,799 --> 00:19:19,440
which you could specify behaviors that

00:19:18,640 --> 00:19:21,840
would be

00:19:19,440 --> 00:19:23,120
compiled down to run at line rate and

00:19:21,840 --> 00:19:26,080
then for the forwarding

00:19:23,120 --> 00:19:27,679
pipeline we came to call that pisa for

00:19:26,080 --> 00:19:29,679
the protocol independent

00:19:27,679 --> 00:19:31,440
switch architecture this is sort of a

00:19:29,679 --> 00:19:33,679
cartoon picture here

00:19:31,440 --> 00:19:35,360
um some of you may have seen it before

00:19:33,679 --> 00:19:37,120
but i'm just going to go briefly through

00:19:35,360 --> 00:19:37,520
how this works give you a sense of what

00:19:37,120 --> 00:19:39,440
the

00:19:37,520 --> 00:19:40,720
kind of the forwarding model was that we

00:19:39,440 --> 00:19:42,480
had in mind

00:19:40,720 --> 00:19:44,320
so packets would arrive on the left just

00:19:42,480 --> 00:19:45,840
as they did on the fix function pipeline

00:19:44,320 --> 00:19:47,679
and then they enter the parser

00:19:45,840 --> 00:19:49,280
so instead of being fixed this parser is

00:19:47,679 --> 00:19:51,520
programmable it's essentially a state

00:19:49,280 --> 00:19:54,400
machine that you describe the how the

00:19:51,520 --> 00:19:55,919
how the packets are um how the packets

00:19:54,400 --> 00:19:56,720
are constructed and how you find one

00:19:55,919 --> 00:19:59,360
header from

00:19:56,720 --> 00:20:00,640
from another and from a software point

00:19:59,360 --> 00:20:02,400
of view it's essentially typing the

00:20:00,640 --> 00:20:04,400
packet header

00:20:02,400 --> 00:20:06,080
stripping apart the the packet header

00:20:04,400 --> 00:20:07,039
fields and then sticking them onto this

00:20:06,080 --> 00:20:09,039
big blue bus

00:20:07,039 --> 00:20:10,320
that goes through a typical

00:20:09,039 --> 00:20:12,320
implementation might have

00:20:10,320 --> 00:20:14,080
a several thousand bit wide bus that

00:20:12,320 --> 00:20:16,720
then goes down this pipeline

00:20:14,080 --> 00:20:17,600
each stage of the pipeline is processing

00:20:16,720 --> 00:20:20,320
a packet

00:20:17,600 --> 00:20:21,760
at the same time so in this particular

00:20:20,320 --> 00:20:23,120
case with four stages it would be

00:20:21,760 --> 00:20:24,960
processing four packets

00:20:23,120 --> 00:20:27,200
at the same time and the longer the

00:20:24,960 --> 00:20:30,000
pipeline the more parallelism that you

00:20:27,200 --> 00:20:30,720
that you have each of these stages shown

00:20:30,000 --> 00:20:34,400
here

00:20:30,720 --> 00:20:36,080
is identical uh contains a

00:20:34,400 --> 00:20:37,760
second dimension of parallelism so we

00:20:36,080 --> 00:20:39,760
have parallelism in the pipeline

00:20:37,760 --> 00:20:41,520
and then within each stage parallelism

00:20:39,760 --> 00:20:45,200
because there are multiple match

00:20:41,520 --> 00:20:45,760
action stages each of those is designed

00:20:45,200 --> 00:20:48,640
to

00:20:45,760 --> 00:20:49,760
have a general purpose match uh across

00:20:48,640 --> 00:20:53,360
exact matches

00:20:49,760 --> 00:20:56,400
or associative matches and then actions

00:20:53,360 --> 00:20:56,720
uh through a little uh alu there might

00:20:56,400 --> 00:20:58,960
be

00:20:56,720 --> 00:21:01,039
and that this picture only only shows

00:20:58,960 --> 00:21:02,960
six of these in any one stage

00:21:01,039 --> 00:21:05,600
but there might be hundreds of them in

00:21:02,960 --> 00:21:07,280
each stage so as the packets come down

00:21:05,600 --> 00:21:08,880
the fields are directed to the match

00:21:07,280 --> 00:21:10,960
action units

00:21:08,880 --> 00:21:12,960
the little processor will do processing

00:21:10,960 --> 00:21:14,640
upon it and then the modified packet

00:21:12,960 --> 00:21:17,840
would be stacked back onto the

00:21:14,640 --> 00:21:20,400
the bus some of the key things that we

00:21:17,840 --> 00:21:21,840
uh that we learned from from doing this

00:21:20,400 --> 00:21:23,840
was

00:21:21,840 --> 00:21:26,080
the stages of this pipeline are all

00:21:23,840 --> 00:21:28,400
exactly the same

00:21:26,080 --> 00:21:30,000
turns out that uh if it's very very

00:21:28,400 --> 00:21:33,120
tempting to optimize

00:21:30,000 --> 00:21:34,880
the resources that are in any one stage

00:21:33,120 --> 00:21:36,720
because of the knowledge that we have

00:21:34,880 --> 00:21:39,600
about current protocols

00:21:36,720 --> 00:21:40,320
or where we tend to do l3 before we do

00:21:39,600 --> 00:21:42,159
l4

00:21:40,320 --> 00:21:44,080
things like that and so therefore we'll

00:21:42,159 --> 00:21:46,240
put this the longest prefix match

00:21:44,080 --> 00:21:47,200
in the in the earlier stage it turns out

00:21:46,240 --> 00:21:48,799
that this this

00:21:47,200 --> 00:21:50,880
gives so many restrictions to the

00:21:48,799 --> 00:21:53,679
compiler that it becomes very hard to

00:21:50,880 --> 00:21:55,679
develop a good compiler as a consequence

00:21:53,679 --> 00:21:58,000
so in the designs that i've been part of

00:21:55,679 --> 00:21:59,919
all of the stages are identical

00:21:58,000 --> 00:22:02,400
and the number of stages is determined

00:21:59,919 --> 00:22:05,039
by the degree of serial dependency

00:22:02,400 --> 00:22:06,080
in the programs so this one shows four

00:22:05,039 --> 00:22:07,200
because that's all i could fit on the

00:22:06,080 --> 00:22:08,960
powerpoint slide

00:22:07,200 --> 00:22:11,039
but typically in practice there are sort

00:22:08,960 --> 00:22:14,240
of 16 20 25

00:22:11,039 --> 00:22:16,559
stages uh just to be able to provide

00:22:14,240 --> 00:22:17,440
room for programmers to add their own

00:22:16,559 --> 00:22:21,360
new features

00:22:17,440 --> 00:22:21,360
over and above basic protocols

00:22:21,440 --> 00:22:26,400
so just to explain this in the sort of

00:22:23,840 --> 00:22:28,400
in the animated version

00:22:26,400 --> 00:22:29,600
the packet arrives on the left hand side

00:22:28,400 --> 00:22:30,880
the different colored

00:22:29,600 --> 00:22:33,600
packet header fields are just supposed

00:22:30,880 --> 00:22:35,440
to represent different protocol fields

00:22:33,600 --> 00:22:37,360
so the parser will break them out

00:22:35,440 --> 00:22:40,320
according to a program that the user is

00:22:37,360 --> 00:22:42,559
has provided and then as those headers

00:22:40,320 --> 00:22:44,159
are presented to the match and action

00:22:42,559 --> 00:22:47,520
stages down the pipeline

00:22:44,159 --> 00:22:49,520
they will get transformed they will they

00:22:47,520 --> 00:22:51,200
they potentially could get removed if

00:22:49,520 --> 00:22:53,039
you're popping a tag for example there

00:22:51,200 --> 00:22:53,760
could be an encapsulation so new headers

00:22:53,039 --> 00:22:56,000
are created

00:22:53,760 --> 00:22:58,320
fields could get modified decrements

00:22:56,000 --> 00:23:00,240
updating of checksums things like that

00:22:58,320 --> 00:23:02,240
and then as it goes down each stage is

00:23:00,240 --> 00:23:04,240
going to get transformed according to

00:23:02,240 --> 00:23:06,080
the match action stages and rules that

00:23:04,240 --> 00:23:07,440
have been placed into that table

00:23:06,080 --> 00:23:09,679
and at the end as the packet gets

00:23:07,440 --> 00:23:12,000
reformed and then sent on its way this

00:23:09,679 --> 00:23:15,120
is the basic operation and then it's pro

00:23:12,000 --> 00:23:17,679
programmed using the p4 language and the

00:23:15,120 --> 00:23:19,919
p4 language is essentially expressing

00:23:17,679 --> 00:23:21,840
three things first of all it's telling

00:23:19,919 --> 00:23:23,679
the parser how to parse the packets

00:23:21,840 --> 00:23:26,799
that's on the left hand side

00:23:23,679 --> 00:23:29,440
it's telling the match action units

00:23:26,799 --> 00:23:30,960
how matches are structured so it's

00:23:29,440 --> 00:23:33,360
explaining the tables

00:23:30,960 --> 00:23:35,120
specifying the tables what are the how

00:23:33,360 --> 00:23:37,360
do you match what fields do you match

00:23:35,120 --> 00:23:39,600
upon and then what actions you put

00:23:37,360 --> 00:23:41,200
what you perform initially this pipeline

00:23:39,600 --> 00:23:44,080
doesn't know anything about any protocol

00:23:41,200 --> 00:23:45,679
it doesn't know about ipv4 ipv6

00:23:44,080 --> 00:23:47,760
etc and so you're telling it and

00:23:45,679 --> 00:23:49,440
describing it how it's going to

00:23:47,760 --> 00:23:50,880
how it's going to program the packets

00:23:49,440 --> 00:23:52,559
and then finally on the right hand side

00:23:50,880 --> 00:23:54,159
is the control flow this is a sequence

00:23:52,559 --> 00:23:54,799
of tables that a packet will pass

00:23:54,159 --> 00:23:57,039
through

00:23:54,799 --> 00:23:59,520
on its way through that through that

00:23:57,039 --> 00:23:59,520
pipeline

00:24:01,600 --> 00:24:05,520
so you might be thinking okay this is

00:24:03,360 --> 00:24:07,120
all very good actually that pipeline

00:24:05,520 --> 00:24:08,240
looks pretty much like the fix function

00:24:07,120 --> 00:24:09,919
one

00:24:08,240 --> 00:24:12,080
so what's the big difference clearly the

00:24:09,919 --> 00:24:15,679
big difference is that you can change

00:24:12,080 --> 00:24:17,440
what you place into this device and

00:24:15,679 --> 00:24:19,120
as you probably know barefoot built

00:24:17,440 --> 00:24:22,080
built switches that are based on this

00:24:19,120 --> 00:24:25,039
this model called defino 1 and tofino 2.

00:24:22,080 --> 00:24:25,919
and it's going to surprise me the way in

00:24:25,039 --> 00:24:28,720
which people

00:24:25,919 --> 00:24:30,640
use those devices obviously they tend to

00:24:28,720 --> 00:24:31,520
use them with standard protocols that we

00:24:30,640 --> 00:24:34,960
all know and love

00:24:31,520 --> 00:24:36,960
ipv4 ipv6 etc but they also add things

00:24:34,960 --> 00:24:39,520
in that are custom to their environment

00:24:36,960 --> 00:24:41,200
whether it's for doing load balancing is

00:24:39,520 --> 00:24:43,520
a very common layer for load balancing

00:24:41,200 --> 00:24:45,600
is a very common application

00:24:43,520 --> 00:24:46,559
adding telemetry int and band network

00:24:45,600 --> 00:24:48,559
telemetry

00:24:46,559 --> 00:24:51,039
for capturing metadata about queue

00:24:48,559 --> 00:24:51,919
occupancy switch id etc as the packet

00:24:51,039 --> 00:24:54,400
passes by

00:24:51,919 --> 00:24:55,600
we've seen all sorts of things that the

00:24:54,400 --> 00:24:56,880
different people have done i've even

00:24:55,600 --> 00:25:00,000
you've seen people use

00:24:56,880 --> 00:25:01,600
ip with non-standard address sizes

00:25:00,000 --> 00:25:03,440
um i'm not sure i particularly recommend

00:25:01,600 --> 00:25:06,720
it i don't know why someone did that

00:25:03,440 --> 00:25:10,240
i think they had a 48-bit ipv4 address

00:25:06,720 --> 00:25:10,640
each to their own so you might be

00:25:10,240 --> 00:25:13,200
thinking

00:25:10,640 --> 00:25:14,960
also uh there must be a penalty for this

00:25:13,200 --> 00:25:16,559
right so what's the penalty for this

00:25:14,960 --> 00:25:17,039
programmability we're used to the idea

00:25:16,559 --> 00:25:19,440
that

00:25:17,039 --> 00:25:20,400
a dedicated fixed function device must

00:25:19,440 --> 00:25:23,600
consume

00:25:20,400 --> 00:25:24,880
less power less area and therefore be

00:25:23,600 --> 00:25:27,200
cheaper

00:25:24,880 --> 00:25:28,799
and have higher performance after all

00:25:27,200 --> 00:25:30,240
that's what the conventional wisdom had

00:25:28,799 --> 00:25:32,400
told us

00:25:30,240 --> 00:25:33,600
so what i want to do is to to just show

00:25:32,400 --> 00:25:35,600
you one example

00:25:33,600 --> 00:25:36,960
uh i i hate showing things that look

00:25:35,600 --> 00:25:38,400
like marketing slides

00:25:36,960 --> 00:25:40,080
uh but i'm only showing you this because

00:25:38,400 --> 00:25:43,120
it's scraped from the

00:25:40,080 --> 00:25:45,120
website of a big switch vendor

00:25:43,120 --> 00:25:47,200
who happens to sell switches that use

00:25:45,120 --> 00:25:48,720
the p4 programmable tofino device shown

00:25:47,200 --> 00:25:50,159
in blue on the left

00:25:48,720 --> 00:25:52,159
against the sort of the standard fixed

00:25:50,159 --> 00:25:53,760
function device so they were both

00:25:52,159 --> 00:25:56,320
built out of the same process 16

00:25:53,760 --> 00:25:59,279
nanometer tsmc process they both had

00:25:56,320 --> 00:25:59,760
6400 gig ports 6.4 terabits per second

00:25:59,279 --> 00:26:02,559
total

00:25:59,760 --> 00:26:03,840
total capacity um the faceplates of the

00:26:02,559 --> 00:26:05,919
boxes looked uh

00:26:03,840 --> 00:26:08,240
looked identical the set of protocols

00:26:05,919 --> 00:26:10,480
and features was pretty much the same

00:26:08,240 --> 00:26:12,159
so in terms of the performance the

00:26:10,480 --> 00:26:14,080
maximum packets per second

00:26:12,159 --> 00:26:15,840
it was essentially the same the

00:26:14,080 --> 00:26:17,840
programmable device was slightly higher

00:26:15,840 --> 00:26:18,880
at just over five billion packets per

00:26:17,840 --> 00:26:20,960
second

00:26:18,880 --> 00:26:23,440
um by the way if you stop and think

00:26:20,960 --> 00:26:26,559
about five billion packets per second

00:26:23,440 --> 00:26:28,720
uh compare that with 1992

00:26:26,559 --> 00:26:30,240
of uh when we first had a hundred

00:26:28,720 --> 00:26:31,919
thousand packets per second

00:26:30,240 --> 00:26:33,760
it's pretty amazing how things have

00:26:31,919 --> 00:26:34,720
moved on at five billion packets per

00:26:33,760 --> 00:26:38,480
second

00:26:34,720 --> 00:26:41,600
that means every time a a photon

00:26:38,480 --> 00:26:44,559
moves one foot you've processed

00:26:41,600 --> 00:26:46,080
five packets uh it's it's kind of crazy

00:26:44,559 --> 00:26:48,240
to think about

00:26:46,080 --> 00:26:50,320
in terms of power power was slightly

00:26:48,240 --> 00:26:51,679
lower for this particular configuration

00:26:50,320 --> 00:26:53,600
we'll say it's the same it was

00:26:51,679 --> 00:26:54,799
essentially the same unchanged and from

00:26:53,600 --> 00:26:57,039
a latency point of view

00:26:54,799 --> 00:26:58,640
because the number of pipeline stages

00:26:57,039 --> 00:27:02,000
determines the

00:26:58,640 --> 00:27:03,840
uh the the overall latency because

00:27:02,000 --> 00:27:05,440
in a device that you're programming you

00:27:03,840 --> 00:27:06,159
don't include the protocols that you

00:27:05,440 --> 00:27:08,559
don't want

00:27:06,159 --> 00:27:10,799
it's often the case that the uh the

00:27:08,559 --> 00:27:12,240
latency ends up being slightly lower

00:27:10,799 --> 00:27:13,600
but we'll call it the same so it's

00:27:12,240 --> 00:27:14,480
essentially the same it makes no

00:27:13,600 --> 00:27:16,799
difference

00:27:14,480 --> 00:27:18,480
and this should tell us something right

00:27:16,799 --> 00:27:21,520
it should tell us that

00:27:18,480 --> 00:27:21,919
in future if you can build switches that

00:27:21,520 --> 00:27:23,919
are

00:27:21,919 --> 00:27:25,360
of the same power performance and area

00:27:23,919 --> 00:27:26,480
then probably you will because it gives

00:27:25,360 --> 00:27:27,919
you more flexibility

00:27:26,480 --> 00:27:29,840
even if you end up using the same

00:27:27,919 --> 00:27:30,720
protocols that you used before it gives

00:27:29,840 --> 00:27:32,159
you

00:27:30,720 --> 00:27:33,840
it gives you protection against the

00:27:32,159 --> 00:27:34,480
unknown it allows you to change table

00:27:33,840 --> 00:27:36,000
sizes

00:27:34,480 --> 00:27:37,760
but it allows you of course to introduce

00:27:36,000 --> 00:27:40,159
new features as you go

00:27:37,760 --> 00:27:40,799
if you want to learn more about the p4

00:27:40,159 --> 00:27:43,120
language

00:27:40,799 --> 00:27:43,919
um there's an original paper shown here

00:27:43,120 --> 00:27:46,000
from

00:27:43,919 --> 00:27:48,240
um the the that was published back in

00:27:46,000 --> 00:27:51,360
about 2014

00:27:48,240 --> 00:27:53,279
and and there's also p4.org where you'll

00:27:51,360 --> 00:27:56,240
find code and specification

00:27:53,279 --> 00:27:57,440
etc um this isn't a tutorial on p4 so

00:27:56,240 --> 00:27:59,679
i'm not going to spend any

00:27:57,440 --> 00:28:02,240
any time on that right now but the

00:27:59,679 --> 00:28:04,399
basics are essentially the following

00:28:02,240 --> 00:28:05,840
it's a language for specifying both

00:28:04,399 --> 00:28:06,880
stateless and stateful forwarding

00:28:05,840 --> 00:28:09,919
behavior

00:28:06,880 --> 00:28:11,279
in pipelines it allows you to program a

00:28:09,919 --> 00:28:14,480
sequence of

00:28:11,279 --> 00:28:16,159
parsing tables actions control flow that

00:28:14,480 --> 00:28:19,520
are not necessarily structured in the

00:28:16,159 --> 00:28:21,200
as the pisa pipeline p416 allows you to

00:28:19,520 --> 00:28:23,039
describe different architectures so

00:28:21,200 --> 00:28:25,520
there are um

00:28:23,039 --> 00:28:27,200
uh are ways in which you can compile to

00:28:25,520 --> 00:28:30,240
a variety of different

00:28:27,200 --> 00:28:31,279
structures uh from with the idea of

00:28:30,240 --> 00:28:32,640
making it so that

00:28:31,279 --> 00:28:34,000
you can have different structures

00:28:32,640 --> 00:28:36,080
constructed in different ways by

00:28:34,000 --> 00:28:38,480
different different vendors

00:28:36,080 --> 00:28:41,279
the compiler the language is designed to

00:28:38,480 --> 00:28:43,440
allow the compiler to find dependencies

00:28:41,279 --> 00:28:44,960
and opportunities for parallelism by

00:28:43,440 --> 00:28:45,760
expressing the forwarding behavior at a

00:28:44,960 --> 00:28:47,440
high level

00:28:45,760 --> 00:28:49,520
but being careful to specify the

00:28:47,440 --> 00:28:50,399
specific set of operations that you want

00:28:49,520 --> 00:28:51,679
to have happen

00:28:50,399 --> 00:28:53,520
it means they can build a serial

00:28:51,679 --> 00:28:54,000
dependency graph and therefore figure

00:28:53,520 --> 00:28:55,919
out

00:28:54,000 --> 00:28:57,679
what the opportunities for parallelism

00:28:55,919 --> 00:29:00,480
are

00:28:57,679 --> 00:29:02,080
it's loop free event driven by packets

00:29:00,480 --> 00:29:04,000
and there's no program counter

00:29:02,080 --> 00:29:06,559
so you know in some ways it's similar to

00:29:04,000 --> 00:29:09,520
eppf um it's designed to

00:29:06,559 --> 00:29:11,120
be uh be safe in the sense that it's

00:29:09,520 --> 00:29:13,840
type safe and

00:29:11,120 --> 00:29:14,799
memory safe packets are processed always

00:29:13,840 --> 00:29:17,039
at line rate

00:29:14,799 --> 00:29:18,480
in the pisa pipeline because it's a feed

00:29:17,039 --> 00:29:19,600
forward pipeline and so you've got a

00:29:18,480 --> 00:29:22,640
deterministic time

00:29:19,600 --> 00:29:24,320
through the uh through the device

00:29:22,640 --> 00:29:25,600
and also because of the clock rate is

00:29:24,320 --> 00:29:26,159
always constant because of those

00:29:25,600 --> 00:29:28,080
pipeline

00:29:26,159 --> 00:29:30,480
stages it means that you end up with a

00:29:28,080 --> 00:29:33,919
deterministic throughput

00:29:30,480 --> 00:29:34,559
the the code is or the idea of p4 is

00:29:33,919 --> 00:29:36,960
that you can

00:29:34,559 --> 00:29:38,480
write code that is hardware independent

00:29:36,960 --> 00:29:41,760
now in practice

00:29:38,480 --> 00:29:44,720
because of the specifics of the

00:29:41,760 --> 00:29:46,720
of the pipeline you end up having to

00:29:44,720 --> 00:29:48,080
tailor it somewhat to the particular

00:29:46,720 --> 00:29:50,799
device

00:29:48,080 --> 00:29:52,080
to in in order to encourage portability

00:29:50,799 --> 00:29:53,919
there is a

00:29:52,080 --> 00:29:56,240
what's called the psa or portable switch

00:29:53,919 --> 00:29:58,159
architecture which is a forwarding model

00:29:56,240 --> 00:30:00,640
for writing code 2 that should work on

00:29:58,159 --> 00:30:01,600
any device so this means that people can

00:30:00,640 --> 00:30:03,919
share code

00:30:01,600 --> 00:30:05,039
that were that was written for the for

00:30:03,919 --> 00:30:08,240
the psa

00:30:05,039 --> 00:30:09,120
and then you can extend it via opaque

00:30:08,240 --> 00:30:11,200
externs

00:30:09,120 --> 00:30:12,960
so this is for functions that have been

00:30:11,200 --> 00:30:14,159
forgotten or weren't considered

00:30:12,960 --> 00:30:16,720
important at the time

00:30:14,159 --> 00:30:17,760
or where someone has a proprietary

00:30:16,720 --> 00:30:19,279
extension

00:30:17,760 --> 00:30:21,279
to their device that they want to be

00:30:19,279 --> 00:30:23,600
able to program and access

00:30:21,279 --> 00:30:24,799
so for example the pipelines today don't

00:30:23,600 --> 00:30:26,640
allow you to program

00:30:24,799 --> 00:30:28,799
the traffic manager you can figure that

00:30:26,640 --> 00:30:30,240
separately one could easily imagine an

00:30:28,799 --> 00:30:32,000
extension in the future in which you're

00:30:30,240 --> 00:30:33,600
programming the behavior of the

00:30:32,000 --> 00:30:35,440
traffic manager and there have been some

00:30:33,600 --> 00:30:37,440
papers and ideas about this

00:30:35,440 --> 00:30:39,840
and some prototypes so this would be an

00:30:37,440 --> 00:30:42,480
example or encryption and decryption

00:30:39,840 --> 00:30:45,679
which today are not readily expressible

00:30:42,480 --> 00:30:45,679
within the p4 language

00:30:46,080 --> 00:30:49,279
so now that's been around for a while in

00:30:47,679 --> 00:30:50,480
switches you can see it beginning to

00:30:49,279 --> 00:30:54,240
show up in nicks

00:30:50,480 --> 00:30:56,240
as well in uh so-called smartnix

00:30:54,240 --> 00:30:57,600
um this is a very sort of crude picture

00:30:56,240 --> 00:31:00,480
on the left hand side

00:30:57,600 --> 00:31:01,519
of a pisa pipeline for packets going

00:31:00,480 --> 00:31:03,760
from the cpu

00:31:01,519 --> 00:31:05,679
out to the wire and and vice versa

00:31:03,760 --> 00:31:07,919
typically there's a bunch of cores there

00:31:05,679 --> 00:31:10,399
as well the top right hand corner is the

00:31:07,919 --> 00:31:13,519
the recently discussed pencendo

00:31:10,399 --> 00:31:15,519
nick and then there's the alveo board

00:31:13,519 --> 00:31:16,399
from xilinx which they program with the

00:31:15,519 --> 00:31:19,679
sdnet

00:31:16,399 --> 00:31:20,880
uh p4 compiler so we're going to

00:31:19,679 --> 00:31:22,799
i think we're going to start seeing

00:31:20,880 --> 00:31:24,720
these show up more and more

00:31:22,799 --> 00:31:27,120
as a model for expressing the forwarding

00:31:24,720 --> 00:31:30,240
behavior in the pipelines

00:31:27,120 --> 00:31:30,960
not necessarily in the cores but for the

00:31:30,240 --> 00:31:32,640
pipelines

00:31:30,960 --> 00:31:35,039
it allows you to have a deterministic

00:31:32,640 --> 00:31:38,640
forwarding behavior

00:31:35,039 --> 00:31:39,760
okay programmable switches programmable

00:31:38,640 --> 00:31:42,880
nics

00:31:39,760 --> 00:31:46,799
stepping back again what does this mean

00:31:42,880 --> 00:31:48,320
for where we're for where we're headed

00:31:46,799 --> 00:31:50,320
sort of taking stock of where we are

00:31:48,320 --> 00:31:53,279
today uh

00:31:50,320 --> 00:31:54,159
the the movement towards disaggregation

00:31:53,279 --> 00:31:57,279
which often

00:31:54,159 --> 00:31:59,600
gets described as about about cost

00:31:57,279 --> 00:32:01,039
about cost reduction i really think that

00:31:59,600 --> 00:32:02,640
it's about something slightly different

00:32:01,039 --> 00:32:05,039
i think this aggregation is

00:32:02,640 --> 00:32:06,880
about network owners and operators

00:32:05,039 --> 00:32:08,640
taking control of the software that

00:32:06,880 --> 00:32:10,240
controls their networks

00:32:08,640 --> 00:32:11,679
i think that's what it was really about

00:32:10,240 --> 00:32:14,080
and continues to be about

00:32:11,679 --> 00:32:16,000
they want to be in charge because they

00:32:14,080 --> 00:32:17,760
they it's their lifeblood

00:32:16,000 --> 00:32:19,200
and so they need to make sure that it's

00:32:17,760 --> 00:32:20,720
secure reliable

00:32:19,200 --> 00:32:23,279
and they can extend it to be able to

00:32:20,720 --> 00:32:24,880
differentiate from their competition

00:32:23,279 --> 00:32:26,799
and now they're starting to take control

00:32:24,880 --> 00:32:28,240
of how the packets are processed

00:32:26,799 --> 00:32:30,000
too because of the availability of

00:32:28,240 --> 00:32:31,919
programmable switches and

00:32:30,000 --> 00:32:34,240
and nicks and that's a sort of a

00:32:31,919 --> 00:32:37,519
transition that's just happening now

00:32:34,240 --> 00:32:40,080
and this sort of deep programmability

00:32:37,519 --> 00:32:41,840
in the the nix the switches the

00:32:40,080 --> 00:32:43,760
v-switches of course they always were

00:32:41,840 --> 00:32:46,559
and the end host networking stack

00:32:43,760 --> 00:32:47,519
they're becoming more malleable but now

00:32:46,559 --> 00:32:50,559
we're at the point

00:32:47,519 --> 00:32:52,480
where everything from the beginning to

00:32:50,559 --> 00:32:54,720
the end from one end to the other

00:32:52,480 --> 00:32:56,240
is more malleable than it was before so

00:32:54,720 --> 00:32:59,919
this opens up some interesting

00:32:56,240 --> 00:33:00,480
possibilities and where i want to go

00:32:59,919 --> 00:33:03,519
next

00:33:00,480 --> 00:33:04,240
is to address this question what does

00:33:03,519 --> 00:33:06,960
this mean

00:33:04,240 --> 00:33:08,080
for how networks are programmed what

00:33:06,960 --> 00:33:11,039
does this mean for

00:33:08,080 --> 00:33:12,480
how we will develop code develop systems

00:33:11,039 --> 00:33:13,440
develop networks what does it mean for

00:33:12,480 --> 00:33:17,679
how

00:33:13,440 --> 00:33:17,679
large networks will be will be operated

00:33:18,159 --> 00:33:25,039
so i think this first point

00:33:22,240 --> 00:33:27,200
is is perhaps obvious that we will start

00:33:25,039 --> 00:33:29,600
to think of a network as a programmable

00:33:27,200 --> 00:33:30,799
platform the behavior will be described

00:33:29,600 --> 00:33:33,039
at the top

00:33:30,799 --> 00:33:34,320
and eventually my hope is that it will

00:33:33,039 --> 00:33:36,840
be partitioned

00:33:34,320 --> 00:33:38,720
compiled and then run across the

00:33:36,840 --> 00:33:40,159
elements

00:33:38,720 --> 00:33:42,320
we're not there yet we have a lot of

00:33:40,159 --> 00:33:43,919
work to to to get there but i do think

00:33:42,320 --> 00:33:45,519
that this

00:33:43,919 --> 00:33:47,200
thinking of it as a programmable

00:33:45,519 --> 00:33:50,159
platform is

00:33:47,200 --> 00:33:50,480
just beginning to happen now rather than

00:33:50,159 --> 00:33:52,559
a

00:33:50,480 --> 00:33:53,840
collection of different elements i think

00:33:52,559 --> 00:33:56,320
every data center will work

00:33:53,840 --> 00:33:58,640
differently it will be programmed and

00:33:56,320 --> 00:34:00,399
tailored locally

00:33:58,640 --> 00:34:01,760
maybe to make it simpler to throw out

00:34:00,399 --> 00:34:02,480
protocols you don't need to make it more

00:34:01,760 --> 00:34:04,840
reliable

00:34:02,480 --> 00:34:06,000
or to add security measures whatever is

00:34:04,840 --> 00:34:07,760
needed

00:34:06,000 --> 00:34:09,599
slightly more controversial statement i

00:34:07,760 --> 00:34:11,200
i don't think we'll think in protocols

00:34:09,599 --> 00:34:12,639
nearly as much as we do

00:34:11,200 --> 00:34:14,560
today instead we're going to think in

00:34:12,639 --> 00:34:17,839
terms of software

00:34:14,560 --> 00:34:20,240
all functions and protocols will be

00:34:17,839 --> 00:34:20,879
will have migrated up and out of the

00:34:20,240 --> 00:34:22,800
hardware

00:34:20,879 --> 00:34:24,000
into software throughout the internet i

00:34:22,800 --> 00:34:26,639
think this will be true

00:34:24,000 --> 00:34:27,679
of every aspect of the internet many of

00:34:26,639 --> 00:34:29,280
you probably

00:34:27,679 --> 00:34:31,119
think like this and have this mindset

00:34:29,280 --> 00:34:31,520
already so this doesn't come as news to

00:34:31,119 --> 00:34:33,919
you

00:34:31,520 --> 00:34:35,359
but most of the most networking

00:34:33,919 --> 00:34:36,879
development is still stuck in

00:34:35,359 --> 00:34:37,919
interoperability interoperability

00:34:36,879 --> 00:34:40,079
mattered a lot

00:34:37,919 --> 00:34:41,839
when you were building devices bottom up

00:34:40,079 --> 00:34:44,079
having to make sure that they connected

00:34:41,839 --> 00:34:45,359
together correctly typically large

00:34:44,079 --> 00:34:48,000
networks today

00:34:45,359 --> 00:34:48,960
are somewhat homogeneous they they tend

00:34:48,000 --> 00:34:50,800
to use

00:34:48,960 --> 00:34:52,000
very similar equipment if you can

00:34:50,800 --> 00:34:54,399
actually program it top

00:34:52,000 --> 00:34:56,079
down and express the behavior that you

00:34:54,399 --> 00:34:57,680
want such that it's consistent across

00:34:56,079 --> 00:34:59,520
all the devices

00:34:57,680 --> 00:35:00,960
interoperability will matter but much

00:34:59,520 --> 00:35:02,240
less than it used to because you're

00:35:00,960 --> 00:35:04,400
specifying the behavior

00:35:02,240 --> 00:35:05,920
that you want and therefore the

00:35:04,400 --> 00:35:08,800
interoperability should come

00:35:05,920 --> 00:35:10,400
from design we have to figure out what

00:35:08,800 --> 00:35:11,520
this means for networking students

00:35:10,400 --> 00:35:13,200
they're going to learn how to program a

00:35:11,520 --> 00:35:14,320
network top down as a distributed

00:35:13,200 --> 00:35:16,160
computing platform

00:35:14,320 --> 00:35:17,440
and so our classes will have to evolve

00:35:16,160 --> 00:35:18,560
in this direction and we're trying to

00:35:17,440 --> 00:35:21,119
see what that means

00:35:18,560 --> 00:35:22,960
at the moment um i do think that we'll

00:35:21,119 --> 00:35:24,720
start to describe protocols in

00:35:22,960 --> 00:35:26,240
maybe even quaint historical terms

00:35:24,720 --> 00:35:28,640
routing and congestion control

00:35:26,240 --> 00:35:31,839
will be programs partitioned across the

00:35:28,640 --> 00:35:31,839
system by a compiler

00:35:32,240 --> 00:35:37,839
what i think is really potentially

00:35:35,359 --> 00:35:38,960
game-changing in the sort of the next

00:35:37,839 --> 00:35:41,920
wave that i think could be

00:35:38,960 --> 00:35:44,000
absolutely huge is the introduction of

00:35:41,920 --> 00:35:45,520
software engineering techniques

00:35:44,000 --> 00:35:47,359
routinely into networking if you think

00:35:45,520 --> 00:35:48,000
about it if we're programming our

00:35:47,359 --> 00:35:50,320
networks

00:35:48,000 --> 00:35:52,400
as a platform top down where we have a

00:35:50,320 --> 00:35:53,119
specification of the desired behavior at

00:35:52,400 --> 00:35:55,200
the top

00:35:53,119 --> 00:35:56,480
then we can work down towards where the

00:35:55,200 --> 00:35:58,880
packets are processed

00:35:56,480 --> 00:35:59,839
across either all of the layers of

00:35:58,880 --> 00:36:02,240
abstraction

00:35:59,839 --> 00:36:03,359
as we go down the apis as we head down

00:36:02,240 --> 00:36:06,079
towards the packets

00:36:03,359 --> 00:36:08,000
it gives us an opportunity to to check

00:36:06,079 --> 00:36:10,160
the correctness of that behavior

00:36:08,000 --> 00:36:12,000
whether it's through just clever unit

00:36:10,160 --> 00:36:13,839
testing all the way through to formal

00:36:12,000 --> 00:36:17,119
verification and validation

00:36:13,839 --> 00:36:17,440
on the fly for me this is reminiscent of

00:36:17,119 --> 00:36:19,040
the

00:36:17,440 --> 00:36:20,560
actually of the chip industry which does

00:36:19,040 --> 00:36:21,359
this very cleverly of formal

00:36:20,560 --> 00:36:23,280
verification

00:36:21,359 --> 00:36:24,720
across boundaries as you head down to a

00:36:23,280 --> 00:36:26,160
more and more detailed

00:36:24,720 --> 00:36:28,560
description all the way down to the

00:36:26,160 --> 00:36:30,320
transistor layout but in any big system

00:36:28,560 --> 00:36:31,839
having that ability to check that the

00:36:30,320 --> 00:36:34,000
behavior of individual packets

00:36:31,839 --> 00:36:34,800
corresponds to the original intended

00:36:34,000 --> 00:36:37,200
behavior

00:36:34,800 --> 00:36:39,280
is a long way from where we are today

00:36:37,200 --> 00:36:40,800
but many of these techniques either

00:36:39,280 --> 00:36:42,880
exist today

00:36:40,800 --> 00:36:45,040
or are within our reach and being

00:36:42,880 --> 00:36:46,480
researched and demonstrated in prototype

00:36:45,040 --> 00:36:49,040
form i think there's a lot of exciting

00:36:46,480 --> 00:36:51,119
work to be done there

00:36:49,040 --> 00:36:52,320
i do think that fine grain per packet

00:36:51,119 --> 00:36:54,560
measurement will

00:36:52,320 --> 00:36:55,599
will become very popular and very

00:36:54,560 --> 00:36:57,040
widespread

00:36:55,599 --> 00:36:59,599
not just through inband network

00:36:57,040 --> 00:37:01,280
telemetry int i think that will be

00:36:59,599 --> 00:37:02,720
one part of it i think there will be

00:37:01,280 --> 00:37:05,200
many flavors

00:37:02,720 --> 00:37:06,640
many improvements over time as soon as a

00:37:05,200 --> 00:37:08,640
device is programmable

00:37:06,640 --> 00:37:10,880
the owners and operators can decide what

00:37:08,640 --> 00:37:12,320
they measure for themselves and as soon

00:37:10,880 --> 00:37:12,800
as you can measure for yourself what you

00:37:12,320 --> 00:37:14,160
want

00:37:12,800 --> 00:37:15,920
you will measure something different

00:37:14,160 --> 00:37:17,520
from somebody at a different company or

00:37:15,920 --> 00:37:19,520
that i would ever think up

00:37:17,520 --> 00:37:22,000
and so there will be a lot of innovation

00:37:19,520 --> 00:37:24,960
i think in in telemetry

00:37:22,000 --> 00:37:26,640
um increasing amount of stream uh

00:37:24,960 --> 00:37:30,000
computation

00:37:26,640 --> 00:37:31,680
is being placed into these accelerators

00:37:30,000 --> 00:37:34,560
uh it's starting out with things that

00:37:31,680 --> 00:37:37,040
you would expect firewalls gateways

00:37:34,560 --> 00:37:38,640
load balancers but you can do things

00:37:37,040 --> 00:37:40,960
like dns caches

00:37:38,640 --> 00:37:42,480
uh that will be placed in the tables of

00:37:40,960 --> 00:37:44,560
one of these devices

00:37:42,480 --> 00:37:45,520
some people have implemented um key

00:37:44,560 --> 00:37:48,480
value stores

00:37:45,520 --> 00:37:50,480
for as a cache to the front end of a

00:37:48,480 --> 00:37:52,560
memcache system and so there's been a

00:37:50,480 --> 00:37:54,880
variety of these different uh

00:37:52,560 --> 00:37:55,599
of different devices not to replace a

00:37:54,880 --> 00:37:58,320
cpu

00:37:55,599 --> 00:38:00,000
but to do what it does well which is to

00:37:58,320 --> 00:38:01,599
do stream processing and match and

00:38:00,000 --> 00:38:02,640
action rules a little bit of state for

00:38:01,599 --> 00:38:04,320
processing

00:38:02,640 --> 00:38:06,320
and so if you can offload some of that

00:38:04,320 --> 00:38:08,560
then it can accelerate some

00:38:06,320 --> 00:38:10,880
some things that we would be also doing

00:38:08,560 --> 00:38:12,800
within a cpu

00:38:10,880 --> 00:38:14,000
but i think the eventual goal is that we

00:38:12,800 --> 00:38:17,200
will have networks

00:38:14,000 --> 00:38:18,160
that are programmed by many and operated

00:38:17,200 --> 00:38:19,680
by few

00:38:18,160 --> 00:38:21,520
in other words they're programmed by

00:38:19,680 --> 00:38:24,320
owners operators

00:38:21,520 --> 00:38:24,880
anybody who has a network anybody who's

00:38:24,320 --> 00:38:26,560
studying

00:38:24,880 --> 00:38:29,119
and learning about networks anybody

00:38:26,560 --> 00:38:31,040
who's doing research in networking

00:38:29,119 --> 00:38:33,119
they would be the programmers and

00:38:31,040 --> 00:38:35,119
hopefully the networks would be operated

00:38:33,119 --> 00:38:38,240
by a lot fewer people than they are

00:38:35,119 --> 00:38:40,160
today uh last time i looked

00:38:38,240 --> 00:38:42,160
at stanford we have a population of

00:38:40,160 --> 00:38:44,240
about 35 000 people on campus

00:38:42,160 --> 00:38:46,480
during normal during normal times we

00:38:44,240 --> 00:38:47,359
have about 200 people keeping the

00:38:46,480 --> 00:38:50,320
network

00:38:47,359 --> 00:38:51,920
going and uh if you compare that to the

00:38:50,320 --> 00:38:54,320
telephone system of old

00:38:51,920 --> 00:38:56,160
it took about three people to do that so

00:38:54,320 --> 00:38:56,640
we clearly haven't quite got it right

00:38:56,160 --> 00:38:58,880
yet

00:38:56,640 --> 00:39:00,400
in terms of making networks simple to

00:38:58,880 --> 00:39:02,560
operate and manage

00:39:00,400 --> 00:39:04,800
same goes whether it's on a small scale

00:39:02,560 --> 00:39:07,839
whether it's in a wi-fi network or

00:39:04,800 --> 00:39:09,760
in a large isp or mobile operator

00:39:07,839 --> 00:39:11,520
because if you can hand them the ability

00:39:09,760 --> 00:39:13,200
to express

00:39:11,520 --> 00:39:14,880
what they can measure what they can

00:39:13,200 --> 00:39:17,119
observe what they can see

00:39:14,880 --> 00:39:19,599
in their networks and then hand them the

00:39:17,119 --> 00:39:21,599
ability to then decide how they control

00:39:19,599 --> 00:39:23,200
the network based on what they can see

00:39:21,599 --> 00:39:24,960
they will do things differently and they

00:39:23,200 --> 00:39:28,000
will tend to do to move in a direction

00:39:24,960 --> 00:39:29,200
of simpler more reliable more secure and

00:39:28,000 --> 00:39:32,160
a lower cost of

00:39:29,200 --> 00:39:33,359
of of operation just to give you an

00:39:32,160 --> 00:39:35,920
example of what i

00:39:33,359 --> 00:39:37,119
what i mean by this this is a this is a

00:39:35,920 --> 00:39:40,320
cartoon picture

00:39:37,119 --> 00:39:41,760
of of a large cloud or isp

00:39:40,320 --> 00:39:43,520
in this particular case showing the

00:39:41,760 --> 00:39:45,119
separation of control from forwarding

00:39:43,520 --> 00:39:45,599
plane just as an example so this would

00:39:45,119 --> 00:39:48,720
be

00:39:45,599 --> 00:39:50,079
illustrative of say google or vmware

00:39:48,720 --> 00:39:51,839
in the way that they structure their

00:39:50,079 --> 00:39:53,280
networks

00:39:51,839 --> 00:39:55,280
you have a control plane control apps

00:39:53,280 --> 00:39:56,480
running routing protocols virtualization

00:39:55,280 --> 00:39:57,599
this type of thing

00:39:56,480 --> 00:39:59,520
that's reaching down and then

00:39:57,599 --> 00:40:01,440
controlling a pipeline of switches nicks

00:39:59,520 --> 00:40:04,560
and v-switches

00:40:01,440 --> 00:40:06,400
along the along the path

00:40:04,560 --> 00:40:09,520
the switch os that would be sitting on

00:40:06,400 --> 00:40:11,839
each of these of these switches

00:40:09,520 --> 00:40:13,920
and uh i'm sure you're familiar with

00:40:11,839 --> 00:40:15,040
with many of those like fbas and sonic

00:40:13,920 --> 00:40:17,359
etc

00:40:15,040 --> 00:40:19,280
and then that control plane could be a

00:40:17,359 --> 00:40:21,280
proprietary one it could be an open

00:40:19,280 --> 00:40:24,400
source one like uh like onos from the

00:40:21,280 --> 00:40:26,160
open networking foundation

00:40:24,400 --> 00:40:28,079
i think of these nicks and switches of

00:40:26,160 --> 00:40:28,800
being programmed to have a specific

00:40:28,079 --> 00:40:30,720
behavior

00:40:28,800 --> 00:40:32,560
perhaps in the p4 language there may be

00:40:30,720 --> 00:40:34,560
other languages that emerge too

00:40:32,560 --> 00:40:36,720
and those that language expressing and

00:40:34,560 --> 00:40:39,760
specifying their forwarding behavior

00:40:36,720 --> 00:40:41,119
and then some means to take that

00:40:39,760 --> 00:40:43,440
expression of the program

00:40:41,119 --> 00:40:44,480
and turn it into an api that the control

00:40:43,440 --> 00:40:46,240
plane can use

00:40:44,480 --> 00:40:48,000
some of you may be familiar with the p4

00:40:46,240 --> 00:40:49,760
runtime contract that was developed

00:40:48,000 --> 00:40:52,880
between

00:40:49,760 --> 00:40:53,680
barefoot originally and google which is

00:40:52,880 --> 00:40:56,000
a

00:40:53,680 --> 00:40:58,240
an open source way of maintaining a

00:40:56,000 --> 00:40:59,920
contract between that control plane and

00:40:58,240 --> 00:41:01,760
the forwarding plane as you update the

00:40:59,920 --> 00:41:04,960
program that's specifying the behavior

00:41:01,760 --> 00:41:06,880
it might expose new api's new calls to

00:41:04,960 --> 00:41:08,560
the control plane so you want those

00:41:06,880 --> 00:41:10,560
exposed on the fly

00:41:08,560 --> 00:41:11,920
without having to reboot the reboot the

00:41:10,560 --> 00:41:13,920
system

00:41:11,920 --> 00:41:15,920
so that could be an example of of how

00:41:13,920 --> 00:41:18,000
that takes place however it happens

00:41:15,920 --> 00:41:19,359
however that contract is formed between

00:41:18,000 --> 00:41:21,520
the control plane and the

00:41:19,359 --> 00:41:22,960
the forwarding plane it gives us the

00:41:21,520 --> 00:41:25,200
ability to now

00:41:22,960 --> 00:41:26,079
express the behavior from the top and

00:41:25,200 --> 00:41:28,319
work down

00:41:26,079 --> 00:41:29,280
towards how the packets are processed

00:41:28,319 --> 00:41:32,319
and the reason i keep

00:41:29,280 --> 00:41:34,319
i keep dwelling on this processing from

00:41:32,319 --> 00:41:35,040
the top down or expressing from the top

00:41:34,319 --> 00:41:36,960
down

00:41:35,040 --> 00:41:39,280
is because i think those who own

00:41:36,960 --> 00:41:40,720
networks who who are doing devops and

00:41:39,280 --> 00:41:43,599
developing their own networks

00:41:40,720 --> 00:41:45,200
sort of realizing that taking charge of

00:41:43,599 --> 00:41:48,880
the control plane software

00:41:45,200 --> 00:41:52,079
was a big deal but at the end of the day

00:41:48,880 --> 00:41:53,440
their network is passing packets from

00:41:52,079 --> 00:41:54,960
one place to another let's face it

00:41:53,440 --> 00:41:57,040
that's all the network does

00:41:54,960 --> 00:41:58,480
and as the packets go by we look at some

00:41:57,040 --> 00:42:01,040
headers and twizzle some bits that's

00:41:58,480 --> 00:42:02,800
really all that goes goes on

00:42:01,040 --> 00:42:04,160
so if they're not in charge of how the

00:42:02,800 --> 00:42:06,000
packets are processed

00:42:04,160 --> 00:42:07,760
then they're not really in charge of how

00:42:06,000 --> 00:42:09,520
the network operates

00:42:07,760 --> 00:42:11,200
so taking more and more control of it

00:42:09,520 --> 00:42:12,640
seems kind of inevitable

00:42:11,200 --> 00:42:14,240
now i've shown the pipeline here of just

00:42:12,640 --> 00:42:14,880
the switches and the nics of course this

00:42:14,240 --> 00:42:17,280
extends

00:42:14,880 --> 00:42:18,560
into the end host as well through the

00:42:17,280 --> 00:42:22,560
kernel and up into

00:42:18,560 --> 00:42:22,560
to user space as as well

00:42:23,440 --> 00:42:25,599
so

00:42:27,119 --> 00:42:31,119
if we to think of this as a programmable

00:42:30,160 --> 00:42:33,440
platform

00:42:31,119 --> 00:42:35,280
what are people going to do with it what

00:42:33,440 --> 00:42:39,119
is the kind of the next step

00:42:35,280 --> 00:42:40,560
uh along this along this path

00:42:39,119 --> 00:42:42,240
i've already said that i think that they

00:42:40,560 --> 00:42:44,640
will measure

00:42:42,240 --> 00:42:46,079
they will measure a lot of metadata

00:42:44,640 --> 00:42:49,119
about the packets

00:42:46,079 --> 00:42:50,720
so as as i'm sure you know

00:42:49,119 --> 00:42:52,400
every packet as it passes through a

00:42:50,720 --> 00:42:54,880
network goes to a switch

00:42:52,400 --> 00:42:55,680
and as it hits a switch that switch

00:42:54,880 --> 00:42:58,560
knows

00:42:55,680 --> 00:42:59,599
of course its own id the switch's id it

00:42:58,560 --> 00:43:02,400
knows

00:42:59,599 --> 00:43:03,200
the delay that this packet faces the

00:43:02,400 --> 00:43:05,200
amount of q

00:43:03,200 --> 00:43:06,960
the queuing delay that it experiences

00:43:05,200 --> 00:43:08,400
the latency across the switch

00:43:06,960 --> 00:43:10,880
the other packets that it shared the

00:43:08,400 --> 00:43:12,960
queue with all of this metadata

00:43:10,880 --> 00:43:14,000
becomes available to the programmer if

00:43:12,960 --> 00:43:16,240
the switch or the

00:43:14,000 --> 00:43:17,920
or the smart nic is programmable and

00:43:16,240 --> 00:43:20,560
allows you to add that data

00:43:17,920 --> 00:43:22,720
into the packet or shoot off a telemetry

00:43:20,560 --> 00:43:24,319
packet as it goes by

00:43:22,720 --> 00:43:26,480
and if you think about how what what a

00:43:24,319 --> 00:43:29,040
far cry this is from

00:43:26,480 --> 00:43:30,160
uh from traceroute and ping the things

00:43:29,040 --> 00:43:33,359
that we've relied on

00:43:30,160 --> 00:43:34,880
for for 20 or 30 years now

00:43:33,359 --> 00:43:36,640
i'm pretty sure that people are going to

00:43:34,880 --> 00:43:37,680
adopt as they already are doing they're

00:43:36,640 --> 00:43:41,119
going to adopt and

00:43:37,680 --> 00:43:43,599
and and modify the way in which they

00:43:41,119 --> 00:43:45,200
they collect data primarily to make

00:43:43,599 --> 00:43:47,440
their networks easier to debug

00:43:45,200 --> 00:43:49,440
but once they can do this there's a

00:43:47,440 --> 00:43:50,319
logical next stage of being able to take

00:43:49,440 --> 00:43:53,359
a packet

00:43:50,319 --> 00:43:53,680
and asking does this packet conform to

00:43:53,359 --> 00:43:56,160
my

00:43:53,680 --> 00:43:57,839
original intended behavior the original

00:43:56,160 --> 00:43:58,720
specified behavior behavior of the

00:43:57,839 --> 00:44:00,400
network

00:43:58,720 --> 00:44:02,160
if i look at it and see the sequence of

00:44:00,400 --> 00:44:03,040
switches that it visited was that a

00:44:02,160 --> 00:44:06,720
legal

00:44:03,040 --> 00:44:08,160
uh set of switches was that a legal path

00:44:06,720 --> 00:44:09,920
is there a problem in the network

00:44:08,160 --> 00:44:10,960
because of misconfiguration a routing

00:44:09,920 --> 00:44:13,119
table state

00:44:10,960 --> 00:44:14,160
or routing protocol is there a security

00:44:13,119 --> 00:44:15,920
violation that

00:44:14,160 --> 00:44:18,000
has allowed a packet to take a path that

00:44:15,920 --> 00:44:19,440
it shouldn't so as soon as you can do

00:44:18,000 --> 00:44:21,359
that and ask questions of

00:44:19,440 --> 00:44:22,720
functionality and performance then i

00:44:21,359 --> 00:44:24,800
think that this this

00:44:22,720 --> 00:44:26,720
verification and validation will happen

00:44:24,800 --> 00:44:29,200
faster and faster

00:44:26,720 --> 00:44:29,839
leading to potentially an update of the

00:44:29,200 --> 00:44:32,079
state

00:44:29,839 --> 00:44:33,680
that is that is managing the network

00:44:32,079 --> 00:44:35,520
maybe even the control code

00:44:33,680 --> 00:44:36,960
itself and the forwarding forwarding

00:44:35,520 --> 00:44:38,880
code i think it'll be a while before

00:44:36,960 --> 00:44:40,640
this is done completely automatically

00:44:38,880 --> 00:44:42,960
but uh maybe in sort of the science

00:44:40,640 --> 00:44:46,319
fiction future of 10 or 15 years time

00:44:42,960 --> 00:44:48,079
that might happen but that that closing

00:44:46,319 --> 00:44:50,640
of the loop

00:44:48,079 --> 00:44:51,920
is this is how i think that closing of

00:44:50,640 --> 00:44:54,160
the loop to make the network

00:44:51,920 --> 00:44:57,119
control and management or automatic will

00:44:54,160 --> 00:44:58,720
happen it's not because

00:44:57,119 --> 00:45:00,319
the chip vendor will come up with a

00:44:58,720 --> 00:45:01,839
feature that they need it's not because

00:45:00,319 --> 00:45:03,680
the equipment vendor will come up with a

00:45:01,839 --> 00:45:04,800
feature it's because the network owner

00:45:03,680 --> 00:45:06,640
and operator

00:45:04,800 --> 00:45:08,720
realizing the problem that they have to

00:45:06,640 --> 00:45:11,280
solve will figure out how to do this for

00:45:08,720 --> 00:45:11,280
themselves

00:45:12,400 --> 00:45:19,280
so what does it mean for for for for us

00:45:17,280 --> 00:45:20,319
together we're all thinking about how

00:45:19,280 --> 00:45:23,359
this pipeline

00:45:20,319 --> 00:45:26,640
is programmed how can we write code that

00:45:23,359 --> 00:45:28,480
is clear familiar runs at lane rate

00:45:26,640 --> 00:45:30,839
and can be moved around within this

00:45:28,480 --> 00:45:32,000
pipeline to the place that it rightfully

00:45:30,839 --> 00:45:33,520
belongs

00:45:32,000 --> 00:45:35,280
so i've drawn out a pipeline here

00:45:33,520 --> 00:45:37,200
corresponding a little bit to the to the

00:45:35,280 --> 00:45:39,280
hardware pipeline below

00:45:37,200 --> 00:45:40,800
of devices consisting of the user space

00:45:39,280 --> 00:45:42,079
kernel the nick the switch

00:45:40,800 --> 00:45:44,000
and then the same thing on the right

00:45:42,079 --> 00:45:45,440
hand side reflected

00:45:44,000 --> 00:45:47,520
and we're going to think about what code

00:45:45,440 --> 00:45:49,359
belongs in there or what what what

00:45:47,520 --> 00:45:51,200
things belong in each of those

00:45:49,359 --> 00:45:53,200
in those blocks i'm going to abbreviate

00:45:51,200 --> 00:45:56,560
that with you for user space

00:45:53,200 --> 00:45:58,839
k for kernel and for nick x for switch

00:45:56,560 --> 00:46:01,839
just to make it a little uh a little

00:45:58,839 --> 00:46:01,839
cleaner

00:46:02,640 --> 00:46:06,480
these parts already exist work extremely

00:46:05,359 --> 00:46:09,520
well there's a large

00:46:06,480 --> 00:46:12,240
body of programmers many of them who

00:46:09,520 --> 00:46:14,000
viewer here today who are extremely

00:46:12,240 --> 00:46:16,880
adept at programming in this

00:46:14,000 --> 00:46:19,040
model in the switches in the middle this

00:46:16,880 --> 00:46:22,079
pisa pipeline and this p4

00:46:19,040 --> 00:46:23,520
language is is increasingly being used

00:46:22,079 --> 00:46:25,200
and i think this is going to appear on

00:46:23,520 --> 00:46:27,680
the next as well

00:46:25,200 --> 00:46:28,880
so we have a little bit of a potential

00:46:27,680 --> 00:46:31,040
collision of two

00:46:28,880 --> 00:46:32,720
sort of viewpoints and two ways of doing

00:46:31,040 --> 00:46:35,040
things

00:46:32,720 --> 00:46:37,040
at the end of the day everything trying

00:46:35,040 --> 00:46:38,000
to do efficient fast processing of

00:46:37,040 --> 00:46:41,680
packets

00:46:38,000 --> 00:46:43,839
in a familiar easy to use way

00:46:41,680 --> 00:46:45,599
but uh i'm not here to say that we

00:46:43,839 --> 00:46:47,599
should abandon the use of c

00:46:45,599 --> 00:46:50,319
or c plus plus or anything like that

00:46:47,599 --> 00:46:52,560
it's a remarkably successful way of

00:46:50,319 --> 00:46:53,599
programming behaviors but as we already

00:46:52,560 --> 00:46:57,680
see with with

00:46:53,599 --> 00:47:01,440
xd xdp and eppf you've clearly got to

00:46:57,680 --> 00:47:03,280
provide a a constrained way of

00:47:01,440 --> 00:47:05,920
of programming in order for it to

00:47:03,280 --> 00:47:09,520
operate safely within the kernel

00:47:05,920 --> 00:47:11,920
so it sort of begs thinking how can we

00:47:09,520 --> 00:47:12,560
get the benefits of both of these ways

00:47:11,920 --> 00:47:14,560
of thinking

00:47:12,560 --> 00:47:16,480
in order to be able to make sure that

00:47:14,560 --> 00:47:19,200
our code can run at line rate

00:47:16,480 --> 00:47:20,800
on these on these accelerators so let's

00:47:19,200 --> 00:47:22,160
take an example of some

00:47:20,800 --> 00:47:24,319
sort of behavior that we might be

00:47:22,160 --> 00:47:25,680
interested in and and i want to use this

00:47:24,319 --> 00:47:27,760
as a way of explaining

00:47:25,680 --> 00:47:29,680
why i think we might need to move

00:47:27,760 --> 00:47:32,160
functionality around and give the

00:47:29,680 --> 00:47:34,319
programmer the ability to do that

00:47:32,160 --> 00:47:35,599
so if you've been tracking how

00:47:34,319 --> 00:47:38,960
congestion control

00:47:35,599 --> 00:47:41,920
has been uh changing over time and

00:47:38,960 --> 00:47:44,079
evolving over time

00:47:41,920 --> 00:47:45,839
i'm stepping into dangerous ground here

00:47:44,079 --> 00:47:47,440
because everybody has their own

00:47:45,839 --> 00:47:49,119
sort of religious convictions about the

00:47:47,440 --> 00:47:49,760
way that congestion control what we've

00:47:49,119 --> 00:47:51,280
done

00:47:49,760 --> 00:47:52,720
i'm not here to say that one method is

00:47:51,280 --> 00:47:53,599
better than another just merely to

00:47:52,720 --> 00:47:56,079
observe

00:47:53,599 --> 00:47:57,680
that different large cloud and service

00:47:56,079 --> 00:47:59,200
provider cloud service provider and data

00:47:57,680 --> 00:48:01,040
center operators have been experimenting

00:47:59,200 --> 00:48:02,079
with or deploying a variety of different

00:48:01,040 --> 00:48:04,640
techniques

00:48:02,079 --> 00:48:05,599
of course in the you know originally we

00:48:04,640 --> 00:48:07,920
used

00:48:05,599 --> 00:48:09,520
the packet drops and duplicate acts as

00:48:07,920 --> 00:48:11,599
the primary form of

00:48:09,520 --> 00:48:13,200
the indication of congestion at the end

00:48:11,599 --> 00:48:15,599
point and i uh

00:48:13,200 --> 00:48:16,319
i put this with a k here to say that

00:48:15,599 --> 00:48:18,839
that

00:48:16,319 --> 00:48:21,440
that signal is observed mostly by the

00:48:18,839 --> 00:48:23,040
kernel in order to be able to

00:48:21,440 --> 00:48:25,440
identify the congestion and that's why

00:48:23,040 --> 00:48:27,040
tcp is running as you know

00:48:25,440 --> 00:48:29,359
imagine that you're you're implementing

00:48:27,040 --> 00:48:33,359
a method like um

00:48:29,359 --> 00:48:36,960
like like tcp vegas or

00:48:33,359 --> 00:48:39,680
like timely as described by google

00:48:36,960 --> 00:48:40,319
they use rtt as the primary measure of

00:48:39,680 --> 00:48:42,240
congestion

00:48:40,319 --> 00:48:44,319
the onset of congestion and in which

00:48:42,240 --> 00:48:46,880
case they need very accurate timers

00:48:44,319 --> 00:48:48,480
and ideally running out on the the nick

00:48:46,880 --> 00:48:48,800
so this would be something you'd like in

00:48:48,480 --> 00:48:52,480
the

00:48:48,800 --> 00:48:54,160
in the nick last year there was a paper

00:48:52,480 --> 00:48:55,440
that alibaba published about something

00:48:54,160 --> 00:48:58,079
called hpcc

00:48:55,440 --> 00:48:59,440
where they used um information about the

00:48:58,079 --> 00:49:01,359
queue occupancy and the build up of the

00:48:59,440 --> 00:49:03,839
queues in the switches

00:49:01,359 --> 00:49:04,640
our argument being if the switch is

00:49:03,839 --> 00:49:06,960
where the

00:49:04,640 --> 00:49:08,800
congestion is then why don't we have a

00:49:06,960 --> 00:49:11,440
direct measure of what that q

00:49:08,800 --> 00:49:13,119
occupancy is as a direct explicit

00:49:11,440 --> 00:49:15,040
measure of what the congestion is

00:49:13,119 --> 00:49:16,319
and so that's been taking place at the

00:49:15,040 --> 00:49:18,480
at the switch x

00:49:16,319 --> 00:49:19,920
here in order to be able to report it

00:49:18,480 --> 00:49:22,319
back you need to modify a packet

00:49:19,920 --> 00:49:23,520
header either by creating a new one or

00:49:22,319 --> 00:49:26,079
or overwriting

00:49:23,520 --> 00:49:27,440
or reusing a another field and so you

00:49:26,079 --> 00:49:29,520
need a new header format

00:49:27,440 --> 00:49:31,440
and then eventually both the nick and

00:49:29,520 --> 00:49:33,119
the kernel will need to know about that

00:49:31,440 --> 00:49:34,720
so that involves changing three things

00:49:33,119 --> 00:49:36,640
here

00:49:34,720 --> 00:49:38,319
as soon as you start thinking about how

00:49:36,640 --> 00:49:40,000
you can have congestion control

00:49:38,319 --> 00:49:41,440
in vms and containers that might be

00:49:40,000 --> 00:49:42,880
different with the underlying one that's

00:49:41,440 --> 00:49:43,440
taking place in the kernel or out on the

00:49:42,880 --> 00:49:44,960
neck

00:49:43,440 --> 00:49:46,240
it all gets a little bit confusing and

00:49:44,960 --> 00:49:47,440
you can imagine that you would want to

00:49:46,240 --> 00:49:49,680
move things around

00:49:47,440 --> 00:49:51,280
and have this functionality change to

00:49:49,680 --> 00:49:52,319
different places over time as we learn

00:49:51,280 --> 00:49:54,319
more and as we

00:49:52,319 --> 00:49:56,839
as we evolve so it'll be sort of a

00:49:54,319 --> 00:49:58,559
simple example routing is another

00:49:56,839 --> 00:50:00,960
example

00:49:58,559 --> 00:50:02,079
today pretty much all routing is done

00:50:00,960 --> 00:50:04,000
based on the forwarding

00:50:02,079 --> 00:50:05,680
information base that's in the switch

00:50:04,000 --> 00:50:06,480
the kernel has to be aware of it of

00:50:05,680 --> 00:50:09,520
course

00:50:06,480 --> 00:50:10,880
so the x and k both know about this

00:50:09,520 --> 00:50:13,119
if you want to do congestion based

00:50:10,880 --> 00:50:16,400
routing which seems

00:50:13,119 --> 00:50:18,640
fairly popular there's a sort of an

00:50:16,400 --> 00:50:19,119
evolution of traffic engineering down to

00:50:18,640 --> 00:50:21,520
more

00:50:19,119 --> 00:50:22,480
congestion based route congestion aware

00:50:21,520 --> 00:50:25,280
routing

00:50:22,480 --> 00:50:27,359
in which case yes the the switch and the

00:50:25,280 --> 00:50:29,599
nick both have to know about this

00:50:27,359 --> 00:50:31,119
um and uh eventually you have to feed

00:50:29,599 --> 00:50:32,240
that information to the kernel in order

00:50:31,119 --> 00:50:33,760
to be able to make

00:50:32,240 --> 00:50:35,359
its decision as to where it sends the

00:50:33,760 --> 00:50:37,680
packet and if you're doing source

00:50:35,359 --> 00:50:40,000
routing then that information

00:50:37,680 --> 00:50:40,960
almost by definition is moving from the

00:50:40,000 --> 00:50:44,559
from the

00:50:40,960 --> 00:50:46,640
uh uh from from the switch to the kernel

00:50:44,559 --> 00:50:48,079
to 2k and then you've got to make sure

00:50:46,640 --> 00:50:50,160
the switch knows because now you're

00:50:48,079 --> 00:50:52,480
taking over that routing decision

00:50:50,160 --> 00:50:54,079
so it means modifying the switch as well

00:50:52,480 --> 00:50:56,000
so even if you take basically very

00:50:54,079 --> 00:50:57,520
simple operations like these

00:50:56,000 --> 00:50:58,880
the two fundamental operations of

00:50:57,520 --> 00:50:59,520
networking congestion control and

00:50:58,880 --> 00:51:02,319
routing

00:50:59,520 --> 00:51:04,319
you can see how if you allowed people to

00:51:02,319 --> 00:51:06,640
be able to move this functionality very

00:51:04,319 --> 00:51:08,480
easily between these different places

00:51:06,640 --> 00:51:10,480
then they're probably over time going to

00:51:08,480 --> 00:51:11,040
do it and they will come up with better

00:51:10,480 --> 00:51:14,079
techniques

00:51:11,040 --> 00:51:14,079
as a consequence

00:51:16,559 --> 00:51:21,280
so how might we actually do this

00:51:19,680 --> 00:51:23,280
i'm going to take the dangerous risk of

00:51:21,280 --> 00:51:25,680
putting down a very tentative

00:51:23,280 --> 00:51:27,200
strawman suggestion there's lots of ways

00:51:25,680 --> 00:51:29,920
that we could do this

00:51:27,200 --> 00:51:31,839
um but i think that it deserves a lot of

00:51:29,920 --> 00:51:33,680
thought a lot of careful thought because

00:51:31,839 --> 00:51:36,400
i think if we can do this right

00:51:33,680 --> 00:51:36,960
it will have dramatic consequences for

00:51:36,400 --> 00:51:40,000
the

00:51:36,960 --> 00:51:41,920
for the field of networking as a whole

00:51:40,000 --> 00:51:43,680
and i think we need to try and balance

00:51:41,920 --> 00:51:47,119
two things one is

00:51:43,680 --> 00:51:49,520
an immense population of programmers

00:51:47,119 --> 00:51:50,559
of user space and kernel code there's a

00:51:49,520 --> 00:51:52,160
lot of expertise

00:51:50,559 --> 00:51:53,920
thousands and thousands of people who

00:51:52,160 --> 00:51:54,800
have who have written a huge amount of

00:51:53,920 --> 00:51:56,160
code

00:51:54,800 --> 00:51:57,599
many many techniques that have been

00:51:56,160 --> 00:51:59,760
developed and so we're going to make

00:51:57,599 --> 00:52:01,440
sure that we maintain that

00:51:59,760 --> 00:52:03,680
on the other hand if you're trying to

00:52:01,440 --> 00:52:05,599
take that general purpose code

00:52:03,680 --> 00:52:08,640
and run it on a hardware accelerated

00:52:05,599 --> 00:52:10,400
pipeline like in a nick or in a switch

00:52:08,640 --> 00:52:12,079
then it's going to be very hard because

00:52:10,400 --> 00:52:14,319
you're expressing a behavior

00:52:12,079 --> 00:52:16,319
that doesn't necessarily fit onto that

00:52:14,319 --> 00:52:18,400
device so you need to use

00:52:16,319 --> 00:52:20,079
some method that will constrain that

00:52:18,400 --> 00:52:22,160
programming so that it'll work on a

00:52:20,079 --> 00:52:24,559
feed-forward loop-free pipeline

00:52:22,160 --> 00:52:25,200
such that it uses the the the behavior

00:52:24,559 --> 00:52:28,000
that you

00:52:25,200 --> 00:52:30,720
that you need and you also need to

00:52:28,000 --> 00:52:33,760
express the overall pipeline

00:52:30,720 --> 00:52:35,040
that is the sequence or the the sequence

00:52:33,760 --> 00:52:37,280
of devices

00:52:35,040 --> 00:52:39,040
whether it's the end host the nix the

00:52:37,280 --> 00:52:40,640
switches the v-switches

00:52:39,040 --> 00:52:42,240
and whatever device that you have in the

00:52:40,640 --> 00:52:43,200
network like firewalls and gateways you

00:52:42,240 --> 00:52:44,400
need a pipeline

00:52:43,200 --> 00:52:45,920
because if you're going to program it

00:52:44,400 --> 00:52:47,040
and partition this code across it then

00:52:45,920 --> 00:52:48,800
you need a means to

00:52:47,040 --> 00:52:50,240
to express it so finding the right

00:52:48,800 --> 00:52:53,440
balance and combination

00:52:50,240 --> 00:52:54,720
is not entirely obvious is a is one way

00:52:53,440 --> 00:52:58,000
that we could think about it

00:52:54,720 --> 00:53:00,240
which is to specify an overall structure

00:52:58,000 --> 00:53:02,960
using a language like p4 where you're

00:53:00,240 --> 00:53:04,720
expressing the serial dependency

00:53:02,960 --> 00:53:06,480
because ultimately you need things that

00:53:04,720 --> 00:53:08,240
will operate in a sequence that you get

00:53:06,480 --> 00:53:09,839
the dependencies correct and then they

00:53:08,240 --> 00:53:11,280
will sit in the correct location where

00:53:09,839 --> 00:53:14,319
they can be accelerated

00:53:11,280 --> 00:53:16,720
but that using the extern function

00:53:14,319 --> 00:53:17,599
of of p4 the majority of the code might

00:53:16,720 --> 00:53:20,559
actually be

00:53:17,599 --> 00:53:21,760
the existing conventional cc plus c c

00:53:20,559 --> 00:53:24,800
plus plus code

00:53:21,760 --> 00:53:26,400
um that will run on a cpu particularly

00:53:24,800 --> 00:53:28,319
if you know that that code is

00:53:26,400 --> 00:53:29,920
always going to run on the end host so

00:53:28,319 --> 00:53:31,599
something that is in user space

00:53:29,920 --> 00:53:33,760
or something that just belongs on the

00:53:31,599 --> 00:53:34,079
end host there's no point in rewriting

00:53:33,760 --> 00:53:36,800
that

00:53:34,079 --> 00:53:38,000
into a new language but then you could

00:53:36,800 --> 00:53:42,000
write p4 for

00:53:38,000 --> 00:53:43,760
for to specify behaviors that you know

00:53:42,000 --> 00:53:45,280
potentially will end up being

00:53:43,760 --> 00:53:46,800
accelerated in hardware you might want

00:53:45,280 --> 00:53:49,280
to be able to move them around

00:53:46,800 --> 00:53:50,559
good example of this is there are

00:53:49,280 --> 00:53:54,000
behaviors that are

00:53:50,559 --> 00:53:57,359
programmed into smartnics today that uh

00:53:54,000 --> 00:54:00,319
to do with security of the of the vms

00:53:57,359 --> 00:54:02,559
and containers that run in the cloud

00:54:00,319 --> 00:54:03,359
if they're wanting to add bare metal

00:54:02,559 --> 00:54:06,800
devices

00:54:03,359 --> 00:54:07,760
like supercomputers etc then typically

00:54:06,800 --> 00:54:10,960
they

00:54:07,760 --> 00:54:14,000
can't trust a nic connected

00:54:10,960 --> 00:54:15,839
to that uh that device because they

00:54:14,000 --> 00:54:18,559
don't control the software that runs

00:54:15,839 --> 00:54:19,040
on it so typically they then move that

00:54:18,559 --> 00:54:21,119
same

00:54:19,040 --> 00:54:22,240
behavior that same functionality over to

00:54:21,119 --> 00:54:23,599
the switch

00:54:22,240 --> 00:54:25,359
and so if they're written in the same

00:54:23,599 --> 00:54:27,280
language and they have the same

00:54:25,359 --> 00:54:28,480
means of operating at line right it

00:54:27,280 --> 00:54:31,520
becomes very easy

00:54:28,480 --> 00:54:32,559
just to move that code over and port it

00:54:31,520 --> 00:54:34,000
over to the other

00:54:32,559 --> 00:54:35,200
other device so if you know that it

00:54:34,000 --> 00:54:35,839
needs to run at line right in the

00:54:35,200 --> 00:54:38,079
network

00:54:35,839 --> 00:54:40,400
then that is one way that you can do it

00:54:38,079 --> 00:54:43,839
however

00:54:40,400 --> 00:54:44,240
i don't think that the right way to do

00:54:43,839 --> 00:54:48,480
this

00:54:44,240 --> 00:54:49,599
is for either of the p4 community or the

00:54:48,480 --> 00:54:51,440
netdev community

00:54:49,599 --> 00:54:52,880
to do this on their own because we have

00:54:51,440 --> 00:54:55,200
an expertise

00:54:52,880 --> 00:54:56,400
from two different from two different

00:54:55,200 --> 00:54:57,839
aspects of networking

00:54:56,400 --> 00:55:00,240
and the best way to do this be to try

00:54:57,839 --> 00:55:02,880
and figure out ourselves

00:55:00,240 --> 00:55:03,680
and in the true spirit of merit-based

00:55:02,880 --> 00:55:05,200
open source

00:55:03,680 --> 00:55:07,839
that shouldn't come from someone like me

00:55:05,200 --> 00:55:09,520
it should come from whoever is actually

00:55:07,839 --> 00:55:10,960
going to be doing that work and holding

00:55:09,520 --> 00:55:14,079
the pen and

00:55:10,960 --> 00:55:17,119
on the keyboard so my proposal is

00:55:14,079 --> 00:55:19,599
that the netdevandp4.org

00:55:17,119 --> 00:55:21,119
create a working group however

00:55:19,599 --> 00:55:23,119
informally or formally

00:55:21,119 --> 00:55:24,960
with the express intent of trying to

00:55:23,119 --> 00:55:27,119
figure out how this would come together

00:55:24,960 --> 00:55:29,280
and create an open source activity

00:55:27,119 --> 00:55:34,799
together that would allow this to

00:55:29,280 --> 00:55:36,640
to to move forwards

00:55:34,799 --> 00:55:38,160
so returning to this picture i just

00:55:36,640 --> 00:55:41,440
wanted to say a few

00:55:38,160 --> 00:55:42,880
parting words um you know i believe that

00:55:41,440 --> 00:55:46,319
networks are becoming

00:55:42,880 --> 00:55:48,000
deeply programmable i really believe

00:55:46,319 --> 00:55:50,640
that over the next decade

00:55:48,000 --> 00:55:51,119
this is going to happen end to end and

00:55:50,640 --> 00:55:53,040
that we

00:55:51,119 --> 00:55:54,799
need to work together to try and make

00:55:53,040 --> 00:55:57,119
this happen in a consistent

00:55:54,799 --> 00:55:58,960
in a consistent way such that the

00:55:57,119 --> 00:56:01,119
behavior is specified at the top

00:55:58,960 --> 00:56:02,559
partition and compiled down

00:56:01,119 --> 00:56:04,720
i think if we do that we're going to see

00:56:02,559 --> 00:56:06,319
a lot more innovation in networking i

00:56:04,720 --> 00:56:08,799
think we're going to see it move and

00:56:06,319 --> 00:56:10,079
improve much faster than it has in the

00:56:08,799 --> 00:56:11,359
past

00:56:10,079 --> 00:56:13,359
those who own and operate networks

00:56:11,359 --> 00:56:15,680
whether it's my home network or

00:56:13,359 --> 00:56:18,160
amazon's cloud they're going to create

00:56:15,680 --> 00:56:19,920
the the dials that they need to observe

00:56:18,160 --> 00:56:21,119
the behavior

00:56:19,920 --> 00:56:22,799
and they're going to create the control

00:56:21,119 --> 00:56:24,640
knobs that they need to change that

00:56:22,799 --> 00:56:26,000
behavior

00:56:24,640 --> 00:56:27,520
and i think that most of the time

00:56:26,000 --> 00:56:28,240
they'll use it to make their network

00:56:27,520 --> 00:56:30,240
simpler

00:56:28,240 --> 00:56:31,599
they will focus them on the small set of

00:56:30,240 --> 00:56:32,640
operations that they want

00:56:31,599 --> 00:56:34,240
i don't think they're going to make them

00:56:32,640 --> 00:56:36,559
much more complex i think they're going

00:56:34,240 --> 00:56:38,079
to figure out that set that they need in

00:56:36,559 --> 00:56:41,200
order to be able to make that

00:56:38,079 --> 00:56:44,160
more reliable more secure

00:56:41,200 --> 00:56:45,440
and our job is to figure out how to make

00:56:44,160 --> 00:56:47,680
it possible for them

00:56:45,440 --> 00:56:49,839
to do so and i don't think we should

00:56:47,680 --> 00:56:52,160
take this responsibility lightly

00:56:49,839 --> 00:56:52,880
i think done right we can have a huge

00:56:52,160 --> 00:56:55,359
influence

00:56:52,880 --> 00:56:57,359
over how networks are built in future

00:56:55,359 --> 00:56:58,960
and i think that's super exciting

00:56:57,359 --> 00:57:01,680
and i hope that we can work together to

00:56:58,960 --> 00:57:02,960
do that thank you

00:57:01,680 --> 00:57:05,200
the first question in the chat from

00:57:02,960 --> 00:57:06,880
david was if you'd be pressed to say

00:57:05,200 --> 00:57:08,720
something negative about tofino a6

00:57:06,880 --> 00:57:10,319
performance cost operational wise in

00:57:08,720 --> 00:57:11,359
comparison to the more traditional a6

00:57:10,319 --> 00:57:12,480
what would you say

00:57:11,359 --> 00:57:14,480
um you know whenever you produce

00:57:12,480 --> 00:57:16,319
something new uh

00:57:14,480 --> 00:57:18,400
it's you know it's a struggle to start

00:57:16,319 --> 00:57:20,720
with um because

00:57:18,400 --> 00:57:22,559
of course if you're you know as many of

00:57:20,720 --> 00:57:26,000
you know you're creating a new way

00:57:22,559 --> 00:57:28,319
of programming um you need all of the

00:57:26,000 --> 00:57:29,760
the tools the visualization tools the

00:57:28,319 --> 00:57:33,040
examples the example

00:57:29,760 --> 00:57:33,680
applications and uh it always feels once

00:57:33,040 --> 00:57:35,359
it's become

00:57:33,680 --> 00:57:36,480
obvious to you that of course this is

00:57:35,359 --> 00:57:37,920
absolutely the right way to do it

00:57:36,480 --> 00:57:41,520
there's no other way to do it right

00:57:37,920 --> 00:57:43,280
uh we'll fall into that trap then uh

00:57:41,520 --> 00:57:44,960
having to find you have to spend a lot

00:57:43,280 --> 00:57:46,640
of time uh working with people who are

00:57:44,960 --> 00:57:48,400
trying to make the difficult transition

00:57:46,640 --> 00:57:50,559
to thinking that way going from

00:57:48,400 --> 00:57:52,160
something that was fixed that works

00:57:50,559 --> 00:57:53,599
to something that is that is

00:57:52,160 --> 00:57:55,599
programmable so the

00:57:53,599 --> 00:57:56,720
the sort of the switch over cost to

00:57:55,599 --> 00:58:00,319
something new

00:57:56,720 --> 00:58:02,240
is always hard um and um not necessary

00:58:00,319 --> 00:58:04,319
and i would say less so because of the

00:58:02,240 --> 00:58:04,720
language if any of you have looked at

00:58:04,319 --> 00:58:07,280
the

00:58:04,720 --> 00:58:08,319
p4 program uh snippets they're very

00:58:07,280 --> 00:58:10,240
familiar they're

00:58:08,319 --> 00:58:12,319
very easy to to understand if i was to

00:58:10,240 --> 00:58:13,839
give you a snippet of uh

00:58:12,319 --> 00:58:15,359
there's a thing called switched up p4

00:58:13,839 --> 00:58:16,880
which is a few hundred lines of

00:58:15,359 --> 00:58:18,160
few thousand lines of code that

00:58:16,880 --> 00:58:19,040
expresses the typical forwarding

00:58:18,160 --> 00:58:22,559
behavior

00:58:19,040 --> 00:58:24,160
for a modern switch asic and uh you

00:58:22,559 --> 00:58:25,040
you'd be able to follow it and recognize

00:58:24,160 --> 00:58:27,359
what it's doing

00:58:25,040 --> 00:58:28,799
so it's not the coding so much as the

00:58:27,359 --> 00:58:30,559
entire environment of

00:58:28,799 --> 00:58:32,240
just getting used to that way of

00:58:30,559 --> 00:58:37,280
thinking

00:58:32,240 --> 00:58:39,280
um there's a second question here if uh

00:58:37,280 --> 00:58:40,799
so for the promotional slide i'm not

00:58:39,280 --> 00:58:42,319
sure what this is this using a rather

00:58:40,799 --> 00:58:43,359
limited use case or are the latency

00:58:42,319 --> 00:58:46,799
numbers for example

00:58:43,359 --> 00:58:48,799
significant for the real world um

00:58:46,799 --> 00:58:50,160
i i believe so these are numbers taken

00:58:48,799 --> 00:58:53,280
from a from a

00:58:50,160 --> 00:58:55,520
from a large vendor so uh i don't think

00:58:53,280 --> 00:58:57,440
that they express what the use case was

00:58:55,520 --> 00:58:59,119
but it was sort of their typical

00:58:57,440 --> 00:59:01,520
operating numbers

00:58:59,119 --> 00:59:03,280
um do you know of efforts to get really

00:59:01,520 --> 00:59:03,839
open hardware descriptions to actually

00:59:03,280 --> 00:59:06,880
create an

00:59:03,839 --> 00:59:09,920
asic yourself a p4 pisa

00:59:06,880 --> 00:59:12,960
ah this is a great question um

00:59:09,920 --> 00:59:15,359
i i don't know of any efforts

00:59:12,960 --> 00:59:16,559
right now to create an open source

00:59:15,359 --> 00:59:18,640
switch

00:59:16,559 --> 00:59:20,799
but there are certainly a variety of

00:59:18,640 --> 00:59:23,920
different uh different models the

00:59:20,799 --> 00:59:26,160
the front end compiler uh for

00:59:23,920 --> 00:59:28,240
for p4 is open source as many of you

00:59:26,160 --> 00:59:29,200
know and so you can generate from the

00:59:28,240 --> 00:59:33,839
back end

00:59:29,200 --> 00:59:33,839
c or um other

00:59:34,319 --> 00:59:37,839
other models that you that you would

00:59:35,680 --> 00:59:40,000
want um but if you actually want to do

00:59:37,839 --> 00:59:43,839
back into a new device

00:59:40,000 --> 00:59:45,440
uh then it makes it pretty easy to do so

00:59:43,839 --> 00:59:47,839
it's essentially the front end that gets

00:59:45,440 --> 00:59:50,240
used by xilinx and others for

00:59:47,839 --> 00:59:51,200
their compilers for compiling to their

00:59:50,240 --> 00:59:54,319
devices

00:59:51,200 --> 00:59:56,000
as well so they're sort of emerging um i

00:59:54,319 --> 00:59:58,160
think this will happen over the next

00:59:56,000 --> 01:00:00,400
over the next few years risk five is a

00:59:58,160 --> 01:00:02,559
great platform

01:00:00,400 --> 01:00:03,839
it's not clear whether it's the platform

01:00:02,559 --> 01:00:05,839
that you'd want for switching

01:00:03,839 --> 01:00:09,520
but certainly for nix and smartnix it

01:00:05,839 --> 01:00:09,520
seems to be a very good device

01:00:10,960 --> 01:00:14,720
any other questions yeah so there are a

01:00:14,319 --> 01:00:16,559
bunch

01:00:14,720 --> 01:00:18,079
on the would you prefer people type

01:00:16,559 --> 01:00:20,079
their questions on the channel i'm fine

01:00:18,079 --> 01:00:22,559
either way i don't mind

01:00:20,079 --> 01:00:24,160
so you're you're still not on video so

01:00:22,559 --> 01:00:25,680
we'll just go to the chat then the next

01:00:24,160 --> 01:00:28,240
person is william

01:00:25,680 --> 01:00:30,000
king i think you can read that oh have

01:00:28,240 --> 01:00:30,960
you seen any progress to integrate a p4

01:00:30,000 --> 01:00:33,119
programmable switch

01:00:30,960 --> 01:00:36,319
or smartnic that has enabled support for

01:00:33,119 --> 01:00:40,240
epdf offload from the linux kernel

01:00:36,319 --> 01:00:42,720
um yeah okay um is a great question

01:00:40,240 --> 01:00:44,480
i think this gets right to the heart of

01:00:42,720 --> 01:00:47,599
what we need to be thinking about

01:00:44,480 --> 01:00:50,400
uh the answer is sort of i've seen

01:00:47,599 --> 01:00:52,559
some prototypes uh i believe there are a

01:00:50,400 --> 01:00:54,319
couple of proprietary approaches to

01:00:52,559 --> 01:00:56,880
doing this

01:00:54,319 --> 01:00:57,520
and you'll have seen some presentations

01:00:56,880 --> 01:01:00,319
here

01:00:57,520 --> 01:01:01,440
and elsewhere um and you know thinking

01:01:00,319 --> 01:01:03,119
along these lines

01:01:01,440 --> 01:01:05,200
um i don't know if william william two

01:01:03,119 --> 01:01:07,280
is is here on online

01:01:05,200 --> 01:01:08,960
from vmware clearly been thinking along

01:01:07,280 --> 01:01:11,520
these lines as well

01:01:08,960 --> 01:01:12,640
there was a p4 front end to ovs that was

01:01:11,520 --> 01:01:15,599
done as a research

01:01:12,640 --> 01:01:16,960
prototype by mohammed shabazz when he

01:01:15,599 --> 01:01:19,599
was doing his phd

01:01:16,960 --> 01:01:20,079
at princeton so there have been some

01:01:19,599 --> 01:01:23,440
some

01:01:20,079 --> 01:01:25,839
initial work for for doing this

01:01:23,440 --> 01:01:26,799
um i think there's actually a big need

01:01:25,839 --> 01:01:30,240
and i think that the

01:01:26,799 --> 01:01:32,799
the knowing where to start

01:01:30,240 --> 01:01:34,000
is is critical because you could just

01:01:32,799 --> 01:01:37,359
start by doing

01:01:34,000 --> 01:01:39,119
a straight p4 to eppf

01:01:37,359 --> 01:01:40,640
or the other way around and certainly

01:01:39,119 --> 01:01:41,599
some people have done that uh mihai

01:01:40,640 --> 01:01:44,799
budio

01:01:41,599 --> 01:01:47,280
at vmware has has worked on that more

01:01:44,799 --> 01:01:48,720
uh quite recently and so i think many of

01:01:47,280 --> 01:01:49,200
you are probably familiar with that so

01:01:48,720 --> 01:01:50,880
there's

01:01:49,200 --> 01:01:52,640
you know there's there's work and effort

01:01:50,880 --> 01:01:54,799
that's going on i think the bigger

01:01:52,640 --> 01:01:56,720
question that we need to address is

01:01:54,799 --> 01:01:57,920
so if you do this how does it fit into

01:01:56,720 --> 01:01:59,760
that whole pipeline

01:01:57,920 --> 01:02:01,359
because if we do this piecemeal we need

01:01:59,760 --> 01:02:03,119
the individual pieces for sure but if we

01:02:01,359 --> 01:02:04,640
do this piecemeal we don't end up with a

01:02:03,119 --> 01:02:06,559
consistent way of doing this

01:02:04,640 --> 01:02:08,160
across the entire pipeline so that's the

01:02:06,559 --> 01:02:08,720
sort of the question that's most in my

01:02:08,160 --> 01:02:11,839
mind

01:02:08,720 --> 01:02:12,799
at the moment i hope william i hope that

01:02:11,839 --> 01:02:14,960
answers your uh

01:02:12,799 --> 01:02:17,599
your question by all means jump in if

01:02:14,960 --> 01:02:17,599
you've got to follow up

01:02:18,240 --> 01:02:26,240
okay uh we're gonna uh pass it on to

01:02:22,079 --> 01:02:26,240
salil next okay

01:02:29,839 --> 01:02:36,640
i can't i can't can you guys hear him

01:02:33,119 --> 01:02:39,760
no okay

01:02:36,640 --> 01:02:39,760
and mute yourself please

01:02:45,440 --> 01:02:52,640
try that nope afraid we can't hear you

01:02:50,319 --> 01:02:54,160
okay uh let me let me jump to the next

01:02:52,640 --> 01:02:55,280
quest and then we'll see how your video

01:02:54,160 --> 01:02:56,799
works okay so

01:02:55,280 --> 01:02:58,559
and if you want to type it into the chat

01:02:56,799 --> 01:03:02,240
window i can uh we can try and answer it

01:02:58,559 --> 01:03:04,880
from there too

01:03:02,240 --> 01:03:05,920
okay so let let me uh are you going to

01:03:04,880 --> 01:03:09,039
type it something

01:03:05,920 --> 01:03:09,039
just node if yes

01:03:10,400 --> 01:03:13,760
i i can't hear you i don't know if

01:03:14,839 --> 01:03:19,760
anybody

01:03:16,480 --> 01:03:22,880
okay um there's a question here about

01:03:19,760 --> 01:03:24,720
um okay yeah terrace

01:03:22,880 --> 01:03:26,079
yes hi so first of all thank you for

01:03:24,720 --> 01:03:29,280
this and

01:03:26,079 --> 01:03:32,160
great speech i

01:03:29,280 --> 01:03:34,079
wondering uh you know i'm looking and

01:03:32,160 --> 01:03:37,039
thinking from the different direction

01:03:34,079 --> 01:03:38,079
having this model and having this uh

01:03:37,039 --> 01:03:41,680
flexibility

01:03:38,079 --> 01:03:45,119
from bottom to up uh will definitely

01:03:41,680 --> 01:03:46,880
for not force but leads

01:03:45,119 --> 01:03:49,520
for the cloud providers huge cloud

01:03:46,880 --> 01:03:52,960
providers to simplify their networks

01:03:49,520 --> 01:03:56,319
to remove some um matches to remove some

01:03:52,960 --> 01:03:58,400
headers from the protocol etc so

01:03:56,319 --> 01:03:59,440
their networks will become much much

01:03:58,400 --> 01:04:02,720
more

01:03:59,440 --> 01:04:05,359
faster maybe less latency etc but

01:04:02,720 --> 01:04:06,720
what will happen what when we will end

01:04:05,359 --> 01:04:10,000
up having

01:04:06,720 --> 01:04:11,680
three five or ten huge cloud vendors

01:04:10,000 --> 01:04:13,839
that have their own

01:04:11,680 --> 01:04:15,200
redesigned networking how we will

01:04:13,839 --> 01:04:18,400
interconnect them

01:04:15,200 --> 01:04:19,520
who will be responsible for managing

01:04:18,400 --> 01:04:23,119
this

01:04:19,520 --> 01:04:26,960
um standard way because we will now have

01:04:23,119 --> 01:04:29,359
five or six different ways of doing that

01:04:26,960 --> 01:04:30,079
yeah no there's a i i understand the

01:04:29,359 --> 01:04:32,160
fear

01:04:30,079 --> 01:04:33,359
uh the fear is palpable right you know

01:04:32,160 --> 01:04:36,480
you sort of uh

01:04:33,359 --> 01:04:38,400
feel feel it in your stomach right of

01:04:36,480 --> 01:04:39,920
what might happen if everybody was to

01:04:38,400 --> 01:04:41,920
try you could just sort of picture

01:04:39,920 --> 01:04:44,160
people coming together in uh

01:04:41,920 --> 01:04:45,760
uh in an ixp or something like this and

01:04:44,160 --> 01:04:46,880
saying how do we get these things to

01:04:45,760 --> 01:04:48,480
there's there's a great new yorker

01:04:46,880 --> 01:04:51,520
cartoon here somewhere

01:04:48,480 --> 01:04:53,839
um but seriously i think what what

01:04:51,520 --> 01:04:55,599
what is already happening is that the

01:04:53,839 --> 01:04:58,799
insides of cloud

01:04:55,599 --> 01:05:00,960
service provider networks are already

01:04:58,799 --> 01:05:02,559
non-standard they're already adding

01:05:00,960 --> 01:05:05,039
their own capabilities

01:05:02,559 --> 01:05:06,319
and they know that in order to speak to

01:05:05,039 --> 01:05:07,920
the rest of the world

01:05:06,319 --> 01:05:10,079
then they have to meet standards

01:05:07,920 --> 01:05:12,400
interoperable standards or boundaries

01:05:10,079 --> 01:05:14,319
on the the interconnects so everybody

01:05:12,400 --> 01:05:16,799
has to speak bgp5 right that's

01:05:14,319 --> 01:05:17,440
that's the way that things are done um

01:05:16,799 --> 01:05:20,720
and uh

01:05:17,440 --> 01:05:22,720
for now i think that will that has

01:05:20,720 --> 01:05:26,000
already allowed them to

01:05:22,720 --> 01:05:26,720
to try out new idea ideas some choose to

01:05:26,000 --> 01:05:28,480
simplify

01:05:26,720 --> 01:05:30,480
and reduce down to a very very small

01:05:28,480 --> 01:05:31,200
number of protocols unfortunately they

01:05:30,480 --> 01:05:33,039
all

01:05:31,200 --> 01:05:35,039
choose to simplify in different ways

01:05:33,039 --> 01:05:37,200
based on their own experiences but you

01:05:35,039 --> 01:05:38,799
know that's uh that's up to them

01:05:37,200 --> 01:05:40,480
uh they have to deal with the the

01:05:38,799 --> 01:05:42,400
consequences in internally

01:05:40,480 --> 01:05:44,160
some choose to make it richer in order

01:05:42,400 --> 01:05:45,920
to add things uh

01:05:44,160 --> 01:05:47,280
we may or may not do that ourselves but

01:05:45,920 --> 01:05:47,680
they're the ones who are in the network

01:05:47,280 --> 01:05:49,200
so

01:05:47,680 --> 01:05:51,280
you know it's up to them if that works

01:05:49,200 --> 01:05:52,720
for them but they still need to maintain

01:05:51,280 --> 01:05:55,440
a basic subset

01:05:52,720 --> 01:05:56,640
now you could imagine over time just to

01:05:55,440 --> 01:05:59,920
sort of

01:05:56,640 --> 01:06:02,079
run with your scary thought that a

01:05:59,920 --> 01:06:04,160
couple of operators may be a cloud

01:06:02,079 --> 01:06:05,119
service provider and an isp might get

01:06:04,160 --> 01:06:08,400
together and say

01:06:05,119 --> 01:06:10,720
hey we'll form our own mini uh

01:06:08,400 --> 01:06:12,640
you know autonomous system perhaps and

01:06:10,720 --> 01:06:15,200
outside on the boundaries of that

01:06:12,640 --> 01:06:16,079
we will continue to speak the standards

01:06:15,200 --> 01:06:17,280
bgp

01:06:16,079 --> 01:06:19,119
but internally we're going to do

01:06:17,280 --> 01:06:20,799
something that is richer and better

01:06:19,119 --> 01:06:22,720
we're going to actually allow ourselves

01:06:20,799 --> 01:06:23,440
to do something that is that is better

01:06:22,720 --> 01:06:25,680
just between

01:06:23,440 --> 01:06:27,039
just between the two of the two of us

01:06:25,680 --> 01:06:28,720
you know that could go very well if they

01:06:27,039 --> 01:06:30,079
can actually improve things because then

01:06:28,720 --> 01:06:31,440
that could grow over time you might get

01:06:30,079 --> 01:06:32,079
these islands that eventually become

01:06:31,440 --> 01:06:33,520
connected

01:06:32,079 --> 01:06:34,799
it could go very well it could go very

01:06:33,520 --> 01:06:36,319
badly but that's always true with

01:06:34,799 --> 01:06:37,599
software you know you can do good things

01:06:36,319 --> 01:06:41,039
and you can do bad things

01:06:37,599 --> 01:06:42,640
and i think that uh we it's good to

01:06:41,039 --> 01:06:43,039
enable people to try these things out

01:06:42,640 --> 01:06:44,720
because

01:06:43,039 --> 01:06:48,000
the good ideas will live on and the bad

01:06:44,720 --> 01:06:48,000
ideas hopefully will die out

01:06:48,799 --> 01:06:52,000
i'm not too i you know overall i'm not

01:06:50,880 --> 01:06:53,359
too worried about it

01:06:52,000 --> 01:06:55,440
because i think that the the vested

01:06:53,359 --> 01:06:56,240
interest of in the end having a network

01:06:55,440 --> 01:06:59,119
that is

01:06:56,240 --> 01:07:00,000
very reliable very secure and connects

01:06:59,119 --> 01:07:02,480
to all of

01:07:00,000 --> 01:07:04,160
the end customers is going to

01:07:02,480 --> 01:07:07,200
incentivize people to do the right thing

01:07:04,160 --> 01:07:07,200
or they're going to go out of business

01:07:07,280 --> 01:07:11,200
okay uh we'll go to there's a question

01:07:10,160 --> 01:07:14,720
on the chat

01:07:11,200 --> 01:07:16,480
nick by talk great

01:07:14,720 --> 01:07:18,720
other than the extern model do you have

01:07:16,480 --> 01:07:20,559
any thoughts on how to unify the p4 and

01:07:18,720 --> 01:07:23,200
cepbf programming model

01:07:20,559 --> 01:07:24,720
i.e you can compile p4 to ebbf yep but

01:07:23,200 --> 01:07:25,440
it doesn't produce very efficient code

01:07:24,720 --> 01:07:27,119
agreed

01:07:25,440 --> 01:07:28,799
and the reverse is hard can compilers be

01:07:27,119 --> 01:07:32,319
made smart enough to bridge this gap are

01:07:28,799 --> 01:07:33,920
we doomed to have a bifurcated ecosystem

01:07:32,319 --> 01:07:35,520
i really really hope that we're not

01:07:33,920 --> 01:07:35,839
doomed to have a bifurcated ecosystem i

01:07:35,520 --> 01:07:39,920
think

01:07:35,839 --> 01:07:41,839
that would be i i i think we should uh

01:07:39,920 --> 01:07:43,359
we deserve to be slapped if that happens

01:07:41,839 --> 01:07:45,359
right because we've got these

01:07:43,359 --> 01:07:47,119
two ways of doing things they're

01:07:45,359 --> 01:07:49,359
optimized for different environments so

01:07:47,119 --> 01:07:51,359
eppf is fantastic for the kernel

01:07:49,359 --> 01:07:52,400
p4 is fantastic for the hardware

01:07:51,359 --> 01:07:54,079
accelerator

01:07:52,400 --> 01:07:56,079
they're similar they're not the same and

01:07:54,079 --> 01:07:59,680
as said you can't efficiently

01:07:56,079 --> 01:08:02,240
necessarily um uh compile from

01:07:59,680 --> 01:08:04,079
in both directions super easily that's

01:08:02,240 --> 01:08:05,920
why we should work together to figure

01:08:04,079 --> 01:08:09,280
out how to how to bring these three

01:08:05,920 --> 01:08:09,599
bring these things together um and uh if

01:08:09,280 --> 01:08:11,200
we

01:08:09,599 --> 01:08:13,280
if we know that there is code that is

01:08:11,200 --> 01:08:13,760
always going to uh sit in the in the

01:08:13,280 --> 01:08:14,880
kernel

01:08:13,760 --> 01:08:16,319
we should do it in the ways that we're

01:08:14,880 --> 01:08:17,839
familiar with if we know it's always

01:08:16,319 --> 01:08:19,279
going to sit on an accelerator we should

01:08:17,839 --> 01:08:19,920
do it in the way that we're familiar

01:08:19,279 --> 01:08:21,679
with

01:08:19,920 --> 01:08:24,400
but at the boundary between the two

01:08:21,679 --> 01:08:26,080
figuring out how you can express in one

01:08:24,400 --> 01:08:27,839
that will generate efficient code for

01:08:26,080 --> 01:08:30,000
both i think that's the key

01:08:27,839 --> 01:08:31,279
i really do think that's the key so you

01:08:30,000 --> 01:08:33,839
can't do that easily

01:08:31,279 --> 01:08:34,719
today i do think that it will mean

01:08:33,839 --> 01:08:36,480
probably

01:08:34,719 --> 01:08:38,560
that things that you know that need to

01:08:36,480 --> 01:08:40,159
move to an accelerator you are going to

01:08:38,560 --> 01:08:41,920
have to create it in a constrained

01:08:40,159 --> 01:08:44,319
language which is designed to operate on

01:08:41,920 --> 01:08:46,960
an accelerator

01:08:44,319 --> 01:08:49,120
and it doesn't have to be p4 but p4 is

01:08:46,960 --> 01:08:51,279
such an example of a language that

01:08:49,120 --> 01:08:54,880
allows you to express in a familiar way

01:08:51,279 --> 01:08:56,799
tables parsing actions control flow

01:08:54,880 --> 01:08:58,400
in a way that's familiar to us that

01:08:56,799 --> 01:08:59,359
would allow it to move to an accelerator

01:08:58,400 --> 01:09:01,440
but if you know it's never going to go

01:08:59,359 --> 01:09:02,000
an accelerator no point in doing that at

01:09:01,440 --> 01:09:03,279
all

01:09:02,000 --> 01:09:04,960
and then the question is how do you

01:09:03,279 --> 01:09:06,640
build that pipeline how do you put

01:09:04,960 --> 01:09:07,839
things together in a pipeline such that

01:09:06,640 --> 01:09:10,400
you can drop in

01:09:07,839 --> 01:09:11,679
those different those different pieces i

01:09:10,400 --> 01:09:13,920
don't know the answer

01:09:11,679 --> 01:09:14,719
i have a rough rough idea of how it

01:09:13,920 --> 01:09:16,960
might look

01:09:14,719 --> 01:09:21,520
but uh it's going to take a concerted

01:09:16,960 --> 01:09:23,040
effort by us to to figure that out

01:09:21,520 --> 01:09:25,120
but let's not end up with a bifurcated

01:09:23,040 --> 01:09:26,480
ecosystem that would be crazy

01:09:25,120 --> 01:09:28,480
it'd be just shooting ourselves in the

01:09:26,480 --> 01:09:30,640
foot if we do that there's no need to do

01:09:28,480 --> 01:09:30,640
that

01:09:31,759 --> 01:09:38,080
the question there um about the the

01:09:34,239 --> 01:09:38,080
scope of the p4 and integrated nix

01:09:43,679 --> 01:09:51,199
so this was from surlil um

01:09:48,590 --> 01:09:54,080
[Music]

01:09:51,199 --> 01:09:54,560
so i think if i understand the correct

01:09:54,080 --> 01:09:57,679
the

01:09:54,560 --> 01:10:00,320
the the your question correctly salil uh

01:09:57,679 --> 01:10:01,280
i think it's about the the constraints

01:10:00,320 --> 01:10:05,360
that you have

01:10:01,280 --> 01:10:07,199
in in in in a neck now you know nicks

01:10:05,360 --> 01:10:08,880
have to go into a slot that's power

01:10:07,199 --> 01:10:10,560
limited

01:10:08,880 --> 01:10:12,719
remember the exact number you know it's

01:10:10,560 --> 01:10:13,360
50 60 70 watts something like that as a

01:10:12,719 --> 01:10:15,040
maximum

01:10:13,360 --> 01:10:17,199
for the for the power that it can

01:10:15,040 --> 01:10:20,239
consume in pcie

01:10:17,199 --> 01:10:20,560
um and you know you've got to choose how

01:10:20,239 --> 01:10:23,040
you

01:10:20,560 --> 01:10:25,440
allocate that power very carefully the

01:10:23,040 --> 01:10:26,880
the basic fix function foundational nics

01:10:25,440 --> 01:10:29,840
today

01:10:26,880 --> 01:10:30,719
have a relatively low power they're

01:10:29,840 --> 01:10:32,239
they're not doing

01:10:30,719 --> 01:10:34,000
very much other than processing the

01:10:32,239 --> 01:10:35,600
packets in and out onto the

01:10:34,000 --> 01:10:37,120
onto the wire as you add more

01:10:35,600 --> 01:10:39,920
functionality to that

01:10:37,120 --> 01:10:40,480
uh you know there's some some folks who

01:10:39,920 --> 01:10:42,800
are running

01:10:40,480 --> 01:10:44,400
entire uh operating systems and vm

01:10:42,800 --> 01:10:45,199
monitors and all sorts of other things

01:10:44,400 --> 01:10:48,239
down on the

01:10:45,199 --> 01:10:49,600
on the smart neck on the on cpu cores

01:10:48,239 --> 01:10:50,800
that's running software that might

01:10:49,600 --> 01:10:54,000
otherwise run on the

01:10:50,800 --> 01:10:56,239
on the server cpus the power

01:10:54,000 --> 01:10:58,320
of the pipeline that's doing the packet

01:10:56,239 --> 01:10:59,840
processing as the packets go through

01:10:58,320 --> 01:11:02,080
i think it's always going to be a small

01:10:59,840 --> 01:11:02,480
fraction of the overall power of a smart

01:11:02,080 --> 01:11:04,400
neck

01:11:02,480 --> 01:11:05,840
so this isn't this isn't the power

01:11:04,400 --> 01:11:08,960
problem for a smart neck

01:11:05,840 --> 01:11:10,239
so introducing a programmable fast

01:11:08,960 --> 01:11:11,679
programmable accelerator

01:11:10,239 --> 01:11:13,040
isn't going to be the issue it's that

01:11:11,679 --> 01:11:14,400
you're going to have a whole load of cp

01:11:13,040 --> 01:11:16,159
cpu cores there or

01:11:14,400 --> 01:11:18,000
rather people seem to want to have a

01:11:16,159 --> 01:11:20,320
large number of cpu cores there

01:11:18,000 --> 01:11:21,920
as well and that's going to dictate the

01:11:20,320 --> 01:11:22,800
power so i'm not particularly worried

01:11:21,920 --> 01:11:27,840
about the

01:11:22,800 --> 01:11:27,840
the hardware accelerator portion of it

01:11:31,440 --> 01:11:35,440
by all means ask a follow-up if i if i

01:11:33,199 --> 01:11:36,880
miss the point of your question

01:11:35,440 --> 01:11:38,239
christian has a question there it seems

01:11:36,880 --> 01:11:40,000
allowing for stateful programming to

01:11:38,239 --> 01:11:41,840
allow for very powerful network programs

01:11:40,000 --> 01:11:44,560
however it also seems to be hard to do

01:11:41,840 --> 01:11:46,400
generalize without ending up with an npu

01:11:44,560 --> 01:11:47,679
are we stuck with limited stateful

01:11:46,400 --> 01:11:49,520
techniques if we want to use something

01:11:47,679 --> 01:11:52,560
like p4

01:11:49,520 --> 01:11:54,480
um this isn't actually a question of p4

01:11:52,560 --> 01:11:56,080
it's really got to do with the ability

01:11:54,480 --> 01:11:59,120
to do things at line rate

01:11:56,080 --> 01:12:00,960
um and uh so p4 is just really kind of a

01:11:59,120 --> 01:12:02,480
reflection of the fact that in order to

01:12:00,960 --> 01:12:04,239
be able to do things that line right you

01:12:02,480 --> 01:12:07,440
want to limit the number of loops

01:12:04,239 --> 01:12:09,360
the number of the number of you know

01:12:07,440 --> 01:12:12,080
cycles that a packet would go through in

01:12:09,360 --> 01:12:12,880
in processing so in in stateful

01:12:12,080 --> 01:12:14,640
processing

01:12:12,880 --> 01:12:16,159
think about what stateful processing

01:12:14,640 --> 01:12:19,520
typically is it's

01:12:16,159 --> 01:12:22,000
indexing into some state and then

01:12:19,520 --> 01:12:24,560
potentially modifying and updating that

01:12:22,000 --> 01:12:26,400
state as a packet goes through if you

01:12:24,560 --> 01:12:29,520
can do that as a read modifier right

01:12:26,400 --> 01:12:31,199
on some table as is typical of the

01:12:29,520 --> 01:12:34,560
switch and nick pipelines

01:12:31,199 --> 01:12:36,800
then there's it's not really

01:12:34,560 --> 01:12:38,880
it it doesn't really have a performance

01:12:36,800 --> 01:12:40,560
uh problem associated with it

01:12:38,880 --> 01:12:42,400
it's harder to design the hardware to do

01:12:40,560 --> 01:12:42,960
a read modify write rather than just a

01:12:42,400 --> 01:12:44,880
read

01:12:42,960 --> 01:12:46,239
on a table but the pipelines already

01:12:44,880 --> 01:12:48,080
exist in order to do that to some

01:12:46,239 --> 01:12:50,560
limited amount so tofino does it some of

01:12:48,080 --> 01:12:52,560
the smartnics do it as well

01:12:50,560 --> 01:12:53,840
so that doesn't actually slow the

01:12:52,560 --> 01:12:55,280
packets down

01:12:53,840 --> 01:12:56,960
consumes slightly more power to do a

01:12:55,280 --> 01:12:57,679
read modify right than just simply a

01:12:56,960 --> 01:12:59,040
read

01:12:57,679 --> 01:13:01,040
in the end it's not a very large

01:12:59,040 --> 01:13:04,880
fraction of the overall power

01:13:01,040 --> 01:13:07,360
if you want to do things like un

01:13:04,880 --> 01:13:08,320
sort of decapulate a very very large

01:13:07,360 --> 01:13:10,719
number of headers

01:13:08,320 --> 01:13:11,920
that is beyond the length of a pipeline

01:13:10,719 --> 01:13:14,880
then that can get tricky

01:13:11,920 --> 01:13:15,679
so if you've designed a pipeline with 10

01:13:14,880 --> 01:13:18,880
stages

01:13:15,679 --> 01:13:21,600
and now you do segment routing with 25

01:13:18,880 --> 01:13:23,120
headers on the front then you may end up

01:13:21,600 --> 01:13:24,800
having to recirculate a packet because

01:13:23,120 --> 01:13:25,199
of the serial dependency of unwrapping

01:13:24,800 --> 01:13:26,719
them

01:13:25,199 --> 01:13:28,400
if in fact you need to unwrap all of

01:13:26,719 --> 01:13:31,920
them at a single point

01:13:28,400 --> 01:13:32,800
um so then then but i would i would sort

01:13:31,920 --> 01:13:35,280
of put it to

01:13:32,800 --> 01:13:36,880
just though we also need to design the

01:13:35,280 --> 01:13:38,800
things that we do a little bit more

01:13:36,880 --> 01:13:41,679
carefully so we don't introduce such

01:13:38,800 --> 01:13:42,320
crazy amounts of processing um one of

01:13:41,679 --> 01:13:44,239
the reasons

01:13:42,320 --> 01:13:46,560
if i may ramble a little bit one of the

01:13:44,239 --> 01:13:49,360
reasons that these switch pipelines

01:13:46,560 --> 01:13:50,000
tend not to have that many stages is

01:13:49,360 --> 01:13:53,520
because

01:13:50,000 --> 01:13:54,880
of protocol layering in protocol

01:13:53,520 --> 01:13:56,239
layering if you think about it

01:13:54,880 --> 01:13:57,840
the reason for having the layers in the

01:13:56,239 --> 01:13:59,920
first place was for a separation of

01:13:57,840 --> 01:14:01,360
concerns a separation of what's

01:13:59,920 --> 01:14:02,800
happening at each

01:14:01,360 --> 01:14:04,640
at each independent header and typically

01:14:02,800 --> 01:14:06,400
we add an extra layer of

01:14:04,640 --> 01:14:08,239
encapsulation because we want to

01:14:06,400 --> 01:14:09,920
introduce a new independent function

01:14:08,239 --> 01:14:10,960
that's not represented by the underlying

01:14:09,920 --> 01:14:13,760
protocols

01:14:10,960 --> 01:14:14,239
so it tends not to be dependent and so

01:14:13,760 --> 01:14:16,480
you can

01:14:14,239 --> 01:14:17,840
end up doing many of these processing

01:14:16,480 --> 01:14:21,440
stages in parallel

01:14:17,840 --> 01:14:22,880
so for example it's common for 20 25

01:14:21,440 --> 01:14:23,440
different operations to be done in

01:14:22,880 --> 01:14:24,880
parallel

01:14:23,440 --> 01:14:27,040
in a single stage of a forwarding

01:14:24,880 --> 01:14:30,159
pipeline if there's no serial

01:14:27,040 --> 01:14:32,000
if there's no serial dependency when

01:14:30,159 --> 01:14:35,199
we're designing new

01:14:32,000 --> 01:14:37,199
headers we should probably be careful

01:14:35,199 --> 01:14:39,360
and mindful of the fact that if we add

01:14:37,199 --> 01:14:40,800
in too much extra dependency whether

01:14:39,360 --> 01:14:42,719
it's massive amounts of

01:14:40,800 --> 01:14:44,400
nested encapsulation that we're going to

01:14:42,719 --> 01:14:45,360
pay for it in the end in some kind of

01:14:44,400 --> 01:14:47,600
processing

01:14:45,360 --> 01:14:48,560
whatever that processing element is so

01:14:47,600 --> 01:14:50,400
we need to be thoughtful

01:14:48,560 --> 01:14:52,480
we don't want to restrict what we do too

01:14:50,400 --> 01:14:54,880
much but

01:14:52,480 --> 01:14:56,080
we i think it just it just tells us that

01:14:54,880 --> 01:14:58,640
we have to be thoughtful about the way

01:14:56,080 --> 01:14:58,640
that we do that

01:14:59,040 --> 01:15:02,560
uh nick you skipped andrew collins

01:15:01,840 --> 01:15:04,080
question

01:15:02,560 --> 01:15:05,520
oh sorry i didn't see that one sorry it

01:15:04,080 --> 01:15:06,480
scrolled off the top here let me see if

01:15:05,520 --> 01:15:08,480
i can get to that one

01:15:06,480 --> 01:15:11,040
oh yeah another somewhat related

01:15:08,480 --> 01:15:13,440
question in gpus the extension model of

01:15:11,040 --> 01:15:15,120
opengl ended up being used for a wide

01:15:13,440 --> 01:15:16,480
variety of vendor-specific extension

01:15:15,120 --> 01:15:17,679
that caused significant portability

01:15:16,480 --> 01:15:22,000
problems

01:15:17,679 --> 01:15:25,280
yeah great question um

01:15:22,000 --> 01:15:28,480
so the the idea of the psa

01:15:25,280 --> 01:15:31,679
the portable switch architecture in p416

01:15:28,480 --> 01:15:35,040
um is to encourage

01:15:31,679 --> 01:15:37,920
portability around basic operations so

01:15:35,040 --> 01:15:38,880
parsing standard match and action uh

01:15:37,920 --> 01:15:41,440
primitives

01:15:38,880 --> 01:15:43,199
and a standard uh control flow through

01:15:41,440 --> 01:15:44,560
the through the program so

01:15:43,199 --> 01:15:46,320
the psa or the portable switch

01:15:44,560 --> 01:15:48,960
architecture

01:15:46,320 --> 01:15:49,920
uh is a good starting point so tofino

01:15:48,960 --> 01:15:52,080
for example is a

01:15:49,920 --> 01:15:53,120
is a superset of the portable switch

01:15:52,080 --> 01:15:54,960
architecture

01:15:53,120 --> 01:15:56,239
other switches that people have

01:15:54,960 --> 01:15:58,239
developed or are developing

01:15:56,239 --> 01:16:00,159
are a superset of the portable switch

01:15:58,239 --> 01:16:02,159
architecture so code written for one

01:16:00,159 --> 01:16:04,239
should work on the others as long as it

01:16:02,159 --> 01:16:06,480
conforms to that psa

01:16:04,239 --> 01:16:08,080
that's good for basic functions and so

01:16:06,480 --> 01:16:08,719
hopefully we'll allow portability of

01:16:08,080 --> 01:16:11,600
things which

01:16:08,719 --> 01:16:12,880
are basic operations because that psa is

01:16:11,600 --> 01:16:14,239
kind of designed to be able to do all

01:16:12,880 --> 01:16:16,159
the things that we normally

01:16:14,239 --> 01:16:18,080
expect to be able to do is encapsulation

01:16:16,159 --> 01:16:18,880
decalculation telemetry all of these

01:16:18,080 --> 01:16:20,400
kinds of things

01:16:18,880 --> 01:16:22,480
however if you want to add something in

01:16:20,400 --> 01:16:25,760
there which is very very different

01:16:22,480 --> 01:16:27,360
um some type of key value store lookup

01:16:25,760 --> 01:16:29,040
or some kind of sort of paxos

01:16:27,360 --> 01:16:30,320
implementation for example that's done

01:16:29,040 --> 01:16:31,520
streaming in the hardware

01:16:30,320 --> 01:16:33,520
you may or may not find that the

01:16:31,520 --> 01:16:35,199
hardware is capable of doing it

01:16:33,520 --> 01:16:37,120
um in which case you've got to add that

01:16:35,199 --> 01:16:39,679
extension so i think that the

01:16:37,120 --> 01:16:40,880
the the important the important thing is

01:16:39,679 --> 01:16:42,960
that over time

01:16:40,880 --> 01:16:44,239
as we observe the kinds of programs that

01:16:42,960 --> 01:16:46,840
people are creating

01:16:44,239 --> 01:16:48,320
we need to evolve the portable switch

01:16:46,840 --> 01:16:50,480
architecture

01:16:48,320 --> 01:16:51,679
and uh there's a backward compatibility

01:16:50,480 --> 01:16:52,719
versioning problem here we're going to

01:16:51,679 --> 01:16:53,679
make sure that we don't do it too

01:16:52,719 --> 01:16:55,679
aggressively

01:16:53,679 --> 01:16:57,920
otherwise we're going to prevent you

01:16:55,679 --> 01:17:00,480
know prevent code from being portable

01:16:57,920 --> 01:17:01,920
in a backward compatible way so we've

01:17:00,480 --> 01:17:02,640
got to be mindful though of doing this

01:17:01,920 --> 01:17:04,400
for switches

01:17:02,640 --> 01:17:05,679
and for nicks there's a working group at

01:17:04,400 --> 01:17:06,800
the moment on the portable nick

01:17:05,679 --> 01:17:08,800
architecture

01:17:06,800 --> 01:17:10,960
for evolving smart necks to try and

01:17:08,800 --> 01:17:12,400
accomplish the same thing for nics

01:17:10,960 --> 01:17:13,440
and nick's have different architectures

01:17:12,400 --> 01:17:15,199
they have their different needs they've

01:17:13,440 --> 01:17:16,640
got the whole interaction with pcie and

01:17:15,199 --> 01:17:18,560
the host and the host memory

01:17:16,640 --> 01:17:19,920
and so they need to be capable of being

01:17:18,560 --> 01:17:22,239
extended in that direction

01:17:19,920 --> 01:17:24,080
as we learn what operations every nic

01:17:22,239 --> 01:17:26,080
has and every switch has

01:17:24,080 --> 01:17:28,159
it's imperative that we go back and try

01:17:26,080 --> 01:17:29,120
and add it to a portable switch or

01:17:28,159 --> 01:17:31,760
portable nic

01:17:29,120 --> 01:17:32,880
model to encourage that portability so

01:17:31,760 --> 01:17:34,560
we've got to be very

01:17:32,880 --> 01:17:36,080
very very mindful and i think it's upon

01:17:34,560 --> 01:17:38,480
us to try and make sure that that

01:17:36,080 --> 01:17:38,480
happens

01:17:40,320 --> 01:17:45,840
any other questions

01:17:46,800 --> 01:17:50,159
i i have a question nick so

01:17:50,400 --> 01:17:54,239
you your slide which you showed the big

01:17:52,400 --> 01:17:55,360
picture of

01:17:54,239 --> 01:17:58,480
essentially you're programming the

01:17:55,360 --> 01:18:00,239
network now it's a hierarchy of devices

01:17:58,480 --> 01:18:02,080
uh you're programming from one

01:18:00,239 --> 01:18:04,640
programming point of view

01:18:02,080 --> 01:18:06,480
assuming intent of some phone of what

01:18:04,640 --> 01:18:09,760
you had achieved

01:18:06,480 --> 01:18:11,760
uh do you see that as hierarchically

01:18:09,760 --> 01:18:12,800
the processing is hierarchical where you

01:18:11,760 --> 01:18:15,120
would do

01:18:12,800 --> 01:18:16,000
let's say offload something in the nic

01:18:15,120 --> 01:18:17,679
that recom

01:18:16,000 --> 01:18:20,400
that computation doesn't get repeated on

01:18:17,679 --> 01:18:21,840
the host likewise if you offload on the

01:18:20,400 --> 01:18:24,480
switch

01:18:21,840 --> 01:18:26,159
so there's a hierarchy of computation as

01:18:24,480 --> 01:18:27,920
opposed to the current model where

01:18:26,159 --> 01:18:30,080
i write a p4 program i'm describing the

01:18:27,920 --> 01:18:33,520
whole full uh

01:18:30,080 --> 01:18:36,719
process pipeline basically

01:18:33,520 --> 01:18:40,080
yeah so

01:18:36,719 --> 01:18:42,880
in a way i think that the that um what's

01:18:40,080 --> 01:18:46,000
happened because of disaggregation

01:18:42,880 --> 01:18:46,880
is that we now have uh we have

01:18:46,000 --> 01:18:49,120
abstractions

01:18:46,880 --> 01:18:50,000
in two dimensions we have abstractions

01:18:49,120 --> 01:18:52,640
of

01:18:50,000 --> 01:18:54,400
of the forwarding plane you know the old

01:18:52,640 --> 01:18:56,400
layering model and you know

01:18:54,400 --> 01:18:57,760
the the seven four layer model whatever

01:18:56,400 --> 01:18:58,960
we want to call that right so we had

01:18:57,760 --> 01:19:00,000
that abstraction that have been around

01:18:58,960 --> 01:19:01,440
for a long time

01:19:00,000 --> 01:19:02,719
what's happened over the last 10 years

01:19:01,440 --> 01:19:03,199
is people have started to create their

01:19:02,719 --> 01:19:04,960
own

01:19:03,199 --> 01:19:06,480
their own control planes we've got this

01:19:04,960 --> 01:19:08,080
hierarchy that moves vertically in the

01:19:06,480 --> 01:19:08,719
control plane and the layers of

01:19:08,080 --> 01:19:10,239
abstraction

01:19:08,719 --> 01:19:12,880
for anyone here that hasn't seen scott

01:19:10,239 --> 01:19:14,719
schenker's talk on network abstractions

01:19:12,880 --> 01:19:16,640
i think it's called the history of the

01:19:14,719 --> 01:19:17,760
history of protocols and the future of

01:19:16,640 --> 01:19:19,600
networking or something that was from

01:19:17,760 --> 01:19:22,400
about 2011 2012.

01:19:19,600 --> 01:19:24,480
i think is the best video i've ever seen

01:19:22,400 --> 01:19:26,960
or the best talk i've seen about sort of

01:19:24,480 --> 01:19:28,320
where networking is heading from a sort

01:19:26,960 --> 01:19:29,760
of how we're going to control that

01:19:28,320 --> 01:19:31,360
it's about the creation of abstractions

01:19:29,760 --> 01:19:33,120
in the vertical direction as well as the

01:19:31,360 --> 01:19:35,679
horizontal direction

01:19:33,120 --> 01:19:37,199
so there there there's there's lots of

01:19:35,679 --> 01:19:38,800
room for confusion

01:19:37,199 --> 01:19:40,320
right so is processing that takes place

01:19:38,800 --> 01:19:41,679
on a server that could be control plane

01:19:40,320 --> 01:19:43,040
software it could be data plane

01:19:41,679 --> 01:19:44,800
forwarding software

01:19:43,040 --> 01:19:46,080
and right now we tend to separate those

01:19:44,800 --> 01:19:47,679
and that's probably a good thing to do

01:19:46,080 --> 01:19:48,880
otherwise we're going to go crazy unless

01:19:47,679 --> 01:19:51,280
we separate those

01:19:48,880 --> 01:19:52,880
those two portions but as more and more

01:19:51,280 --> 01:19:55,280
of it moves to being expressed

01:19:52,880 --> 01:19:56,400
in code whether it's at the end host or

01:19:55,280 --> 01:19:58,800
in the forwarding plane

01:19:56,400 --> 01:19:59,440
then we will start to blur blur those

01:19:58,800 --> 01:20:01,760
lines

01:19:59,440 --> 01:20:03,040
so that abstraction that i showed of a

01:20:01,760 --> 01:20:05,280
forwarding pipeline

01:20:03,040 --> 01:20:07,760
that has a clean separation to a control

01:20:05,280 --> 01:20:10,960
plane and applications that run over top

01:20:07,760 --> 01:20:12,800
that's just an example uh that

01:20:10,960 --> 01:20:14,480
that seems to work quite well there are

01:20:12,800 --> 01:20:15,120
many that are heading in that direction

01:20:14,480 --> 01:20:17,199
right now

01:20:15,120 --> 01:20:18,159
that may not be the end point and that's

01:20:17,199 --> 01:20:20,080
fine

01:20:18,159 --> 01:20:22,239
uh so i think that there will be a

01:20:20,080 --> 01:20:25,760
hierarchy in both directions

01:20:22,239 --> 01:20:27,199
over over time and we just have to be

01:20:25,760 --> 01:20:28,960
mindful of

01:20:27,199 --> 01:20:31,280
allowing a clean expression and the

01:20:28,960 --> 01:20:33,360
ability to be able to test validate

01:20:31,280 --> 01:20:35,520
both at the time of writing the code

01:20:33,360 --> 01:20:37,040
visualizing what it means for the device

01:20:35,520 --> 01:20:40,239
it's being programmed for

01:20:37,040 --> 01:20:42,080
validating the behavior in the wild

01:20:40,239 --> 01:20:44,560
and that's that you know that will be

01:20:42,080 --> 01:20:44,560
imperative

01:20:44,639 --> 01:20:50,320
if you had something specific in mind

01:20:46,239 --> 01:20:50,320
jamal and then happy to chat about it

01:20:50,560 --> 01:20:53,280
yeah um

01:20:53,679 --> 01:20:57,920
yeah so i've been struggling with this

01:20:55,199 --> 01:21:01,040
for some time i mean we

01:20:57,920 --> 01:21:02,719
you know is for example on smart nick uh

01:21:01,040 --> 01:21:04,639
on the horse side do i want to do

01:21:02,719 --> 01:21:05,520
reclassification again or could i just

01:21:04,639 --> 01:21:07,040
receive a tag

01:21:05,520 --> 01:21:08,800
which tells me what's been done on the

01:21:07,040 --> 01:21:13,679
neck likewise and

01:21:08,800 --> 01:21:15,280
in the scope of um

01:21:13,679 --> 01:21:17,199
i i think that in your own private

01:21:15,280 --> 01:21:20,159
network you can you can literally

01:21:17,199 --> 01:21:21,360
define your own p4 program um thinking

01:21:20,159 --> 01:21:24,480
maybe

01:21:21,360 --> 01:21:26,320
um for a few hours you run a brand new

01:21:24,480 --> 01:21:28,159
protocol all together and then

01:21:26,320 --> 01:21:29,440
you know remove all your code and

01:21:28,159 --> 01:21:32,560
somebody else will install

01:21:29,440 --> 01:21:33,920
another propriety data path that's

01:21:32,560 --> 01:21:38,080
hierarchical

01:21:33,920 --> 01:21:40,840
yes to achieve a specific uh goal

01:21:38,080 --> 01:21:42,239
and if you're going to do hierarchical

01:21:40,840 --> 01:21:44,719
then

01:21:42,239 --> 01:21:46,239
the the programming paradigm changes

01:21:44,719 --> 01:21:47,120
right it's not it's no longer just i'm

01:21:46,239 --> 01:21:50,159
going to write some

01:21:47,120 --> 01:21:53,440
evpf code or a p4 module

01:21:50,159 --> 01:21:54,800
that uh that's local to the process it's

01:21:53,440 --> 01:21:56,080
as if i take the match actions and i

01:21:54,800 --> 01:21:57,199
sprayed them across the hierarchies as

01:21:56,080 --> 01:21:59,920
opposed to yes

01:21:57,199 --> 01:22:01,040
yeah no i think this is i i i think this

01:21:59,920 --> 01:22:02,880
actually gets to the essence of the

01:22:01,040 --> 01:22:05,280
problem right you've got behavior

01:22:02,880 --> 01:22:07,040
that at the time that you're creating it

01:22:05,280 --> 01:22:09,120
you're not quite sure whether it

01:22:07,040 --> 01:22:10,239
belongs in one place or the other will

01:22:09,120 --> 01:22:12,480
get replicated

01:22:10,239 --> 01:22:14,719
or needs to move and even needs to move

01:22:12,480 --> 01:22:15,920
dynamically depending on the particular

01:22:14,719 --> 01:22:19,040
you know whether you're talking

01:22:15,920 --> 01:22:21,520
remotely to someone over a over a

01:22:19,040 --> 01:22:22,080
you know many many layers of hierarchy

01:22:21,520 --> 01:22:24,400
or

01:22:22,080 --> 01:22:26,000
locally just over a running summary so

01:22:24,400 --> 01:22:26,719
you can easily imagine repetition of

01:22:26,000 --> 01:22:28,159
function

01:22:26,719 --> 01:22:30,400
and that function over time you might

01:22:28,159 --> 01:22:31,199
want to optimize to be able to remove

01:22:30,400 --> 01:22:33,120
the repetition

01:22:31,199 --> 01:22:34,880
or you may want to be able to move it or

01:22:33,120 --> 01:22:36,320
enable or disable it if you're finding

01:22:34,880 --> 01:22:37,360
that it's being repeated in multiple

01:22:36,320 --> 01:22:41,199
locations

01:22:37,360 --> 01:22:43,760
so the the we mustn't think of it

01:22:41,199 --> 01:22:45,040
as separate pieces we really mustn't um

01:22:43,760 --> 01:22:48,320
um uh

01:22:45,040 --> 01:22:49,760
uh i i we i think we would be missed you

01:22:48,320 --> 01:22:50,320
know i think your question gets to the

01:22:49,760 --> 01:22:53,280
to

01:22:50,320 --> 01:22:54,480
to the danger here if we think of it as

01:22:53,280 --> 01:22:56,000
we're programming a nick

01:22:54,480 --> 01:22:57,920
we're programming a switch we're

01:22:56,000 --> 01:22:59,600
programming a kernel we're programming

01:22:57,920 --> 01:23:03,520
we're doing user space programming

01:22:59,600 --> 01:23:03,520
if we keep thinking in that that that

01:23:03,679 --> 01:23:07,520
that separate that separate vulcanized

01:23:05,679 --> 01:23:10,159
way then

01:23:07,520 --> 01:23:11,600
then we will never we will never make it

01:23:10,159 --> 01:23:13,520
easy we will just

01:23:11,600 --> 01:23:15,600
present the developer with more

01:23:13,520 --> 01:23:17,520
complexity so thinking about how things

01:23:15,600 --> 01:23:18,880
can move across that boundary that's why

01:23:17,520 --> 01:23:21,520
i think we have to think of

01:23:18,880 --> 01:23:23,120
how you can express behavior that will

01:23:21,520 --> 01:23:25,840
run efficiently

01:23:23,120 --> 01:23:27,840
in a kernel that you could pick up that

01:23:25,840 --> 01:23:29,199
behavior and then move it and run it in

01:23:27,840 --> 01:23:30,480
a hardware accelerator and a nick you

01:23:29,199 --> 01:23:31,520
can't you don't just have the choice of

01:23:30,480 --> 01:23:33,280
putting it in the core

01:23:31,520 --> 01:23:34,719
out on a neck you can put it on the

01:23:33,280 --> 01:23:36,239
accelerator in the neck or you can move

01:23:34,719 --> 01:23:37,040
it out to the switch if that benefits

01:23:36,239 --> 01:23:39,040
you

01:23:37,040 --> 01:23:42,320
and eventually because it because if we

01:23:39,040 --> 01:23:42,320
can do that eventually

01:23:42,719 --> 01:23:45,760
the programmer doesn't even have to make

01:23:44,000 --> 01:23:47,199
that choice themselves they express the

01:23:45,760 --> 01:23:48,480
behavior that they want

01:23:47,199 --> 01:23:50,080
and then it's dynamically moved

01:23:48,480 --> 01:23:51,199
depending on the best way to allocate it

01:23:50,080 --> 01:23:54,880
across that pipeline

01:23:51,199 --> 01:23:56,960
i know that sounds sounds crazy now but

01:23:54,880 --> 01:23:58,800
within a decade why can't we be there

01:23:56,960 --> 01:24:00,320
such that you can express that behavior

01:23:58,800 --> 01:24:02,080
you know for example as i gave on

01:24:00,320 --> 01:24:03,679
congestion control and routing

01:24:02,080 --> 01:24:06,159
if i want that behavior and i don't

01:24:03,679 --> 01:24:08,880
particularly care where it is

01:24:06,159 --> 01:24:10,239
that the rtt is measured whether it's in

01:24:08,880 --> 01:24:11,440
the kernel whether it's in the nick or

01:24:10,239 --> 01:24:12,560
if it's some assistance between the

01:24:11,440 --> 01:24:15,360
knicks and the switches

01:24:12,560 --> 01:24:16,800
why do i as a as a developer care why

01:24:15,360 --> 01:24:18,320
can't i figure it out for me

01:24:16,800 --> 01:24:20,400
that's what abstraction should bring me

01:24:18,320 --> 01:24:21,679
over time the ability for it to place

01:24:20,400 --> 01:24:22,239
that function at the place that's

01:24:21,679 --> 01:24:24,000
optimal

01:24:22,239 --> 01:24:25,840
and if it finds that it's repeating it

01:24:24,000 --> 01:24:26,320
in the wrong places it should remove it

01:24:25,840 --> 01:24:28,719
and i should

01:24:26,320 --> 01:24:30,320
shouldn't even need to know um yeah i'll

01:24:28,719 --> 01:24:31,600
give my hubby horse a little bit and say

01:24:30,320 --> 01:24:33,679
you know you notice when you get

01:24:31,600 --> 01:24:35,840
networking folks together

01:24:33,679 --> 01:24:37,440
in a room or you know like this we we

01:24:35,840 --> 01:24:39,120
tend to end up talking about packet

01:24:37,440 --> 01:24:40,080
header formats and bits and things like

01:24:39,120 --> 01:24:42,960
that

01:24:40,080 --> 01:24:44,800
all right it would be a bit like two i

01:24:42,960 --> 01:24:45,440
know java programmers that were talking

01:24:44,800 --> 01:24:48,960
about

01:24:45,440 --> 01:24:50,960
uh register allocation you know it's

01:24:48,960 --> 01:24:53,199
abstraction means that we shouldn't need

01:24:50,960 --> 01:24:56,560
to worry about these low-level details

01:24:53,199 --> 01:24:59,199
but in networking we still do and

01:24:56,560 --> 01:25:00,800
uh it's i think it's our job to try and

01:24:59,199 --> 01:25:02,080
make it to liberate us from having to

01:25:00,800 --> 01:25:03,040
worry about these things and so your

01:25:02,080 --> 01:25:05,520
question is right on

01:25:03,040 --> 01:25:05,520
about that

01:25:06,800 --> 01:25:14,080
okay uh you're trying to make a comment

01:25:11,040 --> 01:25:16,719
well on mean i i think i was just hey

01:25:14,080 --> 01:25:18,560
nick nice to see you again um i was

01:25:16,719 --> 01:25:19,920
actually just costing off of your point

01:25:18,560 --> 01:25:22,320
uh

01:25:19,920 --> 01:25:23,920
jamal which is the hierarchy whether i'm

01:25:22,320 --> 01:25:25,760
actually this is sort of a question for

01:25:23,920 --> 01:25:27,199
you as well i mean as we get into the

01:25:25,760 --> 01:25:28,320
notion of being able to move things

01:25:27,199 --> 01:25:29,920
around

01:25:28,320 --> 01:25:31,440
one very practical thing that i think

01:25:29,920 --> 01:25:33,040
we'll end up with is an intermediate

01:25:31,440 --> 01:25:34,960
representation right i mean if you think

01:25:33,040 --> 01:25:37,199
really if you carry even your

01:25:34,960 --> 01:25:38,639
java analogy to the extreme if you

01:25:37,199 --> 01:25:40,639
really are saying that

01:25:38,639 --> 01:25:42,480
the objects could live anywhere you want

01:25:40,639 --> 01:25:44,000
you will have to have sort of a compiler

01:25:42,480 --> 01:25:45,920
intermediate

01:25:44,000 --> 01:25:47,520
that lives across your networking

01:25:45,920 --> 01:25:48,480
continuum whether it's the kernel it's a

01:25:47,520 --> 01:25:50,480
switch or the

01:25:48,480 --> 01:25:52,560
neck or the core on the neck right

01:25:50,480 --> 01:25:53,440
because the example that you run into

01:25:52,560 --> 01:25:55,760
all the time is

01:25:53,440 --> 01:25:57,120
if i'm doing overlay networking the

01:25:55,760 --> 01:25:57,920
overlay routing table is being

01:25:57,120 --> 01:26:00,080
replicated

01:25:57,920 --> 01:26:01,920
identical routing tables been replicated

01:26:00,080 --> 01:26:04,960
in every switch in every nick

01:26:01,920 --> 01:26:06,719
sorry makes no sense it's a giant waste

01:26:04,960 --> 01:26:08,639
of dram

01:26:06,719 --> 01:26:10,480
but you want the application of the

01:26:08,639 --> 01:26:10,960
encap d cap in the nick because that's

01:26:10,480 --> 01:26:13,600
the

01:26:10,960 --> 01:26:14,639
best place to do it so you end up with

01:26:13,600 --> 01:26:16,159
some

01:26:14,639 --> 01:26:18,239
something right you have to be able to

01:26:16,159 --> 01:26:20,239
say okay i'm going to

01:26:18,239 --> 01:26:22,000
do the end cap dcap classification and

01:26:20,239 --> 01:26:25,040
i'm going to tell the switch to

01:26:22,000 --> 01:26:26,480
actually put the header on because you

01:26:25,040 --> 01:26:28,880
might as well put the header there so

01:26:26,480 --> 01:26:30,639
so i think in in addition to your mix

01:26:28,880 --> 01:26:33,120
there has to be another like

01:26:30,639 --> 01:26:35,199
okay if the two of you are cooperating

01:26:33,120 --> 01:26:37,040
this is a set of tags or this is a set

01:26:35,199 --> 01:26:38,480
of

01:26:37,040 --> 01:26:40,400
symbols that you can exchange and

01:26:38,480 --> 01:26:43,199
continue with yeah

01:26:40,400 --> 01:26:45,520
possibly yes and i mean i think that um

01:26:43,199 --> 01:26:48,880
a means of expressing a behavior that

01:26:45,520 --> 01:26:51,440
can readily be accelerated or or

01:26:48,880 --> 01:26:52,880
exploit all the generality of a of a cpu

01:26:51,440 --> 01:26:54,719
based on whether it's needed

01:26:52,880 --> 01:26:56,320
and then the ability to move between the

01:26:54,719 --> 01:26:57,280
two uh

01:26:56,320 --> 01:26:58,480
it's when you want to be able to move

01:26:57,280 --> 01:26:59,840
between the two clearly which is the

01:26:58,480 --> 01:27:01,280
hard case because you want to exploit

01:26:59,840 --> 01:27:02,880
the generality of the cpu and you want

01:27:01,280 --> 01:27:04,000
it hardware accelerated and those two

01:27:02,880 --> 01:27:05,840
things are are

01:27:04,000 --> 01:27:08,159
in tension with each other so it's that

01:27:05,840 --> 01:27:10,639
case i hope that we don't end up with a

01:27:08,159 --> 01:27:12,320
way that burdens both of the extremes

01:27:10,639 --> 01:27:14,239
just for the sake of the middle ground

01:27:12,320 --> 01:27:14,880
and that's that's the that's the tricky

01:27:14,239 --> 01:27:17,199
part

01:27:14,880 --> 01:27:19,360
and so i think that uh you know allowing

01:27:17,199 --> 01:27:21,280
that that that freedom to do things that

01:27:19,360 --> 01:27:22,239
are expressed entirely in the hardware

01:27:21,280 --> 01:27:25,360
accelerator

01:27:22,239 --> 01:27:28,080
language or entirely in the cpu language

01:27:25,360 --> 01:27:29,280
is important so that we don't restrict

01:27:28,080 --> 01:27:30,800
those when they don't need to be

01:27:29,280 --> 01:27:32,159
restricted it's that middle ground

01:27:30,800 --> 01:27:33,520
that's going to be the tricky and then

01:27:32,159 --> 01:27:34,800
intermediate representation may be the

01:27:33,520 --> 01:27:36,400
right way to do it

01:27:34,800 --> 01:27:37,520
and i think that's why that's why i

01:27:36,400 --> 01:27:38,560
think we've got to get our heads

01:27:37,520 --> 01:27:40,400
together around that

01:27:38,560 --> 01:27:42,320
right and that's my point i think if you

01:27:40,400 --> 01:27:43,199
don't take a hard stance on that

01:27:42,320 --> 01:27:45,360
intermediate

01:27:43,199 --> 01:27:46,960
exactly as you said right the the

01:27:45,360 --> 01:27:49,920
tension to innovate in

01:27:46,960 --> 01:27:51,360
different vectors will result in sort of

01:27:49,920 --> 01:27:53,199
canceling the other side out

01:27:51,360 --> 01:27:55,199
yeah i think so yeah and you know just

01:27:53,199 --> 01:27:57,040
to sort of make a maybe this is a this

01:27:55,199 --> 01:27:57,760
is a this is a poor chase uh sort of

01:27:57,040 --> 01:28:00,719
analogy but

01:27:57,760 --> 01:28:01,360
you know you look at how it the insides

01:28:00,719 --> 01:28:02,719
of

01:28:01,360 --> 01:28:04,639
movements where there are different

01:28:02,719 --> 01:28:06,960
ideas whether political movements

01:28:04,639 --> 01:28:08,320
religious movements over over time

01:28:06,960 --> 01:28:10,000
there's always this sort of this

01:28:08,320 --> 01:28:11,679
tendency to get very stuck on a

01:28:10,000 --> 01:28:14,000
particular approach

01:28:11,679 --> 01:28:15,760
and we you know the the everybody gets

01:28:14,000 --> 01:28:17,760
expelled from the party or from the

01:28:15,760 --> 01:28:19,600
from the religion they're not sort of

01:28:17,760 --> 01:28:21,760
following the particular model

01:28:19,600 --> 01:28:23,600
and where there's a breakout innovation

01:28:21,760 --> 01:28:25,120
is where people can figure out the best

01:28:23,600 --> 01:28:28,000
of two ideas and bring them

01:28:25,120 --> 01:28:28,800
bring them together and uh so you know

01:28:28,000 --> 01:28:30,560
we we need to

01:28:28,800 --> 01:28:31,840
i think just to avoid any infighting

01:28:30,560 --> 01:28:33,040
we're going to sort of try and figure

01:28:31,840 --> 01:28:34,239
out how we can bring these two together

01:28:33,040 --> 01:28:37,520
and i think the only way to do it

01:28:34,239 --> 01:28:40,400
is there are two good organizations with

01:28:37,520 --> 01:28:42,320
p4.org on the and and netdev and

01:28:40,400 --> 01:28:46,159
figuring out how those can

01:28:42,320 --> 01:28:49,600
in a very informed way just

01:28:46,159 --> 01:28:52,800
figure out a solution to this and um

01:28:49,600 --> 01:28:54,400
i'm i'm all for that uh nate foster

01:28:52,800 --> 01:28:57,120
unfortunately wasn't able to join us

01:28:54,400 --> 01:28:59,760
he's sort of the technical lead of p4

01:28:57,120 --> 01:29:01,280
and uh he's super interested in doing

01:28:59,760 --> 01:29:01,520
that i talked to him a few days ago he's

01:29:01,280 --> 01:29:04,080
uh

01:29:01,520 --> 01:29:07,760
in the woods right now but uh it'd be

01:29:04,080 --> 01:29:07,760
delighted to be a part of that as well

01:29:08,000 --> 01:29:11,760
so the resource resource management and

01:29:10,239 --> 01:29:14,080
all that discovery

01:29:11,760 --> 01:29:15,760
will have to be built so is the is this

01:29:14,080 --> 01:29:16,480
intermediate representation going to

01:29:15,760 --> 01:29:18,719
take

01:29:16,480 --> 01:29:20,239
that because this stuff gets to be run

01:29:18,719 --> 01:29:21,520
right you're not controlling one device

01:29:20,239 --> 01:29:22,639
you're controlling the hierarchy of

01:29:21,520 --> 01:29:25,440
devices

01:29:22,639 --> 01:29:27,120
and you know both horizontally and

01:29:25,440 --> 01:29:29,280
vertically right

01:29:27,120 --> 01:29:30,719
yeah i think eventually that we will

01:29:29,280 --> 01:29:35,360
need eventually

01:29:30,719 --> 01:29:37,520
so i i do think it it's still um

01:29:35,360 --> 01:29:39,600
it's still most pragmatic to keep the

01:29:37,520 --> 01:29:41,120
control and the data plane expression

01:29:39,600 --> 01:29:43,120
separate from each other you're creating

01:29:41,120 --> 01:29:44,719
a pipeline for which you then control i

01:29:43,120 --> 01:29:48,000
mean we tend to do that whether

01:29:44,719 --> 01:29:49,440
we're writing you know cpu code or or

01:29:48,000 --> 01:29:51,199
forwarding plain code

01:29:49,440 --> 01:29:52,560
and um you know this is where this p4

01:29:51,199 --> 01:29:55,360
runtime model came

01:29:52,560 --> 01:29:56,960
came about as the generation of an api

01:29:55,360 --> 01:30:00,159
and uh it actually has a lot of

01:29:56,960 --> 01:30:01,280
benefits that uh that that that sort of

01:30:00,159 --> 01:30:02,719
general model of

01:30:01,280 --> 01:30:04,480
taking the expression the forwarding

01:30:02,719 --> 01:30:05,600
behavior and generating the api to

01:30:04,480 --> 01:30:07,199
control it

01:30:05,600 --> 01:30:08,639
i think there may be something to borrow

01:30:07,199 --> 01:30:10,080
there in the separation of the two

01:30:08,639 --> 01:30:10,639
dimensions of the control from the

01:30:10,080 --> 01:30:12,960
forwarding

01:30:10,639 --> 01:30:14,080
but then when you have a hierarchy of

01:30:12,960 --> 01:30:17,120
things that are

01:30:14,080 --> 01:30:20,480
that are in the forwarding plane then

01:30:17,120 --> 01:30:21,280
um if i think we should try to figure

01:30:20,480 --> 01:30:24,239
out how to

01:30:21,280 --> 01:30:25,760
to express it as a pipeline i you know

01:30:24,239 --> 01:30:27,600
this may just be a different

01:30:25,760 --> 01:30:29,840
sort of philosophical standing point i

01:30:27,600 --> 01:30:32,239
tend to think of the layering

01:30:29,840 --> 01:30:33,440
as sometimes the in the forwarding plane

01:30:32,239 --> 01:30:35,760
is sometimes useful

01:30:33,440 --> 01:30:38,080
sometimes getting in the way right so

01:30:35,760 --> 01:30:40,400
the example that triggy gave of

01:30:38,080 --> 01:30:41,679
overlay networking as having this whole

01:30:40,400 --> 01:30:44,239
other layer

01:30:41,679 --> 01:30:45,679
in the hierarchy if you're trying to

01:30:44,239 --> 01:30:46,800
accelerate it you want to know as little

01:30:45,679 --> 01:30:48,880
about that as possible

01:30:46,800 --> 01:30:50,880
and collapse it down into i'm just doing

01:30:48,880 --> 01:30:52,560
a look-up i don't care where it is

01:30:50,880 --> 01:30:53,120
whether it's in the kernel or the user

01:30:52,560 --> 01:30:55,199
space

01:30:53,120 --> 01:30:56,719
or out on the neck or in the v-switch or

01:30:55,199 --> 01:30:58,159
in the physical switch i shouldn't have

01:30:56,719 --> 01:30:59,440
to care about i'm doing a look-up i just

01:30:58,159 --> 01:31:02,320
needed to get done somewhere

01:30:59,440 --> 01:31:03,600
and i need to know that it happened and

01:31:02,320 --> 01:31:05,199
so i think that if we can

01:31:03,600 --> 01:31:07,280
if we can think that we're accelerating

01:31:05,199 --> 01:31:08,000
and and humans are not going to be very

01:31:07,280 --> 01:31:10,639
good at

01:31:08,000 --> 01:31:11,360
collapsing that hierarchy and so i think

01:31:10,639 --> 01:31:13,440
that's where

01:31:11,360 --> 01:31:15,040
where compilation and automation will be

01:31:13,440 --> 01:31:17,840
our friend and we'll need to do that

01:31:15,040 --> 01:31:17,840
otherwise we'll get it wrong

01:31:20,560 --> 01:31:26,480
uh we can continue if people

01:31:24,159 --> 01:31:28,719
still have questions otherwise we are

01:31:26,480 --> 01:31:31,840
right on time

01:31:28,719 --> 01:31:31,840
any other questions

01:31:35,920 --> 01:31:40,800
hml this is anjali hey uh nick sorry i

01:31:38,880 --> 01:31:41,440
joined late and i missed most of your

01:31:40,800 --> 01:31:43,840
talk

01:31:41,440 --> 01:31:45,600
uh but i i just wanted to uh you know

01:31:43,840 --> 01:31:47,920
thank you and jamal for

01:31:45,600 --> 01:31:49,760
such an interesting uh you know

01:31:47,920 --> 01:31:50,320
philosophical debate about where we need

01:31:49,760 --> 01:31:53,199
to be

01:31:50,320 --> 01:31:54,560
rather than you know i mean yes there's

01:31:53,199 --> 01:31:56,080
the technical aspect of it but the

01:31:54,560 --> 01:31:59,920
bigger picture where

01:31:56,080 --> 01:32:02,480
uh you know we put it from from

01:31:59,920 --> 01:32:03,199
uh what is the minimum we need to

01:32:02,480 --> 01:32:06,320
achieve

01:32:03,199 --> 01:32:06,719
um effective networking uh i think that

01:32:06,320 --> 01:32:09,360
was

01:32:06,719 --> 01:32:09,760
really useful to think through thank you

01:32:09,360 --> 01:32:11,840
thank you

01:32:09,760 --> 01:32:13,520
thank you appreciate it yeah it's i see

01:32:11,840 --> 01:32:17,199
a little red flashing dot that says it's

01:32:13,520 --> 01:32:17,199
being recorded if that's useful later

01:32:20,560 --> 01:32:24,080
any other questions christian is that a

01:32:23,040 --> 01:32:27,840
question or

01:32:24,080 --> 01:32:27,840
it's a comment

01:32:28,960 --> 01:32:32,080
the more general the hardware is the

01:32:30,400 --> 01:32:33,760
more i can offload to it but then we end

01:32:32,080 --> 01:32:36,000
up with an npu and that's not efficient

01:32:33,760 --> 01:32:38,400
agree 100 so we're going to be very

01:32:36,000 --> 01:32:40,239
careful right a hardware accelerator

01:32:38,400 --> 01:32:42,159
is is an accelerator so long as it's

01:32:40,239 --> 01:32:44,239
accelerating something and

01:32:42,159 --> 01:32:46,159
and sort of falling back to that npu

01:32:44,239 --> 01:32:48,239
model would be would be a big mistake so

01:32:46,159 --> 01:32:49,760
i think we're to think in terms of

01:32:48,239 --> 01:32:51,280
we're accelerating things through a

01:32:49,760 --> 01:32:55,840
specific structure

01:32:51,280 --> 01:32:55,840
deeply pipelined lots of parallelism

01:32:56,159 --> 01:32:59,840
and a parallelism that's fitted with

01:32:57,679 --> 01:33:01,360
packet processing and huge amounts of io

01:32:59,840 --> 01:33:02,320
as soon as we move away from that it

01:33:01,360 --> 01:33:03,360
ain't going to be very good as an

01:33:02,320 --> 01:33:05,120
accelerator

01:33:03,360 --> 01:33:09,840
bye everybody look forward to working

01:33:05,120 --> 01:33:09,840

YouTube URL: https://www.youtube.com/watch?v=fiBuao6YZl0


