Title: Netdev 0x14 - Have you ever tried to create complex network service chains with eBPF?
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Sebastiano Miano, Alex Palesandro, Yunsong Lu, Jianwen Pi, Aasif Shaikh, Mauricio Vasquez Bernal, Fulvio Risso

More info: https://netdevconf.info/0x14/session.html?talk-complex-network-service-chains-with-eBPF

Date: Monday, August 17, 2020

eBPF is great but unfortunately tends to gravitate to the appliance
model; IOW, lumping data and control in one-off pile which solves
a simple problem.
Writing complex network services with eBPF is therefore painful.

In this moonshot talk, Fulvio Risso introduces
the Polycube project that eases ability to write complex
network services with eBPF.
Polycube network services have an architecture that moves
away from the appliance model by separating data from control
and management plane. With its model-driven architecture,
Polycube exposes REST APIs for service management.

This talk will go into some detail of the Polycube APIs
and abstractions and then illustrate the power of Polycube
with a small live demo.
Captions: 
	00:00:02,720 --> 00:00:07,279
hello everybody

00:00:04,080 --> 00:00:09,599
so this talk is about uh uh a friend

00:00:07,279 --> 00:00:12,799
sort of framework that we created

00:00:09,599 --> 00:00:15,759
um we started about three years ago

00:00:12,799 --> 00:00:16,400
uh which is called polycube and the

00:00:15,759 --> 00:00:19,760
problem

00:00:16,400 --> 00:00:22,240
that we were facing at the time was that

00:00:19,760 --> 00:00:23,119
in the traditional networking world

00:00:22,240 --> 00:00:26,640
we're uh

00:00:23,119 --> 00:00:30,560
used to work with let's say little boxes

00:00:26,640 --> 00:00:33,040
so like we create we have a bridge

00:00:30,560 --> 00:00:33,680
we connect to a router then we connect

00:00:33,040 --> 00:00:37,200
or not

00:00:33,680 --> 00:00:40,239
and then a firewall and then

00:00:37,200 --> 00:00:43,680
while in the virtual world that we are

00:00:40,239 --> 00:00:44,879
used in the recent years this model is

00:00:43,680 --> 00:00:48,000
not that clear

00:00:44,879 --> 00:00:51,199
and what we would like to do is to

00:00:48,000 --> 00:00:54,160
try to recreate exactly the same model

00:00:51,199 --> 00:00:54,559
of course where physical machiners are

00:00:54,160 --> 00:00:56,800
now

00:00:54,559 --> 00:00:59,039
virtual machines but then where the

00:00:56,800 --> 00:00:59,680
virtual machines can be connected to a

00:00:59,039 --> 00:01:03,440
bridge

00:00:59,680 --> 00:01:06,479
and then a router and a knot and so on

00:01:03,440 --> 00:01:09,760
and this was not that

00:01:06,479 --> 00:01:11,040
easy right now so our software framework

00:01:09,760 --> 00:01:13,840
the polycube

00:01:11,040 --> 00:01:16,080
brings the well-known paradigm used in

00:01:13,840 --> 00:01:19,600
the traditional world like

00:01:16,080 --> 00:01:23,280
boxes ports and links

00:01:19,600 --> 00:01:26,799
that connect between port and boxes

00:01:23,280 --> 00:01:29,920
in the linux virtualized world in order

00:01:26,799 --> 00:01:32,240
to recreate english the same

00:01:29,920 --> 00:01:33,680
familiar environment that were used to

00:01:32,240 --> 00:01:36,960
in the physical world

00:01:33,680 --> 00:01:39,520
of course we don't want to give up on

00:01:36,960 --> 00:01:40,320
efficiency and that's the reason we

00:01:39,520 --> 00:01:43,360
choose the

00:01:40,320 --> 00:01:46,960
ebpf internal processing

00:01:43,360 --> 00:01:50,880
so given this high level goal let's say

00:01:46,960 --> 00:01:54,720
long term goal the path to polycube

00:01:50,880 --> 00:01:57,920
has been has been determined

00:01:54,720 --> 00:02:01,360
trying to solve the following problems

00:01:57,920 --> 00:02:01,840
first i think that many people uh try to

00:02:01,360 --> 00:02:04,640
create

00:02:01,840 --> 00:02:05,680
a network service with ebdf and they

00:02:04,640 --> 00:02:08,160
recognize that

00:02:05,680 --> 00:02:08,800
in the end is not that simple and the

00:02:08,160 --> 00:02:11,680
reason

00:02:08,800 --> 00:02:12,800
is that network services are not just

00:02:11,680 --> 00:02:16,239
data planning

00:02:12,800 --> 00:02:19,760
while i mean ebpf is very strong in that

00:02:16,239 --> 00:02:22,800
blind processing second when you

00:02:19,760 --> 00:02:26,400
want to create a complex network service

00:02:22,800 --> 00:02:28,480
you have to handle network topologies so

00:02:26,400 --> 00:02:29,920
it's not just a matter of creating a

00:02:28,480 --> 00:02:33,360
very powerful

00:02:29,920 --> 00:02:36,080
advancer or a very powerful router

00:02:33,360 --> 00:02:37,599
you have to create many services and

00:02:36,080 --> 00:02:40,560
chain them together

00:02:37,599 --> 00:02:41,440
and this is not some something that is

00:02:40,560 --> 00:02:45,840
so simple

00:02:41,440 --> 00:02:49,120
in virtualized environment third

00:02:45,840 --> 00:02:50,800
when we create a network service can we

00:02:49,120 --> 00:02:53,920
simplify the life

00:02:50,800 --> 00:02:56,560
of the developer of the service itself

00:02:53,920 --> 00:02:58,959
so that the developer can concentrate on

00:02:56,560 --> 00:03:01,360
the high level logic of its service if

00:02:58,959 --> 00:03:04,159
it is a router maybe a routing protocol

00:03:01,360 --> 00:03:05,120
and left forwarding but let's say let's

00:03:04,159 --> 00:03:08,159
avoid

00:03:05,120 --> 00:03:09,120
all the ancillary tasks that are often

00:03:08,159 --> 00:03:12,400
needed

00:03:09,120 --> 00:03:15,599
in this world and they can bring you

00:03:12,400 --> 00:03:16,319
a lot of time and this is not really

00:03:15,599 --> 00:03:19,280
something that

00:03:16,319 --> 00:03:20,000
you would like to spend time on that

00:03:19,280 --> 00:03:22,560
basically

00:03:20,000 --> 00:03:23,120
also thinking about the vpf hiding

00:03:22,560 --> 00:03:26,239
difference

00:03:23,120 --> 00:03:26,640
between tc and xdp is very important

00:03:26,239 --> 00:03:30,159
because

00:03:26,640 --> 00:03:33,519
your service can execute the different

00:03:30,159 --> 00:03:34,640
points in the networking step for a

00:03:33,519 --> 00:03:37,519
similar reason

00:03:34,640 --> 00:03:38,640
we would like to simplify the life of

00:03:37,519 --> 00:03:41,680
network admins

00:03:38,640 --> 00:03:43,680
so the guy who runs the service who

00:03:41,680 --> 00:03:44,319
deploys the router the bridge and the

00:03:43,680 --> 00:03:47,360
nas

00:03:44,319 --> 00:03:47,920
in order to create and control its

00:03:47,360 --> 00:03:51,120
network

00:03:47,920 --> 00:03:51,840
quality and finally we don't want to

00:03:51,120 --> 00:03:54,879
give up

00:03:51,840 --> 00:03:58,000
on performance and we would like to

00:03:54,879 --> 00:04:00,560
leverage the best of the linux ecosystem

00:03:58,000 --> 00:04:01,920
so we don't want to reinvent everything

00:04:00,560 --> 00:04:05,040
from scratch

00:04:01,920 --> 00:04:07,200
so those are basically the questions

00:04:05,040 --> 00:04:08,959
the more detailed questions that we try

00:04:07,200 --> 00:04:12,799
to answer when we create

00:04:08,959 --> 00:04:16,000
policy we started about three years ago

00:04:12,799 --> 00:04:19,840
so let's try to see how this

00:04:16,000 --> 00:04:22,560
framework software framework works

00:04:19,840 --> 00:04:23,040
splitting this presentation in let's say

00:04:22,560 --> 00:04:24,800
six

00:04:23,040 --> 00:04:26,479
different objectives the first

00:04:24,800 --> 00:04:29,919
objectives is

00:04:26,479 --> 00:04:32,960
we try to create a common structure

00:04:29,919 --> 00:04:35,840
and abstraction for network function

00:04:32,960 --> 00:04:36,880
which means that definitely network

00:04:35,840 --> 00:04:40,240
functions are

00:04:36,880 --> 00:04:42,960
usually made in three components

00:04:40,240 --> 00:04:44,479
the first is the data plan the data plan

00:04:42,960 --> 00:04:46,080
is very important is in charge of

00:04:44,479 --> 00:04:48,400
forwarding packets

00:04:46,080 --> 00:04:49,680
but if you go a little bit deeper all

00:04:48,400 --> 00:04:53,040
the network devices

00:04:49,680 --> 00:04:56,000
have two kinds of data planning first

00:04:53,040 --> 00:04:57,919
the fast path which is in charge of most

00:04:56,000 --> 00:04:58,720
of the packets so the packets are coming

00:04:57,919 --> 00:05:00,400
the first part

00:04:58,720 --> 00:05:02,080
is doing something to the packets and

00:05:00,400 --> 00:05:05,440
sending them out

00:05:02,080 --> 00:05:08,320
like forwarding in a router and then

00:05:05,440 --> 00:05:10,639
there's usually a slow path component

00:05:08,320 --> 00:05:13,759
which is in charge of the

00:05:10,639 --> 00:05:16,960
tasks which are still data paths but

00:05:13,759 --> 00:05:18,320
that does not happen often like for

00:05:16,960 --> 00:05:21,520
instance i would like to

00:05:18,320 --> 00:05:22,560
handle our request okay this is

00:05:21,520 --> 00:05:24,479
something that

00:05:22,560 --> 00:05:26,479
has to be done in your router but it

00:05:24,479 --> 00:05:28,800
doesn't happen so often

00:05:26,479 --> 00:05:30,240
if we move that logic in the slow path

00:05:28,800 --> 00:05:33,440
we can create a

00:05:30,240 --> 00:05:34,560
much slimmer fast path which means it's

00:05:33,440 --> 00:05:37,120
much faster

00:05:34,560 --> 00:05:38,560
but still we have the possibility to

00:05:37,120 --> 00:05:41,919
handle that traffic

00:05:38,560 --> 00:05:45,039
in the slow path uh because uh it's

00:05:41,919 --> 00:05:48,240
really needed in case of ebtf

00:05:45,039 --> 00:05:51,039
we have one more reason for having

00:05:48,240 --> 00:05:53,600
this slow path the fact that the first

00:05:51,039 --> 00:05:57,120
part so the internal processing

00:05:53,600 --> 00:05:59,120
is not um complete so we cannot do

00:05:57,120 --> 00:06:02,080
whatever we wanted in the first part

00:05:59,120 --> 00:06:03,280
because we know ebf has some well-known

00:06:02,080 --> 00:06:06,800
limitations

00:06:03,280 --> 00:06:10,240
so in our case the slow path is created

00:06:06,800 --> 00:06:13,360
in user space is not related to

00:06:10,240 --> 00:06:14,479
ebdf and you can do there anything you

00:06:13,360 --> 00:06:17,600
want so you are not

00:06:14,479 --> 00:06:18,720
no longer limited by the limitation of

00:06:17,600 --> 00:06:21,039
the evpn

00:06:18,720 --> 00:06:22,960
so that's the reason one more reason for

00:06:21,039 --> 00:06:25,360
which we have the slow path

00:06:22,960 --> 00:06:26,720
and then of course control and

00:06:25,360 --> 00:06:29,759
management plan

00:06:26,720 --> 00:06:30,639
so all the algorithms in order to

00:06:29,759 --> 00:06:33,680
control

00:06:30,639 --> 00:06:36,479
like uh control the routing protocols

00:06:33,680 --> 00:06:37,440
or to show statistics or configure your

00:06:36,479 --> 00:06:40,000
service

00:06:37,440 --> 00:06:40,800
are here in the control and management

00:06:40,000 --> 00:06:43,759
plan

00:06:40,800 --> 00:06:47,440
also running user space so you don't

00:06:43,759 --> 00:06:51,039
have any limitations related to ebbs

00:06:47,440 --> 00:06:54,000
the programmer that creates this service

00:06:51,039 --> 00:06:54,880
has to concentrate on these three boxes

00:06:54,000 --> 00:06:57,680
slow path

00:06:54,880 --> 00:07:00,000
fast path and control and management and

00:06:57,680 --> 00:07:00,800
all the interaction between all those

00:07:00,000 --> 00:07:04,080
components

00:07:00,800 --> 00:07:06,400
are handled by the polycube framework

00:07:04,080 --> 00:07:08,160
automatically you have just to say send

00:07:06,400 --> 00:07:10,960
this packet to the slow path

00:07:08,160 --> 00:07:11,919
and that's it by magic the packet comes

00:07:10,960 --> 00:07:14,560
on the slow path

00:07:11,919 --> 00:07:15,199
and so on so all the glue logic made

00:07:14,560 --> 00:07:18,560
together

00:07:15,199 --> 00:07:21,120
by policy second

00:07:18,560 --> 00:07:22,800
service function training so let's see

00:07:21,120 --> 00:07:23,520
the service function changing from the

00:07:22,800 --> 00:07:26,720
perspective

00:07:23,520 --> 00:07:28,560
of the user the final user so

00:07:26,720 --> 00:07:30,080
let's imagine you have a linux server

00:07:28,560 --> 00:07:31,919
with three virtual machine

00:07:30,080 --> 00:07:33,840
or something like that and a network

00:07:31,919 --> 00:07:36,080
card and we would like to create a

00:07:33,840 --> 00:07:39,360
network service in between

00:07:36,080 --> 00:07:41,520
so what can we do okay

00:07:39,360 --> 00:07:42,800
let's connect to a bridge so let's

00:07:41,520 --> 00:07:45,919
create first

00:07:42,800 --> 00:07:46,360
a bridge okay and this is the common

00:07:45,919 --> 00:07:49,680
line

00:07:46,360 --> 00:07:52,560
polycubectl is our common line interface

00:07:49,680 --> 00:07:53,039
which is used to create the bridge and

00:07:52,560 --> 00:07:56,240
then

00:07:53,039 --> 00:07:59,520
you create a port on a bridge this

00:07:56,240 --> 00:08:02,560
port here and then you connect

00:07:59,520 --> 00:08:04,720
this port into a virtual machine

00:08:02,560 --> 00:08:06,479
and then of course you create a second

00:08:04,720 --> 00:08:07,199
port connect to the second vehicle

00:08:06,479 --> 00:08:09,759
machine

00:08:07,199 --> 00:08:11,120
third port and then connect to the third

00:08:09,759 --> 00:08:14,240
virtual machine

00:08:11,120 --> 00:08:15,120
and finally you create a fourth port to

00:08:14,240 --> 00:08:17,360
a router

00:08:15,120 --> 00:08:18,720
but right now you cannot connect to the

00:08:17,360 --> 00:08:22,080
router because the router

00:08:18,720 --> 00:08:22,960
doesn't exist yet so let's create a

00:08:22,080 --> 00:08:25,599
router

00:08:22,960 --> 00:08:26,080
okay create it now let's create the

00:08:25,599 --> 00:08:29,120
first

00:08:26,080 --> 00:08:31,520
port to the router toward

00:08:29,120 --> 00:08:34,080
the bridge let's connect the bridge

00:08:31,520 --> 00:08:36,719
let's create a second port to the router

00:08:34,080 --> 00:08:38,560
let's connect to the nic and that's it

00:08:36,719 --> 00:08:41,120
i'm cheating a little bit because

00:08:38,560 --> 00:08:42,880
the router has to be configured so we

00:08:41,120 --> 00:08:43,519
have to configure the routing table and

00:08:42,880 --> 00:08:46,720
so on but

00:08:43,519 --> 00:08:48,880
still you can see the power of

00:08:46,720 --> 00:08:50,480
service function chaining in political

00:08:48,880 --> 00:08:54,959
you can create

00:08:50,480 --> 00:08:57,360
connect ports devices and

00:08:54,959 --> 00:09:00,000
network functions together pretty easily

00:08:57,360 --> 00:09:02,480
with the same command line interface

00:09:00,000 --> 00:09:04,800
this is not possible in the traditional

00:09:02,480 --> 00:09:08,000
edpf world i mean it's not that simple

00:09:04,800 --> 00:09:11,200
so what how can we do this

00:09:08,000 --> 00:09:14,240
uh so what we do is that once

00:09:11,200 --> 00:09:17,360
we create a bridge or a router

00:09:14,240 --> 00:09:17,760
in the kernel when you create those in

00:09:17,360 --> 00:09:20,560
fact

00:09:17,760 --> 00:09:22,720
we create always some additional

00:09:20,560 --> 00:09:26,800
preprocessor and post-processor

00:09:22,720 --> 00:09:30,000
programs toward associated to each

00:09:26,800 --> 00:09:32,720
one of the network function and those

00:09:30,000 --> 00:09:35,279
preprocessor and post processors

00:09:32,720 --> 00:09:36,959
are just there in order to simplify the

00:09:35,279 --> 00:09:40,720
connection between

00:09:36,959 --> 00:09:44,080
one program to the other so the bridge

00:09:40,720 --> 00:09:46,080
the edtf bridge and the edpf router

00:09:44,080 --> 00:09:47,200
so that you can link the program

00:09:46,080 --> 00:09:50,000
together and this

00:09:47,200 --> 00:09:50,640
allows enables the command line

00:09:50,000 --> 00:09:54,080
interface

00:09:50,640 --> 00:09:55,600
as simple as we said before for the same

00:09:54,080 --> 00:09:58,320
reason we have to create

00:09:55,600 --> 00:09:58,959
additional programs associated with the

00:09:58,320 --> 00:10:01,360
input

00:09:58,959 --> 00:10:02,480
and output devices in order to allow

00:10:01,360 --> 00:10:05,360
this kind of

00:10:02,480 --> 00:10:07,279
very flexible chaining and of course we

00:10:05,360 --> 00:10:11,279
have to create some helpers

00:10:07,279 --> 00:10:14,240
to be used within each one of the ebbf

00:10:11,279 --> 00:10:16,240
program in order to allow the packet to

00:10:14,240 --> 00:10:18,800
be sent to the next

00:10:16,240 --> 00:10:19,920
block in the chain which can be another

00:10:18,800 --> 00:10:22,800
edpf program

00:10:19,920 --> 00:10:23,120
or a physical virtual interface and so

00:10:22,800 --> 00:10:26,240
that

00:10:23,120 --> 00:10:28,160
this uh helper doesn't change i mean

00:10:26,240 --> 00:10:30,079
it changes the behavior but it doesn't

00:10:28,160 --> 00:10:32,399
change from the user perspective at the

00:10:30,079 --> 00:10:34,959
programmer perspective that says okay

00:10:32,399 --> 00:10:35,680
i'm done that push the packet out

00:10:34,959 --> 00:10:39,839
whatever

00:10:35,680 --> 00:10:41,839
out it is of course those pre-processor

00:10:39,839 --> 00:10:42,959
and post processor may introduce a

00:10:41,839 --> 00:10:45,760
little bit of

00:10:42,959 --> 00:10:46,320
override but we can see the overhead

00:10:45,760 --> 00:10:50,399
later

00:10:46,320 --> 00:10:53,279
in a slide third objective

00:10:50,399 --> 00:10:54,079
single point of control so from the user

00:10:53,279 --> 00:10:57,279
perspective

00:10:54,079 --> 00:11:00,160
i would like to control all my network

00:10:57,279 --> 00:11:01,519
and all my services from a single point

00:11:00,160 --> 00:11:03,800
so what we did

00:11:01,519 --> 00:11:05,600
is we created a demo called the

00:11:03,800 --> 00:11:09,360
polycubed

00:11:05,600 --> 00:11:12,720
that is handling the entire lifecycle

00:11:09,360 --> 00:11:16,320
of all your virtual network which means

00:11:12,720 --> 00:11:16,880
two different things first has to take

00:11:16,320 --> 00:11:20,399
care

00:11:16,880 --> 00:11:22,079
of topology related tasks so as to

00:11:20,399 --> 00:11:24,800
create a device

00:11:22,079 --> 00:11:25,760
create another network function connect

00:11:24,800 --> 00:11:28,880
them together

00:11:25,760 --> 00:11:30,560
and so on so creating the topology of

00:11:28,880 --> 00:11:33,600
your network service

00:11:30,560 --> 00:11:36,880
and then service related tasks because

00:11:33,600 --> 00:11:37,920
once you create a router maybe you have

00:11:36,880 --> 00:11:40,959
to configure

00:11:37,920 --> 00:11:41,440
ip addresses in the router or maybe you

00:11:40,959 --> 00:11:43,920
have to

00:11:41,440 --> 00:11:46,480
show the statistics of the filtering

00:11:43,920 --> 00:11:47,839
database on the bridge and so on so you

00:11:46,480 --> 00:11:51,519
have to configure

00:11:47,839 --> 00:11:54,720
and inspect everything from the same

00:11:51,519 --> 00:11:55,200
demon from the same point of control of

00:11:54,720 --> 00:11:58,720
your

00:11:55,200 --> 00:12:01,519
entire virtual network but

00:11:58,720 --> 00:12:02,079
what does it mean service which are the

00:12:01,519 --> 00:12:04,320
service

00:12:02,079 --> 00:12:06,000
right now we have the router we have the

00:12:04,320 --> 00:12:09,279
switch but what about

00:12:06,000 --> 00:12:11,839
if we want to create our own service

00:12:09,279 --> 00:12:14,560
we have to modify polycubed do we have

00:12:11,839 --> 00:12:18,320
to modify the command line interface

00:12:14,560 --> 00:12:21,760
in order to add a new survey

00:12:18,320 --> 00:12:25,440
into point view so we thought about this

00:12:21,760 --> 00:12:28,320
and we decided that we have to implement

00:12:25,440 --> 00:12:29,040
a model-driven service abstraction what

00:12:28,320 --> 00:12:32,399
does it mean

00:12:29,040 --> 00:12:33,920
it means that we can add a new service a

00:12:32,399 --> 00:12:36,880
new network function

00:12:33,920 --> 00:12:39,120
without changing that much about the

00:12:36,880 --> 00:12:41,760
framework the key

00:12:39,120 --> 00:12:42,560
technology here is that each network

00:12:41,760 --> 00:12:45,120
function

00:12:42,560 --> 00:12:47,040
has to be associated to a young data

00:12:45,120 --> 00:12:47,680
model young is a language that is

00:12:47,040 --> 00:12:50,399
becoming

00:12:47,680 --> 00:12:51,839
extremely common in networking in order

00:12:50,399 --> 00:12:54,720
to abstract

00:12:51,839 --> 00:12:57,440
the let's say configuration so the

00:12:54,720 --> 00:13:00,320
structure the syntax and the semantic

00:12:57,440 --> 00:13:02,399
of the configuration data so basically

00:13:00,320 --> 00:13:05,040
you can change and configure

00:13:02,399 --> 00:13:07,040
a network service by just setting a

00:13:05,040 --> 00:13:10,560
variable deleting

00:13:07,040 --> 00:13:13,279
a structure or adding a new record

00:13:10,560 --> 00:13:13,680
in a list or something like that so it's

00:13:13,279 --> 00:13:17,519
a

00:13:13,680 --> 00:13:20,480
sort of abstract form okay so we take

00:13:17,519 --> 00:13:22,240
this young data model and we brought a

00:13:20,480 --> 00:13:25,440
piece of

00:13:22,240 --> 00:13:26,959
tools some tools automatic that are able

00:13:25,440 --> 00:13:29,440
to generate automatic

00:13:26,959 --> 00:13:30,880
the code and those tools are

00:13:29,440 --> 00:13:34,160
automatically

00:13:30,880 --> 00:13:36,320
creating the command line interface so

00:13:34,160 --> 00:13:38,000
if you develop a new network service

00:13:36,320 --> 00:13:40,480
like your powerful

00:13:38,000 --> 00:13:41,760
much better router you don't have to

00:13:40,480 --> 00:13:44,639
write anything

00:13:41,760 --> 00:13:46,000
about the command line interface for

00:13:44,639 --> 00:13:48,399
your router because

00:13:46,000 --> 00:13:50,079
once you brought the young data model

00:13:48,399 --> 00:13:52,160
the command line interface is

00:13:50,079 --> 00:13:54,639
automatically generated for you

00:13:52,160 --> 00:13:55,600
and the same happens for the rest api

00:13:54,639 --> 00:13:57,920
because you know

00:13:55,600 --> 00:14:00,000
the command line interface is very nice

00:13:57,920 --> 00:14:02,160
for computers but it's not that sorry

00:14:00,000 --> 00:14:03,680
very nice for humans but it's not so

00:14:02,160 --> 00:14:06,480
nice for computers so

00:14:03,680 --> 00:14:06,800
of course we have a rest api where you

00:14:06,480 --> 00:14:09,040
can

00:14:06,800 --> 00:14:10,560
control all your network topology and so

00:14:09,040 --> 00:14:13,360
on by the way polycubed

00:14:10,560 --> 00:14:15,440
is a rest api also the sdpi is

00:14:13,360 --> 00:14:17,839
automatically created

00:14:15,440 --> 00:14:18,800
and finally the automatic code

00:14:17,839 --> 00:14:21,440
generation tool

00:14:18,800 --> 00:14:23,360
are creating some service specific

00:14:21,440 --> 00:14:24,160
source code so they are creating the

00:14:23,360 --> 00:14:27,360
files

00:14:24,160 --> 00:14:30,160
that you can include in your service

00:14:27,360 --> 00:14:30,480
and that perform already validation of

00:14:30,160 --> 00:14:33,279
your

00:14:30,480 --> 00:14:34,079
input and all that stuff that is

00:14:33,279 --> 00:14:37,279
required

00:14:34,079 --> 00:14:37,760
in order for your service to work but

00:14:37,279 --> 00:14:41,279
it's

00:14:37,760 --> 00:14:44,639
really annoying to be written manually

00:14:41,279 --> 00:14:47,680
by a user problem so young model

00:14:44,639 --> 00:14:50,800
is the key part here

00:14:47,680 --> 00:14:53,519
objective 5 this is something

00:14:50,800 --> 00:14:55,040
a little bit strange code reloading what

00:14:53,519 --> 00:14:56,560
does it mean for the reloading let's

00:14:55,040 --> 00:14:59,199
start with an example

00:14:56,560 --> 00:15:01,040
let's imagine we have a firewall okay so

00:14:59,199 --> 00:15:03,279
we have a firewall we created this

00:15:01,040 --> 00:15:06,079
firewall and the firewall control train

00:15:03,279 --> 00:15:06,800
instantiate the firewall okay very

00:15:06,079 --> 00:15:09,839
simple

00:15:06,800 --> 00:15:11,839
and then the user says okay you fire

00:15:09,839 --> 00:15:14,880
you have to drop traffic from these

00:15:11,839 --> 00:15:18,480
address you know this is a very simple

00:15:14,880 --> 00:15:21,680
action so it's enough to inspect the

00:15:18,480 --> 00:15:22,000
uh suicide b of the of the packet and

00:15:21,680 --> 00:15:24,880
then

00:15:22,000 --> 00:15:25,680
if it matches you can drop the back and

00:15:24,880 --> 00:15:28,880
that's it

00:15:25,680 --> 00:15:31,759
so the code that you can inject in this

00:15:28,880 --> 00:15:34,880
firewall that satisfy this action

00:15:31,759 --> 00:15:38,560
is pretty small now let's imagine that

00:15:34,880 --> 00:15:39,199
now the user says okay let's add a new

00:15:38,560 --> 00:15:42,720
rule

00:15:39,199 --> 00:15:43,440
you have to enable also establish

00:15:42,720 --> 00:15:47,360
sessions

00:15:43,440 --> 00:15:49,279
so uh allow people from inside to go to

00:15:47,360 --> 00:15:52,399
the internet and get the answer

00:15:49,279 --> 00:15:54,079
but not the reverse so

00:15:52,399 --> 00:15:55,600
connection coming from the external

00:15:54,079 --> 00:15:57,920
world this is

00:15:55,600 --> 00:16:00,079
definitely much more complex so the

00:15:57,920 --> 00:16:03,199
source code that you have to write

00:16:00,079 --> 00:16:04,560
in order to satisfy both action is much

00:16:03,199 --> 00:16:08,399
more complex

00:16:04,560 --> 00:16:11,199
so what we do in political is we provide

00:16:08,399 --> 00:16:12,959
support for code reloading which means

00:16:11,199 --> 00:16:17,360
that you can dynamically

00:16:12,959 --> 00:16:20,399
create the minimum code data path code

00:16:17,360 --> 00:16:24,160
that is required to process your data

00:16:20,399 --> 00:16:27,199
so once you have this rule you inject

00:16:24,160 --> 00:16:28,480
in the kernel only a few lines of code

00:16:27,199 --> 00:16:31,440
that are enough

00:16:28,480 --> 00:16:32,160
for taking care of this section when the

00:16:31,440 --> 00:16:34,720
user

00:16:32,160 --> 00:16:35,279
adds something more complex you update

00:16:34,720 --> 00:16:37,519
this

00:16:35,279 --> 00:16:39,600
code in the data plane in order to

00:16:37,519 --> 00:16:42,399
satisfy also the second action

00:16:39,600 --> 00:16:43,360
so that in the end you have always the

00:16:42,399 --> 00:16:46,399
minimum

00:16:43,360 --> 00:16:46,880
amount of code are required for you to

00:16:46,399 --> 00:16:49,920
work

00:16:46,880 --> 00:16:53,199
which means you are always going at the

00:16:49,920 --> 00:16:55,199
fastest speed how can you do this

00:16:53,199 --> 00:16:56,320
okay it's a little bit more complicated

00:16:55,199 --> 00:17:00,240
but okay

00:16:56,320 --> 00:17:02,320
so when we ask for a new feature

00:17:00,240 --> 00:17:04,799
the control plane of your network

00:17:02,320 --> 00:17:05,520
function has to generate the data plane

00:17:04,799 --> 00:17:08,160
code

00:17:05,520 --> 00:17:09,199
that is required to support that feature

00:17:08,160 --> 00:17:12,400
and then

00:17:09,199 --> 00:17:14,720
we inject that feature in parallel with

00:17:12,400 --> 00:17:17,360
all firewalls so we have two firewalls

00:17:14,720 --> 00:17:20,000
let's say in parallel but one is working

00:17:17,360 --> 00:17:20,720
and the other is still in standby and

00:17:20,000 --> 00:17:23,360
then

00:17:20,720 --> 00:17:24,240
we attach some shared data structure

00:17:23,360 --> 00:17:27,520
like maps

00:17:24,240 --> 00:17:30,240
to both firewalls because maybe it's

00:17:27,520 --> 00:17:31,440
nice to start a new firewall without

00:17:30,240 --> 00:17:33,919
losing the state

00:17:31,440 --> 00:17:34,559
of the previous and then once this is

00:17:33,919 --> 00:17:36,720
done

00:17:34,559 --> 00:17:38,720
you basically you move the pointer so

00:17:36,720 --> 00:17:39,760
instead of sending the packets to the

00:17:38,720 --> 00:17:43,120
old firewall

00:17:39,760 --> 00:17:44,559
you move it's just a very very atomic

00:17:43,120 --> 00:17:46,799
and very fast action

00:17:44,559 --> 00:17:47,840
you move the pointer to the new firewall

00:17:46,799 --> 00:17:49,919
so that the packets

00:17:47,840 --> 00:17:50,960
are starting to flow through the new

00:17:49,919 --> 00:17:53,200
firewall and the

00:17:50,960 --> 00:17:54,000
old firewall is still there but does

00:17:53,200 --> 00:17:57,360
nothing

00:17:54,000 --> 00:17:58,160
and then finally you can delete the old

00:17:57,360 --> 00:17:59,679
firewall

00:17:58,160 --> 00:18:01,520
and then you have the new firewall

00:17:59,679 --> 00:18:03,440
running and this is completely

00:18:01,520 --> 00:18:05,840
transparent from the user

00:18:03,440 --> 00:18:08,640
from what the user perceives is that

00:18:05,840 --> 00:18:12,000
this is very fast

00:18:08,640 --> 00:18:14,240
finally leveraging the unix

00:18:12,000 --> 00:18:15,360
ecosystem so we don't want to reinvent

00:18:14,240 --> 00:18:17,760
the wheel so

00:18:15,360 --> 00:18:19,440
for instance we have a routing protocols

00:18:17,760 --> 00:18:22,640
guaga is very nice

00:18:19,440 --> 00:18:22,960
we have a packet capture and analysis

00:18:22,640 --> 00:18:25,840
like

00:18:22,960 --> 00:18:26,080
washer this is very nice we don't want

00:18:25,840 --> 00:18:28,960
to

00:18:26,080 --> 00:18:29,520
reinvent the wheel so what we did is

00:18:28,960 --> 00:18:32,640
that

00:18:29,520 --> 00:18:35,520
we can set up a service in

00:18:32,640 --> 00:18:37,520
what we call the shadow mode when we

00:18:35,520 --> 00:18:39,440
enable the shadow mode

00:18:37,520 --> 00:18:41,200
so this is the service in the normal

00:18:39,440 --> 00:18:42,320
mode this is a service in the shadow

00:18:41,200 --> 00:18:45,360
mode

00:18:42,320 --> 00:18:47,919
each port is duplicated so

00:18:45,360 --> 00:18:49,440
we have this port to port in the router

00:18:47,919 --> 00:18:51,679
each part is duplicated

00:18:49,440 --> 00:18:52,799
in a separate name space where it's

00:18:51,679 --> 00:18:56,000
terminated

00:18:52,799 --> 00:18:58,799
so we create a dedicated namespace

00:18:56,000 --> 00:18:59,360
for this device in this case a router

00:18:58,799 --> 00:19:02,000
and

00:18:59,360 --> 00:19:02,720
here we have exactly the same ports that

00:19:02,000 --> 00:19:05,840
we have

00:19:02,720 --> 00:19:06,559
on the original device and some selected

00:19:05,840 --> 00:19:08,640
traffic

00:19:06,559 --> 00:19:10,480
not all the traffic we can decide which

00:19:08,640 --> 00:19:13,679
kind of traffic is

00:19:10,480 --> 00:19:16,080
taking and duplicated also on this port

00:19:13,679 --> 00:19:17,120
and of course which is the network

00:19:16,080 --> 00:19:19,360
namespace

00:19:17,120 --> 00:19:21,520
where we can do whatever you want of

00:19:19,360 --> 00:19:22,240
course we can support also the reverse

00:19:21,520 --> 00:19:24,160
traffic

00:19:22,240 --> 00:19:26,080
let's imagine you don't have wireshark

00:19:24,160 --> 00:19:28,400
but you have a quagga here

00:19:26,080 --> 00:19:30,480
you can generate routing messages

00:19:28,400 --> 00:19:33,280
routing messages are pushed here

00:19:30,480 --> 00:19:33,840
and then push on the physical wire so

00:19:33,280 --> 00:19:37,039
this

00:19:33,840 --> 00:19:38,320
will allow to reuse most of the tools we

00:19:37,039 --> 00:19:41,440
have already in

00:19:38,320 --> 00:19:42,240
english also in polycube without having

00:19:41,440 --> 00:19:45,360
to rewrite

00:19:42,240 --> 00:19:48,480
everything from scratch so

00:19:45,360 --> 00:19:48,480
we validated this

00:19:48,799 --> 00:19:55,200
library in kubernetes and it was

00:19:52,480 --> 00:19:57,200
really uh surprising to me not because

00:19:55,200 --> 00:19:59,360
we we made it because i mean

00:19:57,200 --> 00:20:00,640
we can do it but the fact that we made

00:19:59,360 --> 00:20:03,280
it in less than four months

00:20:00,640 --> 00:20:04,000
so basically we said let's take those

00:20:03,280 --> 00:20:07,679
boxes

00:20:04,000 --> 00:20:09,760
like lord balancer router nat we have a

00:20:07,679 --> 00:20:12,080
lot of network function already written

00:20:09,760 --> 00:20:13,200
and let's try to create the complete

00:20:12,080 --> 00:20:16,799
network support

00:20:13,200 --> 00:20:17,520
so the cni for kubernetes using ebbs

00:20:16,799 --> 00:20:20,880
blocks

00:20:17,520 --> 00:20:23,120
and we succeeded and the speed is good

00:20:20,880 --> 00:20:25,679
there is a slider later that

00:20:23,120 --> 00:20:26,799
the speed but most important we

00:20:25,679 --> 00:20:30,320
succeeded

00:20:26,799 --> 00:20:30,640
in a very short time frame and this is

00:20:30,320 --> 00:20:32,799
what's

00:20:30,640 --> 00:20:34,720
really surprising for for us and by the

00:20:32,799 --> 00:20:37,760
way it was really much

00:20:34,720 --> 00:20:38,640
clearer for us to follow the path of a

00:20:37,760 --> 00:20:41,840
packet

00:20:38,640 --> 00:20:43,200
between uh the different blocks if you

00:20:41,840 --> 00:20:46,840
take a a a

00:20:43,200 --> 00:20:49,440
standard cni for kubernetes like silver

00:20:46,840 --> 00:20:52,080
romana

00:20:49,440 --> 00:20:52,559
calico you can see that you hope it

00:20:52,080 --> 00:20:54,159
works

00:20:52,559 --> 00:20:56,159
because it's not really easy to

00:20:54,159 --> 00:20:58,799
understand the path of a packet

00:20:56,159 --> 00:21:00,640
inside with this let's say traditional

00:20:58,799 --> 00:21:03,840
mechanism with needle boxes

00:21:00,640 --> 00:21:04,480
not router load banks is much easier and

00:21:03,840 --> 00:21:07,919
it was

00:21:04,480 --> 00:21:10,880
also really fast to do

00:21:07,919 --> 00:21:11,919
okay so some numbers now some numbers we

00:21:10,880 --> 00:21:15,520
compared

00:21:11,919 --> 00:21:18,720
a bridge um running in

00:21:15,520 --> 00:21:21,679
polycube in two cases dc mode

00:21:18,720 --> 00:21:22,400
and xdp mode compared to traditional

00:21:21,679 --> 00:21:25,840
bridges

00:21:22,400 --> 00:21:26,400
like obs and linux bridge you can see

00:21:25,840 --> 00:21:30,080
that

00:21:26,400 --> 00:21:32,720
the performance of our pc and bridge

00:21:30,080 --> 00:21:34,240
running npc is definitely similar a

00:21:32,720 --> 00:21:37,600
little bit better honestly

00:21:34,240 --> 00:21:39,919
to the other the bridge running in pc is

00:21:37,600 --> 00:21:42,400
much higher so it's good

00:21:39,919 --> 00:21:43,200
we compared another app like a lot

00:21:42,400 --> 00:21:46,320
balancer

00:21:43,200 --> 00:21:47,039
so ipvs which is standard in linux kat

00:21:46,320 --> 00:21:50,000
run

00:21:47,039 --> 00:21:50,880
the ebbf file and load balancer from

00:21:50,000 --> 00:21:53,919
from facebook

00:21:50,880 --> 00:21:56,960
and our load balancer again running

00:21:53,919 --> 00:22:00,080
in dc and xdp and we can see

00:21:56,960 --> 00:22:03,600
that if you run into c we're

00:22:00,080 --> 00:22:06,080
better than uh ipds if we run

00:22:03,600 --> 00:22:06,720
in xdp we're better than that run

00:22:06,080 --> 00:22:10,000
somebody

00:22:06,720 --> 00:22:11,520
will say okay but maybe katran is richer

00:22:10,000 --> 00:22:14,720
internal functionalities

00:22:11,520 --> 00:22:15,600
i agree probably yes our is a proof of

00:22:14,720 --> 00:22:19,840
concept but

00:22:15,600 --> 00:22:22,080
it shows that we can go really fast

00:22:19,840 --> 00:22:23,919
we talk about kubernetes just some

00:22:22,080 --> 00:22:27,120
numbers we are here

00:22:23,919 --> 00:22:29,760
the other network plugins are here so

00:22:27,120 --> 00:22:30,400
not only it works but it's really fast

00:22:29,760 --> 00:22:33,440
okay

00:22:30,400 --> 00:22:36,320
um then there can be some

00:22:33,440 --> 00:22:38,400
differences um between the number of

00:22:36,320 --> 00:22:41,600
features that we support and so on but

00:22:38,400 --> 00:22:44,080
those preliminary numbers without going

00:22:41,600 --> 00:22:45,440
too much into details means that

00:22:44,080 --> 00:22:48,880
polycube

00:22:45,440 --> 00:22:49,760
is a really nice framework also in inner

00:22:48,880 --> 00:22:53,120
in order to

00:22:49,760 --> 00:22:57,440
achieve high performance framing

00:22:53,120 --> 00:23:00,799
framework overhead so we talked about

00:22:57,440 --> 00:23:03,360
those small programs before and after

00:23:00,799 --> 00:23:04,559
each network function and we were

00:23:03,360 --> 00:23:07,679
curious about

00:23:04,559 --> 00:23:08,640
the overhead that is introduced here

00:23:07,679 --> 00:23:11,600
honestly

00:23:08,640 --> 00:23:13,280
if you have only one network function

00:23:11,600 --> 00:23:16,000
the overhead is pretty small

00:23:13,280 --> 00:23:18,159
so we took the sdp redirect that takes a

00:23:16,000 --> 00:23:21,760
packet from one interface and sends

00:23:18,159 --> 00:23:23,840
out on another and we compared with the

00:23:21,760 --> 00:23:24,640
polycube equivalent which is symbol for

00:23:23,840 --> 00:23:26,880
water

00:23:24,640 --> 00:23:28,400
and you know the numbers are pretty much

00:23:26,880 --> 00:23:30,640
equivalent so the

00:23:28,400 --> 00:23:31,600
the performance loss is pretty

00:23:30,640 --> 00:23:34,240
negligible

00:23:31,600 --> 00:23:34,880
and the same happens if you are if you

00:23:34,240 --> 00:23:38,960
run

00:23:34,880 --> 00:23:42,480
in a pc mode so to be honest

00:23:38,960 --> 00:23:45,840
however the difference becomes huger

00:23:42,480 --> 00:23:49,279
if you run a lot of network functions

00:23:45,840 --> 00:23:50,960
in a chain so once you have one or two

00:23:49,279 --> 00:23:51,760
network functions basically there is no

00:23:50,960 --> 00:23:55,120
difference

00:23:51,760 --> 00:23:55,600
once you go larger in terms of service

00:23:55,120 --> 00:23:59,600
chain

00:23:55,600 --> 00:24:02,720
the difference becomes more substantial

00:23:59,600 --> 00:24:04,000
as you can see but we we don't see we

00:24:02,720 --> 00:24:06,080
don't expect

00:24:04,000 --> 00:24:07,600
service chain to be much longer probably

00:24:06,080 --> 00:24:10,720
two three

00:24:07,600 --> 00:24:12,640
it's it's it's really enough by the way

00:24:10,720 --> 00:24:14,480
you can see also that each network

00:24:12,640 --> 00:24:18,240
function so each cube

00:24:14,480 --> 00:24:21,120
can be split internally in a lot of uh

00:24:18,240 --> 00:24:21,760
evpf programs which are called micro

00:24:21,120 --> 00:24:24,720
cubes

00:24:21,760 --> 00:24:25,679
the firewall that we have is really made

00:24:24,720 --> 00:24:28,320
this way

00:24:25,679 --> 00:24:28,960
and in this case there is no overhead

00:24:28,320 --> 00:24:32,559
because

00:24:28,960 --> 00:24:35,039
the pre and post processor are just

00:24:32,559 --> 00:24:36,799
before and after a network function not

00:24:35,039 --> 00:24:40,159
inside the network function

00:24:36,799 --> 00:24:42,880
so it's good project status

00:24:40,159 --> 00:24:43,520
so we implement more than 10 network

00:24:42,880 --> 00:24:45,679
functions

00:24:43,520 --> 00:24:47,200
of course proof of concept but they are

00:24:45,679 --> 00:24:50,400
there you can try

00:24:47,200 --> 00:24:53,440
and run it the source code

00:24:50,400 --> 00:24:55,840
is available on github

00:24:53,440 --> 00:24:56,720
most active contributors come from our

00:24:55,840 --> 00:25:00,720
university

00:24:56,720 --> 00:25:02,960
from torino in italy and uh obviously

00:25:00,720 --> 00:25:04,320
other contributions are welcome by the

00:25:02,960 --> 00:25:07,360
way the

00:25:04,320 --> 00:25:09,760
source code is released under apache ii

00:25:07,360 --> 00:25:11,360
so it's pretty okay in terms of

00:25:09,760 --> 00:25:14,320
licensing

00:25:11,360 --> 00:25:14,880
so concluding remarks polycube is the

00:25:14,320 --> 00:25:17,840
first

00:25:14,880 --> 00:25:19,039
internal framework for creating network

00:25:17,840 --> 00:25:22,159
functions

00:25:19,039 --> 00:25:25,440
uh with epf it

00:25:22,159 --> 00:25:28,320
enables the facilitates the creation of

00:25:25,440 --> 00:25:28,880
complex network services and also

00:25:28,320 --> 00:25:32,159
network

00:25:28,880 --> 00:25:36,159
voltages so not just a single box

00:25:32,159 --> 00:25:38,960
but a set of boxes connected together

00:25:36,159 --> 00:25:40,559
it extends the ebf programming model

00:25:38,960 --> 00:25:43,440
with

00:25:40,559 --> 00:25:44,240
abstraction which are very handy for

00:25:43,440 --> 00:25:47,679
network

00:25:44,240 --> 00:25:50,080
network functions um it supports

00:25:47,679 --> 00:25:51,039
dynamic optimization of those network

00:25:50,080 --> 00:25:53,840
functions that we call

00:25:51,039 --> 00:25:54,799
tubes uh that can be dynamically

00:25:53,840 --> 00:25:57,760
injected the

00:25:54,799 --> 00:25:59,039
injected and updated in order to be more

00:25:57,760 --> 00:26:01,840
optimized

00:25:59,039 --> 00:26:03,120
and it also leverages the power of the

00:26:01,840 --> 00:26:05,760
linux ecosystem

00:26:03,120 --> 00:26:06,480
in order to avoid to re-implement

00:26:05,760 --> 00:26:09,600
everything

00:26:06,480 --> 00:26:10,240
from from scratch performance are really

00:26:09,600 --> 00:26:13,520
good

00:26:10,240 --> 00:26:16,159
um honestly not the the same level of

00:26:13,520 --> 00:26:17,600
dpdk and so on but this is completely

00:26:16,159 --> 00:26:19,679
another story because

00:26:17,600 --> 00:26:21,600
uh you have to make a choice between

00:26:19,679 --> 00:26:24,480
ebbf and ddk but

00:26:21,600 --> 00:26:25,520
if you want to stay in the linux kernel

00:26:24,480 --> 00:26:28,080
the performance

00:26:25,520 --> 00:26:30,000
of ebdf are good a performance of oil

00:26:28,080 --> 00:26:32,640
cube giving all the extraction

00:26:30,000 --> 00:26:33,600
abstraction that we did are still very

00:26:32,640 --> 00:26:37,200
very very good

00:26:33,600 --> 00:26:40,559
so just slightly less than

00:26:37,200 --> 00:26:43,679
vanilla ibf and

00:26:40,559 --> 00:26:47,279
we validated also in case of complex

00:26:43,679 --> 00:26:49,840
cases like a complex plug-in

00:26:47,279 --> 00:26:51,039
for kubernetes and everything was

00:26:49,840 --> 00:26:53,600
defeated

00:26:51,039 --> 00:26:54,960
okay and is available you can try

00:26:53,600 --> 00:26:58,400
yourself

00:26:54,960 --> 00:27:02,559
this has finished my presentation

00:26:58,400 --> 00:27:02,559
uh if you have any question read it once

00:27:04,840 --> 00:27:10,320
okay questions not seeing any in the

00:27:08,080 --> 00:27:10,320
queue

00:27:10,960 --> 00:27:16,480
unless i missed one um

00:27:14,640 --> 00:27:17,919
why while people are dreaming up

00:27:16,480 --> 00:27:22,000
questions let me ask

00:27:17,919 --> 00:27:23,919
one for you so um the katran comparison

00:27:22,000 --> 00:27:27,120
confused me a little bit so because

00:27:23,919 --> 00:27:28,880
katran is also vp evp of program and

00:27:27,120 --> 00:27:30,799
so is yours and you have your prologue

00:27:28,880 --> 00:27:31,760
epilogue overhead like you said which

00:27:30,799 --> 00:27:35,039
will

00:27:31,760 --> 00:27:36,159
add to the to the cycles needed so is is

00:27:35,039 --> 00:27:38,159
really the benefit

00:27:36,159 --> 00:27:40,240
from the chaining and the sort of the

00:27:38,159 --> 00:27:40,960
continuation of the different functions

00:27:40,240 --> 00:27:42,480
is that

00:27:40,960 --> 00:27:44,799
why you're able to edge out katran

00:27:42,480 --> 00:27:44,799
itself

00:27:46,960 --> 00:27:51,600
no catherine was simply chosen because

00:27:49,919 --> 00:27:54,240
we wanted to compare

00:27:51,600 --> 00:27:56,240
what we did with uh some state of the

00:27:54,240 --> 00:27:57,679
art and definitely we have a proof of

00:27:56,240 --> 00:28:02,000
concept load balancer

00:27:57,679 --> 00:28:03,440
and katran is one of the top load

00:28:02,000 --> 00:28:06,559
balancer around

00:28:03,440 --> 00:28:10,159
so we wanted to compare there and see

00:28:06,559 --> 00:28:12,799
if the performance we can reach

00:28:10,159 --> 00:28:14,000
in our framework which has the advantage

00:28:12,799 --> 00:28:16,880
of creating

00:28:14,000 --> 00:28:18,799
service chain because if you want to

00:28:16,880 --> 00:28:21,840
create just a simple network

00:28:18,799 --> 00:28:24,399
service um there is no need for

00:28:21,840 --> 00:28:25,600
for quality but just if you want to

00:28:24,399 --> 00:28:29,360
create

00:28:25,600 --> 00:28:31,120
a chain and then we want to compare

00:28:29,360 --> 00:28:32,880
with the state of the art so katarang

00:28:31,120 --> 00:28:35,760
was an obvious choice

00:28:32,880 --> 00:28:37,120
like the other obvious church that was a

00:28:35,760 --> 00:28:39,039
breach

00:28:37,120 --> 00:28:41,279
right so i okay i got it so you were

00:28:39,039 --> 00:28:43,600
just you were saying that you can

00:28:41,279 --> 00:28:45,520
you were proving that you could hit that

00:28:43,600 --> 00:28:48,159
kind of packets per second processing

00:28:45,520 --> 00:28:49,039
including the the overhead that you have

00:28:48,159 --> 00:28:51,760
to

00:28:49,039 --> 00:28:52,720
service okay got it uh there's a

00:28:51,760 --> 00:28:56,640
question on the

00:28:52,720 --> 00:28:58,000
on the chat from power what made complex

00:28:56,640 --> 00:29:03,120
service chaining drop

00:28:58,000 --> 00:29:06,559
performance a lot simply because

00:29:03,120 --> 00:29:07,600
before and after each network function

00:29:06,559 --> 00:29:09,760
like a bridge

00:29:07,600 --> 00:29:10,799
we have to create some additional

00:29:09,760 --> 00:29:14,000
programs

00:29:10,799 --> 00:29:15,039
which facilitate the the creation of the

00:29:14,000 --> 00:29:17,520
chain

00:29:15,039 --> 00:29:19,600
because you have a bridge and then you

00:29:17,520 --> 00:29:22,720
have something else the bridge doesn't

00:29:19,600 --> 00:29:25,840
really know what is after

00:29:22,720 --> 00:29:27,039
him so it can be a network interface it

00:29:25,840 --> 00:29:30,080
can be another service

00:29:27,039 --> 00:29:33,200
so we have to create those two modules

00:29:30,080 --> 00:29:35,520
two tiny evpf programs which

00:29:33,200 --> 00:29:36,799
helps in ready writing the traffic the

00:29:35,520 --> 00:29:40,159
proper way

00:29:36,799 --> 00:29:42,480
so those two help two

00:29:40,159 --> 00:29:44,000
small programs create a little bit of

00:29:42,480 --> 00:29:46,399
overhead if the chain

00:29:44,000 --> 00:29:48,960
is short the overhead is pretty much

00:29:46,399 --> 00:29:52,320
negligible but if the chain is becoming

00:29:48,960 --> 00:29:56,080
longer because you have maybe six

00:29:52,320 --> 00:29:58,399
seven eight uh servicing chain cascade

00:29:56,080 --> 00:29:59,200
then the overhead becomes more

00:29:58,399 --> 00:30:02,240
noticeable

00:29:59,200 --> 00:30:04,799
so i mean we want to be fair so

00:30:02,240 --> 00:30:07,039
this is the reason for this performance

00:30:04,799 --> 00:30:07,039
though

00:30:07,360 --> 00:30:12,559
one more question was uh how are

00:30:10,320 --> 00:30:13,120
stateful functions like nat implemented

00:30:12,559 --> 00:30:17,679
because of

00:30:13,120 --> 00:30:17,679
your service chain epilogue product

00:30:19,360 --> 00:30:23,919
so i didn't get the point how how are

00:30:22,240 --> 00:30:25,600
stateful functions i guess the question

00:30:23,919 --> 00:30:29,120
is

00:30:25,600 --> 00:30:31,520
okay yes that's a function are a little

00:30:29,120 --> 00:30:32,559
bit more complex because you have to uh

00:30:31,520 --> 00:30:35,760
handle the state

00:30:32,559 --> 00:30:38,320
in the ebpf so um

00:30:35,760 --> 00:30:39,360
i mean the usual stuff we have to create

00:30:38,320 --> 00:30:41,520
some tables

00:30:39,360 --> 00:30:43,360
and then do connection tracking

00:30:41,520 --> 00:30:45,760
everything in the pdf like other

00:30:43,360 --> 00:30:45,760
projects

00:30:45,919 --> 00:30:51,919
there is nothing basically different

00:30:49,360 --> 00:30:53,679
from other projects in this respect what

00:30:51,919 --> 00:30:55,039
is really different is that you can

00:30:53,679 --> 00:31:05,840
change multiple

00:30:55,039 --> 00:31:05,840
functions together

00:31:06,640 --> 00:31:13,679
um hello

00:31:09,919 --> 00:31:17,360
yep yes i raised my hand

00:31:13,679 --> 00:31:18,799
magnet one go for it i am magnifying

00:31:17,360 --> 00:31:21,760
okay

00:31:18,799 --> 00:31:21,760
uh that's me actually

00:31:22,960 --> 00:31:31,760
uh hey fully it's it's jamal sorry

00:31:27,120 --> 00:31:34,159
it shows up the wrong id there um

00:31:31,760 --> 00:31:35,679
so if i understand it correctly your

00:31:34,159 --> 00:31:39,440
concept of service chaining is

00:31:35,679 --> 00:31:44,159
uh using map programs

00:31:39,440 --> 00:31:47,840
program maps i'm sorry for defining

00:31:44,159 --> 00:31:47,840
uh the the

00:31:48,080 --> 00:31:52,399
the the the components of a service

00:31:50,559 --> 00:31:55,519
right this is a chain or it's a

00:31:52,399 --> 00:31:59,120
bunch of programs which uh then

00:31:55,519 --> 00:32:00,559
um the composition of that

00:31:59,120 --> 00:32:02,480
uh chain of programs becomes your

00:32:00,559 --> 00:32:05,919
service correct yes

00:32:02,480 --> 00:32:08,080
this is uh using go at uh program maps

00:32:05,919 --> 00:32:10,080
yeah

00:32:08,080 --> 00:32:12,799
yes are you finding that there's a lot

00:32:10,080 --> 00:32:16,799
of the control interface to bpf is not

00:32:12,799 --> 00:32:16,799
to maps in particular is not the most

00:32:16,880 --> 00:32:20,720
it's almost like it's an afterthought to

00:32:18,559 --> 00:32:24,080
be honest the

00:32:20,720 --> 00:32:24,080
idea of um

00:32:24,240 --> 00:32:27,760
for example everything is packet driven

00:32:26,159 --> 00:32:31,600
right so if you're trying to do map

00:32:27,760 --> 00:32:34,880
aging or um

00:32:31,600 --> 00:32:38,159
ability to graciously age

00:32:34,880 --> 00:32:39,679
entries in a table it's not uh

00:32:38,159 --> 00:32:41,360
the trivial because the only thing you

00:32:39,679 --> 00:32:42,080
have to basically depend on either a

00:32:41,360 --> 00:32:44,960
user space

00:32:42,080 --> 00:32:45,200
application that constantly pulls when

00:32:44,960 --> 00:32:46,640
is

00:32:45,200 --> 00:32:48,399
as the tables grow bigger you have a

00:32:46,640 --> 00:32:50,240
problem or

00:32:48,399 --> 00:32:51,919
a new packet arriving and then you

00:32:50,240 --> 00:32:55,519
somehow include your logic

00:32:51,919 --> 00:32:58,159
to check for these schemes

00:32:55,519 --> 00:33:00,159
um did you have to deal with any of

00:32:58,159 --> 00:33:03,360
these issues

00:33:00,159 --> 00:33:04,320
no because i mean this is some somehow

00:33:03,360 --> 00:33:07,519
words we're gonna

00:33:04,320 --> 00:33:09,919
do the work that we did so um

00:33:07,519 --> 00:33:10,720
yeah has some limitation exactly what

00:33:09,919 --> 00:33:14,000
you did

00:33:10,720 --> 00:33:17,919
uh what you mentioned in the maps

00:33:14,000 --> 00:33:21,760
but the problem we wanted to solve is

00:33:17,919 --> 00:33:24,880
how to create a cascade

00:33:21,760 --> 00:33:28,080
a variable number of uh

00:33:24,880 --> 00:33:28,720
etf programs that are cascaded one to

00:33:28,080 --> 00:33:32,320
the other i

00:33:28,720 --> 00:33:34,399
i think um the most interesting

00:33:32,320 --> 00:33:35,679
concept comes from one of the first

00:33:34,399 --> 00:33:39,120
slider in which i

00:33:35,679 --> 00:33:42,000
created complex network topology with

00:33:39,120 --> 00:33:46,320
the bridge or router or not and so on so

00:33:42,000 --> 00:33:48,559
um this is the novelty of the framework

00:33:46,320 --> 00:33:51,440
uh the compositional network function

00:33:48,559 --> 00:33:53,840
not the single network function itself

00:33:51,440 --> 00:33:55,840
and the second novelty is that when you

00:33:53,840 --> 00:33:56,320
try to create a network function you are

00:33:55,840 --> 00:33:58,880
not

00:33:56,320 --> 00:33:59,519
just have to build about data plane you

00:33:58,880 --> 00:34:03,120
have to think

00:33:59,519 --> 00:34:06,080
about data control uh management plan

00:34:03,120 --> 00:34:06,399
and we greatly simplify the creation of

00:34:06,080 --> 00:34:08,540
the

00:34:06,399 --> 00:34:09,839
control plane because

00:34:08,540 --> 00:34:12,800
[Music]

00:34:09,839 --> 00:34:14,079
there is no sub such a concept in there

00:34:12,800 --> 00:34:17,440
there's just

00:34:14,079 --> 00:34:18,800
um data plane

00:34:17,440 --> 00:34:20,720
that's right that's right there's

00:34:18,800 --> 00:34:22,800
there's a lot of constructs that are

00:34:20,720 --> 00:34:26,159
important for the control to data path

00:34:22,800 --> 00:34:29,679
manipulation that are missing

00:34:26,159 --> 00:34:33,040
to be to put it simply yes

00:34:29,679 --> 00:34:34,879
right so we leverage uh abstraction that

00:34:33,040 --> 00:34:37,839
are already in

00:34:34,879 --> 00:34:38,720
pcc in order to get access to maps and

00:34:37,839 --> 00:34:41,280
so on

00:34:38,720 --> 00:34:43,679
and we create a new abstraction in order

00:34:41,280 --> 00:34:44,000
to create a service chain and to connect

00:34:43,679 --> 00:34:46,159
the

00:34:44,000 --> 00:34:49,760
multiple pieces together like a fast

00:34:46,159 --> 00:34:51,599
slow and control plane

00:34:49,760 --> 00:34:53,440
the rest api is automatically

00:34:51,599 --> 00:34:55,440
synthesized so you

00:34:53,440 --> 00:34:57,119
you don't have as a programmer you don't

00:34:55,440 --> 00:34:59,920
have to do anything you just

00:34:57,119 --> 00:35:01,200
write your data model young and

00:34:59,920 --> 00:35:04,880
everything is

00:35:01,200 --> 00:35:06,480
created automatically and so on so

00:35:04,880 --> 00:35:09,520
but that doesn't include creating the

00:35:06,480 --> 00:35:09,520
data path component

00:35:09,920 --> 00:35:12,960
you still have to write it by hand yes

00:35:12,400 --> 00:35:15,040
but

00:35:12,960 --> 00:35:16,880
if you want to create a network service

00:35:15,040 --> 00:35:19,040
probably you're interested in that

00:35:16,880 --> 00:35:19,920
in the data place so it is exactly what

00:35:19,040 --> 00:35:22,720
you want to

00:35:19,920 --> 00:35:23,599
do what you don't want to do is bother

00:35:22,720 --> 00:35:26,720
about

00:35:23,599 --> 00:35:27,920
rest api what about the recipient so we

00:35:26,720 --> 00:35:31,599
simplify the task

00:35:27,920 --> 00:35:35,200
and the connection between one uh

00:35:31,599 --> 00:35:36,560
one function to the other okay

00:35:35,200 --> 00:35:40,240
thanks i can talk to you offline or

00:35:36,560 --> 00:35:40,240

YouTube URL: https://www.youtube.com/watch?v=fiFzljVyUF8


