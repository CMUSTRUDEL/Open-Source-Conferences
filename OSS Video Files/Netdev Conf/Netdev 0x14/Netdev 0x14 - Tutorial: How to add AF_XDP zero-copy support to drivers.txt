Title: Netdev 0x14 - Tutorial: How to add AF_XDP zero-copy support to drivers
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Instructor: Maxim Mikityanskiy

More info: https://netdevconf.info/0x14/session.html?tutorial-adding-AF_XDP-zero-copy-support-to-drivers

Date: Friday, August 14, 2020

AF_XDP is a relatively new technology optimized for high
performance packet processing. It provides an
abstraction over hardware rings, so the application can
handle packets in a low-level, yet hardware-agnostic
fashion. With conforming drivers, AF_XDP also provides
zero-copy packet handling capabilities to the application.

At its basic level AF_XDP works works fine with a lot of
conforming drivers. Adding zero-copy support is more challenging.
Maxim Mikityanskiy has been through trial-by-fire writting zero
copy AF_XDP support and came out unscathed.

In this tutorial, Maxim instructs on how a driver author would go about
adding AF_XDP zero copy support using the mlx5e driver as an
example.
Captions: 
	00:00:03,439 --> 00:00:09,519
hello everyone

00:00:06,160 --> 00:00:13,280
i'm maxim from melanox which was

00:00:09,519 --> 00:00:16,960
acquired by nvidia and today

00:00:13,280 --> 00:00:20,560
we'll have such an educational topic

00:00:16,960 --> 00:00:23,920
how to add af xdp xerocopy support

00:00:20,560 --> 00:00:27,680
to a new driver

00:00:23,920 --> 00:00:31,119
so this is the agenda for today

00:00:27,680 --> 00:00:34,399
first we'll do a quick recap of

00:00:31,119 --> 00:00:38,000
fxdp and the things that will be useful

00:00:34,399 --> 00:00:38,719
in this tutorial and then goes the main

00:00:38,000 --> 00:00:41,440
part

00:00:38,719 --> 00:00:42,160
well i'll show you how to add the fxdp

00:00:41,440 --> 00:00:45,440
support

00:00:42,160 --> 00:00:46,320
into the driver i'll be using code

00:00:45,440 --> 00:00:50,160
structure

00:00:46,320 --> 00:00:52,719
and snippets from the mlx 5 driver

00:00:50,160 --> 00:00:55,760
but i'm not going to dig into any

00:00:52,719 --> 00:00:58,239
hardware specific details

00:00:55,760 --> 00:00:59,520
i will finish with some extra stuff that

00:00:58,239 --> 00:01:02,559
is optional

00:00:59,520 --> 00:01:05,439
but very good to have in the driver and

00:01:02,559 --> 00:01:07,040
describe possible challenges and things

00:01:05,439 --> 00:01:10,640
that i had to deal with

00:01:07,040 --> 00:01:13,280
when implementing a fxdp and mlx5

00:01:10,640 --> 00:01:14,320
which was the second driver after intel

00:01:13,280 --> 00:01:18,720
to support

00:01:14,320 --> 00:01:20,880
af xdp as this is a tutorial

00:01:18,720 --> 00:01:24,080
feel free to interrupt me and ask

00:01:20,880 --> 00:01:24,080
questions on topic

00:01:24,960 --> 00:01:32,560
so before we start i want to highlight

00:01:29,360 --> 00:01:36,079
the prerequisites for this tutorial

00:01:32,560 --> 00:01:40,000
um the driver has to support xdp

00:01:36,079 --> 00:01:41,759
in the first place and just in case your

00:01:40,000 --> 00:01:43,600
driver doesn't support it

00:01:41,759 --> 00:01:45,040
there is another there is another

00:01:43,600 --> 00:01:48,079
tutorial about

00:01:45,040 --> 00:01:51,600
how to add xdp support

00:01:48,079 --> 00:01:52,000
you can check it out and also you should

00:01:51,600 --> 00:01:55,360
have

00:01:52,000 --> 00:01:56,320
basic knowledge about fxdp the roles of

00:01:55,360 --> 00:01:59,680
umam

00:01:56,320 --> 00:02:02,000
rings descriptors etc

00:01:59,680 --> 00:02:04,240
but don't worry the driver doesn't have

00:02:02,000 --> 00:02:06,640
to deal with all that stuff

00:02:04,240 --> 00:02:07,439
because the kernel provides a convenient

00:02:06,640 --> 00:02:13,039
interface

00:02:07,439 --> 00:02:13,039
and hides most of the internals of afxdb

00:02:13,920 --> 00:02:20,400
so let's do a quick recap

00:02:17,280 --> 00:02:20,400
of fxdp

00:02:21,200 --> 00:02:28,879
first uh here is the um

00:02:25,280 --> 00:02:29,920
it's that central structure of an fxdp

00:02:28,879 --> 00:02:32,720
socket

00:02:29,920 --> 00:02:33,840
it's a region of memory allocated by the

00:02:32,720 --> 00:02:36,080
application

00:02:33,840 --> 00:02:36,879
and it's shared between the app the

00:02:36,080 --> 00:02:40,160
driver

00:02:36,879 --> 00:02:41,440
and the nic it's split into frames each

00:02:40,160 --> 00:02:44,959
of which can store

00:02:41,440 --> 00:02:47,040
a single packet either received or to be

00:02:44,959 --> 00:02:51,440
transmitted

00:02:47,040 --> 00:02:54,319
and we have four rings which is for cues

00:02:51,440 --> 00:02:55,440
that store handles that point to the

00:02:54,319 --> 00:02:58,319
frames

00:02:55,440 --> 00:02:59,840
to get the idea of how the rings work

00:02:58,319 --> 00:03:03,599
let's look at the pair

00:02:59,840 --> 00:03:04,640
of the feel and rx ring the application

00:03:03,599 --> 00:03:07,280
puts

00:03:04,640 --> 00:03:09,200
uh the descriptors of of empty frames

00:03:07,280 --> 00:03:11,519
into the fill ring

00:03:09,200 --> 00:03:15,120
this is a signal to the driver that it

00:03:11,519 --> 00:03:17,680
can put received data into those frames

00:03:15,120 --> 00:03:20,480
then the driver will move the descriptor

00:03:17,680 --> 00:03:22,879
into the rx ring

00:03:20,480 --> 00:03:25,120
to make the application know that a

00:03:22,879 --> 00:03:27,440
packet was received

00:03:25,120 --> 00:03:28,879
a symmetric process happens on the tx

00:03:27,440 --> 00:03:32,239
side

00:03:28,879 --> 00:03:33,120
so this is a simplified picture because

00:03:32,239 --> 00:03:34,959
the um

00:03:33,120 --> 00:03:37,760
can also be shared between multiple

00:03:34,959 --> 00:03:41,280
sockets so there can be more than one

00:03:37,760 --> 00:03:46,239
hierarchs and tx ring but the kernel api

00:03:41,280 --> 00:03:48,400
completely hides it from the driver so

00:03:46,239 --> 00:03:49,280
the driver doesn't have to worry about

00:03:48,400 --> 00:03:53,120
it

00:03:49,280 --> 00:03:56,239
um what's important to understand

00:03:53,120 --> 00:04:00,000
is that a umam is attached to

00:03:56,239 --> 00:04:00,400
a device q so the requests to open the

00:04:00,000 --> 00:04:03,040
cro

00:04:00,400 --> 00:04:03,920
or close the socket will contain a queue

00:04:03,040 --> 00:04:07,519
number

00:04:03,920 --> 00:04:10,239
it's not just that we open

00:04:07,519 --> 00:04:11,120
an afx dp socket just like a regular

00:04:10,239 --> 00:04:14,239
socket

00:04:11,120 --> 00:04:18,000
but we need to specify the net device

00:04:14,239 --> 00:04:18,000
and the queue number

00:04:19,199 --> 00:04:24,479
a reasonable question is why

00:04:22,320 --> 00:04:26,960
do we need to do anything in the driver

00:04:24,479 --> 00:04:30,479
to support af xdp

00:04:26,960 --> 00:04:30,960
the answer is that it's um it's the only

00:04:30,479 --> 00:04:34,400
way

00:04:30,960 --> 00:04:38,160
we can achieve zero copy

00:04:34,400 --> 00:04:38,160
sorry any question

00:04:39,040 --> 00:04:45,919
no okay so um

00:04:43,199 --> 00:04:47,120
we need that because it's the only way

00:04:45,919 --> 00:04:50,080
that we can achieve

00:04:47,120 --> 00:04:51,040
zero copy all the way from the nic to

00:04:50,080 --> 00:04:54,400
the application

00:04:51,040 --> 00:04:57,680
and the back fxdp is very flexible

00:04:54,400 --> 00:04:58,639
and it can work in absence of driver

00:04:57,680 --> 00:05:00,639
support

00:04:58,639 --> 00:05:01,759
and even if the driver doesn't support

00:05:00,639 --> 00:05:04,479
xdp

00:05:01,759 --> 00:05:05,039
but those fallbacks are slow to get zero

00:05:04,479 --> 00:05:07,680
copy

00:05:05,039 --> 00:05:10,000
the application in the driver must have

00:05:07,680 --> 00:05:13,280
some shared knowledge about placement of

00:05:10,000 --> 00:05:16,479
packets and memory and fxdp

00:05:13,280 --> 00:05:18,720
is a framework that provides it

00:05:16,479 --> 00:05:20,320
as i already mentioned a good thing for

00:05:18,720 --> 00:05:23,360
the driver developer

00:05:20,320 --> 00:05:25,360
is that the kernel api is minimal and

00:05:23,360 --> 00:05:26,240
most of the stuff is hidden under the

00:05:25,360 --> 00:05:28,639
hood

00:05:26,240 --> 00:05:30,479
so the driver doesn't have to worry

00:05:28,639 --> 00:05:33,440
about it

00:05:30,479 --> 00:05:34,720
it gets even better over time for

00:05:33,440 --> 00:05:38,560
example

00:05:34,720 --> 00:05:41,680
recently there was a refactoring series

00:05:38,560 --> 00:05:45,440
by bjorn from intel that simplified

00:05:41,680 --> 00:05:48,720
the driver interface even further

00:05:45,440 --> 00:05:51,600
so that's it for the recap let's move to

00:05:48,720 --> 00:05:53,840
the driver implementation any questions

00:05:51,600 --> 00:05:53,840
so far

00:05:57,600 --> 00:06:04,800
okay so this slide

00:06:02,000 --> 00:06:05,280
shows a short plan of what has to be

00:06:04,800 --> 00:06:07,280
done

00:06:05,280 --> 00:06:08,400
in the driver from from the driver's

00:06:07,280 --> 00:06:11,520
side

00:06:08,400 --> 00:06:14,160
step 0 is of course to support xdp

00:06:11,520 --> 00:06:16,479
which you should have at this point and

00:06:14,160 --> 00:06:18,880
it won't be covered in this tutorial

00:06:16,479 --> 00:06:20,400
but as i mentioned there is another

00:06:18,880 --> 00:06:23,520
tutorial uh

00:06:20,400 --> 00:06:26,960
specifically for xdp

00:06:23,520 --> 00:06:30,880
uh second thing is to

00:06:26,960 --> 00:06:34,160
implement ngos used by the kernel

00:06:30,880 --> 00:06:36,720
to interact with the driver

00:06:34,160 --> 00:06:40,240
these are used in the setup stage when a

00:06:36,720 --> 00:06:42,639
socket or crate is created or destroyed

00:06:40,240 --> 00:06:44,400
and also for wake ups which will be

00:06:42,639 --> 00:06:47,440
covered later

00:06:44,400 --> 00:06:50,479
then when an xsk which

00:06:47,440 --> 00:06:52,880
means xdp socket

00:06:50,479 --> 00:06:55,440
when an xsk is attached to a queue

00:06:52,880 --> 00:06:56,479
number the driver has to create a pair

00:06:55,440 --> 00:07:00,479
of cues for

00:06:56,479 --> 00:07:02,800
xsk data transfers the methods to

00:07:00,479 --> 00:07:04,240
allocate those cues will be covered

00:07:02,800 --> 00:07:06,639
later

00:07:04,240 --> 00:07:07,919
and when the setup stage is complete

00:07:06,639 --> 00:07:10,960
it's time to implement

00:07:07,919 --> 00:07:13,360
the data path for the rx side

00:07:10,960 --> 00:07:14,880
the driver will have to allocate buffers

00:07:13,360 --> 00:07:17,440
from the um

00:07:14,880 --> 00:07:18,720
instead of its normal page allocation

00:07:17,440 --> 00:07:22,400
scheme

00:07:18,720 --> 00:07:25,199
the teak side has to be handled in nappy

00:07:22,400 --> 00:07:25,919
and it includes not only completions but

00:07:25,199 --> 00:07:28,720
also

00:07:25,919 --> 00:07:29,759
the actual transmissions they will also

00:07:28,720 --> 00:07:32,960
happen

00:07:29,759 --> 00:07:32,960
in nappy contexts

00:07:33,759 --> 00:07:38,160
now i'd like to answer this question

00:07:36,319 --> 00:07:40,240
beforehand

00:07:38,160 --> 00:07:42,000
while it may be tempting to save some

00:07:40,240 --> 00:07:45,360
hardware and driver resources

00:07:42,000 --> 00:07:46,560
and reuse your existing cues as is for

00:07:45,360 --> 00:07:50,080
xsk

00:07:46,560 --> 00:07:53,360
you shouldn't do so the xsk

00:07:50,080 --> 00:07:54,400
rxq requires a different xdp memory

00:07:53,360 --> 00:07:57,039
model because the

00:07:54,400 --> 00:07:59,360
buffers are allocated from the um

00:07:57,039 --> 00:08:02,560
instead of being dynamically allocated

00:07:59,360 --> 00:08:04,639
for example from a page pool

00:08:02,560 --> 00:08:07,759
this condition basically forces you to

00:08:04,639 --> 00:08:10,840
use a separate queue type

00:08:07,759 --> 00:08:12,319
and while you may try to reuse the

00:08:10,840 --> 00:08:15,800
xdptxq

00:08:12,319 --> 00:08:17,120
for x6k having a separate queue for

00:08:15,800 --> 00:08:20,720
xsktx

00:08:17,120 --> 00:08:24,319
is also a good idea consider a situation

00:08:20,720 --> 00:08:27,440
where an fxdp socket is closed

00:08:24,319 --> 00:08:29,440
and instantly reopened on the same

00:08:27,440 --> 00:08:31,919
channel

00:08:29,440 --> 00:08:33,440
if a hard work view is shared with for

00:08:31,919 --> 00:08:36,159
example xdptx

00:08:33,440 --> 00:08:38,399
and it's not destroyed and recreated

00:08:36,159 --> 00:08:40,640
your new socket may receive completions

00:08:38,399 --> 00:08:44,080
for packets from the old socket and

00:08:40,640 --> 00:08:45,920
it will mess things up the driver will

00:08:44,080 --> 00:08:48,399
either have to flush the cube

00:08:45,920 --> 00:08:50,240
carefully which may be problematic if

00:08:48,399 --> 00:08:51,120
other traffic is also using the same

00:08:50,240 --> 00:08:55,200
queue

00:08:51,120 --> 00:08:55,200
or just have a separate queue and

00:09:02,480 --> 00:09:11,760
yeah the host muted me for some reason

00:09:09,120 --> 00:09:12,480
so yeah it's just easier to use a

00:09:11,760 --> 00:09:15,600
separate

00:09:12,480 --> 00:09:18,800
queue and close it with the socket

00:09:15,600 --> 00:09:23,839
so that we don't need to do that

00:09:18,800 --> 00:09:23,839
complex flashing procedure

00:09:28,480 --> 00:09:33,600
okay here is all the api that we are

00:09:31,920 --> 00:09:36,160
going to use

00:09:33,600 --> 00:09:37,040
but don't worry we'll be using it step

00:09:36,160 --> 00:09:39,839
by step

00:09:37,040 --> 00:09:40,720
you can later use this slide as a

00:09:39,839 --> 00:09:44,000
reference but

00:09:40,720 --> 00:09:47,360
no need to remember all those functions

00:09:44,000 --> 00:09:50,480
right now let's begin

00:09:47,360 --> 00:09:54,720
with implementing ngo stubs

00:09:50,480 --> 00:09:59,120
there are two ngos in use ngo bpf

00:09:54,720 --> 00:10:01,920
and ngo xsk wake up the first one

00:09:59,120 --> 00:10:04,000
will be used at setup stage and here we

00:10:01,920 --> 00:10:07,200
just handle the setup command

00:10:04,000 --> 00:10:10,240
and the actual implementation oops sorry

00:10:07,200 --> 00:10:12,320
it's too early the actual

00:10:10,240 --> 00:10:14,720
implementation of the setup command will

00:10:12,320 --> 00:10:18,240
be shown later

00:10:14,720 --> 00:10:21,360
here i use vng as

00:10:18,240 --> 00:10:22,560
a vendor neutral prefix for the driver

00:10:21,360 --> 00:10:26,160
functions

00:10:22,560 --> 00:10:27,440
and i replace any hardware specific

00:10:26,160 --> 00:10:30,959
details with

00:10:27,440 --> 00:10:34,320
pseudocode or commands

00:10:30,959 --> 00:10:37,519
but you can also use the source code

00:10:34,320 --> 00:10:40,000
of mlx5 as a reference and you'll find

00:10:37,519 --> 00:10:46,800
the complete code of those functions

00:10:40,000 --> 00:10:50,240
prefixed with mlx5e instead of vnd

00:10:46,800 --> 00:10:53,600
so the second indio handles

00:10:50,240 --> 00:10:54,399
xsk wake ups this is needed mainly for

00:10:53,600 --> 00:10:57,360
transmit

00:10:54,399 --> 00:10:59,040
that happens from nappy so the main

00:10:57,360 --> 00:11:02,000
point of this function

00:10:59,040 --> 00:11:04,800
is to schedule nappy when the

00:11:02,000 --> 00:11:07,600
application has something to transmit

00:11:04,800 --> 00:11:07,920
it can also be used to signal the driver

00:11:07,600 --> 00:11:10,800
that

00:11:07,920 --> 00:11:12,399
the fill ring has new frames in which

00:11:10,800 --> 00:11:16,959
incoming packets can be

00:11:12,399 --> 00:11:20,160
received i will talk about it later

00:11:16,959 --> 00:11:21,279
this function should schedule nappy on

00:11:20,160 --> 00:11:24,959
the right cpu

00:11:21,279 --> 00:11:27,839
according to the affinity and normally

00:11:24,959 --> 00:11:28,959
you need to use a hardware specific way

00:11:27,839 --> 00:11:32,000
to make

00:11:28,959 --> 00:11:37,360
the nic pull an irq

00:11:32,000 --> 00:11:37,360
which will in turn trigger our nappy

00:11:37,600 --> 00:11:42,880
we call this function nappy scheduled

00:11:41,040 --> 00:11:46,240
mark missed

00:11:42,880 --> 00:11:47,200
before as a shortcut if nappy is already

00:11:46,240 --> 00:11:51,760
running

00:11:47,200 --> 00:11:55,680
so in that case we we don't need to

00:11:51,760 --> 00:11:59,200
to touch the hardware and make it turn

00:11:55,680 --> 00:11:59,200
make it pull the irq

00:11:59,600 --> 00:12:03,440
before triggering nappy the driver

00:12:02,320 --> 00:12:06,480
should make sure

00:12:03,440 --> 00:12:09,279
that the xdp program is set and

00:12:06,480 --> 00:12:10,800
xsk is actually enabled in the given

00:12:09,279 --> 00:12:13,200
queue

00:12:10,800 --> 00:12:14,959
and this is basically it this is all

00:12:13,200 --> 00:12:16,800
that is required from the wake up

00:12:14,959 --> 00:12:19,760
callback this is the simplest

00:12:16,800 --> 00:12:20,480
function that is needed so you can start

00:12:19,760 --> 00:12:25,600
with it

00:12:20,480 --> 00:12:29,279
when you implement fxdp in your driver

00:12:25,600 --> 00:12:32,800
let's move on to the setup callback

00:12:29,279 --> 00:12:34,399
implementation it's a good idea to split

00:12:32,800 --> 00:12:37,519
it into two functions

00:12:34,399 --> 00:12:40,240
enable and disable xsk

00:12:37,519 --> 00:12:40,880
the kernel guarantees you that it won't

00:12:40,240 --> 00:12:44,240
try

00:12:40,880 --> 00:12:46,480
to enable xsk multiple times

00:12:44,240 --> 00:12:47,519
but you have to keep track of the status

00:12:46,480 --> 00:12:50,720
in the driver

00:12:47,519 --> 00:12:54,160
anyway this is something that actually

00:12:50,720 --> 00:12:57,200
can be improved in the api but

00:12:54,160 --> 00:13:01,920
like the current status is has is

00:12:57,200 --> 00:13:05,200
you you still need to track it yourself

00:13:01,920 --> 00:13:07,040
fxdp sockets survive reset of cues

00:13:05,200 --> 00:13:08,240
for example if the interface is brought

00:13:07,040 --> 00:13:10,959
down and up

00:13:08,240 --> 00:13:11,680
or some configuration is changed leading

00:13:10,959 --> 00:13:14,639
to

00:13:11,680 --> 00:13:15,040
creating a new set of cues that means

00:13:14,639 --> 00:13:17,600
that

00:13:15,040 --> 00:13:19,920
you need to keep track which queues are

00:13:17,600 --> 00:13:23,040
access key enabled

00:13:19,920 --> 00:13:23,920
because when you when you reopen your

00:13:23,040 --> 00:13:27,360
cues

00:13:23,920 --> 00:13:30,480
you have to know if if that queue is xsk

00:13:27,360 --> 00:13:31,279
or not there is a function that returns

00:13:30,480 --> 00:13:34,560
a pointer

00:13:31,279 --> 00:13:36,639
to the umem by qadd but it doesn't

00:13:34,560 --> 00:13:37,519
distinguish between zero copy and copy

00:13:36,639 --> 00:13:40,800
sockets

00:13:37,519 --> 00:13:44,000
so you can't just use it

00:13:40,800 --> 00:13:46,720
you need to store either a flag or

00:13:44,000 --> 00:13:48,240
a pointer to the um per queue in some

00:13:46,720 --> 00:13:51,680
location that survives

00:13:48,240 --> 00:13:55,040
resetting the queues this way

00:13:51,680 --> 00:13:58,000
when the driver recreates the queues

00:13:55,040 --> 00:13:59,120
it can determine which of them are xsk

00:13:58,000 --> 00:14:03,600
enabled

00:13:59,120 --> 00:14:05,360
so that's why it's important

00:14:03,600 --> 00:14:07,760
i see there are some messages in the

00:14:05,360 --> 00:14:07,760
chat

00:14:07,839 --> 00:14:12,079
let me quickly review it

00:14:12,959 --> 00:14:17,839
okay some sound issues

00:14:24,320 --> 00:14:29,120
okay so the question is if you have a

00:14:27,279 --> 00:14:32,959
multicast listener

00:14:29,120 --> 00:14:36,320
would you need to set up xskt x

00:14:32,959 --> 00:14:38,720
i'm fine with the subscription by normal

00:14:36,320 --> 00:14:38,720
socket

00:14:40,959 --> 00:14:48,079
not sure if i exactly get your question

00:14:44,480 --> 00:14:53,040
uh you mean that you want to

00:14:48,079 --> 00:14:53,040
only receive data

00:14:53,279 --> 00:14:59,920
i'm not sure how multicast relates

00:14:56,800 --> 00:15:04,320
to it yes you can do

00:14:59,920 --> 00:15:07,600
multicast rx with xsk

00:15:04,320 --> 00:15:08,959
so is the question about uh whether you

00:15:07,600 --> 00:15:11,440
need to

00:15:08,959 --> 00:15:12,160
uh set up also gtx side when you don't

00:15:11,440 --> 00:15:16,160
need it

00:15:12,160 --> 00:15:16,160
can you unmute and explain

00:15:22,959 --> 00:15:30,560
yes okay so um basically

00:15:27,519 --> 00:15:35,440
uh i know it's possible

00:15:30,560 --> 00:15:38,320
to like um i'm not ready to give you

00:15:35,440 --> 00:15:40,079
the exact answer i know it's intended to

00:15:38,320 --> 00:15:44,000
be possible

00:15:40,079 --> 00:15:44,800
to create one-sided sockets uh like only

00:15:44,000 --> 00:15:48,240
dx or

00:15:44,800 --> 00:15:50,560
only rx um but i'm not sure

00:15:48,240 --> 00:15:51,839
if it's fun if it's fully functional at

00:15:50,560 --> 00:15:54,480
this point

00:15:51,839 --> 00:15:56,240
to be honest i only experimented with

00:15:54,480 --> 00:15:59,360
like two-sided sockets

00:15:56,240 --> 00:16:01,279
but you can actually try

00:15:59,360 --> 00:16:02,880
uh there is some infrastructure in the

00:16:01,279 --> 00:16:05,759
kernel that

00:16:02,880 --> 00:16:07,040
should support creating over socket

00:16:05,759 --> 00:16:11,839
without

00:16:07,040 --> 00:16:11,839
like a txq or without an rxq

00:16:12,320 --> 00:16:22,480
so as this technology is pretty new

00:16:17,759 --> 00:16:26,160
i expect there might be some bugs but

00:16:22,480 --> 00:16:29,759
like actually you have to try it out and

00:16:26,160 --> 00:16:35,040
maybe it just works for you okay

00:16:29,759 --> 00:16:35,040
uh thanks for the question let's move on

00:16:35,199 --> 00:16:41,040
um so yeah we're going on to the setup

00:16:39,680 --> 00:16:43,680
stage first

00:16:41,040 --> 00:16:46,320
and this is the pseudo code of the

00:16:43,680 --> 00:16:49,440
access key enable function

00:16:46,320 --> 00:16:50,639
um you should validate the um parameters

00:16:49,440 --> 00:16:54,079
if your hardware

00:16:50,639 --> 00:16:56,480
has any related limitations

00:16:54,079 --> 00:17:00,000
then you should map the pages and don't

00:16:56,480 --> 00:17:02,320
forget to check the error code

00:17:00,000 --> 00:17:03,040
because like some functions like this

00:17:02,320 --> 00:17:06,240
one

00:17:03,040 --> 00:17:09,520
it can return an error and of course i'm

00:17:06,240 --> 00:17:13,760
skipping it for the sake of simplicity

00:17:09,520 --> 00:17:14,640
but you should always check your return

00:17:13,760 --> 00:17:17,679
code

00:17:14,640 --> 00:17:20,880
and do proper

00:17:17,679 --> 00:17:23,760
rollbacks um

00:17:20,880 --> 00:17:25,039
okay so then you mark then that the

00:17:23,760 --> 00:17:28,079
given q

00:17:25,039 --> 00:17:31,039
is hex k enabled and

00:17:28,079 --> 00:17:32,080
the following actions depend on whether

00:17:31,039 --> 00:17:35,600
the net death is

00:17:32,080 --> 00:17:37,760
up at the moment if not you have to

00:17:35,600 --> 00:17:38,640
validate the human parameters for

00:17:37,760 --> 00:17:40,880
example

00:17:38,640 --> 00:17:43,919
make sure that the frame size is

00:17:40,880 --> 00:17:47,039
compatible with the current mtu

00:17:43,919 --> 00:17:50,080
when the interface comes up you won't

00:17:47,039 --> 00:17:53,360
have a chance to fail

00:17:50,080 --> 00:17:56,240
so that's why you have to check it now

00:17:53,360 --> 00:17:56,880
but if the interface is currently up you

00:17:56,240 --> 00:18:00,080
also

00:17:56,880 --> 00:18:02,799
have to create the xsku's and

00:18:00,080 --> 00:18:02,799
you are done

00:18:03,360 --> 00:18:07,440
xsk disable is basically a reverse for

00:18:06,480 --> 00:18:09,679
enable

00:18:07,440 --> 00:18:11,200
the driver has to tear down access key

00:18:09,679 --> 00:18:14,640
queues if the interface is

00:18:11,200 --> 00:18:17,280
up clear the flag and unmap

00:18:14,640 --> 00:18:17,280
the pages

00:18:18,240 --> 00:18:21,760
let's take a look at the flow when the

00:18:20,960 --> 00:18:25,360
interface

00:18:21,760 --> 00:18:28,400
was down when a socket was created

00:18:25,360 --> 00:18:29,200
when the interface goes up the driver

00:18:28,400 --> 00:18:32,400
has to create

00:18:29,200 --> 00:18:34,880
access kqs for xsk enable channels

00:18:32,400 --> 00:18:37,200
we also get into this flow when the

00:18:34,880 --> 00:18:40,480
interface goes down and up

00:18:37,200 --> 00:18:43,120
with some active af xdp sockets or when

00:18:40,480 --> 00:18:47,039
some configuration changes

00:18:43,120 --> 00:18:49,280
the implementations details really

00:18:47,039 --> 00:18:50,480
depend on how you manage the queues in

00:18:49,280 --> 00:18:53,280
your driver

00:18:50,480 --> 00:18:56,160
but the main idea is that you shouldn't

00:18:53,280 --> 00:18:57,200
forget to open xsk resources in in this

00:18:56,160 --> 00:19:00,320
flow too

00:18:57,200 --> 00:19:03,760
and you can use the xdp

00:19:00,320 --> 00:19:07,200
get um from qad function to query

00:19:03,760 --> 00:19:07,200
the pointer to the um

00:19:08,480 --> 00:19:12,000
let's dig into more details regarding

00:19:10,960 --> 00:19:16,400
creating xsk

00:19:12,000 --> 00:19:18,240
queues while xskt xqs don't require

00:19:16,400 --> 00:19:20,640
anything special you should just

00:19:18,240 --> 00:19:24,880
configure them in a similar fashion

00:19:20,640 --> 00:19:28,080
to how you configure the excuse

00:19:24,880 --> 00:19:30,640
arcside is a bit more trickier

00:19:28,080 --> 00:19:31,200
this snippet shows how to register the

00:19:30,640 --> 00:19:35,360
correct

00:19:31,200 --> 00:19:39,360
memory model for the xskrxq

00:19:35,360 --> 00:19:42,559
you connect the xdp rxq info

00:19:39,360 --> 00:19:44,640
to the um with this function

00:19:42,559 --> 00:19:47,120
and of course you should handle possible

00:19:44,640 --> 00:19:47,120
errors

00:19:48,320 --> 00:19:55,440
now let's go over the key points in

00:19:51,600 --> 00:19:59,360
the access k data path use

00:19:55,440 --> 00:20:02,240
xsk buff analog to allocate buffers

00:19:59,360 --> 00:20:03,600
it will return a prefield xdp buff

00:20:02,240 --> 00:20:06,960
structure

00:20:03,600 --> 00:20:07,679
you should run xsk buff xdp get frame

00:20:06,960 --> 00:20:11,360
dma

00:20:07,679 --> 00:20:15,039
to get the dma address so that you'll be

00:20:11,360 --> 00:20:16,640
able to post a hardware descriptor

00:20:15,039 --> 00:20:18,799
if you need to allocate a batch of

00:20:16,640 --> 00:20:22,159
buffers there is also a

00:20:18,799 --> 00:20:25,280
function that you can use it's xsk buff

00:20:22,159 --> 00:20:28,080
can alloc it's mentioned in this summary

00:20:25,280 --> 00:20:30,000
slide in the beginning

00:20:28,080 --> 00:20:31,360
and you can use this function to check

00:20:30,000 --> 00:20:33,200
in advance

00:20:31,360 --> 00:20:34,880
if a given number of frames are

00:20:33,200 --> 00:20:37,679
available

00:20:34,880 --> 00:20:39,360
the next stage is when the hardware

00:20:37,679 --> 00:20:42,799
receives the packet

00:20:39,360 --> 00:20:47,840
nappy gets triggered you should run xsk

00:20:42,799 --> 00:20:49,919
above the amazing for cpu 4d amazing

00:20:47,840 --> 00:20:51,520
then you should run your xdp handling

00:20:49,919 --> 00:20:54,880
function as usual

00:20:51,520 --> 00:20:58,080
but with one minor difference which is

00:20:54,880 --> 00:21:01,039
anyway important you shouldn't unmap

00:20:58,080 --> 00:21:01,600
your mem frames you never want to unmap

00:21:01,039 --> 00:21:05,200
xsk

00:21:01,600 --> 00:21:07,360
frames while the socket is active

00:21:05,200 --> 00:21:09,120
the next slide will have some

00:21:07,360 --> 00:21:13,360
instructions how to proceed

00:21:09,120 --> 00:21:13,360
after the xdp program returned the code

00:21:13,520 --> 00:21:17,200
so the first case is the main use case

00:21:16,159 --> 00:21:19,520
for xsk

00:21:17,200 --> 00:21:22,400
it's when we redirect the incoming

00:21:19,520 --> 00:21:25,039
packet to the xsk application

00:21:22,400 --> 00:21:25,760
no action is required from the driver

00:21:25,039 --> 00:21:29,280
side

00:21:25,760 --> 00:21:30,640
xsk buff 3 should not be called in that

00:21:29,280 --> 00:21:32,720
case

00:21:30,640 --> 00:21:34,240
the rule of thumb for the rest of the

00:21:32,720 --> 00:21:37,360
cases is that

00:21:34,240 --> 00:21:41,520
you need to call xscape off free

00:21:37,360 --> 00:21:44,799
unless it's called for us so

00:21:41,520 --> 00:21:45,600
on other successful xdp redirects xscape

00:21:44,799 --> 00:21:48,799
of free

00:21:45,600 --> 00:21:50,159
will be called for us still no action is

00:21:48,799 --> 00:21:53,120
needed

00:21:50,159 --> 00:21:55,120
however on errors you should call it

00:21:53,120 --> 00:21:58,159
manually

00:21:55,120 --> 00:22:01,760
xdp drop and xdp aborted require

00:21:58,159 --> 00:22:04,880
a manual call to x escape of free

00:22:01,760 --> 00:22:08,240
in xdptx it's done for

00:22:04,880 --> 00:22:11,600
us by xdp convert buff to frame

00:22:08,240 --> 00:22:12,480
which you call but if it fails itself

00:22:11,600 --> 00:22:17,039
the driver

00:22:12,480 --> 00:22:20,159
must call x escape off free by itself

00:22:17,039 --> 00:22:23,039
xdp pass also requires a manual call

00:22:20,159 --> 00:22:24,320
but first you need to actually allocate

00:22:23,039 --> 00:22:26,880
a new skb

00:22:24,320 --> 00:22:27,760
and copy data to it because we want to

00:22:26,880 --> 00:22:31,200
reuse

00:22:27,760 --> 00:22:34,880
the human page as soon as possible for

00:22:31,200 --> 00:22:36,960
the actual xskrx we don't want to use

00:22:34,880 --> 00:22:40,320
the human memory to build the

00:22:36,960 --> 00:22:42,760
eskbs on top of it for many reasons

00:22:40,320 --> 00:22:44,080
especially because this memory is

00:22:42,760 --> 00:22:46,960
user-writable

00:22:44,080 --> 00:22:48,559
and the kernel data path is not

00:22:46,960 --> 00:22:54,159
protected from external

00:22:48,559 --> 00:22:57,679
random data manipulations

00:22:54,159 --> 00:23:00,480
and this is sample code for xdp pass

00:22:57,679 --> 00:23:01,600
and it's actually that simple you just

00:23:00,480 --> 00:23:06,080
allocate

00:23:01,600 --> 00:23:09,280
an uskb and copy data to it

00:23:06,080 --> 00:23:13,200
that's it and remember to call xsk

00:23:09,280 --> 00:23:15,360
buff free afterwards so this is actually

00:23:13,200 --> 00:23:17,280
the real code like the complete code

00:23:15,360 --> 00:23:19,360
that we have in the mlx 5 it's really

00:23:17,280 --> 00:23:22,159
that simple

00:23:19,360 --> 00:23:22,720
i just skipped the increase in counter

00:23:22,159 --> 00:23:26,000
detail

00:23:22,720 --> 00:23:28,480
which is also a one-liner but driver

00:23:26,000 --> 00:23:28,480
specific

00:23:29,840 --> 00:23:40,799
now let's switch to the gx side

00:23:37,679 --> 00:23:42,720
access ktx happens from nappy

00:23:40,799 --> 00:23:44,799
which is triggered by the wake up

00:23:42,720 --> 00:23:47,520
function which in turn

00:23:44,799 --> 00:23:48,720
is triggered by a syscall from the user

00:23:47,520 --> 00:23:51,440
space

00:23:48,720 --> 00:23:52,480
the application puts one or more frame

00:23:51,440 --> 00:23:56,159
descriptors

00:23:52,480 --> 00:23:59,039
into the tx ring and calls the driver

00:23:56,159 --> 00:24:01,120
that has to transmit them it doesn't

00:23:59,039 --> 00:24:03,760
have to transmit all of them

00:24:01,120 --> 00:24:04,480
it can stop in the middle running from

00:24:03,760 --> 00:24:06,880
nappy

00:24:04,480 --> 00:24:09,200
ensures the right cpu affinity and

00:24:06,880 --> 00:24:13,200
guarantees no concurrency issues

00:24:09,200 --> 00:24:13,200
when accessing the dxq

00:24:13,760 --> 00:24:19,760
so this is the code for tx datapath

00:24:17,360 --> 00:24:20,720
in a loop while all packets are

00:24:19,760 --> 00:24:23,840
available

00:24:20,720 --> 00:24:26,960
while any packets are available

00:24:23,840 --> 00:24:30,559
and while we have budget we

00:24:26,960 --> 00:24:31,760
pick the descriptors with xsk um consume

00:24:30,559 --> 00:24:35,440
gx

00:24:31,760 --> 00:24:37,360
we get the dma address and length

00:24:35,440 --> 00:24:39,840
the length is just a field in the

00:24:37,360 --> 00:24:40,480
structure for the dma address you have

00:24:39,840 --> 00:24:44,480
to call

00:24:40,480 --> 00:24:47,039
a function we sync for the device

00:24:44,480 --> 00:24:47,919
and invoke a hardware specific routine

00:24:47,039 --> 00:24:50,880
to transmit

00:24:47,919 --> 00:24:53,760
the packet so here you should put your

00:24:50,880 --> 00:24:57,600
hardware specific code

00:24:53,760 --> 00:25:01,679
and there is also xscape buff

00:24:57,600 --> 00:25:02,080
row get data which is similar to get dma

00:25:01,679 --> 00:25:05,120
but

00:25:02,080 --> 00:25:07,039
get data just in case your driver needs

00:25:05,120 --> 00:25:09,799
to access the packet data

00:25:07,039 --> 00:25:11,039
for example mlx5 hardware in certain

00:25:09,799 --> 00:25:14,159
configurations

00:25:11,039 --> 00:25:16,320
requires the driver to inline the

00:25:14,159 --> 00:25:19,679
initial part of a packet into

00:25:16,320 --> 00:25:22,559
a descriptor though the api

00:25:19,679 --> 00:25:23,520
has changed since then when i first

00:25:22,559 --> 00:25:27,200
start and

00:25:23,520 --> 00:25:29,600
started implementing af xdp and mlx5

00:25:27,200 --> 00:25:32,960
this functionality was missing because

00:25:29,600 --> 00:25:35,600
most of the drivers don't really need it

00:25:32,960 --> 00:25:37,679
and in the end of the loop if any

00:25:35,600 --> 00:25:40,320
packets were transmitted

00:25:37,679 --> 00:25:42,000
ring the doorbell put your hardware

00:25:40,320 --> 00:25:45,760
specific code here

00:25:42,000 --> 00:25:49,039
and call xsk um consume tx

00:25:45,760 --> 00:25:56,159
done to sync the cached consumer index

00:25:49,039 --> 00:25:59,600
and the tx ring with the application

00:25:56,159 --> 00:26:03,600
okay so this is the second part

00:25:59,600 --> 00:26:06,320
of the tx flow it's handling completions

00:26:03,600 --> 00:26:06,960
first you pull the completions just as

00:26:06,320 --> 00:26:10,159
usual

00:26:06,960 --> 00:26:14,400
no difference from the regular data path

00:26:10,159 --> 00:26:17,760
but you count them and in the end

00:26:14,400 --> 00:26:19,120
all you need to do is to call xsk um

00:26:17,760 --> 00:26:22,240
complete tweaks

00:26:19,120 --> 00:26:23,039
and pass this count it will tell the

00:26:22,240 --> 00:26:27,919
application

00:26:23,039 --> 00:26:31,200
that the packets transmitted before

00:26:27,919 --> 00:26:31,200
that they were completed

00:26:33,520 --> 00:26:38,080
so at this point we are done with the

00:26:36,559 --> 00:26:40,640
main part uh

00:26:38,080 --> 00:26:44,400
we will proceed with talking about some

00:26:40,640 --> 00:26:44,400
additional stuff in challenges

00:26:44,720 --> 00:26:49,360
let's start with the unaligned chunks

00:26:47,679 --> 00:26:52,559
extension

00:26:49,360 --> 00:26:55,679
so normally the human frames come

00:26:52,559 --> 00:26:56,880
one after another and they are aligned

00:26:55,679 --> 00:27:00,240
to their size

00:26:56,880 --> 00:27:01,679
which is a power of two the unaligned

00:27:00,240 --> 00:27:05,360
chunks extension

00:27:01,679 --> 00:27:09,200
allows to lift this this limitation

00:27:05,360 --> 00:27:11,120
but by setting a special flag in the app

00:27:09,200 --> 00:27:13,039
if your driver can deal with such

00:27:11,120 --> 00:27:16,559
buffers this extension

00:27:13,039 --> 00:27:19,360
is automatically supported however

00:27:16,559 --> 00:27:20,960
if you know that your hardware can't

00:27:19,360 --> 00:27:23,440
deal with it

00:27:20,960 --> 00:27:24,000
you should check the flag and return an

00:27:23,440 --> 00:27:27,279
error

00:27:24,000 --> 00:27:30,480
on xsk attached as far as i know

00:27:27,279 --> 00:27:35,279
all xsk enabled entry drivers

00:27:30,480 --> 00:27:38,640
supports this feature

00:27:35,279 --> 00:27:39,120
another really great thing is need wake

00:27:38,640 --> 00:27:41,360
up

00:27:39,120 --> 00:27:42,480
it's a feature that improves performance

00:27:41,360 --> 00:27:45,039
by avoiding

00:27:42,480 --> 00:27:45,520
unnecessary busy waiting which may

00:27:45,039 --> 00:27:48,799
happen

00:27:45,520 --> 00:27:51,360
both on ticks and directs

00:27:48,799 --> 00:27:53,039
so consider the situation when the

00:27:51,360 --> 00:27:54,159
application stops refilling the

00:27:53,039 --> 00:27:56,960
fillering

00:27:54,159 --> 00:27:58,240
and the driver cannot allocate buffers

00:27:56,960 --> 00:28:01,600
with xsk buff

00:27:58,240 --> 00:28:02,159
analog in this case the driver has to

00:28:01,600 --> 00:28:04,640
pull

00:28:02,159 --> 00:28:06,880
the fuel ring until the application

00:28:04,640 --> 00:28:10,000
finally puts something there

00:28:06,880 --> 00:28:13,520
consuming 100 percent cpu

00:28:10,000 --> 00:28:16,240
need wake up provides a solution to this

00:28:13,520 --> 00:28:18,640
on tx side the driver can transmit only

00:28:16,240 --> 00:28:19,360
part of the packets from the tx ring as

00:28:18,640 --> 00:28:22,720
i mentioned

00:28:19,360 --> 00:28:25,840
before like when when when we have a

00:28:22,720 --> 00:28:29,039
wake up we are free to stop

00:28:25,840 --> 00:28:30,880
in the middle of transmitting packets

00:28:29,039 --> 00:28:32,799
the application doesn't have a good

00:28:30,880 --> 00:28:33,840
indication of how many packets were

00:28:32,799 --> 00:28:36,399
queued up

00:28:33,840 --> 00:28:37,200
so it keeps pinging the driver with the

00:28:36,399 --> 00:28:40,080
six calls

00:28:37,200 --> 00:28:41,919
until it receives all the completions

00:28:40,080 --> 00:28:43,360
which may never happen in case of

00:28:41,919 --> 00:28:46,480
continuous traffic

00:28:43,360 --> 00:28:49,600
so we'll have a flood of syscalls

00:28:46,480 --> 00:28:51,919
all the time all these unnecessary

00:28:49,600 --> 00:28:54,240
context switches consume a significant

00:28:51,919 --> 00:28:57,279
part of cpu resources

00:28:54,240 --> 00:28:59,840
and luckily it can be solved by

00:28:57,279 --> 00:28:59,840
need wake up

00:29:02,720 --> 00:29:07,360
and also luckily it's very easy to add

00:29:05,520 --> 00:29:11,360
need wake up functionality to

00:29:07,360 --> 00:29:14,159
your xsk enabled driver after you

00:29:11,360 --> 00:29:16,559
follow the previous steps and had basic

00:29:14,159 --> 00:29:19,840
support

00:29:16,559 --> 00:29:21,840
so for the rx side you just need to call

00:29:19,840 --> 00:29:22,960
this function that is shown in this

00:29:21,840 --> 00:29:26,159
slide

00:29:22,960 --> 00:29:28,480
after posting hardware descriptors

00:29:26,159 --> 00:29:29,760
if the fill ring didn't have enough

00:29:28,480 --> 00:29:33,520
frames

00:29:29,760 --> 00:29:36,000
alloc error will be true first of all

00:29:33,520 --> 00:29:38,080
the function checks if the application

00:29:36,000 --> 00:29:40,720
supports need backup

00:29:38,080 --> 00:29:42,480
if not we don't have any other option

00:29:40,720 --> 00:29:45,039
but reschedule nappy and

00:29:42,480 --> 00:29:46,720
fall until there is something in the

00:29:45,039 --> 00:29:49,600
fill ring

00:29:46,720 --> 00:29:50,480
but if the application does support lead

00:29:49,600 --> 00:29:53,520
wake up

00:29:50,480 --> 00:29:56,640
we need set of we

00:29:53,520 --> 00:29:58,159
will set a flag for the application with

00:29:56,640 --> 00:30:00,960
this function

00:29:58,159 --> 00:30:04,080
and we will stop polling we return false

00:30:00,960 --> 00:30:07,120
which means we will not reschedule nappy

00:30:04,080 --> 00:30:09,279
when the application reveals oops

00:30:07,120 --> 00:30:10,320
when the application reveals the field

00:30:09,279 --> 00:30:13,600
ring

00:30:10,320 --> 00:30:15,679
it will see the flag and

00:30:13,600 --> 00:30:17,279
the flag in the application will mean

00:30:15,679 --> 00:30:20,399
that it has to

00:30:17,279 --> 00:30:23,279
trigger a wake up issue assist call

00:30:20,399 --> 00:30:24,000
so we will wake up get into the nappy

00:30:23,279 --> 00:30:28,640
and

00:30:24,000 --> 00:30:28,640
um retry again allocating frames

00:30:28,799 --> 00:30:36,080
on the tig side the flow is very similar

00:30:32,640 --> 00:30:39,120
if the driver knows that the txq is not

00:30:36,080 --> 00:30:40,880
empty it means that hardware completions

00:30:39,120 --> 00:30:43,440
will trigger nappy anyway

00:30:40,880 --> 00:30:44,240
at some point which will also transmit

00:30:43,440 --> 00:30:46,960
more xsk

00:30:44,240 --> 00:30:49,360
packets so there is no need for the

00:30:46,960 --> 00:30:52,640
application to call the sys call

00:30:49,360 --> 00:30:55,039
under heavy traffic this feature reduces

00:30:52,640 --> 00:30:57,519
the amount of wake up cisco's from

00:30:55,039 --> 00:31:00,080
hundreds of thousands per second to only

00:30:57,519 --> 00:31:01,519
a few per second which makes a huge

00:31:00,080 --> 00:31:04,399
difference

00:31:01,519 --> 00:31:05,600
however there is one thing i should

00:31:04,399 --> 00:31:08,240
highlight

00:31:05,600 --> 00:31:10,240
there is a race condition which luckily

00:31:08,240 --> 00:31:13,519
can be easily avoided by

00:31:10,240 --> 00:31:16,559
calling this update function twice both

00:31:13,519 --> 00:31:17,440
before and after the transmit so first

00:31:16,559 --> 00:31:19,679
time

00:31:17,440 --> 00:31:20,480
after falling completions and second

00:31:19,679 --> 00:31:23,840
time after

00:31:20,480 --> 00:31:26,640
doing the transmit in this order

00:31:23,840 --> 00:31:29,200
so if you follow the order you will not

00:31:26,640 --> 00:31:31,840
have any race condition

00:31:29,200 --> 00:31:33,200
but let's take a deeper look at this

00:31:31,840 --> 00:31:36,480
race condition anyway

00:31:33,200 --> 00:31:39,519
and how the fix works

00:31:36,480 --> 00:31:40,159
what can happen if we call the update

00:31:39,519 --> 00:31:42,880
function

00:31:40,159 --> 00:31:43,519
only after we transmit packets it's

00:31:42,880 --> 00:31:47,679
shown

00:31:43,519 --> 00:31:51,600
in the table the driver transmits

00:31:47,679 --> 00:31:54,080
all the packets and it's going to set

00:31:51,600 --> 00:31:58,320
need wake up to true

00:31:54,080 --> 00:32:00,640
but the application queries just before

00:31:58,320 --> 00:32:02,000
and we are in trouble the application

00:32:00,640 --> 00:32:04,640
thinks that

00:32:02,000 --> 00:32:05,679
it doesn't have to call the wake up but

00:32:04,640 --> 00:32:07,919
the driver

00:32:05,679 --> 00:32:10,240
won't do any more transmits on its own

00:32:07,919 --> 00:32:12,720
it will wait for the wake up

00:32:10,240 --> 00:32:15,279
that's why we have to set need wake up

00:32:12,720 --> 00:32:18,480
before we do the actual transmit

00:32:15,279 --> 00:32:21,440
in this case even if

00:32:18,480 --> 00:32:23,039
even if the application queries it it's

00:32:21,440 --> 00:32:26,000
false

00:32:23,039 --> 00:32:28,159
the packets are already in the tx ring

00:32:26,000 --> 00:32:30,720
because the application should first put

00:32:28,159 --> 00:32:31,200
packets then it queries need wake up

00:32:30,720 --> 00:32:34,159
then

00:32:31,200 --> 00:32:35,760
it issues assist call if need wake up is

00:32:34,159 --> 00:32:38,559
true

00:32:35,760 --> 00:32:39,679
so yep the packets will be already in

00:32:38,559 --> 00:32:42,799
the tx ring

00:32:39,679 --> 00:32:44,399
and the driver will transmit them in

00:32:42,799 --> 00:32:46,159
another situation

00:32:44,399 --> 00:32:48,559
if the driver has already started

00:32:46,159 --> 00:32:50,559
transmitting the flag will already be

00:32:48,559 --> 00:32:53,120
true and the application will wake up

00:32:50,559 --> 00:32:55,519
the driver properly

00:32:53,120 --> 00:32:56,480
on the other hand if the transmit

00:32:55,519 --> 00:32:59,840
function has

00:32:56,480 --> 00:33:02,480
put some packets into the hardware queue

00:32:59,840 --> 00:33:03,919
we don't want need wake up to stay true

00:33:02,480 --> 00:33:06,880
without need

00:33:03,919 --> 00:33:07,840
so we call we call the update function

00:33:06,880 --> 00:33:10,960
once again

00:33:07,840 --> 00:33:14,559
after transmitting to clear the flag as

00:33:10,960 --> 00:33:18,000
soon as we can when it's possible

00:33:14,559 --> 00:33:20,960
so basically the first update call can

00:33:18,000 --> 00:33:22,080
transition the flag to true and the

00:33:20,960 --> 00:33:25,120
second one

00:33:22,080 --> 00:33:28,640
can set it to false

00:33:25,120 --> 00:33:32,240
of course it will not happen every

00:33:28,640 --> 00:33:35,440
iteration but that's

00:33:32,240 --> 00:33:35,440
what can happen at all

00:33:36,720 --> 00:33:41,760
and after talking about the need wake up

00:33:40,480 --> 00:33:45,120
challenges

00:33:41,760 --> 00:33:49,679
we smoothly go to other challenges

00:33:45,120 --> 00:33:53,760
such as the q allocation scheme

00:33:49,679 --> 00:33:56,399
so in the beginning i40e

00:33:53,760 --> 00:33:57,039
and the medic's five had something in

00:33:56,399 --> 00:34:00,320
common

00:33:57,039 --> 00:34:03,519
before xsk there are n channels

00:34:00,320 --> 00:34:06,960
each channel contains an rx and the gxq

00:34:03,519 --> 00:34:07,360
for norm for normal traffic and also

00:34:06,960 --> 00:34:12,000
some

00:34:07,360 --> 00:34:14,480
xdpt excuse however

00:34:12,000 --> 00:34:15,280
we decided to use a different q

00:34:14,480 --> 00:34:18,560
allocation

00:34:15,280 --> 00:34:21,599
scheme in mlx5 rather than

00:34:18,560 --> 00:34:25,919
following the same for that was used in

00:34:21,599 --> 00:34:29,359
i40 in i40 when a socket is

00:34:25,919 --> 00:34:32,240
attached with a qadx

00:34:29,359 --> 00:34:32,800
the corresponding channel turns into an

00:34:32,240 --> 00:34:35,520
xsk

00:34:32,800 --> 00:34:37,679
channel which means that the buffer

00:34:35,520 --> 00:34:40,720
allocation happens from the um

00:34:37,679 --> 00:34:44,960
it depends on the application

00:34:40,720 --> 00:34:49,200
and in mlx5 on on the contrary

00:34:44,960 --> 00:34:52,399
an additional pair of rx and txq's in

00:34:49,200 --> 00:34:53,280
opened in the same channel like in

00:34:52,399 --> 00:34:56,240
addition to

00:34:53,280 --> 00:34:58,160
the normal queues which continue to

00:34:56,240 --> 00:35:01,040
exist

00:34:58,160 --> 00:35:03,040
we use a separate range of qids to

00:35:01,040 --> 00:35:06,160
distinguish between normal

00:35:03,040 --> 00:35:08,960
and xsk queues for example

00:35:06,160 --> 00:35:09,760
it's used in each tool to steer incoming

00:35:08,960 --> 00:35:12,240
traffic

00:35:09,760 --> 00:35:13,119
and we need to distinguish where we want

00:35:12,240 --> 00:35:17,200
to steer

00:35:13,119 --> 00:35:20,560
either to xskrq or normal rq

00:35:17,200 --> 00:35:21,359
and a common xdp program used with high

00:35:20,560 --> 00:35:23,359
fxdp

00:35:21,359 --> 00:35:24,480
normally just redirects all the traffic

00:35:23,359 --> 00:35:27,599
from a given queue

00:35:24,480 --> 00:35:30,160
to the af xdp application and

00:35:27,599 --> 00:35:32,240
unless a separate queue range is used

00:35:30,160 --> 00:35:35,440
rss can also steer some

00:35:32,240 --> 00:35:37,680
normal traffic unrelated to afxdp into

00:35:35,440 --> 00:35:40,640
the xsk enabled queue

00:35:37,680 --> 00:35:42,160
and mistakenly block holding it in the

00:35:40,640 --> 00:35:45,760
application

00:35:42,160 --> 00:35:47,760
with such an approach uh rss has to be

00:35:45,760 --> 00:35:49,280
manually reconfigured by the

00:35:47,760 --> 00:35:52,720
administrator

00:35:49,280 --> 00:35:55,200
whenever an access case opened or closed

00:35:52,720 --> 00:35:58,000
and we wanted to avoid this issue in

00:35:55,200 --> 00:36:00,880
mlx5 so with our approach

00:35:58,000 --> 00:36:03,119
normal traffic can always use the whole

00:36:00,880 --> 00:36:06,880
range of channels

00:36:03,119 --> 00:36:10,079
however using a separate range for

00:36:06,880 --> 00:36:13,040
zero copy high fxdp sockets breaks

00:36:10,079 --> 00:36:15,520
the automatic fallback to copy mode in

00:36:13,040 --> 00:36:17,119
cases when zero copy is not supported by

00:36:15,520 --> 00:36:21,280
the driver

00:36:17,119 --> 00:36:24,839
and we decided that rss is more repo

00:36:21,280 --> 00:36:28,160
is more important that that

00:36:24,839 --> 00:36:29,280
fallback given that mlx 5 supports zero

00:36:28,160 --> 00:36:32,320
copy so

00:36:29,280 --> 00:36:33,920
we picked this way but now you should

00:36:32,320 --> 00:36:36,320
have enough information

00:36:33,920 --> 00:36:37,920
that will allow you to pick what's best

00:36:36,320 --> 00:36:40,960
for your driver

00:36:37,920 --> 00:36:43,920
and of course the source code for

00:36:40,960 --> 00:36:46,560
both drivers is available for the

00:36:43,920 --> 00:36:46,560
reference

00:36:47,760 --> 00:36:51,839
so at this point i'd like to finish this

00:36:50,400 --> 00:36:54,560
presentation

00:36:51,839 --> 00:36:55,359
thank you and i hope that now that

00:36:54,560 --> 00:36:58,640
you've watched

00:36:55,359 --> 00:37:01,839
this tutorial you will be able to add a

00:36:58,640 --> 00:37:05,119
fxdp to your drivers easily

00:37:01,839 --> 00:37:05,599
feel free to ask questions if you have

00:37:05,119 --> 00:37:09,839
any

00:37:05,599 --> 00:37:09,839
i'm here to answer them

00:37:10,720 --> 00:37:18,240
okay i see a question

00:37:14,000 --> 00:37:22,240
how are fragmented packets put in

00:37:18,240 --> 00:37:25,359
in the ring buffers so if you mean

00:37:22,240 --> 00:37:27,280
uh stuff like non-linear packets like

00:37:25,359 --> 00:37:31,359
non-linear skbs

00:37:27,280 --> 00:37:35,680
then um it's not supported by fxdp

00:37:31,359 --> 00:37:38,240
it's a limitation by design af xdp

00:37:35,680 --> 00:37:41,280
only has frames and each frame is

00:37:38,240 --> 00:37:44,720
continuous and it holds one packet

00:37:41,280 --> 00:37:48,839
so you don't have

00:37:44,720 --> 00:37:50,240
an alternative to non-linear skbs with a

00:37:48,839 --> 00:37:53,760
fxdp

00:37:50,240 --> 00:37:56,960
and actually with xdp

00:37:53,760 --> 00:38:00,160
user and

00:37:56,960 --> 00:38:00,720
as high fxdp is based on xdp on the rx

00:38:00,160 --> 00:38:04,400
side

00:38:00,720 --> 00:38:07,520
so here comes this limitation

00:38:04,400 --> 00:38:10,640
okay so the next question is about

00:38:07,520 --> 00:38:14,079
are your urine what um does for

00:38:10,640 --> 00:38:17,119
xdp similar to what io

00:38:14,079 --> 00:38:20,400
urine does is there any thought on this

00:38:17,119 --> 00:38:24,240
prevailing in the community

00:38:20,400 --> 00:38:27,359
well to be honest i heard of urine

00:38:24,240 --> 00:38:30,240
if i'm not mistaken it appeared

00:38:27,359 --> 00:38:32,640
slightly after ifxdp but correct me if

00:38:30,240 --> 00:38:36,079
i'm wrong

00:38:32,640 --> 00:38:37,599
and to be honest i never touched during

00:38:36,079 --> 00:38:41,520
so

00:38:37,599 --> 00:38:44,800
i'm not competent to analyze

00:38:41,520 --> 00:38:47,839
this topic i'm

00:38:44,800 --> 00:38:50,400
an ifxdp guy so

00:38:47,839 --> 00:38:51,520
yeah that's a good stuff that i should

00:38:50,400 --> 00:38:55,280
um

00:38:51,520 --> 00:38:58,640
look at in my free time

00:38:55,280 --> 00:39:01,760
but uh like i can't really compare them

00:38:58,640 --> 00:39:04,240
at this moment sorry

00:39:01,760 --> 00:39:06,640
jasper probably you could answer this

00:39:04,240 --> 00:39:09,040
question

00:39:06,640 --> 00:39:10,240
yeah i don't i i don't i have an answer

00:39:09,040 --> 00:39:13,359
either so

00:39:10,240 --> 00:39:17,200
it's like like you said you

00:39:13,359 --> 00:39:21,680
that the iou ring came after

00:39:17,200 --> 00:39:23,920
af hdb i hope someone would actually

00:39:21,680 --> 00:39:26,079
work on this and maybe do a model but we

00:39:23,920 --> 00:39:28,720
can also support

00:39:26,079 --> 00:39:29,200
the iou ring but i don't know enough

00:39:28,720 --> 00:39:34,400
about

00:39:29,200 --> 00:39:34,400
iou ring too no if it's possible or not

00:39:34,880 --> 00:39:38,400
okay so probably that's a good topic

00:39:37,280 --> 00:39:44,000
that we can

00:39:38,400 --> 00:39:47,599
analyze in our free time

00:39:44,000 --> 00:39:52,000
yeah okay yeah so this

00:39:47,599 --> 00:39:54,839
link that you sent to the chat is uh

00:39:52,000 --> 00:39:56,160
regarding adding the need wake up

00:39:54,839 --> 00:39:59,359
feature

00:39:56,160 --> 00:40:02,720
and they see that magnus compares it

00:39:59,359 --> 00:40:04,480
it's he says that they need wake up

00:40:02,720 --> 00:40:07,520
feature was inspired by

00:40:04,480 --> 00:40:07,520
io urine

00:40:08,839 --> 00:40:16,160
so yeah

00:40:12,880 --> 00:40:19,200
probably the intel guys uh looked at it

00:40:16,160 --> 00:40:23,440
and took some advantage and moved

00:40:19,200 --> 00:40:26,480
to moved it to fxdp

00:40:23,440 --> 00:40:27,200
okay so you see two questions uh first

00:40:26,480 --> 00:40:31,200
one

00:40:27,200 --> 00:40:35,599
is about um what do you think

00:40:31,200 --> 00:40:39,599
is the next development uh with a fxdp

00:40:35,599 --> 00:40:42,480
improvements yeah first of all

00:40:39,599 --> 00:40:43,760
uh we can move on with further

00:40:42,480 --> 00:40:48,000
simplifying

00:40:43,760 --> 00:40:50,640
uh the driver api um

00:40:48,000 --> 00:40:51,280
there was one thing that i mentioned in

00:40:50,640 --> 00:40:54,400
the stock

00:40:51,280 --> 00:40:57,920
that can be improved uh but

00:40:54,400 --> 00:41:00,800
uh anyway the intel guys uh

00:40:57,920 --> 00:41:03,040
did a great job recently on the

00:41:00,800 --> 00:41:07,200
refactoring

00:41:03,040 --> 00:41:10,560
and the simplifying that interface

00:41:07,200 --> 00:41:14,960
the next thing that they

00:41:10,560 --> 00:41:19,200
know it wasn't mentioned in this talk

00:41:14,960 --> 00:41:19,200
it's sharing

00:41:19,520 --> 00:41:26,160
of the same um between

00:41:22,640 --> 00:41:26,960
different net devices or different cues

00:41:26,160 --> 00:41:30,400
of the same

00:41:26,960 --> 00:41:34,079
net device which is useful for

00:41:30,400 --> 00:41:36,640
forwarding use cases uh basically

00:41:34,079 --> 00:41:37,599
the serious ones on the mailing list i

00:41:36,640 --> 00:41:41,119
think it was

00:41:37,599 --> 00:41:41,760
already merged uh but anyway this

00:41:41,119 --> 00:41:45,520
feature

00:41:41,760 --> 00:41:45,520
is ready um

00:41:46,000 --> 00:41:53,040
from my side i don't have

00:41:49,200 --> 00:41:57,200
anything any new ideas if anyone has

00:41:53,040 --> 00:41:59,920
it's a great opportunity to share and

00:41:57,200 --> 00:42:00,240
probably there will be some great ideas

00:41:59,920 --> 00:42:03,200
that

00:42:00,240 --> 00:42:04,240
can be implemented that's basically the

00:42:03,200 --> 00:42:08,480
answer

00:42:04,240 --> 00:42:11,200
and the second question i see is

00:42:08,480 --> 00:42:13,599
about the challenges of fxdp with

00:42:11,200 --> 00:42:16,960
non-linear buffers

00:42:13,599 --> 00:42:20,640
so basically the main challenge

00:42:16,960 --> 00:42:24,079
is that xdp doesn't work with non-linear

00:42:20,640 --> 00:42:27,920
and afxdp uses

00:42:24,079 --> 00:42:32,560
xdp for the rx side it bases on it

00:42:27,920 --> 00:42:35,599
it's kinda fundamental

00:42:32,560 --> 00:42:39,040
limitation of fxdp

00:42:35,599 --> 00:42:39,839
of course with some decent amount of

00:42:39,040 --> 00:42:45,440
work

00:42:39,839 --> 00:42:47,920
it could be added

00:42:45,440 --> 00:42:50,400
because there is nothing that prevents

00:42:47,920 --> 00:42:58,240
us from extending the api

00:42:50,400 --> 00:43:02,000
and like if you just

00:42:58,240 --> 00:43:05,200
well you need a more advanced allocator

00:43:02,000 --> 00:43:08,800
for that to allocate

00:43:05,200 --> 00:43:11,839
arbitrary buffers from the um

00:43:08,800 --> 00:43:15,119
you also need to

00:43:11,839 --> 00:43:20,240
extend the descriptors to store like

00:43:15,119 --> 00:43:20,240
multiple pointers to the chunks and

00:43:21,040 --> 00:43:27,839
it's not impossible to implement

00:43:24,240 --> 00:43:30,319
but it's quite a big amount of work

00:43:27,839 --> 00:43:31,280
and i'm not sure that it's actually

00:43:30,319 --> 00:43:36,319
needed for

00:43:31,280 --> 00:43:40,319
the ifxdp scenarios

00:43:36,319 --> 00:43:44,400
okay next question is about arm 64.

00:43:40,319 --> 00:43:48,400
on arm 64 with smmu io mmu

00:43:44,400 --> 00:43:51,200
an action having multiple small size

00:43:48,400 --> 00:43:52,640
becomes an overhead with respect mapping

00:43:51,200 --> 00:43:55,680
and mapping

00:43:52,640 --> 00:43:57,119
so in some drivers we support coalition

00:43:55,680 --> 00:43:59,119
of tx buffers

00:43:57,119 --> 00:44:01,920
not sure if this could be done with

00:43:59,119 --> 00:44:01,920
human buffs

00:44:02,800 --> 00:44:09,119
so for ifxdp you

00:44:05,839 --> 00:44:10,880
do the mapping only once

00:44:09,119 --> 00:44:13,040
in the beginning you set up a

00:44:10,880 --> 00:44:16,319
bidirectional mapping

00:44:13,040 --> 00:44:18,880
for the whole um and

00:44:16,319 --> 00:44:20,240
then all the allocations will be done

00:44:18,880 --> 00:44:23,359
from that um

00:44:20,240 --> 00:44:27,280
and you don't have to map on the map uh

00:44:23,359 --> 00:44:27,920
per packet so i don't think it's it's a

00:44:27,280 --> 00:44:31,839
problem

00:44:27,920 --> 00:44:34,400
with the fxdp okay um

00:44:31,839 --> 00:44:36,640
i hope you and i i hope i answered the

00:44:34,400 --> 00:44:40,640
previous question

00:44:36,640 --> 00:44:44,560
if not please elaborate more

00:44:40,640 --> 00:44:45,920
the next one is could you list some real

00:44:44,560 --> 00:44:49,680
practical

00:44:45,920 --> 00:44:52,720
scenarios of using ifxdp which you saw

00:44:49,680 --> 00:44:55,680
in production environment

00:44:52,720 --> 00:44:58,240
well unfortunately i don't think i can

00:44:55,680 --> 00:45:00,800
talk about it

00:44:58,240 --> 00:45:01,599
do we have some performance improvement

00:45:00,800 --> 00:45:05,839
numbers

00:45:01,599 --> 00:45:05,839
in percents with fxdp

00:45:07,839 --> 00:45:16,160
yes actually it's a matter of

00:45:11,119 --> 00:45:18,720
packet rate uh basically and

00:45:16,160 --> 00:45:20,319
i'm not ready to tell you any exact

00:45:18,720 --> 00:45:23,680
numbers right now

00:45:20,319 --> 00:45:28,000
because it all depends on this

00:45:23,680 --> 00:45:30,960
setup on your cpu and

00:45:28,000 --> 00:45:32,079
the nic that you're using you can

00:45:30,960 --> 00:45:36,160
actually find

00:45:32,079 --> 00:45:39,119
performance numbers on the mailing lists

00:45:36,160 --> 00:45:40,160
with the corresponding commits um

00:45:39,119 --> 00:45:44,480
usually

00:45:40,160 --> 00:45:47,760
when we do performance related stuff

00:45:44,480 --> 00:45:50,240
such as ifxdp

00:45:47,760 --> 00:45:51,440
we put performance numbers into the

00:45:50,240 --> 00:45:55,839
commit message

00:45:51,440 --> 00:45:59,200
so you can find it there

00:45:55,839 --> 00:46:02,960
some some numbers with

00:45:59,200 --> 00:46:05,599
packets per second indications and

00:46:02,960 --> 00:46:06,560
of course you'll also have a performance

00:46:05,599 --> 00:46:09,680
improvement

00:46:06,560 --> 00:46:13,760
uh for having

00:46:09,680 --> 00:46:17,599
zero copy you actually can

00:46:13,760 --> 00:46:20,720
use zero copy even in such ways that

00:46:17,599 --> 00:46:21,200
you receive some packet modified in

00:46:20,720 --> 00:46:23,520
place

00:46:21,200 --> 00:46:25,680
and then retransmit back from the same

00:46:23,520 --> 00:46:29,119
memory so it's never copied

00:46:25,680 --> 00:46:32,400
uh on this um like

00:46:29,119 --> 00:46:36,480
in this pipeline so a good

00:46:32,400 --> 00:46:40,000
uh a good

00:46:36,480 --> 00:46:43,680
real user usage example could be

00:46:40,000 --> 00:46:47,040
uh forwarding scenarios or some proxies

00:46:43,680 --> 00:46:50,640
um but unfortunately as i said before

00:46:47,040 --> 00:46:54,240
i can't list any uh real

00:46:50,640 --> 00:46:57,839
like names customers and uh that use

00:46:54,240 --> 00:46:57,839
it in production

00:46:58,480 --> 00:47:06,720
i believe it's confidential

00:47:02,160 --> 00:47:10,000
um okay more questions

00:47:06,720 --> 00:47:13,920
if all of your channels in unique

00:47:10,000 --> 00:47:16,160
go to a new xdp only channel

00:47:13,920 --> 00:47:18,240
does this limitation mean that only one

00:47:16,160 --> 00:47:21,119
application can be used per nic

00:47:18,240 --> 00:47:23,359
or am i misunderstanding that part of

00:47:21,119 --> 00:47:27,599
creating the nucleus

00:47:23,359 --> 00:47:30,800
so okay let's say you have

00:47:27,599 --> 00:47:34,960
like like first of all of course

00:47:30,800 --> 00:47:38,319
it's not limited to only one application

00:47:34,960 --> 00:47:40,720
and it's it doesn't break the regular

00:47:38,319 --> 00:47:40,720
traffic

00:47:41,599 --> 00:47:45,440
of course you can have only one xdp

00:47:44,559 --> 00:47:49,839
program

00:47:45,440 --> 00:47:52,800
per the interface that means that

00:47:49,839 --> 00:47:54,640
if you have multiple application they

00:47:52,800 --> 00:47:58,400
have to collaborate

00:47:54,640 --> 00:48:00,960
regarding the xdp program

00:47:58,400 --> 00:48:03,040
because only one can be set and of

00:48:00,960 --> 00:48:06,079
course it's possible to write a program

00:48:03,040 --> 00:48:10,160
that will satisfy both applications

00:48:06,079 --> 00:48:13,359
or many applications but

00:48:10,160 --> 00:48:14,880
it's not something that happens in the

00:48:13,359 --> 00:48:16,960
kernel automatically

00:48:14,880 --> 00:48:19,760
so that's some bottleneck regarding

00:48:16,960 --> 00:48:24,800
multiple fxdp applications

00:48:19,760 --> 00:48:28,160
regarding channels there is no problem

00:48:24,800 --> 00:48:31,280
because when you open

00:48:28,160 --> 00:48:31,920
an ifxdp socket you pick only one

00:48:31,280 --> 00:48:34,559
channel

00:48:31,920 --> 00:48:35,200
and the channel will be used by a newly

00:48:34,559 --> 00:48:39,760
created

00:48:35,200 --> 00:48:42,960
fxdp socket so

00:48:39,760 --> 00:48:45,760
it doesn't occupy the whole device and

00:48:42,960 --> 00:48:47,200
another high fx dp application can use

00:48:45,760 --> 00:48:51,680
another

00:48:47,200 --> 00:48:55,440
channel or multiple channels so

00:48:51,680 --> 00:48:57,440
yeah i hope it's clear now thanks

00:48:55,440 --> 00:48:59,599
the second question is what's the

00:48:57,440 --> 00:49:03,119
difference between a copy and zero copy

00:48:59,599 --> 00:49:07,760
operation from the user side

00:49:03,119 --> 00:49:12,000
well it's meant to be transparent

00:49:07,760 --> 00:49:16,240
so the default mode is

00:49:12,000 --> 00:49:18,880
when you don't specify your preferences

00:49:16,240 --> 00:49:19,839
and you will get zero copy when possible

00:49:18,880 --> 00:49:22,720
um

00:49:19,839 --> 00:49:24,240
and it will fall back to copy when when

00:49:22,720 --> 00:49:27,599
not possible

00:49:24,240 --> 00:49:31,200
um but like there is one

00:49:27,599 --> 00:49:34,160
caveat regarding this slide

00:49:31,200 --> 00:49:35,760
queue allocation scheme so if you go

00:49:34,160 --> 00:49:38,880
i40e away

00:49:35,760 --> 00:49:41,119
this fallback will work so basically

00:49:38,880 --> 00:49:42,839
you will run an application and it will

00:49:41,119 --> 00:49:46,079
fall back to copy

00:49:42,839 --> 00:49:46,880
on uh looks that don't support zero copy

00:49:46,079 --> 00:49:50,640
and that will use

00:49:46,880 --> 00:49:53,920
zero copy on those that does that does

00:49:50,640 --> 00:49:57,040
that do support it uh but

00:49:53,920 --> 00:50:00,480
uh this approach has rss broken so we

00:49:57,040 --> 00:50:03,599
in in melanox we picked another way

00:50:00,480 --> 00:50:07,119
and this fallback

00:50:03,599 --> 00:50:07,520
doesn't work just as is uh so that may

00:50:07,119 --> 00:50:10,319
be

00:50:07,520 --> 00:50:13,359
a difference for the user and of course

00:50:10,319 --> 00:50:13,359
you have uh

00:50:14,400 --> 00:50:20,400
you have a flag that you can set when

00:50:18,400 --> 00:50:24,240
creating a socket you can prefer

00:50:20,400 --> 00:50:27,280
copy or prefer zero copy in this way

00:50:24,240 --> 00:50:28,880
you will like you will get an error

00:50:27,280 --> 00:50:30,319
if you want zero copy and it's not

00:50:28,880 --> 00:50:32,480
supported and

00:50:30,319 --> 00:50:34,160
if you want copy you will always get

00:50:32,480 --> 00:50:37,520
copy

00:50:34,160 --> 00:50:40,079
so uh but yeah

00:50:37,520 --> 00:50:41,599
in general there is this fallback to

00:50:40,079 --> 00:50:45,200
copy

00:50:41,599 --> 00:50:48,480
for compatibility uh

00:50:45,200 --> 00:50:50,160
next question you may miss shared with

00:50:48,480 --> 00:50:55,440
oak use is that true

00:50:50,160 --> 00:50:59,359
no it's not true um

00:50:55,440 --> 00:51:00,960
so i think the uh the remaining part of

00:50:59,359 --> 00:51:04,079
the question

00:51:00,960 --> 00:51:07,200
uh is not actual we

00:51:04,079 --> 00:51:09,839
yes we use um per q that's

00:51:07,200 --> 00:51:09,839
how it happens

00:51:10,480 --> 00:51:14,240
and like with the recent work you can

00:51:13,839 --> 00:51:17,359
share

00:51:14,240 --> 00:51:20,880
um with multiple cues or even between

00:51:17,359 --> 00:51:21,599
net devices but by default you get a new

00:51:20,880 --> 00:51:24,079
um

00:51:21,599 --> 00:51:24,079
per q

00:51:25,040 --> 00:51:31,680
okay i see a question regarding the nyx

00:51:28,559 --> 00:51:35,760
you can play with for some learning

00:51:31,680 --> 00:51:38,720
so yeah of course i can suggest

00:51:35,760 --> 00:51:38,720
melanox nix

00:51:39,119 --> 00:51:47,599
basically connect x5

00:51:42,720 --> 00:51:47,599
and newer support fxdp

00:51:48,720 --> 00:51:55,599
you can play with them and also

00:51:52,160 --> 00:51:58,720
you can use intel nix

00:51:55,599 --> 00:52:02,160
unfortunately i don't know the

00:51:58,720 --> 00:52:05,520
article names but anything that runs

00:52:02,160 --> 00:52:08,880
i40 driver ixgbe

00:52:05,520 --> 00:52:12,640
or ice all that stuff

00:52:08,880 --> 00:52:12,640
should support high fxdp

00:52:13,599 --> 00:52:21,440
um are you aware of any applications

00:52:18,160 --> 00:52:24,559
using ifxdp yes i

00:52:21,440 --> 00:52:27,359
am but i believe i cannot

00:52:24,559 --> 00:52:29,119
talk about real world examples and

00:52:27,359 --> 00:52:33,839
customers

00:52:29,119 --> 00:52:33,839
because i believe it's confidential

00:52:34,000 --> 00:52:41,440
yeah and of course i should mention that

00:52:38,160 --> 00:52:44,720
if you want to play around with fxdp

00:52:41,440 --> 00:52:47,119
there is a sample in

00:52:44,720 --> 00:52:48,160
in the kernel sources directory it's

00:52:47,119 --> 00:52:52,000
called

00:52:48,160 --> 00:52:55,359
xdp sock and basically it allows you

00:52:52,000 --> 00:52:58,400
to test the different modes rx sticks

00:52:55,359 --> 00:53:00,640
forwarding you can play with that

00:52:58,400 --> 00:53:01,440
as an example application if you're

00:53:00,640 --> 00:53:04,400
developing

00:53:01,440 --> 00:53:07,119
your own one or if you're just exploring

00:53:04,400 --> 00:53:07,119
fxdp

00:53:09,920 --> 00:53:14,960
so next question is

00:53:13,040 --> 00:53:17,119
uh is there any difference in

00:53:14,960 --> 00:53:21,040
performance on tiny packets

00:53:17,119 --> 00:53:24,079
when switching to fxdp or is performance

00:53:21,040 --> 00:53:24,079
exactly the same

00:53:24,480 --> 00:53:32,079
so if you mean compared to

00:53:29,040 --> 00:53:32,079
the regular

00:53:32,880 --> 00:53:37,760
kernel data path then yes there is

00:53:40,839 --> 00:53:45,119
difference

00:53:42,880 --> 00:53:46,640
again i'm not ready to give you some

00:53:45,119 --> 00:53:50,559
exact numbers

00:53:46,640 --> 00:53:53,680
uh oh okay compared to ordinary xdp

00:53:50,559 --> 00:53:57,359
um well i'm not sure

00:53:53,680 --> 00:53:59,760
we explored it

00:53:57,359 --> 00:53:59,760
enough

00:54:00,880 --> 00:54:08,160
i expect that it could be comparably

00:54:04,480 --> 00:54:12,000
the same but

00:54:08,160 --> 00:54:16,079
ifxdp could be slower because

00:54:12,000 --> 00:54:16,400
it involves like more code more entities

00:54:16,079 --> 00:54:24,240
and

00:54:16,400 --> 00:54:27,520
some user user land part um

00:54:24,240 --> 00:54:32,480
but like it's actually

00:54:27,520 --> 00:54:36,079
pretty easy to compare uh if you run

00:54:32,480 --> 00:54:39,599
you even can use the kernel samples

00:54:36,079 --> 00:54:43,520
for xdp forwarding for example and for

00:54:39,599 --> 00:54:46,720
af xdp you can use xdp shock minus l

00:54:43,520 --> 00:54:46,720
and compare yourself

00:54:47,119 --> 00:54:55,760
i don't have any good numbers to

00:54:51,520 --> 00:54:55,760
tell right now sorry

00:54:56,079 --> 00:55:00,720
well one thing i know for sure is that

00:54:58,880 --> 00:55:05,040
xdp drop

00:55:00,720 --> 00:55:08,079
is much faster than uh

00:55:05,040 --> 00:55:11,599
than what xdp sock does for

00:55:08,079 --> 00:55:11,599
the receive and drop mode

00:55:12,400 --> 00:55:15,520
like a few times

00:55:16,160 --> 00:55:20,160
well could you just repeat that one more

00:55:17,760 --> 00:55:24,000
time so x db drop is faster than

00:55:20,160 --> 00:55:27,119
which one uh yeah

00:55:24,000 --> 00:55:28,160
if you just run playing xdp drop so you

00:55:27,119 --> 00:55:32,000
drop the packets

00:55:28,160 --> 00:55:35,599
uh like at the very very early point

00:55:32,000 --> 00:55:39,280
and they enter the xdp application

00:55:35,599 --> 00:55:43,200
uh it will be faster than if you run

00:55:39,280 --> 00:55:46,400
a fxdp application xdp stock which is a

00:55:43,200 --> 00:55:48,960
sample shipped with the kernel and

00:55:46,400 --> 00:55:49,920
configure it to just drop incoming

00:55:48,960 --> 00:55:54,240
packets

00:55:49,920 --> 00:55:54,240
and it's expectable because

00:55:54,480 --> 00:55:58,799
with xdp drop you just drop the packets

00:55:57,200 --> 00:56:01,599
as soon as they arrive

00:55:58,799 --> 00:56:02,319
and with the fxdp you need to move

00:56:01,599 --> 00:56:04,480
around

00:56:02,319 --> 00:56:07,040
descriptors you have some part in the

00:56:04,480 --> 00:56:10,640
user space

00:56:07,040 --> 00:56:13,760
and only after all that code runs

00:56:10,640 --> 00:56:16,319
you drop a packet so

00:56:13,760 --> 00:56:17,839
yeah it's it's faster than the kernel

00:56:16,319 --> 00:56:20,319
stack but slower than

00:56:17,839 --> 00:56:20,319
xdp

00:56:20,880 --> 00:56:25,280
okay next question the application of

00:56:23,680 --> 00:56:28,000
fxdp in your case

00:56:25,280 --> 00:56:32,559
is meant for real deployment or the work

00:56:28,000 --> 00:56:32,559
you are doing is just meant to prototype

00:56:32,640 --> 00:56:37,359
not sure what you mean by my case in my

00:56:35,440 --> 00:56:40,799
case i was the developer

00:56:37,359 --> 00:56:44,880
who added fx dp 0 copy support to

00:56:40,799 --> 00:56:47,040
the melanox driver and it's

00:56:44,880 --> 00:56:48,079
meant for real deployment of course it's

00:56:47,040 --> 00:56:50,400
just

00:56:48,079 --> 00:56:53,520
full-blown support in the driver and can

00:56:50,400 --> 00:56:55,760
be used in production

00:56:53,520 --> 00:56:56,559
regarding the xdp stock sample that i

00:56:55,760 --> 00:57:00,000
mentioned

00:56:56,559 --> 00:57:03,119
it's just an example application uh

00:57:00,000 --> 00:57:06,480
that was developed

00:57:03,119 --> 00:57:10,000
by intel and the xdp shock is

00:57:06,480 --> 00:57:15,040
meant to be for testing purposes

00:57:10,000 --> 00:57:18,319
and uh to like just as a

00:57:15,040 --> 00:57:20,559
example how a fxdp application looks

00:57:18,319 --> 00:57:22,799
like

00:57:20,559 --> 00:57:27,839
so if you're developing an application

00:57:22,799 --> 00:57:27,839
you are going to write your own

00:57:28,000 --> 00:57:36,000
okay any tips for migrating from dpdk

00:57:31,680 --> 00:57:39,040
lip bpf's api is slightly different

00:57:36,000 --> 00:57:42,640
well yeah i expect it to be different

00:57:39,040 --> 00:57:43,359
unfortunately i'm not familiar with the

00:57:42,640 --> 00:57:47,920
btk

00:57:43,359 --> 00:57:51,440
api i don't know how it looks like

00:57:47,920 --> 00:57:55,040
so but i guess this question

00:57:51,440 --> 00:57:58,640
could be like a topic for

00:57:55,040 --> 00:58:00,400
a whole talk by someone

00:57:58,640 --> 00:58:03,040
who has experience with both

00:58:00,400 --> 00:58:06,960
technologies

00:58:03,040 --> 00:58:09,839
so yeah unfortunately i don't have

00:58:06,960 --> 00:58:09,839
any tips for you

00:58:10,799 --> 00:58:17,440
regarding dpdk yeah i'm

00:58:14,160 --> 00:58:21,440
i'm not an expert as i said but i know

00:58:17,440 --> 00:58:25,119
that there is a dpdk driver that uses

00:58:21,440 --> 00:58:28,480
afx dp so

00:58:25,119 --> 00:58:32,880
it basically allows you to use dpdk over

00:58:28,480 --> 00:58:34,319
ifxdp so so this might be a bit of a

00:58:32,880 --> 00:58:38,559
silly question as

00:58:34,319 --> 00:58:39,520
af um is af zero copy a component of

00:58:38,559 --> 00:58:43,359
afxdp

00:58:39,520 --> 00:58:46,480
or are they uh distinct uh technologies

00:58:43,359 --> 00:58:49,599
how do they kind of work together okay

00:58:46,480 --> 00:58:53,599
so basically afxdb is

00:58:49,599 --> 00:58:56,880
meant to be used with zerocopy um

00:58:53,599 --> 00:58:58,720
uh af actually stands for address family

00:58:56,880 --> 00:59:03,359
this is what you specify

00:58:58,720 --> 00:59:06,400
in your socket syscall like af unix

00:59:03,359 --> 00:59:10,160
and this is af xdp

00:59:06,400 --> 00:59:12,880
so zero copy is the main

00:59:10,160 --> 00:59:15,040
intended mode of using a fxdp because

00:59:12,880 --> 00:59:17,680
it's the fastest

00:59:15,040 --> 00:59:18,960
but the good thing about afx dp is that

00:59:17,680 --> 00:59:22,480
it's

00:59:18,960 --> 00:59:24,319
compatible with drivers that do not

00:59:22,480 --> 00:59:27,760
support this functionality

00:59:24,319 --> 00:59:31,760
so there is first fallback

00:59:27,760 --> 00:59:35,280
to copy mode if your driver supports xdp

00:59:31,760 --> 00:59:38,960
but doesn't support zero copy for af xdp

00:59:35,280 --> 00:59:39,839
the kernel will do the job uh for the

00:59:38,960 --> 00:59:42,559
driver

00:59:39,839 --> 00:59:43,119
and yeah of course there will be a copy

00:59:42,559 --> 00:59:47,839
involved

00:59:43,119 --> 00:59:47,839
but the application api will be the same

00:59:48,640 --> 00:59:55,200
and another mode is for the drivers

00:59:52,160 --> 00:59:58,559
that do not support xdp

00:59:55,200 --> 01:00:02,000
they will pass skbs to the kernel and

00:59:58,559 --> 01:00:05,920
it will run xdp over them and

01:00:02,000 --> 01:00:09,280
it can also run hey fxdp so

01:00:05,920 --> 01:00:11,119
basically yes fxdp is a framework

01:00:09,280 --> 01:00:14,400
that is intended to be used with zero

01:00:11,119 --> 01:00:18,480
copy all the rest is just

01:00:14,400 --> 01:00:22,640
some fallbacks for incompatible drivers

01:00:18,480 --> 01:00:25,520
okay thanks thank you

01:00:22,640 --> 01:00:25,920
okay i see there have been no questions

01:00:25,520 --> 01:00:29,359
for

01:00:25,920 --> 01:00:32,559
the last few minutes thank you

01:00:29,359 --> 01:00:35,760
all of you who asked me questions

01:00:32,559 --> 01:00:42,160
it was really nice to

01:00:35,760 --> 01:00:42,160

YouTube URL: https://www.youtube.com/watch?v=cSdQIISFx08


