Title: Netdev 0x14 - Extending TC with 5-tuple hash offload (dp_hash)
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Rony Efraim, Roni Bar Yanai, Ariel Levkovich

More info: https://netdevconf.info/0x14/session.html?talk-extending-tc-with-5-tuple-hash-offload-dp-hash

Date: Friday, August 14, 2020

In this moonshot talk Bar Yanai describes a clever way
to do efficient forwarding by introducing a TC hash action. 
An example use case of this feature is closely emulating what Equal
Cost Multipath (ECMP) based forwarding does. ECMP-like can be achieved by
enabling policy which will:
- First create a hash on a classical 5 tuple in hardware
- Use the resulting hash as a tc filter chain id and jump to that filter chain
- within the destination chain lookup a much smaller set of tc flower
rules (in the equivalent 5 tuple space) and execute the leaf action(s)
such as setting the next hop mac address, etc.

Bar will describe the suggested TC extension to define the hash
semantics and then delve into the challenges involved.
Captions: 
	00:00:02,560 --> 00:00:07,600
okay so

00:00:03,679 --> 00:00:10,960
my name is uh ronnie byannai from nvidia

00:00:07,600 --> 00:00:12,559
i'm here to present uh an idea we have

00:00:10,960 --> 00:00:15,759
of extending the tc with

00:00:12,559 --> 00:00:16,880
a five tuple hash offload this is the

00:00:15,759 --> 00:00:19,600
work of me and

00:00:16,880 --> 00:00:20,160
also ronnie frye and also i want to

00:00:19,600 --> 00:00:22,800
thank

00:00:20,160 --> 00:00:24,880
a real leftover which is not appearing

00:00:22,800 --> 00:00:26,880
here in the title

00:00:24,880 --> 00:00:29,599
so first i'm going to talk about a

00:00:26,880 --> 00:00:32,640
programmable a data plane

00:00:29,599 --> 00:00:35,520
and if what it is

00:00:32,640 --> 00:00:36,480
and about the tc how tc can be used to

00:00:35,520 --> 00:00:38,879
implement this

00:00:36,480 --> 00:00:40,480
program data plane concept and when we

00:00:38,879 --> 00:00:43,680
have tc we also

00:00:40,480 --> 00:00:47,200
have a tc other offload and

00:00:43,680 --> 00:00:50,239
i'm going to do some recap about it um

00:00:47,200 --> 00:00:53,280
as it already exists in

00:00:50,239 --> 00:00:54,000
in the kernel and we just want to extend

00:00:53,280 --> 00:00:56,160
it

00:00:54,000 --> 00:00:57,920
then for the specific use case of

00:00:56,160 --> 00:00:58,559
hashing i'm going to explain a little

00:00:57,920 --> 00:01:02,000
bit about

00:00:58,559 --> 00:01:03,280
ecmp is the the main use case here but

00:01:02,000 --> 00:01:06,400
we have a lot of other

00:01:03,280 --> 00:01:09,600
more general general generalized

00:01:06,400 --> 00:01:11,600
use case for it and last

00:01:09,600 --> 00:01:13,840
we focused a little bit about the

00:01:11,600 --> 00:01:17,920
details uh

00:01:13,840 --> 00:01:20,479
offloading hash has some pitfalls

00:01:17,920 --> 00:01:22,080
on synchronizing between the the data

00:01:20,479 --> 00:01:25,360
plan and the control plan

00:01:22,080 --> 00:01:28,720
and we talk about it

00:01:25,360 --> 00:01:31,360
okay so about tc and dc offload

00:01:28,720 --> 00:01:32,079
and programmable data plan so the

00:01:31,360 --> 00:01:35,200
concept of

00:01:32,079 --> 00:01:36,240
uh programmable data plane is uh i think

00:01:35,200 --> 00:01:39,680
driven from that

00:01:36,240 --> 00:01:40,240
from the understanding that when we have

00:01:39,680 --> 00:01:42,000
a flow

00:01:40,240 --> 00:01:43,439
let's say you have a cloud and you have

00:01:42,000 --> 00:01:45,360
the web server

00:01:43,439 --> 00:01:48,159
and someone is trying to access the web

00:01:45,360 --> 00:01:49,840
server and download the page

00:01:48,159 --> 00:01:51,200
the first packet that will arrive it

00:01:49,840 --> 00:01:54,240
will be a packet with

00:01:51,200 --> 00:01:57,200
an underlay which

00:01:54,240 --> 00:01:59,200
carried the packets on the

00:01:57,200 --> 00:02:01,439
infrastructure of the cloud maybe it

00:01:59,200 --> 00:02:02,719
would be vixlan geneve or other

00:02:01,439 --> 00:02:04,799
tunneling

00:02:02,719 --> 00:02:06,719
and the first thing that will be done on

00:02:04,799 --> 00:02:08,000
the host after receiving the packet is

00:02:06,719 --> 00:02:11,200
understanding the

00:02:08,000 --> 00:02:14,480
understanding which vm

00:02:11,200 --> 00:02:15,760
or which port basically this packet

00:02:14,480 --> 00:02:18,480
belong to

00:02:15,760 --> 00:02:19,599
and it probably strip the packet from

00:02:18,480 --> 00:02:21,440
the vxlan

00:02:19,599 --> 00:02:23,120
and we fold it to the next phase the

00:02:21,440 --> 00:02:25,440
next phase can be

00:02:23,120 --> 00:02:27,920
for example connection tracking if you

00:02:25,440 --> 00:02:31,599
have a security groups you want to

00:02:27,920 --> 00:02:34,640
add some to have some window validation

00:02:31,599 --> 00:02:38,319
or just to to make sure that connection

00:02:34,640 --> 00:02:42,720
is coming in and not coming out and and

00:02:38,319 --> 00:02:44,959
last probably have not because usually

00:02:42,720 --> 00:02:47,360
there is the use of different ips

00:02:44,959 --> 00:02:50,160
locally

00:02:47,360 --> 00:02:51,200
so the first packet we have a series of

00:02:50,160 --> 00:02:54,480
steps that we need

00:02:51,200 --> 00:02:55,599
to take but after we understand this

00:02:54,480 --> 00:02:57,440
tech this is

00:02:55,599 --> 00:02:59,200
this is the first packet in in a stream

00:02:57,440 --> 00:03:00,159
of packet because when we download the

00:02:59,200 --> 00:03:01,840
page

00:03:00,159 --> 00:03:04,800
we probably are going to download

00:03:01,840 --> 00:03:06,720
content it will open a data a tcp flow

00:03:04,800 --> 00:03:09,680
and will download the

00:03:06,720 --> 00:03:10,800
the data itself it will be stream of

00:03:09,680 --> 00:03:13,280
packets

00:03:10,800 --> 00:03:14,480
but after the the first few packets we

00:03:13,280 --> 00:03:17,519
can say that the the

00:03:14,480 --> 00:03:20,480
the flow is now deterministic we have a

00:03:17,519 --> 00:03:22,480
some kind of execution pipeline that we

00:03:20,480 --> 00:03:26,000
that is it will not change during the

00:03:22,480 --> 00:03:28,560
the lifetime of this uh flow

00:03:26,000 --> 00:03:29,040
and this is a where program of data

00:03:28,560 --> 00:03:32,480
planning

00:03:29,040 --> 00:03:35,920
comes in we can express it the the

00:03:32,480 --> 00:03:39,680
the the the deterministic part we can

00:03:35,920 --> 00:03:42,480
express uh with um a concept of

00:03:39,680 --> 00:03:43,840
uh tables and rules and the programmable

00:03:42,480 --> 00:03:46,799
data pane have

00:03:43,840 --> 00:03:48,000
tables each has an id and for in each

00:03:46,799 --> 00:03:50,879
table we have the

00:03:48,000 --> 00:03:52,319
rules each rule is consisted of matches

00:03:50,879 --> 00:03:55,360
and actions

00:03:52,319 --> 00:03:55,920
match can be usually it will be a part

00:03:55,360 --> 00:03:58,959
of the

00:03:55,920 --> 00:04:00,000
of the packet and fields like the ipad

00:03:58,959 --> 00:04:03,040
the mac addresses

00:04:00,000 --> 00:04:05,760
if it's tunnel it can be vni and so on

00:04:03,040 --> 00:04:07,599
it can also be a metadata for example

00:04:05,760 --> 00:04:11,439
after we strip the packet

00:04:07,599 --> 00:04:14,159
and the metadata itself is still kept

00:04:11,439 --> 00:04:15,120
somewhere and we can compare it when the

00:04:14,159 --> 00:04:17,519
processing

00:04:15,120 --> 00:04:19,600
continue and other actions can be

00:04:17,519 --> 00:04:21,680
modified the header uh for example

00:04:19,600 --> 00:04:24,080
when we have not we will modify the

00:04:21,680 --> 00:04:27,520
source ip or destination api port

00:04:24,080 --> 00:04:30,160
and so on and last is

00:04:27,520 --> 00:04:30,800
steering action steering actions means

00:04:30,160 --> 00:04:33,680
that

00:04:30,800 --> 00:04:35,520
we can tell what is the next table in

00:04:33,680 --> 00:04:37,919
the pipeline that we need

00:04:35,520 --> 00:04:38,800
to execute or it could be if this is the

00:04:37,919 --> 00:04:41,360
last table

00:04:38,800 --> 00:04:42,400
we can take a decision about forwarding

00:04:41,360 --> 00:04:45,120
the packet to

00:04:42,400 --> 00:04:46,639
the vm to the where it will be handled

00:04:45,120 --> 00:04:47,919
and given to the web servers in this

00:04:46,639 --> 00:04:50,320
case in this example

00:04:47,919 --> 00:04:51,680
or we can take an other action of drop

00:04:50,320 --> 00:04:54,400
and so on

00:04:51,680 --> 00:04:56,560
so we have a control plane which is uh

00:04:54,400 --> 00:04:59,199
can be more complex

00:04:56,560 --> 00:05:00,560
that learn the first flow and be

00:04:59,199 --> 00:05:03,280
configured we

00:05:00,560 --> 00:05:06,240
like with sdn controller maybe open flow

00:05:03,280 --> 00:05:09,600
and we have a very simple data plane

00:05:06,240 --> 00:05:10,000
and and the data plane is simple it

00:05:09,600 --> 00:05:13,280
means that

00:05:10,000 --> 00:05:16,000
we can implement it also in

00:05:13,280 --> 00:05:16,000
in hardware

00:05:17,520 --> 00:05:23,280
okay so a few years ago and the

00:05:20,560 --> 00:05:26,800
community started to

00:05:23,280 --> 00:05:28,560
to implement this kind of um

00:05:26,800 --> 00:05:30,080
let's start with the beginning this is

00:05:28,560 --> 00:05:33,520
existing for a long time but

00:05:30,080 --> 00:05:36,479
tc was chosen as the the right tool

00:05:33,520 --> 00:05:36,880
of uh implementing programmable data

00:05:36,479 --> 00:05:39,759
plan

00:05:36,880 --> 00:05:40,960
and with also hardware offload support

00:05:39,759 --> 00:05:44,880
the reason for that is

00:05:40,960 --> 00:05:48,160
that this is first in line except xdp

00:05:44,880 --> 00:05:50,880
and um and it already has a lot of

00:05:48,160 --> 00:05:52,479
a classifier from this classifier and tc

00:05:50,880 --> 00:05:54,800
flowers chosen because

00:05:52,479 --> 00:05:56,240
it has a very flexible key structure

00:05:54,800 --> 00:05:59,600
that you can extend

00:05:56,240 --> 00:06:03,360
and you can express a lot of matches

00:05:59,600 --> 00:06:05,919
different matches with this key and

00:06:03,360 --> 00:06:07,039
tc already has a lot of different

00:06:05,919 --> 00:06:10,000
actions

00:06:07,039 --> 00:06:12,800
that can be used for the steering for

00:06:10,000 --> 00:06:16,000
the steering or for modifying a packet

00:06:12,800 --> 00:06:16,960
so it has very expressive language you

00:06:16,000 --> 00:06:20,240
can say

00:06:16,960 --> 00:06:24,000
and it's also a linux tool

00:06:20,240 --> 00:06:26,160
and then also vendor agnostic so um

00:06:24,000 --> 00:06:28,160
you can implement using the tc you can

00:06:26,160 --> 00:06:28,960
implement a programmable database a data

00:06:28,160 --> 00:06:31,600
plane

00:06:28,960 --> 00:06:32,880
using the tc software only and if you

00:06:31,600 --> 00:06:35,440
have a nic that supports

00:06:32,880 --> 00:06:37,039
hardware offload this um those rules

00:06:35,440 --> 00:06:39,199
that you configure can be

00:06:37,039 --> 00:06:41,360
offloaded and packet will be handled

00:06:39,199 --> 00:06:43,600
completely completely in hardware

00:06:41,360 --> 00:06:45,440
so here is an example this is a i think

00:06:43,600 --> 00:06:48,479
a very famous one

00:06:45,440 --> 00:06:51,840
how you add a flow for and decap okay

00:06:48,479 --> 00:06:54,240
you see that we configure a tca a

00:06:51,840 --> 00:06:56,319
flower a rule uh for matching the

00:06:54,240 --> 00:06:58,080
destination mark source mark

00:06:56,319 --> 00:07:00,639
a source ip and destination appear of

00:06:58,080 --> 00:07:02,639
the tunnel itself and also there

00:07:00,639 --> 00:07:03,919
is the destination port in this case

00:07:02,639 --> 00:07:07,680
four seven

00:07:03,919 --> 00:07:12,000
eight nine which is the default uh

00:07:07,680 --> 00:07:12,720
vixelan there is the vni which is a 16

00:07:12,000 --> 00:07:17,199
in this case

00:07:12,720 --> 00:07:20,560
and the action is a up unset the tunnel

00:07:17,199 --> 00:07:24,400
and the next action is sent to the

00:07:20,560 --> 00:07:26,080
vm so packets with this vni with v916

00:07:24,400 --> 00:07:29,280
from this source

00:07:26,080 --> 00:07:31,840
a ipm destination ip will go to this

00:07:29,280 --> 00:07:33,759
spot

00:07:31,840 --> 00:07:35,280
of course this is a very simple rule

00:07:33,759 --> 00:07:38,639
there is no way

00:07:35,280 --> 00:07:41,759
next table but a tc also is

00:07:38,639 --> 00:07:42,319
a go to chain which can be which can

00:07:41,759 --> 00:07:45,520
express

00:07:42,319 --> 00:07:47,919
a table

00:07:45,520 --> 00:07:49,599
so um there's a lot of benefit in

00:07:47,919 --> 00:07:51,680
offloading later the

00:07:49,599 --> 00:07:53,680
the data plan and the benefit is mainly

00:07:51,680 --> 00:07:57,360
performance here is a simple

00:07:53,680 --> 00:08:00,720
example we tested and

00:07:57,360 --> 00:08:02,479
this is a test that we did vxlan with

00:08:00,720 --> 00:08:06,240
the connection tracking we do

00:08:02,479 --> 00:08:08,800
a two hundred thousand flows

00:08:06,240 --> 00:08:09,680
hundred thousand flows when you add the

00:08:08,800 --> 00:08:12,560
different

00:08:09,680 --> 00:08:13,680
tcp and udp sessions concurrently when

00:08:12,560 --> 00:08:16,080
we run

00:08:13,680 --> 00:08:17,840
packet from each flow like this is the

00:08:16,080 --> 00:08:21,280
the worst case there is there's

00:08:17,840 --> 00:08:24,800
there's a cache missed for each a packet

00:08:21,280 --> 00:08:25,599
as you can see the the the number of

00:08:24,800 --> 00:08:29,440
packets

00:08:25,599 --> 00:08:30,080
you can reach um using also the 27

00:08:29,440 --> 00:08:33,120
million

00:08:30,080 --> 00:08:37,360
packets per second doing that with the

00:08:33,120 --> 00:08:39,440
software and let's say software

00:08:37,360 --> 00:08:41,279
with connection tracking a core can do

00:08:39,440 --> 00:08:44,000
maybe 500k

00:08:41,279 --> 00:08:45,519
even less this depends what app is this

00:08:44,000 --> 00:08:46,320
is a call without hyper thread with

00:08:45,519 --> 00:08:49,519
hyper thread

00:08:46,320 --> 00:08:53,519
it's half so and this is also a lower

00:08:49,519 --> 00:08:56,320
uh i'm giving a higher rate

00:08:53,519 --> 00:08:59,040
where we saw but you can see that for

00:08:56,320 --> 00:09:01,040
yourself that for pushing 27

00:08:59,040 --> 00:09:03,360
million packets per second you will have

00:09:01,040 --> 00:09:06,399
to use at least 54

00:09:03,360 --> 00:09:08,480
calls and those are host cores that can

00:09:06,399 --> 00:09:10,320
be used for other purposes

00:09:08,480 --> 00:09:13,440
when you're doing offload you use zero

00:09:10,320 --> 00:09:15,040
cpu cycles for pushing this traffic

00:09:13,440 --> 00:09:17,040
of course you'll also have the the

00:09:15,040 --> 00:09:19,200
controller part that you need

00:09:17,040 --> 00:09:20,399
to learn the first flow okay of the part

00:09:19,200 --> 00:09:22,240
that you learn

00:09:20,399 --> 00:09:23,839
and the part that you configure but i

00:09:22,240 --> 00:09:25,920
feel after you configure

00:09:23,839 --> 00:09:27,360
everything run in in hardware so you

00:09:25,920 --> 00:09:29,760
have to maybe invest two

00:09:27,360 --> 00:09:31,600
three cores for the control and all the

00:09:29,760 --> 00:09:32,959
rest is done in hardware so this is the

00:09:31,600 --> 00:09:36,480
benefit

00:09:32,959 --> 00:09:39,120
um okay now we go for

00:09:36,480 --> 00:09:40,000
for the ecmp so i just want to check the

00:09:39,120 --> 00:09:44,399
time

00:09:40,000 --> 00:09:47,680
um so ecmp equal costs multipath

00:09:44,399 --> 00:09:47,680
okay this is a very a

00:09:48,839 --> 00:09:54,080
known

00:09:51,200 --> 00:09:55,519
you have a network with multiple routers

00:09:54,080 --> 00:09:57,279
and you have

00:09:55,519 --> 00:09:59,920
two nodes that are connecting between

00:09:57,279 --> 00:10:03,279
them there's the source and destination

00:09:59,920 --> 00:10:07,040
and the packet can go through router a

00:10:03,279 --> 00:10:09,200
router b or router c from l3 perspective

00:10:07,040 --> 00:10:12,480
this is the same

00:10:09,200 --> 00:10:16,839
distance the same number of hops so all

00:10:12,480 --> 00:10:19,360
are all considered as the best paths

00:10:16,839 --> 00:10:22,000
um if we would choose

00:10:19,360 --> 00:10:22,480
just one of them uh for example always

00:10:22,000 --> 00:10:24,959
go

00:10:22,480 --> 00:10:26,000
go to router a and we have other nodes

00:10:24,959 --> 00:10:28,800
this is

00:10:26,000 --> 00:10:29,360
of course a very simplified um drawing

00:10:28,800 --> 00:10:31,120
they

00:10:29,360 --> 00:10:33,120
will have a much more will have a lot of

00:10:31,120 --> 00:10:36,480
nodes and if for example

00:10:33,120 --> 00:10:39,279
another source which is also route array

00:10:36,480 --> 00:10:41,279
and we will get rotary uh pushing all

00:10:39,279 --> 00:10:44,640
the traffic and router b and c

00:10:41,279 --> 00:10:46,320
will not see any packet so to achieve

00:10:44,640 --> 00:10:49,440
much better utilization

00:10:46,320 --> 00:10:49,920
uh with equal cost multipass in this

00:10:49,440 --> 00:10:52,160
case

00:10:49,920 --> 00:10:54,000
we split the traffic we send some of the

00:10:52,160 --> 00:10:56,640
traffic throughout our a sound to the b

00:10:54,000 --> 00:11:00,079
and some to c

00:10:56,640 --> 00:11:01,839
and when we do that we have to to make

00:11:00,079 --> 00:11:04,320
sure that packets

00:11:01,839 --> 00:11:06,320
arrive on the same order that they were

00:11:04,320 --> 00:11:09,040
sent at least for the same session okay

00:11:06,320 --> 00:11:10,959
if we have a tcp session we cannot send

00:11:09,040 --> 00:11:12,160
some of the packet to router any sound

00:11:10,959 --> 00:11:15,360
some to be

00:11:12,160 --> 00:11:19,040
because on an on a local time

00:11:15,360 --> 00:11:21,519
uh there might be a different load

00:11:19,040 --> 00:11:23,600
on the routers so right away might have

00:11:21,519 --> 00:11:24,880
different latency it will be more loaded

00:11:23,600 --> 00:11:28,480
than router b

00:11:24,880 --> 00:11:31,040
so packets might arrive out of order

00:11:28,480 --> 00:11:32,160
um if this is only one two packets or

00:11:31,040 --> 00:11:35,279
very short time

00:11:32,160 --> 00:11:35,839
it might not affect tcp but if we have a

00:11:35,279 --> 00:11:39,120
lot of

00:11:35,839 --> 00:11:41,440
reorders tcp might consider this as

00:11:39,120 --> 00:11:42,800
bucket loss and when you have packet

00:11:41,440 --> 00:11:45,120
loads there there are

00:11:42,800 --> 00:11:45,839
retransmissions of packets and the

00:11:45,120 --> 00:11:48,000
throughput is

00:11:45,839 --> 00:11:48,880
is dropping and of course we don't want

00:11:48,000 --> 00:11:53,600
that

00:11:48,880 --> 00:11:55,440
uh udp it doesn't have that ordering but

00:11:53,600 --> 00:11:57,760
when we look at protocols that are using

00:11:55,440 --> 00:11:59,839
udp on top of it

00:11:57,760 --> 00:12:02,160
and it's also required for example if

00:11:59,839 --> 00:12:04,480
you have rtp and you have a video

00:12:02,160 --> 00:12:05,600
or a voice and you start to get packets

00:12:04,480 --> 00:12:09,920
out of order

00:12:05,600 --> 00:12:11,440
it will affect the quality and jitter

00:12:09,920 --> 00:12:13,440
and if you have uh

00:12:11,440 --> 00:12:15,040
also there are protocols like google

00:12:13,440 --> 00:12:18,000
quick that are completely

00:12:15,040 --> 00:12:19,200
and like tcp it uses the udp as the

00:12:18,000 --> 00:12:21,120
underlayer

00:12:19,200 --> 00:12:23,040
but the protocol itself has

00:12:21,120 --> 00:12:24,320
retransmission and sequence as

00:12:23,040 --> 00:12:27,440
congestion

00:12:24,320 --> 00:12:28,240
control and so on so we must keep the

00:12:27,440 --> 00:12:31,760
order

00:12:28,240 --> 00:12:31,760
on both udp and tcp

00:12:32,880 --> 00:12:36,079
so how we do that the most simple way of

00:12:35,519 --> 00:12:37,920
doing that

00:12:36,079 --> 00:12:39,519
or the first thing that come comes in

00:12:37,920 --> 00:12:41,279
mind is that you

00:12:39,519 --> 00:12:43,360
build a table and when you have a new

00:12:41,279 --> 00:12:47,120
flow you look at that table

00:12:43,360 --> 00:12:48,880
and you you look for the this five tuple

00:12:47,120 --> 00:12:50,160
if you find this five tuple you know

00:12:48,880 --> 00:12:53,279
what is the node

00:12:50,160 --> 00:12:54,079
if not you allocate the next node maybe

00:12:53,279 --> 00:12:57,360
in round

00:12:54,079 --> 00:13:00,160
robin and and keep it and the

00:12:57,360 --> 00:13:00,160
following packets

00:13:00,639 --> 00:13:04,720
you will look you will look up for the

00:13:02,240 --> 00:13:07,440
five tuple and you find the same node

00:13:04,720 --> 00:13:09,120
of course this is uh not an a very

00:13:07,440 --> 00:13:11,519
performance

00:13:09,120 --> 00:13:12,560
or very effective method of doing that

00:13:11,519 --> 00:13:15,680
because you have to keep

00:13:12,560 --> 00:13:16,720
all this formation you have to now do

00:13:15,680 --> 00:13:19,920
aging

00:13:16,720 --> 00:13:21,839
and on the on

00:13:19,920 --> 00:13:23,040
on the floors because some of the flaws

00:13:21,839 --> 00:13:25,360
will not terminate

00:13:23,040 --> 00:13:26,959
normally also for udp don't have

00:13:25,360 --> 00:13:29,839
domination at all

00:13:26,959 --> 00:13:30,880
um if there is a change in the network

00:13:29,839 --> 00:13:34,160
you now have to

00:13:30,880 --> 00:13:37,600
scan all the um the entries in the table

00:13:34,160 --> 00:13:38,399
and find the table that are related to

00:13:37,600 --> 00:13:41,199
the node that

00:13:38,399 --> 00:13:42,160
was changed and update them this is not

00:13:41,199 --> 00:13:46,399
efficient

00:13:42,160 --> 00:13:48,800
a much better um method or much

00:13:46,399 --> 00:13:49,680
more resilient methods of doing that is

00:13:48,800 --> 00:13:53,680
like

00:13:49,680 --> 00:13:55,440
um similar to hash table we do the hash

00:13:53,680 --> 00:13:58,800
calculation in separate we have the

00:13:55,440 --> 00:14:01,600
packet we calculate hash on five tuple

00:13:58,800 --> 00:14:02,399
we have a number we're doing a bit mask

00:14:01,600 --> 00:14:04,720
on that now

00:14:02,399 --> 00:14:06,320
and jump to one of the of the brackets

00:14:04,720 --> 00:14:09,360
we have a list of packets

00:14:06,320 --> 00:14:11,440
or array of brackets and in each bracket

00:14:09,360 --> 00:14:13,839
well what is the next action

00:14:11,440 --> 00:14:14,800
in ecmp it will go you will go to the

00:14:13,839 --> 00:14:16,880
next node by

00:14:14,800 --> 00:14:18,880
probably setting the mac address the

00:14:16,880 --> 00:14:20,880
right mac address and

00:14:18,880 --> 00:14:22,079
and sending to the wire um

00:14:20,880 --> 00:14:24,399
[Music]

00:14:22,079 --> 00:14:26,800
for other use cases you might choose to

00:14:24,399 --> 00:14:28,959
do something else

00:14:26,800 --> 00:14:31,040
so and with this method you have the

00:14:28,959 --> 00:14:32,800
cons the same consistency because

00:14:31,040 --> 00:14:34,639
each flow will always go to the same

00:14:32,800 --> 00:14:36,480
bucket

00:14:34,639 --> 00:14:38,320
and you don't need to save anything

00:14:36,480 --> 00:14:40,399
beside the buckets themselves

00:14:38,320 --> 00:14:41,519
and it would be a small number even if

00:14:40,399 --> 00:14:44,959
we would

00:14:41,519 --> 00:14:48,320
as we see we will we will use the

00:14:44,959 --> 00:14:49,920
in array of buckets it's probably 256

00:14:48,320 --> 00:14:52,560
maybe more

00:14:49,920 --> 00:14:54,399
but it's a very small number if you need

00:14:52,560 --> 00:14:55,760
an update so you update 10 buckets 20

00:14:54,399 --> 00:14:58,480
buckets it's not like

00:14:55,760 --> 00:15:00,800
updating thousands of flows there is no

00:14:58,480 --> 00:15:04,240
edging and so on

00:15:00,800 --> 00:15:04,880
so it's much more simple here is an

00:15:04,240 --> 00:15:07,920
example

00:15:04,880 --> 00:15:11,920
and of how we can implement

00:15:07,920 --> 00:15:13,279
the hashing with with this hash method

00:15:11,920 --> 00:15:16,399
okay we have a list of

00:15:13,279 --> 00:15:17,360
of packets consistent hash means that if

00:15:16,399 --> 00:15:21,279
you have

00:15:17,360 --> 00:15:25,279
a change change in the hash

00:15:21,279 --> 00:15:28,399
it affects only a k divided by n

00:15:25,279 --> 00:15:31,680
of the of the entries in the hash

00:15:28,399 --> 00:15:34,240
okay um it will try to be as

00:15:31,680 --> 00:15:34,880
consistable the more nodes you have and

00:15:34,240 --> 00:15:36,880
the less

00:15:34,880 --> 00:15:38,480
entries that will be affected by a

00:15:36,880 --> 00:15:41,600
change and

00:15:38,480 --> 00:15:44,240
you want that most of the of the entries

00:15:41,600 --> 00:15:45,120
will remain the same so in consistent

00:15:44,240 --> 00:15:47,279
hashing

00:15:45,120 --> 00:15:48,880
we have your node d and let's say there

00:15:47,279 --> 00:15:51,040
is a update in the

00:15:48,880 --> 00:15:52,399
in the network and node d is now a

00:15:51,040 --> 00:15:54,240
removal

00:15:52,399 --> 00:15:55,519
what we need to do is update all the

00:15:54,240 --> 00:15:59,279
brackets that has

00:15:55,519 --> 00:16:01,680
no d and changing to a to another

00:15:59,279 --> 00:16:02,959
node this means that all the green

00:16:01,680 --> 00:16:05,519
buckets node a b

00:16:02,959 --> 00:16:08,160
and c will remain the same we will not

00:16:05,519 --> 00:16:11,920
have packet reorder and we will not

00:16:08,160 --> 00:16:14,720
have any effect on on the traffic

00:16:11,920 --> 00:16:15,759
and then instead of not d we'll choose

00:16:14,720 --> 00:16:17,519
other nodes

00:16:15,759 --> 00:16:18,959
probably better to do it in a balanced

00:16:17,519 --> 00:16:20,880
way so here

00:16:18,959 --> 00:16:22,560
we see that the first one was replaced

00:16:20,880 --> 00:16:26,160
by node a second way not b

00:16:22,560 --> 00:16:28,720
and third by node c of course the high

00:16:26,160 --> 00:16:30,560
number of buckets uh will enable you

00:16:28,720 --> 00:16:33,680
also to have weights you can

00:16:30,560 --> 00:16:34,480
allocate 70 of the packets for node a

00:16:33,680 --> 00:16:38,399
and 30

00:16:34,480 --> 00:16:40,399
of the brackets so the rest and so on

00:16:38,399 --> 00:16:41,920
when you add a new node let's say

00:16:40,399 --> 00:16:43,120
there's another update on the network

00:16:41,920 --> 00:16:46,000
and you want to

00:16:43,120 --> 00:16:47,360
to add a new node you have to choose

00:16:46,000 --> 00:16:50,480
which bucket you change

00:16:47,360 --> 00:16:54,399
here we took three buckets one from a

00:16:50,480 --> 00:16:57,680
one for b and one from c and now

00:16:54,399 --> 00:16:59,199
there we go to node e the new node and

00:16:57,680 --> 00:17:02,160
only this traffic

00:16:59,199 --> 00:17:04,160
will change so it will not prevent uh

00:17:02,160 --> 00:17:06,640
real though but the reorder happens

00:17:04,160 --> 00:17:07,280
on network update and only for very

00:17:06,640 --> 00:17:09,839
short

00:17:07,280 --> 00:17:10,959
time in the the transition time and the

00:17:09,839 --> 00:17:12,799
assumption that

00:17:10,959 --> 00:17:14,079
removing and adding node nodes in

00:17:12,799 --> 00:17:16,880
network is much

00:17:14,079 --> 00:17:18,000
slower than the the rate that you open

00:17:16,880 --> 00:17:21,199
session in closed session

00:17:18,000 --> 00:17:21,199
and slow duration

00:17:22,400 --> 00:17:27,520
so we can generalize uh this hashing and

00:17:26,240 --> 00:17:30,799
have a much more

00:17:27,520 --> 00:17:34,240
complex or other use cases that

00:17:30,799 --> 00:17:35,440
will use the the hash and here is an

00:17:34,240 --> 00:17:38,559
example we want to do

00:17:35,440 --> 00:17:40,240
uh redundancy so we have

00:17:38,559 --> 00:17:42,000
vm number one and we have number two

00:17:40,240 --> 00:17:44,799
that are sending traffic the host

00:17:42,000 --> 00:17:46,160
is is has two routers connected to him

00:17:44,799 --> 00:17:49,760
active active

00:17:46,160 --> 00:17:52,160
um in doing a hash

00:17:49,760 --> 00:17:53,679
and choosing route array on router b

00:17:52,160 --> 00:17:57,039
according to the hash

00:17:53,679 --> 00:17:59,760
if one of the router is going down it

00:17:57,039 --> 00:18:01,039
will update the buckets and that the

00:17:59,760 --> 00:18:04,240
traffic would be

00:18:01,039 --> 00:18:07,039
diverted to the active one and

00:18:04,240 --> 00:18:08,320
the vm has no idea about that this is an

00:18:07,039 --> 00:18:11,360
infrastructure

00:18:08,320 --> 00:18:13,360
and also you don't need a special

00:18:11,360 --> 00:18:15,360
feature or something like that you just

00:18:13,360 --> 00:18:17,600
can program the data plane

00:18:15,360 --> 00:18:19,919
to do it easily and there are the use

00:18:17,600 --> 00:18:24,400
cases like service if you if we look on

00:18:19,919 --> 00:18:27,600
a higher level you can have a

00:18:24,400 --> 00:18:28,240
servers and on congestion time or busy

00:18:27,600 --> 00:18:31,679
time

00:18:28,240 --> 00:18:34,000
you might want to um add more vms

00:18:31,679 --> 00:18:35,840
and and you need to split the traffic

00:18:34,000 --> 00:18:38,640
between them so you have a gateway

00:18:35,840 --> 00:18:39,679
and when you add the ends you had more

00:18:38,640 --> 00:18:42,080
backer

00:18:39,679 --> 00:18:43,679
or more buckets or updated brackets to

00:18:42,080 --> 00:18:46,000
and direct

00:18:43,679 --> 00:18:47,120
the traffic to more and nodes to under

00:18:46,000 --> 00:18:49,440
the traffic

00:18:47,120 --> 00:18:51,280
okay there are there are other use cases

00:18:49,440 --> 00:18:54,799
so the hashing it can be

00:18:51,280 --> 00:18:57,840
generally generalized and using other

00:18:54,799 --> 00:18:57,840
cases as well

00:18:58,320 --> 00:19:01,919
so we talked about what is for a

00:19:00,080 --> 00:19:04,320
programmable data plan about the tc and

00:19:01,919 --> 00:19:05,679
then tc how to offload and its benefits

00:19:04,320 --> 00:19:08,640
we talked about ecmp

00:19:05,679 --> 00:19:09,039
and hashing in in general and now and we

00:19:08,640 --> 00:19:12,240
want

00:19:09,039 --> 00:19:13,039
uh i want to present how we can extend

00:19:12,240 --> 00:19:17,200
tc

00:19:13,039 --> 00:19:17,200
um to support that

00:19:19,120 --> 00:19:26,240
so the initial initial suggestion is

00:19:22,640 --> 00:19:29,200
adding a dedicated hash action

00:19:26,240 --> 00:19:31,600
and this would be a new new action in tc

00:19:29,200 --> 00:19:34,480
and and the action

00:19:31,600 --> 00:19:35,760
will uh calculate hash and on the first

00:19:34,480 --> 00:19:39,200
apple i will talk about

00:19:35,760 --> 00:19:40,880
which hash you can say the which

00:19:39,200 --> 00:19:42,640
are you going to calculate what is the

00:19:40,880 --> 00:19:43,090
hash function

00:19:42,640 --> 00:19:45,760
and

00:19:43,090 --> 00:19:48,559
[Music]

00:19:45,760 --> 00:19:49,840
and we put the the result in the skb

00:19:48,559 --> 00:19:52,240
hash

00:19:49,840 --> 00:19:54,240
and the other side of it is the bucket

00:19:52,240 --> 00:19:55,520
itself so the bucket can be implemented

00:19:54,240 --> 00:19:58,640
by tc flower

00:19:55,520 --> 00:19:59,120
you go to chain number two okay the

00:19:58,640 --> 00:20:01,919
first

00:19:59,120 --> 00:20:03,840
tc will calculate the hash and we'll

00:20:01,919 --> 00:20:04,799
jump to the hash table which is chain

00:20:03,840 --> 00:20:07,600
two

00:20:04,799 --> 00:20:09,280
in chain two uh we will have a match on

00:20:07,600 --> 00:20:11,440
the hash itself so

00:20:09,280 --> 00:20:13,679
in this case the bitmask is for the last

00:20:11,440 --> 00:20:15,760
four bits we have six in brackets

00:20:13,679 --> 00:20:17,440
in this case it will go to bracket

00:20:15,760 --> 00:20:20,400
number one

00:20:17,440 --> 00:20:21,600
and if you go to action to back at

00:20:20,400 --> 00:20:23,760
number one the

00:20:21,600 --> 00:20:25,919
in this case the action would be uh

00:20:23,760 --> 00:20:29,600
redirect the packet to

00:20:25,919 --> 00:20:29,600
this this interface

00:20:30,240 --> 00:20:33,600
however um we have a problem with the

00:20:32,559 --> 00:20:36,799
hash function

00:20:33,600 --> 00:20:39,200
itself and since we have a

00:20:36,799 --> 00:20:40,720
control plane and data plane or

00:20:39,200 --> 00:20:42,640
programmable data plane

00:20:40,720 --> 00:20:44,000
you know if we have auto offload it's

00:20:42,640 --> 00:20:46,640
another layer

00:20:44,000 --> 00:20:47,280
and the question is how what which what

00:20:46,640 --> 00:20:50,880
hash

00:20:47,280 --> 00:20:51,520
are we going to use um the control

00:20:50,880 --> 00:20:54,000
player might

00:20:51,520 --> 00:20:56,799
might choose one hash because it was

00:20:54,000 --> 00:21:00,240
written before this feature because

00:20:56,799 --> 00:21:01,760
um it's very effective hash

00:21:00,240 --> 00:21:03,919
for this use case i don't know what is

00:21:01,760 --> 00:21:06,559
the reason the hardware

00:21:03,919 --> 00:21:08,320
probably have its own hash because for

00:21:06,559 --> 00:21:09,840
hardware is usually different than

00:21:08,320 --> 00:21:12,880
software because

00:21:09,840 --> 00:21:14,880
um because of efficiency there are some

00:21:12,880 --> 00:21:17,360
hashes that are more efficient

00:21:14,880 --> 00:21:19,440
that you want to implement and of course

00:21:17,360 --> 00:21:20,320
the software might change it's uh it's

00:21:19,440 --> 00:21:23,280
hashing

00:21:20,320 --> 00:21:23,760
so uh for example in the linux you

00:21:23,280 --> 00:21:27,039
usually

00:21:23,760 --> 00:21:29,039
use a jenkins hash for

00:21:27,039 --> 00:21:30,080
the last year i don't know 10 years 15

00:21:29,039 --> 00:21:32,159
years

00:21:30,080 --> 00:21:33,360
and it might be that in the future

00:21:32,159 --> 00:21:35,840
someone will create

00:21:33,360 --> 00:21:37,760
a better hash that they have that will

00:21:35,840 --> 00:21:39,679
be double the performance

00:21:37,760 --> 00:21:41,520
reduced by half the time we take to

00:21:39,679 --> 00:21:43,440
execute or the cycles they take to

00:21:41,520 --> 00:21:46,559
execute the hashing

00:21:43,440 --> 00:21:48,240
and everything will start to use this

00:21:46,559 --> 00:21:51,440
hash

00:21:48,240 --> 00:21:53,200
so the ash itself it's a problem because

00:21:51,440 --> 00:21:55,600
we have different different components

00:21:53,200 --> 00:21:58,559
that are going to use this hash

00:21:55,600 --> 00:22:00,159
and why it is a problem in this case

00:21:58,559 --> 00:22:02,720
here we have an example

00:22:00,159 --> 00:22:04,080
in in sdn there are two use cases the

00:22:02,720 --> 00:22:06,320
the simple use case that

00:22:04,080 --> 00:22:07,520
is you you know your programmable data

00:22:06,320 --> 00:22:10,080
plane in advance

00:22:07,520 --> 00:22:11,120
it's all static and you can configure

00:22:10,080 --> 00:22:13,760
everything

00:22:11,120 --> 00:22:15,520
before you see the first packet in this

00:22:13,760 --> 00:22:19,840
case you don't have a problem

00:22:15,520 --> 00:22:22,880
because hash is always calculated in the

00:22:19,840 --> 00:22:26,559
in the hardware or on the data plane

00:22:22,880 --> 00:22:29,760
and and we know a

00:22:26,559 --> 00:22:30,480
sync problem but in the in use case

00:22:29,760 --> 00:22:33,280
where you have

00:22:30,480 --> 00:22:34,799
sdn usually in sdn controller you have a

00:22:33,280 --> 00:22:37,840
rules it's very dynamic

00:22:34,799 --> 00:22:38,480
because you're migrating vns vms are

00:22:37,840 --> 00:22:42,960
going down

00:22:38,480 --> 00:22:46,240
going up everything changes all the time

00:22:42,960 --> 00:22:46,799
so usually the data plan is empty on

00:22:46,240 --> 00:22:48,799
start

00:22:46,799 --> 00:22:50,640
and when you see traffic the first

00:22:48,799 --> 00:22:52,960
traffic you see and you don't have

00:22:50,640 --> 00:22:54,400
the data plan has no rule to what to do

00:22:52,960 --> 00:22:56,799
with this packet

00:22:54,400 --> 00:22:58,480
the packet will go to the control and

00:22:56,799 --> 00:23:00,960
the control will consult

00:22:58,480 --> 00:23:01,600
with the configuration that can be open

00:23:00,960 --> 00:23:06,080
flow

00:23:01,600 --> 00:23:08,799
or or other specific implementation

00:23:06,080 --> 00:23:09,679
and it will generate the pipeline the

00:23:08,799 --> 00:23:13,919
data plane

00:23:09,679 --> 00:23:13,919
pipeline so if we follow this

00:23:14,960 --> 00:23:19,679
and see what happens the first packet

00:23:18,640 --> 00:23:23,200
will not match

00:23:19,679 --> 00:23:26,640
in hardware because there is no buckets

00:23:23,200 --> 00:23:29,120
or a or intc if you go to software

00:23:26,640 --> 00:23:29,679
the software will calculate some kind of

00:23:29,120 --> 00:23:31,760
hash

00:23:29,679 --> 00:23:34,720
and for the software and the result was

00:23:31,760 --> 00:23:36,960
it is going to back it number zero

00:23:34,720 --> 00:23:38,799
now it generates the data plane

00:23:36,960 --> 00:23:40,240
configuration the data plane

00:23:38,799 --> 00:23:43,919
configuration

00:23:40,240 --> 00:23:46,640
uh is done and the next packet will hit

00:23:43,919 --> 00:23:47,600
the data plane now there is an there is

00:23:46,640 --> 00:23:49,919
a hash

00:23:47,600 --> 00:23:51,840
and and the result is different because

00:23:49,919 --> 00:23:55,760
there is a different hash

00:23:51,840 --> 00:23:59,360
in the data plane so here it it hit a

00:23:55,760 --> 00:24:02,080
bucket a number number two

00:23:59,360 --> 00:24:02,720
and there is no rule in bucket number

00:24:02,080 --> 00:24:06,640
two

00:24:02,720 --> 00:24:08,720
so it will enter software

00:24:06,640 --> 00:24:11,440
or to control plane so in the control

00:24:08,720 --> 00:24:14,000
plane we we calculate again the hash

00:24:11,440 --> 00:24:15,120
and we hit bucket number zero and this

00:24:14,000 --> 00:24:17,440
will not converge

00:24:15,120 --> 00:24:18,240
the result of this is that your data

00:24:17,440 --> 00:24:20,559
plane

00:24:18,240 --> 00:24:21,279
is not the programmable data plan is not

00:24:20,559 --> 00:24:23,440
configured

00:24:21,279 --> 00:24:24,720
correctly and you see all the traffic in

00:24:23,440 --> 00:24:28,159
the control

00:24:24,720 --> 00:24:31,440
and the control is the slowest path

00:24:28,159 --> 00:24:34,400
in in the system okay it's more complex

00:24:31,440 --> 00:24:35,840
and this is why it's more slow and the

00:24:34,400 --> 00:24:39,200
data play is simple and

00:24:35,840 --> 00:24:44,400
fast and in this case we cannot use it

00:24:39,200 --> 00:24:44,400
so what is the solution that we are

00:24:44,840 --> 00:24:48,000
suggesting

00:24:46,320 --> 00:24:49,440
there's very nice thing in the kernel

00:24:48,000 --> 00:24:53,279
that called the edpf

00:24:49,440 --> 00:24:56,320
or bps and you can provide a code

00:24:53,279 --> 00:24:58,240
that runs on on the on the packets and

00:24:56,320 --> 00:25:00,880
can do a lot of stuff

00:24:58,240 --> 00:25:02,400
one of them is calculating hash you can

00:25:00,880 --> 00:25:05,600
implement any hash

00:25:02,400 --> 00:25:09,039
or any common hash that we have crc

00:25:05,600 --> 00:25:11,520
or jenkins or or i don't know uh

00:25:09,039 --> 00:25:13,440
the common ash that that are used you

00:25:11,520 --> 00:25:17,360
can implement it with uh

00:25:13,440 --> 00:25:21,440
with this code and you can provide it uh

00:25:17,360 --> 00:25:25,679
as an apf code or bpf vpf code

00:25:21,440 --> 00:25:27,279
together with the with the

00:25:25,679 --> 00:25:29,840
data plan and the control point

00:25:27,279 --> 00:25:29,840
configuration

00:25:30,080 --> 00:25:34,240
so you will have the same hash dash is

00:25:33,039 --> 00:25:37,440
defined

00:25:34,240 --> 00:25:40,799
and now a dash is defined

00:25:37,440 --> 00:25:44,400
it is a vpf code and it depends if

00:25:40,799 --> 00:25:47,520
you're doing for example harder offload

00:25:44,400 --> 00:25:49,520
um the hardware can or the driver of the

00:25:47,520 --> 00:25:53,039
hardware can provide you

00:25:49,520 --> 00:25:54,080
the right function that is used for

00:25:53,039 --> 00:25:56,000
hardware you will not

00:25:54,080 --> 00:25:58,960
be able to change how the hardware

00:25:56,000 --> 00:26:02,159
behave but the hardware can supply

00:25:58,960 --> 00:26:02,720
a bpf code that can calculate the same

00:26:02,159 --> 00:26:05,600
hashing

00:26:02,720 --> 00:26:08,799
exactly the same hashing as the hardware

00:26:05,600 --> 00:26:08,799
so once you do that

00:26:08,880 --> 00:26:12,240
and and if if you have a missing into

00:26:11,600 --> 00:26:16,400
software

00:26:12,240 --> 00:26:19,440
you run the the ebpa for the bpf code

00:26:16,400 --> 00:26:21,600
um in software and

00:26:19,440 --> 00:26:22,720
the result will be that you will have

00:26:21,600 --> 00:26:25,840
the hash number

00:26:22,720 --> 00:26:26,960
or the result in the skb hash and it

00:26:25,840 --> 00:26:30,240
will go to bucket

00:26:26,960 --> 00:26:33,840
number two you configure the hardware

00:26:30,240 --> 00:26:36,880
and now okay and now

00:26:33,840 --> 00:26:39,120
when after you configured the first

00:26:36,880 --> 00:26:40,799
packet in that will be with that will be

00:26:39,120 --> 00:26:44,000
matched in hardware

00:26:40,799 --> 00:26:44,640
and we calculate the exact same hash

00:26:44,000 --> 00:26:46,799
function

00:26:44,640 --> 00:26:48,159
and as a result it will go to the exact

00:26:46,799 --> 00:26:51,840
same packet

00:26:48,159 --> 00:26:52,880
and we have a synchronization between

00:26:51,840 --> 00:26:56,159
and the hardware

00:26:52,880 --> 00:26:56,159
and and the software

00:26:56,880 --> 00:27:02,960
okay so we suggest to to extend

00:27:00,480 --> 00:27:04,480
the hash and beside saying that this is

00:27:02,960 --> 00:27:07,520
a hash

00:27:04,480 --> 00:27:11,120
we also provide um

00:27:07,520 --> 00:27:13,200
how to calculate it okay so in case of

00:27:11,120 --> 00:27:14,159
hardware offload you will take it from

00:27:13,200 --> 00:27:17,360
the from the

00:27:14,159 --> 00:27:21,440
from the driver and in other use cases

00:27:17,360 --> 00:27:23,919
um it it can be a way to sync you can

00:27:21,440 --> 00:27:26,000
think the software and the tc to do the

00:27:23,919 --> 00:27:26,720
same maybe your software is old and is

00:27:26,000 --> 00:27:28,640
doing

00:27:26,720 --> 00:27:30,080
another kind of hashing so you can

00:27:28,640 --> 00:27:32,399
provide the same hashing

00:27:30,080 --> 00:27:33,440
to the tcl science software that you

00:27:32,399 --> 00:27:37,039
would calculate

00:27:33,440 --> 00:27:40,240
the exact same hash and this solves

00:27:37,039 --> 00:27:40,240
the the sync problem

00:27:42,320 --> 00:27:48,399
okay so um to summarize

00:27:45,919 --> 00:27:48,960
we talked about programmable data plane

00:27:48,399 --> 00:27:53,360
as

00:27:48,960 --> 00:27:56,000
as a concept and is in about tc how

00:27:53,360 --> 00:27:58,320
this can be the right tool of doing that

00:27:56,000 --> 00:28:01,679
and even more

00:27:58,320 --> 00:28:04,880
this can be used as a hardware offload a

00:28:01,679 --> 00:28:07,520
tool in in in the programmable data

00:28:04,880 --> 00:28:10,399
plane can be offloaded to the hardware

00:28:07,520 --> 00:28:11,520
and the benefit of that which is uh

00:28:10,399 --> 00:28:13,679
offloading

00:28:11,520 --> 00:28:15,440
the packet forwarding entirely to the

00:28:13,679 --> 00:28:18,559
hardware and and

00:28:15,440 --> 00:28:21,440
giving the cycles to the hosts

00:28:18,559 --> 00:28:22,000
that they can be used for virtual

00:28:21,440 --> 00:28:24,799
machine

00:28:22,000 --> 00:28:26,000
or for anything else besides the packet

00:28:24,799 --> 00:28:28,799
folding

00:28:26,000 --> 00:28:31,120
um we explained a little bit about hash

00:28:28,799 --> 00:28:35,120
use cases when the first

00:28:31,120 --> 00:28:38,159
with the best use case is ecmp

00:28:35,120 --> 00:28:38,480
but the other use case the suggested way

00:28:38,159 --> 00:28:40,960
of

00:28:38,480 --> 00:28:41,600
solving ecmp can be used in other use

00:28:40,960 --> 00:28:44,200
cases

00:28:41,600 --> 00:28:46,000
like redundancy and service load

00:28:44,200 --> 00:28:50,159
balances and

00:28:46,000 --> 00:28:53,279
probably other stuff um

00:28:50,159 --> 00:28:56,960
we presented how we're going to extend

00:28:53,279 --> 00:28:58,240
or suggest to extend tc and to support

00:28:56,960 --> 00:29:00,799
this kind of hashing

00:28:58,240 --> 00:29:02,480
hash and the problem the six the sync

00:29:00,799 --> 00:29:05,120
challenge when you do that

00:29:02,480 --> 00:29:06,320
because you have hardware or data plane

00:29:05,120 --> 00:29:09,520
um

00:29:06,320 --> 00:29:10,799
hash and it might be different than the

00:29:09,520 --> 00:29:13,679
software hash

00:29:10,799 --> 00:29:14,240
and the way for solve that we suggest

00:29:13,679 --> 00:29:17,840
that we use

00:29:14,240 --> 00:29:21,919
ebpf to sync this uh

00:29:17,840 --> 00:29:22,960
this hash and the net dev conference

00:29:21,919 --> 00:29:26,080
should have been

00:29:22,960 --> 00:29:28,799
a few months ago but we didn't

00:29:26,080 --> 00:29:30,480
wait so the patches are now uh discussed

00:29:28,799 --> 00:29:33,600
in the community

00:29:30,480 --> 00:29:34,399
and the main rejection that we hear is

00:29:33,600 --> 00:29:38,720
about

00:29:34,399 --> 00:29:41,039
that there is already ebpf

00:29:38,720 --> 00:29:41,919
action so we can use that this is of

00:29:41,039 --> 00:29:44,240
course true

00:29:41,919 --> 00:29:45,279
and it's also true for other stuff we

00:29:44,240 --> 00:29:48,000
can do

00:29:45,279 --> 00:29:49,200
a lot of stuff with the bps i mean and

00:29:48,000 --> 00:29:52,880
there are

00:29:49,200 --> 00:29:57,840
actions uh specific actions for dust

00:29:52,880 --> 00:29:59,279
i guess that it's a trade-off

00:29:57,840 --> 00:30:01,039
between giving the user the

00:29:59,279 --> 00:30:04,080
expressiveness because it's much

00:30:01,039 --> 00:30:08,399
much more easy to configure tc hash

00:30:04,080 --> 00:30:12,159
and know what you're doing

00:30:08,399 --> 00:30:15,760
uh comparing to uh providing evpf code

00:30:12,159 --> 00:30:16,799
but um and this is the the trade-off and

00:30:15,760 --> 00:30:20,480
this is currently

00:30:16,799 --> 00:30:23,840
discussed in the community and

00:30:20,480 --> 00:30:23,840
that's it thank you for your time

00:30:24,720 --> 00:30:29,279
hey jamal i have a question this is

00:30:26,880 --> 00:30:29,279
anjali

00:30:29,360 --> 00:30:35,120
uh so the question is uh maybe i missed

00:30:32,880 --> 00:30:37,440
but is there a way to specify the seed

00:30:35,120 --> 00:30:42,159
for the hash as well like the key

00:30:37,440 --> 00:30:45,520
um you know not just the five tuple

00:30:42,159 --> 00:30:48,559
and then the other question um is uh

00:30:45,520 --> 00:30:51,520
i mean as i understood the the

00:30:48,559 --> 00:30:54,320
the bpf hook is to align the software

00:30:51,520 --> 00:30:58,880
hash algorithm with the hardware one

00:30:54,320 --> 00:31:01,200
um can i get the answers for those

00:30:58,880 --> 00:31:03,360
so i i don't know is ron in here anybody

00:31:01,200 --> 00:31:05,200
from metalworks worked on this

00:31:03,360 --> 00:31:06,399
no i can give you my point of view from

00:31:05,200 --> 00:31:09,440
what i understood

00:31:06,399 --> 00:31:12,320
would that help i'm not sure yeah

00:31:09,440 --> 00:31:15,039
okay well we'll we will make up some

00:31:12,320 --> 00:31:18,559
theories about what he's trying to say

00:31:15,039 --> 00:31:22,880
so uh my understanding is

00:31:18,559 --> 00:31:26,159
um the there is

00:31:22,880 --> 00:31:28,480
the software in the in the kernel

00:31:26,159 --> 00:31:29,519
has to be aware of what's being offered

00:31:28,480 --> 00:31:32,240
in the hardware

00:31:29,519 --> 00:31:32,720
correct right in order for the hash to

00:31:32,240 --> 00:31:36,480
work

00:31:32,720 --> 00:31:39,200
and um effectively

00:31:36,480 --> 00:31:40,080
um hash correctly so you can you can you

00:31:39,200 --> 00:31:43,600
can pick the

00:31:40,080 --> 00:31:43,600
the correct values right

00:31:44,640 --> 00:31:51,039
and so i i suspect that

00:31:47,840 --> 00:31:51,039
part of that uh

00:31:51,200 --> 00:31:54,399
uh policy definition will include this

00:31:53,919 --> 00:31:58,240
this

00:31:54,399 --> 00:31:58,240
uh seed you described

00:31:58,320 --> 00:32:04,559
that's just a suspicion i have no uh

00:32:01,760 --> 00:32:06,159
so the patches were posted and it seems

00:32:04,559 --> 00:32:08,000
that like there's a variety of hash

00:32:06,159 --> 00:32:09,279
algorithms and some of them were to be

00:32:08,000 --> 00:32:12,720
expressed using

00:32:09,279 --> 00:32:15,279
edpf because uh they may not have made a

00:32:12,720 --> 00:32:29,840
lot of sense for

00:32:15,279 --> 00:32:29,840
software anybody else wants to chime in

00:32:30,240 --> 00:32:36,480
uh sorry marcelo raised his hand

00:32:33,440 --> 00:32:39,039
hey jamal um as i

00:32:36,480 --> 00:32:40,159
was asking on the chat uh one question

00:32:39,039 --> 00:32:43,440
would be

00:32:40,159 --> 00:32:44,799
if this ppf object needs to be in sync

00:32:43,440 --> 00:32:47,440
with the hardware

00:32:44,799 --> 00:32:49,200
who would be distributing it but it

00:32:47,440 --> 00:32:51,200
would be distributed together with the

00:32:49,200 --> 00:32:53,679
driver with linux streamer

00:32:51,200 --> 00:32:55,279
or oh because they need to be maintained

00:32:53,679 --> 00:32:57,279
right

00:32:55,279 --> 00:32:59,360
that's always a problem with bpf right i

00:32:57,279 --> 00:33:00,000
mean uh it's not really part of upstream

00:32:59,360 --> 00:33:02,159
kernel

00:33:00,000 --> 00:33:03,279
it may be there may be a sample code in

00:33:02,159 --> 00:33:07,600
uh in

00:33:03,279 --> 00:33:11,440
uh tools testing or samples ppf

00:33:07,600 --> 00:33:13,679
but um

00:33:11,440 --> 00:33:15,279
that's why i like these simple things

00:33:13,679 --> 00:33:17,760
like this to be part of the kind of lab

00:33:15,279 --> 00:33:20,880
stream right so

00:33:17,760 --> 00:33:24,000
uh um i i don't know the answer to that

00:33:20,880 --> 00:33:25,519
to be honest

00:33:24,000 --> 00:33:27,440
but i think it's a generic problem it's

00:33:25,519 --> 00:33:30,640
not just uh this scenario but

00:33:27,440 --> 00:33:34,159
uh uh

00:33:30,640 --> 00:33:36,480
but possibly uh yeah but

00:33:34,159 --> 00:33:38,559
a bp efficient the thing in this case

00:33:36,480 --> 00:33:41,519
that we need to

00:33:38,559 --> 00:33:44,399
have it in sync with the nick and more

00:33:41,519 --> 00:33:46,080
specifically with the nick firmer

00:33:44,399 --> 00:33:48,399
so we need to know what the nick is

00:33:46,080 --> 00:33:49,279
capable so that we can use that specific

00:33:48,399 --> 00:33:52,799
bpf file

00:33:49,279 --> 00:33:56,399
with it it's harder dependent

00:33:52,799 --> 00:33:58,640
yeah right sorry guys yeah

00:33:56,399 --> 00:34:00,000
i believe so uh the same thing jamal

00:33:58,640 --> 00:34:01,919
that it is you know you have to know

00:34:00,000 --> 00:34:04,559
what is nick using for you to

00:34:01,919 --> 00:34:05,519
match it up in the bpf program there was

00:34:04,559 --> 00:34:07,679
one more question

00:34:05,519 --> 00:34:09,760
uh you know related to this which was

00:34:07,679 --> 00:34:12,000
about hash balancing

00:34:09,760 --> 00:34:12,879
so what i understood as the hash

00:34:12,000 --> 00:34:14,960
balancing

00:34:12,879 --> 00:34:16,000
uh you know it's more resilient hash

00:34:14,960 --> 00:34:18,879
balance that

00:34:16,000 --> 00:34:20,879
is being done but i couldn't uh gather

00:34:18,879 --> 00:34:24,560
if there was a way for

00:34:20,879 --> 00:34:27,040
uh you know the you know for from

00:34:24,560 --> 00:34:29,839
software to actually

00:34:27,040 --> 00:34:31,040
do the hash balancing themselves you

00:34:29,839 --> 00:34:34,480
know

00:34:31,040 --> 00:34:35,040
um through whatever uh scripts or

00:34:34,480 --> 00:34:37,040
whatever

00:34:35,040 --> 00:34:40,079
they want to use like like in each tool

00:34:37,040 --> 00:34:43,119
we do have the hash let's exposed

00:34:40,079 --> 00:34:44,240
uh i'm not sure that is the case here so

00:34:43,119 --> 00:34:46,480
you're talking about rss

00:34:44,240 --> 00:34:48,320
hashing in this case or yeah yeah rss

00:34:46,480 --> 00:34:50,720
hashing so i mean any hash

00:34:48,320 --> 00:34:51,520
will have their lookup table that you

00:34:50,720 --> 00:34:54,320
can

00:34:51,520 --> 00:34:55,839
the buckets that you could expose to

00:34:54,320 --> 00:34:58,480
balance either

00:34:55,839 --> 00:34:59,520
uh through the user space or you know

00:34:58,480 --> 00:35:02,320
you assume

00:34:59,520 --> 00:35:04,400
a balancing either in the driver or in

00:35:02,320 --> 00:35:06,400
the hardware so i couldn't gather if it

00:35:04,400 --> 00:35:08,320
was completely configurable or it was

00:35:06,400 --> 00:35:10,880
something

00:35:08,320 --> 00:35:11,520
that was not it sounded to me like

00:35:10,880 --> 00:35:13,040
there's

00:35:11,520 --> 00:35:14,640
multiple ways you can do hashing in the

00:35:13,040 --> 00:35:17,359
hardware right

00:35:14,640 --> 00:35:18,000
and you so whoever's sitting policy in

00:35:17,359 --> 00:35:20,160
software so

00:35:18,000 --> 00:35:21,200
here's my understanding right i like uh

00:35:20,160 --> 00:35:23,680
and

00:35:21,200 --> 00:35:25,760
i'm hoping that's how it works is

00:35:23,680 --> 00:35:26,640
somebody in user space will configure

00:35:25,760 --> 00:35:30,160
the hardware

00:35:26,640 --> 00:35:31,599
to do a hash and set the skb harsh so

00:35:30,160 --> 00:35:32,079
when it arrives in software in the

00:35:31,599 --> 00:35:33,760
kernel

00:35:32,079 --> 00:35:35,920
you already know what let's say one two

00:35:33,760 --> 00:35:38,640
three four means right

00:35:35,920 --> 00:35:40,160
right and then you can classify on one

00:35:38,640 --> 00:35:42,160
two three four and the approaches to

00:35:40,160 --> 00:35:45,280
classify using uh flower

00:35:42,160 --> 00:35:46,720
so you can see tc flower match hash one

00:35:45,280 --> 00:35:48,880
two three four

00:35:46,720 --> 00:35:49,760
run these extra actions in in in the

00:35:48,880 --> 00:35:52,240
camera

00:35:49,760 --> 00:35:53,520
but the hardware would have tagged that

00:35:52,240 --> 00:35:54,960
hash

00:35:53,520 --> 00:35:57,200
uh and you could control that and

00:35:54,960 --> 00:35:57,680
there's multiple ways that that hash

00:35:57,200 --> 00:36:00,480
would be

00:35:57,680 --> 00:36:02,079
created in the hardware and i think the

00:36:00,480 --> 00:36:04,640
attributes of how you download that

00:36:02,079 --> 00:36:06,160
is the example unfortunately provided

00:36:04,640 --> 00:36:07,599
was not very good it just said action

00:36:06,160 --> 00:36:08,640
hash he didn't say anything other

00:36:07,599 --> 00:36:11,680
parameters

00:36:08,640 --> 00:36:12,079
in addition to that yeah jamal my

00:36:11,680 --> 00:36:14,160
question

00:36:12,079 --> 00:36:15,520
was more related to you know once you

00:36:14,160 --> 00:36:18,640
have done that

00:36:15,520 --> 00:36:21,839
later on you want to do a rebalance

00:36:18,640 --> 00:36:25,200
and what do you do a rebalance yes

00:36:21,839 --> 00:36:27,839
and is the rebalance uh being done as a

00:36:25,200 --> 00:36:29,359
policy in the device or the driver or is

00:36:27,839 --> 00:36:32,560
it something exposed

00:36:29,359 --> 00:36:34,800
so uh so somebody could decide if if a

00:36:32,560 --> 00:36:37,280
new port is added or

00:36:34,800 --> 00:36:39,280
removed how do they want to balance that

00:36:37,280 --> 00:36:41,839
hash

00:36:39,280 --> 00:36:43,839
i don't know i wish one of is like four

00:36:41,839 --> 00:36:45,520
or five people involved in this work

00:36:43,839 --> 00:36:47,280
and none of them are here and they were

00:36:45,520 --> 00:36:49,599
all i mean i copy them on the agenda i

00:36:47,280 --> 00:36:53,200
think i may have missed somebody but

00:36:49,599 --> 00:36:54,560
um so i don't know the answer to that

00:36:53,200 --> 00:36:56,240
but it's a good question

00:36:54,560 --> 00:36:58,720
i think you would need to deal with that

00:36:56,240 --> 00:36:59,440
right yes you know that or you deal you

00:36:58,720 --> 00:37:03,680
know

00:36:59,440 --> 00:37:06,960
and you know uh or flows go away or

00:37:03,680 --> 00:37:08,400
you have infinite amount of buckets then

00:37:06,960 --> 00:37:10,640
then it's probably not a very big

00:37:08,400 --> 00:37:15,839
problem

00:37:10,640 --> 00:37:18,880
uh yeah okay thanks jamal i think yeah

00:37:15,839 --> 00:37:19,599
yeah so so i i i have been i did a poor

00:37:18,880 --> 00:37:21,760
job of

00:37:19,599 --> 00:37:22,800
managing the queue there's a question

00:37:21,760 --> 00:37:27,440
from

00:37:22,800 --> 00:37:29,920
marseille on on the chat is asking if

00:37:27,440 --> 00:37:32,000
but do we have do we know what

00:37:29,920 --> 00:37:36,000
performance hit

00:37:32,000 --> 00:37:38,800
evpf would have with the hashing

00:37:36,000 --> 00:37:39,440
i don't know the answer to that is any

00:37:38,800 --> 00:37:43,040
evp

00:37:39,440 --> 00:37:44,560
guru here i mean it this this ebpf will

00:37:43,040 --> 00:37:47,040
just be a phony

00:37:44,560 --> 00:37:49,200
uh hash algorithm software but in

00:37:47,040 --> 00:37:51,520
reality it's trying to be

00:37:49,200 --> 00:37:53,760
mimic what runs and saw in hardware so i

00:37:51,520 --> 00:37:56,640
think when somebody

00:37:53,760 --> 00:37:58,160
adds the tc rule that rule will probably

00:37:56,640 --> 00:38:00,160
have like skipped software and it will

00:37:58,160 --> 00:38:01,520
go to hardware although

00:38:00,160 --> 00:38:03,040
at least that's my understanding of it

00:38:01,520 --> 00:38:05,839
is anybody else has a different

00:38:03,040 --> 00:38:05,839
understanding of this

00:38:11,920 --> 00:38:17,200
yeah i also think that it is just maybe

00:38:14,560 --> 00:38:20,160
only one packet of a flow will match at

00:38:17,200 --> 00:38:21,040
ebpf cache program i think right the

00:38:20,160 --> 00:38:24,960
later packets

00:38:21,040 --> 00:38:26,800
will be offloaded to hardware

00:38:24,960 --> 00:38:28,320
okay so it goes the first packet goes to

00:38:26,800 --> 00:38:31,359
software and then that

00:38:28,320 --> 00:38:33,760
installs the policy in the hardware yeah

00:38:31,359 --> 00:38:36,640
set the hash in the skb and then the

00:38:33,760 --> 00:38:37,440
pc there is a filter rule that matches

00:38:36,640 --> 00:38:40,320
that hash

00:38:37,440 --> 00:38:42,320
and then offload it to hardware so that

00:38:40,320 --> 00:38:43,760
the later package will hit the hardware

00:38:42,320 --> 00:38:45,599
i think

00:38:43,760 --> 00:38:46,960
but doesn't that make it uh then you

00:38:45,599 --> 00:38:48,560
have to do puff floor then after that

00:38:46,960 --> 00:38:49,599
because you have to say this flow

00:38:48,560 --> 00:38:52,880
matches

00:38:49,599 --> 00:38:55,040
this skb hash right

00:38:52,880 --> 00:38:57,359
yeah that's what i thought that they had

00:38:55,040 --> 00:38:59,599
two filters right the first filter was

00:38:57,359 --> 00:39:02,000
setting the hash and the accent filter

00:38:59,599 --> 00:39:06,960
was matching on the hash

00:39:02,000 --> 00:39:10,960
and then redirecting okay

00:39:06,960 --> 00:39:14,800
uh taras raise your hand

00:39:10,960 --> 00:39:17,760
you you can go ahead please yes so i was

00:39:14,800 --> 00:39:18,640
wondering uh for example two different

00:39:17,760 --> 00:39:21,040
devices

00:39:18,640 --> 00:39:22,240
uh from two different vendors might have

00:39:21,040 --> 00:39:24,240
completely

00:39:22,240 --> 00:39:26,400
different hash even from the size

00:39:24,240 --> 00:39:29,680
perspective so like 16

00:39:26,400 --> 00:39:32,800
16 or 32 bits and

00:39:29,680 --> 00:39:35,680
uh keeping this keeping this in sync

00:39:32,800 --> 00:39:37,200
that software okay for ingress we can we

00:39:35,680 --> 00:39:38,480
can definitely know okay this one comes

00:39:37,200 --> 00:39:39,359
from that hardware we should do that

00:39:38,480 --> 00:39:42,400
hash

00:39:39,359 --> 00:39:44,320
but how to apply this for the egress

00:39:42,400 --> 00:39:46,560
for me it's completely unknown i don't

00:39:44,320 --> 00:39:48,160
see how we can easily

00:39:46,560 --> 00:39:50,880
match two different hashes with two

00:39:48,160 --> 00:39:50,880
different sizes

00:39:51,760 --> 00:39:58,880
right anybody wants to chime into that

00:39:56,480 --> 00:40:00,240
i mean yes these are attributes you have

00:39:58,880 --> 00:40:01,760
to know you have to know what

00:40:00,240 --> 00:40:04,400
when you specify a hash what does it

00:40:01,760 --> 00:40:07,040
mean what does which tuples it takes

00:40:04,400 --> 00:40:08,880
to create rss for example is well known

00:40:07,040 --> 00:40:10,800
even with rss

00:40:08,880 --> 00:40:13,119
you could uh still inject different

00:40:10,800 --> 00:40:15,520
seeds and have different results for rss

00:40:13,119 --> 00:40:17,040
as i think that's what angeli was

00:40:15,520 --> 00:40:18,960
hinting at

00:40:17,040 --> 00:40:20,079
you know if you put it's still the same

00:40:18,960 --> 00:40:21,920
five tuples but

00:40:20,079 --> 00:40:23,359
different you get different values if

00:40:21,920 --> 00:40:27,440
you use different seeds

00:40:23,359 --> 00:40:29,119
right and then is it i mean

00:40:27,440 --> 00:40:32,160
tricks like that where symmetry

00:40:29,119 --> 00:40:37,200
symmetric hashes are used to

00:40:32,160 --> 00:40:38,960
identify different directions so i i'm

00:40:37,200 --> 00:40:40,400
unfortunately there's nothing much we

00:40:38,960 --> 00:40:44,079
can do here so

00:40:40,400 --> 00:40:46,240
uh it's time-wise

00:40:44,079 --> 00:40:47,920
we still have about 10-15 minutes we can

00:40:46,240 --> 00:40:51,119
continue talking about it but

00:40:47,920 --> 00:40:52,880
i think it's uh so my concern was

00:40:51,119 --> 00:40:54,720
when these patches are posted maybe we

00:40:52,880 --> 00:40:58,640
should uh

00:40:54,720 --> 00:41:01,119
pivot to that question is uh

00:40:58,640 --> 00:41:03,280
they used flower for classifying a hash

00:41:01,119 --> 00:41:06,800
and i

00:41:03,280 --> 00:41:07,839
i raised the concern that um flower

00:41:06,800 --> 00:41:09,760
tends to be

00:41:07,839 --> 00:41:11,440
so if i now i have to add every other

00:41:09,760 --> 00:41:14,880
classifier i have to extend it

00:41:11,440 --> 00:41:16,000
and make it do have skb hash as part of

00:41:14,880 --> 00:41:19,680
its classification so i have to

00:41:16,000 --> 00:41:21,920
i'm using u32 i now have to extend u32

00:41:19,680 --> 00:41:24,160
i was kind of concerned about that and

00:41:21,920 --> 00:41:26,640
so i posted some patches as well

00:41:24,160 --> 00:41:27,200
to introduce a brand new classifier

00:41:26,640 --> 00:41:31,680
called

00:41:27,200 --> 00:41:31,680
skb hash or for a lack of a better name

00:41:32,640 --> 00:41:35,680
and i so that was one of the reasons i

00:41:34,880 --> 00:41:37,680
didn't want to go and

00:41:35,680 --> 00:41:41,200
change other classifiers i'm using i'm

00:41:37,680 --> 00:41:42,480
not a big use of flower for example

00:41:41,200 --> 00:41:44,319
and the other thing is i i don't think

00:41:42,480 --> 00:41:47,760
the performance

00:41:44,319 --> 00:41:49,119
uh would be the same because

00:41:47,760 --> 00:41:51,920
the passing in flower would be a little

00:41:49,119 --> 00:41:51,920
bit more expensive

00:41:57,200 --> 00:42:03,839
well nobody is uh should i start picking

00:42:00,560 --> 00:42:03,839
people to say something here

00:42:04,800 --> 00:42:08,640
paul do you say uh

00:42:09,200 --> 00:42:13,040
you probably need to separate separate

00:42:11,280 --> 00:42:14,880
secondary tables for the different size

00:42:13,040 --> 00:42:18,079
hashes

00:42:14,880 --> 00:42:20,720
in that in the example he was showing it

00:42:18,079 --> 00:42:22,800
he would have he is he used two tables

00:42:20,720 --> 00:42:25,760
the second table was the buckets

00:42:22,800 --> 00:42:27,040
so if you had used different size hashes

00:42:25,760 --> 00:42:29,280
you could just have

00:42:27,040 --> 00:42:31,440
set two different tables for that second

00:42:29,280 --> 00:42:33,920
step they'd all map to the same egress

00:42:31,440 --> 00:42:37,200
ports set of egress ports but

00:42:33,920 --> 00:42:40,160
that might be one approach um

00:42:37,200 --> 00:42:40,560
okay and you're going to have different

00:42:40,160 --> 00:42:42,640
the

00:42:40,560 --> 00:42:43,760
the that i'm assuming you're having

00:42:42,640 --> 00:42:45,520
different nics

00:42:43,760 --> 00:42:47,839
different input ports so you're actually

00:42:45,520 --> 00:42:49,200
your table definitions would kind of be

00:42:47,839 --> 00:42:52,400
purport i think anyway

00:42:49,200 --> 00:42:54,079
so the separate size hashes should

00:42:52,400 --> 00:42:56,240
shouldn't necessarily be a problem i

00:42:54,079 --> 00:42:56,240
think

00:42:57,680 --> 00:43:01,440
so that the separate hashes would uh

00:43:00,240 --> 00:43:02,800
what would be the impact is that a

00:43:01,440 --> 00:43:05,599
performance impact

00:43:02,800 --> 00:43:07,119
well you might not get a uh your load

00:43:05,599 --> 00:43:09,200
distribution might

00:43:07,119 --> 00:43:10,400
not be as consistent because you're you

00:43:09,200 --> 00:43:13,520
have different

00:43:10,400 --> 00:43:15,520
mechanisms for for load balancing

00:43:13,520 --> 00:43:16,880
uh particular five tuples but they

00:43:15,520 --> 00:43:18,880
should still always

00:43:16,880 --> 00:43:20,160
map to the same but you know to a buck

00:43:18,880 --> 00:43:21,920
to a consistent bucket

00:43:20,160 --> 00:43:24,319
so no matter what you won't have an out

00:43:21,920 --> 00:43:26,400
of order out of order problem

00:43:24,319 --> 00:43:28,079
you'll just may have different load

00:43:26,400 --> 00:43:30,000
distribution

00:43:28,079 --> 00:43:31,599
taking place i don't think it's

00:43:30,000 --> 00:43:33,760
necessarily a big problem

00:43:31,599 --> 00:43:35,200
that they have different size hashes

00:43:33,760 --> 00:43:37,839
seems like it's manageable in that

00:43:35,200 --> 00:43:37,839
architecture

00:43:38,960 --> 00:43:42,319
so anybody from other nick vendors who

00:43:40,960 --> 00:43:45,760
has

00:43:42,319 --> 00:43:48,079
anjali or jcsu there

00:43:45,760 --> 00:43:49,200
yeah jamal sorry i missed what was the

00:43:48,079 --> 00:43:51,280
question

00:43:49,200 --> 00:43:53,359
no i mean are you guys uh what do you

00:43:51,280 --> 00:43:56,160
guys think of this uh

00:43:53,359 --> 00:43:57,440
uh talk but specifically to your

00:43:56,160 --> 00:44:00,319
hardware basically

00:43:57,440 --> 00:44:01,920
right so so i mean definitely a good

00:44:00,319 --> 00:44:03,839
effort but i think

00:44:01,920 --> 00:44:05,040
uh there is more configuration that

00:44:03,839 --> 00:44:07,920
needs to be exposed

00:44:05,040 --> 00:44:08,880
um particularly as i messaged on the

00:44:07,920 --> 00:44:11,599
chat side

00:44:08,880 --> 00:44:14,160
you know the seed rebalancing policy or

00:44:11,599 --> 00:44:16,720
exposure to hash buckets for balancing

00:44:14,160 --> 00:44:18,560
and then the uh you know i would also

00:44:16,720 --> 00:44:19,359
like the algorithm to be in kernel

00:44:18,560 --> 00:44:22,480
instead of

00:44:19,359 --> 00:44:25,119
you know through bpf uh and and and uh

00:44:22,480 --> 00:44:26,560
yeah i mean performance uh you know

00:44:25,119 --> 00:44:30,160
depends on

00:44:26,560 --> 00:44:32,560
um yeah so i mean the way it is being

00:44:30,160 --> 00:44:35,200
done is like only the first packet

00:44:32,560 --> 00:44:37,200
uh is used in software and then uh you

00:44:35,200 --> 00:44:41,200
know the rest of it is in hardware

00:44:37,200 --> 00:44:43,839
which is fine uh and and uh maybe in

00:44:41,200 --> 00:44:45,839
with that respect you know u32 versus

00:44:43,839 --> 00:44:50,400
flower i i don't really know

00:44:45,839 --> 00:44:53,119
if uh there is um

00:44:50,400 --> 00:44:55,119
any benefit to have because of course

00:44:53,119 --> 00:44:57,760
once it's offloaded the performance is

00:44:55,119 --> 00:44:58,800
hardware performance so yeah but then i

00:44:57,760 --> 00:45:00,560
i would

00:44:58,800 --> 00:45:03,599
you know feel comfortable if we had a

00:45:00,560 --> 00:45:05,520
little bit more configuration available

00:45:03,599 --> 00:45:06,640
and brother i've just been informed that

00:45:05,520 --> 00:45:08,560
uh the reason

00:45:06,640 --> 00:45:10,319
this gentleman are probably not here is

00:45:08,560 --> 00:45:13,599
because it's a weekend

00:45:10,319 --> 00:45:16,000
in this trail right now so they can be

00:45:13,599 --> 00:45:16,000
excused

00:45:16,400 --> 00:45:19,839
so your hardware though intel hardware

00:45:19,200 --> 00:45:23,280
does

00:45:19,839 --> 00:45:26,079
would this be useful

00:45:23,280 --> 00:45:26,880
yes for sure which one because i have a

00:45:26,079 --> 00:45:30,640
lot of intel

00:45:26,880 --> 00:45:30,640
xdbe or i40e

00:45:30,800 --> 00:45:35,520
sorry i can't comment okay

00:45:33,920 --> 00:45:42,160
but you're probably gonna add this

00:45:35,520 --> 00:45:42,160

YouTube URL: https://www.youtube.com/watch?v=krTnLDpjPAo


