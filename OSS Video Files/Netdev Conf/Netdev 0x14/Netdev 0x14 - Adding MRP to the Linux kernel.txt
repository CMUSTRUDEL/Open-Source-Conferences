Title: Netdev 0x14 - Adding MRP to the Linux kernel
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speaker: Horatiu Vultur

More info: https://netdevconf.info/0x14/session.html?talk-adding-MRP-to-the-linux-kernel

Date: Friday, August 21, 2020

MRP(Media Redundancy Protocol) is an open standard for ring topologies
in industrial ethernet networks defined in common standards-based
protocol(IEC 62439-2). In an MRP-enabled network each Ethernet switch
is connected to two other switches forming a ring. An MRP-enabled ring
can overcome single link point of failures at worst case recovery time
of 30ms - which is faster than STP.

In this talk Horatiu Vultur will describe the MRP protocol in
some detail. He will then proceed to discuss the effort to add support
to the kernel; implementation approaches considered and path taken
after receiving feedback on the mailing list. And last but
not least future work including hardware offload of MRP
as well as preliminary results comparing hardware-offloaded MRP vs
non-offloaded version.
Captions: 
	00:00:03,040 --> 00:00:05,759
hi

00:00:03,439 --> 00:00:07,839
my name is uh horativ wolter i'm a

00:00:05,759 --> 00:00:09,679
software engineer at microchip

00:00:07,839 --> 00:00:12,080
and today i will present the media

00:00:09,679 --> 00:00:16,320
redundancy protocol

00:00:12,080 --> 00:00:18,400
first i want to say a disclaimer here

00:00:16,320 --> 00:00:20,800
we will present what we understand from

00:00:18,400 --> 00:00:21,920
the standard and we try to do it in the

00:00:20,800 --> 00:00:24,480
best way but

00:00:21,920 --> 00:00:25,439
we might be wrong in some parts so the

00:00:24,480 --> 00:00:27,439
best is to

00:00:25,439 --> 00:00:29,679
read the standard and look there for the

00:00:27,439 --> 00:00:33,200
information

00:00:29,679 --> 00:00:34,640
so first what is mrp mrp is media

00:00:33,200 --> 00:00:37,520
redundancy protocol

00:00:34,640 --> 00:00:38,559
it's a recovery protocol based on ring

00:00:37,520 --> 00:00:41,440
topology

00:00:38,559 --> 00:00:42,000
with fast recovery times of a single

00:00:41,440 --> 00:00:45,600
failure

00:00:42,000 --> 00:00:46,440
in the ring mrp is standardized by the

00:00:45,600 --> 00:00:50,000
international

00:00:46,440 --> 00:00:52,320
electronical commission um and it's

00:00:50,000 --> 00:00:55,760
primarily used in the industrial

00:00:52,320 --> 00:00:59,280
networks because it's cheaper to have a

00:00:55,760 --> 00:01:00,320
ring topology than to have a switch in a

00:00:59,280 --> 00:01:04,720
central location

00:01:00,320 --> 00:01:07,680
and aggregate all these other switches

00:01:04,720 --> 00:01:10,000
unfortunately this protocol cannot be

00:01:07,680 --> 00:01:11,040
implemented 100 percent in the user

00:01:10,000 --> 00:01:14,080
space

00:01:11,040 --> 00:01:15,600
and we need to do some changes in the

00:01:14,080 --> 00:01:18,080
kernels to have

00:01:15,600 --> 00:01:19,040
this because the kernel needs to

00:01:18,080 --> 00:01:22,159
understand these

00:01:19,040 --> 00:01:26,080
mrp frames and needs to

00:01:22,159 --> 00:01:28,080
process them it's not that easy to

00:01:26,080 --> 00:01:30,960
implement this because it has

00:01:28,080 --> 00:01:32,159
quite a few state machines the protocol

00:01:30,960 --> 00:01:36,000
and timers

00:01:32,159 --> 00:01:38,479
and the standard is not precise there

00:01:36,000 --> 00:01:41,280
are some mistakes in the standard

00:01:38,479 --> 00:01:41,680
so we had to interpret them the best as

00:01:41,280 --> 00:01:45,360
we

00:01:41,680 --> 00:01:49,200
can the current status of the mrp

00:01:45,360 --> 00:01:52,560
is we have mrm mrc mra accepted

00:01:49,200 --> 00:01:56,159
and we continue to add other features in

00:01:52,560 --> 00:01:59,680
so it's kind of like 50 60

00:01:56,159 --> 00:02:02,320
already upstream and what we want

00:01:59,680 --> 00:02:02,799
is for the community to continue to help

00:02:02,320 --> 00:02:05,520
us

00:02:02,799 --> 00:02:07,439
and guide us to add the rest of the

00:02:05,520 --> 00:02:10,560
features

00:02:07,439 --> 00:02:14,160
so in a ring

00:02:10,560 --> 00:02:17,280
we have if we look in the topic picture

00:02:14,160 --> 00:02:20,640
we have uh one mrm which stands for

00:02:17,280 --> 00:02:23,280
a manager and in a ring can be only one

00:02:20,640 --> 00:02:24,000
manager and there can be multiple

00:02:23,280 --> 00:02:27,440
clients

00:02:24,000 --> 00:02:31,280
which is mrc also in a ring can be

00:02:27,440 --> 00:02:34,480
a auto manager and this means

00:02:31,280 --> 00:02:38,000
this behaves as a manager or as a

00:02:34,480 --> 00:02:40,319
client it's a voting algorithm that

00:02:38,000 --> 00:02:42,080
goes between all these auto managers

00:02:40,319 --> 00:02:45,760
we'll talk about that

00:02:42,080 --> 00:02:49,519
a little bit later in the lower picture

00:02:45,760 --> 00:02:53,760
we see two rings where there are two

00:02:49,519 --> 00:02:56,800
mrm and one interconnect ring

00:02:53,760 --> 00:03:00,879
that is formed out of these four

00:02:56,800 --> 00:03:04,080
uh nodes and they have also

00:03:00,879 --> 00:03:06,959
roles and they are interconnect roles

00:03:04,080 --> 00:03:08,080
like interconnect manager and intercon

00:03:06,959 --> 00:03:11,440
interconnect

00:03:08,080 --> 00:03:15,040
client in the interconnect ring

00:03:11,440 --> 00:03:18,400
there are always four nodes

00:03:15,040 --> 00:03:21,440
uh one manager interconnect manager and

00:03:18,400 --> 00:03:24,080
three interconnect clients

00:03:21,440 --> 00:03:25,519
there are two modes for this

00:03:24,080 --> 00:03:28,799
interconnect ring to

00:03:25,519 --> 00:03:32,959
operate one is a

00:03:28,799 --> 00:03:35,440
link check mode where sending ccm frames

00:03:32,959 --> 00:03:36,799
and the other one is a ring check where

00:03:35,440 --> 00:03:39,599
it's sending these

00:03:36,799 --> 00:03:40,239
uh interconnect test frames again we

00:03:39,599 --> 00:03:43,280
will cover

00:03:40,239 --> 00:03:47,680
all this later on um

00:03:43,280 --> 00:03:52,080
now to present uh the pdus used by

00:03:47,680 --> 00:03:55,360
mrp they have their own

00:03:52,080 --> 00:03:56,720
videos first the destination mac it's a

00:03:55,360 --> 00:04:00,000
multicast address

00:03:56,720 --> 00:04:03,040
where the last byte depends on

00:04:00,000 --> 00:04:07,439
the mrp pdu

00:04:03,040 --> 00:04:10,879
type the source mark it's

00:04:07,439 --> 00:04:12,080
the mac of the port it has its own

00:04:10,879 --> 00:04:15,120
ethernet type

00:04:12,080 --> 00:04:18,639
and then the pdu is

00:04:15,120 --> 00:04:22,320
tlv based but it has a version

00:04:18,639 --> 00:04:24,800
that uh it's two bytes and

00:04:22,320 --> 00:04:26,880
it has version number one and then it's

00:04:24,800 --> 00:04:29,919
a tlv base where you can

00:04:26,880 --> 00:04:33,040
have the following tlvs

00:04:29,919 --> 00:04:36,080
like test topology link down link

00:04:33,040 --> 00:04:37,280
up and then it's followed by a common

00:04:36,080 --> 00:04:40,160
tlv

00:04:37,280 --> 00:04:41,520
and an optional tlv and it will finish

00:04:40,160 --> 00:04:45,199
with a

00:04:41,520 --> 00:04:48,479
and tlv it's important

00:04:45,199 --> 00:04:49,040
uh to remember that these frames they

00:04:48,479 --> 00:04:52,320
have a

00:04:49,040 --> 00:04:56,160
priority when i'm meant by a priority

00:04:52,320 --> 00:04:57,120
i mean by the field in in the in the

00:04:56,160 --> 00:05:00,160
frame and not the

00:04:57,120 --> 00:05:03,199
priority of the frame

00:05:00,160 --> 00:05:05,919
um yes now that we know

00:05:03,199 --> 00:05:06,720
the frames that are used by mrp and the

00:05:05,919 --> 00:05:10,080
roles

00:05:06,720 --> 00:05:13,440
we can talk a little bit who is doing

00:05:10,080 --> 00:05:16,960
what and for example uh

00:05:13,440 --> 00:05:20,400
mrm is generating the test frames

00:05:16,960 --> 00:05:23,680
and is sending on the ring port and

00:05:20,400 --> 00:05:25,600
is terminating those frames it's also

00:05:23,680 --> 00:05:29,759
generating topology

00:05:25,600 --> 00:05:33,680
reframes and terminates those it traps

00:05:29,759 --> 00:05:36,400
the link down link up frames

00:05:33,680 --> 00:05:38,560
and also it terminates those and

00:05:36,400 --> 00:05:40,479
optional frames we'll

00:05:38,560 --> 00:05:42,400
talk about those later on but it will

00:05:40,479 --> 00:05:44,960
terminate also those frames

00:05:42,400 --> 00:05:46,320
and then with mrc is just forwarding

00:05:44,960 --> 00:05:49,759
those frames

00:05:46,320 --> 00:05:51,360
and mra is listening and for the other

00:05:49,759 --> 00:05:53,840
frames

00:05:51,360 --> 00:05:54,560
if we look also at the colors this is

00:05:53,840 --> 00:05:57,919
what we

00:05:54,560 --> 00:06:01,919
propose in the kernel that

00:05:57,919 --> 00:06:02,880
mrm to generate these frames in the

00:06:01,919 --> 00:06:05,360
hardware

00:06:02,880 --> 00:06:06,400
because there are profiles where it

00:06:05,360 --> 00:06:09,759
needs to generate

00:06:06,400 --> 00:06:10,560
up to 4k frames per second and needs to

00:06:09,759 --> 00:06:12,800
process those

00:06:10,560 --> 00:06:15,840
frames so it will be much better if the

00:06:12,800 --> 00:06:15,840
hardware can do that

00:06:16,000 --> 00:06:23,120
then the cpu can do something else and

00:06:19,440 --> 00:06:26,720
it's taking all the work from the cpu

00:06:23,120 --> 00:06:29,680
what is with green we think we can be

00:06:26,720 --> 00:06:30,800
also offload to the hardware and but it

00:06:29,680 --> 00:06:34,160
cannot behave as

00:06:30,800 --> 00:06:35,120
a manager in this case because it needs

00:06:34,160 --> 00:06:38,560
a special

00:06:35,120 --> 00:06:41,680
it needs to generate these frames and

00:06:38,560 --> 00:06:46,080
what is with a yellow color we don't see

00:06:41,680 --> 00:06:48,880
any performance benefits by

00:06:46,080 --> 00:06:50,080
offloading this to the hardware because

00:06:48,880 --> 00:06:53,039
only few

00:06:50,080 --> 00:06:53,680
of these frames are sent out so there's

00:06:53,039 --> 00:06:56,639
no re

00:06:53,680 --> 00:06:56,639
no need for that

00:06:57,199 --> 00:07:04,880
here is just a next a simple example

00:07:01,520 --> 00:07:07,840
where we have one manager and two

00:07:04,880 --> 00:07:08,479
clients and if we look at the colors of

00:07:07,840 --> 00:07:11,840
the lines

00:07:08,479 --> 00:07:16,000
we the black one represents the internet

00:07:11,840 --> 00:07:19,360
the wire connection and the two color

00:07:16,000 --> 00:07:22,560
green and red represents the test flow

00:07:19,360 --> 00:07:25,520
frames so when the manager starts up

00:07:22,560 --> 00:07:26,080
it starts to send continuously test

00:07:25,520 --> 00:07:29,440
frames

00:07:26,080 --> 00:07:32,479
on both of the rings

00:07:29,440 --> 00:07:35,440
um eventually these

00:07:32,479 --> 00:07:37,199
frames will reach back to the manager

00:07:35,440 --> 00:07:39,280
because the client is just

00:07:37,199 --> 00:07:40,560
forwarding these frames and when the

00:07:39,280 --> 00:07:43,680
manager sees

00:07:40,560 --> 00:07:44,080
that that it receives its own frame then

00:07:43,680 --> 00:07:46,800
it will

00:07:44,080 --> 00:07:48,319
set one of the ports in a blocking state

00:07:46,800 --> 00:07:49,759
and the other one will set in the

00:07:48,319 --> 00:07:52,639
forwarding state

00:07:49,759 --> 00:07:54,720
meaning that no frames are going down on

00:07:52,639 --> 00:07:57,440
the block state

00:07:54,720 --> 00:07:58,319
and it will send also topology change

00:07:57,440 --> 00:08:01,680
frames

00:07:58,319 --> 00:08:02,720
so then every client it needs to process

00:08:01,680 --> 00:08:05,680
these frames and

00:08:02,720 --> 00:08:07,039
they will clear their uh ftb the

00:08:05,680 --> 00:08:08,960
forwarding database

00:08:07,039 --> 00:08:10,319
so then everyone in the network will

00:08:08,960 --> 00:08:13,360
have a clear

00:08:10,319 --> 00:08:15,599
or ftp

00:08:13,360 --> 00:08:18,160
but let's say then for example one of

00:08:15,599 --> 00:08:21,440
the one of the links between the clients

00:08:18,160 --> 00:08:22,240
goes down in this case then the test

00:08:21,440 --> 00:08:25,759
frames

00:08:22,240 --> 00:08:29,039
are not coming back to the manager and

00:08:25,759 --> 00:08:32,159
it will detect this and then

00:08:29,039 --> 00:08:32,560
it will set the port the block log port

00:08:32,159 --> 00:08:34,640
in

00:08:32,560 --> 00:08:35,839
forwarding state and it will send again

00:08:34,640 --> 00:08:39,120
topology

00:08:35,839 --> 00:08:42,240
change frames on both of the rings

00:08:39,120 --> 00:08:44,480
to notify again the clients that the

00:08:42,240 --> 00:08:48,560
topology is changed so they need to

00:08:44,480 --> 00:08:48,560
clear again their forwarding database

00:08:49,680 --> 00:08:53,680
let's talk now about auto manager

00:08:52,240 --> 00:08:55,839
because

00:08:53,680 --> 00:08:57,120
the case with a manager in case the

00:08:55,839 --> 00:08:59,920
manager

00:08:57,120 --> 00:09:01,839
dies or is removed then you need to

00:08:59,920 --> 00:09:04,880
configure a client for

00:09:01,839 --> 00:09:07,279
to behave as a manager but this

00:09:04,880 --> 00:09:09,839
auto manager they can automatically

00:09:07,279 --> 00:09:12,080
detect when to behave as a

00:09:09,839 --> 00:09:14,320
manager or a client so you can have a

00:09:12,080 --> 00:09:17,120
ring only with auto managers

00:09:14,320 --> 00:09:18,320
and then everything will work even that

00:09:17,120 --> 00:09:21,440
you remove

00:09:18,320 --> 00:09:25,040
a switch from the

00:09:21,440 --> 00:09:26,560
ring but before talking about the auto

00:09:25,040 --> 00:09:29,040
managers we

00:09:26,560 --> 00:09:30,640
need to present the frame types used by

00:09:29,040 --> 00:09:34,080
this

00:09:30,640 --> 00:09:37,760
it's similar with a ring but it has a

00:09:34,080 --> 00:09:40,080
sub tlv where there are two

00:09:37,760 --> 00:09:42,560
well there are multiple uh subtitles but

00:09:40,080 --> 00:09:47,440
the most important ones are the

00:09:42,560 --> 00:09:47,440
managing manager neck and propagate

00:09:48,399 --> 00:09:52,080
if we take again an example here we have

00:09:51,600 --> 00:09:55,600
uh

00:09:52,080 --> 00:09:58,320
two clients and two who auto managers

00:09:55,600 --> 00:09:59,519
and again when they start they behave as

00:09:58,320 --> 00:10:02,480
a manager

00:09:59,519 --> 00:10:03,279
and they start to send a ring test

00:10:02,480 --> 00:10:06,480
frames

00:10:03,279 --> 00:10:08,480
on both of the rings both on both of the

00:10:06,480 --> 00:10:10,320
ports

00:10:08,480 --> 00:10:11,680
eventually these frames will reach the

00:10:10,320 --> 00:10:15,600
other manager

00:10:11,680 --> 00:10:18,959
and here is the voting algor algorithm

00:10:15,600 --> 00:10:22,640
where if a manager sees

00:10:18,959 --> 00:10:25,279
the test frames from a different manager

00:10:22,640 --> 00:10:26,720
it will look at the priority of these

00:10:25,279 --> 00:10:29,519
frames

00:10:26,720 --> 00:10:30,160
by priority i mean the priority field in

00:10:29,519 --> 00:10:33,200
the

00:10:30,160 --> 00:10:34,399
ring test frame and you compare with its

00:10:33,200 --> 00:10:37,760
own priority

00:10:34,399 --> 00:10:40,800
if it's a smaller priority it will send

00:10:37,760 --> 00:10:41,920
this optional frame manager neck to tell

00:10:40,800 --> 00:10:45,440
the other

00:10:41,920 --> 00:10:49,519
manager to stop sending frames

00:10:45,440 --> 00:10:53,519
and behave as a client

00:10:49,519 --> 00:10:53,519
and in that case when the other

00:10:53,760 --> 00:10:59,680
auto manager receive this frame it will

00:10:57,279 --> 00:11:01,920
like i said it will stop sending frames

00:10:59,680 --> 00:11:05,200
and allow all the test frames to

00:11:01,920 --> 00:11:08,320
to get uh true and in this case

00:11:05,200 --> 00:11:09,040
again the test frames will come back to

00:11:08,320 --> 00:11:11,120
the

00:11:09,040 --> 00:11:12,640
manager and you set the port in a

00:11:11,120 --> 00:11:15,839
blocking state and

00:11:12,640 --> 00:11:19,440
it's similar as before

00:11:15,839 --> 00:11:23,120
but in case that the

00:11:19,440 --> 00:11:23,760
the manager is removed from the network

00:11:23,120 --> 00:11:26,880
or

00:11:23,760 --> 00:11:29,680
the mrp instance is deleted

00:11:26,880 --> 00:11:30,959
then there are no more frames no no more

00:11:29,680 --> 00:11:34,399
test frames

00:11:30,959 --> 00:11:36,880
in the network so then the the

00:11:34,399 --> 00:11:37,760
main auto manager that behaves as a

00:11:36,880 --> 00:11:40,240
client

00:11:37,760 --> 00:11:40,959
it will detect this and it will start to

00:11:40,240 --> 00:11:44,720
send

00:11:40,959 --> 00:11:48,959
test frames by itself and in this case

00:11:44,720 --> 00:11:51,760
this will come back to the

00:11:48,959 --> 00:11:53,200
auto manager because there is no other

00:11:51,760 --> 00:11:56,480
auto manager in the

00:11:53,200 --> 00:11:59,600
in the ring and it will detect

00:11:56,480 --> 00:12:03,440
any links down and it will do all these

00:11:59,600 --> 00:12:07,760
recovery times um

00:12:03,440 --> 00:12:11,360
the last uh main feature it's uh

00:12:07,760 --> 00:12:13,519
you can you can connect multiple rings

00:12:11,360 --> 00:12:14,720
because usually in the ring the standard

00:12:13,519 --> 00:12:18,000
suggests that you should have

00:12:14,720 --> 00:12:20,320
up to 50 nodes but

00:12:18,000 --> 00:12:21,519
if you have i don't know let's say

00:12:20,320 --> 00:12:24,000
hundreds of

00:12:21,519 --> 00:12:25,680
nodes you can make smaller rings and

00:12:24,000 --> 00:12:29,040
then you can just connect these

00:12:25,680 --> 00:12:32,800
rings and this

00:12:29,040 --> 00:12:36,720
interconnect rings is just connecting

00:12:32,800 --> 00:12:39,680
multiple rings um again if we are

00:12:36,720 --> 00:12:40,880
looking at the frames used by

00:12:39,680 --> 00:12:44,880
interconnect rings

00:12:40,880 --> 00:12:48,639
they are similar with the

00:12:44,880 --> 00:12:52,079
ring with the videos used in the ring

00:12:48,639 --> 00:12:57,120
only they have a different tlvs

00:12:52,079 --> 00:12:57,120
types and yeah it's pretty similar

00:12:58,160 --> 00:13:02,880
if we talk about again about who is

00:13:01,519 --> 00:13:06,880
doing what

00:13:02,880 --> 00:13:09,519
it's similar with the rings only that

00:13:06,880 --> 00:13:10,880
in this case also the ring manager and

00:13:09,519 --> 00:13:14,959
the ring client will

00:13:10,880 --> 00:13:15,440
see these frames and the ring manager we

00:13:14,959 --> 00:13:18,240
will

00:13:15,440 --> 00:13:19,360
terminate these frames or forward it

00:13:18,240 --> 00:13:23,120
depends on some

00:13:19,360 --> 00:13:26,560
states in the state machines and

00:13:23,120 --> 00:13:27,040
uh the ring client it will just forward

00:13:26,560 --> 00:13:31,120
these

00:13:27,040 --> 00:13:34,240
frames and again we propose some

00:13:31,120 --> 00:13:37,519
parts to be done by the hardware

00:13:34,240 --> 00:13:39,440
like generating and terminating the

00:13:37,519 --> 00:13:42,720
interconnect test frames

00:13:39,440 --> 00:13:45,680
and terminating the

00:13:42,720 --> 00:13:46,720
again the test frames interconnected

00:13:45,680 --> 00:13:50,880
frames by the

00:13:46,720 --> 00:13:54,480
ring manager everything else can be

00:13:50,880 --> 00:13:56,240
again pushed in the hardware to do all

00:13:54,480 --> 00:13:57,440
this forwarding and termination of the

00:13:56,240 --> 00:14:00,160
frames

00:13:57,440 --> 00:14:01,279
and it doesn't need any special hardware

00:14:00,160 --> 00:14:04,639
for this

00:14:01,279 --> 00:14:05,839
and the gener the frames are generated

00:14:04,639 --> 00:14:08,639
in the software because

00:14:05,839 --> 00:14:11,519
again there are not many frames and it's

00:14:08,639 --> 00:14:11,519
fine to do that

00:14:12,240 --> 00:14:17,120
there are two ways as i mentioned before

00:14:15,600 --> 00:14:20,160
to

00:14:17,120 --> 00:14:23,680
operate for these interconnected links

00:14:20,160 --> 00:14:24,639
in interconnect rings first mode is link

00:14:23,680 --> 00:14:28,880
check

00:14:24,639 --> 00:14:31,519
where each of the

00:14:28,880 --> 00:14:32,560
mic uh interconnect clients and

00:14:31,519 --> 00:14:35,680
interconnect

00:14:32,560 --> 00:14:39,279
uh manager he will start to send

00:14:35,680 --> 00:14:42,399
ccm frames on the interconnect port

00:14:39,279 --> 00:14:42,959
and when the manage interconnect manager

00:14:42,399 --> 00:14:46,160
sees

00:14:42,959 --> 00:14:47,120
that it has a link it will send the

00:14:46,160 --> 00:14:49,680
frame

00:14:47,120 --> 00:14:50,560
interconnect state to spall to the

00:14:49,680 --> 00:14:52,800
client

00:14:50,560 --> 00:14:53,680
to see the status of the interconnect

00:14:52,800 --> 00:14:56,560
link

00:14:53,680 --> 00:14:57,519
and in case that one it's up it will set

00:14:56,560 --> 00:15:00,959
its own port

00:14:57,519 --> 00:15:02,639
in the blocking state and then it will

00:15:00,959 --> 00:15:06,959
just continue to send these

00:15:02,639 --> 00:15:09,040
ccm frames but if the

00:15:06,959 --> 00:15:10,959
the link between the interconnect

00:15:09,040 --> 00:15:13,279
clients is going down

00:15:10,959 --> 00:15:15,040
the clients will send interconnect link

00:15:13,279 --> 00:15:18,079
change frames

00:15:15,040 --> 00:15:20,959
and eventually these ones will

00:15:18,079 --> 00:15:23,839
reach the interconnect manager for

00:15:20,959 --> 00:15:27,199
example if we follow the

00:15:23,839 --> 00:15:31,279
the orange dark orange line

00:15:27,199 --> 00:15:33,839
we can see how they are sent in the

00:15:31,279 --> 00:15:35,839
in the rings and we can see also that

00:15:33,839 --> 00:15:37,839
the manager is uh

00:15:35,839 --> 00:15:41,519
stopping this is not forwarding these

00:15:37,839 --> 00:15:45,600
frames because otherwise there will be

00:15:41,519 --> 00:15:47,519
a ring and then when

00:15:45,600 --> 00:15:48,959
the interconnect manager receives this

00:15:47,519 --> 00:15:52,480
frame it will set

00:15:48,959 --> 00:15:56,800
the port in a forwarding state it will

00:15:52,480 --> 00:16:00,000
send interconnect topology change frames

00:15:56,800 --> 00:16:03,199
on all the ports and

00:16:00,000 --> 00:16:06,560
eventually these ones will reach the

00:16:03,199 --> 00:16:09,040
ring manager and the ring manager

00:16:06,560 --> 00:16:10,480
will process these frames and you will

00:16:09,040 --> 00:16:13,680
need to send

00:16:10,480 --> 00:16:17,279
topology change range frames

00:16:13,680 --> 00:16:19,839
so then everyone in the in both rings

00:16:17,279 --> 00:16:23,839
will clear their folding database at the

00:16:19,839 --> 00:16:23,839
same time

00:16:23,920 --> 00:16:30,560
the other mode is a ring check

00:16:27,360 --> 00:16:33,040
and it's similar with a ring

00:16:30,560 --> 00:16:34,480
where the interconnect manager is

00:16:33,040 --> 00:16:39,120
sending this

00:16:34,480 --> 00:16:41,920
interconnect test frames on all ports

00:16:39,120 --> 00:16:42,800
and again if you look at the at the

00:16:41,920 --> 00:16:45,279
lines

00:16:42,800 --> 00:16:47,040
you see how they are forward and where

00:16:45,279 --> 00:16:49,759
they are terminated

00:16:47,040 --> 00:16:51,920
and if you follow for example again the

00:16:49,759 --> 00:16:55,839
orange line

00:16:51,920 --> 00:16:58,800
then the frames sent on that line

00:16:55,839 --> 00:17:00,320
it will come back to the the manager

00:16:58,800 --> 00:17:03,040
interconnect manager and

00:17:00,320 --> 00:17:04,160
we'll see that okay the the interconnect

00:17:03,040 --> 00:17:07,039
ring is

00:17:04,160 --> 00:17:08,160
closed so we'll set again the the

00:17:07,039 --> 00:17:11,760
interconnect port in

00:17:08,160 --> 00:17:14,480
block state then again

00:17:11,760 --> 00:17:16,000
if the link is going down between the

00:17:14,480 --> 00:17:17,919
interconnect clients

00:17:16,000 --> 00:17:19,280
it will stop receiving the interconnect

00:17:17,919 --> 00:17:22,160
test frames

00:17:19,280 --> 00:17:24,079
it will send the interconnect topology

00:17:22,160 --> 00:17:27,280
you change frames they will reach the

00:17:24,079 --> 00:17:30,960
mrm and mrm will send the

00:17:27,280 --> 00:17:34,160
topology change frames um

00:17:30,960 --> 00:17:37,280
one advantage of the

00:17:34,160 --> 00:17:38,240
lc mode over the rc mode is there are

00:17:37,280 --> 00:17:41,840
fewer uh

00:17:38,240 --> 00:17:44,960
frames in the in the rings because

00:17:41,840 --> 00:17:47,039
as you see in the previous slides all

00:17:44,960 --> 00:17:48,480
these interconnect test frames are going

00:17:47,039 --> 00:17:50,960
also in the rings

00:17:48,480 --> 00:17:51,919
and in those rings also the mrp test

00:17:50,960 --> 00:17:55,039
frames are

00:17:51,919 --> 00:18:01,120
are flowing so it's fewer frames

00:17:55,039 --> 00:18:01,120
for the lc mode and it's less processing

00:18:03,280 --> 00:18:10,080
and the last feature of the

00:18:07,200 --> 00:18:10,960
standard is that you can have at the

00:18:10,080 --> 00:18:14,160
same time

00:18:10,960 --> 00:18:17,679
multiple mrp instances of

00:18:14,160 --> 00:18:20,960
on a switch for example if a switch has

00:18:17,679 --> 00:18:23,360
four four ports you can have

00:18:20,960 --> 00:18:24,080
two instances because each instance

00:18:23,360 --> 00:18:27,600
needs

00:18:24,080 --> 00:18:31,120
two ports and because of this

00:18:27,600 --> 00:18:34,160
feature we could not use the mdb

00:18:31,120 --> 00:18:36,640
from the from the bridge to do all these

00:18:34,160 --> 00:18:38,080
forwarding so we had to implement our

00:18:36,640 --> 00:18:41,039
own

00:18:38,080 --> 00:18:41,039
forwarding scheme

00:18:41,520 --> 00:18:48,799
yep and if we talk a little bit about

00:18:45,120 --> 00:18:51,919
uh implementation um

00:18:48,799 --> 00:18:54,720
when we have sent the first patch

00:18:51,919 --> 00:18:55,360
we got really good comments saying that

00:18:54,720 --> 00:18:58,160
we try

00:18:55,360 --> 00:18:58,640
well we try to put everything in the

00:18:58,160 --> 00:19:01,840
kernel

00:18:58,640 --> 00:19:02,720
initially the mrp state machine and all

00:19:01,840 --> 00:19:05,919
the timers

00:19:02,720 --> 00:19:08,160
and uh generating all those frames but

00:19:05,919 --> 00:19:09,679
we were supposed we were told not to do

00:19:08,160 --> 00:19:12,080
that and then we

00:19:09,679 --> 00:19:13,200
try to move in the user space as much as

00:19:12,080 --> 00:19:16,799
possible

00:19:13,200 --> 00:19:20,720
and we have all these state machines and

00:19:16,799 --> 00:19:23,840
we generate all these topology

00:19:20,720 --> 00:19:25,600
and link change frames in the user space

00:19:23,840 --> 00:19:29,200
and all these timers

00:19:25,600 --> 00:19:32,240
there is a link to this user space

00:19:29,200 --> 00:19:33,520
and then in the kernel we try to do only

00:19:32,240 --> 00:19:36,720
what is

00:19:33,520 --> 00:19:37,760
essential and time sensitive for example

00:19:36,720 --> 00:19:39,840
generating the

00:19:37,760 --> 00:19:40,799
the test frames and interconnect test

00:19:39,840 --> 00:19:43,120
frames

00:19:40,799 --> 00:19:44,160
and detect when we stop receiving these

00:19:43,120 --> 00:19:48,000
frames and

00:19:44,160 --> 00:19:52,320
forward all these frames on the correct

00:19:48,000 --> 00:19:55,440
ports the implementation can be found in

00:19:52,320 --> 00:19:56,799
in that file vr underscore mrp and there

00:19:55,440 --> 00:20:00,080
are a few other

00:19:56,799 --> 00:20:04,000
mrp files there for net link processing

00:20:00,080 --> 00:20:08,640
and for switch dev support

00:20:04,000 --> 00:20:11,760
sorry um yes and if we

00:20:08,640 --> 00:20:15,760
look from a a switch perspective we

00:20:11,760 --> 00:20:17,039
see three cases a switch that doesn't

00:20:15,760 --> 00:20:20,080
have any

00:20:17,039 --> 00:20:21,840
uh offload it cannot be

00:20:20,080 --> 00:20:23,840
it cannot offload anything to the

00:20:21,840 --> 00:20:27,360
hardware so it's a pure software

00:20:23,840 --> 00:20:30,720
then everything is done in the software

00:20:27,360 --> 00:20:33,200
the general generating the frames

00:20:30,720 --> 00:20:35,280
detecting when these frames are stopped

00:20:33,200 --> 00:20:36,720
receiving and all the forwarding is done

00:20:35,280 --> 00:20:40,159
in the software

00:20:36,720 --> 00:20:41,840
then uh it's uh bridge uh

00:20:40,159 --> 00:20:43,360
switches that have a for example a

00:20:41,840 --> 00:20:47,120
switch dev driver

00:20:43,360 --> 00:20:50,799
and but they are not mrp aware

00:20:47,120 --> 00:20:54,640
meaning that they cannot generate these

00:20:50,799 --> 00:20:58,000
test frames but these

00:20:54,640 --> 00:20:59,120
switches they can behave as mrc if they

00:20:58,000 --> 00:21:03,120
can trap

00:20:59,120 --> 00:21:06,159
the frames the mrp frames

00:21:03,120 --> 00:21:09,760
and the last is

00:21:06,159 --> 00:21:13,120
uh switches that that can generate

00:21:09,760 --> 00:21:13,919
the the test the test frames and detect

00:21:13,120 --> 00:21:15,679
this

00:21:13,919 --> 00:21:17,360
and currently i don't think there are

00:21:15,679 --> 00:21:21,440
any switches

00:21:17,360 --> 00:21:24,640
but we are working on on adding those

00:21:21,440 --> 00:21:27,520
um as i said the

00:21:24,640 --> 00:21:28,799
the standard says that it has fast

00:21:27,520 --> 00:21:31,919
recovery times

00:21:28,799 --> 00:21:35,120
and there are different profiles for

00:21:31,919 --> 00:21:36,320
this how fast you want to recover for

00:21:35,120 --> 00:21:40,000
example it can

00:21:36,320 --> 00:21:43,039
recover up to 500 milliseconds

00:21:40,000 --> 00:21:46,400
but for that it needs to send test

00:21:43,039 --> 00:21:49,760
frames every 50 milliseconds

00:21:46,400 --> 00:21:51,919
and but it can also recover up to

00:21:49,760 --> 00:21:53,280
10 milliseconds and in that case it

00:21:51,919 --> 00:21:56,320
needs to send

00:21:53,280 --> 00:21:57,600
test frames for example every 500

00:21:56,320 --> 00:22:01,679
microseconds

00:21:57,600 --> 00:22:06,480
so we really think this this should be

00:22:01,679 --> 00:22:06,480
offload to the hardware and

00:22:07,280 --> 00:22:13,440
ah sorry this

00:22:11,120 --> 00:22:14,880
profile it's for the interconnect ring

00:22:13,440 --> 00:22:18,320
it's

00:22:14,880 --> 00:22:21,360
not requiring so much uh

00:22:18,320 --> 00:22:24,000
work from the software point of view but

00:22:21,360 --> 00:22:26,720
still it would be nice to generate the

00:22:24,000 --> 00:22:30,720
test frames in the

00:22:26,720 --> 00:22:34,320
in the hardware uh the future work

00:22:30,720 --> 00:22:37,440
we are trying to upstream now the

00:22:34,320 --> 00:22:39,360
mim and mic support we are trying

00:22:37,440 --> 00:22:41,200
actually we are trying to do the ring

00:22:39,360 --> 00:22:43,679
check mode

00:22:41,200 --> 00:22:44,320
and we have sent some patches and we got

00:22:43,679 --> 00:22:47,679
some good

00:22:44,320 --> 00:22:50,159
comments we are working on this to

00:22:47,679 --> 00:22:52,400
fix all these issues that other people

00:22:50,159 --> 00:22:52,400
found

00:22:52,840 --> 00:22:57,600
and if you have any questions

00:22:58,559 --> 00:23:01,520
that's it thank you

00:23:03,440 --> 00:23:07,919
that was a good talk martin uh so

00:23:06,640 --> 00:23:09,679
there's a couple of questions but i'm

00:23:07,919 --> 00:23:10,799
actually going to ask one of my own and

00:23:09,679 --> 00:23:14,480
sort of lead the

00:23:10,799 --> 00:23:16,960
discussion that way first which is um

00:23:14,480 --> 00:23:18,960
so i mean a lot of the characteristics

00:23:16,960 --> 00:23:22,240
of what you're talking about is what stp

00:23:18,960 --> 00:23:23,520
and dvds do right so so and maybe you

00:23:22,240 --> 00:23:24,880
explained it and i didn't quite

00:23:23,520 --> 00:23:28,799
understand it

00:23:24,880 --> 00:23:30,559
why invent a new technology clearly the

00:23:28,799 --> 00:23:32,720
the one difference is that if you had

00:23:30,559 --> 00:23:33,440
two parallel links stp would hold one of

00:23:32,720 --> 00:23:36,720
them down

00:23:33,440 --> 00:23:39,039
which you are avoiding but is that the

00:23:36,720 --> 00:23:42,080
only reason to go invent

00:23:39,039 --> 00:23:45,279
a brand new protocol it's

00:23:42,080 --> 00:23:49,120
also because it's detecting the

00:23:45,279 --> 00:23:53,120
the failure of the order of the rings

00:23:49,120 --> 00:23:55,919
or the yeah of the links in much faster

00:23:53,120 --> 00:23:58,400
time for example as you've seen in these

00:23:55,919 --> 00:24:01,919
profiles it can detect a

00:23:58,400 --> 00:24:05,120
failure in 10 milliseconds and

00:24:01,919 --> 00:24:08,320
in stp it's higher

00:24:05,120 --> 00:24:10,480
i don't know exactly no no but that's uh

00:24:08,320 --> 00:24:12,320
that's not fundamental to the stp design

00:24:10,480 --> 00:24:16,240
right like i mean that

00:24:12,320 --> 00:24:18,159
so the two questions right stp has been

00:24:16,240 --> 00:24:19,360
like has taken years and there are

00:24:18,159 --> 00:24:22,799
enough people here from

00:24:19,360 --> 00:24:24,720
cisco etc there can tell you of of uh

00:24:22,799 --> 00:24:26,080
decades of experience to get it to a

00:24:24,720 --> 00:24:27,919
stable reliable

00:24:26,080 --> 00:24:29,840
spot and it's still a pretty fragile

00:24:27,919 --> 00:24:31,120
environment and layer two technologies

00:24:29,840 --> 00:24:34,880
tend to be

00:24:31,120 --> 00:24:36,880
uh so the question is twofold one is

00:24:34,880 --> 00:24:38,320
was there something fundamental in stp

00:24:36,880 --> 00:24:39,520
that required a new protocol to be

00:24:38,320 --> 00:24:42,000
invented and the second

00:24:39,520 --> 00:24:44,480
is even if there was was there an

00:24:42,000 --> 00:24:46,159
attempt to at least use things like vpdu

00:24:44,480 --> 00:24:47,679
formats in a meaningful way because

00:24:46,159 --> 00:24:50,640
a lot of the signals that you have

00:24:47,679 --> 00:24:52,720
priority identification by mac

00:24:50,640 --> 00:24:54,480
any layer 2 protocol needs it so

00:24:52,720 --> 00:24:56,400
creating yet another one

00:24:54,480 --> 00:24:59,919
and thus adding code to the kernel and

00:24:56,400 --> 00:25:01,279
adding another l2 implementation seems

00:24:59,919 --> 00:25:03,360
could be better

00:25:01,279 --> 00:25:05,360
and maybe it's too you know it's a

00:25:03,360 --> 00:25:08,159
standard already who knows

00:25:05,360 --> 00:25:10,159
so uh well i'm i'm not working with the

00:25:08,159 --> 00:25:14,240
standard so

00:25:10,159 --> 00:25:18,000
there was already i just implemented the

00:25:14,240 --> 00:25:22,080
standard so i i don't know exactly

00:25:18,000 --> 00:25:22,080
and um

00:25:24,000 --> 00:25:30,960
yeah let's and the standard is not the

00:25:27,120 --> 00:25:33,360
like i mentioned it's not really clear

00:25:30,960 --> 00:25:35,440
um there are some mistakes in the

00:25:33,360 --> 00:25:38,720
standard and

00:25:35,440 --> 00:25:41,200
cases are missing so

00:25:38,720 --> 00:25:42,880
so so maybe the question that i should

00:25:41,200 --> 00:25:43,679
ask is the reverse which is what's the

00:25:42,880 --> 00:25:46,080
use

00:25:43,679 --> 00:25:47,760
i mean yes the redundancy or sorry the

00:25:46,080 --> 00:25:50,720
reaction time is

00:25:47,760 --> 00:25:52,640
the use case but did did you guys try

00:25:50,720 --> 00:25:54,799
with stp to get the reaction time by

00:25:52,640 --> 00:25:57,200
tuning the timers by tuning the

00:25:54,799 --> 00:25:58,400
the reaction loop or or seeing if that

00:25:57,200 --> 00:26:01,679
could fix it

00:25:58,400 --> 00:26:02,960
what drove to mrp being for you guys the

00:26:01,679 --> 00:26:05,279
feature that you needed with the

00:26:02,960 --> 00:26:07,600
standard that you needed

00:26:05,279 --> 00:26:08,640
uh from what i understand the the

00:26:07,600 --> 00:26:13,200
actually the clients

00:26:08,640 --> 00:26:13,200
are are they want to use this

00:26:14,159 --> 00:26:18,559
okay that's a fair answer so this is

00:26:16,640 --> 00:26:22,000
deployed basically

00:26:18,559 --> 00:26:25,279
yeah yeah okay okay

00:26:22,000 --> 00:26:26,400
okay so next question uh which you

00:26:25,279 --> 00:26:29,760
answered already but

00:26:26,400 --> 00:26:32,000
uh what is the redundancy use case for

00:26:29,760 --> 00:26:33,760
connected rings how does it differ from

00:26:32,000 --> 00:26:36,960
one big ring

00:26:33,760 --> 00:26:37,840
so from my basic understanding that each

00:26:36,960 --> 00:26:41,039
node

00:26:37,840 --> 00:26:44,240
in if you have a let's say a ring with

00:26:41,039 --> 00:26:47,760
100 nodes then each node will

00:26:44,240 --> 00:26:51,200
introduce a a small delay

00:26:47,760 --> 00:26:51,760
when it's folding the frame so it will

00:26:51,200 --> 00:26:56,799
be

00:26:51,760 --> 00:27:00,000
harder to reach these low profiles

00:26:56,799 --> 00:27:03,440
and then it's easier to have a

00:27:00,000 --> 00:27:06,480
smaller rings and just connect them

00:27:03,440 --> 00:27:07,120
with interconnect rings because the ring

00:27:06,480 --> 00:27:10,400
test

00:27:07,120 --> 00:27:14,159
from one ring they are not going

00:27:10,400 --> 00:27:17,200
to the other uh ring

00:27:14,159 --> 00:27:19,440
so those ring tests are not passing

00:27:17,200 --> 00:27:23,200
through the interconnect

00:27:19,440 --> 00:27:25,840
ring that's

00:27:23,200 --> 00:27:25,840
how i see it

00:27:26,640 --> 00:27:31,120
excellent stansler does that answer your

00:27:32,840 --> 00:27:36,720
question

00:27:35,039 --> 00:27:39,200
although i wonder about the use cases

00:27:36,720 --> 00:27:41,279
when somebody has a hundred

00:27:39,200 --> 00:27:43,919
redundant machines your client is very

00:27:41,279 --> 00:27:46,880
rich i imagine

00:27:43,919 --> 00:27:48,399
sorry i i didn't uh here i mean your

00:27:46,880 --> 00:27:52,000
clients must be wealthy if they

00:27:48,399 --> 00:27:55,840
have so many redundant machines

00:27:52,000 --> 00:27:56,240
i hope so well i i'm suspecting that

00:27:55,840 --> 00:27:58,159
this

00:27:56,240 --> 00:28:00,080
use case is like some industrial

00:27:58,159 --> 00:28:01,200
controller or something else right it's

00:28:00,080 --> 00:28:04,399
it's probably

00:28:01,200 --> 00:28:07,279
some very different from a

00:28:04,399 --> 00:28:08,960
server system kind of design that's my

00:28:07,279 --> 00:28:12,320
expectation

00:28:08,960 --> 00:28:14,000
but i could be wrong um

00:28:12,320 --> 00:28:16,000
okay do we have anything else i'm

00:28:14,000 --> 00:28:19,279
surprised jamal no questions from you

00:28:16,000 --> 00:28:19,279
he did say the word bridge

00:28:19,520 --> 00:28:22,960
i was just laughing there that was a at

00:28:21,919 --> 00:28:25,279
the comment

00:28:22,960 --> 00:28:26,559
yeah that's my contribution to this

00:28:25,279 --> 00:28:29,600
let's see

00:28:26,559 --> 00:28:34,399
uh well okay in that case i understand

00:28:29,600 --> 00:28:34,399

YouTube URL: https://www.youtube.com/watch?v=R3vQYfwiJ2M


