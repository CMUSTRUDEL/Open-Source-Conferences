Title: Netdev 0x14 - Tutorial: Programming QUIC using Isquic
Publication date: 2020-10-18
Playlist: Netdev 0x14
Description: 
	Instructors: Dmitri Tikhonov

More info: https://netdevconf.info/0x14-staging/session.html?tutorial-programming-QUIC-using-lsquic

Date: Friday, August 14, 2020

So you've heard of this new shiny transport called QUIC. You've
even been to several presentations on QUIC in 0x12 and 0x13. And you
are wondering how to write applications that run using QUIC
transport. Or ... maybe you happen to know that if you pulled apart the
Chromium tree, perform some tooling kungfu you could get QUIC infra
sufficient for you to write a client or a server...

Dmitri Tikhonov has a better idea. In this session he will
be giving a tutorial on how to write applications on top of
HTTP/3 QUIC based on the lsquic library.
The tutorial will start with a (very) short QUIC and HTTP/3
basics introduction followed by delving into the innards of
the lsquic library and leading to interactive coding of simple
echo server and client programs.
And more..
All the demoed code will be made available on github.
Captions: 
	00:00:03,919 --> 00:00:07,919
hello

00:00:04,799 --> 00:00:09,679
my name is dmitrii tikhonov and the

00:00:07,919 --> 00:00:12,240
topic of today's presentation is

00:00:09,679 --> 00:00:15,599
programming ls quick

00:00:12,240 --> 00:00:17,520
ls quick stands for light speed quick

00:00:15,599 --> 00:00:20,000
quick lsquik is an open source quick

00:00:17,520 --> 00:00:21,520
library and quick is a new general

00:00:20,000 --> 00:00:22,880
purpose transport protocol for the

00:00:21,520 --> 00:00:24,480
internet

00:00:22,880 --> 00:00:26,160
uh right now is its final

00:00:24,480 --> 00:00:29,920
standardization stages

00:00:26,160 --> 00:00:32,320
at the ietf the goal of my presentation

00:00:29,920 --> 00:00:34,000
is to show how to use ls quick

00:00:32,320 --> 00:00:38,320
there's also an accompanying tutorial

00:00:34,000 --> 00:00:38,320
program on github that uses ls quick

00:00:40,160 --> 00:00:44,399
presentation outline the presentation

00:00:42,640 --> 00:00:46,640
will proceed as follows

00:00:44,399 --> 00:00:47,840
after the introduction i'll describe

00:00:46,640 --> 00:00:50,320
bell's quick history

00:00:47,840 --> 00:00:51,360
features and architecture the bulk of

00:00:50,320 --> 00:00:54,399
the time will spend

00:00:51,360 --> 00:00:56,239
presenting and discussing ls quick api

00:00:54,399 --> 00:00:58,399
please do not hesitate to ask questions

00:00:56,239 --> 00:01:00,320
as you progress through the slides

00:00:58,399 --> 00:01:02,719
if time permits there will be a bonus

00:01:00,320 --> 00:01:02,719
section

00:01:04,960 --> 00:01:09,360
example program 2.c

00:01:08,400 --> 00:01:12,720
you can follow along with the

00:01:09,360 --> 00:01:13,520
presentation snippets of this tutorial

00:01:12,720 --> 00:01:15,520
program

00:01:13,520 --> 00:01:17,040
are used as the examples in the

00:01:15,520 --> 00:01:19,439
following slides

00:01:17,040 --> 00:01:21,040
now we're about 10 minutes away from the

00:01:19,439 --> 00:01:22,080
time that we'll really delve into the

00:01:21,040 --> 00:01:23,920
apis

00:01:22,080 --> 00:01:26,640
so it gives enough time to clone this

00:01:23,920 --> 00:01:28,720
repository and build it

00:01:26,640 --> 00:01:30,320
it pulls in boring ssl which takes

00:01:28,720 --> 00:01:32,159
couple minutes to compile depending on

00:01:30,320 --> 00:01:35,920
your hardware

00:01:32,159 --> 00:01:35,920
but 10 minutes should be plenty of time

00:01:37,520 --> 00:01:41,759
now i promise the organizers not to talk

00:01:39,920 --> 00:01:43,680
about quick too much but i'm going to do

00:01:41,759 --> 00:01:46,799
it in 60 seconds just a short

00:01:43,680 --> 00:01:48,640
background now the reason google started

00:01:46,799 --> 00:01:52,240
working on quick in 2012

00:01:48,640 --> 00:01:54,960
is ossification ossification is what

00:01:52,240 --> 00:01:57,360
is the strange things that happen to

00:01:54,960 --> 00:01:59,200
packets as they traverse middle boxes

00:01:57,360 --> 00:02:00,479
classification prevents new internet

00:01:59,200 --> 00:02:02,399
protocols from being deployed

00:02:00,479 --> 00:02:05,759
successfully

00:02:02,399 --> 00:02:07,600
quick began as http 2 over udp now quick

00:02:05,759 --> 00:02:09,599
is an actually developed set of itf

00:02:07,600 --> 00:02:12,000
standards it is a general purpose

00:02:09,599 --> 00:02:15,200
transport protocol

00:02:12,000 --> 00:02:17,520
quick skiller feature is http 3

00:02:15,200 --> 00:02:19,280
http 3 rfc is scheduled to be released

00:02:17,520 --> 00:02:20,640
together with a quick rfc later this

00:02:19,280 --> 00:02:22,319
year

00:02:20,640 --> 00:02:25,120
other application protocol using quick

00:02:22,319 --> 00:02:27,599
have been proposed netconf overquick

00:02:25,120 --> 00:02:29,599
dns server quick anything else you can

00:02:27,599 --> 00:02:31,760
you can name over quick

00:02:29,599 --> 00:02:33,200
the momentum behind quick is strong and

00:02:31,760 --> 00:02:37,840
its future is bright

00:02:33,200 --> 00:02:37,840
some people say that quick is the future

00:02:38,160 --> 00:02:41,840
now we must touch upon the terminology

00:02:40,480 --> 00:02:43,120
used when we talk about quick in the

00:02:41,840 --> 00:02:46,319
beginning kwik stood for

00:02:43,120 --> 00:02:47,840
quick udp internet connections

00:02:46,319 --> 00:02:50,000
and it was google's implementation of

00:02:47,840 --> 00:02:52,080
http 2 over udp

00:02:50,000 --> 00:02:54,000
when ietf started standardizing quick

00:02:52,080 --> 00:02:56,480
the protocol was split into two parts

00:02:54,000 --> 00:02:58,720
the transport part quick and application

00:02:56,480 --> 00:03:01,120
part http

00:02:58,720 --> 00:03:02,159
the slides that will follow when we say

00:03:01,120 --> 00:03:05,440
talk about quick

00:03:02,159 --> 00:03:06,640
will mean itf quick also quick is no

00:03:05,440 --> 00:03:10,000
longer an abbreviation

00:03:06,640 --> 00:03:10,000
you're just supposed to shout it

00:03:11,599 --> 00:03:16,840
introducing ls quick ls quick again is a

00:03:14,720 --> 00:03:19,280
proprietary

00:03:16,840 --> 00:03:20,959
component and then we open sourced it it

00:03:19,280 --> 00:03:23,840
is written in vanilla c

00:03:20,959 --> 00:03:25,440
it has minimal dependencies uh our main

00:03:23,840 --> 00:03:26,720
emphasis on the performance use as

00:03:25,440 --> 00:03:30,319
little memory and as

00:03:26,720 --> 00:03:30,319
few cpu cycles as possible

00:03:30,480 --> 00:03:36,799
our next goal is flexibility we can

00:03:33,920 --> 00:03:39,200
lsq can be configured to perform variety

00:03:36,799 --> 00:03:41,519
of tasks in different ways

00:03:39,200 --> 00:03:43,360
and uh last but not least is portability

00:03:41,519 --> 00:03:46,000
i know this is linux conference

00:03:43,360 --> 00:03:48,239
but ls quick also on other platforms

00:03:46,000 --> 00:03:52,480
freebsd micros windows

00:03:48,239 --> 00:03:52,480
android and even raspberry pi

00:03:53,840 --> 00:03:59,360
ls quick history in 2016 we set a goal

00:03:57,200 --> 00:04:01,200
to add support for the google quick

00:03:59,360 --> 00:04:02,480
protocol to our web server lightspeed

00:04:01,200 --> 00:04:05,200
web server

00:04:02,480 --> 00:04:07,840
and in 2017 we shipped support for

00:04:05,200 --> 00:04:10,080
google quick version q035

00:04:07,840 --> 00:04:11,040
and open sourced quick ls quick on

00:04:10,080 --> 00:04:12,959
github

00:04:11,040 --> 00:04:14,720
we open sourced only the client bits of

00:04:12,959 --> 00:04:16,000
the library because we wanted to keep

00:04:14,720 --> 00:04:17,759
the server parts to ourselves for

00:04:16,000 --> 00:04:20,959
competitive advantage over other

00:04:17,759 --> 00:04:22,400
web server vendors iatf began working on

00:04:20,959 --> 00:04:25,759
quick in 2018

00:04:22,400 --> 00:04:27,919
and at iitf 103 in november 2018

00:04:25,759 --> 00:04:29,840
ellis quick became the first functional

00:04:27,919 --> 00:04:31,840
http 3 web server when the facebook

00:04:29,840 --> 00:04:34,800
client interrupt with it

00:04:31,840 --> 00:04:35,919
in 2019 we released ls quick 2.0 to

00:04:34,800 --> 00:04:37,840
github in this part

00:04:35,919 --> 00:04:40,479
which this time we open source both the

00:04:37,840 --> 00:04:42,320
server and the client components

00:04:40,479 --> 00:04:44,720
and in the sum of that year we shipped

00:04:42,320 --> 00:04:46,800
http 3 support

00:04:44,720 --> 00:04:49,520
and this year by the end of this year we

00:04:46,800 --> 00:04:52,560
hope to see rfcs for both quick

00:04:49,520 --> 00:04:52,560
and http 3.

00:04:54,720 --> 00:04:58,639
features now among about a dozen or so

00:04:56,800 --> 00:05:00,960
excellent quick implementations

00:04:58,639 --> 00:05:01,680
ls quick is one of the more featureful

00:05:00,960 --> 00:05:04,400
it supports

00:05:01,680 --> 00:05:06,160
almost all of the things that the quick

00:05:04,400 --> 00:05:09,120
transport and http drafts

00:05:06,160 --> 00:05:10,720
uh recommend uh we support ecn which

00:05:09,120 --> 00:05:13,039
stands for

00:05:10,720 --> 00:05:14,240
explicit congestion notifications we

00:05:13,039 --> 00:05:15,840
support spin bits

00:05:14,240 --> 00:05:17,680
which allows network observer to

00:05:15,840 --> 00:05:19,840
calculate rtt

00:05:17,680 --> 00:05:22,479
of a quick connection and we support

00:05:19,840 --> 00:05:26,240
path migration and battery binding

00:05:22,479 --> 00:05:28,320
we support dplp mtud push promises which

00:05:26,240 --> 00:05:31,520
is an http 3 feature

00:05:28,320 --> 00:05:33,440
we support tls key updates and several

00:05:31,520 --> 00:05:34,720
experimental extensions such as the loss

00:05:33,440 --> 00:05:36,479
bit extension

00:05:34,720 --> 00:05:38,639
loads bit extension allows network

00:05:36,479 --> 00:05:41,039
observer to locate the source

00:05:38,639 --> 00:05:43,039
of a packet loss on a quick connection

00:05:41,039 --> 00:05:45,199
we support timestamps extension

00:05:43,039 --> 00:05:46,160
which allows one to calculate one-way

00:05:45,199 --> 00:05:48,000
delay

00:05:46,160 --> 00:05:49,680
an important part of some congestion

00:05:48,000 --> 00:05:52,240
controllers

00:05:49,680 --> 00:05:54,160
we support delay dax extension which

00:05:52,240 --> 00:05:55,759
allows the connection to fine tune the

00:05:54,160 --> 00:05:58,000
number of acts

00:05:55,759 --> 00:05:59,440
issued and therefore minimize the number

00:05:58,000 --> 00:06:02,080
of packets sent

00:05:59,440 --> 00:06:04,840
which improves performance and we

00:06:02,080 --> 00:06:07,039
support the quick grease bit extension

00:06:04,840 --> 00:06:08,560
which randomizes the value of a

00:06:07,039 --> 00:06:11,120
particular bit in the header file to

00:06:08,560 --> 00:06:13,759
reduce specification opportunities

00:06:11,120 --> 00:06:15,520
uh we support google quick versions 43

00:06:13,759 --> 00:06:20,240
46 and 50.

00:06:15,520 --> 00:06:23,360
uh q050 is what chrome uses right now

00:06:20,240 --> 00:06:28,319
and we support the latest itf drafts 27

00:06:23,360 --> 00:06:34,720
28 and 29 and also lsv possesses many

00:06:28,319 --> 00:06:37,360
many configuration knobs

00:06:34,720 --> 00:06:38,000
ls quick architecture dell's heat

00:06:37,360 --> 00:06:39,840
library

00:06:38,000 --> 00:06:41,680
does not use sockets to receive and send

00:06:39,840 --> 00:06:43,199
packets all that is performed using

00:06:41,680 --> 00:06:45,039
callbacks

00:06:43,199 --> 00:06:46,639
the library also does not mandate use of

00:06:45,039 --> 00:06:48,319
any particular event loop

00:06:46,639 --> 00:06:50,240
instead it has functions to help the

00:06:48,319 --> 00:06:51,840
user schedule events

00:06:50,240 --> 00:06:53,680
thus using an event loop is not only

00:06:51,840 --> 00:06:55,360
strictly necessary

00:06:53,680 --> 00:06:58,160
the various callbacks and settings are

00:06:55,360 --> 00:07:01,199
supplied to the engine constructor

00:06:58,160 --> 00:07:02,160
lsq keeps quick connections in several

00:07:01,199 --> 00:07:04,319
data structures

00:07:02,160 --> 00:07:05,919
in order to process them efficiently

00:07:04,319 --> 00:07:07,360
among others connections are kept in two

00:07:05,919 --> 00:07:08,720
priority queues

00:07:07,360 --> 00:07:10,080
one priority queue holds connections

00:07:08,720 --> 00:07:11,039
that are ready to be processed in the

00:07:10,080 --> 00:07:14,800
order of

00:07:11,039 --> 00:07:17,919
connections and the other calls them uh

00:07:14,800 --> 00:07:19,919
based on the next timer expiration value

00:07:17,919 --> 00:07:22,800
as a result connections are processed

00:07:19,919 --> 00:07:22,800
very efficiently

00:07:25,360 --> 00:07:31,360
objects ls kick exposes three basic

00:07:28,560 --> 00:07:32,080
object types to the user engine

00:07:31,360 --> 00:07:35,840
connection

00:07:32,080 --> 00:07:38,240
and stream an engine manages connections

00:07:35,840 --> 00:07:39,599
processes incoming packets and schedules

00:07:38,240 --> 00:07:41,599
outgoing packets

00:07:39,599 --> 00:07:42,960
it can be instantiated either in server

00:07:41,599 --> 00:07:44,560
client mode

00:07:42,960 --> 00:07:46,720
if your program needs to have both quick

00:07:44,560 --> 00:07:49,199
client and quick server functionality

00:07:46,720 --> 00:07:50,400
you can instantiate two engines or as

00:07:49,199 --> 00:07:52,400
many as you want

00:07:50,400 --> 00:07:54,560
this is what we do in our light speed

00:07:52,400 --> 00:07:56,319
web adc product which acts both as the

00:07:54,560 --> 00:07:58,560
server and the client

00:07:56,319 --> 00:08:01,520
in addition a ls quick engine can be

00:07:58,560 --> 00:08:04,160
instantiated in http mode

00:08:01,520 --> 00:08:06,080
a connection carries one or more streams

00:08:04,160 --> 00:08:08,800
insurance reliable data delivery

00:08:06,080 --> 00:08:09,680
and handles the protocol details in

00:08:08,800 --> 00:08:11,280
client mode

00:08:09,680 --> 00:08:13,360
a connection is created using a function

00:08:11,280 --> 00:08:15,599
call in server mode

00:08:13,360 --> 00:08:16,639
a connection by the time the user gets a

00:08:15,599 --> 00:08:18,960
connection

00:08:16,639 --> 00:08:22,400
the handshake has already been completed

00:08:18,960 --> 00:08:24,639
that is not the case in client mode

00:08:22,400 --> 00:08:26,879
streams do not exist by themselves

00:08:24,639 --> 00:08:28,319
they're always part of a connection

00:08:26,879 --> 00:08:31,360
streams are bi-directional and usually

00:08:28,319 --> 00:08:33,599
correspond to request response exchange

00:08:31,360 --> 00:08:37,279
depending on the application protocol

00:08:33,599 --> 00:08:37,279
application data is carried using

00:08:38,839 --> 00:08:44,159
streams

00:08:40,000 --> 00:08:46,240
the http mode http support is included

00:08:44,159 --> 00:08:47,600
directly into ls quick

00:08:46,240 --> 00:08:49,680
the library hides the interaction

00:08:47,600 --> 00:08:51,120
between http application protocol and

00:08:49,680 --> 00:08:54,160
the quick transfer protocol

00:08:51,120 --> 00:08:57,760
such as control streams data framing

00:08:54,160 --> 00:09:00,320
and header compression the user

00:08:57,760 --> 00:09:02,399
gets access to the http protocol in

00:09:00,320 --> 00:09:04,240
unified way by unified i mean

00:09:02,399 --> 00:09:07,279
g quick and http 3 have identical

00:09:04,240 --> 00:09:09,440
interfaces in ls quick

00:09:07,279 --> 00:09:11,040
uh the reason this is done this way is

00:09:09,440 --> 00:09:13,519
uh that g-quick's

00:09:11,040 --> 00:09:15,279
original goal was to erase the boundary

00:09:13,519 --> 00:09:16,959
between application and transport layers

00:09:15,279 --> 00:09:19,360
to improve performance

00:09:16,959 --> 00:09:20,000
when we started work on support for http

00:09:19,360 --> 00:09:22,880
00:09:20,000 --> 00:09:24,080
we kept the same design even though ietf

00:09:22,880 --> 00:09:26,320
has different

00:09:24,080 --> 00:09:29,279
drafts for quick and hdp protocols in

00:09:26,320 --> 00:09:32,480
the different beasts

00:09:29,279 --> 00:09:35,519
so this is historic circumstance but it

00:09:32,480 --> 00:09:38,000
allows for some optimizations

00:09:35,519 --> 00:09:39,519
you can write to an http stream and have

00:09:38,000 --> 00:09:41,200
your data end up directly in the packet

00:09:39,519 --> 00:09:42,560
ready to be sent

00:09:41,200 --> 00:09:44,720
on the other hand it does include

00:09:42,560 --> 00:09:46,240
complexity increased complexity in the

00:09:44,720 --> 00:09:47,200
library and i don't think you'll be

00:09:46,240 --> 00:09:49,360
adding

00:09:47,200 --> 00:09:52,800
support for other application protocols

00:09:49,360 --> 00:09:52,800
directly into lsqc

00:09:56,000 --> 00:09:59,519
now we finally get to using ls quick to

00:09:58,399 --> 00:10:01,200
include

00:09:59,519 --> 00:10:03,519
the file you need the one single include

00:10:01,200 --> 00:10:05,440
file let's click that h

00:10:03,519 --> 00:10:07,200
this file contains on the nes all the

00:10:05,440 --> 00:10:09,519
necessary declarations

00:10:07,200 --> 00:10:12,320
and it pulls in auxiliary ls quick

00:10:09,519 --> 00:10:12,320
types.h

00:10:15,360 --> 00:10:18,720
library initialization this is an

00:10:17,600 --> 00:10:22,959
example from

00:10:18,720 --> 00:10:24,160
2.c uh before instantiating objects

00:10:22,959 --> 00:10:26,959
the library itself needs to be

00:10:24,160 --> 00:10:28,800
instantiated and depending on whether

00:10:26,959 --> 00:10:30,480
you which types of engines you're going

00:10:28,800 --> 00:10:32,160
to instantiate server or client you can

00:10:30,480 --> 00:10:34,720
pass the appropriate flag to the

00:10:32,160 --> 00:10:35,279
initialization function depending on the

00:10:34,720 --> 00:10:38,560
platform

00:10:35,279 --> 00:10:40,959
it will instantiate monotonic timers

00:10:38,560 --> 00:10:43,200
and depending on some other flags it

00:10:40,959 --> 00:10:46,480
will instantiate

00:10:43,200 --> 00:10:47,279
server side certificate cache for g

00:10:46,480 --> 00:10:51,839
quick

00:10:47,279 --> 00:10:51,839
and it will initialize the crypt library

00:10:53,839 --> 00:10:57,839
introducing the tutorial program now

00:10:56,320 --> 00:10:59,360
this time it's been a little bit over 10

00:10:57,839 --> 00:11:02,480
minutes

00:10:59,360 --> 00:11:04,480
into our presentation or our tutorial

00:11:02,480 --> 00:11:06,079
and i hope you've had time to download

00:11:04,480 --> 00:11:09,600
and compile

00:11:06,079 --> 00:11:12,839
the um program i'm going to ask

00:11:09,600 --> 00:11:14,079
stop shoulder to see if you have any

00:11:12,839 --> 00:11:16,800
questions

00:11:14,079 --> 00:11:16,800
one second

00:11:21,040 --> 00:11:29,839
i'm not sure how to see it

00:11:40,160 --> 00:11:46,160
well uh i'm not sure how to get to the

00:11:43,279 --> 00:11:47,279
chat from my screen so i will just move

00:11:46,160 --> 00:11:50,399
on you can perhaps

00:11:47,279 --> 00:11:53,279
ask me uh directly using audio

00:11:50,399 --> 00:11:53,279
oh no there is chat

00:11:54,240 --> 00:12:00,880
ah there are no questions i apologize um

00:11:57,839 --> 00:12:02,399
so the program 2.c illustrates ls quick

00:12:00,880 --> 00:12:05,440
api use

00:12:02,399 --> 00:12:07,600
it contains both client and server code

00:12:05,440 --> 00:12:09,680
it is a simple echo service the client

00:12:07,600 --> 00:12:12,000
sends lines to the server and server

00:12:09,680 --> 00:12:13,760
versus them and sends them back

00:12:12,000 --> 00:12:15,440
each request is sent in a single

00:12:13,760 --> 00:12:17,519
bidirectional stream

00:12:15,440 --> 00:12:18,959
and several examples that follow are

00:12:17,519 --> 00:12:22,560
taken directly from

00:12:18,959 --> 00:12:22,560
to that c program

00:12:23,120 --> 00:12:27,600
running the tutorial program uh it has

00:12:26,000 --> 00:12:30,720
several options

00:12:27,600 --> 00:12:33,040
uh use the h flag uh you to run you can

00:12:30,720 --> 00:12:35,680
run it both in client or server mode

00:12:33,040 --> 00:12:38,560
uh the server takes dash cn-k arguments

00:12:35,680 --> 00:12:40,399
to specify certificate in the key file

00:12:38,560 --> 00:12:42,480
and you can see a small example here on

00:12:40,399 --> 00:12:44,160
this slide

00:12:42,480 --> 00:12:45,839
the server specifies going to list on

00:12:44,160 --> 00:12:46,560
port one two three four five and clients

00:12:45,839 --> 00:12:50,839
connect to it

00:12:46,560 --> 00:12:53,839
and sends it a line and server sends it

00:12:50,839 --> 00:12:53,839
back

00:12:55,200 --> 00:12:59,839
engine constructor ls quick engine new

00:12:58,240 --> 00:13:01,760
is the engine constructor

00:12:59,839 --> 00:13:03,600
it allocates initializes and returns a

00:13:01,760 --> 00:13:05,600
new engine object

00:13:03,600 --> 00:13:07,279
the first argument is a bit mask to tell

00:13:05,600 --> 00:13:08,639
the engine whether or not it's in server

00:13:07,279 --> 00:13:10,560
or client mode

00:13:08,639 --> 00:13:13,680
and the second bit specifies whether or

00:13:10,560 --> 00:13:15,279
not to turn on the http functionality

00:13:13,680 --> 00:13:18,399
the second argument is a pointer to the

00:13:15,279 --> 00:13:19,920
so-called engine api struct

00:13:18,399 --> 00:13:22,639
this structure specifies various

00:13:19,920 --> 00:13:25,600
callbacks used by elsquick api

00:13:22,639 --> 00:13:27,440
it may also point to a settings struct

00:13:25,600 --> 00:13:29,519
there are many settings

00:13:27,440 --> 00:13:35,519
both the api's tracked and the settings

00:13:29,519 --> 00:13:38,480
tracks are copied into the engine

00:13:35,519 --> 00:13:39,440
specifying engine callbacks here's a

00:13:38,480 --> 00:13:40,880
minimal

00:13:39,440 --> 00:13:45,120
version of the second argument to the

00:13:40,880 --> 00:13:46,720
agent constructor the engine api struct

00:13:45,120 --> 00:13:48,560
the user must provide a pointer to a

00:13:46,720 --> 00:13:49,600
function that the ng will call to send

00:13:48,560 --> 00:13:51,120
packets

00:13:49,600 --> 00:13:54,880
it will pass this function using

00:13:51,120 --> 00:13:56,880
specified data a packets out ctx

00:13:54,880 --> 00:13:58,720
note that incoming packets are passed to

00:13:56,880 --> 00:14:02,000
the engine using a function

00:13:58,720 --> 00:14:03,680
which we'll cover in the later slide

00:14:02,000 --> 00:14:05,440
the second required piece of information

00:14:03,680 --> 00:14:07,120
is the point to connection and stream

00:14:05,440 --> 00:14:08,720
callbacks

00:14:07,120 --> 00:14:10,320
these are functions that get called when

00:14:08,720 --> 00:14:11,760
connections in stream get created and

00:14:10,320 --> 00:14:13,440
destroyed

00:14:11,760 --> 00:14:16,000
and also functions that are called when

00:14:13,440 --> 00:14:18,320
read and write events occur

00:14:16,000 --> 00:14:19,279
in server mode one must also specify a

00:14:18,320 --> 00:14:23,120
function to get

00:14:19,279 --> 00:14:23,120
initialized ssl context

00:14:25,360 --> 00:14:29,600
and here's an excerpt from our tutorial

00:14:27,920 --> 00:14:32,160
program

00:14:29,600 --> 00:14:33,760
you can see that because it runs in both

00:14:32,160 --> 00:14:34,880
client and server mode we check for a

00:14:33,760 --> 00:14:37,920
flag

00:14:34,880 --> 00:14:39,279
and if it's a server we set we give it a

00:14:37,920 --> 00:14:40,959
server callbacks

00:14:39,279 --> 00:14:42,720
and for client we specified client

00:14:40,959 --> 00:14:46,399
callbacks

00:14:42,720 --> 00:14:47,839
we assign the get ssl ctx function

00:14:46,399 --> 00:14:49,519
unconditionally

00:14:47,839 --> 00:14:52,000
the client engine will not call this

00:14:49,519 --> 00:14:52,000
callback

00:14:55,440 --> 00:14:58,959
packets in udp datagrams are passed to

00:14:58,480 --> 00:15:01,199
the engine

00:14:58,959 --> 00:15:02,639
using the ls quick engine packet in

00:15:01,199 --> 00:15:05,120
function

00:15:02,639 --> 00:15:06,240
this is the only way to do so a pointer

00:15:05,120 --> 00:15:09,120
to ddp payload

00:15:06,240 --> 00:15:09,680
enter its size and it says a pass to the

00:15:09,120 --> 00:15:12,720
function

00:15:09,680 --> 00:15:15,839
as well as pointer is to local and peer

00:15:12,720 --> 00:15:16,880
psychic addresses another piece of

00:15:15,839 --> 00:15:19,920
information that is passed

00:15:16,880 --> 00:15:21,839
is the void peer context pointer

00:15:19,920 --> 00:15:23,040
it this context pointer gets passed to

00:15:21,839 --> 00:15:26,000
the functions that

00:15:23,040 --> 00:15:26,959
sent packet subsense packets out in a

00:15:26,000 --> 00:15:30,000
standard setup

00:15:26,959 --> 00:15:32,399
this uh pctx pointer is usually just

00:15:30,000 --> 00:15:34,000
associated with the file descriptor but

00:15:32,399 --> 00:15:34,880
depending on the network stack users

00:15:34,000 --> 00:15:37,360
maybe

00:15:34,880 --> 00:15:38,880
it may be pointing to something else and

00:15:37,360 --> 00:15:44,079
the ecn is a standard

00:15:38,880 --> 00:15:44,079
value as described in rfc 3168.

00:15:45,199 --> 00:15:50,160
why specify local address the local

00:15:48,240 --> 00:15:51,040
address is necessary because it becomes

00:15:50,160 --> 00:15:53,519
the

00:15:51,040 --> 00:15:55,600
source address for outgoing packets it

00:15:53,519 --> 00:15:58,800
is important in multi-home setups

00:15:55,600 --> 00:16:00,399
where a destination address of a packet

00:15:58,800 --> 00:16:01,839
on a single file descriptor may be

00:16:00,399 --> 00:16:03,759
different

00:16:01,839 --> 00:16:06,000
also changes in local imperial addresses

00:16:03,759 --> 00:16:08,720
are used to detect changes in paths

00:16:06,000 --> 00:16:10,720
such as path migration during the

00:16:08,720 --> 00:16:11,839
classic parking lot problem or netflix

00:16:10,720 --> 00:16:13,920
bindings

00:16:11,839 --> 00:16:15,600
when path change is detected quick

00:16:13,920 --> 00:16:19,040
connections perform several special

00:16:15,600 --> 00:16:19,040
steps to validate the new path

00:16:21,279 --> 00:16:26,480
uh the packets out callback now this is

00:16:24,399 --> 00:16:29,519
the function to send outgoing packages

00:16:26,480 --> 00:16:32,480
as specified in uh

00:16:29,519 --> 00:16:33,120
engine api struct uh the packets are

00:16:32,480 --> 00:16:34,639
sent out

00:16:33,120 --> 00:16:36,160
and this call is made when connections

00:16:34,639 --> 00:16:38,240
are being processed

00:16:36,160 --> 00:16:40,639
this is an explicit call by the user

00:16:38,240 --> 00:16:42,399
which we'll cover in a later slide

00:16:40,639 --> 00:16:43,839
this function is passed to user

00:16:42,399 --> 00:16:47,199
specified context

00:16:43,839 --> 00:16:48,320
and an array of packet out

00:16:47,199 --> 00:16:52,240
specifications

00:16:48,320 --> 00:16:52,240
it returns the number of datagrams sent

00:16:54,800 --> 00:16:58,959
now when an error occurs this function

00:16:56,320 --> 00:17:00,800
returns -1 or it returns a number that

00:16:58,959 --> 00:17:01,600
is smaller than the number of diagrams

00:17:00,800 --> 00:17:03,759
passed in

00:17:01,600 --> 00:17:05,199
in that case the engine examines the

00:17:03,759 --> 00:17:07,520
value of arnold

00:17:05,199 --> 00:17:09,439
and there are two main air nodes we need

00:17:07,520 --> 00:17:11,839
to concern ourselves with

00:17:09,439 --> 00:17:12,559
the first one is e again or e would

00:17:11,839 --> 00:17:14,720
block

00:17:12,559 --> 00:17:17,039
which means that the sending could not

00:17:14,720 --> 00:17:18,880
happen and you need to retry later

00:17:17,039 --> 00:17:21,600
in that case the engine enters cannot

00:17:18,880 --> 00:17:23,679
send mode to exit this mode

00:17:21,600 --> 00:17:24,959
the user should call the ls quick engine

00:17:23,679 --> 00:17:28,079
sent on set packets

00:17:24,959 --> 00:17:30,080
when sending is possible again engine

00:17:28,079 --> 00:17:32,480
also implements a fallback mechanism

00:17:30,080 --> 00:17:34,799
it's going to try sending packets again

00:17:32,480 --> 00:17:37,120
one second later regardless

00:17:34,799 --> 00:17:40,320
this is because we don't expect an

00:17:37,120 --> 00:17:43,360
ability to send to last over one second

00:17:40,320 --> 00:17:44,320
uh the second error code is e-message

00:17:43,360 --> 00:17:45,840
size

00:17:44,320 --> 00:17:48,240
and it means that the packet was too

00:17:45,840 --> 00:17:51,440
large this occurs when

00:17:48,240 --> 00:17:53,440
ls quick sends mtu probes in that case

00:17:51,440 --> 00:17:55,520
engine is going to retry sending again

00:17:53,440 --> 00:17:57,360
right away but without the packet that's

00:17:55,520 --> 00:17:59,360
too large

00:17:57,360 --> 00:18:00,960
all other errors cause immediate

00:17:59,360 --> 00:18:03,039
connection termination because

00:18:00,960 --> 00:18:05,679
ls click does not know what to do about

00:18:03,039 --> 00:18:05,679
those errors

00:18:07,760 --> 00:18:12,840
outgoing packet specification this is

00:18:10,320 --> 00:18:14,080
what it looks like structures quick out

00:18:12,840 --> 00:18:15,760
spec

00:18:14,080 --> 00:18:17,360
in addition to the packet payload the

00:18:15,760 --> 00:18:20,160
specification contains

00:18:17,360 --> 00:18:22,160
local and destination addresses which is

00:18:20,160 --> 00:18:25,039
the reverse of the addresses passed to

00:18:22,160 --> 00:18:27,679
the packets in function

00:18:25,039 --> 00:18:29,280
and contains the peer context which in

00:18:27,679 --> 00:18:30,320
the tutorial program is simply the file

00:18:29,280 --> 00:18:34,000
descriptor

00:18:30,320 --> 00:18:36,640
and the ecn the reason for using ivec

00:18:34,000 --> 00:18:38,080
is that udp diagram may contain several

00:18:36,640 --> 00:18:39,679
quick packets

00:18:38,080 --> 00:18:41,280
the way it works is that during quick

00:18:39,679 --> 00:18:44,000
handshake

00:18:41,280 --> 00:18:44,559
packets with long headers can be put

00:18:44,000 --> 00:18:48,000
together

00:18:44,559 --> 00:18:50,400
into the udp diagram or coalesced

00:18:48,000 --> 00:18:52,080
in quick lingo and this is done in order

00:18:50,400 --> 00:18:54,640
to minimize the number of packets

00:18:52,080 --> 00:18:56,000
or the edp diagrams that need to be sent

00:18:54,640 --> 00:18:59,679
lske takes advantage

00:18:56,000 --> 00:19:01,200
of this of this protocol and tries to

00:18:59,679 --> 00:19:03,679
collapse as many packets

00:19:01,200 --> 00:19:03,679
as it can

00:19:05,760 --> 00:19:09,520
and here's a made up packets out example

00:19:07,840 --> 00:19:12,080
you can see that send message

00:19:09,520 --> 00:19:13,919
is called in a loop for each

00:19:12,080 --> 00:19:16,240
specification

00:19:13,919 --> 00:19:17,039
you can also see that pure context is

00:19:16,240 --> 00:19:18,559
cast

00:19:17,039 --> 00:19:20,400
to an integer because it's just a file

00:19:18,559 --> 00:19:23,120
descriptor

00:19:20,400 --> 00:19:25,280
and you will also notice that we ignore

00:19:23,120 --> 00:19:28,400
the value of ecn and local address

00:19:25,280 --> 00:19:30,000
in the packet specification this example

00:19:28,400 --> 00:19:32,880
is similar to the first version of the

00:19:30,000 --> 00:19:34,799
packets out function in tutorial.c

00:19:32,880 --> 00:19:36,640
a more involved packet out function is

00:19:34,799 --> 00:19:39,679
available and it will use

00:19:36,640 --> 00:19:41,760
ancillary messages to specify local

00:19:39,679 --> 00:19:43,280
address and the ecn

00:19:41,760 --> 00:19:45,360
to choose a different packet out

00:19:43,280 --> 00:19:47,440
function use the p1

00:19:45,360 --> 00:19:48,559
option on the command line the simple

00:19:47,440 --> 00:19:51,120
version is the default

00:19:48,559 --> 00:19:52,559
dash p0 and the complex or more involved

00:19:51,120 --> 00:19:55,039
packets out version is the

00:19:52,559 --> 00:19:55,039
p1

00:19:57,919 --> 00:20:01,760
now that we covered uh how to initialize

00:19:59,919 --> 00:20:03,919
the library instantiate the engines

00:20:01,760 --> 00:20:07,120
and the send and receive packets we'll

00:20:03,919 --> 00:20:09,360
talk about processing connections

00:20:07,120 --> 00:20:10,880
ls quick has the concept of tick which

00:20:09,360 --> 00:20:11,280
is a way to describe what a connection

00:20:10,880 --> 00:20:13,760
does

00:20:11,280 --> 00:20:14,559
when it does something productive uh

00:20:13,760 --> 00:20:16,240
other

00:20:14,559 --> 00:20:18,159
verbs we could have settled in would be

00:20:16,240 --> 00:20:20,320
like kick prod or poke but we

00:20:18,159 --> 00:20:22,240
settled on tick because it's a little

00:20:20,320 --> 00:20:23,679
bit more dignified

00:20:22,240 --> 00:20:25,280
now there's a single function that can

00:20:23,679 --> 00:20:27,919
tell the user whether and when their

00:20:25,280 --> 00:20:29,840
connections that need to be processed

00:20:27,919 --> 00:20:31,200
and this function is ls quick engine

00:20:29,840 --> 00:20:33,840
earliest ad tick

00:20:31,200 --> 00:20:35,440
where ad stands for advisory now

00:20:33,840 --> 00:20:36,960
advisory means that you don't have to

00:20:35,440 --> 00:20:38,480
call this function the process

00:20:36,960 --> 00:20:39,120
connections that particular point in

00:20:38,480 --> 00:20:42,159
time

00:20:39,120 --> 00:20:43,760
it is just the best to do so if there

00:20:42,159 --> 00:20:46,720
are connections to be processed this

00:20:43,760 --> 00:20:49,919
function returns a true value

00:20:46,720 --> 00:20:52,960
and sets diff to number of microseconds

00:20:49,919 --> 00:20:54,640
uh from current time when this pricing

00:20:52,960 --> 00:20:56,720
should take place

00:20:54,640 --> 00:20:57,840
note that diff could be negative in

00:20:56,720 --> 00:21:00,000
which case

00:20:57,840 --> 00:21:03,840
it means that the perfect time for

00:21:00,000 --> 00:21:03,840
pricing connection has passed

00:21:05,600 --> 00:21:08,640
the engine keeps all connections and

00:21:07,200 --> 00:21:10,559
several data structures

00:21:08,640 --> 00:21:12,559
and it tracks each connection's timers

00:21:10,559 --> 00:21:14,240
and it knows when to fire them

00:21:12,559 --> 00:21:17,520
that's how i can tell you when to fire

00:21:14,240 --> 00:21:19,120
when to process connections

00:21:17,520 --> 00:21:21,360
and here's the example with the event

00:21:19,120 --> 00:21:23,120
loop from our tutorial program

00:21:21,360 --> 00:21:24,720
you can see that we first stopped the

00:21:23,120 --> 00:21:27,919
timer

00:21:24,720 --> 00:21:29,840
we call ls quick engine process cons

00:21:27,919 --> 00:21:32,159
and when this function is called that's

00:21:29,840 --> 00:21:33,600
when engine will call all the callbacks

00:21:32,159 --> 00:21:34,799
that it needs

00:21:33,600 --> 00:21:37,120
after the connections have been

00:21:34,799 --> 00:21:39,679
processed uh we call

00:21:37,120 --> 00:21:41,280
uh lsqc engine earliest advertising

00:21:39,679 --> 00:21:42,880
function to find out

00:21:41,280 --> 00:21:45,039
whether their connections to be

00:21:42,880 --> 00:21:47,200
processed and when

00:21:45,039 --> 00:21:49,200
and if it returns true then we specified

00:21:47,200 --> 00:21:51,520
calculate the value of a new timeout

00:21:49,200 --> 00:21:52,880
and restart the timer and start the

00:21:51,520 --> 00:21:56,480
process of the

00:21:52,880 --> 00:21:58,640
loop again now sometimes

00:21:56,480 --> 00:22:01,039
this function ls quick engine earliest

00:21:58,640 --> 00:22:02,799
advertising may return false value

00:22:01,039 --> 00:22:04,799
even if there are connections managed by

00:22:02,799 --> 00:22:06,480
the engine and this happens when the

00:22:04,799 --> 00:22:07,840
connection has idle timer turned off

00:22:06,480 --> 00:22:10,400
meaning there are no

00:22:07,840 --> 00:22:11,200
events to be fired at all but that

00:22:10,400 --> 00:22:14,159
doesn't happen

00:22:11,200 --> 00:22:14,159
in the standard setup

00:22:16,480 --> 00:22:20,000
tickable connection there are several

00:22:18,640 --> 00:22:21,039
ways for connection to do something

00:22:20,000 --> 00:22:22,559
productive

00:22:21,039 --> 00:22:25,039
when a connection can do any of the

00:22:22,559 --> 00:22:28,240
following things it is tickable

00:22:25,039 --> 00:22:30,320
they're incoming packets a user wants to

00:22:28,240 --> 00:22:31,280
read from stream and there is data to be

00:22:30,320 --> 00:22:33,200
read

00:22:31,280 --> 00:22:34,960
a user wants to write to stream and

00:22:33,200 --> 00:22:37,360
stream is writable

00:22:34,960 --> 00:22:38,480
or user has written to stream outside of

00:22:37,360 --> 00:22:40,400
callbacks

00:22:38,480 --> 00:22:41,679
that's allowed and now there's some

00:22:40,400 --> 00:22:43,919
buffered packets that need to be

00:22:41,679 --> 00:22:47,120
scheduled and sent out

00:22:43,919 --> 00:22:49,840
or lsqc needs to do something internally

00:22:47,120 --> 00:22:50,400
such as send out a control frame or

00:22:49,840 --> 00:22:53,600
perhaps

00:22:50,400 --> 00:22:57,039
services stream such as cola on close

00:22:53,600 --> 00:22:57,039
function on a stream

00:22:59,679 --> 00:23:04,000
processing connections so connect all

00:23:02,400 --> 00:23:04,559
connections the process using the single

00:23:04,000 --> 00:23:07,840
function

00:23:04,559 --> 00:23:10,240
ls quick engine process cons and

00:23:07,840 --> 00:23:12,000
this call inside this call all the

00:23:10,240 --> 00:23:13,200
necessary callbacks are called to send

00:23:12,000 --> 00:23:15,760
out packets

00:23:13,200 --> 00:23:18,640
and all new on read and read all the

00:23:15,760 --> 00:23:18,640
read and write events

00:23:18,880 --> 00:23:23,440
this function is not re-entrant so do

00:23:20,559 --> 00:23:26,799
not call it from other callbacks

00:23:23,440 --> 00:23:29,039
uh you should call this function when

00:23:26,799 --> 00:23:30,240
advised by the ls quick engine earliest

00:23:29,039 --> 00:23:31,679
advertic

00:23:30,240 --> 00:23:33,600
uh but know that event loop is really

00:23:31,679 --> 00:23:35,039
not necessary and as a matter of fact

00:23:33,600 --> 00:23:36,240
the library will still work if you

00:23:35,039 --> 00:23:38,640
simply call

00:23:36,240 --> 00:23:39,600
ellis kick engine process cons in a loop

00:23:38,640 --> 00:23:41,520
every

00:23:39,600 --> 00:23:43,039
10 milliseconds but that's not

00:23:41,520 --> 00:23:45,120
recommended

00:23:43,039 --> 00:23:48,400
another function that sends packets is

00:23:45,120 --> 00:23:50,000
ls quick engine sent and sent packets

00:23:48,400 --> 00:23:52,080
and that should be called when there was

00:23:50,000 --> 00:23:53,440
a earlier failure to send packets as

00:23:52,080 --> 00:23:57,120
we've discussed before

00:23:53,440 --> 00:23:57,120
with the e-again error code

00:24:00,159 --> 00:24:04,080
engine callbacks let us continue

00:24:03,039 --> 00:24:05,919
initializing the

00:24:04,080 --> 00:24:07,919
engine instance we have covered the

00:24:05,919 --> 00:24:09,760
callbacks to send out packets

00:24:07,919 --> 00:24:11,200
this is one of the required engine

00:24:09,760 --> 00:24:12,559
callbacks

00:24:11,200 --> 00:24:14,000
the other set of required engine

00:24:12,559 --> 00:24:14,799
callbacks are connection and stream

00:24:14,000 --> 00:24:17,120
callbacks

00:24:14,799 --> 00:24:18,159
such as on new connection on read and so

00:24:17,120 --> 00:24:19,919
on

00:24:18,159 --> 00:24:23,600
and for the server there is a callback

00:24:19,919 --> 00:24:23,600
to get default tls context

00:24:23,679 --> 00:24:26,480
now also i'd like to mention some

00:24:25,039 --> 00:24:28,159
optional callbacks which will not be

00:24:26,480 --> 00:24:30,960
covered in this presentation but they're

00:24:28,159 --> 00:24:32,480
good to be aware of in the future

00:24:30,960 --> 00:24:34,559
there are callbacks to look up

00:24:32,480 --> 00:24:36,480
certificate by sni

00:24:34,559 --> 00:24:38,320
which is necessary when you when the

00:24:36,480 --> 00:24:40,480
application protocol demands it such as

00:24:38,320 --> 00:24:42,559
http 3

00:24:40,480 --> 00:24:44,799
there are callbacks to control memory

00:24:42,559 --> 00:24:47,200
allocation for outgoing packets

00:24:44,799 --> 00:24:47,919
this is useful when you use an

00:24:47,200 --> 00:24:49,679
alternative

00:24:47,919 --> 00:24:51,440
network stack and for example all of

00:24:49,679 --> 00:24:53,600
your outgoing packets must be contained

00:24:51,440 --> 00:24:55,600
in contiguous memory

00:24:53,600 --> 00:24:57,039
uh for multi-process setup there are

00:24:55,600 --> 00:24:59,039
callbacks to

00:24:57,039 --> 00:25:01,279
observe connection id life cycle when

00:24:59,039 --> 00:25:02,880
connections are created and destroyed

00:25:01,279 --> 00:25:05,279
as well as a shared memory hash which

00:25:02,880 --> 00:25:07,679
allows multiple processes to share

00:25:05,279 --> 00:25:10,559
crypto information there is also an

00:25:07,679 --> 00:25:15,840
optional set of http header calls

00:25:10,559 --> 00:25:15,840
to process incoming http headers

00:25:18,159 --> 00:25:21,279
now we will talk about streaming

00:25:19,440 --> 00:25:22,480
connection callbacks streaming

00:25:21,279 --> 00:25:23,919
connection callbacks are the way that

00:25:22,480 --> 00:25:25,039
the library communicates with the user

00:25:23,919 --> 00:25:26,799
code

00:25:25,039 --> 00:25:28,240
some of these callbacks are mandatory

00:25:26,799 --> 00:25:31,679
and others are

00:25:28,240 --> 00:25:33,600
optional the mandatory callbacks are

00:25:31,679 --> 00:25:34,799
destruction and creation of connections

00:25:33,600 --> 00:25:37,600
stream

00:25:34,799 --> 00:25:38,720
and stream read and write events

00:25:37,600 --> 00:25:40,240
optional callbacks

00:25:38,720 --> 00:25:42,720
are have to usually have to do with the

00:25:40,240 --> 00:25:44,400
connection lifecycle and they

00:25:42,720 --> 00:25:45,919
involve things such as receiving a go

00:25:44,400 --> 00:25:49,919
away from peer

00:25:45,919 --> 00:25:52,640
or having a new tls

00:25:49,919 --> 00:25:52,640
session ticket

00:25:54,960 --> 00:25:59,120
let us go through these connections

00:25:56,240 --> 00:26:00,799
through these callbacks one by one

00:25:59,120 --> 00:26:03,440
when a connection object is created the

00:26:00,799 --> 00:26:05,039
on new connection callback is called

00:26:03,440 --> 00:26:06,640
in server mode the handshake is already

00:26:05,039 --> 00:26:08,480
known to have succeeded

00:26:06,640 --> 00:26:09,840
in client mode the connection object is

00:26:08,480 --> 00:26:11,039
created before the hand check is

00:26:09,840 --> 00:26:12,480
successful

00:26:11,039 --> 00:26:14,559
the client can tell whether or not the

00:26:12,480 --> 00:26:16,000
handshake succeeds by using the optional

00:26:14,559 --> 00:26:18,799
on handshake done

00:26:16,000 --> 00:26:21,279
callback or just by watching the on

00:26:18,799 --> 00:26:23,200
connection clause callback

00:26:21,279 --> 00:26:24,559
in the made up example on the slide we

00:26:23,200 --> 00:26:27,120
can see that we allocate

00:26:24,559 --> 00:26:27,840
per connection context and then we

00:26:27,120 --> 00:26:30,640
return

00:26:27,840 --> 00:26:32,000
this pointer to this new context this is

00:26:30,640 --> 00:26:33,440
the connection context that will be

00:26:32,000 --> 00:26:34,720
associated with this connection for its

00:26:33,440 --> 00:26:36,400
duration

00:26:34,720 --> 00:26:37,919
uh note that it's perfectly okay to

00:26:36,400 --> 00:26:40,000
return null you don't have to create a

00:26:37,919 --> 00:26:43,120
connection context

00:26:40,000 --> 00:26:45,360
also in this callback if you're a client

00:26:43,120 --> 00:26:46,480
and want to send some requests which you

00:26:45,360 --> 00:26:48,480
probably do

00:26:46,480 --> 00:26:50,080
this is a good place to call ls quick

00:26:48,480 --> 00:26:52,799
can make stream

00:26:50,080 --> 00:26:53,520
and after handshake succeeds alice quick

00:26:52,799 --> 00:26:56,080
will call

00:26:53,520 --> 00:26:58,960
on a stream new callback when your

00:26:56,080 --> 00:26:58,960
stream is created

00:27:01,679 --> 00:27:06,640
on new stream now quick allows either

00:27:04,720 --> 00:27:08,400
endpoint to create streams and send and

00:27:06,640 --> 00:27:09,440
receive data on them

00:27:08,400 --> 00:27:11,279
there are uni-directional and

00:27:09,440 --> 00:27:13,840
bi-directional streams and thus the

00:27:11,279 --> 00:27:15,919
total of four stream types

00:27:13,840 --> 00:27:17,039
but in our simple example we stick to

00:27:15,919 --> 00:27:19,520
the usual paradigm

00:27:17,039 --> 00:27:21,279
of a single stream per request the

00:27:19,520 --> 00:27:23,360
client sends the request

00:27:21,279 --> 00:27:26,159
and server sends the response back on

00:27:23,360 --> 00:27:28,480
the same bi-directional stream

00:27:26,159 --> 00:27:30,080
uh on the server the stream is created

00:27:28,480 --> 00:27:32,159
when the new requests arrive

00:27:30,080 --> 00:27:34,000
and on the client are created when

00:27:32,159 --> 00:27:34,799
client calls the function we discussed

00:27:34,000 --> 00:27:38,240
earlier

00:27:34,799 --> 00:27:38,240
ls quick con make stream

00:27:39,440 --> 00:27:44,799
now on this slide you can see that

00:27:42,799 --> 00:27:46,000
similar to previous slide on connection

00:27:44,799 --> 00:27:48,080
new

00:27:46,000 --> 00:27:49,840
you can create a per stream context and

00:27:48,080 --> 00:27:51,279
associated with the stream by returning

00:27:49,840 --> 00:27:53,200
it

00:27:51,279 --> 00:27:54,559
uh this is the stream context which will

00:27:53,200 --> 00:27:56,640
be associated with the stream for the

00:27:54,559 --> 00:27:58,559
duration of its lifetime

00:27:56,640 --> 00:28:00,320
and just as before it's okay return null

00:27:58,559 --> 00:28:03,120
you're not forced to create a

00:28:00,320 --> 00:28:03,679
context for the stream and if your

00:28:03,120 --> 00:28:07,279
client

00:28:03,679 --> 00:28:08,640
and this is the request

00:28:07,279 --> 00:28:10,799
the stream that you're going to write

00:28:08,640 --> 00:28:12,399
the request on here you would like to

00:28:10,799 --> 00:28:12,880
indicate that you want to write to this

00:28:12,399 --> 00:28:15,840
stream

00:28:12,880 --> 00:28:17,600
by using lsq extreme won't write and

00:28:15,840 --> 00:28:20,480
passing it the true value

00:28:17,600 --> 00:28:20,799
this will cause uh the ls quick to call

00:28:20,480 --> 00:28:24,320
the

00:28:20,799 --> 00:28:25,840
on write event when

00:28:24,320 --> 00:28:28,399
appropriate when the stream becomes

00:28:25,840 --> 00:28:30,080
writable if you're the server

00:28:28,399 --> 00:28:33,200
then you'll probably want to call lsq

00:28:30,080 --> 00:28:35,279
extreme one treat and that will call the

00:28:33,200 --> 00:28:37,679
stream on read event when stream becomes

00:28:35,279 --> 00:28:37,679
readable

00:28:40,320 --> 00:28:44,480
and here is the on read call the inside

00:28:43,600 --> 00:28:46,000
this callback

00:28:44,480 --> 00:28:48,880
you will be able to read from stream or

00:28:46,000 --> 00:28:50,480
to collect an error

00:28:48,880 --> 00:28:52,159
to read the data or collect the area you

00:28:50,480 --> 00:28:53,520
should call the same function lsq

00:28:52,159 --> 00:28:56,880
extreme read

00:28:53,520 --> 00:28:58,799
and it returns a sign size type

00:28:56,880 --> 00:29:00,720
and if it's negative value it means an

00:28:58,799 --> 00:29:03,039
error has occurred

00:29:00,720 --> 00:29:04,720
uh the usual error is the e-wood block

00:29:03,039 --> 00:29:07,200
which means that you can't read from

00:29:04,720 --> 00:29:08,640
stream yet this occurs if you

00:29:07,200 --> 00:29:10,880
read a couple of time frame stream or

00:29:08,640 --> 00:29:13,760
just read in a loop

00:29:10,880 --> 00:29:15,919
um but if there's a different error such

00:29:13,760 --> 00:29:19,679
as a protocol error or library error

00:29:15,919 --> 00:29:19,679
the connection is going to be aborted

00:29:21,919 --> 00:29:25,039
and here you can see that zero means

00:29:23,919 --> 00:29:28,720
that you've reached the

00:29:25,039 --> 00:29:28,720
end of stream when reading

00:29:30,480 --> 00:29:36,240
the on write event looks like this it is

00:29:33,760 --> 00:29:37,440
called when stream can be written to

00:29:36,240 --> 00:29:40,080
at this point you should be able to

00:29:37,440 --> 00:29:42,399
write at least one byte to the stream

00:29:40,080 --> 00:29:44,159
as with the on read callback for this

00:29:42,399 --> 00:29:45,200
callback to be called the user must have

00:29:44,159 --> 00:29:48,240
registered interest

00:29:45,200 --> 00:29:50,480
in writing by calling lsq extreme want

00:29:48,240 --> 00:29:52,399
write function

00:29:50,480 --> 00:29:54,960
and here we can see that after we are

00:29:52,399 --> 00:29:58,000
done writing all the data we wanted

00:29:54,960 --> 00:29:59,360
we can call ls quick stream close

00:29:58,000 --> 00:30:01,120
which will close both reading and

00:29:59,360 --> 00:30:03,360
writing side of the string

00:30:01,120 --> 00:30:09,039
and that will cause the on clause

00:30:03,360 --> 00:30:11,279
connection to be called

00:30:09,039 --> 00:30:13,279
uh when reading and writing ends once

00:30:11,279 --> 00:30:15,279
callback is called

00:30:13,279 --> 00:30:16,720
after this function returns the stream

00:30:15,279 --> 00:30:19,120
pointer becomes invalid

00:30:16,720 --> 00:30:20,240
don't reference it afterwards the

00:30:19,120 --> 00:30:22,799
library will delete it

00:30:20,240 --> 00:30:24,399
in appropriate appropriate time uh

00:30:22,799 --> 00:30:27,440
here's a good time to clean up your

00:30:24,399 --> 00:30:27,440
press stream connection

00:30:28,320 --> 00:30:32,159
here we can see that we call free at the

00:30:30,480 --> 00:30:33,919
end of this callback

00:30:32,159 --> 00:30:36,320
and also just for example if there is no

00:30:33,919 --> 00:30:38,880
more connections a request to send

00:30:36,320 --> 00:30:40,480
we can call ls quick concludes to close

00:30:38,880 --> 00:30:43,200
the connection

00:30:40,480 --> 00:30:47,039
now when lsk can close this code or the

00:30:43,200 --> 00:30:47,039
peers sends the connection closed frame

00:30:47,120 --> 00:30:53,840
or an error occurs the on connection

00:30:51,360 --> 00:30:54,559
closed stream is called uh oh now is the

00:30:53,840 --> 00:30:56,960
example

00:30:54,559 --> 00:30:58,720
of a stream on close event in the

00:30:56,960 --> 00:31:00,720
tutorial program

00:30:58,720 --> 00:31:02,080
this is the server part you can see that

00:31:00,720 --> 00:31:04,000
we cast the second

00:31:02,080 --> 00:31:05,120
argument to our stream context and we

00:31:04,000 --> 00:31:09,760
freed

00:31:05,120 --> 00:31:09,760
and then we log a message pretty simple

00:31:13,679 --> 00:31:20,640
and here's the on connection close

00:31:18,000 --> 00:31:21,840
um you can see that similar to on-stream

00:31:20,640 --> 00:31:25,440
close we

00:31:21,840 --> 00:31:27,440
free the context and if

00:31:25,440 --> 00:31:28,799
we're closing the connection we exit the

00:31:27,440 --> 00:31:32,240
event loop

00:31:28,799 --> 00:31:34,080
for example also after this function

00:31:32,240 --> 00:31:35,679
returns the connection pointer becomes

00:31:34,080 --> 00:31:38,799
invalid the library will destroy it

00:31:35,679 --> 00:31:38,799
do not reference it again

00:31:39,760 --> 00:31:43,760
here is the example from the tutorial

00:31:42,399 --> 00:31:45,519
program

00:31:43,760 --> 00:31:47,519
the per connection context is simply

00:31:45,519 --> 00:31:50,080
pointed to the tutorial struct

00:31:47,519 --> 00:31:50,880
so we don't need to free it on the other

00:31:50,080 --> 00:31:54,159
hand

00:31:50,880 --> 00:31:55,840
we do stop the event loop that's because

00:31:54,159 --> 00:31:57,519
our tutorial program is a very simple

00:31:55,840 --> 00:31:59,840
client it makes a single connection

00:31:57,519 --> 00:32:02,720
and when connection exits there is no

00:31:59,840 --> 00:32:02,720
reason to continue

00:32:07,760 --> 00:32:12,480
more about streams to reduce buffering

00:32:11,120 --> 00:32:14,159
bytes written to stream are written to

00:32:12,480 --> 00:32:16,720
package directly

00:32:14,159 --> 00:32:17,440
except when they aren't what else quick

00:32:16,720 --> 00:32:19,679
does is

00:32:17,440 --> 00:32:21,840
tries to create full packets otherwise

00:32:19,679 --> 00:32:24,399
it buffers

00:32:21,840 --> 00:32:25,919
these bytes in the stream there's a

00:32:24,399 --> 00:32:30,399
function ls quick

00:32:25,919 --> 00:32:30,399
stream flush that flushes the bytes out

00:32:30,559 --> 00:32:33,760
it is impossible to write more data than

00:32:32,240 --> 00:32:35,519
the congestion window

00:32:33,760 --> 00:32:37,039
this prevents excessive buffering inside

00:32:35,519 --> 00:32:38,880
the library

00:32:37,039 --> 00:32:40,960
inside the on read and write callbacks

00:32:38,880 --> 00:32:43,039
reading and writing should succeed

00:32:40,960 --> 00:32:46,159
the exception is error collection which

00:32:43,039 --> 00:32:48,559
happens inside the onread callback

00:32:46,159 --> 00:32:50,480
by default all read and write callbacks

00:32:48,559 --> 00:32:52,000
are going to be called in a loop

00:32:50,480 --> 00:32:53,919
so if you're done reading from writing

00:32:52,000 --> 00:32:55,360
to stream you should either shut down

00:32:53,919 --> 00:32:57,440
the appropriate end

00:32:55,360 --> 00:32:58,559
close the stream or unregister your

00:32:57,440 --> 00:33:01,120
interest

00:32:58,559 --> 00:33:03,039
from reading and writing by calling one

00:33:01,120 --> 00:33:04,240
three or one tried function with a false

00:33:03,039 --> 00:33:07,519
argument

00:33:04,240 --> 00:33:09,519
otherwise you'll enter in infinite loop

00:33:07,519 --> 00:33:11,760
now by default ls quick implements a

00:33:09,519 --> 00:33:13,760
circuit breaker by watching progress

00:33:11,760 --> 00:33:15,360
whether or not the callback is making

00:33:13,760 --> 00:33:17,200
progress leading to

00:33:15,360 --> 00:33:18,799
reading from a writing to stream and it

00:33:17,200 --> 00:33:21,200
will break you out

00:33:18,799 --> 00:33:23,039
this particular feature saved my butt a

00:33:21,200 --> 00:33:25,519
couple of times

00:33:23,039 --> 00:33:26,480
now um outside of the callbacks be ready

00:33:25,519 --> 00:33:28,880
to handle errors

00:33:26,480 --> 00:33:30,320
you don't have to read from stream or

00:33:28,880 --> 00:33:31,760
write to stream inside the callback you

00:33:30,320 --> 00:33:33,440
can do it outside the callback is not

00:33:31,760 --> 00:33:35,600
recommended but you can do it

00:33:33,440 --> 00:33:37,519
uh then you have to be able to handle uh

00:33:35,600 --> 00:33:38,720
return values of minus one from read

00:33:37,519 --> 00:33:40,799
function

00:33:38,720 --> 00:33:42,320
or return values of 0 from write

00:33:40,799 --> 00:33:44,640
function when you could not write to

00:33:42,320 --> 00:33:44,640
stream

00:33:49,600 --> 00:33:53,200
and here are some more useful string

00:33:51,440 --> 00:33:54,960
functions as mentioned before

00:33:53,200 --> 00:33:57,600
lsq extreme flash will cause the stream

00:33:54,960 --> 00:33:59,519
to packetize the buffer data

00:33:57,600 --> 00:34:00,640
uh no that may not happen immediately

00:33:59,519 --> 00:34:02,480
because there might not be enough

00:34:00,640 --> 00:34:05,279
congestion window to

00:34:02,480 --> 00:34:06,000
to do so what happens instead is that

00:34:05,279 --> 00:34:09,520
the stream

00:34:06,000 --> 00:34:10,879
schedules a flush of buffers to

00:34:09,520 --> 00:34:14,159
particular offset

00:34:10,879 --> 00:34:14,159
and it does it when possible

00:34:14,240 --> 00:34:19,040
shut down and close are modeled on the

00:34:16,240 --> 00:34:21,520
regular shutdown and close

00:34:19,040 --> 00:34:22,960
functions in unix and they take the same

00:34:21,520 --> 00:34:24,560
arguments

00:34:22,960 --> 00:34:26,639
now after both ends of the stream are

00:34:24,560 --> 00:34:29,280
closed the on stream close

00:34:26,639 --> 00:34:29,280
will be called

00:34:33,679 --> 00:34:38,879
now strip return values

00:34:36,720 --> 00:34:40,480
now read and write a modeled on the

00:34:38,879 --> 00:34:42,800
standard reading right

00:34:40,480 --> 00:34:44,159
including the use of erno the two most

00:34:42,800 --> 00:34:47,119
important error codes

00:34:44,159 --> 00:34:48,720
are he would block and econ reset

00:34:47,119 --> 00:34:50,159
because you may encounter them during

00:34:48,720 --> 00:34:52,240
regular programming

00:34:50,159 --> 00:34:53,679
even if you do everything correctly the

00:34:52,240 --> 00:34:55,520
first one he would block

00:34:53,679 --> 00:34:57,680
means that you could not read from

00:34:55,520 --> 00:34:59,680
stream and you should try again

00:34:57,680 --> 00:35:03,760
econ reset means that the stream was

00:34:59,680 --> 00:35:07,920
reset and that's sort of an application

00:35:03,760 --> 00:35:09,359
thing other errors should not happen

00:35:07,920 --> 00:35:11,359
and usually when there's a protocol

00:35:09,359 --> 00:35:16,480
error or library error your connection

00:35:11,359 --> 00:35:18,560
will be aborted

00:35:16,480 --> 00:35:20,240
note that return values of 0 are

00:35:18,560 --> 00:35:22,720
different for reads and write for read

00:35:20,240 --> 00:35:24,320
it means that you have read the end of

00:35:22,720 --> 00:35:25,440
stream marker and you should stop

00:35:24,320 --> 00:35:27,119
reading

00:35:25,440 --> 00:35:28,800
for writes it means that you can write

00:35:27,119 --> 00:35:30,400
no more

00:35:28,800 --> 00:35:31,920
when writing to a stream returns an

00:35:30,400 --> 00:35:34,800
error it may mean

00:35:31,920 --> 00:35:37,520
that a memory location failed in which

00:35:34,800 --> 00:35:39,680
case you should be able to retry later

00:35:37,520 --> 00:35:40,560
or it may it will probably mean a

00:35:39,680 --> 00:35:43,280
protocol error

00:35:40,560 --> 00:35:44,720
or an application or a library error in

00:35:43,280 --> 00:35:45,920
that case your connection will be

00:35:44,720 --> 00:35:48,960
aborted

00:35:45,920 --> 00:35:49,760
you should not encounter a return value

00:35:48,960 --> 00:35:53,680
of -1

00:35:49,760 --> 00:35:53,680
during regular programming when calling

00:35:56,839 --> 00:36:01,920
right more ways to read and write

00:35:59,280 --> 00:36:02,880
um there's the scatter gather form of

00:36:01,920 --> 00:36:04,800
reading and writing

00:36:02,880 --> 00:36:07,119
and it is modeled on the standard readv

00:36:04,800 --> 00:36:09,520
and write view functions

00:36:07,119 --> 00:36:11,040
all return values and error codes are

00:36:09,520 --> 00:36:13,040
the same as for the

00:36:11,040 --> 00:36:14,400
read and write functions we covered

00:36:13,040 --> 00:36:16,240
before

00:36:14,400 --> 00:36:18,560
which makes sense because those

00:36:16,240 --> 00:36:21,680
functions are simply wrappers around the

00:36:18,560 --> 00:36:21,680
scattergather versions

00:36:22,960 --> 00:36:27,440
read using a callback what's interesting

00:36:25,920 --> 00:36:29,200
is that the scattergather functions

00:36:27,440 --> 00:36:31,119
themselves are wrappers

00:36:29,200 --> 00:36:32,800
around functions that implement reading

00:36:31,119 --> 00:36:34,800
and writing using a function

00:36:32,800 --> 00:36:36,400
uh read f and write the functions that

00:36:34,800 --> 00:36:38,720
use a callback

00:36:36,400 --> 00:36:40,160
uh so one of those functions is ls quick

00:36:38,720 --> 00:36:42,240
stream read f

00:36:40,160 --> 00:36:45,280
and it has passed the callback to

00:36:42,240 --> 00:36:47,119
process incoming data directly

00:36:45,280 --> 00:36:48,560
the callback returns number of bytes

00:36:47,119 --> 00:36:50,720
processed and is passed

00:36:48,560 --> 00:36:54,000
pointed to the supplied object which is

00:36:50,720 --> 00:36:56,640
the third argument to read f function

00:36:54,000 --> 00:36:57,119
as well as the data which can be zero

00:36:56,640 --> 00:36:59,359
length

00:36:57,119 --> 00:37:00,560
and the fin marker which indicates that

00:36:59,359 --> 00:37:03,599
after this

00:37:00,560 --> 00:37:05,920
land bytes end of stream marker is

00:37:03,599 --> 00:37:05,920
coming

00:37:07,680 --> 00:37:10,960
now this callback is called in a loop

00:37:10,320 --> 00:37:12,960
until

00:37:10,960 --> 00:37:15,040
it returns zero or until it returns a

00:37:12,960 --> 00:37:17,280
value that is smaller than len

00:37:15,040 --> 00:37:20,560
which indicates a short read and then

00:37:17,280 --> 00:37:20,560
the stream will stop calling this

00:37:20,839 --> 00:37:25,119
callback

00:37:23,119 --> 00:37:27,920
stream read copy data so here is the

00:37:25,119 --> 00:37:30,560
example of reading

00:37:27,920 --> 00:37:30,960
from the tutorial you can see it's v0

00:37:30,560 --> 00:37:33,599
because

00:37:30,960 --> 00:37:34,960
this is default version the client

00:37:33,599 --> 00:37:37,280
possesses three different

00:37:34,960 --> 00:37:39,359
onread callbacks and you can select

00:37:37,280 --> 00:37:44,480
which one to use by using the dashb

00:37:39,359 --> 00:37:44,480
command line flag dash b0 is the default

00:37:44,960 --> 00:37:49,280
so here the three byte buffer is here

00:37:46,960 --> 00:37:51,280
just for illustration purposes

00:37:49,280 --> 00:37:53,920
just to illustrate that this callback is

00:37:51,280 --> 00:37:57,599
indeed called in a loop

00:37:53,920 --> 00:37:57,599
this is a pretty simple way to read

00:37:59,520 --> 00:38:04,320
stream read take two using a callback

00:38:02,560 --> 00:38:06,240
and here's the second version of the

00:38:04,320 --> 00:38:10,560
clients on stream read

00:38:06,240 --> 00:38:12,960
callback on the command line use the b1

00:38:10,560 --> 00:38:14,800
here we use the lsq extreme reader

00:38:12,960 --> 00:38:15,440
function and this example is put into

00:38:14,800 --> 00:38:18,560
two side

00:38:15,440 --> 00:38:20,640
two parts because we don't

00:38:18,560 --> 00:38:22,320
because we just print the data to

00:38:20,640 --> 00:38:25,680
standard out we don't need to pass

00:38:22,320 --> 00:38:28,960
any extra user data to the

00:38:25,680 --> 00:38:30,800
callback and we just pass null and if

00:38:28,960 --> 00:38:33,839
zero is returned it means that we hit

00:38:30,800 --> 00:38:33,839
the end of stream

00:38:37,440 --> 00:38:42,160
and here's the callback itself for the

00:38:39,440 --> 00:38:45,040
second version of the onread

00:38:42,160 --> 00:38:45,599
callback so here you can see that we

00:38:45,040 --> 00:38:47,040
just

00:38:45,599 --> 00:38:49,359
write the data if there is a need to be

00:38:47,040 --> 00:38:51,680
had to stand it out and return the

00:38:49,359 --> 00:38:51,680
length

00:38:55,680 --> 00:38:58,720
note that the data size length can be

00:38:57,520 --> 00:39:02,079
anything

00:38:58,720 --> 00:39:05,760
this size is not limited by

00:39:02,079 --> 00:39:07,920
the maximum diagram size uh because

00:39:05,760 --> 00:39:10,000
if helisquik detects a stream

00:39:07,920 --> 00:39:11,520
fragmentation attack open in in short if

00:39:10,000 --> 00:39:13,119
there is excessive fragmentation

00:39:11,520 --> 00:39:14,720
incoming string frames

00:39:13,119 --> 00:39:16,400
it switches to more robust data

00:39:14,720 --> 00:39:17,200
structure for incoming data and starts

00:39:16,400 --> 00:39:19,440
copying

00:39:17,200 --> 00:39:21,680
into the data structure so you may be

00:39:19,440 --> 00:39:23,520
given a much larger chunk of data to

00:39:21,680 --> 00:39:25,119
process

00:39:23,520 --> 00:39:27,119
so don't rely on length to be any

00:39:25,119 --> 00:39:28,640
particular value

00:39:27,119 --> 00:39:30,000
and to stop reading using this callback

00:39:28,640 --> 00:39:31,920
as i mentioned before you can just

00:39:30,000 --> 00:39:35,040
return zero

00:39:31,920 --> 00:39:38,480
or uh return a value smaller than len

00:39:35,040 --> 00:39:39,040
or you can make ls quick apart this is

00:39:38,480 --> 00:39:43,839
uh

00:39:39,040 --> 00:39:43,839
going to be the next slide

00:39:44,800 --> 00:39:48,720
and here's the third version uh you may

00:39:47,200 --> 00:39:50,079
have noticed that in previous version we

00:39:48,720 --> 00:39:52,320
didn't do anything with the fin

00:39:50,079 --> 00:39:54,160
indicator and here we're going to use it

00:39:52,320 --> 00:39:57,839
to stop reading as soon as we hit

00:39:54,160 --> 00:40:00,240
thin this is a little bit more uh

00:39:57,839 --> 00:40:03,200
efficient because we save on this uh on

00:40:00,240 --> 00:40:03,200
one on read call

00:40:04,000 --> 00:40:07,200
so here we package pointers to the

00:40:06,400 --> 00:40:10,400
tutorials

00:40:07,200 --> 00:40:13,359
uh struct and the stream into a special

00:40:10,400 --> 00:40:15,280
v2 ctx struct and we pass the pointer to

00:40:13,359 --> 00:40:18,880
it to read f

00:40:15,280 --> 00:40:22,400
and the callback is on the next slide

00:40:18,880 --> 00:40:23,200
and here's the callback used for the

00:40:22,400 --> 00:40:25,839
third version

00:40:23,200 --> 00:40:27,839
of onreadcallback you can see now it is

00:40:25,839 --> 00:40:30,880
more complicated because we've moved the

00:40:27,839 --> 00:40:31,599
logic to shut down the reading side of

00:40:30,880 --> 00:40:34,480
the stream

00:40:31,599 --> 00:40:35,760
and to restart the event loop into this

00:40:34,480 --> 00:40:37,920
function

00:40:35,760 --> 00:40:39,920
as before we write data to standard out

00:40:37,920 --> 00:40:43,520
but if we hit the fin

00:40:39,920 --> 00:40:53,839
then we're going to call stream shutdown

00:40:43,520 --> 00:40:53,839
and restart reading from standard input

00:40:55,760 --> 00:40:59,839
just to make things interesting uh it is

00:40:57,839 --> 00:41:01,440
the server that possesses different ways

00:40:59,839 --> 00:41:03,520
to write from

00:41:01,440 --> 00:41:06,000
stream and there are two ways here is

00:41:03,520 --> 00:41:08,079
the first one this is the default

00:41:06,000 --> 00:41:10,079
on the server command line you can

00:41:08,079 --> 00:41:12,240
select w0

00:41:10,079 --> 00:41:13,760
to use the default or w1 to use the

00:41:12,240 --> 00:41:16,000
second version

00:41:13,760 --> 00:41:17,440
this is the default it calls lsq extreme

00:41:16,000 --> 00:41:19,760
write

00:41:17,440 --> 00:41:20,480
and if it returns a positive number then

00:41:19,760 --> 00:41:22,880
we

00:41:20,480 --> 00:41:24,240
advance the pointer and we if if we have

00:41:22,880 --> 00:41:26,560
written as much as we

00:41:24,240 --> 00:41:28,560
intended to then we can just close the

00:41:26,560 --> 00:41:31,359
stream

00:41:28,560 --> 00:41:31,359
so this is a

00:41:33,200 --> 00:41:37,839
simple and here to use the second

00:41:36,000 --> 00:41:41,440
version we're going to use the

00:41:37,839 --> 00:41:43,119
lsq extreme right f function

00:41:41,440 --> 00:41:44,640
it is a little bit more involved because

00:41:43,119 --> 00:41:45,359
instead of just passing a single

00:41:44,640 --> 00:41:47,119
callback

00:41:45,359 --> 00:41:48,800
we pass a pointer to a struct that

00:41:47,119 --> 00:41:51,839
contains two

00:41:48,800 --> 00:41:53,680
callbacks one is to read data or to

00:41:51,839 --> 00:41:56,000
capture data to the packet

00:41:53,680 --> 00:41:56,960
and the second callback is the size

00:41:56,000 --> 00:42:00,000
callback which

00:41:56,960 --> 00:42:02,079
tells you how many bytes you have left

00:42:00,000 --> 00:42:03,839
this is useful when the data source

00:42:02,079 --> 00:42:05,119
you're reading from may change in size

00:42:03,839 --> 00:42:07,680
such as when reading from the file

00:42:05,119 --> 00:42:07,680
descriptor

00:42:08,960 --> 00:42:17,839
and here is the second version of onride

00:42:11,040 --> 00:42:17,839
callback for the server

00:42:20,079 --> 00:42:24,160
you can see that the reader is

00:42:21,599 --> 00:42:27,280
initialized uh with

00:42:24,160 --> 00:42:28,400
the read and size function pointers

00:42:27,280 --> 00:42:29,359
we're going to cover them in following

00:42:28,400 --> 00:42:32,640
slides

00:42:29,359 --> 00:42:35,760
and the tcc tscc

00:42:32,640 --> 00:42:37,839
struct and we call right f we examine

00:42:35,760 --> 00:42:39,520
the return value of

00:42:37,839 --> 00:42:44,290
this writer function and we call the

00:42:39,520 --> 00:42:46,000
stream if we're done writing

00:42:44,290 --> 00:42:49,280
[Music]

00:42:46,000 --> 00:42:50,720
here's the size callback now the size is

00:42:49,280 --> 00:42:51,200
pretty simple it just returns number of

00:42:50,720 --> 00:42:53,520
sizes

00:42:51,200 --> 00:42:53,520
left

00:42:54,560 --> 00:42:58,000
and here's the reader read callback now

00:42:57,200 --> 00:43:01,200
read callback

00:42:58,000 --> 00:43:04,960
is called read callback because you read

00:43:01,200 --> 00:43:06,640
from data source and write to the packet

00:43:04,960 --> 00:43:08,160
now here you pass the count and you're

00:43:06,640 --> 00:43:12,560
supposed to

00:43:08,160 --> 00:43:15,520
copy no more than count bytes to buffer

00:43:12,560 --> 00:43:16,560
and the return number of bytes written

00:43:15,520 --> 00:43:19,920
now count

00:43:16,560 --> 00:43:22,240
is calculated using the size callback

00:43:19,920 --> 00:43:24,640
and note that even though in our example

00:43:22,240 --> 00:43:26,960
this value count is never larger

00:43:24,640 --> 00:43:28,400
than the number of bytes left in a

00:43:26,960 --> 00:43:30,079
different situation when you were

00:43:28,400 --> 00:43:32,160
reading from file descriptor

00:43:30,079 --> 00:43:33,520
and the file could be truncated you

00:43:32,160 --> 00:43:35,200
could actually pass the

00:43:33,520 --> 00:43:36,480
number larger than how many bytes you

00:43:35,200 --> 00:43:37,359
have left in which case you have to

00:43:36,480 --> 00:43:41,839
check

00:43:37,359 --> 00:43:41,839
something to be aware of

00:43:47,040 --> 00:43:51,760
client making the connection are there

00:43:48,880 --> 00:43:51,760
any questions

00:43:52,079 --> 00:43:55,839
about the stuff i've covered so far

00:44:00,319 --> 00:44:03,760
it doesn't seem like there are questions

00:44:01,520 --> 00:44:05,599
so i'm going to continue

00:44:03,760 --> 00:44:08,079
we now switch our attention to making a

00:44:05,599 --> 00:44:10,160
quick connection from the client

00:44:08,079 --> 00:44:12,560
the functionalist quick engine connect

00:44:10,160 --> 00:44:15,200
does that it has

00:44:12,560 --> 00:44:16,720
12 arguments these arguments have

00:44:15,200 --> 00:44:18,240
accreted over the years

00:44:16,720 --> 00:44:20,720
we're going to cover them one by one on

00:44:18,240 --> 00:44:22,160
this slide and on the next slide we're

00:44:20,720 --> 00:44:24,560
going to look at the example from the

00:44:22,160 --> 00:44:26,560
tutorial program

00:44:24,560 --> 00:44:28,000
so the first argument is the pointer to

00:44:26,560 --> 00:44:30,560
the engine

00:44:28,000 --> 00:44:32,880
the second argument is the version which

00:44:30,560 --> 00:44:35,520
needs to be used to

00:44:32,880 --> 00:44:36,880
the version of the connection you prefer

00:44:35,520 --> 00:44:39,119
the second two arguments

00:44:36,880 --> 00:44:40,800
are pointers to local and pure saket

00:44:39,119 --> 00:44:43,920
addresses

00:44:40,800 --> 00:44:45,599
next argument is the pure context

00:44:43,920 --> 00:44:47,280
the sixth argument is the connection

00:44:45,599 --> 00:44:49,440
context

00:44:47,280 --> 00:44:51,680
now this connection context pointer is

00:44:49,440 --> 00:44:54,240
useful if you want to pass a value

00:44:51,680 --> 00:44:56,000
to the on connection to the on new

00:44:54,240 --> 00:44:57,200
connection callback

00:44:56,000 --> 00:44:58,720
now note that this is a connection

00:44:57,200 --> 00:45:01,760
context so it's going to be overwritten

00:44:58,720 --> 00:45:04,720
by the return value of that callback

00:45:01,760 --> 00:45:05,040
uh the seventh argument is hostname and

00:45:04,720 --> 00:45:08,640
in

00:45:05,040 --> 00:45:11,359
quick an itf quick it is used for sni

00:45:08,640 --> 00:45:12,400
uh next argument is the maximum udp

00:45:11,359 --> 00:45:14,400
datagram size

00:45:12,400 --> 00:45:15,760
and it's going to be used as the base pl

00:45:14,400 --> 00:45:19,520
pmtu

00:45:15,760 --> 00:45:20,319
if dplpmtud support is enabled in the ls

00:45:19,520 --> 00:45:23,680
quick

00:45:20,319 --> 00:45:23,680
and it is enabled by default

00:45:23,839 --> 00:45:28,319
the next two arguments point to

00:45:26,400 --> 00:45:30,319
resumption information

00:45:28,319 --> 00:45:32,000
which allow you to resume session and in

00:45:30,319 --> 00:45:35,599
itf quick it's usually

00:45:32,000 --> 00:45:37,599
just a pointer the tls session ticket

00:45:35,599 --> 00:45:39,520
and the last two arguments are pointer

00:45:37,599 --> 00:45:42,880
to a token

00:45:39,520 --> 00:45:44,880
and these are the

00:45:42,880 --> 00:45:46,960
token will allow you to bypass

00:45:44,880 --> 00:45:50,160
potentially a server-side

00:45:46,960 --> 00:45:52,480
stateless retry now session resume

00:45:50,160 --> 00:45:54,000
information and the token can be gotten

00:45:52,480 --> 00:45:56,000
from a previous connection

00:45:54,000 --> 00:45:59,040
using the optional callbacks one is

00:45:56,000 --> 00:46:01,440
called on search resume information

00:45:59,040 --> 00:46:03,520
and the other one is called on new token

00:46:01,440 --> 00:46:08,319
if this callbacks are not specified

00:46:03,520 --> 00:46:08,319
you get you don't get this information

00:46:09,119 --> 00:46:12,319
now let's look at the example

00:46:12,480 --> 00:46:16,000
before the example let's talk about uh

00:46:14,560 --> 00:46:17,920
quick versions

00:46:16,000 --> 00:46:19,280
uh quick versions in ls quick are

00:46:17,920 --> 00:46:22,319
gathered in an inum

00:46:19,280 --> 00:46:24,640
ls quick version the actual value

00:46:22,319 --> 00:46:25,440
of this enum is not important the

00:46:24,640 --> 00:46:28,880
special value

00:46:25,440 --> 00:46:30,800
nlsqvar specifies to ls quick engine

00:46:28,880 --> 00:46:31,920
connect to pick a default version and by

00:46:30,800 --> 00:46:33,760
default

00:46:31,920 --> 00:46:36,000
ls3 will pick the highest

00:46:33,760 --> 00:46:38,240
non-experimental version

00:46:36,000 --> 00:46:39,280
uh non-experimental from the point of

00:46:38,240 --> 00:46:42,319
view of ls quick

00:46:39,280 --> 00:46:43,760
so for example it supports the internet

00:46:42,319 --> 00:46:45,920
draft 29

00:46:43,760 --> 00:46:46,960
very well even though internet 29 is

00:46:45,920 --> 00:46:50,560
experimental

00:46:46,960 --> 00:46:54,400
in the eyes of uh itf

00:46:50,560 --> 00:46:54,960
um now because version unknown values

00:46:54,400 --> 00:46:57,760
are small

00:46:54,960 --> 00:46:58,400
and that's by design a list of versions

00:46:57,760 --> 00:47:00,160
can be

00:46:58,400 --> 00:47:01,599
packed into a bitmask and passed around

00:47:00,160 --> 00:47:05,520
like that and in in

00:47:01,599 --> 00:47:08,480
a few places in the lsq api it is done

00:47:05,520 --> 00:47:10,079
uh one prominent place is the settings

00:47:08,480 --> 00:47:11,680
member es versions

00:47:10,079 --> 00:47:13,280
which is just a bit mask of supported

00:47:11,680 --> 00:47:15,119
versions and by default

00:47:13,280 --> 00:47:17,520
ls click engine will support all the

00:47:15,119 --> 00:47:17,520
versions

00:47:19,119 --> 00:47:22,400
and here's the connect call from the

00:47:20,559 --> 00:47:23,440
tutorial program to that see you can see

00:47:22,400 --> 00:47:24,960
that

00:47:23,440 --> 00:47:26,640
it is a lot less intimidating than

00:47:24,960 --> 00:47:28,160
before because half the arguments are

00:47:26,640 --> 00:47:30,079
set to zero

00:47:28,160 --> 00:47:31,440
uh so first we see the pointer to the

00:47:30,079 --> 00:47:34,960
engine and the

00:47:31,440 --> 00:47:39,280
lsqr lsqvar special value

00:47:34,960 --> 00:47:41,440
uh we passed to uh socket addresses

00:47:39,280 --> 00:47:43,119
and we cast our file descriptor to a

00:47:41,440 --> 00:47:47,760
pointer

00:47:43,119 --> 00:47:47,760
and the rest is zero and off you go

00:47:49,680 --> 00:47:53,040
now the peer contact the the socket file

00:47:51,920 --> 00:47:54,960
descriptor

00:47:53,040 --> 00:47:58,640
is what will get passed to the sent

00:47:54,960 --> 00:47:58,640
packets out this is the peer context

00:48:00,880 --> 00:48:06,160
server additional callbacks now the

00:48:03,920 --> 00:48:07,920
server requires an ssl contacts to be

00:48:06,160 --> 00:48:09,599
sll callbacks to be present the basic

00:48:07,920 --> 00:48:12,800
callback is the

00:48:09,599 --> 00:48:14,559
get ssl ctx because it is used to create

00:48:12,800 --> 00:48:17,760
tls connections

00:48:14,559 --> 00:48:20,960
uh in case sni is used lsq will use ea

00:48:17,760 --> 00:48:22,640
lookup cert callback for example in our

00:48:20,960 --> 00:48:25,680
web server

00:48:22,640 --> 00:48:26,400
each virtual host has its own ssl

00:48:25,680 --> 00:48:29,280
context

00:48:26,400 --> 00:48:29,680
and this function allows one to look up

00:48:29,280 --> 00:48:33,280
the

00:48:29,680 --> 00:48:35,440
necessary virtual host by sni

00:48:33,280 --> 00:48:36,640
notice that the lookup function besides

00:48:35,440 --> 00:48:38,480
the sni

00:48:36,640 --> 00:48:39,680
also provides a point to the local

00:48:38,480 --> 00:48:42,400
address

00:48:39,680 --> 00:48:45,200
and this makes for a nice flexible

00:48:42,400 --> 00:48:45,200
lookup function

00:48:47,440 --> 00:48:53,440
engine settings beside the engine api

00:48:51,680 --> 00:48:55,760
passed to the uh

00:48:53,440 --> 00:48:57,599
engine constructor there's also an

00:48:55,760 --> 00:49:00,319
engine settings truck

00:48:57,599 --> 00:49:01,200
ls quick engine settings uh the ea

00:49:00,319 --> 00:49:04,720
settings member

00:49:01,200 --> 00:49:06,960
of the ls of the engine api can be

00:49:04,720 --> 00:49:09,440
pointed to these settings which is

00:49:06,960 --> 00:49:10,400
settings are null by default now there

00:49:09,440 --> 00:49:12,240
are many settings

00:49:10,400 --> 00:49:14,800
controlling everything from falcon flow

00:49:12,240 --> 00:49:17,440
control windows to the number of times

00:49:14,800 --> 00:49:20,400
an on read callback is called in a loop

00:49:17,440 --> 00:49:22,880
before a circuit breaker is kicking in

00:49:20,400 --> 00:49:25,280
to make changing default settings easier

00:49:22,880 --> 00:49:26,559
because there are over 50 settings

00:49:25,280 --> 00:49:28,319
there are two auxiliary functions

00:49:26,559 --> 00:49:29,119
provided one to initialize the settings

00:49:28,319 --> 00:49:32,559
struct

00:49:29,119 --> 00:49:32,559
and one to check it for errors

00:49:33,359 --> 00:49:37,200
and here are the setting helper

00:49:34,800 --> 00:49:37,200
functions

00:49:38,559 --> 00:49:42,160
the first function is ls quick engine

00:49:40,640 --> 00:49:45,119
init settings which does

00:49:42,160 --> 00:49:46,480
just that uh the first argument is the

00:49:45,119 --> 00:49:48,160
uh

00:49:46,480 --> 00:49:50,480
ls quick engine setting struct and the

00:49:48,160 --> 00:49:53,440
second argument is the

00:49:50,480 --> 00:49:54,400
server and http flag bitmask this

00:49:53,440 --> 00:49:55,920
bitmask

00:49:54,400 --> 00:49:57,839
must be the same as the one passed to

00:49:55,920 --> 00:50:00,000
the engine constructor

00:49:57,839 --> 00:50:01,760
because the settings that depend on the

00:50:00,000 --> 00:50:04,240
value of both the server bit and the

00:50:01,760 --> 00:50:06,559
http bit

00:50:04,240 --> 00:50:09,200
the second function ls quick engine

00:50:06,559 --> 00:50:09,200
check settings

00:50:09,520 --> 00:50:12,640
takes the first two arguments which are

00:50:11,200 --> 00:50:16,240
the same as the

00:50:12,640 --> 00:50:17,680
initialization function and the two

00:50:16,240 --> 00:50:19,280
the third and fourth arguments are

00:50:17,680 --> 00:50:21,440
pointed to the error buffer

00:50:19,280 --> 00:50:23,280
in case there is an error the human

00:50:21,440 --> 00:50:24,319
readable error can be placed in this air

00:50:23,280 --> 00:50:27,520
buffer and then

00:50:24,319 --> 00:50:30,000
printed or logged this these arguments

00:50:27,520 --> 00:50:31,520
are optional

00:50:30,000 --> 00:50:33,920
now note that the check settings

00:50:31,520 --> 00:50:35,520
function only checks for basic

00:50:33,920 --> 00:50:41,280
errors uh there are many ways to

00:50:35,520 --> 00:50:42,960
misconfigure lsq so please test

00:50:41,280 --> 00:50:46,240
settings example in tutorial let's see

00:50:42,960 --> 00:50:48,559
part one of two so here we see the um

00:50:46,240 --> 00:50:49,440
this is a part of the wild get up loop

00:50:48,559 --> 00:50:51,599
in the main

00:50:49,440 --> 00:50:54,000
function you can see that we use the

00:50:51,599 --> 00:50:56,079
dash or option to specify options

00:50:54,000 --> 00:50:58,400
or settings and the dash show is

00:50:56,079 --> 00:51:00,400
followed by a name value pair separated

00:50:58,400 --> 00:51:02,559
by the equal sign

00:51:00,400 --> 00:51:04,800
the first time we see the dash o we

00:51:02,559 --> 00:51:06,400
initialize the settings

00:51:04,800 --> 00:51:08,079
and you can see that we figure out

00:51:06,400 --> 00:51:09,839
whether or not to be our client

00:51:08,079 --> 00:51:12,400
or a server based on the values of

00:51:09,839 --> 00:51:16,480
search file and key file pointers

00:51:12,400 --> 00:51:19,119
which means that dash cn-k must precede

00:51:16,480 --> 00:51:20,319
all on the command line after

00:51:19,119 --> 00:51:23,520
initialization

00:51:20,319 --> 00:51:24,240
we parse arg and in this case we change

00:51:23,520 --> 00:51:27,200
the value

00:51:24,240 --> 00:51:29,280
of uh congestion control algorithm to

00:51:27,200 --> 00:51:32,640
the one specified on the command line

00:51:29,280 --> 00:51:33,599
uh so for example cubic is one and bbr

00:51:32,640 --> 00:51:37,839
is two

00:51:33,599 --> 00:51:37,839
and default is zero

00:51:38,400 --> 00:51:43,920
settings example in total.c part two

00:51:41,920 --> 00:51:45,839
so after uh we're done processing

00:51:43,920 --> 00:51:47,119
options we call the check engine

00:51:45,839 --> 00:51:48,880
settings

00:51:47,119 --> 00:51:51,119
and here you can see how the air buffer

00:51:48,880 --> 00:51:52,960
is used if there is an error

00:51:51,119 --> 00:51:54,319
then we print it and exit with the

00:51:52,960 --> 00:51:55,599
failure

00:51:54,319 --> 00:51:57,599
and at the very end everything is

00:51:55,599 --> 00:51:59,440
checking out correctly but before the

00:51:57,599 --> 00:52:01,200
engine constructor is called

00:51:59,440 --> 00:52:02,800
we assign the pointer to the settings

00:52:01,200 --> 00:52:04,880
truck

00:52:02,800 --> 00:52:07,359
with the ea settings in the engine api

00:52:04,880 --> 00:52:07,359
struct

00:52:11,599 --> 00:52:16,960
logging mechanism let's keep provides a

00:52:15,280 --> 00:52:19,520
simple login interface

00:52:16,960 --> 00:52:21,280
with just a single callback function by

00:52:19,520 --> 00:52:22,559
default no messages are logged they're

00:52:21,280 --> 00:52:24,880
all thrown away

00:52:22,559 --> 00:52:26,079
this can be changed by calling ls quick

00:52:24,880 --> 00:52:29,440
logger init function

00:52:26,079 --> 00:52:33,440
and providing the logger function

00:52:29,440 --> 00:52:34,720
the library can generate timestamps

00:52:33,440 --> 00:52:36,800
and include them along with the error

00:52:34,720 --> 00:52:39,280
messages and this time stamps

00:52:36,800 --> 00:52:41,359
styles enumerated in the inum you can

00:52:39,280 --> 00:52:43,359
see at the bottom of the slides

00:52:41,359 --> 00:52:44,800
you can see by the name of inums what

00:52:43,359 --> 00:52:45,760
type of timestamps they are whether or

00:52:44,800 --> 00:52:48,720
not they include

00:52:45,760 --> 00:52:50,160
microseconds milliseconds or dates one

00:52:48,720 --> 00:52:53,359
of the most use useful

00:52:50,160 --> 00:52:55,760
uh time stamps styles is chrome like

00:52:53,359 --> 00:52:57,920
uh because when you develop with chrome

00:52:55,760 --> 00:53:00,640
and enable debug messages it has its own

00:52:57,920 --> 00:53:01,920
timestamp which is very strange but it

00:53:00,640 --> 00:53:04,640
is

00:53:01,920 --> 00:53:05,520
useful to compare output of your

00:53:04,640 --> 00:53:08,000
endpoint

00:53:05,520 --> 00:53:09,680
and chrome side by side in this case you

00:53:08,000 --> 00:53:15,839
can use timestamp that look exactly the

00:53:09,680 --> 00:53:15,839
same and log the same time

00:53:16,720 --> 00:53:20,079
logging levels and modules

00:53:20,480 --> 00:53:24,480
there are eight log levels in ls quick

00:53:22,400 --> 00:53:26,079
uh and this is correspond to the usual

00:53:24,480 --> 00:53:27,599
log levels and those for example in

00:53:26,079 --> 00:53:30,240
syslog

00:53:27,599 --> 00:53:33,359
but lsq uses only the first five

00:53:30,240 --> 00:53:35,760
debugging for notice warning and error

00:53:33,359 --> 00:53:37,200
usually warning and error messages are

00:53:35,760 --> 00:53:38,160
printed only when there's a bug in the

00:53:37,200 --> 00:53:40,400
library

00:53:38,160 --> 00:53:42,000
or some protocol error occurs or memory

00:53:40,400 --> 00:53:44,960
initialization or memory allocation

00:53:42,000 --> 00:53:45,599
failure other errors are not logged

00:53:44,960 --> 00:53:49,119
because

00:53:45,599 --> 00:53:50,640
it's not really lsc's job now ls peak

00:53:49,119 --> 00:53:55,359
also contains

00:53:50,640 --> 00:53:58,079
many log modules over 40 by last count

00:53:55,359 --> 00:54:00,319
each module corresponds to a particular

00:53:58,079 --> 00:54:02,960
set of functionality or component

00:54:00,319 --> 00:54:04,480
in nails quick library such as engine

00:54:02,960 --> 00:54:07,520
bbr stream connection

00:54:04,480 --> 00:54:08,559
handshake and so on one exception is the

00:54:07,520 --> 00:54:11,839
event

00:54:08,559 --> 00:54:14,400
module which is a cross

00:54:11,839 --> 00:54:17,599
cross module module and prints

00:54:14,400 --> 00:54:19,200
interesting events in all the modules

00:54:17,599 --> 00:54:21,119
so now there are two functions to change

00:54:19,200 --> 00:54:23,599
log levels and modules

00:54:21,119 --> 00:54:25,359
the first one is ls quick set log level

00:54:23,599 --> 00:54:28,240
and it changes log levels for

00:54:25,359 --> 00:54:29,359
all the modules the default log level is

00:54:28,240 --> 00:54:31,839
warning

00:54:29,359 --> 00:54:32,559
and the second function is lsk logger

00:54:31,839 --> 00:54:35,599
lapt

00:54:32,559 --> 00:54:39,839
which can set a particular which can set

00:54:35,599 --> 00:54:39,839
log levels for a particular module

00:54:41,520 --> 00:54:45,200
logging tutorial part one out of two so

00:54:44,079 --> 00:54:47,920
uh by default

00:54:45,200 --> 00:54:49,760
log log messages in the tutorial program

00:54:47,920 --> 00:54:51,920
go to standard air

00:54:49,760 --> 00:54:53,440
you can change it by using the dash f

00:54:51,920 --> 00:54:55,440
option

00:54:53,440 --> 00:54:56,640
and the dash l and dash capital l

00:54:55,440 --> 00:55:00,480
specify the

00:54:56,640 --> 00:55:02,240
log levels and here is the

00:55:00,480 --> 00:55:04,160
log function itself we can see that we

00:55:02,240 --> 00:55:06,640
simply write it to the file handle

00:55:04,160 --> 00:55:07,200
flash it and return zero uh one

00:55:06,640 --> 00:55:08,559
interesting

00:55:07,200 --> 00:55:10,000
note here is that even though this

00:55:08,559 --> 00:55:11,920
function is an end function it turns

00:55:10,000 --> 00:55:13,520
zero on success this value is ignored by

00:55:11,920 --> 00:55:15,280
as quick

00:55:13,520 --> 00:55:17,440
because it doesn't know what to do about

00:55:15,280 --> 00:55:19,839
the log function that fails

00:55:17,440 --> 00:55:21,280
i mean the only thing it could do is

00:55:19,839 --> 00:55:22,640
call this log function again for it to

00:55:21,280 --> 00:55:23,920
fail again

00:55:22,640 --> 00:55:26,559
uh and at the bottom of the slide you

00:55:23,920 --> 00:55:29,599
can see how we pass

00:55:26,559 --> 00:55:33,280
this point of this tract to the library

00:55:29,599 --> 00:55:35,520
and how we specify uh

00:55:33,280 --> 00:55:38,400
how to specify the type of timestamp

00:55:35,520 --> 00:55:38,400
that to be generated

00:55:38,960 --> 00:55:44,240
uh log into that c part two out of two

00:55:41,920 --> 00:55:44,880
and here we are inside the wild get up

00:55:44,240 --> 00:55:48,480
loop again

00:55:44,880 --> 00:55:50,880
we can see how the lowercase l invokes

00:55:48,480 --> 00:55:52,079
logger lapt function and uppercase l

00:55:50,880 --> 00:55:55,520
invokes the

00:55:52,079 --> 00:55:57,520
lsx at log level a both of this function

00:55:55,520 --> 00:56:03,839
may fail because you may have misspelled

00:55:57,520 --> 00:56:03,839
the log level or module name

00:56:03,920 --> 00:56:07,119
and here's a log messaging example this

00:56:06,640 --> 00:56:10,160
is uh

00:56:07,119 --> 00:56:10,799
taken from a client i had to break up

00:56:10,160 --> 00:56:14,240
lines

00:56:10,799 --> 00:56:16,559
and i had to align the timestamp

00:56:14,240 --> 00:56:18,559
on the left uh but here you can

00:56:16,559 --> 00:56:21,040
definitely immediately see that

00:56:18,559 --> 00:56:22,880
there is a quick connection uh logged on

00:56:21,040 --> 00:56:24,799
the left

00:56:22,880 --> 00:56:26,319
and in some of these error mess in those

00:56:24,799 --> 00:56:28,000
log messages you can see that the

00:56:26,319 --> 00:56:30,799
connection is followed by a dash

00:56:28,000 --> 00:56:32,640
and a number in this case is zero and

00:56:30,799 --> 00:56:34,319
zero corresponds to stream number

00:56:32,640 --> 00:56:35,680
so in this case we're dealing with

00:56:34,319 --> 00:56:38,720
stream number zero

00:56:35,680 --> 00:56:39,359
which is the first request uh the first

00:56:38,720 --> 00:56:41,920
one

00:56:39,359 --> 00:56:43,839
event module says that we generate a

00:56:41,920 --> 00:56:46,960
stream frame on stream 0

00:56:43,839 --> 00:56:50,319
with offset 0 and size 3 and

00:56:46,960 --> 00:56:52,000
there's a fin bit set in this frame

00:56:50,319 --> 00:56:53,839
i just tapped in high on the command

00:56:52,000 --> 00:56:55,280
line and hit enter and it's sent to the

00:56:53,839 --> 00:56:57,839
server

00:56:55,280 --> 00:56:59,920
then we see that the stream flushed past

00:56:57,839 --> 00:57:02,079
required offset three

00:56:59,920 --> 00:57:04,079
and we sent the packet so this log

00:57:02,079 --> 00:57:05,200
message is logged after send message is

00:57:04,079 --> 00:57:07,599
called

00:57:05,200 --> 00:57:10,160
it was back at number 13. uh the type is

00:57:07,599 --> 00:57:13,040
short it is forward secure

00:57:10,160 --> 00:57:15,200
32 bytes long contains the frames of

00:57:13,040 --> 00:57:15,920
only one type stream the cn value is

00:57:15,200 --> 00:57:18,160
zero

00:57:15,920 --> 00:57:19,359
spin bit to zero key phase is zero path

00:57:18,160 --> 00:57:21,760
is zero

00:57:19,359 --> 00:57:24,240
and there are some internal flags that

00:57:21,760 --> 00:57:26,880
are not important right now

00:57:24,240 --> 00:57:28,799
uh some time later we can see that we

00:57:26,880 --> 00:57:32,079
get a response packet back

00:57:28,799 --> 00:57:34,319
of size 44 and

00:57:32,079 --> 00:57:36,000
receive history which is a separate

00:57:34,319 --> 00:57:37,520
component and here you can see the

00:57:36,000 --> 00:57:40,000
module reaches

00:57:37,520 --> 00:57:41,760
is received packet number 15. uh we

00:57:40,000 --> 00:57:44,880
parse the arc frame

00:57:41,760 --> 00:57:47,760
which acts packets 9 through 13 and

00:57:44,880 --> 00:57:49,680
you can see that our packet 13 we sent

00:57:47,760 --> 00:57:52,319
before his act

00:57:49,680 --> 00:57:54,000
we're about to process a frame stream a

00:57:52,319 --> 00:57:56,160
stream frame

00:57:54,000 --> 00:57:58,160
and you know it also is on stream zero

00:57:56,160 --> 00:58:02,400
with offset zero and size three

00:57:58,160 --> 00:58:02,400
so it's just a reverse high string back

00:58:02,559 --> 00:58:06,000
and that very last uh message that's

00:58:04,720 --> 00:58:09,920
chopped a little bit at the end

00:58:06,000 --> 00:58:13,119
says di this is the data in module

00:58:09,920 --> 00:58:13,839
which i mentioned before uh ls quick has

00:58:13,119 --> 00:58:17,599
several of them

00:58:13,839 --> 00:58:19,680
to be able to switch to a robust

00:58:17,599 --> 00:58:21,680
incoming data module to prevent to

00:58:19,680 --> 00:58:25,040
mitigate

00:58:21,680 --> 00:58:25,040
stream fragmentation attacks

00:58:25,200 --> 00:58:30,000
so logging is very useful but another

00:58:27,920 --> 00:58:32,240
useful tool is wireshark

00:58:30,000 --> 00:58:34,559
wireshark supports itf quick and the

00:58:32,240 --> 00:58:37,839
wireshark developers have been very good

00:58:34,559 --> 00:58:39,920
with following the latest itf drafts

00:58:37,839 --> 00:58:42,480
you'll need version 33 for the internet

00:58:39,920 --> 00:58:46,240
draft 29 support

00:58:42,480 --> 00:58:47,440
now ls quick supports exporting tls

00:58:46,240 --> 00:58:49,760
secrets

00:58:47,440 --> 00:58:50,799
using its key log interface and here on

00:58:49,760 --> 00:58:53,599
the slide you can see

00:58:50,799 --> 00:58:55,760
how we initialize the engine api struct

00:58:53,599 --> 00:58:57,440
by passing it

00:58:55,760 --> 00:58:58,880
pointer to the struct with function

00:58:57,440 --> 00:59:00,400
pointers we're going to describe on the

00:58:58,880 --> 00:59:03,440
next slide

00:59:00,400 --> 00:59:05,760
and oh then the g option

00:59:03,440 --> 00:59:07,440
specifies the directory in which the

00:59:05,760 --> 00:59:09,280
secret file will be created

00:59:07,440 --> 00:59:10,720
now the secret file can then be loaded

00:59:09,280 --> 00:59:12,160
by wireshark

00:59:10,720 --> 00:59:14,720
and your quick connection will be

00:59:12,160 --> 00:59:14,720
decrypted

00:59:15,760 --> 00:59:20,880
and here is ls api for key logging

00:59:18,960 --> 00:59:22,799
there are three functions one to open

00:59:20,880 --> 00:59:25,920
the file one to log a line

00:59:22,799 --> 00:59:26,240
and one to close the handle and here we

00:59:25,920 --> 00:59:33,839
see

00:59:26,240 --> 00:59:33,839
how it's specified in the lsq engine api

00:59:35,359 --> 00:59:38,799
and here how it looks in the tutorial

00:59:37,440 --> 00:59:40,720
program

00:59:38,799 --> 00:59:42,160
we will not cover every function we'll

00:59:40,720 --> 00:59:45,200
just note uh

00:59:42,160 --> 00:59:47,200
how this track is initialized and

00:59:45,200 --> 00:59:49,200
we don't interpret the secret line we

00:59:47,200 --> 00:59:51,760
just printed to the file and we flush

00:59:49,200 --> 00:59:51,760
the handle

00:59:52,559 --> 00:59:56,079
so after we jump through all those hoops

00:59:55,200 --> 00:59:58,319
our reward

00:59:56,079 --> 00:59:59,680
is a decrypted quick connection in

00:59:58,319 --> 01:00:01,280
wireshark

00:59:59,680 --> 01:00:02,880
you can see on the bottom panel i've

01:00:01,280 --> 01:00:06,319
highlighted the reverse hello

01:00:02,880 --> 01:00:07,839
that we received from stream um

01:00:06,319 --> 01:00:09,440
oh this is not the same session as the

01:00:07,839 --> 01:00:11,119
one that we looked when we looked at the

01:00:09,440 --> 01:00:12,880
log messages

01:00:11,119 --> 01:00:14,480
uh and the on the middle panel you can

01:00:12,880 --> 01:00:14,960
see that besides the stream frame we

01:00:14,480 --> 01:00:18,000
have

01:00:14,960 --> 01:00:20,000
time stamp and act frames

01:00:18,000 --> 01:00:21,520
and on the top panel you can see that

01:00:20,000 --> 01:00:23,839
next to the packet numbers and

01:00:21,520 --> 01:00:27,280
connection ids

01:00:23,839 --> 01:00:30,640
wireshark helpfully prints lists of

01:00:27,280 --> 01:00:32,400
frame tabs contained in a packet

01:00:30,640 --> 01:00:34,240
another interesting thing to note in

01:00:32,400 --> 01:00:35,920
this display

01:00:34,240 --> 01:00:38,079
in the top panel is that even though

01:00:35,920 --> 01:00:40,640
there are one connection

01:00:38,079 --> 01:00:43,839
the connection i use are different and

01:00:40,640 --> 01:00:43,839
we'll talk about it next

01:00:44,960 --> 01:00:49,920
now each quick connection has two sets

01:00:48,000 --> 01:00:52,160
of connection ids

01:00:49,920 --> 01:00:53,359
one set is the source connection ids or

01:00:52,160 --> 01:00:55,680
s sids

01:00:53,359 --> 01:00:58,000
and the other set are is destination

01:00:55,680 --> 01:01:00,480
connection ideas or dissids

01:00:58,000 --> 01:01:02,559
now source connection ids is what the

01:01:00,480 --> 01:01:05,119
peer uses

01:01:02,559 --> 01:01:06,720
to put into its packet when it sends the

01:01:05,119 --> 01:01:08,880
packets to us

01:01:06,720 --> 01:01:11,040
and destination connection ids are what

01:01:08,880 --> 01:01:12,079
we use to put into a packet to send to

01:01:11,040 --> 01:01:13,839
our peer

01:01:12,079 --> 01:01:15,520
now one endpoint's destination

01:01:13,839 --> 01:01:17,520
connection ids

01:01:15,520 --> 01:01:20,640
are other endpoints source connection

01:01:17,520 --> 01:01:21,920
ids and vice versa

01:01:20,640 --> 01:01:24,079
what's interesting about these

01:01:21,920 --> 01:01:26,319
connection ids is that each

01:01:24,079 --> 01:01:28,559
endpoint can choose to change the

01:01:26,319 --> 01:01:29,760
destination connection id it uses at any

01:01:28,559 --> 01:01:34,720
time

01:01:29,760 --> 01:01:34,720
for any reason so if you see a

01:01:35,280 --> 01:01:39,200
log log file with connection ids that

01:01:38,319 --> 01:01:41,119
are different

01:01:39,200 --> 01:01:42,480
it doesn't mean that it's different

01:01:41,119 --> 01:01:45,520
those are different connections it may

01:01:42,480 --> 01:01:48,160
be just the same connection

01:01:45,520 --> 01:01:50,319
uh now on this slide you can see how ls

01:01:48,160 --> 01:01:53,680
quick represents a connection

01:01:50,319 --> 01:01:55,039
uh connection ids can be up to 20 bytes

01:01:53,680 --> 01:01:58,240
in length

01:01:55,039 --> 01:01:59,680
uh by default uh i say by default

01:01:58,240 --> 01:02:01,119
because of course you can configure this

01:01:59,680 --> 01:02:03,359
option in ls quick

01:02:01,119 --> 01:02:04,839
uh by default lsquid uses eight byte

01:02:03,359 --> 01:02:06,160
long connection ids to speed up

01:02:04,839 --> 01:02:07,599
comparison

01:02:06,160 --> 01:02:10,720
and you can see how comparison is

01:02:07,599 --> 01:02:14,240
performed by looking at the

01:02:10,720 --> 01:02:14,240
macro at the bottom of this slide

01:02:17,680 --> 01:02:23,440
get this in that apis now here's some

01:02:20,880 --> 01:02:25,359
miscellaneous functions to get

01:02:23,440 --> 01:02:27,119
to objects from other objects in ls

01:02:25,359 --> 01:02:29,039
quick

01:02:27,119 --> 01:02:30,240
now the seed returned by the first

01:02:29,039 --> 01:02:33,680
function lsb con

01:02:30,240 --> 01:02:35,359
id is different depending on the client

01:02:33,680 --> 01:02:37,359
whether or not your client or server the

01:02:35,359 --> 01:02:41,039
server returns

01:02:37,359 --> 01:02:42,880
the current source connection id

01:02:41,039 --> 01:02:44,720
and the client returns the current

01:02:42,880 --> 01:02:46,400
destination connection id

01:02:44,720 --> 01:02:47,839
the end result is when you're debugging

01:02:46,400 --> 01:02:49,760
your implementation you look at the two

01:02:47,839 --> 01:02:52,400
log files from client and server

01:02:49,760 --> 01:02:53,119
the connection id is going to match as i

01:02:52,400 --> 01:02:54,960
said

01:02:53,119 --> 01:02:56,240
as i just said before do not rely on the

01:02:54,960 --> 01:02:58,000
connection id to be unique for a

01:02:56,240 --> 01:02:59,599
connection use some other

01:02:58,000 --> 01:03:01,359
means to identify your connection in

01:02:59,599 --> 01:03:03,680
your code

01:03:01,359 --> 01:03:05,839
lsquix streamcon gets you a connection

01:03:03,680 --> 01:03:09,039
pointer from a stream

01:03:05,839 --> 01:03:12,079
lsk can't get engine gets the engine

01:03:09,039 --> 01:03:13,440
from a connection and lsqc can't get

01:03:12,079 --> 01:03:16,160
suck adder

01:03:13,440 --> 01:03:17,680
points your local and peer pointers to

01:03:16,160 --> 01:03:21,200
the

01:03:17,680 --> 01:03:23,839
current paths local and peer addresses

01:03:21,200 --> 01:03:26,079
now kwik doesn't do a true multipath yet

01:03:23,839 --> 01:03:28,240
but ls quick supports

01:03:26,079 --> 01:03:30,720
several path objects internally for

01:03:28,240 --> 01:03:33,760
during path migration

01:03:30,720 --> 01:03:35,280
so when uh there is multiple support and

01:03:33,760 --> 01:03:37,039
quick perhaps in version two

01:03:35,280 --> 01:03:38,480
or version three this api will change

01:03:37,039 --> 01:03:40,319
and they will be able to get

01:03:38,480 --> 01:03:42,839
addresses for any path and perhaps do

01:03:40,319 --> 01:03:45,839
things that are a little bit more

01:03:42,839 --> 01:03:45,839
complicated

01:03:46,720 --> 01:03:52,960
stream priorities uh ls click inherited

01:03:50,480 --> 01:03:55,119
stream priorities from google quick

01:03:52,960 --> 01:03:56,400
now itf quick streams do not have

01:03:55,119 --> 01:03:58,640
priorities

01:03:56,400 --> 01:04:00,079
priority information in itf quick is

01:03:58,640 --> 01:04:01,839
supposed to be communicated by

01:04:00,079 --> 01:04:04,960
communication protocol

01:04:01,839 --> 01:04:08,000
such as for example http 3.

01:04:04,960 --> 01:04:12,079
um and http 3 priorities are not

01:04:08,000 --> 01:04:13,440
yet even a draft that can be used uh

01:04:12,079 --> 01:04:14,960
however does mean we couldn't use

01:04:13,440 --> 01:04:17,200
priorities now

01:04:14,960 --> 01:04:19,680
uh priorities numbered one through 56

01:04:17,200 --> 01:04:22,480
where the lower number is high priority

01:04:19,680 --> 01:04:24,480
uh the stream priority controls uh the

01:04:22,480 --> 01:04:27,280
order in which on right

01:04:24,480 --> 01:04:31,359
and on read callbacks are called and the

01:04:27,280 --> 01:04:31,359
packetization priority for stream data

01:04:36,640 --> 01:04:40,240
and now we've reached the last slide we

01:04:38,799 --> 01:04:42,559
have covered only

01:04:40,240 --> 01:04:45,680
the basic functionality of ellis quick

01:04:42,559 --> 01:04:47,920
it supports many more things

01:04:45,680 --> 01:04:49,359
please refer to online documentation at

01:04:47,920 --> 01:04:53,119
lsquid read the docs dot

01:04:49,359 --> 01:04:56,799
io if you have any questions i'll be

01:04:53,119 --> 01:04:56,799
very glad to answer them now

01:04:57,599 --> 01:05:01,039
the question is do i have any

01:04:59,359 --> 01:05:02,720
performance comparison with other quick

01:05:01,039 --> 01:05:05,440
implementations

01:05:02,720 --> 01:05:08,000
uh we have done a couple of them uh

01:05:05,440 --> 01:05:10,160
they're available at our blog

01:05:08,000 --> 01:05:12,280
i don't have it handy here but if you go

01:05:10,160 --> 01:05:14,559
to

01:05:12,280 --> 01:05:16,400
blog.lightspeedtech.com you'll be able

01:05:14,559 --> 01:05:18,799
to find them

01:05:16,400 --> 01:05:19,839
because of our name lightspeed we aim to

01:05:18,799 --> 01:05:22,079
be the fastest

01:05:19,839 --> 01:05:23,839
and we believe we are the fastest but of

01:05:22,079 --> 01:05:25,200
course we always welcome people to run

01:05:23,839 --> 01:05:27,680
their own benchmarks and as a matter of

01:05:25,200 --> 01:05:29,359
fact we made our benchmarking mechanism

01:05:27,680 --> 01:05:36,720
available on github so you can try to

01:05:29,359 --> 01:05:40,720
reproduce our benchmarks

01:05:36,720 --> 01:05:44,240
um i have a question um

01:05:40,720 --> 01:05:48,480
how tightly coupled is quick to

01:05:44,240 --> 01:05:48,480
the underlying udp uh transport

01:05:48,720 --> 01:05:51,920
uh theoretically it's not uh tightly

01:05:50,880 --> 01:05:53,520
coupled but

01:05:51,920 --> 01:05:56,480
recently i was looking at it and it is

01:05:53,520 --> 01:05:59,839
indeed very tightly coupled to udp

01:05:56,480 --> 01:06:03,200
uh there are mentions of ptm uh pv

01:05:59,839 --> 01:06:04,079
dpl pmtud in the quick transport draft

01:06:03,200 --> 01:06:06,400
itself

01:06:04,079 --> 01:06:08,079
and there's uh things like tuples

01:06:06,400 --> 01:06:11,039
mentioned in the draft so

01:06:08,079 --> 01:06:11,520
yes it's coupled to udp and in ip i

01:06:11,039 --> 01:06:14,720
think

01:06:11,520 --> 01:06:18,640
uh itf quick charter talks specifically

01:06:14,720 --> 01:06:21,680
about udp

01:06:18,640 --> 01:06:24,240
so um

01:06:21,680 --> 01:06:24,960
trying to think like could you implement

01:06:24,240 --> 01:06:28,400
this

01:06:24,960 --> 01:06:29,680
over rdma do you think

01:06:28,400 --> 01:06:33,039
i don't know what that is but i think

01:06:29,680 --> 01:06:35,039
yes okay

01:06:33,039 --> 01:06:36,640
i mean there's nothing really besides uh

01:06:35,039 --> 01:06:39,680
this you know well you saw the um

01:06:36,640 --> 01:06:40,960
in our api you saw the socket addresses

01:06:39,680 --> 01:06:43,119
i mean if you replace them with

01:06:40,960 --> 01:06:46,799
something else uh

01:06:43,119 --> 01:06:48,480
then it will just work

01:06:46,799 --> 01:06:50,960
i prepared some backup slides i believe

01:06:48,480 --> 01:06:52,960
i have a few minutes

01:06:50,960 --> 01:06:55,039
uh if you guys have more questions on ls

01:06:52,960 --> 01:06:56,480
quick proper you can ask them

01:06:55,039 --> 01:07:00,319
while i talk about some of the other

01:06:56,480 --> 01:07:03,920
things i prepared does it sound good

01:07:00,319 --> 01:07:06,960
i have one question uh is it hard to

01:07:03,920 --> 01:07:09,359
extract the secret keys from ls quick

01:07:06,960 --> 01:07:12,000
for example for hardware of loading of

01:07:09,359 --> 01:07:12,000
the flows

01:07:12,559 --> 01:07:17,839
it should not be uh because uh you know

01:07:15,839 --> 01:07:19,920
we use boring ssl and boring ssl

01:07:17,839 --> 01:07:23,599
provides the api for that

01:07:19,920 --> 01:07:24,400
okay uh we uh do some handshake

01:07:23,599 --> 01:07:26,960
offloading

01:07:24,400 --> 01:07:28,160
in our enterprise version of our web

01:07:26,960 --> 01:07:29,920
server

01:07:28,160 --> 01:07:31,520
but ls quick library itself does not

01:07:29,920 --> 01:07:34,720
provide it

01:07:31,520 --> 01:07:37,680
okay yeah it could be done

01:07:34,720 --> 01:07:38,240
all right during the um proposal of the

01:07:37,680 --> 01:07:41,200
stock

01:07:38,240 --> 01:07:42,720
uh one thing that i was asked is whether

01:07:41,200 --> 01:07:45,280
or not

01:07:42,720 --> 01:07:46,480
ellis quick or the committee had any

01:07:45,280 --> 01:07:49,039
wish list for

01:07:46,480 --> 01:07:50,480
linux kernel and the first bonus section

01:07:49,039 --> 01:07:53,839
is linux wishlist

01:07:50,480 --> 01:07:55,280
and indeed we have wishes the biggest

01:07:53,839 --> 01:07:56,960
wish of course is that the udp

01:07:55,280 --> 01:07:58,319
processing and the linux kernel were

01:07:56,960 --> 01:07:59,920
just a little bit more

01:07:58,319 --> 01:08:01,359
a little just a little bit faster but

01:07:59,920 --> 01:08:04,559
that's a obvious wish

01:08:01,359 --> 01:08:08,799
and a couple of non-obvious things that

01:08:04,559 --> 01:08:10,720
you may find interesting the first one

01:08:08,799 --> 01:08:12,640
is that there is no way to use ecl and

01:08:10,720 --> 01:08:15,839
gso at the same time

01:08:12,640 --> 01:08:17,120
ecn is recommended by uh the ietf

01:08:15,839 --> 01:08:20,000
transport draft

01:08:17,120 --> 01:08:20,719
analyst supports it png so can be used

01:08:20,000 --> 01:08:24,080
to speed up

01:08:20,719 --> 01:08:25,040
sending of udp packets but there's no

01:08:24,080 --> 01:08:28,319
way to do

01:08:25,040 --> 01:08:30,880
both at the same time so it would be

01:08:28,319 --> 01:08:30,880
nice to have

01:08:31,040 --> 01:08:35,600
the second wish or the second problem

01:08:34,080 --> 01:08:37,679
that i've run into very recently is when

01:08:35,600 --> 01:08:40,880
i was implementing

01:08:37,679 --> 01:08:45,120
dpl pmtud now the

01:08:40,880 --> 01:08:48,159
pl in dplp m2d stands for packet layer

01:08:45,120 --> 01:08:51,600
which means that's lsq's job to

01:08:48,159 --> 01:08:54,880
create mtu probes and run the protocol

01:08:51,600 --> 01:08:57,120
itself but i found that

01:08:54,880 --> 01:08:58,159
there is no way to make send message not

01:08:57,120 --> 01:08:59,679
fail

01:08:58,159 --> 01:09:02,719
when the datagram is too large for the

01:08:59,679 --> 01:09:06,239
local interface it always returns

01:09:02,719 --> 01:09:10,159
-1 with the e-message size

01:09:06,239 --> 01:09:12,799
uh now from the perspective of gpl pmg

01:09:10,159 --> 01:09:14,159
to be much nicer if we just let it drop

01:09:12,799 --> 01:09:16,239
silently on the floor but there is no

01:09:14,159 --> 01:09:18,480
option to do that

01:09:16,239 --> 01:09:19,279
so what dealing with this air made me do

01:09:18,480 --> 01:09:21,199
is first

01:09:19,279 --> 01:09:23,759
introduce a couple of branches in the

01:09:21,199 --> 01:09:25,600
loop which i like to stay fast

01:09:23,759 --> 01:09:27,199
and second it is just more complicated

01:09:25,600 --> 01:09:30,719
dealing with the

01:09:27,199 --> 01:09:34,080
retry so now i have to in that send

01:09:30,719 --> 01:09:35,920
out packets batch that we talked about

01:09:34,080 --> 01:09:36,960
before now i have to figure out where it

01:09:35,920 --> 01:09:38,400
stopped

01:09:36,960 --> 01:09:40,719
skip this packet do something with it

01:09:38,400 --> 01:09:43,359
actually and then retry the

01:09:40,719 --> 01:09:44,960
second part of the batch immediately uh

01:09:43,359 --> 01:09:46,719
and that complication

01:09:44,960 --> 01:09:48,400
or that complexity actually added a

01:09:46,719 --> 01:09:50,239
couple of regressions

01:09:48,400 --> 01:09:53,679
which thankfully we caught during

01:09:50,239 --> 01:09:55,600
testing time before deploying it

01:09:53,679 --> 01:09:58,560
but yeah this would be nice to be able

01:09:55,600 --> 01:10:03,840
to specify maybe a fourth value for the

01:09:58,560 --> 01:10:03,840
ipm2 discover socket option

01:10:08,480 --> 01:10:12,080
well if there are comments to this i

01:10:09,760 --> 01:10:15,120
have a second bonus section

01:10:12,080 --> 01:10:17,280
i've talked a lot about http 3 today

01:10:15,120 --> 01:10:18,159
without talking more about it and now is

01:10:17,280 --> 01:10:21,280
the time

01:10:18,159 --> 01:10:22,800
for me to do so now http 3 is a quick

01:10:21,280 --> 01:10:25,440
skiller feature and

01:10:22,800 --> 01:10:27,440
my opinion is that success or failure of

01:10:25,440 --> 01:10:30,400
http 3 will dictate success or failure

01:10:27,440 --> 01:10:33,600
of the quick protocol itself

01:10:30,400 --> 01:10:37,120
now how to do http 3

01:10:33,600 --> 01:10:39,600
http 3 is similar to http 2

01:10:37,120 --> 01:10:40,800
over quick the protocol is similar but

01:10:39,600 --> 01:10:43,679
they're not the same

01:10:40,800 --> 01:10:45,520
and it is not a simple protocol http 3

01:10:43,679 --> 01:10:47,679
has sub protocols

01:10:45,520 --> 01:10:49,679
such as header compression and the

01:10:47,679 --> 01:10:51,440
upcoming priorities

01:10:49,679 --> 01:10:52,800
it has control streams and it has data

01:10:51,440 --> 01:10:54,880
framing

01:10:52,800 --> 01:10:57,440
thankfully as i mentioned before lsp

01:10:54,880 --> 01:10:59,199
hides most of that stuff from the user

01:10:57,440 --> 01:11:01,600
so the user only needs to be aware what

01:10:59,199 --> 01:11:02,719
new knobs to turn and new functions to

01:11:01,600 --> 01:11:04,800
use

01:11:02,719 --> 01:11:06,239
and on this slide we'll discuss the hp3

01:11:04,800 --> 01:11:09,679
differences as far as

01:11:06,239 --> 01:11:11,120
quick usage is concerned now sni is

01:11:09,679 --> 01:11:12,880
required

01:11:11,120 --> 01:11:14,400
for our purposes it just means that the

01:11:12,880 --> 01:11:15,840
client needs to specify the seventh

01:11:14,400 --> 01:11:18,000
argument to the connect function which

01:11:15,840 --> 01:11:19,920
will become the sni indicator

01:11:18,000 --> 01:11:22,239
and the server must use the ea lookup

01:11:19,920 --> 01:11:25,360
search callback

01:11:22,239 --> 01:11:27,520
http headers need to be sent before the

01:11:25,360 --> 01:11:28,960
body of http message there's a special

01:11:27,520 --> 01:11:32,080
function for that

01:11:28,960 --> 01:11:34,000
lsu extreme sent headers and there's

01:11:32,080 --> 01:11:36,800
also an optional callback

01:11:34,000 --> 01:11:38,719
to process the response http headers if

01:11:36,800 --> 01:11:39,360
this callback is not specified then ls

01:11:38,719 --> 01:11:42,159
quick will

01:11:39,360 --> 01:11:43,360
pretend this is a http one stream it

01:11:42,159 --> 01:11:46,239
will translate

01:11:43,360 --> 01:11:47,679
those uh headers into a stream and you

01:11:46,239 --> 01:11:50,480
can just pretend you parsing

01:11:47,679 --> 01:11:52,000
http one stream uh i mean it works but

01:11:50,480 --> 01:11:54,960
it's not efficient so you you

01:11:52,000 --> 01:11:55,440
you're better off using the um using

01:11:54,960 --> 01:11:58,000
these

01:11:55,440 --> 01:11:58,000
callbacks

01:11:58,560 --> 01:12:02,719
and as a bonus in the tutorial program

01:12:01,440 --> 01:12:05,199
there's also an h3

01:12:02,719 --> 01:12:07,120
cli program which is a simple http 3

01:12:05,199 --> 01:12:08,960
client

01:12:07,120 --> 01:12:10,320
uh to run it give it the hostname and

01:12:08,960 --> 01:12:13,600
the port number and

01:12:10,320 --> 01:12:15,199
path and hit lightspeedtag.com

01:12:13,600 --> 01:12:18,159
couple of other websites to try as

01:12:15,199 --> 01:12:20,239
google.com and facebook.com

01:12:18,159 --> 01:12:22,400
you can change the default method by

01:12:20,239 --> 01:12:25,760
using the dash capital m

01:12:22,400 --> 01:12:27,280
option the default method is get

01:12:25,760 --> 01:12:29,679
and now we're going to look inside a

01:12:27,280 --> 01:12:29,679
little bit

01:12:30,800 --> 01:12:34,960
now we saw this in previous slides ls

01:12:33,040 --> 01:12:36,400
engine http flag and you need to pass it

01:12:34,960 --> 01:12:38,560
to three functions

01:12:36,400 --> 01:12:40,000
init settings check settings and the

01:12:38,560 --> 01:12:41,679
engine constructor

01:12:40,000 --> 01:12:45,760
without this flag the engine constructor

01:12:41,679 --> 01:12:45,760
is not going to do the http magic

01:12:47,120 --> 01:12:52,560
and this is how you would connect

01:12:50,640 --> 01:12:54,159
this is looks exactly like the previous

01:12:52,560 --> 01:12:54,960
connect called only difference now we

01:12:54,159 --> 01:12:57,760
set

01:12:54,960 --> 01:13:04,159
the hostname and this becomes the s i in

01:12:57,760 --> 01:13:07,679
the quick client hello

01:13:04,159 --> 01:13:12,320
and uh this is the on right

01:13:07,679 --> 01:13:14,000
um callback in http 3 simple client

01:13:12,320 --> 01:13:16,400
you can see here on the bottom that we

01:13:14,000 --> 01:13:18,880
send http headers then we close the

01:13:16,400 --> 01:13:20,880
right hand and prepare for reading

01:13:18,880 --> 01:13:22,640
if our simple client supported methods

01:13:20,880 --> 01:13:25,199
such as spot

01:13:22,640 --> 01:13:26,880
post or put methods with http payloads

01:13:25,199 --> 01:13:28,480
we would not stop writing would

01:13:26,880 --> 01:13:31,040
continue writing using the regular

01:13:28,480 --> 01:13:32,560
stream write function

01:13:31,040 --> 01:13:34,560
here however we've just prepared to read

01:13:32,560 --> 01:13:37,840
the response from the server

01:13:34,560 --> 01:13:40,800
uh another thing to note here is that we

01:13:37,840 --> 01:13:42,480
package we use a special helper function

01:13:40,800 --> 01:13:46,239
to package these uh headers

01:13:42,480 --> 01:13:50,560
into the ls expat header array

01:13:46,239 --> 01:13:53,679
otherwise it just not fit on a slide

01:13:50,560 --> 01:13:56,480
and this is how you do http 3 in

01:13:53,679 --> 01:13:57,360
using ls quick now you can just read the

01:13:56,480 --> 01:13:59,199
results

01:13:57,360 --> 01:14:00,719
from the server and if you have it

01:13:59,199 --> 01:14:04,239
running you should see

01:14:00,719 --> 01:14:06,080
it working hopefully um

01:14:04,239 --> 01:14:08,239
and now it's here in the last slide uh

01:14:06,080 --> 01:14:10,000
now http 3 is its own protocol

01:14:08,239 --> 01:14:11,360
and of course it has its own

01:14:10,000 --> 01:14:13,199
configuration parameters and of course

01:14:11,360 --> 01:14:14,800
lsqc supports all these configuration

01:14:13,199 --> 01:14:16,320
parameters

01:14:14,800 --> 01:14:19,199
some of the most interesting ones have

01:14:16,320 --> 01:14:21,120
to do with compression q-pack

01:14:19,199 --> 01:14:22,239
there are choices such as stable size

01:14:21,120 --> 01:14:27,120
and ability to

01:14:22,239 --> 01:14:30,320
risk or not risk a number of streams

01:14:27,120 --> 01:14:31,600
and changing these parameters uh will

01:14:30,320 --> 01:14:36,719
affect your performance

01:14:31,600 --> 01:14:36,719
so feed them uh to suit your needs

01:14:37,280 --> 01:14:40,880
and i was watching the tls presentations

01:14:39,360 --> 01:14:42,400
earlier and was salivating and then i

01:14:40,880 --> 01:14:44,320
remembered that quick can take advantage

01:14:42,400 --> 01:14:47,120
of any of them

01:14:44,320 --> 01:14:48,320
of any of the nice kernel or hardware

01:14:47,120 --> 01:14:51,440
speed ups

01:14:48,320 --> 01:14:51,440
at least not easily

01:14:52,800 --> 01:14:56,800
looks like we have no more questions do

01:14:54,640 --> 01:14:58,320
you have some more bonus uh sections for

01:14:56,800 --> 01:15:01,600
us

01:14:58,320 --> 01:15:03,600
no that's it that run out uh i was uh

01:15:01,600 --> 01:15:05,360
you know doing this too i didn't want to

01:15:03,600 --> 01:15:07,679
make it too much i mean i could go

01:15:05,360 --> 01:15:09,679
deeper into http 3 but i don't know

01:15:07,679 --> 01:15:11,600
you're probably all tired by looking at

01:15:09,679 --> 01:15:14,000
code and looking at the apis i know that

01:15:11,600 --> 01:15:15,840
fitting all of this in just over an hour

01:15:14,000 --> 01:15:18,159
is pretty tough to follow

01:15:15,840 --> 01:15:18,960
but uh hopefully you guys got a feel for

01:15:18,159 --> 01:15:21,920
uh

01:15:18,960 --> 01:15:21,920
how to use ls quick

01:15:22,800 --> 01:15:31,920

YouTube URL: https://www.youtube.com/watch?v=kDwyGNsQXds


