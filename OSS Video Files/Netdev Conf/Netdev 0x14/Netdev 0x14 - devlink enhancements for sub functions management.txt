Title: Netdev 0x14 - devlink enhancements for sub functions management
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Parav Pandit

More info: https://netdevconf.info/0x14/session.html?talk-devlink-enhancements-for-sub-functions-management

Date: Tuesday, August 18, 2020

New virtualization deployments call out for high density virtual
functions with more frequent lifetime recycling. Unfortunately,
PCIe SR-IOV has limited function count and large instantiation
overhead.  A solution to these challenges is to take a PCIE device
and "split" it into multiple subdevices. Each subdevice gets its
own virtual port(s), queues as well as named resources; Combined
with TC and switchdev offloads this approach overcomes the SR-IOV
limitations.

In this talk Parav Pandit introduces devlink enhancements
to manage such sub functions.

Parav  first discusses how devlink is used to life cycle,
configure and deploy accelerated sub functions with eswitch offloads
support. He then discusses the plumbing done using
virtbus to achieve persistence naming of netdevices and
rdma devices. Parav will also cover how such model
addresses smartnic use case where a sub-function NIC is
hot plugged in host system in a secure manner.
Captions: 
	00:00:00,080 --> 00:00:04,319
um today i'm going to discuss um the

00:00:02,399 --> 00:00:04,799
living extensions that we would like to

00:00:04,319 --> 00:00:09,520
do

00:00:04,799 --> 00:00:09,520
for managing the sub functions uh

00:00:11,599 --> 00:00:15,360
feel free to to note down your questions

00:00:13,920 --> 00:00:18,160
feedback or comments

00:00:15,360 --> 00:00:18,560
i have my email at the end of the slides

00:00:18,160 --> 00:00:21,840
um

00:00:18,560 --> 00:00:23,840
feel free to send me your questions um

00:00:21,840 --> 00:00:26,000
or if you prefer to discuss over option

00:00:23,840 --> 00:00:28,800
mailing list then i have a link to

00:00:26,000 --> 00:00:29,599
a few rfc then batches that's been

00:00:28,800 --> 00:00:31,920
posted

00:00:29,599 --> 00:00:33,360
uh feel free to reply there and we would

00:00:31,920 --> 00:00:36,559
be happy to discuss

00:00:33,360 --> 00:00:38,160
um all your suggestions and feedback for

00:00:36,559 --> 00:00:41,280
it

00:00:38,160 --> 00:00:44,239
so let's let's get started um

00:00:41,280 --> 00:00:46,480
our my today's talk is mainly around

00:00:44,239 --> 00:00:49,120
three

00:00:46,480 --> 00:00:52,480
three topics one is understanding the

00:00:49,120 --> 00:00:52,480
user requirements for

00:00:53,120 --> 00:00:59,199
creating configuring the sub functions

00:00:56,800 --> 00:01:00,960
the second piece of the puzzle is what's

00:00:59,199 --> 00:01:03,359
the current state of the labeling

00:01:00,960 --> 00:01:04,000
and how um how we would like to extend

00:01:03,359 --> 00:01:06,000
it

00:01:04,000 --> 00:01:08,080
and the third part is the main is the

00:01:06,000 --> 00:01:09,920
design of how

00:01:08,080 --> 00:01:12,400
these requirements are getting addressed

00:01:09,920 --> 00:01:15,600
with the extensions

00:01:12,400 --> 00:01:20,240
so that the user can use it

00:01:15,600 --> 00:01:24,400
so so today as we know

00:01:20,240 --> 00:01:26,799
users have been using the virtualization

00:01:24,400 --> 00:01:28,240
in various different ways uh one that we

00:01:26,799 --> 00:01:31,280
know is um

00:01:28,240 --> 00:01:33,280
one one side is a vts devices where we

00:01:31,280 --> 00:01:37,040
have a pair of um

00:01:33,280 --> 00:01:38,000
vth one is mapped to the virtual machine

00:01:37,040 --> 00:01:40,720
or container

00:01:38,000 --> 00:01:43,439
and the other side is exposed to the

00:01:40,720 --> 00:01:45,759
switch and all the pc configurations

00:01:43,439 --> 00:01:46,640
um including their taking care of the

00:01:45,759 --> 00:01:49,759
gap

00:01:46,640 --> 00:01:50,240
um is being done on the other end of the

00:01:49,759 --> 00:01:53,200
wire

00:01:50,240 --> 00:01:53,200
of the vth bed

00:01:53,439 --> 00:01:56,560
which is one side the other side of the

00:01:55,200 --> 00:01:59,759
spectrum is

00:01:56,560 --> 00:02:02,159
the e-speech uploaded devices um

00:01:59,759 --> 00:02:03,439
so far we have been seen the sriv

00:02:02,159 --> 00:02:06,159
virtual functions

00:02:03,439 --> 00:02:08,000
where the vm uses a virtual function or

00:02:06,159 --> 00:02:11,920
the container uses virtual function and

00:02:08,000 --> 00:02:15,440
the the speech representation is our

00:02:11,920 --> 00:02:17,599
exist for each of these vf or up here

00:02:15,440 --> 00:02:19,760
and all the tc rules apply on the

00:02:17,599 --> 00:02:22,800
represented device

00:02:19,760 --> 00:02:23,760
now the the requirements that we hear

00:02:22,800 --> 00:02:26,560
from the users

00:02:23,760 --> 00:02:28,160
is um the user should be able to create

00:02:26,560 --> 00:02:31,360
configure and deploy

00:02:28,160 --> 00:02:32,239
the sub function device or one device at

00:02:31,360 --> 00:02:34,720
a time which is

00:02:32,239 --> 00:02:36,239
essentially a portion of the device that

00:02:34,720 --> 00:02:39,360
the user creates

00:02:36,239 --> 00:02:42,560
configures and it grows now

00:02:39,360 --> 00:02:44,080
um so far we have seen usually unique

00:02:42,560 --> 00:02:47,160
management is done through

00:02:44,080 --> 00:02:48,720
ncsi interface for some of the

00:02:47,160 --> 00:02:51,599
proprietary

00:02:48,720 --> 00:02:52,640
but with uh with the upcoming smart nick

00:02:51,599 --> 00:02:54,879
devices

00:02:52,640 --> 00:02:55,840
um the nic itself is running the linux

00:02:54,879 --> 00:02:58,959
kernel

00:02:55,840 --> 00:03:00,879
and and therefore um several of the

00:02:58,959 --> 00:03:01,920
applications can be run on the leak

00:03:00,879 --> 00:03:03,760
including

00:03:01,920 --> 00:03:05,200
uh the most common one is running an

00:03:03,760 --> 00:03:07,680
easy step

00:03:05,200 --> 00:03:08,560
so the user's primary requirement is

00:03:07,680 --> 00:03:10,400
that

00:03:08,560 --> 00:03:12,480
user should be able to create the nic

00:03:10,400 --> 00:03:14,480
device from the nik side

00:03:12,480 --> 00:03:15,519
and not from the host where the nic is

00:03:14,480 --> 00:03:19,120
plugged in

00:03:15,519 --> 00:03:20,800
as a device now as a user we should have

00:03:19,120 --> 00:03:24,000
the same user interface

00:03:20,800 --> 00:03:25,920
um regardless um this

00:03:24,000 --> 00:03:28,080
virtual need for virtual device is

00:03:25,920 --> 00:03:31,920
created from the nik side

00:03:28,080 --> 00:03:32,959
or from the the host system side itself

00:03:31,920 --> 00:03:34,640
um

00:03:32,959 --> 00:03:36,480
that's the most second important

00:03:34,640 --> 00:03:39,120
requirement

00:03:36,480 --> 00:03:43,120
the third one is a configuration is that

00:03:39,120 --> 00:03:43,120
user should be able to configure the nic

00:03:43,599 --> 00:03:51,120
enough before this nick is being

00:03:47,360 --> 00:03:53,920
given to a virtual machine container

00:03:51,120 --> 00:03:54,799
or in some cases even a pixel driver

00:03:53,920 --> 00:03:58,000
which will start

00:03:54,799 --> 00:03:59,840
um loading and booting on on this device

00:03:58,000 --> 00:04:02,080
so we want to make sure that the device

00:03:59,840 --> 00:04:04,480
is configured enough

00:04:02,080 --> 00:04:06,480
before these drivers can get access to

00:04:04,480 --> 00:04:10,239
the device

00:04:06,480 --> 00:04:12,879
um as a user we might want to

00:04:10,239 --> 00:04:15,519
move this this portion of the device or

00:04:12,879 --> 00:04:18,880
a virtual function or a sub function

00:04:15,519 --> 00:04:22,800
to the vm and therefore

00:04:18,880 --> 00:04:25,440
all the um all the driver facing

00:04:22,800 --> 00:04:26,400
resources being exposed uh should be

00:04:25,440 --> 00:04:28,880
secure enough

00:04:26,400 --> 00:04:30,560
and the most common one is the pci bar

00:04:28,880 --> 00:04:33,840
if we map a page of the bar

00:04:30,560 --> 00:04:36,639
we want to have this as a composite or

00:04:33,840 --> 00:04:38,160
one page that is not mapped between two

00:04:36,639 --> 00:04:40,000
two virtual machines

00:04:38,160 --> 00:04:42,000
so the pci bio resource is something

00:04:40,000 --> 00:04:43,160
which is dedicated and that we should be

00:04:42,000 --> 00:04:44,320
able to map

00:04:43,160 --> 00:04:47,360
[Music]

00:04:44,320 --> 00:04:50,160
as part of the sub function from the use

00:04:47,360 --> 00:04:51,199
use case or application point um user

00:04:50,160 --> 00:04:53,680
wants to configure

00:04:51,199 --> 00:04:55,840
and use this device either for a vm or

00:04:53,680 --> 00:04:58,240
for bare metal or for the continuity

00:04:55,840 --> 00:04:58,240
space

00:04:58,720 --> 00:05:02,800
these are the say the primary

00:05:01,680 --> 00:05:05,440
requirements for

00:05:02,800 --> 00:05:07,199
um for creating the subconscious the

00:05:05,440 --> 00:05:09,440
second part of the requirement is on the

00:05:07,199 --> 00:05:12,800
e-speech side

00:05:09,440 --> 00:05:16,800
as a user um user should be able to

00:05:12,800 --> 00:05:18,160
use the the rich pc offload interface

00:05:16,800 --> 00:05:21,199
that we have

00:05:18,160 --> 00:05:24,800
for um pf vf

00:05:21,199 --> 00:05:26,720
and sf in exactly same manner

00:05:24,800 --> 00:05:28,080
so that all the infrastructure that

00:05:26,720 --> 00:05:31,440
exists today

00:05:28,080 --> 00:05:32,800
can be leveraged when we have the

00:05:31,440 --> 00:05:34,080
representer

00:05:32,800 --> 00:05:36,960
we want to make sure that the

00:05:34,080 --> 00:05:39,759
representative naming scheme is

00:05:36,960 --> 00:05:41,039
correct from the day one in past we have

00:05:39,759 --> 00:05:44,800
seen

00:05:41,039 --> 00:05:48,000
a different naming scheme coming over

00:05:44,800 --> 00:05:51,520
for the representers and since

00:05:48,000 --> 00:05:53,440
it goes into a csfs that

00:05:51,520 --> 00:05:56,160
changing the scheme it gives a bit of

00:05:53,440 --> 00:05:58,160
experience so we want to make sure that

00:05:56,160 --> 00:06:00,000
the representative naming scheme as well

00:05:58,160 --> 00:06:01,759
as the name um

00:06:00,000 --> 00:06:03,759
we have a deterministic name through the

00:06:01,759 --> 00:06:07,440
system d and uw

00:06:03,759 --> 00:06:09,039
for the sub functions similar way as

00:06:07,440 --> 00:06:12,639
virtual and

00:06:09,039 --> 00:06:15,039
physical functions so

00:06:12,639 --> 00:06:16,160
okay so what does this requirements mean

00:06:15,039 --> 00:06:18,800
to

00:06:16,160 --> 00:06:20,400
to implementing this in a linux kernel

00:06:18,800 --> 00:06:23,440
is uh

00:06:20,400 --> 00:06:26,800
we as a user should be able to create

00:06:23,440 --> 00:06:28,720
um and slice a device um

00:06:26,800 --> 00:06:30,800
we started with a slice but now it's a

00:06:28,720 --> 00:06:33,520
design code

00:06:30,800 --> 00:06:34,000
at the end of our discussion so a user

00:06:33,520 --> 00:06:35,840
should be able

00:06:34,000 --> 00:06:39,360
to create one device at a time rather

00:06:35,840 --> 00:06:42,050
than say to enable 256 devices at a time

00:06:39,360 --> 00:06:44,240
which can take a fairly long time

00:06:42,050 --> 00:06:46,840
[Music]

00:06:44,240 --> 00:06:48,880
this function does not need to enable

00:06:46,840 --> 00:06:52,000
sriv because it's not

00:06:48,880 --> 00:06:53,599
a pcie vfd exposed so we should be able

00:06:52,000 --> 00:06:57,199
to configure and create

00:06:53,599 --> 00:06:57,199
these sub functions without smd

00:06:57,759 --> 00:07:00,960
sub functions runs on top of the

00:06:59,440 --> 00:07:02,880
existing pci device

00:07:00,960 --> 00:07:05,360
so you should be able to share your

00:07:02,880 --> 00:07:08,720
resources such as an irq resource

00:07:05,360 --> 00:07:10,720
with the pcipf or other sub functions

00:07:08,720 --> 00:07:12,880
at the same time you should not be able

00:07:10,720 --> 00:07:14,400
to share the pci bar

00:07:12,880 --> 00:07:16,479
which is directly accessed by the

00:07:14,400 --> 00:07:17,039
application sometimes it may have to be

00:07:16,479 --> 00:07:20,160
user

00:07:17,039 --> 00:07:22,960
space as well um through an rdma

00:07:20,160 --> 00:07:25,280
device and therefore the pci bar is a

00:07:22,960 --> 00:07:28,319
non-shared resource

00:07:25,280 --> 00:07:31,360
between the multiple sub functions or

00:07:28,319 --> 00:07:35,199
its parent display device

00:07:31,360 --> 00:07:38,160
um this is a function since we want to

00:07:35,199 --> 00:07:39,440
name them deterministically we need to

00:07:38,160 --> 00:07:42,000
have a backing with uh

00:07:39,440 --> 00:07:42,800
with the bus and therefore this lives on

00:07:42,000 --> 00:07:45,039
a

00:07:42,800 --> 00:07:46,240
new software bus and we'll see that in

00:07:45,039 --> 00:07:49,199
more detail

00:07:46,240 --> 00:07:51,360
and it follows the same process as any

00:07:49,199 --> 00:07:53,039
other bus device that follows

00:07:51,360 --> 00:07:55,039
to have a probe to move on power

00:07:53,039 --> 00:07:58,560
management so that we don't have to

00:07:55,039 --> 00:08:00,560
reinvent the wheel to

00:07:58,560 --> 00:08:02,000
to handle the power management

00:08:00,560 --> 00:08:03,759
differently

00:08:02,000 --> 00:08:05,520
just because it causes a function which

00:08:03,759 --> 00:08:07,599
is not the idea so we should be able to

00:08:05,520 --> 00:08:11,280
replace the existing kernel

00:08:07,599 --> 00:08:11,280
infrastructure for uh

00:08:11,520 --> 00:08:15,120
handle the power management events

00:08:15,440 --> 00:08:20,319
um okay so this was our first part of

00:08:18,240 --> 00:08:20,879
the understanding the user requirements

00:08:20,319 --> 00:08:23,520
in

00:08:20,879 --> 00:08:24,720
getting the picture clear the second

00:08:23,520 --> 00:08:26,960
part is

00:08:24,720 --> 00:08:28,639
the getting to know the current state of

00:08:26,960 --> 00:08:31,840
the developing

00:08:28,639 --> 00:08:33,360
interface as you might have guessed by

00:08:31,840 --> 00:08:35,919
now that we want to use the leveling

00:08:33,360 --> 00:08:37,839
interface for sub function management

00:08:35,919 --> 00:08:40,399
um let's understand what's the current

00:08:37,839 --> 00:08:42,080
state of the labeling and why it was

00:08:40,399 --> 00:08:44,640
chosen compared to

00:08:42,080 --> 00:08:45,600
few other options that which are

00:08:44,640 --> 00:08:48,800
obviously

00:08:45,600 --> 00:08:50,880
not so good but it's it's worth to to to

00:08:48,800 --> 00:08:53,040
add down

00:08:50,880 --> 00:08:54,000
so today the deviling interface is the

00:08:53,040 --> 00:08:58,560
one that exists

00:08:54,000 --> 00:09:01,040
that exposes a device level management

00:08:58,560 --> 00:09:02,800
without involving any of the classes for

00:09:01,040 --> 00:09:06,800
example vpa

00:09:02,800 --> 00:09:09,279
or dna or net class these are the

00:09:06,800 --> 00:09:10,080
the classes that exist today uh apart

00:09:09,279 --> 00:09:12,480
from the other

00:09:10,080 --> 00:09:13,519
block and several other classes but in

00:09:12,480 --> 00:09:15,839
context of

00:09:13,519 --> 00:09:16,720
networking devices um the dev link

00:09:15,839 --> 00:09:18,720
offers

00:09:16,720 --> 00:09:19,980
uh device management without attaching

00:09:18,720 --> 00:09:21,600
to any of these

00:09:19,980 --> 00:09:24,880
[Music]

00:09:21,600 --> 00:09:28,080
any of these specific classes

00:09:24,880 --> 00:09:30,880
so what we have we have a very rich

00:09:28,080 --> 00:09:32,880
health reporters and health

00:09:30,880 --> 00:09:33,440
configuration and the recovery of some

00:09:32,880 --> 00:09:36,080
of these

00:09:33,440 --> 00:09:37,680
resources as well when they discover the

00:09:36,080 --> 00:09:39,760
errors

00:09:37,680 --> 00:09:41,680
we can do a device configuration through

00:09:39,760 --> 00:09:45,360
device parameters or

00:09:41,680 --> 00:09:47,680
port parameters and

00:09:45,360 --> 00:09:50,880
with this feature we can reload the

00:09:47,680 --> 00:09:52,959
device without unloading the drivers

00:09:50,880 --> 00:09:54,160
and which is very helpful when you want

00:09:52,959 --> 00:09:56,959
to um

00:09:54,160 --> 00:09:58,000
only specify and modify only few device

00:09:56,959 --> 00:10:00,800
temperatures

00:09:58,000 --> 00:10:02,480
without unloading driver which is

00:10:00,800 --> 00:10:04,000
serving other devices and they are

00:10:02,480 --> 00:10:07,040
already in use

00:10:04,000 --> 00:10:07,040
by the applications

00:10:07,200 --> 00:10:11,600
currently devlink is mainly used or

00:10:09,360 --> 00:10:12,959
widely used over the networking

00:10:11,600 --> 00:10:16,000
[Music]

00:10:12,959 --> 00:10:18,720
by networking stack and

00:10:16,000 --> 00:10:19,200
not so much in by the other stacks but

00:10:18,720 --> 00:10:22,320
it is

00:10:19,200 --> 00:10:25,920
it is um it is not

00:10:22,320 --> 00:10:29,040
tied to the networking stack um

00:10:25,920 --> 00:10:29,440
one of the most um important feature

00:10:29,040 --> 00:10:31,839
that

00:10:29,440 --> 00:10:32,800
that's useful is uh the leveling

00:10:31,839 --> 00:10:35,680
interfaces

00:10:32,800 --> 00:10:37,040
is uh the instance is a network name

00:10:35,680 --> 00:10:39,279
space aware

00:10:37,040 --> 00:10:40,959
and it's a c scholar friendly data

00:10:39,279 --> 00:10:41,839
enables us to do several of the

00:10:40,959 --> 00:10:45,120
automated

00:10:41,839 --> 00:10:45,120
uh testing over

00:10:45,200 --> 00:10:50,079
over the for the kernel to make sure

00:10:48,720 --> 00:10:53,200
that

00:10:50,079 --> 00:10:55,600
all the user color interfaces are solid

00:10:53,200 --> 00:10:55,600
enough

00:10:57,200 --> 00:11:03,200
now if we see here

00:11:00,560 --> 00:11:03,839
the the third second part of the dev

00:11:03,200 --> 00:11:06,800
link is

00:11:03,839 --> 00:11:08,240
the e-switch representation um all the

00:11:06,800 --> 00:11:11,760
octo configuration

00:11:08,240 --> 00:11:12,880
is is accessible and enabled via the

00:11:11,760 --> 00:11:15,279
designing interface

00:11:12,880 --> 00:11:16,560
so by default the sriv works in the

00:11:15,279 --> 00:11:19,040
legacy mode

00:11:16,560 --> 00:11:21,519
and the switched mode can be enabled

00:11:19,040 --> 00:11:23,600
again through the leveling

00:11:21,519 --> 00:11:25,440
it also has a close tie up with the

00:11:23,600 --> 00:11:27,600
representer

00:11:25,440 --> 00:11:29,360
for each of the speed port which is

00:11:27,600 --> 00:11:31,760
represented by a network

00:11:29,360 --> 00:11:32,880
and its information is accessible

00:11:31,760 --> 00:11:35,760
through the doubling

00:11:32,880 --> 00:11:38,800
uh for example it's it's attachment page

00:11:35,760 --> 00:11:41,519
pr via perceptiveness

00:11:38,800 --> 00:11:43,279
um the last part is even though the

00:11:41,519 --> 00:11:46,640
doubling supports the

00:11:43,279 --> 00:11:48,399
representation and the switch

00:11:46,640 --> 00:11:50,639
here the switch is still an optional

00:11:48,399 --> 00:11:52,000
part of it so

00:11:50,639 --> 00:11:53,839
the often question comes in the

00:11:52,000 --> 00:11:57,920
meaningless discussion is uh

00:11:53,839 --> 00:11:59,839
well devlink is key speech attached so

00:11:57,920 --> 00:12:01,680
what do we do if our device does not

00:11:59,839 --> 00:12:04,240
have the e-switch and

00:12:01,680 --> 00:12:06,000
it's it's straightforward that this kit

00:12:04,240 --> 00:12:08,480
is optional through the deadline

00:12:06,000 --> 00:12:11,680
uh representation so the device does not

00:12:08,480 --> 00:12:15,920
have any speech it should still

00:12:11,680 --> 00:12:19,040
work just fine so what we see in this

00:12:15,920 --> 00:12:20,079
diagram is a pci device with a pf over

00:12:19,040 --> 00:12:23,120
here

00:12:20,079 --> 00:12:24,800
and on the right side we see here three

00:12:23,120 --> 00:12:27,360
class devices

00:12:24,800 --> 00:12:29,440
through either one or multiple drivers

00:12:27,360 --> 00:12:30,639
in this example it's multiple drivers

00:12:29,440 --> 00:12:34,240
being used

00:12:30,639 --> 00:12:35,920
um which is a mlx five core and mlx by

00:12:34,240 --> 00:12:38,639
iv here

00:12:35,920 --> 00:12:38,959
and uh on the on the left side what we

00:12:38,639 --> 00:12:42,399
see

00:12:38,959 --> 00:12:45,200
is a doubling representation of it

00:12:42,399 --> 00:12:46,880
um through which all the uh the switch

00:12:45,200 --> 00:12:48,720
configuration happens

00:12:46,880 --> 00:12:50,399
so even though it's monolithic driver

00:12:48,720 --> 00:12:52,880
today the nx5 core

00:12:50,399 --> 00:12:54,240
but essentially it has a two-piece with

00:12:52,880 --> 00:12:58,240
the e-speech driver

00:12:54,240 --> 00:12:58,240
and the internet device class

00:12:59,440 --> 00:13:03,200
now let's look at the second part of it

00:13:01,519 --> 00:13:07,200
um

00:13:03,200 --> 00:13:10,320
huh so how does the doubling interface

00:13:07,200 --> 00:13:13,760
is being used when we have

00:13:10,320 --> 00:13:15,420
a split network instead

00:13:13,760 --> 00:13:17,040
excuse me one is

00:13:15,420 --> 00:13:19,040
[Music]

00:13:17,040 --> 00:13:20,560
one is a linux kernel which is running

00:13:19,040 --> 00:13:22,959
on the link itself

00:13:20,560 --> 00:13:25,200
um which is managing the speech which is

00:13:22,959 --> 00:13:27,600
on our left side here

00:13:25,200 --> 00:13:30,000
and on the right side what we see is the

00:13:27,600 --> 00:13:33,040
guest for the host operating system

00:13:30,000 --> 00:13:35,200
uh this is where the pci here we are

00:13:33,040 --> 00:13:36,320
and in the future we want to see the sub

00:13:35,200 --> 00:13:40,330
function

00:13:36,320 --> 00:13:42,000
uh running side by side with appear

00:13:40,330 --> 00:13:45,279
[Music]

00:13:42,000 --> 00:13:48,639
so in this model we can see that

00:13:45,279 --> 00:13:51,440
the isolated kernel

00:13:48,639 --> 00:13:52,880
running on the nic he runs the e-switch

00:13:51,440 --> 00:13:54,560
and

00:13:52,880 --> 00:13:56,880
typically the user running this

00:13:54,560 --> 00:13:58,160
application does not have a direct

00:13:56,880 --> 00:14:01,600
access to the

00:13:58,160 --> 00:14:04,560
the secure nick here on the left

00:14:01,600 --> 00:14:06,240
and as we saw in the user's requirement

00:14:04,560 --> 00:14:08,720
the first one

00:14:06,240 --> 00:14:10,160
is the user should be able to create the

00:14:08,720 --> 00:14:13,920
need

00:14:10,160 --> 00:14:15,279
a virtual need we call it as a function

00:14:13,920 --> 00:14:17,440
here

00:14:15,279 --> 00:14:19,519
just to match with the pc ipf and a

00:14:17,440 --> 00:14:21,360
virtual function

00:14:19,519 --> 00:14:23,600
so user should be able to create this

00:14:21,360 --> 00:14:26,399
nic from the

00:14:23,600 --> 00:14:27,600
from the next side and that nick should

00:14:26,399 --> 00:14:30,720
be hot pluggable

00:14:27,600 --> 00:14:35,600
on the host um

00:14:30,720 --> 00:14:35,600
the guest host system on the right side

00:14:36,399 --> 00:14:43,120
so we will see in few moments um why

00:14:40,000 --> 00:14:44,240
how how that's being achieved but before

00:14:43,120 --> 00:14:46,800
we jump to the

00:14:44,240 --> 00:14:48,160
the doubling part of it um let's let's

00:14:46,800 --> 00:14:51,600
understand that why the

00:14:48,160 --> 00:14:55,040
link uh management is being chosen is um

00:14:51,600 --> 00:14:57,440
today what we have is an ip link command

00:14:55,040 --> 00:14:58,639
to to configure the vf parameters there

00:14:57,440 --> 00:15:01,760
are six or seven

00:14:58,639 --> 00:15:03,199
rear parameters that's been configured

00:15:01,760 --> 00:15:05,199
that's been managed through life

00:15:03,199 --> 00:15:05,760
building command but i feeling command

00:15:05,199 --> 00:15:08,079
does not

00:15:05,760 --> 00:15:08,800
uh fit all the requirements now

00:15:08,079 --> 00:15:11,600
primarily

00:15:08,800 --> 00:15:13,279
it's its inability to follow the create

00:15:11,600 --> 00:15:16,240
configure and deploy model

00:15:13,279 --> 00:15:17,839
it needs to get involved with the csfs

00:15:16,240 --> 00:15:20,240
part of it

00:15:17,839 --> 00:15:22,480
uh to bind and unwind the driver after

00:15:20,240 --> 00:15:26,639
the necessary configuration is done

00:15:22,480 --> 00:15:29,680
secondly the user needs to enable the

00:15:26,639 --> 00:15:31,920
vfs again for the c surface and there is

00:15:29,680 --> 00:15:34,800
a complex locking involved of the

00:15:31,920 --> 00:15:36,560
device lock as well as the network and

00:15:34,800 --> 00:15:40,880
the doubling part of it

00:15:36,560 --> 00:15:43,279
so this this is barely um

00:15:40,880 --> 00:15:46,639
complex as well as it does not address

00:15:43,279 --> 00:15:46,639
the requirements of the music

00:15:47,040 --> 00:15:50,639
it does not handle these assumptions

00:15:50,000 --> 00:15:53,920
today

00:15:50,639 --> 00:15:54,399
so that something is hard to extend here

00:15:53,920 --> 00:15:56,800
um

00:15:54,399 --> 00:15:59,120
and and mainly it's missing the

00:15:56,800 --> 00:16:01,199
presentation with the switchbar model

00:15:59,120 --> 00:16:03,920
um here's the representer and the

00:16:01,199 --> 00:16:05,279
doubling code is the one that

00:16:03,920 --> 00:16:07,680
extends the current switching

00:16:05,279 --> 00:16:09,120
functionality so it makes sense to

00:16:07,680 --> 00:16:11,600
extend the leveling

00:16:09,120 --> 00:16:12,320
speech the model uh for the sub

00:16:11,600 --> 00:16:16,240
functions

00:16:12,320 --> 00:16:19,440
rather than extending the iq set command

00:16:16,240 --> 00:16:22,560
which is actually not possible when we

00:16:19,440 --> 00:16:25,120
talk of two systems as we have seen here

00:16:22,560 --> 00:16:25,759
the ipl link command is just not usable

00:16:25,120 --> 00:16:29,279
on the

00:16:25,759 --> 00:16:29,680
nic because the sriv is not even enabled

00:16:29,279 --> 00:16:32,320
here

00:16:29,680 --> 00:16:33,519
sriv is enabled on the right on the test

00:16:32,320 --> 00:16:35,440
system

00:16:33,519 --> 00:16:38,320
so that's why we will need something

00:16:35,440 --> 00:16:41,040
generic unique enough

00:16:38,320 --> 00:16:43,279
that can be done through the doubling

00:16:41,040 --> 00:16:45,360
that works in both the use cases

00:16:43,279 --> 00:16:48,320
if these two are single system or the

00:16:45,360 --> 00:16:48,320
dual system mode

00:16:48,480 --> 00:16:53,040
second second option ruled out in second

00:16:51,199 --> 00:16:54,880
and third are very interconnected is

00:16:53,040 --> 00:16:56,320
either to use cc sequence or

00:16:54,880 --> 00:17:00,000
configuration

00:16:56,320 --> 00:17:04,400
um as soon as we expose the csfs

00:17:00,000 --> 00:17:07,760
um it it opens the security problem to

00:17:04,400 --> 00:17:09,919
um that it's going to be network name

00:17:07,760 --> 00:17:12,400
space aware or not

00:17:09,919 --> 00:17:13,039
and that's something that we want to

00:17:12,400 --> 00:17:15,760
avoid

00:17:13,039 --> 00:17:18,000
um the network is pretty baked into it

00:17:15,760 --> 00:17:22,559
to handle that scenario

00:17:18,000 --> 00:17:22,559
c surface and config fs misses um

00:17:22,959 --> 00:17:28,640
the main error reporting capability

00:17:26,240 --> 00:17:29,360
where a user gives an incorrect

00:17:28,640 --> 00:17:32,799
parameter

00:17:29,360 --> 00:17:35,760
or or a configuration

00:17:32,799 --> 00:17:36,880
command and there is just one way to

00:17:35,760 --> 00:17:38,880
return the error

00:17:36,880 --> 00:17:40,640
is an error code and that does not tell

00:17:38,880 --> 00:17:41,679
that out of six parameters which was

00:17:40,640 --> 00:17:45,120
wrong

00:17:41,679 --> 00:17:48,400
now netlink is is fairly uh

00:17:45,120 --> 00:17:50,480
you know with the extended app um third

00:17:48,400 --> 00:17:52,160
when we want to scale to large number of

00:17:50,480 --> 00:17:54,720
sub functions

00:17:52,160 --> 00:17:55,600
in range of hundreds um it may not be a

00:17:54,720 --> 00:17:58,000
good idea

00:17:55,600 --> 00:17:59,600
to create the configuration files for

00:17:58,000 --> 00:18:02,320
each of the small parameter

00:17:59,600 --> 00:18:03,919
and configure and consume the inode

00:18:02,320 --> 00:18:05,120
entries

00:18:03,919 --> 00:18:07,440
and all of this applies to the

00:18:05,120 --> 00:18:09,600
configurations as well

00:18:07,440 --> 00:18:11,360
that it misses some of the netting

00:18:09,600 --> 00:18:14,400
features that we've done

00:18:11,360 --> 00:18:14,720
and and creating some of these interface

00:18:14,400 --> 00:18:18,160
with

00:18:14,720 --> 00:18:21,440
um another representative model

00:18:18,160 --> 00:18:24,240
uh just doesn't make sense

00:18:21,440 --> 00:18:25,360
and the other option if you would like

00:18:24,240 --> 00:18:28,000
to rule out

00:18:25,360 --> 00:18:28,720
is why not create a character device

00:18:28,000 --> 00:18:31,840
with knight

00:18:28,720 --> 00:18:35,039
hell or the right command

00:18:31,840 --> 00:18:36,559
to do all the configurations um which

00:18:35,039 --> 00:18:38,640
which can be done through the existing

00:18:36,559 --> 00:18:41,360
network or leveling interface

00:18:38,640 --> 00:18:42,320
and i think we would be reinventing the

00:18:41,360 --> 00:18:46,080
wheel

00:18:42,320 --> 00:18:48,559
in in taking of this approach because

00:18:46,080 --> 00:18:50,960
um net link already has the features for

00:18:48,559 --> 00:18:54,640
tracing errors network name space

00:18:50,960 --> 00:18:55,120
tlb attributes all the nested attributes

00:18:54,640 --> 00:18:58,720
that

00:18:55,120 --> 00:19:00,720
can be extended um and and

00:18:58,720 --> 00:19:02,640
and implementing all of that over again

00:19:00,720 --> 00:19:06,320
over the

00:19:02,640 --> 00:19:07,360
character device yeah just doesn't make

00:19:06,320 --> 00:19:09,360
sense

00:19:07,360 --> 00:19:11,360
um so i think that way that the devil

00:19:09,360 --> 00:19:15,039
link is fairly mature

00:19:11,360 --> 00:19:18,960
that addresses all the needs of the user

00:19:15,039 --> 00:19:18,960
to create this function

00:19:19,440 --> 00:19:25,840
and manage and configure them

00:19:22,559 --> 00:19:28,160
and hence let's see the flow of how

00:19:25,840 --> 00:19:30,480
how users would like to see them being

00:19:28,160 --> 00:19:33,679
created and used

00:19:30,480 --> 00:19:35,039
so the three-step process is is the

00:19:33,679 --> 00:19:38,480
fundamental to

00:19:35,039 --> 00:19:39,919
managing function is create when it's

00:19:38,480 --> 00:19:42,640
created it is

00:19:39,919 --> 00:19:44,320
practically in an inactive state or an

00:19:42,640 --> 00:19:46,640
unused state

00:19:44,320 --> 00:19:49,360
the second step is configure where the

00:19:46,640 --> 00:19:52,799
user does the necessary configuration

00:19:49,360 --> 00:19:56,320
for a sub function

00:19:52,799 --> 00:19:59,360
ends with presenter mac address and once

00:19:56,320 --> 00:20:02,400
the configuration is enough

00:19:59,360 --> 00:20:04,480
that the device is actually usable the

00:20:02,400 --> 00:20:06,880
third place comes with the deploy

00:20:04,480 --> 00:20:08,960
and in the deploy phase the device is

00:20:06,880 --> 00:20:12,080
deployed either on the local system

00:20:08,960 --> 00:20:12,559
or onto the external host system in

00:20:12,080 --> 00:20:15,679
which

00:20:12,559 --> 00:20:18,840
this new card is connected

00:20:15,679 --> 00:20:20,400
all the three steps are done on the nik

00:20:18,840 --> 00:20:23,039
side

00:20:20,400 --> 00:20:24,720
where the switch is located again

00:20:23,039 --> 00:20:28,000
e-switch is optional

00:20:24,720 --> 00:20:29,679
but in our case these which exist

00:20:28,000 --> 00:20:31,280
and the user would like to use it using

00:20:29,679 --> 00:20:34,240
the pc uploads

00:20:31,280 --> 00:20:34,720
in an open source manner so the three

00:20:34,240 --> 00:20:37,280
commands

00:20:34,720 --> 00:20:38,400
happens on the usb system now the

00:20:37,280 --> 00:20:41,919
question happens what

00:20:38,400 --> 00:20:42,320
what is the case if we have a non-smart

00:20:41,919 --> 00:20:45,840
nic

00:20:42,320 --> 00:20:49,360
or or just a nic with a speech on it

00:20:45,840 --> 00:20:51,280
um which perfectly works fine

00:20:49,360 --> 00:20:54,000
because then you have a single system

00:20:51,280 --> 00:20:55,919
and the nic has the e-switch on it

00:20:54,000 --> 00:20:58,159
it's a single system who's going to do

00:20:55,919 --> 00:21:02,080
create configure and deploy companies

00:20:58,159 --> 00:21:03,280
so very similar to um sriv devices that

00:21:02,080 --> 00:21:06,559
exist without

00:21:03,280 --> 00:21:06,559
the smartnet configuration

00:21:07,039 --> 00:21:10,240
so now what happens in the create and

00:21:09,039 --> 00:21:11,600
delete

00:21:10,240 --> 00:21:13,280
create and delete is fairly

00:21:11,600 --> 00:21:15,039
straightforward it's been done through a

00:21:13,280 --> 00:21:17,840
developing code

00:21:15,039 --> 00:21:19,200
initially we started with something

00:21:17,840 --> 00:21:21,840
called virtual device

00:21:19,200 --> 00:21:22,799
then we thought a slice would be a

00:21:21,840 --> 00:21:26,960
better name

00:21:22,799 --> 00:21:26,960
to say slice of your device as a portion

00:21:27,760 --> 00:21:32,559
but i think overall in upstream we

00:21:30,080 --> 00:21:35,919
agreed that the leveling port

00:21:32,559 --> 00:21:38,799
is uh is better suitable that

00:21:35,919 --> 00:21:39,360
has can have a port function um which is

00:21:38,799 --> 00:21:42,880
what

00:21:39,360 --> 00:21:45,120
we can configure um the port function

00:21:42,880 --> 00:21:48,400
object is the one that represents

00:21:45,120 --> 00:21:49,840
um the whole set of functionality it's

00:21:48,400 --> 00:21:51,760
it's better to note the difference

00:21:49,840 --> 00:21:53,919
between the port function and the code

00:21:51,760 --> 00:21:55,039
um since the port is attached to the

00:21:53,919 --> 00:21:57,039
e-switch

00:21:55,039 --> 00:21:58,320
and there is only one code for the whole

00:21:57,039 --> 00:22:01,200
device um

00:21:58,320 --> 00:22:03,440
for a sub function um so the port

00:22:01,200 --> 00:22:05,440
represents its own um

00:22:03,440 --> 00:22:06,720
these we set up capabilities where the

00:22:05,440 --> 00:22:09,120
port function

00:22:06,720 --> 00:22:10,720
represents the capabilities of the

00:22:09,120 --> 00:22:12,640
attributes i'm sorry not just

00:22:10,720 --> 00:22:15,440
capabilities but the attributes

00:22:12,640 --> 00:22:16,320
attributes of the function it can be a

00:22:15,440 --> 00:22:19,679
pci

00:22:16,320 --> 00:22:22,090
here or a virtual function sriv

00:22:19,679 --> 00:22:23,760
or it could be a sub function and

00:22:22,090 --> 00:22:25,840
[Music]

00:22:23,760 --> 00:22:27,360
it's good to notice that it's it's a

00:22:25,840 --> 00:22:29,679
unified interface

00:22:27,360 --> 00:22:31,200
regardless of being a virtual function

00:22:29,679 --> 00:22:33,120
or a sub function

00:22:31,200 --> 00:22:34,400
that gives a much easier access to the

00:22:33,120 --> 00:22:37,200
users and

00:22:34,400 --> 00:22:38,840
how the how they can switch over between

00:22:37,200 --> 00:22:41,840
using virtual functions or just

00:22:38,840 --> 00:22:41,840
functions

00:22:44,640 --> 00:22:48,320
sorry the second part of it is the

00:22:46,480 --> 00:22:51,600
deploy

00:22:48,320 --> 00:22:53,039
when the user chose to create a doubling

00:22:51,600 --> 00:22:55,039
port

00:22:53,039 --> 00:22:57,440
the user has chosen whether he wants

00:22:55,039 --> 00:23:01,520
from this system or the other system

00:22:57,440 --> 00:23:04,799
um on the external host system

00:23:01,520 --> 00:23:07,440
and that has a strong tie up with

00:23:04,799 --> 00:23:09,280
how the representers are created for

00:23:07,440 --> 00:23:11,360
this port we will see the example in a

00:23:09,280 --> 00:23:14,320
moment

00:23:11,360 --> 00:23:14,799
um but in the final stage of the deploy

00:23:14,320 --> 00:23:17,039
is

00:23:14,799 --> 00:23:19,039
very similar to a hot plug or a hot

00:23:17,039 --> 00:23:22,640
envelope of the device where

00:23:19,039 --> 00:23:24,640
um already configured device

00:23:22,640 --> 00:23:26,799
shows up into the whole system where

00:23:24,640 --> 00:23:30,559
it's being deployed

00:23:26,799 --> 00:23:34,000
so let's see the examples uh in a moment

00:23:30,559 --> 00:23:35,440
and let's do a um value of the software

00:23:34,000 --> 00:23:38,880
stack involved in

00:23:35,440 --> 00:23:40,480
supporting this so the user starts from

00:23:38,880 --> 00:23:42,720
the usb system

00:23:40,480 --> 00:23:44,799
as a user will issue a doubling command

00:23:42,720 --> 00:23:47,039
to say add a port

00:23:44,799 --> 00:23:49,440
it comes to the designing module here

00:23:47,039 --> 00:23:51,919
which calls the callback function of the

00:23:49,440 --> 00:23:53,440
index.pro driver here which is a vendor

00:23:51,919 --> 00:23:57,039
driver

00:23:53,440 --> 00:23:59,279
the vendor driver issues any firmware

00:23:57,039 --> 00:24:01,360
or device specific commands to add the

00:23:59,279 --> 00:24:03,440
port

00:24:01,360 --> 00:24:05,440
and at the same time when you present or

00:24:03,440 --> 00:24:08,559
device is also created

00:24:05,440 --> 00:24:11,200
um for this development code and

00:24:08,559 --> 00:24:12,080
the user now can configure the obs

00:24:11,200 --> 00:24:14,240
policies

00:24:12,080 --> 00:24:16,080
or rules or the pc was obviously

00:24:14,240 --> 00:24:17,279
obviously not mentally but i just took

00:24:16,080 --> 00:24:20,799
an example here

00:24:17,279 --> 00:24:24,240
to show that it's been usable to the

00:24:20,799 --> 00:24:24,799
representative um the system b or the u

00:24:24,240 --> 00:24:28,159
dave

00:24:24,799 --> 00:24:30,559
will rename the representative device

00:24:28,159 --> 00:24:33,360
based on the first port name

00:24:30,559 --> 00:24:34,960
and speech id being exposed for this

00:24:33,360 --> 00:24:37,679
deadly code

00:24:34,960 --> 00:24:38,559
this gives us the uh the vendor neutral

00:24:37,679 --> 00:24:42,480
way to

00:24:38,559 --> 00:24:42,960
name the um represent our device of the

00:24:42,480 --> 00:24:46,480
pf

00:24:42,960 --> 00:24:49,200
vfn for pf and v if we already have it

00:24:46,480 --> 00:24:49,760
uh sub function is is just an extension

00:24:49,200 --> 00:24:52,480
to

00:24:49,760 --> 00:24:54,880
make use of the existing system view

00:24:52,480 --> 00:24:58,080
meaning scheme

00:24:54,880 --> 00:25:00,480
okay so user created the device the next

00:24:58,080 --> 00:25:02,480
step is the configuration he would do

00:25:00,480 --> 00:25:07,200
the configuration using the same

00:25:02,480 --> 00:25:07,200
tool here using a port function

00:25:07,919 --> 00:25:12,400
and the third step would be to activate

00:25:10,480 --> 00:25:13,200
this device that the configuration is

00:25:12,400 --> 00:25:15,919
done

00:25:13,200 --> 00:25:17,279
so when it's activated we can see that

00:25:15,919 --> 00:25:20,720
this through the arrow

00:25:17,279 --> 00:25:23,919
that if this device is being created

00:25:20,720 --> 00:25:25,600
for the user's host system in this

00:25:23,919 --> 00:25:27,360
example i took two different system

00:25:25,600 --> 00:25:29,440
because it's easy to visualize

00:25:27,360 --> 00:25:30,559
and once with the two system here is

00:25:29,440 --> 00:25:32,720
clear then

00:25:30,559 --> 00:25:34,240
it's it's very easy to see that the same

00:25:32,720 --> 00:25:37,360
thing works on the

00:25:34,240 --> 00:25:39,120
single system tool so

00:25:37,360 --> 00:25:41,120
when when it's being deployed it's

00:25:39,120 --> 00:25:44,080
deployed onto the remote system

00:25:41,120 --> 00:25:44,720
where for the sub function shows uh

00:25:44,080 --> 00:25:46,720
event

00:25:44,720 --> 00:25:49,440
comes up saying well there is a hot plug

00:25:46,720 --> 00:25:51,840
even and the pcipf

00:25:49,440 --> 00:25:54,400
for which the device is created would

00:25:51,840 --> 00:25:56,720
create a wordpress device

00:25:54,400 --> 00:25:57,760
this is the wordpress device that would

00:25:56,720 --> 00:26:00,159
um

00:25:57,760 --> 00:26:01,120
show up on a software bus called a word

00:26:00,159 --> 00:26:04,159
dev

00:26:01,120 --> 00:26:07,039
and now this is the ready device

00:26:04,159 --> 00:26:07,760
so that the wordpress driver can match

00:26:07,039 --> 00:26:09,520
to it

00:26:07,760 --> 00:26:11,360
using the classic probe and remove

00:26:09,520 --> 00:26:14,640
functions uh

00:26:11,360 --> 00:26:17,440
probes for the hot plug event and uh

00:26:14,640 --> 00:26:18,559
remove for the amphibian and when the

00:26:17,440 --> 00:26:21,200
driver shows up

00:26:18,559 --> 00:26:23,039
uh when it's loaded then he would create

00:26:21,200 --> 00:26:25,039
its own class devices

00:26:23,039 --> 00:26:26,960
it could be combination of these three

00:26:25,039 --> 00:26:30,880
in the device rdma or will

00:26:26,960 --> 00:26:34,960
here or just a few of them

00:26:30,880 --> 00:26:38,559
and the system b here running would name

00:26:34,960 --> 00:26:40,400
the rdma and the devices based on the

00:26:38,559 --> 00:26:40,720
naming scheme that will be extended for

00:26:40,400 --> 00:26:43,919
this

00:26:40,720 --> 00:26:49,039
function so with this

00:26:43,919 --> 00:26:52,559
we we get a clear view of how

00:26:49,039 --> 00:26:55,679
how the cloud user can

00:26:52,559 --> 00:26:59,039
create and activate

00:26:55,679 --> 00:27:00,960
the device from the e-speech side and

00:26:59,039 --> 00:27:04,799
the applications running on the whole

00:27:00,960 --> 00:27:04,799
system can make use of

00:27:04,840 --> 00:27:08,480
it

00:27:06,159 --> 00:27:09,440
so i think it's time to see some of the

00:27:08,480 --> 00:27:13,200
examples

00:27:09,440 --> 00:27:15,919
at the leveling flavor to get a feed of

00:27:13,200 --> 00:27:19,039
how how the commands are gonna run and

00:27:15,919 --> 00:27:21,679
how the naming scheme looks like

00:27:19,039 --> 00:27:22,640
so now we go through the same example

00:27:21,679 --> 00:27:25,679
sequence

00:27:22,640 --> 00:27:27,760
is a port ad when

00:27:25,679 --> 00:27:28,880
when you add a code you say on pci

00:27:27,760 --> 00:27:33,279
device my

00:27:28,880 --> 00:27:36,000
flavor is sf on pci except flavor

00:27:33,279 --> 00:27:36,480
create a device for f number zero we

00:27:36,000 --> 00:27:39,360
have

00:27:36,480 --> 00:27:39,919
step number 46 i just chose the random

00:27:39,360 --> 00:27:44,720
number

00:27:39,919 --> 00:27:46,880
user user chosen number 46 to

00:27:44,720 --> 00:27:50,080
show but it could be an auto selected

00:27:46,880 --> 00:27:52,240
way where the user does not choose

00:27:50,080 --> 00:27:53,200
but the system can choose whichever is a

00:27:52,240 --> 00:27:55,840
psf

00:27:53,200 --> 00:27:56,799
he can pick the device however in most

00:27:55,840 --> 00:27:58,640
most cases

00:27:56,799 --> 00:28:00,559
the user might want to choose their set

00:27:58,640 --> 00:28:02,960
number because we will see

00:28:00,559 --> 00:28:04,240
how it's been attached to the several

00:28:02,960 --> 00:28:08,720
naming schemes that

00:28:04,240 --> 00:28:11,520
that is being baked with the remembering

00:28:08,720 --> 00:28:14,840
so once the port is added the user

00:28:11,520 --> 00:28:16,640
issues the commands in the game

00:28:14,840 --> 00:28:19,440
portfolio

00:28:16,640 --> 00:28:20,960
the port is visible using this new port

00:28:19,440 --> 00:28:22,960
index one

00:28:20,960 --> 00:28:24,159
and the representer device is being

00:28:22,960 --> 00:28:28,720
constructed

00:28:24,159 --> 00:28:29,600
using um the name pf0 and sf46 which is

00:28:28,720 --> 00:28:31,840
what user has

00:28:29,600 --> 00:28:31,840
passed

00:28:32,720 --> 00:28:36,159
the third step user would do is to do

00:28:34,880 --> 00:28:38,640
the configuration

00:28:36,159 --> 00:28:40,159
um the code configuration in this

00:28:38,640 --> 00:28:41,200
example we are doing only two

00:28:40,159 --> 00:28:43,679
configuration

00:28:41,200 --> 00:28:45,840
actually one one which is just the mac

00:28:43,679 --> 00:28:48,399
address configuration

00:28:45,840 --> 00:28:50,559
so the mac address is configured and the

00:28:48,399 --> 00:28:54,000
user activates the device

00:28:50,559 --> 00:28:56,799
um it is important to note that

00:28:54,000 --> 00:28:58,159
this the activation should be done only

00:28:56,799 --> 00:28:59,039
after the mac address is being

00:28:58,159 --> 00:29:01,120
configured

00:28:59,039 --> 00:29:02,080
so all configuration followed by the

00:29:01,120 --> 00:29:05,200
scale

00:29:02,080 --> 00:29:08,159
will activate the devices we will see

00:29:05,200 --> 00:29:11,440
the port delete in a moment after we

00:29:08,159 --> 00:29:11,440
show some more examples

00:29:11,520 --> 00:29:16,559
so um doubling this we are still at the

00:29:15,120 --> 00:29:18,720
developing course show command

00:29:16,559 --> 00:29:22,720
still on the e-speed side uh this is

00:29:18,720 --> 00:29:25,279
just for json representation of

00:29:22,720 --> 00:29:27,440
various fields here you will see the the

00:29:25,279 --> 00:29:30,880
attitudes to state

00:29:27,440 --> 00:29:30,880
the operational state in a moment

00:29:32,480 --> 00:29:40,559
so we saw we saw in the previous

00:29:35,600 --> 00:29:43,120
command here that the user activated

00:29:40,559 --> 00:29:44,399
this port function and when the state

00:29:43,120 --> 00:29:46,640
was activated

00:29:44,399 --> 00:29:48,559
the device is expected to show up onto

00:29:46,640 --> 00:29:50,880
the host system

00:29:48,559 --> 00:29:52,399
so on the whole system if you see at the

00:29:50,880 --> 00:29:54,799
develop level

00:29:52,399 --> 00:29:57,360
this is the pci device that i used the

00:29:54,799 --> 00:30:00,399
zero is the pf number

00:29:57,360 --> 00:30:03,200
um on this here

00:30:00,399 --> 00:30:03,440
a new sub function showed up and which

00:30:03,200 --> 00:30:06,559
is

00:30:03,440 --> 00:30:08,399
named after this psf number 46

00:30:06,559 --> 00:30:10,640
now we can see that since the user

00:30:08,399 --> 00:30:11,200
specified it he wants to see the same

00:30:10,640 --> 00:30:15,200
number

00:30:11,200 --> 00:30:16,880
even after um this configuration is done

00:30:15,200 --> 00:30:23,200
across the reboot

00:30:16,880 --> 00:30:25,039
um and when the healthy portals are run

00:30:23,200 --> 00:30:27,600
if the scripts are returned onto the

00:30:25,039 --> 00:30:27,919
host which is expecting it to be running

00:30:27,600 --> 00:30:31,520
on

00:30:27,919 --> 00:30:34,159
sf number 46 we don't want that to break

00:30:31,520 --> 00:30:36,080
and that's why the device naming here

00:30:34,159 --> 00:30:38,399
for the soft function is picked up based

00:30:36,080 --> 00:30:39,440
on the sf number and its parent pci

00:30:38,399 --> 00:30:42,640
device

00:30:39,440 --> 00:30:44,559
unlike um a word was device because on a

00:30:42,640 --> 00:30:46,960
wordpress or software device the ids

00:30:44,559 --> 00:30:46,960
could be

00:30:47,279 --> 00:30:52,320
could be a random number and and the

00:30:50,320 --> 00:30:55,039
user script will start creating

00:30:52,320 --> 00:30:56,640
and hence it's its desire to have the

00:30:55,039 --> 00:30:57,840
deviling scripts and the weapon

00:30:56,640 --> 00:31:00,159
infrastructure

00:30:57,840 --> 00:31:03,519
to have the sf number and the current

00:31:00,159 --> 00:31:05,360
pci device back into it

00:31:03,519 --> 00:31:07,679
and the last command that we would like

00:31:05,360 --> 00:31:10,320
to see is that every code show

00:31:07,679 --> 00:31:11,519
here if you can see the the the net

00:31:10,320 --> 00:31:13,919
device is created

00:31:11,519 --> 00:31:15,279
this is the class that was created for

00:31:13,919 --> 00:31:19,039
the sub function

00:31:15,279 --> 00:31:22,880
with its own enhanced

00:31:19,039 --> 00:31:23,440
which is s46 s stands for the sub

00:31:22,880 --> 00:31:26,960
function

00:31:23,440 --> 00:31:26,960
and this is a function number

00:31:29,039 --> 00:31:34,880
so keep in mind these are the patches

00:31:32,240 --> 00:31:36,559
um that you would like to have this is

00:31:34,880 --> 00:31:39,440
the rfc that's been posted

00:31:36,559 --> 00:31:40,080
uh three months back and being reviewed

00:31:39,440 --> 00:31:43,360
uh

00:31:40,080 --> 00:31:43,760
a few times over the needing list and

00:31:43,360 --> 00:31:45,440
this

00:31:43,760 --> 00:31:49,840
these are the patches that would like to

00:31:45,440 --> 00:31:49,840
carry forward in 510 and finally

00:31:52,799 --> 00:32:01,120
so i am almost about to

00:31:56,799 --> 00:32:01,120
time should do a thank

00:32:02,960 --> 00:32:06,880
and these are the two parts of detail

00:32:05,360 --> 00:32:09,360
that i wanted to go through

00:32:06,880 --> 00:32:09,360
but um

00:32:10,720 --> 00:32:15,440
so this is basically a state machine of

00:32:13,039 --> 00:32:17,360
the sub function

00:32:15,440 --> 00:32:19,360
it enters into an inactive state by

00:32:17,360 --> 00:32:20,799
default and the user is expected to

00:32:19,360 --> 00:32:23,360
activate it

00:32:20,799 --> 00:32:24,399
and when it's activated we saw the

00:32:23,360 --> 00:32:27,200
sequence

00:32:24,399 --> 00:32:28,960
that it creates the device into a new

00:32:27,200 --> 00:32:31,279
bus onto a whole system

00:32:28,960 --> 00:32:32,480
it's a hot plug event and when it's

00:32:31,279 --> 00:32:34,720
inactivated

00:32:32,480 --> 00:32:36,480
uh it's a hot on plug event and we would

00:32:34,720 --> 00:32:39,760
like to have the hotend plug

00:32:36,480 --> 00:32:41,840
as um as a gracefully order so

00:32:39,760 --> 00:32:42,880
in most cases it could be a baseball

00:32:41,840 --> 00:32:45,679
where the

00:32:42,880 --> 00:32:46,559
from the ac system the user can destroy

00:32:45,679 --> 00:32:49,919
the device

00:32:46,559 --> 00:32:52,640
and wait for driver to get unloaded

00:32:49,919 --> 00:32:54,960
and once it's uploaded the user can

00:32:52,640 --> 00:32:58,320
delete the device

00:32:54,960 --> 00:33:00,799
so the two states are being split out um

00:32:58,320 --> 00:33:02,480
one is the port function state which is

00:33:00,799 --> 00:33:05,600
what we saw in our

00:33:02,480 --> 00:33:07,519
previous statement here the next state

00:33:05,600 --> 00:33:11,679
machine here what we see

00:33:07,519 --> 00:33:15,120
is of the um of the driver state

00:33:11,679 --> 00:33:17,360
and uh the e-speed system needs to know

00:33:15,120 --> 00:33:19,360
what's the state of the device if the

00:33:17,360 --> 00:33:22,159
driver is detached or not

00:33:19,360 --> 00:33:22,799
uh from the drive from the device so

00:33:22,159 --> 00:33:24,960
that it's

00:33:22,799 --> 00:33:27,120
safe to remove the device and

00:33:24,960 --> 00:33:29,360
reprovision or reactivate the device

00:33:27,120 --> 00:33:32,960
again

00:33:29,360 --> 00:33:36,080
onto the same system so here

00:33:32,960 --> 00:33:37,840
we can see that um by default it it is

00:33:36,080 --> 00:33:40,799
into a detached state and when it's

00:33:37,840 --> 00:33:41,919
activated a new wordpress device gets

00:33:40,799 --> 00:33:44,559
created

00:33:41,919 --> 00:33:45,440
and its probe is being called the driver

00:33:44,559 --> 00:33:47,519
binds to it

00:33:45,440 --> 00:33:48,640
and the device moves into an attach to

00:33:47,519 --> 00:33:51,760
it

00:33:48,640 --> 00:33:52,640
and when when it's removed in a graceful

00:33:51,760 --> 00:33:54,880
way

00:33:52,640 --> 00:33:57,200
the remove moves it into a detached to

00:33:54,880 --> 00:33:59,279
it it is inside some

00:33:57,200 --> 00:34:01,200
user's responsibility to monitor the

00:33:59,279 --> 00:34:02,080
state and make sure that the device is

00:34:01,200 --> 00:34:04,430
removed

00:34:02,080 --> 00:34:05,600
after it's been detached

00:34:04,430 --> 00:34:08,720
[Music]

00:34:05,600 --> 00:34:11,919
and in the case when

00:34:08,720 --> 00:34:13,839
the driver is misbehaving um

00:34:11,919 --> 00:34:17,200
in that case the ac system will keep

00:34:13,839 --> 00:34:19,359
marking and keep mark as detached

00:34:17,200 --> 00:34:21,040
and they could wait for enough time out

00:34:19,359 --> 00:34:24,639
before declaring that this

00:34:21,040 --> 00:34:28,159
this device is not usable um

00:34:24,639 --> 00:34:29,119
or if the pcipf resets into the host

00:34:28,159 --> 00:34:31,679
system

00:34:29,119 --> 00:34:34,079
in that case the device is reusable

00:34:31,679 --> 00:34:35,040
because it was a pci fly reset that

00:34:34,079 --> 00:34:38,079
happened

00:34:35,040 --> 00:34:40,399
and now the device is being cleared

00:34:38,079 --> 00:34:42,159
so in either of the two cases it would

00:34:40,399 --> 00:34:46,639
move into a detached event

00:34:42,159 --> 00:34:48,960
in a error clone and in a graceful way

00:34:46,639 --> 00:34:51,839
the drivers remove would move the device

00:34:48,960 --> 00:34:51,839
into the b test

00:34:54,159 --> 00:35:01,359
that that aligns on

00:34:57,760 --> 00:35:02,480
our three two parts um for the part of

00:35:01,359 --> 00:35:05,359
the jigsaw puzzle

00:35:02,480 --> 00:35:07,119
is um the user requirements the current

00:35:05,359 --> 00:35:10,160
state of the dev link

00:35:07,119 --> 00:35:11,839
and the proposed building extensions

00:35:10,160 --> 00:35:15,119
that we would like to

00:35:11,839 --> 00:35:17,599
do through the doubling code to handle

00:35:15,119 --> 00:35:18,240
all the sub functions um all the three

00:35:17,599 --> 00:35:21,839
create

00:35:18,240 --> 00:35:26,000
comfortable and different tools

00:35:21,839 --> 00:35:28,320
these are the rfcs that we have

00:35:26,000 --> 00:35:29,680
over the mailing list over the last few

00:35:28,320 --> 00:35:31,359
months

00:35:29,680 --> 00:35:32,880
some packages are watched or mainly

00:35:31,359 --> 00:35:36,000
around code function

00:35:32,880 --> 00:35:39,200
to manage the port on the usb side

00:35:36,000 --> 00:35:39,200
or from the whole system

00:35:41,040 --> 00:35:44,079
if you have questions

00:35:49,599 --> 00:35:52,640
we still have some of the open issues

00:35:52,000 --> 00:35:54,240
and

00:35:52,640 --> 00:35:57,119
the open issues are something that you

00:35:54,240 --> 00:36:00,079
see on the screen is um

00:35:57,119 --> 00:36:00,640
um we are missing the host annotation

00:36:00,079 --> 00:36:04,400
from the

00:36:00,640 --> 00:36:13,839
multiple hosts uh in in this diagram we

00:36:04,400 --> 00:36:13,839
saw there are two hosts involved

00:36:15,119 --> 00:36:18,800
okay so we see here there are two hosts

00:36:17,680 --> 00:36:20,880
involved the

00:36:18,800 --> 00:36:22,640
system and the user and some application

00:36:20,880 --> 00:36:25,599
user might want to create

00:36:22,640 --> 00:36:27,920
the sub function on the e6 system itself

00:36:25,599 --> 00:36:30,400
and both can have the same pci

00:36:27,920 --> 00:36:32,640
naming scheme because they both belong

00:36:30,400 --> 00:36:35,040
to two different root complexes

00:36:32,640 --> 00:36:36,560
so the pci device name zero three zero

00:36:35,040 --> 00:36:38,640
zero pdf

00:36:36,560 --> 00:36:40,000
can be seen here on the user whole

00:36:38,640 --> 00:36:44,320
system too

00:36:40,000 --> 00:36:46,560
and that's why um we need an annotation

00:36:44,320 --> 00:36:48,960
to say create the device on this

00:36:46,560 --> 00:36:50,640
particular post

00:36:48,960 --> 00:36:53,359
so this is something that we would like

00:36:50,640 --> 00:36:56,079
to drive earlier

00:36:53,359 --> 00:36:57,680
to have the consistent meaning for this

00:36:56,079 --> 00:37:02,000
function

00:36:57,680 --> 00:37:04,079
the second open item in a while is um

00:37:02,000 --> 00:37:06,880
requisite is to have the virtual bus

00:37:04,079 --> 00:37:08,880
what was being merged into the karma

00:37:06,880 --> 00:37:11,520
which has more use cases than just the

00:37:08,880 --> 00:37:11,520
sub function

00:37:12,640 --> 00:37:17,599
so once this is done you would like to

00:37:14,240 --> 00:37:19,839
use this information function series

00:37:17,599 --> 00:37:22,480
the third and the typical task is to

00:37:19,839 --> 00:37:25,520
have the provisioning flow

00:37:22,480 --> 00:37:26,960
for the vf and safety is same currently

00:37:25,520 --> 00:37:30,320
the vf's are enabled

00:37:26,960 --> 00:37:31,119
from the host system using the csfs and

00:37:30,320 --> 00:37:33,119
that's

00:37:31,119 --> 00:37:35,599
relatively and hard flow to achieve at

00:37:33,119 --> 00:37:35,599
this point

00:37:35,760 --> 00:37:38,800
the two some of the minor points that i

00:37:37,680 --> 00:37:40,560
see is um

00:37:38,800 --> 00:37:42,720
in future if we need to enable the

00:37:40,560 --> 00:37:46,400
immune on the wordpress

00:37:42,720 --> 00:37:48,079
then that something may be required and

00:37:46,400 --> 00:37:51,280
we should do

00:37:48,079 --> 00:37:51,280
as the time of year

00:37:52,960 --> 00:37:58,320
and the fifth one is to to enable

00:37:55,520 --> 00:38:01,119
specific class devices on a particular

00:37:58,320 --> 00:38:01,760
sub function or virtual function for

00:38:01,119 --> 00:38:04,480
example

00:38:01,760 --> 00:38:05,839
have arduino net device and vpa all

00:38:04,480 --> 00:38:08,079
enable together

00:38:05,839 --> 00:38:09,200
or only some of them depending on the

00:38:08,079 --> 00:38:11,680
use case

00:38:09,200 --> 00:38:13,440
uh we believe that these configuration

00:38:11,680 --> 00:38:14,480
should be done on the whole system where

00:38:13,440 --> 00:38:17,520
it's actually being

00:38:14,480 --> 00:38:18,320
used so how how a device should be used

00:38:17,520 --> 00:38:20,800
is

00:38:18,320 --> 00:38:22,240
likely a conflict that should give into

00:38:20,800 --> 00:38:25,839
the whole system

00:38:22,240 --> 00:38:29,040
rather than on the usb system

00:38:25,839 --> 00:38:32,400
um so these are these are the open

00:38:29,040 --> 00:38:34,079
trending issues that uh likely would

00:38:32,400 --> 00:38:37,040
like to have uh letters in the

00:38:34,079 --> 00:38:37,040
subsequent series

00:38:38,160 --> 00:38:41,599
once the infrastructure is being do

00:38:42,000 --> 00:38:47,359
and that brings the my session to an end

00:38:45,520 --> 00:38:49,280
if you have questions in comments uh

00:38:47,359 --> 00:38:52,000
feel free to send me an email

00:38:49,280 --> 00:38:53,680
or if you like to discuss on the mailing

00:38:52,000 --> 00:38:56,880
list um

00:38:53,680 --> 00:39:00,640
there are links to the updates you can

00:38:56,880 --> 00:39:05,040
discuss over reading this as well

00:39:00,640 --> 00:39:05,040
that's all i have thank you very much

00:39:08,160 --> 00:39:14,320
okay uh thank you so that actually puts

00:39:11,920 --> 00:39:17,359
us just a little bit over time

00:39:14,320 --> 00:39:19,520
so why don't we um maybe

00:39:17,359 --> 00:39:22,240
uh look at a few of these questions and

00:39:19,520 --> 00:39:25,359
then we'll proceed into the

00:39:22,240 --> 00:39:28,560
happy hour uh part of this

00:39:25,359 --> 00:39:30,000
uh so i wanted to cover um so little's

00:39:28,560 --> 00:39:33,680
question i o

00:39:30,000 --> 00:39:35,760
m u s m n u on arm 64 system provides

00:39:33,680 --> 00:39:36,720
protection at stream id r d level for

00:39:35,760 --> 00:39:40,240
pcie

00:39:36,720 --> 00:39:42,160
uh pfs and vs but if i understood

00:39:40,240 --> 00:39:45,200
correctly sub functions are

00:39:42,160 --> 00:39:48,400
further partitioning of vspfs

00:39:45,200 --> 00:39:50,079
if yes how protection is insured across

00:39:48,400 --> 00:39:53,119
sub functions card out

00:39:50,079 --> 00:39:56,400
of the same vfpf

00:39:53,119 --> 00:39:59,119
uh do you have a comment on that bro yes

00:39:56,400 --> 00:40:01,040
um so so you're right the sub function

00:39:59,119 --> 00:40:02,079
is further partitioning the pf and the

00:40:01,040 --> 00:40:05,359
vf

00:40:02,079 --> 00:40:05,359
so if um

00:40:05,680 --> 00:40:11,599
only if you map a sub function to a vm

00:40:09,040 --> 00:40:13,520
through some higher level driver only

00:40:11,599 --> 00:40:14,880
then some sort of protection is needed

00:40:13,520 --> 00:40:19,520
either through pass id

00:40:14,880 --> 00:40:21,359
or an immune platform immune

00:40:19,520 --> 00:40:22,960
device for sub function in the

00:40:21,359 --> 00:40:26,160
hypervisor

00:40:22,960 --> 00:40:26,880
but in in use cases to use either as a

00:40:26,160 --> 00:40:31,920
container

00:40:26,880 --> 00:40:34,000
or in the bare metal uh setup

00:40:31,920 --> 00:40:35,040
each of the sub function has its own bar

00:40:34,000 --> 00:40:37,119
memory

00:40:35,040 --> 00:40:40,400
so even if it is mapped to as an rdma

00:40:37,119 --> 00:40:42,400
device to the user space it's secure

00:40:40,400 --> 00:40:46,160
and one sub function cannot really do

00:40:42,400 --> 00:40:46,160
the dma to the other sub functions

00:40:46,319 --> 00:40:53,839
queues so it's so it's protected if it

00:40:49,680 --> 00:40:53,839
as long as it's used in single os

00:40:54,640 --> 00:40:57,839
okay with regards to exposing the sub

00:40:56,720 --> 00:41:01,599
function

00:40:57,839 --> 00:41:03,119
as immediate media mediated device not

00:41:01,599 --> 00:41:06,960
medicated device

00:41:03,119 --> 00:41:09,119
i kind of like the the mediated device

00:41:06,960 --> 00:41:10,480
um so you said it doesn't request all

00:41:09,119 --> 00:41:13,359
the requirements i

00:41:10,480 --> 00:41:15,839
supplied here and uh greg kh and others

00:41:13,359 --> 00:41:18,400
don't like exposing sub functions

00:41:15,839 --> 00:41:21,200
uh so uh what are your comments on that

00:41:18,400 --> 00:41:23,359
or any more comments

00:41:21,200 --> 00:41:25,200
no i think that's it we i posted the

00:41:23,359 --> 00:41:28,240
patches to expose a function with

00:41:25,200 --> 00:41:30,560
uh as mediated device and

00:41:28,240 --> 00:41:32,480
the feedback was not to abuse the mw bus

00:41:30,560 --> 00:41:34,319
for this purpose which is very specific

00:41:32,480 --> 00:41:37,520
to a vfio

00:41:34,319 --> 00:41:39,760
so maybe it should be used if we want to

00:41:37,520 --> 00:41:40,400
expose the mdev on top of the sub

00:41:39,760 --> 00:41:43,680
function

00:41:40,400 --> 00:41:46,319
so like but not

00:41:43,680 --> 00:41:47,680
not really to to anchor the sub function

00:41:46,319 --> 00:41:50,079
devices

00:41:47,680 --> 00:41:53,040
to bind to the driver through the mdev

00:41:50,079 --> 00:41:53,040
is not the approach

00:41:53,440 --> 00:41:58,240
okay and emerith says sub-functions can

00:41:56,720 --> 00:42:00,079
be used for bare metal containers but

00:41:58,240 --> 00:42:02,800
some functions for containers

00:42:00,079 --> 00:42:04,560
within a vm would need and um mdev

00:42:02,800 --> 00:42:08,000
device as well

00:42:04,560 --> 00:42:11,040
i guess that's a question i guess so

00:42:08,000 --> 00:42:13,200
if if you haven't worked out

00:42:11,040 --> 00:42:15,599
the exact mapping of how to map as a

00:42:13,200 --> 00:42:19,200
function to um

00:42:15,599 --> 00:42:19,760
to a vm so yeah maybe mw can be one

00:42:19,200 --> 00:42:21,599
option

00:42:19,760 --> 00:42:23,280
given the framework already exist in the

00:42:21,599 --> 00:42:26,160
kernel

00:42:23,280 --> 00:42:28,160
uh but i'm not sure of the performance

00:42:26,160 --> 00:42:31,520
that mdo can service

00:42:28,160 --> 00:42:34,079
for the networking workload for 64 byte

00:42:31,520 --> 00:42:34,079
packets

00:42:34,640 --> 00:42:38,960
okay and one more question is switch has

00:42:37,680 --> 00:42:42,000
split a hard split

00:42:38,960 --> 00:42:44,079
meaning if we enable the switch device

00:42:42,000 --> 00:42:46,400
will we still be able to use tc on the

00:42:44,079 --> 00:42:46,400
host

00:42:47,119 --> 00:42:52,079
um yes and no so i think dc is still

00:42:50,560 --> 00:42:55,119
usable on the host

00:42:52,079 --> 00:42:57,200
on the sub function uh

00:42:55,119 --> 00:42:58,880
but the the the e suite side the

00:42:57,200 --> 00:43:02,160
representer is on the

00:42:58,880 --> 00:43:04,000
on the switch side so um

00:43:02,160 --> 00:43:05,760
all the tc commands being issued on the

00:43:04,000 --> 00:43:08,400
representer is only available on the

00:43:05,760 --> 00:43:13,839
e-switch side

00:43:08,400 --> 00:43:13,839
does that answer your question or

00:43:14,400 --> 00:43:17,280
that was magic

00:43:19,680 --> 00:43:26,960
yeah ho can you hear me yes yes

00:43:23,760 --> 00:43:30,720
yeah mostly yes so that means that if

00:43:26,960 --> 00:43:31,280
we run the let's say the control plane

00:43:30,720 --> 00:43:33,359
on the

00:43:31,280 --> 00:43:35,839
smart nick we are unable really to

00:43:33,359 --> 00:43:38,319
control too much from the host right

00:43:35,839 --> 00:43:39,520
that's the mostly for the bare metal use

00:43:38,319 --> 00:43:41,599
cases right

00:43:39,520 --> 00:43:42,880
that's right the host is pretty much not

00:43:41,599 --> 00:43:45,359
trusted so

00:43:42,880 --> 00:43:47,440
host adding the rules can inject traffic

00:43:45,359 --> 00:43:47,839
into any tenants network and that's why

00:43:47,440 --> 00:43:51,040
the

00:43:47,839 --> 00:43:52,960
these switches on on the next side on a

00:43:51,040 --> 00:43:55,839
different host

00:43:52,960 --> 00:43:55,839
okay

00:43:57,440 --> 00:44:01,200
okay so let's um

00:43:59,560 --> 00:44:06,319
[Music]

00:44:01,200 --> 00:44:06,319

YouTube URL: https://www.youtube.com/watch?v=bwu5ED6QcoA


