Title: Netdev 0x14 - Linux Network Scripting with Lua
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Lourival Vieira Neto, Victor Nogueira, Ana LÃºcia de Moura, Roberto Ierusalimschy

More info: https://netdevconf.info/0x14/session.html?talk-linux-network-scripting-with-lua

Date: Thursday, August 20, 2020

If you thought that eBPF is the only approach to extend the kernel,
think again. In this talk, Lourival Vieira Neto et al describe a framework,
Lunatik, which facilitates dynamically injecting Lua scripts into the kernel
to extend kernel mechanisms.

Some context:

what is Lua?
1) It is a scripting language that is very widely deployed as an embededable
_extension language_.  Game programming in particular predominantly uses it for
extensions. Openwrt uses it as config language and there are many others
listed here: https://en.wikipedia.org/wiki/List_of_applications_using_Lua.
Wide deployment means it has seen exposure in many environments.
2) It is a tiny language (the whole language is about 200KB) that is
designed to be easy to embed - in particular in C
3) It is considered relatively secure. Despite the wide deployment
over many years there have been very few CVEs reported against Lua in
more than a decade. See:
https://www.cvedetails.com/product/28436/LUA-LUA.html?vendor_id=13641).

Why scripting?
The simple answer to this question is to compare a compiler driven
approach (think C) vs a scripting language(think Bash or python).
The former requires a complex development environment (think eBPF needing
latest clang, gcc, correct libbpf, etc) while the later provides faster
turnarounds to development and deployment (you need a kernel with the Lua
VM but not much after that in terms of tooling) and of course,
a much simpler and stable ABI. Script based execution is often not
as performant but often more usable relatively speaking.

And back to the talk...
The Lunatik framework has rich coverage across different kernel hooks and has
been used to script different Linux subsystems such as CPUfreq, Sockets, RCU,
ULP, Netfilter, and now XDP. Lunatik has been around for a while, just not
upstreamed - and to give a little sample space of its deployment: NFLua is
currently deployed _in production used in over 20 million home routers_!

You dont want a rogue script kill your kernel and system.
Lourival et al will discuss the challenges and approach taken in allowing
script injection into the kernel while still maintaining correctness,
isolation, and liveness.
They will then describe NFLua and introduce XPDLua, which allows
users to extend XDP with Lua. XDPLua aims to replace NFLua.
The authors will detail how Lua can be used within XDP:
as a standalone to directly invoke currently exposed eBPF helpers or
alternatively have eBPF programs invoke Lua scripts.

And last but not least: Lourival et al will provide perf comparison data for
packet filtering between with Iptables, eBPF, NFLua and XDPLua.
Captions: 
	00:00:00,480 --> 00:00:06,960
i'm lorebo i'm victor

00:00:04,080 --> 00:00:08,960
we are both from ring zero networks and

00:00:06,960 --> 00:00:11,759
we are going to present

00:00:08,960 --> 00:00:12,080
our work on scripting the linux network

00:00:11,759 --> 00:00:15,360
with

00:00:12,080 --> 00:00:18,720
lua this work was also developed by

00:00:15,360 --> 00:00:22,160
ana luce de moda and roberto zalinski

00:00:18,720 --> 00:00:25,279
from puke rio university in

00:00:22,160 --> 00:00:25,760
huge general i'd like to thank the net

00:00:25,279 --> 00:00:28,960
dev

00:00:25,760 --> 00:00:32,239
conf organization especially jamal

00:00:28,960 --> 00:00:34,640
for for all his kind of

00:00:32,239 --> 00:00:34,640
sport

00:00:36,000 --> 00:00:40,000
we have been working on scripting

00:00:38,719 --> 00:00:43,520
operant systems

00:00:40,000 --> 00:00:44,000
kernels since 2008 lunatic is our kind

00:00:43,520 --> 00:00:47,120
of script

00:00:44,000 --> 00:00:50,320
framework for linux which supports

00:00:47,120 --> 00:00:53,520
developers to make their subsystems

00:00:50,320 --> 00:00:54,960
scriptable and also allows users to

00:00:53,520 --> 00:00:58,079
dynamically load

00:00:54,960 --> 00:01:01,120
their scripts into the kernel we

00:00:58,079 --> 00:01:04,400
believe that lewis adequate choice for

00:01:01,120 --> 00:01:07,119
scripting the kernel because quite small

00:01:04,400 --> 00:01:09,680
and fast scripting language and widely

00:01:07,119 --> 00:01:13,600
use it for scripting

00:01:09,680 --> 00:01:16,720
network tools such as wireshark and map

00:01:13,600 --> 00:01:19,600
and smart in this

00:01:16,720 --> 00:01:20,880
presentation we're gonna focus on

00:01:19,600 --> 00:01:24,400
scripting

00:01:20,880 --> 00:01:27,759
two linux network subsystems

00:01:24,400 --> 00:01:31,119
net future and xdp

00:01:27,759 --> 00:01:34,320
we have developed two binders

00:01:31,119 --> 00:01:37,759
bindings respectively for

00:01:34,320 --> 00:01:41,840
these uh subsystems one is nflua

00:01:37,759 --> 00:01:41,840
in the other xdp luan

00:01:42,560 --> 00:01:48,799
in order to script

00:01:45,600 --> 00:01:50,880
the kernel we need to prevent kernel

00:01:48,799 --> 00:01:54,240
scripts to introduce

00:01:50,880 --> 00:01:57,600
malfunction name to the system such as

00:01:54,240 --> 00:02:01,680
crashing it running indefinitely

00:01:57,600 --> 00:02:01,680
or or even corrupting it

00:02:03,280 --> 00:02:10,239
for doing that we leverage the

00:02:06,560 --> 00:02:13,520
new vm facilities

00:02:10,239 --> 00:02:17,520
for sending boxing the

00:02:13,520 --> 00:02:20,959
script so firstly you need to care about

00:02:17,520 --> 00:02:24,239
the scripting script is

00:02:20,959 --> 00:02:25,440
addressing memory fortunately lua

00:02:24,239 --> 00:02:28,640
provides dynamic

00:02:25,440 --> 00:02:31,840
memory management so scripts can't

00:02:28,640 --> 00:02:35,519
address memory directly instead they

00:02:31,840 --> 00:02:39,040
need to use lua native data types

00:02:35,519 --> 00:02:42,239
such as strings and tables

00:02:39,040 --> 00:02:45,519
all lua objects are located by

00:02:42,239 --> 00:02:49,519
the lua vm and subjected to

00:02:45,519 --> 00:02:50,000
a garbage collector unfortunately this

00:02:49,519 --> 00:02:53,760
is not

00:02:50,000 --> 00:02:56,160
enough for preventing the scripts

00:02:53,760 --> 00:02:56,959
cause harm to the system they could

00:02:56,160 --> 00:03:00,080
eventually

00:02:56,959 --> 00:03:01,040
allocate too much memory for this lua

00:03:00,080 --> 00:03:05,120
provides

00:03:01,040 --> 00:03:06,640
a facility to define crystal memory

00:03:05,120 --> 00:03:10,480
allocators

00:03:06,640 --> 00:03:10,480
we use these on our

00:03:10,640 --> 00:03:17,280
network scripting bindings

00:03:14,239 --> 00:03:18,400
for capping the memory allocated by the

00:03:17,280 --> 00:03:21,760
script so

00:03:18,400 --> 00:03:22,560
whenever scripts try to allocate too

00:03:21,760 --> 00:03:25,840
much memory

00:03:22,560 --> 00:03:29,760
we just raise an error

00:03:25,840 --> 00:03:32,080
lua also pro provides fully isolated

00:03:29,760 --> 00:03:34,799
execution states

00:03:32,080 --> 00:03:34,799
we have

00:03:35,440 --> 00:03:43,440
separated execution states for

00:03:39,040 --> 00:03:43,440
every purpose for instance

00:03:43,599 --> 00:03:49,920
xdp lua has one state per

00:03:46,640 --> 00:03:53,680
cpu and all

00:03:49,920 --> 00:03:57,680
those states are created empty

00:03:53,680 --> 00:04:00,400
completely empty so the

00:03:57,680 --> 00:04:01,599
kernel developer can choose what

00:04:00,400 --> 00:04:04,720
libraries to

00:04:01,599 --> 00:04:09,280
load into such states we

00:04:04,720 --> 00:04:12,400
have here two examples of

00:04:09,280 --> 00:04:13,519
libraries one is lua data that is used

00:04:12,400 --> 00:04:17,359
to

00:04:13,519 --> 00:04:20,880
access x memory external to

00:04:17,359 --> 00:04:22,000
the lua vm safely we use these for

00:04:20,880 --> 00:04:26,720
instance on both

00:04:22,000 --> 00:04:29,759
nf lua and xtp lua for accessing

00:04:26,720 --> 00:04:32,800
packets inside the scripts

00:04:29,759 --> 00:04:36,880
and we have here also lua rcu

00:04:32,800 --> 00:04:39,919
that we use to share memory across the

00:04:36,880 --> 00:04:42,240
execution states lua also

00:04:39,919 --> 00:04:43,759
runs in a single threaded execution

00:04:42,240 --> 00:04:47,040
environment

00:04:43,759 --> 00:04:50,960
what means that it doesn't provide

00:04:47,040 --> 00:04:55,520
any synchronization mechanism like

00:04:50,960 --> 00:04:59,600
mutex and then scripts cannot explicitly

00:04:55,520 --> 00:05:03,039
lock a kernel flow however the

00:04:59,600 --> 00:05:03,840
scripts could still run indefinitely

00:05:03,039 --> 00:05:06,960
right

00:05:03,840 --> 00:05:07,919
so luo provides a facility to interrupt

00:05:06,960 --> 00:05:11,360
the script

00:05:07,919 --> 00:05:14,960
after execution executing a

00:05:11,360 --> 00:05:17,120
given amount of instructions in this

00:05:14,960 --> 00:05:20,639
case we just

00:05:17,120 --> 00:05:24,880
set a callback for because

00:05:20,639 --> 00:05:28,000
after a script runs uh

00:05:24,880 --> 00:05:31,039
this amount of execution is these amount

00:05:28,000 --> 00:05:34,800
of instructions sorry

00:05:31,039 --> 00:05:37,840
both nflua and

00:05:34,800 --> 00:05:39,520
xdp lua leverage this facility to

00:05:37,840 --> 00:05:41,680
prevent

00:05:39,520 --> 00:05:43,120
discrete kernel scripts to run

00:05:41,680 --> 00:05:46,320
definitely

00:05:43,120 --> 00:05:48,880
as mentioned before lunatic allows

00:05:46,320 --> 00:05:51,440
the creation of multiple execution

00:05:48,880 --> 00:05:54,400
states

00:05:51,440 --> 00:05:56,160
in the kernel provide in that way

00:05:54,400 --> 00:05:59,120
multitasking will

00:05:56,160 --> 00:06:01,440
talk a bit tomorrow days later on this

00:05:59,120 --> 00:06:03,919
presentation

00:06:01,440 --> 00:06:04,720
uh besides all that and if you both fell

00:06:03,919 --> 00:06:08,160
in love

00:06:04,720 --> 00:06:10,639
and allow only

00:06:08,160 --> 00:06:11,759
the network administrators to load code

00:06:10,639 --> 00:06:14,960
and

00:06:11,759 --> 00:06:17,520
access the execution states

00:06:14,960 --> 00:06:20,000
in the kernel we do this by using a

00:06:17,520 --> 00:06:23,199
netlink socket for communicating with

00:06:20,000 --> 00:06:28,560
the user space and checking

00:06:23,199 --> 00:06:28,560
the net admin capability on every access

00:06:29,680 --> 00:06:36,720
nflua is our

00:06:33,280 --> 00:06:40,720
ext net future extension for providing

00:06:36,720 --> 00:06:40,720
packet filtering with lua

00:06:40,880 --> 00:06:46,880
it's especially useful for

00:06:43,919 --> 00:06:49,120
implementing advanced layer 7 filtering

00:06:46,880 --> 00:06:52,080
we can have like tables

00:06:49,120 --> 00:06:52,080
rows to match

00:06:52,160 --> 00:07:00,160
layer 3 and 4 and then

00:06:55,440 --> 00:07:00,160
call lua to inspect the upper layer

00:07:00,479 --> 00:07:04,880
and if lua is widely used by network

00:07:03,759 --> 00:07:07,680
operator for

00:07:04,880 --> 00:07:10,560
operators for advanced security and

00:07:07,680 --> 00:07:13,520
network monitoring features

00:07:10,560 --> 00:07:15,280
and it's completely implemented as a

00:07:13,520 --> 00:07:19,919
loadable kernel module

00:07:15,280 --> 00:07:22,210
here is how nf lua works

00:07:19,919 --> 00:07:24,160
assume you want to

00:07:22,210 --> 00:07:28,240
[Music]

00:07:24,160 --> 00:07:31,919
filter the http requests

00:07:28,240 --> 00:07:35,360
and check if uh the user agent

00:07:31,919 --> 00:07:38,639
is in a black in a block list

00:07:35,360 --> 00:07:41,680
for instance to block access from

00:07:38,639 --> 00:07:44,960
a curve client

00:07:41,680 --> 00:07:48,800
so to do this we need first to

00:07:44,960 --> 00:07:53,120
create execution state on

00:07:48,800 --> 00:07:57,840
nflua using the nflua control

00:07:53,120 --> 00:08:01,039
2 and then we need to load the

00:07:57,840 --> 00:08:04,960
script check user agent in this case

00:08:01,039 --> 00:08:08,319
into the state this is

00:08:04,960 --> 00:08:12,879
the example of uh the

00:08:08,319 --> 00:08:15,919
check user agent we use the lua

00:08:12,879 --> 00:08:19,840
string library to do

00:08:15,919 --> 00:08:23,199
to for pattern matting

00:08:19,840 --> 00:08:27,360
and extracted the

00:08:23,199 --> 00:08:30,800
user agent from the hp request

00:08:27,360 --> 00:08:34,320
and then check against uh block list

00:08:30,800 --> 00:08:35,120
and v5 these user agents should be

00:08:34,320 --> 00:08:37,760
blocked

00:08:35,120 --> 00:08:37,760
or not

00:08:38,560 --> 00:08:45,279
so after loading the script

00:08:42,240 --> 00:08:49,120
we need to create a

00:08:45,279 --> 00:08:52,399
tables rule to call the script

00:08:49,120 --> 00:08:56,560
when we get a packet in this case

00:08:52,399 --> 00:09:00,560
it will match all income

00:08:56,560 --> 00:09:03,920
packets destinated to tcp port 80

00:09:00,560 --> 00:09:06,480
and column

00:09:03,920 --> 00:09:10,800
called this particular function check

00:09:06,480 --> 00:09:10,800
user agent in lunatic

00:09:12,399 --> 00:09:16,080
so whenever net filter receives a packet

00:09:15,279 --> 00:09:20,000
from part

00:09:16,080 --> 00:09:23,600
tcp 80 net filter will send the packet

00:09:20,000 --> 00:09:27,920
to nfluron and then call

00:09:23,600 --> 00:09:31,519
the jackie user agent function

00:09:27,920 --> 00:09:34,839
if the function returns true then

00:09:31,519 --> 00:09:37,839
net filter will terminate the

00:09:34,839 --> 00:09:37,839
connection

00:09:38,640 --> 00:09:46,480
now tutorial will talk about xdp learn

00:09:42,720 --> 00:09:49,200
so xct lure is an extension of xct

00:09:46,480 --> 00:09:50,240
that allows the usage of lure inside the

00:09:49,200 --> 00:09:53,040
database

00:09:50,240 --> 00:09:53,360
it was created as a natural revolution

00:09:53,040 --> 00:09:56,399
of

00:09:53,360 --> 00:09:58,320
nf lure because it processed it

00:09:56,399 --> 00:10:00,720
processed packets before

00:09:58,320 --> 00:10:01,360
they were received by the networking

00:10:00,720 --> 00:10:04,000
stack

00:10:01,360 --> 00:10:06,079
and also because executable creates one

00:10:04,000 --> 00:10:09,760
newest state per cpu

00:10:06,079 --> 00:10:13,200
guys taking advantage of multi cpu

00:10:09,760 --> 00:10:16,079
systems parallelism one of our goals

00:10:13,200 --> 00:10:19,680
with xdp lua was to add expressiveness

00:10:16,079 --> 00:10:22,640
and dynamism into the data paths

00:10:19,680 --> 00:10:23,680
so to help programmers create more

00:10:22,640 --> 00:10:25,360
complex

00:10:23,680 --> 00:10:28,480
applications to be loaded inside the

00:10:25,360 --> 00:10:31,680
framework to extended the xdp

00:10:28,480 --> 00:10:32,560
to allow the usage of lua we scripted

00:10:31,680 --> 00:10:36,720
the dtf

00:10:32,560 --> 00:10:38,800
with lua by creating evps helpers

00:10:36,720 --> 00:10:39,839
that are basically wrappers to the river

00:10:38,800 --> 00:10:43,040
c api

00:10:39,839 --> 00:10:46,079
and does allow ebps programs to call

00:10:43,040 --> 00:10:49,360
new scripts also

00:10:46,079 --> 00:10:52,079
we wanted to use ebpf with lure

00:10:49,360 --> 00:10:53,040
wanted those two to cooperate so we can

00:10:52,079 --> 00:10:55,839
have the best

00:10:53,040 --> 00:10:57,760
of both of them so for example we wanted

00:10:55,839 --> 00:11:02,399
ebpf's performance

00:10:57,760 --> 00:11:02,399
and lua's expressiveness and dynamism

00:11:04,079 --> 00:11:08,480
to better illustrate how xdp will work

00:11:06,800 --> 00:11:10,880
i'll use the same example

00:11:08,480 --> 00:11:11,600
as thoroughly will use in the nf lewis

00:11:10,880 --> 00:11:15,279
lines

00:11:11,600 --> 00:11:17,680
which is the user agent verification

00:11:15,279 --> 00:11:19,680
so the first thing that will happen is

00:11:17,680 --> 00:11:20,560
that the user would load the check user

00:11:19,680 --> 00:11:23,519
agent

00:11:20,560 --> 00:11:25,600
function afterwards you would load the

00:11:23,519 --> 00:11:28,480
dpf program into xcp

00:11:25,600 --> 00:11:30,160
let's say eventually an http request

00:11:28,480 --> 00:11:33,200
arrives

00:11:30,160 --> 00:11:35,519
at xcp which will in turn execute

00:11:33,200 --> 00:11:38,000
the udtf program which will see that it

00:11:35,519 --> 00:11:40,720
has just received the dcd packet

00:11:38,000 --> 00:11:42,000
destined to board 80 and so it will call

00:11:40,720 --> 00:11:44,399
the lua function

00:11:42,000 --> 00:11:45,760
check user agent this function as

00:11:44,399 --> 00:11:48,240
laurave already said

00:11:45,760 --> 00:11:49,680
will extract the user agent from the

00:11:48,240 --> 00:11:51,920
http request

00:11:49,680 --> 00:11:54,160
see if it is in a block list and if it

00:11:51,920 --> 00:11:54,880
is it will return a value to the vgf

00:11:54,160 --> 00:11:56,639
program

00:11:54,880 --> 00:11:58,800
telling it to drop the package and of

00:11:56,639 --> 00:11:59,519
course if it isn't we'll return another

00:11:58,800 --> 00:12:01,839
value

00:11:59,519 --> 00:12:03,200
selling the dj program to less to let

00:12:01,839 --> 00:12:06,399
the packet pass through

00:12:03,200 --> 00:12:06,399
to the networking stack

00:12:08,320 --> 00:12:12,079
we implemented two applications to

00:12:10,880 --> 00:12:15,200
validate

00:12:12,079 --> 00:12:15,920
our solution the first one is javascript

00:12:15,200 --> 00:12:19,600
challenge

00:12:15,920 --> 00:12:22,240
which is basically a method to

00:12:19,600 --> 00:12:23,279
distinguish legitimate from illegitimate

00:12:22,240 --> 00:12:27,120
users

00:12:23,279 --> 00:12:29,200
using http cookies so for example let's

00:12:27,120 --> 00:12:31,839
say that we have a malicious watts

00:12:29,200 --> 00:12:34,079
that's trying to act to connect with our

00:12:31,839 --> 00:12:36,160
http server

00:12:34,079 --> 00:12:39,040
let's say the first thing this spot does

00:12:36,160 --> 00:12:41,440
is send an http request to our server

00:12:39,040 --> 00:12:43,120
which will then receive this request and

00:12:41,440 --> 00:12:43,760
seeing that this is the first time that

00:12:43,120 --> 00:12:46,720
this

00:12:43,760 --> 00:12:48,800
client is trying to connect with us or

00:12:46,720 --> 00:12:51,279
generate a random cookie value

00:12:48,800 --> 00:12:54,000
that's specific for this client after

00:12:51,279 --> 00:12:55,279
afterwards it will send a message to xcp

00:12:54,000 --> 00:12:57,440
lure

00:12:55,279 --> 00:12:58,880
telling it that any further http

00:12:57,440 --> 00:13:02,079
requests sent

00:12:58,880 --> 00:13:06,079
by this specific client must have

00:13:02,079 --> 00:13:10,560
the just generated cookie value in

00:13:06,079 --> 00:13:13,519
set in the any future requests

00:13:10,560 --> 00:13:15,519
after that of course the http server

00:13:13,519 --> 00:13:18,399
will send

00:13:15,519 --> 00:13:19,600
an http response with a javascript code

00:13:18,399 --> 00:13:22,079
embedded on it

00:13:19,600 --> 00:13:23,760
telling the client to set the cookie to

00:13:22,079 --> 00:13:26,560
the just generated

00:13:23,760 --> 00:13:26,560
cookie value

00:13:29,680 --> 00:13:33,519
this is the lure function used in this

00:13:32,480 --> 00:13:35,600
application

00:13:33,519 --> 00:13:37,360
which is check cookie as you can see

00:13:35,600 --> 00:13:40,720
it's pretty simple

00:13:37,360 --> 00:13:43,839
and what it does is simply extract

00:13:40,720 --> 00:13:46,480
the cookie from the http request see

00:13:43,839 --> 00:13:47,040
if the extracted cookie is indeed

00:13:46,480 --> 00:13:49,839
correct

00:13:47,040 --> 00:13:52,800
for this specific user and return of our

00:13:49,839 --> 00:13:52,800
new according

00:13:54,800 --> 00:13:58,560
so let's say that that malicious bot is

00:13:57,600 --> 00:14:01,920
trying to connect

00:13:58,560 --> 00:14:04,639
with our server once again so it will

00:14:01,920 --> 00:14:08,160
send an http request to the server

00:14:04,639 --> 00:14:10,320
which will then arrive at xct which

00:14:08,160 --> 00:14:12,079
will execute the visa program which will

00:14:10,320 --> 00:14:14,959
see that it has just received

00:14:12,079 --> 00:14:16,639
a tcp packet destined to port 80 and

00:14:14,959 --> 00:14:17,839
then it will call the lure function

00:14:16,639 --> 00:14:20,160
check cookie

00:14:17,839 --> 00:14:23,519
this function as i said before will

00:14:20,160 --> 00:14:25,680
extract the cookie from the http request

00:14:23,519 --> 00:14:26,800
see if it is the correct value but in

00:14:25,680 --> 00:14:29,680
this case

00:14:26,800 --> 00:14:31,040
since it was sent by a box which we

00:14:29,680 --> 00:14:33,839
which typically

00:14:31,040 --> 00:14:35,760
can't process javascript the cookie

00:14:33,839 --> 00:14:38,320
won't be present in the request

00:14:35,760 --> 00:14:39,839
and so the rule function check cookie

00:14:38,320 --> 00:14:41,920
will return a value

00:14:39,839 --> 00:14:43,040
telling the btf program to drop the

00:14:41,920 --> 00:14:45,680
packet

00:14:43,040 --> 00:14:46,880
but before doing that the bpf program

00:14:45,680 --> 00:14:49,519
will store

00:14:46,880 --> 00:14:50,720
the ip address of the client in the

00:14:49,519 --> 00:14:54,399
block list

00:14:50,720 --> 00:14:57,279
so that any future packets sent

00:14:54,399 --> 00:14:58,480
by this client will be blocked by the

00:14:57,279 --> 00:15:01,519
evps program

00:14:58,480 --> 00:15:04,000
since the ip address of the bot will be

00:15:01,519 --> 00:15:05,519
in the brightness so the bb reference

00:15:04,000 --> 00:15:08,079
won't need to call lua

00:15:05,519 --> 00:15:08,079
anymore

00:15:10,959 --> 00:15:14,560
the other application we developed was

00:15:13,279 --> 00:15:17,839
access control

00:15:14,560 --> 00:15:18,800
which is basically a domain filter that

00:15:17,839 --> 00:15:22,079
blocks

00:15:18,800 --> 00:15:25,920
access to specific domains for all users

00:15:22,079 --> 00:15:27,199
in a given network so to try and further

00:15:25,920 --> 00:15:30,320
explain how it works

00:15:27,199 --> 00:15:33,519
i'll show you how

00:15:30,320 --> 00:15:35,440
it is implemented in xcp lua uh

00:15:33,519 --> 00:15:37,600
well the first thing that will happen is

00:15:35,440 --> 00:15:38,320
that uh the user will load the block

00:15:37,600 --> 00:15:42,079
list

00:15:38,320 --> 00:15:45,120
into xcp ruler uh then it will

00:15:42,079 --> 00:15:46,079
the user will load the check sni newer

00:15:45,120 --> 00:15:49,440
function

00:15:46,079 --> 00:15:50,000
and of course it will load then the vpf

00:15:49,440 --> 00:15:54,399
program

00:15:50,000 --> 00:15:56,880
into xcp let's say a package derived

00:15:54,399 --> 00:15:57,920
add xdb and in this case this packet

00:15:56,880 --> 00:16:01,199
will be a

00:15:57,920 --> 00:16:04,399
tls client hello

00:16:01,199 --> 00:16:07,120
and so the btf program will process it

00:16:04,399 --> 00:16:09,680
see that it is a tcp package destined to

00:16:07,120 --> 00:16:11,759
port 443

00:16:09,680 --> 00:16:13,040
and then call the lure function check

00:16:11,759 --> 00:16:16,079
sni

00:16:13,040 --> 00:16:19,279
this function will extract the smi

00:16:16,079 --> 00:16:22,160
from this packet see

00:16:19,279 --> 00:16:23,759
that see if it is in a block list or not

00:16:22,160 --> 00:16:25,440
and if it is in a block list

00:16:23,759 --> 00:16:27,120
it will send a message to the dpf

00:16:25,440 --> 00:16:30,000
program sorry we would

00:16:27,120 --> 00:16:30,800
return a value to the adtf program

00:16:30,000 --> 00:16:34,160
telling it to

00:16:30,800 --> 00:16:34,720
drop the packet or the right otherwise

00:16:34,160 --> 00:16:37,199
it will

00:16:34,720 --> 00:16:38,560
send another value to the btf program

00:16:37,199 --> 00:16:40,480
telling it to

00:16:38,560 --> 00:16:42,320
let the packet pass through to the

00:16:40,480 --> 00:16:46,240
networking stack

00:16:42,320 --> 00:16:48,839
thus impeding any tls sessions

00:16:46,240 --> 00:16:51,839
destined to that specific domain from

00:16:48,839 --> 00:16:51,839
occurring

00:16:52,959 --> 00:16:58,639
so we ran a few benchmarks

00:16:59,199 --> 00:17:07,280
comparing xvp without mirror xcp lua and

00:17:02,800 --> 00:17:10,400
nf lure we had to develop a

00:17:07,280 --> 00:17:14,319
fury bps version of the access control

00:17:10,400 --> 00:17:16,720
application to be executed inside xct

00:17:14,319 --> 00:17:17,360
and it is important to note that this

00:17:16,720 --> 00:17:19,600
was

00:17:17,360 --> 00:17:21,360
really harder to do than implementing

00:17:19,600 --> 00:17:25,520
the xcp lower version

00:17:21,360 --> 00:17:27,919
and the result was a cumbersome c code

00:17:25,520 --> 00:17:29,679
it's also important to say that xdp lua

00:17:27,919 --> 00:17:33,760
n and fluores shared

00:17:29,679 --> 00:17:37,360
the same rura script implementation

00:17:33,760 --> 00:17:40,400
also the benchmark consisted of a client

00:17:37,360 --> 00:17:43,919
sending as much tls client hello packets

00:17:40,400 --> 00:17:46,400
as possible to the server

00:17:43,919 --> 00:17:48,400
these packets were generated by trap gen

00:17:46,400 --> 00:17:51,200
and it was also important to say

00:17:48,400 --> 00:17:51,600
that all of the gis client hello package

00:17:51,200 --> 00:17:54,559
had

00:17:51,600 --> 00:17:54,960
an sni on them that was in the block

00:17:54,559 --> 00:17:57,679
list

00:17:54,960 --> 00:17:59,280
this means that every tls client hello

00:17:57,679 --> 00:18:01,840
package sent to the server

00:17:59,280 --> 00:18:03,440
was dropped by the access control

00:18:01,840 --> 00:18:06,080
application

00:18:03,440 --> 00:18:09,280
with that said we measured the drop rate

00:18:06,080 --> 00:18:11,440
and the cpu usage on the server

00:18:09,280 --> 00:18:13,120
we ran this benchmark in a fully

00:18:11,440 --> 00:18:15,520
virtualized environment

00:18:13,120 --> 00:18:16,400
both the client and the server had one

00:18:15,520 --> 00:18:19,120
cpu

00:18:16,400 --> 00:18:20,400
with eight cores running at three

00:18:19,120 --> 00:18:23,120
gigahertz

00:18:20,400 --> 00:18:25,039
and they also had 32 gigabytes of rom

00:18:23,120 --> 00:18:29,840
and a 10 gigabit per second

00:18:25,039 --> 00:18:29,840
vertio network interface

00:18:29,919 --> 00:18:34,000
so these are the results as you can see

00:18:32,720 --> 00:18:37,360
we generated

00:18:34,000 --> 00:18:40,480
1.5 million packets a second

00:18:37,360 --> 00:18:40,880
which was enough to stress and if we

00:18:40,480 --> 00:18:44,320
were

00:18:40,880 --> 00:18:47,919
and as you can see and if we would which

00:18:44,320 --> 00:18:51,360
dropped approximately a third of all xcp

00:18:47,919 --> 00:18:51,679
and xdp were good uh which as you can

00:18:51,360 --> 00:18:56,640
see

00:18:51,679 --> 00:18:59,360
dropped approximately the same thing

00:18:56,640 --> 00:19:00,480
also as you can see by the city usage

00:18:59,360 --> 00:19:03,600
xct lure

00:19:00,480 --> 00:19:06,160
and xct without lure uh

00:19:03,600 --> 00:19:08,160
use approximately the same amount of cpu

00:19:06,160 --> 00:19:11,440
well nfluor used

00:19:08,160 --> 00:19:14,799
500 times uh we believe that is

00:19:11,440 --> 00:19:16,640
because nflua only processes packets

00:19:14,799 --> 00:19:18,240
before they have they have passed

00:19:16,640 --> 00:19:21,200
through the networking stack

00:19:18,240 --> 00:19:22,160
and also because nf lure doesn't take

00:19:21,200 --> 00:19:25,520
advantage

00:19:22,160 --> 00:19:28,720
of the mufa core cpu

00:19:25,520 --> 00:19:30,240
which we had in this case in this

00:19:28,720 --> 00:19:33,600
specific benchmark

00:19:30,240 --> 00:19:37,440
also i think it's important to say that

00:19:33,600 --> 00:19:40,000
in this specific scenario having xcp

00:19:37,440 --> 00:19:41,200
execute lua scripts didn't have a

00:19:40,000 --> 00:19:44,720
significant

00:19:41,200 --> 00:19:47,039
impact in the performance as final

00:19:44,720 --> 00:19:50,240
remarks we'd like to point out

00:19:47,039 --> 00:19:53,120
that nflua is

00:19:50,240 --> 00:19:54,320
widely used by network operators for

00:19:53,120 --> 00:19:57,600
implemented

00:19:54,320 --> 00:20:01,039
implementing advanced security

00:19:57,600 --> 00:20:01,760
network monitoring features it is

00:20:01,039 --> 00:20:05,280
currently

00:20:01,760 --> 00:20:08,159
present in around two 20 million

00:20:05,280 --> 00:20:08,159
home routers

00:20:08,400 --> 00:20:13,600
xdp lua is the evolution of the natural

00:20:12,240 --> 00:20:16,880
evolution of

00:20:13,600 --> 00:20:19,919
nf lua applying the lessons we learned

00:20:16,880 --> 00:20:20,640
from the uninfluenced development such

00:20:19,919 --> 00:20:25,280
as

00:20:20,640 --> 00:20:29,039
using multitasking having one state

00:20:25,280 --> 00:20:32,559
per cpu also leveraging

00:20:29,039 --> 00:20:36,000
xdp bypass from the

00:20:32,559 --> 00:20:39,360
network stack xdp lua

00:20:36,000 --> 00:20:43,280
was designed from the very beginning

00:20:39,360 --> 00:20:46,159
to use elua cooperatively with ebpf

00:20:43,280 --> 00:20:46,400
adding the expressiveness and the ease

00:20:46,159 --> 00:20:50,720
of

00:20:46,400 --> 00:20:54,080
use of lua to the performance of ebpf

00:20:50,720 --> 00:20:57,760
in that way we strongly believe

00:20:54,080 --> 00:21:01,039
that we can have advanced

00:20:57,760 --> 00:21:04,799
applications implemented

00:21:01,039 --> 00:21:08,159
using bpf to leverage performance

00:21:04,799 --> 00:21:12,799
and lua for

00:21:08,159 --> 00:21:12,799
implementing more complex code

00:21:13,840 --> 00:21:21,120
xdp lua is currently used in ring zero

00:21:17,600 --> 00:21:25,120
fire running in points of presence

00:21:21,120 --> 00:21:29,360
with 10 gigabits per second to put

00:21:25,120 --> 00:21:32,880
using only up to four percent of cpu

00:21:29,360 --> 00:21:37,280
we also would like to point out that

00:21:32,880 --> 00:21:41,600
one downside of xdp lua development

00:21:37,280 --> 00:21:44,960
uh it has been quite hard to

00:21:41,600 --> 00:21:47,440
to develop these as an out of three

00:21:44,960 --> 00:21:51,679
binding

00:21:47,440 --> 00:21:55,679
differently from net filter which has

00:21:51,679 --> 00:21:58,720
x tables that was quite useful

00:21:55,679 --> 00:22:01,919
for the nflua

00:21:58,720 --> 00:22:05,280
development xdp doesn't have

00:22:01,919 --> 00:22:09,840
uh doesn't support extensions as

00:22:05,280 --> 00:22:12,960
loadable kernel modules so it would be

00:22:09,840 --> 00:22:16,400
great if you could have some

00:22:12,960 --> 00:22:20,880
something similar to like stables on xdp

00:22:16,400 --> 00:22:24,880
for our particular user case

00:22:20,880 --> 00:22:28,080
so we also showed that we can apply

00:22:24,880 --> 00:22:30,960
sandboxing techniques instead of having

00:22:28,080 --> 00:22:35,360
an internal verifier which

00:22:30,960 --> 00:22:39,520
has at least in our case

00:22:35,360 --> 00:22:43,440
has shown us quite hard to

00:22:39,520 --> 00:22:46,400
to use for as pointed by vito

00:22:43,440 --> 00:22:47,600
on our benchmark developing the access

00:22:46,400 --> 00:22:51,039
control

00:22:47,600 --> 00:22:53,840
application was a bit hard to

00:22:51,039 --> 00:22:54,960
implement the same feature parsing as an

00:22:53,840 --> 00:22:58,480
eye

00:22:54,960 --> 00:23:02,159
and in ebp off mainly

00:22:58,480 --> 00:23:05,600
because of the internal verifier

00:23:02,159 --> 00:23:09,120
and especially we want weren't

00:23:05,600 --> 00:23:12,240
able to develop

00:23:09,120 --> 00:23:16,400
the same block list

00:23:12,240 --> 00:23:19,760
based on sni who we have on

00:23:16,400 --> 00:23:23,840
our lewis script mainly also because the

00:23:19,760 --> 00:23:23,840
internal verifier

00:23:25,200 --> 00:23:32,080
so that's it we would like to thank you

00:23:28,880 --> 00:23:36,240
uh here are our

00:23:32,080 --> 00:23:40,480
info feel free to reach out and time

00:23:36,240 --> 00:23:40,480
and if you have some any questions

00:23:44,960 --> 00:23:52,720
thank you so we do have a few questions

00:23:48,880 --> 00:23:56,320
but i wanted to start off with probably

00:23:52,720 --> 00:23:58,640
um with regards to linux

00:23:56,320 --> 00:24:00,400
the the area that's going to be the

00:23:58,640 --> 00:24:04,000
hardest to overcome

00:24:00,400 --> 00:24:05,200
so clearly this is a major programming

00:24:04,000 --> 00:24:07,039
environment we're trying to put in the

00:24:05,200 --> 00:24:10,240
kernel and i think

00:24:07,039 --> 00:24:11,919
up front we have to be realistic

00:24:10,240 --> 00:24:13,760
that trying to upstream something like

00:24:11,919 --> 00:24:16,880
this is going to be

00:24:13,760 --> 00:24:20,960
um a lot of work if that's the intent

00:24:16,880 --> 00:24:24,240
so i think we can compare this to

00:24:20,960 --> 00:24:25,919
xdp um ebpf and particularly the

00:24:24,240 --> 00:24:29,120
verifier

00:24:25,919 --> 00:24:29,440
which provide uh a safe environment and

00:24:29,120 --> 00:24:33,360
this

00:24:29,440 --> 00:24:35,919
is really a lot of what xvp is about

00:24:33,360 --> 00:24:37,039
in ebpf is that we can guarantee a safe

00:24:35,919 --> 00:24:39,520
environment

00:24:37,039 --> 00:24:41,200
so if we ever wanted to get this

00:24:39,520 --> 00:24:42,080
upstream i think that that's the first

00:24:41,200 --> 00:24:44,880
order goal

00:24:42,080 --> 00:24:46,720
how are we going to convince the world

00:24:44,880 --> 00:24:51,120
that we can run

00:24:46,720 --> 00:24:53,679
a lua assume interpreter

00:24:51,120 --> 00:24:54,159
inside the kernel and guarantee that

00:24:53,679 --> 00:24:56,480
it's

00:24:54,159 --> 00:24:56,480
safe

00:24:58,720 --> 00:25:00,880
so

00:25:03,840 --> 00:25:09,440
so how how can we upstream this in the

00:25:07,679 --> 00:25:11,039
kernel

00:25:09,440 --> 00:25:13,039
because the kernel has a lot of

00:25:11,039 --> 00:25:15,760
requirements and

00:25:13,039 --> 00:25:16,960
we have to ensure uh complete safety so

00:25:15,760 --> 00:25:20,080
for instance

00:25:16,960 --> 00:25:21,279
we cannot have the kernel crash because

00:25:20,080 --> 00:25:24,000
a luau program

00:25:21,279 --> 00:25:25,120
accesses the wrong memory so how how

00:25:24,000 --> 00:25:28,159
would we enforce

00:25:25,120 --> 00:25:31,440
all the safeguards so

00:25:28,159 --> 00:25:34,720
um i think we have talked at these

00:25:31,440 --> 00:25:37,279
a little bit in the presentation but

00:25:34,720 --> 00:25:38,320
mainly we don't access memory there

00:25:37,279 --> 00:25:40,880
directly right

00:25:38,320 --> 00:25:41,760
lua doesn't have pointers so your script

00:25:40,880 --> 00:25:45,360
cannot

00:25:41,760 --> 00:25:48,000
address uh memory directly but

00:25:45,360 --> 00:25:49,039
they can allocate memory for these we

00:25:48,000 --> 00:25:51,520
can limit

00:25:49,039 --> 00:25:53,120
the amount of memory that that gonna be

00:25:51,520 --> 00:25:56,240
allocated by the

00:25:53,120 --> 00:25:59,360
execution state right uh

00:25:56,240 --> 00:26:00,640
the other thing is to run definitely we

00:25:59,360 --> 00:26:03,600
don't have

00:26:00,640 --> 00:26:04,720
a sort of verifier like ebpf but we can

00:26:03,600 --> 00:26:08,000
limit

00:26:04,720 --> 00:26:11,919
the amount of instructions that

00:26:08,000 --> 00:26:15,279
going to be executed by the

00:26:11,919 --> 00:26:19,200
by luan right so if it

00:26:15,279 --> 00:26:22,480
exceeds you can take some

00:26:19,200 --> 00:26:23,679
policy to interrupt the execution state

00:26:22,480 --> 00:26:26,960
or just raise

00:26:23,679 --> 00:26:30,080
an arrow and fall back into a

00:26:26,960 --> 00:26:33,440
fail-safe mechanism

00:26:30,080 --> 00:26:33,760
um don't know what what else you think

00:26:33,440 --> 00:26:38,080
that

00:26:33,760 --> 00:26:42,400
could be a security uh

00:26:38,080 --> 00:26:44,480
issue for well it's

00:26:42,400 --> 00:26:45,679
so thinking assuming that you want to

00:26:44,480 --> 00:26:48,799
get this upstream

00:26:45,679 --> 00:26:52,400
um the arguments about

00:26:48,799 --> 00:26:55,679
safety will have to be crystal clear

00:26:52,400 --> 00:26:56,559
and the the other thing you're very

00:26:55,679 --> 00:26:59,120
likely to get

00:26:56,559 --> 00:27:00,720
um push back on or at least somebody

00:26:59,120 --> 00:27:03,840
will ask this question

00:27:00,720 --> 00:27:05,840
why can't we just build a lua to ebpf

00:27:03,840 --> 00:27:08,080
compiler so remember ebpf is not a

00:27:05,840 --> 00:27:10,400
programming language it's a byte code

00:27:08,080 --> 00:27:11,919
so we already have a seed ebpf we have

00:27:10,400 --> 00:27:15,679
p40 ebpf

00:27:11,919 --> 00:27:18,720
why not just have a lua to ebpf

00:27:15,679 --> 00:27:19,360
you can have like lower syntax to ebpf

00:27:18,720 --> 00:27:22,640
but not

00:27:19,360 --> 00:27:27,039
the whole package right

00:27:22,640 --> 00:27:30,240
like having a actual lua vm

00:27:27,039 --> 00:27:32,960
uh on top of ebpf

00:27:30,240 --> 00:27:34,159
it's like you have the verifier it's

00:27:32,960 --> 00:27:36,320
limited

00:27:34,159 --> 00:27:37,440
language it's not i mean the language

00:27:36,320 --> 00:27:41,120
itself not but

00:27:37,440 --> 00:27:43,760
it's limited by the

00:27:41,120 --> 00:27:46,799
by the verifier itself so you cannot run

00:27:43,760 --> 00:27:51,760
to the incomplete code on top of this

00:27:46,799 --> 00:27:55,120
so you may have some

00:27:51,760 --> 00:27:58,240
subset of lua like using

00:27:55,120 --> 00:28:02,480
its syntax but not a complete

00:27:58,240 --> 00:28:05,919
implementation right

00:28:02,480 --> 00:28:06,880
it's so then thinking about the response

00:28:05,919 --> 00:28:09,760
to that

00:28:06,880 --> 00:28:12,399
so the reason we restrict uh the

00:28:09,760 --> 00:28:14,880
language is precisely because

00:28:12,399 --> 00:28:16,559
it has to be a safe environment but for

00:28:14,880 --> 00:28:19,360
instance we can't have

00:28:16,559 --> 00:28:20,399
uh a construct in c that gets into uh

00:28:19,360 --> 00:28:24,960
infinite loop

00:28:20,399 --> 00:28:27,679
or we've bricked a core in the kernel so

00:28:24,960 --> 00:28:28,799
we have to realize the kernel is as a

00:28:27,679 --> 00:28:31,520
programming environment

00:28:28,799 --> 00:28:32,240
it's an unforgiving environment and

00:28:31,520 --> 00:28:34,320
that's

00:28:32,240 --> 00:28:35,679
you know just projecting the sort of

00:28:34,320 --> 00:28:37,840
questions you'll get

00:28:35,679 --> 00:28:39,520
when the upstream conversation happens i

00:28:37,840 --> 00:28:40,399
think it's going to be heavily along

00:28:39,520 --> 00:28:42,320
these lines

00:28:40,399 --> 00:28:44,080
how do you ensure that this is a safe

00:28:42,320 --> 00:28:47,679
program to run in the kernel

00:28:44,080 --> 00:28:50,240
and um again why

00:28:47,679 --> 00:28:53,679
why can't we just use ebpf so i don't

00:28:50,240 --> 00:28:55,039
have answers to this actually i think

00:28:53,679 --> 00:28:57,679
in one regard i think you did a really

00:28:55,039 --> 00:29:00,799
good job in isolating the

00:28:57,679 --> 00:29:02,240
the lua parts out of xdp and using

00:29:00,799 --> 00:29:04,480
helper functions i think that's

00:29:02,240 --> 00:29:06,240
that's a good interface so it does

00:29:04,480 --> 00:29:08,159
isolate this so we don't have to modify

00:29:06,240 --> 00:29:10,240
xtp which is really good

00:29:08,159 --> 00:29:13,120
uh but still i think the questions

00:29:10,240 --> 00:29:17,360
around the safety are going to be

00:29:13,120 --> 00:29:21,520
brought up quickly as this goes forward

00:29:17,360 --> 00:29:24,000
the thing is is that verifying the

00:29:21,520 --> 00:29:25,200
user code is not the only way to provide

00:29:24,000 --> 00:29:28,159
safety right

00:29:25,200 --> 00:29:28,880
you can send box doing these uh on run

00:29:28,159 --> 00:29:32,880
time

00:29:28,880 --> 00:29:35,840
like we do uh don't

00:29:32,880 --> 00:29:37,760
i would like to exercise some particular

00:29:35,840 --> 00:29:42,480
user case you have in mind

00:29:37,760 --> 00:29:46,640
uh for crashing it uh

00:29:42,480 --> 00:29:49,919
like crashing our memory verification or

00:29:46,640 --> 00:29:50,399
limiting the instructions how how a

00:29:49,919 --> 00:29:53,520
scree

00:29:50,399 --> 00:29:56,159
a script could uh

00:29:53,520 --> 00:29:57,840
running definitely if you have like a

00:29:56,159 --> 00:30:01,360
hook on the

00:29:57,840 --> 00:30:02,559
vm itself of course you can have like

00:30:01,360 --> 00:30:06,000
the

00:30:02,559 --> 00:30:09,600
major bug in the vm itself but

00:30:06,000 --> 00:30:10,000
if the vm is working like the the fire

00:30:09,600 --> 00:30:13,200
it's

00:30:10,000 --> 00:30:16,720
working it's just uh about

00:30:13,200 --> 00:30:20,159
where you put your verifications

00:30:16,720 --> 00:30:23,039
i take uh compiling time

00:30:20,159 --> 00:30:23,760
on loading time or on execution time

00:30:23,039 --> 00:30:28,559
right

00:30:23,760 --> 00:30:28,559
we are not uh skipping verifications

00:30:28,799 --> 00:30:33,200
okay can i add one can i have a comment

00:30:31,919 --> 00:30:35,520
here i think i think the

00:30:33,200 --> 00:30:36,399
meta point is obviously valid right but

00:30:35,520 --> 00:30:38,960
the bigger issue

00:30:36,399 --> 00:30:39,840
i think is effectively you have two vms

00:30:38,960 --> 00:30:42,880
now

00:30:39,840 --> 00:30:43,919
and not only is that added complexity

00:30:42,880 --> 00:30:46,159
it's also

00:30:43,919 --> 00:30:47,200
added surface area so i think if you can

00:30:46,159 --> 00:30:50,080
reduce the

00:30:47,200 --> 00:30:52,720
lower vm footprint the things that do

00:30:50,080 --> 00:30:55,279
not run in kernel context and run in the

00:30:52,720 --> 00:30:57,120
hot path which is one or one

00:30:55,279 --> 00:30:58,640
manifestation of that would be what tom

00:30:57,120 --> 00:30:59,919
was suggesting which is you compile out

00:30:58,640 --> 00:31:02,399
dbpf

00:30:59,919 --> 00:31:05,200
you've reduced the number of vms to the

00:31:02,399 --> 00:31:07,360
evpfvm and i think the avp of vm has

00:31:05,200 --> 00:31:09,840
has momentum and has acceptance which is

00:31:07,360 --> 00:31:11,360
also a thing that we need to worry about

00:31:09,840 --> 00:31:13,200
so i think the question that will come

00:31:11,360 --> 00:31:13,840
down is how do you sandbox them in such

00:31:13,200 --> 00:31:16,720
a way

00:31:13,840 --> 00:31:17,679
that both the vms are not possibly in

00:31:16,720 --> 00:31:20,240
your hot path

00:31:17,679 --> 00:31:21,360
because like you said limit the number

00:31:20,240 --> 00:31:23,360
of instructions

00:31:21,360 --> 00:31:25,679
i need one instruction to do an infinite

00:31:23,360 --> 00:31:27,840
loop that that cannot

00:31:25,679 --> 00:31:30,080
i won't be able to protect against that

00:31:27,840 --> 00:31:32,640
in a meaningful way unless i go

00:31:30,080 --> 00:31:34,000
understand the vm like ebpf does through

00:31:32,640 --> 00:31:36,559
its verifier

00:31:34,000 --> 00:31:38,720
right so so i think i think it's a

00:31:36,559 --> 00:31:41,679
multivm story and by the way i i like

00:31:38,720 --> 00:31:43,519
the answers like tom said i'm not saying

00:31:41,679 --> 00:31:44,559
i have any problems with what you guys

00:31:43,519 --> 00:31:46,000
have done it's actually pretty

00:31:44,559 --> 00:31:48,080
fascinating but

00:31:46,000 --> 00:31:51,919
from a community perspective the answer

00:31:48,080 --> 00:31:51,919
of two vms will be problematic

00:31:52,480 --> 00:31:55,200
yes um

00:31:57,039 --> 00:32:03,440
i think that this discussion started on

00:32:00,080 --> 00:32:06,240
how to convince these on uh

00:32:03,440 --> 00:32:07,440
the upstream right but i think it's not

00:32:06,240 --> 00:32:10,480
the

00:32:07,440 --> 00:32:11,440
angle we are trying to approach is more

00:32:10,480 --> 00:32:13,360
like

00:32:11,440 --> 00:32:15,919
it would be good if we have some

00:32:13,360 --> 00:32:20,000
extensibility on top of

00:32:15,919 --> 00:32:23,120
xdp that we could uh extend the kernel

00:32:20,000 --> 00:32:26,720
with uh our execution environment

00:32:23,120 --> 00:32:29,519
the same way we do with net filter

00:32:26,720 --> 00:32:30,320
and a fluid doesn't need to to be in the

00:32:29,519 --> 00:32:33,440
upstream

00:32:30,320 --> 00:32:36,880
it can be it is a simple

00:32:33,440 --> 00:32:39,840
x tables extension if it could

00:32:36,880 --> 00:32:40,840
have some sort of mechanism to do this

00:32:39,840 --> 00:32:43,679
the same for

00:32:40,840 --> 00:32:47,760
xdp for me

00:32:43,679 --> 00:32:49,840
to be the the path the right path first

00:32:47,760 --> 00:32:51,600
well that's going to be a hard sell too

00:32:49,840 --> 00:32:54,720
so

00:32:51,600 --> 00:32:58,480
xvp did start with the intent that

00:32:54,720 --> 00:33:01,679
that it could be plugable and open but

00:32:58,480 --> 00:33:05,120
now it's really an ebpf hook

00:33:01,679 --> 00:33:07,840
and um that's that again is going to get

00:33:05,120 --> 00:33:08,960
get pushed back so i think all of this

00:33:07,840 --> 00:33:12,240
you know just take it as

00:33:08,960 --> 00:33:13,200
as feedback and input um like tradie

00:33:12,240 --> 00:33:15,679
said i think the

00:33:13,200 --> 00:33:16,480
it's really cool what you're doing but

00:33:15,679 --> 00:33:18,799
uh

00:33:16,480 --> 00:33:19,760
this is definitely a moonshot and you

00:33:18,799 --> 00:33:21,600
know i think uh

00:33:19,760 --> 00:33:23,039
we just need to be aware of that so

00:33:21,600 --> 00:33:26,480
let's move on

00:33:23,039 --> 00:33:28,240
go ahead sorry i just think look

00:33:26,480 --> 00:33:29,519
i think the the law serves slightly

00:33:28,240 --> 00:33:31,600
different purposes

00:33:29,519 --> 00:33:33,279
it's a scripting as opposed to

00:33:31,600 --> 00:33:35,279
compilable language

00:33:33,279 --> 00:33:36,640
it's not intended to be for the uh you

00:33:35,279 --> 00:33:39,679
know

00:33:36,640 --> 00:33:42,880
high intense performance requirements

00:33:39,679 --> 00:33:43,840
but it does serve a purpose uh the two

00:33:42,880 --> 00:33:45,840
vm

00:33:43,840 --> 00:33:46,880
i agree with both of you actually that

00:33:45,840 --> 00:33:50,240
this is a

00:33:46,880 --> 00:33:52,559
battle upstream because uh bpf has

00:33:50,240 --> 00:33:53,120
formed a religion now more than anything

00:33:52,559 --> 00:33:55,679
this is

00:33:53,120 --> 00:33:56,720
uh whether you have two vms or not is

00:33:55,679 --> 00:33:59,760
not as relevant

00:33:56,720 --> 00:34:01,360
because uh you want to use the lower vm

00:33:59,760 --> 00:34:03,279
you go ahead and use it

00:34:01,360 --> 00:34:07,120
as opposed to you know you want to use

00:34:03,279 --> 00:34:09,679
the dpfvm

00:34:07,120 --> 00:34:11,440
the security issues the requirements i

00:34:09,679 --> 00:34:12,560
think lua would meet them will just meet

00:34:11,440 --> 00:34:13,760
them slightly differently

00:34:12,560 --> 00:34:15,200
right you can you can restrict the

00:34:13,760 --> 00:34:16,240
functionality that lu any law

00:34:15,200 --> 00:34:18,720
interpreter can have

00:34:16,240 --> 00:34:20,639
you it uses the same helpers the biggest

00:34:18,720 --> 00:34:22,480
value evpf has is it has helped us in

00:34:20,639 --> 00:34:25,520
the country i've been exposed for it

00:34:22,480 --> 00:34:26,800
which if i'm not mistaken lure lunatic

00:34:25,520 --> 00:34:30,000
could use

00:34:26,800 --> 00:34:31,599
right uh yes it's mostly a political

00:34:30,000 --> 00:34:33,440
battle then it is a technical problem

00:34:31,599 --> 00:34:37,440
right now

00:34:33,440 --> 00:34:39,760
so jamel um if performance isn't

00:34:37,440 --> 00:34:41,200
relevant then the obvious question why

00:34:39,760 --> 00:34:43,200
even put this in the kernel why not just

00:34:41,200 --> 00:34:44,879
put this in user space and

00:34:43,200 --> 00:34:47,040
run the packets or tongue tap or

00:34:44,879 --> 00:34:48,960
something sometimes you just want to uh

00:34:47,040 --> 00:34:50,320
have a quick

00:34:48,960 --> 00:34:51,760
protection while you're building

00:34:50,320 --> 00:34:52,320
something that's the way i would say

00:34:51,760 --> 00:34:54,000
this

00:34:52,320 --> 00:34:55,119
right i i've been in a data center where

00:34:54,000 --> 00:34:56,399
they wouldn't allow code that you've

00:34:55,119 --> 00:34:58,800
compiled but they don't have a problem

00:34:56,399 --> 00:35:00,720
you installing a patch script

00:34:58,800 --> 00:35:02,240
right they will absolutely not even fix

00:35:00,720 --> 00:35:05,359
the drivers body

00:35:02,240 --> 00:35:06,880
but it's okay to run a back script right

00:35:05,359 --> 00:35:09,680
so i i would see that maybe

00:35:06,880 --> 00:35:10,640
similar here no but that actually there

00:35:09,680 --> 00:35:13,359
is a way to

00:35:10,640 --> 00:35:15,440
fix that problem and i haven't looked at

00:35:13,359 --> 00:35:16,000
any of the codes i won't presuppose this

00:35:15,440 --> 00:35:17,200
but

00:35:16,000 --> 00:35:19,680
you could say that all the

00:35:17,200 --> 00:35:23,440
classification work all the per packet

00:35:19,680 --> 00:35:25,839
ops is an xdp lives in the xtpvm

00:35:23,440 --> 00:35:28,160
and all the policies are in pure lua

00:35:25,839 --> 00:35:29,760
user space and runs into a user space

00:35:28,160 --> 00:35:32,400
and the exchange is through

00:35:29,760 --> 00:35:33,520
the shared match right with rcu somebody

00:35:32,400 --> 00:35:35,359
suggested already

00:35:33,520 --> 00:35:37,359
or somebody said already so there might

00:35:35,359 --> 00:35:40,640
be a line to cut

00:35:37,359 --> 00:35:42,960
where the packet touching which is

00:35:40,640 --> 00:35:44,400
really in the kernel's domain stays in

00:35:42,960 --> 00:35:46,400
the kernel domain and not in the lower

00:35:44,400 --> 00:35:50,320
domain

00:35:46,400 --> 00:35:50,320
right would you guys agree with that

00:35:51,599 --> 00:35:57,760
sorry the thing is you would

00:35:54,800 --> 00:35:59,119
add latency to go to the user space try

00:35:57,760 --> 00:36:03,440
to

00:35:59,119 --> 00:36:08,079
take the decision over this policy

00:36:03,440 --> 00:36:11,520
and using something like

00:36:08,079 --> 00:36:14,880
nfq with

00:36:11,520 --> 00:36:15,599
net filter right we have tried this

00:36:14,880 --> 00:36:20,160
approach

00:36:15,599 --> 00:36:23,599
in the past but nf lua

00:36:20,160 --> 00:36:27,599
was way more equated uh

00:36:23,599 --> 00:36:30,000
solution for our use case right

00:36:27,599 --> 00:36:31,359
so it can take decision the kernel while

00:36:30,000 --> 00:36:34,720
the the packet

00:36:31,359 --> 00:36:37,599
is going through without uh

00:36:34,720 --> 00:36:38,880
moving these to all the way up to the

00:36:37,599 --> 00:36:41,520
user space

00:36:38,880 --> 00:36:43,119
but that's that's uh that's presupposing

00:36:41,520 --> 00:36:44,400
and there may be performance reasons why

00:36:43,119 --> 00:36:46,640
you have to do it that way but that's

00:36:44,400 --> 00:36:48,960
presupposing that you cannot push the

00:36:46,640 --> 00:36:49,760
cached policy or the downloaded policy

00:36:48,960 --> 00:36:52,960
till

00:36:49,760 --> 00:36:56,400
you've seen the first packet

00:36:52,960 --> 00:36:58,240
take a um example of a star 80 block

00:36:56,400 --> 00:37:00,880
right that can be pushed before you see

00:36:58,240 --> 00:37:02,720
the packet even right so it's sort of

00:37:00,880 --> 00:37:04,960
the question is like where is the cache

00:37:02,720 --> 00:37:06,079
and what is the update policy right if

00:37:04,960 --> 00:37:09,119
you say that

00:37:06,079 --> 00:37:12,160
i push policies updated lua policies

00:37:09,119 --> 00:37:13,839
from before for the basic stuff and only

00:37:12,160 --> 00:37:15,520
for the really complicated

00:37:13,839 --> 00:37:17,599
deep lookups i'm going to take the added

00:37:15,520 --> 00:37:18,000
latency there may be a happy medium and

00:37:17,599 --> 00:37:20,320
i'm

00:37:18,000 --> 00:37:21,680
actually not even sure that that's

00:37:20,320 --> 00:37:22,640
reasonable but there may be things like

00:37:21,680 --> 00:37:26,079
that that is worth

00:37:22,640 --> 00:37:29,359
pursuing alluring in that way

00:37:26,079 --> 00:37:32,800
works like a glue code and

00:37:29,359 --> 00:37:36,240
configuration code as well so we

00:37:32,800 --> 00:37:40,079
can inject lewis creeks to

00:37:36,240 --> 00:37:42,720
access uh rcu

00:37:40,079 --> 00:37:44,160
structure for instance and cache the

00:37:42,720 --> 00:37:47,599
polis there

00:37:44,160 --> 00:37:50,320
so what we're gonna do in lua in in

00:37:47,599 --> 00:37:53,839
kernel space is just a few logic

00:37:50,320 --> 00:37:57,839
accessing these uh data structure

00:37:53,839 --> 00:38:02,800
like a glucose so going up to

00:37:57,839 --> 00:38:02,800
your space in that case would be way

00:38:02,839 --> 00:38:06,320
slower

00:38:04,720 --> 00:38:07,839
yeah and i actually that sounds

00:38:06,320 --> 00:38:10,880
reasonable right i mean that

00:38:07,839 --> 00:38:13,839
you're not actually injecting the lua vm

00:38:10,880 --> 00:38:14,560
in the hot pot then right you're you're

00:38:13,839 --> 00:38:17,280
keeping

00:38:14,560 --> 00:38:18,720
everything in the kernel bpf xdp vm

00:38:17,280 --> 00:38:21,119
which is

00:38:18,720 --> 00:38:23,119
it sounds reasonable i'm looking at dom

00:38:21,119 --> 00:38:26,160
we are using the lua vm

00:38:23,119 --> 00:38:30,240
in kernel as a glue right we use

00:38:26,160 --> 00:38:34,480
we are called by ebpf and we can

00:38:30,240 --> 00:38:38,079
send uh communicate back to ebpf

00:38:34,480 --> 00:38:41,839
in using the map for instance and

00:38:38,079 --> 00:38:44,480
the thing is you don't need to go uh

00:38:41,839 --> 00:38:46,400
on lua for every packet and you don't

00:38:44,480 --> 00:38:49,119
need to go to your space

00:38:46,400 --> 00:38:50,960
as well right it's like the midway

00:38:49,119 --> 00:38:54,960
halfway

00:38:50,960 --> 00:38:56,320
approach yeah actually i see somebody

00:38:54,960 --> 00:39:00,320
suggested okay

00:38:56,320 --> 00:39:01,839
suggested the same thing so

00:39:00,320 --> 00:39:04,240
or something similar doesn't mean the

00:39:01,839 --> 00:39:04,240
same thing

00:39:07,359 --> 00:39:10,480
okay good so let's go to uh next

00:39:09,839 --> 00:39:13,599
question

00:39:10,480 --> 00:39:18,000
is the little context shared among

00:39:13,599 --> 00:39:18,000
all messages on the same cpu

00:39:19,200 --> 00:39:27,200
we use the we have different contexts

00:39:23,920 --> 00:39:30,640
like different execution states for

00:39:27,200 --> 00:39:35,200
cpu but can share data using

00:39:30,640 --> 00:39:35,200
rcu or even the ubf map

00:39:36,160 --> 00:39:43,599
so every state execution state

00:39:39,680 --> 00:39:46,880
is isolated from each other

00:39:43,599 --> 00:39:50,079
but we can share memory using some

00:39:46,880 --> 00:39:52,560
safe mechanism like our rcu and the map

00:39:50,079 --> 00:39:52,560
itself

00:39:54,320 --> 00:40:00,400
okay does each instance of lua

00:39:57,359 --> 00:40:02,800
script run its own interpreter or one

00:40:00,400 --> 00:40:02,800
copy

00:40:05,680 --> 00:40:14,800
you're muted

00:40:10,880 --> 00:40:18,480
sorry sorry uh we copy the

00:40:14,800 --> 00:40:23,280
the script among all

00:40:18,480 --> 00:40:26,400
instances of the vm like in xdp we have

00:40:23,280 --> 00:40:30,560
one vm instance for

00:40:26,400 --> 00:40:35,520
every cpu on when floor we have

00:40:30,560 --> 00:40:38,560
uh execution states created by the user

00:40:35,520 --> 00:40:42,640
itself himself using the

00:40:38,560 --> 00:40:45,280
command line so we can associate the

00:40:42,640 --> 00:40:46,800
the state with uh namespace for instance

00:40:45,280 --> 00:40:49,839
a network namespace

00:40:46,800 --> 00:40:52,960
in that case it took it to be

00:40:49,839 --> 00:40:56,160
only one state per uh

00:40:52,960 --> 00:40:59,359
script right in xdp

00:40:56,160 --> 00:41:01,760
we copy the script among all the cpu

00:40:59,359 --> 00:41:01,760
states

00:41:05,440 --> 00:41:08,880
what is the state of maturity for the

00:41:08,240 --> 00:41:11,599
xdp

00:41:08,880 --> 00:41:11,599
noaa project

00:41:12,480 --> 00:41:18,560
we are running these uh in production

00:41:15,839 --> 00:41:18,560
right now you know

00:41:18,839 --> 00:41:20,960
cdn

00:41:19,870 --> 00:41:24,400
[Music]

00:41:20,960 --> 00:41:27,520
but it's still under

00:41:24,400 --> 00:41:30,880
uh development i mean it's not like

00:41:27,520 --> 00:41:32,720
we have a patch to submit promptly for

00:41:30,880 --> 00:41:36,000
the upstream or

00:41:32,720 --> 00:41:41,520
something like that is kind of biased

00:41:36,000 --> 00:41:46,800
on our use case right so we need to do

00:41:41,520 --> 00:41:46,800
some cleanup and evolution on top of

00:41:46,839 --> 00:41:51,520
these

00:41:48,400 --> 00:41:52,880
okay uh the test results

00:41:51,520 --> 00:41:56,240
make it look like the test machine is

00:41:52,880 --> 00:41:59,359
too fast to get interesting data for x2p

00:41:56,240 --> 00:42:02,720
uh would be nice to have

00:41:59,359 --> 00:42:04,640
10 gigabits or faster because we're

00:42:02,720 --> 00:42:06,480
apparently running out of links

00:42:04,640 --> 00:42:09,359
throughput before cpu

00:42:06,480 --> 00:42:10,079
so i guess that's more of a comment um

00:42:09,359 --> 00:42:13,440
yes

00:42:10,079 --> 00:42:14,560
would be good to see that yeah i totally

00:42:13,440 --> 00:42:18,400
agree with you

00:42:14,560 --> 00:42:21,040
and it's actually the the thing we are

00:42:18,400 --> 00:42:22,400
struggling the the most because don't

00:42:21,040 --> 00:42:25,440
have like

00:42:22,400 --> 00:42:30,319
fancy uh network

00:42:25,440 --> 00:42:31,520
interface and we are relying on virtual

00:42:30,319 --> 00:42:34,880
environment right

00:42:31,520 --> 00:42:38,000
but stone pointed out

00:42:34,880 --> 00:42:41,599
we may vary the

00:42:38,000 --> 00:42:44,720
the cpu on capacity on

00:42:41,599 --> 00:42:46,960
such vm so we definitely going to do

00:42:44,720 --> 00:42:46,960
that

00:42:47,839 --> 00:42:51,839
is this lua jet or sorry how does that

00:42:51,040 --> 00:42:55,440
fluid

00:42:51,839 --> 00:42:55,440
do it rio or your own vm

00:42:55,520 --> 00:43:02,480
sure uh is this louis louis

00:42:59,760 --> 00:43:04,720
who are real who are real they are real

00:43:02,480 --> 00:43:04,720
okay

00:43:05,440 --> 00:43:12,880
it's uh the the

00:43:08,640 --> 00:43:16,480
actual main language right not uh

00:43:12,880 --> 00:43:18,560
the lewis jet fork and

00:43:16,480 --> 00:43:19,680
we are trying that that's something that

00:43:18,560 --> 00:43:22,880
are

00:43:19,680 --> 00:43:26,160
is on our road map that is to use

00:43:22,880 --> 00:43:29,680
pallini that is like

00:43:26,160 --> 00:43:33,280
a typed lure that allow

00:43:29,680 --> 00:43:36,319
us to to compile lua

00:43:33,280 --> 00:43:39,520
and perform some optimizations

00:43:36,319 --> 00:43:41,940
it's like the approach the

00:43:39,520 --> 00:43:43,520
main development is following to

00:43:41,940 --> 00:43:47,119
[Music]

00:43:43,520 --> 00:43:50,400
compete with luigi uh performance

00:43:47,119 --> 00:43:55,119
so it's something that is on our roadmap

00:43:50,400 --> 00:43:58,400
not to use luigi directly because of all

00:43:55,119 --> 00:44:01,680
platform dependency but

00:43:58,400 --> 00:44:05,119
we sure want to try pallini

00:44:01,680 --> 00:44:09,839
that is pretty much lure syntax with

00:44:05,119 --> 00:44:09,839
uh type marks

00:44:12,640 --> 00:44:16,640
okay uh jamel you have your hand raised

00:44:18,960 --> 00:44:24,160
sorry that's before i interjected i'll

00:44:20,960 --> 00:44:24,160
i'll remove it

00:44:28,960 --> 00:44:32,240
okay uh there's a lot a lot of comments

00:44:31,440 --> 00:44:35,200
um

00:44:32,240 --> 00:44:35,599
in the chat hopefully i can capture that

00:44:35,200 --> 00:44:39,040
uh

00:44:35,599 --> 00:44:40,560
but i think that's all of the major

00:44:39,040 --> 00:44:43,599
questions

00:44:40,560 --> 00:44:44,319
so uh thank you very much and as i

00:44:43,599 --> 00:44:46,000
mentioned

00:44:44,319 --> 00:44:47,920
um we're still ahead of time so why

00:44:46,000 --> 00:44:51,119
don't we take a a five minute

00:44:47,920 --> 00:44:53,599
uh break and then we'll

00:44:51,119 --> 00:44:53,599
continue

00:44:54,160 --> 00:44:57,920
can we talk during this five minute

00:44:55,680 --> 00:44:57,920

YouTube URL: https://www.youtube.com/watch?v=WseulhFNpLE


