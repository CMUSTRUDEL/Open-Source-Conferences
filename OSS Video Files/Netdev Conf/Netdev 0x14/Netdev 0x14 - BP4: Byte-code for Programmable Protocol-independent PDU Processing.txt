Title: Netdev 0x14 - BP4: Byte-code for Programmable Protocol-independent PDU Processing
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Tom Herbert

More info: https://netdevconf.info/0x14/session.html?talk-BP4-byte-code-for-programmable-protocol-independent-PDU-processing

Date: Monday, August 17, 2020

Tom Herbert likes moonshots and three-letter acronyms;
first it was XDP and now it is BP4.

In this talk, Tom will introduce BP4 - a Domain Specific Language
for programmable dataplanes based on unifying the best features of
eBPF and P4. The goal of BP4 is “write once, run anywhere, run well!”
BP4 is intended to run in _both software and hardware_ execution
environments.

Central to a BP4 program is a dynamically programmable parser that supports
a wide variety of protocols and permits support for new protocols to be added
on the fly. The BP4 parser semantics include native support for parsing
Variable Length Headers (VLH) that contains TLVs, flag-fields, or variable
length arrays. 

Tom will describe the first PoC for BP4 which leverages the eBPF infrastructure.
The PoC  implements a flow dissector as a BP4 program by essentially replicating
the functionality of the current Linux network flow_dissector with extra
functionality to handle TLV and flag-fields. The programmable flow dissector
will then be used as the basis for a dynamic tc-flower classification
(which will allow protocols to be programmed and dynamically added for
tc-flower processing).
Captions: 
	00:00:02,720 --> 00:00:08,720
my name is tom herbert

00:00:04,240 --> 00:00:10,800
and today i'm going to talk about bp4

00:00:08,720 --> 00:00:12,480
beyond packet processing towards

00:00:10,800 --> 00:00:16,240
protocol processing

00:00:12,480 --> 00:00:19,680
this is some work that excuse me

00:00:16,240 --> 00:00:22,720
um i started a while back

00:00:19,680 --> 00:00:24,320
and the aim is to basically improve host

00:00:22,720 --> 00:00:26,080
network processing and start to

00:00:24,320 --> 00:00:27,199
introduce some possibilities for

00:00:26,080 --> 00:00:30,880
accelerating

00:00:27,199 --> 00:00:33,360
some of the networking stack

00:00:30,880 --> 00:00:34,480
so let's look at the problems in host

00:00:33,360 --> 00:00:37,520
networking

00:00:34,480 --> 00:00:40,000
that people are hitting today

00:00:37,520 --> 00:00:41,520
and these these problems are based on

00:00:40,000 --> 00:00:43,520
kind of the problem space which is

00:00:41,520 --> 00:00:44,160
programmable devices programmable data

00:00:43,520 --> 00:00:47,280
pass

00:00:44,160 --> 00:00:50,399
p4 ebpf things like that

00:00:47,280 --> 00:00:53,039
so first of all hosts are not routers

00:00:50,399 --> 00:00:54,160
this has been a long-standing kind of

00:00:53,039 --> 00:00:58,239
issue

00:00:54,160 --> 00:01:00,000
we've seen this go both ways so hosts

00:00:58,239 --> 00:01:01,600
are sometimes adapting to router

00:01:00,000 --> 00:01:03,199
functionality routers are adapting to

00:01:01,600 --> 00:01:05,439
host functionality

00:01:03,199 --> 00:01:06,400
uh one good example of this right now is

00:01:05,439 --> 00:01:09,600
there's some push

00:01:06,400 --> 00:01:10,960
to implement p4 in the host

00:01:09,600 --> 00:01:12,799
and then we know there's a lot of

00:01:10,960 --> 00:01:15,200
routers out there that are starting to

00:01:12,799 --> 00:01:18,400
do things like connection tracking

00:01:15,200 --> 00:01:19,119
and and implement host functionality but

00:01:18,400 --> 00:01:20,799
fundamentally

00:01:19,119 --> 00:01:23,280
we should never forget this host are not

00:01:20,799 --> 00:01:25,840
routers they're fundamentally different

00:01:23,280 --> 00:01:27,520
and the problems on the host are very

00:01:25,840 --> 00:01:29,759
different than routers

00:01:27,520 --> 00:01:31,680
hosts are concerned with all of the

00:01:29,759 --> 00:01:34,560
seven layers of the osi

00:01:31,680 --> 00:01:35,680
model so everything from obviously the

00:01:34,560 --> 00:01:38,840
network interconnect

00:01:35,680 --> 00:01:40,159
network layer transport layer crypto

00:01:38,840 --> 00:01:41,600
protocols

00:01:40,159 --> 00:01:43,280
everything all the way up through upper

00:01:41,600 --> 00:01:44,799
layer protocols and the application

00:01:43,280 --> 00:01:47,520
itself

00:01:44,799 --> 00:01:48,320
so we have to view the host in this

00:01:47,520 --> 00:01:51,600
regard

00:01:48,320 --> 00:01:54,000
with a holistic mindset so when we try

00:01:51,600 --> 00:01:56,560
to solve problems we want to solve

00:01:54,000 --> 00:01:57,680
problems that improve the application in

00:01:56,560 --> 00:01:59,360
the end of the day

00:01:57,680 --> 00:02:01,119
and sometimes there's a tendency to get

00:01:59,360 --> 00:02:02,960
lost in this maybe

00:02:01,119 --> 00:02:04,960
we improve one small part of the stack

00:02:02,960 --> 00:02:07,680
say packet processing

00:02:04,960 --> 00:02:08,319
and in that in that small part we see a

00:02:07,680 --> 00:02:10,720
00:02:08,319 --> 00:02:11,920
performance game well that's great

00:02:10,720 --> 00:02:14,160
except when you take this on an

00:02:11,920 --> 00:02:16,959
application we hit amdahl's law and that

00:02:14,160 --> 00:02:18,560
50 percent turns into some tiny

00:02:16,959 --> 00:02:20,800
performance gain because the packet

00:02:18,560 --> 00:02:24,160
processing really wasn't

00:02:20,800 --> 00:02:26,319
much of the overall processing overhead

00:02:24,160 --> 00:02:27,680
stateful versus stateless so this is a

00:02:26,319 --> 00:02:30,640
big issue

00:02:27,680 --> 00:02:31,680
as most people know the second we turn

00:02:30,640 --> 00:02:33,440
into

00:02:31,680 --> 00:02:35,360
a stateful device or stateful

00:02:33,440 --> 00:02:36,640
implementation particularly with flow

00:02:35,360 --> 00:02:39,599
state

00:02:36,640 --> 00:02:41,760
we need memory we need synchronization

00:02:39,599 --> 00:02:44,000
there is a lot of work

00:02:41,760 --> 00:02:45,599
and a lot of effort that goes into that

00:02:44,000 --> 00:02:48,160
so it's really uh

00:02:45,599 --> 00:02:50,080
it's almost like a binary switch for

00:02:48,160 --> 00:02:53,440
implementations to go from state

00:02:50,080 --> 00:02:54,640
stateless to state full one of the

00:02:53,440 --> 00:02:56,959
aspects here

00:02:54,640 --> 00:02:59,599
particularly in bp4 that we're focusing

00:02:56,959 --> 00:03:02,640
on is pdus and not just packets

00:02:59,599 --> 00:03:04,480
so pdus are protocol data units the

00:03:02,640 --> 00:03:07,519
distinction here is that

00:03:04,480 --> 00:03:09,200
as a host we don't just process packets

00:03:07,519 --> 00:03:11,680
sometimes we process

00:03:09,200 --> 00:03:12,400
uh higher layer abstractions and a great

00:03:11,680 --> 00:03:15,680
example

00:03:12,400 --> 00:03:17,760
is as i warp i have a slide on this next

00:03:15,680 --> 00:03:19,599
where we are processing messages within

00:03:17,760 --> 00:03:22,239
a tcp stream

00:03:19,599 --> 00:03:24,879
so in fact there's several layers of

00:03:22,239 --> 00:03:28,080
protocol processing that we have to

00:03:24,879 --> 00:03:29,519
do in those cases one of the

00:03:28,080 --> 00:03:32,159
topics that i've been pondering a lot

00:03:29,519 --> 00:03:34,799
lately is hardware offloads

00:03:32,159 --> 00:03:36,319
and frankly when i look at the industry

00:03:34,799 --> 00:03:38,799
hardware offloads

00:03:36,319 --> 00:03:40,400
success has been underwhelming and i

00:03:38,799 --> 00:03:42,239
think we need to ask why

00:03:40,400 --> 00:03:44,879
so there's only a handful of hardware

00:03:42,239 --> 00:03:48,080
offloads check some offload

00:03:44,879 --> 00:03:51,200
rss tso

00:03:48,080 --> 00:03:53,280
that have shown any

00:03:51,200 --> 00:03:54,319
real success in the market in the

00:03:53,280 --> 00:03:56,480
industry

00:03:54,319 --> 00:03:58,840
any advanced offloads or most of them

00:03:56,480 --> 00:04:01,920
have either become very niche

00:03:58,840 --> 00:04:04,400
or we've kind of abandoned

00:04:01,920 --> 00:04:07,280
you can think of tcp offload engines as

00:04:04,400 --> 00:04:09,280
kind of the poster child of that

00:04:07,280 --> 00:04:11,120
the next one is the myth of the fast

00:04:09,280 --> 00:04:13,599
path and common case

00:04:11,120 --> 00:04:16,079
and this is a really interesting one we

00:04:13,599 --> 00:04:18,320
also have a long history of this

00:04:16,079 --> 00:04:20,000
so you can go way back when into the

00:04:18,320 --> 00:04:23,040
early days of the internet

00:04:20,000 --> 00:04:25,440
and almost immediately we devised

00:04:23,040 --> 00:04:27,680
that there are fast path protocol

00:04:25,440 --> 00:04:29,600
operations and slow path

00:04:27,680 --> 00:04:31,600
so usually the fast path is what we call

00:04:29,600 --> 00:04:33,360
the critical data path

00:04:31,600 --> 00:04:35,120
and everything else is relegated to the

00:04:33,360 --> 00:04:38,240
slope path so

00:04:35,120 --> 00:04:41,199
one obvious example of this was tcp

00:04:38,240 --> 00:04:41,520
send processing so tcp sends are only

00:04:41,199 --> 00:04:44,080
sent

00:04:41,520 --> 00:04:45,520
at the beginning of a connection and

00:04:44,080 --> 00:04:47,280
once the connection's an established

00:04:45,520 --> 00:04:49,680
state we don't have to worry about them

00:04:47,280 --> 00:04:52,000
so the fast path basically became tcp

00:04:49,680 --> 00:04:54,160
connections and established state

00:04:52,000 --> 00:04:56,320
but subsequent to that people figured

00:04:54,160 --> 00:04:59,360
out that they could do a dos attack

00:04:56,320 --> 00:05:01,840
a sin attack basically and floods

00:04:59,360 --> 00:05:03,520
machines with sins and what they were

00:05:01,840 --> 00:05:07,520
doing was exercising

00:05:03,520 --> 00:05:09,360
the slow path and we found out that

00:05:07,520 --> 00:05:11,120
what we thought was a slow path wasn't

00:05:09,360 --> 00:05:12,240
was actually the fast path and this was

00:05:11,120 --> 00:05:14,639
also

00:05:12,240 --> 00:05:16,000
also occurred because of web server

00:05:14,639 --> 00:05:19,360
front-end web servers that have

00:05:16,000 --> 00:05:20,960
very high turnover rates so we have to

00:05:19,360 --> 00:05:23,280
be really careful when we when we

00:05:20,960 --> 00:05:26,080
consider optimizations

00:05:23,280 --> 00:05:27,680
to ensure that we're not myopic on the

00:05:26,080 --> 00:05:28,639
fast path or the common case and

00:05:27,680 --> 00:05:31,360
remember that

00:05:28,639 --> 00:05:33,120
in networking even edge conditions

00:05:31,360 --> 00:05:35,120
especially with regards to things like

00:05:33,120 --> 00:05:35,919
denial of service can come back to haunt

00:05:35,120 --> 00:05:39,440
us if we don't

00:05:35,919 --> 00:05:42,400
consider them the next one is the

00:05:39,440 --> 00:05:44,320
traditional stack driver device model

00:05:42,400 --> 00:05:45,840
i've actually come to believe that this

00:05:44,320 --> 00:05:49,039
is a bottleneck

00:05:45,840 --> 00:05:51,120
and i think we

00:05:49,039 --> 00:05:52,800
we want to change this fundamental model

00:05:51,120 --> 00:05:54,479
so i won't be talking about this today

00:05:52,800 --> 00:05:56,960
and and i should have mentioned up front

00:05:54,479 --> 00:05:59,520
that all of these are in themselves

00:05:56,960 --> 00:06:00,639
probably worthy of their own talk this

00:05:59,520 --> 00:06:02,639
is one of the big

00:06:00,639 --> 00:06:04,960
big items i think in the future is

00:06:02,639 --> 00:06:08,000
changing that model

00:06:04,960 --> 00:06:09,039
another one that is probably more

00:06:08,000 --> 00:06:11,280
understood by

00:06:09,039 --> 00:06:12,240
a linux developer community but once you

00:06:11,280 --> 00:06:15,680
leave that

00:06:12,240 --> 00:06:17,280
uh there's some um kind of uh

00:06:15,680 --> 00:06:19,360
ambivalence about this

00:06:17,280 --> 00:06:20,960
but host stacks today are written in c

00:06:19,360 --> 00:06:24,560
and c plus plus

00:06:20,960 --> 00:06:28,400
and this is very difficult to change so

00:06:24,560 --> 00:06:30,560
for instance evpf is conceptually

00:06:28,400 --> 00:06:32,400
a byte code that could work with any

00:06:30,560 --> 00:06:34,400
language but realistically most people

00:06:32,400 --> 00:06:36,560
are writing in c

00:06:34,400 --> 00:06:38,479
and i don't see that uh changing

00:06:36,560 --> 00:06:40,560
dramatically so we will continue to

00:06:38,479 --> 00:06:42,319
write host stacks in c and c plus plus

00:06:40,560 --> 00:06:45,440
and presumably extending them

00:06:42,319 --> 00:06:46,840
uh in those languages uh the last one is

00:06:45,440 --> 00:06:48,960
more of a

00:06:46,840 --> 00:06:50,240
interesting philosophical argument or

00:06:48,960 --> 00:06:53,440
dichotomy

00:06:50,240 --> 00:06:55,520
so getting performance and flexibility

00:06:53,440 --> 00:06:57,520
at the same time simultaneously goes

00:06:55,520 --> 00:07:01,039
again against

00:06:57,520 --> 00:07:02,800
conventional wisdom so the idea is with

00:07:01,039 --> 00:07:04,960
performance

00:07:02,800 --> 00:07:06,639
the argument is typically you cannot do

00:07:04,960 --> 00:07:09,440
that in a cpu

00:07:06,639 --> 00:07:10,639
you have to have fancy hardware offloads

00:07:09,440 --> 00:07:12,960
in order to do that

00:07:10,639 --> 00:07:14,880
and flexibility is kind of the contrary

00:07:12,960 --> 00:07:16,400
argument we cannot make a hardware

00:07:14,880 --> 00:07:20,080
implementation

00:07:16,400 --> 00:07:22,160
super flexible so the

00:07:20,080 --> 00:07:23,919
the grand prize in all this then i think

00:07:22,160 --> 00:07:25,120
there's there's several people who

00:07:23,919 --> 00:07:26,880
understand this

00:07:25,120 --> 00:07:28,080
if you can get both of these performance

00:07:26,880 --> 00:07:29,440
and flexibility in the same

00:07:28,080 --> 00:07:33,280
implementation

00:07:29,440 --> 00:07:34,000
then you have something so this quickly

00:07:33,280 --> 00:07:36,560
is

00:07:34,000 --> 00:07:38,960
an example of the pdus that i was

00:07:36,560 --> 00:07:42,240
referring to so we have two tcp

00:07:38,960 --> 00:07:46,560
over ipv6 packets and

00:07:42,240 --> 00:07:49,360
within the first packet is one ddp rdma

00:07:46,560 --> 00:07:50,240
iwork message so that's the ddp header

00:07:49,360 --> 00:07:53,440
the rdma

00:07:50,240 --> 00:07:55,759
data header and the data itself

00:07:53,440 --> 00:07:58,639
and then it contains about the first

00:07:55,759 --> 00:08:00,720
half of the second message

00:07:58,639 --> 00:08:03,280
and then the data portion of the second

00:08:00,720 --> 00:08:06,960
message continues in the second packet

00:08:03,280 --> 00:08:09,759
and then after that we have another rdm

00:08:06,960 --> 00:08:11,039
rdma message now when we process these

00:08:09,759 --> 00:08:14,800
packets we see two

00:08:11,039 --> 00:08:18,639
tcpip packets however when we process

00:08:14,800 --> 00:08:21,120
the encapsulated iwork messages

00:08:18,639 --> 00:08:21,840
we actually have three of them so this

00:08:21,120 --> 00:08:24,479
is a

00:08:21,840 --> 00:08:25,599
a host problem especially for end hose

00:08:24,479 --> 00:08:28,240
processing

00:08:25,599 --> 00:08:29,919
we have basically five protocol units

00:08:28,240 --> 00:08:34,240
that have to be processed

00:08:29,919 --> 00:08:34,240
to completely process this scenario

00:08:35,039 --> 00:08:40,320
so what are the goals of bp4

00:08:38,479 --> 00:08:43,279
and it's pretty simple we want to make

00:08:40,320 --> 00:08:44,640
networking stack software better

00:08:43,279 --> 00:08:47,839
and we want to make better use of

00:08:44,640 --> 00:08:47,839
hardware acceleration

00:08:49,120 --> 00:08:52,640
so if we look at what what what can we

00:08:51,440 --> 00:08:54,640
do in the host stack

00:08:52,640 --> 00:08:57,040
and one way to look at that is what are

00:08:54,640 --> 00:08:59,440
the functions that

00:08:57,040 --> 00:09:02,080
we can accelerate we can make faster we

00:08:59,440 --> 00:09:03,839
could potentially accelerate in hardware

00:09:02,080 --> 00:09:05,680
and these are most of these are the

00:09:03,839 --> 00:09:07,360
typical ones so we know that checksum

00:09:05,680 --> 00:09:10,560
offload

00:09:07,360 --> 00:09:14,320
crypto hashes these are

00:09:10,560 --> 00:09:16,880
commonly either accelerated or offloaded

00:09:14,320 --> 00:09:18,399
state lookup as i mentioned when we

00:09:16,880 --> 00:09:21,279
transition to a stateless

00:09:18,399 --> 00:09:22,800
or stateful environment we now have to

00:09:21,279 --> 00:09:24,080
do state lookups

00:09:22,800 --> 00:09:26,080
so this is something that could be

00:09:24,080 --> 00:09:29,440
optimized for instance

00:09:26,080 --> 00:09:30,640
even the hash of lookup in a hash table

00:09:29,440 --> 00:09:33,279
could be

00:09:30,640 --> 00:09:33,760
somewhat automated or accelerated and

00:09:33,279 --> 00:09:36,880
then

00:09:33,760 --> 00:09:37,519
the procedures to track down the actual

00:09:36,880 --> 00:09:41,120
state and

00:09:37,519 --> 00:09:43,680
say our hash table that could be

00:09:41,120 --> 00:09:45,760
something of interest to accelerate and

00:09:43,680 --> 00:09:47,040
that leads into state maintenance

00:09:45,760 --> 00:09:50,080
so once we have state we have to

00:09:47,040 --> 00:09:52,800
maintain it so we need ways to

00:09:50,080 --> 00:09:54,560
create state remove state and as i

00:09:52,800 --> 00:09:57,360
mentioned in the case of something a syn

00:09:54,560 --> 00:09:57,839
attack this can be considered a fast

00:09:57,360 --> 00:10:00,959
path

00:09:57,839 --> 00:10:02,160
operation in a lot of cases segmentation

00:10:00,959 --> 00:10:04,079
and reassembly

00:10:02,160 --> 00:10:06,399
is important especially when we deal

00:10:04,079 --> 00:10:08,480
with the

00:10:06,399 --> 00:10:09,440
messages in tcp for instance as we

00:10:08,480 --> 00:10:13,040
showed on the

00:10:09,440 --> 00:10:15,839
last slide with the iwork example so

00:10:13,040 --> 00:10:16,959
processes that automate that or help

00:10:15,839 --> 00:10:20,000
with that

00:10:16,959 --> 00:10:22,160
that provide cues that can be

00:10:20,000 --> 00:10:24,079
quickly accessed and then once we have

00:10:22,160 --> 00:10:26,880
queues usually we need timers

00:10:24,079 --> 00:10:28,720
for reassembly so there's quite a bit of

00:10:26,880 --> 00:10:32,000
mechanics there

00:10:28,720 --> 00:10:34,560
protocol pursing this is one that that

00:10:32,000 --> 00:10:35,600
is really interesting and i will go a

00:10:34,560 --> 00:10:38,640
little more into depth

00:10:35,600 --> 00:10:41,519
on this in the next few slides

00:10:38,640 --> 00:10:43,279
data movement header data split so this

00:10:41,519 --> 00:10:44,640
is again something that's pretty unique

00:10:43,279 --> 00:10:46,480
to a host

00:10:44,640 --> 00:10:48,800
we need to always remember that when we

00:10:46,480 --> 00:10:51,600
get packets from the network

00:10:48,800 --> 00:10:53,279
the point is to deliver the data to the

00:10:51,600 --> 00:10:54,240
application in the most efficient way

00:10:53,279 --> 00:10:55,839
possible

00:10:54,240 --> 00:10:58,240
this becomes especially interesting in

00:10:55,839 --> 00:11:00,560
the world of gpus and cpus

00:10:58,240 --> 00:11:02,240
where the data and the headers may go

00:11:00,560 --> 00:11:03,200
completely different directions so for

00:11:02,240 --> 00:11:06,399
instance

00:11:03,200 --> 00:11:10,000
the tcp header might be processed by

00:11:06,399 --> 00:11:13,200
the cpu however the enclosed data

00:11:10,000 --> 00:11:14,720
would be processed by gpus so we need a

00:11:13,200 --> 00:11:16,560
increasing amount of intelligence to

00:11:14,720 --> 00:11:19,839
handle that

00:11:16,560 --> 00:11:23,360
the last one is more of the pedantics of

00:11:19,839 --> 00:11:26,800
protocol processing so we need

00:11:23,360 --> 00:11:29,440
efficient header field access byte swap

00:11:26,800 --> 00:11:30,160
those normal things and the last one but

00:11:29,440 --> 00:11:32,160
not least

00:11:30,160 --> 00:11:33,600
is we're always on the lookout to

00:11:32,160 --> 00:11:36,240
improve the parallelism

00:11:33,600 --> 00:11:37,040
in the system so if you look at all

00:11:36,240 --> 00:11:39,200
these these

00:11:37,040 --> 00:11:40,640
these essentially form sort of the basic

00:11:39,200 --> 00:11:43,680
mechanics

00:11:40,640 --> 00:11:44,880
of network processing uh particularly

00:11:43,680 --> 00:11:46,959
receive

00:11:44,880 --> 00:11:47,920
transmit also transmitter could probably

00:11:46,959 --> 00:11:50,560
add qos

00:11:47,920 --> 00:11:51,440
and packet scheduling but when you break

00:11:50,560 --> 00:11:54,160
it down

00:11:51,440 --> 00:11:57,040
uh pdu processing protocol processing

00:11:54,160 --> 00:11:58,720
really is about these sort of

00:11:57,040 --> 00:12:00,800
of components and then we glue those

00:11:58,720 --> 00:12:03,839
together in a coherent program and

00:12:00,800 --> 00:12:05,920
that's the implementation

00:12:03,839 --> 00:12:07,839
so the one i want to focus on today and

00:12:05,920 --> 00:12:11,040
this is the most relevant to

00:12:07,839 --> 00:12:11,760
the initial implementation of bp4 is the

00:12:11,040 --> 00:12:15,680
protocol

00:12:11,760 --> 00:12:18,959
parsing aspect so why is

00:12:15,680 --> 00:12:19,920
protocol parsing interesting well here

00:12:18,959 --> 00:12:23,040
is the graph

00:12:19,920 --> 00:12:24,079
of most of the protocols that floated

00:12:23,040 --> 00:12:27,200
sector in the coronal

00:12:24,079 --> 00:12:30,160
kernel processes so the idea here is

00:12:27,200 --> 00:12:31,040
we can create a parse graph and we can

00:12:30,160 --> 00:12:34,639
link

00:12:31,040 --> 00:12:36,320
various protocols as they appear in

00:12:34,639 --> 00:12:38,160
possible packets

00:12:36,320 --> 00:12:40,800
so for the most part all protocols start

00:12:38,160 --> 00:12:44,240
with the top there which is the ethernet

00:12:40,800 --> 00:12:46,079
frame coming in and the way we proceed

00:12:44,240 --> 00:12:47,040
through this table is we do a look up on

00:12:46,079 --> 00:12:49,680
the

00:12:47,040 --> 00:12:51,600
protocol and the ethernet header and do

00:12:49,680 --> 00:12:52,639
a switch on that that gets us in to say

00:12:51,600 --> 00:12:55,120
ipv4

00:12:52,639 --> 00:12:57,360
and we switch on that protocol that gets

00:12:55,120 --> 00:12:59,600
us into udp

00:12:57,360 --> 00:13:02,480
udp we now have encapsulation so that

00:12:59,600 --> 00:13:04,720
can switch us into something like turi

00:13:02,480 --> 00:13:07,440
and then if you look at this graph the

00:13:04,720 --> 00:13:08,720
red lines are the backlinks

00:13:07,440 --> 00:13:11,040
so the backlinks are really

00:13:08,720 --> 00:13:12,079
encapsulation and

00:13:11,040 --> 00:13:15,200
the interesting thing about

00:13:12,079 --> 00:13:17,920
encapsulation was before encapsulation

00:13:15,200 --> 00:13:19,760
life was pretty simple uh once we have

00:13:17,920 --> 00:13:23,279
encapsulations specifically

00:13:19,760 --> 00:13:25,600
all these red backlinks we now have

00:13:23,279 --> 00:13:27,920
basically an infinite number of packet

00:13:25,600 --> 00:13:29,600
combinations that that are possible

00:13:27,920 --> 00:13:33,360
so we can go through several layers of

00:13:29,600 --> 00:13:38,240
encapsulation we can have ipv6 and ipv4

00:13:33,360 --> 00:13:41,600
we can do udp and udp tcp and udp

00:13:38,240 --> 00:13:43,600
many many encapsulations

00:13:41,600 --> 00:13:46,160
and host we also have an additional

00:13:43,600 --> 00:13:48,880
problem that that switches wouldn't see

00:13:46,160 --> 00:13:50,639
and that's exhibited on the left side on

00:13:48,880 --> 00:13:53,440
the stream parser

00:13:50,639 --> 00:13:54,240
where we actually want to parse the tcp

00:13:53,440 --> 00:13:56,399
data stream

00:13:54,240 --> 00:13:57,680
into discrete messages so that's

00:13:56,399 --> 00:14:00,160
represented there

00:13:57,680 --> 00:14:01,680
so now we have for instance tls messages

00:14:00,160 --> 00:14:04,880
over tcp

00:14:01,680 --> 00:14:08,000
and that can further be parsed into rpc

00:14:04,880 --> 00:14:10,959
messages over tls over tcp

00:14:08,000 --> 00:14:12,240
so all of this if you look at it at a

00:14:10,959 --> 00:14:13,519
picture like this looks really

00:14:12,240 --> 00:14:17,519
complicated

00:14:13,519 --> 00:14:23,279
and indeed it it kind of is

00:14:17,519 --> 00:14:25,199
and that leads us into skb flow dissect

00:14:23,279 --> 00:14:27,120
i like to call this the function linux

00:14:25,199 --> 00:14:27,920
function that we love to hate or hate to

00:14:27,120 --> 00:14:30,560
love

00:14:27,920 --> 00:14:31,839
it's a very interesting function it's

00:14:30,560 --> 00:14:33,040
one of the largest probably in the

00:14:31,839 --> 00:14:36,079
networking stack

00:14:33,040 --> 00:14:37,839
but basically what it does is it parses

00:14:36,079 --> 00:14:39,360
pretty much all those protocols on the

00:14:37,839 --> 00:14:41,680
preceding page

00:14:39,360 --> 00:14:43,600
and the idea is that it just parses them

00:14:41,680 --> 00:14:45,440
and extracts metadata so we want this to

00:14:43,600 --> 00:14:49,040
be as fast as possible

00:14:45,440 --> 00:14:50,079
and we want it to be as complete as

00:14:49,040 --> 00:14:53,120
possible

00:14:50,079 --> 00:14:56,079
so it handles probably as many protocols

00:14:53,120 --> 00:14:58,800
as about anyone else it has multiple

00:14:56,079 --> 00:15:00,959
uses so it's really mushroomed

00:14:58,800 --> 00:15:03,279
in the kernel so originally it was just

00:15:00,959 --> 00:15:04,800
a simple hash to do rps but now it's

00:15:03,279 --> 00:15:08,399
been

00:15:04,800 --> 00:15:11,120
extended for security and other reasons

00:15:08,399 --> 00:15:12,160
and it's completely parametrizable so we

00:15:11,120 --> 00:15:14,160
can control

00:15:12,160 --> 00:15:15,440
certain aspects of the parsing like like

00:15:14,160 --> 00:15:17,199
whether or not we go into certain

00:15:15,440 --> 00:15:20,079
extension headers

00:15:17,199 --> 00:15:22,399
it's it is efficient um but its

00:15:20,079 --> 00:15:22,880
efficiency is limited by the fact that

00:15:22,399 --> 00:15:25,120
it's

00:15:22,880 --> 00:15:26,160
it's kind of serialized code the

00:15:25,120 --> 00:15:29,360
function itself

00:15:26,160 --> 00:15:30,720
is over 600 lines

00:15:29,360 --> 00:15:34,399
and then there's like another thousand

00:15:30,720 --> 00:15:36,800
lines of code to support it

00:15:34,399 --> 00:15:38,720
tc flower makes nice use of it and has

00:15:36,800 --> 00:15:41,440
an ebpf hook

00:15:38,720 --> 00:15:42,959
so that's the good side of it uh the bad

00:15:41,440 --> 00:15:45,920
side as i mentioned

00:15:42,959 --> 00:15:46,720
it's a lot of lines of code uh and

00:15:45,920 --> 00:15:49,680
believe it or not

00:15:46,720 --> 00:15:51,279
it's been cleaned up significantly um

00:15:49,680 --> 00:15:54,720
prior to

00:15:51,279 --> 00:15:57,040
the first major cleanup it had

00:15:54,720 --> 00:15:58,000
many many lines of code in line in one

00:15:57,040 --> 00:16:01,279
function

00:15:58,000 --> 00:16:02,800
we had a whole bunch of go to's it still

00:16:01,279 --> 00:16:06,000
is a bunch of switches and

00:16:02,800 --> 00:16:08,240
if statements and

00:16:06,000 --> 00:16:09,120
it is complex and i don't think anyone's

00:16:08,240 --> 00:16:12,880
going to

00:16:09,120 --> 00:16:16,240
going to deny that and that complexity

00:16:12,880 --> 00:16:18,959
has led to a number of errors and bugs

00:16:16,240 --> 00:16:19,920
especially in less common protocols and

00:16:18,959 --> 00:16:22,160
usually

00:16:19,920 --> 00:16:23,279
the bugs are in what i call the

00:16:22,160 --> 00:16:26,000
bookkeeping

00:16:23,279 --> 00:16:27,680
of this so every time we parse a

00:16:26,000 --> 00:16:29,279
protocol we have to check

00:16:27,680 --> 00:16:30,720
certain things like the bounds of the

00:16:29,279 --> 00:16:31,680
protocol we have to check that the

00:16:30,720 --> 00:16:34,160
length

00:16:31,680 --> 00:16:36,160
uh of the protocol header doesn't exceed

00:16:34,160 --> 00:16:38,240
the length of the packet

00:16:36,160 --> 00:16:40,959
in the kernel we have to pull up the

00:16:38,240 --> 00:16:44,160
data and skbs

00:16:40,959 --> 00:16:47,040
and all of that contributed to to

00:16:44,160 --> 00:16:49,360
some of the bugs we saw so it is complex

00:16:47,040 --> 00:16:52,160
it's also inflexible

00:16:49,360 --> 00:16:52,959
and why we do have an ebpf hook

00:16:52,160 --> 00:16:56,240
basically

00:16:52,959 --> 00:16:57,839
the the protocols that we parse

00:16:56,240 --> 00:17:00,160
are kind of fixed and if somebody wants

00:16:57,839 --> 00:17:03,680
to add a new protocol on the function

00:17:00,160 --> 00:17:05,039
that does mean a respand of the kernel

00:17:03,680 --> 00:17:08,000
and as i mentioned

00:17:05,039 --> 00:17:09,919
um there are go to's in it which handle

00:17:08,000 --> 00:17:12,720
the primary flow this is not the the

00:17:09,919 --> 00:17:15,600
normal use of go to handle exceptions

00:17:12,720 --> 00:17:17,120
so the flow of the code and again we

00:17:15,600 --> 00:17:20,160
cleaned it up substantially but it's

00:17:17,120 --> 00:17:23,360
still there's at least two major go-to's

00:17:20,160 --> 00:17:24,240
and it loops without an obvious for a

00:17:23,360 --> 00:17:26,799
while

00:17:24,240 --> 00:17:28,319
so in the end of the day it's uh it's an

00:17:26,799 --> 00:17:31,200
impressive function but it is rather

00:17:28,319 --> 00:17:33,679
hard to maintain an extent

00:17:31,200 --> 00:17:34,880
so the alternative and this is where bp4

00:17:33,679 --> 00:17:37,679
comes in

00:17:34,880 --> 00:17:40,000
is to kind of rethink the the whole

00:17:37,679 --> 00:17:43,760
concept of protocol parsing

00:17:40,000 --> 00:17:47,360
and if if we go back and look at

00:17:43,760 --> 00:17:49,280
the the graph it is a graph so

00:17:47,360 --> 00:17:50,880
fundamentally in computer science

00:17:49,280 --> 00:17:53,520
terminology this is walking

00:17:50,880 --> 00:17:57,760
a pars graph and we can also think of

00:17:53,520 --> 00:17:57,760
this as a type of finite state machine

00:17:57,840 --> 00:18:02,480
so transitions are in the finite state

00:18:01,200 --> 00:18:05,520
machine are based on

00:18:02,480 --> 00:18:07,039
the current header input so we need two

00:18:05,520 --> 00:18:10,080
things to determine

00:18:07,039 --> 00:18:12,080
the next protocol header we need the

00:18:10,080 --> 00:18:15,840
length of the current header

00:18:12,080 --> 00:18:18,960
and we need the next protocol

00:18:15,840 --> 00:18:20,240
number so given those two we can

00:18:18,960 --> 00:18:22,960
actually

00:18:20,240 --> 00:18:25,360
parse pretty much all of those protocols

00:18:22,960 --> 00:18:27,039
that we previously mentioned

00:18:25,360 --> 00:18:28,960
and at each layer we can extract

00:18:27,039 --> 00:18:32,320
metadata

00:18:28,960 --> 00:18:34,880
one thing that is needed is a table

00:18:32,320 --> 00:18:36,240
to look up the protocol num the next

00:18:34,880 --> 00:18:38,240
protocol number to find the next

00:18:36,240 --> 00:18:41,200
protocol node

00:18:38,240 --> 00:18:42,080
so if you take all this together the

00:18:41,200 --> 00:18:44,720
insight

00:18:42,080 --> 00:18:46,080
and this insight uh kind of preceded

00:18:44,720 --> 00:18:48,880
even p4 this was

00:18:46,080 --> 00:18:50,559
um a very nice insight based on some

00:18:48,880 --> 00:18:51,840
early work by nick mckean on protocol

00:18:50,559 --> 00:18:54,039
parsers

00:18:51,840 --> 00:18:55,360
the insight is that a declarative

00:18:54,039 --> 00:18:56,720
representation

00:18:55,360 --> 00:18:58,720
is better than an imperative

00:18:56,720 --> 00:19:01,919
representation for this

00:18:58,720 --> 00:19:05,679
uh wherein declarative is more we

00:19:01,919 --> 00:19:08,640
describe the graph

00:19:05,679 --> 00:19:09,600
in in a kind of a graphical term graph

00:19:08,640 --> 00:19:11,600
terms

00:19:09,600 --> 00:19:13,200
and imperative is we list the sequence

00:19:11,600 --> 00:19:16,400
of instructions which is exactly what

00:19:13,200 --> 00:19:19,360
skb flow dissect is doing today

00:19:16,400 --> 00:19:19,360
so if we take this

00:19:19,440 --> 00:19:22,720
concept and we apply it to to that

00:19:21,520 --> 00:19:25,440
previous graph

00:19:22,720 --> 00:19:27,360
now we can see what happens in in a

00:19:25,440 --> 00:19:29,679
single walk through this

00:19:27,360 --> 00:19:31,360
so this is the green lines here the

00:19:29,679 --> 00:19:33,200
arrows represent

00:19:31,360 --> 00:19:36,080
one protocol work so we start with an

00:19:33,200 --> 00:19:39,600
ethernet ethernet protocol

00:19:36,080 --> 00:19:42,240
is has a protocol number field

00:19:39,600 --> 00:19:43,440
and it has a length the length is 6 to

00:19:42,240 --> 00:19:45,679
14 bytes so

00:19:43,440 --> 00:19:46,559
we have those two pieces of information

00:19:45,679 --> 00:19:49,280
we take the

00:19:46,559 --> 00:19:50,000
ethernet protocol number we look it up

00:19:49,280 --> 00:19:53,960
in a table

00:19:50,000 --> 00:19:57,039
the table returned in this case ipv6

00:19:53,960 --> 00:20:00,640
806 i believe or 800.

00:19:57,039 --> 00:20:02,960
hex and then we jump to the ipv6 header

00:20:00,640 --> 00:20:05,600
it's the ipv6 header starts at the end

00:20:02,960 --> 00:20:07,840
of the ethernet header which is 14 bytes

00:20:05,600 --> 00:20:08,640
so we get an ipv6 header it's the same

00:20:07,840 --> 00:20:10,960
process

00:20:08,640 --> 00:20:12,400
we extract the next protocol from the

00:20:10,960 --> 00:20:16,000
ipv6 header

00:20:12,400 --> 00:20:17,120
we know that the ipv6 header is 20 bytes

00:20:16,000 --> 00:20:19,919
in length

00:20:17,120 --> 00:20:20,400
so we look up the next protocol in this

00:20:19,919 --> 00:20:23,679
case

00:20:20,400 --> 00:20:26,720
it is a hop i hop option

00:20:23,679 --> 00:20:27,360
or hop a help extension header so we do

00:20:26,720 --> 00:20:30,640
the lookup

00:20:27,360 --> 00:20:31,600
we go to that there is some interesting

00:20:30,640 --> 00:20:33,120
things here

00:20:31,600 --> 00:20:35,360
that i'll get to in a little bit we we

00:20:33,120 --> 00:20:37,679
do need to process the

00:20:35,360 --> 00:20:38,640
hop by hop options and those are not

00:20:37,679 --> 00:20:41,360
quite a protocol

00:20:38,640 --> 00:20:43,039
but we'll skip that for now but once we

00:20:41,360 --> 00:20:46,840
get through the

00:20:43,039 --> 00:20:48,720
hoppy hop extension header we perform

00:20:46,840 --> 00:20:51,600
another

00:20:48,720 --> 00:20:52,320
another look up on the next proto next

00:20:51,600 --> 00:20:54,880
header

00:20:52,320 --> 00:20:56,080
in the extension header we know the

00:20:54,880 --> 00:20:58,320
length of the hop by hop

00:20:56,080 --> 00:20:59,919
options there's a length field in the

00:20:58,320 --> 00:21:03,280
extension header itself

00:20:59,919 --> 00:21:04,960
and we see the next is udp same process

00:21:03,280 --> 00:21:07,120
we go through udp

00:21:04,960 --> 00:21:10,000
we do a switch on the protocol number in

00:21:07,120 --> 00:21:12,559
this case encapsulate gre udp

00:21:10,000 --> 00:21:14,880
header is eight bytes and we continue

00:21:12,559 --> 00:21:17,600
the process and then we go into gre

00:21:14,880 --> 00:21:18,480
at the end of gre we actually see that

00:21:17,600 --> 00:21:21,679
we have

00:21:18,480 --> 00:21:23,360
a encapsulate ipv4 packet

00:21:21,679 --> 00:21:25,039
so this is where the encapsulation comes

00:21:23,360 --> 00:21:28,320
back so we jump all the way back

00:21:25,039 --> 00:21:31,280
to the eth proto switch and then proceed

00:21:28,320 --> 00:21:33,919
to ipv4 and finally we get to tcp

00:21:31,280 --> 00:21:35,760
so you'll note that we went through this

00:21:33,919 --> 00:21:39,039
whole path but at every

00:21:35,760 --> 00:21:39,840
node the process was the same what's the

00:21:39,039 --> 00:21:42,640
length

00:21:39,840 --> 00:21:43,360
of the current protocol what is the next

00:21:42,640 --> 00:21:46,320
header

00:21:43,360 --> 00:21:48,799
and just those two pieces of information

00:21:46,320 --> 00:21:51,200
pretty much allow us to parse

00:21:48,799 --> 00:21:52,000
all of the possible protocols listed on

00:21:51,200 --> 00:21:54,480
this

00:21:52,000 --> 00:21:56,159
so this is kind of a way to degenerate

00:21:54,480 --> 00:21:57,280
the protocol processing into simple

00:21:56,159 --> 00:22:01,280
elements

00:21:57,280 --> 00:22:02,640
so the bp4 protocol parser is then

00:22:01,280 --> 00:22:04,880
an implementation of this and

00:22:02,640 --> 00:22:06,559
declarative representation and we'll put

00:22:04,880 --> 00:22:08,720
this in a c library

00:22:06,559 --> 00:22:10,159
so the front end to this is basically

00:22:08,720 --> 00:22:13,200
parse pdu

00:22:10,159 --> 00:22:16,400
so we take the pointer and the length

00:22:13,200 --> 00:22:17,120
a parse graph similar to what we just

00:22:16,400 --> 00:22:18,960
showed

00:22:17,120 --> 00:22:20,400
and the set of tables for the next

00:22:18,960 --> 00:22:23,039
protocol

00:22:20,400 --> 00:22:24,480
so the parse graph is composed of nodes

00:22:23,039 --> 00:22:27,200
and those nodes have

00:22:24,480 --> 00:22:28,960
are associated with c functions there's

00:22:27,200 --> 00:22:29,520
the functions for the protocol work so

00:22:28,960 --> 00:22:31,440
for each

00:22:29,520 --> 00:22:33,919
protocol node we need a next protocol

00:22:31,440 --> 00:22:35,440
function and a length of header function

00:22:33,919 --> 00:22:38,159
we can have functions to extract the

00:22:35,440 --> 00:22:40,559
metadata and we can have functions per

00:22:38,159 --> 00:22:45,039
process to do per process

00:22:40,559 --> 00:22:48,960
per layer process per layer processing

00:22:45,039 --> 00:22:51,440
so what does this look like uh here's is

00:22:48,960 --> 00:22:52,320
kind of the graphical representation of

00:22:51,440 --> 00:22:55,120
one

00:22:52,320 --> 00:22:56,640
walk through a simple tcp over ipv4

00:22:55,120 --> 00:22:59,840
packet

00:22:56,640 --> 00:23:02,400
and we develop we devise the

00:22:59,840 --> 00:23:03,760
protocol nodes into kind of two parts

00:23:02,400 --> 00:23:07,440
one is the fixed

00:23:03,760 --> 00:23:11,440
protocol node so this would apply to

00:23:07,440 --> 00:23:14,240
all cases so for instance in ethernet

00:23:11,440 --> 00:23:16,159
the length part and the next protocol

00:23:14,240 --> 00:23:18,320
are always the same they're in variant

00:23:16,159 --> 00:23:19,600
and same thing for ipv4 same thing for

00:23:18,320 --> 00:23:21,679
tcp

00:23:19,600 --> 00:23:24,559
what is different and customizable would

00:23:21,679 --> 00:23:26,720
be the metadata we extract

00:23:24,559 --> 00:23:28,320
or the functions that we run so in this

00:23:26,720 --> 00:23:31,600
case for instance

00:23:28,320 --> 00:23:32,320
the ipv4 header the length is the

00:23:31,600 --> 00:23:35,280
typical

00:23:32,320 --> 00:23:37,120
operation on the ip header length where

00:23:35,280 --> 00:23:39,840
we shift by four

00:23:37,120 --> 00:23:41,440
and the next protocol is just simply

00:23:39,840 --> 00:23:43,200
derived from the protocol field in the

00:23:41,440 --> 00:23:46,080
ipv4 header

00:23:43,200 --> 00:23:47,919
that is invariant for all of ipv4

00:23:46,080 --> 00:23:50,159
definitions

00:23:47,919 --> 00:23:52,159
what is customizable here is the

00:23:50,159 --> 00:23:53,919
metadata we're interested in

00:23:52,159 --> 00:23:56,159
so in this case for instance we're just

00:23:53,919 --> 00:23:59,200
extracting the ip

00:23:56,159 --> 00:24:00,640
addresses and the ip protocol but you

00:23:59,200 --> 00:24:03,200
can imagine this could easily be

00:24:00,640 --> 00:24:04,960
extended to get the ttl

00:24:03,200 --> 00:24:06,640
or maybe for some reason somebody wants

00:24:04,960 --> 00:24:09,919
to check some

00:24:06,640 --> 00:24:12,720
so there's a lot of variance to that

00:24:09,919 --> 00:24:16,000
the protocol table at the bottom is the

00:24:12,720 --> 00:24:19,279
ipv4 protocol table again this is

00:24:16,000 --> 00:24:20,240
more or less constant but it allows a

00:24:19,279 --> 00:24:22,799
simple lookup

00:24:20,240 --> 00:24:25,039
uh in the case of ipv4 it really is a

00:24:22,799 --> 00:24:25,919
simple lookup since there's only 256

00:24:25,039 --> 00:24:27,520
possible

00:24:25,919 --> 00:24:29,679
protocol numbers so it's reasonable to

00:24:27,520 --> 00:24:32,799
put that in a simple lookup array

00:24:29,679 --> 00:24:35,120
so for instance the ip protocol number

00:24:32,799 --> 00:24:37,039
for tcp is matched and then that

00:24:35,120 --> 00:24:38,880
immediately gives us the next node

00:24:37,039 --> 00:24:40,320
so you can imagine we can construct a

00:24:38,880 --> 00:24:42,960
full uh

00:24:40,320 --> 00:24:44,240
parser based on this sort of data

00:24:42,960 --> 00:24:46,720
structure

00:24:44,240 --> 00:24:47,760
so as i mentioned tlvs are a little more

00:24:46,720 --> 00:24:49,840
interesting

00:24:47,760 --> 00:24:51,760
and for glvs we have to consider these

00:24:49,840 --> 00:24:55,039
are sort of sub

00:24:51,760 --> 00:24:58,080
parsing so for instance once we get into

00:24:55,039 --> 00:25:00,080
a hoppy hop extension header we want to

00:24:58,080 --> 00:25:03,760
process the enclosed

00:25:00,080 --> 00:25:05,840
tlvs in the context of that being within

00:25:03,760 --> 00:25:08,159
an extension header so the extension

00:25:05,840 --> 00:25:10,799
header for instance has its own length

00:25:08,159 --> 00:25:11,840
and the tlvs within that extension

00:25:10,799 --> 00:25:14,640
header cannot

00:25:11,840 --> 00:25:16,240
exceed the the length so at each level

00:25:14,640 --> 00:25:18,320
we have to check

00:25:16,240 --> 00:25:19,760
if the tlv that we're looking at is

00:25:18,320 --> 00:25:20,640
beyond the length of the extension

00:25:19,760 --> 00:25:23,120
header

00:25:20,640 --> 00:25:24,400
but similarly we would have a tlv

00:25:23,120 --> 00:25:26,080
protocol node

00:25:24,400 --> 00:25:27,679
in the case of tlvs they're slightly

00:25:26,080 --> 00:25:28,799
different they don't have so much next

00:25:27,679 --> 00:25:30,320
protocol they're actually

00:25:28,799 --> 00:25:33,279
self-identifying

00:25:30,320 --> 00:25:34,480
for for this one so in this case we we

00:25:33,279 --> 00:25:36,880
still have a length field

00:25:34,480 --> 00:25:37,520
to determine length of tlv but instead

00:25:36,880 --> 00:25:41,120
of next

00:25:37,520 --> 00:25:43,600
tlv we have more of a type field

00:25:41,120 --> 00:25:46,159
and then an additional convolution with

00:25:43,600 --> 00:25:49,039
tlvs we do need to know where the tlv

00:25:46,159 --> 00:25:49,039
offset is

00:25:49,279 --> 00:25:55,039
the similar to protocol processing

00:25:52,960 --> 00:25:56,159
tlvs have a table so for instance in

00:25:55,039 --> 00:25:58,960
this case we're profit

00:25:56,159 --> 00:26:01,919
processing the ipv6 jumbo frame tlv for

00:25:58,960 --> 00:26:01,919
helping help options

00:26:03,679 --> 00:26:07,919
okay so now given that let's assume that

00:26:06,159 --> 00:26:11,200
that we can implement

00:26:07,919 --> 00:26:13,200
a parsing engine and

00:26:11,200 --> 00:26:14,240
instead of this looking like skb flow

00:26:13,200 --> 00:26:17,279
dissect

00:26:14,240 --> 00:26:18,880
now it looks more like a library with a

00:26:17,279 --> 00:26:21,600
function call

00:26:18,880 --> 00:26:22,559
the function call will hide a lot of the

00:26:21,600 --> 00:26:25,120
details

00:26:22,559 --> 00:26:26,400
of the parsing so for instance the

00:26:25,120 --> 00:26:28,960
administrative

00:26:26,400 --> 00:26:30,960
checks that the length of a header

00:26:28,960 --> 00:26:33,600
exceeds the length of the packet can be

00:26:30,960 --> 00:26:35,919
removed and handled by the engine

00:26:33,600 --> 00:26:37,440
so i want to look at an actual example

00:26:35,919 --> 00:26:41,279
of what this might look at

00:26:37,440 --> 00:26:45,120
and a really good example is ovs ovs

00:26:41,279 --> 00:26:48,320
is as we know an open v switch

00:26:45,120 --> 00:26:49,919
it parses protocols for the purposes of

00:26:48,320 --> 00:26:52,240
switching on them

00:26:49,919 --> 00:26:54,080
and it does a substantial amount of

00:26:52,240 --> 00:26:56,240
pursing in fact if you look at

00:26:54,080 --> 00:26:57,679
the ovs implementations about a third of

00:26:56,240 --> 00:27:00,720
the code it's actually

00:26:57,679 --> 00:27:04,080
devoted to protocol pursing

00:27:00,720 --> 00:27:07,520
so the concept of ovs to review

00:27:04,080 --> 00:27:10,400
receive a packet from the network or vm

00:27:07,520 --> 00:27:12,799
parse it extract metadata perform some

00:27:10,400 --> 00:27:16,000
lookup operations on the metadata

00:27:12,799 --> 00:27:20,880
and execute actions based on the lookup

00:27:16,000 --> 00:27:23,279
forward to vm drop etc

00:27:20,880 --> 00:27:24,960
so we can look at actual code this is

00:27:23,279 --> 00:27:28,480
the ovs parser

00:27:24,960 --> 00:27:32,559
i believe based on ebpf

00:27:28,480 --> 00:27:36,080
so this is code by vmware and

00:27:32,559 --> 00:27:39,600
in this case we highlighted some of the

00:27:36,080 --> 00:27:42,159
various operations so anything in red is

00:27:39,600 --> 00:27:44,720
kind of the administrative checks where

00:27:42,159 --> 00:27:47,279
we check the the length of fields

00:27:44,720 --> 00:27:48,880
length of protocol headers against the

00:27:47,279 --> 00:27:52,880
length of the packet

00:27:48,880 --> 00:27:57,120
the blue is where we extract data

00:27:52,880 --> 00:27:57,120
and the green are protocol switches

00:27:58,559 --> 00:28:02,000
so we can look at the same sort of

00:28:01,120 --> 00:28:06,240
parser

00:28:02,000 --> 00:28:08,000
um in p4 so again ovs is nice because it

00:28:06,240 --> 00:28:08,799
has so many implementations of the same

00:28:08,000 --> 00:28:11,360
thing so it

00:28:08,799 --> 00:28:12,799
serves kind of as a rosetta stone of

00:28:11,360 --> 00:28:15,279
packet parsing

00:28:12,799 --> 00:28:16,240
so if we look at that excuse me look at

00:28:15,279 --> 00:28:18,720
that you can see

00:28:16,240 --> 00:28:19,360
that p4 it looks very different it

00:28:18,720 --> 00:28:22,080
defines

00:28:19,360 --> 00:28:23,760
nodes more than defining a sequence of

00:28:22,080 --> 00:28:24,799
instructions so for instance there's no

00:28:23,760 --> 00:28:27,919
ifs

00:28:24,799 --> 00:28:30,799
there's no switches uh there's no checks

00:28:27,919 --> 00:28:31,760
against links so this turns out to be

00:28:30,799 --> 00:28:34,960
very clean

00:28:31,760 --> 00:28:35,600
and economical representation so what we

00:28:34,960 --> 00:28:38,799
want though

00:28:35,600 --> 00:28:42,080
is is something that that gives us

00:28:38,799 --> 00:28:44,799
this sort of structure

00:28:42,080 --> 00:28:47,600
but we want to implement it more in in c

00:28:44,799 --> 00:28:50,640
or ebpf

00:28:47,600 --> 00:28:53,919
so in p4 they do

00:28:50,640 --> 00:28:56,720
have similar concepts

00:28:53,919 --> 00:28:59,760
so it's definitely header definition

00:28:56,720 --> 00:29:01,679
parser and switch uh metadata extraction

00:28:59,760 --> 00:29:02,960
uh in this case there was no ipv4 header

00:29:01,679 --> 00:29:03,520
length handling i'm not sure that could

00:29:02,960 --> 00:29:07,200
be

00:29:03,520 --> 00:29:08,159
taken care of also okay so now what does

00:29:07,200 --> 00:29:11,120
this look in

00:29:08,159 --> 00:29:12,880
look like in bp4 so when we do this in

00:29:11,120 --> 00:29:15,279
bp4

00:29:12,880 --> 00:29:15,919
we break down the the protocol you want

00:29:15,279 --> 00:29:19,039
to parse

00:29:15,919 --> 00:29:20,399
in to parse nodes and each of these

00:29:19,039 --> 00:29:23,600
parse nodes

00:29:20,399 --> 00:29:26,559
has the the functions that

00:29:23,600 --> 00:29:28,000
we call that are called from the engine

00:29:26,559 --> 00:29:30,080
so if you look at the bottom right hand

00:29:28,000 --> 00:29:32,559
corner

00:29:30,080 --> 00:29:35,039
what we see are the the make parse nodes

00:29:32,559 --> 00:29:37,039
so bp4 make parse node

00:29:35,039 --> 00:29:38,640
these construct the parse node out of

00:29:37,039 --> 00:29:41,600
various components

00:29:38,640 --> 00:29:42,320
on the left is kind of the static

00:29:41,600 --> 00:29:44,320
constant

00:29:42,320 --> 00:29:46,159
parsing library so these are the

00:29:44,320 --> 00:29:47,440
functions that are invariant per

00:29:46,159 --> 00:29:51,279
protocol

00:29:47,440 --> 00:29:54,640
so the first function is

00:29:51,279 --> 00:29:58,240
the next header for um

00:29:54,640 --> 00:30:01,200
ipv4 when we don't person or when we

00:29:58,240 --> 00:30:02,480
don't parse into fragments so this

00:30:01,200 --> 00:30:05,760
requires this little check

00:30:02,480 --> 00:30:08,960
to see is the ip packet of fragment

00:30:05,760 --> 00:30:12,399
if it is we stop if not we go

00:30:08,960 --> 00:30:14,159
to the next protocol so this is kind of

00:30:12,399 --> 00:30:16,480
a convolution and what i referred to

00:30:14,159 --> 00:30:18,200
before where skb flow dissect

00:30:16,480 --> 00:30:20,840
actually does allow these sort of

00:30:18,200 --> 00:30:23,600
parametrizable

00:30:20,840 --> 00:30:24,880
checks so if you look at all these

00:30:23,600 --> 00:30:27,360
functions they're pretty simple

00:30:24,880 --> 00:30:28,960
so the ipv4 length function is just

00:30:27,360 --> 00:30:30,399
extracts the ipv

00:30:28,960 --> 00:30:33,039
the header length from the protocol

00:30:30,399 --> 00:30:34,240
header and shifts it by or multiplies by

00:30:33,039 --> 00:30:36,480
four

00:30:34,240 --> 00:30:38,159
ipv6 protocol is even simpler it just

00:30:36,480 --> 00:30:42,399
takes out the next header

00:30:38,159 --> 00:30:45,440
field and the length is actually

00:30:42,399 --> 00:30:49,120
fixed i should mention uh

00:30:45,440 --> 00:30:51,919
the bp4 proto node

00:30:49,120 --> 00:30:53,360
this defines the constant part of the of

00:30:51,919 --> 00:30:55,200
the parsing

00:30:53,360 --> 00:30:56,640
so we give each of these a name so the

00:30:55,200 --> 00:30:59,360
first one is the ipv4

00:30:56,640 --> 00:30:59,360
no fragment

00:31:00,399 --> 00:31:03,760
it would also be an ipv4 fragment

00:31:02,240 --> 00:31:07,360
obviously

00:31:03,760 --> 00:31:09,919
the next one is ipv6 and then

00:31:07,360 --> 00:31:11,519
the functions that are associated with

00:31:09,919 --> 00:31:15,360
these call out functions

00:31:11,519 --> 00:31:18,000
so for ipv ipv4 there's a min length

00:31:15,360 --> 00:31:19,279
ipv4 there's a min length which

00:31:18,000 --> 00:31:20,720
specifies the minimum length of the

00:31:19,279 --> 00:31:23,760
header actually

00:31:20,720 --> 00:31:26,640
there's the length of the op

00:31:23,760 --> 00:31:28,880
the operation to get the ipv4 length

00:31:26,640 --> 00:31:32,960
there's a next protocol function

00:31:28,880 --> 00:31:34,880
ipv6 it's even simpler we don't need the

00:31:32,960 --> 00:31:37,200
length function because the length is

00:31:34,880 --> 00:31:39,679
fixed at 20 20 bytes so we just assume

00:31:37,200 --> 00:31:41,679
there it's the same as mid length

00:31:39,679 --> 00:31:43,519
so if we look at the right this is sort

00:31:41,679 --> 00:31:46,559
of the customizable parts

00:31:43,519 --> 00:31:48,080
of the parsing function

00:31:46,559 --> 00:31:50,320
so you can imagine when this is

00:31:48,080 --> 00:31:53,919
programmed the user probably would

00:31:50,320 --> 00:31:55,760
combine the constant parts from the

00:31:53,919 --> 00:31:57,039
library to parse the protocols they're

00:31:55,760 --> 00:32:00,880
interested in

00:31:57,039 --> 00:32:02,399
and then write their own code to

00:32:00,880 --> 00:32:04,000
for instance extract the metadata

00:32:02,399 --> 00:32:05,840
they're interested in

00:32:04,000 --> 00:32:07,600
so these first four or first three

00:32:05,840 --> 00:32:08,880
functions are the metadata extraction

00:32:07,600 --> 00:32:11,919
functions

00:32:08,880 --> 00:32:15,039
uh it's very similar to to what skb

00:32:11,919 --> 00:32:18,240
flow dissect would do if we just go

00:32:15,039 --> 00:32:20,320
into each node we look at the current

00:32:18,240 --> 00:32:21,360
header extract the values and place them

00:32:20,320 --> 00:32:23,519
into

00:32:21,360 --> 00:32:25,600
a metadata structure and then pass that

00:32:23,519 --> 00:32:27,840
metadata structure on

00:32:25,600 --> 00:32:28,960
so at the bottom of this is the table

00:32:27,840 --> 00:32:31,200
that we formed so

00:32:28,960 --> 00:32:34,399
for instance ethernet table is shown we

00:32:31,200 --> 00:32:37,679
support two protocols ethyp ethypv6

00:32:34,399 --> 00:32:41,519
and those correspond to the nodes

00:32:37,679 --> 00:32:44,000
which we define and the nodes include

00:32:41,519 --> 00:32:45,440
the func the customize function as well

00:32:44,000 --> 00:32:49,440
as the

00:32:45,440 --> 00:32:49,440
nodes from the constant parsers

00:32:51,600 --> 00:32:56,080
and that's all i had so i will give a

00:32:53,840 --> 00:32:59,279
little bit of update so we are

00:32:56,080 --> 00:33:00,559
implementing this the idea is basically

00:32:59,279 --> 00:33:03,679
to implement this

00:33:00,559 --> 00:33:07,440
first as uh call out an ebpf

00:33:03,679 --> 00:33:11,200
but i would like to actually modify

00:33:07,440 --> 00:33:14,640
ebpf to include an engine in itself

00:33:11,200 --> 00:33:17,840
so that we can write the

00:33:14,640 --> 00:33:18,399
uh parser and sort of this declarative

00:33:17,840 --> 00:33:21,279
structure

00:33:18,399 --> 00:33:22,799
and actually have it compiled into

00:33:21,279 --> 00:33:25,840
bytecode directly

00:33:22,799 --> 00:33:29,519
and then as part of ebpf we would invoke

00:33:25,840 --> 00:33:32,320
the that byte code to do the parsing

00:33:29,519 --> 00:33:34,399
um via parsing engine and then the

00:33:32,320 --> 00:33:35,039
output from that would be to call into

00:33:34,399 --> 00:33:37,760
other bp

00:33:35,039 --> 00:33:38,720
ebpf programs for instance if we had per

00:33:37,760 --> 00:33:42,240
layer

00:33:38,720 --> 00:33:43,679
processing so we are doing this as sort

00:33:42,240 --> 00:33:45,600
of uh

00:33:43,679 --> 00:33:47,440
starting with a user space

00:33:45,600 --> 00:33:48,640
implementation and eventually we will

00:33:47,440 --> 00:33:51,600
migrate that

00:33:48,640 --> 00:33:53,760
into the kernel and acceleration comes

00:33:51,600 --> 00:33:56,960
into play when we consider

00:33:53,760 --> 00:34:00,240
the possibility of a compiler

00:33:56,960 --> 00:34:03,279
analyzing this sort of data structure

00:34:00,240 --> 00:34:06,799
and producing an output and the value of

00:34:03,279 --> 00:34:10,079
acceleration or what facilitates it

00:34:06,799 --> 00:34:12,639
when we go with a very structured

00:34:10,079 --> 00:34:15,359
format such as this it actually looks a

00:34:12,639 --> 00:34:17,919
lot more like something like p4

00:34:15,359 --> 00:34:20,159
and the whole point of p4 in that regard

00:34:17,919 --> 00:34:23,280
was to use a structured

00:34:20,159 --> 00:34:26,399
programming language as a

00:34:23,280 --> 00:34:27,839
segue into accelerating something so

00:34:26,399 --> 00:34:29,280
it's very clear that it's it's much

00:34:27,839 --> 00:34:32,800
easier to accelerate

00:34:29,280 --> 00:34:34,320
a specific data format as opposed to

00:34:32,800 --> 00:34:36,240
trying to accelerate

00:34:34,320 --> 00:34:37,919
a bunch of a sequential list of

00:34:36,240 --> 00:34:39,760
instructions so sequential list of

00:34:37,919 --> 00:34:43,040
instructions we know are

00:34:39,760 --> 00:34:44,720
amenable to compilation in the cpu

00:34:43,040 --> 00:34:46,879
but it becomes much harder when we try

00:34:44,720 --> 00:34:50,560
to translate that into

00:34:46,879 --> 00:34:53,839
a specific hardware parser

00:34:50,560 --> 00:34:53,839
that is all i have

00:34:59,839 --> 00:35:05,280
thank you tom um so a couple of

00:35:03,440 --> 00:35:07,599
uh interesting comments but maybe i'll

00:35:05,280 --> 00:35:08,960
address the first one first there seems

00:35:07,599 --> 00:35:11,920
to be some

00:35:08,960 --> 00:35:13,200
questions around the readability of the

00:35:11,920 --> 00:35:14,960
code

00:35:13,200 --> 00:35:17,520
and my personal feeling is that's

00:35:14,960 --> 00:35:19,040
probably got to do with bandwidth on the

00:35:17,520 --> 00:35:20,480
on the delivery side not in the

00:35:19,040 --> 00:35:21,680
recording because i think i saw the

00:35:20,480 --> 00:35:24,640
original recording and it

00:35:21,680 --> 00:35:25,920
was pretty legible there um but we'll

00:35:24,640 --> 00:35:29,440
assume that everything is

00:35:25,920 --> 00:35:31,920
in the code that tom's head is there so

00:35:29,440 --> 00:35:33,760
um first let's do questions if there are

00:35:31,920 --> 00:35:36,640
questions raise your hand like i said or

00:35:33,760 --> 00:35:37,280
ask the questions in the in the chat if

00:35:36,640 --> 00:35:39,200
not

00:35:37,280 --> 00:35:42,079
i will read some of the comments or

00:35:39,200 --> 00:35:43,280
actually the comments everybody can see

00:35:42,079 --> 00:35:45,839
maybe you can start looking at the

00:35:43,280 --> 00:35:45,839
comments as well

00:35:47,839 --> 00:35:51,920
question you have mentioned in the past

00:35:50,079 --> 00:35:54,160
that bp4 should be considered a

00:35:51,920 --> 00:35:55,680
functional interface to accelerators

00:35:54,160 --> 00:35:57,359
could you say a bit more about what

00:35:55,680 --> 00:35:59,599
kinds of nix accelerators might be

00:35:57,359 --> 00:36:02,480
amenable to bp for acceleration

00:35:59,599 --> 00:36:04,079
very interesting talk by the way okay so

00:36:02,480 --> 00:36:06,079
um

00:36:04,079 --> 00:36:07,280
let me back up and and mention a couple

00:36:06,079 --> 00:36:10,400
of things that probably

00:36:07,280 --> 00:36:12,079
didn't come out um

00:36:10,400 --> 00:36:14,000
in the in the talk beforehand so i

00:36:12,079 --> 00:36:14,800
apologize for the the code it wasn't

00:36:14,000 --> 00:36:16,560
meant to be

00:36:14,800 --> 00:36:17,920
a detailed code review it was actually

00:36:16,560 --> 00:36:18,960
met just to show an overview on the

00:36:17,920 --> 00:36:20,880
complexity

00:36:18,960 --> 00:36:22,320
probably um jumped a little too much

00:36:20,880 --> 00:36:24,160
into the detail on that

00:36:22,320 --> 00:36:25,680
so one of the important things here is

00:36:24,160 --> 00:36:29,040
that

00:36:25,680 --> 00:36:32,720
we when we restructure code like this

00:36:29,040 --> 00:36:35,119
um by by default

00:36:32,720 --> 00:36:36,000
it's if we just implement that and

00:36:35,119 --> 00:36:37,599
compile it

00:36:36,000 --> 00:36:39,359
it probably wouldn't be nearly as good

00:36:37,599 --> 00:36:42,160
performance

00:36:39,359 --> 00:36:42,480
of either an accelerated version or even

00:36:42,160 --> 00:36:44,720
a

00:36:42,480 --> 00:36:45,920
flow detector code so one of the

00:36:44,720 --> 00:36:47,119
important things here is

00:36:45,920 --> 00:36:49,119
and i've mentioned this in other

00:36:47,119 --> 00:36:52,000
contexts

00:36:49,119 --> 00:36:53,280
once we have a structured program

00:36:52,000 --> 00:36:55,200
designed

00:36:53,280 --> 00:36:57,040
then conceptually we should be able to

00:36:55,200 --> 00:36:58,160
have a compiler actually understand that

00:36:57,040 --> 00:36:59,760
structure

00:36:58,160 --> 00:37:01,280
and the compiler should be able to do

00:36:59,760 --> 00:37:03,839
all the optimizations

00:37:01,280 --> 00:37:06,079
and in this case would basically unroll

00:37:03,839 --> 00:37:08,880
the the parse graph so

00:37:06,079 --> 00:37:10,000
for instance my expectation is that we

00:37:08,880 --> 00:37:11,440
should be able to take something like

00:37:10,000 --> 00:37:14,240
llvm

00:37:11,440 --> 00:37:15,839
input this pars graph program and the

00:37:14,240 --> 00:37:19,040
output should be

00:37:15,839 --> 00:37:20,400
uh equivalent uh instructions

00:37:19,040 --> 00:37:22,400
uh to what we would get with flow

00:37:20,400 --> 00:37:23,839
dissector some expectation is that at

00:37:22,400 --> 00:37:24,880
the end of the day performance should

00:37:23,839 --> 00:37:27,200
actually be

00:37:24,880 --> 00:37:29,680
equivalent to organic florida sector now

00:37:27,200 --> 00:37:32,480
acceleration comes from the fact that

00:37:29,680 --> 00:37:34,720
since we are having a very restricted

00:37:32,480 --> 00:37:34,720
and

00:37:34,880 --> 00:37:41,440
kind of clear data structure

00:37:38,000 --> 00:37:43,440
and program structure uh it should be

00:37:41,440 --> 00:37:45,839
immutable to acceleration and this is

00:37:43,440 --> 00:37:47,359
similar to how with evpf we have

00:37:45,839 --> 00:37:49,839
restricted c

00:37:47,359 --> 00:37:51,520
but to accelerate this it's even a

00:37:49,839 --> 00:37:54,079
little more restrictive

00:37:51,520 --> 00:37:56,160
so for instance the lane function that i

00:37:54,079 --> 00:37:58,160
mentioned several times

00:37:56,160 --> 00:37:59,839
the way protocols determine length are

00:37:58,160 --> 00:38:03,040
almost always

00:37:59,839 --> 00:38:04,000
fixed and easily converted to a hardware

00:38:03,040 --> 00:38:06,160
function

00:38:04,000 --> 00:38:07,440
uh in in obvious cases it's fixed length

00:38:06,160 --> 00:38:10,240
there's no issue but in

00:38:07,440 --> 00:38:11,760
cases where like the ip header it's a

00:38:10,240 --> 00:38:14,000
fixed function of shifts

00:38:11,760 --> 00:38:16,079
and maybe ads so those are the things

00:38:14,000 --> 00:38:19,760
that you wanted to get in the hardware

00:38:16,079 --> 00:38:20,320
so the hardware itself in in one sense

00:38:19,760 --> 00:38:23,680
we could

00:38:20,320 --> 00:38:26,880
say that that p4 is going that direction

00:38:23,680 --> 00:38:29,440
where uh we can convert to a

00:38:26,880 --> 00:38:31,119
parse parsing language or personal

00:38:29,440 --> 00:38:34,480
representation into

00:38:31,119 --> 00:38:36,800
a hardware abstraction uh also

00:38:34,480 --> 00:38:38,079
one could say that the the work that

00:38:36,800 --> 00:38:40,720
metronome had done

00:38:38,079 --> 00:38:42,640
uh to down to offload ebpf would have

00:38:40,720 --> 00:38:46,160
been along the same lines

00:38:42,640 --> 00:38:48,960
uh ebpf however itself is

00:38:46,160 --> 00:38:51,359
just uh imperative language what we want

00:38:48,960 --> 00:38:53,200
to do here is actually

00:38:51,359 --> 00:38:55,040
a little more so declarative part of

00:38:53,200 --> 00:38:56,720
this is actually the structure and we

00:38:55,040 --> 00:38:59,599
can build hardware around that

00:38:56,720 --> 00:39:01,200
so what i envision is that this is

00:38:59,599 --> 00:39:03,440
starting as a library

00:39:01,200 --> 00:39:04,480
um and i'll be posting the code shortly

00:39:03,440 --> 00:39:05,839
on that so we'll start with the user

00:39:04,480 --> 00:39:08,320
space library

00:39:05,839 --> 00:39:09,359
uh implement this in ebpf as kind of a

00:39:08,320 --> 00:39:11,599
library

00:39:09,359 --> 00:39:12,720
and then implement it as hardware as a

00:39:11,599 --> 00:39:14,880
function and

00:39:12,720 --> 00:39:16,960
then the compiler will uh do all the

00:39:14,880 --> 00:39:19,359
work to translate into the specific

00:39:16,960 --> 00:39:19,359
hardware

00:39:19,599 --> 00:39:23,760
um we are running that kind of answers

00:39:22,079 --> 00:39:25,520
or's question too i believe

00:39:23,760 --> 00:39:27,200
yeah that was my point i think we're

00:39:25,520 --> 00:39:29,280
running a little uh

00:39:27,200 --> 00:39:31,119
low on time sir or does that address

00:39:29,280 --> 00:39:34,800
your question or would you rather

00:39:31,119 --> 00:39:34,800
would you need something more clarified

00:39:35,920 --> 00:39:39,200
uh so i think we're we're good on that

00:39:37,920 --> 00:39:42,640
um

00:39:39,200 --> 00:39:45,040
i i i also didn't mention um

00:39:42,640 --> 00:39:46,960
the status of this so there is some code

00:39:45,040 --> 00:39:49,599
that i hope to post shortly

00:39:46,960 --> 00:39:51,599
on this that implements the the library

00:39:49,599 --> 00:39:53,680
and this project really is in three

00:39:51,599 --> 00:39:56,320
phases so first phase is to define

00:39:53,680 --> 00:39:57,599
the the protocol format the critical

00:39:56,320 --> 00:39:59,760
representation

00:39:57,599 --> 00:40:01,359
um any potential language extensions we

00:39:59,760 --> 00:40:02,240
need although i'm not sure we have to

00:40:01,359 --> 00:40:04,800
extend and see

00:40:02,240 --> 00:40:06,480
for this so phase one is uh how to do

00:40:04,800 --> 00:40:08,480
this in software library

00:40:06,480 --> 00:40:10,960
phase two is the compiler extension so

00:40:08,480 --> 00:40:12,800
as i mentioned how do we optimize

00:40:10,960 --> 00:40:14,000
uh this sort of code through the

00:40:12,800 --> 00:40:17,280
compiler

00:40:14,000 --> 00:40:18,240
to produce a reasonable executed

00:40:17,280 --> 00:40:20,880
environment

00:40:18,240 --> 00:40:22,640
and then phase three is uh how to

00:40:20,880 --> 00:40:24,480
hardware offload

00:40:22,640 --> 00:40:25,760
to jesse's answer unfortunately i didn't

00:40:24,480 --> 00:40:28,480
expect the uh

00:40:25,760 --> 00:40:30,000
presentation was so long um i should

00:40:28,480 --> 00:40:31,440
mention this was the first one that we

00:40:30,000 --> 00:40:34,800
recorded so

00:40:31,440 --> 00:40:37,119
uh it was kind of practice but um

00:40:34,800 --> 00:40:38,160
we can do as jamel says we can certainly

00:40:37,119 --> 00:40:40,160
talk more about this

00:40:38,160 --> 00:40:43,839
uh during happy hour and whatever

00:40:40,160 --> 00:40:47,839
hallway conversations we can generate

00:40:43,839 --> 00:40:50,000
um so i tom i had one

00:40:47,839 --> 00:40:51,599
one comment i wanted to not comment one

00:40:50,000 --> 00:40:53,280
point i wanted to make so i guess this

00:40:51,599 --> 00:40:55,520
is really an extension for

00:40:53,280 --> 00:40:56,560
people working on b4 and people working

00:40:55,520 --> 00:40:59,280
on evpf

00:40:56,560 --> 00:40:59,920
on a hardware download but so that's

00:40:59,280 --> 00:41:02,160
probably

00:40:59,920 --> 00:41:03,440
the the confluence of groups that we

00:41:02,160 --> 00:41:04,720
want to see

00:41:03,440 --> 00:41:06,319
contributing to this and paying

00:41:04,720 --> 00:41:07,359
attention to this right because all of

00:41:06,319 --> 00:41:10,480
the questions

00:41:07,359 --> 00:41:12,880
have a flip response which is um

00:41:10,480 --> 00:41:13,599
if bp4 is the way in which you're going

00:41:12,880 --> 00:41:16,720
to do this

00:41:13,599 --> 00:41:18,720
slightly more flexible than b4 slightly

00:41:16,720 --> 00:41:19,280
more declarative and more restricted

00:41:18,720 --> 00:41:22,560
than

00:41:19,280 --> 00:41:24,720
pure evpf but amenable to hardware

00:41:22,560 --> 00:41:26,800
download or hardware offload

00:41:24,720 --> 00:41:29,040
those communities need to sort of arrive

00:41:26,800 --> 00:41:31,520
at some confluence right

00:41:29,040 --> 00:41:32,160
so i did present this to the p4 folks

00:41:31,520 --> 00:41:35,200
and

00:41:32,160 --> 00:41:37,520
um they seemed interested uh

00:41:35,200 --> 00:41:38,960
the name actually the name kind of is

00:41:37,520 --> 00:41:40,560
morphing and i'm not sure this will be

00:41:38,960 --> 00:41:41,440
the final name but it did reflect the

00:41:40,560 --> 00:41:43,440
fact that

00:41:41,440 --> 00:41:45,280
we're trying to take elements of ebpf

00:41:43,440 --> 00:41:48,319
and elements of p4

00:41:45,280 --> 00:41:49,920
uh combine the best of both of them

00:41:48,319 --> 00:41:52,400
but i do think it's going to arrive to

00:41:49,920 --> 00:41:54,079
be a little more than that and

00:41:52,400 --> 00:41:55,839
it will be applied i think to both of

00:41:54,079 --> 00:41:58,400
these cases uh

00:41:55,839 --> 00:42:00,000
it's definitely something that is we

00:41:58,400 --> 00:42:01,599
want to be generic so this should work

00:42:00,000 --> 00:42:02,720
in dpdk i think there's an interesting

00:42:01,599 --> 00:42:05,680
comment

00:42:02,720 --> 00:42:06,800
uh that vpp has something similar so i

00:42:05,680 --> 00:42:09,280
definitely want to be

00:42:06,800 --> 00:42:11,040
in that environment ebpf i think is a as

00:42:09,280 --> 00:42:12,960
a target as i mentioned

00:42:11,040 --> 00:42:14,480
uh hardware acceleration but also just

00:42:12,960 --> 00:42:17,839
as a plain c library which would

00:42:14,480 --> 00:42:17,839
probably be the first instantiation

00:42:17,920 --> 00:42:21,440
okay well i guess we'll move on but uh

00:42:20,079 --> 00:42:24,400
thank you

00:42:21,440 --> 00:42:24,400

YouTube URL: https://www.youtube.com/watch?v=SOOuo5hpCPo


