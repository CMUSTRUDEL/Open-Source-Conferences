Title: Netdev 0x14 - Using Upstream MPTCP in Linux Systems
Publication date: 2020-10-09
Playlist: Netdev 0x14
Description: 
	Speakers: Mat Martineau, Ossama Othman

More info: https://netdevconf.info/0x14/session.html?talk-using-upstream-MPTCP-in-linux-systems

Date: Friday, August 21, 2020

The Multipath TCP community started its engagement with netdev conf
0.1 (https://netdevconf.info/0.1/sessions/16.html) and have shown
up to multiple other netdev confs after to solicit for feedback and
report progress. After all that hard work MPTCP has finally been merged!

In this talk Mat Martineau will provide advice to developers, ops
and distros how to make good use of the upstreamed MPTCP.

Mat will discuss kernel considerations, report on upstream merge
progress to date, and introduce the Multipath TCP Daemon(mptcpd) to
the Linux networking community.
Captions: 
	00:00:02,639 --> 00:00:06,000
hi everyone

00:00:03,439 --> 00:00:08,880
i'm matt martino presenting uh using

00:00:06,000 --> 00:00:11,599
upstream mptcp in linux systems uh i

00:00:08,880 --> 00:00:12,960
co-authored this with osama othman also

00:00:11,599 --> 00:00:17,920
and intel

00:00:12,960 --> 00:00:17,920
and uh let's begin

00:00:18,160 --> 00:00:22,000
um so to start with uh when i originally

00:00:20,800 --> 00:00:25,199
proposed this talk

00:00:22,000 --> 00:00:25,840
uh we didn't have nbtcp upstream yet and

00:00:25,199 --> 00:00:29,599
now

00:00:25,840 --> 00:00:31,920
um six months later we we do um

00:00:29,599 --> 00:00:33,120
over 150 commits have been merged this

00:00:31,920 --> 00:00:36,320
year

00:00:33,120 --> 00:00:37,760
um and at this point um by the

00:00:36,320 --> 00:00:40,719
time you're viewing this we'll have

00:00:37,760 --> 00:00:42,719
linux 5.8 available with multi-path tcp

00:00:40,719 --> 00:00:45,840
features including

00:00:42,719 --> 00:00:49,680
uh multipath tcp v1

00:00:45,840 --> 00:00:51,920
the ability to create multiple subflows

00:00:49,680 --> 00:00:54,399
the ability to manage those sub flows

00:00:51,920 --> 00:00:57,760
with some in kernel functionality

00:00:54,399 --> 00:00:58,239
and viewing the status of connections

00:00:57,760 --> 00:01:01,760
with

00:00:58,239 --> 00:01:04,400
the ss command via diac

00:01:01,760 --> 00:01:06,960
and i also want to point out while while

00:01:04,400 --> 00:01:09,600
osama and myself are from intel

00:01:06,960 --> 00:01:11,920
and in this presentation the the

00:01:09,600 --> 00:01:13,119
upstream effort has very much been a

00:01:11,920 --> 00:01:15,680
collaboration

00:01:13,119 --> 00:01:16,640
um you know there's more more non-intel

00:01:15,680 --> 00:01:18,799
people involved than

00:01:16,640 --> 00:01:20,240
intel people so i want to definitely

00:01:18,799 --> 00:01:22,960
give credit to

00:01:20,240 --> 00:01:23,759
uh our fellow community contributors

00:01:22,960 --> 00:01:27,119
from red hat

00:01:23,759 --> 00:01:31,600
tesseras and apple um

00:01:27,119 --> 00:01:34,240
and even uh growing community today more

00:01:31,600 --> 00:01:35,520
more people becoming involved and if

00:01:34,240 --> 00:01:37,600
you're interested in looking at our

00:01:35,520 --> 00:01:40,240
github project here's the url with the

00:01:37,600 --> 00:01:42,640
shortcut to that

00:01:40,240 --> 00:01:44,960
and i'll have more more resources linked

00:01:42,640 --> 00:01:44,960
later

00:01:45,040 --> 00:01:50,560
so um just to give a quick framing for

00:01:48,079 --> 00:01:53,280
what is multi-path tcp

00:01:50,560 --> 00:01:54,000
some of our previous talks have gone

00:01:53,280 --> 00:01:57,119
into more detail

00:01:54,000 --> 00:01:58,320
on this but um just wanted to give a

00:01:57,119 --> 00:02:00,159
quick view

00:01:58,320 --> 00:02:02,079
in this example is a use case where

00:02:00,159 --> 00:02:03,280
we've got a mobile device talking to a

00:02:02,079 --> 00:02:06,079
server

00:02:03,280 --> 00:02:08,160
and the mobile device has multiple

00:02:06,079 --> 00:02:09,360
network interfaces one wi-fi one

00:02:08,160 --> 00:02:12,480
cellular

00:02:09,360 --> 00:02:13,440
and it's talking to a server with a

00:02:12,480 --> 00:02:16,959
public

00:02:13,440 --> 00:02:17,760
ipv6 address and so the mobile device

00:02:16,959 --> 00:02:21,040
has

00:02:17,760 --> 00:02:24,319
made it made a connection created two

00:02:21,040 --> 00:02:27,440
tcp subflows which are to the network

00:02:24,319 --> 00:02:28,560
look like separate tcp streams the

00:02:27,440 --> 00:02:32,640
application is just

00:02:28,560 --> 00:02:35,440
open one socket it sends a b c d

00:02:32,640 --> 00:02:37,360
and mbtcp in the kernel decided which

00:02:35,440 --> 00:02:40,879
interfaces to send

00:02:37,360 --> 00:02:43,599
each uh packet over so

00:02:40,879 --> 00:02:44,640
for example here on subfloor one it's

00:02:43,599 --> 00:02:46,959
sent a b and d

00:02:44,640 --> 00:02:48,959
and subflow two is sent b and d and then

00:02:46,959 --> 00:02:52,239
on the receiver side

00:02:48,959 --> 00:02:55,760
it's uh uses sequence number information

00:02:52,239 --> 00:02:58,640
um at a layer above tcp to

00:02:55,760 --> 00:02:59,920
reassemble the stream to present on the

00:02:58,640 --> 00:03:04,319
streaming socket

00:02:59,920 --> 00:03:08,080
on the service so

00:03:04,319 --> 00:03:10,000
um it is a protocol multipath tcp is a

00:03:08,080 --> 00:03:12,800
protocol that is

00:03:10,000 --> 00:03:14,239
both kind of layered above tcp and also

00:03:12,800 --> 00:03:17,440
intermingled with it

00:03:14,239 --> 00:03:18,159
um and so it's not a completely clean

00:03:17,440 --> 00:03:21,200
separation

00:03:18,159 --> 00:03:22,879
but um it's it's a lot of aspects of it

00:03:21,200 --> 00:03:26,000
you can think of it that way

00:03:22,879 --> 00:03:27,040
um when it when a multi-path tcp

00:03:26,000 --> 00:03:28,959
connection begins

00:03:27,040 --> 00:03:30,560
it looks a lot like a normal tcp

00:03:28,959 --> 00:03:32,799
connection you've got your

00:03:30,560 --> 00:03:34,000
you know sim synack acknowledgement

00:03:32,799 --> 00:03:36,319
handshakes

00:03:34,000 --> 00:03:37,280
but there are additional there's an

00:03:36,319 --> 00:03:39,760
additional tcp

00:03:37,280 --> 00:03:41,200
option sort of uh along for the ride on

00:03:39,760 --> 00:03:44,480
that handshake that also

00:03:41,200 --> 00:03:47,680
is um allowing each peer

00:03:44,480 --> 00:03:48,879
to consider that connection multipath

00:03:47,680 --> 00:03:52,000
tcp

00:03:48,879 --> 00:03:55,840
and add the ability to

00:03:52,000 --> 00:04:00,319
to have new subflows later

00:03:55,840 --> 00:04:01,760
and that's called joining when more tcp

00:04:00,319 --> 00:04:03,680
connections are created inside the

00:04:01,760 --> 00:04:07,680
kernel and

00:04:03,680 --> 00:04:11,840
added to the parallel streams

00:04:07,680 --> 00:04:14,239
so um when appear ascending

00:04:11,840 --> 00:04:17,280
it can send data on one or more subflows

00:04:14,239 --> 00:04:19,120
the receiver will discard the duplicates

00:04:17,280 --> 00:04:20,799
if you were say watching one of these

00:04:19,120 --> 00:04:24,400
subflow streams in

00:04:20,799 --> 00:04:27,280
you know wireshark or tcp dump or

00:04:24,400 --> 00:04:28,720
or you know watching the connection in

00:04:27,280 --> 00:04:31,600
the middle over the network

00:04:28,720 --> 00:04:32,960
the subflow streams may actually contain

00:04:31,600 --> 00:04:34,400
data that looks out of order or

00:04:32,960 --> 00:04:38,080
redundant

00:04:34,400 --> 00:04:38,720
but multipath tcp sorts that all out

00:04:38,080 --> 00:04:41,840
before

00:04:38,720 --> 00:04:45,520
presenting the stream to the

00:04:41,840 --> 00:04:48,639
client that put it to the application

00:04:45,520 --> 00:04:50,320
so multi-path tcp does this while the

00:04:48,639 --> 00:04:52,400
connection is active

00:04:50,320 --> 00:04:53,600
also with tcp options those carry an

00:04:52,400 --> 00:04:57,199
additional layer of

00:04:53,600 --> 00:04:58,960
sequence numbers um to reassemble data

00:04:57,199 --> 00:05:02,240
packets later

00:04:58,960 --> 00:05:04,639
and also acknowledge that

00:05:02,240 --> 00:05:06,080
things have been reassembled at the

00:05:04,639 --> 00:05:06,720
level so that they don't need to be

00:05:06,080 --> 00:05:11,840
reset

00:05:06,720 --> 00:05:14,400
by the sender

00:05:11,840 --> 00:05:15,919
so what's this useful for um there's

00:05:14,400 --> 00:05:18,960
kind of three categories

00:05:15,919 --> 00:05:21,360
one is steering where the sender can

00:05:18,960 --> 00:05:22,960
use information it has about what the

00:05:21,360 --> 00:05:25,759
best network is

00:05:22,960 --> 00:05:27,680
best meaning maybe in some cases lowest

00:05:25,759 --> 00:05:29,039
latency best in some cases meaning

00:05:27,680 --> 00:05:32,400
higher bandwidth

00:05:29,039 --> 00:05:36,320
and so it can it can push data over

00:05:32,400 --> 00:05:36,320
the link that that works best for it

00:05:37,280 --> 00:05:41,919
the switching case where you know for

00:05:40,320 --> 00:05:45,759
example you have both a mobile and a

00:05:41,919 --> 00:05:45,759
wi-fi interface where you might want to

00:05:46,320 --> 00:05:52,000
fall back to using cellular as you

00:05:49,360 --> 00:05:53,919
leave range of a wi-fi network and

00:05:52,000 --> 00:05:56,000
multi-path tcp can handle this

00:05:53,919 --> 00:05:58,400
failover pretty seamlessly without the

00:05:56,000 --> 00:06:01,919
application having to change things

00:05:58,400 --> 00:06:04,840
and also splitting so the ability to

00:06:01,919 --> 00:06:06,080
combine the bandwidth of multiple

00:06:04,840 --> 00:06:07,919
interfaces

00:06:06,080 --> 00:06:10,000
such as like a hybrid access use case

00:06:07,919 --> 00:06:13,759
where it could send over both

00:06:10,000 --> 00:06:16,400
lte and dsl at the same time

00:06:13,759 --> 00:06:18,840
um you know one always on one for for

00:06:16,400 --> 00:06:22,800
peak bandwidth

00:06:18,840 --> 00:06:25,919
and multipat tcp has been

00:06:22,800 --> 00:06:29,039
selected for use in the 5g atss

00:06:25,919 --> 00:06:29,600
standard for access traffic steering

00:06:29,039 --> 00:06:31,360
switching

00:06:29,600 --> 00:06:33,759
and splitting to to handle these various

00:06:31,360 --> 00:06:36,800
use cases

00:06:33,759 --> 00:06:39,199
you know be used by cellular provider

00:06:36,800 --> 00:06:41,440
policy carrier policy and things like

00:06:39,199 --> 00:06:41,440
that

00:06:44,080 --> 00:06:48,479
so in some ways multi-path tcp has been

00:06:47,600 --> 00:06:50,960
around a while

00:06:48,479 --> 00:06:53,919
the initial experimental rfc was was

00:06:50,960 --> 00:06:57,599
published in 2013

00:06:53,919 --> 00:07:01,199
after several year drafting process

00:06:57,599 --> 00:07:03,440
if you see multi-path gcp used in most

00:07:01,199 --> 00:07:04,479
existing deployments today it is an

00:07:03,440 --> 00:07:08,400
implementation of this

00:07:04,479 --> 00:07:12,319
this older rfc uh in march this year

00:07:08,400 --> 00:07:14,840
the the v1 the standards track rfc 8684

00:07:12,319 --> 00:07:17,759
was published

00:07:14,840 --> 00:07:21,440
and um that is the version

00:07:17,759 --> 00:07:25,360
that has been included in upstream linux

00:07:21,440 --> 00:07:28,400
um the specification was developed to

00:07:25,360 --> 00:07:30,319
to fix some of the issues seen in the

00:07:28,400 --> 00:07:32,960
version zero spec

00:07:30,319 --> 00:07:34,720
and um they they aren't reverse

00:07:32,960 --> 00:07:37,919
compatible

00:07:34,720 --> 00:07:41,039
but uh that doesn't

00:07:37,919 --> 00:07:42,840
doesn't mean you you still have options

00:07:41,039 --> 00:07:45,840
for uh

00:07:42,840 --> 00:07:48,800
interoperation if you have a stack that

00:07:45,840 --> 00:07:51,520
supports both on one side

00:07:48,800 --> 00:07:54,080
so um this this incompatibility is due

00:07:51,520 --> 00:07:58,000
to changes in the connection handshake

00:07:54,080 --> 00:08:01,039
um so the newer one better supports tcp

00:07:58,000 --> 00:08:01,520
fast open but his flag is a different

00:08:01,039 --> 00:08:05,599
version

00:08:01,520 --> 00:08:07,919
so if you have a say a v1

00:08:05,599 --> 00:08:09,840
pier initiating a connection to one that

00:08:07,919 --> 00:08:12,160
only supports v0

00:08:09,840 --> 00:08:13,759
the v01 will see that it's not a

00:08:12,160 --> 00:08:16,879
compatible version and you'll just get a

00:08:13,759 --> 00:08:20,160
regular tcp connection

00:08:16,879 --> 00:08:21,440
now it is also possible for

00:08:20,160 --> 00:08:23,120
say a device that supports both

00:08:21,440 --> 00:08:23,680
standards to see oh they didn't support

00:08:23,120 --> 00:08:25,919
v1

00:08:23,680 --> 00:08:28,000
i can retry with v0 but that would be a

00:08:25,919 --> 00:08:31,440
whole separate handshake

00:08:28,000 --> 00:08:32,240
so the the fallback is a separate um tcp

00:08:31,440 --> 00:08:35,200
connection

00:08:32,240 --> 00:08:37,120
not it isn't able to switch multipath

00:08:35,200 --> 00:08:40,479
tcp versions

00:08:37,120 --> 00:08:40,479
during one connection

00:08:40,719 --> 00:08:44,159
the newer multi-path the v1 spec does

00:08:43,440 --> 00:08:47,279
use

00:08:44,159 --> 00:08:51,519
sha-256 and

00:08:47,279 --> 00:08:54,959
has some more features for reliable

00:08:51,519 --> 00:08:58,880
sharing of ip address information and

00:08:54,959 --> 00:09:03,279
um is available is able to do a

00:08:58,880 --> 00:09:03,279
faster close with tcp reset

00:09:04,959 --> 00:09:10,160
so the um

00:09:08,240 --> 00:09:12,240
evolution of multipath tcp in the

00:09:10,160 --> 00:09:15,440
upstream kernel as i said we've

00:09:12,240 --> 00:09:16,880
been active with this throughout 2020 so

00:09:15,440 --> 00:09:20,000
far

00:09:16,880 --> 00:09:22,320
the the first multipath tcp

00:09:20,000 --> 00:09:24,160
current linux kernel version was 5.6 but

00:09:22,320 --> 00:09:27,440
it only supported

00:09:24,160 --> 00:09:30,560
a a single multi-path

00:09:27,440 --> 00:09:32,640
well a single sub flow

00:09:30,560 --> 00:09:34,240
so it didn't actually have the the

00:09:32,640 --> 00:09:37,519
multiple in the

00:09:34,240 --> 00:09:38,160
in the multi-path um yet it was just at

00:09:37,519 --> 00:09:39,920
a

00:09:38,160 --> 00:09:41,600
released at a phase in the upstreaming

00:09:39,920 --> 00:09:42,240
where some of the foundational parts

00:09:41,600 --> 00:09:44,959
were there

00:09:42,240 --> 00:09:46,320
but not full functionality so 5.7 is

00:09:44,959 --> 00:09:48,399
where we did add

00:09:46,320 --> 00:09:50,560
the ability to create multiple subflows

00:09:48,399 --> 00:09:52,640
and control

00:09:50,560 --> 00:09:55,040
to some degree when those are are

00:09:52,640 --> 00:09:58,800
created and accepted and also

00:09:55,040 --> 00:10:00,880
the ability to use the ss command to

00:09:58,800 --> 00:10:02,320
find out the status of those multiple

00:10:00,880 --> 00:10:04,959
subflows

00:10:02,320 --> 00:10:07,120
and then uh as i record this the

00:10:04,959 --> 00:10:07,519
upcoming release of 5.8 which should be

00:10:07,120 --> 00:10:10,720
out

00:10:07,519 --> 00:10:12,880
by the time the conference happens um

00:10:10,720 --> 00:10:14,000
that will improve uh performance and

00:10:12,880 --> 00:10:17,279
reliability

00:10:14,000 --> 00:10:20,720
of multiple subflows and uh

00:10:17,279 --> 00:10:23,839
and through things like better

00:10:20,720 --> 00:10:27,120
receive window um handling at the

00:10:23,839 --> 00:10:27,120
multi-path tcp level

00:10:27,279 --> 00:10:32,560
so one um

00:10:30,560 --> 00:10:34,800
one thing about upstreaming multipath

00:10:32,560 --> 00:10:39,040
tcps is it's

00:10:34,800 --> 00:10:40,560
been a a long road um and

00:10:39,040 --> 00:10:42,959
uh we think we've learned some things

00:10:40,560 --> 00:10:46,399
that might be helpful to other projects

00:10:42,959 --> 00:10:49,279
um they might be able to learn um

00:10:46,399 --> 00:10:50,720
so what would be a similar project um in

00:10:49,279 --> 00:10:52,320
this context

00:10:50,720 --> 00:10:55,279
um you've got significant new

00:10:52,320 --> 00:10:57,519
functionality that that

00:10:55,279 --> 00:10:58,959
doesn't have a home in the staging tree

00:10:57,519 --> 00:11:02,000
um

00:10:58,959 --> 00:11:05,040
you've got both

00:11:02,000 --> 00:11:06,560
close coupling with existing you know

00:11:05,040 --> 00:11:08,160
critical kernel functionality like in

00:11:06,560 --> 00:11:09,760
our case the tcp stack

00:11:08,160 --> 00:11:11,440
that we we very much did not want to

00:11:09,760 --> 00:11:14,800
break and

00:11:11,440 --> 00:11:16,079
um also possibly modifying that existing

00:11:14,800 --> 00:11:18,720
kernel subsystem

00:11:16,079 --> 00:11:20,560
and and you've got a team that's

00:11:18,720 --> 00:11:25,360
distributed across different

00:11:20,560 --> 00:11:25,360
organizations different companies and

00:11:25,600 --> 00:11:30,240
you know this this is kind of the scope

00:11:27,360 --> 00:11:34,240
of a project that

00:11:30,240 --> 00:11:37,360
might match up with what mptcp did

00:11:34,240 --> 00:11:38,880
um kind of one of the main things we

00:11:37,360 --> 00:11:41,120
had to consider in something like this

00:11:38,880 --> 00:11:42,959
is that there's this kind of paradox of

00:11:41,120 --> 00:11:46,320
the maintainers needing to

00:11:42,959 --> 00:11:49,519
have reviewable pieces of functionality

00:11:46,320 --> 00:11:50,240
so you know you have to send something

00:11:49,519 --> 00:11:53,200
initially

00:11:50,240 --> 00:11:55,360
but you don't necessarily know what the

00:11:53,200 --> 00:11:56,240
early foundational pieces are until you

00:11:55,360 --> 00:11:59,279
build

00:11:56,240 --> 00:12:03,040
a lot of what you're trying to do

00:11:59,279 --> 00:12:04,320
um so you kind of have to try to balance

00:12:03,040 --> 00:12:07,279
the

00:12:04,320 --> 00:12:07,519
initial patch set contents with with you

00:12:07,279 --> 00:12:09,600
know

00:12:07,519 --> 00:12:10,639
the investment in the work up front

00:12:09,600 --> 00:12:13,279
because you might

00:12:10,639 --> 00:12:14,560
get feedback that'll sort of cascade

00:12:13,279 --> 00:12:18,480
through

00:12:14,560 --> 00:12:21,120
the addition the the rest of the project

00:12:18,480 --> 00:12:24,240
so some things we learned to to maybe

00:12:21,120 --> 00:12:27,680
try to steer away from

00:12:24,240 --> 00:12:28,959
we did try uh an initial approach of

00:12:27,680 --> 00:12:31,200
saying okay well

00:12:28,959 --> 00:12:32,000
to make multi-path tcp work well we

00:12:31,200 --> 00:12:35,760
might

00:12:32,000 --> 00:12:38,000
want to um add some more generic

00:12:35,760 --> 00:12:40,720
capabilities to the tcp stack

00:12:38,000 --> 00:12:42,480
in our case a tcp options framework to

00:12:40,720 --> 00:12:45,040
add

00:12:42,480 --> 00:12:46,240
different tcp options that weren't hard

00:12:45,040 --> 00:12:49,600
coded into the

00:12:46,240 --> 00:12:50,240
option handling so we we identified some

00:12:49,600 --> 00:12:53,839
kind of

00:12:50,240 --> 00:12:57,279
common use cases with md5 and

00:12:53,839 --> 00:13:00,560
tcp md5 and tried to add

00:12:57,279 --> 00:13:03,040
add that and uh it was it was rejected

00:13:00,560 --> 00:13:03,600
um but the feedback we got from it was

00:13:03,040 --> 00:13:06,240
good and

00:13:03,600 --> 00:13:07,839
and and the advice there was to you know

00:13:06,240 --> 00:13:10,800
go ahead and build what we needed for

00:13:07,839 --> 00:13:12,079
multibat tcp and then you know if we

00:13:10,800 --> 00:13:13,920
identified

00:13:12,079 --> 00:13:15,680
an opportunity that you know a framework

00:13:13,920 --> 00:13:17,279
would make things cleaner later then

00:13:15,680 --> 00:13:18,720
maybe the later would be the right time

00:13:17,279 --> 00:13:21,200
to work on that

00:13:18,720 --> 00:13:22,560
um you don't want to spend a lot of time

00:13:21,200 --> 00:13:24,800
kind of guessing and going in circles

00:13:22,560 --> 00:13:27,839
about what containers do and don't want

00:13:24,800 --> 00:13:31,040
um you know there is a balance

00:13:27,839 --> 00:13:32,880
if they've got you know

00:13:31,040 --> 00:13:34,880
time to spread across all kinds of

00:13:32,880 --> 00:13:37,440
projects not just yours

00:13:34,880 --> 00:13:38,720
but you know seeing code is helpful rfc

00:13:37,440 --> 00:13:42,560
patch sets can help

00:13:38,720 --> 00:13:45,040
you know and keeping that balanced um

00:13:42,560 --> 00:13:45,760
you know not too many that they get sick

00:13:45,040 --> 00:13:47,279
of you but

00:13:45,760 --> 00:13:48,800
but enough to get the important

00:13:47,279 --> 00:13:51,600
questions answered this is a good

00:13:48,800 --> 00:13:51,600
balance to strike

00:13:51,760 --> 00:13:57,680
and um you also may don't

00:13:55,040 --> 00:13:59,199
churn too much on prototype code i mean

00:13:57,680 --> 00:14:02,480
you want to get value out of it you

00:13:59,199 --> 00:14:05,279
don't want to

00:14:02,480 --> 00:14:05,920
explore too many ideas that that aren't

00:14:05,279 --> 00:14:08,720
um

00:14:05,920 --> 00:14:09,600
contributing to forward progress on the

00:14:08,720 --> 00:14:12,800
upstream

00:14:09,600 --> 00:14:14,560
front so um

00:14:12,800 --> 00:14:16,160
some some recommendations for what you

00:14:14,560 --> 00:14:17,440
want to do to to get a successful

00:14:16,160 --> 00:14:19,360
project

00:14:17,440 --> 00:14:21,040
building communities is really important

00:14:19,360 --> 00:14:24,560
you want to you want to get the word out

00:14:21,040 --> 00:14:28,320
early you want to get on a mailing list

00:14:24,560 --> 00:14:31,040
where like-minded or

00:14:28,320 --> 00:14:32,320
similarly focused people um you know

00:14:31,040 --> 00:14:35,279
netdev list or

00:14:32,320 --> 00:14:35,760
or other things would be listening and

00:14:35,279 --> 00:14:38,320
and

00:14:35,760 --> 00:14:40,320
might have common interests um proposing

00:14:38,320 --> 00:14:43,519
a conference talk like this one

00:14:40,320 --> 00:14:46,000
um gets gets a lot of

00:14:43,519 --> 00:14:48,560
attention too and you may be surprised

00:14:46,000 --> 00:14:52,880
at who gets involved or

00:14:48,560 --> 00:14:55,360
uh supports the project and um

00:14:52,880 --> 00:14:56,959
that's a good way to go um you'll you'll

00:14:55,360 --> 00:14:59,519
want to have

00:14:56,959 --> 00:15:00,480
a team that that has people in a whole

00:14:59,519 --> 00:15:03,360
bunch of different roles

00:15:00,480 --> 00:15:04,720
um you know probably the initial focus

00:15:03,360 --> 00:15:07,120
will be from

00:15:04,720 --> 00:15:08,240
um you know people are interested in the

00:15:07,120 --> 00:15:11,440
technology or

00:15:08,240 --> 00:15:13,360
her experts already um but

00:15:11,440 --> 00:15:15,199
it's it's also very important especially

00:15:13,360 --> 00:15:18,480
in in the

00:15:15,199 --> 00:15:20,959
context of having changes to an existing

00:15:18,480 --> 00:15:22,320
complicated and uh very performance

00:15:20,959 --> 00:15:24,560
sensitive system

00:15:22,320 --> 00:15:25,600
you want you want people who know that

00:15:24,560 --> 00:15:29,759
inside and out

00:15:25,600 --> 00:15:32,079
um and that that

00:15:29,759 --> 00:15:33,839
was something that our initial team

00:15:32,079 --> 00:15:35,360
didn't have and then once we got that it

00:15:33,839 --> 00:15:37,040
was that we were able to make progress a

00:15:35,360 --> 00:15:39,360
lot faster

00:15:37,040 --> 00:15:40,160
you want to have people who are

00:15:39,360 --> 00:15:44,320
fulfilling

00:15:40,160 --> 00:15:47,440
communication role of doing

00:15:44,320 --> 00:15:50,000
doing a conference presentation doing

00:15:47,440 --> 00:15:51,279
uh the meeting logistics that kind of

00:15:50,000 --> 00:15:54,720
thing

00:15:51,279 --> 00:15:57,759
and also having having automation

00:15:54,720 --> 00:15:58,800
available to keep things on track with

00:15:57,759 --> 00:16:01,839
builds and

00:15:58,800 --> 00:16:03,199
and uh sharing test results and making

00:16:01,839 --> 00:16:06,480
sure everybody's all

00:16:03,199 --> 00:16:08,720
on the same page um we've had a lot of

00:16:06,480 --> 00:16:11,839
luck with uh weekly online meetings

00:16:08,720 --> 00:16:15,040
were spread over different countries

00:16:11,839 --> 00:16:17,600
um and but

00:16:15,040 --> 00:16:18,959
it's been a regular helpful thing for

00:16:17,600 --> 00:16:22,240
strengthening our community and

00:16:18,959 --> 00:16:23,680
staying accountable to each other and

00:16:22,240 --> 00:16:25,920
you know when when everybody's able to

00:16:23,680 --> 00:16:26,800
travel again um face-to-face meetings

00:16:25,920 --> 00:16:30,320
really

00:16:26,800 --> 00:16:32,639
really help um we had

00:16:30,320 --> 00:16:33,519
also some just kind of a grab bag of

00:16:32,639 --> 00:16:36,560
tips here we

00:16:33,519 --> 00:16:39,839
use top kit for revising patch sets and

00:16:36,560 --> 00:16:41,199
rebasing on netdev um

00:16:39,839 --> 00:16:43,519
use a variety of communication

00:16:41,199 --> 00:16:44,480
technologies and uh and continuous

00:16:43,519 --> 00:16:46,160
integration to

00:16:44,480 --> 00:16:48,000
to stay on top of test results and make

00:16:46,160 --> 00:16:49,199
sure you're not breaking your own code

00:16:48,000 --> 00:16:52,240
or other codes

00:16:49,199 --> 00:16:55,440
is also super helpful and

00:16:52,240 --> 00:16:59,199
um just a final slide on

00:16:55,440 --> 00:17:01,360
on the up streaming process um

00:16:59,199 --> 00:17:03,440
what we ended up doing you know after

00:17:01,360 --> 00:17:04,040
after learning a lesson on what didn't

00:17:03,440 --> 00:17:05,120
work

00:17:04,040 --> 00:17:07,439
[Music]

00:17:05,120 --> 00:17:09,039
we kind of split things up into four

00:17:07,439 --> 00:17:12,720
phases

00:17:09,039 --> 00:17:14,400
the first was the upstream's

00:17:12,720 --> 00:17:17,199
independent building blocks example of

00:17:14,400 --> 00:17:19,199
this is skbx that

00:17:17,199 --> 00:17:21,280
westfall up streamed and and this

00:17:19,199 --> 00:17:24,640
refactored a couple systems and made

00:17:21,280 --> 00:17:26,240
um a positive change to those that that

00:17:24,640 --> 00:17:28,000
it was accepted on its own and then that

00:17:26,240 --> 00:17:29,039
was available for multi-path to use as

00:17:28,000 --> 00:17:32,080
well

00:17:29,039 --> 00:17:35,120
um and then after that we can we have

00:17:32,080 --> 00:17:36,960
the next three phases where where we had

00:17:35,120 --> 00:17:39,360
built significant functionality out of

00:17:36,960 --> 00:17:40,480
tree um

00:17:39,360 --> 00:17:42,880
all the way up through the multiple

00:17:40,480 --> 00:17:44,320
subflow capability but in order to have

00:17:42,880 --> 00:17:47,120
reviewable patch sets

00:17:44,320 --> 00:17:49,120
we we split that into three pieces first

00:17:47,120 --> 00:17:50,559
was prerequisite changes that that

00:17:49,120 --> 00:17:53,520
focused on

00:17:50,559 --> 00:17:54,640
um kind of the points for tcp was

00:17:53,520 --> 00:17:57,440
changing

00:17:54,640 --> 00:17:59,120
um that we wanted to have the

00:17:57,440 --> 00:18:03,760
maintainers take a close look at

00:17:59,120 --> 00:18:06,240
before proceeding with merges

00:18:03,760 --> 00:18:08,080
and and you know establishing things

00:18:06,240 --> 00:18:10,480
like

00:18:08,080 --> 00:18:11,679
user interface user space interface

00:18:10,480 --> 00:18:14,160
values

00:18:11,679 --> 00:18:16,960
iproto and ptcp things like that that

00:18:14,160 --> 00:18:18,880
just needed to get established up front

00:18:16,960 --> 00:18:20,000
the next step from there once that was

00:18:18,880 --> 00:18:22,400
merged was the

00:18:20,000 --> 00:18:24,160
sort of the next chunk of foundational

00:18:22,400 --> 00:18:26,720
code that was of real

00:18:24,160 --> 00:18:29,200
reviewable size for us that was a single

00:18:26,720 --> 00:18:32,240
subflow multi-path tcp

00:18:29,200 --> 00:18:34,400
um not super useful on its own but but

00:18:32,240 --> 00:18:35,840
it built it brought in a lot of the code

00:18:34,400 --> 00:18:39,520
that that we needed to

00:18:35,840 --> 00:18:42,160
to continue building on and so

00:18:39,520 --> 00:18:44,640
um you know it's not it's not broken

00:18:42,160 --> 00:18:49,280
it's there it does its thing it's

00:18:44,640 --> 00:18:51,120
it's solid code but it um is not the

00:18:49,280 --> 00:18:53,440
the real first step that we wanted and

00:18:51,120 --> 00:18:56,080
that and that gets us to

00:18:53,440 --> 00:18:57,679
uh the multiple subflow number four on

00:18:56,080 --> 00:19:00,480
this slide where we

00:18:57,679 --> 00:19:01,919
added um the ability to create those

00:19:00,480 --> 00:19:04,160
multiple subflows and kind of have that

00:19:01,919 --> 00:19:08,000
baseline functionality we're aiming for

00:19:04,160 --> 00:19:08,720
um and so the advice we got was to stick

00:19:08,000 --> 00:19:10,640
to

00:19:08,720 --> 00:19:12,320
you know 12 to 20 hopefully closer to

00:19:10,640 --> 00:19:14,799
the 12 patches per patch set

00:19:12,320 --> 00:19:16,080
and to keep things uh and have a

00:19:14,799 --> 00:19:17,600
reviewable size and

00:19:16,080 --> 00:19:20,240
of course the individual patches being

00:19:17,600 --> 00:19:20,240
reasonable too

00:19:21,600 --> 00:19:28,559
so um what needs to happen

00:19:25,360 --> 00:19:30,080
on a on a linux distribution or

00:19:28,559 --> 00:19:32,559
you know configuring your own machine to

00:19:30,080 --> 00:19:34,799
be able to use multipath tcp

00:19:32,559 --> 00:19:36,000
the first step in that is uh making sure

00:19:34,799 --> 00:19:39,520
it's built into your kernel

00:19:36,000 --> 00:19:42,240
um by you know if you do a def config

00:19:39,520 --> 00:19:44,480
it's it's not there um so you need to

00:19:42,240 --> 00:19:46,080
enable config mptcp and and probably

00:19:44,480 --> 00:19:49,919
ipv6 as well

00:19:46,080 --> 00:19:52,799
uh keeping in mind that the

00:19:49,919 --> 00:19:56,640
the ipv6 support in multicat tcp does

00:19:52,799 --> 00:19:59,039
prevent use of ipv6 as a module

00:19:56,640 --> 00:20:01,120
um and if you're a developer trying to

00:19:59,039 --> 00:20:02,799
run the mptcp self-test there are a

00:20:01,120 --> 00:20:06,720
couple other options that

00:20:02,799 --> 00:20:11,360
that we use to implement the

00:20:06,720 --> 00:20:11,360
self-test support in multiple namespaces

00:20:12,400 --> 00:20:17,120
so you've got a kernel with multi-path

00:20:14,880 --> 00:20:21,679
dcp supported

00:20:17,120 --> 00:20:24,480
now um your applications make use of it

00:20:21,679 --> 00:20:25,360
um so it's just when you create your

00:20:24,480 --> 00:20:28,799
socket

00:20:25,360 --> 00:20:31,679
instead of uh iproto tcp

00:20:28,799 --> 00:20:32,799
or or just leaving it to default based

00:20:31,679 --> 00:20:35,840
on the

00:20:32,799 --> 00:20:37,919
streaming type uh you specify iproto

00:20:35,840 --> 00:20:41,440
mptcp

00:20:37,919 --> 00:20:42,880
and um then after that initial socket

00:20:41,440 --> 00:20:44,799
call the normal

00:20:42,880 --> 00:20:46,159
you know connect or bindless and accept

00:20:44,799 --> 00:20:47,760
kind of cycle

00:20:46,159 --> 00:20:50,559
sending and receiving data with send to

00:20:47,760 --> 00:20:52,480
receive function that all

00:20:50,559 --> 00:20:54,480
works like you're used to with a regular

00:20:52,480 --> 00:20:56,480
stream socket

00:20:54,480 --> 00:21:00,000
there's some some important things to

00:20:56,480 --> 00:21:02,640
note that are different from tcp

00:21:00,000 --> 00:21:04,080
we don't have advanced features like

00:21:02,640 --> 00:21:07,760
zero copy

00:21:04,080 --> 00:21:09,200
um you know ulp using kernel tls then

00:21:07,760 --> 00:21:12,400
that stuff isn't there

00:21:09,200 --> 00:21:14,480
um and if you're you're

00:21:12,400 --> 00:21:16,320
using socket options on the socket

00:21:14,480 --> 00:21:18,880
that's gonna require some extra

00:21:16,320 --> 00:21:20,880
attention as well

00:21:18,880 --> 00:21:22,080
there's several things about supporting

00:21:20,880 --> 00:21:25,760
socket options with

00:21:22,080 --> 00:21:26,080
multi-path tcp that aren't trivial it's

00:21:25,760 --> 00:21:28,159
not

00:21:26,080 --> 00:21:31,039
possible to just pass things through in

00:21:28,159 --> 00:21:33,840
all cases to the subflows um

00:21:31,039 --> 00:21:35,120
there is the issue that that individual

00:21:33,840 --> 00:21:38,159
tcp connections

00:21:35,120 --> 00:21:38,960
that that are under control of the mptcp

00:21:38,159 --> 00:21:40,799
socket those

00:21:38,960 --> 00:21:42,080
those can be added and removed as time

00:21:40,799 --> 00:21:43,440
goes on so you have things to think

00:21:42,080 --> 00:21:46,559
about like

00:21:43,440 --> 00:21:48,799
does does this

00:21:46,559 --> 00:21:50,000
setting get remembered and applied to

00:21:48,799 --> 00:21:53,520
new

00:21:50,000 --> 00:21:56,880
new connections new tcp connections or

00:21:53,520 --> 00:22:00,240
do the new ones have defaults again um

00:21:56,880 --> 00:22:00,640
and you might have multiple subflows and

00:22:00,240 --> 00:22:02,720
and

00:22:00,640 --> 00:22:04,320
setting one socket option the value

00:22:02,720 --> 00:22:06,880
there

00:22:04,320 --> 00:22:08,240
might not make sense across all of them

00:22:06,880 --> 00:22:11,280
or if you're getting a value

00:22:08,240 --> 00:22:15,200
you do you somehow combine

00:22:11,280 --> 00:22:16,559
the multiple subflow um socket option

00:22:15,200 --> 00:22:18,320
values that you've read from those

00:22:16,559 --> 00:22:21,280
individual ones um

00:22:18,320 --> 00:22:22,799
or or do you prefer one the one that's

00:22:21,280 --> 00:22:25,200
currently active there's so there's just

00:22:22,799 --> 00:22:28,880
a lot of questions like that and so

00:22:25,200 --> 00:22:30,159
um we we don't have those implemented

00:22:28,880 --> 00:22:31,280
yet for the most part the ones that

00:22:30,159 --> 00:22:34,320
aren't supported will

00:22:31,280 --> 00:22:36,880
will give uh an error

00:22:34,320 --> 00:22:38,240
a not supported error but um as time

00:22:36,880 --> 00:22:40,159
goes on where we're

00:22:38,240 --> 00:22:42,080
gonna pick out the ones that are needed

00:22:40,159 --> 00:22:45,200
most and um

00:22:42,080 --> 00:22:48,400
make those work well so so that

00:22:45,200 --> 00:22:49,919
programs using tcp sockets don't have to

00:22:48,400 --> 00:22:52,799
make too many changes

00:22:49,919 --> 00:22:55,840
in their socket option usage in order to

00:22:52,799 --> 00:22:59,440
leverage multi-path tcp

00:22:55,840 --> 00:23:01,120
so um the ones that aren't supported

00:22:59,440 --> 00:23:04,080
right now are the ones under the that

00:23:01,120 --> 00:23:07,280
you would use iproto tcp to set

00:23:04,080 --> 00:23:11,120
um and even the the saw socket options

00:23:07,280 --> 00:23:13,840
in kernels 5.8 and earlier so reuse port

00:23:11,120 --> 00:23:13,840
and reuse adder

00:23:14,240 --> 00:23:20,840
won't to give the expected behavior but

00:23:18,000 --> 00:23:23,200
in 5.9 we do have a fix for that coming

00:23:20,840 --> 00:23:25,919
up

00:23:23,200 --> 00:23:26,320
and and we we are looking at ways to

00:23:25,919 --> 00:23:29,600
have

00:23:26,320 --> 00:23:31,280
more more control of multi-path tcp

00:23:29,600 --> 00:23:33,840
itself via socket options so an

00:23:31,280 --> 00:23:36,880
application could have some

00:23:33,840 --> 00:23:36,880
some more input on

00:23:37,120 --> 00:23:42,640
subflow information setting up subflows

00:23:40,799 --> 00:23:44,960
changing their configuration while

00:23:42,640 --> 00:23:44,960
running

00:23:46,080 --> 00:23:50,480
so that that's the individual programs

00:23:49,279 --> 00:23:54,240
configuring a socket

00:23:50,480 --> 00:23:58,000
now another thing to consider is

00:23:54,240 --> 00:24:01,520
system level runtime configuration

00:23:58,000 --> 00:24:02,240
there is a assist control at nptcp

00:24:01,520 --> 00:24:04,960
enabled

00:24:02,240 --> 00:24:06,960
that is turned on by default but you can

00:24:04,960 --> 00:24:10,000
turn it off per name space if you

00:24:06,960 --> 00:24:13,760
don't want i'll type out tcp to get used

00:24:10,000 --> 00:24:15,760
um so by default in a in a kernel that

00:24:13,760 --> 00:24:17,760
supports multi-path tcp

00:24:15,760 --> 00:24:18,880
it won't create those additional

00:24:17,760 --> 00:24:20,320
subflows

00:24:18,880 --> 00:24:22,880
unless you take some specific

00:24:20,320 --> 00:24:24,960
configuration steps at runtime

00:24:22,880 --> 00:24:27,039
so you need you need to tell multi about

00:24:24,960 --> 00:24:28,880
the multi.tcp system that

00:24:27,039 --> 00:24:30,840
okay here's how many subflows i want to

00:24:28,880 --> 00:24:34,159
allow

00:24:30,840 --> 00:24:34,880
and that will have a couple of different

00:24:34,159 --> 00:24:37,919
ways to

00:24:34,880 --> 00:24:41,039
to be addressed um long-term

00:24:37,919 --> 00:24:42,799
um devices will be able to have a user

00:24:41,039 --> 00:24:45,120
space component that

00:24:42,799 --> 00:24:46,720
that controls subflow establishment such

00:24:45,120 --> 00:24:50,159
as multi-path tcpd

00:24:46,720 --> 00:24:54,080
or something else right now we use

00:24:50,159 --> 00:24:56,799
the ipnbcp command this is in ip route 2

00:24:54,080 --> 00:24:59,200
recent versions corresponding to the

00:24:56,799 --> 00:25:01,760
kernel version 5.7 and later

00:24:59,200 --> 00:25:04,240
and um these these just configure

00:25:01,760 --> 00:25:09,600
system-wide behavior

00:25:04,240 --> 00:25:11,120
um so how this ip mptcp command works

00:25:09,600 --> 00:25:13,200
obviously you can refer to the man page

00:25:11,120 --> 00:25:16,720
but the the simple cases

00:25:13,200 --> 00:25:19,840
um mentioned here one is like

00:25:16,720 --> 00:25:23,120
if you have say a server that

00:25:19,840 --> 00:25:26,080
is uh has a has a public ip address

00:25:23,120 --> 00:25:28,640
and you just want to let appear be in

00:25:26,080 --> 00:25:30,720
charge of initiating more subflows

00:25:28,640 --> 00:25:31,679
you can set a limit that controls how

00:25:30,720 --> 00:25:34,880
many of those

00:25:31,679 --> 00:25:38,159
requests you will accept per connection

00:25:34,880 --> 00:25:40,960
and that's the sudo ip mptcp limit set

00:25:38,159 --> 00:25:40,960
subflow command

00:25:41,039 --> 00:25:44,880
so it's like this is set to four then

00:25:42,640 --> 00:25:48,159
you get four additional subflows

00:25:44,880 --> 00:25:48,159
before it starts limiting

00:25:53,360 --> 00:25:59,039
now you can also

00:25:56,400 --> 00:26:00,480
initiate more subflows from today's

00:25:59,039 --> 00:26:03,919
linux kernels

00:26:00,480 --> 00:26:05,520
and this is with the ip mpdcp limit set

00:26:03,919 --> 00:26:07,840
subflow command which

00:26:05,520 --> 00:26:09,360
which again lets you set a number of

00:26:07,840 --> 00:26:12,559
subflows that this kernel

00:26:09,360 --> 00:26:14,320
will try to initiate to the peer

00:26:12,559 --> 00:26:16,080
and an additional thing that needs to

00:26:14,320 --> 00:26:20,080
take place is

00:26:16,080 --> 00:26:22,640
telling telling multipath tcp which

00:26:20,080 --> 00:26:23,120
local interfaces you want to use for

00:26:22,640 --> 00:26:25,760
this

00:26:23,120 --> 00:26:27,120
additional subflow including especially

00:26:25,760 --> 00:26:30,480
implied by the

00:26:27,120 --> 00:26:34,159
local ip address on that interface so

00:26:30,480 --> 00:26:37,200
the iptcp endpoint command you can add

00:26:34,159 --> 00:26:41,120
multiple endpoints to say use these

00:26:37,200 --> 00:26:41,120
addresses inform

00:26:41,600 --> 00:26:45,760
optionally inform the other side that

00:26:43,600 --> 00:26:48,080
they're available and then

00:26:45,760 --> 00:26:51,279
when creating more tcp connections for

00:26:48,080 --> 00:26:51,279
those tcp subflows

00:26:51,440 --> 00:26:54,960
use those as the source address

00:26:55,600 --> 00:27:02,559
now an example of this is um

00:26:59,919 --> 00:27:02,960
if you have a you know a device possibly

00:27:02,559 --> 00:27:05,120
with

00:27:02,960 --> 00:27:08,480
interfaces behind that that are they're

00:27:05,120 --> 00:27:10,320
trying to connect to a server

00:27:08,480 --> 00:27:11,919
this would allow you to create those

00:27:10,320 --> 00:27:14,159
multiple subflows and take advantage of

00:27:11,919 --> 00:27:14,159
those

00:27:15,360 --> 00:27:20,720
so i've mentioned path management

00:27:18,559 --> 00:27:22,480
and doing so in user space so this this

00:27:20,720 --> 00:27:26,399
is the sort of the terminology

00:27:22,480 --> 00:27:27,440
for um controlling which subflows are

00:27:26,399 --> 00:27:30,880
part of an individual

00:27:27,440 --> 00:27:30,880
multipath tcp connection

00:27:31,200 --> 00:27:34,399
so you can either do this in user space

00:27:33,919 --> 00:27:36,720
or

00:27:34,399 --> 00:27:39,360
inside the kernel there's some

00:27:36,720 --> 00:27:42,000
advantages to being in user space

00:27:39,360 --> 00:27:43,120
it'll be easier to integrate with like

00:27:42,000 --> 00:27:46,320
platform middleware

00:27:43,120 --> 00:27:47,919
on mobile devices or carrier policy

00:27:46,320 --> 00:27:50,559
things like that

00:27:47,919 --> 00:27:52,080
it keeps keeps the logic for this and

00:27:50,559 --> 00:27:55,279
the ability to customize it

00:27:52,080 --> 00:27:56,960
separate from the kernel so that it's

00:27:55,279 --> 00:28:00,240
easier to manage separately you know as

00:27:56,960 --> 00:28:02,880
the kernel's up updated

00:28:00,240 --> 00:28:03,919
and also if you know any bugs in in a

00:28:02,880 --> 00:28:07,039
path manager don't

00:28:03,919 --> 00:28:10,720
don't affect system stability so much

00:28:07,039 --> 00:28:13,600
um and the

00:28:10,720 --> 00:28:15,200
one of the other main reasons to to look

00:28:13,600 --> 00:28:18,480
at a user space path manager

00:28:15,200 --> 00:28:20,399
is that on a say a server use case where

00:28:18,480 --> 00:28:22,480
server's under heavy load the the

00:28:20,399 --> 00:28:24,399
netlink interface up to user space could

00:28:22,480 --> 00:28:26,000
could become a bottleneck and so if

00:28:24,399 --> 00:28:26,799
there are simple criteria that can be in

00:28:26,000 --> 00:28:29,840
the kernel that

00:28:26,799 --> 00:28:31,360
that can be helpful um that's

00:28:29,840 --> 00:28:33,200
showing on this slide with having an

00:28:31,360 --> 00:28:36,240
internal path manager

00:28:33,200 --> 00:28:37,440
um it accommodates that server-side use

00:28:36,240 --> 00:28:38,720
case

00:28:37,440 --> 00:28:42,320
pretty well because you don't have that

00:28:38,720 --> 00:28:43,679
overhead um

00:28:42,320 --> 00:28:46,240
and like i mentioned on the previous

00:28:43,679 --> 00:28:49,120
slide the the maintenance and

00:28:46,240 --> 00:28:50,000
bugs are potentially a bigger issue and

00:28:49,120 --> 00:28:53,200
then

00:28:50,000 --> 00:28:55,120
that it is more amenable to kind of a

00:28:53,200 --> 00:28:57,039
global policy

00:28:55,120 --> 00:28:58,880
that doesn't take as much into account

00:28:57,039 --> 00:29:01,279
of the characteristics of an individual

00:28:58,880 --> 00:29:01,279
connection

00:29:02,640 --> 00:29:07,120
so as i mentioned the connection between

00:29:05,440 --> 00:29:12,080
the kernel and user space

00:29:07,120 --> 00:29:13,840
is is via a generic netlink api

00:29:12,080 --> 00:29:15,919
and this this allows the kernel to

00:29:13,840 --> 00:29:17,919
inform user space of events that happen

00:29:15,919 --> 00:29:19,520
such as there's there's a new connection

00:29:17,919 --> 00:29:22,240
or a new subflow or

00:29:19,520 --> 00:29:22,640
a subflow went away things like that and

00:29:22,240 --> 00:29:26,720
then

00:29:22,640 --> 00:29:30,880
um the daemon the user space demon can

00:29:26,720 --> 00:29:33,440
can take that and issue commands that

00:29:30,880 --> 00:29:35,760
that change the behavior with the

00:29:33,440 --> 00:29:40,000
subflows

00:29:35,760 --> 00:29:43,200
this api is uh in the user api linux

00:29:40,000 --> 00:29:46,240
mptc.h file and um

00:29:43,200 --> 00:29:49,360
is available for use by anything with uh

00:29:46,240 --> 00:29:51,840
the right privileges um so so

00:29:49,360 --> 00:29:53,919
perhaps someday could be included in

00:29:51,840 --> 00:29:55,679
network manager or we could con man

00:29:53,919 --> 00:30:00,159
things like that but

00:29:55,679 --> 00:30:02,559
those those don't support mbtcp today

00:30:00,159 --> 00:30:03,440
what we went with for an initial

00:30:02,559 --> 00:30:04,960
implementation

00:30:03,440 --> 00:30:07,440
using this netlink interface is to

00:30:04,960 --> 00:30:10,240
create the multi-path tcp daemon

00:30:07,440 --> 00:30:12,080
independent daemon that that talks to

00:30:10,240 --> 00:30:15,200
the network interface and monitors

00:30:12,080 --> 00:30:18,000
network interface changes

00:30:15,200 --> 00:30:19,440
this is extensible with with plugins to

00:30:18,000 --> 00:30:22,480
implement different

00:30:19,440 --> 00:30:24,320
techniques for for creating subflows and

00:30:22,480 --> 00:30:27,679
allowing those connections

00:30:24,320 --> 00:30:29,120
um it is it's not a replacement for

00:30:27,679 --> 00:30:32,000
things like network manager

00:30:29,120 --> 00:30:33,520
um but we just we wanted to have an

00:30:32,000 --> 00:30:36,559
implementation that would work across a

00:30:33,520 --> 00:30:40,159
variety of use cases that was kind of

00:30:36,559 --> 00:30:42,880
system agnostic in terms of what

00:30:40,159 --> 00:30:46,000
what a distribution or what her mobile

00:30:42,880 --> 00:30:46,000
platform was built around

00:30:46,399 --> 00:30:51,840
and so it it receives those events and

00:30:49,360 --> 00:30:51,840
and

00:30:51,919 --> 00:30:54,880
you know we're working on functionality

00:30:53,200 --> 00:30:56,640
today that allows it to configure the

00:30:54,880 --> 00:30:59,919
internal

00:30:56,640 --> 00:31:02,000
manager uh path manager but um

00:30:59,919 --> 00:31:04,000
you're still still working towards

00:31:02,000 --> 00:31:05,760
having upstream functionality that

00:31:04,000 --> 00:31:08,480
has the full set of events and commands

00:31:05,760 --> 00:31:11,679
to do user space

00:31:08,480 --> 00:31:13,200
path management and we have a github

00:31:11,679 --> 00:31:17,200
project for here

00:31:13,200 --> 00:31:21,919
at github.com intel mptcpd

00:31:17,200 --> 00:31:25,279
um so like i mentioned uh multipath tcpd

00:31:21,919 --> 00:31:28,159
has plug-ins um that

00:31:25,279 --> 00:31:29,760
uh we've got a series of headers for

00:31:28,159 --> 00:31:31,600
showing the interface their

00:31:29,760 --> 00:31:33,200
example plugins in the in the source

00:31:31,600 --> 00:31:37,679
code to show

00:31:33,200 --> 00:31:39,600
how to how to do this um and

00:31:37,679 --> 00:31:42,000
and the community the plugins also

00:31:39,600 --> 00:31:45,200
communicate with the mptcpd library

00:31:42,000 --> 00:31:45,200
to be able to um

00:31:45,519 --> 00:31:49,840
exert control over over what happens and

00:31:48,080 --> 00:31:51,679
then then the

00:31:49,840 --> 00:31:52,960
the core demon itself does the net like

00:31:51,679 --> 00:31:53,600
communication to propagate that

00:31:52,960 --> 00:31:56,159
information

00:31:53,600 --> 00:31:56,880
so you know as an illustration here over

00:31:56,159 --> 00:31:59,840
the life cycle

00:31:56,880 --> 00:32:01,279
cycle of a connection you could start a

00:31:59,840 --> 00:32:03,279
connection

00:32:01,279 --> 00:32:05,279
it would both create the the behavior on

00:32:03,279 --> 00:32:06,320
the network sending syn packets doing

00:32:05,279 --> 00:32:08,640
the handshake

00:32:06,320 --> 00:32:10,159
and also propagating events to the the

00:32:08,640 --> 00:32:14,640
path manager

00:32:10,159 --> 00:32:16,240
that um allow it to to further control

00:32:14,640 --> 00:32:17,840
um additional subflow getting

00:32:16,240 --> 00:32:21,600
established so

00:32:17,840 --> 00:32:24,559
um after after a new connection event

00:32:21,600 --> 00:32:26,080
comes to the path manager it also gets

00:32:24,559 --> 00:32:29,679
notified of each new subflow

00:32:26,080 --> 00:32:32,880
and um can update its stored data

00:32:29,679 --> 00:32:36,159
and and control its own logic for

00:32:32,880 --> 00:32:38,480
how things proceed from there um

00:32:36,159 --> 00:32:41,120
and in addition there's this uh the the

00:32:38,480 --> 00:32:45,919
network interface side of things where

00:32:41,120 --> 00:32:48,480
real time where then the generic netlink

00:32:45,919 --> 00:32:49,039
updates for a new interface also trigger

00:32:48,480 --> 00:32:52,399
events

00:32:49,039 --> 00:32:55,120
and can then be used to to send

00:32:52,399 --> 00:32:56,000
new ip address information to the peer

00:32:55,120 --> 00:32:59,039
so that it could choose

00:32:56,000 --> 00:33:02,320
to to initiate some flows if it wants

00:32:59,039 --> 00:33:04,480
and just to close up on the multi-path

00:33:02,320 --> 00:33:07,200
tcp daemon

00:33:04,480 --> 00:33:09,279
it requires cap net admin for for using

00:33:07,200 --> 00:33:12,000
the netlink interface like any

00:33:09,279 --> 00:33:13,200
network client would have to for for

00:33:12,000 --> 00:33:16,159
network stuff

00:33:13,200 --> 00:33:17,360
um it builds with some system d

00:33:16,159 --> 00:33:20,159
integration

00:33:17,360 --> 00:33:21,919
if that's detected and uses dynamic user

00:33:20,159 --> 00:33:25,360
support to

00:33:21,919 --> 00:33:27,919
help with the security situation

00:33:25,360 --> 00:33:29,919
and is configured with a configuration

00:33:27,919 --> 00:33:32,000
file

00:33:29,919 --> 00:33:34,320
and like it's and also as i mentioned

00:33:32,000 --> 00:33:37,279
earlier having a

00:33:34,320 --> 00:33:39,440
reference plugin that that will do a

00:33:37,279 --> 00:33:42,559
fairly simple use case of

00:33:39,440 --> 00:33:44,159
creating subflows one per interface to

00:33:42,559 --> 00:33:48,320
take advantage of those

00:33:44,159 --> 00:33:50,640
parallel capabilities so

00:33:48,320 --> 00:33:53,600
in closing today programs can't begin

00:33:50,640 --> 00:33:57,120
using iproto mptcp

00:33:53,600 --> 00:33:58,080
and um that's with the 5.7 kernel and

00:33:57,120 --> 00:34:00,399
later

00:33:58,080 --> 00:34:03,279
and especially with 5.8 and later you're

00:34:00,399 --> 00:34:04,880
ready for like handover based use cases

00:34:03,279 --> 00:34:06,399
with with the version one of the

00:34:04,880 --> 00:34:09,919
protocol

00:34:06,399 --> 00:34:12,159
and um in the future as as we

00:34:09,919 --> 00:34:13,599
fill out the the netlink api on the

00:34:12,159 --> 00:34:16,320
upstream kernel

00:34:13,599 --> 00:34:17,599
user space path managers will add even

00:34:16,320 --> 00:34:21,520
richer functionality

00:34:17,599 --> 00:34:24,560
on the path manager front

00:34:21,520 --> 00:34:27,119
so and we also are

00:34:24,560 --> 00:34:28,399
busy with a whole bunch of other tasks

00:34:27,119 --> 00:34:30,399
to

00:34:28,399 --> 00:34:32,159
make multi-path tcp work as well as

00:34:30,399 --> 00:34:34,079
possible and support a number of

00:34:32,159 --> 00:34:38,000
advanced features

00:34:34,079 --> 00:34:38,639
in the future so if you'd like to find

00:34:38,000 --> 00:34:40,879
us

00:34:38,639 --> 00:34:42,000
our project page is at github we have an

00:34:40,879 --> 00:34:45,119
active mailing list

00:34:42,000 --> 00:34:48,879
mbdcp lists.one.org and

00:34:45,119 --> 00:34:51,679
uh and we're on irc

00:34:48,879 --> 00:34:52,399
and feel free to contact me or osama

00:34:51,679 --> 00:34:55,119
about

00:34:52,399 --> 00:34:55,119
these projects

00:34:55,679 --> 00:34:59,599
um i'm not going to read all the links

00:34:57,760 --> 00:35:02,000
to you but if you are interested in more

00:34:59,599 --> 00:35:05,359
detail on what multipath tcp does

00:35:02,000 --> 00:35:08,320
or steps along our upstreaming effort

00:35:05,359 --> 00:35:08,320
you can refer to these

00:35:08,640 --> 00:35:12,800
and thank you very much for your time

00:35:15,440 --> 00:35:19,599
uh thank you matt uh i i i'll say this

00:35:18,640 --> 00:35:21,839
like i

00:35:19,599 --> 00:35:23,359
was very skeptical of mptcp but i've

00:35:21,839 --> 00:35:25,280
come to really like

00:35:23,359 --> 00:35:27,920
what you guys have done and and actually

00:35:25,280 --> 00:35:31,200
you know it's an i find mptcp as

00:35:27,920 --> 00:35:33,520
uh as a manifestation of we can

00:35:31,200 --> 00:35:34,480
keep making tcp better and it's widely

00:35:33,520 --> 00:35:36,000
used

00:35:34,480 --> 00:35:37,920
there are things that can be added to it

00:35:36,000 --> 00:35:40,800
and requires

00:35:37,920 --> 00:35:41,680
community effort as you said uh quite a

00:35:40,800 --> 00:35:45,040
few questions

00:35:41,680 --> 00:35:47,440
so uh question number one can wireshark

00:35:45,040 --> 00:35:50,320
reassemble the mptcp stream already

00:35:47,440 --> 00:35:50,960
because are there dissectors for it well

00:35:50,320 --> 00:35:54,320
yeah there's

00:35:50,960 --> 00:35:56,880
there is a wireshark dissector um

00:35:54,320 --> 00:35:59,040
as far as i know i don't think it puts

00:35:56,880 --> 00:36:02,079
things together across multiple streams

00:35:59,040 --> 00:36:05,440
um but it does

00:36:02,079 --> 00:36:08,320
show you each individual subflow and

00:36:05,440 --> 00:36:09,359
you know that recognizes that mptpcp is

00:36:08,320 --> 00:36:12,400
in use and

00:36:09,359 --> 00:36:14,560
um you know it shows all the headers and

00:36:12,400 --> 00:36:14,560
stuff

00:36:14,880 --> 00:36:21,040
awesome uh

00:36:18,880 --> 00:36:22,960
are the stream another next question is

00:36:21,040 --> 00:36:25,760
are the streams blocking in your example

00:36:22,960 --> 00:36:27,520
i guess if you lose packets from stream

00:36:25,760 --> 00:36:29,040
will we have to retransmit everything

00:36:27,520 --> 00:36:32,320
that should come after

00:36:29,040 --> 00:36:35,440
on all the other streams

00:36:32,320 --> 00:36:36,079
yeah it um so if you lose packets on

00:36:35,440 --> 00:36:39,520
stream b

00:36:36,079 --> 00:36:42,640
so it's the mptcp

00:36:39,520 --> 00:36:44,880
level acknowledgement is is

00:36:42,640 --> 00:36:45,760
you know it's not like selective act or

00:36:44,880 --> 00:36:49,680
anything it's just

00:36:45,760 --> 00:36:53,359
how far has it made it and so um

00:36:49,680 --> 00:36:55,440
it it will in the sense

00:36:53,359 --> 00:36:57,040
if if something hasn't been acknowledged

00:36:55,440 --> 00:37:00,240
the sender will will

00:36:57,040 --> 00:37:02,560
resend on other streams but the uh

00:37:00,240 --> 00:37:04,880
the receiver you know still has all the

00:37:02,560 --> 00:37:07,520
data from

00:37:04,880 --> 00:37:09,359
whatever it's received on other streams

00:37:07,520 --> 00:37:12,560
that we're moving forward

00:37:09,359 --> 00:37:14,400
and so it can uh you know as soon as

00:37:12,560 --> 00:37:16,240
it's able to move that act forward based

00:37:14,400 --> 00:37:18,079
on buffer data it can but

00:37:16,240 --> 00:37:23,200
you know there still might be more in

00:37:18,079 --> 00:37:24,880
flight than really needs to be

00:37:23,200 --> 00:37:26,240
but the idea is that the act is at the

00:37:24,880 --> 00:37:28,960
mptcp

00:37:26,240 --> 00:37:30,720
stream level right so right at the mp mp

00:37:28,960 --> 00:37:32,000
level you already know

00:37:30,720 --> 00:37:33,200
what has been acknowledged and what

00:37:32,000 --> 00:37:34,560
hasn't been acknowledged so you don't

00:37:33,200 --> 00:37:38,000
have to globally

00:37:34,560 --> 00:37:41,119
take our corrective action

00:37:38,000 --> 00:37:43,040
um i yeah

00:37:41,119 --> 00:37:45,119
i'm not sure on the answer that question

00:37:43,040 --> 00:37:48,480
i mean each subflow is still is a

00:37:45,119 --> 00:37:51,520
is a tcp stream that that you know

00:37:48,480 --> 00:37:53,119
has been uh reassembled and you know any

00:37:51,520 --> 00:37:54,960
re-transmissions have happened there so

00:37:53,119 --> 00:37:57,440
pretty much if you were

00:37:54,960 --> 00:38:00,160
if you're blocked by you know something

00:37:57,440 --> 00:38:02,240
that was sent on one stream

00:38:00,160 --> 00:38:03,680
you know that that one like you're going

00:38:02,240 --> 00:38:04,000
out of wi-fi range and you're just not

00:38:03,680 --> 00:38:07,200
getting

00:38:04,000 --> 00:38:07,200
anything on that stream anymore

00:38:07,440 --> 00:38:14,560
you will you know just depend on

00:38:12,079 --> 00:38:16,480
on the sender starting starting over

00:38:14,560 --> 00:38:18,160
from whatever wasn't hacked

00:38:16,480 --> 00:38:20,320
and you know there can be different

00:38:18,160 --> 00:38:22,400
approaches so it's called a

00:38:20,320 --> 00:38:23,680
scheduler at the mptcp level where it

00:38:22,400 --> 00:38:25,760
decides which

00:38:23,680 --> 00:38:27,760
which data is going out on which subflow

00:38:25,760 --> 00:38:29,359
and so

00:38:27,760 --> 00:38:31,040
you know you can have schedules with

00:38:29,359 --> 00:38:35,280
different strategies where

00:38:31,040 --> 00:38:37,599
if you had retransmitted data um

00:38:35,280 --> 00:38:39,040
you could infer you know which one it

00:38:37,599 --> 00:38:41,200
was blocked on and know

00:38:39,040 --> 00:38:44,839
know which data was kind of stuck behind

00:38:41,200 --> 00:38:46,560
that on that flow and only retransmit

00:38:44,839 --> 00:38:49,280
that

00:38:46,560 --> 00:38:51,440
make sense um sorry i missed this tom

00:38:49,280 --> 00:38:55,920
you have your hand raised

00:38:51,440 --> 00:38:58,240
did you have a question you wanted to

00:38:55,920 --> 00:38:58,240
ask

00:38:59,119 --> 00:39:03,280
okay well tom is answering that we'll

00:39:02,160 --> 00:39:06,640
continue

00:39:03,280 --> 00:39:09,920
uh what's still missing

00:39:06,640 --> 00:39:13,520
yeah i did have the slide later in the

00:39:09,920 --> 00:39:16,560
in the list about that um

00:39:13,520 --> 00:39:19,839
so a lot of them are things

00:39:16,560 --> 00:39:23,040
addressing you know how how you would

00:39:19,839 --> 00:39:25,359
make good use of mptcp on say a mobile

00:39:23,040 --> 00:39:28,160
phone or something so we

00:39:25,359 --> 00:39:30,079
kind of started from the server use

00:39:28,160 --> 00:39:32,480
cases of okay something else is

00:39:30,079 --> 00:39:34,640
responsible for initiating multiple

00:39:32,480 --> 00:39:36,480
subflows the peer is going to handle

00:39:34,640 --> 00:39:36,960
that and we just have to decide whether

00:39:36,480 --> 00:39:40,480
to

00:39:36,960 --> 00:39:44,000
accept those connections or not so

00:39:40,480 --> 00:39:46,640
the main things we have going are um

00:39:44,000 --> 00:39:47,680
you know supporting the side that that

00:39:46,640 --> 00:39:50,640
is making

00:39:47,680 --> 00:39:51,040
use of those multiple interfaces and um

00:39:50,640 --> 00:39:54,480
you know

00:39:51,040 --> 00:39:56,720
like the user space path management to

00:39:54,480 --> 00:39:57,520
take a more active role in in looking at

00:39:56,720 --> 00:40:00,240
which

00:39:57,520 --> 00:40:02,079
interfaces are available when to

00:40:00,240 --> 00:40:04,319
announce those to the pier

00:40:02,079 --> 00:40:05,599
which which ones to prefer in different

00:40:04,319 --> 00:40:08,480
uh scenarios

00:40:05,599 --> 00:40:12,160
that kind of thing um let's see what

00:40:08,480 --> 00:40:12,160
else is on that slide um

00:40:12,560 --> 00:40:18,960
just refining

00:40:16,000 --> 00:40:20,079
um the performance um making it more

00:40:18,960 --> 00:40:23,440
configurable

00:40:20,079 --> 00:40:25,440
how how outgoing data is

00:40:23,440 --> 00:40:28,560
which which subflows are chosen for that

00:40:25,440 --> 00:40:28,560
the packet schedulers

00:40:28,640 --> 00:40:32,560
i think there's some things kind of in

00:40:31,520 --> 00:40:36,880
the pipeline for

00:40:32,560 --> 00:40:38,800
um send cookies and

00:40:36,880 --> 00:40:40,560
there are some things in the rfc that

00:40:38,800 --> 00:40:43,680
are kind of you know

00:40:40,560 --> 00:40:47,839
should uh implement or things like that

00:40:43,680 --> 00:40:52,160
to just uh you know dot all the eyes and

00:40:47,839 --> 00:40:55,280
across the t's

00:40:52,160 --> 00:40:56,960
uh continuing uh i'm wondering if next

00:40:55,280 --> 00:41:00,960
question i'm wondering if there's a real

00:40:56,960 --> 00:41:03,599
life example of tcp fast open usage

00:41:00,960 --> 00:41:04,640
um i don't have one on the top of my

00:41:03,599 --> 00:41:06,800
head it's been

00:41:04,640 --> 00:41:08,079
some other community members that have

00:41:06,800 --> 00:41:11,920
been more active on that

00:41:08,079 --> 00:41:15,520
so i i mean i do know that like

00:41:11,920 --> 00:41:18,319
um you have a community member from

00:41:15,520 --> 00:41:19,359
apple who that's probably one of the

00:41:18,319 --> 00:41:21,520
probably the biggest

00:41:19,359 --> 00:41:23,280
mbtc deployment in the world that they

00:41:21,520 --> 00:41:26,720
they use for siri

00:41:23,280 --> 00:41:29,440
um and he's

00:41:26,720 --> 00:41:30,160
he's been very knowledgeable about tcp

00:41:29,440 --> 00:41:33,200
fast open

00:41:30,160 --> 00:41:36,240
and helping that happen so that's that's

00:41:33,200 --> 00:41:36,240
all i know on that front

00:41:37,920 --> 00:41:42,960
okay continuing uh the same question and

00:41:41,200 --> 00:41:45,119
what features functionalities are

00:41:42,960 --> 00:41:47,760
missing so we'll skip that

00:41:45,119 --> 00:41:49,520
how is mptcp better than quick slash

00:41:47,760 --> 00:41:53,440
http 3

00:41:49,520 --> 00:41:56,640
and is there http support for mptcp

00:41:53,440 --> 00:41:57,920
um yeah i mean i think mbtcp and quick

00:41:56,640 --> 00:42:00,000
each have their

00:41:57,920 --> 00:42:01,200
kind of benefits and drawbacks i mean i

00:42:00,000 --> 00:42:05,040
think the main thing about

00:42:01,200 --> 00:42:08,240
multi-path tcp is that it it is tcp

00:42:05,040 --> 00:42:10,480
um and in in terms of

00:42:08,240 --> 00:42:11,520
dealing with firewalls and things it's

00:42:10,480 --> 00:42:14,160
going to be

00:42:11,520 --> 00:42:17,280
handled that way um it does you know the

00:42:14,160 --> 00:42:19,040
way it uses option headers

00:42:17,280 --> 00:42:20,400
can lead to problems with some middle

00:42:19,040 --> 00:42:21,920
boxes

00:42:20,400 --> 00:42:24,960
so you know that's the trade-off in the

00:42:21,920 --> 00:42:24,960
other direction but

00:42:25,359 --> 00:42:30,480
i think kind of kind of the main

00:42:28,400 --> 00:42:31,760
way i think of it is that if you know if

00:42:30,480 --> 00:42:34,480
you've got things using a

00:42:31,760 --> 00:42:37,119
streaming socket today you know at the

00:42:34,480 --> 00:42:40,640
user api level in linux then

00:42:37,119 --> 00:42:43,440
you know they just deal with that

00:42:40,640 --> 00:42:44,000
a very similar socket um to make use of

00:42:43,440 --> 00:42:47,359
multiple

00:42:44,000 --> 00:42:48,720
tcp or or um

00:42:47,359 --> 00:42:52,240
i guess this is one other thing that's

00:42:48,720 --> 00:42:55,599
kind of in terms of future work like

00:42:52,240 --> 00:42:55,599
we're talking about using a

00:42:57,280 --> 00:43:02,000
bpf hook on the the socket call to be

00:43:00,079 --> 00:43:04,240
able to configure like per

00:43:02,000 --> 00:43:05,119
c group to just say well oh you

00:43:04,240 --> 00:43:08,400
requested

00:43:05,119 --> 00:43:12,240
tcp well we're we're just gonna

00:43:08,400 --> 00:43:14,400
switch that over to mptcp in the kernel

00:43:12,240 --> 00:43:16,400
and not have to make any changes to your

00:43:14,400 --> 00:43:19,599
program binary at all

00:43:16,400 --> 00:43:22,720
um http support for mptcp it's

00:43:19,599 --> 00:43:26,319
it's just it's at a lower level but yeah

00:43:22,720 --> 00:43:26,800
yeah it's http hooks up to the stream

00:43:26,319 --> 00:43:28,400
and

00:43:26,800 --> 00:43:32,400
whether that gets split across multiple

00:43:28,400 --> 00:43:32,400
subflows is just transparent

00:43:33,440 --> 00:43:36,160
so there was a second part where i

00:43:34,960 --> 00:43:38,160
should have read that i guess how many

00:43:36,160 --> 00:43:41,119
kernel level sockets are there is it one

00:43:38,160 --> 00:43:43,440
per user visible mptcp and one for each

00:43:41,119 --> 00:43:44,480
subfloor tcp subfloor is there some

00:43:43,440 --> 00:43:46,960
other number

00:43:44,480 --> 00:43:49,680
that's yeah that's exactly it so you

00:43:46,960 --> 00:43:52,800
when when a socket is created it creates

00:43:49,680 --> 00:43:55,839
an nptcp level socket that is

00:43:52,800 --> 00:43:58,000
the one facing user space and then

00:43:55,839 --> 00:43:58,960
for the initial connection that creates

00:43:58,000 --> 00:44:02,319
an underlying

00:43:58,960 --> 00:44:05,280
regular tcp socket um which

00:44:02,319 --> 00:44:06,480
you know being in the kernel it can do

00:44:05,280 --> 00:44:08,480
uh

00:44:06,480 --> 00:44:09,520
different things with to uh kind of

00:44:08,480 --> 00:44:13,680
hijack that for

00:44:09,520 --> 00:44:15,680
for multi-path purposes and customize it

00:44:13,680 --> 00:44:17,280
because there are some differences in

00:44:15,680 --> 00:44:19,839
the

00:44:17,280 --> 00:44:22,000
tcp semantics of a subflow versus a

00:44:19,839 --> 00:44:25,760
regular tcp

00:44:22,000 --> 00:44:28,720
connection um so i'm going to read the

00:44:25,760 --> 00:44:30,640
next two together because i think

00:44:28,720 --> 00:44:32,960
they're kind of related at least i think

00:44:30,640 --> 00:44:35,040
there is mptcp something like a reverse

00:44:32,960 --> 00:44:36,720
proxy for tcp connections to multiple

00:44:35,040 --> 00:44:39,200
interfaces and the next one is how does

00:44:36,720 --> 00:44:43,520
one load balance nptcp

00:44:39,200 --> 00:44:44,800
um um yeah i mean i guess

00:44:43,520 --> 00:44:46,640
i haven't really thought about it as a

00:44:44,800 --> 00:44:48,880
reverse proxy before just

00:44:46,640 --> 00:44:52,319
because everything's so yes the

00:44:48,880 --> 00:44:54,079
endpoints are kind of in control of the

00:44:52,319 --> 00:44:56,160
establishment and approval of those

00:44:54,079 --> 00:44:58,319
those different subflows there are

00:44:56,160 --> 00:45:00,400
i mean well i think one way that

00:44:58,319 --> 00:45:04,880
multibat tcp is used in

00:45:00,400 --> 00:45:08,000
in practice today is with um

00:45:04,880 --> 00:45:08,800
you know proxies that handle multi-path

00:45:08,000 --> 00:45:10,720
tcp

00:45:08,800 --> 00:45:12,480
you know on the public-facing ip side

00:45:10,720 --> 00:45:14,640
and then that just that gets

00:45:12,480 --> 00:45:16,800
proxy to a regular tcp connection that

00:45:14,640 --> 00:45:18,880
then the servers themselves

00:45:16,800 --> 00:45:20,240
are only dealing with regular tcp flows

00:45:18,880 --> 00:45:22,960
um

00:45:20,240 --> 00:45:24,560
there i i think there has been you know

00:45:22,960 --> 00:45:26,240
there's like research papers and things

00:45:24,560 --> 00:45:28,960
on load balancing and

00:45:26,240 --> 00:45:30,400
um i don't know much about the details

00:45:28,960 --> 00:45:33,760
but it does

00:45:30,400 --> 00:45:35,920
does certainly complicate like the

00:45:33,760 --> 00:45:37,599
example in the chat of uh

00:45:35,920 --> 00:45:40,560
the load balancer not seeing return

00:45:37,599 --> 00:45:42,319
traffic it's there would have to be

00:45:40,560 --> 00:45:44,319
communication of a bunch of multipath

00:45:42,319 --> 00:45:47,359
tcp state between the

00:45:44,319 --> 00:45:51,280
the proxy and the server and um i'm not

00:45:47,359 --> 00:45:51,280
aware of anyone having implemented that

00:45:52,400 --> 00:45:56,400
hey i'm going to inject interject on

00:45:54,800 --> 00:45:58,480
that question just a little bit

00:45:56,400 --> 00:45:59,680
i mean currently my understanding is

00:45:58,480 --> 00:46:02,560
that you're the sub

00:45:59,680 --> 00:46:04,640
the distribution to the sub flows is

00:46:02,560 --> 00:46:08,079
sort of a round robin

00:46:04,640 --> 00:46:10,240
model right or or sort of efficiency of

00:46:08,079 --> 00:46:14,079
the connection model

00:46:10,240 --> 00:46:18,160
right now yeah right now it's pretty

00:46:14,079 --> 00:46:20,079
simple where where it just kind of

00:46:18,160 --> 00:46:21,359
there's there are kind of there are two

00:46:20,079 --> 00:46:23,119
priority levels for

00:46:21,359 --> 00:46:24,720
a subflow they can be designated a

00:46:23,119 --> 00:46:28,079
backup flow

00:46:24,720 --> 00:46:31,520
or just a regular one and so

00:46:28,079 --> 00:46:34,960
right now when transmitting

00:46:31,520 --> 00:46:38,640
it'll just if if

00:46:34,960 --> 00:46:39,280
there are more than one non-backup flows

00:46:38,640 --> 00:46:41,440
it'll just

00:46:39,280 --> 00:46:43,599
try to use whatever's there it'll push

00:46:41,440 --> 00:46:45,119
as much data as it can and then

00:46:43,599 --> 00:46:47,040
if there's buffer space available on

00:46:45,119 --> 00:46:49,520
another one it'll try to send there

00:46:47,040 --> 00:46:50,640
and then if it'll ignore the backup

00:46:49,520 --> 00:46:52,560
flows in that scenario

00:46:50,640 --> 00:46:53,920
unless there's only backup flows in

00:46:52,560 --> 00:46:57,440
which case it will

00:46:53,920 --> 00:46:59,760
distribute among those

00:46:57,440 --> 00:47:00,720
right so i think so that was my point

00:46:59,760 --> 00:47:03,359
that maybe that's

00:47:00,720 --> 00:47:03,920
that's an area where the you could come

00:47:03,359 --> 00:47:06,960
up with

00:47:03,920 --> 00:47:07,920
more than just you know right yeah yeah

00:47:06,960 --> 00:47:10,240
so that's

00:47:07,920 --> 00:47:11,599
so so there's a an out of tree kernel

00:47:10,240 --> 00:47:15,119
that that

00:47:11,599 --> 00:47:16,880
has been in wider use that that does

00:47:15,119 --> 00:47:18,880
um it has kernel modules for packet

00:47:16,880 --> 00:47:21,599
schedulers and so we're

00:47:18,880 --> 00:47:22,640
kind of our plan is to you know try to

00:47:21,599 --> 00:47:27,040
do something bpf

00:47:22,640 --> 00:47:27,040
based to allow that to be customized

00:47:27,599 --> 00:47:32,480
make sense uh

00:47:30,720 --> 00:47:34,160
there was a follow-on comment that note

00:47:32,480 --> 00:47:34,800
that high band with load balancers do

00:47:34,160 --> 00:47:37,119
not see

00:47:34,800 --> 00:47:38,800
return traffic at the director turned in

00:47:37,119 --> 00:47:40,880
um

00:47:38,800 --> 00:47:42,720
fair but i think in this case it

00:47:40,880 --> 00:47:46,160
wouldn't really matter

00:47:42,720 --> 00:47:49,359
it's a source based load balancing um

00:47:46,160 --> 00:47:50,480
question what about evpf based path

00:47:49,359 --> 00:47:53,040
management i've seen

00:47:50,480 --> 00:47:53,680
some patches i've seen some patches

00:47:53,040 --> 00:47:56,800
posted

00:47:53,680 --> 00:47:59,839
these days to the mptcp list

00:47:56,800 --> 00:48:00,640
yeah the current round of epbf patches

00:47:59,839 --> 00:48:04,240
those are that's

00:48:00,640 --> 00:48:04,240
um that's an effort to

00:48:04,559 --> 00:48:08,960
support use of socket options on on the

00:48:07,599 --> 00:48:10,720
subflows

00:48:08,960 --> 00:48:14,319
configuration through ebpf it's not

00:48:10,720 --> 00:48:14,319
related to path management right now

00:48:16,400 --> 00:48:20,720
is that a sufficient answer there's a

00:48:19,200 --> 00:48:24,079
follow-up please

00:48:20,720 --> 00:48:24,319
please speak up uh another question what

00:48:24,079 --> 00:48:26,880
is

00:48:24,319 --> 00:48:29,200
the cpu overhead with respect to mptcp

00:48:26,880 --> 00:48:29,920
is the mptcp checksum normally disabled

00:48:29,200 --> 00:48:32,960
release

00:48:29,920 --> 00:48:36,559
cpu overhead

00:48:32,960 --> 00:48:38,319
um so today what's what's in kernel

00:48:36,559 --> 00:48:40,720
well any of the any of the upstream

00:48:38,319 --> 00:48:42,400
kernels we we don't support the mptcp

00:48:40,720 --> 00:48:45,440
checksum right now

00:48:42,400 --> 00:48:48,960
um it's always disabled

00:48:45,440 --> 00:48:51,280
and i think we talked about

00:48:48,960 --> 00:48:52,319
in you know having that option available

00:48:51,280 --> 00:48:56,079
in the future but

00:48:52,319 --> 00:48:56,079
i haven't haven't built that yet

00:48:58,559 --> 00:49:04,319
okay next question can we mix v4 and v6

00:49:02,720 --> 00:49:08,319
streams

00:49:04,319 --> 00:49:10,000
oh yeah multipath tcp does

00:49:08,319 --> 00:49:12,319
that that's part of the assumption is

00:49:10,000 --> 00:49:14,000
that you can when you advertise

00:49:12,319 --> 00:49:18,720
additional addresses that are available

00:49:14,000 --> 00:49:18,720
they can be a mix of v4 and v6

00:49:20,400 --> 00:49:23,680
actually that's an interesting question

00:49:21,920 --> 00:49:25,599
so that what

00:49:23,680 --> 00:49:26,720
you if i understood that right what

00:49:25,599 --> 00:49:28,640
you're saying is

00:49:26,720 --> 00:49:31,040
the user socket the user facing socket

00:49:28,640 --> 00:49:34,960
could be a v4 socket but you could be

00:49:31,040 --> 00:49:39,440
striping over a v4 and a v6 subfloor

00:49:34,960 --> 00:49:39,440
yeah that's pretty cool

00:49:40,079 --> 00:49:44,240
given mptcpd and kernel and ip commands

00:49:43,920 --> 00:49:46,319
can

00:49:44,240 --> 00:49:47,599
mptcp work with an unmodified

00:49:46,319 --> 00:49:51,520
application

00:49:47,599 --> 00:49:54,480
example can ssh sshd

00:49:51,520 --> 00:49:56,079
or like ssh or sshd or does every

00:49:54,480 --> 00:49:59,359
application need to be adjusted for even

00:49:56,079 --> 00:50:03,280
basic use

00:49:59,359 --> 00:50:04,880
yeah so there's um i think

00:50:03,280 --> 00:50:07,200
you know i mean there's always the kind

00:50:04,880 --> 00:50:10,960
of ld preload approach of

00:50:07,200 --> 00:50:12,880
um hijacking the the socket call and

00:50:10,960 --> 00:50:14,480
substituting the thing there

00:50:12,880 --> 00:50:16,640
and i think some people have been using

00:50:14,480 --> 00:50:19,760
that for testing purposes but

00:50:16,640 --> 00:50:21,280
um pretty much that and the the c group

00:50:19,760 --> 00:50:24,960
thing i mentioned earlier of

00:50:21,280 --> 00:50:28,880
of extending adding a secret bpf hook

00:50:24,960 --> 00:50:32,079
for the socket call could uh enable that

00:50:28,880 --> 00:50:36,240
in a way too um and

00:50:32,079 --> 00:50:39,599
like the uh the outer tree kernel

00:50:36,240 --> 00:50:42,319
that i mentioned that um has older

00:50:39,599 --> 00:50:43,119
support for mbtcp that that one just

00:50:42,319 --> 00:50:46,400
every socket

00:50:43,119 --> 00:50:48,880
was an mptcp socket but they also

00:50:46,400 --> 00:50:49,760
um they didn't have so there was that

00:50:48,880 --> 00:50:53,760
question earlier

00:50:49,760 --> 00:50:55,599
about having how many sockets are

00:50:53,760 --> 00:50:58,160
created in the kernel

00:50:55,599 --> 00:51:00,400
and so we didn't want to go the route of

00:50:58,160 --> 00:51:05,119
taking over every tcp connection because

00:51:00,400 --> 00:51:05,119
you do always have the intermediary

00:51:05,200 --> 00:51:08,240
mptcp socket talking to a lower level

00:51:07,680 --> 00:51:11,920
tcp

00:51:08,240 --> 00:51:13,440
socket that you know it is it is a

00:51:11,920 --> 00:51:15,760
more resource intensive thing than a

00:51:13,440 --> 00:51:19,280
regular tcp connection but

00:51:15,760 --> 00:51:20,960
um that said i think there are also

00:51:19,280 --> 00:51:22,880
people who's like well you know we could

00:51:20,960 --> 00:51:25,760
add this cis control

00:51:22,880 --> 00:51:26,400
to just say always use tcp or always use

00:51:25,760 --> 00:51:29,760
tcp

00:51:26,400 --> 00:51:33,839
for listening connections or

00:51:29,760 --> 00:51:33,839
as opposed to outgoing or things like

00:51:34,839 --> 00:51:40,160
that

00:51:37,200 --> 00:51:41,680
the question set keeps growing um good

00:51:40,160 --> 00:51:43,839
for us we have time so we

00:51:41,680 --> 00:51:46,160
will keep rolling with this for a while

00:51:43,839 --> 00:51:48,839
uh how does it work with net filters

00:51:46,160 --> 00:51:52,960
firewalls etc

00:51:48,839 --> 00:51:54,559
um well i mean

00:51:52,960 --> 00:51:56,480
in terms of firewalls it's gonna just

00:51:54,559 --> 00:51:59,359
show up as separate tcp

00:51:56,480 --> 00:52:01,839
flows um i don't know the net filter

00:51:59,359 --> 00:52:05,040
details

00:52:01,839 --> 00:52:06,880
i guess you just need to have policies

00:52:05,040 --> 00:52:08,480
adopt the sub flows right because that's

00:52:06,880 --> 00:52:11,040
the real problem

00:52:08,480 --> 00:52:12,319
if i was you know blocking an ip address

00:52:11,040 --> 00:52:14,000
and all the traffic came in on a

00:52:12,319 --> 00:52:15,200
subfloor ip address then i have to make

00:52:14,000 --> 00:52:17,200
sure that

00:52:15,200 --> 00:52:18,800
all my policies translate to whatever

00:52:17,200 --> 00:52:22,880
the subflows

00:52:18,800 --> 00:52:22,880
that are applicable are yeah

00:52:23,040 --> 00:52:26,160
there's a question about ld preload i

00:52:25,119 --> 00:52:29,520
think we

00:52:26,160 --> 00:52:30,880
we covered that thank you for the

00:52:29,520 --> 00:52:33,599
lightning talk

00:52:30,880 --> 00:52:35,040
bpf of course there's a question from

00:52:33,599 --> 00:52:38,000
tom but it's um oh

00:52:35,040 --> 00:52:39,920
well tom's question comes later um so

00:52:38,000 --> 00:52:41,839
since tom reserved the spot we'll ask

00:52:39,920 --> 00:52:44,720
his question first of all

00:52:41,839 --> 00:52:46,319
you see what tom did that uh mptcp

00:52:44,720 --> 00:52:48,160
proxies are an oxymoron

00:52:46,319 --> 00:52:52,240
what are the prospects of deploying this

00:52:48,160 --> 00:52:52,240
so we can eliminate these abominations

00:52:54,400 --> 00:53:01,040
i don't know tom

00:52:57,680 --> 00:53:03,520
douglas should speak more here okay so

00:53:01,040 --> 00:53:06,800
it's a little bit of a

00:53:03,520 --> 00:53:09,520
loaded question um so the

00:53:06,800 --> 00:53:11,119
these uh multi-path tcp proxies came up

00:53:09,520 --> 00:53:14,240
in ietf

00:53:11,119 --> 00:53:16,400
and they're like oh we need this as a

00:53:14,240 --> 00:53:18,720
stop gap because

00:53:16,400 --> 00:53:20,800
uh either the server side or client side

00:53:18,720 --> 00:53:24,000
doesn't support them

00:53:20,800 --> 00:53:25,520
and i looked at that and i said okay

00:53:24,000 --> 00:53:28,559
if you're going to call something a stop

00:53:25,520 --> 00:53:32,400
cap you need to show that

00:53:28,559 --> 00:53:35,200
you there's a plan to close it

00:53:32,400 --> 00:53:36,800
and they didn't have that plan so like

00:53:35,200 --> 00:53:37,200
anything else if you start deploying

00:53:36,800 --> 00:53:40,720
this

00:53:37,200 --> 00:53:43,839
then it's going to be there forever

00:53:40,720 --> 00:53:46,400
um but the the obvious problem here is

00:53:43,839 --> 00:53:48,000
it multi-path and yet forces us to go

00:53:46,400 --> 00:53:49,520
through a single point in the network so

00:53:48,000 --> 00:53:52,400
it kind of

00:53:49,520 --> 00:53:52,960
undermines the whole point of multi-path

00:53:52,400 --> 00:53:54,880
so

00:53:52,960 --> 00:53:56,240
so let me let me preface this by by

00:53:54,880 --> 00:53:57,280
saying first of all i think this work

00:53:56,240 --> 00:54:00,400
was great

00:53:57,280 --> 00:54:02,319
and you know kudos to the team

00:54:00,400 --> 00:54:04,559
for the persistence i know this was a

00:54:02,319 --> 00:54:07,359
really hard patch to get in the colonel

00:54:04,559 --> 00:54:08,960
um you guys stuck with it and you know i

00:54:07,359 --> 00:54:09,440
think that's absolutely fantastic it is

00:54:08,960 --> 00:54:11,119
a

00:54:09,440 --> 00:54:12,640
very good case study for how to get

00:54:11,119 --> 00:54:15,599
something complex

00:54:12,640 --> 00:54:17,119
um into into the kernel so it should uh

00:54:15,599 --> 00:54:20,319
should be used as that

00:54:17,119 --> 00:54:23,839
but now that it's in where do we go

00:54:20,319 --> 00:54:24,559
so who really needs to get this into

00:54:23,839 --> 00:54:26,160
deployment

00:54:24,559 --> 00:54:27,760
and how quickly can we get so maybe it's

00:54:26,160 --> 00:54:29,920
not so much uh

00:54:27,760 --> 00:54:30,880
a question for this but you know i'm

00:54:29,920 --> 00:54:33,760
thinking

00:54:30,880 --> 00:54:34,240
um zan can android pick this up quickly

00:54:33,760 --> 00:54:37,119
uh

00:54:34,240 --> 00:54:38,000
and then can we can we get the server

00:54:37,119 --> 00:54:39,280
guys uh google

00:54:38,000 --> 00:54:41,200
facebook or whatever to pick this up

00:54:39,280 --> 00:54:44,400
quickly too um

00:54:41,200 --> 00:54:47,920
with the intent of trying to

00:54:44,400 --> 00:54:50,480
preclude this complete uh universal

00:54:47,920 --> 00:54:52,240
deployment of multi-path proxies

00:54:50,480 --> 00:54:54,400
so i don't know if that's it's more of a

00:54:52,240 --> 00:54:56,160
philosophical question i guess but

00:54:54,400 --> 00:54:58,640
um if you have any short-term ideas how

00:54:56,160 --> 00:55:00,319
to influence deployment that would be

00:54:58,640 --> 00:55:03,839
good

00:55:00,319 --> 00:55:06,000
yeah um well i do know so

00:55:03,839 --> 00:55:07,119
as far as an android type of use case

00:55:06,000 --> 00:55:10,799
goes that

00:55:07,119 --> 00:55:12,319
i think is where we're still working on

00:55:10,799 --> 00:55:14,640
some of those client-side

00:55:12,319 --> 00:55:15,920
features of for especially for path

00:55:14,640 --> 00:55:18,880
management

00:55:15,920 --> 00:55:20,720
and uh like probably some lower level

00:55:18,880 --> 00:55:23,920
stuff about

00:55:20,720 --> 00:55:25,520
managing specific interfaces and data

00:55:23,920 --> 00:55:28,880
flowing to those

00:55:25,520 --> 00:55:32,640
i pasted a link in the chat of

00:55:28,880 --> 00:55:35,760
so red hat just published

00:55:32,640 --> 00:55:40,559
a information about a tech preview um

00:55:35,760 --> 00:55:45,200
for um their

00:55:40,559 --> 00:55:48,559
um support of this in their enterprise

00:55:45,200 --> 00:55:51,920
linux so they're

00:55:48,559 --> 00:55:55,440
working on that from the server side too

00:55:51,920 --> 00:55:56,880
um well it's going to be the client side

00:55:55,440 --> 00:55:57,599
that's going to be the harder one to get

00:55:56,880 --> 00:56:00,559
in right like

00:55:57,599 --> 00:56:00,559
right right

00:56:00,640 --> 00:56:04,720
but there are you know there are you

00:56:02,640 --> 00:56:07,599
know

00:56:04,720 --> 00:56:08,880
a very large number of uh mptcps

00:56:07,599 --> 00:56:12,480
supporting clients

00:56:08,880 --> 00:56:12,480
out there they're just not running linux

00:56:13,200 --> 00:56:18,720
so and they're not running multi-path

00:56:15,440 --> 00:56:18,720
tcp version one yet

00:56:20,240 --> 00:56:25,760
okay um i see jamal tried

00:56:23,440 --> 00:56:26,559
tom's trick but his question came in a

00:56:25,760 --> 00:56:29,440
little later

00:56:26,559 --> 00:56:31,280
but uh jamal says can you inject your

00:56:29,440 --> 00:56:32,240
own flow scheduling algorithm maybe

00:56:31,280 --> 00:56:35,040
using ebpf

00:56:32,240 --> 00:56:37,599
at the socket level and build cool load

00:56:35,040 --> 00:56:37,599
balancers

00:56:38,079 --> 00:56:42,079
yeah that's the plan to be able to do

00:56:40,000 --> 00:56:45,599
that

00:56:42,079 --> 00:56:47,760
but not yet i mean nothing

00:56:45,599 --> 00:56:49,599
nothing in the pipeline prevents you

00:56:47,760 --> 00:56:51,119
right because by the time your egress

00:56:49,599 --> 00:56:54,559
evpf runs

00:56:51,119 --> 00:56:58,480
it's just a tcp flow you well

00:56:54,559 --> 00:57:01,280
okay um so so it's this

00:56:58,480 --> 00:57:01,680
multi-path tcp socket that sits above

00:57:01,280 --> 00:57:03,920
that

00:57:01,680 --> 00:57:05,440
the tcp subflows that that actually

00:57:03,920 --> 00:57:09,200
decides which

00:57:05,440 --> 00:57:12,319
which subflow socket to transmit on

00:57:09,200 --> 00:57:14,559
um so it that there's a decision

00:57:12,319 --> 00:57:16,640
happening at that level that

00:57:14,559 --> 00:57:18,000
yeah we're talking about using eppf to

00:57:16,640 --> 00:57:21,119
determine

00:57:18,000 --> 00:57:24,400
which subflow socket it goes to

00:57:21,119 --> 00:57:28,079
make sense well middle boxes like

00:57:24,400 --> 00:57:32,559
cellular pps uh usually drop

00:57:28,079 --> 00:57:34,960
mptcp options it's a very good question

00:57:32,559 --> 00:57:36,880
um i don't know i mean from from what

00:57:34,960 --> 00:57:40,480
i've heard from large deployments

00:57:36,880 --> 00:57:44,079
that that it's a fairly large

00:57:40,480 --> 00:57:46,079
percentage of uh of the connections that

00:57:44,079 --> 00:57:47,440
succeed so so multi-path tcp at

00:57:46,079 --> 00:57:50,640
connection time

00:57:47,440 --> 00:57:52,240
if it senses a middle box messing around

00:57:50,640 --> 00:57:54,319
with

00:57:52,240 --> 00:57:56,799
the mpdcp options it'll it'll just

00:57:54,319 --> 00:57:59,920
succeed as a tcp connection

00:57:56,799 --> 00:58:03,119
and they keep stats on that and

00:57:59,920 --> 00:58:06,240
and it's still i can't remember if it's

00:58:03,119 --> 00:58:09,440
in in the 90 range

00:58:06,240 --> 00:58:12,319
um of things succeeding so

00:58:09,440 --> 00:58:14,640
it's uh since it is widely used on a

00:58:12,319 --> 00:58:15,520
popular mobile platform i think a lot of

00:58:14,640 --> 00:58:18,160
that has been

00:58:15,520 --> 00:58:18,160
straightened out

00:58:19,040 --> 00:58:26,079
i see but but you don't know of any

00:58:22,880 --> 00:58:28,400
places where the the sin options or the

00:58:26,079 --> 00:58:30,319
options and the sameness

00:58:28,400 --> 00:58:32,079
has been dropped and nptcp therefore

00:58:30,319 --> 00:58:35,839
could not work

00:58:32,079 --> 00:58:36,240
um i not not specific ones i mean i know

00:58:35,839 --> 00:58:39,119
that

00:58:36,240 --> 00:58:41,520
the middle box problems do do crop up

00:58:39,119 --> 00:58:41,520
and then

00:58:43,920 --> 00:58:48,839
there's been a bunch of studies which

00:58:45,440 --> 00:58:51,920
showed it's pretty safe most of the time

00:58:48,839 --> 00:58:54,160
yeah yeah i mean we know metal boxes

00:58:51,920 --> 00:58:57,200
exist to create problems but

00:58:54,160 --> 00:59:00,160
this one might be safe um okay

00:58:57,200 --> 00:59:01,760
uh jamal you had a follow-up on your

00:59:00,160 --> 00:59:03,680
comment which is now you can do

00:59:01,760 --> 00:59:05,440
clever load balancing by using netlink

00:59:03,680 --> 00:59:07,680
apis

00:59:05,440 --> 00:59:08,480
which i think is your user space

00:59:07,680 --> 00:59:10,160
solution

00:59:08,480 --> 00:59:12,480
yeah i was wondering if you just listen

00:59:10,160 --> 00:59:14,319
to the network events and

00:59:12,480 --> 00:59:16,240
consult your user space scheduling

00:59:14,319 --> 00:59:18,880
algorithm and then decide where

00:59:16,240 --> 00:59:19,520
which interface that subfloor should go

00:59:18,880 --> 00:59:21,760
to

00:59:19,520 --> 00:59:22,720
and that will achieve your own home

00:59:21,760 --> 00:59:25,680
cooked

00:59:22,720 --> 00:59:25,680
load balancer right

00:59:28,660 --> 00:59:34,240
[Music]

00:59:31,599 --> 00:59:36,799
so there are two two questions which

00:59:34,240 --> 00:59:39,839
again i think are related in some sense

00:59:36,799 --> 00:59:41,200
uh question about does contract work on

00:59:39,839 --> 00:59:43,200
fptcp

00:59:41,200 --> 00:59:44,720
and the second is how could could you

00:59:43,200 --> 00:59:46,720
use different congestion control

00:59:44,720 --> 00:59:47,680
managers for subfloors and queue become

00:59:46,720 --> 00:59:50,720
one and

00:59:47,680 --> 00:59:50,720
b are on the other

00:59:51,520 --> 00:59:58,079
um yeah i don't i i haven't

00:59:54,720 --> 01:00:00,640
tried anything with contract um

00:59:58,079 --> 01:00:02,319
so i i think there's people in the

01:00:00,640 --> 01:00:03,280
community who can answer that better

01:00:02,319 --> 01:00:06,160
than me

01:00:03,280 --> 01:00:08,400
um so if yeah yeah if you want to find

01:00:06,160 --> 01:00:10,880
us on irc or our mailing list

01:00:08,400 --> 01:00:11,839
i think we could get an answer for you

01:00:10,880 --> 01:00:14,799
um

01:00:11,839 --> 01:00:16,720
for the different congestion controllers

01:00:14,799 --> 01:00:17,599
yeah our main limitation there right now

01:00:16,720 --> 01:00:20,640
is just the

01:00:17,599 --> 01:00:21,520
like the the user space doesn't have a

01:00:20,640 --> 01:00:25,839
way to

01:00:21,520 --> 01:00:26,720
direct a you know configuration to one

01:00:25,839 --> 01:00:29,760
specific

01:00:26,720 --> 01:00:30,400
subflow but it's certainly yeah that

01:00:29,760 --> 01:00:32,160
since the tub

01:00:30,400 --> 01:00:34,079
subflows are each independent tcp

01:00:32,160 --> 01:00:37,119
connections they they can be

01:00:34,079 --> 01:00:37,119
independently configured

01:00:38,240 --> 01:00:45,380
for congestion control

01:00:42,240 --> 01:00:46,720
yeah okay uh

01:00:45,380 --> 01:00:49,760
[Music]

01:00:46,720 --> 01:00:51,520
uh alex has i seems i missed an answer

01:00:49,760 --> 01:00:54,640
how is mptcp better than

01:00:51,520 --> 01:00:57,680
quick http 3 we covered that right and

01:00:54,640 --> 01:01:00,640
is that http support for nptcp

01:00:57,680 --> 01:01:04,160
right yeah well i mean definitely there

01:01:00,640 --> 01:01:07,359
is http sort to repeat that one and

01:01:04,160 --> 01:01:10,559
and there

01:01:07,359 --> 01:01:10,880
yeah i think there's just yeah i don't

01:01:10,559 --> 01:01:14,240
want to

01:01:10,880 --> 01:01:14,240
rehash on the trade off

01:01:15,040 --> 01:01:19,280
um jamal saying sd-wan would be a good

01:01:18,079 --> 01:01:23,359
use case

01:01:19,280 --> 01:01:26,640
uh this is really cool good talk is

01:01:23,359 --> 01:01:28,880
i second that i just don't see how this

01:01:26,640 --> 01:01:30,079
is usable on a large-scale server farm

01:01:28,880 --> 01:01:33,040
with tcmp and

01:01:30,079 --> 01:01:33,920
four-way four-to-four hash hashing load

01:01:33,040 --> 01:01:35,599
balances

01:01:33,920 --> 01:01:37,839
which are two levels of flow balancing

01:01:35,599 --> 01:01:42,160
which will have sub flows to different

01:01:37,839 --> 01:01:42,160
end servers for actual tcp termination

01:01:47,280 --> 01:01:53,680
yeah i think it would

01:01:52,160 --> 01:01:56,000
require some different approaches i

01:01:53,680 --> 01:01:58,799
don't i don't have anything specific to

01:01:56,000 --> 01:01:58,799
suggest on that

01:02:00,960 --> 01:02:05,440
how would re-transmit work for loss in

01:02:03,280 --> 01:02:07,520
one subflow we'll

01:02:05,440 --> 01:02:09,280
cover this one as well right will it be

01:02:07,520 --> 01:02:09,920
transmitted in the same subfloor okay

01:02:09,280 --> 01:02:12,559
now this is

01:02:09,920 --> 01:02:14,640
a spin on it will it be retransmitted in

01:02:12,559 --> 01:02:17,359
the same subfloor different subfloor in

01:02:14,640 --> 01:02:20,000
a multi-sub flow

01:02:17,359 --> 01:02:21,839
yeah so the the mpdcp level

01:02:20,000 --> 01:02:22,160
re-transmission that pretty much happens

01:02:21,839 --> 01:02:25,119
when

01:02:22,160 --> 01:02:28,960
like one subflow so if if a piece of

01:02:25,119 --> 01:02:33,039
data was only transmitted on one subflow

01:02:28,960 --> 01:02:36,400
that if that's not moving forward then

01:02:33,039 --> 01:02:39,599
you know it's it wouldn't it would

01:02:36,400 --> 01:02:41,520
be you know stuck on the

01:02:39,599 --> 01:02:42,960
transmit side it wouldn't have any you

01:02:41,520 --> 01:02:44,960
know wouldn't be able to push anything

01:02:42,960 --> 01:02:48,000
else into the buffer so it would

01:02:44,960 --> 01:02:49,760
it would end up going somewhere else i

01:02:48,000 --> 01:02:50,720
mean there's room there for more smarts

01:02:49,760 --> 01:02:52,720
on

01:02:50,720 --> 01:02:55,599
keeping track of which data went on

01:02:52,720 --> 01:02:57,839
which subflow and

01:02:55,599 --> 01:03:00,079
optimizing that a bit but it yeah it

01:02:57,839 --> 01:03:00,079
will

01:03:00,160 --> 01:03:03,920
typically go to a different different

01:03:02,000 --> 01:03:05,119
subflow which is the

01:03:03,920 --> 01:03:07,760
kind of the purpose of having the

01:03:05,119 --> 01:03:07,760
multiple ones

01:03:09,760 --> 01:03:13,280
uh somebody answered one of the

01:03:11,760 --> 01:03:15,680
questions one of the benefits of quick

01:03:13,280 --> 01:03:17,760
for http is that it's per stream flow so

01:03:15,680 --> 01:03:20,160
there is my head of line blocking

01:03:17,760 --> 01:03:22,640
doesn't sound like http over mbtc people

01:03:20,160 --> 01:03:22,640
get that

01:03:22,799 --> 01:03:27,839
yeah say that's accurate uh

01:03:26,000 --> 01:03:30,559
question the tutorial on the website is

01:03:27,839 --> 01:03:31,599
from 2013 is it still valid does it

01:03:30,559 --> 01:03:35,359
still work

01:03:31,599 --> 01:03:38,960
oh yeah that um that tutorial applies

01:03:35,359 --> 01:03:42,000
to the um the out of

01:03:38,960 --> 01:03:43,680
out of tree kernel which

01:03:42,000 --> 01:03:45,920
which is different in terms of how it

01:03:43,680 --> 01:03:47,839
handles

01:03:45,920 --> 01:03:49,039
user space apis you know like i said it

01:03:47,839 --> 01:03:52,960
takes over every tcp

01:03:49,039 --> 01:03:55,839
connection that handles path management

01:03:52,960 --> 01:03:57,520
scheduling and things differently

01:03:55,839 --> 01:03:59,520
so just be aware of that when you're

01:03:57,520 --> 01:04:00,400
looking up multi-path tcp for linux at

01:03:59,520 --> 01:04:03,440
the

01:04:00,400 --> 01:04:06,160
the upstream side versus the this stuff

01:04:03,440 --> 01:04:07,599
at multipath tcp.org

01:04:06,160 --> 01:04:09,280
i mean we have a lot of overlap in the

01:04:07,599 --> 01:04:12,400
teams even but

01:04:09,280 --> 01:04:13,599
um we did make different decisions

01:04:12,400 --> 01:04:16,079
because that that

01:04:13,599 --> 01:04:17,680
the out of tree kernel was you know a

01:04:16,079 --> 01:04:21,359
test bed for the protocol

01:04:17,680 --> 01:04:22,960
and and kind of had the

01:04:21,359 --> 01:04:24,640
approach of trying to look at it from

01:04:22,960 --> 01:04:24,880
the perspective of okay we're just going

01:04:24,640 --> 01:04:26,799
to

01:04:24,880 --> 01:04:29,280
take over every tcp connection and add

01:04:26,799 --> 01:04:32,160
this capability versus with upstream

01:04:29,280 --> 01:04:32,880
um we had a different set of trade-offs

01:04:32,160 --> 01:04:36,319
in order to

01:04:32,880 --> 01:04:38,640
to get it upstream and and work the way

01:04:36,319 --> 01:04:38,640
that the

01:04:38,839 --> 01:04:44,880
the maintainers we're

01:04:42,240 --> 01:04:44,880
comfortable with

01:04:49,359 --> 01:04:53,359
i think we might be done

01:04:53,680 --> 01:04:57,599
all right well thank you once again it

01:04:56,079 --> 01:04:59,520
was a good talk clearly

01:04:57,599 --> 01:05:01,359
lots of interest and clearly an area

01:04:59,520 --> 01:05:04,079
that has been

01:05:01,359 --> 01:05:06,240
that's taken years and a lot of effort

01:05:04,079 --> 01:05:09,839
but i think the end result is

01:05:06,240 --> 01:05:09,839

YouTube URL: https://www.youtube.com/watch?v=3EgtS-lwzso


