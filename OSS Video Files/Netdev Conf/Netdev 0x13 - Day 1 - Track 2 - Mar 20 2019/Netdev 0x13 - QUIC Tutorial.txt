Title: Netdev 0x13 - QUIC Tutorial
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 1 - Track 2 - Mar 20 2019
Description: 
	QUIC guru Jana Iyengar gave  a tutorial at netdev 0x13.

Quick UDP Internet Connections, pronounced 'quick' is a new important transport which is growing at a phenomenal rate. Studies have shown by November 2017, QUIC
already represented 20% of the total mobile traffic[1] and grew over 200% in two years.
There are other advantages for QUIC; refer to 0x12 talk[2]. 

QUIC is implemented on top of UDP making it much easier to deploy improvements
and fixes when compared to TCP which is in the kernel (and therefore requires
kernel patch submissions and process overhead).

More info:
https://netdevconf.org/0x13/session.html?tutorial-QUIC

[1]https://owmobility.com/blog/meteoric-rise-google-quic-worrying-mobile-operators/
[2]https://www.netdevconf.org/0x12/session.html?quic-developing-and-deploying-a-tcp-replacement-for-the-web
Captions: 
	00:00:00,000 --> 00:00:08,370
um I will I will get started now welcome

00:00:04,350 --> 00:00:11,130
and thank you for showing up I will be

00:00:08,370 --> 00:00:13,830
talking about quick and if you were at

00:00:11,130 --> 00:00:15,770
last year's net dev that's gonna be some

00:00:13,830 --> 00:00:18,900
of that material that's rehashed here

00:00:15,770 --> 00:00:21,869
but hopefully not too much but I will

00:00:18,900 --> 00:00:24,539
start off with a general sort of an

00:00:21,869 --> 00:00:26,640
introduction to quake so the plan here

00:00:24,539 --> 00:00:29,369
is to have a general introduction to

00:00:26,640 --> 00:00:31,199
quick an overview and what quake is in

00:00:29,369 --> 00:00:34,050
this part pre-lunch

00:00:31,199 --> 00:00:35,489
and post-lunch I'll dive into the

00:00:34,050 --> 00:00:37,760
details of the protocol some of the

00:00:35,489 --> 00:00:41,219
details of the protocol I'll dive into

00:00:37,760 --> 00:00:45,239
an open source implementation and I will

00:00:41,219 --> 00:00:47,070
talk about how how you might write an

00:00:45,239 --> 00:00:49,050
example up a sample application I might

00:00:47,070 --> 00:00:51,480
if I have enough time I'll do a code

00:00:49,050 --> 00:00:55,649
read-through of a sample application and

00:00:51,480 --> 00:00:58,199
I'll show you how I basically run it and

00:00:55,649 --> 00:01:00,930
show you some packet traces from that

00:00:58,199 --> 00:01:02,510
run so that's the that's the goal so

00:01:00,930 --> 00:01:04,409
this first part is just basically me

00:01:02,510 --> 00:01:07,229
talking through things and then maybe

00:01:04,409 --> 00:01:09,990
the second part would be more hands-on

00:01:07,229 --> 00:01:13,320
if you are interested but yeah that's

00:01:09,990 --> 00:01:16,170
the goal this tutorial was supposed to

00:01:13,320 --> 00:01:19,920
be me along with Ian sweat from Google

00:01:16,170 --> 00:01:23,100
but he's decided that he's going to pass

00:01:19,920 --> 00:01:24,780
on this hold on to his family though

00:01:23,100 --> 00:01:27,299
he's gonna be here for next week also

00:01:24,780 --> 00:01:29,759
for the IETF I'm kidding about that but

00:01:27,299 --> 00:01:31,320
he's it's he's unfortunately you're

00:01:29,759 --> 00:01:32,009
stuck listening to my voice for an hour

00:01:31,320 --> 00:01:34,020
and a half

00:01:32,009 --> 00:01:37,049
hopefully it's not too boring and I'll

00:01:34,020 --> 00:01:42,570
try to keep it quick and going forward

00:01:37,049 --> 00:01:44,820
fast so i'm i work at fastly and my

00:01:42,570 --> 00:01:47,009
colleague Kazoku who also works at

00:01:44,820 --> 00:01:49,590
fastly helped me with some of the with a

00:01:47,009 --> 00:01:54,390
bunch of material here so much thanks to

00:01:49,590 --> 00:01:58,049
him how many of you are familiar with

00:01:54,390 --> 00:02:02,540
quick how many of you have never heard

00:01:58,049 --> 00:02:05,490
about quick yeah right

00:02:02,540 --> 00:02:06,900
all right well good enough if you

00:02:05,490 --> 00:02:08,190
haven't you should be ashamed you're

00:02:06,900 --> 00:02:10,319
right to not raise your hand

00:02:08,190 --> 00:02:13,069
google it look it up I'll start with a

00:02:10,319 --> 00:02:15,840
very quick history of what-what quick is

00:02:13,069 --> 00:02:18,870
just basically a protocol for HTTP

00:02:15,840 --> 00:02:21,000
transport and it was deployed at Google

00:02:18,870 --> 00:02:23,580
starting in 2014 so full disclosure I

00:02:21,000 --> 00:02:28,350
used to work at Google and and I moved

00:02:23,580 --> 00:02:30,840
to fastly about a year ago and this some

00:02:28,350 --> 00:02:36,360
of this stuff is data that was generated

00:02:30,840 --> 00:02:38,480
while I was at Google so the protocol

00:02:36,360 --> 00:02:41,130
was deployed between Google services and

00:02:38,480 --> 00:02:43,920
Chrome and mobile apps so we basically

00:02:41,130 --> 00:02:45,870
had control Google had control over all

00:02:43,920 --> 00:02:47,580
the service and also over chrome and

00:02:45,870 --> 00:02:49,950
over first-party mobile apps like

00:02:47,580 --> 00:02:52,470
YouTube application Google Search app on

00:02:49,950 --> 00:02:54,840
Android and so on and quic was deployed

00:02:52,470 --> 00:02:58,260
as an application-level transport

00:02:54,840 --> 00:03:00,690
sitting on top of UDP on both sides and

00:02:58,260 --> 00:03:05,100
the performance benefit that we started

00:03:00,690 --> 00:03:09,959
to see was was good and it was so good

00:03:05,100 --> 00:03:15,600
that we basically turned on turn it on

00:03:09,959 --> 00:03:17,640
to basically 100% of what we could which

00:03:15,600 --> 00:03:20,160
meant that it became about 35 more than

00:03:17,640 --> 00:03:22,920
35 percent of Google's egress traffic in

00:03:20,160 --> 00:03:27,900
bytes was was quick and this is from

00:03:22,920 --> 00:03:30,269
these numbers are from two years ago but

00:03:27,900 --> 00:03:32,100
yes it improved application performance

00:03:30,269 --> 00:03:36,420
specifically YouTube video rebuffed errs

00:03:32,100 --> 00:03:38,549
and Google search latency by quite a bit

00:03:36,420 --> 00:03:41,100
as you can see and these numbers are

00:03:38,549 --> 00:03:42,870
actually substantial partly because they

00:03:41,100 --> 00:03:45,090
are not micro benchmarks their

00:03:42,870 --> 00:03:46,920
end-to-end measures so changing a

00:03:45,090 --> 00:03:49,260
transfer protocol changed the end-to-end

00:03:46,920 --> 00:03:51,989
application level quality of experience

00:03:49,260 --> 00:03:54,120
metrics significantly and again Google

00:03:51,989 --> 00:03:57,120
search latency it's not it's no it's no

00:03:54,120 --> 00:03:59,150
small task to change one of the most

00:03:57,120 --> 00:04:01,920
optimized applications on the planet and

00:03:59,150 --> 00:04:05,730
being able to move it by that that

00:04:01,920 --> 00:04:08,670
amount was quite significant and since

00:04:05,730 --> 00:04:10,810
then we formed an ITF working group to

00:04:08,670 --> 00:04:12,310
module rise under standardized

00:04:10,810 --> 00:04:15,069
of quick and I'll talk a little bit more

00:04:12,310 --> 00:04:18,130
about that later but that's that that

00:04:15,069 --> 00:04:20,230
became the goal of it so what are we

00:04:18,130 --> 00:04:21,190
talking about just let's go back to

00:04:20,230 --> 00:04:24,160
basics for a moment

00:04:21,190 --> 00:04:27,040
that's our traditional well known well

00:04:24,160 --> 00:04:29,470
understood HTTP tag that you know half

00:04:27,040 --> 00:04:31,180
of this room tries to optimize TCP for

00:04:29,470 --> 00:04:34,230
because let's face it

00:04:31,180 --> 00:04:38,200
what's TCP being used for if not HTTP

00:04:34,230 --> 00:04:40,600
practically nothing else but that's the

00:04:38,200 --> 00:04:43,570
stack that we have in love and use the

00:04:40,600 --> 00:04:48,790
most and what quake does is effectively

00:04:43,570 --> 00:04:52,389
replaces a big chunk of that stack so

00:04:48,790 --> 00:04:54,910
two places TCP entire link at the place

00:04:52,389 --> 00:04:56,919
it doesn't replace TLS but it sort of

00:04:54,910 --> 00:04:59,919
encapsulate sit in an interesting way

00:04:56,919 --> 00:05:05,440
and it it replaces a whole bunch of what

00:04:59,919 --> 00:05:08,139
HTTP 2 provided for HTTP so it subsumes

00:05:05,440 --> 00:05:12,610
a lot of that functionality and running

00:05:08,139 --> 00:05:14,139
HTTP on top of quick is now hvp 3 so the

00:05:12,610 --> 00:05:17,650
version of HTTP that runs on top of

00:05:14,139 --> 00:05:19,630
quake is a it's slightly it's it's

00:05:17,650 --> 00:05:21,160
different it's quite different than HTTP

00:05:19,630 --> 00:05:23,130
2 because as I said much of that

00:05:21,160 --> 00:05:26,140
functionality has been subsumed in quick

00:05:23,130 --> 00:05:31,330
so the mapping of HTTP on top of quick

00:05:26,140 --> 00:05:32,710
is HTTP 3 and TLS 1.3 is basically as

00:05:31,330 --> 00:05:36,010
you can see here it's embedded

00:05:32,710 --> 00:05:37,539
effectively in quick and it I can talk

00:05:36,010 --> 00:05:38,860
more about this mapping but I'll move on

00:05:37,539 --> 00:05:41,440
and if you have questions please feel

00:05:38,860 --> 00:05:47,710
free to raise your hand I have a mic

00:05:41,440 --> 00:05:50,110
here that feels very lonely all right so

00:05:47,710 --> 00:05:52,630
these are the IETF internet drafts

00:05:50,110 --> 00:05:55,020
you're welcome to go read them if you

00:05:52,630 --> 00:06:00,120
feel like you are unable to fall asleep

00:05:55,020 --> 00:06:00,120
or if you enjoy hurting yourself badly

00:06:00,479 --> 00:06:06,400
but I want to very briefly start with

00:06:03,400 --> 00:06:09,010
basically what I call the HTTP story so

00:06:06,400 --> 00:06:11,229
if just just looking back a bit then to

00:06:09,010 --> 00:06:12,700
place all of this in context right what

00:06:11,229 --> 00:06:17,919
is quic coming from where is this coming

00:06:12,700 --> 00:06:20,770
from and why are we working on this HDB

00:06:17,919 --> 00:06:23,380
have it goes back for the beyond that of

00:06:20,770 --> 00:06:24,639
course but HTTP 1.0 1.1 happened in the

00:06:23,380 --> 00:06:28,569
late 90s

00:06:24,639 --> 00:06:30,400
and that was an HTTP ng effort there was

00:06:28,569 --> 00:06:32,289
a working group and a big effort in the

00:06:30,400 --> 00:06:36,099
late 90s and early 2000s anybody

00:06:32,289 --> 00:06:38,250
remember the HTTP ng effort anybody here

00:06:36,099 --> 00:06:41,259
a part of this effort at all

00:06:38,250 --> 00:06:42,819
no there was it there's a pretty big

00:06:41,259 --> 00:06:45,220
push at the time to try and figure out

00:06:42,819 --> 00:06:47,860
how to solve the problems that that was

00:06:45,220 --> 00:06:52,720
seen in HTTP and I won't list them all

00:06:47,860 --> 00:06:54,870
here but eventually much much later HTTP

00:06:52,720 --> 00:06:58,889
2 showed up a few years ago as a

00:06:54,870 --> 00:07:02,169
standard and HTTP 2 introduced notions

00:06:58,889 --> 00:07:03,759
such as streams and multiplexing of

00:07:02,169 --> 00:07:05,830
objects now all of you are familiar with

00:07:03,759 --> 00:07:08,800
the TCP problem of head-of-line blocking

00:07:05,830 --> 00:07:11,560
yeah these BC realizes everything that

00:07:08,800 --> 00:07:13,539
sent down that connection and the

00:07:11,560 --> 00:07:15,610
receiver if there's a if there's a loss

00:07:13,539 --> 00:07:17,289
the receiver holds on to packets that

00:07:15,610 --> 00:07:19,990
are received later cannot deliver them

00:07:17,289 --> 00:07:23,949
up to the application until the loss is

00:07:19,990 --> 00:07:25,810
repaired and in HTTP you typically send

00:07:23,949 --> 00:07:28,180
a whole bunch of different objects into

00:07:25,810 --> 00:07:32,169
the same connection and the receiver

00:07:28,180 --> 00:07:34,000
even if that lost packet does not belong

00:07:32,169 --> 00:07:36,639
to the same object as subsequent packets

00:07:34,000 --> 00:07:39,759
subject subsequent packets are still

00:07:36,639 --> 00:07:40,930
held in the TCP buffers so this is

00:07:39,759 --> 00:07:46,000
head-of-line blocking that TCP

00:07:40,930 --> 00:07:48,550
introduces and HTTP - sorry HTTP ng was

00:07:46,000 --> 00:07:50,740
trying to solve these problems some of

00:07:48,550 --> 00:07:54,580
these problems got solved with HTTP - a

00:07:50,740 --> 00:07:56,259
few years ago but that was basically you

00:07:54,580 --> 00:07:59,680
know like I said streams and

00:07:56,259 --> 00:08:01,000
multiplexing that allows multiple

00:07:59,680 --> 00:08:04,680
objects to be sent on the same

00:08:01,000 --> 00:08:08,139
connection but interleaved and then

00:08:04,680 --> 00:08:11,139
introduces flow control per stream

00:08:08,139 --> 00:08:13,479
effectively and priorities across

00:08:11,139 --> 00:08:15,460
multiple objects so the idea and HTTP 2

00:08:13,479 --> 00:08:18,069
was to use one connection more

00:08:15,460 --> 00:08:21,190
efficiently for multiple objects with

00:08:18,069 --> 00:08:22,719
HTTP 1 1 objects are sent back to back a

00:08:21,190 --> 00:08:24,099
whole object is sent and the subs' in

00:08:22,719 --> 00:08:26,740
the next object is requested and then

00:08:24,099 --> 00:08:28,750
sent behind that they should be -

00:08:26,740 --> 00:08:30,250
interleaves multiple objects so you can

00:08:28,750 --> 00:08:32,829
receive multiple requests at the same

00:08:30,250 --> 00:08:34,690
time so multiple objects at the same

00:08:32,829 --> 00:08:35,800
time and by the at the same time I mean

00:08:34,690 --> 00:08:40,539
multiply

00:08:35,800 --> 00:08:43,779
on the same connection there's a big gap

00:08:40,539 --> 00:08:48,670
right there right from the 90s to a few

00:08:43,779 --> 00:08:50,199
years ago massive gap I don't know not a

00:08:48,670 --> 00:08:52,180
lot really happened in the HTTP

00:08:50,199 --> 00:08:54,959
community all the time now you folks

00:08:52,180 --> 00:08:56,550
might be more familiar with this

00:08:54,959 --> 00:09:03,629
schedule

00:08:56,550 --> 00:09:06,040
anybody remember TD CP here oh come on

00:09:03,629 --> 00:09:08,410
I'm seeing some nods that's good enough

00:09:06,040 --> 00:09:10,629
for me so what happened in transport

00:09:08,410 --> 00:09:12,759
world around we were also trying to

00:09:10,629 --> 00:09:14,050
solve problems similar problems we were

00:09:12,759 --> 00:09:15,819
trying some of the problems was shared

00:09:14,050 --> 00:09:18,040
in similar we tried to solve similar

00:09:15,819 --> 00:09:20,470
problems TD CP was one of the things

00:09:18,040 --> 00:09:22,449
that was proposed it was proposed in 94

00:09:20,470 --> 00:09:26,170
anybody can can anybody tell me what TDC

00:09:22,449 --> 00:09:45,189
be solved what's the problem that it

00:09:26,170 --> 00:09:46,629
solves yep yep sure yep so TTC B

00:09:45,189 --> 00:09:49,029
basically eliminates the handshake

00:09:46,629 --> 00:09:51,670
latency so it was going after a

00:09:49,029 --> 00:09:53,379
particular type of traffic which is

00:09:51,670 --> 00:09:55,089
small objects right because that's where

00:09:53,379 --> 00:09:58,930
the handshake latency plays in the most

00:09:55,089 --> 00:10:02,110
and guess what the web is made of a lot

00:09:58,930 --> 00:10:04,569
of small objects so that handshake

00:10:02,110 --> 00:10:07,269
latency really hurts when I'm talking

00:10:04,569 --> 00:10:08,889
about web traffic and HTTP 2 was trying

00:10:07,269 --> 00:10:10,449
to solve go after that problem in a

00:10:08,889 --> 00:10:12,250
different way by trying to say let's put

00:10:10,449 --> 00:10:13,509
more objects in the same connection same

00:10:12,250 --> 00:10:16,000
thing HTTP 1 1 did

00:10:13,509 --> 00:10:17,649
how anyways T TCP was trying to solve a

00:10:16,000 --> 00:10:18,850
similar problem was basically trying to

00:10:17,649 --> 00:10:22,120
eliminate handshake latency and

00:10:18,850 --> 00:10:25,240
effectively later on sort of jumped and

00:10:22,120 --> 00:10:28,089
showed up again in 2009 as TCP fast open

00:10:25,240 --> 00:10:30,509
and you may be familiar with that and

00:10:28,089 --> 00:10:32,620
that's basically doing the same thing

00:10:30,509 --> 00:10:36,550
it's just become more important to us

00:10:32,620 --> 00:10:39,100
now but then we had other things as well

00:10:36,550 --> 00:10:41,679
which were trying to make TCP better for

00:10:39,100 --> 00:10:43,089
web traffic and not even focus just on

00:10:41,679 --> 00:10:45,250
web traffic but they were effectively

00:10:43,089 --> 00:10:47,139
all the efforts were what they were

00:10:45,250 --> 00:10:48,610
trying to do would make web traffic work

00:10:47,139 --> 00:10:51,459
much better with TCP

00:10:48,610 --> 00:10:53,139
and there's a big gap again and then

00:10:51,459 --> 00:10:56,350
there are some proposals and then PCP

00:10:53,139 --> 00:11:01,809
fast open happens and TCP fast open

00:10:56,350 --> 00:11:04,239
happens in 2009 and can anybody tell me

00:11:01,809 --> 00:11:06,249
how widely TCP fast open is deployed

00:11:04,239 --> 00:11:07,720
anybody here by the way how many people

00:11:06,249 --> 00:11:09,670
here know TCP fast open I should ask

00:11:07,720 --> 00:11:11,499
that question first okay good

00:11:09,670 --> 00:11:13,089
how widely is the supplied I know

00:11:11,499 --> 00:11:16,329
prevent can answer this question how

00:11:13,089 --> 00:11:19,149
widely is this deployed not very widely

00:11:16,329 --> 00:11:23,259
you say not very widely praveen what do

00:11:19,149 --> 00:11:25,989
you say he agrees pravin agrees it's not

00:11:23,259 --> 00:11:28,269
very widely deployed 2009 and it's 2019

00:11:25,989 --> 00:11:30,399
10 years later not very widely deployed

00:11:28,269 --> 00:11:32,980
what happened here and what happened in

00:11:30,399 --> 00:11:34,929
that gap here we had a CDP just before

00:11:32,980 --> 00:11:39,189
that gap anybody here familiar with SCTP

00:11:34,929 --> 00:11:41,309
a little bit enough how much SCTP do we

00:11:39,189 --> 00:11:43,929
have today

00:11:41,309 --> 00:11:45,579
actually a lot if you count all the bits

00:11:43,929 --> 00:11:48,100
because if you're making a phone call

00:11:45,579 --> 00:11:49,660
right now you're using a CDP and that

00:11:48,100 --> 00:11:50,829
form if you're using you know the

00:11:49,660 --> 00:11:52,509
telephone is signaling such as you're

00:11:50,829 --> 00:11:55,329
using a CDP but if it isn't the internet

00:11:52,509 --> 00:11:56,889
you're not using a CDP what happened in

00:11:55,329 --> 00:11:58,749
all of these spaces what happened to

00:11:56,889 --> 00:12:00,100
keep TCP fast open from getting deployed

00:11:58,749 --> 00:12:03,189
since then what happened

00:12:00,100 --> 00:12:09,759
anybody one word middleboxes says

00:12:03,189 --> 00:12:12,699
somebody and yes you get lunch everybody

00:12:09,759 --> 00:12:15,689
else here has to stay and and and and

00:12:12,699 --> 00:12:18,279
I'll walk you through what happened

00:12:15,689 --> 00:12:19,839
middle box has happened well they didn't

00:12:18,279 --> 00:12:21,040
quite happen during that time they've

00:12:19,839 --> 00:12:23,139
always been around

00:12:21,040 --> 00:12:26,019
it's just that they became a real

00:12:23,139 --> 00:12:27,730
problem during that time so what what

00:12:26,019 --> 00:12:29,709
are these things are basically

00:12:27,730 --> 00:12:31,600
intermediary devices that look past the

00:12:29,709 --> 00:12:34,269
IP header that's effectively what they

00:12:31,600 --> 00:12:38,049
are very very basic definition level

00:12:34,269 --> 00:12:39,970
right and they are pervasive they're

00:12:38,049 --> 00:12:41,769
everywhere you're using one right now

00:12:39,970 --> 00:12:43,329
and you don't even know it right I mean

00:12:41,769 --> 00:12:46,660
that's basically how pervasive it is

00:12:43,329 --> 00:12:49,149
home routers firewalls everything

00:12:46,660 --> 00:12:50,290
everything that you're every every

00:12:49,149 --> 00:12:52,319
packet that goes on the internet today

00:12:50,290 --> 00:12:56,919
touches at least one metal box right

00:12:52,319 --> 00:12:59,559
most likely so these things basically

00:12:56,919 --> 00:13:01,320
destroyed in some ways our ability to be

00:12:59,559 --> 00:13:05,400
able to deploy new transfer

00:13:01,320 --> 00:13:07,170
and and and deploy new changes and we

00:13:05,400 --> 00:13:09,780
didn't quite have a good way of handling

00:13:07,170 --> 00:13:11,400
this problem and we tried to deploy

00:13:09,780 --> 00:13:13,050
changes and we still try to you know

00:13:11,400 --> 00:13:14,610
tease be fast open is a great example of

00:13:13,050 --> 00:13:16,800
this right we want to we want to deploy

00:13:14,610 --> 00:13:19,470
these changes but it's hard it's really

00:13:16,800 --> 00:13:22,290
hard to deploy new changes on an

00:13:19,470 --> 00:13:25,290
internet that is fundamentally ossified

00:13:22,290 --> 00:13:27,120
by metal boxes metal boxes expect a

00:13:25,290 --> 00:13:29,370
certain type of behavior from various

00:13:27,120 --> 00:13:32,820
protocols and if those protocols change

00:13:29,370 --> 00:13:33,540
they break in unknown ways and that's a

00:13:32,820 --> 00:13:38,010
huge problem

00:13:33,540 --> 00:13:40,110
so with that I'll switch to basically

00:13:38,010 --> 00:13:43,500
what we started off wanting to build

00:13:40,110 --> 00:13:46,950
quick to do we wanted quick to be

00:13:43,500 --> 00:13:49,170
deployable today we didn't want to wait

00:13:46,950 --> 00:13:50,640
for nuts to come on board we didn't want

00:13:49,170 --> 00:13:53,460
to wait for metal boxes to come on board

00:13:50,640 --> 00:13:55,590
we want to deploy it today and we wanted

00:13:53,460 --> 00:13:58,560
it to be evolved over the last well so

00:13:55,590 --> 00:14:00,930
we put it in user space on top of UDP so

00:13:58,560 --> 00:14:02,910
we could deploy it right away if it is a

00:14:00,930 --> 00:14:05,070
new transport like a CDP we could wait

00:14:02,910 --> 00:14:07,110
for another 20 years and then say it's

00:14:05,070 --> 00:14:10,140
still not deployed or we could deploy on

00:14:07,110 --> 00:14:12,480
top of UDP and basically give up the

00:14:10,140 --> 00:14:15,690
battle to try and deploy new things on

00:14:12,480 --> 00:14:17,490
top of IP and say well maybe we will

00:14:15,690 --> 00:14:19,500
actually have something so we tried and

00:14:17,490 --> 00:14:21,600
we did and we got something

00:14:19,500 --> 00:14:23,520
so we deployed it on top of UDP and that

00:14:21,600 --> 00:14:25,470
was a very deliberate design choice and

00:14:23,520 --> 00:14:27,870
it's in user space and that allowed us

00:14:25,470 --> 00:14:30,060
to iterate much more rapidly at the

00:14:27,870 --> 00:14:32,790
endpoints and that was also a very

00:14:30,060 --> 00:14:36,060
deliberate design choice and we wanted

00:14:32,790 --> 00:14:37,560
it to be evolvable as well and we incur

00:14:36,060 --> 00:14:40,890
encrypted and authenticated the headers

00:14:37,560 --> 00:14:42,810
so why does evolvable an encryption and

00:14:40,890 --> 00:14:44,910
authentication of headers why are they

00:14:42,810 --> 00:14:48,810
in the same bullet point here why are

00:14:44,910 --> 00:14:50,220
they in the same conversation you don't

00:14:48,810 --> 00:14:53,660
get very many points for this but he'll

00:14:50,220 --> 00:14:53,660
get some points if you answer this

00:14:57,800 --> 00:15:04,439
because metal boxes can't read them you

00:15:00,180 --> 00:15:05,939
get another lunch and you're running out

00:15:04,439 --> 00:15:10,860
of your quota by the way others have to

00:15:05,939 --> 00:15:14,490
answer to but yes exactly this is this

00:15:10,860 --> 00:15:18,540
is if and I'll explain this with the

00:15:14,490 --> 00:15:20,939
story right so little while ago what we

00:15:18,540 --> 00:15:23,220
now call G quick is basically Google's

00:15:20,939 --> 00:15:24,870
quick so I haven't really they work

00:15:23,220 --> 00:15:26,850
through this but Google's original

00:15:24,870 --> 00:15:29,579
version of quick is now called G quick

00:15:26,850 --> 00:15:31,170
because the IDF is standardizing quick

00:15:29,579 --> 00:15:34,559
and that is actually quite different

00:15:31,170 --> 00:15:36,480
than the original version of quick which

00:15:34,559 --> 00:15:38,490
is now called G quick because we didn't

00:15:36,480 --> 00:15:39,360
want to call this AI quick because that

00:15:38,490 --> 00:15:40,709
would be quick and this would be AI

00:15:39,360 --> 00:15:42,540
quick and this is the thing we wanted to

00:15:40,709 --> 00:15:44,939
stay forever so we call this quick and

00:15:42,540 --> 00:15:49,079
that G quick if I haven't confused you

00:15:44,939 --> 00:15:52,949
enough just it's alright so the first

00:15:49,079 --> 00:15:55,189
byte of G quick was basically every

00:15:52,949 --> 00:15:57,420
packet was was a byte was called flags

00:15:55,189 --> 00:15:59,430
now you know what flags are used for

00:15:57,420 --> 00:16:01,889
right there basically boolean's right

00:15:59,430 --> 00:16:03,720
that you ought to be able to flip them

00:16:01,889 --> 00:16:06,809
back and forth and that's sort of the

00:16:03,720 --> 00:16:09,389
goal with them so that's what we we it

00:16:06,809 --> 00:16:11,550
was and it was unencrypted because it

00:16:09,389 --> 00:16:13,410
was required for the the receiver had to

00:16:11,550 --> 00:16:15,929
be able to see it to figure out how to

00:16:13,410 --> 00:16:18,300
parse the rest of the packet and so this

00:16:15,929 --> 00:16:19,980
was unencrypted and had been seven for a

00:16:18,300 --> 00:16:21,509
little while because we hadn't flipped

00:16:19,980 --> 00:16:23,370
any bits and by a little while I mean

00:16:21,509 --> 00:16:27,660
about nine months to a year it had not

00:16:23,370 --> 00:16:30,709
changed very much so we did what you do

00:16:27,660 --> 00:16:36,089
with flags right we flipped a bit and

00:16:30,709 --> 00:16:40,319
then everything went to hell we get this

00:16:36,089 --> 00:16:44,040
you know p0 call saying the new chrome

00:16:40,319 --> 00:16:47,459
version that was launched users can't

00:16:44,040 --> 00:16:49,649
reach the internet / / / / Chrome you

00:16:47,459 --> 00:16:53,160
can't use reach any Google property /

00:16:49,649 --> 00:16:55,259
Chrome and it was we were able to

00:16:53,160 --> 00:16:56,790
quickly you know bisect it down and

00:16:55,259 --> 00:16:58,139
figure out that this was because of

00:16:56,790 --> 00:17:00,179
quick and by the way the user was saying

00:16:58,139 --> 00:17:01,679
oh by the way we can teach Google /

00:17:00,179 --> 00:17:04,740
Chrome but we can reach it just fine

00:17:01,679 --> 00:17:06,649
using Firefox right so that's when it

00:17:04,740 --> 00:17:09,539
really hurts because you go this is

00:17:06,649 --> 00:17:10,319
because Firefox was in doing quick and V

00:17:09,539 --> 00:17:12,209
were doing quick

00:17:10,319 --> 00:17:15,600
and so we figured out it was quick and

00:17:12,209 --> 00:17:20,220
and and long story short it took us a

00:17:15,600 --> 00:17:22,230
while but basically we narrowed it down

00:17:20,220 --> 00:17:25,169
and we and we with the help of a bunch

00:17:22,230 --> 00:17:28,710
of really helpful users we were able to

00:17:25,169 --> 00:17:31,200
figure out that the common thing that

00:17:28,710 --> 00:17:33,419
caused this to break down in various

00:17:31,200 --> 00:17:36,570
places was the presence of it particular

00:17:33,419 --> 00:17:39,509
vendors firewall right so what was this

00:17:36,570 --> 00:17:42,269
firewall doing after but much digging

00:17:39,509 --> 00:17:45,360
what we found out that it was allowing

00:17:42,269 --> 00:17:48,830
the first packet of an unknown protocol

00:17:45,360 --> 00:17:51,179
to go through in both directions and

00:17:48,830 --> 00:17:52,919
then it would decide this is not

00:17:51,179 --> 00:17:55,350
something I want to allow so I called

00:17:52,919 --> 00:17:56,700
all subsequent packets now this is

00:17:55,350 --> 00:17:59,700
particularly problematic for quick

00:17:56,700 --> 00:18:01,409
because the way chrome detects whether

00:17:59,700 --> 00:18:05,460
quick works or not

00:18:01,409 --> 00:18:07,049
chrome basically does a it tries quick

00:18:05,460 --> 00:18:09,809
and quick doesn't work it will fall back

00:18:07,049 --> 00:18:11,700
to TCP the way it does that is it'll try

00:18:09,809 --> 00:18:14,039
to a quick handshake and if the quick

00:18:11,700 --> 00:18:15,779
handshake succeeds it'll say okay I'm

00:18:14,039 --> 00:18:17,700
going to go through with quick the quick

00:18:15,779 --> 00:18:20,129
handshake fails it will fall back to DCP

00:18:17,700 --> 00:18:22,649
now of course this firewall allowed the

00:18:20,129 --> 00:18:24,960
quick handshake to go through right and

00:18:22,649 --> 00:18:27,269
then chrome said quick works and then

00:18:24,960 --> 00:18:28,830
the firewall black hold everything right

00:18:27,269 --> 00:18:31,129
so this was basically the worst of all

00:18:28,830 --> 00:18:34,190
worlds for us and this is a big problem

00:18:31,129 --> 00:18:39,120
why did the firewall decide to do this

00:18:34,190 --> 00:18:40,559
because they basically found that the

00:18:39,120 --> 00:18:44,190
protocol that they were seeing this

00:18:40,559 --> 00:18:45,539
packet come from was not quick they saw

00:18:44,190 --> 00:18:47,129
that this packet that was coming through

00:18:45,539 --> 00:18:48,570
was not quick so they allowed it and

00:18:47,129 --> 00:18:50,730
then the black hole did because it did

00:18:48,570 --> 00:18:56,190
not fall into their category of what was

00:18:50,730 --> 00:18:58,169
quick so how did they detect quick what

00:18:56,190 --> 00:18:59,639
they did was they opened up Wireshark no

00:18:58,169 --> 00:19:01,379
our dogs are already public at this time

00:18:59,639 --> 00:19:04,950
they simply looked at the trace for a

00:19:01,379 --> 00:19:07,440
little while and they said guess what it

00:19:04,950 --> 00:19:09,720
looks like the first bite is always the

00:19:07,440 --> 00:19:14,909
same guess what the classifier looks

00:19:09,720 --> 00:19:19,320
like then and this was verified more or

00:19:14,909 --> 00:19:21,029
less yeah now this is basically what we

00:19:19,320 --> 00:19:23,940
had to deal with right so this was one

00:19:21,029 --> 00:19:28,260
bite that was open not encrypted

00:19:23,940 --> 00:19:30,480
and we had this massive issue that we

00:19:28,260 --> 00:19:32,790
and this was not a public protocol this

00:19:30,480 --> 00:19:34,470
was entirely proprietary it was not you

00:19:32,790 --> 00:19:36,450
know it was deployed only within Google

00:19:34,470 --> 00:19:37,740
and it was not very widespread traffic

00:19:36,450 --> 00:19:39,480
at the time that we hadn't ramped up the

00:19:37,740 --> 00:19:42,000
traffic to the extent that we did

00:19:39,480 --> 00:19:44,790
afterwards but that's what we dealt with

00:19:42,000 --> 00:19:45,930
and that's one of the times when me when

00:19:44,790 --> 00:19:48,660
we realized that we had made the right

00:19:45,930 --> 00:19:51,600
decision and the fact that the only way

00:19:48,660 --> 00:19:53,820
the only way you protect a protocol and

00:19:51,600 --> 00:19:56,160
you protect evolvability of any protocol

00:19:53,820 --> 00:19:58,350
and of the Internet is by using

00:19:56,160 --> 00:20:01,350
encryption this is not to say that

00:19:58,350 --> 00:20:03,210
middle boxes aren't doing useful things

00:20:01,350 --> 00:20:04,560
which if you catch me off in the

00:20:03,210 --> 00:20:07,230
corridors I will tell you why they are

00:20:04,560 --> 00:20:11,520
not using useful things but for the

00:20:07,230 --> 00:20:13,910
purposes of this conversation it's that

00:20:11,520 --> 00:20:16,170
they are there there are unintended

00:20:13,910 --> 00:20:17,430
consequences to what they do and they

00:20:16,170 --> 00:20:19,700
don't necessarily take those into

00:20:17,430 --> 00:20:21,960
account also vacation is one of those

00:20:19,700 --> 00:20:24,960
unintended consequences they've stepped

00:20:21,960 --> 00:20:26,850
on things to the extent that it does not

00:20:24,960 --> 00:20:34,080
allow us to evolve protocols in ways

00:20:26,850 --> 00:20:37,860
that we want so that is why that figured

00:20:34,080 --> 00:20:41,280
as the top item in our design Maxim so

00:20:37,860 --> 00:20:42,810
to speak we wanted to then of course

00:20:41,280 --> 00:20:45,680
performance was important somebody's got

00:20:42,810 --> 00:20:48,510
to pay for you to build this stuff and

00:20:45,680 --> 00:20:50,820
reducing latency as it turns out pays

00:20:48,510 --> 00:20:53,220
for building this stuff so we wanted

00:20:50,820 --> 00:20:56,100
mostly zero RTT and sometimes one or two

00:20:53,220 --> 00:20:57,870
t connection establishment this is you

00:20:56,100 --> 00:20:59,340
know if you understand TCP fast open and

00:20:57,870 --> 00:21:02,160
even point three this is roughly the

00:20:59,340 --> 00:21:03,360
same as that now of course as I said T

00:21:02,160 --> 00:21:05,460
was one point three has deployment

00:21:03,360 --> 00:21:07,110
issues and TCP file and sorry

00:21:05,460 --> 00:21:08,850
please be fast open has deployment

00:21:07,110 --> 00:21:11,970
issues tiers one point three came

00:21:08,850 --> 00:21:14,070
afterwards and and that's something that

00:21:11,970 --> 00:21:17,190
we've been now incorporating in the IETF

00:21:14,070 --> 00:21:20,580
work in too quickly so this was an

00:21:17,190 --> 00:21:23,010
important characteristic and as I noted

00:21:20,580 --> 00:21:25,050
earlier some of the features of HTTP two

00:21:23,010 --> 00:21:27,210
which were necessary and very useful for

00:21:25,050 --> 00:21:30,450
for web traffic streams in multiplexing

00:21:27,210 --> 00:21:37,020
that was that became part of quick this

00:21:30,450 --> 00:21:38,220
was also further on we also wanted to do

00:21:37,020 --> 00:21:40,860
better with loss

00:21:38,220 --> 00:21:42,120
and congestion control or at least we

00:21:40,860 --> 00:21:43,799
didn't think that we necessarily could

00:21:42,120 --> 00:21:45,450
do substantially better on congestion

00:21:43,799 --> 00:21:47,039
control but we could make it possible

00:21:45,450 --> 00:21:49,830
and easier for people to play with

00:21:47,039 --> 00:21:51,929
condition controllers and that's we went

00:21:49,830 --> 00:21:55,679
about building the stack in such a way

00:21:51,929 --> 00:22:00,240
so you'll actually see a little bit more

00:21:55,679 --> 00:22:02,129
of this later but quicks packet design

00:22:00,240 --> 00:22:06,419
is such that it allows for us to do much

00:22:02,129 --> 00:22:08,279
more efficient loss recovery and and and

00:22:06,419 --> 00:22:10,289
gives a lot more information to the

00:22:08,279 --> 00:22:17,929
congestion controller as well about how

00:22:10,289 --> 00:22:21,629
it can detect network usage and

00:22:17,929 --> 00:22:23,850
additionally because again Nats because

00:22:21,629 --> 00:22:28,169
things don't like UDP so much in the

00:22:23,850 --> 00:22:31,049
network and so on we have connection ID

00:22:28,169 --> 00:22:34,500
that's in the part of the transport had

00:22:31,049 --> 00:22:37,440
a part of the by the way point of

00:22:34,500 --> 00:22:39,960
clarification here how many people here

00:22:37,440 --> 00:22:45,779
think UDP is a transport Tom don't raise

00:22:39,960 --> 00:22:52,470
your hand you can raise your hand it's

00:22:45,779 --> 00:22:54,450
ok I might say yes it's not sorry I

00:22:52,470 --> 00:22:56,730
fooled you there no it's not it's not

00:22:54,450 --> 00:22:58,620
it's not it's it's it's it's a way to

00:22:56,730 --> 00:23:03,000
build it I keep saying UDP is not a

00:22:58,620 --> 00:23:06,769
transport it's a way to build one and

00:23:03,000 --> 00:23:10,259
Tom is there shaking his head going oh

00:23:06,769 --> 00:23:13,289
yeah I know I RFC 1122 says Tom and it's

00:23:10,259 --> 00:23:15,899
four pages say says me that's not a full

00:23:13,289 --> 00:23:19,169
transport but anyways we can have this

00:23:15,899 --> 00:23:21,509
debate later yeah we can have this

00:23:19,169 --> 00:23:25,019
debate later the point here is that UDP

00:23:21,509 --> 00:23:27,389
is simply a way to build something

00:23:25,019 --> 00:23:30,269
that's that I would call a full fledged

00:23:27,389 --> 00:23:33,419
transport on top but your EP has port

00:23:30,269 --> 00:23:35,789
numbers and and Nats don't there are

00:23:33,419 --> 00:23:38,639
there are issues with with nuts and

00:23:35,789 --> 00:23:41,549
rebinding and so anyways we have a

00:23:38,639 --> 00:23:46,139
connection ID in the quic protocol

00:23:41,549 --> 00:23:49,889
itself that allows us to do to not care

00:23:46,139 --> 00:23:51,450
as much about the four table and have a

00:23:49,889 --> 00:23:52,500
connection ID that identifies the

00:23:51,450 --> 00:23:54,780
connection and

00:23:52,500 --> 00:23:59,910
and this connection ID is part of the

00:23:54,780 --> 00:24:01,920
the packet header and is authenticated

00:23:59,910 --> 00:24:07,800
so nobody can mess around with it as

00:24:01,920 --> 00:24:10,500
well it's it's useful it was primarily

00:24:07,800 --> 00:24:12,930
meant for natural binding because Nats

00:24:10,500 --> 00:24:14,970
understand PCP they'd hold on for the

00:24:12,930 --> 00:24:17,340
hold on to TCP state for a TCP

00:24:14,970 --> 00:24:20,310
connection but they don't understand

00:24:17,340 --> 00:24:22,350
quick or UDP there's no notion of UDP

00:24:20,310 --> 00:24:24,750
connections so they'll drop state

00:24:22,350 --> 00:24:26,400
whenever they decide to and so we have

00:24:24,750 --> 00:24:29,340
to be willing to deal with Natalie

00:24:26,400 --> 00:24:32,340
bindings and so that also gives us

00:24:29,340 --> 00:24:35,400
mobility basically right the holy grail

00:24:32,340 --> 00:24:38,190
of things that we've been trying to do

00:24:35,400 --> 00:24:40,310
for a long time MP TCP for example but

00:24:38,190 --> 00:24:43,260
yeah it gives us mobility also for free

00:24:40,310 --> 00:24:47,430
with not quite for free but it but you

00:24:43,260 --> 00:24:51,990
get that occasionally so I'm basically

00:24:47,430 --> 00:24:54,330
going to not talk more about the details

00:24:51,990 --> 00:24:55,890
of earthquake here I'll talk a little

00:24:54,330 --> 00:24:58,710
bit more about the packetization details

00:24:55,890 --> 00:25:03,570
and so on after the after the break but

00:24:58,710 --> 00:25:06,120
I want to show you roughly why we care

00:25:03,570 --> 00:25:07,590
about this we've talked about head of

00:25:06,120 --> 00:25:09,750
line blocking and those Layton sees

00:25:07,590 --> 00:25:11,550
might seem small and it seems like you

00:25:09,750 --> 00:25:15,270
know who are we really solving these

00:25:11,550 --> 00:25:16,950
problems for and and and this this

00:25:15,270 --> 00:25:18,990
should be instructive a little bit a

00:25:16,950 --> 00:25:21,690
this is basically showing quick

00:25:18,990 --> 00:25:25,230
performance improvement by by geo by

00:25:21,690 --> 00:25:29,760
country and this is for YouTube video

00:25:25,230 --> 00:25:32,280
and this was rebuffed aerates reduction

00:25:29,760 --> 00:25:38,100
in in in in in re buffer rate for

00:25:32,280 --> 00:25:41,430
YouTube for South Korea which has a

00:25:38,100 --> 00:25:46,260
minority D of about 38 milliseconds and

00:25:41,430 --> 00:25:49,680
TCP retransmit rate of about 1% the

00:25:46,260 --> 00:25:52,290
reduction in rebuff a rate is modest its

00:25:49,680 --> 00:25:55,260
modest on on mobile actually but it's

00:25:52,290 --> 00:25:56,580
basically non-existent on desktop and if

00:25:55,260 --> 00:25:58,800
you've seen bandwidths and Korea in

00:25:56,580 --> 00:26:00,690
general you'll understand why it's hard

00:25:58,800 --> 00:26:02,340
to do anything anywhere else to improve

00:26:00,690 --> 00:26:03,480
that performance cause it's super super

00:26:02,340 --> 00:26:05,850
good anyways

00:26:03,480 --> 00:26:08,520
if you get to a place like the US which

00:26:05,850 --> 00:26:12,270
is you know a little crappier then then

00:26:08,520 --> 00:26:14,610
then South Korea you start to see more

00:26:12,270 --> 00:26:17,340
improvements it's when you get to a

00:26:14,610 --> 00:26:21,600
place like India which has really sucky

00:26:17,340 --> 00:26:25,020
connectivity that quick shines so the

00:26:21,600 --> 00:26:27,060
value of quake is in being able to make

00:26:25,020 --> 00:26:35,730
connectivity much better about it really

00:26:27,060 --> 00:26:36,960
really sucks so how have we been working

00:26:35,730 --> 00:26:40,740
on this over the past couple of years

00:26:36,960 --> 00:26:44,880
we've been working on this at the IDF

00:26:40,740 --> 00:26:47,550
we've been working with some very with a

00:26:44,880 --> 00:26:54,270
large number of folks across the board

00:26:47,550 --> 00:26:56,670
and it's it's it's coming to a stable

00:26:54,270 --> 00:27:02,340
point I'll say unofficially informally

00:26:56,670 --> 00:27:04,890
on tape but it's it's it's it's come

00:27:02,340 --> 00:27:06,870
along quite a bit since when we started

00:27:04,890 --> 00:27:09,750
the focus on security and privacy has

00:27:06,870 --> 00:27:14,040
gotten even stronger over the past

00:27:09,750 --> 00:27:15,870
couple of years and that's rubbed a lot

00:27:14,040 --> 00:27:17,220
of network operators the wrong way and

00:27:15,870 --> 00:27:19,500
not I shouldn't say it's rubbed them the

00:27:17,220 --> 00:27:22,980
wrong way it's basically we've we've had

00:27:19,500 --> 00:27:25,290
a lot of contention within the working

00:27:22,980 --> 00:27:26,910
group on how to because network

00:27:25,290 --> 00:27:28,670
operators are used to seeing a certain

00:27:26,910 --> 00:27:32,160
amount of transport information and

00:27:28,670 --> 00:27:33,930
quick basically hides everything so

00:27:32,160 --> 00:27:37,560
there's been some contention discussion

00:27:33,930 --> 00:27:40,980
debate and we've had that but that's all

00:27:37,560 --> 00:27:42,360
been I'd say healthy and there's been a

00:27:40,980 --> 00:27:42,990
very strong focus on avoiding

00:27:42,360 --> 00:27:45,510
ossification

00:27:42,990 --> 00:27:47,070
through encryption and increasing which

00:27:45,510 --> 00:27:52,320
is the mechanism I won't get into the

00:27:47,070 --> 00:27:54,570
details here what's the word like right

00:27:52,320 --> 00:27:56,100
now in terms of implementations we have

00:27:54,570 --> 00:27:58,260
a large number of implementations right

00:27:56,100 --> 00:28:00,060
now working on building and

00:27:58,260 --> 00:28:02,010
interoperating with quick we are gonna

00:28:00,060 --> 00:28:03,600
have a number of these at the Interop

00:28:02,010 --> 00:28:08,190
this weekend

00:28:03,600 --> 00:28:09,570
at the IETF so Apple has a couple of

00:28:08,190 --> 00:28:11,610
implementations as it turns out one of

00:28:09,570 --> 00:28:12,510
them is for ATS Apache traffic traffic

00:28:11,610 --> 00:28:15,820
serve and the other one is the

00:28:12,510 --> 00:28:18,130
proprietary one firstly has

00:28:15,820 --> 00:28:20,770
our we have our own implementation it's

00:28:18,130 --> 00:28:24,940
called quickly because we are cute with

00:28:20,770 --> 00:28:27,760
names like that Facebook has its

00:28:24,940 --> 00:28:30,250
implementation Firefox has an

00:28:27,760 --> 00:28:31,180
implementation f5 Google's is chromium

00:28:30,250 --> 00:28:33,700
that's open source

00:28:31,180 --> 00:28:36,490
Microsoft has theirs which is not open

00:28:33,700 --> 00:28:39,610
source Lightspeed and click go which is

00:28:36,490 --> 00:28:40,930
an go for the carry web service so there

00:28:39,610 --> 00:28:42,970
are a number of implementations out

00:28:40,930 --> 00:28:44,260
there and a lot of them they're all

00:28:42,970 --> 00:28:45,700
working on interoperating with each

00:28:44,260 --> 00:28:48,580
other and they are all spending a lot of

00:28:45,700 --> 00:28:51,640
effort and energy building these up to

00:28:48,580 --> 00:28:54,040
speed will be actually we will be

00:28:51,640 --> 00:28:55,090
looking at quickly here I won't be going

00:28:54,040 --> 00:28:56,740
into the details of how quickly

00:28:55,090 --> 00:28:59,020
implements quick but I'll be talking

00:28:56,740 --> 00:29:01,720
about the surface of quickly how an

00:28:59,020 --> 00:29:03,550
application might use it it's gonna be a

00:29:01,720 --> 00:29:04,350
little tenuous but we'll see how that

00:29:03,550 --> 00:29:09,940
goes

00:29:04,350 --> 00:29:11,260
and as it turns out because this is

00:29:09,940 --> 00:29:15,870
being built in user space and as

00:29:11,260 --> 00:29:19,590
libraries there's no one socket like API

00:29:15,870 --> 00:29:23,260
they all have their own API basically

00:29:19,590 --> 00:29:25,090
and so one of the things that Jomon had

00:29:23,260 --> 00:29:26,740
asked me when when when arranging this

00:29:25,090 --> 00:29:29,440
talk was hey can you can you actually

00:29:26,740 --> 00:29:32,070
you know do a simple thing where people

00:29:29,440 --> 00:29:34,870
can write a hello world program like

00:29:32,070 --> 00:29:37,180
intro to sockets type of thing I'm like

00:29:34,870 --> 00:29:40,500
there is no sockets here I mean in the

00:29:37,180 --> 00:29:43,300
sense that there is no unified API so

00:29:40,500 --> 00:29:44,920
but the one I'm going to show you is

00:29:43,300 --> 00:29:46,180
quickly it's available open source and

00:29:44,920 --> 00:29:52,120
you can play with it afterwards if you

00:29:46,180 --> 00:29:53,260
would like so so a number of

00:29:52,120 --> 00:29:56,590
implementations like chromium for

00:29:53,260 --> 00:29:59,890
example is building it for its own HTTP

00:29:56,590 --> 00:30:02,710
stack so it's not separable really from

00:29:59,890 --> 00:30:04,720
the rest of the HTTP stack so quick as

00:30:02,710 --> 00:30:06,970
in library is not separable from its

00:30:04,720 --> 00:30:10,560
HTTP the surface that it exposes is on

00:30:06,970 --> 00:30:13,660
top of HTTP so you do a get URL request

00:30:10,560 --> 00:30:15,580
on top of the the chrome networking

00:30:13,660 --> 00:30:17,740
stack but you can't really pull that

00:30:15,580 --> 00:30:19,090
quick and say I want to have an API that

00:30:17,740 --> 00:30:21,700
simply uses quick and build my own

00:30:19,090 --> 00:30:26,500
application on top of quick that's much

00:30:21,700 --> 00:30:29,310
harder to do so that's about it for our

00:30:26,500 --> 00:30:32,190
pre-launch time and I'm 15 seconds

00:30:29,310 --> 00:30:34,470
it's 1233 sorry three minutes past 1:00

00:30:32,190 --> 00:30:39,200
I said end but I'll see you back here

00:30:34,470 --> 00:30:39,200
what time is it 1:00 something 1:20

00:30:40,250 --> 00:30:45,240
anybody 120 120 okay

00:30:43,470 --> 00:30:47,430
so 120 will pick it back up from here

00:30:45,240 --> 00:30:52,590
and we will go into more interesting

00:30:47,430 --> 00:31:00,830
stuff thank you all all right I think we

00:30:52,590 --> 00:31:00,830
have quorum here shall we start

00:31:10,380 --> 00:31:18,590
I hope you've had your coffee don't

00:31:14,639 --> 00:31:18,590
blame me later if you fall asleep okay

00:31:19,220 --> 00:31:24,600
so I want to pick up where we left off

00:31:21,299 --> 00:31:27,630
any thoughts any questions about what we

00:31:24,600 --> 00:31:31,470
what we discussed so far please feel

00:31:27,630 --> 00:31:32,940
free to raise them and honestly I love

00:31:31,470 --> 00:31:35,610
it when we're just having a conversation

00:31:32,940 --> 00:31:37,049
because ultimately to me the value of of

00:31:35,610 --> 00:31:38,909
being in the same room rather than

00:31:37,049 --> 00:31:43,169
watching a YouTube video is that you can

00:31:38,909 --> 00:31:46,440
actually throw peanuts at me and I have

00:31:43,169 --> 00:31:51,059
the mic so I get to say things to you in

00:31:46,440 --> 00:31:55,679
response so please ask questions throw

00:31:51,059 --> 00:31:57,960
peanuts so I want to I'm realizing that

00:31:55,679 --> 00:32:01,110
there's there's there's a there's a very

00:31:57,960 --> 00:32:03,090
wide mix of people in this room so what

00:32:01,110 --> 00:32:05,129
I'm going to do is change the plan

00:32:03,090 --> 00:32:07,049
slightly I'm not going to do a full code

00:32:05,129 --> 00:32:09,269
read-through I'll show the code but I'm

00:32:07,049 --> 00:32:10,980
basically just going to show it I'm

00:32:09,269 --> 00:32:13,259
happy to discuss the details and I'm

00:32:10,980 --> 00:32:14,700
going to go the API I'm also going to go

00:32:13,259 --> 00:32:16,320
over the code but I'm not gonna go into

00:32:14,700 --> 00:32:18,210
it in substantial details because I

00:32:16,320 --> 00:32:19,679
think there's other discussion elements

00:32:18,210 --> 00:32:21,659
as well that might show up later I'm

00:32:19,679 --> 00:32:23,460
going to show you some tooling and there

00:32:21,659 --> 00:32:24,690
might be other discussion later as well

00:32:23,460 --> 00:32:28,259
and I'm happy to engage in pretty much

00:32:24,690 --> 00:32:34,289
all of that any of you have questions

00:32:28,259 --> 00:32:36,269
about the idea for Q&A later so and

00:32:34,289 --> 00:32:38,070
again this session might go on a few

00:32:36,269 --> 00:32:41,610
minutes past the end time because again

00:32:38,070 --> 00:32:45,570
we are starting a little bit late but

00:32:41,610 --> 00:32:51,240
but I should be done by 2:30 at the

00:32:45,570 --> 00:32:52,710
latest okay so this is where we left off

00:32:51,240 --> 00:32:53,549
you are talking about quick and we're

00:32:52,710 --> 00:32:57,149
talking about the fact that there are

00:32:53,549 --> 00:32:59,700
different implementations and each one

00:32:57,149 --> 00:33:01,139
of them has its own API to how you use

00:32:59,700 --> 00:33:03,330
quick and some of them don't even have a

00:33:01,139 --> 00:33:05,580
well-defined API at the moment and this

00:33:03,330 --> 00:33:07,919
is although evolving so as these

00:33:05,580 --> 00:33:09,360
implementations mature there's there's

00:33:07,919 --> 00:33:11,100
been talk and you've talked about this

00:33:09,360 --> 00:33:14,100
in the past about actually having some

00:33:11,100 --> 00:33:16,500
sort of standardized notion of an API I

00:33:14,100 --> 00:33:18,659
don't think it's going to be as rigid as

00:33:16,500 --> 00:33:20,250
the POSIX API but it could certainly be

00:33:18,659 --> 00:33:22,470
something that's a broader sort of an

00:33:20,250 --> 00:33:25,470
abstract API for

00:33:22,470 --> 00:33:28,890
that all implementations implement a

00:33:25,470 --> 00:33:31,980
version of so we might go there we're

00:33:28,890 --> 00:33:33,900
not there yet certainly but if you would

00:33:31,980 --> 00:33:36,360
like to play with quick and then your

00:33:33,900 --> 00:33:42,330
you can just expect that the road will

00:33:36,360 --> 00:33:43,799
be slightly rough so I'll I'll give a

00:33:42,330 --> 00:33:47,220
little bit of a brief about quickly

00:33:43,799 --> 00:33:50,220
itself quickly is the the fastly

00:33:47,220 --> 00:33:53,580
implementation of quick and this was

00:33:50,220 --> 00:33:55,260
written for the h2o web server how many

00:33:53,580 --> 00:34:03,029
of you here are familiar with the h2o

00:33:55,260 --> 00:34:05,520
web server that's it is basically it's

00:34:03,029 --> 00:34:09,810
it's it's it's a super-fast HDB to

00:34:05,520 --> 00:34:14,190
server released in 2014 and it's

00:34:09,810 --> 00:34:19,230
primarily optimized for HTTP two and by

00:34:14,190 --> 00:34:22,230
that I mean it has it Tunes the TCP send

00:34:19,230 --> 00:34:24,780
buffer to basically be minimal to

00:34:22,230 --> 00:34:27,389
minimize latency and it's got a

00:34:24,780 --> 00:34:29,460
fine-grained HTTP 2 prioritization and

00:34:27,389 --> 00:34:31,619
implement some upcoming features in HTTP

00:34:29,460 --> 00:34:33,869
2 so it's pretty cutting edge with HTTP

00:34:31,619 --> 00:34:36,740
2 and it's really focused on HTTP 2

00:34:33,869 --> 00:34:36,740
performance

00:34:51,069 --> 00:34:54,579
shrim plug this

00:35:06,680 --> 00:35:09,680
yeah

00:35:21,650 --> 00:35:29,299
there you go thank you all right

00:35:25,490 --> 00:35:31,849
and quickly users so as I pointed out

00:35:29,299 --> 00:35:34,039
earlier quick is basically encrypted by

00:35:31,849 --> 00:35:38,420
default it's always encrypted and it

00:35:34,039 --> 00:35:42,140
uses a TLS one uses the TRS library to

00:35:38,420 --> 00:35:45,529
encrypt and you'll see in a moment nor

00:35:42,140 --> 00:35:53,410
in a moment in a little while the slides

00:35:45,529 --> 00:36:12,980
I hope but I'll yeah okay good enough so

00:35:53,410 --> 00:36:15,740
yes so there are that isn't very much to

00:36:12,980 --> 00:36:17,180
ossify in UDP in terms of features and

00:36:15,740 --> 00:36:19,579
in terms of extensions that we want to

00:36:17,180 --> 00:36:20,329
do to UDP as the protocol UDP the

00:36:19,579 --> 00:36:22,130
protocol itself

00:36:20,329 --> 00:36:26,839
do you wanna make extensions too quick

00:36:22,130 --> 00:36:28,970
and we are we are avoiding ossification

00:36:26,839 --> 00:36:32,749
or we are avoiding it getting ossified

00:36:28,970 --> 00:36:35,630
by encrypting everything so the hope is

00:36:32,749 --> 00:36:39,859
that going forward they that quick will

00:36:35,630 --> 00:36:41,509
remain not also fide although I have no

00:36:39,859 --> 00:36:43,009
doubt that metal box vendors will find

00:36:41,509 --> 00:36:45,950
clever ways of falsifying something that

00:36:43,009 --> 00:36:52,069
is fundamentally unmerciful book it's

00:36:45,950 --> 00:36:53,450
possible they'd have to see so the

00:36:52,069 --> 00:36:56,150
question is what level is encryption

00:36:53,450 --> 00:36:59,089
happening at encryption happens the

00:36:56,150 --> 00:37:01,009
quick level and up so all of the quick

00:36:59,089 --> 00:37:02,509
packet headers are encrypted the data

00:37:01,009 --> 00:37:05,509
that's inside of quick is encrypted the

00:37:02,509 --> 00:37:07,009
UDP header is not encrypted but

00:37:05,509 --> 00:37:09,549
everything inside of UDP is encrypted

00:37:07,009 --> 00:37:09,549
basically

00:37:12,770 --> 00:37:16,740
so the question roses encryption on a

00:37:15,000 --> 00:37:18,480
per packet basis the answer is yes it's

00:37:16,740 --> 00:37:20,070
on a per packet basis the reason you

00:37:18,480 --> 00:37:21,450
need adorable packet basis is because

00:37:20,070 --> 00:37:23,610
you have to be able to deal with the

00:37:21,450 --> 00:37:25,020
receive packets out of order otherwise

00:37:23,610 --> 00:37:29,540
you reintroduce the head-of-line

00:37:25,020 --> 00:37:34,740
blocking problem all right

00:37:29,540 --> 00:37:39,150
going along here quickly uses Pico TLS

00:37:34,740 --> 00:37:41,930
as a library for doing for doing SSL for

00:37:39,150 --> 00:37:46,560
doing TLS I'm sorry I'm showing my age

00:37:41,930 --> 00:37:48,720
and TLS 1.3 the Pico TLS supports

00:37:46,560 --> 00:37:50,670
various new features and ers such as

00:37:48,720 --> 00:37:52,140
encrypted SMI which is going to be by

00:37:50,670 --> 00:37:59,460
the way a lot of fun when it hits the

00:37:52,140 --> 00:38:02,130
wires and certificate compression and it

00:37:59,460 --> 00:38:04,200
supports quick and attack it has a very

00:38:02,130 --> 00:38:07,260
interesting it is a different API then

00:38:04,200 --> 00:38:09,510
open SSL is if you're familiar with open

00:38:07,260 --> 00:38:11,520
SSL the API is different in that it

00:38:09,510 --> 00:38:14,850
specifically supports a codec style API

00:38:11,520 --> 00:38:17,240
in which you you send you you you give

00:38:14,850 --> 00:38:23,070
it in plain text and it spits back

00:38:17,240 --> 00:38:24,570
encrypted the encrypted text this is

00:38:23,070 --> 00:38:26,580
different from open open SSL where you

00:38:24,570 --> 00:38:29,040
simply write and open SSL then writes

00:38:26,580 --> 00:38:31,320
into the socket below and this is quite

00:38:29,040 --> 00:38:33,150
useful because then it's modular the

00:38:31,320 --> 00:38:35,280
koteas is modular and in quick it's very

00:38:33,150 --> 00:38:39,570
useful because quick will basically send

00:38:35,280 --> 00:38:41,940
it to send the packet to picot TLS get

00:38:39,570 --> 00:38:44,460
the encrypted text back and then dump it

00:38:41,940 --> 00:38:46,320
down into the UDP socket so we will get

00:38:44,460 --> 00:38:51,600
into that in just a moment so the way

00:38:46,320 --> 00:38:53,340
that quickly so just very quickly it's

00:38:51,600 --> 00:38:55,350
written in C and was waiting for issue

00:38:53,340 --> 00:38:58,830
as I said and I've already covered these

00:38:55,350 --> 00:39:00,570
points the API for quickly itself is

00:38:58,830 --> 00:39:03,450
minimal buffering it basically supports

00:39:00,570 --> 00:39:05,220
a codec style API again quickly itself

00:39:03,450 --> 00:39:06,480
supports a core textile API both the

00:39:05,220 --> 00:39:09,750
Cordilleras and quickly both have this

00:39:06,480 --> 00:39:10,500
codec style api and that means something

00:39:09,750 --> 00:39:11,880
very particular

00:39:10,500 --> 00:39:14,240
well it's also bufferless I'll talk

00:39:11,880 --> 00:39:19,770
about the core textile API in a moment

00:39:14,240 --> 00:39:21,810
question codecs API is is basically you

00:39:19,770 --> 00:39:23,430
you you give it raw data and it gives

00:39:21,810 --> 00:39:26,709
you an the encoded data

00:39:23,430 --> 00:39:29,289
so that's as against you right to it and

00:39:26,709 --> 00:39:30,700
it rights as against the Laird API where

00:39:29,289 --> 00:39:37,349
you write to it and it writes the layer

00:39:30,700 --> 00:39:37,349
below this is more of a modular API yes

00:39:45,749 --> 00:39:53,829
yes oh that's that's interesting with

00:39:51,549 --> 00:39:56,079
and so the question is Google control

00:39:53,829 --> 00:39:59,440
both ends of the connection so it was

00:39:56,079 --> 00:40:01,329
able to deploy quick on both ends it's

00:39:59,440 --> 00:40:04,329
not a quickly problem as much as it is a

00:40:01,329 --> 00:40:07,799
fastly problem because fastly owns only

00:40:04,329 --> 00:40:10,779
the servers we are basically the CDN but

00:40:07,799 --> 00:40:13,690
with only on the serving side we don't

00:40:10,779 --> 00:40:15,940
know the client-side necessarily so this

00:40:13,690 --> 00:40:18,160
is why a place like the IETF is really

00:40:15,940 --> 00:40:20,469
useful because you get clients then to

00:40:18,160 --> 00:40:21,880
implement and deploy quick as well so we

00:40:20,469 --> 00:40:23,709
are working with clients who are

00:40:21,880 --> 00:40:25,599
deploying IETF quick and we are

00:40:23,709 --> 00:40:29,440
deploying IETF quick at the service as

00:40:25,599 --> 00:40:32,499
well so yes we rely on clients

00:40:29,440 --> 00:40:35,019
implementing but quickly itself has in

00:40:32,499 --> 00:40:36,729
it a client and a server both for

00:40:35,019 --> 00:40:38,920
testing and for various purposes but

00:40:36,729 --> 00:40:46,769
it's fundamentally being built for the

00:40:38,920 --> 00:40:46,769
server yes

00:40:48,460 --> 00:40:51,740
excellent question so the question was

00:40:50,450 --> 00:40:53,840
if it's buffaloes how does it handle

00:40:51,740 --> 00:40:55,910
three transmissions well I'll show that

00:40:53,840 --> 00:40:59,020
in a second the buffer is actually held

00:40:55,910 --> 00:41:01,580
by the the application effective and

00:40:59,020 --> 00:41:04,580
quick goes up all the way to the stack

00:41:01,580 --> 00:41:08,270
to pull data so I'll get to that in a

00:41:04,580 --> 00:41:10,520
second basically the value of being

00:41:08,270 --> 00:41:11,780
buffaloes is that it's much less memory

00:41:10,520 --> 00:41:13,760
footprint especially if you are a file

00:41:11,780 --> 00:41:16,220
if you're a server that's serving a very

00:41:13,760 --> 00:41:17,510
common object for example then instead

00:41:16,220 --> 00:41:18,710
of maintaining you know as many

00:41:17,510 --> 00:41:19,760
connection instead of trying to scale

00:41:18,710 --> 00:41:21,740
that memory to be the number of

00:41:19,760 --> 00:41:25,760
connections you just have one copy of

00:41:21,740 --> 00:41:28,070
this and it also allows for better HTTP

00:41:25,760 --> 00:41:30,470
header compression because if you are

00:41:28,070 --> 00:41:32,960
serializing this at the last moment your

00:41:30,470 --> 00:41:34,790
cue pack or the dictionary state is the

00:41:32,960 --> 00:41:37,280
most updated state and so you can get

00:41:34,790 --> 00:41:38,900
more efficient compression for this and

00:41:37,280 --> 00:41:40,880
it also allows you to do better stream

00:41:38,900 --> 00:41:42,680
prioritization because again you're not

00:41:40,880 --> 00:41:45,740
committing data before it's time to

00:41:42,680 --> 00:41:47,150
literally put it on the wire so you can

00:41:45,740 --> 00:41:48,830
choose from whichever stream is the

00:41:47,150 --> 00:41:52,690
highest priority at that point in time

00:41:48,830 --> 00:41:56,660
this is very useful for HTTP priorities

00:41:52,690 --> 00:41:58,940
so here the key is that the application

00:41:56,660 --> 00:42:01,340
defines the send send and receive

00:41:58,940 --> 00:42:04,280
buffers and quick simply uses the

00:42:01,340 --> 00:42:05,810
applications buffers and and does call I

00:42:04,280 --> 00:42:07,280
don't want to say up calls because it's

00:42:05,810 --> 00:42:08,930
not strictly layer in that sense but

00:42:07,280 --> 00:42:11,420
it's basically like an op call into the

00:42:08,930 --> 00:42:14,060
application to get data but it needs to

00:42:11,420 --> 00:42:15,530
send it and this really works well

00:42:14,060 --> 00:42:19,450
because it's all in user space so

00:42:15,530 --> 00:42:22,700
there's no real context switch here so

00:42:19,450 --> 00:42:24,620
briefly this is how a typical quickly

00:42:22,700 --> 00:42:27,740
itself would do this in HTTP for example

00:42:24,620 --> 00:42:29,780
so when doing an HTTP two this is how

00:42:27,740 --> 00:42:31,790
quickly will send data it basically

00:42:29,780 --> 00:42:35,300
pushes data into the TCP send buffers

00:42:31,790 --> 00:42:36,590
across the kernel boundary and then the

00:42:35,300 --> 00:42:38,390
TCP Center will you know eventually

00:42:36,590 --> 00:42:39,950
fetch data when it has the ability to

00:42:38,390 --> 00:42:44,930
send data from the send buffer and

00:42:39,950 --> 00:42:48,290
packet rises and sends it whereas in in

00:42:44,930 --> 00:42:50,510
in the quick it's quite different the

00:42:48,290 --> 00:42:53,330
architecture allows the application to

00:42:50,510 --> 00:42:56,210
basically maintain state per connection

00:42:53,330 --> 00:42:58,430
and then when it's time to send data

00:42:56,210 --> 00:42:59,820
they eat a new transmission or beta

00:42:58,430 --> 00:43:02,400
retransmission it's

00:42:59,820 --> 00:43:05,040
he goes back into the file server or the

00:43:02,400 --> 00:43:07,620
file system or the file cache and grabs

00:43:05,040 --> 00:43:10,410
that bunch of data and literally packet

00:43:07,620 --> 00:43:12,720
Isis it encrypts it shifts it down the

00:43:10,410 --> 00:43:14,490
wire and it's gone so there is no

00:43:12,720 --> 00:43:16,230
intermediate buffering from the source

00:43:14,490 --> 00:43:19,080
of data all the way down there really

00:43:16,230 --> 00:43:22,400
isn't any place that data is is buffered

00:43:19,080 --> 00:43:25,860
it's it's it's one stream through and

00:43:22,400 --> 00:43:27,660
the fetch itself that that happens up

00:43:25,860 --> 00:43:28,980
into the file cache here is only

00:43:27,660 --> 00:43:31,770
happening when there's permission to

00:43:28,980 --> 00:43:33,450
send the quick level meaning the quick

00:43:31,770 --> 00:43:35,040
has conditioned window to send and this

00:43:33,450 --> 00:43:37,320
is the stream that we want to send data

00:43:35,040 --> 00:43:40,430
from the basically goes and grabs the

00:43:37,320 --> 00:43:44,090
data encrypted packet izalith sends it

00:43:40,430 --> 00:43:44,090
yes question

00:44:07,569 --> 00:44:10,569
sure

00:44:16,369 --> 00:44:36,210
yes yes I mean the codex I'll I don't

00:44:34,619 --> 00:44:40,670
think the core excel is necessarily I

00:44:36,210 --> 00:44:42,750
saw I can't speak to the design choice I

00:44:40,670 --> 00:44:44,760
wouldn't say the codex is fundamental to

00:44:42,750 --> 00:45:05,190
this you're right you're totally right

00:44:44,760 --> 00:45:08,160
about that so the so the the the other

00:45:05,190 --> 00:45:10,290
piece that the API that quickly doesn't

00:45:08,160 --> 00:45:13,230
do is it doesn't actually send packets

00:45:10,290 --> 00:45:14,790
on on the European so the application

00:45:13,230 --> 00:45:17,730
has to do it so this is again part of

00:45:14,790 --> 00:45:19,020
the same core textile API which is that

00:45:17,730 --> 00:45:20,579
the application owns the buffers the

00:45:19,020 --> 00:45:25,260
application owns the sockets and

00:45:20,579 --> 00:45:29,060
basically grabs data ships it to quick

00:45:25,260 --> 00:45:32,160
quickly quickly will send back packets

00:45:29,060 --> 00:45:33,510
effectively and then quickly and then

00:45:32,160 --> 00:45:36,690
the application has to take that and

00:45:33,510 --> 00:45:38,220
dump it into the into the socket and it

00:45:36,690 --> 00:45:42,450
quickly provides some helper functions

00:45:38,220 --> 00:45:44,310
to accomplish these ends so this is

00:45:42,450 --> 00:45:47,849
basically how it looks so this is

00:45:44,310 --> 00:45:51,270
roughly how the HT HT t h2o itself looks

00:45:47,849 --> 00:45:55,579
there's h2 on the middle there which

00:45:51,270 --> 00:45:58,260
which talks to on the one side on the

00:45:55,579 --> 00:46:00,420
left side of that picture is basically

00:45:58,260 --> 00:46:03,200
the conversation that the parts that are

00:46:00,420 --> 00:46:07,349
useful for HTTP 1 and HTTP to serving

00:46:03,200 --> 00:46:11,160
and the right side is for using HTTP 3

00:46:07,349 --> 00:46:13,950
and quick so as you can see here h2o is

00:46:11,160 --> 00:46:17,670
the the application owns the sockets and

00:46:13,950 --> 00:46:19,619
it basically talks to pico TLS on the

00:46:17,670 --> 00:46:23,849
sides and then dumps things down into

00:46:19,619 --> 00:46:26,530
the socket and it similarly does so for

00:46:23,849 --> 00:46:40,550
for quick and for HTTP 3

00:46:26,530 --> 00:46:42,080
yep do the same architecture so the

00:46:40,550 --> 00:46:44,690
question is is this model unique too

00:46:42,080 --> 00:46:46,220
quickly or rather other implementations

00:46:44,690 --> 00:46:49,730
that are doing quick using the same

00:46:46,220 --> 00:46:51,080
architecture I I don't think it's unique

00:46:49,730 --> 00:46:54,680
but at the same time I don't think it's

00:46:51,080 --> 00:46:57,940
super common in partly because so the

00:46:54,680 --> 00:47:00,320
the the AP actually comes from from

00:46:57,940 --> 00:47:05,150
using TLS and trying to minimize latency

00:47:00,320 --> 00:47:07,340
for HTTP using TLS and quic just fits

00:47:05,150 --> 00:47:08,540
into that same thing so the codecs idea

00:47:07,340 --> 00:47:11,260
that I was talking to you about where

00:47:08,540 --> 00:47:13,610
these web server owns the socket

00:47:11,260 --> 00:47:15,770
underneath if you can see on the left

00:47:13,610 --> 00:47:19,610
side of that picture is true for HTTP to

00:47:15,770 --> 00:47:21,950
HTTPS well so that's h2o architecture

00:47:19,610 --> 00:47:23,780
and it shows architectures so to try and

00:47:21,950 --> 00:47:25,910
minimize latency in this attack below if

00:47:23,780 --> 00:47:28,280
you look at open SSL then you basically

00:47:25,910 --> 00:47:30,560
have the application doesn't have as

00:47:28,280 --> 00:47:33,050
much control open SSL is the thing that

00:47:30,560 --> 00:47:35,330
has control over record boundaries and

00:47:33,050 --> 00:47:41,020
how many things how long to wait before

00:47:35,330 --> 00:47:41,020
dumping a packet down a couple so as

00:47:41,290 --> 00:47:46,310
fundamentally architecturally unique you

00:47:44,960 --> 00:47:48,050
can you can get those latency benefits

00:47:46,310 --> 00:47:54,440
from other architectures too it's just

00:47:48,050 --> 00:47:56,120
not the case right now so issue was has

00:47:54,440 --> 00:47:59,320
been trying to optimize for latency and

00:47:56,120 --> 00:48:03,520
so this architecture allows for that

00:47:59,320 --> 00:48:03,520
yeah exactly

00:48:05,110 --> 00:48:10,880
so but that I'm basically just going to

00:48:09,500 --> 00:48:14,420
talk to you very briefly about what

00:48:10,880 --> 00:48:16,280
typically what you expect to see in the

00:48:14,420 --> 00:48:21,140
quickly API and we'll see more calls

00:48:16,280 --> 00:48:22,220
then then functions but at both the

00:48:21,140 --> 00:48:26,750
client and the server you want to be

00:48:22,220 --> 00:48:27,860
able to accept a so at the client you

00:48:26,750 --> 00:48:29,390
want to be able to connect to the server

00:48:27,860 --> 00:48:30,800
at the server you want to be able to

00:48:29,390 --> 00:48:32,870
accept an incoming connection from the

00:48:30,800 --> 00:48:35,110
client and at both ends you want to be

00:48:32,870 --> 00:48:37,100
able to create streams now to be clear

00:48:35,110 --> 00:48:39,360
for those of you who may not have

00:48:37,100 --> 00:48:41,430
gathered this yet streams are

00:48:39,360 --> 00:48:43,230
tractions and and the way to think about

00:48:41,430 --> 00:48:46,350
them is from a program from an API point

00:48:43,230 --> 00:48:47,640
of view I created two endpoints that an

00:48:46,350 --> 00:48:50,730
endpoint creates a connection with

00:48:47,640 --> 00:48:53,460
another endpoint and then within that

00:48:50,730 --> 00:48:56,750
connection the endpoint creates streams

00:48:53,460 --> 00:48:59,670
so I can open a stream to the the peer

00:48:56,750 --> 00:49:02,340
within the connection okay and streams

00:48:59,670 --> 00:49:04,290
are basically ephemeral things and and

00:49:02,340 --> 00:49:05,850
you use a stream to write you can't

00:49:04,290 --> 00:49:07,830
write without opening a stream first

00:49:05,850 --> 00:49:11,150
anything any data that an application

00:49:07,830 --> 00:49:21,540
writes has to be written in a stream

00:49:11,150 --> 00:49:22,620
exactly yeah question so the question is

00:49:21,540 --> 00:49:25,340
are streams unidirectional or

00:49:22,620 --> 00:49:27,300
bi-directional quick has both kinds a

00:49:25,340 --> 00:49:37,860
quick has both bi-directional and

00:49:27,300 --> 00:49:39,510
unidirectional streams so the question

00:49:37,860 --> 00:49:41,040
is are the streams negotiated or is it

00:49:39,510 --> 00:49:44,040
just the client writing data on one side

00:49:41,040 --> 00:49:46,440
and so on streams are not negotiated but

00:49:44,040 --> 00:49:48,180
the maximum allowable streams is

00:49:46,440 --> 00:49:50,100
something that both endpoints will

00:49:48,180 --> 00:49:51,840
advertise and then there's a flow

00:49:50,100 --> 00:49:53,040
control for streams basically there's a

00:49:51,840 --> 00:49:55,500
way to say okay I'm gonna allow more

00:49:53,040 --> 00:49:57,750
streams now so both endpoints can keep

00:49:55,500 --> 00:50:00,630
pumping that limit a higher and higher

00:49:57,750 --> 00:50:02,160
and in within under that limit an

00:50:00,630 --> 00:50:09,360
application is free to open as many

00:50:02,160 --> 00:50:11,100
streams as it notes yeah so the question

00:50:09,360 --> 00:50:12,150
is what about condition control is that

00:50:11,100 --> 00:50:13,400
stream based the connection based

00:50:12,150 --> 00:50:16,530
conditioning or towards connection based

00:50:13,400 --> 00:50:18,020
on the entire loss recovery condition

00:50:16,530 --> 00:50:20,370
control basically connection level

00:50:18,020 --> 00:50:22,280
constructs and we use them for

00:50:20,370 --> 00:50:25,200
connection level things not for stream

00:50:22,280 --> 00:50:27,150
flow control however operates at the at

00:50:25,200 --> 00:50:30,570
the stream level and there also is a

00:50:27,150 --> 00:50:32,640
connection wide flow control so there's

00:50:30,570 --> 00:50:44,820
this connection wide and there's first

00:50:32,640 --> 00:50:48,270
fee in flow control so yeah so so this

00:50:44,820 --> 00:50:50,490
is basically roughly the API that

00:50:48,270 --> 00:50:52,260
quickly offers this is exactly the API

00:50:50,490 --> 00:50:54,710
sorry that quickly offers but

00:50:52,260 --> 00:50:58,290
I'm going to go over it very briefly

00:50:54,710 --> 00:51:02,190
this is I have links and you can you can

00:50:58,290 --> 00:51:04,380
go look at the code examples as well but

00:51:02,190 --> 00:51:07,020
you can use quickly open stream to open

00:51:04,380 --> 00:51:08,760
a stream this this is all the stream

00:51:07,020 --> 00:51:10,050
level API right now that I'm going to

00:51:08,760 --> 00:51:13,140
show and then I'll show the connection

00:51:10,050 --> 00:51:15,720
level API and then there's a callback

00:51:13,140 --> 00:51:18,680
that's registered to call when a stream

00:51:15,720 --> 00:51:20,640
gets opened on the other side so

00:51:18,680 --> 00:51:23,040
similarly there's a stream level

00:51:20,640 --> 00:51:25,980
callback which says okay I have now

00:51:23,040 --> 00:51:27,510
space to send fill data in here this is

00:51:25,980 --> 00:51:28,980
the bufferless API I was talking about

00:51:27,510 --> 00:51:30,990
there's a callback that the application

00:51:28,980 --> 00:51:33,060
registers that that quickly will call

00:51:30,990 --> 00:51:37,530
into when there's there's availability

00:51:33,060 --> 00:51:39,420
of space to send new data and similarly

00:51:37,530 --> 00:51:41,670
there's other things about how when when

00:51:39,420 --> 00:51:43,020
something gets acknowledged again

00:51:41,670 --> 00:51:44,640
remember that the application is the one

00:51:43,020 --> 00:51:46,290
that's maintaining all the buffers right

00:51:44,640 --> 00:51:48,180
it quickly doesn't have any buffers so

00:51:46,290 --> 00:51:49,950
there's a callback to say get rid of

00:51:48,180 --> 00:51:51,390
this data it's been acknowledged from

00:51:49,950 --> 00:51:56,660
the peer you don't need to maintain it

00:51:51,390 --> 00:51:58,680
anymore there's there's yeah so

00:51:56,660 --> 00:52:00,360
applications can call back in too

00:51:58,680 --> 00:52:01,920
quickly and say oh you asked for data

00:52:00,360 --> 00:52:04,380
earlier I didn't have any data but now

00:52:01,920 --> 00:52:06,240
there's more data and so there's all of

00:52:04,380 --> 00:52:07,860
those calls for basically and all of

00:52:06,240 --> 00:52:10,110
these operators the stream level because

00:52:07,860 --> 00:52:12,180
the expectation is that ultimately a

00:52:10,110 --> 00:52:14,430
consumer and a provider of data is

00:52:12,180 --> 00:52:18,150
operating at the stream level that can

00:52:14,430 --> 00:52:20,100
be one application but the expectation

00:52:18,150 --> 00:52:25,620
is that you register one callback per

00:52:20,100 --> 00:52:28,080
stream on the receive side there's a

00:52:25,620 --> 00:52:29,940
callback to to receive data when creator

00:52:28,080 --> 00:52:32,040
arrives on a stream you have the

00:52:29,940 --> 00:52:36,150
callback that that that delivers that

00:52:32,040 --> 00:52:38,580
data and there's also a a call from the

00:52:36,150 --> 00:52:41,640
application to say I've removed this

00:52:38,580 --> 00:52:43,560
data from the receive buffer basically

00:52:41,640 --> 00:52:45,890
you can move your you know your your

00:52:43,560 --> 00:52:48,660
flow control window forward for example

00:52:45,890 --> 00:52:50,370
so that's that's a sink down from the

00:52:48,660 --> 00:52:54,570
application saying I've finished

00:52:50,370 --> 00:52:56,880
consuming this data closing streams

00:52:54,570 --> 00:52:58,620
straightforward there's a there's a call

00:52:56,880 --> 00:53:00,000
to close the stream from the application

00:52:58,620 --> 00:53:01,590
and there's a callback that says yes

00:53:00,000 --> 00:53:04,790
I've cleared out all the application all

00:53:01,590 --> 00:53:04,790
the stream related state

00:53:04,829 --> 00:53:08,930
and now we move on to the connection

00:53:06,239 --> 00:53:11,940
level stuff so this is basically where

00:53:08,930 --> 00:53:13,559
there's there's quickly is operating now

00:53:11,940 --> 00:53:15,479
not at the stream level but at the

00:53:13,559 --> 00:53:18,630
packet level right so that's quickly

00:53:15,479 --> 00:53:20,430
sent which is basically we are we are in

00:53:18,630 --> 00:53:21,779
the process right now of trying to

00:53:20,430 --> 00:53:23,400
figure out if we should rename some of

00:53:21,779 --> 00:53:25,920
these functions so quickly send

00:53:23,400 --> 00:53:29,670
basically is called to say you know

00:53:25,920 --> 00:53:31,289
crank the wheel see there's any data to

00:53:29,670 --> 00:53:33,089
send send it out of the simulator to

00:53:31,289 --> 00:53:35,309
send or if there are retransmissions to

00:53:33,089 --> 00:53:36,869
send out of a timer has fired or so on

00:53:35,309 --> 00:53:39,029
and so forth so this is basically what

00:53:36,869 --> 00:53:40,289
the event loop calls into so the

00:53:39,029 --> 00:53:43,829
application is supposed to keep cranking

00:53:40,289 --> 00:53:45,209
the wheel by calling quickly send how

00:53:43,829 --> 00:53:48,390
often should it call quickly send

00:53:45,209 --> 00:53:50,640
whenever it has data and it has like you

00:53:48,390 --> 00:53:52,650
know put dump that into the stream

00:53:50,640 --> 00:53:55,170
buffer and it can call quickly send to

00:53:52,650 --> 00:53:57,269
say yep I've put some data on the stream

00:53:55,170 --> 00:54:00,089
buffer go ahead and not same buffer

00:53:57,269 --> 00:54:02,420
sorry I have some data to send and and

00:54:00,089 --> 00:54:06,569
I'm going to ask you to send it or

00:54:02,420 --> 00:54:08,489
quickly returns a time so the

00:54:06,569 --> 00:54:11,459
application is expected to call quickly

00:54:08,489 --> 00:54:14,609
get first time out to say when should I

00:54:11,459 --> 00:54:16,289
call back quickly send again and quickly

00:54:14,609 --> 00:54:20,729
will say here's a time that I mod is

00:54:16,289 --> 00:54:22,440
based on retransmission logic on delayed

00:54:20,729 --> 00:54:25,650
acknowledgement logic various logic and

00:54:22,440 --> 00:54:27,539
quickly remained in state for what to do

00:54:25,650 --> 00:54:29,640
when the timer actually fires but the

00:54:27,539 --> 00:54:30,869
timer itself is in the applications and

00:54:29,640 --> 00:54:32,839
the application is the one that's

00:54:30,869 --> 00:54:35,039
actually driving the event loop forward

00:54:32,839 --> 00:54:37,949
so that's that's what those two

00:54:35,039 --> 00:54:39,719
functions are for on receiving packets

00:54:37,949 --> 00:54:42,769
quickly offers a decode packet so you

00:54:39,719 --> 00:54:48,329
basically grab a packet and you you

00:54:42,769 --> 00:54:51,029
decode it using packet and as yeah

00:54:48,329 --> 00:54:54,140
quickly receive which which takes a

00:54:51,029 --> 00:54:54,140
decoded packet and then actually

00:55:10,470 --> 00:55:16,990
it's the CDN that controls that because

00:55:13,599 --> 00:55:20,380
it knows where the link characteristics

00:55:16,990 --> 00:55:22,539
of the end-users sure so are you going

00:55:20,380 --> 00:55:25,089
to deal with that problem in the server

00:55:22,539 --> 00:55:28,839
side or in the client side and they

00:55:25,089 --> 00:55:30,460
received okay in there and there are you

00:55:28,839 --> 00:55:32,380
see I mean in the receiver side

00:55:30,460 --> 00:55:34,150
I do understand so I should probably

00:55:32,380 --> 00:55:38,500
make one thing clear because I've heard

00:55:34,150 --> 00:55:40,390
this not twice the goal here for the

00:55:38,500 --> 00:55:41,710
receive and the same side in the server

00:55:40,390 --> 00:55:43,960
and the client side so to speak is not

00:55:41,710 --> 00:55:46,720
to make quickly available on both sides

00:55:43,960 --> 00:55:48,730
right so quickly is basically just one

00:55:46,720 --> 00:55:50,019
end of the implementation just like TCP

00:55:48,730 --> 00:55:51,339
has both server and client

00:55:50,019 --> 00:55:53,980
implementations within the same

00:55:51,339 --> 00:55:56,829
implementation we have everything in

00:55:53,980 --> 00:55:58,779
here and and send and receive are both

00:55:56,829 --> 00:56:01,660
functions that are available at both

00:55:58,779 --> 00:56:05,740
endpoints the client side is unlikely to

00:56:01,660 --> 00:56:07,269
be our server implementation commonly we

00:56:05,740 --> 00:56:09,400
expect browsers to be doing the client

00:56:07,269 --> 00:56:10,660
side implementation so in terms of the

00:56:09,400 --> 00:56:12,369
optimization that you're talking about

00:56:10,660 --> 00:56:17,079
that's going to happen at a layer that's

00:56:12,369 --> 00:56:21,910
above this API I think that's a protocol

00:56:17,079 --> 00:56:24,180
level question that you're asking but we

00:56:21,910 --> 00:56:27,369
can talk about this more later as well

00:56:24,180 --> 00:56:30,700
but but yeah just to be clear everything

00:56:27,369 --> 00:56:32,470
I'm showing here is basically a full

00:56:30,700 --> 00:56:33,910
solid quickly implementation at the same

00:56:32,470 --> 00:56:35,109
time what we are working on is

00:56:33,910 --> 00:56:37,240
interoperating with other

00:56:35,109 --> 00:56:38,829
implementations so that our server can

00:56:37,240 --> 00:56:41,170
work with other clients and other

00:56:38,829 --> 00:56:47,619
servers can work with our test client

00:56:41,170 --> 00:56:49,599
basically I am NOT going to go to do the

00:56:47,619 --> 00:56:52,089
read-through because I have 35 minutes

00:56:49,599 --> 00:56:54,220
and I I think the subsequent things are

00:56:52,089 --> 00:56:57,970
going to be more interesting I have a

00:56:54,220 --> 00:57:02,559
wait a second how did this jump go find

00:56:57,970 --> 00:57:05,619
that code and and try it out

00:57:02,559 --> 00:57:09,670
I can I can run it and show you but it

00:57:05,619 --> 00:57:11,740
says you could run it yourself actually

00:57:09,670 --> 00:57:15,069
you know what I'll show you how this

00:57:11,740 --> 00:57:15,720
works because it's a quick server using

00:57:15,069 --> 00:57:30,390
its

00:57:15,720 --> 00:57:33,359
it's a so I'll just so that's basically

00:57:30,390 --> 00:57:35,700
just the the echo server I'm gonna run

00:57:33,359 --> 00:57:38,880
the echo server there if you can see can

00:57:35,700 --> 00:57:46,890
you see can everybody see that it's kind

00:57:38,880 --> 00:57:48,599
of tiny okay let me see you don't have

00:57:46,890 --> 00:57:50,160
to sit in memorize this right now it's

00:57:48,599 --> 00:57:51,569
quite fine the point here is that

00:57:50,160 --> 00:57:53,190
running the echo server requires you to

00:57:51,569 --> 00:57:55,619
supply a server key and a server

00:57:53,190 --> 00:57:57,390
certificate because again as I said it's

00:57:55,619 --> 00:57:59,579
always encrypted and it needs these

00:57:57,390 --> 00:58:01,829
things to to set up the TLS server and

00:57:59,579 --> 00:58:04,319
these manager to to actually do the

00:58:01,829 --> 00:58:08,550
right things here so now the server's

00:58:04,319 --> 00:58:12,300
running on that side I am going to run

00:58:08,550 --> 00:58:21,810
the client on this side connects to the

00:58:12,300 --> 00:58:23,700
server and I'll see there we go there

00:58:21,810 --> 00:58:27,869
you go yay the first bits of quick I've

00:58:23,700 --> 00:58:29,430
flown so that's that the echo server you

00:58:27,869 --> 00:58:32,220
can you can you can play notes it's a

00:58:29,430 --> 00:58:35,369
very simple implementation that kazuo

00:58:32,220 --> 00:58:38,609
put together especially for this so go

00:58:35,369 --> 00:58:40,079
take a look and it's it's it's a good

00:58:38,609 --> 00:58:42,420
way to get started if you're trying to

00:58:40,079 --> 00:58:48,900
write a simple client and server using

00:58:42,420 --> 00:58:51,390
quick so so I'm going to move past this

00:58:48,900 --> 00:58:52,829
and I'm going to go to tooling because I

00:58:51,390 --> 00:58:55,520
know there are thoughts about tooling

00:58:52,829 --> 00:58:55,520
yes question

00:59:01,680 --> 00:59:08,050
so what the question is what is what is

00:59:04,870 --> 00:59:09,760
the first packet of the client how does

00:59:08,050 --> 00:59:11,650
it get encrypted what's the keying

00:59:09,760 --> 00:59:14,680
material so the first packet of the

00:59:11,650 --> 00:59:16,210
client is from the client in a fresh

00:59:14,680 --> 00:59:19,660
connection that you never spoken to the

00:59:16,210 --> 00:59:22,360
server before is encrypted it's

00:59:19,660 --> 00:59:25,120
effectively obfuscated it's encrypted

00:59:22,360 --> 00:59:27,910
with the static key that's the key that

00:59:25,120 --> 00:59:32,200
we are publishing in the draft so so but

00:59:27,910 --> 00:59:35,620
it's also include so that's that's not

00:59:32,200 --> 00:59:38,320
going to be something that you call we

00:59:35,620 --> 00:59:40,210
would call rate encryption on a

00:59:38,320 --> 00:59:41,590
subsequent connection however this is a

00:59:40,210 --> 00:59:43,120
more important one on subsequent

00:59:41,590 --> 00:59:44,710
connection where we expect to get zero

00:59:43,120 --> 00:59:48,010
round-trip time we encrypted earrings

00:59:44,710 --> 00:59:56,770
using the zero RT t keys that we got the

00:59:48,010 --> 00:59:58,060
last time so the so so tooling this is

00:59:56,770 --> 01:00:01,810
there's been a burning question for a

00:59:58,060 --> 01:00:03,400
lot of people about quick because well

01:00:01,810 --> 01:00:05,860
the first thing I'll say is well that's

01:00:03,400 --> 01:00:08,530
a wire shock detector so go bonkers

01:00:05,860 --> 01:00:12,070
that is tooling available isn't Wysocki

01:00:08,530 --> 01:00:16,210
not for everybody it's not apparently

01:00:12,070 --> 01:00:16,900
why isn't it enough in this case he says

01:00:16,210 --> 01:00:19,030
it's encrypted

01:00:16,900 --> 01:00:21,130
and it's very baffled how is that a

01:00:19,030 --> 01:00:22,690
Wireshark dissected so there is a

01:00:21,130 --> 01:00:24,040
Wireshark decision and you're right it's

01:00:22,690 --> 01:00:25,690
encrypted so you need to feed it a

01:00:24,040 --> 01:00:26,830
master key for it to be able to open up

01:00:25,690 --> 01:00:29,110
the packets and look at it because

01:00:26,830 --> 01:00:31,390
without that it can basically read it

01:00:29,110 --> 01:00:33,190
can still read a few bytes but there

01:00:31,390 --> 01:00:35,350
aren't that isn't very much that you can

01:00:33,190 --> 01:00:39,700
really look at in a packet trace that

01:00:35,350 --> 01:00:40,900
makes it interesting so so yes so

01:00:39,700 --> 01:00:43,090
there's a bit of a problem here right if

01:00:40,900 --> 01:00:45,430
you wanna grab traces you have to grab

01:00:43,090 --> 01:00:47,260
the key as well what what does it mean

01:00:45,430 --> 01:00:48,610
though if you have an encrypted payload

01:00:47,260 --> 01:00:49,630
in encrypted headers and everything else

01:00:48,610 --> 01:00:51,790
what does it mean if you're trying to

01:00:49,630 --> 01:00:53,770
record traffic if you're going to use

01:00:51,790 --> 01:00:55,090
wire shock what does it mean you're

01:00:53,770 --> 01:00:56,590
gonna have to record the entire payload

01:00:55,090 --> 01:01:00,910
for the connection you can't simply

01:00:56,590 --> 01:01:02,620
record the headers yet record the entire

01:01:00,910 --> 01:01:04,420
payload record the whole connection and

01:01:02,620 --> 01:01:05,860
then you have to go decrypt it and and

01:01:04,420 --> 01:01:07,270
that's got all sorts of issues

01:01:05,860 --> 01:01:08,950
especially if you are logging this if

01:01:07,270 --> 01:01:11,930
you are storing this somewhere it's got

01:01:08,950 --> 01:01:16,250
all sorts of PII type issues

01:01:11,930 --> 01:01:18,140
and privacy issues so there's a lot of

01:01:16,250 --> 01:01:21,260
issues with this so one of the things

01:01:18,140 --> 01:01:23,240
that we realized is that this is not

01:01:21,260 --> 01:01:26,390
adequate and we need something that's

01:01:23,240 --> 01:01:29,240
that's that's better and so we've been

01:01:26,390 --> 01:01:31,099
trying and we've been working on when I

01:01:29,240 --> 01:01:32,539
say we the broader community not just

01:01:31,099 --> 01:01:34,369
not just me we've been working on

01:01:32,539 --> 01:01:36,109
endpoint based packet tracing the point

01:01:34,369 --> 01:01:38,720
being here that the server and the

01:01:36,109 --> 01:01:39,710
clients are best positioned to actually

01:01:38,720 --> 01:01:42,260
describe what's going on in the

01:01:39,710 --> 01:01:43,099
connection and they have the keys and

01:01:42,260 --> 01:01:46,160
they are going to be looking at the

01:01:43,099 --> 01:01:48,020
packets anyway so as long as you're not

01:01:46,160 --> 01:01:50,420
as long as you're an endpoint we ought

01:01:48,020 --> 01:01:53,779
to be able to at least grab traces at

01:01:50,420 --> 01:01:56,390
the endpoints themselves so this has

01:01:53,779 --> 01:01:58,730
been gaining a lot of traction and this

01:01:56,390 --> 01:02:00,440
is what we have been working on at

01:01:58,730 --> 01:02:02,150
transia as well so I'll show you some of

01:02:00,440 --> 01:02:04,430
some of the tooling that's being built

01:02:02,150 --> 01:02:06,260
in the community right now on this so

01:02:04,430 --> 01:02:08,510
the idea here is that the quick server

01:02:06,260 --> 01:02:10,190
and the quick client log packet level

01:02:08,510 --> 01:02:13,730
events and various other events and

01:02:10,190 --> 01:02:18,890
those logs turn into you know various

01:02:13,730 --> 01:02:23,869
visualizations and other things so there

01:02:18,890 --> 01:02:24,980
are two tools I will be showing you one

01:02:23,869 --> 01:02:26,510
of them in more detail than the other

01:02:24,980 --> 01:02:29,210
one but there's good place and there's

01:02:26,510 --> 01:02:32,569
quick ways and both of the implementers

01:02:29,210 --> 01:02:34,670
will be present at the IETF coming up

01:02:32,569 --> 01:02:36,230
and they'll be so if you're interested

01:02:34,670 --> 01:02:38,329
they'll be there and you can talk to

01:02:36,230 --> 01:02:40,819
them the first one is quick trace which

01:02:38,329 --> 01:02:43,579
comes out of Google and this was written

01:02:40,819 --> 01:02:45,880
by Victor Vasily F and others and this

01:02:43,579 --> 01:02:49,099
is open source and it's available

01:02:45,880 --> 01:02:51,079
basically you feed it a proto buff or a

01:02:49,099 --> 01:02:53,000
JSON if you want there's a converter

01:02:51,079 --> 01:02:55,760
that converts some JSON to protobuf and

01:02:53,000 --> 01:02:57,529
then feeds that into the tool and this

01:02:55,760 --> 01:03:02,119
is an awesome tool because it basically

01:02:57,529 --> 01:03:04,730
gives you a packet trace this looks very

01:03:02,119 --> 01:03:08,480
much like other PCP traces that you

01:03:04,730 --> 01:03:11,180
might have seen and I'll show this in a

01:03:08,480 --> 01:03:14,720
moment but this basically is generated

01:03:11,180 --> 01:03:17,930
and entirely by the server process the

01:03:14,720 --> 01:03:20,029
quick server generating logs that

01:03:17,930 --> 01:03:23,020
generate those packet traces this is not

01:03:20,029 --> 01:03:23,020
from a peekaboo

01:03:23,630 --> 01:03:29,910
the second tool is QuickBase which is

01:03:27,329 --> 01:03:32,190
written by robin marx and others at

01:03:29,910 --> 01:03:36,930
university of hasselt and they've done

01:03:32,190 --> 01:03:38,790
some extraordinary work they take input

01:03:36,930 --> 01:03:41,670
the input that they can as JSON and they

01:03:38,790 --> 01:03:44,640
produce basically various state

01:03:41,670 --> 01:03:47,700
transitions in the transport in HTTP

01:03:44,640 --> 01:03:50,970
levels and what's going on on different

01:03:47,700 --> 01:03:53,310
streams at different times and a full

01:03:50,970 --> 01:03:57,359
timing diagram this is produced from

01:03:53,310 --> 01:03:59,670
places of course they can they can do

01:03:57,359 --> 01:04:01,950
partial traces meaning only one end one

01:03:59,670 --> 01:04:03,720
side or they can take traces on the

01:04:01,950 --> 01:04:06,720
client and the server and put pull this

01:04:03,720 --> 01:04:09,450
together so this is some incredible work

01:04:06,720 --> 01:04:12,119
that they've been doing and also you

01:04:09,450 --> 01:04:24,150
know various other graphs that you might

01:04:12,119 --> 01:04:26,609
be familiar with in the TCP world I

01:04:24,150 --> 01:04:28,140
can't speak to that I've not really

01:04:26,609 --> 01:04:30,569
tested them with large traces the quick

01:04:28,140 --> 01:04:33,359
trace is actually super super good for

01:04:30,569 --> 01:04:36,210
large traces quick quiz I don't know I

01:04:33,359 --> 01:04:38,040
haven't really worked with it myself I'm

01:04:36,210 --> 01:04:39,540
trying to talk to them but there's

01:04:38,040 --> 01:04:40,710
active development again pretty much

01:04:39,540 --> 01:04:42,150
everything you're gonna find in this

01:04:40,710 --> 01:04:44,130
world right now is rough-edged

01:04:42,150 --> 01:04:46,619
because all of this is work in progress

01:04:44,130 --> 01:04:48,540
right I mean just about stabilizing the

01:04:46,619 --> 01:04:50,190
protocol format at the moment so you're

01:04:48,540 --> 01:04:52,260
going to find that the things have rough

01:04:50,190 --> 01:05:00,990
edges but these are things that we can

01:04:52,260 --> 01:05:03,089
make work with so so before going into

01:05:00,990 --> 01:05:05,160
this I want to talk about exactly what

01:05:03,089 --> 01:05:07,079
the quic packet looks like so you know

01:05:05,160 --> 01:05:09,450
what you're looking for so you know what

01:05:07,079 --> 01:05:10,770
it is that we are tracing right so and

01:05:09,450 --> 01:05:12,990
this is also a little bit of protocol

01:05:10,770 --> 01:05:15,780
detail that is hopefully helpful for you

01:05:12,990 --> 01:05:17,250
to understand how quick packets look how

01:05:15,780 --> 01:05:20,940
quick an encapsulation look how the

01:05:17,250 --> 01:05:24,630
packetization works so quick packets

01:05:20,940 --> 01:05:28,829
have come in to two varieties because

01:05:24,630 --> 01:05:30,630
one is boring we like we got two there's

01:05:28,829 --> 01:05:33,569
the long header format and there's the

01:05:30,630 --> 01:05:35,750
short header format the long header is

01:05:33,569 --> 01:05:37,820
primarily used during the

01:05:35,750 --> 01:05:40,850
not just primarily it's only used during

01:05:37,820 --> 01:05:43,070
the handshake this is to establish

01:05:40,850 --> 01:05:46,610
various kinds of things that we don't

01:05:43,070 --> 01:05:48,380
know about the pier but we so this is

01:05:46,610 --> 01:05:49,820
what the long header looks like I'm not

01:05:48,380 --> 01:05:51,410
gonna go into all the details here but

01:05:49,820 --> 01:05:53,180
it's got as you can see it has a version

01:05:51,410 --> 01:05:56,180
number in there and it has connection

01:05:53,180 --> 01:06:02,150
IDs as I mentioned to you earlier in

01:05:56,180 --> 01:06:03,890
there as well and once we've negotiated

01:06:02,150 --> 01:06:05,810
the version and once we finish the

01:06:03,890 --> 01:06:08,660
handshake we don't need a number of

01:06:05,810 --> 01:06:10,670
these things so we can go with a shorter

01:06:08,660 --> 01:06:13,580
version of the header and that basically

01:06:10,670 --> 01:06:17,150
includes only a handful of things it has

01:06:13,580 --> 01:06:18,170
a packet number and it has a destination

01:06:17,150 --> 01:06:21,920
connection area it doesn't have a

01:06:18,170 --> 01:06:27,470
version notably as you can see now not

01:06:21,920 --> 01:06:29,180
all of these are visible on the wire to

01:06:27,470 --> 01:06:31,070
be clear and not all of these are going

01:06:29,180 --> 01:06:34,460
to be fixed in time our expectation is

01:06:31,070 --> 01:06:36,920
there as quick versions happen that many

01:06:34,460 --> 01:06:38,690
of these things will change specifically

01:06:36,920 --> 01:06:40,730
there's a draft called the quick

01:06:38,690 --> 01:06:43,010
invariants draft that talks about which

01:06:40,730 --> 01:06:45,920
parts of the header encrypted or not

01:06:43,010 --> 01:06:47,510
will remain the same across quick

01:06:45,920 --> 01:06:49,280
versions and which parts are not

01:06:47,510 --> 01:06:51,020
guaranteed to remain the same this was

01:06:49,280 --> 01:06:53,870
basically a way for us to delve in

01:06:51,020 --> 01:06:56,030
middle box vendors or any vendor

01:06:53,870 --> 01:06:59,480
basically what they can go and ossify

01:06:56,030 --> 01:07:01,610
and what they cannot ossify so if you

01:06:59,480 --> 01:07:03,560
look at this header it basically shows

01:07:01,610 --> 01:07:06,350
you that you know from the long-long

01:07:03,560 --> 01:07:07,130
header those flags are basically

01:07:06,350 --> 01:07:10,370
off-limits

01:07:07,130 --> 01:07:12,500
those can keep changing across versions

01:07:10,370 --> 01:07:14,330
that the first bit of one is going to

01:07:12,500 --> 01:07:18,290
remain the same across all versions of

01:07:14,330 --> 01:07:20,750
quick for the short header does the

01:07:18,290 --> 01:07:24,950
connection ID is visible and that's

01:07:20,750 --> 01:07:26,560
basically it and the zero so commonly

01:07:24,950 --> 01:07:28,820
through the lifetime of a connection

01:07:26,560 --> 01:07:30,170
there's going to be the zero that's at

01:07:28,820 --> 01:07:31,790
the beginning that's going to be visible

01:07:30,170 --> 01:07:34,130
and then there's the connection ID

01:07:31,790 --> 01:07:35,690
that's going to be visible that's all

01:07:34,130 --> 01:07:37,220
that's really usable now bear in mind

01:07:35,690 --> 01:07:39,530
that the connection ID itself can be

01:07:37,220 --> 01:07:40,880
renegotiated on the crypto power so the

01:07:39,530 --> 01:07:43,370
connection ID can change within a

01:07:40,880 --> 01:07:44,870
connection so if you want to go latch

01:07:43,370 --> 01:07:45,960
onto a connection ID and think this is

01:07:44,870 --> 01:08:09,960
the connection

01:07:45,960 --> 01:08:12,270
oh the long-headed so the longer has

01:08:09,960 --> 01:08:13,859
connection ID so the question is if I

01:08:12,270 --> 01:08:15,030
understand correctly you're saying the

01:08:13,859 --> 01:08:40,140
long hair it doesn't it does not

01:08:15,030 --> 01:08:41,520
connection ID in the long I see so

01:08:40,140 --> 01:08:42,989
you're asking if you can create a

01:08:41,520 --> 01:08:44,400
connection without actually using a long

01:08:42,989 --> 01:08:48,870
hair no that's not the case right now

01:08:44,400 --> 01:08:50,310
you can't no no not doable either I mean

01:08:48,870 --> 01:08:52,020
not not not with the way that their

01:08:50,310 --> 01:08:53,819
handshake mechanisms work it's

01:08:52,020 --> 01:08:55,950
technically possible to do it in a

01:08:53,819 --> 01:09:00,060
different protocol but that's not our

01:08:55,950 --> 01:09:02,160
goal yeah so that's what the packet

01:09:00,060 --> 01:09:05,130
headers looked like water inside of

01:09:02,160 --> 01:09:09,000
packets beyond the packet header there

01:09:05,130 --> 01:09:11,130
are quick frames that's basically what

01:09:09,000 --> 01:09:14,040
I'll talk about them in a moment every

01:09:11,130 --> 01:09:17,569
frame looks like this there's a frame

01:09:14,040 --> 01:09:20,339
type and there are type dependent fields

01:09:17,569 --> 01:09:22,020
okay so there's a basically quick packet

01:09:20,339 --> 01:09:24,029
has a packet header and has a bunch of

01:09:22,020 --> 01:09:26,670
frames and each of them has a type and

01:09:24,029 --> 01:09:28,529
then very type dependent fields and

01:09:26,670 --> 01:09:30,600
these are all the different types of

01:09:28,529 --> 01:09:34,469
frames that are currently defined in the

01:09:30,600 --> 01:09:36,060
draft as you can see the ones that that

01:09:34,469 --> 01:09:38,520
the functions at least that you might be

01:09:36,060 --> 01:09:40,440
familiar with I'll point to them there's

01:09:38,520 --> 01:09:43,290
the stream frame and there's the ACK

01:09:40,440 --> 01:09:46,170
frame stream frame carries data the arc

01:09:43,290 --> 01:09:47,250
frame carries acknowledgments right so

01:09:46,170 --> 01:09:48,989
those are basically not part of the

01:09:47,250 --> 01:09:53,370
packet header they're all contained

01:09:48,989 --> 01:09:55,469
inside of a packet as frames you can see

01:09:53,370 --> 01:09:58,020
various other things such as max data

01:09:55,469 --> 01:09:59,489
all the max data max stream data Mac

01:09:58,020 --> 01:09:59,940
streams pretty much all of these are

01:09:59,489 --> 01:10:04,110
basically

01:09:59,940 --> 01:10:05,580
control trade frames and all the control

01:10:04,110 --> 01:10:07,340
signaling that happens within between

01:10:05,580 --> 01:10:09,600
the endpoints happens with frames

01:10:07,340 --> 01:10:11,880
there's more these frames like the ping

01:10:09,600 --> 01:10:13,949
frame is basically a one byte frame

01:10:11,880 --> 01:10:16,860
order this is a frame type there's no

01:10:13,949 --> 01:10:18,180
data in it but they're all you all of

01:10:16,860 --> 01:10:21,980
these frames are used for control

01:10:18,180 --> 01:10:21,980
signaling between the two endpoints

01:10:22,940 --> 01:10:29,670
right so let's look at one of these in a

01:10:28,260 --> 01:10:32,460
little bit of detail so we try to

01:10:29,670 --> 01:10:35,190
understand basically how it is that data

01:10:32,460 --> 01:10:37,350
flows in a connection so a stream frame

01:10:35,190 --> 01:10:40,140
which carries application data

01:10:37,350 --> 01:10:42,810
ultimately has these headers it has a

01:10:40,140 --> 01:10:44,940
stream ID which indicates the stream

01:10:42,810 --> 01:10:47,460
number basically that this data is going

01:10:44,940 --> 01:10:49,140
to it has an offset that's optional

01:10:47,460 --> 01:10:51,600
offset in the stream

01:10:49,140 --> 01:10:54,390
it's a byte offset within the stream so

01:10:51,600 --> 01:10:56,550
one stream is roughly it's semantically

01:10:54,390 --> 01:10:59,610
equivalent to a TCP connection once

01:10:56,550 --> 01:11:00,780
every stream is a byte stream right so

01:10:59,610 --> 01:11:04,590
you can have multiple of these within a

01:11:00,780 --> 01:11:07,380
connection and the length tells you how

01:11:04,590 --> 01:11:09,239
big this particular frame itself is and

01:11:07,380 --> 01:11:12,180
then the stream data there's actually

01:11:09,239 --> 01:11:15,150
the data right so that's what a stream

01:11:12,180 --> 01:11:17,580
cream contains so let's look at how a

01:11:15,150 --> 01:11:20,070
quick packet would look with various

01:11:17,580 --> 01:11:22,230
things in it so here's a quick short

01:11:20,070 --> 01:11:23,969
header packet it's the header bit as one

01:11:22,230 --> 01:11:25,350
that indicates is the shorted a packet

01:11:23,969 --> 01:11:29,100
there's the spin bit which I will not go

01:11:25,350 --> 01:11:31,110
into but that is basically a bit that is

01:11:29,100 --> 01:11:33,360
supposed to indicate they're suppose to

01:11:31,110 --> 01:11:38,340
be used by operators for doing passive

01:11:33,360 --> 01:11:39,600
measurements of RTT specifically there's

01:11:38,340 --> 01:11:41,310
the destination connection ID there's a

01:11:39,600 --> 01:11:44,370
key phase and there's a packet number

01:11:41,310 --> 01:11:45,840
and those are encrypted so the greyed

01:11:44,370 --> 01:11:47,010
out ones are basically and even

01:11:45,840 --> 01:11:50,670
the packet number by the way is

01:11:47,010 --> 01:11:52,020
encrypted so a metal box can't even see

01:11:50,670 --> 01:11:57,840
what the packet number of a particular

01:11:52,020 --> 01:11:59,160
packet is and a quick packet as I

01:11:57,840 --> 01:12:00,449
mentioned has frames so in this

01:11:59,160 --> 01:12:02,190
particular example there's a stream

01:12:00,449 --> 01:12:06,030
there to stream frames and an action

01:12:02,190 --> 01:12:08,100
alright so let's look at one example one

01:12:06,030 --> 01:12:11,429
example right so this is packet number

01:12:08,100 --> 01:12:12,809
56 and it is carrying data from stream

01:12:11,429 --> 01:12:15,599
ID five at

01:12:12,809 --> 01:12:17,849
at offset 11 23 and it has a length of

01:12:15,599 --> 01:12:20,130
500 bytes and it says that this is not

01:12:17,849 --> 01:12:24,030
the last frame in this particular stream

01:12:20,130 --> 01:12:26,190
which means that it's the the fin bit is

01:12:24,030 --> 01:12:29,099
set to false and then it carries

01:12:26,190 --> 01:12:30,480
application data everything good so far

01:12:29,099 --> 01:12:32,309
there's going to be a quiz so pay

01:12:30,480 --> 01:12:38,460
attention if you're falling asleep good

01:12:32,309 --> 01:12:40,139
time to wake up wake up wake up all

01:12:38,460 --> 01:12:42,300
right

01:12:40,139 --> 01:12:47,429
that's in that stream ID that's in that

01:12:42,300 --> 01:12:49,409
stream frame this is another stream

01:12:47,429 --> 01:12:52,289
frame this carries data from another

01:12:49,409 --> 01:12:55,020
stream ID right stream ID 8 it has a

01:12:52,289 --> 01:12:58,520
length of 300 the fin is false but the

01:12:55,020 --> 01:12:58,520
offsets not there what does that mean

01:13:00,020 --> 01:13:06,389
the office is not there 0 thank you yes

01:13:04,320 --> 01:13:08,520
the obvious conclusion yes so offset is

01:13:06,389 --> 01:13:11,039
optional if it's if it's not there it's

01:13:08,520 --> 01:13:14,510
0 there's a bit that indicates that the

01:13:11,039 --> 01:13:16,710
offset is present or not in the flags

01:13:14,510 --> 01:13:21,420
and the rest application data of course

01:13:16,710 --> 01:13:23,639
so this is fine and in this example

01:13:21,420 --> 01:13:29,400
continue example we've removed the

01:13:23,639 --> 01:13:31,099
length what does that mean that means no

01:13:29,400 --> 01:13:33,929
data no it doesn't mean there's no data

01:13:31,099 --> 01:13:38,550
although you can send a empty a stream

01:13:33,929 --> 01:13:39,960
frame the maximum length the maximum

01:13:38,550 --> 01:13:41,159
link that goes up to the end of the

01:13:39,960 --> 01:13:43,530
packet which means this particular

01:13:41,159 --> 01:13:44,940
packet ization is incorrect what it

01:13:43,530 --> 01:13:47,909
really looks like should look like is

01:13:44,940 --> 01:13:49,289
this basically it says everything from

01:13:47,909 --> 01:13:52,440
here up onto the end of the packet is

01:13:49,289 --> 01:13:53,880
this stream data all right so the length

01:13:52,440 --> 01:13:55,770
is optional as well if you're going to

01:13:53,880 --> 01:13:57,750
look in the common case when you are

01:13:55,770 --> 01:14:00,179
packing every packet is just data from

01:13:57,750 --> 01:14:02,010
one stream in the bulk transfer case you

01:14:00,179 --> 01:14:05,730
you have the offset but you remove the

01:14:02,010 --> 01:14:08,250
length that's the general idea so that's

01:14:05,730 --> 01:14:12,679
what we got for these these this is what

01:14:08,250 --> 01:14:19,409
a stream frame looks like all right and

01:14:12,679 --> 01:14:21,809
going back to the ACK frame now let's

01:14:19,409 --> 01:14:26,280
look at the action ok the acronym has a

01:14:21,809 --> 01:14:27,840
number of fields in it and it has

01:14:26,280 --> 01:14:29,700
if you're familiar I'll try to draw

01:14:27,840 --> 01:14:33,080
parallels so how many of you are

01:14:29,700 --> 01:14:36,320
familiar with the TCP packet format

01:14:33,080 --> 01:14:40,430
seriously like for people in this room

01:14:36,320 --> 01:14:40,430
how many of you are sleeping right now

01:14:40,880 --> 01:14:47,250
yeah I was expecting that response all

01:14:43,830 --> 01:14:50,670
right wake up wake up wake up like I

01:14:47,250 --> 01:14:52,230
said there's a quiz and and you won't be

01:14:50,670 --> 01:14:54,090
allowed to go out and get coffee after

01:14:52,230 --> 01:14:56,910
this if you don't answer the questions

01:14:54,090 --> 01:14:59,640
on the quiz critical I mean not just

01:14:56,910 --> 01:15:01,880
reward right but but what is the carrot

01:14:59,640 --> 01:15:01,880
and the stick

01:15:02,210 --> 01:15:13,800
what's it I have a man that he's gonna

01:15:08,010 --> 01:15:17,850
hold the gate there so the act itself

01:15:13,800 --> 01:15:19,920
carries a largest acknowledged what does

01:15:17,850 --> 01:15:24,110
the equivalent not the equivalent what

01:15:19,920 --> 01:15:26,910
is the TCP packet carry in it it carries

01:15:24,110 --> 01:15:28,380
the Iraqi carries a sequence number on

01:15:26,910 --> 01:15:30,600
the send side on the receive side or

01:15:28,380 --> 01:15:32,850
meaning on the on the AK side

01:15:30,600 --> 01:15:35,340
it's got a cumulative ACK okay

01:15:32,850 --> 01:15:38,520
cumulative ACK is the smallest number

01:15:35,340 --> 01:15:41,970
that you received in order this one is

01:15:38,520 --> 01:15:46,740
the largest acknowledged it's the other

01:15:41,970 --> 01:15:48,780
end okay so in TCP you might have sack

01:15:46,740 --> 01:15:50,730
blocks cumulative ACK and then sack

01:15:48,780 --> 01:15:53,880
blocks after that in quick

01:15:50,730 --> 01:15:56,250
it's the largest acknowledged that's

01:15:53,880 --> 01:15:57,720
what's sent in the ACK now the other

01:15:56,250 --> 01:16:00,480
things are also sent and we look at that

01:15:57,720 --> 01:16:02,430
act delay if some of you were at the TCP

01:16:00,480 --> 01:16:03,660
Analytics talk session this morning you

01:16:02,430 --> 01:16:05,520
might have heard this thing about you

01:16:03,660 --> 01:16:08,760
know we don't move the RTD carries in a

01:16:05,520 --> 01:16:10,680
delayed acts that the the amount of time

01:16:08,760 --> 01:16:13,620
that this is the receiver was sitting on

01:16:10,680 --> 01:16:15,560
an AK or not right the radar delays are

01:16:13,620 --> 01:16:18,750
captured as part of the round-trip time

01:16:15,560 --> 01:16:21,510
sadly in TCP but here the receiver

01:16:18,750 --> 01:16:23,430
explicitly encodes the ad delay meaning

01:16:21,510 --> 01:16:25,350
how long did it sit on an ACK before

01:16:23,430 --> 01:16:28,260
sent on a packet before sending the ACK

01:16:25,350 --> 01:16:29,790
back so if I receive a packet and I'm

01:16:28,260 --> 01:16:30,810
waiting to send an act because I'm going

01:16:29,790 --> 01:16:33,270
to delay Mike knowledge moon for a

01:16:30,810 --> 01:16:34,950
little while then when I send the act

01:16:33,270 --> 01:16:37,410
back I'm going to encode that time

01:16:34,950 --> 01:16:40,020
inside the ACK and ship it back so that

01:16:37,410 --> 01:16:43,470
the sender has a better estimate of

01:16:40,020 --> 01:16:48,750
of time and can get rid of the receivers

01:16:43,470 --> 01:16:50,790
actally it has in a crane account and

01:16:48,750 --> 01:16:54,330
this is these are the ranges that are

01:16:50,790 --> 01:16:55,800
appearing does the does the the

01:16:54,330 --> 01:16:57,930
first-act range which is basically

01:16:55,800 --> 01:16:59,370
contiguous from the largest act we look

01:16:57,930 --> 01:17:00,000
at an example and we'll talk about this

01:16:59,370 --> 01:17:02,220
in a moment

01:17:00,000 --> 01:17:04,050
so the AK and then the subsequent act

01:17:02,220 --> 01:17:06,360
ranges ECM counts I'm not even going to

01:17:04,050 --> 01:17:07,740
go into so let's look at an example okay

01:17:06,360 --> 01:17:12,180
that's probably best done with an

01:17:07,740 --> 01:17:13,860
example here and this is one example so

01:17:12,180 --> 01:17:16,860
let's say that the packets received are

01:17:13,860 --> 01:17:19,110
1 through 125 okay

01:17:16,860 --> 01:17:20,520
the time let's say that the time since

01:17:19,110 --> 01:17:22,410
the largest received at the receiver is

01:17:20,520 --> 01:17:24,030
25 milliseconds when the receiver

01:17:22,410 --> 01:17:25,500
generates an acknowledgment this is

01:17:24,030 --> 01:17:28,440
represented in a particular way

01:17:25,500 --> 01:17:31,290
it's a shifted value to allow for a

01:17:28,440 --> 01:17:33,420
larger range of values and the shift is

01:17:31,290 --> 01:17:34,860
negotiated but it's defaulted 3 this was

01:17:33,420 --> 01:17:37,680
very much like your window scaling

01:17:34,860 --> 01:17:41,370
basically right so the value that's

01:17:37,680 --> 01:17:44,720
encoded in in the ACK is in microseconds

01:17:41,370 --> 01:17:47,610
and in this case it would be 3 1 to 5

01:17:44,720 --> 01:17:50,340
because it's 25 milliseconds shifted by

01:17:47,610 --> 01:17:53,940
3 the receiver will encode 3 1 to 5

01:17:50,340 --> 01:17:55,950
microseconds inside the ACK and the and

01:17:53,940 --> 01:18:01,850
that's what's going to be sent does it

01:17:55,950 --> 01:18:01,850
make sense yes No

01:18:02,720 --> 01:18:07,590
the receivers okay I'll go over this

01:18:04,890 --> 01:18:09,450
again I'll keep going over this until it

01:18:07,590 --> 01:18:11,610
makes it the point is that the receiver

01:18:09,450 --> 01:18:13,170
is waiting for 25 milliseconds before it

01:18:11,610 --> 01:18:14,940
sends an acknowledgment and it encodes

01:18:13,170 --> 01:18:16,260
it in a particular way you don't need to

01:18:14,940 --> 01:18:17,610
know what the encoding is because you're

01:18:16,260 --> 01:18:20,400
not going to write that encoder tomorrow

01:18:17,610 --> 01:18:26,610
it's fine all you need to know is that 3

01:18:20,400 --> 01:18:28,620
1 2 5 is 25 milliseconds what shake is

01:18:26,610 --> 01:18:30,810
sending what we go sending the act the

01:18:28,620 --> 01:18:32,760
same as a TCP it's a delayed act I'm

01:18:30,810 --> 01:18:35,550
there's a delay timer you can piggyback

01:18:32,760 --> 01:18:38,240
it with data that's coming out or a

01:18:35,550 --> 01:18:44,030
second packet that's received so there's

01:18:38,240 --> 01:18:44,030
4 TCP when we receive like 2 segments we

01:18:47,660 --> 01:18:52,320
so it is it is right now recommended

01:18:50,610 --> 01:18:53,530
that I can actually remember the

01:18:52,320 --> 01:18:55,540
language in the draft is

01:18:53,530 --> 01:19:01,510
but that is one area where we have

01:18:55,540 --> 01:19:05,410
flexibility we you can have you can wait

01:19:01,510 --> 01:19:06,670
for larger number of packets to be to be

01:19:05,410 --> 01:19:08,500
received before sending an

01:19:06,670 --> 01:19:11,800
acknowledgement and there's actually a

01:19:08,500 --> 01:19:14,320
draft that that some of us are going to

01:19:11,800 --> 01:19:16,210
write together about that but at the

01:19:14,320 --> 01:19:18,880
moment because it's simply behaving like

01:19:16,210 --> 01:19:28,840
PCB the current current answer is to

01:19:18,880 --> 01:19:30,580
again but that's negotiable those are

01:19:28,840 --> 01:19:31,990
generally yes so the behavior right now

01:19:30,580 --> 01:19:34,000
is gonna be generally those triggers

01:19:31,990 --> 01:19:36,010
will be roughly the same as TCP but

01:19:34,000 --> 01:19:43,300
there's possibility to extend it to two

01:19:36,010 --> 01:19:48,750
non tcp like behaviors but if if mostly

01:19:43,300 --> 01:19:52,270
models the tcp state machine the highest

01:19:48,750 --> 01:19:55,210
I mean because that TCP assumes that you

01:19:52,270 --> 01:19:56,890
are cleaning up like contiguous blocks

01:19:55,210 --> 01:20:02,230
yes means you could leave holes behind

01:19:56,890 --> 01:20:03,550
yes you can that's an excellent question

01:20:02,230 --> 01:20:05,500
do you mind holding on to that person

01:20:03,550 --> 01:20:11,230
asking me again in a bit because I do

01:20:05,500 --> 01:20:12,760
want to answer that question so that the

01:20:11,230 --> 01:20:14,080
time since largest received is not the

01:20:12,760 --> 01:20:15,880
most important thing if you didn't get

01:20:14,080 --> 01:20:18,550
it it's fine we can move on the other

01:20:15,880 --> 01:20:20,650
stuff is independent the act fields are

01:20:18,550 --> 01:20:22,450
basically largest received so far in

01:20:20,650 --> 01:20:25,420
this case it's 125 because we receive

01:20:22,450 --> 01:20:28,930
everything from 1 to 125 so far so the

01:20:25,420 --> 01:20:32,020
first a Kremes is the largest AG does

01:20:28,930 --> 01:20:36,100
125 and then how many packets below it

01:20:32,020 --> 01:20:38,800
contiguously are acknowledged and in

01:20:36,100 --> 01:20:40,150
this case that's 124 because 1 through

01:20:38,800 --> 01:20:42,340
120 has been received so I'm gonna say

01:20:40,150 --> 01:20:46,780
largest Act there's 125 and then I'm

01:20:42,340 --> 01:20:49,540
also acting 124 packets below it that's

01:20:46,780 --> 01:20:52,150
what that says the ACK range count of 0

01:20:49,540 --> 01:20:55,930
means there are no discontiguous blocks

01:20:52,150 --> 01:20:57,790
below that that's what that says or at

01:20:55,930 --> 01:21:01,120
least I'm not reporting anything else

01:20:57,790 --> 01:21:02,050
below that that's what that says so this

01:21:01,120 --> 01:21:05,980
is what that looks like

01:21:02,050 --> 01:21:09,180
the acronym looks like this yeah now to

01:21:05,980 --> 01:21:09,180
this let's add a little too

01:21:12,880 --> 01:21:19,430
yes excellent point

01:21:16,880 --> 01:21:23,110
he says your accident packets but the

01:21:19,430 --> 01:21:26,770
stream data is in offsets and stream IDs

01:21:23,110 --> 01:21:32,240
what the bleep can I say that on camera

01:21:26,770 --> 01:21:34,160
it's not CBS right what the yeah

01:21:32,240 --> 01:21:38,180
you're exactly right and it'll get to

01:21:34,160 --> 01:21:40,610
that in a second that's actually all the

01:21:38,180 --> 01:21:43,400
features right but in a second so let's

01:21:40,610 --> 01:21:43,850
let's do it little twist here a little

01:21:43,400 --> 01:21:46,790
twist

01:21:43,850 --> 01:21:49,490
now we receive one thirty why because

01:21:46,790 --> 01:21:52,670
the internet sucks and drops packets and

01:21:49,490 --> 01:21:55,010
so we have 130 and now things change a

01:21:52,670 --> 01:21:57,290
little bit now the largest received is

01:21:55,010 --> 01:21:58,780
130 its bumped up to 130 because yes

01:21:57,290 --> 01:22:01,790
that's in fact the largest we've seen

01:21:58,780 --> 01:22:03,740
the first stack range how many packets

01:22:01,790 --> 01:22:07,580
contiguously below 130 are you reporting

01:22:03,740 --> 01:22:09,200
as acknowledged none right because 129

01:22:07,580 --> 01:22:11,740
is not acknowledged immediately the

01:22:09,200 --> 01:22:15,770
first-act range becomes of size zero

01:22:11,740 --> 01:22:18,290
okay and now I'm reporting a gap I'm

01:22:15,770 --> 01:22:20,540
reporting a gap from 126 to 129 I'm

01:22:18,290 --> 01:22:24,980
saying there's a gap that goes from 129

01:22:20,540 --> 01:22:27,680
down to 126 and then I'm acknowledging

01:22:24,980 --> 01:22:30,140
everything below that 125 to 1 again I'm

01:22:27,680 --> 01:22:31,730
acknowledging ok so the way these are

01:22:30,140 --> 01:22:33,560
encoded and again you don't need to

01:22:31,730 --> 01:22:40,580
understand this you can think about this

01:22:33,560 --> 01:22:43,280
later is this gap is simply an encoded

01:22:40,580 --> 01:22:46,070
as 1.9 minus 126 which is 3 and the ACK

01:22:43,280 --> 01:22:51,050
range is again 125 minus 1 which is 124

01:22:46,070 --> 01:22:53,120
ok that's what the same coding works so

01:22:51,050 --> 01:22:57,620
that's what that looks like the ACK film

01:22:53,120 --> 01:23:03,470
for that final twist promise this is the

01:22:57,620 --> 01:23:05,180
final twist let's add 129 to this ok so

01:23:03,470 --> 01:23:07,940
now we receive one print and why again

01:23:05,180 --> 01:23:10,100
because the internet sucks and now the

01:23:07,940 --> 01:23:11,750
largest packet received is still 130 but

01:23:10,100 --> 01:23:13,700
the first-act range has grown by 1

01:23:11,750 --> 01:23:16,970
because now I'm acknowledging one packet

01:23:13,700 --> 01:23:18,800
contiguously below 1 to 130 so again

01:23:16,970 --> 01:23:20,300
notice that the goal is that in a common

01:23:18,800 --> 01:23:21,110
case you're going to see packets in

01:23:20,300 --> 01:23:23,180
order

01:23:21,110 --> 01:23:26,360
that means you'll have the largest tag

01:23:23,180 --> 01:23:28,970
and the first-act range as basically

01:23:26,360 --> 01:23:30,620
conveying all your information but in

01:23:28,970 --> 01:23:32,480
this case again your gap has reduced in

01:23:30,620 --> 01:23:34,790
size and the arc range is reduced but

01:23:32,480 --> 01:23:37,100
this is I hope this is clear more or

01:23:34,790 --> 01:23:39,440
less and if it's not it's okay you can

01:23:37,100 --> 01:23:42,050
catch up with this you don't have to

01:23:39,440 --> 01:23:43,640
understand the details here now so

01:23:42,050 --> 01:23:48,740
that's what that looks like that I claim

01:23:43,640 --> 01:23:50,840
is what that looks like so this is

01:23:48,740 --> 01:23:55,130
absolutely the last example I promise

01:23:50,840 --> 01:23:59,480
the last twist let's say packet 56 was

01:23:55,130 --> 01:24:01,190
dropped right this is packet 56 right

01:23:59,480 --> 01:24:02,870
let's say this packet that is being sent

01:24:01,190 --> 01:24:04,940
right here see the how do I know this is

01:24:02,870 --> 01:24:08,090
packet 56 because this pn packet number

01:24:04,940 --> 01:24:10,040
here says 56 and let's say this packet

01:24:08,090 --> 01:24:11,450
that carries that stream frame that

01:24:10,040 --> 01:24:13,850
stream frame and that AK frame is

01:24:11,450 --> 01:24:16,100
actually dropped by the network okay and

01:24:13,850 --> 01:24:18,020
eventually because quic is reliable

01:24:16,100 --> 01:24:22,900
quick has lost detection machinery it

01:24:18,020 --> 01:24:26,720
detects this packet as lost right and

01:24:22,900 --> 01:24:29,510
let's also assume that stream eight was

01:24:26,720 --> 01:24:31,850
reset remember stream eight that's the

01:24:29,510 --> 01:24:33,200
middle stream frame there when I say

01:24:31,850 --> 01:24:35,060
reset this is something that an

01:24:33,200 --> 01:24:36,380
application can do in quick an

01:24:35,060 --> 01:24:39,410
application we can say I don't carry a

01:24:36,380 --> 01:24:41,210
care about the stream anymore let's not

01:24:39,410 --> 01:24:42,620
send it on the stream anymore cancel the

01:24:41,210 --> 01:24:44,300
stream I'm done with the stream

01:24:42,620 --> 01:24:45,560
okay the my stream is just some

01:24:44,300 --> 01:24:46,670
abstraction within a connection that

01:24:45,560 --> 01:24:51,050
doesn't mean the connection is closed

01:24:46,670 --> 01:24:52,790
the stream is closed okay so at this

01:24:51,050 --> 01:24:55,670
point quick detects after all of this

01:24:52,790 --> 01:24:57,800
has happened quick detects packet 56 is

01:24:55,670 --> 01:25:03,080
lost and let's say that the last packet

01:24:57,800 --> 01:25:04,540
that I had sent was back at 74 what

01:25:03,080 --> 01:25:07,370
should happen next

01:25:04,540 --> 01:25:11,810
quick needs to retransmit data that was

01:25:07,370 --> 01:25:15,410
in in 56 right so this is packet 56 this

01:25:11,810 --> 01:25:16,520
needs to be retransmitted so first

01:25:15,410 --> 01:25:19,240
question what should the what will the

01:25:16,520 --> 01:25:19,240
packet number be

01:25:21,040 --> 01:25:26,860
56 seems obvious how many people say 56

01:25:24,910 --> 01:25:28,990
oh come on

01:25:26,860 --> 01:25:37,960
raise your hands you want how many

01:25:28,990 --> 01:25:39,760
people say is 75 it's 75 it's not 56

01:25:37,960 --> 01:25:43,930
because I'm actually not retransmitting

01:25:39,760 --> 01:25:47,320
56 I don't care to retransmit 56 one

01:25:43,930 --> 01:25:49,650
more second what should I eat transmit

01:25:47,320 --> 01:25:55,240
in here what frames should I send again

01:25:49,650 --> 01:26:01,240
should I send stream ID 5 yes why not

01:25:55,240 --> 01:26:03,130
somebody said no what would the offside

01:26:01,240 --> 01:26:05,770
be different that packet was lost those

01:26:03,130 --> 01:26:13,900
offsets were dropped those bytes were

01:26:05,770 --> 01:26:20,500
dropped this offset is only within the

01:26:13,900 --> 01:26:23,410
stream so stream ID 5 is still in that

01:26:20,500 --> 01:26:26,350
that piece of data that would have been

01:26:23,410 --> 01:26:28,810
delivered in 395 did not receive did not

01:26:26,350 --> 01:26:31,420
reach the receiver so we need to

01:26:28,810 --> 01:26:33,730
retransmit those bytes the offset within

01:26:31,420 --> 01:26:36,150
the stream remains the same because

01:26:33,730 --> 01:26:39,030
that's delivery order within the stream

01:26:36,150 --> 01:26:46,150
that hasn't changed

01:26:39,030 --> 01:26:46,600
what about stream ID 8 we just huh it's

01:26:46,150 --> 01:26:49,870
closed

01:26:46,600 --> 01:26:52,830
do we need to retransmit that why

01:26:49,870 --> 01:26:52,830
somebody says yes

01:26:57,920 --> 01:27:04,500
yeah why would he need it you're right

01:27:01,680 --> 01:27:06,740
he says that at the time that packet 56

01:27:04,500 --> 01:27:09,600
was constructed stream eight was alive

01:27:06,740 --> 01:27:11,310
but we no longer need to deliver to the

01:27:09,600 --> 01:27:14,130
receiver because the receiver has also

01:27:11,310 --> 01:27:15,750
closed the stream it's gone the stream

01:27:14,130 --> 01:27:17,460
has been reset the receiver does not

01:27:15,750 --> 01:27:21,390
care about receiving data on a reset

01:27:17,460 --> 01:27:22,740
stream that's the that's a semantics I

01:27:21,390 --> 01:27:23,970
mean that's a quick semantics and that's

01:27:22,740 --> 01:27:25,680
something you didn't you but that's what

01:27:23,970 --> 01:27:27,090
I want to point out here the separation

01:27:25,680 --> 01:27:33,980
between streams and connection is very

01:27:27,090 --> 01:27:33,980
very strong and quick yes question

01:27:34,460 --> 01:27:39,900
trying to be more disciplined so but

01:27:37,950 --> 01:27:41,820
that implies that the other side is

01:27:39,900 --> 01:27:44,430
effectively left dangling right there is

01:27:41,820 --> 01:27:46,200
no the receiver is now going to do a

01:27:44,430 --> 01:27:47,910
timeout disconnect because that

01:27:46,200 --> 01:27:50,700
particular stream has no signal that

01:27:47,910 --> 01:27:51,810
said go cancel yourself that is that is

01:27:50,700 --> 01:27:54,330
the current signal and that's called a

01:27:51,810 --> 01:27:56,370
reset stream control signal but that's

01:27:54,330 --> 01:27:59,940
going to be in a frame that might have

01:27:56,370 --> 01:28:01,740
been in 74 that could be any guess that

01:27:59,940 --> 01:28:03,630
might have been in 74 exactly and if

01:28:01,740 --> 01:28:07,850
that's dropped that is retransmitted as

01:28:03,630 --> 01:28:09,720
well oh also the cancel is actually yes

01:28:07,850 --> 01:28:12,360
exactly yes

01:28:09,720 --> 01:28:14,640
so the reset of a stream means don't

01:28:12,360 --> 01:28:17,070
care about the stream anymore fin of a

01:28:14,640 --> 01:28:19,650
stream very much like TCP reset in TCP

01:28:17,070 --> 01:28:21,030
fin means yes I'm still going to send

01:28:19,650 --> 01:28:22,230
you data even though I've sent to your

01:28:21,030 --> 01:28:27,390
fin because they all need to get

01:28:22,230 --> 01:28:29,040
delivered in order so in this case we

01:28:27,390 --> 01:28:30,840
don't care about these oh I should have

01:28:29,040 --> 01:28:32,790
asked you this question should the ACK

01:28:30,840 --> 01:28:40,680
frame be read I'll ask you forget you

01:28:32,790 --> 01:28:42,090
saw that right answer thank you for

01:28:40,680 --> 01:28:42,570
playing along you get points for playing

01:28:42,090 --> 01:28:46,460
along

01:28:42,570 --> 01:28:46,460
should the ACK frame be retransmitted

01:28:47,870 --> 01:28:52,760
see now I'm going to hold you to it

01:28:50,340 --> 01:28:52,760
why

01:28:55,739 --> 01:29:00,179
he said yes and then when I pinned him

01:28:58,140 --> 01:29:02,880
down he said no father I called because

01:29:00,179 --> 01:29:04,170
you're not on the mic at the time so the

01:29:02,880 --> 01:29:05,600
accident need to be retransmitted

01:29:04,170 --> 01:29:07,380
because it's carrying state information

01:29:05,600 --> 01:29:09,420
acknowledgments in quick very much like

01:29:07,380 --> 01:29:11,640
in TCP are cumulative in the sense that

01:29:09,420 --> 01:29:12,630
a later acknowledgement carries the

01:29:11,640 --> 01:29:15,179
information of a previous

01:29:12,630 --> 01:29:16,500
acknowledgement all right so we don't

01:29:15,179 --> 01:29:18,060
need to send that we could send a new

01:29:16,500 --> 01:29:19,679
acknowledgement we could in place of

01:29:18,060 --> 01:29:22,170
these two things we could send other

01:29:19,679 --> 01:29:23,670
stuff we can send new stream data we can

01:29:22,170 --> 01:29:27,270
send other control messages we can send

01:29:23,670 --> 01:29:29,010
whatever we want but it does not have to

01:29:27,270 --> 01:29:30,270
send these two bits of information and

01:29:29,010 --> 01:29:34,250
it won't send these two bits of

01:29:30,270 --> 01:29:34,250
information yes question

01:29:46,170 --> 01:29:50,020
so the question is does the quick

01:29:48,550 --> 01:29:52,179
library maintain information about

01:29:50,020 --> 01:29:54,369
packet sizes offsets and various things

01:29:52,179 --> 01:29:56,290
packetization information basically so

01:29:54,369 --> 01:29:57,699
that when an acknowledgement comes it

01:29:56,290 --> 01:29:59,679
does the right thing above pulling

01:29:57,699 --> 01:30:01,900
information from the right streams and

01:29:59,679 --> 01:30:03,909
so on if it doesn't come then marks

01:30:01,900 --> 01:30:05,800
those as lost yes in both cases it does

01:30:03,909 --> 01:30:08,050
it has to maintain all of that

01:30:05,800 --> 01:30:09,699
information and when a packet is

01:30:08,050 --> 01:30:11,230
acknowledged it goes up and tells the

01:30:09,699 --> 01:30:14,139
stream hey this data has been delivered

01:30:11,230 --> 01:30:18,040
and if a packet is lost it says I lost

01:30:14,139 --> 01:30:22,389
the stream data and I can retransmit if

01:30:18,040 --> 01:30:33,610
you would like so yes you fetch data

01:30:22,389 --> 01:30:35,349
from the application again yeah so the

01:30:33,610 --> 01:30:37,210
question is can you we remove stuff we

01:30:35,349 --> 01:30:39,360
don't want to send in the packet but can

01:30:37,210 --> 01:30:41,889
we add new stuff the short answer is yes

01:30:39,360 --> 01:30:44,230
that's sort of the whole point packets

01:30:41,889 --> 01:30:46,630
are basically containers in quick

01:30:44,230 --> 01:30:48,280
packets of simply containers they carry

01:30:46,630 --> 01:30:50,139
a packet number that is monotonically

01:30:48,280 --> 01:30:52,840
increasing no matter what you put in

01:30:50,139 --> 01:30:55,239
them the packet number is used for

01:30:52,840 --> 01:30:56,679
sending and it maintains only thing

01:30:55,239 --> 01:30:58,210
packet number encodes transmission

01:30:56,679 --> 01:31:00,639
orders so an earlier question was about

01:30:58,210 --> 01:31:02,080
oh this has this this packet numbers in

01:31:00,639 --> 01:31:03,880
this and there's three my reason offices

01:31:02,080 --> 01:31:07,780
in that the acknowledgments are for the

01:31:03,880 --> 01:31:10,389
containers technologyand say I have

01:31:07,780 --> 01:31:12,190
received this packet what's in the

01:31:10,389 --> 01:31:14,710
packet well you ought to know you are

01:31:12,190 --> 01:31:15,699
the one who sent me the packet that's

01:31:14,710 --> 01:31:17,710
basically what it means

01:31:15,699 --> 01:31:19,480
so I maintain state about what I'm

01:31:17,710 --> 01:31:21,190
putting inside a packet I give it a

01:31:19,480 --> 01:31:22,900
packet number I ship it an

01:31:21,190 --> 01:31:25,679
acknowledgement is received it says I've

01:31:22,900 --> 01:31:28,210
received this packet that's enough and

01:31:25,679 --> 01:31:30,159
if I lose the bag if the packet is

01:31:28,210 --> 01:31:31,989
treated as lost again I know what was in

01:31:30,159 --> 01:31:33,610
the packet so I can decide what to

01:31:31,989 --> 01:31:35,219
retransmit what not to retransmit

01:31:33,610 --> 01:31:37,659
and so on at the time of retransmission

01:31:35,219 --> 01:31:41,020
the value of separating these two things

01:31:37,659 --> 01:31:45,099
again is that lost detection is separate

01:31:41,020 --> 01:31:47,710
from loss recovery I can detect a loss

01:31:45,099 --> 01:31:49,389
and I can in fact choose not to

01:31:47,710 --> 01:31:53,230
retransmit any of the things that were

01:31:49,389 --> 01:31:54,880
in that packet that's perfectly fine in

01:31:53,230 --> 01:31:55,730
the example I just showed you if stream

01:31:54,880 --> 01:31:59,000
5 had

01:31:55,730 --> 01:32:01,520
also been cancelled when I did it the

01:31:59,000 --> 01:32:04,880
loss of packet 56 I do not have to send

01:32:01,520 --> 01:32:06,590
a packet 74 or 75 because there's

01:32:04,880 --> 01:32:09,650
nothing in that packet that I need to

01:32:06,590 --> 01:32:12,530
retransmit anymore so loss detection is

01:32:09,650 --> 01:32:15,739
separate from actually retransmitting

01:32:12,530 --> 01:32:19,370
the bits that were lost okay so that's

01:32:15,739 --> 01:32:23,720
hugely useful also because your your

01:32:19,370 --> 01:32:28,550
stream offsets indicate what basically

01:32:23,720 --> 01:32:29,690
so the the the the key distinction here

01:32:28,550 --> 01:32:31,760
is packet numbers are used for

01:32:29,690 --> 01:32:35,210
transmission order stream IDs and

01:32:31,760 --> 01:32:37,580
offsets are used for delivery order okay

01:32:35,210 --> 01:32:39,140
so this is the separation that we are

01:32:37,580 --> 01:32:40,370
able to achieve when TCP doesn't have

01:32:39,140 --> 01:32:44,420
this separation but we are able to

01:32:40,370 --> 01:32:46,989
achieve and quick so packets end up

01:32:44,420 --> 01:32:46,989
being containers

01:32:55,889 --> 01:33:03,730
yep yes so the question is it's not like

01:33:01,059 --> 01:33:05,320
UDP but the question is is this is this

01:33:03,730 --> 01:33:07,420
like where you can where you can drop

01:33:05,320 --> 01:33:08,889
certain frames for videos encoding video

01:33:07,420 --> 01:33:10,329
streaming for example you can say I

01:33:08,889 --> 01:33:11,679
don't care about these streams anymore

01:33:10,329 --> 01:33:13,090
that's exactly what it is and that's

01:33:11,679 --> 01:33:22,719
actually work on trying to make this

01:33:13,090 --> 01:33:31,719
work for video yes can you allow loss in

01:33:22,719 --> 01:33:33,429
a certain stream within a stream at the

01:33:31,719 --> 01:33:36,400
moment that abstraction is not available

01:33:33,429 --> 01:33:40,510
in quick so the way you would if you

01:33:36,400 --> 01:33:42,760
wanted to if you wanted to in depending

01:33:40,510 --> 01:33:45,099
on the impeller it would depend so in

01:33:42,760 --> 01:33:46,659
short no not at the moment but that's an

01:33:45,099 --> 01:33:48,849
extension that people are talking about

01:33:46,659 --> 01:33:50,469
have been talking about and the working

01:33:48,849 --> 01:33:53,050
group has been trying to keep it tight

01:33:50,469 --> 01:33:55,750
to do not expand scope to increase

01:33:53,050 --> 01:33:58,349
include everything but that's coming

01:33:55,750 --> 01:33:58,349
very very soon

01:34:02,889 --> 01:34:06,260
if there are lot of gaps yes it'll get

01:34:05,570 --> 01:34:13,219
bigger and bigger

01:34:06,260 --> 01:34:15,019
much like sack ranges so yes that is so

01:34:13,219 --> 01:34:16,909
so somebody else has asked this question

01:34:15,019 --> 01:34:18,860
I'll answer it now about when do you

01:34:16,909 --> 01:34:20,389
stop reporting something because in this

01:34:18,860 --> 01:34:22,939
world you're never going to fill a gap

01:34:20,389 --> 01:34:24,769
right so at some point you decide to

01:34:22,939 --> 01:34:26,599
stop reporting and that is actually left

01:34:24,769 --> 01:34:27,860
to the implementation to some extent so

01:34:26,599 --> 01:34:28,969
we've left it to the implementation in

01:34:27,860 --> 01:34:30,789
the spec but there are some

01:34:28,969 --> 01:34:32,900
recommendations about what's a good time

01:34:30,789 --> 01:34:35,900
specifically because every quick packet

01:34:32,900 --> 01:34:38,570
carries a packet number funnily acts get

01:34:35,900 --> 01:34:40,389
acknowledged remember that acts are

01:34:38,570 --> 01:34:45,919
frames that are carried in packets and

01:34:40,389 --> 01:34:47,869
those packets also get acknowledged and

01:34:45,919 --> 01:34:49,369
let you think about that cause it can

01:34:47,869 --> 01:34:52,340
lead to an infinite loop it can lead to

01:34:49,369 --> 01:34:54,019
ping-pong but there are safeguards in

01:34:52,340 --> 01:34:56,749
place to not let that happen but what it

01:34:54,019 --> 01:34:59,539
means is that I can know when a peer has

01:34:56,749 --> 01:35:01,699
seen my acknowledgement so when I know

01:34:59,539 --> 01:35:05,840
that that guy has seen this information

01:35:01,699 --> 01:35:07,340
I can stop reporting it so I can I only

01:35:05,840 --> 01:35:09,320
need to report as long as I know that

01:35:07,340 --> 01:35:10,789
the other hand has not seen this

01:35:09,320 --> 01:35:12,229
information as long as the Pierre has

01:35:10,789 --> 01:35:14,570
seen this information meaning that I

01:35:12,229 --> 01:35:17,599
receive an ACK for the packet that

01:35:14,570 --> 01:35:19,519
carried my ACK frame I can retire so to

01:35:17,599 --> 01:35:22,719
speak that ACK information I do not have

01:35:19,519 --> 01:35:25,969
to report that again so that's again a

01:35:22,719 --> 01:35:27,650
trick that you can use or you would also

01:35:25,969 --> 01:35:29,030
use some sort of a timing thing you

01:35:27,650 --> 01:35:30,229
report this for one or two round-trip

01:35:29,030 --> 01:35:32,769
times and then after that you don't

01:35:30,229 --> 01:35:32,769
report it anymore

01:35:33,169 --> 01:35:36,079
another huge value is that

01:35:34,820 --> 01:35:37,699
retransmissions are not automatically

01:35:36,079 --> 01:35:39,590
high priority basically stream

01:35:37,699 --> 01:35:41,179
priorities allow you to determine

01:35:39,590 --> 01:35:44,419
whether you want to send retransmission

01:35:41,179 --> 01:35:52,280
now or not so quick separates what is

01:35:44,419 --> 01:35:54,409
sent from when it is sent I am basically

01:35:52,280 --> 01:35:55,760
out of time at this point is 232 and I

01:35:54,409 --> 01:35:58,039
don't want to run into your break into

01:35:55,760 --> 01:36:01,909
the next session but I will show you one

01:35:58,039 --> 01:36:07,039
very quick thing and then hawk one very

01:36:01,909 --> 01:36:10,340
quick thing so here's a I will show you

01:36:07,039 --> 01:36:12,439
a quick server I'm running a quick

01:36:10,340 --> 01:36:15,490
server here and I'm running a UDP

01:36:12,439 --> 01:36:19,260
forwarder that basically will introduce

01:36:15,490 --> 01:36:23,380
a drop at some point in the connection

01:36:19,260 --> 01:36:24,940
and it introduces loss and delay and

01:36:23,380 --> 01:36:27,460
things like that's a simulator which

01:36:24,940 --> 01:36:29,110
also will forward packets along this is

01:36:27,460 --> 01:36:36,880
all available in the quickly repository

01:36:29,110 --> 01:36:38,490
by the way and no why would you do that

01:36:36,880 --> 01:36:46,000
maybe I'm running it somewhere else

01:36:38,490 --> 01:36:48,070
apologies it's fine and here's the

01:36:46,000 --> 01:36:50,310
client and the client basically talked

01:36:48,070 --> 01:36:54,940
and sent a bunch of stuff and now I have

01:36:50,310 --> 01:36:56,580
traces and this is what this is what I

01:36:54,940 --> 01:37:00,220
was

01:36:56,580 --> 01:37:03,460
it's a JSON stuff that spit out of the

01:37:00,220 --> 01:37:05,110
server as the connection proceeds and I

01:37:03,460 --> 01:37:07,150
have a converter that basically wraps

01:37:05,110 --> 01:37:15,940
this to things and then converted into a

01:37:07,150 --> 01:37:17,560
protobuf and and I can plot it and there

01:37:15,940 --> 01:37:18,820
you go there's a nice little packet

01:37:17,560 --> 01:37:22,120
raised if you're not familiar the packet

01:37:18,820 --> 01:37:24,040
race it's time on the x-axis and packets

01:37:22,120 --> 01:37:27,100
data on the y-axis and what you've seen

01:37:24,040 --> 01:37:29,350
here is in blue is packets sent and the

01:37:27,100 --> 01:37:31,330
Green is acknowledgments received for

01:37:29,350 --> 01:37:33,790
those packets and you can see that every

01:37:31,330 --> 01:37:35,560
packet there's basically various things

01:37:33,790 --> 01:37:37,450
including the frame list and the

01:37:35,560 --> 01:37:39,820
frameless in this case has stream ID 0

01:37:37,450 --> 01:37:42,340
and you can see it has certain offsets

01:37:39,820 --> 01:37:45,220
in it and the acknowledgments are

01:37:42,340 --> 01:37:47,650
basically four packets and along with

01:37:45,220 --> 01:37:49,600
the acknowledgments I can also show

01:37:47,650 --> 01:37:51,400
various transport State because the

01:37:49,600 --> 01:37:54,460
server as it receives an acknowledgement

01:37:51,400 --> 01:37:56,830
is logging this stuff as well in the

01:37:54,460 --> 01:38:00,400
JSON I just want to show you one quick

01:37:56,830 --> 01:38:04,540
thing which is here okay so the Reds

01:38:00,400 --> 01:38:06,400
here are packets are lost okay so this

01:38:04,540 --> 01:38:08,560
says lost packet nine which means a

01:38:06,400 --> 01:38:12,610
server said at this moment in time I'm

01:38:08,560 --> 01:38:14,590
logging packet nine as lost okay but

01:38:12,610 --> 01:38:18,250
let's go back and see what was in packet

01:38:14,590 --> 01:38:22,840
nine packet nine carried the stream zero

01:38:18,250 --> 01:38:25,600
data offset thirty seven one three yes

01:38:22,840 --> 01:38:27,340
and that was dropped in the network and

01:38:25,600 --> 01:38:29,260
of course we're going to retransmit that

01:38:27,340 --> 01:38:33,280
but as you can see

01:38:29,260 --> 01:38:36,010
the retransmission happens here where it

01:38:33,280 --> 01:38:37,900
has sent us back at 38 but it carries

01:38:36,010 --> 01:38:41,440
the same stream ID and the same stream

01:38:37,900 --> 01:38:43,690
offsets so if you're used to seeing PCB

01:38:41,440 --> 01:38:46,000
traces this looks slightly weird because

01:38:43,690 --> 01:38:48,010
again as was pointed out earlier gaps

01:38:46,000 --> 01:38:50,079
are not filled retransmissions don't

01:38:48,010 --> 01:38:53,469
show up along the same horizontal line

01:38:50,079 --> 01:38:55,090
they're going to show up later so you so

01:38:53,469 --> 01:38:57,099
you're going to have to reorient

01:38:55,090 --> 01:38:58,630
yourself a little bit to looking at

01:38:57,099 --> 01:39:00,730
these traces because they are different

01:38:58,630 --> 01:39:03,039
but at the same time these traces can be

01:39:00,730 --> 01:39:04,989
substantially more substantially richer

01:39:03,039 --> 01:39:06,250
because we can actually record a lot of

01:39:04,989 --> 01:39:08,920
details about what's going on at the

01:39:06,250 --> 01:39:10,900
server in these traces and with that I

01:39:08,920 --> 01:39:12,969
will end sorry that it's only five

01:39:10,900 --> 01:39:14,530
minutes left for your break but thank

01:39:12,969 --> 01:39:16,079
you for being patient and not sleeping

01:39:14,530 --> 01:39:18,570
through this presentation post-lunch

01:39:16,079 --> 01:39:22,840
thank you again and I'll be around

01:39:18,570 --> 01:39:22,840

YouTube URL: https://www.youtube.com/watch?v=CtsBawwGwns


