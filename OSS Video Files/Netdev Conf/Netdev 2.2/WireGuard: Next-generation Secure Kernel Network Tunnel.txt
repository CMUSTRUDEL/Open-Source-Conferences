Title: WireGuard: Next-generation Secure Kernel Network Tunnel
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: Jason Donenfeld
Friday November 09th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?donenfeld-wireguard-talk
Captions: 
	00:00:02,400 --> 00:00:10,980
No okay so this is on wire guard which

00:00:06,790 --> 00:00:14,160
is a next-generation VPN tunnel

00:00:10,980 --> 00:00:17,220
specifically made for the Linux kernel

00:00:14,160 --> 00:00:21,070
so a bit of background first

00:00:17,220 --> 00:00:23,429
Jason donenfeld the internet knows me by

00:00:21,070 --> 00:00:28,269
the strange handles yes to c4

00:00:23,429 --> 00:00:32,100
I'm mainly from the security world do

00:00:28,269 --> 00:00:36,609
exploitation kernel voles crypto bones

00:00:32,100 --> 00:00:40,960
root kits defensive security offensive

00:00:36,609 --> 00:00:42,489
security I've been into kernel

00:00:40,960 --> 00:00:44,500
development for many years and I wanted

00:00:42,489 --> 00:00:48,429
to make a VPN that avoided a lot of the

00:00:44,500 --> 00:00:51,850
issues that I've seen in the field on

00:00:48,429 --> 00:00:53,530
the job finding VPN deployments and

00:00:51,850 --> 00:00:55,929
these systems that break horribly and I

00:00:53,530 --> 00:01:00,190
wanted to kind of fix the things I've

00:00:55,929 --> 00:01:03,129
seen out there so what does wire guard

00:01:00,190 --> 00:01:09,490
it's a layer 3 secure network tunnel for

00:01:03,129 --> 00:01:12,130
v4 v6 and we'll do a small overview of

00:01:09,490 --> 00:01:13,630
what wire guard is other talks I've

00:01:12,130 --> 00:01:15,759
given have kind of gone into the details

00:01:13,630 --> 00:01:17,369
of the protocol and all these things but

00:01:15,759 --> 00:01:21,369
I kind of want to get into the more

00:01:17,369 --> 00:01:23,079
currently things but one thing is that a

00:01:21,369 --> 00:01:26,530
lot of decisions made in wire guard are

00:01:23,079 --> 00:01:28,600
very opinionated so it's the VPN

00:01:26,530 --> 00:01:31,390
protocol but it's layer 3 only not layer

00:01:28,600 --> 00:01:34,329
2 because I think layer 3 is the right

00:01:31,390 --> 00:01:35,409
way to make your secret tunnels and kind

00:01:34,329 --> 00:01:38,049
of throughout there are a lot of these

00:01:35,409 --> 00:01:41,530
decisions already made to kind of create

00:01:38,049 --> 00:01:46,329
a simpler simpler situation that I think

00:01:41,530 --> 00:01:47,649
leads to better overall security as I

00:01:46,329 --> 00:01:50,680
said it's been designed for the Linux

00:01:47,649 --> 00:01:53,289
kernel but of course they're kind of the

00:01:50,680 --> 00:01:56,320
cross-platform tunt app base user space

00:01:53,289 --> 00:01:59,590
things too for interoperability but it's

00:01:56,320 --> 00:02:04,479
really dedicated for the kernel its

00:01:59,590 --> 00:02:07,689
udp-based so works on the internet it

00:02:04,479 --> 00:02:10,360
uses new crypto but modern crypto but

00:02:07,689 --> 00:02:15,040
it's conservative we're not doing

00:02:10,360 --> 00:02:16,840
anything too funky or controversial

00:02:15,040 --> 00:02:19,630
and the emphasis of the whole project is

00:02:16,840 --> 00:02:22,020
on being really simple and auditable

00:02:19,630 --> 00:02:24,550
trying to keep a small codebase

00:02:22,020 --> 00:02:25,900
understandable concepts the kind of

00:02:24,550 --> 00:02:28,750
thing you can wrap your head around in

00:02:25,900 --> 00:02:30,790
an afternoon instead of you know years

00:02:28,750 --> 00:02:33,580
trying to understand exif RM or IP sac

00:02:30,790 --> 00:02:36,760
or what have you the authentication

00:02:33,580 --> 00:02:39,220
model is similar to ssh is a ton of

00:02:36,760 --> 00:02:41,500
candy keys were two sides share their

00:02:39,220 --> 00:02:43,840
public keys and then they can talk there

00:02:41,500 --> 00:02:47,680
no certificates or x.509 or a s and one

00:02:43,840 --> 00:02:49,930
or anything like that so it's kind of a

00:02:47,680 --> 00:02:52,180
very simplified model and the key

00:02:49,930 --> 00:02:55,000
distribution aspects then are handled by

00:02:52,180 --> 00:02:57,640
the various other adeb and things that

00:02:55,000 --> 00:03:00,580
already do key distribution like SSH

00:02:57,640 --> 00:03:04,300
even or LDAP or you know and anything

00:03:00,580 --> 00:03:06,550
you already have in place the code base

00:03:04,300 --> 00:03:09,100
itself actually grew out of a stealth

00:03:06,550 --> 00:03:13,240
rootkit project I needed a way to

00:03:09,100 --> 00:03:14,620
exfiltrate data in a stealthy way from

00:03:13,240 --> 00:03:16,420
kernel space and it turns out that a lot

00:03:14,620 --> 00:03:18,250
of the things that you need when you're

00:03:16,420 --> 00:03:20,170
trying to be stealthy and trying to

00:03:18,250 --> 00:03:22,959
harden up a rootkit are actually really

00:03:20,170 --> 00:03:28,930
useful defensive measures for a real a

00:03:22,959 --> 00:03:31,150
real piece of infrastructure but wire

00:03:28,930 --> 00:03:33,670
guard is is kind of blasphemous we break

00:03:31,150 --> 00:03:36,970
a lot of the kind of academically

00:03:33,670 --> 00:03:41,020
correct layering assumptions things like

00:03:36,970 --> 00:03:43,209
IPSec with the transformation table user

00:03:41,020 --> 00:03:44,530
space daemon doing the keying and wire

00:03:43,209 --> 00:03:46,420
guard would kind of smush everything

00:03:44,530 --> 00:03:48,220
together or you just have a wire guard

00:03:46,420 --> 00:03:50,350
interface which makes things a lot more

00:03:48,220 --> 00:03:54,190
simple but because we've gotten rid of

00:03:50,350 --> 00:03:57,580
these kind of pristine layering things

00:03:54,190 --> 00:03:59,620
we were forced then to kind of reefs all

00:03:57,580 --> 00:04:01,660
the issues that come up when we break

00:03:59,620 --> 00:04:03,250
the layering but I think for each issue

00:04:01,660 --> 00:04:06,610
that's come up we've solved it in a way

00:04:03,250 --> 00:04:10,570
that makes the the overall result of the

00:04:06,610 --> 00:04:12,700
project a lot cleaner and simpler so we

00:04:10,570 --> 00:04:15,090
start with a struct net device it's kind

00:04:12,700 --> 00:04:17,320
of the the basic building block of this

00:04:15,090 --> 00:04:20,769
as I mentioned it's really easily out of

00:04:17,320 --> 00:04:21,910
editable open the VPN is a hundred

00:04:20,769 --> 00:04:24,400
thousand lines of code

00:04:21,910 --> 00:04:25,690
exif RM is thirteen thousand lines but

00:04:24,400 --> 00:04:28,750
it needs strong Swann for the key

00:04:25,690 --> 00:04:30,460
exchange which is massive soft ether

00:04:28,750 --> 00:04:32,980
is big - and liar guard it's less than

00:04:30,460 --> 00:04:34,780
4,000 lines of code so something you

00:04:32,980 --> 00:04:37,750
could sit down and read the entirety of

00:04:34,780 --> 00:04:42,850
in an afternoon and really understand it

00:04:37,750 --> 00:04:47,790
in depth so in the the solar system of

00:04:42,850 --> 00:04:47,790
VPNs were Pluto all the way out there

00:04:48,640 --> 00:04:54,390
so it works just with a normal network

00:04:51,490 --> 00:04:56,800
interface you I feel like I had

00:04:54,390 --> 00:04:58,840
addresses or routes all the things you

00:04:56,800 --> 00:05:03,100
know about network interface is gonna

00:04:58,840 --> 00:05:04,900
work as you'd expect importantly it

00:05:03,100 --> 00:05:06,670
appears stateless to the administrator

00:05:04,900 --> 00:05:09,430
this is really important concept you add

00:05:06,670 --> 00:05:11,470
an interface you configure the peers

00:05:09,430 --> 00:05:14,080
it's going to talk to and any keys and

00:05:11,470 --> 00:05:15,460
allowed IP is as I'll show and then you

00:05:14,080 --> 00:05:17,710
can just start sending packets it

00:05:15,460 --> 00:05:20,560
doesn't have any concept of connection

00:05:17,710 --> 00:05:24,160
state is it is it connected which peers

00:05:20,560 --> 00:05:25,870
are connected to has a handshake AB it

00:05:24,160 --> 00:05:28,630
doesn't really expose these concepts

00:05:25,870 --> 00:05:30,130
it's just it's configured or it's not

00:05:28,630 --> 00:05:32,850
configured and when it's configured it

00:05:30,130 --> 00:05:32,850
can send packets

00:05:33,300 --> 00:05:38,590
it also has roaming like mosh if you've

00:05:36,100 --> 00:05:43,600
ever used it so you can move between

00:05:38,590 --> 00:05:45,400
IPAs or between Wi-Fi and and 4G or put

00:05:43,600 --> 00:05:47,410
your laptop to sleep and one plays open

00:05:45,400 --> 00:05:49,390
up to another and things can I keep

00:05:47,410 --> 00:05:53,400
working because it's either on or it's

00:05:49,390 --> 00:05:53,400
off it doesn't have a connection state

00:05:53,430 --> 00:05:58,840
and so the the fundamental thing that

00:05:56,320 --> 00:06:00,880
allows us to smush things down to

00:05:58,840 --> 00:06:04,960
interface is what I call cryptokey

00:06:00,880 --> 00:06:06,730
routing which is a dissociation of a

00:06:04,960 --> 00:06:09,670
peer which is identified by its public

00:06:06,730 --> 00:06:12,660
key and a list of IP addresses that that

00:06:09,670 --> 00:06:15,850
peer is allowed to be inside the tunnel

00:06:12,660 --> 00:06:17,770
so the basic system is like this so why

00:06:15,850 --> 00:06:20,470
are guard interface has its private key

00:06:17,770 --> 00:06:23,530
it has a UDP port it listens on and it

00:06:20,470 --> 00:06:26,050
has a list of peers each peer has its

00:06:23,530 --> 00:06:28,120
own public key which is how its

00:06:26,050 --> 00:06:30,820
identified and then it has a list of

00:06:28,120 --> 00:06:32,710
these allowed IPs a list of these IPS

00:06:30,820 --> 00:06:35,560
that it's allowed to be within the

00:06:32,710 --> 00:06:39,040
tunnel and it optionally has an endpoint

00:06:35,560 --> 00:06:42,160
IP in port optional because if you don't

00:06:39,040 --> 00:06:47,650
specify it then it learns it on its own

00:06:42,160 --> 00:06:49,960
roaming just like in mosh so fundamental

00:06:47,650 --> 00:06:53,500
concept here is that public key then has

00:06:49,960 --> 00:06:55,990
a mapping directly to an IP address you

00:06:53,500 --> 00:06:58,690
can't have two peers that share the

00:06:55,990 --> 00:07:02,740
exact same slash 32 for for an allowed

00:06:58,690 --> 00:07:04,510
IP you have so you have this really

00:07:02,740 --> 00:07:08,620
strict mapping between a public key that

00:07:04,510 --> 00:07:10,690
has up here and an IP address so just to

00:07:08,620 --> 00:07:14,560
kind of show you configuration example a

00:07:10,690 --> 00:07:17,950
server has a listening port a private

00:07:14,560 --> 00:07:19,930
key and two peers and this peer is

00:07:17,950 --> 00:07:23,080
allowed to be this slash 32 and this

00:07:19,930 --> 00:07:27,040
slash 24 and this one gets this 32 in

00:07:23,080 --> 00:07:29,020
this 16 then a client would have the

00:07:27,040 --> 00:07:30,670
private his own private key the public

00:07:29,020 --> 00:07:32,620
key here that corresponds to the private

00:07:30,670 --> 00:07:34,720
key of the server and it might give

00:07:32,620 --> 00:07:37,390
everything for a loud IP is which would

00:07:34,720 --> 00:07:39,060
mean I'll let the server tunnel me the

00:07:37,390 --> 00:07:41,830
internet you know if you're trying to

00:07:39,060 --> 00:07:43,600
get your internet through a VPN provider

00:07:41,830 --> 00:07:45,250
for example it could also do something

00:07:43,600 --> 00:07:47,800
more restrictive if it only wants a

00:07:45,250 --> 00:07:53,140
certain subnet from this peers talking

00:07:47,800 --> 00:07:55,630
to so this setup makes system

00:07:53,140 --> 00:07:59,770
administration really simple if it comes

00:07:55,630 --> 00:08:03,130
from WG 0 and it's from yoshis tunnel IP

00:07:59,770 --> 00:08:07,120
of 102 168 517 then it definitely came

00:08:03,130 --> 00:08:10,330
from Yoshi you don't need any other you

00:08:07,120 --> 00:08:12,130
know of IP tables security marks or

00:08:10,330 --> 00:08:14,200
anything like that it's just it's from

00:08:12,130 --> 00:08:16,600
the wire guard interface and it's from

00:08:14,200 --> 00:08:18,190
the IP that you had given to this peer

00:08:16,600 --> 00:08:19,060
then it definitely came to that peer and

00:08:18,190 --> 00:08:22,510
wire guard ensures that

00:08:19,060 --> 00:08:23,740
cryptographically and I mean you could

00:08:22,510 --> 00:08:26,050
already kind of imagine what the IP

00:08:23,740 --> 00:08:30,340
table rules of being in a wire guard

00:08:26,050 --> 00:08:31,660
setup so before we get into the kernel

00:08:30,340 --> 00:08:33,760
things I just want to show a demo of

00:08:31,660 --> 00:08:35,950
what it's like to set it up so you kind

00:08:33,760 --> 00:08:39,360
of see it in action and then we'll start

00:08:35,950 --> 00:08:39,360
getting into implementation details

00:08:45,280 --> 00:08:53,240
okay so we have pure a and pure B and we

00:08:49,340 --> 00:08:55,010
generate a private key we generate a

00:08:53,240 --> 00:08:57,410
private key using WGN key and we just

00:08:55,010 --> 00:09:00,170
write it into this file private and if

00:08:57,410 --> 00:09:03,170
we can't the file we see it's just this

00:09:00,170 --> 00:09:05,270
really short base64 thing we can drive a

00:09:03,170 --> 00:09:07,550
public key from a private key trivially

00:09:05,270 --> 00:09:08,570
just by attending the private into WT

00:09:07,550 --> 00:09:15,470
pub key and then we get the

00:09:08,570 --> 00:09:19,060
corresponding public key okay so we add

00:09:15,470 --> 00:09:21,530
WG 0 interface we give it an IP address

00:09:19,060 --> 00:09:30,020
kind of all the standard things you'd

00:09:21,530 --> 00:09:31,730
expect and then we can say WG set WG 0

00:09:30,020 --> 00:09:35,170
to give it the private key that we just

00:09:31,730 --> 00:09:41,990
generated and then we can set it up and

00:09:35,170 --> 00:09:44,860
we'll do the same on pure B so we make

00:09:41,990 --> 00:09:49,520
an interface we add an IP address for it

00:09:44,860 --> 00:09:50,810
and then we call set W 0 private key we

00:09:49,520 --> 00:09:53,570
get the private key we just created and

00:09:50,810 --> 00:09:58,730
we set it up so now we have this WG 0 on

00:09:53,570 --> 00:10:02,180
each end so if we hit IP address we can

00:09:58,730 --> 00:10:02,630
see we have here our WG 0 that we just

00:10:02,180 --> 00:10:05,270
added

00:10:02,630 --> 00:10:08,570
and there's our Ethernet device with

00:10:05,270 --> 00:10:12,050
this IP kind of external IP address and

00:10:08,570 --> 00:10:14,630
then here's W 0 with our internal IP

00:10:12,050 --> 00:10:16,970
address and so now we'll tell the two

00:10:14,630 --> 00:10:21,410
peers about each other so that they can

00:10:16,970 --> 00:10:23,840
talk so if we hit W G now we see public

00:10:21,410 --> 00:10:26,920
key and a private key and there's a

00:10:23,840 --> 00:10:29,960
listening port and we can now say ok

00:10:26,920 --> 00:10:34,340
puree is going to learn pure B's public

00:10:29,960 --> 00:10:36,200
key and peer B is allowed to be 10002 in

00:10:34,340 --> 00:10:40,340
the tunnel and that's its

00:10:36,200 --> 00:10:44,360
internet-facing endpoint 102 168 1 to 5

00:10:40,340 --> 00:10:46,430
182 oh and now we can tell peer be about

00:10:44,360 --> 00:10:49,790
pure a doing the exact same copy and

00:10:46,430 --> 00:10:52,430
paste where the public key for peer is

00:10:49,790 --> 00:10:54,170
this we paste it in we give it the

00:10:52,430 --> 00:10:57,139
allowed ip's it's it can be in the

00:10:54,170 --> 00:10:58,519
tunnel so 1000 1

00:10:57,139 --> 00:10:59,779
and we give it the internet-facing IP

00:10:58,519 --> 00:11:01,009
address we only have to give the

00:10:59,779 --> 00:11:01,970
internet-facing IP address and one of

00:11:01,009 --> 00:11:04,069
these actually because it'll learn

00:11:01,970 --> 00:11:05,829
automatically through the roaming but

00:11:04,069 --> 00:11:08,809
after do we do that we can just ping and

00:11:05,829 --> 00:11:10,279
it works it it does all the crypto

00:11:08,809 --> 00:11:12,170
behind the scenes so there's kind of

00:11:10,279 --> 00:11:14,269
know is it connected you just set it up

00:11:12,170 --> 00:11:16,100
and it goes and we hit wgz there then

00:11:14,269 --> 00:11:17,779
you can see some information about what

00:11:16,100 --> 00:11:19,579
actually happened but from the admin

00:11:17,779 --> 00:11:23,379
point of view it just it's just on you

00:11:19,579 --> 00:11:26,869
can figure it and it goes huh so that's

00:11:23,379 --> 00:11:28,790
that's about it as opposed to using it

00:11:26,869 --> 00:11:30,939
there it's not really more complicated

00:11:28,790 --> 00:11:30,939
than that

00:11:43,660 --> 00:11:49,369
okay so there's as we saw there's WG

00:11:46,790 --> 00:11:51,949
which is just this very simple tool for

00:11:49,369 --> 00:11:54,199
configuring things maybe it'll be folded

00:11:51,949 --> 00:11:55,309
into IP route two at some point or maybe

00:11:54,199 --> 00:11:58,790
it's best to keep that kind of thing

00:11:55,309 --> 00:12:01,309
standalone discussion to be had down the

00:11:58,790 --> 00:12:03,230
line but very simple and you can kind of

00:12:01,309 --> 00:12:05,389
build other tools on top of this is

00:12:03,230 --> 00:12:07,009
basic building block is this kind of

00:12:05,389 --> 00:12:08,449
bare-bones GG tool and then you can make

00:12:07,009 --> 00:12:10,759
all sorts of network management things

00:12:08,449 --> 00:12:13,459
if you wanted to there's a net link

00:12:10,759 --> 00:12:15,949
based API that just has two commands to

00:12:13,459 --> 00:12:20,329
get to get all the device info and set

00:12:15,949 --> 00:12:22,699
to set the device it takes a big net

00:12:20,329 --> 00:12:24,889
link message with the device information

00:12:22,699 --> 00:12:26,569
and then a nested list of all appears

00:12:24,889 --> 00:12:32,360
and then each peer has a nested list of

00:12:26,569 --> 00:12:35,990
the allowed IPs and we fragment this up

00:12:32,360 --> 00:12:38,990
into pieces and put into a bunch of

00:12:35,990 --> 00:12:41,959
different s copies and it seems to work

00:12:38,990 --> 00:12:44,029
okay for forgetting its we only do dump

00:12:41,959 --> 00:12:45,860
you can't get an individual periods just

00:12:44,029 --> 00:12:50,389
you get everything all at once

00:12:45,860 --> 00:12:52,459
and as soon as we fast enough the road

00:12:50,389 --> 00:12:55,730
map might be adding some multicast event

00:12:52,459 --> 00:12:57,709
notifications through net link so maybe

00:12:55,730 --> 00:12:59,059
when a handshake is initialized some

00:12:57,709 --> 00:13:00,740
specific applications want a

00:12:59,059 --> 00:13:04,959
notification of that and we could add

00:13:00,740 --> 00:13:07,699
that that kind of thing pretty easily so

00:13:04,959 --> 00:13:09,110
this is actually really easily composed

00:13:07,699 --> 00:13:11,600
and integrated and it's already been put

00:13:09,110 --> 00:13:13,519
into a lot of things there's a wif up

00:13:11,600 --> 00:13:17,420
down helper for it it's in the core

00:13:13,519 --> 00:13:19,120
repository now of open wrt and lead it's

00:13:17,420 --> 00:13:21,860
kind of a central part of their system

00:13:19,120 --> 00:13:24,740
it's part of open RC it's part of nick's

00:13:21,860 --> 00:13:26,179
OS build route supports it letting Skip

00:13:24,740 --> 00:13:27,589
from the docker people and now have this

00:13:26,179 --> 00:13:30,170
is kind of their central networking

00:13:27,589 --> 00:13:33,610
component it's available for edge OS

00:13:30,170 --> 00:13:36,879
like the the ubiquity of I had a stuff

00:13:33,610 --> 00:13:40,009
the phone in my pocket runs it

00:13:36,879 --> 00:13:42,740
integrates with androids native network

00:13:40,009 --> 00:13:44,660
management things there's work in

00:13:42,740 --> 00:13:47,019
progress integration going on for system

00:13:44,660 --> 00:13:50,899
D Network D and for network manager and

00:13:47,019 --> 00:13:52,699
just with WD alone everyone has you know

00:13:50,899 --> 00:13:56,120
they're trivial shell script to set

00:13:52,699 --> 00:13:57,500
things up and there are also packages

00:13:56,120 --> 00:14:00,260
ready for about 20 different

00:13:57,500 --> 00:14:04,360
distributions of all all sorts so you

00:14:00,260 --> 00:14:04,360
can you can apt get it and know the rest

00:14:05,740 --> 00:14:10,700
with the tools package we do ship one

00:14:08,600 --> 00:14:14,240
really simple shell script called WG

00:14:10,700 --> 00:14:16,220
quick which is like the normal WG format

00:14:14,240 --> 00:14:19,760
except it takes additionally in address

00:14:16,220 --> 00:14:24,529
in a DNS and then it calls IP route ad

00:14:19,760 --> 00:14:26,480
and IP address ad and resolve coffin all

00:14:24,529 --> 00:14:28,550
the rest but this is just a silly little

00:14:26,480 --> 00:14:32,210
bash script that a lot of major things

00:14:28,550 --> 00:14:33,589
people do commonly with it but it seems

00:14:32,210 --> 00:14:35,000
like a lot of people when they need more

00:14:33,589 --> 00:14:37,910
complicated things they take this they

00:14:35,000 --> 00:14:40,880
modify it and they have you know million

00:14:37,910 --> 00:14:43,880
different possibilities okay so how is

00:14:40,880 --> 00:14:47,570
this this stateless configuration thing

00:14:43,880 --> 00:14:50,660
done no obviously it's a stateful

00:14:47,570 --> 00:14:52,490
protocol I mean you can't do good crypto

00:14:50,660 --> 00:14:56,029
without having some kind of state that's

00:14:52,490 --> 00:15:00,920
kept but it appears stateless to the

00:14:56,029 --> 00:15:03,830
administrator and we do this with a very

00:15:00,920 --> 00:15:06,620
simple series of timers and a little

00:15:03,830 --> 00:15:10,520
state machine that's event was that's

00:15:06,620 --> 00:15:12,740
this event based and the state machine

00:15:10,520 --> 00:15:14,240
has been drawn up in such a way that you

00:15:12,740 --> 00:15:15,920
can you can write the whole thing down

00:15:14,240 --> 00:15:18,110
and see that there are no undefined

00:15:15,920 --> 00:15:22,160
state transitions possible so it's a

00:15:18,110 --> 00:15:24,320
fully complete state machine so user

00:15:22,160 --> 00:15:26,180
space sends a packet if there's been no

00:15:24,320 --> 00:15:27,920
session established for a hundred twenty

00:15:26,180 --> 00:15:31,190
seconds then we send a handshake

00:15:27,920 --> 00:15:33,470
initiation packet if there's no response

00:15:31,190 --> 00:15:36,589
after five seconds we resend a handshake

00:15:33,470 --> 00:15:37,970
initiation that is we send a new one

00:15:36,589 --> 00:15:42,050
we don't retransmitted just send a new

00:15:37,970 --> 00:15:43,779
one if there is successful

00:15:42,050 --> 00:15:47,540
authentication of an incoming packet

00:15:43,779 --> 00:15:49,910
then we send an empty authenticated

00:15:47,540 --> 00:15:52,550
packet after ten seconds if we don't

00:15:49,910 --> 00:15:54,380
have anything else to send so if you're

00:15:52,550 --> 00:15:57,380
talking to me and I don't have anything

00:15:54,380 --> 00:15:59,839
natural to send back to you then I'll

00:15:57,380 --> 00:16:02,630
just send you nothing but authenticated

00:15:59,839 --> 00:16:05,839
so that at least you know I I heard your

00:16:02,630 --> 00:16:06,890
message but if you're not talking to me

00:16:05,839 --> 00:16:08,480
and I'm not talking to you then we don't

00:16:06,890 --> 00:16:09,619
have to send each other anything so it's

00:16:08,480 --> 00:16:12,959
not chatty

00:16:09,619 --> 00:16:15,809
so then if we don't get anything after

00:16:12,959 --> 00:16:17,129
15 seconds then we know I've been

00:16:15,809 --> 00:16:20,129
sending something to someone and they

00:16:17,129 --> 00:16:21,389
haven't sent anything back to me so it

00:16:20,129 --> 00:16:23,489
was probably some disconnection so we

00:16:21,389 --> 00:16:26,670
send a handshake initiation so we we

00:16:23,489 --> 00:16:28,439
start over and this is super simple

00:16:26,670 --> 00:16:29,910
model what winds up giving us a really

00:16:28,439 --> 00:16:33,059
nice properties where things are just

00:16:29,910 --> 00:16:36,179
always on when you need it but then it's

00:16:33,059 --> 00:16:39,239
not on it doesn't send any packets when

00:16:36,179 --> 00:16:40,980
you stop using it so it's not a chatty

00:16:39,239 --> 00:16:45,989
protocol but it's always available

00:16:40,980 --> 00:16:48,059
nonetheless wire guard makes use of a

00:16:45,989 --> 00:16:55,049
lot of nice tricks to do things for

00:16:48,059 --> 00:16:57,860
network namespaces so as I mentioned

00:16:55,049 --> 00:17:03,749
it's UDP base so that means we we have a

00:16:57,860 --> 00:17:07,169
socket that's part of the driver and you

00:17:03,749 --> 00:17:09,209
can have your wire guard interface in

00:17:07,169 --> 00:17:11,279
one namespace and you say your physical

00:17:09,209 --> 00:17:14,639
interfaces or other interfaces in

00:17:11,279 --> 00:17:17,939
another namespace and the socket that it

00:17:14,639 --> 00:17:20,839
uses will always live in the namespace

00:17:17,939 --> 00:17:23,699
where the device was first added

00:17:20,839 --> 00:17:25,980
so if you add wire guard and say you're

00:17:23,699 --> 00:17:28,769
in it namespace and then you move the

00:17:25,980 --> 00:17:32,070
interface to a different namespace the

00:17:28,769 --> 00:17:33,510
socket remains in init namespace so you

00:17:32,070 --> 00:17:36,450
can do really cool things like this like

00:17:33,510 --> 00:17:37,950
you can you can make a container only

00:17:36,450 --> 00:17:41,220
allow them to access the internet

00:17:37,950 --> 00:17:43,769
through wire guard or well look at some

00:17:41,220 --> 00:17:47,639
diagrams so for the container interface

00:17:43,769 --> 00:17:49,110
you could have W G 0 and your container

00:17:47,639 --> 00:17:52,559
names face in your docker container or

00:17:49,110 --> 00:17:56,100
whatever it pings in clear text and then

00:17:52,559 --> 00:17:58,440
the driver encrypts things and sends the

00:17:56,100 --> 00:18:00,059
UDP ciphertext out through the init name

00:17:58,440 --> 00:18:02,309
space because the socket is actually

00:18:00,059 --> 00:18:04,950
living where the device was originally

00:18:02,309 --> 00:18:07,620
created so this would give kind of a

00:18:04,950 --> 00:18:09,480
perfect isolation to a container where

00:18:07,620 --> 00:18:11,309
it's only way of accessing the outside

00:18:09,480 --> 00:18:14,010
world is through this encrypted and

00:18:11,309 --> 00:18:16,139
authenticated tunnel or we can reverse

00:18:14,010 --> 00:18:19,730
the picture where we could give your

00:18:16,139 --> 00:18:23,520
init namespace only the WG 0 interface

00:18:19,730 --> 00:18:25,840
and then put your makes a

00:18:23,520 --> 00:18:28,990
interface called physical where we put

00:18:25,840 --> 00:18:30,250
your Ethernet or wireless and that way

00:18:28,990 --> 00:18:32,440
when you when you're loading your web

00:18:30,250 --> 00:18:34,240
browser in the init namespace the only

00:18:32,440 --> 00:18:37,480
thing your web browser can see is WG

00:18:34,240 --> 00:18:39,360
zero because because the other

00:18:37,480 --> 00:18:42,730
interfaces are in the physical namespace

00:18:39,360 --> 00:18:43,330
and so again then you get no no possible

00:18:42,730 --> 00:18:45,400
weak Ã¤j--

00:18:43,330 --> 00:18:47,740
and this is made possible because we

00:18:45,400 --> 00:18:51,780
always keep the socket in the original

00:18:47,740 --> 00:18:51,780
namespace where the device was created

00:18:53,190 --> 00:18:58,030
we do some nice policy routing things

00:18:56,020 --> 00:19:01,419
you can set the fw mark on these

00:18:58,030 --> 00:19:03,250
outgoing UDP packets so this would be

00:19:01,419 --> 00:19:06,730
the same in user space where you make a

00:19:03,250 --> 00:19:08,320
socket and you call a so mark on it and

00:19:06,730 --> 00:19:11,679
this works pretty well it allows us to

00:19:08,320 --> 00:19:15,760
you know do IP rules with fw mark and

00:19:11,679 --> 00:19:19,270
suppress prefix and whatnot but there's

00:19:15,760 --> 00:19:21,370
a patch it posted maybe a year and a

00:19:19,270 --> 00:19:26,950
half or two ago they I need to follow up

00:19:21,370 --> 00:19:30,250
on and kind of push to its end is not oh

00:19:26,950 --> 00:19:34,030
i f-4s oh not oh is where you could

00:19:30,250 --> 00:19:36,070
specify to your struct flow i that you

00:19:34,030 --> 00:19:39,160
want it to find a way of rounding the

00:19:36,070 --> 00:19:42,040
packet that assumes a certain interface

00:19:39,160 --> 00:19:43,330
doesn't exist so you could avoid routing

00:19:42,040 --> 00:19:44,500
loops when you're when you're trying to

00:19:43,330 --> 00:19:50,080
send things out so you could override

00:19:44,500 --> 00:19:51,850
the default route but then the packets

00:19:50,080 --> 00:19:53,140
that are encrypted wouldn't go out

00:19:51,850 --> 00:19:56,350
through wire guarded go out through

00:19:53,140 --> 00:19:58,780
everything else except wire guard this

00:19:56,350 --> 00:20:01,570
has an analog in user space would be s

00:19:58,780 --> 00:20:03,220
oh not Oh F where you could mark a

00:20:01,570 --> 00:20:05,679
socket as having this property I want

00:20:03,220 --> 00:20:08,400
the socket to route things such that a

00:20:05,679 --> 00:20:10,540
particular interface doesn't exist so

00:20:08,400 --> 00:20:12,940
that's something I need to follow up on

00:20:10,540 --> 00:20:16,059
and be interesting to to to see the the

00:20:12,940 --> 00:20:19,000
feedback of you all about that as I

00:20:16,059 --> 00:20:21,040
mentioned it's a stealthy protocol so it

00:20:19,000 --> 00:20:24,130
doesn't respond to any unauthenticated

00:20:21,040 --> 00:20:25,270
packets so you can't scan for wire guard

00:20:24,130 --> 00:20:28,240
services on the Internet

00:20:25,270 --> 00:20:29,590
it only will respond if you're sending a

00:20:28,240 --> 00:20:32,440
packet that has the right crypto that

00:20:29,590 --> 00:20:33,669
authenticates correctly and as I

00:20:32,440 --> 00:20:35,860
mentioned it's not chatty when there's

00:20:33,669 --> 00:20:36,640
no data to be sent it to stop sending

00:20:35,860 --> 00:20:39,070
data

00:20:36,640 --> 00:20:40,480
goes to sleep it it doesn't keep going

00:20:39,070 --> 00:20:44,500
so this is it's really nice for mobile

00:20:40,480 --> 00:20:45,549
where it's not using any battery just to

00:20:44,500 --> 00:20:49,840
keep the connection alive because

00:20:45,549 --> 00:20:52,510
there's not really a connection there's

00:20:49,840 --> 00:20:55,000
a lot of Defense and depth security

00:20:52,510 --> 00:20:57,070
practices that went into designing it

00:20:55,000 --> 00:20:58,540
all the state that's required for our

00:20:57,070 --> 00:21:01,630
guard to work is allocated during

00:20:58,540 --> 00:21:05,020
configuration time not in relation to

00:21:01,630 --> 00:21:07,840
packets being sent and so since there's

00:21:05,020 --> 00:21:10,410
no dynamic memory allocation you kind of

00:21:07,840 --> 00:21:15,640
throw away a whole variety of bugs that

00:21:10,410 --> 00:21:19,419
that come out of that the packet parsing

00:21:15,640 --> 00:21:23,559
itself doesn't exist because everything

00:21:19,419 --> 00:21:25,780
is fixed with so we don't have to you

00:21:23,559 --> 00:21:27,820
know do any crazy asm1 parsing or

00:21:25,780 --> 00:21:30,340
whatever else and so it's the kind of

00:21:27,820 --> 00:21:33,429
thing where we if we have if we have no

00:21:30,340 --> 00:21:35,700
parser then we have no parser bugs kind

00:21:33,429 --> 00:21:37,929
of a magical way of eliminating

00:21:35,700 --> 00:21:39,850
vulnerabilities and the last thing is

00:21:37,929 --> 00:21:42,580
important we don't modify any state in

00:21:39,850 --> 00:21:45,309
response to unauthenticated packets and

00:21:42,580 --> 00:21:48,190
this is especially important to have

00:21:45,309 --> 00:21:49,750
because we're not allocating any memory

00:21:48,190 --> 00:21:52,660
in response to receive packets which

00:21:49,750 --> 00:21:55,840
means if we are going to modify the

00:21:52,660 --> 00:21:57,070
memory we have allocated it better be in

00:21:55,840 --> 00:22:01,720
response to something that's authentic

00:21:57,070 --> 00:22:03,790
not just some some random stuff so the

00:22:01,720 --> 00:22:05,260
these requirements make it nice for kind

00:22:03,790 --> 00:22:07,660
of a lightweight kernel environment but

00:22:05,260 --> 00:22:09,669
also really heavily impacted the crypto

00:22:07,660 --> 00:22:11,590
that went into designing it to actually

00:22:09,669 --> 00:22:15,100
make a protocol that could be

00:22:11,590 --> 00:22:16,840
implemented like this a lot of times

00:22:15,100 --> 00:22:18,850
crypto protocols first comes the

00:22:16,840 --> 00:22:20,440
cryptography and then it's kind of left

00:22:18,850 --> 00:22:22,960
up to the programmers to figure out the

00:22:20,440 --> 00:22:24,460
best way to implement it but this has

00:22:22,960 --> 00:22:26,460
been done a little bit in Reverse or

00:22:24,460 --> 00:22:28,510
kind of in tandem with each other where

00:22:26,460 --> 00:22:31,360
had this concern how do I want to

00:22:28,510 --> 00:22:32,950
implement it what what environment is it

00:22:31,360 --> 00:22:38,440
for all right now we'll look at what

00:22:32,950 --> 00:22:40,480
cryptographic methods are available and

00:22:38,440 --> 00:22:43,480
so this this forces us to be one

00:22:40,480 --> 00:22:46,179
round-trip for the handshake we also

00:22:43,480 --> 00:22:48,040
have really fast crypto primitives we

00:22:46,179 --> 00:22:50,110
use a touch of twenty point one three or

00:22:48,040 --> 00:22:53,860
five for symmetric encryption which

00:22:50,110 --> 00:22:56,830
is fast on an all Hardware not just not

00:22:53,860 --> 00:23:00,400
just Intel likes AAS and I so will go

00:22:56,830 --> 00:23:02,710
into details on that later there's also

00:23:00,400 --> 00:23:05,410
a really clear division between the slow

00:23:02,710 --> 00:23:07,090
path for the handshake for things like a

00:23:05,410 --> 00:23:08,650
lip to curve cryptography and a fast

00:23:07,090 --> 00:23:12,100
path for symmetric crypto for the actual

00:23:08,650 --> 00:23:14,790
packet encryption and I suppose this is

00:23:12,100 --> 00:23:19,390
akin to in IPSec you have the key in

00:23:14,790 --> 00:23:20,700
daemon being separate user space but in

00:23:19,390 --> 00:23:23,950
this we're doing an all in kernel space

00:23:20,700 --> 00:23:27,460
and because we smush it together we can

00:23:23,950 --> 00:23:30,429
take advantage of kind of signaling

00:23:27,460 --> 00:23:33,190
events that happen in both the data

00:23:30,429 --> 00:23:37,080
plane and the handshake plane but there

00:23:33,190 --> 00:23:37,080
still is a clear separation between them

00:23:37,140 --> 00:23:43,600
and well all the talk about crypto

00:23:42,280 --> 00:23:46,270
designed just for the kernel might be

00:23:43,600 --> 00:23:48,580
scary this has actually been formally

00:23:46,270 --> 00:23:51,520
verified using a tool called tamarin

00:23:48,580 --> 00:23:53,799
where we wrote up the whole model of all

00:23:51,520 --> 00:23:56,080
the crypto that's happening and now

00:23:53,799 --> 00:23:58,390
develop mathematical proofs that it's

00:23:56,080 --> 00:24:00,790
not nonsense actually works

00:23:58,390 --> 00:24:07,090
it fits the security properties we claim

00:24:00,790 --> 00:24:15,130
it does etc this is curious we would I

00:24:07,090 --> 00:24:16,990
do multi core cryptography so for a lot

00:24:15,130 --> 00:24:19,330
of processor intensive things in the

00:24:16,990 --> 00:24:23,049
kernel in the in the networking stack

00:24:19,330 --> 00:24:25,360
anyway the idea is well if you have a

00:24:23,049 --> 00:24:29,710
bunch of different flows you put each

00:24:25,360 --> 00:24:31,330
flow per core and because most routers

00:24:29,710 --> 00:24:33,780
are dealing with tons of different flows

00:24:31,330 --> 00:24:36,220
this will kind of work out over time and

00:24:33,780 --> 00:24:39,340
there's no need to make a single flow

00:24:36,220 --> 00:24:40,929
fast but actually I think in a lot of

00:24:39,340 --> 00:24:42,280
cases you do want a single flow to be

00:24:40,929 --> 00:24:45,669
fast especially if you're running this

00:24:42,280 --> 00:24:47,679
on some some tiny home router and trying

00:24:45,669 --> 00:24:51,160
to download a file you know a single

00:24:47,679 --> 00:24:52,870
file or a movie stream you don't want

00:24:51,160 --> 00:24:55,150
that to be pegged to a single core you

00:24:52,870 --> 00:25:01,390
want a single flow to be able to take

00:24:55,150 --> 00:25:03,580
advantage of multiple cores so this is a

00:25:01,390 --> 00:25:05,170
bit of a different requirement than

00:25:03,580 --> 00:25:11,890
previous things have tried to account

00:25:05,170 --> 00:25:13,600
for there's a there's a parallel aspect

00:25:11,890 --> 00:25:16,660
and serial aspect the parallel aspect is

00:25:13,600 --> 00:25:18,370
that packets can be encrypted and

00:25:16,660 --> 00:25:21,790
decrypted in parallel on lots of cores

00:25:18,370 --> 00:25:25,270
but the transmission of packets has to

00:25:21,790 --> 00:25:28,210
be done in serial because you know why

00:25:25,270 --> 00:25:29,710
out of order packets and likewise once

00:25:28,210 --> 00:25:39,190
checking your sequence number checking

00:25:29,710 --> 00:25:41,860
has to be done in order so the parallel

00:25:39,190 --> 00:25:45,880
encryption queue is multi producer multi

00:25:41,860 --> 00:25:49,810
consumer right now we're using the

00:25:45,880 --> 00:25:51,520
pointer QH which is it's a great ring

00:25:49,810 --> 00:25:53,830
buffer structure but it's not lock with

00:25:51,520 --> 00:25:56,200
so I'm looking now at trying to make

00:25:53,830 --> 00:25:57,760
this a lock with structure but remains

00:25:56,200 --> 00:26:02,280
to be seen how much this will help

00:25:57,760 --> 00:26:04,540
things lock less things are great for

00:26:02,280 --> 00:26:06,430
having tons of cores and reducing

00:26:04,540 --> 00:26:08,080
contention but sometimes you wind up

00:26:06,430 --> 00:26:10,420
spinning anyway on a compare and

00:26:08,080 --> 00:26:17,200
exchange so some kind of future research

00:26:10,420 --> 00:26:19,650
to look into for that also we're we

00:26:17,200 --> 00:26:22,270
started to use a lock with linked list

00:26:19,650 --> 00:26:24,370
but that winds up being really hard and

00:26:22,270 --> 00:26:29,650
terrible to implement so we're back to

00:26:24,370 --> 00:26:31,300
the ring buffer the traditional wisdom

00:26:29,650 --> 00:26:34,930
for this kind of thing says well really

00:26:31,300 --> 00:26:39,040
you should just do a single queue per

00:26:34,930 --> 00:26:41,370
CPU and then you don't have this this

00:26:39,040 --> 00:26:44,530
problem multi producer multi consumer

00:26:41,370 --> 00:26:47,010
and well indeed this reduces lock

00:26:44,530 --> 00:26:47,010
contention

00:26:48,600 --> 00:26:54,430
it makes the scheduler now an important

00:26:52,210 --> 00:26:56,530
part the packet flow so if say you're

00:26:54,430 --> 00:26:58,900
distributing a bunch of packets to these

00:26:56,530 --> 00:27:00,670
different CPU cores and they need to

00:26:58,900 --> 00:27:02,530
then be transmitted later on in a

00:27:00,670 --> 00:27:06,520
particular order

00:27:02,530 --> 00:27:08,260
if you have a queue per CPU and means

00:27:06,520 --> 00:27:11,320
the scheduler has to hit each of these

00:27:08,260 --> 00:27:16,310
CPUs before it can transmit a packet so

00:27:11,320 --> 00:27:19,050
if you have packet one on CPU eight and

00:27:16,310 --> 00:27:22,050
the rest of the packets on CPUs one

00:27:19,050 --> 00:27:23,580
through seven now you have to wait for

00:27:22,050 --> 00:27:26,130
the the scheduler to get all the way to

00:27:23,580 --> 00:27:27,540
CPU eight in order to start transmitting

00:27:26,130 --> 00:27:30,540
things because it needs to transmit the

00:27:27,540 --> 00:27:33,630
first packet first so by making things

00:27:30,540 --> 00:27:35,400
single Cuba shared by all CPUs then it

00:27:33,630 --> 00:27:40,590
means whichever CPU the scheduler

00:27:35,400 --> 00:27:47,040
happens to give can start encrypting

00:27:40,590 --> 00:27:50,010
packets now interestingly for receiving

00:27:47,040 --> 00:27:53,430
packets though the trend and most

00:27:50,010 --> 00:27:55,110
drivers is to use net ifr X and Q things

00:27:53,430 --> 00:27:58,800
up we actually don't want an additional

00:27:55,110 --> 00:28:01,110
queue we use net I have four sieve skp

00:27:58,800 --> 00:28:04,160
instead so that we block well it's being

00:28:01,110 --> 00:28:08,130
received so that we actually wind up

00:28:04,160 --> 00:28:11,850
filling up the serial queue for longer

00:28:08,130 --> 00:28:13,470
so that if if packets come in and the

00:28:11,850 --> 00:28:16,830
serial queue is already massive because

00:28:13,470 --> 00:28:19,680
say net I F receive s KB is really slow

00:28:16,830 --> 00:28:21,270
then we push back on adding new packets

00:28:19,680 --> 00:28:23,040
to it and that way we don't wind up

00:28:21,270 --> 00:28:25,740
discarding packets because the net I

00:28:23,040 --> 00:28:27,890
have our XQ is full we discard them

00:28:25,740 --> 00:28:36,090
early on before we waste the cycles for

00:28:27,890 --> 00:28:41,040
decryption it turns out that if we bunch

00:28:36,090 --> 00:28:43,560
of packets together so that related

00:28:41,040 --> 00:28:46,560
packets are encrypted all in order on

00:28:43,560 --> 00:28:48,530
the same CPU instead of spreading them

00:28:46,560 --> 00:28:51,630
out we get a bunch of performance gains

00:28:48,530 --> 00:28:53,940
of course we want things to be in

00:28:51,630 --> 00:28:56,460
parallel in general but say a series of

00:28:53,940 --> 00:28:58,590
packets that just came in why does it

00:28:56,460 --> 00:29:01,020
being a lot faster to implement a big

00:28:58,590 --> 00:29:03,600
chunk or a bundle of packets immediately

00:29:01,020 --> 00:29:05,130
on the same on the same core so the

00:29:03,600 --> 00:29:08,310
question that comes out of this then is

00:29:05,130 --> 00:29:12,690
how big do we make the bundles if is it

00:29:08,310 --> 00:29:14,580
best to do 40 packets at a time or a

00:29:12,690 --> 00:29:16,680
hundred packets or what's the deal how

00:29:14,580 --> 00:29:18,560
do we choose the size so it turns out

00:29:16,680 --> 00:29:22,140
that gso gives us the answer we

00:29:18,560 --> 00:29:24,420
advertise that wire guard accepts a gso

00:29:22,140 --> 00:29:27,120
super packet and then in the driver

00:29:24,420 --> 00:29:29,190
itself we call skb she has those

00:29:27,120 --> 00:29:29,700
segments so that then we have all the

00:29:29,190 --> 00:29:30,990
individual

00:29:29,700 --> 00:29:32,820
packets but now we know that these

00:29:30,990 --> 00:29:34,919
packets are related that these are

00:29:32,820 --> 00:29:40,830
bunched up and so we can queue these up

00:29:34,919 --> 00:29:43,380
as a discrete item in in I guess a

00:29:40,830 --> 00:29:45,840
length list each so picturing this we

00:29:43,380 --> 00:29:48,210
have our ring buffer of each of items in

00:29:45,840 --> 00:29:56,429
each item in the ring buffer points to

00:29:48,210 --> 00:29:58,380
this linked list of of gso segments so

00:29:56,429 --> 00:30:00,240
of course in all this we have queueing

00:29:58,380 --> 00:30:04,200
big question then is how to determine

00:30:00,240 --> 00:30:06,299
queue lengths one approach is just to

00:30:04,200 --> 00:30:09,330
have a fixed queue length which is

00:30:06,299 --> 00:30:11,190
simple we don't make it too big then we

00:30:09,330 --> 00:30:13,799
won't get buffer blow but how does a

00:30:11,190 --> 00:30:16,740
scale on different speed CPUs a lot of

00:30:13,799 --> 00:30:19,470
questions to be answered there so

00:30:16,740 --> 00:30:21,029
looking at now trying to use dql for

00:30:19,470 --> 00:30:25,169
determined queue length or perhaps even

00:30:21,029 --> 00:30:26,370
better using fq coddle if we go with fq

00:30:25,169 --> 00:30:27,779
comma route then there's a big question

00:30:26,370 --> 00:30:31,289
of whether or not we should use it by

00:30:27,779 --> 00:30:32,639
the queue disk layer and then we'd be

00:30:31,289 --> 00:30:35,570
starting and stopping sub queues as

00:30:32,639 --> 00:30:37,649
things get full or using it directly

00:30:35,570 --> 00:30:41,960
there's also this issue of fairness

00:30:37,649 --> 00:30:41,960
between queues versus fairness per flow

00:30:42,110 --> 00:30:47,669
if we go with fq kadhalan the cutest

00:30:44,700 --> 00:30:49,559
layer one disadvantage of that is then

00:30:47,669 --> 00:30:52,380
we can no longer be an iff no queue

00:30:49,559 --> 00:30:55,139
interface turns out with the with a no

00:30:52,380 --> 00:30:57,059
queue interface you can return from and

00:30:55,139 --> 00:30:59,250
do start x met and error number that

00:30:57,059 --> 00:31:00,510
gets passed up to user space directly

00:30:59,250 --> 00:31:02,850
which is really nice because we can give

00:31:00,510 --> 00:31:07,019
more descriptive errors to user space of

00:31:02,850 --> 00:31:08,610
why a packet might not being be sent but

00:31:07,019 --> 00:31:10,789
there's also ICMP for this kind of thing

00:31:08,610 --> 00:31:15,690
which we're also using in the case that

00:31:10,789 --> 00:31:17,279
why are guards running on a router there

00:31:15,690 --> 00:31:19,470
there's kind of a open question with

00:31:17,279 --> 00:31:21,960
sending ICMP packets from a struct net

00:31:19,470 --> 00:31:25,440
device what if the packets already been

00:31:21,960 --> 00:31:27,779
transformed by s net in which case

00:31:25,440 --> 00:31:29,539
calling ICMP on this will use the s

00:31:27,779 --> 00:31:32,909
added address for the rate-limiting

00:31:29,539 --> 00:31:35,100
which is problematic so if some clear

00:31:32,909 --> 00:31:37,110
right now if net filter needs and

00:31:35,100 --> 00:31:41,190
connection tracking needs to link into

00:31:37,110 --> 00:31:44,059
ICMP send or if this can be still hidden

00:31:41,190 --> 00:31:44,059
in that filter

00:31:44,160 --> 00:31:51,300
so a open issue we've been discussing

00:31:46,800 --> 00:31:54,240
here a bit some people want to send in

00:31:51,300 --> 00:31:56,910
banned messages so like configuration in

00:31:54,240 --> 00:32:01,560
info within the tunnel that would not be

00:31:56,910 --> 00:32:05,340
IP packets people want this for dynamic

00:32:01,560 --> 00:32:07,950
IP addresses DHCP replacement kind of

00:32:05,340 --> 00:32:10,050
thing some folks want to do a post

00:32:07,950 --> 00:32:12,240
quantum exchange within the wire guard

00:32:10,050 --> 00:32:13,920
tunnel other really monstrous things

00:32:12,240 --> 00:32:19,680
people have all sorts of stuff they want

00:32:13,920 --> 00:32:22,130
to put over a control band and so I

00:32:19,680 --> 00:32:24,900
wonder is is this useful do we want this

00:32:22,130 --> 00:32:28,080
what situations really necessitate it

00:32:24,900 --> 00:32:30,270
and which other use cases can be punted

00:32:28,080 --> 00:32:33,870
to an out-of-band mechanism or just

00:32:30,270 --> 00:32:35,820
statically configured in other words for

00:32:33,870 --> 00:32:39,380
how long can I say no to the people

00:32:35,820 --> 00:32:42,540
asking for this and have things work and

00:32:39,380 --> 00:32:45,120
I hope I can keep saying no but maybe

00:32:42,540 --> 00:32:46,920
there are good use cases and so I've

00:32:45,120 --> 00:32:50,520
started to think about best way to

00:32:46,920 --> 00:32:53,210
implement that so three approaches first

00:32:50,520 --> 00:32:56,220
would be to add a eff wire guard where

00:32:53,210 --> 00:32:58,620
send to and receive from take a sock

00:32:56,220 --> 00:33:02,490
address WG that's actually the peers

00:32:58,620 --> 00:33:05,190
public key and I mean this is super

00:33:02,490 --> 00:33:06,840
sleek and elegant wow you make a socket

00:33:05,190 --> 00:33:09,320
and address things right to the public

00:33:06,840 --> 00:33:12,090
key and works with all the socket api's

00:33:09,320 --> 00:33:15,060
but of course now we're adding a you

00:33:12,090 --> 00:33:18,930
know a new AF and the bar is quite high

00:33:15,060 --> 00:33:20,190
to justify that on one hand it's good

00:33:18,930 --> 00:33:22,560
because this would open up interesting

00:33:20,190 --> 00:33:24,810
uses that you know we can't really

00:33:22,560 --> 00:33:27,990
foresee but on the other hand do we want

00:33:24,810 --> 00:33:31,140
people using wire guard for this maybe

00:33:27,990 --> 00:33:33,210
not so a more conservative approach

00:33:31,140 --> 00:33:34,680
would just be a net link event you have

00:33:33,210 --> 00:33:37,500
a multicast event when receiving a

00:33:34,680 --> 00:33:39,720
message and you do a net link call when

00:33:37,500 --> 00:33:41,100
you want to send one and this would kind

00:33:39,720 --> 00:33:43,400
of reinforce the fact that it's for

00:33:41,100 --> 00:33:46,740
control configuration messages and not

00:33:43,400 --> 00:33:49,200
full-blown protocol but AF wire guard

00:33:46,740 --> 00:33:52,440
sounds kind of cool so maybe something

00:33:49,200 --> 00:33:54,390
to discuss and as I mentioned most

00:33:52,440 --> 00:33:56,800
attractive option is just not doing it

00:33:54,390 --> 00:34:00,610
at all keeping things out of

00:33:56,800 --> 00:34:07,570
to be simpler clearer but maybe in-band

00:34:00,610 --> 00:34:12,010
is necessary maybe maybe not yikes wire

00:34:07,570 --> 00:34:14,440
guard has sticky sockets so it always

00:34:12,010 --> 00:34:16,120
listens on all IP addresses it doesn't

00:34:14,440 --> 00:34:17,980
you can't specify that you want to bind

00:34:16,120 --> 00:34:20,470
to a particular IP address because I

00:34:17,980 --> 00:34:21,850
don't want to have ACLs based on where

00:34:20,470 --> 00:34:23,350
you're binding to because there's

00:34:21,850 --> 00:34:26,590
already authentication within the wire

00:34:23,350 --> 00:34:29,830
guard protocol if a packet makes it to

00:34:26,590 --> 00:34:31,810
to the UDP port and it correctly

00:34:29,830 --> 00:34:33,400
authenticates using the crypto then I

00:34:31,810 --> 00:34:37,840
know it's good I don't care where it

00:34:33,400 --> 00:34:40,179
came from so there there's really no

00:34:37,840 --> 00:34:41,890
need to allow binding to two other

00:34:40,179 --> 00:34:44,140
addresses but this does beg the question

00:34:41,890 --> 00:34:48,070
well what about the source address when

00:34:44,140 --> 00:34:53,920
I'm sending packets so with some clever

00:34:48,070 --> 00:34:57,540
use of the desk lookup api's it's

00:34:53,920 --> 00:34:59,620
possible to keep track of the

00:34:57,540 --> 00:35:01,900
destination address from receiving a

00:34:59,620 --> 00:35:05,440
packet to then use that as the source

00:35:01,900 --> 00:35:07,510
address when sending a packet but making

00:35:05,440 --> 00:35:11,230
sure that this kind of stickiness isn't

00:35:07,510 --> 00:35:12,880
too sticky so that it defaults back to

00:35:11,230 --> 00:35:17,470
the the default source address when

00:35:12,880 --> 00:35:20,430
things change and the nice thing about

00:35:17,470 --> 00:35:23,230
this is the semantics for sticky sockets

00:35:20,430 --> 00:35:26,080
map clearly to something that can be

00:35:23,230 --> 00:35:30,820
done in user space too with IP packet

00:35:26,080 --> 00:35:32,770
info so it's not necessarily behavior

00:35:30,820 --> 00:35:34,750
that requires weird kernel things

00:35:32,770 --> 00:35:39,790
because you can you can get it out of IP

00:35:34,750 --> 00:35:42,690
packet info wire guard makes extensive

00:35:39,790 --> 00:35:44,980
use of MEMS 0 explicit to zero out

00:35:42,690 --> 00:35:46,750
ephemeral information from memory so

00:35:44,980 --> 00:35:48,670
that there really is forward secrecy

00:35:46,750 --> 00:35:51,250
that you can't dump someone's physical

00:35:48,670 --> 00:35:55,030
memory and say oh look and all these of

00:35:51,250 --> 00:35:58,800
the allocated parts of the heap there

00:35:55,030 --> 00:36:01,000
are these old keys no we doubt

00:35:58,800 --> 00:36:03,040
disturbingly a lot of crypto related in

00:36:01,000 --> 00:36:05,830
the code and the kernel forgets to do

00:36:03,040 --> 00:36:06,850
this or it doesn't care ok TLS but just

00:36:05,830 --> 00:36:09,040
kind of a bunch of different parts of

00:36:06,850 --> 00:36:10,390
the stack so might be worthwhile at some

00:36:09,040 --> 00:36:13,299
point to clean that up

00:36:10,390 --> 00:36:17,829
but one thing I am finding problematic

00:36:13,299 --> 00:36:21,670
is netlink uses SK B's obviously but if

00:36:17,829 --> 00:36:24,519
I'm putting secret data through sk b how

00:36:21,670 --> 00:36:26,349
do i make sure is zeroed i can do this

00:36:24,519 --> 00:36:28,750
when the colonel receives in sk because

00:36:26,349 --> 00:36:31,059
I can just zero out that part of memory

00:36:28,750 --> 00:36:33,069
before calling K for sk b but when I'm

00:36:31,059 --> 00:36:34,539
sending the sk p back up to user space i

00:36:33,069 --> 00:36:37,589
don't have that same type of control

00:36:34,539 --> 00:36:40,450
over what happens the sk b at the end so

00:36:37,589 --> 00:36:45,450
I'd like to propose a new flag for the

00:36:40,450 --> 00:36:48,029
sk b something sk b 0 on free perhaps

00:36:45,450 --> 00:36:50,859
III could assign the destructor except

00:36:48,029 --> 00:36:52,390
i'm I'm sending things to user space

00:36:50,859 --> 00:36:56,740
socket and that's already assigned a

00:36:52,390 --> 00:36:58,809
destructor so I guess I could wrap the

00:36:56,740 --> 00:37:01,359
pointer to that and put it in the CB and

00:36:58,809 --> 00:37:05,170
yeah terrible right yes so there's gotta

00:37:01,359 --> 00:37:08,980
be I think we might need a new thing for

00:37:05,170 --> 00:37:10,900
this but discussion to be had the the

00:37:08,980 --> 00:37:13,390
biggest issue right now with wire guard

00:37:10,900 --> 00:37:17,769
blocking it from from patch series is

00:37:13,390 --> 00:37:19,329
the crypto API really that there's a lot

00:37:17,769 --> 00:37:22,480
of work to be done in this wire guard

00:37:19,329 --> 00:37:26,980
uses his own internal crypto API because

00:37:22,480 --> 00:37:28,839
the existing one isn't sufficient I'd

00:37:26,980 --> 00:37:36,609
like to start reworking the crypto API

00:37:28,839 --> 00:37:38,200
in 2018 I want to add things more direct

00:37:36,609 --> 00:37:41,470
function calls and so through this huge

00:37:38,200 --> 00:37:43,450
abstraction layer wire guard changes

00:37:41,470 --> 00:37:44,980
keys frequently and I don't want to have

00:37:43,450 --> 00:37:48,039
to allocate a new structure every time I

00:37:44,980 --> 00:37:50,710
want to use a new key I don't want to

00:37:48,039 --> 00:37:54,609
have to deal with with physical memory

00:37:50,710 --> 00:37:56,079
addresses when I just want to encrypt

00:37:54,609 --> 00:37:59,259
something I made on the stack for

00:37:56,079 --> 00:38:01,690
example and there are a lot of a lot of

00:37:59,259 --> 00:38:04,779
like very basic API things that can be

00:38:01,690 --> 00:38:06,880
for placed and even for the primitives

00:38:04,779 --> 00:38:09,220
themselves a lot of them are in pretty

00:38:06,880 --> 00:38:10,900
shabby shape and sup and working people

00:38:09,220 --> 00:38:12,759
in Rio we've been talking about maybe

00:38:10,900 --> 00:38:18,609
adding formally verified primitives to

00:38:12,759 --> 00:38:20,650
the kernel another big issue is if you

00:38:18,609 --> 00:38:22,000
want to use the fast instructions on

00:38:20,650 --> 00:38:25,660
these processors

00:38:22,000 --> 00:38:29,200
you have to you have to get you have to

00:38:25,660 --> 00:38:31,890
ask permission use the FPU so you so

00:38:29,200 --> 00:38:34,860
this usually results in massive save of

00:38:31,890 --> 00:38:37,420
if user space is using these registers

00:38:34,860 --> 00:38:37,690
and then a restore when you're done with

00:38:37,420 --> 00:38:40,120
it

00:38:37,690 --> 00:38:42,220
and in the current crypto API this is

00:38:40,120 --> 00:38:47,050
done for every call of the crypto API

00:38:42,220 --> 00:38:48,250
but if you're encrypting a bunch of

00:38:47,050 --> 00:38:49,240
packets one after another on the same

00:38:48,250 --> 00:38:51,670
thread you don't want to have to be

00:38:49,240 --> 00:38:53,620
toggling back and forth between saving

00:38:51,670 --> 00:38:57,010
restoring these a few it's it's super

00:38:53,620 --> 00:38:58,960
expensive so with my own thing I'm able

00:38:57,010 --> 00:39:00,910
to kind of bash this hoist it outside of

00:38:58,960 --> 00:39:05,020
the loop so it's only done saved and

00:39:00,910 --> 00:39:06,340
restored once per thread though this is

00:39:05,020 --> 00:39:09,190
straightforward and obvious was

00:39:06,340 --> 00:39:11,020
happening maybe a different approach

00:39:09,190 --> 00:39:14,160
would be just to make the restore lazy

00:39:11,020 --> 00:39:21,000
only actually restore when changing

00:39:14,160 --> 00:39:21,000
context that's one possibility as well

00:39:22,500 --> 00:39:27,700
it's super fast because it's in the

00:39:25,600 --> 00:39:29,350
kernel and not tun tap device fast low

00:39:27,700 --> 00:39:32,620
latency like you'd expect there's not

00:39:29,350 --> 00:39:34,120
million copies you do this before watch

00:39:32,620 --> 00:39:39,070
a twenty point one through five is

00:39:34,120 --> 00:39:41,470
really nice because it performs well on

00:39:39,070 --> 00:39:45,940
pretty much all architectures on MIPS on

00:39:41,470 --> 00:39:49,900
an old arm and on avx-512 it's even

00:39:45,940 --> 00:39:51,160
faster than aes ni so looks like I'm

00:39:49,900 --> 00:39:56,170
running out of time so I'll try and

00:39:51,160 --> 00:39:58,450
hurry up and and so well well it'd be

00:39:56,170 --> 00:40:02,470
nice to you know get on the AES

00:39:58,450 --> 00:40:04,110
bandwagon AES is super hard to implement

00:40:02,470 --> 00:40:08,460
that in a way that's fast and

00:40:04,110 --> 00:40:13,620
invulnerable to cache timing attacks on

00:40:08,460 --> 00:40:17,620
on normal hardware so cha-cha 20 is

00:40:13,620 --> 00:40:19,840
really quite nice for this and also wire

00:40:17,620 --> 00:40:22,870
guard I think is is fast because it's

00:40:19,840 --> 00:40:25,420
small I mean less code faster program

00:40:22,870 --> 00:40:28,770
this is a stupid general statement but

00:40:25,420 --> 00:40:31,630
for a lot of cases that happens to be so

00:40:28,770 --> 00:40:35,589
there's just doing less it's it's it's

00:40:31,630 --> 00:40:38,799
simple and so the performance

00:40:35,589 --> 00:40:41,410
graphs are favorable

00:40:38,799 --> 00:40:42,729
I had hinted at this earlier today and

00:40:41,410 --> 00:40:46,059
asking a question there's an extensive

00:40:42,729 --> 00:40:48,940
continuous integration suite that tries

00:40:46,059 --> 00:40:51,339
out all sorts of topologies and weird

00:40:48,940 --> 00:40:55,349
behaviors and interaction with netfilter

00:40:51,339 --> 00:40:58,239
and different peers coming and going and

00:40:55,349 --> 00:41:01,349
every commit is tested on all the

00:40:58,239 --> 00:41:01,349
kernels listed on kernel.org

00:41:01,769 --> 00:41:06,819
freshly built and run in qmu and this

00:41:04,359 --> 00:41:09,969
whole thing goes and does it on a bunch

00:41:06,819 --> 00:41:12,249
of different architectures has built in

00:41:09,969 --> 00:41:15,039
self tests as well and build wire guard

00:41:12,249 --> 00:41:16,539
comm has all the current status and this

00:41:15,039 --> 00:41:19,930
kind of infrastructure has been really

00:41:16,539 --> 00:41:22,089
immensely useful I can push commits up

00:41:19,930 --> 00:41:25,150
kind of fast and frivolously and then I

00:41:22,089 --> 00:41:28,150
can watch them break go back and fix

00:41:25,150 --> 00:41:29,799
things up every time I find a bug I can

00:41:28,150 --> 00:41:32,890
add a little thing to the to the test

00:41:29,799 --> 00:41:35,079
suite and I think a part of upstreaming

00:41:32,890 --> 00:41:36,789
wire guard will be up streaming some

00:41:35,079 --> 00:41:38,589
some components of this infrastructure

00:41:36,789 --> 00:41:40,829
as well because I think it could be

00:41:38,589 --> 00:41:44,200
really useful for the general ecosystem

00:41:40,829 --> 00:41:46,839
so upstream roadmap before we're done

00:41:44,200 --> 00:41:49,660
as I mentioned maybe multicast netlink

00:41:46,839 --> 00:41:53,229
events for these notifications maybe in

00:41:49,660 --> 00:41:55,450
man messages maybe not I don't know the

00:41:53,229 --> 00:41:57,999
crypto API is kind of top of the list of

00:41:55,450 --> 00:41:59,890
things to start tackling and then once

00:41:57,999 --> 00:42:02,289
crypto API in the kernel has been

00:41:59,890 --> 00:42:05,079
changed then I'll pour wire guard from

00:42:02,289 --> 00:42:08,019
my kind of stopgap solution over to the

00:42:05,079 --> 00:42:11,529
improve crypto API hoping some time next

00:42:08,019 --> 00:42:12,910
year for the initial patch series as I

00:42:11,529 --> 00:42:17,680
mentioned is already in many

00:42:12,910 --> 00:42:19,989
distributions it sees regular testing T

00:42:17,680 --> 00:42:21,549
anacott cetera they're already

00:42:19,989 --> 00:42:24,700
commercial VPN providers that are

00:42:21,549 --> 00:42:28,749
selling services with it so it's seeing

00:42:24,700 --> 00:42:31,930
huge production use seen use in kind of

00:42:28,749 --> 00:42:34,599
like top 100 web pages and in massive

00:42:31,930 --> 00:42:36,849
financial institutions so it's getting a

00:42:34,599 --> 00:42:38,469
lot of testing and cycles and we're

00:42:36,849 --> 00:42:41,559
doing kind of every week or every other

00:42:38,469 --> 00:42:42,880
week a snapshot and so now's now is the

00:42:41,559 --> 00:42:44,619
time to start getting upstream feedback

00:42:42,880 --> 00:42:47,859
on the way it's designed you know what

00:42:44,619 --> 00:42:49,300
needs to change before up streaming okay

00:42:47,859 --> 00:42:51,460
so to conclude it's available

00:42:49,300 --> 00:42:53,800
all distros wire guard comm / install

00:42:51,460 --> 00:42:56,380
give you the list I can bill and your

00:42:53,800 --> 00:42:58,060
Colonel compile it as a module there's a

00:42:56,380 --> 00:43:00,070
peer-reviewed paper publish the Serie

00:42:58,060 --> 00:43:01,450
and ESS they can read if you want kind

00:43:00,070 --> 00:43:05,080
of the crypto background and the overall

00:43:01,450 --> 00:43:08,470
design there's a mailing list git repo

00:43:05,080 --> 00:43:09,970
wire guard on freenode I have stickers

00:43:08,470 --> 00:43:12,520
for everyone here if you didn't already

00:43:09,970 --> 00:43:16,120
get them I have copious quantities of

00:43:12,520 --> 00:43:18,370
stickers your to give out of course if

00:43:16,120 --> 00:43:27,670
anyone wants to work on stuff plenty of

00:43:18,370 --> 00:43:28,390
work to be done that's all thanks just

00:43:27,670 --> 00:43:31,210
one question

00:43:28,390 --> 00:43:35,200
I have only one quick thing to say I

00:43:31,210 --> 00:43:37,600
would like you to upstream this earlier

00:43:35,200 --> 00:43:39,310
rather than later so if you have to make

00:43:37,600 --> 00:43:40,630
a decision about when you're gonna do it

00:43:39,310 --> 00:43:42,520
I would like you to err on the side of

00:43:40,630 --> 00:43:44,830
doing it as quickly as possible I mean

00:43:42,520 --> 00:43:48,550
even as an RFC patch set that's in early

00:43:44,830 --> 00:43:50,530
state of being for review and feedback I

00:43:48,550 --> 00:43:51,580
really want to start seeing internet dev

00:43:50,530 --> 00:43:53,800
sometime soon

00:43:51,580 --> 00:43:55,990
okay this is good so I can just put

00:43:53,800 --> 00:44:02,460
RFC's not to be merged now but just to

00:43:55,990 --> 00:44:02,460
solicit feedback alright Jason

00:44:03,700 --> 00:44:07,230

YouTube URL: https://www.youtube.com/watch?v=54orFwtQ1XY


