Title: Resource Management for Hardware Accelerated Linux Kernel Network Functions
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: Andy Roulin, Shrijeet Mukherjee, David Ahern, Roopa Prabhu
Friday November 09th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?roulin-hardwareresourcesmgmt-talk
Captions: 
	00:00:02,880 --> 00:00:08,680
okay so let's get started the next talk

00:00:06,819 --> 00:00:11,049
is about resource management and

00:00:08,680 --> 00:00:13,750
offloaded switches it's actually work

00:00:11,049 --> 00:00:17,949
done by an intern that worked works at

00:00:13,750 --> 00:00:19,359
cumulus networks called Andy and I'll be

00:00:17,949 --> 00:00:21,939
doing the presentation because Andy is

00:00:19,359 --> 00:00:23,769
not here and in preparation for this

00:00:21,939 --> 00:00:27,880
talk I've learned two lessons from

00:00:23,769 --> 00:00:30,340
previous masters from Eric Dumas they

00:00:27,880 --> 00:00:31,119
have learned how to give a talk for

00:00:30,340 --> 00:00:33,460
somebody else

00:00:31,119 --> 00:00:34,960
and make sure that all the good things

00:00:33,460 --> 00:00:37,720
are attributed to me and all the

00:00:34,960 --> 00:00:40,210
mistakes are attributed to Andy and from

00:00:37,720 --> 00:00:43,240
heard I've learned that the right dress

00:00:40,210 --> 00:00:46,390
code is all black but just like my talk

00:00:43,240 --> 00:00:48,610
I'm almost there um it's going to be

00:00:46,390 --> 00:00:51,250
almost as good sort of you're going to

00:00:48,610 --> 00:00:54,390
end up so a little bit of an

00:00:51,250 --> 00:00:56,950
introduction about the topic itself

00:00:54,390 --> 00:00:59,620
cumulus as people may or may not know

00:00:56,950 --> 00:01:01,000
spends a lot of time taking Linux the

00:00:59,620 --> 00:01:03,370
kernel the networking model and

00:01:01,000 --> 00:01:05,830
accelerating it on switches we run on a

00:01:03,370 --> 00:01:09,070
very very wide variety of devices from

00:01:05,830 --> 00:01:11,590
multiple vendors and so on and so forth

00:01:09,070 --> 00:01:13,390
one of the things that we've always run

00:01:11,590 --> 00:01:15,460
into and we've always had problems with

00:01:13,390 --> 00:01:19,300
and that's what this this talk is about

00:01:15,460 --> 00:01:21,880
is how do you reflect Hardware resource

00:01:19,300 --> 00:01:24,880
capability as part of the offload

00:01:21,880 --> 00:01:27,820
conversation to every component and

00:01:24,880 --> 00:01:31,930
vendor sorry component and member that

00:01:27,820 --> 00:01:34,630
needs to know about it so let's get some

00:01:31,930 --> 00:01:36,550
taxonomy right right so this is a very

00:01:34,630 --> 00:01:39,280
sophisticated picture and hopefully you

00:01:36,550 --> 00:01:40,900
can see it out in the back the

00:01:39,280 --> 00:01:42,909
components that matter right there is

00:01:40,900 --> 00:01:44,110
almost always some user space control

00:01:42,909 --> 00:01:46,750
plain diamond something that's

00:01:44,110 --> 00:01:49,810
implementing a protocol you always have

00:01:46,750 --> 00:01:51,670
the Linux kernel and the kernel like it

00:01:49,810 --> 00:01:54,370
should always has some data structure

00:01:51,670 --> 00:01:57,549
that represents a resource and we'll

00:01:54,370 --> 00:01:58,960
call it so for now and typically you

00:01:57,549 --> 00:02:00,909
have a device driver that is now

00:01:58,960 --> 00:02:04,180
synchronizing the state of that table

00:02:00,909 --> 00:02:06,370
with some table in the hardware and this

00:02:04,180 --> 00:02:09,069
is clearly specific to the use case that

00:02:06,370 --> 00:02:10,720
cumulus worries about the most the

00:02:09,069 --> 00:02:13,450
packet paths that wait

00:02:10,720 --> 00:02:16,780
fleurs is through that hardware table so

00:02:13,450 --> 00:02:19,450
the problem in some sense is defined as

00:02:16,780 --> 00:02:21,160
the synchronization between the kernel

00:02:19,450 --> 00:02:22,920
representation of the table and the

00:02:21,160 --> 00:02:25,660
hardware's representation of the table

00:02:22,920 --> 00:02:27,760
one thing I'd make sure I want to make

00:02:25,660 --> 00:02:29,350
sure everybody understands and remembers

00:02:27,760 --> 00:02:31,900
is that those two tables are not the

00:02:29,350 --> 00:02:33,670
same the way they're represented the

00:02:31,900 --> 00:02:35,320
attributes they can carry their

00:02:33,670 --> 00:02:39,850
capabilities that they can express are

00:02:35,320 --> 00:02:42,270
fundamentally different so what are the

00:02:39,850 --> 00:02:44,770
steps in this model that can fail right

00:02:42,270 --> 00:02:46,180
so typically the update from the control

00:02:44,770 --> 00:02:48,910
plane to the kernel are synchronous

00:02:46,180 --> 00:02:50,709
right you have various examples of that

00:02:48,910 --> 00:02:52,270
you need to leave the net link commands

00:02:50,709 --> 00:02:55,360
and so on and so forth and the caller

00:02:52,270 --> 00:02:57,130
expects to know right there and then

00:02:55,360 --> 00:02:59,140
whether the collie is going to be able

00:02:57,130 --> 00:03:03,280
to support the call that was just made I

00:02:59,140 --> 00:03:05,590
whether Kali is the kernel matching has

00:03:03,280 --> 00:03:07,300
effects right for efficiency you almost

00:03:05,590 --> 00:03:10,450
always want to send n number of

00:03:07,300 --> 00:03:12,790
something to the kernel and clearly

00:03:10,450 --> 00:03:14,500
that's a problem because if you fail one

00:03:12,790 --> 00:03:17,140
out of N and the failure happens to be

00:03:14,500 --> 00:03:18,489
in the middle then how do you signal do

00:03:17,140 --> 00:03:20,950
you roll back the whole thing do you

00:03:18,489 --> 00:03:24,340
selectively fail some so on and so forth

00:03:20,950 --> 00:03:27,519
and the second question and sort of one

00:03:24,340 --> 00:03:29,890
of the aspects that matter is since the

00:03:27,519 --> 00:03:33,130
kernel is a relatively monolithic

00:03:29,890 --> 00:03:35,709
component if you make a change how do

00:03:33,130 --> 00:03:37,450
you disperse that change to every user

00:03:35,709 --> 00:03:39,519
space implementation out there which

00:03:37,450 --> 00:03:42,820
also involves forward and backward

00:03:39,519 --> 00:03:44,950
compatibility concerns and then there

00:03:42,820 --> 00:03:47,140
are the opposite which is an update from

00:03:44,950 --> 00:03:49,840
the kernel to hardware not the opposite

00:03:47,140 --> 00:03:51,519
it's sort of the next step right as so

00:03:49,840 --> 00:03:53,200
the first step is getting data from

00:03:51,519 --> 00:03:54,820
there into that table the second is

00:03:53,200 --> 00:03:58,330
getting it from that table to that table

00:03:54,820 --> 00:04:00,010
so the first problem with that second

00:03:58,330 --> 00:04:02,799
step when you're getting from there as

00:04:00,010 --> 00:04:04,660
the picture shows is that the kept the

00:04:02,799 --> 00:04:07,420
capacity and the capabilities might be

00:04:04,660 --> 00:04:10,260
mismatched there might be rate issues

00:04:07,420 --> 00:04:13,269
the kernel might be able to sync data

00:04:10,260 --> 00:04:14,739
memory bandwidth rates whereas let's say

00:04:13,269 --> 00:04:16,299
for the sake of argument if you're

00:04:14,739 --> 00:04:18,760
downloading two Hardware over and I

00:04:16,299 --> 00:04:21,039
squared C bus it's like squeezing it

00:04:18,760 --> 00:04:22,580
into a modem right so you squeeze in too

00:04:21,039 --> 00:04:25,069
much it's going to start having problem

00:04:22,580 --> 00:04:27,889
and then you have pipe mismatches the

00:04:25,069 --> 00:04:31,729
colonel if you think about routing as an

00:04:27,889 --> 00:04:33,919
example uses very simple types of route

00:04:31,729 --> 00:04:35,900
distinguishers it's before or it's v6

00:04:33,919 --> 00:04:38,569
and the rest is sort of within the

00:04:35,900 --> 00:04:40,490
structures in hardware the actual length

00:04:38,569 --> 00:04:44,150
of a prefix is a very important thing

00:04:40,490 --> 00:04:47,150
and it might say that a v4 address and a

00:04:44,150 --> 00:04:49,699
v6 slash 64 are housed in the same spot

00:04:47,150 --> 00:04:51,349
so the way the colonel calls capacity

00:04:49,699 --> 00:04:57,050
might be very different from the way the

00:04:51,349 --> 00:04:59,300
hardware calls capacity sorry if those

00:04:57,050 --> 00:05:01,250
are the problems or - so that those are

00:04:59,300 --> 00:05:04,400
the steps that can fail what are the

00:05:01,250 --> 00:05:07,250
types of failures you can have the worst

00:05:04,400 --> 00:05:09,860
and everybody's favorite is the silent

00:05:07,250 --> 00:05:12,409
failure you told me to do something I

00:05:09,860 --> 00:05:15,199
just decided not to do it and sit on my

00:05:12,409 --> 00:05:17,690
hands this has real problems and we'll

00:05:15,199 --> 00:05:21,740
talk about that in subsequent slides so

00:05:17,690 --> 00:05:23,360
one of the most problematic ones is that

00:05:21,740 --> 00:05:25,759
the kernel table updated the hardware

00:05:23,360 --> 00:05:27,199
table did not update so the package when

00:05:25,759 --> 00:05:31,099
the packet is doing its lookup is

00:05:27,199 --> 00:05:32,779
getting a result which is different from

00:05:31,099 --> 00:05:36,039
what the user thinks the result is going

00:05:32,779 --> 00:05:39,229
to be and the control plane is therefore

00:05:36,039 --> 00:05:40,849
oblivious to that the other kind of

00:05:39,229 --> 00:05:43,000
failure is advertised failures but the

00:05:40,849 --> 00:05:45,229
advertised failures might be

00:05:43,000 --> 00:05:47,539
asynchronous or almost always will be

00:05:45,229 --> 00:05:49,250
asynchronous now this creates a burden

00:05:47,539 --> 00:05:51,800
on the user space up because the user

00:05:49,250 --> 00:05:54,080
space app now has to have some ability

00:05:51,800 --> 00:05:57,050
to say I know I moved my state forward

00:05:54,080 --> 00:05:58,729
but I need to come back and clean it up

00:05:57,050 --> 00:06:01,460
and revert something that I've already

00:05:58,729 --> 00:06:03,080
done and maybe have advertised to the

00:06:01,460 --> 00:06:05,000
rest of the world and we'll talk more

00:06:03,080 --> 00:06:08,120
about that with a specific example in a

00:06:05,000 --> 00:06:09,680
second and we didn't talk about the

00:06:08,120 --> 00:06:13,639
synchronous failure model here because

00:06:09,680 --> 00:06:15,469
it's covered later so let's look at what

00:06:13,639 --> 00:06:17,389
this means from an actual example

00:06:15,469 --> 00:06:19,069
perspective and this is a little bit

00:06:17,389 --> 00:06:22,129
dense and it's got a lot of information

00:06:19,069 --> 00:06:23,870
so I'm going to try and talk slowly and

00:06:22,129 --> 00:06:25,520
point to things and if it's not clear

00:06:23,870 --> 00:06:26,960
this is actually a good time to just

00:06:25,520 --> 00:06:30,560
raise your hand and say I didn't get

00:06:26,960 --> 00:06:32,810
that and we'll go talk about it more so

00:06:30,560 --> 00:06:34,880
this is in this example what you have is

00:06:32,810 --> 00:06:37,250
you have a host which

00:06:34,880 --> 00:06:40,700
not shown here that's attached to this

00:06:37,250 --> 00:06:44,090
link under this router r2 and let's say

00:06:40,700 --> 00:06:45,920
our this router r1 is connected to the

00:06:44,090 --> 00:06:47,900
outside world so this was your capital I

00:06:45,920 --> 00:06:50,840
internet and you have a device under

00:06:47,900 --> 00:06:52,880
test so we call it the device under test

00:06:50,840 --> 00:06:55,370
because it's a router that is going to

00:06:52,880 --> 00:06:58,970
be the emphasis on the focal point for

00:06:55,370 --> 00:07:02,960
our discussion going forward so what you

00:06:58,970 --> 00:07:05,330
have here is this this router over here

00:07:02,960 --> 00:07:09,800
is saying that it has the path to reach

00:07:05,330 --> 00:07:13,340
1300 0/24 so anybody in this subnet over

00:07:09,800 --> 00:07:14,840
here will be reachable will be able to

00:07:13,340 --> 00:07:16,310
reach the internet or will be reachable

00:07:14,840 --> 00:07:18,290
from the Internet through our one

00:07:16,310 --> 00:07:21,020
through the D UT through our to an out

00:07:18,290 --> 00:07:24,110
here and the expectation is that r2 has

00:07:21,020 --> 00:07:27,290
advertised this capability to this

00:07:24,110 --> 00:07:30,890
device under test and subsequently this

00:07:27,290 --> 00:07:34,730
router is told r1 that a path exists to

00:07:30,890 --> 00:07:40,910
give to get to this 13000 subnet that's

00:07:34,730 --> 00:07:42,260
the set up to cover something else okay

00:07:40,910 --> 00:07:44,660
so that's that's where we are now

00:07:42,260 --> 00:07:48,860
consider the case that for whatever

00:07:44,660 --> 00:07:52,850
reason this guy this duty while it took

00:07:48,860 --> 00:07:56,390
the router advertisement from here it

00:07:52,850 --> 00:07:59,570
failed to inject the route the hardware

00:07:56,390 --> 00:08:02,450
out for 1300 0/24 into the hardware

00:07:59,570 --> 00:08:04,220
table but the control plane that is

00:08:02,450 --> 00:08:09,100
oblivious to that fact to that failure

00:08:04,220 --> 00:08:11,780
has advertised this route up to r1 so r1

00:08:09,100 --> 00:08:14,150
amongst all the ways that it thinks it

00:08:11,780 --> 00:08:17,420
can get to that host that's attached

00:08:14,150 --> 00:08:19,430
down here is now saying oh I know the

00:08:17,420 --> 00:08:21,470
way I can to get to that host is through

00:08:19,430 --> 00:08:24,800
deity because I have seen an

00:08:21,470 --> 00:08:29,030
advertisement coming from below however

00:08:24,800 --> 00:08:30,920
I also have a default route and because

00:08:29,030 --> 00:08:33,890
in Hardware the route never got

00:08:30,920 --> 00:08:36,620
installed all packets that are destined

00:08:33,890 --> 00:08:38,719
towards that horse down here are hitting

00:08:36,620 --> 00:08:41,060
the deity not getting Hardware forwarded

00:08:38,719 --> 00:08:42,860
because the prefix doesn't exist and is

00:08:41,060 --> 00:08:46,720
being shunted down here and is going

00:08:42,860 --> 00:08:50,020
into a deep dark black hole

00:08:46,720 --> 00:08:54,460
and as the slide says happiness and joy

00:08:50,020 --> 00:08:56,410
is felt all around now just think about

00:08:54,460 --> 00:08:58,390
this for a second right a situation like

00:08:56,410 --> 00:09:02,290
this is actually highly highly

00:08:58,390 --> 00:09:04,060
problematic no network debugging tool is

00:09:02,290 --> 00:09:06,760
going to be able to tell you that you're

00:09:04,060 --> 00:09:09,250
in this condition what you're going to

00:09:06,760 --> 00:09:11,800
see is random sporadic outage because

00:09:09,250 --> 00:09:13,660
that particular prefix might get

00:09:11,800 --> 00:09:16,650
withdrawn at some point and might get

00:09:13,660 --> 00:09:18,880
reinserted and depending on the

00:09:16,650 --> 00:09:22,780
statistical setup of the table at that

00:09:18,880 --> 00:09:25,150
point it might succeed so suddenly you

00:09:22,780 --> 00:09:27,660
go oh I hit return and I can reach the

00:09:25,150 --> 00:09:30,580
internet again great problem solved

00:09:27,660 --> 00:09:32,470
while your neighbor is now going to

00:09:30,580 --> 00:09:36,550
start screaming because suddenly his or

00:09:32,470 --> 00:09:38,710
her host is unreachable this is a very

00:09:36,550 --> 00:09:41,650
big problem and the reason why this

00:09:38,710 --> 00:09:44,620
problem is is highlighted in networking

00:09:41,650 --> 00:09:47,890
is it's not it's no longer a box problem

00:09:44,620 --> 00:09:49,720
the problem is left from a box effect to

00:09:47,890 --> 00:09:52,360
a system-wide effect and it's very hard

00:09:49,720 --> 00:09:54,280
to nail down and and while we are on

00:09:52,360 --> 00:09:56,020
this topic let's understand the

00:09:54,280 --> 00:09:58,120
implication of solving it right so we'll

00:09:56,020 --> 00:09:59,560
clearly the rest of this talk is going

00:09:58,120 --> 00:10:01,540
to talk about some things that we are

00:09:59,560 --> 00:10:05,020
looking at about how to solve this

00:10:01,540 --> 00:10:07,330
particular problem but to solve this

00:10:05,020 --> 00:10:10,060
problem correctly not only would the

00:10:07,330 --> 00:10:12,700
hardware and the kernel indicate

00:10:10,060 --> 00:10:14,620
correctly to the to the routing protocol

00:10:12,700 --> 00:10:16,690
or the protocol daemons that there has

00:10:14,620 --> 00:10:18,570
been a failure the protocol demons

00:10:16,690 --> 00:10:21,580
themselves have to have some ability to

00:10:18,570 --> 00:10:23,170
go and withdraw routing withdraw the

00:10:21,580 --> 00:10:25,360
routes and tell the neighbors that this

00:10:23,170 --> 00:10:28,930
is no longer possible so if you look at

00:10:25,360 --> 00:10:30,850
the state-of-the-art today we we had

00:10:28,930 --> 00:10:33,400
cumulus use this thing call FRR which is

00:10:30,850 --> 00:10:35,560
a fork off of quagga which is I would

00:10:33,400 --> 00:10:38,650
argue the most commonly used routing

00:10:35,560 --> 00:10:42,040
suite on the Internet today and in that

00:10:38,650 --> 00:10:45,160
in in FRR what you see is that the route

00:10:42,040 --> 00:10:47,620
from the failed route from the D UT will

00:10:45,160 --> 00:10:49,839
be shown as an inactive route however

00:10:47,620 --> 00:10:51,820
our one will still see the advertisement

00:10:49,839 --> 00:10:54,520
and even if the colonel did everything

00:10:51,820 --> 00:10:55,960
absolutely perfectly today you would

00:10:54,520 --> 00:10:57,880
still end up in this deep dark hole and

00:10:55,960 --> 00:10:58,540
we are working on fixing that because it

00:10:57,880 --> 00:11:01,360
is a thing

00:10:58,540 --> 00:11:04,150
we believe is hugely influential to

00:11:01,360 --> 00:11:05,830
getting the networking model right and

00:11:04,150 --> 00:11:07,630
to the point where networking gets out

00:11:05,830 --> 00:11:09,970
of sort of the deep dark arts to

00:11:07,630 --> 00:11:13,870
something that just works and by that I

00:11:09,970 --> 00:11:15,520
mean infrastructure networking or the

00:11:13,870 --> 00:11:19,690
host networking at which Linux has

00:11:15,520 --> 00:11:21,670
excelled for many years now so how bad

00:11:19,690 --> 00:11:23,560
is this problem like how bad can this

00:11:21,670 --> 00:11:25,060
problem be it's clearly not a big deal

00:11:23,560 --> 00:11:28,720
because no one's talking about it so

00:11:25,060 --> 00:11:30,450
therefore it must be a tiny portion of

00:11:28,720 --> 00:11:32,800
the problem space that is known to man

00:11:30,450 --> 00:11:37,440
so if you look at this picture up here

00:11:32,800 --> 00:11:39,430
it's this is a hugely generalized

00:11:37,440 --> 00:11:41,740
implementation of what a networking

00:11:39,430 --> 00:11:44,530
device pipeline would look like right

00:11:41,740 --> 00:11:46,360
it's it's fairly straightforward and I

00:11:44,530 --> 00:11:48,760
as I look around the room I know that

00:11:46,360 --> 00:11:51,190
everybody in this room who's got an ASIC

00:11:48,760 --> 00:11:52,690
order or a pipeline architecture is

00:11:51,190 --> 00:11:54,190
looking at this picture and saying wow

00:11:52,690 --> 00:11:56,800
that's completely wrong because my

00:11:54,190 --> 00:11:59,290
pipeline looks different and you're all

00:11:56,800 --> 00:12:01,090
right however I think you can squint

00:11:59,290 --> 00:12:02,920
your eyes and say at a very high level

00:12:01,090 --> 00:12:04,810
they say these are the stages at which

00:12:02,920 --> 00:12:06,670
things are looked up there's an L to

00:12:04,810 --> 00:12:08,980
look up with any ackles that might be

00:12:06,670 --> 00:12:11,920
applicable there's an l-3 look up with a

00:12:08,980 --> 00:12:15,460
cuz that might be applicable once the l3

00:12:11,920 --> 00:12:17,470
has has given up a destination a way to

00:12:15,460 --> 00:12:20,140
get to its destination you'll have some

00:12:17,470 --> 00:12:21,670
egress circles and so on and so forth in

00:12:20,140 --> 00:12:24,700
between as part of the lookup you'll

00:12:21,670 --> 00:12:26,170
have something some kind of LPM engine

00:12:24,700 --> 00:12:27,610
that will give you the l3 lookup and

00:12:26,170 --> 00:12:30,070
you'll have some kind of a tee cam that

00:12:27,610 --> 00:12:33,670
will give you the Mac Villa and Vienna I

00:12:30,070 --> 00:12:36,640
look up for the L to look up so

00:12:33,670 --> 00:12:38,830
the point however is that in this

00:12:36,640 --> 00:12:41,170
picture there are five growth tables in

00:12:38,830 --> 00:12:44,440
reality it's actually almost always way

00:12:41,170 --> 00:12:46,780
more complex than that and each of those

00:12:44,440 --> 00:12:48,970
tables right now are subject to this

00:12:46,780 --> 00:12:53,410
class of problems and we'll talk about

00:12:48,970 --> 00:12:56,260
them one by one but this is basically

00:12:53,410 --> 00:12:59,650
the point that this is an issue that can

00:12:56,260 --> 00:13:02,680
cause failures in wide and amazing ways

00:12:59,650 --> 00:13:04,300
and almost all the innovation that you

00:13:02,680 --> 00:13:05,820
can do in this space is going to hurt

00:13:04,300 --> 00:13:08,860
you

00:13:05,820 --> 00:13:10,450
so what is the state of the art for

00:13:08,860 --> 00:13:11,050
resource management in the kernel today

00:13:10,450 --> 00:13:13,089
right

00:13:11,050 --> 00:13:17,070
so ICL's let's talk about how ICL's are

00:13:13,089 --> 00:13:19,209
implemented clearly networking operators

00:13:17,070 --> 00:13:21,850
definition of nacl an access control

00:13:19,209 --> 00:13:23,649
list is a little bit different from how

00:13:21,850 --> 00:13:25,480
people who are implementing networking

00:13:23,649 --> 00:13:28,300
on hosts virtual switches virtual

00:13:25,480 --> 00:13:31,510
routers container networking looks at it

00:13:28,300 --> 00:13:33,670
and if you think about today about it

00:13:31,510 --> 00:13:35,829
today you have net filter offload is not

00:13:33,670 --> 00:13:38,500
really very easy it's not there is no

00:13:35,829 --> 00:13:42,670
clean simple structured path that gives

00:13:38,500 --> 00:13:44,620
you deterministic offload behavior it's

00:13:42,670 --> 00:13:47,070
implemented we are this ndo set up DC

00:13:44,620 --> 00:13:50,649
and in fact it was talked about in

00:13:47,070 --> 00:13:53,200
Roma's talk yesterday so we will skip it

00:13:50,649 --> 00:13:55,540
for the most part but for a switch for

00:13:53,200 --> 00:13:57,670
for a device that is sitting on the

00:13:55,540 --> 00:13:59,579
first button and I want to actually

00:13:57,670 --> 00:14:02,140
maybe paint this picture a little bit

00:13:59,579 --> 00:14:04,240
when what I call a switch what an

00:14:02,140 --> 00:14:05,500
enterprise device would look like is

00:14:04,240 --> 00:14:10,570
switching somewhere in the order of

00:14:05,500 --> 00:14:12,730
let's say 1.8 terabytes and above at any

00:14:10,570 --> 00:14:15,430
given time there's no way you're going

00:14:12,730 --> 00:14:18,520
to be moving that kind of data to any

00:14:15,430 --> 00:14:19,839
CPU and be able to afford the CPU you

00:14:18,520 --> 00:14:23,200
would need to be able to handle the

00:14:19,839 --> 00:14:25,390
bandwidth right so effectively these are

00:14:23,200 --> 00:14:26,740
problem scenarios where either the

00:14:25,390 --> 00:14:28,899
hardware is going to do the right thing

00:14:26,740 --> 00:14:31,089
or it's going to completely mess up

00:14:28,899 --> 00:14:32,920
there is no way for the CPU to step in

00:14:31,089 --> 00:14:34,959
and say oh I know there's something

00:14:32,920 --> 00:14:38,070
wrong here but I'll be able to take the

00:14:34,959 --> 00:14:41,800
backpressure and deal with it over time

00:14:38,070 --> 00:14:43,660
so for for a switch of that class

00:14:41,800 --> 00:14:46,300
they're using the definition I just used

00:14:43,660 --> 00:14:48,160
you could say if there's a problem with

00:14:46,300 --> 00:14:50,290
the ACL table the ACL doesn't exist or

00:14:48,160 --> 00:14:53,470
whatever point all the packets to the

00:14:50,290 --> 00:14:55,570
CPU that's highly impractical because as

00:14:53,470 --> 00:14:57,490
I said the CPU that you need to be able

00:14:55,570 --> 00:15:02,410
to do 1.8 terabytes or

00:14:57,490 --> 00:15:05,320
or more actually 3.2 is kind of the de

00:15:02,410 --> 00:15:07,930
facto standard today and 6.4 is on its

00:15:05,320 --> 00:15:10,240
way so if you talk about being able to

00:15:07,930 --> 00:15:13,990
handle that kind of bandwidth in like

00:15:10,240 --> 00:15:16,240
the most the biggest x86 class CPU can

00:15:13,990 --> 00:15:17,740
find you're talking about basically a

00:15:16,240 --> 00:15:19,390
server that's more expensive than you

00:15:17,740 --> 00:15:22,149
can afford to put in place of that

00:15:19,390 --> 00:15:24,499
switch so if you consider that a problem

00:15:22,149 --> 00:15:26,269
then you say ok so part to the

00:15:24,499 --> 00:15:28,459
EU is really not an option and it's

00:15:26,269 --> 00:15:30,769
highly impractical you could say that I

00:15:28,459 --> 00:15:32,539
will only do like I will make sure that

00:15:30,769 --> 00:15:34,849
they see ELLs are perfectly implemented

00:15:32,539 --> 00:15:35,689
in software for the control plane yeah

00:15:34,849 --> 00:15:37,939
that's great

00:15:35,689 --> 00:15:39,739
so you'll protect the control plane but

00:15:37,939 --> 00:15:42,679
again there's a security hole because

00:15:39,739 --> 00:15:46,309
now imagine the case where you are a

00:15:42,679 --> 00:15:48,199
bank and you have certified ratios that

00:15:46,309 --> 00:15:50,659
need to be downloaded and installed such

00:15:48,199 --> 00:15:53,209
that you can get your whatever security

00:15:50,659 --> 00:15:55,939
clearances implemented and you cannot

00:15:53,209 --> 00:15:58,669
guarantee that all your ratios will be

00:15:55,939 --> 00:16:00,529
in Hardware you don't want to be the

00:15:58,669 --> 00:16:02,329
security officer over there signing that

00:16:00,529 --> 00:16:05,839
that statement and saying no no don't

00:16:02,329 --> 00:16:08,569
worry about it it's all fine the second

00:16:05,839 --> 00:16:11,749
class of such tables would be the Mak

00:16:08,569 --> 00:16:15,349
table or the FTB and FDB table is it's

00:16:11,749 --> 00:16:16,969
all it's as it's called in the kernel l2

00:16:15,349 --> 00:16:19,579
is a little bit more forgiving right the

00:16:16,969 --> 00:16:23,059
worst-case situation with the l2 table

00:16:19,579 --> 00:16:26,509
is you're going to just flood on a

00:16:23,059 --> 00:16:28,999
single host very annoying but probably

00:16:26,509 --> 00:16:30,319
not fatal if you have like we were

00:16:28,999 --> 00:16:31,909
talking about in the talk that jamal

00:16:30,319 --> 00:16:33,169
gave yesterday a hundred thousand one

00:16:31,909 --> 00:16:35,539
hundred fifty thousand max in your

00:16:33,169 --> 00:16:38,509
system flooding everywhere will bring

00:16:35,539 --> 00:16:41,049
your network to its knees and again not

00:16:38,509 --> 00:16:44,269
practical for for those applications

00:16:41,049 --> 00:16:46,699
almost all hardware has something called

00:16:44,269 --> 00:16:49,879
flood control so you could actually get

00:16:46,699 --> 00:16:51,799
by with this so l2 in the grand scheme

00:16:49,879 --> 00:16:55,629
of things the l2 table is probably the

00:16:51,799 --> 00:16:57,979
one that you will worry about the least

00:16:55,629 --> 00:16:59,839
another table that matters a lot from

00:16:57,979 --> 00:17:01,279
that picture before is the neighbor

00:16:59,839 --> 00:17:03,679
table or what's called the directly

00:17:01,279 --> 00:17:05,329
connected host table typically again not

00:17:03,679 --> 00:17:07,459
an issue because it's you know it's

00:17:05,329 --> 00:17:09,319
limited there is only so many neighbors

00:17:07,459 --> 00:17:13,909
you can directly connect to a given box

00:17:09,319 --> 00:17:16,669
so that typically is not an issue one of

00:17:13,909 --> 00:17:18,259
the biggest problems is the you know

00:17:16,669 --> 00:17:21,350
this is all three configuration this is

00:17:18,259 --> 00:17:23,689
not the LPM yet there are there are

00:17:21,350 --> 00:17:26,059
issues here potentially but they are

00:17:23,689 --> 00:17:28,279
almost all liveable with like things

00:17:26,059 --> 00:17:28,789
that you worry about are like is there a

00:17:28,279 --> 00:17:30,740
Verve

00:17:28,789 --> 00:17:32,690
is there a V excellent and why these

00:17:30,740 --> 00:17:34,250
things matter is because depending on

00:17:32,690 --> 00:17:36,830
the hardware that you're using

00:17:34,250 --> 00:17:38,780
when you create a word or you create a

00:17:36,830 --> 00:17:40,940
VX line interface and you're going to do

00:17:38,780 --> 00:17:43,190
routing over that VX line interface you

00:17:40,940 --> 00:17:45,710
might have to go reserve capabilities

00:17:43,190 --> 00:17:47,240
that were that are not obvious sometimes

00:17:45,710 --> 00:17:48,680
you have to go like if you're going to

00:17:47,240 --> 00:17:52,220
be excellent outing or if you're going

00:17:48,680 --> 00:17:54,230
to put an s VI router virtual interface

00:17:52,220 --> 00:17:56,150
on a bridge you're going to have to go

00:17:54,230 --> 00:17:58,220
reserve some capabilities for routing

00:17:56,150 --> 00:17:59,720
you're going to have to resolve some

00:17:58,220 --> 00:18:03,890
next-hop table you're going to have to

00:17:59,720 --> 00:18:06,710
reserve some l3 interface entries and so

00:18:03,890 --> 00:18:09,800
on and so forth and those things can

00:18:06,710 --> 00:18:12,680
fail and again the kernel thinks you are

00:18:09,800 --> 00:18:15,170
able to do routing over VX LAN network

00:18:12,680 --> 00:18:17,630
but what has happened is underneath you

00:18:15,170 --> 00:18:19,910
some critical resource has not been

00:18:17,630 --> 00:18:21,560
allocated and either you're going to be

00:18:19,910 --> 00:18:23,150
able to clean up correctly or you're

00:18:21,560 --> 00:18:26,690
going to fail the device creation in a

00:18:23,150 --> 00:18:29,210
very coherent and deterministic way but

00:18:26,690 --> 00:18:30,500
the worst case scenarios were that the

00:18:29,210 --> 00:18:32,180
kernels view of the world and the

00:18:30,500 --> 00:18:34,940
hardware's view of the world are not are

00:18:32,180 --> 00:18:44,120
no longer in sync and from here on out

00:18:34,940 --> 00:18:46,430
all results are going to be confusing so

00:18:44,120 --> 00:18:48,500
their tables tables everywhere how do we

00:18:46,430 --> 00:18:50,650
protect them all and by the way I am

00:18:48,500 --> 00:18:54,200
talking about this in the context of

00:18:50,650 --> 00:18:58,790
Hardware switches but as has been

00:18:54,200 --> 00:19:00,620
mentioned as was mentioned earlier one

00:18:58,790 --> 00:19:02,890
of the hottest topics at this conference

00:19:00,620 --> 00:19:05,900
and in Linux right now is smart Nix and

00:19:02,890 --> 00:19:09,890
a smart thing has nothing in my mind but

00:19:05,900 --> 00:19:13,220
a small switch with the one luxury that

00:19:09,890 --> 00:19:15,980
the CPU can come in and help however it

00:19:13,220 --> 00:19:17,480
doesn't get absorbed from this problem

00:19:15,980 --> 00:19:19,520
that we are talking about which is if

00:19:17,480 --> 00:19:22,100
there's a failure in the kernel to

00:19:19,520 --> 00:19:24,020
hardware interface the result of that

00:19:22,100 --> 00:19:26,450
failure has to be highly deterministic

00:19:24,020 --> 00:19:29,330
and there should be a well agreed to

00:19:26,450 --> 00:19:30,950
plan as to how to deal with it okay so

00:19:29,330 --> 00:19:33,410
what is needed is a consistent offload

00:19:30,950 --> 00:19:35,810
failure path to the user of protocol

00:19:33,410 --> 00:19:37,580
daemon a signaling from kernel to user

00:19:35,810 --> 00:19:40,850
space of the resource utilization and

00:19:37,580 --> 00:19:44,770
the capacity and a resource manager

00:19:40,850 --> 00:19:44,770
model or a resource management algorithm

00:19:46,050 --> 00:19:51,660
okay yeah so and and you know basically

00:19:49,230 --> 00:19:54,390
the notion of driver profiles and this

00:19:51,660 --> 00:19:57,450
actually is right now being pushed into

00:19:54,390 --> 00:19:59,310
the into switch def there's a bunch of

00:19:57,450 --> 00:20:00,810
work that Mellanox is doing to make this

00:19:59,310 --> 00:20:03,720
into something that becomes a de-facto

00:20:00,810 --> 00:20:05,250
standard and it's sort of a step is a

00:20:03,720 --> 00:20:07,440
big step in the right direction right

00:20:05,250 --> 00:20:08,970
it's it's what you have to do you have

00:20:07,440 --> 00:20:12,960
to come in and say here are sort of the

00:20:08,970 --> 00:20:16,050
general outlines of how given a highly

00:20:12,960 --> 00:20:18,720
configurable device I want to sort of

00:20:16,050 --> 00:20:20,670
set the bookends of how resources are

00:20:18,720 --> 00:20:23,190
carved out you have to start there

00:20:20,670 --> 00:20:25,890
anything less than that is when you're

00:20:23,190 --> 00:20:29,900
writing PhD theses to figure out how and

00:20:25,890 --> 00:20:29,900
how many of particular resource you have

00:20:30,920 --> 00:20:35,040
another simple solution is to do try

00:20:33,270 --> 00:20:36,300
abort and this actually was also try

00:20:35,040 --> 00:20:38,190
sort of there was a fledgling

00:20:36,300 --> 00:20:40,560
implementation in switch Devon has been

00:20:38,190 --> 00:20:42,900
withdrawn since which is I think it was

00:20:40,560 --> 00:20:45,480
called the two-step transaction model or

00:20:42,900 --> 00:20:47,910
so on and so forth where you do a try

00:20:45,480 --> 00:20:50,820
see if the hardware can actually support

00:20:47,910 --> 00:20:52,470
what you want and then come back and say

00:20:50,820 --> 00:20:54,710
oh sorry it didn't work we're going to

00:20:52,470 --> 00:20:58,590
abort this and go go ahead from there

00:20:54,710 --> 00:21:00,120
the problem with try bot is there are

00:20:58,590 --> 00:21:01,560
multiple problems at trial board but the

00:21:00,120 --> 00:21:03,360
single largest one is that you're still

00:21:01,560 --> 00:21:05,310
basically dealing with a very static

00:21:03,360 --> 00:21:06,540
model you cannot you don't have the

00:21:05,310 --> 00:21:08,790
ability and you don't have the time

00:21:06,540 --> 00:21:10,280
budget to be able to do a complex

00:21:08,790 --> 00:21:12,510
analysis so if you're looking at a

00:21:10,280 --> 00:21:14,280
relatively simple implementation you

00:21:12,510 --> 00:21:16,530
can't you cannot make it more

00:21:14,280 --> 00:21:18,360
sophisticated and and if you look at at

00:21:16,530 --> 00:21:20,820
least what's happening in in the switch

00:21:18,360 --> 00:21:22,680
class of devices now most of the tables

00:21:20,820 --> 00:21:25,170
are no longer tea camps are not hard

00:21:22,680 --> 00:21:27,870
limits they are all algorithmic which

00:21:25,170 --> 00:21:29,280
means the hash the efficiency of the

00:21:27,870 --> 00:21:32,190
hash and the occupancy of the hash

00:21:29,280 --> 00:21:34,020
function will change based on what input

00:21:32,190 --> 00:21:36,210
you're getting and so so there is a

00:21:34,020 --> 00:21:39,390
dynamic evaluation component that

00:21:36,210 --> 00:21:41,180
becomes more complicated and the trial

00:21:39,390 --> 00:21:43,950
board model will work actually will work

00:21:41,180 --> 00:21:46,620
amazingly as long as like I was saying

00:21:43,950 --> 00:21:48,930
earlier the whole stack implements it

00:21:46,620 --> 00:21:53,250
all the way from user space down to the

00:21:48,930 --> 00:21:55,290
last level everybody needs to know that

00:21:53,250 --> 00:21:58,410
the call that I'm about to make might

00:21:55,290 --> 00:21:59,340
fail and then you can move the abort all

00:21:58,410 --> 00:22:00,930
the way to the top of

00:21:59,340 --> 00:22:02,520
this is I mean very standard really

00:22:00,930 --> 00:22:04,170
anybody who's used any programming

00:22:02,520 --> 00:22:04,710
language with like a try fail or try

00:22:04,170 --> 00:22:06,480
abort

00:22:04,710 --> 00:22:08,400
you can't just implement it at the lower

00:22:06,480 --> 00:22:10,170
level and then leave the upper layer of

00:22:08,400 --> 00:22:12,540
oblivious you have to move it all the

00:22:10,170 --> 00:22:14,700
way up and new pipelines have to be

00:22:12,540 --> 00:22:22,220
built such that that communication goes

00:22:14,700 --> 00:22:24,810
all the way up to the top so so

00:22:22,220 --> 00:22:25,680
therefore the last portion of the stock

00:22:24,810 --> 00:22:27,720
we're going to talk about some

00:22:25,680 --> 00:22:31,980
experiments we did and and propose a

00:22:27,720 --> 00:22:33,870
solution that we hack together all of

00:22:31,980 --> 00:22:37,740
the work was done using the Mellanox

00:22:33,870 --> 00:22:39,000
driver in I guess a 414 kernel I'm

00:22:37,740 --> 00:22:42,750
looking for yeah I'm looking for a

00:22:39,000 --> 00:22:44,310
confirmation from David and and you know

00:22:42,750 --> 00:22:48,120
all the code is up there actually if you

00:22:44,310 --> 00:22:49,830
look at there's an interesting subunit

00:22:48,120 --> 00:22:52,520
on this slide which needs to be fixed

00:22:49,830 --> 00:22:55,050
which has actual code changes I here

00:22:52,520 --> 00:22:57,840
what was supposed to be there is a real

00:22:55,050 --> 00:22:59,280
github pointer and if you look at the

00:22:57,840 --> 00:23:01,590
paper the paper has the references

00:22:59,280 --> 00:23:05,150
there's a github repo everything that we

00:23:01,590 --> 00:23:07,920
are talking about today is is available

00:23:05,150 --> 00:23:09,510
you can try this experiment at home I

00:23:07,920 --> 00:23:11,930
should say that these experiments were

00:23:09,510 --> 00:23:14,280
conducted by professional stuntmen and

00:23:11,930 --> 00:23:16,800
and there's there is a risk to trying

00:23:14,280 --> 00:23:18,360
this at home but so if you look at this

00:23:16,800 --> 00:23:20,910
picture and I don't know if this is

00:23:18,360 --> 00:23:26,130
readable it it's a lot more readable and

00:23:20,910 --> 00:23:27,960
on my screen what this is saying is

00:23:26,130 --> 00:23:29,370
there is a user space tool that's

00:23:27,960 --> 00:23:32,370
creating the routing information base

00:23:29,370 --> 00:23:33,930
the RHIB and if you look at the path

00:23:32,370 --> 00:23:36,750
this is user learned this is Colonel

00:23:33,930 --> 00:23:38,280
this is router router device there are

00:23:36,750 --> 00:23:40,650
three loops that you need to worry about

00:23:38,280 --> 00:23:42,480
right there's a loop that user space is

00:23:40,650 --> 00:23:44,420
pushing the ribbon to the FIB which is

00:23:42,480 --> 00:23:47,280
the kernels forwarding information base

00:23:44,420 --> 00:23:49,610
there's a second loop where that data is

00:23:47,280 --> 00:23:52,740
being pushed into a device driver and

00:23:49,610 --> 00:23:54,150
effectively into the the third loop is

00:23:52,740 --> 00:23:56,010
the device driver pushing it into the

00:23:54,150 --> 00:24:02,100
asic right so and if you think of them

00:23:56,010 --> 00:24:04,200
as three sort of server loops then it's

00:24:02,100 --> 00:24:05,610
easy to characterize the problem we are

00:24:04,200 --> 00:24:08,160
trying to solve and how to measure

00:24:05,610 --> 00:24:09,890
whether a given problem solves or given

00:24:08,160 --> 00:24:12,929
solution solves the problem or not

00:24:09,890 --> 00:24:15,000
so like I said the first one is user

00:24:12,929 --> 00:24:16,799
space kernel interaction doop the second

00:24:15,000 --> 00:24:18,660
is the kernel - device driver loop and

00:24:16,799 --> 00:24:22,080
the third is device driver to the actual

00:24:18,660 --> 00:24:25,080
ASIC what we did is we simulated number

00:24:22,080 --> 00:24:26,700
three by rather than actually going and

00:24:25,080 --> 00:24:28,140
doing the complex calculations that

00:24:26,700 --> 00:24:31,320
would be needed for the Mellanox

00:24:28,140 --> 00:24:34,679
hardware we just said that we were going

00:24:31,320 --> 00:24:35,940
to put a simple you sleep and that at

00:24:34,679 --> 00:24:38,130
the end of you sleep we are going to

00:24:35,940 --> 00:24:40,080
give you in a binary form a certain

00:24:38,130 --> 00:24:42,000
number of resources have been consumed

00:24:40,080 --> 00:24:46,770
by hardware that's it

00:24:42,000 --> 00:24:48,840
that's the test we made another change

00:24:46,770 --> 00:24:50,850
that we put a synchronous check of the

00:24:48,840 --> 00:24:54,120
query result in the FIB notifier path so

00:24:50,850 --> 00:24:57,150
in the device driver the ipv4 event

00:24:54,120 --> 00:25:01,700
handler we put in an additional check

00:24:57,150 --> 00:25:06,570
that says when you're about to go accept

00:25:01,700 --> 00:25:08,820
the defib notifier update either I have

00:25:06,570 --> 00:25:11,039
space or I don't have space I know that

00:25:08,820 --> 00:25:13,799
check is now in line and it's a very

00:25:11,039 --> 00:25:16,770
fast check whereas jasper is going to

00:25:13,799 --> 00:25:19,200
tell me a very simple counter check is

00:25:16,770 --> 00:25:20,880
not fast actually but let's assume it is

00:25:19,200 --> 00:25:22,860
for the sake of argument and since it's

00:25:20,880 --> 00:25:24,330
a device to everything you don't pay

00:25:22,860 --> 00:25:26,880
that price unless you're using that

00:25:24,330 --> 00:25:28,500
particular device in the path but if you

00:25:26,880 --> 00:25:30,539
have the device driver be able to do

00:25:28,500 --> 00:25:34,230
that synchronously so all that's going

00:25:30,539 --> 00:25:36,990
to happen is when entry let's say it's

00:25:34,230 --> 00:25:40,350
an IP route ad that gets that pushes are

00:25:36,990 --> 00:25:42,539
out into the FIB the fit will invoke the

00:25:40,350 --> 00:25:45,179
notifier the device driver that has the

00:25:42,539 --> 00:25:47,429
notifier receiver if you will is going

00:25:45,179 --> 00:25:50,280
to now go and say do I have the space to

00:25:47,429 --> 00:25:53,220
accept this update if the answer is no

00:25:50,280 --> 00:25:56,789
I'm going to fail it and this part will

00:25:53,220 --> 00:25:58,799
go fail fail right away or I'm going to

00:25:56,789 --> 00:26:03,090
say I have the space and I'll go ahead

00:25:58,799 --> 00:26:04,470
and accept it asynchronous to that or

00:26:03,090 --> 00:26:08,700
synchronous actually we have both

00:26:04,470 --> 00:26:11,370
examples we will say hardware has going

00:26:08,700 --> 00:26:14,130
has informed the device driver that the

00:26:11,370 --> 00:26:16,320
updates that you had staged for me have

00:26:14,130 --> 00:26:19,049
been consumed by me and I have so much

00:26:16,320 --> 00:26:21,910
or so many resources free for you to

00:26:19,049 --> 00:26:26,770
consume going forward that sort of the

00:26:21,910 --> 00:26:28,660
going forward model so we looked at two

00:26:26,770 --> 00:26:30,580
implementations and actually we looked

00:26:28,660 --> 00:26:32,200
at many implementations or only to that

00:26:30,580 --> 00:26:34,870
two or three we are going to talk about

00:26:32,200 --> 00:26:36,550
explicitly so the first one is lockstep

00:26:34,870 --> 00:26:39,580
right this is the easiest one to do

00:26:36,550 --> 00:26:42,220
every call is going to go through an in

00:26:39,580 --> 00:26:44,290
a lockstep manner tell me whether or not

00:26:42,220 --> 00:26:47,050
that entry could have been accepted in

00:26:44,290 --> 00:26:49,470
hardware or not there is no you know

00:26:47,050 --> 00:26:51,610
this is how you establish baselines and

00:26:49,470 --> 00:26:53,050
it's a good way to write a paper right

00:26:51,610 --> 00:26:55,180
you basically want to know what your

00:26:53,050 --> 00:26:57,190
absolute worst-case operations are going

00:26:55,180 --> 00:26:59,410
to be so the slope is executed

00:26:57,190 --> 00:27:00,910
explicitly in series right so you get

00:26:59,410 --> 00:27:05,380
this update to get this order you get

00:27:00,910 --> 00:27:07,360
this update we then considered a second

00:27:05,380 --> 00:27:09,670
or a second model which we call the

00:27:07,360 --> 00:27:12,490
synchronous prefetch and effectively it

00:27:09,670 --> 00:27:15,880
takes the lockstep model and says this

00:27:12,490 --> 00:27:17,770
check instead of being one by one we're

00:27:15,880 --> 00:27:19,360
going to every time you ask us we're

00:27:17,770 --> 00:27:21,340
going to also ask for five more

00:27:19,360 --> 00:27:24,100
resources from hardware so we have a

00:27:21,340 --> 00:27:26,650
little bit of skid so that the next five

00:27:24,100 --> 00:27:29,410
or the next ten or the next 1000 it's a

00:27:26,650 --> 00:27:31,480
configurable number will not have to go

00:27:29,410 --> 00:27:33,580
to Hardware to find out whether Hardware

00:27:31,480 --> 00:27:34,990
would be able to pass or fail it so you

00:27:33,580 --> 00:27:38,890
have a little bit of a Headroom right

00:27:34,990 --> 00:27:41,080
here your your advertising over n number

00:27:38,890 --> 00:27:43,870
of calls and the latency is amortized as

00:27:41,080 --> 00:27:46,470
well and the last solution we looked at

00:27:43,870 --> 00:27:49,000
was a credit-based prefetch model which

00:27:46,470 --> 00:27:50,590
we will tell you will hide latency

00:27:49,000 --> 00:27:52,000
checks the capacity and rate a

00:27:50,590 --> 00:27:53,920
synchronous update of availability

00:27:52,000 --> 00:27:57,220
matches capacity and rate and needs an

00:27:53,920 --> 00:28:00,370
atomic ad from the async thread so let

00:27:57,220 --> 00:28:03,400
me say that maybe again slower in in

00:28:00,370 --> 00:28:06,070
this model what we do is when the fib

00:28:03,400 --> 00:28:08,050
goes to the device driver the device

00:28:06,070 --> 00:28:11,710
driver will tell you whether or not it

00:28:08,050 --> 00:28:14,020
has resources but its resource is not a

00:28:11,710 --> 00:28:16,720
single resource nor is it a bucket or

00:28:14,020 --> 00:28:18,280
nor nor is it a list it's a bucket of

00:28:16,720 --> 00:28:21,400
resources so you have some you have

00:28:18,280 --> 00:28:22,930
basically a pre fetched

00:28:21,400 --> 00:28:25,660
if you consider the previous example a

00:28:22,930 --> 00:28:27,610
prefetch set of capacity and you're

00:28:25,660 --> 00:28:29,800
going to consume from the prefetch set

00:28:27,610 --> 00:28:32,620
of capacity and this capacity will be

00:28:29,800 --> 00:28:33,700
refreshed asynchronously by a separate

00:28:32,620 --> 00:28:36,310
kernel thread

00:28:33,700 --> 00:28:37,990
which is reflecting the hardware doing

00:28:36,310 --> 00:28:40,630
its calculations and saying okay I think

00:28:37,990 --> 00:28:44,590
I can take anymore routes going forward

00:28:40,630 --> 00:28:48,850
and what this allows you to do is that

00:28:44,590 --> 00:28:51,750
it allows you to match both the rate and

00:28:48,850 --> 00:28:55,600
the capacity of the hardware so by

00:28:51,750 --> 00:28:58,000
shrinking or growing the bucket size you

00:28:55,600 --> 00:29:03,450
can say that I will not take updates at

00:28:58,000 --> 00:29:06,130
a greater than X rate and the total

00:29:03,450 --> 00:29:07,690
summation of all the bucket sizes so

00:29:06,130 --> 00:29:11,620
let's say let's take a real example

00:29:07,690 --> 00:29:14,410
right let's say you said I have a 4k

00:29:11,620 --> 00:29:18,400
entry hardware table and I'm trying to

00:29:14,410 --> 00:29:21,610
update 4k and what we said is that the

00:29:18,400 --> 00:29:25,000
in the device driver the bucket size is

00:29:21,610 --> 00:29:28,300
a thousand entries and the update is at

00:29:25,000 --> 00:29:30,100
a hundred so you can take basically you

00:29:28,300 --> 00:29:33,520
can take bursts of hundred entries at a

00:29:30,100 --> 00:29:36,940
time you can gather up to 1000 entries

00:29:33,520 --> 00:29:38,920
before you know that I cannot take one

00:29:36,940 --> 00:29:41,530
more entry without asking hardware that

00:29:38,920 --> 00:29:44,320
it has the capacity or not and so on and

00:29:41,530 --> 00:29:47,410
so forth people will recognize this this

00:29:44,320 --> 00:29:49,900
solution as something that a lot of high

00:29:47,410 --> 00:29:53,220
speed computer buses do as a way to make

00:29:49,900 --> 00:29:55,660
sure the two of the two ends are

00:29:53,220 --> 00:29:58,150
continuing to talk to each other but are

00:29:55,660 --> 00:30:07,540
not able to able to overwhelm the other

00:29:58,150 --> 00:30:09,310
end of the wire so and we ran a bunch of

00:30:07,540 --> 00:30:13,570
experiments and this is basically what

00:30:09,310 --> 00:30:16,210
the experiment is so you recognize this

00:30:13,570 --> 00:30:20,140
portion of the picture from what we did

00:30:16,210 --> 00:30:22,900
previously and fundamentally what we are

00:30:20,140 --> 00:30:24,610
doing is we are measuring once this

00:30:22,900 --> 00:30:27,310
happened so we are taking this outer

00:30:24,610 --> 00:30:29,200
path we are causing r2 to break which

00:30:27,310 --> 00:30:31,690
means the all the routes have to be

00:30:29,200 --> 00:30:34,510
updated such that it's now going to

00:30:31,690 --> 00:30:37,990
swing to the our three path and traffic

00:30:34,510 --> 00:30:40,090
from r1 to r4 or to the host behind r4

00:30:37,990 --> 00:30:42,820
is going to be ready is going to be

00:30:40,090 --> 00:30:44,500
restored right so the reason maybe I

00:30:42,820 --> 00:30:46,720
should say a few more words before that

00:30:44,500 --> 00:30:47,140
what we tried to do was if we were to

00:30:46,720 --> 00:30:48,970
enjoy

00:30:47,140 --> 00:30:50,290
this into the current path if you were

00:30:48,970 --> 00:30:52,720
to inject this mechanism into the

00:30:50,290 --> 00:30:55,540
current path of updating hardware

00:30:52,720 --> 00:30:58,300
resources what is the impact and what do

00:30:55,540 --> 00:30:59,800
you get out of it so we wanted to do

00:30:58,300 --> 00:31:01,870
some measurements to see what that means

00:30:59,800 --> 00:31:06,610
and this is what it is so what we did

00:31:01,870 --> 00:31:09,130
was repeat then we put in traffic that

00:31:06,610 --> 00:31:11,760
was coming from above our one aim for

00:31:09,130 --> 00:31:14,290
this host 1300 one behind our four and

00:31:11,760 --> 00:31:16,270
traffic was running through this path

00:31:14,290 --> 00:31:19,150
who are two and when we broke the link

00:31:16,270 --> 00:31:21,190
we caused a full route install on our

00:31:19,150 --> 00:31:25,240
three and we measured what that time was

00:31:21,190 --> 00:31:27,160
so that we see what happens so and I

00:31:25,240 --> 00:31:29,050
noticed that in the slides I forgot to

00:31:27,160 --> 00:31:31,240
add one important number so what we

00:31:29,050 --> 00:31:35,950
measured was that a single write to

00:31:31,240 --> 00:31:37,690
hardware was about 55 microseconds if I

00:31:35,950 --> 00:31:41,230
or 60 microseconds I think what we used

00:31:37,690 --> 00:31:42,730
here we measured that it's rough I'm

00:31:41,230 --> 00:31:45,070
sure some Mellanox person will tell me

00:31:42,730 --> 00:31:46,800
it's way lower than that but for this

00:31:45,070 --> 00:31:50,350
experiment let's say that's the number

00:31:46,800 --> 00:31:52,390
so it's 60 microseconds to get her out

00:31:50,350 --> 00:31:54,880
all the way from user space into

00:31:52,390 --> 00:31:58,180
hardware and if you remember we said we

00:31:54,880 --> 00:31:59,650
put in a sleep to indicate when hardware

00:31:58,180 --> 00:32:01,120
can indicate that a particular

00:31:59,650 --> 00:32:04,630
transaction aimed towards the hardware

00:32:01,120 --> 00:32:07,000
has been has actually landed or not so

00:32:04,630 --> 00:32:10,720
the lockstep experiment we basically

00:32:07,000 --> 00:32:13,900
said that oh okay so we're going to send

00:32:10,720 --> 00:32:16,810
a 10000 route so there are 10,000 routes

00:32:13,900 --> 00:32:19,150
the last of those routes is what

00:32:16,810 --> 00:32:22,720
triggers the path to become available so

00:32:19,150 --> 00:32:25,720
we know that if if the host here can

00:32:22,720 --> 00:32:28,150
reach a host here the 10,000th

00:32:25,720 --> 00:32:30,720
route has made it into hardware and

00:32:28,150 --> 00:32:34,180
hardware can now forward packets right

00:32:30,720 --> 00:32:36,400
so far so good so what you see is that

00:32:34,180 --> 00:32:38,500
if you have 10,000 routes and you do

00:32:36,400 --> 00:32:40,330
lockstep such that you can guarantee

00:32:38,500 --> 00:32:41,890
that hardware will never accidentally

00:32:40,330 --> 00:32:44,830
tell you that it could do something that

00:32:41,890 --> 00:32:46,210
it couldn't your latency is 600

00:32:44,830 --> 00:32:47,800
milliseconds this is relatively easy

00:32:46,210 --> 00:32:48,570
right you multiply those two numbers and

00:32:47,800 --> 00:32:52,600
you get that number

00:32:48,570 --> 00:32:54,790
straightforward we see that at 600

00:32:52,600 --> 00:32:56,320
milliseconds latency the actual outage

00:32:54,790 --> 00:32:57,250
because that's the thing that really

00:32:56,320 --> 00:33:00,940
matters

00:32:57,250 --> 00:33:04,450
about 1.1 seconds that's that's how long

00:33:00,940 --> 00:33:07,540
it took between a horse that was able to

00:33:04,450 --> 00:33:09,490
reach this guy through this path losing

00:33:07,540 --> 00:33:11,650
this link switching over getting all the

00:33:09,490 --> 00:33:15,190
10,000 routes installed and restoring

00:33:11,650 --> 00:33:17,860
traffic then he looked at the credit

00:33:15,190 --> 00:33:19,390
based scheme we saw that because the

00:33:17,860 --> 00:33:21,210
credit base scheme doesn't do the

00:33:19,390 --> 00:33:24,090
lockstep it doesn't do the 1 1 to 1

00:33:21,210 --> 00:33:26,890
there are a couple of setup and teardown

00:33:24,090 --> 00:33:29,580
events that make this number marginally

00:33:26,890 --> 00:33:32,170
better right it's about 13% better so

00:33:29,580 --> 00:33:36,130
there is the law of physics right we are

00:33:32,170 --> 00:33:37,750
doing 10,000 of those but clearly the 60

00:33:36,130 --> 00:33:39,910
microseconds has some setup and teardown

00:33:37,750 --> 00:33:41,980
overhead which is getting amortized in

00:33:39,910 --> 00:33:44,190
the credit based scheme so it it comes

00:33:41,980 --> 00:33:47,590
down to four hundred eighty microseconds

00:33:44,190 --> 00:33:50,830
millisecond sorry and the hardware

00:33:47,590 --> 00:33:54,370
latency is still 35 an hour outages 0.81

00:33:50,830 --> 00:33:54,760
so clearly an improvement but it is what

00:33:54,370 --> 00:33:56,320
it is

00:33:54,760 --> 00:33:57,730
but here's the thing that is really

00:33:56,320 --> 00:34:01,030
interesting so then we said since this

00:33:57,730 --> 00:34:02,980
is just asleep what if we said we are

00:34:01,030 --> 00:34:07,270
running a super sophisticated algorithm

00:34:02,980 --> 00:34:08,800
and it's going to take 350 microseconds

00:34:07,270 --> 00:34:11,260
to be able to come back with a

00:34:08,800 --> 00:34:14,169
definitive answer of do I have capacity

00:34:11,260 --> 00:34:16,000
or do I not have capacity you see the

00:34:14,169 --> 00:34:18,280
credit based scheme starts to pull away

00:34:16,000 --> 00:34:20,800
because at that point the numbers look

00:34:18,280 --> 00:34:24,129
almost identical right whereas the

00:34:20,800 --> 00:34:26,679
lockstep answer becomes way bigger

00:34:24,129 --> 00:34:28,690
because clearly you're waiting for the

00:34:26,679 --> 00:34:33,690
time to update to be able to move

00:34:28,690 --> 00:34:33,690
forward so nothing nothing dramatic here

00:34:34,470 --> 00:34:39,899
but just an observation to prove the

00:34:38,110 --> 00:34:41,950
point that we were trying to make

00:34:39,899 --> 00:34:44,649
clearly one of the things that is

00:34:41,950 --> 00:34:47,500
obvious here is that if you make this

00:34:44,649 --> 00:34:49,929
have this update also have some kind of

00:34:47,500 --> 00:34:53,530
batching capability then we can hide

00:34:49,929 --> 00:34:55,419
this 55 into into 10,000 number and

00:34:53,530 --> 00:34:58,780
we'll get a significant speed up there

00:34:55,419 --> 00:35:02,590
as well and I think that was the very

00:34:58,780 --> 00:35:04,420
last oh okay so conclusions right I mean

00:35:02,590 --> 00:35:07,510
resource management is non-negotiable

00:35:04,420 --> 00:35:09,370
for user experience we hopefully in the

00:35:07,510 --> 00:35:11,500
in the paper the paper does a much

00:35:09,370 --> 00:35:15,160
better job than what I did with the

00:35:11,500 --> 00:35:17,260
presentation here but it makes it clear

00:35:15,160 --> 00:35:19,900
that there are lots of issues with us

00:35:17,260 --> 00:35:23,800
not having a clear and consistent answer

00:35:19,900 --> 00:35:25,420
for resource management and we assert

00:35:23,800 --> 00:35:27,580
that the credit based skill scheme will

00:35:25,420 --> 00:35:29,740
give you way better overall experience

00:35:27,580 --> 00:35:32,560
it will hide the hardware latency is

00:35:29,740 --> 00:35:34,360
better and it fits in with fairly

00:35:32,560 --> 00:35:36,160
minimal changes the current solution

00:35:34,360 --> 00:35:38,230
that exists the current stack that

00:35:36,160 --> 00:35:41,980
exists can adopt this in a fairly

00:35:38,230 --> 00:35:43,510
straightforward way and has almost no

00:35:41,980 --> 00:35:44,980
footprint in the pure software path

00:35:43,510 --> 00:35:48,370
because it's all hidden behind the

00:35:44,980 --> 00:35:50,320
notifier set and if the same principle

00:35:48,370 --> 00:35:50,860
was applied to the right path the total

00:35:50,320 --> 00:35:53,110
latency of

00:35:50,860 --> 00:35:55,870
these updates can be significantly

00:35:53,110 --> 00:35:59,620
reduced so that's all I had I have three

00:35:55,870 --> 00:36:14,470
minutes and 22 seconds if anybody has

00:35:59,620 --> 00:36:15,880
any questions okay to three or comment I

00:36:14,470 --> 00:36:18,550
just have a comment

00:36:15,880 --> 00:36:21,220
shut up out the credit based scheme an

00:36:18,550 --> 00:36:22,810
idea that I've seen before that I think

00:36:21,220 --> 00:36:25,480
it'd be really useful for hardware

00:36:22,810 --> 00:36:28,690
vendors to implement is where you get a

00:36:25,480 --> 00:36:31,030
key with this when you get a response

00:36:28,690 --> 00:36:33,970
and you get these credits sure it comes

00:36:31,030 --> 00:36:36,970
with a key and only the the entity using

00:36:33,970 --> 00:36:40,480
that key can then get those credits and

00:36:36,970 --> 00:36:42,220
use them yeah it makes sure that they

00:36:40,480 --> 00:36:45,460
remain there for you and there's no

00:36:42,220 --> 00:36:46,600
override or something so not only do I

00:36:45,460 --> 00:36:48,640
agree with you I actually have some

00:36:46,600 --> 00:36:51,700
personal experience with this we used to

00:36:48,640 --> 00:36:53,170
many many years ago and and Dave might

00:36:51,700 --> 00:36:55,120
actually remember this as well last year

00:36:53,170 --> 00:36:58,180
I used to use a similar scheme for its

00:36:55,120 --> 00:37:00,730
Numa bus on the back end and and we had

00:36:58,180 --> 00:37:05,290
a very famous problem where I think it

00:37:00,730 --> 00:37:08,770
was at shell or Exxon Mobil Exxon where

00:37:05,290 --> 00:37:13,480
on a 2,000 node system we were losing

00:37:08,770 --> 00:37:16,900
credits and it was a seven or eight year

00:37:13,480 --> 00:37:18,430
bug that stayed on forever because no

00:37:16,900 --> 00:37:19,690
one could find them it's like where the

00:37:18,430 --> 00:37:20,380
hell did they go and we don't know who

00:37:19,690 --> 00:37:21,640
consumed

00:37:20,380 --> 00:37:23,500
and we don't know who what the source

00:37:21,640 --> 00:37:27,460
and the destinations were right so very

00:37:23,500 --> 00:37:29,230
good point and clearly if like

00:37:27,460 --> 00:37:31,630
everything else if we can make this work

00:37:29,230 --> 00:37:33,940
well and and cumulus is working on some

00:37:31,630 --> 00:37:36,369
implementations here if we can make this

00:37:33,940 --> 00:37:39,220
work well and make it upstream modeled

00:37:36,369 --> 00:37:41,859
correctly in software then I would very

00:37:39,220 --> 00:37:43,839
shortly expect to see hardware will be

00:37:41,859 --> 00:37:46,509
hardware vendors will be able to enhance

00:37:43,839 --> 00:37:48,430
that with having some kind of cookie iki

00:37:46,509 --> 00:37:50,950
whatever jamal likes the word cookie so

00:37:48,430 --> 00:37:53,170
we will call it a cookie for now we all

00:37:50,950 --> 00:38:02,049
love cookies exactly I thought J I had a

00:37:53,170 --> 00:38:03,700
question over there so you would mention

00:38:02,049 --> 00:38:05,289
briefly the smart Nix which are

00:38:03,700 --> 00:38:07,900
essentially switches inside the card

00:38:05,289 --> 00:38:10,420
this is the hardware capabilities of the

00:38:07,900 --> 00:38:11,920
switches on the cards affect any of

00:38:10,420 --> 00:38:14,500
these kind of results so if they're more

00:38:11,920 --> 00:38:18,569
or less capable does it change how well

00:38:14,500 --> 00:38:21,400
or how poorly this thing works it's like

00:38:18,569 --> 00:38:22,900
if you consider ACLs as an example I

00:38:21,400 --> 00:38:24,849
think the same problem applies right

00:38:22,900 --> 00:38:26,380
let's say you have two containers take

00:38:24,849 --> 00:38:28,690
take an example you have a two container

00:38:26,380 --> 00:38:30,700
or multi container Network and you're

00:38:28,690 --> 00:38:33,009
running these containers as credit card

00:38:30,700 --> 00:38:35,559
transaction endpoints and you have a

00:38:33,009 --> 00:38:38,349
hard ACL requirement that says at 100

00:38:35,559 --> 00:38:40,509
gig speed I'm using Mac VLAN or Mac

00:38:38,349 --> 00:38:43,480
meetup or one of those or IP VLAN and

00:38:40,509 --> 00:38:46,480
I'm sending traffic straight out from

00:38:43,480 --> 00:38:49,390
from the switch up into the host and I

00:38:46,480 --> 00:38:50,950
need my ACL to be in place otherwise I'm

00:38:49,390 --> 00:38:52,569
out of whatever fips-compliant or

00:38:50,950 --> 00:38:56,170
whatever other compliance scheme that

00:38:52,569 --> 00:38:58,390
you have and like oh my Hardware could

00:38:56,170 --> 00:39:00,009
silently just drop installing the ACL I

00:38:58,390 --> 00:39:02,289
mean that's a real problem right that's

00:39:00,009 --> 00:39:03,880
that will happen with a smart NIC the

00:39:02,289 --> 00:39:05,859
way it is currently set up there is no

00:39:03,880 --> 00:39:07,420
there is no feedback loop that is

00:39:05,859 --> 00:39:10,299
complete now vendors have implemented

00:39:07,420 --> 00:39:11,740
specific solutions right so so vendors

00:39:10,299 --> 00:39:15,009
have been clever but there isn't a

00:39:11,740 --> 00:39:15,849
consistent Linux answer for that can I

00:39:15,009 --> 00:39:18,609
comment on that

00:39:15,849 --> 00:39:20,410
when using the cookie the TC ndo thing

00:39:18,609 --> 00:39:24,369
drops packets

00:39:20,410 --> 00:39:27,759
you can't comment on the it's break time

00:39:24,369 --> 00:39:29,230
so yeah TC n diode drops packets that's

00:39:27,759 --> 00:39:31,509
what you no no I didn't say drops

00:39:29,230 --> 00:39:34,089
packets up the message there is no

00:39:31,509 --> 00:39:35,710
structured response up right there is

00:39:34,089 --> 00:39:38,740
like the color

00:39:35,710 --> 00:39:40,420
how are you installing it in a way that

00:39:38,740 --> 00:39:43,630
you know that this particular thing

00:39:40,420 --> 00:39:45,400
would not get offloaded completely let's

00:39:43,630 --> 00:39:48,309
say you ran out of a resource how do you

00:39:45,400 --> 00:39:51,609
how do you have that message if you ask

00:39:48,309 --> 00:39:54,039
for a flaw to be offloaded and there is

00:39:51,609 --> 00:39:56,109
no in the driver rejects you think the

00:39:54,039 --> 00:39:58,119
driver won't reject and you will never

00:39:56,109 --> 00:40:00,069
know who's asking for the floor to be

00:39:58,119 --> 00:40:05,670
offloaded as I guess questioning the

00:40:00,069 --> 00:40:08,890
user using a TC add skip software or

00:40:05,670 --> 00:40:10,480
yeah there's a flat which I want you to

00:40:08,890 --> 00:40:12,819
offload this if you have a very specific

00:40:10,480 --> 00:40:15,250
thing and you get it you know or

00:40:12,819 --> 00:40:17,289
something yes you have the user space

00:40:15,250 --> 00:40:20,769
capability to go handle it but let's say

00:40:17,289 --> 00:40:23,490
it was not that clear right the tables

00:40:20,769 --> 00:40:26,650
are in multiple places the tables in

00:40:23,490 --> 00:40:28,900
case you have all this next hop and a

00:40:26,650 --> 00:40:31,119
route ad it implies several tables not

00:40:28,900 --> 00:40:33,359
one and and by the way I mean TC the

00:40:31,119 --> 00:40:35,769
first step in that question is is TC the

00:40:33,359 --> 00:40:37,480
only way or the structure where the

00:40:35,769 --> 00:40:39,940
service suggested where that people

00:40:37,480 --> 00:40:42,579
implementations and Linux if the answer

00:40:39,940 --> 00:40:44,380
is no then that right there is SN driver

00:40:42,579 --> 00:40:46,869
API right now that's a driver API yeah

00:40:44,380 --> 00:40:50,140
so okay maybe you can take this offline

00:40:46,869 --> 00:40:53,500
yeah there's any other questions in the

00:40:50,140 --> 00:41:00,309
minus one minutes that we have yeah no

00:40:53,500 --> 00:41:03,880
pressure so so the pre allocation of

00:41:00,309 --> 00:41:05,890
credits approach isn't it in some use

00:41:03,880 --> 00:41:08,490
cases wasting memory because you pre

00:41:05,890 --> 00:41:10,569
allocate and you end up not using it so

00:41:08,490 --> 00:41:12,069
that's up to you so the way we

00:41:10,569 --> 00:41:13,809
implemented it and if you look at the

00:41:12,069 --> 00:41:16,180
code you'll see we gave you parameters

00:41:13,809 --> 00:41:18,970
I'd it gives you the the queue depth and

00:41:16,180 --> 00:41:21,430
the credit sort of batch set if you will

00:41:18,970 --> 00:41:25,299
so you decide if you keep both of those

00:41:21,430 --> 00:41:28,569
shallow you will ask more often but you

00:41:25,299 --> 00:41:31,690
will not waste space if you keep it deep

00:41:28,569 --> 00:41:33,670
you will ask less often but the risk

00:41:31,690 --> 00:41:34,250
exists that you will fail a transaction

00:41:33,670 --> 00:41:36,890
because

00:41:34,250 --> 00:41:41,230
you had 800 entries but you asked for

00:41:36,890 --> 00:41:44,270
1,000 so that's not going to pass I

00:41:41,230 --> 00:41:45,800
think it comes down to you want a high

00:41:44,270 --> 00:41:48,590
degree of confidence that the hardware

00:41:45,800 --> 00:41:50,300
program is gonna succeed because once

00:41:48,590 --> 00:41:52,640
it's done asynchronously you lose that

00:41:50,300 --> 00:41:54,830
feedback to the user so if something

00:41:52,640 --> 00:41:56,359
goes wrong they're not going to know so

00:41:54,830 --> 00:41:58,820
that's that's the whole point of you're

00:41:56,359 --> 00:42:16,060
doing these reservations just so that

00:41:58,820 --> 00:42:37,880
you have it's not going to fail so we

00:42:16,060 --> 00:42:41,240
are now in the break I was saying you

00:42:37,880 --> 00:42:43,760
know keeping it shallow is the key but

00:42:41,240 --> 00:42:46,070
at the same time most Hardware you know

00:42:43,760 --> 00:42:49,700
the way it was implemented it allows you

00:42:46,070 --> 00:42:54,050
for both upfront reservation as well as

00:42:49,700 --> 00:42:57,800
you know resolve as you as you use kind

00:42:54,050 --> 00:42:59,270
of yeah so I mean this like so in my

00:42:57,800 --> 00:43:00,920
past life building mix right the

00:42:59,270 --> 00:43:02,869
hardware typically doesn't care the only

00:43:00,920 --> 00:43:05,690
problem with hardware is if you have if

00:43:02,869 --> 00:43:08,359
your hardware allocation is slow versus

00:43:05,690 --> 00:43:10,220
fast so for example changing buffering

00:43:08,359 --> 00:43:13,580
typically requires you to restart your

00:43:10,220 --> 00:43:15,170
DMA rings which is very problematic so

00:43:13,580 --> 00:43:17,510
doing that dynamically is very hard

00:43:15,170 --> 00:43:20,900
however if you are talking about a CL

00:43:17,510 --> 00:43:22,760
allocation or LPM entries or FDB entries

00:43:20,900 --> 00:43:25,609
you can change them on the fly and and

00:43:22,760 --> 00:43:27,980
what this is really saying is what is

00:43:25,609 --> 00:43:30,500
being proposed here is that you don't

00:43:27,980 --> 00:43:33,260
you take your driver resources and your

00:43:30,500 --> 00:43:36,410
profiles and you make them bookends and

00:43:33,260 --> 00:43:39,170
then how you actually use them actively

00:43:36,410 --> 00:43:41,359
as a driver decision this credit return

00:43:39,170 --> 00:43:44,480
is exactly what the driver is doing so

00:43:41,359 --> 00:43:47,260
you decide right whether you think more

00:43:44,480 --> 00:43:49,450
v4 more v6 entries are coming or

00:43:47,260 --> 00:43:51,790
for entries are coming and change how

00:43:49,450 --> 00:43:53,710
many you think you can take you can go

00:43:51,790 --> 00:43:58,030
tell userspace that they can safely send

00:43:53,710 --> 00:44:00,460
you in the next batch and I think we'll

00:43:58,030 --> 00:44:06,700
cut the questions here thank you

00:44:00,460 --> 00:44:09,090
listen even opposed to Wi-Fi walking

00:44:06,700 --> 00:44:09,090

YouTube URL: https://www.youtube.com/watch?v=FhmhY48hsI4


