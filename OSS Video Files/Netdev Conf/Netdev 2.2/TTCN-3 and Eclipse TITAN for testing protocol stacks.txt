Title: TTCN-3 and Eclipse TITAN for testing protocol stacks
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: Harald Welte
Friday November 09th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?welte-ttcn3-talk
Captions: 
	00:00:01,850 --> 00:00:08,610
okay welcome everyone to my presentation

00:00:05,520 --> 00:00:11,760
about a entirely different topic which

00:00:08,610 --> 00:00:13,560
is well something that starts with an

00:00:11,760 --> 00:00:14,370
acronym so it must be coming from the

00:00:13,560 --> 00:00:18,690
telecom world

00:00:14,370 --> 00:00:20,910
it's called TTC n3 and Eclipse Titan for

00:00:18,690 --> 00:00:24,210
testing protocol stacks it's a topic

00:00:20,910 --> 00:00:27,960
that I have been investigating for quite

00:00:24,210 --> 00:00:29,930
some time and not so much in the context

00:00:27,960 --> 00:00:32,669
of the protocols you find in the kernel

00:00:29,930 --> 00:00:35,460
as I'm not really working much on the

00:00:32,669 --> 00:00:37,949
kernel anymore but in terms of protocols

00:00:35,460 --> 00:00:40,609
that I implemented user space in in many

00:00:37,949 --> 00:00:42,629
other areas of communication systems and

00:00:40,609 --> 00:00:44,309
I'd like to share some of these

00:00:42,629 --> 00:00:46,379
experiences and introduce this language

00:00:44,309 --> 00:00:50,579
to you because I think it really has a

00:00:46,379 --> 00:00:53,370
very large potential of helping in in

00:00:50,579 --> 00:00:54,989
testing of protocol stacks so well why

00:00:53,370 --> 00:00:57,510
do we need testing I think that's sort

00:00:54,989 --> 00:01:00,120
of obvious but well some people want to

00:00:57,510 --> 00:01:03,299
check conformance to specifications they

00:01:00,120 --> 00:01:05,820
want to ensure interoperability they

00:01:03,299 --> 00:01:08,070
want to look at network security or

00:01:05,820 --> 00:01:11,520
ensure that this regression testing of

00:01:08,070 --> 00:01:14,909
course and performance testing last but

00:01:11,520 --> 00:01:17,490
not least now of course there is no

00:01:14,909 --> 00:01:19,350
single standard methodology or language

00:01:17,490 --> 00:01:21,960
or approach or tool and that people use

00:01:19,350 --> 00:01:23,759
for testing you can test your

00:01:21,960 --> 00:01:25,740
implementation against another copy of

00:01:23,759 --> 00:01:28,770
your implementation that only works for

00:01:25,740 --> 00:01:30,420
symmetric protocols which well in the IP

00:01:28,770 --> 00:01:32,159
world we have many of them in the world

00:01:30,420 --> 00:01:35,850
that I spent my time we don't have so

00:01:32,159 --> 00:01:37,109
many of them and it doesn't cover a lot

00:01:35,850 --> 00:01:38,640
of the problems of course because if

00:01:37,109 --> 00:01:40,049
you're back in your implementation in

00:01:38,640 --> 00:01:41,729
your test against your implementation on

00:01:40,049 --> 00:01:43,200
the other end they both are buggy and

00:01:41,729 --> 00:01:46,020
they talk to each other but still you're

00:01:43,200 --> 00:01:47,999
not compatible with the spec you can do

00:01:46,020 --> 00:01:50,039
like manual testing and look at the wire

00:01:47,999 --> 00:01:51,630
sir shark dissection that's often very

00:01:50,039 --> 00:01:53,670
misleading because Wireshark is

00:01:51,630 --> 00:01:56,280
extremely tolerant and in Bakke of

00:01:53,670 --> 00:01:57,899
course as well but way too tolerant in

00:01:56,280 --> 00:02:00,329
terms of what it decodes as valid

00:01:57,899 --> 00:02:02,670
messages in many protocol t sectors so

00:02:00,329 --> 00:02:05,189
it shows you that it's fine but in

00:02:02,670 --> 00:02:08,369
reality it's it's not so that's also not

00:02:05,189 --> 00:02:10,500
a very useful approach people come up

00:02:08,369 --> 00:02:12,900
with custom implementations of their

00:02:10,500 --> 00:02:15,050
respective protocols for example in in

00:02:12,900 --> 00:02:18,110
in Python using scape II or other frame

00:02:15,050 --> 00:02:20,450
works or in Erlang because it is an

00:02:18,110 --> 00:02:22,390
exceptionally nice binary encoded

00:02:20,450 --> 00:02:25,340
decoder how you can express a binary

00:02:22,390 --> 00:02:27,470
messages in there or other language is

00:02:25,340 --> 00:02:30,500
of course NS specific tools like packet

00:02:27,470 --> 00:02:32,960
rail which all have their upsides and

00:02:30,500 --> 00:02:37,190
downsides and for sure they have use

00:02:32,960 --> 00:02:39,590
cases but anyway I'd like to share

00:02:37,190 --> 00:02:42,110
something with you that's different from

00:02:39,590 --> 00:02:44,870
all of these tools so during the past

00:02:42,110 --> 00:02:47,150
couple of years after I didn't have time

00:02:44,870 --> 00:02:49,310
for netfilter anymore I implemented tons

00:02:47,150 --> 00:02:52,160
of telecom protocols and and stacks of

00:02:49,310 --> 00:02:54,100
those protocols at Ozma comm and I was

00:02:52,160 --> 00:02:57,440
looking for better tools to help

00:02:54,100 --> 00:02:59,600
automatic testing and the interest here

00:02:57,440 --> 00:03:01,520
is primarily functional testing it's not

00:02:59,600 --> 00:03:03,380
so much performance testing in our case

00:03:01,520 --> 00:03:05,750
because well this is signaling protocols

00:03:03,380 --> 00:03:07,280
and and the kind of systems we look at

00:03:05,750 --> 00:03:09,230
we're not talking about millions of

00:03:07,280 --> 00:03:11,120
signaling message per second or

00:03:09,230 --> 00:03:13,040
something it's rather low signaling

00:03:11,120 --> 00:03:15,770
rates so performance testing was not a

00:03:13,040 --> 00:03:17,360
focus and well an ideal testing - what

00:03:15,770 --> 00:03:19,370
would it do it would allow you to to

00:03:17,360 --> 00:03:21,470
have a very productive and expressive

00:03:19,370 --> 00:03:23,870
way to describe your protocol encoding

00:03:21,470 --> 00:03:26,390
and and other parameters of the protocol

00:03:23,870 --> 00:03:28,459
and it would allow extremely convenient

00:03:26,390 --> 00:03:30,140
pattern matching of incoming messages

00:03:28,459 --> 00:03:32,239
because the common problem I mean

00:03:30,140 --> 00:03:34,250
sending a certain hard coded message is

00:03:32,239 --> 00:03:36,980
easy but then matching on incoming

00:03:34,250 --> 00:03:40,250
messages based on certain patterns or

00:03:36,980 --> 00:03:42,050
rules it becomes more difficult and of

00:03:40,250 --> 00:03:43,820
course it has to allow exchange of

00:03:42,050 --> 00:03:46,459
messages asynchronously with the

00:03:43,820 --> 00:03:48,380
implementation under test and also have

00:03:46,459 --> 00:03:50,360
probably other features and I stumbled

00:03:48,380 --> 00:03:53,860
on something called TTC and three

00:03:50,360 --> 00:03:59,510
occasionally while reading telecom specs

00:03:53,860 --> 00:04:01,520
and I investigated and I found out it's

00:03:59,510 --> 00:04:04,300
a domain-specific language that's just

00:04:01,520 --> 00:04:07,040
made for protocol conformance tests

00:04:04,300 --> 00:04:08,840
history actually goes back to 83 so it's

00:04:07,040 --> 00:04:12,080
as old as all of the other protocols I

00:04:08,840 --> 00:04:14,269
look into but the TTC and three as like

00:04:12,080 --> 00:04:16,790
with three as a version is actually from

00:04:14,269 --> 00:04:18,190
2000 so it's not all that old and used

00:04:16,790 --> 00:04:23,570
extensively in the telecom sector

00:04:18,190 --> 00:04:25,340
there's not so much open source like

00:04:23,570 --> 00:04:27,020
code that you could find and of course

00:04:25,340 --> 00:04:29,000
not on Stack Overflow or or other

00:04:27,020 --> 00:04:31,400
websites I mean it's basically

00:04:29,000 --> 00:04:34,160
rather niche language but you can find

00:04:31,400 --> 00:04:36,560
lots of papers we're developers at

00:04:34,160 --> 00:04:39,350
Ericsson nokia and other large Telecom

00:04:36,560 --> 00:04:41,060
vendors describe how much and they have

00:04:39,350 --> 00:04:42,800
actually been implementing in this

00:04:41,060 --> 00:04:46,570
programming language in order to test

00:04:42,800 --> 00:04:48,800
their various implementations and Etsy

00:04:46,570 --> 00:04:50,330
the European telecommunication

00:04:48,800 --> 00:04:53,060
standardization Institute has actually

00:04:50,330 --> 00:04:55,790
published abstract test suits written in

00:04:53,060 --> 00:04:58,820
TTC and three four protocols like ipv6

00:04:55,790 --> 00:05:01,640
sip diameter for electronic passports

00:04:58,820 --> 00:05:05,900
digital mobile radio excuse my typos I'm

00:05:01,640 --> 00:05:09,980
always bad with typos 6lowpan and other

00:05:05,900 --> 00:05:12,290
standards bodies for other focus areas

00:05:09,980 --> 00:05:16,280
the industry's published tests use for a

00:05:12,290 --> 00:05:19,790
coop MQTT most which is automotive or

00:05:16,280 --> 00:05:22,040
AUTOSAR is also an automotive protocol

00:05:19,790 --> 00:05:24,110
one of the problems has been it's nice

00:05:22,040 --> 00:05:26,510
that you have a test suit for

00:05:24,110 --> 00:05:29,180
conformance testing if you don't have a

00:05:26,510 --> 00:05:33,560
compiler to actually compile the test

00:05:29,180 --> 00:05:37,370
suit into anything and until 2015 there

00:05:33,560 --> 00:05:39,590
will no free software tools actually a

00:05:37,370 --> 00:05:41,690
free software compilers out there and so

00:05:39,590 --> 00:05:46,760
it was rather uninteresting like a

00:05:41,690 --> 00:05:50,630
theoretic exercise now enter eclipse

00:05:46,760 --> 00:05:54,169
Titan after TTC and three was specified

00:05:50,630 --> 00:05:56,390
in 2000 Ericsson has internally

00:05:54,169 --> 00:05:58,340
developed the TTC and three tool train

00:05:56,390 --> 00:06:00,229
not only the compiler but centered

00:05:58,340 --> 00:06:02,660
around the compiler and this is what

00:06:00,229 --> 00:06:04,640
they used internally for testing of all

00:06:02,660 --> 00:06:07,040
kinds of products like their STS ends

00:06:04,640 --> 00:06:10,310
and their BSC S&M SCS and all the other

00:06:07,040 --> 00:06:12,380
telecom network elements it was

00:06:10,310 --> 00:06:14,900
developed as proprietary software with

00:06:12,380 --> 00:06:17,330
commercial licenses available to third

00:06:14,900 --> 00:06:18,890
parties has grown into something like

00:06:17,330 --> 00:06:22,479
three hundred thousand lines of Java and

00:06:18,890 --> 00:06:27,229
1.6 million lines of C++ so it's rather

00:06:22,479 --> 00:06:29,419
complex product and in 2015 for whatever

00:06:27,229 --> 00:06:32,630
reason I don't know the details they

00:06:29,419 --> 00:06:34,479
decided to release this as an eclipse

00:06:32,630 --> 00:06:37,700
project and the eclipse public license

00:06:34,479 --> 00:06:40,220
and ever since it's a normal Eclipse

00:06:37,700 --> 00:06:42,510
member project all the source code is

00:06:40,220 --> 00:06:45,630
maintained in in engage

00:06:42,510 --> 00:06:47,490
they have forums they extremely

00:06:45,630 --> 00:06:50,430
responsive you can see all the the

00:06:47,490 --> 00:06:52,170
commit history the developers are are so

00:06:50,430 --> 00:06:53,880
basically it's not abandoned it's not a

00:06:52,170 --> 00:06:55,320
code dump to the community and they

00:06:53,880 --> 00:06:56,910
disappeared but they continue to

00:06:55,320 --> 00:06:58,170
maintain that code base is just that

00:06:56,910 --> 00:07:00,240
they now do that as an open-source

00:06:58,170 --> 00:07:02,820
project under the umbrella of umbrella

00:07:00,240 --> 00:07:05,640
of the Eclipse Foundation and it's not

00:07:02,820 --> 00:07:09,270
just a compiler itself but also tons of

00:07:05,640 --> 00:07:13,050
documentation like PDF manuals to to you

00:07:09,270 --> 00:07:15,120
know to kill people with including also

00:07:13,050 --> 00:07:17,060
source code for many protocol modules

00:07:15,120 --> 00:07:19,350
which we look at at some other slides

00:07:17,060 --> 00:07:21,390
because the compiler of course ok is

00:07:19,350 --> 00:07:22,830
nice but then what do I compile I don't

00:07:21,390 --> 00:07:24,540
want to rewrite everything from scratch

00:07:22,830 --> 00:07:27,270
so they also released a lot of the

00:07:24,540 --> 00:07:30,330
protocol implementations at least

00:07:27,270 --> 00:07:32,370
encoding and decoding and so on there's

00:07:30,330 --> 00:07:34,860
also an eclipse ide which i don't use

00:07:32,370 --> 00:07:37,140
because well it's it's a GUI tool and I

00:07:34,860 --> 00:07:39,780
don't really like which rules but the

00:07:37,140 --> 00:07:42,690
compiler itself is just a command-line

00:07:39,780 --> 00:07:44,270
tool and you use make files just like

00:07:42,690 --> 00:07:47,220
you use the C compiler so it's really

00:07:44,270 --> 00:07:49,110
you don't need that but there is also a

00:07:47,220 --> 00:07:51,510
log viewer and visualization and all

00:07:49,110 --> 00:07:55,800
kinds of things that some people tend to

00:07:51,510 --> 00:07:58,470
like yeah and last but not least in

00:07:55,800 --> 00:08:00,270
Debian and Ubuntu it's already part of

00:07:58,470 --> 00:08:02,010
the standard distribution so you just

00:08:00,270 --> 00:08:04,940
need an app get install eclipse Titan

00:08:02,010 --> 00:08:07,020
and there it is so no no weird

00:08:04,940 --> 00:08:08,550
installation or build from source or

00:08:07,020 --> 00:08:10,830
something like that so ok we finally

00:08:08,550 --> 00:08:13,320
have some free software so how does the

00:08:10,830 --> 00:08:15,900
workflow look like so we have a human

00:08:13,320 --> 00:08:17,940
developer that writes some code it but

00:08:15,900 --> 00:08:20,100
the human developer writes is called an

00:08:17,940 --> 00:08:22,740
ATS it's in let's the source codes the

00:08:20,100 --> 00:08:24,600
abstract tests you how they call it and

00:08:22,740 --> 00:08:27,000
then you call the CGC and three compiler

00:08:24,600 --> 00:08:29,790
that transforms that into C++ or source

00:08:27,000 --> 00:08:31,860
code and then you can link in some other

00:08:29,790 --> 00:08:33,960
C++ code of course if you have some

00:08:31,860 --> 00:08:36,120
native functions let's say some checksum

00:08:33,960 --> 00:08:37,680
computations or some whatever utility

00:08:36,120 --> 00:08:39,360
libraries that you'd like to use because

00:08:37,680 --> 00:08:42,330
you already have them you can link them

00:08:39,360 --> 00:08:44,660
in and compile them together with the

00:08:42,330 --> 00:08:47,430
other C++ that was generated using

00:08:44,660 --> 00:08:50,670
regular new G plus plus and you get the

00:08:47,430 --> 00:08:55,470
binary test suit which they call an ETS

00:08:50,670 --> 00:08:56,460
and executable test suit so these are

00:08:55,470 --> 00:08:58,260
basically the time

00:08:56,460 --> 00:09:01,230
the use in the process actually it's

00:08:58,260 --> 00:09:03,540
even more nice because it includes a

00:09:01,230 --> 00:09:05,250
make file generator so actually can even

00:09:03,540 --> 00:09:07,020
generate the make file and then you run

00:09:05,250 --> 00:09:08,880
the make file to compile both your C++

00:09:07,020 --> 00:09:10,770
entity TC and three and you get the

00:09:08,880 --> 00:09:15,810
final executable program and that's it

00:09:10,770 --> 00:09:17,430
so it's really rather easy now let's

00:09:15,810 --> 00:09:19,140
look a little bit at that language and

00:09:17,430 --> 00:09:23,010
why I think it's interesting in this

00:09:19,140 --> 00:09:24,720
context well one thing - it's obviously

00:09:23,010 --> 00:09:27,390
from this slide but let me just add that

00:09:24,720 --> 00:09:29,250
still before a proceeding you get binary

00:09:27,390 --> 00:09:31,950
executable code it's native code there's

00:09:29,250 --> 00:09:33,930
no virtual machine there is no you know

00:09:31,950 --> 00:09:35,010
no interpretation or scripting or

00:09:33,930 --> 00:09:38,100
something like that it's a real native

00:09:35,010 --> 00:09:41,279
executable that then you execute acute

00:09:38,100 --> 00:09:42,779
and s actually some people also use it

00:09:41,279 --> 00:09:44,640
for performance testing of course it

00:09:42,779 --> 00:09:47,130
depends on the scalability requirements

00:09:44,640 --> 00:09:50,399
but it's it's not like a script or a VM

00:09:47,130 --> 00:09:52,260
or something like that okay so the

00:09:50,399 --> 00:09:54,420
language itself has a very comprehensive

00:09:52,260 --> 00:09:57,300
type system which is important in order

00:09:54,420 --> 00:09:59,279
to be able to express protocols and

00:09:57,300 --> 00:10:00,779
headers and so on it has parametric

00:09:59,279 --> 00:10:01,170
templates which we'll look into in

00:10:00,779 --> 00:10:03,420
detail

00:10:01,170 --> 00:10:06,930
lots of existing encoders and decoders

00:10:03,420 --> 00:10:12,390
that help you to productively specify

00:10:06,930 --> 00:10:14,550
the the protocol has a very nice logging

00:10:12,390 --> 00:10:16,080
framework that will automatically do a

00:10:14,550 --> 00:10:17,930
lot of things so you don't even need to

00:10:16,080 --> 00:10:20,910
write a lot of log statements yourself

00:10:17,930 --> 00:10:22,260
you have interesting program control

00:10:20,910 --> 00:10:25,800
features that I haven't seen in other

00:10:22,260 --> 00:10:28,830
languages so far as a built-in notion of

00:10:25,800 --> 00:10:31,020
test cases so it's not like a how can I

00:10:28,830 --> 00:10:33,120
say a runtime library or some other

00:10:31,020 --> 00:10:34,950
abstraction in the programming language

00:10:33,120 --> 00:10:36,660
that then enables you to provide test

00:10:34,950 --> 00:10:38,550
cases but actually the language itself

00:10:36,660 --> 00:10:40,680
has a notion of what's the test suit and

00:10:38,550 --> 00:10:42,870
what's the test case and what are

00:10:40,680 --> 00:10:44,959
verdicts as results of test case and so

00:10:42,870 --> 00:10:48,480
on and then you have this executor and

00:10:44,959 --> 00:10:51,390
runtime part of it that gets linked into

00:10:48,480 --> 00:10:54,810
your executable to run what they call

00:10:51,390 --> 00:10:56,880
parallel test components so it's not a

00:10:54,810 --> 00:10:58,410
single threaded single process

00:10:56,880 --> 00:11:00,570
necessarily but you can have multiple

00:10:58,410 --> 00:11:02,459
parallel processes or even you can have

00:11:00,570 --> 00:11:05,100
multiple different machines because

00:11:02,459 --> 00:11:06,810
where these guys are coming from an

00:11:05,100 --> 00:11:08,160
implementation under test is not a

00:11:06,810 --> 00:11:10,590
software program that they want

00:11:08,160 --> 00:11:12,630
it's like a hardware rack full of you

00:11:10,590 --> 00:11:15,570
know some proprietary hardware and and

00:11:12,630 --> 00:11:17,400
embedded software in firmware so if you

00:11:15,570 --> 00:11:19,200
want to test that you need like ten

00:11:17,400 --> 00:11:21,300
boxes surrounding all the different

00:11:19,200 --> 00:11:23,610
interfaces of that proprietary hardware

00:11:21,300 --> 00:11:25,770
and you want to launch all the the

00:11:23,610 --> 00:11:27,420
individual parallel test components on

00:11:25,770 --> 00:11:29,640
those ten boxes surrounding your

00:11:27,420 --> 00:11:31,170
implementation under test and you want

00:11:29,640 --> 00:11:32,730
to aggregate the results and get that

00:11:31,170 --> 00:11:34,320
back and all of this is already built

00:11:32,730 --> 00:11:35,970
into this runtime so you don't need to

00:11:34,320 --> 00:11:39,060
worry about you know synchronizing and

00:11:35,970 --> 00:11:39,480
gathering results and all that kind of

00:11:39,060 --> 00:11:43,650
stuff

00:11:39,480 --> 00:11:46,080
okay so let's look a bit about the types

00:11:43,650 --> 00:11:48,360
I mean of course there's integers

00:11:46,080 --> 00:11:50,460
there's float this boolean very basic

00:11:48,360 --> 00:11:51,660
things this but then it already starts

00:11:50,460 --> 00:11:54,570
to get interesting you have something

00:11:51,660 --> 00:11:56,460
called bit strings which are arbitrary

00:11:54,570 --> 00:11:58,020
links so it doesn't don't need to be

00:11:56,460 --> 00:11:59,760
like octave aligned or something you

00:11:58,020 --> 00:12:01,260
have octave strings you also have hex

00:11:59,760 --> 00:12:03,030
strings which can have something like

00:12:01,260 --> 00:12:05,820
five nibbles so it doesn't have to fill

00:12:03,030 --> 00:12:07,890
the entire bytes you have character

00:12:05,820 --> 00:12:10,590
strings a character string is actually

00:12:07,890 --> 00:12:12,540
defined as an eye a five alphabet so you

00:12:10,590 --> 00:12:14,820
cannot have non ASCII characters in

00:12:12,540 --> 00:12:16,320
there and the the checking will make

00:12:14,820 --> 00:12:19,380
sure that you also have Universal

00:12:16,320 --> 00:12:21,570
strings you can build structure types

00:12:19,380 --> 00:12:24,540
from those basic types and kind of

00:12:21,570 --> 00:12:26,970
course nest those structure types and

00:12:24,540 --> 00:12:28,950
you have we look at all of this in in a

00:12:26,970 --> 00:12:32,250
bit more detail and you also have a

00:12:28,950 --> 00:12:35,280
native verdict type which is quite fun

00:12:32,250 --> 00:12:36,660
because well of course well what's the

00:12:35,280 --> 00:12:38,790
verdict verdict is the result of your

00:12:36,660 --> 00:12:40,620
test it can be passed it can be failed

00:12:38,790 --> 00:12:42,060
it can be inconclusive or it can be

00:12:40,620 --> 00:12:45,540
error because some runtime error

00:12:42,060 --> 00:12:47,640
happened but this type has a special

00:12:45,540 --> 00:12:50,430
property that he can only deteriorate so

00:12:47,640 --> 00:12:52,200
if you ever set it to error or fail and

00:12:50,430 --> 00:12:54,000
you have later statements in your code

00:12:52,200 --> 00:12:55,950
that would set it to pass it just

00:12:54,000 --> 00:13:00,180
wouldn't wouldn't happen so basically

00:12:55,950 --> 00:13:02,760
it's very easy to write code without

00:13:00,180 --> 00:13:04,620
having to have proper return paths in

00:13:02,760 --> 00:13:06,300
all the error cases and so on all you do

00:13:04,620 --> 00:13:08,730
is basically oh something happened that

00:13:06,300 --> 00:13:10,410
made this test fail okay now I set my

00:13:08,730 --> 00:13:12,450
verdict to fail and I don't have to care

00:13:10,410 --> 00:13:15,030
what other code gets executed after that

00:13:12,450 --> 00:13:18,030
it can never make the verdict any better

00:13:15,030 --> 00:13:20,589
than the fail that it already is helps a

00:13:18,030 --> 00:13:23,139
lot in in in productivity again

00:13:20,589 --> 00:13:25,589
so let's look at the structure types I

00:13:23,139 --> 00:13:31,929
mean yeah it's just like a struct in C

00:13:25,589 --> 00:13:34,449
no interesting shading there going on on

00:13:31,929 --> 00:13:37,149
the under projector it's just like a see

00:13:34,449 --> 00:13:39,429
structure in the end though you have

00:13:37,149 --> 00:13:40,719
things for example like optional members

00:13:39,429 --> 00:13:44,979
so you can say there's an optional

00:13:40,719 --> 00:13:46,719
member in this structure and then an

00:13:44,979 --> 00:13:48,039
optional member can of course be present

00:13:46,719 --> 00:13:49,809
or not and all the question is of course

00:13:48,039 --> 00:13:51,699
well how does this map to a binary

00:13:49,809 --> 00:13:53,769
encoding I mean it's much more abstract

00:13:51,699 --> 00:13:56,459
and in a C struct so this doesn't

00:13:53,769 --> 00:13:58,839
specify a memory layout of some

00:13:56,459 --> 00:14:00,729
representation but it's an an abstract

00:13:58,839 --> 00:14:02,799
representation of a structure data type

00:14:00,729 --> 00:14:02,979
and of course you can nest them and so

00:14:02,799 --> 00:14:05,349
on

00:14:02,979 --> 00:14:07,499
you also have unions the nice part about

00:14:05,349 --> 00:14:10,179
the unions is well you have a built-in

00:14:07,499 --> 00:14:12,129
capability of identifying which of the

00:14:10,179 --> 00:14:14,379
choices inside the Union were taken

00:14:12,129 --> 00:14:15,999
there is a built-in function called is

00:14:14,379 --> 00:14:18,069
chosen so you can say well is this

00:14:15,999 --> 00:14:20,229
member chosen in that Union and you

00:14:18,069 --> 00:14:22,059
don't have to have an explicit member to

00:14:20,229 --> 00:14:23,649
express something like that like you

00:14:22,059 --> 00:14:26,049
would have in in C you would start with

00:14:23,649 --> 00:14:29,319
a struct that has a member that says

00:14:26,049 --> 00:14:32,889
which of your member unions is selected

00:14:29,319 --> 00:14:37,449
in the end now the important concept to

00:14:32,889 --> 00:14:40,989
note is until you have assigned a value

00:14:37,449 --> 00:14:44,109
to a given variable or a member of a

00:14:40,989 --> 00:14:47,109
structure type its unbound and unbound

00:14:44,109 --> 00:14:50,649
is a special value or a special yeah

00:14:47,109 --> 00:14:51,970
concept and whenever you need a value

00:14:50,649 --> 00:14:54,819
for example you want to transmit a

00:14:51,970 --> 00:14:57,429
packet and of course you need to know

00:14:54,819 --> 00:14:59,249
exactly which bit at which position and

00:14:57,429 --> 00:15:01,569
which by it needs to be transmitted and

00:14:59,249 --> 00:15:03,309
everything must be bound you cannot have

00:15:01,569 --> 00:15:04,899
like in a C structures an uninitialized

00:15:03,309 --> 00:15:06,189
memory of course you don't want to

00:15:04,899 --> 00:15:08,649
transmit something that hasn't been

00:15:06,189 --> 00:15:12,999
properly initialized and the the runtime

00:15:08,649 --> 00:15:15,789
of this takes care that whenever a value

00:15:12,999 --> 00:15:18,219
is expected and you have any unbound

00:15:15,789 --> 00:15:19,929
members in your data type or any unbound

00:15:18,219 --> 00:15:21,939
variables there will be a runtime error

00:15:19,929 --> 00:15:23,409
basically you cannot transmit it so you

00:15:21,939 --> 00:15:25,539
cannot use this in this context because

00:15:23,409 --> 00:15:27,699
it has not been fully specified there

00:15:25,539 --> 00:15:30,579
are some members or some variables that

00:15:27,699 --> 00:15:32,439
are not assigned values and in the case

00:15:30,579 --> 00:15:34,270
of optional fields you basically have to

00:15:32,439 --> 00:15:36,520
say omit so you have to assign

00:15:34,270 --> 00:15:38,260
in this particular optional structure

00:15:36,520 --> 00:15:39,910
members or let's say we're talking about

00:15:38,260 --> 00:15:42,610
this here is a field one member

00:15:39,910 --> 00:15:46,870
basically have to say my message dot

00:15:42,610 --> 00:15:48,550
field 1 equals omit to say that this is

00:15:46,870 --> 00:15:50,050
actually not to be transmitted as an

00:15:48,550 --> 00:15:53,170
optional member that you don't want in

00:15:50,050 --> 00:15:55,180
this context so this helps you to catch

00:15:53,170 --> 00:15:57,400
all kinds of bugs about not properly

00:15:55,180 --> 00:15:59,620
initially a sing it and now it starts to

00:15:57,400 --> 00:16:03,280
become interesting because you can

00:15:59,620 --> 00:16:05,230
basically say well I can subtype I can

00:16:03,280 --> 00:16:08,770
create my own types that are specified

00:16:05,230 --> 00:16:10,750
as subtypes of some other types so I can

00:16:08,770 --> 00:16:13,990
specify it as an integer that can only

00:16:10,750 --> 00:16:16,300
have a range from 1 to 100 or it can go

00:16:13,990 --> 00:16:19,090
up to infinity or I have a set of

00:16:16,300 --> 00:16:22,170
characters in a certain range or in a

00:16:19,090 --> 00:16:24,880
certain set and I can of course also

00:16:22,170 --> 00:16:27,010
specify patterns so I can say well I

00:16:24,880 --> 00:16:29,140
have this data type in it's it's a

00:16:27,010 --> 00:16:30,760
carriage line feed terminated string so

00:16:29,140 --> 00:16:34,000
it's basically anything followed by a

00:16:30,760 --> 00:16:36,240
slash are slash n at the end and then I

00:16:34,000 --> 00:16:38,890
can use this type in in all my other

00:16:36,240 --> 00:16:40,900
development and whenever a string would

00:16:38,890 --> 00:16:42,130
not match that it would not measure give

00:16:40,900 --> 00:16:44,680
a runtime error or something like that

00:16:42,130 --> 00:16:47,320
so you don't need to explicitly open

00:16:44,680 --> 00:16:48,910
code functions to check whether it is in

00:16:47,320 --> 00:16:52,570
a certain range or whether it is

00:16:48,910 --> 00:16:54,400
matching a certain pattern and the the

00:16:52,570 --> 00:16:57,730
system can basically take care of that

00:16:54,400 --> 00:17:00,220
you just specify what's possible or

00:16:57,730 --> 00:17:05,650
what's legal for a given data type or

00:17:00,220 --> 00:17:06,520
for a given member of a structure okay

00:17:05,650 --> 00:17:09,100
that's subtyping

00:17:06,520 --> 00:17:11,830
but now the really exciting part is when

00:17:09,100 --> 00:17:12,790
you start to look at templates and now

00:17:11,830 --> 00:17:15,660
what are templates

00:17:12,790 --> 00:17:18,339
don't think of C++ forget about that and

00:17:15,660 --> 00:17:21,490
the templates here are templates for

00:17:18,339 --> 00:17:23,290
data types so in in testing some kind of

00:17:21,490 --> 00:17:26,410
network protocol you send messages you

00:17:23,290 --> 00:17:29,650
receive messages and for sending

00:17:26,410 --> 00:17:31,810
messages well probably not a strict

00:17:29,650 --> 00:17:33,850
necessity to have templates I mean you

00:17:31,810 --> 00:17:35,740
can just somehow encode your data and

00:17:33,850 --> 00:17:38,680
send it off but if you want to receive

00:17:35,740 --> 00:17:41,290
then you want to match incoming packets

00:17:38,680 --> 00:17:42,940
and what do you normally do well you if

00:17:41,290 --> 00:17:44,890
you do that in any other language you

00:17:42,940 --> 00:17:46,660
would decode the packet in some way and

00:17:44,890 --> 00:17:48,010
then you actually have like handwritten

00:17:46,660 --> 00:17:50,080
code that checks

00:17:48,010 --> 00:17:52,210
well is this member in a certain

00:17:50,080 --> 00:17:54,040
permitted range or is this identifier

00:17:52,210 --> 00:17:56,200
the number that I'm supposed to expect

00:17:54,040 --> 00:18:00,549
and so on and this again in TTC and

00:17:56,200 --> 00:18:02,530
three thus the templates can help you to

00:18:00,549 --> 00:18:04,450
do this because basically you can say

00:18:02,530 --> 00:18:07,030
well I want to have I want to create a

00:18:04,450 --> 00:18:10,419
template from such-and-such a data type

00:18:07,030 --> 00:18:12,970
and then I describe sort of the the

00:18:10,419 --> 00:18:16,360
properties of the individual fields and

00:18:12,970 --> 00:18:18,580
I can say well okay the I don't know the

00:18:16,360 --> 00:18:20,350
the sequence number must be plus one of

00:18:18,580 --> 00:18:22,150
the last sequence number that I had sent

00:18:20,350 --> 00:18:24,309
or things like that and you don't need

00:18:22,150 --> 00:18:26,290
to open code this or you can say that

00:18:24,309 --> 00:18:27,700
some members that I don't care because

00:18:26,290 --> 00:18:29,620
this is like a I don't know a

00:18:27,700 --> 00:18:31,510
transaction number that my peer is

00:18:29,620 --> 00:18:33,549
allocating and I don't really know what

00:18:31,510 --> 00:18:35,950
what he will be allocating so this can

00:18:33,549 --> 00:18:38,140
be some any value at this case so you

00:18:35,950 --> 00:18:39,760
can describe this in templates and let's

00:18:38,140 --> 00:18:43,059
start with some very simple templates

00:18:39,760 --> 00:18:45,280
here let's say well okay we have a

00:18:43,059 --> 00:18:49,419
character string that must be either A

00:18:45,280 --> 00:18:50,950
or B or C rather simple you can also

00:18:49,419 --> 00:18:52,510
have these examples are from the

00:18:50,950 --> 00:18:55,780
official documentation and I really like

00:18:52,510 --> 00:19:00,640
this near PI value so it's like 3.14 to

00:18:55,780 --> 00:19:02,049
3.15 some float value in between not

00:19:00,640 --> 00:19:04,660
sure which network protocol would use

00:19:02,049 --> 00:19:07,809
this but well they also test other

00:19:04,660 --> 00:19:09,970
things not just network protocols right

00:19:07,809 --> 00:19:12,880
yes fit into one by it's a bit stupid

00:19:09,970 --> 00:19:14,890
but you can also mix that so you can say

00:19:12,880 --> 00:19:18,220
Vasiliev on an integer value that's 0 to

00:19:14,890 --> 00:19:21,270
127 or 200 or 255 so you're not

00:19:18,220 --> 00:19:24,490
constrained to trust ranges or just sets

00:19:21,270 --> 00:19:26,470
and you can also do interesting things

00:19:24,490 --> 00:19:28,750
like bit string templates so here you

00:19:26,470 --> 00:19:31,270
see well basically this must be one zero

00:19:28,750 --> 00:19:33,270
one one zero one and some other two bits

00:19:31,270 --> 00:19:37,000
but you don't care what those bits are

00:19:33,270 --> 00:19:38,860
with the question mark in there or in

00:19:37,000 --> 00:19:41,470
character strings you can say well it's

00:19:38,860 --> 00:19:43,570
some something that starts with a and it

00:19:41,470 --> 00:19:45,700
ends with set but what's in between you

00:19:43,570 --> 00:19:48,880
don't really care some any number of

00:19:45,700 --> 00:19:50,919
other characters in between and you also

00:19:48,880 --> 00:19:52,690
have much more examine I'm not going to

00:19:50,919 --> 00:19:55,540
go into all the details of the language

00:19:52,690 --> 00:19:57,429
here times not sufficient but you also

00:19:55,540 --> 00:19:59,230
have other constructs such as complement

00:19:57,429 --> 00:20:01,059
if present subset super sets and

00:19:59,230 --> 00:20:04,029
permutations that you can use

00:20:01,059 --> 00:20:06,220
to construct that and of course the the

00:20:04,029 --> 00:20:09,100
the interesting part is when you apply

00:20:06,220 --> 00:20:11,769
templates to structure types and nested

00:20:09,100 --> 00:20:14,470
structure types and also you can have

00:20:11,769 --> 00:20:16,990
parametric templates so basically you

00:20:14,470 --> 00:20:19,149
say here well I have my message type

00:20:16,990 --> 00:20:20,649
here and it's the old message type from

00:20:19,149 --> 00:20:22,539
the previous example you have a couple

00:20:20,649 --> 00:20:26,200
of fields and you say well I have a

00:20:22,539 --> 00:20:28,740
template called TR my template well even

00:20:26,200 --> 00:20:32,769
without an a and I said typos yeah sorry

00:20:28,740 --> 00:20:35,110
and I give some parameter into the

00:20:32,769 --> 00:20:36,669
template and then basically I define my

00:20:35,110 --> 00:20:38,230
template and when I instantiate the

00:20:36,669 --> 00:20:39,879
temperate I can give it some arguments

00:20:38,230 --> 00:20:42,249
and parameters and those parameters will

00:20:39,879 --> 00:20:44,139
be put into the template so we have

00:20:42,249 --> 00:20:46,840
basically filled one we don't care if

00:20:44,139 --> 00:20:48,789
you two must be B or Q and field three

00:20:46,840 --> 00:20:50,950
will be the time the parameter that I

00:20:48,789 --> 00:20:53,320
passed into the template so of course I

00:20:50,950 --> 00:20:56,139
can also all do this by writing explicit

00:20:53,320 --> 00:20:59,169
code but it's so much more easier if

00:20:56,139 --> 00:21:02,139
it's some support in the in the language

00:20:59,169 --> 00:21:04,629
for this now now what do you do with the

00:21:02,139 --> 00:21:07,809
templates well you can use the built in

00:21:04,629 --> 00:21:10,119
match function which is we can say well

00:21:07,809 --> 00:21:13,840
does this blob of data match whatever

00:21:10,119 --> 00:21:16,629
template but actually this happens

00:21:13,840 --> 00:21:18,369
automatically at many given points in

00:21:16,629 --> 00:21:21,009
other statements that the language has

00:21:18,369 --> 00:21:24,730
so for example a fundamental function

00:21:21,009 --> 00:21:28,059
like receive where you think in abstract

00:21:24,730 --> 00:21:29,919
terms to a linux or C system level

00:21:28,059 --> 00:21:31,570
developer think of it as a receive

00:21:29,919 --> 00:21:33,759
system call it does in reality something

00:21:31,570 --> 00:21:36,309
else but you're receiving some data from

00:21:33,759 --> 00:21:38,559
some they call it test port in your case

00:21:36,309 --> 00:21:40,389
it might be a socket and and you can

00:21:38,559 --> 00:21:42,519
basically just say well receive

00:21:40,389 --> 00:21:44,169
something that matches the template and

00:21:42,519 --> 00:21:46,450
you just passed the template as the

00:21:44,169 --> 00:21:48,909
argument to the receive and then this

00:21:46,450 --> 00:21:50,860
receive call will complete only if data

00:21:48,909 --> 00:21:52,539
arrives that matches the template and we

00:21:50,860 --> 00:21:55,499
will look into how we deal with this in

00:21:52,539 --> 00:21:58,029
in in practice you also can have

00:21:55,499 --> 00:21:59,649
hierarchies of template so you can start

00:21:58,029 --> 00:22:02,049
with a very generic template that would

00:21:59,649 --> 00:22:03,879
match any legal message in your protocol

00:22:02,049 --> 00:22:06,419
for example and you can derive more

00:22:03,879 --> 00:22:09,629
specific messages so let's say any

00:22:06,419 --> 00:22:11,769
possible message or a possible

00:22:09,629 --> 00:22:13,509
acknowledgement message or a possible

00:22:11,769 --> 00:22:14,860
error message and then from there you

00:22:13,509 --> 00:22:17,590
can go deeper and deeper and you

00:22:14,860 --> 00:22:20,170
create your hierarchy of more specific

00:22:17,590 --> 00:22:22,030
templates so in this example we have a

00:22:20,170 --> 00:22:24,370
template that basically says well any

00:22:22,030 --> 00:22:27,790
message type is permitted and whatever

00:22:24,370 --> 00:22:29,350
other parameter must be bar and then I

00:22:27,790 --> 00:22:32,230
can declare another template that

00:22:29,350 --> 00:22:34,059
modifies the original template and I say

00:22:32,230 --> 00:22:36,220
well but in this case for that template

00:22:34,059 --> 00:22:37,929
the message type must be 23 and then in

00:22:36,220 --> 00:22:42,340
your code you can refer to the different

00:22:37,929 --> 00:22:44,020
templates as you go along now we've

00:22:42,340 --> 00:22:46,270
spoken a lot of about these abstract

00:22:44,020 --> 00:22:49,230
data types and records and structures

00:22:46,270 --> 00:22:51,549
and so on but how do I get there now

00:22:49,230 --> 00:22:54,340
somehow we need to come from the

00:22:51,549 --> 00:22:57,190
concrete binary message that we see in

00:22:54,340 --> 00:23:00,700
our protocol and attest to this abstract

00:22:57,190 --> 00:23:03,400
data type TTC + 3 specifies importing of

00:23:00,700 --> 00:23:09,220
formal schema definitions for asn.1

00:23:03,400 --> 00:23:11,500
specified protocols for IDL for xst for

00:23:09,220 --> 00:23:14,169
XML schema definitions and also for JSON

00:23:11,500 --> 00:23:16,270
schema definition that's nice for some

00:23:14,169 --> 00:23:18,760
protocols that are specified in such

00:23:16,270 --> 00:23:20,049
definitions but a lot of the things that

00:23:18,760 --> 00:23:22,299
people have to deal with are not

00:23:20,049 --> 00:23:24,309
specified that way so this is why

00:23:22,299 --> 00:23:25,990
tighten this which is the specific

00:23:24,309 --> 00:23:28,059
implementation of the TTC and three

00:23:25,990 --> 00:23:31,270
compilers has additional codecs and

00:23:28,059 --> 00:23:33,280
language extensions for expressing

00:23:31,270 --> 00:23:34,720
protocols that don't follow any such

00:23:33,280 --> 00:23:36,460
formal definition so if you want to

00:23:34,720 --> 00:23:39,940
implement an IP header or a TCP header

00:23:36,460 --> 00:23:42,700
there is no you know no no abstract

00:23:39,940 --> 00:23:44,860
syntax that you can use so they have two

00:23:42,700 --> 00:23:46,570
what they call codecs one is raw and one

00:23:44,860 --> 00:23:49,660
is text the name sort of is

00:23:46,570 --> 00:23:53,710
self-explanatory and using these codecs

00:23:49,660 --> 00:23:56,020
again you can using declarative

00:23:53,710 --> 00:23:58,330
programming you can express how a given

00:23:56,020 --> 00:24:01,330
abstract data is encoded or decoded into

00:23:58,330 --> 00:24:04,150
binary so how does this look like now

00:24:01,330 --> 00:24:05,620
this is a good and a bad example I try

00:24:04,150 --> 00:24:07,270
to use a protocol that everyone knows

00:24:05,620 --> 00:24:09,250
here it's a UDP header but then if you

00:24:07,270 --> 00:24:11,440
look at this like in C this would be

00:24:09,250 --> 00:24:15,370
much less code and then then here right

00:24:11,440 --> 00:24:17,020
but of course for more complex protocols

00:24:15,370 --> 00:24:19,990
with more complex head as an optional

00:24:17,020 --> 00:24:22,510
fields and TVs and so on it's much more

00:24:19,990 --> 00:24:24,610
simpler and this illustrates sort of the

00:24:22,510 --> 00:24:27,550
power because we start first to define a

00:24:24,610 --> 00:24:28,630
data type that says well is from 0 to 2

00:24:27,550 --> 00:24:33,670
to the power of 16

00:24:28,630 --> 00:24:35,920
which is encoded as a 16-bit field as an

00:24:33,670 --> 00:24:39,490
unsigned value because there's no sign

00:24:35,920 --> 00:24:41,290
and we use the least significant byte

00:24:39,490 --> 00:24:43,180
ordering in there I could also specify

00:24:41,290 --> 00:24:45,940
bit ordering even if I wanted to not

00:24:43,180 --> 00:24:48,100
just byte ordering and then I use this

00:24:45,940 --> 00:24:49,780
data type to construct a UDP header with

00:24:48,100 --> 00:24:52,240
the source port destination for links

00:24:49,780 --> 00:24:55,810
field and checksum and then I say well

00:24:52,240 --> 00:24:59,080
the field order in this record is most

00:24:55,810 --> 00:25:00,490
significant a bit a most significant bit

00:24:59,080 --> 00:25:04,410
first and that defines how the

00:25:00,490 --> 00:25:08,290
individual elements in my record in are

00:25:04,410 --> 00:25:09,790
ordered and then I define a UDP packet

00:25:08,290 --> 00:25:12,910
which consists of the header and the

00:25:09,790 --> 00:25:14,830
payload and I say basically with this

00:25:12,910 --> 00:25:17,110
line here at the bottom that's actually

00:25:14,830 --> 00:25:21,130
the key part of oh yeah of the entire

00:25:17,110 --> 00:25:23,200
slide here at the second last line on

00:25:21,130 --> 00:25:25,600
the slide where I say variant header

00:25:23,200 --> 00:25:27,400
links to header payload length index

00:25:25,600 --> 00:25:32,040
length what that does is basically say

00:25:27,400 --> 00:25:35,320
well in the header member of this record

00:25:32,040 --> 00:25:38,350
we store the length of both the header

00:25:35,320 --> 00:25:40,510
and the payload into a field called Len

00:25:38,350 --> 00:25:42,130
inside the header so basically in the

00:25:40,510 --> 00:25:44,320
substructure which defines the letter

00:25:42,130 --> 00:25:45,880
the header it has a length field and I

00:25:44,320 --> 00:25:47,590
want to store the total length of both

00:25:45,880 --> 00:25:49,330
the header and the packet in there and I

00:25:47,590 --> 00:25:51,940
don't need to write any explicit code to

00:25:49,330 --> 00:25:54,160
do that it will just do it based on this

00:25:51,940 --> 00:25:57,340
declaration and this set this works for

00:25:54,160 --> 00:25:59,350
much more complex data types in in in

00:25:57,340 --> 00:26:02,170
the similar way of course now for the

00:25:59,350 --> 00:26:03,820
checksum this is where you hit the end

00:26:02,170 --> 00:26:05,350
of what you can do with declarative

00:26:03,820 --> 00:26:07,030
programming so you actually have to have

00:26:05,350 --> 00:26:09,070
a piece of code that validates the

00:26:07,030 --> 00:26:12,310
checksum and it can be C++ or they can

00:26:09,070 --> 00:26:16,240
be TTC entry code here for example

00:26:12,310 --> 00:26:18,250
there's a GRE header GRE has some bit

00:26:16,240 --> 00:26:20,770
flags in the beginning that define which

00:26:18,250 --> 00:26:24,070
other optional members optional fields

00:26:20,770 --> 00:26:26,020
later in the header appear so we have a

00:26:24,070 --> 00:26:28,330
checksum present bit and an RT present

00:26:26,020 --> 00:26:30,040
and the key present bit so we define

00:26:28,330 --> 00:26:31,810
that header and and of course there's

00:26:30,040 --> 00:26:34,120
more bits and later we have some octet

00:26:31,810 --> 00:26:35,560
s-- protocol type checksum and so on and

00:26:34,120 --> 00:26:37,240
some of those are optional like the

00:26:35,560 --> 00:26:40,390
checks on the offset in the key are

00:26:37,240 --> 00:26:42,670
optional and this optional not ocean s

00:26:40,390 --> 00:26:45,280
is it sorry for my typos

00:26:42,670 --> 00:26:48,430
so and then we say well the checksum

00:26:45,280 --> 00:26:51,520
field is present if the season present

00:26:48,430 --> 00:26:54,040
bid equals one or the RT present bit

00:26:51,520 --> 00:26:57,130
equals one and you can express again

00:26:54,040 --> 00:26:58,960
these kind of conditions upon which a

00:26:57,130 --> 00:27:01,240
certain optional field must be there

00:26:58,960 --> 00:27:03,460
must not be there and the binary raw

00:27:01,240 --> 00:27:05,410
encoder or decoder will behave

00:27:03,460 --> 00:27:09,720
accordingly when it decodes the message

00:27:05,410 --> 00:27:13,630
so again no need to to code explicitly

00:27:09,720 --> 00:27:15,730
functions that iterate over the message

00:27:13,630 --> 00:27:22,420
or something like that now let's look at

00:27:15,730 --> 00:27:28,200
an example of a text coder the text here

00:27:22,420 --> 00:27:31,000
is a small sub part of an mgcp

00:27:28,200 --> 00:27:33,100
example I chose mgcp because well it's

00:27:31,000 --> 00:27:34,690
one protocol that I implement secondly

00:27:33,100 --> 00:27:36,430
it's an IETF protocol even though

00:27:34,690 --> 00:27:38,110
probably many people don't know it it's

00:27:36,430 --> 00:27:41,530
the media gateway control protocol I

00:27:38,110 --> 00:27:41,770
think it's RFC 3455 or something like

00:27:41,530 --> 00:27:45,040
that

00:27:41,770 --> 00:27:48,310
it's fess if I'd in text and using the

00:27:45,040 --> 00:27:51,400
text encoder capabilities of Titan we

00:27:48,310 --> 00:27:53,230
can again declare how this protocol

00:27:51,400 --> 00:27:56,260
looks like so we first say well there is

00:27:53,230 --> 00:27:58,810
a verb and it can be whatever can be CR

00:27:56,260 --> 00:28:01,810
6mb 6006 whatever these are basically

00:27:58,810 --> 00:28:05,020
verbs of the protocol and we say well it

00:28:01,810 --> 00:28:07,390
has a text encoding and when I receive

00:28:05,020 --> 00:28:09,760
something it's text so it's case

00:28:07,390 --> 00:28:11,440
insensitive the match but then after

00:28:09,760 --> 00:28:13,600
receiving it actually I want to convert

00:28:11,440 --> 00:28:16,030
it to an uppercase so all my remaining

00:28:13,600 --> 00:28:17,440
code inside the test case only deals

00:28:16,030 --> 00:28:20,260
with uppercase and I don't need to do

00:28:17,440 --> 00:28:22,150
like a case insensitive string compares

00:28:20,260 --> 00:28:24,370
and things like that I define some other

00:28:22,150 --> 00:28:26,920
things like a transaction ID which is a

00:28:24,370 --> 00:28:29,710
decimal number with one to nine digits

00:28:26,920 --> 00:28:31,360
of length there's an mgcp endpoint which

00:28:29,710 --> 00:28:33,700
looks a bit like an email address so it

00:28:31,360 --> 00:28:35,350
has some part in front of an @ sign in

00:28:33,700 --> 00:28:35,680
some part after an @ sign and so on and

00:28:35,350 --> 00:28:37,870
so on

00:28:35,680 --> 00:28:40,450
and then I construct basically my entire

00:28:37,870 --> 00:28:42,640
command line and I can specify that

00:28:40,450 --> 00:28:45,610
there can be spaces or tabs in between

00:28:42,640 --> 00:28:47,680
and there must be a carriage return line

00:28:45,610 --> 00:28:50,170
feed termination at the end and so on so

00:28:47,680 --> 00:28:52,210
once again I just express this in in the

00:28:50,170 --> 00:28:54,040
syntax of the language and I don't need

00:28:52,210 --> 00:28:55,750
to write a single line of code to parse

00:28:54,040 --> 00:28:57,220
or encode this entire take

00:28:55,750 --> 00:28:59,590
space protocol you could do the same

00:28:57,220 --> 00:29:04,360
with smtp with HTTP with whatever you

00:28:59,590 --> 00:29:06,880
want to do not writing any any code like

00:29:04,360 --> 00:29:10,240
any normal like how you would write code

00:29:06,880 --> 00:29:13,150
in c or other languages so program

00:29:10,240 --> 00:29:16,840
control statements we have if-else for

00:29:13,150 --> 00:29:18,670
while to do while loops go to and label

00:29:16,840 --> 00:29:21,070
with break and continuous all that is

00:29:18,670 --> 00:29:25,240
very much like in C the Select statement

00:29:21,070 --> 00:29:27,130
is rather different but it's

00:29:25,240 --> 00:29:28,870
fundamentally similar to a switch

00:29:27,130 --> 00:29:30,460
statement in C so I'm not going to go

00:29:28,870 --> 00:29:33,840
into details here we also want to look

00:29:30,460 --> 00:29:35,710
at some examples still now

00:29:33,840 --> 00:29:37,150
communications operations so in the end

00:29:35,710 --> 00:29:40,180
we want to send and receive some stuff

00:29:37,150 --> 00:29:42,730
and in TTC and three this works for

00:29:40,180 --> 00:29:44,710
something called text ports now this

00:29:42,730 --> 00:29:46,960
does not have anything to do with the

00:29:44,710 --> 00:29:49,030
UDP port or a TCP port it's it's a much

00:29:46,960 --> 00:29:51,310
more abstract concept a test port could

00:29:49,030 --> 00:29:53,410
be a serial line it could be I don't

00:29:51,310 --> 00:29:57,270
know it could be avian carriers it's

00:29:53,410 --> 00:29:57,270
basically a very abstract concept and

00:29:57,540 --> 00:30:03,280
you can then use a test port

00:30:01,000 --> 00:30:05,980
implementation to map onto whatever that

00:30:03,280 --> 00:30:08,290
is so in in titan for example you have

00:30:05,980 --> 00:30:12,040
test ports that map onto a packet socket

00:30:08,290 --> 00:30:13,540
onto an IP UDP TCP SCTP socket and in

00:30:12,040 --> 00:30:16,810
the end then you can send and receive

00:30:13,540 --> 00:30:18,640
data on the port and for sending well

00:30:16,810 --> 00:30:20,200
you give some value and it performs a

00:30:18,640 --> 00:30:22,030
non-blocking send and you can have

00:30:20,200 --> 00:30:24,250
literal values constants and so on to

00:30:22,030 --> 00:30:26,860
send the receive operation is always

00:30:24,250 --> 00:30:28,240
blocking in TTC and three and no people

00:30:26,860 --> 00:30:29,620
will probably have question mice in they

00:30:28,240 --> 00:30:34,270
had how can that work we will look at

00:30:29,620 --> 00:30:36,220
that so if they receive blocks I mean if

00:30:34,270 --> 00:30:37,630
it locks in indefinitely you want to

00:30:36,220 --> 00:30:39,190
have some time out how do you handle

00:30:37,630 --> 00:30:40,750
that or if you're waiting for like three

00:30:39,190 --> 00:30:42,760
different things to happen in any random

00:30:40,750 --> 00:30:45,160
order but all of the three must happen

00:30:42,760 --> 00:30:48,850
how do you do this in in a blocking

00:30:45,160 --> 00:30:51,460
receive so that's an example that

00:30:48,850 --> 00:30:55,570
illustrates that so let's assume we want

00:30:51,460 --> 00:30:59,230
to receive X&Y but we don't know whether

00:30:55,570 --> 00:31:00,940
X appears before Y or Y ESP forex or

00:30:59,230 --> 00:31:03,970
doing - blocking receives of course

00:31:00,940 --> 00:31:05,440
wouldn't work in sequence and so TTC and

00:31:03,970 --> 00:31:07,480
three introduced something called the

00:31:05,440 --> 00:31:09,430
alt statement so you can specify well

00:31:07,480 --> 00:31:12,400
either A or B or

00:31:09,430 --> 00:31:14,530
see must happen and then you can define

00:31:12,400 --> 00:31:17,080
the handling so in this program example

00:31:14,530 --> 00:31:19,300
here we basically in the first line

00:31:17,080 --> 00:31:21,390
we're sending some request whatever it

00:31:19,300 --> 00:31:24,010
might be we start a timer

00:31:21,390 --> 00:31:26,380
we do some other stuff and then we have

00:31:24,010 --> 00:31:29,080
an alt statement here we say well if on

00:31:26,380 --> 00:31:31,660
test port P we receive something that

00:31:29,080 --> 00:31:35,230
matches RESP where s might be a template

00:31:31,660 --> 00:31:37,480
to match a response according to your

00:31:35,230 --> 00:31:40,150
spec then you have a block here in in

00:31:37,480 --> 00:31:42,400
curly braces of whatever to do if that

00:31:40,150 --> 00:31:44,740
happens and it quote the control flow

00:31:42,400 --> 00:31:47,020
then continues after this alt statement

00:31:44,740 --> 00:31:49,000
or if you receive anything else on any

00:31:47,020 --> 00:31:50,740
other port you can define whatever

00:31:49,000 --> 00:31:52,720
should happen then there or if the

00:31:50,740 --> 00:31:54,370
timeout on this timer T which you

00:31:52,720 --> 00:31:56,170
started up there has happened and you

00:31:54,370 --> 00:31:58,240
can handle timeout expiry or something

00:31:56,170 --> 00:32:01,540
like that what's in the beginning is a

00:31:58,240 --> 00:32:03,610
guard statement which if MP is always

00:32:01,540 --> 00:32:05,230
true but if you want to have state

00:32:03,610 --> 00:32:06,940
machines or something that's rather good

00:32:05,230 --> 00:32:09,660
because you can match in there can say

00:32:06,940 --> 00:32:12,280
well any given number of your alt

00:32:09,660 --> 00:32:13,570
alternatives in the alt only apply if

00:32:12,280 --> 00:32:14,620
you're in a certain state or something

00:32:13,570 --> 00:32:19,660
like that that's what the guard

00:32:14,620 --> 00:32:22,240
statement is for we also have repeat so

00:32:19,660 --> 00:32:25,780
in again this example to fill in some

00:32:22,240 --> 00:32:27,910
stuff where we be sent some requests we

00:32:25,780 --> 00:32:30,730
start a timer we wait for something so

00:32:27,910 --> 00:32:32,710
either we receive a response where we

00:32:30,730 --> 00:32:34,210
implement like the intended response or

00:32:32,710 --> 00:32:35,980
we receive something like a keepalive

00:32:34,210 --> 00:32:37,210
that's not really part of our test but

00:32:35,980 --> 00:32:39,160
it's part of the protocol that there's a

00:32:37,210 --> 00:32:41,530
regular keeper life between lion and

00:32:39,160 --> 00:32:43,090
server going on and we just want to

00:32:41,530 --> 00:32:44,980
ignore it or we want to respond to it

00:32:43,090 --> 00:32:47,110
but it shouldn't affect the control flow

00:32:44,980 --> 00:32:49,510
of our test then we can say well if we

00:32:47,110 --> 00:32:52,230
receive a keepalive then we repeat so

00:32:49,510 --> 00:32:54,970
basically this entire alt statement gets

00:32:52,230 --> 00:32:56,950
continued and we don't exit it if a

00:32:54,970 --> 00:32:57,550
match happens if you receive anything

00:32:56,950 --> 00:32:59,680
else

00:32:57,550 --> 00:33:02,830
maybe we abort the test or we fail it in

00:32:59,680 --> 00:33:05,350
some way or if you have timeout then we

00:33:02,830 --> 00:33:09,400
handle that in some way so that's an alt

00:33:05,350 --> 00:33:11,530
statement there is even more fancy

00:33:09,400 --> 00:33:14,260
concepts now because if you start to

00:33:11,530 --> 00:33:15,850
write tests in in this way you you send

00:33:14,260 --> 00:33:17,530
something you have the alt statement and

00:33:15,850 --> 00:33:19,690
you will find well you know in each of

00:33:17,530 --> 00:33:21,490
my test cases I'm starting a timer and

00:33:19,690 --> 00:33:23,200
I'm waiting or I have one of the

00:33:21,490 --> 00:33:25,300
alternatives is the timer expires

00:33:23,200 --> 00:33:26,830
and if the timer expires my test case

00:33:25,300 --> 00:33:28,630
should fail and you don't want to write

00:33:26,830 --> 00:33:31,120
that 100 times if you write 100

00:33:28,630 --> 00:33:32,890
different test cases so what you can do

00:33:31,120 --> 00:33:34,540
and I didn't put this in the example it

00:33:32,890 --> 00:33:38,760
would go too far but just conceptually

00:33:34,540 --> 00:33:41,980
you can you can have something called a

00:33:38,760 --> 00:33:44,680
it's called an alt step actually and you

00:33:41,980 --> 00:33:47,260
can basically say well in my alt

00:33:44,680 --> 00:33:49,000
statement I have some I activate some

00:33:47,260 --> 00:33:50,740
some additional things which magically

00:33:49,000 --> 00:33:52,960
get inserted here but which I don't have

00:33:50,740 --> 00:33:54,790
to state every time I'm writing such an

00:33:52,960 --> 00:33:56,620
alt statement so you default timer

00:33:54,790 --> 00:33:58,960
handling or whatever other handling like

00:33:56,620 --> 00:34:01,300
sending a pawn in response to a ping

00:33:58,960 --> 00:34:03,970
that you just have to do to keep the

00:34:01,300 --> 00:34:05,410
protocol alive you do this in in what's

00:34:03,970 --> 00:34:07,990
called an auth step and that gets

00:34:05,410 --> 00:34:09,820
activated in all of you alts that you

00:34:07,990 --> 00:34:11,800
write so you can abstract all the things

00:34:09,820 --> 00:34:13,300
that are common to each of their to all

00:34:11,800 --> 00:34:16,720
of your test cases or many of the test

00:34:13,300 --> 00:34:18,370
cases now how do we write code we write

00:34:16,720 --> 00:34:20,560
it actually in modules it's a bit like

00:34:18,370 --> 00:34:24,250
Python conceptually if you've done any

00:34:20,560 --> 00:34:27,010
Python work so you have modules and you

00:34:24,250 --> 00:34:28,840
can import certain objects or variables

00:34:27,010 --> 00:34:31,240
or definitions from other objects using

00:34:28,840 --> 00:34:33,429
and from other modules using an import

00:34:31,240 --> 00:34:35,169
statement if parameters data types

00:34:33,429 --> 00:34:36,310
communication was you define basically

00:34:35,169 --> 00:34:39,730
all the different things you could

00:34:36,310 --> 00:34:41,620
import and now before we go a couple of

00:34:39,730 --> 00:34:44,020
additional slides let's look at some

00:34:41,620 --> 00:34:47,850
example code actually how this looks

00:34:44,020 --> 00:34:47,850
like in in a real use case

00:35:27,060 --> 00:35:30,690
I'm starting at the bottom of the file

00:35:29,280 --> 00:35:32,550
where I have something called control

00:35:30,690 --> 00:35:35,130
that's basically the control statement

00:35:32,550 --> 00:35:37,140
which is a default statement that says

00:35:35,130 --> 00:35:39,020
what are the individual test cases to be

00:35:37,140 --> 00:35:41,370
executed in this test

00:35:39,020 --> 00:35:43,320
every TTC and three tests suit

00:35:41,370 --> 00:35:45,330
automatically has a configuration file

00:35:43,320 --> 00:35:48,120
and with that configuration file without

00:35:45,330 --> 00:35:49,980
writing any explicit line of code you

00:35:48,120 --> 00:35:51,390
can also define you can override

00:35:49,980 --> 00:35:53,190
basically what's in their control

00:35:51,390 --> 00:35:56,270
statement another interesting part is

00:35:53,190 --> 00:35:59,250
let me just go to the beginning here I

00:35:56,270 --> 00:36:01,260
can have module parameters now of course

00:35:59,250 --> 00:36:03,660
I don't find them anyway let's see let's

00:36:01,260 --> 00:36:06,000
ignore that you I module power here

00:36:03,660 --> 00:36:07,140
actually I so here we define for some of

00:36:06,000 --> 00:36:09,150
the port numbers and the IP addresses

00:36:07,140 --> 00:36:11,040
with which our test interacts I can have

00:36:09,150 --> 00:36:12,870
some compiled in defaults there but

00:36:11,040 --> 00:36:15,810
automatically because I declared those

00:36:12,870 --> 00:36:17,250
in the module power section at X config

00:36:15,810 --> 00:36:19,050
file can take any of those parameters

00:36:17,250 --> 00:36:20,640
and I don't need to write code for

00:36:19,050 --> 00:36:22,260
parsing a config file for dealing with

00:36:20,640 --> 00:36:24,860
any of that it just takes care of that

00:36:22,260 --> 00:36:27,150
and I don't need to worry about this so

00:36:24,860 --> 00:36:28,770
this is automatically available in the

00:36:27,150 --> 00:36:32,580
config file can be specified when I

00:36:28,770 --> 00:36:34,950
execute it now let's look at some what

00:36:32,580 --> 00:36:36,540
this is a pure function here you get

00:36:34,950 --> 00:36:39,050
next transaction ID which just

00:36:36,540 --> 00:36:41,550
increments a global variable and

00:36:39,050 --> 00:36:43,620
allocates me a new transaction ID for

00:36:41,550 --> 00:36:46,170
for interacting this is mgcp the media

00:36:43,620 --> 00:36:47,850
gateway protocol and I can define just

00:36:46,170 --> 00:36:49,920
normal functions like in any other

00:36:47,850 --> 00:36:52,020
programming language but in the end and

00:36:49,920 --> 00:36:55,680
here we see some template definitions in

00:36:52,020 --> 00:36:57,570
the end you come to test cases so let's

00:36:55,680 --> 00:37:00,210
actually look at that for example the TC

00:36:57,570 --> 00:37:03,390
self test and TC is test case it's not

00:37:00,210 --> 00:37:06,540
related in any way to Jamal he didn't

00:37:03,390 --> 00:37:09,390
pay me any secret peers to to make it

00:37:06,540 --> 00:37:11,150
call TC so this is I'm defining some

00:37:09,390 --> 00:37:13,350
strings these are basically strings that

00:37:11,150 --> 00:37:15,330
I'm self testing the module here so

00:37:13,350 --> 00:37:18,540
these are strings that are valid or

00:37:15,330 --> 00:37:21,660
invalid or whatever mgcp strings and I'm

00:37:18,540 --> 00:37:24,600
just testing by calling the decoder I'm

00:37:21,660 --> 00:37:29,790
self testing the module but some actual

00:37:24,600 --> 00:37:32,460
like real test case let's look at this

00:37:29,790 --> 00:37:34,710
here so this is test case that sends a

00:37:32,460 --> 00:37:37,650
certain message to the CRC X to create a

00:37:34,710 --> 00:37:40,140
connection and it tests with some

00:37:37,650 --> 00:37:42,870
unsupported parameters so

00:37:40,140 --> 00:37:45,510
I call some initialization function I

00:37:42,870 --> 00:37:50,460
have here I basically I derive a value

00:37:45,510 --> 00:37:52,770
of mgcp command type from a sent

00:37:50,460 --> 00:37:54,390
template for CRC X where I use the next

00:37:52,770 --> 00:37:56,220
transaction ID and some other values and

00:37:54,390 --> 00:37:57,890
this is a parametric template so that

00:37:56,220 --> 00:37:59,970
the values I put in here they are

00:37:57,890 --> 00:38:02,850
basically getting part of a template

00:37:59,970 --> 00:38:05,510
then I initialize some more fields of

00:38:02,850 --> 00:38:09,960
this command again using utility

00:38:05,510 --> 00:38:12,300
templates so to have a more abstract

00:38:09,960 --> 00:38:14,760
definition than writing the actual

00:38:12,300 --> 00:38:16,350
native text there and in the end I have

00:38:14,760 --> 00:38:19,950
a helper function that transceivers this

00:38:16,350 --> 00:38:21,960
command and returns a template and I

00:38:19,950 --> 00:38:25,290
have a pass here so basically where does

00:38:21,960 --> 00:38:28,770
it fail well this mgcp trans sieve

00:38:25,290 --> 00:38:30,960
helper function and that I'm calling and

00:38:28,770 --> 00:38:31,440
now I lost the context sorry for that

00:38:30,960 --> 00:38:34,170
anyway

00:38:31,440 --> 00:38:36,540
the mgcp transceiver function and it

00:38:34,170 --> 00:38:38,400
also has access to the the verdict so

00:38:36,540 --> 00:38:39,990
any function you call has automatically

00:38:38,400 --> 00:38:42,480
access to the verdict of the current

00:38:39,990 --> 00:38:44,610
test case so it can basically check and

00:38:42,480 --> 00:38:46,080
match and see if something fails or

00:38:44,610 --> 00:38:49,170
doesn't fail and actually let's look at

00:38:46,080 --> 00:38:51,470
this mgcp receive a transition for a

00:38:49,170 --> 00:38:51,470
second

00:39:01,180 --> 00:39:07,180
yeah here we are so this transy function

00:39:05,829 --> 00:39:08,829
so we have a command that we want to

00:39:07,180 --> 00:39:10,960
transmit we have a template which

00:39:08,829 --> 00:39:13,450
specifies what do we expect in return

00:39:10,960 --> 00:39:15,760
and now here we're just patching in some

00:39:13,450 --> 00:39:18,510
some transaction ID and in the end we

00:39:15,760 --> 00:39:21,700
send it so here we send the the template

00:39:18,510 --> 00:39:24,369
through the test port we start a timer

00:39:21,700 --> 00:39:31,510
we end our alt statement and then if we

00:39:24,369 --> 00:39:34,480
receive something that matches MRT what

00:39:31,510 --> 00:39:36,849
MRT is is a template that we have

00:39:34,480 --> 00:39:39,130
derived here yes it's a temperate so if

00:39:36,849 --> 00:39:41,619
we what whatever we matched and

00:39:39,130 --> 00:39:43,990
basically we continue here if we receive

00:39:41,619 --> 00:39:46,180
something else that is still an a valid

00:39:43,990 --> 00:39:48,460
mgcp we say it's failed because we

00:39:46,180 --> 00:39:50,589
received something that's not matching

00:39:48,460 --> 00:39:52,900
our template if we receive anything else

00:39:50,589 --> 00:39:54,880
that's not mgcp we ignore it at this

00:39:52,900 --> 00:39:56,859
point if we have a timeout we fail the

00:39:54,880 --> 00:39:58,480
test case and so on and then here we do

00:39:56,859 --> 00:40:02,740
some additional processing at the bottom

00:39:58,480 --> 00:40:04,359
so of course very difficult to

00:40:02,740 --> 00:40:06,730
illustrate all the features of such a

00:40:04,359 --> 00:40:11,319
powerful tool in a very short amount of

00:40:06,730 --> 00:40:14,559
time which brings me to the time two

00:40:11,319 --> 00:40:17,559
more slides very quickly so there's

00:40:14,559 --> 00:40:19,690
logging support I already said that it

00:40:17,559 --> 00:40:22,690
does help us to format the locks in a

00:40:19,690 --> 00:40:24,339
very nice way so this would be the log

00:40:22,690 --> 00:40:26,079
how it's generated looks a bit like JSON

00:40:24,339 --> 00:40:27,819
so if we see anytime you send or receive

00:40:26,079 --> 00:40:30,400
something it already dumps you the

00:40:27,819 --> 00:40:32,170
decoded and the encoded data and there's

00:40:30,400 --> 00:40:33,880
some formatting tools that will format

00:40:32,170 --> 00:40:35,890
and structure it nicely like this for

00:40:33,880 --> 00:40:39,609
you which is much more easy to to

00:40:35,890 --> 00:40:41,710
understand what is actually going on and

00:40:39,609 --> 00:40:43,599
this is just a list of all the protocols

00:40:41,710 --> 00:40:46,299
that the Titan guys already have

00:40:43,599 --> 00:40:48,190
implemented for you so you don't need to

00:40:46,299 --> 00:40:49,720
restart by creating encoding and

00:40:48,190 --> 00:40:52,599
decoding of those protocols and you can

00:40:49,720 --> 00:40:54,160
focus on your actual test cases and this

00:40:52,599 --> 00:40:56,079
brings me to the end I don't want to go

00:40:54,160 --> 00:40:57,579
too much over time thank you for your

00:40:56,079 --> 00:40:59,890
attention and if you have any questions

00:40:57,579 --> 00:41:04,410
feel free to reach out to me at any time

00:40:59,890 --> 00:41:04,410
thanks question

00:41:05,890 --> 00:41:10,820
question and nobody the question do you

00:41:09,320 --> 00:41:13,460
see do you see us using this in the

00:41:10,820 --> 00:41:15,020
kernel to test some well not in the

00:41:13,460 --> 00:41:18,620
kernel but to test the kernel for sure

00:41:15,020 --> 00:41:21,170
yes yeah well what I did as a demo at

00:41:18,620 --> 00:41:22,970
the netfilter workshop this year is I

00:41:21,170 --> 00:41:24,710
implemented a very simplistic connection

00:41:22,970 --> 00:41:27,860
tracking testing so basically I opened

00:41:24,710 --> 00:41:29,300
two-ton devices and basically sending

00:41:27,860 --> 00:41:31,700
and receiving packets through the ton

00:41:29,300 --> 00:41:34,190
devices from my test case and then I

00:41:31,700 --> 00:41:37,310
implemented you can link in native code

00:41:34,190 --> 00:41:39,650
so I linked in lip citynet link to query

00:41:37,310 --> 00:41:41,570
the connection tracking table of net

00:41:39,650 --> 00:41:43,880
link so you can basically send some

00:41:41,570 --> 00:41:45,470
messages you sent the first packet and

00:41:43,880 --> 00:41:47,090
then you read the connection tracking

00:41:45,470 --> 00:41:48,500
and you verify if it's in the state that

00:41:47,090 --> 00:41:50,090
you expect then you send a response

00:41:48,500 --> 00:41:51,620
packet you reread the connection

00:41:50,090 --> 00:41:53,780
tracking entry and you match again if

00:41:51,620 --> 00:41:57,320
now this state change that you expect to

00:41:53,780 --> 00:41:59,900
happen after reply packet has arrived is

00:41:57,320 --> 00:42:01,850
there so I wrote some code that is more

00:41:59,900 --> 00:42:03,860
in the context of what kernel net for

00:42:01,850 --> 00:42:06,320
networking people do I think it's useful

00:42:03,860 --> 00:42:08,810
even in such cases whether any of you

00:42:06,320 --> 00:42:11,360
guys has time or interest or thinks it's

00:42:08,810 --> 00:42:14,630
important to do automatic test cases

00:42:11,360 --> 00:42:17,600
that's a separate question but I think

00:42:14,630 --> 00:42:21,010
it's useful in this context yes Thanks

00:42:17,600 --> 00:42:21,010

YouTube URL: https://www.youtube.com/watch?v=GSosAKreMBI


