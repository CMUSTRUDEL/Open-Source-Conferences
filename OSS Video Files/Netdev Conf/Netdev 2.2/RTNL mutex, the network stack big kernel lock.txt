Title: RTNL mutex, the network stack big kernel lock
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: Florian Westphal
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?westphal-rtnlmutex-talk
Captions: 
	00:00:05,380 --> 00:00:10,029
it's lastly poplars not listening to me

00:00:16,830 --> 00:00:25,300
that's great now I think I'll hand the

00:00:21,460 --> 00:00:27,130
mic over to deploy and wish for yeah as

00:00:25,300 --> 00:00:28,989
you know he's already been mentioned by

00:00:27,130 --> 00:00:33,370
if I hold he's kind of kind of finish

00:00:28,989 --> 00:00:34,469
famous Colonel guy so there you go thank

00:00:33,370 --> 00:00:39,129
you

00:00:34,469 --> 00:00:41,440
so let's start so first I'm giving a

00:00:39,129 --> 00:00:43,149
brief overview of what art netlink is

00:00:41,440 --> 00:00:46,780
and what it's doing and why we have this

00:00:43,149 --> 00:00:49,420
thing and then I will delve into what

00:00:46,780 --> 00:00:52,120
alternating used to look like and what

00:00:49,420 --> 00:00:55,059
it looks like now and what kind of

00:00:52,120 --> 00:00:56,920
problems we have with it and then I will

00:00:55,059 --> 00:00:58,659
talk about the kind of problems and

00:00:56,920 --> 00:01:00,460
challenges challenges we are currently

00:00:58,659 --> 00:01:02,559
facing when trying to push down the art

00:01:00,460 --> 00:01:08,100
in l-lot to make this thing more

00:01:02,559 --> 00:01:10,540
scalable so basically art netlink is the

00:01:08,100 --> 00:01:13,330
colonel's interface to use a space to

00:01:10,540 --> 00:01:14,979
configure all things networking when

00:01:13,330 --> 00:01:17,470
it's pretty ancient by Colonel standards

00:01:14,979 --> 00:01:20,650
it was added more than 20 years ago

00:01:17,470 --> 00:01:22,750
and basically you can't even build a

00:01:20,650 --> 00:01:26,290
kernel without art Annette link unless

00:01:22,750 --> 00:01:30,100
you elide all kind all all the entire

00:01:26,290 --> 00:01:31,690
networks there completely and so if you

00:01:30,100 --> 00:01:34,300
configure an ipv4 address or ipv6

00:01:31,690 --> 00:01:36,490
address or you bring up and down tunnels

00:01:34,300 --> 00:01:40,900
and you always involve 14 it link at one

00:01:36,490 --> 00:01:45,610
point and in the kernel there is an

00:01:40,900 --> 00:01:48,070
register API where I use a kernel module

00:01:45,610 --> 00:01:51,430
can basically say for this protocol

00:01:48,070 --> 00:01:58,270
family and this type for instance new

00:01:51,430 --> 00:02:01,420
route invoke this callback and in Linux

00:01:58,270 --> 00:02:04,420
for the 13 the kernel stack basically

00:02:01,420 --> 00:02:05,800
looks like this whenever an RT netlink

00:02:04,420 --> 00:02:08,739
message is coming in and we first

00:02:05,800 --> 00:02:11,470
grabbed the art in L lock then the

00:02:08,739 --> 00:02:15,010
messages processed and after that we

00:02:11,470 --> 00:02:17,290
unlock again and all that are genetic

00:02:15,010 --> 00:02:19,720
received message does is basically it

00:02:17,290 --> 00:02:22,330
takes a look at the art in Etling

00:02:19,720 --> 00:02:24,220
message which contains the family and

00:02:22,330 --> 00:02:26,170
the type and finds out what callback it

00:02:24,220 --> 00:02:28,540
needs to invoke invokes that callback

00:02:26,170 --> 00:02:31,989
and after that it's done

00:02:28,540 --> 00:02:34,629
and it's up to the callback to decode

00:02:31,989 --> 00:02:37,150
what the actual message is supposed to

00:02:34,629 --> 00:02:40,870
do for instance is this message supposed

00:02:37,150 --> 00:02:44,849
to delete in IP address for example and

00:02:40,870 --> 00:02:44,849
if yes which one and so on and so forth

00:02:47,560 --> 00:02:52,239
RT netlink mutex what does it do

00:02:49,450 --> 00:02:54,159
actually so first of all as we have seen

00:02:52,239 --> 00:02:56,230
it serialized really all the art in that

00:02:54,159 --> 00:02:58,480
link requests it does not matter what

00:02:56,230 --> 00:03:01,989
they do they all have to go through the

00:02:58,480 --> 00:03:03,730
single request then it's utilized with

00:03:01,989 --> 00:03:07,120
other user space api said somehow

00:03:03,730 --> 00:03:09,220
interact with the net links system for

00:03:07,120 --> 00:03:13,120
instance there is a sisyphus file which

00:03:09,220 --> 00:03:16,480
you can change to change the name alias

00:03:13,120 --> 00:03:18,730
of a network interface and that is even

00:03:16,480 --> 00:03:21,609
though it's exposed wire sisyphus it's

00:03:18,730 --> 00:03:23,739
also available by RT net link so

00:03:21,609 --> 00:03:25,480
whenever someone changes that the

00:03:23,739 --> 00:03:27,819
sisyphus code that is responsible for

00:03:25,480 --> 00:03:31,030
this also grabs the RTL mutex and

00:03:27,819 --> 00:03:33,400
another very popular data structure in

00:03:31,030 --> 00:03:36,340
the kernel that is used that is

00:03:33,400 --> 00:03:38,199
protected by a trt non-mutex is the list

00:03:36,340 --> 00:03:40,599
of network namespaces so whenever some

00:03:38,199 --> 00:03:42,849
piece of kernel code has to make changes

00:03:40,599 --> 00:03:45,040
that affect all network namespaces and

00:03:42,849 --> 00:03:47,620
it has to iterate the network namespace

00:03:45,040 --> 00:03:50,829
list this has to be done under RTL mutex

00:03:47,620 --> 00:03:53,680
protection as well and as a consequence

00:03:50,829 --> 00:03:55,870
of that you can only do one request at a

00:03:53,680 --> 00:03:58,720
time so when you for instance want to

00:03:55,870 --> 00:04:03,340
add a new IP address and someone else is

00:03:58,720 --> 00:04:05,340
listing all links in a system or some

00:04:03,340 --> 00:04:08,680
other program is stamping a list of

00:04:05,340 --> 00:04:11,530
traffic control and classifiers attached

00:04:08,680 --> 00:04:15,060
to the system then those all have to

00:04:11,530 --> 00:04:17,889
wait until the first action is done and

00:04:15,060 --> 00:04:19,510
dump requests even though they

00:04:17,889 --> 00:04:22,360
technically don't change anything in the

00:04:19,510 --> 00:04:25,180
system they are also fully serialized by

00:04:22,360 --> 00:04:27,550
this RT on mutex and a consequence of

00:04:25,180 --> 00:04:31,150
that is that yet RTL mutex can be hold

00:04:27,550 --> 00:04:34,240
for a very long time so for instance the

00:04:31,150 --> 00:04:35,860
act the do it callback might sleep for a

00:04:34,240 --> 00:04:37,710
brief moment because it has to wait for

00:04:35,860 --> 00:04:40,270
a kernel memory allocation to complete

00:04:37,710 --> 00:04:41,480
there are more expensive operations I

00:04:40,270 --> 00:04:44,630
like synchronized net

00:04:41,480 --> 00:04:46,100
which could cause this thing to wait for

00:04:44,630 --> 00:04:49,280
a couple of milliseconds and if you are

00:04:46,100 --> 00:04:51,020
looking for high numbers for instance

00:04:49,280 --> 00:04:53,090
consider a routing daemon that wants to

00:04:51,020 --> 00:04:56,450
insert tens of thousands of routes then

00:04:53,090 --> 00:04:57,950
this single mutex becomes a real pain

00:04:56,450 --> 00:05:00,920
point especially if you also consider

00:04:57,950 --> 00:05:03,070
other users that for instance want to

00:05:00,920 --> 00:05:11,690
look at statistics and traffic count and

00:05:03,070 --> 00:05:14,000
TC so what we would like to do is

00:05:11,690 --> 00:05:16,520
basically get rid of this single

00:05:14,000 --> 00:05:20,380
serialization step and make it so that

00:05:16,520 --> 00:05:23,090
different actions can happen in parallel

00:05:20,380 --> 00:05:26,270
but unfortunately most of the do would

00:05:23,090 --> 00:05:28,960
callbacks make assumptions on our TL

00:05:26,270 --> 00:05:34,280
mutex being held and protecting us from

00:05:28,960 --> 00:05:36,290
certain things so for instance the art

00:05:34,280 --> 00:05:38,540
in El loc obviously guarantees full

00:05:36,290 --> 00:05:41,990
contents consistency it was in a handler

00:05:38,540 --> 00:05:45,440
so if you check a property of say a

00:05:41,990 --> 00:05:47,960
network link inside a handler and then

00:05:45,440 --> 00:05:50,030
later make the same check again in the

00:05:47,960 --> 00:05:53,270
handlers and it's obviously not going to

00:05:50,030 --> 00:05:55,790
change because if it would have to be

00:05:53,270 --> 00:05:57,350
changed and someone else would have to

00:05:55,790 --> 00:05:59,690
grab this mutex which they can't of

00:05:57,350 --> 00:06:05,210
obviously do because you are owning it

00:05:59,690 --> 00:06:09,470
already so what we decided to do is we

00:06:05,210 --> 00:06:12,530
are now allowing in this register API we

00:06:09,470 --> 00:06:16,280
are allowing to say that if this message

00:06:12,530 --> 00:06:20,180
type is requested then we allow to say

00:06:16,280 --> 00:06:23,900
that it can be called without a mutex so

00:06:20,180 --> 00:06:27,350
what's happening now in linux 4.14 this

00:06:23,900 --> 00:06:29,330
mutex which was here normally it's no

00:06:27,350 --> 00:06:33,290
longer there and instead in this

00:06:29,330 --> 00:06:36,320
function there's now a check if you have

00:06:33,290 --> 00:06:39,830
decoded the type and function that you

00:06:36,320 --> 00:06:41,750
want to invoke check if the in kernel

00:06:39,830 --> 00:06:45,260
user has basically

00:06:41,750 --> 00:06:47,330
flagged this callback as it can run lot

00:06:45,260 --> 00:06:49,790
less and if so and lot less version is

00:06:47,330 --> 00:06:52,190
used and if not then the old one is used

00:06:49,790 --> 00:06:54,620
at this time most of the current will

00:06:52,190 --> 00:07:00,530
still use this fallback pass and do for

00:06:54,620 --> 00:07:02,200
serialization of RTL there were some

00:07:00,530 --> 00:07:04,400
low-hanging fruits that are already

00:07:02,200 --> 00:07:06,380
converted so for instance Artyom get

00:07:04,400 --> 00:07:07,820
route which is basically just an

00:07:06,380 --> 00:07:10,700
interface to use a space where user

00:07:07,820 --> 00:07:13,610
space can ask the kernel and which

00:07:10,700 --> 00:07:15,080
network interface packet would take if

00:07:13,610 --> 00:07:17,810
you give it a route in keys for instance

00:07:15,080 --> 00:07:19,220
IP addresses or a device information and

00:07:17,810 --> 00:07:21,410
then the kernel will say I don't have a

00:07:19,220 --> 00:07:25,520
route for this or it will go by at this

00:07:21,410 --> 00:07:27,680
interface and things like that other

00:07:25,520 --> 00:07:29,990
things that should be easy to convert or

00:07:27,680 --> 00:07:32,420
have been converted our handlers that

00:07:29,990 --> 00:07:35,120
use the different lock internally so one

00:07:32,420 --> 00:07:37,790
example would be ipv6 address labels

00:07:35,120 --> 00:07:40,430
because nothing in that functionality

00:07:37,790 --> 00:07:42,950
really needed the RT non-mutex to begin

00:07:40,430 --> 00:07:45,050
with and the address label database in

00:07:42,950 --> 00:07:50,050
the kernel already had a private lock

00:07:45,050 --> 00:07:52,850
for this so we could easily change that

00:07:50,050 --> 00:07:56,540
the main problem is that even if a

00:07:52,850 --> 00:07:59,390
handler doesn't modify anything then you

00:07:56,540 --> 00:08:01,490
take still guarantees consistency for

00:07:59,390 --> 00:08:03,260
instance you know that device in

00:08:01,490 --> 00:08:05,030
question will not silently go away

00:08:03,260 --> 00:08:07,730
underneath because you are holding the

00:08:05,030 --> 00:08:09,740
RTL mutex you know that the name is not

00:08:07,730 --> 00:08:10,610
going to change it's not going to be

00:08:09,740 --> 00:08:14,960
switched to a different network

00:08:10,610 --> 00:08:21,770
namespaces and all of that they are also

00:08:14,960 --> 00:08:23,690
various callbacks that the kernel has to

00:08:21,770 --> 00:08:27,170
deal with for instance a network

00:08:23,690 --> 00:08:30,170
interface being added or removed and all

00:08:27,170 --> 00:08:32,810
of those also depend on the RTL mutex so

00:08:30,170 --> 00:08:35,660
for instance if a driver is unloaded

00:08:32,810 --> 00:08:38,710
they say or you are someone unloads the

00:08:35,660 --> 00:08:40,880
module and that implements GRE tunnels

00:08:38,710 --> 00:08:42,890
where nothing bad will happen because

00:08:40,880 --> 00:08:45,890
all of this will be serialized by DRT

00:08:42,890 --> 00:08:48,530
now mutex as well and then we have the

00:08:45,890 --> 00:08:50,360
complex case with virtual interfaces and

00:08:48,530 --> 00:08:52,670
stacked setups like bonding or bridge

00:08:50,360 --> 00:08:56,030
where you have multiple interfaces on

00:08:52,670 --> 00:08:57,740
top of another and you obviously don't

00:08:56,030 --> 00:09:00,770
want bad things to happen just because

00:08:57,740 --> 00:09:06,290
someone else removed a stack device

00:09:00,770 --> 00:09:07,970
while you try to look at it it another

00:09:06,290 --> 00:09:08,420
example would be the functionality now

00:09:07,970 --> 00:09:11,000
fill

00:09:08,420 --> 00:09:14,060
if info which is used pretty frequently

00:09:11,000 --> 00:09:17,410
in most of dumpers and what it does it

00:09:14,060 --> 00:09:19,339
basically just marshals all the

00:09:17,410 --> 00:09:21,320
information in the kernel into user

00:09:19,339 --> 00:09:23,540
space format for instance the device

00:09:21,320 --> 00:09:26,630
name the transmit queue length sense of

00:09:23,540 --> 00:09:28,639
fun and so forth and we don't take any

00:09:26,630 --> 00:09:30,440
special precautions against changing

00:09:28,639 --> 00:09:32,269
information because we hold this mutex

00:09:30,440 --> 00:09:34,760
so you don't have to worry about the

00:09:32,269 --> 00:09:37,310
name being inconsistent and the users

00:09:34,760 --> 00:09:38,930
seeing something that is a mixture

00:09:37,310 --> 00:09:42,769
between the old and the new name and it

00:09:38,930 --> 00:09:44,660
gets renamed and really if you want to

00:09:42,769 --> 00:09:45,949
get rid of the are mutex we have to find

00:09:44,660 --> 00:09:48,199
solutions on how we can guarantee

00:09:45,949 --> 00:09:51,529
contents consistency even when we don't

00:09:48,199 --> 00:09:54,339
have the mutex anymore one thing that

00:09:51,529 --> 00:09:56,980
was very easy to convert is the AF ups

00:09:54,339 --> 00:10:01,310
basically the art in l AF ups contain

00:09:56,980 --> 00:10:04,339
family specific informations operations

00:10:01,310 --> 00:10:06,260
for instance ipv4 and ipv6 so there are

00:10:04,339 --> 00:10:08,420
not many of these in the kernel because

00:10:06,260 --> 00:10:10,370
we don't have that many address families

00:10:08,420 --> 00:10:13,010
in the kernel to begin with so it was

00:10:10,370 --> 00:10:14,959
easy to audit all of that and since not

00:10:13,010 --> 00:10:18,230
a single call back needs to sleep we can

00:10:14,959 --> 00:10:21,920
just protect this with our Cu and are

00:10:18,230 --> 00:10:26,240
done with it the more difficult one are

00:10:21,920 --> 00:10:28,040
the RTL link ups which implements in the

00:10:26,240 --> 00:10:29,990
kernel the part that is responsible for

00:10:28,040 --> 00:10:34,550
instance to bring up a new network link

00:10:29,990 --> 00:10:38,570
so if you configure a tunnel or tear

00:10:34,550 --> 00:10:41,000
down a bridge then special RTL link-up

00:10:38,570 --> 00:10:45,260
will be called for that implements the

00:10:41,000 --> 00:10:47,390
actual logic in the driver and obviously

00:10:45,260 --> 00:10:48,980
if we don't have art in analytics for

00:10:47,390 --> 00:10:51,140
that anymore then we need to find a way

00:10:48,980 --> 00:10:54,319
to be sure that nothing bad can happen

00:10:51,140 --> 00:10:56,720
when someone unloads the driver because

00:10:54,319 --> 00:10:58,579
we don't want another CPU to still call

00:10:56,720 --> 00:11:00,829
into that driver while it's being

00:10:58,579 --> 00:11:02,660
unloaded but fortunately it turned out

00:11:00,829 --> 00:11:05,690
that it's already safe at this point

00:11:02,660 --> 00:11:09,110
because as long as the callback either

00:11:05,690 --> 00:11:12,380
acquires mutex we are safe but we are

00:11:09,110 --> 00:11:15,920
also safe if the callback takes the RSU

00:11:12,380 --> 00:11:19,250
read lock while it's using or making

00:11:15,920 --> 00:11:20,740
calls into the original link ops and we

00:11:19,250 --> 00:11:22,920
are also safe when we

00:11:20,740 --> 00:11:26,110
increment a device reference count

00:11:22,920 --> 00:11:27,730
reason for that because if a driver is

00:11:26,110 --> 00:11:31,870
removed and a link ops up being

00:11:27,730 --> 00:11:33,850
unregistered then the kernel will have

00:11:31,870 --> 00:11:36,420
to wait until all the devices that are

00:11:33,850 --> 00:11:39,460
affected by this are being removed and

00:11:36,420 --> 00:11:42,550
this removal happens when Arjun allen

00:11:39,460 --> 00:11:44,530
mutex is unlocked and the device refcon

00:11:42,550 --> 00:11:46,960
must drop to zero for that so as long as

00:11:44,530 --> 00:11:52,090
we keep a device reference count we are

00:11:46,960 --> 00:11:53,950
also safe so general problems when

00:11:52,090 --> 00:11:55,300
converting this so the worst part is

00:11:53,950 --> 00:11:58,060
basically that we are talking about a

00:11:55,300 --> 00:12:00,820
huge amount of code and most of this

00:11:58,060 --> 00:12:03,580
stuff involves native operations and

00:12:00,820 --> 00:12:05,890
those bring the entire device drivers

00:12:03,580 --> 00:12:07,990
into the game so you really can't just

00:12:05,890 --> 00:12:10,060
look at the core code but you would have

00:12:07,990 --> 00:12:11,350
to also out it every single Network

00:12:10,060 --> 00:12:15,010
driver so a typical question would be

00:12:11,350 --> 00:12:19,540
for instance can I can when someone adds

00:12:15,010 --> 00:12:21,190
or floats for FTB can that work without

00:12:19,540 --> 00:12:22,780
any analytics and you would have to

00:12:21,190 --> 00:12:25,090
audit every single driver does it use it

00:12:22,780 --> 00:12:27,010
does it have a private lock yes or no

00:12:25,090 --> 00:12:28,930
and if no then I would have to add one

00:12:27,010 --> 00:12:31,030
so this quickly gets out of hand

00:12:28,930 --> 00:12:32,740
and the same question can we basically

00:12:31,030 --> 00:12:35,890
repeat it for every single otter and the

00:12:32,740 --> 00:12:39,250
o op or function that somehow interacts

00:12:35,890 --> 00:12:41,350
with device drivers and then as I

00:12:39,250 --> 00:12:43,210
mentioned we are not just dealing with

00:12:41,350 --> 00:12:45,220
data races we also dealing with trivial

00:12:43,210 --> 00:12:50,020
seemingly trivial things like parallel

00:12:45,220 --> 00:12:52,600
model removals one request moving at a

00:12:50,020 --> 00:12:55,780
network link to a different namespace

00:12:52,600 --> 00:12:58,180
and things like that and even worse our

00:12:55,780 --> 00:13:02,830
net device notifiers as we are about to

00:12:58,180 --> 00:13:05,890
find out so I will now give two examples

00:13:02,830 --> 00:13:07,780
of subsystems where I try to remove the

00:13:05,890 --> 00:13:10,090
art in a mutex because I at first at

00:13:07,780 --> 00:13:12,850
first I thought that it would be quite

00:13:10,090 --> 00:13:15,670
straightforward but in both cases it

00:13:12,850 --> 00:13:17,080
turned out to be quite problematic in

00:13:15,670 --> 00:13:19,450
the first one is define it and the other

00:13:17,080 --> 00:13:22,050
one is fit so let's first look at the

00:13:19,450 --> 00:13:28,030
fine init they find it basically just

00:13:22,050 --> 00:13:30,520
implements IP address management so IP

00:13:28,030 --> 00:13:32,410
addresses and things like that it also

00:13:30,520 --> 00:13:34,240
has a legacy i/o control based interface

00:13:32,410 --> 00:13:37,209
which also is you

00:13:34,240 --> 00:13:39,700
by the RT non-mutex so everything gets

00:13:37,209 --> 00:13:44,560
utilized no matter if you have if you're

00:13:39,700 --> 00:13:48,310
using old net tools like net shot or old

00:13:44,560 --> 00:13:54,820
route binary or the new IP tools it's

00:13:48,310 --> 00:13:58,089
always our teen net link so one problem

00:13:54,820 --> 00:14:01,870
is that when a new address is added to

00:13:58,089 --> 00:14:05,260
the system then it's not just that the

00:14:01,870 --> 00:14:07,540
kernel just does that but it not only

00:14:05,260 --> 00:14:09,850
validates the address but then it

00:14:07,540 --> 00:14:15,130
invokes and the network device notifier

00:14:09,850 --> 00:14:18,610
chain and that in turn makes calls into

00:14:15,130 --> 00:14:21,670
drivers for instance IP VLAN will listen

00:14:18,610 --> 00:14:24,220
to new addresses that are supposed to be

00:14:21,670 --> 00:14:26,529
configured and it can in fact veto and

00:14:24,220 --> 00:14:28,290
say no I cannot accept this new

00:14:26,529 --> 00:14:31,420
configuration that you want to add and

00:14:28,290 --> 00:14:36,370
in that case the requester add this new

00:14:31,420 --> 00:14:38,050
address would fail so obviously you need

00:14:36,370 --> 00:14:40,750
to see utilize that in some way because

00:14:38,050 --> 00:14:44,560
otherwise you could never be sure that

00:14:40,750 --> 00:14:47,200
the address that's being added could in

00:14:44,560 --> 00:14:48,730
fact generate a conflict with IP feel

00:14:47,200 --> 00:14:50,529
and if you can't guarantee that the

00:14:48,730 --> 00:14:55,899
state remains consistent while you are

00:14:50,529 --> 00:14:58,720
doing all these checks and that's quite

00:14:55,899 --> 00:15:03,370
a big problem and similar problems exist

00:14:58,720 --> 00:15:07,029
in fib again phoebus also see realized

00:15:03,370 --> 00:15:09,190
by this artino mutex I thought that it

00:15:07,029 --> 00:15:11,290
would be quite easy because the fit is

00:15:09,190 --> 00:15:13,089
mostly used from the packet path and the

00:15:11,290 --> 00:15:15,610
packet passive can take any mutexes

00:15:13,089 --> 00:15:18,430
because they sleep so the entire read

00:15:15,610 --> 00:15:22,029
only thing making lookups in the fibbies

00:15:18,430 --> 00:15:24,130
guarantee to be lock less so I thought

00:15:22,029 --> 00:15:26,079
we could just basically remove the RTL

00:15:24,130 --> 00:15:31,470
mutex and create a new private mutex for

00:15:26,079 --> 00:15:34,959
the FIB but it's not that easy because

00:15:31,470 --> 00:15:36,970
changes to the FIP can also incur

00:15:34,959 --> 00:15:41,380
indirectly by the kernel itself and not

00:15:36,970 --> 00:15:46,540
just on behalf of user space and it's

00:15:41,380 --> 00:15:48,100
not easy to use both new mutex and the

00:15:46,540 --> 00:15:49,900
RTL mutex at the same

00:15:48,100 --> 00:15:51,820
because whenever you have more than one

00:15:49,900 --> 00:15:53,920
lock involved and you always risk

00:15:51,820 --> 00:15:57,160
deadlock so you will have to keep very

00:15:53,920 --> 00:16:01,060
strict ordering on which lock is allowed

00:15:57,160 --> 00:16:02,440
to be taken first if you allow this so

00:16:01,060 --> 00:16:04,540
the problem is that all the network

00:16:02,440 --> 00:16:08,470
device no defiers are called with the

00:16:04,540 --> 00:16:11,770
RTL mutex already held so if we now

00:16:08,470 --> 00:16:13,840
allow changes to happen from the network

00:16:11,770 --> 00:16:16,270
device notifiers then you would have to

00:16:13,840 --> 00:16:18,640
take the private lock which means that

00:16:16,270 --> 00:16:20,410
the private lock is taken after the RTL

00:16:18,640 --> 00:16:23,110
mutex and once we allow that we cannot

00:16:20,410 --> 00:16:27,250
allow the reverse obviously because it

00:16:23,110 --> 00:16:30,780
would result in a deadlock so the second

00:16:27,250 --> 00:16:34,900
issue is the dumb consistency to check

00:16:30,780 --> 00:16:38,800
and the problem is basically that a net

00:16:34,900 --> 00:16:41,710
link dump can be very very large just

00:16:38,800 --> 00:16:45,580
consider a system that has maybe a lot

00:16:41,710 --> 00:16:48,160
of a large TC hierarchy with lots of

00:16:45,580 --> 00:16:49,600
classes and someone dumps that and you

00:16:48,160 --> 00:16:51,730
will get a lot of information that has

00:16:49,600 --> 00:16:53,020
been has to be brought to user space and

00:16:51,730 --> 00:16:55,870
it might not even fit in a single

00:16:53,020 --> 00:16:58,060
message and the way that is solved is

00:16:55,870 --> 00:17:01,720
that the dump request is allowed to span

00:16:58,060 --> 00:17:04,150
multiple messages but once you do that

00:17:01,720 --> 00:17:06,100
you have to release the lock obviously

00:17:04,150 --> 00:17:09,790
before you return to use the space

00:17:06,100 --> 00:17:11,800
so there is a small window where changes

00:17:09,790 --> 00:17:15,490
can come in while a dump is happening

00:17:11,800 --> 00:17:19,540
and you need some way to for the kernel

00:17:15,490 --> 00:17:22,000
and to notify use a space that a dump is

00:17:19,540 --> 00:17:24,459
possibly in consistence because some

00:17:22,000 --> 00:17:29,620
other changed change has happened in

00:17:24,459 --> 00:17:32,790
between so the way that is done usually

00:17:29,620 --> 00:17:36,040
is that you have some sort of counter

00:17:32,790 --> 00:17:40,060
that is incremented whenever change

00:17:36,040 --> 00:17:41,940
happens and when you start it done you

00:17:40,060 --> 00:17:44,350
just look at this counter value and

00:17:41,940 --> 00:17:46,660
after the dump is completed you will

00:17:44,350 --> 00:17:49,780
check if the counter has been changed

00:17:46,660 --> 00:17:52,750
and if it was changed then the colonel

00:17:49,780 --> 00:17:54,460
knows that something might be missing in

00:17:52,750 --> 00:17:56,410
the messages because we had to skip it

00:17:54,460 --> 00:17:59,320
because some data structure was

00:17:56,410 --> 00:18:01,420
inconsistent and we tell you space about

00:17:59,320 --> 00:18:06,730
that by setting a flag in the down

00:18:01,420 --> 00:18:10,260
message but the problem is that if yet

00:18:06,730 --> 00:18:14,200
if we now change counters that before

00:18:10,260 --> 00:18:16,780
were only changed under this RTL mutex

00:18:14,200 --> 00:18:20,050
if we make it for instance atomic to

00:18:16,780 --> 00:18:22,000
allow it to change in parallel then we

00:18:20,050 --> 00:18:24,490
can get still get situations where we

00:18:22,000 --> 00:18:27,010
might miss the fact that a dump was

00:18:24,490 --> 00:18:30,250
inconsistent even though it appears to

00:18:27,010 --> 00:18:33,610
not be so for instance consider two

00:18:30,250 --> 00:18:36,520
tasks a and B a adds a new flip entry

00:18:33,610 --> 00:18:39,970
and B makes a dump request of the FIP

00:18:36,520 --> 00:18:43,000
database it can happen that the flip

00:18:39,970 --> 00:18:45,070
entry is linked into the list and only

00:18:43,000 --> 00:18:47,380
then when the dump has already finished

00:18:45,070 --> 00:18:49,870
we make the modification to the counter

00:18:47,380 --> 00:18:52,900
this problem can't happen at the moment

00:18:49,870 --> 00:18:54,430
because the dumps and the changes can't

00:18:52,900 --> 00:18:56,290
occur in parallel in the first place

00:18:54,430 --> 00:19:00,760
because they are both here lies body art

00:18:56,290 --> 00:19:02,380
in l mutex so the only way we could

00:19:00,760 --> 00:19:04,690
possibly allow both to happen at the

00:19:02,380 --> 00:19:07,390
same time if we find a way to make these

00:19:04,690 --> 00:19:10,570
counters both atomic and allow at the

00:19:07,390 --> 00:19:13,030
same time to detect when a modification

00:19:10,570 --> 00:19:14,770
is happening right now so the only

00:19:13,030 --> 00:19:16,810
possible way out would be to somehow

00:19:14,770 --> 00:19:18,700
your sequence locks for this so that we

00:19:16,810 --> 00:19:20,740
know just from looking at a counter

00:19:18,700 --> 00:19:22,510
value if it's even or odd whether a

00:19:20,740 --> 00:19:24,850
change is happening right now and then

00:19:22,510 --> 00:19:28,260
we could possibly block either block to

00:19:24,850 --> 00:19:32,410
dump or just signal it as inconsistent

00:19:28,260 --> 00:19:36,490
and the last thing that is not so easy

00:19:32,410 --> 00:19:39,690
is lock less dumps which is very

00:19:36,490 --> 00:19:42,700
tempting because there's really no

00:19:39,690 --> 00:19:44,920
logical reason why we couldn't should

00:19:42,700 --> 00:19:47,580
not be able to say look at the fifth

00:19:44,920 --> 00:19:51,040
database while as someone else wants to

00:19:47,580 --> 00:19:53,290
configure acutest for instance so it

00:19:51,040 --> 00:19:56,380
would be very nice to allow both in

00:19:53,290 --> 00:19:59,830
parallel so that at least dumps which

00:19:56,380 --> 00:20:02,260
don't change any state can occur while

00:19:59,830 --> 00:20:03,880
and modifications happening this was

00:20:02,260 --> 00:20:05,530
already tried a few years back and it

00:20:03,880 --> 00:20:07,960
had to be reverted again because there's

00:20:05,530 --> 00:20:13,210
just too much code that makes these

00:20:07,960 --> 00:20:14,980
consistency assumptions so I started to

00:20:13,210 --> 00:20:18,010
have some patches except in the kernel

00:20:14,980 --> 00:20:19,690
already that reduces reduce the spots

00:20:18,010 --> 00:20:22,960
where we make these assumptions about

00:20:19,690 --> 00:20:24,940
consistency but it's not done yet so for

00:20:22,960 --> 00:20:27,280
instance we currently would crash if

00:20:24,940 --> 00:20:29,919
another CPU replaces the cue disk when a

00:20:27,280 --> 00:20:31,990
dump is in progress simply because there

00:20:29,919 --> 00:20:35,530
is no reference count that would prevent

00:20:31,990 --> 00:20:39,520
it from happening and then they are for

00:20:35,530 --> 00:20:41,200
instance if you dumped and user space

00:20:39,520 --> 00:20:42,700
will get information about the xep

00:20:41,200 --> 00:20:44,919
program that might be attached to the

00:20:42,700 --> 00:20:46,630
interface and there's nothing that would

00:20:44,919 --> 00:20:48,250
prevent bad things from happening if you

00:20:46,630 --> 00:20:51,760
don't take the arjun allu takes at that

00:20:48,250 --> 00:20:59,110
point other things are Silv information

00:20:51,760 --> 00:21:01,929
and link stats and stack devices so in

00:20:59,110 --> 00:21:04,360
summary you could basically say that the

00:21:01,929 --> 00:21:06,730
network contract pass has a gazillion of

00:21:04,360 --> 00:21:08,799
dependencies especially the network

00:21:06,730 --> 00:21:11,650
notifiers which are not very obvious so

00:21:08,799 --> 00:21:14,620
it's not really enough to just look at a

00:21:11,650 --> 00:21:17,049
code and it makes it really hard to

00:21:14,620 --> 00:21:19,240
remove our general locking the initial

00:21:17,049 --> 00:21:21,280
infrastructure is there because we can

00:21:19,240 --> 00:21:25,059
now basically annotate the handlers and

00:21:21,280 --> 00:21:27,880
make them lock less but to actually get

00:21:25,059 --> 00:21:30,010
most of the really important handlers to

00:21:27,880 --> 00:21:31,809
a point where we don't need to move

00:21:30,010 --> 00:21:35,880
ticks anymore it's going to it's going

00:21:31,809 --> 00:21:38,470
to be a long road ahead currently

00:21:35,880 --> 00:21:42,880
focusing on seeing whether we can make

00:21:38,470 --> 00:21:45,370
the dumps lock lists again by removing

00:21:42,880 --> 00:21:50,799
the spots that make our TL mutex

00:21:45,370 --> 00:21:53,880
assumptions any questions otherwise

00:21:50,799 --> 00:21:53,880
please find me later

00:21:59,780 --> 00:22:05,030
well about the part that at least as far

00:22:02,460 --> 00:22:08,220
as I'm concerned hurts most is the

00:22:05,030 --> 00:22:11,640
network namespaces when you call a

00:22:08,220 --> 00:22:14,150
cleanup net it can takes hundreds of

00:22:11,640 --> 00:22:17,310
milliseconds if you get even to three

00:22:14,150 --> 00:22:20,120
Network namespaces to clean up and then

00:22:17,310 --> 00:22:23,850
if you restore the application and

00:22:20,120 --> 00:22:26,220
cleanup net holds the RTL mutex and

00:22:23,850 --> 00:22:30,810
let's say just do a sis control to set

00:22:26,220 --> 00:22:32,820
ipv6 parameters at least in not in x86

00:22:30,810 --> 00:22:36,660
what we farm we got into a deadlock

00:22:32,820 --> 00:22:39,810
because in what happens is the sis

00:22:36,660 --> 00:22:43,710
control returns busy and in our mill if

00:22:39,810 --> 00:22:47,100
a system calls get busy it from the

00:22:43,710 --> 00:22:48,900
Cisco system call handler retries

00:22:47,100 --> 00:22:52,890
automatically without going back to user

00:22:48,900 --> 00:22:55,710
space say get into a deadlock and I

00:22:52,890 --> 00:22:59,900
think this part hurts the most and the

00:22:55,710 --> 00:22:59,900
only way around it is to visit the board

00:23:00,050 --> 00:23:07,470
[Music]

00:23:02,330 --> 00:23:10,440
in the upcoming channel 4.15 I divide it

00:23:07,470 --> 00:23:24,770
by 10/2 time in to dismantle net inist

00:23:10,440 --> 00:23:27,570
so should be good for you Erik so so we

00:23:24,770 --> 00:23:30,000
kind of make this problem worse in

00:23:27,570 --> 00:23:32,460
Wireless because we hold the RTL all the

00:23:30,000 --> 00:23:34,080
time and I'm thinking about how can we

00:23:32,460 --> 00:23:35,730
fix this because the only reason we

00:23:34,080 --> 00:23:37,320
really want to hold it is that we need

00:23:35,730 --> 00:23:38,820
to make sure that our net devs don't go

00:23:37,320 --> 00:23:41,250
away and we're sort of synchronized

00:23:38,820 --> 00:23:42,960
against all these notifiers that tell us

00:23:41,250 --> 00:23:45,870
your net if just went away because we

00:23:42,960 --> 00:23:49,190
rely heavily on the stack interacting

00:23:45,870 --> 00:23:51,780
there and the stack saying all right

00:23:49,190 --> 00:23:53,730
or I mean the net devstack telling the

00:23:51,780 --> 00:23:55,020
Wi-Fi stack right this net dev is going

00:23:53,730 --> 00:23:56,730
down or something and we need to

00:23:55,020 --> 00:23:58,470
interact with that and we can't really

00:23:56,730 --> 00:24:00,870
have any other operations going on at

00:23:58,470 --> 00:24:02,670
the same time so is there is there

00:24:00,870 --> 00:24:05,310
anything that you've done with respect

00:24:02,670 --> 00:24:06,710
to like splitting out certain things

00:24:05,310 --> 00:24:09,830
like the dev list

00:24:06,710 --> 00:24:11,270
I know there's a definite mutex also but

00:24:09,830 --> 00:24:14,210
it doesn't really seem to be used very

00:24:11,270 --> 00:24:15,649
much or in common usage so is there

00:24:14,210 --> 00:24:17,299
anything that you've done in that area

00:24:15,649 --> 00:24:19,399
where we could say all right let's just

00:24:17,299 --> 00:24:22,010
take the devilÃ­s mutex where we need to

00:24:19,399 --> 00:24:24,110
and then we can rely on all these other

00:24:22,010 --> 00:24:28,760
things all right on the serialization

00:24:24,110 --> 00:24:31,039
there no I looked at it I thought okay I

00:24:28,760 --> 00:24:32,779
can never get that done and quickly move

00:24:31,039 --> 00:24:36,110
to other tasks I thought we're simpler

00:24:32,779 --> 00:24:39,799
and then that's when I found out about

00:24:36,110 --> 00:24:42,230
an advice notifiers and yeah so I'm just

00:24:39,799 --> 00:24:45,559
looking at at the moment I'm pretty much

00:24:42,230 --> 00:24:48,080
just looking at making dumps lot less

00:24:45,559 --> 00:24:50,809
again or okay spur family a lot of

00:24:48,080 --> 00:24:52,820
family here enough right I think for

00:24:50,809 --> 00:24:55,130
Wi-Fi at least the dumps hopefully our

00:24:52,820 --> 00:24:57,049
luckiest or it could be made but but

00:24:55,130 --> 00:24:59,120
yeah we we hold I mean you mentioned we

00:24:57,049 --> 00:24:59,750
hold the RTL over a synchronize net or

00:24:59,120 --> 00:25:01,850
something like that

00:24:59,750 --> 00:25:03,470
right I mean we hold the RTL over

00:25:01,850 --> 00:25:05,570
sending commands to the devices and

00:25:03,470 --> 00:25:08,899
those might be on a USB bus that's not

00:25:05,570 --> 00:25:11,600
really not what you want to do but it's

00:25:08,899 --> 00:25:13,039
difficult to solve that because we you

00:25:11,600 --> 00:25:16,460
know can't just have the net def go away

00:25:13,039 --> 00:25:18,140
while we do something with it and we can

00:25:16,460 --> 00:25:20,750
hold it but then we need to look it up

00:25:18,140 --> 00:25:22,669
and we need we have all these quirks

00:25:20,750 --> 00:25:24,110
where we have a bunch of net dips right

00:25:22,669 --> 00:25:25,940
so we don't really want any one of them

00:25:24,110 --> 00:25:29,870
to go away so we don't want to hold all

00:25:25,940 --> 00:25:31,130
of them and you it gets tricky but yeah

00:25:29,870 --> 00:25:33,169
if there's nothing there we'll just

00:25:31,130 --> 00:25:36,020
maybe when I look at it but I won't

00:25:33,169 --> 00:25:44,179
promise anything yeah that's a good

00:25:36,020 --> 00:25:48,890
suggestion don't promise anything you

00:25:44,179 --> 00:25:51,320
spoke about notifiers so with this

00:25:48,890 --> 00:25:55,490
petition potential deadlock if you are

00:25:51,320 --> 00:25:58,010
using two metics so one idea would even

00:25:55,490 --> 00:26:00,080
truly to use a synchronous note if you

00:25:58,010 --> 00:26:02,570
are being able to post on it notifier

00:26:00,080 --> 00:26:04,190
and to run it later in the different

00:26:02,570 --> 00:26:09,970
context you're going to reform another

00:26:04,190 --> 00:26:09,970
process if needed

00:26:13,140 --> 00:26:17,670
yes it does not help for every villain

00:26:19,710 --> 00:26:23,590
you have this veto issue again right you

00:26:22,240 --> 00:26:25,180
need to notify er to do something and

00:26:23,590 --> 00:26:29,950
you need all of the no defiers to return

00:26:25,180 --> 00:26:31,180
all right this operation is fine not all

00:26:29,950 --> 00:26:32,290
of them need to be synchronous but there

00:26:31,180 --> 00:26:33,730
are a lot of them that need to be

00:26:32,290 --> 00:26:41,980
synchronous like can I bring this

00:26:33,730 --> 00:26:47,200
interface up and cutis code yes sir

00:26:41,980 --> 00:26:49,960
recent about adding synchronous core our

00:26:47,200 --> 00:26:52,840
superior and synchronous synchronizers

00:26:49,960 --> 00:26:55,750
you incur risk management code and

00:26:52,840 --> 00:26:58,270
that's awful because if you hold our tnl

00:26:55,750 --> 00:27:00,220
then you wait like sometimes 50

00:26:58,270 --> 00:27:05,380
milliseconds just to do the synchronize

00:27:00,220 --> 00:27:07,420
else you yeah 300 so basically I think I

00:27:05,380 --> 00:27:09,640
do think that all the key risks code

00:27:07,420 --> 00:27:13,000
should be not relying on our channel at

00:27:09,640 --> 00:27:15,400
all but use another vertex so if the

00:27:13,000 --> 00:27:17,260
Kudus code needs to send notifier i'm

00:27:15,400 --> 00:27:20,500
pretty sure that we don't need

00:27:17,260 --> 00:27:23,050
synchronous stuff for cuda skew disk is

00:27:20,500 --> 00:27:25,570
like well it should be completely

00:27:23,050 --> 00:27:34,900
different space I don't see any point

00:27:25,570 --> 00:27:36,970
for that so any more questions no yes

00:27:34,900 --> 00:27:39,690
let's just think fluorine for doing this

00:27:36,970 --> 00:27:39,690
huge effort

00:27:40,010 --> 00:27:45,950

YouTube URL: https://www.youtube.com/watch?v=M6RiQGNz4HE


