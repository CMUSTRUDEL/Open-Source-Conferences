Title: Accelerating XDP programs using HW-based hints
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: PJ Waskiewicz, Anjali Singhai Jain, Neerav Parikh
Friday November 09th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?waskiewicz-xdpacceleration-talk
Captions: 
	00:00:01,360 --> 00:00:10,299
all right good afternoon I'm PJ wasowicz

00:00:06,300 --> 00:00:12,009
I'm here with Anjali saying hi Jane we

00:00:10,299 --> 00:00:13,839
work for the networking division at

00:00:12,009 --> 00:00:16,630
Intel and we're going to be talking

00:00:13,839 --> 00:00:20,380
about some of the work that we're

00:00:16,630 --> 00:00:26,680
pursuing with XDP acceleration using

00:00:20,380 --> 00:00:30,310
hardware hints so the obligatory agenda

00:00:26,680 --> 00:00:34,060
slide everyone should know what X DP is

00:00:30,310 --> 00:00:36,730
by now but we'll go over the brief

00:00:34,060 --> 00:00:39,040
software model kind of highlighting the

00:00:36,730 --> 00:00:41,829
areas that we're trying to target with

00:00:39,040 --> 00:00:43,960
the work that we're doing and then

00:00:41,829 --> 00:00:47,739
describe what we mean by hardware hints

00:00:43,960 --> 00:00:49,480
in xdp programs have some performance

00:00:47,739 --> 00:00:51,850
results it's always good to use

00:00:49,480 --> 00:00:53,110
performance as a benchmark whether or

00:00:51,850 --> 00:00:55,570
not you're on the right track with

00:00:53,110 --> 00:00:57,940
something then we're going to talk about

00:00:55,570 --> 00:01:00,579
metadata layout considerations and this

00:00:57,940 --> 00:01:02,829
is an area that we're still under debate

00:01:00,579 --> 00:01:06,490
and we'll be looking at the community

00:01:02,829 --> 00:01:08,890
for which way we want to go and then

00:01:06,490 --> 00:01:10,870
Anjali you'll go into some of the

00:01:08,890 --> 00:01:13,180
dynamic things with programming the

00:01:10,870 --> 00:01:19,540
hints requesting hints and then we'll

00:01:13,180 --> 00:01:22,299
wrap up all right so just a brief recap

00:01:19,540 --> 00:01:25,420
for those who aren't intimately familiar

00:01:22,299 --> 00:01:30,790
with what XTP actually does it does make

00:01:25,420 --> 00:01:33,159
things go fast but how so the packet

00:01:30,790 --> 00:01:34,930
parsing engine 4x DP is to first

00:01:33,159 --> 00:01:37,689
identify the packet type right it starts

00:01:34,930 --> 00:01:40,210
parsing packet raw packet data that was

00:01:37,689 --> 00:01:42,850
DM made out of the NIC and hand it off

00:01:40,210 --> 00:01:44,110
to the X DB core and once we identify

00:01:42,850 --> 00:01:45,820
the packet type then we can start

00:01:44,110 --> 00:01:47,470
parsing it so we'll start extracting

00:01:45,820 --> 00:01:49,509
information out of the packet data

00:01:47,470 --> 00:01:51,490
whether it's in the header whether it's

00:01:49,509 --> 00:01:55,000
in the payload it really depends on what

00:01:51,490 --> 00:01:58,150
your xdp program is trying to do so

00:01:55,000 --> 00:02:00,759
based on that use case we might monitor

00:01:58,150 --> 00:02:03,430
incoming traffic on the network maybe

00:02:00,759 --> 00:02:05,049
make some counters as to say I've seen

00:02:03,430 --> 00:02:06,909
some Arps or I've been seeing some

00:02:05,049 --> 00:02:10,330
broadcast traffic anything that you're

00:02:06,909 --> 00:02:12,970
trying to do xdp programs may manipulate

00:02:10,330 --> 00:02:14,660
packets in the case of encapsulation

00:02:12,970 --> 00:02:17,580
decap

00:02:14,660 --> 00:02:19,230
forwarding you might want to swap source

00:02:17,580 --> 00:02:22,350
destination addresses and fire it back

00:02:19,230 --> 00:02:24,390
out on transmit and then you might do

00:02:22,350 --> 00:02:27,300
some computations you might compute

00:02:24,390 --> 00:02:29,790
hashes or have to recount recompute

00:02:27,300 --> 00:02:34,610
check sums for any packets that you

00:02:29,790 --> 00:02:37,410
modified and then based on map lookups

00:02:34,610 --> 00:02:39,540
and then based on all of the other

00:02:37,410 --> 00:02:41,850
information that you've accumulated the

00:02:39,540 --> 00:02:45,090
xt program makes a decision whether to

00:02:41,850 --> 00:02:48,090
drop accept the packet transmitted

00:02:45,090 --> 00:02:50,390
redirect it etc etc and then passes that

00:02:48,090 --> 00:02:54,300
back to the driver to tell it what to do

00:02:50,390 --> 00:02:55,080
so this is the basic format of what

00:02:54,300 --> 00:02:57,660
these things do

00:02:55,080 --> 00:03:00,750
and they are getting much more complex

00:02:57,660 --> 00:03:03,630
as things are evolving for those of you

00:03:00,750 --> 00:03:05,970
who rat Andy and yes pers talked

00:03:03,630 --> 00:03:10,530
yesterday about xtp kind of gave a good

00:03:05,970 --> 00:03:13,170
sequel to the last net dev showing how

00:03:10,530 --> 00:03:15,420
much XDP is evolved in a very short

00:03:13,170 --> 00:03:17,400
amount of time and it's not a

00:03:15,420 --> 00:03:18,750
coincidence that the core is evolved

00:03:17,400 --> 00:03:23,910
it's really because the programs are

00:03:18,750 --> 00:03:26,720
demanding it so our goal with the work

00:03:23,910 --> 00:03:29,670
that we're going to show you today is

00:03:26,720 --> 00:03:33,180
what can we use with present-day

00:03:29,670 --> 00:03:36,660
hardware right so if you have older

00:03:33,180 --> 00:03:38,490
older hardware can it do anything to

00:03:36,660 --> 00:03:40,580
help accelerate XDP and we believe it

00:03:38,490 --> 00:03:44,489
can

00:03:40,580 --> 00:03:46,770
so in the terms of packet processing we

00:03:44,489 --> 00:03:48,900
might be able to extract things like we

00:03:46,770 --> 00:03:51,540
identify packet type or we might be able

00:03:48,900 --> 00:03:54,540
to figure out where a header starts in

00:03:51,540 --> 00:03:58,830
the hardware so if we're able to do that

00:03:54,540 --> 00:04:00,420
and somehow I tell XDP about it then we

00:03:58,830 --> 00:04:01,470
can offset some of the CPU cycles that

00:04:00,420 --> 00:04:04,470
are used for this packet processing

00:04:01,470 --> 00:04:06,480
right I think Jason just mentioned in

00:04:04,470 --> 00:04:08,700
his last talk that if you have less code

00:04:06,480 --> 00:04:09,780
to run usually you go faster so if we're

00:04:08,700 --> 00:04:12,750
able to offset some of these

00:04:09,780 --> 00:04:15,209
computations in xdp then we have less

00:04:12,750 --> 00:04:19,590
instructions to compute on the cpu for

00:04:15,209 --> 00:04:21,720
that process we also want to keep this

00:04:19,590 --> 00:04:25,350
consistent with how xdp works today

00:04:21,720 --> 00:04:27,460
right a big point is to avoid kernel

00:04:25,350 --> 00:04:29,139
changes as much as possible

00:04:27,460 --> 00:04:31,960
right if you want to filter on something

00:04:29,139 --> 00:04:34,030
new or you want to identify a new header

00:04:31,960 --> 00:04:35,770
or a new packet you don't want to have

00:04:34,030 --> 00:04:38,889
to go ahead and inject some new patches

00:04:35,770 --> 00:04:40,630
or change some struts for that

00:04:38,889 --> 00:04:43,030
functionality you want to just go ahead

00:04:40,630 --> 00:04:47,800
and adjust your XDP program reload it

00:04:43,030 --> 00:04:51,880
and you're off and running now being a

00:04:47,800 --> 00:04:54,370
hardware vendor keeping it as Hardware

00:04:51,880 --> 00:04:55,960
agnostic as much as possible is usually

00:04:54,370 --> 00:04:58,000
the antithesis of what you're trying to

00:04:55,960 --> 00:04:59,380
do because you're trying to make

00:04:58,000 --> 00:05:02,800
something that goes fast on your stuff

00:04:59,380 --> 00:05:04,830
but this is a general-purpose framework

00:05:02,800 --> 00:05:08,740
that we would really like to play well

00:05:04,830 --> 00:05:10,539
with everyone else that uses this so our

00:05:08,740 --> 00:05:14,560
goal is really to try to keep any

00:05:10,539 --> 00:05:16,840
hardware specific that's out of this the

00:05:14,560 --> 00:05:19,900
best effort acceleration this is really

00:05:16,840 --> 00:05:22,150
getting down to kind of the previous

00:05:19,900 --> 00:05:24,400
slide about we're trying to use current

00:05:22,150 --> 00:05:28,870
day hardware or even older day hardware

00:05:24,400 --> 00:05:31,900
so if one network interface card may

00:05:28,870 --> 00:05:33,220
have an offload and another NIC in

00:05:31,900 --> 00:05:36,039
another system doesn't have that same

00:05:33,220 --> 00:05:39,520
offload then we want to make sure that

00:05:36,039 --> 00:05:40,630
xtp doesn't fall over we either can use

00:05:39,520 --> 00:05:42,280
the hint that comes out of the hardware

00:05:40,630 --> 00:05:43,780
that provides it and then if it doesn't

00:05:42,280 --> 00:05:50,770
provide it maybe we can provide a

00:05:43,780 --> 00:05:53,680
software fallback that's still TBD so

00:05:50,770 --> 00:05:57,190
the other two goals are really we want

00:05:53,680 --> 00:05:58,870
to also expose the flexibility as Nix

00:05:57,190 --> 00:06:03,060
becomes smarter yeah this whole smart

00:05:58,870 --> 00:06:05,080
NIC move Nix are going to be exposing

00:06:03,060 --> 00:06:07,330
packet processing pipelines that are

00:06:05,080 --> 00:06:10,380
programmable way beyond what they are

00:06:07,330 --> 00:06:14,860
today so we want to find a way to

00:06:10,380 --> 00:06:16,630
generically use XDP in any fashion to

00:06:14,860 --> 00:06:20,139
help teach it which hints that we are

00:06:16,630 --> 00:06:22,810
actually interested in and we believe

00:06:20,139 --> 00:06:26,080
that if we can really put the bits in

00:06:22,810 --> 00:06:28,080
place inside of xdp to harness all of

00:06:26,080 --> 00:06:31,419
this capability and flexibility to

00:06:28,080 --> 00:06:32,620
provide hints program hints extract

00:06:31,419 --> 00:06:34,599
hints

00:06:32,620 --> 00:06:35,949
that'll make future hardware designs

00:06:34,599 --> 00:06:38,949
much more interesting because they'll

00:06:35,949 --> 00:06:42,029
have more capabilities in the stack not

00:06:38,949 --> 00:06:42,029
requiring kernel changes

00:06:43,330 --> 00:06:51,500
so this is just a simple diagram kind of

00:06:48,530 --> 00:06:54,800
outlining the the flow that was back on

00:06:51,500 --> 00:06:58,280
the data flow so the bottom part here is

00:06:54,800 --> 00:07:00,470
really down on the hardware and it

00:06:58,280 --> 00:07:02,840
really signifies kind of how a packet

00:07:00,470 --> 00:07:04,040
parser works in the neck right so first

00:07:02,840 --> 00:07:06,500
thing is that you identify what the

00:07:04,040 --> 00:07:08,090
packet type is internally to the parser

00:07:06,500 --> 00:07:09,320
and the hardware then you start

00:07:08,090 --> 00:07:11,120
extracting things that you've been told

00:07:09,320 --> 00:07:14,480
to extract whether it's you know a five

00:07:11,120 --> 00:07:16,970
tuple or four tuple you might do some

00:07:14,480 --> 00:07:20,600
map lookups you may compute some things

00:07:16,970 --> 00:07:22,070
like a RSS hash for example and then

00:07:20,600 --> 00:07:23,720
this metadata thing is what we'll get

00:07:22,070 --> 00:07:25,850
into with the hardware hints and this is

00:07:23,720 --> 00:07:29,120
going to be can we populate some

00:07:25,850 --> 00:07:34,850
metadata to then pass off to XDP through

00:07:29,120 --> 00:07:37,910
the XDP packet buffer so this is all

00:07:34,850 --> 00:07:39,140
good but to kind of boil down what are

00:07:37,910 --> 00:07:42,020
the two problems that we are trying to

00:07:39,140 --> 00:07:43,430
solve right now the first one is how do

00:07:42,020 --> 00:07:45,470
we dynamically program the hardware

00:07:43,430 --> 00:07:47,750
right so some hardware is more

00:07:45,470 --> 00:07:51,440
programmable than others right now that

00:07:47,750 --> 00:07:54,920
won't be the case in the future so how

00:07:51,440 --> 00:07:56,750
can we in tandem program the hardware to

00:07:54,920 --> 00:07:58,640
work with the XDP program that is going

00:07:56,750 --> 00:08:01,550
to try to parse and use the hints that

00:07:58,640 --> 00:08:02,690
it's going to be providing so that's one

00:08:01,550 --> 00:08:06,440
problem and anjali is going to talk

00:08:02,690 --> 00:08:08,270
about that the other problem is how do

00:08:06,440 --> 00:08:10,160
we then once we have that data coming

00:08:08,270 --> 00:08:15,410
out of the hardware how do we pass it

00:08:10,160 --> 00:08:17,300
off from the driver into XDP and that is

00:08:15,410 --> 00:08:24,110
going to be something that I'll talk

00:08:17,300 --> 00:08:26,630
about so that didn't render very well

00:08:24,110 --> 00:08:28,820
so Daniel Berkman had a patch set and

00:08:26,630 --> 00:08:31,130
this was mentioned in Andy's and yes

00:08:28,820 --> 00:08:33,500
pers talked that there was a recent

00:08:31,130 --> 00:08:35,510
patch that went in that added this data

00:08:33,500 --> 00:08:37,370
meta pointer which I love the name by

00:08:35,510 --> 00:08:41,180
the way and screws me up all the time

00:08:37,370 --> 00:08:43,100
instead of meta data but there's this

00:08:41,180 --> 00:08:47,690
data meta pointer that was added to

00:08:43,100 --> 00:08:50,480
allow passing data from the xdp core

00:08:47,690 --> 00:08:53,720
into the SK B's that could be used later

00:08:50,480 --> 00:08:54,470
up in the stack and they kind of hide it

00:08:53,720 --> 00:08:56,300
in the head room

00:08:54,470 --> 00:08:58,280
that is allocated as part of the XDP

00:08:56,300 --> 00:09:00,680
packet buffer so we looked at it and

00:08:58,280 --> 00:09:02,090
said heck we can go ahead and stick

00:09:00,680 --> 00:09:06,530
something in there from the driver to

00:09:02,090 --> 00:09:08,540
XDP and it works kind of like the the CB

00:09:06,530 --> 00:09:10,010
the control block and the SK buff that

00:09:08,540 --> 00:09:11,840
once you go up to the next layer

00:09:10,010 --> 00:09:14,750
it's no guarantee that it's going to

00:09:11,840 --> 00:09:16,070
survive and we really don't care so this

00:09:14,750 --> 00:09:18,530
is where we're going to start hiding our

00:09:16,070 --> 00:09:22,580
metadata for packaging it I guess should

00:09:18,530 --> 00:09:25,340
be a better word alright so before we

00:09:22,580 --> 00:09:27,590
get into the how and then people can

00:09:25,340 --> 00:09:29,510
start heckling we'll talk about the

00:09:27,590 --> 00:09:33,680
performance because that will kind of

00:09:29,510 --> 00:09:36,050
help smooth the road this is all

00:09:33,680 --> 00:09:40,130
internal testing this wasn't done by any

00:09:36,050 --> 00:09:44,080
of our official perf labs so numbers are

00:09:40,130 --> 00:09:49,400
TBD but the target was an Ivy Bridge

00:09:44,080 --> 00:09:53,600
Xeon system we were using the 25 gig I

00:09:49,400 --> 00:09:56,600
for TE device single R X cubed pinned

00:09:53,600 --> 00:09:58,850
interrupt blah blah blah and then we had

00:09:56,600 --> 00:10:00,470
a couple x DP programs so the first

00:09:58,850 --> 00:10:03,290
thing that we did was take a benchmark

00:10:00,470 --> 00:10:07,610
of X DP 1 so the sample X DP 1 and the

00:10:03,290 --> 00:10:10,100
kernel which parses out data identifies

00:10:07,610 --> 00:10:12,170
the packet type and then if it's an ipv4

00:10:10,100 --> 00:10:14,690
packet it increments a counter and the

00:10:12,170 --> 00:10:17,390
maps and then drops it so it identifies

00:10:14,690 --> 00:10:18,920
the packet by reading the packet data

00:10:17,390 --> 00:10:23,060
that came over from the driver and then

00:10:18,920 --> 00:10:25,130
drops it XD p3 was a modified version of

00:10:23,060 --> 00:10:27,260
that that we wanted to see what is the

00:10:25,130 --> 00:10:29,540
absolute fastest way that we can drop a

00:10:27,260 --> 00:10:31,790
packet so we said we're not going to

00:10:29,540 --> 00:10:34,190
parse the packet at all and we're just

00:10:31,790 --> 00:10:36,920
going to drop it so this should show

00:10:34,190 --> 00:10:40,970
that Delta between what is the hit by

00:10:36,920 --> 00:10:43,460
reading the packet buffer itself then

00:10:40,970 --> 00:10:46,490
xdb hints is a modification of X DP 1

00:10:43,460 --> 00:10:49,490
which is still go ahead and check if

00:10:46,490 --> 00:10:50,720
it's an ipv4 packet but use a hint

00:10:49,490 --> 00:10:57,170
that's provided by the driver

00:10:50,720 --> 00:11:00,980
so don't parse it in the xtp program so

00:10:57,170 --> 00:11:05,120
reading this left-to-right the first

00:11:00,980 --> 00:11:07,040
three bars correspond to non JIT and

00:11:05,120 --> 00:11:09,430
then the last three bars are the same

00:11:07,040 --> 00:11:09,430
programs

00:11:09,740 --> 00:11:17,480
so the important one here is look at the

00:11:12,110 --> 00:11:19,129
yellow one which it's right there so

00:11:17,480 --> 00:11:21,110
that is about seven and a half

00:11:19,129 --> 00:11:23,389
ish eight million packets per second oh

00:11:21,110 --> 00:11:25,579
do I have a little sappy thing all right

00:11:23,389 --> 00:11:27,529
sweet so this is about seven and a half

00:11:25,579 --> 00:11:32,149
million packets per second with the

00:11:27,529 --> 00:11:35,480
packet parsing to drop then XTP 3 which

00:11:32,149 --> 00:11:38,720
is just pure drop we cap out at like 21

00:11:35,480 --> 00:11:41,149
million packets per second so then the

00:11:38,720 --> 00:11:43,540
xdp hints which again is the same as XTP

00:11:41,149 --> 00:11:47,420
one but using the hint out of the driver

00:11:43,540 --> 00:11:51,259
still doing the drop if it's ipv4 we hit

00:11:47,420 --> 00:11:54,050
the same cap this cap we found as an

00:11:51,259 --> 00:11:56,420
artificial cap because of some

00:11:54,050 --> 00:11:58,100
limitations with certain counters that

00:11:56,420 --> 00:12:00,529
were on in our nick when we were doing

00:11:58,100 --> 00:12:02,300
the benchmarking so we know that this

00:12:00,529 --> 00:12:05,649
can go faster we just didn't have the

00:12:02,300 --> 00:12:08,870
time to adjust the test before net Devin

00:12:05,649 --> 00:12:11,930
but to look at the non jet version so XD

00:12:08,870 --> 00:12:13,819
p3 non jet is about 18 million packets

00:12:11,930 --> 00:12:17,540
per second again this is the just pure

00:12:13,819 --> 00:12:21,829
drop no parsing and then the XDP hints

00:12:17,540 --> 00:12:23,899
is about 14 million so extrapolating

00:12:21,829 --> 00:12:27,139
this I would imagine that we would see

00:12:23,899 --> 00:12:29,509
kind of that same Delta but it's still a

00:12:27,139 --> 00:12:31,160
pretty dramatic increase from XD p1

00:12:29,509 --> 00:12:35,209
where we're actually doing the packet

00:12:31,160 --> 00:12:37,189
parsing itself so right now at the cap

00:12:35,209 --> 00:12:44,660
we're looking at about a 3x increase in

00:12:37,189 --> 00:12:47,120
performance so next steps that we know

00:12:44,660 --> 00:12:51,589
that we want to do think yes per had

00:12:47,120 --> 00:12:55,069
this comment off line to me which was

00:12:51,589 --> 00:12:57,769
can we look at new rosy on systems so

00:12:55,069 --> 00:13:00,559
broad well maybe skylake and see if we

00:12:57,769 --> 00:13:05,839
have any DDI Oh direct data i/o

00:13:00,559 --> 00:13:07,519
performance improvements we also want to

00:13:05,839 --> 00:13:09,889
right now the way that we have the the

00:13:07,519 --> 00:13:13,160
patches which are kind of a hack we do

00:13:09,889 --> 00:13:16,819
mem copies into the into that xdp

00:13:13,160 --> 00:13:18,439
metadata location so maybe we can do

00:13:16,819 --> 00:13:20,070
some tricks there with doing direct

00:13:18,439 --> 00:13:21,600
EMA's if we can

00:13:20,070 --> 00:13:24,509
we want to go ahead and explore that and

00:13:21,600 --> 00:13:27,480
see just how much of a hit that mem copy

00:13:24,509 --> 00:13:31,290
is and then obviously we need to test

00:13:27,480 --> 00:13:34,860
with bigger XDP programs and cap T cap

00:13:31,290 --> 00:13:35,850
load balancer etc etc so that's kind of

00:13:34,860 --> 00:13:43,850
the next steps where we're gonna go

00:13:35,850 --> 00:13:43,850
after this all right so now the fun part

00:13:44,209 --> 00:13:48,180
so we're trying to figure out how do we

00:13:46,560 --> 00:13:50,610
actually stick this data in the metadata

00:13:48,180 --> 00:13:54,000
fields right and so we yet we came up

00:13:50,610 --> 00:13:56,519
with three approaches these are going to

00:13:54,000 --> 00:13:57,660
be the points of discussion I think in

00:13:56,519 --> 00:13:59,819
the community and that's the whole point

00:13:57,660 --> 00:14:02,250
that we brought this here the first

00:13:59,819 --> 00:14:04,110
approach is to define a common layout

00:14:02,250 --> 00:14:05,370
independent of underlying hardware so

00:14:04,110 --> 00:14:09,000
actually build a struct that we're gonna

00:14:05,370 --> 00:14:12,810
stick in the XDP meta location or data

00:14:09,000 --> 00:14:14,779
meta this I think is going to be a

00:14:12,810 --> 00:14:20,279
pretty big lift right this is now

00:14:14,779 --> 00:14:21,630
imposing ABI on that location the

00:14:20,279 --> 00:14:22,740
community would have to agree on it the

00:14:21,630 --> 00:14:25,230
hardware vendors would also have to

00:14:22,740 --> 00:14:27,029
agree on it based on whatever types of

00:14:25,230 --> 00:14:29,639
metadata that they're producing out of

00:14:27,029 --> 00:14:32,550
their hardware so once we define that

00:14:29,639 --> 00:14:36,930
and merged it it's going to be pretty

00:14:32,550 --> 00:14:39,690
pretty rigid so I'm not a huge fan of

00:14:36,930 --> 00:14:42,510
this but but you know if that's the way

00:14:39,690 --> 00:14:44,819
that we go that's the way we go the

00:14:42,510 --> 00:14:47,970
second approach is to put in vendor

00:14:44,819 --> 00:14:49,620
libraries in the EBP F in BPF lab so

00:14:47,970 --> 00:14:53,519
have some wrappers with some helper

00:14:49,620 --> 00:14:56,100
functions this would require your xt

00:14:53,519 --> 00:15:00,209
programs to detect the underlying

00:14:56,100 --> 00:15:02,010
hardware in order to know which which

00:15:00,209 --> 00:15:05,730
helped her to call and i'm not sure that

00:15:02,010 --> 00:15:07,139
that's going to be particularly nice we

00:15:05,730 --> 00:15:08,730
don't know how much overhead that will

00:15:07,139 --> 00:15:09,240
cause with all of the layers of

00:15:08,730 --> 00:15:10,740
indirection

00:15:09,240 --> 00:15:14,850
but it's another approach we thought

00:15:10,740 --> 00:15:18,300
about and the last one we kind of had

00:15:14,850 --> 00:15:21,240
this shortly before this conference is

00:15:18,300 --> 00:15:22,649
what have we changed EP programs so

00:15:21,240 --> 00:15:26,250
there was some recent work to allow this

00:15:22,649 --> 00:15:27,839
to happen in in BPF so we would have a

00:15:26,250 --> 00:15:30,180
lightweight shim attached to the driver

00:15:27,839 --> 00:15:33,510
itself that would contain the vendor

00:15:30,180 --> 00:15:35,100
specific logic and then we would have a

00:15:33,510 --> 00:15:37,020
another bigger program which is like

00:15:35,100 --> 00:15:39,500
maybe your load balancer or your and got

00:15:37,020 --> 00:15:42,600
ECAP that has all your business logic

00:15:39,500 --> 00:15:47,090
that would be tail called into with the

00:15:42,600 --> 00:15:49,380
metadata passed in this one still has a

00:15:47,090 --> 00:15:53,910
lot of work to do to see if this is even

00:15:49,380 --> 00:15:57,860
feasible but oh wow that looks really

00:15:53,910 --> 00:16:00,390
terrible anyways this was just kind of a

00:15:57,860 --> 00:16:02,400
an overview of that that little shim

00:16:00,390 --> 00:16:03,390
program you have your jump tables and

00:16:02,400 --> 00:16:06,270
then you would have to do some jump

00:16:03,390 --> 00:16:08,280
table manipulation when you load the

00:16:06,270 --> 00:16:10,590
programs we're not entirely sure if this

00:16:08,280 --> 00:16:12,540
is going to work yet there's a lot of

00:16:10,590 --> 00:16:14,100
work here that we have to do this

00:16:12,540 --> 00:16:27,930
picture renders a lot nicer in the paper

00:16:14,100 --> 00:16:32,160
as well alright so Anjali okay so PJ

00:16:27,930 --> 00:16:35,220
went over one of the problems in kind of

00:16:32,160 --> 00:16:37,830
passing the hints into the EVP of

00:16:35,220 --> 00:16:40,290
programs that are containing the

00:16:37,830 --> 00:16:41,970
business logic and you know the three

00:16:40,290 --> 00:16:44,280
approaches and we don't really know

00:16:41,970 --> 00:16:47,490
which way we're gonna go forward with it

00:16:44,280 --> 00:16:50,040
but you know that's the part he was

00:16:47,490 --> 00:16:55,140
covering the part I am going to talk

00:16:50,040 --> 00:16:58,440
about is how do I know what hints are

00:16:55,140 --> 00:17:01,680
useful for a given IPPF program and how

00:16:58,440 --> 00:17:03,150
does that how does the driver get to

00:17:01,680 --> 00:17:09,000
know about it and program the hardware

00:17:03,150 --> 00:17:11,370
correctly so you know one way we could

00:17:09,000 --> 00:17:15,660
do this is using again

00:17:11,370 --> 00:17:21,510
you know the TC tools if flour or you 32

00:17:15,660 --> 00:17:22,800
whatever there are some obvious issues

00:17:21,510 --> 00:17:25,589
here

00:17:22,800 --> 00:17:28,110
first of all any changes that we'll have

00:17:25,589 --> 00:17:29,670
to do to kind of implement actions for

00:17:28,110 --> 00:17:32,070
passing hints to the exhibit program

00:17:29,670 --> 00:17:36,110
would require extensions of TC which

00:17:32,070 --> 00:17:39,630
will require kernel changes and you know

00:17:36,110 --> 00:17:40,980
it's one of the goals as we highlighted

00:17:39,630 --> 00:17:44,880
earlier we really want to minimize

00:17:40,980 --> 00:17:46,780
kernel changes for taking benefit of the

00:17:44,880 --> 00:17:48,940
hardware hints

00:17:46,780 --> 00:17:51,370
you know there are definite limitations

00:17:48,940 --> 00:17:59,230
with going ahead and programming the

00:17:51,370 --> 00:18:08,500
hardware using TC to get the benefits so

00:17:59,230 --> 00:18:10,679
we went ahead and so we went ahead and

00:18:08,500 --> 00:18:18,240
kind of imagined a different kind of

00:18:10,679 --> 00:18:21,970
solution to kind of you know passing

00:18:18,240 --> 00:18:24,340
information to the driver so that it can

00:18:21,970 --> 00:18:27,090
generate the right kind of hints and we

00:18:24,340 --> 00:18:29,530
believe with this method you have

00:18:27,090 --> 00:18:33,270
one-time changes into the kernel but

00:18:29,530 --> 00:18:36,070
then for the long run it just kind of

00:18:33,270 --> 00:18:39,490
doesn't require any further changes even

00:18:36,070 --> 00:18:43,000
if you know the kind of hints that are

00:18:39,490 --> 00:18:44,710
being delivered change as well as you

00:18:43,000 --> 00:18:49,200
know your business logic changes and you

00:18:44,710 --> 00:18:53,500
know so the proposal that we have is

00:18:49,200 --> 00:18:57,850
basically when you know you're you write

00:18:53,500 --> 00:19:01,929
your business logic and C code for and

00:18:57,850 --> 00:19:04,809
use the LLVM to compile and generate the

00:19:01,929 --> 00:19:08,429
the bytecode which is the you know the

00:19:04,809 --> 00:19:12,460
elf file we basically stick the hints in

00:19:08,429 --> 00:19:18,490
some special header sections inside the

00:19:12,460 --> 00:19:22,630
elf file itself and and then you know

00:19:18,490 --> 00:19:25,150
those sections most likely are skipped

00:19:22,630 --> 00:19:29,530
over by the file loader the verifier and

00:19:25,150 --> 00:19:33,340
stuff like that and some kind of an OS

00:19:29,530 --> 00:19:35,950
API will have to be developed so it when

00:19:33,340 --> 00:19:41,730
the when the bytecode gets loaded into

00:19:35,950 --> 00:19:45,669
the kernel it kind of extracts the

00:19:41,730 --> 00:19:48,730
special you know the sections that are

00:19:45,669 --> 00:19:50,590
there in the if you've byte code and you

00:19:48,730 --> 00:19:52,809
know passes it over to the driver so

00:19:50,590 --> 00:19:54,250
that it can learn about what hints it

00:19:52,809 --> 00:19:57,070
should program in its programmable

00:19:54,250 --> 00:19:58,530
pipeline which will be usable for a

00:19:57,070 --> 00:20:04,710
given

00:19:58,530 --> 00:20:08,730
business logic okay so this slide is

00:20:04,710 --> 00:20:15,570
more about what can we do right now in

00:20:08,730 --> 00:20:18,780
terms of hardware hints and it's it's

00:20:15,570 --> 00:20:22,110
based on what we understand is useful

00:20:18,780 --> 00:20:26,190
for most of the use cases out there

00:20:22,110 --> 00:20:29,970
which are doing packet processing using

00:20:26,190 --> 00:20:33,900
the code so there are three different

00:20:29,970 --> 00:20:37,590
kinds of hardware hints that we believe

00:20:33,900 --> 00:20:40,530
most hardware can pass one is the

00:20:37,590 --> 00:20:43,350
parsing hints basically identifying the

00:20:40,530 --> 00:20:46,559
packet type and that was again one of

00:20:43,350 --> 00:20:48,690
the benchmarking data gathering that we

00:20:46,559 --> 00:20:50,760
did was using the first hand witches

00:20:48,690 --> 00:20:54,480
just identifying what kind of packet it

00:20:50,760 --> 00:20:59,539
is and so that the the EPF code doesn't

00:20:54,480 --> 00:21:03,960
have to kind of do that in software and

00:20:59,539 --> 00:21:06,330
then the other two fall in the same

00:21:03,960 --> 00:21:09,030
category where a lot of these programs

00:21:06,330 --> 00:21:12,419
want a particular field extracted from

00:21:09,030 --> 00:21:14,789
the packet or be able to get to a

00:21:12,419 --> 00:21:21,330
particular offset in the packet so that

00:21:14,789 --> 00:21:23,909
it can very quickly you know either use

00:21:21,330 --> 00:21:25,230
it for modifying the packet or compare

00:21:23,909 --> 00:21:28,559
it against us

00:21:25,230 --> 00:21:34,110
you know a value to kind of decide the

00:21:28,559 --> 00:21:37,789
action further so those are the parsing

00:21:34,110 --> 00:21:40,200
hints that most hardware can provide

00:21:37,789 --> 00:21:44,150
including the Intel hardware that we

00:21:40,200 --> 00:21:49,320
have right now the other two categories

00:21:44,150 --> 00:21:52,350
is more the bottom one is more about you

00:21:49,320 --> 00:21:55,679
know the compute kind of hints which is

00:21:52,350 --> 00:21:58,440
the hardware has already computed either

00:21:55,679 --> 00:22:01,890
the checks checksum on the packet or you

00:21:58,440 --> 00:22:03,960
know the hash on certain fields or you

00:22:01,890 --> 00:22:06,450
know it has marked the packet with a

00:22:03,960 --> 00:22:09,419
timestamp or something and if that's

00:22:06,450 --> 00:22:10,919
useful for making decisions for the

00:22:09,419 --> 00:22:14,580
business logic that's the other

00:22:10,919 --> 00:22:18,659
hint that the hard way can provide the

00:22:14,580 --> 00:22:23,129
middle one is more of you know this is

00:22:18,659 --> 00:22:28,070
similar to escapee mark that we have

00:22:23,129 --> 00:22:30,659
we're hard we can identify you know

00:22:28,070 --> 00:22:33,570
particular set of fields and match

00:22:30,659 --> 00:22:38,070
against values most hardware have a very

00:22:33,570 --> 00:22:43,470
huge lookup table exact match or LPM

00:22:38,070 --> 00:22:45,629
table ACS whatnot and it can use that to

00:22:43,470 --> 00:22:49,169
mark a particular flow with a software

00:22:45,629 --> 00:22:54,419
marker that gets passed as a hint to the

00:22:49,169 --> 00:22:57,659
PPF program and we believe this one

00:22:54,419 --> 00:23:00,059
you know the map offload would have you

00:22:57,659 --> 00:23:05,639
know the longest bang for the buck kind

00:23:00,059 --> 00:23:08,480
of thing in terms of hints yeah sure we

00:23:05,639 --> 00:23:08,480
can move on to the next one

00:23:08,539 --> 00:23:12,059
up to now I don't know how you're

00:23:10,919 --> 00:23:19,679
passing this since I know there's a

00:23:12,059 --> 00:23:28,679
buffer is it a TLV what is it so you're

00:23:19,679 --> 00:23:30,840
referring to the the hints so this would

00:23:28,679 --> 00:23:34,309
be part of that that metadata field that

00:23:30,840 --> 00:23:37,169
we're hiding in the XD buffer headroom

00:23:34,309 --> 00:23:38,820
but the layout of how we're going to

00:23:37,169 --> 00:23:41,519
actually pass that through is that's the

00:23:38,820 --> 00:23:42,960
TBD part we currently have patches where

00:23:41,519 --> 00:23:46,649
we're just mem copying things out of our

00:23:42,960 --> 00:23:48,509
received descriptors into an opaque

00:23:46,649 --> 00:23:50,639
pointer that we define a struct but

00:23:48,509 --> 00:23:58,649
that's not something that is up

00:23:50,639 --> 00:24:00,210
streamable yet yeah we definitely need

00:23:58,649 --> 00:24:03,659
to discuss this because what we did is

00:24:00,210 --> 00:24:06,149
we are assuming the layout for right now

00:24:03,659 --> 00:24:09,059
where those hints are in the metadata

00:24:06,149 --> 00:24:10,909
and using it but that isn't it's not a

00:24:09,059 --> 00:24:18,359
hard way agnostic way of doing it so

00:24:10,909 --> 00:24:20,609
yeah okay so this is again going into

00:24:18,359 --> 00:24:22,830
how do i program my hardware to get the

00:24:20,609 --> 00:24:23,879
right kind of pins and we believe we can

00:24:22,830 --> 00:24:26,519
use some

00:24:23,879 --> 00:24:29,629
special headers to request these hands

00:24:26,519 --> 00:24:33,749
and there are some examples of of those

00:24:29,629 --> 00:24:37,349
you know one of them could be give me

00:24:33,749 --> 00:24:40,589
the offset to the inner l4 header and

00:24:37,349 --> 00:24:42,209
you could get that you know programmed

00:24:40,589 --> 00:24:45,419
in the hardware and then how I can give

00:24:42,209 --> 00:24:48,209
you back where the l4 header starts you

00:24:45,419 --> 00:24:50,459
can get the p-type or you could last one

00:24:48,209 --> 00:24:52,199
is more about this KB more kind of thing

00:24:50,459 --> 00:24:54,059
that I was talking about where you could

00:24:52,199 --> 00:24:56,519
define a packet match criteria and

00:24:54,059 --> 00:25:00,149
market with a particular ID in this case

00:24:56,519 --> 00:25:01,499
25 or something and then you get that as

00:25:00,149 --> 00:25:11,059
part of your hint that it actually

00:25:01,499 --> 00:25:11,059
matched that particular flow okay so

00:25:13,069 --> 00:25:19,289
based on what I was describing earlier

00:25:15,509 --> 00:25:21,719
we will have to somehow get that

00:25:19,289 --> 00:25:25,579
information about the special headers

00:25:21,719 --> 00:25:27,899
that are in the elf file into the driver

00:25:25,579 --> 00:25:29,669
for the driver to be able to program it

00:25:27,899 --> 00:25:33,449
and so we will have to you know

00:25:29,669 --> 00:25:35,519
introduce new and Europe of some sort to

00:25:33,449 --> 00:25:39,839
get the XDP hints and program the

00:25:35,519 --> 00:25:42,329
hardware accordingly and I think PJ

00:25:39,839 --> 00:25:46,979
mentioned that all of this is best

00:25:42,329 --> 00:25:50,069
effort which means that when I call from

00:25:46,979 --> 00:25:52,139
my driver to get the XDP hints I may or

00:25:50,069 --> 00:25:54,149
may not be able to program all of those

00:25:52,139 --> 00:25:57,809
in my hardware and I do the best effort

00:25:54,149 --> 00:26:00,649
to program as many as I can and you know

00:25:57,809 --> 00:26:04,229
we will have to have some way of

00:26:00,649 --> 00:26:06,449
indicating into software saying you know

00:26:04,229 --> 00:26:09,029
this was accelerated by the hardware

00:26:06,449 --> 00:26:12,109
versus the other has to be has to go

00:26:09,029 --> 00:26:12,109
through the regular supper bath

00:26:15,090 --> 00:26:19,900
okay so to wrap up this is kind of the

00:26:18,490 --> 00:26:21,730
next steps and so this goes to your

00:26:19,900 --> 00:26:24,820
question you may have been peeking into

00:26:21,730 --> 00:26:27,010
the matrix but so the next things that

00:26:24,820 --> 00:26:28,740
we really want to do is is continue to

00:26:27,010 --> 00:26:31,510
do the performance characterizations

00:26:28,740 --> 00:26:32,980
like I had mentioned before we need to

00:26:31,510 --> 00:26:35,380
test on newer hardware we need to make

00:26:32,980 --> 00:26:39,850
some changes to our test rigs to remove

00:26:35,380 --> 00:26:42,250
that that artificial head room on that

00:26:39,850 --> 00:26:45,030
NIC that we were using and we need to

00:26:42,250 --> 00:26:47,770
test with more types of X TV programs

00:26:45,030 --> 00:26:49,780
and then this is the next two pieces are

00:26:47,770 --> 00:26:52,510
the things that I think everyone here is

00:26:49,780 --> 00:26:54,310
more interested in start providing some

00:26:52,510 --> 00:26:57,970
prototypes of what we then coming up

00:26:54,310 --> 00:26:59,590
with as RFC patches both the hardware

00:26:57,970 --> 00:27:01,750
Hin programming model that Anjali just

00:26:59,590 --> 00:27:04,090
described that's going to be a pretty

00:27:01,750 --> 00:27:05,950
big lift since it touches you know the

00:27:04,090 --> 00:27:08,440
whole tool chain from LLVM down through

00:27:05,950 --> 00:27:09,880
the kernel but in order to have a

00:27:08,440 --> 00:27:13,870
meaningful discussion I think we have to

00:27:09,880 --> 00:27:16,330
provide some code and then the last one

00:27:13,870 --> 00:27:17,830
is yes we need to figure out how is this

00:27:16,330 --> 00:27:20,070
metadata going to look and how do we

00:27:17,830 --> 00:27:25,570
pass it back and forth in the XD debuff

00:27:20,070 --> 00:27:28,920
so yeah so this plenty of time so we can

00:27:25,570 --> 00:27:31,330
ask you you want to talk to me okay so

00:27:28,920 --> 00:27:34,030
yeah they're two pieces right one is how

00:27:31,330 --> 00:27:35,890
do you know what if even if it's an S KB

00:27:34,030 --> 00:27:37,600
mark what the data path was doing with

00:27:35,890 --> 00:27:39,700
it and what is what is that data path

00:27:37,600 --> 00:27:42,700
telling you this KB mark means that's

00:27:39,700 --> 00:27:44,350
one but also III guess it's very

00:27:42,700 --> 00:27:47,230
difficult for hardware to pass tlvs

00:27:44,350 --> 00:27:49,300
because then then you could you can give

00:27:47,230 --> 00:27:51,940
because we do this in IFE which is a TC

00:27:49,300 --> 00:27:56,380
action which you basically define a T to

00:27:51,940 --> 00:27:59,650
mean SK each metadata has an ID the ID

00:27:56,380 --> 00:28:02,260
gets defined as standardized so

00:27:59,650 --> 00:28:03,580
everybody knows what the idea is or you

00:28:02,260 --> 00:28:06,400
could have some vendor spec where

00:28:03,580 --> 00:28:08,260
everybody defines their own space that

00:28:06,400 --> 00:28:10,030
only they understand but they can share

00:28:08,260 --> 00:28:12,390
that with other people but that there's

00:28:10,030 --> 00:28:14,950
a space way which is standardized right

00:28:12,390 --> 00:28:17,050
so but but I understand that a lot of

00:28:14,950 --> 00:28:20,320
people in the hardware community don't

00:28:17,050 --> 00:28:24,040
like to use steal V's maybe you are nick

00:28:20,320 --> 00:28:29,320
can do it or we we do use the RV's

00:28:24,040 --> 00:28:31,720
in the context of things like DCB okay

00:28:29,320 --> 00:28:34,799
so you have a choice okay

00:28:31,720 --> 00:28:39,370
because it will make sense to at least

00:28:34,799 --> 00:28:41,640
pass a big part of all the of tlvs where

00:28:39,370 --> 00:28:44,830
the type identifies the metadata type

00:28:41,640 --> 00:28:46,720
the value has the metadata value and

00:28:44,830 --> 00:28:49,870
then you could one option is to

00:28:46,720 --> 00:28:52,650
standardize specific types that

00:28:49,870 --> 00:28:55,210
everybody agrees to an escapee mark or

00:28:52,650 --> 00:28:56,350
so yeah in that in that case then we

00:28:55,210 --> 00:28:58,330
would we would need to figure out a

00:28:56,350 --> 00:29:00,610
place to stick those TL V's to pass them

00:28:58,330 --> 00:29:02,260
into X D P right right now I thought

00:29:00,610 --> 00:29:03,520
that buffer comes from the drive from

00:29:02,260 --> 00:29:05,919
the hardware it may not be big enough

00:29:03,520 --> 00:29:08,590
depending on how I supply the TLB is

00:29:05,919 --> 00:29:10,270
okay but but I I mean I'm not

00:29:08,590 --> 00:29:12,370
discounting that yeah so take a look at

00:29:10,270 --> 00:29:17,679
IFE and how we do things but here to

00:29:12,370 --> 00:29:21,880
your first one yeah so so this this here

00:29:17,679 --> 00:29:23,679
Jamal is kind of outlying how that mark

00:29:21,880 --> 00:29:26,410
would work or how we're envisioning it

00:29:23,679 --> 00:29:29,500
would work so the type of the hint would

00:29:26,410 --> 00:29:31,240
be if you have a packet match right and

00:29:29,500 --> 00:29:34,780
if it matches that tuple that's passed

00:29:31,240 --> 00:29:37,510
in then the result is 25 arbitrary

00:29:34,780 --> 00:29:40,179
number right this your flow ID or and

00:29:37,510 --> 00:29:42,400
then that's the mark and the size is you

00:29:40,179 --> 00:29:45,820
32 so we would define where in that

00:29:42,400 --> 00:29:47,770
metadata struct that would be defined so

00:29:45,820 --> 00:29:51,160
then if we saw 25 we knew that we hid a

00:29:47,770 --> 00:29:56,169
packet match based on that to poll it's

00:29:51,160 --> 00:29:58,900
a very arbitrary so so I was watching

00:29:56,169 --> 00:30:02,410
Lawrence's presentation on TCP BPF I had

00:29:58,900 --> 00:30:03,940
a bit of an epiphany about something I

00:30:02,410 --> 00:30:05,980
could simplify what you guys are doing

00:30:03,940 --> 00:30:07,240
for at least a two but two bubbles at

00:30:05,980 --> 00:30:09,400
the top of that slide you were just

00:30:07,240 --> 00:30:10,780
showing the places that the situations

00:30:09,400 --> 00:30:12,700
where we're we're interested in a

00:30:10,780 --> 00:30:13,960
particular specific well-defined field

00:30:12,700 --> 00:30:15,940
and the headers and we would like to

00:30:13,960 --> 00:30:18,340
just load it and inspect it in some way

00:30:15,940 --> 00:30:20,290
okay and this this would obviate the

00:30:18,340 --> 00:30:22,750
need for the special elf sections this

00:30:20,290 --> 00:30:25,179
is why I like this idea so in things

00:30:22,750 --> 00:30:26,950
like TCP BPF the canonical way to handle

00:30:25,179 --> 00:30:30,070
this situation in BPF is that you have

00:30:26,950 --> 00:30:32,710
an abstract structure like a struck sock

00:30:30,070 --> 00:30:36,010
XDP or whatever like so here we would

00:30:32,710 --> 00:30:38,080
have our struck XD p HW hints right

00:30:36,010 --> 00:30:41,810
and this would be relative to the

00:30:38,080 --> 00:30:44,900
data meta I got it right yeah the data

00:30:41,810 --> 00:30:50,390
meta pointer so each access to data meta

00:30:44,900 --> 00:30:52,850
as XT PE hints structure type so you had

00:30:50,390 --> 00:30:56,840
this structure that it's like you 16 P

00:30:52,850 --> 00:30:59,060
type you 16 inner l4 blah blah blah blah

00:30:56,840 --> 00:31:01,280
blah blah blah so when you load the

00:30:59,060 --> 00:31:03,230
program into the kernel it scans for all

00:31:01,280 --> 00:31:05,360
the loads done relative to that context

00:31:03,230 --> 00:31:07,430
pointer right and if it's seasonal an

00:31:05,360 --> 00:31:09,730
access to X it'll translate that into uh

00:31:07,430 --> 00:31:12,920
wherever you put that field in hardware

00:31:09,730 --> 00:31:14,450
so at program load time we rewrite the

00:31:12,920 --> 00:31:15,440
load instructions to be P of load

00:31:14,450 --> 00:31:18,260
instructions so that they actually

00:31:15,440 --> 00:31:21,800
access the place where you really put

00:31:18,260 --> 00:31:23,270
the metadata field into the metadata

00:31:21,800 --> 00:31:24,800
area of the packets whatever you

00:31:23,270 --> 00:31:27,080
configure the program the horrors do or

00:31:24,800 --> 00:31:29,150
whatever it's capable of okay and so

00:31:27,080 --> 00:31:31,940
then when you when the program gets

00:31:29,150 --> 00:31:34,370
loaded with the existing ndo x DP

00:31:31,940 --> 00:31:35,960
operation you have the program and we

00:31:34,370 --> 00:31:37,640
can have some auxilary data of the

00:31:35,960 --> 00:31:39,470
rewritten load instructions and you

00:31:37,640 --> 00:31:41,270
could therefore know exactly what fields

00:31:39,470 --> 00:31:44,030
were accessed and what they need to get

00:31:41,270 --> 00:31:45,770
rewritten to so if you do things that

00:31:44,030 --> 00:31:47,540
from that approach you don't need the

00:31:45,770 --> 00:31:50,120
elf section for that but for the match

00:31:47,540 --> 00:31:52,220
stuff that's a totally different animal

00:31:50,120 --> 00:31:55,040
altogether so you may be able to get a

00:31:52,220 --> 00:31:58,010
quick prototype of the loading accessing

00:31:55,040 --> 00:31:59,330
fields bit just using the instruction

00:31:58,010 --> 00:32:00,830
rewrite stuff and then you can look into

00:31:59,330 --> 00:32:03,710
using elf sections maybe for the

00:32:00,830 --> 00:32:05,540
matching aspect so that would kind of be

00:32:03,710 --> 00:32:07,100
a hybrid between the first and second

00:32:05,540 --> 00:32:11,630
approaches where the first one was

00:32:07,100 --> 00:32:14,900
defining a struct right it's a struct

00:32:11,630 --> 00:32:18,410
and access to them indicate an interest

00:32:14,900 --> 00:32:20,060
in field X right and then the the second

00:32:18,410 --> 00:32:22,100
one was you have something in BPF that's

00:32:20,060 --> 00:32:23,660
actually doing some magic populating the

00:32:22,100 --> 00:32:25,160
field so it's kind of a mix of the two

00:32:23,660 --> 00:32:28,310
right and this also gives you

00:32:25,160 --> 00:32:30,890
flexibility in the software fall back as

00:32:28,310 --> 00:32:33,380
well yes and that's one thing that we

00:32:30,890 --> 00:32:35,270
did not have well-defined in either of

00:32:33,380 --> 00:32:39,620
those yeah right so anyways just think

00:32:35,270 --> 00:32:41,810
about that I like it anybody else and

00:32:39,620 --> 00:32:44,050
it's being recorded so I can I can refer

00:32:41,810 --> 00:32:44,050
to it later

00:32:48,150 --> 00:32:54,559
is there any presumption that this is

00:32:50,549 --> 00:32:57,600
Ethernet centric or applicable to IP

00:32:54,559 --> 00:33:03,929
ipv6 network devices where you just get

00:32:57,600 --> 00:33:06,059
IP packets there is important

00:33:03,929 --> 00:33:08,220
there's no percent okay no and there was

00:33:06,059 --> 00:33:12,900
another question that somebody had asked

00:33:08,220 --> 00:33:16,650
earlier it was about is there a way I

00:33:12,900 --> 00:33:20,159
could reprogram the person in the

00:33:16,650 --> 00:33:22,080
hardware using this and so that I can

00:33:20,159 --> 00:33:25,289
use my own protocol types and stuff like

00:33:22,080 --> 00:33:28,650
that we haven't really looked into it so

00:33:25,289 --> 00:33:31,020
we will think about it yeah I mean the

00:33:28,650 --> 00:33:33,330
thing is that if you know how to parse

00:33:31,020 --> 00:33:35,700
your packet apart if you know what's

00:33:33,330 --> 00:33:38,130
going to be where in your data streams

00:33:35,700 --> 00:33:39,360
then there's you get a pointer to your

00:33:38,130 --> 00:33:41,610
packet buffer and you just start tearing

00:33:39,360 --> 00:33:48,240
it apart that really doesn't matter

00:33:41,610 --> 00:33:51,000
what's there any other questions yes

00:33:48,240 --> 00:33:53,370
please how are you going to take an EPA

00:33:51,000 --> 00:33:56,190
program and understand from it from a

00:33:53,370 --> 00:34:02,220
general program what you want to

00:33:56,190 --> 00:34:04,289
configure the hardware so that's the

00:34:02,220 --> 00:34:07,799
problem that we were trying to solve in

00:34:04,289 --> 00:34:10,169
some way if the elf header file that is

00:34:07,799 --> 00:34:13,649
being generated if it can give me

00:34:10,169 --> 00:34:16,050
information on what hints are useful for

00:34:13,649 --> 00:34:18,990
that program then I can program my

00:34:16,050 --> 00:34:20,700
hardware and you know that's the part

00:34:18,990 --> 00:34:22,109
that Dave was suggesting there's

00:34:20,700 --> 00:34:24,030
probably a mixed approach there is

00:34:22,109 --> 00:34:26,879
something that I can implicitly Drive

00:34:24,030 --> 00:34:32,369
and I don't need these special header

00:34:26,879 --> 00:34:36,629
sections in their file although for

00:34:32,369 --> 00:34:37,740
things like you know flow match a kind

00:34:36,629 --> 00:34:41,720
of thing we might have to add those

00:34:37,740 --> 00:34:45,119
headers now those sections in the header

00:34:41,720 --> 00:34:47,040
because a BPF program can be something

00:34:45,119 --> 00:34:49,679
that's read generic orders just

00:34:47,040 --> 00:34:51,659
modifying the packet and then asking a

00:34:49,679 --> 00:34:53,550
question about the packet so could be

00:34:51,659 --> 00:34:56,790
that you need to reclassify the packet

00:34:53,550 --> 00:34:58,870
after the change so you need to

00:34:56,790 --> 00:35:00,340
understand really look on the on

00:34:58,870 --> 00:35:04,030
program to understand what he's doing

00:35:00,340 --> 00:35:06,580
and well but that's the case for any of

00:35:04,030 --> 00:35:09,430
them right now right I mean no right now

00:35:06,580 --> 00:35:11,650
you take the EPF code and run it that's

00:35:09,430 --> 00:35:13,240
true right so if you go back to the

00:35:11,650 --> 00:35:15,040
initial slide we said we're not gonna

00:35:13,240 --> 00:35:17,410
we're trying to solve some of the

00:35:15,040 --> 00:35:19,510
problems you know some of the things

00:35:17,410 --> 00:35:21,700
that the EPP program does and not some

00:35:19,510 --> 00:35:25,540
of those like packet manipulation is

00:35:21,700 --> 00:35:29,050
something we're really not taking into

00:35:25,540 --> 00:35:30,730
account and most of the I mean programs

00:35:29,050 --> 00:35:32,530
that are you know I have been looking at

00:35:30,730 --> 00:35:35,170
it's like you classify before

00:35:32,530 --> 00:35:37,570
manipulation manipulating the packet and

00:35:35,170 --> 00:35:40,360
then you classify after you've made the

00:35:37,570 --> 00:35:42,370
changes this is pretty manipulation of

00:35:40,360 --> 00:35:49,330
the packet that I can classify like the

00:35:42,370 --> 00:35:50,560
packet as as it came in so this is also

00:35:49,330 --> 00:35:53,800
intended that if you were going to

00:35:50,560 --> 00:35:55,600
change your target hint fields that you

00:35:53,800 --> 00:36:00,340
are interested in you would reload the

00:35:55,600 --> 00:36:02,230
program with a different set of hints so

00:36:00,340 --> 00:36:04,500
someone need to have it to give the

00:36:02,230 --> 00:36:04,500
hints

00:36:12,079 --> 00:36:19,809
there's one okay are you on board Ronnie

00:36:21,189 --> 00:36:27,589
would there be a way to modify whatever

00:36:25,670 --> 00:36:30,199
information is passed to the XDP program

00:36:27,589 --> 00:36:32,420
so that further chained programs don't

00:36:30,199 --> 00:36:33,859
wind up getting wrong information from

00:36:32,420 --> 00:36:39,739
the hardware after a previous program

00:36:33,859 --> 00:36:41,689
has invalidated it if I have an original

00:36:39,739 --> 00:36:44,239
program that's designed to do something

00:36:41,689 --> 00:36:46,519
if it's ipv6 or ipv4 and then I make

00:36:44,239 --> 00:36:50,179
some program that decides to translate a

00:36:46,519 --> 00:36:51,949
packet from ipv4 to ipv6 and I simply

00:36:50,179 --> 00:36:54,019
insert that in front of the chain next

00:36:51,949 --> 00:36:55,939
program goes oh hardware said it's ipv4

00:36:54,019 --> 00:37:04,339
but I've actually changed it to be ipv6

00:36:55,939 --> 00:37:06,459
that's no longer correct so this would

00:37:04,339 --> 00:37:09,559
be if you manipulate the packet but

00:37:06,459 --> 00:37:12,650
you're potentially having stale data in

00:37:09,559 --> 00:37:14,420
your metadata pointer is that okay in

00:37:12,650 --> 00:37:16,400
that case typically when we're modifying

00:37:14,420 --> 00:37:19,309
the packet the reason that that Headroom

00:37:16,400 --> 00:37:21,259
is there is to extend the headers so in

00:37:19,309 --> 00:37:22,910
that case I mean we haven't thought

00:37:21,259 --> 00:37:24,199
about it but thinking about it kind of

00:37:22,910 --> 00:37:25,880
off the top of my head we would just

00:37:24,199 --> 00:37:28,339
invalidate the metadata pointer at that

00:37:25,880 --> 00:37:30,019
point as we extend the headers and then

00:37:28,339 --> 00:37:32,799
it software would have to parse it but

00:37:30,019 --> 00:37:32,799
that's a good point

00:37:33,759 --> 00:37:45,920
any other questions we've got two

00:37:36,799 --> 00:37:50,989
minutes and 27 seconds the performance

00:37:45,920 --> 00:37:53,449
testing the big boost reduction of the

00:37:50,989 --> 00:37:57,009
data cache miss in your test so this

00:37:53,449 --> 00:37:59,390
specific BPS program that we tested this

00:37:57,009 --> 00:38:03,380
may not work like i don't say on other

00:37:59,390 --> 00:38:06,969
programs the performance boosts yeah so

00:38:03,380 --> 00:38:06,969
that that that's the whole reason that

00:38:07,959 --> 00:38:13,130
the the top bullets especially the still

00:38:11,900 --> 00:38:16,249
need to test with more complex

00:38:13,130 --> 00:38:18,170
xdp programs because of that limitation

00:38:16,249 --> 00:38:20,779
of the NIC we're not really sure where

00:38:18,170 --> 00:38:22,489
that upper limit is we do believe it's

00:38:20,779 --> 00:38:24,910
quite a bit higher than that 21 million

00:38:22,489 --> 00:38:27,500
and some chain

00:38:24,910 --> 00:38:29,329
but we need to test it right we need to

00:38:27,500 --> 00:38:34,460
test with like a load balance or an end

00:38:29,329 --> 00:38:35,930
cap D cap I'm hoping that we still get

00:38:34,460 --> 00:38:37,940
some good performance out of it but at

00:38:35,930 --> 00:38:38,809
this point we can't extrapolate we just

00:38:37,940 --> 00:38:41,000
didn't have enough time to do the

00:38:38,809 --> 00:38:48,910
testing but it is something that we're

00:38:41,000 --> 00:38:48,910
committed to doing got one more minute

00:38:50,650 --> 00:39:00,949
that's it well thank you

00:38:54,620 --> 00:39:00,949

YouTube URL: https://www.youtube.com/watch?v=uD1_oAHpUmU


