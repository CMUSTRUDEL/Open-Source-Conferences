Title: Status, Open Issues and Extensions for switchdev SR-IOV mode
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: Or Gerlitz, Simon Horman
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?gerlitz-sriov-bof
Captions: 
	00:00:02,030 --> 00:00:07,560
good so that's the buff and again will

00:00:05,580 --> 00:00:15,080
not be able to introduce the feature

00:00:07,560 --> 00:00:15,080
because we have only 27 minutes so let's

00:00:15,470 --> 00:00:20,310
so we'll be talking about the current

00:00:18,600 --> 00:00:23,099
the first slide is the current summary

00:00:20,310 --> 00:00:25,740
of the support and then we are proposing

00:00:23,099 --> 00:00:27,660
some extensions and also there's some

00:00:25,740 --> 00:00:29,789
open issues will be discussed by Simon

00:00:27,660 --> 00:00:32,700
and I not sure we'll get to the last

00:00:29,789 --> 00:00:34,469
topic which is how do if and how to

00:00:32,700 --> 00:00:39,750
apply the same model for container

00:00:34,469 --> 00:00:42,809
networking so what today in for the date

00:00:39,750 --> 00:00:46,680
the the basic mode the basic new stuff

00:00:42,809 --> 00:00:50,129
got in where you can say that you want

00:00:46,680 --> 00:00:51,930
to work in this mode this is a Devlin

00:00:50,129 --> 00:00:54,329
command and then there was an emetic

00:00:51,930 --> 00:00:57,899
swab implementation for the representers

00:00:54,329 --> 00:01:00,780
and and some basic offloading and then

00:00:57,899 --> 00:01:02,789
till for the 12-week a kind of extended

00:01:00,780 --> 00:01:05,490
that we supported more actions like

00:01:02,789 --> 00:01:08,280
offloading of VLAN push and prop we

00:01:05,490 --> 00:01:11,730
introduced the tunnel key tunnel key set

00:01:08,280 --> 00:01:14,340
it's a TC TC actions that allows to

00:01:11,730 --> 00:01:17,100
implement encapsulation with for

00:01:14,340 --> 00:01:19,410
instance Vixens but it's a it's tailored

00:01:17,100 --> 00:01:21,300
to something only the kernel sure tunnel

00:01:19,410 --> 00:01:23,790
device can which can be weeks lon

00:01:21,300 --> 00:01:27,230
GRE and now tom is working on gtp or

00:01:23,790 --> 00:01:29,700
other stuff in front of the 11 and 12 we

00:01:27,230 --> 00:01:33,420
facelifted Jamal's code from 20 years

00:01:29,700 --> 00:01:36,780
ago to an action called T edit it's a

00:01:33,420 --> 00:01:38,370
it's a packet editing which you need in

00:01:36,780 --> 00:01:41,580
a use cases where you have to rewrite

00:01:38,370 --> 00:01:44,660
the headers of packet like in flow based

00:01:41,580 --> 00:01:48,930
router stuff like that so that was all

00:01:44,660 --> 00:01:54,060
till 4.12 in 4.13 metronome also

00:01:48,930 --> 00:01:56,280
contributed their driver to align to

00:01:54,060 --> 00:02:01,110
this framework and then extended it

00:01:56,280 --> 00:02:02,670
since then in 415 Broadcom joined so now

00:02:01,110 --> 00:02:05,820
we have three drivers supporting that

00:02:02,670 --> 00:02:07,740
and in ISO patches from liquid i/o in

00:02:05,820 --> 00:02:09,509
the past we had some patches from i-40 I

00:02:07,740 --> 00:02:13,560
don't know John you should tell them to

00:02:09,509 --> 00:02:14,970
continue and push it so and jelly

00:02:13,560 --> 00:02:16,260
you guys send me one to the other

00:02:14,970 --> 00:02:21,330
talking to Anjali she's sending it to

00:02:16,260 --> 00:02:24,030
you you're talking to you okay yes so so

00:02:21,330 --> 00:02:26,849
we kind of build a community suppose for

00:02:24,030 --> 00:02:28,230
that and and that this is where we are

00:02:26,849 --> 00:02:31,500
this is the State of the Union for

00:02:28,230 --> 00:02:34,230
that's small piece of the universe what

00:02:31,500 --> 00:02:36,510
I did want to make a comment now and I

00:02:34,230 --> 00:02:38,810
just talked to you two guys from Intel

00:02:36,510 --> 00:02:40,860
Broadcom and that's one or Mellanox

00:02:38,810 --> 00:02:44,069
don't see if Davies here it's not here I

00:02:40,860 --> 00:02:46,920
can talk to him later so we have we have

00:02:44,069 --> 00:02:48,870
in the kernel the legacy mode which was

00:02:46,920 --> 00:02:51,600
maybe historical mistakes but it can

00:02:48,870 --> 00:02:54,000
happen we would like to have a community

00:02:51,600 --> 00:02:56,880
standpoint which says we don't want to

00:02:54,000 --> 00:02:59,670
see new features in the in the legacy

00:02:56,880 --> 00:03:01,950
mode because it confuses users it's

00:02:59,670 --> 00:03:04,349
creates the applicate code so our

00:03:01,950 --> 00:03:06,569
message that we came into agreement now

00:03:04,349 --> 00:03:09,750
is that new features should go to the

00:03:06,569 --> 00:03:11,549
new mode if someone has fixes or

00:03:09,750 --> 00:03:15,650
maintenance patches to the old mode

00:03:11,549 --> 00:03:15,650
that's probably fine so

00:03:18,080 --> 00:03:21,950
one thing that is confusing when I try

00:03:20,450 --> 00:03:24,800
to explain these two modes is their

00:03:21,950 --> 00:03:26,990
names like the legacy mode now it's

00:03:24,800 --> 00:03:29,480
legacy that makes sense but switch dev

00:03:26,990 --> 00:03:33,190
mode is not has doesn't have an obvious

00:03:29,480 --> 00:03:33,190
meaning to those who don't already know

00:03:33,340 --> 00:03:37,670
this is sort of informal name so if we

00:03:36,230 --> 00:03:39,710
can make a name competition if you have

00:03:37,670 --> 00:03:41,600
a better I mean and that's that's not

00:03:39,710 --> 00:03:44,600
the essence of it right so the essence

00:03:41,600 --> 00:03:46,910
is that you get representations for the

00:03:44,600 --> 00:03:49,700
switch ports in the form of a net device

00:03:46,910 --> 00:03:58,240
and then you can apply colonel data the

00:03:49,700 --> 00:03:58,240
data pass only that's it like so okay

00:03:58,660 --> 00:04:06,350
yes so one of the challenges that we are

00:04:03,380 --> 00:04:07,970
having is most of our devices they you

00:04:06,350 --> 00:04:09,800
know we can expose the switch dev mode

00:04:07,970 --> 00:04:12,620
but we're having prompts for the slow

00:04:09,800 --> 00:04:14,870
path like the devices that we have today

00:04:12,620 --> 00:04:17,660
if you send a packet from the VF and

00:04:14,870 --> 00:04:19,880
there is no match in the hardware it

00:04:17,660 --> 00:04:22,750
goes out both ways it goes out to the

00:04:19,880 --> 00:04:25,280
wire and it goes to the representor and

00:04:22,750 --> 00:04:27,230
that's the reason that we push back on

00:04:25,280 --> 00:04:29,000
the I party patches for supporting

00:04:27,230 --> 00:04:31,250
switch there and if we kind of relax

00:04:29,000 --> 00:04:33,530
that then it would be really well you

00:04:31,250 --> 00:04:35,240
know it will work out great because we

00:04:33,530 --> 00:04:37,040
really would like to add all the T

00:04:35,240 --> 00:04:38,630
seok's hooks for offload on the

00:04:37,040 --> 00:04:40,520
representor we would not want to go to

00:04:38,630 --> 00:04:41,990
the legacy mode right because it works

00:04:40,520 --> 00:04:44,360
out really good for us but the slow path

00:04:41,990 --> 00:04:46,940
is what is holding us so there is some

00:04:44,360 --> 00:04:49,640
freedom in how you how you implement the

00:04:46,940 --> 00:04:51,410
slope as within your driver in this

00:04:49,640 --> 00:04:52,730
private example that you gave you say

00:04:51,410 --> 00:04:54,530
that you have a less m limitation that

00:04:52,730 --> 00:04:55,760
when a virtual function sends a packet

00:04:54,530 --> 00:04:57,410
and there's no path and there was no

00:04:55,760 --> 00:04:59,570
match it goes to the representor but it

00:04:57,410 --> 00:05:01,310
also goes to the wire what the kernel

00:04:59,570 --> 00:05:04,880
data path needs it's the package to go

00:05:01,310 --> 00:05:07,040
to their presenter if going out to the

00:05:04,880 --> 00:05:10,070
wire doesn't have a significant side

00:05:07,040 --> 00:05:15,950
effect which I don't know somehow cause

00:05:10,070 --> 00:05:18,770
I so I so it was it confused the

00:05:15,950 --> 00:05:22,910
networks so so what do you want me to do

00:05:18,770 --> 00:05:25,310
like so wait the this the slow path is

00:05:22,910 --> 00:05:26,870
the foundation of the story because if

00:05:25,310 --> 00:05:29,090
you don't have a proper slope as the

00:05:26,870 --> 00:05:31,460
kernel the control plane cannot

00:05:29,090 --> 00:05:33,650
configure you so you so you could

00:05:31,460 --> 00:05:35,810
in your case what can happen like you

00:05:33,650 --> 00:05:37,850
know in the same OVS there's the normal

00:05:35,810 --> 00:05:39,980
rule that cause obvious to apply

00:05:37,850 --> 00:05:41,960
learning but if it's an environment

00:05:39,980 --> 00:05:46,610
which does not use learning it will work

00:05:41,960 --> 00:05:48,680
for you right so yes that's exactly the

00:05:46,610 --> 00:05:50,510
point right so anybody who's not really

00:05:48,680 --> 00:05:53,320
running obvious as our credit

00:05:50,510 --> 00:06:10,940
orchestration on top and doing learning

00:05:53,320 --> 00:06:12,470
right well if it's if it's an

00:06:10,940 --> 00:06:14,810
environment where slow pass is not used

00:06:12,470 --> 00:06:16,160
at all you can work but it's hard to me

00:06:14,810 --> 00:06:17,450
to imagine such an environment because

00:06:16,160 --> 00:06:18,920
you always have something that goes on

00:06:17,450 --> 00:06:21,320
slow pass you have some only some

00:06:18,920 --> 00:06:23,660
control plane that wants to do something

00:06:21,320 --> 00:06:26,180
right but then there is also the idea

00:06:23,660 --> 00:06:29,120
where you know the hypervisor is missing

00:06:26,180 --> 00:06:31,160
out on the VF state itself like you know

00:06:29,120 --> 00:06:32,630
the stats or the link status or actually

00:06:31,160 --> 00:06:34,400
programming or the rules on the VF where

00:06:32,630 --> 00:06:36,320
I will have to use the legacy method to

00:06:34,400 --> 00:06:39,140
say oh we if I did this on IP route to

00:06:36,320 --> 00:06:41,540
you know to program a rule so I would

00:06:39,140 --> 00:06:44,840
really prefer I if there was a way to

00:06:41,540 --> 00:06:46,850
say I have representatives on a switch

00:06:44,840 --> 00:06:51,920
tab but I don't really support the slow

00:06:46,850 --> 00:06:54,220
path because that's okay so let's

00:06:51,920 --> 00:06:54,220
continue

00:06:57,090 --> 00:07:04,320
okay so let's start to think about so

00:07:01,610 --> 00:07:05,880
again the people that most of the many

00:07:04,320 --> 00:07:07,560
people that here know the details but

00:07:05,880 --> 00:07:10,139
and again I don't have to introduce them

00:07:07,560 --> 00:07:12,570
but the approach was to expose a

00:07:10,139 --> 00:07:14,550
representative device for each switch

00:07:12,570 --> 00:07:16,080
port and then the programming of the

00:07:14,550 --> 00:07:19,110
data paths the the Fastpass

00:07:16,080 --> 00:07:21,210
we chose to go through TC flower which

00:07:19,110 --> 00:07:23,880
there's also introduction later by Simon

00:07:21,210 --> 00:07:26,010
but it's it's flow based okay what's in

00:07:23,880 --> 00:07:28,020
the switch world called ACS or in the

00:07:26,010 --> 00:07:31,760
Negro's that we call it flows we are

00:07:28,020 --> 00:07:34,500
using TC flower so so how about

00:07:31,760 --> 00:07:37,620
environment environment that are no flow

00:07:34,500 --> 00:07:43,250
not flow based okay more conventional

00:07:37,620 --> 00:07:45,990
environment like l2 l2 or l3 based so

00:07:43,250 --> 00:07:49,500
again if the control plane is flow based

00:07:45,990 --> 00:07:51,750
but like they they implement layer 2

00:07:49,500 --> 00:07:54,030
network networking or or simple narrow

00:07:51,750 --> 00:07:56,820
layer 3 networking by programming flows

00:07:54,030 --> 00:07:58,979
so we are back to the same to the same

00:07:56,820 --> 00:08:01,470
game and it's sort of easy if you use

00:07:58,979 --> 00:08:04,400
stuff like obvious or or DLL or DVR

00:08:01,470 --> 00:08:08,039
which is dissipated virtual router so

00:08:04,400 --> 00:08:09,930
again if you're doing layer 2 so the

00:08:08,039 --> 00:08:11,880
control plane itself they're

00:08:09,930 --> 00:08:14,520
implementing some model of a bridge but

00:08:11,880 --> 00:08:18,330
they would program a flow that does

00:08:14,520 --> 00:08:20,340
matching on on layer 2 and then deals

00:08:18,330 --> 00:08:22,950
with villainy and forward so we can

00:08:20,340 --> 00:08:25,800
support it if it's a simple relatively

00:08:22,950 --> 00:08:28,380
simply l3 case so this control plane

00:08:25,800 --> 00:08:30,419
again would program some matching on mac

00:08:28,380 --> 00:08:32,640
and villains it would apply heathery

00:08:30,419 --> 00:08:35,339
right right because it's a router that

00:08:32,640 --> 00:08:39,180
has to change mac and then again we're

00:08:35,339 --> 00:08:43,919
back to the same story so that's that's

00:08:39,180 --> 00:08:45,750
a that's an easier and easier example

00:08:43,919 --> 00:08:50,550
but let's let's try to take it further

00:08:45,750 --> 00:08:52,589
okay typically NIC hardware they don't

00:08:50,550 --> 00:08:55,190
have the same building block as a switch

00:08:52,589 --> 00:08:57,000
ASIC right it's a it's a different

00:08:55,190 --> 00:09:00,070
different architecture I don't know

00:08:57,000 --> 00:09:02,170
sometimes I don't understand why

00:09:00,070 --> 00:09:03,640
I was doesn't remember Jonah was talking

00:09:02,170 --> 00:09:05,440
to you and you said hey it's that's how

00:09:03,640 --> 00:09:07,270
a white has to be so different but but

00:09:05,440 --> 00:09:10,270
still let's try to think how we can

00:09:07,270 --> 00:09:13,900
apply layer two layer two layer three

00:09:10,270 --> 00:09:15,640
offloading on mix with of Linux data

00:09:13,900 --> 00:09:20,350
pass on the NIC that support is this

00:09:15,640 --> 00:09:22,090
stuff so to begin with let let's adjust

00:09:20,350 --> 00:09:24,340
the hardware driver to register on

00:09:22,090 --> 00:09:27,250
events so today we have the switch deaf

00:09:24,340 --> 00:09:29,080
driver it's it's an switch ASIC driver

00:09:27,250 --> 00:09:30,670
that melon off did it but other vendors

00:09:29,080 --> 00:09:32,350
could do that as well so so the way that

00:09:30,670 --> 00:09:34,510
this driver walk is the stack they

00:09:32,350 --> 00:09:36,640
register two notifications from the

00:09:34,510 --> 00:09:38,290
stack and they respond of them and there

00:09:36,640 --> 00:09:40,300
are notifications typically from the

00:09:38,290 --> 00:09:42,370
stuck to the driver but sometimes also

00:09:40,300 --> 00:09:44,170
the other way up from the driver to the

00:09:42,370 --> 00:09:46,780
stack so if we get those notifications

00:09:44,170 --> 00:09:49,000
and we do some adjustment in the driver

00:09:46,780 --> 00:09:52,150
in the firmer to translate from the

00:09:49,000 --> 00:09:55,240
kernel l-2 and l-3 thinking to the

00:09:52,150 --> 00:10:00,010
driver to the hardware API we can try an

00:09:55,240 --> 00:10:02,500
attempt to offload the l2 l3 let's take

00:10:00,010 --> 00:10:03,670
it well to because it's simpler so how

00:10:02,500 --> 00:10:06,130
would you how would it would look like

00:10:03,670 --> 00:10:08,020
we would create a Linux bridge and we

00:10:06,130 --> 00:10:11,410
would assign those represent us to the

00:10:08,020 --> 00:10:13,450
bridge and we should support the

00:10:11,410 --> 00:10:16,390
notification in the hardware driver so

00:10:13,450 --> 00:10:20,740
for instance the Mellanox sneaked our

00:10:16,390 --> 00:10:22,510
hardware don't doesn't learn FDB entries

00:10:20,740 --> 00:10:24,720
whereas in the ASIC driver they do know

00:10:22,510 --> 00:10:27,490
how to learn it so this there is already

00:10:24,720 --> 00:10:29,320
instructor for that that if the bridge

00:10:27,490 --> 00:10:33,640
today it used only for studying FTB's

00:10:29,320 --> 00:10:35,410
but but it will just happen or maybe we

00:10:33,640 --> 00:10:37,750
have to only a little bit tweak the

00:10:35,410 --> 00:10:39,520
bridge code that when they learn an FDB

00:10:37,750 --> 00:10:42,550
they would they send this notification

00:10:39,520 --> 00:10:43,990
you see add to device and then in the

00:10:42,550 --> 00:10:45,940
hardware driver we will get to send

00:10:43,990 --> 00:10:49,420
notification and we can translate it to

00:10:45,940 --> 00:10:53,500
a flow and proper bit right so so here I

00:10:49,420 --> 00:10:55,240
attempted to kind of I I was sitting

00:10:53,500 --> 00:10:57,280
with someone from our team we don't even

00:10:55,240 --> 00:10:58,720
we kind of broke it to what what

00:10:57,280 --> 00:11:00,070
disciplines you have to do in order to

00:10:58,720 --> 00:11:02,200
offload l2 you have to deal with

00:11:00,070 --> 00:11:04,570
learning with aging with STP with

00:11:02,200 --> 00:11:07,270
floating and it's it seems doable so

00:11:04,570 --> 00:11:10,390
because you have slope us and because

00:11:07,270 --> 00:11:11,360
they can in slow pass what happens you

00:11:10,390 --> 00:11:12,860
have a miss

00:11:11,360 --> 00:11:17,240
we'll go to the bridge they would learn

00:11:12,860 --> 00:11:18,649
the FDB right so the the l2 of course

00:11:17,240 --> 00:11:22,970
there are many details to complete you

00:11:18,649 --> 00:11:26,060
but this is a simpler exercise when we

00:11:22,970 --> 00:11:27,680
went to layer three it became more

00:11:26,060 --> 00:11:29,000
America complex you have to build the

00:11:27,680 --> 00:11:30,500
environment again with the bridge you

00:11:29,000 --> 00:11:32,480
have to assign IP addresses this is

00:11:30,500 --> 00:11:36,680
morale and here you have to respond to

00:11:32,480 --> 00:11:39,350
fit events so in a very simple routing

00:11:36,680 --> 00:11:41,570
scheme router does the LPI matching and

00:11:39,350 --> 00:11:44,600
then the neighbor stuff so you could

00:11:41,570 --> 00:11:46,399
also here here is some example how to do

00:11:44,600 --> 00:11:49,089
a lot on an unarmed NIC NIC and a flow

00:11:46,399 --> 00:11:53,209
based Nick how the API but this is more

00:11:49,089 --> 00:11:56,600
how would I say this become more less

00:11:53,209 --> 00:11:58,579
natural and annoying and our one we have

00:11:56,600 --> 00:12:00,890
to do a thing is to go back home and

00:11:58,579 --> 00:12:03,019
talk to our hardware architecture or the

00:12:00,890 --> 00:12:05,240
people that expose those how the API and

00:12:03,019 --> 00:12:09,019
to see if if Nick Hardware can support

00:12:05,240 --> 00:12:13,010
API switch are more suitable to that to

00:12:09,019 --> 00:12:17,600
that stuff it's doable but it starts to

00:12:13,010 --> 00:12:21,680
be a bit ugly and I don't know LPM and

00:12:17,600 --> 00:12:23,209
yes yes it's it's - yes it's written

00:12:21,680 --> 00:12:26,360
here how you do it it's written on the

00:12:23,209 --> 00:12:27,860
slide but yes yes but Ronnie I think

00:12:26,360 --> 00:12:30,680
that maybe today our hardware can do

00:12:27,860 --> 00:12:32,390
more than what the api's exposes so

00:12:30,680 --> 00:12:35,839
because the people that design those

00:12:32,390 --> 00:12:39,160
api's the architects of nick's they kind

00:12:35,839 --> 00:12:39,160
of less live this room

00:12:40,140 --> 00:12:46,290
yes this is okay again again yes it says

00:12:43,260 --> 00:12:50,370
yes maybe in your eye yes again those

00:12:46,290 --> 00:12:52,410
excuse me those two slides they attempt

00:12:50,370 --> 00:12:57,120
to say Hecky let's say I have a kernel

00:12:52,410 --> 00:12:58,800
model that uses l 3o l 2 and then we use

00:12:57,120 --> 00:13:00,899
all those notifications and now we want

00:12:58,800 --> 00:13:03,269
to implement it over an ik harder driver

00:13:00,899 --> 00:13:06,060
so what we need to do we have to we have

00:13:03,269 --> 00:13:07,890
to respond to those notifications and

00:13:06,060 --> 00:13:10,290
program the hardware so when I said that

00:13:07,890 --> 00:13:12,360
the the the Nick is less suitable for

00:13:10,290 --> 00:13:13,860
the kernel for the kernel the kind of

00:13:12,360 --> 00:13:16,380
doesn't know that it's a switch or a

00:13:13,860 --> 00:13:18,000
Nick right they see they see a bridge or

00:13:16,380 --> 00:13:21,570
they see a routing scheme and they just

00:13:18,000 --> 00:13:36,420
send the notifications okay so maybe in

00:13:21,570 --> 00:13:38,399
your case your router oh yes yes there

00:13:36,420 --> 00:13:40,470
could be some points where you have to

00:13:38,399 --> 00:13:44,160
do small adjustment in the OSS API

00:13:40,470 --> 00:13:46,949
because maybe even Giri can tell us and

00:13:44,160 --> 00:13:50,940
now for instance in the in the in the

00:13:46,949 --> 00:13:54,000
bridge case in the bridge case those

00:13:50,940 --> 00:13:56,850
notifications would would you just work

00:13:54,000 --> 00:13:58,769
transparently when if my if I hold it

00:13:56,850 --> 00:14:00,480
doesn't learn it goes to the CPU it will

00:13:58,769 --> 00:14:04,230
the bridge will learn it and send this

00:14:00,480 --> 00:14:06,360
notification no so today it only sent us

00:14:04,230 --> 00:14:08,040
static FTB's right right so this is

00:14:06,360 --> 00:14:10,709
example for a small small adjustment but

00:14:08,040 --> 00:14:14,750
it's doable it doesn't break the

00:14:10,709 --> 00:14:14,750
architecture it it's it's nice even

00:14:15,259 --> 00:14:23,939
the point being the mic not see myself

00:14:21,259 --> 00:14:26,069
you should use the mic okay because you

00:14:23,939 --> 00:14:30,689
know it's going to unless you don't want

00:14:26,069 --> 00:14:33,779
your parents to see you on YouTube my

00:14:30,689 --> 00:14:35,250
only point is that these are mostly when

00:14:33,779 --> 00:14:37,949
I look at this list that list is the

00:14:35,250 --> 00:14:39,449
deficiency in the hardware to driver API

00:14:37,949 --> 00:14:40,560
not knowing how your hardware

00:14:39,449 --> 00:14:41,970
architecture works maybe it's also

00:14:40,560 --> 00:14:44,430
deficiencies in the hardware have no

00:14:41,970 --> 00:14:46,110
comment on that and I think the changes

00:14:44,430 --> 00:14:48,300
from the OS to the driver are fairly

00:14:46,110 --> 00:14:49,470
minimal for l2 and l3 because we've done

00:14:48,300 --> 00:14:51,810
most of the work already

00:14:49,470 --> 00:14:53,009
sans maybe this one small patch to get

00:14:51,810 --> 00:14:54,870
the l2 working which i think is a

00:14:53,009 --> 00:14:57,389
relatively small patch at this point and

00:14:54,870 --> 00:14:59,029
I think l3 should by and large work out

00:14:57,389 --> 00:15:02,160
of the box if you implement the api's

00:14:59,029 --> 00:15:03,750
okay so I think you what you're saying

00:15:02,160 --> 00:15:05,699
is if the hardware doesn't know how to

00:15:03,750 --> 00:15:12,240
learn its deficient is that what you

00:15:05,699 --> 00:15:15,750
meant no I'm I'm saying if you're if

00:15:12,240 --> 00:15:17,279
your hardware can't implement LPM that

00:15:15,750 --> 00:15:19,500
is a requirement for doing layer 3

00:15:17,279 --> 00:15:21,240
routing from the OSS perspective and if

00:15:19,500 --> 00:15:23,279
you're not doing layer 3 routes with LPS

00:15:21,240 --> 00:15:24,540
you're not doing layer 3 routing in the

00:15:23,279 --> 00:15:27,180
sense that the kernel does routing so

00:15:24,540 --> 00:15:28,829
you have to do something else my point

00:15:27,180 --> 00:15:30,600
in saying that all that all of the API

00:15:28,829 --> 00:15:33,420
is I think are working and ready to go

00:15:30,600 --> 00:15:35,670
except for as you can put it out the l2

00:15:33,420 --> 00:15:37,199
thing which I've looked at that code

00:15:35,670 --> 00:15:38,610
before to implement it and I think it's

00:15:37,199 --> 00:15:41,939
a fairly small patch and could be done

00:15:38,610 --> 00:15:44,339
in like weeks Ramzan I agree 100% what

00:15:41,939 --> 00:15:47,160
I'm trying that in the l3 case because

00:15:44,339 --> 00:15:50,160
this is was a very simple case there's

00:15:47,160 --> 00:15:52,050
no es CBEC ampere there's no PRF the

00:15:50,160 --> 00:15:56,129
kernel model is very sophisticated so if

00:15:52,050 --> 00:15:58,860
you would always use I if in my driver

00:15:56,129 --> 00:16:00,779
core the user very very limited api's my

00:15:58,860 --> 00:16:02,879
driver will be I mean bigger and bigger

00:16:00,779 --> 00:16:03,870
I'm not arguing with you I just wanted

00:16:02,879 --> 00:16:05,459
to be clear for everyone in the audience

00:16:03,870 --> 00:16:06,870
yes that didn't they didn't walk away

00:16:05,459 --> 00:16:08,189
with the impression that the Linux OS

00:16:06,870 --> 00:16:10,019
didn't support all this already which

00:16:08,189 --> 00:16:13,980
which was my sort of impression from

00:16:10,019 --> 00:16:15,629
readiness like I don't want to talk to

00:16:13,980 --> 00:16:18,089
your meeting but so your angle of how

00:16:15,629 --> 00:16:22,680
you do this is use USB edit to pretend

00:16:18,089 --> 00:16:25,620
it in LPM or oh no no no ok that's okay

00:16:22,680 --> 00:16:27,230
I'm sorry no no again the P I did stuff

00:16:25,620 --> 00:16:30,629
ok that's that's confused

00:16:27,230 --> 00:16:33,990
if your control plane by itself Jamal is

00:16:30,629 --> 00:16:36,119
is flow-based okay so they they they

00:16:33,990 --> 00:16:38,160
they like do all the routing in their

00:16:36,119 --> 00:16:40,740
minds and in the end of the day they

00:16:38,160 --> 00:16:42,389
configure a flow okay so they only need

00:16:40,740 --> 00:16:44,100
they need to you at the only thing so

00:16:42,389 --> 00:16:45,240
they would do that the LPM they would do

00:16:44,100 --> 00:16:47,490
the neighbor they would do everything

00:16:45,240 --> 00:16:49,050
that in the end of the day they would

00:16:47,490 --> 00:16:51,360
just give you a flow that you do

00:16:49,050 --> 00:16:53,160
matching and you have to forward it but

00:16:51,360 --> 00:16:55,499
as part of the forwarding they will tell

00:16:53,160 --> 00:16:58,319
you hey rewrite the max and the TTL

00:16:55,499 --> 00:17:00,839
that's it so this this would apply for

00:16:58,319 --> 00:17:03,600
control component compelling excuse me

00:17:00,839 --> 00:17:06,240
like DVR distributed virtual router

00:17:03,600 --> 00:17:08,039
which is flow based okay that's one

00:17:06,240 --> 00:17:10,380
thing that it can be supported today

00:17:08,039 --> 00:17:11,970
okay I think we have patches further

00:17:10,380 --> 00:17:18,089
right you have it too right so so it

00:17:11,970 --> 00:17:20,130
that's supported so but if your yes but

00:17:18,089 --> 00:17:22,140
if your if you are trying to take a

00:17:20,130 --> 00:17:25,169
Linux router they're not using flows

00:17:22,140 --> 00:17:30,419
right they are using fibs and now you

00:17:25,169 --> 00:17:33,000
want to offload that nobody model is

00:17:30,419 --> 00:17:36,779
different because they they would they

00:17:33,000 --> 00:17:46,830
would be the LP m3 you got it okay good

00:17:36,779 --> 00:17:48,270
okay so excuse me yes so as I mentioned

00:17:46,830 --> 00:17:50,970
earlier we have these things called

00:17:48,270 --> 00:17:55,200
representers which is part of the switch

00:17:50,970 --> 00:17:58,049
ative SRV model so what a representer is

00:17:55,200 --> 00:18:02,010
is as its name implies it represents

00:17:58,049 --> 00:18:04,610
some kind of port if you think of a

00:18:02,010 --> 00:18:07,470
switch kind of model

00:18:04,610 --> 00:18:09,090
so for each VF for example and the VF

00:18:07,470 --> 00:18:12,419
smoke themselves might be handed off to

00:18:09,090 --> 00:18:14,700
VMs you're left with a represented on in

00:18:12,419 --> 00:18:17,370
the host the Juhu news to get fallback

00:18:14,700 --> 00:18:19,860
traffic you can use to configure aspects

00:18:17,370 --> 00:18:22,799
of the port like the link state and so

00:18:19,860 --> 00:18:25,950
on and also to collect statistics and

00:18:22,799 --> 00:18:27,809
how many packets in and out and so on so

00:18:25,950 --> 00:18:32,279
in the beginning there was only one type

00:18:27,809 --> 00:18:37,200
of port you could have which is just the

00:18:32,279 --> 00:18:38,429
physical ports and then we can get

00:18:37,200 --> 00:18:40,440
virtual ports and now we can get

00:18:38,429 --> 00:18:40,990
representers and at here we can get

00:18:40,440 --> 00:18:44,380
represent

00:18:40,990 --> 00:18:46,720
for the different types of ports so most

00:18:44,380 --> 00:18:49,000
of the drivers have representatives only

00:18:46,720 --> 00:18:50,350
for virtual ports but in the metronome

00:18:49,000 --> 00:18:53,950
case we also have them for physical

00:18:50,350 --> 00:18:55,510
ports and a few other things too so what

00:18:53,950 --> 00:18:58,900
this proposal is I won't read through it

00:18:55,510 --> 00:19:00,610
but is the idea to standardize on the

00:18:58,900 --> 00:19:05,140
string that is exported to use a space

00:19:00,610 --> 00:19:07,480
to a sea surface to allow orchestration

00:19:05,140 --> 00:19:10,059
to differentiate between different types

00:19:07,480 --> 00:19:12,130
of Representatives so I can we can

00:19:10,059 --> 00:19:14,050
basically know that this represent is

00:19:12,130 --> 00:19:16,270
associated with physical port number one

00:19:14,050 --> 00:19:18,340
whatever physical port number one means

00:19:16,270 --> 00:19:20,470
whereas this other represented is

00:19:18,340 --> 00:19:22,270
associated with virtual port number six

00:19:20,470 --> 00:19:29,070
whatever that means

00:19:22,270 --> 00:19:31,840
and this game covers not all conceivable

00:19:29,070 --> 00:19:34,000
combinations but all that are likely to

00:19:31,840 --> 00:19:37,840
be used in practice in the foreseeable

00:19:34,000 --> 00:19:40,000
future so actually this was proposed by

00:19:37,840 --> 00:19:49,510
my colleague Jakob I just copy pasted

00:19:40,000 --> 00:19:51,190
his email into the slide so in a

00:19:49,510 --> 00:19:53,830
secondary part of this proposal which is

00:19:51,190 --> 00:19:55,510
from from Yuri over here is right now

00:19:53,830 --> 00:19:57,490
these strings are just generated by the

00:19:55,510 --> 00:19:59,380
drivers themselves so typically they'll

00:19:57,490 --> 00:20:02,770
just put the number of the VF or

00:19:59,380 --> 00:20:04,510
something in there but it's up to the

00:20:02,770 --> 00:20:05,950
drivers to conform to whatever standard

00:20:04,510 --> 00:20:09,130
there is and there isn't so much of a

00:20:05,950 --> 00:20:11,320
standard and yet his idea was that some

00:20:09,130 --> 00:20:16,600
higher labor layer maybe dev link or

00:20:11,320 --> 00:20:20,559
whatever could generate these so that it

00:20:16,600 --> 00:20:21,940
would basically it would be up to a

00:20:20,559 --> 00:20:23,500
higher level to generate the string

00:20:21,940 --> 00:20:25,780
based on the information provided by the

00:20:23,500 --> 00:20:28,240
driver rather than the driver generating

00:20:25,780 --> 00:20:29,350
the string you mean those strings or

00:20:28,240 --> 00:20:31,210
yeah those strings

00:20:29,350 --> 00:20:33,850
I think if we can get to alignment and

00:20:31,210 --> 00:20:37,380
agree and we can patch our driver and II

00:20:33,850 --> 00:20:39,400
like you can I know that you're also so

00:20:37,380 --> 00:20:44,380
devices today your name by system D

00:20:39,400 --> 00:20:45,550
right sort of kind of I mean I guess

00:20:44,380 --> 00:20:48,190
that was one of the things I wanted to

00:20:45,550 --> 00:20:49,929
just say what this is yeah so I forgot

00:20:48,190 --> 00:20:52,540
to mention one of the motivations for

00:20:49,929 --> 00:20:53,860
this is to allow system D or whatever to

00:20:52,540 --> 00:20:57,390
give consistent names to

00:20:53,860 --> 00:20:59,470
there's dust the title of the slide I

00:20:57,390 --> 00:21:03,040
just didn't see everybody's favorite

00:20:59,470 --> 00:21:05,170
system do you list it up okay so yeah so

00:21:03,040 --> 00:21:07,090
I guess I think this sounds pretty good

00:21:05,170 --> 00:21:08,380
and obviously I think I mean several

00:21:07,090 --> 00:21:10,360
people know like in this martynuk use

00:21:08,380 --> 00:21:12,490
case that I've talked about there is the

00:21:10,360 --> 00:21:13,660
idea of some more representers for maybe

00:21:12,490 --> 00:21:18,480
some devices that aren't directly

00:21:13,660 --> 00:21:22,000
connected to your to your your your

00:21:18,480 --> 00:21:23,200
namespace but anyway I think like

00:21:22,000 --> 00:21:24,429
something like this would work well I

00:21:23,200 --> 00:21:26,169
mean do we think that we can work

00:21:24,429 --> 00:21:26,950
together with system D to help get these

00:21:26,169 --> 00:21:28,030
name correctly

00:21:26,950 --> 00:21:29,710
I mean if we provide them the right

00:21:28,030 --> 00:21:31,510
input or do we really want to allow this

00:21:29,710 --> 00:21:33,280
I mean it seems like we ought to let

00:21:31,510 --> 00:21:36,760
system do you do the naming as yes as I

00:21:33,280 --> 00:21:38,260
hate to say that so absolutely the

00:21:36,760 --> 00:21:41,320
naming should be left to give the space

00:21:38,260 --> 00:21:43,960
and yeah the the implication of this is

00:21:41,320 --> 00:21:46,690
that we can work with system da or you

00:21:43,960 --> 00:21:53,410
dev or whatever to get it updated good

00:21:46,690 --> 00:21:55,179
so we all will align also just yeah so

00:21:53,410 --> 00:21:57,970
what we're talking about here to be

00:21:55,179 --> 00:22:00,130
clear is is providing a hint to use a

00:21:57,970 --> 00:22:03,040
space using sisyphus which already

00:22:00,130 --> 00:22:05,710
exists but just standardizing on on the

00:22:03,040 --> 00:22:07,299
format of the contents of that hint so

00:22:05,710 --> 00:22:09,640
that user space can do whatever it wants

00:22:07,299 --> 00:22:12,040
with it but you're talking about the

00:22:09,640 --> 00:22:14,919
name of the of the net device or talking

00:22:12,040 --> 00:22:18,490
about the inner naming from the switch

00:22:14,919 --> 00:22:22,000
dev so that the the user space could use

00:22:18,490 --> 00:22:24,150
it to rename the net devices or it could

00:22:22,000 --> 00:22:24,150
not

00:22:36,340 --> 00:22:43,700
so we can share the slides with you

00:22:39,950 --> 00:22:45,380
later yes that that's it it's something

00:22:43,700 --> 00:22:47,120
that Jacob sent on the least and we can

00:22:45,380 --> 00:22:49,760
it's on the mailing list maybe we should

00:22:47,120 --> 00:22:53,140
have anyway maybe we can use some break

00:22:49,760 --> 00:22:57,919
and see that the keyword you want is

00:22:53,140 --> 00:23:04,820
this poor name and mousse you a part of

00:22:57,919 --> 00:23:07,309
the thread okay okay so moving on so

00:23:04,820 --> 00:23:09,620
this slide is just right now in the

00:23:07,309 --> 00:23:16,460
corner we have two different models

00:23:09,620 --> 00:23:19,130
being used for various RV representation

00:23:16,460 --> 00:23:20,929
of of it's not really CPU port but of

00:23:19,130 --> 00:23:23,750
relationship between physical links

00:23:20,929 --> 00:23:25,370
links and the natives so there's the the

00:23:23,750 --> 00:23:27,080
model which is first done by Mellanox

00:23:25,370 --> 00:23:30,970
and which everyone except metronome has

00:23:27,080 --> 00:23:33,740
followed and so that's model number one

00:23:30,970 --> 00:23:36,289
and in this model you get a PF for every

00:23:33,740 --> 00:23:38,000
physical port just as you would it for

00:23:36,289 --> 00:23:43,760
basically every other Nick you've ever

00:23:38,000 --> 00:23:45,260
seen I use the word represents here this

00:23:43,760 --> 00:23:47,570
is incorrect it basically is the

00:23:45,260 --> 00:23:50,510
physical port so there you are

00:23:47,570 --> 00:23:53,299
so we are going to change it and to

00:23:50,510 --> 00:23:54,890
align to so this time from powerful

00:23:53,299 --> 00:23:57,799
ization environment where the physical

00:23:54,890 --> 00:24:00,289
port is represented IDPF but it doesn't

00:23:57,799 --> 00:24:02,360
apply well to this model and to some

00:24:00,289 --> 00:24:04,640
generalization and extensions of it for

00:24:02,360 --> 00:24:06,520
smart Nick and for other stuff so we

00:24:04,640 --> 00:24:08,779
would we would actually introduce

00:24:06,520 --> 00:24:12,380
representer for the uplink for the

00:24:08,779 --> 00:24:16,220
physical ports right yes regarding the

00:24:12,380 --> 00:24:18,380
representa for the PF we do that but so

00:24:16,220 --> 00:24:20,539
I guess that's also doable I mean that's

00:24:18,380 --> 00:24:23,929
not I think that's that's the more

00:24:20,539 --> 00:24:26,330
general model and I III don't see a

00:24:23,929 --> 00:24:27,620
problem is do that yeah so in the in the

00:24:26,330 --> 00:24:31,460
model to which is so far only

00:24:27,620 --> 00:24:33,200
implemented for NFP the reason we chose

00:24:31,460 --> 00:24:37,220
this is because it better matches the

00:24:33,200 --> 00:24:39,040
physical hardware we have because in the

00:24:37,220 --> 00:24:41,320
case of our hardware there is no

00:24:39,040 --> 00:24:43,660
a coupling between the PF and the

00:24:41,320 --> 00:24:45,730
physical ports so it didn't really make

00:24:43,660 --> 00:24:47,770
sense to expose that to the host we

00:24:45,730 --> 00:24:49,930
could have and kind of lied but we

00:24:47,770 --> 00:24:52,390
decided not to so instead we have this

00:24:49,930 --> 00:24:54,880
kind of new thing which is that we have

00:24:52,390 --> 00:24:56,830
a negative for the PF itself and this is

00:24:54,880 --> 00:25:00,580
just a connection between the host and

00:24:56,830 --> 00:25:01,960
the card and we can use it for various

00:25:00,580 --> 00:25:04,570
things but that's it it's not associated

00:25:01,960 --> 00:25:06,970
with any type of port physics so what is

00:25:04,570 --> 00:25:14,650
the use what is the use for their path

00:25:06,970 --> 00:25:18,390
native what is used for so in practice

00:25:14,650 --> 00:25:22,390
what we use it for yeah is we use it to

00:25:18,390 --> 00:25:24,850
carry all the so we have it as a lower

00:25:22,390 --> 00:25:29,140
device and we put all our representers

00:25:24,850 --> 00:25:30,940
as upper devices on top of it so this is

00:25:29,140 --> 00:25:34,450
a net-net device that's can send traffic

00:25:30,940 --> 00:25:36,100
and receive traffic yes but their

00:25:34,450 --> 00:25:44,500
traffic only goes between the host and

00:25:36,100 --> 00:25:46,540
the card so I believe the idea is going

00:25:44,500 --> 00:25:48,280
towards more of a true switch like ma

00:25:46,540 --> 00:25:51,760
right because that's where you would

00:25:48,280 --> 00:25:54,190
want a default interface per you know

00:25:51,760 --> 00:25:55,630
port on the switch and PF becomes then a

00:25:54,190 --> 00:25:56,920
port on the switch and then you want a

00:25:55,630 --> 00:25:58,900
default interface which is your PF

00:25:56,920 --> 00:26:01,090
representor yes and I think it works

00:25:58,900 --> 00:26:03,220
better going forward for a lot of things

00:26:01,090 --> 00:26:05,110
where there is a decoupling between the

00:26:03,220 --> 00:26:07,540
PF interface and external port I don't

00:26:05,110 --> 00:26:09,070
think yes so somebody from Mellanox is

00:26:07,540 --> 00:26:10,810
talking about the multi-home stuff and

00:26:09,070 --> 00:26:12,340
it becomes very handy there right right

00:26:10,810 --> 00:26:13,540
so we can go into that a little bit I

00:26:12,340 --> 00:26:15,660
don't know how much time we have but the

00:26:13,540 --> 00:26:18,250
other half as you mentioned is we have

00:26:15,660 --> 00:26:21,240
we have no matter we have represented

00:26:18,250 --> 00:26:21,240
for the physical ports

00:26:26,029 --> 00:26:31,289
okay and so we also have which is not

00:26:29,610 --> 00:26:32,940
written here because I thought it would

00:26:31,289 --> 00:26:35,669
be confusing but we also have a

00:26:32,940 --> 00:26:37,889
representer for the PF and this

00:26:35,669 --> 00:26:40,590
representor could be shared to secondary

00:26:37,889 --> 00:26:42,480
hosts and so they can control or get

00:26:40,590 --> 00:27:30,110
information about the PF without owning

00:26:42,480 --> 00:27:30,110
the maybe he can

00:27:35,730 --> 00:27:41,440
sorry you guys so yeah it is my

00:27:40,000 --> 00:27:43,330
colleague Jakob he he actually designed

00:27:41,440 --> 00:27:46,120
the thing that I'm sorry about yeah it's

00:27:43,330 --> 00:27:48,160
another VF effectively so the VF minus

00:27:46,120 --> 00:27:48,670
one or whatever and it works exactly the

00:27:48,160 --> 00:27:50,530
same way

00:27:48,670 --> 00:27:59,170
fall back goes to the representor and

00:27:50,530 --> 00:28:00,850
everything I think the problem that will

00:27:59,170 --> 00:28:02,200
confuse people that that's the reason we

00:28:00,850 --> 00:28:05,650
didn't do it in the beginning because

00:28:02,200 --> 00:28:10,030
when like you running open open stock or

00:28:05,650 --> 00:28:12,550
open this which yes so you currently use

00:28:10,030 --> 00:28:15,160
the old physical function and connect it

00:28:12,550 --> 00:28:18,910
to the bridge so that's what people do

00:28:15,160 --> 00:28:21,160
today so now you can use them and have

00:28:18,910 --> 00:28:23,560
another link and it the question is is

00:28:21,160 --> 00:28:25,150
the original link or not I understand

00:28:23,560 --> 00:28:26,860
that so we need to have another link for

00:28:25,150 --> 00:28:28,600
the localhost and probably will have

00:28:26,860 --> 00:28:31,120
more links like when you're talking

00:28:28,600 --> 00:28:34,330
about containers who you probably will

00:28:31,120 --> 00:28:35,830
be III I agree about this confusion

00:28:34,330 --> 00:28:38,470
point and I think we would have did we

00:28:35,830 --> 00:28:40,900
discussed that I seem to recall but it

00:28:38,470 --> 00:28:44,190
comes back to we want to represent the

00:28:40,900 --> 00:28:46,690
hardware in the OS rather than

00:28:44,190 --> 00:28:48,940
misrepresented by saying that each

00:28:46,690 --> 00:28:54,010
physical port is a PF which in the case

00:28:48,940 --> 00:28:55,810
of our hardware is not true so that that

00:28:54,010 --> 00:28:57,610
we how do we use the existing software

00:28:55,810 --> 00:28:58,960
model to match the new hardware that's

00:28:57,610 --> 00:29:01,780
that was the question we were trying to

00:28:58,960 --> 00:29:06,850
solve so the I think the question is is

00:29:01,780 --> 00:29:10,360
the part if the uplink is the physical

00:29:06,850 --> 00:29:13,030
function or and I think you need just to

00:29:10,360 --> 00:29:16,810
flip them so the uplink continue to be

00:29:13,030 --> 00:29:20,020
the external put the puffs sorry is the

00:29:16,810 --> 00:29:21,280
uplink representer and you can have like

00:29:20,020 --> 00:29:28,630
you have virtual function you can have

00:29:21,280 --> 00:29:30,130
in other ports no the uplink representer

00:29:28,630 --> 00:29:32,080
is the macro presenter it's just a

00:29:30,130 --> 00:29:34,860
different word for the same thing no

00:29:32,080 --> 00:29:34,860
this is the link between

00:29:36,750 --> 00:29:41,559
is the uplink itself link yeah sorry

00:29:39,880 --> 00:29:44,410
okay so the physical function is not the

00:29:41,559 --> 00:29:49,000
uplink no no no so you okay so you

00:29:44,410 --> 00:29:51,309
adding another another port just is not

00:29:49,000 --> 00:29:55,540
connected to the uplink so so so it's

00:29:51,309 --> 00:29:57,580
gone so no matter how many so no matter

00:29:55,540 --> 00:30:06,160
how many you always get exactly one of

00:29:57,580 --> 00:30:09,570
these let's continue this later okay

00:30:06,160 --> 00:30:09,570
thank you guys thank you

00:30:09,720 --> 00:30:12,970

YouTube URL: https://www.youtube.com/watch?v=Thx31C-V-CU


