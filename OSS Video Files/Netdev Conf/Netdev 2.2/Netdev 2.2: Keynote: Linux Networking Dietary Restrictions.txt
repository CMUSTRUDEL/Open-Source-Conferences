Title: Netdev 2.2: Keynote: Linux Networking Dietary Restrictions
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker:  David Miller
Seoul, Korea
Friday November 10th, 2017 
https://www.netdevconf.org/2.2/session.html?miller-datastructurebloat-keynote
Captions: 
	00:00:01,040 --> 00:00:05,779
okay welcome everyone to the third day

00:00:04,040 --> 00:00:06,920
of net dev I hope everyone's having a

00:00:05,779 --> 00:00:08,570
great time and enjoying all the

00:00:06,920 --> 00:00:11,960
presentations and high quality content

00:00:08,570 --> 00:00:13,730
we've had so far so today I'm gonna talk

00:00:11,960 --> 00:00:15,680
about one of my long-running favorite

00:00:13,730 --> 00:00:19,220
topics to talk about well I guess it has

00:00:15,680 --> 00:00:21,500
become my favorite topic because getting

00:00:19,220 --> 00:00:23,660
results in this area is really

00:00:21,500 --> 00:00:26,630
pleasurable in my personal opinion so

00:00:23,660 --> 00:00:29,600
we're going to talk about shrinking data

00:00:26,630 --> 00:00:32,930
structures and let's get right to it so

00:00:29,600 --> 00:00:34,899
in my opinion small is beautiful if you

00:00:32,930 --> 00:00:36,859
look at a lot of architectural

00:00:34,899 --> 00:00:38,420
masterminds over the years this is

00:00:36,859 --> 00:00:39,769
something that they believe is well as

00:00:38,420 --> 00:00:42,409
small and simple is something to strive

00:00:39,769 --> 00:00:45,350
for and I believe that's the same for

00:00:42,409 --> 00:00:47,089
software as well so look at some

00:00:45,350 --> 00:00:50,510
critical Linux networking data

00:00:47,089 --> 00:00:52,639
structures in the tree the first one we

00:00:50,510 --> 00:00:54,769
have is the packet metadata structure

00:00:52,639 --> 00:00:57,709
called SK buff it's about two hundred

00:00:54,769 --> 00:01:01,969
sixteen bytes and one thing to note

00:00:57,709 --> 00:01:04,549
about this is it heavily contributes to

00:01:01,969 --> 00:01:06,140
the transactional cost of every packet

00:01:04,549 --> 00:01:09,410
traversing through the networking stack

00:01:06,140 --> 00:01:11,660
this is indisputable so any change to

00:01:09,410 --> 00:01:14,530
this structure however minor a minuscule

00:01:11,660 --> 00:01:17,540
has enormous implications for

00:01:14,530 --> 00:01:20,720
performance and functionality in the

00:01:17,540 --> 00:01:23,300
kernel so that thing is 216 bytes

00:01:20,720 --> 00:01:24,560
another thing that's in particular to

00:01:23,300 --> 00:01:27,560
mention about this data structure is

00:01:24,560 --> 00:01:30,920
that we are extremely strict about any

00:01:27,560 --> 00:01:33,500
addition whatsoever to this I you're

00:01:30,920 --> 00:01:35,930
gonna have to do something really

00:01:33,500 --> 00:01:37,880
incredible to convince us to even add a

00:01:35,930 --> 00:01:39,380
bit to this structure it that's how

00:01:37,880 --> 00:01:42,140
critical it is that a Linux networking

00:01:39,380 --> 00:01:43,430
stack the next one is the struct test

00:01:42,140 --> 00:01:45,290
entry and there's going to be quite a

00:01:43,430 --> 00:01:48,110
bit of content about this data structure

00:01:45,290 --> 00:01:50,030
in the keynote this is the base class

00:01:48,110 --> 00:01:53,960
for every single route type that we have

00:01:50,030 --> 00:01:57,080
in a Linux kernel so ipv4 routes ipv6

00:01:53,960 --> 00:01:59,479
routes IPSec routes they all start with

00:01:57,080 --> 00:02:02,479
a test entry as their base class and

00:01:59,479 --> 00:02:04,190
it's currently 160 bytes and as you will

00:02:02,479 --> 00:02:08,390
see later that's far too large it's

00:02:04,190 --> 00:02:11,420
unnecessarily large so as I said the

00:02:08,390 --> 00:02:14,840
ipv4 route it's called struck our table

00:02:11,420 --> 00:02:16,940
is the struck test entry plus some ipv4

00:02:14,840 --> 00:02:20,870
cific information it's currently 216

00:02:16,940 --> 00:02:23,090
bytes to ipv6 route RT 6 info likewise

00:02:20,870 --> 00:02:26,360
starts with a desk to entry and then has

00:02:23,090 --> 00:02:31,489
a bunch of ipv6 info and its 384 bytes

00:02:26,360 --> 00:02:35,090
now obviously ipv4 excuse me ipv6

00:02:31,489 --> 00:02:37,580
addresses for larger than ipv4 addresses

00:02:35,090 --> 00:02:40,430
therefore even if it contained the same

00:02:37,580 --> 00:02:42,680
number of kinds of information it would

00:02:40,430 --> 00:02:44,870
be larger but it's it's to an order of

00:02:42,680 --> 00:02:47,959
magnitude larger because it stores more

00:02:44,870 --> 00:02:50,480
addresses in its protocol specific area

00:02:47,959 --> 00:02:52,549
than ipv4 does so maybe we can fix that

00:02:50,480 --> 00:02:54,980
somehow because and therefore therefore

00:02:52,549 --> 00:02:57,349
another way to think about it is every

00:02:54,980 --> 00:02:59,360
address we move from the rt6 info has a

00:02:57,349 --> 00:03:01,819
larger impact and removing address from

00:02:59,360 --> 00:03:04,190
the ipv4 route so we should strive to do

00:03:01,819 --> 00:03:06,110
something about that next we have

00:03:04,190 --> 00:03:08,209
something called struct common it's kind

00:03:06,110 --> 00:03:09,200
of like the base class for the all

00:03:08,209 --> 00:03:12,650
sockets

00:03:09,200 --> 00:03:16,069
it's 136 bytes then we have struck sock

00:03:12,650 --> 00:03:18,110
itself which is furthermore a base class

00:03:16,069 --> 00:03:20,359
for all protocol specific sockets in a

00:03:18,110 --> 00:03:24,290
networking tree and that's 704 bytes and

00:03:20,359 --> 00:03:26,150
that's quite large and then we have the

00:03:24,290 --> 00:03:28,040
struct net device which is almost 2 K

00:03:26,150 --> 00:03:29,989
and this doesn't even take into

00:03:28,040 --> 00:03:32,900
consideration all the sisyphus files

00:03:29,989 --> 00:03:36,200
that are instantiating when you create a

00:03:32,900 --> 00:03:38,630
net device and and open and set it up so

00:03:36,200 --> 00:03:40,790
that things even enormous by it an order

00:03:38,630 --> 00:03:42,920
of magnitude even more so it looks like

00:03:40,790 --> 00:03:47,230
we have a lot of work to do and things

00:03:42,920 --> 00:03:50,030
have clearly clearly spun out of control

00:03:47,230 --> 00:03:51,500
so why is this matter performance is the

00:03:50,030 --> 00:03:54,109
dictating factor for a lot of these

00:03:51,500 --> 00:03:57,139
decisions as I mentioned with the SK

00:03:54,109 --> 00:03:58,639
both minor modifications to these data

00:03:57,139 --> 00:04:01,639
structures have enormous performance

00:03:58,639 --> 00:04:03,500
implications for everyone smaller data

00:04:01,639 --> 00:04:05,299
structures less cache misses this is

00:04:03,500 --> 00:04:07,340
something almost all of us who work on

00:04:05,299 --> 00:04:09,169
the kernel understand at this point size

00:04:07,340 --> 00:04:11,989
also about complexity bigger things are

00:04:09,169 --> 00:04:15,440
harder to understand and harder to

00:04:11,989 --> 00:04:16,340
maintain this goes into what my area you

00:04:15,440 --> 00:04:18,019
don't want to make things harder to

00:04:16,340 --> 00:04:21,320
maintain that means more work for me and

00:04:18,019 --> 00:04:23,419
memory is a scarce resource even on

00:04:21,320 --> 00:04:24,830
large systems because on large systems

00:04:23,419 --> 00:04:26,539
you're trying to handle large number of

00:04:24,830 --> 00:04:28,460
connections large number of routes large

00:04:26,539 --> 00:04:30,800
number of packets and flight etc

00:04:28,460 --> 00:04:33,650
so making things smaller is great for

00:04:30,800 --> 00:04:36,500
everyone so what kind of techniques can

00:04:33,650 --> 00:04:38,800
we use to fix this data structure blow

00:04:36,500 --> 00:04:42,490
problem well the first one is a

00:04:38,800 --> 00:04:45,560
technique which I call uncommon ting and

00:04:42,490 --> 00:04:49,009
the next one is called state compression

00:04:45,560 --> 00:04:50,900
that's about taking you're reducing your

00:04:49,009 --> 00:04:53,840
representation of a piece of data to the

00:04:50,900 --> 00:04:55,340
smallest point possible unused pointer

00:04:53,840 --> 00:04:56,750
bit storage which is interesting it

00:04:55,340 --> 00:04:58,850
turns out that the lowest bits of

00:04:56,750 --> 00:05:01,030
pointers are freely usable for boolean

00:04:58,850 --> 00:05:04,430
and other kinds of small integer state

00:05:01,030 --> 00:05:06,500
unionizing state specific numbers so I

00:05:04,430 --> 00:05:08,210
first came across this technique in the

00:05:06,500 --> 00:05:10,570
struct page in the kernel they've been

00:05:08,210 --> 00:05:13,070
using this for a long time you have two

00:05:10,570 --> 00:05:15,169
data structure members that are used at

00:05:13,070 --> 00:05:16,639
completely disjoint points in time and

00:05:15,169 --> 00:05:18,560
the data structures lifetime and

00:05:16,639 --> 00:05:21,199
therefore it's it's it's safe to use the

00:05:18,560 --> 00:05:24,320
same area of the data structure to hold

00:05:21,199 --> 00:05:27,349
that value we have using lookup keys

00:05:24,320 --> 00:05:29,599
instead of object pointers so if the key

00:05:27,349 --> 00:05:31,070
that you use to look up an object that

00:05:29,599 --> 00:05:32,960
sits in the kernel is smaller than a

00:05:31,070 --> 00:05:34,699
pointer that it may make sense to store

00:05:32,960 --> 00:05:37,310
the key instead of the object pointer

00:05:34,699 --> 00:05:39,340
itself and we'll get into that later so

00:05:37,310 --> 00:05:41,139
what is this fancy thing I called

00:05:39,340 --> 00:05:43,490
uncommon Inge

00:05:41,139 --> 00:05:45,650
well uncommon II deals with the

00:05:43,490 --> 00:05:47,810
situation where you have members of a

00:05:45,650 --> 00:05:49,820
common base class that are only used by

00:05:47,810 --> 00:05:51,110
someone as two subclasses so what tends

00:05:49,820 --> 00:05:53,690
to happen when we designs data

00:05:51,110 --> 00:05:56,870
structures is we have four types of

00:05:53,690 --> 00:05:59,030
objects an ipv4 route ipv6 X throughout

00:05:56,870 --> 00:06:00,590
an IPSec route and we try to see what's

00:05:59,030 --> 00:06:02,270
common amongst them and just put it into

00:06:00,590 --> 00:06:03,889
the base class that they can all share

00:06:02,270 --> 00:06:06,710
and that's what happened what struck

00:06:03,889 --> 00:06:08,930
test entry however over time so I'm

00:06:06,710 --> 00:06:10,669
gonna subclasses stop using those common

00:06:08,930 --> 00:06:12,800
deston tree members and we haven't

00:06:10,669 --> 00:06:16,130
updated dest entry to reflect this fact

00:06:12,800 --> 00:06:18,099
in a reasonable way in many cases as we

00:06:16,130 --> 00:06:21,710
will find in this presentation the

00:06:18,099 --> 00:06:24,800
common entry in the desk desk structure

00:06:21,710 --> 00:06:27,440
only is used by one of the subclasses so

00:06:24,800 --> 00:06:28,669
that's absolutely inappropriate so what

00:06:27,440 --> 00:06:30,289
should we do we should push it down into

00:06:28,669 --> 00:06:33,199
the subclasses that actually use them

00:06:30,289 --> 00:06:35,300
and we'll talk about that now so here is

00:06:33,199 --> 00:06:37,969
desk entry as it exists before we make

00:06:35,300 --> 00:06:40,310
any changes as you can see we have a

00:06:37,969 --> 00:06:42,020
struct net device it's be pretty hard to

00:06:40,310 --> 00:06:43,639
have a route without

00:06:42,020 --> 00:06:45,110
that the route points to you right so

00:06:43,639 --> 00:06:47,270
that doesn't seem to be a clear way to

00:06:45,110 --> 00:06:50,180
get rid of that we have an RC you head

00:06:47,270 --> 00:06:51,530
so routes are generally freed by RC you

00:06:50,180 --> 00:06:52,009
Frings so that's probably going to stay

00:06:51,530 --> 00:06:54,319
there

00:06:52,009 --> 00:06:56,240
we have des entry child that's a

00:06:54,319 --> 00:06:59,780
candidate and we'll get into why later

00:06:56,240 --> 00:07:02,810
we have metrics we haven't a set of

00:06:59,780 --> 00:07:05,389
operations at this offset and by the way

00:07:02,810 --> 00:07:07,789
these are the hexadecimal offsets of all

00:07:05,389 --> 00:07:09,139
the data structure members and struct

00:07:07,789 --> 00:07:11,509
des des entry that's what these numbers

00:07:09,139 --> 00:07:12,710
are over here so we'll keep track of

00:07:11,509 --> 00:07:15,440
where everything is laying in the data

00:07:12,710 --> 00:07:18,169
structure metrics all kinds of routes

00:07:15,440 --> 00:07:19,759
have metrics such as the RTT and things

00:07:18,169 --> 00:07:22,159
of this nature so that's probably going

00:07:19,759 --> 00:07:24,080
to stay there we have an expiration all

00:07:22,159 --> 00:07:26,449
routes have various kinds of expiration

00:07:24,080 --> 00:07:27,949
times for dealing with p.m. tu events

00:07:26,449 --> 00:07:29,419
and things of this nature so that's

00:07:27,949 --> 00:07:31,699
probably something we'll have to keep in

00:07:29,419 --> 00:07:35,300
there we have pointers to other deaths

00:07:31,699 --> 00:07:36,770
entries a routing path and from well

00:07:35,300 --> 00:07:39,560
we'll have to see what's going to go on

00:07:36,770 --> 00:07:42,110
with those two we have a transform state

00:07:39,560 --> 00:07:44,960
which is a pointer to IPSec specific

00:07:42,110 --> 00:07:47,690
information this this member serves two

00:07:44,960 --> 00:07:50,840
purposes it's a pointer to the IPSec

00:07:47,690 --> 00:07:54,680
specific information it's also an

00:07:50,840 --> 00:07:56,599
indicator that the this dest entry is

00:07:54,680 --> 00:07:58,789
serving as a base class for an IPSec

00:07:56,599 --> 00:08:00,740
route so there is some clever things we

00:07:58,789 --> 00:08:02,180
might be able to do with that later we

00:08:00,740 --> 00:08:04,250
have an input and output method that's

00:08:02,180 --> 00:08:07,310
rather fundamental we have some random

00:08:04,250 --> 00:08:10,219
Flags an error indication an obsolete

00:08:07,310 --> 00:08:13,490
state a bunch of small integer values

00:08:10,219 --> 00:08:15,380
header and trailer lends for telling

00:08:13,490 --> 00:08:18,050
various layers how much space is needed

00:08:15,380 --> 00:08:20,150
to build build packets that are backed

00:08:18,050 --> 00:08:21,860
by these kind of routes we have a

00:08:20,150 --> 00:08:24,039
traffic class ID for the packet

00:08:21,860 --> 00:08:26,930
scheduler and then we have some padding

00:08:24,039 --> 00:08:29,120
which is an important issue which we'll

00:08:26,930 --> 00:08:31,430
discuss in this in this presentation and

00:08:29,120 --> 00:08:33,349
then we have the reference count now

00:08:31,430 --> 00:08:36,200
you'll notice that the reference count

00:08:33,349 --> 00:08:38,779
sits set offset 64 and that's important

00:08:36,200 --> 00:08:41,360
and we'll get into that later we have a

00:08:38,779 --> 00:08:44,180
use count every time at the route gates

00:08:41,360 --> 00:08:46,730
referenced we bumped a use count we have

00:08:44,180 --> 00:08:48,709
a time stamp which says when was the

00:08:46,730 --> 00:08:50,630
last time this route was used that seems

00:08:48,709 --> 00:08:52,279
pretty fundamental right we have a

00:08:50,630 --> 00:08:54,949
pointer to a lightweight tunnel state

00:08:52,279 --> 00:08:55,760
and then we have this Union and it's a

00:08:54,949 --> 00:08:58,070
pointer

00:08:55,760 --> 00:08:59,839
based upon the climate type of route

00:08:58,070 --> 00:09:02,570
that this is serving as a base class of

00:08:59,839 --> 00:09:07,910
the next pointer so it's that this is

00:09:02,570 --> 00:09:09,800
where we get 160 bytes from so and we

00:09:07,910 --> 00:09:11,389
you'll see that diagram several times

00:09:09,800 --> 00:09:13,730
throughout this presentation as we make

00:09:11,389 --> 00:09:16,610
modifications to deaths entry so this

00:09:13,730 --> 00:09:18,170
entry next this is how I came down this

00:09:16,610 --> 00:09:20,149
path I looked and I said well the next

00:09:18,170 --> 00:09:22,670
pointer isn't even used by ipv4 routes

00:09:20,149 --> 00:09:24,649
that's I mean it can be removed

00:09:22,670 --> 00:09:26,949
completely so we should push it down so

00:09:24,649 --> 00:09:29,420
two subclasses that actually do use it I

00:09:26,949 --> 00:09:32,899
mentioned desk entry child it's only

00:09:29,420 --> 00:09:35,060
used by IPSec routes when IPSec builds a

00:09:32,899 --> 00:09:37,579
bundle of transformations the

00:09:35,060 --> 00:09:39,980
transformations add things like ESP

00:09:37,579 --> 00:09:41,630
headers authentication headers and so

00:09:39,980 --> 00:09:44,389
forth and then underneath that we have a

00:09:41,630 --> 00:09:47,000
chain down to the actual IP v4 route

00:09:44,389 --> 00:09:49,670
which will route the IPSec packet so the

00:09:47,000 --> 00:09:51,500
chain is only used by IPSec to hold the

00:09:49,670 --> 00:09:52,730
bundle together to keep it in one piece

00:09:51,500 --> 00:09:54,829
so you could traverse it from top to

00:09:52,730 --> 00:09:59,690
bottom so we'll give that we'll push

00:09:54,829 --> 00:10:03,769
that down into IPSec this entry from

00:09:59,690 --> 00:10:06,470
what's this used for so ipv6 routes it

00:10:03,769 --> 00:10:09,829
in the FIB tree and then when we want to

00:10:06,470 --> 00:10:11,870
create clones or copies of that route we

00:10:09,829 --> 00:10:14,240
use the front pointer to remember what

00:10:11,870 --> 00:10:16,910
fib entry we got the route from so we

00:10:14,240 --> 00:10:19,279
can update the expiration the route

00:10:16,910 --> 00:10:21,290
expiration timestamp in the in the thing

00:10:19,279 --> 00:10:23,660
it came from not in the object itself so

00:10:21,290 --> 00:10:25,069
that's important for ipv6 so let's push

00:10:23,660 --> 00:10:28,940
it down to there

00:10:25,069 --> 00:10:30,949
path is another thing used by IPSec

00:10:28,940 --> 00:10:32,480
specifically it points to the actual

00:10:30,949 --> 00:10:35,269
transport route that's going to push the

00:10:32,480 --> 00:10:38,630
IPSec encapsulated bits to the next hop

00:10:35,269 --> 00:10:40,790
so we can give that to IPSec so there

00:10:38,630 --> 00:10:42,949
are several members of death sentry that

00:10:40,790 --> 00:10:47,440
are absolutely not used by more than one

00:10:42,949 --> 00:10:49,639
route site as we are finding now now

00:10:47,440 --> 00:10:50,930
pushing all these elements down are well

00:10:49,639 --> 00:10:52,730
and good but what is that actually going

00:10:50,930 --> 00:10:55,190
to do to the size of the struct test

00:10:52,730 --> 00:10:57,019
entry well unfortunately it's not going

00:10:55,190 --> 00:10:59,240
to shrink it very much and here's why I

00:10:57,019 --> 00:11:01,310
showed you that padding and why is that

00:10:59,240 --> 00:11:03,769
padding there the reason is we tried to

00:11:01,310 --> 00:11:07,339
align this the ref count on a 64 byte

00:11:03,769 --> 00:11:09,529
boundary why is that because compared to

00:11:07,339 --> 00:11:12,199
other elements of the dest entry

00:11:09,529 --> 00:11:14,810
the reference count is very right heavy

00:11:12,199 --> 00:11:16,339
and means that the cache line that the

00:11:14,810 --> 00:11:18,889
ref count sits on will be dirty all the

00:11:16,339 --> 00:11:21,230
time if you mix this with a whole bunch

00:11:18,889 --> 00:11:23,089
of read heavy objects that curate more

00:11:21,230 --> 00:11:25,189
cache thrashing between CPUs on the

00:11:23,089 --> 00:11:27,949
system so we specifically align the

00:11:25,189 --> 00:11:29,809
reference count on a 64 byte cache line

00:11:27,949 --> 00:11:31,809
then follow it by some other elements

00:11:29,809 --> 00:11:36,589
that are typically written and not read

00:11:31,809 --> 00:11:38,209
so we we use this alignment member here

00:11:36,589 --> 00:11:40,819
called pad to align the ref count to

00:11:38,209 --> 00:11:43,459
make sure that this disk condition is

00:11:40,819 --> 00:11:45,079
always met so once we move all these

00:11:43,459 --> 00:11:48,230
things down into the sub classes this

00:11:45,079 --> 00:11:52,519
this array increases from 2 to 5 which

00:11:48,230 --> 00:11:53,990
is 40 bytes worth of completely wasted

00:11:52,519 --> 00:11:55,220
space in the data structure just for

00:11:53,990 --> 00:12:00,290
padding and that's absolutely

00:11:55,220 --> 00:12:03,019
unacceptable right so after we uncommon

00:12:00,290 --> 00:12:04,910
everything the best entry is at a

00:12:03,019 --> 00:12:07,370
hundred fifty two bytes and a problem as

00:12:04,910 --> 00:12:09,379
I stated is this ugly red thing right

00:12:07,370 --> 00:12:12,470
here which is the the ref count padding

00:12:09,379 --> 00:12:14,059
which is 40 bytes so what can we do

00:12:12,470 --> 00:12:15,019
about this and then and it but if you

00:12:14,059 --> 00:12:16,819
look at the rest of the structure it

00:12:15,019 --> 00:12:19,069
looks nice and more condensed and more

00:12:16,819 --> 00:12:21,800
concise and more really about what is

00:12:19,069 --> 00:12:23,029
common about all routes in a Linux

00:12:21,800 --> 00:12:30,019
kernel and I think that's a really nice

00:12:23,029 --> 00:12:31,970
thing to see so as I explained this is

00:12:30,019 --> 00:12:33,709
this this is this padding is completely

00:12:31,970 --> 00:12:36,230
useless and the reason it's there is to

00:12:33,709 --> 00:12:40,790
align the reference count but we have to

00:12:36,230 --> 00:12:42,740
make sure that we meet the required sub

00:12:40,790 --> 00:12:44,899
the reference count alignment well well

00:12:42,740 --> 00:12:46,850
not at the same time getting rid of the

00:12:44,899 --> 00:12:48,939
padding and how can we do that so we

00:12:46,850 --> 00:12:51,970
just rearrange things a little bit and

00:12:48,939 --> 00:12:55,309
as you see here we put the ref count at

00:12:51,970 --> 00:12:57,829
exactly 64 bytes offset we move some

00:12:55,309 --> 00:13:01,069
things that were below the ref count and

00:12:57,829 --> 00:13:04,819
his friends up into here such as these

00:13:01,069 --> 00:13:06,350
lens and now what we have is a much

00:13:04,819 --> 00:13:09,050
smaller data structure at a hundred and

00:13:06,350 --> 00:13:10,699
twelve bytes so I think that's pretty

00:13:09,050 --> 00:13:17,389
pretty for a couple days of work right

00:13:10,699 --> 00:13:19,399
isn't that nice yeah okay so what are we

00:13:17,389 --> 00:13:22,360
left with so we killed 48 bytes from

00:13:19,399 --> 00:13:22,360
struct test entry

00:13:23,600 --> 00:13:32,190
we killed 48 bytes from struck our table

00:13:26,850 --> 00:13:33,290
whoo and ipv6 routing 64 bytes of

00:13:32,190 --> 00:13:38,160
shrinkage whoo

00:13:33,290 --> 00:13:40,740
so what why did I pv6 gain a larger

00:13:38,160 --> 00:13:42,630
amount of freed space than the other

00:13:40,740 --> 00:13:45,960
ones does anyone have any any clue why

00:13:42,630 --> 00:13:49,350
this might be okay the reason is that

00:13:45,960 --> 00:13:52,470
one of the members of the ipv6 specific

00:13:49,350 --> 00:13:54,600
info in here is an ipv6 address with the

00:13:52,470 --> 00:13:57,270
cache line aligned directive given to it

00:13:54,600 --> 00:13:59,130
so we bumped ourselves until yet another

00:13:57,270 --> 00:14:01,920
cache line and therefore we were able to

00:13:59,130 --> 00:14:04,290
save a full 64 bytes for that reason so

00:14:01,920 --> 00:14:06,180
that's behind that the IPSec route

00:14:04,290 --> 00:14:07,920
stayed about the same and shrunk

00:14:06,180 --> 00:14:09,480
slightly and it's at four hundred forty

00:14:07,920 --> 00:14:12,660
eight bytes now so that's it gained a

00:14:09,480 --> 00:14:14,280
little bit as well although if you look

00:14:12,660 --> 00:14:16,740
at the patch set that I posted on net

00:14:14,280 --> 00:14:19,200
dev the the majority of the changes were

00:14:16,740 --> 00:14:20,970
for IPSec because a lot of the push

00:14:19,200 --> 00:14:23,730
downs happens to the IPSec route so I

00:14:20,970 --> 00:14:25,920
was very concerned that I broke IPSec

00:14:23,730 --> 00:14:27,900
but the IPSec maintainer stuff in class

00:14:25,920 --> 00:14:30,180
o2 assured me that he ran his tests and

00:14:27,900 --> 00:14:37,530
as far as you can see everything still

00:14:30,180 --> 00:14:40,680
passes so let's ship it right now if you

00:14:37,530 --> 00:14:44,430
look at this I computer all these

00:14:40,680 --> 00:14:45,870
offsets by hand but real men compute

00:14:44,430 --> 00:14:48,720
structure offers sets by hand but for

00:14:45,870 --> 00:14:51,930
the rest of you there is this tool

00:14:48,720 --> 00:14:54,240
called PA Hall PA hole is one of many

00:14:51,930 --> 00:14:54,990
incredible tools written by Arnaldo

00:14:54,240 --> 00:14:59,340
called

00:14:54,990 --> 00:15:01,290
de Mello who wanted to work on all kinds

00:14:59,340 --> 00:15:02,550
of tools to help developers analyze the

00:15:01,290 --> 00:15:05,100
kernel data structures and make

00:15:02,550 --> 00:15:07,350
improvements to them it's part of the

00:15:05,100 --> 00:15:09,420
drawer set of utilities so on whatever

00:15:07,350 --> 00:15:11,040
distribution you're on it package is

00:15:09,420 --> 00:15:12,270
called Dwarves order or something so

00:15:11,040 --> 00:15:15,000
that you can just install this very

00:15:12,270 --> 00:15:16,680
easily on your machine and PA hole can

00:15:15,000 --> 00:15:18,510
shoot compute structure layouts using

00:15:16,680 --> 00:15:20,760
debugging info contained in the object

00:15:18,510 --> 00:15:22,950
file you can do all kinds of clever

00:15:20,760 --> 00:15:25,560
things with it like say please only show

00:15:22,950 --> 00:15:28,980
me data structures that have this prefix

00:15:25,560 --> 00:15:31,110
string to them use like it also can tell

00:15:28,980 --> 00:15:32,640
you on what cache line each each member

00:15:31,110 --> 00:15:34,020
of the data structure sits on and how

00:15:32,640 --> 00:15:35,699
much more you would have to do to move

00:15:34,020 --> 00:15:37,199
it to the next cache line and

00:15:35,699 --> 00:15:38,819
the cache line is configurable you can

00:15:37,199 --> 00:15:41,129
tell it how big of a cache line to use

00:15:38,819 --> 00:15:42,329
so regardless of what the CPU

00:15:41,129 --> 00:15:44,429
characteristics are that you're

00:15:42,329 --> 00:15:47,249
targeting you can make P whole show you

00:15:44,429 --> 00:15:47,910
information based upon that so how would

00:15:47,249 --> 00:15:50,040
you use it

00:15:47,910 --> 00:15:52,410
install the drawers package get it on

00:15:50,040 --> 00:15:55,350
your system then you build a colonel

00:15:52,410 --> 00:15:57,029
with config debug info now here's his

00:15:55,350 --> 00:15:59,009
awesome part you don't have to build the

00:15:57,029 --> 00:16:00,269
whole kernel just look at a specific

00:15:59,009 --> 00:16:03,209
data structure if you're just trying to

00:16:00,269 --> 00:16:05,309
look at something really quickly just

00:16:03,209 --> 00:16:07,169
build an object that references those

00:16:05,309 --> 00:16:10,079
data structures somehow so I picked net

00:16:07,169 --> 00:16:12,419
core Edisto here and then you can use

00:16:10,079 --> 00:16:17,040
that in PA hold to display to lay out a

00:16:12,419 --> 00:16:19,589
data structure so this C 64 that sets

00:16:17,040 --> 00:16:21,449
the cache line size and I'm choosing 64

00:16:19,589 --> 00:16:23,699
because that's the cache line size that

00:16:21,449 --> 00:16:26,160
we're targeting in the networking in

00:16:23,699 --> 00:16:29,209
debug on compile time check I showed you

00:16:26,160 --> 00:16:31,410
earlier for aligning the reference count

00:16:29,209 --> 00:16:33,989
here's the data structure I want to see

00:16:31,410 --> 00:16:37,339
dest entry I want the off sex in hex

00:16:33,989 --> 00:16:39,839
because real men use hexadecimal and

00:16:37,339 --> 00:16:41,369
this object file that we built here and

00:16:39,839 --> 00:16:44,220
it will show you something that looks

00:16:41,369 --> 00:16:45,779
almost identical to my previous slide so

00:16:44,220 --> 00:16:47,850
that's how you can use it and work on

00:16:45,779 --> 00:16:51,779
data structures in the kernel to shrink

00:16:47,850 --> 00:16:53,789
them and improve their layout let's talk

00:16:51,779 --> 00:16:57,239
a little bit about something called

00:16:53,789 --> 00:17:00,029
state compression it has very common to

00:16:57,239 --> 00:17:04,709
have a lot of objects pieces of boolean

00:17:00,029 --> 00:17:07,829
state in a data structure but bull is

00:17:04,709 --> 00:17:10,199
too expensive it uses more space than it

00:17:07,829 --> 00:17:11,850
actually needs to although it's very

00:17:10,199 --> 00:17:13,319
expressive it's nice to see true false

00:17:11,850 --> 00:17:15,179
values all over the kernel and proper

00:17:13,319 --> 00:17:17,579
bold types but for the most critical

00:17:15,179 --> 00:17:19,230
structures in the kernel I think we can

00:17:17,579 --> 00:17:22,350
sacrifice a little bit of cleanliness

00:17:19,230 --> 00:17:25,049
for the sake of top performance because

00:17:22,350 --> 00:17:28,049
that's what we're famous for sometimes

00:17:25,049 --> 00:17:31,200
even a 8-bit unsigned integer is too big

00:17:28,049 --> 00:17:32,669
so the suggestion is to use either C bit

00:17:31,200 --> 00:17:36,500
fields which is what we do in a lot of

00:17:32,669 --> 00:17:39,779
structures such as SK buff and others or

00:17:36,500 --> 00:17:41,370
group them into an integer flags and

00:17:39,779 --> 00:17:42,840
make the flags only as big as you need

00:17:41,370 --> 00:17:45,389
to to fit all the bits so if you only

00:17:42,840 --> 00:17:49,650
need seven bits use a UA if you need 15

00:17:45,389 --> 00:17:51,480
bits use au 16 and so on and so forth I

00:17:49,650 --> 00:17:54,120
non boolean values you should actually

00:17:51,480 --> 00:17:57,030
try to understand the actual range of

00:17:54,120 --> 00:17:58,680
values that that member actually holds

00:17:57,030 --> 00:18:01,110
and used the smallest type appropriate

00:17:58,680 --> 00:18:02,130
for that range of values I guess it

00:18:01,110 --> 00:18:05,750
would be nice if we could have some

00:18:02,130 --> 00:18:08,190
compiler support or some kind of

00:18:05,750 --> 00:18:09,870
automated way to determine these kinds

00:18:08,190 --> 00:18:11,850
of things but usually if you study most

00:18:09,870 --> 00:18:13,770
of the code you can see that all this

00:18:11,850 --> 00:18:16,410
only has a header length and we know

00:18:13,770 --> 00:18:17,940
that put in protocols we only have

00:18:16,410 --> 00:18:19,920
headers up to this size therefore the

00:18:17,940 --> 00:18:22,680
range is X and you can use that value

00:18:19,920 --> 00:18:25,070
acciden what an appropriate type would

00:18:22,680 --> 00:18:27,660
be for the for the integer in question

00:18:25,070 --> 00:18:30,660
so that's one way to do some state

00:18:27,660 --> 00:18:32,340
compression another interesting

00:18:30,660 --> 00:18:36,810
technique which I really like a lot is

00:18:32,340 --> 00:18:38,340
called unused pointer bits so basically

00:18:36,810 --> 00:18:40,020
the idea is that you have a pointer and

00:18:38,340 --> 00:18:42,210
then you have some small amount of

00:18:40,020 --> 00:18:46,590
states that can be represented and just

00:18:42,210 --> 00:18:48,780
a couple bits so all pointers to objects

00:18:46,590 --> 00:18:51,170
in the dynamically allocated objects in

00:18:48,780 --> 00:18:53,700
the kernel at a minimum or at least

00:18:51,170 --> 00:18:55,560
pointer aligned or better which means

00:18:53,700 --> 00:18:58,680
you can assume basically four or even

00:18:55,560 --> 00:19:00,870
eight byte alignment and those unused

00:18:58,680 --> 00:19:02,670
bits at the bottom of the pointer value

00:19:00,870 --> 00:19:05,460
can be used for other pieces of State

00:19:02,670 --> 00:19:08,070
for example boolean or small integers

00:19:05,460 --> 00:19:11,430
and because you could use small integers

00:19:08,070 --> 00:19:13,380
you could do a type encoding scheme so

00:19:11,430 --> 00:19:15,780
for example the pointer can point to

00:19:13,380 --> 00:19:17,760
several types of objects and that small

00:19:15,780 --> 00:19:19,260
integer value at the bottom will tell

00:19:17,760 --> 00:19:21,840
you what kind of object sits behind a

00:19:19,260 --> 00:19:24,420
pointer this is kind of nice because you

00:19:21,840 --> 00:19:26,940
you have to have create a set of helpers

00:19:24,420 --> 00:19:28,710
to dereference a pointer and therefore

00:19:26,940 --> 00:19:31,140
since you have to go through a helper

00:19:28,710 --> 00:19:32,730
you you you have control over how people

00:19:31,140 --> 00:19:35,130
gain access to the object and therefore

00:19:32,730 --> 00:19:38,460
you can do some form of nice type safety

00:19:35,130 --> 00:19:40,170
that way and actually it the most

00:19:38,460 --> 00:19:43,170
critical element in using this technique

00:19:40,170 --> 00:19:46,110
is designing the helpers in a way that

00:19:43,170 --> 00:19:47,820
works reliably and is an error prone

00:19:46,110 --> 00:19:50,670
that's an important part about using

00:19:47,820 --> 00:19:52,140
this technique so basically that people

00:19:50,670 --> 00:19:53,730
call the helper function they get the

00:19:52,140 --> 00:19:56,520
pointer and maybe some piece of metadata

00:19:53,730 --> 00:19:58,860
like the type behind it for example so

00:19:56,520 --> 00:20:01,800
that's a that's a one way to save some

00:19:58,860 --> 00:20:03,330
space and data structures here's an

00:20:01,800 --> 00:20:05,340
example

00:20:03,330 --> 00:20:07,170
showed you the metrics value and it was

00:20:05,340 --> 00:20:09,150
an unsigned long but it's a pointer to

00:20:07,170 --> 00:20:13,920
something right it's a pointer to an

00:20:09,150 --> 00:20:15,930
array of metrics stored for the route so

00:20:13,920 --> 00:20:17,820
we encoded as an unsigned long and for

00:20:15,930 --> 00:20:21,210
the unused pointer bits at the bottom we

00:20:17,820 --> 00:20:24,150
store to beat two flags and one flag is

00:20:21,210 --> 00:20:27,960
read only and one flag is rep counted so

00:20:24,150 --> 00:20:29,610
we try to share memory for best route

00:20:27,960 --> 00:20:34,070
metrics as much as possible and how do

00:20:29,610 --> 00:20:36,450
we do that if we assign a Const or a

00:20:34,070 --> 00:20:38,190
shared piece of memory for the for the

00:20:36,450 --> 00:20:39,990
route metrics we set the read-only bit

00:20:38,190 --> 00:20:42,600
and this tells the death Slayer that

00:20:39,990 --> 00:20:44,280
when we release the route we don't have

00:20:42,600 --> 00:20:46,050
to do anything with the backing memory

00:20:44,280 --> 00:20:48,990
we just forget about it right and we

00:20:46,050 --> 00:20:51,030
just know out the metrics value if it

00:20:48,990 --> 00:20:52,950
has the ref counted bit and Erik duma's

00:20:51,030 --> 00:20:55,350
they added this code we have a

00:20:52,950 --> 00:20:57,360
dynamically allocated piece of metric

00:20:55,350 --> 00:20:58,980
State and we need to decrement a ref

00:20:57,360 --> 00:21:01,070
count associated with it and then free

00:20:58,980 --> 00:21:04,020
to memory if necessary so it's all about

00:21:01,070 --> 00:21:08,310
object management so this is really cool

00:21:04,020 --> 00:21:10,290
it allow us to mix non non dynamically

00:21:08,310 --> 00:21:11,610
allocated metrics with dynamically

00:21:10,290 --> 00:21:13,250
allocated ones and that's a really neat

00:21:11,610 --> 00:21:15,270
trick

00:21:13,250 --> 00:21:17,520
earlier I spoke about the unionization

00:21:15,270 --> 00:21:21,560
of state specific state so we have a

00:21:17,520 --> 00:21:21,560
structured member that's only used in to

00:21:22,430 --> 00:21:27,510
formally disjoint points in time this

00:21:25,380 --> 00:21:29,220
means that we can use the same memory

00:21:27,510 --> 00:21:30,660
space for the two different objects and

00:21:29,220 --> 00:21:32,820
therefore we define a union for those

00:21:30,660 --> 00:21:35,670
two values here's an example an

00:21:32,820 --> 00:21:38,340
instructor sock right now we have s case

00:21:35,670 --> 00:21:39,960
n head which is used for various

00:21:38,340 --> 00:21:43,290
protocols to maintain their send queue

00:21:39,960 --> 00:21:45,690
but for TCP we now use a RB tree

00:21:43,290 --> 00:21:49,320
we don't use this s case n head value so

00:21:45,690 --> 00:21:53,100
we can for TCP sockets we used the TCP

00:21:49,320 --> 00:21:54,480
r-tx q or B root pointer and therefore

00:21:53,100 --> 00:21:56,700
these two objects can share state

00:21:54,480 --> 00:21:58,520
because TCP will never use s case n head

00:21:56,700 --> 00:22:01,680
we know for a fact and vice versa

00:21:58,520 --> 00:22:05,130
protocols that use s case n head will

00:22:01,680 --> 00:22:05,820
not use TCP r-tx Q so that's one another

00:22:05,130 --> 00:22:08,510
thing you can do

00:22:05,820 --> 00:22:11,430
lookup keys instead of pointers

00:22:08,510 --> 00:22:12,750
basically they index to some object in

00:22:11,430 --> 00:22:15,270
the kernel that's looked up in a hash

00:22:12,750 --> 00:22:17,159
table or some other data structure you

00:22:15,270 --> 00:22:18,210
can store that inside the data structure

00:22:17,159 --> 00:22:22,859
instead of the pointer to the object

00:22:18,210 --> 00:22:25,649
itself now one major thing that needs to

00:22:22,859 --> 00:22:27,769
be taken into consideration if you want

00:22:25,649 --> 00:22:30,599
to use this technique is how how

00:22:27,769 --> 00:22:33,080
inexpensive is it to do this lookup if

00:22:30,599 --> 00:22:35,340
it's an RC you look up into a hash table

00:22:33,080 --> 00:22:37,889
you can probably do this and this is

00:22:35,340 --> 00:22:41,460
typically where we apply this technique

00:22:37,889 --> 00:22:43,979
so one example is that the the packet

00:22:41,460 --> 00:22:45,690
metadata structure returns stores the

00:22:43,979 --> 00:22:48,899
incoming device that the packet arrived

00:22:45,690 --> 00:22:51,509
on in a member called skb underscore iif

00:22:48,899 --> 00:22:53,489
and we used to store the actual pointer

00:22:51,509 --> 00:22:55,649
to the net device there but instead we

00:22:53,489 --> 00:22:58,259
just store the if index and we just look

00:22:55,649 --> 00:23:00,659
it up as needed another thing to take

00:22:58,259 --> 00:23:03,029
into consideration is not only you can

00:23:00,659 --> 00:23:04,649
do this when the lookup is cheap but

00:23:03,029 --> 00:23:06,570
when the lookup is done very

00:23:04,649 --> 00:23:08,279
infrequently so even if it's slightly

00:23:06,570 --> 00:23:10,229
expensive if we do to look up and

00:23:08,279 --> 00:23:12,330
frequently we may be able to apply this

00:23:10,229 --> 00:23:16,830
technique reasonably as well so that's

00:23:12,330 --> 00:23:20,220
one thing to look into so I'd like to

00:23:16,830 --> 00:23:22,259
thank my pond director Joe for helping

00:23:20,220 --> 00:23:24,299
organize this technique let's give a

00:23:22,259 --> 00:23:25,080
round of applause we really appreciate

00:23:24,299 --> 00:23:29,759
all their help

00:23:25,080 --> 00:23:31,229
I like their length Willam and Eric in

00:23:29,759 --> 00:23:32,759
particular because they've worked on

00:23:31,229 --> 00:23:34,320
things in this area and they realized

00:23:32,759 --> 00:23:36,149
the value of data is shrinking so I like

00:23:34,320 --> 00:23:37,349
to point them out in particular so let's

00:23:36,149 --> 00:23:41,009
give Eric and William my round of

00:23:37,349 --> 00:23:42,419
applause and I like to thank not only

00:23:41,009 --> 00:23:44,460
people who have shrunk the data

00:23:42,419 --> 00:23:46,919
structures in a litter next network but

00:23:44,460 --> 00:23:49,889
those who will in the future do so I am

00:23:46,919 --> 00:23:51,269
thanking you right now um so one thing

00:23:49,889 --> 00:23:52,769
you need to understand as I was going

00:23:51,269 --> 00:23:55,169
through this presentation and working on

00:23:52,769 --> 00:23:57,809
the desk entry that last beautiful

00:23:55,169 --> 00:23:59,489
picture of the desk entry I still see

00:23:57,809 --> 00:24:02,340
some improvements that can be done but I

00:23:59,489 --> 00:24:03,749
had to stop myself I had to not walk

00:24:02,340 --> 00:24:05,970
over that line and keep doing it

00:24:03,749 --> 00:24:07,649
otherwise you guys would be like Dave's

00:24:05,970 --> 00:24:10,830
just gonna work on it I don't need to do

00:24:07,649 --> 00:24:12,479
anything so please look into this

00:24:10,830 --> 00:24:14,489
especially on the larger data structures

00:24:12,479 --> 00:24:16,710
like struck sock and the network device

00:24:14,489 --> 00:24:18,359
I'm sure there's an enormous amount of

00:24:16,710 --> 00:24:20,279
low-hanging fruit that can be taken care

00:24:18,359 --> 00:24:22,049
of and some fun projects for people to

00:24:20,279 --> 00:24:23,789
work on to make our data structures

00:24:22,049 --> 00:24:26,279
smaller and finally I like to thank

00:24:23,789 --> 00:24:27,839
Linda's Torvalds who gave us this fun

00:24:26,279 --> 00:24:29,399
toy to work on for these past couple

00:24:27,839 --> 00:24:30,429
decades without him we wouldn't be

00:24:29,399 --> 00:24:34,080
sitting in this room right

00:24:30,429 --> 00:24:34,080
now so thank you Linda's very much a

00:24:34,860 --> 00:24:50,559
[Applause]

00:24:36,179 --> 00:24:51,999
question microphone for Dave a her it

00:24:50,559 --> 00:25:03,369
won't get it I want you be on the record

00:24:51,999 --> 00:25:05,860
dude so one thing to remember about the

00:25:03,369 --> 00:25:07,659
data structure shrinking is the real

00:25:05,860 --> 00:25:10,269
memory allocation is actually rounded up

00:25:07,659 --> 00:25:12,879
to the next power or two so getting it

00:25:10,269 --> 00:25:14,830
down below those is really even a bigger

00:25:12,879 --> 00:25:17,200
win I think we even did that for dust

00:25:14,830 --> 00:25:18,639
dust entry right we got under 120 yes so

00:25:17,200 --> 00:25:22,110
what I mean like the net device is

00:25:18,639 --> 00:25:24,610
actually a 4k allocation because it's a

00:25:22,110 --> 00:25:26,590
1900 byte even though it's just around

00:25:24,610 --> 00:25:28,179
today or so right yeah so that's

00:25:26,590 --> 00:25:29,740
something to taking consideration one

00:25:28,179 --> 00:25:32,610
goal to strive for is to get it under

00:25:29,740 --> 00:25:32,610
the next power of tool

00:25:38,000 --> 00:25:45,150
any other questions all right thank you

00:25:43,800 --> 00:25:47,420
very much for spending the time to

00:25:45,150 --> 00:25:49,070
listen to my presentation

00:25:47,420 --> 00:25:52,200
[Applause]

00:25:49,070 --> 00:25:52,200

YouTube URL: https://www.youtube.com/watch?v=GgTwx1399Dc


