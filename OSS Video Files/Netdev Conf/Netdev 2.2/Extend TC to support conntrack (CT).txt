Title: Extend TC to support conntrack (CT)
Publication date: 2018-03-14
Playlist: Netdev 2.2
Description: 
	Speaker: Rony Efraim, Guy Shattah
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?efraim-extendtctoct-talk
Captions: 
	00:00:01,490 --> 00:00:15,200
no give you give you a minute

00:00:03,929 --> 00:00:18,539
cool okay so after Pablo present

00:00:15,200 --> 00:00:20,519
connection tracking and how to do it how

00:00:18,539 --> 00:00:23,310
and how to offer hardware offload it I

00:00:20,519 --> 00:00:26,099
think we also want to I also want to

00:00:23,310 --> 00:00:28,820
talk about connection tracking I want to

00:00:26,099 --> 00:00:31,830
talk what it to speak what a little bit

00:00:28,820 --> 00:00:35,430
what is connection tracking what is done

00:00:31,830 --> 00:00:38,160
today with obvious what is currently

00:00:35,430 --> 00:00:42,300
implemented through TC that's required

00:00:38,160 --> 00:00:47,309
and what the motivation and a suggestion

00:00:42,300 --> 00:00:56,340
how to use TC to contract a to control

00:00:47,309 --> 00:00:59,250
CT okay so I will start talking about

00:00:56,340 --> 00:01:00,780
what is connection tracking and an

00:00:59,250 --> 00:01:04,199
electric tracking there are two things

00:01:00,780 --> 00:01:06,390
that is done so first is the database

00:01:04,199 --> 00:01:09,299
that's for every new connection we have

00:01:06,390 --> 00:01:11,460
a state that is a new connection and we

00:01:09,299 --> 00:01:13,740
put it inside the database that is done

00:01:11,460 --> 00:01:17,360
for every it's usually done for the same

00:01:13,740 --> 00:01:21,960
packet that's creating a connection and

00:01:17,360 --> 00:01:23,939
that's what Pablo say had the NGO to to

00:01:21,960 --> 00:01:25,650
get into the hardware the second thing

00:01:23,939 --> 00:01:28,110
that connection this connection tracking

00:01:25,650 --> 00:01:30,960
is doing so for every packet is doing

00:01:28,110 --> 00:01:33,990
the validation of the packet for TCP the

00:01:30,960 --> 00:01:36,299
validation is not just a pair packet

00:01:33,990 --> 00:01:39,240
validation it's validate that the stream

00:01:36,299 --> 00:01:43,500
is valid and it's mean that's for every

00:01:39,240 --> 00:01:45,840
packet he checked that's the the packet

00:01:43,500 --> 00:01:48,180
is there in the T States it's valid

00:01:45,840 --> 00:01:51,600
meaning the TCP window in order to do

00:01:48,180 --> 00:01:53,909
that we need to track on all the packets

00:01:51,600 --> 00:01:56,250
that belong from both side it's a

00:01:53,909 --> 00:01:58,500
connection from box ID that's related to

00:01:56,250 --> 00:02:02,549
this connection so this is something

00:01:58,500 --> 00:02:04,170
that's as probably looking his in the

00:02:02,549 --> 00:02:07,229
other that he is using it's currently

00:02:04,170 --> 00:02:09,530
not implemented in hardware and this is

00:02:07,229 --> 00:02:12,750
something that we want to take into the

00:02:09,530 --> 00:02:14,460
coming hardware so that's the reason we

00:02:12,750 --> 00:02:19,260
want to to build the infrastructure

00:02:14,460 --> 00:02:21,480
to do that so that's the two things that

00:02:19,260 --> 00:02:23,490
connection tracking the kernel model of

00:02:21,480 --> 00:02:29,340
connection tracking that's contract is

00:02:23,490 --> 00:02:30,810
doing today what actually is the the

00:02:29,340 --> 00:02:32,850
pocket is going out from the connection

00:02:30,810 --> 00:02:35,790
tracking with a state the state can be a

00:02:32,850 --> 00:02:38,730
new for new connections establish

00:02:35,790 --> 00:02:40,830
forever a valid connection related

00:02:38,730 --> 00:02:42,570
because it's related to another

00:02:40,830 --> 00:02:45,600
connection that's like an FTP connection

00:02:42,570 --> 00:02:47,190
or those kind of and in valid invalid

00:02:45,600 --> 00:02:50,510
that's mean that's the packet is not

00:02:47,190 --> 00:02:53,430
part of a connections probably because

00:02:50,510 --> 00:02:56,790
it's Val it's not it couldn't validate

00:02:53,430 --> 00:02:58,950
the packet inside the TCP window it's at

00:02:56,790 --> 00:03:03,150
the end probably the packet will be

00:02:58,950 --> 00:03:05,670
dropped so this is the idea of

00:03:03,150 --> 00:03:10,620
connection tracking that's implemented

00:03:05,670 --> 00:03:15,110
today in the contract it's and it's

00:03:10,620 --> 00:03:17,520
currently being used by IP table and

00:03:15,110 --> 00:03:22,170
another customer that's using the same

00:03:17,520 --> 00:03:24,930
code is the obvious so obvious is using

00:03:22,170 --> 00:03:28,470
it in using the same code of contract so

00:03:24,930 --> 00:03:33,090
nobody thought about duplicating the

00:03:28,470 --> 00:03:37,020
code of course and there is two things

00:03:33,090 --> 00:03:41,160
that say obvious is doing there is to

00:03:37,020 --> 00:03:43,170
two rules that's one of them is an

00:03:41,160 --> 00:03:45,420
action go to the connection tracking so

00:03:43,170 --> 00:03:47,610
you can stay set a rule from open V

00:03:45,420 --> 00:03:49,380
switch go to connection tracking so it's

00:03:47,610 --> 00:03:52,200
means that this packet will be tracked

00:03:49,380 --> 00:03:53,760
by the connection tracking and after

00:03:52,200 --> 00:03:57,450
this pocket is coming back from the

00:03:53,760 --> 00:03:59,850
connection tracking we can add rules to

00:03:57,450 --> 00:04:01,890
classify according to the state that we

00:03:59,850 --> 00:04:06,390
got from the connection tracking if it's

00:04:01,890 --> 00:04:09,540
a new established related or invalid so

00:04:06,390 --> 00:04:12,260
this is how today con a obvious is using

00:04:09,540 --> 00:04:12,260
connection tracking

00:04:15,280 --> 00:04:22,130
and those look like the rules on the

00:04:19,579 --> 00:04:26,419
data path of the connection tracking as

00:04:22,130 --> 00:04:30,169
you can see there is a rule with city

00:04:26,419 --> 00:04:32,150
state if it's non track - a track so the

00:04:30,169 --> 00:04:39,949
action will be in the second line let's

00:04:32,150 --> 00:04:42,320
the pointer as you can see here the

00:04:39,949 --> 00:04:45,229
action will be go to connection tracking

00:04:42,320 --> 00:04:46,639
and recirculate its main go to when you

00:04:45,229 --> 00:04:52,820
come back from the connection track and

00:04:46,639 --> 00:04:55,340
go to table number nine this is and when

00:04:52,820 --> 00:04:57,919
you come back to rule number nine

00:04:55,340 --> 00:05:02,479
as for table number nine if the pocket

00:04:57,919 --> 00:05:04,340
was tracked and established then the

00:05:02,479 --> 00:05:07,070
action will be okay go out on the

00:05:04,340 --> 00:05:09,020
external products is supposed to be on

00:05:07,070 --> 00:05:12,020
the other direction there also will be

00:05:09,020 --> 00:05:14,560
if it's if the port is different port if

00:05:12,020 --> 00:05:18,400
it's not trackable go to table number

00:05:14,560 --> 00:05:22,780
hey sorry yeah

00:05:18,400 --> 00:05:27,289
the last one yeah so if it's they're not

00:05:22,780 --> 00:05:31,070
trackable go to table a and in table a

00:05:27,289 --> 00:05:34,039
if it's established and track go to

00:05:31,070 --> 00:05:36,680
action and go to port number five so

00:05:34,039 --> 00:05:40,190
this is how obvious is implementing

00:05:36,680 --> 00:05:41,599
today the connection tracking it's using

00:05:40,190 --> 00:05:46,900
of course the contract in the kernel the

00:05:41,599 --> 00:05:46,900
same one that's in the IP table

00:05:48,740 --> 00:05:57,180
okay so I try to look what we currently

00:05:53,700 --> 00:06:00,570
have in PC because I want to use TC in

00:05:57,180 --> 00:06:04,230
order to do the upload to the to support

00:06:00,570 --> 00:06:07,020
to let TC support contract so currently

00:06:04,230 --> 00:06:10,560
today there is a comma a TC action

00:06:07,020 --> 00:06:12,990
called cone mark that's I thought oh

00:06:10,560 --> 00:06:15,330
well I have it so I don't do anything

00:06:12,990 --> 00:06:18,120
but what corn mark is doing is just

00:06:15,330 --> 00:06:20,130
marking a packet in order that the

00:06:18,120 --> 00:06:24,180
connection the connection tracking can

00:06:20,130 --> 00:06:29,270
use this mark so this is not something

00:06:24,180 --> 00:06:32,940
that is useful for us for what we need

00:06:29,270 --> 00:06:36,000
and I think another thing that's cheery

00:06:32,940 --> 00:06:39,870
now implemented in the TC in the support

00:06:36,000 --> 00:06:44,100
of a multi table multi chain it's

00:06:39,870 --> 00:06:46,530
resembled the recirculate ID that's open

00:06:44,100 --> 00:06:48,240
this which have so you can point from

00:06:46,530 --> 00:06:50,970
another table from one table to another

00:06:48,240 --> 00:06:53,130
table that you can do the action go to

00:06:50,970 --> 00:06:54,450
the connection tracking and then when

00:06:53,130 --> 00:07:00,240
you come from the connection tracking

00:06:54,450 --> 00:07:03,750
you need to have another table so this

00:07:00,240 --> 00:07:07,050
is the the same types of TC to support

00:07:03,750 --> 00:07:11,670
as you can see there is an action go to

00:07:07,050 --> 00:07:13,860
table go to chain sorry and also when

00:07:11,670 --> 00:07:15,600
you add the rule you can specify which

00:07:13,860 --> 00:07:18,180
they change so it's mean which table

00:07:15,600 --> 00:07:20,190
that's we will be in of course by

00:07:18,180 --> 00:07:26,790
default there the chain is 0 so it's

00:07:20,190 --> 00:07:32,120
backward compatible so this is already

00:07:26,790 --> 00:07:37,740
support today so what is the motivation

00:07:32,120 --> 00:07:40,590
so the motivation that's now of course

00:07:37,740 --> 00:07:43,410
TC now is the one that's don't support

00:07:40,590 --> 00:07:47,580
connection tracking so because obvious

00:07:43,410 --> 00:07:50,760
support it IP tools supported IP IP

00:07:47,580 --> 00:07:54,330
table supported so ytc not it should

00:07:50,760 --> 00:07:58,710
support it too so but this is you know

00:07:54,330 --> 00:08:01,860
just a nice way to ask for it but I

00:07:58,710 --> 00:08:03,990
think our next motivation will be

00:08:01,860 --> 00:08:05,699
enable open this which hardware offload

00:08:03,990 --> 00:08:09,590
because today if you want to offload of

00:08:05,699 --> 00:08:15,210
yes to hardware were using TC to do that

00:08:09,590 --> 00:08:16,710
so today obvious is not a sorry this is

00:08:15,210 --> 00:08:20,310
not supporting any connection tracking

00:08:16,710 --> 00:08:24,060
so the way that we want to to continue

00:08:20,310 --> 00:08:32,700
this effort is to let connection a to

00:08:24,060 --> 00:08:35,880
let TC support connection tracking so

00:08:32,700 --> 00:08:39,539
again my suggestion will be the same use

00:08:35,880 --> 00:08:42,990
as open this which is doing it so we

00:08:39,539 --> 00:08:46,170
will have an action in TC okay go to

00:08:42,990 --> 00:08:48,450
connection tracking and then we can

00:08:46,170 --> 00:08:49,769
classify when there when we get to the

00:08:48,450 --> 00:08:51,690
packet back from the connection tracking

00:08:49,769 --> 00:08:55,620
we can classify according to the

00:08:51,690 --> 00:08:57,779
connection tracking state so the idea

00:08:55,620 --> 00:09:00,870
again is not to use is to use the same

00:08:57,779 --> 00:09:03,480
code of the net filter and just have an

00:09:00,870 --> 00:09:05,100
action go to connection tracking and

00:09:03,480 --> 00:09:07,290
when the packet is back from the

00:09:05,100 --> 00:09:10,560
connection tracking we can classify

00:09:07,290 --> 00:09:14,220
about the state the city state so again

00:09:10,560 --> 00:09:17,720
to reuse the code connection tracking is

00:09:14,220 --> 00:09:21,410
is a lot of code it's not something that

00:09:17,720 --> 00:09:21,410
we want to duplicate

00:09:25,350 --> 00:09:35,500
so be more specific the new action we

00:09:30,670 --> 00:09:37,660
call CT or connection tracking of course

00:09:35,500 --> 00:09:41,400
if you have a better names if you prefer

00:09:37,660 --> 00:09:44,080
a longer one I don't don't think so but

00:09:41,400 --> 00:09:49,270
that will send a packet to the NFF

00:09:44,080 --> 00:09:51,820
connection tracking of course the

00:09:49,270 --> 00:09:54,910
parameters that will have it's a commit

00:09:51,820 --> 00:09:56,770
it's mean that's this action going to

00:09:54,910 --> 00:10:00,400
happen it's mean that you will take it

00:09:56,770 --> 00:10:02,380
inside to the database and zone so if

00:10:00,400 --> 00:10:04,180
you want to have multiple zones in the

00:10:02,380 --> 00:10:07,330
connection tracking so it's the command

00:10:04,180 --> 00:10:10,240
also need to support that so as I

00:10:07,330 --> 00:10:18,850
mentioned so the TC command will send a

00:10:10,240 --> 00:10:21,460
packet to connection tracking after the

00:10:18,850 --> 00:10:23,440
packet is coming back from the

00:10:21,460 --> 00:10:28,180
connection tracking of course it will be

00:10:23,440 --> 00:10:30,550
used the the chain that's the reason we

00:10:28,180 --> 00:10:32,250
can class if we have another TC on

00:10:30,550 --> 00:10:34,300
another on a different chain that's

00:10:32,250 --> 00:10:43,380
classify according to the connection

00:10:34,300 --> 00:10:48,540
information so so the connections the

00:10:43,380 --> 00:10:51,340
the connections city-state will classify

00:10:48,540 --> 00:10:51,730
so we want to classify according to the

00:10:51,340 --> 00:10:54,640
flags

00:10:51,730 --> 00:10:56,860
so the flags are going to be track

00:10:54,640 --> 00:10:58,480
invalidate so the idea it's like I took

00:10:56,860 --> 00:11:00,190
this idea of course from open base which

00:10:58,480 --> 00:11:05,140
when you do something good it's better

00:11:00,190 --> 00:11:11,320
to copy so we can use a plus if you want

00:11:05,140 --> 00:11:14,800
this flag to be set - if it must be

00:11:11,320 --> 00:11:17,770
clear or if you're not coming in so we

00:11:14,800 --> 00:11:20,320
ignore this F we can ignore this flag so

00:11:17,770 --> 00:11:24,040
the flags the flags can be if the packet

00:11:20,320 --> 00:11:27,850
tracked if it's had been a it was being

00:11:24,040 --> 00:11:29,290
a true connection tracker invalid if the

00:11:27,850 --> 00:11:31,630
connection tracking is things that the

00:11:29,290 --> 00:11:34,060
part is invalid as I mentioned this is

00:11:31,630 --> 00:11:36,920
probably because a TCP window or other

00:11:34,060 --> 00:11:40,639
things he knew if it's new

00:11:36,920 --> 00:11:43,790
connection established if it's an

00:11:40,639 --> 00:11:47,660
established connection and the reply

00:11:43,790 --> 00:11:50,389
will be will be set if the if it's a

00:11:47,660 --> 00:11:53,420
reply and relate it of course if it's

00:11:50,389 --> 00:11:55,670
something that's related to another the

00:11:53,420 --> 00:11:59,920
route that you already billed it I'd say

00:11:55,670 --> 00:11:59,920
MP or FTP connection that is related to

00:12:00,130 --> 00:12:08,620
so again this is exactly the same as

00:12:04,610 --> 00:12:08,620
what open V switch is doing doing today

00:12:13,000 --> 00:12:21,529
so just an example how the TC command

00:12:17,839 --> 00:12:24,680
would look like will use action to go to

00:12:21,529 --> 00:12:27,529
connection tracking and of course go to

00:12:24,680 --> 00:12:29,389
chain number one so so it's

00:12:27,529 --> 00:12:37,430
approximately the same as we look at the

00:12:29,389 --> 00:12:44,170
rules of an open V switch any question

00:12:37,430 --> 00:12:46,800
regarded right

00:12:44,170 --> 00:12:46,800
might

00:12:48,190 --> 00:12:56,260
nope the mics there at work unit just to

00:12:54,660 --> 00:12:59,400
bring it

00:12:56,260 --> 00:12:59,400
miss Evelyn Evelyn

00:13:08,250 --> 00:13:13,949
they've already been planning to do this

00:13:10,110 --> 00:13:17,040
but I'd also suggest being able to set

00:13:13,949 --> 00:13:19,920
and match on the mark and the label okay

00:13:17,040 --> 00:13:22,500
and then also something that we've used

00:13:19,920 --> 00:13:24,620
in OBS is being able to specify the

00:13:22,500 --> 00:13:28,740
helper so if you're using like FTP or

00:13:24,620 --> 00:13:30,509
TFTP for when you tell it to go to the

00:13:28,740 --> 00:13:32,160
contractor so it knows which helper

00:13:30,509 --> 00:13:38,399
function if so that you can get the

00:13:32,160 --> 00:13:41,040
related flags mm-hmm related so the the

00:13:38,399 --> 00:13:42,899
connection tracking state also has mark

00:13:41,040 --> 00:13:44,430
and label associated with it and then

00:13:42,899 --> 00:13:47,370
being able to set those and then match

00:13:44,430 --> 00:13:48,959
them later on is helpful OVS does that

00:13:47,370 --> 00:13:50,459
and if you're trying to do that for

00:13:48,959 --> 00:13:56,480
hardware off-loaded probably helpful to

00:13:50,459 --> 00:13:58,649
have that as well okay

00:13:56,480 --> 00:14:01,910
why couldn't you use : mark again

00:13:58,649 --> 00:14:05,879
because it's it has access to the

00:14:01,910 --> 00:14:08,310
contract state right right it so you

00:14:05,879 --> 00:14:11,670
could it just doesn't look at the state

00:14:08,310 --> 00:14:16,529
it looks at the mark instead so you

00:14:11,670 --> 00:14:19,740
could easily extend it to to state the

00:14:16,529 --> 00:14:23,880
checking or or mark or validation to use

00:14:19,740 --> 00:14:27,050
the same syntax call mark thinkit's was

00:14:23,880 --> 00:14:27,050
it will be misleading

00:14:27,620 --> 00:14:35,459
the name was again something connection

00:14:30,930 --> 00:14:38,250
checking okay oh sure we use it sorry a

00:14:35,459 --> 00:14:43,110
statement yes okay but as I said the

00:14:38,250 --> 00:14:47,089
name write it but it has the code would

00:14:43,110 --> 00:14:47,089
be very useful yes of course okay

00:14:54,300 --> 00:14:59,020
yes I just wanted to say that after once

00:14:57,670 --> 00:15:01,540
you get a big connection tracking

00:14:59,020 --> 00:15:03,490
support for TC I think that it would

00:15:01,540 --> 00:15:06,220
mean yes a matter to of adding a new

00:15:03,490 --> 00:15:07,510
action to flow offload so you could

00:15:06,220 --> 00:15:09,280
reuse all the infrastructure that I'm

00:15:07,510 --> 00:15:11,380
that I'm going to do before they have

00:15:09,280 --> 00:15:13,870
one of those so it I see this is going

00:15:11,380 --> 00:15:15,220
to be kind of complementary to to the

00:15:13,870 --> 00:15:17,890
board about what I am doing sure if you

00:15:15,220 --> 00:15:21,100
both both things mix well right

00:15:17,890 --> 00:15:24,280
and this is the first stage I think and

00:15:21,100 --> 00:15:26,590
as we spoke in your lecture I think we

00:15:24,280 --> 00:15:29,800
want to to extend that because customers

00:15:26,590 --> 00:15:32,890
are asking for the full blow not just to

00:15:29,800 --> 00:15:35,410
connect to to to to classify our new

00:15:32,890 --> 00:15:38,470
connection also to validate that's the

00:15:35,410 --> 00:15:40,360
packets are in the TCP window so so

00:15:38,470 --> 00:15:41,800
that's the reason I asked what when you

00:15:40,360 --> 00:15:44,200
do a a new connection

00:15:41,800 --> 00:15:45,970
you tell the huddle the NGO of a new

00:15:44,200 --> 00:15:49,450
connection do I get all the information

00:15:45,970 --> 00:15:52,360
that's I think we need to have all the

00:15:49,450 --> 00:15:54,250
information in order to create it to try

00:15:52,360 --> 00:15:59,460
to offload it so we need to TCP window

00:15:54,250 --> 00:15:59,460
and and all the current information and

00:15:59,640 --> 00:16:08,020
after we do that we need to also do to

00:16:05,560 --> 00:16:09,880
pour to get event of connection that's

00:16:08,020 --> 00:16:12,490
are not valid you know that that's the

00:16:09,880 --> 00:16:16,030
user space will understand what is the

00:16:12,490 --> 00:16:18,010
current status for each connection and I

00:16:16,030 --> 00:16:20,320
think there we are finding with some

00:16:18,010 --> 00:16:23,020
small things that's we need to figure

00:16:20,320 --> 00:16:26,020
out what is done for because they are

00:16:23,020 --> 00:16:27,910
free esta if the Feeny we want to take

00:16:26,020 --> 00:16:30,430
the fina because what we understand of

00:16:27,910 --> 00:16:33,130
course that the syn packet will be going

00:16:30,430 --> 00:16:36,280
through the software we don't want to

00:16:33,130 --> 00:16:38,110
hardware offloaded the same packets so

00:16:36,280 --> 00:16:39,610
what we are doing with the fin because

00:16:38,110 --> 00:16:42,070
there are corner case of the fiend

00:16:39,610 --> 00:16:44,590
that's if you get a syn attack in the

00:16:42,070 --> 00:16:47,440
middle you need to do something in the

00:16:44,590 --> 00:16:49,720
fin there are a few cases that's make

00:16:47,440 --> 00:16:52,830
make it complicated to Hardware off of

00:16:49,720 --> 00:16:55,300
it and we want to make it compatible so

00:16:52,830 --> 00:16:56,680
we don't want to tell the customer okay

00:16:55,300 --> 00:16:58,540
we are doing connection tracking but

00:16:56,680 --> 00:17:00,850
we're not supporting this this this so

00:16:58,540 --> 00:17:03,209
the customer will say okay

00:17:00,850 --> 00:17:07,240
so you're not supporting one because

00:17:03,209 --> 00:17:10,329
currently like openvz openstack the

00:17:07,240 --> 00:17:12,939
customer using a security group they

00:17:10,329 --> 00:17:14,799
don't know exactly what it mean quantity

00:17:12,939 --> 00:17:17,500
the implementation is using connection

00:17:14,799 --> 00:17:21,309
tracking so if we want to offload it we

00:17:17,500 --> 00:17:28,029
want to give the same security level we

00:17:21,309 --> 00:17:32,789
don't want so sorry what is your

00:17:28,029 --> 00:17:35,740
strategy for not offloading the sin so

00:17:32,789 --> 00:17:37,809
we we prefer not to offload the scene I

00:17:35,740 --> 00:17:40,179
understand that but do you mean you

00:17:37,809 --> 00:17:44,230
would match on the TCP flag in the

00:17:40,179 --> 00:17:46,330
hardware flow yes but I don't think that

00:17:44,230 --> 00:17:48,429
that's the way to do it the way to do it

00:17:46,330 --> 00:17:50,649
is to match on their current connections

00:17:48,429 --> 00:17:52,299
of the established connections and if

00:17:50,649 --> 00:17:54,850
it's not established its main go to

00:17:52,299 --> 00:17:56,200
software software their connection so

00:17:54,850 --> 00:17:58,029
the syn packet probably go to the

00:17:56,200 --> 00:18:00,789
software because of that we don't need

00:17:58,029 --> 00:18:07,289
to have a match on the scene pockets so

00:18:00,789 --> 00:18:07,289
it's understood I understand thank you

00:18:08,009 --> 00:18:13,990
so one of the questions I have actually

00:18:10,809 --> 00:18:15,759
in general is like so it's quite useful

00:18:13,990 --> 00:18:17,529
to be able to for instance look at what

00:18:15,759 --> 00:18:18,700
the contract the contract state is right

00:18:17,529 --> 00:18:20,769
now you know you've got like the

00:18:18,700 --> 00:18:22,659
contract command-line tool so that will

00:18:20,769 --> 00:18:26,200
be presumably at the moments you know it

00:18:22,659 --> 00:18:27,700
just probes into the the the version of

00:18:26,200 --> 00:18:30,399
the state that exists inside the kernel

00:18:27,700 --> 00:18:32,080
so the question is like what what's the

00:18:30,399 --> 00:18:33,549
synchronization between what exists in

00:18:32,080 --> 00:18:36,490
the kernel state and what exists in

00:18:33,549 --> 00:18:39,190
hardware tables and particularly when

00:18:36,490 --> 00:18:42,610
you're like query Inglis yes so that's

00:18:39,190 --> 00:18:43,929
the reason I won I think that's also the

00:18:42,610 --> 00:18:45,580
timeout and everything we want to

00:18:43,929 --> 00:18:46,779
implement I think it will be easy to

00:18:45,580 --> 00:18:50,710
implement in the software you don't need

00:18:46,779 --> 00:18:54,039
to take it to the hardware so in my idea

00:18:50,710 --> 00:18:55,990
I see that's we will we'll do some

00:18:54,039 --> 00:18:57,100
polling on the hardware and get all the

00:18:55,990 --> 00:19:00,039
connection while they're running

00:18:57,100 --> 00:19:02,019
connection dots and and the counters of

00:19:00,039 --> 00:19:04,509
each of them and update the software

00:19:02,019 --> 00:19:06,159
connection tracking so also that you

00:19:04,509 --> 00:19:08,710
will get number of packets that was

00:19:06,159 --> 00:19:11,139
what's the current window what is the

00:19:08,710 --> 00:19:13,190
last time that packet was seen on this

00:19:11,139 --> 00:19:14,899
connection and then

00:19:13,190 --> 00:19:21,169
you can also manage the timeouts from

00:19:14,899 --> 00:19:22,580
the software this is similar what what

00:19:21,169 --> 00:19:25,489
we are doing for instance in when we

00:19:22,580 --> 00:19:27,080
offload in the hardware villain so so

00:19:25,489 --> 00:19:28,489
actually we offload the neighbor from

00:19:27,080 --> 00:19:30,259
the operating system they don't see the

00:19:28,489 --> 00:19:32,570
activity of the neighbor but operating

00:19:30,259 --> 00:19:35,690
system already has the knob for us to

00:19:32,570 --> 00:19:37,909
update the used value of the neighbor so

00:19:35,690 --> 00:19:39,489
they would not put it into stale so here

00:19:37,909 --> 00:19:42,019
we think something we need something

00:19:39,489 --> 00:19:46,220
similar we need the connection tracking

00:19:42,019 --> 00:19:50,769
subsystem to allow us to upload a used

00:19:46,220 --> 00:19:53,389
value into them or packet and bytes okay

00:19:50,769 --> 00:20:02,539
that would be an internal change it's

00:19:53,389 --> 00:20:04,460
not yes but this is not a

00:20:02,539 --> 00:20:06,249
synchronization that's a feedback okay

00:20:04,460 --> 00:20:08,029
synchronization goes beyond that

00:20:06,249 --> 00:20:09,739
feedback means that you're using

00:20:08,029 --> 00:20:11,840
something which is offloaded from the

00:20:09,739 --> 00:20:13,580
kernel so they would know that it's been

00:20:11,840 --> 00:20:15,710
used right so otherwise they would edge

00:20:13,580 --> 00:20:18,499
this out right now I get that part the

00:20:15,710 --> 00:20:20,179
question is is there so it'll be more

00:20:18,499 --> 00:20:21,470
than potentially more than just a same

00:20:20,179 --> 00:20:23,539
factory right like if you get a whole

00:20:21,470 --> 00:20:26,479
bunch of flows there is a risk that

00:20:23,539 --> 00:20:28,549
you've gotten the same the state has

00:20:26,479 --> 00:20:30,859
progressed you've actually established

00:20:28,549 --> 00:20:32,450
but you still haven't updated the

00:20:30,859 --> 00:20:33,889
software state or you haven't updated

00:20:32,450 --> 00:20:36,489
the hardware state right one way or the

00:20:33,889 --> 00:20:39,649
other that doesn't that risk exists like

00:20:36,489 --> 00:20:41,899
so no because what I mentioned before

00:20:39,649 --> 00:20:46,070
that we went only after this scene when

00:20:41,899 --> 00:20:48,049
when we establish connection then we

00:20:46,070 --> 00:20:51,889
want to 42 the the rule to the hardware

00:20:48,049 --> 00:20:53,299
so you won't see so when you move to the

00:20:51,889 --> 00:20:55,309
shop to the hardware you're already an

00:20:53,299 --> 00:20:57,590
established connection established state

00:20:55,309 --> 00:20:59,869
oh I see because your I see because

00:20:57,590 --> 00:21:03,200
you're saying you may take a couple of

00:20:59,869 --> 00:21:05,299
packets into software post yeah yeah and

00:21:03,200 --> 00:21:08,259
that's okay so it'll be so it'll become

00:21:05,299 --> 00:21:11,179
faster later basically yeah oh God and

00:21:08,259 --> 00:21:13,489
think about calling the hardware every

00:21:11,179 --> 00:21:16,639
one second so when you said when a human

00:21:13,489 --> 00:21:19,730
being is looking on those so one second

00:21:16,639 --> 00:21:22,460
update I think it's good enough

00:21:19,730 --> 00:21:24,289
so I got much basic question than that

00:21:22,460 --> 00:21:26,659
or pony

00:21:24,289 --> 00:21:28,519
so I mean something being established

00:21:26,659 --> 00:21:30,740
doesn't equate it could be a very

00:21:28,519 --> 00:21:32,929
short-lived flaw correct right so what

00:21:30,740 --> 00:21:34,190
what is your decision point yes every

00:21:32,929 --> 00:21:34,669
time it gets established you are not

00:21:34,190 --> 00:21:38,090
Florida

00:21:34,669 --> 00:21:40,100
so the problem that's most of the time

00:21:38,090 --> 00:21:41,809
you need a few pockets in order to

00:21:40,100 --> 00:21:44,090
understand which protocol it is and if

00:21:41,809 --> 00:21:46,490
it's a short lever or long link even if

00:21:44,090 --> 00:21:49,850
it's a YouTube connection that you're

00:21:46,490 --> 00:21:52,789
going to download a full movie or it's a

00:21:49,850 --> 00:21:55,429
short clip of a gif file that is single

00:21:52,789 --> 00:21:57,649
file that you just bless the name to you

00:21:55,429 --> 00:22:00,860
so the problem that you need to parse

00:21:57,649 --> 00:22:03,460
the first pocket to do that and if you

00:22:00,860 --> 00:22:08,179
start to parsing the packets the TCP

00:22:03,460 --> 00:22:11,450
connection is going to be the speed of

00:22:08,179 --> 00:22:14,179
the connection the will will be higher

00:22:11,450 --> 00:22:17,899
and then you will probably when you try

00:22:14,179 --> 00:22:19,220
to offload it you will have a real miss

00:22:17,899 --> 00:22:21,049
ordering the problem because some of

00:22:19,220 --> 00:22:22,399
them are in the software and you will

00:22:21,049 --> 00:22:26,419
start to do the forwarding by the

00:22:22,399 --> 00:22:30,260
hardware you have a TCP reordering so

00:22:26,419 --> 00:22:34,190
miss order sorry so it's it's a problem

00:22:30,260 --> 00:22:36,380
that's we try to avoid so could be that

00:22:34,190 --> 00:22:37,760
we prefer to do the connection tracking

00:22:36,380 --> 00:22:41,090
from the beginning for all the sessions

00:22:37,760 --> 00:22:43,070
and but of course we can think about it

00:22:41,090 --> 00:22:44,809
in the future to find the new scheme

00:22:43,070 --> 00:22:47,630
because currently to their connection

00:22:44,809 --> 00:22:50,090
tracking is not aware of their if it's a

00:22:47,630 --> 00:22:52,730
long wave or short live connection so we

00:22:50,090 --> 00:22:56,210
can decide of course that's only after

00:22:52,730 --> 00:22:57,980
five packets we will call it the harder

00:22:56,210 --> 00:22:59,510
to do a hardware offload this is very

00:22:57,980 --> 00:23:02,029
easy to do but it will cause the

00:22:59,510 --> 00:23:06,500
problems so when the questions actually

00:23:02,029 --> 00:23:08,539
to follow on that is that so the way

00:23:06,500 --> 00:23:09,950
that you're deciding to push things into

00:23:08,539 --> 00:23:13,010
Hardware at the moment is based on these

00:23:09,950 --> 00:23:15,620
TC flower rules and there's some benefit

00:23:13,010 --> 00:23:18,139
for these TC flower rules to mask out

00:23:15,620 --> 00:23:19,850
that set maybe don't matter for like if

00:23:18,139 --> 00:23:22,880
you handle several different actual

00:23:19,850 --> 00:23:24,529
flows with the same rule than you could

00:23:22,880 --> 00:23:26,809
ideally just hardware offload them with

00:23:24,529 --> 00:23:29,480
one giant rule but when it comes to the

00:23:26,809 --> 00:23:32,740
actual individual connections how you

00:23:29,480 --> 00:23:32,740
handle for instance ism

00:23:35,880 --> 00:23:46,110
hardware tables for the connection

00:23:37,830 --> 00:23:47,850
tracking injuries it's yes so the

00:23:46,110 --> 00:23:50,970
hardware awful decision will be from the

00:23:47,850 --> 00:23:53,070
connection tracking it's from the TC

00:23:50,970 --> 00:23:56,100
form point of view you mean that's

00:23:53,070 --> 00:23:58,920
you're going to take down the action go

00:23:56,100 --> 00:24:00,720
to turn to connection tracking it does

00:23:58,920 --> 00:24:02,730
the TC rule and the action what to do

00:24:00,720 --> 00:24:04,650
with the state of the connection after

00:24:02,730 --> 00:24:06,090
you get the packet the connection

00:24:04,650 --> 00:24:10,110
tracking himself it's a kind of a block

00:24:06,090 --> 00:24:15,060
that's DC is using so there will be a

00:24:10,110 --> 00:24:17,550
connection tracking offload so from TC

00:24:15,060 --> 00:24:20,790
so like in the way that this works in

00:24:17,550 --> 00:24:23,040
Mike for instance obvious today we're

00:24:20,790 --> 00:24:24,620
just using whatever the contract table

00:24:23,040 --> 00:24:26,700
limits are so that's like a million

00:24:24,620 --> 00:24:28,800
connections or whatever it is that you

00:24:26,700 --> 00:24:30,000
configure through the sis cattle so does

00:24:28,800 --> 00:24:32,520
that mean that you're also saying well

00:24:30,000 --> 00:24:34,740
I'm going to support putting a million

00:24:32,520 --> 00:24:45,450
contract entries into my hardware tables

00:24:34,740 --> 00:24:46,680
because you have a CTE so yes so can you

00:24:45,450 --> 00:24:48,710
repeat I'm not sure I understand the

00:24:46,680 --> 00:24:48,710
question

00:24:51,850 --> 00:25:01,390
yeah yeah it just keeps on dying halfway

00:24:54,440 --> 00:25:01,390
through this so like

00:25:14,709 --> 00:25:20,029
so you can offload the like the TC

00:25:18,109 --> 00:25:23,539
flower rule which wouldn't matches on

00:25:20,029 --> 00:25:25,339
for instance anything to this IP or it

00:25:23,539 --> 00:25:27,889
could be even more generic than that and

00:25:25,339 --> 00:25:29,359
then your action is do contract and

00:25:27,889 --> 00:25:31,789
perhaps for this particular rule you

00:25:29,359 --> 00:25:34,159
always want to create connection so your

00:25:31,789 --> 00:25:37,729
rule would look like your action is CT

00:25:34,159 --> 00:25:39,499
creates an injury now if you look at

00:25:37,729 --> 00:25:41,450
this like running in software the CT

00:25:39,499 --> 00:25:43,429
create is going to use the contract

00:25:41,450 --> 00:25:44,570
table limits and figured through sis

00:25:43,429 --> 00:25:47,659
cattle so you have like potentially a

00:25:44,570 --> 00:25:50,119
million entries or it could be whatever

00:25:47,659 --> 00:25:51,979
the user happens to configure I think a

00:25:50,119 --> 00:25:54,799
million it's like roughly the default

00:25:51,979 --> 00:25:58,099
today sitting the question is basically

00:25:54,799 --> 00:25:59,929
does the CT create you know action does

00:25:58,099 --> 00:26:03,049
that when you run that in hardware does

00:25:59,929 --> 00:26:04,999
that you know does that do you guarantee

00:26:03,049 --> 00:26:07,489
you have a million you know entries

00:26:04,999 --> 00:26:09,799
available or do you somehow establish a

00:26:07,489 --> 00:26:12,320
fallback path so that the CT action when

00:26:09,799 --> 00:26:15,709
you can't create it falls back first

00:26:12,320 --> 00:26:17,779
we support million of rules a formal

00:26:15,709 --> 00:26:18,139
analysis a hundred that's not the

00:26:17,779 --> 00:26:20,779
problem

00:26:18,139 --> 00:26:25,869
but of course we do have a software

00:26:20,779 --> 00:26:28,909
available fail fail and failsafe

00:26:25,869 --> 00:26:31,940
fallback sorry hope it because also the

00:26:28,909 --> 00:26:34,369
scene pocket using the same same rules

00:26:31,940 --> 00:26:36,769
the same pocket is also going up going

00:26:34,369 --> 00:26:38,149
going to the hardware you have a fail in

00:26:36,769 --> 00:26:39,979
the connection checking you don't know

00:26:38,149 --> 00:26:41,359
match in the hardware the pocket is

00:26:39,979 --> 00:26:43,309
going to the software the software is

00:26:41,359 --> 00:26:45,289
going through the TC and the TC is

00:26:43,309 --> 00:26:47,509
sending it to the connection tracking so

00:26:45,289 --> 00:26:50,179
again if you don't have a match in the

00:26:47,509 --> 00:26:52,219
harder because of this is connection

00:26:50,179 --> 00:26:57,379
that is not established yet this is a

00:26:52,219 --> 00:27:00,079
connection that's you don't you don't

00:26:57,379 --> 00:27:02,179
have enough space in the hardware to to

00:27:00,079 --> 00:27:07,159
maintain the list so this will go to the

00:27:02,179 --> 00:27:09,320
sofa for the aspect of this is it with

00:27:07,159 --> 00:27:11,779
the model that Pablo described in the

00:27:09,320 --> 00:27:13,669
previous session is that the creation

00:27:11,779 --> 00:27:17,029
actually always occurs in software and

00:27:13,669 --> 00:27:18,619
then gets pushed to the hardware so if

00:27:17,029 --> 00:27:21,529
there's resource contention which is a

00:27:18,619 --> 00:27:21,840
valid concern presumably the push would

00:27:21,529 --> 00:27:23,580
fail

00:27:21,840 --> 00:27:26,029
yeah and it would just always you a

00:27:23,580 --> 00:27:26,029
software

00:27:35,250 --> 00:27:41,800
is there any other company probably

00:27:38,110 --> 00:27:44,110
natural new one - yeah well yes I'm from

00:27:41,800 --> 00:27:47,230
metronome anticipating the API I think

00:27:44,110 --> 00:27:48,640
Pablo of course yeah so sorry for being

00:27:47,230 --> 00:27:52,360
a bit quiet I have actually seen this

00:27:48,640 --> 00:27:54,790
material before this is if I had

00:27:52,360 --> 00:27:56,950
designed it it's very similar to what I

00:27:54,790 --> 00:28:01,870
would have designed I think it works

00:27:56,950 --> 00:28:04,030
well I see the main contention from it

00:28:01,870 --> 00:28:05,260
being in in just the topic that we were

00:28:04,030 --> 00:28:07,900
talking about just now that the

00:28:05,260 --> 00:28:10,270
connection set up the fact that the

00:28:07,900 --> 00:28:11,920
scene needs to go to software but I

00:28:10,270 --> 00:28:15,820
think you've thought that through and

00:28:11,920 --> 00:28:17,920
probably it's going to be workable yeah

00:28:15,820 --> 00:28:19,750
otherwise I mean there's significant

00:28:17,920 --> 00:28:21,430
implementation details we're trying to

00:28:19,750 --> 00:28:24,150
get these things together but I'm sure

00:28:21,430 --> 00:28:24,150
we can work through it

00:28:35,940 --> 00:28:42,760
turn it off so I was clear I wasn't in

00:28:41,020 --> 00:28:44,909
your lecture because we're some resource

00:28:42,760 --> 00:28:46,120
contention here on double track but

00:28:44,909 --> 00:28:48,970
Pablo

00:28:46,120 --> 00:28:50,620
so you people who mentioned NGOs for

00:28:48,970 --> 00:28:52,779
offloading that you talked about that

00:28:50,620 --> 00:28:55,000
just a general comment that I think

00:28:52,779 --> 00:28:56,770
today a much much more common in the

00:28:55,000 --> 00:29:00,850
stack is to offload by notifications

00:28:56,770 --> 00:29:03,460
right like if you want to do something

00:29:00,850 --> 00:29:05,260
because sometimes you have like you have

00:29:03,460 --> 00:29:08,440
virtual devices like Villa and Vic's

00:29:05,260 --> 00:29:10,179
line bonding in the way so notifications

00:29:08,440 --> 00:29:14,140
is easier way to get to how to driver

00:29:10,179 --> 00:29:14,820
than to propagate NGOs just think about

00:29:14,140 --> 00:29:19,270
it

00:29:14,820 --> 00:29:21,039
you see I mean did you send you you

00:29:19,270 --> 00:29:22,960
would create a connection tracking

00:29:21,039 --> 00:29:24,820
context and you can send notification I

00:29:22,960 --> 00:29:26,890
created that I mean someone wants to

00:29:24,820 --> 00:29:29,020
offload that they get the notification

00:29:26,890 --> 00:29:32,140
and they act you don't have to call them

00:29:29,020 --> 00:29:36,159
directly that's just a comment consider

00:29:32,140 --> 00:29:43,260
it okay that's an implementation detail

00:29:36,159 --> 00:29:43,260
anyway but I mean so far it's NGO based

00:29:52,330 --> 00:29:56,990
okay so any other vendor through net

00:29:55,430 --> 00:30:09,920
random that's want to collaborate on

00:29:56,990 --> 00:30:16,790
that welcome everyone everyone okay make

00:30:09,920 --> 00:30:19,340
your demanding least okay so any other

00:30:16,790 --> 00:30:21,650
question it's just gonna say it might be

00:30:19,340 --> 00:30:24,020
kind of you're probably already looking

00:30:21,650 --> 00:30:27,710
at this but the the OVS fields manual in

00:30:24,020 --> 00:30:31,600
terms of the kinds of different features

00:30:27,710 --> 00:30:33,500
that OVS uses from contract would be a

00:30:31,600 --> 00:30:36,200
demand pages that would be really useful

00:30:33,500 --> 00:30:38,810
for considering the potential future of

00:30:36,200 --> 00:30:41,270
this API including things like you know

00:30:38,810 --> 00:30:43,930
I mean alg was raised before but but

00:30:41,270 --> 00:30:46,970
that was also raised this morning during

00:30:43,930 --> 00:30:48,980
Harold's sort of archeology of knit

00:30:46,970 --> 00:30:51,140
filter and the question of whether a og

00:30:48,980 --> 00:30:53,920
should exist in kernel or in the

00:30:51,140 --> 00:30:56,540
hardware is sort of another big question

00:30:53,920 --> 00:31:01,130
and then and that sort of relates to

00:30:56,540 --> 00:31:04,310
things like as OBS provides this ability

00:31:01,130 --> 00:31:07,670
to from a related package Fitch the

00:31:04,310 --> 00:31:09,260
original connection that is that like

00:31:07,670 --> 00:31:11,600
the original FTP connection that

00:31:09,260 --> 00:31:18,470
established this connection Fitch the

00:31:11,600 --> 00:31:19,820
5-tuple of that you see based on what

00:31:18,470 --> 00:31:21,020
Simon was saying though it sounds like

00:31:19,820 --> 00:31:23,000
there's still going to be a software

00:31:21,020 --> 00:31:24,290
copy of all of these flows so doing

00:31:23,000 --> 00:31:26,570
things like reverse yeah I guess it

00:31:24,290 --> 00:31:28,100
would be helpful from it just a API

00:31:26,570 --> 00:31:30,230
perspective but it doesn't sound like

00:31:28,100 --> 00:31:34,370
the hardware interface needs to support

00:31:30,230 --> 00:31:36,200
that yeah I think in general Pablo's

00:31:34,370 --> 00:31:37,970
design the idea is to anything that's

00:31:36,200 --> 00:31:39,710
not in Hardwick and still be done in

00:31:37,970 --> 00:31:41,630
software and so that we can

00:31:39,710 --> 00:31:43,550
progressively push more and more

00:31:41,630 --> 00:31:46,960
features or not push more and more

00:31:43,550 --> 00:31:46,960
features into the hard way

00:31:47,690 --> 00:31:54,530
yes as you asked related to related I

00:31:51,110 --> 00:31:56,600
don't think that's FTP parsing we wanted

00:31:54,530 --> 00:31:58,250
to contain the hardware so probably will

00:31:56,600 --> 00:32:00,950
handle them to the software and then

00:31:58,250 --> 00:32:04,940
only the the traffic itself we want to

00:32:00,950 --> 00:32:06,410
do the hardware offload right but for

00:32:04,940 --> 00:32:09,130
instance in the way the OVS you might

00:32:06,410 --> 00:32:12,650
want to use it is for that offloaded

00:32:09,130 --> 00:32:15,380
data traffic you want to do some policy

00:32:12,650 --> 00:32:17,810
match based on the control traffic that

00:32:15,380 --> 00:32:18,920
established this data connect traffic in

00:32:17,810 --> 00:32:21,920
which case you would have to have that

00:32:18,920 --> 00:32:25,810
somehow represented in your your

00:32:21,920 --> 00:32:25,810
intellectual okay hydro float

00:32:33,399 --> 00:32:37,760
so just just describe the use case that

00:32:36,230 --> 00:32:38,750
the Joe was talking about so like you

00:32:37,760 --> 00:32:40,429
have the control channel which is

00:32:38,750 --> 00:32:42,770
establishing the data channels and if

00:32:40,429 --> 00:32:45,320
you have an policy update to the control

00:32:42,770 --> 00:32:46,669
channel then you want to drop the you

00:32:45,320 --> 00:32:48,440
know like for example it was allowed and

00:32:46,669 --> 00:32:50,090
then you want to change it to deny you

00:32:48,440 --> 00:32:52,159
want to kill all of the data channels as

00:32:50,090 --> 00:32:54,320
well is the particular use case that

00:32:52,159 --> 00:32:57,380
where you'd want to then do that you

00:32:54,320 --> 00:32:59,809
know look up going to the connection

00:32:57,380 --> 00:33:08,419
tracking and do kind of a flash with

00:32:59,809 --> 00:33:10,789
something like that so the way that this

00:33:08,419 --> 00:33:13,820
would be done with the OBS stuff today

00:33:10,789 --> 00:33:15,830
is even for the data traffic the match

00:33:13,820 --> 00:33:20,990
is actually based on the control

00:33:15,830 --> 00:33:22,820
traffic's v topple okay so when you run

00:33:20,990 --> 00:33:23,630
through the connection tracking for the

00:33:22,820 --> 00:33:25,700
data traffic

00:33:23,630 --> 00:33:27,710
it looks up the connection tracking the

00:33:25,700 --> 00:33:29,720
entry it finds that was related it goes

00:33:27,710 --> 00:33:31,399
it follows the pointer back to the

00:33:29,720 --> 00:33:32,990
original connection and then gets the

00:33:31,399 --> 00:33:36,620
five tuple of that and then it makes it

00:33:32,990 --> 00:33:39,049
takes that you know if TP control

00:33:36,620 --> 00:33:44,710
traffic's 5 took : and does the the

00:33:39,049 --> 00:33:44,710
policy lookup based on them okay

00:33:51,840 --> 00:33:59,790
I am in an environment of a cluster of

00:33:56,970 --> 00:34:01,830
to physical boxes for example if the

00:33:59,790 --> 00:34:03,560
contract connections say I assume they

00:34:01,830 --> 00:34:08,880
will be synchronized between the colonel

00:34:03,560 --> 00:34:12,810
and some of the those entries in the

00:34:08,880 --> 00:34:17,910
hardware will be also synced a in real

00:34:12,810 --> 00:34:19,830
time yes okay so if the connection is

00:34:17,910 --> 00:34:21,300
broken one member goes down and the

00:34:19,830 --> 00:34:23,220
connection goes to the other member

00:34:21,300 --> 00:34:24,420
those the entries are already entering

00:34:23,220 --> 00:34:31,590
the hardware and ready to come ready to

00:34:24,420 --> 00:34:33,060
rock same table yes so if it's thanks

00:34:31,590 --> 00:34:34,410
but what environment you're talking

00:34:33,060 --> 00:34:38,460
about like you have a link and you

00:34:34,410 --> 00:34:41,070
Gatien or what cluster of redundancy to

00:34:38,460 --> 00:34:47,610
to see those two different boxes ready

00:34:41,070 --> 00:34:51,690
to to deal with connections the same

00:34:47,610 --> 00:34:53,490
hardware different hardware so of course

00:34:51,690 --> 00:34:55,800
you can sync them but the question if

00:34:53,490 --> 00:35:00,240
both of them support all flows for the

00:34:55,800 --> 00:35:01,650
connection cracking so yeah we assume

00:35:00,240 --> 00:35:06,030
assuming they're both the same using the

00:35:01,650 --> 00:35:07,440
same analog for example I think it's

00:35:06,030 --> 00:35:09,780
much easier to support it if we're

00:35:07,440 --> 00:35:13,650
talking about the same chip so that's we

00:35:09,780 --> 00:35:16,170
can use a single table because if not it

00:35:13,650 --> 00:35:18,480
also can be possible to upload so that's

00:35:16,170 --> 00:35:20,820
what I think or mentioned it's you don't

00:35:18,480 --> 00:35:23,760
want to go to specific net device you

00:35:20,820 --> 00:35:25,890
want to submit an event and then both of

00:35:23,760 --> 00:35:29,130
the cards that's know that support it

00:35:25,890 --> 00:35:32,370
will add this entry the entry we want to

00:35:29,130 --> 00:35:34,740
be aged because one of them is hitting

00:35:32,370 --> 00:35:36,540
the traffic and updates the the

00:35:34,740 --> 00:35:40,670
connection tracking so that's the reason

00:35:36,540 --> 00:35:40,670
we will not age this entry

00:36:03,490 --> 00:36:10,760
okay any more questions what about agent

00:36:09,050 --> 00:36:15,100
I'm just trying to understand whether

00:36:10,760 --> 00:36:15,100
your solution because she's joking

00:36:16,240 --> 00:36:24,080
yes yes so as I mentioned before we want

00:36:21,260 --> 00:36:26,840
to update through polling for each

00:36:24,080 --> 00:36:29,300
connection the stationed what is current

00:36:26,840 --> 00:36:31,370
status in the hot rod so that you can do

00:36:29,300 --> 00:36:32,930
the edging the edging is the established

00:36:31,370 --> 00:36:35,990
connection if I remember correctly I

00:36:32,930 --> 00:36:38,380
default in three days so we have it

00:36:35,990 --> 00:36:40,430
depends on the stage of your a

00:36:38,380 --> 00:36:42,920
connection checking and 4,000,000

00:36:40,430 --> 00:36:47,270
connection it could be very painful

00:36:42,920 --> 00:36:50,240
procedure yes to update so we're facing

00:36:47,270 --> 00:36:52,040
this problem also currently today with

00:36:50,240 --> 00:36:53,620
when we try to do when we're doing open

00:36:52,040 --> 00:36:55,550
this switch off load we also maintain

00:36:53,620 --> 00:36:57,590
millions rule and what we are doing

00:36:55,550 --> 00:36:59,240
that's the reason I'm talking about that

00:36:57,590 --> 00:37:01,670
I don't want that it will be event I

00:36:59,240 --> 00:37:05,570
wanted to be a batch that you can grab

00:37:01,670 --> 00:37:07,880
in folding a lot of connections each

00:37:05,570 --> 00:37:10,970
time so you can do a polling for each

00:37:07,880 --> 00:37:14,450
few seconds of one millions because if

00:37:10,970 --> 00:37:15,770
it will be event 1 million events we

00:37:14,450 --> 00:37:18,700
want you can't handle it

00:37:15,770 --> 00:37:18,700
thank you

00:37:21,800 --> 00:37:28,920
okay this is cutting it to be a time so

00:37:25,410 --> 00:37:33,030
let's think Ronnie

00:37:28,920 --> 00:37:37,339
give thank you

00:37:33,030 --> 00:37:37,339

YouTube URL: https://www.youtube.com/watch?v=2CcKzGOdyP0


