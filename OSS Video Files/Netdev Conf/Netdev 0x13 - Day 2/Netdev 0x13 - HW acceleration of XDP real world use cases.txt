Title: Netdev 0x13 - HW acceleration of XDP real world use cases
Publication date: 2019-05-25
Playlist: Netdev 0x13 - Day 2
Description: 
	In this talk Rony Efraim and Amir Ancel present a solution architecture and API approach that show cases hardware-software interaction for accelerated HW XDP.

With a few lines of code change to the Facebook Load balancer Katran to enable
TC offload they show phenomenal improvement in performance.

More info:
https://netdevconf.org/0x13/session.html?talk-hw-accel-xdp-use-cases
Captions: 
	00:00:00,060 --> 00:00:06,690
good afternoon my name is emiram close

00:00:05,430 --> 00:00:11,099
the door please

00:00:06,690 --> 00:00:13,230
I work for Mellanox

00:00:11,099 --> 00:00:18,300
in charge of the performance clinic

00:00:13,230 --> 00:00:23,390
performance I am running a frame and

00:00:18,300 --> 00:00:32,399
also technique Mellanox lets you listen

00:00:23,390 --> 00:00:36,239
today okay so what are we going to talk

00:00:32,399 --> 00:00:42,180
about we're going to talk about hardware

00:00:36,239 --> 00:00:44,719
acceleration for XDP and these are the

00:00:42,180 --> 00:00:47,610
topics mainly we want to use

00:00:44,719 --> 00:00:51,899
acceleration Rock DP not from off load

00:00:47,610 --> 00:00:56,160
yet and what want to do is using

00:00:51,899 --> 00:01:04,260
metadata prepared by the Nick harder it

00:00:56,160 --> 00:01:09,049
will be vendor agnostic have a generic

00:01:04,260 --> 00:01:13,250
API to the xdp something like TC and

00:01:09,049 --> 00:01:17,040
what we can do with metadata is save

00:01:13,250 --> 00:01:20,060
save the parsing of the packet and also

00:01:17,040 --> 00:01:22,710
saved cache miss included in that and

00:01:20,060 --> 00:01:28,210
for that we need to add rules to the NIC

00:01:22,710 --> 00:01:31,440
hardware to either mark the packet or

00:01:28,210 --> 00:01:31,440
[Music]

00:01:34,280 --> 00:01:43,470
okay in kinetics network adapters we

00:01:38,820 --> 00:01:46,530
have acceleration capabilities for

00:01:43,470 --> 00:01:52,250
classification and actions the adapter

00:01:46,530 --> 00:01:56,729
can do a classification for l2 l3 for

00:01:52,250 --> 00:02:00,990
encapsulation and cap dica and parsing

00:01:56,729 --> 00:02:03,329
and more fields by the open flow and

00:02:00,990 --> 00:02:06,719
reactions in the marking steering to

00:02:03,329 --> 00:02:11,060
queues into virtual function rewriting

00:02:06,719 --> 00:02:14,190
packets counters and so on so we have

00:02:11,060 --> 00:02:21,599
modern NICs modern NICs can do those

00:02:14,190 --> 00:02:27,140
things so let's use them what we can do

00:02:21,599 --> 00:02:30,920
for its DP so we can use TC to put

00:02:27,140 --> 00:02:33,840
insert the rules into the hardware and

00:02:30,920 --> 00:02:35,819
it should work also with legacy NICs

00:02:33,840 --> 00:02:41,730
that do not have other acceleration

00:02:35,819 --> 00:02:46,170
support so two examples one of them

00:02:41,730 --> 00:02:50,879
gonna show is marking so you can use

00:02:46,170 --> 00:02:54,239
already TC to do marking on the skb with

00:02:50,879 --> 00:02:58,530
skb edit mark a flow with a certain

00:02:54,239 --> 00:03:05,129
number certain tag and then choose any

00:02:58,530 --> 00:03:07,170
action for that marking another example

00:03:05,129 --> 00:03:10,260
is dropping instead of going to the

00:03:07,170 --> 00:03:13,019
software and dropping software you can

00:03:10,260 --> 00:03:17,730
decide that your specific flow is going

00:03:13,019 --> 00:03:20,489
to be dropped in hardware also and all

00:03:17,730 --> 00:03:27,140
the statistics of of those flows will go

00:03:20,489 --> 00:03:29,610
to the software so usually all the

00:03:27,140 --> 00:03:32,760
performance at the XDP programs is

00:03:29,610 --> 00:03:35,129
showing so you can drop around at 20

00:03:32,760 --> 00:03:38,879
millions packet per second per quart so

00:03:35,129 --> 00:03:41,489
I think in that case you can drop 100

00:03:38,879 --> 00:03:44,599
million packets per second which 0

00:03:41,489 --> 00:03:44,599
course for example

00:03:45,620 --> 00:03:54,030
that's okay so the XDP application that

00:03:51,959 --> 00:03:57,120
will really use case that we're going to

00:03:54,030 --> 00:04:06,150
talk about is Catherine so first of all

00:03:57,120 --> 00:04:09,239
what is cut okay so what is that first

00:04:06,150 --> 00:04:15,390
the first thing it is it's a village in

00:04:09,239 --> 00:04:22,410
Kyrgyzstan okay second thing is we need

00:04:15,390 --> 00:04:24,330
to cut and run with a typo so the third

00:04:22,410 --> 00:04:28,710
thing is you know just a cat running

00:04:24,330 --> 00:04:35,520
away with also some okay and it's also a

00:04:28,710 --> 00:04:39,810
load balancer and what it is so it all

00:04:35,520 --> 00:04:44,340
those all those things and it really is

00:04:39,810 --> 00:04:51,979
in our world a load balancer software

00:04:44,340 --> 00:04:55,470
written in XTP and what it does like

00:04:51,979 --> 00:04:59,600
over that packets coming in from the

00:04:55,470 --> 00:05:03,450
network going to the load balancer being

00:04:59,600 --> 00:05:06,030
parsed if it's a new flow you need to

00:05:03,450 --> 00:05:10,050
calculate you need to take to do a hash

00:05:06,030 --> 00:05:11,820
and create a key for that and then you

00:05:10,050 --> 00:05:14,539
encapsulate the packet and send it over

00:05:11,820 --> 00:05:17,910
to the real server that is actually

00:05:14,539 --> 00:05:22,680
consuming the packet and performing the

00:05:17,910 --> 00:05:24,500
processing for the application so we

00:05:22,680 --> 00:05:29,039
have the cut one we have the real server

00:05:24,500 --> 00:05:33,539
we have services so on the link so here

00:05:29,039 --> 00:05:37,020
it's open source by Facebook so what we

00:05:33,539 --> 00:05:43,169
did we took it and we added acceleration

00:05:37,020 --> 00:05:45,840
for that so a little deeper on cut one

00:05:43,169 --> 00:05:48,770
it has two parts it has user space part

00:05:45,840 --> 00:05:54,030
and xdp based packet processing code

00:05:48,770 --> 00:05:55,550
they these parts has the shared share

00:05:54,030 --> 00:05:58,559
tables for the

00:05:55,550 --> 00:06:01,349
between the users and user space and XDP

00:05:58,559 --> 00:06:05,399
where all the keys and virtual IPS are

00:06:01,349 --> 00:06:07,889
stored and the action are as I said it's

00:06:05,399 --> 00:06:11,669
you need to do parsing extract for light

00:06:07,889 --> 00:06:14,819
flow ID from the force you need to

00:06:11,669 --> 00:06:16,710
generate a key if it's a new flow and

00:06:14,819 --> 00:06:18,839
then you need to look up that key in the

00:06:16,710 --> 00:06:21,210
verge in the rich database where you

00:06:18,839 --> 00:06:24,229
have the virtual IP you update

00:06:21,210 --> 00:06:27,990
statistics counters and so on and you

00:06:24,229 --> 00:06:30,270
modify the packet do usually here its IP

00:06:27,990 --> 00:06:32,729
IP capsulation

00:06:30,270 --> 00:06:36,330
and you send it to the real server this

00:06:32,729 --> 00:06:41,159
is what the cut run does and what we did

00:06:36,330 --> 00:06:45,779
is added acceleration using t see how we

00:06:41,159 --> 00:06:50,099
did it packets are arriving from the NIC

00:06:45,779 --> 00:06:52,979
into the XLE program xep program what it

00:06:50,099 --> 00:06:57,689
does it first check if the public

00:06:52,979 --> 00:07:00,389
already has a mark if it doesn't have a

00:06:57,689 --> 00:07:05,370
mark it needs to like the legacy one it

00:07:00,389 --> 00:07:11,459
needs to parse it need to look to look

00:07:05,370 --> 00:07:13,529
up look up the flow ID and if it's if if

00:07:11,459 --> 00:07:15,659
it doesn't exist then it has it added

00:07:13,529 --> 00:07:18,749
with the hash and what we added is

00:07:15,659 --> 00:07:21,719
actually the part where you sync signal

00:07:18,749 --> 00:07:24,930
to the user space application to add

00:07:21,719 --> 00:07:28,019
that flow to the hardware so you see we

00:07:24,930 --> 00:07:29,580
signal it through perfect to the user

00:07:28,019 --> 00:07:33,559
space to the same user space application

00:07:29,580 --> 00:07:36,719
user space part of the catchment and

00:07:33,559 --> 00:07:40,769
that user space application app update

00:07:36,719 --> 00:07:45,990
xdp map and called TC to mark that flow

00:07:40,769 --> 00:07:49,110
with a certain flow ID once this flow

00:07:45,990 --> 00:07:53,389
like a same flower is like arriving to

00:07:49,110 --> 00:07:57,439
the xdp program it skip this part and

00:07:53,389 --> 00:08:02,269
just updated statistics encapsulate and

00:07:57,439 --> 00:08:02,269
doing the takes for the wire

00:08:03,650 --> 00:08:12,480
questions you know so so the only thing

00:08:10,650 --> 00:08:19,130
that you need to change in the program

00:08:12,480 --> 00:08:26,120
is only there only the three colored

00:08:19,130 --> 00:08:26,120
lines we need to extend the application

00:08:28,100 --> 00:08:35,099
okay so a little bit more info about

00:08:30,650 --> 00:08:39,180
user space application as we said it it

00:08:35,099 --> 00:08:42,690
updates it gets the perfect from from

00:08:39,180 --> 00:08:46,560
from the XTP application then create TC

00:08:42,690 --> 00:08:53,430
using TC filter skb edit mark and the

00:08:46,560 --> 00:09:01,500
mark ID here and from that point on the

00:08:53,430 --> 00:09:06,150
harder is marking it and you get it on

00:09:01,500 --> 00:09:09,210
the skb and you can see the modified

00:09:06,150 --> 00:09:17,910
code is here you can have a look and

00:09:09,210 --> 00:09:22,590
browse it you can get so what we gain

00:09:17,910 --> 00:09:27,660
from it right performance this is what

00:09:22,590 --> 00:09:32,250
we do so performance results what we've

00:09:27,660 --> 00:09:33,210
seen that we we run it with multiple our

00:09:32,250 --> 00:09:38,160
excuse

00:09:33,210 --> 00:09:42,210
each rxq is a different core and it

00:09:38,160 --> 00:09:44,820
directs Q and T excu of course the same

00:09:42,210 --> 00:09:47,700
go to the x ttv program and antics on

00:09:44,820 --> 00:09:51,360
the same core and what we've seen is

00:09:47,700 --> 00:09:54,890
that with a small number of laws we saw

00:09:51,360 --> 00:09:59,610
between 40 and 50 percent improvement

00:09:54,890 --> 00:10:02,730
and and it scales up as well when you go

00:09:59,610 --> 00:10:06,000
up with a number of course so the green

00:10:02,730 --> 00:10:09,630
is the metadata accelerated results this

00:10:06,000 --> 00:10:11,550
is packet per second so like what single

00:10:09,630 --> 00:10:15,390
core was improved from about three

00:10:11,550 --> 00:10:17,880
million to four point almost 2 million

00:10:15,390 --> 00:10:29,250
and it goes up until the improvement

00:10:17,880 --> 00:10:32,790
from 26 to 39 or 40 million between the

00:10:29,250 --> 00:10:34,380
course was the distribution of traffic

00:10:32,790 --> 00:10:35,550
that was supposed to be dropped persons

00:10:34,380 --> 00:10:38,130
traffic that was supposed to be

00:10:35,550 --> 00:10:40,140
forwarded so all the packets were all

00:10:38,130 --> 00:10:42,390
marked we didn't use drop in this

00:10:40,140 --> 00:10:45,210
experiment everything is going to the

00:10:42,390 --> 00:10:48,900
software and being accelerated by the

00:10:45,210 --> 00:10:50,910
market so the software doesn't happen

00:10:48,900 --> 00:10:53,760
after the first flow

00:10:50,910 --> 00:11:00,740
it doesn't use it doesn't look up the

00:10:53,760 --> 00:11:00,740
flow ID and just statistics and transmit

00:11:19,490 --> 00:11:25,830
skb action you're not really editing

00:11:23,490 --> 00:11:27,720
this KB I'm guessing you're doing it in

00:11:25,830 --> 00:11:31,650
the data metal for the

00:11:27,720 --> 00:11:35,250
xdp buffer the mark action so it

00:11:31,650 --> 00:11:37,500
actually also do the skp edit so if you

00:11:35,250 --> 00:11:39,240
don't have an X DB program that is what

00:11:37,500 --> 00:11:42,630
is done today yeah yeah you will get it

00:11:39,240 --> 00:11:49,050
in there sq in the sqb mark but now we

00:11:42,630 --> 00:11:51,090
also extended the XT program today so so

00:11:49,050 --> 00:11:53,640
so the understanding is right it is not

00:11:51,090 --> 00:11:56,700
in this KB but in the data matter of X

00:11:53,640 --> 00:11:59,610
DV x DP is done before they ask you be

00:11:56,700 --> 00:12:01,650
right right so the next question is I

00:11:59,610 --> 00:12:04,130
mean when only we were talking about

00:12:01,650 --> 00:12:08,400
this you know we had some discussions

00:12:04,130 --> 00:12:11,310
when they was around in Neda about how

00:12:08,400 --> 00:12:13,410
do we define the format of these hints

00:12:11,310 --> 00:12:17,130
which are acceleration hints that we

00:12:13,410 --> 00:12:19,050
program provide to the HDP program in

00:12:17,130 --> 00:12:20,580
this case because it's just one hint

00:12:19,050 --> 00:12:23,010
that you're giving which is a mark I

00:12:20,580 --> 00:12:23,760
mean you know simple enough we just put

00:12:23,010 --> 00:12:25,650
it and use it

00:12:23,760 --> 00:12:28,380
but then if we have to do more than that

00:12:25,650 --> 00:12:33,240
would you do you guys have any idea of

00:12:28,380 --> 00:12:36,750
that so we use the RFC that's aside from

00:12:33,240 --> 00:12:39,090
Mellanox a published and it's using a

00:12:36,750 --> 00:12:41,880
very complicated structure that's

00:12:39,090 --> 00:12:47,310
actually it's put it in the head room of

00:12:41,880 --> 00:12:48,690
the of the buffer well again this is the

00:12:47,310 --> 00:12:53,340
complicated data structure is

00:12:48,690 --> 00:12:56,040
vendor-specific know it's a generic it's

00:12:53,340 --> 00:12:59,100
a generic way to tell the driver I want

00:12:56,040 --> 00:13:01,860
their specific feature to and be enabled

00:12:59,100 --> 00:13:04,800
and it will be copied to the to the head

00:13:01,860 --> 00:13:12,870
room how does the X DB program parse

00:13:04,800 --> 00:13:14,280
that information it's not accepted

00:13:12,870 --> 00:13:17,030
upstream and option wants another

00:13:14,280 --> 00:13:21,660
solution that is based on the the tip

00:13:17,030 --> 00:13:24,030
the PDF type format instead so and sage

00:13:21,660 --> 00:13:25,530
is also working on that but yeah and I

00:13:24,030 --> 00:13:30,620
also have an implementation that got

00:13:25,530 --> 00:13:30,620
rejected upstream like say it's like

00:13:31,790 --> 00:13:37,770
yeah we have to figure this one out

00:13:34,650 --> 00:13:42,720
this is very critical for the forward

00:13:37,770 --> 00:13:45,900
progress of the project we first want

00:13:42,720 --> 00:13:52,080
you know to give the appetizer first for

00:13:45,900 --> 00:13:55,050
the people to do it so now's the time we

00:13:52,080 --> 00:13:59,220
need to renew my normal rant against the

00:13:55,050 --> 00:14:04,730
neck vendors so this supports what a

00:13:59,220 --> 00:14:07,830
handful of protocols UDP TCP to Neve yes

00:14:04,730 --> 00:14:10,050
we we had the battle to get checksum

00:14:07,830 --> 00:14:12,900
complete because that works with all

00:14:10,050 --> 00:14:16,050
protocols and I'm concerned that we're

00:14:12,900 --> 00:14:18,420
falling back into that mode where the

00:14:16,050 --> 00:14:20,490
nicks are only supporting protocols that

00:14:18,420 --> 00:14:22,710
basically the marketing team at the

00:14:20,490 --> 00:14:24,930
vendors want to support so I'm trying to

00:14:22,710 --> 00:14:29,250
be constructive and figure out a way

00:14:24,930 --> 00:14:32,490
forward and yeah so that last line inner

00:14:29,250 --> 00:14:36,350
packet and TCP UDP this looks like the

00:14:32,490 --> 00:14:38,780
datasheet no that well one below

00:14:36,350 --> 00:14:41,480
we in Mellanox nix we do support

00:14:38,780 --> 00:14:45,800
reflects parser and we use it today to

00:14:41,480 --> 00:14:48,080
implement in neo protocols so for

00:14:45,800 --> 00:14:51,710
example we can parse quick we can well

00:14:48,080 --> 00:14:53,780
well if you can purchase anything that's

00:14:51,710 --> 00:14:57,590
fine but there's still the issue if you

00:14:53,780 --> 00:15:00,080
go to the TC flower man page it's it's

00:14:57,590 --> 00:15:01,910
like three pages long and if you read it

00:15:00,080 --> 00:15:03,830
it supports a very small number of

00:15:01,910 --> 00:15:06,020
protocols so somehow we need to get out

00:15:03,830 --> 00:15:09,290
of this mode that there's only a few

00:15:06,020 --> 00:15:11,360
protocols so I think if the right way to

00:15:09,290 --> 00:15:15,410
do this if the infrastructure allows

00:15:11,360 --> 00:15:17,780
that flexible parsing sunbae I do want

00:15:15,410 --> 00:15:19,820
to be able to download BPF program to

00:15:17,780 --> 00:15:22,310
actually do the parsing for me I don't

00:15:19,820 --> 00:15:24,980
want to rely on the vendors if we can

00:15:22,310 --> 00:15:29,380
get there that's a good thing so BPF

00:15:24,980 --> 00:15:35,150
it's not efficient for a six but can we

00:15:29,380 --> 00:15:39,760
agree don't before well well so let's

00:15:35,150 --> 00:15:41,450
not worry about about the p4 versus BPS

00:15:39,760 --> 00:15:43,940
it's critical

00:15:41,450 --> 00:15:47,660
well but the first level is any program

00:15:43,940 --> 00:15:49,460
ability of the parser before I need a

00:15:47,660 --> 00:15:50,840
fixed parser that's the differentiation

00:15:49,460 --> 00:15:53,240
that I want to make I don't I don't care

00:15:50,840 --> 00:15:55,520
as much about p4 versus BPF because you

00:15:53,240 --> 00:15:59,150
can always convert p4 to b PF or

00:15:55,520 --> 00:16:02,120
whatever or maybe vice versa but so it's

00:15:59,150 --> 00:16:05,000
like a concern when I see classification

00:16:02,120 --> 00:16:06,860
fields and a very small number and we

00:16:05,000 --> 00:16:09,800
just had Alyssa talk about protocol

00:16:06,860 --> 00:16:11,870
suffocation we had talks this morning

00:16:09,800 --> 00:16:16,790
about people want to put OAM and even

00:16:11,870 --> 00:16:18,710
tcp it's an it's a mismatch if i have a

00:16:16,790 --> 00:16:21,470
device that is offering this great

00:16:18,710 --> 00:16:25,250
functionality but it's very limited to

00:16:21,470 --> 00:16:26,930
the protocols that can support okay so

00:16:25,250 --> 00:16:27,440
so that's the reason we do have in the

00:16:26,930 --> 00:16:30,350
hardware

00:16:27,440 --> 00:16:33,860
currently we're not exposing it as a p4

00:16:30,350 --> 00:16:37,070
so in the language of p4 you can expect

00:16:33,860 --> 00:16:40,690
you can define new structure of

00:16:37,070 --> 00:16:45,170
protocols you can extend the pipeline of

00:16:40,690 --> 00:16:46,850
the tree of protocols so before you do

00:16:45,170 --> 00:16:48,930
give this

00:16:46,850 --> 00:16:52,410
how much how many more slides do you

00:16:48,930 --> 00:16:53,310
have we can continue doing this two more

00:16:52,410 --> 00:16:59,190
okay

00:16:53,310 --> 00:17:03,090
keep keep going Tom there's only about

00:16:59,190 --> 00:17:07,200
ten minutes left so if if the ten

00:17:03,090 --> 00:17:09,210
minutes left this talk yes so I think

00:17:07,200 --> 00:17:15,540
that's great if if you can somehow use

00:17:09,210 --> 00:17:18,390
before we're not wedded to BPF in that

00:17:15,540 --> 00:17:22,380
sense p4 does have an advantage and the

00:17:18,390 --> 00:17:23,880
way it describes the parse graph is a

00:17:22,380 --> 00:17:25,110
descriptive language and that makes a

00:17:23,880 --> 00:17:27,480
lot of sense it's something that we do

00:17:25,110 --> 00:17:29,820
lack in the BPS world if you look at

00:17:27,480 --> 00:17:32,820
something like flow to sector in the

00:17:29,820 --> 00:17:34,800
kernel or BPF it's a lot of code because

00:17:32,820 --> 00:17:36,840
it's a functional language but if you

00:17:34,800 --> 00:17:39,240
step back and look at what what protocol

00:17:36,840 --> 00:17:41,520
person really is you can come up with an

00:17:39,240 --> 00:17:43,080
abstraction more like p4 that actually

00:17:41,520 --> 00:17:46,230
makes sense so if you could take that

00:17:43,080 --> 00:17:50,070
abstraction with this interface and give

00:17:46,230 --> 00:17:52,650
me the ability to program I want to do

00:17:50,070 --> 00:17:54,090
quick classification for some reason and

00:17:52,650 --> 00:17:55,440
I don't want to have to go back to the

00:17:54,090 --> 00:17:58,320
hardware vendor but if I can do that

00:17:55,440 --> 00:17:59,940
somehow in a common programmable

00:17:58,320 --> 00:18:02,040
language that's right once run anywhere

00:17:59,940 --> 00:18:03,600
and I can program it and get this sort

00:18:02,040 --> 00:18:06,930
of thing and I can classify quick

00:18:03,600 --> 00:18:12,450
packets by the connection ID that is a

00:18:06,930 --> 00:18:21,510
value to me yeah let's have the

00:18:12,450 --> 00:18:28,590
discussion of this okay so we're talking

00:18:21,510 --> 00:18:30,600
about the results in 1550 flows then we

00:18:28,590 --> 00:18:36,840
wanted more right hundred flows not

00:18:30,600 --> 00:18:40,980
really so we wanted more we bring up two

00:18:36,840 --> 00:18:44,700
Roper up to 10k flows and what we saw

00:18:40,980 --> 00:18:49,500
there is that on 12 cores we still got

00:18:44,700 --> 00:18:52,620
the 50 almost 50/50 percent gain with

00:18:49,500 --> 00:18:56,330
acceleration and what we saw interesting

00:18:52,620 --> 00:18:58,330
is that with low number of course and

00:18:56,330 --> 00:19:02,920
single cord was almost

00:18:58,330 --> 00:19:04,930
there's no improvement and when we sew

00:19:02,920 --> 00:19:08,950
the improvement is increasing as you

00:19:04,930 --> 00:19:13,390
increase the number of course then we

00:19:08,950 --> 00:19:15,820
thought okay what Wow why is that what

00:19:13,390 --> 00:19:19,920
we found out is that we thought about it

00:19:15,820 --> 00:19:22,540
and we were thinking that the actual

00:19:19,920 --> 00:19:27,550
when you have one core you have 10k

00:19:22,540 --> 00:19:30,280
flows you have cash basis for the

00:19:27,550 --> 00:19:34,330
counters so you still have cache misses

00:19:30,280 --> 00:19:38,940
on a single core and so we thought why

00:19:34,330 --> 00:19:42,370
why on 12 cores you don't have it so and

00:19:38,940 --> 00:19:44,590
so it's pretty simple but on - of course

00:19:42,370 --> 00:19:48,370
these 10k are dividing between the

00:19:44,590 --> 00:19:52,030
course so we get about 1,000 flows per

00:19:48,370 --> 00:20:00,220
core and with 1,000 we already got good

00:19:52,030 --> 00:20:05,040
improvement in that 40% range so this is

00:20:00,220 --> 00:20:10,330
the explanation of why of course

00:20:05,040 --> 00:20:15,250
currently less efficient but we do have

00:20:10,330 --> 00:20:18,250
a way to fix that so what we've learned

00:20:15,250 --> 00:20:22,750
is really currently with the current

00:20:18,250 --> 00:20:25,630
implementation high number of flows so

00:20:22,750 --> 00:20:28,930
what we need to do is actually instead

00:20:25,630 --> 00:20:32,410
of marking per flow we need to mark per

00:20:28,930 --> 00:20:34,990
destination ID destination ID is the

00:20:32,410 --> 00:20:39,010
real server so we don't really need to

00:20:34,990 --> 00:20:43,510
mark per flow basis you need to mark

00:20:39,010 --> 00:20:53,290
each flow we need to only to mark its

00:20:43,510 --> 00:20:56,050
destination and that that will that

00:20:53,290 --> 00:21:01,270
should clear the cache miss issue from

00:20:56,050 --> 00:21:03,520
the CPU another thing that to avoid

00:21:01,270 --> 00:21:07,270
cache miss for the statistics is also

00:21:03,520 --> 00:21:09,070
using TC for the statistics in order so

00:21:07,270 --> 00:21:11,010
instead of opting the updating the

00:21:09,070 --> 00:21:14,340
statistics in software

00:21:11,010 --> 00:21:16,140
cause Christmas you get the statistics

00:21:14,340 --> 00:21:18,990
from the other and whenever you want to

00:21:16,140 --> 00:21:20,730
read it for flow aging and so on you

00:21:18,990 --> 00:21:25,410
just query the hardware and get the

00:21:20,730 --> 00:21:27,600
statistics from that so once we do that

00:21:25,410 --> 00:21:31,770
we expect the performance of multi-core

00:21:27,600 --> 00:21:34,590
or even 1 million core 1 million flows

00:21:31,770 --> 00:21:37,710
one mini of course is not yet they're

00:21:34,590 --> 00:21:39,540
not yet not in single server so 1

00:21:37,710 --> 00:21:41,880
million flows are expected to be the

00:21:39,540 --> 00:21:44,280
same as 100 flows so single code would

00:21:41,880 --> 00:21:47,820
be 4 million and 12 cores of the 40

00:21:44,280 --> 00:21:53,640
million for 1 million flows this is what

00:21:47,820 --> 00:22:01,380
we expect after these modification keep

00:21:53,640 --> 00:22:03,860
you updated more questions for a

00:22:01,380 --> 00:22:03,860
question or two

00:22:08,269 --> 00:22:17,269
okay so one observation when when you

00:22:13,289 --> 00:22:20,909
have both TC rose and XDP program loaded

00:22:17,269 --> 00:22:22,889
and you just specify TC rose without bit

00:22:20,909 --> 00:22:24,659
out like saying but they should be

00:22:22,889 --> 00:22:27,450
offloaded or not like so you don't

00:22:24,659 --> 00:22:31,740
specify the skip hardware flag terms

00:22:27,450 --> 00:22:35,070
like yes then depending on what the

00:22:31,740 --> 00:22:38,279
rules are and what hardware is capable

00:22:35,070 --> 00:22:41,700
of doing those two things might happen

00:22:38,279 --> 00:22:44,100
to execute in either order so if the TC

00:22:41,700 --> 00:22:46,830
rows are offloaded they will run before

00:22:44,100 --> 00:22:49,380
xdp but if they happen not to be

00:22:46,830 --> 00:22:50,789
uploaded because of whatever arbitrary

00:22:49,380 --> 00:22:53,940
choices we're talking about the colonel

00:22:50,789 --> 00:22:56,279
XD program will be on first so this is

00:22:53,940 --> 00:22:58,830
really inconsistent so I wonder whether

00:22:56,279 --> 00:23:01,620
the correct solution would be like this

00:22:58,830 --> 00:23:04,440
allowing offloading of t semen and xdb

00:23:01,620 --> 00:23:07,470
program is loaded to always preserve the

00:23:04,440 --> 00:23:09,330
same order because this is highly

00:23:07,470 --> 00:23:17,460
confusing and I think it's wrong I think

00:23:09,330 --> 00:23:20,309
it's a bug in the kernel actually this

00:23:17,460 --> 00:23:23,460
example think we must use of course skip

00:23:20,309 --> 00:23:30,809
software because this pocket not not

00:23:23,460 --> 00:23:32,970
supposed to come to DC at all so what

00:23:30,809 --> 00:23:35,250
you're proposing is to like have

00:23:32,970 --> 00:23:37,500
different behavior of the kernel and the

00:23:35,250 --> 00:23:40,019
Skip software flag is specified and not

00:23:37,500 --> 00:23:42,210
that doesn't seem correct to me either

00:23:40,019 --> 00:23:45,120
and if you behave we the same know so

00:23:42,210 --> 00:23:48,990
what will happen if you're asking for

00:23:45,120 --> 00:23:49,740
skip software the so the harder will do

00:23:48,990 --> 00:23:51,630
it for you

00:23:49,740 --> 00:23:54,059
so when you get a packet and what's

00:23:51,630 --> 00:23:56,130
classifying the hardware you will get

00:23:54,059 --> 00:23:58,230
and it's like if you don't have an ax DP

00:23:56,130 --> 00:24:01,080
program that's doing nothing you will

00:23:58,230 --> 00:24:03,720
get a packet with an S key be with S key

00:24:01,080 --> 00:24:06,120
be mark with the specific value the

00:24:03,720 --> 00:24:12,929
hardware is doing it of course by the

00:24:06,120 --> 00:24:15,380
driver outside yes for last one somebody

00:24:12,929 --> 00:24:20,570
else wanted to ask a question

00:24:15,380 --> 00:24:23,960
I have one why why did you like update

00:24:20,570 --> 00:24:25,970
while you're sending an event we had the

00:24:23,960 --> 00:24:27,440
ring buffer at the perforin buffer to

00:24:25,970 --> 00:24:29,750
use the space and then then you update

00:24:27,440 --> 00:24:34,090
the map from user space why don't you

00:24:29,750 --> 00:24:34,090
just update a map from the fast path

00:24:37,120 --> 00:24:41,660
think about optimization but the reason

00:24:39,860 --> 00:24:43,340
that we're sending an event because you

00:24:41,660 --> 00:24:47,390
don't want the user space to scan them

00:24:43,340 --> 00:24:51,290
up you want to get an event because you

00:24:47,390 --> 00:24:54,170
need to do an action for every new that

00:24:51,290 --> 00:24:56,210
find you installing that the TC stuff

00:24:54,170 --> 00:24:58,250
but you could you could already mark the

00:24:56,210 --> 00:25:01,450
packets before but I guess you don't

00:24:58,250 --> 00:25:04,850
need actually not interested in marking

00:25:01,450 --> 00:25:08,750
right you're interested in the hardware

00:25:04,850 --> 00:25:11,480
marking yeah because you didn't get a

00:25:08,750 --> 00:25:14,000
specific action to mark it so if you run

00:25:11,480 --> 00:25:17,600
to you if you typically want to mark it

00:25:14,000 --> 00:25:22,610
of course you can yeah but I still think

00:25:17,600 --> 00:25:24,290
so it's in use as a lookup table I think

00:25:22,610 --> 00:25:26,840
you need to student in the first part to

00:25:24,290 --> 00:25:30,890
update the map that that that you

00:25:26,840 --> 00:25:33,320
calculate the to figure out what flow

00:25:30,890 --> 00:25:35,240
ite does this and then then you have to

00:25:33,320 --> 00:25:38,690
look up in that table and it will be too

00:25:35,240 --> 00:25:40,220
slow having to late by killing you are

00:25:38,690 --> 00:25:42,050
waiting for the user space to update

00:25:40,220 --> 00:25:45,800
before you can start processing packets

00:25:42,050 --> 00:25:47,630
but it's just a minor detail and so in

00:25:45,800 --> 00:25:50,210
any case you know if it's take time or

00:25:47,630 --> 00:25:51,830
if the hardware is not supporting the

00:25:50,210 --> 00:25:54,170
code the code is still processing

00:25:51,830 --> 00:25:58,100
pockets even that they are not marked by

00:25:54,170 --> 00:26:00,680
the order so legacy just continue

00:25:58,100 --> 00:26:03,410
working we also have some ideas you know

00:26:00,680 --> 00:26:05,540
maybe not to go to to use the space

00:26:03,410 --> 00:26:09,170
maybe to have a helper function that's

00:26:05,540 --> 00:26:11,630
actually adding a rule yeah so there are

00:26:09,170 --> 00:26:15,830
so many options we just you know I think

00:26:11,630 --> 00:26:19,510
what is make me make me do this work I

00:26:15,830 --> 00:26:23,060
think if you remember few tips ago

00:26:19,510 --> 00:26:24,830
everybody said okay I'm doing xtp and

00:26:23,060 --> 00:26:29,090
that's the DOS and

00:26:24,830 --> 00:26:31,760
me and Gemma was asking why why are you

00:26:29,090 --> 00:26:33,680
not using TC to do it there are awful

00:26:31,760 --> 00:26:36,890
for that and you can show me that's it's

00:26:33,680 --> 00:26:39,860
not dropping in 10 20 millions P record

00:26:36,890 --> 00:26:40,370
so we said okay we need to do it by

00:26:39,860 --> 00:26:43,280
ourselves

00:26:40,370 --> 00:26:44,690
nobody's doing it and stuff has also

00:26:43,280 --> 00:26:47,120
been stalled because we have not

00:26:44,690 --> 00:26:50,020
standardized the meter data area and

00:26:47,120 --> 00:26:53,180
stuff like that someone also do so but

00:26:50,020 --> 00:26:55,580
yeah so so you're running but without of

00:26:53,180 --> 00:26:57,080
three patches to make two to two tumors

00:26:55,580 --> 00:26:59,240
tonight demonstrate a point and I think

00:26:57,080 --> 00:27:02,000
the performance numbers to show that it

00:26:59,240 --> 00:27:04,760
it is valuable to skip the passing of

00:27:02,000 --> 00:27:06,700
the packets if the heart I can assist

00:27:04,760 --> 00:27:11,150
there is actually quite interesting

00:27:06,700 --> 00:27:13,130
performance wise yes there's some

00:27:11,150 --> 00:27:16,660
caveats on how to hold the setup is and

00:27:13,130 --> 00:27:16,660
but it's okay it's a proof of concept

00:27:17,440 --> 00:27:26,930
Thanks so think best line came out today

00:27:24,800 --> 00:27:30,230
what is that zero cause to drop how many

00:27:26,930 --> 00:27:35,660
pockets with zero cause you said how

00:27:30,230 --> 00:27:40,640
many who came up with that brownie like

00:27:35,660 --> 00:27:44,740
a new marketing so all the NIC vendors

00:27:40,640 --> 00:27:44,740
now gonna say zero cause to drop pockets

00:27:47,800 --> 00:27:53,360
exactly test for that but I know that we

00:27:51,290 --> 00:27:55,580
do have obvious offload and we've

00:27:53,360 --> 00:27:59,300
obvious with leaks plan forwarding the

00:27:55,580 --> 00:28:01,070
packets yeah we do 70 million people per

00:27:59,300 --> 00:28:04,270
second with zero cause I don't need the

00:28:01,070 --> 00:28:04,270
CPU anymore yeah

00:28:11,420 --> 00:28:15,859

YouTube URL: https://www.youtube.com/watch?v=IlNwhnmDdbA


