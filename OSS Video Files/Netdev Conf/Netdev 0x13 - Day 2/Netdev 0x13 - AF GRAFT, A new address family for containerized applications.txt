Title: Netdev 0x13 - AF GRAFT, A new address family for containerized applications
Publication date: 2019-05-25
Playlist: Netdev 0x13 - Day 2
Description: 
	Ryo Nakamura believes we can take container networking to a new level.

Why do we still need to use old-school virtual ports (think veth) for inter-container networking?
In this talk, Ryo introduces a new socket family, AF_GRAFT, for containers. Instead of the link between the host and container network stacks, AF_GRAFT provides a socket-layer interconnection between them.

https://netdevconf.org/0x13/session.html?talk-AF_GRAFT
Captions: 
	00:00:00,030 --> 00:00:08,130
Master I'm a camera from the University

00:00:05,609 --> 00:00:11,370
of Tokyo and maybe everyone does not

00:00:08,130 --> 00:00:13,799
does not know that I was organization

00:00:11,370 --> 00:00:16,049
committee member in the past on it

00:00:13,799 --> 00:00:18,240
they've one point three in the Tokyo but

00:00:16,049 --> 00:00:22,080
I couldn't attend the conference because

00:00:18,240 --> 00:00:26,160
it was three days before my PhD defense

00:00:22,080 --> 00:00:29,160
so I'm I'm very happy to be here and

00:00:26,160 --> 00:00:31,679
make a presentation so my talk is about

00:00:29,160 --> 00:00:34,559
aircraft it is the new address family

00:00:31,679 --> 00:00:36,870
for computerized application so a

00:00:34,559 --> 00:00:39,180
container is just an application

00:00:36,870 --> 00:00:41,460
execution environment as you know and

00:00:39,180 --> 00:00:44,040
the Microsoft architecture is a very

00:00:41,460 --> 00:00:46,890
popular enough to for today's implement

00:00:44,040 --> 00:00:50,730
very large information systems and in

00:00:46,890 --> 00:00:53,520
such principle very the monastic system

00:00:50,730 --> 00:00:56,699
is decomposed into the multiple services

00:00:53,520 --> 00:00:58,770
and our service is implemented in a

00:00:56,699 --> 00:01:02,309
container and the providers are

00:00:58,770 --> 00:01:05,460
container in such content Rastas control

00:01:02,309 --> 00:01:09,229
device at kubernetes and so this talk is

00:01:05,460 --> 00:01:13,799
about continent working so container is

00:01:09,229 --> 00:01:15,659
separated namespace in Linux host so we

00:01:13,799 --> 00:01:17,280
have to connect to our container the

00:01:15,659 --> 00:01:20,369
separated name space to the other

00:01:17,280 --> 00:01:22,920
containers or alternate works or the

00:01:20,369 --> 00:01:26,520
host network stack so we need to connect

00:01:22,920 --> 00:01:30,450
to connect the different instances so to

00:01:26,520 --> 00:01:35,220
Dedes very the conventional approach is

00:01:30,450 --> 00:01:37,380
to use adapters and rings abstraction so

00:01:35,220 --> 00:01:39,960
this abstraction is there derived from

00:01:37,380 --> 00:01:42,509
the fish power machines so fish car

00:01:39,960 --> 00:01:44,820
machine has adapted the network

00:01:42,509 --> 00:01:47,670
interface card and connected to the

00:01:44,820 --> 00:01:50,579
other alternate works for switch or it

00:01:47,670 --> 00:01:54,000
is using the rink the five hour UTP and

00:01:50,579 --> 00:01:56,759
so on so the for example the bottom was

00:01:54,000 --> 00:01:58,740
the environment this the battery washing

00:01:56,759 --> 00:02:01,020
network architecture is also using this

00:01:58,740 --> 00:02:03,810
abstraction the bottom machines has

00:02:01,020 --> 00:02:05,909
adapted the top interface about our

00:02:03,810 --> 00:02:07,770
interface and connected to the host

00:02:05,909 --> 00:02:10,410
network stack and host network stack

00:02:07,770 --> 00:02:13,160
performs the not worse each other and so

00:02:10,410 --> 00:02:15,230
on and in the contra Network Star

00:02:13,160 --> 00:02:17,750
Cantara Network stack architecture it is

00:02:15,230 --> 00:02:20,000
the same so container is the separated

00:02:17,750 --> 00:02:22,220
names are separated instance so the

00:02:20,000 --> 00:02:25,520
container has the adapter the brief type

00:02:22,220 --> 00:02:27,680
interface in usual so the container is

00:02:25,520 --> 00:02:30,500
connected to the host network stack so

00:02:27,680 --> 00:02:32,330
this is the similar way the same way in

00:02:30,500 --> 00:02:34,220
the fish current environment this is a

00:02:32,330 --> 00:02:37,340
very traditional obstruction to connect

00:02:34,220 --> 00:02:39,380
the different instances they are using

00:02:37,340 --> 00:02:42,440
the adapters and drinks so this is a

00:02:39,380 --> 00:02:44,900
conventional destruction so what we know

00:02:42,440 --> 00:02:47,090
there is overhead in the content current

00:02:44,900 --> 00:02:50,030
continent working using this abstraction

00:02:47,090 --> 00:02:53,840
so container involve containers involved

00:02:50,030 --> 00:02:56,900
but earnings and battery bridge like

00:02:53,840 --> 00:03:00,290
dokas 0 and not in the host Network

00:02:56,900 --> 00:03:03,320
stack then the fiber or the wire so we

00:03:00,290 --> 00:03:05,900
call this the long data path so from

00:03:03,320 --> 00:03:08,870
application to network interface card so

00:03:05,900 --> 00:03:11,570
the this peak this figure indicates the

00:03:08,870 --> 00:03:23,660
protocol stack in the network stack

00:03:11,570 --> 00:03:25,310
architecture the okay so the in the

00:03:23,660 --> 00:03:28,250
native parameter host the application

00:03:25,310 --> 00:03:31,220
writer data to the socket in the network

00:03:28,250 --> 00:03:33,950
stack processes the data and divided the

00:03:31,220 --> 00:03:36,950
data into the packet and there is there

00:03:33,950 --> 00:03:38,959
are the I pista ipiria on the ethernet

00:03:36,950 --> 00:03:41,540
layer then the data is transmitted to

00:03:38,959 --> 00:03:43,459
the wire but in the Kanto network stack

00:03:41,540 --> 00:03:45,830
architecture there that is very wrong

00:03:43,459 --> 00:03:48,110
from application technique so

00:03:45,830 --> 00:03:50,900
application write the data and there is

00:03:48,110 --> 00:03:52,450
the TCP UDP the layer for stock and IPS

00:03:50,900 --> 00:03:55,190
that we select stuck in the pocket

00:03:52,450 --> 00:03:57,170
transits are transmitted to the three so

00:03:55,190 --> 00:03:59,450
type interface and the host network

00:03:57,170 --> 00:04:03,620
stock received the packet and process it

00:03:59,450 --> 00:04:06,350
in the bridge and not to fall for the

00:04:03,620 --> 00:04:09,620
mask to for masquerade and then the

00:04:06,350 --> 00:04:11,840
sorry the looting and masquerade and the

00:04:09,620 --> 00:04:13,700
transmitted to the wire so that is a

00:04:11,840 --> 00:04:15,560
very hungry tapas and it causes the

00:04:13,700 --> 00:04:19,040
performance degradation as shown in

00:04:15,560 --> 00:04:22,039
these graphs so the in the our in our

00:04:19,040 --> 00:04:26,150
preliminary experiments the series PT

00:04:22,039 --> 00:04:27,120
degrades by the 50% to half and it

00:04:26,150 --> 00:04:30,150
increases

00:04:27,120 --> 00:04:34,800
also increases the latency by fifty

00:04:30,150 --> 00:04:36,870
fifty-five percent so this overhead is

00:04:34,800 --> 00:04:38,490
the well-known so there are some the

00:04:36,870 --> 00:04:42,690
state of that container networking

00:04:38,490 --> 00:04:46,260
technologies in the boss had said this

00:04:42,690 --> 00:04:47,520
community and research areas so the

00:04:46,260 --> 00:04:51,020
first one is the interface

00:04:47,520 --> 00:04:53,250
virtualization it so this approach is

00:04:51,020 --> 00:04:56,580
connecting the three

00:04:53,250 --> 00:04:58,650
this approach is how to say the attack

00:04:56,580 --> 00:05:00,660
attach the virtual network interface

00:04:58,650 --> 00:05:04,280
directory to the container like the

00:05:00,660 --> 00:05:07,110
maqbara interface OS r io v so but and

00:05:04,280 --> 00:05:09,330
another approach is the optimizing the

00:05:07,110 --> 00:05:12,180
network stack entire or part of network

00:05:09,330 --> 00:05:16,560
stack using such the net map or DP D K

00:05:12,180 --> 00:05:18,360
so the famous example is the free flow

00:05:16,560 --> 00:05:22,260
published by the Microsoft in the

00:05:18,360 --> 00:05:24,240
alternate and I may be rusty on SDI so

00:05:22,260 --> 00:05:26,669
the in the free throw a free flow

00:05:24,240 --> 00:05:29,370
incremental or up the network stack

00:05:26,669 --> 00:05:31,560
using the DP DK and our DMA and the

00:05:29,370 --> 00:05:34,830
stream is also a part of this approach

00:05:31,560 --> 00:05:38,669
so cm implement very fast the host

00:05:34,830 --> 00:05:41,010
network stack using the x DP so but both

00:05:38,669 --> 00:05:43,320
approaches have advantages and

00:05:41,010 --> 00:05:45,270
disadvantages in the interface

00:05:43,320 --> 00:05:47,490
virtualization the containers

00:05:45,270 --> 00:05:51,270
direct containers are directly exposed

00:05:47,490 --> 00:05:54,000
to the alter networks so that alternate

00:05:51,270 --> 00:05:56,220
works must manage is the IP address or

00:05:54,000 --> 00:05:59,130
port numbers or firewall and the Asia

00:05:56,220 --> 00:06:00,900
rules for continents so maybe it

00:05:59,130 --> 00:06:03,539
complicates the alternate work

00:06:00,900 --> 00:06:05,849
management and in optimize network stock

00:06:03,539 --> 00:06:10,110
approach so it is a feature away I think

00:06:05,849 --> 00:06:12,270
but it has also disadvantage because in

00:06:10,110 --> 00:06:14,880
optimize network stack approach the

00:06:12,270 --> 00:06:17,130
wrong data path does not disappear that

00:06:14,880 --> 00:06:20,340
means there are two network stack for

00:06:17,130 --> 00:06:23,190
containers and hosts so I think so they

00:06:20,340 --> 00:06:28,530
are the same the overhead from the

00:06:23,190 --> 00:06:31,770
architectural view so in our hats the

00:06:28,530 --> 00:06:33,720
industry so we advocate the sub approach

00:06:31,770 --> 00:06:37,620
the bypassing the container network

00:06:33,720 --> 00:06:40,960
stacks so I think about just a very

00:06:37,620 --> 00:06:43,090
simple container and in the in the micro

00:06:40,960 --> 00:06:45,280
architecture Princeville the container

00:06:43,090 --> 00:06:48,580
is just an application execution

00:06:45,280 --> 00:06:51,190
environment and maybe not interested in

00:06:48,580 --> 00:06:53,830
how pockets are there but then we think

00:06:51,190 --> 00:06:57,039
the containers the truck stock can be

00:06:53,830 --> 00:07:02,080
bypassed so let us consider a very

00:06:57,039 --> 00:07:04,900
simple example so let us consider our it

00:07:02,080 --> 00:07:09,970
consider very simple HTTP server or

00:07:04,900 --> 00:07:14,949
content so the user client like you are

00:07:09,970 --> 00:07:19,360
up tops the browser center get request

00:07:14,949 --> 00:07:22,509
or TCP request to the to the global IP

00:07:19,360 --> 00:07:25,060
address so this global IP addresses are

00:07:22,509 --> 00:07:27,039
trying to to the host Network stack then

00:07:25,060 --> 00:07:29,770
this packet is the knotted and

00:07:27,039 --> 00:07:32,889
transmitted to the container network

00:07:29,770 --> 00:07:35,320
stack series the visa interface and if

00:07:32,889 --> 00:07:36,970
the content does not contain as the

00:07:35,320 --> 00:07:39,340
container does not have the network

00:07:36,970 --> 00:07:41,830
stack that means the container is the

00:07:39,340 --> 00:08:03,430
host network stack directory the user

00:07:41,830 --> 00:08:08,099
can use a cry and send us the after is

00:08:03,430 --> 00:08:08,099
that so pretty there it's no difference

00:08:15,930 --> 00:08:23,169
the cry and user cry and send the same

00:08:20,169 --> 00:08:24,520
the identical data in both cases so

00:08:23,169 --> 00:08:27,520
there is no difference from the data

00:08:24,520 --> 00:08:29,680
communication perspective so this is the

00:08:27,520 --> 00:08:32,200
reason we had advocated the containers

00:08:29,680 --> 00:08:33,520
network stack can be bypassed so a

00:08:32,200 --> 00:08:36,070
container is just an application

00:08:33,520 --> 00:08:39,610
execution environment and applications

00:08:36,070 --> 00:08:41,770
in the containers are insensitive to the

00:08:39,610 --> 00:08:43,899
network how pockets are there but then

00:08:41,770 --> 00:08:46,810
we can bypass the control network stacks

00:08:43,899 --> 00:08:50,199
but the network stack separation should

00:08:46,810 --> 00:08:52,959
be retained because so docker has the

00:08:50,199 --> 00:08:54,910
option to share the host network stack

00:08:52,959 --> 00:08:57,520
of these containers but in this case

00:08:54,910 --> 00:08:59,500
come try uses there are arbitrary the

00:08:57,520 --> 00:09:01,990
network resources like IP address or

00:08:59,500 --> 00:09:06,310
port numbers or the host network stock

00:09:01,990 --> 00:09:09,550
so it can lead the marshals or intended

00:09:06,310 --> 00:09:12,810
use so we think network stocks should be

00:09:09,550 --> 00:09:14,980
separated but so to do this the

00:09:12,810 --> 00:09:18,670
separating the network stock and by the

00:09:14,980 --> 00:09:23,680
same container network stock to so to do

00:09:18,670 --> 00:09:26,320
this so we need a new mechanism so here

00:09:23,680 --> 00:09:28,360
are three so connecting the application

00:09:26,320 --> 00:09:31,660
or a container to the hostile stock with

00:09:28,360 --> 00:09:34,540
the proper access control to prevent the

00:09:31,660 --> 00:09:38,170
such partial uses so this mechanism

00:09:34,540 --> 00:09:40,600
should be they are the boundary between

00:09:38,170 --> 00:09:45,790
the container and the host so we know

00:09:40,600 --> 00:09:49,450
there is the scott reil so our approach

00:09:45,790 --> 00:09:51,610
is a circuit crafting so it graphs the

00:09:49,450 --> 00:09:54,790
socket in the containers until the

00:09:51,610 --> 00:09:58,510
sockets in the host network stock so

00:09:54,790 --> 00:10:00,910
this this picture illustrates the data

00:09:58,510 --> 00:10:03,070
path of the socket grafting application

00:10:00,910 --> 00:10:04,930
send data to the socket area by the

00:10:03,070 --> 00:10:07,150
socket circuit related system course

00:10:04,930 --> 00:10:09,430
then the data is transferred to the

00:10:07,150 --> 00:10:11,620
socket area in the host network stack

00:10:09,430 --> 00:10:15,610
then the processed by the host network

00:10:11,620 --> 00:10:18,040
stock so there is one network stack so

00:10:15,610 --> 00:10:19,990
there is no overhead due to the

00:10:18,040 --> 00:10:24,940
continuous that container network stack

00:10:19,990 --> 00:10:28,060
architecture so it has two advantage the

00:10:24,940 --> 00:10:30,940
one is there is just one network stack

00:10:28,060 --> 00:10:33,670
so it can mitigate the overhead due to

00:10:30,940 --> 00:10:38,080
the continent working and another one is

00:10:33,670 --> 00:10:40,000
this approach is the just enhancement on

00:10:38,080 --> 00:10:41,650
the circuitry and this is the date

00:10:40,000 --> 00:10:44,620
communication channel design in the

00:10:41,650 --> 00:10:47,890
socket area so it is implemented from

00:10:44,620 --> 00:10:51,040
the the network stack implementation so

00:10:47,890 --> 00:10:52,900
it can be applied to the current very

00:10:51,040 --> 00:10:55,840
muttered Linux network socket

00:10:52,900 --> 00:10:58,000
representation and if the future in the

00:10:55,840 --> 00:11:01,380
future the network stack will be

00:10:58,000 --> 00:11:03,940
implemented through scratch then the

00:11:01,380 --> 00:11:07,810
grafting approach can be applied we

00:11:03,940 --> 00:11:08,750
think so this is the approach and next

00:11:07,810 --> 00:11:13,310
is the concrete

00:11:08,750 --> 00:11:15,590
mechanism so we implemented a circuit

00:11:13,310 --> 00:11:19,070
grafting as a new address family

00:11:15,590 --> 00:11:22,310
korto aircraft so applications in

00:11:19,070 --> 00:11:25,040
containers create F grafter sockets then

00:11:22,310 --> 00:11:27,770
the aircraft sockets grafted onto the

00:11:25,040 --> 00:11:30,590
other address family socket in the host

00:11:27,770 --> 00:11:33,020
Network stack so the application in the

00:11:30,590 --> 00:11:35,930
container write the data using the

00:11:33,020 --> 00:11:40,490
writer system core then the data is also

00:11:35,930 --> 00:11:42,800
written into the host address our other

00:11:40,490 --> 00:11:47,300
others family socket in the host Network

00:11:42,800 --> 00:11:53,050
stack so this is the grafting between

00:11:47,300 --> 00:11:56,420
the sockets great simple I think so the

00:11:53,050 --> 00:11:58,670
two grafting the socket from to the

00:11:56,420 --> 00:12:01,640
other socket we need to specify the

00:11:58,670 --> 00:12:04,880
which aircraft sockets should be grafted

00:12:01,640 --> 00:12:08,000
onto which other F sockets so to do this

00:12:04,880 --> 00:12:12,980
we use the binder system core semantics

00:12:08,000 --> 00:12:15,890
so the front mom page of the bind so the

00:12:12,980 --> 00:12:19,070
best the original operation not buying

00:12:15,890 --> 00:12:22,250
the ease of finding the names to socket

00:12:19,070 --> 00:12:27,230
so F crafty is a new address family so

00:12:22,250 --> 00:12:29,660
if craft also has its the new name for

00:12:27,230 --> 00:12:32,630
the bind so it is the graft in the point

00:12:29,660 --> 00:12:34,820
so if grafted in the point is identified

00:12:32,630 --> 00:12:37,190
bra by after is drink and

00:12:34,820 --> 00:12:40,640
AF craft corner moves even manages the

00:12:37,190 --> 00:12:44,180
mapping between the F graft end point

00:12:40,640 --> 00:12:47,990
and other address family end point so in

00:12:44,180 --> 00:12:50,420
fi in it the end point means ipv4

00:12:47,990 --> 00:12:53,720
address and the port number and I a

00:12:50,420 --> 00:12:56,540
finite six the end point is ipv6 address

00:12:53,720 --> 00:12:59,870
and the port number so for example the

00:12:56,540 --> 00:13:03,650
EP - HTTP the graft endpoint is grafted

00:12:59,870 --> 00:13:07,580
onto the host and the point 10 - 2 0 to

00:13:03,650 --> 00:13:10,940
0 to 1 and port 80 like that so and F

00:13:07,580 --> 00:13:14,210
craft manages these mappings in the

00:13:10,940 --> 00:13:17,959
power network namespace so in this

00:13:14,210 --> 00:13:21,020
example the container one has only

00:13:17,959 --> 00:13:22,520
EP HTTP F graph the end point so that

00:13:21,020 --> 00:13:25,279
container 1

00:13:22,520 --> 00:13:28,130
can use only the EP HTTP graphed

00:13:25,279 --> 00:13:31,070
endpoint so that means it can prevent

00:13:28,130 --> 00:13:36,880
such Marshall so I intended use of the

00:13:31,070 --> 00:13:41,420
host Network stock resources so this is

00:13:36,880 --> 00:13:45,260
sorry this is the aircraft so KPI so to

00:13:41,420 --> 00:13:47,870
describe the new name for the bind we

00:13:45,260 --> 00:13:51,260
introduced a new socket socket other

00:13:47,870 --> 00:13:54,560
structure so called gr it contains the

00:13:51,260 --> 00:13:57,410
just Canaris a family key key for

00:13:54,560 --> 00:14:00,920
identifying the family and I just string

00:13:57,410 --> 00:14:04,070
for the graft and the point name and to

00:14:00,920 --> 00:14:07,700
use the to create the F graph to socket

00:14:04,070 --> 00:14:10,310
it is very we use the familiar the

00:14:07,700 --> 00:14:12,830
socket API you can create the F graft

00:14:10,310 --> 00:14:15,860
socket using the socket system core F

00:14:12,830 --> 00:14:18,830
grafts extreme IP participe with 0 YP

00:14:15,860 --> 00:14:21,320
per TDP and so on and then you can call

00:14:18,830 --> 00:14:25,910
the pine system core to the F graph to

00:14:21,320 --> 00:14:28,720
socket using tsukada gr then the the

00:14:25,910 --> 00:14:32,480
aircraft socket is the grafted onto the

00:14:28,720 --> 00:14:35,029
the host and appointed host to end point

00:14:32,480 --> 00:14:38,690
associated with the graph the end point

00:14:35,029 --> 00:14:42,620
by the mapping table so this example

00:14:38,690 --> 00:14:45,440
shows the socket for the server side the

00:14:42,620 --> 00:14:47,329
application and of course aircraft can

00:14:45,440 --> 00:14:50,060
be used for the outbound connections

00:14:47,329 --> 00:14:55,220
right cry and side socket so it is easy

00:14:50,060 --> 00:14:57,200
because cryin circuit just uses the hot

00:14:55,220 --> 00:15:00,770
side my familiar report the random port

00:14:57,200 --> 00:15:04,310
number for the salsa sauce in point so F

00:15:00,770 --> 00:15:08,300
crafts supposed that such the dynamic

00:15:04,310 --> 00:15:13,220
port use so that you can you can call

00:15:08,300 --> 00:15:15,470
the you can create F graft socket using

00:15:13,220 --> 00:15:18,980
F Krauts extremely pro TCP for the

00:15:15,470 --> 00:15:22,160
current circuit then the cord bind to to

00:15:18,980 --> 00:15:24,709
craft and you can call connect to this

00:15:22,160 --> 00:15:28,270
socket then you can use the the aircraft

00:15:24,709 --> 00:15:32,390
socket as usual the TCP cry and socket

00:15:28,270 --> 00:15:34,370
so we implemented F graft as a single

00:15:32,390 --> 00:15:35,699
column user at it is available on the

00:15:34,370 --> 00:15:39,480
github

00:15:35,699 --> 00:15:42,949
and so the important point one input

00:15:39,480 --> 00:15:45,389
unimportant thing is the the grafting is

00:15:42,949 --> 00:15:47,339
implemented as a function core

00:15:45,389 --> 00:15:49,919
there's no messaging or queuing or

00:15:47,339 --> 00:15:53,939
buffering that means it is very minimal

00:15:49,919 --> 00:15:56,669
the overhead actually so the hots a the

00:15:53,939 --> 00:15:58,919
implementation of the send message of F

00:15:56,669 --> 00:16:03,499
graft socket just course the

00:15:58,919 --> 00:16:07,439
implementation of the host of socket so

00:16:03,499 --> 00:16:09,259
yeah and to manage the aircraft and the

00:16:07,439 --> 00:16:12,209
host end point mapping carries I

00:16:09,259 --> 00:16:13,919
modified the IP route tree so you can

00:16:12,209 --> 00:16:16,679
the configure the mapping table using

00:16:13,919 --> 00:16:19,889
the IP graft at EP and type IP beyond

00:16:16,679 --> 00:16:24,899
other and so like the IP loot at Ojai

00:16:19,889 --> 00:16:26,850
Peru today so we evaluated the

00:16:24,899 --> 00:16:29,429
performance improvement using the two

00:16:26,850 --> 00:16:29,790
hosts connected pier 40 gigabit base

00:16:29,429 --> 00:16:34,799
link

00:16:29,790 --> 00:16:37,410
and so we compare the F graft with the

00:16:34,799 --> 00:16:39,389
native host performance and took a zero

00:16:37,410 --> 00:16:41,309
that means that not that they fort not

00:16:39,389 --> 00:16:44,939
continent at their fault continue

00:16:41,309 --> 00:16:48,509
talking so this is strips to test result

00:16:44,939 --> 00:16:52,019
so as you can see the F graft succeed

00:16:48,509 --> 00:16:54,569
free mitigate the degradation due to the

00:16:52,019 --> 00:16:56,819
the long data paths involving the to you

00:16:54,569 --> 00:16:59,339
network stacks in container and host

00:16:56,819 --> 00:17:03,299
network stack so if graft is performance

00:16:59,339 --> 00:17:06,750
is comparable with the host native host

00:17:03,299 --> 00:17:09,389
performance and in latency perspective

00:17:06,750 --> 00:17:12,389
it is the same they have craft also

00:17:09,389 --> 00:17:15,289
mitigate degradation from the latency

00:17:12,389 --> 00:17:18,839
and more variation results about the

00:17:15,289 --> 00:17:21,839
endings the HTTP benchmark and the rim

00:17:18,839 --> 00:17:24,240
Cuban team Acorah be Rwanda I by the

00:17:21,839 --> 00:17:28,679
research paper published by the ACM and

00:17:24,240 --> 00:17:31,289
it is all passes so this is the the has

00:17:28,679 --> 00:17:35,130
the introduction of aircraft and in this

00:17:31,289 --> 00:17:37,799
talk I want I'd like to demonstrate the

00:17:35,130 --> 00:17:40,549
aircraft using some product card series

00:17:37,799 --> 00:17:43,889
so aircraft is a new address family so

00:17:40,549 --> 00:17:48,490
existing applications cannot use the

00:17:43,889 --> 00:17:50,920
aircraft without the modifications so it

00:17:48,490 --> 00:17:55,270
maybe the modifying the existing

00:17:50,920 --> 00:17:58,570
application source code is not so does

00:17:55,270 --> 00:18:01,300
not require a significant effort because

00:17:58,570 --> 00:18:04,360
of the very similar very familiar I look

00:18:01,300 --> 00:18:06,640
at the API but it is we know it is

00:18:04,360 --> 00:18:11,520
sometimes very hard to maintain the out

00:18:06,640 --> 00:18:15,040
of tree source code so we develop the

00:18:11,520 --> 00:18:18,430
shared library using the LDP roadie live

00:18:15,040 --> 00:18:20,380
graft combat duty so it is a hijacking

00:18:18,430 --> 00:18:25,360
library using the LDP rose

00:18:20,380 --> 00:18:28,120
so this rivalry overrides the system

00:18:25,360 --> 00:18:31,780
socket created system course and then

00:18:28,120 --> 00:18:37,720
convert F depend the operations into the

00:18:31,780 --> 00:18:40,540
aircraft capable ones so so the rig deep

00:18:37,720 --> 00:18:43,990
grass come back to the soviet EP wrote

00:18:40,540 --> 00:18:46,240
over eyes socket system course and it

00:18:43,990 --> 00:18:48,520
returns the f graph to sock it instead

00:18:46,240 --> 00:18:52,450
of the a finite y56

00:18:48,520 --> 00:18:56,530
and it this Ribery also over eyes a

00:18:52,450 --> 00:18:59,800
binary system call so to combat tsukada

00:18:56,530 --> 00:19:02,620
in or in ticks into the Socata gr for

00:18:59,800 --> 00:19:05,490
graph ten points and also and connect

00:19:02,620 --> 00:19:10,000
sense seems to understand message or hi

00:19:05,490 --> 00:19:11,920
hijacked so as as you know the subscribe

00:19:10,000 --> 00:19:15,400
socket does not require a binder system

00:19:11,920 --> 00:19:17,650
cover to use but f draft if graph the

00:19:15,400 --> 00:19:21,820
socket require bind the two daytime in

00:19:17,650 --> 00:19:25,470
the host endpoint so P is the so too

00:19:21,820 --> 00:19:29,290
sweet so to combat such the cry and

00:19:25,470 --> 00:19:31,830
socket source code such application the

00:19:29,290 --> 00:19:34,510
in today if craft capable one is the

00:19:31,830 --> 00:19:37,810
technique called bind before connect

00:19:34,510 --> 00:19:42,580
that at the time is the source end point

00:19:37,810 --> 00:19:46,750
for the connect so and this so you can

00:19:42,580 --> 00:19:48,430
configure which the grab which if I need

00:19:46,750 --> 00:19:51,160
to I did six and the point should be

00:19:48,430 --> 00:19:56,080
converted in should be converted into

00:19:51,160 --> 00:19:59,850
which the F perhaps in the point you can

00:19:56,080 --> 00:20:02,140
use some the two environmental variables

00:19:59,850 --> 00:20:06,820
for example in this

00:20:02,140 --> 00:20:08,380
the application tried to bind to 0.02 to

00:20:06,820 --> 00:20:12,580
zero quorum a key

00:20:08,380 --> 00:20:15,670
Ecore then live graph to hijack combat

00:20:12,580 --> 00:20:21,790
that this oka dying into the cicadas gr

00:20:15,670 --> 00:20:23,880
with EP - HTTP so the so let me

00:20:21,790 --> 00:20:23,880
demonstrate

00:20:37,279 --> 00:20:46,639
okay this I have this just event the

00:20:43,049 --> 00:20:50,639
latest 80s release and IP blocked then

00:20:46,639 --> 00:20:56,809
this is the usage of IP craft then so

00:20:50,639 --> 00:21:01,860
the surest create IP net NS art test

00:20:56,809 --> 00:21:08,249
then the pseudo IP net to an acoustic

00:21:01,860 --> 00:21:11,940
retest o IP graph to adopt a name IP

00:21:08,249 --> 00:21:17,480
test type IP before for example

00:21:11,940 --> 00:21:17,480
luboc and port 8080 oops

00:21:19,789 --> 00:21:35,429
r3 I've got other okay then the net in a

00:21:25,830 --> 00:21:41,509
physics test IP craft show in the in the

00:21:35,429 --> 00:21:41,509
retinas ah okay

00:21:43,390 --> 00:21:48,710
so that good point are so the host

00:21:46,700 --> 00:21:54,700
Network stock hosta or reading Terrace

00:21:48,710 --> 00:22:03,860
on the interfaces but in the net anus

00:21:54,700 --> 00:22:11,450
there is only the POC interface so sorry

00:22:03,860 --> 00:22:13,370
to repeat the question so if I have an

00:22:11,450 --> 00:22:15,290
application that is doing IP packet in

00:22:13,370 --> 00:22:18,290
for bind to I have what is it going to

00:22:15,290 --> 00:22:20,480
do I need so basic more fundamental

00:22:18,290 --> 00:22:23,270
question a network is usually four

00:22:20,480 --> 00:22:25,340
things it is interfaces addresses routes

00:22:23,270 --> 00:22:27,290
and solids you only talked about

00:22:25,340 --> 00:22:29,030
stockist you've talked about mapping

00:22:27,290 --> 00:22:32,630
addresses to a namespace which is

00:22:29,030 --> 00:22:33,980
finally inside your container you no

00:22:32,630 --> 00:22:35,780
longer see routes and you no longer see

00:22:33,980 --> 00:22:37,190
interfaces so all the socket API eyes

00:22:35,780 --> 00:22:43,130
that need those what are they going to

00:22:37,190 --> 00:22:47,840
do okay so I think his message I'm

00:22:43,130 --> 00:22:49,460
trying to answer for him because he you

00:22:47,840 --> 00:22:52,400
want a new way of doing networking right

00:22:49,460 --> 00:22:53,090
it's you don't care about interfaces am

00:22:52,400 --> 00:22:55,430
I correct

00:22:53,090 --> 00:22:57,560
yes so the applications in container

00:22:55,430 --> 00:23:04,040
does not care that the such had say the

00:22:57,560 --> 00:23:06,140
interface and with us so I think I think

00:23:04,040 --> 00:23:08,600
I think the high-order question here is

00:23:06,140 --> 00:23:11,360
this site if you are using a socket in

00:23:08,600 --> 00:23:14,000
any environment it has to know things

00:23:11,360 --> 00:23:16,130
like am I going to collide on ports am i

00:23:14,000 --> 00:23:18,680
picking the right routing to pick an

00:23:16,130 --> 00:23:24,230
interface can I listen on this can i

00:23:18,680 --> 00:23:27,500
bind to an any caste IP so how the

00:23:24,230 --> 00:23:29,960
because interfaces are hidden yeah the

00:23:27,500 --> 00:23:32,210
application cannot unilaterally decide

00:23:29,960 --> 00:23:35,690
how to make those decisions if it used

00:23:32,210 --> 00:23:40,220
to make those decisions so it is yeah I

00:23:35,690 --> 00:23:44,450
think it is depends on the use case so I

00:23:40,220 --> 00:23:46,550
think so in kubernetes the applications

00:23:44,450 --> 00:23:49,070
doesn't actually doesn't care

00:23:46,550 --> 00:23:52,580
substitute actual IP addresses because

00:23:49,070 --> 00:23:55,960
the sub crossed IP abstract or hidden

00:23:52,580 --> 00:24:04,760
the detail of the networks

00:23:55,960 --> 00:24:06,200
supplications does not care the such so

00:24:04,760 --> 00:24:08,960
it's for a subset of applications it's

00:24:06,200 --> 00:24:19,250
not for everybody it's for a specific

00:24:08,960 --> 00:24:21,409
use case ok so I think I think the point

00:24:19,250 --> 00:24:24,260
here and maybe this is an ongoing work

00:24:21,409 --> 00:24:26,179
slide there is a I think there's a

00:24:24,260 --> 00:24:27,980
control plane that's missing that's

00:24:26,179 --> 00:24:29,890
outside right there is something else

00:24:27,980 --> 00:24:32,539
that needs to come in and say you

00:24:29,890 --> 00:24:34,730
application are special you can only

00:24:32,539 --> 00:24:37,340
bind to these things you can only see

00:24:34,730 --> 00:24:39,260
these four five routes and you can use

00:24:37,340 --> 00:24:43,010
AF graft and get the direct connection

00:24:39,260 --> 00:24:44,630
but if you say that a generic networking

00:24:43,010 --> 00:24:46,640
application running inside a container

00:24:44,630 --> 00:24:48,649
should be able to do all of its things

00:24:46,640 --> 00:24:50,390
it won't work so there's one component

00:24:48,649 --> 00:24:54,710
somewhere that's missing that is going

00:24:50,390 --> 00:24:58,279
to do synchronization yep so after

00:24:54,710 --> 00:25:00,230
that's right mention mentions but so as

00:24:58,279 --> 00:25:02,570
you again as you say the network

00:25:00,230 --> 00:25:06,320
sensitive applications doesn't work on

00:25:02,570 --> 00:25:09,020
such the container yes that is the

00:25:06,320 --> 00:25:13,970
limitation we're kind of running out of

00:25:09,020 --> 00:25:16,820
time so yes please so as you say they

00:25:13,970 --> 00:25:18,559
are so but on one slide you were

00:25:16,820 --> 00:25:20,600
actually shown that you are using LD

00:25:18,559 --> 00:25:22,820
preload to load a library which would

00:25:20,600 --> 00:25:24,740
then be applying those you know

00:25:22,820 --> 00:25:27,380
heuristics to all application and not

00:25:24,740 --> 00:25:29,500
just selectively some applications so

00:25:27,380 --> 00:25:32,330
are you expecting that long term

00:25:29,500 --> 00:25:35,330
individual applications that run only in

00:25:32,330 --> 00:25:37,640
a container would be converted to use AF

00:25:35,330 --> 00:25:40,970
graph natively or would you be looking

00:25:37,640 --> 00:25:44,390
into some kernel other user space level

00:25:40,970 --> 00:25:46,429
like converter inside the container that

00:25:44,390 --> 00:25:50,210
would be taking care of that the idea

00:25:46,429 --> 00:25:53,870
case is if the application suppose the F

00:25:50,210 --> 00:25:55,730
growth maybe is the idea our case and so

00:25:53,870 --> 00:26:00,230
this LDP road-based of toric

00:25:55,730 --> 00:26:02,419
is just a hard to say transition so that

00:26:00,230 --> 00:26:06,369
is the warp around for the current

00:26:02,419 --> 00:26:08,859
applications so are you expecting that

00:26:06,369 --> 00:26:11,889
open-source applications detect whether

00:26:08,859 --> 00:26:13,779
they are running in an AF capable

00:26:11,889 --> 00:26:15,820
aircraft capable container and then

00:26:13,779 --> 00:26:18,389
switch between different address

00:26:15,820 --> 00:26:20,619
families or how do you expect that to

00:26:18,389 --> 00:26:23,769
you know to be done with regards to the

00:26:20,619 --> 00:26:29,289
anticipations the best way is I think

00:26:23,769 --> 00:26:32,409
the applications code will be if the

00:26:29,289 --> 00:26:34,899
independent source code in F independent

00:26:32,409 --> 00:26:50,529
code and then the get other info suppose

00:26:34,899 --> 00:26:55,239
the aircraft the end okay have you

00:26:50,529 --> 00:26:58,509
considered to use namespace isolation

00:26:55,239 --> 00:27:01,809
for the socket interface sorry what

00:26:58,509 --> 00:27:04,359
interface the namespaces in the kernel

00:27:01,809 --> 00:27:08,169
because this is what you actually

00:27:04,359 --> 00:27:11,559
achieve isolation of different

00:27:08,169 --> 00:27:14,200
containers into their own space ah so

00:27:11,559 --> 00:27:16,929
eventually the namespaces could be the

00:27:14,200 --> 00:27:22,289
isolation layer for the socket interface

00:27:16,929 --> 00:27:29,019
have you considered this not yet okay

00:27:22,289 --> 00:27:33,700
all right oh oh you after okay let him

00:27:29,019 --> 00:27:35,259
finish you stay focus yeah that that

00:27:33,700 --> 00:27:37,269
means you have an exciting talk right

00:27:35,259 --> 00:27:41,429
look at everybody knows what they found

00:27:37,269 --> 00:27:45,039
some so in this country has only one the

00:27:41,429 --> 00:27:49,359
graft in the point without looting

00:27:45,039 --> 00:27:51,879
Terran trees and interfaces and then so

00:27:49,359 --> 00:27:55,989
the this craft command is just a wrapper

00:27:51,879 --> 00:28:03,509
to set up the library for LTP rot so my

00:27:55,989 --> 00:28:09,940
zero zero zero zero sorry

00:28:03,509 --> 00:28:14,679
then this means that or the bind for the

00:28:09,940 --> 00:28:17,770
in this range is combated F craft Secada

00:28:14,679 --> 00:28:23,080
gr so ap HTTP then okay

00:28:17,770 --> 00:28:25,020
started Ipath three as a server we are

00:28:23,080 --> 00:28:46,210
sorry

00:28:25,020 --> 00:28:48,880
hahaha sorry ah ah sorry pee test good

00:28:46,210 --> 00:28:51,370
deer hunting okay then this I passed

00:28:48,880 --> 00:28:54,310
three processes reasoning on the EP -

00:28:51,370 --> 00:28:57,220
test craft and point without the

00:28:54,310 --> 00:28:58,750
interfaces and routing table entries so

00:28:57,220 --> 00:29:07,510
this is a socket area communication

00:28:58,750 --> 00:29:11,980
channel so in host network stack so

00:29:07,510 --> 00:29:21,420
there is a listen listening process so

00:29:11,980 --> 00:29:21,420
then we can use the eye path to the 8080

00:29:30,990 --> 00:29:43,559
I people are taught to eat P distal to

00:29:39,000 --> 00:29:46,700
the type IP before other up one both

00:29:43,559 --> 00:29:46,700
smaller 81

00:29:58,280 --> 00:30:09,980
yeah this sucks

00:30:11,450 --> 00:30:44,690
[Applause]

00:30:17,420 --> 00:30:44,690
okay okay maybe it will be successful

00:30:50,030 --> 00:30:53,240
thank you

00:30:53,450 --> 00:30:59,480
so then we can the new communication

00:30:57,000 --> 00:31:02,540
channel between the continents or

00:30:59,480 --> 00:31:07,650
between the network name spaces without

00:31:02,540 --> 00:31:13,890
interfaces so sorry why I spent a very

00:31:07,650 --> 00:31:15,600
long long time so and I have the another

00:31:13,890 --> 00:31:17,520
demonstration using the dhaka

00:31:15,600 --> 00:31:22,670
integration but maybe I spend too much

00:31:17,520 --> 00:31:27,090
time so sorry okay

00:31:22,670 --> 00:31:29,190
and also as you say every rafter has

00:31:27,090 --> 00:31:32,220
some many limitations

00:31:29,190 --> 00:31:34,170
so if first aircraft does not improve

00:31:32,220 --> 00:31:35,880
the network stock performance itself

00:31:34,170 --> 00:31:39,780
because it's just a data communication

00:31:35,880 --> 00:31:41,670
channel design so and if craft assumes

00:31:39,780 --> 00:31:43,830
that the application is insensitive to

00:31:41,670 --> 00:31:45,750
the network stack that means the how

00:31:43,830 --> 00:31:48,390
pocket or the report so if the

00:31:45,750 --> 00:31:52,110
application focusing on such pocket

00:31:48,390 --> 00:31:55,500
rendering like the NFPA continuously it

00:31:52,110 --> 00:31:58,380
cannot work with AF craft so and also

00:31:55,500 --> 00:32:00,150
you can say the LDP rhetoric is just

00:31:58,380 --> 00:32:03,150
walk around for the existing

00:32:00,150 --> 00:32:05,760
applications as is so the LDP road is

00:32:03,150 --> 00:32:09,120
not always applicable today any

00:32:05,760 --> 00:32:11,910
applications so for example the go rank

00:32:09,120 --> 00:32:14,610
doesn't use the BBC so it cannot be

00:32:11,910 --> 00:32:17,190
hijacked so the conclusion I introduced

00:32:14,610 --> 00:32:19,710
the circuit grafting and F graft has

00:32:17,190 --> 00:32:21,480
implemented concrete implementation so

00:32:19,710 --> 00:32:26,130
and the comment and suggestions are

00:32:21,480 --> 00:32:29,400
welcome but all ready to mate so and I'm

00:32:26,130 --> 00:32:31,260
I'm finding a good way to integrate this

00:32:29,400 --> 00:32:38,000
F craft mechanism into the country are

00:32:31,260 --> 00:32:40,559
platforms thank you very much thank you

00:32:38,000 --> 00:32:43,140
okay this is actually quite exciting I

00:32:40,559 --> 00:32:45,480
think you ran into a port collision

00:32:43,140 --> 00:32:47,460
issue this is so there are some real

00:32:45,480 --> 00:32:49,110
problems to solve with respect to the

00:32:47,460 --> 00:32:52,970
hosts but this is very exciting because

00:32:49,110 --> 00:32:56,760
it's very useful and thank you very much

00:32:52,970 --> 00:32:59,670
the next so I do still need to get rid

00:32:56,760 --> 00:33:03,059
of one question which is do you know

00:32:59,670 --> 00:33:05,550
what SCM underscore rights is do you

00:33:03,059 --> 00:33:09,179
know what SCM underscore Rights is on a

00:33:05,550 --> 00:33:11,400
UNIX socket have you ever heard of that

00:33:09,179 --> 00:33:12,980
has who here in the room knows what that

00:33:11,400 --> 00:33:15,900
is can you please raise your hand

00:33:12,980 --> 00:33:18,030
that is way less than I expected because

00:33:15,900 --> 00:33:20,760
what you just described is perfectly why

00:33:18,030 --> 00:33:22,230
it will already by user space you don't

00:33:20,760 --> 00:33:23,910
need a new address family you don't need

00:33:22,230 --> 00:33:35,960
anything you just need to appropriate

00:33:23,910 --> 00:33:35,960

YouTube URL: https://www.youtube.com/watch?v=Sd86uwvkHak


