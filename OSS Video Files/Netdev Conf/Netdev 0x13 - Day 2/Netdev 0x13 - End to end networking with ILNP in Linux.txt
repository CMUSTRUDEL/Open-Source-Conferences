Title: Netdev 0x13 - End to end networking with ILNP in Linux
Publication date: 2019-05-25
Playlist: Netdev 0x13 - Day 2
Description: 
	Saleem Bhatti talks about ILNP on Linux.
The Identifier-Locator Network Protocol (ILNP) is defined as an Experimental Internet
Protocol by the Internet Research Task Force (IRTF) in RFCs 6740-6748.
At the heart of the ILNP architecture is the desire to address the deprecation of IP addresses. ILNP replaces IP address semantics with use of node Identifiers and network Locators using IPv6. No application changes needed.
Current kernel implementation is on top of 4.19. Ryo and Saleem plan to upgrade to a newer kernel and push upstream. In this talk Saleem describes the ILNP architecture, the kernel implementation of ILNP and include results of testbed experiments for IP-level mobility.

More info:
https://www.netdevconf.org/0x13/session.html?talk-ilnp
Captions: 
	00:00:00,000 --> 00:00:03,030
okay everyone I'm not sure if there's a

00:00:01,589 --> 00:00:05,970
session chair or not so we'll just make

00:00:03,030 --> 00:00:09,630
a start good morning my name's Celine

00:00:05,970 --> 00:00:12,240
and I'm here with Rio who's been working

00:00:09,630 --> 00:00:14,730
with me doing a PhD on this strange

00:00:12,240 --> 00:00:19,289
thing called Ireland PFI locator network

00:00:14,730 --> 00:00:21,900
protocol so we are both net dev newbies

00:00:19,289 --> 00:00:23,580
so please be gentle with us but we're

00:00:21,900 --> 00:00:27,480
actually after two reasons one is to

00:00:23,580 --> 00:00:32,189
explain to you about what Ireland PS but

00:00:27,480 --> 00:00:34,620
also to get any advice and help you can

00:00:32,189 --> 00:00:38,129
offer on how we can make this available

00:00:34,620 --> 00:00:41,370
to the community because it's quite a

00:00:38,129 --> 00:00:43,500
major change to how networking might be

00:00:41,370 --> 00:00:46,379
done with respect to how addressing is

00:00:43,500 --> 00:00:49,379
used today we're also very grateful to

00:00:46,379 --> 00:00:50,820
our store who have sponsored us and made

00:00:49,379 --> 00:00:52,680
it possible for us to attend here and

00:00:50,820 --> 00:00:55,710
we're going to have a demo of the

00:00:52,680 --> 00:00:59,629
codebase working later on today in the

00:00:55,710 --> 00:01:01,920
bits nibbles bikes and word session and

00:00:59,629 --> 00:01:03,690
that is the code base that we're going

00:01:01,920 --> 00:01:06,930
to be releasing in a few weeks time as

00:01:03,690 --> 00:01:08,189
well that you'll see in action so just

00:01:06,930 --> 00:01:10,229
an outline of what we're going to cover

00:01:08,189 --> 00:01:12,750
today so why Ireland pea what's it all

00:01:10,229 --> 00:01:15,060
about the core concepts of Ireland pea

00:01:12,750 --> 00:01:17,790
which are changed the way addressing and

00:01:15,060 --> 00:01:19,770
naming is done and then Rios going to

00:01:17,790 --> 00:01:22,409
walk you through how we've implemented

00:01:19,770 --> 00:01:25,259
this new architectural approach

00:01:22,409 --> 00:01:27,540
including the modifications we've made

00:01:25,259 --> 00:01:27,990
to the Linux kernel so clearly in half

00:01:27,540 --> 00:01:29,400
an hour

00:01:27,990 --> 00:01:30,479
allowing time for questions as well

00:01:29,400 --> 00:01:32,759
we're not going to be able to go into

00:01:30,479 --> 00:01:35,159
lots of detail but when we do the code

00:01:32,759 --> 00:01:36,900
release we are going to release more

00:01:35,159 --> 00:01:40,920
details including all the cool graphs

00:01:36,900 --> 00:01:43,950
and how files have changed etc etc and

00:01:40,920 --> 00:01:46,020
then later on this evening there's going

00:01:43,950 --> 00:01:48,420
to be an experiment showing you a

00:01:46,020 --> 00:01:52,409
particular application of Ireland P

00:01:48,420 --> 00:01:54,119
which is mobility working with IL NP so

00:01:52,409 --> 00:01:57,570
where did Ireland P came about so I've

00:01:54,119 --> 00:02:00,060
been working on Ireland P for about 15

00:01:57,570 --> 00:02:02,549
odd years now and it first came about as

00:02:00,060 --> 00:02:05,130
an academic exercise I work in a

00:02:02,549 --> 00:02:07,340
university and at that time lots of

00:02:05,130 --> 00:02:10,860
people were trying to do new things with

00:02:07,340 --> 00:02:12,510
IP I say new in that they weren't

00:02:10,860 --> 00:02:13,500
necessarily part of the core

00:02:12,510 --> 00:02:15,690
architecture

00:02:13,500 --> 00:02:17,580
charity like mobility multihoming which

00:02:15,690 --> 00:02:19,500
can be done today but all those

00:02:17,580 --> 00:02:21,090
functions are enabled separately with

00:02:19,500 --> 00:02:24,450
separate mechanisms which might not

00:02:21,090 --> 00:02:26,370
always work together and so um a

00:02:24,450 --> 00:02:27,840
colleague of mine and I ran Atkinson we

00:02:26,370 --> 00:02:29,820
thought well how can we kind of bring

00:02:27,840 --> 00:02:33,720
this all together and that's where

00:02:29,820 --> 00:02:36,240
Ireland P came from and at moment it's

00:02:33,720 --> 00:02:37,170
an experimental standard well I don't

00:02:36,240 --> 00:02:41,250
think it's a standard it's just an

00:02:37,170 --> 00:02:44,160
experimental proposal and it came from

00:02:41,250 --> 00:02:45,510
some work we did within the IRT F

00:02:44,160 --> 00:02:46,320
routing research group which is now

00:02:45,510 --> 00:02:49,440
concluded

00:02:46,320 --> 00:02:51,750
RFC 67 forty to sixty seven forty eight

00:02:49,440 --> 00:02:53,070
and on the island P website there are

00:02:51,750 --> 00:02:56,220
links to those and various other things

00:02:53,070 --> 00:02:59,070
including academic papers and some

00:02:56,220 --> 00:03:03,180
results showing how things like TCP and

00:02:59,070 --> 00:03:06,870
UDP perform as well okay so what are the

00:03:03,180 --> 00:03:09,630
core differences between Ireland P and

00:03:06,870 --> 00:03:11,430
IP well I'm going to take you through

00:03:09,630 --> 00:03:13,800
really an architectural approach first

00:03:11,430 --> 00:03:16,410
looking at the protocol architecture and

00:03:13,800 --> 00:03:20,370
then look at how we engineered that so

00:03:16,410 --> 00:03:22,500
first of all our idea well what we ended

00:03:20,370 --> 00:03:25,650
up with was a realization that the way

00:03:22,500 --> 00:03:27,209
IP addresses are used today is a little

00:03:25,650 --> 00:03:29,489
bit broken with respect to some of the

00:03:27,209 --> 00:03:31,980
things we want to do so instead of

00:03:29,489 --> 00:03:33,870
having IP addresses we use something

00:03:31,980 --> 00:03:36,000
called an identifier and something

00:03:33,870 --> 00:03:38,870
called a locator and I'll explain more

00:03:36,000 --> 00:03:41,580
about those on the coming slide and

00:03:38,870 --> 00:03:43,590
really this came from looking at the way

00:03:41,580 --> 00:03:45,930
the IP address is used in the protocol

00:03:43,590 --> 00:03:47,579
stack and realizing that the IP address

00:03:45,930 --> 00:03:50,220
bits get used all over the place and

00:03:47,579 --> 00:03:52,799
things get a little hairy when you do

00:03:50,220 --> 00:03:55,350
that especially because the IP address

00:03:52,799 --> 00:03:59,040
is physically bound to an interface so

00:03:55,350 --> 00:04:02,040
when you configure an end system you

00:03:59,040 --> 00:04:03,329
bind an IP address to an interface we

00:04:02,040 --> 00:04:06,000
all do that all the time we do

00:04:03,329 --> 00:04:08,850
automatically and that means that that

00:04:06,000 --> 00:04:11,519
address is bound to that point of

00:04:08,850 --> 00:04:15,269
connection for that host so if we have a

00:04:11,519 --> 00:04:17,790
look at what that means for the stack if

00:04:15,269 --> 00:04:19,680
we take the layers and we look at what

00:04:17,790 --> 00:04:22,349
happens with IP you get the IP address

00:04:19,680 --> 00:04:24,360
that's bound to an interface as I've

00:04:22,349 --> 00:04:27,090
just shown you it's used that the

00:04:24,360 --> 00:04:27,630
network layer for routing and then it's

00:04:27,090 --> 00:04:29,940
used

00:04:27,630 --> 00:04:33,480
one sport layer it forms part of the

00:04:29,940 --> 00:04:35,550
tuple that forms the end-to-end State

00:04:33,480 --> 00:04:37,470
for both TCP connections and UDP

00:04:35,550 --> 00:04:41,090
sessions and then of course applications

00:04:37,470 --> 00:04:43,740
can use an IP address as well of course

00:04:41,090 --> 00:04:45,420
best practice is to use say a fully

00:04:43,740 --> 00:04:47,940
qualified domain name of the application

00:04:45,420 --> 00:04:50,430
layer or an application specific naming

00:04:47,940 --> 00:04:53,820
space but typically it's very convenient

00:04:50,430 --> 00:04:55,530
just to use the IP address okay so we

00:04:53,820 --> 00:04:57,950
saw that that was part of the problem

00:04:55,530 --> 00:05:00,900
after looking at it for a few years and

00:04:57,950 --> 00:05:04,440
so we decided to have a clean split of

00:05:00,900 --> 00:05:08,160
the way that that aspect of naming works

00:05:04,440 --> 00:05:10,650
in the in the core architecture so we

00:05:08,160 --> 00:05:13,110
introduced two new namespaces a locator

00:05:10,650 --> 00:05:15,900
and a node identifier and I'll explain

00:05:13,110 --> 00:05:18,690
more about those and the other thing we

00:05:15,900 --> 00:05:21,510
thought it'd be useful to do is not to

00:05:18,690 --> 00:05:23,910
have the kind of tight semi permanent

00:05:21,510 --> 00:05:26,760
binding you have between addresses and

00:05:23,910 --> 00:05:28,740
objects in the protocol stack so there

00:05:26,760 --> 00:05:32,220
are now dynamic bindings between node

00:05:28,740 --> 00:05:35,660
identifiers and locators and dynamic

00:05:32,220 --> 00:05:38,760
bindings between locators and interfaces

00:05:35,660 --> 00:05:40,320
so you have a node identifier which

00:05:38,760 --> 00:05:43,110
doesn't identify an interface it

00:05:40,320 --> 00:05:45,960
identifies a node and it's dynamically

00:05:43,110 --> 00:05:48,630
bound to a locator and if that node

00:05:45,960 --> 00:05:51,110
happens to change location it bangs to a

00:05:48,630 --> 00:05:54,390
new locator and so you have mobility and

00:05:51,110 --> 00:05:56,640
if you want a node to be multihomed you

00:05:54,390 --> 00:05:59,310
dynamically bind the identify the node

00:05:56,640 --> 00:06:01,890
identifier to multiple locators and you

00:05:59,310 --> 00:06:03,840
have multihoming okay and it's all done

00:06:01,890 --> 00:06:06,600
from the end system so you don't need

00:06:03,840 --> 00:06:09,930
any specific support from the network

00:06:06,600 --> 00:06:11,190
other than the basic support that you

00:06:09,930 --> 00:06:13,560
expect the network to give which is

00:06:11,190 --> 00:06:15,390
routing and forwarding ok so one of the

00:06:13,560 --> 00:06:17,940
things we try to do quite consciously

00:06:15,390 --> 00:06:20,730
was go back to the kind of original

00:06:17,940 --> 00:06:22,710
philosophy of the Internet which is that

00:06:20,730 --> 00:06:24,780
the core networks are simple things and

00:06:22,710 --> 00:06:27,420
tries to do them well and effectively so

00:06:24,780 --> 00:06:29,040
routing and forwarding and then all the

00:06:27,420 --> 00:06:31,650
other stuff you want to do you move to

00:06:29,040 --> 00:06:35,010
the edge to the end system as far as you

00:06:31,650 --> 00:06:38,010
can so just a little bit more on these

00:06:35,010 --> 00:06:41,530
two new namespaces first of all the

00:06:38,010 --> 00:06:44,320
locator is topologically

00:06:41,530 --> 00:06:46,870
so it is used in routing but it's not

00:06:44,320 --> 00:06:48,490
used at the transport layer state so

00:06:46,870 --> 00:06:51,010
basically the bits you used at the

00:06:48,490 --> 00:06:52,750
transport layer are no longer linked to

00:06:51,010 --> 00:06:55,330
topology they're no longer bound to an

00:06:52,750 --> 00:06:58,030
interface so you have some agility for

00:06:55,330 --> 00:07:01,240
the transport layer session because the

00:06:58,030 --> 00:07:03,550
state is no longer bound to some sort of

00:07:01,240 --> 00:07:06,160
topological set of bits in the network

00:07:03,550 --> 00:07:10,030
or to an interface and then we have a

00:07:06,160 --> 00:07:12,100
node identifier and that is has no

00:07:10,030 --> 00:07:14,740
topological significance at all it

00:07:12,100 --> 00:07:17,590
doesn't play any part in routing and

00:07:14,740 --> 00:07:20,080
that's the only set of bits that's used

00:07:17,590 --> 00:07:22,150
in the end-to-end transport protocol

00:07:20,080 --> 00:07:25,270
State and then as I said there are

00:07:22,150 --> 00:07:28,720
dynamic bindings between node identifier

00:07:25,270 --> 00:07:32,700
and locators okay so this all sounds a

00:07:28,720 --> 00:07:35,020
little bit abstract at the moment and

00:07:32,700 --> 00:07:37,600
certainly one approach we could have

00:07:35,020 --> 00:07:39,700
taken many years ago was to look at this

00:07:37,600 --> 00:07:41,290
in a clean slate approach and say well

00:07:39,700 --> 00:07:43,480
how do we do everything from first

00:07:41,290 --> 00:07:45,160
principles but we thought that might not

00:07:43,480 --> 00:07:46,900
be so useful so we started looking at

00:07:45,160 --> 00:07:49,540
how we could build this into FreeBSD and

00:07:46,900 --> 00:07:50,980
Linux and so what I'm real and I are

00:07:49,540 --> 00:07:53,620
going to talk to you about today in demo

00:07:50,980 --> 00:07:56,200
later is the work we've done in Linux so

00:07:53,620 --> 00:07:58,810
if we do a bit of a reality check on

00:07:56,200 --> 00:08:02,380
this how do we get this new kind of

00:07:58,810 --> 00:08:04,270
protocol architecture shipped as bits

00:08:02,380 --> 00:08:06,520
across the network and then how do we

00:08:04,270 --> 00:08:09,340
change the code in the protocol stack to

00:08:06,520 --> 00:08:10,990
do something useful with these so the

00:08:09,340 --> 00:08:14,590
first part is to say well how does this

00:08:10,990 --> 00:08:16,690
fit on the wire and we looked very much

00:08:14,590 --> 00:08:19,300
at ipv6 if you look at the RFC documents

00:08:16,690 --> 00:08:22,840
for Ireland P you'll see that we've

00:08:19,300 --> 00:08:25,750
defined Ireland P as effectively

00:08:22,840 --> 00:08:27,910
extensions of both ipv4 and ipv6 so we

00:08:25,750 --> 00:08:30,430
take the architectural approach and we

00:08:27,910 --> 00:08:33,460
basically implement it as a superset of

00:08:30,430 --> 00:08:36,160
either ipv4 or ipv6 so you may see

00:08:33,460 --> 00:08:37,810
references to Ireland P v6 so that

00:08:36,160 --> 00:08:38,860
doesn't mean we have five versions that

00:08:37,810 --> 00:08:41,440
were rubbish and we threw them away

00:08:38,860 --> 00:08:44,110
that's just Ireland P as a superset of

00:08:41,440 --> 00:08:45,340
ipv6 okay and that's really all I'm

00:08:44,110 --> 00:08:48,310
going to be talking about today

00:08:45,340 --> 00:08:50,170
I'll npv for silent Piatt on to provide

00:08:48,310 --> 00:08:51,670
pv for is also possible but it gets

00:08:50,170 --> 00:08:54,820
really messy and I think pretty

00:08:51,670 --> 00:08:57,100
difficult to deploy okay so this is

00:08:54,820 --> 00:09:00,490
the essence of what this looks like in a

00:08:57,100 --> 00:09:03,460
packet it turns out that the locator is

00:09:00,490 --> 00:09:05,770
effectively a name for a network and so

00:09:03,460 --> 00:09:08,380
that has the same syntax and semantics

00:09:05,770 --> 00:09:10,780
as an ipv6 routing prefix today now

00:09:08,380 --> 00:09:15,250
that's really handy because that's the

00:09:10,780 --> 00:09:17,530
part of the 128 bits in the packet

00:09:15,250 --> 00:09:20,470
header that IP routers use in order to

00:09:17,530 --> 00:09:25,390
route packets so basically an iln P

00:09:20,470 --> 00:09:27,730
packet looks like an ipv6 packet as far

00:09:25,390 --> 00:09:29,320
as a Rooter is concerned and then we

00:09:27,730 --> 00:09:34,630
have a node identifier which occupies

00:09:29,320 --> 00:09:35,710
the lower 64 bits of the 128 bits in the

00:09:34,630 --> 00:09:38,800
packet header that would normally be

00:09:35,710 --> 00:09:41,140
used for an ipv6 address and that is

00:09:38,800 --> 00:09:42,640
used to identify a node and not an

00:09:41,140 --> 00:09:44,890
interface so it's not bound to an

00:09:42,640 --> 00:09:47,050
individual interface it actually is an

00:09:44,890 --> 00:09:49,060
identity for the node and nodes are

00:09:47,050 --> 00:09:51,580
permitted to have multiple identifiers

00:09:49,060 --> 00:09:53,800
simultaneously and multiple locator

00:09:51,580 --> 00:09:57,880
simultaneously they can even if they

00:09:53,800 --> 00:10:00,340
like generate dynamically identifies on

00:09:57,880 --> 00:10:02,590
the fly to use them for an individual

00:10:00,340 --> 00:10:06,790
session in fact any mechanism you can

00:10:02,590 --> 00:10:09,400
use to I generate for 64 identifier bits

00:10:06,790 --> 00:10:11,530
for IP for example privacy or CG a

00:10:09,400 --> 00:10:13,720
cryptographic key generator addresses

00:10:11,530 --> 00:10:15,730
that can be used to generate node

00:10:13,720 --> 00:10:17,470
identify as the differences in the

00:10:15,730 --> 00:10:20,770
semantics they're bound to a node as a

00:10:17,470 --> 00:10:23,770
whole and not to an interface okay so

00:10:20,770 --> 00:10:25,240
today I'm gonna hand over to Rio for a

00:10:23,770 --> 00:10:27,700
short time and he's going to talk to you

00:10:25,240 --> 00:10:29,860
to some bits of the code base we've need

00:10:27,700 --> 00:10:31,540
to change there are changes to get add

00:10:29,860 --> 00:10:34,360
row info which we're not going to cover

00:10:31,540 --> 00:10:36,490
in detail today but we will include with

00:10:34,360 --> 00:10:39,670
the code release and that's so that when

00:10:36,490 --> 00:10:41,350
you make a an access to a fully

00:10:39,670 --> 00:10:44,410
qualified domain name you pickup

00:10:41,350 --> 00:10:46,210
identifies and locators or you go to the

00:10:44,410 --> 00:10:49,090
DNS and pick up the DNS records for

00:10:46,210 --> 00:10:52,960
identifies and locators but what we

00:10:49,090 --> 00:10:56,080
focused on is making those look to

00:10:52,960 --> 00:10:58,960
anything above sockets like ipv6 so

00:10:56,080 --> 00:11:02,380
again in the demo you'll see later ping

00:10:58,960 --> 00:11:05,170
6 and iperf working over an iln PE

00:11:02,380 --> 00:11:08,570
enabled kernel but they are not

00:11:05,170 --> 00:11:11,720
recompile binary their standard ipv6

00:11:08,570 --> 00:11:14,510
compiled binaries for pink 6 and iperf

00:11:11,720 --> 00:11:16,370
and they work over LNP while mobility is

00:11:14,510 --> 00:11:18,170
happening and they seem to be reasonably

00:11:16,370 --> 00:11:21,020
happy about it

00:11:18,170 --> 00:11:24,350
Rhea will talk to you about some changes

00:11:21,020 --> 00:11:26,000
have been made to socket API and the

00:11:24,350 --> 00:11:28,610
kernel code again there's some changes

00:11:26,000 --> 00:11:30,890
to icmpv6 which I'll say more about have

00:11:28,610 --> 00:11:32,960
some slides with a demo later on with a

00:11:30,890 --> 00:11:37,030
bit more detail and also what's needed

00:11:32,960 --> 00:11:42,800
to change in the TCP and UDP kernel code

00:11:37,030 --> 00:11:47,270
so I'll hand over to Rio everyone and so

00:11:42,800 --> 00:11:48,680
the main sort of modifications that we

00:11:47,270 --> 00:11:52,270
will want one of the one of our main

00:11:48,680 --> 00:11:55,550
goals in implementing Island pv6 into

00:11:52,270 --> 00:11:58,220
Linux kernel was that we want to utilize

00:11:55,550 --> 00:12:00,710
the ipv6 infrastructure as much as

00:11:58,220 --> 00:12:03,620
possible so that we had the backwards

00:12:00,710 --> 00:12:07,940
compatibility and the new features side

00:12:03,620 --> 00:12:12,020
by side at the same time essentially so

00:12:07,940 --> 00:12:16,550
the in order to achieve what we want to

00:12:12,020 --> 00:12:19,430
do with Island pv6 we essentially had to

00:12:16,550 --> 00:12:21,920
have the hooks to call for the Island P

00:12:19,430 --> 00:12:25,130
processing in the ipv6 input and output

00:12:21,920 --> 00:12:29,630
paths so which means modifying files

00:12:25,130 --> 00:12:34,130
within next net ipv6 you know files

00:12:29,630 --> 00:12:36,890
within a and so on and so on and input

00:12:34,130 --> 00:12:40,370
and output so the IP six input and

00:12:36,890 --> 00:12:44,870
output both have a hooks that calls

00:12:40,370 --> 00:12:48,910
Island P send and receive which modifies

00:12:44,870 --> 00:12:52,550
what's called il NP communication cache

00:12:48,910 --> 00:12:55,190
so that encapsulate s-- the information

00:12:52,550 --> 00:12:57,950
for an IP operations in general won't go

00:12:55,190 --> 00:12:59,060
into details today but certainly happy

00:12:57,950 --> 00:13:03,430
to talk about this later on

00:12:59,060 --> 00:13:07,010
and as Salim has mentioned just now

00:13:03,430 --> 00:13:10,250
socket so the stroke has the is island

00:13:07,010 --> 00:13:13,190
PFLAG sk buff also has the is arm and

00:13:10,250 --> 00:13:16,580
people flag to indicate that this is an

00:13:13,190 --> 00:13:19,070
IP connection so that the island p

00:13:16,580 --> 00:13:20,860
operations can be triggered as it goes

00:13:19,070 --> 00:13:25,269
through the IP

00:13:20,860 --> 00:13:26,980
and also TCP UDP processing paths I'm

00:13:25,269 --> 00:13:29,050
seeing some confused looks but I'm sure

00:13:26,980 --> 00:13:32,730
I'll be able to clarify as I go along

00:13:29,050 --> 00:13:36,750
and obviously yes I'll NP has to have

00:13:32,730 --> 00:13:40,510
its files to do the aforementioned

00:13:36,750 --> 00:13:44,740
operations so island t6 dot C and I'm

00:13:40,510 --> 00:13:47,950
island p6 dot H is added right so the

00:13:44,740 --> 00:13:53,410
main challenge in making this work so

00:13:47,950 --> 00:13:56,350
then the splitting the the locator from

00:13:53,410 --> 00:13:59,260
the identify layers of the sockets in

00:13:56,350 --> 00:14:02,200
the transport layer the main challenge

00:13:59,260 --> 00:14:05,440
here was that obviously the ipv6 expects

00:14:02,200 --> 00:14:07,810
entire hundred to 128 bits to be used as

00:14:05,440 --> 00:14:11,019
a both identifier for checks and all

00:14:07,810 --> 00:14:12,459
sorts of things and and those are the

00:14:11,019 --> 00:14:15,370
two main things that we had we had to

00:14:12,459 --> 00:14:20,500
focus on in a bit about doing some

00:14:15,370 --> 00:14:24,459
juggling I'd like to stress that the top

00:14:20,500 --> 00:14:28,510
64 bit which notes the locator is

00:14:24,459 --> 00:14:30,399
mutable it does not matter what what it

00:14:28,510 --> 00:14:33,130
is as long as I MP knows about it and

00:14:30,399 --> 00:14:35,800
what matters in the context of sake

00:14:33,130 --> 00:14:37,990
identical identification so essentially

00:14:35,800 --> 00:14:41,230
the identifier of the connection between

00:14:37,990 --> 00:14:47,890
the two hosts the bottom 64 bit which

00:14:41,230 --> 00:14:51,100
does the node identifier so essentially

00:14:47,890 --> 00:14:53,230
what we do in that context is that we in

00:14:51,100 --> 00:14:55,779
those two sets of operations we

00:14:53,230 --> 00:14:58,870
basically mask the locator

00:14:55,779 --> 00:15:01,120
and we restore them as soon as we're

00:14:58,870 --> 00:15:03,640
done with those things so everything

00:15:01,120 --> 00:15:05,560
else looks exactly the same except in

00:15:03,640 --> 00:15:10,230
the context of identifying and checking

00:15:05,560 --> 00:15:10,230
if this is the correct set of

00:15:10,410 --> 00:15:16,300
identifiers to identify socket or do a

00:15:13,240 --> 00:15:19,660
chuck some as done correctly for Island

00:15:16,300 --> 00:15:21,250
peope job that is once again if it is an

00:15:19,660 --> 00:15:25,029
eye on the people so this is why we have

00:15:21,250 --> 00:15:29,500
the is Island P flags in EM sock struck

00:15:25,029 --> 00:15:31,720
sock and SK buff so let's start with

00:15:29,500 --> 00:15:34,030
something simple so that the UDP is

00:15:31,720 --> 00:15:36,640
slightly simple in a sense that

00:15:34,030 --> 00:15:38,230
I mean that's a ground scent and you

00:15:36,640 --> 00:15:41,260
know it may or may not be received by

00:15:38,230 --> 00:15:43,570
that arcade you know is it's a it

00:15:41,260 --> 00:15:46,300
doesn't have the state control right so

00:15:43,570 --> 00:15:48,610
if the application wants to send this is

00:15:46,300 --> 00:15:50,700
a very simplified call graph and I'm

00:15:48,610 --> 00:15:53,820
sure you've recognized ideas

00:15:50,700 --> 00:15:57,060
so in this core graph we have

00:15:53,820 --> 00:16:00,610
essentially three colors of boxes grave

00:15:57,060 --> 00:16:02,980
yellow and blue blue and notates their

00:16:00,610 --> 00:16:05,590
new file new functions so it's entirely

00:16:02,980 --> 00:16:08,560
new to die on if you carnal or Ireland

00:16:05,590 --> 00:16:10,870
be enabled Karel shall we say and yellow

00:16:08,560 --> 00:16:15,310
is modifications to existing file

00:16:10,870 --> 00:16:17,140
existing function so the gray one is

00:16:15,310 --> 00:16:20,110
completely untouched we have not touched

00:16:17,140 --> 00:16:23,110
those functions so when the message of

00:16:20,110 --> 00:16:25,600
being sent send message calls which goes

00:16:23,110 --> 00:16:28,480
call makes escapee at one point which

00:16:25,600 --> 00:16:32,950
will cause underscore underscore ip6

00:16:28,480 --> 00:16:37,120
make STP in that at that point we check

00:16:32,950 --> 00:16:42,070
for whether this is sending to be a host

00:16:37,120 --> 00:16:45,100
from Island P host and we call Island p6

00:16:42,070 --> 00:16:48,850
and in order to first of all update a

00:16:45,100 --> 00:16:51,760
record of talking with and what sets of

00:16:48,850 --> 00:16:54,550
the locators and needs are used and and

00:16:51,760 --> 00:16:59,170
then after this is sorted and correctly

00:16:54,550 --> 00:17:02,800
selected in the header section it goes

00:16:59,170 --> 00:17:05,560
off set sets the destination in source

00:17:02,800 --> 00:17:07,030
address what it looks like a source to

00:17:05,560 --> 00:17:09,640
destination source address it then goes

00:17:07,030 --> 00:17:12,720
to send s KB which once again checks

00:17:09,640 --> 00:17:16,750
whether this is actually Island p6

00:17:12,720 --> 00:17:21,790
destination and source or not and and

00:17:16,750 --> 00:17:23,980
then it does the checksum for the island

00:17:21,790 --> 00:17:27,790
P so that which basically means that we

00:17:23,980 --> 00:17:30,790
do not include the locator in a checksum

00:17:27,790 --> 00:17:33,010
calculation so we just back them up mask

00:17:30,790 --> 00:17:35,590
them do the calculation put them back in

00:17:33,010 --> 00:17:37,810
and send them off so as soon as it goes

00:17:35,590 --> 00:17:41,050
to the wire by the time it hits the wire

00:17:37,810 --> 00:17:44,320
it's going to look exactly like ipv6 but

00:17:41,050 --> 00:17:46,210
we've been enabled the the socket

00:17:44,320 --> 00:17:47,300
identification and the checksum

00:17:46,210 --> 00:17:51,460
calculation when

00:17:47,300 --> 00:17:55,820
man in there is in the receiving path

00:17:51,460 --> 00:17:59,320
when the ip6 input finishes cold this

00:17:55,820 --> 00:18:04,910
first of all checks that it's an IP

00:17:59,320 --> 00:18:07,940
destination in source and it it calls

00:18:04,910 --> 00:18:13,220
iron p6 receive which essentially once

00:18:07,940 --> 00:18:17,450
again updates the the the MPI OCC which

00:18:13,220 --> 00:18:21,200
keeps track of the location it and in

00:18:17,450 --> 00:18:23,900
the following one point ip6 checksum in

00:18:21,200 --> 00:18:26,090
it is done which obviously I'm sure you

00:18:23,900 --> 00:18:28,070
know that it does the checksum

00:18:26,090 --> 00:18:29,570
calculation so before this before the

00:18:28,070 --> 00:18:33,500
actual checksum calculation happens

00:18:29,570 --> 00:18:35,780
masks restores mask calculates restores

00:18:33,500 --> 00:18:38,900
those are the cycle is essentially

00:18:35,780 --> 00:18:41,680
happening in the compute school in order

00:18:38,900 --> 00:18:44,450
to do the soccer identification so that

00:18:41,680 --> 00:18:46,700
when you do I charges comparison once

00:18:44,450 --> 00:18:50,450
again locators masked so that we only

00:18:46,700 --> 00:18:52,580
check against the net and UDP sixty has

00:18:50,450 --> 00:18:55,670
fun once again hash calculation so we

00:18:52,580 --> 00:18:58,580
need to do mask calculate restore those

00:18:55,670 --> 00:19:01,670
simple cycles that's how you DP is

00:18:58,580 --> 00:19:05,200
received so this is how new DP is done

00:19:01,670 --> 00:19:08,810
and it seems to work quite well and

00:19:05,200 --> 00:19:10,640
moving on to TCP it gets a little bit

00:19:08,810 --> 00:19:12,320
complex once again this is overly

00:19:10,640 --> 00:19:15,320
simplified I'm sure I've skipped a lot

00:19:12,320 --> 00:19:17,360
of functions that are essential once

00:19:15,320 --> 00:19:18,980
again in the context final impede those

00:19:17,360 --> 00:19:21,170
are the net essential functions that we

00:19:18,980 --> 00:19:23,530
had to modify so yellow boxes once again

00:19:21,170 --> 00:19:27,250
our modified gray boxes aren't touched

00:19:23,530 --> 00:19:31,190
blue are the new file and new function

00:19:27,250 --> 00:19:34,400
so once again we have fun so that's the

00:19:31,190 --> 00:19:37,750
on the on the left bottom that that's

00:19:34,400 --> 00:19:43,160
the hash calculation back up mask

00:19:37,750 --> 00:19:46,820
restore and on the far right we have the

00:19:43,160 --> 00:19:50,570
same message and tcp current MSS so

00:19:46,820 --> 00:19:53,300
those are modified because i'll NP have

00:19:50,570 --> 00:19:56,840
additional optional headers for Island P

00:19:53,300 --> 00:19:59,060
gnomes which we have the exploiter we

00:19:56,840 --> 00:19:59,660
have an additional option so we have to

00:19:59,060 --> 00:20:00,860
account for that

00:19:59,660 --> 00:20:05,570
in in

00:20:00,860 --> 00:20:08,270
setting the MSS so the TCP send message

00:20:05,570 --> 00:20:11,780
checks for it by calling is Island p6

00:20:08,270 --> 00:20:14,600
and then Flags it the the socket to be

00:20:11,780 --> 00:20:17,780
is Island P socket and TCP current MSS

00:20:14,600 --> 00:20:19,970
actually adjusts them now

00:20:17,780 --> 00:20:22,549
TCP sent check that's another checksum

00:20:19,970 --> 00:20:25,760
so we we did a checksum calculation and

00:20:22,549 --> 00:20:28,360
in IP 6x MIT so I thought that's at the

00:20:25,760 --> 00:20:30,650
bottom before we send them off the

00:20:28,360 --> 00:20:33,710
segmentation length is actually adjusted

00:20:30,650 --> 00:20:36,530
again so that happens at that point and

00:20:33,710 --> 00:20:40,370
also island peace extent is called in

00:20:36,530 --> 00:20:45,380
order to the IOC updates and setting the

00:20:40,370 --> 00:20:46,610
correct source and destination I'm going

00:20:45,380 --> 00:20:49,040
a little fast because I think I'm

00:20:46,610 --> 00:20:52,460
running out of time here but this is how

00:20:49,040 --> 00:20:55,610
we received the TCP once again when it

00:20:52,460 --> 00:21:00,380
comes in and it does the mark and lookup

00:20:55,610 --> 00:21:03,049
of the IRC severe ion p6 receive in IP 6

00:21:00,380 --> 00:21:05,530
input finish and then it gets passed on

00:21:03,049 --> 00:21:06,890
to TCP v6 receive which does the

00:21:05,530 --> 00:21:09,160
checksum in it

00:21:06,890 --> 00:21:15,320
so the skb checksum in it before that

00:21:09,160 --> 00:21:18,350
mask calculate restore and I net 6

00:21:15,320 --> 00:21:20,030
lookup established and Aoife she has fun

00:21:18,350 --> 00:21:23,590
so that's once again look up and

00:21:20,030 --> 00:21:26,750
checksum calculation so that's modified

00:21:23,590 --> 00:21:30,340
tcp v6 sensing on the right left boat

00:21:26,750 --> 00:21:32,840
I'm sorry that one it's calls these

00:21:30,340 --> 00:21:34,880
underscore underscore sent check so then

00:21:32,840 --> 00:21:39,290
before that's called it needs to have

00:21:34,880 --> 00:21:41,750
the L 64 mast again and on the right

00:21:39,290 --> 00:21:44,299
bottom TCP con request once again we

00:21:41,750 --> 00:21:46,669
need to mask them before we call the TV

00:21:44,299 --> 00:21:50,150
sitcom request so that we don't include

00:21:46,669 --> 00:21:52,940
the locator in identifying the socket

00:21:50,150 --> 00:21:54,410
that we're dealing with them so I'm

00:21:52,940 --> 00:21:55,820
running all the time once again so I'm

00:21:54,410 --> 00:21:57,860
kind of rushing through it but I'm happy

00:21:55,820 --> 00:22:01,540
to answer questions towards the end and

00:21:57,860 --> 00:22:01,540
I'm gonna hand this back to Selene

00:22:05,350 --> 00:22:11,150
the demo you'll see later on today tries

00:22:08,539 --> 00:22:13,220
to show this in operation so the

00:22:11,150 --> 00:22:16,190
location identify working with a

00:22:13,220 --> 00:22:18,799
particular scenario which is end-to-end

00:22:16,190 --> 00:22:21,350
mobility so mobility done without any

00:22:18,799 --> 00:22:24,289
tunnels or proxies or middleboxes just

00:22:21,350 --> 00:22:25,280
on purely end to end so what we're going

00:22:24,289 --> 00:22:29,330
to have in our setup

00:22:25,280 --> 00:22:32,470
later on today is six kind of small

00:22:29,330 --> 00:22:36,470
desktop machines they're all running

00:22:32,470 --> 00:22:39,860
Linux but some are running BIOS so the

00:22:36,470 --> 00:22:42,020
ones marked R 1 R 2 R 3 are ipv6 OD

00:22:39,860 --> 00:22:46,460
machines running Vios acting as routers

00:22:42,020 --> 00:22:49,610
and blue boxes with white text those the

00:22:46,460 --> 00:22:51,559
only ones running Island P and what

00:22:49,610 --> 00:22:54,289
we're going to show is that there's a

00:22:51,559 --> 00:22:56,539
mobile node marked MN talking to a

00:22:54,289 --> 00:22:58,309
correspondent node CN and correspondent

00:22:56,539 --> 00:23:01,100
node stays where it is and the mobile

00:22:58,309 --> 00:23:02,360
node moves between networks and as it

00:23:01,100 --> 00:23:04,970
moves between networks we're going to

00:23:02,360 --> 00:23:08,360
show a ping running and iperf running

00:23:04,970 --> 00:23:10,270
and you'll see we run will run if' top

00:23:08,360 --> 00:23:14,690
and you'll see that there's a handover

00:23:10,270 --> 00:23:17,570
between those different networks but the

00:23:14,690 --> 00:23:20,450
flow stays intact and in fact what

00:23:17,570 --> 00:23:23,270
happens is that Island P does something

00:23:20,450 --> 00:23:25,429
called network layer soft handoff so

00:23:23,270 --> 00:23:26,840
basically in the overlap region between

00:23:25,429 --> 00:23:30,080
the two networks

00:23:26,840 --> 00:23:33,039
it's multihomed in both of the networks

00:23:30,080 --> 00:23:35,600
and so you get pretty much zero

00:23:33,039 --> 00:23:38,360
gratuitous packet loss you do get some

00:23:35,600 --> 00:23:41,059
miss ordering but it means that you can

00:23:38,360 --> 00:23:42,590
have hand off without packet loss and in

00:23:41,059 --> 00:23:44,450
the paper that accompanies the talk

00:23:42,590 --> 00:23:47,140
which eventually I think ends up on the

00:23:44,450 --> 00:23:49,309
native website you'll see we have some

00:23:47,140 --> 00:23:51,169
just some lightweight performance

00:23:49,309 --> 00:23:53,870
figures show you how that works and

00:23:51,169 --> 00:23:56,419
you'll see in the UDP graphs that there

00:23:53,870 --> 00:23:58,010
is no loss during the handoff that it

00:23:56,419 --> 00:23:59,600
just carries on that the flow just

00:23:58,010 --> 00:24:01,789
carries on straight through as it goes

00:23:59,600 --> 00:24:03,890
across the network and the TCP at the

00:24:01,789 --> 00:24:05,480
handoff there are some system and

00:24:03,890 --> 00:24:08,630
buffering effects that we notice on this

00:24:05,480 --> 00:24:10,730
testbed when we moved it the code onto

00:24:08,630 --> 00:24:12,470
the testbed about a week ago but we

00:24:10,730 --> 00:24:13,510
didn't see it on our main testbed which

00:24:12,470 --> 00:24:15,160
was

00:24:13,510 --> 00:24:16,810
on some rackmount machine so I think

00:24:15,160 --> 00:24:18,640
that's a system-level issue which again

00:24:16,810 --> 00:24:21,760
we're going to look at before we release

00:24:18,640 --> 00:24:23,290
the code in a few weeks time but it

00:24:21,760 --> 00:24:24,760
pretty much does work this there's no

00:24:23,290 --> 00:24:27,670
loss but there are some buffering

00:24:24,760 --> 00:24:29,320
effects for TCP again you'll see links

00:24:27,670 --> 00:24:35,770
to various papers on the website and

00:24:29,320 --> 00:24:38,440
other TCP performance evaluation with an

00:24:35,770 --> 00:24:41,560
older kernel a 3.9 kernel and you don't

00:24:38,440 --> 00:24:43,390
see those artifacts for TCP that's what

00:24:41,560 --> 00:24:46,230
I'm gonna say for now so I think we

00:24:43,390 --> 00:24:46,230
still have time for questions

00:24:50,460 --> 00:24:57,040
what about chicks um afros I don't

00:24:54,220 --> 00:24:58,600
really understand how it works at the

00:24:57,040 --> 00:25:00,460
moment it doesn't you anyway that a

00:24:58,600 --> 00:25:02,380
checksum is calculated you have to

00:25:00,460 --> 00:25:04,990
modify the checks on calculation so for

00:25:02,380 --> 00:25:08,140
example when we're looking at packets on

00:25:04,990 --> 00:25:10,050
the wire and we we have a peek up file

00:25:08,140 --> 00:25:13,240
and we look at them with something like

00:25:10,050 --> 00:25:20,140
Y shark it says all the checks under pad

00:25:13,240 --> 00:25:22,270
whoa that's huge well yes those need to

00:25:20,140 --> 00:25:24,430
be modified in fact what you do is you

00:25:22,270 --> 00:25:26,800
zero out the locator and run the checks

00:25:24,430 --> 00:25:28,480
on calculation is normal and they'll put

00:25:26,800 --> 00:25:30,310
back the locator bit that's the

00:25:28,480 --> 00:25:32,620
modification that needs to be made to

00:25:30,310 --> 00:25:34,750
the checksum so it's not a big

00:25:32,620 --> 00:25:37,000
modification but I agree with you that

00:25:34,750 --> 00:25:42,700
anyway you compute a checksum you're

00:25:37,000 --> 00:25:45,600
going to have to change it it was

00:25:42,700 --> 00:25:45,600
another question someone

00:25:47,710 --> 00:25:52,240
so a couple comments on the checksum why

00:25:50,470 --> 00:25:55,000
do you need to do this because you're

00:25:52,240 --> 00:25:58,299
sending a packet it looks like an ipv4

00:25:55,000 --> 00:26:00,220
ipv6 packet or I guess ipv6 it has a

00:25:58,299 --> 00:26:01,830
source and destination address as far as

00:26:00,220 --> 00:26:05,559
the network's concerned it doesn't care

00:26:01,830 --> 00:26:08,169
what those bits are just I mean unless

00:26:05,559 --> 00:26:09,730
they're changing you'll get this you'll

00:26:08,169 --> 00:26:11,169
get the same checksum and the other

00:26:09,730 --> 00:26:12,850
reason to do that if there are devices

00:26:11,169 --> 00:26:15,190
on the Internet they're gonna try to

00:26:12,850 --> 00:26:17,769
validate the checksum so they're gonna

00:26:15,190 --> 00:26:21,240
be dropped but more generally can you go

00:26:17,769 --> 00:26:21,240
back to the slide that showed the mods

00:26:21,659 --> 00:26:28,269
which one the one with all the yellow

00:26:24,429 --> 00:26:31,929
boxes as many as possible so I think

00:26:28,269 --> 00:26:34,179
your goal if you want to that's a lot of

00:26:31,929 --> 00:26:37,269
yellow boxes so your goal if you want to

00:26:34,179 --> 00:26:39,580
get this accepted upstream is to

00:26:37,269 --> 00:26:43,299
minimize the number of yellow boxes here

00:26:39,580 --> 00:26:45,970
and in some cases I think it might be

00:26:43,299 --> 00:26:49,210
kind of easy so for instance the IP

00:26:45,970 --> 00:26:51,789
input we already have an NF hook that we

00:26:49,210 --> 00:26:54,370
use for instance in ila so hopefully you

00:26:51,789 --> 00:26:57,490
won't need specialized code in nineteen

00:26:54,370 --> 00:26:58,899
put for il NP just call the existing

00:26:57,490 --> 00:27:03,879
hook and we just need to populate the

00:26:58,899 --> 00:27:07,899
hook and that way it just works now the

00:27:03,879 --> 00:27:12,429
tcp and UDP those are a little more

00:27:07,899 --> 00:27:13,570
worrisome we have a resident TCP

00:27:12,429 --> 00:27:15,250
maintainer here I don't know if he's

00:27:13,570 --> 00:27:18,100
gonna be too happy if we're putting

00:27:15,250 --> 00:27:21,480
special hooks in to just do a different

00:27:18,100 --> 00:27:24,610
type of socket socket lookup and also

00:27:21,480 --> 00:27:26,559
there's another obvious part here is UDP

00:27:24,610 --> 00:27:29,139
and TCP aren't necessarily the sum total

00:27:26,559 --> 00:27:33,990
of all transport protocols that the

00:27:29,139 --> 00:27:36,639
kernel supports so what about DCP setp

00:27:33,990 --> 00:27:39,250
there's potentially a long list tunnels

00:27:36,639 --> 00:27:41,529
and things like that so again I think

00:27:39,250 --> 00:27:44,139
the goal that you probably want to have

00:27:41,529 --> 00:27:46,539
in development is to absolutely minimize

00:27:44,139 --> 00:27:48,669
the number of the amount of churn the

00:27:46,539 --> 00:27:50,200
amount of invasiveness and that would

00:27:48,669 --> 00:27:51,290
give you the best shot to actually get

00:27:50,200 --> 00:27:54,230
this upstream

00:27:51,290 --> 00:27:55,400
anything okay so several questions now

00:27:54,230 --> 00:27:57,830
I'm gonna try and answer the first of

00:27:55,400 --> 00:27:59,900
all why not just use the checks on it is

00:27:57,830 --> 00:28:02,300
because the locator is immutable the

00:27:59,900 --> 00:28:03,770
locator can change on path and we

00:28:02,300 --> 00:28:06,230
totally allow that for various things

00:28:03,770 --> 00:28:08,300
again I can go into them so for example

00:28:06,230 --> 00:28:10,430
this is not the he'll be fine but if the

00:28:08,300 --> 00:28:14,210
locator changes on path just update the

00:28:10,430 --> 00:28:16,940
checksum or you know but then that would

00:28:14,210 --> 00:28:18,830
require changes to the middle box in the

00:28:16,940 --> 00:28:20,990
middle so but there's another option

00:28:18,830 --> 00:28:26,200
here or you can do that trick we did in

00:28:20,990 --> 00:28:29,060
ila where if you if the locator changes

00:28:26,200 --> 00:28:31,130
let's say somehow we need to offset that

00:28:29,060 --> 00:28:33,380
okay so but if you're changing the

00:28:31,130 --> 00:28:35,360
locator in flight the middle box is

00:28:33,380 --> 00:28:37,370
already being modified so it never

00:28:35,360 --> 00:28:40,550
changes the locator should update the

00:28:37,370 --> 00:28:43,970
checksum somehow right so there at the

00:28:40,550 --> 00:28:47,210
moment what we're focusing on is hiding

00:28:43,970 --> 00:28:48,950
il NP from existing applications so ipv6

00:28:47,210 --> 00:28:51,920
applications work as they are the

00:28:48,950 --> 00:28:53,920
eventual goal for me is to have Ln P

00:28:51,920 --> 00:28:56,450
aware applications so knowing that

00:28:53,920 --> 00:28:58,520
identifies and locators can change and

00:28:56,450 --> 00:29:00,710
that would require changes to the

00:28:58,520 --> 00:29:03,050
sockets API and for that if I make it to

00:29:00,710 --> 00:29:05,330
be available and in that case you don't

00:29:03,050 --> 00:29:08,750
need to worry about that as much because

00:29:05,330 --> 00:29:11,060
that change is end to end visible but

00:29:08,750 --> 00:29:12,590
what's happening at the application or

00:29:11,060 --> 00:29:14,840
the checksum should be completely

00:29:12,590 --> 00:29:17,510
independent of the application all the

00:29:14,840 --> 00:29:19,370
checksum is it just has the pseudo

00:29:17,510 --> 00:29:22,100
header that includes the IP source and

00:29:19,370 --> 00:29:25,310
IP destination okay so if you calculate

00:29:22,100 --> 00:29:27,380
the checksum over those and if somebody

00:29:25,310 --> 00:29:28,880
wants to change those like a NAT it's

00:29:27,380 --> 00:29:30,410
their responsibility to change the

00:29:28,880 --> 00:29:32,150
checksum accordingly so we already do

00:29:30,410 --> 00:29:34,760
all of this in other context no but if

00:29:32,150 --> 00:29:37,700
you if you change the if you change the

00:29:34,760 --> 00:29:39,830
chicks on computation which locator bits

00:29:37,700 --> 00:29:42,260
would you use for the correct locator so

00:29:39,830 --> 00:29:45,410
you'd use one set of bits when it's sent

00:29:42,260 --> 00:29:48,320
and what would you do if the packets

00:29:45,410 --> 00:29:51,200
happens to be multihomed and it's bound

00:29:48,320 --> 00:29:54,650
to two locators so having the checksum

00:29:51,200 --> 00:29:56,810
not tie to the locator in my view is the

00:29:54,650 --> 00:30:00,110
correct thing because then you have an

00:29:56,810 --> 00:30:02,600
end-to-end checksum only and it's tied

00:30:00,110 --> 00:30:04,429
to bits that are stable for the whole of

00:30:02,600 --> 00:30:05,869
the transport layer session and

00:30:04,429 --> 00:30:08,570
you have end-to-end integrity for the

00:30:05,869 --> 00:30:10,460
check so but that's not an assumption of

00:30:08,570 --> 00:30:13,009
checks yes the assumption of checksum is

00:30:10,460 --> 00:30:18,429
that it is a checksum over the bits as

00:30:13,009 --> 00:30:18,429
their scent on the wire and if again if

00:30:18,909 --> 00:30:23,659
one question you've got you've asked

00:30:21,049 --> 00:30:25,490
other questions and I think the second

00:30:23,659 --> 00:30:26,960
question but Meyer is but my my

00:30:25,490 --> 00:30:28,999
understanding of the checks on me it's

00:30:26,960 --> 00:30:31,249
an end-to-end checksum so you want

00:30:28,999 --> 00:30:32,119
end-to-end integrity no because of NAT

00:30:31,249 --> 00:30:35,149
that's broken

00:30:32,119 --> 00:30:37,490
no but the you know it works with it has

00:30:35,149 --> 00:30:39,710
to be corrected and is broken with that

00:30:37,490 --> 00:30:41,240
but it works with this again cuz you

00:30:39,710 --> 00:30:43,580
don't need that well no actually it's

00:30:41,240 --> 00:30:45,950
it's not working with NAT networks sorry

00:30:43,580 --> 00:30:48,740
if NAT did not update the checksum the I

00:30:45,950 --> 00:30:50,929
found but that breaks the end-to-end

00:30:48,740 --> 00:30:54,139
integrity of the of the transport layer

00:30:50,929 --> 00:30:57,049
session it's what you have different

00:30:54,139 --> 00:30:59,960
addresses at each side so you don't have

00:30:57,049 --> 00:31:02,269
the end-to-end integrity of the session

00:30:59,960 --> 00:31:04,070
yes that's fine that's fine if you want

00:31:02,269 --> 00:31:05,960
to restore the addresses at the endpoint

00:31:04,070 --> 00:31:08,059
but on these wires we should talk later

00:31:05,960 --> 00:31:09,619
I think so I think the simple rule is on

00:31:08,059 --> 00:31:10,940
the wire if the checksums incorrect

00:31:09,619 --> 00:31:12,919
that's going to cause problems

00:31:10,940 --> 00:31:16,119
checksum offload you're gonna have

00:31:12,919 --> 00:31:18,619
intermediate devices dropping packets I

00:31:16,119 --> 00:31:20,059
just figure out a way to keep the

00:31:18,619 --> 00:31:26,179
checksum correct I think your life will

00:31:20,059 --> 00:31:28,999
be a lot easier yeah just too far and

00:31:26,179 --> 00:31:33,200
checksum is too well known to be to be

00:31:28,999 --> 00:31:35,559
modifying it at this point any other

00:31:33,200 --> 00:31:35,559
questions

00:31:37,000 --> 00:31:41,170
can you explain in high-level cells what

00:31:39,430 --> 00:31:44,950
are the differences between Ireland P

00:31:41,170 --> 00:31:49,350
and ila right so the main difference is

00:31:44,950 --> 00:31:53,350
really that Isle NP is purely end-to-end

00:31:49,350 --> 00:31:55,870
and doesn't have the kind of control

00:31:53,350 --> 00:31:58,900
plane that ila has so certainly Tom will

00:31:55,870 --> 00:32:01,180
be able to tell you more about ila in

00:31:58,900 --> 00:32:03,760
terms of the control plane when in order

00:32:01,180 --> 00:32:06,790
to make ila work you need these ila

00:32:03,760 --> 00:32:10,360
Reuters and with Island P you don't it

00:32:06,790 --> 00:32:12,730
just works over standard ipv6 you need

00:32:10,360 --> 00:32:16,150
new DNS entries but DNS is already

00:32:12,730 --> 00:32:19,510
globally deployed and it's supported for

00:32:16,150 --> 00:32:22,330
so you can you know set up Island P need

00:32:19,510 --> 00:32:26,160
an L 64 records with an isp and they

00:32:22,330 --> 00:32:28,810
will just build its work so the main I

00:32:26,160 --> 00:32:32,020
suppose the main difference in terms of

00:32:28,810 --> 00:32:33,820
practical aspects is in terms of

00:32:32,020 --> 00:32:36,180
deployment you just update the end

00:32:33,820 --> 00:32:38,770
systems that you want to run il NP and

00:32:36,180 --> 00:32:46,900
they should work modulo the discussion

00:32:38,770 --> 00:32:49,750
we've just heard about the checksum any

00:32:46,900 --> 00:32:51,100
other questions okay thank you I'm sorry

00:32:49,750 --> 00:32:52,810
we seem to have taken more than our

00:32:51,100 --> 00:32:55,020
allotted time so my apology to the other

00:32:52,810 --> 00:32:55,020
speakers

00:32:55,790 --> 00:32:59,380

YouTube URL: https://www.youtube.com/watch?v=_jwiNrKE5ao


