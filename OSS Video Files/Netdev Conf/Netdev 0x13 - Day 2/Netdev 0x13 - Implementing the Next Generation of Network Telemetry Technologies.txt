Title: Netdev 0x13 - Implementing the Next Generation of Network Telemetry Technologies
Publication date: 2019-05-25
Playlist: Netdev 0x13 - Day 2
Description: 
	Telemetry is now an important part of networking. Standards and proposals for
producing and consuming metadata are emerging. In this talk, Andy Gospodarek
introduces two such standards: INT and IFA. He describes the hardware
requirements and implementation challenges. He further proposes approaches
for configuring INT/IFA for the kernel and supported hardware which attempts to
minimize risk associated with deploying early specs.

More info:
https://www.netdevconf.org/0x13/session.html?talk-nextgen-telemetry
Captions: 
	00:00:00,089 --> 00:00:05,730
all right I think we'll go ahead and get

00:00:00,960 --> 00:00:09,360
started I'm Andy gospel Doric as the

00:00:05,730 --> 00:00:12,150
slide says I work at Broadcom so I want

00:00:09,360 --> 00:00:15,030
to do this moonshot talk great news is

00:00:12,150 --> 00:00:18,840
it or maybe bad news is there's nothing

00:00:15,030 --> 00:00:20,310
about nvme so if you were you know a

00:00:18,840 --> 00:00:21,900
change of pace from the last two talks

00:00:20,310 --> 00:00:23,850
that's okay it's great technology but

00:00:21,900 --> 00:00:25,920
this is nothing about that and other

00:00:23,850 --> 00:00:27,480
good news have no slides because none of

00:00:25,920 --> 00:00:30,300
this is actually implemented so that's

00:00:27,480 --> 00:00:31,920
super cool too but we've been seeing a

00:00:30,300 --> 00:00:34,410
lot of interest in telemetry in general

00:00:31,920 --> 00:00:37,890
from customers and potential customers

00:00:34,410 --> 00:00:41,040
and there's two to three sort of

00:00:37,890 --> 00:00:42,210
standards that exist and wanted to sort

00:00:41,040 --> 00:00:44,219
of talk about those and just highlight

00:00:42,210 --> 00:00:46,770
those and kind of encourage us to think

00:00:44,219 --> 00:00:48,570
a little bit a little bit earlier

00:00:46,770 --> 00:00:50,399
there's always discussions about do we

00:00:48,570 --> 00:00:51,809
do development in the right way do we

00:00:50,399 --> 00:00:53,550
wait for hardware to have support and

00:00:51,809 --> 00:00:55,620
then do the work I have this discussion

00:00:53,550 --> 00:00:59,070
last week or do we earlier this week or

00:00:55,620 --> 00:01:01,559
do we find a ways to do it before

00:00:59,070 --> 00:01:03,000
hardware supports there so this is maybe

00:01:01,559 --> 00:01:04,830
a little bit of an encouraging talk to

00:01:03,000 --> 00:01:06,960
have us think about doing some of these

00:01:04,830 --> 00:01:08,220
things before the hardware is ready so

00:01:06,960 --> 00:01:10,700
I'll give you a brief introduction I

00:01:08,220 --> 00:01:13,350
don't looking up there I can look here

00:01:10,700 --> 00:01:14,610
anyway so hopefully it's not too much of

00:01:13,350 --> 00:01:17,250
an eye chart if you need to bring your

00:01:14,610 --> 00:01:19,680
binoculars so the idea behind telemetry

00:01:17,250 --> 00:01:22,320
is this a sort of a generic method for

00:01:19,680 --> 00:01:23,939
collecting Network State but it's often

00:01:22,320 --> 00:01:26,330
times on the packets as they traverse

00:01:23,939 --> 00:01:30,509
the network so you're not looking at

00:01:26,330 --> 00:01:33,509
necessarily a special agent or any any

00:01:30,509 --> 00:01:35,310
special little bit of an agent but

00:01:33,509 --> 00:01:37,369
nothing nothing third party the idea is

00:01:35,310 --> 00:01:39,840
we could have this native to the kernel

00:01:37,369 --> 00:01:41,850
so the way this works is that packets

00:01:39,840 --> 00:01:45,270
have eyes telemetry instructions

00:01:41,850 --> 00:01:47,220
inserted and a supported device would

00:01:45,270 --> 00:01:49,020
read these instructions and based on

00:01:47,220 --> 00:01:51,630
what's there would add some metadata to

00:01:49,020 --> 00:01:53,520
traffic as it flows through so sort of

00:01:51,630 --> 00:01:55,680
two ways that we think about this so

00:01:53,520 --> 00:01:58,439
these these telemetry instructions are

00:01:55,680 --> 00:01:59,610
added in situ which is if I'm

00:01:58,439 --> 00:02:02,280
pronouncing that correctly which is I

00:01:59,610 --> 00:02:04,979
believe one of the more popular ways so

00:02:02,280 --> 00:02:06,950
it goes on existing frames so in other

00:02:04,979 --> 00:02:09,890
words you're adding data to things

00:02:06,950 --> 00:02:11,840
as they go through your network this

00:02:09,890 --> 00:02:14,390
obviously has it could be problematic

00:02:11,840 --> 00:02:17,480
could be great we'll talk about some of

00:02:14,390 --> 00:02:19,430
those issues or in many cases it could

00:02:17,480 --> 00:02:23,060
be on a sample of the frames so in the

00:02:19,430 --> 00:02:25,099
event that you don't want to don't want

00:02:23,060 --> 00:02:27,170
to insert this directly in your data

00:02:25,099 --> 00:02:29,330
path but you want to still use the same

00:02:27,170 --> 00:02:32,330
data path you could sample a frame add

00:02:29,330 --> 00:02:34,700
the data possibly truncate the data so

00:02:32,330 --> 00:02:36,170
that you're not above the MTU and and

00:02:34,700 --> 00:02:38,330
those would be transmitted basically

00:02:36,170 --> 00:02:42,140
simultaneously with the frames that were

00:02:38,330 --> 00:02:44,090
cloned there's sort of three things you

00:02:42,140 --> 00:02:47,299
probably you may have heard of io a.m.

00:02:44,090 --> 00:02:49,280
this was kind of an extension that's

00:02:47,299 --> 00:02:52,130
been proposed and in a variety of frame

00:02:49,280 --> 00:02:54,739
formats VXLAN a particular BX ing PE has

00:02:52,130 --> 00:02:56,299
support for this there's a little bit of

00:02:54,739 --> 00:02:57,620
a little bit of knowledge of this in the

00:02:56,299 --> 00:02:59,630
kernel right now in fact there's

00:02:57,620 --> 00:03:02,269
actually the the extensive knowledge

00:02:59,630 --> 00:03:05,000
that exists for IO a.m. and the VIX and

00:03:02,269 --> 00:03:06,739
Driver it just says oh here's an IO am

00:03:05,000 --> 00:03:10,519
header yeah I don't know what to do with

00:03:06,739 --> 00:03:13,489
that don't just know that it's okay and

00:03:10,519 --> 00:03:14,720
we'll just we'll just move on which is

00:03:13,489 --> 00:03:16,790
fine I mean it's better than dropping

00:03:14,720 --> 00:03:17,780
the packet altogether which is kind of

00:03:16,790 --> 00:03:19,790
the case a while ago

00:03:17,780 --> 00:03:22,790
there's also IMT in-band network

00:03:19,790 --> 00:03:24,620
telemetry and IFA in band flow analysis

00:03:22,790 --> 00:03:26,000
and these are all these are all ways

00:03:24,620 --> 00:03:29,260
that we can implement this sort of

00:03:26,000 --> 00:03:32,810
generic network telemetry feature set

00:03:29,260 --> 00:03:37,250
all right so I shamelessly took this

00:03:32,810 --> 00:03:40,510
picture directly from the I one of the

00:03:37,250 --> 00:03:42,470
IFA IETF drafts it was much easier

00:03:40,510 --> 00:03:43,549
apparently to cut and paste this ASCII

00:03:42,470 --> 00:03:46,639
art than it was for me to draw something

00:03:43,549 --> 00:03:50,209
new so we're gonna talk about these main

00:03:46,639 --> 00:03:52,370
components key that used to there's

00:03:50,209 --> 00:03:54,829
three really key pieces you see C an

00:03:52,370 --> 00:03:58,300
initiative and really for an initiator

00:03:54,829 --> 00:03:59,890
node a transit node

00:03:58,300 --> 00:04:01,450
terminating note now I'm a little

00:03:59,890 --> 00:04:03,820
disappointed as a native English speaker

00:04:01,450 --> 00:04:06,370
that we didn't call this a terminator

00:04:03,820 --> 00:04:08,920
node that would be much cooler much more

00:04:06,370 --> 00:04:12,640
fun conjure up all sorts of thoughts

00:04:08,920 --> 00:04:14,440
about that future for us and and then

00:04:12,640 --> 00:04:16,859
the collector node so we'll go through

00:04:14,440 --> 00:04:19,180
each one of these components

00:04:16,859 --> 00:04:21,040
alright the source of the initiator node

00:04:19,180 --> 00:04:24,040
so in this case we have a flow that

00:04:21,040 --> 00:04:26,050
comes in and the idea behind all these

00:04:24,040 --> 00:04:28,690
technologies is that you're not sampling

00:04:26,050 --> 00:04:32,080
every packet you might say you know I

00:04:28,690 --> 00:04:33,910
want to understand what the flow of this

00:04:32,080 --> 00:04:35,980
application is inside my data center

00:04:33,910 --> 00:04:38,260
until it exits the network what ecmp

00:04:35,980 --> 00:04:40,480
host is going through where it's

00:04:38,260 --> 00:04:42,310
happening what the latency is all these

00:04:40,480 --> 00:04:45,760
details so a flow comes into an

00:04:42,310 --> 00:04:47,260
initiator node this initiator node notes

00:04:45,760 --> 00:04:48,670
that it is one it cares about in this

00:04:47,260 --> 00:04:50,290
case we're going to talk about an IFA

00:04:48,670 --> 00:04:51,910
flow that's cloned so we're not doing

00:04:50,290 --> 00:04:55,510
the traffic we're not doing it in situ

00:04:51,910 --> 00:04:57,910
we're actually cloning it and this is a

00:04:55,510 --> 00:04:59,380
initiator node is going to add the

00:04:57,910 --> 00:05:02,830
telemetry instructions so this is

00:04:59,380 --> 00:05:04,680
something configured by your data center

00:05:02,830 --> 00:05:06,880
administrator your IFA administrator

00:05:04,680 --> 00:05:08,260
again could be in band could be out of

00:05:06,880 --> 00:05:11,199
band in this particular example I have

00:05:08,260 --> 00:05:16,659
drawn it as out of band so cloned

00:05:11,199 --> 00:05:18,099
I the next is a transit node so these

00:05:16,659 --> 00:05:19,689
are the nodes that are going to provide

00:05:18,099 --> 00:05:21,310
us interesting information they're going

00:05:19,689 --> 00:05:23,169
to notice that a telemetry instruction

00:05:21,310 --> 00:05:26,110
exists they're not doing any cloning

00:05:23,169 --> 00:05:31,389
there they're only adding data in line

00:05:26,110 --> 00:05:33,340
so this is the the pieces most that's

00:05:31,389 --> 00:05:34,330
critical in a lot of ways because this

00:05:33,340 --> 00:05:37,620
is what's going to give you information

00:05:34,330 --> 00:05:40,560
as you traverse through the network and

00:05:37,620 --> 00:05:43,199
it's only again it's only going to add

00:05:40,560 --> 00:05:46,509
telemetry data to frames that contain

00:05:43,199 --> 00:05:48,339
telemetry instructions and these ifá or

00:05:46,509 --> 00:05:51,520
int headers we'll talk about what those

00:05:48,339 --> 00:05:53,169
look like in a little bit then we have a

00:05:51,520 --> 00:05:57,009
sink or a terminating note or a

00:05:53,169 --> 00:05:59,620
terminator node and these these are

00:05:57,009 --> 00:06:01,029
moved telemetry headers from frames send

00:05:59,620 --> 00:06:04,419
them to a collector not really that

00:06:01,029 --> 00:06:05,889
complex so in two cases the two

00:06:04,419 --> 00:06:07,599
different worse you know workflows you

00:06:05,889 --> 00:06:09,789
think about if this is a frame that was

00:06:07,599 --> 00:06:12,610
modified as a traverser network and in

00:06:09,789 --> 00:06:14,499
situ frame or an in band you take

00:06:12,610 --> 00:06:16,300
telemetry instructions out a telemetry

00:06:14,499 --> 00:06:18,639
data you may or may not send it to a

00:06:16,300 --> 00:06:20,740
collector node one of the keys about

00:06:18,639 --> 00:06:23,529
this is that there's no guarantee that

00:06:20,740 --> 00:06:26,199
you send everything to a collector part

00:06:23,529 --> 00:06:30,399
of these the idea behind this is that if

00:06:26,199 --> 00:06:32,439
you're within what you'd consider to be

00:06:30,399 --> 00:06:34,000
an acceptable range whether it's latency

00:06:32,439 --> 00:06:36,129
whether it's number of hops other things

00:06:34,000 --> 00:06:37,870
there's no reason to send send this to

00:06:36,129 --> 00:06:40,180
your collector - maybe not overload your

00:06:37,870 --> 00:06:43,120
collector when you're talking about you

00:06:40,180 --> 00:06:46,560
know terabit networking speeds this

00:06:43,120 --> 00:06:46,560
could be a lot of data even at 1%

00:06:46,919 --> 00:06:52,830
if if it is a clone frame what will

00:06:51,120 --> 00:06:54,030
happen is you just you drop it when

00:06:52,830 --> 00:06:55,590
you're done you don't need to send it on

00:06:54,030 --> 00:06:57,930
so that's one of the advantages to

00:06:55,590 --> 00:06:59,639
cloning you look at the data take out

00:06:57,930 --> 00:07:01,680
what you need drop the Flint frame on

00:06:59,639 --> 00:07:03,539
the floor you're done all right so using

00:07:01,680 --> 00:07:06,120
these are the key components last one

00:07:03,539 --> 00:07:08,009
the collector of course and any generic

00:07:06,120 --> 00:07:11,180
application will receive receive this

00:07:08,009 --> 00:07:14,759
data from a sink or terminating node so

00:07:11,180 --> 00:07:17,759
initiator transit Terminator pretty

00:07:14,759 --> 00:07:19,409
simple stuff all right so first one

00:07:17,759 --> 00:07:22,469
we'll talk about is is in band network

00:07:19,409 --> 00:07:24,689
telemetry so this is kind of I think the

00:07:22,469 --> 00:07:27,330
first one of the of the two we'll talk

00:07:24,689 --> 00:07:29,370
about today that appeared it's really a

00:07:27,330 --> 00:07:32,129
framework that you see suggested by p4

00:07:29,370 --> 00:07:32,819
group the idea is it's in band

00:07:32,129 --> 00:07:34,319
monitoring

00:07:32,819 --> 00:07:36,360
so as the frames reverse the network

00:07:34,319 --> 00:07:37,949
this is somewhat unsurprising if you

00:07:36,360 --> 00:07:40,259
think about p4 as a program with a

00:07:37,949 --> 00:07:42,779
pipeline that they have this opportunity

00:07:40,259 --> 00:07:45,409
to do things right in the middle because

00:07:42,779 --> 00:07:52,420
they're defining everything as they go

00:07:45,409 --> 00:07:56,830
so no fixed function worries there so

00:07:52,420 --> 00:07:58,840
this the the unban telemetry the IMT

00:07:56,830 --> 00:08:00,190
spec is pretty large and it goes over a

00:07:58,840 --> 00:08:03,670
pretty significant number of frame

00:08:00,190 --> 00:08:05,920
formats apparently that's like no good

00:08:03,670 --> 00:08:10,840
all right we're back excellent

00:08:05,920 --> 00:08:14,140
all right didn't notice so they it goes

00:08:10,840 --> 00:08:15,250
over int over V X land so again this is

00:08:14,140 --> 00:08:18,610
like this is like what we talked about

00:08:15,250 --> 00:08:22,810
with IO am a GP e extension as int over

00:08:18,610 --> 00:08:25,660
genève int over GRE over network service

00:08:22,810 --> 00:08:26,950
editor all sorts of different ways and

00:08:25,660 --> 00:08:29,050
then they talk just a little bit at the

00:08:26,950 --> 00:08:32,500
end like oh well here's how you do it if

00:08:29,050 --> 00:08:34,480
I PV ipv4 ipv6 and if it's a standard

00:08:32,500 --> 00:08:37,210
TCP or UDP payload I think when you

00:08:34,480 --> 00:08:40,750
think about that this standard as it is

00:08:37,210 --> 00:08:42,850
is really designed to use a lot of those

00:08:40,750 --> 00:08:44,500
same overlay technologies that are used

00:08:42,850 --> 00:08:47,680
across the data center so it's not

00:08:44,500 --> 00:08:50,560
surprising and this in this case the

00:08:47,680 --> 00:08:52,810
ipv4 ipv6 standard stuff the header is

00:08:50,560 --> 00:08:56,100
added and the metadata there

00:08:52,810 --> 00:08:58,840
transparently added to the payload so

00:08:56,100 --> 00:09:00,540
sounds like it seems relatively

00:08:58,840 --> 00:09:03,280
reasonable if we were again to look at a

00:09:00,540 --> 00:09:06,970
completely stolen from the spec frame

00:09:03,280 --> 00:09:09,340
format IP header layer for header now we

00:09:06,970 --> 00:09:11,140
have our our int shim it's got some

00:09:09,340 --> 00:09:12,700
information and our int metadata that's

00:09:11,140 --> 00:09:14,680
been added and our payload at the end

00:09:12,700 --> 00:09:16,390
the important part to think think about

00:09:14,680 --> 00:09:18,250
with these three these last three bits

00:09:16,390 --> 00:09:22,600
is technically those are all seen as the

00:09:18,250 --> 00:09:25,030
payload as far as the the first two

00:09:22,600 --> 00:09:26,680
headers are concerned so all right see

00:09:25,030 --> 00:09:28,540
who's paying attention who's awake who

00:09:26,680 --> 00:09:30,670
who attended to talk yesterday that

00:09:28,540 --> 00:09:33,210
might might cause problems here anybody

00:09:30,670 --> 00:09:33,210
have any ideas

00:09:33,380 --> 00:09:43,170
okay why would quick be a problem okay

00:09:40,040 --> 00:09:45,480
so yeah the key here is that if quick is

00:09:43,170 --> 00:09:46,470
expected one you're absolutely right I

00:09:45,480 --> 00:09:48,150
was kind of even thinking about a

00:09:46,470 --> 00:09:50,040
different angle so if your payload is

00:09:48,150 --> 00:09:51,660
expected to be encrypted and you're

00:09:50,040 --> 00:09:53,300
thinking about it's quick you're

00:09:51,660 --> 00:09:56,610
obviously going to run into problems if

00:09:53,300 --> 00:09:57,540
like you could have issues the great

00:09:56,610 --> 00:10:01,860
thing about all these is they're all

00:09:57,540 --> 00:10:03,060
going to have some issues this is the

00:10:01,860 --> 00:10:04,200
way it works right they're all gonna

00:10:03,060 --> 00:10:07,050
have they're all gonna have some

00:10:04,200 --> 00:10:09,180
problems but I think the thing is people

00:10:07,050 --> 00:10:11,640
are people are really interested in this

00:10:09,180 --> 00:10:13,500
so we've got a we've got to be ahead of

00:10:11,640 --> 00:10:15,180
it or be aware of it so I think the fact

00:10:13,500 --> 00:10:17,070
that it's inserted in the payload could

00:10:15,180 --> 00:10:20,010
be somewhat problematic especially as

00:10:17,070 --> 00:10:21,360
you say like the way boxes I mean this

00:10:20,010 --> 00:10:22,800
is something that is running kind of on

00:10:21,360 --> 00:10:24,600
middleboxes so or maybe we're part of

00:10:22,800 --> 00:10:25,830
the problem with quick or part of the

00:10:24,600 --> 00:10:28,440
problem for quick but I think this is

00:10:25,830 --> 00:10:32,480
important to think about the the payload

00:10:28,440 --> 00:10:35,820
being being sort of faked in this case

00:10:32,480 --> 00:10:42,140
so yeah all right

00:10:35,820 --> 00:10:42,140
I can well there's a button

00:10:47,410 --> 00:10:51,580
maybe I maybe I have the second mic

00:10:54,660 --> 00:11:01,300
so in this case what is what is the

00:10:57,820 --> 00:11:02,800
protocol in the IP header in this case

00:11:01,300 --> 00:11:07,209
it's the same protocol as it was before

00:11:02,800 --> 00:11:12,220
so TCP how can this possibly work if I'm

00:11:07,209 --> 00:11:14,860
putting data into the TCP stream yeah

00:11:12,220 --> 00:11:16,600
there's so there's parts about it so you

00:11:14,860 --> 00:11:21,720
could if you extract it before someone

00:11:16,600 --> 00:11:21,720
else consumes it it could work in theory

00:11:24,090 --> 00:11:34,170
people actually doing this in real life

00:11:26,160 --> 00:11:36,660
this I don't know yeah okay no so Tom

00:11:34,170 --> 00:11:39,120
the answer is the expectation is that

00:11:36,660 --> 00:11:41,550
you'd the int data doesn't leave the int

00:11:39,120 --> 00:11:42,930
Network right that's right so this is

00:11:41,550 --> 00:11:44,940
actually thank you this is an important

00:11:42,930 --> 00:11:46,290
point that I think I added to a version

00:11:44,940 --> 00:11:49,680
three of these slides that didn't exist

00:11:46,290 --> 00:11:50,970
let me go back but it's right here all

00:11:49,680 --> 00:11:53,510
right so the last piece I didn't mention

00:11:50,970 --> 00:11:56,340
this whole thing so thank you the the

00:11:53,510 --> 00:11:58,050
what does int network mean then I'm

00:11:56,340 --> 00:12:01,230
getting ready to say it excellent segue

00:11:58,050 --> 00:12:02,550
Thank You Jamal so at the bottom you can

00:12:01,230 --> 00:12:05,130
see this is these are considered it

00:12:02,550 --> 00:12:06,960
within an IFA domain so from the

00:12:05,130 --> 00:12:08,910
initiator node the beginning to the to

00:12:06,960 --> 00:12:10,290
the terminating node this is considered

00:12:08,910 --> 00:12:12,870
the domain and the idea would be this is

00:12:10,290 --> 00:12:14,430
inside your data center so the the

00:12:12,870 --> 00:12:16,080
problematic part about this is it's not

00:12:14,430 --> 00:12:18,540
designed to exit your data center which

00:12:16,080 --> 00:12:21,270
is maybe good maybe bad so I mean from a

00:12:18,540 --> 00:12:23,430
consumption standpoint obviously the

00:12:21,270 --> 00:12:25,080
idea is that the remote device doing the

00:12:23,430 --> 00:12:30,780
reception of these frames would already

00:12:25,080 --> 00:12:32,190
have the int data removed from it so you

00:12:30,780 --> 00:12:34,490
mentioned you had the slides with

00:12:32,190 --> 00:12:38,430
Overland networks can you go there like

00:12:34,490 --> 00:12:41,610
absolutely when you say that it's it's

00:12:38,430 --> 00:12:44,300
convenient in for the X LAN and genève

00:12:41,610 --> 00:12:46,620
you mean that the V tip does that or

00:12:44,300 --> 00:12:49,440
like you did it - let me tree where you

00:12:46,620 --> 00:12:53,790
do the encapsulation in the same point

00:12:49,440 --> 00:12:56,400
in the fabric or you could yes I think

00:12:53,790 --> 00:12:58,800
the other option is that further per the

00:12:56,400 --> 00:13:01,680
GPE extension you could add the int data

00:12:58,800 --> 00:13:04,530
there so if the encapsulation had

00:13:01,680 --> 00:13:07,930
already been done the standard supports

00:13:04,530 --> 00:13:10,240
the extension to do that

00:13:07,930 --> 00:13:15,040
okay I didn't write the standard just

00:13:10,240 --> 00:13:17,890
side square and that well and I've given

00:13:15,040 --> 00:13:19,960
so alright these are all fair questions

00:13:17,890 --> 00:13:21,390
that I mean I'm happy to answer them as

00:13:19,960 --> 00:13:23,770
best I can

00:13:21,390 --> 00:13:25,290
alright so I think we've gone so I want

00:13:23,770 --> 00:13:26,830
to move on to IFA because I think

00:13:25,290 --> 00:13:30,760
personally I think this one's a little

00:13:26,830 --> 00:13:32,380
more interesting and so that is the the

00:13:30,760 --> 00:13:33,970
first version of this I was released a

00:13:32,380 --> 00:13:37,030
little bit later I mean these things are

00:13:33,970 --> 00:13:38,320
new enough so we had the IFA 1.0 I think

00:13:37,030 --> 00:13:40,510
we're calling it that the first version

00:13:38,320 --> 00:13:41,650
of it was released late last year and

00:13:40,510 --> 00:13:44,710
there's actually a second version that

00:13:41,650 --> 00:13:47,220
came out I think in February so these

00:13:44,710 --> 00:13:52,600
things are actually moving pretty fast

00:13:47,220 --> 00:13:54,490
so the idea behind it is that not only

00:13:52,600 --> 00:13:58,150
can you add telemetry instructions and

00:13:54,490 --> 00:14:00,160
then metadata in-band if you'd like it

00:13:58,150 --> 00:14:02,980
also provides the capability to do

00:14:00,160 --> 00:14:04,450
sampling and send it out AB and so the

00:14:02,980 --> 00:14:08,710
sampling one is interesting because it

00:14:04,450 --> 00:14:11,320
actually probably allows hardware or

00:14:08,710 --> 00:14:12,610
devices in the middle that maybe don't

00:14:11,320 --> 00:14:14,530
have native support in their data path

00:14:12,610 --> 00:14:16,480
for doing this it allows them to have

00:14:14,530 --> 00:14:18,580
the opportunity to sample a packet maybe

00:14:16,480 --> 00:14:20,470
have it run on a host CPU and do

00:14:18,580 --> 00:14:22,810
something different now of course you're

00:14:20,470 --> 00:14:25,600
gonna get a little bit of you gonna have

00:14:22,810 --> 00:14:26,950
some latency there but I think that's

00:14:25,600 --> 00:14:28,810
one of the reasons I think this is

00:14:26,950 --> 00:14:30,400
interesting also when we talk about the

00:14:28,810 --> 00:14:31,380
sampling case the frames can be dropped

00:14:30,400 --> 00:14:34,180
on the way out

00:14:31,380 --> 00:14:36,400
you don't have to deal with them and the

00:14:34,180 --> 00:14:38,430
frame format the aim is for it to be a

00:14:36,400 --> 00:14:40,600
little bit more compatible with hardware

00:14:38,430 --> 00:14:43,780
everyone will probably notice some of

00:14:40,600 --> 00:14:46,150
the issues with that right here so in

00:14:43,780 --> 00:14:48,400
this case if we had an ipv4 TCP frame

00:14:46,150 --> 00:14:50,440
now what we have is actually our IP

00:14:48,400 --> 00:14:52,300
header then we have an IFA header

00:14:50,440 --> 00:14:54,430
inserted then we have our layer 4 data

00:14:52,300 --> 00:14:56,710
so the way this is done differently is

00:14:54,430 --> 00:14:59,620
the next protocol for IP instead of

00:14:56,710 --> 00:15:02,050
being TCP or UDP in this case it'll be

00:14:59,620 --> 00:15:05,860
it would be specified as something the

00:15:02,050 --> 00:15:08,800
IFA now right now there's no I in a

00:15:05,860 --> 00:15:10,490
reserved address for this so anyone

00:15:08,800 --> 00:15:11,960
doing this work

00:15:10,490 --> 00:15:15,640
would be doing this probably on one of

00:15:11,960 --> 00:15:19,520
the two experimental ones so 253 or 254

00:15:15,640 --> 00:15:22,190
so you so in in that case any middle

00:15:19,520 --> 00:15:23,600
boxes that are there might end up not

00:15:22,190 --> 00:15:27,620
quite knowing what to do with this and

00:15:23,600 --> 00:15:28,970
in that case it's not unexpected but

00:15:27,620 --> 00:15:31,190
it's a little bit different than then

00:15:28,970 --> 00:15:32,570
the way this is designed to do that the

00:15:31,190 --> 00:15:36,140
idea is that you're not going to skip

00:15:32,570 --> 00:15:39,710
devices but in fact the protocol

00:15:36,140 --> 00:15:41,210
actually outlines ways to look at TTL x'

00:15:39,710 --> 00:15:43,010
that have been decremented or other

00:15:41,210 --> 00:15:45,440
other indicators that a packets been

00:15:43,010 --> 00:15:46,610
forwarded without metadata being added

00:15:45,440 --> 00:15:48,200
so this is one of the things that can

00:15:46,610 --> 00:15:50,450
actually detect this hey there's a box

00:15:48,200 --> 00:15:52,370
in my network that's it's doing

00:15:50,450 --> 00:15:54,850
something to these packets it's maybe

00:15:52,370 --> 00:15:59,870
forwarding these packets maybe not and

00:15:54,850 --> 00:16:01,880
is not participating in IFA so we love

00:15:59,870 --> 00:16:05,030
we love participation so you know we

00:16:01,880 --> 00:16:06,770
don't want to don't have that but again

00:16:05,030 --> 00:16:10,700
now we haven't we haven't taken this

00:16:06,770 --> 00:16:12,800
sorry so we haven't taken this and sort

00:16:10,700 --> 00:16:14,660
of faked out our payload it's fairly

00:16:12,800 --> 00:16:19,010
well known and this is fairly it's well

00:16:14,660 --> 00:16:20,930
described so as I mentioned here the

00:16:19,010 --> 00:16:22,790
protocol would be something that would

00:16:20,930 --> 00:16:25,100
mark it as IFA if you're implementing

00:16:22,790 --> 00:16:27,320
this today said maybe you'd use 253 or

00:16:25,100 --> 00:16:30,860
250 for since those are left as

00:16:27,320 --> 00:16:32,330
experimental in theory that there'd be a

00:16:30,860 --> 00:16:33,410
reservation made for that I don't know

00:16:32,330 --> 00:16:35,330
that the standard has pushed themselves

00:16:33,410 --> 00:16:37,780
to the point where they're ready to make

00:16:35,330 --> 00:16:37,780
a reservation

00:16:38,600 --> 00:16:42,260
so those are the kind of the key

00:16:40,850 --> 00:16:48,370
components all right Tom's got another

00:16:42,260 --> 00:16:48,370
question excellent keep me on my game

00:16:49,480 --> 00:16:53,860
okay can you go back one slide

00:16:55,450 --> 00:17:03,440
okay so ipv4 what about ipv6 yeah ipv6

00:17:00,920 --> 00:17:07,640
has the it's the same idea you specify

00:17:03,440 --> 00:17:10,850
the protocol the next protocol as IFA it

00:17:07,640 --> 00:17:12,230
there are it does also outline what

00:17:10,850 --> 00:17:14,510
you're going to want to hear which is

00:17:12,230 --> 00:17:16,640
using extension headers for some of this

00:17:14,510 --> 00:17:19,130
information so so let's talk about ipv6

00:17:16,640 --> 00:17:20,930
for one second sure why would you need a

00:17:19,130 --> 00:17:22,160
new protocol if we have extension

00:17:20,930 --> 00:17:27,320
headers that already have all the

00:17:22,160 --> 00:17:29,840
functionality great question okay so if

00:17:27,320 --> 00:17:34,070
you accept premise number a go back to

00:17:29,840 --> 00:17:37,220
the ipv4 I think last week or two weeks

00:17:34,070 --> 00:17:38,930
ago I posted the internet draft that

00:17:37,220 --> 00:17:41,540
says it says how to use extension

00:17:38,930 --> 00:17:44,960
headers in ipv4 mm-hmm so now instead of

00:17:41,540 --> 00:17:46,640
having an IFA protocol you can just use

00:17:44,960 --> 00:17:49,970
a hop-by-hop option and you can get

00:17:46,640 --> 00:17:51,710
exactly the same format in ipv6 no new

00:17:49,970 --> 00:17:53,630
protocol necessary that would be awesome

00:17:51,710 --> 00:17:55,760
that'd be awesome but who do I talk

00:17:53,630 --> 00:17:58,010
about oh yeah make sure that happens

00:17:55,760 --> 00:17:59,810
because this is exactly perfect in that

00:17:58,010 --> 00:18:00,290
sense yeah well yeah we'll talk

00:17:59,810 --> 00:18:05,560
afterwards

00:18:00,290 --> 00:18:09,770
cool Tommy's in that hope I hope

00:18:05,560 --> 00:18:10,880
hop-by-hop options yeah yeah this is

00:18:09,770 --> 00:18:14,540
gonna give you a little bit more

00:18:10,880 --> 00:18:18,100
information so part of the problem here

00:18:14,540 --> 00:18:21,560
right is like was said earlier the the

00:18:18,100 --> 00:18:23,900
analysis traffic is supposed to be data

00:18:21,560 --> 00:18:26,810
center wide not necessarily hop-by-hop

00:18:23,900 --> 00:18:29,600
or not aggregated at any home

00:18:26,810 --> 00:18:31,580
so so read up on how by hop options what

00:18:29,600 --> 00:18:33,350
they are is you can put these in a

00:18:31,580 --> 00:18:36,490
packet they can be inspected by

00:18:33,350 --> 00:18:38,889
intermediate hops they can be modified

00:18:36,490 --> 00:18:41,919
there's a way to do that so one of the

00:18:38,889 --> 00:18:43,840
problems on that slide that had genève

00:18:41,919 --> 00:18:47,110
and the X LAN and stuff like that

00:18:43,840 --> 00:18:49,809
they're in UDP and if we have devices

00:18:47,110 --> 00:18:52,090
going into UDP and modifying payload

00:18:49,809 --> 00:18:54,399
there's a fundamental problem because

00:18:52,090 --> 00:18:55,629
the way you identify those as being the

00:18:54,399 --> 00:18:58,179
payload you're interested in is by

00:18:55,629 --> 00:19:01,269
destination port however destination

00:18:58,179 --> 00:19:04,389
port are not reserved so for instance

00:19:01,269 --> 00:19:06,970
the genève port number I can use that in

00:19:04,389 --> 00:19:09,159
my data center to be any traffic I want

00:19:06,970 --> 00:19:12,730
and if I have something going into

00:19:09,159 --> 00:19:13,929
packets and modifying data because they

00:19:12,730 --> 00:19:14,679
think it's something else than it

00:19:13,929 --> 00:19:17,409
actually is

00:19:14,679 --> 00:19:20,019
we have silent data corruption so the

00:19:17,409 --> 00:19:21,759
idea of going into UDP packets and

00:19:20,019 --> 00:19:25,960
modifying data even in the data center

00:19:21,759 --> 00:19:28,570
very risky I'm not arguing against the

00:19:25,960 --> 00:19:31,299
risky part the design here is fairly

00:19:28,570 --> 00:19:34,330
simple switches while traffic is going

00:19:31,299 --> 00:19:35,740
through will insert this into because

00:19:34,330 --> 00:19:37,869
there are any we're tracking the header

00:19:35,740 --> 00:19:40,419
separately from the payload so they'll

00:19:37,869 --> 00:19:41,679
insert this data in between the header

00:19:40,419 --> 00:19:43,960
and the payload and pass it on

00:19:41,679 --> 00:19:46,509
effectively but the dáil data in that

00:19:43,960 --> 00:19:48,970
case is actually the payload so like

00:19:46,509 --> 00:19:50,799
Andy said we want this to be in headers

00:19:48,970 --> 00:19:53,980
outside of the payload between the IP

00:19:50,799 --> 00:19:56,139
header and the actual transport then

00:19:53,980 --> 00:19:57,820
there's very few ways that's the only

00:19:56,139 --> 00:19:58,899
one way to actually do that correctly no

00:19:57,820 --> 00:20:00,730
no that's right so I think you're right

00:19:58,899 --> 00:20:02,230
I mean the car these guys came up with

00:20:00,730 --> 00:20:06,220
like we'll just stick it in the front of

00:20:02,230 --> 00:20:09,869
the payload I'm interested to see how

00:20:06,220 --> 00:20:13,960
this works in TCP still yeah

00:20:09,869 --> 00:20:16,119
alright okay so one of the things I

00:20:13,960 --> 00:20:17,619
wanted to do now that I've given you

00:20:16,119 --> 00:20:19,690
this brief introduction to these

00:20:17,619 --> 00:20:20,590
technologies I just talked about how

00:20:19,690 --> 00:20:21,820
would this would fit in the Linux

00:20:20,590 --> 00:20:23,740
ecosystem

00:20:21,820 --> 00:20:25,029
what kind of components we need what

00:20:23,740 --> 00:20:27,070
kind of modifications we need so I broke

00:20:25,029 --> 00:20:29,110
down each node and what what what we

00:20:27,070 --> 00:20:30,759
would need to get some of this done some

00:20:29,110 --> 00:20:33,340
of these are not completely functional

00:20:30,759 --> 00:20:37,119
but these are ideas of where we could do

00:20:33,340 --> 00:20:39,220
this and all right so the key sort of

00:20:37,119 --> 00:20:41,799
operations for initiator is the sample

00:20:39,220 --> 00:20:45,129
easily TC netfilter we can do both these

00:20:41,799 --> 00:20:46,509
now mirror TC does this now redirecting

00:20:45,129 --> 00:20:49,990
the packets we can either do this with

00:20:46,509 --> 00:20:52,990
TC or everybody's favorite we can do x d

00:20:49,990 --> 00:20:54,340
PT b PF programs to do this and then if

00:20:52,990 --> 00:20:56,909
we want to do incapsulate and transmit

00:20:54,340 --> 00:20:58,720
the interesting part about this is that

00:20:56,909 --> 00:20:59,950
encapsulating and putting in this frame

00:20:58,720 --> 00:21:02,200
format would be something that would be

00:20:59,950 --> 00:21:04,179
really very similar actually to the

00:21:02,200 --> 00:21:06,129
recent sort of kernel edition for ER

00:21:04,179 --> 00:21:07,779
spam so we're talking about taking a

00:21:06,129 --> 00:21:10,119
frame that was there already putting it

00:21:07,779 --> 00:21:12,009
inside sort of another header adding

00:21:10,119 --> 00:21:14,259
some more some more information so we

00:21:12,009 --> 00:21:16,269
could do similar to the how that's done

00:21:14,259 --> 00:21:19,629
right now which is lightweight tunnels

00:21:16,269 --> 00:21:21,129
the new net dev type could also again

00:21:19,629 --> 00:21:24,940
because you can do everything with x TP

00:21:21,129 --> 00:21:28,090
or eb PF you could do it there so if

00:21:24,940 --> 00:21:31,059
we're gonna do a transit hop match we're

00:21:28,090 --> 00:21:32,860
gonna match on this int or IFA frame we

00:21:31,059 --> 00:21:35,049
can do this with TC no problem update

00:21:32,860 --> 00:21:37,419
the metadata again I think the right the

00:21:35,049 --> 00:21:40,529
right option here is to consider using a

00:21:37,419 --> 00:21:40,529
new lightweight tunnel type

00:21:41,940 --> 00:21:46,770
in the sink note or the terminating node

00:21:43,860 --> 00:21:49,710
again TC netfilter both of those can do

00:21:46,770 --> 00:21:52,260
this collect the metadata consider

00:21:49,710 --> 00:21:54,030
sending it on sending it and then

00:21:52,260 --> 00:21:57,260
transmitting in the original frame in

00:21:54,030 --> 00:21:59,190
the int case or the IFA non sampled case

00:21:57,260 --> 00:22:01,680
again I think the right the right

00:21:59,190 --> 00:22:06,180
probably mode here is to consider using

00:22:01,680 --> 00:22:08,130
a lightweight tunnel type same situation

00:22:06,180 --> 00:22:09,060
so the cool thing is that Linux kernel

00:22:08,130 --> 00:22:11,280
has a lot of these building blocks

00:22:09,060 --> 00:22:15,240
already in place to allow us to support

00:22:11,280 --> 00:22:16,200
this new technology this new thing and I

00:22:15,240 --> 00:22:17,070
think that's kind of nice they're all

00:22:16,200 --> 00:22:18,990
going to require a little bit of

00:22:17,070 --> 00:22:21,150
modification a lot of the mirroring for

00:22:18,990 --> 00:22:23,010
example and sampling is actually thought

00:22:21,150 --> 00:22:24,660
of typically right now is on the receive

00:22:23,010 --> 00:22:27,650
side whereas this would be typically

00:22:24,660 --> 00:22:31,020
done on the transmit side but either way

00:22:27,650 --> 00:22:32,760
it's cool we're close hey can you go to

00:22:31,020 --> 00:22:36,630
the slide which note is the one that

00:22:32,760 --> 00:22:38,700
adds the telemetry the the the transit

00:22:36,630 --> 00:22:40,650
node or the transit hop is the one that

00:22:38,700 --> 00:22:42,360
I'm sorry repeat your question that

00:22:40,650 --> 00:22:45,570
which one of is the no that actually

00:22:42,360 --> 00:22:50,100
adds the telemetry data so this the

00:22:45,570 --> 00:22:51,840
transit hop adds it along the way so the

00:22:50,100 --> 00:22:52,980
source node or the initiator node is the

00:22:51,840 --> 00:22:54,450
one that does the sampling of the

00:22:52,980 --> 00:22:57,480
traffic and decides to add the

00:22:54,450 --> 00:23:00,720
instructions yes this one this one so

00:22:57,480 --> 00:23:04,080
how do you suggest to add to model the

00:23:00,720 --> 00:23:08,640
adding of the instruction by lightweight

00:23:04,080 --> 00:23:12,600
ah no yes because if you do the matching

00:23:08,640 --> 00:23:15,550
in TC you don't want to you can also

00:23:12,600 --> 00:23:18,160
have the tunnel in this you know

00:23:15,550 --> 00:23:21,070
the header no or you want to do it with

00:23:18,160 --> 00:23:23,770
the time I'm walking so because a lot of

00:23:21,070 --> 00:23:26,290
the fields are configurable it felt like

00:23:23,770 --> 00:23:27,580
doing it with a lightweight tunnel felt

00:23:26,290 --> 00:23:30,370
like a better it felt like a good option

00:23:27,580 --> 00:23:32,470
and I'm not married to all these these

00:23:30,370 --> 00:23:33,940
ideas but and when you say package

00:23:32,470 --> 00:23:39,460
sampling with DC you referred to this

00:23:33,940 --> 00:23:41,980
sample actually yeah good yeah sorry I

00:23:39,460 --> 00:23:44,470
agree with with or you could you could

00:23:41,980 --> 00:23:50,130
do the encapsulation with genève and in

00:23:44,470 --> 00:23:50,130
TC yeah yeah we could do it there too

00:23:50,400 --> 00:23:57,850
okay all right so nothing would be

00:23:55,960 --> 00:24:00,940
complete without sort of thinking beyond

00:23:57,850 --> 00:24:03,070
the kernel data path a little bit so as

00:24:00,940 --> 00:24:05,050
was mentioned you know switch hardware

00:24:03,070 --> 00:24:06,730
it's probably gonna people are gonna

00:24:05,050 --> 00:24:09,670
people are interested in this you can

00:24:06,730 --> 00:24:11,830
you can know that you know in int is

00:24:09,670 --> 00:24:15,130
backed by sort of p4 and they're clearly

00:24:11,830 --> 00:24:16,120
people building switches based on p4 but

00:24:15,130 --> 00:24:19,540
that's of course not limited to

00:24:16,120 --> 00:24:21,100
programmable data planes and really

00:24:19,540 --> 00:24:23,140
customer demand is going to dictate

00:24:21,100 --> 00:24:24,460
whether or not this is supported on you

00:24:23,140 --> 00:24:26,110
know only something with programmable

00:24:24,460 --> 00:24:31,030
data planes or more fixed function

00:24:26,110 --> 00:24:32,830
devices yeah another comment that will

00:24:31,030 --> 00:24:34,780
be happy to hear that so what well you

00:24:32,830 --> 00:24:36,850
start playing is all this telemetry data

00:24:34,780 --> 00:24:40,810
I think the importance of support for

00:24:36,850 --> 00:24:42,220
Jackson complete well so guys so far

00:24:40,810 --> 00:24:43,600
only the milan's driver supposed checks

00:24:42,220 --> 00:24:45,240
on complete you're gonna really gonna

00:24:43,600 --> 00:24:48,490
mess if you're not gonna support it soon

00:24:45,240 --> 00:24:51,400
and another comment is that with the

00:24:48,490 --> 00:24:53,260
kind of data pass because the package

00:24:51,400 --> 00:24:55,480
reverse between the layers in the kernel

00:24:53,260 --> 00:24:58,720
and and the headers are being taken into

00:24:55,480 --> 00:25:01,720
the into the cash the checks on complete

00:24:58,720 --> 00:25:03,460
is not doesn't exist but in DP decay

00:25:01,720 --> 00:25:05,740
it's a real mess because in PP decay

00:25:03,460 --> 00:25:07,270
that the driver

00:25:05,740 --> 00:25:12,300
it's only a driver right it's not a

00:25:07,270 --> 00:25:15,790
stack so they only they do not put the

00:25:12,300 --> 00:25:17,560
l3 and l4 headers into the cache and in

00:25:15,790 --> 00:25:20,350
Mellanox when we did experiments in

00:25:17,560 --> 00:25:22,960
frozen checks and complete there it was

00:25:20,350 --> 00:25:25,610
a disaster because they have to so

00:25:22,960 --> 00:25:28,430
deeply care is really in deep

00:25:25,610 --> 00:25:33,950
because this with this can I quote you

00:25:28,430 --> 00:25:36,650
on that I don't understand the problem

00:25:33,950 --> 00:25:39,250
so DP DK doesn't look at l3 and l4

00:25:36,650 --> 00:25:39,250
headers

00:25:48,259 --> 00:25:56,879
right but but but I don't know I'm

00:25:55,049 --> 00:25:59,039
missing something fundamental so DPD

00:25:56,879 --> 00:26:01,919
case is getting a raw frame it has to

00:25:59,039 --> 00:26:05,070
look at the l3 l4 headers right it has

00:26:01,919 --> 00:26:09,889
to take the cash mess I love the healthy

00:26:05,070 --> 00:26:09,889
discussion but can I try to okay sorry

00:26:10,049 --> 00:26:18,419
last question okay let me yeah I think

00:26:16,679 --> 00:26:20,399
well let me just say this

00:26:18,419 --> 00:26:23,489
yeah so the the other thing again sort

00:26:20,399 --> 00:26:24,869
of like I said before like switch

00:26:23,489 --> 00:26:26,970
Hardware NIC card was gonna have support

00:26:24,869 --> 00:26:29,759
as people ask for it it's unsurprising

00:26:26,970 --> 00:26:31,889
to think about it that way yeah the rest

00:26:29,759 --> 00:26:33,119
of these one of the other things one of

00:26:31,889 --> 00:26:35,159
the other pieces for us to just be aware

00:26:33,119 --> 00:26:36,869
of is that network based configuration

00:26:35,159 --> 00:26:39,480
so something where your device is

00:26:36,869 --> 00:26:42,090
actually being configured remotely is

00:26:39,480 --> 00:26:44,789
something that's an interesting data

00:26:42,090 --> 00:26:46,289
center trend so the hardest part is

00:26:44,789 --> 00:26:47,369
whether you know it or not there's gonna

00:26:46,289 --> 00:26:49,320
be a chance that you're going to have a

00:26:47,369 --> 00:26:51,960
NIC or you're gonna have a switch that

00:26:49,320 --> 00:26:53,249
has this feature turned on and it's

00:26:51,960 --> 00:26:55,799
happening and you don't know about it

00:26:53,249 --> 00:26:57,419
which is not great so we probably

00:26:55,799 --> 00:26:59,489
actually need to really pay attention

00:26:57,419 --> 00:27:00,809
and make sure that kernel support and

00:26:59,489 --> 00:27:03,989
other infrastructure supports there

00:27:00,809 --> 00:27:07,830
before it's it's there without us

00:27:03,989 --> 00:27:09,299
knowing it I'm going to quote or on DB

00:27:07,830 --> 00:27:15,769
DK being in deep

00:27:09,299 --> 00:27:15,769
but know that do use your question yeah

00:27:18,739 --> 00:27:23,249
so what what type of evidence is there

00:27:21,570 --> 00:27:25,409
that you know processing off these

00:27:23,249 --> 00:27:26,940
headers in a switch in the middle could

00:27:25,409 --> 00:27:28,769
be done at reasonable cost without

00:27:26,940 --> 00:27:31,259
adding delay right because I think the

00:27:28,769 --> 00:27:33,809
applications want to see the performance

00:27:31,259 --> 00:27:36,330
of traffic without that end you know yes

00:27:33,809 --> 00:27:38,039
I think that's why the the outer band or

00:27:36,330 --> 00:27:40,440
the sample based one is the most

00:27:38,039 --> 00:27:42,239
attractive because you're you're taking

00:27:40,440 --> 00:27:44,399
your regular data plane is still running

00:27:42,239 --> 00:27:45,929
and you've got this extra packet that's

00:27:44,399 --> 00:27:47,369
hopefully not too much extra packet

00:27:45,929 --> 00:27:50,700
because it's on a per flow too much

00:27:47,369 --> 00:27:53,009
extra Network load sampled on a per flow

00:27:50,700 --> 00:27:56,999
basis so I mean evidence I think the

00:27:53,009 --> 00:28:01,440
proof will be in implementation so yeah

00:27:56,999 --> 00:28:03,769
we're out of time I guess negative 36

00:28:01,440 --> 00:28:03,769

YouTube URL: https://www.youtube.com/watch?v=E4MWZLn-RCI


