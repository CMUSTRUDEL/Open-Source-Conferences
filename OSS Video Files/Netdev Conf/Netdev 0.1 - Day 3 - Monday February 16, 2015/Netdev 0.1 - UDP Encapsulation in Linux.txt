Title: Netdev 0.1 - UDP Encapsulation in Linux
Publication date: 2015-03-21
Playlist: Netdev 0.1 - Day 3 - Monday February 16, 2015
Description: 
	UDP Encapsulation in Linux
Tom Herbert
February 2015

Description from netdev01.org:
 A discussion about recent efforts to make UDP encapsulation performant and well supported in the Linux networking stack, and also an introduction of foo-over UDP (FOU) and Generic UDP Encapsulation(GUE).

UDP based encapsulation is likely to become ubiquitous in data centers, not just for virtualization use case but also for non-virtualization. The reasons for this are simple: it's a low overhead protocol and allows us to leverage several UDP specific optimizations commonly supported by networking hardware (RSS and ECMP for instance). In part one of this this talk, we'll review the additions to the Linux kernel to make UDP encapsulation efficient and a first class citizen of the stack.

For part two of this discussion, we'll look at foo-over-UDP (FOU). FOU is an encapsulation method to where IP protocol packets are directly encapsulated in a UDP payload. The first support of this is IPIP, sit, GRE tunnels which can be configured to transmit using FOU encapsulation. The GRE part implements the GRE/UDP draft.

For part three of this discussion, we'll look at Generic UDP Encapsulation (GUE) and Remote Checksum Offload. GUE is a lightweight, extensible, and performant encapsulation mechanism of IP protocol packets (indicated in a header field). The GUE header allows for optional data fields which which we intend to use for virtualization, security, and congestion control. 


https://www.netdev01.org

This video is licensed under Creative Commons Attribution-ShareAlike 4.0 International license. Feel free to download and distribute.
Captions: 
	00:00:06,080 --> 00:00:12,880
hi my name is Tom Robert I'm an engineer

00:00:10,550 --> 00:00:17,170
at Google and today I'm gonna talk about

00:00:12,880 --> 00:00:17,170
UDP encapsulation and Linux

00:00:17,890 --> 00:00:24,529
so basically kind of a broad topic

00:00:21,680 --> 00:00:27,680
actually or at least ended up to be a

00:00:24,529 --> 00:00:29,419
broad topic kind of combining a lot of

00:00:27,680 --> 00:00:32,509
many different technologies for good

00:00:29,419 --> 00:00:36,530
solution so one cover today is some of

00:00:32,509 --> 00:00:39,680
the basics of UDP encapsulation and then

00:00:36,530 --> 00:00:44,059
common offloads that we need to consider

00:00:39,680 --> 00:00:49,609
and then I'll present two forms of UDP

00:00:44,059 --> 00:00:52,579
encapsulation that we put into Linux so

00:00:49,609 --> 00:00:54,140
the basic idea of UDP encapsulation is

00:00:52,579 --> 00:00:57,710
actually pretty simple we have a

00:00:54,140 --> 00:01:00,289
networking packet sometimes it's an IP

00:00:57,710 --> 00:01:02,960
layer packet could be an Ethernet packet

00:01:00,289 --> 00:01:06,250
whatever and what we do is we put this

00:01:02,960 --> 00:01:10,190
into UDP payload in some fashion and

00:01:06,250 --> 00:01:14,480
there's two kind of methods that this is

00:01:10,190 --> 00:01:18,080
that are done so one is immediately

00:01:14,480 --> 00:01:20,180
following the UDP header is a packet the

00:01:18,080 --> 00:01:22,040
other one is immediately following the

00:01:20,180 --> 00:01:26,420
ADP header is another encapsulation

00:01:22,040 --> 00:01:29,540
header and then a packet so the first

00:01:26,420 --> 00:01:31,880
case if you think of ESP over UDP I

00:01:29,540 --> 00:01:35,060
think it's a great example where yes P

00:01:31,880 --> 00:01:36,980
is kind of the payload of UDP packet the

00:01:35,060 --> 00:01:38,810
second case is kind of more common in

00:01:36,980 --> 00:01:42,380
virtualization now I guess with the X

00:01:38,810 --> 00:01:46,220
LAN and that gram at the bottom kind of

00:01:42,380 --> 00:01:48,530
shows generic UDP encapsulation so you

00:01:46,220 --> 00:01:51,230
can see the progression of headers from

00:01:48,530 --> 00:01:53,630
the data packet that maybe a VM would

00:01:51,230 --> 00:01:56,150
send on a socket all the way down to the

00:01:53,630 --> 00:02:00,500
wire and it's just typical layered

00:01:56,150 --> 00:02:03,010
encapsulation and the UDP goo kind of on

00:02:00,500 --> 00:02:06,610
the third third row is the encapsulation

00:02:03,010 --> 00:02:06,610
layer for UDP

00:02:08,360 --> 00:02:14,870
so this is kind of a graph of the

00:02:12,920 --> 00:02:17,270
process of encapsulation in this example

00:02:14,870 --> 00:02:19,760
is kind of the canonical vm

00:02:17,270 --> 00:02:23,360
encapsulation so we have an application

00:02:19,760 --> 00:02:25,610
running in a guest Colonel again

00:02:23,360 --> 00:02:27,910
application sends data on a TCP socket

00:02:25,610 --> 00:02:30,740
for instance goes into the guest kernel

00:02:27,910 --> 00:02:33,500
that eventually goes into host kernel in

00:02:30,740 --> 00:02:35,150
this model host kernel at some point and

00:02:33,500 --> 00:02:38,780
capsule lights the packets so we're in

00:02:35,150 --> 00:02:42,650
capsule ating a virtual packet with

00:02:38,780 --> 00:02:44,390
virtual address for transport across an

00:02:42,650 --> 00:02:48,230
underlay so this is kind of the overlay

00:02:44,390 --> 00:02:50,000
network is implemented for the guest on

00:02:48,230 --> 00:02:52,250
your leg network is a physical network

00:02:50,000 --> 00:02:56,000
so we need a capsulation to facilitate

00:02:52,250 --> 00:02:58,790
transport across the underlay and that's

00:02:56,000 --> 00:03:01,670
kind of also known as tunneling a few

00:02:58,790 --> 00:03:03,350
terms around that so a packet goes down

00:03:01,670 --> 00:03:07,490
gets encapsulated it goes through IP

00:03:03,350 --> 00:03:09,860
goes through networking goes across to a

00:03:07,490 --> 00:03:12,440
pure machine and then the reverse

00:03:09,860 --> 00:03:14,380
happens so we D capsulate meaning the

00:03:12,440 --> 00:03:16,700
encapsulation headers are removed and

00:03:14,380 --> 00:03:19,780
it's sent up to the guest current on

00:03:16,700 --> 00:03:22,310
back to the application so the idea is

00:03:19,780 --> 00:03:24,950
between each of the number levels we see

00:03:22,310 --> 00:03:27,019
the same packet so the guest Colonel

00:03:24,950 --> 00:03:29,660
packet that sent is obviously the same

00:03:27,019 --> 00:03:32,120
one that's received so encapsulation in

00:03:29,660 --> 00:03:41,030
this case is very transparent to the

00:03:32,120 --> 00:03:43,459
user so why UDP it turns out UDP

00:03:41,030 --> 00:03:46,040
it's very common already and a lot of

00:03:43,459 --> 00:03:50,000
hardware supports it so in particular we

00:03:46,040 --> 00:03:52,430
can get common offloads with UDP it's

00:03:50,000 --> 00:03:54,190
also used or going to be used in nearly

00:03:52,430 --> 00:03:55,480
all the new network virtualization

00:03:54,190 --> 00:03:57,890
encapsulations

00:03:55,480 --> 00:03:59,660
there's several now being proposed at

00:03:57,890 --> 00:04:03,380
IETF pretty much all of them are

00:03:59,660 --> 00:04:06,200
udp-based and it seems fairly likely

00:04:03,380 --> 00:04:08,989
that UDP will become very prevalent the

00:04:06,200 --> 00:04:11,390
data center and again the reasons for

00:04:08,989 --> 00:04:13,430
that it's just utterly simple it does

00:04:11,390 --> 00:04:17,230
its job and it gives us a lot of kind of

00:04:13,430 --> 00:04:17,230
value in terms of legacy hardware

00:04:18,790 --> 00:04:25,580
so looking at offloads

00:04:22,360 --> 00:04:27,950
so we kind of consider the three most

00:04:25,580 --> 00:04:30,530
fundamental areas of offload so load

00:04:27,950 --> 00:04:36,680
balancing checksum offload segmentation

00:04:30,530 --> 00:04:39,440
offload so for load balancing the idea

00:04:36,680 --> 00:04:41,420
is that we want to basically split

00:04:39,440 --> 00:04:43,100
packets usually over a set of never

00:04:41,420 --> 00:04:46,760
networking resources to improve

00:04:43,100 --> 00:04:49,010
utilization and this happens inside the

00:04:46,760 --> 00:04:52,430
network when we do equal cost multi path

00:04:49,010 --> 00:04:55,070
routing ecmp this can happen at the mix

00:04:52,430 --> 00:04:58,820
and we do things like our assess the hoe

00:04:55,070 --> 00:05:00,530
stack actually has RFS RPS link

00:04:58,820 --> 00:05:03,020
aggregation or support selection so

00:05:00,530 --> 00:05:05,860
there's many many places where we're

00:05:03,020 --> 00:05:08,470
trying to split packets among resources

00:05:05,860 --> 00:05:11,660
usually the property is that we want

00:05:08,470 --> 00:05:14,300
display to be done per flow so for

00:05:11,660 --> 00:05:16,190
instance if we're routing a TCP

00:05:14,300 --> 00:05:19,370
connection we really want the packets of

00:05:16,190 --> 00:05:21,560
that connection to go the same path so

00:05:19,370 --> 00:05:26,900
the idea with most of these mechanisms

00:05:21,560 --> 00:05:29,660
is that we do some sort of hash on the

00:05:26,900 --> 00:05:31,820
five top well basically the IP protocols

00:05:29,660 --> 00:05:35,990
and the TCP UDP ports if they're

00:05:31,820 --> 00:05:39,350
available so the solution to make this

00:05:35,990 --> 00:05:42,800
all work nicely in UDP is that we want

00:05:39,350 --> 00:05:45,140
the kind of five tuple on the outer UDP

00:05:42,800 --> 00:05:48,470
headers to be sufficient to represent

00:05:45,140 --> 00:05:51,700
the inner flow and what we do there is

00:05:48,470 --> 00:05:55,340
basically set the source port of the UDP

00:05:51,700 --> 00:05:58,070
packet to be kind of an entropy for the

00:05:55,340 --> 00:06:00,860
inner flow and if we use the ephemeral

00:05:58,070 --> 00:06:03,110
ports that gives us about fourteen bits

00:06:00,860 --> 00:06:06,980
of entropy which is probably sufficient

00:06:03,110 --> 00:06:09,370
in most cases so we implemented a nice

00:06:06,980 --> 00:06:11,690
function UDP source source flow port

00:06:09,370 --> 00:06:13,600
that any of these encapsulation is can

00:06:11,690 --> 00:06:19,160
call and it kind of just figures out

00:06:13,600 --> 00:06:22,520
from the SK buff how to create a kind of

00:06:19,160 --> 00:06:24,680
a hash for the source port so this

00:06:22,520 --> 00:06:27,200
doesn't really work when you have

00:06:24,680 --> 00:06:29,990
something like l2tp and beer as type

00:06:27,200 --> 00:06:30,960
scenarios because a lot of the times at

00:06:29,990 --> 00:06:34,289
least on the

00:06:30,960 --> 00:06:36,509
a black side of things I think you're

00:06:34,289 --> 00:06:38,250
gonna have the one system sends

00:06:36,509 --> 00:06:42,750
everything out with a source port of

00:06:38,250 --> 00:06:46,710
1701 so this this works when you can

00:06:42,750 --> 00:06:48,330
change the source port yes so IP said

00:06:46,710 --> 00:06:50,099
that isn't always the case though it's

00:06:48,330 --> 00:06:52,039
it would not be the case if you wanted

00:06:50,099 --> 00:06:54,740
to get this through net

00:06:52,039 --> 00:06:57,539
however if if it's a one-way

00:06:54,740 --> 00:07:00,380
communication and we have an inner

00:06:57,539 --> 00:07:03,990
packet we can set the problem is that

00:07:00,380 --> 00:07:07,020
fundamentally within one l2tp tunnel you

00:07:03,990 --> 00:07:10,050
can have many many many sessions and you

00:07:07,020 --> 00:07:11,370
ideally want load balancing for sessions

00:07:10,050 --> 00:07:14,970
within the tunnel when you're doing

00:07:11,370 --> 00:07:17,699
dealing with these kinds of things so if

00:07:14,970 --> 00:07:21,870
if in the l2tp so the lttp has a

00:07:17,699 --> 00:07:24,960
destination which is l2tp can i set the

00:07:21,870 --> 00:07:27,120
source port based on the contents of the

00:07:24,960 --> 00:07:29,250
inner you don't do that because then you

00:07:27,120 --> 00:07:31,699
have to set up multiple tunnels and that

00:07:29,250 --> 00:07:36,690
sort of that depletes your resources for

00:07:31,699 --> 00:07:39,900
okay so the beer as scenarios you you

00:07:36,690 --> 00:07:44,159
can end up with an LC tpv - you can have

00:07:39,900 --> 00:07:46,349
like 10,000 30,000 60,000 sessions in

00:07:44,159 --> 00:07:49,440
one tunnel okay so if it's the case

00:07:46,349 --> 00:07:51,479
where we cannot use the source port for

00:07:49,440 --> 00:07:54,180
flow hash there's actually a pretty good

00:07:51,479 --> 00:07:56,430
alternative and ipv6 you can use a flow

00:07:54,180 --> 00:07:58,740
label so basically has the same fact

00:07:56,430 --> 00:08:00,979
it's 20 bits that you don't like that

00:07:58,740 --> 00:08:00,979
either

00:08:02,060 --> 00:08:08,789
ISPs aren't deploying ipv6 for l2tp

00:08:05,430 --> 00:08:10,020
tunnels at present okay so I should

00:08:08,789 --> 00:08:12,180
mention that most of these

00:08:10,020 --> 00:08:17,990
encapsulations are within a data center

00:08:12,180 --> 00:08:23,030
but yes there's limitations everything

00:08:17,990 --> 00:08:25,860
okay so that's kind of the story on the

00:08:23,030 --> 00:08:28,530
load balancing so looking at the

00:08:25,860 --> 00:08:30,240
checksum all floats a little bit of a

00:08:28,530 --> 00:08:32,849
digression it's kind of hard to talk

00:08:30,240 --> 00:08:35,159
about checksum offloads without using

00:08:32,849 --> 00:08:37,680
some of the terminology in the stack so

00:08:35,159 --> 00:08:42,120
on transmit checksum off there are two

00:08:37,680 --> 00:08:43,979
forms that NICs provide one is net if

00:08:42,120 --> 00:08:44,520
Hardware checksum basically the idea

00:08:43,979 --> 00:08:47,670
here

00:08:44,520 --> 00:08:50,220
as we give the knick start point and

00:08:47,670 --> 00:08:53,340
offset the start point is where checksum

00:08:50,220 --> 00:08:55,050
needs to start to be calculated all set

00:08:53,340 --> 00:08:57,420
is where to write a checksum in a packet

00:08:55,050 --> 00:08:59,460
and this way we send a packet to it Nick

00:08:57,420 --> 00:09:01,770
it takes those it does to checksum

00:08:59,460 --> 00:09:04,080
computation it writes checks them into

00:09:01,770 --> 00:09:07,980
the packet so this is good because it

00:09:04,080 --> 00:09:11,790
kind of works within a protocol the

00:09:07,980 --> 00:09:14,130
other implementation is net if I pay

00:09:11,790 --> 00:09:17,520
checksum this is a more limited form

00:09:14,130 --> 00:09:20,880
where the NIC actually parses the IP

00:09:17,520 --> 00:09:24,330
packet usually TCP or UDP figures out

00:09:20,880 --> 00:09:27,810
the pseudo header checksum and does all

00:09:24,330 --> 00:09:29,640
the work itself so that kind of has a

00:09:27,810 --> 00:09:30,960
disadvantage in that it's not quite as

00:09:29,640 --> 00:09:35,610
generic so when the capsulation

00:09:30,960 --> 00:09:37,590
protocols some legacy NICs if they use

00:09:35,610 --> 00:09:43,740
net FIP checksum it's hard to get the

00:09:37,590 --> 00:09:46,560
transmitted checksum similarly on the

00:09:43,740 --> 00:09:48,540
receive side so Dave talked about this

00:09:46,560 --> 00:09:51,360
this morning so checksum complete is

00:09:48,540 --> 00:09:52,830
kind of the most generic form receive

00:09:51,360 --> 00:09:56,130
checksum offload and this gives us a

00:09:52,830 --> 00:09:58,920
checksum for the whole packet and then

00:09:56,130 --> 00:10:00,570
through some quasi magic we can actually

00:09:58,920 --> 00:10:04,410
use this checksum in various layers of

00:10:00,570 --> 00:10:06,240
the stack to verify different check sums

00:10:04,410 --> 00:10:09,660
in the packet without actually computing

00:10:06,240 --> 00:10:12,810
the packet checksum on the CPU check

00:10:09,660 --> 00:10:14,670
some unnecessary is I guess in some

00:10:12,810 --> 00:10:17,790
sense more common or at least in legacy

00:10:14,670 --> 00:10:20,700
devices the idea in checksum unnecessary

00:10:17,790 --> 00:10:23,340
as the device will tell us oh this

00:10:20,700 --> 00:10:26,270
checksum is verified so it actually has

00:10:23,340 --> 00:10:28,680
a logic to parse the IP packet parch TCP

00:10:26,270 --> 00:10:30,870
compute the checksum ports a pseudo

00:10:28,680 --> 00:10:33,960
header validate that the checksum and

00:10:30,870 --> 00:10:36,720
the TCP header is actually correct for

00:10:33,960 --> 00:10:39,660
the packet some devices actually can

00:10:36,720 --> 00:10:41,280
support more than one checksum so when

00:10:39,660 --> 00:10:45,300
encapsulation came along we started

00:10:41,280 --> 00:10:47,850
having some devices that could verify

00:10:45,300 --> 00:10:52,520
the outer UDP checksum for instance and

00:10:47,850 --> 00:10:52,520
an inner IP inner checksum

00:10:53,390 --> 00:11:01,200
so when we look at checksum offload for

00:10:56,490 --> 00:11:03,300
encapsulation first observation is we

00:11:01,200 --> 00:11:06,750
still need to offload the inner checksum

00:11:03,300 --> 00:11:08,340
so somebody's running TCP /

00:11:06,750 --> 00:11:10,320
encapsulation from a host

00:11:08,340 --> 00:11:11,850
if we don't offload the inner checksum

00:11:10,320 --> 00:11:14,580
we're obviously going to take a big

00:11:11,850 --> 00:11:18,390
performance hit but the other aspect of

00:11:14,580 --> 00:11:20,700
it is that UDP also has a checksum and

00:11:18,390 --> 00:11:25,260
this is actually where thing is start to

00:11:20,700 --> 00:11:27,390
get a little interesting so there's

00:11:25,260 --> 00:11:29,550
pretty good story on the UDP checksum

00:11:27,390 --> 00:11:31,830
and encapsulation but kind of both in

00:11:29,550 --> 00:11:35,880
Linux and in like standards bodies like

00:11:31,830 --> 00:11:38,310
IETF so basically most switch vendors

00:11:35,880 --> 00:11:40,290
want to use zero check sums because

00:11:38,310 --> 00:11:42,990
switch Hardware typically doesn't have

00:11:40,290 --> 00:11:44,670
the functionality to support checksums

00:11:42,990 --> 00:11:47,460
however they do want to terminate

00:11:44,670 --> 00:11:49,490
tunnels and UDP encapsulation so they

00:11:47,460 --> 00:11:53,340
can switch packets between tunnels

00:11:49,490 --> 00:11:57,330
however according to I P v6 standarts

00:11:53,340 --> 00:11:59,690
UDP checksum was required and the reason

00:11:57,330 --> 00:12:02,640
it's required is because unlike ipv4

00:11:59,690 --> 00:12:05,250
ipv6 does not have a header checksum so

00:12:02,640 --> 00:12:07,470
the UDP checksum actually is the thing

00:12:05,250 --> 00:12:10,530
that supposedly protects the IP

00:12:07,470 --> 00:12:11,910
addresses from corruption because I P

00:12:10,530 --> 00:12:14,460
addresses are in the pseudo header

00:12:11,910 --> 00:12:16,260
checksum and the other thing that's

00:12:14,460 --> 00:12:18,600
interesting about the UDP checksum as

00:12:16,260 --> 00:12:20,370
opposed to an inner checksum is the UDP

00:12:18,600 --> 00:12:23,730
checksum actually covers more of the

00:12:20,370 --> 00:12:26,340
packet so this becomes interesting in

00:12:23,730 --> 00:12:29,220
the case of something like VX LAN where

00:12:26,340 --> 00:12:31,320
if you have a TCP packet inside the X

00:12:29,220 --> 00:12:35,460
LAN it has a checksum but that only

00:12:31,320 --> 00:12:39,900
covers TCP UDP checksum potentially

00:12:35,460 --> 00:12:41,910
covers UDP the VX LAN header and TCP and

00:12:39,900 --> 00:12:43,230
the interesting part about the excellent

00:12:41,910 --> 00:12:45,600
of course would be that the virtual

00:12:43,230 --> 00:12:49,470
network identifier would be covered by

00:12:45,600 --> 00:12:54,500
at least checksum which today it's not

00:12:49,470 --> 00:12:57,990
covered by any end end verification so

00:12:54,500 --> 00:13:00,480
on the flip side though because of a

00:12:57,990 --> 00:13:05,490
request to have zero checksum allowed in

00:13:00,480 --> 00:13:06,410
ipv6 for tunnels we invented RFC 69 35

00:13:05,490 --> 00:13:09,500
and 69

00:13:06,410 --> 00:13:11,959
six and these are two very long RFC's

00:13:09,500 --> 00:13:13,459
with an eighth detail about the risks

00:13:11,959 --> 00:13:17,209
and the trade-offs of using zero

00:13:13,459 --> 00:13:19,579
checksum and ipv6 for UDP so it's very

00:13:17,209 --> 00:13:21,829
kind of detailed not exactly exciting

00:13:19,579 --> 00:13:24,529
reading but it's fawning a pretty large

00:13:21,829 --> 00:13:27,529
discussion about the at least a standard

00:13:24,529 --> 00:13:30,170
side requirements of this so if you take

00:13:27,529 --> 00:13:32,089
all this together though what we

00:13:30,170 --> 00:13:35,000
actually found out in a lot of testing

00:13:32,089 --> 00:13:37,639
and some of the work that we did that

00:13:35,000 --> 00:13:40,399
because of the Hardware legacy issue UDP

00:13:37,639 --> 00:13:41,779
checksum actually is not a bad thing in

00:13:40,399 --> 00:13:44,569
a lot of cases if you're dealing with

00:13:41,779 --> 00:13:49,519
like a host of hosts communication using

00:13:44,569 --> 00:13:52,430
something like Linux so the idea about

00:13:49,519 --> 00:13:56,660
that is we want to leverage the UDP

00:13:52,430 --> 00:13:58,759
checksum offload capability so probably

00:13:56,660 --> 00:14:02,899
all NICs deployed or heard least most of

00:13:58,759 --> 00:14:06,199
them support simple UDP IP and TCP check

00:14:02,899 --> 00:14:09,620
sum offload as I mentioned a lot of new

00:14:06,199 --> 00:14:10,339
NIC support more advanced encapsulation

00:14:09,620 --> 00:14:13,069
offloads

00:14:10,339 --> 00:14:15,649
but our solution at least to handle

00:14:13,069 --> 00:14:18,470
these legacy cases enable the UDP

00:14:15,649 --> 00:14:21,920
checksum on the outer header and then

00:14:18,470 --> 00:14:23,689
somehow use that to kind of offload the

00:14:21,920 --> 00:14:30,500
inner header for both transmit and

00:14:23,689 --> 00:14:32,689
receive so on the receive side we

00:14:30,500 --> 00:14:35,870
implement it this thing called check

00:14:32,689 --> 00:14:38,930
some unnecessary conversion and the idea

00:14:35,870 --> 00:14:41,149
here is I have a NIC that gives me a

00:14:38,930 --> 00:14:44,269
checksum unnecessary so it can tell me a

00:14:41,149 --> 00:14:47,120
UDP checksum nonzero UDP checksum is

00:14:44,269 --> 00:14:49,250
valid but nothing about an encapsulated

00:14:47,120 --> 00:14:51,769
checksum so what we can actually do is

00:14:49,250 --> 00:14:55,579
get this information use that to

00:14:51,769 --> 00:14:57,350
validate the outer UDP checksum and then

00:14:55,579 --> 00:14:57,949
once we know the outer UDP checksum is

00:14:57,350 --> 00:15:00,470
good

00:14:57,949 --> 00:15:02,959
we can actually kind of reverse engineer

00:15:00,470 --> 00:15:05,689
what is the complete checksum value

00:15:02,959 --> 00:15:07,100
starting from the UDP header and the

00:15:05,689 --> 00:15:10,009
calculation is actually really really

00:15:07,100 --> 00:15:11,509
simple it's just the complement of the

00:15:10,009 --> 00:15:15,829
pseudo header checksum that would be

00:15:11,509 --> 00:15:17,180
used to create the UDP checksum so a few

00:15:15,829 --> 00:15:19,200
instructions and all of a sudden we

00:15:17,180 --> 00:15:21,510
basically convert checksum 1s

00:15:19,200 --> 00:15:24,330
check some complete and then that gets

00:15:21,510 --> 00:15:26,220
us into you know again check something

00:15:24,330 --> 00:15:28,410
complete we can use that to validate any

00:15:26,220 --> 00:15:31,610
checksum that are in the packet later on

00:15:28,410 --> 00:15:34,110
so this gets us out of needing to do

00:15:31,610 --> 00:15:37,530
checksum calculation on the host on

00:15:34,110 --> 00:15:40,260
receive no protocol change there it

00:15:37,530 --> 00:15:43,260
works really well and we kind of want a

00:15:40,260 --> 00:15:46,080
similar thing on the transmit this is a

00:15:43,260 --> 00:15:48,630
little harder because kind of needs some

00:15:46,080 --> 00:15:52,650
protocol assistance with this but the

00:15:48,630 --> 00:15:55,740
idea is to kind of do something similar

00:15:52,650 --> 00:15:57,270
to net if Hardware checksum so in the

00:15:55,740 --> 00:15:59,940
packet we have some additional

00:15:57,270 --> 00:16:03,060
information which gives us the starting

00:15:59,940 --> 00:16:05,610
point and the offset where to write the

00:16:03,060 --> 00:16:07,830
checksum and instead of a nick doing

00:16:05,610 --> 00:16:12,450
this computation we actually just send

00:16:07,830 --> 00:16:15,210
this to the pier and at the pier we also

00:16:12,450 --> 00:16:18,600
set the UDP checksum to non zero so the

00:16:15,210 --> 00:16:20,610
PR just validates UDP checksum we get a

00:16:18,600 --> 00:16:23,100
checksum complete packet flows and then

00:16:20,610 --> 00:16:25,430
we process the encapsulation header

00:16:23,100 --> 00:16:27,570
which contains this extra information

00:16:25,430 --> 00:16:29,820
encapsulation header just does a fairly

00:16:27,570 --> 00:16:32,010
simple algorithm it knows the complete

00:16:29,820 --> 00:16:35,430
checksum it knows where the starting

00:16:32,010 --> 00:16:37,770
checksum is supposed to to begin so it

00:16:35,430 --> 00:16:39,750
calculates from the complete set some

00:16:37,770 --> 00:16:42,390
point that it's at to the starting

00:16:39,750 --> 00:16:44,190
checksum the difference there subtract

00:16:42,390 --> 00:16:46,860
that subtracts that from the complete

00:16:44,190 --> 00:16:50,340
checksum and then that's the checksum

00:16:46,860 --> 00:16:54,570
that we use from the starting point off

00:16:50,340 --> 00:16:57,120
set and then just the details are in

00:16:54,570 --> 00:17:02,010
paper but I really it's just adding that

00:16:57,120 --> 00:17:03,900
into the checksum field and kind of semi

00:17:02,010 --> 00:17:10,829
magically we have the actual checksum

00:17:03,900 --> 00:17:13,530
that TCP needs so again this has the

00:17:10,829 --> 00:17:17,850
advantage it eliminates the checksum

00:17:13,530 --> 00:17:20,310
computation on the host on transmit so I

00:17:17,850 --> 00:17:23,640
didn't actually have time to put some

00:17:20,310 --> 00:17:26,839
performance numbers and they are in the

00:17:23,640 --> 00:17:29,670
patches but both of these were about

00:17:26,839 --> 00:17:31,990
about half the CPU calls for the normal

00:17:29,670 --> 00:17:33,390
tests so they were quite impressive so

00:17:31,990 --> 00:17:35,890
checksum offload is very expensive

00:17:33,390 --> 00:17:39,940
especially and receive obviously pulling

00:17:35,890 --> 00:17:41,700
all of the packet into the CPU cache is

00:17:39,940 --> 00:17:49,090
kind of costly so there are pretty good

00:17:41,700 --> 00:17:52,630
features okay so moving to segmentation

00:17:49,090 --> 00:17:55,540
offload this is another very common form

00:17:52,630 --> 00:17:58,330
of offload and fundamentally concept is

00:17:55,540 --> 00:18:01,150
we want the stack to operate on large

00:17:58,330 --> 00:18:03,190
packets instead of small packets so

00:18:01,150 --> 00:18:05,800
again like Dave said this morning doing

00:18:03,190 --> 00:18:09,880
routing look-up on 10 packets versus

00:18:05,800 --> 00:18:11,530
just one has a lot of advantages so this

00:18:09,880 --> 00:18:15,460
was usually implemented in the context

00:18:11,530 --> 00:18:19,150
of TCP there is a UDP fragmentation

00:18:15,460 --> 00:18:22,270
offload a little different but so we'll

00:18:19,150 --> 00:18:25,750
talk a little bit about TCP offload and

00:18:22,270 --> 00:18:28,480
its relevance encapsulation so as I

00:18:25,750 --> 00:18:31,210
mentioned transmit segmentation offload

00:18:28,480 --> 00:18:33,730
the ideas start with a big TCP packet

00:18:31,210 --> 00:18:35,950
split it up into small ones as low as

00:18:33,730 --> 00:18:38,470
possible in the stack and then send out

00:18:35,950 --> 00:18:41,080
each small one and this is actually very

00:18:38,470 --> 00:18:44,050
common in hardware it's called usually

00:18:41,080 --> 00:18:47,800
called TSO when it's specifically for

00:18:44,050 --> 00:18:50,590
TCP and we also implement this fairly

00:18:47,800 --> 00:18:52,330
long time ago in the stack just kind of

00:18:50,590 --> 00:18:56,380
emulating what the hardware is doing and

00:18:52,330 --> 00:18:58,000
generic segmentation offload or GSL so

00:18:56,380 --> 00:18:59,610
for each packet the process is actually

00:18:58,000 --> 00:19:03,270
fairly simple

00:18:59,610 --> 00:19:06,100
what we need to do is copy the headers

00:19:03,270 --> 00:19:08,309
from the large packet all the way

00:19:06,100 --> 00:19:10,390
through kind of the to the data

00:19:08,309 --> 00:19:13,450
replicate those headers in each small

00:19:10,390 --> 00:19:15,160
packet and then for fields in the

00:19:13,450 --> 00:19:19,200
headers that have to be updated per

00:19:15,160 --> 00:19:23,020
packet like the length of the packet or

00:19:19,200 --> 00:19:25,870
checksum over the packet or TCP sequence

00:19:23,020 --> 00:19:28,210
number or anything that is per packet we

00:19:25,870 --> 00:19:30,670
need to go and update those for each

00:19:28,210 --> 00:19:32,830
protocol layer so for instance in IP we

00:19:30,670 --> 00:19:35,250
have to update the IP length of each

00:19:32,830 --> 00:19:35,250
packet

00:19:36,830 --> 00:19:44,770
so with regards to unity encapsulation

00:19:41,020 --> 00:19:48,590
we actually implement a very nice

00:19:44,770 --> 00:19:52,910
implementation of this so the UDP gso

00:19:48,590 --> 00:19:55,490
function cause sqv skb UDP tunnel

00:19:52,910 --> 00:19:58,580
segment it would know that this is

00:19:55,490 --> 00:20:02,180
basically a UDP tunnel through some

00:19:58,580 --> 00:20:05,000
flags and the sk buff so the first thing

00:20:02,180 --> 00:20:07,700
it does is basically cause the same

00:20:05,000 --> 00:20:10,670
function for the next protocol layer so

00:20:07,700 --> 00:20:13,670
UDP will get this we will somehow figure

00:20:10,670 --> 00:20:15,920
out that UDP is encapsulating an IP

00:20:13,670 --> 00:20:18,770
packet so we'll call the GSO for the IP

00:20:15,920 --> 00:20:21,880
packet and in turn the IP packet caused

00:20:18,770 --> 00:20:24,230
gso for TCP so it's kind of a chained

00:20:21,880 --> 00:20:27,110
set of callbacks eventually it gets to

00:20:24,230 --> 00:20:30,800
TCP and this is the guy that actually

00:20:27,110 --> 00:20:33,800
caused the function to create the the

00:20:30,800 --> 00:20:35,990
packets so on the return path through

00:20:33,800 --> 00:20:39,680
this call chain each layer needs to

00:20:35,990 --> 00:20:43,100
update its layer of the protocol so in

00:20:39,680 --> 00:20:45,830
the case of UDP encapsulation we need

00:20:43,100 --> 00:20:49,040
update the UDP length and the checksum

00:20:45,830 --> 00:20:50,510
because those are per packet however for

00:20:49,040 --> 00:20:54,770
encapsulation we have a really nice

00:20:50,510 --> 00:20:56,720
trick and that the current encapsulation

00:20:54,770 --> 00:20:59,870
protocols and methods that have been

00:20:56,720 --> 00:21:02,210
implemented don't have any per packet

00:20:59,870 --> 00:21:05,030
fields that we need to update so what

00:21:02,210 --> 00:21:09,860
this means is we can have a generic UDP

00:21:05,030 --> 00:21:11,900
encapsulation GSO and all we need to do

00:21:09,860 --> 00:21:15,140
for any of the encapsulation stuff

00:21:11,900 --> 00:21:17,720
between the UDP header and the kind of

00:21:15,140 --> 00:21:20,030
encapsulated protocol we just copy those

00:21:17,720 --> 00:21:22,730
bits so same thing could be done in

00:21:20,030 --> 00:21:26,060
hardware and as long as we keep things

00:21:22,730 --> 00:21:29,150
clean we have a very nice way to do a

00:21:26,060 --> 00:21:30,920
generic UDP encapsulation very protocol

00:21:29,150 --> 00:21:36,610
agnostic which is nice so this would

00:21:30,920 --> 00:21:36,610
work at VX LAN - Neve go whatever

00:21:40,850 --> 00:21:44,640
okay

00:21:42,180 --> 00:21:47,160
turning to receive segmentation offload

00:21:44,640 --> 00:21:49,590
so this is kind of a converse to

00:21:47,160 --> 00:21:51,180
transmit so in this case we're starting

00:21:49,590 --> 00:21:53,910
with a whole bunch of small packets that

00:21:51,180 --> 00:21:56,370
we get off the network for a flow or TCP

00:21:53,910 --> 00:21:59,130
connection basically construct those

00:21:56,370 --> 00:22:01,620
into one large packet again very low in

00:21:59,130 --> 00:22:03,480
the stacker in the device and then send

00:22:01,620 --> 00:22:05,520
that up in the stack only has to process

00:22:03,480 --> 00:22:09,180
a large packet instead of dealing with a

00:22:05,520 --> 00:22:11,010
whole bunch of small TCP packets so in

00:22:09,180 --> 00:22:15,090
the stack this is generic receive

00:22:11,010 --> 00:22:20,400
offload in the hardware it's called

00:22:15,090 --> 00:22:23,850
larger she'll receive offload so again

00:22:20,400 --> 00:22:28,640
we did some implementation specific to

00:22:23,850 --> 00:22:32,610
you tube encapsulation in this case the

00:22:28,640 --> 00:22:35,190
UDP grow function will be called at some

00:22:32,610 --> 00:22:36,870
point so packet packets come in and kind

00:22:35,190 --> 00:22:39,810
of basic idea of grow is that we need to

00:22:36,870 --> 00:22:42,510
match packets to flow so we build up

00:22:39,810 --> 00:22:45,510
kind of chains of packets that match to

00:22:42,510 --> 00:22:48,150
a flow so the packets go through each

00:22:45,510 --> 00:22:50,880
layer of protocol and we match per that

00:22:48,150 --> 00:22:53,430
layer of protocols so when they get so

00:22:50,880 --> 00:22:57,480
when the UDP function is called we're

00:22:53,430 --> 00:22:59,520
matching UDP characteristics so we take

00:22:57,480 --> 00:23:01,530
all the flows that were we are we've

00:22:59,520 --> 00:23:06,260
already seen and we're trying to match

00:23:01,530 --> 00:23:10,440
the ports to those flows so for the

00:23:06,260 --> 00:23:12,540
encapsulation we need a taxi create kind

00:23:10,440 --> 00:23:16,770
of an encapsulation specific function

00:23:12,540 --> 00:23:19,260
grow function per port so we're Berlitz

00:23:16,770 --> 00:23:22,650
did a nice implementation where we can

00:23:19,260 --> 00:23:25,560
register the set of grow functions per

00:23:22,650 --> 00:23:28,770
port so an encapsulation packet comes in

00:23:25,560 --> 00:23:31,020
and UDP it's the destination port that

00:23:28,770 --> 00:23:33,180
tells us what the encapsulation protocol

00:23:31,020 --> 00:23:36,390
is someone grow we need to take that

00:23:33,180 --> 00:23:38,520
port lookup to find the exact functions

00:23:36,390 --> 00:23:40,170
to call then we call that function and

00:23:38,520 --> 00:23:42,660
then that particular grow function will

00:23:40,170 --> 00:23:46,920
handle the details of that encapsulation

00:23:42,660 --> 00:23:49,230
layer so this the the details of an

00:23:46,920 --> 00:23:52,200
encapsulation layer are kind of similar

00:23:49,230 --> 00:23:52,800
to other growth functions we need to

00:23:52,200 --> 00:23:56,820
match

00:23:52,800 --> 00:23:59,130
that this packet matches that packet in

00:23:56,820 --> 00:24:02,430
like it is it's encapsulated the same

00:23:59,130 --> 00:24:04,650
way and another important thing similar

00:24:02,430 --> 00:24:07,650
to the GSO case we always need to call

00:24:04,650 --> 00:24:09,390
the next layer of protocol and the

00:24:07,650 --> 00:24:12,900
encapsulation case we need to get this

00:24:09,390 --> 00:24:15,390
from either the encapsulation header if

00:24:12,900 --> 00:24:17,540
it contains the next protocol or it's

00:24:15,390 --> 00:24:19,980
inferred from the port so we need some

00:24:17,540 --> 00:24:30,450
kind of XOR information to be able to

00:24:19,980 --> 00:24:34,620
make that call any questions okay

00:24:30,450 --> 00:24:38,460
so turning a little more to kind of some

00:24:34,620 --> 00:24:40,410
implementation or protocol examples so

00:24:38,460 --> 00:24:44,640
we implemented something called for over

00:24:40,410 --> 00:24:48,270
UDP and generic UDP encapsulation these

00:24:44,640 --> 00:24:55,830
are both different methods to

00:24:48,270 --> 00:25:02,070
encapsulate packets of IP protocol or so

00:24:55,830 --> 00:25:05,370
through over UDP a basic idea is we have

00:25:02,070 --> 00:25:08,190
a UDP IP UDP and then the networking

00:25:05,370 --> 00:25:10,560
packet so there's no extra protocol

00:25:08,190 --> 00:25:13,500
header the it's the destination port

00:25:10,560 --> 00:25:15,600
that tells us what the type of protocol

00:25:13,500 --> 00:25:18,120
is so again going back to here if you if

00:25:15,600 --> 00:25:21,540
you look at the left this is an IP

00:25:18,120 --> 00:25:25,920
header or UDP header IP packet so if

00:25:21,540 --> 00:25:28,620
this was actually an ipv4 packet it's

00:25:25,920 --> 00:25:32,640
the destination UPA destination UDP

00:25:28,620 --> 00:25:39,680
address it tells us this port means this

00:25:32,640 --> 00:25:43,230
I this IP protocol so to implement

00:25:39,680 --> 00:25:46,920
through over UDP we had to kind of model

00:25:43,230 --> 00:25:48,480
this as a header insertion so I have a

00:25:46,920 --> 00:25:51,300
kind of a walk through that that will

00:25:48,480 --> 00:25:54,120
clarify that we implemented this in a

00:25:51,300 --> 00:25:57,090
kernel module one important function in

00:25:54,120 --> 00:25:59,130
encapsulation is in cap receive this is

00:25:57,090 --> 00:26:02,670
placed in sockets and this is kind of

00:25:59,130 --> 00:26:05,310
the intercept for any receiver doing

00:26:02,670 --> 00:26:07,770
encapsulation

00:26:05,310 --> 00:26:09,420
the important thing one of the important

00:26:07,770 --> 00:26:11,970
aspects of this is we really split the

00:26:09,420 --> 00:26:14,370
receive path in the U and the transmit

00:26:11,970 --> 00:26:17,700
path so the receive path is handled by a

00:26:14,370 --> 00:26:20,160
kernel module which conceptually can

00:26:17,700 --> 00:26:23,100
handle any sort of I P protocol

00:26:20,160 --> 00:26:25,290
encapsulation at this point but the

00:26:23,100 --> 00:26:28,290
transmit side we have to go in and kind

00:26:25,290 --> 00:26:30,990
of implement this for different tunnels

00:26:28,290 --> 00:26:34,800
that was the first instantiation so we

00:26:30,990 --> 00:26:41,370
can set up an IP IP si T or GRE tunnel

00:26:34,800 --> 00:26:44,900
to use this so looking at the over UDP

00:26:41,370 --> 00:26:49,470
example so on a receiver we would set up

00:26:44,900 --> 00:26:52,260
port and it would say open port in this

00:26:49,470 --> 00:26:56,850
case five five five five and we're

00:26:52,260 --> 00:26:59,430
calling that a ipv4 port so packets

00:26:56,850 --> 00:27:03,330
coming in on this will assume oaring to

00:26:59,430 --> 00:27:07,230
encapsulated ipv4 packets and on

00:27:03,330 --> 00:27:09,650
transmit we attach this to tunnel so in

00:27:07,230 --> 00:27:12,690
this case we're creating an IP IP tunnel

00:27:09,650 --> 00:27:16,160
giving it the normal remote local

00:27:12,690 --> 00:27:18,900
addresses and then we add it an in cap

00:27:16,160 --> 00:27:20,790
kind of sub command to the IP a link

00:27:18,900 --> 00:27:22,260
commands and in this case we're saying

00:27:20,790 --> 00:27:25,560
it's we're going to in cap with foo over

00:27:22,260 --> 00:27:27,540
UDP the source port will automatically

00:27:25,560 --> 00:27:29,820
be chosen by the kernel so we're gonna

00:27:27,540 --> 00:27:31,740
call the UDP source float port that I

00:27:29,820 --> 00:27:35,760
mentioned before and then we just give

00:27:31,740 --> 00:27:40,620
it the destination port so how this

00:27:35,760 --> 00:27:43,770
looks kind of a at the protocol layer so

00:27:40,620 --> 00:27:46,440
we will start by sending a packet on the

00:27:43,770 --> 00:27:51,600
tunnel interface so this is a normal I P

00:27:46,440 --> 00:27:55,320
TCP packet so this is IP and IP

00:27:51,600 --> 00:27:59,100
technology CLE will insert an IP header

00:27:55,320 --> 00:28:02,010
in front where the IP protocol is for so

00:27:59,100 --> 00:28:05,160
this looks just like an IP IP however

00:28:02,010 --> 00:28:07,890
the difference in this path is that we

00:28:05,160 --> 00:28:13,370
insert UDP header between the two IP

00:28:07,890 --> 00:28:16,320
headers destination port set to 5555 and

00:28:13,370 --> 00:28:18,260
the UDP port source port as I mentioned

00:28:16,320 --> 00:28:21,410
is going to be set to

00:28:18,260 --> 00:28:23,620
basically the 5-tuple hash of the inner

00:28:21,410 --> 00:28:26,210
packet so the inner IP and rtcp

00:28:23,620 --> 00:28:27,770
addresses and ports are going to be

00:28:26,210 --> 00:28:30,290
hashed and then we're going to compute a

00:28:27,770 --> 00:28:34,070
fourteen bit value and put it into the

00:28:30,290 --> 00:28:37,190
UDP source port so now we have a fully

00:28:34,070 --> 00:28:40,940
qualified IP packet so the outer IP

00:28:37,190 --> 00:28:43,340
header says next protocol is UDP the

00:28:40,940 --> 00:28:46,669
inner IP header says next protocols TCP

00:28:43,340 --> 00:28:50,570
and the UDP destination port says we're

00:28:46,669 --> 00:28:52,610
encapsulating an IP packet slap an

00:28:50,570 --> 00:28:56,179
Ethernet header on this is now good to

00:28:52,610 --> 00:28:57,679
go out on the wire and at the receiver

00:28:56,179 --> 00:29:00,320
we're going to do kind of the reverse

00:28:57,679 --> 00:29:03,950
process so again we're going to see the

00:29:00,320 --> 00:29:07,610
destination port was 5555 that's going

00:29:03,950 --> 00:29:11,900
to go to or UDP receive socket or

00:29:07,610 --> 00:29:13,910
possibly the grower chain for it so what

00:29:11,900 --> 00:29:16,370
we have to do here is the inverse of

00:29:13,910 --> 00:29:18,830
what we've done done did before we will

00:29:16,370 --> 00:29:22,130
now take the UDP header out of the

00:29:18,830 --> 00:29:23,809
packet so this is actually done not by

00:29:22,130 --> 00:29:27,110
physically removing it but just by

00:29:23,809 --> 00:29:31,490
manipulating the header offsets in the

00:29:27,110 --> 00:29:33,590
sk buff so it's very efficient so the

00:29:31,490 --> 00:29:38,929
net of that is it now looks like an an

00:29:33,590 --> 00:29:42,260
IP IP encapsulated packet and what we do

00:29:38,929 --> 00:29:44,990
then is on return from the in capra see

00:29:42,260 --> 00:29:47,110
function set the negative of the

00:29:44,990 --> 00:29:50,840
protocol we want to process in this case

00:29:47,110 --> 00:29:53,150
the protocol of the in our header is 4

00:29:50,840 --> 00:29:54,410
so we can actually convey this back

00:29:53,150 --> 00:29:58,309
through and cap receive

00:29:54,410 --> 00:30:00,590
ok now process this as an IP IP packet

00:29:58,309 --> 00:30:06,520
so it goes right back into the stack and

00:30:00,590 --> 00:30:10,990
then just processes it on the tunnel so

00:30:06,520 --> 00:30:13,280
generic UDP encapsulation so this is

00:30:10,990 --> 00:30:16,160
kind of an extensible and generic

00:30:13,280 --> 00:30:18,890
encapsulation protocol and the idea here

00:30:16,160 --> 00:30:22,850
is again we have an encapsulation header

00:30:18,890 --> 00:30:28,520
that contains an IP protocol so that'll

00:30:22,850 --> 00:30:30,179
be ipv4 ipv6 any of any of those and we

00:30:28,520 --> 00:30:33,179
have some other nice things and

00:30:30,179 --> 00:30:35,759
the generic UDP encapsulation headers

00:30:33,179 --> 00:30:38,580
have a type field header length and as I

00:30:35,759 --> 00:30:41,879
mentioned the 8 bit protocol we also

00:30:38,580 --> 00:30:45,749
have bit flags and these are where we

00:30:41,879 --> 00:30:48,059
get extensibility from in GRE or gue so

00:30:45,749 --> 00:30:51,570
the concept of goe is so similar to GRE

00:30:48,059 --> 00:30:56,100
it because but basically these are GRE

00:30:51,570 --> 00:30:58,710
like flags so we can add protocol

00:30:56,100 --> 00:31:01,499
extensions with this and kind of the

00:30:58,710 --> 00:31:05,669
concept is if a bit is set in the flags

00:31:01,499 --> 00:31:08,220
that corresponds to a field in in the

00:31:05,669 --> 00:31:10,619
header so we can set some number of bits

00:31:08,220 --> 00:31:13,860
have some number fields and we've

00:31:10,619 --> 00:31:17,850
already find some bit fields for

00:31:13,860 --> 00:31:20,369
security we have a type of checksum just

00:31:17,850 --> 00:31:22,710
for the header remote checksum offload

00:31:20,369 --> 00:31:25,110
this is how we convey it in generic UDP

00:31:22,710 --> 00:31:26,490
encapsulation so there's a bit in the

00:31:25,110 --> 00:31:28,649
header and then a field that contains

00:31:26,490 --> 00:31:35,970
the offset and I'll flip set in the

00:31:28,649 --> 00:31:39,779
start so goo is pretty straightforward

00:31:35,970 --> 00:31:42,389
this shows the UDP header followed by

00:31:39,779 --> 00:31:46,110
the gue header it's basically it's 4

00:31:42,389 --> 00:31:48,090
byte fixed header followed by some

00:31:46,110 --> 00:31:55,879
number of zero or more optional fields

00:31:48,090 --> 00:31:58,649
actually so very similar to foo

00:31:55,879 --> 00:32:01,289
goo is kind of configured the same way

00:31:58,649 --> 00:32:03,960
so in the first line then we're gonna

00:32:01,289 --> 00:32:07,710
add a port two seven seven seven seven

00:32:03,960 --> 00:32:09,059
four generic UDP encapsulation so the

00:32:07,710 --> 00:32:10,559
only difference here is we don't have to

00:32:09,059 --> 00:32:12,509
specify the protocol because the

00:32:10,559 --> 00:32:15,210
protocol actually come within the packet

00:32:12,509 --> 00:32:17,070
so this has a nice advantage it's one

00:32:15,210 --> 00:32:17,759
port for kind of all the all the

00:32:17,070 --> 00:32:20,460
protocols

00:32:17,759 --> 00:32:22,320
on the transmit side we do a very

00:32:20,460 --> 00:32:25,350
similar thing we did before so we just

00:32:22,320 --> 00:32:26,460
create an IP IP tunnel in this case say

00:32:25,350 --> 00:32:31,169
in cap

00:32:26,460 --> 00:32:34,379
goo instead of in cap of over UDP same

00:32:31,169 --> 00:32:36,059
thing and this also just shows enabling

00:32:34,379 --> 00:32:39,860
the outer UDP checksum and remote

00:32:36,059 --> 00:32:39,860
checksum offload commands

00:32:40,140 --> 00:32:46,710
so walking through this model so in this

00:32:44,730 --> 00:32:49,890
case we're considering GRE so let's

00:32:46,710 --> 00:32:53,760
assume that the user sends an ipv4

00:32:49,890 --> 00:32:55,920
packet on the GRE tunnel it's a Giri

00:32:53,760 --> 00:32:57,990
tunnel encapsulation over IP it looks

00:32:55,920 --> 00:33:00,840
something like this we add the IP and

00:32:57,990 --> 00:33:06,030
GRE headers kind of logically doing this

00:33:00,840 --> 00:33:10,610
again in this case we insert the a UDP

00:33:06,030 --> 00:33:15,840
and GU header between the IP and the GRE

00:33:10,610 --> 00:33:18,390
so the UDP header will have seven seven

00:33:15,840 --> 00:33:20,340
seven seven as a destination port so

00:33:18,390 --> 00:33:23,750
that that's our port for generic UDP

00:33:20,340 --> 00:33:27,120
encapsulation in this case the next

00:33:23,750 --> 00:33:31,410
protocol and the GU header is 47 so that

00:33:27,120 --> 00:33:35,610
indicates it's GRE so with that we now a

00:33:31,410 --> 00:33:37,140
fully qualified IP packet send the

00:33:35,610 --> 00:33:39,570
appropriate Erb attach the appropriate

00:33:37,140 --> 00:33:43,590
neither Ethernet header and we can send

00:33:39,570 --> 00:33:47,760
that at the receiver again we see this

00:33:43,590 --> 00:33:53,090
is port 7777 so we would send that to

00:33:47,760 --> 00:33:55,980
UDP processing for the GU socket and

00:33:53,090 --> 00:33:58,110
again we're reversing the operation we

00:33:55,980 --> 00:34:00,660
removed the UDP and the GU header from

00:33:58,110 --> 00:34:04,200
the packet and this leaves us with just

00:34:00,660 --> 00:34:06,559
an IP e GRE packet inject that back to

00:34:04,200 --> 00:34:13,230
the tunnel and receive the packet

00:34:06,559 --> 00:34:16,230
normally so that's kind of all ahead I

00:34:13,230 --> 00:34:18,330
don't want to make a point here this was

00:34:16,230 --> 00:34:20,760
a very much a community effort most of

00:34:18,330 --> 00:34:22,740
the technologies in here we kind of

00:34:20,760 --> 00:34:25,590
sewed together to come up with really

00:34:22,740 --> 00:34:29,280
good solution a lot of this goes back a

00:34:25,590 --> 00:34:31,980
long way so the junior gso goes back a

00:34:29,280 --> 00:34:35,820
while we did have to kind of adapt the

00:34:31,980 --> 00:34:37,550
stack for a TP checksum was interesting

00:34:35,820 --> 00:34:39,750
I think we did a pretty good job of

00:34:37,550 --> 00:34:42,570
revamping that to something more

00:34:39,750 --> 00:34:45,570
flexible that being said there's still a

00:34:42,570 --> 00:34:47,100
lot of work here security and control

00:34:45,570 --> 00:34:50,510
and performance I think we can still

00:34:47,100 --> 00:34:53,809
kind of continue to improve and

00:34:50,510 --> 00:34:54,800
I think I think there's enough

00:34:53,809 --> 00:34:56,990
motivation here

00:34:54,800 --> 00:34:59,119
like I said UDP encapsulation seems like

00:34:56,990 --> 00:35:00,589
it's going to be fairly prevalent so I

00:34:59,119 --> 00:35:04,010
haven't a kind of a first class

00:35:00,589 --> 00:35:05,210
implementation on Linux seems like you

00:35:04,010 --> 00:35:10,540
know it's a good idea to continue to

00:35:05,210 --> 00:35:10,540
support that effort any questions

00:35:20,760 --> 00:35:25,350
how much of this is upstream at this

00:35:23,080 --> 00:35:25,350
point

00:35:29,190 --> 00:35:38,520
I think all of the stuff I covered here

00:35:34,770 --> 00:35:41,910
the only thing that is not upstream or

00:35:38,520 --> 00:35:44,609
some of the options that we want to add

00:35:41,910 --> 00:35:49,380
two generic UDP encapsulation the

00:35:44,609 --> 00:35:50,670
checksum stuff is pretty complete I'm

00:35:49,380 --> 00:35:59,400
not sure there's gonna be a lot more

00:35:50,670 --> 00:36:00,930
work on that zero gso work fine for TCP

00:35:59,400 --> 00:36:07,619
I think there might be some more generic

00:36:00,930 --> 00:36:09,990
work how to do non TCP kind of non TCP

00:36:07,619 --> 00:36:11,849
on the non TCP on the receive side so we

00:36:09,990 --> 00:36:14,910
talked a little bit about that at net

00:36:11,849 --> 00:36:18,300
comp but overall most of this is

00:36:14,910 --> 00:36:20,460
upstream and kind of ready to go some of

00:36:18,300 --> 00:36:22,619
this stuff we also implemented in V X

00:36:20,460 --> 00:36:25,319
LAN so for instance the X plane now has

00:36:22,619 --> 00:36:26,300
remote checksum offload that worked out

00:36:25,319 --> 00:36:31,530
pretty well

00:36:26,300 --> 00:36:32,880
cheap GBP they put into VX land seems

00:36:31,530 --> 00:36:34,109
like it's very straightforward to put in

00:36:32,880 --> 00:36:36,900
here so probably just add a few more

00:36:34,109 --> 00:36:39,480
options the one thing that that is

00:36:36,900 --> 00:36:41,760
missing from go would be nice to have an

00:36:39,480 --> 00:36:48,690
OVS implementation so something we have

00:36:41,760 --> 00:36:50,430
to work on so the infrastructure that

00:36:48,690 --> 00:36:53,040
you talked about mostly deal with the

00:36:50,430 --> 00:36:55,410
offload and transmit sort of independent

00:36:53,040 --> 00:36:59,849
of the VX LAN network driver it's the

00:36:55,410 --> 00:37:03,329
step below that right am I reading that

00:36:59,849 --> 00:37:10,079
correctly like the generic VX land

00:37:03,329 --> 00:37:14,010
device it's unchanged the VX land device

00:37:10,079 --> 00:37:17,609
driver is unchanged yes right so I guess

00:37:14,010 --> 00:37:22,710
to support various new like if if

00:37:17,609 --> 00:37:24,000
someone was going to do Geneva is there

00:37:22,710 --> 00:37:25,440
anything that has to happen in the in

00:37:24,000 --> 00:37:27,480
this infrastructure you just talked

00:37:25,440 --> 00:37:29,849
about or any other UDP offload is there

00:37:27,480 --> 00:37:33,089
anything needed so you need to you need

00:37:29,849 --> 00:37:37,410
to take it one offload at a time so for

00:37:33,089 --> 00:37:39,150
the RSS kind of load balancing all you

00:37:37,410 --> 00:37:42,720
need to do is call the appropriate

00:37:39,150 --> 00:37:45,690
function so we standard like standard I

00:37:42,720 --> 00:37:48,090
a lot of the UDP encapsulation formats I

00:37:45,690 --> 00:37:50,910
think there's actually explicit

00:37:48,090 --> 00:37:51,900
functions to send UDP tunnel packets so

00:37:50,910 --> 00:37:54,240
a lot of thats already pretty

00:37:51,900 --> 00:37:56,670
standardized so I think within Linux in

00:37:54,240 --> 00:37:58,650
a UDP encapsulation already has a lot of

00:37:56,670 --> 00:38:02,099
stuff that it can just call so just call

00:37:58,650 --> 00:38:04,560
the UDP a flow source port one shot all

00:38:02,099 --> 00:38:07,830
done so the load balancing is pretty

00:38:04,560 --> 00:38:09,869
much done do modulo things like lttp

00:38:07,830 --> 00:38:13,190
that can't allow it

00:38:09,869 --> 00:38:17,310
checksum offload check some unnecessary

00:38:13,190 --> 00:38:18,810
is trivial template to just turn on in

00:38:17,310 --> 00:38:20,270
every socket there's no reason why we

00:38:18,810 --> 00:38:22,410
shouldn't do that for encapsulation

00:38:20,270 --> 00:38:24,390
receive checksum offload requires

00:38:22,410 --> 00:38:26,730
protocol support like I mentioned so you

00:38:24,390 --> 00:38:29,780
gonna I guess in genve it would be like

00:38:26,730 --> 00:38:35,820
a TLV or something like that

00:38:29,780 --> 00:38:40,800
the grow and gso as long as there's no

00:38:35,820 --> 00:38:42,060
concept of like per per packet fields

00:38:40,800 --> 00:38:45,570
that have to be modified like I

00:38:42,060 --> 00:38:48,839
mentioned GSO can right now probably

00:38:45,570 --> 00:38:52,710
just use the UDP encapsulate UDP AG SOS

00:38:48,839 --> 00:38:56,250
is so that's really nice for the

00:38:52,710 --> 00:38:59,180
flipside gyro I think they're all gonna

00:38:56,250 --> 00:39:01,619
kind of need to implement gyro receive

00:38:59,180 --> 00:39:09,960
but it's pretty straightforward at this

00:39:01,619 --> 00:39:12,720
point one thing we discussed the other

00:39:09,960 --> 00:39:15,900
day so in this presentation the GUI

00:39:12,720 --> 00:39:18,740
examples are always with an IP but we

00:39:15,900 --> 00:39:20,660
agree that vehicle can be expressed as

00:39:18,740 --> 00:39:23,010
good as well right

00:39:20,660 --> 00:39:25,170
like in Vic's long when the inner packet

00:39:23,010 --> 00:39:28,770
is Ethernet it still can be expressed as

00:39:25,170 --> 00:39:29,760
GUI so it can be so there's there's two

00:39:28,770 --> 00:39:33,920
ways to do that

00:39:29,760 --> 00:39:37,470
so there is an ether IP protocol type

00:39:33,920 --> 00:39:41,040
which just another IP protocol number

00:39:37,470 --> 00:39:44,240
and the idea of that was to put Ethernet

00:39:41,040 --> 00:39:46,890
frames into IP there's a little trick

00:39:44,240 --> 00:39:49,290
they actually have a two by kind of

00:39:46,890 --> 00:39:52,760
preamble to this and the effect of that

00:39:49,290 --> 00:39:55,800
is it's not immediately in the IP

00:39:52,760 --> 00:39:56,570
payload either Ethernet frames not

00:39:55,800 --> 00:39:58,100
immediately night

00:39:56,570 --> 00:40:00,020
IP payload there's two bytes and then

00:39:58,100 --> 00:40:02,780
the Ethernet frame that has a nice

00:40:00,020 --> 00:40:05,900
effect though of aligning the IP headers

00:40:02,780 --> 00:40:07,880
within that Ethernet packet I don't know

00:40:05,900 --> 00:40:10,010
if this is still relevant but that

00:40:07,880 --> 00:40:13,430
alignment wouldn't exist in native Jerry

00:40:10,010 --> 00:40:15,170
the other way to encapsulate something

00:40:13,430 --> 00:40:18,530
like GRE or any of the ether types

00:40:15,170 --> 00:40:22,970
actually a protocol number 47 which was

00:40:18,530 --> 00:40:25,730
our example and go is URI which means I

00:40:22,970 --> 00:40:28,100
can have gue header followed by a GRE

00:40:25,730 --> 00:40:30,500
header and then I can encapsulate all

00:40:28,100 --> 00:40:31,850
the thrown Ethernet types so for the

00:40:30,500 --> 00:40:34,520
cost of four bytes

00:40:31,850 --> 00:40:37,910
I can now encapsulate all Ethernet types

00:40:34,520 --> 00:40:40,610
all IP protocols interestingly enough

00:40:37,910 --> 00:40:43,040
one of the one of the ideas somebody had

00:40:40,610 --> 00:40:46,520
for for gue they want to encapsulate 802

00:40:43,040 --> 00:40:49,430
11 apparently 802 dot 11 has no way to

00:40:46,520 --> 00:40:51,820
bridge over IP at this point so some

00:40:49,430 --> 00:40:58,690
creative uses of this I already have

00:40:51,820 --> 00:41:00,620
another point is that you mentioned that

00:40:58,690 --> 00:41:04,670
there's a lot of use case in the

00:41:00,620 --> 00:41:09,430
virtualization space and when we discuss

00:41:04,670 --> 00:41:11,570
the the flow api so we want to have

00:41:09,430 --> 00:41:13,820
encapsulation for traffic that does not

00:41:11,570 --> 00:41:19,730
go through the hypervisor networking

00:41:13,820 --> 00:41:21,500
stack first our V so the harder would do

00:41:19,730 --> 00:41:23,950
the encapsulation decapsulation and

00:41:21,500 --> 00:41:27,200
however is less flexible

00:41:23,950 --> 00:41:29,210
unfortunately so I believe that stuff

00:41:27,200 --> 00:41:33,080
like our CEO is a bit too much for

00:41:29,210 --> 00:41:34,670
hardware like what would you define is

00:41:33,080 --> 00:41:39,590
the minimum set of requirement for

00:41:34,670 --> 00:41:42,410
Hardware our CEO would only are ciosed

00:41:39,590 --> 00:41:46,010
only make sense if you have a

00:41:42,410 --> 00:41:49,910
transmitter that is both sending a TCP

00:41:46,010 --> 00:41:53,480
segment and doing encapsulation so it's

00:41:49,910 --> 00:41:55,370
- it's emulating the TCP offload so it

00:41:53,480 --> 00:41:59,090
would only be used in that context now

00:41:55,370 --> 00:42:01,910
if you had a receiver receiving remote

00:41:59,090 --> 00:42:03,650
checksum offload and it couldn't it

00:42:01,910 --> 00:42:06,800
doesn't have to compute the full packet

00:42:03,650 --> 00:42:09,650
checksum it does need to do a little bit

00:42:06,800 --> 00:42:13,700
of manipulation on the headers

00:42:09,650 --> 00:42:17,020
I know I don't have guidelines on what

00:42:13,700 --> 00:42:19,339
the hardware should or shouldn't support

00:42:17,020 --> 00:42:20,869
you know anymore that I have guidelines

00:42:19,339 --> 00:42:25,130
on whether hardware should be allowed to

00:42:20,869 --> 00:42:27,289
use a zero UDP checksum in ipv6 I think

00:42:25,130 --> 00:42:30,650
this is you know we could develop these

00:42:27,289 --> 00:42:32,720
guidelines if necessary but the point is

00:42:30,650 --> 00:42:35,839
something like marceia really is it has

00:42:32,720 --> 00:42:38,630
meaning to the host and in a certain

00:42:35,839 --> 00:42:40,849
context if I knew that I was only in

00:42:38,630 --> 00:42:44,270
communicating host to host I would use

00:42:40,849 --> 00:42:46,220
that if I knew that I was talking to to

00:42:44,270 --> 00:42:48,230
a device then maybe I can figure

00:42:46,220 --> 00:42:50,480
something different so I think there's

00:42:48,230 --> 00:42:53,839
going to be a class of options or

00:42:50,480 --> 00:42:56,990
extensions here that you could implement

00:42:53,839 --> 00:43:00,319
everywhere but it wouldn't make sense to

00:42:56,990 --> 00:43:02,569
do that so I don't want to send a UDP

00:43:00,319 --> 00:43:04,490
nonzero checksum to a device that can't

00:43:02,569 --> 00:43:06,099
process it so how are we going to deal

00:43:04,490 --> 00:43:08,180
with that it's more of a meta question

00:43:06,099 --> 00:43:10,460
because we have to we have to concede

00:43:08,180 --> 00:43:12,010
that device capabilities and host

00:43:10,460 --> 00:43:14,569
capabilities are very different things

00:43:12,010 --> 00:43:17,450
yet we're trying to kind of design and

00:43:14,569 --> 00:43:19,160
build protocols that satisfy all the

00:43:17,450 --> 00:43:20,809
requirements so if some of my

00:43:19,160 --> 00:43:23,329
requirements are I want this to work

00:43:20,809 --> 00:43:26,690
really well one host with ten-year-old

00:43:23,329 --> 00:43:28,760
Nicks that's not exactly the same as

00:43:26,690 --> 00:43:30,619
like a switch vendor who's trying to

00:43:28,760 --> 00:43:33,559
make this work well and the latest and

00:43:30,619 --> 00:43:35,779
greatest switch so much like TCP how do

00:43:33,559 --> 00:43:38,359
we get to a point where the same

00:43:35,779 --> 00:43:41,329
protocol works efficiently across all of

00:43:38,359 --> 00:43:43,190
these requirements so I think this this

00:43:41,329 --> 00:43:45,950
is not a simple question than you're

00:43:43,190 --> 00:43:48,559
asking this is more case-by-case basis

00:43:45,950 --> 00:43:51,079
does it make sense or is this an obvious

00:43:48,559 --> 00:43:53,150
thing a switch could have to be honest

00:43:51,079 --> 00:43:56,410
one of the biggest rationales for

00:43:53,150 --> 00:44:00,319
generic UDP encapsulation that we have

00:43:56,410 --> 00:44:02,150
we need some sort of security that we

00:44:00,319 --> 00:44:05,000
send in these encapsulation packets and

00:44:02,150 --> 00:44:07,970
if you think in especially network

00:44:05,000 --> 00:44:10,010
virtualization the first requirement of

00:44:07,970 --> 00:44:12,529
network network virtualization really is

00:44:10,010 --> 00:44:15,200
isolation between two tenets on an

00:44:12,529 --> 00:44:17,569
isolate my different customers I have

00:44:15,200 --> 00:44:20,150
two mortal customers now running on the

00:44:17,569 --> 00:44:22,279
same machine sometimes I have to

00:44:20,150 --> 00:44:23,750
guarantee that their packets don't cross

00:44:22,279 --> 00:44:28,640
the bad news

00:44:23,750 --> 00:44:32,020
so for us we need some semblance of

00:44:28,640 --> 00:44:35,869
guarantee of that and one idea is to use

00:44:32,020 --> 00:44:37,340
like a cookie like in l2tp basically put

00:44:35,869 --> 00:44:40,070
a cookie in the packet that's a security

00:44:37,340 --> 00:44:45,650
token and this is an additional thing we

00:44:40,070 --> 00:44:48,290
have to match on receive so this is kind

00:44:45,650 --> 00:44:50,480
of a solution to an obvious problem that

00:44:48,290 --> 00:44:53,420
we see but again how this translates

00:44:50,480 --> 00:44:55,130
into Universal Harvard support I don't

00:44:53,420 --> 00:44:57,560
know and there are certainly cases of

00:44:55,130 --> 00:44:59,990
generic UDP encapsulation when it's

00:44:57,560 --> 00:45:01,820
going to look more like GRE which is I'm

00:44:59,990 --> 00:45:05,540
just using this for the purposes of

00:45:01,820 --> 00:45:09,680
transiting a network that that's not

00:45:05,540 --> 00:45:12,920
routable ipv6 over ipv4 encapsulation

00:45:09,680 --> 00:45:14,390
could use URI or goo or whatever then

00:45:12,920 --> 00:45:16,280
you're just trying to get packets across

00:45:14,390 --> 00:45:18,260
this this backbone that doesn't support

00:45:16,280 --> 00:45:20,869
your protocol so a lot of different use

00:45:18,260 --> 00:45:22,700
cases for this and one important thing

00:45:20,869 --> 00:45:25,790
about about goo when you compare it to

00:45:22,700 --> 00:45:27,440
to VX LAN or genve this really is

00:45:25,790 --> 00:45:30,290
designed not just for network

00:45:27,440 --> 00:45:32,119
fertilization but also to be generic use

00:45:30,290 --> 00:45:35,450
case and in some case in some sense it's

00:45:32,119 --> 00:45:38,410
actually a successor to GRE give us more

00:45:35,450 --> 00:45:44,030
flexibility more options in terms of

00:45:38,410 --> 00:45:44,599
extensions I love you know Don GBP happy

00:45:44,030 --> 00:45:47,480
hater

00:45:44,599 --> 00:45:49,640
so that makes me look hot for more I

00:45:47,480 --> 00:45:52,310
want an obvious next step is service

00:45:49,640 --> 00:45:56,750
training we're currently doing this we

00:45:52,310 --> 00:45:59,240
explained GP and SH thing and I'm

00:45:56,750 --> 00:46:00,770
looking at goo and I'm wondering I've

00:45:59,240 --> 00:46:04,599
looked into the ideas for something that

00:46:00,770 --> 00:46:09,500
Google would you see that as a good fit

00:46:04,599 --> 00:46:13,040
well yes but the thing about service

00:46:09,500 --> 00:46:15,830
chaining is at what level right so you

00:46:13,040 --> 00:46:18,200
could certainly take a complete goo

00:46:15,830 --> 00:46:20,599
packet and put it inside a service chain

00:46:18,200 --> 00:46:22,790
and that's then the service chain is

00:46:20,599 --> 00:46:24,410
transparent to go but I think your

00:46:22,790 --> 00:46:26,720
question is more is how do you integrate

00:46:24,410 --> 00:46:29,020
it into the encapsulation yeah the

00:46:26,720 --> 00:46:31,190
question would be like we would like to

00:46:29,020 --> 00:46:32,930
define the service chain and then

00:46:31,190 --> 00:46:34,200
individual functions and define the

00:46:32,930 --> 00:46:38,810
order ending in

00:46:34,200 --> 00:46:41,609
young cap Hatter so I think in terms of

00:46:38,810 --> 00:46:46,980
protocol obviously we need a way to

00:46:41,609 --> 00:46:49,920
insert nsh inside of goo and right now I

00:46:46,980 --> 00:46:51,420
don't believe it's an IP protocol which

00:46:49,920 --> 00:46:54,450
it probably should be but that's a

00:46:51,420 --> 00:46:57,599
that's up to the standards so there's

00:46:54,450 --> 00:47:03,270
kind of two options insert a GRE header

00:46:57,599 --> 00:47:06,960
and then there is a ether type for an SH

00:47:03,270 --> 00:47:08,369
or we have another there's another

00:47:06,960 --> 00:47:11,550
mechanism that I really didn't talk

00:47:08,369 --> 00:47:14,940
about within goo we have a separate

00:47:11,550 --> 00:47:17,070
number space called control space so we

00:47:14,940 --> 00:47:18,810
have an 8 bit IP protocol that can

00:47:17,070 --> 00:47:21,630
either be an IP protocol number or a

00:47:18,810 --> 00:47:25,230
control number the control number would

00:47:21,630 --> 00:47:27,119
be controlled by by kind of a separate

00:47:25,230 --> 00:47:30,660
mechanism it's not an IP protocol number

00:47:27,119 --> 00:47:32,930
so in theory we can define whatever we

00:47:30,660 --> 00:47:35,099
want in there so it doesn't have to be

00:47:32,930 --> 00:47:37,410
like a no way yeah message like the

00:47:35,099 --> 00:47:41,430
original intent was if necessary we

00:47:37,410 --> 00:47:44,369
could just define another nsh type it's

00:47:41,430 --> 00:47:46,440
kind of similar to the VX lan GPE they

00:47:44,369 --> 00:47:48,510
have the ability to define new types but

00:47:46,440 --> 00:47:50,310
some of them are IP protocols anyway so

00:47:48,510 --> 00:47:52,710
we can kind of combine the best of both

00:47:50,310 --> 00:47:54,210
of those but in terms of the the

00:47:52,710 --> 00:47:57,930
semantics then I think it would just

00:47:54,210 --> 00:48:04,740
follow like the VX LAN GPE and the

00:47:57,930 --> 00:48:09,140
ability to add nsh headers hopefully

00:48:04,740 --> 00:48:11,099
that would be sort of a layer above that

00:48:09,140 --> 00:48:14,490
so I think what we need in the

00:48:11,099 --> 00:48:17,760
consolation is the ability to put those

00:48:14,490 --> 00:48:19,680
in to the protocol headers but should

00:48:17,760 --> 00:48:21,210
not be dependent on that as part of the

00:48:19,680 --> 00:48:27,440
encapsulation that would be my model at

00:48:21,210 --> 00:48:27,440

YouTube URL: https://www.youtube.com/watch?v=hKTD9W2C5s8


