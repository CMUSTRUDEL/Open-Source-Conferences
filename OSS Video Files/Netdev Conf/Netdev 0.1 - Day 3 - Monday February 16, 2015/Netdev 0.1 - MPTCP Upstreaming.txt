Title: Netdev 0.1 - MPTCP Upstreaming
Publication date: 2015-03-21
Playlist: Netdev 0.1 - Day 3 - Monday February 16, 2015
Description: 
	MPTCP Upstreaming by Octavian Purdila
February 2015

Description from netdev01.org:
 MultiPath TCP is a transport layer protocol which takes advantage of today's Internet architecture where multiple paths exist between endpoints. The application uses a single TCP-like socket with multiple subflows being started in kernel-space for the same connection. These subflows are implemented as normal TCP connections and are completely transparent to the application. MPTCP is implemented in the Linux Kernel in an off-tree open-source repository maintained by the academic community.

Our aim is to bring the off-tree Linux Kernel MPTCP implementation in the official tree in order to gain additional contributors and accelerate innovation. The problem is that the code from the off-tree implementation heavily modifies the TCP stack such that an upstream submission can't be accepted without cleaning the TCP stack and moving the MPTCP related operations to a separate layer. Since MPTCP subflows are based on regular TCP connections, the new architectural approach is to call TCP code from the new layer instead of modifying it. Apart from removing the mix between the TCP and MPTCP code and making it a successful candidate for the upstream process, this new layer brings other advantages like allocating the MPTCP data structures at the socket creation and avoiding the overhead of switching from TCP to MPTCP at connection time. In order to implement the MPTCP separate layer, a series of problems must be solved: passing data to/from the subflow level, locking scenarios, performance penalties, switching between TCP and MPTCP, separation of data structures and allocating them at the right moment.


https://www.netdev01.org

This video is licensed under Creative Commons Attribution-ShareAlike 4.0 International license. Feel free to download and distribute.
Captions: 
	00:00:02,129 --> 00:00:09,250
hello everyone my name is Octavia I work

00:00:06,519 --> 00:00:12,100
for in hell I'm part of the OMG center

00:00:09,250 --> 00:00:14,800
and I'm here to talk about some of the

00:00:12,100 --> 00:00:17,429
work we have been doing in order to

00:00:14,800 --> 00:00:19,810
shape the existing IP tcp implementation

00:00:17,429 --> 00:00:23,439
so that we can eventually merge it

00:00:19,810 --> 00:00:25,659
upstream our group has been working with

00:00:23,439 --> 00:00:27,550
the multipath TCP in a couple of

00:00:25,659 --> 00:00:31,210
research projects and I have been

00:00:27,550 --> 00:00:34,480
involved in you know in the capacity to

00:00:31,210 --> 00:00:36,969
try and see what we can do in order to

00:00:34,480 --> 00:00:39,100
merge NP disappear upstream I think that

00:00:36,969 --> 00:00:41,109
it's important because as you will see

00:00:39,100 --> 00:00:43,989
we have some interesting use cases with

00:00:41,109 --> 00:00:48,129
MPD CP but those use cases cannot really

00:00:43,989 --> 00:00:52,710
be deployed if we don't have you know a

00:00:48,129 --> 00:00:58,059
real operating system support for MP TCP

00:00:52,710 --> 00:01:00,909
so here's the agenda um I want to try

00:00:58,059 --> 00:01:03,339
and very briefly explain what ABT CP is

00:01:00,909 --> 00:01:05,620
and then I'm going to present some of

00:01:03,339 --> 00:01:08,700
the important use cases and then we're

00:01:05,620 --> 00:01:10,930
going to dive into the implementation

00:01:08,700 --> 00:01:12,610
basically the the existing

00:01:10,930 --> 00:01:15,640
implementation and then some of the work

00:01:12,610 --> 00:01:18,250
we did so that we can you know make it

00:01:15,640 --> 00:01:21,150
more clean and make you more less

00:01:18,250 --> 00:01:25,390
changes as we will see at the DCP stack

00:01:21,150 --> 00:01:28,480
my my objective for this talk is to keep

00:01:25,390 --> 00:01:30,730
it short and then to make sure they have

00:01:28,480 --> 00:01:33,310
some sort of a discussion to get your

00:01:30,730 --> 00:01:37,030
feedback and to see you know what is the

00:01:33,310 --> 00:01:38,980
right way what we can do to you know to

00:01:37,030 --> 00:01:43,560
get slowly to that point where you can

00:01:38,980 --> 00:01:46,930
merge multipath TCP upstream okay so

00:01:43,560 --> 00:01:49,180
let's start with briefly describing what

00:01:46,930 --> 00:01:53,260
multipath TCP is above so multipath TCP

00:01:49,180 --> 00:01:56,980
it's a multipass solution done at the

00:01:53,260 --> 00:01:58,840
transport layer it is one ITF standard I

00:01:56,980 --> 00:02:02,890
think it's experimental at this stage

00:01:58,840 --> 00:02:05,140
and what it tries to do it tries to take

00:02:02,890 --> 00:02:08,140
advantage of the multipath multi path

00:02:05,140 --> 00:02:11,530
between two endpoints and it tries to do

00:02:08,140 --> 00:02:13,340
so in a compatible way application

00:02:11,530 --> 00:02:15,980
compatible as well as network compare

00:02:13,340 --> 00:02:18,230
both the idea being that you don't want

00:02:15,980 --> 00:02:21,319
to change the application once you have

00:02:18,230 --> 00:02:23,450
support multipath TCP supporting that

00:02:21,319 --> 00:02:25,370
stack then you don't need to compile

00:02:23,450 --> 00:02:29,000
your application you'll just be able to

00:02:25,370 --> 00:02:32,959
use the multi paths available if there

00:02:29,000 --> 00:02:36,230
are any and also it was designed with a

00:02:32,959 --> 00:02:39,769
few things in mind it should work as

00:02:36,230 --> 00:02:42,680
well as TCP it should work when TCP

00:02:39,769 --> 00:02:45,019
works if you know we cannot use the

00:02:42,680 --> 00:02:48,019
multipath extension it should fall back

00:02:45,019 --> 00:02:53,079
to TCP so at least we you know we have

00:02:48,019 --> 00:02:56,209
the connections going and also has some

00:02:53,079 --> 00:02:58,549
some some thought has been done for the

00:02:56,209 --> 00:03:00,379
congestion part so it tries to be fair

00:02:58,549 --> 00:03:03,349
with TCP for instance if you have a

00:03:00,379 --> 00:03:06,019
multipath TCP which we are going to see

00:03:03,349 --> 00:03:08,060
that is using multiple flows it tries

00:03:06,019 --> 00:03:09,799
not you know to be fair from a

00:03:08,060 --> 00:03:14,420
congesting point of view and act just

00:03:09,799 --> 00:03:16,819
like a TCP connection even if we can

00:03:14,420 --> 00:03:20,690
have for instance two flows and we have

00:03:16,819 --> 00:03:23,660
another additional TCP connection it

00:03:20,690 --> 00:03:25,819
should so to speak eat half of the

00:03:23,660 --> 00:03:28,060
bandwidth not you know want two thirds

00:03:25,819 --> 00:03:34,730
for the multipath and one-third for TCP

00:03:28,060 --> 00:03:38,690
so let's now look at a few use cases I

00:03:34,730 --> 00:03:41,090
think one of the obvious use case for

00:03:38,690 --> 00:03:44,690
multipath TCP especially with today's

00:03:41,090 --> 00:03:50,090
focus on mobility is the one where you

00:03:44,690 --> 00:03:52,880
want to use a 22 to pass like 3G 11 and

00:03:50,090 --> 00:03:55,370
Wi-Fi so you usually have your mobile

00:03:52,880 --> 00:03:58,430
phone you have 3g and Wi-Fi connectivity

00:03:55,370 --> 00:04:00,380
and with a multipath TCP you're going to

00:03:58,430 --> 00:04:02,269
be able to use both of these connections

00:04:00,380 --> 00:04:05,510
without needing to change the

00:04:02,269 --> 00:04:07,280
application and also you can fail over

00:04:05,510 --> 00:04:10,190
from one connection to the other you can

00:04:07,280 --> 00:04:12,530
use both connections and you this is

00:04:10,190 --> 00:04:13,760
done completely transparent the

00:04:12,530 --> 00:04:15,829
application doesn't need to do a thing

00:04:13,760 --> 00:04:17,930
the connection is not going to be

00:04:15,829 --> 00:04:20,709
interrupted you don't need to reopen the

00:04:17,930 --> 00:04:24,080
connection so that's this is one of the

00:04:20,709 --> 00:04:26,750
typical use cases other use cases are

00:04:24,080 --> 00:04:29,270
you know let's say are roaming

00:04:26,750 --> 00:04:32,720
use case where you're in the office you

00:04:29,270 --> 00:04:35,480
are connected to the wire net or network

00:04:32,720 --> 00:04:38,600
and then you move to the you know you

00:04:35,480 --> 00:04:41,390
move to the conference room and you're

00:04:38,600 --> 00:04:44,240
connected we're wireless and if you want

00:04:41,390 --> 00:04:46,660
to keep your existing connections active

00:04:44,240 --> 00:04:49,160
you can do so with multipath TCP

00:04:46,660 --> 00:04:51,290
multipath TCP is not only about you know

00:04:49,160 --> 00:04:54,710
keeping the connection active it also

00:04:51,290 --> 00:04:57,380
has nice side effect that it will if you

00:04:54,710 --> 00:05:00,710
are connected to multiple paths and if

00:04:57,380 --> 00:05:02,690
you know the quality of the links the

00:05:00,710 --> 00:05:04,570
quality of the link of varies it will

00:05:02,690 --> 00:05:06,860
offer you the best throughput right

00:05:04,570 --> 00:05:09,320
especially this is important when you

00:05:06,860 --> 00:05:11,810
are mobile and you're let's say that you

00:05:09,320 --> 00:05:14,000
are connected to two access points in

00:05:11,810 --> 00:05:16,820
that case you don't know in advance

00:05:14,000 --> 00:05:18,830
which one is the best to you so we use

00:05:16,820 --> 00:05:21,380
best and as the quality of the link

00:05:18,830 --> 00:05:24,200
decreases you will switch to Africa way

00:05:21,380 --> 00:05:27,220
from one link to the TTI the link and

00:05:24,200 --> 00:05:30,820
you get the best throughput and the same

00:05:27,220 --> 00:05:33,590
can be I mean the same thing can be said

00:05:30,820 --> 00:05:36,470
about a latency as well you'll get the

00:05:33,590 --> 00:05:42,110
same benefits for latency so here we

00:05:36,470 --> 00:05:47,830
have a nice little graph that we we had

00:05:42,110 --> 00:05:51,740
some experiments with the mobile device

00:05:47,830 --> 00:05:53,780
connected to the 3g to the 3g network

00:05:51,740 --> 00:05:56,330
and also to the Wi-Fi here we actually

00:05:53,780 --> 00:05:58,400
have we take a trip through the subway

00:05:56,330 --> 00:06:00,650
and in the stations we have access

00:05:58,400 --> 00:06:03,350
points and you can clearly see that when

00:06:00,650 --> 00:06:07,450
we reach the station you see the the

00:06:03,350 --> 00:06:10,270
blue lines going up basically we have

00:06:07,450 --> 00:06:14,450
throughput through the Wi-Fi

00:06:10,270 --> 00:06:19,150
connectivity there are other interesting

00:06:14,450 --> 00:06:22,280
multipath TCP use cases so for instance

00:06:19,150 --> 00:06:25,070
there are papers that talk about how you

00:06:22,280 --> 00:06:27,070
can improve power how we can reduce the

00:06:25,070 --> 00:06:30,950
power consumption and basically that's

00:06:27,070 --> 00:06:33,290
raised to idle you use both I mean as

00:06:30,950 --> 00:06:35,300
many interfaces as you have in order to

00:06:33,290 --> 00:06:37,220
have a higher throughput and because

00:06:35,300 --> 00:06:38,180
that you'll finish the download faster

00:06:37,220 --> 00:06:41,150
and then you'll go to

00:06:38,180 --> 00:06:43,430
sleep faster other use cases are

00:06:41,150 --> 00:06:46,729
interesting uses are the multi Wi-Fi

00:06:43,430 --> 00:06:50,600
project which basically says that okay

00:06:46,729 --> 00:06:52,340
let's let's let's connect the mobile

00:06:50,600 --> 00:06:55,490
devices to multiple access points and

00:06:52,340 --> 00:06:57,710
with that we can avoid that through I

00:06:55,490 --> 00:07:00,380
mean the link quality issues because we

00:06:57,710 --> 00:07:04,820
don't know in advance which which Ling

00:07:00,380 --> 00:07:07,039
is going to be better and there have

00:07:04,820 --> 00:07:09,740
been some research in the data center as

00:07:07,039 --> 00:07:12,020
well because in data center usually have

00:07:09,740 --> 00:07:17,690
spared links you can use multipath TCP

00:07:12,020 --> 00:07:21,830
to improve throughput okay so now let's

00:07:17,690 --> 00:07:23,539
go over the few MP TCP basics and I'm

00:07:21,830 --> 00:07:28,039
going to present and present a handshake

00:07:23,539 --> 00:07:30,500
and a few things that we we need to know

00:07:28,039 --> 00:07:32,300
about MPDC be so basically as i

00:07:30,500 --> 00:07:34,699
mentioned MP DCP is presented to the

00:07:32,300 --> 00:07:37,910
application as a single socket and then

00:07:34,699 --> 00:07:41,780
the implementation locate multiple tcp

00:07:37,910 --> 00:07:43,610
light connections and they're almost tcp

00:07:41,780 --> 00:07:45,409
light connection so we are going to

00:07:43,610 --> 00:07:46,909
start with the scene and then we have a

00:07:45,409 --> 00:07:50,300
special option which is called MP

00:07:46,909 --> 00:07:52,610
capable and this is how you open the

00:07:50,300 --> 00:07:54,560
first connection this is going to the

00:07:52,610 --> 00:07:57,169
server and the server is going to reply

00:07:54,560 --> 00:08:00,830
back also the MP capable and which means

00:07:57,169 --> 00:08:04,580
that the server knows talks MP tcp so we

00:08:00,830 --> 00:08:06,440
can use MP TCP then and we have one

00:08:04,580 --> 00:08:08,210
connection established you can see that

00:08:06,440 --> 00:08:11,720
we have the state for that connection

00:08:08,210 --> 00:08:15,770
and it's justin tcp connection state

00:08:11,720 --> 00:08:18,530
usual usual things like sequence numbers

00:08:15,770 --> 00:08:20,509
the the window and so on now let's say

00:08:18,530 --> 00:08:24,919
that we are also connected to a Wi-Fi

00:08:20,509 --> 00:08:27,530
hotspot in when the MP DCP implementing

00:08:24,919 --> 00:08:29,750
the ability stack will detect that we

00:08:27,530 --> 00:08:32,539
have a new interface and it is available

00:08:29,750 --> 00:08:35,240
it will try to open us off flow this is

00:08:32,539 --> 00:08:37,399
what we called it which is another TCP

00:08:35,240 --> 00:08:40,630
connection you see that it sends a

00:08:37,399 --> 00:08:44,300
specialist in a packet with the joint

00:08:40,630 --> 00:08:46,670
multipath option that's basically it

00:08:44,300 --> 00:08:48,860
tells the server that it wants to attach

00:08:46,670 --> 00:08:51,769
this second anticipate connection to the

00:08:48,860 --> 00:08:53,779
same logical I'm MPDC

00:08:51,769 --> 00:08:57,559
connection and this is going to the

00:08:53,779 --> 00:09:00,829
server the server we will say okay I

00:08:57,559 --> 00:09:04,309
added the flow this offload to the

00:09:00,829 --> 00:09:08,389
connection and we now have to TCP sup

00:09:04,309 --> 00:09:10,759
flows going on now the in order to

00:09:08,389 --> 00:09:12,410
because we can send packets on either of

00:09:10,759 --> 00:09:14,480
these links we need to distinguish

00:09:12,410 --> 00:09:17,299
between you know how to order the

00:09:14,480 --> 00:09:19,610
package because the mptp connection is

00:09:17,299 --> 00:09:23,350
be scented to the user just like a

00:09:19,610 --> 00:09:27,110
regular TCP session right so we have

00:09:23,350 --> 00:09:30,259
other MP TCP options which say which

00:09:27,110 --> 00:09:33,079
maps basically the South flow packets to

00:09:30,259 --> 00:09:35,869
the connection saw flow yeah software

00:09:33,079 --> 00:09:39,679
package to the connection level so you

00:09:35,869 --> 00:09:42,489
basically have a double sequence space

00:09:39,679 --> 00:09:45,049
one for the South flow and one for the

00:09:42,489 --> 00:09:48,439
multipath connection overall connection

00:09:45,049 --> 00:09:51,799
and you can see here that we have data

00:09:48,439 --> 00:09:58,970
and sequences to order the basically

00:09:51,799 --> 00:10:01,850
they are the important part here is the

00:09:58,970 --> 00:10:03,470
data sequence which tells you which we

00:10:01,850 --> 00:10:06,829
know how to order the packets across the

00:10:03,470 --> 00:10:10,309
the connection and also we have an data

00:10:06,829 --> 00:10:14,329
act which which acknowledges the package

00:10:10,309 --> 00:10:18,970
is the mb TCP connection level any

00:10:14,329 --> 00:10:18,970
questions so far about the protocol yes

00:10:40,170 --> 00:10:48,070
um so the choice yeah actually perfect

00:10:45,640 --> 00:10:50,830
picture so when the cell phone in this

00:10:48,070 --> 00:10:53,230
case is picking the alternate path what

00:10:50,830 --> 00:10:54,910
layer of the stack so is it the TCP

00:10:53,230 --> 00:10:56,980
stock that's saying I have a second path

00:10:54,910 --> 00:10:59,860
because then you're divorcing it from

00:10:56,980 --> 00:11:02,980
routing is it a bonding decision how do

00:10:59,860 --> 00:11:05,290
you it is the MP TCP stack so basically

00:11:02,980 --> 00:11:07,150
the for example the way it's currently

00:11:05,290 --> 00:11:09,670
implemented we listen for netlink

00:11:07,150 --> 00:11:11,980
offense when the interface comes up and

00:11:09,670 --> 00:11:13,390
we detect the interface we detect we

00:11:11,980 --> 00:11:16,470
also see that it has an IP address

00:11:13,390 --> 00:11:19,630
attached and once we have that we

00:11:16,470 --> 00:11:23,200
basically I know start this the second

00:11:19,630 --> 00:11:24,580
flow but then that's not sufficient or

00:11:23,200 --> 00:11:26,980
if somebody has to do a routing look up

00:11:24,580 --> 00:11:28,870
to say they're all regular interface is

00:11:26,980 --> 00:11:31,000
also viable right because you might have

00:11:28,870 --> 00:11:33,370
let's say hundreds of interfaces mhm or

00:11:31,000 --> 00:11:35,110
is that not the use case the use case is

00:11:33,370 --> 00:11:36,700
that the two interfaces they're

00:11:35,110 --> 00:11:39,280
connected to the same subnet and and

00:11:36,700 --> 00:11:41,050
that's the requirement um I'm not

00:11:39,280 --> 00:11:42,790
showering so let's have a hundred

00:11:41,050 --> 00:11:45,910
interfaces how do I decide what my

00:11:42,790 --> 00:11:48,880
second interface is well yeah um the way

00:11:45,910 --> 00:11:50,980
on how you decide you know when if you

00:11:48,880 --> 00:11:53,410
want to start as a flow or not is done

00:11:50,980 --> 00:11:55,930
in a separate so basically MP TCP

00:11:53,410 --> 00:11:58,090
limitation right now it's kind of has

00:11:55,930 --> 00:12:01,570
separate modules so we have for instance

00:11:58,090 --> 00:12:04,240
a module to decide on which which way to

00:12:01,570 --> 00:12:06,720
send a packet and also have a module to

00:12:04,240 --> 00:12:10,600
decide if you want to start or not the

00:12:06,720 --> 00:12:13,960
subfloor on which interfaces are right

00:12:10,600 --> 00:12:19,300
now I think we have two two ways of

00:12:13,960 --> 00:12:23,440
doing this we can say that you know we

00:12:19,300 --> 00:12:25,110
want to start us off low on we can start

00:12:23,440 --> 00:12:27,940
even multiple subfloors on the same

00:12:25,110 --> 00:12:30,700
networking for interface that one's easy

00:12:27,940 --> 00:12:32,730
to understand okay or you can your

00:12:30,700 --> 00:12:35,650
cancer you can say okay we want to start

00:12:32,730 --> 00:12:37,990
is it not multiple you do like what I

00:12:35,650 --> 00:12:40,270
see TP does correct the app has to do

00:12:37,990 --> 00:12:42,490
multiple connect and not not the app

00:12:40,270 --> 00:12:45,460
this is decided by the MP TCP layer

00:12:42,490 --> 00:12:48,100
itself ok so how it is transparent to

00:12:45,460 --> 00:12:49,230
the application I guess I'm just as

00:12:48,100 --> 00:12:52,090
confused

00:12:49,230 --> 00:12:54,760
so I mean once you have you know you

00:12:52,090 --> 00:12:56,980
have one interface right you know what

00:12:54,760 --> 00:12:58,960
the other you start the connection from

00:12:56,980 --> 00:13:01,560
one interface to the other IP and

00:12:58,960 --> 00:13:06,070
pointers say and then you have another

00:13:01,560 --> 00:13:07,900
interface which has you know you just

00:13:06,070 --> 00:13:10,330
associated that access point you get an

00:13:07,900 --> 00:13:12,010
IP address and use that IP address to

00:13:10,330 --> 00:13:13,540
open a new connection today the same

00:13:12,010 --> 00:13:15,160
pier basic I think the question is how

00:13:13,540 --> 00:13:19,480
do you know that address is reachable

00:13:15,160 --> 00:13:25,530
through that interface that we just try

00:13:19,480 --> 00:13:34,590
it if it doesn't work we so it's why yes

00:13:25,530 --> 00:13:34,590
yes yeah okay any other questions

00:13:49,090 --> 00:13:56,780
yeah yeah I think we have different

00:13:53,330 --> 00:13:59,150
modules so if you use we have one module

00:13:56,780 --> 00:14:01,100
is called and if port and that will

00:13:59,150 --> 00:14:03,890
basically tell you that you can start

00:14:01,100 --> 00:14:07,210
you can set the number of soph loss that

00:14:03,890 --> 00:14:13,330
you can open on a per interface level

00:14:07,210 --> 00:14:15,860
it's configurable and I mean also um

00:14:13,330 --> 00:14:18,500
these sorts of policy decision I think

00:14:15,860 --> 00:14:21,800
there are hard to you know to design a

00:14:18,500 --> 00:14:24,280
universal way that's why we have kind of

00:14:21,800 --> 00:14:29,960
this pluggable approach where you can

00:14:24,280 --> 00:14:33,020
you know bright multiple policymaker

00:14:29,960 --> 00:14:36,230
let's say modules because in was news

00:14:33,020 --> 00:14:38,780
case it may be perfect sense to use you

00:14:36,230 --> 00:14:41,090
know one flow for each which sub

00:14:38,780 --> 00:14:42,770
interface but as mentioned early if you

00:14:41,090 --> 00:14:46,420
have a 100 interface it should be open

00:14:42,770 --> 00:14:46,420
up saw flow for each one so

00:14:57,070 --> 00:15:01,430
yes so multipath allows you in

00:14:59,960 --> 00:15:03,350
concurrent connections a concurrent

00:15:01,430 --> 00:15:06,010
connections any concern attack on

00:15:03,350 --> 00:15:07,880
current you can also configure it I mean

00:15:06,010 --> 00:15:09,650
depending on the use case for instance

00:15:07,880 --> 00:15:12,620
if you want higher throughput you'll

00:15:09,650 --> 00:15:16,880
probably want to send packets on on both

00:15:12,620 --> 00:15:19,040
or multiple links but another

00:15:16,880 --> 00:15:21,530
interesting use case is if you want a

00:15:19,040 --> 00:15:25,340
lower latency you may want to duplicate

00:15:21,530 --> 00:15:27,590
the same packet and send the same packet

00:15:25,340 --> 00:15:30,650
across multiple links and basically that

00:15:27,590 --> 00:15:32,330
will get you the lowest latency if you

00:15:30,650 --> 00:15:34,840
don't know I mean if it's hard to know

00:15:32,330 --> 00:15:44,180
in advance what the latency is for those

00:15:34,840 --> 00:15:46,070
links I mean there are people I've been

00:15:44,180 --> 00:15:48,560
working with that have been doing

00:15:46,070 --> 00:15:51,650
experiments at the data center they have

00:15:48,560 --> 00:15:53,930
seen personally I have not but I know

00:15:51,650 --> 00:15:57,020
about the this this research and I think

00:15:53,930 --> 00:15:59,900
that have seen up to thirty thirty

00:15:57,020 --> 00:16:01,820
percent maybe even more increasing

00:15:59,900 --> 00:16:05,450
throughput it depends on all depends on

00:16:01,820 --> 00:16:10,730
the me first I mean the topology I think

00:16:05,450 --> 00:16:11,960
that was seen in fat32 apologies there

00:16:10,730 --> 00:16:16,570
are I think they're there is at least

00:16:11,960 --> 00:16:20,330
one paper which was presented at NDIS

00:16:16,570 --> 00:16:22,370
2012 maybe 13 I don't remember which

00:16:20,330 --> 00:16:29,180
talks about multipath TCP and data

00:16:22,370 --> 00:16:31,970
center Eric you know I had a question

00:16:29,180 --> 00:16:34,940
about the second path you open what

00:16:31,970 --> 00:16:38,030
makes sure that you hit the same server

00:16:34,940 --> 00:16:40,190
on the second path because most people

00:16:38,030 --> 00:16:43,910
use wrong load balancers stuff like that

00:16:40,190 --> 00:16:47,480
so not sure how you can guarantee that

00:16:43,910 --> 00:16:51,590
the connection will hit the same yeah i

00:16:47,480 --> 00:16:54,290
think we use we we send some messages in

00:16:51,590 --> 00:16:55,790
the gcp when when we did in negotiation

00:16:54,290 --> 00:17:01,280
and I think Chris tough maybe can answer

00:16:55,790 --> 00:17:02,550
that question better yeah so if it the

00:17:01,280 --> 00:17:04,319
server is sitting behind

00:17:02,550 --> 00:17:06,720
balance in the load balancer penance to

00:17:04,319 --> 00:17:10,949
look based on D on the source IP which

00:17:06,720 --> 00:17:12,990
they often do I think so there the thing

00:17:10,949 --> 00:17:16,589
is with amputees p or probably will need

00:17:12,990 --> 00:17:18,630
to put if you have a big server farm to

00:17:16,589 --> 00:17:20,790
put basically to terminate the amputees

00:17:18,630 --> 00:17:23,550
p connection at the edge of the budget

00:17:20,790 --> 00:17:24,929
of the idea of your server farm so

00:17:23,550 --> 00:17:27,209
basically that all connections gets

00:17:24,929 --> 00:17:29,850
terminated on the same server another

00:17:27,209 --> 00:17:32,309
solution would be for example the server

00:17:29,850 --> 00:17:34,830
can if the server sitting behind a load

00:17:32,309 --> 00:17:36,990
balancer he could announce if he has a

00:17:34,830 --> 00:17:38,790
public IP he could announce this public

00:17:36,990 --> 00:17:42,230
IP and from that moment on new suffix

00:17:38,790 --> 00:17:42,230
only go to this public IP

00:18:00,960 --> 00:18:20,590
yes okay does it answer your question

00:18:08,530 --> 00:18:25,410
Eric okay I'm any other questions if one

00:18:20,590 --> 00:18:25,410
of the two paths is bad would it have a

00:18:25,440 --> 00:18:32,050
worse effect that not having the path at

00:18:28,720 --> 00:18:34,600
all yeah so MP disappear is designed as

00:18:32,050 --> 00:18:37,450
I mentioned earlier to be as good as and

00:18:34,600 --> 00:18:40,030
at least as TCP so in the case that the

00:18:37,450 --> 00:18:42,190
the other path is is bad and we send a

00:18:40,030 --> 00:18:44,410
packet and we don't receive an act we

00:18:42,190 --> 00:18:50,290
will rain check the packet on the other

00:18:44,410 --> 00:19:01,540
flow so it's going to continue using the

00:18:50,290 --> 00:19:04,090
the flow that it is good how do you

00:19:01,540 --> 00:19:07,360
prevent window collapse in this sort of

00:19:04,090 --> 00:19:10,150
scenario I mean you've got two links

00:19:07,360 --> 00:19:12,250
here which are clearly moving at

00:19:10,150 --> 00:19:14,890
different rates and one of which has a

00:19:12,250 --> 00:19:18,070
higher likelihood of dropping frames how

00:19:14,890 --> 00:19:21,070
does your other endpoint manage when you

00:19:18,070 --> 00:19:24,820
get so many frames out of order so the

00:19:21,070 --> 00:19:26,580
the window the the wyndham receive

00:19:24,820 --> 00:19:29,080
window part is a little bit complicated

00:19:26,580 --> 00:19:32,830
unfortunately there is no explicit

00:19:29,080 --> 00:19:34,930
explicit window for the whole MP

00:19:32,830 --> 00:19:38,380
district connection and the decision

00:19:34,930 --> 00:19:40,780
that has been made by the ITF committee

00:19:38,380 --> 00:19:44,190
is to use actually use the windows of

00:19:40,780 --> 00:19:46,800
the South flow in order to limit or

00:19:44,190 --> 00:19:53,500
influence the limit the window of the

00:19:46,800 --> 00:19:56,830
multipath connection overall no yeah so

00:19:53,500 --> 00:20:00,160
here that is because I'm not familiar

00:19:56,830 --> 00:20:03,850
with that um you know wire has been

00:20:00,160 --> 00:20:07,150
chosen but as far as I understood from

00:20:03,850 --> 00:20:09,140
christophe's because adding another

00:20:07,150 --> 00:20:10,880
adding another you know

00:20:09,140 --> 00:20:13,580
meter and disappearance would mean that

00:20:10,880 --> 00:20:16,460
we need to add another two bites and the

00:20:13,580 --> 00:20:19,400
TCP option space is already limited so

00:20:16,460 --> 00:20:30,770
that's that that's why they choose this

00:20:19,400 --> 00:20:34,010
approach okay um if any more questions

00:20:30,770 --> 00:20:36,110
I'm going to move to the basically to

00:20:34,010 --> 00:20:39,260
the implementation I'm I'm going to try

00:20:36,110 --> 00:20:42,170
to present the implementation initial

00:20:39,260 --> 00:20:43,850
implementation that has been done so the

00:20:42,170 --> 00:20:47,180
initial implementation has been learned

00:20:43,850 --> 00:20:49,940
by the academic community université

00:20:47,180 --> 00:20:52,490
catholique de loved one has been i think

00:20:49,940 --> 00:20:54,500
the driving factor is that Christoph is

00:20:52,490 --> 00:20:56,870
one Christophe as well as sebastian by

00:20:54,500 --> 00:20:59,750
r1 at the ones who did the initial

00:20:56,870 --> 00:21:01,370
implementation and the initial

00:20:59,750 --> 00:21:04,040
implantation focused on doing these

00:21:01,370 --> 00:21:06,500
things that the TCP layer are level and

00:21:04,040 --> 00:21:11,450
that is because of the some stuff that

00:21:06,500 --> 00:21:14,270
we we mentioned already it allows us to

00:21:11,450 --> 00:21:18,430
have good performance it implements

00:21:14,270 --> 00:21:21,200
stuff like TSO already I think it was

00:21:18,430 --> 00:21:22,760
there was an experiment last year a

00:21:21,200 --> 00:21:28,720
couple of years ago where you reach like

00:21:22,760 --> 00:21:32,480
50 50 gigs with a single TCP connection

00:21:28,720 --> 00:21:35,120
and it also big if you do it

00:21:32,480 --> 00:21:37,580
implementation at the DCP layer you will

00:21:35,120 --> 00:21:40,700
also have a very nice fallback approach

00:21:37,580 --> 00:21:43,700
i'm going to show you in a couple of

00:21:40,700 --> 00:21:46,490
slides of course this downside of all

00:21:43,700 --> 00:21:49,250
this is that it has it does a lot of

00:21:46,490 --> 00:21:53,420
changes this tcp stack it's intrusive it

00:21:49,250 --> 00:21:58,460
complicates the stack it the TCP stack

00:21:53,420 --> 00:22:00,020
which is already over complicated so we

00:21:58,460 --> 00:22:02,290
are trying to see what we can do to you

00:22:00,020 --> 00:22:05,660
know to manage this complexity to move

00:22:02,290 --> 00:22:08,050
part of this car outside of the TCP

00:22:05,660 --> 00:22:12,860
layer and and put it in a separate layer

00:22:08,050 --> 00:22:14,270
in order to understand now the mb

00:22:12,860 --> 00:22:17,510
disappear implementing I'm going to

00:22:14,270 --> 00:22:21,350
present some key mptp structures so we

00:22:17,510 --> 00:22:22,419
have basically three types of important

00:22:21,350 --> 00:22:24,279
structure the first

00:22:22,419 --> 00:22:26,289
is the meta socket and the meta socket

00:22:24,279 --> 00:22:31,029
is basically the circuit that is visible

00:22:26,289 --> 00:22:32,919
to the user and it doesn't have any you

00:22:31,029 --> 00:22:34,779
know it doesn't have any mapping to the

00:22:32,919 --> 00:22:37,059
actual TCP connections that are going on

00:22:34,779 --> 00:22:40,269
the absence of flows and then we have

00:22:37,059 --> 00:22:42,460
the sub flows sockets and the subfloor

00:22:40,269 --> 00:22:45,460
sockets are two sockets basically

00:22:42,460 --> 00:22:47,590
because one is that I mean two types of

00:22:45,460 --> 00:22:49,989
sockets one is the master socket and the

00:22:47,590 --> 00:22:51,700
other ones are additional sub circuits

00:22:49,989 --> 00:22:55,239
why it is important to have a master

00:22:51,700 --> 00:22:57,190
socket because without them we want to

00:22:55,239 --> 00:22:58,840
be able to do the fall back to DCP and

00:22:57,190 --> 00:23:02,350
in that case we'll see that the master

00:22:58,840 --> 00:23:04,210
socket becomes a TCP socket one

00:23:02,350 --> 00:23:06,190
important thing to note here is that all

00:23:04,210 --> 00:23:09,190
these sockets are TCP sockets are

00:23:06,190 --> 00:23:10,929
implemented as TCP sockets this has some

00:23:09,190 --> 00:23:13,029
advantages but also said has some

00:23:10,929 --> 00:23:16,239
disadvantages for instance is not

00:23:13,029 --> 00:23:18,460
natural for the matter socket to be a

00:23:16,239 --> 00:23:21,609
TCP socket because actually not

00:23:18,460 --> 00:23:24,580
participate connection right but it has

00:23:21,609 --> 00:23:26,619
some advantages one of the advantage is

00:23:24,580 --> 00:23:29,799
that you don't need to modify the code

00:23:26,619 --> 00:23:33,129
that touches the MP TCP socket accused

00:23:29,799 --> 00:23:36,519
that transfer data to and from user you

00:23:33,129 --> 00:23:39,309
can just use MP tcp I mean you can just

00:23:36,519 --> 00:23:45,279
use TCP receive message to transfer data

00:23:39,309 --> 00:23:48,269
from the matter socket accuse it also

00:23:45,279 --> 00:23:52,090
allows you to transparently switch to

00:23:48,269 --> 00:23:56,379
and to have a fallback that is has a

00:23:52,090 --> 00:24:00,220
very low overhead the downside is that

00:23:56,379 --> 00:24:02,139
we need to basically be aware of what

00:24:00,220 --> 00:24:04,869
kind of socket are we dealing with in

00:24:02,139 --> 00:24:07,179
the TCP stack so we need to check is

00:24:04,869 --> 00:24:10,710
this an a meta socket is this a subfloor

00:24:07,179 --> 00:24:14,710
circuit is this a master socket sometime

00:24:10,710 --> 00:24:19,419
ok so how is the master socket created

00:24:14,710 --> 00:24:21,249
this is basically the the master socket

00:24:19,419 --> 00:24:23,859
is created and is not created

00:24:21,249 --> 00:24:25,690
immediately where it's created once we

00:24:23,859 --> 00:24:28,960
know that we have established that we

00:24:25,690 --> 00:24:31,480
have we have a multipath TCP connection

00:24:28,960 --> 00:24:35,139
so once you have you know that I'm act

00:24:31,480 --> 00:24:35,950
and multi PMP capable flag available we

00:24:35,139 --> 00:24:37,480
will create

00:24:35,950 --> 00:24:41,830
Master circuit and the master socket is

00:24:37,480 --> 00:24:43,510
created sort of a clone it's a special

00:24:41,830 --> 00:24:46,510
Clone initially it was a special Clone

00:24:43,510 --> 00:24:48,700
because we wanted to treat both we want

00:24:46,510 --> 00:24:53,850
to have be able to use both ipv4 and

00:24:48,700 --> 00:24:59,049
ipv6 on the same logical connection and

00:24:53,850 --> 00:25:00,639
what allows us us to do is to in the

00:24:59,049 --> 00:25:03,210
case we are seeing the case that you

00:25:00,639 --> 00:25:08,409
know I things go badly will be able to

00:25:03,210 --> 00:25:10,539
revert back to the TCP socket so this is

00:25:08,409 --> 00:25:13,000
I mean this this is nice because you

00:25:10,539 --> 00:25:14,980
don't create a master socket immediately

00:25:13,000 --> 00:25:17,710
but on the other hand you need all this

00:25:14,980 --> 00:25:22,090
other squad of the connection layer in

00:25:17,710 --> 00:25:26,200
order to the plone in the case where we

00:25:22,090 --> 00:25:28,809
fall back the TCP we just we want to

00:25:26,200 --> 00:25:31,149
receive them NP capable option and in

00:25:28,809 --> 00:25:34,149
that case what we do we set you know we

00:25:31,149 --> 00:25:36,700
set the special flag inside the meta

00:25:34,149 --> 00:25:38,769
socket and the meta socket effectively

00:25:36,700 --> 00:25:42,880
becomes a TCP socket because we won't

00:25:38,769 --> 00:25:47,710
take any multi5 decisions on on it

00:25:42,880 --> 00:25:49,840
anymore ok now about how the package

00:25:47,710 --> 00:25:53,100
flow through the queue through the cells

00:25:49,840 --> 00:25:55,809
into the meta so cute i'm going to do it

00:25:53,100 --> 00:25:59,950
dive into that but before that just a

00:25:55,809 --> 00:26:03,730
quick summary of how the tcp queues work

00:25:59,950 --> 00:26:05,980
this is just a simplification so we

00:26:03,730 --> 00:26:08,320
under the safe side we have the TCP

00:26:05,980 --> 00:26:10,740
packets kamath and then they are getting

00:26:08,320 --> 00:26:14,350
either in the back look you if the

00:26:10,740 --> 00:26:17,620
socket is locked or if they go directed

00:26:14,350 --> 00:26:19,539
to the rescue we also if needed we and

00:26:17,620 --> 00:26:24,250
there is also the out-of-order queue if

00:26:19,539 --> 00:26:26,470
the packets are not in order and from

00:26:24,250 --> 00:26:28,419
the receive queue the packets are going

00:26:26,470 --> 00:26:31,299
to be copied to userspace through GCPD

00:26:28,419 --> 00:26:33,309
receive message on there is on the same

00:26:31,299 --> 00:26:35,919
side we have to sufficient message that

00:26:33,309 --> 00:26:38,139
puts packets into the right Q and then

00:26:35,919 --> 00:26:40,240
through either writing suite or

00:26:38,139 --> 00:26:42,789
retransmitted skb if we need to do a

00:26:40,240 --> 00:26:45,610
retransmission it goes to the TCP

00:26:42,789 --> 00:26:47,210
transmitted skb which pulls the amine

00:26:45,610 --> 00:26:52,340
pushes the packet to the

00:26:47,210 --> 00:26:54,950
bellaire how how the packet flows works

00:26:52,340 --> 00:26:59,210
in the NPT CP case on the receive path

00:26:54,950 --> 00:27:01,130
so on the receive path we have the

00:26:59,210 --> 00:27:04,549
package coming in of course that they

00:27:01,130 --> 00:27:06,500
coming at the cell floor level and we

00:27:04,549 --> 00:27:08,750
put them into them instead of putting

00:27:06,500 --> 00:27:13,130
them into the soft floor level we put

00:27:08,750 --> 00:27:17,779
them into the meta backlog from there we

00:27:13,130 --> 00:27:20,899
have you know we have this nice called

00:27:17,779 --> 00:27:23,299
the function backlog receive and after

00:27:20,899 --> 00:27:25,429
you know that function is called that

00:27:23,299 --> 00:27:27,649
processes the packets of the backlog Q

00:27:25,429 --> 00:27:31,760
we put them into the South flourish

00:27:27,649 --> 00:27:35,240
queue and then we also have this nice

00:27:31,760 --> 00:27:38,120
callback function s cade ready sv data

00:27:35,240 --> 00:27:39,950
ready and through that function we take

00:27:38,120 --> 00:27:43,100
out the package from the softlock you

00:27:39,950 --> 00:27:44,870
and push them into the meta socket or

00:27:43,100 --> 00:27:51,940
either the receive queue or the outer

00:27:44,870 --> 00:27:54,230
out of order Q so yeah any question so

00:27:51,940 --> 00:27:59,899
this design was used in order to you

00:27:54,230 --> 00:28:05,169
know to to make sure that we don't we

00:27:59,899 --> 00:28:05,169
don't change a tcp receive message and

00:28:05,230 --> 00:28:16,520
yeah it's also up basically a push up

00:28:10,010 --> 00:28:20,270
push model any question here maybe on

00:28:16,520 --> 00:28:22,460
the on the sand path we have a

00:28:20,270 --> 00:28:24,490
dissipation message function we are

00:28:22,460 --> 00:28:27,679
going to put a packet into the meta

00:28:24,490 --> 00:28:30,080
socket right cue from there we are going

00:28:27,679 --> 00:28:32,570
through the mptp scheduler we have also

00:28:30,080 --> 00:28:35,090
we have some crooks because right now

00:28:32,570 --> 00:28:37,100
there are not any you know callbacks

00:28:35,090 --> 00:28:38,559
like in the receive queue so we have

00:28:37,100 --> 00:28:40,850
inserted in some hooks into the

00:28:38,559 --> 00:28:44,450
retransmit skb and writing sweet

00:28:40,850 --> 00:28:48,279
functions and then we push those packets

00:28:44,450 --> 00:28:50,630
to the MPD CP scheduler and from there

00:28:48,279 --> 00:28:52,399
the scheduler will select the soft flow

00:28:50,630 --> 00:28:55,779
and we'll put the packet to the right Q

00:28:52,399 --> 00:28:57,530
and from there a TCP that does its job

00:28:55,779 --> 00:29:01,970
okay

00:28:57,530 --> 00:29:03,530
so we also had some issues with the DCC

00:29:01,970 --> 00:29:08,570
option this is the options because they

00:29:03,530 --> 00:29:11,030
are quite big like 20 bytes and ideally

00:29:08,570 --> 00:29:14,410
we want to save them into the control

00:29:11,030 --> 00:29:16,940
block but we didn't have space so

00:29:14,410 --> 00:29:20,680
initially we we save them into the

00:29:16,940 --> 00:29:23,300
header space fortunately we are able to

00:29:20,680 --> 00:29:26,360
compact the options because not all of

00:29:23,300 --> 00:29:28,520
them I needed to be saved in CB so right

00:29:26,360 --> 00:29:32,030
now we do not need this mechanism

00:29:28,520 --> 00:29:34,370
anymore so basically that that's that's

00:29:32,030 --> 00:29:36,290
that is how you know the initial

00:29:34,370 --> 00:29:38,840
implementation was as you can see we

00:29:36,290 --> 00:29:41,990
have quite a lot of hooks quite a lot of

00:29:38,840 --> 00:29:43,460
changes to the TCP stack and when I

00:29:41,990 --> 00:29:45,380
started looking at this a couple of

00:29:43,460 --> 00:29:47,810
years ago to see what we can do in order

00:29:45,380 --> 00:29:50,480
to know to share bit to get it easier to

00:29:47,810 --> 00:29:53,360
be upstream we looked at several

00:29:50,480 --> 00:29:55,850
approaches and one of the approaches we

00:29:53,360 --> 00:29:59,840
explore was can we do this in user space

00:29:55,850 --> 00:30:01,970
and the question i mean the the answer

00:29:59,840 --> 00:30:04,250
to that in my opinion is that we cannot

00:30:01,970 --> 00:30:05,870
really do that in users face because if

00:30:04,250 --> 00:30:07,430
you want to do it in user space you need

00:30:05,870 --> 00:30:08,930
to duplicate the existing TCP

00:30:07,430 --> 00:30:11,750
implementation I don't think that is

00:30:08,930 --> 00:30:15,050
good we could do it maybe if we could

00:30:11,750 --> 00:30:19,370
have some infrastructure a way to pass

00:30:15,050 --> 00:30:22,100
and receive special TCP options but then

00:30:19,370 --> 00:30:25,520
what do you do the handshake you also

00:30:22,100 --> 00:30:27,380
need some you know to you know to have

00:30:25,520 --> 00:30:29,360
some signaling to induce the space I

00:30:27,380 --> 00:30:32,120
think at this point I don't think it's a

00:30:29,360 --> 00:30:35,090
good idea also i think that the existing

00:30:32,120 --> 00:30:37,100
implementation it has been working for

00:30:35,090 --> 00:30:41,360
you know three four years now there are

00:30:37,100 --> 00:30:43,550
people using it and different projects

00:30:41,360 --> 00:30:45,710
there have been a lot of corner cases

00:30:43,550 --> 00:30:48,020
which have been you know investigating

00:30:45,710 --> 00:30:49,550
and fixing the current implementation so

00:30:48,020 --> 00:30:51,200
it I think it would be better just to

00:30:49,550 --> 00:30:54,590
take the existing implementation and

00:30:51,200 --> 00:30:57,650
shaping up and making it you know going

00:30:54,590 --> 00:31:00,650
it in the right direction so the second

00:30:57,650 --> 00:31:03,440
approach would be to take that and try

00:31:00,650 --> 00:31:05,450
to manage the complexity by moving the

00:31:03,440 --> 00:31:08,600
amputee to be stuffing a separate layer

00:31:05,450 --> 00:31:10,380
just like we have you know the NFS that

00:31:08,600 --> 00:31:12,450
uses TCP

00:31:10,380 --> 00:31:18,440
or the the other file system HDFS

00:31:12,450 --> 00:31:21,480
filesystem that uses TCP conceptually we

00:31:18,440 --> 00:31:24,150
MPD CP is very similar to that it should

00:31:21,480 --> 00:31:30,960
stay on a separate layer on top of the

00:31:24,150 --> 00:31:33,840
TCP stack okay so what can we do in

00:31:30,960 --> 00:31:36,180
order to have a mmv TCP layer so we need

00:31:33,840 --> 00:31:39,530
to do a couple of things one is to

00:31:36,180 --> 00:31:42,930
isolate the code at the South flow level

00:31:39,530 --> 00:31:46,530
and move it out as much as possible of

00:31:42,930 --> 00:31:49,650
the of the TCP stack and then the other

00:31:46,530 --> 00:31:54,060
one is to move to completely remove them

00:31:49,650 --> 00:31:56,580
meta socket changes in their own layer

00:31:54,060 --> 00:31:59,670
because this is this is where they

00:31:56,580 --> 00:32:01,440
belong right so we started looking at

00:31:59,670 --> 00:32:03,780
the you know what is this ambitious

00:32:01,440 --> 00:32:06,780
piece off low specific code in TCP and

00:32:03,780 --> 00:32:09,990
we identified a few most of them most of

00:32:06,780 --> 00:32:11,580
it is in the connection handshake a part

00:32:09,990 --> 00:32:13,920
that deals with the receive window and

00:32:11,580 --> 00:32:17,190
the part that deals with the send and

00:32:13,920 --> 00:32:20,250
the couple congestion control and we

00:32:17,190 --> 00:32:22,770
started looking how can we move that

00:32:20,250 --> 00:32:24,450
away so fortunately there are nice

00:32:22,770 --> 00:32:27,420
infrastructure already in place in the

00:32:24,450 --> 00:32:29,610
DCP stack like you have the connect

00:32:27,420 --> 00:32:33,480
socket operations and that was

00:32:29,610 --> 00:32:36,150
implemented in order to you know avoid

00:32:33,480 --> 00:32:38,730
doing the same thing twice or you know

00:32:36,150 --> 00:32:42,060
having ifs in the tcp code in order to

00:32:38,730 --> 00:32:45,900
treat various cases like ipv4 case or

00:32:42,060 --> 00:32:48,360
ipv6 case right so fortunately those

00:32:45,900 --> 00:32:51,030
hooks exist there and we are able to use

00:32:48,360 --> 00:32:52,470
on the on the connection side on the

00:32:51,030 --> 00:32:54,810
transmit side we are you able to use

00:32:52,470 --> 00:32:56,760
those operation and create specific

00:32:54,810 --> 00:32:59,430
operation for multi path and we move

00:32:56,760 --> 00:33:04,050
basically all this a handshake part out

00:32:59,430 --> 00:33:07,830
the TCP and it now sits in its own nice

00:33:04,050 --> 00:33:11,190
layer excuse me I guess it's left five

00:33:07,830 --> 00:33:13,830
minutes no thank you we did the same on

00:33:11,190 --> 00:33:16,650
the receive side and when you started

00:33:13,830 --> 00:33:18,930
working on this there was not I mean

00:33:16,650 --> 00:33:23,580
there there was some infrastructure that

00:33:18,930 --> 00:33:24,290
the md5 for the md5 but unfortunately it

00:33:23,580 --> 00:33:27,980
was not

00:33:24,290 --> 00:33:29,750
enough so we basically extended that it

00:33:27,980 --> 00:33:33,560
was nice because with that we will be

00:33:29,750 --> 00:33:38,690
able to also do some duplication between

00:33:33,560 --> 00:33:41,590
ipv4 and ipv6 tcp code handling and

00:33:38,690 --> 00:33:46,670
eventually we are able to also move the

00:33:41,590 --> 00:33:50,120
the resistive side handshake into its

00:33:46,670 --> 00:33:53,600
own layer for the other thing we kind of

00:33:50,120 --> 00:33:55,760
created a new socket operation structure

00:33:53,600 --> 00:33:58,370
to abstract some of the other operations

00:33:55,760 --> 00:34:01,130
I'm not sure if is this is the best idea

00:33:58,370 --> 00:34:04,010
but it at least you know you don't have

00:34:01,130 --> 00:34:06,950
to deal with lots of is if you now have

00:34:04,010 --> 00:34:11,179
operations and you initialize them for

00:34:06,950 --> 00:34:14,210
meta sockets for subfloor sockets or for

00:34:11,179 --> 00:34:17,540
regular TCP sockets where are we at

00:34:14,210 --> 00:34:21,530
right now this is a live showing the

00:34:17,540 --> 00:34:24,080
differences between 318 and participate

00:34:21,530 --> 00:34:26,780
trunk and you as you can see we still

00:34:24,080 --> 00:34:30,560
have some changes done into the

00:34:26,780 --> 00:34:33,380
disappear probably like one thousand

00:34:30,560 --> 00:34:35,570
lines of code touched but it's not as

00:34:33,380 --> 00:34:40,220
busy it used to be so I think we are

00:34:35,570 --> 00:34:41,870
slowly getting there and writing we have

00:34:40,220 --> 00:34:45,140
a working progress model where we want

00:34:41,870 --> 00:34:47,030
to basically separate the NPDP layer we

00:34:45,140 --> 00:34:50,780
are going to create a new socket for

00:34:47,030 --> 00:34:54,710
meta for the meta new protocol family

00:34:50,780 --> 00:35:00,020
for meta socket and then we are going to

00:34:54,710 --> 00:35:02,090
redesign the receive path because right

00:35:00,020 --> 00:35:04,460
now we are not going to touch at all the

00:35:02,090 --> 00:35:06,590
self loss we just let the package go to

00:35:04,460 --> 00:35:08,830
the self-love queue and then we will

00:35:06,590 --> 00:35:11,270
pull the pack itself from the South flow

00:35:08,830 --> 00:35:14,290
because we will not be able to have our

00:35:11,270 --> 00:35:18,230
own MP TCP receive national message

00:35:14,290 --> 00:35:20,150
implementation and also the same for for

00:35:18,230 --> 00:35:22,910
the same path we want to have our own

00:35:20,150 --> 00:35:28,750
implementation and then push the package

00:35:22,910 --> 00:35:31,880
to the softball level I think that's

00:35:28,750 --> 00:35:35,500
basically it if you have any questions

00:35:31,880 --> 00:35:35,500
comments on anything

00:35:48,810 --> 00:35:54,400
the very first slide you added an option

00:35:51,640 --> 00:35:59,130
to like connection I don't if you or

00:35:54,400 --> 00:36:03,070
something how how the client built is

00:35:59,130 --> 00:36:08,380
this field how we choose the identifier

00:36:03,070 --> 00:36:11,770
for the connection ah here yeah the MP

00:36:08,380 --> 00:36:14,500
capable X what is X exactly so this is

00:36:11,770 --> 00:36:17,170
used in order to negotiate a safe

00:36:14,500 --> 00:36:21,099
basically to so the client and server

00:36:17,170 --> 00:36:23,470
will negotiate a secret and that is

00:36:21,099 --> 00:36:25,510
going to be used when you join the

00:36:23,470 --> 00:36:27,700
connection so that in the server knows

00:36:25,510 --> 00:36:31,680
that this join request comes from the

00:36:27,700 --> 00:36:35,050
same client okay so that's a grip too

00:36:31,680 --> 00:36:42,670
yeah i'm yeah it's cryptographic its I

00:36:35,050 --> 00:36:44,710
think H Mac we use H Mac to do you

00:36:42,670 --> 00:36:47,260
support bi-directional connection

00:36:44,710 --> 00:36:49,030
establishment that is to say if your

00:36:47,260 --> 00:36:51,670
phone there connects through the 3g cell

00:36:49,030 --> 00:36:53,859
tower and the remote system has a

00:36:51,670 --> 00:36:55,570
secondary interface will it attempt to

00:36:53,859 --> 00:36:57,790
send us and backed over each other and

00:36:55,570 --> 00:37:00,250
not at this time so right now we only

00:36:57,790 --> 00:37:05,380
support connection from the client to

00:37:00,250 --> 00:37:07,240
the server they are basically if you

00:37:05,380 --> 00:37:09,780
have another interface of popping out

00:37:07,240 --> 00:37:12,580
with the server you will have a MP

00:37:09,780 --> 00:37:14,560
address and message sent to the client

00:37:12,580 --> 00:37:17,470
and the client will open the connection

00:37:14,560 --> 00:37:20,460
to the server I think that is desirable

00:37:17,470 --> 00:37:23,080
because if you have not and you know

00:37:20,460 --> 00:37:25,270
middleboxes it's easier to open the

00:37:23,080 --> 00:37:27,910
connection from the client side but in

00:37:25,270 --> 00:37:32,619
the future maybe we can even do that the

00:37:27,910 --> 00:37:35,859
the the standard permits that after your

00:37:32,619 --> 00:37:40,680
changes to the tcp stack if i want to

00:37:35,859 --> 00:37:43,750
disable MP tcp option administrative lay

00:37:40,680 --> 00:37:45,760
would you allow socket creation one step

00:37:43,750 --> 00:37:48,400
are there still two sockets meta socket

00:37:45,760 --> 00:37:52,180
and the master socket if you disable it

00:37:48,400 --> 00:37:55,660
now you'll only have one poison you love

00:37:52,180 --> 00:37:56,860
it yes and there is already this we have

00:37:55,660 --> 00:37:59,570
a sis

00:37:56,860 --> 00:38:03,200
CFS entry which allows you to control

00:37:59,570 --> 00:38:06,740
that people want to continue asking

00:38:03,200 --> 00:38:11,350
questions is okay but its food probably

00:38:06,740 --> 00:38:14,710
of an hour long and you can talk to

00:38:11,350 --> 00:38:14,710
afterwards the door

00:38:23,390 --> 00:38:29,390
right now it is transparent so the the

00:38:27,330 --> 00:38:33,030
application doesn't need to change

00:38:29,390 --> 00:38:35,070
however we are we are thinking of moving

00:38:33,030 --> 00:38:38,130
to the direction where the you know you

00:38:35,070 --> 00:38:42,510
need to open up a specific if you want

00:38:38,130 --> 00:38:46,860
an MP TCP socket you would need to you

00:38:42,510 --> 00:38:48,240
know use a special socket Cisco that is

00:38:46,860 --> 00:38:52,800
because it will we think it will

00:38:48,240 --> 00:38:55,320
significantly reduce the UM it will

00:38:52,800 --> 00:38:57,240
significantly reduce the intrusiveness

00:38:55,320 --> 00:38:59,940
of the implementation to the tcp stack

00:38:57,240 --> 00:39:03,600
now with that being said we we can

00:38:59,940 --> 00:39:05,880
actually we follow that and we can still

00:39:03,600 --> 00:39:09,540
make it transparent by redirecting the

00:39:05,880 --> 00:39:11,520
socket call the inet layer you know if

00:39:09,540 --> 00:39:15,420
you have some special Sisyphus setting

00:39:11,520 --> 00:39:19,400
will redirect all the TCP socket calls

00:39:15,420 --> 00:39:19,400
to be actually MP TCP socket calls

00:39:32,250 --> 00:39:42,190
I still wanted to ask about the master

00:39:39,010 --> 00:39:45,220
socket and d-sub flow so the master

00:39:42,190 --> 00:39:47,740
sodium re master socket is eventually

00:39:45,220 --> 00:39:49,720
the one that falls back to normal TCP if

00:39:47,740 --> 00:39:56,500
there's a problem for example in some

00:39:49,720 --> 00:40:00,369
milk box or and that master socket would

00:39:56,500 --> 00:40:05,830
basically based on your path properties

00:40:00,369 --> 00:40:09,640
change during runtime or is that fixed

00:40:05,830 --> 00:40:13,119
or no yeah the master circuit is the

00:40:09,640 --> 00:40:15,369
first socket that is created I mean when

00:40:13,119 --> 00:40:17,560
with the first circuit that is created

00:40:15,369 --> 00:40:21,869
as a clone after the meta circuit when

00:40:17,560 --> 00:40:24,700
we received an MP capable thing option

00:40:21,869 --> 00:40:26,920
so it doesn't change I mean you cannot

00:40:24,700 --> 00:40:48,850
select other sockets to be the master

00:40:26,920 --> 00:40:51,790
socket oh ok ok Christoph you do you

00:40:48,850 --> 00:40:55,720
want to take that I think it's very

00:40:51,790 --> 00:41:15,970
similar today I'm a question can you

00:40:55,720 --> 00:41:18,220
please repeat your question yeah so if

00:41:15,970 --> 00:41:20,680
you have kind of an any cast address to

00:41:18,220 --> 00:41:23,170
to the content provider and this once

00:41:20,680 --> 00:41:27,430
it's in different places depending on

00:41:23,170 --> 00:41:29,619
the ISP it's not sure whether for

00:41:27,430 --> 00:41:31,840
example for I don't know in Akamai use

00:41:29,619 --> 00:41:34,450
case you would want to have NP TCP

00:41:31,840 --> 00:41:36,880
because while you might get over sub

00:41:34,450 --> 00:41:40,270
optimal path definitely there might be

00:41:36,880 --> 00:41:45,630
benefits and disadvantages of using MP

00:41:40,270 --> 00:41:45,630
TCP in a content provider use case

00:41:56,910 --> 00:42:04,390
yeah police using Siri empty CP and

00:42:01,770 --> 00:42:07,060
there are many other users of empties be

00:42:04,390 --> 00:42:11,350
also there are many startups who are

00:42:07,060 --> 00:42:13,810
using it basically to in rural areas

00:42:11,350 --> 00:42:16,960
where for example the dsl connection is

00:42:13,810 --> 00:42:18,100
very crappy then they have dsl or to dsl

00:42:16,960 --> 00:42:20,710
connections they are bonding their

00:42:18,100 --> 00:42:22,180
interfaces and terminating their tcp

00:42:20,710 --> 00:42:24,850
connections somewhere in the cloud and

00:42:22,180 --> 00:42:30,370
that way they have a better better user

00:42:24,850 --> 00:42:31,990
experience so I think there are now two

00:42:30,370 --> 00:42:52,000
startups who have been created just

00:42:31,990 --> 00:42:53,380
around mb tcp yeah so yeah if thank you

00:42:52,000 --> 00:42:56,590
very much for attending a presentation

00:42:53,380 --> 00:42:59,710
I'll be here and if you have questions

00:42:56,590 --> 00:43:03,570
comments suggestions please contact me

00:42:59,710 --> 00:43:03,570

YouTube URL: https://www.youtube.com/watch?v=wftz2cU5SZs


