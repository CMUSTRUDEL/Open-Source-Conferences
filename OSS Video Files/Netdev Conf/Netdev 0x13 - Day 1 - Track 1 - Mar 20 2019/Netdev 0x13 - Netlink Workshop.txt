Title: Netdev 0x13 - Netlink Workshop
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 1 - Track 1 - Mar 20 2019
Description: 
	Netlink is a fundamental kernel/user messaging interface which has evolved over the years.
At Netdev 0x13, David Ahern and Roopa Prabhu co-chaired the Netlink Workshop.

Among topics of discussion:
- status of changes over the last few years
- kernel side filtering
  + classical, socket cbpf, ebpf extensions
- reducing notifications
- strict get requests
- Growth of attributes and impacts to stack memory use
- Lessons learnt and ideas to use the learnings
- Performance improvements
- Networking APIs that need to be converted to netlink(ethtool etc)

More info:
https://netdevconf.org/0x13/session.html?workshop-netlink
Captions: 
	00:00:00,000 --> 00:00:07,040
hello everyone my name is Rupa and this

00:00:03,210 --> 00:00:10,260
is the first netlink workshop at net dev

00:00:07,040 --> 00:00:12,690
chaired by David Ahern and me David is

00:00:10,260 --> 00:00:13,139
on the panel there and we have others as

00:00:12,690 --> 00:00:19,080
well

00:00:13,139 --> 00:00:21,210
johannes who was invited there he is an

00:00:19,080 --> 00:00:22,830
honourable guest and he's been

00:00:21,210 --> 00:00:25,170
contributing a lot to metal Inc recently

00:00:22,830 --> 00:00:28,769
as well and we have other speakers let's

00:00:25,170 --> 00:00:30,750
go over the agenda so introduction I

00:00:28,769 --> 00:00:33,600
will ramble along for a few minutes

00:00:30,750 --> 00:00:34,760
giving a brief high-level overview on

00:00:33,600 --> 00:00:37,920
netlink

00:00:34,760 --> 00:00:41,879
David Evans will cover net link updates

00:00:37,920 --> 00:00:43,800
and then we have a long lunch break we

00:00:41,879 --> 00:00:47,030
will come back and David Ahern will

00:00:43,800 --> 00:00:49,680
resume talking about net link filtering

00:00:47,030 --> 00:00:52,289
net link filtering is basically like

00:00:49,680 --> 00:00:54,600
just the previous workshop there was a

00:00:52,289 --> 00:00:59,160
lot of TCP filtering so TCP info

00:00:54,600 --> 00:01:01,579
filtering the same thing and so many and

00:00:59,160 --> 00:01:04,580
jamol will talk about use cases

00:01:01,579 --> 00:01:06,600
deployment Mettling challenges and

00:01:04,580 --> 00:01:11,340
basically scale challenges with

00:01:06,600 --> 00:01:15,080
filtering and we have a section on new

00:01:11,340 --> 00:01:19,770
netlink ApS that are growing each day

00:01:15,080 --> 00:01:20,310
cheeri will talk about dev link and each

00:01:19,770 --> 00:01:25,340
tool

00:01:20,310 --> 00:01:25,340
Michael will talk about each tool ok

00:01:36,060 --> 00:01:40,200
waiting for my slides to appear

00:01:40,490 --> 00:01:43,060
yes

00:01:44,930 --> 00:01:49,330
oh they asked Excel files what to switch

00:01:48,350 --> 00:01:52,930
out fires

00:01:49,330 --> 00:01:56,290
yeah he's switching he has all the fuss

00:01:52,930 --> 00:01:56,290
it's all there

00:01:56,910 --> 00:02:04,900
okay sorry of all the people I think and

00:02:02,020 --> 00:02:06,280
the least awake today just slept for two

00:02:04,900 --> 00:02:10,930
hours so you can ask all the questions

00:02:06,280 --> 00:02:11,950
to the panel there so yeah so I'll very

00:02:10,930 --> 00:02:16,030
high level overview

00:02:11,950 --> 00:02:18,460
I'm keeping it light I don't know

00:02:16,030 --> 00:02:20,500
I'm fascinated by the cat art in Prague

00:02:18,460 --> 00:02:26,410
so if anybody has any info on them

00:02:20,500 --> 00:02:27,310
please unicast me or talk to me brief

00:02:26,410 --> 00:02:29,320
intro to netlink

00:02:27,310 --> 00:02:31,750
well read the man page there is a link

00:02:29,320 --> 00:02:33,100
to the man page net link as you know is

00:02:31,750 --> 00:02:35,620
used to transfer information between

00:02:33,100 --> 00:02:38,320
kernel and user space and that link is

00:02:35,620 --> 00:02:40,959
also used as an IPC between user space

00:02:38,320 --> 00:02:44,200
processes but this workshop is only

00:02:40,959 --> 00:02:46,480
about kernel and net link sorry kernel

00:02:44,200 --> 00:02:49,420
and user space so net link has a

00:02:46,480 --> 00:02:51,550
standard socket interface as shown there

00:02:49,420 --> 00:02:53,800
socket family actually selects the

00:02:51,550 --> 00:02:56,940
kernel module or net link group to

00:02:53,800 --> 00:02:59,470
communicate with and there is a list of

00:02:56,940 --> 00:03:03,760
socket families or net link families in

00:02:59,470 --> 00:03:05,950
the man page let's this I'll highlight

00:03:03,760 --> 00:03:07,840
or talk about two major Mettling

00:03:05,950 --> 00:03:11,230
families let link route and Mettling

00:03:07,840 --> 00:03:13,450
generic a few thoughts as along I was

00:03:11,230 --> 00:03:15,010
trying to scan through all the

00:03:13,450 --> 00:03:17,920
implementations or all the subsystems

00:03:15,010 --> 00:03:20,680
that uses each one of them net link

00:03:17,920 --> 00:03:23,230
route is nothing but RT net link

00:03:20,680 --> 00:03:26,170
subsystem dictates the message type and

00:03:23,230 --> 00:03:29,170
handlers allows the user to register

00:03:26,170 --> 00:03:33,190
only a certain fixed message types get

00:03:29,170 --> 00:03:36,760
set new view is nothing but create and

00:03:33,190 --> 00:03:38,860
delete and each message type can have a

00:03:36,760 --> 00:03:41,410
do it and a dump at handler

00:03:38,860 --> 00:03:44,110
so that's constraint RT net link defines

00:03:41,410 --> 00:03:48,220
this meta link generic on the other hand

00:03:44,110 --> 00:03:50,890
gives a lot of freedom to subsystem API

00:03:48,220 --> 00:03:55,650
developers to declare any type of

00:03:50,890 --> 00:03:55,650
message and handlers so

00:04:00,730 --> 00:04:03,810
no sorry

00:04:06,610 --> 00:04:12,770
so subsystems just a survey on

00:04:10,460 --> 00:04:18,430
subsystems using RT netlink route today

00:04:12,770 --> 00:04:25,190
is routing addresses links stats

00:04:18,430 --> 00:04:29,000
neighbor subsystem namespaces TC and su

00:04:25,190 --> 00:04:31,460
sitio SRTM net conf so and each of these

00:04:29,000 --> 00:04:34,340
are in some cases they're overloaded by

00:04:31,460 --> 00:04:39,320
family types so for example neighbors RT

00:04:34,340 --> 00:04:40,970
datalink API is used by in with EF

00:04:39,320 --> 00:04:45,050
inspect family by the neighbors of

00:04:40,970 --> 00:04:50,690
system and with AF bridge family for the

00:04:45,050 --> 00:04:52,820
bridge f DB and VX LAN FTB's this is

00:04:50,690 --> 00:04:54,980
some art this is what you do on the

00:04:52,820 --> 00:04:56,860
flight when you have no good movies

00:04:54,980 --> 00:04:59,330
I was just scanning through all the

00:04:56,860 --> 00:05:03,940
sorry I need to go back to the previous

00:04:59,330 --> 00:05:07,430
slide so the link link RT netlink api

00:05:03,940 --> 00:05:10,310
extends itself to provide support for

00:05:07,430 --> 00:05:13,550
many types of links and that why are the

00:05:10,310 --> 00:05:15,229
IFLA link info so this is good to know

00:05:13,550 --> 00:05:17,870
because sometimes when you're adding a

00:05:15,229 --> 00:05:20,810
new link it's usually this is the place

00:05:17,870 --> 00:05:23,360
where you check to see if this can be

00:05:20,810 --> 00:05:29,960
extended because you can leverage a lot

00:05:23,360 --> 00:05:30,740
of code existing code and here the types

00:05:29,960 --> 00:05:33,260
of links

00:05:30,740 --> 00:05:39,070
that's art annette link ops supports are

00:05:33,260 --> 00:05:44,050
these and yeah basically a lot of them

00:05:39,070 --> 00:05:46,730
bonds and bridges we eats and so on

00:05:44,050 --> 00:05:49,670
subsystems using net link generic again

00:05:46,730 --> 00:05:54,830
there are many I did some quick stats

00:05:49,670 --> 00:05:59,150
around 33 and the thing is I think I've

00:05:54,830 --> 00:06:02,090
seen a overlap between Artie net link

00:05:59,150 --> 00:06:05,450
ops and generic I don't want to point

00:06:02,090 --> 00:06:07,850
them here but in general I think if your

00:06:05,450 --> 00:06:10,070
generic dead link op is supporting the

00:06:07,850 --> 00:06:11,990
same exact messages and same exact

00:06:10,070 --> 00:06:14,360
handlers like do it and dump it it's

00:06:11,990 --> 00:06:18,320
better and if it's a link type it's

00:06:14,360 --> 00:06:24,230
better to have it in a defined as RT and

00:06:18,320 --> 00:06:24,920
Al ops so adding a new API where would

00:06:24,230 --> 00:06:27,530
you do it

00:06:24,920 --> 00:06:29,320
Artie net link route or sorry Len link

00:06:27,530 --> 00:06:33,650
route or net link generic which families

00:06:29,320 --> 00:06:35,420
so the general philosophy here is if it

00:06:33,650 --> 00:06:38,240
fits into existing net link route you

00:06:35,420 --> 00:06:40,280
can benefit from a lot of the api's and

00:06:38,240 --> 00:06:43,040
handlers already existing and links

00:06:40,280 --> 00:06:46,100
especially fall right into this whether

00:06:43,040 --> 00:06:49,970
it's a tunnel link or VLAN bridges and

00:06:46,100 --> 00:06:52,190
so on so this can also be true for other

00:06:49,970 --> 00:06:55,010
subsystems for example like the bridge

00:06:52,190 --> 00:06:59,690
FDB uses the neighbor subsystem with the

00:06:55,010 --> 00:07:02,480
AF bridge flag so you essentially use

00:06:59,690 --> 00:07:05,750
the same attributes from user space you

00:07:02,480 --> 00:07:07,610
just key of the cue of the family and

00:07:05,750 --> 00:07:10,130
look for extra attributes if your and

00:07:07,610 --> 00:07:11,750
their neighbors subsystem you're looking

00:07:10,130 --> 00:07:16,040
at a neighbor entry or a bridge f DB

00:07:11,750 --> 00:07:18,740
entry or a VX LAN entry so a little bit

00:07:16,040 --> 00:07:22,730
on user space and net link we all know

00:07:18,740 --> 00:07:25,610
user space can use one of these families

00:07:22,730 --> 00:07:28,970
and send a message to Colonel to create

00:07:25,610 --> 00:07:33,530
delete update and object one object or

00:07:28,970 --> 00:07:35,060
get all objects and there is also

00:07:33,530 --> 00:07:36,080
another channel which is for

00:07:35,060 --> 00:07:38,210
asynchronous

00:07:36,080 --> 00:07:40,850
Mettling notifications from the kernel

00:07:38,210 --> 00:07:42,260
and this is usually a shared bus the

00:07:40,850 --> 00:07:46,660
kernel rights to all the listeners

00:07:42,260 --> 00:07:50,000
sockets and each net link family and

00:07:46,660 --> 00:07:51,660
message type provides you with groups

00:07:50,000 --> 00:07:54,680
that you can listen on

00:07:51,660 --> 00:07:57,180
and these groups dictate what kind of

00:07:54,680 --> 00:07:59,100
notifications you get for example link

00:07:57,180 --> 00:08:00,900
notification there is a multicast group

00:07:59,100 --> 00:08:04,680
where you can your application can

00:08:00,900 --> 00:08:08,370
register too and you'll get linked a

00:08:04,680 --> 00:08:11,190
synchronous link notifications and the

00:08:08,370 --> 00:08:13,140
examples of user space applications

00:08:11,190 --> 00:08:16,350
using letting today all of them

00:08:13,140 --> 00:08:18,930
I work for an network operating system

00:08:16,350 --> 00:08:22,290
distribution company and we have all

00:08:18,930 --> 00:08:25,080
demons listening to net link and we know

00:08:22,290 --> 00:08:27,360
the pain when it scales you get so many

00:08:25,080 --> 00:08:31,250
notification and all in all the

00:08:27,360 --> 00:08:34,650
processes whether it's DHCP D or NTP or

00:08:31,250 --> 00:08:36,479
your telemetry applications and routing

00:08:34,650 --> 00:08:38,700
demons they're all listening and

00:08:36,479 --> 00:08:42,770
processing notifications especially on

00:08:38,700 --> 00:08:42,770
link events at a large scale

00:08:45,650 --> 00:08:51,529
need for netlink libraries I think I

00:08:49,160 --> 00:08:53,450
have spent a lot of time on net link and

00:08:51,529 --> 00:08:57,200
user space especially and the useful

00:08:53,450 --> 00:08:59,450
driver side and some of the networking

00:08:57,200 --> 00:09:01,160
protocol implementations which listen to

00:08:59,450 --> 00:09:05,870
net link and process link events and so

00:09:01,160 --> 00:09:07,430
on and I think we all know there are

00:09:05,870 --> 00:09:09,440
many library implementations out there

00:09:07,430 --> 00:09:13,850
if you're looking for it especially if

00:09:09,440 --> 00:09:18,320
you're writing in Python or go they are

00:09:13,850 --> 00:09:22,100
but none of them is complete at the end

00:09:18,320 --> 00:09:26,390
I have a link to Lib NL and Lib ml which

00:09:22,100 --> 00:09:29,420
are almost complete well Lebanon is the

00:09:26,390 --> 00:09:32,180
farthest I think in terms of supporting

00:09:29,420 --> 00:09:36,080
all the net link API attributes and so

00:09:32,180 --> 00:09:37,910
on so in most cases performed for

00:09:36,080 --> 00:09:39,500
performance reasons all applications

00:09:37,910 --> 00:09:41,660
they do end up building their own

00:09:39,500 --> 00:09:43,580
libraries for example free range routing

00:09:41,660 --> 00:09:47,690
suite if you know there is the zebra

00:09:43,580 --> 00:09:49,790
process which builds its routing cache

00:09:47,690 --> 00:09:52,580
and processes that link and so on for

00:09:49,790 --> 00:09:55,900
all attributes that it wants so we have

00:09:52,580 --> 00:09:58,490
seen this over and over again that every

00:09:55,900 --> 00:10:00,160
like I said in on a network operating

00:09:58,490 --> 00:10:03,350
system you have multiple demons all

00:10:00,160 --> 00:10:09,050
building their own net link parses and

00:10:03,350 --> 00:10:10,910
that link caching functions so and many

00:10:09,050 --> 00:10:12,860
of the net link performance problems are

00:10:10,910 --> 00:10:15,470
because of bugs and these bugs are trust

00:10:12,860 --> 00:10:17,240
me they're replicated all over socket

00:10:15,470 --> 00:10:19,000
buffers small socket buffers you go and

00:10:17,240 --> 00:10:21,260
scan all the demons that are listening

00:10:19,000 --> 00:10:22,790
protocol implementations especially they

00:10:21,260 --> 00:10:24,800
are all either low socket buffers

00:10:22,790 --> 00:10:28,070
they're running out of socket buffer

00:10:24,800 --> 00:10:30,140
space where unlink events especially and

00:10:28,070 --> 00:10:32,990
there's a churn in the network everybody

00:10:30,140 --> 00:10:37,070
is processing net link events so I think

00:10:32,990 --> 00:10:39,110
a lack of documentation is one thing for

00:10:37,070 --> 00:10:42,170
net leg that we keep discussing on and

00:10:39,110 --> 00:10:44,480
off so many many a times it's due to

00:10:42,170 --> 00:10:46,130
applications not knowing what they

00:10:44,480 --> 00:10:48,140
should be listening to and they are

00:10:46,130 --> 00:10:49,880
listening to all events unnecessarily I

00:10:48,140 --> 00:10:51,980
think David is going to touch upon this

00:10:49,880 --> 00:10:55,829
more

00:10:51,980 --> 00:10:58,050
and some more thoughts here well it's a

00:10:55,829 --> 00:11:00,449
long shot I'm just gonna try I can i

00:10:58,050 --> 00:11:03,709
peer out to support a or the colonel to

00:11:00,449 --> 00:11:06,600
provide some kind of a net link library

00:11:03,709 --> 00:11:08,699
it has to be a library that a kernel

00:11:06,600 --> 00:11:11,449
developer can submit a patch to to

00:11:08,699 --> 00:11:15,449
complete the api which would be easier I

00:11:11,449 --> 00:11:19,920
have seen especially people new to Linux

00:11:15,449 --> 00:11:22,319
networking struggling with yeah building

00:11:19,920 --> 00:11:23,999
Mettling libraries and parsing and they

00:11:22,319 --> 00:11:29,790
end up copying code from everywhere and

00:11:23,999 --> 00:11:32,970
copying bugs as well so and yes people

00:11:29,790 --> 00:11:36,420
used to use Lipsy networking api's

00:11:32,970 --> 00:11:39,089
before and it was all standard now with

00:11:36,420 --> 00:11:50,160
Mettling they have to regenerate this

00:11:39,089 --> 00:11:53,999
boilerplate code and yeah just mean that

00:11:50,160 --> 00:11:55,980
link can be hard to people have to read

00:11:53,999 --> 00:11:59,970
kernel code to figure out where your

00:11:55,980 --> 00:12:01,619
attribute is I mean what's the type of

00:11:59,970 --> 00:12:04,379
your attribute and so on so little in

00:12:01,619 --> 00:12:06,449
documentation is key I know we have

00:12:04,379 --> 00:12:08,610
talked about TCP info documentation and

00:12:06,449 --> 00:12:10,369
the EBP of documentation and so on so I

00:12:08,610 --> 00:12:14,100
think that link also needs some

00:12:10,369 --> 00:12:16,079
documentation and yes metalic is in Yui

00:12:14,100 --> 00:12:19,040
BPF this is the first netlink workshop

00:12:16,079 --> 00:12:19,040
so open

00:12:23,600 --> 00:12:27,740
any questions so far

00:12:34,830 --> 00:12:39,160
so just one comment I looked at that

00:12:37,180 --> 00:12:46,050
link and I look at a BBF with the newest

00:12:39,160 --> 00:12:58,060
trace that link is easier okay

00:12:46,050 --> 00:13:01,510
comment you oh you don't have the mic

00:12:58,060 --> 00:13:03,540
okay yeah so you you have a question -

00:13:01,510 --> 00:13:07,230
right okay go ahead

00:13:03,540 --> 00:13:11,290
can you hear me the net link of generic

00:13:07,230 --> 00:13:11,650
how easy it is to support something in a

00:13:11,290 --> 00:13:15,730
driver

00:13:11,650 --> 00:13:18,490
is it Hardware offload friendly it is

00:13:15,730 --> 00:13:21,760
like any other API so dev link uses

00:13:18,490 --> 00:13:24,180
general by the way and and as you know

00:13:21,760 --> 00:13:26,890
dev link was written for hardware

00:13:24,180 --> 00:13:28,390
drivers obviously I'm not sure why

00:13:26,890 --> 00:13:32,080
anyone would ever use anything other

00:13:28,390 --> 00:13:35,320
than general or run in a crowd right

00:13:32,080 --> 00:13:37,510
yeah at this point yeah because general

00:13:35,320 --> 00:13:39,100
just has the other dynamic lookup if the

00:13:37,510 --> 00:13:41,860
families you don't have to worry about

00:13:39,100 --> 00:13:43,270
hard coding and all the things so so

00:13:41,860 --> 00:13:45,400
when you need something completely

00:13:43,270 --> 00:13:47,680
separate like Wi-Fi completely separate

00:13:45,400 --> 00:13:49,120
from like all your methods operations

00:13:47,680 --> 00:13:51,460
are completely separate from that any

00:13:49,120 --> 00:13:54,280
crowd then you probably want to use net

00:13:51,460 --> 00:13:56,260
link generic right because it gives the

00:13:54,280 --> 00:13:58,180
freedom to the developer something which

00:13:56,260 --> 00:14:01,630
doesn't fit into the existing one yeah

00:13:58,180 --> 00:14:05,800
one can define new message yes and it

00:14:01,630 --> 00:14:07,510
can be interpreted yeah and there's the

00:14:05,800 --> 00:14:11,500
application tool chain also supports

00:14:07,510 --> 00:14:13,750
this yeah example like a TC TC flower

00:14:11,500 --> 00:14:17,440
today it does a net link event right yes

00:14:13,750 --> 00:14:21,550
yeah TC uses artena

00:14:17,440 --> 00:14:23,980
but there are many many tools in IP

00:14:21,550 --> 00:14:26,709
route to that use channel okay so there

00:14:23,980 --> 00:14:28,959
are many examples so general came in

00:14:26,709 --> 00:14:30,910
because we were running out of net link

00:14:28,959 --> 00:14:34,540
numbers so said okay let's have

00:14:30,910 --> 00:14:38,079
something that so with no need to take a

00:14:34,540 --> 00:14:40,889
new number right for for your next

00:14:38,079 --> 00:14:44,740
everybody inventing their own net linker

00:14:40,889 --> 00:14:48,399
thank you so yeah my comment is with the

00:14:44,740 --> 00:14:51,040
libraries I think the problem is well I

00:14:48,399 --> 00:14:53,829
guess do we need a new library it's like

00:14:51,040 --> 00:15:08,860
asking do we need a new laughs song

00:14:53,829 --> 00:15:12,459
right the problem is everybody thinks so

00:15:08,860 --> 00:15:14,439
the problem is everybody has their own

00:15:12,459 --> 00:15:15,879
knobs they they think are important so

00:15:14,439 --> 00:15:19,269
one of my problems will live in hell for

00:15:15,879 --> 00:15:21,819
example it has like 15,000 hooks yeah it

00:15:19,269 --> 00:15:25,089
tries to cash doesn't do it very well

00:15:21,819 --> 00:15:26,470
it is my ears though I think it may have

00:15:25,089 --> 00:15:29,589
improved I stopped looking at it at some

00:15:26,470 --> 00:15:32,709
point but I like lieberman l better but

00:15:29,589 --> 00:15:34,839
it doesn't have parsing for you to do my

00:15:32,709 --> 00:15:38,709
parsing for me okay see see this is the

00:15:34,839 --> 00:15:41,290
problem it's a love song which which one

00:15:38,709 --> 00:15:44,110
do you like most right so i let's lose

00:15:41,290 --> 00:15:45,819
the challenge we have to minimalist and

00:15:44,110 --> 00:15:48,310
if someone can build up on top

00:15:45,819 --> 00:15:50,350
that's okay i think we could put you in

00:15:48,310 --> 00:15:53,889
the advanced category yeah so the

00:15:50,350 --> 00:15:56,079
libraries are really for someone who has

00:15:53,889 --> 00:15:58,149
is it used to being an Ellen gap yeah

00:15:56,079 --> 00:16:00,920
it's about the richness I mean do I want

00:15:58,149 --> 00:16:03,890
all that richness

00:16:00,920 --> 00:16:07,049
others do some do okay

00:16:03,890 --> 00:16:07,049
[Music]

00:16:13,180 --> 00:16:20,260
all right hello everyone I'm David Ahern

00:16:16,210 --> 00:16:23,910
I work with Rupa at cumulus hmm and how

00:16:20,260 --> 00:16:23,910
do we get to the next slide

00:16:31,019 --> 00:16:38,499
all right so I have a couple of topics I

00:16:35,230 --> 00:16:40,569
want to get into one of those is past

00:16:38,499 --> 00:16:43,299
mistakes and how that's hurting us and

00:16:40,569 --> 00:16:45,160
then the next topic is scale but before

00:16:43,299 --> 00:16:48,309
I do that I don't want to start off with

00:16:45,160 --> 00:16:50,910
some background do I need to aim this at

00:16:48,309 --> 00:16:54,210
any particular spot

00:16:50,910 --> 00:16:54,210
at the wall

00:16:59,730 --> 00:17:08,370
huh

00:17:02,220 --> 00:17:11,370
the user mistake

00:17:08,370 --> 00:17:11,370
No

00:17:14,480 --> 00:17:20,449
No there we go all right

00:17:32,130 --> 00:17:36,679
any particular wall all right

00:17:50,900 --> 00:17:55,430
okay so let's start with some background

00:17:52,700 --> 00:17:57,080
on what now link is so it's a generic

00:17:55,430 --> 00:17:59,059
messaging infrastructure between the

00:17:57,080 --> 00:18:00,950
kernel and user space there's an RFC

00:17:59,059 --> 00:18:03,620
that documents this from way back when

00:18:00,950 --> 00:18:05,510
it was first thought of as Rupert

00:18:03,620 --> 00:18:09,290
pointed out there it's a socket based

00:18:05,510 --> 00:18:11,330
API so you open up the socket with a F

00:18:09,290 --> 00:18:14,090
net link and whatever protocol is of

00:18:11,330 --> 00:18:16,370
interest specifically we're focused on

00:18:14,090 --> 00:18:18,050
that link route the net link generic I'm

00:18:16,370 --> 00:18:19,760
focused on that link route everything

00:18:18,050 --> 00:18:23,510
I've done is within our t-nut link

00:18:19,760 --> 00:18:26,120
category in terms of the structure of

00:18:23,510 --> 00:18:28,940
the messages you've got a message header

00:18:26,120 --> 00:18:31,850
which contains the length the type of

00:18:28,940 --> 00:18:34,760
message sequence number process ID or

00:18:31,850 --> 00:18:36,559
port ID as it was changed to and then

00:18:34,760 --> 00:18:39,530
any flags associated with that message

00:18:36,559 --> 00:18:42,070
and so this gets important into some of

00:18:39,530 --> 00:18:44,990
the complaints I have you know coming up

00:18:42,070 --> 00:18:47,570
so generically speaking header payload

00:18:44,990 --> 00:18:49,970
that payload is then interpreted as a

00:18:47,570 --> 00:18:52,280
header based on the message type and

00:18:49,970 --> 00:18:55,010
then a series of attributes and those

00:18:52,280 --> 00:18:56,150
attributes are TLV based so what's the

00:18:55,010 --> 00:18:58,580
type what's the link

00:18:56,150 --> 00:19:00,650
here's the value they have to be for

00:18:58,580 --> 00:19:02,450
byte aligned so if it's not for byte

00:19:00,650 --> 00:19:04,460
aligned you need to add some pad so for

00:19:02,450 --> 00:19:05,960
example if you're sending a u8 you got

00:19:04,460 --> 00:19:08,770
to add three bytes of pad to make that

00:19:05,960 --> 00:19:08,770
four total

00:19:09,660 --> 00:19:14,850
so RT netlink uses a scheme where

00:19:12,420 --> 00:19:18,690
there's like four actions on objects a

00:19:14,850 --> 00:19:20,820
new delete I get a set those basic

00:19:18,690 --> 00:19:23,580
operations are repeated for each one of

00:19:20,820 --> 00:19:28,650
the objects and the objects are links

00:19:23,580 --> 00:19:30,080
addresses routes neighbors rules etc so

00:19:28,650 --> 00:19:33,510
when you combine those two together

00:19:30,080 --> 00:19:36,960
example message types are RTM new link

00:19:33,510 --> 00:19:39,150
are TM del link are TM new routes are TM

00:19:36,960 --> 00:19:41,730
get route okay so that's kind of the

00:19:39,150 --> 00:19:43,980
generic pattern and then those four go

00:19:41,730 --> 00:19:46,290
together for that object but you don't

00:19:43,980 --> 00:19:48,150
have to implement an action for an

00:19:46,290 --> 00:19:52,430
object type so there's several messages

00:19:48,150 --> 00:19:52,430
where there's only a get for example

00:19:53,460 --> 00:19:58,470
so each object as I showed earlier in

00:19:55,980 --> 00:20:01,350
that side of the message format each

00:19:58,470 --> 00:20:03,960
object has its own header struct so for

00:20:01,350 --> 00:20:06,000
example if I'm doing a link it's an if'

00:20:03,960 --> 00:20:08,220
info message and I have the struck there

00:20:06,000 --> 00:20:11,040
as an example if I'm doing neighbors

00:20:08,220 --> 00:20:12,510
it's an indie message struck that is the

00:20:11,040 --> 00:20:13,800
theory that's what's supposed to be

00:20:12,510 --> 00:20:16,140
happening for all these different

00:20:13,800 --> 00:20:18,660
message types so if I'm sending a new

00:20:16,140 --> 00:20:23,430
link or a get link or delete link I have

00:20:18,660 --> 00:20:25,440
an if' info message in front and then

00:20:23,430 --> 00:20:27,000
lastly for some background you know a

00:20:25,440 --> 00:20:28,340
true pin mentioned also that you know

00:20:27,000 --> 00:20:31,200
the kernel will generate notifications

00:20:28,340 --> 00:20:33,090
so let's say process a inserts a new

00:20:31,200 --> 00:20:34,800
route into the kernel the kernel

00:20:33,090 --> 00:20:36,660
generates a notification that goes up to

00:20:34,800 --> 00:20:38,730
user space for any other processes that

00:20:36,660 --> 00:20:41,040
are interested they can also learn of

00:20:38,730 --> 00:20:44,330
that route that got added or deleted or

00:20:41,040 --> 00:20:46,830
if a link goes up or down same thing a

00:20:44,330 --> 00:20:48,270
notification is generated user space

00:20:46,830 --> 00:20:53,160
gets to kind of follow along about

00:20:48,270 --> 00:20:55,200
what's what's happening because it's a

00:20:53,160 --> 00:20:58,080
32 bit mass for the groups remember if

00:20:55,200 --> 00:21:00,540
you're using any groups over bit 31 you

00:20:58,080 --> 00:21:02,400
have to use a set sock opt to join the

00:21:00,540 --> 00:21:03,720
membership of that group and that

00:21:02,400 --> 00:21:06,360
actually comes up with the next hop

00:21:03,720 --> 00:21:08,760
stuff that I've done I'm over 31 so my

00:21:06,360 --> 00:21:12,870
32 so I have to start using the set sock

00:21:08,760 --> 00:21:15,630
hop to join the group ok with that

00:21:12,870 --> 00:21:17,190
background on the theory of net link in

00:21:15,630 --> 00:21:19,290
the message types and the parsing and

00:21:17,190 --> 00:21:22,539
such let's get into some past mistakes

00:21:19,290 --> 00:21:26,509
and how that's hurting us going forward

00:21:22,539 --> 00:21:30,970
so way back in the beginning IP route 2

00:21:26,509 --> 00:21:33,799
had this generic dump filter or dump

00:21:30,970 --> 00:21:35,240
function that it was using to send down

00:21:33,799 --> 00:21:36,679
to the kernel you know to drink the

00:21:35,240 --> 00:21:39,139
message to send to the kernel that says

00:21:36,679 --> 00:21:40,610
give me all the links that are that you

00:21:39,139 --> 00:21:43,429
know about or give me all the routes

00:21:40,610 --> 00:21:45,080
that you know about and that header that

00:21:43,429 --> 00:21:47,899
it put on the front of the message was

00:21:45,080 --> 00:21:50,029
just an RT gen message our T Gen message

00:21:47,899 --> 00:21:52,129
is just a family okay

00:21:50,029 --> 00:21:54,499
had no other information well that was

00:21:52,129 --> 00:21:56,480
really illegal for everything except

00:21:54,499 --> 00:21:59,090
namespaces which didn't exist back when

00:21:56,480 --> 00:22:00,769
that originally was there so really when

00:21:59,090 --> 00:22:02,360
you're doing a link word a link dump it

00:22:00,769 --> 00:22:04,129
should have been an if' info message

00:22:02,360 --> 00:22:05,840
when you're doing a neighbor dump it

00:22:04,129 --> 00:22:07,759
should have been an indie message etc

00:22:05,840 --> 00:22:09,019
for each one of those message types in

00:22:07,759 --> 00:22:14,019
each one of those headers I showed

00:22:09,019 --> 00:22:18,499
earlier in that summary okay so about I

00:22:14,019 --> 00:22:20,539
forget the dates now around 3.9 someone

00:22:18,499 --> 00:22:22,940
decides hey you know I want to add a

00:22:20,539 --> 00:22:24,080
filter to my dump request and so what

00:22:22,940 --> 00:22:25,669
they're really doing is they come in and

00:22:24,080 --> 00:22:28,009
they add an attribute they add some data

00:22:25,669 --> 00:22:31,009
after that header that the kernel then

00:22:28,009 --> 00:22:34,549
parses and says oh not only am I going

00:22:31,009 --> 00:22:36,259
to do a dump of the links I'm also going

00:22:34,549 --> 00:22:38,269
to modify this dump with the following

00:22:36,259 --> 00:22:39,499
request and in this case it was virtual

00:22:38,269 --> 00:22:43,879
functions give me all the virtual

00:22:39,499 --> 00:22:46,309
function information as well so the

00:22:43,879 --> 00:22:48,409
developer goes into the code and changes

00:22:46,309 --> 00:22:50,869
that struck from RT gen message to I

00:22:48,409 --> 00:22:54,019
have info message but that handler was

00:22:50,869 --> 00:22:54,590
used by all the dump requests so

00:22:54,019 --> 00:22:56,600
suddenly

00:22:54,590 --> 00:22:57,840
if I'm doing a neighbor dump I'm pushing

00:22:56,600 --> 00:22:59,730
down an if' info

00:22:57,840 --> 00:23:01,830
if I'm doing an address don't I'm

00:22:59,730 --> 00:23:03,420
pushing down an if' info message that

00:23:01,830 --> 00:23:05,610
should have been illegal from the

00:23:03,420 --> 00:23:07,650
Colonel's perspective but the code that

00:23:05,610 --> 00:23:10,470
was originally put in allowed it

00:23:07,650 --> 00:23:12,540
there was no checking on what came down

00:23:10,470 --> 00:23:13,410
from the user space it said oh well I'm

00:23:12,540 --> 00:23:15,630
doing a link dump

00:23:13,410 --> 00:23:18,030
let me just pass that off to whatever

00:23:15,630 --> 00:23:19,350
address family handles this and run

00:23:18,030 --> 00:23:22,500
through all the devices that are known

00:23:19,350 --> 00:23:29,760
and push back that request and there's

00:23:22,500 --> 00:23:33,060
implications of that all right so I

00:23:29,760 --> 00:23:34,490
think I've covered covered all that all

00:23:33,060 --> 00:23:37,110
right so let's look at some examples

00:23:34,490 --> 00:23:40,710
someone else and so the point of this

00:23:37,110 --> 00:23:42,420
this kind of historical trip here it's

00:23:40,710 --> 00:23:44,160
not to point fingers we're all human we

00:23:42,420 --> 00:23:46,500
all make mistakes we're all focused on

00:23:44,160 --> 00:23:47,820
what we want to get done there really

00:23:46,500 --> 00:23:50,940
what I'm trying to get at with these

00:23:47,820 --> 00:23:53,970
examples is to say when we overlook

00:23:50,940 --> 00:23:56,490
things in the past with this edik from

00:23:53,970 --> 00:23:59,040
Lena from leanness about Linux is that

00:23:56,490 --> 00:24:00,570
thou shalt never break user space so

00:23:59,040 --> 00:24:03,060
once you allow a user space to do

00:24:00,570 --> 00:24:05,460
something you have to forever allow user

00:24:03,060 --> 00:24:07,200
space to do something and that that over

00:24:05,460 --> 00:24:10,260
time that kind of builds up this this

00:24:07,200 --> 00:24:12,600
legacy that we have to deal with so

00:24:10,260 --> 00:24:14,910
someone else comes along and says you

00:24:12,600 --> 00:24:18,270
know I want to modify this FDB dump

00:24:14,910 --> 00:24:20,310
request to only send me the entries for

00:24:18,270 --> 00:24:23,130
a specific bridge or a specific Bridge

00:24:20,310 --> 00:24:25,260
port and so IP route 2 it's already

00:24:23,130 --> 00:24:28,830
sending the if' info message that wasn't

00:24:25,260 --> 00:24:31,260
copied into the fdic for IP route 2 and

00:24:28,830 --> 00:24:34,050
we added the master attribute to the end

00:24:31,260 --> 00:24:36,240
of that kernel happily accepted it all

00:24:34,050 --> 00:24:37,629
the other dump handlers won't affected

00:24:36,240 --> 00:24:40,899
so yeah

00:24:37,629 --> 00:24:43,659
moving along right but all those other

00:24:40,899 --> 00:24:45,369
dump handlers were now being given a

00:24:43,659 --> 00:24:47,950
larger message than what should have

00:24:45,369 --> 00:24:49,149
been allowed so then other people come

00:24:47,950 --> 00:24:52,629
along me

00:24:49,149 --> 00:24:55,119
and I do things like vrf and you know

00:24:52,629 --> 00:24:57,159
immediately I know if I'm dumping tables

00:24:55,119 --> 00:24:59,169
I don't want to dump all the tables I

00:24:57,159 --> 00:25:01,059
want to be able to say just give me this

00:24:59,169 --> 00:25:04,479
one specific table I'm only interested

00:25:01,059 --> 00:25:06,549
in Route table 1,001 so I go to add that

00:25:04,479 --> 00:25:08,229
to the colonel hey let me tell the

00:25:06,549 --> 00:25:11,739
colonel only give me the routes for one

00:25:08,229 --> 00:25:14,379
thousand and one I can't because how can

00:25:11,739 --> 00:25:16,690
I add that attribute to the RT message

00:25:14,379 --> 00:25:19,989
header and that colonel can uniquely

00:25:16,690 --> 00:25:22,659
identify that it's an RT message plus

00:25:19,989 --> 00:25:27,009
this table request as opposed to an if'

00:25:22,659 --> 00:25:28,899
info message and that bf function filter

00:25:27,009 --> 00:25:30,369
that was added to the end of it you get

00:25:28,899 --> 00:25:31,899
into this problem now if the colonel

00:25:30,369 --> 00:25:36,149
cannot uniquely identify what the

00:25:31,899 --> 00:25:36,149
request is so can't do it

00:25:38,510 --> 00:25:44,240
so then this past fall someone else was

00:25:41,660 --> 00:25:46,429
adding other requests to kind of modify

00:25:44,240 --> 00:25:48,620
that dump handler in this case it was

00:25:46,429 --> 00:25:50,780
Christian and wanting to say hey give me

00:25:48,620 --> 00:25:54,320
all the addresses that are known in some

00:25:50,780 --> 00:25:56,299
target namespace okay sure great idea I

00:25:54,320 --> 00:25:58,220
want to modify what what information is

00:25:56,299 --> 00:26:01,220
coming back from the kernel but again

00:25:58,220 --> 00:26:02,690
how does the kernel know uniquely what

00:26:01,220 --> 00:26:05,360
this request is we need to be able to

00:26:02,690 --> 00:26:06,980
parse that message so knowing that I had

00:26:05,360 --> 00:26:08,870
all these things in my head about I want

00:26:06,980 --> 00:26:11,240
to be able to do some other kernel side

00:26:08,870 --> 00:26:15,740
filtering kind of stuff that I was doing

00:26:11,240 --> 00:26:17,630
at that time and when added this strict

00:26:15,740 --> 00:26:19,580
checking infrastructure which basically

00:26:17,630 --> 00:26:22,309
was trying to fix some of these past

00:26:19,580 --> 00:26:26,120
mistakes and say let's add another API

00:26:22,309 --> 00:26:28,280
that says I'm an updated user space I'm

00:26:26,120 --> 00:26:30,590
sending you the proper header please do

00:26:28,280 --> 00:26:32,809
all the formal checking make sure I have

00:26:30,590 --> 00:26:35,030
the right structure make sure I have you

00:26:32,809 --> 00:26:38,000
know request any any bit that's in this

00:26:35,030 --> 00:26:39,980
dump request that it's a valid part of

00:26:38,000 --> 00:26:42,950
what this handler knows how to how to

00:26:39,980 --> 00:26:43,790
interpret and then send back but that's

00:26:42,950 --> 00:26:46,760
awkward

00:26:43,790 --> 00:26:48,770
user space is basically opting in to the

00:26:46,760 --> 00:26:49,910
kernel doing the right thing when the

00:26:48,770 --> 00:26:52,610
kernel really should have been doing the

00:26:49,910 --> 00:26:55,250
right thing from the beginning and so I

00:26:52,610 --> 00:26:57,559
guess the point here is just because of

00:26:55,250 --> 00:26:59,179
I don't want to say shortcuts or

00:26:57,559 --> 00:27:00,530
whatever just this hyper focused

00:26:59,179 --> 00:27:03,080
development that happened in the past

00:27:00,530 --> 00:27:05,660
it's really impacted the ability to move

00:27:03,080 --> 00:27:08,590
to do something new in the future and we

00:27:05,660 --> 00:27:13,190
have to create new api's to handle that

00:27:08,590 --> 00:27:15,440
really awkward kind of a user space you

00:27:13,190 --> 00:27:17,660
know API and interface for someone new

00:27:15,440 --> 00:27:18,770
comes along so someone new comes into

00:27:17,660 --> 00:27:21,080
that link and they want to write an

00:27:18,770 --> 00:27:23,870
application what do you mean I have to

00:27:21,080 --> 00:27:24,919
opt in to you know rigid checking and

00:27:23,870 --> 00:27:26,110
actually being able to do something

00:27:24,919 --> 00:27:29,500
legit

00:27:26,110 --> 00:27:32,529
and then of course you know I only have

00:27:29,500 --> 00:27:34,659
so much time so I changed all the things

00:27:32,529 --> 00:27:38,470
that were important to me so routes

00:27:34,659 --> 00:27:40,630
rules neighbors addresses etc I didn't

00:27:38,470 --> 00:27:43,000
have the time to get into TC so now we

00:27:40,630 --> 00:27:46,570
have this user space API that affects

00:27:43,000 --> 00:27:48,519
most of net link and that link route but

00:27:46,570 --> 00:27:51,250
not all of that link Rob right so again

00:27:48,519 --> 00:27:53,950
it's a little bit of awkwardness going

00:27:51,250 --> 00:27:55,330
forward but you know again I think

00:27:53,950 --> 00:28:00,340
things are much better now than they

00:27:55,330 --> 00:28:02,320
were so going forward kernel developers

00:28:00,340 --> 00:28:05,649
if you're writing new infrastructure

00:28:02,320 --> 00:28:08,590
like eath tool over net link please use

00:28:05,649 --> 00:28:10,480
the strict check strict parsing

00:28:08,590 --> 00:28:13,330
functions of the you know NL message

00:28:10,480 --> 00:28:16,570
parse strict and nla par strict to

00:28:13,330 --> 00:28:20,950
develop a validate every single bit any

00:28:16,570 --> 00:28:23,710
new code should be required to check

00:28:20,950 --> 00:28:25,389
everything the right header the right

00:28:23,710 --> 00:28:27,220
bits in the header if there's a reserved

00:28:25,389 --> 00:28:29,590
fields that you don't modify your dump

00:28:27,220 --> 00:28:32,200
with check those and say not valid if

00:28:29,590 --> 00:28:34,029
it's if it's nonzero and then use the

00:28:32,200 --> 00:28:36,399
strict so I have a part of policy and

00:28:34,029 --> 00:28:39,010
then use these strict parsing functions

00:28:36,399 --> 00:28:41,409
to validate what's coming down from user

00:28:39,010 --> 00:28:43,149
space and so going forward new code

00:28:41,409 --> 00:28:45,690
should have this rigid checking in place

00:28:43,149 --> 00:28:45,690
from the get-go

00:28:47,110 --> 00:28:54,070
kind of a extending piece of this you

00:28:51,429 --> 00:28:56,629
know incomplete checking from the past

00:28:54,070 --> 00:28:59,169
the colonel was also allowed wrong

00:28:56,629 --> 00:29:01,850
attribute sizes yeah there's a policy

00:28:59,169 --> 00:29:03,559
yeah it does some validation that make

00:29:01,850 --> 00:29:07,429
sure there's at least that many bytes

00:29:03,559 --> 00:29:10,730
but at least is not the right API if the

00:29:07,429 --> 00:29:12,950
API is au 32 it shouldn't be greater

00:29:10,730 --> 00:29:15,799
than equal to four bytes it should be

00:29:12,950 --> 00:29:19,039
four bytes and if user space sends more

00:29:15,799 --> 00:29:22,129
than that it's wrong an example of this

00:29:19,039 --> 00:29:25,429
something I hit recently was you know

00:29:22,129 --> 00:29:28,789
I'm adding ipv6 gateways for ipv4 rounds

00:29:25,429 --> 00:29:31,850
and I noticed that if if I put an ipv6

00:29:28,789 --> 00:29:34,940
address into the RTA gateway attribute

00:29:31,850 --> 00:29:38,179
and I send that to the ipv4 code it

00:29:34,940 --> 00:29:40,639
ignores the top twelve whole bytes so

00:29:38,179 --> 00:29:48,889
the the route that gets inserted is

00:29:40,639 --> 00:29:50,600
wrong right yeah exactly when even

00:29:48,889 --> 00:29:53,659
getting to be a little Indian versus big

00:29:50,600 --> 00:29:56,960
in the interpretation of it yeah this is

00:29:53,659 --> 00:29:58,610
strictly the x86 that I'm working on you

00:29:56,960 --> 00:30:00,320
know I would do this you know going in

00:29:58,610 --> 00:30:02,210
and hack up IP route to to say hey what

00:30:00,320 --> 00:30:04,460
happens when I do this and the route

00:30:02,210 --> 00:30:08,830
looks really weird because it's

00:30:04,460 --> 00:30:08,830
interpreting an ipv6 address as an ipv4

00:30:12,080 --> 00:30:16,300
[Music]

00:30:14,680 --> 00:30:19,960
are you gonna blame the colonel for that

00:30:16,300 --> 00:30:22,690
the user sent but address the colonel

00:30:19,960 --> 00:30:24,520
should not allow it assume user space is

00:30:22,690 --> 00:30:27,610
dumb when the colonel should be doing

00:30:24,520 --> 00:30:30,670
strict Jackie right checking yes but I

00:30:27,610 --> 00:30:32,770
mean if you give it a bunch of octet it

00:30:30,670 --> 00:30:35,260
looks at the length it only assumes that

00:30:32,770 --> 00:30:40,240
the four bytes are good enough for you

00:30:35,260 --> 00:30:43,000
for a my argument is that an API is an

00:30:40,240 --> 00:30:46,750
API and it should be exactly an API not

00:30:43,000 --> 00:30:49,960
an ish right so saying that our TA

00:30:46,750 --> 00:30:51,550
gateway for ipv4 is four and more then

00:30:49,960 --> 00:30:53,640
I'll pick which four bytes I want to

00:30:51,550 --> 00:30:57,070
acknowledge that's not really a good API

00:30:53,640 --> 00:31:00,280
okay well you have to say define Indian

00:30:57,070 --> 00:31:01,680
s or something like that but if you give

00:31:00,280 --> 00:31:04,540
me more data than I need

00:31:01,680 --> 00:31:07,180
mhm what should I do with the rest of

00:31:04,540 --> 00:31:09,790
the data or should we say that this is

00:31:07,180 --> 00:31:11,980
invalid because I'm an ipv4 K - it

00:31:09,790 --> 00:31:13,600
should be invalid okay fine yeah that's

00:31:11,980 --> 00:31:16,480
what I mean by getting into strict

00:31:13,600 --> 00:31:18,490
checking and validating what user space

00:31:16,480 --> 00:31:22,770
is sending should be exactly what I

00:31:18,490 --> 00:31:22,770
expect not more not less

00:31:24,040 --> 00:31:31,720
so kind of in this same vein is also the

00:31:28,120 --> 00:31:33,790
new set commands so for example the

00:31:31,720 --> 00:31:36,670
handlers have historically not checked

00:31:33,790 --> 00:31:38,890
every attribute in a request okay you're

00:31:36,670 --> 00:31:41,020
allowing some flexibility but they're

00:31:38,890 --> 00:31:42,880
side effects to that if you have new

00:31:41,020 --> 00:31:45,070
user space running on an older kernel

00:31:42,880 --> 00:31:46,990
new user space is sending down an

00:31:45,070 --> 00:31:49,930
attribute that the old colonel doesn't

00:31:46,990 --> 00:31:51,820
understand so it ignores it but that's

00:31:49,930 --> 00:31:53,770
not what the user asked for the user

00:31:51,820 --> 00:31:55,690
asked for a specific networking config

00:31:53,770 --> 00:31:59,070
and the kernel is ignoring something it

00:31:55,690 --> 00:32:01,480
didn't understand an example of this is

00:31:59,070 --> 00:32:05,680
of course I always have examples for the

00:32:01,480 --> 00:32:11,830
stuff let's go forward I think it's next

00:32:05,680 --> 00:32:14,740
slide yeah Archie avia was a attribute

00:32:11,830 --> 00:32:17,230
that was added recently for MPLS right

00:32:14,740 --> 00:32:20,290
so MPLS it wants to have a gateway

00:32:17,230 --> 00:32:22,600
that's either of efore or v6 so it's a

00:32:20,290 --> 00:32:24,960
new attribute that says here's your RTA

00:32:22,600 --> 00:32:27,100
gateway or here's your Gateway you know

00:32:24,960 --> 00:32:30,070
value but then I have to tell you the

00:32:27,100 --> 00:32:30,490
address family to interpret okay well

00:32:30,070 --> 00:32:33,460
that's great

00:32:30,490 --> 00:32:36,360
MPLS needed this the RTA that's a

00:32:33,460 --> 00:32:38,320
generic routing attribute ipv4 and ipv6

00:32:36,360 --> 00:32:39,580
we're not paying attention to that

00:32:38,320 --> 00:32:43,030
they're ignoring that attribute

00:32:39,580 --> 00:32:46,990
completely so if you send down a route

00:32:43,030 --> 00:32:48,760
that has an RTA via with ipv4 ipv6 the

00:32:46,990 --> 00:32:50,740
route you get is not the route you asked

00:32:48,760 --> 00:32:53,220
for the gateway is completely ignored

00:32:50,740 --> 00:32:57,100
and all you get is a device only route

00:32:53,220 --> 00:33:00,040
so again this has impacts on the kernels

00:32:57,100 --> 00:33:02,860
not doing what the user asked and one

00:33:00,040 --> 00:33:05,140
example that that that this are not

00:33:02,860 --> 00:33:07,270
example a a limitation that this

00:33:05,140 --> 00:33:10,690
provides or it houses

00:33:07,270 --> 00:33:13,030
something like FRR can't probe for when

00:33:10,690 --> 00:33:14,020
a feature is supported right so really

00:33:13,030 --> 00:33:15,970
what the kernel should have been doing

00:33:14,020 --> 00:33:17,230
this whole time is saying

00:33:15,970 --> 00:33:19,509
I've gone through all the attributes are

00:33:17,230 --> 00:33:21,669
in this message I don't support some of

00:33:19,509 --> 00:33:23,889
these I'm a returnee invalid now

00:33:21,669 --> 00:33:27,190
userspace knows it's asking for

00:33:23,889 --> 00:33:31,539
something I can't provide so so is it

00:33:27,190 --> 00:33:33,730
lunchtime or can i because okay so my

00:33:31,539 --> 00:33:35,970
only challenge is this you know the

00:33:33,730 --> 00:33:39,100
principle of robustness if you may be

00:33:35,970 --> 00:33:42,070
attributed to your postel because of

00:33:39,100 --> 00:33:44,740
offer you expect of others and be

00:33:42,070 --> 00:33:45,850
laborers or is it be liberal what for to

00:33:44,740 --> 00:33:49,450
expect of other people

00:33:45,850 --> 00:33:53,740
I send you crap that you don't support

00:33:49,450 --> 00:33:55,889
you can ignore it that that's if but you

00:33:53,740 --> 00:33:58,149
don't send crap to other people that's

00:33:55,889 --> 00:34:01,360
yes I am familiar with the phrase and I

00:33:58,149 --> 00:34:02,919
don't know the exact line but if the

00:34:01,360 --> 00:34:05,889
user space is telling you to do

00:34:02,919 --> 00:34:07,299
something and you're not doing it then

00:34:05,889 --> 00:34:10,629
you're not doing what you were asked to

00:34:07,299 --> 00:34:12,460
do right so in the case of the X land

00:34:10,629 --> 00:34:14,260
being the example I think it was

00:34:12,460 --> 00:34:16,270
discussed a few years ago you know

00:34:14,260 --> 00:34:19,149
attributes being completely ignored it

00:34:16,270 --> 00:34:21,010
could be a security all right in some

00:34:19,149 --> 00:34:23,020
cases depending on what the attribute is

00:34:21,010 --> 00:34:24,760
it could be a huge problem that you're

00:34:23,020 --> 00:34:26,050
just ignoring you do you have look it

00:34:24,760 --> 00:34:29,770
makes another slide that we will say

00:34:26,050 --> 00:34:31,839
what your solution is or discussion the

00:34:29,770 --> 00:34:33,609
the solution yeah I do

00:34:31,839 --> 00:34:36,190
bring that up generically the solution

00:34:33,609 --> 00:34:37,359
is to the when you're doing kernel side

00:34:36,190 --> 00:34:39,399
development you should be checking

00:34:37,359 --> 00:34:41,349
everything and you should be airing out

00:34:39,399 --> 00:34:43,270
if the user space sends you something

00:34:41,349 --> 00:34:45,639
you don't need you don't support and

00:34:43,270 --> 00:34:48,730
here's why I know you and know you want

00:34:45,639 --> 00:34:51,310
the more liberal policy but features are

00:34:48,730 --> 00:34:53,079
constantly coming in features are back

00:34:51,310 --> 00:34:54,609
ported then there's you know vendor

00:34:53,079 --> 00:34:56,859
distributions are always back boarding

00:34:54,609 --> 00:34:59,200
stuff how does a generic application

00:34:56,859 --> 00:35:01,810
know it can use a certain feature on a

00:34:59,200 --> 00:35:03,609
certain kernel but how far all kernels

00:35:01,810 --> 00:35:06,369
will ignore what you're sending I'm

00:35:03,609 --> 00:35:08,619
sorry colonel from three years ago is

00:35:06,369 --> 00:35:10,230
not gonna interpret what he sent right

00:35:08,619 --> 00:35:21,060
right so how do

00:35:10,230 --> 00:35:22,470
you know Mike Mike that's not the issue

00:35:21,060 --> 00:35:24,930
though right it's a compatibility

00:35:22,470 --> 00:35:27,599
problem you you build something and you

00:35:24,930 --> 00:35:30,150
release it out there you have to now

00:35:27,599 --> 00:35:32,339
figure out whether a kernel just ignored

00:35:30,150 --> 00:35:34,770
it or a kernel in implemented it and did

00:35:32,339 --> 00:35:36,839
what you expected which becomes an

00:35:34,770 --> 00:35:38,630
impossible task once you start getting

00:35:36,839 --> 00:35:40,950
to see the overlap of different

00:35:38,630 --> 00:35:43,740
attributes from different features yes

00:35:40,950 --> 00:35:47,520
as long as you you're not going to use

00:35:43,740 --> 00:35:49,619
all kernels you're fine right so this is

00:35:47,520 --> 00:35:51,089
why I'm giving specific examples so well

00:35:49,619 --> 00:35:53,339
I'm just saying because you may have if

00:35:51,089 --> 00:35:56,099
this check that's telling me is invalid

00:35:53,339 --> 00:35:59,550
so as this this is why I bring up Archie

00:35:56,099 --> 00:36:02,369
haveá-- so Archie avea is needed for

00:35:59,550 --> 00:36:04,079
ipv6 gateways with ipv4 routes this is

00:36:02,369 --> 00:36:06,270
an essential feature that all network

00:36:04,079 --> 00:36:08,310
operating systems have to have so I have

00:36:06,270 --> 00:36:10,619
that implemented now how does that far

00:36:08,310 --> 00:36:12,540
are know when it can use it how there's

00:36:10,619 --> 00:36:15,089
an occasional know about it because like

00:36:12,540 --> 00:36:16,950
I said if if FRR is running on an old

00:36:15,089 --> 00:36:19,079
kernel and it pushes that down thinking

00:36:16,950 --> 00:36:20,790
oh I'm using a numbered I can just push

00:36:19,079 --> 00:36:22,770
this route down and then the kernel

00:36:20,790 --> 00:36:25,740
drops the Gateway completely it doesn't

00:36:22,770 --> 00:36:28,020
work you're not working is broken that's

00:36:25,740 --> 00:36:30,359
wrong no I totally agree with you I'm

00:36:28,020 --> 00:36:32,010
just saying that there's no way we have

00:36:30,359 --> 00:36:34,319
had no traditional way of indicating

00:36:32,010 --> 00:36:35,579
that if this thing I'm sending you

00:36:34,319 --> 00:36:39,060
doesn't work for you

00:36:35,579 --> 00:36:40,800
I want you to tell me it's a bad if you

00:36:39,060 --> 00:36:42,510
can support this attribute so I would

00:36:40,800 --> 00:36:45,180
argue that's part of proper API design

00:36:42,510 --> 00:36:47,670
no I and with perf for example any bit

00:36:45,180 --> 00:36:50,099
that comes down in a perfe vent it will

00:36:47,670 --> 00:36:52,230
air out and so per for a long time has

00:36:50,099 --> 00:36:54,510
had this ability to kind of figure out

00:36:52,230 --> 00:36:56,490
based on the order the features were

00:36:54,510 --> 00:36:58,109
added and it will probe in the reverse

00:36:56,490 --> 00:36:59,430
order and say oh you don't support this

00:36:58,109 --> 00:37:00,740
this this and this I'm gonna go with

00:36:59,430 --> 00:37:03,320
this working config

00:37:00,740 --> 00:37:05,270
to get the perfect answer networking

00:37:03,320 --> 00:37:06,500
should be doing something similar if you

00:37:05,270 --> 00:37:07,310
just ignore the things you don't

00:37:06,500 --> 00:37:10,430
understand

00:37:07,310 --> 00:37:12,470
you have then says but I say yes that's

00:37:10,430 --> 00:37:14,210
that's a long-standing principle I mean

00:37:12,470 --> 00:37:15,830
XML does the same thing you can name

00:37:14,210 --> 00:37:17,810
like ten different things that says you

00:37:15,830 --> 00:37:19,010
know what you don't understand no prob

00:37:17,810 --> 00:37:21,830
you should error you should log it

00:37:19,010 --> 00:37:25,420
probably always air out it's my art it's

00:37:21,830 --> 00:37:27,859
that's too conservative right

00:37:25,420 --> 00:37:30,220
unacceptable for a networking to be

00:37:27,859 --> 00:37:30,220
ignored

00:37:32,560 --> 00:37:37,910
things like OpenGL where you basically

00:37:35,510 --> 00:37:39,440
have extension attributes and you

00:37:37,910 --> 00:37:41,210
negotiate which is along the lines of

00:37:39,440 --> 00:37:43,640
what you described for perfo negotiate

00:37:41,210 --> 00:37:45,140
upfront and you only use the attributes

00:37:43,640 --> 00:37:46,490
that you are allowed to use and if you

00:37:45,140 --> 00:37:48,830
call something that you're not allowed

00:37:46,490 --> 00:37:51,109
it becomes an explicit error call but

00:37:48,830 --> 00:37:53,450
retro actively fitting that into these

00:37:51,109 --> 00:37:54,890
internet link may not be the easier yeah

00:37:53,450 --> 00:37:55,849
that's the problem I mean if you're

00:37:54,890 --> 00:37:58,130
saying you're going forward

00:37:55,849 --> 00:38:01,250
I'm sorry I just want to make this one

00:37:58,130 --> 00:38:04,700
point going forward maybe and I think

00:38:01,250 --> 00:38:08,359
SCTP does this you you will set a bit

00:38:04,700 --> 00:38:10,820
correct me if I'm wrong which which says

00:38:08,359 --> 00:38:12,560
I can't operate if you can set this

00:38:10,820 --> 00:38:15,680
attribute right you send it to the

00:38:12,560 --> 00:38:17,420
kernel mmm and yeah if you don't set

00:38:15,680 --> 00:38:20,180
that bit the new be ignored it's fair to

00:38:17,420 --> 00:38:22,700
ignore it or in other words and if you

00:38:20,180 --> 00:38:24,920
set that flag then then the I it makes

00:38:22,700 --> 00:38:26,119
sense to ignore but I don't I don't know

00:38:24,920 --> 00:38:29,720
how you can do backward compatibility

00:38:26,119 --> 00:38:31,339
with that right there was a comment so

00:38:29,720 --> 00:38:34,040
for the artsy idea I did send out

00:38:31,339 --> 00:38:36,619
patches which now ipv4 ipv6 will error

00:38:34,040 --> 00:38:38,030
out but it's gonna take time and so FRR

00:38:36,619 --> 00:38:40,960
for the longest time will have no way of

00:38:38,030 --> 00:38:43,670
knowing can I use this feature or not

00:38:40,960 --> 00:38:45,859
and I'm saying that this exact feature

00:38:43,670 --> 00:38:47,930
the MPLS which I pointed out would fail

00:38:45,859 --> 00:38:50,500
in all kernels and our our wouldn't know

00:38:47,930 --> 00:38:50,500
anything about it

00:38:50,529 --> 00:38:59,359
it's not failing yes to be accepted FRR

00:38:55,609 --> 00:39:01,160
will use the wrong field so the correct

00:38:59,359 --> 00:39:02,690
ever are sending the right message it's

00:39:01,160 --> 00:39:05,420
sending the rebel is ignoring it gets a

00:39:02,690 --> 00:39:07,369
success because Pasha but partially the

00:39:05,420 --> 00:39:08,779
Gateway was an imposing the stall so

00:39:07,369 --> 00:39:10,460
you're trying to get BGP and numbered

00:39:08,779 --> 00:39:11,720
working and it won't and the user is

00:39:10,460 --> 00:39:15,680
like wait a minute if you use Colonel

00:39:11,720 --> 00:39:17,690
2.2 or 2.63 - it won't work

00:39:15,680 --> 00:39:19,579
correct it'll steer auntie Rotti sex

00:39:17,690 --> 00:39:24,799
these are very old right they always

00:39:19,579 --> 00:39:27,619
work I recently fix it'll make its way

00:39:24,799 --> 00:39:29,930
through all the back stay back ports but

00:39:27,619 --> 00:39:32,029
that takes time and really it's the

00:39:29,930 --> 00:39:33,859
bigger point of and I use this example

00:39:32,029 --> 00:39:35,779
from both the missing attribute and the

00:39:33,859 --> 00:39:38,539
ability to probe this is an essential

00:39:35,779 --> 00:39:40,460
feature that a legit user space

00:39:38,539 --> 00:39:43,940
application has no way of knowing when

00:39:40,460 --> 00:39:45,890
can it use it when can it not that's

00:39:43,940 --> 00:39:47,960
horrible that's a horrible API yeah I

00:39:45,890 --> 00:39:50,749
just wanted to point out that in this

00:39:47,960 --> 00:39:55,430
example you can see something really bad

00:39:50,749 --> 00:39:58,269
because the request does not allow the

00:39:55,430 --> 00:40:01,069
request is not ignored it's actually in

00:39:58,269 --> 00:40:04,130
misinterpreted because only part of the

00:40:01,069 --> 00:40:07,279
request is implemented imagine that you

00:40:04,130 --> 00:40:11,089
want to add an advert arul with iptables

00:40:07,279 --> 00:40:13,970
and colonel doesn't understand one of

00:40:11,089 --> 00:40:15,289
the conditions so it just emits it so

00:40:13,970 --> 00:40:16,460
I'm saying this is nothing wrong with

00:40:15,289 --> 00:40:18,470
that based on the current philosophy

00:40:16,460 --> 00:40:21,349
we've always had this philosophy of

00:40:18,470 --> 00:40:22,789
being liberal you send me crap I say

00:40:21,349 --> 00:40:24,109
okay well it's crazy I'm just gonna

00:40:22,789 --> 00:40:28,489
ignore him right but in this case it's

00:40:24,109 --> 00:40:30,739
not crap it was not crap so but given

00:40:28,489 --> 00:40:32,749
all the kernels up to this point have

00:40:30,739 --> 00:40:35,180
been behaving this hard so the vx land

00:40:32,749 --> 00:40:37,839
when the excellent first came on there

00:40:35,180 --> 00:40:40,190
was a discussion years ago about this

00:40:37,839 --> 00:40:40,650
ignoring attributes you understand and

00:40:40,190 --> 00:40:42,210
how you

00:40:40,650 --> 00:40:44,010
completely wrong networking fake and

00:40:42,210 --> 00:40:45,839
it's like how do you fix us going

00:40:44,010 --> 00:40:47,430
forward well I would argue anyone who

00:40:45,839 --> 00:40:49,890
puts in a new API on the kernel should

00:40:47,430 --> 00:40:52,260
have this rigid checking so that user

00:40:49,890 --> 00:40:54,390
space can reliably know if it can use an

00:40:52,260 --> 00:40:55,799
attribute or not because otherwise it's

00:40:54,390 --> 00:40:58,079
a craps you don't leave it's a middle

00:40:55,799 --> 00:41:01,500
ground like the HTTP modal where I think

00:40:58,079 --> 00:41:03,869
it's SCTP sits I as a user will tell you

00:41:01,500 --> 00:41:06,839
like FRR will now set a flag to see

00:41:03,869 --> 00:41:09,299
whether it's very bad if you can't apply

00:41:06,839 --> 00:41:10,829
this attribute then you get an error on

00:41:09,299 --> 00:41:12,180
your that gets into what I put in for

00:41:10,829 --> 00:41:14,460
this rec checking which is basically

00:41:12,180 --> 00:41:15,809
saying I have a clue I'm sending you out

00:41:14,460 --> 00:41:17,220
information so you have you can turn

00:41:15,809 --> 00:41:19,559
over it but I think that's an awkward

00:41:17,220 --> 00:41:21,720
API I think that's horrible to say I

00:41:19,559 --> 00:41:23,460
think it should be the inverse of be

00:41:21,720 --> 00:41:25,589
relaxed you know if you don't understand

00:41:23,460 --> 00:41:30,359
something it's okay to ignore it that's

00:41:25,589 --> 00:41:33,150
it okay so as long as that flag is there

00:41:30,359 --> 00:41:34,890
I'm with you it's a difference of it

00:41:33,150 --> 00:41:36,779
didn't get too liberal for new and SATs

00:41:34,890 --> 00:41:39,000
it's not there right and so I guess what

00:41:36,779 --> 00:41:41,730
I'm arguing is we run a horrible

00:41:39,000 --> 00:41:43,529
situation where you just pace has no way

00:41:41,730 --> 00:41:45,470
of knowing how something's gonna be

00:41:43,529 --> 00:41:49,950
interpreted and I would say that's

00:41:45,470 --> 00:41:53,039
unacceptable going forward that's what

00:41:49,950 --> 00:41:54,359
this kind of slide gets into is when you

00:41:53,039 --> 00:41:56,130
have all this locks checking you have

00:41:54,359 --> 00:41:58,410
this history you end up with these

00:41:56,130 --> 00:41:59,789
really ugly hacks and the strict

00:41:58,410 --> 00:42:01,950
checking is just one I could have given

00:41:59,789 --> 00:42:03,440
many more examples where some ugly API

00:42:01,950 --> 00:42:05,920
additions have been put in

00:42:03,440 --> 00:42:09,200
to accommodate these past mistakes and

00:42:05,920 --> 00:42:10,609
for us to have you know for example one

00:42:09,200 --> 00:42:13,700
of the things Donald's been asking for

00:42:10,609 --> 00:42:15,589
FRR is you know if if there's no way to

00:42:13,700 --> 00:42:18,109
get an error back when doesn't support

00:42:15,589 --> 00:42:20,150
something then how do I know what

00:42:18,109 --> 00:42:21,680
supported there there's got to be

00:42:20,150 --> 00:42:26,960
something that says tell me what you'll

00:42:21,680 --> 00:42:29,780
interpret right and then I guess a is a

00:42:26,960 --> 00:42:31,819
part of this request it's also yeah this

00:42:29,780 --> 00:42:34,130
this edict where you can't change you

00:42:31,819 --> 00:42:36,680
can't break user space when something's

00:42:34,130 --> 00:42:38,839
coming in for new user API we got to be

00:42:36,680 --> 00:42:40,099
very careful and thoughtful about you

00:42:38,839 --> 00:42:42,260
know everyone needs to put some eyes on

00:42:40,099 --> 00:42:43,520
and review it and give some ideas or of

00:42:42,260 --> 00:42:46,339
whether this is a good thing or a bad

00:42:43,520 --> 00:42:48,920
thing because once it goes in its young

00:42:46,339 --> 00:42:52,460
so on that I think the problem is

00:42:48,920 --> 00:42:56,059
there's not enough time I think here is

00:42:52,460 --> 00:42:58,970
he we've always complained about LaHaye

00:42:56,059 --> 00:43:01,730
let you API discussions stay there for a

00:42:58,970 --> 00:43:03,530
long time right because it's too late

00:43:01,730 --> 00:43:05,240
once you we've had this discussion you

00:43:03,530 --> 00:43:06,890
have a discussion again and that's why I

00:43:05,240 --> 00:43:10,730
bring it up again

00:43:06,890 --> 00:43:13,789
yeah I actually try to ask Dave yeah

00:43:10,730 --> 00:43:15,650
Miller to to death multiple times if

00:43:13,789 --> 00:43:17,869
there's a you API and that or a class

00:43:15,650 --> 00:43:19,309
just leave it there from the brain weeks

00:43:17,869 --> 00:43:23,049
that's all right

00:43:19,309 --> 00:43:26,049
you can't wait but it's not like that

00:43:23,049 --> 00:43:26,049
perfectly

00:43:26,460 --> 00:43:32,220
I don't see how to force it well that's

00:43:29,940 --> 00:43:33,599
where Dave's trying to balance a lot of

00:43:32,220 --> 00:43:36,800
things and so this is where the

00:43:33,599 --> 00:43:39,900
community has to be involved as well and

00:43:36,800 --> 00:43:43,020
even if it has been a week after they've

00:43:39,900 --> 00:43:44,490
been applied until it hits Lena's tree

00:43:43,020 --> 00:43:46,349
and actually gets released from there

00:43:44,490 --> 00:43:49,530
there is a chance to either fix it or

00:43:46,349 --> 00:43:51,030
revert it so there is some time window

00:43:49,530 --> 00:43:52,890
but we all have to be involved and

00:43:51,030 --> 00:43:55,500
invested in and doing that and doing the

00:43:52,890 --> 00:43:57,540
review and yeah I think this is a

00:43:55,500 --> 00:43:59,460
request also for kernel side developers

00:43:57,540 --> 00:44:02,250
to start doing this trick Jackie and

00:43:59,460 --> 00:44:04,470
start doing the like my next stop API I

00:44:02,250 --> 00:44:06,599
do run that through that list there's an

00:44:04,470 --> 00:44:08,460
attribute that comes down it's gonna

00:44:06,599 --> 00:44:11,790
error out and that's because I want that

00:44:08,460 --> 00:44:13,800
I want networking demons via to say you

00:44:11,790 --> 00:44:16,250
know you know it's worth this but isn't

00:44:13,800 --> 00:44:19,890
that something we really need to go and

00:44:16,250 --> 00:44:21,869
sort of make the make some kind of

00:44:19,890 --> 00:44:23,309
generic infrastructure for so that you

00:44:21,869 --> 00:44:27,270
don't have to go check every single

00:44:23,309 --> 00:44:29,790
attribute but it's gonna be so this way

00:44:27,270 --> 00:44:33,390
opt into something so maybe some areas

00:44:29,790 --> 00:44:36,000
are okay with ignoring it for me the

00:44:33,390 --> 00:44:37,500
next hop stuff no every single attribute

00:44:36,000 --> 00:44:38,940
needs to come down I need to understand

00:44:37,500 --> 00:44:40,559
and I know you need to know I'm doing

00:44:38,940 --> 00:44:42,470
the right thing with that request from

00:44:40,559 --> 00:44:45,440
user space

00:44:42,470 --> 00:44:47,000
and I would argue that's for most

00:44:45,440 --> 00:44:49,310
networking and fake that's always going

00:44:47,000 --> 00:44:50,690
to be true it should always run through

00:44:49,310 --> 00:44:52,670
the TV is that you know that the

00:44:50,690 --> 00:44:54,319
attributes and say if I don't understand

00:44:52,670 --> 00:44:57,170
this one I gotta tell the user I don't

00:44:54,319 --> 00:45:01,250
understand this ignoring should never be

00:44:57,170 --> 00:45:02,450
acceptable I guess somebody all right it

00:45:01,250 --> 00:45:06,680
looks like we're at a time for this

00:45:02,450 --> 00:45:11,690
initial thirty minutes any other quick

00:45:06,680 --> 00:45:14,150
questions no I've got the scale piece of

00:45:11,690 --> 00:45:17,980
this but that's another bunch of edges

00:45:14,150 --> 00:45:17,980
upstairs okay caffeine

00:45:19,849 --> 00:45:29,000
so next on the agenda is discussions on

00:45:23,849 --> 00:45:31,410
scale so debt like messaging at scale I

00:45:29,000 --> 00:45:33,690
want to start with I guess some

00:45:31,410 --> 00:45:35,520
suggestions for application developers

00:45:33,690 --> 00:45:36,720
so if you're doing something with net

00:45:35,520 --> 00:45:39,270
link and you're like how can I make

00:45:36,720 --> 00:45:41,130
things better so if you remember back

00:45:39,270 --> 00:45:44,160
one of those original slides first

00:45:41,130 --> 00:45:45,900
slides for me I showed that format for

00:45:44,160 --> 00:45:47,940
net linked messages which is the null

00:45:45,900 --> 00:45:51,240
message header followed by the payload

00:45:47,940 --> 00:45:53,940
well the Natalie KPI supports batching

00:45:51,240 --> 00:45:56,310
so you can push down a buffer with

00:45:53,940 --> 00:45:57,869
multiple messages in it and the kernel

00:45:56,310 --> 00:46:00,060
loops over each one of those messages

00:45:57,869 --> 00:46:01,410
calling the handlers to do whatever

00:46:00,060 --> 00:46:05,220
you're asking for that particular

00:46:01,410 --> 00:46:07,859
message so that is one way to get to get

00:46:05,220 --> 00:46:11,010
increased scale so TC batch for example

00:46:07,859 --> 00:46:12,990
was recently changed to use this and FRR

00:46:11,010 --> 00:46:16,109
for example I'm told is working on

00:46:12,990 --> 00:46:19,589
support for this another option is to

00:46:16,109 --> 00:46:22,589
not set the act flag for every message

00:46:19,589 --> 00:46:25,020
so don't have the colonel send you back

00:46:22,589 --> 00:46:27,960
up that everything was good everything

00:46:25,020 --> 00:46:30,060
was good everything was good and instead

00:46:27,960 --> 00:46:32,280
only get back an error an error message

00:46:30,060 --> 00:46:34,140
so if you push down a command that the

00:46:32,280 --> 00:46:36,690
colonel said I can't do this for you

00:46:34,140 --> 00:46:37,890
then you get an error message back and

00:46:36,690 --> 00:46:38,930
so you can say well everything else must

00:46:37,890 --> 00:46:41,280
have worked fine

00:46:38,930 --> 00:46:42,599
although based on that last discussion

00:46:41,280 --> 00:46:44,220
perhaps assumptions aren't a good thing

00:46:42,599 --> 00:46:46,920
so anyway

00:46:44,220 --> 00:46:48,900
fr recently did this switch to not

00:46:46,920 --> 00:46:50,220
getting an act for every message and it

00:46:48,900 --> 00:46:52,730
was a ballpark about a 20 percent

00:46:50,220 --> 00:46:52,730
improvement

00:46:54,210 --> 00:46:57,420
one problem that we do have to start

00:46:55,920 --> 00:47:00,450
thinking about and dealing with is

00:46:57,420 --> 00:47:03,690
notification storms so as I mentioned in

00:47:00,450 --> 00:47:05,970
the beginning of this typically there's

00:47:03,690 --> 00:47:08,490
a multicast group that applications can

00:47:05,970 --> 00:47:10,280
register with to get notifications as

00:47:08,490 --> 00:47:12,690
events happen in the kernel

00:47:10,280 --> 00:47:15,210
unfortunately there are way too many

00:47:12,690 --> 00:47:18,240
events and the messages that are

00:47:15,210 --> 00:47:20,550
generated are way too large so link

00:47:18,240 --> 00:47:22,530
events are the huge example of this in

00:47:20,550 --> 00:47:26,130
terms of both message sides and in

00:47:22,530 --> 00:47:28,590
frequency so when all these messages get

00:47:26,130 --> 00:47:31,140
generated and the applications that have

00:47:28,590 --> 00:47:33,300
asked for these notifications their

00:47:31,140 --> 00:47:34,890
sockets can overflow pretty quickly if

00:47:33,300 --> 00:47:37,320
they're not able to run and handle the

00:47:34,890 --> 00:47:39,420
messages in time and if the application

00:47:37,320 --> 00:47:40,890
overflows typically the application is

00:47:39,420 --> 00:47:43,470
going to close the socket and start over

00:47:40,890 --> 00:47:45,180
again which is a resync and that can be

00:47:43,470 --> 00:47:47,460
extremely costly if you have to do an

00:47:45,180 --> 00:47:50,940
entire dump to kind of reset where you

00:47:47,460 --> 00:47:53,490
are so you know I mentioned in a lot of

00:47:50,940 --> 00:47:56,880
slide that netlink supports batching

00:47:53,490 --> 00:47:58,170
with respect to messages so application

00:47:56,880 --> 00:48:01,200
can push down a buffer with a whole

00:47:58,170 --> 00:48:02,640
bunch of messages is it possible to do

00:48:01,200 --> 00:48:05,100
something like batched

00:48:02,640 --> 00:48:06,780
notifications so can we have a whole

00:48:05,100 --> 00:48:08,790
bunch of notifications get generated in

00:48:06,780 --> 00:48:11,400
one buffer and then push those up to

00:48:08,790 --> 00:48:12,930
user space and have it apply I haven't

00:48:11,400 --> 00:48:14,040
looked into this it was one of the

00:48:12,930 --> 00:48:16,760
suggestions that was tossed on the

00:48:14,040 --> 00:48:16,760
mailing list for example

00:48:17,830 --> 00:48:21,580
when ik when it comes to generating

00:48:19,510 --> 00:48:24,010
these notifications it takes a

00:48:21,580 --> 00:48:26,710
noticeable amount of time to allocate

00:48:24,010 --> 00:48:29,200
the skv to fill in the information for

00:48:26,710 --> 00:48:31,750
that object type link being the largest

00:48:29,200 --> 00:48:35,170
one of those and then to have that

00:48:31,750 --> 00:48:37,900
message applied to all the sockets if

00:48:35,170 --> 00:48:39,700
there are no listeners could we

00:48:37,900 --> 00:48:43,030
potentially bypass generating that

00:48:39,700 --> 00:48:45,160
message completely or based on whatever

00:48:43,030 --> 00:48:46,690
filtering is in place basically what

00:48:45,160 --> 00:48:48,700
Jamal talked about a little bit later is

00:48:46,690 --> 00:48:51,360
it possible to somehow know ahead of

00:48:48,700 --> 00:48:53,560
time and no one cares about this message

00:48:51,360 --> 00:48:55,870
right so that could end up saving a

00:48:53,560 --> 00:48:57,760
civic about a time on the kernel side

00:48:55,870 --> 00:49:00,220
generating something that no one cares

00:48:57,760 --> 00:49:03,310
about and so those are more open

00:49:00,220 --> 00:49:05,800
questions one option that does exist

00:49:03,310 --> 00:49:08,770
today is for applications to push down a

00:49:05,800 --> 00:49:10,810
BPF filter to a knelling socket but

00:49:08,770 --> 00:49:14,110
unfortunately that applies after the skb

00:49:10,810 --> 00:49:15,190
has been generated so in this case you

00:49:14,110 --> 00:49:16,990
know all the applications will get a

00:49:15,190 --> 00:49:19,300
copy you'll run the filter on it and

00:49:16,990 --> 00:49:21,850
just this app says and I don't care

00:49:19,300 --> 00:49:23,530
about this message okay sure that's it's

00:49:21,850 --> 00:49:25,300
a to help some of those some

00:49:23,530 --> 00:49:27,910
applications won't be waking up for all

00:49:25,300 --> 00:49:30,400
the messages but there's going to be you

00:49:27,910 --> 00:49:33,580
know there are limits to what you can do

00:49:30,400 --> 00:49:38,800
with those BPF filters one example for

00:49:33,580 --> 00:49:41,500
this is VR F so VR F is more of a it's a

00:49:38,800 --> 00:49:44,470
higher-level feature so for example if

00:49:41,500 --> 00:49:48,100
link 1 has an event of eath one has a

00:49:44,470 --> 00:49:50,470
link event and eath 1 is not in the VR F

00:49:48,100 --> 00:49:53,230
of interest how does an application say

00:49:50,470 --> 00:49:55,540
I only care about management for events

00:49:53,230 --> 00:49:57,190
so which case 8th one is not a part of

00:49:55,540 --> 00:49:59,350
management where I don't want to know be

00:49:57,190 --> 00:50:02,370
notified about this what can we do in

00:49:59,350 --> 00:50:02,370
that scope

00:50:02,630 --> 00:50:09,960
so as I said I do link events are by far

00:50:06,930 --> 00:50:14,250
the largest message sizes and frequency

00:50:09,960 --> 00:50:18,330
of notifications routes is another one

00:50:14,250 --> 00:50:20,550
so when a link goes down ipv4 does not

00:50:18,330 --> 00:50:22,830
generate notifications the user space

00:50:20,550 --> 00:50:25,590
user space is expected to monitor those

00:50:22,830 --> 00:50:27,030
link events and say oh I know the

00:50:25,590 --> 00:50:30,570
colonel just evicted all the routes

00:50:27,030 --> 00:50:34,140
associated with this device ipv6 does

00:50:30,570 --> 00:50:36,780
not I sent a patch in I don't know how

00:50:34,140 --> 00:50:39,030
long ago now maybe six months ago where

00:50:36,780 --> 00:50:43,110
you can opt in how be six opt into this

00:50:39,030 --> 00:50:45,060
behavior where a link goes down when so

00:50:43,110 --> 00:50:46,950
ipv6 routes already victim because of

00:50:45,060 --> 00:50:49,680
that link down event do not generate a

00:50:46,950 --> 00:50:53,310
notification so that is one way to kind

00:50:49,680 --> 00:50:55,410
of help reduce a storm MPLS is kind of

00:50:53,310 --> 00:50:57,240
all over the board need to need to find

00:50:55,410 --> 00:50:58,740
some time to focus on that one and bring

00:50:57,240 --> 00:51:02,820
it in line with the other routing

00:50:58,740 --> 00:51:05,010
routing families neighbors same thing

00:51:02,820 --> 00:51:06,900
and you get into scenarios like evpn

00:51:05,010 --> 00:51:10,050
where you can have tens of thousands of

00:51:06,900 --> 00:51:11,910
Mac's per per device if your device goes

00:51:10,050 --> 00:51:13,440
down that's a whole bunch of

00:51:11,910 --> 00:51:16,560
notifications after you've generated the

00:51:13,440 --> 00:51:18,660
user space I have a version multiple

00:51:16,560 --> 00:51:21,810
versions of a neighbor patch that says

00:51:18,660 --> 00:51:23,220
again you can opt in to user space

00:51:21,810 --> 00:51:25,320
doesn't need to be told about all these

00:51:23,220 --> 00:51:27,390
events it's already monitoring linked

00:51:25,320 --> 00:51:28,080
events it already knows all the stuff is

00:51:27,390 --> 00:51:30,060
going to happen

00:51:28,080 --> 00:51:31,440
it'll be evicted from their cache on its

00:51:30,060 --> 00:51:33,420
own you don't need to generate these

00:51:31,440 --> 00:51:35,970
events

00:51:33,420 --> 00:51:37,980
so just a comment on that so TC also

00:51:35,970 --> 00:51:40,380
does some of this stuff when you have a

00:51:37,980 --> 00:51:42,150
hierarchy of thing of objects and if the

00:51:40,380 --> 00:51:44,040
root is gone you don't want to advertise

00:51:42,150 --> 00:51:46,170
the lower level so I think the link

00:51:44,040 --> 00:51:48,450
going down meaning routes which were

00:51:46,170 --> 00:51:51,300
tied to that link there's no point in

00:51:48,450 --> 00:51:52,950
advertising whoever assumedly whoever's

00:51:51,300 --> 00:51:54,990
doing it in userspace already knows the

00:51:52,950 --> 00:51:57,030
hierarchies and if the link is gone

00:51:54,990 --> 00:51:59,190
they're out but it's not just the

00:51:57,030 --> 00:52:01,470
application that does it it's the other

00:51:59,190 --> 00:52:04,860
ones so I've got some examples I think

00:52:01,470 --> 00:52:06,720
it's on the next slide so does TC today

00:52:04,860 --> 00:52:08,940
generate those notifications and you're

00:52:06,720 --> 00:52:10,530
saying a class needed to opt out for

00:52:08,940 --> 00:52:13,290
example if I could add a queue disk

00:52:10,530 --> 00:52:14,700
ingress add filters to it if I delete

00:52:13,290 --> 00:52:16,890
the cutest ingress which is the matter

00:52:14,700 --> 00:52:18,180
of the filters I don't get notifications

00:52:16,890 --> 00:52:19,680
that filters were deleted I get

00:52:18,180 --> 00:52:25,310
notification the computers was deleted

00:52:19,680 --> 00:52:25,310
okay then I deduce that okay

00:52:25,500 --> 00:52:32,290
so looking examples of applications that

00:52:29,740 --> 00:52:33,430
are notified so you'd be surprised and

00:52:32,290 --> 00:52:35,920
this comes out of some testing that

00:52:33,430 --> 00:52:37,510
Donald's done with FRR where you inject

00:52:35,920 --> 00:52:39,520
a million routes into the kernel and

00:52:37,510 --> 00:52:43,150
you're watching the CPU kind of

00:52:39,520 --> 00:52:46,210
surprising NTP taking a lot of CPU DHT

00:52:43,150 --> 00:52:48,130
PD taking a lot of CPU turns out both

00:52:46,210 --> 00:52:50,560
those processes register for

00:52:48,130 --> 00:52:52,240
notifications every time you have a link

00:52:50,560 --> 00:52:54,700
event every time you have an address

00:52:52,240 --> 00:52:57,130
event a routing events a multicast

00:52:54,700 --> 00:52:59,440
routing event when you get into a

00:52:57,130 --> 00:53:01,960
networking operating system environment

00:52:59,440 --> 00:53:05,260
there can be millions of routes tens of

00:53:01,960 --> 00:53:08,349
thousands of links and addresses so ntpd

00:53:05,260 --> 00:53:10,180
is waking up and doing a lot well what

00:53:08,349 --> 00:53:12,849
is it doing well really all it's doing

00:53:10,180 --> 00:53:14,980
is receiving this message says oh I

00:53:12,849 --> 00:53:17,319
should reset this timer value and so it

00:53:14,980 --> 00:53:19,690
sets a flag to not do anything for a

00:53:17,319 --> 00:53:21,550
number of seconds that's a lot of

00:53:19,690 --> 00:53:24,040
overhead just to say I'm gonna wait a

00:53:21,550 --> 00:53:25,869
few seconds before I check something so

00:53:24,040 --> 00:53:28,510
what can we do to reduce that that

00:53:25,869 --> 00:53:30,730
overhead and one example I said is this

00:53:28,510 --> 00:53:32,740
management verb if I'm running in CPD

00:53:30,730 --> 00:53:34,030
and management ver then it shouldn't

00:53:32,740 --> 00:53:36,040
know anything about the data plane

00:53:34,030 --> 00:53:38,500
events it really should only know about

00:53:36,040 --> 00:53:41,170
management work events so what can we do

00:53:38,500 --> 00:53:44,050
to have some kind of filtering and

00:53:41,170 --> 00:53:48,010
limitation you know that again says ntp

00:53:44,050 --> 00:53:49,720
would only be notified of these dhcp d

00:53:48,010 --> 00:53:51,430
same thing it was doing much more

00:53:49,720 --> 00:53:54,700
processing it registered for all these

00:53:51,430 --> 00:53:56,170
notifications and it was actually as

00:53:54,700 --> 00:53:58,720
Donald was saying it was a sorted linked

00:53:56,170 --> 00:54:01,119
list for inserting these routes for

00:53:58,720 --> 00:54:03,040
example and just a small change in the

00:54:01,119 --> 00:54:05,050
code made a huge change in how much CPU

00:54:03,040 --> 00:54:07,060
was doing didn't really get into

00:54:05,050 --> 00:54:09,819
analyzing what it's doing with those

00:54:07,060 --> 00:54:11,589
routes or addresses or links but point

00:54:09,819 --> 00:54:14,560
being is that you've got multiple demons

00:54:11,589 --> 00:54:15,670
sometimes surprising demons that are

00:54:14,560 --> 00:54:16,960
listening to all these notifications

00:54:15,670 --> 00:54:18,550
from the kernel

00:54:16,960 --> 00:54:20,470
and I think Jamal has some other

00:54:18,550 --> 00:54:25,869
examples later based on what he wants to

00:54:20,470 --> 00:54:29,589
do with filtering the next topic gets

00:54:25,869 --> 00:54:31,089
into querying the kernel so if you think

00:54:29,589 --> 00:54:34,030
of the kernel you know if you if you buy

00:54:31,089 --> 00:54:35,500
into the Linux model where the kernel is

00:54:34,030 --> 00:54:37,660
your source of networking truth

00:54:35,500 --> 00:54:39,130
you've got FRR that takes care of route

00:54:37,660 --> 00:54:41,500
management and it puts routes into the

00:54:39,130 --> 00:54:43,300
kernel you've got I up up down to or

00:54:41,500 --> 00:54:45,550
whatever interface manager it's

00:54:43,300 --> 00:54:48,040
responsible for creating links putting

00:54:45,550 --> 00:54:49,809
addresses on it and then some other

00:54:48,040 --> 00:54:52,930
process maybe it's a monitoring demon

00:54:49,809 --> 00:54:55,210
wants to learn about these things you

00:54:52,930 --> 00:54:57,670
know it can issue these get requests

00:54:55,210 --> 00:55:00,880
with a dump flag set and so it gets

00:54:57,670 --> 00:55:02,800
everything or maybe only wants some

00:55:00,880 --> 00:55:04,569
subset maybe this is a user trying to

00:55:02,800 --> 00:55:07,420
figure out where something didn't went

00:55:04,569 --> 00:55:09,040
wrong and what you don't want to do is

00:55:07,420 --> 00:55:11,140
have this database in the kernel with

00:55:09,040 --> 00:55:13,540
like a million routes or 10,000 links

00:55:11,140 --> 00:55:16,200
and push all that data up to user space

00:55:13,540 --> 00:55:19,089
when it only cares about say each one

00:55:16,200 --> 00:55:21,309
right so that's a lot of wasted cycles

00:55:19,089 --> 00:55:22,990
both on the kernel side pushing all this

00:55:21,309 --> 00:55:25,000
data to user space and the user to face

00:55:22,990 --> 00:55:27,099
going I don't care about this one right

00:55:25,000 --> 00:55:31,450
and if that that dump gets interrupted

00:55:27,099 --> 00:55:33,490
you get start all over again so one

00:55:31,450 --> 00:55:36,430
thing that we can do at this if you know

00:55:33,490 --> 00:55:39,190
for the dump requests is to put some

00:55:36,430 --> 00:55:41,470
filtering so for example you know I

00:55:39,190 --> 00:55:43,660
label this as course filtering for get

00:55:41,470 --> 00:55:45,400
requests which is you know if you

00:55:43,660 --> 00:55:48,130
remember back in that first slide about

00:55:45,400 --> 00:55:50,980
net link messages which is a header with

00:55:48,130 --> 00:55:54,569
a payload and that header has some

00:55:50,980 --> 00:55:57,250
attributes after it so for a get request

00:55:54,569 --> 00:55:57,680
normally you don't have any data after

00:55:57,250 --> 00:55:59,029
it

00:55:57,680 --> 00:56:01,220
but what if we started putting

00:55:59,029 --> 00:56:03,920
attributes behind it so for example when

00:56:01,220 --> 00:56:05,660
I did vrf you know I knew I wasn't I

00:56:03,920 --> 00:56:07,819
didn't want to dump everything about the

00:56:05,660 --> 00:56:09,829
router table or everything about the

00:56:07,819 --> 00:56:12,230
neighbor table so I added an attribute

00:56:09,829 --> 00:56:15,349
to the end of that neighbor dump request

00:56:12,230 --> 00:56:16,970
that said only tell me things associated

00:56:15,349 --> 00:56:19,250
with this master device or the vrf

00:56:16,970 --> 00:56:21,260
device right now I'm only getting

00:56:19,250 --> 00:56:23,390
neighbor entries associated with the

00:56:21,260 --> 00:56:26,270
birth of my interest so that is one way

00:56:23,390 --> 00:56:28,250
to take this huge database and limit it

00:56:26,270 --> 00:56:30,589
down to a smaller subset of things the

00:56:28,250 --> 00:56:33,319
user cares about and there's been some

00:56:30,589 --> 00:56:35,930
other attributes that have been added as

00:56:33,319 --> 00:56:38,990
well so for example with that strict

00:56:35,930 --> 00:56:40,250
checking I was able to do things like if

00:56:38,990 --> 00:56:42,890
you're doing an address dump on an

00:56:40,250 --> 00:56:44,960
interface you know the old way is you

00:56:42,890 --> 00:56:46,670
basically had to do an address dump of

00:56:44,960 --> 00:56:48,470
everything and then come back and

00:56:46,670 --> 00:56:51,559
display to the user just the interface

00:56:48,470 --> 00:56:53,299
in question but now you can say only

00:56:51,559 --> 00:56:55,670
tell me the interface information for

00:56:53,299 --> 00:56:57,740
this one interface right so you've gone

00:56:55,670 --> 00:56:59,119
from dumping everything to just dumping

00:56:57,740 --> 00:57:01,190
the addresses on the interface in

00:56:59,119 --> 00:57:03,140
question right so again this is what I

00:57:01,190 --> 00:57:04,910
call the the coarse-grained filtering

00:57:03,140 --> 00:57:07,339
and it's gonna be a little bit different

00:57:04,910 --> 00:57:10,480
than what then what Jamal let's get into

00:57:07,339 --> 00:57:10,480
what the fine-grained filtering

00:57:11,980 --> 00:57:17,470
I think that was it so any I guess I

00:57:16,119 --> 00:57:19,270
didn't really get into from a time

00:57:17,470 --> 00:57:22,450
perspective I guess I should have

00:57:19,270 --> 00:57:23,829
summarized for the different message

00:57:22,450 --> 00:57:25,869
types with an artsy netlink

00:57:23,829 --> 00:57:27,790
what are the course filtering options

00:57:25,869 --> 00:57:29,560
that exist because you really have to be

00:57:27,790 --> 00:57:32,440
kernel developer going into the code to

00:57:29,560 --> 00:57:34,390
say ah for neighbors I can specify a

00:57:32,440 --> 00:57:36,970
device of interest and a master device

00:57:34,390 --> 00:57:38,920
of interest for FDB I can specify a

00:57:36,970 --> 00:57:40,270
bridge board of interest and a master

00:57:38,920 --> 00:57:42,640
device of interest or you know the

00:57:40,270 --> 00:57:45,520
bridge of interest I guess I should

00:57:42,640 --> 00:57:47,109
create a summary of that that says today

00:57:45,520 --> 00:57:50,410
this is what you can do from a course

00:57:47,109 --> 00:57:52,530
main filtering perspective so any any

00:57:50,410 --> 00:57:52,530
questions

00:57:54,130 --> 00:58:03,130
all right I think Jamal is next moving

00:57:58,430 --> 00:58:03,130
into a lower level filtering

00:58:13,500 --> 00:58:18,690
so

00:58:16,470 --> 00:58:24,380
I was suckered by so many to give this

00:58:18,690 --> 00:58:24,380
talk she did most of the work okay

00:58:34,809 --> 00:58:43,140
right so we want slightly fine-grained

00:58:39,299 --> 00:58:45,789
events notification so we have a

00:58:43,140 --> 00:58:48,039
gazillion of events we receive I don't

00:58:45,789 --> 00:58:50,109
have somebody saw that I give a little

00:58:48,039 --> 00:58:51,939
talk earlier on TCP how we collect a lot

00:58:50,109 --> 00:58:59,109
of TCP netlink

00:58:51,939 --> 00:59:01,599
info but there's a lot of for actions

00:58:59,109 --> 00:59:04,089
for example we have a million actions in

00:59:01,599 --> 00:59:06,459
the kernel running at any one time right

00:59:04,089 --> 00:59:09,130
and they're being actively updated or

00:59:06,459 --> 00:59:12,579
deleted we could change different

00:59:09,130 --> 00:59:15,009
attributes of those and so we receive

00:59:12,579 --> 00:59:17,559
this event so some of the things we do

00:59:15,009 --> 00:59:19,299
is we create a shouting of this netlink

00:59:17,559 --> 00:59:21,609
sockets by creating multiple sockets

00:59:19,299 --> 00:59:26,109
each one of them supposedly listens to

00:59:21,609 --> 00:59:31,029
to one event so that's one way to scale

00:59:26,109 --> 00:59:32,829
is you can add filters per socket and

00:59:31,029 --> 00:59:35,739
have every socket responsible for one

00:59:32,829 --> 00:59:39,189
feature in any case so here's some of

00:59:35,739 --> 00:59:41,279
the things that some of some of them

00:59:39,189 --> 00:59:45,339
apply to so many scares some two hours

00:59:41,279 --> 00:59:49,209
for example the IFA infamous the IFA is

00:59:45,339 --> 00:59:50,469
it IV info when when I add an address of

00:59:49,209 --> 00:59:52,630
the leader and address I get the whole

00:59:50,469 --> 00:59:54,309
thing whether I like it or not but what

00:59:52,630 --> 00:59:57,880
if I could add a filter into the colonel

00:59:54,309 --> 01:00:02,109
say only tell me if address one two

00:59:57,880 --> 01:00:04,089
three four prefix sorry to chain got

01:00:02,109 --> 01:00:06,069
deleted that's it that's all I want to

01:00:04,089 --> 01:00:10,119
know and if only it happens when I I

01:00:06,069 --> 01:00:13,059
have index one another one is I only

01:00:10,119 --> 01:00:15,069
want to see link change events when the

01:00:13,059 --> 01:00:16,269
link goes down in others the North Korea

01:00:15,069 --> 01:00:18,999
flag is set I don't want to hear

01:00:16,269 --> 01:00:21,969
anything else I know that you do admin

01:00:18,999 --> 01:00:23,380
down up you may add a porch immediately

01:00:21,969 --> 01:00:26,349
they all come with the same Artie new

01:00:23,380 --> 01:00:27,909
link or Artie deleted their link I don't

01:00:26,349 --> 01:00:29,890
want to hear because at that level of

01:00:27,909 --> 01:00:32,930
filtering I can I can subscribe to the

01:00:29,890 --> 01:00:34,670
net link broadcast paths and say

01:00:32,930 --> 01:00:36,920
put my hook in there just give me all

01:00:34,670 --> 01:00:41,839
our TMU links and I receive everything

01:00:36,920 --> 01:00:43,880
unconditional right another thing is the

01:00:41,839 --> 01:00:45,950
negation of that right tell me when

01:00:43,880 --> 01:00:49,400
anything else goes down but I have index

01:00:45,950 --> 01:00:52,369
to write that's another fine grain

01:00:49,400 --> 01:00:53,569
filter another one is just tell me when

01:00:52,369 --> 01:00:55,940
the neighbor changes

01:00:53,569 --> 01:00:58,910
don't tell me about new link unless it's

01:00:55,940 --> 01:01:01,759
a new neighbor I'm sorry unless it's the

01:00:58,910 --> 01:01:04,640
following address you can also put some

01:01:01,759 --> 01:01:07,880
thresholds right what if I say only tell

01:01:04,640 --> 01:01:11,569
me when are X bytes for this I findex

01:01:07,880 --> 01:01:14,599
cross ten thousand bytes air or errors

01:01:11,569 --> 01:01:16,849
hit 500 or if you want to be more

01:01:14,599 --> 01:01:19,910
creative before you get an error rate at

01:01:16,849 --> 01:01:22,249
one per second those are very

01:01:19,910 --> 01:01:27,079
fine-grained events filtering right it

01:01:22,249 --> 01:01:28,819
is no way to currently express them same

01:01:27,079 --> 01:01:30,289
thing would get requests other than then

01:01:28,819 --> 01:01:32,450
dump I want to be able to say the same

01:01:30,289 --> 01:01:36,559
thing but what if I want to be more

01:01:32,450 --> 01:01:37,910
creative think of to be honestly what we

01:01:36,559 --> 01:01:40,249
have in the kernel is a database right

01:01:37,910 --> 01:01:42,710
so think of this as a select you're

01:01:40,249 --> 01:01:46,299
doing it get gets a database select

01:01:42,710 --> 01:01:52,400
request look up the FTB and tell me

01:01:46,299 --> 01:01:53,869
where port equals two is zero and this

01:01:52,400 --> 01:01:56,569
address is reachable or something to

01:01:53,869 --> 01:01:59,599
that effect or when the or add another

01:01:56,569 --> 01:02:01,969
select parameter or you can do metal

01:01:59,599 --> 01:02:03,680
conditional things like you know like I

01:02:01,969 --> 01:02:05,630
need to know if the stats changed in the

01:02:03,680 --> 01:02:07,609
last 1 minute don't tell me any other

01:02:05,630 --> 01:02:09,710
time I'm gonna do a get and you only

01:02:07,609 --> 01:02:13,239
give it back to me if it changed in the

01:02:09,710 --> 01:02:13,239
last 1 minute so

01:02:21,619 --> 01:02:27,720
right we recently added a handler for

01:02:25,260 --> 01:02:29,820
that okay but it doesn't have qualifiers

01:02:27,720 --> 01:02:32,340
like reachable or anything it just looks

01:02:29,820 --> 01:02:35,580
up there to be given a MAC address and

01:02:32,340 --> 01:02:38,670
device no so I I think that's that's a

01:02:35,580 --> 01:02:40,500
point I want to talk about because those

01:02:38,670 --> 01:02:42,540
filters sufficient because now you have

01:02:40,500 --> 01:02:44,510
changed the kernel and you've changed

01:02:42,540 --> 01:02:47,190
user space that has to know about this

01:02:44,510 --> 01:02:53,160
right it's good that's the way we've

01:02:47,190 --> 01:02:54,390
been doing things so far well I'll get

01:02:53,160 --> 01:02:57,030
to that point actually it's one of my

01:02:54,390 --> 01:03:00,150
bullets my slides here so what we've

01:02:57,030 --> 01:03:01,980
done so far is used classical BPF right

01:03:00,150 --> 01:03:05,160
you put you right to your simpler code

01:03:01,980 --> 01:03:09,720
you know where things are you've got an

01:03:05,160 --> 01:03:12,000
SK be serialized already yeah you can

01:03:09,720 --> 01:03:13,920
you can you can check and drop as long

01:03:12,000 --> 01:03:15,360
as it's a single message and you didn't

01:03:13,920 --> 01:03:17,640
receive a whole big dump but you want to

01:03:15,360 --> 01:03:21,119
drop something in the middle right then

01:03:17,640 --> 01:03:23,850
it becomes a challenge as long as it's

01:03:21,119 --> 01:03:25,470
not you and even dance sometimes you can

01:03:23,850 --> 01:03:28,890
actually deal with them but you when you

01:03:25,470 --> 01:03:31,040
have something that's nested tlvs which

01:03:28,890 --> 01:03:33,780
may require to write some sort of

01:03:31,040 --> 01:03:36,420
conditions in classical vpf that looks

01:03:33,780 --> 01:03:38,790
like you're iterating a loop it's not

01:03:36,420 --> 01:03:43,680
very good at doing that kind of stuff

01:03:38,790 --> 01:03:45,720
TC actions are an example so just to let

01:03:43,680 --> 01:03:48,750
you know that every TC action comes on

01:03:45,720 --> 01:03:50,640
exactly the same it's also our tmu

01:03:48,750 --> 01:03:52,380
action they have to look at the kind

01:03:50,640 --> 01:03:54,810
attribute and you don't say oh yeah it's

01:03:52,380 --> 01:03:56,340
it's a me right I'm not interested in me

01:03:54,810 --> 01:03:57,280
right or I'm interested in me right it's

01:03:56,340 --> 01:03:59,470
only

01:03:57,280 --> 01:04:01,119
and if you're dumping 1 million entries

01:03:59,470 --> 01:04:03,369
and we're only interested in range 1 to

01:04:01,119 --> 01:04:05,590
5 so we've been adding hacks like that

01:04:03,369 --> 01:04:07,060
where I can pass the ranges now it's

01:04:05,590 --> 01:04:12,730
another filter I've changed user space

01:04:07,060 --> 01:04:14,050
I've changed the kernel yeah so the

01:04:12,730 --> 01:04:16,359
classical example was watch it just

01:04:14,050 --> 01:04:20,380
described and I use David's example here

01:04:16,359 --> 01:04:23,440
where he added the table ID and yes it's

01:04:20,380 --> 01:04:24,820
a nice filter and it was not needed

01:04:23,440 --> 01:04:27,099
before but it was needed now because of

01:04:24,820 --> 01:04:28,990
scale right so I think that was a

01:04:27,099 --> 01:04:32,349
motivation for adding it at the time you

01:04:28,990 --> 01:04:33,790
just wanted just the one table well the

01:04:32,349 --> 01:04:36,550
original motivation was when I was doing

01:04:33,790 --> 01:04:38,950
vrf right okay I didn't want all the

01:04:36,550 --> 01:04:41,710
tables I just wanted the DRF table right

01:04:38,950 --> 01:04:43,480
and I knew from history you know like

01:04:41,710 --> 01:04:46,180
I'd gone into about the if' info message

01:04:43,480 --> 01:04:48,400
header struct being sent that I couldn't

01:04:46,180 --> 01:04:49,930
just go in and set the table ID and they

01:04:48,400 --> 01:04:52,359
don't proquest I knew something much

01:04:49,930 --> 01:04:55,300
more was needed so that was the

01:04:52,359 --> 01:04:57,670
motivation for doing that was from 2015

01:04:55,300 --> 01:04:59,920
I just didn't have the infrastructure in

01:04:57,670 --> 01:05:02,380
place to actually make it happened right

01:04:59,920 --> 01:05:04,450
but again I put this in the high level

01:05:02,380 --> 01:05:07,150
you don't want to have a gazillion if

01:05:04,450 --> 01:05:09,099
checks on every message or every object

01:05:07,150 --> 01:05:10,690
that you're pushing out you really want

01:05:09,099 --> 01:05:13,150
to have this like high level filtering

01:05:10,690 --> 01:05:16,690
and then you know from the aspect of

01:05:13,150 --> 01:05:18,880
sending more attributes in only take it

01:05:16,690 --> 01:05:21,070
from a huge set of data to a smaller set

01:05:18,880 --> 01:05:24,010
of data as opposed to what you're trying

01:05:21,070 --> 01:05:26,109
to go after which is just specific data

01:05:24,010 --> 01:05:29,260
yeah when you have a gazillion of these

01:05:26,109 --> 01:05:30,760
things you really don't want to get all

01:05:29,260 --> 01:05:32,530
of them and then filter in user space

01:05:30,760 --> 01:05:34,359
which is what IP route 2 does right it

01:05:32,530 --> 01:05:36,820
dumps all the ports and say oh yeah it's

01:05:34,359 --> 01:05:40,750
it's zero and get me I have index for

01:05:36,820 --> 01:05:42,430
that guy I've made a few changes but yes

01:05:40,750 --> 01:05:44,650
you're right it does require the kernel

01:05:42,430 --> 01:05:46,420
side support for that and I 3lt who

01:05:44,650 --> 01:05:49,000
falls back to what it does in the past

01:05:46,420 --> 01:05:50,650
which is he gets everything and then has

01:05:49,000 --> 01:05:52,780
the filter that says oh the user didn't

01:05:50,650 --> 01:05:54,520
care about this this is nice but it's a

01:05:52,780 --> 01:05:56,940
lot of wasted cycles all the way around

01:05:54,520 --> 01:05:56,940
yeah

01:05:57,560 --> 01:06:03,599
if this is for dumps though even if you

01:06:00,270 --> 01:06:05,760
do a socket filter it's post forming the

01:06:03,599 --> 01:06:08,130
message so we've gotten lucky over time

01:06:05,760 --> 01:06:11,040
they're filtering that David added is

01:06:08,130 --> 01:06:13,349
more yeah no no I'm saying that that's

01:06:11,040 --> 01:06:14,700
better than the classical BPF but it

01:06:13,349 --> 01:06:17,250
requires for me to go and change the

01:06:14,700 --> 01:06:19,230
kernel code mm-hmm I can support it's

01:06:17,250 --> 01:06:20,520
not backward-compatible and requires for

01:06:19,230 --> 01:06:24,119
me to change the user space code that

01:06:20,520 --> 01:06:26,369
knows how to set these attributes right

01:06:24,119 --> 01:06:28,349
with class code BPF oh if I can get away

01:06:26,369 --> 01:06:30,119
with it I just write a small filter that

01:06:28,349 --> 01:06:32,670
I put in the socket and it filters for

01:06:30,119 --> 01:06:34,320
me right I think they want that we use

01:06:32,670 --> 01:06:36,480
the most is to look at the kind field

01:06:34,320 --> 01:06:43,830
and drop when we're scaring the actions

01:06:36,480 --> 01:06:45,359
sure it's always post so you might have

01:06:43,830 --> 01:06:49,230
a million entries I was only interested

01:06:45,359 --> 01:06:51,060
in fourth and it's a loop right and it's

01:06:49,230 --> 01:06:53,220
the message is a partial so it's

01:06:51,060 --> 01:06:54,359
whatever fills up the socket I have to

01:06:53,220 --> 01:06:55,740
filter that and I have to maintain

01:06:54,359 --> 01:06:58,200
current of state oh yeah there's more

01:06:55,740 --> 01:06:59,609
coming look at the end right until I see

01:06:58,200 --> 01:07:03,000
another message done I know it's not

01:06:59,609 --> 01:07:04,500
over yet and try to do LMS H down in net

01:07:03,000 --> 01:07:06,570
I think you yeah what plus could be PF

01:07:04,500 --> 01:07:10,940
it's not a problem in a message down is

01:07:06,570 --> 01:07:10,940
a message type in Nano message header so

01:07:11,320 --> 01:07:19,030
okay so the goal was okay this is the

01:07:15,370 --> 01:07:22,870
patches that came from so many at the

01:07:19,030 --> 01:07:26,830
time and say okay can we do something in

01:07:22,870 --> 01:07:28,750
the middle right could we do what we

01:07:26,830 --> 01:07:31,300
call the hybrid mode so our goal is to

01:07:28,750 --> 01:07:33,580
have no kernel changes can we add these

01:07:31,300 --> 01:07:35,860
select code encode features without

01:07:33,580 --> 01:07:37,870
making any kernel changes so in the

01:07:35,860 --> 01:07:39,130
future I want to do something that I'm

01:07:37,870 --> 01:07:41,020
only interested in I don't want to push

01:07:39,130 --> 01:07:43,600
it to the kernel because it makes no

01:07:41,020 --> 01:07:45,280
sense if I want to filter based on some

01:07:43,600 --> 01:07:47,110
crazy attribute that nobody else is

01:07:45,280 --> 01:07:50,230
interested in

01:07:47,110 --> 01:07:53,520
could we so that's that's what our goal

01:07:50,230 --> 01:07:56,620
was right can we put a generic enough

01:07:53,520 --> 01:07:58,510
description in the get request so that

01:07:56,620 --> 01:08:00,700
when it either it's the table the dump

01:07:58,510 --> 01:08:03,340
is dumping it's gonna be able to run my

01:08:00,700 --> 01:08:06,490
execute my select message if you want to

01:08:03,340 --> 01:08:07,840
call it that and not I don't have to

01:08:06,490 --> 01:08:09,340
change the kind of back that that is the

01:08:07,840 --> 01:08:11,980
ultimate goal if we can get away with it

01:08:09,340 --> 01:08:13,540
so so many introduced this patch in that

01:08:11,980 --> 01:08:17,410
archive that's what started our

01:08:13,540 --> 01:08:19,540
discussion at the time but again it it's

01:08:17,410 --> 01:08:23,260
it it kind of worked

01:08:19,540 --> 01:08:24,700
am I correct it kind of worked and but

01:08:23,260 --> 01:08:26,440
it was horrible it's like you have to

01:08:24,700 --> 01:08:28,270
deal with memory management you have to

01:08:26,440 --> 01:08:29,740
pick put a little point over here oh

01:08:28,270 --> 01:08:33,430
yeah she let me go backwards a little

01:08:29,740 --> 01:08:37,150
bit it was it worked but it's not

01:08:33,430 --> 01:08:38,680
something to you know to try and push

01:08:37,150 --> 01:08:39,940
into the camera right but it started a

01:08:38,680 --> 01:08:42,480
discussion that's why we're here today

01:08:39,940 --> 01:08:45,850
right so there's a horrible skb

01:08:42,480 --> 01:08:47,650
manipulation games and it doesn't play

01:08:45,850 --> 01:08:51,290
well with events because again events

01:08:47,650 --> 01:08:53,280
could be across many many messages right

01:08:51,290 --> 01:08:55,050
so the idea of that you have to

01:08:53,280 --> 01:08:57,150
serialize the data structure into an

01:08:55,050 --> 01:08:58,890
esky into something that's it's a stream

01:08:57,150 --> 01:09:01,080
and then you have to poke into the

01:08:58,890 --> 01:09:02,610
stream and know where everything is and

01:09:01,080 --> 01:09:04,530
then decide you want to drop half of

01:09:02,610 --> 01:09:06,900
that stream but the other continues to

01:09:04,530 --> 01:09:12,870
work just as well as before while doable

01:09:06,900 --> 01:09:15,210
it's a little bit of acrobatics so these

01:09:12,870 --> 01:09:18,180
are some numbers - it's just a selling

01:09:15,210 --> 01:09:20,700
point I to show that there is value in

01:09:18,180 --> 01:09:26,790
this this experiment was run by by so

01:09:20,700 --> 01:09:28,290
many it shows that she had 200,000 BF DB

01:09:26,790 --> 01:09:31,740
is in there there's some crazy stuff

01:09:28,290 --> 01:09:33,210
that is going on and she just want and

01:09:31,740 --> 01:09:34,830
she was able to reduce the call the

01:09:33,210 --> 01:09:37,400
system calls going into the kernel by

01:09:34,830 --> 01:09:40,530
pushing the filter in this hybrid mode

01:09:37,400 --> 01:09:42,690
by sending the gate and doing a filter

01:09:40,530 --> 01:09:48,540
along with it that was class was

01:09:42,690 --> 01:09:51,660
classical vpf from 364 system calls to -

01:09:48,540 --> 01:09:53,940
right so you it doesn't quite show in

01:09:51,660 --> 01:09:55,620
the number of CPU cycles there but you

01:09:53,940 --> 01:10:01,890
know you've got we went from 364

01:09:55,620 --> 01:10:05,370
messages to 2 right so but of course you

01:10:01,890 --> 01:10:07,560
can't ignore the when you want to do

01:10:05,370 --> 01:10:12,030
non-trivial stuff CBF just doesn't cut

01:10:07,560 --> 01:10:13,790
it ok so here's a suggestion that kind

01:10:12,030 --> 01:10:17,370
of came up in that email discussion

01:10:13,790 --> 01:10:19,770
right what if we could make the field

01:10:17,370 --> 01:10:21,420
info everybody has a fill info when they

01:10:19,770 --> 01:10:26,700
want to generate an event or they want

01:10:21,420 --> 01:10:28,320
to generate a dump they call fill in for

01:10:26,700 --> 01:10:30,690
which fills your headers and then it you

01:10:28,320 --> 01:10:33,220
send it messages and it keeps creating

01:10:30,690 --> 01:10:35,760
the the skb stream for you

01:10:33,220 --> 01:10:40,300
what if we could put a eb PF hook there

01:10:35,760 --> 01:10:44,620
i'm gonna be a fanboy as well so and

01:10:40,300 --> 01:10:50,500
then this IPPF callback would invoke

01:10:44,620 --> 01:10:52,260
your own propriety eb PF code that you

01:10:50,500 --> 01:10:56,560
passed in a get request for example

01:10:52,260 --> 01:10:59,380
right then the callback will says called

01:10:56,560 --> 01:11:01,540
the b PF code just like what the tcp BPF

01:10:59,380 --> 01:11:03,430
does and it gets a return code you say

01:11:01,540 --> 01:11:06,820
yeah yeah this this guy this message is

01:11:03,430 --> 01:11:11,890
good you can append it to the sk b so

01:11:06,820 --> 01:11:14,530
that's the general suggestions of course

01:11:11,890 --> 01:11:17,050
this there's a lot of issues of this

01:11:14,530 --> 01:11:20,890
because now i have to we have to go and

01:11:17,050 --> 01:11:22,620
inspect every spot where feel info is

01:11:20,890 --> 01:11:25,750
being invoked maybe we need a call back

01:11:22,620 --> 01:11:29,200
and in some sort of ops structure there

01:11:25,750 --> 01:11:34,330
that now is going to call if the user

01:11:29,200 --> 01:11:36,760
has a BBF program along with a get then

01:11:34,330 --> 01:11:37,840
it will be invoked and it returns

01:11:36,760 --> 01:11:38,950
something and then you could either

01:11:37,840 --> 01:11:41,500
continue depending on what the results

01:11:38,950 --> 01:11:44,590
are right so this is the kind of trick

01:11:41,500 --> 01:11:47,200
that tcp eb PF does and it has worked

01:11:44,590 --> 01:11:48,850
very well for them right you you get

01:11:47,200 --> 01:11:50,350
messages and you can choose to do

01:11:48,850 --> 01:11:54,670
something about them or just return a

01:11:50,350 --> 01:11:56,260
call say continue right this is just

01:11:54,670 --> 01:11:56,800
back up slide there's nothing that's it

01:11:56,260 --> 01:11:59,260
for me

01:11:56,800 --> 01:12:00,400
so to get into I guess the details I

01:11:59,260 --> 01:12:02,740
think I mentioned this to you

01:12:00,400 --> 01:12:03,610
so yesterday I've lost track of time

01:12:02,740 --> 01:12:06,520
right

01:12:03,610 --> 01:12:10,150
one of the problems with doing EPP f eb

01:12:06,520 --> 01:12:11,860
PF processing on like the fill infos you

01:12:10,150 --> 01:12:13,930
don't have a single data structure that

01:12:11,860 --> 01:12:16,060
you can operate on so it's not like you

01:12:13,930 --> 01:12:18,190
can say here's a signature for your

01:12:16,060 --> 01:12:20,320
context right because you're pulling

01:12:18,190 --> 01:12:21,610
information from all over the place for

01:12:20,320 --> 01:12:23,380
example you're pulling information out

01:12:21,610 --> 01:12:24,760
of the device structure you're pulling

01:12:23,380 --> 01:12:25,810
information out of film structures

01:12:24,760 --> 01:12:28,300
you're pulling information about

01:12:25,810 --> 01:12:30,430
neighbor structures and in some cases

01:12:28,300 --> 01:12:33,409
and i got brought up the management very

01:12:30,430 --> 01:12:36,380
maybe i want even derived information

01:12:33,409 --> 01:12:38,030
so again I only want information this

01:12:36,380 --> 01:12:39,949
process only wants information related

01:12:38,030 --> 01:12:42,260
to management perf which then that's a

01:12:39,949 --> 01:12:44,659
master device the property of a device I

01:12:42,260 --> 01:12:46,909
think that if we if this is a good idea

01:12:44,659 --> 01:12:48,770
if people agree it's a good idea then we

01:12:46,909 --> 01:12:51,230
will have to write what one would call

01:12:48,770 --> 01:12:53,150
EBP F help us they'll be this structures

01:12:51,230 --> 01:12:56,330
will be visible to you BPF all that I've

01:12:53,150 --> 01:12:59,270
seen for IFA yeah it's my remit is that

01:12:56,330 --> 01:13:01,130
it's not just the the hooks and the

01:12:59,270 --> 01:13:02,989
helpers I have to go in you've got to

01:13:01,130 --> 01:13:05,870
create the data structure itself that

01:13:02,989 --> 01:13:07,850
the EPF code operates on that's right so

01:13:05,870 --> 01:13:11,420
I'm saying it's equivalent to the fake

01:13:07,850 --> 01:13:13,850
SK be that a BPF has access to copies

01:13:11,420 --> 01:13:16,130
fields from the SK be you'll need one

01:13:13,850 --> 01:13:18,560
for the link for the route for

01:13:16,130 --> 01:13:20,239
everything yeah under the net link world

01:13:18,560 --> 01:13:22,040
right you'll need one like that well and

01:13:20,239 --> 01:13:24,139
then there's two different classes of

01:13:22,040 --> 01:13:26,659
problems here one is the get request

01:13:24,139 --> 01:13:28,610
where you're you send a request into the

01:13:26,659 --> 01:13:30,380
kernel asking for something and the

01:13:28,610 --> 01:13:31,850
other one is the notifications yeah the

01:13:30,380 --> 01:13:33,710
notification is like that's a much

01:13:31,850 --> 01:13:35,929
harder problem because it's not directly

01:13:33,710 --> 01:13:37,699
connected to a process you're correct

01:13:35,929 --> 01:13:39,560
about that so it will have to be because

01:13:37,699 --> 01:13:41,840
they and they may be a thousand users

01:13:39,560 --> 01:13:44,320
trying to listen to the same event and

01:13:41,840 --> 01:13:48,350
you'll have to deal with all of them for

01:13:44,320 --> 01:13:49,909
how the gate one is is easy to see you

01:13:48,350 --> 01:13:52,550
have to feel all they feel info sure

01:13:49,909 --> 01:13:54,679
events also useful info right the

01:13:52,550 --> 01:13:57,350
question is which of these filters do

01:13:54,679 --> 01:13:59,600
you use right do you use the filter that

01:13:57,350 --> 01:14:03,290
was inserted by one user or not there

01:13:59,600 --> 01:14:05,960
may be a way where this EBP f-code could

01:14:03,290 --> 01:14:07,580
be inserted in place or somewhere close

01:14:05,960 --> 01:14:10,130
to where the classical BPF code is

01:14:07,580 --> 01:14:12,820
invoked right now you you set it and you

01:14:10,130 --> 01:14:15,260
put it there and then it gets invoked

01:14:12,820 --> 01:14:18,469
when even feel employees being

01:14:15,260 --> 01:14:20,239
yeah the classical BPF is run when it's

01:14:18,469 --> 01:14:23,159
getting attached to the socket as

01:14:20,239 --> 01:14:25,800
opposed to right so I

01:14:23,159 --> 01:14:28,469
before generation of the skb right so

01:14:25,800 --> 01:14:30,360
yes it has to work on the on the data

01:14:28,469 --> 01:14:33,150
structures and it requires a lot of work

01:14:30,360 --> 01:14:34,860
a lot of mechanical work I would say

01:14:33,150 --> 01:14:35,969
once the first one is done I think the

01:14:34,860 --> 01:14:38,400
rest of them will you can just copy

01:14:35,969 --> 01:14:40,110
verbatim and of course there's

01:14:38,400 --> 01:14:42,119
maintenance involved afterwards what if

01:14:40,110 --> 01:14:47,010
a new field gets added that now I have

01:14:42,119 --> 01:14:48,809
to update EBP F so you can help or

01:14:47,010 --> 01:14:50,610
argument which is needing colonel site

01:14:48,809 --> 01:14:54,599
changes as well as user space changes

01:14:50,610 --> 01:14:57,479
right but in this case the colonel site

01:14:54,599 --> 01:14:59,280
changes are probably done once in theory

01:14:57,479 --> 01:15:01,829
unless you change the data structure you

01:14:59,280 --> 01:15:03,900
don't have to add and I have index into

01:15:01,829 --> 01:15:05,489
this new I have info message that used

01:15:03,900 --> 01:15:08,070
to be 0 now you are setting it to mean

01:15:05,489 --> 01:15:10,229
something that that is the structure

01:15:08,070 --> 01:15:14,459
existed array is just now the messaging

01:15:10,229 --> 01:15:17,369
is changed right yeah it's certainly an

01:15:14,459 --> 01:15:20,429
intriguing need to be able to say like

01:15:17,369 --> 01:15:22,939
querying a database I only want specific

01:15:20,429 --> 01:15:25,979
information right yet I do not

01:15:22,939 --> 01:15:29,269
hard-coded specific information this is

01:15:25,979 --> 01:15:31,679
a big pain point right we have a lot of

01:15:29,269 --> 01:15:35,400
someone with a few hundred messages may

01:15:31,679 --> 01:15:38,880
not care but we care about scale so

01:15:35,400 --> 01:15:40,919
that's why this is important now there

01:15:38,880 --> 01:15:42,709
may be other ideas this is EVP F I don't

01:15:40,919 --> 01:15:44,789
I still have three minutes anybody else

01:15:42,709 --> 01:15:50,159
has a different way of solving this

01:15:44,789 --> 01:15:53,729
problem I'll be happy to anybody wants

01:15:50,159 --> 01:15:55,229
to run low in the kernel anyone have any

01:15:53,729 --> 01:15:56,900
other suggestions for a kind of

01:15:55,229 --> 01:16:00,760
filtering that's needed

01:15:56,900 --> 01:16:02,989
kind of add on to this this need right

01:16:00,760 --> 01:16:05,290
anybody else thinks this is a useful

01:16:02,989 --> 01:16:08,920
problem to solve

01:16:05,290 --> 01:16:13,090
is anyone else awake

01:16:08,920 --> 01:16:15,889
florian says it's a good problem okay

01:16:13,090 --> 01:16:17,719
alright so I have two minutes I can

01:16:15,889 --> 01:16:19,489
still take I can take questions or you

01:16:17,719 --> 01:16:20,840
know your backup side tomato you're not

01:16:19,489 --> 01:16:25,190
allowed to throw tomatoes you can just

01:16:20,840 --> 01:16:26,989
say nice things to me that's it okay

01:16:25,190 --> 01:16:29,790
that's all right

01:16:26,989 --> 01:16:34,540
Thanks thank you mama

01:16:29,790 --> 01:16:34,540
[Applause]

01:16:36,809 --> 01:16:39,809
Jerry

01:16:52,150 --> 01:16:58,490
yeah so I'm going to tell you something

01:16:56,000 --> 01:17:01,340
about telling nothing netlink issues

01:16:58,490 --> 01:17:04,100
that turns out that lot of these issues

01:17:01,340 --> 01:17:07,340
are overlapping with the issues which

01:17:04,100 --> 01:17:08,210
are which were described already how

01:17:07,340 --> 01:17:13,600
does this work

01:17:08,210 --> 01:17:13,600
but top green

01:17:15,040 --> 01:17:21,200
okay too big to see actually okay so

01:17:19,040 --> 01:17:25,130
what is the link I will just tell you

01:17:21,200 --> 01:17:28,360
something about it how many of you raise

01:17:25,130 --> 01:17:33,950
your hand if you know what deviling is

01:17:28,360 --> 01:17:37,220
okay alright so basically it was

01:17:33,950 --> 01:17:43,010
introduced to model the Asics in more

01:17:37,220 --> 01:17:47,420
accurate way so in in typical nake you

01:17:43,010 --> 01:17:51,350
have one port and you have ETA zero for

01:17:47,420 --> 01:17:53,900
that that's like the standard model but

01:17:51,350 --> 01:17:57,950
there are Nick's which have more ports

01:17:53,900 --> 01:18:00,470
but it is one single basic so in that

01:17:57,950 --> 01:18:03,440
case it doesn't really make sense and

01:18:00,470 --> 01:18:06,110
this is one of the examples if you want

01:18:03,440 --> 01:18:09,500
to flash firmware on this ASIC you have

01:18:06,110 --> 01:18:12,950
to net devices and you you basically you

01:18:09,500 --> 01:18:16,190
used ETH to minus F for one of those net

01:18:12,950 --> 01:18:17,870
devices it's kind of weird because when

01:18:16,190 --> 01:18:20,210
you flash one of the one of the net

01:18:17,870 --> 01:18:24,500
devices you are actually flashing both

01:18:20,210 --> 01:18:26,780
because it's single ASIC so for that for

01:18:24,500 --> 01:18:31,670
this for that purpose and for a lot of

01:18:26,780 --> 01:18:34,340
other similar purposes it was deviling

01:18:31,670 --> 01:18:39,200
introduced to to model the entity of the

01:18:34,340 --> 01:18:41,360
whole ASIC and then you have another

01:18:39,200 --> 01:18:44,140
entities there like objects which one of

01:18:41,360 --> 01:18:48,770
those is deviling port which handles

01:18:44,140 --> 01:18:51,890
physical or internal port of the ASIC by

01:18:48,770 --> 01:18:55,700
internal I mean if you have like SRV you

01:18:51,890 --> 01:19:00,170
switch it has for each virtual function

01:18:55,700 --> 01:19:04,520
you have one port of embedded switch

01:19:00,170 --> 01:19:10,760
and so devil Inc uses generic netlink

01:19:04,520 --> 01:19:14,950
now we have about 38 do it commands you

01:19:10,760 --> 01:19:19,220
can you can see it and basically it's

01:19:14,950 --> 01:19:26,240
what it does is most of those commands

01:19:19,220 --> 01:19:28,670
are for working with the ports setting

01:19:26,240 --> 01:19:33,290
some parameters working with chair

01:19:28,670 --> 01:19:35,990
buffer V pipe and recently there was

01:19:33,290 --> 01:19:38,690
health mechanism introduced as well

01:19:35,990 --> 01:19:42,920
there is a presentation about health I

01:19:38,690 --> 01:19:47,600
think tomorrow I would recommend that we

01:19:42,920 --> 01:19:51,410
have twelve twelve of those commands

01:19:47,600 --> 01:19:54,680
support dump it so you actually can dump

01:19:51,410 --> 01:19:57,460
the whole database and I would talk a

01:19:54,680 --> 01:20:03,380
little bit more about dump it later on

01:19:57,460 --> 01:20:05,870
so so here's something which was kind of

01:20:03,380 --> 01:20:09,740
inherited from the previous

01:20:05,870 --> 01:20:11,780
implementation of not link there is no

01:20:09,740 --> 01:20:14,540
one to one mapping between commands and

01:20:11,780 --> 01:20:18,080
notifications although it's somehow

01:20:14,540 --> 01:20:21,950
related so for example notifications are

01:20:18,080 --> 01:20:24,350
named she has the word CMD in them

01:20:21,950 --> 01:20:28,340
because they have kind of related with

01:20:24,350 --> 01:20:32,210
the command which generated the

01:20:28,340 --> 01:20:35,600
notification but also there might be

01:20:32,210 --> 01:20:37,760
there are some notifications which are

01:20:35,600 --> 01:20:41,330
not generated by a command for example

01:20:37,760 --> 01:20:44,450
if port appears in the system it is not

01:20:41,330 --> 01:20:46,380
generated by any command but still the

01:20:44,450 --> 01:20:50,369
notification

01:20:46,380 --> 01:20:54,090
you know has CMD in that so it's kind of

01:20:50,369 --> 01:21:00,440
confusing it's it's like it works like

01:20:54,090 --> 01:21:04,050
that in most of the netlink api's it's

01:21:00,440 --> 01:21:07,499
it's confusing so I'm just I'm just

01:21:04,050 --> 01:21:11,369
throwing it in to tonight mean out maybe

01:21:07,499 --> 01:21:15,059
for food for the future API we can do it

01:21:11,369 --> 01:21:20,400
better but I think it's mostly because

01:21:15,059 --> 01:21:23,969
as they describe the four messages types

01:21:20,400 --> 01:21:34,010
like you get so it's probably because of

01:21:23,969 --> 01:21:40,829
that okay yeah the underscore new

01:21:34,010 --> 01:21:43,409
command you get that when you you get

01:21:40,829 --> 01:21:47,880
that but the notification by that name

01:21:43,409 --> 01:21:51,840
you get when the object is created and

01:21:47,880 --> 01:21:54,659
also when it is updated and in user

01:21:51,840 --> 01:21:59,780
space you really have no way to tell

01:21:54,659 --> 01:22:02,780
which event happened so it's not really

01:21:59,780 --> 01:22:02,780
probably

01:22:02,960 --> 01:22:07,790
yep maybe

01:22:13,239 --> 01:22:18,949
the application might not be listening

01:22:16,610 --> 01:22:21,080
to the create message read it started a

01:22:18,949 --> 01:22:22,969
soft created socket later and it just

01:22:21,080 --> 01:22:25,190
gets the new message so I think a flag

01:22:22,969 --> 01:22:26,659
is possibly probably the only option I

01:22:25,190 --> 01:22:30,110
do but where you put the flag it's

01:22:26,659 --> 01:22:35,000
another attribute I don't know the

01:22:30,110 --> 01:22:36,710
header we don't have anymore yeah yeah

01:22:35,000 --> 01:22:42,260
so yeah it's it's all above it's it's

01:22:36,710 --> 01:22:46,699
just not sure how and yeah the last

01:22:42,260 --> 01:22:51,159
thing on the slide I put it if you look

01:22:46,699 --> 01:22:56,239
at these issues then nothing at the face

01:22:51,159 --> 01:22:58,820
is too much flexible so it allows people

01:22:56,239 --> 01:23:02,389
who are implementing API using it to do

01:22:58,820 --> 01:23:06,889
mass basically so maybe it would be good

01:23:02,389 --> 01:23:09,080
to have like Tyra model to tie the

01:23:06,889 --> 01:23:11,929
commands and notifications together

01:23:09,080 --> 01:23:13,760
somehow when you define the interface

01:23:11,929 --> 01:23:15,889
but it's too late for that

01:23:13,760 --> 01:23:17,330
I know but putting that into the lessons

01:23:15,889 --> 01:23:25,900
learned and things you do better as a

01:23:17,330 --> 01:23:25,900
forward ok let's do 30 boots it's it's

01:23:26,750 --> 01:23:34,820
in deviling in devil Inc we have all the

01:23:31,850 --> 01:23:38,090
attributes which are used by by deviling

01:23:34,820 --> 01:23:40,969
it it's one big enum so the question is

01:23:38,090 --> 01:23:43,120
do we want to have it in one big enum or

01:23:40,969 --> 01:23:49,400
do we want to have separate enums four

01:23:43,120 --> 01:23:51,020
four four separate nests I think that

01:23:49,400 --> 01:23:54,620
Wireless guys are doing it in the same

01:23:51,020 --> 01:23:57,260
way I do not link implementations as I

01:23:54,620 --> 01:24:04,040
do are having a separate enum for for

01:23:57,260 --> 01:24:07,130
each it's kind of confusing as well well

01:24:04,040 --> 01:24:10,430
you know you are doing nasty nesting

01:24:07,130 --> 01:24:13,250
but you are using one namespace of

01:24:10,430 --> 01:24:17,690
attributes basically the top level was

01:24:13,250 --> 01:24:20,630
just just it's just numbers right just

01:24:17,690 --> 01:24:22,790
numbers so you are using you are you

01:24:20,630 --> 01:24:24,110
either have multiple in arms and for

01:24:22,790 --> 01:24:27,830
each nest you have four separate

01:24:24,110 --> 01:24:30,520
britannia's or like like what we do in

01:24:27,830 --> 01:24:35,690
that link you have one big enum for all

01:24:30,520 --> 01:24:37,820
it's good that the same attribute if you

01:24:35,690 --> 01:24:41,540
use it in multiple messages or multiple

01:24:37,820 --> 01:24:44,870
nests you can use the same that's pro

01:24:41,540 --> 01:24:50,360
but cone is it's kind of messy to have

01:24:44,870 --> 01:24:53,150
everything out there do what is so not

01:24:50,360 --> 01:24:56,150
sure it's it's another thing when the

01:24:53,150 --> 01:25:02,390
flexibility it's kind of not good

01:24:56,150 --> 01:25:04,550
because if you if you are you used to do

01:25:02,390 --> 01:25:09,320
something in one subsystem and you go to

01:25:04,550 --> 01:25:13,730
other one you are so I think nesting art

01:25:09,320 --> 01:25:16,250
innately usually NASA better right VMs

01:25:13,730 --> 01:25:18,890
are supported there in some cases

01:25:16,250 --> 01:25:21,620
duplicated because of that yeah exactly

01:25:18,890 --> 01:25:23,630
so yeah another thing I wanted to talk

01:25:21,620 --> 01:25:25,460
about this SKB spill I call it this

01:25:23,630 --> 01:25:26,360
could be split so basically you have

01:25:25,460 --> 01:25:31,280
like

01:25:26,360 --> 01:25:34,760
two columns and the the each rectangle

01:25:31,280 --> 01:25:38,180
represents a skb and each green

01:25:34,760 --> 01:25:41,020
rectangle represents one attribute so

01:25:38,180 --> 01:25:46,340
you can see it's the nice thing it goes

01:25:41,020 --> 01:25:48,770
level on the each row God gets another

01:25:46,340 --> 01:25:53,530
nest and then it goes back so the

01:25:48,770 --> 01:25:57,590
problem is that the nest has to be ended

01:25:53,530 --> 01:26:01,010
in by the skb so it cannot you cannot

01:25:57,590 --> 01:26:03,140
open a nest and finish the skb go to

01:26:01,010 --> 01:26:06,230
another Skippy and then to close the

01:26:03,140 --> 01:26:09,380
nest there and so if you have like big

01:26:06,230 --> 01:26:13,820
dumps and which cannot fill into one skb

01:26:09,380 --> 01:26:18,500
you have to somehow resolve it so what

01:26:13,820 --> 01:26:20,570
we did in in a message it's formatted

01:26:18,500 --> 01:26:23,180
message or something like that in that

01:26:20,570 --> 01:26:26,510
link we just introduced custom

01:26:23,180 --> 01:26:29,390
attributes to actually do this kind of

01:26:26,510 --> 01:26:31,640
nesting it's it's custom nesting

01:26:29,390 --> 01:26:34,670
basically Sonique Jamal's got a comment

01:26:31,640 --> 01:26:36,320
on that yeah I mean maybe you shouldn't

01:26:34,670 --> 01:26:37,640
send that message if you don't have

01:26:36,320 --> 01:26:41,930
enough socket buffer is that what the

01:26:37,640 --> 01:26:44,900
problem is you're fragmenting it for

01:26:41,930 --> 01:26:47,270
cases can be you cannot put all the data

01:26:44,900 --> 01:26:50,260
into one for case can be right you

01:26:47,270 --> 01:26:54,650
didn't you then just make it 8 K or 16 K

01:26:50,260 --> 01:26:56,000
yeah but at 64 and I swear there was

01:26:54,650 --> 01:26:58,880
somebody recently that was saying I

01:26:56,000 --> 01:27:00,740
can't fit it all into one because

01:26:58,880 --> 01:27:02,810
because netlink is a messaging right it

01:27:00,740 --> 01:27:04,760
has message boundaries it's not really

01:27:02,810 --> 01:27:07,490
streaming like the way tcp would way

01:27:04,760 --> 01:27:09,500
okay I'm still waiting yeah but why not

01:27:07,490 --> 01:27:11,810
I mean you can have like very big dump

01:27:09,500 --> 01:27:12,919
which which you want to maintain the

01:27:11,810 --> 01:27:16,280
nesting

01:27:12,919 --> 01:27:18,530
like look at it as big Jason of some

01:27:16,280 --> 01:27:20,809
formative data or something some big

01:27:18,530 --> 01:27:23,780
user space waits until everything is

01:27:20,809 --> 01:27:25,459
there before it interprets it yeah so

01:27:23,780 --> 01:27:30,649
returning little akin to a streaming

01:27:25,459 --> 01:27:33,380
product in endeavoring health mechanism

01:27:30,649 --> 01:27:37,249
yeah for dumping the deformer yeah

01:27:33,380 --> 01:27:38,689
because I go through like even the IPM

01:27:37,249 --> 01:27:42,739
are I don't think they're nesting

01:27:38,689 --> 01:27:46,039
continues on multiple escapees right

01:27:42,739 --> 01:27:48,079
it's just entries you have to you have

01:27:46,039 --> 01:27:51,050
to still end the nest until you open

01:27:48,079 --> 01:27:55,610
another one in another skb there is also

01:27:51,050 --> 01:27:58,249
one example which is already causing

01:27:55,610 --> 01:28:01,070
some trouble and is probably going to

01:27:58,249 --> 01:28:05,599
cause much more trouble very soon which

01:28:01,070 --> 01:28:07,010
is the IFLA VF in Felicity attribute

01:28:05,599 --> 01:28:10,010
which is nested attribute so it's

01:28:07,010 --> 01:28:13,130
limited to 64 kilobytes yeah but even

01:28:10,010 --> 01:28:18,649
now we are really getting close to that

01:28:13,130 --> 01:28:22,099
with something like 250 if you have an

01:28:18,649 --> 01:28:25,909
one interface hit that limit like 64 we

01:28:22,099 --> 01:28:28,849
are close to death when I counted it

01:28:25,909 --> 01:28:36,619
this it was something like you would

01:28:28,849 --> 01:28:37,820
need something like 270 bf I think

01:28:36,619 --> 01:28:39,349
that's a real problem

01:28:37,820 --> 01:28:41,630
yeah and it's already caused a problem

01:28:39,349 --> 01:28:43,540
because we have very big messages which

01:28:41,630 --> 01:28:48,070
is causing trouble in IP route 2

01:28:43,540 --> 01:28:51,450
yeah yeah I can see how that is Riv case

01:28:48,070 --> 01:28:57,570
so we can say that it's a bad design

01:28:51,450 --> 01:29:00,460
designed badly designed but do we have

01:28:57,570 --> 01:29:03,550
the issue is you can't fit something in

01:29:00,460 --> 01:29:07,060
a TLV you only have 64 K what is that

01:29:03,550 --> 01:29:11,280
the length is 16 bits the message is

01:29:07,060 --> 01:29:11,280
much bigger than 16 bits can hold inside

01:29:16,060 --> 01:29:20,650
a message can be bigger than 64

01:29:18,670 --> 01:29:23,280
kilobytes right unless did a tribute

01:29:20,650 --> 01:29:26,170
because a tribute size is 16 bit number

01:29:23,280 --> 01:29:27,610
right but in other words if you have a

01:29:26,170 --> 01:29:29,230
table with a million entries we don't

01:29:27,610 --> 01:29:30,850
have this problem today they're nested

01:29:29,230 --> 01:29:34,750
but I just keep sending them in chunks

01:29:30,850 --> 01:29:40,090
until they get there but with many

01:29:34,750 --> 01:29:44,199
attributes in it this is you're talking

01:29:40,090 --> 01:29:47,790
about this arrow s r io v if someone

01:29:44,199 --> 01:29:47,790
thought they'll never be more than 63

01:29:58,409 --> 01:30:04,449
solution again I'm sorry maybe maybe it

01:30:00,580 --> 01:30:12,070
makes sense now okay so it's another

01:30:04,449 --> 01:30:17,260
thing which was briefly discussed so

01:30:12,070 --> 01:30:20,290
this yeah silent ignore of the kernel

01:30:17,260 --> 01:30:23,949
that was discussed I think that maybe it

01:30:20,290 --> 01:30:25,989
would be good to at least have like an

01:30:23,949 --> 01:30:29,440
egg stack or something which would the

01:30:25,989 --> 01:30:31,600
colonel would say I got some attributes

01:30:29,440 --> 01:30:33,909
which I didn't understand like the

01:30:31,600 --> 01:30:35,380
message will be okay but I have this

01:30:33,909 --> 01:30:37,750
attributes which are denounced at least

01:30:35,380 --> 01:30:40,480
I don't know it's I also like to fail

01:30:37,750 --> 01:30:42,190
but you know it's it's the notion that

01:30:40,480 --> 01:30:44,739
the wrong thing was was implemented

01:30:42,190 --> 01:30:47,050
maybe this would work this would helped

01:30:44,739 --> 01:30:51,040
a little bit but it's certainly better

01:30:47,050 --> 01:30:53,679
than silent ignore okay it might be

01:30:51,040 --> 01:30:57,250
tricky with nesting to actually pinpoint

01:30:53,679 --> 01:30:59,380
all the attributes which failed strict

01:30:57,250 --> 01:31:01,570
checking you do that for New Yorker

01:30:59,380 --> 01:31:03,760
only for the dumps get or get requests

01:31:01,570 --> 01:31:11,680
soon strict checking is strictly limited

01:31:03,760 --> 01:31:13,930
to get a request to the world in a day

01:31:11,680 --> 01:31:15,580
actually I like also so this is an

01:31:13,930 --> 01:31:18,430
extension to what David had said earlier

01:31:15,580 --> 01:31:20,290
right in case of you don't do strict

01:31:18,430 --> 01:31:22,060
shaking you just want to say I didn't do

01:31:20,290 --> 01:31:23,530
anything with these attributes give me

01:31:22,060 --> 01:31:26,380
your best effort on understanding these

01:31:23,530 --> 01:31:30,370
attributes right but really we have to

01:31:26,380 --> 01:31:32,740
it's more like a relaxed way to just it

01:31:30,370 --> 01:31:34,540
doesn't it's orthogonal it's it's not

01:31:32,740 --> 01:31:36,430
contradictory to what you're saying well

01:31:34,540 --> 01:31:38,860
it if you change this it has to be an

01:31:36,430 --> 01:31:42,130
opt-in flag so now would be not get

01:31:38,860 --> 01:31:44,350
strict check it would be a new string

01:31:42,130 --> 01:31:45,610
check meaning if you don't if you don't

01:31:44,350 --> 01:31:48,220
understand everything in this request

01:31:45,610 --> 01:31:50,500
don't do anything which again I think

01:31:48,220 --> 01:31:56,740
that is an odd API that you opt in to

01:31:50,500 --> 01:32:00,930
the kernel doing sure yes and I'm being

01:31:56,740 --> 01:32:03,720
super strict with the next hop API yeah

01:32:00,930 --> 01:32:09,570
often is the only option I don't see me

01:32:03,720 --> 01:32:11,580
yeah okay I will just be quick one thing

01:32:09,570 --> 01:32:12,900
which we probably didn't discuss at

01:32:11,580 --> 01:32:16,230
least I didn't get it

01:32:12,900 --> 01:32:20,520
is the when kernel is not putting some

01:32:16,230 --> 01:32:22,470
attribute because you you you as a user

01:32:20,520 --> 01:32:24,840
space you know you don't know if the

01:32:22,470 --> 01:32:28,710
attribute is not supported or it was

01:32:24,840 --> 01:32:31,560
just not filled out so like for a nice

01:32:28,710 --> 01:32:33,840
example is a life like which is

01:32:31,560 --> 01:32:37,230
basically unusable because you don't

01:32:33,840 --> 01:32:42,270
know if if the if it means false or if

01:32:37,230 --> 01:32:47,640
it means like I don't support it yeah so

01:32:42,270 --> 01:32:49,950
so we have to use and I you so almost

01:32:47,640 --> 01:32:55,730
put a deprecated thing on the Nellie and

01:32:49,950 --> 01:32:58,860
fle really I don't remember because

01:32:55,730 --> 01:33:01,740
there will be a plant attributes don't

01:32:58,860 --> 01:33:04,380
use NL a flag they all use u8 and

01:33:01,740 --> 01:33:05,640
recently recent attributes yes that is

01:33:04,380 --> 01:33:08,520
an interesting dilemma though you don't

01:33:05,640 --> 01:33:12,390
know if it's it doesn't understand it or

01:33:08,520 --> 01:33:14,910
if it's just not set yeah the problem

01:33:12,390 --> 01:33:17,460
discussed before right but I think it's

01:33:14,910 --> 01:33:19,800
also important another thing

01:33:17,460 --> 01:33:21,810
yeah we can we can perhaps have like

01:33:19,800 --> 01:33:24,240
some templates or something which the

01:33:21,810 --> 01:33:27,450
kernel would dump the templates of the

01:33:24,240 --> 01:33:30,150
messages on our notifications and it

01:33:27,450 --> 01:33:32,929
would say it will tell you you can

01:33:30,150 --> 01:33:37,099
expect this kind of attributes from me

01:33:32,929 --> 01:33:38,570
it's like the capabilities but I was

01:33:37,099 --> 01:33:42,770
saying that a dump of all the attributes

01:33:38,570 --> 01:33:45,380
would be an empty dump okay

01:33:42,770 --> 01:33:48,710
yeah and this is also related to what

01:33:45,380 --> 01:33:51,110
you discussed already and so endeavoring

01:33:48,710 --> 01:33:53,690
we do dump it commands and we just dump

01:33:51,110 --> 01:33:56,960
everything with one exception which is

01:33:53,690 --> 01:34:00,230
which is region read and it allows you

01:33:56,960 --> 01:34:02,449
to select by an attribute so you you put

01:34:00,230 --> 01:34:05,719
you put is a user space you put some

01:34:02,449 --> 01:34:07,580
attributes and according to this it does

01:34:05,719 --> 01:34:09,849
the selection and the filtering of the

01:34:07,580 --> 01:34:13,880
dump not filtering but it actually

01:34:09,849 --> 01:34:15,940
doesn't put data in the dump when you

01:34:13,880 --> 01:34:18,409
don't need it and you just specify it

01:34:15,940 --> 01:34:20,239
for shared buffer for example we do the

01:34:18,409 --> 01:34:22,280
filtering can use this place so we dump

01:34:20,239 --> 01:34:26,139
everything and then in this place we

01:34:22,280 --> 01:34:30,849
filter it out so it's not it's not good

01:34:26,139 --> 01:34:34,010
but this can be extended probably but

01:34:30,849 --> 01:34:36,860
for our purposes I think that doing it

01:34:34,010 --> 01:34:39,830
by attribute is enough but maybe

01:34:36,860 --> 01:34:42,170
something what what what what Jemma

01:34:39,830 --> 01:34:44,300
mentioned would be would be nice if you

01:34:42,170 --> 01:34:48,770
if you if you do it in some generic way

01:34:44,300 --> 01:34:52,360
because we can use it as well yeah

01:34:48,770 --> 01:34:54,870
that's it I think it's it yep

01:34:52,360 --> 01:34:59,350
all right thanks Jerry

01:34:54,870 --> 01:34:59,350
[Applause]

01:35:06,630 --> 01:35:09,630
you

01:35:10,260 --> 01:35:13,260
okay

01:35:25,320 --> 01:35:30,560
ah this one

01:35:43,950 --> 01:35:48,910
Thanks

01:35:45,150 --> 01:35:54,640
so what I'm talking going to talk about

01:35:48,910 --> 01:35:57,910
is conversion of one of the old network

01:35:54,640 --> 01:36:00,810
configuration tool ETH to named way to

01:35:57,910 --> 01:36:03,340
that link because it's one of the last

01:36:00,810 --> 01:36:05,470
well-known tools which doesn't use

01:36:03,340 --> 01:36:15,360
nothing these days and it's causing

01:36:05,470 --> 01:36:18,490
trouble so we have to we have to

01:36:15,360 --> 01:36:21,010
interfaces to talk about what I'm

01:36:18,490 --> 01:36:23,620
interesting about now is the upper

01:36:21,010 --> 01:36:26,800
interface between the generic ETH - code

01:36:23,620 --> 01:36:29,200
in kernel and the user space CTF -

01:36:26,800 --> 01:36:32,470
utility which is currently implemented

01:36:29,200 --> 01:36:35,350
by a ioctl which causes a lot of

01:36:32,470 --> 01:36:38,200
problems then there is second interface

01:36:35,350 --> 01:36:41,590
which is not so interesting now but it

01:36:38,200 --> 01:36:44,710
still effects the way the netting

01:36:41,590 --> 01:36:46,600
implementation is done and that's it eh

01:36:44,710 --> 01:36:52,610
- ops which is the interface between

01:36:46,600 --> 01:36:56,120
this generic code and network drivers

01:36:52,610 --> 01:37:00,020
so this is what the picture used to look

01:36:56,120 --> 01:37:02,210
like for long where we have the ETH tool

01:37:00,020 --> 01:37:05,300
utility in the space but we shouldn't

01:37:02,210 --> 01:37:07,460
forget that these days ETH tool is not

01:37:05,300 --> 01:37:11,720
the only user space utility using the

01:37:07,460 --> 01:37:14,560
interface so we have others like we get

01:37:11,720 --> 01:37:17,180
system D Network the network manager and

01:37:14,560 --> 01:37:20,780
many distributions are for various

01:37:17,180 --> 01:37:24,110
reasons moving to some configuration

01:37:20,780 --> 01:37:29,200
management demons which make things more

01:37:24,110 --> 01:37:29,200
complicated okay

01:37:30,179 --> 01:37:38,770
her own button so these are the goals

01:37:34,869 --> 01:37:41,650
the main goals for netlink api for the

01:37:38,770 --> 01:37:45,849
new net link base tptp high and these

01:37:41,650 --> 01:37:48,219
goals directly correspond to the main

01:37:45,849 --> 01:37:53,170
problems with this existing ioctl

01:37:48,219 --> 01:37:55,300
interface the first and the most visible

01:37:53,170 --> 01:37:57,400
problem with the ioctl interface is the

01:37:55,300 --> 01:38:00,280
extensibility or rather lack of

01:37:57,400 --> 01:38:02,679
extensibility most of the interfaces

01:38:00,280 --> 01:38:06,790
most of the commands are not extensible

01:38:02,679 --> 01:38:08,829
at all and some in very limited way if

01:38:06,790 --> 01:38:12,099
you remember in the morning when saya

01:38:08,829 --> 01:38:15,869
was talking about TCP a TCP info

01:38:12,099 --> 01:38:19,690
structure which can be only appended to

01:38:15,869 --> 01:38:22,360
the ETH to ioctl interface is much worse

01:38:19,690 --> 01:38:25,659
because you don't have the structure

01:38:22,360 --> 01:38:28,690
size which served as kind of interface

01:38:25,659 --> 01:38:33,190
version so you cannot even append you

01:38:28,690 --> 01:38:35,949
can only fill the holes so if you don't

01:38:33,190 --> 01:38:37,540
have any holes well if you want to add

01:38:35,949 --> 01:38:40,210
an attribute you have to add a new

01:38:37,540 --> 01:38:44,290
command and this is what happened many

01:38:40,210 --> 01:38:46,619
times in the past that's bad so with

01:38:44,290 --> 01:38:50,380
that link you can easily add new

01:38:46,619 --> 01:38:53,349
attributes to extend the interface to

01:38:50,380 --> 01:38:58,960
add new parameters new information and

01:38:53,349 --> 01:39:03,969
so on the proposed that link API also

01:38:58,960 --> 01:39:07,090
works with bit sets of arbitrary size so

01:39:03,969 --> 01:39:09,960
not limited to the 32 bit bit fields

01:39:07,090 --> 01:39:09,960
mostly

01:39:10,590 --> 01:39:18,010
we don't have fixed size things second

01:39:15,940 --> 01:39:20,619
big problem of the old each issue

01:39:18,010 --> 01:39:23,380
interface is the error reporting because

01:39:20,619 --> 01:39:25,929
the only information the only reporting

01:39:23,380 --> 01:39:29,409
you have with your interface is the

01:39:25,929 --> 01:39:32,380
numeric error code so that you where you

01:39:29,409 --> 01:39:34,540
get involved for example that means some

01:39:32,380 --> 01:39:37,179
parameter you wanted to set was wrong

01:39:34,540 --> 01:39:41,980
which parameter and what was wrong with

01:39:37,179 --> 01:39:44,830
it no idea that's very bad some of the

01:39:41,980 --> 01:39:48,969
drivers put this information into

01:39:44,830 --> 01:39:51,190
catalog by a print key which is not

01:39:48,969 --> 01:39:55,869
really able to interface for this for

01:39:51,190 --> 01:39:59,530
user errors or admin errors so with net

01:39:55,869 --> 01:40:03,159
link we can use x tag or a reporting or

01:39:59,530 --> 01:40:05,770
for warnings another problem of the old

01:40:03,159 --> 01:40:07,900
interface is the read modify write cycle

01:40:05,770 --> 01:40:10,630
because if you want to change one

01:40:07,900 --> 01:40:12,429
parameter you have to retrieve the whole

01:40:10,630 --> 01:40:14,050
structure change value of that one

01:40:12,429 --> 01:40:18,550
parameter and send the whole structure

01:40:14,050 --> 01:40:20,350
back when to user space processes do the

01:40:18,550 --> 01:40:25,239
same with the same structure at the same

01:40:20,350 --> 01:40:27,480
time you are in trouble and okay in the

01:40:25,239 --> 01:40:30,790
old times when there was only it eh -

01:40:27,480 --> 01:40:33,159
you wouldn't do that but today when you

01:40:30,790 --> 01:40:35,790
have demons in the background it can

01:40:33,159 --> 01:40:35,790
happen

01:40:35,980 --> 01:40:42,349
there is still read-modify-write cycle

01:40:38,780 --> 01:40:47,719
in the netlink api in implementation we

01:40:42,349 --> 01:40:50,150
have but it's only in kernel between the

01:40:47,719 --> 01:40:53,570
generic kernel code and network driver

01:40:50,150 --> 01:40:58,250
and as everything is done under our DNA

01:40:53,570 --> 01:41:04,070
lock at the time there is no place for

01:40:58,250 --> 01:41:06,739
Asus we have notifications that's

01:41:04,070 --> 01:41:08,840
another problem we had with ioctl if you

01:41:06,739 --> 01:41:14,510
are using things like IP monitor or

01:41:08,840 --> 01:41:18,260
other tools you monitoring evens and

01:41:14,510 --> 01:41:21,980
what is changing in the system one of

01:41:18,260 --> 01:41:26,090
the new things in in this new net link

01:41:21,980 --> 01:41:29,059
api is that it allows notifications on

01:41:26,090 --> 01:41:32,420
changes both on changes done where the

01:41:29,059 --> 01:41:35,239
net link interface and changes done

01:41:32,420 --> 01:41:38,389
where the old ioctl interface in some

01:41:35,239 --> 01:41:41,880
cases like saying that the features it's

01:41:38,389 --> 01:41:48,570
also unchanged is done by other

01:41:41,880 --> 01:41:50,820
tools or other interfaces this is this

01:41:48,570 --> 01:41:54,179
works really nicely there is one big

01:41:50,820 --> 01:41:57,060
difference when the change is done by a

01:41:54,179 --> 01:41:59,040
net link interface you get a

01:41:57,060 --> 01:42:02,340
notification only if something really

01:41:59,040 --> 01:42:05,760
does change because you have the

01:42:02,340 --> 01:42:08,520
information about the old state and the

01:42:05,760 --> 01:42:11,670
new state so you know whether you did

01:42:08,520 --> 01:42:15,480
change something if you are changing in

01:42:11,670 --> 01:42:18,030
via D or legacy ioctl interface you

01:42:15,480 --> 01:42:20,579
don't have that kind of information in

01:42:18,030 --> 01:42:22,440
the notification so you have to send a

01:42:20,579 --> 01:42:30,060
notification always when someone tried

01:42:22,440 --> 01:42:33,540
to change and okay another advantage is

01:42:30,060 --> 01:42:35,790
that there is less need for cardinal and

01:42:33,540 --> 01:42:38,989
user space code to be in sins so for

01:42:35,790 --> 01:42:43,400
example when a new link mode is added

01:42:38,989 --> 01:42:47,969
you don't have to update user space and

01:42:43,400 --> 01:42:50,820
some other things like that and last but

01:42:47,969 --> 01:42:54,079
not least there was a mention of the

01:42:50,820 --> 01:42:57,540
documentation in the pre noon session so

01:42:54,079 --> 01:43:01,320
I tried an approach position which is

01:42:57,540 --> 01:43:03,510
quite unusual for me which is that I try

01:43:01,320 --> 01:43:06,389
to start with the documentation so

01:43:03,510 --> 01:43:09,150
whenever I add a new new command I try

01:43:06,389 --> 01:43:10,920
to document the API first and then

01:43:09,150 --> 01:43:13,829
implement it according to the

01:43:10,920 --> 01:43:16,380
documentation it helped me a lot already

01:43:13,829 --> 01:43:23,540
many times

01:43:16,380 --> 01:43:29,040
okay okay so some implementation details

01:43:23,540 --> 01:43:32,220
so the API is using journaling a family

01:43:29,040 --> 01:43:33,170
named ETH tool there are three kind of

01:43:32,220 --> 01:43:36,930
commands

01:43:33,170 --> 01:43:40,140
starting with perfect get set or act get

01:43:36,930 --> 01:43:44,550
is for retrieving information set is for

01:43:40,140 --> 01:43:47,790
setting parameters these come in pairs

01:43:44,550 --> 01:43:52,380
because the set messages are also used

01:43:47,790 --> 01:43:54,480
as a replies for the get commands so

01:43:52,380 --> 01:43:56,520
there are some set commands which do not

01:43:54,480 --> 01:43:58,680
really correspond to actual setting

01:43:56,520 --> 01:44:04,200
something okay which is something Eric

01:43:58,680 --> 01:44:07,190
was talking about Hardy didn't forget to

01:44:04,200 --> 01:44:10,170
make the same mistake and act our

01:44:07,190 --> 01:44:12,240
actions which are not really sending or

01:44:10,170 --> 01:44:15,030
receiving data for example like device

01:44:12,240 --> 01:44:19,260
reset or physical identification by

01:44:15,030 --> 01:44:20,880
bringing the light and the set the same

01:44:19,260 --> 01:44:24,630
set messages are also used for

01:44:20,880 --> 01:44:28,860
notification which makes use of space

01:44:24,630 --> 01:44:32,880
writing user space monitor easier so

01:44:28,860 --> 01:44:36,390
actually the user space code for ETH to

01:44:32,880 --> 01:44:38,310
monitor I was able to write while

01:44:36,390 --> 01:44:42,830
waiting for the plane after the last in

01:44:38,310 --> 01:44:42,830
the difficult Ference in the mall

01:44:44,590 --> 01:44:50,380
we use the nested attributes are used a

01:44:48,010 --> 01:44:54,850
lot to structure the information better

01:44:50,380 --> 01:44:56,920
and to handle that better the

01:44:54,850 --> 01:45:00,100
informatics is split into multiple files

01:44:56,920 --> 01:45:01,840
because it would be too long the problem

01:45:00,100 --> 01:45:03,550
is that the old interface was using

01:45:01,840 --> 01:45:05,260
essentially the same structure for

01:45:03,550 --> 01:45:07,630
talking between user space and generic

01:45:05,260 --> 01:45:09,790
ETH to encode in kernel and between

01:45:07,630 --> 01:45:12,700
generic ETH Zurich or in kernel and

01:45:09,790 --> 01:45:15,450
network drivers we don't have that

01:45:12,700 --> 01:45:19,570
luxury so the code is more complicated

01:45:15,450 --> 01:45:23,140
and the implementation is optional so

01:45:19,570 --> 01:45:25,270
there is a config option for that well

01:45:23,140 --> 01:45:27,730
there is not yet what I'm talking about

01:45:25,270 --> 01:45:31,360
this just in the form of a person that

01:45:27,730 --> 01:45:35,110
I'm going to submit later today but

01:45:31,360 --> 01:45:40,090
there have already been three RFC

01:45:35,110 --> 01:45:43,950
submissions in parallel I'm ray amending

01:45:40,090 --> 01:45:43,950
the user space ETH to the authority

01:45:46,740 --> 01:45:56,110
so current state tools now I'm in the

01:45:53,110 --> 01:45:58,120
what I call the phase one where the goal

01:45:56,110 --> 01:45:59,920
of phase one and the end of phase one

01:45:58,120 --> 01:46:02,230
should be that we have ETH to

01:45:59,920 --> 01:46:06,130
implementation which doesn't use or

01:46:02,230 --> 01:46:09,220
doesn't have it to use ioctl at all both

01:46:06,130 --> 01:46:14,320
in kernel and in user space so what is

01:46:09,220 --> 01:46:16,480
missing to that goal there are still few

01:46:14,320 --> 01:46:19,920
comments missing and some of them a bit

01:46:16,480 --> 01:46:23,380
tricky but we we are already in the

01:46:19,920 --> 01:46:25,900
state where it was easier to list things

01:46:23,380 --> 01:46:28,440
that list things that are missing then

01:46:25,900 --> 01:46:34,150
list things that are done which is

01:46:28,440 --> 01:46:36,280
encouraging I must say so some open

01:46:34,150 --> 01:46:38,350
questions yeah one of the open question

01:46:36,280 --> 01:46:40,330
is is the relationship between HT issue

01:46:38,350 --> 01:46:43,450
and deviling because traditionally it is

01:46:40,330 --> 01:46:46,780
to implement some features which would

01:46:43,450 --> 01:46:49,060
rather belong to dev link one example

01:46:46,780 --> 01:46:52,000
was the flashing but they are more like

01:46:49,060 --> 01:46:56,860
that now the question is what on which

01:46:52,000 --> 01:47:01,180
level we are doing going to use deviling

01:46:56,860 --> 01:47:05,230
to implement e th to feature well one

01:47:01,180 --> 01:47:07,240
one option is that the generic e th to

01:47:05,230 --> 01:47:11,950
encode in kernel would called the link

01:47:07,240 --> 01:47:15,160
code or deviling corvex problem is that

01:47:11,950 --> 01:47:17,710
we will we would have two different user

01:47:15,160 --> 01:47:21,270
space AP is for the same feature same

01:47:17,710 --> 01:47:24,700
function which is not really desirable

01:47:21,270 --> 01:47:27,690
second option would be that user space e

01:47:24,700 --> 01:47:30,820
th you would use dev link socket and

01:47:27,690 --> 01:47:33,100
deviling commands to implement the

01:47:30,820 --> 01:47:36,550
feature the problem here is there are

01:47:33,100 --> 01:47:40,660
two problem more complicated user space

01:47:36,550 --> 01:47:43,660
code which is not really critical but

01:47:40,660 --> 01:47:46,130
what I find for worse is that there is

01:47:43,660 --> 01:47:48,860
currently limited doubling support in

01:47:46,130 --> 01:47:51,260
drivers in particular are Chetnik next

01:47:48,860 --> 01:47:55,040
check to the net next three is three

01:47:51,260 --> 01:47:58,100
evening and there are deviling some

01:47:55,040 --> 01:48:01,790
deviling support is only in six Nick

01:47:58,100 --> 01:48:05,870
drivers from four defenders seven if you

01:48:01,790 --> 01:48:08,330
count native scene which is not much and

01:48:05,870 --> 01:48:12,469
I think it would take quite a lot of

01:48:08,330 --> 01:48:15,679
time until all network drivers would

01:48:12,469 --> 01:48:20,440
support the rink and evering

01:48:15,679 --> 01:48:23,920
implementation of necessary features I

01:48:20,440 --> 01:48:30,830
wanted to comment on your patches but

01:48:23,920 --> 01:48:35,090
why do you see what I would like to

01:48:30,830 --> 01:48:38,360
achieve in some near future would be a

01:48:35,090 --> 01:48:41,600
state where we could actually make the

01:48:38,360 --> 01:48:43,790
ioctl interface optional and would be

01:48:41,600 --> 01:48:53,330
able to implement everything that eta2

01:48:43,790 --> 01:48:56,929
does now build-out no CTO and with a B

01:48:53,330 --> 01:49:00,760
or C that I'm afraid would take quite a

01:48:56,929 --> 01:49:03,860
lot of time and fight all sort of work

01:49:00,760 --> 01:49:06,800
even if we only care about the entry

01:49:03,860 --> 01:49:10,760
drivers yeah so the thing is with option

01:49:06,800 --> 01:49:11,960
C it also ah yes well let me say a few

01:49:10,760 --> 01:49:15,739
words

01:49:11,960 --> 01:49:18,679
the obviously would be to either replace

01:49:15,739 --> 01:49:24,199
it is to buy a new utility with clear

01:49:18,679 --> 01:49:28,760
syntax or not implement those commands

01:49:24,199 --> 01:49:31,760
all the problem I see with this is the

01:49:28,760 --> 01:49:33,829
biggest problem with this that I see is

01:49:31,760 --> 01:49:36,599
that

01:49:33,829 --> 01:49:39,210
tools like if config are now obsolete

01:49:36,599 --> 01:49:42,690
for 20 years and there are still people

01:49:39,210 --> 01:49:45,420
using them and those people mostly use

01:49:42,690 --> 01:49:47,250
the excuse that they don't want to learn

01:49:45,420 --> 01:49:50,219
something new something they are not

01:49:47,250 --> 01:49:54,020
used to even if they only learn about it

01:49:50,219 --> 01:49:56,909
five years ago and I'm afraid that if we

01:49:54,020 --> 01:50:00,570
remove functionality from ETH to or

01:49:56,909 --> 01:50:02,969
replace ETH to buy annuity completely we

01:50:00,570 --> 01:50:09,210
would be in exactly the same situation

01:50:02,969 --> 01:50:10,380
as we were in those yeah it will take 20

01:50:09,210 --> 01:50:14,579
years but I think I've configured

01:50:10,380 --> 01:50:16,590
finally going we moved only few years

01:50:14,579 --> 01:50:19,380
ago there started to be distributions

01:50:16,590 --> 01:50:23,369
which don't install it by default like

01:50:19,380 --> 01:50:25,260
two or three years so because yeah I saw

01:50:23,369 --> 01:50:29,810
firmware management all that moved to

01:50:25,260 --> 01:50:29,810
the blink rate already and I understand

01:50:30,349 --> 01:50:37,560
the devlin for I think most uses for

01:50:33,989 --> 01:50:43,760
many users or not so skill to users is

01:50:37,560 --> 01:50:47,280
that it uses different different handles

01:50:43,760 --> 01:50:50,010
so people are kind of used to doing

01:50:47,280 --> 01:50:51,510
network device names and the

01:50:50,010 --> 01:50:55,770
correspondence between a network device

01:50:51,510 --> 01:50:56,940
names and the Devlin controls which are

01:50:55,770 --> 01:51:01,480
the

01:50:56,940 --> 01:51:05,290
which are bound to the bus and device

01:51:01,480 --> 01:51:07,960
naming is not so straightforward for

01:51:05,290 --> 01:51:11,290
many people I personally I have the same

01:51:07,960 --> 01:51:21,670
problem with the iw utility yeah Bridget

01:51:11,290 --> 01:51:24,220
Bridget be our city some more well some

01:51:21,670 --> 01:51:27,940
more open problems for discussion or for

01:51:24,220 --> 01:51:31,360
thinking about at the moment extact is

01:51:27,940 --> 01:51:33,940
only used for reporting code detected by

01:51:31,360 --> 01:51:36,670
the generic code nor not that not the

01:51:33,940 --> 01:51:39,870
problems like parameter problems

01:51:36,670 --> 01:51:43,150
detected at the Nick driver level

01:51:39,870 --> 01:51:46,630
because there is no exact support in the

01:51:43,150 --> 01:51:50,140
ETH loops so there is something that I

01:51:46,630 --> 01:51:50,830
would like to address eventually in say

01:51:50,140 --> 01:51:56,230
face bar

01:51:50,830 --> 01:51:58,930
phase 2 there are still some bit field

01:51:56,230 --> 01:52:01,360
32 attributes and the question is

01:51:58,930 --> 01:52:08,530
whether these are future safe like

01:52:01,360 --> 01:52:12,100
message types or wake-on-lan types maybe

01:52:08,530 --> 01:52:13,390
we should use arbitrary size bit bit

01:52:12,100 --> 01:52:16,270
sets everywhere

01:52:13,390 --> 01:52:18,610
the statistics those are not implemented

01:52:16,270 --> 01:52:25,260
yet but I'm thinking about whether the

01:52:18,610 --> 01:52:28,290
32 bit statistics are not a bit updated

01:52:25,260 --> 01:52:31,320
ah interesting idea that only occurred

01:52:28,290 --> 01:52:34,110
to me while reading the program of this

01:52:31,320 --> 01:52:37,620
conference was the the 32-bit field for

01:52:34,110 --> 01:52:40,530
ring speed allows because of some

01:52:37,620 --> 01:52:42,660
limitations historic only speeds up to 2

01:52:40,530 --> 01:52:45,960
terabytes which seems quite a lot but

01:52:42,660 --> 01:52:48,360
there is going to be a talk about 400

01:52:45,960 --> 01:52:51,450
Gigabit Ethernet it's not really that

01:52:48,360 --> 01:52:53,220
far we might want to think about it a

01:52:51,450 --> 01:52:57,090
bit what do you say what's wrong with

01:52:53,220 --> 01:52:58,770
only bit field and a bit field is broken

01:52:57,090 --> 01:53:00,510
you say it or what suppose no no the

01:52:58,770 --> 01:53:05,010
problem is that an L a bit field is

01:53:00,510 --> 01:53:07,770
limited to 32 bits so if there are new

01:53:05,010 --> 01:53:12,180
say wakin up in types so we are at I

01:53:07,770 --> 01:53:15,560
think 8 at the moment but well we are

01:53:12,180 --> 01:53:19,830
designing now the interface for future

01:53:15,560 --> 01:53:24,060
you can add another one basically yeah

01:53:19,830 --> 01:53:25,710
sure but it would be I think we looked

01:53:24,060 --> 01:53:28,170
at David and I did have this

01:53:25,710 --> 01:53:29,730
conversation when event you say ok let's

01:53:28,170 --> 01:53:31,680
just I don't we don't need more than

01:53:29,730 --> 01:53:33,750
three bits right now so let's make it a

01:53:31,680 --> 01:53:35,670
little bit but there's actually a

01:53:33,750 --> 01:53:38,250
library thing in the kernel for bitmaps

01:53:35,670 --> 01:53:40,999
that you can make it grow as much as you

01:53:38,250 --> 01:53:43,219
want yeah

01:53:40,999 --> 01:53:44,659
but it was very complicated if I

01:53:43,219 --> 01:53:52,429
remember correctly yeah it's my things

01:53:44,659 --> 01:53:54,769
with more complicated there was some

01:53:52,429 --> 01:53:58,369
reason why she was changed for in um to

01:53:54,769 --> 01:54:02,019
actual speed one thing I was thinking

01:53:58,369 --> 01:54:05,599
about is that we are actually using only

01:54:02,019 --> 01:54:09,920
some speed so maybe we could use

01:54:05,599 --> 01:54:11,929
something like speed and offset so we've

01:54:09,920 --> 01:54:14,210
hit this a few times like four table

01:54:11,929 --> 01:54:17,090
table ID used to be a u8 inside the

01:54:14,210 --> 01:54:19,940
message and now it's a 32-bit attribute

01:54:17,090 --> 01:54:22,130
appended to the route messages so yeah

01:54:19,940 --> 01:54:23,989
they're solutions for that yeah flipping

01:54:22,130 --> 01:54:26,809
over from the the old yeah those are

01:54:23,989 --> 01:54:28,940
things that thinking about and people

01:54:26,809 --> 01:54:31,360
running speeds fired but faster than

01:54:28,940 --> 01:54:36,699
that we'd have to have new tools so yeah

01:54:31,360 --> 01:54:40,249
yeah of course the internal Cardinal

01:54:36,699 --> 01:54:42,940
interfaces use 32-bit everywhere so the

01:54:40,249 --> 01:54:46,840
river ID would have to be massive anyway

01:54:42,940 --> 01:54:50,389
but it's something to think about

01:54:46,840 --> 01:54:54,920
yeah so some ideas what we could think

01:54:50,389 --> 01:54:56,420
about after phase 1 is finished so we

01:54:54,920 --> 01:55:00,110
should do no more extensions to the

01:54:56,420 --> 01:55:03,260
ioctl interface to kind of push people

01:55:00,110 --> 01:55:05,409
to use unit link one yeah make it

01:55:03,260 --> 01:55:05,409
optional

01:55:05,620 --> 01:55:10,750
and convince others user space tools to

01:55:07,990 --> 01:55:13,270
use netlink which may be harder than it

01:55:10,750 --> 01:55:16,300
seems because I remember when I was back

01:55:13,270 --> 01:55:18,610
porting the net line interface for

01:55:16,300 --> 01:55:22,120
bonding configuration to slit valve

01:55:18,610 --> 01:55:24,370
I mentioned that to people working on

01:55:22,120 --> 01:55:27,970
wicked and they said oh that's great

01:55:24,370 --> 01:55:30,340
that'd save us a lot of work about a

01:55:27,970 --> 01:55:33,610
month ago I'd checked the wicked code

01:55:30,340 --> 01:55:37,230
and was surprised that to this day it's

01:55:33,610 --> 01:55:40,630
still using CSS CTL sisyphus interface

01:55:37,230 --> 01:55:43,930
to configure the bonding so it may be

01:55:40,630 --> 01:55:47,020
harder then it seems yeah

01:55:43,930 --> 01:55:50,440
then we might start rebelling eth to ops

01:55:47,020 --> 01:55:52,660
mostly to implicit

01:55:50,440 --> 01:55:57,580
for error reporting and better

01:55:52,660 --> 01:55:59,500
extensibility those some features some

01:55:57,580 --> 01:56:02,170
pretty sure they will come some features

01:55:59,500 --> 01:56:06,400
which are currently kind of blocked by

01:56:02,170 --> 01:56:09,790
ioctl interface deficiencies and there

01:56:06,400 --> 01:56:12,010
are some ideas within last year about

01:56:09,790 --> 01:56:13,990
structured statistics or structured

01:56:12,010 --> 01:56:19,420
offroading flags so that's something

01:56:13,990 --> 01:56:22,180
that will be more open now yeah it would

01:56:19,420 --> 01:56:25,120
be nice to get rid of get rid of our TNL

01:56:22,180 --> 01:56:28,270
lock which is currently used around eth

01:56:25,120 --> 01:56:31,390
to ops the problem is that for years or

01:56:28,270 --> 01:56:34,540
maybe rather decades now DET to ops

01:56:31,390 --> 01:56:37,510
in drivers were written under the

01:56:34,540 --> 01:56:41,329
impression that you can rely on RT

01:56:37,510 --> 01:56:47,420
analog so it may be problem

01:56:41,329 --> 01:56:50,929
ah yeah why shall dessert estrous over

01:56:47,420 --> 01:56:53,360
here mistress why do you need wash a

01:56:50,929 --> 01:56:55,400
mistress is actually the new modern

01:56:53,360 --> 01:56:56,989
estrous knows how to delude netlink

01:56:55,400 --> 01:57:00,380
i was kind of very impressed they have a

01:56:56,989 --> 01:57:02,030
lot of bugs misreporting things sending

01:57:00,380 --> 01:57:04,159
them a patch they have this process I

01:57:02,030 --> 01:57:06,349
couldn't keep up that scent of a patch a

01:57:04,159 --> 01:57:09,050
couple of times to fix the neighbour

01:57:06,349 --> 01:57:12,280
messages but it's amazing you should

01:57:09,050 --> 01:57:12,280
take a look at it instead of wyshak

01:57:12,909 --> 01:57:18,530
currently just download the latest for

01:57:15,710 --> 01:57:21,290
my debugging actually using edit an

01:57:18,530 --> 01:57:23,449
option 2 ETA 2 ETA H 2 so that it dumps

01:57:21,290 --> 01:57:27,770
both outgoing and coming meddling

01:57:23,449 --> 01:57:29,329
messages in some readable form art think

01:57:27,770 --> 01:57:34,400
about contributing it to a stress which

01:57:29,329 --> 01:57:36,739
is a much wider check definitely I never

01:57:34,400 --> 01:57:41,079
heard about it before it's I was

01:57:36,739 --> 01:57:46,460
surprised the first time I saw it so

01:57:41,079 --> 01:57:52,000
here you can find some links so as I

01:57:46,460 --> 01:57:54,440
said I'm well I planned to submit the v4

01:57:52,000 --> 01:57:56,659
yesterday but I did some last-minute

01:57:54,440 --> 01:57:59,179
change so I need to update the cover

01:57:56,659 --> 01:58:02,599
letter but hopefully I'll be able to

01:57:59,179 --> 01:58:04,790
submit the purchases today right our

01:58:02,599 --> 01:58:08,630
first part of the picture because I have

01:58:04,790 --> 01:58:10,909
some more but so currently I'm at

01:58:08,630 --> 01:58:12,880
something like 45 patches which would be

01:58:10,909 --> 01:58:16,520
too long to submit at once

01:58:12,880 --> 01:58:19,190
and there is a presentation from Sue's

01:58:16,520 --> 01:58:24,600
conference asked

01:58:19,190 --> 01:58:27,690
September so thank you for attention on

01:58:24,600 --> 01:58:30,210
we have something like - a minutes for

01:58:27,690 --> 01:58:37,260
questions so you can define me in the

01:58:30,210 --> 01:58:39,390
lobby or yeah thanks Michael so I think

01:58:37,260 --> 01:58:41,220
in general yes we did run over a little

01:58:39,390 --> 01:58:44,040
bit on our time slot it was a break

01:58:41,220 --> 01:58:46,350
after this before the TC workshop starts

01:58:44,040 --> 01:58:48,840
so we have a few minutes thanks everyone

01:58:46,350 --> 01:58:50,760
for attending if anyone has suggestions

01:58:48,840 --> 01:58:52,950
on implementing any of things that were

01:58:50,760 --> 01:58:56,670
proposed you know feel free give it a

01:58:52,950 --> 01:58:58,110
shot try it send some patches other than

01:58:56,670 --> 01:58:59,880
that I guess you know we have other

01:58:58,110 --> 01:59:01,680
topics so we could be getting into so

01:58:59,880 --> 01:59:06,260
hopefully we'll be doing other work

01:59:01,680 --> 01:59:06,260

YouTube URL: https://www.youtube.com/watch?v=U3KCmJ1W_1E


