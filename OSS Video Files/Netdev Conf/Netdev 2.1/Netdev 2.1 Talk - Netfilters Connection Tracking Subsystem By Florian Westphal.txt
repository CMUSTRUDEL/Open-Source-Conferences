Title: Netdev 2.1 Talk - Netfilters Connection Tracking Subsystem By Florian Westphal
Publication date: 2017-04-30
Playlist: Netdev 2.1
Description: 
	In this talk, Florian Westphal  dissects netfilter's connection tracking subsystem

https://www.netdevconf.org/2.1/session.html?westphal
Captions: 
	00:00:11,059 --> 00:00:19,010
let's first discuss what netfilter

00:00:15,600 --> 00:00:20,910
connection tracking is actually about so

00:00:19,010 --> 00:00:23,460
basically it's flow tracking by

00:00:20,910 --> 00:00:27,869
addresses of the endpoints so in layers

00:00:23,460 --> 00:00:31,140
304 you might have IP addresses and

00:00:27,869 --> 00:00:33,890
ports or IP addresses and GRE qualities

00:00:31,140 --> 00:00:36,179
and some things like that

00:00:33,890 --> 00:00:38,159
programmatically a net filter we have

00:00:36,179 --> 00:00:40,319
splits the Tracking's in layer 3 in

00:00:38,159 --> 00:00:42,719
layer 4 so the layer for tracking

00:00:40,319 --> 00:00:44,850
modules like TCP or UDP only exists once

00:00:42,719 --> 00:00:51,239
and they don't care if they run on top

00:00:44,850 --> 00:00:53,339
of ipv4 ipv6 they try to keep state so

00:00:51,239 --> 00:00:55,379
the TCP tracker actually will look at it

00:00:53,339 --> 00:00:57,510
be sequence numbers it looks at these P

00:00:55,379 --> 00:01:02,069
Flags can detect in the little flag

00:00:57,510 --> 00:01:04,080
combinations it can adjust timeouts when

00:01:02,069 --> 00:01:06,510
it sees that data has been sent in one

00:01:04,080 --> 00:01:08,430
direction and not yet been acknowledged

00:01:06,510 --> 00:01:10,409
by the peers so we can evict connections

00:01:08,430 --> 00:01:15,170
early when in pH and suddenly goes down

00:01:10,409 --> 00:01:17,399
and doesn't respond anymore we deleted

00:01:15,170 --> 00:01:21,119
connections quickly when we see resets

00:01:17,399 --> 00:01:23,490
and also will close down internally the

00:01:21,119 --> 00:01:27,899
state when we see fin exchanges on the

00:01:23,490 --> 00:01:31,890
wire contract itself never all those

00:01:27,899 --> 00:01:33,689
packets and net is built on top in net

00:01:31,890 --> 00:01:38,729
filter so a net field and net is always

00:01:33,689 --> 00:01:41,850
stateful the contract subsystem hooks

00:01:38,729 --> 00:01:44,429
into a net filter so at before the

00:01:41,850 --> 00:01:46,409
routing lookup and aspects go out to

00:01:44,429 --> 00:01:50,880
observe packets on the wire as they come

00:01:46,409 --> 00:01:55,590
and leave the system another nice

00:01:50,880 --> 00:01:59,100
feature is the connection checking event

00:01:55,590 --> 00:02:01,530
subsystem which allows user space to

00:01:59,100 --> 00:02:04,950
subscribe to whatever is happening in

00:02:01,530 --> 00:02:07,170
the internal state machine so your user

00:02:04,950 --> 00:02:09,300
space can get notifications about new

00:02:07,170 --> 00:02:11,880
connections about connections that they

00:02:09,300 --> 00:02:13,830
are deleted about changes in the state

00:02:11,880 --> 00:02:16,060
so for instance transitions from

00:02:13,830 --> 00:02:19,150
established to closing

00:02:16,060 --> 00:02:21,220
or when an iptables rules change the

00:02:19,150 --> 00:02:23,709
corn market always generates events that

00:02:21,220 --> 00:02:25,209
your space can subscribe to this is

00:02:23,709 --> 00:02:27,700
especially useful to for instance

00:02:25,209 --> 00:02:33,069
implement flow accounting news space by

00:02:27,700 --> 00:02:37,120
you Lochte or to track what's happening

00:02:33,069 --> 00:02:39,069
in the system so for instance contract

00:02:37,120 --> 00:02:40,959
can also do byte accounting and packet

00:02:39,069 --> 00:02:44,800
accounting to see how much data was

00:02:40,959 --> 00:02:46,569
transferred on a connection it's also

00:02:44,800 --> 00:02:48,220
possible to restrict what kinds of

00:02:46,569 --> 00:02:51,640
unions are generated on very large

00:02:48,220 --> 00:02:55,320
setups where there are a lot of events

00:02:51,640 --> 00:02:58,120
you can use IP table City target to

00:02:55,320 --> 00:03:03,459
restrict what kind of events you are

00:02:58,120 --> 00:03:04,780
interested in to reduce the load there

00:03:03,459 --> 00:03:06,670
are unfortunately a bunch of

00:03:04,780 --> 00:03:08,739
misconceptions about contracts so the

00:03:06,670 --> 00:03:09,880
most common that I hear is that IP

00:03:08,739 --> 00:03:12,340
tables as something to do with

00:03:09,880 --> 00:03:14,380
connection tracking that's not true so

00:03:12,340 --> 00:03:16,120
if you use the IP tables contract match

00:03:14,380 --> 00:03:17,530
then there doesn't do connection

00:03:16,120 --> 00:03:20,860
tracking at all it just checks the

00:03:17,530 --> 00:03:23,890
packet state as determined by the

00:03:20,860 --> 00:03:25,239
earlier connection tracking step and the

00:03:23,890 --> 00:03:28,180
same is true for the any of tables

00:03:25,239 --> 00:03:30,160
counterpart also contract does not look

00:03:28,180 --> 00:03:33,700
at socket States at all it just looks at

00:03:30,160 --> 00:03:38,019
packets as they come in and go so there

00:03:33,700 --> 00:03:43,630
is no extra check of the TCP stack in

00:03:38,019 --> 00:03:46,060
the kernel contract supports several

00:03:43,630 --> 00:03:48,130
different states the most common one you

00:03:46,060 --> 00:03:49,780
will see is established which is

00:03:48,130 --> 00:03:52,000
basically always true when we have an

00:03:49,780 --> 00:03:54,609
existing entry and the layer for tracker

00:03:52,000 --> 00:03:56,739
checks paths or TCP flex combinations

00:03:54,609 --> 00:04:00,850
are okay packets in window and so on

00:03:56,739 --> 00:04:02,410
it's a force the other one is new which

00:04:00,850 --> 00:04:06,310
will happen when we have no previous

00:04:02,410 --> 00:04:09,280
record at all and that's that case we

00:04:06,310 --> 00:04:12,640
will try to allocate a new connection

00:04:09,280 --> 00:04:15,010
tracking entry but we will not place it

00:04:12,640 --> 00:04:17,169
in the main table until after all the IP

00:04:15,010 --> 00:04:19,390
tables rules have been passed that's

00:04:17,169 --> 00:04:22,289
basically an optimization because adding

00:04:19,390 --> 00:04:25,180
to the table requires taking locks and

00:04:22,289 --> 00:04:26,530
if you are being flooded and packets are

00:04:25,180 --> 00:04:28,570
being dropped in there's no point in

00:04:26,530 --> 00:04:29,320
taking the extra penalty of adding and

00:04:28,570 --> 00:04:29,889
deleting

00:04:29,320 --> 00:04:35,860
to the

00:04:29,889 --> 00:04:37,749
check table so in contract speak and

00:04:35,860 --> 00:04:41,949
entries always confirmed as soon as it

00:04:37,749 --> 00:04:44,020
enters the main table another state is

00:04:41,949 --> 00:04:46,509
related which is basically exactly the

00:04:44,020 --> 00:04:48,999
same as new except that the packet

00:04:46,509 --> 00:04:51,039
relates or the new flow relates in some

00:04:48,999 --> 00:04:53,949
way to something we already have a

00:04:51,039 --> 00:04:56,590
record of so for example if you receive

00:04:53,949 --> 00:04:58,749
an ipv6 packet a big message we will

00:04:56,590 --> 00:05:00,550
actually extract the original header of

00:04:58,749 --> 00:05:02,650
the packet that generated the event

00:05:00,550 --> 00:05:04,300
we'll look that up and if you see that

00:05:02,650 --> 00:05:08,050
we have a record of that flow then it

00:05:04,300 --> 00:05:09,610
will be related and not new and the same

00:05:08,050 --> 00:05:11,800
is true for the connection tracking help

00:05:09,610 --> 00:05:13,539
us more on that later which can have the

00:05:11,800 --> 00:05:16,740
symmetric expectation table where we can

00:05:13,539 --> 00:05:20,979
basically make records of flows that we

00:05:16,740 --> 00:05:23,349
expect to see in the near future in the

00:05:20,979 --> 00:05:25,389
last say that it's on tract which is for

00:05:23,349 --> 00:05:26,800
packets that either are you don't want

00:05:25,389 --> 00:05:31,539
to be tracked you can do that in IP

00:05:26,800 --> 00:05:33,400
tables with the CT target or for ipv6

00:05:31,539 --> 00:05:35,199
case where we do not track intentionally

00:05:33,400 --> 00:05:36,969
for instance neighbor discovery because

00:05:35,199 --> 00:05:39,279
it's basically I believe six equivalent

00:05:36,969 --> 00:05:43,000
to ipv4 ARP and we don't track that

00:05:39,279 --> 00:05:45,129
either and invalid is not a state at all

00:05:43,000 --> 00:05:46,509
because it basically means that there is

00:05:45,129 --> 00:05:49,060
no contract entries of the original

00:05:46,509 --> 00:05:50,800
state and that will happen whenever

00:05:49,060 --> 00:05:52,659
there the connection tracking engine

00:05:50,800 --> 00:05:55,149
thinks that something is wrong with the

00:05:52,659 --> 00:05:56,439
packets or TCP out of sequence will not

00:05:55,149 --> 00:05:57,969
be dropped that contract it's marked as

00:05:56,439 --> 00:06:04,060
invalid so users can drop it in their

00:05:57,969 --> 00:06:06,069
rulesets connection checking helpers so

00:06:04,060 --> 00:06:07,659
unfortunately there are some weird

00:06:06,069 --> 00:06:09,849
protocols that are pretty hard to track

00:06:07,659 --> 00:06:14,439
and especially provide a net for that's

00:06:09,849 --> 00:06:18,669
especially true for SIP h.323 and FTP

00:06:14,439 --> 00:06:20,529
and so on so and basically for contract

00:06:18,669 --> 00:06:22,149
modules it's always for the contract

00:06:20,529 --> 00:06:25,089
have a modules it's always the same they

00:06:22,149 --> 00:06:27,550
try to monitor the layer seven data on

00:06:25,089 --> 00:06:29,740
the control channel so in the FTP case

00:06:27,550 --> 00:06:33,550
you will monitor all four port commands

00:06:29,740 --> 00:06:36,580
on the control channel and parse the

00:06:33,550 --> 00:06:39,370
addresses that are being exchanged and

00:06:36,580 --> 00:06:42,009
every whenever you see one then there's

00:06:39,370 --> 00:06:42,780
an entry edit to the expectation table

00:06:42,009 --> 00:06:44,550
with

00:06:42,780 --> 00:06:46,950
address so that when the data connection

00:06:44,550 --> 00:06:48,750
comes in we will know about it and we

00:06:46,950 --> 00:06:50,100
can also apply automatically any net

00:06:48,750 --> 00:06:51,600
transformation on the control channel

00:06:50,100 --> 00:06:53,880
automatically so users don't have to

00:06:51,600 --> 00:06:56,520
fudge with extranet rules for the data

00:06:53,880 --> 00:06:59,730
channel or voice Channel or whatever

00:06:56,520 --> 00:07:02,280
protocol we are tracking this is best

00:06:59,730 --> 00:07:03,780
effort only so we do not do TCP stream

00:07:02,280 --> 00:07:05,850
reassembly so when port commands get

00:07:03,780 --> 00:07:07,350
split over several packets and this will

00:07:05,850 --> 00:07:11,520
simply not work but it's good enough in

00:07:07,350 --> 00:07:15,780
practice unfortunately this also means

00:07:11,520 --> 00:07:17,880
that we have some pretty hard to

00:07:15,780 --> 00:07:20,730
understand and probably even faulty code

00:07:17,880 --> 00:07:24,210
in the kernel especially the sn1 parser

00:07:20,730 --> 00:07:26,520
for the h.323 helper which basically no

00:07:24,210 --> 00:07:28,710
one has ever looked at since it what it

00:07:26,520 --> 00:07:34,020
was added and I'm not even sure if it

00:07:28,710 --> 00:07:35,310
works so it's in a lot of cases for

00:07:34,020 --> 00:07:37,950
these protocols it would be preferable

00:07:35,310 --> 00:07:41,970
to do this in userspace by using

00:07:37,950 --> 00:07:44,490
something like t proxy to then packets

00:07:41,970 --> 00:07:47,550
for the data channel to approximate

00:07:44,490 --> 00:07:50,130
application and nowadays we provide in

00:07:47,550 --> 00:07:53,100
the kernel user space api so user space

00:07:50,130 --> 00:07:55,410
can in fact in inject expectations into

00:07:53,100 --> 00:07:57,810
the kernel so you only have to monitor

00:07:55,410 --> 00:07:59,490
our control connections and for instance

00:07:57,810 --> 00:08:03,840
if you see a sip invite message then it

00:07:59,490 --> 00:08:06,570
could add the expectation of the actual

00:08:03,840 --> 00:08:09,000
voice calls into the kernel so that all

00:08:06,570 --> 00:08:11,640
of that gets passed through in the crown

00:08:09,000 --> 00:08:14,150
and not take the penalty of sending that

00:08:11,640 --> 00:08:14,150
user space

00:08:16,369 --> 00:08:21,749
the main connection tracking table

00:08:18,629 --> 00:08:25,589
nowadays is completely la classe for all

00:08:21,749 --> 00:08:27,779
read accesses and we can even do

00:08:25,589 --> 00:08:30,059
parallel ads and delete operations on

00:08:27,779 --> 00:08:31,649
the table provided that they occur in

00:08:30,059 --> 00:08:33,329
different slots of the table this is

00:08:31,649 --> 00:08:35,430
mostly to work of Eric do mozzie and

00:08:33,329 --> 00:08:40,860
then later revived the Esper Tangut

00:08:35,430 --> 00:08:44,610
Brauer the table has a fixed size that

00:08:40,860 --> 00:08:47,370
is exposed by assists ETL and there is

00:08:44,610 --> 00:08:50,040
no automated growth so we just pick an

00:08:47,370 --> 00:08:51,360
initial value based on the memory of the

00:08:50,040 --> 00:08:53,970
system and leave it to the system

00:08:51,360 --> 00:08:57,870
administrator to make adjustments as

00:08:53,970 --> 00:09:01,500
needed for a given workload every entry

00:08:57,870 --> 00:09:03,870
is hashed twice once in the original

00:09:01,500 --> 00:09:05,250
months in the reply direction the reason

00:09:03,870 --> 00:09:06,750
for that is network address translation

00:09:05,250 --> 00:09:09,569
of course because if we have a net

00:09:06,750 --> 00:09:11,160
nothing and the reply comes back we

00:09:09,569 --> 00:09:14,220
don't have the original IP address

00:09:11,160 --> 00:09:16,440
anymore on the wire and and we would not

00:09:14,220 --> 00:09:19,319
find a match in a contract entry that is

00:09:16,440 --> 00:09:21,750
why we also have the netted address so

00:09:19,319 --> 00:09:24,300
we can from that conclude what the

00:09:21,750 --> 00:09:31,440
original address is and how to apply it

00:09:24,300 --> 00:09:33,269
in reverse mappings because we have a

00:09:31,440 --> 00:09:37,100
lot of features in contract like events

00:09:33,269 --> 00:09:40,440
and byte accounting and time stands and

00:09:37,100 --> 00:09:42,750
connection tracking helpers the contract

00:09:40,440 --> 00:09:44,550
and entry would be pretty big that's why

00:09:42,750 --> 00:09:48,180
we have this thing called extensions

00:09:44,550 --> 00:09:50,730
which allows us to offload a rarely used

00:09:48,180 --> 00:09:53,850
stuff into an external blob that is

00:09:50,730 --> 00:09:56,959
linked from the contract entry so the

00:09:53,850 --> 00:09:59,160
good side is we save a lot of memory for

00:09:56,959 --> 00:10:02,639
common setups that don't use these

00:09:59,160 --> 00:10:04,230
features but we take some overhead

00:10:02,639 --> 00:10:04,829
because we have some metadata that

00:10:04,230 --> 00:10:07,199
tracks

00:10:04,829 --> 00:10:10,410
what extensions are actually allocated

00:10:07,199 --> 00:10:12,720
and in place and we need one extra key

00:10:10,410 --> 00:10:16,370
reference to obtain whatever the

00:10:12,720 --> 00:10:16,370
extension data we are interested in

00:10:18,880 --> 00:10:24,980
NAT as I already said is built on top of

00:10:22,070 --> 00:10:28,070
the connection checking engine and they

00:10:24,980 --> 00:10:30,740
are always created at contract creation

00:10:28,070 --> 00:10:32,660
time so for the new packet state and

00:10:30,740 --> 00:10:35,510
that's also the reason why the apt

00:10:32,660 --> 00:10:37,490
iptables NAT table always only sees the

00:10:35,510 --> 00:10:39,850
first packet in a flow because it's

00:10:37,490 --> 00:10:44,899
essentially just a mapping database of

00:10:39,850 --> 00:10:46,580
addresses to address we also have to

00:10:44,899 --> 00:10:49,339
maintain one extra hash table the so

00:10:46,580 --> 00:10:50,959
called by source table which all the

00:10:49,339 --> 00:10:54,800
connections regardless if they have not

00:10:50,959 --> 00:10:57,140
applied or not get editor because we

00:10:54,800 --> 00:10:58,880
have to detect the case where for

00:10:57,140 --> 00:11:02,300
example we have an outgoing connection

00:10:58,880 --> 00:11:04,130
from the Rotti router and another

00:11:02,300 --> 00:11:06,350
connection comes in that gets mapped to

00:11:04,130 --> 00:11:07,940
the same address that would collide so

00:11:06,350 --> 00:11:11,360
we have to detect this collision and

00:11:07,940 --> 00:11:18,350
then provide a new port translation for

00:11:11,360 --> 00:11:21,680
the new connection so now for overflow

00:11:18,350 --> 00:11:22,480
handling that's a bit of a difficult

00:11:21,680 --> 00:11:25,040
topic

00:11:22,480 --> 00:11:27,050
so whenever the contact table gets full

00:11:25,040 --> 00:11:31,339
you will see this message log by the

00:11:27,050 --> 00:11:33,079
kernel table full dropping packet the

00:11:31,339 --> 00:11:35,660
main assumption here is that most

00:11:33,079 --> 00:11:36,230
entries are not assured what does that

00:11:35,660 --> 00:11:38,450
mean

00:11:36,230 --> 00:11:40,550
so assured is a special flag in the

00:11:38,450 --> 00:11:42,850
contract entry that gets set by the

00:11:40,550 --> 00:11:46,100
higher layer protocol tracker like TCP

00:11:42,850 --> 00:11:47,570
whenever certain event has passed so for

00:11:46,100 --> 00:11:49,640
instance in this be case we have seen

00:11:47,570 --> 00:11:51,649
the full three-way handshake so for

00:11:49,640 --> 00:11:53,180
instance if you gets in flooded then

00:11:51,649 --> 00:11:55,700
most of your entries in the contact

00:11:53,180 --> 00:11:57,829
table would not be assured and out there

00:11:55,700 --> 00:12:00,200
for candidates for early evictions which

00:11:57,829 --> 00:12:04,000
means that we try to toss one of these

00:12:00,200 --> 00:12:07,070
out and make room for the new connection

00:12:04,000 --> 00:12:09,440
and that's done by searching the next

00:12:07,070 --> 00:12:11,690
eight buckets in the table where the new

00:12:09,440 --> 00:12:14,870
connection would have been assigned to

00:12:11,690 --> 00:12:16,610
and then if it's not assured we destroy

00:12:14,870 --> 00:12:17,870
it and allocate a new entry in its place

00:12:16,610 --> 00:12:22,089
and otherwise we have to drop the new

00:12:17,870 --> 00:12:25,790
packet so what's the problem with that

00:12:22,089 --> 00:12:29,150
so we can only ever drop non assured

00:12:25,790 --> 00:12:31,310
entries and there's no way if a new

00:12:29,150 --> 00:12:33,170
table if a new packet is

00:12:31,310 --> 00:12:35,180
more important than any of the other

00:12:33,170 --> 00:12:38,120
entries that we already have so we can't

00:12:35,180 --> 00:12:40,400
just go around widely and just evict

00:12:38,120 --> 00:12:43,279
random entries because we could evict

00:12:40,400 --> 00:12:44,960
something very important and it also

00:12:43,279 --> 00:12:46,970
does not play nice with a network

00:12:44,960 --> 00:12:48,589
address translation because the status

00:12:46,970 --> 00:12:50,930
in the contract table so whenever you

00:12:48,589 --> 00:12:54,529
destroy something you lose mappings for

00:12:50,930 --> 00:12:57,350
that flow and then of course there's the

00:12:54,529 --> 00:12:58,520
case of overflow with legitimate traffic

00:12:57,350 --> 00:13:00,140
pattern so yes of course the

00:12:58,520 --> 00:13:01,700
administrator can always increase the

00:13:00,140 --> 00:13:04,130
connection tracking table if resources

00:13:01,700 --> 00:13:07,339
allow this but it's also possible that

00:13:04,130 --> 00:13:09,860
some end point just went away without

00:13:07,339 --> 00:13:12,410
having outstanding data for instance and

00:13:09,860 --> 00:13:16,880
we have pretty pretty long timeouts in

00:13:12,410 --> 00:13:20,990
some cases by default so what could we

00:13:16,880 --> 00:13:23,690
do about it so some ideas here are to

00:13:20,990 --> 00:13:25,250
remove some rather strange contract

00:13:23,690 --> 00:13:28,190
error handling and I would basically say

00:13:25,250 --> 00:13:30,710
it's a bug so for instance if a packet

00:13:28,190 --> 00:13:33,320
is always it's invalid then we always

00:13:30,710 --> 00:13:35,839
pass it on to the filter IP tables or n

00:13:33,320 --> 00:13:37,220
F tables and users can decide what they

00:13:35,839 --> 00:13:40,700
want to do was the invalid packet like

00:13:37,220 --> 00:13:42,589
pass or drop or lock or whatever but in

00:13:40,700 --> 00:13:43,820
case we cannot allocate a contract entry

00:13:42,589 --> 00:13:45,290
because we are over the limit and

00:13:43,820 --> 00:13:47,510
automatically we will drop the packet

00:13:45,290 --> 00:13:50,150
instead of saying it's invalid and

00:13:47,510 --> 00:13:51,680
leaving the decision to the user one of

00:13:50,150 --> 00:13:53,360
the questions here is of course if we

00:13:51,680 --> 00:13:56,690
can just change the behavior without

00:13:53,360 --> 00:13:59,960
potentially risking some set up becoming

00:13:56,690 --> 00:14:01,670
insecure insecure or whatever so maybe

00:13:59,960 --> 00:14:04,250
we will have to new add and useless

00:14:01,670 --> 00:14:07,790
control to make this behavior

00:14:04,250 --> 00:14:09,890
configurable another problem here is

00:14:07,790 --> 00:14:12,020
that this does not solve the table

00:14:09,890 --> 00:14:15,920
exhaustion problem for our cases because

00:14:12,020 --> 00:14:21,110
you cannot fundamentally track and at

00:14:15,920 --> 00:14:23,089
non track packets therefore another may

00:14:21,110 --> 00:14:25,120
be better suggestion is to add an early

00:14:23,089 --> 00:14:29,779
drop callback to the lair for trackers

00:14:25,120 --> 00:14:32,630
so instead of just going around and

00:14:29,779 --> 00:14:34,970
trying to evict a random entry asked

00:14:32,630 --> 00:14:37,100
layer for tracker if this is an early

00:14:34,970 --> 00:14:40,610
drop candidate even if it's in a short

00:14:37,100 --> 00:14:43,490
state so we have very very large default

00:14:40,610 --> 00:14:45,140
timers so like five days for first

00:14:43,490 --> 00:14:47,330
and even if you lower it to something

00:14:45,140 --> 00:14:52,790
reasonable it's like lakeside like say

00:14:47,330 --> 00:14:55,040
five minutes we could still make some

00:14:52,790 --> 00:14:57,709
use of the knowledge that alia for

00:14:55,040 --> 00:15:05,140
tracker has so for instance if we are

00:14:57,709 --> 00:15:08,149
under pressure we could we could try to

00:15:05,140 --> 00:15:09,700
earlier Vick for that are already in fin

00:15:08,149 --> 00:15:13,970
State or

00:15:09,700 --> 00:15:16,700
closing and we could under pressure just

00:15:13,970 --> 00:15:20,180
kill those off and allow a new entry to

00:15:16,700 --> 00:15:23,690
come in another thing is that we

00:15:20,180 --> 00:15:25,910
nowadays we do have a background worker

00:15:23,690 --> 00:15:28,070
for the that takes care of evicting

00:15:25,910 --> 00:15:31,040
contract entries so you could extend

00:15:28,070 --> 00:15:33,740
that theoretically to inject egg probing

00:15:31,040 --> 00:15:36,920
into the connection to see if it's still

00:15:33,740 --> 00:15:38,089
alive if we are not sure and that of

00:15:36,920 --> 00:15:39,920
course might be a bit controversial

00:15:38,089 --> 00:15:42,380
because nowadays contract is passive and

00:15:39,920 --> 00:15:46,160
doing act roving is definitely not

00:15:42,380 --> 00:15:48,260
passive anymore and our saying that we

00:15:46,160 --> 00:15:49,910
could look into is implementing adaptive

00:15:48,260 --> 00:15:53,300
time outs it's something that is

00:15:49,910 --> 00:15:57,829
implemented in the Beasties so for

00:15:53,300 --> 00:15:59,329
instance we could combine the time outs

00:15:57,829 --> 00:16:03,890
which that we already have for the city

00:15:59,329 --> 00:16:07,310
target with a match on how much or what

00:16:03,890 --> 00:16:10,010
how big the fraction of used table slots

00:16:07,310 --> 00:16:11,839
is currently which is not possible to

00:16:10,010 --> 00:16:15,529
match on but it would be easy to add and

00:16:11,839 --> 00:16:17,390
match that you can say match if more

00:16:15,529 --> 00:16:19,100
than 80% of the table is full or

00:16:17,390 --> 00:16:22,149
something like that and then configure

00:16:19,100 --> 00:16:27,020
ibly lower the timeouts during

00:16:22,149 --> 00:16:31,310
connection setup we could of course only

00:16:27,020 --> 00:16:33,560
also prefer to evict those contracts

00:16:31,310 --> 00:16:34,880
that have a net now binding that is they

00:16:33,560 --> 00:16:37,790
don't translate to a different address

00:16:34,880 --> 00:16:41,620
or different port pair because for those

00:16:37,790 --> 00:16:44,060
we could rebuild state if necessary

00:16:41,620 --> 00:16:46,160
another problem of course is that even

00:16:44,060 --> 00:16:47,779
under flood lowering timeouts does not

00:16:46,160 --> 00:16:51,170
really help so even one minute is just

00:16:47,779 --> 00:16:53,750
too long but it does help with peers

00:16:51,170 --> 00:16:55,100
that do not close properly so it's

00:16:53,750 --> 00:16:57,110
definitely something that I would like

00:16:55,100 --> 00:17:02,200
to look into at

00:16:57,110 --> 00:17:04,339
in the near future so in summary

00:17:02,200 --> 00:17:07,370
contract does have a pretty major code

00:17:04,339 --> 00:17:10,250
base and lots of features but there's

00:17:07,370 --> 00:17:11,600
still some room for improvements so as

00:17:10,250 --> 00:17:14,890
we have seen the overflow handing could

00:17:11,600 --> 00:17:18,170
be improved I'm also looking into

00:17:14,890 --> 00:17:20,510
removing the need to wait for an ICU

00:17:18,170 --> 00:17:22,060
grace period to delete the extension

00:17:20,510 --> 00:17:24,800
blot that we have in the kernel because

00:17:22,060 --> 00:17:26,870
nowadays all the excesses with two

00:17:24,800 --> 00:17:28,370
exceptions occur after obtaining a

00:17:26,870 --> 00:17:30,230
reference count on the connection

00:17:28,370 --> 00:17:34,850
tracking entry so we are sure that we

00:17:30,230 --> 00:17:36,230
own it and can't go away and another

00:17:34,850 --> 00:17:38,960
thing that we could look into as

00:17:36,230 --> 00:17:45,020
removing variable size extensions so

00:17:38,960 --> 00:17:48,470
right now we support that you can define

00:17:45,020 --> 00:17:51,230
an extension and it determine at setup

00:17:48,470 --> 00:17:53,900
time of the connection how big a space

00:17:51,230 --> 00:17:55,160
the extension requires but actually I

00:17:53,900 --> 00:17:57,560
don't think this is really useful

00:17:55,160 --> 00:17:59,210
anymore because for the the only

00:17:57,560 --> 00:18:01,700
extension that makes use of this is to

00:17:59,210 --> 00:18:04,190
have extension and all the helpers that

00:18:01,700 --> 00:18:07,400
we have in occur only need like 20 or 30

00:18:04,190 --> 00:18:09,680
bytes tops so the idea is to just at a

00:18:07,400 --> 00:18:10,940
scratch area similar to the escapee

00:18:09,680 --> 00:18:13,940
control buffer that we have in the

00:18:10,940 --> 00:18:15,860
kernel and then remove the VAR sized

00:18:13,940 --> 00:18:18,110
extensions a big advantage of doing that

00:18:15,860 --> 00:18:20,690
is that it would allow us to add a build

00:18:18,110 --> 00:18:22,760
time assertions to check what the

00:18:20,690 --> 00:18:25,220
maximum size of all the extensions of

00:18:22,760 --> 00:18:27,320
beauty support is and that might allow

00:18:25,220 --> 00:18:30,470
us to also do some offsets that we have

00:18:27,320 --> 00:18:35,330
to lower quantities to save some space

00:18:30,470 --> 00:18:38,170
in the middle area so that's it

00:18:35,330 --> 00:18:38,170
any questions

00:18:41,860 --> 00:18:50,569
[Applause]

00:18:54,130 --> 00:19:03,640
so you've been talking a lot about TCP

00:18:56,660 --> 00:19:06,860
are there any plans to support quick so

00:19:03,640 --> 00:19:09,530
not yet someone would have to look at a

00:19:06,860 --> 00:19:12,610
quick protocol and how to tell it apart

00:19:09,530 --> 00:19:16,570
from playing UDP flows that we can track

00:19:12,610 --> 00:19:16,570
but no not yet

00:19:27,590 --> 00:19:32,490
so you're talking about me one of the

00:19:29,730 --> 00:19:33,840
problems being the when the table gets

00:19:32,490 --> 00:19:35,400
full and I think a lot of people like

00:19:33,840 --> 00:19:36,960
this various different posts on the line

00:19:35,400 --> 00:19:38,460
if you see the table full dropping

00:19:36,960 --> 00:19:42,870
packet like people get very confused

00:19:38,460 --> 00:19:44,370
about this and so if there's a way to

00:19:42,870 --> 00:19:46,290
improve certainly that would be great

00:19:44,370 --> 00:19:48,720
I wonder like in terms of doing

00:19:46,290 --> 00:19:50,280
something like an LRU where you can see

00:19:48,720 --> 00:19:52,799
like these connections aren't receiving

00:19:50,280 --> 00:19:53,760
traffic over a long period is do you

00:19:52,799 --> 00:19:55,290
think there's like some way we could

00:19:53,760 --> 00:20:00,240
integrate a mechanism that could just

00:19:55,290 --> 00:20:03,270
bomb old less active connections or

00:20:00,240 --> 00:20:05,790
something yes one idea was to add a

00:20:03,270 --> 00:20:08,070
nuisance control like a soft timeout

00:20:05,790 --> 00:20:09,660
that doesn't do anything under normal

00:20:08,070 --> 00:20:12,210
conditions but whenever we hit a limit

00:20:09,660 --> 00:20:15,570
and we find that the connection we are

00:20:12,210 --> 00:20:18,750
looking at is past that and just said

00:20:15,570 --> 00:20:28,140
that that was one idea if you have other

00:20:18,750 --> 00:20:30,510
ideas I'm all these so the whole

00:20:28,140 --> 00:20:33,450
connection table overflow situation is

00:20:30,510 --> 00:20:34,860
kind of like their routing cache except

00:20:33,450 --> 00:20:37,590
that you have this class of entries that

00:20:34,860 --> 00:20:40,559
are non reconstitute Abul in that cases

00:20:37,590 --> 00:20:42,660
for example right so it seems like an

00:20:40,559 --> 00:20:45,510
even more difficult problem than the

00:20:42,660 --> 00:20:47,340
routing cash flow is in many aspects so

00:20:45,510 --> 00:20:48,870
one advantage we have over the routing

00:20:47,340 --> 00:20:50,610
characters that we actually have TCP

00:20:48,870 --> 00:20:54,120
information like it's this connection

00:20:50,610 --> 00:20:55,740
closing or not right actually Robert

00:20:54,120 --> 00:20:57,179
Olson had a bunch of hacks where he

00:20:55,740 --> 00:20:59,130
would actually look for the fins and

00:20:57,179 --> 00:21:00,570
kill routing cash entries when a fin

00:20:59,130 --> 00:21:01,679
would arrive and things everybody get

00:21:00,570 --> 00:21:05,419
that's exactly what the connection

00:21:01,679 --> 00:21:07,320
tracker is able to do so I don't know I

00:21:05,419 --> 00:21:08,760
have you thought about garbage

00:21:07,320 --> 00:21:11,910
collection scans when you get into

00:21:08,760 --> 00:21:13,679
overflow mode or anything like that yeah

00:21:11,910 --> 00:21:15,419
so nowadays we always have garbage

00:21:13,679 --> 00:21:17,490
collection active in the background

00:21:15,419 --> 00:21:18,900
anyway because contracts backtrack

00:21:17,490 --> 00:21:20,490
entries don't have timers anymore

00:21:18,900 --> 00:21:21,929
you put them into an even put it into a

00:21:20,490 --> 00:21:24,900
more aggressive mode when we hit this

00:21:21,929 --> 00:21:26,309
overflow situation yeah that was an

00:21:24,900 --> 00:21:27,900
example like you said there's these

00:21:26,309 --> 00:21:31,140
timers that only apply when we ran over

00:21:27,900 --> 00:21:32,760
a full mozi the garbage yeah so the idea

00:21:31,140 --> 00:21:33,750
was that whenever we detect that there

00:21:32,760 --> 00:21:36,000
was no flow that risk

00:21:33,750 --> 00:21:37,530
we always schedule the garbage

00:21:36,000 --> 00:21:40,669
collection worker for an instant

00:21:37,530 --> 00:21:40,669
execution yes

00:21:43,169 --> 00:21:49,549
so I want to thank you to work on this

00:21:45,690 --> 00:21:52,710
contracting infra which is a kind of

00:21:49,549 --> 00:21:57,210
difficult to manage

00:21:52,710 --> 00:21:58,859
so yeah the photo variable time out I do

00:21:57,210 --> 00:22:02,909
I think it's make sense

00:21:58,859 --> 00:22:05,609
we have in TCP stack variables in a

00:22:02,909 --> 00:22:11,580
queue transmission logic depending on

00:22:05,609 --> 00:22:16,080
how the the scene receive circuit table

00:22:11,580 --> 00:22:20,869
your table is filled when we reach the

00:22:16,080 --> 00:22:24,840
limit of this table we no longer some

00:22:20,869 --> 00:22:27,749
mini syn/ack per person receives okay so

00:22:24,840 --> 00:22:30,239
that's an idea effectively that could be

00:22:27,749 --> 00:22:36,799
applied to contracting yeah I will look

00:22:30,239 --> 00:22:36,799
at thanks for the pointer anymore

00:22:36,919 --> 00:22:46,180
let's give fluorine

00:22:40,250 --> 00:22:46,180

YouTube URL: https://www.youtube.com/watch?v=mx2X9mZaZ5A


