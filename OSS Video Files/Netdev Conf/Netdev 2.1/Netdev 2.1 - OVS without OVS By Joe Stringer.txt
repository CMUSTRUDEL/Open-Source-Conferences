Title: Netdev 2.1 - OVS without OVS By Joe Stringer
Publication date: 2017-05-02
Playlist: Netdev 2.1
Description: 
	Talk given by Joe Stringer at Netdev 2.1 in Montreal on the 8th of Apr/2017.  The talk covers the OVS kernel API, shows how it can be directly configured with simpler low-level utilities (eg, ovs-dpctl), and looks at how it compares to similar APIs such as the tc cls_flower classifier.

Content at: https://www.netdevconf.org/2.1/session.html?stringer
Captions: 
	00:00:04,310 --> 00:00:11,309
all right great so this talk is about

00:00:07,919 --> 00:00:13,200
the the OS kernel API there's been

00:00:11,309 --> 00:00:15,210
various different talks over the years

00:00:13,200 --> 00:00:18,300
from something even the audience and

00:00:15,210 --> 00:00:21,570
various other people about how the open

00:00:18,300 --> 00:00:24,779
V switch userland works and how the open

00:00:21,570 --> 00:00:26,910
flow interface and so on are exposed but

00:00:24,779 --> 00:00:29,310
in terms of what's actually available in

00:00:26,910 --> 00:00:31,199
the kernel API that's been less well

00:00:29,310 --> 00:00:33,450
covered and I've had a few discussions

00:00:31,199 --> 00:00:36,660
with a few people in community lately

00:00:33,450 --> 00:00:39,059
and this may be so always clear to

00:00:36,660 --> 00:00:43,129
people what it is that the kernel API

00:00:39,059 --> 00:00:45,870
provides in sitting within this OVS

00:00:43,129 --> 00:00:49,079
community so what I want to cover today

00:00:45,870 --> 00:00:50,760
is some of the motivations behind the

00:00:49,079 --> 00:00:54,899
kernel API that we have for open V

00:00:50,760 --> 00:00:58,530
switch the description about what it is

00:00:54,899 --> 00:01:00,059
that we provide in that API and then to

00:00:58,530 --> 00:01:02,239
describe some of the different use cases

00:01:00,059 --> 00:01:04,650
and some of the different user land

00:01:02,239 --> 00:01:09,630
implementations that exist which are

00:01:04,650 --> 00:01:11,630
using this OVS kernel API so why open V

00:01:09,630 --> 00:01:15,119
switch - open V switch is kind of a

00:01:11,630 --> 00:01:17,610
confusing title so so those are familiar

00:01:15,119 --> 00:01:20,759
with garfield's there's actually a sort

00:01:17,610 --> 00:01:24,030
of spin-off for other garfield's comic

00:01:20,759 --> 00:01:26,400
called Garfield - Garfield so this guy

00:01:24,030 --> 00:01:29,340
basically takes the the Gow field comics

00:01:26,400 --> 00:01:31,220
and then he strips Garfield out and he

00:01:29,340 --> 00:01:34,290
strips out all the other characters and

00:01:31,220 --> 00:01:36,900
but he leaves Jon Arbuckle in there and

00:01:34,290 --> 00:01:38,460
so John is this like suburban American

00:01:36,900 --> 00:01:41,520
singer he's very very thoughtful very

00:01:38,460 --> 00:01:43,860
deep and it's kind of an interesting

00:01:41,520 --> 00:01:45,180
comic I think it really stands alone as

00:01:43,860 --> 00:01:46,770
a separate sort of contribution to the

00:01:45,180 --> 00:01:48,960
common space I think is quite quite cool

00:01:46,770 --> 00:01:51,180
and I would argue that maybe like OBS

00:01:48,960 --> 00:01:53,759
kernel module without the OBS user space

00:01:51,180 --> 00:01:58,229
also stands alone as a useful contribute

00:01:53,759 --> 00:02:00,210
contribution to the Linux kernel so just

00:01:58,229 --> 00:02:03,560
briefly here's the comic where John

00:02:00,210 --> 00:02:03,560
learns about network virtualization

00:02:04,830 --> 00:02:09,250
so a network virtualization is one of

00:02:07,600 --> 00:02:11,710
the use cases that that really comes in

00:02:09,250 --> 00:02:13,800
when you start to talk about OBS so we

00:02:11,710 --> 00:02:15,700
want to be able to logically separate

00:02:13,800 --> 00:02:18,000
different types of traffic

00:02:15,700 --> 00:02:22,270
maybe guys in between VMs or containers

00:02:18,000 --> 00:02:24,310
and and this behavior is defined based

00:02:22,270 --> 00:02:26,860
on some sort of a global view of the

00:02:24,310 --> 00:02:28,210
network and we were talking about open V

00:02:26,860 --> 00:02:31,150
so if you couldn't really throw stone

00:02:28,210 --> 00:02:35,880
very far without jumping on to Software

00:02:31,150 --> 00:02:40,090
Defined Networking so briefly talking

00:02:35,880 --> 00:02:41,020
Software Defined Networking defines that

00:02:40,090 --> 00:02:44,860
there should be some sort of a global

00:02:41,020 --> 00:02:46,450
view of the network as opposed to a sort

00:02:44,860 --> 00:02:48,310
of just distributed algorithms approach

00:02:46,450 --> 00:02:51,040
where every single box in the network

00:02:48,310 --> 00:02:52,600
builds up the entire state of how the

00:02:51,040 --> 00:02:55,180
network looks and it makes forwarding

00:02:52,600 --> 00:02:57,550
decisions based on that rather Software

00:02:55,180 --> 00:02:59,020
Defined Networking says that there is

00:02:57,550 --> 00:03:01,780
some logically centralized controller

00:02:59,020 --> 00:03:03,090
that has maybe a omniscient view of the

00:03:01,780 --> 00:03:07,090
network and is able to make decisions

00:03:03,090 --> 00:03:08,410
based on that sort of model and this is

00:03:07,090 --> 00:03:10,660
really coming from sort of a software

00:03:08,410 --> 00:03:13,510
world where we're trying to push the

00:03:10,660 --> 00:03:16,090
features at perhaps a faster rate then

00:03:13,510 --> 00:03:17,019
it's otherwise possible so some of the

00:03:16,090 --> 00:03:18,180
problems that they're trying to solve

00:03:17,019 --> 00:03:21,250
I mentioned network virtualization

00:03:18,180 --> 00:03:23,019
there's also lots of different cool

00:03:21,250 --> 00:03:25,480
stuff that Google's doing around link

00:03:23,019 --> 00:03:27,810
utilization improvements and various

00:03:25,480 --> 00:03:32,290
other things and perhaps traffic

00:03:27,810 --> 00:03:34,980
prioritization but this talks about the

00:03:32,290 --> 00:03:37,090
kind of like the ISO so I want to slowly

00:03:34,980 --> 00:03:39,100
transition towards there so how do we

00:03:37,090 --> 00:03:40,810
get to a point where we can do this

00:03:39,100 --> 00:03:43,450
cool software-defined networking stuff

00:03:40,810 --> 00:03:45,070
and I want to focus on these on the

00:03:43,450 --> 00:03:47,950
right-hand side of your the slides

00:03:45,070 --> 00:03:50,950
they're the arrows that come down from

00:03:47,950 --> 00:03:52,870
the centralized Sdn controller defining

00:03:50,950 --> 00:03:57,630
what they each individual individual

00:03:52,870 --> 00:04:00,340
device on the network is trying to do so

00:03:57,630 --> 00:04:03,370
flows is really the the abstraction that

00:04:00,340 --> 00:04:07,420
we use in the OBS world to describe

00:04:03,370 --> 00:04:10,660
things and what we're trying to do is is

00:04:07,420 --> 00:04:14,049
classify some some set of constraints

00:04:10,660 --> 00:04:15,250
around a set of packets and then do

00:04:14,049 --> 00:04:16,850
something with those so you might call

00:04:15,250 --> 00:04:19,250
this like there's a match action

00:04:16,850 --> 00:04:21,080
traction and when I talk about flows

00:04:19,250 --> 00:04:23,090
here I'm not talking about necessarily

00:04:21,080 --> 00:04:25,250
like a connection like a five tuple or

00:04:23,090 --> 00:04:28,700
something like that what I'm trying to

00:04:25,250 --> 00:04:30,950
find is some broader concept of just all

00:04:28,700 --> 00:04:33,620
of the possible natural fields and this

00:04:30,950 --> 00:04:36,490
may be fields within the packet maybe

00:04:33,620 --> 00:04:38,900
metadata such as the income and port or

00:04:36,490 --> 00:04:41,150
information it comes from a tunnel or

00:04:38,900 --> 00:04:44,600
even from another subsystem in Linux or

00:04:41,150 --> 00:04:47,420
this kind of thing as well so so briefly

00:04:44,600 --> 00:04:49,430
like if you were to look at every single

00:04:47,420 --> 00:04:51,320
possible field in the packet that you

00:04:49,430 --> 00:04:53,300
can look at you get a lot of granularity

00:04:51,320 --> 00:04:55,580
in terms of how you can determine your

00:04:53,300 --> 00:04:57,770
forwarding behavior and with that comes

00:04:55,580 --> 00:04:59,870
a lot of power a lot of ability to guide

00:04:57,770 --> 00:05:02,120
your traffic differently based on those

00:04:59,870 --> 00:05:04,850
hitters but then you do have to consider

00:05:02,120 --> 00:05:07,640
the performance implications of looking

00:05:04,850 --> 00:05:09,980
at all those extra headers and and how

00:05:07,640 --> 00:05:14,180
that is actually going to affect your

00:05:09,980 --> 00:05:16,850
forwarding performance so ideally what

00:05:14,180 --> 00:05:18,200
would happen is we could take you know

00:05:16,850 --> 00:05:20,930
one pass through the packet we figure

00:05:18,200 --> 00:05:22,160
out what we need to know do some lookup

00:05:20,930 --> 00:05:25,550
and determine our forwarding behavior

00:05:22,160 --> 00:05:26,960
and then forward our traffic on so

00:05:25,550 --> 00:05:30,890
that's maybe one of the goals that I

00:05:26,960 --> 00:05:37,700
hope that ensure that we achieve in some

00:05:30,890 --> 00:05:40,580
level so moving from the more abstract

00:05:37,700 --> 00:05:43,040
so this is what I'm saying flow is to to

00:05:40,580 --> 00:05:44,750
how we actually implement this and get

00:05:43,040 --> 00:05:49,160
this user working within the Linux

00:05:44,750 --> 00:05:51,740
kernel so I think the vast majority of

00:05:49,160 --> 00:05:53,300
network policy as defined in the Linux

00:05:51,740 --> 00:05:55,190
kernel is is defined through net links

00:05:53,300 --> 00:05:57,560
from families whether it's the generic

00:05:55,190 --> 00:06:00,080
or the ones that existed before that and

00:05:57,560 --> 00:06:03,080
so the the obvious kernel API is defined

00:06:00,080 --> 00:06:06,770
in terms of a set of generic net link

00:06:03,080 --> 00:06:08,410
families so firstly we have some some

00:06:06,770 --> 00:06:11,750
definition of a shared flow table

00:06:08,410 --> 00:06:16,010
resource we call this the data path so

00:06:11,750 --> 00:06:17,480
this applies the bounding box around how

00:06:16,010 --> 00:06:19,640
exactly our forwarding behavior is

00:06:17,480 --> 00:06:22,070
defined and it gives the hook point for

00:06:19,640 --> 00:06:25,010
where other things can can hang off so

00:06:22,070 --> 00:06:27,890
you've got one place that defines the

00:06:25,010 --> 00:06:29,690
all the behavior for that for that

00:06:27,890 --> 00:06:30,620
particular instance and then obviously

00:06:29,690 --> 00:06:33,139
we have to

00:06:30,620 --> 00:06:35,090
able to connect ports into this data

00:06:33,139 --> 00:06:38,780
path in some way for uh for receiving

00:06:35,090 --> 00:06:41,210
and transmitting the packets and then we

00:06:38,780 --> 00:06:43,490
come into this sort of flow concept that

00:06:41,210 --> 00:06:46,970
I defined just before where we want to

00:06:43,490 --> 00:06:49,100
be able to perform some sort of match on

00:06:46,970 --> 00:06:50,870
tech fields and metadata and then

00:06:49,100 --> 00:06:54,220
perform some sort of actions on that and

00:06:50,870 --> 00:06:58,310
so we we have a network family that

00:06:54,220 --> 00:07:00,430
describes what this format actually

00:06:58,310 --> 00:07:03,830
looks like and how you can configure it

00:07:00,430 --> 00:07:05,419
and finally you have to have some sort

00:07:03,830 --> 00:07:07,479
of way to describe what happens when the

00:07:05,419 --> 00:07:10,580
flow table is empty and maybe this is a

00:07:07,479 --> 00:07:12,110
little obvious but it needs to be there

00:07:10,580 --> 00:07:18,580
and it's important part of the yellow

00:07:12,110 --> 00:07:21,590
and KPI so first up the data path family

00:07:18,580 --> 00:07:23,449
this net link family for for OBS allows

00:07:21,590 --> 00:07:25,490
you to instantiate a particular data

00:07:23,449 --> 00:07:30,380
path so that's a logically separate flow

00:07:25,490 --> 00:07:33,650
table it includes a data path Network

00:07:30,380 --> 00:07:37,010
knit device that is named the same as

00:07:33,650 --> 00:07:39,349
the data path so this is similar to when

00:07:37,010 --> 00:07:41,450
you create a bridge of linux bridge you

00:07:39,349 --> 00:07:43,010
go add bridge and create say a device

00:07:41,450 --> 00:07:45,470
that's named the same as that divided us

00:07:43,010 --> 00:07:48,110
as that bridge and then you can hang off

00:07:45,470 --> 00:07:51,289
IP addresses off of that it gives access

00:07:48,110 --> 00:07:57,169
to the stack basically calling like need

00:07:51,289 --> 00:08:00,050
ifr X so for a particular data path we

00:07:57,169 --> 00:08:02,210
have a single flow table we associate

00:08:00,050 --> 00:08:05,210
one or more ports it has to be at least

00:08:02,210 --> 00:08:08,840
the data path device and in the zero or

00:08:05,210 --> 00:08:10,780
more flows determine how our packets

00:08:08,840 --> 00:08:13,789
wish to be forward

00:08:10,780 --> 00:08:17,360
so moving on is the virtual port family

00:08:13,789 --> 00:08:22,820
in the net link API this allows you to

00:08:17,360 --> 00:08:26,270
attach a device to that data path is

00:08:22,820 --> 00:08:27,740
this an income so there are various

00:08:26,270 --> 00:08:30,380
different types of ports that you can

00:08:27,740 --> 00:08:32,990
add so the V port internal is the same

00:08:30,380 --> 00:08:35,570
as as the bridge device but you can

00:08:32,990 --> 00:08:37,880
actually add additional internal devices

00:08:35,570 --> 00:08:40,820
to the bridge if that makes sense for

00:08:37,880 --> 00:08:43,419
your use case obviously you can attach

00:08:40,820 --> 00:08:46,089
like just your regular net devices

00:08:43,419 --> 00:08:48,730
there's also these tunnel virtual ports

00:08:46,089 --> 00:08:52,209
so previously you know we've had genÃ¨ve

00:08:48,730 --> 00:08:55,179
and VX plan and gree ports of is in the

00:08:52,209 --> 00:08:56,679
kernel this was built on something

00:08:55,179 --> 00:08:59,049
similar to what lightweight tunnels now

00:08:56,679 --> 00:09:01,509
achieves and over time we are

00:08:59,049 --> 00:09:07,899
transitioning these over to use the

00:09:01,509 --> 00:09:10,119
lightweight tunnel infrastructure moving

00:09:07,899 --> 00:09:12,040
onto the flow family this is where the

00:09:10,119 --> 00:09:12,339
interesting stuff stuff starts to come

00:09:12,040 --> 00:09:14,019
in

00:09:12,339 --> 00:09:16,389
so from user space you can configure

00:09:14,019 --> 00:09:20,139
some set of fields and these are defined

00:09:16,389 --> 00:09:23,679
in the API to match on and then some set

00:09:20,139 --> 00:09:26,019
of actions to execute so in the blue or

00:09:23,679 --> 00:09:27,579
cyan here we've got a match and we're

00:09:26,019 --> 00:09:29,189
matching on something some port we're

00:09:27,579 --> 00:09:31,540
saying we want to match on our traffic

00:09:29,189 --> 00:09:34,480
and then we want to output to to a

00:09:31,540 --> 00:09:37,389
different port on the device so when we

00:09:34,480 --> 00:09:40,389
insert this into the into the kernel we

00:09:37,389 --> 00:09:41,739
can specify yes this key of the packet

00:09:40,389 --> 00:09:44,589
fields and metadata that we want to

00:09:41,739 --> 00:09:48,249
match on we have the actions of what to

00:09:44,589 --> 00:09:49,600
actually execute output is the the most

00:09:48,249 --> 00:09:51,970
obvious basic case but there's obviously

00:09:49,600 --> 00:09:53,739
the you want to manage the packet in

00:09:51,970 --> 00:09:55,989
some way you may want to resubmit it

00:09:53,739 --> 00:09:58,839
when a subsystems various other actions

00:09:55,989 --> 00:10:00,999
that can be executed and then we have

00:09:58,839 --> 00:10:03,459
this concept of a flow mask which I'll

00:10:00,999 --> 00:10:05,169
go into in a bit more gifts and a little

00:10:03,459 --> 00:10:08,319
bit that this allows the granularity of

00:10:05,169 --> 00:10:11,619
the flow to be to be managed and to make

00:10:08,319 --> 00:10:16,209
more abstract so that covers multiple

00:10:11,619 --> 00:10:18,730
different flows and then there's also an

00:10:16,209 --> 00:10:21,489
identifier in there that allows you to

00:10:18,730 --> 00:10:23,709
more efficiently manage information or

00:10:21,489 --> 00:10:25,540
dump information from the kernel and

00:10:23,709 --> 00:10:29,799
there's a few other pieces that are sort

00:10:25,540 --> 00:10:33,129
of glossed over here so we look at how

00:10:29,799 --> 00:10:35,079
this lookup actually happens in OBS so

00:10:33,129 --> 00:10:38,529
what we do is we take the packet from

00:10:35,079 --> 00:10:41,019
the neck we extract all the fields that

00:10:38,529 --> 00:10:44,829
we know about from that packet isn't it

00:10:41,019 --> 00:10:47,079
IP whatever whatever have you and then

00:10:44,829 --> 00:10:49,389
when we have this full key of all of the

00:10:47,079 --> 00:10:50,889
possible fields that we know about we do

00:10:49,389 --> 00:10:52,600
a hash across that and then we do a

00:10:50,889 --> 00:10:54,910
lookup in our flow table and then we hit

00:10:52,600 --> 00:10:57,100
and we see okay here's the flow

00:10:54,910 --> 00:11:02,200
that describes what we should actually

00:10:57,100 --> 00:11:04,720
execute on this packet now I mentioned

00:11:02,200 --> 00:11:07,060
before there's this mask concept so if

00:11:04,720 --> 00:11:12,070
you were to separate all of your traffic

00:11:07,060 --> 00:11:14,980
out into the fully matched all possible

00:11:12,070 --> 00:11:16,930
fields you ever know about any possible

00:11:14,980 --> 00:11:19,090
value of this then you're going to end

00:11:16,930 --> 00:11:22,210
up inserting a large number of flows

00:11:19,090 --> 00:11:23,260
into the into the kernel and most likely

00:11:22,210 --> 00:11:25,360
this is going to have some sort of a

00:11:23,260 --> 00:11:28,030
performance impact and so this is where

00:11:25,360 --> 00:11:30,220
the mega flows came in so I put simply

00:11:28,030 --> 00:11:32,830
we want to be able to group a see it all

00:11:30,220 --> 00:11:38,670
flows together and we create this mega

00:11:32,830 --> 00:11:42,670
flow then when we actually do a lookup

00:11:38,670 --> 00:11:44,230
for any of these packet descriptions on

00:11:42,670 --> 00:11:46,710
the left hand side they'll be able to

00:11:44,230 --> 00:11:49,840
find the same entry in the flow table

00:11:46,710 --> 00:11:52,290
and the the mega flow here is based on a

00:11:49,840 --> 00:11:59,590
arbitrary bit mask across the full

00:11:52,290 --> 00:12:02,140
extracted key so if we look again at the

00:11:59,590 --> 00:12:04,360
the lookup it's a this is actually how

00:12:02,140 --> 00:12:08,350
it works in OBS today with you insert

00:12:04,360 --> 00:12:10,660
mask masked flows so the step number one

00:12:08,350 --> 00:12:12,550
is the same calling the unmasked key now

00:12:10,660 --> 00:12:14,050
so this is all of the possible fields

00:12:12,550 --> 00:12:17,590
that we could know about for this

00:12:14,050 --> 00:12:19,840
particular packet then we iterate

00:12:17,590 --> 00:12:22,480
through a set of masks

00:12:19,840 --> 00:12:24,610
that exist in the flow table and for

00:12:22,480 --> 00:12:27,430
each of these masks we will apply that

00:12:24,610 --> 00:12:29,290
mask across the unmasked key and we end

00:12:27,430 --> 00:12:30,730
up with a smart key in fact leader says

00:12:29,290 --> 00:12:33,070
that we're going to zero out the bits

00:12:30,730 --> 00:12:37,030
that we're not interested in matching on

00:12:33,070 --> 00:12:39,040
for executing this particular flow then

00:12:37,030 --> 00:12:41,080
once we have this masked key we can hash

00:12:39,040 --> 00:12:42,670
across that and do our lookup and find

00:12:41,080 --> 00:12:47,800
our flow and eventually execute the

00:12:42,670 --> 00:12:50,930
actions yeah

00:12:47,800 --> 00:12:53,209
so what happens when it messes so in

00:12:50,930 --> 00:12:54,920
this case again step one saying we're

00:12:53,209 --> 00:12:57,260
extracting this key I've abstracted out

00:12:54,920 --> 00:12:59,390
the the mass lookup that's not really

00:12:57,260 --> 00:13:01,339
relevant to this point so a tip number

00:12:59,390 --> 00:13:03,490
two we're saying we did our lookup in

00:13:01,339 --> 00:13:05,630
our flow table that it actually misses

00:13:03,490 --> 00:13:07,310
there's no entry in the flow table to

00:13:05,630 --> 00:13:09,680
determine what the packet forwarding

00:13:07,310 --> 00:13:13,730
behavior should be so what I'm doing

00:13:09,680 --> 00:13:15,829
here is we define this up call structure

00:13:13,730 --> 00:13:18,440
which includes the packet includes the

00:13:15,829 --> 00:13:20,690
metadata about we're executing what

00:13:18,440 --> 00:13:22,310
we've done to the packet and so on this

00:13:20,690 --> 00:13:23,930
includes things like the float key that

00:13:22,310 --> 00:13:26,959
we have on the left-hand side it may

00:13:23,930 --> 00:13:28,370
include other information as well and

00:13:26,959 --> 00:13:30,320
then what we do is we seen this out to a

00:13:28,370 --> 00:13:32,750
net link socket so that user space can

00:13:30,320 --> 00:13:36,320
then determine what it's going to do

00:13:32,750 --> 00:13:37,670
with this flow and this net link socket

00:13:36,320 --> 00:13:39,800
it can actually be configured to be zero

00:13:37,670 --> 00:13:41,450
so if you want to have a default drop

00:13:39,800 --> 00:13:44,149
and don't have a user space game and

00:13:41,450 --> 00:13:45,649
sitting sitting around to handle all

00:13:44,149 --> 00:13:48,200
this you can you can also configure to

00:13:45,649 --> 00:13:55,730
configure it in that way and just

00:13:48,200 --> 00:13:57,589
briefly the the so the the flow gets

00:13:55,730 --> 00:13:59,240
normalized when we send it up starting

00:13:57,589 --> 00:14:01,790
the packet gets normalized so we push on

00:13:59,240 --> 00:14:05,350
the accelerated VLANs we complete checks

00:14:01,790 --> 00:14:08,560
on partial and segment the GSO and so on

00:14:05,350 --> 00:14:11,480
so that alcohol comes up to the user

00:14:08,560 --> 00:14:14,060
userland process we have some sort of

00:14:11,480 --> 00:14:15,800
Sdn controller II thing that determines

00:14:14,060 --> 00:14:18,740
what it is we want to do with these

00:14:15,800 --> 00:14:20,779
packets so in the immediate case that's

00:14:18,740 --> 00:14:23,540
about what do we do with the current

00:14:20,779 --> 00:14:25,339
packet how do we execute it so we sing

00:14:23,540 --> 00:14:26,810
down a Down call back down to the kernel

00:14:25,339 --> 00:14:29,060
when we say execute the set of actions

00:14:26,810 --> 00:14:30,290
on this packet and here's maybe a bit of

00:14:29,060 --> 00:14:33,350
metadata that will help you to do that

00:14:30,290 --> 00:14:35,180
and then of course we've got the flow

00:14:33,350 --> 00:14:37,220
install that we've got before because if

00:14:35,180 --> 00:14:38,480
we don't install a flow then all of the

00:14:37,220 --> 00:14:40,550
traffic would always be forwarded

00:14:38,480 --> 00:14:43,279
through the user space so if we can

00:14:40,550 --> 00:14:46,490
regenerate the the most broad flow to

00:14:43,279 --> 00:14:48,110
insert into the into the kernel so that

00:14:46,490 --> 00:14:50,990
the widest set of traffic will be

00:14:48,110 --> 00:14:52,940
covered by that and then the future

00:14:50,990 --> 00:14:56,930
traffic will all be executed directly in

00:14:52,940 --> 00:14:58,790
the kernel no user space necessary and

00:14:56,930 --> 00:15:00,500
so the execute piece it's fairly

00:14:58,790 --> 00:15:03,230
straightforward it comes down from

00:15:00,500 --> 00:15:05,930
from New Zealand contains these pieces

00:15:03,230 --> 00:15:08,330
we use the metadata and the actions to

00:15:05,930 --> 00:15:10,220
execute on that packet and then

00:15:08,330 --> 00:15:15,290
presumably we send that packet out to

00:15:10,220 --> 00:15:18,140
the on the wire so briefly we describe

00:15:15,290 --> 00:15:19,880
the the datapath family that allows the

00:15:18,140 --> 00:15:21,500
shared flow table the access to the to

00:15:19,880 --> 00:15:25,580
the networking stack to routing and so

00:15:21,500 --> 00:15:26,870
on it's a place to hang ports we have we

00:15:25,580 --> 00:15:31,190
have these virtual ports that we can

00:15:26,870 --> 00:15:32,900
configure and we have the the flow of

00:15:31,190 --> 00:15:34,910
family to describe what we should do in

00:15:32,900 --> 00:15:37,130
the Texas family that that allows use of

00:15:34,910 --> 00:15:38,450
space to to find out what kind of

00:15:37,130 --> 00:15:44,090
traffic we're getting in to populate

00:15:38,450 --> 00:15:45,590
this flow table so there's a few notable

00:15:44,090 --> 00:15:49,090
improvements that have occurred over the

00:15:45,590 --> 00:15:53,000
years so I mentioned mega flows already

00:15:49,090 --> 00:15:55,540
I'll go into each of those briefly so

00:15:53,000 --> 00:15:57,410
our main flows basically allowed us to

00:15:55,540 --> 00:15:59,900
significantly increase our performance

00:15:57,410 --> 00:16:03,290
while decreasing in on a CPU that we use

00:15:59,900 --> 00:16:04,970
to actually get that and so this example

00:16:03,290 --> 00:16:07,250
is from the design and implementation

00:16:04,970 --> 00:16:10,370
above yes paper we put out in in SDI a

00:16:07,250 --> 00:16:11,930
couple of years ago the the flow table

00:16:10,370 --> 00:16:14,390
is relatively simple it handles up and a

00:16:11,930 --> 00:16:17,150
couple of IP matches on particular IP

00:16:14,390 --> 00:16:20,210
addresses and then floats match on TCP

00:16:17,150 --> 00:16:22,040
with some l4 port matching as well so

00:16:20,210 --> 00:16:23,690
with a naive implementation without mega

00:16:22,040 --> 00:16:25,480
flows we were generating something like

00:16:23,690 --> 00:16:28,370
a million different flows in the kernel

00:16:25,480 --> 00:16:30,500
but then with mega flows and also with

00:16:28,370 --> 00:16:33,200
some sensible optimizations in the user

00:16:30,500 --> 00:16:35,480
LAN process we were able to drive up the

00:16:33,200 --> 00:16:37,820
number of masks and and cover all those

00:16:35,480 --> 00:16:39,980
that traffic far better and then

00:16:37,820 --> 00:16:42,830
basically independent if all that

00:16:39,980 --> 00:16:44,540
traffic in the kernel and standard

00:16:42,830 --> 00:16:45,410
disclaimer replies that your software or

00:16:44,540 --> 00:16:49,820
hardware might get different numbers

00:16:45,410 --> 00:16:54,050
there's more details in the paper so the

00:16:49,820 --> 00:16:55,790
alcohol the optical mechanism doesn't

00:16:54,050 --> 00:16:57,470
have to use just one net link socket so

00:16:55,790 --> 00:16:59,060
a lot of the users use multiple in a

00:16:57,470 --> 00:17:01,310
Link sockets and basically use the SKT

00:16:59,060 --> 00:17:02,930
hash to hash across and select one of

00:17:01,310 --> 00:17:06,589
those sockets to actually see in the

00:17:02,930 --> 00:17:08,209
packets opportunity space so this is

00:17:06,589 --> 00:17:10,160
primarily for like a performance or so

00:17:08,209 --> 00:17:13,650
multi-threaded user space program can

00:17:10,160 --> 00:17:15,839
handle these up calls in parallel

00:17:13,650 --> 00:17:17,429
and then there's also a sort of a side

00:17:15,839 --> 00:17:20,640
case which is if there's one particular

00:17:17,429 --> 00:17:22,230
luscious flow then it will end up

00:17:20,640 --> 00:17:24,029
getting cash to a single net link socket

00:17:22,230 --> 00:17:27,720
and hopefully want to see actually are

00:17:24,029 --> 00:17:29,010
the others contract is some work that

00:17:27,720 --> 00:17:30,510
we've done over the last couple of years

00:17:29,010 --> 00:17:34,799
to it to integrate with the natural two

00:17:30,510 --> 00:17:38,820
sub system so what we what we have is a

00:17:34,799 --> 00:17:42,059
in our flow there and in the blue we has

00:17:38,820 --> 00:17:43,590
action which is contract CT and what

00:17:42,059 --> 00:17:45,419
this does is submit to the the Nick

00:17:43,590 --> 00:17:47,250
Seltzer subsystem and then once the Nick

00:17:45,419 --> 00:17:50,120
filters is done during the connection

00:17:47,250 --> 00:17:52,740
tracking it's resubmits back into the

00:17:50,120 --> 00:17:54,600
actions list executing in OBS and we can

00:17:52,740 --> 00:17:56,880
continue processing but with more

00:17:54,600 --> 00:18:03,330
metadata or more knowledge about what

00:17:56,880 --> 00:18:05,789
this connection is actually is useful

00:18:03,330 --> 00:18:08,130
also with this is the recirculate action

00:18:05,789 --> 00:18:09,659
and so this allows us to reclassify the

00:18:08,130 --> 00:18:11,340
packet so once we've submitted to the

00:18:09,659 --> 00:18:13,860
the connection tracker it provides

00:18:11,340 --> 00:18:16,890
information such as whether this

00:18:13,860 --> 00:18:18,510
connection is new or established it may

00:18:16,890 --> 00:18:22,770
provide some marks and labels and other

00:18:18,510 --> 00:18:24,620
metadata and so we're able to reclassify

00:18:22,770 --> 00:18:30,120
that packet based on that new metadata

00:18:24,620 --> 00:18:32,820
and execute that so I want to move on

00:18:30,120 --> 00:18:34,770
into some of the different users of the

00:18:32,820 --> 00:18:38,480
kernel API this is going to include some

00:18:34,770 --> 00:18:40,679
of the CLI tools that we have with OBS I

00:18:38,480 --> 00:18:43,289
obviously have to mention open V switch

00:18:40,679 --> 00:18:45,990
as well it's the primary user that we're

00:18:43,289 --> 00:18:48,539
working on but then there's also several

00:18:45,990 --> 00:18:50,700
other users from the open source

00:18:48,539 --> 00:18:53,730
community and I'm not going to even try

00:18:50,700 --> 00:18:59,909
to to cover the various people that are

00:18:53,730 --> 00:19:02,940
using it beyond that so quickly so from

00:18:59,909 --> 00:19:04,860
the CLI tools so here's like a brief

00:19:02,940 --> 00:19:07,830
example of how to get started with OVS

00:19:04,860 --> 00:19:10,110
without actually running the OBS user

00:19:07,830 --> 00:19:12,029
space obviously switch D process so you

00:19:10,110 --> 00:19:13,890
don't need a user space demon sitting

00:19:12,029 --> 00:19:15,059
and managing all of your flows if you

00:19:13,890 --> 00:19:16,679
know exactly what your forwarding

00:19:15,059 --> 00:19:19,620
behaviour is doing when you can you can

00:19:16,679 --> 00:19:21,240
consider like this and pre-fill what I

00:19:19,620 --> 00:19:23,190
mentioned Aaron can all put out a blog

00:19:21,240 --> 00:19:24,990
post a couple of days ago that goes into

00:19:23,190 --> 00:19:26,170
a bit more detail on how these CLI tools

00:19:24,990 --> 00:19:28,540
work

00:19:26,170 --> 00:19:30,850
and goes through some examples but you

00:19:28,540 --> 00:19:33,160
know I mean we're loading the module we

00:19:30,850 --> 00:19:35,650
have this obvious DP cattle ads DP ad

00:19:33,160 --> 00:19:37,560
data path command that follows the the

00:19:35,650 --> 00:19:41,350
data path description that I had before

00:19:37,560 --> 00:19:44,260
and then we can use EDIS to add an

00:19:41,350 --> 00:19:46,030
interface through that OVS data path

00:19:44,260 --> 00:19:48,130
then on the right hand side I've got

00:19:46,030 --> 00:19:50,140
this like simple example of obvious DP

00:19:48,130 --> 00:19:52,810
Cal show that gives some like high-level

00:19:50,140 --> 00:19:54,910
view of what's going on in the OBS

00:19:52,810 --> 00:19:58,150
kernel module right now so I've got this

00:19:54,910 --> 00:20:00,310
my DP data path that was configured on

00:19:58,150 --> 00:20:02,800
the left I guess in this example I

00:20:00,310 --> 00:20:04,570
actually had a bit of traffic flowing

00:20:02,800 --> 00:20:06,070
through that probably as Connect splenic

00:20:04,570 --> 00:20:08,470
stack and sending some like IP 6

00:20:06,070 --> 00:20:10,150
neighbor just got rid of something and

00:20:08,470 --> 00:20:11,620
so all that traffic actually ended up

00:20:10,150 --> 00:20:13,110
getting missed and lost because we've

00:20:11,620 --> 00:20:16,420
got the default drop when it's

00:20:13,110 --> 00:20:18,760
configured vais fire vs DP cow and

00:20:16,420 --> 00:20:21,040
finally you can see the support 0 that

00:20:18,760 --> 00:20:23,950
is my DP internal port as well as the

00:20:21,040 --> 00:20:28,570
ports 1 & 2 which we configured on the

00:20:23,950 --> 00:20:32,470
land and so here's some basic examples

00:20:28,570 --> 00:20:35,590
about the the flows so we can add some

00:20:32,470 --> 00:20:38,320
flows at natural on our some flows and

00:20:35,590 --> 00:20:39,730
matching on some ICMP obvious DP cattle

00:20:38,320 --> 00:20:41,140
don't flows will tell you actually what

00:20:39,730 --> 00:20:42,790
the flows are there existing in the

00:20:41,140 --> 00:20:44,200
kernel and will provide you statistics

00:20:42,790 --> 00:20:46,150
around packets and bytes and so on and

00:20:44,200 --> 00:20:48,270
so this is really helpful debug tool

00:20:46,150 --> 00:20:51,040
once you've configured OVS to be able to

00:20:48,270 --> 00:20:53,920
determine what what the traffic is

00:20:51,040 --> 00:20:57,490
actually flowing through through the

00:20:53,920 --> 00:21:00,820
kernel module moving on so open V switch

00:20:57,490 --> 00:21:02,080
is the most well known user there's an

00:21:00,820 --> 00:21:04,320
open source community around that we

00:21:02,080 --> 00:21:06,520
support Linux platform we have gbk

00:21:04,320 --> 00:21:09,370
implementation we have a hyper-v and

00:21:06,520 --> 00:21:12,430
we're also supporting two BSD so it's

00:21:09,370 --> 00:21:15,280
sort of a wide range of platforms it's

00:21:12,430 --> 00:21:17,920
actively maintained and supported it

00:21:15,280 --> 00:21:20,470
really what the preps main point of over

00:21:17,920 --> 00:21:22,600
yes or the open V switch daemon and user

00:21:20,470 --> 00:21:25,420
spaces is that it compiles open flow and

00:21:22,600 --> 00:21:29,260
OBS DB down into this OVS knee-length

00:21:25,420 --> 00:21:31,180
api so it provides virtual switching for

00:21:29,260 --> 00:21:32,740
containers in VMs and it's also used as

00:21:31,180 --> 00:21:34,690
a forwarding agent on hardware but it is

00:21:32,740 --> 00:21:38,650
primarily targeted at the software use

00:21:34,690 --> 00:21:39,879
cases middle net is another project

00:21:38,650 --> 00:21:43,299
which uses the

00:21:39,879 --> 00:21:44,889
yes Colonel module API without actually

00:21:43,299 --> 00:21:47,019
using the open V switch user space and

00:21:44,889 --> 00:21:47,679
meadow net is targeted at a lot of

00:21:47,019 --> 00:21:50,049
OpenStack

00:21:47,679 --> 00:21:53,199
sort of use cases you can configure your

00:21:50,049 --> 00:21:55,209
virtual routers or your tenants and and

00:21:53,199 --> 00:21:57,219
how those all connect through the

00:21:55,209 --> 00:21:59,799
OpenStack API is that will boil down

00:21:57,219 --> 00:22:03,909
into the middle net agent which will

00:21:59,799 --> 00:22:06,339
actually insert data paths and flows and

00:22:03,909 --> 00:22:09,219
so on in the OBS kernel module two to

00:22:06,339 --> 00:22:10,749
fold your traffic across that fabric so

00:22:09,219 --> 00:22:15,009
this is probably a bit more like an HD

00:22:10,749 --> 00:22:20,019
in application yeah solving sort of

00:22:15,009 --> 00:22:21,489
OpenStack use cases we've net is another

00:22:20,019 --> 00:22:23,889
one that's quite interesting this was

00:22:21,489 --> 00:22:26,679
targeted more at container environments

00:22:23,889 --> 00:22:30,249
what they do is set up a DX plan tunnel

00:22:26,679 --> 00:22:32,259
mesh across various different hosts to

00:22:30,249 --> 00:22:34,059
connect the containers together and they

00:22:32,259 --> 00:22:37,440
set up some some flows in OVS to be able

00:22:34,059 --> 00:22:42,099
to connect all that forwarding together

00:22:37,440 --> 00:22:47,699
yeah indigo virtual switch is another

00:22:42,099 --> 00:22:51,219
virtual switch put out by the the

00:22:47,699 --> 00:22:53,229
floodlight community and so again this

00:22:51,219 --> 00:22:56,440
is maybe in somewhere in a lot of ways

00:22:53,229 --> 00:22:58,629
to what the open V switch demon tries to

00:22:56,440 --> 00:23:03,519
achieve but it's a bit more focused on

00:22:58,629 --> 00:23:07,809
the hardware platforms so they've got it

00:23:03,519 --> 00:23:08,769
for bare metal switches there as well so

00:23:07,809 --> 00:23:10,839
some of the common threads that I've

00:23:08,769 --> 00:23:13,899
noticed with the different users of the

00:23:10,839 --> 00:23:15,429
open V switch kernel api they're trying

00:23:13,899 --> 00:23:17,649
to integrate well with some of the other

00:23:15,429 --> 00:23:21,639
subsystems and so on in the community

00:23:17,649 --> 00:23:24,789
sorry in the Linux codebase so I mean we

00:23:21,639 --> 00:23:26,979
always make use of lightweight tunneling

00:23:24,789 --> 00:23:28,239
in OBS where we're integrating with the

00:23:26,979 --> 00:23:30,279
next volts or subsystem for all the

00:23:28,239 --> 00:23:31,529
connection tracking when you look at

00:23:30,279 --> 00:23:36,819
something like we've net they're

00:23:31,529 --> 00:23:40,059
applying IP sick annex frm to encrypt

00:23:36,819 --> 00:23:43,089
the traffic between their containers I

00:23:40,059 --> 00:23:44,499
know that meadow net is using HT b OE s

00:23:43,089 --> 00:23:47,889
has a variety of different ways to

00:23:44,499 --> 00:23:50,440
configure the TC to disks and so on for

00:23:47,889 --> 00:23:52,239
quality of service and we're also

00:23:50,440 --> 00:23:53,710
actually looking at for the open V

00:23:52,239 --> 00:23:58,110
switch user space to make you

00:23:53,710 --> 00:23:58,110
the TC flower hog where offloads AP is

00:23:58,320 --> 00:24:04,120
so briefly there's also a point around

00:24:01,330 --> 00:24:05,679
the sort of complexity so this is

00:24:04,120 --> 00:24:07,870
certainly true for the open piece which

00:24:05,679 --> 00:24:10,570
demon where we have an open flow API

00:24:07,870 --> 00:24:13,779
that provides dozens of hundreds of

00:24:10,570 --> 00:24:15,700
tables tens of thousands of priorities

00:24:13,779 --> 00:24:17,740
and the number of flows that you can

00:24:15,700 --> 00:24:23,049
configure at this open flow layer is is

00:24:17,740 --> 00:24:27,970
very large and the traffic makes it many

00:24:23,049 --> 00:24:29,740
many stages many different tables and we

00:24:27,970 --> 00:24:32,049
don't actually want to execute all of

00:24:29,740 --> 00:24:35,590
that logic for a particular packet so

00:24:32,049 --> 00:24:37,630
OVS compiles that logic down into

00:24:35,590 --> 00:24:41,409
basically what is a single work up in

00:24:37,630 --> 00:24:43,149
the OBS kernel API to reduce the the per

00:24:41,409 --> 00:24:48,370
packet cost for actually executing that

00:24:43,149 --> 00:24:50,520
behavior so in summary so if TN really

00:24:48,370 --> 00:24:52,809
has driven the open V switch API

00:24:50,520 --> 00:24:54,039
development around the logically

00:24:52,809 --> 00:24:56,590
centralized packet forwarding behavior

00:24:54,039 --> 00:25:00,279
I've described the obvious net link API

00:24:56,590 --> 00:25:02,620
and I believe that it provides some some

00:25:00,279 --> 00:25:05,080
generally useful primitives and and one

00:25:02,620 --> 00:25:08,020
of the the signs that it's useful is

00:25:05,080 --> 00:25:10,330
that it's not just the OBS user space

00:25:08,020 --> 00:25:12,399
that we provide that is making use of

00:25:10,330 --> 00:25:14,080
this kernel API but we can see there are

00:25:12,399 --> 00:25:15,669
other complete community projects that

00:25:14,080 --> 00:25:20,590
are building on top of this and finding

00:25:15,669 --> 00:25:21,730
it useful obviously built in a way that

00:25:20,590 --> 00:25:23,080
allows you to integrate with other

00:25:21,730 --> 00:25:25,539
kernel functionalities which in the air

00:25:23,080 --> 00:25:27,460
filter and curate and so on and finally

00:25:25,539 --> 00:25:28,929
we were able to minimize the amount of

00:25:27,460 --> 00:25:31,870
code complexity that we put into the

00:25:28,929 --> 00:25:34,120
kernel and put some of that complexity

00:25:31,870 --> 00:25:36,309
into the user space but still have that

00:25:34,120 --> 00:25:38,320
power and that ability to forward

00:25:36,309 --> 00:25:43,200
traffic in the way that the users are

00:25:38,320 --> 00:25:43,200
hoping to do so what do you think

00:25:45,070 --> 00:25:50,060
[Applause]

00:25:46,830 --> 00:25:50,060
[Music]

00:25:57,080 --> 00:26:03,780
hi would it be possible to hook these

00:26:00,180 --> 00:26:05,610
tables and already in like the XDP data

00:26:03,780 --> 00:26:07,560
path to do stuff like the DDoS

00:26:05,610 --> 00:26:09,480
protection that we've heard about yeah

00:26:07,560 --> 00:26:12,270
there's absolutely no reason why you

00:26:09,480 --> 00:26:13,830
couldn't can do that you could I could

00:26:12,270 --> 00:26:16,050
imagine a situation where you have some

00:26:13,830 --> 00:26:17,940
state of Aikido s filters and so on

00:26:16,050 --> 00:26:19,410
existing in HTTP and maybe that's sort

00:26:17,940 --> 00:26:23,250
of like a first layer of protection and

00:26:19,410 --> 00:26:25,770
then when the traffic when the HTTP

00:26:23,250 --> 00:26:27,330
program does like HDD passes it isn't

00:26:25,770 --> 00:26:28,530
able to filter that traffic then it

00:26:27,330 --> 00:26:30,150
proceeds up through the normal

00:26:28,530 --> 00:26:31,740
networking stack and you could configure

00:26:30,150 --> 00:26:33,570
an etsilopp so you configure of yes and

00:26:31,740 --> 00:26:37,370
configure multiple different things

00:26:33,570 --> 00:26:37,370
together and that would work great

00:26:42,940 --> 00:26:50,830
I agree that the open V switch is very

00:26:48,429 --> 00:26:52,570
powerful mechanism and their various

00:26:50,830 --> 00:26:54,729
ways to configure it to have a daemon up

00:26:52,570 --> 00:26:56,679
up there how people said it's static

00:26:54,729 --> 00:26:57,999
rules and everything like that but I

00:26:56,679 --> 00:26:59,679
think that the thing that's considered

00:26:57,999 --> 00:27:01,619
powerful which is the arbitrary masking

00:26:59,679 --> 00:27:04,570
capability is also its greatest weakness

00:27:01,619 --> 00:27:06,090
because as I learned when we're moving

00:27:04,570 --> 00:27:10,330
the routing cache from the kernel that

00:27:06,090 --> 00:27:12,249
allowing traffic to determine population

00:27:10,330 --> 00:27:15,580
events is kind of dangerous

00:27:12,249 --> 00:27:19,029
and in essence denial is serviceable so

00:27:15,580 --> 00:27:20,619
I think that's that's always been a

00:27:19,029 --> 00:27:22,419
fundamental issue I've seen with

00:27:20,619 --> 00:27:25,090
openness pieces yes so so actually

00:27:22,419 --> 00:27:26,289
that's a great point and I think it's

00:27:25,090 --> 00:27:29,169
actually it would be interesting to see

00:27:26,289 --> 00:27:30,849
I think there's the some interest in

00:27:29,169 --> 00:27:34,059
being able to try to address that that

00:27:30,849 --> 00:27:35,529
concern may be you know if if the

00:27:34,059 --> 00:27:37,809
traffic is causing alcohols and

00:27:35,529 --> 00:27:39,309
populating the sampling socket and and

00:27:37,809 --> 00:27:41,379
so on maybe there's a way that we can

00:27:39,309 --> 00:27:43,840
rate limit that other thing I've noticed

00:27:41,379 --> 00:27:46,090
when I look at the examples are actually

00:27:43,840 --> 00:27:49,690
real life scenarios people don't use

00:27:46,090 --> 00:27:51,429
arbitrary masks they use prefixes yeah I

00:27:49,690 --> 00:27:53,019
mean it depends on though if we

00:27:51,429 --> 00:27:54,700
formalize that we could start using

00:27:53,019 --> 00:27:57,009
trees for the lookups and things like

00:27:54,700 --> 00:27:59,739
that instead of having this arbitrary

00:27:57,009 --> 00:28:01,509
prefix kind of situation which is that's

00:27:59,739 --> 00:28:02,979
why IPSec lookups for example are very

00:28:01,509 --> 00:28:04,690
complicated because they use arbitrary

00:28:02,979 --> 00:28:05,830
I'm asking and things like this so

00:28:04,690 --> 00:28:09,190
something I think about

00:28:05,830 --> 00:28:12,070
so absolutely on and I think in some

00:28:09,190 --> 00:28:14,979
ways I think that the flow allows this

00:28:12,070 --> 00:28:16,389
arbitrary mask allows all that power and

00:28:14,979 --> 00:28:18,399
allows them to use that sorry the

00:28:16,389 --> 00:28:21,159
researchers to do some like crazy stuff

00:28:18,399 --> 00:28:22,869
and it's sort of useful in some way for

00:28:21,159 --> 00:28:24,279
that but then when you do start to look

00:28:22,869 --> 00:28:25,840
at implementing something that looks a

00:28:24,279 --> 00:28:27,399
lot more like a traditional Network

00:28:25,840 --> 00:28:29,830
you're doing that with you know your

00:28:27,399 --> 00:28:33,519
prefix lookups and so on so no make

00:28:29,830 --> 00:28:35,480
sense make sense no questions I was

00:28:33,519 --> 00:28:41,660
given a row no clothes

00:28:35,480 --> 00:28:41,660

YouTube URL: https://www.youtube.com/watch?v=8ieoUQI7X88


