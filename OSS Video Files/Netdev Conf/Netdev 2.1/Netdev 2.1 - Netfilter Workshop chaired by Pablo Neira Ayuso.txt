Title: Netdev 2.1 - Netfilter Workshop chaired by Pablo Neira Ayuso
Publication date: 2017-05-03
Playlist: Netdev 2.1
Description: 
	The workshop is a discussion of new Netfilter features and things that have changed since Netdev1.2 Chaired by Pablo Neira Ayuso

Content: https://www.netdevconf.org/2.1/session.html?ayuso
Captions: 
	00:00:00,030 --> 00:00:05,210
so well my name is Pablo I underneath of

00:00:03,090 --> 00:00:07,980
the maintainer and I'm going to

00:00:05,210 --> 00:00:11,700
introduce you to this netfilter

00:00:07,980 --> 00:00:12,840
mini watch presentation I'm going to

00:00:11,700 --> 00:00:15,210
start with summits lights at the

00:00:12,840 --> 00:00:17,220
hospital and then slowly invest a

00:00:15,210 --> 00:00:20,400
Louisville follow-up to discuss some

00:00:17,220 --> 00:00:29,730
ongoing stuff he's basically currently

00:00:20,400 --> 00:00:31,410
working on so so whatever I am I going

00:00:29,730 --> 00:00:34,829
to cover in this presentation basically

00:00:31,410 --> 00:00:37,860
this is not a tutorial so those are new

00:00:34,829 --> 00:00:40,920
to NF stables and head fitter in general

00:00:37,860 --> 00:00:43,320
they are in about a suitor we have a

00:00:40,920 --> 00:00:45,660
well-established documentation based

00:00:43,320 --> 00:00:51,570
available on the internet so that you

00:00:45,660 --> 00:00:54,030
can reach specifically for those already

00:00:51,570 --> 00:00:56,760
we're playing around with IP tables the

00:00:54,030 --> 00:01:00,090
club we know Oscar Andre also and

00:00:56,760 --> 00:01:03,840
documentation it's quite quite extensive

00:01:00,090 --> 00:01:06,479
and it in all specific aspects of IP

00:01:03,840 --> 00:01:09,869
tables we don't have sunset Italian FP

00:01:06,479 --> 00:01:11,820
yet it will be great to have it so so

00:01:09,869 --> 00:01:15,000
far what we have is basically this wiki

00:01:11,820 --> 00:01:16,560
and a table salt or page that we are

00:01:15,000 --> 00:01:19,080
getting some users and developers

00:01:16,560 --> 00:01:22,409
involved in updated this in updating

00:01:19,080 --> 00:01:25,200
this documentation in an in an agile way

00:01:22,409 --> 00:01:27,270
we have also well I made several

00:01:25,200 --> 00:01:31,079
presentations already in the past there

00:01:27,270 --> 00:01:32,490
is a YouTube video that a very cool user

00:01:31,079 --> 00:01:34,110
group in the Netherlands that

00:01:32,490 --> 00:01:36,990
environment it's all about NS tables

00:01:34,110 --> 00:01:39,780
make and it's basically neon a

00:01:36,990 --> 00:01:41,310
whiteboard just type it right writing

00:01:39,780 --> 00:01:44,280
and a key commands and so on and

00:01:41,310 --> 00:01:47,640
explaining the thing and that is also

00:01:44,280 --> 00:01:49,610
the man page that is now quite large

00:01:47,640 --> 00:01:52,649
there has been some debate on on

00:01:49,610 --> 00:01:54,960
splitting it up already so then they

00:01:52,649 --> 00:01:55,979
happen at some point because it's quite

00:01:54,960 --> 00:01:58,380
quite extensive

00:01:55,979 --> 00:02:00,119
it's more like reference I mean as all

00:01:58,380 --> 00:02:02,820
man pages your cell reference does

00:02:00,119 --> 00:02:04,020
engage you need to know more something

00:02:02,820 --> 00:02:08,789
more specifically you go there and you

00:02:04,020 --> 00:02:10,770
take what you need and well all the

00:02:08,789 --> 00:02:13,260
other random documentation that you can

00:02:10,770 --> 00:02:13,920
find out users are starting to write

00:02:13,260 --> 00:02:17,069
about

00:02:13,920 --> 00:02:19,590
so now what is an astable so it's it's a

00:02:17,069 --> 00:02:22,709
replacement for IP IP 6eb

00:02:19,590 --> 00:02:24,750
AFP tables we really see that intended

00:02:22,709 --> 00:02:26,760
to be probably a sign that it's good to

00:02:24,750 --> 00:02:29,849
remove it yesterday I enter in the wiki

00:02:26,760 --> 00:02:33,209
page and I already put that scratch on

00:02:29,849 --> 00:02:34,410
all that intended we have almost 70% of

00:02:33,209 --> 00:02:38,340
the features that we have in IP tables

00:02:34,410 --> 00:02:40,319
and if we if we make any one-to-one

00:02:38,340 --> 00:02:42,420
mapping but we already have more

00:02:40,319 --> 00:02:44,010
features already in Annecy that were not

00:02:42,420 --> 00:02:46,410
available in IP tables actually because

00:02:44,010 --> 00:02:48,989
we are language a new language is way

00:02:46,410 --> 00:02:51,769
more expressive so we are already having

00:02:48,989 --> 00:02:56,610
new features that we didn't have before

00:02:51,769 --> 00:02:59,400
so one of the main features that I would

00:02:56,610 --> 00:03:03,750
like to highlight off NFC is the fact

00:02:59,400 --> 00:03:05,970
that we we provide a generic set

00:03:03,750 --> 00:03:11,340
infrastructure that we can use to make

00:03:05,970 --> 00:03:15,239
maps to build dictionaries and and if I

00:03:11,340 --> 00:03:17,250
mean it requires a is like change in the

00:03:15,239 --> 00:03:19,980
mindset for the user for those that have

00:03:17,250 --> 00:03:22,530
been already using IP set it's probably

00:03:19,980 --> 00:03:26,390
going to be easier but for for others

00:03:22,530 --> 00:03:26,390
and dot basically the idea is that

00:03:27,019 --> 00:03:33,150
defining your policy in in linear rules

00:03:31,709 --> 00:03:35,819
it's not good it's not that you should

00:03:33,150 --> 00:03:39,209
avoid so what you have to do is you have

00:03:35,819 --> 00:03:40,410
to rearrange your rule set to be based

00:03:39,209 --> 00:03:42,630
on the dimensions that you have the

00:03:40,410 --> 00:03:44,609
number of of key selectors that you are

00:03:42,630 --> 00:03:46,590
going to expect in the packet meta

00:03:44,609 --> 00:03:48,959
information or really real information

00:03:46,590 --> 00:03:51,329
in the packet and based on that quickly

00:03:48,959 --> 00:03:57,420
find an action to perform on that all

00:03:51,329 --> 00:03:59,430
that packet so currently the current

00:03:57,420 --> 00:04:01,850
version is an FEC about 70 was relieved

00:03:59,430 --> 00:04:06,480
yes several dates because before

00:04:01,850 --> 00:04:07,069
Christmas NFC 0.8 is cooking it's almost

00:04:06,480 --> 00:04:10,650
ready

00:04:07,069 --> 00:04:13,319
probably release it by when max kernel

00:04:10,650 --> 00:04:17,190
is release or by the time problem let's

00:04:13,319 --> 00:04:18,930
see and and I'm going to cover also

00:04:17,190 --> 00:04:23,000
updates that are going to canvas with

00:04:18,930 --> 00:04:26,000
with a new version in this presentation

00:04:23,000 --> 00:04:26,000
so

00:04:26,310 --> 00:04:30,940
before going up forward I would like to

00:04:29,440 --> 00:04:33,400
show some control my number because

00:04:30,940 --> 00:04:35,199
there have been performance on me being

00:04:33,400 --> 00:04:37,780
shown in this conference and I would

00:04:35,199 --> 00:04:39,910
like just to do a bit of meet nice

00:04:37,780 --> 00:04:42,759
buster we are not so slow okay

00:04:39,910 --> 00:04:44,919
we are not so slow we are if we do

00:04:42,759 --> 00:04:47,740
filtering using this rule from nfe

00:04:44,919 --> 00:04:51,250
ingress we are achieving actually twice

00:04:47,740 --> 00:04:53,289
almost twice and we have to still doing

00:04:51,250 --> 00:04:55,599
this from English I mean if I already

00:04:53,289 --> 00:04:58,240
talked to the on wisdom I would like to

00:04:55,599 --> 00:05:01,599
have a hook in the next index VP so

00:04:58,240 --> 00:05:04,900
people can either use programmable stuff

00:05:01,599 --> 00:05:07,210
or if they are afraid of programming in

00:05:04,900 --> 00:05:08,949
C go Python whatever they can still

00:05:07,210 --> 00:05:11,860
stick to rule based languages this is

00:05:08,949 --> 00:05:14,550
good to them so in that case why we will

00:05:11,860 --> 00:05:16,780
in a filter we will benefit from

00:05:14,550 --> 00:05:18,220
performing these early hook for those

00:05:16,780 --> 00:05:24,430
specific use case that has been

00:05:18,220 --> 00:05:27,580
discussed in this conference so new

00:05:24,430 --> 00:05:29,919
features that we got so we got a new

00:05:27,580 --> 00:05:32,880
expression this tip it basically allows

00:05:29,919 --> 00:05:35,320
us to inquire the forward internet base

00:05:32,880 --> 00:05:36,610
if something that slowly unmade we've

00:05:35,320 --> 00:05:40,270
been discussing about this for a while

00:05:36,610 --> 00:05:42,130
it's actually being very cool feature it

00:05:40,270 --> 00:05:44,800
integrates really well according to what

00:05:42,130 --> 00:05:47,590
we have so basically all the router you

00:05:44,800 --> 00:05:52,120
add through the Nellie interface that we

00:05:47,590 --> 00:05:54,550
have already in the kernel and all that

00:05:52,120 --> 00:05:56,289
database available already in in the in

00:05:54,550 --> 00:06:00,009
the in the step we can it we can use it

00:05:56,289 --> 00:06:04,389
to to perform quiz and the syntax is

00:06:00,009 --> 00:06:07,810
looks it's oh this this is a pointer so

00:06:04,389 --> 00:06:10,690
it's here so basically we have the feed

00:06:07,810 --> 00:06:13,090
that in defies the the instruction and

00:06:10,690 --> 00:06:16,780
that we have a key the possible key that

00:06:13,090 --> 00:06:19,930
we can use is source address this nation

00:06:16,780 --> 00:06:23,919
address mark input interface and output

00:06:19,930 --> 00:06:26,349
interface this source address it can be

00:06:23,919 --> 00:06:27,759
used either for ipv4 ipv6 traffic we

00:06:26,349 --> 00:06:29,979
want to have good integration of

00:06:27,759 --> 00:06:32,650
anything to do all stacks and so on it

00:06:29,979 --> 00:06:33,940
it's it's already well known that we are

00:06:32,650 --> 00:06:36,699
going to Headley actually for this

00:06:33,940 --> 00:06:38,319
deployment for for awhile right so we

00:06:36,699 --> 00:06:40,210
want to keep it easy for

00:06:38,319 --> 00:06:42,360
system is traitors and they don't have

00:06:40,210 --> 00:06:45,729
to keep dealing with all that

00:06:42,360 --> 00:06:48,430
duplication I have seen friends of mine

00:06:45,729 --> 00:06:51,159
in Spain has been shown me very crazy

00:06:48,430 --> 00:06:53,800
scripts to maintain these IP tables and

00:06:51,159 --> 00:06:55,270
IP six tables or rosettes in think that

00:06:53,800 --> 00:06:57,909
sometimes brag of things get

00:06:55,270 --> 00:07:00,430
inconsistent and so on that's something

00:06:57,909 --> 00:07:02,619
that we don't we definitely don't want

00:07:00,430 --> 00:07:06,759
to keep we don't want to keep in that in

00:07:02,619 --> 00:07:10,599
that in that domain okay so these keys

00:07:06,759 --> 00:07:12,219
you can combine them for not not for

00:07:10,599 --> 00:07:15,629
developers so basically we are

00:07:12,219 --> 00:07:18,069
populating the flow we of flow with six

00:07:15,629 --> 00:07:20,499
structuring in the kernel ifs mapping to

00:07:18,069 --> 00:07:22,449
that the content an ancient feature

00:07:20,499 --> 00:07:24,969
basically allows us in the nasty cooking

00:07:22,449 --> 00:07:26,439
to concatenate any kind of any kind of

00:07:24,969 --> 00:07:27,789
key okay

00:07:26,439 --> 00:07:29,050
in this case the number of keys is

00:07:27,789 --> 00:07:31,149
restricted what we are currently

00:07:29,050 --> 00:07:32,830
exposing we have more keys in flow away

00:07:31,149 --> 00:07:35,439
but we just started with something

00:07:32,830 --> 00:07:38,770
simple and it uses can with more use

00:07:35,439 --> 00:07:43,569
cases valid use cases to explore more of

00:07:38,770 --> 00:07:45,309
those fields so over there you get a

00:07:43,569 --> 00:07:47,199
simple condition so basically this is

00:07:45,309 --> 00:07:48,939
going to use the source address and the

00:07:47,199 --> 00:07:51,550
input interface has key to it required

00:07:48,939 --> 00:07:54,879
if it and and then you get data the data

00:07:51,550 --> 00:07:58,779
is the the right side of the map in that

00:07:54,879 --> 00:08:00,969
the feed provides basically and the

00:07:58,779 --> 00:08:03,099
three type of data that you can set that

00:08:00,969 --> 00:08:05,379
is attached to that key that is linked

00:08:03,099 --> 00:08:09,099
to that key is the open interface the

00:08:05,379 --> 00:08:11,979
output interface name so we want to

00:08:09,099 --> 00:08:15,459
handle also a scenario with dynamic

00:08:11,979 --> 00:08:18,009
designing interfaces tab tune and all

00:08:15,459 --> 00:08:22,659
that kind of stuff that just shows up

00:08:18,009 --> 00:08:24,519
and then goes away and so basically the

00:08:22,659 --> 00:08:27,369
name providing provide a persistent way

00:08:24,519 --> 00:08:29,830
to without having to trigger rules or

00:08:27,369 --> 00:08:33,939
updates with without depending in the

00:08:29,830 --> 00:08:37,899
interface in text and we can also match

00:08:33,939 --> 00:08:41,139
based on the other side we basically we

00:08:37,899 --> 00:08:43,569
have unicast log local broadcast and

00:08:41,139 --> 00:08:46,889
cache multicast black hole and vegetable

00:08:43,569 --> 00:08:49,510
and prohibit it's basically mapping to

00:08:46,889 --> 00:08:52,060
to the feed to the phoebus allowing us

00:08:49,510 --> 00:08:55,840
actions some of those right

00:08:52,060 --> 00:08:57,880
black hole or prohibit and the operator

00:08:55,840 --> 00:09:00,190
is have yet shown the most relevant

00:08:57,880 --> 00:09:03,340
operators but our language is very

00:09:00,190 --> 00:09:05,800
expressive and it's not like like

00:09:03,340 --> 00:09:09,730
inactive Abel's where you have one

00:09:05,800 --> 00:09:11,470
extinction where you have built in all

00:09:09,730 --> 00:09:14,339
the things that you can do is that you

00:09:11,470 --> 00:09:18,250
can you can combine things and build and

00:09:14,339 --> 00:09:19,420
and achieve more develop a multiple of

00:09:18,250 --> 00:09:23,800
way to represent the thing through

00:09:19,420 --> 00:09:26,770
through through Maps so most typically

00:09:23,800 --> 00:09:29,290
just to mention the vertical also allows

00:09:26,770 --> 00:09:32,410
us to based on what we find from the

00:09:29,290 --> 00:09:34,300
front a bleep match a value and relate a

00:09:32,410 --> 00:09:38,560
verdict to do to perform on the package

00:09:34,300 --> 00:09:41,430
or simply map just to is the information

00:09:38,560 --> 00:09:43,630
that we get to plug it into another

00:09:41,430 --> 00:09:52,560
internal statement that we have in the

00:09:43,630 --> 00:09:56,970
language so here you can see the list of

00:09:52,560 --> 00:10:05,530
example somehow how you can use the SIP

00:09:56,970 --> 00:10:09,430
expression so basically the first rules

00:10:05,530 --> 00:10:13,300
the first for it so basically the first

00:10:09,430 --> 00:10:15,250
rule there just implement the this

00:10:13,300 --> 00:10:18,370
reverse pass filtering the classic one

00:10:15,250 --> 00:10:20,260
that we have implemented with are we

00:10:18,370 --> 00:10:23,440
with that we perform with the RP sort of

00:10:20,260 --> 00:10:26,380
thing in IP tables and we could also

00:10:23,440 --> 00:10:29,440
filter I mean just say if there is no

00:10:26,380 --> 00:10:31,660
this missing thing is a boolean boolean

00:10:29,440 --> 00:10:33,100
thing that we have that it was still

00:10:31,660 --> 00:10:35,230
suited that it has introduced it quite

00:10:33,100 --> 00:10:38,140
recently we have two possible values

00:10:35,230 --> 00:10:40,540
exist and missing it's basically mapping

00:10:38,140 --> 00:10:43,930
to two it's telling the kernel to to

00:10:40,540 --> 00:10:45,490
just to to tell that I don't want to I

00:10:43,930 --> 00:10:47,680
don't want to specifically the interface

00:10:45,490 --> 00:10:48,640
index to be returned but just tell me if

00:10:47,680 --> 00:10:55,690
there is one or not

00:10:48,640 --> 00:10:57,730
and this all the rule is yes sir to drop

00:10:55,690 --> 00:11:00,910
a packet to the addresses are not

00:10:57,730 --> 00:11:03,820
configure on the interface and the last

00:11:00,910 --> 00:11:04,820
one shows you examples of the British

00:11:03,820 --> 00:11:08,600
maps

00:11:04,820 --> 00:11:11,390
so basically here it's setting is

00:11:08,600 --> 00:11:15,650
setting the packet mark to dead that is

00:11:11,390 --> 00:11:18,140
going to be used in the inquiry that we

00:11:15,650 --> 00:11:19,820
are going to perform v so basically the

00:11:18,140 --> 00:11:22,400
tapas that we use is the destination

00:11:19,820 --> 00:11:24,170
address and this marks and that's based

00:11:22,400 --> 00:11:26,150
on the type of the address that we

00:11:24,170 --> 00:11:28,220
obtained so it's black hole we are going

00:11:26,150 --> 00:11:30,590
to perform some action the packet is

00:11:28,220 --> 00:11:33,650
would require defining this known based

00:11:30,590 --> 00:11:35,660
change is prohibited but basically for

00:11:33,650 --> 00:11:41,210
black hole unreachable we'll just drop

00:11:35,660 --> 00:11:44,750
in packets okay what's next

00:11:41,210 --> 00:11:46,730
so good things about the fit as I said

00:11:44,750 --> 00:11:51,230
it integrates well into what we have

00:11:46,730 --> 00:11:53,420
people are using para or BGP demos quite

00:11:51,230 --> 00:11:55,760
quite massively right in their data

00:11:53,420 --> 00:11:58,910
centers so this there have been users

00:11:55,760 --> 00:12:01,910
asking that finally on just using basic

00:11:58,910 --> 00:12:05,060
new noon feature to integrate this into

00:12:01,910 --> 00:12:07,370
the remote trigger black hole - BGP so

00:12:05,060 --> 00:12:10,250
basically from from the road trip from

00:12:07,370 --> 00:12:12,590
the rather that the three router we are

00:12:10,250 --> 00:12:15,500
going to distribute route to the edge

00:12:12,590 --> 00:12:19,790
routers in case that that is a attacks

00:12:15,500 --> 00:12:21,560
is one of the servers in our network so

00:12:19,790 --> 00:12:23,570
we basically want to avoid that our

00:12:21,560 --> 00:12:27,260
entire network gets flooded so from the

00:12:23,570 --> 00:12:28,670
edge we just black hole that this is

00:12:27,260 --> 00:12:34,130
something that should be easy to

00:12:28,670 --> 00:12:36,260
integrated we could even actually we

00:12:34,130 --> 00:12:38,390
could be good to look at this way

00:12:36,260 --> 00:12:40,670
earlier from ingress this is not

00:12:38,390 --> 00:12:42,320
supported yet but I've been discussing

00:12:40,670 --> 00:12:45,260
these exchanges with Florian yesterday

00:12:42,320 --> 00:12:48,500
and yes a matter of basically dealing

00:12:45,260 --> 00:12:51,530
with the the assumption that it doesn't

00:12:48,500 --> 00:12:53,900
stand anymore in the in the ingress path

00:12:51,530 --> 00:12:55,850
that is that the ipv4 header organs

00:12:53,900 --> 00:12:58,910
Excel may not be linear so it's just a

00:12:55,850 --> 00:13:01,700
matter of using DES key we had a copy

00:12:58,910 --> 00:13:03,860
function that allows us to just to make

00:13:01,700 --> 00:13:05,540
sure that is we have we had a full

00:13:03,860 --> 00:13:09,080
Heather day right so it's very very

00:13:05,540 --> 00:13:11,240
simple change and it will be good to to

00:13:09,080 --> 00:13:13,130
get that match for the next probably we

00:13:11,240 --> 00:13:15,380
can get we can get some of the google

00:13:13,130 --> 00:13:16,950
Summer of Code people are going to join

00:13:15,380 --> 00:13:19,950
us soon into that small

00:13:16,950 --> 00:13:21,750
that can be a good thing to to for them

00:13:19,950 --> 00:13:29,130
so it's basically some good for you new

00:13:21,750 --> 00:13:30,960
people what else um we got a new routing

00:13:29,130 --> 00:13:32,850
expression that allows us to match on

00:13:30,960 --> 00:13:36,090
things in the meta information reserve

00:13:32,850 --> 00:13:39,840
ready attached the SK plus the syntax is

00:13:36,090 --> 00:13:42,240
our key key generic operator and any

00:13:39,840 --> 00:13:45,030
kind expression the expressions can be a

00:13:42,240 --> 00:13:48,180
value but it can be also a map right so

00:13:45,030 --> 00:13:50,460
and keys that we support now is the

00:13:48,180 --> 00:13:56,190
class ID so basically allows us to match

00:13:50,460 --> 00:13:58,020
based on the route of wheel and it

00:13:56,190 --> 00:14:00,510
specifically the user that has

00:13:58,020 --> 00:14:03,300
contributed this update what was very

00:14:00,510 --> 00:14:08,280
interested in interested in knowing the

00:14:03,300 --> 00:14:10,140
next hop right so um just to show you an

00:14:08,280 --> 00:14:12,540
example of course this user had been

00:14:10,140 --> 00:14:15,090
using he was this first rule basically

00:14:12,540 --> 00:14:17,730
he was very concerned about having

00:14:15,090 --> 00:14:20,790
receiving from BGP routes aware not

00:14:17,730 --> 00:14:22,560
correct so he was basically using an FTP

00:14:20,790 --> 00:14:24,810
make sure that he was not getting to

00:14:22,560 --> 00:14:28,380
write the right the wrong route right

00:14:24,810 --> 00:14:31,320
and and then so it's complement

00:14:28,380 --> 00:14:34,020
conformance check basically and and then

00:14:31,320 --> 00:14:36,300
he was also combining the this feature

00:14:34,020 --> 00:14:37,800
this new feature with flow tables so

00:14:36,300 --> 00:14:39,710
tables are basically using the set

00:14:37,800 --> 00:14:42,240
infrastructure that we have in a chronal

00:14:39,710 --> 00:14:46,440
basically what what what is what is this

00:14:42,240 --> 00:14:49,470
does this this command here is flow

00:14:46,440 --> 00:14:52,260
table we we use an a in the name of the

00:14:49,470 --> 00:14:54,750
flow table if you NH from stands for net

00:14:52,260 --> 00:14:56,730
next hop and that set is going to be

00:14:54,750 --> 00:15:02,670
populated with the data that we fetch

00:14:56,730 --> 00:15:04,140
from the RT next hop and every entry

00:15:02,670 --> 00:15:06,450
that is going to be inserted in this

00:15:04,140 --> 00:15:10,130
flow table we have a time out of 10

00:15:06,450 --> 00:15:14,120
minutes and we also attach a counter

00:15:10,130 --> 00:15:16,970
this thing the flow table is basically

00:15:14,120 --> 00:15:19,350
avoiding us to have because in AP tables

00:15:16,970 --> 00:15:21,570
for those that you know that we have

00:15:19,350 --> 00:15:23,940
hash limit right we have received in the

00:15:21,570 --> 00:15:27,330
batch budget to the hashed quota has

00:15:23,940 --> 00:15:29,310
limit hash whatever and and we've been

00:15:27,330 --> 00:15:31,080
stopping that because reasonable

00:15:29,310 --> 00:15:33,270
didn't want to keep bloating the colonel

00:15:31,080 --> 00:15:35,340
with all these Frankenstein combinations

00:15:33,270 --> 00:15:37,200
of all the fishes and can be used so so

00:15:35,340 --> 00:15:39,180
this just provides a flexible way to

00:15:37,200 --> 00:15:40,890
have all those although other

00:15:39,180 --> 00:15:44,910
flexibility that was that was lacking

00:15:40,890 --> 00:15:47,339
the next day was line we could obviously

00:15:44,910 --> 00:15:49,740
obviously also dumped the flow table

00:15:47,339 --> 00:15:52,560
here you have and then you get the list

00:15:49,740 --> 00:15:54,450
of elements the counters right and here

00:15:52,560 --> 00:15:56,730
it's missing it this is because of the

00:15:54,450 --> 00:15:59,670
copy and paste it should be a time out

00:15:56,730 --> 00:16:01,830
their price it's a mistake probably I

00:15:59,670 --> 00:16:03,140
made when making these like sorry about

00:16:01,830 --> 00:16:07,350
that

00:16:03,140 --> 00:16:09,480
so what else no track this is very

00:16:07,350 --> 00:16:12,420
simple one it's been missing for a while

00:16:09,480 --> 00:16:16,430
and it seems to be very important for

00:16:12,420 --> 00:16:19,230
users there are users basically

00:16:16,430 --> 00:16:22,170
indicating that for some traffic they

00:16:19,230 --> 00:16:23,940
don't want to do a stateful filtering

00:16:22,170 --> 00:16:26,339
okay they don't want little one

00:16:23,940 --> 00:16:29,339
contracting so we just have a very

00:16:26,339 --> 00:16:32,430
simple one it as you can see it's yes

00:16:29,339 --> 00:16:33,900
you just specify here no track this rule

00:16:32,430 --> 00:16:37,770
is basically telling that all traffic

00:16:33,900 --> 00:16:40,440
going to port 80 is not going to be it's

00:16:37,770 --> 00:16:44,730
not going to be contracted okay this one

00:16:40,440 --> 00:16:47,190
is simple one and it's important as

00:16:44,730 --> 00:16:50,970
needs to be if you happen before

00:16:47,190 --> 00:16:52,380
priority 300 that is where we have where

00:16:50,970 --> 00:16:56,430
the connection tracking hook is

00:16:52,380 --> 00:16:58,560
registered and we want to have talking

00:16:56,430 --> 00:17:00,300
about priorities something that people

00:16:58,560 --> 00:17:01,770
have been asking all the mailing list so

00:17:00,300 --> 00:17:03,480
they don't have to keep all these

00:17:01,770 --> 00:17:06,120
numbers really not prettier it's not

00:17:03,480 --> 00:17:10,400
priority numbers in their head so we

00:17:06,120 --> 00:17:13,589
could introduce labels that provide the

00:17:10,400 --> 00:17:16,170
default priority for many of these

00:17:13,589 --> 00:17:19,380
chains that we have inevitable so should

00:17:16,170 --> 00:17:21,720
be easy easier to keep in mind when this

00:17:19,380 --> 00:17:23,699
is something to that we would like to

00:17:21,720 --> 00:17:26,839
have - we don't have it so far

00:17:23,699 --> 00:17:31,950
and another extension is the coder

00:17:26,839 --> 00:17:34,890
extension this coder only supports

00:17:31,950 --> 00:17:37,350
packet-based coders at this stage but it

00:17:34,890 --> 00:17:37,710
should be AB sorry byte by byte based

00:17:37,350 --> 00:17:40,440
coder

00:17:37,710 --> 00:17:42,390
it should be easy to implement for the

00:17:40,440 --> 00:17:47,610
two extended support

00:17:42,390 --> 00:17:50,309
bass and it's the syntax is quota the

00:17:47,610 --> 00:17:55,440
over thing yes tell me tell tell tell

00:17:50,309 --> 00:17:58,200
tell identity if you want to match if

00:17:55,440 --> 00:18:01,140
the if the porta if you go over quota of

00:17:58,200 --> 00:18:04,440
if you if you don't specify it's going

00:18:01,140 --> 00:18:08,280
to match if you are under water okay

00:18:04,440 --> 00:18:13,410
that is the default behavior and then we

00:18:08,280 --> 00:18:17,940
have to specify a value a unit and this

00:18:13,410 --> 00:18:20,720
unit can be byte megabytes or so far I

00:18:17,940 --> 00:18:23,820
think it's this will be supporting and

00:18:20,720 --> 00:18:25,890
and as I said before we could combine

00:18:23,820 --> 00:18:28,049
these new quota extensions that you

00:18:25,890 --> 00:18:30,780
don't have to add like in AP tables one

00:18:28,049 --> 00:18:34,020
rule very very important you want to

00:18:30,780 --> 00:18:36,210
enforce and so this is basically

00:18:34,020 --> 00:18:40,980
permitting this hash quota thing we are

00:18:36,210 --> 00:18:43,440
going to add in this HTTP table based on

00:18:40,980 --> 00:18:46,890
the source address we add a timeout and

00:18:43,440 --> 00:18:50,400
we we set a quota of 50 megabytes for

00:18:46,890 --> 00:18:59,580
that given slow it's a slow based way to

00:18:50,400 --> 00:19:03,090
define quota the payload is not new one

00:18:59,580 --> 00:19:06,179
it has a 60 it has existed since the

00:19:03,090 --> 00:19:08,400
beginning but it has been extended to

00:19:06,179 --> 00:19:12,150
deal with something that users has been

00:19:08,400 --> 00:19:13,679
asking for is that basically if people

00:19:12,150 --> 00:19:15,299
wanted to have some way of to perform

00:19:13,679 --> 00:19:16,980
its platelet snap there are some

00:19:15,299 --> 00:19:19,290
scenarios where this is valid a bit

00:19:16,980 --> 00:19:21,660
tricky I mean this say that not you have

00:19:19,290 --> 00:19:23,700
to be careful with anything it's easy to

00:19:21,660 --> 00:19:27,120
shoot yourself and your own seed right

00:19:23,700 --> 00:19:29,400
so but for very specific scenarios like

00:19:27,120 --> 00:19:31,740
load balancing it really makes sense and

00:19:29,400 --> 00:19:33,120
we we provide a more like way to do

00:19:31,740 --> 00:19:35,250
neither and then the full-blown

00:19:33,120 --> 00:19:36,809
connection tracking thing for example

00:19:35,250 --> 00:19:39,750
they are scenarios where what you only

00:19:36,809 --> 00:19:40,980
want to you're going to see traffic

00:19:39,750 --> 00:19:44,040
going in one direction right

00:19:40,980 --> 00:19:45,630
so even contract is not going to be very

00:19:44,040 --> 00:19:48,270
good at that because we will have an

00:19:45,630 --> 00:19:51,030
entry in year state with a very long

00:19:48,270 --> 00:19:53,429
time out and what we in tell it what

00:19:51,030 --> 00:19:55,640
we've been telling user so far is that

00:19:53,429 --> 00:19:58,040
you write a time out as a way to work

00:19:55,640 --> 00:19:58,910
it's very ugly so that doesn't need to

00:19:58,040 --> 00:20:04,190
happen anymore

00:19:58,910 --> 00:20:06,860
and it's very simple syntax is basically

00:20:04,190 --> 00:20:09,080
IP software destination address and set

00:20:06,860 --> 00:20:10,850
and unit and the expression that can be

00:20:09,080 --> 00:20:13,340
a value again I've mapped the deep black

00:20:10,850 --> 00:20:16,670
so you just look up quickly based on

00:20:13,340 --> 00:20:21,260
some key what IP address you want to

00:20:16,670 --> 00:20:23,900
apply this shows one example where

00:20:21,260 --> 00:20:26,600
basically the source address is going to

00:20:23,900 --> 00:20:30,170
be set based on known gen this

00:20:26,600 --> 00:20:31,370
generation this number generation it's

00:20:30,170 --> 00:20:35,360
basically telling that do it

00:20:31,370 --> 00:20:38,740
incrementally unbounded to up to two so

00:20:35,360 --> 00:20:45,640
if you are counting 0 1 0 1 2 1 and

00:20:38,740 --> 00:20:49,970
based on that we are going to set the

00:20:45,640 --> 00:20:52,070
the source address okay actually this

00:20:49,970 --> 00:20:54,050
example I wanted to use this nation

00:20:52,070 --> 00:20:57,110
address that makes more sense for load

00:20:54,050 --> 00:21:03,560
balancing ok so just another mistake

00:20:57,110 --> 00:21:06,680
there more updates so we have a net lock

00:21:03,560 --> 00:21:07,870
infrastructure that has been there for a

00:21:06,680 --> 00:21:12,260
long long time

00:21:07,870 --> 00:21:15,710
it relies on on the kernel log like in a

00:21:12,260 --> 00:21:19,700
log buffer so that all those P P R and

00:21:15,710 --> 00:21:21,800
the score thing it just prints the

00:21:19,700 --> 00:21:26,180
target in a human readable way it's

00:21:21,800 --> 00:21:27,260
something that users it has its own

00:21:26,180 --> 00:21:28,940
problems but users

00:21:27,260 --> 00:21:30,320
seems to like it because it reduces the

00:21:28,940 --> 00:21:32,150
amount and infrastructure that you can

00:21:30,320 --> 00:21:33,650
keep you don't need to keep a user

00:21:32,150 --> 00:21:35,780
demand user space we have also you know

00:21:33,650 --> 00:21:38,990
D - you probably know that it's way more

00:21:35,780 --> 00:21:41,750
flexible and that that is not sending

00:21:38,990 --> 00:21:44,180
locks through the kernel log buffer it's

00:21:41,750 --> 00:21:46,580
using that link and so the user space

00:21:44,180 --> 00:21:48,380
demin basically received those log

00:21:46,580 --> 00:21:50,900
events and and it's going to

00:21:48,380 --> 00:21:53,530
representing it in the way that the user

00:21:50,900 --> 00:21:55,700
needs as I said very flexible you can

00:21:53,530 --> 00:21:57,500
represent the packaging in very

00:21:55,700 --> 00:21:59,330
different outputs and so on or even

00:21:57,500 --> 00:22:03,260
decide to place that block method

00:21:59,330 --> 00:22:05,960
somewhere else so but it is something

00:22:03,260 --> 00:22:07,540
that users has been asking so and it was

00:22:05,960 --> 00:22:14,230
very easy to do too

00:22:07,540 --> 00:22:16,240
and so basically here just after this

00:22:14,230 --> 00:22:19,150
update this little small update we can

00:22:16,240 --> 00:22:21,880
just log we can easily native log and

00:22:19,150 --> 00:22:23,350
perfect and we are going to obtain this

00:22:21,880 --> 00:22:26,020
kind of locked messages but you probably

00:22:23,350 --> 00:22:27,730
already know there is another update

00:22:26,020 --> 00:22:31,720
that happened it was Mitchell Cooper

00:22:27,730 --> 00:22:37,660
check he was pushing this for a while

00:22:31,720 --> 00:22:38,800
he's got basically people that I wanted

00:22:37,660 --> 00:22:44,130
to use this in controlled environments

00:22:38,800 --> 00:22:46,900
with containers with namespaces and this

00:22:44,130 --> 00:22:49,330
login was disabled for security reasons

00:22:46,900 --> 00:22:54,220
so one of the containers could not spam

00:22:49,330 --> 00:22:59,740
and we cannot log log buffer so

00:22:54,220 --> 00:23:02,080
basically they said toggle now that you

00:22:59,740 --> 00:23:04,930
can switch on and so you are going to

00:23:02,080 --> 00:23:07,030
get from all namespaces you are going to

00:23:04,930 --> 00:23:10,000
get all of those log messages that are

00:23:07,030 --> 00:23:13,980
trigger also very small incremental

00:23:10,000 --> 00:23:13,980
update oh no this is not okay

00:23:14,160 --> 00:23:18,370
connection tracking update this is work

00:23:16,090 --> 00:23:22,870
that slogan has been performing in this

00:23:18,370 --> 00:23:24,640
sill so basically we used to have we

00:23:22,870 --> 00:23:26,140
used to have two fills to represent the

00:23:24,640 --> 00:23:30,190
connection tracking information in the

00:23:26,140 --> 00:23:32,710
SK bus on different cache lines the NFC

00:23:30,190 --> 00:23:36,100
T info was only three bits actually we

00:23:32,710 --> 00:23:38,740
only need we only need five we have five

00:23:36,100 --> 00:23:41,890
combinations it's me with reply doesn't

00:23:38,740 --> 00:23:46,180
make sense so it's near stablish so this

00:23:41,890 --> 00:23:49,630
reply related related reply okay so we

00:23:46,180 --> 00:23:53,460
need three bits and we have the sk b and

00:23:49,630 --> 00:23:56,980
NFC t pointer to the contract object and

00:23:53,460 --> 00:24:00,310
so the solution that that so you have

00:23:56,980 --> 00:24:02,970
sub stream is basically rename what we

00:24:00,310 --> 00:24:06,130
have to rename that to sk b and a

00:24:02,970 --> 00:24:08,920
underscore CT and we are going to

00:24:06,130 --> 00:24:13,510
restore those three B that we have in

00:24:08,920 --> 00:24:15,250
NFC t info into the pointer into the

00:24:13,510 --> 00:24:17,710
pointer that we have that we used to

00:24:15,250 --> 00:24:20,840
store the contract object so the trick

00:24:17,710 --> 00:24:23,270
here is to make sure that the

00:24:20,840 --> 00:24:26,150
memories monument allocates objects at

00:24:23,270 --> 00:24:27,590
eight bytes that is basically similar to

00:24:26,150 --> 00:24:36,679
the trick that we were already using

00:24:27,590 --> 00:24:38,779
using an in KB DST right so he has also

00:24:36,679 --> 00:24:40,970
removed the contract timer now we have a

00:24:38,779 --> 00:24:44,120
garbage collector it's basically I work

00:24:40,970 --> 00:24:47,720
here it's sweeping the the connection

00:24:44,120 --> 00:24:51,770
tracking table we don't need this struct

00:24:47,720 --> 00:24:54,020
timer anymore and also he has removed

00:24:51,770 --> 00:24:56,750
this is this item is actually not like

00:24:54,020 --> 00:25:01,700
there should be should be out of head

00:24:56,750 --> 00:25:03,860
anyway so he has also converted the hash

00:25:01,700 --> 00:25:07,309
table that we have in that by address

00:25:03,860 --> 00:25:10,580
has tabled by by the researchable hash

00:25:07,309 --> 00:25:14,110
table in the arch RH at least variant

00:25:10,580 --> 00:25:16,370
that allows allows having several

00:25:14,110 --> 00:25:19,720
elements with the same that can be

00:25:16,370 --> 00:25:23,600
identified with the same couple okay so

00:25:19,720 --> 00:25:26,809
and and what the result is have

00:25:23,600 --> 00:25:30,770
according to some reports that we have

00:25:26,809 --> 00:25:34,520
receive is we will talk is that we some

00:25:30,770 --> 00:25:36,770
some users are observing half half less

00:25:34,520 --> 00:25:38,990
CPU consumption that's before after all

00:25:36,770 --> 00:25:41,750
these changes so this is going to have

00:25:38,990 --> 00:25:48,080
any impact on on performance is going to

00:25:41,750 --> 00:25:52,490
get it better obviously so what else the

00:25:48,080 --> 00:25:54,309
the hooks that we have basically two

00:25:52,490 --> 00:25:58,010
hooks in the coefficient wrapping system

00:25:54,309 --> 00:26:01,760
he's playing that right so so I can skip

00:25:58,010 --> 00:26:03,919
the details so so those those hooks are

00:26:01,760 --> 00:26:09,039
ready sir whenever contract the control

00:26:03,919 --> 00:26:15,440
module was installed since we have now

00:26:09,039 --> 00:26:16,909
pertinent namespace hooks and and we

00:26:15,440 --> 00:26:20,600
don't necessarily need to release them

00:26:16,909 --> 00:26:23,210
for them all just because one need them

00:26:20,600 --> 00:26:25,539
right it has a it has a performance

00:26:23,210 --> 00:26:28,970
impact on place so what we can do is

00:26:25,539 --> 00:26:31,740
avoid that who cause voice keep the hook

00:26:28,970 --> 00:26:34,980
registration by

00:26:31,740 --> 00:26:36,659
by only registering on demand based on

00:26:34,980 --> 00:26:39,809
what we have from the policy so if the

00:26:36,659 --> 00:26:41,850
policy indicates that the staple

00:26:39,809 --> 00:26:44,789
filtering needs to happen for some

00:26:41,850 --> 00:26:47,460
reason and the fragmentation also

00:26:44,789 --> 00:26:50,940
because some of the existing stations

00:26:47,460 --> 00:26:52,799
needed so for example forty proxy not

00:26:50,940 --> 00:26:54,840
only for say for suturing so in that

00:26:52,799 --> 00:26:57,750
case we are going to get the hooks

00:26:54,840 --> 00:26:59,820
register so so this early this is going

00:26:57,750 --> 00:27:04,470
to only have an impact in the in the

00:26:59,820 --> 00:27:06,299
people that needed the OTP light code

00:27:04,470 --> 00:27:09,870
was basically a copy on phase of the UDP

00:27:06,299 --> 00:27:12,870
connection tracking halter and just like

00:27:09,870 --> 00:27:15,809
we do in the stacks it has been

00:27:12,870 --> 00:27:19,409
basically removed and we have we got

00:27:15,809 --> 00:27:21,840
Soyoung gaudí the the bits match to the

00:27:19,409 --> 00:27:25,640
little pizza that differ from from the

00:27:21,840 --> 00:27:28,919
from the UDP and now STP is not built in

00:27:25,640 --> 00:27:32,580
the sea no problem I mean we took a

00:27:28,919 --> 00:27:38,070
clutch time ago I took about time ago

00:27:32,580 --> 00:27:40,890
that because some people have security

00:27:38,070 --> 00:27:45,000
concerns on the following scenario is

00:27:40,890 --> 00:27:48,679
basically if you have a CD be flows and

00:27:45,000 --> 00:27:53,580
you forgot to mob broke the NF contract

00:27:48,679 --> 00:27:56,340
SCDP tracker construct was defaulting on

00:27:53,580 --> 00:27:59,159
the division D generic we have a generic

00:27:56,340 --> 00:28:04,230
protocol tracker doing some very very

00:27:59,159 --> 00:28:06,510
basic tracking just making sure that

00:28:04,230 --> 00:28:08,039
just annotating if we have seen traffic

00:28:06,510 --> 00:28:11,730
in both directions

00:28:08,039 --> 00:28:13,649
we have so we can keep some minimal set

00:28:11,730 --> 00:28:15,570
of states to perform this type of

00:28:13,649 --> 00:28:18,980
filtering right so basically if if you

00:28:15,570 --> 00:28:25,080
were you forgot to multiple this this

00:28:18,980 --> 00:28:29,909
trucker and you were having STD flows

00:28:25,080 --> 00:28:32,640
and after that touch the SDP flows were

00:28:29,909 --> 00:28:34,590
reacted basically this dispatch with the

00:28:32,640 --> 00:28:39,929
we tube for security concerns is was

00:28:34,590 --> 00:28:42,600
dropping traffic if if there is a better

00:28:39,929 --> 00:28:45,000
module available it I mean for example

00:28:42,600 --> 00:28:45,639
if there is an SDP helper connection

00:28:45,000 --> 00:28:48,219
tracking in

00:28:45,639 --> 00:28:51,159
a protocol helper and it was no loaded

00:28:48,219 --> 00:28:52,719
and so in some ways it was that way uses

00:28:51,159 --> 00:28:55,659
complaining that it was practiced this

00:28:52,719 --> 00:28:58,179
was breaking the current set up so so

00:28:55,659 --> 00:29:01,559
this is one of the solutions the one

00:28:58,179 --> 00:29:06,429
that we had up today that just plays SVP

00:29:01,559 --> 00:29:08,889
built-in and also this was also it's all

00:29:06,429 --> 00:29:12,159
been fixing addressing complaints from

00:29:08,889 --> 00:29:15,399
people that seems to be using a CDP and

00:29:12,159 --> 00:29:19,359
I'm going to point this small home

00:29:15,399 --> 00:29:23,229
routers at the cost for break-in SDP I

00:29:19,359 --> 00:29:26,349
guess that other ISPs and telcos are

00:29:23,229 --> 00:29:30,429
probably blame but just to make sure

00:29:26,349 --> 00:29:32,259
that any of the Linux base the filter

00:29:30,429 --> 00:29:35,589
base routers out there that are quite a

00:29:32,259 --> 00:29:38,679
lot of them so just just provide a good

00:29:35,589 --> 00:29:42,789
default so to see if this improve the

00:29:38,679 --> 00:29:43,989
situation anyway so what else the

00:29:42,789 --> 00:29:47,799
infrastructure that we got is name

00:29:43,989 --> 00:29:51,009
objects we had these already in IP

00:29:47,799 --> 00:29:54,909
tables the name of this infrastructure

00:29:51,009 --> 00:29:57,099
in every table 6 NS ax it's the original

00:29:54,909 --> 00:30:01,869
names the IP table extend an accounting

00:29:57,099 --> 00:30:04,599
infrastructure it was basically having

00:30:01,869 --> 00:30:07,029
its own has it has its own netting

00:30:04,599 --> 00:30:09,820
interface that has his problems because

00:30:07,029 --> 00:30:13,149
IP tables is not having a native nailing

00:30:09,820 --> 00:30:16,209
interface and in fact is so it doesn't

00:30:13,149 --> 00:30:18,579
really integrates grade but it's okay

00:30:16,209 --> 00:30:21,969
but it was ok for for what we needed at

00:30:18,579 --> 00:30:25,329
a time so it's been already six seven

00:30:21,969 --> 00:30:28,629
years I think since then so basically

00:30:25,329 --> 00:30:32,019
this infrastructure allows us to create

00:30:28,629 --> 00:30:33,339
named counters why these name counters

00:30:32,019 --> 00:30:36,700
because there were people complaining

00:30:33,339 --> 00:30:40,479
that that polling polling the rule said

00:30:36,700 --> 00:30:47,499
to stretch counters what was a real

00:30:40,479 --> 00:30:50,440
hasten right so the so when arguing on

00:30:47,499 --> 00:30:51,879
on this feature the final conclusion we

00:30:50,440 --> 00:30:53,889
got is that it would be good to have

00:30:51,879 --> 00:30:58,279
objects that we can refer to names right

00:30:53,889 --> 00:31:00,590
we just started with counters right so

00:30:58,279 --> 00:31:02,960
and this ended this this resulted in a

00:31:00,590 --> 00:31:07,609
very simple tool is an attack ad and the

00:31:02,960 --> 00:31:10,309
name of the counter you want then you

00:31:07,609 --> 00:31:14,299
could leave sixteen counters and you can

00:31:10,309 --> 00:31:18,309
perform also atomic jump and reset then

00:31:14,299 --> 00:31:21,320
from IP tables you require one rule to

00:31:18,309 --> 00:31:23,330
reference for each object that obviously

00:31:21,320 --> 00:31:28,009
has scalability problems right

00:31:23,330 --> 00:31:30,879
and later on Leonardo and needed to have

00:31:28,009 --> 00:31:34,519
quota so this calls this code was grown

00:31:30,879 --> 00:31:38,149
support named quotas and it specifically

00:31:34,519 --> 00:31:42,320
also any feature that allows and in fact

00:31:38,149 --> 00:31:49,940
to to report when the quota is what the

00:31:42,320 --> 00:31:52,129
quota has expired so Fred first thought

00:31:49,940 --> 00:31:54,950
was can we bring you this infrastructure

00:31:52,129 --> 00:31:56,239
foreigners tables and it was not very

00:31:54,950 --> 00:31:58,099
easy it's not very easy to do

00:31:56,239 --> 00:32:00,019
specifically because in NFT we have a

00:31:58,099 --> 00:32:01,969
two-phase commit protocol that allows us

00:32:00,019 --> 00:32:08,330
to perform atomic incremental updates

00:32:01,969 --> 00:32:09,619
over net link okay so um it was not I

00:32:08,330 --> 00:32:13,759
mean I started hacking on that it was

00:32:09,619 --> 00:32:16,539
not looks nice okay so so and also NF AK

00:32:13,759 --> 00:32:19,219
was grown code we just started with with

00:32:16,539 --> 00:32:20,989
stateful counters with a name it was not

00:32:19,219 --> 00:32:23,419
envisioned to have anything else that

00:32:20,989 --> 00:32:24,529
you know people they took we took a

00:32:23,419 --> 00:32:27,559
while discussing how to accommodate

00:32:24,529 --> 00:32:30,259
quotas there we managed it took a little

00:32:27,559 --> 00:32:33,080
while but it's it was upstream long time

00:32:30,259 --> 00:32:34,940
ago so but then some more people follow

00:32:33,080 --> 00:32:36,739
on and said I would like to have control

00:32:34,940 --> 00:32:39,320
or more stateful objects that we want to

00:32:36,739 --> 00:32:41,779
have for example if I set some rate

00:32:39,320 --> 00:32:44,599
limit after do you go over you go over

00:32:41,779 --> 00:32:46,820
some quota and given quota I want to

00:32:44,599 --> 00:32:49,519
apply some something great let me the

00:32:46,820 --> 00:32:54,529
kind of things that telcos are doing

00:32:49,519 --> 00:33:00,619
well so so it will be good to support

00:32:54,529 --> 00:33:04,009
other objects and again for any fact we

00:33:00,619 --> 00:33:07,339
could only we could only add we could

00:33:04,009 --> 00:33:09,910
only add one rule to refer to objects so

00:33:07,339 --> 00:33:12,370
we were we were kind of

00:33:09,910 --> 00:33:13,570
taking that that limitations that we

00:33:12,370 --> 00:33:15,670
have for an IP table that obvious

00:33:13,570 --> 00:33:17,830
obviously is I don't know no way out we

00:33:15,670 --> 00:33:20,710
don't go of that okay we want to use

00:33:17,830 --> 00:33:23,290
maps intensively and that has to I mean

00:33:20,710 --> 00:33:25,900
if you sir it's optional up to user but

00:33:23,290 --> 00:33:28,420
as soon as the user changes its mind set

00:33:25,900 --> 00:33:31,770
it should be it should be taking

00:33:28,420 --> 00:33:35,290
advantage front on your feature okay so

00:33:31,770 --> 00:33:37,900
new infrastructure but its generic one

00:33:35,290 --> 00:33:41,410
okay so basically we got three new

00:33:37,900 --> 00:33:43,720
commands for NS tables and these new

00:33:41,410 --> 00:33:46,150
commands allows us to create to add to

00:33:43,720 --> 00:33:47,170
the lead and get objects named objects

00:33:46,150 --> 00:33:48,850
okay

00:33:47,170 --> 00:33:50,710
the original part was referring to this

00:33:48,850 --> 00:33:52,690
to a stateful objects but now they are

00:33:50,710 --> 00:33:54,910
just named objects we clear we are also

00:33:52,690 --> 00:33:56,770
accommodating some stainless objects

00:33:54,910 --> 00:34:00,550
I'll explain you why in a follow-up

00:33:56,770 --> 00:34:02,170
follow-up slide okay so we have

00:34:00,550 --> 00:34:03,550
infrastructure to register these new

00:34:02,170 --> 00:34:05,830
object we have a structure they're

00:34:03,550 --> 00:34:09,310
basically model how the object looks

00:34:05,830 --> 00:34:13,410
like it's a it's an tell me describe me

00:34:09,310 --> 00:34:15,490
what this object ID is it's basically

00:34:13,410 --> 00:34:17,500
extending the net link interface that we

00:34:15,490 --> 00:34:20,650
have adding the attributes that describe

00:34:17,500 --> 00:34:22,690
the describe those objects and we have a

00:34:20,650 --> 00:34:24,640
valve evaluation fraction that is come

00:34:22,690 --> 00:34:28,720
from the package back okay so every time

00:34:24,640 --> 00:34:30,730
every time a packet gets hit that object

00:34:28,720 --> 00:34:33,640
the action that we perform the package

00:34:30,730 --> 00:34:36,370
is has been there okay so what we have

00:34:33,640 --> 00:34:40,360
now is counter and photo support we

00:34:36,370 --> 00:34:43,150
should be very easy to to extend this to

00:34:40,360 --> 00:34:46,000
support great limit and we could have

00:34:43,150 --> 00:34:50,860
all sort of stateful objects or any kind

00:34:46,000 --> 00:34:52,900
of object that could be useful to to to

00:34:50,860 --> 00:34:58,690
be to be referenced from the rule set

00:34:52,900 --> 00:35:00,460
okay what else so this is showing just

00:34:58,690 --> 00:35:03,010
an example so basically we have act a

00:35:00,460 --> 00:35:05,500
command that you can use to to add new

00:35:03,010 --> 00:35:08,350
object this is our counter to the

00:35:05,500 --> 00:35:10,990
context counters they are tables in NS

00:35:08,350 --> 00:35:13,150
tables are already top-level object

00:35:10,990 --> 00:35:15,340
infrastructure is the container object

00:35:13,150 --> 00:35:17,830
right so everything everything has to be

00:35:15,340 --> 00:35:21,310
conveniently so we have this container

00:35:17,830 --> 00:35:23,440
this discounters object that is the name

00:35:21,310 --> 00:35:27,400
is HTTP traffic you can use any random

00:35:23,440 --> 00:35:29,680
okay so I can also add in a quota you

00:35:27,400 --> 00:35:31,960
can use the same name for the same for

00:35:29,680 --> 00:35:33,970
two different object times that was

00:35:31,960 --> 00:35:38,319
something that also was requested

00:35:33,970 --> 00:35:40,240
because ideally you would probably use

00:35:38,319 --> 00:35:43,180
if this actually represents a user

00:35:40,240 --> 00:35:44,530
you're mapping these two users to the to

00:35:43,180 --> 00:35:47,050
the limitation that you apply to your

00:35:44,530 --> 00:35:48,970
are giving users so you have user number

00:35:47,050 --> 00:35:51,099
blah blah blah and you use the same name

00:35:48,970 --> 00:35:56,710
for all objects that you have right and

00:35:51,099 --> 00:35:58,869
then you could do the iptables way so

00:35:56,710 --> 00:36:02,619
the average tables way is basically just

00:35:58,869 --> 00:36:06,040
use one single rule for this but this as

00:36:02,619 --> 00:36:10,180
I said this has this poses a scalability

00:36:06,040 --> 00:36:12,250
problem so we can use it with web Maps I

00:36:10,180 --> 00:36:15,579
didn't create this explicitly but you

00:36:12,250 --> 00:36:17,200
can you figure out right what you have

00:36:15,579 --> 00:36:21,069
to do to create this object it shouldn't

00:36:17,200 --> 00:36:23,280
be hard line so here what we have is a

00:36:21,069 --> 00:36:25,960
mapping between based on the TCP

00:36:23,280 --> 00:36:30,160
definition port so based on what we

00:36:25,960 --> 00:36:35,190
match here we are going to use the

00:36:30,160 --> 00:36:37,960
respective object okay good

00:36:35,190 --> 00:36:42,940
this can be also used from from from

00:36:37,960 --> 00:36:45,640
from from a dynamic set or sets can be

00:36:42,940 --> 00:36:47,890
updating runtime right not not only this

00:36:45,640 --> 00:36:50,410
constant we call them animals they are

00:36:47,890 --> 00:36:54,730
not animals they have it's actually the

00:36:50,410 --> 00:36:57,160
decide that they are deleted by when the

00:36:54,730 --> 00:36:58,780
rule is removed okay these rules are

00:36:57,160 --> 00:37:01,839
interfering to these rules these rules

00:36:58,780 --> 00:37:05,579
that define a set between braces right

00:37:01,839 --> 00:37:10,119
so we call that anonymous sets so anyway

00:37:05,579 --> 00:37:17,440
we could add map to so this is basically

00:37:10,119 --> 00:37:21,280
mapping in an ipv4 address and a counter

00:37:17,440 --> 00:37:23,319
object and then we only need one single

00:37:21,280 --> 00:37:26,800
rule to do this mapping and we can in

00:37:23,319 --> 00:37:30,369
runtime we can create objects at add

00:37:26,800 --> 00:37:33,069
mappings to to that to that bad guys map

00:37:30,369 --> 00:37:35,170
so this would be basically for this

00:37:33,069 --> 00:37:37,280
element we are a new element so too bad

00:37:35,170 --> 00:37:40,400
guys this disappear aggressive

00:37:37,280 --> 00:37:48,470
guy and we are going to account it using

00:37:40,400 --> 00:37:50,630
the bad guy one object okay we can

00:37:48,470 --> 00:37:53,960
obviously at least existing bouncers

00:37:50,630 --> 00:37:55,130
existing quotas existing whatever object

00:37:53,960 --> 00:37:58,780
that we implement on this infrastructure

00:37:55,130 --> 00:38:01,910
we have atomic dump and reset basically

00:37:58,780 --> 00:38:04,580
when you call this command NFPA reset

00:38:01,910 --> 00:38:07,760
it's going to list what is currently in

00:38:04,580 --> 00:38:11,150
the kernel and it's going to reset it in

00:38:07,760 --> 00:38:15,470
an atomic fashion okay it was very good

00:38:11,150 --> 00:38:18,440
that Eddie came up with with a very nice

00:38:15,470 --> 00:38:21,230
way to sort out this because I I got a

00:38:18,440 --> 00:38:26,780
bit of hastening that he's in touch but

00:38:21,230 --> 00:38:28,340
anyway and same thing for quotas quotas

00:38:26,780 --> 00:38:32,540
you can represent also the amount of

00:38:28,340 --> 00:38:34,550
water that has been used and so so you

00:38:32,540 --> 00:38:38,540
can you are going to fetch what what is

00:38:34,550 --> 00:38:41,750
already there that it is good for I mean

00:38:38,540 --> 00:38:44,600
for accountability pool boss right so we

00:38:41,750 --> 00:38:47,060
don't lose that interesting stateful

00:38:44,600 --> 00:38:49,640
information this is something that sorry

00:38:47,060 --> 00:38:51,560
I made it took us a while to figure out

00:38:49,640 --> 00:38:54,080
how to integrate an action checking

00:38:51,560 --> 00:38:56,360
helper synchronous tables we got quite a

00:38:54,080 --> 00:38:59,420
lot of discussions we wanted to be

00:38:56,360 --> 00:39:02,120
exactly in the same way that even 80 AP

00:38:59,420 --> 00:39:04,610
tables but then we have that concern on

00:39:02,120 --> 00:39:07,900
having to add one single rule to attach

00:39:04,610 --> 00:39:13,870
one helper so we want to use maps okay

00:39:07,900 --> 00:39:15,950
so so finally well what we did is we

00:39:13,870 --> 00:39:19,640
integrated this new infrastructure into

00:39:15,950 --> 00:39:21,350
this name object thing okay so we could

00:39:19,640 --> 00:39:25,100
even have different policy for different

00:39:21,350 --> 00:39:27,080
helpers and depending on on where the

00:39:25,100 --> 00:39:28,910
traffic is coming from and we get we

00:39:27,080 --> 00:39:32,900
achieved all that flexibility that we

00:39:28,910 --> 00:39:34,150
want to divide by 1080 so all this is

00:39:32,900 --> 00:39:37,010
this is just to remind you that

00:39:34,150 --> 00:39:40,880
automatic helper assignment has been

00:39:37,010 --> 00:39:44,060
already disabled okay it's only disabled

00:39:40,880 --> 00:39:47,540
in the C CTL I mean it's a it has been

00:39:44,060 --> 00:39:50,680
even if it was unsecure we have to keep

00:39:47,540 --> 00:39:54,580
it for I think it's been for five years

00:39:50,680 --> 00:39:59,410
so there were people still complaining

00:39:54,580 --> 00:40:01,210
though about that so anyway if you if

00:39:59,410 --> 00:40:02,560
you want to get more information on that

00:40:01,210 --> 00:40:06,070
same an information that you'd read this

00:40:02,560 --> 00:40:08,680
document that long wrote about it and it

00:40:06,070 --> 00:40:11,430
provides all the details about that so

00:40:08,680 --> 00:40:14,170
basically an attacker with the automatic

00:40:11,430 --> 00:40:16,480
assignment could hunt grab a pack head

00:40:14,170 --> 00:40:19,030
and just punch hole into the heart in

00:40:16,480 --> 00:40:23,910
its a fireball nasty thing not good okay

00:40:19,030 --> 00:40:26,140
so so now you have to specify explicitly

00:40:23,910 --> 00:40:29,830
the helper that you want to that and

00:40:26,140 --> 00:40:32,950
things like what what from where exactly

00:40:29,830 --> 00:40:35,740
this is going to be a low and what port

00:40:32,950 --> 00:40:38,080
range and so on this is an example this

00:40:35,740 --> 00:40:40,030
is a very basic example of probably what

00:40:38,080 --> 00:40:43,750
you don't have to do right that is

00:40:40,030 --> 00:40:46,420
exactly add a rule to a rule that covers

00:40:43,750 --> 00:40:48,760
that same that same behavior but if you

00:40:46,420 --> 00:40:50,230
aside if you read this documentation you

00:40:48,760 --> 00:40:51,820
will understand that you have to

00:40:50,230 --> 00:40:56,650
restrict its good to restrict this to

00:40:51,820 --> 00:40:58,750
your fibers okay so what we used to do

00:40:56,650 --> 00:41:01,210
is basically from the helper path this

00:40:58,750 --> 00:41:03,640
is now obsolete but it can be it can be

00:41:01,210 --> 00:41:07,510
enabled with with yes a queen was I mean

00:41:03,640 --> 00:41:11,500
just switching the value of RC CDL so if

00:41:07,510 --> 00:41:13,300
someone didn't notice so far and it's

00:41:11,500 --> 00:41:15,790
out of time still can't recover from

00:41:13,300 --> 00:41:18,940
some little time this behavior on T will

00:41:15,790 --> 00:41:22,810
remove it okay so you still have more

00:41:18,940 --> 00:41:26,080
time to fix your setup so basically what

00:41:22,810 --> 00:41:28,420
we were doing is contract helpers where

00:41:26,080 --> 00:41:32,530
control in mob drove by a mob that was

00:41:28,420 --> 00:41:34,330
good that was good in probably probably

00:41:32,530 --> 00:41:36,730
the previous decade right when we have

00:41:34,330 --> 00:41:39,190
no containers and so on and so we were

00:41:36,730 --> 00:41:41,410
just more Pro a globally enabled right

00:41:39,190 --> 00:41:42,040
but these days this is not this is not

00:41:41,410 --> 00:41:45,520
acceptable

00:41:42,040 --> 00:41:47,620
right so not prob is not good and in top

00:41:45,520 --> 00:41:49,450
of that we are spending precious time

00:41:47,620 --> 00:41:51,340
from the packet test to look up for a

00:41:49,450 --> 00:41:54,220
helper we have a very small hash table

00:41:51,340 --> 00:41:58,120
and we are just going to expect if there

00:41:54,220 --> 00:42:00,370
is a an entry in that hash table that is

00:41:58,120 --> 00:42:02,170
going to map with with with a port that

00:42:00,370 --> 00:42:04,540
describe the helper is basically a small

00:42:02,170 --> 00:42:09,660
table with protocol

00:42:04,540 --> 00:42:12,640
lay it laid through 34 and import' and

00:42:09,660 --> 00:42:14,200
so we spend in cycles in finding in

00:42:12,640 --> 00:42:18,220
figuring out what helper we want to use

00:42:14,200 --> 00:42:20,590
all these just because a lot of time it

00:42:18,220 --> 00:42:24,580
was considered to be conveniently to the

00:42:20,590 --> 00:42:28,450
magic stuff so and then attach the

00:42:24,580 --> 00:42:30,490
helper right so not not very good I mean

00:42:28,450 --> 00:42:33,160
assuming that this is slow path and and

00:42:30,490 --> 00:42:33,670
helpers have a very specific scope and

00:42:33,160 --> 00:42:36,040
so on

00:42:33,670 --> 00:42:38,530
anyway so this is what we got so how can

00:42:36,040 --> 00:42:40,660
we do better now in F T so we can

00:42:38,530 --> 00:42:43,270
instantiate one is the fatigue helper

00:42:40,660 --> 00:42:45,970
okay we are basically using this name

00:42:43,270 --> 00:42:49,020
object infrastructure so this would also

00:42:45,970 --> 00:42:51,340
allows us to expose a specific

00:42:49,020 --> 00:42:55,260
configuration of these helpers these

00:42:51,340 --> 00:42:57,820
helpers they have some internal

00:42:55,260 --> 00:43:01,000
configuration parameters most of them

00:42:57,820 --> 00:43:04,480
they are not exposing that but it will

00:43:01,000 --> 00:43:07,000
be good to provide the flexibility so so

00:43:04,480 --> 00:43:08,800
basically what you get now is yes you

00:43:07,000 --> 00:43:14,340
say that you want an instance of the

00:43:08,800 --> 00:43:17,710
seat helper for ipv4 and EDP okay and

00:43:14,340 --> 00:43:20,140
then from your rule if you do it like

00:43:17,710 --> 00:43:22,240
this it's going to be exactly in the IP

00:43:20,140 --> 00:43:24,550
tables way so one rule you attach one

00:43:22,240 --> 00:43:27,160
helper but this is as I said we could

00:43:24,550 --> 00:43:30,310
just do it in one go by having a map

00:43:27,160 --> 00:43:32,410
between port and and the instance of the

00:43:30,310 --> 00:43:36,520
helper that we have just defined this is

00:43:32,410 --> 00:43:43,450
already in the tree something that okay

00:43:36,520 --> 00:43:46,450
no not here okay so most of we work with

00:43:43,450 --> 00:43:50,430
we working on it's migrated in providing

00:43:46,450 --> 00:43:53,260
tools to migrate privy tables to NF e so

00:43:50,430 --> 00:43:56,320
when I have the chance to meet with with

00:43:53,260 --> 00:43:58,380
my sis I've been friends in Spain they

00:43:56,320 --> 00:44:01,750
tell me you know borrow we have a

00:43:58,380 --> 00:44:04,810
inevitable rusev with 5,000 10,000 rules

00:44:01,750 --> 00:44:07,390
right and what are you going to do to

00:44:04,810 --> 00:44:10,240
convince me to migrate to anything huh

00:44:07,390 --> 00:44:12,790
because I don't have any any incentive

00:44:10,240 --> 00:44:14,290
to this alright so there I start

00:44:12,790 --> 00:44:16,450
scratching my head and said I have to do

00:44:14,290 --> 00:44:18,099
something to success again let's try to

00:44:16,450 --> 00:44:20,410
make this migration comfortable

00:44:18,099 --> 00:44:22,299
so we provide a translation

00:44:20,410 --> 00:44:23,710
infrastructure actually we have more

00:44:22,299 --> 00:44:25,660
than the translation infrastructure we

00:44:23,710 --> 00:44:27,339
have also infrastructure already so we

00:44:25,660 --> 00:44:29,440
can probably at some point once we get

00:44:27,339 --> 00:44:32,049
numbers but iptables

00:44:29,440 --> 00:44:34,989
- tables is exactly performing on either

00:44:32,049 --> 00:44:37,509
outperforming the IP tables engine we

00:44:34,989 --> 00:44:40,839
could kill part of the code the X table

00:44:37,509 --> 00:44:43,229
IP underscore stable and so on basically

00:44:40,839 --> 00:44:46,660
the engine is something to consider and

00:44:43,229 --> 00:44:50,200
and easiness tables infrastructure but

00:44:46,660 --> 00:44:52,119
apart from that now what is most simple

00:44:50,200 --> 00:44:54,849
thing is yes translate translate your

00:44:52,119 --> 00:44:56,079
rules so I can show you and I'm not

00:44:54,849 --> 00:44:57,190
going to have enough time to make a demo

00:44:56,079 --> 00:44:59,410
I was planning to make a demo but

00:44:57,190 --> 00:45:00,999
basically we have these tools the IP

00:44:59,410 --> 00:45:03,729
tables resource translate you pass your

00:45:00,999 --> 00:45:06,519
IP tables lose head and if there is a

00:45:03,729 --> 00:45:08,229
translation available it's going to to

00:45:06,519 --> 00:45:10,329
do that automatically for you it's a

00:45:08,229 --> 00:45:13,479
very very simple tool at this stage so

00:45:10,329 --> 00:45:18,160
it is nothing like the tables 1 to 1 to

00:45:13,479 --> 00:45:23,079
n of T so so far the system in has to

00:45:18,160 --> 00:45:26,079
perform the the smart mindset change

00:45:23,079 --> 00:45:29,049
right so rearrange its Russa to see if

00:45:26,079 --> 00:45:33,519
we can collapse several rules into one

00:45:29,049 --> 00:45:35,079
single and be arranged and so on so but

00:45:33,519 --> 00:45:37,809
we will have we're also planning to have

00:45:35,079 --> 00:45:39,759
some - tongue extension University that

00:45:37,809 --> 00:45:42,489
world will will provide the lesson to

00:45:39,759 --> 00:45:44,200
the user to - to optimize the rows at at

00:45:42,489 --> 00:45:46,630
some point to say hey you know I have

00:45:44,200 --> 00:45:50,349
seen that you have four dimensions and

00:45:46,630 --> 00:45:52,900
this four dimensions by lookups so I can

00:45:50,349 --> 00:45:56,410
probably use one concatenation initially

00:45:52,900 --> 00:46:00,400
for two of the or two of the values of

00:45:56,410 --> 00:46:03,249
your topple and then after jumps to

00:46:00,400 --> 00:46:06,489
change the non based change and their to

00:46:03,249 --> 00:46:08,170
form another check of your key so did

00:46:06,489 --> 00:46:09,249
all these is just to reduce number of

00:46:08,170 --> 00:46:11,559
inspection in your rules apply to

00:46:09,249 --> 00:46:16,630
justify inspect one rule to rule 3

00:46:11,559 --> 00:46:22,839
action as soon as possible ok so these

00:46:16,630 --> 00:46:25,359
are going to skip the demo and what's

00:46:22,839 --> 00:46:27,910
what's following up in something I've

00:46:25,359 --> 00:46:28,930
been discussing in net cause it's

00:46:27,910 --> 00:46:30,819
something that they we mentioned in the

00:46:28,930 --> 00:46:31,900
previous nature of the butcher so we

00:46:30,819 --> 00:46:34,200
need winning add

00:46:31,900 --> 00:46:36,880
vo to machine description NFP has a

00:46:34,200 --> 00:46:38,369
specialized network based virtual

00:46:36,880 --> 00:46:42,400
machine

00:46:38,369 --> 00:46:47,259
currently with 25 instructions right so

00:46:42,400 --> 00:46:48,940
we have to have a way to expose what

00:46:47,259 --> 00:46:52,529
instructions are available for several

00:46:48,940 --> 00:46:57,190
reasons because if we have an a weight

00:46:52,529 --> 00:46:59,950
more performant way to express our rules

00:46:57,190 --> 00:47:02,079
we should use it if it's available and

00:46:59,950 --> 00:47:05,319
stop using the old one if we have an old

00:47:02,079 --> 00:47:06,279
NXT binary I'm sorry a new NFD binary

00:47:05,319 --> 00:47:09,549
with an old colonel

00:47:06,279 --> 00:47:11,980
it shouldn't try to represent things in

00:47:09,549 --> 00:47:14,440
a way that this can and cannot do okay

00:47:11,980 --> 00:47:16,779
so all those kind of combination that we

00:47:14,440 --> 00:47:20,380
used to deal with in IP tables right so

00:47:16,779 --> 00:47:21,549
making sure that all to lean all kind of

00:47:20,380 --> 00:47:28,390
versions and so on all these

00:47:21,549 --> 00:47:29,769
combinations they keep working and just

00:47:28,390 --> 00:47:31,809
basically exposing to user space the

00:47:29,769 --> 00:47:33,579
instruction available the command the

00:47:31,809 --> 00:47:35,769
command sided an NF tables interface

00:47:33,579 --> 00:47:38,829
provides and also described in adding

00:47:35,769 --> 00:47:41,309
attributes in that they describe the end

00:47:38,829 --> 00:47:43,450
le attributes in CSV format basically

00:47:41,309 --> 00:47:44,920
the attributes are available to the

00:47:43,450 --> 00:47:46,660
instruction they are instruction to get

00:47:44,920 --> 00:47:49,569
extended get the attributes in the

00:47:46,660 --> 00:47:51,730
attributes allows you to enable some new

00:47:49,569 --> 00:47:55,420
features sometimes for example we will

00:47:51,730 --> 00:47:58,180
need a new attribute for the for the

00:47:55,420 --> 00:48:02,019
quota instruction to indicate the mode

00:47:58,180 --> 00:48:04,150
is packet based or by byte base so now

00:48:02,019 --> 00:48:06,640
this this VM version doesn't have that

00:48:04,150 --> 00:48:08,950
support so we introduced this

00:48:06,640 --> 00:48:12,430
description and it induces base notes oh

00:48:08,950 --> 00:48:14,829
okay I can do packet based coder okay it

00:48:12,430 --> 00:48:16,029
was not available for or sorry you said

00:48:14,829 --> 00:48:19,390
you cannot do it instead of getting some

00:48:16,029 --> 00:48:22,630
critic error like involved or even worse

00:48:19,390 --> 00:48:25,390
right so and then scratch your head and

00:48:22,630 --> 00:48:29,920
say hmm what is going wrong this thing

00:48:25,390 --> 00:48:36,279
is broken right so it is also useful for

00:48:29,920 --> 00:48:38,140
hardware offloads the the uploader have

00:48:36,279 --> 00:48:40,960
seen so far the highway that I have seen

00:48:38,140 --> 00:48:43,640
so far I mean the Tekin basis is it has

00:48:40,960 --> 00:48:48,170
its own limitations

00:48:43,640 --> 00:48:50,330
and we're going to like that that that

00:48:48,170 --> 00:48:52,880
the hardware limitations propagate to

00:48:50,330 --> 00:48:55,280
the software path in any way so that

00:48:52,880 --> 00:48:57,920
needs to be clearly clear brady's

00:48:55,280 --> 00:48:59,420
software can keep evolving in a way that

00:48:57,920 --> 00:49:04,970
doesn't affect hardware and either way

00:48:59,420 --> 00:49:07,760
okay so so we want to provide also these

00:49:04,970 --> 00:49:10,310
abstracted this virtual machine

00:49:07,760 --> 00:49:14,060
efficient is basically Dell also from a

00:49:10,310 --> 00:49:17,180
NSE perspective what nfe can do with

00:49:14,060 --> 00:49:17,870
hardware okay so no layout is exposed to

00:49:17,180 --> 00:49:22,750
using space

00:49:17,870 --> 00:49:26,240
it's this is based on nfe or NFC condom

00:49:22,750 --> 00:49:30,260
right and this is going to be again from

00:49:26,240 --> 00:49:33,020
interspace NFP it will generate or just

00:49:30,260 --> 00:49:34,460
the signal arrows to the user indicating

00:49:33,020 --> 00:49:36,980
what it can do it's something that is

00:49:34,460 --> 00:49:42,800
new interface we have a command at some

00:49:36,980 --> 00:49:44,360
point so we can use to to get some text

00:49:42,800 --> 00:49:48,710
representation or even even Jason for

00:49:44,360 --> 00:49:50,690
robots right so so for example one one

00:49:48,710 --> 00:49:52,640
one very clear example where we have

00:49:50,690 --> 00:49:53,210
problems to map these to Hardware if

00:49:52,640 --> 00:49:56,060
Mita

00:49:53,210 --> 00:49:58,550
laid for proto let me tell you for

00:49:56,060 --> 00:50:00,590
brother has its own specific semantics

00:49:58,550 --> 00:50:03,230
it's basically searching for the first

00:50:00,590 --> 00:50:06,200
transport header that we find in the

00:50:03,230 --> 00:50:09,020
packet okay this is in ipv4 this is very

00:50:06,200 --> 00:50:10,970
obvious it's just the next what what

00:50:09,020 --> 00:50:13,760
what the next protocol of the ipv4

00:50:10,970 --> 00:50:15,350
header indicates but in ipv6 we have we

00:50:13,760 --> 00:50:19,490
may have all kind of extension headers

00:50:15,350 --> 00:50:21,500
and so on that that we don't want to we

00:50:19,490 --> 00:50:23,300
don't want to say that a this is your

00:50:21,500 --> 00:50:25,070
next I mean we don't want to say that

00:50:23,300 --> 00:50:28,010
meter layer protocol is this extension

00:50:25,070 --> 00:50:30,650
no no we want to jump to the transport

00:50:28,010 --> 00:50:32,480
layer that that has the relevant

00:50:30,650 --> 00:50:37,130
information that is not what most users

00:50:32,480 --> 00:50:39,020
need right so so in this case 40 can

00:50:37,130 --> 00:50:41,240
based hardware at least the one way I

00:50:39,020 --> 00:50:43,850
have seen this is not it

00:50:41,240 --> 00:50:46,580
we cannot extract extra so this BN

00:50:43,850 --> 00:50:49,580
description should state user space you

00:50:46,580 --> 00:50:52,820
cannot use meet a lady for products you

00:50:49,580 --> 00:50:55,520
have to use IP six next header okay and

00:50:52,820 --> 00:50:57,250
and then you are you become aware of the

00:50:55,520 --> 00:51:00,670
limitations or what decent

00:50:57,250 --> 00:51:02,320
I okay so so you can audit this month

00:51:00,670 --> 00:51:02,710
saying that this is exactly expose in

00:51:02,320 --> 00:51:05,500
userspace

00:51:02,710 --> 00:51:08,650
these so these little semantic

00:51:05,500 --> 00:51:11,890
differences emerge and the user the user

00:51:08,650 --> 00:51:13,870
is well aware of it okay so also it's

00:51:11,890 --> 00:51:16,180
good if the driver gets out of things so

00:51:13,870 --> 00:51:18,360
some of the feature that we have in the

00:51:16,180 --> 00:51:21,010
solver plane is not yet because the

00:51:18,360 --> 00:51:24,550
driver developer has doesn't have time

00:51:21,010 --> 00:51:27,640
to update the driver so it's also good

00:51:24,550 --> 00:51:29,920
if if we have this description because

00:51:27,640 --> 00:51:35,680
it's just going to keep this out of

00:51:29,920 --> 00:51:38,350
things in under control so it will be a

00:51:35,680 --> 00:51:41,830
command to retrieve this would replace

00:51:38,350 --> 00:51:44,020
it somewhere in a file and we will find

00:51:41,830 --> 00:51:46,000
a way to compile breakage to compile

00:51:44,020 --> 00:51:48,220
break if the description is not

00:51:46,000 --> 00:51:50,620
available and this should be from NF it

00:51:48,220 --> 00:51:53,530
should be transparent to the user so NFC

00:51:50,620 --> 00:51:55,420
will inquire for this command to obtain

00:51:53,530 --> 00:51:57,040
the capabilities but also it should be

00:51:55,420 --> 00:51:59,380
good if we provide some commands so

00:51:57,040 --> 00:52:02,020
these abstract description is exposed to

00:51:59,380 --> 00:52:05,050
usage so the user can't read 3ds in some

00:52:02,020 --> 00:52:10,990
text days or if it's a robot son Jason

00:52:05,050 --> 00:52:13,630
formats do this okay set so we don't

00:52:10,990 --> 00:52:17,290
expose our bucket set representations in

00:52:13,630 --> 00:52:19,600
unity so the user cannot say I want to

00:52:17,290 --> 00:52:21,940
use a hash table now this is not the way

00:52:19,600 --> 00:52:24,040
it works in action so do you provide a

00:52:21,940 --> 00:52:25,480
description of what you need you may

00:52:24,040 --> 00:52:27,580
provide the elements that you want to

00:52:25,480 --> 00:52:29,890
insert in the set what size this set is

00:52:27,580 --> 00:52:33,100
going to have if you're going to use

00:52:29,890 --> 00:52:34,960
ranges you may not want to specify how

00:52:33,100 --> 00:52:39,070
many how many elements you are going to

00:52:34,960 --> 00:52:40,960
having said all that it's a description

00:52:39,070 --> 00:52:43,450
that the user space provides and then

00:52:40,960 --> 00:52:46,630
from the kernel side we have AV call

00:52:43,450 --> 00:52:49,480
notation they just provide some this

00:52:46,630 --> 00:52:51,940
capability it represents the scalability

00:52:49,480 --> 00:52:53,500
of a setback and representation so based

00:52:51,940 --> 00:52:55,150
on that and the more information of

00:52:53,500 --> 00:52:57,210
course we get from user space them the

00:52:55,150 --> 00:53:00,490
more specific is the description weekend

00:52:57,210 --> 00:53:03,940
the best from the kernel we can do the

00:53:00,490 --> 00:53:06,310
selection of the back end okay so we

00:53:03,940 --> 00:53:07,930
will also need more set back end for the

00:53:06,310 --> 00:53:09,100
currently we only have very little only

00:53:07,930 --> 00:53:12,070
three the

00:53:09,100 --> 00:53:14,170
hash-table liar resizable hash tables

00:53:12,070 --> 00:53:16,840
that for example is not needed if the

00:53:14,170 --> 00:53:18,670
set is contact constant okay why do we

00:53:16,840 --> 00:53:20,770
where we going to space cycling our

00:53:18,670 --> 00:53:24,040
recital hash table that is not going

00:53:20,770 --> 00:53:26,260
ever going to be resized right so we can

00:53:24,040 --> 00:53:27,790
probably have a very more simple more

00:53:26,260 --> 00:53:30,160
performant way to represent this hash

00:53:27,790 --> 00:53:32,920
tag so we have an arbitrary that we want

00:53:30,160 --> 00:53:35,020
to get rid of because it has a

00:53:32,920 --> 00:53:36,880
centralized pin lock and it's going to

00:53:35,020 --> 00:53:39,760
catch things it's already causing us

00:53:36,880 --> 00:53:42,370
problems and in terms of performance

00:53:39,760 --> 00:53:45,010
it's the only thing we have so far but

00:53:42,370 --> 00:53:46,900
once we kill it we I mean we can kill it

00:53:45,010 --> 00:53:50,140
freely because it's not being exposed

00:53:46,900 --> 00:53:51,880
and this this give us this give us the

00:53:50,140 --> 00:53:55,690
flexibility that that we need we don't

00:53:51,880 --> 00:53:59,440
want to keep maintaining call that users

00:53:55,690 --> 00:54:01,390
should not be using okay and and and a

00:53:59,440 --> 00:54:05,530
bitmap now it's limited to key length of

00:54:01,390 --> 00:54:08,170
it smaller than 16 bits so the bitmap

00:54:05,530 --> 00:54:10,510
side doesn't explode and currently it is

00:54:08,170 --> 00:54:14,680
supporting it is supporting dynamic

00:54:10,510 --> 00:54:16,900
updates and hmm it should be also

00:54:14,680 --> 00:54:18,970
possible to to provide a more simple

00:54:16,900 --> 00:54:21,180
representation for for constant sets

00:54:18,970 --> 00:54:21,180
okay

00:54:21,420 --> 00:54:32,620
it's an it performs it performs better

00:54:24,220 --> 00:54:33,730
than then-then-then hash table so this

00:54:32,620 --> 00:54:36,360
is something that we don't have but

00:54:33,730 --> 00:54:39,550
probably it's kid if we provide more

00:54:36,360 --> 00:54:41,350
description for we keep enriching the

00:54:39,550 --> 00:54:43,840
description that we provide from in

00:54:41,350 --> 00:54:46,420
space so we for example to define app

00:54:43,840 --> 00:54:48,400
subset and say as I said that is going

00:54:46,420 --> 00:54:50,560
to basically represent what is in this

00:54:48,400 --> 00:54:52,420
range and it's going to be good because

00:54:50,560 --> 00:54:56,530
the corner can say oh this is very small

00:54:52,420 --> 00:54:59,140
I can use a bit now and so the user it

00:54:56,530 --> 00:55:01,690
renews is a space with yeah we will just

00:54:59,140 --> 00:55:04,120
need when creating the side just set on

00:55:01,690 --> 00:55:07,450
a flag to indicate this is a portfolio

00:55:04,120 --> 00:55:09,360
of subsets or whatever and then we have

00:55:07,450 --> 00:55:11,590
to make sure meteor information is

00:55:09,360 --> 00:55:14,770
converted to network byte order because

00:55:11,590 --> 00:55:16,900
of men compared and probably we need

00:55:14,770 --> 00:55:20,920
some basic bignum things to subtract

00:55:16,900 --> 00:55:22,120
calculate offset for 24 bits for ipv6

00:55:20,920 --> 00:55:26,170
addresses

00:55:22,120 --> 00:55:27,550
and what else

00:55:26,170 --> 00:55:30,760
Dahlia there are people asking for a

00:55:27,550 --> 00:55:34,480
catch-all for elements in maps so if we

00:55:30,760 --> 00:55:35,980
have something like this if we want to

00:55:34,480 --> 00:55:40,330
be for the full action something that we

00:55:35,980 --> 00:55:46,740
don't find we just at this wire thing

00:55:40,330 --> 00:55:46,740
and we're going to drop the traffic okay

00:55:47,280 --> 00:55:52,900
as we don't expose the back in

00:55:50,890 --> 00:55:55,590
representations we can implement very

00:55:52,900 --> 00:55:58,600
silly way to represent the rule set for

00:55:55,590 --> 00:56:01,900
things that for for very small set

00:55:58,600 --> 00:56:04,630
probably I am we are starting to collect

00:56:01,900 --> 00:56:07,330
numbers now perform are not numbers but

00:56:04,630 --> 00:56:10,990
basically if you create a set with only

00:56:07,330 --> 00:56:18,910
two elements it's way too much to create

00:56:10,990 --> 00:56:22,630
a hash table for this okay and if it's

00:56:18,910 --> 00:56:25,330
proved to be that the hash table also

00:56:22,630 --> 00:56:26,770
form in that case we could look at it

00:56:25,330 --> 00:56:28,180
really get rid of that because we don't

00:56:26,770 --> 00:56:31,300
explode that set so we don't have we

00:56:28,180 --> 00:56:35,170
have that sexy video kay what else um we

00:56:31,300 --> 00:56:38,500
have new new commands we have a create

00:56:35,170 --> 00:56:41,800
command it's basically there for almost

00:56:38,500 --> 00:56:44,830
every object it just provides the the

00:56:41,800 --> 00:56:49,570
please bail out if the objects already

00:56:44,830 --> 00:56:56,010
exists okay and now we have also

00:56:49,570 --> 00:56:57,900
inverted set lookups okay not here okay

00:56:56,010 --> 00:57:00,850
next next

00:56:57,900 --> 00:57:02,770
people like names they from time to time

00:57:00,850 --> 00:57:04,330
they come to the middle is asking for I

00:57:02,770 --> 00:57:05,020
would like to filter by some name no

00:57:04,330 --> 00:57:09,040
that's crazy

00:57:05,020 --> 00:57:11,800
don't do it okay don't do it and this is

00:57:09,040 --> 00:57:15,640
not exactly what what you want to do or

00:57:11,800 --> 00:57:18,760
this is not DNS tables right and so if

00:57:15,640 --> 00:57:22,420
you want to do this you can you can rely

00:57:18,760 --> 00:57:24,160
on on you can heavily use the variable

00:57:22,420 --> 00:57:27,010
definitions that we have so you can even

00:57:24,160 --> 00:57:28,840
have a robot that is going to create a

00:57:27,010 --> 00:57:31,060
file that contain all the definitions

00:57:28,840 --> 00:57:33,430
that are going to map with all the names

00:57:31,060 --> 00:57:35,020
that you have and keep this in a roster

00:57:33,430 --> 00:57:37,180
event import that from you

00:57:35,020 --> 00:57:38,530
we'll set and just reference to that

00:57:37,180 --> 00:57:41,590
variable okay

00:57:38,530 --> 00:57:43,600
and even you could just keep that bad

00:57:41,590 --> 00:57:45,070
guys filer is automatically generated or

00:57:43,600 --> 00:57:46,630
partially automatically generated that

00:57:45,070 --> 00:57:50,650
required the supervision on some human

00:57:46,630 --> 00:57:53,380
or whatever separated from this just to

00:57:50,650 --> 00:57:54,910
improve maintainability of this rule the

00:57:53,380 --> 00:57:59,740
deletion description so uses are

00:57:54,910 --> 00:58:02,220
containing so far about about the fact

00:57:59,740 --> 00:58:05,890
that they have to list the rule set

00:58:02,220 --> 00:58:09,280
obtain a unique handle number based on

00:58:05,890 --> 00:58:11,320
test if the booster is is large this is

00:58:09,280 --> 00:58:13,810
going to I mean it takes a while to find

00:58:11,320 --> 00:58:15,430
to figure out where is the handle number

00:58:13,810 --> 00:58:17,590
of the road you can make a mistake

00:58:15,430 --> 00:58:24,220
oh I took the wrong one and we delayed

00:58:17,590 --> 00:58:26,440
and you just screw it off right so so it

00:58:24,220 --> 00:58:29,020
would be good to have a way to achieve

00:58:26,440 --> 00:58:31,440
what we have been in iptables right it's

00:58:29,020 --> 00:58:35,560
NFC delete rule and then the description

00:58:31,440 --> 00:58:36,880
so so basically the infrastructure in

00:58:35,560 --> 00:58:38,920
the kernel is already there we have to

00:58:36,880 --> 00:58:43,830
still this is not available in HP user

00:58:38,920 --> 00:58:46,060
space it's it's a more this change I

00:58:43,830 --> 00:58:48,340
start working on this thinking that it

00:58:46,060 --> 00:58:50,650
was going to be shorted actually under

00:58:48,340 --> 00:58:51,940
nine I realized that is taking it's more

00:58:50,650 --> 00:58:53,920
complicated specifically because there

00:58:51,940 --> 00:58:56,680
are symmetries between the way we

00:58:53,920 --> 00:58:59,980
represent the rule sets on from the

00:58:56,680 --> 00:59:02,230
insert tab on the linear part I'm in the

00:58:59,980 --> 00:59:05,140
table where we take the policing text

00:59:02,230 --> 00:59:06,910
and we generate the byte code and buy

00:59:05,140 --> 00:59:10,540
one because enemies are compiler on the

00:59:06,910 --> 00:59:14,020
compiler but when we take back the byte

00:59:10,540 --> 00:59:15,820
code away we get back the boosted

00:59:14,020 --> 00:59:17,110
representation so currently the

00:59:15,820 --> 00:59:19,510
structure that we're using to represent

00:59:17,110 --> 00:59:21,280
both are not exactly mapping one to one

00:59:19,510 --> 00:59:22,840
it's just a matter of fixing this

00:59:21,280 --> 00:59:24,490
inconsistency I think that test

00:59:22,840 --> 00:59:26,920
infrastructure was reporting something

00:59:24,490 --> 00:59:31,270
like 100 or something

00:59:26,920 --> 00:59:34,650
test failing lisanna checked and this is

00:59:31,270 --> 00:59:34,650
the last slide Okayama

00:59:35,680 --> 00:59:41,800
you have to be nice with medium on any

00:59:39,670 --> 00:59:43,720
profile reporting and at this I can

00:59:41,800 --> 00:59:47,970
escape Jamaa he is told these topics on

00:59:43,720 --> 00:59:51,460
medias read you evil guy okay so but

00:59:47,970 --> 00:59:54,070
last time to do this anthem yeah okay no

00:59:51,460 --> 00:59:56,080
problem I lost them anyway so basically

00:59:54,070 --> 00:59:58,690
the idea is is this is the way we with

00:59:56,080 --> 01:00:03,160
report errors now it's quite as you can

00:59:58,690 --> 01:00:05,080
see it's post Grange right so no no

01:00:03,160 --> 01:00:09,070
entry but what a ninety what does it

01:00:05,080 --> 01:00:13,740
mean is no table no chain oh no no what

01:00:09,070 --> 01:00:17,080
no object with a Dane right so now

01:00:13,740 --> 01:00:20,740
johannes he has pushed a pat said that

01:00:17,080 --> 01:00:22,450
basically has has collected all the

01:00:20,740 --> 01:00:24,940
design ideas with the cousin I don't

01:00:22,450 --> 01:00:27,280
know if it's already in the chief he

01:00:24,940 --> 01:00:28,600
still working line okay

01:00:27,280 --> 01:00:30,670
so basically the idea is that we can

01:00:28,600 --> 01:00:33,070
just say exactly what is the problem so

01:00:30,670 --> 01:00:38,230
it doesn't exist and we can say the

01:00:33,070 --> 01:00:40,150
table come on okay so um anything else

01:00:38,230 --> 01:00:42,940
that's all okay

01:00:40,150 --> 01:00:46,330
probably one question which is children

01:00:42,940 --> 01:00:50,290
last more than 30 seconds I have a mic

01:00:46,330 --> 01:00:51,910
these are working okay so I think what's

01:00:50,290 --> 01:00:55,090
great about NF tables is that it

01:00:51,910 --> 01:00:56,530
provides a users user-facing interface

01:00:55,090 --> 01:00:57,730
that it's easy for users to become

01:00:56,530 --> 01:01:03,390
comfortable with you have the

01:00:57,730 --> 01:01:05,890
abstractions of rules tables sets and

01:01:03,390 --> 01:01:08,440
maps different kinds of things like that

01:01:05,890 --> 01:01:11,830
and I think for the if you look at the

01:01:08,440 --> 01:01:14,230
ingress netfilter it's a little more on

01:01:11,830 --> 01:01:15,850
the stateless side right it's not

01:01:14,230 --> 01:01:17,290
getting into all the details we have all

01:01:15,850 --> 01:01:19,560
this complicated state that's associated

01:01:17,290 --> 01:01:22,750
with an skb and things like that and

01:01:19,560 --> 01:01:27,070
then let's look at another area which is

01:01:22,750 --> 01:01:28,060
that we have layers of detail so if you

01:01:27,070 --> 01:01:31,360
look at something like

01:01:28,060 --> 01:01:32,680
xdp at the lowest level there are people

01:01:31,360 --> 01:01:34,540
who want to control everything and they

01:01:32,680 --> 01:01:36,730
want to write BPF programs and assembler

01:01:34,540 --> 01:01:38,800
those guys are kind of crazy but they

01:01:36,730 --> 01:01:40,060
can do that if they want and then we

01:01:38,800 --> 01:01:41,620
have people who are not interested in

01:01:40,060 --> 01:01:43,270
learning how BPF assembler works and

01:01:41,620 --> 01:01:45,190
they're willing to write C code to write

01:01:43,270 --> 01:01:47,410
their filters and stuff like that I do

01:01:45,190 --> 01:01:49,180
not think it's a stretch to take it one

01:01:47,410 --> 01:01:51,550
level further to provide a nice you

01:01:49,180 --> 01:01:53,680
your front end like this and January BPF

01:01:51,550 --> 01:01:56,200
programs that people can run based upon

01:01:53,680 --> 01:01:58,750
NF rules you could do everything you do

01:01:56,200 --> 01:02:00,579
now with sets like you abstract away to

01:01:58,750 --> 01:02:02,800
set selection from the users description

01:02:00,579 --> 01:02:04,869
of how the data is like intervals and

01:02:02,800 --> 01:02:07,900
things of that nature you could say okay

01:02:04,869 --> 01:02:11,020
this BPF map maps to this users use case

01:02:07,900 --> 01:02:12,490
more better than any other CIFAS so I

01:02:11,020 --> 01:02:15,880
think it's really interesting from that

01:02:12,490 --> 01:02:20,079
perspective and also I don't think it's

01:02:15,880 --> 01:02:24,250
practical to translate from multiple VMs

01:02:20,079 --> 01:02:29,890
into different NT use in Hardware

01:02:24,250 --> 01:02:31,720
drivers because the the metronome kit is

01:02:29,890 --> 01:02:33,010
very complicated it took a lot of work

01:02:31,720 --> 01:02:35,230
and we have to build even more

01:02:33,010 --> 01:02:37,599
infrastructure for them to be efficient

01:02:35,230 --> 01:02:39,220
so I think it would be its interest it's

01:02:37,599 --> 01:02:40,930
very important to think about

01:02:39,220 --> 01:02:42,400
consolidating all the complexity that

01:02:40,930 --> 01:02:44,710
we're generating by representing all

01:02:42,400 --> 01:02:46,540
these different concert uh things both

01:02:44,710 --> 01:02:50,410
on the user facing down to what actually

01:02:46,540 --> 01:02:52,390
happens inside the criminal okay thanks

01:02:50,410 --> 01:02:59,980
let's give them enough applause go

01:02:52,390 --> 01:03:02,200
public and chlorine okay so I don't know

01:02:59,980 --> 01:03:04,359
if you guys have observed normally yes

01:03:02,200 --> 01:03:07,150
we do have keynotes but it's not from

01:03:04,359 --> 01:03:12,190
some VP of Marketing okay member of our

01:03:07,150 --> 01:03:14,559
community and we typically have another

01:03:12,190 --> 01:03:16,119
member of our community who has known

01:03:14,559 --> 01:03:18,819
this person would like to embarrass them

01:03:16,119 --> 01:03:23,609
to introduce them so for next week I'm

01:03:18,819 --> 01:03:23,609
going to have Alex introduce yes

01:03:29,630 --> 01:03:45,809
starting time for two minutes okay life

01:03:37,789 --> 01:03:49,470
closely yeah Jenny over to me

01:03:45,809 --> 01:03:53,670
okay slide to her yeah just read the

01:03:49,470 --> 01:03:56,509
stopwatch we're just gonna yup flowing

01:03:53,670 --> 01:03:56,509
slide funny

01:04:04,650 --> 01:04:16,570
what you can find and read easy okay

01:04:13,270 --> 01:04:19,480
you're on get two minutes okay just very

01:04:16,570 --> 01:04:21,250
quick so I'm going to skip this a bit so

01:04:19,480 --> 01:04:24,970
this is about I project I've been

01:04:21,250 --> 01:04:27,070
working on about making packet steering

01:04:24,970 --> 01:04:30,130
available and enough tables so you can

01:04:27,070 --> 01:04:34,360
send packet to other CPUs so we already

01:04:30,130 --> 01:04:36,700
have some stuff like RPS or RSS but it's

01:04:34,360 --> 01:04:38,410
not so flexible with ricotta

01:04:36,700 --> 01:04:40,870
configuration so what I have at the

01:04:38,410 --> 01:04:44,920
moment is some sample code that extends

01:04:40,870 --> 01:04:47,290
NFC's meta net expression so you can set

01:04:44,920 --> 01:04:49,270
a CPU and then it used to package that

01:04:47,290 --> 01:04:52,420
CPU by returning in a stolen for the

01:04:49,270 --> 01:04:58,930
fibula processed the packet will just go

01:04:52,420 --> 01:05:02,080
back to the RX Navy and it will wake up

01:04:58,930 --> 01:05:03,670
a work queue so you could split ways on

01:05:02,080 --> 01:05:05,140
packets that you know that out will be

01:05:03,670 --> 01:05:07,900
more expensive to process for instance

01:05:05,140 --> 01:05:10,630
IPSec or con complex applicable

01:05:07,900 --> 01:05:12,630
filtering or whatever or to have

01:05:10,630 --> 01:05:15,220
dedicated forwarding CPUs or whatever

01:05:12,630 --> 01:05:16,990
and it's still in early toys stage which

01:05:15,220 --> 01:05:21,430
means what basically it compiles when it

01:05:16,990 --> 01:05:24,730
seems to not crash the kernel and use

01:05:21,430 --> 01:05:27,520
per CPU data work you use skb array

01:05:24,730 --> 01:05:31,180
which really sets this consumer producer

01:05:27,520 --> 01:05:33,180
model so we just place in the FGB into

01:05:31,180 --> 01:05:36,610
the fkd array the any fog state and

01:05:33,180 --> 01:05:40,240
that's it and the other the other CPU

01:05:36,610 --> 01:05:41,980
will just wake up the work you and that

01:05:40,240 --> 01:05:44,380
works you to batch the queuing of

01:05:41,980 --> 01:05:47,530
whatever is there and just invoke the

01:05:44,380 --> 01:05:52,690
okay function that is in the and the any

01:05:47,530 --> 01:05:54,910
folk state to process the tacit in the

01:05:52,690 --> 01:05:55,500
nicotine to the next stage well that's

01:05:54,910 --> 01:05:58,960
it

01:05:55,500 --> 01:06:01,360
and is elicited to get numbers how much

01:05:58,960 --> 01:06:03,370
of cost it is to have this an extra

01:06:01,360 --> 01:06:06,880
penalty of putting the package of the

01:06:03,370 --> 01:06:10,780
other cpu and if that looks not so where

01:06:06,880 --> 01:06:12,490
then it would be good to make it so that

01:06:10,780 --> 01:06:14,350
we can resume processing in the next

01:06:12,490 --> 01:06:16,030
netfilter hook instead of the next okay

01:06:14,350 --> 01:06:16,760
function so instead of going from P

01:06:16,030 --> 01:06:20,420
routing to in

01:06:16,760 --> 01:06:25,300
rerouting to forward profit for next

01:06:20,420 --> 01:06:25,300
table instead method

01:06:27,290 --> 01:06:30,530

YouTube URL: https://www.youtube.com/watch?v=qXVOA2MKA1s


