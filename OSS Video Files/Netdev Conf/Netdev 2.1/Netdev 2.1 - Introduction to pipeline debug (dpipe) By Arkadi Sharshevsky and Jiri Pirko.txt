Title: Netdev 2.1 - Introduction to pipeline debug (dpipe) By Arkadi Sharshevsky and Jiri Pirko
Publication date: 2017-05-01
Playlist: Netdev 2.1
Description: 
	Talk was given by Jiri Pirko on 6th of Apr/2017

The new dpipe interface introduces capability for exporting the ASICs pipeline abstraction via devlink infrastructure, which should serve as an complementary tool. This infrastructure allows the user to get visibility into the ASIC by modeling it as a set of match/action tables.
Content at:
https://www.netdevconf.org/2.1/session.html?sharshevsky
Captions: 
	00:00:00,030 --> 00:00:10,320
well I'm Jerry I'm this second guy the

00:00:06,500 --> 00:00:14,000
the first guy Arkady who actually should

00:00:10,320 --> 00:00:17,480
do the talk was not able to come so I

00:00:14,000 --> 00:00:20,960
here and I'm doing it instead of them

00:00:17,480 --> 00:00:27,480
hopefully I know all the details but

00:00:20,960 --> 00:00:34,290
we'll see okay so we can start the talk

00:00:27,480 --> 00:00:39,840
will be about essentially way to provide

00:00:34,290 --> 00:00:41,910
a possibility to debug pipeline which is

00:00:39,840 --> 00:00:47,039
inside the ASIC and I'm talking about

00:00:41,910 --> 00:00:48,780
ASIC it's in our case it's a switch and

00:00:47,039 --> 00:00:55,320
the error case is a melodic spectrum

00:00:48,780 --> 00:00:58,530
sewage and okay I can get you one right

00:00:55,320 --> 00:01:01,770
one so the problem statement is obvious

00:00:58,530 --> 00:01:05,189
we need to have some visibility about

00:01:01,770 --> 00:01:11,310
what's going on inside inside the ASIC

00:01:05,189 --> 00:01:15,689
itself because when you do offloading of

00:01:11,310 --> 00:01:18,930
linux pipeline or linux networking

00:01:15,689 --> 00:01:24,090
blocks into the hardware they are not

00:01:18,930 --> 00:01:27,960
not one-to-one so most of most of the

00:01:24,090 --> 00:01:34,070
time the specifics the details are

00:01:27,960 --> 00:01:37,320
different so there can be some issues

00:01:34,070 --> 00:01:43,649
related to that in regard to performance

00:01:37,320 --> 00:01:48,570
and scalability and also when you do

00:01:43,649 --> 00:01:50,970
some setup to kernel and then something

00:01:48,570 --> 00:01:56,070
is it's offloaded down to the to the

00:01:50,970 --> 00:01:58,380
hardware and it fails you don't have any

00:01:56,070 --> 00:02:01,560
information about what what actually

00:01:58,380 --> 00:02:05,759
went wrong if it was because of the

00:02:01,560 --> 00:02:07,700
there were not enough resources or there

00:02:05,759 --> 00:02:10,440
is just

00:02:07,700 --> 00:02:14,520
neuroses the resources are there but

00:02:10,440 --> 00:02:20,460
they are just not utilized in a good way

00:02:14,520 --> 00:02:23,100
or in an optimal way and also there can

00:02:20,460 --> 00:02:26,070
be a problem with the dependencies which

00:02:23,100 --> 00:02:29,040
are not on that so there is need for

00:02:26,070 --> 00:02:32,460
some tool which is which is going to

00:02:29,040 --> 00:02:40,590
provide this visibility to the user or

00:02:32,460 --> 00:02:44,310
to the developer as well and this this

00:02:40,590 --> 00:02:47,640
is not only in case something is going

00:02:44,310 --> 00:02:53,220
wrong but also in case you need to

00:02:47,640 --> 00:02:56,070
improve the performance here is a slide

00:02:53,220 --> 00:02:58,709
which is showing you an example about

00:02:56,070 --> 00:03:03,320
this mismatch between software and

00:02:58,709 --> 00:03:07,160
hardware implementation of doing things

00:03:03,320 --> 00:03:09,930
so here is a longest prefix match which

00:03:07,160 --> 00:03:14,489
on the right side it's how it's

00:03:09,930 --> 00:03:16,620
implemented in kernel it's a tree on the

00:03:14,489 --> 00:03:20,880
left side it's an example how it could

00:03:16,620 --> 00:03:27,030
be implemented in in some hardware it is

00:03:20,880 --> 00:03:30,540
actually a chain of hash tables so you

00:03:27,030 --> 00:03:36,870
can see that in software the lookup is

00:03:30,540 --> 00:03:40,850
very fast it's it's if you see the tree

00:03:36,870 --> 00:03:43,230
it's on the left side it's one note and

00:03:40,850 --> 00:03:47,220
but in the hardware it can be much

00:03:43,230 --> 00:03:49,200
slower because the other roots which are

00:03:47,220 --> 00:03:52,070
inserted and are not really related to

00:03:49,200 --> 00:03:56,310
the to the root we are today we are

00:03:52,070 --> 00:03:59,489
discussing can make it a lot worse

00:03:56,310 --> 00:04:03,140
because you basically do liner than our

00:03:59,489 --> 00:04:05,690
lookup in that case for each hash table

00:04:03,140 --> 00:04:10,400
so

00:04:05,690 --> 00:04:17,930
that's not nice and we need somehow to

00:04:10,400 --> 00:04:21,019
provide that information to the user so

00:04:17,930 --> 00:04:24,070
the other thing is that different

00:04:21,019 --> 00:04:29,620
hardware chips have different pipelines

00:04:24,070 --> 00:04:34,220
so you cannot really have like one

00:04:29,620 --> 00:04:37,880
solution or you cannot say that software

00:04:34,220 --> 00:04:40,760
differ I mean a Linux kernel behaves

00:04:37,880 --> 00:04:49,150
this way and however in general behaves

00:04:40,760 --> 00:04:54,800
in this way each are different so in

00:04:49,150 --> 00:04:57,440
yeah in most cases there is more than

00:04:54,800 --> 00:05:03,740
one way to do the offloading I mean you

00:04:57,440 --> 00:05:06,770
can use multiple solutions for example

00:05:03,740 --> 00:05:10,790
you can use tkm or you can use a DB for

00:05:06,770 --> 00:05:16,760
the same thing so you need to also make

00:05:10,790 --> 00:05:21,770
it visible to the user and of course the

00:05:16,760 --> 00:05:23,940
tool to solve this problem should be in

00:05:21,770 --> 00:05:25,300
vendor-neutral

00:05:23,940 --> 00:05:28,760
[Music]

00:05:25,300 --> 00:05:32,150
because if we do like something which is

00:05:28,760 --> 00:05:33,740
specific to one vendor it can be used in

00:05:32,150 --> 00:05:39,430
a generic way for for the users

00:05:33,740 --> 00:05:39,430
obviously okay so here's the solution

00:05:39,460 --> 00:05:48,710
solution which we think is good is to

00:05:45,050 --> 00:05:54,530
model the the ASIC pipeline as a graph

00:05:48,710 --> 00:05:57,620
of match and action tables it's not new

00:05:54,530 --> 00:06:01,870
approach before uses something very

00:05:57,620 --> 00:06:04,970
similar to that same flow api by john

00:06:01,870 --> 00:06:09,590
sitting over there which was presented

00:06:04,970 --> 00:06:13,160
in ottawa two years ago is basically

00:06:09,590 --> 00:06:14,379
very similar we actually are using the

00:06:13,160 --> 00:06:25,539
same concept

00:06:14,379 --> 00:06:28,120
and so yeah this this this new tool

00:06:25,539 --> 00:06:31,280
actually provides the visibility to

00:06:28,120 --> 00:06:34,460
something which you configure via

00:06:31,280 --> 00:06:38,659
standard - so basically you do IP route

00:06:34,460 --> 00:06:40,849
ad let's offload the route into the

00:06:38,659 --> 00:06:44,629
harbor but you don't know what happened

00:06:40,849 --> 00:06:47,479
so you used this tool to actually see I

00:06:44,629 --> 00:06:49,849
mean this there will be a couple of

00:06:47,479 --> 00:06:54,020
tables in the pipeline which will

00:06:49,849 --> 00:06:56,229
actually let you see how it is done in

00:06:54,020 --> 00:06:56,229
hardware

00:06:57,969 --> 00:07:04,219
yeah the advantage is I mentioned it

00:07:00,860 --> 00:07:11,449
already the specifics can be presented

00:07:04,219 --> 00:07:13,370
in a generic way the it is also possible

00:07:11,449 --> 00:07:18,680
to describe very complex Hardware blocks

00:07:13,370 --> 00:07:21,879
as a match action tables and this is

00:07:18,680 --> 00:07:26,870
this whole model is easily accepted

00:07:21,879 --> 00:07:29,539
extendable for other things if needed we

00:07:26,870 --> 00:07:36,080
decided to use that link as an interface

00:07:29,539 --> 00:07:39,620
because it allows exposing stuff which

00:07:36,080 --> 00:07:43,789
is not per NAT device or per port but

00:07:39,620 --> 00:07:45,889
which is more for like per ASIC that was

00:07:43,789 --> 00:07:55,219
actually one of the goals of the of the

00:07:45,889 --> 00:07:59,150
dead link and we introduced a new couple

00:07:55,219 --> 00:08:04,099
of new objects and that is that is the

00:07:59,150 --> 00:08:07,009
header and the table it is also again

00:08:04,099 --> 00:08:12,129
similar to before and the header

00:08:07,009 --> 00:08:15,050
describes this the packet formats

00:08:12,129 --> 00:08:19,759
provided names and field within the

00:08:15,050 --> 00:08:22,430
packet and and also it provides

00:08:19,759 --> 00:08:26,360
something which can be specific to the

00:08:22,430 --> 00:08:27,460
ASIC like metadata for example like

00:08:26,360 --> 00:08:31,300
internal

00:08:27,460 --> 00:08:34,060
or some some interface something like

00:08:31,300 --> 00:08:40,860
that router interface for example which

00:08:34,060 --> 00:08:40,860
is which cannot be done in a generic way

00:08:42,539 --> 00:08:52,420
table that describes a block as I

00:08:49,000 --> 00:08:56,170
already mentioned and it's supported as

00:08:52,420 --> 00:08:59,080
a net match action behavior and each

00:08:56,170 --> 00:09:01,029
table has a name so yeah there are a

00:08:59,080 --> 00:09:06,790
couple of commands introduced along with

00:09:01,029 --> 00:09:09,420
this you can get the the description of

00:09:06,790 --> 00:09:11,050
the table I mean the what are the

00:09:09,420 --> 00:09:14,980
nitrous and what are the actions

00:09:11,050 --> 00:09:19,800
possible you can get the header the

00:09:14,980 --> 00:09:23,920
headers which are possible to work with

00:09:19,800 --> 00:09:26,860
for specific device you can get the

00:09:23,920 --> 00:09:32,320
entries which are this is basically a

00:09:26,860 --> 00:09:35,620
dump of the table and also you can set

00:09:32,320 --> 00:09:37,390
for each table the counters if they are

00:09:35,620 --> 00:09:42,220
an a group of the table that this is

00:09:37,390 --> 00:09:45,279
actually the only right command which

00:09:42,220 --> 00:09:48,070
this interface provides the the rest of

00:09:45,279 --> 00:09:53,950
the interface is purely week only and

00:09:48,070 --> 00:09:57,190
that is the intent okay yeah so the

00:09:53,950 --> 00:10:00,730
interaction between that was described

00:09:57,190 --> 00:10:03,750
on the previous slide was that was the

00:10:00,730 --> 00:10:09,279
API to the user space now the API to the

00:10:03,750 --> 00:10:11,589
to the driver so we wanted to design it

00:10:09,279 --> 00:10:13,649
in a way it can be that the tables can

00:10:11,589 --> 00:10:16,510
be dynamically

00:10:13,649 --> 00:10:20,709
registered and unregistered on the fly

00:10:16,510 --> 00:10:24,910
because for example if we have like t

00:10:20,709 --> 00:10:27,250
cam we can create the regions and remove

00:10:24,910 --> 00:10:29,520
them dynamically so we need to have this

00:10:27,250 --> 00:10:29,520
dynamic

00:10:31,649 --> 00:10:39,550
there can be some headers which are

00:10:34,630 --> 00:10:43,360
specific to the driver I described it in

00:10:39,550 --> 00:10:49,509
the previous slide these are the

00:10:43,360 --> 00:10:51,940
metadata headers and each table each

00:10:49,509 --> 00:10:57,370
table object which is registered to dead

00:10:51,940 --> 00:11:01,329
link has to provide a couple of hops

00:10:57,370 --> 00:11:05,139
which are listed there or the first one

00:11:01,329 --> 00:11:07,839
is to dump the supported actions front

00:11:05,139 --> 00:11:11,649
table the second one is to dump the

00:11:07,839 --> 00:11:15,880
supporting matches and third one is to

00:11:11,649 --> 00:11:19,329
dump the the whole table at every entry

00:11:15,880 --> 00:11:27,040
in the table and also there is a option

00:11:19,329 --> 00:11:32,829
to set the set of counters okay okay so

00:11:27,040 --> 00:11:35,769
the sort of mass action as I said

00:11:32,829 --> 00:11:39,639
earlier it used to describe the table

00:11:35,769 --> 00:11:45,790
behavior basically the input and output

00:11:39,639 --> 00:11:49,269
of a block and they are kept very close

00:11:45,790 --> 00:11:52,959
to what hardware is actually doing and

00:11:49,269 --> 00:11:59,279
they are very there in a very primitive

00:11:52,959 --> 00:11:59,279
way later on in the slide I'll show you

00:11:59,370 --> 00:12:07,180
for example the reactions there are no

00:12:04,000 --> 00:12:10,720
such action lists as for example beyond

00:12:07,180 --> 00:12:14,050
pop up push you just we just have failed

00:12:10,720 --> 00:12:17,350
modifier which will set some specific

00:12:14,050 --> 00:12:19,990
header and field value and we have had a

00:12:17,350 --> 00:12:21,639
push and pop and we have field increment

00:12:19,990 --> 00:12:28,449
and decrement that's basically it

00:12:21,639 --> 00:12:31,600
so if you if you want to use this to

00:12:28,449 --> 00:12:34,980
expose some more complicated action you

00:12:31,600 --> 00:12:39,990
have to make it

00:12:34,980 --> 00:12:42,610
we assembled from this primitive actions

00:12:39,990 --> 00:12:47,290
there are a couple of matches at this

00:12:42,610 --> 00:12:48,699
moment is one match which does only

00:12:47,290 --> 00:12:51,790
exact matching and the second one does

00:12:48,699 --> 00:13:04,509
takes of machine with which is maxed

00:12:51,790 --> 00:13:07,750
mask masked actually yeah so what is

00:13:04,509 --> 00:13:14,250
entry the entry is one line in the table

00:13:07,750 --> 00:13:19,899
basically and it contains a list of

00:13:14,250 --> 00:13:23,350
match list of match values this can be

00:13:19,899 --> 00:13:25,779
only a subset of the table so it can be

00:13:23,350 --> 00:13:31,089
one of the it can be one of those or can

00:13:25,779 --> 00:13:35,920
be all the matches which table provides

00:13:31,089 --> 00:13:39,660
and the other thing which is part of the

00:13:35,920 --> 00:13:43,290
entry is the list of actions and also

00:13:39,660 --> 00:13:43,290
counter if it's available

00:13:47,410 --> 00:13:56,859
one yeah this part I don't really I

00:13:52,569 --> 00:14:00,220
don't really agree with Arkady with I

00:13:56,859 --> 00:14:03,989
think it might be not possible to do it

00:14:00,220 --> 00:14:06,369
but basically the idea is that from this

00:14:03,989 --> 00:14:08,739
description of the tables from the

00:14:06,369 --> 00:14:11,499
magician from the actions you can

00:14:08,739 --> 00:14:18,159
essentially assemble the graph itself

00:14:11,499 --> 00:14:21,099
because you can see that some some table

00:14:18,159 --> 00:14:23,349
action is to set some specific metadata

00:14:21,099 --> 00:14:26,519
and another table matches on the

00:14:23,349 --> 00:14:30,249
specific metadata so we can somehow

00:14:26,519 --> 00:14:31,839
connect it together but I'm going to

00:14:30,249 --> 00:14:36,879
serve it's entirely possible for every

00:14:31,839 --> 00:14:39,399
cases but if it would be a good that we

00:14:36,879 --> 00:14:41,889
began just from this information we have

00:14:39,399 --> 00:14:44,379
now we can we just provided to the user

00:14:41,889 --> 00:14:49,299
space and usual can assemble the path

00:14:44,379 --> 00:14:52,839
graph okay

00:14:49,299 --> 00:14:55,989
that's sure if it's if you see good

00:14:52,839 --> 00:15:00,959
I don't so this is this is actually

00:14:55,989 --> 00:15:05,739
example of the of the LC lookup which is

00:15:00,959 --> 00:15:08,619
taken from our this is this is basically

00:15:05,739 --> 00:15:15,119
the tables which are in our ASIC of

00:15:08,619 --> 00:15:17,249
course the sizes are are made up yeah

00:15:15,119 --> 00:15:21,669
definitely

00:15:17,249 --> 00:15:24,729
so on the so basically you can you can

00:15:21,669 --> 00:15:28,749
see that there are four tables the first

00:15:24,729 --> 00:15:32,470
one is called rpm it's it's a set of

00:15:28,749 --> 00:15:38,199
tables actually because for each prefix

00:15:32,470 --> 00:15:45,909
length there is one table and according

00:15:38,199 --> 00:15:50,109
to where whether if the destination if

00:15:45,909 --> 00:15:53,609
this is the route is local it either

00:15:50,109 --> 00:15:53,609
matches the

00:15:54,520 --> 00:16:04,160
yeah if you read this local the the risk

00:15:58,100 --> 00:16:06,230
port is it is an action so you can see

00:16:04,160 --> 00:16:09,460
you can go directly to the local table

00:16:06,230 --> 00:16:14,270
according to the to the report you can

00:16:09,460 --> 00:16:17,990
you can find out the MAC address if it's

00:16:14,270 --> 00:16:22,430
if the route is not local you have an

00:16:17,990 --> 00:16:25,250
action which actually sets the adjacency

00:16:22,430 --> 00:16:30,740
table index and the size which is

00:16:25,250 --> 00:16:33,560
basically any CMP group and it goes to

00:16:30,740 --> 00:16:39,880
the adjacency table and according to

00:16:33,560 --> 00:16:48,560
that it will also create a report and

00:16:39,880 --> 00:16:51,260
and yeah the last table just according

00:16:48,560 --> 00:16:57,190
to the report it does before running or

00:16:51,260 --> 00:16:57,190
not so this is just basic example

00:17:00,410 --> 00:17:09,290
here you can see a couple of outputs of

00:17:03,810 --> 00:17:15,690
the user space of this user space part

00:17:09,290 --> 00:17:20,610
of that link first first command just

00:17:15,690 --> 00:17:26,760
dumps the headers which are supported

00:17:20,610 --> 00:17:30,300
for this specific device you can see

00:17:26,760 --> 00:17:33,780
that the only header which is supported

00:17:30,300 --> 00:17:40,290
for this device is Alyssa's w underscore

00:17:33,780 --> 00:17:44,970
meta stands for the metadata and you can

00:17:40,290 --> 00:17:48,780
see the list of headers which is I mean

00:17:44,970 --> 00:17:55,070
list of fields which is a report and

00:17:48,780 --> 00:17:55,070
forward and that alpha drop

00:17:59,180 --> 00:18:04,760
yeah and the second command is to

00:18:02,860 --> 00:18:10,770
[Music]

00:18:04,760 --> 00:18:13,440
actually list to show the table by the

00:18:10,770 --> 00:18:15,150
name you can see at the end of the

00:18:13,440 --> 00:18:16,590
command line there is the name of the

00:18:15,150 --> 00:18:21,150
table a malicious double underscore

00:18:16,590 --> 00:18:25,170
erase and it basically the output shows

00:18:21,150 --> 00:18:29,940
you the possible matches and possible

00:18:25,170 --> 00:18:32,310
actions for this table since this is

00:18:29,940 --> 00:18:36,270
currently the only table we have

00:18:32,310 --> 00:18:41,070
implemented its but we definitely want

00:18:36,270 --> 00:18:46,620
to extend our drive to to provide much

00:18:41,070 --> 00:18:50,970
more tables in the future yeah here you

00:18:46,620 --> 00:18:54,530
can see actually the dump dump of the

00:18:50,970 --> 00:18:59,660
table itself so you can see two entries

00:18:54,530 --> 00:19:02,670
there is a there is an index over there

00:18:59,660 --> 00:19:08,790
in the zero index one foot for the two

00:19:02,670 --> 00:19:12,870
entries and you can see also the mapping

00:19:08,790 --> 00:19:15,720
value field which actually

00:19:12,870 --> 00:19:19,740
provides you two nothing to the net

00:19:15,720 --> 00:19:26,159
device if' indexes which is which might

00:19:19,740 --> 00:19:29,549
be handy for the user to know what what

00:19:26,159 --> 00:19:33,750
net device is he dealing with so just a

00:19:29,549 --> 00:19:38,970
hint yeah

00:19:33,750 --> 00:19:43,400
so for the future the plans are to to

00:19:38,970 --> 00:19:47,220
basically to introduce some kind of

00:19:43,400 --> 00:19:50,760
nesting because the in Hardware the

00:19:47,220 --> 00:19:54,140
building blocks are like you have a CL

00:19:50,760 --> 00:19:58,049
building block you have l2 l3 and

00:19:54,140 --> 00:20:03,200
they're like big modules you probably

00:19:58,049 --> 00:20:07,890
want to zoom in and to see more details

00:20:03,200 --> 00:20:12,630
so as an example the nesting you can see

00:20:07,890 --> 00:20:17,600
that l3 block actually contains more

00:20:12,630 --> 00:20:20,669
virtual routers and that contains LPM

00:20:17,600 --> 00:20:24,090
table and that LPM table contains a

00:20:20,669 --> 00:20:26,159
couple of tables of the prefixes so

00:20:24,090 --> 00:20:30,090
basically either you are interested in

00:20:26,159 --> 00:20:32,309
the in a bigger picture or you can zoom

00:20:30,090 --> 00:20:40,230
in and to see the actual tables how they

00:20:32,309 --> 00:20:46,169
look like in the details another thing

00:20:40,230 --> 00:20:52,140
is that many tables actually share the

00:20:46,169 --> 00:20:54,240
resources among them so this is

00:20:52,140 --> 00:20:58,260
something which definitely needs to be

00:20:54,240 --> 00:21:01,590
exposed as well me personally I'm not

00:20:58,260 --> 00:21:06,270
sure how to do it but we have to find a

00:21:01,590 --> 00:21:07,140
way I guess otherwise it won't be that

00:21:06,270 --> 00:21:14,120
usable

00:21:07,140 --> 00:21:14,120
I mean pretty much important

00:21:14,540 --> 00:21:21,890
also another plan is to introduce some

00:21:18,230 --> 00:21:27,110
external tool because now we just we can

00:21:21,890 --> 00:21:30,460
just dump to Jason which is nice but as

00:21:27,110 --> 00:21:34,100
you have like huge tables and you

00:21:30,460 --> 00:21:39,040
actually want to figure out what what's

00:21:34,100 --> 00:21:42,410
going on there it's not that easy so

00:21:39,040 --> 00:21:46,400
that would be good to actually push this

00:21:42,410 --> 00:21:50,090
output to some some tool and it can do

00:21:46,400 --> 00:21:55,250
some some magic with that so you can

00:21:50,090 --> 00:22:03,230
actually see what's going on I think is

00:21:55,250 --> 00:22:05,840
it yeah that's it the questions I'll ask

00:22:03,230 --> 00:22:06,380
a question so eat well what happened to

00:22:05,840 --> 00:22:10,400
the slides

00:22:06,380 --> 00:22:14,470
they've gone sorry where the slides are

00:22:10,400 --> 00:22:18,740
gone from the screen oh yeah huh

00:22:14,470 --> 00:22:21,770
can we put them back please okay so I'm

00:22:18,740 --> 00:22:24,020
not doing this your colleague Arkady

00:22:21,770 --> 00:22:29,060
right I think he may have a point go

00:22:24,020 --> 00:22:31,280
back to that slide where you're which

00:22:29,060 --> 00:22:32,600
way is talking about building the graph

00:22:31,280 --> 00:22:35,890
dynamic I think it's this one here

00:22:32,600 --> 00:22:39,770
but what dynamically building the graph

00:22:35,890 --> 00:22:41,300
you said you disagree with him will it

00:22:39,770 --> 00:22:43,720
work I don't know which one is I think

00:22:41,300 --> 00:22:50,450
those before here hmm

00:22:43,720 --> 00:22:54,230
that's the one oh yeah okay so yeah so

00:22:50,450 --> 00:22:56,750
yeah the building graph is possible if

00:22:54,230 --> 00:22:59,450
you can also find you can somehow in

00:22:56,750 --> 00:23:03,710
code constraints right if you say for

00:22:59,450 --> 00:23:05,630
example you can say match this then drop

00:23:03,710 --> 00:23:07,160
and then redirect and then police right

00:23:05,630 --> 00:23:09,380
that doesn't make any sense from a graph

00:23:07,160 --> 00:23:13,630
perspective so if you're able to somehow

00:23:09,380 --> 00:23:19,000
describe a constraint you say drop so a

00:23:13,630 --> 00:23:19,000
redirect can't come after drop and

00:23:19,650 --> 00:23:23,310
so if you could describe who your left

00:23:21,660 --> 00:23:24,840
neighbor could be the possibilities are

00:23:23,310 --> 00:23:26,940
and who your right neighbor could be

00:23:24,840 --> 00:23:28,710
yeah then it's possible to and you can

00:23:26,940 --> 00:23:31,380
extract these capabilities out of the

00:23:28,710 --> 00:23:34,290
hardware then it's possible to create a

00:23:31,380 --> 00:23:35,730
dynamic graph on the fly the only

00:23:34,290 --> 00:23:37,830
challenge is you have to start

00:23:35,730 --> 00:23:39,920
standardizing what the action is because

00:23:37,830 --> 00:23:43,770
if you have a broad combs chip that's

00:23:39,920 --> 00:23:46,290
describing LPM with an embedded next-hop

00:23:43,770 --> 00:23:48,660
table inside where somebody else has a

00:23:46,290 --> 00:23:51,090
different implementation that it may not

00:23:48,660 --> 00:23:52,680
work right you can have a universal

00:23:51,090 --> 00:23:54,510
program that looks at this stuff

00:23:52,680 --> 00:23:56,280
that's where linux becomes useful

00:23:54,510 --> 00:23:57,810
because if you write to the driver

00:23:56,280 --> 00:24:00,240
reveler the switch dev level you don't

00:23:57,810 --> 00:24:01,830
care about this stuff the only reason I

00:24:00,240 --> 00:24:05,040
would look at this is because I know how

00:24:01,830 --> 00:24:06,930
the Mellanox chip works I know I can

00:24:05,040 --> 00:24:09,630
look deeper into its implementation and

00:24:06,930 --> 00:24:14,430
thick and optimize but that's my view

00:24:09,630 --> 00:24:15,630
yeah I have two questions um that the

00:24:14,430 --> 00:24:17,760
first one is I've heard there's this

00:24:15,630 --> 00:24:19,170
forces thing that may describe the kind

00:24:17,760 --> 00:24:20,310
of elements like this and I heard those

00:24:19,170 --> 00:24:22,440
people this room that might know

00:24:20,310 --> 00:24:25,560
something about it and it seems to me

00:24:22,440 --> 00:24:27,650
like those DUHS this Apple does the the

00:24:25,560 --> 00:24:30,030
forwarding elements pieces do they

00:24:27,650 --> 00:24:31,980
should he be modeling them based on that

00:24:30,030 --> 00:24:33,930
yeah it's pretty trivial to model it

00:24:31,980 --> 00:24:37,110
okay so I think that's really the other

00:24:33,930 --> 00:24:39,480
question I had is um so what if my

00:24:37,110 --> 00:24:41,970
hardware is an intel x86 running linux

00:24:39,480 --> 00:24:43,380
kernel um shouldn't I be able to use the

00:24:41,970 --> 00:24:48,450
same tools to debug let the health

00:24:43,380 --> 00:24:51,240
happen to my packets wait I I don't

00:24:48,450 --> 00:24:54,150
understand well I mean it's quite hard

00:24:51,240 --> 00:24:56,130
to understand here right okay didn't he

00:24:54,150 --> 00:24:58,350
understand so I'm being a bit busy so

00:24:56,130 --> 00:25:00,210
I'm saying this is really cool and it's

00:24:58,350 --> 00:25:01,470
really important to build this kind of

00:25:00,210 --> 00:25:03,060
debugging through the hardware because

00:25:01,470 --> 00:25:05,910
you don't have any other way to do this

00:25:03,060 --> 00:25:08,070
because it's hardware a lot of the

00:25:05,910 --> 00:25:09,870
people in this room would you know put

00:25:08,070 --> 00:25:11,250
some counters or print tech Caze or

00:25:09,870 --> 00:25:13,020
something like that through a kernel to

00:25:11,250 --> 00:25:16,080
figure out what's going on in software

00:25:13,020 --> 00:25:17,940
that itself is really annoying because

00:25:16,080 --> 00:25:21,960
you have to damn well rebuild it and you

00:25:17,940 --> 00:25:24,000
wind up with with a lot of code that

00:25:21,960 --> 00:25:26,730
slows it down in the wrong places and so

00:25:24,000 --> 00:25:29,610
be really interesting if your same model

00:25:26,730 --> 00:25:32,070
could be used applied you know kind of

00:25:29,610 --> 00:25:33,570
the black box that's the Linux kernel

00:25:32,070 --> 00:25:35,640
at least at the black box - a lot of

00:25:33,570 --> 00:25:38,280
operators so that we could actually get

00:25:35,640 --> 00:25:39,420
in the field debugging out of some of

00:25:38,280 --> 00:25:41,280
this I know there's a lot of other

00:25:39,420 --> 00:25:42,600
pieces and dtrace points and other stuff

00:25:41,280 --> 00:25:44,580
like that that can be used and I think

00:25:42,600 --> 00:25:47,340
that's very a good way to approach it

00:25:44,580 --> 00:25:50,730
but it seems like it would be great if

00:25:47,340 --> 00:25:54,930
if an operator didn't actually have to

00:25:50,730 --> 00:25:57,630
care whether he was using a hardware

00:25:54,930 --> 00:25:59,760
accelerator or not underneath there

00:25:57,630 --> 00:26:02,190
you could get similar statistics like

00:25:59,760 --> 00:26:06,620
debugging that make sense to you you

00:26:02,190 --> 00:26:08,820
know okay okay I mean the thing is I I

00:26:06,620 --> 00:26:11,430
understand what Michael is saying so can

00:26:08,820 --> 00:26:13,050
i well I I mean the thing is that you

00:26:11,430 --> 00:26:14,460
don't need to visibility for the for the

00:26:13,050 --> 00:26:17,100
kernel because you already have it right

00:26:14,460 --> 00:26:18,690
you can just don't no no no there's a so

00:26:17,100 --> 00:26:21,150
for example let's say somebody enters a

00:26:18,690 --> 00:26:21,690
stupid TC role like what I just

00:26:21,150 --> 00:26:26,880
described

00:26:21,690 --> 00:26:30,390
he entered much full action drop action

00:26:26,880 --> 00:26:32,430
redirect right if you could actually and

00:26:30,390 --> 00:26:34,440
so I don't want to plug-in forces but

00:26:32,430 --> 00:26:37,050
yes true forces has all this construct

00:26:34,440 --> 00:26:38,460
but you if you could discover the

00:26:37,050 --> 00:26:40,590
capabilities from the kernel if you

00:26:38,460 --> 00:26:43,050
could suck them out of the kernel you

00:26:40,590 --> 00:26:44,550
would be able to stop stupid policies

00:26:43,050 --> 00:26:46,440
being implemented right so it's that

00:26:44,550 --> 00:26:49,530
discovery the fact that I think what he

00:26:46,440 --> 00:26:53,850
means is if we added such constraints am

00:26:49,530 --> 00:26:56,180
i correct number one you could stop bad

00:26:53,850 --> 00:26:59,070
policies but number two is you could

00:26:56,180 --> 00:27:01,440
poke into the connivance and check if

00:26:59,070 --> 00:27:07,290
you mean but again see we want to

00:27:01,440 --> 00:27:10,710
somehow limit the user to not to be able

00:27:07,290 --> 00:27:13,110
to include rules which does no clicks

00:27:10,710 --> 00:27:15,840
doesn't make sense that's one how how

00:27:13,110 --> 00:27:18,750
does it how is it connected with this

00:27:15,840 --> 00:27:20,400
debug pipeline well if I'm if they

00:27:18,750 --> 00:27:25,080
needed the constraints if you could

00:27:20,400 --> 00:27:30,510
expose the constraints right about what

00:27:25,080 --> 00:27:34,080
it makes sense to to to offload okay we

00:27:30,510 --> 00:27:35,910
have it could be as simple as how many

00:27:34,080 --> 00:27:37,740
how do a table interest that's not what

00:27:35,910 --> 00:27:39,150
I mean it's not what I mean at all let's

00:27:37,740 --> 00:27:41,400
say let's say let's say I push down

00:27:39,150 --> 00:27:44,160
let's say push down a classifier of some

00:27:41,400 --> 00:27:45,660
kind to some hardware it says an

00:27:44,160 --> 00:27:50,340
Ethernet byte

00:27:45,660 --> 00:27:54,420
14 and 15 I said that in purpose wrong I

00:27:50,340 --> 00:27:55,710
want to do something with 888 DDD's ipv6

00:27:54,420 --> 00:27:58,500
do something and send it the wrong way

00:27:55,710 --> 00:28:01,890
okay so I was some layer to filtering

00:27:58,500 --> 00:28:03,390
that your thing implements and and I've

00:28:01,890 --> 00:28:04,530
set up a whole bunch of policies and a

00:28:03,390 --> 00:28:06,620
bunch of things and it's going to go

00:28:04,530 --> 00:28:09,510
through your example of the L to the l3

00:28:06,620 --> 00:28:13,140
prefix match no table was a good one

00:28:09,510 --> 00:28:15,050
right so I want it something's done

00:28:13,140 --> 00:28:17,820
clearly I've made a mistake

00:28:15,050 --> 00:28:22,410
right I can't possibly debug it with

00:28:17,820 --> 00:28:24,930
print Ches and the hardware right can't

00:28:22,410 --> 00:28:27,600
do it right so I want to know I want to

00:28:24,930 --> 00:28:28,500
know what how did it flow why is it

00:28:27,600 --> 00:28:31,560
going the wrong way

00:28:28,500 --> 00:28:34,620
and so my understanding is that you're

00:28:31,560 --> 00:28:36,270
providing a facility such that now I can

00:28:34,620 --> 00:28:38,610
ask questions like well why are the

00:28:36,270 --> 00:28:41,250
packets going out port 12 when they're

00:28:38,610 --> 00:28:43,920
supposed to be going out port 9 right of

00:28:41,250 --> 00:28:45,450
the switch or something whatever and you

00:28:43,920 --> 00:28:48,150
know and you say well it's because you

00:28:45,450 --> 00:28:50,760
keep hitting hash entry twelve okay and

00:28:48,150 --> 00:28:52,140
like well but that's wrong and I pull

00:28:50,760 --> 00:28:53,850
all the data out in all these nice

00:28:52,140 --> 00:28:55,590
tables and I go oh my goodness

00:28:53,850 --> 00:28:57,510
look of course it's going that way

00:28:55,590 --> 00:28:59,640
because that's where the bikes tell me

00:28:57,510 --> 00:29:01,080
to go and I made a mistake if I

00:28:59,640 --> 00:29:05,700
understand it correctly what you would

00:29:01,080 --> 00:29:09,690
like to see is some kind of like in

00:29:05,700 --> 00:29:12,870
place talk options for the hardware

00:29:09,690 --> 00:29:14,430
itself like this this is just like

00:29:12,870 --> 00:29:17,760
dumping of the tables doesn't really

00:29:14,430 --> 00:29:19,500
tell you which packets school we're like

00:29:17,760 --> 00:29:21,600
well does these digital counters it's

00:29:19,500 --> 00:29:23,160
right behind counter available right so

00:29:21,600 --> 00:29:25,140
how many packets went down a particular

00:29:23,160 --> 00:29:26,430
path at writing they think here right so

00:29:25,140 --> 00:29:27,960
how many packets going through in a

00:29:26,430 --> 00:29:30,510
particular path that's almost all you

00:29:27,960 --> 00:29:32,790
can get from hardware is is this many

00:29:30,510 --> 00:29:35,040
went this way this many match the action

00:29:32,790 --> 00:29:36,990
this action happened whatever from that

00:29:35,040 --> 00:29:39,240
somehow I can say well I was expecting

00:29:36,990 --> 00:29:41,070
10,000 packets to go left and five

00:29:39,240 --> 00:29:43,200
thousand packets to go right but you

00:29:41,070 --> 00:29:45,150
won't like when you send a specific

00:29:43,200 --> 00:29:46,710
packet you want to know what happened

00:29:45,150 --> 00:29:49,020
what's happening with this specific

00:29:46,710 --> 00:29:51,120
packets right or maybe I can't do that

00:29:49,020 --> 00:29:53,490
because I'm running at two fast speeds

00:29:51,120 --> 00:29:56,520
to send one packet but I can see that I

00:29:53,490 --> 00:29:59,130
expect 25% to left and 50% to go right

00:29:56,520 --> 00:29:59,580
and I don't see that the counters say

00:29:59,130 --> 00:30:01,680
different

00:29:59,580 --> 00:30:03,660
and I could finally conclude that upside

00:30:01,680 --> 00:30:05,610
is supposed to do bytes 13 and 14 as I

00:30:03,660 --> 00:30:09,360
made an off day one error counting from

00:30:05,610 --> 00:30:11,310
my packet right so I can say oh okay

00:30:09,360 --> 00:30:12,870
something's wrong there right so that's

00:30:11,310 --> 00:30:14,580
a kind of that's that's the only way

00:30:12,870 --> 00:30:17,100
you're going to debug something in in

00:30:14,580 --> 00:30:18,990
the field or in with at high speeds in

00:30:17,100 --> 00:30:20,310
the lab right right so you agree with

00:30:18,990 --> 00:30:22,380
that and that's on I understand you're

00:30:20,310 --> 00:30:24,810
trying to provide if I'm not mistaken

00:30:22,380 --> 00:30:28,380
then tell me I'm misunderstood your

00:30:24,810 --> 00:30:30,930
presentation yeah well you can certainly

00:30:28,380 --> 00:30:33,720
use it for that but you get you got the

00:30:30,930 --> 00:30:35,250
counter so you know what's happening but

00:30:33,720 --> 00:30:38,750
if you want to track like specific

00:30:35,250 --> 00:30:41,040
packet and you want to know yeah

00:30:38,750 --> 00:30:42,960
actually you like it and a million of

00:30:41,040 --> 00:30:44,880
the specific packets and that that'll

00:30:42,960 --> 00:30:47,190
know my pipe it might and whatever yeah

00:30:44,880 --> 00:30:48,510
because because I try to express what

00:30:47,190 --> 00:30:50,190
you what I thought you said and you say

00:30:48,510 --> 00:30:55,920
that's not what I said I'm going to cut

00:30:50,190 --> 00:30:57,810
your mic now okay okay so we will end

00:30:55,920 --> 00:30:59,950
this thanks Eric

00:30:57,810 --> 00:31:02,799
let's give

00:30:59,950 --> 00:31:02,799

YouTube URL: https://www.youtube.com/watch?v=RNMDQKcfE7I


