Title: netdev2-1: Playing BBR with a userspace network stack By Hajime Tazaki
Publication date: 2017-05-16
Playlist: Netdev 2.1
Description: 
	In this talk given at Netdev 2.1 in Montreal on April 7th 2017, Hajime Tazaki looks at some of the obstacles in moving the linux network stack to user space via the LKL infrastructure.

The talk focuses on timing accuracy concerns of a userspace network stack. Hajime presents the result of netperf benchmarks on select Linux TCP congestion control algorithms: BBR and cubic.
He compares both the LKL-ed netperf and ordinal netperf with Linux kernel and discusses what obstacle exist within LKL and what can be fixed to reach x1 performance of the barebone kernel network stack.

Content at:
https://www.netdevconf.org/2.1/session.html?tazaki
Captions: 
	00:00:00,410 --> 00:00:08,000
hiya morning i'm hajime for my IJ and

00:00:05,100 --> 00:00:10,920
today I'm going to talk about my recent

00:00:08,000 --> 00:00:15,240
personal experience playing with the you

00:00:10,920 --> 00:00:17,369
justice natok stockless Realty new PCP

00:00:15,240 --> 00:00:19,560
condition controls ambience

00:00:17,369 --> 00:00:21,570
I'm very happy to back to this

00:00:19,560 --> 00:00:24,090
conference as a speaker because I was

00:00:21,570 --> 00:00:30,570
not involved in any kind of put together

00:00:24,090 --> 00:00:33,780
talking the last conference so this talk

00:00:30,570 --> 00:00:36,210
is all about that my current project

00:00:33,780 --> 00:00:39,780
which is about the Linux car which is

00:00:36,210 --> 00:00:42,989
called the Excalibur library this is

00:00:39,780 --> 00:00:46,170
kind of the framework that you can use

00:00:42,989 --> 00:00:48,690
the Linux kernel code on top of the

00:00:46,170 --> 00:00:52,199
various platform the bias platform

00:00:48,690 --> 00:00:55,379
includes the user space Network

00:00:52,199 --> 00:01:00,180
applications you can do any kind of user

00:00:55,379 --> 00:01:02,879
space and you can use any kind of Linux

00:01:00,180 --> 00:01:04,830
color code directory inside the user

00:01:02,879 --> 00:01:08,189
space application occur you can do fuse

00:01:04,830 --> 00:01:11,880
news views to you tear the file system

00:01:08,189 --> 00:01:15,509
Network and block devices and the other

00:01:11,880 --> 00:01:19,740
example of this Linux kernel driver is

00:01:15,509 --> 00:01:21,930
to be hosts as the cool part of the unit

00:01:19,740 --> 00:01:24,150
Connor and Connor is the kind of the

00:01:21,930 --> 00:01:26,759
single application framework that can be

00:01:24,150 --> 00:01:30,890
run on top of the hypervisor directory

00:01:26,759 --> 00:01:35,189
without involving any under agree and

00:01:30,890 --> 00:01:38,640
they are another example you can do a

00:01:35,189 --> 00:01:41,280
detox mission which is which I have been

00:01:38,640 --> 00:01:43,470
talk about this feature in the past

00:01:41,280 --> 00:01:46,280
native APIs for human testing you can

00:01:43,470 --> 00:01:49,380
take a look at the video on the site and

00:01:46,280 --> 00:01:51,990
then most of the benefit to do such a

00:01:49,380 --> 00:01:56,460
things with this library is you can be

00:01:51,990 --> 00:01:58,680
used the mature Linux kernel call in a

00:01:56,460 --> 00:02:01,219
different environment so if you can if

00:01:58,680 --> 00:02:04,020
you want to do some you want to have a

00:02:01,219 --> 00:02:07,530
little specific network so for example

00:02:04,020 --> 00:02:10,679
you can do bigger increments you are

00:02:07,530 --> 00:02:12,610
only those all networks up from scratch

00:02:10,679 --> 00:02:14,530
while you can put some

00:02:12,610 --> 00:02:17,650
this thing called into your application

00:02:14,530 --> 00:02:22,180
but in this framework we don't have to

00:02:17,650 --> 00:02:23,980
do such a implementation of a 14-4 to

00:02:22,180 --> 00:02:27,580
utilize on the body and different

00:02:23,980 --> 00:02:31,180
different environments so the use cases

00:02:27,580 --> 00:02:32,890
is we have a three different discrete is

00:02:31,180 --> 00:02:34,960
for this and one of them is the

00:02:32,890 --> 00:02:38,740
operating system personality to

00:02:34,960 --> 00:02:41,190
introduce new feature without involving

00:02:38,740 --> 00:02:44,350
the whole circuit host operating system

00:02:41,190 --> 00:02:47,710
or with the unicolor use cases you can

00:02:44,350 --> 00:02:51,190
do you can create a very tiny guest

00:02:47,710 --> 00:02:52,930
operating system which you can associate

00:02:51,190 --> 00:02:57,400
for many numbers of the guest operating

00:02:52,930 --> 00:02:59,260
system in a single physical mode or the

00:02:57,400 --> 00:03:06,370
network with an approximation you can

00:02:59,260 --> 00:03:10,030
test or debug you linux kernel code with

00:03:06,370 --> 00:03:14,770
the kind of the framework to continuous

00:03:10,030 --> 00:03:21,250
integration test so the motivation

00:03:14,770 --> 00:03:23,980
behind this work at least for me is to

00:03:21,250 --> 00:03:26,110
tackle to tackle the existing industries

00:03:23,980 --> 00:03:29,050
network stack so there are formally

00:03:26,110 --> 00:03:32,950
numbers of the you dismiss toxic then

00:03:29,050 --> 00:03:36,070
the disk if this is very short part of

00:03:32,950 --> 00:03:41,350
the leaders that net user space network

00:03:36,070 --> 00:03:44,680
implementation and all of them has have

00:03:41,350 --> 00:03:47,590
a very beautiful number to improve the

00:03:44,680 --> 00:03:51,100
performance of the network stack but at

00:03:47,590 --> 00:03:53,410
the same time they degrade many many

00:03:51,100 --> 00:03:57,459
kinds many aspects of the network stack

00:03:53,410 --> 00:03:59,080
some of them do the just existing

00:03:57,459 --> 00:04:00,220
application support because they don't

00:03:59,080 --> 00:04:03,580
have the project API

00:04:00,220 --> 00:04:08,380
some of them only intimate partial part

00:04:03,580 --> 00:04:12,610
of the network service like the mainly

00:04:08,380 --> 00:04:15,760
support ipv6 for example so I don't want

00:04:12,610 --> 00:04:19,269
to do success stuff I do really want to

00:04:15,760 --> 00:04:20,590
be use the maturity talk stock even

00:04:19,269 --> 00:04:21,419
though we are using the different

00:04:20,590 --> 00:04:24,900
environment

00:04:21,419 --> 00:04:28,530
you know Fresnel toxins and because the

00:04:24,900 --> 00:04:31,620
implementation is maybe we need to give

00:04:28,530 --> 00:04:35,610
up the the lecturer F maturing

00:04:31,620 --> 00:04:39,120
implementation which is the output of

00:04:35,610 --> 00:04:42,419
the couple of decades result and the

00:04:39,120 --> 00:04:46,889
eternal support but the 14 is also in

00:04:42,419 --> 00:04:50,099
introduced another problem in you really

00:04:46,889 --> 00:04:54,689
spend much of time to track the newest

00:04:50,099 --> 00:04:58,909
version the original code and the using

00:04:54,689 --> 00:05:01,889
is also makes another benefit to

00:04:58,909 --> 00:05:04,610
preserve the various semantics of the

00:05:01,889 --> 00:05:07,800
body and the original versions of

00:05:04,610 --> 00:05:11,039
original version a Linux kernel you can

00:05:07,800 --> 00:05:13,560
preserve the syntax level compatibility

00:05:11,039 --> 00:05:16,349
with the different different operating

00:05:13,560 --> 00:05:20,370
system and you can preserve the API or

00:05:16,349 --> 00:05:23,069
system horrible compatibility and adults

00:05:20,370 --> 00:05:25,919
compatibility benefit to utilize your

00:05:23,069 --> 00:05:30,389
existing tools or using the application

00:05:25,919 --> 00:05:33,479
with a different environment I don't

00:05:30,389 --> 00:05:38,370
have much strong opinion for speed of

00:05:33,479 --> 00:05:41,430
with the user with this framework like

00:05:38,370 --> 00:05:44,430
the any kind of modulation technology

00:05:41,430 --> 00:05:47,270
like hypervisor hypervisor warrick

00:05:44,430 --> 00:05:51,419
horrible realization technologies we can

00:05:47,270 --> 00:05:54,029
our goal for the performance alchemist

00:05:51,419 --> 00:05:58,189
quarries to achieve the same speed of

00:05:54,029 --> 00:05:58,189
the original version so general colonel

00:05:58,279 --> 00:06:05,279
so how it looks like how the LK looks

00:06:02,099 --> 00:06:08,039
like relaxed color library is

00:06:05,279 --> 00:06:10,529
implemented as Hardware independent the

00:06:08,039 --> 00:06:13,009
architecture which is called access ok

00:06:10,529 --> 00:06:13,009
and

00:06:17,460 --> 00:06:26,790
so the motivation behind this this

00:06:22,410 --> 00:06:29,970
diagram is we are trying to not modify

00:06:26,790 --> 00:06:32,850
this next color part as well as the

00:06:29,970 --> 00:06:35,400
application code so we can use the

00:06:32,850 --> 00:06:38,070
kernel implementation as well as the

00:06:35,400 --> 00:06:42,350
application with this framework so in

00:06:38,070 --> 00:06:45,930
order to achieve this benefit we put a

00:06:42,350 --> 00:06:49,800
predefined intermediate layer between

00:06:45,930 --> 00:06:54,110
the application the Linux kernel and the

00:06:49,800 --> 00:06:58,260
harder engine adapter as well as the

00:06:54,110 --> 00:07:01,890
host host environment in order to

00:06:58,260 --> 00:07:06,480
obstruct the underlying execution

00:07:01,890 --> 00:07:09,830
environment so it is the current body of

00:07:06,480 --> 00:07:12,960
the earth care we support the various

00:07:09,830 --> 00:07:17,550
operating system with the use of this

00:07:12,960 --> 00:07:20,340
application execution and it can also

00:07:17,550 --> 00:07:22,800
learn this library application with

00:07:20,340 --> 00:07:25,080
library on top of that on top of the

00:07:22,800 --> 00:07:29,780
hypervisor directory right now we only

00:07:25,080 --> 00:07:33,360
have a KVM with the very specific

00:07:29,780 --> 00:07:37,320
environment with specific platform

00:07:33,360 --> 00:07:40,200
support but we are going to remain be

00:07:37,320 --> 00:07:43,440
able to easily support the very

00:07:40,200 --> 00:07:49,680
hypervisor for example and the dysentry

00:07:43,440 --> 00:07:53,370
we also added the the UEFI boot for the

00:07:49,680 --> 00:07:56,760
support which means that you can access

00:07:53,370 --> 00:08:00,180
the file systems before building the

00:07:56,760 --> 00:08:05,790
before booting operating systems finder

00:08:00,180 --> 00:08:08,250
you UEFI controller prompt you can

00:08:05,790 --> 00:08:12,780
access the files in order to check how

00:08:08,250 --> 00:08:14,850
the boot process is going on and the to

00:08:12,780 --> 00:08:17,460
support the existing application we also

00:08:14,850 --> 00:08:20,640
ported the standard library for this

00:08:17,460 --> 00:08:23,630
particular teaching architecture which

00:08:20,640 --> 00:08:26,250
is based on the mass muscle gives the

00:08:23,630 --> 00:08:28,140
implementation and we also introduced

00:08:26,250 --> 00:08:29,870
the cost comparison builders change

00:08:28,140 --> 00:08:33,590
based on the ramp

00:08:29,870 --> 00:08:37,760
Ranieri contributions so I'm going to

00:08:33,590 --> 00:08:42,800
show the couple of demos for this use

00:08:37,760 --> 00:08:46,570
cases for the past demo shows the Jesus

00:08:42,800 --> 00:08:49,370
person a truck stuck with the and

00:08:46,570 --> 00:08:50,000
defined from the host operating system

00:08:49,370 --> 00:08:55,370
works

00:08:50,000 --> 00:09:00,790
so in this horse we are using the 4.9

00:08:55,370 --> 00:09:05,410
belgium the kernel but with this special

00:09:00,790 --> 00:09:07,550
configuration and environment variables

00:09:05,410 --> 00:09:09,620
which is conferring the gateway address

00:09:07,550 --> 00:09:12,700
and IP address of this particular

00:09:09,620 --> 00:09:18,590
application in this case we are using

00:09:12,700 --> 00:09:23,570
net path this is just a special badge on

00:09:18,590 --> 00:09:29,180
the network which is just yell finally

00:09:23,570 --> 00:09:32,000
and if you execute this command is this

00:09:29,180 --> 00:09:35,390
agency this is just connecting to the

00:09:32,000 --> 00:09:40,700
net saba running inside this localhost

00:09:35,390 --> 00:09:44,420
and it's this particular application is

00:09:40,700 --> 00:09:47,590
using different kernel module which is

00:09:44,420 --> 00:09:53,710
embedded in the embedded into this

00:09:47,590 --> 00:09:57,710
network application and another demo is

00:09:53,710 --> 00:10:00,140
is kind of the unique color when using

00:09:57,710 --> 00:10:02,030
the realcare framework which means the

00:10:00,140 --> 00:10:05,360
net path application embedded it's

00:10:02,030 --> 00:10:10,850
embedded the air Cal in a scallion

00:10:05,360 --> 00:10:15,710
library and this finally is landing on

00:10:10,850 --> 00:10:20,540
top of the QM Gabriel hypervisor so you

00:10:15,710 --> 00:10:23,480
can create your own you know all

00:10:20,540 --> 00:10:26,390
operating system for the guest operating

00:10:23,480 --> 00:10:34,670
system but you can only use the single

00:10:26,390 --> 00:10:40,720
application in this case there's a turbo

00:10:34,670 --> 00:10:40,720
botanist I think ice I can delegate

00:10:43,749 --> 00:10:52,399
okay so going back to the original

00:10:47,389 --> 00:10:54,679
motivation of my current work so I want

00:10:52,399 --> 00:10:58,929
to have a little Cessna toxic but I

00:10:54,679 --> 00:11:04,869
don't want to have a new network snack

00:10:58,929 --> 00:11:07,220
but by doing such a approaches with the

00:11:04,869 --> 00:11:09,470
Hardware independent architecture there

00:11:07,220 --> 00:11:12,859
was a concern and there was a discussion

00:11:09,470 --> 00:11:14,659
about the timing accuracy issues of the

00:11:12,859 --> 00:11:17,359
user space network and user space code

00:11:14,659 --> 00:11:21,309
execution this was discussed this was

00:11:17,359 --> 00:11:23,929
discussed in a reflective conference and

00:11:21,309 --> 00:11:28,789
one of the example of this kind of

00:11:23,929 --> 00:11:30,649
situation of the issue is the if the

00:11:28,789 --> 00:11:33,169
protocol implementation of the kernel

00:11:30,649 --> 00:11:36,559
code is used in a highly highly version

00:11:33,169 --> 00:11:40,759
timer which requires a very accuracy of

00:11:36,559 --> 00:11:44,449
the timing behavior it will be make some

00:11:40,759 --> 00:11:47,470
trouble and the for example bbl polish

00:11:44,449 --> 00:11:52,100
to control our goal is algorithm using

00:11:47,470 --> 00:11:54,949
uses the packet scheduling feature which

00:11:52,100 --> 00:11:58,399
is based on excuse pockets Kuna and the

00:11:54,949 --> 00:12:02,929
scheduler requires a itself time highly

00:11:58,399 --> 00:12:04,669
highly duration timers which may have

00:12:02,929 --> 00:12:09,399
some trouble with the user specific

00:12:04,669 --> 00:12:14,269
exclusion value just examination so I

00:12:09,399 --> 00:12:17,179
want to have Phi iota try to investigate

00:12:14,269 --> 00:12:22,279
this issues by using air care and they

00:12:17,179 --> 00:12:24,139
see a the report of my experience so as

00:12:22,279 --> 00:12:28,220
the previous speaker already explained

00:12:24,139 --> 00:12:30,109
about what is VBR and we I'm going to

00:12:28,220 --> 00:12:35,959
step out model most of the part of the

00:12:30,109 --> 00:12:39,470
business explanation so basically they

00:12:35,959 --> 00:12:42,470
are great I mean they outperformed the

00:12:39,470 --> 00:12:47,470
other condition controller will argue in

00:12:42,470 --> 00:12:51,230
the read environment and most of the

00:12:47,470 --> 00:12:54,350
most of the understanding are impressed

00:12:51,230 --> 00:12:56,840
result is the in some situation in some

00:12:54,350 --> 00:13:01,840
conditions there achieved good clip is

00:12:56,840 --> 00:13:04,540
more than 25 times hundred and cubic

00:13:01,840 --> 00:13:08,930
other conditions on tourism

00:13:04,540 --> 00:13:12,190
so the first toy will be using this

00:13:08,930 --> 00:13:18,470
barrier on top of the Cessna toxa is

00:13:12,190 --> 00:13:20,120
just trying to achieve the just trying

00:13:18,470 --> 00:13:22,970
to deduce the desert

00:13:20,120 --> 00:13:27,790
that the original vdr paper its

00:13:22,970 --> 00:13:30,920
described and this topology is the first

00:13:27,790 --> 00:13:33,440
experiment explaining topology which

00:13:30,920 --> 00:13:36,650
only consists of the two simple nodes

00:13:33,440 --> 00:13:40,990
connecting connecting the back-to-back

00:13:36,650 --> 00:13:46,040
link with the techniques VPS connect and

00:13:40,990 --> 00:13:48,050
we try to so for the lifestyle Lord we

00:13:46,040 --> 00:13:51,500
use the standard Linux kernel and the

00:13:48,050 --> 00:13:54,590
mid server in order to receive the TCP

00:13:51,500 --> 00:13:56,990
flows and the left side so hard to

00:13:54,590 --> 00:13:59,750
define configuration one of them is

00:13:56,990 --> 00:14:03,710
using this standard Linux kernel and

00:13:59,750 --> 00:14:05,450
standard net paths with the disk with

00:14:03,710 --> 00:14:09,350
the two different condition control

00:14:05,450 --> 00:14:14,780
widow and another configuration is using

00:14:09,350 --> 00:14:20,270
sjl and try to use try to utilize the

00:14:14,780 --> 00:14:23,690
bandwidth between the tooth loss and the

00:14:20,270 --> 00:14:27,260
in this benchmark or in this extremists

00:14:23,690 --> 00:14:30,380
death law packet loss or bottleneck

00:14:27,260 --> 00:14:33,260
configuration this destructive a pink

00:14:30,380 --> 00:14:39,740
and round-trip time between these two

00:14:33,260 --> 00:14:44,720
node is very and very short so change

00:14:39,740 --> 00:14:48,770
the results of the fast failure so be

00:14:44,720 --> 00:14:52,220
with the standard linux config standard

00:14:48,770 --> 00:14:54,920
next net path it should almost fully

00:14:52,220 --> 00:14:57,590
utilizing the boundary is available

00:14:54,920 --> 00:14:59,210
within two links even though you are

00:14:57,590 --> 00:15:02,400
using the different conducive on to our

00:14:59,210 --> 00:15:06,089
wounds and there is cubic

00:15:02,400 --> 00:15:11,880
and there carry Justice Network stack it

00:15:06,089 --> 00:15:14,700
should almost similar but with vdr we

00:15:11,880 --> 00:15:18,200
didn't get it I mean the the first thing

00:15:14,700 --> 00:15:21,870
that I have to investigate is why this

00:15:18,200 --> 00:15:24,110
lower bandwidth achieved by the use of

00:15:21,870 --> 00:15:27,330
this net exactly

00:15:24,110 --> 00:15:31,920
so only VBR with the space network

00:15:27,330 --> 00:15:34,670
structures about performance and one

00:15:31,920 --> 00:15:40,800
thing that I'm investigating during the

00:15:34,670 --> 00:15:45,000
this landmark is the constant using the

00:15:40,800 --> 00:15:49,680
every aqaq packet received is using the

00:15:45,000 --> 00:15:53,339
very last roughly assigned the timing

00:15:49,680 --> 00:15:59,040
time value which is provided by HK and L

00:15:53,339 --> 00:16:01,500
care system code and the issue which we

00:15:59,040 --> 00:16:04,410
can provide more higher less ratio of

00:16:01,500 --> 00:16:06,420
the time stamp should be improve the

00:16:04,410 --> 00:16:10,140
video almost even though you are using

00:16:06,420 --> 00:16:13,770
you dose definite doctor so the fast

00:16:10,140 --> 00:16:20,430
fire forming is trying to change the

00:16:13,770 --> 00:16:26,100
tick tick interval value so before other

00:16:20,430 --> 00:16:30,980
default configuration again uses the 103

00:16:26,100 --> 00:16:34,830
tick tick tick counters

00:16:30,980 --> 00:16:37,080
while the standard unix I mean in disk

00:16:34,830 --> 00:16:41,070
and this experimentally we use the

00:16:37,080 --> 00:16:45,570
federal version which is the 1000 health

00:16:41,070 --> 00:16:49,400
for the tick's interval and if you if we

00:16:45,570 --> 00:16:55,050
increase this ticking double value to

00:16:49,400 --> 00:16:57,480
one server on top on top of the space it

00:16:55,050 --> 00:17:07,110
shows the increased

00:16:57,480 --> 00:17:11,880
good foot as I as I assumed but it sees

00:17:07,110 --> 00:17:12,900
so the reality is actively roll up a

00:17:11,880 --> 00:17:17,240
Hamas

00:17:12,900 --> 00:17:20,880
with this tip interval confusion changes

00:17:17,240 --> 00:17:24,030
so what is happening when you want to

00:17:20,880 --> 00:17:28,800
stand start on the every packet received

00:17:24,030 --> 00:17:32,610
so the basic behavior of the previous

00:17:28,800 --> 00:17:38,400
part of their care is using the fees for

00:17:32,610 --> 00:17:41,250
the every packet pencil so it means it's

00:17:38,400 --> 00:17:45,590
only it can only have a revolution the

00:17:41,250 --> 00:17:48,179
tip interval it's method the minimum and

00:17:45,590 --> 00:17:52,200
alkie key measurement are DT measurement

00:17:48,179 --> 00:17:59,190
values should be kept to the disk if

00:17:52,200 --> 00:18:03,390
it's resolution but if some a specific

00:17:59,190 --> 00:18:06,900
architecture of the Linux kernel for 3d

00:18:03,390 --> 00:18:09,140
file the override function which is

00:18:06,900 --> 00:18:14,540
showing this sketch clock function

00:18:09,140 --> 00:18:18,929
inside this objectia you can provide any

00:18:14,540 --> 00:18:21,350
reservation for the clock value of clock

00:18:18,929 --> 00:18:25,380
variable instead of using these values

00:18:21,350 --> 00:18:28,650
so with this scatter crocks internally

00:18:25,380 --> 00:18:33,000
air carrier uses the clock time voice

00:18:28,650 --> 00:18:38,520
call in order to provide this nanosecond

00:18:33,000 --> 00:18:42,570
resolution value it includes the result

00:18:38,520 --> 00:18:47,520
with this situation this is the first

00:18:42,570 --> 00:18:51,210
winner of this improvement but what

00:18:47,520 --> 00:18:56,090
happens if this some CPU architecture

00:18:51,210 --> 00:19:01,550
doesn't provide this hydration panel by

00:18:56,090 --> 00:19:05,160
not using this schedule function so it's

00:19:01,550 --> 00:19:08,130
as I showed in the previous explain X

00:19:05,160 --> 00:19:12,179
example it shows the good but for Hamas

00:19:08,130 --> 00:19:14,730
is the time an RTT measurement and I

00:19:12,179 --> 00:19:18,929
reported this issues is the BBL

00:19:14,730 --> 00:19:21,630
development mailing list and lucky we

00:19:18,929 --> 00:19:24,480
have their taxes from the name from

00:19:21,630 --> 00:19:25,900
dinner to total 8 this lower performance

00:19:24,480 --> 00:19:28,059
even though we are

00:19:25,900 --> 00:19:32,800
we cannot use the hydration time samples

00:19:28,059 --> 00:19:37,270
I didn't go into the detail about this

00:19:32,800 --> 00:19:41,070
parties but you you can look at our

00:19:37,270 --> 00:19:44,740
discussion about this improvement by

00:19:41,070 --> 00:19:51,850
clink looking at this meaningless

00:19:44,740 --> 00:19:54,040
archive so that's the fast for us all

00:19:51,850 --> 00:19:56,850
with this patch and the result the

00:19:54,040 --> 00:20:00,670
higher high resolution time stamp

00:19:56,850 --> 00:20:03,910
without hydrogen sometimes and you can

00:20:00,670 --> 00:20:12,190
achieve almost similar good boots as the

00:20:03,910 --> 00:20:15,490
standard Linux has like this okay so the

00:20:12,190 --> 00:20:23,280
next step will be to reproduce an

00:20:15,490 --> 00:20:26,380
association of the DD of dbl works well

00:20:23,280 --> 00:20:30,660
by putting the middle box between the

00:20:26,380 --> 00:20:33,429
two nodes and introducing some pocket

00:20:30,660 --> 00:20:36,490
modification in the middle so in this

00:20:33,429 --> 00:20:41,350
case we introduced the pocket one custom

00:20:36,490 --> 00:20:44,710
event pocket rose and musical delay in

00:20:41,350 --> 00:20:52,240
the middle and then we measure so we

00:20:44,710 --> 00:20:55,090
measured this this good put on top all

00:20:52,240 --> 00:20:59,890
by using the same software as I showed

00:20:55,090 --> 00:21:02,110
before and there as you can see the

00:20:59,890 --> 00:21:03,880
sandal reacts or still shows the good

00:21:02,110 --> 00:21:09,210
perform of even though in this patient

00:21:03,880 --> 00:21:11,710
and the cubic shows the threaded less

00:21:09,210 --> 00:21:15,580
responder is because of the there is a

00:21:11,710 --> 00:21:20,800
pocket Rose between a lot but this will

00:21:15,580 --> 00:21:24,390
still okay there is not performance so

00:21:20,800 --> 00:21:26,679
why is that so

00:21:24,390 --> 00:21:28,870
after investigating a lot of the

00:21:26,679 --> 00:21:31,690
information we say what what's happening

00:21:28,870 --> 00:21:35,560
inside air here we found a pocket

00:21:31,690 --> 00:21:37,470
besides already full I mean we didn't

00:21:35,560 --> 00:21:40,049
have any configuration to

00:21:37,470 --> 00:21:43,020
to change and forget about fossils with

00:21:40,049 --> 00:21:45,059
air gaps because we always we are

00:21:43,020 --> 00:21:48,390
eternally done a single process we

00:21:45,059 --> 00:21:53,070
cannot have multiple processes outside

00:21:48,390 --> 00:21:55,440
from the main processes for we we

00:21:53,070 --> 00:22:01,100
provided the composition interface to

00:21:55,440 --> 00:22:06,679
change the confuse sysctl buyable and

00:22:01,100 --> 00:22:09,330
also we use the static static

00:22:06,679 --> 00:22:12,200
virtual memory side for the other

00:22:09,330 --> 00:22:16,110
instances because we didn't have any

00:22:12,200 --> 00:22:19,590
direct interface for the hardware so the

00:22:16,110 --> 00:22:23,220
default memory size of the scale was 64

00:22:19,590 --> 00:22:26,539
megabytes which which limits the

00:22:23,220 --> 00:22:29,419
expansion of the send buffer size by

00:22:26,539 --> 00:22:35,220
calling different ethnicity should

00:22:29,419 --> 00:22:38,130
expand tenable function and the other

00:22:35,220 --> 00:22:40,650
configuration we added is to just enable

00:22:38,130 --> 00:22:44,760
the highest resolution timers on the

00:22:40,650 --> 00:22:47,549
kernel configuration as there are the F

00:22:44,760 --> 00:22:50,429
key packet scheduler instead of a

00:22:47,549 --> 00:22:53,400
instead of invoking TC command because

00:22:50,429 --> 00:22:55,909
we cannot we also cannot use the DC

00:22:53,400 --> 00:22:55,909
command

00:22:57,320 --> 00:23:05,970
so here somehow some from the sort of

00:23:01,740 --> 00:23:11,659
the observation of the delivery delay of

00:23:05,970 --> 00:23:11,659
the timer events each time I event and

00:23:13,130 --> 00:23:18,539
greenberg Green Line shows the Linux

00:23:15,510 --> 00:23:21,150
standard Linux and every day while the

00:23:18,539 --> 00:23:25,530
popular lines of the L carried in case

00:23:21,150 --> 00:23:27,900
one Sun and it means the how to

00:23:25,530 --> 00:23:31,710
interpret interpret this graph is the

00:23:27,900 --> 00:23:36,539
left side is dinner reflects the more

00:23:31,710 --> 00:23:39,840
shorter delivery delay has on the packet

00:23:36,539 --> 00:23:42,720
scheduling function and as you can see

00:23:39,840 --> 00:23:45,899
with the Linux sundar Linux kernel the

00:23:42,720 --> 00:23:49,280
daily delivery delay of the high

00:23:45,899 --> 00:23:53,180
resolution timer is about 100 now now

00:23:49,280 --> 00:23:59,260
becomes why the weekend is almost about

00:23:53,180 --> 00:24:02,750
to 20 or 30 microsecond called every day

00:23:59,260 --> 00:24:05,450
so I want to group this suggestion

00:24:02,750 --> 00:24:10,820
because the area uses their own schedule

00:24:05,450 --> 00:24:13,370
- schedule the code and one file and the

00:24:10,820 --> 00:24:20,000
data fact to reduce the scheduling delay

00:24:13,370 --> 00:24:23,060
is trying to release the the cost of the

00:24:20,000 --> 00:24:26,780
system call in the in the scheduler code

00:24:23,060 --> 00:24:30,470
of the lkl we used a system code in

00:24:26,780 --> 00:24:34,910
order to block some program schedule but

00:24:30,470 --> 00:24:38,480
if the block duration is short we are

00:24:34,910 --> 00:24:40,910
trying to avoid the system call and by

00:24:38,480 --> 00:24:44,630
instead of that we provided the answer

00:24:40,910 --> 00:24:48,170
we provided the first pass to disable

00:24:44,630 --> 00:24:54,280
the clock variable in order to block the

00:24:48,170 --> 00:24:59,030
code so by doing a changing risk or

00:24:54,280 --> 00:25:02,630
scheduling behavior the the top line is

00:24:59,030 --> 00:25:05,330
moving to the left side but which is

00:25:02,630 --> 00:25:10,130
good for the packet scheduling but we

00:25:05,330 --> 00:25:12,170
saw it also introduced some tame Delta C

00:25:10,130 --> 00:25:16,600
which I'm still in the schedule on this

00:25:12,170 --> 00:25:21,110
behavior so this is the final result

00:25:16,600 --> 00:25:25,550
so with the socket by the large socket

00:25:21,110 --> 00:25:27,590
buffer yellow standard a yellow bar

00:25:25,550 --> 00:25:29,360
which means the standard Linux kernel

00:25:27,590 --> 00:25:33,200
with the BBL so they almost

00:25:29,360 --> 00:25:38,170
adrià bit Pascal for good fit while the

00:25:33,200 --> 00:25:42,440
purple bar shows it's almost fall gig

00:25:38,170 --> 00:25:44,630
DBS with this situation which was

00:25:42,440 --> 00:25:47,600
improved somehow from the original

00:25:44,630 --> 00:25:52,130
performers like they only have a 100

00:25:47,600 --> 00:25:56,930
megabit DNA before modifying before

00:25:52,130 --> 00:26:00,380
adding in such a feature so yeah the

00:25:56,930 --> 00:26:02,090
somebody would what we have done for to

00:26:00,380 --> 00:26:04,550
improve the station of the user space

00:26:02,090 --> 00:26:07,610
net extract and it also includes the

00:26:04,550 --> 00:26:10,250
previous effort of the JD chief from

00:26:07,610 --> 00:26:14,120
Google which is the sum of floating

00:26:10,250 --> 00:26:18,970
function and the next possible step for

00:26:14,120 --> 00:26:21,620
a care should be more profiling and more

00:26:18,970 --> 00:26:24,170
finding some bottlenecks in the user

00:26:21,620 --> 00:26:28,190
space execution and it also tell the

00:26:24,170 --> 00:26:32,200
various sub cuts for the packet or clock

00:26:28,190 --> 00:26:38,510
accessing like a busy pouring I all as

00:26:32,200 --> 00:26:41,060
some of the PDK library this dance and

00:26:38,510 --> 00:26:43,880
we can also try to investigate how the

00:26:41,060 --> 00:26:45,530
link kernel configuration works well in

00:26:43,880 --> 00:26:47,630
thermo comes from the packet delay

00:26:45,530 --> 00:26:51,640
validation because there is no schedule

00:26:47,630 --> 00:26:51,640
I said that Lee does this execution half

00:26:51,730 --> 00:26:59,090
so that's almost 6 I'm running atomic by

00:26:55,040 --> 00:27:12,620
running out of time so that is thank you

00:26:59,090 --> 00:27:14,150
so much one question only I really

00:27:12,620 --> 00:27:15,770
appreciate this kind of investigation

00:27:14,150 --> 00:27:17,750
because always always theoretically

00:27:15,770 --> 00:27:19,840
thinking that accuracy accurate timers

00:27:17,750 --> 00:27:24,230
in user space would be a issue for

00:27:19,840 --> 00:27:27,020
algorithms such as VBR so then the next

00:27:24,230 --> 00:27:29,540
the next level of this problem is if lkl

00:27:27,020 --> 00:27:31,610
is executing on a machine that's loaded

00:27:29,540 --> 00:27:34,220
that has a high load and has other

00:27:31,610 --> 00:27:36,200
things running on it consuming CPU time

00:27:34,220 --> 00:27:39,530
lkl is getting preempted quite

00:27:36,200 --> 00:27:41,090
frequently and if it's getting preempted

00:27:39,530 --> 00:27:43,340
quite frequently you could get preempted

00:27:41,090 --> 00:27:45,290
between the calculation of the time

00:27:43,340 --> 00:27:47,660
stamp and the actual application of that

00:27:45,290 --> 00:27:48,890
time stamp value and measurements and

00:27:47,660 --> 00:27:50,810
things of this nature so you get right

00:27:48,890 --> 00:27:52,490
back to the timing accuracy problem

00:27:50,810 --> 00:27:54,740
again so that's something to consider

00:27:52,490 --> 00:27:58,630
yeah I'm also just in front institution

00:27:54,740 --> 00:27:58,630

YouTube URL: https://www.youtube.com/watch?v=ygsbhRrDwq0


