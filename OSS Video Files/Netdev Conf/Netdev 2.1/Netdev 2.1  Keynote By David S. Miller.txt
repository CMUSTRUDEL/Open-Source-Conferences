Title: Netdev 2.1  Keynote By David S. Miller
Publication date: 2017-04-26
Playlist: Netdev 2.1
Description: 
	Keynote By Netdev Maintainer David S. Miller given at Netdev conf 2.1 in Montreal on Apr. 7th 2017.
https://www.netdevconf.org/2.1/session.html?miller
Captions: 
	00:00:00,860 --> 00:00:07,950
so I've known Dave for longer than I

00:00:04,350 --> 00:00:11,070
might care to admit and I met him at a

00:00:07,950 --> 00:00:13,170
conference and I went up and introduced

00:00:11,070 --> 00:00:15,719
myself and this is because at the time I

00:00:13,170 --> 00:00:17,670
was using a spark 30 to system which

00:00:15,719 --> 00:00:21,300
maybe gives some context of the age of

00:00:17,670 --> 00:00:23,400
this story and the systems when they

00:00:21,300 --> 00:00:26,400
were the panic did you get this ASCII

00:00:23,400 --> 00:00:29,310
art of this poking his tongue out a

00:00:26,400 --> 00:00:31,800
little bit like that and so even before

00:00:29,310 --> 00:00:33,930
I met Dave I knew he had quite a good

00:00:31,800 --> 00:00:36,870
sense of humor

00:00:33,930 --> 00:00:38,640
and over the years I've learnt a few

00:00:36,870 --> 00:00:40,770
other things about Dave

00:00:38,640 --> 00:00:44,640
he really likes sushi he really likes

00:00:40,770 --> 00:00:46,950
coffee but maybe more relevantly he's

00:00:44,640 --> 00:00:49,739
very passionate about about what he does

00:00:46,950 --> 00:00:52,110
and his position in our community as a

00:00:49,739 --> 00:00:55,320
maintainer of the Linux networking stack

00:00:52,110 --> 00:00:57,090
and so I won't take up any more time

00:00:55,320 --> 00:00:58,980
I've learned a lot from Dave over the

00:00:57,090 --> 00:01:01,559
years and I look forward to learning

00:00:58,980 --> 00:01:03,989
something new from him in the next 30

00:01:01,559 --> 00:01:06,479
minutes or so thank you thanks a lot

00:01:03,989 --> 00:01:08,689
Simon really appreciate it

00:01:06,479 --> 00:01:12,240
so today we're going to be talking about

00:01:08,689 --> 00:01:14,700
xbp and I just want to let everyone know

00:01:12,240 --> 00:01:21,270
in this room that this would be my last

00:01:14,700 --> 00:01:24,869
talk about XTP ever actually today and I

00:01:21,270 --> 00:01:26,340
want to assure everyone that we will be

00:01:24,869 --> 00:01:28,650
able to successfully complete this

00:01:26,340 --> 00:01:32,060
presentation because I brought with me

00:01:28,650 --> 00:01:35,009
the power of the reverse Christmas tree

00:01:32,060 --> 00:01:36,270
so just be a confident knowing that he's

00:01:35,009 --> 00:01:38,850
going to help us get through this just

00:01:36,270 --> 00:01:40,979
fine so what are we going to talk about

00:01:38,850 --> 00:01:42,689
well I'll give an overview of xdp an EPA

00:01:40,979 --> 00:01:44,670
EPF which you've probably seen that a

00:01:42,689 --> 00:01:45,810
dozen times so far in this but this

00:01:44,670 --> 00:01:47,189
conference but I'm going to make sure I

00:01:45,810 --> 00:01:48,479
give you a little bit more context and

00:01:47,189 --> 00:01:50,369
more reasoning about why these

00:01:48,479 --> 00:01:53,549
architectural elements are important and

00:01:50,369 --> 00:01:55,079
well thought out which I think needs to

00:01:53,549 --> 00:01:58,649
be reinforced when we talk about these

00:01:55,079 --> 00:02:01,170
things why is it a good long-term

00:01:58,649 --> 00:02:02,219
solution to certain problems faces I

00:02:01,170 --> 00:02:04,049
think that's a question a lot of people

00:02:02,219 --> 00:02:06,030
have when they say well this new xdp

00:02:04,049 --> 00:02:08,879
thing what why why should we use it

00:02:06,030 --> 00:02:10,649
what's it good for and most importantly

00:02:08,879 --> 00:02:12,239
I'm going to talk about free if we

00:02:10,649 --> 00:02:13,190
couldn't miss that I hear about xcp

00:02:12,239 --> 00:02:15,080
there's some

00:02:13,190 --> 00:02:16,370
lot of fake news out there we're going

00:02:15,080 --> 00:02:19,880
to use the reverse Christmas tree to

00:02:16,370 --> 00:02:21,650
help us get through that and then we're

00:02:19,880 --> 00:02:24,140
going to talk about things that are true

00:02:21,650 --> 00:02:26,870
now but will not be true for long as

00:02:24,140 --> 00:02:28,670
long as the momentum continues in the

00:02:26,870 --> 00:02:30,590
XDP space which I'm completely confident

00:02:28,670 --> 00:02:32,300
about and I'm going to finish the talk

00:02:30,590 --> 00:02:33,620
to talk about little an observation I

00:02:32,300 --> 00:02:35,930
made that caused me to have an epiphany

00:02:33,620 --> 00:02:37,160
about XDP development and something

00:02:35,930 --> 00:02:38,630
people might want to keep in line when

00:02:37,160 --> 00:02:40,820
they think about the environment that

00:02:38,630 --> 00:02:42,140
all this is happening in and what it may

00:02:40,820 --> 00:02:45,200
come to in the end which i think is

00:02:42,140 --> 00:02:48,380
actually very exciting so what does EVP

00:02:45,200 --> 00:02:52,490
f so Jacobson and McCain back in 1992

00:02:48,380 --> 00:02:52,880
which is what 15 years ago or even

00:02:52,490 --> 00:02:57,950
longer

00:02:52,880 --> 00:03:00,350
I mean 2020 long time ago realized that

00:02:57,950 --> 00:03:02,930
we needed some level programmability

00:03:00,350 --> 00:03:04,400
inside the operating system I think this

00:03:02,930 --> 00:03:05,900
is a really powerful concept and I think

00:03:04,400 --> 00:03:06,710
these guys had no idea what they what

00:03:05,900 --> 00:03:08,410
kind of mess they were getting

00:03:06,710 --> 00:03:10,400
themselves into

00:03:08,410 --> 00:03:11,930
but they just needed it for simple

00:03:10,400 --> 00:03:14,870
packet filtering so they built they

00:03:11,930 --> 00:03:18,860
built a facility that solved that

00:03:14,870 --> 00:03:20,270
problem but if you want to do something

00:03:18,860 --> 00:03:22,700
more sophisticated you need something

00:03:20,270 --> 00:03:24,980
closer to a full-blown CPU or something

00:03:22,700 --> 00:03:28,040
it looks like a real CPU so that's why

00:03:24,980 --> 00:03:30,980
we came up with EBP F Alexei worked on

00:03:28,040 --> 00:03:34,970
that and what it provides is a full

00:03:30,980 --> 00:03:37,310
register set 12 about 12 registers full

00:03:34,970 --> 00:03:40,910
instruction set even atomic operations

00:03:37,310 --> 00:03:43,640
and a set of helpers and more

00:03:40,910 --> 00:03:45,800
importantly the fundamental concepts of

00:03:43,640 --> 00:03:48,110
data structures called Maps why is it

00:03:45,800 --> 00:03:50,510
important to have an abstraction of the

00:03:48,110 --> 00:03:52,610
data structures in the design of EBP F

00:03:50,510 --> 00:03:54,709
the reason is we want to retain one

00:03:52,610 --> 00:03:56,870
element of the basic BPF design that

00:03:54,709 --> 00:03:58,700
goes all the way back to 1992 which is

00:03:56,870 --> 00:04:00,950
that the EPI programs cannot branch

00:03:58,700 --> 00:04:03,140
backwards it's impossible to generate

00:04:00,950 --> 00:04:05,720
loops inside VP of programs therefore

00:04:03,140 --> 00:04:07,610
the execution time of all BPF programs

00:04:05,720 --> 00:04:09,590
are well bounded and can be well defined

00:04:07,610 --> 00:04:11,630
and they can't get out of this box of

00:04:09,590 --> 00:04:13,850
execution so it's an important element

00:04:11,630 --> 00:04:18,080
to understand the design of BPF and why

00:04:13,850 --> 00:04:19,790
things were done that way well okay we

00:04:18,080 --> 00:04:21,859
have the EPF what can we use it for well

00:04:19,790 --> 00:04:23,630
one of the many applications of BPF is

00:04:21,859 --> 00:04:25,700
XDP and that's an important thing to

00:04:23,630 --> 00:04:26,030
understand as well BPF isn't limited to

00:04:25,700 --> 00:04:28,490
net

00:04:26,030 --> 00:04:30,620
working BPF is used for trace points at

00:04:28,490 --> 00:04:32,690
aw and for selecting control groups of

00:04:30,620 --> 00:04:34,010
sockets and things of this nature it's

00:04:32,690 --> 00:04:36,470
not just limited to networking

00:04:34,010 --> 00:04:39,770
applications or specifically packet

00:04:36,470 --> 00:04:44,000
filtering so what happens with XT P V as

00:04:39,770 --> 00:04:47,300
yes per and and each owed the X to P is

00:04:44,000 --> 00:04:49,340
an e BPF programming program executing

00:04:47,300 --> 00:04:50,840
exactly when the device driver receives

00:04:49,340 --> 00:04:52,160
the packet it is the earliest point in

00:04:50,840 --> 00:04:54,050
time in which we can do anything with

00:04:52,160 --> 00:04:57,050
networking data that we receive on the

00:04:54,050 --> 00:04:58,790
system it is by definition the fastest

00:04:57,050 --> 00:05:00,110
way we can process networking packets it

00:04:58,790 --> 00:05:03,260
is the earliest point in time in which

00:05:00,110 --> 00:05:06,440
we can do so so what are the programs do

00:05:03,260 --> 00:05:09,620
they they make a determination and they

00:05:06,440 --> 00:05:11,270
return a result code and a result code

00:05:09,620 --> 00:05:13,580
determines what happens with the packet

00:05:11,270 --> 00:05:15,320
you can drop the packet you can transmit

00:05:13,580 --> 00:05:16,580
it out the same interface you could pass

00:05:15,320 --> 00:05:18,410
it up into the rest of the networking

00:05:16,580 --> 00:05:20,440
stack and more codes would be coming in

00:05:18,410 --> 00:05:22,400
the future

00:05:20,440 --> 00:05:24,470
another thing you understands the XP

00:05:22,400 --> 00:05:28,130
programs can modify packet contents the

00:05:24,470 --> 00:05:29,540
example Andy and Jasper gave is that you

00:05:28,130 --> 00:05:31,070
could switch the MAC addresses and one

00:05:29,540 --> 00:05:32,419
of the example programs in the tree but

00:05:31,070 --> 00:05:34,820
you can do more sophisticated things

00:05:32,419 --> 00:05:36,530
like build tunnel headers do not

00:05:34,820 --> 00:05:40,310
whatever you like whatever your

00:05:36,530 --> 00:05:41,300
application actually needs in xcp and so

00:05:40,310 --> 00:05:42,830
you can push and pull headers to

00:05:41,300 --> 00:05:44,900
implement tunneling as well and that's

00:05:42,830 --> 00:05:47,800
important for various things including

00:05:44,900 --> 00:05:47,800
load balancing

00:05:48,430 --> 00:05:53,360
what is it fundamentally to make xcp so

00:05:51,200 --> 00:05:55,130
fast well I kind of got into this in the

00:05:53,360 --> 00:05:57,620
previous slide it's the earliest point

00:05:55,130 --> 00:05:59,240
in time in the execution path in which

00:05:57,620 --> 00:06:01,760
we can actually look at the packet at

00:05:59,240 --> 00:06:03,979
all so by definition that's a part of

00:06:01,760 --> 00:06:06,500
the what makes it so fast the more

00:06:03,979 --> 00:06:09,110
another aspect is that memory allocation

00:06:06,500 --> 00:06:10,640
is a large part of the transactional

00:06:09,110 --> 00:06:13,400
overhead for processing a packet and

00:06:10,640 --> 00:06:15,200
networking stack and every packet that

00:06:13,400 --> 00:06:17,300
we build for the full networking stack

00:06:15,200 --> 00:06:19,130
has to have an sk buff piece of metadata

00:06:17,300 --> 00:06:22,100
attached to it and that thing is about

00:06:19,130 --> 00:06:24,680
256 bytes and it shows up in the profile

00:06:22,100 --> 00:06:27,200
as the allocation of this thing for high

00:06:24,680 --> 00:06:30,140
packet rate benchmarks and loads

00:06:27,200 --> 00:06:31,910
so one thing ICP does it eliminates the

00:06:30,140 --> 00:06:34,610
need for the metadata we just work with

00:06:31,910 --> 00:06:36,349
completely linear packets and we only

00:06:34,610 --> 00:06:37,940
give the XDP program a pointer to the

00:06:36,349 --> 00:06:40,250
beginning and the end

00:06:37,940 --> 00:06:42,350
the packet and that's it we don't

00:06:40,250 --> 00:06:45,290
allocate any memory we don't dedicate

00:06:42,350 --> 00:06:51,170
any allocation refute resources to

00:06:45,290 --> 00:06:53,240
processing the packet so another thing

00:06:51,170 --> 00:06:56,060
to think about xcp is it's it's kind of

00:06:53,240 --> 00:06:57,680
stateless yes xcp has maps and can

00:06:56,060 --> 00:07:00,110
interact with other parts of the kernel

00:06:57,680 --> 00:07:02,390
but as its base design it is completely

00:07:00,110 --> 00:07:04,100
stateless the reason we need an sk buff

00:07:02,390 --> 00:07:05,510
to pass packets into the rest of the

00:07:04,100 --> 00:07:07,840
networking set because there's lots of

00:07:05,510 --> 00:07:10,340
state there is sockets there's

00:07:07,840 --> 00:07:12,620
references to rouse this references to

00:07:10,340 --> 00:07:16,250
packet filtering data this references to

00:07:12,620 --> 00:07:17,480
the TC information it just it just it's

00:07:16,250 --> 00:07:19,220
almost endless every single feature

00:07:17,480 --> 00:07:20,450
seems to need a new part of the sk buff

00:07:19,220 --> 00:07:23,510
and it just makes it more and more

00:07:20,450 --> 00:07:25,610
overhead to process packets and in the

00:07:23,510 --> 00:07:27,590
kernel so xcp kind of gets us out of

00:07:25,610 --> 00:07:31,540
that realm and gets us into a stateless

00:07:27,590 --> 00:07:31,540
area which makes things go a lot faster

00:07:31,630 --> 00:07:38,270
what kind of problem spaces is xcp

00:07:34,630 --> 00:07:40,040
well-suited for so yes for and company

00:07:38,270 --> 00:07:41,600
showed us that DDoS protection is one

00:07:40,040 --> 00:07:44,960
application Facebook is doing it some

00:07:41,600 --> 00:07:47,600
production load balancing which XE PTX

00:07:44,960 --> 00:07:49,040
Facebook is doing this in production one

00:07:47,600 --> 00:07:51,230
thing that I like is you can generate

00:07:49,040 --> 00:07:52,460
custom statistics like let's say you

00:07:51,230 --> 00:07:53,990
know that you've got some kind of

00:07:52,460 --> 00:07:55,460
problem happening in your network you

00:07:53,990 --> 00:07:57,770
don't know exactly what the traffic

00:07:55,460 --> 00:07:59,660
looks like but you want to narrow down

00:07:57,770 --> 00:08:01,340
the scope of what's causing it so you

00:07:59,660 --> 00:08:03,080
generate a text EP program which matches

00:08:01,340 --> 00:08:05,120
the kind of traffic you think is doing

00:08:03,080 --> 00:08:06,800
it and generate more detailed

00:08:05,120 --> 00:08:08,060
fine-grained statistics on the events

00:08:06,800 --> 00:08:09,200
that are happening for packets flowing

00:08:08,060 --> 00:08:11,270
through your system and then you could

00:08:09,200 --> 00:08:12,950
interest you could look at them for

00:08:11,270 --> 00:08:15,070
music space and see and derive

00:08:12,950 --> 00:08:17,480
information that way

00:08:15,070 --> 00:08:19,910
you could do even more sophisticated

00:08:17,480 --> 00:08:22,010
things like have a filter inside your

00:08:19,910 --> 00:08:23,090
xdp program and then generate a perfect

00:08:22,010 --> 00:08:26,180
thats well-defined

00:08:23,090 --> 00:08:27,919
that captures part of that packet or the

00:08:26,180 --> 00:08:29,480
entire frame and then you could use perf

00:08:27,919 --> 00:08:33,620
to sample all the things all the packets

00:08:29,480 --> 00:08:36,140
that match your criteria the last ones

00:08:33,620 --> 00:08:37,580
like kind of like the I know somewhere

00:08:36,140 --> 00:08:38,750
behind the scenes someone's working on

00:08:37,580 --> 00:08:40,339
high-speed trading and thinking about

00:08:38,750 --> 00:08:41,240
using X DP for this but they're probably

00:08:40,339 --> 00:08:42,740
not going to come here and give a

00:08:41,240 --> 00:08:46,640
presentation about that that's going to

00:08:42,740 --> 00:08:49,730
be their secret sauce why is this

00:08:46,640 --> 00:08:50,780
approach awesome compared to alternative

00:08:49,730 --> 00:08:51,950
schemes for this kind of thing it's

00:08:50,780 --> 00:08:55,910
inside the kernel and it's

00:08:51,950 --> 00:08:58,070
integrated why is that important well in

00:08:55,910 --> 00:09:00,170
the long term it's going to be important

00:08:58,070 --> 00:09:01,460
for XDP to be able to coexist with the

00:09:00,170 --> 00:09:02,930
rest of the networking stack and in

00:09:01,460 --> 00:09:05,390
particular to get you'd be able to gain

00:09:02,930 --> 00:09:08,180
objects to access to objects and tables

00:09:05,390 --> 00:09:10,010
within the kernel it's not behind a wall

00:09:08,180 --> 00:09:11,330
to the point where it cannot interact

00:09:10,010 --> 00:09:15,500
with the rest of the kernel and I think

00:09:11,330 --> 00:09:17,510
that's important and how is it so BPF is

00:09:15,500 --> 00:09:19,750
interesting because it's in a tightly

00:09:17,510 --> 00:09:22,490
controlled execution framework that's

00:09:19,750 --> 00:09:25,130
can't just access arbitrary pieces of

00:09:22,490 --> 00:09:26,630
kernel memory it can only access objects

00:09:25,130 --> 00:09:28,310
and pieces of data using the

00:09:26,630 --> 00:09:32,330
well-defined helpers and maps that are

00:09:28,310 --> 00:09:34,430
that are provided to EBP F programs so

00:09:32,330 --> 00:09:36,050
the way that we're going to be allow FCP

00:09:34,430 --> 00:09:37,790
programs to interact with other elements

00:09:36,050 --> 00:09:39,050
of the network the networking stack and

00:09:37,790 --> 00:09:41,300
other objects in the kernel is with

00:09:39,050 --> 00:09:42,650
these helpers so that's something look

00:09:41,300 --> 00:09:45,980
forward to in the future and that's how

00:09:42,650 --> 00:09:48,350
we'll extend BPF over time so I went and

00:09:45,980 --> 00:09:49,460
I explained the know looping constraint

00:09:48,350 --> 00:09:50,720
which is important for people doing

00:09:49,460 --> 00:09:52,730
networking you want to know that your

00:09:50,720 --> 00:09:54,770
networking pipeline has a fixed cost and

00:09:52,730 --> 00:09:57,110
doesn't have very variableness into it

00:09:54,770 --> 00:09:58,400
and can't be exploited in that manner so

00:09:57,110 --> 00:09:59,810
strictly bound the execution time is

00:09:58,400 --> 00:10:03,890
important for networking the next DP

00:09:59,810 --> 00:10:06,230
gives us this ok here comes the fun part

00:10:03,890 --> 00:10:07,970
of the talk so this we're going to get a

00:10:06,230 --> 00:10:10,370
little bit of an audience participation

00:10:07,970 --> 00:10:12,830
here so what's going to happen it's

00:10:10,370 --> 00:10:13,970
going to I'm going to ask a question and

00:10:12,830 --> 00:10:15,620
you'll know I'm asking a question

00:10:13,970 --> 00:10:17,210
because it'll have a really huge font

00:10:15,620 --> 00:10:19,970
update you won't you'll know what's

00:10:17,210 --> 00:10:23,090
happening and the appropriate answer for

00:10:19,970 --> 00:10:24,710
every single question is no so I want

00:10:23,090 --> 00:10:27,050
everyone to say that when this happens

00:10:24,710 --> 00:10:28,400
so we're going to do a test run ok we

00:10:27,050 --> 00:10:29,630
use the reverse Christmas tree to help

00:10:28,400 --> 00:10:36,620
us get to say everything's going to be

00:10:29,630 --> 00:10:38,090
fine can X DP slice bread you guys are

00:10:36,620 --> 00:10:41,410
pros we're going to get through this

00:10:38,090 --> 00:10:44,860
just fine all right here we go is x DP

00:10:41,410 --> 00:10:44,860
just a fad

00:10:45,010 --> 00:10:50,150
so XDP as i've been trying to describe

00:10:48,170 --> 00:10:52,279
is a long-term architectural solution it

00:10:50,150 --> 00:10:53,660
is specifically designed what to weight

00:10:52,279 --> 00:10:56,029
the different needs of people trying to

00:10:53,660 --> 00:10:57,740
do high-speed networking operations its

00:10:56,029 --> 00:10:59,720
high-performance it's fully programmable

00:10:57,740 --> 00:11:03,760
it's fully integrated into the kernel

00:10:59,720 --> 00:11:07,970
and it's safe which leads me to is XDP

00:11:03,760 --> 00:11:10,730
unsafe that's right

00:11:07,970 --> 00:11:14,300
xcp I will argue is no less safe than

00:11:10,730 --> 00:11:16,970
user space itself how can I say that the

00:11:14,300 --> 00:11:20,480
EVPs verify verifier protects us from

00:11:16,970 --> 00:11:21,740
rogue EPF programs right and the various

00:11:20,480 --> 00:11:24,560
mechanisms in the kernel for

00:11:21,740 --> 00:11:26,960
implementing process processes memory

00:11:24,560 --> 00:11:28,730
management etc protect us from rogue use

00:11:26,960 --> 00:11:31,220
and Lantern programs there is no

00:11:28,730 --> 00:11:33,980
fundamental difference between these two

00:11:31,220 --> 00:11:36,170
levels of safety in my opinion so if you

00:11:33,980 --> 00:11:37,339
argue that user land is safer just

00:11:36,170 --> 00:11:39,770
realize that this is an emotional

00:11:37,339 --> 00:11:42,020
opinion of yours and it has no basis in

00:11:39,770 --> 00:11:45,110
reality so if you feel more comfortable

00:11:42,020 --> 00:11:46,700
in user space that's fine if you want to

00:11:45,110 --> 00:11:48,650
prove that user space is more safe

00:11:46,700 --> 00:11:50,750
that's another matter all-together I

00:11:48,650 --> 00:11:57,970
argue that xdt is just as safe as user

00:11:50,750 --> 00:11:57,970
space is xep less flexible than d PT k

00:11:58,480 --> 00:12:06,200
DP DK lives behind the wall of user

00:12:03,260 --> 00:12:07,940
space is fundamental weakness is its

00:12:06,200 --> 00:12:09,980
lack of integration into the kernel the

00:12:07,940 --> 00:12:11,660
fact that it can't live with the rest of

00:12:09,980 --> 00:12:13,160
the facilities and subsystems that are

00:12:11,660 --> 00:12:15,920
inside the kernel in any way shape or

00:12:13,160 --> 00:12:17,420
form if they want to do things to go

00:12:15,920 --> 00:12:19,279
into the back into the networking

00:12:17,420 --> 00:12:21,020
subsystem they have to re-inject packets

00:12:19,279 --> 00:12:22,640
into the kernel and that means they're

00:12:21,020 --> 00:12:24,770
going have to copy it back over the user

00:12:22,640 --> 00:12:26,720
kernel boundary which blows away all the

00:12:24,770 --> 00:12:28,279
performance benefits that are supposedly

00:12:26,720 --> 00:12:30,680
the reason why we'd be using such a

00:12:28,279 --> 00:12:32,690
facility and if you ask anyone who works

00:12:30,680 --> 00:12:35,420
on that stuff what the DP DK container

00:12:32,690 --> 00:12:37,279
story is you'll get this there is no

00:12:35,420 --> 00:12:38,390
answer to that fundamental question and

00:12:37,279 --> 00:12:42,290
I think that's a that's a really

00:12:38,390 --> 00:12:45,260
important limitation is xdp a

00:12:42,290 --> 00:12:48,080
replacement for netfilter TC and other

00:12:45,260 --> 00:12:51,860
such facilities

00:12:48,080 --> 00:12:53,930
that's right xcp targets of specific

00:12:51,860 --> 00:12:55,970
kinds of use cases and if you just dude

00:12:53,930 --> 00:12:58,490
here he's the ejected jack-of-all-trades

00:12:55,970 --> 00:13:01,370
that that's not xvp on the screen there

00:12:58,490 --> 00:13:02,930
doesn't that's something else it

00:13:01,370 --> 00:13:05,269
provides high-performance packet

00:13:02,930 --> 00:13:07,040
high-performance packet operations very

00:13:05,269 --> 00:13:08,420
extremely flexible policy

00:13:07,040 --> 00:13:10,810
decision-making and I think that's an

00:13:08,420 --> 00:13:14,360
important aspect to understand about BPF

00:13:10,810 --> 00:13:15,500
so one thing that over time if you've

00:13:14,360 --> 00:13:16,760
been in the kernel for a long time

00:13:15,500 --> 00:13:19,160
you'll notice is that people keep asking

00:13:16,760 --> 00:13:20,149
for new interfaces and API is to do all

00:13:19,160 --> 00:13:22,279
kinds of new things

00:13:20,149 --> 00:13:24,350
it's basically I've come up with this

00:13:22,279 --> 00:13:27,050
new policy decision-making mechanism I

00:13:24,350 --> 00:13:28,910
want to use for my use case please add

00:13:27,050 --> 00:13:30,050
this new API to the kernel so I can

00:13:28,910 --> 00:13:30,980
actually implement that policy

00:13:30,050 --> 00:13:34,100
decision-making

00:13:30,980 --> 00:13:35,570
this doesn't scale this is actually kind

00:13:34,100 --> 00:13:38,240
of terrible the reason that it's

00:13:35,570 --> 00:13:40,820
terrible is that we'll make this new

00:13:38,240 --> 00:13:42,260
policy decision-making facility you'll

00:13:40,820 --> 00:13:43,670
be using it for a year or two and then

00:13:42,260 --> 00:13:45,500
you move on to something else yet we

00:13:43,670 --> 00:13:47,660
have to fold onto that API in the kernel

00:13:45,500 --> 00:13:49,399
basically for eternity and it's never

00:13:47,660 --> 00:13:51,649
going to go away whereas if we give

00:13:49,399 --> 00:13:52,790
people a mechanism like Eevee if you

00:13:51,649 --> 00:13:54,350
have to implement their policy

00:13:52,790 --> 00:13:57,470
decision-making however they please in

00:13:54,350 --> 00:13:58,850
whatever way they want we just need this

00:13:57,470 --> 00:14:00,560
it solves the problem on a long-term

00:13:58,850 --> 00:14:02,360
instead of having these short-term

00:14:00,560 --> 00:14:03,709
little ABI tweaks that we do all over

00:14:02,360 --> 00:14:06,829
the place which i think is a really

00:14:03,709 --> 00:14:08,180
important aspect of EBP F but for this

00:14:06,829 --> 00:14:10,370
powered is the cost there are some

00:14:08,180 --> 00:14:11,839
things I can't do it's a fundamentally

00:14:10,370 --> 00:14:13,160
stateless so if you want to have a

00:14:11,839 --> 00:14:14,660
staple kind of thing you would have to

00:14:13,160 --> 00:14:17,600
build it yourself but we have facilities

00:14:14,660 --> 00:14:19,190
that do this already so the next thing

00:14:17,600 --> 00:14:21,440
to ask is well is there at least some

00:14:19,190 --> 00:14:23,180
overlap between these facilities and xdp

00:14:21,440 --> 00:14:25,190
MEB pfm the answer is absolutely yes

00:14:23,180 --> 00:14:26,510
there is overlap between these areas but

00:14:25,190 --> 00:14:28,250
they're not replacements for each other

00:14:26,510 --> 00:14:30,290
they're trying to solve two different

00:14:28,250 --> 00:14:33,890
aspects of the problem space and I think

00:14:30,290 --> 00:14:35,570
it's really important to understand so

00:14:33,890 --> 00:14:37,490
in the future we're going to have a lot

00:14:35,570 --> 00:14:39,560
of things change I hope a lot of

00:14:37,490 --> 00:14:41,510
improvements to the in particular to the

00:14:39,560 --> 00:14:44,720
user experience of running vpf programs

00:14:41,510 --> 00:14:45,769
so aspirin and you got into that one

00:14:44,720 --> 00:14:48,560
thing people are asking for is

00:14:45,769 --> 00:14:51,140
introspection so that means they want to

00:14:48,560 --> 00:14:52,850
be able to pull xcp programs that

00:14:51,140 --> 00:14:54,019
they've installed out and take a look at

00:14:52,850 --> 00:14:58,190
them and see if they installed the right

00:14:54,019 --> 00:15:01,400
one for example we do generate sha-1 ID

00:14:58,190 --> 00:15:03,800
hashes for XDP probe for BPF programs so

00:15:01,400 --> 00:15:06,290
good at least in the initial stages pull

00:15:03,800 --> 00:15:07,430
the SCP program out and make sure it had

00:15:06,290 --> 00:15:10,520
the same house that the one that you

00:15:07,430 --> 00:15:13,430
thought you installed the next element

00:15:10,520 --> 00:15:15,080
is debugging this has been some

00:15:13,430 --> 00:15:18,950
discussion about this we do want to add

00:15:15,080 --> 00:15:21,650
debugging tagging to xcp programs at BPF

00:15:18,950 --> 00:15:23,300
programs and dwarf two is pretty big and

00:15:21,650 --> 00:15:25,310
complicated I guess they're up to dwarf

00:15:23,300 --> 00:15:26,660
four or five now so we've been looking

00:15:25,310 --> 00:15:29,300
at something called compressed type

00:15:26,660 --> 00:15:31,310
format compressed type format is a very

00:15:29,300 --> 00:15:33,470
simplistic way to describe data

00:15:31,310 --> 00:15:35,750
structures that are possible in the C

00:15:33,470 --> 00:15:38,360
language and we could attach this

00:15:35,750 --> 00:15:39,740
debugging information to BPF programs to

00:15:38,360 --> 00:15:43,820
do all kinds of cool stuff so for

00:15:39,740 --> 00:15:46,340
example if we attach the CTF info to the

00:15:43,820 --> 00:15:48,800
BPF program and the maps it's attached

00:15:46,340 --> 00:15:50,060
to we could pretty print them when you

00:15:48,800 --> 00:15:51,790
put in when we pull them out of the

00:15:50,060 --> 00:15:54,290
kernel when we do an introspection

00:15:51,790 --> 00:15:56,180
another thing that element to this that

00:15:54,290 --> 00:15:58,190
I think is really interesting is we

00:15:56,180 --> 00:16:00,710
could trace xev programs using per 5

00:15:58,190 --> 00:16:02,630
ends so for example you could put X DP

00:16:00,710 --> 00:16:04,970
into a debugging mode where you say okay

00:16:02,630 --> 00:16:07,460
don't use the JIT use the interpreter

00:16:04,970 --> 00:16:09,350
and as you execute every VP of

00:16:07,460 --> 00:16:11,810
instruction in my code generate a

00:16:09,350 --> 00:16:13,820
perfect well structured with a reference

00:16:11,810 --> 00:16:17,090
to the CTF information so I could see it

00:16:13,820 --> 00:16:18,440
every I can I can trace the xdp programs

00:16:17,090 --> 00:16:19,940
that's running we could do this on a

00:16:18,440 --> 00:16:21,590
probabilistic manner because you don't

00:16:19,940 --> 00:16:23,270
want to trace every single packet that

00:16:21,590 --> 00:16:25,820
comes to the system you could say every

00:16:23,270 --> 00:16:27,680
10,000 packets run a trace and give me a

00:16:25,820 --> 00:16:29,210
perf dump with all the type information

00:16:27,680 --> 00:16:32,440
and everything so that could be really

00:16:29,210 --> 00:16:34,520
useful the tooling is not it has been

00:16:32,440 --> 00:16:35,900
converging on a more consistent manner

00:16:34,520 --> 00:16:38,510
but there's a lot of improvement for

00:16:35,900 --> 00:16:41,000
that area as well so I think another

00:16:38,510 --> 00:16:43,250
thing that's interesting is that the xdp

00:16:41,000 --> 00:16:45,440
programs can as Facebook showed can

00:16:43,250 --> 00:16:47,660
generate arbitrary performance and we

00:16:45,440 --> 00:16:49,550
could also we could leverage the CTF

00:16:47,660 --> 00:16:50,930
infrastructure to allow programs to

00:16:49,550 --> 00:16:53,840
define what types are involved are

00:16:50,930 --> 00:16:55,370
including in those events so if they

00:16:53,840 --> 00:16:56,930
just get spit out by / if we could use

00:16:55,370 --> 00:16:59,780
CTF to figure out what the layout of the

00:16:56,930 --> 00:17:01,180
data structures are so I think the whole

00:16:59,780 --> 00:17:04,790
argument about lack of introspection

00:17:01,180 --> 00:17:06,530
will be solved but I think there's

00:17:04,790 --> 00:17:11,510
another element to this discussion which

00:17:06,530 --> 00:17:14,060
we're going to get into next so I went

00:17:11,510 --> 00:17:15,290
to a place where they were teaching

00:17:14,060 --> 00:17:18,350
people how to use our dream

00:17:15,290 --> 00:17:20,329
and I sat there in an introduction yard

00:17:18,350 --> 00:17:22,430
Reno class and I wrote the usual

00:17:20,329 --> 00:17:23,750
introduction the first program everyone

00:17:22,430 --> 00:17:26,690
writes in our journal just to flip the

00:17:23,750 --> 00:17:28,700
leads off and on and basically how this

00:17:26,690 --> 00:17:30,470
works is you get this GUI you write your

00:17:28,700 --> 00:17:31,970
little C program and there is a bunch of

00:17:30,470 --> 00:17:33,380
well-defined entry points and there's a

00:17:31,970 --> 00:17:34,910
set of well-defined helpers that you can

00:17:33,380 --> 00:17:36,590
call to interact with the device and

00:17:34,910 --> 00:17:38,390
then when you're done you click this

00:17:36,590 --> 00:17:39,980
button which compiles it and if it

00:17:38,390 --> 00:17:41,630
compiles successfully it pushes it on to

00:17:39,980 --> 00:17:44,180
the device and if everything goes

00:17:41,630 --> 00:17:46,970
correctly the LED starts blinking and I

00:17:44,180 --> 00:17:49,280
said to myself it's a wing this is just

00:17:46,970 --> 00:17:51,350
like writing XDP programs this is very

00:17:49,280 --> 00:17:53,780
similar development cycle and the

00:17:51,350 --> 00:17:57,320
workflow is almost identical and if you

00:17:53,780 --> 00:17:59,300
think about it anybody with such a huge

00:17:57,320 --> 00:18:01,400
class of people write arduino programs

00:17:59,300 --> 00:18:03,020
fashion designers people designing

00:18:01,400 --> 00:18:06,080
interiors and buildings and things like

00:18:03,020 --> 00:18:07,670
this it's not limited to just computer

00:18:06,080 --> 00:18:09,110
people which is kind of like a

00:18:07,670 --> 00:18:10,820
revelation that I think isn't quite

00:18:09,110 --> 00:18:12,680
important so this I kind of think that

00:18:10,820 --> 00:18:14,510
XDP can kind of move in this direction

00:18:12,680 --> 00:18:16,790
where people who are not kernel

00:18:14,510 --> 00:18:18,650
developers people who don't specialize

00:18:16,790 --> 00:18:21,530
in this area like we do could be able to

00:18:18,650 --> 00:18:23,390
write simple programs to say oh I want

00:18:21,530 --> 00:18:25,160
to block packets from this place because

00:18:23,390 --> 00:18:26,900
someone's attacking my machine at home I

00:18:25,160 --> 00:18:28,250
can describe a little xp program and I

00:18:26,900 --> 00:18:30,860
can make that work I think that's kind

00:18:28,250 --> 00:18:32,150
of cool so it's kind of interesting to

00:18:30,860 --> 00:18:33,110
think about the previous slide where

00:18:32,150 --> 00:18:35,300
everyone complains that there's no

00:18:33,110 --> 00:18:36,890
introspection well with Arduino there

00:18:35,300 --> 00:18:38,270
isn't any introspection either you push

00:18:36,890 --> 00:18:39,860
it into this black box and it either

00:18:38,270 --> 00:18:41,900
works or it doesn't you have to debug

00:18:39,860 --> 00:18:43,540
the little program in your GUI interface

00:18:41,900 --> 00:18:46,400
or whatever so I think there's a lot of

00:18:43,540 --> 00:18:48,470
parallels there that are quite

00:18:46,400 --> 00:18:49,970
interesting so we're going to get there

00:18:48,470 --> 00:18:51,560
things are going to get better and we're

00:18:49,970 --> 00:18:53,450
going to have like your neighbor the

00:18:51,560 --> 00:18:55,100
plumber running xdp programs it's a very

00:18:53,450 --> 00:18:58,760
exciting future I have a plan for

00:18:55,100 --> 00:19:00,590
everyone now it's time for some thank

00:18:58,760 --> 00:19:02,150
yous I like to lengthen his 12 volts for

00:19:00,590 --> 00:19:04,030
making this incredible project for us to

00:19:02,150 --> 00:19:07,040
hack on every single day I think it's

00:19:04,030 --> 00:19:09,050
it's easy to forget that way back in the

00:19:07,040 --> 00:19:10,970
day he made a critical decision that

00:19:09,050 --> 00:19:12,980
created what we have right now at this

00:19:10,970 --> 00:19:15,110
moment so that's really important like

00:19:12,980 --> 00:19:17,420
to thank van Jacobson and make over oyk

00:19:15,110 --> 00:19:19,340
because they they created BPF and gave

00:19:17,420 --> 00:19:20,870
us this interesting piece of

00:19:19,340 --> 00:19:24,110
infrastructure to build into a much

00:19:20,870 --> 00:19:25,460
bigger crazy beast I like to thank Alexi

00:19:24,110 --> 00:19:27,650
and Daniel because they've been working

00:19:25,460 --> 00:19:28,980
on EVP eff for a long time giving us all

00:19:27,650 --> 00:19:31,110
the great infrastructure we have

00:19:28,980 --> 00:19:32,400
I like to thank Thomas Graff and Tom

00:19:31,110 --> 00:19:34,860
Herbert in particular because they've

00:19:32,400 --> 00:19:36,330
been thinking about how to use EPF EB PF

00:19:34,860 --> 00:19:37,890
in other interesting ways and at what

00:19:36,330 --> 00:19:39,810
the long-term strategy is for all these

00:19:37,890 --> 00:19:42,120
amazing pieces of architectural

00:19:39,810 --> 00:19:43,860
infrastructure I'd also like to thank

00:19:42,120 --> 00:19:46,320
Intel Mellanox and net genome because

00:19:43,860 --> 00:19:48,510
they were the first to write ad xcp

00:19:46,320 --> 00:19:49,740
support for their hardware I think that

00:19:48,510 --> 00:19:52,230
was important that we had a couple

00:19:49,740 --> 00:19:53,730
drivers - for people with reference

00:19:52,230 --> 00:19:55,970
drivers initially for people to actually

00:19:53,730 --> 00:19:58,230
use and see what next EP can do and

00:19:55,970 --> 00:20:00,390
finally I'd like to thank Jamal because

00:19:58,230 --> 00:20:01,920
he put this whole thing together and if

00:20:00,390 --> 00:20:04,050
you have even an inkling into what's

00:20:01,920 --> 00:20:06,720
involved in writing running an event of

00:20:04,050 --> 00:20:08,580
this nature he really worked really hard

00:20:06,720 --> 00:20:10,140
and it's not easy so I'd like to

00:20:08,580 --> 00:20:18,150
everyone to give a round of applause for

00:20:10,140 --> 00:20:21,710
Jamal and I hope everyone looks forward

00:20:18,150 --> 00:20:33,470
to my nan XDP talk at the next met dev

00:20:21,710 --> 00:20:33,470
presentation thank you questions

00:20:46,650 --> 00:20:54,120
first I wanna thank Dave xvp is you know

00:20:51,910 --> 00:20:57,250
solving a lot of problems and making

00:20:54,120 --> 00:20:59,380
performance for a lot of this traffic

00:20:57,250 --> 00:21:04,270
that should have been dropped at the

00:20:59,380 --> 00:21:07,780
right place you know happening I do have

00:21:04,270 --> 00:21:10,230
one question and maybe you know you have

00:21:07,780 --> 00:21:14,230
when we started with XTP there was one

00:21:10,230 --> 00:21:19,900
thing we said it is Hardware agnostic in

00:21:14,230 --> 00:21:23,530
some sense the action which is xt p TX

00:21:19,900 --> 00:21:26,350
action which is the forward pocket to

00:21:23,530 --> 00:21:29,110
see performance on that you know the

00:21:26,350 --> 00:21:33,160
only way we can do it is in a hardware

00:21:29,110 --> 00:21:35,890
aware manner where you have an x DP TX q

00:21:33,160 --> 00:21:39,910
pork or dedicated for you know sending a

00:21:35,890 --> 00:21:43,090
packet out which leads to some driver

00:21:39,910 --> 00:21:46,390
model change so it's not totally

00:21:43,090 --> 00:21:49,660
Hardware agnostic in the sense which you

00:21:46,390 --> 00:21:52,390
know is not a bad thing so I think it is

00:21:49,660 --> 00:21:54,760
in a different way it's there's two

00:21:52,390 --> 00:21:56,679
things first of all at some point in the

00:21:54,760 --> 00:21:59,110
not-too-distant future I want to have a

00:21:56,679 --> 00:22:01,510
generic XDP implementation that such

00:21:59,110 --> 00:22:03,370
that any driver you could have any

00:22:01,510 --> 00:22:06,220
device whatsoever in at least experiment

00:22:03,370 --> 00:22:08,260
and play with xtp the first point the

00:22:06,220 --> 00:22:10,570
second point is if you want the full

00:22:08,260 --> 00:22:12,370
performance of x DP TX yes absolutely

00:22:10,570 --> 00:22:14,350
you need to do some special stuff in

00:22:12,370 --> 00:22:19,660
your driver and this applies to xcp

00:22:14,350 --> 00:22:21,790
support fundamentally right third thing

00:22:19,660 --> 00:22:23,920
is we do have plans for something that's

00:22:21,790 --> 00:22:25,630
going to test those boundaries and the

00:22:23,920 --> 00:22:26,800
limitations of that kind of design we're

00:22:25,630 --> 00:22:28,660
going to try to have a something called

00:22:26,800 --> 00:22:31,330
an x DP redirect where you could send to

00:22:28,660 --> 00:22:33,910
another device altogether so yes that's

00:22:31,330 --> 00:22:36,850
a very important point like the XE BTX

00:22:33,910 --> 00:22:38,620
support to be optimal it needs to be

00:22:36,850 --> 00:22:40,330
done in a driver specific manner and

00:22:38,620 --> 00:22:42,429
that's an important point to make yeah I

00:22:40,330 --> 00:22:43,929
also I also want to want to say that one

00:22:42,429 --> 00:22:46,840
thing I do want to see is I want to see

00:22:43,929 --> 00:22:49,000
anyone who does goes to the trouble of

00:22:46,840 --> 00:22:51,090
doing xdp support for a specific driver

00:22:49,000 --> 00:22:53,320
that they implement the full feature set

00:22:51,090 --> 00:22:55,780
because we don't want a situation where

00:22:53,320 --> 00:22:56,980
people can't load certain programs on a

00:22:55,780 --> 00:22:58,600
particular kernel release

00:22:56,980 --> 00:23:00,700
the driver author said I'm not want to

00:22:58,600 --> 00:23:02,320
bother Alexi bgx so we should really

00:23:00,700 --> 00:23:05,049
make it a requirement to support the

00:23:02,320 --> 00:23:07,210
whole suite of facilities yeah that was

00:23:05,049 --> 00:23:08,770
my point like if we can understand that

00:23:07,210 --> 00:23:11,169
requirement over there from the hardware

00:23:08,770 --> 00:23:14,230
it'll be really easy to design the

00:23:11,169 --> 00:23:16,559
driver around it and the device so yes I

00:23:14,230 --> 00:23:22,660
agree

00:23:16,559 --> 00:23:24,419
anybody else oh let's give him another

00:23:22,660 --> 00:23:29,850
round of applause but don't leave yet

00:23:24,419 --> 00:23:29,850

YouTube URL: https://www.youtube.com/watch?v=8Cxg7mpVIWw


