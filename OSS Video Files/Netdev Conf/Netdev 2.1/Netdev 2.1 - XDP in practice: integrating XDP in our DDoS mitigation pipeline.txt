Title: Netdev 2.1 - XDP in practice: integrating XDP in our DDoS mitigation pipeline
Publication date: 2017-04-26
Playlist: Netdev 2.1
Description: 
	This talk given on  2017 April 6th by  by Gilberto Bertin
provides an overview of how Cloudflare is planning to integrate
XDP for DDoS mitigation.

https://www.netdevconf.org/2.1/session.html?bertin
Captions: 
	00:00:00,350 --> 00:00:03,920
can you hear me

00:00:13,980 --> 00:00:18,779
okay good morning everyone thanks for

00:00:18,360 --> 00:00:21,869
coming

00:00:18,779 --> 00:00:23,760
so I'm Jim dr. Burton I'm a system

00:00:21,869 --> 00:00:26,490
engineer at culture and today I will

00:00:23,760 --> 00:00:29,609
talk about our plans to integrate xep

00:00:26,490 --> 00:00:31,830
into our DDoS mitigation pipeline so

00:00:29,609 --> 00:00:33,930
let's get started by introducing this

00:00:31,830 --> 00:00:35,820
culture culture is a security and

00:00:33,930 --> 00:00:38,070
performance company which provides among

00:00:35,820 --> 00:00:41,460
other things reverse proxy CDN service

00:00:38,070 --> 00:00:43,739
so when a site is on culture our edge

00:00:41,460 --> 00:00:47,220
service will sit in front of the site

00:00:43,739 --> 00:00:48,809
original service and this means that all

00:00:47,220 --> 00:00:51,330
the traffic for the site will go first

00:00:48,809 --> 00:00:53,820
to our network and will then select

00:00:51,330 --> 00:00:56,159
Weebly proxy back to the origin servers

00:00:53,820 --> 00:00:58,650
in this way we can provide different

00:00:56,159 --> 00:01:01,619
services such as caching or content

00:00:58,650 --> 00:01:04,199
optimization but most important day for

00:01:01,619 --> 00:01:06,360
the sake of this talk we can filter on

00:01:04,199 --> 00:01:08,970
average all the malicious traffic that

00:01:06,360 --> 00:01:15,600
is targeting the origin servers of the

00:01:08,970 --> 00:01:18,830
site Y and Cutler so to give you some

00:01:15,600 --> 00:01:21,510
numbers culturas about 6 million

00:01:18,830 --> 00:01:24,660
customers and about 100 points of

00:01:21,510 --> 00:01:26,760
presence and every day we have to handle

00:01:24,660 --> 00:01:29,460
hundreds of different little subducts

00:01:26,760 --> 00:01:32,820
targeting manual properties and they are

00:01:29,460 --> 00:01:35,940
usually ranging between 50 and 150 boxes

00:01:32,820 --> 00:01:40,260
per second but we recorded peaks of 500

00:01:35,940 --> 00:01:41,370
packets per second attacks so in the

00:01:40,260 --> 00:01:44,490
last three years we have been developing

00:01:41,370 --> 00:01:46,920
a system called Gatewood Gatewood is an

00:01:44,490 --> 00:01:50,580
automatic digital mitigation system and

00:01:46,920 --> 00:01:53,370
is able to automatically detect and

00:01:50,580 --> 00:01:56,070
mitigate different kind of diss attacks

00:01:53,370 --> 00:01:57,630
and it works by constantly analyzing the

00:01:56,070 --> 00:02:01,650
traffic that is flowing through our

00:01:57,630 --> 00:02:04,170
network so this is a overview of the

00:02:01,650 --> 00:02:06,990
gate boat architecture and gate bot can

00:02:04,170 --> 00:02:10,080
be broken down into four main phases the

00:02:06,990 --> 00:02:11,790
first phase is traffic collection so the

00:02:10,080 --> 00:02:14,430
first thing we do is collect traffic

00:02:11,790 --> 00:02:17,160
samples on every single server on our

00:02:14,430 --> 00:02:19,950
network the second phase is aggregating

00:02:17,160 --> 00:02:22,290
all the samples in a central location to

00:02:19,950 --> 00:02:24,990
actually detect the traffic that is

00:02:22,290 --> 00:02:27,990
happening on our network the third phase

00:02:24,990 --> 00:02:29,820
is reacting which means given a list of

00:02:27,990 --> 00:02:31,950
description of the attacks we want to

00:02:29,820 --> 00:02:36,780
produce a series of mitigation routes

00:02:31,950 --> 00:02:39,150
and the phase is of course filtering the

00:02:36,780 --> 00:02:40,740
traffic on the edge service and there

00:02:39,150 --> 00:02:43,050
are two important things to notice here

00:02:40,740 --> 00:02:45,210
the first one is that we don't rely on

00:02:43,050 --> 00:02:47,730
scrubbing centers where the traffic is

00:02:45,210 --> 00:02:50,340
forwarded to be filtered but we rather

00:02:47,730 --> 00:02:52,650
just filter all the traffic on the edge

00:02:50,340 --> 00:02:56,340
servers and the second thing is that we

00:02:52,650 --> 00:02:59,160
are currently heavy users of classic PDF

00:02:56,340 --> 00:03:02,760
byte code for to express the mitigation

00:02:59,160 --> 00:03:04,830
logic so let's get started from traffic

00:03:02,760 --> 00:03:07,590
sampling the important thing to notice

00:03:04,830 --> 00:03:09,240
here is that to detect big DDoS attacks

00:03:07,590 --> 00:03:11,100
there is no need to analyze the entire

00:03:09,240 --> 00:03:13,050
traffic flowing through our network it

00:03:11,100 --> 00:03:15,660
will be impractical and a waste of

00:03:13,050 --> 00:03:17,970
resources in fact only a small portion

00:03:15,660 --> 00:03:22,200
of the traffic is more than sufficient

00:03:17,970 --> 00:03:24,510
to detect big DDoS attacks of millions

00:03:22,200 --> 00:03:26,670
of packets per second and the traffic

00:03:24,510 --> 00:03:29,310
samples are corrected directly on the

00:03:26,670 --> 00:03:32,250
edge servers we use a combination of

00:03:29,310 --> 00:03:35,270
alka tables and a clock target and a

00:03:32,250 --> 00:03:37,800
user space program which basically takes

00:03:35,270 --> 00:03:40,770
which gets all the samples from IP

00:03:37,800 --> 00:03:42,720
tables and forward them as aspra UDP

00:03:40,770 --> 00:03:46,350
packets to a central location where they

00:03:42,720 --> 00:03:48,270
will be analyzed further the second

00:03:46,350 --> 00:03:51,180
phase is attack detection but first we

00:03:48,270 --> 00:03:54,390
should define what is an attack we can

00:03:51,180 --> 00:03:56,610
broadly define an attack as a big spike

00:03:54,390 --> 00:03:59,880
of traffic targeting a specific IP or

00:03:56,610 --> 00:04:02,430
subnet and part and in this way it's

00:03:59,880 --> 00:04:04,920
easy to reason about attacks targeting a

00:04:02,430 --> 00:04:06,450
specific service this is a typical day

00:04:04,920 --> 00:04:09,030
at Telfer where the yellow line

00:04:06,450 --> 00:04:11,090
represents the baseline or logic traffic

00:04:09,030 --> 00:04:13,350
while the green line represents the

00:04:11,090 --> 00:04:17,970
malicious traffic that was detected by

00:04:13,350 --> 00:04:20,730
gate bot so for what concerns the

00:04:17,970 --> 00:04:23,280
traffic analysis and aggregation we

00:04:20,730 --> 00:04:25,830
first try to aggregate the traffic into

00:04:23,280 --> 00:04:29,010
macro categories so for example the TCP

00:04:25,830 --> 00:04:30,710
syn packets are treated separately from

00:04:29,010 --> 00:04:33,350
TCP packets and from

00:04:30,710 --> 00:04:35,449
Deanna's pockets on top of that we apply

00:04:33,350 --> 00:04:38,330
other aggregation based on the

00:04:35,449 --> 00:04:41,900
distinction that impart and finally on

00:04:38,330 --> 00:04:44,060
top of that we apply other aggregation

00:04:41,900 --> 00:04:49,190
based on known attack vectors and other

00:04:44,060 --> 00:04:51,110
eristic and this is simplified output of

00:04:49,190 --> 00:04:53,840
the state for example gate bode may have

00:04:51,110 --> 00:04:55,699
detected that there are a couple of DNS

00:04:53,840 --> 00:04:59,900
crude targeting a couple of name servers

00:04:55,699 --> 00:05:02,479
and the attacker is trying to perform

00:04:59,900 --> 00:05:04,130
what we call a random practice attack so

00:05:02,479 --> 00:05:06,650
basically the attacker is just sending

00:05:04,130 --> 00:05:11,900
random queries for the domain

00:05:06,650 --> 00:05:15,740
example.com to exhaust the CPU of the of

00:05:11,900 --> 00:05:17,660
the server the next phase is reaction so

00:05:15,740 --> 00:05:19,160
the first thing we do is applying a sip

00:05:17,660 --> 00:05:21,229
at simple packets per second

00:05:19,160 --> 00:05:23,599
thresholding because for small attacks

00:05:21,229 --> 00:05:26,300
there is no need to mitigate them we can

00:05:23,599 --> 00:05:29,270
just let the traffic flow through and

00:05:26,300 --> 00:05:31,849
then other factors such as the SLA of

00:05:29,270 --> 00:05:34,960
the client are taken into account to

00:05:31,849 --> 00:05:37,820
determine the mitigation parameters and

00:05:34,960 --> 00:05:40,870
finally the attack description is turned

00:05:37,820 --> 00:05:45,680
into BBS which will then be run on the

00:05:40,870 --> 00:05:48,199
edge servers to do this we use a set of

00:05:45,680 --> 00:05:51,800
utilities called VPS tools they

00:05:48,199 --> 00:05:54,050
basically take a description of the part

00:05:51,800 --> 00:05:56,360
of the attack that you want to match and

00:05:54,050 --> 00:05:59,570
generate classic VPS byte code for

00:05:56,360 --> 00:06:01,909
example here we are generating a VPS

00:05:59,570 --> 00:06:04,759
byte code to match a specific payload in

00:06:01,909 --> 00:06:07,159
generous packets and in this case we are

00:06:04,759 --> 00:06:12,169
matching all the queries for start of

00:06:07,159 --> 00:06:15,530
example dot whywe X wizard the next

00:06:12,169 --> 00:06:19,880
phase is to push mitigations back to the

00:06:15,530 --> 00:06:22,009
edge service and we to do this we use a

00:06:19,880 --> 00:06:26,509
distributed key-value database which

00:06:22,009 --> 00:06:28,970
allows us to push in a short time the

00:06:26,509 --> 00:06:33,470
mitigations back to our set of machines

00:06:28,970 --> 00:06:37,039
and then in the on every server there is

00:06:33,470 --> 00:06:40,370
a demon listening for updates on this

00:06:37,039 --> 00:06:42,729
key value store and this demon is in

00:06:40,370 --> 00:06:44,300
charge of actually applying the

00:06:42,729 --> 00:06:46,400
limitations

00:06:44,300 --> 00:06:50,629
and to do this with a couple of tools

00:06:46,400 --> 00:06:53,659
iptables and user space program to where

00:06:50,629 --> 00:06:56,300
we have flowed network traffic so let's

00:06:53,659 --> 00:06:57,830
start from IP tables IP tables I

00:06:56,300 --> 00:07:01,099
initially was the only tool we were

00:06:57,830 --> 00:07:04,729
relying on to inter malicious traffic

00:07:01,099 --> 00:07:07,840
and it was great because we could use

00:07:04,729 --> 00:07:10,970
the usual IP tables syntax to express

00:07:07,840 --> 00:07:12,860
all the mitigation logic and where IP

00:07:10,970 --> 00:07:15,580
tables was not expressive enough we

00:07:12,860 --> 00:07:19,280
would just load with the HTTP module

00:07:15,580 --> 00:07:19,639
some VPS byte code so this was great to

00:07:19,280 --> 00:07:21,620
use

00:07:19,639 --> 00:07:24,110
but unfortunately soon we started

00:07:21,620 --> 00:07:28,969
experiencing performance issues with IP

00:07:24,110 --> 00:07:30,650
tables because in case of big attacks at

00:07:28,969 --> 00:07:33,139
worst servers were basically just

00:07:30,650 --> 00:07:35,449
processing and printing Network packets

00:07:33,139 --> 00:07:39,110
and the actual applications were just

00:07:35,449 --> 00:07:41,900
starving of CPUs so we have to move to a

00:07:39,110 --> 00:07:46,129
user space offload solution this is

00:07:41,900 --> 00:07:48,860
based on the salasi FEI api and using

00:07:46,129 --> 00:07:51,889
this solution we can just upload to user

00:07:48,860 --> 00:07:54,349
space the network traffic before the

00:07:51,889 --> 00:07:57,500
traffic the Linux Network stack and not

00:07:54,349 --> 00:08:00,889
filter and then user space we can just

00:07:57,500 --> 00:08:03,529
run a VPS the same VPS that we will run

00:08:00,889 --> 00:08:06,979
with IP tables and just filter the

00:08:03,529 --> 00:08:08,990
traffic and this works well because this

00:08:06,979 --> 00:08:12,050
is an order of magnitude faster than IP

00:08:08,990 --> 00:08:14,870
tables but this is still not optimal

00:08:12,050 --> 00:08:17,360
because there are a couple of issues

00:08:14,870 --> 00:08:19,430
with that first thing this solution

00:08:17,360 --> 00:08:21,229
requires one or more CPUs to be

00:08:19,430 --> 00:08:25,069
completely dedicated for this task

00:08:21,229 --> 00:08:27,740
because what we do is we perform busy

00:08:25,069 --> 00:08:29,900
polling on the network as de thank you

00:08:27,740 --> 00:08:32,630
because we want to minimize the latency

00:08:29,900 --> 00:08:34,880
of course and the second thing is that

00:08:32,630 --> 00:08:36,760
we injecting packets back into the

00:08:34,880 --> 00:08:39,800
network stack from user space is

00:08:36,760 --> 00:08:42,110
expensive so for certain kind of attacks

00:08:39,800 --> 00:08:44,120
we may end up uploading a lot of legit

00:08:42,110 --> 00:08:46,310
traffic to your space which has done to

00:08:44,120 --> 00:08:50,720
be rejected back to the network stack

00:08:46,310 --> 00:08:51,649
and this may be expansion and this is

00:08:50,720 --> 00:08:54,740
where xep

00:08:51,649 --> 00:08:57,020
comes into play because with xep we

00:08:54,740 --> 00:08:58,279
would have a single unified solution to

00:08:57,020 --> 00:08:59,930
filter traffic

00:08:58,279 --> 00:09:01,550
we would be able to move away the

00:08:59,930 --> 00:09:03,560
sintering logic from iptables

00:09:01,550 --> 00:09:07,999
and of course there will be no need to

00:09:03,560 --> 00:09:12,079
use sintering solution based on user

00:09:07,999 --> 00:09:15,259
space of load so where does PCP fit in

00:09:12,079 --> 00:09:17,509
our system the first piece that need to

00:09:15,259 --> 00:09:20,329
be changed is the reaction phase because

00:09:17,509 --> 00:09:23,990
instead of outputting just classic DPS

00:09:20,329 --> 00:09:27,620
for a partial part of a sintering law

00:09:23,990 --> 00:09:29,569
rule what we want to do is get the list

00:09:27,620 --> 00:09:31,759
of all the attacks and generate a single

00:09:29,569 --> 00:09:34,670
xep program that would match all the

00:09:31,759 --> 00:09:37,069
attacks and after that we could just

00:09:34,670 --> 00:09:39,470
compile it to ebps and use the same

00:09:37,069 --> 00:09:42,170
x-value database tour that we are

00:09:39,470 --> 00:09:47,149
currently using and just distribute the

00:09:42,170 --> 00:09:49,819
bytecode to our little machine so only

00:09:47,149 --> 00:09:52,370
on the edge on our edge server that will

00:09:49,819 --> 00:09:54,800
be done in CP diamond user space lemma

00:09:52,370 --> 00:09:57,110
which would listen for updates on the

00:09:54,800 --> 00:09:59,360
key value store and we'll just be in

00:09:57,110 --> 00:10:02,660
charge of deploying the new HTTP

00:09:59,360 --> 00:10:05,779
programs on the NIC driver and keep

00:10:02,660 --> 00:10:08,500
track of the packets that were dropped

00:10:05,779 --> 00:10:12,379
by using immediate Maps

00:10:08,500 --> 00:10:14,750
so this is an example of simple HTTP

00:10:12,379 --> 00:10:17,809
program that would be also generated so

00:10:14,750 --> 00:10:20,029
it's just a list of simple statements

00:10:17,809 --> 00:10:22,819
where every statement represents a

00:10:20,029 --> 00:10:26,689
single rule so the program would just go

00:10:22,819 --> 00:10:28,870
through all the rules and try to if any

00:10:26,689 --> 00:10:31,699
of the rules is a match this mean that

00:10:28,870 --> 00:10:32,930
the packet is should be dropped and so

00:10:31,699 --> 00:10:35,839
we just return xep

00:10:32,930 --> 00:10:41,089
drop otherwise after going through all

00:10:35,839 --> 00:10:43,250
the rules and if known is a match we

00:10:41,089 --> 00:10:46,850
just return exhibit pass and the packet

00:10:43,250 --> 00:10:49,699
is accepted so how does a specific rule

00:10:46,850 --> 00:10:52,519
looks like and again are a specific rule

00:10:49,699 --> 00:10:55,069
would be composed of a list of a simple

00:10:52,519 --> 00:10:56,779
leaf of statements where every state can

00:10:55,069 --> 00:11:00,829
represent a condition that the packet

00:10:56,779 --> 00:11:03,579
must meet to be matched by the rules so

00:11:00,829 --> 00:11:06,319
if any of the condition is not a match

00:11:03,579 --> 00:11:09,440
the packet is not a match for the rules

00:11:06,319 --> 00:11:11,780
and so we go on with the next rule

00:11:09,440 --> 00:11:13,820
otherwise if the packet is actually a

00:11:11,780 --> 00:11:16,340
match for the rules to more actions are

00:11:13,820 --> 00:11:18,380
needed and the actions are accounting

00:11:16,340 --> 00:11:23,210
and trying to pick the packet for

00:11:18,380 --> 00:11:25,850
traffic to be sampled so accounting is

00:11:23,210 --> 00:11:28,160
easy because we can just keep an EDF map

00:11:25,850 --> 00:11:32,270
shared with a user space program where

00:11:28,160 --> 00:11:34,580
the key is the attack ad while the value

00:11:32,270 --> 00:11:38,180
is just a number of packets that were

00:11:34,580 --> 00:11:42,590
dropped by the two were dropped by the

00:11:38,180 --> 00:11:46,670
root so this is fairly easy for what so

00:11:42,590 --> 00:11:49,010
for what concerns something packets we

00:11:46,670 --> 00:11:51,230
are not yet sure about the solution to

00:11:49,010 --> 00:11:54,980
about and in fact here it just commented

00:11:51,230 --> 00:11:57,350
out and the filtering function is just

00:11:54,980 --> 00:12:02,390
ignoring this for the moment but I will

00:11:57,350 --> 00:12:05,450
come back to this later so let's see a

00:12:02,390 --> 00:12:07,310
practical example of auto-generated rule

00:12:05,450 --> 00:12:10,460
but before doing that let me first

00:12:07,310 --> 00:12:12,710
introduce pause so path is a tool to

00:12:10,460 --> 00:12:15,410
passively analyze and categorize network

00:12:12,710 --> 00:12:17,330
traffic and one of the features that we

00:12:15,410 --> 00:12:20,090
like the most from pause is the

00:12:17,330 --> 00:12:23,720
extremely conscious syntax that perfuses

00:12:20,090 --> 00:12:25,910
to a civilized a TCP syn packet we call

00:12:23,720 --> 00:12:29,090
this a signature and basically it's just

00:12:25,910 --> 00:12:31,400
a short description of all the

00:12:29,090 --> 00:12:34,430
meaningful skills of a TCP syn packet

00:12:31,400 --> 00:12:36,140
for example here we can see a signature

00:12:34,430 --> 00:12:38,720
which tells us a lot because we know

00:12:36,140 --> 00:12:41,510
it's an ipv4 packet we know the initial

00:12:38,720 --> 00:12:44,870
TTL is 64 we know that there are no 80

00:12:41,510 --> 00:12:48,170
options the MSS is not fixed but the

00:12:44,870 --> 00:12:50,780
windows size is 10 times the MSS and the

00:12:48,170 --> 00:12:53,510
windows scale is 6 then we have the

00:12:50,780 --> 00:12:56,900
layout of the TCP options a couple of

00:12:53,510 --> 00:12:59,060
tweaks such as JP ID is not zero and we

00:12:56,900 --> 00:13:03,790
know that the packet is not carrying any

00:12:59,060 --> 00:13:06,830
payload so currently our BPS tools

00:13:03,790 --> 00:13:09,920
package as a ready support for pause so

00:13:06,830 --> 00:13:13,100
we can run the tool pass up of signature

00:13:09,920 --> 00:13:17,050
and we will get as output a the duty

00:13:13,100 --> 00:13:21,350
cycle to match a specific packet that

00:13:17,050 --> 00:13:23,180
matches the pop signatures and this this

00:13:21,350 --> 00:13:25,700
is done by just in

00:13:23,180 --> 00:13:28,910
tcpdump filter sirs which is then

00:13:25,700 --> 00:13:30,950
converted to classic DBS and the output

00:13:28,910 --> 00:13:33,190
is the following

00:13:30,950 --> 00:13:35,900
moving to ebps and xep

00:13:33,190 --> 00:13:40,330
would be bring many improvements because

00:13:35,900 --> 00:13:43,280
we can just omit C code which would be

00:13:40,330 --> 00:13:46,570
optimized by sealing and there will be

00:13:43,280 --> 00:13:48,290
no longer the 64 instruction limitation

00:13:46,570 --> 00:13:50,720
which can be hid

00:13:48,290 --> 00:13:52,850
if we are dealing with particularly

00:13:50,720 --> 00:13:56,060
complex of signatures with classic

00:13:52,850 --> 00:13:59,300
videos and finally it's easy to combine

00:13:56,060 --> 00:14:02,630
multiple pause function together because

00:13:59,300 --> 00:14:05,690
a matching pause function is just a sip

00:14:02,630 --> 00:14:10,400
function from xeb context to one HCP

00:14:05,690 --> 00:14:14,690
action so let's see an example of an

00:14:10,400 --> 00:14:16,430
auto-generated puffs source in this case

00:14:14,690 --> 00:14:20,360
this is an early implementation of a

00:14:16,430 --> 00:14:23,030
puff to ebps compiler and we have the

00:14:20,360 --> 00:14:25,010
usual packet boundary checks before

00:14:23,030 --> 00:14:27,740
accessing any data from

00:14:25,010 --> 00:14:30,950
xep we access the ethernet other and

00:14:27,740 --> 00:14:33,350
then we can move on with AP header so

00:14:30,950 --> 00:14:35,300
again unrest checks and then we can

00:14:33,350 --> 00:14:39,080
match all the fields that are specified

00:14:35,300 --> 00:14:42,590
in the dep of signatures for example IP

00:14:39,080 --> 00:14:45,140
version initial teacher and other quicks

00:14:42,590 --> 00:14:47,720
of the packet and then we can we can

00:14:45,140 --> 00:14:51,290
move on and do the same for the TCP

00:14:47,720 --> 00:14:55,640
header and the TCG options we can check

00:14:51,290 --> 00:14:58,100
the that the tcp layout is exactly the

00:14:55,640 --> 00:15:01,340
same specified on the box signature and

00:14:58,100 --> 00:15:03,530
this is just a simple C program which

00:15:01,340 --> 00:15:06,050
can be generated automatically by a

00:15:03,530 --> 00:15:07,760
script and then can be multiple of this

00:15:06,050 --> 00:15:12,860
program square can we just put together

00:15:07,760 --> 00:15:18,130
into a single xeb C program and run on

00:15:12,860 --> 00:15:21,170
our edge so issues we found while

00:15:18,130 --> 00:15:23,540
testing is sleeping this is not really

00:15:21,170 --> 00:15:25,760
an issue is just like a thing because

00:15:23,540 --> 00:15:28,700
xep is a new technology but XE d

00:15:25,760 --> 00:15:31,430
requires a new kernel at least 4.8 but

00:15:28,700 --> 00:15:33,950
at clouds sir we are trying to follow

00:15:31,430 --> 00:15:36,529
the long-term support release so we

00:15:33,950 --> 00:15:38,749
would need to run at least Linux 4.9

00:15:36,529 --> 00:15:41,209
and the second problem is that there is

00:15:38,749 --> 00:15:44,480
no driver support so our network outs as

00:15:41,209 --> 00:15:47,629
a moment as of Linux 4.10 only Mellanox

00:15:44,480 --> 00:15:49,790
and collage ik network cards are

00:15:47,629 --> 00:15:51,709
supported so again this is not a real

00:15:49,790 --> 00:15:55,759
issue just something that it's slowing

00:15:51,709 --> 00:15:59,059
down the adoption and the second bigger

00:15:55,759 --> 00:16:03,470
issue is sampling packet because as I

00:15:59,059 --> 00:16:06,529
said we sample packets on the edge so if

00:16:03,470 --> 00:16:09,170
we just drop the packet with XDP drop we

00:16:06,529 --> 00:16:10,610
would lose visibility into the traffic

00:16:09,170 --> 00:16:15,069
that is going to be that is being

00:16:10,610 --> 00:16:19,189
mitigated by xep so we need a way to

00:16:15,069 --> 00:16:21,230
sample to mark a packet that is going to

00:16:19,189 --> 00:16:23,899
be dropped in a way that the packet can

00:16:21,230 --> 00:16:26,449
be done matched by IP tables and an

00:16:23,899 --> 00:16:28,550
analogue target and just sent back to

00:16:26,449 --> 00:16:32,269
the same user space program we are

00:16:28,550 --> 00:16:35,509
currently using to format all the packet

00:16:32,269 --> 00:16:38,660
sample in a s flow UDP format and sent

00:16:35,509 --> 00:16:41,809
to a central location so there are two

00:16:38,660 --> 00:16:44,480
free ways of doing this the first one

00:16:41,809 --> 00:16:49,329
would be to change a field of the packet

00:16:44,480 --> 00:16:53,089
but of course this would be will mean

00:16:49,329 --> 00:16:56,300
trading off some information for the

00:16:53,089 --> 00:16:59,389
possibility to sample packets the second

00:16:56,300 --> 00:17:00,889
option is to add a Dylan tag to to a

00:16:59,389 --> 00:17:04,419
packet and in this way we could just

00:17:00,889 --> 00:17:06,860
match the VLAN tag IP tables without

00:17:04,419 --> 00:17:10,159
discarding an information from the

00:17:06,860 --> 00:17:12,079
packet but this has downsides as well

00:17:10,159 --> 00:17:15,439
because it will mean that we need to

00:17:12,079 --> 00:17:18,610
shift the whole packet content of 8

00:17:15,439 --> 00:17:21,620
bytes and depending on the sampling rate

00:17:18,610 --> 00:17:25,010
this could have performance implications

00:17:21,620 --> 00:17:26,990
and the first thing has just first

00:17:25,010 --> 00:17:29,120
suggested on the HTTP documentation

00:17:26,990 --> 00:17:31,520
would be to introduce a new target for

00:17:29,120 --> 00:17:34,130
example xtp damn which would allow to

00:17:31,520 --> 00:17:38,809
move the packet that is going to be

00:17:34,130 --> 00:17:41,440
dropped to an AF socket socket so

00:17:38,809 --> 00:17:45,700
currently yeah we would probably just

00:17:41,440 --> 00:17:45,700
add a VLAN tag and

00:17:52,180 --> 00:17:58,430
so you basically want to skv mark value

00:17:55,360 --> 00:18:03,590
I'm sorry could you use an S KB mark

00:17:58,430 --> 00:18:05,780
value if I gave you two you should be

00:18:03,590 --> 00:18:08,510
able to set the skb mark and then

00:18:05,780 --> 00:18:10,600
analyze the packet based upon that value

00:18:08,510 --> 00:18:13,760
later on right yes

00:18:10,600 --> 00:18:16,940
why can't you do that now I mean now

00:18:13,760 --> 00:18:18,290
it's EPA's not access to the skb right

00:18:16,940 --> 00:18:19,910
right okay that's right

00:18:18,290 --> 00:18:22,310
so what I'm what I'm suggesting is we

00:18:19,910 --> 00:18:24,920
could add a field to the metadata yes

00:18:22,310 --> 00:18:26,480
and then let's pool and with that mark

00:18:24,920 --> 00:18:27,980
value gets propagated into this case

00:18:26,480 --> 00:18:29,750
even with us would be yeah which I was

00:18:27,980 --> 00:18:32,390
expecting that they just way to just

00:18:29,750 --> 00:18:33,890
mark a pocket and then we can just

00:18:32,390 --> 00:18:35,210
I could definitely envision a lot of

00:18:33,890 --> 00:18:36,170
people wanting to do the same exact

00:18:35,210 --> 00:18:39,230
thing so that's a pretty reasonable

00:18:36,170 --> 00:18:41,000
request for interface so we might do

00:18:39,230 --> 00:18:44,860
that for you that doesn't feel real

00:18:41,000 --> 00:18:46,010
exist like the TC offload guys already

00:18:44,860 --> 00:18:48,530
doomed

00:18:46,010 --> 00:18:50,210
SKB mark and the metadata they mocked me

00:18:48,530 --> 00:18:53,870
they passed some metadata which

00:18:50,210 --> 00:18:55,640
implements skb mark to the kernel right

00:18:53,870 --> 00:18:57,050
the X which X if he doesn't have the skb

00:18:55,640 --> 00:18:58,160
so you can't execute the instructions

00:18:57,050 --> 00:18:59,990
that change them or you could use the

00:18:58,160 --> 00:19:03,920
same field on the makanda it on the DMA

00:18:59,990 --> 00:19:05,180
metadata no but then I'd have a little

00:19:03,920 --> 00:19:07,220
glad I'm not so sorry

00:19:05,180 --> 00:19:10,730
somebody else was raising their hand

00:19:07,220 --> 00:19:21,470
okay questions are supposed to come at

00:19:10,730 --> 00:19:24,050
the end people but you get high so my

00:19:21,470 --> 00:19:27,260
question is da just like you would have

00:19:24,050 --> 00:19:29,660
safe a bit of engineering effort if you

00:19:27,260 --> 00:19:31,670
would have keep using not IV labels

00:19:29,660 --> 00:19:34,910
because it's going to be hard to be

00:19:31,670 --> 00:19:36,770
jaded but if we if you use NFC and the

00:19:34,910 --> 00:19:38,840
jeat happens from the kernel itself I

00:19:36,770 --> 00:19:40,700
mean in terms of integrating all this

00:19:38,840 --> 00:19:44,360
into your existing infrastructure

00:19:40,700 --> 00:19:47,000
instead of having to school migration we

00:19:44,360 --> 00:19:51,140
we did not think about that because I

00:19:47,000 --> 00:19:53,750
mean the moment we had a possible

00:19:51,140 --> 00:19:57,470
solution would be to use an ST and maybe

00:19:53,750 --> 00:19:58,080
the EBP F because we saw that with Linux

00:19:57,470 --> 00:20:02,309
for

00:19:58,080 --> 00:20:05,039
dan iptables god the ebps mojo sub got

00:20:02,309 --> 00:20:09,419
support for EVF so we could probably run

00:20:05,039 --> 00:20:11,130
EVPs with NF t at a lower layer but we

00:20:09,419 --> 00:20:13,980
don't know we don't have benchmarks

00:20:11,130 --> 00:20:17,640
about that so it's something we should

00:20:13,980 --> 00:20:18,059
probably try yes but we didn't think

00:20:17,640 --> 00:20:22,740
about that

00:20:18,059 --> 00:20:24,480
okay I was just responding to what Jamal

00:20:22,740 --> 00:20:27,750
was saying at most hardware they will

00:20:24,480 --> 00:20:29,730
actually do the mark in the you know for

00:20:27,750 --> 00:20:31,769
the DMA take a software marker put it

00:20:29,730 --> 00:20:34,169
and then it gets copied back which then

00:20:31,769 --> 00:20:36,059
gets carried in this KB and then it can

00:20:34,169 --> 00:20:48,059
be extracted and put in the metadata for

00:20:36,059 --> 00:20:50,100
HTTP yes okay so yeah as I said that the

00:20:48,059 --> 00:20:52,409
current solution would be to just change

00:20:50,100 --> 00:20:54,090
the packet for example we can discuss

00:20:52,409 --> 00:20:56,429
the field and that would be our match

00:20:54,090 --> 00:20:58,019
but if we could just add a mark to the

00:20:56,429 --> 00:21:00,179
socket buffer that would be in the alias

00:20:58,019 --> 00:21:05,760
solution and we can just match it from

00:21:00,179 --> 00:21:08,039
AP tables and so in conclusion I'm

00:21:05,760 --> 00:21:11,100
saying nothing new but we think xD P is

00:21:08,039 --> 00:21:13,169
great for two reasons first speed

00:21:11,100 --> 00:21:15,179
because we are back at dropping packets

00:21:13,169 --> 00:21:17,820
at the lowest possible layer with

00:21:15,179 --> 00:21:20,340
basically virtually no cost in dropping

00:21:17,820 --> 00:21:22,950
them because the packet buffers are just

00:21:20,340 --> 00:21:25,049
recycle and another important thing is

00:21:22,950 --> 00:21:28,860
safety because we can run C code in

00:21:25,049 --> 00:21:30,779
kernel space with guarantees about the

00:21:28,860 --> 00:21:34,350
program termination and memory safety

00:21:30,779 --> 00:21:36,809
safety guarantees we don't have yet

00:21:34,350 --> 00:21:40,139
benchmarks about xep because there is no

00:21:36,809 --> 00:21:43,070
support for the drivers for our NICs but

00:21:40,139 --> 00:21:45,779
we are looking forward to start

00:21:43,070 --> 00:21:50,730
benchmarking as soon as the driver will

00:21:45,779 --> 00:21:56,309
be available and that's all from me so

00:21:50,730 --> 00:21:58,559
questions yes so I like first of all I

00:21:56,309 --> 00:21:59,970
want to congratulate you on being bold

00:21:58,559 --> 00:22:01,620
enough to take on a new piece of

00:21:59,970 --> 00:22:03,570
technology like this and try to use it

00:22:01,620 --> 00:22:05,580
on such a grand scale so that's I think

00:22:03,570 --> 00:22:07,260
you guys should get a round of applause

00:22:05,580 --> 00:22:11,089
for taking our next video

00:22:07,260 --> 00:22:11,089
[Applause]

00:22:11,330 --> 00:22:16,260
so one thing we're looking at in the

00:22:14,070 --> 00:22:21,510
future that will be interesting for you

00:22:16,260 --> 00:22:23,100
guys is I don't want it just to test xdt

00:22:21,510 --> 00:22:24,540
and see if it works properly I don't

00:22:23,100 --> 00:22:27,030
want people to reacquire to use specific

00:22:24,540 --> 00:22:28,500
NIC cards or anything like that so I at

00:22:27,030 --> 00:22:29,940
some point I want to add a generic hook

00:22:28,500 --> 00:22:32,280
in the code path somewhere so that we

00:22:29,940 --> 00:22:33,540
can just you can just see if x2d works

00:22:32,280 --> 00:22:35,580
it won't be optimal won't be the most

00:22:33,540 --> 00:22:36,720
highest performing solution but I know a

00:22:35,580 --> 00:22:38,160
lot of people are going to run into your

00:22:36,720 --> 00:22:40,860
situation with the mix that you have

00:22:38,160 --> 00:22:42,360
don't support XTP yet so thanks for

00:22:40,860 --> 00:22:51,230
bringing it up that was a really good

00:22:42,360 --> 00:22:54,420
point to make so thank you yes okay um

00:22:51,230 --> 00:22:57,300
did you say you said that the lower a

00:22:54,420 --> 00:22:59,490
place to do the drop is the HCP program

00:22:57,300 --> 00:23:02,040
did you considering do it using the

00:22:59,490 --> 00:23:08,250
hardware like using the TCP skip

00:23:02,040 --> 00:23:11,870
software or we didn't consider using the

00:23:08,250 --> 00:23:14,370
order because with so currently our

00:23:11,870 --> 00:23:17,940
servers are using solar flare cuts and

00:23:14,370 --> 00:23:21,800
so we were using previously the SPI API

00:23:17,940 --> 00:23:24,390
but XTP look like the easiest way to

00:23:21,800 --> 00:23:27,240
achieve better performance for our

00:23:24,390 --> 00:23:28,950
current setup okay because you can do

00:23:27,240 --> 00:23:31,890
most of the classification that you're

00:23:28,950 --> 00:23:33,750
doing index in the ebk program inside

00:23:31,890 --> 00:23:35,460
the hardware you can drop the counter to

00:23:33,750 --> 00:23:37,710
you can drop the packet you can count it

00:23:35,460 --> 00:23:39,870
and you could mark it if you want to do

00:23:37,710 --> 00:23:43,040
it to get it to user space it doesn't

00:23:39,870 --> 00:23:43,040
have unique that's why

00:23:44,010 --> 00:23:51,000
is he you're using so lovely so awful I

00:23:50,279 --> 00:23:54,870
can't do that

00:23:51,000 --> 00:23:57,929
that's Mellanox in tow everybody was

00:23:54,870 --> 00:23:59,700
doing TC of all can do this natural now

00:23:57,929 --> 00:24:14,190
then you can run XD pinion hardware and

00:23:59,700 --> 00:24:16,470
they can do XD p2 so and solitaire 2 2 2

00:24:14,190 --> 00:24:19,799
2 marking the packet if you want to

00:24:16,470 --> 00:24:23,010
sample it one idea is also to use to the

00:24:19,799 --> 00:24:24,929
perf infrastructure to use that as we

00:24:23,010 --> 00:24:27,090
create a perfect sample buffer and

00:24:24,929 --> 00:24:29,580
actually think that spaniels idea that

00:24:27,090 --> 00:24:30,779
that because in this case you don't care

00:24:29,580 --> 00:24:33,179
about the latency of there so we can

00:24:30,779 --> 00:24:35,519
delay these sample packets so we'll use

00:24:33,179 --> 00:24:37,679
the perfect infrastructure to to to to

00:24:35,519 --> 00:24:39,419
to put just your your pet the pegs you

00:24:37,679 --> 00:24:41,669
want to sample in and you can have a

00:24:39,419 --> 00:24:44,340
user space program pulling this out from

00:24:41,669 --> 00:24:50,940
from the perf infrastructure and it

00:24:44,340 --> 00:24:55,440
should be quite fast but can I access

00:24:50,940 --> 00:24:55,980
the perfect system from an excipient yes

00:24:55,440 --> 00:24:57,980
I think so

00:24:55,980 --> 00:25:01,380
Daniel is nothing and I think he edited

00:24:57,980 --> 00:25:02,909
so you can do that and the good thing

00:25:01,380 --> 00:25:05,340
about it is although you you also get

00:25:02,909 --> 00:25:07,730
notification is if you try to include

00:25:05,340 --> 00:25:11,070
something to Perth and there's not room

00:25:07,730 --> 00:25:13,529
do you'll get information about that in

00:25:11,070 --> 00:25:15,330
industry that some packets from missed

00:25:13,529 --> 00:25:24,990
so you know if they use space program

00:25:15,330 --> 00:25:27,659
got to slow of sampling this okay so in

00:25:24,990 --> 00:25:31,320
examples you showed it seems like they

00:25:27,659 --> 00:25:33,210
were for one dot signature at a time I'm

00:25:31,320 --> 00:25:37,260
wondering if you have multiple cases

00:25:33,210 --> 00:25:39,419
where there's multiple problems and if

00:25:37,260 --> 00:25:41,130
you're hitting the limit say the bps

00:25:39,419 --> 00:25:43,590
limit I believe is 4k has that been an

00:25:41,130 --> 00:25:46,710
issue sorry can you repeat the question

00:25:43,590 --> 00:25:49,019
so in the examples you showed they were

00:25:46,710 --> 00:25:53,340
seemed like it was one for one dog

00:25:49,019 --> 00:25:54,279
mature at a time like one domain being

00:25:53,340 --> 00:25:56,859
dosed

00:25:54,279 --> 00:25:59,729
or the saint's attack and I'm wondering

00:25:56,859 --> 00:26:03,519
how do you combine multiple attacks and

00:25:59,729 --> 00:26:05,259
into a single mitigation and whether or

00:26:03,519 --> 00:26:07,419
not we're hitting the limits of BPF

00:26:05,259 --> 00:26:09,849
furtively like a 4k instructions that

00:26:07,419 --> 00:26:11,409
makes your next EP would be I thought

00:26:09,849 --> 00:26:15,219
about that and they don't think we are

00:26:11,409 --> 00:26:17,219
going to hit the 4k limitations for for

00:26:15,219 --> 00:26:26,200
an immediate program that seems unlikely

00:26:17,219 --> 00:26:29,169
so do you do the upper poke into the

00:26:26,200 --> 00:26:32,619
packet or or most of your VPS kind of

00:26:29,169 --> 00:26:39,519
just look at the headers as we're sorry

00:26:32,619 --> 00:26:42,190
okay the question is do you do you ever

00:26:39,519 --> 00:26:43,899
poke deeper into the jackets or do your

00:26:42,190 --> 00:26:45,299
dirt programs just look at the package

00:26:43,899 --> 00:26:49,440
headers

00:26:45,299 --> 00:26:49,440
I'm not following

00:26:50,609 --> 00:27:00,249
yes we inspect all the belayer for data

00:26:54,789 --> 00:27:02,200
of a packet I think we're gonna we're

00:27:00,249 --> 00:27:05,769
gonna put gilberto at the penalty box

00:27:02,200 --> 00:27:07,809
over here there's a gift way thank you

00:27:05,769 --> 00:27:09,010
thank you let's give it up wonderful

00:27:07,809 --> 00:27:09,470
pose

00:27:09,010 --> 00:27:14,339
[Music]

00:27:09,470 --> 00:27:14,339

YouTube URL: https://www.youtube.com/watch?v=7OuOukmuivg


