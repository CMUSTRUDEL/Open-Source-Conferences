Title: Netdev 2.1 XDP for the Rest of Us By Andy Gospodarek + Jesper Dangaard Brouer
Publication date: 2017-06-03
Playlist: Netdev 2.1
Description: 
	XDP is an alternative approach to DPDK that runs within the Linux Kernel.
Learning to use XDP can feel like a fairly steep learning curve. Andy Gospodarek and Jesper Dangaard Brouer  try to flatten that learning curve in this introductory tutorial. The tutorial given on  2017/April  the 7th at Netdev 2.1 in Montreal is intended to provide clarity to kernel developers, sysadmins, or anyone with DevOps responsibilities.

Content: https://www.netdevconf.org/2.1/session.html?gospodarek
Captions: 
	00:00:00,000 --> 00:00:15,860
they did we'll do this soon he's working

00:00:05,910 --> 00:00:15,860
for a Jamaat Costa

00:00:32,220 --> 00:00:42,500
was that timer the timer actually gonna

00:00:34,739 --> 00:00:42,500
run yeah okay you took a quick selfie

00:00:54,629 --> 00:00:58,460
he's taking a break apparently

00:01:38,149 --> 00:01:42,680
right now yeah gosh off the t-shirt

00:01:54,200 --> 00:01:58,610
alright seems like we can go ahead and

00:01:55,790 --> 00:02:03,200
get started so I'm Andy gospel dark

00:01:58,610 --> 00:02:06,140
yeah I'm desperate and I'm with Broadcom

00:02:03,200 --> 00:02:08,330
yes his red hat we're here just kind of

00:02:06,140 --> 00:02:09,200
talking about a next EP application that

00:02:08,330 --> 00:02:11,690
we've worked on

00:02:09,200 --> 00:02:13,370
yes we laid down the framework I had a

00:02:11,690 --> 00:02:15,140
really similar interest so in a true

00:02:13,370 --> 00:02:16,459
open source way I abandoned all the code

00:02:15,140 --> 00:02:18,770
I was writing and just started hacking

00:02:16,459 --> 00:02:22,970
on his and so we've got a sample

00:02:18,770 --> 00:02:28,430
application full full source available

00:02:22,970 --> 00:02:31,010
we were both motivated by like we sat

00:02:28,430 --> 00:02:34,250
down I looked at this EP 8 this BPF

00:02:31,010 --> 00:02:36,769
stuff and they just hard to like figure

00:02:34,250 --> 00:02:38,300
out so we thought maybe other people

00:02:36,769 --> 00:02:43,130
also like have a hard time getting

00:02:38,300 --> 00:02:44,989
getting started using DPF and so we sat

00:02:43,130 --> 00:02:47,150
down and say ok let's try to make this a

00:02:44,989 --> 00:02:50,269
little bit easier right the sample

00:02:47,150 --> 00:02:52,160
application now we want to teach people

00:02:50,269 --> 00:02:53,720
right and try and we're willing to share

00:02:52,160 --> 00:02:54,980
it with you no matter how bad it is that

00:02:53,720 --> 00:02:58,670
we both talked about how bad we are at

00:02:54,980 --> 00:03:01,459
user interfaces so you can laugh it's

00:02:58,670 --> 00:03:03,049
fine so some of the motivation to you

00:03:01,459 --> 00:03:04,579
know xdp is still pretty new despite

00:03:03,049 --> 00:03:06,110
there being a lot of talks about it at

00:03:04,579 --> 00:03:09,070
the conference and other places that's

00:03:06,110 --> 00:03:11,000
been a popular net dev topic for a while

00:03:09,070 --> 00:03:14,030
but a lot of the discussion is focused

00:03:11,000 --> 00:03:15,200
around like data center use cases or you

00:03:14,030 --> 00:03:16,850
know often with expensive nickk nickk

00:03:15,200 --> 00:03:19,940
hardware or you know pretty beefy

00:03:16,850 --> 00:03:21,890
processors but there's also obviously a

00:03:19,940 --> 00:03:24,799
lot of benefits to DDoS prevention on

00:03:21,890 --> 00:03:27,610
lower lower end systems maybe not the

00:03:24,799 --> 00:03:31,250
most expensive thing you can find and

00:03:27,610 --> 00:03:33,650
thankfully there's alternative hardware

00:03:31,250 --> 00:03:36,890
supports x86 and arm and so we had a

00:03:33,650 --> 00:03:38,329
chance to demonstrate both of those both

00:03:36,890 --> 00:03:40,400
of those architectures and some of the

00:03:38,329 --> 00:03:41,660
nicks that are available there

00:03:40,400 --> 00:03:43,220
the other goal too is to think about

00:03:41,660 --> 00:03:47,810
there's a pretty limited set right now

00:03:43,220 --> 00:03:49,700
of drivers that have support so maybe

00:03:47,810 --> 00:03:51,079
hopefully if you're if you're a driver

00:03:49,700 --> 00:03:53,030
maintainer and you're not thinking about

00:03:51,079 --> 00:03:55,670
it you can start thinking about it as

00:03:53,030 --> 00:03:58,100
you can see here that we put the example

00:03:55,670 --> 00:03:59,299
code up on github because this is

00:03:58,100 --> 00:04:01,549
basically what everybody does today

00:03:59,299 --> 00:04:03,890
right they they find some some example

00:04:01,549 --> 00:04:06,379
code and github and just get clones this

00:04:03,890 --> 00:04:06,630
and run it without like checking in this

00:04:06,379 --> 00:04:09,000
thing

00:04:06,630 --> 00:04:11,010
right so this is basic the model so

00:04:09,000 --> 00:04:12,600
they'd have to run to poke on this route

00:04:11,010 --> 00:04:14,250
by that people and I think people are

00:04:12,600 --> 00:04:15,480
just fun stuff people just seem to enjoy

00:04:14,250 --> 00:04:18,690
running anything from you know people

00:04:15,480 --> 00:04:20,640
just want a quick example code that just

00:04:18,690 --> 00:04:23,430
works so that's what we try to do just

00:04:20,640 --> 00:04:26,580
put it out there and people can download

00:04:23,430 --> 00:04:27,900
the stuff and see what what happens

00:04:26,580 --> 00:04:29,730
that's right so initially what we've got

00:04:27,900 --> 00:04:31,590
support for is a sort of a non

00:04:29,730 --> 00:04:33,840
interactive program so it runs and runs

00:04:31,590 --> 00:04:35,520
in the background which is the case is

00:04:33,840 --> 00:04:38,220
everything xpp but there's no user

00:04:35,520 --> 00:04:39,900
interface program that runs at the same

00:04:38,220 --> 00:04:42,030
time right now sort of differentiates it

00:04:39,900 --> 00:04:43,980
from some of the internal kernel tree

00:04:42,030 --> 00:04:47,040
programs right now filters on source IP

00:04:43,980 --> 00:04:49,860
address and destination UDP and or TCP

00:04:47,040 --> 00:04:52,710
ports so it's basically the most simple

00:04:49,860 --> 00:04:54,720
like blacklist implementation right so

00:04:52,710 --> 00:04:57,060
that's also to keep it simple to use

00:04:54,720 --> 00:04:59,790
case it's not an advanced denial of

00:04:57,060 --> 00:05:01,800
service protection detection mechanism

00:04:59,790 --> 00:05:04,020
it's just really simple like you would

00:05:01,800 --> 00:05:06,300
block you're not normal IP tables

00:05:04,020 --> 00:05:08,550
there's also makes it comparable like to

00:05:06,300 --> 00:05:10,530
other tables if you just drop that right

00:05:08,550 --> 00:05:12,330
there's a single single command to add

00:05:10,530 --> 00:05:16,380
something or single command to remove

00:05:12,330 --> 00:05:19,530
something from the list so just kind of

00:05:16,380 --> 00:05:21,600
as a as a little demonstration of the

00:05:19,530 --> 00:05:24,570
output you have a few IP addresses and

00:05:21,600 --> 00:05:27,060
the data after it is blocked a few ports

00:05:24,570 --> 00:05:28,250
and the protocol and the drop traffic

00:05:27,060 --> 00:05:30,360
from each one

00:05:28,250 --> 00:05:32,370
yes we're and I are debating as to

00:05:30,360 --> 00:05:34,320
whether or not this is valid JSON we

00:05:32,370 --> 00:05:36,510
don't I think that going to change it

00:05:34,320 --> 00:05:40,140
yeah I'm about to work on this a little

00:05:36,510 --> 00:05:41,220
bit but either way I'm sort of the idea

00:05:40,140 --> 00:05:43,260
that this should also be machine

00:05:41,220 --> 00:05:44,700
parsable into the output you have if you

00:05:43,260 --> 00:05:45,960
want to quickly quickly figure that out

00:05:44,700 --> 00:05:50,430
so we sort of baked that in from the

00:05:45,960 --> 00:05:53,130
start and also we've got some real-time

00:05:50,430 --> 00:05:54,210
stats that are available got very

00:05:53,130 --> 00:05:56,120
similar to the stuff that that's

00:05:54,210 --> 00:05:59,670
happened before this is just a random

00:05:56,120 --> 00:06:01,410
small sample I had on a system so

00:05:59,670 --> 00:06:02,880
clearly a number of packets that are

00:06:01,410 --> 00:06:04,890
being dropped number that are passing so

00:06:02,880 --> 00:06:07,110
we've got a couple a couple frames in

00:06:04,890 --> 00:06:09,600
this one what kind of system is this

00:06:07,110 --> 00:06:12,120
this was a like a low-end x86 okay

00:06:09,600 --> 00:06:13,920
nothing nothing too crazy and just a

00:06:12,120 --> 00:06:16,919
simple tank low in ten gig NIC

00:06:13,920 --> 00:06:17,910
nothing nothing new or fancy explain

00:06:16,919 --> 00:06:20,810
what

00:06:17,910 --> 00:06:25,260
the ten of us a little low here genic

00:06:20,810 --> 00:06:27,630
what is the neck technique what is it

00:06:25,260 --> 00:06:30,060
not in this case this was a Broadcom

00:06:27,630 --> 00:06:34,080
nick driven by the B NXT driver support

00:06:30,060 --> 00:06:36,120
six xbp already yeah okay okay thanks

00:06:34,080 --> 00:06:38,130
I think they have a slide on what's when

00:06:36,120 --> 00:06:39,930
you're studying for I do okay so that's

00:06:38,130 --> 00:06:42,960
just a little taste of what we're

00:06:39,930 --> 00:06:45,240
talking about so haha so now how can I

00:06:42,960 --> 00:06:46,920
get started there's been a lot of I want

00:06:45,240 --> 00:06:48,450
to burn through these beginning slides

00:06:46,920 --> 00:06:51,270
but I did want to provide a little bit

00:06:48,450 --> 00:06:54,530
of kind of fundamentals on xbp or EVP F

00:06:51,270 --> 00:06:56,280
just for those watching from home or

00:06:54,530 --> 00:06:57,990
realistically the funny part is there's

00:06:56,280 --> 00:06:59,400
so many these slides will appear online

00:06:57,990 --> 00:07:00,630
we sort of felt like it's good to put a

00:06:59,400 --> 00:07:02,480
little bit of extra information in there

00:07:00,630 --> 00:07:08,340
for people that read this after the fact

00:07:02,480 --> 00:07:12,570
so BPF is old circa 1992 EBP F a little

00:07:08,340 --> 00:07:13,950
bit newer circa 2014 so programs are

00:07:12,570 --> 00:07:15,570
small they have restrictions I don't

00:07:13,950 --> 00:07:16,770
want to go into all the details I think

00:07:15,570 --> 00:07:18,480
it was even discussed yesterday so

00:07:16,770 --> 00:07:22,260
people probably know 4k instructions

00:07:18,480 --> 00:07:24,180
lots of other things and the primary

00:07:22,260 --> 00:07:26,400
interaction with the outside world is

00:07:24,180 --> 00:07:29,250
sort of a generic key value store people

00:07:26,400 --> 00:07:31,110
refer to as an EP PF map and by the way

00:07:29,250 --> 00:07:32,820
I'm going to say try not to say EBP eff

00:07:31,110 --> 00:07:34,620
too much because it's amazingly kind of

00:07:32,820 --> 00:07:39,180
a mouthful so if I say BPF just know

00:07:34,620 --> 00:07:43,530
it's the same and there's a whole bunch

00:07:39,180 --> 00:07:45,000
of different key store make map types at

00:07:43,530 --> 00:07:46,800
least a dozen right now is pretty

00:07:45,000 --> 00:07:48,270
regularly growing lots of people are

00:07:46,800 --> 00:07:49,710
making optimizations to them alexei

00:07:48,270 --> 00:07:52,650
posted some optimizations to one of the

00:07:49,710 --> 00:07:55,070
most popular ones maybe two weeks ago so

00:07:52,650 --> 00:07:58,860
lots of things are happening

00:07:55,070 --> 00:08:02,550
it's exciting an xdp sort of think about

00:07:58,860 --> 00:08:05,580
what that is so it's again an extension

00:08:02,550 --> 00:08:06,630
of EBP F to run directly like within a

00:08:05,580 --> 00:08:08,760
nick

00:08:06,630 --> 00:08:10,110
the idea is to operate before the sk b

00:08:08,760 --> 00:08:11,790
is allocated not always the case

00:08:10,110 --> 00:08:14,850
depending on how your your driver is

00:08:11,790 --> 00:08:17,160
implemented there's three key results

00:08:14,850 --> 00:08:19,680
that we think about with XB p today so

00:08:17,160 --> 00:08:21,540
drop transmit either with or without

00:08:19,680 --> 00:08:24,540
modification depending on what your BP f

00:08:21,540 --> 00:08:25,610
program does and then pass back to the

00:08:24,540 --> 00:08:27,680
kernel stack

00:08:25,610 --> 00:08:30,710
for continued process yeah and what what

00:08:27,680 --> 00:08:34,159
the point is programmable so that's we

00:08:30,710 --> 00:08:36,409
allow the users to to add a small

00:08:34,159 --> 00:08:38,510
program all the way down in the in the

00:08:36,409 --> 00:08:42,919
driver and that creates incredible

00:08:38,510 --> 00:08:44,480
flexibility that's right alright so if

00:08:42,919 --> 00:08:46,100
you want to get started here's sort of

00:08:44,480 --> 00:08:47,390
the things to think about

00:08:46,100 --> 00:08:48,800
clearly you start to look at these

00:08:47,390 --> 00:08:52,540
numbers for kernel versions and realize

00:08:48,800 --> 00:08:54,950
this is pretty new xdp and for eight

00:08:52,540 --> 00:08:57,890
you know Mellanox added support in for

00:08:54,950 --> 00:09:00,079
eight and four nine four do two

00:08:57,890 --> 00:09:02,570
different drivers QLogic caveum and four

00:09:00,079 --> 00:09:06,740
ten verdi o-net and 4:10 metronome in

00:09:02,570 --> 00:09:08,480
410 and Broadcom vxt and added in 411 so

00:09:06,740 --> 00:09:09,920
pretty new stuff so we've got to have

00:09:08,480 --> 00:09:13,810
some some comfort running an upstream

00:09:09,920 --> 00:09:16,040
kernel or if you have the opportunity

00:09:13,810 --> 00:09:18,440
put over 25 I think some of the the

00:09:16,040 --> 00:09:21,200
things there's a good chance that the

00:09:18,440 --> 00:09:23,390
next the next version of a bun to that

00:09:21,200 --> 00:09:26,329
that's coming out very soon I didn't

00:09:23,390 --> 00:09:29,480
check should work other requirements to

00:09:26,329 --> 00:09:31,399
be rolling your own J confirmed okay we

00:09:29,480 --> 00:09:35,630
talked before in thanks so for over 25

00:09:31,399 --> 00:09:38,149
or 17 16:10 thank you

00:09:35,630 --> 00:09:40,010
well both works that's a good start you

00:09:38,149 --> 00:09:42,019
don't have to roll your own I have built

00:09:40,010 --> 00:09:44,839
LLVM and clang it's not that hard

00:09:42,019 --> 00:09:46,519
they're great instructions nonetheless

00:09:44,839 --> 00:09:47,660
it's easier if you can get to get

00:09:46,519 --> 00:09:53,269
started with something like this if

00:09:47,660 --> 00:09:54,410
you've got a good base alright the other

00:09:53,269 --> 00:09:56,510
thing to think about is there's sort of

00:09:54,410 --> 00:09:58,720
three samples that are out there right

00:09:56,510 --> 00:10:01,370
now in the kernel tree in samples BPF

00:09:58,720 --> 00:10:02,600
these are great things to you know have

00:10:01,370 --> 00:10:03,649
some familiarity with before you get

00:10:02,600 --> 00:10:06,170
started

00:10:03,649 --> 00:10:08,180
gives you just a good head start so xdp

00:10:06,170 --> 00:10:09,890
one really simple just drops all the

00:10:08,180 --> 00:10:11,120
frames to come in has a nice counter

00:10:09,890 --> 00:10:14,690
that prints on the screen while you're

00:10:11,120 --> 00:10:16,130
running it XD be to just swaps the

00:10:14,690 --> 00:10:18,769
source and decimal dresses and

00:10:16,130 --> 00:10:21,920
retransmits on the same interface again

00:10:18,769 --> 00:10:24,079
these are not amazing amazing things but

00:10:21,920 --> 00:10:25,430
it's great to see how this works and

00:10:24,079 --> 00:10:27,890
should have some familiarity before you

00:10:25,430 --> 00:10:29,630
get going then X pptx IP tunnel it's a

00:10:27,890 --> 00:10:30,890
little more complicated matches the

00:10:29,630 --> 00:10:33,740
source and destination IP that you

00:10:30,890 --> 00:10:36,110
specify does some in cap and retransmits

00:10:33,740 --> 00:10:38,370
if that run is basically a sample of

00:10:36,110 --> 00:10:41,970
what Facebook is doing for

00:10:38,370 --> 00:10:43,560
dancing there you go so so these are

00:10:41,970 --> 00:10:44,970
good good things to get started with you

00:10:43,560 --> 00:10:46,800
don't have to write your own program if

00:10:44,970 --> 00:10:49,080
you want to run this and test it on any

00:10:46,800 --> 00:10:50,850
NIC that supports it or if you're doing

00:10:49,080 --> 00:10:53,970
the development on a new NIC you can use

00:10:50,850 --> 00:10:55,230
those other thing to think about it's

00:10:53,970 --> 00:10:56,610
either these are broken down because

00:10:55,230 --> 00:10:58,890
this is kind of the same model we

00:10:56,610 --> 00:11:01,200
followed with ours you end up with the e

00:10:58,890 --> 00:11:03,540
b PF code and map definitions in a file

00:11:01,200 --> 00:11:06,240
that's just underscore current dot C in

00:11:03,540 --> 00:11:09,450
this case I just reference it is who and

00:11:06,240 --> 00:11:10,800
the output of that is created by LVM and

00:11:09,450 --> 00:11:13,589
clang and you end up with a foo

00:11:10,800 --> 00:11:15,330
underscore current oh the cool thing

00:11:13,589 --> 00:11:17,460
about this is it's pretty portable it

00:11:15,330 --> 00:11:20,400
doesn't contain any shouldn't contain

00:11:17,460 --> 00:11:22,380
any code that's native to your your

00:11:20,400 --> 00:11:26,370
architecture so example I can compile I

00:11:22,380 --> 00:11:28,350
can make food current Oh on an x86 and

00:11:26,370 --> 00:11:30,270
actually move that file just that file

00:11:28,350 --> 00:11:31,589
directly over to an arm system if I want

00:11:30,270 --> 00:11:34,650
and as long as I've compiled the

00:11:31,589 --> 00:11:38,160
supporting user space code with GCC

00:11:34,650 --> 00:11:38,460
native to that architecture it just

00:11:38,160 --> 00:11:40,980
works

00:11:38,460 --> 00:11:42,300
it's kind of neat unsurprising when you

00:11:40,980 --> 00:11:45,959
start breaking down the file and to see

00:11:42,300 --> 00:11:47,970
what it looks like so in the user space

00:11:45,959 --> 00:11:49,400
code that does most of the loading maybe

00:11:47,970 --> 00:11:51,630
does some app interaction

00:11:49,400 --> 00:11:54,600
statistics gathering stuff word to say

00:11:51,630 --> 00:11:57,300
apparently it's all in who user dot o

00:11:54,600 --> 00:11:58,589
and ultimately compiled in this case in

00:11:57,300 --> 00:12:00,470
the kernel something that would just be

00:11:58,589 --> 00:12:02,730
called foo

00:12:00,470 --> 00:12:05,279
so for those that are visual learners I

00:12:02,730 --> 00:12:08,279
managed to find a nice graphic stolen

00:12:05,279 --> 00:12:10,800
from somewhere else and you can sort of

00:12:08,279 --> 00:12:12,959
see how this interaction happens who

00:12:10,800 --> 00:12:16,830
user has I think I have some cool sort

00:12:12,959 --> 00:12:18,959
of laser pointer here yeah so the e BPF

00:12:16,830 --> 00:12:22,080
code contains the byte code and the maps

00:12:18,959 --> 00:12:24,410
and what we end up with is user space

00:12:22,080 --> 00:12:27,209
code reads and interacts with these maps

00:12:24,410 --> 00:12:30,450
user space code also low with the

00:12:27,209 --> 00:12:31,650
original loader of this code and this

00:12:30,450 --> 00:12:32,940
part will just ignore because that was

00:12:31,650 --> 00:12:35,700
just something else I just didn't blank

00:12:32,940 --> 00:12:37,260
it out of a slide but this kind of gives

00:12:35,700 --> 00:12:43,110
you a picture of where things live so

00:12:37,260 --> 00:12:45,170
ebps byte code and maps all inside you

00:12:43,110 --> 00:12:47,250
know the ultimately originally in Fuko

00:12:45,170 --> 00:12:49,940
loaded by user space user space

00:12:47,250 --> 00:12:51,959
interacts seems pretty straightforward

00:12:49,940 --> 00:12:52,390
although it's amazing how long it takes

00:12:51,959 --> 00:12:54,130
to sort

00:12:52,390 --> 00:12:58,600
get a grasp of how this all works the

00:12:54,130 --> 00:13:00,910
first time here you're exposed to it all

00:12:58,600 --> 00:13:03,910
right so enough talking let's see how

00:13:00,910 --> 00:13:05,860
this thing actually works so we as I

00:13:03,910 --> 00:13:07,350
mentioned kind of a similar split it's

00:13:05,860 --> 00:13:10,600
what we had before

00:13:07,350 --> 00:13:13,000
currency map definitions restricted EB

00:13:10,600 --> 00:13:16,779
PF restricted see that'll be compiled

00:13:13,000 --> 00:13:18,730
into byte code user the user space code

00:13:16,779 --> 00:13:20,649
that that actually loads it now in our

00:13:18,730 --> 00:13:22,959
case the differentiator between the

00:13:20,649 --> 00:13:25,300
existing XDP programs is this one loads

00:13:22,959 --> 00:13:27,130
and exits goes away and that's that

00:13:25,300 --> 00:13:29,230
program had to be run as root that's

00:13:27,130 --> 00:13:31,570
right to be able to load to program but

00:13:29,230 --> 00:13:34,029
what we did is there's also that the

00:13:31,570 --> 00:13:36,760
command line version and that actually

00:13:34,029 --> 00:13:39,100
can be run as as as a normal user and

00:13:36,760 --> 00:13:40,959
the whole trick is that I only need to

00:13:39,100 --> 00:13:42,310
interact with the treaty's Maps after

00:13:40,959 --> 00:13:45,399
loading the program I only need to

00:13:42,310 --> 00:13:47,620
interact with the PPF maps and take it

00:13:45,399 --> 00:13:49,630
exported to the filesystem and it is

00:13:47,620 --> 00:13:52,410
really simple I change the owner of the

00:13:49,630 --> 00:13:55,360
file and then then I can actually

00:13:52,410 --> 00:13:57,640
interact whereas a normal user so that's

00:13:55,360 --> 00:13:59,440
a parameter you give to the program run

00:13:57,640 --> 00:14:01,570
this route but what you want to change

00:13:59,440 --> 00:14:03,760
the file that the owner of the file into

00:14:01,570 --> 00:14:06,279
and afterwards you can have drawn a set

00:14:03,760 --> 00:14:08,949
route a test at user at the command line

00:14:06,279 --> 00:14:11,920
tool and in fact BPF as a normal user so

00:14:08,949 --> 00:14:14,199
that's like a cheap split security model

00:14:11,920 --> 00:14:18,850
as we are always known it from from your

00:14:14,199 --> 00:14:19,870
nation all right so let's kind of dive

00:14:18,850 --> 00:14:21,519
into this a little bit

00:14:19,870 --> 00:14:24,820
oh and obviously the command line code

00:14:21,519 --> 00:14:27,100
as Jesper said it you know just nice

00:14:24,820 --> 00:14:31,209
interactions with the system fest files

00:14:27,100 --> 00:14:33,370
that we've linked back to VPS maps we

00:14:31,209 --> 00:14:35,620
had to add something it was confusing so

00:14:33,370 --> 00:14:40,600
all right of course standard disclaimer

00:14:35,620 --> 00:14:42,130
applies here you'll probably notice bugs

00:14:40,600 --> 00:14:43,329
I wish I had some like swag to throw

00:14:42,130 --> 00:14:44,649
people I thought maybe throwing chips

00:14:43,329 --> 00:14:46,329
that people would be a bad idea and

00:14:44,649 --> 00:14:47,500
dangerous in this environment so I

00:14:46,329 --> 00:14:50,339
didn't bring any to give out and throw

00:14:47,500 --> 00:14:52,360
at people but yeah let's take a look all

00:14:50,339 --> 00:14:53,560
right so we kind of break down the files

00:14:52,360 --> 00:14:54,670
and just talk about the different

00:14:53,560 --> 00:14:58,750
functions that are in each and I can

00:14:54,670 --> 00:15:00,160
look at either screen so the things to

00:14:58,750 --> 00:15:03,170
think about they're significant I try to

00:15:00,160 --> 00:15:06,499
highlight this is initial map definition

00:15:03,170 --> 00:15:08,329
I don't want to go through the entire

00:15:06,499 --> 00:15:09,679
man page so I'm not going to go over all

00:15:08,329 --> 00:15:13,309
the different options that are available

00:15:09,679 --> 00:15:14,779
for your map type in our case what we

00:15:13,309 --> 00:15:17,589
can indicate that we chose was the first

00:15:14,779 --> 00:15:19,519
CPU hash so it's a hash list per CPU

00:15:17,589 --> 00:15:21,949
unsurprising there's a copy of it on

00:15:19,519 --> 00:15:24,049
each CPU that's cool because that means

00:15:21,949 --> 00:15:26,809
you can access it on your CPU so if you

00:15:24,049 --> 00:15:29,329
want to have in our case our key value

00:15:26,809 --> 00:15:30,889
store the value is a drop counter we

00:15:29,329 --> 00:15:32,359
want to be able to accesses drop that

00:15:30,889 --> 00:15:34,549
drop counter without doing any locking

00:15:32,359 --> 00:15:37,220
without doing any synchronization to end

00:15:34,549 --> 00:15:39,619
it with a per CPU hash when you go ahead

00:15:37,220 --> 00:15:45,109
if you want yeah and just the key size

00:15:39,619 --> 00:15:48,439
is like 32 bit and that's the our our

00:15:45,109 --> 00:15:49,790
input his dispatch the IP address that's

00:15:48,439 --> 00:15:53,239
where you saw the I predators the trap

00:15:49,790 --> 00:15:54,949
address is our key and and the value is

00:15:53,239 --> 00:15:57,470
just a counter for how many drops we're

00:15:54,949 --> 00:15:59,449
missing there that's right so there's a

00:15:57,470 --> 00:16:02,059
variety of there's a variety of

00:15:59,449 --> 00:16:03,439
different map types available we've said

00:16:02,059 --> 00:16:06,199
in this case the per CPU hash seemed

00:16:03,439 --> 00:16:08,119
like a good choice because our we want

00:16:06,199 --> 00:16:09,829
to optimize for reading and writing

00:16:08,119 --> 00:16:11,600
while packets are coming in that's our

00:16:09,829 --> 00:16:14,089
hot path we don't want optimize for we

00:16:11,600 --> 00:16:15,470
could do a just a type hash it's not for

00:16:14,089 --> 00:16:17,299
CPU but then we'd have to do with the

00:16:15,470 --> 00:16:19,759
synchronization across all CPUs whenever

00:16:17,299 --> 00:16:21,619
updating the counters and just didn't

00:16:19,759 --> 00:16:23,689
want to do that so kind of good to think

00:16:21,619 --> 00:16:25,549
about right what's going to be I think

00:16:23,689 --> 00:16:27,649
they have some examples that because you

00:16:25,549 --> 00:16:29,209
have to post a few thing we put a bit

00:16:27,649 --> 00:16:30,139
more stress on how user space have to

00:16:29,209 --> 00:16:31,369
interact with that's right

00:16:30,139 --> 00:16:33,139
we put the burden on user space we

00:16:31,369 --> 00:16:34,819
figure we polling a lot less I mean as

00:16:33,139 --> 00:16:36,829
you saw we were processing 5 or 6

00:16:34,819 --> 00:16:38,179
million packets per second not not

00:16:36,829 --> 00:16:39,889
polling I'm not checking the stats 5 or

00:16:38,179 --> 00:16:41,689
6 million times per second so yeah so

00:16:39,889 --> 00:16:44,809
useless base half because it's perceive

00:16:41,689 --> 00:16:47,389
you actually have has to do the the

00:16:44,809 --> 00:16:49,039
summing of the trace abusal user space

00:16:47,389 --> 00:16:51,649
we'll see the counters perceive you and

00:16:49,039 --> 00:16:54,110
it has to do some of these counters so

00:16:51,649 --> 00:16:55,730
instead of having yeah it's a balance

00:16:54,110 --> 00:16:59,359
where where you put the complexity and

00:16:55,730 --> 00:17:01,249
the fast path is in the kernel so that's

00:16:59,359 --> 00:17:02,539
right there we go so the other thing is

00:17:01,249 --> 00:17:07,480
every vpf map do you define a

00:17:02,539 --> 00:17:10,279
highlighted online oh that's not good

00:17:07,480 --> 00:17:13,069
there we go much better short

00:17:10,279 --> 00:17:14,990
presentation so on line one you can also

00:17:13,069 --> 00:17:16,819
see that I just labeled the section

00:17:14,990 --> 00:17:18,439
there

00:17:16,819 --> 00:17:21,579
map if you have multiple maps like this

00:17:18,439 --> 00:17:23,870
you can still just call it section maps

00:17:21,579 --> 00:17:25,549
so this doesn't need to change at all

00:17:23,870 --> 00:17:27,289
this is sort of some of the dark art

00:17:25,549 --> 00:17:29,990
that currently exists with some of the

00:17:27,289 --> 00:17:32,029
the BPF programming it's not a problem

00:17:29,990 --> 00:17:33,409
it's just that this is just how it is

00:17:32,029 --> 00:17:37,730
today I mean this is a new technology

00:17:33,409 --> 00:17:39,710
it's emerging at the dissection is a

00:17:37,730 --> 00:17:43,000
little bit doc magic so what happens

00:17:39,710 --> 00:17:46,610
that this just helps when generating the

00:17:43,000 --> 00:17:49,809
doubt profiles right Dale's binary file

00:17:46,610 --> 00:17:52,190
to make it recognizable later for dota

00:17:49,809 --> 00:17:54,019
all right so we've got our map created

00:17:52,190 --> 00:17:55,279
so we talked about for the IP address

00:17:54,019 --> 00:17:58,129
case this is going to be our key value

00:17:55,279 --> 00:17:59,210
store all right so the next thing we do

00:17:58,129 --> 00:18:01,279
is we have to create a function that the

00:17:59,210 --> 00:18:03,529
kernel is going to call and this is the

00:18:01,279 --> 00:18:05,629
function that it will sit there and be

00:18:03,529 --> 00:18:09,500
ready when we attach an x DP program to

00:18:05,629 --> 00:18:13,190
an interface and it's really pretty

00:18:09,500 --> 00:18:15,320
simple line 1 you can see there we just

00:18:13,190 --> 00:18:18,080
define again a section you can put any

00:18:15,320 --> 00:18:19,700
string in there you want I put several

00:18:18,080 --> 00:18:21,830
other words in there just for testing

00:18:19,700 --> 00:18:25,220
earlier and had to change it for the

00:18:21,830 --> 00:18:28,370
purposes of the slide but just to find

00:18:25,220 --> 00:18:30,740
that section it just sort of works it's

00:18:28,370 --> 00:18:32,860
good I don't know if there's an interest

00:18:30,740 --> 00:18:36,440
in in changing the way that that's

00:18:32,860 --> 00:18:38,120
instantiated later but that's key you

00:18:36,440 --> 00:18:40,460
just got to do it

00:18:38,120 --> 00:18:42,620
another couple things to look at line 7

00:18:40,460 --> 00:18:44,720
a highlighted l3 offset in the case

00:18:42,620 --> 00:18:46,490
where where we have a VLAN tag frame or

00:18:44,720 --> 00:18:47,720
a multiple VLAN tag frame or other

00:18:46,490 --> 00:18:50,899
things you'd obviously want to think

00:18:47,720 --> 00:18:52,279
about once you about parsing that so

00:18:50,899 --> 00:18:53,899
we've got to parse each function it's

00:18:52,279 --> 00:18:55,580
going to return the l3 offset so

00:18:53,899 --> 00:18:57,110
something to consider and we've got a

00:18:55,580 --> 00:18:59,870
function handle each protocol I'll go

00:18:57,110 --> 00:19:02,179
into each one of these one of the really

00:18:59,870 --> 00:19:05,769
cool things also to think about if you

00:19:02,179 --> 00:19:08,450
look at line 6 is that because we're

00:19:05,769 --> 00:19:09,889
sort of in the kernel tree and we're

00:19:08,450 --> 00:19:11,269
including kernel files we can actually

00:19:09,889 --> 00:19:12,620
just use all the existing kernel

00:19:11,269 --> 00:19:14,059
structures or many of the existing

00:19:12,620 --> 00:19:16,009
kernel structures for things so you

00:19:14,059 --> 00:19:18,320
don't have to go reinvent an entire new

00:19:16,009 --> 00:19:20,570
set of structures is egg paste Rock

00:19:18,320 --> 00:19:22,789
teeth header that's there let's use it

00:19:20,570 --> 00:19:26,210
and we'll show you how to use it because

00:19:22,789 --> 00:19:27,350
you have to be careful but this is great

00:19:26,210 --> 00:19:28,580
like we don't have to reinvent

00:19:27,350 --> 00:19:30,500
everything if you're writing a

00:19:28,580 --> 00:19:34,280
standalone application with

00:19:30,500 --> 00:19:36,140
some other interface that had user space

00:19:34,280 --> 00:19:38,600
pulmo drivers for something for example

00:19:36,140 --> 00:19:39,919
that was high-performance networking you

00:19:38,600 --> 00:19:41,480
might have to you know write your own

00:19:39,919 --> 00:19:44,870
structures for everything you don't have

00:19:41,480 --> 00:19:47,330
to do that here all right so we start

00:19:44,870 --> 00:19:50,179
parsing the packets so this is our parse

00:19:47,330 --> 00:19:51,169
eath function what I want to highlight

00:19:50,179 --> 00:19:52,940
it was actually already touched upon

00:19:51,169 --> 00:19:54,200
yesterday with the presentation from

00:19:52,940 --> 00:19:57,409
Facebook it's important to highlight

00:19:54,200 --> 00:19:59,299
again part of what BPF does there's a

00:19:57,409 --> 00:20:05,179
verifier that checks to make sure you're

00:19:59,299 --> 00:20:06,770
following the rules line nine is key if

00:20:05,179 --> 00:20:08,450
you want to access something in that new

00:20:06,770 --> 00:20:12,980
structure you created you have to double

00:20:08,450 --> 00:20:14,270
check that you have space to do it so in

00:20:12,980 --> 00:20:16,789
the first function we had I should have

00:20:14,270 --> 00:20:18,919
mentioned this line four and five we

00:20:16,789 --> 00:20:21,500
pass the data pointer on line five and a

00:20:18,919 --> 00:20:23,419
data end spot in line four

00:20:21,500 --> 00:20:25,760
so what we have to do each time we

00:20:23,419 --> 00:20:28,100
access any data is double check do we

00:20:25,760 --> 00:20:29,990
have space to do this else what happens

00:20:28,100 --> 00:20:31,460
if you forget this that is that when you

00:20:29,990 --> 00:20:33,200
load it into the kernel the kernel will

00:20:31,460 --> 00:20:34,370
reject your program and say right it

00:20:33,200 --> 00:20:36,289
didn't do a boundary Chicks

00:20:34,370 --> 00:20:37,940
so that's actually a nice feature that

00:20:36,289 --> 00:20:40,100
he actually gets that that's right along

00:20:37,940 --> 00:20:41,750
there yeah it's a huge splat you get on

00:20:40,100 --> 00:20:43,370
the screen the first time you see it

00:20:41,750 --> 00:20:45,260
you're like what does that even mean you

00:20:43,370 --> 00:20:46,480
start digging into it you wonder if we

00:20:45,260 --> 00:20:48,830
should just call daniel Borgman

00:20:46,480 --> 00:20:50,360
you decide no i'm not gonna waste his

00:20:48,830 --> 00:20:53,179
time also he's probably asleep right now

00:20:50,360 --> 00:20:54,559
and so you just go ahead and you dig

00:20:53,179 --> 00:20:57,590
into it realized oh I didn't check my

00:20:54,559 --> 00:20:58,669
pointer so everyone will probably make

00:20:57,590 --> 00:21:01,460
that mistake at some point or another

00:20:58,669 --> 00:21:04,669
when writing a packet parsing program

00:21:01,460 --> 00:21:09,080
here in BPF it so important important to

00:21:04,669 --> 00:21:11,210
point out so the next thing to do is

00:21:09,080 --> 00:21:14,059
have this handle each protocol function

00:21:11,210 --> 00:21:16,940
and again we just check to check the

00:21:14,059 --> 00:21:19,280
protocol some cases v6r if we don't care

00:21:16,940 --> 00:21:21,799
default also don't care

00:21:19,280 --> 00:21:23,570
and it's ipv4 since we've got a

00:21:21,799 --> 00:21:24,860
blacklist for ipv4 we're maintaining

00:21:23,570 --> 00:21:27,919
that let's go ahead and check it out

00:21:24,860 --> 00:21:30,590
passing our data data and pointers again

00:21:27,919 --> 00:21:32,570
and our l3 offset and off we will go

00:21:30,590 --> 00:21:35,480
you'll notice in several cases we're

00:21:32,570 --> 00:21:37,610
seeing this return XDP pass you know in

00:21:35,480 --> 00:21:39,080
two spots here so basically if we can't

00:21:37,610 --> 00:21:41,450
figure out what the packet is just let

00:21:39,080 --> 00:21:43,690
it through maybe not the best idea but

00:21:41,450 --> 00:21:45,519
you have to be practical about it

00:21:43,690 --> 00:21:47,169
our case and that's the return code that

00:21:45,519 --> 00:21:48,549
the Colonels going to receive so your

00:21:47,169 --> 00:21:50,409
your net driver or anything else is

00:21:48,549 --> 00:21:52,419
going to see that exact return code

00:21:50,409 --> 00:21:54,549
because that's the end yeah and our code

00:21:52,419 --> 00:21:56,740
is obviously much more verbose and it

00:21:54,549 --> 00:21:58,600
has to be we just included this to show

00:21:56,740 --> 00:22:00,220
that it would be really easy to do a

00:21:58,600 --> 00:22:03,940
switch statement but most of this

00:22:00,220 --> 00:22:07,509
basically compiles out thing right all

00:22:03,940 --> 00:22:09,309
right all right here's our parse ipv4 so

00:22:07,509 --> 00:22:11,289
once again you can see on line 6 we

00:22:09,309 --> 00:22:12,370
could take advantage of cool kernel

00:22:11,289 --> 00:22:14,620
structures that already there

00:22:12,370 --> 00:22:16,480
not a whole lot of extra effort and

00:22:14,620 --> 00:22:18,129
again on line 10 you can see once more

00:22:16,480 --> 00:22:20,409
time we use some cool pointer arithmetic

00:22:18,129 --> 00:22:24,279
there and just double check that we have

00:22:20,409 --> 00:22:25,840
the ability to access that data I just

00:22:24,279 --> 00:22:27,759
want to mention that I bet that trick

00:22:25,840 --> 00:22:31,870
but just plus one is it's just because

00:22:27,759 --> 00:22:33,909
you know see it is 22 plus 1 is the size

00:22:31,870 --> 00:22:36,490
of distrusted you actually moving right

00:22:33,909 --> 00:22:38,259
a lot of people that don't see daily

00:22:36,490 --> 00:22:39,490
maybe not catch that one there you go

00:22:38,259 --> 00:22:41,409
but yeah thank you

00:22:39,490 --> 00:22:42,580
excellent point all right so now here's

00:22:41,409 --> 00:22:44,230
where the rubber meets the road and

00:22:42,580 --> 00:22:45,940
where things get interesting on line 14

00:22:44,230 --> 00:22:48,340
so this is where we actually our first

00:22:45,940 --> 00:22:50,139
call in to our BPF map to see if

00:22:48,340 --> 00:22:52,059
something's there so we just call BPF

00:22:50,139 --> 00:22:54,480
map lookup element and we pass it

00:22:52,059 --> 00:22:57,129
surprise surprise the address of our

00:22:54,480 --> 00:22:58,779
blacklist what we created and what are

00:22:57,129 --> 00:23:01,210
we passing it our IP source that we

00:22:58,779 --> 00:23:05,259
computed on line 12 and what's going to

00:23:01,210 --> 00:23:07,840
return is a pointer and a value and so

00:23:05,259 --> 00:23:09,549
in our case if the value is valid then

00:23:07,840 --> 00:23:14,200
we know there's an entry there in the

00:23:09,549 --> 00:23:16,269
case of a BPF hash map only valid

00:23:14,200 --> 00:23:18,190
entries are populated so if this were an

00:23:16,269 --> 00:23:20,080
array for example value would always

00:23:18,190 --> 00:23:23,139
return something because arrays are

00:23:20,080 --> 00:23:25,029
pre-populated with 0 values so in our

00:23:23,139 --> 00:23:26,860
case because this is a hash we can write

00:23:25,029 --> 00:23:29,529
the code one way for an array we'd write

00:23:26,860 --> 00:23:33,759
it a little bit differently we'd

00:23:29,529 --> 00:23:34,870
actually probably do a if value well it

00:23:33,759 --> 00:23:36,009
depends on what you're storing there and

00:23:34,870 --> 00:23:37,210
then array you might you might show a

00:23:36,009 --> 00:23:41,740
counter you might do or something else

00:23:37,210 --> 00:23:43,720
but either way we just increment it so

00:23:41,740 --> 00:23:46,419
this is a cool thing again right here we

00:23:43,720 --> 00:23:48,519
mentioned that per CPU hashes you don't

00:23:46,419 --> 00:23:52,509
need to do any protection so when we're

00:23:48,519 --> 00:23:54,340
doing this value plus 1 this is only the

00:23:52,509 --> 00:23:57,550
value that's stored in the hash map on

00:23:54,340 --> 00:23:58,840
our currently running CPU not

00:23:57,550 --> 00:24:00,940
is completely safe because we're running

00:23:58,840 --> 00:24:03,040
in epic context and we actually running

00:24:00,940 --> 00:24:03,400
with as you to say to those oh that's

00:24:03,040 --> 00:24:05,710
right

00:24:03,400 --> 00:24:07,270
so we under each scientist right we can

00:24:05,710 --> 00:24:08,860
feel pretty confident what a percent

00:24:07,270 --> 00:24:10,360
confident I guess maybe not you never

00:24:08,860 --> 00:24:13,570
know there's always a room for some some

00:24:10,360 --> 00:24:16,000
failure but uh no we don't have to do

00:24:13,570 --> 00:24:18,160
any sort of milking there that's right

00:24:16,000 --> 00:24:20,620
it's just it works so that's kind of

00:24:18,160 --> 00:24:22,950
cool that's an optimization that we it

00:24:20,620 --> 00:24:25,270
was chosen for this all right

00:24:22,950 --> 00:24:26,800
so now we're to the point where we're

00:24:25,270 --> 00:24:30,150
going to return XDP drop because this

00:24:26,800 --> 00:24:32,170
one got a hit and that's pretty much it

00:24:30,150 --> 00:24:34,630
like the programs aren't complicated

00:24:32,170 --> 00:24:36,220
they're not long I mean this is I don't

00:24:34,630 --> 00:24:38,230
need to remember how long the how long

00:24:36,220 --> 00:24:39,520
it is I probably could have put the real

00:24:38,230 --> 00:24:41,320
line numbers in but it was easier to not

00:24:39,520 --> 00:24:43,480
not do that for the purpose of this

00:24:41,320 --> 00:24:46,210
demonstration but it's pretty short code

00:24:43,480 --> 00:24:48,700
so really the keys for your kernel file

00:24:46,210 --> 00:24:50,740
the file that's going to be loaded as

00:24:48,700 --> 00:24:53,080
you repeat as your EBP F program you

00:24:50,740 --> 00:24:55,570
define a black list you write a function

00:24:53,080 --> 00:24:57,250
that's going to receive your frames if

00:24:55,570 --> 00:25:01,210
you want to you track whether or not the

00:24:57,250 --> 00:25:02,950
frame was good and and if you want to

00:25:01,210 --> 00:25:04,750
keep some stats like said you don't have

00:25:02,950 --> 00:25:05,860
to keep stats but seems like kind of a

00:25:04,750 --> 00:25:08,110
good idea you want to know what your

00:25:05,860 --> 00:25:10,480
program is doing and you report the

00:25:08,110 --> 00:25:12,190
decision back what did we do with it and

00:25:10,480 --> 00:25:14,440
it's the whole point of all this is you

00:25:12,190 --> 00:25:16,570
know doing something yeah that just want

00:25:14,440 --> 00:25:20,920
to mention so one of the key concepts is

00:25:16,570 --> 00:25:22,960
that with HTTP you only write the exact

00:25:20,920 --> 00:25:25,300
code you need to solve your use case and

00:25:22,960 --> 00:25:27,100
then you know that that means that you

00:25:25,300 --> 00:25:29,410
only add the assembler instructions that

00:25:27,100 --> 00:25:32,170
you need this is key to some of the

00:25:29,410 --> 00:25:33,730
performance gain we are seeing so I have

00:25:32,170 --> 00:25:37,000
a very specific use case I want to match

00:25:33,730 --> 00:25:38,440
this blacklist and I only add those that

00:25:37,000 --> 00:25:39,790
gets compiled down to these assembly

00:25:38,440 --> 00:25:41,680
instructions which is much shorter than

00:25:39,790 --> 00:25:44,110
if I had to be generic and you have to

00:25:41,680 --> 00:25:46,120
have such a generic parser and so right

00:25:44,110 --> 00:25:47,440
you don't want to find yourself probably

00:25:46,120 --> 00:25:48,490
in a city you probably don't want to

00:25:47,440 --> 00:25:51,340
find yourself in a situation where

00:25:48,490 --> 00:25:51,970
you're like rewriting you know all of

00:25:51,340 --> 00:25:54,160
netfilter

00:25:51,970 --> 00:25:57,850
in xdp because you want to have this

00:25:54,160 --> 00:25:59,920
this amazingly detailed ability I mean

00:25:57,850 --> 00:26:02,080
we not seen as a replacement it's again

00:25:59,920 --> 00:26:04,360
early drop we want to get rid of these

00:26:02,080 --> 00:26:05,890
things early consume as little CPU as

00:26:04,360 --> 00:26:07,600
possible and only ask the instructions

00:26:05,890 --> 00:26:09,640
you need one and only at the

00:26:07,600 --> 00:26:10,179
instructions really nuts right that's

00:26:09,640 --> 00:26:12,549
right only at

00:26:10,179 --> 00:26:14,679
what you need everything you need

00:26:12,549 --> 00:26:17,710
nothing you want I guess was a joke I

00:26:14,679 --> 00:26:18,789
used to use about a car we had so all

00:26:17,710 --> 00:26:21,309
right so how does this actually attach

00:26:18,789 --> 00:26:24,970
to a net dev that's the next question so

00:26:21,309 --> 00:26:26,379
we'll go into blacklist user dot C so

00:26:24,970 --> 00:26:28,659
this is where a little bit of the the

00:26:26,379 --> 00:26:30,249
sort of black magic exists right now and

00:26:28,659 --> 00:26:31,509
until you get into it and work with it

00:26:30,249 --> 00:26:32,980
and again I don't see that it's a

00:26:31,509 --> 00:26:35,860
problem it's just this is the way it is

00:26:32,980 --> 00:26:37,840
and so you get into it there's a BPF

00:26:35,860 --> 00:26:40,840
library and tools Lib BPF again in the

00:26:37,840 --> 00:26:42,309
kernel tree it's really helpful there's

00:26:40,840 --> 00:26:44,139
a couple variables that are set and are

00:26:42,309 --> 00:26:45,789
accessed especially in the examples that

00:26:44,139 --> 00:26:47,320
until you drill down into it you don't

00:26:45,789 --> 00:26:48,639
you don't realize that that's that's how

00:26:47,320 --> 00:26:50,679
it works

00:26:48,639 --> 00:26:56,190
so we're going to do is typically the

00:26:50,679 --> 00:26:59,139
other examples use load BPF file to set

00:26:56,190 --> 00:27:00,309
to load the program I mean it loads the

00:26:59,139 --> 00:27:01,779
vpf file it's pretty simple

00:27:00,309 --> 00:27:04,389
self-explanatory excellently named

00:27:01,779 --> 00:27:07,749
function one of the two things that it

00:27:04,389 --> 00:27:10,629
does is it loads program D so all the

00:27:07,749 --> 00:27:12,999
entries for all the programs you have

00:27:10,629 --> 00:27:15,429
that we're in that file are populated in

00:27:12,999 --> 00:27:17,110
that array and then map ft aligns the

00:27:15,429 --> 00:27:18,879
maps there's a little bit of manual work

00:27:17,110 --> 00:27:21,190
that has to happen that you need to yeah

00:27:18,879 --> 00:27:24,129
just don't need it like we need annoying

00:27:21,190 --> 00:27:26,259
part that that these map 5 districts

00:27:24,129 --> 00:27:28,659
descriptors yeah they will be in the

00:27:26,259 --> 00:27:30,669
order you've defined that ended right

00:27:28,659 --> 00:27:33,129
and on the scroll criminal that's C file

00:27:30,669 --> 00:27:35,529
that's the only thing you have to has to

00:27:33,129 --> 00:27:38,889
align between right in our case in the

00:27:35,529 --> 00:27:41,139
first are our blacklist since if it was

00:27:38,889 --> 00:27:42,940
the first entry the first section map

00:27:41,139 --> 00:27:45,789
section that we defined it would be map

00:27:42,940 --> 00:27:47,889
FD 0 flat-out but but if you have

00:27:45,789 --> 00:27:49,389
multiple multiple Maps you're going to

00:27:47,889 --> 00:27:51,159
have to manually sort of look over and

00:27:49,389 --> 00:27:53,350
say ok well that's 0 and that's 1 and

00:27:51,159 --> 00:27:56,019
count them off no when you access map FD

00:27:53,350 --> 00:27:57,970
if you had something that it it does it

00:27:56,019 --> 00:28:00,419
so that's a little bit of the manual

00:27:57,970 --> 00:28:02,830
programming that goes with it right now

00:28:00,419 --> 00:28:04,299
now the other the other thing to think

00:28:02,830 --> 00:28:07,749
about is there are other ways to load

00:28:04,299 --> 00:28:08,889
files depending on how what level of

00:28:07,749 --> 00:28:10,659
interaction you want to have with each

00:28:08,889 --> 00:28:12,580
of them how many files you on a map is s

00:28:10,659 --> 00:28:14,379
FS there's some other ways to do this

00:28:12,580 --> 00:28:15,669
right now for this think this was the

00:28:14,379 --> 00:28:21,669
easiest way to get going and have

00:28:15,669 --> 00:28:23,950
multiple Maps so again

00:28:21,669 --> 00:28:29,289
we sort of talked about the same review

00:28:23,950 --> 00:28:31,950
but here's the code in action so if once

00:28:29,289 --> 00:28:34,719
we once we've loaded called load BPF map

00:28:31,950 --> 00:28:36,729
we have program v-0 should be set if

00:28:34,719 --> 00:28:39,429
it's not just exit because we're in

00:28:36,729 --> 00:28:41,229
trouble in fact one of the things that

00:28:39,429 --> 00:28:42,789
you'll find a case where this won't

00:28:41,229 --> 00:28:44,589
where this may fail is if you try to

00:28:42,789 --> 00:28:46,209
build on one system and say oh this is

00:28:44,589 --> 00:28:47,739
great I got my new app I'm gonna copy it

00:28:46,209 --> 00:28:49,450
over somewhere else and the first time

00:28:47,739 --> 00:28:51,339
you SCP the file over the new system you

00:28:49,450 --> 00:28:52,659
forgot to bring Kern dotto you're going

00:28:51,339 --> 00:28:54,249
to hit a failure like this because you

00:28:52,659 --> 00:28:58,570
you need that Kern dotto to actually do

00:28:54,249 --> 00:29:00,639
things and he's an easy mistake to make

00:28:58,570 --> 00:29:03,249
when you'll hopefully not make too many

00:29:00,639 --> 00:29:06,820
times but the next case is line 6 now

00:29:03,249 --> 00:29:11,079
you actually set that program as and I

00:29:06,820 --> 00:29:13,179
assign it to an interface index with the

00:29:11,079 --> 00:29:16,299
call set link XD PFD which is a net

00:29:13,179 --> 00:29:16,809
linked call loads the file and you're

00:29:16,299 --> 00:29:18,759
off and running

00:29:16,809 --> 00:29:21,789
that goes into the code line and attach

00:29:18,759 --> 00:29:24,369
this program directly to the to the

00:29:21,789 --> 00:29:26,979
given receive queues that's right and to

00:29:24,369 --> 00:29:29,679
make literally this is it like it's not

00:29:26,979 --> 00:29:31,629
yep that's now we do some different

00:29:29,679 --> 00:29:33,369
things here because we're rather than

00:29:31,629 --> 00:29:35,379
having a program that loads it runs it

00:29:33,369 --> 00:29:37,570
and waits in print state prints

00:29:35,379 --> 00:29:40,409
interaction do a little bit of extra

00:29:37,570 --> 00:29:42,729
work we'll talk about that a little bit

00:29:40,409 --> 00:29:47,709
it's just as someone once said it's just

00:29:42,729 --> 00:29:49,119
a small matter of programming so the

00:29:47,709 --> 00:29:53,349
other thing is talk about the importance

00:29:49,119 --> 00:29:56,579
of math ft why we care about it so again

00:29:53,349 --> 00:29:59,440
all the all the maps are loaded here and

00:29:56,579 --> 00:30:02,049
unsurprisingly thankfully in userspace

00:29:59,440 --> 00:30:02,559
the calls to access these things are

00:30:02,049 --> 00:30:04,119
very similar

00:30:02,559 --> 00:30:07,149
you may remember just a few minutes ago

00:30:04,119 --> 00:30:08,950
we did a BPF mac map lookup element call

00:30:07,149 --> 00:30:11,440
and that time when we call that we

00:30:08,950 --> 00:30:14,079
passed blacklist as the first argument

00:30:11,440 --> 00:30:16,299
and then we passed key as the second

00:30:14,079 --> 00:30:17,679
argument and it returned value well in

00:30:16,299 --> 00:30:19,570
this case now we're just going to pass

00:30:17,679 --> 00:30:22,629
the file descriptor associated with that

00:30:19,570 --> 00:30:24,129
map passing the key and instead of being

00:30:22,629 --> 00:30:25,869
returned the third argument is the value

00:30:24,129 --> 00:30:29,200
so this is really cool because it's like

00:30:25,869 --> 00:30:31,480
it's the same little confusing maybe

00:30:29,200 --> 00:30:33,470
because a different set of

00:30:31,480 --> 00:30:36,440
parameters but it's basically the same

00:30:33,470 --> 00:30:38,840
call and it's just not a lot of work and

00:30:36,440 --> 00:30:44,030
a lot of the difficulties are abstracted

00:30:38,840 --> 00:30:46,550
away it just it works it's nice so kudos

00:30:44,030 --> 00:30:48,470
to the writers of tools lib BPF and and

00:30:46,550 --> 00:30:53,510
the interactions between kernel user

00:30:48,470 --> 00:30:55,040
space so if you were doing again this is

00:30:53,510 --> 00:30:57,610
sort of the example and this is straight

00:30:55,040 --> 00:31:01,340
from xcp user see you load the file

00:30:57,610 --> 00:31:04,130
check to see that it got loaded set it

00:31:01,340 --> 00:31:08,090
up so you can hit control C to exit on

00:31:04,130 --> 00:31:11,150
line 13 you can see we assign it to a

00:31:08,090 --> 00:31:14,000
net dev and then we pretty much just

00:31:11,150 --> 00:31:16,010
pull the stats and - in this case just

00:31:14,000 --> 00:31:17,990
indicates every two seconds I think pull

00:31:16,010 --> 00:31:20,690
the stats sleep for two seconds print

00:31:17,990 --> 00:31:22,940
the stats this is super easy this user

00:31:20,690 --> 00:31:26,030
space implementation is not anything

00:31:22,940 --> 00:31:27,680
crazy if you didn't care about polling

00:31:26,030 --> 00:31:29,960
the stats you could actually probably

00:31:27,680 --> 00:31:32,390
take that at current oh and actually

00:31:29,960 --> 00:31:33,680
load it with IP route - and it would be

00:31:32,390 --> 00:31:34,700
up and running you just wouldn't have

00:31:33,680 --> 00:31:37,700
the ability to really check to see

00:31:34,700 --> 00:31:39,380
what's being dropped very very easily in

00:31:37,700 --> 00:31:41,570
this case they actually creates a map

00:31:39,380 --> 00:31:44,180
that that we could export as a file

00:31:41,570 --> 00:31:46,130
right I didn't have a normal user space

00:31:44,180 --> 00:31:47,720
your right application calling does man

00:31:46,130 --> 00:31:50,810
good yeah I have a Sisyphus father's pin

00:31:47,720 --> 00:31:52,130
to it yeah so again pretty pretty easy

00:31:50,810 --> 00:31:54,410
stuff but we want to provide a full

00:31:52,130 --> 00:31:55,880
example and talk about it so yeah this

00:31:54,410 --> 00:31:57,920
is a slightly different implementation

00:31:55,880 --> 00:32:01,130
so yes brush you did some of this work

00:31:57,920 --> 00:32:03,620
before before I arrived and they

00:32:01,130 --> 00:32:06,500
actually split upload BPF file we talked

00:32:03,620 --> 00:32:08,720
have you talked any more about I'm not

00:32:06,500 --> 00:32:10,070
really happy about that but okay we're

00:32:08,720 --> 00:32:13,130
going to change their add reconning

00:32:10,070 --> 00:32:14,570
maybe going to to put this up and merge

00:32:13,130 --> 00:32:18,950
this into the to the kernel trees

00:32:14,570 --> 00:32:21,140
version okay of floats says that the

00:32:18,950 --> 00:32:25,790
video would load the file because the

00:32:21,140 --> 00:32:27,350
problem I hit was that when when I I'm

00:32:25,790 --> 00:32:30,170
just loading the file it automatically

00:32:27,350 --> 00:32:32,870
knows all the maps and added attaches to

00:32:30,170 --> 00:32:35,390
five descriptors but I wanted to reuse

00:32:32,870 --> 00:32:37,040
so when I love my program I want to to

00:32:35,390 --> 00:32:38,900
see if there's already already been

00:32:37,040 --> 00:32:40,550
exported of a file and then I'll take

00:32:38,900 --> 00:32:41,990
that file the scripture open that and

00:32:40,550 --> 00:32:44,270
get that file descriptor instead of

00:32:41,990 --> 00:32:47,920
creating a new map so it was just a way

00:32:44,270 --> 00:32:50,720
of spreading so I could it's called read

00:32:47,920 --> 00:32:52,160
educated met maps and attach so I had to

00:32:50,720 --> 00:32:55,280
split that out in the function so I

00:32:52,160 --> 00:32:57,170
could verify the maps before it to

00:32:55,280 --> 00:32:59,840
program get loaded for me this was a

00:32:57,170 --> 00:33:01,160
like when I came into this code base

00:32:59,840 --> 00:33:03,140
this was the first part that I looked at

00:33:01,160 --> 00:33:05,060
was like oh it's a little different like

00:33:03,140 --> 00:33:07,250
I like it and it really gave me a

00:33:05,060 --> 00:33:08,960
greater a little bit greater knowledge

00:33:07,250 --> 00:33:10,760
of some of the internals and how things

00:33:08,960 --> 00:33:12,740
work so if you're looking at if you

00:33:10,760 --> 00:33:15,770
ultimately if you clone the code and

00:33:12,740 --> 00:33:16,790
take a look at it this is a little bit

00:33:15,770 --> 00:33:18,350
different I think it's a pretty good

00:33:16,790 --> 00:33:20,000
example but like I said that API is

00:33:18,350 --> 00:33:23,270
probably going to that may change a

00:33:20,000 --> 00:33:24,710
little bit over time so the tricky part

00:33:23,270 --> 00:33:26,980
is what you actually have to do some of

00:33:24,710 --> 00:33:29,810
the details is that that you have the

00:33:26,980 --> 00:33:31,520
WPF program and you have to actually you

00:33:29,810 --> 00:33:35,420
have to go in and modify the PPF

00:33:31,520 --> 00:33:37,490
programs to point it pointed to what

00:33:35,420 --> 00:33:39,560
what what five descriptors these maps

00:33:37,490 --> 00:33:41,120
are being used and that that helps the

00:33:39,560 --> 00:33:44,420
current to figure out what what maps

00:33:41,120 --> 00:33:47,570
actually should use so that that has to

00:33:44,420 --> 00:33:49,490
happen when we load load the program so

00:33:47,570 --> 00:33:50,990
that's there's a bit of a hassle but

00:33:49,490 --> 00:33:53,870
it's been sort of hidden in the program

00:33:50,990 --> 00:33:55,790
so what recently got added was maps and

00:33:53,870 --> 00:33:57,410
maps so you can have really good you

00:33:55,790 --> 00:33:59,720
could do a lookup in the kernel to get

00:33:57,410 --> 00:34:02,480
what map it is you can dynamically add

00:33:59,720 --> 00:34:04,850
mass so this what this shows is that

00:34:02,480 --> 00:34:07,430
we've sort of statically when we load to

00:34:04,850 --> 00:34:09,380
poke the program we statically say what

00:34:07,430 --> 00:34:12,980
what maps takes exists the module you

00:34:09,380 --> 00:34:16,220
can access but the reason editing

00:34:12,980 --> 00:34:18,530
addition of a new type of map that has

00:34:16,220 --> 00:34:21,860
maps then that opens up the possibility

00:34:18,530 --> 00:34:22,220
that you can actually dynamically create

00:34:21,860 --> 00:34:24,950
maps

00:34:22,220 --> 00:34:29,510
afterwards so but that's that's it's

00:34:24,950 --> 00:34:34,370
like that's really right listen time

00:34:29,510 --> 00:34:35,510
margin take those patches so right so

00:34:34,370 --> 00:34:38,450
this is again a slightly different

00:34:35,510 --> 00:34:39,920
implementation but the examples here you

00:34:38,450 --> 00:34:46,040
can look at it you can use it if you'd

00:34:39,920 --> 00:34:48,860
like all right okay so when when

00:34:46,040 --> 00:34:50,600
blacklist user exits what we can say for

00:34:48,860 --> 00:34:53,720
sure is that all the DPF maps that we

00:34:50,600 --> 00:34:55,910
had are created they're all pinned to

00:34:53,720 --> 00:34:57,340
new files insist FS BPF so you could

00:34:55,910 --> 00:34:59,920
actually go look at those

00:34:57,340 --> 00:35:01,330
as Jesper pointed out you can go ahead

00:34:59,920 --> 00:35:02,920
you can see you can trim on those or

00:35:01,330 --> 00:35:05,980
tone those you can do whatever you want

00:35:02,920 --> 00:35:07,810
so that average average user non-root

00:35:05,980 --> 00:35:09,670
user fact if you have an application

00:35:07,810 --> 00:35:11,410
it's going to feed data in you don't

00:35:09,670 --> 00:35:13,750
want that application to run as root you

00:35:11,410 --> 00:35:16,810
could change the ownership to be that

00:35:13,750 --> 00:35:20,620
applications however whatever user that

00:35:16,810 --> 00:35:22,660
application runs as and then later when

00:35:20,620 --> 00:35:24,040
the command-line tools come in you know

00:35:22,660 --> 00:35:27,400
anybody with the proper permissions can

00:35:24,040 --> 00:35:29,040
can do that yeah and and this district

00:35:27,400 --> 00:35:32,530
is you actually have to be able to mount

00:35:29,040 --> 00:35:36,520
right mom's mounted the a new type of

00:35:32,530 --> 00:35:38,410
file system AF but we were so and

00:35:36,520 --> 00:35:40,780
anticipating so we just run our program

00:35:38,410 --> 00:35:42,190
and it says oh you forgot to mount this

00:35:40,780 --> 00:35:44,530
and Bill gives you the mount command so

00:35:42,190 --> 00:35:46,570
you just copy/paste it so it's very user

00:35:44,530 --> 00:35:49,600
friendly so make it very user friendly

00:35:46,570 --> 00:35:51,100
in a command-line user friendly for us

00:35:49,600 --> 00:35:52,180
we don't know how to do you are but yeah

00:35:51,100 --> 00:35:55,180
yeah that's right

00:35:52,180 --> 00:35:57,340
so uh so now when we're done here our

00:35:55,180 --> 00:35:58,350
EPF program is attached to the net it's

00:35:57,340 --> 00:36:00,730
up and running

00:35:58,350 --> 00:36:02,140
may or may not be filtering any packets

00:36:00,730 --> 00:36:04,390
actually probably shouldn't be what's

00:36:02,140 --> 00:36:06,220
the hope they're supposed to be there

00:36:04,390 --> 00:36:08,560
waiting for waiting for command so now

00:36:06,220 --> 00:36:09,850
this is where we start configuring

00:36:08,560 --> 00:36:12,400
things so this is our command line

00:36:09,850 --> 00:36:15,100
interface appropriately named command

00:36:12,400 --> 00:36:16,810
line dot C also there's a common one so

00:36:15,100 --> 00:36:18,490
we had to support at the very beginning

00:36:16,810 --> 00:36:20,170
to put a couple entries in there just

00:36:18,490 --> 00:36:24,280
for testing to make sure our program is

00:36:20,170 --> 00:36:26,260
not completely not working and that's

00:36:24,280 --> 00:36:27,880
why some of the modify functions for

00:36:26,260 --> 00:36:30,460
modifying and adding entries to the map

00:36:27,880 --> 00:36:31,630
are also in this common dot H so we'll

00:36:30,460 --> 00:36:36,100
kind of go over a couple of things that

00:36:31,630 --> 00:36:37,630
are there all right so real basic you

00:36:36,100 --> 00:36:41,110
know print the print the entries that

00:36:37,630 --> 00:36:42,640
are there add in delete entries add or

00:36:41,110 --> 00:36:45,910
delete TCP and UDP ports from the

00:36:42,640 --> 00:36:48,310
blacklist and for fun print real-time

00:36:45,910 --> 00:36:51,370
xdp verdict stats so the real-time

00:36:48,310 --> 00:36:53,500
printing is just a literal is the first

00:36:51,370 --> 00:36:55,240
leg that first the second UI that I

00:36:53,500 --> 00:36:56,560
showed was just how many packets per

00:36:55,240 --> 00:36:59,710
second are we dropping how many are we

00:36:56,560 --> 00:37:02,500
accepting how many aborts are happening

00:36:59,710 --> 00:37:04,000
and transmits out again right and we

00:37:02,500 --> 00:37:05,500
don't have any hit but it doesn't have

00:37:04,000 --> 00:37:06,970
any a week just covered although no

00:37:05,500 --> 00:37:08,320
right now we're not here right now we're

00:37:06,970 --> 00:37:08,870
not doing we're not doing transmit with

00:37:08,320 --> 00:37:10,880
this

00:37:08,870 --> 00:37:12,530
just just for DDoS protection but you

00:37:10,880 --> 00:37:14,450
should be able to see girls a counter

00:37:12,530 --> 00:37:16,550
thoughts if some kind of strange chatter

00:37:14,450 --> 00:37:19,790
you have a couple of our boards right

00:37:16,550 --> 00:37:21,770
right aborts as well just so you can see

00:37:19,790 --> 00:37:24,140
the difference if the program is failing

00:37:21,770 --> 00:37:26,060
or writing it because it wants to drop

00:37:24,140 --> 00:37:32,690
it though because it was a malformed

00:37:26,060 --> 00:37:33,740
packet all right so this is a small

00:37:32,690 --> 00:37:36,070
amount of code it probably doesn't need

00:37:33,740 --> 00:37:39,590
some slides but we added it anyway

00:37:36,070 --> 00:37:41,810
so in our case really pretty simple

00:37:39,590 --> 00:37:44,420
we're opening up this BPF map associated

00:37:41,810 --> 00:37:48,170
with file blacklist coincidentally file

00:37:44,420 --> 00:37:50,000
blacklist is is also a string that

00:37:48,170 --> 00:37:52,220
happens to be the SIS FS file that we

00:37:50,000 --> 00:37:55,220
mapped to our blacklist map how this all

00:37:52,220 --> 00:37:56,480
sort of works together and we're going

00:37:55,220 --> 00:37:57,560
to do is in this case we're just going

00:37:56,480 --> 00:38:01,070
to read the entry so we're going to

00:37:57,560 --> 00:38:02,780
print all the ipv4 addresses so in our

00:38:01,070 --> 00:38:06,230
case we're going to call BPF object get

00:38:02,780 --> 00:38:08,330
on the file through the magic of the BPF

00:38:06,230 --> 00:38:09,350
syscall and the colonel's storage of

00:38:08,330 --> 00:38:11,030
this information we're going to be

00:38:09,350 --> 00:38:14,960
returned to file descriptor associated

00:38:11,030 --> 00:38:17,540
with that it's a pretty simple function

00:38:14,960 --> 00:38:19,130
but just put this here to really just

00:38:17,540 --> 00:38:20,140
make the the other code easier to read

00:38:19,130 --> 00:38:24,950
yeah

00:38:20,140 --> 00:38:26,330
so you might question why why this needs

00:38:24,950 --> 00:38:28,220
its own function but it does I think it

00:38:26,330 --> 00:38:30,440
makes it cleaner now we print all the

00:38:28,220 --> 00:38:33,080
addresses so here's here's some map

00:38:30,440 --> 00:38:35,660
interactions so in our case we're

00:38:33,080 --> 00:38:37,520
setting our initial key to zero there's

00:38:35,660 --> 00:38:40,580
this cool function this works well for

00:38:37,520 --> 00:38:42,620
both arrays and hashes that's nice

00:38:40,580 --> 00:38:44,090
to get the next key so constant file

00:38:42,620 --> 00:38:47,180
descriptor a key in the next key and

00:38:44,090 --> 00:38:48,530
you're off and rolling any time it

00:38:47,180 --> 00:38:50,660
returns is going to return a valid key

00:38:48,530 --> 00:38:53,900
key point to think about this is an

00:38:50,660 --> 00:38:55,370
array every t's valid so you're going to

00:38:53,900 --> 00:38:57,230
get back a lot of entries that basically

00:38:55,370 --> 00:38:58,550
have nothing in them so if you have an

00:38:57,230 --> 00:39:01,790
array you've got to come up with a way

00:38:58,550 --> 00:39:02,240
to note that nothing in you know that

00:39:01,790 --> 00:39:04,970
it's empty

00:39:02,240 --> 00:39:09,040
either it's 0 sometimes that's a good

00:39:04,970 --> 00:39:12,350
thing or has no value set in anyway so

00:39:09,040 --> 00:39:14,540
in our case the hash so it's only going

00:39:12,350 --> 00:39:16,400
to return valid entries in the case of

00:39:14,540 --> 00:39:17,750
my first example will either only been

00:39:16,400 --> 00:39:18,560
two entries that are returned because

00:39:17,750 --> 00:39:20,170
there were just two IP addresses

00:39:18,560 --> 00:39:21,730
specified

00:39:20,170 --> 00:39:23,950
so the other thing is we've written a

00:39:21,730 --> 00:39:27,700
function called get key 32 value 64 for

00:39:23,950 --> 00:39:29,500
CPU which is a mouthful but it's pretty

00:39:27,700 --> 00:39:31,180
appropriate for what the what the

00:39:29,500 --> 00:39:33,720
function is so we're passing in a 30 to

00:39:31,180 --> 00:39:37,480
get key 32-bit key we're gonna return a

00:39:33,720 --> 00:39:39,070
64-bit value so more they say it's just

00:39:37,480 --> 00:39:43,120
hiding the fact that we have to do the

00:39:39,070 --> 00:39:47,170
summing of that's right venues so here

00:39:43,120 --> 00:39:48,130
is that function pretty pretty

00:39:47,170 --> 00:39:50,740
straightforward we're gonna get the

00:39:48,130 --> 00:39:52,210
number of CPUs on line 3 I'm going to go

00:39:50,740 --> 00:39:54,190
through and on line 8 you're going to

00:39:52,210 --> 00:39:56,620
see that we actually look up so here's

00:39:54,190 --> 00:40:00,370
our user space to call again called the

00:39:56,620 --> 00:40:02,890
same as what we had in in current dot C

00:40:00,370 --> 00:40:04,120
BPF map lookup element we're going to

00:40:02,890 --> 00:40:05,380
pass it a file descriptor because that's

00:40:04,120 --> 00:40:06,970
the file descriptor that we have passed

00:40:05,380 --> 00:40:08,440
in that matches the blacklist we're

00:40:06,970 --> 00:40:10,270
going to check the key we're going to

00:40:08,440 --> 00:40:13,360
get the values you'll notice that values

00:40:10,270 --> 00:40:15,790
on line 4 is a you 64 that's equal to

00:40:13,360 --> 00:40:16,840
the number of CPUs in array size so

00:40:15,790 --> 00:40:18,220
what's going to do it's going to return

00:40:16,840 --> 00:40:20,080
an array and that's going to

00:40:18,220 --> 00:40:21,520
interestingly if we wanted to know which

00:40:20,080 --> 00:40:22,780
CPU was doing the drop for this

00:40:21,520 --> 00:40:26,320
particular blacklist we could actually

00:40:22,780 --> 00:40:27,520
inspect that adequate we cared not that

00:40:26,320 --> 00:40:28,660
much about it we just wanted to know how

00:40:27,520 --> 00:40:29,950
many times it was actually dropped

00:40:28,660 --> 00:40:31,570
weren't too worried about which which

00:40:29,950 --> 00:40:34,030
queue received it or which CPU handled

00:40:31,570 --> 00:40:36,310
it and then we just sum the values so

00:40:34,030 --> 00:40:38,290
just take those in in our case sometimes

00:40:36,310 --> 00:40:41,800
we ran this on a 4 core system on an 8

00:40:38,290 --> 00:40:44,230
core system did you have a 16 core or

00:40:41,800 --> 00:40:45,700
just four eight you remember how many go

00:40:44,230 --> 00:40:47,440
ahead remember nine different ones

00:40:45,700 --> 00:40:50,800
a bunch of system yes we've got yes

00:40:47,440 --> 00:40:53,230
we've got a home lab and so this is only

00:40:50,800 --> 00:40:54,310
eight HCV only eight okay yeah I don't

00:40:53,230 --> 00:40:58,870
think I tested more than eight either

00:40:54,310 --> 00:41:00,940
but um what confident it works so just

00:40:58,870 --> 00:41:02,650
something about this is like it's really

00:41:00,940 --> 00:41:04,600
elementary it's kind of funny to walk

00:41:02,650 --> 00:41:05,830
through but but we want to again wanted

00:41:04,600 --> 00:41:07,450
to provide an example want to have

00:41:05,830 --> 00:41:10,990
people you have the opportunity to see

00:41:07,450 --> 00:41:12,550
see how this works so then the next

00:41:10,990 --> 00:41:15,160
thing I want to do in our in our order

00:41:12,550 --> 00:41:19,960
if you remember then we call blacklist

00:41:15,160 --> 00:41:22,060
print ipv4 again not not terribly uh not

00:41:19,960 --> 00:41:24,460
rocket surgery as some would say but

00:41:22,060 --> 00:41:26,170
just really take our our 32-bit value

00:41:24,460 --> 00:41:28,390
convert it back to a printable IP

00:41:26,170 --> 00:41:32,880
address and hopefully print out what we

00:41:28,390 --> 00:41:32,880
think is valid JSON for for

00:41:33,210 --> 00:41:37,180
nothing nothing real crazy so that the

00:41:35,740 --> 00:41:40,620
real key interaction is actually just

00:41:37,180 --> 00:41:42,520
hearing this get key 32 value 64 per CPU

00:41:40,620 --> 00:41:44,380
function where we're looking at the

00:41:42,520 --> 00:41:46,600
elements summing them because in our

00:41:44,380 --> 00:41:48,520
case we're using a per CPU hash move or

00:41:46,600 --> 00:41:50,590
we thought that might be worth pointing

00:41:48,520 --> 00:41:53,200
out because that's something that I also

00:41:50,590 --> 00:41:55,060
get that got me that yeah I am and I've

00:41:53,200 --> 00:41:56,680
seen all the values right right and the

00:41:55,060 --> 00:41:58,540
first time you do it sometimes you'd see

00:41:56,680 --> 00:42:01,420
ports you see things getting dropped and

00:41:58,540 --> 00:42:02,890
you're like oh okay that works but then

00:42:01,420 --> 00:42:04,030
other times you send traffic make you

00:42:02,890 --> 00:42:05,470
know you're running eight windows you

00:42:04,030 --> 00:42:07,030
got TCP dump runnin to see if the frames

00:42:05,470 --> 00:42:08,410
are coming in on the interface see if

00:42:07,030 --> 00:42:09,820
they're getting drops you realize

00:42:08,410 --> 00:42:11,380
they're getting dropped but why is my

00:42:09,820 --> 00:42:13,320
counter incrementing and it turns out

00:42:11,380 --> 00:42:16,690
it's because when you you did the call

00:42:13,320 --> 00:42:18,670
you only got value you only got the one

00:42:16,690 --> 00:42:21,940
value for the one CPU you were on or

00:42:18,670 --> 00:42:23,710
four CPUs zero so an important yeah and

00:42:21,940 --> 00:42:25,330
also when you when you update a value if

00:42:23,710 --> 00:42:27,820
you want bunch of reset it to zero you

00:42:25,330 --> 00:42:28,720
have to put in all the CPUs to see it's

00:42:27,820 --> 00:42:31,270
almost letting you know what the next

00:42:28,720 --> 00:42:32,770
slide is yeah exactly

00:42:31,270 --> 00:42:36,190
the next case you're going to do the

00:42:32,770 --> 00:42:37,750
black let's modify function so again

00:42:36,190 --> 00:42:39,310
kind of similar we're going to open the

00:42:37,750 --> 00:42:40,900
BPF map you saw that that code earlier

00:42:39,310 --> 00:42:42,760
so we won't bore you with that since

00:42:40,900 --> 00:42:44,640
it's still the same and we're going to

00:42:42,760 --> 00:42:47,590
call black let's modify so in this case

00:42:44,640 --> 00:42:49,630
right is Jesper said right on time line

00:42:47,590 --> 00:42:51,580
eight we just do a mem set we wipe out

00:42:49,630 --> 00:42:53,260
whatever was you create an empty array

00:42:51,580 --> 00:42:55,660
before we get the element so that we

00:42:53,260 --> 00:42:57,490
know what we're getting back is correct

00:42:55,660 --> 00:43:01,050
and and we can feel confident that it's

00:42:57,490 --> 00:43:03,670
actually being updated so in this case

00:43:01,050 --> 00:43:08,850
if the action in ours in our case is add

00:43:03,670 --> 00:43:08,850
we're going to update it by updating

00:43:09,330 --> 00:43:14,680
yeah do we so we actually okay so here's

00:43:13,990 --> 00:43:15,250
where things get a little bit

00:43:14,680 --> 00:43:18,940
interesting

00:43:15,250 --> 00:43:19,990
so with if this were an array I talked

00:43:18,940 --> 00:43:21,190
about it earlier I think I've said it

00:43:19,990 --> 00:43:23,410
twice so say at a third time because

00:43:21,190 --> 00:43:25,630
it's worth remembering just or an array

00:43:23,410 --> 00:43:27,070
we were adding something in all the

00:43:25,630 --> 00:43:29,260
array the arrays are initialized to zero

00:43:27,070 --> 00:43:30,940
to start with so in our case because

00:43:29,260 --> 00:43:32,500
it's a hash and it's not initialized to

00:43:30,940 --> 00:43:35,020
zero to start with we can actually write

00:43:32,500 --> 00:43:36,850
zero in there and that creates this

00:43:35,020 --> 00:43:40,420
initial value that creates the initial

00:43:36,850 --> 00:43:43,360
entry in in the hash so we want our

00:43:40,420 --> 00:43:44,650
counter to be zero it all makes sense so

00:43:43,360 --> 00:43:47,200
we're actually our ad

00:43:44,650 --> 00:43:48,670
just say write zeros in at this key and

00:43:47,200 --> 00:43:50,260
now we know that that's a key we want to

00:43:48,670 --> 00:43:52,630
block and we know that values would be

00:43:50,260 --> 00:43:54,549
incremented as traffic comes in that

00:43:52,630 --> 00:43:55,960
should be blocked yeah and we also have

00:43:54,549 --> 00:43:58,809
to take it that doesn't exist as we

00:43:55,960 --> 00:44:02,910
would clear out our old entries right

00:43:58,809 --> 00:44:06,369
that's right so Piazza 36 values right

00:44:02,910 --> 00:44:07,630
so and then if our action is delete we

00:44:06,369 --> 00:44:11,260
just call delete the element because

00:44:07,630 --> 00:44:12,849
again this is that's what we're doing

00:44:11,260 --> 00:44:15,910
it's easy so we just we want to not have

00:44:12,849 --> 00:44:18,039
it there at all we want if we if we just

00:44:15,910 --> 00:44:19,839
cleared the value in values the way our

00:44:18,039 --> 00:44:22,210
program is written it way we wrote our

00:44:19,839 --> 00:44:25,180
BPF code we just cleared it we would

00:44:22,210 --> 00:44:30,099
still drop drop frames because values is

00:44:25,180 --> 00:44:31,869
just the counter so it's pretty simple

00:44:30,099 --> 00:44:36,099
you do have to know some about the

00:44:31,869 --> 00:44:38,109
nuances of the map elements or the map

00:44:36,099 --> 00:44:40,510
types in order to write this correctly

00:44:38,109 --> 00:44:42,910
but the cool thing is a lot of the api's

00:44:40,510 --> 00:44:45,789
are the same I actually when I

00:44:42,910 --> 00:44:48,539
implemented the port blocking for for

00:44:45,789 --> 00:44:50,260
TCP and UDP ports my first

00:44:48,539 --> 00:44:52,089
implementation was just using a hash

00:44:50,260 --> 00:44:54,940
just like let's just get it working it's

00:44:52,089 --> 00:44:59,349
not think too much about getting it

00:44:54,940 --> 00:45:01,420
complex and you know you can when I

00:44:59,349 --> 00:45:03,309
switch to an array you still use all the

00:45:01,420 --> 00:45:04,420
same calls you just have to know that

00:45:03,309 --> 00:45:06,960
slight difference between what the

00:45:04,420 --> 00:45:10,510
return values are and how they interact

00:45:06,960 --> 00:45:12,910
all right so now we've we've added one

00:45:10,510 --> 00:45:14,460
we've deleted one actually I think I

00:45:12,910 --> 00:45:17,260
forgot to update the title on that so

00:45:14,460 --> 00:45:18,339
now we'll go a little bit of usage how

00:45:17,260 --> 00:45:19,119
does this thing work what does it look

00:45:18,339 --> 00:45:22,539
like when it runs

00:45:19,119 --> 00:45:24,369
so here's us initializing the

00:45:22,539 --> 00:45:27,099
application we're attaching it to a

00:45:24,369 --> 00:45:29,650
device we have gone all the way to being

00:45:27,099 --> 00:45:31,210
able to specify the name of the net dev

00:45:29,650 --> 00:45:33,970
instead of just the if' index on the

00:45:31,210 --> 00:45:35,770
command line like this is like just

00:45:33,970 --> 00:45:38,200
lightyears ahead of other things that

00:45:35,770 --> 00:45:42,609
are out there thank you for the mod

00:45:38,200 --> 00:45:45,160
laughter ah and and here we get a nice

00:45:42,609 --> 00:45:47,109
printout of all the black lists map all

00:45:45,160 --> 00:45:49,420
the all the maps that we're using the

00:45:47,109 --> 00:45:51,730
one we talked about today and went into

00:45:49,420 --> 00:45:54,520
detail is on line 10 there this is the

00:45:51,730 --> 00:45:57,039
DDoS blacklist this is the file again

00:45:54,520 --> 00:45:58,270
this is where the printout is done that

00:45:57,039 --> 00:46:02,350
you put in there if

00:45:58,270 --> 00:46:03,790
if sis FSB PF is not if not mounted the

00:46:02,350 --> 00:46:05,710
program won't start will actually

00:46:03,790 --> 00:46:07,930
complain and say something it's right

00:46:05,710 --> 00:46:09,880
this also have a quiet option but the

00:46:07,930 --> 00:46:12,430
default is that it actually tells you a

00:46:09,880 --> 00:46:14,350
lot about what's going on that see this

00:46:12,430 --> 00:46:16,750
is the files this is because this is an

00:46:14,350 --> 00:46:18,700
example program so yeah really wants us

00:46:16,750 --> 00:46:20,680
to like point out what this is doing

00:46:18,700 --> 00:46:22,840
when you call it you can also call it

00:46:20,680 --> 00:46:24,040
with a quiet option and suspended UNIX

00:46:22,840 --> 00:46:25,300
it does pertain neither one of us are

00:46:24,040 --> 00:46:29,860
very quiet so that didn't seem appealing

00:46:25,300 --> 00:46:30,730
to demonstrate so the other thing that's

00:46:29,860 --> 00:46:33,369
cool

00:46:30,730 --> 00:46:35,800
I decided on line 16 to demonstrate the

00:46:33,369 --> 00:46:38,320
fact that the latest IP route 2 also

00:46:35,800 --> 00:46:40,240
prints not typically highlighted in

00:46:38,320 --> 00:46:41,590
yellow and hopefully this is good for

00:46:40,240 --> 00:46:43,000
all folks that are red-green colorblind

00:46:41,590 --> 00:46:47,260
I don't know if people can see that

00:46:43,000 --> 00:46:49,450
color that XDP is currently attached so

00:46:47,260 --> 00:46:52,180
this would be another reason to upgrade

00:46:49,450 --> 00:46:54,460
to a pretty modern distro or make sure

00:46:52,180 --> 00:46:56,500
you're running latest IP route 2 so why

00:46:54,460 --> 00:46:58,810
you can't explicitly check to see what

00:46:56,500 --> 00:47:01,270
vpf is program is running right now or

00:46:58,810 --> 00:47:03,820
what happens in that VP of program you

00:47:01,270 --> 00:47:06,369
can't know that the text EP is attached

00:47:03,820 --> 00:47:07,660
to an interface so that's kind of

00:47:06,369 --> 00:47:13,780
convenient if you if you're debugging

00:47:07,660 --> 00:47:18,850
something alright so blacklist

00:47:13,780 --> 00:47:20,740
configuration again not that epic um

00:47:18,850 --> 00:47:24,010
you're really just adding an IP address

00:47:20,740 --> 00:47:26,590
deleting IP addresses and got to remove

00:47:24,010 --> 00:47:30,210
the debug outputs with the keys yeah

00:47:26,590 --> 00:47:35,230
well you know it's uh we can add we can

00:47:30,210 --> 00:47:37,300
patches accepted no uh yeah we get rid

00:47:35,230 --> 00:47:38,500
of some of that debug output I don't

00:47:37,300 --> 00:47:41,859
know if you added that right of that but

00:47:38,500 --> 00:47:42,850
anyway this is a good it's a good canary

00:47:41,859 --> 00:47:46,960
to let you know that that's are

00:47:42,850 --> 00:47:48,820
happening correctly ah now you actually

00:47:46,960 --> 00:47:50,170
detention you had a ten-cent or else you

00:47:48,820 --> 00:47:53,290
could actually see the keyboard would be

00:47:50,170 --> 00:47:56,530
in the network by total but yes yeah

00:47:53,290 --> 00:48:00,550
well that's sort of intentional yeah all

00:47:56,530 --> 00:48:02,680
right ah so the other thing is we

00:48:00,550 --> 00:48:05,050
thought about all right neither one of

00:48:02,680 --> 00:48:07,060
us or at least I won't speak for yes per

00:48:05,050 --> 00:48:09,250
but I don't maintain a lot of websites

00:48:07,060 --> 00:48:10,570
that are highly targeted by anybody but

00:48:09,250 --> 00:48:11,770
I thought about what if we wanted to

00:48:10,570 --> 00:48:14,080
automate this how could we

00:48:11,770 --> 00:48:16,720
so it seems like back when I did run

00:48:14,080 --> 00:48:18,880
something deny hosts seem to be cool or

00:48:16,720 --> 00:48:20,680
at least non terrible and it seems like

00:48:18,880 --> 00:48:22,450
the spiritual successor to that is like

00:48:20,680 --> 00:48:24,850
failed to ban so I thought all right

00:48:22,450 --> 00:48:28,960
well how easy is it to automate this and

00:48:24,850 --> 00:48:32,140
so I quickly forked it and it was really

00:48:28,960 --> 00:48:33,460
trivial so congrats on the to the failed

00:48:32,140 --> 00:48:36,520
of banned folks for making it so easy to

00:48:33,460 --> 00:48:37,930
use in all honesty and there's just an

00:48:36,520 --> 00:48:41,050
example of what it would take to take

00:48:37,930 --> 00:48:43,530
this application and allow you to look

00:48:41,050 --> 00:48:45,550
at all the different SSH or other

00:48:43,530 --> 00:48:47,290
protocols that you enable other log

00:48:45,550 --> 00:48:48,480
files you enable and add these to the to

00:48:47,290 --> 00:48:55,930
a blacklist

00:48:48,480 --> 00:48:56,650
BPF blacklist automatically all right so

00:48:55,930 --> 00:48:59,140
now we'll talk a little bit about

00:48:56,650 --> 00:49:00,070
performance that's why that's real

00:48:59,140 --> 00:49:01,540
reason to use xcp

00:49:00,070 --> 00:49:03,340
so we've got a couple couple charts on

00:49:01,540 --> 00:49:06,910
that so you want to talk about this one

00:49:03,340 --> 00:49:09,790
yet this is run on my system so this is

00:49:06,910 --> 00:49:11,890
I'm just running a single UDP stream so

00:49:09,790 --> 00:49:15,340
what what this test is really showing is

00:49:11,890 --> 00:49:19,570
a ln activate a single CPU so if I want

00:49:15,340 --> 00:49:22,170
to just since if I'm just sending a lot

00:49:19,570 --> 00:49:25,960
of packets UDP packets to the same port

00:49:22,170 --> 00:49:27,880
then and I have no listener I think the

00:49:25,960 --> 00:49:29,640
colonel is driving with it's which is

00:49:27,880 --> 00:49:33,010
around three million packets per second

00:49:29,640 --> 00:49:34,480
and this is after commits something

00:49:33,010 --> 00:49:39,760
because doesn't want afford we had like

00:49:34,480 --> 00:49:41,350
half performance but if we then to go

00:49:39,760 --> 00:49:43,090
ahead look at what what is the earliest

00:49:41,350 --> 00:49:45,670
possible point we could be the droplet

00:49:43,090 --> 00:49:47,710
like IP tables that's like you know we

00:49:45,670 --> 00:49:51,970
have a table called raw and in

00:49:47,710 --> 00:49:55,030
pre-rounding step I'm adding a match for

00:49:51,970 --> 00:49:59,170
for port nine which is the the ports I'm

00:49:55,030 --> 00:50:01,330
attacking with the package in and what

00:49:59,170 --> 00:50:03,640
we see there is that the base

00:50:01,330 --> 00:50:05,560
performance is 4.5 million packets per

00:50:03,640 --> 00:50:07,930
second we can drop and then we did the

00:50:05,560 --> 00:50:10,750
same test with the blacklist and I can

00:50:07,930 --> 00:50:12,520
drop the nine point six million packets

00:50:10,750 --> 00:50:14,650
per second and this this is mostly

00:50:12,520 --> 00:50:16,570
action because I get a cache cache hit

00:50:14,650 --> 00:50:18,460
right this is actually not because of

00:50:16,570 --> 00:50:20,950
the so much because especially when you

00:50:18,460 --> 00:50:22,460
next time can you try with dropping a TC

00:50:20,950 --> 00:50:28,300
ingress

00:50:22,460 --> 00:50:31,609
no you asked that shimmer try to try

00:50:28,300 --> 00:50:33,980
when you give them a chance again try to

00:50:31,609 --> 00:50:34,280
do dropping the TC ingress I'm just

00:50:33,980 --> 00:50:37,730
curious

00:50:34,280 --> 00:50:42,250
just the action drop simple ya know in

00:50:37,730 --> 00:50:42,250
software yawn and nfe ingress and I

00:50:42,849 --> 00:50:47,839
actually I actually have a test group

00:50:45,260 --> 00:50:49,970
that I can drop that in TC because

00:50:47,839 --> 00:50:52,460
there's Jamel s curve I have a small

00:50:49,970 --> 00:50:55,280
intervention that's really nice of you

00:50:52,460 --> 00:50:57,800
doing all the stuff we detect one bug on

00:50:55,280 --> 00:51:03,109
your HTTP program because you are using

00:50:57,800 --> 00:51:07,010
you 64-bit counters but it won't work on

00:51:03,109 --> 00:51:08,569
a 32-bit kernel right yeah because when

00:51:07,010 --> 00:51:11,000
you fetch the values from you space

00:51:08,569 --> 00:51:14,119
there is no way you can fetch that

00:51:11,000 --> 00:51:16,309
automatically it is 64-bit value but

00:51:14,119 --> 00:51:18,920
that's a minor point but yeah ok so

00:51:16,309 --> 00:51:20,300
there's a bug in your P program so I

00:51:18,920 --> 00:51:23,930
guarantee you that's on the open you

00:51:20,300 --> 00:51:30,980
know thank you we are accessing your

00:51:23,930 --> 00:51:32,690
patches yeah so yeah that was this is

00:51:30,980 --> 00:51:36,770
also like completely like this is

00:51:32,690 --> 00:51:38,599
completely untuned unhak drivers may

00:51:36,770 --> 00:51:39,950
very like vanilla yeah it should be

00:51:38,599 --> 00:51:43,130
something that if you if you happen to

00:51:39,950 --> 00:51:45,710
have a CX 4 card you could reproduce we

00:51:43,130 --> 00:51:48,890
hope pretty easily in Italy that's and

00:51:45,710 --> 00:51:50,480
yes as I said if I actually have to

00:51:48,890 --> 00:51:52,790
impetuous or will change this number to

00:51:50,480 --> 00:51:58,460
like 17 million eggs per second in the

00:51:52,790 --> 00:52:00,680
practice right but is it this so then

00:51:58,460 --> 00:52:03,380
yet another one that we do scaling

00:52:00,680 --> 00:52:06,770
testing to see it doesn't not doesn't

00:52:03,380 --> 00:52:09,559
hit but Mars just hit this off didn't

00:52:06,770 --> 00:52:11,180
scale right so we did like a hat because

00:52:09,559 --> 00:52:13,430
there were seven CPUs in my machine and

00:52:11,180 --> 00:52:17,990
eight CPUs in my sheet machine my

00:52:13,430 --> 00:52:21,380
machine I waited like seven flows of and

00:52:17,990 --> 00:52:22,880
then have one flow being accepted we'll

00:52:21,380 --> 00:52:25,099
take the pee pants and the other flows

00:52:22,880 --> 00:52:27,500
like just attacking and as you can see

00:52:25,099 --> 00:52:30,770
I'm dropping X 30 million packets per

00:52:27,500 --> 00:52:33,319
second and and we are passing through

00:52:30,770 --> 00:52:34,390
what what the current can handle in this

00:52:33,319 --> 00:52:36,790
case

00:52:34,390 --> 00:52:38,620
it's a street point 4 million packets

00:52:36,790 --> 00:52:40,120
per second because that's I'm just

00:52:38,620 --> 00:52:42,460
selling it to a UDP port that where

00:52:40,120 --> 00:52:43,930
there's no listener and aunty Colonel

00:52:42,460 --> 00:52:46,450
just drops that there was basically the

00:52:43,930 --> 00:52:48,460
other number from before that that's

00:52:46,450 --> 00:52:52,900
that's what what happens when you send

00:52:48,460 --> 00:52:54,700
it to the network's dying the the

00:52:52,900 --> 00:52:56,290
performance does proper if I to intermix

00:52:54,700 --> 00:52:57,760
traffic because now I'm just keeping

00:52:56,290 --> 00:52:58,510
these flows but that I'm working on

00:52:57,760 --> 00:53:01,390
fixing them

00:52:58,510 --> 00:53:03,910
right and this is again early early

00:53:01,390 --> 00:53:05,770
phase of things I think be better if we

00:53:03,910 --> 00:53:07,060
had some nice profile put it's a pretty

00:53:05,770 --> 00:53:09,370
good number right baby

00:53:07,060 --> 00:53:15,250
DDoS protection with 30 million packets

00:53:09,370 --> 00:53:17,640
per second this you have a question I'll

00:53:15,250 --> 00:53:17,640
repeat it

00:53:24,750 --> 00:53:32,830
yeah so so XT piece is not magic so if

00:53:29,790 --> 00:53:35,110
you actually if you it's a pretty good

00:53:32,830 --> 00:53:37,600
question so if you just do HDPE pass if

00:53:35,110 --> 00:53:40,810
you primarily couldn't like use cases

00:53:37,600 --> 00:53:43,180
just or program to http pass the number

00:53:40,810 --> 00:53:45,040
of cycles you edit in the hot path is

00:53:43,180 --> 00:53:48,370
going to affect your performance so you

00:53:45,040 --> 00:53:50,380
to see every aggregation like maybe 10

00:53:48,370 --> 00:53:52,330
percent or something if it's really bad

00:53:50,380 --> 00:53:54,370
like take it that that Jackson dues

00:53:52,330 --> 00:53:55,990
performed by loading this program for

00:53:54,370 --> 00:53:58,600
for doing connect follow be found just

00:53:55,990 --> 00:54:00,790
what when you did your tests with IP IP

00:53:58,600 --> 00:54:04,840
tables did you have X to be loaded

00:54:00,790 --> 00:54:07,660
already no it was not loaded xB was not

00:54:04,840 --> 00:54:10,170
loaded and not the IP tables test

00:54:07,660 --> 00:54:10,170
Pakistan

00:54:14,090 --> 00:54:17,180
that's right yeah absolutely that's a

00:54:16,190 --> 00:54:19,070
great that's a great point I mean the

00:54:17,180 --> 00:54:20,060
cycles spent processing these frames to

00:54:19,070 --> 00:54:26,900
check as to whether or not they're

00:54:20,060 --> 00:54:28,370
acceptable yeah no I'm not fair but make

00:54:26,900 --> 00:54:30,620
sure the HTTP program is not running

00:54:28,370 --> 00:54:33,230
of course I think whatever instruction

00:54:30,620 --> 00:54:35,180
in the hot path is going to count down

00:54:33,230 --> 00:54:36,470
for deliverance and over your space but

00:54:35,180 --> 00:54:38,120
that's that's the trade-off you are

00:54:36,470 --> 00:54:41,240
choosing when you load safety people run

00:54:38,120 --> 00:54:43,730
if you want to filter some certain kind

00:54:41,240 --> 00:54:45,320
of traffic you can do that but it comes

00:54:43,730 --> 00:54:46,670
at the performance cost for delivering

00:54:45,320 --> 00:54:48,740
the normal stack and that's something

00:54:46,670 --> 00:54:51,650
people should be aware it's not not a

00:54:48,740 --> 00:54:55,700
magic thing so there's a second thing I

00:54:51,650 --> 00:54:58,940
wanted to say it's about ipv4 what about

00:54:55,700 --> 00:55:00,680
ipv6 guys hey well we have we have a

00:54:58,940 --> 00:55:02,360
slicer then yeah we have thought on that

00:55:00,680 --> 00:55:06,770
and an t1 is implemented

00:55:02,360 --> 00:55:09,440
yeah if ya really came down to time I

00:55:06,770 --> 00:55:11,090
mean because we know that especially in

00:55:09,440 --> 00:55:12,440
a lot of the data centers right ipv6 is

00:55:11,090 --> 00:55:17,300
what's happening people are not doing

00:55:12,440 --> 00:55:18,590
ipv4 really anywhere much so we also

00:55:17,300 --> 00:55:20,840
want to target to think about like home

00:55:18,590 --> 00:55:23,930
users so the next slide kind of actually

00:55:20,840 --> 00:55:26,500
tested this on a quad-core a57 surprise

00:55:23,930 --> 00:55:30,650
surprise that my company makes and

00:55:26,500 --> 00:55:33,230
because be NX t en supports xt p did

00:55:30,650 --> 00:55:35,990
some similar testing this is the arms of

00:55:33,230 --> 00:55:37,250
you because he's right and so in this

00:55:35,990 --> 00:55:40,130
case we were able to with a single

00:55:37,250 --> 00:55:41,990
stream drop 3.7 million I know from

00:55:40,130 --> 00:55:43,580
talking to other people but there exists

00:55:41,990 --> 00:55:45,650
the capability to drop it a much higher

00:55:43,580 --> 00:55:47,150
rate especially if things are tweaked so

00:55:45,650 --> 00:55:50,140
that's going to be the sort of next

00:55:47,150 --> 00:55:51,740
action for me is to work on that

00:55:50,140 --> 00:55:55,910
disappointed their pictures of it but

00:55:51,740 --> 00:55:57,320
that's okay um so but yeah feel like

00:55:55,910 --> 00:56:01,220
ipv6 is the way to go there's going to

00:55:57,320 --> 00:56:03,520
be a much bigger hit going in looking

00:56:01,220 --> 00:56:06,140
that far into the packet but that's okay

00:56:03,520 --> 00:56:10,760
that'll be next in the in the pipeline

00:56:06,140 --> 00:56:12,470
so alright so a couple tips and tricks

00:56:10,760 --> 00:56:14,840
that we encountered wanted to save you

00:56:12,470 --> 00:56:17,180
some time if you're writing your own or

00:56:14,840 --> 00:56:19,340
if you're trying to use this so the

00:56:17,180 --> 00:56:23,540
first one is to turn on the in kernel in

00:56:19,340 --> 00:56:24,630
kernel JIT for BPF so it makes a huge

00:56:23,540 --> 00:56:27,300
difference

00:56:24,630 --> 00:56:27,720
huge huge difference Thanks thank you

00:56:27,300 --> 00:56:31,740
Eric

00:56:27,720 --> 00:56:32,970
yeah yes so the first time I did some

00:56:31,740 --> 00:56:34,260
testing I was like this is pretty

00:56:32,970 --> 00:56:35,700
disappointing I'm not sure this is going

00:56:34,260 --> 00:56:38,700
to be a technology that's worth using

00:56:35,700 --> 00:56:40,410
and I realized once I turned it on I was

00:56:38,700 --> 00:56:41,430
like oh I mean it's you're talking about

00:56:40,410 --> 00:56:44,760
pretty close to double the performance

00:56:41,430 --> 00:56:46,530
in a lot of cases and the deeper the

00:56:44,760 --> 00:56:48,510
bigger your program is the greater the

00:56:46,530 --> 00:56:50,850
gain is so if you have a simple program

00:56:48,510 --> 00:56:52,080
that's doing that like HDPE one is

00:56:50,850 --> 00:56:54,300
probably not going to notice a huge

00:56:52,080 --> 00:56:55,950
change in performance especially if you

00:56:54,300 --> 00:56:59,010
yeah you're really not going to notice

00:56:55,950 --> 00:57:00,750
much if it's not going in very far but

00:56:59,010 --> 00:57:03,570
the more BPF code you're running the

00:57:00,750 --> 00:57:06,030
more this is critical so do this put

00:57:03,570 --> 00:57:11,940
this in in your config files so it's on

00:57:06,030 --> 00:57:14,760
all the time so yeah again huge

00:57:11,940 --> 00:57:15,720
performance gain the other thing is when

00:57:14,760 --> 00:57:17,130
you first start using some of these

00:57:15,720 --> 00:57:19,290
things some of the programs don't have

00:57:17,130 --> 00:57:21,930
depending on what shell you're using my

00:57:19,290 --> 00:57:25,200
tested this on a bun too we tested this

00:57:21,930 --> 00:57:28,680
on Fedora did a little bit of testing on

00:57:25,200 --> 00:57:29,520
a yak so based distribution and the

00:57:28,680 --> 00:57:31,020
shell is going to have different you

00:57:29,520 --> 00:57:32,430
limit settings so you're going to want

00:57:31,020 --> 00:57:33,510
to run you you might try to run it the

00:57:32,430 --> 00:57:36,540
first time you're going to get an error

00:57:33,510 --> 00:57:38,850
about memory limits or map size so check

00:57:36,540 --> 00:57:42,240
checking limit - a and consider

00:57:38,850 --> 00:57:44,130
increasing your defaults so that's

00:57:42,240 --> 00:57:47,220
that's key to think about when getting

00:57:44,130 --> 00:57:48,870
started the other thing is just a

00:57:47,220 --> 00:57:51,660
familiar eye familiarize yourself with

00:57:48,870 --> 00:57:54,330
the ability to dump out the maps both

00:57:51,660 --> 00:57:56,190
LLVM and retells can do this gives you a

00:57:54,330 --> 00:57:58,110
chance to look at how big things are if

00:57:56,190 --> 00:58:01,050
you want so you can see that in this

00:57:58,110 --> 00:58:06,840
case we have our X DB program is on line

00:58:01,050 --> 00:58:09,300
11 our maps are there this was just to

00:58:06,840 --> 00:58:11,100
demystify that the elf file that's

00:58:09,300 --> 00:58:13,290
generated you can actually use to stand

00:58:11,100 --> 00:58:16,290
up right like object dump debugging

00:58:13,290 --> 00:58:18,930
tools to look at this stuff this like in

00:58:16,290 --> 00:58:21,060
the newer LLVM Aleksey is telling me

00:58:18,930 --> 00:58:24,000
that we can we can inline some of the

00:58:21,060 --> 00:58:26,370
reaching original c code so we could

00:58:24,000 --> 00:58:27,750
actually what I really wanted to show

00:58:26,370 --> 00:58:29,430
here was that you could like Tom -

00:58:27,750 --> 00:58:31,530
assembler we would see something useful

00:58:29,430 --> 00:58:33,660
but we are not doing it here because -

00:58:31,530 --> 00:58:34,550
joshua BPF code we really wanted to show

00:58:33,660 --> 00:58:37,880
the Lua

00:58:34,550 --> 00:58:40,220
when we get dumped and in line it's not

00:58:37,880 --> 00:58:41,930
the seeker so you can get get a feeling

00:58:40,220 --> 00:58:43,430
that that I generated this and what

00:58:41,930 --> 00:58:45,770
today I can look at the simple

00:58:43,430 --> 00:58:47,570
instruction just to demystify that this

00:58:45,770 --> 00:58:49,820
this whole thing that just the elf

00:58:47,570 --> 00:58:51,560
island is magic right you can actually

00:58:49,820 --> 00:58:53,540
look into it with standard tools it's

00:58:51,560 --> 00:58:55,130
not not that matching and I had some

00:58:53,540 --> 00:58:56,330
issues I think initially when out before

00:58:55,130 --> 00:58:58,040
maybe discovering the you limit things

00:58:56,330 --> 00:58:59,750
that I I mean I was going going through

00:58:58,040 --> 00:59:01,730
saying like really are like other

00:58:59,750 --> 00:59:03,350
sections really there so it's always

00:59:01,730 --> 00:59:08,450
good to understand what you're working

00:59:03,350 --> 00:59:10,190
with whenever you can so I also talked a

00:59:08,450 --> 00:59:13,700
little bit about everybody's favorite

00:59:10,190 --> 00:59:15,260
debugging tool print K and what you can

00:59:13,700 --> 00:59:18,830
do while running in your program if you

00:59:15,260 --> 00:59:23,060
need to so there's a there's this BPF

00:59:18,830 --> 00:59:24,470
debug piece that was added and you can

00:59:23,060 --> 00:59:26,150
see in the comment here that yes we're

00:59:24,470 --> 00:59:28,880
so kindly put in there that you can you

00:59:26,150 --> 00:59:30,620
can actually just examine what's in the

00:59:28,880 --> 00:59:32,870
trace pipe file and you can see things

00:59:30,620 --> 00:59:36,470
that happen this was important when I

00:59:32,870 --> 00:59:39,080
was doing some initial initial work to

00:59:36,470 --> 00:59:41,030
see what what is going on you shouldn't

00:59:39,080 --> 00:59:43,130
leave this on for production dues

00:59:41,030 --> 00:59:47,120
because enough but heavily to call the

00:59:43,130 --> 00:59:49,700
the p5 trace print k and so we we make

00:59:47,120 --> 00:59:50,960
it look from the sea side we restrict to

00:59:49,700 --> 00:59:52,670
see if we make it look like if we have a

00:59:50,960 --> 00:59:54,500
print function we actually don't have

00:59:52,670 --> 00:59:56,360
them write what you have as you can use

00:59:54,500 --> 00:59:58,220
the trace infrastructure to do this

00:59:56,360 --> 01:00:01,220
print k and we actually have to remember

00:59:58,220 --> 01:00:04,040
it ends up in the file and so that you

01:00:01,220 --> 01:00:06,440
have to list but it's not the key is it

01:00:04,040 --> 01:00:08,450
it's not so it's not so magical that you

01:00:06,440 --> 01:00:09,590
don't get any output at all you get to

01:00:08,450 --> 01:00:11,510
see what's going on you get to see

01:00:09,590 --> 01:00:13,340
what's happening if you want to put that

01:00:11,510 --> 01:00:15,980
in there I think the line above this has

01:00:13,340 --> 01:00:20,630
like an undef debug or something or the

01:00:15,980 --> 01:00:20,840
50 bug yeah one commented out huh all

01:00:20,630 --> 01:00:23,420
right

01:00:20,840 --> 01:00:26,840
so a couple of things we could think

01:00:23,420 --> 01:00:30,350
about so if you wanted to make this a

01:00:26,840 --> 01:00:32,090
whitelist app instead you I believe you

01:00:30,350 --> 01:00:33,890
could run those three commands and

01:00:32,090 --> 01:00:39,260
recompile and suddenly you'd have a

01:00:33,890 --> 01:00:41,330
whitelist a whitelist application that

01:00:39,260 --> 01:00:43,280
would be kind of cool if you were if you

01:00:41,330 --> 01:00:44,390
decided like hey I just I need to check

01:00:43,280 --> 01:00:46,070
these these things i want to keep my

01:00:44,390 --> 01:00:48,110
list short you want to reduce the size

01:00:46,070 --> 01:00:51,290
of your hash map all sorts of benefits

01:00:48,110 --> 01:00:53,780
doing whitelisting throughout a

01:00:51,290 --> 01:00:57,140
blacklist an entire subnet there's a new

01:00:53,780 --> 01:00:59,900
type for that so thanks for Daniel max

01:00:57,140 --> 01:01:01,700
for implementing that I think it maybe

01:00:59,900 --> 01:01:03,350
went through a little bit of flux at the

01:01:01,700 --> 01:01:05,210
beginning but I think some it's pretty

01:01:03,350 --> 01:01:07,910
it works now maybe yeah

01:01:05,210 --> 01:01:09,080
good now Dodie and snores the pillows

01:01:07,910 --> 01:01:12,890
mostly that's right so I'll just stop

01:01:09,080 --> 01:01:15,650
talking to him ah no I won't so that

01:01:12,890 --> 01:01:17,060
would be pretty easy to add you know

01:01:15,650 --> 01:01:18,560
again new command-line options pretty

01:01:17,060 --> 01:01:20,330
simple but I feel like there's a

01:01:18,560 --> 01:01:23,270
opportunity for growth with this or with

01:01:20,330 --> 01:01:27,020
other apps and then see right on time

01:01:23,270 --> 01:01:28,700
I got it ipv6 blacklisting that

01:01:27,020 --> 01:01:32,960
obviously is there people they accept

01:01:28,700 --> 01:01:35,690
caches pithre yeah we will so again

01:01:32,960 --> 01:01:36,590
really simple but just ran out of time

01:01:35,690 --> 01:01:38,810
but I actually wanted to implement

01:01:36,590 --> 01:01:41,210
benefits in exam right because we know

01:01:38,810 --> 01:01:42,340
we know how useful that is all right so

01:01:41,210 --> 01:01:44,890
maybe what's next

01:01:42,340 --> 01:01:46,940
some of these features we talked about

01:01:44,890 --> 01:01:49,790
so one of the other things that ran out

01:01:46,940 --> 01:01:52,370
of time to implement is the ability to

01:01:49,790 --> 01:01:54,860
keep the Maps persistent so that you

01:01:52,370 --> 01:01:56,660
have a consistent blacklist that's

01:01:54,860 --> 01:01:58,820
available and port blacklist right now

01:01:56,660 --> 01:02:00,530
we're really using this this map from

01:01:58,820 --> 01:02:02,390
from and and seeing it's over Dave

01:02:00,530 --> 01:02:04,460
mounted at the file system I'm just

01:02:02,390 --> 01:02:07,310
going to open this and and we used that

01:02:04,460 --> 01:02:09,590
to the file system or in my paid program

01:02:07,310 --> 01:02:12,070
but what this is actually not valid

01:02:09,590 --> 01:02:14,780
because if I changed my PPF program

01:02:12,070 --> 01:02:17,870
enough that I I want to use another

01:02:14,780 --> 01:02:19,550
layout of the map I fake you see that oh

01:02:17,870 --> 01:02:21,950
there's a map I'm just going to take

01:02:19,550 --> 01:02:23,660
this map and use that in my program but

01:02:21,950 --> 01:02:26,270
this egg will actually have to the

01:02:23,660 --> 01:02:28,280
invalid layout because I changed my

01:02:26,270 --> 01:02:30,560
people a program to actually just a map

01:02:28,280 --> 01:02:32,440
in the new way but then I'm cheating

01:02:30,560 --> 01:02:34,910
myself but tango pokeman solve that

01:02:32,440 --> 01:02:36,500
because you can actually open the file

01:02:34,910 --> 01:02:39,710
and you can you can read some of the

01:02:36,500 --> 01:02:41,960
information about the file to see in the

01:02:39,710 --> 01:02:44,510
open the file the scripture you can

01:02:41,960 --> 01:02:47,690
access some information about what what

01:02:44,510 --> 01:02:49,910
map type it is what the size of the key

01:02:47,690 --> 01:02:53,390
and value is and from that you can

01:02:49,910 --> 01:02:56,150
deduct that I I'm using this this map

01:02:53,390 --> 01:02:58,370
here is it's the wrong size so a better

01:02:56,150 --> 01:03:00,140
like create a new map or to something

01:02:58,370 --> 01:03:01,580
else right right right to the user you

01:03:00,140 --> 01:03:04,160
have to read up your whole program

01:03:01,580 --> 01:03:06,830
and if you ate and Daniel Bergman

01:03:04,160 --> 01:03:08,510
actually implemented s45 to be - we just

01:03:06,830 --> 01:03:11,060
get past the time to learn right so

01:03:08,510 --> 01:03:13,910
we'll steal that code and so we know

01:03:11,060 --> 01:03:15,230
does there's a buck there I was

01:03:13,910 --> 01:03:16,700
wondering when you just might have to

01:03:15,230 --> 01:03:22,010
slice Oh Daniel didn't point it out

01:03:16,700 --> 01:03:23,840
right so and then the other baby ability

01:03:22,010 --> 01:03:25,330
to have like an import option so if

01:03:23,840 --> 01:03:27,620
you've already got a long list of things

01:03:25,330 --> 01:03:29,300
you know add the ability to bring in a

01:03:27,620 --> 01:03:31,880
whole new whole bunch of entries at the

01:03:29,300 --> 01:03:33,320
same time you could merge it you could

01:03:31,880 --> 01:03:34,700
do other things that would be really

01:03:33,320 --> 01:03:36,410
nice if you had a fleet of machines and

01:03:34,700 --> 01:03:38,090
you were rolling up a new one and wanted

01:03:36,410 --> 01:03:41,770
to make sure they had the same lists

01:03:38,090 --> 01:03:41,770
everywhere or you have a riot of things

01:03:41,890 --> 01:03:46,760
the last one that I think is also

01:03:44,690 --> 01:03:49,310
interesting is to think about dividing

01:03:46,760 --> 01:03:52,310
up right now the code as it exists first

01:03:49,310 --> 01:03:55,370
parsons ipv4 and then the last call is

01:03:52,310 --> 01:03:57,220
that parses the ports TCP UDP ports I

01:03:55,370 --> 01:04:01,460
think it would be more compelling is to

01:03:57,220 --> 01:04:06,710
you know use tail calls and a map and an

01:04:01,460 --> 01:04:08,300
array of programs and be able to say be

01:04:06,710 --> 01:04:09,830
able to very clearly say alright look I

01:04:08,300 --> 01:04:11,300
don't have anything in the port list so

01:04:09,830 --> 01:04:13,070
don't scan it because that's one of the

01:04:11,300 --> 01:04:14,780
issues right now where we're scanning

01:04:13,070 --> 01:04:16,310
every every packet even if we don't have

01:04:14,780 --> 01:04:17,690
anything in either one of those lists

01:04:16,310 --> 01:04:19,670
and so there's a lot of room for

01:04:17,690 --> 01:04:21,170
optimization and right I'm also features

01:04:19,670 --> 01:04:23,540
that you could put in a tail call

01:04:21,170 --> 01:04:25,310
because every day optimizing the number

01:04:23,540 --> 01:04:27,680
of instructions we want to push push

01:04:25,310 --> 01:04:29,360
into this really really cool paso so

01:04:27,680 --> 01:04:31,370
what you're saying is that yeah you

01:04:29,360 --> 01:04:33,500
could say if you don't use the deport

01:04:31,370 --> 01:04:37,370
number function we will put that into a

01:04:33,500 --> 01:04:38,930
separate vpf program and use the tail

01:04:37,370 --> 01:04:40,670
call for that the reason for that is

01:04:38,930 --> 01:04:44,030
that then we actually don't have to load

01:04:40,670 --> 01:04:46,130
the instructions and and put pressure on

01:04:44,030 --> 01:04:48,380
the instruction cast because you might

01:04:46,130 --> 01:04:50,120
never load this program right and then

01:04:48,380 --> 01:04:51,890
you could also give you the chance to

01:04:50,120 --> 01:04:53,570
have like maybe more custom pipeline

01:04:51,890 --> 01:04:56,180
like if you felt like some things were

01:04:53,570 --> 01:04:58,490
important and some things weren't you

01:04:56,180 --> 01:04:59,780
could do that so who knows how far we'll

01:04:58,490 --> 01:05:02,690
take it so I also have like a whole an

01:04:59,780 --> 01:05:04,550
eye chart of references man bps probably

01:05:02,690 --> 01:05:07,190
the most important one but no this is

01:05:04,550 --> 01:05:08,870
really we borrowed from a lot of a lot

01:05:07,190 --> 01:05:13,310
of folks that have done things in the

01:05:08,870 --> 01:05:15,230
past looked at a lot of things there's a

01:05:13,310 --> 01:05:17,240
ton of resource online about this and we

01:05:15,230 --> 01:05:19,010
want to just provide a real concrete

01:05:17,240 --> 01:05:21,530
example of how to write a program and

01:05:19,010 --> 01:05:23,000
I'd say people make hopefully make it

01:05:21,530 --> 01:05:24,590
easier for people to get started that's

01:05:23,000 --> 01:05:28,040
right so they don't think this is all

01:05:24,590 --> 01:05:39,109
magic that's it thank you very much

01:05:28,040 --> 01:05:42,410
demystifying yeah so so another another

01:05:39,109 --> 01:05:44,300
question yeah um you brought up

01:05:42,410 --> 01:05:46,280
optimization there and that was like

01:05:44,300 --> 01:05:49,100
sort of an external optimization right

01:05:46,280 --> 01:05:51,800
have you looked at all that how well at

01:05:49,100 --> 01:05:53,720
IBM optimizes your code like if you have

01:05:51,800 --> 01:05:55,609
a bunch of functions like what Marcin

01:05:53,720 --> 01:05:56,990
was showing yesterday where they call a

01:05:55,609 --> 01:05:57,530
bunch of functions that all kind of do

01:05:56,990 --> 01:06:00,440
the same thing

01:05:57,530 --> 01:06:03,260
does it go and does it really use the

01:06:00,440 --> 01:06:04,580
full optimizer can it actually apps all

01:06:03,260 --> 01:06:09,410
of these things I would I would like

01:06:04,580 --> 01:06:11,570
Alexi to answer back okay Jana thought

01:06:09,410 --> 01:06:14,690
maybe you'd actually I don't know I

01:06:11,570 --> 01:06:16,340
don't know I wanted once one of the

01:06:14,690 --> 01:06:17,450
reasons that you sold who used object um

01:06:16,340 --> 01:06:18,920
because I wanted to look at the

01:06:17,450 --> 01:06:21,080
instructions and stuff like that right

01:06:18,920 --> 01:06:22,670
but it turned out to be a little harder

01:06:21,080 --> 01:06:24,740
and had to have a newer version of LLVM

01:06:22,670 --> 01:06:26,090
and sausage resize actually wanted to

01:06:24,740 --> 01:06:27,830
look at the stuff but so I actually

01:06:26,090 --> 01:06:29,600
didn't have time to check it I think the

01:06:27,830 --> 01:06:31,160
the tool incompatible are not

01:06:29,600 --> 01:06:33,380
incompatibility with the the newness

01:06:31,160 --> 01:06:35,000
from for me for an experience standpoint

01:06:33,380 --> 01:06:37,369
of some of these tools made it hard to

01:06:35,000 --> 01:06:39,800
know like it's sort of like my first

01:06:37,369 --> 01:06:40,850
step was like did it actually work you

01:06:39,800 --> 01:06:42,560
know and it was like all right cool it

01:06:40,850 --> 01:06:46,100
works maybe it's not perfectly optimal

01:06:42,560 --> 01:06:48,770
I'll point out to that right now out of

01:06:46,100 --> 01:06:51,170
the box arm doesn't quite work there's a

01:06:48,770 --> 01:06:52,460
small patch needed I tried to socialise

01:06:51,170 --> 01:06:55,090
it a little bit there's some some in

01:06:52,460 --> 01:06:57,680
line assembly that's in some of the arch

01:06:55,090 --> 01:06:59,060
the arm arch files that I'm hoping to

01:06:57,680 --> 01:07:00,710
get resolved pretty soon so this works

01:06:59,060 --> 01:07:02,960
well kind of a known problem but it's

01:07:00,710 --> 01:07:04,820
for me personally it's sort of like we

01:07:02,960 --> 01:07:06,590
can't can't demo this we can't do this

01:07:04,820 --> 01:07:08,150
easily other people can't use it let's

01:07:06,590 --> 01:07:09,320
make the make it easy to consume so I'm

01:07:08,150 --> 01:07:12,470
hoping we'll get that resolved pretty

01:07:09,320 --> 01:07:13,970
quick and the distributions are catching

01:07:12,470 --> 01:07:16,640
up right before we had you have to

01:07:13,970 --> 01:07:18,950
recompile into them but now actually the

01:07:16,640 --> 01:07:20,869
diversions in the disbanded distribution

01:07:18,950 --> 01:07:22,480
are starting to have versions of a band

01:07:20,869 --> 01:07:24,130
which supports this and

01:07:22,480 --> 01:07:25,740
moves out of the box and that's pretty

01:07:24,130 --> 01:07:28,570
great there's some great great

01:07:25,740 --> 01:07:31,450
improvements coming that Alexa

01:07:28,570 --> 01:07:33,310
implemented in the van right and it will

01:07:31,450 --> 01:07:35,380
show up in the distribution so we don't

01:07:33,310 --> 01:07:37,119
have to recompile the whole inch wrench

01:07:35,380 --> 01:07:38,920
it'll get easier hopefully the

01:07:37,119 --> 01:07:46,210
enterprise ones will follow - and and

01:07:38,920 --> 01:07:49,780
everyone will be able to use it anymore

01:07:46,210 --> 01:07:52,990
Christians I don't think so come on any

01:07:49,780 --> 01:07:55,450
more questions no uh nothing from the

01:07:52,990 --> 01:07:56,619
hallway each other so I'm just asking

01:07:55,450 --> 01:07:59,560
the how I was doing

01:07:56,619 --> 01:08:01,270
all right there is life happy are they

01:07:59,560 --> 01:08:04,359
going into the penalty box I'm just

01:08:01,270 --> 01:08:09,400
gonna say wrap it up we're gonna have a

01:08:04,359 --> 01:08:11,080
excellent key not coming up yeah we're

01:08:09,400 --> 01:08:18,479
done we roll it applause guys

01:08:11,080 --> 01:08:18,479

YouTube URL: https://www.youtube.com/watch?v=iBkR4gvjxtE


