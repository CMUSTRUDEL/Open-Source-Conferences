Title: Netdev 0x13 - Accelerating QUIC via Hardware Offloads Through a Socket Interface
Publication date: 2019-05-26
Playlist: Netdev 0x13 - Day 3
Description: 
	Joshua Hay discusses an interface to support hardware offloads used by QUIC such as cryptography and transmit segmentation.
In this talk he describes an effort with his co-authors for an implementation
and proposes APIs similar to KTLS. He also presents performance measurements and results using the chromium QUIC implementation.

More info:
https://netdevconf.org/0x13/news.html?talk-quic-offload
Captions: 
	00:00:00,030 --> 00:00:04,049
we are here to present you the

00:00:01,500 --> 00:00:06,359
accelerating quick via hardware uploads

00:00:04,049 --> 00:00:08,730
through a socket interface presentation

00:00:06,359 --> 00:00:10,769
that was our PLC we unite to actually

00:00:08,730 --> 00:00:13,230
try to accelerate something in the quic

00:00:10,769 --> 00:00:15,089
protocol my name is Matty mechanical

00:00:13,230 --> 00:00:18,539
Sookie I work for Intel and I will

00:00:15,089 --> 00:00:23,369
present that with Joshua hey and I also

00:00:18,539 --> 00:00:27,029
work for Intel so the agenda for today

00:00:23,369 --> 00:00:29,010
is a bit of background of course no not

00:00:27,029 --> 00:00:32,250
everyone here knows what quick is so we

00:00:29,010 --> 00:00:34,140
will tell couple words about it then we

00:00:32,250 --> 00:00:37,050
will say why we actually tried to

00:00:34,140 --> 00:00:39,960
offload and what we uploaded and then we

00:00:37,050 --> 00:00:43,680
will switch to Josh's parts which is a

00:00:39,960 --> 00:00:50,550
socket interface so what is quick who

00:00:43,680 --> 00:00:58,530
doesn't know what quick is ok I will

00:00:50,550 --> 00:01:01,230
tell you and about it anyway so okay so

00:00:58,530 --> 00:01:03,930
a quick is reliable transport protocol

00:01:01,230 --> 00:01:07,380
layered on top of UDP it's alternative

00:01:03,930 --> 00:01:10,170
to TCP with TLS with a lower connection

00:01:07,380 --> 00:01:12,750
setup latency and then the TCP it

00:01:10,170 --> 00:01:14,880
supports the zero round-trip time with

00:01:12,750 --> 00:01:17,009
time resumes for the connections that

00:01:14,880 --> 00:01:18,990
were already established and one

00:01:17,009 --> 00:01:22,140
round-trip time for the connections that

00:01:18,990 --> 00:01:24,619
are new it supports streams within

00:01:22,140 --> 00:01:30,180
connections and the case and embedded

00:01:24,619 --> 00:01:33,090
encryption and authentication yes so but

00:01:30,180 --> 00:01:35,700
of course with all new great protocols

00:01:33,090 --> 00:01:38,540
there are some challenges when Google

00:01:35,700 --> 00:01:41,970
tried to actually started deploying the

00:01:38,540 --> 00:01:46,049
quick to serve the card videos over

00:01:41,970 --> 00:01:50,009
YouTube they found out that the cost of

00:01:46,049 --> 00:01:52,530
the CPU cost of transmitting data over

00:01:50,009 --> 00:01:57,090
quick is about two or three times more

00:01:52,530 --> 00:02:01,890
than TCP with TLS and it actually formed

00:01:57,090 --> 00:02:04,380
a barrier to adoption because well no

00:02:01,890 --> 00:02:07,469
one wants to spend cycles right before

00:02:04,380 --> 00:02:10,560
just transmitting data the reason for

00:02:07,469 --> 00:02:16,470
that is that TCP was optimized over the

00:02:10,560 --> 00:02:18,900
and TDP was always not so much so we

00:02:16,470 --> 00:02:22,920
decided that we will try to offload some

00:02:18,900 --> 00:02:27,720
parts of quick to actually see how much

00:02:22,920 --> 00:02:31,100
can we improve that and also we wanted

00:02:27,720 --> 00:02:33,660
to start now because it's still not

00:02:31,100 --> 00:02:37,230
finalized so we can still put some

00:02:33,660 --> 00:02:41,330
changes in today IETF aspect to actually

00:02:37,230 --> 00:02:44,760
make it affordable and of course yet

00:02:41,330 --> 00:02:46,920
ok so what we want wanted to offload

00:02:44,760 --> 00:02:51,750
first think we try to offload was a

00:02:46,920 --> 00:02:56,700
cryptography quick protocol by uses two

00:02:51,750 --> 00:02:59,310
methods of encryption one is AES GCM and

00:02:56,700 --> 00:03:04,980
other is such a poly for our PLC we

00:02:59,310 --> 00:03:08,700
decided to use the AES GCM then we try

00:03:04,980 --> 00:03:10,890
to upload the segmentation luckily the

00:03:08,700 --> 00:03:16,079
patches for the software segmentation

00:03:10,890 --> 00:03:18,810
came up when we did the PLC and then we

00:03:16,079 --> 00:03:20,970
know of course offload strike zones but

00:03:18,810 --> 00:03:25,290
everyone does it right now so that's not

00:03:20,970 --> 00:03:26,970
a part of of this presentation and of

00:03:25,290 --> 00:03:29,640
course the challenge is that the quick

00:03:26,970 --> 00:03:31,500
stack runs in the user space so we

00:03:29,640 --> 00:03:34,320
actually needed to come up with some

00:03:31,500 --> 00:03:38,150
creative ideas how to pass everything we

00:03:34,320 --> 00:03:41,190
need to the hardware from the user space

00:03:38,150 --> 00:03:45,750
ok so couple words about our test

00:03:41,190 --> 00:03:49,170
topology we use the quick toy stack that

00:03:45,750 --> 00:03:51,570
is part of Google's chromium project the

00:03:49,170 --> 00:03:53,489
toy stack actually is not really

00:03:51,570 --> 00:03:56,370
designed for performance and scalability

00:03:53,489 --> 00:04:01,200
and runs only on single threats so we

00:03:56,370 --> 00:04:04,739
had to crack it a bit and actually to

00:04:01,200 --> 00:04:08,850
show any results and scale it scale it

00:04:04,739 --> 00:04:12,390
up to do that we actually use the socket

00:04:08,850 --> 00:04:14,910
reuse and reuse port and sockets reuse

00:04:12,390 --> 00:04:18,209
address to all over running more than

00:04:14,910 --> 00:04:20,159
one instance of the quick server on the

00:04:18,209 --> 00:04:24,200
same EDP board because our hardware

00:04:20,159 --> 00:04:24,200
actually supports one port or now

00:04:24,300 --> 00:04:32,770
and we use the error RSS to spread the

00:04:27,490 --> 00:04:36,370
connection between the other servers we

00:04:32,770 --> 00:04:38,650
run those tests well okay so maybe let's

00:04:36,370 --> 00:04:41,080
start we also had to modify the chromium

00:04:38,650 --> 00:04:45,160
stack to send non encrypted traffic and

00:04:41,080 --> 00:04:48,330
receive non encrypted packets over this

00:04:45,160 --> 00:04:54,910
socket and through our hardware so

00:04:48,330 --> 00:04:58,720
basically our hardware our hardware was

00:04:54,910 --> 00:05:01,210
supposed to encrypt our packets and also

00:04:58,720 --> 00:05:05,710
segment them later and we needed to

00:05:01,210 --> 00:05:07,600
somehow pass passes all the keys and and

00:05:05,710 --> 00:05:11,919
parameters that are were needed to

00:05:07,600 --> 00:05:14,950
actually offload that we used the excel

00:05:11,919 --> 00:05:18,210
700 stand connected with the FPGA that

00:05:14,950 --> 00:05:23,230
actually did all this heavy lifting and

00:05:18,210 --> 00:05:28,200
we ran it on the dual core server with a

00:05:23,230 --> 00:05:30,390
bit of RAM to actually allow the scaling

00:05:28,200 --> 00:05:33,490
[Music]

00:05:30,390 --> 00:05:38,290
okay yeah and all the servers that we

00:05:33,490 --> 00:05:40,300
were running we we used 15 instances of

00:05:38,290 --> 00:05:47,110
the server were bound to the same Numa

00:05:40,300 --> 00:05:50,169
note that Nick was connected assumptions

00:05:47,110 --> 00:05:52,000
of course since this was a POC we had to

00:05:50,169 --> 00:05:55,200
make some assumptions to actually make

00:05:52,000 --> 00:06:00,310
it happen so we use the G quick version

00:05:55,200 --> 00:06:05,290
qo 44 and our hardware agent actually

00:06:00,310 --> 00:06:08,740
was supposed supposed to support IETF

00:06:05,290 --> 00:06:10,990
draft 11 packet format so we had to

00:06:08,740 --> 00:06:16,419
modify the stack to actually conform to

00:06:10,990 --> 00:06:18,990
that standard we had to yes and since we

00:06:16,419 --> 00:06:23,260
use the IETF draft 11 packet number

00:06:18,990 --> 00:06:26,229
encryption wasn't there yet key exchange

00:06:23,260 --> 00:06:30,940
is still owned by the stock to prevent

00:06:26,229 --> 00:06:32,919
the ossification and SAS were programmed

00:06:30,940 --> 00:06:34,210
to the hardware only when the connection

00:06:32,919 --> 00:06:38,949
was M

00:06:34,210 --> 00:06:40,810
early negotiated by the stack and we

00:06:38,949 --> 00:06:42,759
enabled the offload only for the short

00:06:40,810 --> 00:06:48,460
header packets since all the data is

00:06:42,759 --> 00:06:54,099
transmitted using them so first we

00:06:48,460 --> 00:06:56,860
started with the crypto offload and we

00:06:54,099 --> 00:07:00,069
gained actually about 13 percent of the

00:06:56,860 --> 00:07:03,069
fruit and 13% better

00:07:00,069 --> 00:07:07,000
CPU utilization and was important on

00:07:03,069 --> 00:07:09,009
this chart actually the CPU utilization

00:07:07,000 --> 00:07:11,410
is drawn with the lines and bars

00:07:09,009 --> 00:07:14,320
represent the throughput for every

00:07:11,410 --> 00:07:16,990
second of the tests that were that the

00:07:14,320 --> 00:07:19,690
test was run and the most important part

00:07:16,990 --> 00:07:23,080
is that when we are saturating the CPU

00:07:19,690 --> 00:07:26,770
utilization for those 15 servers we see

00:07:23,080 --> 00:07:31,599
that we gained a lot of robots by using

00:07:26,770 --> 00:07:34,300
those decrypt offload and as a second

00:07:31,599 --> 00:07:38,199
step we also enabled the segmentation of

00:07:34,300 --> 00:07:41,169
lot and here we can see that we got

00:07:38,199 --> 00:07:45,870
about 42 percent gain in the fruit boot

00:07:41,169 --> 00:07:49,150
and 16 percent of the CPU utilization

00:07:45,870 --> 00:07:51,159
and of course we the transmission time

00:07:49,150 --> 00:07:54,159
for the data that we transmitted this

00:07:51,159 --> 00:07:59,380
was done for 15 servers 60 clients and

00:07:54,159 --> 00:08:03,430
10 streams each and 15 max files we see

00:07:59,380 --> 00:08:07,509
the significant gain in the time of the

00:08:03,430 --> 00:08:11,050
test and of course all those results are

00:08:07,509 --> 00:08:14,460
from the POC so there might be you know

00:08:11,050 --> 00:08:20,440
the results might be a bit different so

00:08:14,460 --> 00:08:22,479
now to the job so as Mark mentioned we

00:08:20,440 --> 00:08:24,580
have to program the keys into the

00:08:22,479 --> 00:08:26,070
hardware from user space which is a bit

00:08:24,580 --> 00:08:29,289
of a problem

00:08:26,070 --> 00:08:32,770
so we we were kind of proposing a

00:08:29,289 --> 00:08:35,020
generic crypto offload interface similar

00:08:32,770 --> 00:08:37,360
to k2 s or TLS offload just in the sense

00:08:35,020 --> 00:08:39,760
that you send the keys through socket

00:08:37,360 --> 00:08:42,490
options basically the first thing we had

00:08:39,760 --> 00:08:44,620
to do was enable the UDP upper layer

00:08:42,490 --> 00:08:47,170
protocol infrastructure because it

00:08:44,620 --> 00:08:50,380
wasn't there at the time and one of the

00:08:47,170 --> 00:08:53,680
big caveats to doing this is we have to

00:08:50,380 --> 00:08:56,800
bind the socket to the device we are

00:08:53,680 --> 00:08:58,959
offloading to we can't let a packet get

00:08:56,800 --> 00:09:00,760
sent down in the clear and then go out

00:08:58,959 --> 00:09:03,699
some other port where yes a doesn't

00:09:00,760 --> 00:09:05,910
exist that would be a big security the

00:09:03,699 --> 00:09:09,010
other reason we need to do this is to

00:09:05,910 --> 00:09:11,620
call the hooks into the driver to

00:09:09,010 --> 00:09:14,740
program the hardware we need the net dev

00:09:11,620 --> 00:09:16,449
reference so we can access the dev ops

00:09:14,740 --> 00:09:25,690
structure which I will show you in a few

00:09:16,449 --> 00:09:27,850
seconds okay so this is just an example

00:09:25,690 --> 00:09:30,520
flow of the top part of that previous

00:09:27,850 --> 00:09:33,940
image so you start with the the chromium

00:09:30,520 --> 00:09:38,500
stack you set suck up to with this new

00:09:33,940 --> 00:09:39,880
socket layer option not tied to the name

00:09:38,500 --> 00:09:41,890
but this that's what we decided to go

00:09:39,880 --> 00:09:43,839
with for now and you have the command

00:09:41,890 --> 00:09:46,089
add si TX

00:09:43,839 --> 00:09:48,279
we're adding the transmit security

00:09:46,089 --> 00:09:50,290
Association and then the add si

00:09:48,279 --> 00:09:52,300
structure there contains all the keys

00:09:50,290 --> 00:09:55,540
and necessary information to do the

00:09:52,300 --> 00:09:58,240
offload so goes to the socket and then

00:09:55,540 --> 00:10:00,339
when it's a socket layer we have our our

00:09:58,240 --> 00:10:03,520
net dev and the register dev ops struct

00:10:00,339 --> 00:10:05,079
with the hook into the driver and that's

00:10:03,520 --> 00:10:09,459
that calls into the driver and we have

00:10:05,079 --> 00:10:11,110
our specific function to format the data

00:10:09,459 --> 00:10:13,959
we need to send to the hardware it does

00:10:11,110 --> 00:10:19,029
whatever whatever's required at that

00:10:13,959 --> 00:10:22,810
stage and this is a bit of an eye chart

00:10:19,029 --> 00:10:25,150
but I wanted to provide a whole image of

00:10:22,810 --> 00:10:27,459
what we're proposing so these are all

00:10:25,150 --> 00:10:31,240
the commands we would need so we have an

00:10:27,459 --> 00:10:33,279
init which does the binding and whatever

00:10:31,240 --> 00:10:35,920
else needs to be done for that offload

00:10:33,279 --> 00:10:38,350
we have the add si 4 TX and rx

00:10:35,920 --> 00:10:41,770
we have the update which we need for

00:10:38,350 --> 00:10:43,390
quick because the we need we need the

00:10:41,770 --> 00:10:45,220
full packet number to do the encryption

00:10:43,390 --> 00:10:47,500
and that's not sent down with each

00:10:45,220 --> 00:10:50,709
packet so periodically the chromium

00:10:47,500 --> 00:10:52,720
stack will update the full packet number

00:10:50,709 --> 00:10:55,990
in the hardware database so we can use

00:10:52,720 --> 00:10:59,290
that to construct the nuts and then

00:10:55,990 --> 00:11:00,579
dweet si we have a get caps

00:10:59,290 --> 00:11:03,790
so we know that the hardware is actually

00:11:00,579 --> 00:11:06,339
capable of doing this offload and then

00:11:03,790 --> 00:11:08,380
this offload okay hook on these these

00:11:06,339 --> 00:11:10,269
last two are get socket options so it

00:11:08,380 --> 00:11:13,060
can be returned to the stack but the

00:11:10,269 --> 00:11:14,560
offload okay is to query the state of

00:11:13,060 --> 00:11:17,769
the hardware to make sure we can still

00:11:14,560 --> 00:11:19,959
offload certain essays so if it was

00:11:17,769 --> 00:11:21,610
reset and all the essays are gone you

00:11:19,959 --> 00:11:26,199
don't want to be sending down anymore

00:11:21,610 --> 00:11:28,870
packets right so in an the stack can

00:11:26,199 --> 00:11:34,449
periodically check if it can still be

00:11:28,870 --> 00:11:37,329
using this offload okay back to the data

00:11:34,449 --> 00:11:39,130
plane so we didn't actually implement

00:11:37,329 --> 00:11:43,240
this because we were mostly focused on

00:11:39,130 --> 00:11:46,440
transmit excuse me

00:11:43,240 --> 00:11:49,959
right now we have a mechanism to pass

00:11:46,440 --> 00:11:52,360
metadata to the driver from the hardware

00:11:49,959 --> 00:11:56,110
but we don't really have a solid way to

00:11:52,360 --> 00:11:58,569
do that to the user space stack so our

00:11:56,110 --> 00:12:01,600
proposal is to basically extract the

00:11:58,569 --> 00:12:04,240
metadata in the driver store it in the

00:12:01,600 --> 00:12:06,550
control buffer in the skb when that hits

00:12:04,240 --> 00:12:08,050
the socket layer it'll create a C

00:12:06,550 --> 00:12:12,040
message header and pass it up to the

00:12:08,050 --> 00:12:13,959
stack and hopefully that's that works at

00:12:12,040 --> 00:12:15,490
scale I'm not really sure because we

00:12:13,959 --> 00:12:19,149
didn't get to flush this out that's what

00:12:15,490 --> 00:12:23,019
the under construction is for all right

00:12:19,149 --> 00:12:25,769
on to segmentation offload so the

00:12:23,019 --> 00:12:29,310
current segmentation support in chromium

00:12:25,769 --> 00:12:32,819
requires padding of the quick packets

00:12:29,310 --> 00:12:36,279
because of how it frames each packet so

00:12:32,819 --> 00:12:38,079
if we didn't have the padding and you

00:12:36,279 --> 00:12:40,180
kind of took it out in that red circle

00:12:38,079 --> 00:12:42,579
you'd be chopping in the middle of a

00:12:40,180 --> 00:12:45,850
quick header which we can't allow so you

00:12:42,579 --> 00:12:47,230
have to pad two MSS and then send it

00:12:45,850 --> 00:12:50,740
through the socket we put it in our

00:12:47,230 --> 00:12:52,839
metadata and do our normal segmentation

00:12:50,740 --> 00:13:00,490
this has just done through standard C

00:12:52,839 --> 00:13:03,819
message headers and so we want to avoid

00:13:00,490 --> 00:13:06,880
the pattern the way we propose to do

00:13:03,819 --> 00:13:10,510
that is basically take multiple MSS

00:13:06,880 --> 00:13:11,930
values per quick segment and send it

00:13:10,510 --> 00:13:14,840
through the socket to draw

00:13:11,930 --> 00:13:18,440
and insert that as metadata to the

00:13:14,840 --> 00:13:19,820
hardware this has some limitations

00:13:18,440 --> 00:13:22,850
because you can only send so much

00:13:19,820 --> 00:13:23,990
metadata to hardware but this would work

00:13:22,850 --> 00:13:25,460
out much better because you don't have

00:13:23,990 --> 00:13:29,500
to send any and this is unnecessary

00:13:25,460 --> 00:13:38,090
petting excuse me you create an array of

00:13:29,500 --> 00:13:41,150
MSS C message headers pretty simple so

00:13:38,090 --> 00:13:43,790
this is an extension of proposing a

00:13:41,150 --> 00:13:45,440
flexible interface just cuz we're not

00:13:43,790 --> 00:13:48,170
sure where this is going yet but you

00:13:45,440 --> 00:13:50,420
could do something else to say abstract

00:13:48,170 --> 00:13:53,090
the nuts away from the hardware as well

00:13:50,420 --> 00:13:55,430
so just like you would send multiple MSS

00:13:53,090 --> 00:13:58,540
you could send the nonce per segment as

00:13:55,430 --> 00:14:01,340
as well probably as a C message header

00:13:58,540 --> 00:14:03,650
but it just kind of keeps things open

00:14:01,340 --> 00:14:05,150
but again we didn't implement this

00:14:03,650 --> 00:14:09,430
version because our hardware can't

00:14:05,150 --> 00:14:09,430
support it right now just to be clear

00:14:10,990 --> 00:14:19,490
okay so in summary we we saw performance

00:14:16,970 --> 00:14:24,320
improvements up to 16% for CPU

00:14:19,490 --> 00:14:26,720
utilization and 32% for throughput the

00:14:24,320 --> 00:14:29,360
two interfaces we're proposing are

00:14:26,720 --> 00:14:32,990
independent so you can have segmentation

00:14:29,360 --> 00:14:35,870
without crypto but the problem is the

00:14:32,990 --> 00:14:38,120
crypto offload is not possible unless we

00:14:35,870 --> 00:14:41,810
get some kind of interface to send the

00:14:38,120 --> 00:14:46,820
keys to the hardware and we wanted to

00:14:41,810 --> 00:14:48,500
make this a generic generic interface so

00:14:46,820 --> 00:14:51,760
maybe other protocols could possibly use

00:14:48,500 --> 00:14:55,190
it it's just a generic crypto offload

00:14:51,760 --> 00:14:58,100
now going back to some of the opens I

00:14:55,190 --> 00:15:00,560
mentioned you have to bind the socket to

00:14:58,100 --> 00:15:02,780
the device we initially did this with

00:15:00,560 --> 00:15:05,660
soo bind to device but I think that's

00:15:02,780 --> 00:15:09,080
deprecated now so we need a better way

00:15:05,660 --> 00:15:13,520
to do that I already raised the question

00:15:09,080 --> 00:15:14,750
about the ingress metadata and of course

00:15:13,520 --> 00:15:16,760
asking again if there are other

00:15:14,750 --> 00:15:19,120
protocols we could use such an interface

00:15:16,760 --> 00:15:19,120
for

00:15:20,950 --> 00:15:28,750
that's what we have are there any

00:15:22,450 --> 00:15:37,480
questions it's not oh that's somewhere

00:15:28,750 --> 00:15:40,329
okay so we can use it use what okay SSO

00:15:37,480 --> 00:15:41,459
a bunch of devices not deprecated I just

00:15:40,329 --> 00:15:50,740
read that somewhere

00:15:41,459 --> 00:15:53,829
okay sorta you can actually even use the

00:15:50,740 --> 00:15:55,980
C message mechanism do by to select your

00:15:53,829 --> 00:15:58,779
device on your way out of you

00:15:55,980 --> 00:16:00,160
in the C message but you can specify the

00:15:58,779 --> 00:16:01,899
device the interface that you're looking

00:16:00,160 --> 00:16:04,540
for if you're just using interface as a

00:16:01,899 --> 00:16:07,510
handle so that solves one problem we

00:16:04,540 --> 00:16:09,449
have the other problem of needing the

00:16:07,510 --> 00:16:13,149
net dev when we get to the socket layer

00:16:09,449 --> 00:16:15,250
to call the driver looks doc talk to

00:16:13,149 --> 00:16:17,199
that guy David a man over there this is

00:16:15,250 --> 00:16:19,300
exactly the problem yet would be our f3

00:16:17,199 --> 00:16:22,050
this is a salt problem there it's a

00:16:19,300 --> 00:16:22,050
little bit pattern

00:16:32,770 --> 00:16:37,180
thanks for that talk is this working

00:16:37,330 --> 00:16:44,120
repeat my question if it I doubt it um

00:16:41,560 --> 00:16:45,410
so if you're using the chromium stack

00:16:44,120 --> 00:16:49,700
implementation then you're probably

00:16:45,410 --> 00:16:52,490
doing G quick offload no we actually

00:16:49,700 --> 00:16:54,830
modified the stack to conform to the

00:16:52,490 --> 00:16:58,840
idea so I think dealers one point three

00:16:54,830 --> 00:17:00,440
sorry you're doing TLS one point three

00:16:58,840 --> 00:17:01,820
specifically let me ask you to a

00:17:00,440 --> 00:17:03,560
specific question or more to ask which

00:17:01,820 --> 00:17:07,780
is that I didn't see any mention of

00:17:03,560 --> 00:17:07,780
packet number encryption in here yeah

00:17:10,690 --> 00:17:15,890
okay so this doesn't have packet number

00:17:12,740 --> 00:17:17,870
in the fact that not yet needs to happen

00:17:15,890 --> 00:17:19,430
gate and that's one piece that I I think

00:17:17,870 --> 00:17:22,310
I think you're exactly right that using

00:17:19,430 --> 00:17:23,780
a general API for this is the right

00:17:22,310 --> 00:17:24,890
answer generally you don't want to do

00:17:23,780 --> 00:17:28,610
something that's absolutely quick

00:17:24,890 --> 00:17:30,050
specific right but there's that one

00:17:28,610 --> 00:17:33,620
piece of packet number encryption that

00:17:30,050 --> 00:17:35,360
might be quite specific because that's

00:17:33,620 --> 00:17:38,620
sort of a bit of a bespoke mechanism

00:17:35,360 --> 00:17:42,890
where you have to do this two staged

00:17:38,620 --> 00:17:44,270
encryption and that's something to think

00:17:42,890 --> 00:17:46,910
about if you thought about it already

00:17:44,270 --> 00:17:52,550
I'd like to hear your thoughts on how

00:17:46,910 --> 00:17:55,250
feasible you think that's gonna be we're

00:17:52,550 --> 00:17:58,130
a little pressed for time we were a

00:17:55,250 --> 00:18:00,800
little pressed for time so at one point

00:17:58,130 --> 00:18:03,860
we had the choice of doing packet number

00:18:00,800 --> 00:18:06,830
encryption versus doing segmentation so

00:18:03,860 --> 00:18:10,810
we chose to add the segmentation bit for

00:18:06,830 --> 00:18:14,750
these experiments because that would be

00:18:10,810 --> 00:18:18,740
we would be able to show a better CPU

00:18:14,750 --> 00:18:21,200
savings with segmentation with packet

00:18:18,740 --> 00:18:23,180
number encryption the thing that we

00:18:21,200 --> 00:18:24,860
would suss out is that there is some

00:18:23,180 --> 00:18:27,140
complication of implementing it in

00:18:24,860 --> 00:18:31,220
hardware and second is the additional

00:18:27,140 --> 00:18:36,380
latency that comes from you know doing

00:18:31,220 --> 00:18:38,750
that that flow and yeah that that's on

00:18:36,380 --> 00:18:42,140
the list to do at some point after this

00:18:38,750 --> 00:18:44,650
but I think a few months ago with your

00:18:42,140 --> 00:18:44,650
segmentation

00:18:47,620 --> 00:18:54,280
and just one more question on the on the

00:18:49,780 --> 00:18:55,570
MSS values that you mentioned am i

00:18:54,280 --> 00:18:58,150
understanding you correctly that there's

00:18:55,570 --> 00:19:04,780
a finite number of MSS values you can

00:18:58,150 --> 00:19:07,840
you can hold in hardware yes

00:19:04,780 --> 00:19:09,760
so as subsequent and misses values come

00:19:07,840 --> 00:19:11,470
in they are simply going to get added to

00:19:09,760 --> 00:19:14,290
the list of emesis where is that you

00:19:11,470 --> 00:19:15,430
already have what would they replace the

00:19:14,290 --> 00:19:18,790
existing value I'm not questioning

00:19:15,430 --> 00:19:20,860
existing a deeper vice down stack so I

00:19:18,790 --> 00:19:23,290
could basically literally send just a

00:19:20,860 --> 00:19:24,310
packet size with every packet yes yeah

00:19:23,290 --> 00:19:27,880
oh exit

00:19:24,310 --> 00:19:29,380
okay good enough thank you thank you for

00:19:27,880 --> 00:19:36,040
doing this work by the way it's really

00:19:29,380 --> 00:19:40,060
exciting yeah so I think this is on the

00:19:36,040 --> 00:19:43,210
right track a couple comments so before

00:19:40,060 --> 00:19:45,820
we do quick offload we need Kay quick in

00:19:43,210 --> 00:19:49,450
the same way that we had TLS and then k

00:19:45,820 --> 00:19:52,840
TLS and then TLS offload so we would

00:19:49,450 --> 00:19:54,400
want obviously 0 TSO for quick and then

00:19:52,840 --> 00:19:56,380
you have to move the crypto down into

00:19:54,400 --> 00:19:58,690
the kernel and then figure out how to

00:19:56,380 --> 00:20:02,500
offload that so be the normal path

00:19:58,690 --> 00:20:05,590
understand this is a POC that being said

00:20:02,500 --> 00:20:07,390
when they were developing quick the

00:20:05,590 --> 00:20:12,070
engineers are very adamant quick is not

00:20:07,390 --> 00:20:12,490
for the kernel and ok fine so I agree

00:20:12,070 --> 00:20:15,340
with that

00:20:12,490 --> 00:20:17,350
so we're not gonna have quick in the

00:20:15,340 --> 00:20:19,900
kernel which means the word quick should

00:20:17,350 --> 00:20:22,690
not never appear in the kernel what you

00:20:19,900 --> 00:20:27,690
have is a generic programmable thing

00:20:22,690 --> 00:20:31,510
that says this is how we program a UDP

00:20:27,690 --> 00:20:34,090
protocol that we can do G ro TSO on so

00:20:31,510 --> 00:20:36,340
that if that ever changes and that's one

00:20:34,090 --> 00:20:37,540
big aspect of quick certainly they want

00:20:36,340 --> 00:20:40,120
to be able to change the protocol on the

00:20:37,540 --> 00:20:41,980
fly which means we should be Oda just I

00:20:40,120 --> 00:20:44,950
don't know download a BPF program that

00:20:41,980 --> 00:20:46,360
describes it or whatever so we never

00:20:44,950 --> 00:20:48,700
have the word quick in the kernel we're

00:20:46,360 --> 00:20:50,380
never pinned by the protocol in the

00:20:48,700 --> 00:20:52,420
kernel same thing should apply to the

00:20:50,380 --> 00:20:55,060
hardware which I know is a little harder

00:20:52,420 --> 00:20:56,620
but in my view quick is the greatest

00:20:55,060 --> 00:20:59,290
example of why we need

00:20:56,620 --> 00:21:01,270
a programmable device and like I said

00:20:59,290 --> 00:21:02,680
chicken s Gianna they're adamant they

00:21:01,270 --> 00:21:04,990
want to be able to change the protocol

00:21:02,680 --> 00:21:06,940
at least encrypted part which is where

00:21:04,990 --> 00:21:08,980
you need that that segmentation be able

00:21:06,940 --> 00:21:11,800
to change that so we're gonna have to be

00:21:08,980 --> 00:21:15,400
very dynamic in order to satisfy those

00:21:11,800 --> 00:21:17,280
requirements it's a great track so I

00:21:15,400 --> 00:21:19,420
think we're on the right track but

00:21:17,280 --> 00:21:20,770
generalization and abstraction are gonna

00:21:19,420 --> 00:21:22,300
be really important you know obviously

00:21:20,770 --> 00:21:24,040
we're gonna want to apply all of this to

00:21:22,300 --> 00:21:25,450
other protocols besides a quick at some

00:21:24,040 --> 00:21:28,660
point yeah

00:21:25,450 --> 00:21:33,700
that was the intention thank you for

00:21:28,660 --> 00:21:35,650
about the 16% you mentioned and was have

00:21:33,700 --> 00:21:39,900
you tried just to do to the segmentation

00:21:35,650 --> 00:21:45,370
the tears of the USO apart without the

00:21:39,900 --> 00:21:50,290
the Crypt cripples yeah do you mean the

00:21:45,370 --> 00:21:53,760
16% of CPU yeah you mentioned 16% saving

00:21:50,290 --> 00:21:56,410
yeah that was for that combined right

00:21:53,760 --> 00:21:59,410
that was for the combined offload right

00:21:56,410 --> 00:22:03,550
with the it seems small improvement to

00:21:59,410 --> 00:22:05,500
me that because Mellanox did Jesus about

00:22:03,550 --> 00:22:08,920
the last year when the GSO was

00:22:05,500 --> 00:22:12,610
implemented by William last year Mannix

00:22:08,920 --> 00:22:15,780
implemented the GSO in the Benelux fire

00:22:12,610 --> 00:22:19,480
I think and they mention much higher

00:22:15,780 --> 00:22:22,720
improvement just doing the GSO part keep

00:22:19,480 --> 00:22:24,940
in mind that the quick stack also has to

00:22:22,720 --> 00:22:27,309
do some work to actually enable it so

00:22:24,940 --> 00:22:29,920
it's not just dropping the packets but

00:22:27,309 --> 00:22:33,280
the quick itself the stack needs to pass

00:22:29,920 --> 00:22:36,330
those packets and like construct them in

00:22:33,280 --> 00:22:40,900
this certain way what do you mean

00:22:36,330 --> 00:22:43,090
basically yeah if we had slides we can

00:22:40,900 --> 00:22:45,220
show it we already have Jesus who for

00:22:43,090 --> 00:22:47,679
you deep in the cannon yes that is true

00:22:45,220 --> 00:22:50,020
but there is also some extra work that

00:22:47,679 --> 00:22:51,870
actually the quick stack needs to do

00:22:50,020 --> 00:22:54,870
with the packets right it needs to part

00:22:51,870 --> 00:22:57,190
and create the batches of the packets

00:22:54,870 --> 00:23:00,730
yeah but assuming this is all really

00:22:57,190 --> 00:23:04,059
done by userspace yeah but does the

00:23:00,730 --> 00:23:06,160
that's why we don't see the same results

00:23:04,059 --> 00:23:09,100
that that the Mellanox thing we've just

00:23:06,160 --> 00:23:10,300
how much you can speed up with with

00:23:09,100 --> 00:23:17,770
enabling the

00:23:10,300 --> 00:23:20,020
Foundation itself okay do you also have

00:23:17,770 --> 00:23:23,440
the numbers for like just segmentation

00:23:20,020 --> 00:23:32,590
or just crypto we have only just for the

00:23:23,440 --> 00:23:37,780
crypto can I go yeah we don't yet have

00:23:32,590 --> 00:23:39,820
the numbers for just the segmentation so

00:23:37,780 --> 00:23:43,270
I would like to try and respond to Tom

00:23:39,820 --> 00:23:45,540
and my main question is regardless if

00:23:43,270 --> 00:23:48,610
you put the world quake in the camera

00:23:45,540 --> 00:23:51,130
maybe we can put a subset of quick maybe

00:23:48,610 --> 00:23:58,120
only the crypto is defined well enough

00:23:51,130 --> 00:23:59,830
such that we can call it that create the

00:23:58,120 --> 00:24:02,230
quick protocol would not be Dell in any

00:23:59,830 --> 00:24:04,510
way would this be something that's

00:24:02,230 --> 00:24:13,540
acceptable to both ITF in the Calvin

00:24:04,510 --> 00:24:15,760
community ITF point of view the protocol

00:24:13,540 --> 00:24:17,440
was designed to be easy implementable in

00:24:15,760 --> 00:24:19,270
user space but it doesn't mean that it

00:24:17,440 --> 00:24:21,130
can never ever be implemented in kernel

00:24:19,270 --> 00:24:26,440
space right that's not that was not the

00:24:21,130 --> 00:24:28,120
attention well I mean isn't a ETF

00:24:26,440 --> 00:24:29,590
technically should be agnostic to where

00:24:28,120 --> 00:24:31,720
the protocol is implemented I know I

00:24:29,590 --> 00:24:33,310
know sometimes people say oh it's a user

00:24:31,720 --> 00:24:35,650
space protocol it's a kernel protocol

00:24:33,310 --> 00:24:39,460
reality is protocols we never intended

00:24:35,650 --> 00:24:42,310
to be run in a specific place that being

00:24:39,460 --> 00:24:44,910
said the the reason we want to be

00:24:42,310 --> 00:24:46,990
careful here is because we're entering

00:24:44,910 --> 00:24:49,120
hopefully a new realm where we do get

00:24:46,990 --> 00:24:51,780
new new types of protocols coming in and

00:24:49,120 --> 00:24:54,400
we're not limited to what we've been

00:24:51,780 --> 00:24:56,830
limited to in the past few years the big

00:24:54,400 --> 00:25:00,520
advantage of quick honestly is that it's

00:24:56,830 --> 00:25:02,080
not TCP and that's forcing a lot of

00:25:00,520 --> 00:25:04,660
people to rethink when you only have one

00:25:02,080 --> 00:25:06,520
protocol you can build a world around

00:25:04,660 --> 00:25:08,440
that and you can optimize for that one

00:25:06,520 --> 00:25:10,480
only and the problem is everybody gets

00:25:08,440 --> 00:25:13,600
zoned into that that when something new

00:25:10,480 --> 00:25:15,760
and innovative comes along there's no

00:25:13,600 --> 00:25:20,320
way to to deploy it because you're stuck

00:25:15,760 --> 00:25:22,540
so the way to round this is to make sure

00:25:20,320 --> 00:25:24,169
that we have a platform where we can do

00:25:22,540 --> 00:25:25,490
this sort of new

00:25:24,169 --> 00:25:27,770
and the opportunity we have since we

00:25:25,490 --> 00:25:29,750
have quick which is new and it's not in

00:25:27,770 --> 00:25:32,870
the Colonel's we can do it right in that

00:25:29,750 --> 00:25:34,940
generic way and and give us that freedom

00:25:32,870 --> 00:25:36,740
so quick to quick three whatever's

00:25:34,940 --> 00:25:38,570
beyond that will be easier that's so

00:25:36,740 --> 00:25:40,159
this is there's a long term issue on a

00:25:38,570 --> 00:25:42,289
short-term issue here and I think

00:25:40,159 --> 00:25:44,870
they're both satisfied by keeping things

00:25:42,289 --> 00:25:47,570
clean keeping the colonel cleaning and

00:25:44,870 --> 00:25:49,039
using the a lot of the new techniques we

00:25:47,570 --> 00:25:51,919
have that really allow sort of this

00:25:49,039 --> 00:25:53,809
flexible program ability so I'll just

00:25:51,919 --> 00:25:55,250
quickly piggyback on Tom's comment I

00:25:53,809 --> 00:25:58,429
actually I completely agree with what

00:25:55,250 --> 00:26:01,039
Tom said it's important to consider

00:25:58,429 --> 00:26:04,490
quick as not the wandering that binds

00:26:01,039 --> 00:26:05,570
them on it's it's it's it's just not tcp

00:26:04,490 --> 00:26:08,450
and it's basically paving the way for

00:26:05,570 --> 00:26:09,710
more things to do to come and those

00:26:08,450 --> 00:26:11,090
could be subsequent versions of quake

00:26:09,710 --> 00:26:14,899
those could be other protocols as well

00:26:11,090 --> 00:26:17,809
and the idea of tarp I just did a quick

00:26:14,899 --> 00:26:20,270
scan does not mention user space it

00:26:17,809 --> 00:26:23,240
doesn't even mention user which is an

00:26:20,270 --> 00:26:25,640
estranged but it doesn't Jesus face even

00:26:23,240 --> 00:26:27,289
once which is important because the spec

00:26:25,640 --> 00:26:28,669
as Tom mentioned is again basically

00:26:27,289 --> 00:26:30,890
simply saying it's layer on top of UDP

00:26:28,669 --> 00:26:35,149
it doesn't say anything about where the

00:26:30,890 --> 00:26:38,720
code lives so yeah doesn't matter yeah

00:26:35,149 --> 00:26:42,490
thank you for the great talk and I I

00:26:38,720 --> 00:26:47,029
wanted to ask if you try it already to

00:26:42,490 --> 00:26:49,309
upload the the whole handshake of quick

00:26:47,029 --> 00:26:54,529
to the hardware no because that would

00:26:49,309 --> 00:26:57,289
ossify the protocol that's in the same

00:26:54,529 --> 00:27:01,610
way you can do that with TCP because yes

00:26:57,289 --> 00:27:03,740
it Simplot they would be probably not

00:27:01,610 --> 00:27:08,960
for sure there would be similar attacks

00:27:03,740 --> 00:27:12,710
against quick so at the handshake abuse

00:27:08,960 --> 00:27:17,179
so yeah but we we deliberately chose not

00:27:12,710 --> 00:27:19,429
to do that we don't want to actually

00:27:17,179 --> 00:27:22,399
accelerate the handshake because we want

00:27:19,429 --> 00:27:24,470
to have a freedom of what whatever that

00:27:22,399 --> 00:27:28,760
stuck wants to actually put into the

00:27:24,470 --> 00:27:30,740
keys well understood Thanks there's also

00:27:28,760 --> 00:27:32,809
a subtle risk here if we make this too

00:27:30,740 --> 00:27:34,210
easy middleboxes may start implementing

00:27:32,809 --> 00:27:35,200
quick proxy

00:27:34,210 --> 00:27:40,779
yeah I don't know if you want to go

00:27:35,200 --> 00:27:43,809
there did you mention an implementation

00:27:40,779 --> 00:27:47,590
of delusive side I didn't notice

00:27:43,809 --> 00:27:49,840
we're doing received but we didn't worry

00:27:47,590 --> 00:27:51,610
about the metadata part so if we were

00:27:49,840 --> 00:27:54,309
focused on transmit because web servers

00:27:51,610 --> 00:27:57,369
transmit heavy right but it was doing

00:27:54,309 --> 00:28:00,490
bi-directional at some point so how did

00:27:57,369 --> 00:28:01,809
you pass the metadata like you will

00:28:00,490 --> 00:28:06,009
acknowledge it and assume in your

00:28:01,809 --> 00:28:08,499
fingers yeah okay tensions and see

00:28:06,009 --> 00:28:11,049
messages as you've mentioned that you

00:28:08,499 --> 00:28:13,379
can use the skb extensions maybe woodsy

00:28:11,049 --> 00:28:13,379
message

00:28:22,879 --> 00:28:30,059
all right we almost we got a minute but

00:28:27,210 --> 00:28:33,679
yeah we can they would like to Rican all

00:28:30,059 --> 00:28:33,679

YouTube URL: https://www.youtube.com/watch?v=ald5tP2VeGk


