Title: Netdev 0x13 - P4 Compiler Backend for TC
Publication date: 2019-06-03
Playlist: Netdev 0x13 - Day 3
Description: 
	Marian Pritsak describes taking advantage of standard linux features by
creating a Linux Pipeline with with P4 utilizing the traffic control(TC) subsystem. 
In his work with Matty Kadosh, they have written a P4 to TC compiler backend with
switchdev as the HW offload backend.

More info:
https://www.netdevconf.org/0x13/session.html?p4-compiler-backend-for-tc
Captions: 
	00:00:00,030 --> 00:00:04,740
my name is Marion I work for Mellanox

00:00:02,639 --> 00:00:07,649
and switch software architecture team

00:00:04,740 --> 00:00:13,349
and today I'm going to talk about before

00:00:07,649 --> 00:00:16,580
compiler back in 40 C so a few words

00:00:13,349 --> 00:00:19,020
about what we are going to cover today

00:00:16,580 --> 00:00:22,890
first one is overview of the

00:00:19,020 --> 00:00:27,090
programmable forwarding pipelines then

00:00:22,890 --> 00:00:31,520
I'm going to go briefly over the p4

00:00:27,090 --> 00:00:33,960
language it description of how it can

00:00:31,520 --> 00:00:37,680
help us with programming forwarding

00:00:33,960 --> 00:00:41,719
flexible pipelines next I'm going to

00:00:37,680 --> 00:00:45,629
introduce Lennox DC back end as a before

00:00:41,719 --> 00:00:52,649
44 target and together with this Linux

00:00:45,629 --> 00:00:55,890
DC architecture then I'm going to go

00:00:52,649 --> 00:00:59,219
over the compiler backing design and

00:00:55,890 --> 00:01:02,699
implementation follow that by some use

00:00:59,219 --> 00:01:05,189
case and demo and we'll finish with what

00:01:02,699 --> 00:01:08,990
the future work that's the two that

00:01:05,189 --> 00:01:12,990
needs to be done for making it even more

00:01:08,990 --> 00:01:17,189
flexible okay so we'll start with the

00:01:12,990 --> 00:01:21,990
overview of the flexible of deep

00:01:17,189 --> 00:01:26,040
programmable forwarding pipelines so we

00:01:21,990 --> 00:01:29,040
all are used to this view of the legacy

00:01:26,040 --> 00:01:34,400
fixed function pipeline which has some

00:01:29,040 --> 00:01:37,200
ingress entry then then some set of

00:01:34,400 --> 00:01:43,649
fixed function blocks that performed

00:01:37,200 --> 00:01:46,020
this for that much action and some

00:01:43,649 --> 00:01:49,049
inverse parts are on the beginning and

00:01:46,020 --> 00:01:54,570
the parser at the end so as opposed to

00:01:49,049 --> 00:01:58,729
that our Hardware today supports a

00:01:54,570 --> 00:02:03,390
little bit more flexible architecture

00:01:58,729 --> 00:02:05,670
which besides of this fixed function or

00:02:03,390 --> 00:02:09,300
read-only blocks also supports some

00:02:05,670 --> 00:02:10,450
flexible blocks which include ingress

00:02:09,300 --> 00:02:12,430
parser some

00:02:10,450 --> 00:02:18,040
flexible match action tables that you

00:02:12,430 --> 00:02:22,930
can combine and a departure or as it is

00:02:18,040 --> 00:02:26,290
also called a packet modifier so you can

00:02:22,930 --> 00:02:29,519
actually have comparing to the fixed

00:02:26,290 --> 00:02:32,400
function pipeline so you can actually

00:02:29,519 --> 00:02:36,640
jump between different blocks you can

00:02:32,400 --> 00:02:39,400
introduce new protocols to your English

00:02:36,640 --> 00:02:43,330
parser but you can insert new tables

00:02:39,400 --> 00:02:46,599
would first would this flex match action

00:02:43,330 --> 00:02:52,560
block and do some interesting stuff with

00:02:46,599 --> 00:02:55,269
that so let's let's zoom in on the first

00:02:52,560 --> 00:02:58,030
flexible block which is a flexible match

00:02:55,269 --> 00:03:03,760
action so how it looks like it's usually

00:02:58,030 --> 00:03:07,209
a set of tables that you have to define

00:03:03,760 --> 00:03:10,870
which can be comprised in different ways

00:03:07,209 --> 00:03:13,780
they can be they can perform a parallel

00:03:10,870 --> 00:03:18,010
lookup on a field in the packet they can

00:03:13,780 --> 00:03:20,019
be chained into a list you can do go to

00:03:18,010 --> 00:03:23,859
action from one table to another so

00:03:20,019 --> 00:03:28,810
basically you have some flexibility in

00:03:23,859 --> 00:03:34,359
the packet in the packet lookup in the

00:03:28,810 --> 00:03:37,239
match action block so together would

00:03:34,359 --> 00:03:41,049
match action block comes a flexible

00:03:37,239 --> 00:03:43,630
parser which introduces which gives you

00:03:41,049 --> 00:03:49,350
a possibility to introduce new protocols

00:03:43,630 --> 00:03:54,519
to your to your pipeline so it is

00:03:49,350 --> 00:03:58,680
important to emphasize on on statement

00:03:54,519 --> 00:04:02,319
that this pipeline is not considered

00:03:58,680 --> 00:04:04,060
kind of fully programmable it is a

00:04:02,319 --> 00:04:07,030
superset of a fully programmable

00:04:04,060 --> 00:04:10,410
pipeline because this is a hybrid mode

00:04:07,030 --> 00:04:15,099
pipeline it includes both programmable

00:04:10,410 --> 00:04:17,049
pipelines and fixed function blocks to

00:04:15,099 --> 00:04:20,159
which you can always default and you

00:04:17,049 --> 00:04:21,769
don't have to reinvent the wheel by

00:04:20,159 --> 00:04:25,629
writing

00:04:21,769 --> 00:04:29,810
from scratch Ethernet IP and

00:04:25,629 --> 00:04:33,979
higher-level protocols so our flexible

00:04:29,810 --> 00:04:35,629
bar sir gives you possibility to

00:04:33,979 --> 00:04:42,710
introduce new protocols into your

00:04:35,629 --> 00:04:44,960
pipeline you know in this way you can so

00:04:42,710 --> 00:04:47,419
in this example you can build on top of

00:04:44,960 --> 00:04:50,919
UDP so you can introduce quark you can

00:04:47,419 --> 00:04:53,419
introduce new tunnels and then in the

00:04:50,919 --> 00:04:55,580
Flex Mac much action block you can

00:04:53,419 --> 00:05:02,169
actually match on the fields of this

00:04:55,580 --> 00:05:06,380
protocol and the third element of the

00:05:02,169 --> 00:05:10,130
flexible pipelines is the flexible

00:05:06,380 --> 00:05:14,060
packet modifier so this block allows you

00:05:10,130 --> 00:05:24,319
to build your new protocols on the in on

00:05:14,060 --> 00:05:28,039
the egress side so this way you can

00:05:24,319 --> 00:05:31,759
introduce similarly how you introduced

00:05:28,039 --> 00:05:34,069
new protocols to your parser the same

00:05:31,759 --> 00:05:37,009
way you can introduce new templates for

00:05:34,069 --> 00:05:39,979
building packet headers on the egress

00:05:37,009 --> 00:05:41,630
and this way you can do some

00:05:39,979 --> 00:05:44,300
modification you can insert your own

00:05:41,630 --> 00:05:47,270
data you can build tunnels you can build

00:05:44,300 --> 00:05:52,610
telemetry depending on your use case you

00:05:47,270 --> 00:05:56,889
can do pretty much everything ok so

00:05:52,610 --> 00:06:00,800
having said that we need some high level

00:05:56,889 --> 00:06:04,569
programming language to actually be able

00:06:00,800 --> 00:06:08,840
to program all those flexible blocks and

00:06:04,569 --> 00:06:12,130
as of today the best candidate that we

00:06:08,840 --> 00:06:17,800
see for for programming our hardware is

00:06:12,130 --> 00:06:22,940
p4 language to be more precise before 16

00:06:17,800 --> 00:06:26,690
before the standard of 2000 year 2016

00:06:22,940 --> 00:06:30,979
and later and I will explain you why in

00:06:26,690 --> 00:06:34,940
a few minutes so short introduction to

00:06:30,979 --> 00:06:40,130
b4 language it it's basically

00:06:34,940 --> 00:06:43,210
built all on two sets of elements first

00:06:40,130 --> 00:06:47,660
one is generic elements the ones that

00:06:43,210 --> 00:06:50,660
were described before and some target

00:06:47,660 --> 00:06:55,010
specific elements so the generic

00:06:50,660 --> 00:06:58,400
elements include the parser match action

00:06:55,010 --> 00:07:01,700
tables and control blocks so this is how

00:06:58,400 --> 00:07:06,920
it usually looks like in the code for

00:07:01,700 --> 00:07:10,130
the parser it's kind of see like switch

00:07:06,920 --> 00:07:14,630
statement in which having being in one

00:07:10,130 --> 00:07:18,530
state in your parsing tree you can you

00:07:14,630 --> 00:07:23,360
can transition to another one my section

00:07:18,530 --> 00:07:25,880
tables this is actually the point where

00:07:23,360 --> 00:07:27,650
you define the keys by which you mention

00:07:25,880 --> 00:07:31,070
your header and then actions that you

00:07:27,650 --> 00:07:33,560
can perform so this is all descriptive

00:07:31,070 --> 00:07:35,330
part you you do not actually populate

00:07:33,560 --> 00:07:37,160
entries here but this is how you define

00:07:35,330 --> 00:07:40,160
your pipeline and the last one is

00:07:37,160 --> 00:07:44,840
control blocks so control blocks are

00:07:40,160 --> 00:07:48,470
actually helping you define how you

00:07:44,840 --> 00:07:51,890
apply your magics in tables and all the

00:07:48,470 --> 00:07:59,030
stuff to your pipeline at which stages

00:07:51,890 --> 00:08:03,919
et cetera and the target target specific

00:07:59,030 --> 00:08:06,200
elements of the language are actions the

00:08:03,919 --> 00:08:09,880
target architecture itself and a

00:08:06,200 --> 00:08:13,850
metadata that is provided by the started

00:08:09,880 --> 00:08:15,320
so a few words but each of them so

00:08:13,850 --> 00:08:17,650
target let's start from target

00:08:15,320 --> 00:08:23,150
architecture this one is quite important

00:08:17,650 --> 00:08:26,419
because it actually it defines a view of

00:08:23,150 --> 00:08:29,480
your target of your hardware that will

00:08:26,419 --> 00:08:33,650
be presented to the programmer that will

00:08:29,480 --> 00:08:37,250
write the p4 program so it means that as

00:08:33,650 --> 00:08:38,780
long as you provide a target

00:08:37,250 --> 00:08:44,870
architecture for your hardware

00:08:38,780 --> 00:08:46,730
or some generic model it it is by the

00:08:44,870 --> 00:08:48,800
standard it is not portable between

00:08:46,730 --> 00:08:53,060
different targets so for example in

00:08:48,800 --> 00:08:57,920
Mellanox we have our compiler that can

00:08:53,060 --> 00:09:00,350
already compiled p4 code to some sdk

00:08:57,920 --> 00:09:02,660
calls but it's not portable to let's say

00:09:00,350 --> 00:09:06,080
this linux target architecture and it's

00:09:02,660 --> 00:09:09,550
not portable to other hardware so

00:09:06,080 --> 00:09:13,160
there's also a set of actions that

00:09:09,550 --> 00:09:17,240
hardware provides so these are some

00:09:13,160 --> 00:09:19,490
basic building blocks that allow you to

00:09:17,240 --> 00:09:22,310
do manipulations on the packet so you

00:09:19,490 --> 00:09:24,200
can do some TBS you can set metadata you

00:09:22,310 --> 00:09:26,530
can set the bridge set fields on the

00:09:24,200 --> 00:09:29,750
packet and so on and so forth

00:09:26,530 --> 00:09:32,480
and the last one is the standard

00:09:29,750 --> 00:09:35,060
metadata that is provided along with the

00:09:32,480 --> 00:09:35,950
packet it will it can include some

00:09:35,060 --> 00:09:39,560
scratchpad

00:09:35,950 --> 00:09:41,870
fuels it can provide some information

00:09:39,560 --> 00:09:45,800
about the packet like where the packet

00:09:41,870 --> 00:09:53,660
interest from what the packets VR ID et

00:09:45,800 --> 00:09:59,420
cetera ok so as I said we cannot we

00:09:53,660 --> 00:10:03,020
cannot write a p4 application without

00:09:59,420 --> 00:10:05,600
having a target so to be in order to be

00:10:03,020 --> 00:10:10,660
able to write before applications for

00:10:05,600 --> 00:10:13,190
Linux and to customize Linux we need

00:10:10,660 --> 00:10:16,430
target architecture which is specific to

00:10:13,190 --> 00:10:20,000
Linux so we call that a Linux DC target

00:10:16,430 --> 00:10:25,400
architecture in high level it looks like

00:10:20,000 --> 00:10:27,530
this so we have those black blocks that

00:10:25,400 --> 00:10:31,459
are read-only we cannot modify them and

00:10:27,530 --> 00:10:36,770
also we can define we can define a

00:10:31,459 --> 00:10:40,130
programmable blocks together word some

00:10:36,770 --> 00:10:42,459
other stuff like parser and packet

00:10:40,130 --> 00:10:46,370
modifier that I will talk about later

00:10:42,459 --> 00:10:48,200
but basically this is what we need to be

00:10:46,370 --> 00:10:52,610
able to write before applications

00:10:48,200 --> 00:10:54,130
applications for Linux so how it looks

00:10:52,610 --> 00:10:57,130
like

00:10:54,130 --> 00:11:01,150
from the compiler point of view so

00:10:57,130 --> 00:11:04,160
before community already provides a

00:11:01,150 --> 00:11:05,840
standard common front-end for all the

00:11:04,160 --> 00:11:08,900
backends so for all the target

00:11:05,840 --> 00:11:13,010
architectures there is already a common

00:11:08,900 --> 00:11:15,560
front-end which gives you for free some

00:11:13,010 --> 00:11:18,530
syntactic analysis some semantic

00:11:15,560 --> 00:11:21,500
analysis so all the before code is

00:11:18,530 --> 00:11:24,080
already parsed for you and all these

00:11:21,500 --> 00:11:29,420
symbol tables are built so you can just

00:11:24,080 --> 00:11:31,360
use use them and what we did we we wrote

00:11:29,420 --> 00:11:35,780
our own back-end

00:11:31,360 --> 00:11:40,400
which basically translates before

00:11:35,780 --> 00:11:42,530
program into TC calls it has it

00:11:40,400 --> 00:11:47,210
generates several layers first one is

00:11:42,530 --> 00:11:52,580
the base layer it's some TC generic TC

00:11:47,210 --> 00:11:57,110
generic C code that configures TC rules

00:11:52,580 --> 00:12:01,040
and looks it looks kind of like at entry

00:11:57,110 --> 00:12:06,860
to the table remove entry stuff like

00:12:01,040 --> 00:12:10,580
that and the layer above is the API that

00:12:06,860 --> 00:12:16,730
allows you to actually configure entries

00:12:10,580 --> 00:12:21,680
in Linux through TC so for that we chose

00:12:16,730 --> 00:12:25,370
a common way that before community works

00:12:21,680 --> 00:12:29,150
we chose a P for runtime api which gives

00:12:25,370 --> 00:12:33,140
you some nice RPC calls to provision

00:12:29,150 --> 00:12:35,510
your app to provide in your target to to

00:12:33,140 --> 00:12:37,430
configure everything and there's also

00:12:35,510 --> 00:12:40,460
some nice you like with Auto completion

00:12:37,430 --> 00:12:42,770
and some verifications of the parameters

00:12:40,460 --> 00:12:46,220
that you can use which is also generated

00:12:42,770 --> 00:12:49,820
and built for your pipeline and for your

00:12:46,220 --> 00:12:52,460
tables that you programmed and thanks to

00:12:49,820 --> 00:12:56,100
switch dev we can nicely offload all

00:12:52,460 --> 00:13:01,110
this all these TC

00:12:56,100 --> 00:13:03,090
into the hardware so basically the part

00:13:01,110 --> 00:13:06,180
this that's implemented in here is

00:13:03,090 --> 00:13:08,610
already supported and offloaded to all

00:13:06,180 --> 00:13:11,750
Hardware in Mellanox so both switch and

00:13:08,610 --> 00:13:11,750
neck can work with that

00:13:13,010 --> 00:13:19,800
okay so current state of the work first

00:13:16,980 --> 00:13:25,560
I need to tell that back end is not yet

00:13:19,800 --> 00:13:28,200
available in open source it's currently

00:13:25,560 --> 00:13:33,960
it's in a POC stage so I'm going to

00:13:28,200 --> 00:13:36,740
publish it in coming months okay so what

00:13:33,960 --> 00:13:42,000
we have there is the flower filter based

00:13:36,740 --> 00:13:45,900
matching we have a hardware offload

00:13:42,000 --> 00:13:48,750
possibility of course a linux target

00:13:45,900 --> 00:13:53,880
architecture definition so what this

00:13:48,750 --> 00:13:55,830
means is that we have defined control

00:13:53,880 --> 00:13:59,850
blocks that you can program for now it's

00:13:55,830 --> 00:14:03,270
only ingress part but we're going to

00:13:59,850 --> 00:14:07,680
extend that along with that you have a

00:14:03,270 --> 00:14:10,230
set of default headers that DC already

00:14:07,680 --> 00:14:11,040
supports so you can write matches on

00:14:10,230 --> 00:14:13,770
them

00:14:11,040 --> 00:14:14,490
I also generated before an time API for

00:14:13,770 --> 00:14:17,100
configuring

00:14:14,490 --> 00:14:18,990
all of this and conveniently lifelike

00:14:17,100 --> 00:14:22,590
populating table entries along with

00:14:18,990 --> 00:14:26,480
before runtime CLI and what's not yet

00:14:22,590 --> 00:14:30,090
supported first one is kind of big one

00:14:26,480 --> 00:14:35,100
programmable parser and modifier so in

00:14:30,090 --> 00:14:38,610
case you want to be able to work with

00:14:35,100 --> 00:14:42,030
your own protocols on top of some of the

00:14:38,610 --> 00:14:46,050
existing as I mentioned so you will need

00:14:42,030 --> 00:14:52,140
a programmable and infrastructure in TCP

00:14:46,050 --> 00:14:56,790
to be able to parse new protocols and to

00:14:52,140 --> 00:15:00,090
do matches later on and counters also TC

00:14:56,790 --> 00:15:02,560
has a counters out-of-the-box they are

00:15:00,090 --> 00:15:05,500
not yet provided in

00:15:02,560 --> 00:15:11,170
this compiler back in version but it's

00:15:05,500 --> 00:15:14,170
it's gonna be also added verse okay so a

00:15:11,170 --> 00:15:22,410
short use case and then whether I wanted

00:15:14,170 --> 00:15:26,890
to present so I wanted to do some some

00:15:22,410 --> 00:15:30,550
configuration some pipeline that is that

00:15:26,890 --> 00:15:33,339
I can actually offload regardless of the

00:15:30,550 --> 00:15:35,470
hardware that I have so for that I took

00:15:33,339 --> 00:15:38,080
one mountain ox which I took one

00:15:35,470 --> 00:15:41,770
mountain ox neck which is on the host

00:15:38,080 --> 00:15:45,870
above and I just compiled my program and

00:15:41,770 --> 00:15:49,660
configure all the hardware as if this

00:15:45,870 --> 00:15:52,120
homogeneous system all the way so the

00:15:49,660 --> 00:15:56,260
demo is pretty straightforward

00:15:52,120 --> 00:15:59,140
I just based on the source IP of the

00:15:56,260 --> 00:16:01,950
packet I am doing a stateless of load

00:15:59,140 --> 00:16:04,990
balancing between different VMs

00:16:01,950 --> 00:16:08,230
so I just split the address space in

00:16:04,990 --> 00:16:14,410
half and then propagated later and split

00:16:08,230 --> 00:16:18,790
again so so all the all the VMS will

00:16:14,410 --> 00:16:21,400
receive more or less similar workload so

00:16:18,790 --> 00:16:26,080
how it would look in DC so what you

00:16:21,400 --> 00:16:29,290
actually need to write to make it work

00:16:26,080 --> 00:16:33,300
sorry empty for what you actually need

00:16:29,290 --> 00:16:36,820
to write to make it work in before is

00:16:33,300 --> 00:16:39,190
one thing so since we are not

00:16:36,820 --> 00:16:43,450
introducing in protocols you just have

00:16:39,190 --> 00:16:46,600
to add one table so you see that for now

00:16:43,450 --> 00:16:49,240
the only programming point that

00:16:46,600 --> 00:16:51,640
supported this control ingress so you

00:16:49,240 --> 00:16:54,700
put your table into the ingress point of

00:16:51,640 --> 00:16:57,250
your pipeline specify the keys which is

00:16:54,700 --> 00:17:03,100
a ipv4 source address which is an LPN

00:16:57,250 --> 00:17:05,290
match actions action is to port and then

00:17:03,100 --> 00:17:09,910
you say that you want to apply this

00:17:05,290 --> 00:17:12,220
table and that's it next you do more or

00:17:09,910 --> 00:17:14,910
less the same thing that you would do

00:17:12,220 --> 00:17:16,980
with C program you compile it

00:17:14,910 --> 00:17:19,740
kind of a decisive style you provide a

00:17:16,980 --> 00:17:23,190
source file you provide a output pad and

00:17:19,740 --> 00:17:27,330
some arbitrary attributes like switch

00:17:23,190 --> 00:17:29,160
architecture which is DC in our case and

00:17:27,330 --> 00:17:32,660
then you need to actually populate these

00:17:29,160 --> 00:17:37,980
entries you you can do it with a

00:17:32,660 --> 00:17:41,700
auto-generated CLI the syntax is kind of

00:17:37,980 --> 00:17:45,300
like provided here so you you will need

00:17:41,700 --> 00:17:48,360
a few entries per your host so basically

00:17:45,300 --> 00:17:51,890
you add all the prefixes and tell to

00:17:48,360 --> 00:18:19,320
which port you want to go so I have

00:17:51,890 --> 00:18:24,540
three minutes actually works so I'm

00:18:19,320 --> 00:18:26,220
gonna show how you actually having

00:18:24,540 --> 00:18:29,130
already compiled the application how you

00:18:26,220 --> 00:18:31,740
populate all the stuff to your Linux

00:18:29,130 --> 00:18:36,870
machine so what I did I spawned a few

00:18:31,740 --> 00:18:39,840
client VMs on the left side few server

00:18:36,870 --> 00:18:43,560
VMs on the right side so the client VMs

00:18:39,840 --> 00:18:47,010
are in separate halves of the address

00:18:43,560 --> 00:18:54,120
space so that they will be distributed

00:18:47,010 --> 00:19:00,080
to different hosts and the VMS VMs have

00:18:54,120 --> 00:19:03,480
the same configuration basically I

00:19:00,080 --> 00:19:07,310
configured the same idea just to virtual

00:19:03,480 --> 00:19:12,540
IP address to the center to all the

00:19:07,310 --> 00:19:15,690
servers and then I'm just tearing a

00:19:12,540 --> 00:19:17,780
traffic between them so okay let's fast

00:19:15,690 --> 00:19:17,780
forward

00:19:23,430 --> 00:19:32,050
okay let's see so I'm here

00:19:29,560 --> 00:19:34,960
no traffic is passing through as you

00:19:32,050 --> 00:19:37,900
will see in a few seconds so these

00:19:34,960 --> 00:19:46,000
servers are not rituals reachable from

00:19:37,900 --> 00:19:49,540
the client and now let's configure some

00:19:46,000 --> 00:19:52,060
rules so all the CLI is auto-generated

00:19:49,540 --> 00:19:57,060
so you don't actually need to write a

00:19:52,060 --> 00:20:01,300
code to have it working so the syntax is

00:19:57,060 --> 00:20:03,190
pretty simple it's add entry to the

00:20:01,300 --> 00:20:07,480
table you specify name of the table you

00:20:03,190 --> 00:20:09,670
specific keys and you specify the action

00:20:07,480 --> 00:20:13,000
which is the I appendix of the port that

00:20:09,670 --> 00:20:16,180
you want to descend to steer the traffic

00:20:13,000 --> 00:20:23,140
to and the other half of the addresses

00:20:16,180 --> 00:20:25,180
will go to another port and that's it so

00:20:23,140 --> 00:20:25,690
that's all you need to do to make it

00:20:25,180 --> 00:20:29,980
work

00:20:25,690 --> 00:20:34,540
besides compiling of course and do you

00:20:29,980 --> 00:20:38,590
see that underneath this is all the all

00:20:34,540 --> 00:20:43,840
the standard TC roles which are nicely

00:20:38,590 --> 00:20:46,480
loaded into the hardware and it's okay

00:20:43,840 --> 00:20:48,310
so one can you go back the I'm sorry I

00:20:46,480 --> 00:20:52,090
have a question because you inserted

00:20:48,310 --> 00:20:56,170
something 128 yeah but then the address

00:20:52,090 --> 00:20:59,890
is 192 and were you yeah 182 fits into

00:20:56,170 --> 00:21:02,410
128 and above so it has one in the first

00:20:59,890 --> 00:21:05,230
bit and the other one has 0 in the first

00:21:02,410 --> 00:21:06,700
but so that's how they are split into

00:21:05,230 --> 00:21:11,350
two parts

00:21:06,700 --> 00:21:14,470
okay and the last one white to slice why

00:21:11,350 --> 00:21:22,090
TC first one because we of course like

00:21:14,470 --> 00:21:24,040
Jamal next TC despite despite being kind

00:21:22,090 --> 00:21:28,090
of confusing it's still highly flexible

00:21:24,040 --> 00:21:30,610
this is the one of the most flexible

00:21:28,090 --> 00:21:34,110
infrastructure that I've had to work

00:21:30,610 --> 00:21:34,110
with can you say that again

00:21:38,380 --> 00:21:46,310
yes so and besides that it has lots of

00:21:44,030 --> 00:21:48,920
benefits as opposed to other targets

00:21:46,310 --> 00:21:52,610
that I was working with if we are

00:21:48,920 --> 00:21:54,800
talking about before so Linux software

00:21:52,610 --> 00:21:58,370
implementation can be used as a

00:21:54,800 --> 00:22:01,310
reference platform which is a kind of

00:21:58,370 --> 00:22:04,610
main killer of all the others because

00:22:01,310 --> 00:22:06,740
when you have some you don't always have

00:22:04,610 --> 00:22:09,080
some hardware to work with you you want

00:22:06,740 --> 00:22:13,730
to have a software platform that you can

00:22:09,080 --> 00:22:16,960
just program and you want to you want to

00:22:13,730 --> 00:22:21,590
actually just try it on your laptop and

00:22:16,960 --> 00:22:24,140
and see some results without purchasing

00:22:21,590 --> 00:22:28,070
any hardware so it is unified across

00:22:24,140 --> 00:22:30,470
hardware as well so since this is a

00:22:28,070 --> 00:22:35,240
reference platform all Hardware needs to

00:22:30,470 --> 00:22:40,580
conform to it and then it can either

00:22:35,240 --> 00:22:42,860
upload this stuff or basically we see

00:22:40,580 --> 00:22:47,810
the same behavior across all the

00:22:42,860 --> 00:22:53,000
hardware that's working with Linux with

00:22:47,810 --> 00:22:54,800
TC okay so it's open no proprietor SDK

00:22:53,000 --> 00:22:59,120
as opposed to all of the other stuff

00:22:54,800 --> 00:23:01,160
that I've seen and what you need is open

00:22:59,120 --> 00:23:04,670
compiler along with the backend that I

00:23:01,160 --> 00:23:10,370
am going to provide and vanilla Linux

00:23:04,670 --> 00:23:13,790
that's it another huge benefit to other

00:23:10,370 --> 00:23:17,720
target architectures that I see here is

00:23:13,790 --> 00:23:19,820
this hybrid architecture model so you

00:23:17,720 --> 00:23:23,990
don't have to reinvent the wheel you

00:23:19,820 --> 00:23:26,930
already have l2 l3 you have tunnels

00:23:23,990 --> 00:23:30,610
standard tunnels you have everything to

00:23:26,930 --> 00:23:35,090
work with you can just add on top of it

00:23:30,610 --> 00:23:39,470
yes so that's a future work that we need

00:23:35,090 --> 00:23:41,420
to do probably together we need to think

00:23:39,470 --> 00:23:43,040
of some way of introducing a

00:23:41,420 --> 00:23:46,760
programmable parser and

00:23:43,040 --> 00:23:53,360
fire 2tc because it's not a part of this

00:23:46,760 --> 00:23:58,250
infrastructure also I need to expose TC

00:23:53,360 --> 00:24:03,200
counters we are thinking of adding of

00:23:58,250 --> 00:24:08,270
enriching the action set and standard

00:24:03,200 --> 00:24:10,100
filter set of TC filters and also some

00:24:08,270 --> 00:24:12,770
interesting thing to do we'll be

00:24:10,100 --> 00:24:17,390
introducing more binding points instead

00:24:12,770 --> 00:24:20,270
it besides the standard ones which are

00:24:17,390 --> 00:24:22,760
ingress and egress so it's like IP

00:24:20,270 --> 00:24:26,180
tables having more than two like pre

00:24:22,760 --> 00:24:39,170
routing something like that okay so

00:24:26,180 --> 00:24:47,060
that's it I'm just I'm gonna pick

00:24:39,170 --> 00:24:50,420
somebody to ask a question Thanks really

00:24:47,060 --> 00:24:53,450
nice I assumed there could be stuff that

00:24:50,420 --> 00:24:57,050
can be written in p4 which is cannot be

00:24:53,450 --> 00:24:59,950
translated to TC right now so what

00:24:57,050 --> 00:25:04,540
happens in your process that happens

00:24:59,950 --> 00:25:06,920
okay so as I said there is this first

00:25:04,540 --> 00:25:10,250
big thing that we need to address as

00:25:06,920 --> 00:25:13,670
flexible parser and flexible modifier

00:25:10,250 --> 00:25:18,140
which is a generic construct of p4

00:25:13,670 --> 00:25:20,690
language which is not yet MTC and it it

00:25:18,140 --> 00:25:23,450
will just not work if you try to do

00:25:20,690 --> 00:25:28,370
something like that right now another

00:25:23,450 --> 00:25:33,590
thing so sometimes people get confused

00:25:28,370 --> 00:25:35,390
because you can in p4 generally you can

00:25:33,590 --> 00:25:38,870
write different kinds of stuff depending

00:25:35,390 --> 00:25:40,400
on your target architecture and that's

00:25:38,870 --> 00:25:43,190
why we need to define our target

00:25:40,400 --> 00:25:45,260
architecture for Linux because what I've

00:25:43,190 --> 00:25:48,530
seen from the research papers people

00:25:45,260 --> 00:25:51,020
were doing some crazy stuff which then

00:25:48,530 --> 00:25:53,450
wasn't clickable to any hardware so they

00:25:51,020 --> 00:25:56,690
just took some software model like there

00:25:53,450 --> 00:25:59,900
is one popular BM v2 which is which

00:25:56,690 --> 00:26:01,130
just does not map to any hardware and if

00:25:59,900 --> 00:26:06,140
you write something there it's not

00:26:01,130 --> 00:26:08,600
portable so yes as long as you are as

00:26:06,140 --> 00:26:11,030
long as we were will address the problem

00:26:08,600 --> 00:26:16,040
of a flexible parser and flexible

00:26:11,030 --> 00:26:17,780
modifier as everything else is

00:26:16,040 --> 00:26:22,040
constrained with the target architecture

00:26:17,780 --> 00:26:26,900
and will be properly handled with

00:26:22,040 --> 00:26:32,960
compiler errors errors if you go beyond

00:26:26,900 --> 00:26:37,760
your target architecture is that

00:26:32,960 --> 00:26:39,980
spectrum ASIC yes so force which we used

00:26:37,760 --> 00:26:44,420
spectrum is but the changes to the

00:26:39,980 --> 00:26:47,810
driver as well no changes to the driver

00:26:44,420 --> 00:26:59,960
yes it's just yeah right now we support

00:26:47,810 --> 00:27:04,760
the following of TC so you said support

00:26:59,960 --> 00:27:05,800
the modifier isn't period enough or what

00:27:04,760 --> 00:27:08,060
am I missing

00:27:05,800 --> 00:27:11,930
Jamal correct me if I'm wrong Pierre

00:27:08,060 --> 00:27:18,190
does not support adding new headers yes

00:27:11,930 --> 00:27:20,960
you can't expand or contract ok I have

00:27:18,190 --> 00:27:23,630
one more question since I don't

00:27:20,960 --> 00:27:25,940
understand before very well I couldn't

00:27:23,630 --> 00:27:31,700
get why you need P for runtime and then

00:27:25,940 --> 00:27:34,880
TC yes sure so before any p4 program is

00:27:31,700 --> 00:27:37,070
compiled into two pieces first one is

00:27:34,880 --> 00:27:39,770
some kind of binary blob defined by the

00:27:37,070 --> 00:27:42,350
target which describes your platform and

00:27:39,770 --> 00:27:44,480
second one is the API that you need to

00:27:42,350 --> 00:27:47,510
actually populate and twister tables and

00:27:44,480 --> 00:27:49,580
we just chose before runtime so it can

00:27:47,510 --> 00:27:52,010
be it can be something else no I

00:27:49,580 --> 00:27:54,170
understood that part but if you use

00:27:52,010 --> 00:27:59,180
before runtime api to program the rules

00:27:54,170 --> 00:28:01,520
why do you still need TC or use the

00:27:59,180 --> 00:28:03,800
control interface yeah this is this is

00:28:01,520 --> 00:28:06,210
like the base layer for all the api's

00:28:03,800 --> 00:28:08,520
which can be used to

00:28:06,210 --> 00:28:11,250
to add entries to the table so this is

00:28:08,520 --> 00:28:15,660
generic and does not know which API uses

00:28:11,250 --> 00:28:18,710
it yeah I think the question is why p4

00:28:15,660 --> 00:28:22,500
hunt I had that in my head as well I

00:28:18,710 --> 00:28:25,590
know but but it's you have a raw

00:28:22,500 --> 00:28:27,750
interface to the hardware and you picked

00:28:25,590 --> 00:28:29,850
one way of doing of interfacing to that

00:28:27,750 --> 00:28:32,130
raw API which is before run time before

00:28:29,850 --> 00:28:34,290
run time is I could have written a

00:28:32,130 --> 00:28:36,470
different runtime not the one that is

00:28:34,290 --> 00:28:39,510
being presented by before a dog and I

00:28:36,470 --> 00:28:40,980
suspect there'll be other vendors who do

00:28:39,510 --> 00:28:45,540
not want to use before run time for

00:28:40,980 --> 00:28:47,820
example yeah but you still you still

00:28:45,540 --> 00:28:52,770
have this base layer that provides you

00:28:47,820 --> 00:28:55,710
in a generic API which looks kind of

00:28:52,770 --> 00:28:57,210
like a ten feet to the table or remove

00:28:55,710 --> 00:29:01,770
entry from the table so yeah look it's

00:28:57,210 --> 00:29:05,430
based on protobufs and all that and like

00:29:01,770 --> 00:29:08,100
to into things but it's still it's still

00:29:05,430 --> 00:29:11,360
talking to raw what what is the P for

00:29:08,100 --> 00:29:16,440
runtime talking so different I'm SDI

00:29:11,360 --> 00:29:18,780
interfaces to the on the way down to the

00:29:16,440 --> 00:29:20,340
clinic okay I think that's in my opinion

00:29:18,780 --> 00:29:23,250
that's the best thing to expose it API

00:29:20,340 --> 00:29:29,490
interface not people runtime but I can

00:29:23,250 --> 00:29:32,010
understand yeah yeah below that is

00:29:29,490 --> 00:29:35,220
auto-generated code that actually

00:29:32,010 --> 00:29:38,100
populates configuration to but what is

00:29:35,220 --> 00:29:41,220
that lower level API the re for runtime

00:29:38,100 --> 00:29:43,650
runs oh yes so this is a C library

00:29:41,220 --> 00:29:48,690
that's just configures TC out nothing

00:29:43,650 --> 00:29:49,920
call okay okay and that that back in

00:29:48,690 --> 00:29:53,300
could be used by anybody who doesn't

00:29:49,920 --> 00:29:53,300
want to be a foreign key yes

00:29:57,880 --> 00:30:02,030
in your last slides you mentioned the

00:30:00,590 --> 00:30:03,770
two things that might be missing is a

00:30:02,030 --> 00:30:07,070
flexible parser and also more binding

00:30:03,770 --> 00:30:09,380
points that sort of sounds like where

00:30:07,070 --> 00:30:12,820
BBF comes into the kernel could you

00:30:09,380 --> 00:30:15,560
could you create BPF as your bit like a

00:30:12,820 --> 00:30:17,840
hybrid back-end which would be TC NB p

00:30:15,560 --> 00:30:23,360
f4 on the DPL yes so first thing about

00:30:17,840 --> 00:30:26,690
BBF it's not a flaw that at least it's

00:30:23,360 --> 00:30:32,260
not easily offloaded to the hardware but

00:30:26,690 --> 00:30:35,860
most likely you cannot use BPF code so

00:30:32,260 --> 00:30:39,200
the problem here that you need to have

00:30:35,860 --> 00:30:45,160
single entry which and my point of view

00:30:39,200 --> 00:30:48,770
is TC and v PF and well what i mean by

00:30:45,160 --> 00:30:54,700
multiple binding points I'm not sure if

00:30:48,770 --> 00:30:58,340
vpf has that as well so today you cannot

00:30:54,700 --> 00:31:03,800
bind your DPF code to pre routing stage

00:30:58,340 --> 00:31:08,210
right BPF has many available hooks

00:31:03,800 --> 00:31:10,670
incorrect yeah but the point is that you

00:31:08,210 --> 00:31:17,530
need to have something that can be

00:31:10,670 --> 00:31:23,210
uploaded by harder so can you offload

00:31:17,530 --> 00:31:25,160
BPF to your basic first of all this is

00:31:23,210 --> 00:31:26,720
not this is not dedicated for ruffle

00:31:25,160 --> 00:31:29,750
right we what you described here is a

00:31:26,720 --> 00:31:32,720
way for someone to configure TC using p4

00:31:29,750 --> 00:31:35,420
yeah but whether or not the TC I look at

00:31:32,720 --> 00:31:38,810
vpf as separate back-end so you already

00:31:35,420 --> 00:31:42,830
have a back-end for BPF upstream so you

00:31:38,810 --> 00:31:46,430
can take that if you want to but I want

00:31:42,830 --> 00:31:49,280
to work with TC because the way it's

00:31:46,430 --> 00:31:52,640
designed it can be offloaded to hardware

00:31:49,280 --> 00:31:55,430
and we want to do more extensions to TC

00:31:52,640 --> 00:31:59,380
to make it affordable and so that people

00:31:55,430 --> 00:32:01,940
can work with TC basically without vpf

00:31:59,380 --> 00:32:04,550
sure I understand and I'm also for the

00:32:01,940 --> 00:32:06,890
offload teasing just seems like a good

00:32:04,550 --> 00:32:08,770
fit for ya so actually if you if you

00:32:06,890 --> 00:32:11,470
want to use BPM there is already

00:32:08,770 --> 00:32:13,630
compiled a compiler back in for BPF so

00:32:11,470 --> 00:32:16,480
you can look into it but as for now it's

00:32:13,630 --> 00:32:22,140
quite limited at only it's also non

00:32:16,480 --> 00:32:22,140
ingress and it's only filtering not much

00:32:40,630 --> 00:32:48,730
I didn't and the reason why he don't

00:32:42,789 --> 00:32:50,909
translate in one place the that before

00:32:48,730 --> 00:32:53,620
to TC and UNITA not around time I mean

00:32:50,909 --> 00:32:55,149
typically you figure out what are the

00:32:53,620 --> 00:32:58,330
appropriate commands and you're gonna

00:32:55,149 --> 00:33:02,440
write down the ESL program like before

00:32:58,330 --> 00:33:04,240
in one place and run it and okay so P

00:33:02,440 --> 00:33:09,519
for language is a descriptive language

00:33:04,240 --> 00:33:16,659
so it does not so DP for code itself

00:33:09,519 --> 00:33:18,820
does not give you the the configuration

00:33:16,659 --> 00:33:20,889
of your hardware so you need some way to

00:33:18,820 --> 00:33:23,919
configure your hard work having these

00:33:20,889 --> 00:33:27,130
tables defined in p4 that's why you need

00:33:23,919 --> 00:33:31,299
an API additional yeah yeah but there's

00:33:27,130 --> 00:33:33,700
a compiler who provides the Machine

00:33:31,299 --> 00:33:36,909
specific the ASIC specific code I mean

00:33:33,700 --> 00:33:40,330
in any case I mean before is translated

00:33:36,909 --> 00:33:44,320
to target specific architecture correct

00:33:40,330 --> 00:33:47,080
yeah so I mean is there any kind of the

00:33:44,320 --> 00:33:50,760
p4 DSL which cannot be translated and

00:33:47,080 --> 00:33:50,760
you need the API for that

00:33:50,850 --> 00:33:58,750
well configuring your hardware is out of

00:33:54,100 --> 00:34:01,840
the scope of before program so I mean is

00:33:58,750 --> 00:34:05,889
there any lack of p4 expressiveness that

00:34:01,840 --> 00:34:12,609
cannot be handled with a TC if a DSL

00:34:05,889 --> 00:34:15,570
language okay catch the guy the break

00:34:12,609 --> 00:34:15,570

YouTube URL: https://www.youtube.com/watch?v=fSNl4wMKzg8


