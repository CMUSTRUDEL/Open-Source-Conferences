Title: Netdev 0x13 - TCP SO TIMESTAMPING with OPT STATS for performance analytics
Publication date: 2019-05-26
Playlist: Netdev 0x13 - Day 3
Description: 
	In this talk, Soheil Hassas Yeganeh describes how to trace individual TCP flows within the kernel using timestamps. As a crucial extension, he shows how to accurately capture the state of TCP using OPT_STATS for individual messages. He enumerates challenges, shortcomings
and gotchas of kernel timestamps when deployed at scale.

More info:
https://netdevconf.org/0x13/session.html?talk-tcp-timestamping
Captions: 
	00:00:00,030 --> 00:00:04,160
hello everyone my name is Sohail I'm a

00:00:01,860 --> 00:00:08,160
software engineer at Google

00:00:04,160 --> 00:00:13,320
just a quick poll who was in the TCP

00:00:08,160 --> 00:00:15,900
analytics talk on the first day okay

00:00:13,320 --> 00:00:17,940
a good portion I should have changed the

00:00:15,900 --> 00:00:20,939
background slide the background color so

00:00:17,940 --> 00:00:27,359
you think it's a different talk oh yeah

00:00:20,939 --> 00:00:29,429
I try to not I try to skip the things

00:00:27,359 --> 00:00:33,809
you have seen so it's less boring and

00:00:29,429 --> 00:00:35,670
you can get to the break faster this is

00:00:33,809 --> 00:00:39,680
a joint work with you Chong Gann you

00:00:35,670 --> 00:00:43,440
sock and I should acknowledge this is

00:00:39,680 --> 00:00:46,530
all started by vilem he had his so time

00:00:43,440 --> 00:00:48,059
stamping to TCP so this work wouldn't

00:00:46,530 --> 00:00:50,190
have been possible without his

00:00:48,059 --> 00:00:58,289
contribution but his name unfortunately

00:00:50,190 --> 00:01:00,180
is not unsticks so we all had to fix our

00:00:58,289 --> 00:01:02,370
families computers when we work

00:01:00,180 --> 00:01:04,439
somewhere they are all asked why my RPC

00:01:02,370 --> 00:01:09,630
slow because we work in as working parts

00:01:04,439 --> 00:01:12,750
right and when the RPC is slow most of

00:01:09,630 --> 00:01:14,310
us just look at TCP influence' to go to

00:01:12,750 --> 00:01:16,200
the customer to the user to the

00:01:14,310 --> 00:01:18,630
developer in that organization de yeah

00:01:16,200 --> 00:01:20,280
this connection has RTT of 10

00:01:18,630 --> 00:01:23,009
millisecond with three percent loss rate

00:01:20,280 --> 00:01:26,040
that's probably why your RPC is slow and

00:01:23,009 --> 00:01:29,520
the user is just confused and you're not

00:01:26,040 --> 00:01:33,180
really confident that the stats we are

00:01:29,520 --> 00:01:35,700
showing is actually going to help user

00:01:33,180 --> 00:01:38,909
fix that problem and I'm pretty

00:01:35,700 --> 00:01:41,250
confident at the tail even us don't have

00:01:38,909 --> 00:01:41,820
any idea based on TCP in for what is

00:01:41,250 --> 00:01:45,570
going on

00:01:41,820 --> 00:01:47,579
so at 99 P and above our pcs are not as

00:01:45,570 --> 00:01:50,909
slow because of average aggregate stats

00:01:47,579 --> 00:01:53,189
UTC TCP info and if you try to explain

00:01:50,909 --> 00:01:56,610
the tail of your performance based on

00:01:53,189 --> 00:02:00,540
TCP info you're just doing it wrong

00:01:56,610 --> 00:02:04,259
another approach is just look at the RPC

00:02:00,540 --> 00:02:06,810
and see when it was delivered by TCP

00:02:04,259 --> 00:02:09,149
what lost rate experienced what was the

00:02:06,810 --> 00:02:12,110
pacing rate of this RPC at the time we

00:02:09,149 --> 00:02:13,790
were sending this RPC when it was

00:02:12,110 --> 00:02:16,070
to the neck when it was actually the

00:02:13,790 --> 00:02:17,870
other side like explain exactly what

00:02:16,070 --> 00:02:19,490
happened to that RPC what happened to

00:02:17,870 --> 00:02:21,320
the actually keyframe and this is how

00:02:19,490 --> 00:02:24,980
you can you can actually find bugs and

00:02:21,320 --> 00:02:27,620
debug stuff so I'm hoping that in this

00:02:24,980 --> 00:02:31,460
talk again courage like usage of

00:02:27,620 --> 00:02:33,980
timestamps for a networking

00:02:31,460 --> 00:02:37,640
instrumentation instead of TCP info that

00:02:33,980 --> 00:02:43,760
I've heard many are using right now so

00:02:37,640 --> 00:02:47,750
so time stamping provides four main

00:02:43,760 --> 00:02:51,140
types of time stamps when you call a

00:02:47,750 --> 00:02:55,790
send message it's added to the TCP sent

00:02:51,140 --> 00:02:58,070
Q or right q and then it enters the q

00:02:55,790 --> 00:03:00,470
disk on the devices you have and then

00:02:58,070 --> 00:03:01,430
sent by the hardware received by the

00:03:00,470 --> 00:03:05,600
other side

00:03:01,430 --> 00:03:07,670
something happens to TCP sometimes later

00:03:05,600 --> 00:03:11,420
would acknowledge it and then you

00:03:07,670 --> 00:03:14,330
receive the acknowledge on the sender so

00:03:11,420 --> 00:03:18,350
basically four main times sounds here I

00:03:14,330 --> 00:03:21,920
should use a pointer so here it is sent

00:03:18,350 --> 00:03:23,930
by the driver or Zdenek so software

00:03:21,920 --> 00:03:28,790
versus Harvard time stamp receive on the

00:03:23,930 --> 00:03:31,190
other side and then acknowledge and they

00:03:28,790 --> 00:03:33,920
have names the cutest is scheduled

00:03:31,190 --> 00:03:36,350
timestamp software and hardware are

00:03:33,920 --> 00:03:39,050
basically TX software and hardware our

00:03:36,350 --> 00:03:47,380
exes are exes and ours hardware and

00:03:39,050 --> 00:03:49,820
acknowledges acknowledged so using TCP I

00:03:47,380 --> 00:03:55,130
explained this on the first slide that

00:03:49,820 --> 00:04:01,459
basically due to the things we explained

00:03:55,130 --> 00:04:04,190
here explained in the TCP analytics you

00:04:01,459 --> 00:04:07,160
can use TCP info to explain why TCP for

00:04:04,190 --> 00:04:09,440
example delayed a packet why but a

00:04:07,160 --> 00:04:12,280
packet was sent at a specific pacing

00:04:09,440 --> 00:04:16,370
rate why the congestion window was was

00:04:12,280 --> 00:04:18,830
basically small so when you're

00:04:16,370 --> 00:04:21,530
collecting these time stamps you to

00:04:18,830 --> 00:04:23,990
explain it specific delay you also want

00:04:21,530 --> 00:04:26,930
to know the state of TCP

00:04:23,990 --> 00:04:28,460
why such a delay happened you know it

00:04:26,930 --> 00:04:30,890
was sitting in the cutest for a long

00:04:28,460 --> 00:04:34,910
time but you need to look at to TCP

00:04:30,890 --> 00:04:36,860
stats so while you're capturing this

00:04:34,910 --> 00:04:39,620
time sensor on the kernel in user space

00:04:36,860 --> 00:04:41,960
you can also ask for TCP info user space

00:04:39,620 --> 00:04:44,330
but the problem is you are in user space

00:04:41,960 --> 00:04:47,270
you can get this schedule you can get

00:04:44,330 --> 00:04:49,820
delayed the TCP info you collect is not

00:04:47,270 --> 00:04:52,310
going to be accurate it's not going to

00:04:49,820 --> 00:04:54,290
be from the time we were capturing the

00:04:52,310 --> 00:04:55,330
time stamp not from the time the packet

00:04:54,290 --> 00:04:59,930
was being sent

00:04:55,330 --> 00:05:02,570
so our stats are basically the option

00:04:59,930 --> 00:05:04,910
you can add to time stamping it will

00:05:02,570 --> 00:05:07,990
attach TCP info to all of these

00:05:04,910 --> 00:05:11,210
timestamps generated by the kernel so

00:05:07,990 --> 00:05:13,610
when a packet under scooters we capture

00:05:11,210 --> 00:05:15,050
say condition window pacing rate we

00:05:13,610 --> 00:05:17,780
transmission bytes and and everything

00:05:15,050 --> 00:05:19,669
and you can read it in userspace so it

00:05:17,780 --> 00:05:22,490
gives you some metadata and statistics

00:05:19,669 --> 00:05:25,640
about why TCP makers make a particular

00:05:22,490 --> 00:05:28,600
decision we don't support it on receive

00:05:25,640 --> 00:05:35,030
side of course if there's a use we can

00:05:28,600 --> 00:05:37,760
picking out that using the API is well

00:05:35,030 --> 00:05:40,220
documented so we'll get to that but

00:05:37,760 --> 00:05:42,860
there are some gotchas and coordinate

00:05:40,220 --> 00:05:46,160
cases and courts of this sake so I will

00:05:42,860 --> 00:05:48,740
not mention those before getting into

00:05:46,160 --> 00:05:50,150
the details the first one is for every

00:05:48,740 --> 00:05:52,630
device you have you will get one

00:05:50,150 --> 00:05:54,800
scheduled time stamp so if you are say

00:05:52,630 --> 00:05:57,260
tunneling and then bondings

00:05:54,800 --> 00:05:58,820
and then going to the physical NIC you

00:05:57,260 --> 00:06:01,400
always give three schedules so you

00:05:58,820 --> 00:06:05,750
shouldn't be surprised for every layer

00:06:01,400 --> 00:06:07,490
there's just one schedule and this can

00:06:05,750 --> 00:06:09,530
be helpful to see which device is

00:06:07,490 --> 00:06:12,440
actually like the latency of each device

00:06:09,530 --> 00:06:14,300
because we have it before the anther

00:06:12,440 --> 00:06:16,190
cutest up until we entered the next

00:06:14,300 --> 00:06:22,130
gillis layer so you you see all the

00:06:16,190 --> 00:06:24,710
delays another caveat here is the act

00:06:22,130 --> 00:06:31,160
time stamps include the receiver delay

00:06:24,710 --> 00:06:33,590
so one thing that quick if you attended

00:06:31,160 --> 00:06:35,539
a quick talk that was added to quick was

00:06:33,590 --> 00:06:37,070
piggybacking this delay back to the

00:06:35,539 --> 00:06:39,440
receiver

00:06:37,070 --> 00:06:42,560
because in userspace these delays event

00:06:39,440 --> 00:06:45,140
force for Colonel the delay the

00:06:42,560 --> 00:06:47,030
acknowledgment in TCP there are other

00:06:45,140 --> 00:06:48,770
stuff that can happen that can delay the

00:06:47,030 --> 00:06:52,250
acknowledgement so this receiver delay

00:06:48,770 --> 00:06:59,620
is included in your acts and you need to

00:06:52,250 --> 00:07:08,090
be careful about that another surprise

00:06:59,620 --> 00:07:10,520
that it's always I've seen this surprise

00:07:08,090 --> 00:07:15,050
and many many different people with

00:07:10,520 --> 00:07:17,180
different backgrounds TCP can send

00:07:15,050 --> 00:07:19,240
packets synchronously inside the send

00:07:17,180 --> 00:07:21,920
message so it's not always async

00:07:19,240 --> 00:07:23,870
depending on like how much window we

00:07:21,920 --> 00:07:27,110
have if we can release the packet right

00:07:23,870 --> 00:07:29,810
away TCP may or may not send your packet

00:07:27,110 --> 00:07:33,590
inside this is called context so when

00:07:29,810 --> 00:07:36,440
you are in the send message you can like

00:07:33,590 --> 00:07:38,330
generate cue disk time some you can

00:07:36,440 --> 00:07:41,150
generate this sometimes it can hit the

00:07:38,330 --> 00:07:42,560
Nick it can be son and then sometimes if

00:07:41,150 --> 00:07:45,250
you thik is fast enough we can either

00:07:42,560 --> 00:07:47,870
receive the ACK and then receive and

00:07:45,250 --> 00:07:50,270
then userspace Caesar returned from

00:07:47,870 --> 00:07:53,530
Cisco remember from when we unlock the

00:07:50,270 --> 00:07:56,840
socket we cross accent and stuff so

00:07:53,530 --> 00:07:59,750
these timestamps are causal they are all

00:07:56,840 --> 00:08:01,340
from the same clock source but when you

00:07:59,750 --> 00:08:04,010
read them you can't get surprised so

00:08:01,340 --> 00:08:06,740
make sure you understand there's

00:08:04,010 --> 00:08:10,820
synchronous versus asynchronous sync in

00:08:06,740 --> 00:08:14,150
TCP now for the API it is well

00:08:10,820 --> 00:08:17,870
documented we have an example in

00:08:14,150 --> 00:08:20,180
self-test last night I remember it we

00:08:17,870 --> 00:08:22,340
forgot to add up stats examples I'll

00:08:20,180 --> 00:08:24,590
send a patch but I'll have something on

00:08:22,340 --> 00:08:27,410
my laptop I'll show you how we can

00:08:24,590 --> 00:08:29,150
readers so the first thing you need to

00:08:27,410 --> 00:08:32,150
do if you want to use this thing you

00:08:29,150 --> 00:08:36,620
have to enable it on your socket it's a

00:08:32,150 --> 00:08:38,720
socket level times a soft option Sol

00:08:36,620 --> 00:08:41,229
sockets so time stamping and then you

00:08:38,720 --> 00:08:45,560
pass in a value that values a bit flag

00:08:41,229 --> 00:08:47,150
you can use many different options you

00:08:45,560 --> 00:08:48,830
can set many different options in this

00:08:47,150 --> 00:08:50,170
bit flag and then it enables our

00:08:48,830 --> 00:08:52,930
different

00:08:50,170 --> 00:08:57,490
variations of so time Samson so time

00:08:52,930 --> 00:08:59,800
stamping for you one that if you want to

00:08:57,490 --> 00:09:05,320
get softer time stamps meaning scheduled

00:08:59,800 --> 00:09:07,480
acknowledged or sent TX offer you have

00:09:05,320 --> 00:09:09,160
to enable soft I'm stamping suffer if

00:09:07,480 --> 00:09:11,740
you want draw hardware you can also

00:09:09,160 --> 00:09:13,449
neighbor harder there's a sis hardware

00:09:11,740 --> 00:09:18,430
in the Enuma but that is deprecated you

00:09:13,449 --> 00:09:20,139
you can't it if you want to Custer in

00:09:18,430 --> 00:09:24,040
addition to enabling this you can

00:09:20,139 --> 00:09:27,370
optimize customize it using options so

00:09:24,040 --> 00:09:30,970
there are enumerated surf time stamping

00:09:27,370 --> 00:09:34,329
opt so you can get up ID of TS only up

00:09:30,970 --> 00:09:37,149
stats packet info and TX software

00:09:34,329 --> 00:09:39,130
hardware ID basically gives you an

00:09:37,149 --> 00:09:43,500
identifier pair timestamp so you can

00:09:39,130 --> 00:09:46,149
know which packet is this timestamp for

00:09:43,500 --> 00:09:50,740
basically a TCP sequence a relative

00:09:46,149 --> 00:09:53,079
sequence of the TCP backup TS only by

00:09:50,740 --> 00:09:55,269
default each timestamp is a clone of the

00:09:53,079 --> 00:09:57,790
original packet and it's a counter to

00:09:55,269 --> 00:09:59,079
your arm M so it's high overhead if you

00:09:57,790 --> 00:10:01,750
want to use this in production you

00:09:59,079 --> 00:10:03,339
should always enable TS only unless you

00:10:01,750 --> 00:10:07,750
actually want to see the content of the

00:10:03,339 --> 00:10:09,670
packet for if you you're you say just

00:10:07,750 --> 00:10:12,779
for performance analysis as probably

00:10:09,670 --> 00:10:15,430
unlikely you want to see the content of

00:10:12,779 --> 00:10:18,040
stats is basically what I explained it

00:10:15,430 --> 00:10:20,620
attaches extra story timestamps you can

00:10:18,040 --> 00:10:22,899
get the packet info this new option that

00:10:20,620 --> 00:10:26,649
TX offer and hardware is a great

00:10:22,899 --> 00:10:28,779
addition to recent journals software and

00:10:26,649 --> 00:10:30,910
hardware sentenced as were mutually

00:10:28,779 --> 00:10:34,329
exclusive we didn't have in a space to

00:10:30,910 --> 00:10:36,790
keep both they added a feature to enable

00:10:34,329 --> 00:10:39,490
both software and hardware time so you

00:10:36,790 --> 00:10:41,529
can get the timestamps inside the driver

00:10:39,490 --> 00:10:44,110
as well as when the packet was

00:10:41,529 --> 00:10:46,089
transmitted by the neck so it actually

00:10:44,110 --> 00:10:49,779
gives you another delta which I didn't

00:10:46,089 --> 00:10:54,519
have in my my time sequence but I

00:10:49,779 --> 00:10:57,060
wouldn't explain that and then these are

00:10:54,519 --> 00:11:01,029
all for enabling and customizing and

00:10:57,060 --> 00:11:03,670
then you can also say I want these types

00:11:01,029 --> 00:11:05,860
of time step so I want software

00:11:03,670 --> 00:11:08,080
for example transmission software we see

00:11:05,860 --> 00:11:09,610
software acts are scheduled and these

00:11:08,080 --> 00:11:14,260
are like you can mix and match and

00:11:09,610 --> 00:11:18,430
choose whatever you want um this is one

00:11:14,260 --> 00:11:19,750
example here choice key now for reading

00:11:18,430 --> 00:11:22,060
when you enable this you want to read

00:11:19,750 --> 00:11:23,530
this right to read this there is an

00:11:22,060 --> 00:11:25,570
inherent difference on receive

00:11:23,530 --> 00:11:29,920
timestamps not receive out very very

00:11:25,570 --> 00:11:31,780
easy because they sit in the TCP you see

00:11:29,920 --> 00:11:34,300
if you I have the time stuff I just read

00:11:31,780 --> 00:11:36,630
it give it to you on a Sima search on

00:11:34,300 --> 00:11:39,820
transmit is actually very difficult

00:11:36,630 --> 00:11:41,830
because we may send the packets

00:11:39,820 --> 00:11:43,480
asynchronously so the timestamps will be

00:11:41,830 --> 00:11:45,580
generated later so you need an

00:11:43,480 --> 00:11:48,130
asynchronous communication mechanism to

00:11:45,580 --> 00:11:51,000
the user space for that we use Erik heal

00:11:48,130 --> 00:11:53,980
Erik you for those who don't know is

00:11:51,000 --> 00:11:56,020
originally for receiving ICMP packets

00:11:53,980 --> 00:11:59,320
from the kernel for example traceroute

00:11:56,020 --> 00:12:03,850
is implemented using this you receive

00:11:59,320 --> 00:12:08,080
the ICMP it was there we don't have many

00:12:03,850 --> 00:12:11,410
flags to use so the same queue is used

00:12:08,080 --> 00:12:13,420
for other types of control things one is

00:12:11,410 --> 00:12:15,070
time stands for zero coffee bilham uses

00:12:13,420 --> 00:12:17,140
as well mmm

00:12:15,070 --> 00:12:20,430
it's it's account it's a control channel

00:12:17,140 --> 00:12:20,430
right now it's not really an error cue

00:12:21,570 --> 00:12:27,580
for reading ops that's when you receive

00:12:24,820 --> 00:12:30,970
these timestamps from the queue you get

00:12:27,580 --> 00:12:32,860
the value of time stamps and stuff like

00:12:30,970 --> 00:12:35,530
that I'll show the API later at the

00:12:32,860 --> 00:12:38,170
example later but in addition to these

00:12:35,530 --> 00:12:39,880
you can get a bunch of enolate or net

00:12:38,170 --> 00:12:46,120
link attributes which are basically TLB

00:12:39,880 --> 00:12:50,440
is like type length and value of the tcp

00:12:46,120 --> 00:12:52,780
stats we did this because in TCP info we

00:12:50,440 --> 00:12:55,090
learned a lesson that whenever the ad is

00:12:52,780 --> 00:12:56,710
started a public API have filtered a

00:12:55,090 --> 00:12:59,650
public API you can never remove that or

00:12:56,710 --> 00:13:02,140
take it back so this way we can just

00:12:59,650 --> 00:13:04,840
remove things that we don't record

00:13:02,140 --> 00:13:07,410
anymore and we don't have to pay the

00:13:04,840 --> 00:13:11,980
cost of setting them so there are some

00:13:07,410 --> 00:13:14,260
important stats you can get for example

00:13:11,980 --> 00:13:15,580
we can get all of the TCP Kronos busy

00:13:14,260 --> 00:13:17,440
time

00:13:15,580 --> 00:13:21,730
limiters and both limits basically the

00:13:17,440 --> 00:13:25,120
time we were in limited by receiving the

00:13:21,730 --> 00:13:27,670
or sent above was limited so we couldn't

00:13:25,120 --> 00:13:29,590
send anything you can get RTO spacing

00:13:27,670 --> 00:13:33,100
rate congestion windows and Q and many

00:13:29,590 --> 00:13:40,060
many other fields this is a code snippet

00:13:33,100 --> 00:13:44,620
I try to somehow shrink it to so that it

00:13:40,060 --> 00:13:47,800
fits in this light let me show it on my

00:13:44,620 --> 00:13:50,740
laptop so there is a there are two

00:13:47,800 --> 00:13:53,980
structures socket extender and SCM

00:13:50,740 --> 00:13:57,130
timestamping this one is a metadata this

00:13:53,980 --> 00:13:59,770
one is the timestamp value so you set

00:13:57,130 --> 00:14:02,740
your control messages and your message

00:13:59,770 --> 00:14:06,820
you trade a buffer but whatever size you

00:14:02,740 --> 00:14:09,370
expect to get you call receive message

00:14:06,820 --> 00:14:11,320
but with a flag message Eric you then

00:14:09,370 --> 00:14:16,750
you start reading your control messages

00:14:11,320 --> 00:14:18,870
and then if for the TSSs structure there

00:14:16,750 --> 00:14:22,720
would be a control message with type

00:14:18,870 --> 00:14:25,750
same time stamping and your extender

00:14:22,720 --> 00:14:28,210
error would be with these levels and

00:14:25,750 --> 00:14:30,130
types there are other stuff you can

00:14:28,210 --> 00:14:32,860
insert to make sure this is the correct

00:14:30,130 --> 00:14:35,580
extent that error I skip that one and

00:14:32,860 --> 00:14:39,250
then four times for up stats you also

00:14:35,580 --> 00:14:42,400
get up stats as a type now when you have

00:14:39,250 --> 00:14:46,240
these two you can read at a timestamp

00:14:42,400 --> 00:14:49,210
the extended error has a info which is

00:14:46,240 --> 00:14:52,930
stores the timestamp type and then the

00:14:49,210 --> 00:14:55,150
ID which is the opt ID that I explained

00:14:52,930 --> 00:14:58,090
the relative TCP sequence would sit in

00:14:55,150 --> 00:15:01,870
your data remember these are all for

00:14:58,090 --> 00:15:04,920
ICMP so easy data we couldn't rename it

00:15:01,870 --> 00:15:07,750
to Eid right so we had to Union stuff so

00:15:04,920 --> 00:15:09,400
so the key is there the type is there

00:15:07,750 --> 00:15:12,460
and then based on the type like a

00:15:09,400 --> 00:15:16,600
scallops and Iraq you can look into

00:15:12,460 --> 00:15:19,150
these structures see the kernel

00:15:16,600 --> 00:15:22,720
timestamps generated and then you can

00:15:19,150 --> 00:15:25,170
process the offsets the aniline upstairs

00:15:22,720 --> 00:15:29,589
print them to the user and that's all

00:15:25,170 --> 00:15:32,499
for the up stats it's pretty simple

00:15:29,589 --> 00:15:35,620
the idea is you just get the data and

00:15:32,499 --> 00:15:38,560
then you go inside the data and then

00:15:35,620 --> 00:15:41,110
parse the enolase it's a little bit more

00:15:38,560 --> 00:15:44,019
difficult than casting it to TCP info

00:15:41,110 --> 00:15:44,499
for example but I think it has many

00:15:44,019 --> 00:15:47,110
benefits

00:15:44,499 --> 00:15:49,839
just remember on some platforms this is

00:15:47,110 --> 00:15:52,839
not aligned on some platforms when you

00:15:49,839 --> 00:15:55,899
copy stuff that are on aligned you can

00:15:52,839 --> 00:15:58,449
just simply cast it you may have issues

00:15:55,899 --> 00:16:02,050
so adjustment mem copy it otherwise if

00:15:58,449 --> 00:16:03,819
you compile your binaries with UV Sun if

00:16:02,050 --> 00:16:09,009
the sanitizer would complain that you're

00:16:03,819 --> 00:16:10,949
copying on a long memory so another

00:16:09,009 --> 00:16:14,019
feature that is available since

00:16:10,949 --> 00:16:16,689
four-point-seven is that you can enable

00:16:14,019 --> 00:16:18,790
time stamps percent message in

00:16:16,689 --> 00:16:21,249
production if you enable this as assets

00:16:18,790 --> 00:16:24,249
are thought for like I want to receive

00:16:21,249 --> 00:16:27,160
sand and schedule an ACK it would

00:16:24,249 --> 00:16:29,829
generate basically a timestamp for every

00:16:27,160 --> 00:16:32,949
chunk you've written to the socket that

00:16:29,829 --> 00:16:35,019
can be very costly so we added a feature

00:16:32,949 --> 00:16:37,990
that you can enable this on a send

00:16:35,019 --> 00:16:39,639
message basis so you can send whatever

00:16:37,990 --> 00:16:41,800
you want with it would it wouldn't

00:16:39,639 --> 00:16:44,800
generate any timestamp and then when you

00:16:41,800 --> 00:16:46,930
give the kernel a C message that enables

00:16:44,800 --> 00:16:49,660
these time stamping features in TCP it

00:16:46,930 --> 00:16:51,610
would generate the timestamps only for

00:16:49,660 --> 00:16:54,160
the packet created inside that send

00:16:51,610 --> 00:16:56,829
message that gives you the capability to

00:16:54,160 --> 00:17:00,939
just sample a few sequences you are

00:16:56,829 --> 00:17:05,620
interested in if you look at G RPC for

00:17:00,939 --> 00:17:08,260
example whenever we try to trace a RPC

00:17:05,620 --> 00:17:10,179
if we stitch it down from h2 to SSL then

00:17:08,260 --> 00:17:13,750
to TCP capture these timestamps and then

00:17:10,179 --> 00:17:16,839
hook it up it's a very good sampling

00:17:13,750 --> 00:17:19,120
mechanism I had support for UDP and raw

00:17:16,839 --> 00:17:24,459
as well but what I'm explaining here is

00:17:19,120 --> 00:17:26,740
just for TCP timestamps are originally

00:17:24,459 --> 00:17:29,080
for raw on UDP packets they are one

00:17:26,740 --> 00:17:33,250
percent message that is basically one

00:17:29,080 --> 00:17:35,020
packet for TCP it's not a packet is

00:17:33,250 --> 00:17:40,690
basically whatever you have written in

00:17:35,020 --> 00:17:42,960
that send message so it's one timestamp

00:17:40,690 --> 00:17:44,789
percent successful send message

00:17:42,960 --> 00:17:46,669
if whatever if you have a positive

00:17:44,789 --> 00:17:55,919
return value from sendmessage

00:17:46,669 --> 00:17:58,049
if is it per segment or is it per

00:17:55,919 --> 00:18:00,269
message it is per message it is the last

00:17:58,049 --> 00:18:02,070
byte of that message and if you call the

00:18:00,269 --> 00:18:04,440
stuff with another send message that was

00:18:02,070 --> 00:18:06,289
in trace you will get worse one time

00:18:04,440 --> 00:18:13,320
sound there is an SB just have one

00:18:06,289 --> 00:18:16,980
there's just one now sometimes you

00:18:13,320 --> 00:18:19,470
actually want the border like the HTTP

00:18:16,980 --> 00:18:22,200
to frame an RPC or something like that

00:18:19,470 --> 00:18:25,440
Martin from Facebook added message you

00:18:22,200 --> 00:18:28,080
are to TCP a while back in four point

00:18:25,440 --> 00:18:30,210
seven when you send a message with

00:18:28,080 --> 00:18:33,480
message you are Colonel wouldn't call s

00:18:30,210 --> 00:18:35,669
anything to this send message now if you

00:18:33,480 --> 00:18:37,200
want to trace something flush whatever

00:18:35,669 --> 00:18:39,960
you have in your buffer bit message you

00:18:37,200 --> 00:18:42,869
are TCP doesn't call us anything to that

00:18:39,960 --> 00:18:46,139
previously we can think right your trace

00:18:42,869 --> 00:18:49,820
stuff and then it do message you are so

00:18:46,139 --> 00:18:52,919
it's basically a very well-defined white

00:18:49,820 --> 00:18:55,139
border and like a flash point for TCP

00:18:52,919 --> 00:18:57,450
and you get the time stamp only for that

00:18:55,139 --> 00:19:02,700
byte offset so you get a very accurate

00:18:57,450 --> 00:19:05,850
you get very accurate time stamp but

00:19:02,700 --> 00:19:12,269
with the cost of missing coalescing so

00:19:05,850 --> 00:19:13,950
it comes at a performance cost this is

00:19:12,269 --> 00:19:18,090
the control message so instead of doing

00:19:13,950 --> 00:19:20,299
the de set Sokka you enable everything

00:19:18,090 --> 00:19:23,220
but you don't in a but you don't set the

00:19:20,299 --> 00:19:25,049
time stamps you want instead you pass

00:19:23,220 --> 00:19:27,960
the time stamps you want as control

00:19:25,049 --> 00:19:32,580
message to their send message arches are

00:19:27,960 --> 00:19:38,610
pretty easy things you now let me show

00:19:32,580 --> 00:19:44,340
you the self-test so if you go to this

00:19:38,610 --> 00:19:46,830
folder in tools testing software

00:19:44,340 --> 00:19:49,379
networking time stamping there is a TX

00:19:46,830 --> 00:19:49,889
time stamping binary you can compile it

00:19:49,379 --> 00:19:52,259
and run it

00:19:49,889 --> 00:19:54,409
I added offset feature this morning all

00:19:52,259 --> 00:19:56,350
I'll send the patch upstream but

00:19:54,409 --> 00:20:02,110
basically

00:19:56,350 --> 00:20:04,450
can ask it to send UDP raw TCP packets

00:20:02,110 --> 00:20:07,809
to a particular port or destination and

00:20:04,450 --> 00:20:13,750
you get all of the stats I have a server

00:20:07,809 --> 00:20:18,390
running on port 8000 this is what you

00:20:13,750 --> 00:20:24,580
get out of that binary I call the Cisco

00:20:18,390 --> 00:20:27,630
at this time it returned at this time

00:20:24,580 --> 00:20:28,809
and in parentheses we show the relative

00:20:27,630 --> 00:20:31,090
delta

00:20:28,809 --> 00:20:34,270
so from the previous timestamp it took

00:20:31,090 --> 00:20:38,380
54 microseconds basically the Cisco

00:20:34,270 --> 00:20:40,360
enter/exit 54 microsecond then I get

00:20:38,380 --> 00:20:42,580
this schedule I'm probably the local

00:20:40,360 --> 00:20:45,250
host so while I'm in send message packet

00:20:42,580 --> 00:20:47,350
is sent so it was it happened 25

00:20:45,250 --> 00:20:50,530
microsecond before I returned from the

00:20:47,350 --> 00:20:52,240
send message and at the time TCP wasn't

00:20:50,530 --> 00:20:54,880
receiving the limited wasn't sent buff

00:20:52,240 --> 00:20:56,980
limited the pacing rate was this valve

00:20:54,880 --> 00:20:58,330
beard value which is basically max ends

00:20:56,980 --> 00:21:01,780
if you don't believe me you can just

00:20:58,330 --> 00:21:04,299
takes it out the delivery rate but zero

00:21:01,780 --> 00:21:06,850
at that time it was a very first packet

00:21:04,299 --> 00:21:10,750
I see him the initial congestion Windows

00:21:06,850 --> 00:21:14,740
10 min RT t is scenic RT t which is 62

00:21:10,750 --> 00:21:18,460
and the delivery is an app limited the

00:21:14,740 --> 00:21:25,480
next packet on the and sorry where's my

00:21:18,460 --> 00:21:28,600
pointer so the packet was sent to the

00:21:25,480 --> 00:21:30,909
loopback interface 3 microsecond after

00:21:28,600 --> 00:21:35,140
it entered cutest so the cutest delay

00:21:30,909 --> 00:21:36,970
here is p53 microseconds the reason that

00:21:35,140 --> 00:21:39,970
this this is a little bit high is

00:21:36,970 --> 00:21:41,919
because these to B&Q their scheduled

00:21:39,970 --> 00:21:44,049
timestamp on the air queue so there's

00:21:41,919 --> 00:21:45,820
one like you have to generate the packet

00:21:44,049 --> 00:21:49,360
and queue it so there's some some cycles

00:21:45,820 --> 00:21:51,490
to be spent there then we sent it this

00:21:49,360 --> 00:21:55,240
is an time-stamped it got acknowledged

00:21:51,490 --> 00:21:57,490
17 microseconds after the software

00:21:55,240 --> 00:21:59,500
timestamp and all of this happened

00:21:57,490 --> 00:22:03,419
before I actually returned from the

00:21:59,500 --> 00:22:07,090
Cisco right so overall it took about

00:22:03,419 --> 00:22:12,249
like I think 5 microseconds before

00:22:07,090 --> 00:22:13,840
I returned the next packet goes out I do

00:22:12,249 --> 00:22:14,950
another send message one packet send

00:22:13,840 --> 00:22:16,960
message very small one

00:22:14,950 --> 00:22:20,049
now this time I have a delivery rate

00:22:16,960 --> 00:22:23,379
from previous son you see if I'm slow

00:22:20,049 --> 00:22:26,769
starting to 11 my minimum RTT is 25 and

00:22:23,379 --> 00:22:29,830
this is a limit that my tcp doesn't have

00:22:26,769 --> 00:22:33,159
enough backlog to to accurately probe

00:22:29,830 --> 00:22:39,249
the link I get the same time stamps

00:22:33,159 --> 00:22:41,259
almost same like performance and then on

00:22:39,249 --> 00:22:44,379
the next one you see the same time

00:22:41,259 --> 00:22:45,940
stamps I go to this condition window I'm

00:22:44,379 --> 00:22:46,899
basically slow starting no loss

00:22:45,940 --> 00:22:51,070
everything's fine

00:22:46,899 --> 00:22:53,259
now let's probe my employer so this is

00:22:51,070 --> 00:22:55,690
Google calm unfortunately my Wi-Fi

00:22:53,259 --> 00:22:57,549
driver doesn't have that doesn't support

00:22:55,690 --> 00:22:59,619
the same time stamp and I'm not allowed

00:22:57,549 --> 00:23:01,659
to modify my Wi-Fi driver on this

00:22:59,619 --> 00:23:03,700
machine so I'm very sorry you wouldn't

00:23:01,659 --> 00:23:08,649
see the same time stamps but this is

00:23:03,700 --> 00:23:10,899
what I dropped so here of your sending

00:23:08,649 --> 00:23:14,980
the first packet I closed it after the

00:23:10,899 --> 00:23:17,679
first one this is the scheduled time son

00:23:14,980 --> 00:23:20,139
as you can see it also happened before I

00:23:17,679 --> 00:23:26,740
returned from send message and then I

00:23:20,139 --> 00:23:31,809
sent it out on the other side and for

00:23:26,740 --> 00:23:34,779
some reason let me do this so there's a

00:23:31,809 --> 00:23:36,669
flag if you said it it waits for Paul to

00:23:34,779 --> 00:23:42,820
return otherwise it just returns from

00:23:36,669 --> 00:23:45,429
that so here we go

00:23:42,820 --> 00:23:48,850
so you can see the pacing right here is

00:23:45,429 --> 00:23:52,139
actually a same value it's like I have a

00:23:48,850 --> 00:23:54,519
large RTT 6 milliseconds here

00:23:52,139 --> 00:23:57,190
conditioning over 10 so I set the pacing

00:23:54,519 --> 00:24:00,070
rates I got the AK about two

00:23:57,190 --> 00:24:02,909
milliseconds after the cutest release

00:24:00,070 --> 00:24:05,740
the other thing there was no loss

00:24:02,909 --> 00:24:07,480
minimum RTT dropped after this one you

00:24:05,740 --> 00:24:09,570
can see the delivery rate the pacing

00:24:07,480 --> 00:24:13,749
rate is still the same

00:24:09,570 --> 00:24:15,759
this delivery is a because we use the

00:24:13,749 --> 00:24:16,240
same thing for bbr it goes to the max

00:24:15,759 --> 00:24:18,430
filter

00:24:16,240 --> 00:24:20,650
if you use PBR and this is very good if

00:24:18,430 --> 00:24:24,730
to debug BB or connections if you have

00:24:20,650 --> 00:24:26,620
issues same thing here you can see our

00:24:24,730 --> 00:24:29,790
TT changes and everything if I probe

00:24:26,620 --> 00:24:33,070
again you can see I get different values

00:24:29,790 --> 00:24:34,930
different active lays on my Wi-Fi you

00:24:33,070 --> 00:24:38,740
are all using your internet of applaud

00:24:34,930 --> 00:24:40,030
all of that so you can you can see a

00:24:38,740 --> 00:24:45,730
very accurate view of what is happening

00:24:40,030 --> 00:24:50,260
on this network so four more minutes

00:24:45,730 --> 00:24:52,840
I'll go over the common issues if you

00:24:50,260 --> 00:24:58,060
deploy this in prod this is the type of

00:24:52,840 --> 00:25:00,730
issues you can you can see this one you

00:24:58,060 --> 00:25:04,810
can see I'm I'm sending something it

00:25:00,730 --> 00:25:06,760
took about eleven milliseconds to be

00:25:04,810 --> 00:25:09,610
released by the cutest because I I

00:25:06,760 --> 00:25:14,170
manually installed for this talk I

00:25:09,610 --> 00:25:16,780
manually installed a HTV of my box so

00:25:14,170 --> 00:25:20,620
you can accurately see if a cutis is

00:25:16,780 --> 00:25:22,870
hurting your performance this is very

00:25:20,620 --> 00:25:25,150
common pattern when your receiver

00:25:22,870 --> 00:25:26,800
doesn't open up its receive window you

00:25:25,150 --> 00:25:30,480
can see you've been receiving the

00:25:26,800 --> 00:25:33,220
limited for a long time here for example

00:25:30,480 --> 00:25:35,230
we sent a packet and then they were

00:25:33,220 --> 00:25:37,390
waiting for the user to read so receive

00:25:35,230 --> 00:25:38,710
buff opens and then they send an ACK so

00:25:37,390 --> 00:25:42,010
if you look at these counters can say oh

00:25:38,710 --> 00:25:43,960
your receive window is low so either if

00:25:42,010 --> 00:25:47,380
you control the other side go increase

00:25:43,960 --> 00:25:50,380
the receiving though or see whether the

00:25:47,380 --> 00:25:54,570
process can be made more efficient so it

00:25:50,380 --> 00:25:58,000
drains the socket faster you can see

00:25:54,570 --> 00:26:00,760
return for for each TCP retransmission

00:25:58,000 --> 00:26:03,100
of the same sequence you'll get the same

00:26:00,760 --> 00:26:05,080
time stamps so you get say the first

00:26:03,100 --> 00:26:07,780
retransmission would be scared sent and

00:26:05,080 --> 00:26:10,840
then if it's not act it would be scared

00:26:07,780 --> 00:26:13,030
send and you can also have to see the

00:26:10,840 --> 00:26:15,430
value of RTO in Europe stat so you can

00:26:13,030 --> 00:26:17,770
confirm it was RTO faster transmission

00:26:15,430 --> 00:26:23,050
whatever sorry I lost repair or whatever

00:26:17,770 --> 00:26:25,480
and then you can say oh there was a huge

00:26:23,050 --> 00:26:27,430
loss or there was reach ability issue at

00:26:25,480 --> 00:26:30,630
this point so I have to resort to RTO

00:26:27,430 --> 00:26:30,630
that's why your our pcs

00:26:31,190 --> 00:26:40,940
so do using these in production well if

00:26:37,669 --> 00:26:43,909
you enable this for all of your by two

00:26:40,940 --> 00:26:45,049
streams all of your connections the

00:26:43,909 --> 00:26:47,029
overhead is peerconnection

00:26:45,049 --> 00:26:48,559
so it would like if you enable it for

00:26:47,029 --> 00:26:50,539
one person the packets of one connection

00:26:48,559 --> 00:26:54,019
it wouldn't affect another one but

00:26:50,539 --> 00:26:57,740
overall you get about 20% regression so

00:26:54,019 --> 00:26:59,539
make sure you empirically find a good

00:26:57,740 --> 00:27:01,460
sampling rate if you want to use this

00:26:59,539 --> 00:27:05,179
you shouldn't enable this for all

00:27:01,460 --> 00:27:06,830
connections the other issue the

00:27:05,179 --> 00:27:11,149
performance issue that we encountered

00:27:06,830 --> 00:27:12,740
was that for ICMP packets we whenever we

00:27:11,149 --> 00:27:15,289
receive an ICMP packet on a TCP

00:27:12,740 --> 00:27:19,360
connection we set the sk error if is say

00:27:15,289 --> 00:27:22,190
unreachable whatever for it that

00:27:19,360 --> 00:27:27,769
basically happens for UDP and raw as

00:27:22,190 --> 00:27:30,590
well so in DQ of a time stamp from the

00:27:27,769 --> 00:27:33,470
Eric you we were also setting SK air to

00:27:30,590 --> 00:27:35,570
the error code of the time stamps which

00:27:33,470 --> 00:27:38,029
are not really error is email message

00:27:35,570 --> 00:27:41,059
but there's still a nonzero value there

00:27:38,029 --> 00:27:42,980
and whenever we set the SK error

00:27:41,059 --> 00:27:44,690
it basically means there is an error and

00:27:42,980 --> 00:27:46,279
disconnection so we have to pause so

00:27:44,690 --> 00:27:48,769
you're right and read would return with

00:27:46,279 --> 00:27:51,259
an error and they will get paused until

00:27:48,769 --> 00:27:53,960
you clear their you can clear the error

00:27:51,259 --> 00:27:56,899
but draining the Erik you never read the

00:27:53,960 --> 00:28:00,110
saw error I learned this from Erik if we

00:27:56,899 --> 00:28:04,429
do crazy stuff it would reset this care

00:28:00,110 --> 00:28:06,470
you can yeah whenever you see a polar

00:28:04,429 --> 00:28:08,899
you have to drain your air queue and

00:28:06,470 --> 00:28:11,690
then continue read and write before 4:10

00:28:08,899 --> 00:28:13,610
but after 4:10 if you have only

00:28:11,690 --> 00:28:16,940
time-stamping enabled on your connection

00:28:13,610 --> 00:28:19,070
we don't send sk air and you can

00:28:16,940 --> 00:28:23,240
continue read and write without getting

00:28:19,070 --> 00:28:25,820
pauses from timestamps and by fixing

00:28:23,240 --> 00:28:29,899
this when i remove this line you know

00:28:25,820 --> 00:28:32,360
ping and traceroute broke because they

00:28:29,899 --> 00:28:34,309
basically rely on this behavior so for

00:28:32,360 --> 00:28:37,809
ICMP packets we were still sending a

00:28:34,309 --> 00:28:40,480
scare but not for timestamps

00:28:37,809 --> 00:28:43,419
so moving forward I think this is a very

00:28:40,480 --> 00:28:46,870
great powerful and mature well test that

00:28:43,419 --> 00:28:48,669
infrastructure that you can use the only

00:28:46,870 --> 00:28:50,889
problem with this is you can't really

00:28:48,669 --> 00:28:52,990
add a new time stuff if you want another

00:28:50,889 --> 00:28:56,190
delay like a pole in delay or something

00:28:52,990 --> 00:29:00,909
like that you have to change the kernel

00:28:56,190 --> 00:29:04,389
Larry had a talk on BPF a BPF for TCP

00:29:00,909 --> 00:29:05,919
analytics dad is going to be a much

00:29:04,389 --> 00:29:09,190
better replacement for this whole

00:29:05,919 --> 00:29:11,950
infrastructure if he had enough trace

00:29:09,190 --> 00:29:16,149
points so it would give us extensibility

00:29:11,950 --> 00:29:18,970
and more like access we can we can

00:29:16,149 --> 00:29:22,659
exactly collect what we want at the time

00:29:18,970 --> 00:29:28,899
we wanted without one-size-fits-all type

00:29:22,659 --> 00:29:31,360
of instrumentation again I this work was

00:29:28,899 --> 00:29:34,299
done added adding so time stamping to

00:29:31,360 --> 00:29:36,940
TCP was added but F was done by vilem so

00:29:34,299 --> 00:29:43,649
I thanked him for that and thank you all

00:29:36,940 --> 00:29:46,389
for listening 49 seconds just probably

00:29:43,649 --> 00:29:57,419
unless people insist one one question

00:29:46,389 --> 00:29:57,419
that's it sorry somebody was asking okay

00:30:12,289 --> 00:30:17,730
so it's a very simple one so this

00:30:15,450 --> 00:30:19,649
requires the app to effectively be in

00:30:17,730 --> 00:30:21,119
charge of monitoring is that a thought

00:30:19,649 --> 00:30:23,549
about how you can do secondary

00:30:21,119 --> 00:30:25,950
monitoring like its put in put it in

00:30:23,549 --> 00:30:27,929
Sisyphus or something so that if I have

00:30:25,950 --> 00:30:30,389
advertisers that I am interested

00:30:27,929 --> 00:30:34,889
it can start somebody else can attach to

00:30:30,389 --> 00:30:35,700
assess of a Snowden yeah that's a good

00:30:34,889 --> 00:30:38,369
point actually

00:30:35,700 --> 00:30:40,559
there were Craig Alec had some work in

00:30:38,369 --> 00:30:42,659
progress patch to send his constant with

00:30:40,559 --> 00:30:45,269
diagonal in that link so that some team

00:30:42,659 --> 00:30:48,359
on can collect it on your host well

00:30:45,269 --> 00:30:51,830
there's a problem he decided not to go

00:30:48,359 --> 00:30:55,879
with that approach because in userspace

00:30:51,830 --> 00:30:58,710
most of the time apps have their own

00:30:55,879 --> 00:31:01,259
instrumentation and stats infrastructure

00:30:58,710 --> 00:31:04,049
you really want these time stamps to hop

00:31:01,259 --> 00:31:07,259
over those so the developer can actually

00:31:04,049 --> 00:31:10,739
see these if I send this to another for

00:31:07,259 --> 00:31:12,960
example for GRP see you there's all open

00:31:10,739 --> 00:31:15,239
tracing support right you want to attach

00:31:12,960 --> 00:31:16,289
this time son to the trace ID only the

00:31:15,239 --> 00:31:18,659
users face

00:31:16,289 --> 00:31:20,159
that process knows that so it's very

00:31:18,659 --> 00:31:29,879
helpful if you just collected any

00:31:20,159 --> 00:31:37,710
assistance yep all right okay

00:31:29,879 --> 00:31:39,299
last one just I'm good at timing talking

00:31:37,710 --> 00:31:41,159
about the TX time stamps and the

00:31:39,299 --> 00:31:43,710
overhead that is there and we talked

00:31:41,159 --> 00:31:46,259
about the kernel part when you do the

00:31:43,710 --> 00:31:48,570
hardware takes on stands you will see

00:31:46,259 --> 00:31:51,619
the same kind of issues and high speeds

00:31:48,570 --> 00:31:54,749
that if your time stamping every packet

00:31:51,619 --> 00:31:57,269
one of the talks before we had we were

00:31:54,749 --> 00:31:58,919
talking about completions of TX and how

00:31:57,269 --> 00:32:01,470
you want to compress it when you have

00:31:58,919 --> 00:32:04,200
time stamp to it it actually doubles the

00:32:01,470 --> 00:32:05,670
size so those are some of the things

00:32:04,200 --> 00:32:08,929
that

00:32:05,670 --> 00:32:08,929
you know we should keep in mind

00:32:09,170 --> 00:32:16,170
experiment type the time that is

00:32:13,290 --> 00:32:18,710
piggyback by the Nick aster descriptor

00:32:16,170 --> 00:32:21,960
size so and your completion sorry

00:32:18,710 --> 00:32:23,580
and there's another catch through hard

00:32:21,960 --> 00:32:25,559
time stamps sometimes the back is

00:32:23,580 --> 00:32:27,780
generated because they can be received

00:32:25,559 --> 00:32:29,549
on another cue you can receive an AK

00:32:27,780 --> 00:32:31,590
before their Carver time cells ready so

00:32:29,549 --> 00:32:34,620
it's very difficult to process you have

00:32:31,590 --> 00:32:36,360
to be very careful but those are the

00:32:34,620 --> 00:32:38,940
catches sometimes you actually want it

00:32:36,360 --> 00:32:41,370
for example for MTP they want it there

00:32:38,940 --> 00:32:44,220
yeah they wanted to deduct all of the

00:32:41,370 --> 00:32:48,169
local hosts like whatever it overhead is

00:32:44,220 --> 00:32:51,090
on this host so for those you really

00:32:48,169 --> 00:32:54,179
want to pay the cause but have a very

00:32:51,090 --> 00:32:59,160
accurate measurement so that dad is

00:32:54,179 --> 00:33:03,910
worth you thank you

00:32:59,160 --> 00:33:03,910

YouTube URL: https://www.youtube.com/watch?v=RjNEbTaqnX4


