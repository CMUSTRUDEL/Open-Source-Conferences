Title: Netdev 1.1 - On getting tc classifier fully programmable with cls_bpf
Publication date: 2016-03-15
Playlist: Netdev 1.1 - Day 3 - Friday February 12, 2016
Description: 
	Daniel Borkmann
February 2016
Captions: 
	00:00:00,260 --> 00:00:07,109
first I will for those of you don't know

00:00:03,389 --> 00:00:09,510
about a PDF give a short historical

00:00:07,109 --> 00:00:13,740
introduction then what it is and how it

00:00:09,510 --> 00:00:16,560
compares to a classic BPF and after that

00:00:13,740 --> 00:00:19,170
I will go into TC so dtc front end how

00:00:16,560 --> 00:00:22,859
does interacts with each other and ghent

00:00:19,170 --> 00:00:27,240
a couple of small examples to play

00:00:22,859 --> 00:00:31,230
around with and get started alright so

00:00:27,240 --> 00:00:33,360
far so the concept of BPF or a berkeley

00:00:31,230 --> 00:00:34,950
packet filter it is actually what are

00:00:33,360 --> 00:00:38,670
quite old it's it's nothing new to

00:00:34,950 --> 00:00:41,820
general idea it's basically in a very

00:00:38,670 --> 00:00:44,460
small bytecode language arts so the

00:00:41,820 --> 00:00:47,160
original problem was from the TCP dump

00:00:44,460 --> 00:00:50,870
and the pickup project that he had they

00:00:47,160 --> 00:00:54,140
wanted to have efficient and also a safe

00:00:50,870 --> 00:00:57,300
solution for our packet parsing package

00:00:54,140 --> 00:00:59,940
parsing is as we know are not that

00:00:57,300 --> 00:01:01,559
trivial based on a couple of CVS that we

00:00:59,940 --> 00:01:04,379
will see here and there when things

00:01:01,559 --> 00:01:05,850
crash so there should be a safe and

00:01:04,379 --> 00:01:10,460
generic solution so instead of

00:01:05,850 --> 00:01:13,680
implementing every possible protocol

00:01:10,460 --> 00:01:16,470
protocols for example in the kernel

00:01:13,680 --> 00:01:23,250
directly they designed something some

00:01:16,470 --> 00:01:24,509
minimal generic language and the TCP

00:01:23,250 --> 00:01:26,430
dump so when you for example enter a

00:01:24,509 --> 00:01:30,270
filter like into below case when you

00:01:26,430 --> 00:01:32,670
want to filter for IP the this filter

00:01:30,270 --> 00:01:35,119
string is passed from tcpdump down into

00:01:32,670 --> 00:01:39,450
lippy cap and the pcap has an internal

00:01:35,119 --> 00:01:42,630
PPF compiler which generates the below

00:01:39,450 --> 00:01:46,049
bytecode that you can see here in that

00:01:42,630 --> 00:01:49,259
case it loads Halford after it a type

00:01:46,049 --> 00:01:53,640
and compares it to the IP if you type

00:01:49,259 --> 00:01:57,030
and if that comparison is true it jumps

00:01:53,640 --> 00:01:58,890
to the label to which returns that value

00:01:57,030 --> 00:02:02,460
and it if it's false it with trolls

00:01:58,890 --> 00:02:05,369
return 0 in that case it means whenever

00:02:02,460 --> 00:02:07,640
turn 0 that it would be a drop and in

00:02:05,369 --> 00:02:11,930
that case the filter gets past our

00:02:07,640 --> 00:02:18,290
further to AF packet for processing

00:02:11,930 --> 00:02:21,590
so the ideas in that case of AF packet

00:02:18,290 --> 00:02:23,239
and other things since it's a very small

00:02:21,590 --> 00:02:25,459
and generic language that this can be

00:02:23,239 --> 00:02:28,250
pushed into the kernel and executed in

00:02:25,459 --> 00:02:31,030
the kernel at a very early point in time

00:02:28,250 --> 00:02:32,959
so that we don't have to waste resources

00:02:31,030 --> 00:02:38,019
bringing the packet all the way up to

00:02:32,959 --> 00:02:42,739
use the space just to drop it there so

00:02:38,019 --> 00:02:44,120
for that also in 2011 just-in-time

00:02:42,739 --> 00:02:47,720
compiler has been added to the colonel

00:02:44,120 --> 00:02:49,370
it was first edit for x86 and later on

00:02:47,720 --> 00:02:53,269
other architectures followed like

00:02:49,370 --> 00:02:56,659
PowerPC spark both arm flavors s3 and 90

00:02:53,269 --> 00:02:59,299
and also MIPS and what you do is after

00:02:56,659 --> 00:03:01,280
you load the program into the kernel in

00:02:59,299 --> 00:03:06,590
the kernel based on the architecture

00:03:01,280 --> 00:03:08,200
translate those small up codes that you

00:03:06,590 --> 00:03:12,019
can see here are those small

00:03:08,200 --> 00:03:15,859
instructions into native machine up

00:03:12,019 --> 00:03:19,579
cards so that this can run with native

00:03:15,859 --> 00:03:23,229
performance nowadays ppf is used in

00:03:19,579 --> 00:03:23,229
quite a number of areas in the Connaught

00:03:24,040 --> 00:03:28,879
there are like three big areas that you

00:03:27,229 --> 00:03:32,120
can categorize that into which is

00:03:28,879 --> 00:03:35,659
networking tracing and also sent boxing

00:03:32,120 --> 00:03:39,829
so net-net working it's not only used in

00:03:35,659 --> 00:03:43,849
in TC what I'm talking about today but

00:03:39,829 --> 00:03:46,489
also in socket filters so as I mentioned

00:03:43,849 --> 00:03:48,409
AF packet is making use of it but not

00:03:46,489 --> 00:03:52,699
only if packet also other protocols like

00:03:48,409 --> 00:03:57,650
UDP or TCP or a net link you can attach

00:03:52,699 --> 00:04:01,699
PPF programs to the naf packet has also

00:03:57,650 --> 00:04:03,379
another possibility if packet has

00:04:01,699 --> 00:04:06,859
something that is called packet fan out

00:04:03,379 --> 00:04:09,109
which means you have multiple process

00:04:06,859 --> 00:04:11,479
instances that have AF packet sockets

00:04:09,109 --> 00:04:14,239
and you can group them together in a

00:04:11,479 --> 00:04:17,509
fan-out group and so to distribute the

00:04:14,239 --> 00:04:21,950
incoming load and the endures you can

00:04:17,509 --> 00:04:23,529
attach for that and BPF program that can

00:04:21,950 --> 00:04:25,610
in the end make a decision to which

00:04:23,529 --> 00:04:28,909
member of the group to

00:04:25,610 --> 00:04:31,030
forward that packet to so it can make

00:04:28,909 --> 00:04:34,639
the team works decision for example

00:04:31,030 --> 00:04:38,810
there also a couple of other things like

00:04:34,639 --> 00:04:42,349
as a real sport got recently added yeah

00:04:38,810 --> 00:04:45,199
so it's it's it's very generic and can

00:04:42,349 --> 00:04:48,020
be applied to many sub-project in terms

00:04:45,199 --> 00:04:50,479
of tracing i think is got added like one

00:04:48,020 --> 00:04:52,099
or two years ago to the colonel at ppf

00:04:50,479 --> 00:04:54,949
programs can be attached to k probes

00:04:52,099 --> 00:04:58,129
which is it very useful so you can

00:04:54,949 --> 00:05:00,229
account for certain events or do a

00:04:58,129 --> 00:05:02,750
couple of other things sent boxing i

00:05:00,229 --> 00:05:05,870
think some of you have heard of second

00:05:02,750 --> 00:05:09,919
ppf so it's used in system called

00:05:05,870 --> 00:05:12,860
filtering so whenever you execute a

00:05:09,919 --> 00:05:16,400
system call and the program has a ppf

00:05:12,860 --> 00:05:17,900
program for sec comp attached then there

00:05:16,400 --> 00:05:20,180
are some similar instructions like here

00:05:17,900 --> 00:05:22,969
it can check for the system call number

00:05:20,180 --> 00:05:27,370
and a couple and even arguments in a

00:05:22,969 --> 00:05:31,279
limited way and for example if some

00:05:27,370 --> 00:05:33,889
malicious code when would break out of

00:05:31,279 --> 00:05:37,270
that of that white list the kernel can

00:05:33,889 --> 00:05:40,969
just kill the process today are quite

00:05:37,270 --> 00:05:43,039
it's quite generic and flexible so as

00:05:40,969 --> 00:05:47,029
you can see it therefore it also found

00:05:43,039 --> 00:05:51,680
some different use cases so what is

00:05:47,029 --> 00:05:54,830
classic PPF classic PPF in general the

00:05:51,680 --> 00:05:57,139
architecture and it is already in the

00:05:54,830 --> 00:05:59,750
kernel for quite a while it's ready to

00:05:57,139 --> 00:06:01,279
bit registers so you have an in a

00:05:59,750 --> 00:06:04,729
register and expo Chester Avery

00:06:01,279 --> 00:06:07,339
Chester's and the accumulator X is like

00:06:04,729 --> 00:06:10,219
a temporary register and you have M

00:06:07,339 --> 00:06:13,400
which which I which is like a scratch

00:06:10,219 --> 00:06:16,069
space or stack which is like 16 slots of

00:06:13,400 --> 00:06:18,939
32-bit registers and implicitly so

00:06:16,069 --> 00:06:23,659
program counter the instruction size

00:06:18,939 --> 00:06:27,020
itself is 64-bit so it's it's divided

00:06:23,659 --> 00:06:29,599
into 16 bit of the actual code then you

00:06:27,020 --> 00:06:33,469
have a chump true and hm falls offset

00:06:29,599 --> 00:06:36,139
and constant or immediate value which is

00:06:33,469 --> 00:06:38,020
called k usually you have a number of

00:06:36,139 --> 00:06:40,660
instruction classes

00:06:38,020 --> 00:06:44,259
for load-in store those X to the end

00:06:40,660 --> 00:06:46,479
here and LD X this means that the load

00:06:44,259 --> 00:06:49,720
instead of going to the a register it

00:06:46,479 --> 00:06:52,060
goes to the expo Chester but generally

00:06:49,720 --> 00:06:54,190
the averages to the accumulators used

00:06:52,060 --> 00:06:57,340
for almost everything like other

00:06:54,190 --> 00:07:00,990
operations or if you have some

00:06:57,340 --> 00:07:05,520
comparison for jump operations it also

00:07:00,990 --> 00:07:08,590
is comparing against the a register

00:07:05,520 --> 00:07:12,009
classic ppf programs they only have four

00:07:08,590 --> 00:07:13,630
wrk jumps so the general ideas to have

00:07:12,009 --> 00:07:15,400
that really simple and to have a

00:07:13,630 --> 00:07:20,349
guarantee that the program always

00:07:15,400 --> 00:07:23,199
returns it also makes it easier to for

00:07:20,349 --> 00:07:25,960
the verifier in the colonel there are

00:07:23,199 --> 00:07:29,770
maximum of 4000 69 instructions possible

00:07:25,960 --> 00:07:32,590
it can be injected and Linux has a

00:07:29,770 --> 00:07:35,500
couple of Linux specific extensions so

00:07:32,590 --> 00:07:38,909
the load operations are from the load

00:07:35,500 --> 00:07:45,509
instruction class they have a couple of

00:07:38,909 --> 00:07:48,280
so so do you have a specific offset and

00:07:45,509 --> 00:07:49,930
for that specific offset the meaning of

00:07:48,280 --> 00:07:52,840
the Lord is a bit overloaded in the

00:07:49,930 --> 00:07:55,630
sense that in Linux you can for example

00:07:52,840 --> 00:07:57,849
load the queue mapping from an esky be

00:07:55,630 --> 00:07:59,529
or the current cpu and things like that

00:07:57,849 --> 00:08:02,699
so it was added a certain kind of

00:07:59,529 --> 00:08:08,560
extension for accessing somewhere Linux

00:08:02,699 --> 00:08:11,020
specific metadata there's a tool in the

00:08:08,560 --> 00:08:14,919
linux kernel tree which is called PPF

00:08:11,020 --> 00:08:17,500
ASM which is under tools net and they're

00:08:14,919 --> 00:08:20,259
accounted like 43 instructions 11

00:08:17,500 --> 00:08:24,250
different addressing modes and 16 of the

00:08:20,259 --> 00:08:27,940
of that Linux specific extensions the

00:08:24,250 --> 00:08:31,569
input data that we operate on this or

00:08:27,940 --> 00:08:34,479
that we call that context or ctx and it

00:08:31,569 --> 00:08:36,760
can here it'll be a skp so a socket

00:08:34,479 --> 00:08:41,380
buffer or some pre-populated sec

00:08:36,760 --> 00:08:43,659
metadata and t semantics of a program is

00:08:41,380 --> 00:08:46,149
usually defined by the application so as

00:08:43,659 --> 00:08:48,040
for example in the TCP dump case as

00:08:46,149 --> 00:08:51,460
you've seen those two different return

00:08:48,040 --> 00:08:56,590
values so here 0 means drop and

00:08:51,460 --> 00:08:59,680
that 65,000 something means that i keep

00:08:56,590 --> 00:09:02,290
the full packet if that would be a

00:08:59,680 --> 00:09:04,360
smaller value than the skb length then

00:09:02,290 --> 00:09:07,510
in that case or in that particular

00:09:04,360 --> 00:09:13,810
application of ppf it would be truncated

00:09:07,510 --> 00:09:17,020
to ask you be so now going to not going

00:09:13,810 --> 00:09:21,910
to ebf so ebf to was added to the

00:09:17,020 --> 00:09:25,720
colonel it has 64-bit registers but also

00:09:21,910 --> 00:09:30,150
I 32-bit sup registers since the classic

00:09:25,720 --> 00:09:33,370
BPF has to run there as well it has a

00:09:30,150 --> 00:09:37,150
couple of more registers so r 0 to our

00:09:33,370 --> 00:09:39,430
10 you only read only registers are 10

00:09:37,150 --> 00:09:42,910
which points to the frame pointer and

00:09:39,430 --> 00:09:45,460
the other ones are rabid generic so it's

00:09:42,910 --> 00:09:46,990
not like like in classic BPF where you

00:09:45,460 --> 00:09:49,360
only have the averages to where i can do

00:09:46,990 --> 00:09:52,810
particular operations on here it's all

00:09:49,360 --> 00:09:55,900
the others that can it can be used for

00:09:52,810 --> 00:10:00,130
that you have a stack space as well in

00:09:55,900 --> 00:10:02,200
that case it's 512 bytes and justly

00:10:00,130 --> 00:10:06,040
program counter the instruction is

00:10:02,200 --> 00:10:08,620
64-bit as well and the it's violet into

00:10:06,040 --> 00:10:10,780
its divided a bit differently so you

00:10:08,620 --> 00:10:14,080
only have 8 bit of the code which is

00:10:10,780 --> 00:10:18,040
sufficient then you have a destination

00:10:14,080 --> 00:10:20,380
and sauce register and which is both

00:10:18,040 --> 00:10:23,620
8-bit and then you have an an offset

00:10:20,380 --> 00:10:26,590
which is used for jumps here it's as you

00:10:23,620 --> 00:10:30,250
can see assigned offset and also the

00:10:26,590 --> 00:10:33,280
immediate value which scientist well you

00:10:30,250 --> 00:10:36,940
have a couple of new instructions like a

00:10:33,280 --> 00:10:40,180
double word load or store so it you can

00:10:36,940 --> 00:10:42,730
have a 64-bit immediate value that you

00:10:40,180 --> 00:10:47,320
load you have a move instruction you

00:10:42,730 --> 00:10:49,750
have all the 64-bit flavors sign shifts

00:10:47,320 --> 00:10:51,510
engine room con conversions calls which

00:10:49,750 --> 00:10:54,990
I'm going to talk about in a moment and

00:10:51,510 --> 00:10:57,270
also atomic add ok

00:10:54,990 --> 00:11:00,300
write a name is right do you want that's

00:10:57,270 --> 00:11:02,160
what I'm going to talk about so in terms

00:11:00,300 --> 00:11:04,170
of jumps you have forward and backward

00:11:02,160 --> 00:11:06,029
champs but black white gems are limited

00:11:04,170 --> 00:11:09,330
that you cannot implement an infinite

00:11:06,029 --> 00:11:12,470
loop so the the colonel verifier

00:11:09,330 --> 00:11:14,610
analyzes if the area add that so it

00:11:12,470 --> 00:11:17,270
visits all branches from the whole

00:11:14,610 --> 00:11:21,149
program and if it sees the back jump and

00:11:17,270 --> 00:11:25,290
it only allows the program to pass if

00:11:21,149 --> 00:11:29,370
that was previously unvisited so loops

00:11:25,290 --> 00:11:32,850
are not possible here you also have 4096

00:11:29,370 --> 00:11:36,959
instructions like in classic PPF and

00:11:32,850 --> 00:11:39,350
then you have a couple of more like an

00:11:36,959 --> 00:11:43,140
entity is at a part of the architecture

00:11:39,350 --> 00:11:46,980
and so here for example you have a

00:11:43,140 --> 00:11:51,180
generic helper function concept so that

00:11:46,980 --> 00:11:54,149
means you have a message specifically

00:11:51,180 --> 00:11:56,430
defined template how a helper function

00:11:54,149 --> 00:12:03,839
looks like so helper function takes like

00:11:56,430 --> 00:12:08,250
5 registers as an input and it has 6 64

00:12:03,839 --> 00:12:11,370
bit return value and all helper

00:12:08,250 --> 00:12:13,610
functions have to come comply to that

00:12:11,370 --> 00:12:18,209
particular template so you have like a

00:12:13,610 --> 00:12:20,220
calling convention with that so a BPF

00:12:18,209 --> 00:12:24,540
program they had it has to populate

00:12:20,220 --> 00:12:26,940
those five registers according to what

00:12:24,540 --> 00:12:31,860
argument types would be specified the

00:12:26,940 --> 00:12:35,490
verify can can check that and yeah the

00:12:31,860 --> 00:12:38,250
advantage of that is and since this is

00:12:35,490 --> 00:12:40,310
very closely modeled to the to the

00:12:38,250 --> 00:12:42,870
underlying architecture at least in x86

00:12:40,310 --> 00:12:45,149
when this gets just-in-time compiled

00:12:42,870 --> 00:12:47,630
everything is already pre-populated from

00:12:45,149 --> 00:12:50,339
the BPF program so it just has to

00:12:47,630 --> 00:12:55,649
execute the call instruction and that's

00:12:50,339 --> 00:12:57,529
it and the nice thing is that whenever

00:12:55,649 --> 00:13:00,149
you add a new helper you don't have to

00:12:57,529 --> 00:13:03,660
modify the just-in-time compiler so I

00:13:00,149 --> 00:13:06,779
just is just more generic then you have

00:13:03,660 --> 00:13:08,520
maps so maps are like some light weights

00:13:06,779 --> 00:13:11,430
kewell you store

00:13:08,520 --> 00:13:12,900
and they can be arbitrarily shared which

00:13:11,430 --> 00:13:16,290
means maps can be shared between

00:13:12,900 --> 00:13:19,650
multiple EPF programs but also between

00:13:16,290 --> 00:13:21,930
EBP F programs and user space so user

00:13:19,650 --> 00:13:26,820
space can feed data into it or read data

00:13:21,930 --> 00:13:28,620
out and for EPF programs they have some

00:13:26,820 --> 00:13:30,570
state that they can even share among

00:13:28,620 --> 00:13:35,690
themselves which is very powerful I

00:13:30,570 --> 00:13:35,690
think then you have a telecoil concept

00:13:37,610 --> 00:13:45,210
teracles can be seen that that you load

00:13:41,220 --> 00:13:46,740
multiple BPF programs and if you execute

00:13:45,210 --> 00:13:49,640
the tag call it would be like a long

00:13:46,740 --> 00:13:54,480
jump from one eb PF program into another

00:13:49,640 --> 00:13:57,030
reusing the same stack frame ter cards

00:13:54,480 --> 00:14:00,270
they require to have a special kind of a

00:13:57,030 --> 00:14:05,850
map that gets populated from user space

00:14:00,270 --> 00:14:06,990
and so whenever you load an EPF program

00:14:05,850 --> 00:14:09,120
you get a file descriptor from the

00:14:06,990 --> 00:14:12,200
colonel and then you can edit file

00:14:09,120 --> 00:14:16,470
descriptor into that map the colonel

00:14:12,200 --> 00:14:22,350
caches the actual pointer in that

00:14:16,470 --> 00:14:25,950
particular map slot and when you do a

00:14:22,350 --> 00:14:27,240
tailor call in like a function call

00:14:25,950 --> 00:14:29,750
which the colonel trends itunes to

00:14:27,240 --> 00:14:34,110
instructions then it would just jump

00:14:29,750 --> 00:14:36,900
directly into that other program you

00:14:34,110 --> 00:14:39,990
also have EPF object pinning and that

00:14:36,900 --> 00:14:42,030
means that since everything is based on

00:14:39,990 --> 00:14:45,570
file descriptors maps as well as

00:14:42,030 --> 00:14:47,280
programs they only live in the context

00:14:45,570 --> 00:14:52,140
of the application itself so when you

00:14:47,280 --> 00:14:55,920
want to have like in the case of TC

00:14:52,140 --> 00:14:57,990
which does to set up and then exits and

00:14:55,920 --> 00:14:59,130
you want to reuse the same map or you

00:14:57,990 --> 00:15:01,740
want to share that map with other

00:14:59,130 --> 00:15:04,710
programs and you need to have ornate you

00:15:01,740 --> 00:15:07,500
need to fetch that context back again so

00:15:04,710 --> 00:15:10,710
there's a small studio file system where

00:15:07,500 --> 00:15:13,530
you can pin like such a file descriptors

00:15:10,710 --> 00:15:17,760
in as a node and you can retrieve it

00:15:13,530 --> 00:15:21,480
again and also most importantly EP PF

00:15:17,760 --> 00:15:22,180
has an lvm back end which means you can

00:15:21,480 --> 00:15:24,940
write

00:15:22,180 --> 00:15:28,630
and restricted see like men are some

00:15:24,940 --> 00:15:31,750
programs for that and lvm can translate

00:15:28,630 --> 00:15:35,890
that into an object file where do you

00:15:31,750 --> 00:15:39,700
actually ppf code resides that can be

00:15:35,890 --> 00:15:43,540
loaded by the pipe by loaders like t see

00:15:39,700 --> 00:15:45,100
for example or others so the usual work

00:15:43,540 --> 00:15:47,260
flow would be your right your program in

00:15:45,100 --> 00:15:51,190
c you compile it with lvm generates

00:15:47,260 --> 00:15:55,300
object file learn like a elf file and TC

00:15:51,190 --> 00:15:57,070
reads that parses it thus relocations

00:15:55,300 --> 00:16:00,250
loads everything into the kernel and

00:15:57,070 --> 00:16:01,959
then in the end it has a study file

00:16:00,250 --> 00:16:03,940
descriptor from the actual program and

00:16:01,959 --> 00:16:07,630
then it pushes that file descriptor into

00:16:03,940 --> 00:16:09,339
the BPF classifier andy in the

00:16:07,630 --> 00:16:13,300
classifier holds that program into the

00:16:09,339 --> 00:16:15,040
kernel and when SQ peas pass through

00:16:13,300 --> 00:16:19,600
that it does whatever classification or

00:16:15,040 --> 00:16:24,250
actions you want with it so more general

00:16:19,600 --> 00:16:25,839
remarks it's it's a stable ABI from user

00:16:24,250 --> 00:16:27,880
space which is very which is quite

00:16:25,839 --> 00:16:29,920
useful so it's not like you have some

00:16:27,880 --> 00:16:32,770
modules you have to change it all the

00:16:29,920 --> 00:16:34,959
time similarly the case with CBP f of

00:16:32,770 --> 00:16:36,730
course so I will you said management is

00:16:34,959 --> 00:16:40,060
treated PPF system call where you have

00:16:36,730 --> 00:16:42,160
those file descriptors and they point to

00:16:40,060 --> 00:16:44,080
the colonel resource which is map or

00:16:42,160 --> 00:16:46,420
program right and the colonel doesn't

00:16:44,080 --> 00:16:49,270
have classic PPF in the interpreter

00:16:46,420 --> 00:16:51,490
anymore so everything is EPP f which

00:16:49,270 --> 00:16:54,130
means that whenever you load the classic

00:16:51,490 --> 00:16:56,200
PPF program the colonel has to transform

00:16:54,130 --> 00:16:58,209
or microwave that in to 'hey BPF so

00:16:56,200 --> 00:17:00,940
after verification there a couple of

00:16:58,209 --> 00:17:06,870
steps the colonel has to go through and

00:17:00,940 --> 00:17:09,610
then rewrite everything in eb PF and

00:17:06,870 --> 00:17:11,170
there are a couple of so some of those

00:17:09,610 --> 00:17:15,309
just-in-time compilers that i mentioned

00:17:11,170 --> 00:17:16,990
in the very first light there some of

00:17:15,309 --> 00:17:21,550
them are available for EBP f which is

00:17:16,990 --> 00:17:24,579
x86 s390 and i'm 64 there there are some

00:17:21,550 --> 00:17:28,470
other ones that are work in progress to

00:17:24,579 --> 00:17:31,540
microwave / 2 eb PF which is very useful

00:17:28,470 --> 00:17:35,190
and in terms of security as i already

00:17:31,540 --> 00:17:38,260
mentioned you have the verifier itself

00:17:35,190 --> 00:17:40,450
and you have a couple of hardening

00:17:38,260 --> 00:17:43,360
measures and some more non-root

00:17:40,450 --> 00:17:47,770
restrictions where you cannot lick some

00:17:43,360 --> 00:17:51,490
pointers and things like that do you not

00:17:47,770 --> 00:17:53,650
get to the USB PF part so CSP PF so the

00:17:51,490 --> 00:17:56,950
ppf classifier chamada would you mention

00:17:53,650 --> 00:17:58,660
it in his talk it was added in 2013 but

00:17:56,950 --> 00:18:02,140
EPP have support got added in the last

00:17:58,660 --> 00:18:05,020
year the fast path is very minimal so it

00:18:02,140 --> 00:18:08,260
just caused into the ppf program run and

00:18:05,020 --> 00:18:12,190
that's it and with your specified ppf

00:18:08,260 --> 00:18:15,430
program of course the instance can hold

00:18:12,190 --> 00:18:18,130
one or more ppf programs and there are

00:18:15,430 --> 00:18:21,130
two operation modes which i think is

00:18:18,130 --> 00:18:23,680
very important one is to call where it

00:18:21,130 --> 00:18:30,570
normally calls into the and action

00:18:23,680 --> 00:18:32,980
engine which is TC F X extensions exact

00:18:30,570 --> 00:18:36,040
but you also have a direct action mode

00:18:32,980 --> 00:18:39,310
which is sort of a fast path where it

00:18:36,040 --> 00:18:41,770
immediately returns after doing whatever

00:18:39,310 --> 00:18:44,710
ID program does and the reason is

00:18:41,770 --> 00:18:48,730
because II PPF can already mangalore

00:18:44,710 --> 00:18:50,440
forward or update stuff from the packet

00:18:48,730 --> 00:18:52,240
so it can already perform some actions

00:18:50,440 --> 00:18:55,990
and if that's good for you then you can

00:18:52,240 --> 00:18:57,970
immediately returned already it has a

00:18:55,990 --> 00:19:03,100
couple of up codes that it supports for

00:18:57,970 --> 00:19:07,150
that like like you can drop your packet

00:19:03,100 --> 00:19:09,430
or redirect it for example and as I

00:19:07,150 --> 00:19:11,860
already mentioned TG the TC front and

00:19:09,430 --> 00:19:14,620
that's all they have you setup work so

00:19:11,860 --> 00:19:18,100
it only passes down to file descriptor

00:19:14,620 --> 00:19:20,500
to see less BPF or we're not linked some

00:19:18,100 --> 00:19:23,610
couple of things that are possible so

00:19:20,500 --> 00:19:26,620
you have you can read/write sqb metadata

00:19:23,610 --> 00:19:28,210
some of that you can only read and some

00:19:26,620 --> 00:19:31,420
of that you can read and write so it

00:19:28,210 --> 00:19:33,880
like mark priority TC index then you

00:19:31,420 --> 00:19:36,100
have the CB area which you can use as a

00:19:33,880 --> 00:19:39,190
scratch space for example to pass

00:19:36,100 --> 00:19:41,350
arguments further to tear calls and a

00:19:39,190 --> 00:19:45,040
couple of other things then you can use

00:19:41,350 --> 00:19:48,029
it also in terms of tunnels so there's

00:19:45,040 --> 00:19:52,529
this tunnel key infrastructure

00:19:48,029 --> 00:19:54,570
where you can run like VIX learn forex

00:19:52,529 --> 00:19:56,580
forex device for example and collect

00:19:54,570 --> 00:20:00,719
metadata mode and you can populate that

00:19:56,580 --> 00:20:03,599
or retrieve the information yae ppf

00:20:00,719 --> 00:20:05,759
program for ipv4 ipv6 which i think is

00:20:03,599 --> 00:20:08,279
very powerful and then I said mention

00:20:05,759 --> 00:20:10,169
you have a couple of helpers like to

00:20:08,279 --> 00:20:12,769
access maps to update lookup delete

00:20:10,169 --> 00:20:15,599
items from there to load or store

00:20:12,769 --> 00:20:18,659
multiply it's from an mms kabhi to make

00:20:15,599 --> 00:20:21,029
a checksum fix-ups to redirect it you

00:20:18,659 --> 00:20:22,440
have real and push pop you have some

00:20:21,029 --> 00:20:24,929
infrastructure for debugging you can

00:20:22,440 --> 00:20:26,580
read the outsi group and so on so you

00:20:24,929 --> 00:20:29,009
can help you have all those building

00:20:26,580 --> 00:20:30,599
blocks and then you can define your

00:20:29,009 --> 00:20:33,210
application you can program that and see

00:20:30,599 --> 00:20:36,749
and so to tailor it to your specific use

00:20:33,210 --> 00:20:41,279
case the a couple of invocation points

00:20:36,749 --> 00:20:43,289
so you have those sort of pseudocode qdq

00:20:41,279 --> 00:20:47,070
disks which is in grass and recently

00:20:43,289 --> 00:20:49,469
added CLS act where they can attach ppf

00:20:47,070 --> 00:20:52,019
programs to today ingress part to the

00:20:49,469 --> 00:20:53,519
early increased part and in the equation

00:20:52,019 --> 00:20:55,440
you have like two possibilities either

00:20:53,519 --> 00:20:57,269
your cutest it's a class-4 cutest so you

00:20:55,440 --> 00:21:01,049
have a classifier for that that you

00:20:57,269 --> 00:21:02,999
attach or you have the hope that was

00:21:01,049 --> 00:21:05,219
recently added on top of that which is

00:21:02,999 --> 00:21:08,549
attended an earlier point but still in

00:21:05,219 --> 00:21:12,599
the Deaf QX MIT path so I think that's

00:21:08,549 --> 00:21:15,149
quite powerful just to give an example

00:21:12,599 --> 00:21:16,559
set up in only one slide so it's very

00:21:15,149 --> 00:21:18,719
simple the first thing you do is you

00:21:16,559 --> 00:21:21,359
compile your program then you can for

00:21:18,719 --> 00:21:23,789
example at the CLS act q disk and then

00:21:21,359 --> 00:21:26,460
you can either on the ingress or egress

00:21:23,789 --> 00:21:32,879
I can specify it as a parent and then

00:21:26,460 --> 00:21:35,369
add your TC filter with those comments

00:21:32,879 --> 00:21:37,559
what that means is you select BPF front

00:21:35,369 --> 00:21:39,749
and you have to direct action mode here

00:21:37,559 --> 00:21:42,570
you specify the object itself and the

00:21:39,749 --> 00:21:45,509
object itself can have multiple program

00:21:42,570 --> 00:21:47,879
sections and you you specify basically

00:21:45,509 --> 00:21:49,769
just two sections you can do a show on

00:21:47,879 --> 00:21:54,210
the filter and you can delete them and

00:21:49,769 --> 00:21:55,950
that's that's it so it's very simple gtc

00:21:54,210 --> 00:21:58,340
front and it basically has to walk to e

00:21:55,950 --> 00:22:01,190
BPF file

00:21:58,340 --> 00:22:04,250
it can also mount the pseudo file system

00:22:01,190 --> 00:22:08,990
for pinning nodes it's it sets up or

00:22:04,250 --> 00:22:10,820
maps the maps are part of the elf object

00:22:08,990 --> 00:22:13,700
file so it reads all the specification

00:22:10,820 --> 00:22:16,010
sets it up and generates those file

00:22:13,700 --> 00:22:18,049
descriptors it has to do relocations so

00:22:16,010 --> 00:22:20,600
whenever I BPF program wants to access

00:22:18,049 --> 00:22:22,279
the map it has to inject the file

00:22:20,600 --> 00:22:25,429
descriptor into that particular

00:22:22,279 --> 00:22:28,010
instruction as an immediate value um and

00:22:25,429 --> 00:22:30,909
it ending loads the actual program into

00:22:28,010 --> 00:22:34,909
the kernel and it also sets up those

00:22:30,909 --> 00:22:37,250
programs that have tail calls yeah and

00:22:34,909 --> 00:22:39,860
you can do some debugging and stuff like

00:22:37,250 --> 00:22:45,440
that so just to give a very minimal

00:22:39,860 --> 00:22:48,080
example so here's this more program that

00:22:45,440 --> 00:22:51,830
only sets the priority based on the seat

00:22:48,080 --> 00:22:58,909
group and that's it and then it returns

00:22:51,830 --> 00:23:00,890
okay and you can note that as I said you

00:22:58,909 --> 00:23:02,570
can come compile that with with clang

00:23:00,890 --> 00:23:05,990
and then you can roll it into the kernel

00:23:02,570 --> 00:23:08,870
and if you would have like a debug

00:23:05,990 --> 00:23:12,529
statement like a try sprint k then you

00:23:08,870 --> 00:23:14,450
can also show the trace pipe to see

00:23:12,529 --> 00:23:17,360
what's going on and then when you have

00:23:14,450 --> 00:23:20,360
your application you can create new see

00:23:17,360 --> 00:23:22,970
crew add an ID for that which is then

00:23:20,360 --> 00:23:24,830
eventually the SQ be priority and you

00:23:22,970 --> 00:23:31,100
can execute that application and that's

00:23:24,830 --> 00:23:33,500
already it yeah that's good then just to

00:23:31,100 --> 00:23:37,159
give a very minimal toy example how we

00:23:33,500 --> 00:23:39,309
can share map so here you can define a

00:23:37,159 --> 00:23:42,409
map which in that case is a BPF array

00:23:39,309 --> 00:23:45,649
and that map gets automatically pinned

00:23:42,409 --> 00:23:47,090
by TC into that pseudo file system so it

00:23:45,649 --> 00:23:50,149
can be retrieved later and here you have

00:23:47,090 --> 00:23:51,799
to program sections so one is intended

00:23:50,149 --> 00:23:55,549
for ingress in the other one for the

00:23:51,799 --> 00:23:58,190
egress part and in the english part it

00:23:55,549 --> 00:23:59,809
basically just looks up the element and

00:23:58,190 --> 00:24:02,480
prints out the value and the equals part

00:23:59,809 --> 00:24:05,000
it only increments it so whenever TC

00:24:02,480 --> 00:24:07,610
loads that kind of thing and you specify

00:24:05,000 --> 00:24:11,610
those sections it it will and under in

00:24:07,610 --> 00:24:14,760
the first loading generated map since

00:24:11,610 --> 00:24:16,710
yet present anywhere and then pin it in

00:24:14,760 --> 00:24:18,690
the file system since you specified it

00:24:16,710 --> 00:24:21,390
as such and then the equal part it will

00:24:18,690 --> 00:24:24,240
just retrieve that file descriptor from

00:24:21,390 --> 00:24:26,429
the pinned node so as you therefore you

00:24:24,240 --> 00:24:30,630
have a deaf for both are shared between

00:24:26,429 --> 00:24:32,850
both programs tear cards so as you can

00:24:30,630 --> 00:24:36,270
see here in that example you have a

00:24:32,850 --> 00:24:41,220
program array map it also has to be

00:24:36,270 --> 00:24:42,840
pinned because it has to be why it does

00:24:41,220 --> 00:24:45,179
not necessarily have to be pinned in

00:24:42,840 --> 00:24:48,799
that particular example but just to show

00:24:45,179 --> 00:24:54,000
you entity sort that TC loader

00:24:48,799 --> 00:24:57,030
effectively loads that map it pushes

00:24:54,000 --> 00:25:00,030
that that first program section which is

00:24:57,030 --> 00:25:02,220
part of the tail call with the file

00:25:00,030 --> 00:25:05,250
descriptor into the map and later on

00:25:02,220 --> 00:25:10,350
loads the the main program the entry

00:25:05,250 --> 00:25:13,470
program which in that case references

00:25:10,350 --> 00:25:18,320
the telecoil map and here you can see a

00:25:13,470 --> 00:25:20,970
tail call with the key or index of 0 and

00:25:18,320 --> 00:25:22,890
it will jump right into that because I

00:25:20,970 --> 00:25:28,380
specified that it has to be law that the

00:25:22,890 --> 00:25:31,080
key index of 0 as well um yeah so to

00:25:28,380 --> 00:25:33,840
just give a short summary has two

00:25:31,080 --> 00:25:37,080
takeaways actually it's it's rather easy

00:25:33,840 --> 00:25:40,950
to write EP PF programs for for the TC

00:25:37,080 --> 00:25:43,950
case and it's very nice closet this

00:25:40,950 --> 00:25:46,320
table API it's you can fully tailor it

00:25:43,950 --> 00:25:48,000
to your specific use case and when you

00:25:46,320 --> 00:25:50,790
Justin Qaeda when you're just in time

00:25:48,000 --> 00:25:52,820
compile it and it runs wit with native

00:25:50,790 --> 00:25:55,980
performance so it's very flexible

00:25:52,820 --> 00:25:58,049
everything I talked about is upstream so

00:25:55,980 --> 00:25:59,940
its up streaming the colonel I pr2 and

00:25:58,049 --> 00:26:02,790
lvm so if you can retrieve it from the

00:25:59,940 --> 00:26:04,679
usual places and there are a couple of

00:26:02,790 --> 00:26:06,210
more examples so i just talked about

00:26:04,679 --> 00:26:08,600
some toy examples but there are a couple

00:26:06,210 --> 00:26:12,059
of more and the IPO are two examples

00:26:08,600 --> 00:26:15,540
folder you have there even you have to

00:26:12,059 --> 00:26:18,030
even a fully almost fully flow just

00:26:15,540 --> 00:26:21,600
sector for example you can just rip

00:26:18,030 --> 00:26:23,640
apart and toy around with it and there's

00:26:21,600 --> 00:26:25,230
a couple of more documentation and in

00:26:23,640 --> 00:26:27,540
the kernel tree of course

00:26:25,230 --> 00:26:29,340
should be updated as usual but it's a

00:26:27,540 --> 00:26:31,620
starting point at least and you have

00:26:29,340 --> 00:26:35,730
also two men pages one from the syscall

00:26:31,620 --> 00:26:37,440
itself and the other one in TC thanks

00:26:35,730 --> 00:27:08,880
for thank you very much are there any

00:26:37,440 --> 00:27:12,809
questions or comments so in the PPF code

00:27:08,880 --> 00:27:15,960
there's basically ah sorry okay so the

00:27:12,809 --> 00:27:18,900
question is how that lock x add in the

00:27:15,960 --> 00:27:21,960
end translate into PDF code right so yes

00:27:18,900 --> 00:27:26,780
for that particular case just an atomic

00:27:21,960 --> 00:27:30,660
add instruction that is part of the ppf

00:27:26,780 --> 00:27:32,820
let's say instruction set yeah sorry yes

00:27:30,660 --> 00:27:37,500
II BPF instruction set and then the

00:27:32,820 --> 00:27:41,370
compiler it's it come compile sit down

00:27:37,500 --> 00:27:48,720
into that so so that's just a special

00:27:41,370 --> 00:27:51,540
case let's say of I think we're out of

00:27:48,720 --> 00:27:53,010
time anyway so if somebody has any more

00:27:51,540 --> 00:27:58,730
questions they can just approached me

00:27:53,010 --> 00:27:58,730
and I can talk offline thanks a lot

00:28:01,520 --> 00:28:03,580

YouTube URL: https://www.youtube.com/watch?v=KHXxSN5vwHY


