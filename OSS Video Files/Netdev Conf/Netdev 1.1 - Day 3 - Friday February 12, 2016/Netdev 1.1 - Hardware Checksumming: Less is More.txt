Title: Netdev 1.1 - Hardware Checksumming: Less is More
Publication date: 2016-03-15
Playlist: Netdev 1.1 - Day 3 - Friday February 12, 2016
Description: 
	David S. Miller
February 2016
Captions: 
	00:00:01,610 --> 00:00:05,700
okay we should get going I guess welcome

00:00:04,259 --> 00:00:09,090
everyone I hope everyone's having a

00:00:05,700 --> 00:00:11,730
great time at netdev cough seems that we

00:00:09,090 --> 00:00:15,750
have a lot of productive conversations

00:00:11,730 --> 00:00:18,210
so far everything's going well so my

00:00:15,750 --> 00:00:19,529
talk today is about check something you

00:00:18,210 --> 00:00:21,420
would think that we figured out check

00:00:19,529 --> 00:00:23,850
something after how many decades we've

00:00:21,420 --> 00:00:26,910
had the internet so far but obviously

00:00:23,850 --> 00:00:29,539
this talk is necessary so we haven't so

00:00:26,910 --> 00:00:32,430
what we're going to talk about is the

00:00:29,539 --> 00:00:34,860
message from our friend Mies van der

00:00:32,430 --> 00:00:37,320
Rohe here on the screen he's saying less

00:00:34,860 --> 00:00:45,600
is more and if you want to know how

00:00:37,320 --> 00:00:48,480
committed he was to this message he also

00:00:45,600 --> 00:00:53,579
says if I could do less I would do that

00:00:48,480 --> 00:00:56,010
more often so the point we're trying to

00:00:53,579 --> 00:00:57,600
make is that sophisticated facilities

00:00:56,010 --> 00:00:58,859
that are not necessarily better and

00:00:57,600 --> 00:01:01,260
we're going to go through why that's the

00:00:58,859 --> 00:01:03,420
case so first we're going to go through

00:01:01,260 --> 00:01:05,400
the history of where to talk about how

00:01:03,420 --> 00:01:07,290
the internet text having works go

00:01:05,400 --> 00:01:09,000
through the history of how hardware has

00:01:07,290 --> 00:01:10,439
been implemented over time the features

00:01:09,000 --> 00:01:12,119
that have shown up in whether they're

00:01:10,439 --> 00:01:14,070
good or bad or how they help us or don't

00:01:12,119 --> 00:01:16,229
help us then we're going to talk about

00:01:14,070 --> 00:01:18,780
how tunneling an encapsulation interacts

00:01:16,229 --> 00:01:21,229
with all these issues and then we're

00:01:18,780 --> 00:01:23,670
going to make an argument for having

00:01:21,229 --> 00:01:25,590
ubiquitous one compliment check some

00:01:23,670 --> 00:01:28,049
facilities and hardware and why that's

00:01:25,590 --> 00:01:31,140
what we want from from the knicks out

00:01:28,049 --> 00:01:32,970
there so the basics are the internet

00:01:31,140 --> 00:01:36,479
checksum is a one's complement checksum

00:01:32,970 --> 00:01:38,130
computed over the packet contents it's

00:01:36,479 --> 00:01:40,470
done with the header field the header

00:01:38,130 --> 00:01:44,070
checksum field set to 0 it also

00:01:40,470 --> 00:01:46,320
incorporates the pseudo header values

00:01:44,070 --> 00:01:49,950
into the checks on computation as well

00:01:46,320 --> 00:01:51,689
for UDP tcp and others and then the once

00:01:49,950 --> 00:01:54,090
the checksum is computed its negated and

00:01:51,689 --> 00:01:56,430
put into the checksum field what does

00:01:54,090 --> 00:01:58,590
this mean when it's validated it means

00:01:56,430 --> 00:02:00,810
that we do the reverse process and it's

00:01:58,590 --> 00:02:03,229
the results are evaluate to 0 of the

00:02:00,810 --> 00:02:08,129
checksum is correct that is important

00:02:03,229 --> 00:02:10,739
for an interesting discovery we've made

00:02:08,129 --> 00:02:11,940
recently for encapsulation situations

00:02:10,739 --> 00:02:13,080
which will describe earlier but just

00:02:11,940 --> 00:02:16,770
remember that

00:02:13,080 --> 00:02:18,210
when we have a UDP packet for example

00:02:16,770 --> 00:02:20,160
the UDP header out to the end of the

00:02:18,210 --> 00:02:23,190
data and we validate the checksum on

00:02:20,160 --> 00:02:25,080
receive the result is 0 that's important

00:02:23,190 --> 00:02:29,310
because it has implications for

00:02:25,080 --> 00:02:30,900
encapsulation so you can compute the

00:02:29,310 --> 00:02:32,840
internet checksum the ones complement

00:02:30,900 --> 00:02:35,460
checks and with a whole bunch of tricks

00:02:32,840 --> 00:02:37,980
CPUs had bad with Carrie instructions so

00:02:35,460 --> 00:02:39,720
this handles the case of the overflow

00:02:37,980 --> 00:02:41,880
bits propagating out to the end of the

00:02:39,720 --> 00:02:43,950
value that using in the simplest terms

00:02:41,880 --> 00:02:46,440
you could do 16 bits at a time editions

00:02:43,950 --> 00:02:48,930
with carries but that's not efficient we

00:02:46,440 --> 00:02:52,020
have 32-bit and 64-bit CPU so what is

00:02:48,930 --> 00:02:55,410
legal is you can compute 32 bit at a

00:02:52,020 --> 00:02:57,360
time editions with Carrie instructions

00:02:55,410 --> 00:02:59,880
and then collapse that folded at the end

00:02:57,360 --> 00:03:02,730
so those are the two tricks that people

00:02:59,880 --> 00:03:06,420
used on CPUs and a 62 computer more

00:03:02,730 --> 00:03:07,860
efficiently now let's go into the kinds

00:03:06,420 --> 00:03:10,709
of hardware we've had over time back in

00:03:07,860 --> 00:03:12,990
the day originally when I started

00:03:10,709 --> 00:03:14,610
working on this kind of stuff there was

00:03:12,990 --> 00:03:16,680
no hardware checks on facilities in the

00:03:14,610 --> 00:03:18,200
car and actually it wasn't very useful

00:03:16,680 --> 00:03:21,269
at the time to be quite honest with you

00:03:18,200 --> 00:03:23,280
in fact you were lucky if you had even a

00:03:21,269 --> 00:03:25,200
ring buffer on these cards a lot of

00:03:23,280 --> 00:03:26,850
these cars were simple Phi foes you put

00:03:25,200 --> 00:03:29,040
a packet into the file and you said go

00:03:26,850 --> 00:03:30,750
and that was the amount of you could

00:03:29,040 --> 00:03:33,060
only q1 packet at a time there are very

00:03:30,750 --> 00:03:35,130
simplistic devices then we started to

00:03:33,060 --> 00:03:36,870
get devices like the deck lance and the

00:03:35,130 --> 00:03:39,660
deck Lance is one of the first chips to

00:03:36,870 --> 00:03:41,670
have a DMA ring buffer which we actually

00:03:39,660 --> 00:03:44,519
consider the fundamental data structure

00:03:41,670 --> 00:03:46,230
for fast networking these days is

00:03:44,519 --> 00:03:47,910
interesting story the initial drivers

00:03:46,230 --> 00:03:50,100
for the deck Lance chip didn't even take

00:03:47,910 --> 00:03:51,750
advantage of the ring buffer they just

00:03:50,100 --> 00:03:53,190
still acute one packet at the time to

00:03:51,750 --> 00:03:54,959
the DMA descriptor and then waited for

00:03:53,190 --> 00:03:57,930
it to put a completion and ruin only

00:03:54,959 --> 00:04:00,390
submit another packet once the first one

00:03:57,930 --> 00:04:03,840
was sent that's not very useful so van

00:04:00,390 --> 00:04:05,310
jacobson extended the driver to actually

00:04:03,840 --> 00:04:07,620
take advantage of the ring buffer and do

00:04:05,310 --> 00:04:09,480
back-to-back packet transmissions but

00:04:07,620 --> 00:04:11,549
then the problem he ran into was when he

00:04:09,480 --> 00:04:12,690
actually plugged this this system into

00:04:11,549 --> 00:04:14,130
the network that was doing these

00:04:12,690 --> 00:04:16,169
back-to-back transfers it basically

00:04:14,130 --> 00:04:18,600
crashed every other receiving system out

00:04:16,169 --> 00:04:20,880
there at the time so he had a lot of

00:04:18,600 --> 00:04:23,090
bugs to fix before he could turn on all

00:04:20,880 --> 00:04:26,580
the features in the lance driver

00:04:23,090 --> 00:04:27,930
another thing that drove perhaps the

00:04:26,580 --> 00:04:30,540
lack of check some off loading

00:04:27,930 --> 00:04:32,880
facilities back then was check something

00:04:30,540 --> 00:04:36,419
we could do basically for free from

00:04:32,880 --> 00:04:39,660
various perspectives we didn't have

00:04:36,419 --> 00:04:42,419
things like splice like send file all

00:04:39,660 --> 00:04:44,550
these zero copy interfaces so what was

00:04:42,419 --> 00:04:46,350
happening was the user had to do a send

00:04:44,550 --> 00:04:48,690
message call or a receive message call

00:04:46,350 --> 00:04:50,220
and at that point we had to copy to data

00:04:48,690 --> 00:04:52,380
into the networking buffers in the curl

00:04:50,220 --> 00:04:54,120
so there's a copy implicit in all the

00:04:52,380 --> 00:04:57,510
Iowa operations users would do on a

00:04:54,120 --> 00:04:59,370
socket as a result we could it turns out

00:04:57,510 --> 00:05:02,220
that the memory dominates the cost we

00:04:59,370 --> 00:05:04,169
all know that and we could in parallel

00:05:02,220 --> 00:05:06,180
compute the checksum as we do were doing

00:05:04,169 --> 00:05:08,850
the copy the computation of the checksum

00:05:06,180 --> 00:05:11,039
ended up being for free so it's very

00:05:08,850 --> 00:05:13,229
easy person you do to send message you

00:05:11,039 --> 00:05:14,580
have to copy the data you do two checks

00:05:13,229 --> 00:05:16,800
them at that time and you put it into

00:05:14,580 --> 00:05:19,680
the packet on receive it's a little bit

00:05:16,800 --> 00:05:21,660
more complicated what you need to have

00:05:19,680 --> 00:05:23,910
happen is that you need to do that copy

00:05:21,660 --> 00:05:25,979
into user space of the socket data in

00:05:23,910 --> 00:05:28,139
the context of the receive message call

00:05:25,979 --> 00:05:30,900
and the only situation the situation

00:05:28,139 --> 00:05:33,330
without works is if the user has blocked

00:05:30,900 --> 00:05:35,699
in the receive message but that's not

00:05:33,330 --> 00:05:37,260
how people do apps they pull they wait

00:05:35,699 --> 00:05:40,289
for data to arrive and then they call

00:05:37,260 --> 00:05:41,760
receive message so gives limited use

00:05:40,289 --> 00:05:43,500
cases for being able to do check sum

00:05:41,760 --> 00:05:46,409
plus copy unreason received but it did

00:05:43,500 --> 00:05:48,479
happen so that was that's how things

00:05:46,409 --> 00:05:51,840
were a long time ago so let's talk about

00:05:48,479 --> 00:05:54,030
how things became it seemed like the

00:05:51,840 --> 00:05:57,449
first generation of these devices we got

00:05:54,030 --> 00:05:59,729
that would do check something were how

00:05:57,449 --> 00:06:01,680
series say it's stateful they knew how

00:05:59,729 --> 00:06:03,780
to park pass pocket had a packet headers

00:06:01,680 --> 00:06:06,840
and they would just give us this boolean

00:06:03,780 --> 00:06:10,320
state that said the checksum is okay or

00:06:06,840 --> 00:06:13,639
I don't know or it's potentially bad you

00:06:10,320 --> 00:06:16,199
should you should verify it yourself so

00:06:13,639 --> 00:06:17,760
this helps this gives checksum off

00:06:16,199 --> 00:06:19,770
loading facilities and around the same

00:06:17,760 --> 00:06:22,080
time period is when we start having Sun

00:06:19,770 --> 00:06:23,310
page send file splice and all those

00:06:22,080 --> 00:06:24,539
other interfaces where we could take

00:06:23,310 --> 00:06:27,630
advantage of check something on

00:06:24,539 --> 00:06:28,949
transmitted to a significant extent the

00:06:27,630 --> 00:06:30,539
problem like i said is that it's

00:06:28,949 --> 00:06:31,950
stateful it knows how to pat pours

00:06:30,539 --> 00:06:33,960
packet headers therefore if it

00:06:31,950 --> 00:06:34,620
encounters a header type it doesn't

00:06:33,960 --> 00:06:36,780
understand

00:06:34,620 --> 00:06:39,030
and you're screwed so if you want to use

00:06:36,780 --> 00:06:41,120
a new protocol if you want to use sctp

00:06:39,030 --> 00:06:43,800
or you want to use an encapsulating

00:06:41,120 --> 00:06:45,419
tunneling technology that the hardware

00:06:43,800 --> 00:06:47,010
doesn't support you don't get checked

00:06:45,419 --> 00:06:49,080
something off load so you either have to

00:06:47,010 --> 00:06:50,550
not use that technology or you have to

00:06:49,080 --> 00:06:52,860
hope that your hardware vendor will add

00:06:50,550 --> 00:06:54,720
support for it which is a big if and

00:06:52,860 --> 00:06:56,100
then you would have to buy new hardware

00:06:54,720 --> 00:06:57,930
and propagated throughout your

00:06:56,100 --> 00:07:00,510
infrastructure to take advantage of it

00:06:57,930 --> 00:07:03,060
it's not extensible this doesn't really

00:07:00,510 --> 00:07:05,370
work very well it's it's it's not

00:07:03,060 --> 00:07:07,229
user-friendly it really doesn't help us

00:07:05,370 --> 00:07:09,060
in the long term and it's kind of it

00:07:07,229 --> 00:07:14,430
could kind of kill the internet in a way

00:07:09,060 --> 00:07:16,260
which I'll get into later but at least

00:07:14,430 --> 00:07:17,880
in a few limited cases there were some

00:07:16,260 --> 00:07:20,400
other devices that had a different

00:07:17,880 --> 00:07:22,710
approach and this approach was that the

00:07:20,400 --> 00:07:24,330
chip said okay when you receive a packet

00:07:22,710 --> 00:07:25,889
for me in the descriptor I'm going to

00:07:24,330 --> 00:07:27,860
give you the two the ones complement

00:07:25,889 --> 00:07:30,570
some computed over the entire packet and

00:07:27,860 --> 00:07:32,520
this is really useful because the stack

00:07:30,570 --> 00:07:35,820
can just adjust the headers out of that

00:07:32,520 --> 00:07:37,620
computer check some calculation to get

00:07:35,820 --> 00:07:42,990
the actual checksums that it once for

00:07:37,620 --> 00:07:44,729
UDP IP tcp and even regardless of what

00:07:42,990 --> 00:07:47,849
tunnelling encapsulation and layers you

00:07:44,729 --> 00:07:49,349
have in between check some validation

00:07:47,849 --> 00:07:52,470
still works all the way up the stack on

00:07:49,349 --> 00:07:55,050
receive on transmit is a slightly

00:07:52,470 --> 00:07:57,990
different facility given on transmit we

00:07:55,050 --> 00:07:59,760
tell the chip okay start computing from

00:07:57,990 --> 00:08:02,610
this part of the packet till the end and

00:07:59,760 --> 00:08:04,650
whatever you compute as your 16-bit ones

00:08:02,610 --> 00:08:09,270
complement stick it into this location

00:08:04,650 --> 00:08:11,599
here which is a separate offset in order

00:08:09,270 --> 00:08:14,370
to make this work the stack has to

00:08:11,599 --> 00:08:16,849
precede the checksum field in the header

00:08:14,370 --> 00:08:20,160
like I said earlier the pseudo header is

00:08:16,849 --> 00:08:23,220
is computed into the checksum for a UDP

00:08:20,160 --> 00:08:25,229
tcp etc so we put that into the checksum

00:08:23,220 --> 00:08:28,110
field and the way it works out is that

00:08:25,229 --> 00:08:29,880
the if the chip just linearly computes a

00:08:28,110 --> 00:08:31,199
ones complement checksum it will compute

00:08:29,880 --> 00:08:33,870
the right value and put it in the right

00:08:31,199 --> 00:08:35,520
white location this is the kind of model

00:08:33,870 --> 00:08:37,830
we want to see hardware doing this is

00:08:35,520 --> 00:08:39,810
what works there are Nick's that do this

00:08:37,830 --> 00:08:42,000
already Sun believe

00:08:39,810 --> 00:08:44,130
or not was making Ethernet chips that

00:08:42,000 --> 00:08:46,980
provided this kind of check something

00:08:44,130 --> 00:08:49,380
off load a decade or so ago so it's not

00:08:46,980 --> 00:08:50,730
like it it can't be done it's not like

00:08:49,380 --> 00:08:52,890
no one thought of it before it's just

00:08:50,730 --> 00:08:57,930
that it's not ubiquitous and it's not in

00:08:52,890 --> 00:09:02,250
two places we need it to be so let's get

00:08:57,930 --> 00:09:05,100
into tunneling so you have so a large

00:09:02,250 --> 00:09:07,170
majority of tunneling technologies are

00:09:05,100 --> 00:09:08,940
over UDP and there's a reason for that

00:09:07,170 --> 00:09:10,710
which I'll get into later but what's

00:09:08,940 --> 00:09:12,660
important to know is that we now run

00:09:10,710 --> 00:09:14,010
into situations where every trans a

00:09:12,660 --> 00:09:18,360
transmitted packet has multiple

00:09:14,010 --> 00:09:19,800
checksums to compute so for existing

00:09:18,360 --> 00:09:22,800
cards what do we do which one do we

00:09:19,800 --> 00:09:24,390
offload and more specifically which part

00:09:22,800 --> 00:09:26,550
of the packet is that see some start and

00:09:24,390 --> 00:09:28,770
see some offset thing on transmit going

00:09:26,550 --> 00:09:30,510
to refer to well the funny thing is that

00:09:28,770 --> 00:09:32,190
we actually support for multiple

00:09:30,510 --> 00:09:34,230
checksum offloads is completely

00:09:32,190 --> 00:09:37,260
unnecessary the only only the

00:09:34,230 --> 00:09:40,920
fundamental do one checksum at a time

00:09:37,260 --> 00:09:44,190
facility is what we need and it's really

00:09:40,920 --> 00:09:46,620
interesting why that is so Edward create

00:09:44,190 --> 00:09:50,490
solar flare came up with this facility

00:09:46,620 --> 00:09:52,110
called local checksum offload and it

00:09:50,490 --> 00:09:53,460
doesn't matter if you guys don't like it

00:09:52,110 --> 00:09:54,810
because I applied his patches right

00:09:53,460 --> 00:09:57,300
before this talk so it's in the tree

00:09:54,810 --> 00:10:00,110
already this is that's history that's

00:09:57,300 --> 00:10:02,550
been done already it can't be changed

00:10:00,110 --> 00:10:05,370
but anyways it's important observation

00:10:02,550 --> 00:10:07,170
is that the outer checksum so if you're

00:10:05,370 --> 00:10:11,280
tunneling using a UDP based tunneling

00:10:07,170 --> 00:10:14,490
protocol that checksum is it's it's

00:10:11,280 --> 00:10:16,620
trivially computable at transmit time in

00:10:14,490 --> 00:10:19,470
software because it doesn't depend upon

00:10:16,620 --> 00:10:21,480
the rest of the packet why the reason I

00:10:19,470 --> 00:10:25,580
explained earlier the inner check some

00:10:21,480 --> 00:10:27,870
of the transport frame inside the tunnel

00:10:25,580 --> 00:10:30,150
evaluates to 0 if you compute the ones

00:10:27,870 --> 00:10:32,190
checksum over it minus the pseudo header

00:10:30,150 --> 00:10:34,530
so if you just take the pseudo header

00:10:32,190 --> 00:10:37,170
and all the intermediate headers up

00:10:34,530 --> 00:10:39,570
until the tunnel you can know statically

00:10:37,170 --> 00:10:40,920
at transmit time what the outer checksum

00:10:39,570 --> 00:10:42,870
is going to be so you just put it in

00:10:40,920 --> 00:10:44,580
there and you're done we just need the

00:10:42,870 --> 00:10:46,260
card to do the outer texoma because we

00:10:44,580 --> 00:10:47,910
know what the rest is going to is

00:10:46,260 --> 00:10:49,279
because the checksum field is in there

00:10:47,910 --> 00:10:56,449
is why it evaluates like

00:10:49,279 --> 00:10:58,249
so one concern might be well that's okay

00:10:56,449 --> 00:11:01,310
if we control the whole packet and we

00:10:58,249 --> 00:11:03,470
generated as an end host right but the

00:11:01,310 --> 00:11:06,199
issue here is the ones complement

00:11:03,470 --> 00:11:08,779
internet checksum is weak that's

00:11:06,199 --> 00:11:10,220
everyone knows that we don't want to do

00:11:08,779 --> 00:11:13,670
things that would potentially would make

00:11:10,220 --> 00:11:15,790
the checks on weaker so one concern

00:11:13,670 --> 00:11:18,110
might be well if we're forwarding and

00:11:15,790 --> 00:11:19,639
encapsulating into a tunnel we didn't

00:11:18,110 --> 00:11:22,220
compute the inner checksum so we

00:11:19,639 --> 00:11:26,720
shouldn't do this magic thing on the

00:11:22,220 --> 00:11:28,339
outer outer checksum that is going to

00:11:26,720 --> 00:11:30,290
not propagate the error if the inner

00:11:28,339 --> 00:11:32,480
checksum was miscalculated for example

00:11:30,290 --> 00:11:34,009
that's not an issue actually when you're

00:11:32,480 --> 00:11:37,459
forwarding traffic and encapsulating

00:11:34,009 --> 00:11:39,050
into a UDP base tunnel on transmit we

00:11:37,459 --> 00:11:41,120
would tell the card to compute the

00:11:39,050 --> 00:11:43,879
checksum on the outer header just

00:11:41,120 --> 00:11:45,350
compute the whole thing so if any errors

00:11:43,879 --> 00:11:47,329
introduced on the outer section would be

00:11:45,350 --> 00:11:49,550
our mistake and we would preserve any

00:11:47,329 --> 00:11:51,170
errors or non errors in the check sum of

00:11:49,550 --> 00:11:53,300
the inner packet computer by someone

00:11:51,170 --> 00:11:55,459
else so we retain all the end-to-end

00:11:53,300 --> 00:12:01,040
principle subjects some calculations and

00:11:55,459 --> 00:12:03,559
it wouldn't be an issue there is a side

00:12:01,040 --> 00:12:05,600
note discussion about a facility created

00:12:03,559 --> 00:12:07,879
by Tom Herbert called remote checksum

00:12:05,600 --> 00:12:10,699
offload there's an extension to

00:12:07,879 --> 00:12:13,040
tunneling technologies to try to handle

00:12:10,699 --> 00:12:15,769
the case of handling the inner versus

00:12:13,040 --> 00:12:17,870
the outer checksum so basically it's a

00:12:15,769 --> 00:12:19,339
piece of metadata that tells the

00:12:17,870 --> 00:12:24,069
receiver how to handle the inner

00:12:19,339 --> 00:12:26,899
checksum and on transmit we set up the

00:12:24,069 --> 00:12:28,639
piece of metadata and we only compute

00:12:26,899 --> 00:12:30,920
the outer checksum and then the receiver

00:12:28,639 --> 00:12:33,620
uses the validates the outer checksum

00:12:30,920 --> 00:12:35,569
and then uses the cookie in the metadata

00:12:33,620 --> 00:12:37,910
to figure out to act to handle the inter

00:12:35,569 --> 00:12:39,920
checks them properly now for the most

00:12:37,910 --> 00:12:41,809
part this actually isn't needed because

00:12:39,920 --> 00:12:44,420
as I just described you local checksum

00:12:41,809 --> 00:12:45,980
offload works very well but we still

00:12:44,420 --> 00:12:47,720
need something like remote checksum

00:12:45,980 --> 00:12:50,149
offload for a few edge cases for example

00:12:47,720 --> 00:12:51,860
if the car doesn't do any checks are

00:12:50,149 --> 00:12:53,529
more floating at all receive check on

00:12:51,860 --> 00:12:56,089
some offload can help us quite a bit

00:12:53,529 --> 00:12:57,860
another situation is that some cards

00:12:56,089 --> 00:12:59,360
have restrictions like if there are

00:12:57,860 --> 00:13:00,000
multiple checksums in the packet and

00:12:59,360 --> 00:13:02,340
inner and outer

00:13:00,000 --> 00:13:04,200
header in certain situations they may

00:13:02,340 --> 00:13:05,700
not be able to do the inner header they

00:13:04,200 --> 00:13:07,320
may be only able to check some of the

00:13:05,700 --> 00:13:11,280
outer header and we know of several

00:13:07,320 --> 00:13:13,890
cards that are in this category so it's

00:13:11,280 --> 00:13:15,810
not needed universally but it's useful

00:13:13,890 --> 00:13:19,700
in some limited cases so remote checksum

00:13:15,810 --> 00:13:23,540
offload is still something that's useful

00:13:19,700 --> 00:13:29,330
photo classification the point of

00:13:23,540 --> 00:13:31,830
ossification is that too stateful to

00:13:29,330 --> 00:13:33,570
finally focused optimizations and

00:13:31,830 --> 00:13:35,580
offloads and hardware have effectively

00:13:33,570 --> 00:13:40,290
started to make parts of the Internet

00:13:35,580 --> 00:13:42,600
cast in stone if you don't if it is not

00:13:40,290 --> 00:13:45,000
going over UDP or it's not going over

00:13:42,600 --> 00:13:46,500
TCP you don't get any of the offloads

00:13:45,000 --> 00:13:48,360
you don't get any check summon you don't

00:13:46,500 --> 00:13:50,940
get segmentation offloads you don't get

00:13:48,360 --> 00:13:52,830
any of this stuff so that's why does

00:13:50,940 --> 00:13:54,540
this proliferation of X over UDP

00:13:52,830 --> 00:13:55,860
protocols because it's a transport that

00:13:54,540 --> 00:13:59,370
allows us to get check something and

00:13:55,860 --> 00:14:01,260
segmentation offloads and this is one of

00:13:59,370 --> 00:14:03,510
the pain points of sophisticated

00:14:01,260 --> 00:14:06,480
hardware offloads we they actually end

00:14:03,510 --> 00:14:08,330
up hurting us not helping us it's to the

00:14:06,480 --> 00:14:13,490
point where someone tried to even do

00:14:08,330 --> 00:14:16,260
tunneling over tcp that is to send

00:14:13,490 --> 00:14:20,310
unrestricted rate packets over a tcp

00:14:16,260 --> 00:14:22,050
with TCP headers encapsulating tunnel

00:14:20,310 --> 00:14:23,850
which is just ridiculous it would

00:14:22,050 --> 00:14:25,650
actually absolutely completely break the

00:14:23,850 --> 00:14:27,330
internet because in turn every note on

00:14:25,650 --> 00:14:30,030
the internet that passes packets around

00:14:27,330 --> 00:14:32,550
assumes that there's a TCP congestion

00:14:30,030 --> 00:14:34,530
control algorithm sitting behind that

00:14:32,550 --> 00:14:36,839
flow and that the flow can be influenced

00:14:34,530 --> 00:14:39,560
by dropping packets and and delays and

00:14:36,839 --> 00:14:42,630
whatnot it's not true if you just have a

00:14:39,560 --> 00:14:45,510
burst of uncontrolled frames going over

00:14:42,630 --> 00:14:50,370
it TCP headers that's it's not legal you

00:14:45,510 --> 00:14:52,290
can't do it so what's the final argue

00:14:50,370 --> 00:14:54,000
what are the arguments for people to

00:14:52,290 --> 00:14:56,640
have one's complement checksums

00:14:54,000 --> 00:14:59,520
everywhere your chipset logic would be

00:14:56,640 --> 00:15:01,410
less complicated I know you guys have V

00:14:59,520 --> 00:15:03,330
excellent offloads other kind of

00:15:01,410 --> 00:15:05,580
tunneling offloads you've gotten decent

00:15:03,330 --> 00:15:07,140
finna ban things you've got RDMA you've

00:15:05,580 --> 00:15:09,660
got all this complicated stuff in there

00:15:07,140 --> 00:15:11,490
and you have support for parsing all

00:15:09,660 --> 00:15:13,260
kinds of different protocols but you

00:15:11,490 --> 00:15:15,330
only if you do things that we

00:15:13,260 --> 00:15:19,080
we're suggesting you only one piece of

00:15:15,330 --> 00:15:21,750
logic to compute checksums and two in in

00:15:19,080 --> 00:15:23,370
packets it's one piece of logic you'll

00:15:21,750 --> 00:15:24,600
have the test and it's one piece of

00:15:23,370 --> 00:15:28,410
logic that you'll have to deal with bugs

00:15:24,600 --> 00:15:30,570
in and that's in addition to that the

00:15:28,410 --> 00:15:31,950
feature sets and the performance

00:15:30,570 --> 00:15:33,450
characteristics you'll provide your

00:15:31,950 --> 00:15:36,270
customers will be more consistent

00:15:33,450 --> 00:15:39,120
regardless that the customer uses UDP

00:15:36,270 --> 00:15:41,130
tunneling technology GRE VX LAN whatever

00:15:39,120 --> 00:15:44,430
they'll get the same level performance

00:15:41,130 --> 00:15:46,650
as with respect to offloading and check

00:15:44,430 --> 00:15:49,190
something the kernel itself would become

00:15:46,650 --> 00:15:53,160
simpler because we have such a varied

00:15:49,190 --> 00:15:55,110
mechanisms for bed Hardware has for

00:15:53,160 --> 00:15:56,640
supporting texting offload we have a lot

00:15:55,110 --> 00:15:58,680
of different cases to deal with in the

00:15:56,640 --> 00:16:00,630
networking stack it would be great if we

00:15:58,680 --> 00:16:03,240
could just consolidate this all into the

00:16:00,630 --> 00:16:06,660
ones ones complement your bitterness

00:16:03,240 --> 00:16:08,880
situation there's less ossification

00:16:06,660 --> 00:16:10,080
because now if we have this one's

00:16:08,880 --> 00:16:11,580
complement checksum and the received

00:16:10,080 --> 00:16:13,260
descriptor it doesn't matter what kind

00:16:11,580 --> 00:16:15,060
of stuff is inside the packet we can

00:16:13,260 --> 00:16:16,920
always validate one's complement check

00:16:15,060 --> 00:16:20,880
sums no matter where they are in the

00:16:16,920 --> 00:16:22,980
layering another thing I think it's lost

00:16:20,880 --> 00:16:24,870
in the discussions around this is you

00:16:22,980 --> 00:16:26,850
have to understand that just because you

00:16:24,870 --> 00:16:28,800
make some new part that supports the new

00:16:26,850 --> 00:16:30,840
protocol and can check some offload for

00:16:28,800 --> 00:16:33,810
it it doesn't matter for people running

00:16:30,840 --> 00:16:36,450
big data centers because it's the low is

00:16:33,810 --> 00:16:39,000
it's whatever feature set the least

00:16:36,450 --> 00:16:40,890
capable card is in the stack in their

00:16:39,000 --> 00:16:42,030
inner collection of machines that's what

00:16:40,890 --> 00:16:43,980
they can support and that's what they

00:16:42,030 --> 00:16:46,980
can make use of that's the thing that

00:16:43,980 --> 00:16:49,410
they're going to be able to deploy it's

00:16:46,980 --> 00:16:52,500
just really painful to to update stuff

00:16:49,410 --> 00:16:54,000
and have discontinued discontinuous sets

00:16:52,500 --> 00:16:55,530
of features amongst different hardware

00:16:54,000 --> 00:16:58,650
so the message that Hardware designers

00:16:55,530 --> 00:17:00,510
is simple we want raw ones complement

00:16:58,650 --> 00:17:01,890
offloads that's what we want on the

00:17:00,510 --> 00:17:03,570
receive descriptor we want two runs

00:17:01,890 --> 00:17:05,370
compliments over the entire packet and

00:17:03,570 --> 00:17:07,740
on transmit we want a facility that

00:17:05,370 --> 00:17:09,660
allows us to say to the card start from

00:17:07,740 --> 00:17:12,120
here compute the ones check consequent

00:17:09,660 --> 00:17:15,270
check complement checksum and stick it

00:17:12,120 --> 00:17:17,130
into this 16-bit location at offset X

00:17:15,270 --> 00:17:19,140
within the card that's all we want it

00:17:17,130 --> 00:17:20,490
allows every single facility to be

00:17:19,140 --> 00:17:21,959
handled properly and allows us to

00:17:20,490 --> 00:17:24,689
offload check sums in any possible

00:17:21,959 --> 00:17:26,399
situation it's universal and it

00:17:24,689 --> 00:17:32,279
it's really what we should be striving

00:17:26,399 --> 00:17:35,159
for so in in conclusion the colonel

00:17:32,279 --> 00:17:37,019
colonel needs only something very simple

00:17:35,159 --> 00:17:41,129
it just once the 16-bit value over the

00:17:37,019 --> 00:17:42,870
whole packet if going past that has

00:17:41,129 --> 00:17:45,840
almost no value at all it actually gets

00:17:42,870 --> 00:17:47,309
in our way it's not what we want so like

00:17:45,840 --> 00:17:49,049
I said we can support anything if we

00:17:47,309 --> 00:17:50,190
have ubiquitous ones pumpkin check

00:17:49,049 --> 00:17:53,759
cimarron so I think that's the direction

00:17:50,190 --> 00:17:59,220
hardware should be going don't listen to

00:17:53,759 --> 00:18:00,779
me at your own peril so meas is asking

00:17:59,220 --> 00:18:05,429
us what part of less is more didn't you

00:18:00,779 --> 00:18:06,450
understand one second about to

00:18:05,429 --> 00:18:10,529
complement your company you probably

00:18:06,450 --> 00:18:13,889
don't want to interrupt me right now so

00:18:10,529 --> 00:18:16,980
back in February I gave a talk in Ottawa

00:18:13,889 --> 00:18:18,600
about many things but I tried to focus

00:18:16,980 --> 00:18:21,509
on switch step since that was the topic

00:18:18,600 --> 00:18:23,100
du jour at the time and I ended one of

00:18:21,509 --> 00:18:24,480
my slides with in advance I'd like to

00:18:23,100 --> 00:18:27,059
thank the first hardware vendor to merge

00:18:24,480 --> 00:18:28,710
hardware switching driver upstream you

00:18:27,059 --> 00:18:34,200
will be the trailblazer and thanks to

00:18:28,710 --> 00:18:36,120
mellanox thanks to mellanox we have an

00:18:34,200 --> 00:18:39,450
upstream switchdriver right now so thank

00:18:36,120 --> 00:18:43,090
you mellanox one more round of applause

00:18:39,450 --> 00:18:46,960
the problem is problem is that's not

00:18:43,090 --> 00:18:48,519
enough it's great that we have one

00:18:46,960 --> 00:18:50,710
driver upstream and we're having all the

00:18:48,519 --> 00:18:52,119
api's worked out but if mellanox is the

00:18:50,710 --> 00:18:53,859
only one who does an upstream driver

00:18:52,119 --> 00:18:56,139
that's that's of zero value to a lot of

00:18:53,859 --> 00:18:59,769
people so if you have someone who does

00:18:56,139 --> 00:19:01,629
switch switch switch hardware strongly

00:18:59,769 --> 00:19:03,129
encourage them to also have a switch

00:19:01,629 --> 00:19:06,570
step driver so we can have a really

00:19:03,129 --> 00:19:09,759
healthy ecosystem of devices and also

00:19:06,570 --> 00:19:11,679
realize that if if and when all your

00:19:09,759 --> 00:19:13,299
competitors move to switch step and you

00:19:11,679 --> 00:19:15,429
weren't in the initial discussions to

00:19:13,299 --> 00:19:17,470
design things you may be really behind

00:19:15,429 --> 00:19:19,480
the ball if something that's important

00:19:17,470 --> 00:19:21,580
to you isn't incorporated into the api's

00:19:19,480 --> 00:19:23,470
we are designing right now so it is to

00:19:21,580 --> 00:19:24,879
your advantage to be in here at this

00:19:23,470 --> 00:19:28,299
early period where we have a lot of

00:19:24,879 --> 00:19:29,919
flexibility to change things and to

00:19:28,299 --> 00:19:31,419
design things properly and have a really

00:19:29,919 --> 00:19:33,039
strong foundation for all switch step

00:19:31,419 --> 00:19:36,580
drivers in the future so I just wanted

00:19:33,039 --> 00:19:39,119
to make a mention of that finally I like

00:19:36,580 --> 00:19:41,919
to thank people I like to thank Pablo

00:19:39,119 --> 00:19:42,999
Jamal the whole netdev compte of all the

00:19:41,919 --> 00:19:47,190
people who worked really hard to make

00:19:42,999 --> 00:19:49,330
this conference run as smoothly and as

00:19:47,190 --> 00:19:51,039
fantastically as it has so far so here's

00:19:49,330 --> 00:19:53,460
one for the neck def conquer you back to

00:19:51,039 --> 00:19:55,860
the car

00:19:53,460 --> 00:19:57,870
I like to specifically thank Tom Herbert

00:19:55,860 --> 00:20:00,120
for beating on this topic for a long

00:19:57,870 --> 00:20:01,679
time now I didn't think it something so

00:20:00,120 --> 00:20:03,779
fundamental would be such a huge issue

00:20:01,679 --> 00:20:05,309
but Tom saw this coming down the road a

00:20:03,779 --> 00:20:07,590
long time ago so I like to thank Tom for

00:20:05,309 --> 00:20:10,169
that and also like to thank the hardware

00:20:07,590 --> 00:20:11,730
people at Intel solar flare mellanox etc

00:20:10,169 --> 00:20:13,620
for giving valuable feedback as the

00:20:11,730 --> 00:20:15,390
discussions these discussions happen on

00:20:13,620 --> 00:20:22,740
the milling us over time so thanks to

00:20:15,390 --> 00:20:31,320
you guys as well ok so I'll take some

00:20:22,740 --> 00:20:34,380
questions if we have time for that so

00:20:31,320 --> 00:20:37,230
for transmit check something how do you

00:20:34,380 --> 00:20:40,679
differentiate tcp versus UDP and the

00:20:37,230 --> 00:20:43,110
zero vs 65535 Jackson what are you

00:20:40,679 --> 00:20:44,460
talking about specifically specifically

00:20:43,110 --> 00:20:46,230
that you need to know whether you're

00:20:44,460 --> 00:20:48,360
supposed to be filling in a TCP check

00:20:46,230 --> 00:20:51,149
somewhere a UDP Jackson that's handled

00:20:48,360 --> 00:20:52,649
with the pseudo fat pseudo header so

00:20:51,149 --> 00:20:54,929
you're expecting the driver to parson

00:20:52,649 --> 00:20:56,909
under the software preceeds that

00:20:54,929 --> 00:21:00,510
checksum feel with whatever stuff you

00:20:56,909 --> 00:21:03,210
got to do yeah I'm talking about the

00:21:00,510 --> 00:21:05,909
transmit side if the hardware calculates

00:21:03,210 --> 00:21:07,679
a checksum of 0 if it's TCP it has to

00:21:05,909 --> 00:21:13,580
write a zero but if it's UDP it has

00:21:07,679 --> 00:21:16,200
directly and that's valid yep it works

00:21:13,580 --> 00:21:20,580
we've been this has been done for deck

00:21:16,200 --> 00:21:22,500
for more than a decade this works yeah

00:21:20,580 --> 00:21:24,299
zero bytes somewhere in the header is

00:21:22,500 --> 00:21:27,269
you're guaranteed to have you know it's

00:21:24,299 --> 00:21:28,649
not a valid consent from 0 to 0 so the

00:21:27,269 --> 00:21:30,539
fact you're stuck in some bits in the

00:21:28,649 --> 00:21:33,539
studio better guarantees that you're

00:21:30,539 --> 00:21:35,190
going to end up with a the volumes in a

00:21:33,539 --> 00:21:38,010
reset itself because this is you have

00:21:35,190 --> 00:21:42,120
anything to either 0 or all s it comes

00:21:38,010 --> 00:21:43,799
that value so basically what we're

00:21:42,120 --> 00:21:48,570
saying is we never send the tcp check

00:21:43,799 --> 00:21:51,000
sum of zero because we're must not come

00:21:48,570 --> 00:22:02,940
in Jackson 0 or always is the same thing

00:21:51,000 --> 00:22:04,649
there its equivalent yep so for check

00:22:02,940 --> 00:22:06,750
something after your requirement is

00:22:04,649 --> 00:22:09,299
clear but it does so the next chapter is

00:22:06,750 --> 00:22:13,200
0 and LS all right so 0 is in software

00:22:09,299 --> 00:22:15,389
it's okay and what people talk to how

00:22:13,200 --> 00:22:16,740
how how does how the designers so

00:22:15,389 --> 00:22:18,990
they're asking what's your actual

00:22:16,740 --> 00:22:21,299
requirement for the LSO you want to do

00:22:18,990 --> 00:22:23,460
editor on anything right so you have

00:22:21,299 --> 00:22:26,429
this slide with the Teague's so what can

00:22:23,460 --> 00:22:27,809
you state the requirement I have been

00:22:26,429 --> 00:22:30,240
I've been thought very deeply about a

00:22:27,809 --> 00:22:32,460
segmentation offload in that regard I

00:22:30,240 --> 00:22:38,190
know that our software stack is capable

00:22:32,460 --> 00:22:40,440
of doing all the LSO stuff etc yes but

00:22:38,190 --> 00:22:42,539
there is noticeable gain if you do that

00:22:40,440 --> 00:22:44,340
in Harvard right so I understand honest

00:22:42,539 --> 00:22:46,380
so we'll be we'll have to come up with

00:22:44,340 --> 00:22:47,940
something markley for sure there's no

00:22:46,380 --> 00:22:49,559
doubt about it I understand that geocell

00:22:47,940 --> 00:22:51,330
like the segmentation avalos are

00:22:49,559 --> 00:22:54,330
strictly tied to the check something

00:22:51,330 --> 00:22:59,130
facility yes right because gives you yes

00:22:54,330 --> 00:23:01,860
so i can actually comment on that so lso

00:22:59,130 --> 00:23:05,669
and its nature is already tcp specific

00:23:01,860 --> 00:23:09,960
and what we want there is the ability to

00:23:05,669 --> 00:23:11,880
make a generic basically generic TSO

00:23:09,960 --> 00:23:14,130
where the encapsulation can be present

00:23:11,880 --> 00:23:16,679
or not and as long as we know the outer

00:23:14,130 --> 00:23:19,440
IP header the inner IP header the TCP

00:23:16,679 --> 00:23:22,649
header and optionally where r UDP

00:23:19,440 --> 00:23:25,019
encapsulation header is that actually

00:23:22,649 --> 00:23:26,220
encompasses like 90 probably ninety nine

00:23:25,019 --> 00:23:30,690
percent of the use cases for

00:23:26,220 --> 00:23:32,169
encapsulation and TSO we have a will be

00:23:30,690 --> 00:23:36,519
generic solution protocol

00:23:32,169 --> 00:23:38,980
generic solution for lso LRO is a whole

00:23:36,519 --> 00:23:40,509
different ballgame that's really hard to

00:23:38,980 --> 00:23:43,359
generalize and we probably need to get

00:23:40,509 --> 00:23:46,409
into the neck programmability in order

00:23:43,359 --> 00:23:46,409
to really generalize that one

00:23:59,010 --> 00:24:04,060
hey Dave so I'm Anjali and I guess i

00:24:02,230 --> 00:24:08,020
sent the genie patches where all this

00:24:04,060 --> 00:24:10,120
kind of stuff got started discussion so

00:24:08,020 --> 00:24:13,150
first i want to mention that we took

00:24:10,120 --> 00:24:15,070
that feedback to the hardware design

00:24:13,150 --> 00:24:18,520
folks that we want a generic checksum

00:24:15,070 --> 00:24:20,230
and be used to have that in igb it went

00:24:18,520 --> 00:24:23,170
away and we started doing more layered

00:24:20,230 --> 00:24:25,420
checksums and i guess this is a better

00:24:23,170 --> 00:24:28,720
approach so that feedback has been given

00:24:25,420 --> 00:24:32,410
back I want to talk something more so

00:24:28,720 --> 00:24:35,500
there is a the j'ni patches that I sent

00:24:32,410 --> 00:24:39,100
out which helps identify a UDP tunnel

00:24:35,500 --> 00:24:41,260
for Geneva the idea behind that was not

00:24:39,100 --> 00:24:45,910
just check some it was flow steering as

00:24:41,260 --> 00:24:48,360
well so identifying a UDP port protocol

00:24:45,910 --> 00:24:50,740
a tunnel protocol using a code number

00:24:48,360 --> 00:24:53,490
the hardware is designed in such a way

00:24:50,740 --> 00:24:56,710
that I can have multiple different

00:24:53,490 --> 00:25:01,600
European old protocols you know that I

00:24:56,710 --> 00:25:04,960
can very flexibly program on the fly and

00:25:01,600 --> 00:25:07,570
then use the inner header information to

00:25:04,960 --> 00:25:09,970
steer the packet and the only way the

00:25:07,570 --> 00:25:12,700
hardware can do that is if it knows what

00:25:09,970 --> 00:25:18,090
port numbers match map to what protocol

00:25:12,700 --> 00:25:21,400
so so we we still have that kind of

00:25:18,090 --> 00:25:23,470
input we need from the stack into the

00:25:21,400 --> 00:25:27,000
driver so that hardware is aware of

00:25:23,470 --> 00:25:29,740
which town so a point want to make is

00:25:27,000 --> 00:25:33,490
you can do all these fancy be excellent

00:25:29,740 --> 00:25:36,370
offloads UDP GRE tunnels all this stuff

00:25:33,490 --> 00:25:38,050
I don't care right that's fine whatever

00:25:36,370 --> 00:25:40,180
other silicon is there whether we use it

00:25:38,050 --> 00:25:42,220
or not I don't care as long as you give

00:25:40,180 --> 00:25:44,920
the stacked of the way to get that that

00:25:42,220 --> 00:25:47,410
one's complement 16-bit value everything

00:25:44,920 --> 00:25:48,520
else is fine with me right that makes I

00:25:47,410 --> 00:25:50,680
think these are these are separate

00:25:48,520 --> 00:25:52,330
issues right they're completely separate

00:25:50,680 --> 00:25:54,700
issues I don't think there's it is an

00:25:52,330 --> 00:25:58,510
implicit conflict in any way between

00:25:54,700 --> 00:26:00,370
these two right facilities yeah then

00:25:58,510 --> 00:26:03,670
elaborating on that point having a

00:26:00,370 --> 00:26:05,260
separate hook for each tunnel do yes we

00:26:03,670 --> 00:26:06,400
have a proliferation of hooks right now

00:26:05,260 --> 00:26:08,770
and it's getting out of control I

00:26:06,400 --> 00:26:09,660
totally I totally agree with you yeah so

00:26:08,770 --> 00:26:11,340
this consol

00:26:09,660 --> 00:26:13,830
station is absolutely necessary some

00:26:11,340 --> 00:26:16,950
better device driver abstraction is

00:26:13,830 --> 00:26:20,520
necessary right I just want to emphasize

00:26:16,950 --> 00:26:23,280
again on the TX Jackson for in int'l mix

00:26:20,520 --> 00:26:25,050
that is still you know generalized so we

00:26:23,280 --> 00:26:27,630
have the same method where we just say

00:26:25,050 --> 00:26:29,370
put the checks in here and you know do

00:26:27,630 --> 00:26:32,010
it over this length kind of thing so

00:26:29,370 --> 00:26:34,620
that still is ok it's the received side

00:26:32,010 --> 00:26:36,720
which we you know we don't provide a

00:26:34,620 --> 00:26:39,930
checksum in the descriptor up above

00:26:36,720 --> 00:26:43,170
which needs to be fixed one last comment

00:26:39,930 --> 00:26:45,780
on the switch dev stuff so we will will

00:26:43,170 --> 00:26:47,310
definitely be backing this up because we

00:26:45,780 --> 00:26:50,640
have a lot of use cases as well coming

00:26:47,310 --> 00:26:53,160
up so my next keynote i can say thanks

00:26:50,640 --> 00:26:56,490
to mellanox and these guys that we have

00:26:53,160 --> 00:26:59,610
to so please the next vendor upstream

00:26:56,490 --> 00:27:03,600
your switch strep driver but that's good

00:26:59,610 --> 00:27:06,030
news thanks for letting me know so David

00:27:03,600 --> 00:27:08,370
Beck to the dave and tom so maybe it's

00:27:06,030 --> 00:27:10,560
not that you that the hollow will

00:27:08,370 --> 00:27:13,260
support a fixed you know GRE Ephixa you

00:27:10,560 --> 00:27:16,080
just will give you a note to program ass

00:27:13,260 --> 00:27:19,410
right Soph royal so we would need to

00:27:16,080 --> 00:27:21,390
know that it's let's say two DP port 500

00:27:19,410 --> 00:27:23,400
which accounts to this size of header

00:27:21,390 --> 00:27:25,680
which you would use as a template to

00:27:23,400 --> 00:27:27,150
stick it into packet that's it so it's

00:27:25,680 --> 00:27:30,660
big it will be a general-purpose

00:27:27,150 --> 00:27:32,730
programming no not not to say you see

00:27:30,660 --> 00:27:34,710
what I mean I can see how it works on

00:27:32,730 --> 00:27:37,320
transmit I'm not so sure how or transmit

00:27:34,710 --> 00:27:38,910
yes I totally understand how it could be

00:27:37,320 --> 00:27:42,150
generous sized because it's just

00:27:38,910 --> 00:27:46,700
templating and replication and what are

00:27:42,150 --> 00:27:46,700
the parameters for that replication yep

00:27:46,850 --> 00:27:52,250
well good thank you very much

00:27:54,050 --> 00:27:56,110

YouTube URL: https://www.youtube.com/watch?v=6VgmazGwL_Y


