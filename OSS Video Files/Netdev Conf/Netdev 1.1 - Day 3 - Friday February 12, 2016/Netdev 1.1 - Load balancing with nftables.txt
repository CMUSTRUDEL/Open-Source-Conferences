Title: Netdev 1.1 - Load balancing with nftables
Publication date: 2016-03-15
Playlist: Netdev 1.1 - Day 3 - Friday February 12, 2016
Description: 
	Laura Garcia
February 2016
Captions: 
	00:00:02,750 --> 00:00:13,620
hello I'm Laura Garcia and I'm a member

00:00:08,309 --> 00:00:17,119
of balancer we have been balancing with

00:00:13,620 --> 00:00:20,430
iptables and now we want to present a

00:00:17,119 --> 00:00:25,410
prototype floor balance it with enough

00:00:20,430 --> 00:00:31,500
tables this is we want to take advantage

00:00:25,410 --> 00:00:36,030
of all the improvements that enable

00:00:31,500 --> 00:00:38,670
school will provide so our goal here is

00:00:36,030 --> 00:00:41,750
to perform a high load balance high

00:00:38,670 --> 00:00:46,440
performance level answer at layer 4

00:00:41,750 --> 00:00:49,920
maybe a later edition of in a depth we

00:00:46,440 --> 00:00:54,210
could provide a layer 7 contest

00:00:49,920 --> 00:00:57,059
switching valve an answer but a firstly

00:00:54,210 --> 00:00:59,850
we are going to show some solutions that

00:00:57,059 --> 00:01:02,640
currently we we could use first of all

00:00:59,850 --> 00:01:08,700
is a unique spirit server is commonly

00:01:02,640 --> 00:01:11,400
known package later we could use IP

00:01:08,700 --> 00:01:15,020
tables and now we could see how and if

00:01:11,400 --> 00:01:20,430
table school could provide a very high

00:01:15,020 --> 00:01:24,900
performance level answer giving just a

00:01:20,430 --> 00:01:28,430
brief review of LVS ABS provides that

00:01:24,900 --> 00:01:31,400
you complete versatile schedulers

00:01:28,430 --> 00:01:39,119
provides us several for welding methods

00:01:31,400 --> 00:01:42,180
channeling is not or their protein also

00:01:39,119 --> 00:01:46,200
provides integrated health checks it

00:01:42,180 --> 00:01:48,960
it's implemented another layer on top of

00:01:46,200 --> 00:01:53,369
red filter and it's mostly a clinical

00:01:48,960 --> 00:01:57,380
base but with IP tables we could provide

00:01:53,369 --> 00:02:03,810
a lot balancer using extensions X table

00:01:57,380 --> 00:02:07,860
extensions we could set for welding

00:02:03,810 --> 00:02:13,080
methods as ethnic or do not depend on

00:02:07,860 --> 00:02:13,860
the transparency we want you to use we

00:02:13,080 --> 00:02:15,930
have two

00:02:13,860 --> 00:02:21,200
much pockets on them forwarding or even

00:02:15,930 --> 00:02:25,050
much mark the packets before forwarding

00:02:21,200 --> 00:02:26,670
I also a back-end health checks or real

00:02:25,050 --> 00:02:31,890
separate checks

00:02:26,670 --> 00:02:37,260
would be provided from user space so

00:02:31,890 --> 00:02:41,640
here's a first approach of the diagram

00:02:37,260 --> 00:02:46,080
that we have - we have been using during

00:02:41,640 --> 00:02:50,220
those years first of all we have user

00:02:46,080 --> 00:02:55,230
space in the spare time oh it's a rule

00:02:50,220 --> 00:03:00,239
set manager and head check diamo we use

00:02:55,230 --> 00:03:05,640
some health checks from - real servers

00:03:00,239 --> 00:03:09,780
at different layers but we have to set

00:03:05,640 --> 00:03:14,459
some iptables commands sequentially so

00:03:09,780 --> 00:03:17,120
sometimes this could be a problem from

00:03:14,459 --> 00:03:21,410
current space perspective we have to

00:03:17,120 --> 00:03:26,100
mangle in some complex infrastructures

00:03:21,410 --> 00:03:28,799
and then not the connection in order to

00:03:26,100 --> 00:03:31,739
redirect or forward the connect the

00:03:28,799 --> 00:03:37,549
packets or the the connections to one

00:03:31,739 --> 00:03:42,660
backing or another but with NFA tables

00:03:37,549 --> 00:03:46,260
we can use the the infrastructure itself

00:03:42,660 --> 00:03:49,019
of tables and tables libraries and

00:03:46,260 --> 00:03:54,350
stables built on matching and its native

00:03:49,019 --> 00:03:57,840
instructions so we don't need extensions

00:03:54,350 --> 00:04:01,440
additionally we could provide dynamic

00:03:57,840 --> 00:04:05,610
rules which allows - in just one rule

00:04:01,440 --> 00:04:08,610
provide our load balancer and the

00:04:05,610 --> 00:04:14,610
atomicity is quite important because we

00:04:08,610 --> 00:04:19,140
have to to set to load all the rules in

00:04:14,610 --> 00:04:22,710
the same time so we are going to avoid

00:04:19,140 --> 00:04:26,669
side effects that we will face with IP

00:04:22,710 --> 00:04:27,630
tables another improvement is that no

00:04:26,669 --> 00:04:30,210
matching or

00:04:27,630 --> 00:04:35,700
marking packets are needed so the

00:04:30,210 --> 00:04:39,930
performance is going to be very well and

00:04:35,700 --> 00:04:41,670
we will we have several for welding

00:04:39,930 --> 00:04:47,940
metals the same for when the metal such

00:04:41,670 --> 00:04:53,460
a pitiable is able to provide this is a

00:04:47,940 --> 00:04:58,560
diagram to explain this behavior from

00:04:53,460 --> 00:05:01,580
userspace perspective we have the

00:04:58,560 --> 00:05:05,520
ruleset manager I have checked diamond

00:05:01,580 --> 00:05:10,380
to check different layers the real

00:05:05,520 --> 00:05:14,160
servers in just one enough table script

00:05:10,380 --> 00:05:19,230
we are able to load atomically those

00:05:14,160 --> 00:05:23,850
rules just just updating the nut-nut

00:05:19,230 --> 00:05:26,130
table internet space this will provide

00:05:23,850 --> 00:05:31,620
much more performance start with IP

00:05:26,130 --> 00:05:35,460
tables well what what are the features

00:05:31,620 --> 00:05:38,250
we want to accomplish with with load

00:05:35,460 --> 00:05:41,760
balancing with tables first of all

00:05:38,250 --> 00:05:44,670
there's schedulers the Magnus schedulers

00:05:41,760 --> 00:05:47,610
will have to to implement is the wrong

00:05:44,670 --> 00:05:52,380
rubbing weight or these connections this

00:05:47,610 --> 00:05:56,870
is the most popular one used about the

00:05:52,380 --> 00:06:03,690
persistence it's important to have

00:05:56,870 --> 00:06:05,940
persistence by source IP forwarding

00:06:03,690 --> 00:06:10,080
metals is not on the net in order to

00:06:05,940 --> 00:06:13,710
perform transparency or not regarding

00:06:10,080 --> 00:06:18,110
the health checks will be moved to user

00:06:13,710 --> 00:06:21,180
space through a diamond in order to

00:06:18,110 --> 00:06:25,110
perform some health checks at different

00:06:21,180 --> 00:06:26,880
layers and of course if tables will

00:06:25,110 --> 00:06:29,700
provide a very good integration with

00:06:26,880 --> 00:06:34,290
quality of service and filtering so this

00:06:29,700 --> 00:06:38,270
is great now we are going to see some

00:06:34,290 --> 00:06:41,040
use cases that we will we will show here

00:06:38,270 --> 00:06:41,370
for example around roving load balancing

00:06:41,040 --> 00:06:47,280
with

00:06:41,370 --> 00:06:50,430
is quite what easy we have butyl IP and

00:06:47,280 --> 00:06:56,130
a single bit report and then we have to

00:06:50,430 --> 00:06:58,639
set the scheduler I'm both real service

00:06:56,130 --> 00:07:03,870
in this case these are basic basic basic

00:06:58,639 --> 00:07:07,500
case with IP tables is quite easy

00:07:03,870 --> 00:07:12,770
because we have just to set one rule /

00:07:07,500 --> 00:07:16,800
backend and using the match statistic

00:07:12,770 --> 00:07:20,220
but with enough tables it's much clearer

00:07:16,800 --> 00:07:24,840
because we have just two training to

00:07:20,220 --> 00:07:27,960
create chain a pollutant chain link it

00:07:24,840 --> 00:07:32,760
with the hook routine and then just with

00:07:27,960 --> 00:07:37,669
one rule we could we could create run

00:07:32,760 --> 00:07:41,130
roving load balancer the dynamic rules

00:07:37,669 --> 00:07:44,720
is quite important here because we in

00:07:41,130 --> 00:07:49,800
one just rule and creating a map we call

00:07:44,720 --> 00:07:57,050
we could switch one one connection to

00:07:49,800 --> 00:08:01,530
one real server or another in the weight

00:07:57,050 --> 00:08:04,740
case with LVS is quite simple because we

00:08:01,530 --> 00:08:10,400
have just to change the disk a Buehler

00:08:04,740 --> 00:08:17,430
and setting the static weight for every

00:08:10,400 --> 00:08:21,180
everywhere server with IP tables is a

00:08:17,430 --> 00:08:24,210
it's quite easy but we have to maintain

00:08:21,180 --> 00:08:27,690
two rules we have to use a statistic

00:08:24,210 --> 00:08:31,220
match with random mode and setting the

00:08:27,690 --> 00:08:31,220
probability for each rule

00:08:33,270 --> 00:08:41,089
with enough tables it's quite easy

00:08:36,589 --> 00:08:46,260
because we have to use a random

00:08:41,089 --> 00:08:50,970
scheduler here and then creating just a

00:08:46,260 --> 00:08:54,089
map with certain weight here studied

00:08:50,970 --> 00:09:00,959
weight we could switch the connection

00:08:54,089 --> 00:09:04,890
from one real server or another the

00:09:00,959 --> 00:09:09,899
multi port case is a little bit complex

00:09:04,890 --> 00:09:13,110
for LVS because we have to use IP tables

00:09:09,899 --> 00:09:19,140
in order to mark the connections using

00:09:13,110 --> 00:09:22,680
the multi port match and with the mark

00:09:19,140 --> 00:09:25,560
that the connections will have to we

00:09:22,680 --> 00:09:31,430
want to to load balance we have to

00:09:25,560 --> 00:09:31,430
create a virtual service using this mark

00:09:32,330 --> 00:09:40,829
with IP tables we have just to include a

00:09:36,630 --> 00:09:44,570
multi-port match and the list of port

00:09:40,829 --> 00:09:47,880
that we want to load balance layer for

00:09:44,570 --> 00:09:52,110
but with enough tables this is quite

00:09:47,880 --> 00:09:55,950
easy because it's natively integrated so

00:09:52,110 --> 00:09:59,670
we have just to put the list of ports or

00:09:55,950 --> 00:10:03,410
list of IP address that we want to block

00:09:59,670 --> 00:10:08,700
balance therefore this will be the base

00:10:03,410 --> 00:10:13,649
so in this in this case the weight are

00:10:08,700 --> 00:10:18,920
statically configured but we could

00:10:13,649 --> 00:10:21,300
perform some more complex schedulers

00:10:18,920 --> 00:10:23,730
using the weighted for example whether

00:10:21,300 --> 00:10:30,540
this connection waist weighted list

00:10:23,730 --> 00:10:32,940
response we will see later the

00:10:30,540 --> 00:10:37,260
persistent I be persistent parasocial IP

00:10:32,940 --> 00:10:40,320
is quite important with LVS is quite

00:10:37,260 --> 00:10:42,050
easy because it's fully integrated we

00:10:40,320 --> 00:10:47,629
have just 2

00:10:42,050 --> 00:10:50,119
set the parameter and the timeout with

00:10:47,629 --> 00:10:53,329
iptables is a little bit complex

00:10:50,119 --> 00:10:58,879
we hope because we have to set three at

00:10:53,329 --> 00:11:01,910
least three rules per buck and this

00:10:58,879 --> 00:11:04,759
approach has some problems because we

00:11:01,910 --> 00:11:07,129
have to firstly we have to mark several

00:11:04,759 --> 00:11:11,600
times in order to ensure that the the

00:11:07,129 --> 00:11:14,809
packet is marked and then in the manual

00:11:11,600 --> 00:11:19,999
table and then just in the night table

00:11:14,809 --> 00:11:23,480
we have to forward to the 12 to

00:11:19,999 --> 00:11:26,779
ascertain real server another problem is

00:11:23,480 --> 00:11:30,189
that we have to maintain with the recent

00:11:26,779 --> 00:11:33,350
match we have to maintain two lists of

00:11:30,189 --> 00:11:39,529
source IP address in order to know the

00:11:33,350 --> 00:11:42,049
persistency for each back-end with

00:11:39,529 --> 00:11:45,829
enough tables this will be much more

00:11:42,049 --> 00:11:49,059
clear because we have to create firstly

00:11:45,829 --> 00:11:53,660
we don't need too much the day packets

00:11:49,059 --> 00:11:56,839
that we have to create a map with the

00:11:53,660 --> 00:12:00,980
association of source IP am real server

00:11:56,839 --> 00:12:06,040
IP so we don't need to to create several

00:12:00,980 --> 00:12:12,829
lists for real servers and we have to

00:12:06,040 --> 00:12:16,549
just set timeout for every entry once

00:12:12,829 --> 00:12:21,350
the protein chain is linked up with the

00:12:16,549 --> 00:12:26,720
hook for routing we have just to look up

00:12:21,350 --> 00:12:32,389
the source IP to the internet map if is

00:12:26,720 --> 00:12:36,230
this match is matches then go to the

00:12:32,389 --> 00:12:39,410
catch catch down table which is just

00:12:36,230 --> 00:12:44,809
directly the net to the to the back end

00:12:39,410 --> 00:12:46,970
a signal if the list doesn't exist if

00:12:44,809 --> 00:12:51,740
the source IP doesn't assist in the list

00:12:46,970 --> 00:12:56,499
then we will set up the scheduler and

00:12:51,740 --> 00:12:56,499
then include in the map the new entry

00:12:57,019 --> 00:13:05,970
as I said this is the base of the more

00:13:01,349 --> 00:13:08,419
complex behavior of schedulers for

00:13:05,970 --> 00:13:12,119
example the weighted list connections

00:13:08,419 --> 00:13:15,899
there were ten list connections will use

00:13:12,119 --> 00:13:21,229
the same the same base but instead of

00:13:15,899 --> 00:13:25,109
using the static weight we have to

00:13:21,229 --> 00:13:29,459
create in the within the diamond the

00:13:25,109 --> 00:13:34,799
user space time we had to create dynamic

00:13:29,459 --> 00:13:36,509
weights using the table script that we

00:13:34,799 --> 00:13:39,869
are going to gather from the contract

00:13:36,509 --> 00:13:42,209
table from the current contract table we

00:13:39,869 --> 00:13:44,369
have all the information of how many

00:13:42,209 --> 00:13:49,099
connection established connections we

00:13:44,369 --> 00:13:49,099
have in the for every real server

00:13:50,029 --> 00:14:02,369
another example is the wait wait at

00:13:58,949 --> 00:14:05,489
least response in the user space diamo

00:14:02,369 --> 00:14:09,479
we have several checks health checks

00:14:05,489 --> 00:14:12,499
that we are going to gather the time

00:14:09,479 --> 00:14:18,199
that these checks are are being

00:14:12,499 --> 00:14:22,979
executing the less the last response

00:14:18,199 --> 00:14:27,209
back end will be the most higher weight

00:14:22,979 --> 00:14:33,359
for in the case of the NF table script

00:14:27,209 --> 00:14:37,109
with the weight schedule and similar

00:14:33,359 --> 00:14:41,039
case for weighted least CPU load will

00:14:37,109 --> 00:14:44,429
check through SNMP for example there's a

00:14:41,039 --> 00:14:47,999
few lot of every back end if the lesser

00:14:44,429 --> 00:14:51,389
CPU load packing will be the higher we

00:14:47,999 --> 00:14:55,330
get a higher weight in our energy table

00:14:51,389 --> 00:15:01,070
script which we will be low

00:14:55,330 --> 00:15:04,640
I don't make the lease so there is no no

00:15:01,070 --> 00:15:05,660
problem we will have to update it

00:15:04,640 --> 00:15:14,600
protein nuts

00:15:05,660 --> 00:15:18,040
a table very safe well what is the they

00:15:14,600 --> 00:15:23,660
were to do here yes we have to implement

00:15:18,040 --> 00:15:27,350
some mineral changes to any tables a run

00:15:23,660 --> 00:15:32,360
on which it seems that Cornell eateries

00:15:27,350 --> 00:15:34,760
are apart nth for robbing and some maps

00:15:32,360 --> 00:15:39,770
enactments in order to perform correctly

00:15:34,760 --> 00:15:43,580
the IP persistency the user space

00:15:39,770 --> 00:15:46,640
diamond will be the most workload to be

00:15:43,580 --> 00:15:48,200
done mmm in order to perform the health

00:15:46,640 --> 00:15:53,110
checks different health checks at

00:15:48,200 --> 00:15:56,750
different layers and a dynamic wait for

00:15:53,110 --> 00:15:58,940
in order to perform correctly scone

00:15:56,750 --> 00:16:05,180
waited list connection list response or

00:15:58,940 --> 00:16:11,270
list the payload scheduler some

00:16:05,180 --> 00:16:14,510
conclusions of this talk first of all we

00:16:11,270 --> 00:16:18,800
will want to simplify the content

00:16:14,510 --> 00:16:20,570
structure in this case we want to move

00:16:18,800 --> 00:16:22,730
all the complexity of load balancing

00:16:20,570 --> 00:16:28,760
that currently is done in oliviers

00:16:22,730 --> 00:16:31,360
package into the user space controller

00:16:28,760 --> 00:16:35,440
the kernel development in terms of

00:16:31,360 --> 00:16:43,910
avoiding some duplicate work for example

00:16:35,440 --> 00:16:48,770
LVS has its own extensions or handlers

00:16:43,910 --> 00:16:54,220
that which are different from from

00:16:48,770 --> 00:16:57,250
iptables on any table but they would

00:16:54,220 --> 00:17:02,360
behavior is the same so it's quite

00:16:57,250 --> 00:17:05,540
strange but as maintenance of the source

00:17:02,360 --> 00:17:07,880
code and not give LV support for any

00:17:05,540 --> 00:17:12,839
tables for the

00:17:07,880 --> 00:17:17,339
for the colonel and finally with this

00:17:12,839 --> 00:17:19,790
approach we will have a unique art API

00:17:17,339 --> 00:17:24,480
for networking handling so we will use

00:17:19,790 --> 00:17:30,780
tables for quality of service filter but

00:17:24,480 --> 00:17:52,530
also with a load balancing okay thank

00:17:30,780 --> 00:17:55,260
you if you have any question well there

00:17:52,530 --> 00:17:59,310
is some studies from universities and

00:17:55,260 --> 00:18:10,680
our own testing is quite more

00:17:59,310 --> 00:18:14,700
performance than yes no because this is

00:18:10,680 --> 00:18:44,270
a prototype they recently patch husband

00:18:14,700 --> 00:18:49,950
on maybe this there for months

00:18:44,270 --> 00:18:52,440
yes and also with LVS there is some

00:18:49,950 --> 00:18:56,660
because a work that really for example

00:18:52,440 --> 00:19:01,410
is doing the contract so we call a boy

00:18:56,660 --> 00:19:04,610
to do this everything twice so the

00:19:01,410 --> 00:19:04,610
performance is better

00:19:13,290 --> 00:19:16,690
Thank You tables I would be we do big

00:19:16,210 --> 00:19:20,080
one

00:19:16,690 --> 00:19:21,070
wait weather for the water okay so this

00:19:20,080 --> 00:19:23,460
should be dead

00:19:21,070 --> 00:19:23,460
yes

00:19:32,180 --> 00:19:36,190

YouTube URL: https://www.youtube.com/watch?v=Jq6sxsnOt6g


