Title: Netdev  0x13 - An Asynchronous Dataplane for FRR
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 1 - Track 3 - Mar 20 2019
Description: 
	Mark Stapp async describes the threaded model which is part of FRR's
new model planned to improve scale ability.

https://netdevconf.org/0x13/news.html?talk-FRR-async
Captions: 
	00:00:41,540 --> 00:00:44,600
[Music]

00:00:51,270 --> 00:00:54,349
[Music]

00:01:20,770 --> 00:01:23,890
[Music]

00:02:04,330 --> 00:02:07,330
so

00:03:10,730 --> 00:03:12,819
and

00:04:17,520 --> 00:04:20,520
so

00:04:46,900 --> 00:04:50,029
[Music]

00:05:34,920 --> 00:05:38,079
[Music]

00:06:47,310 --> 00:06:53,389
so

00:06:50,300 --> 00:06:53,389
[Music]

00:09:21,630 --> 00:09:24,200
so

00:09:48,290 --> 00:09:51,419
[Music]

00:10:48,720 --> 00:10:56,630
mr. zebra

00:11:11,089 --> 00:11:14,199
this kind of just

00:11:25,080 --> 00:11:28,159
[Music]

00:11:55,529 --> 00:11:58,529
yeah

00:13:31,020 --> 00:13:33,620
so

00:15:07,650 --> 00:15:11,430
what's the a channel between the data

00:15:10,270 --> 00:15:13,660
plane and the main thread

00:15:11,430 --> 00:15:24,220
what's the channel that you queues how

00:15:13,660 --> 00:15:30,010
do you build them between the two

00:15:24,220 --> 00:15:33,180
threads but you said that you might have

00:15:30,010 --> 00:15:33,180
a remote data plane

00:16:25,350 --> 00:16:32,400
so in this example let's say I have

00:16:28,860 --> 00:16:35,430
brought some kind of hardware and ASIC

00:16:32,400 --> 00:16:38,630
will that be called kernel provider or

00:16:35,430 --> 00:16:38,630
remote provider

00:17:15,260 --> 00:17:22,250
though to specifically answer your

00:17:17,630 --> 00:17:24,790
question it is easy doesn't care how the

00:17:22,250 --> 00:17:24,790
program

00:17:25,190 --> 00:17:29,069
[Music]

00:17:26,380 --> 00:17:29,069
person

00:17:39,840 --> 00:17:42,840
so

00:18:00,000 --> 00:18:05,200
yeah but they could provide those

00:18:02,350 --> 00:18:08,220
plugins that'll fit fit in here right so

00:18:05,200 --> 00:18:08,220
it's just the plugin

00:18:26,450 --> 00:18:35,249
so so I only know the very old car got

00:18:31,320 --> 00:18:38,669
and what I understand it it he had the

00:18:35,249 --> 00:18:43,349
ready but and talk to the colonel was

00:18:38,669 --> 00:18:46,349
linked and I assume Colonel poor

00:18:43,349 --> 00:18:49,709
batteries the net link speaker and the

00:18:46,349 --> 00:18:57,479
remote provider is the basic or anything

00:18:49,709 --> 00:19:02,419
and so so basically zero data playing in

00:18:57,479 --> 00:19:02,419
this diagram is the zebra D itself

00:19:10,760 --> 00:19:13,930
[Music]

00:19:16,280 --> 00:19:29,740
I see thank you are there actually any

00:19:27,050 --> 00:19:31,880
routing protocol clients that take the

00:19:29,740 --> 00:19:35,650
successful installation of the routes

00:19:31,880 --> 00:19:35,650
into account kind of that feedback path

00:19:41,620 --> 00:19:47,120
so that is a long-standing open issue

00:19:45,050 --> 00:19:48,680
that we need to fix currently there's no

00:19:47,120 --> 00:19:56,030
provision for even communicating that to

00:19:48,680 --> 00:19:57,800
the daemons but currently if you can as

00:19:56,030 --> 00:19:59,750
a upper-level protocol you can register

00:19:57,800 --> 00:20:01,490
with zebra saying hey when my route

00:19:59,750 --> 00:20:03,770
installs or fails or whatever happens to

00:20:01,490 --> 00:20:05,990
it let me know what the status of it so

00:20:03,770 --> 00:20:08,480
that feedback mechanism they're only

00:20:05,990 --> 00:20:10,370
like one daemon actually watches that

00:20:08,480 --> 00:20:11,480
currently because you know again someone

00:20:10,370 --> 00:20:13,220
has to go through and do it but you're

00:20:11,480 --> 00:20:14,600
actually on a percent right the feedback

00:20:13,220 --> 00:20:17,210
mechanism for all that things like rip

00:20:14,600 --> 00:20:19,760
and BGP they need to be there just

00:20:17,210 --> 00:20:21,980
haven't been done yet so that's in the

00:20:19,760 --> 00:20:23,630
process but the the infrastructure is

00:20:21,980 --> 00:20:24,650
there someone needs to go and write it

00:20:23,630 --> 00:20:26,480
and take advantage of it and we actually

00:20:24,650 --> 00:20:28,070
have a pull request for BGP to take

00:20:26,480 --> 00:20:29,300
advantage of that but they were running

00:20:28,070 --> 00:20:32,060
to some other issues and we haven't

00:20:29,300 --> 00:20:34,970
quite gotten it in the codebase yet so

00:20:32,060 --> 00:20:37,190
there's a demon called chitin aimed at

00:20:34,970 --> 00:20:40,510
this I call it sharp D it was a joke and

00:20:37,190 --> 00:20:43,970
I thought people were gonna go Donald

00:20:40,510 --> 00:20:48,500
great idea stupid demon name but it went

00:20:43,970 --> 00:20:51,020
in so it basically it's a proof of

00:20:48,500 --> 00:20:52,790
concept I can you can say install

00:20:51,020 --> 00:20:54,890
million routes and it will install a

00:20:52,790 --> 00:20:56,170
million routes for you and it knows when

00:20:54,890 --> 00:20:58,580
those million routes are installed

00:20:56,170 --> 00:21:00,860
it's a tested daemon but it's great for

00:20:58,580 --> 00:21:02,840
proof of concepts like if you have you

00:21:00,860 --> 00:21:04,940
know you're going to a customer and they

00:21:02,840 --> 00:21:07,730
say can your can you and can you handle

00:21:04,940 --> 00:21:09,080
a million routes well sure here online I

00:21:07,730 --> 00:21:11,360
have a million routes in the rib and

00:21:09,080 --> 00:21:13,880
then installed so that's kind of the

00:21:11,360 --> 00:21:16,070
goal and so it knows and I also use it

00:21:13,880 --> 00:21:17,960
as a development feature for myself so I

00:21:16,070 --> 00:21:20,870
do a lot of performance testing so I

00:21:17,960 --> 00:21:23,180
have a regular way to install and remove

00:21:20,870 --> 00:21:25,430
routes that I can then look at the

00:21:23,180 --> 00:21:27,110
timing and so the the daemon pays

00:21:25,430 --> 00:21:28,700
attention to that and knows oh you told

00:21:27,110 --> 00:21:29,690
me to install a million routes I got a

00:21:28,700 --> 00:21:32,390
million notifications

00:21:29,690 --> 00:21:34,250
that they're installed I'm done and it's

00:21:32,390 --> 00:21:38,590
it's in the wrist it's in the kernel so

00:21:34,250 --> 00:21:38,590
I know for a fact how long it took

00:21:45,210 --> 00:21:57,100
so so it's a isn't that really kind of a

00:21:53,639 --> 00:21:58,239
individual nauss everyone every NOS

00:21:57,100 --> 00:22:00,100
behaves a little differently so I can

00:21:58,239 --> 00:22:01,809
answer from a cumulus Linux perspective

00:22:00,100 --> 00:22:05,259
I can't necessarily answer from a volta

00:22:01,809 --> 00:22:12,009
perspective about how that works so in

00:22:05,259 --> 00:22:13,989
typical the typically we do not notify

00:22:12,009 --> 00:22:16,149
zebra does not notify the upper-level

00:22:13,989 --> 00:22:18,970
protocol that the raht was installed

00:22:16,149 --> 00:22:21,039
successfully until I got the end of the

00:22:18,970 --> 00:22:24,369
can you go back to the the next slide I

00:22:21,039 --> 00:22:27,099
guess this slide so that this slide so

00:22:24,369 --> 00:22:30,129
it's when the result comes back here

00:22:27,099 --> 00:22:33,070
that is when the notification so that so

00:22:30,129 --> 00:22:35,409
that's when it happened so so if if if

00:22:33,070 --> 00:22:38,559
like take Volta as an example here if

00:22:35,409 --> 00:22:42,460
the remote provider says it's installed

00:22:38,559 --> 00:22:44,979
and gets we get the contacts back then

00:22:42,460 --> 00:22:46,919
we know it's installed okay so but I

00:22:44,979 --> 00:22:55,359
don't know I haven't looked at Voltas

00:22:46,919 --> 00:22:57,489
implementation to know for a fact so

00:22:55,359 --> 00:22:59,679
there is no feedback current mechanism

00:22:57,489 --> 00:23:01,779
between for cumulus linux unfortunately

00:22:59,679 --> 00:23:03,639
there's no current feedback when the

00:23:01,779 --> 00:23:05,979
route goes in the kernel it there is a

00:23:03,639 --> 00:23:08,320
small delay before it goes into the ASIC

00:23:05,979 --> 00:23:09,789
but that we don't have that programmed

00:23:08,320 --> 00:23:14,259
at this point in time and something we

00:23:09,789 --> 00:23:18,970
know when it's going to work on do you

00:23:14,259 --> 00:23:20,710
have more presentation or okay then so

00:23:18,970 --> 00:23:23,859
just for clarification there are three

00:23:20,710 --> 00:23:26,470
different ways that FRR can talk to some

00:23:23,859 --> 00:23:28,570
switch silicon the more number one is

00:23:26,470 --> 00:23:29,889
just through a kernel driver that hooks

00:23:28,570 --> 00:23:32,049
into the appropriate switch to have

00:23:29,889 --> 00:23:36,039
api's I think Mellanox spectrum driver

00:23:32,049 --> 00:23:38,200
does this upstream number two is you can

00:23:36,039 --> 00:23:40,210
have a user space daemon separate of FRR

00:23:38,200 --> 00:23:42,729
that just reads net link that's what

00:23:40,210 --> 00:23:45,330
humans does with switch T and number

00:23:42,729 --> 00:23:48,789
three is the work that is done here

00:23:45,330 --> 00:23:51,070
where you create a custom plug-in that

00:23:48,789 --> 00:23:53,320
runs inside of zebra in the process and

00:23:51,070 --> 00:23:55,029
does whatever you want to talk to your

00:23:53,320 --> 00:23:57,820
data plane that could be 0 and Q that

00:23:55,029 --> 00:24:01,600
could be direct Hardware whatever

00:23:57,820 --> 00:24:03,159
and yeah that is the focus here and um I

00:24:01,600 --> 00:24:05,580
actually have I have two questions on

00:24:03,159 --> 00:24:09,909
this the one is for the kernel people

00:24:05,580 --> 00:24:13,270
regarding multi-threading this so should

00:24:09,909 --> 00:24:16,299
we as user space also try to move this

00:24:13,270 --> 00:24:19,600
right our routing table updates because

00:24:16,299 --> 00:24:23,830
they're still the RTL look look so I

00:24:19,600 --> 00:24:26,169
guess the answer is no and he actually

00:24:23,830 --> 00:24:28,299
kind of alluded to it it's the batch the

00:24:26,169 --> 00:24:30,070
answer from the kernel perspective so

00:24:28,299 --> 00:24:31,720
you're right there is a lock a global

00:24:30,070 --> 00:24:35,080
lock for each route install so you can't

00:24:31,720 --> 00:24:37,720
multi thread it so what the the kernel

00:24:35,080 --> 00:24:40,240
answer is that you can pass down a bunch

00:24:37,720 --> 00:24:43,270
of route Arnette link messages at one

00:24:40,240 --> 00:24:45,640
time and you save the 50 milli like so

00:24:43,270 --> 00:24:49,539
if you if you batch 100 route installs

00:24:45,640 --> 00:24:51,429
instead of instead of you know one one

00:24:49,539 --> 00:24:53,590
right then a read fry the kernel then a

00:24:51,429 --> 00:24:55,570
than a right for the answer back you get

00:24:53,590 --> 00:24:58,960
one right down for everything and the

00:24:55,570 --> 00:24:59,590
kernel la opens the lock once does all

00:24:58,960 --> 00:25:01,840
the work

00:24:59,590 --> 00:25:03,400
unlocks a lock and pass it up so you get

00:25:01,840 --> 00:25:05,020
a lot less lock in and you get a lot

00:25:03,400 --> 00:25:06,970
less contention and you actually get

00:25:05,020 --> 00:25:09,070
some speed ups it's about you know

00:25:06,970 --> 00:25:10,900
really it's the patch request isn't

00:25:09,070 --> 00:25:16,299
presented upstream but it's about a

00:25:10,900 --> 00:25:22,090
quarter faster Annie does anyone want to

00:25:16,299 --> 00:25:24,190
add it I don't the option number three

00:25:22,090 --> 00:25:26,260
that you gave you can use you can

00:25:24,190 --> 00:25:31,750
program your hardware directly from the

00:25:26,260 --> 00:25:39,030
zebra that would be most efficient well

00:25:31,750 --> 00:25:41,740
I mean if you want to do that so sure

00:25:39,030 --> 00:25:43,179
yeah yeah I mean you can't bypass the

00:25:41,740 --> 00:25:52,720
kernel at that point you're inside of

00:25:43,179 --> 00:25:54,309
the zipper process so yeah so and the

00:25:52,720 --> 00:25:55,780
other questions is that this actually

00:25:54,309 --> 00:25:57,070
leads straight over to the other thing I

00:25:55,780 --> 00:25:58,809
wanted to bring up which is kind of a

00:25:57,070 --> 00:26:01,809
question suggestion combination I was

00:25:58,809 --> 00:26:05,590
hoping to discuss this remark right now

00:26:01,809 --> 00:26:07,240
the data plane API it does support

00:26:05,590 --> 00:26:10,179
multiple idea to play in the handlers I

00:26:07,240 --> 00:26:10,930
think at least that's planned but it's

00:26:10,179 --> 00:26:14,230
not organized

00:26:10,930 --> 00:26:16,540
in a way that allows it to to abstract

00:26:14,230 --> 00:26:19,600
away so I'm actually gonna paint on the

00:26:16,540 --> 00:26:22,530
wine party right part here so right now

00:26:19,600 --> 00:26:26,920
what we have is the the ribbon zebra and

00:26:22,530 --> 00:26:34,510
it uses the data plane abstraction which

00:26:26,920 --> 00:26:36,190
does cover both plugin and net link but

00:26:34,510 --> 00:26:38,800
that that's about it for the structure

00:26:36,190 --> 00:26:40,780
so there's it's a fixed structure where

00:26:38,800 --> 00:26:43,660
you can have one or more data plane

00:26:40,780 --> 00:26:45,580
handlers that does the updating and I

00:26:43,660 --> 00:26:47,320
guess that the kernel and a remote API

00:26:45,580 --> 00:26:49,900
are actually not gonna be treated any

00:26:47,320 --> 00:26:52,360
different on this however we can

00:26:49,900 --> 00:26:57,160
actually improve on this design if we

00:26:52,360 --> 00:26:59,710
have a well-defined well abstracted

00:26:57,160 --> 00:27:03,430
point of interfacing here that allows

00:26:59,710 --> 00:27:05,230
reusing itself at a later point and the

00:27:03,430 --> 00:27:07,150
reason I'm bringing this up is exactly

00:27:05,230 --> 00:27:09,730
what you asked about the source of truth

00:27:07,150 --> 00:27:12,220
right now we have hard-coded into the

00:27:09,730 --> 00:27:15,030
data plane handling for whenever

00:27:12,220 --> 00:27:17,320
multiple data planes are in there that

00:27:15,030 --> 00:27:21,340
something needs to happen when the

00:27:17,320 --> 00:27:25,450
results disagree so if we make this API

00:27:21,340 --> 00:27:29,380
reusable we can have the zebra RHIB only

00:27:25,450 --> 00:27:31,540
interface with one data plane Handler

00:27:29,380 --> 00:27:33,670
and the data plane handler itself can be

00:27:31,540 --> 00:27:35,830
a module that is for example a

00:27:33,670 --> 00:27:38,980
combination service and you can put the

00:27:35,830 --> 00:27:41,290
policy into that combination data plane

00:27:38,980 --> 00:27:43,060
and you can implement whatever you're

00:27:41,290 --> 00:27:45,910
interested in for your particular

00:27:43,060 --> 00:27:50,550
application case and you can also put

00:27:45,910 --> 00:27:54,130
things in here like table compression so

00:27:50,550 --> 00:27:56,590
if you want to do people here know what

00:27:54,130 --> 00:27:59,440
there are table compression is so you

00:27:56,590 --> 00:28:01,720
just since the routes are generally

00:27:59,440 --> 00:28:04,600
similar you try to install fewer routes

00:28:01,720 --> 00:28:06,970
by reusing the same route and yeah so

00:28:04,600 --> 00:28:12,540
that could be simply an inline proxy

00:28:06,970 --> 00:28:17,200
that goes from the rib and compresses

00:28:12,540 --> 00:28:20,170
and then uses the same API again to talk

00:28:17,200 --> 00:28:23,590
to the kernel or to this splitter

00:28:20,170 --> 00:28:24,650
functionality or something like that or

00:28:23,590 --> 00:28:26,720
even

00:28:24,650 --> 00:28:29,210
this further you can also support multi

00:28:26,720 --> 00:28:30,890
chassis devices through this where you

00:28:29,210 --> 00:28:33,200
have handler in the middle in the middle

00:28:30,890 --> 00:28:35,570
that takes care of properly programming

00:28:33,200 --> 00:28:38,930
your two three four twenty different

00:28:35,570 --> 00:28:41,090
devices with possibly modified next tops

00:28:38,930 --> 00:28:43,100
that make sure that the devices talk to

00:28:41,090 --> 00:28:45,560
each other and you need to for next

00:28:43,100 --> 00:28:47,870
stops and so on but I don't think this

00:28:45,560 --> 00:28:50,120
is something we can currently do and I

00:28:47,870 --> 00:28:53,300
was just hoping to bring this up here

00:28:50,120 --> 00:28:55,880
and get the discussion rolling on how we

00:28:53,300 --> 00:29:05,960
get here from the current data plane

00:28:55,880 --> 00:29:08,360
that we have yet just wondering on the

00:29:05,960 --> 00:29:10,610
shared next subgroups is there also you

00:29:08,360 --> 00:29:11,750
know some kind of tracking in terms of

00:29:10,610 --> 00:29:13,910
when you have got reconvergence

00:29:11,750 --> 00:29:17,360
typically you know you've got ten

00:29:13,910 --> 00:29:19,520
thousand routes that all you know for

00:29:17,360 --> 00:29:21,350
all of whom the next stop group you know

00:29:19,520 --> 00:29:23,270
just the next hops are changing so

00:29:21,350 --> 00:29:26,480
basically could keep the next up group

00:29:23,270 --> 00:29:29,180
to change the actual members of it is is

00:29:26,480 --> 00:29:32,380
that something that you know the zebra

00:29:29,180 --> 00:29:32,380
demon is trying to do then

00:29:35,440 --> 00:29:43,059
five groups in and then and then add the

00:29:39,940 --> 00:29:45,820
extensibility to allow to be so formal

00:29:43,059 --> 00:29:48,149
in external perspective it's already in

00:29:45,820 --> 00:29:48,149
there

00:29:55,070 --> 00:29:59,720
right better what I'm saying is that

00:29:57,150 --> 00:29:59,720
yeah

00:30:06,490 --> 00:30:11,420
right but what I'm what I'm saying is

00:30:08,900 --> 00:30:15,880
that you know you want to update the

00:30:11,420 --> 00:30:19,040
next up group members themselves okay so

00:30:15,880 --> 00:30:22,510
so that API call itself isn't even there

00:30:19,040 --> 00:30:22,510
yet becoming okay

00:30:35,460 --> 00:30:41,619

YouTube URL: https://www.youtube.com/watch?v=0C3DFWJlX7E


