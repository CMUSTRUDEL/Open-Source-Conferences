Title: Netdev 0x13 -  FRRouting Workshop
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 1 - Track 3 - Mar 20 2019
Description: 
	Donald Sharp and David Lamparter co-chair the FRRouting workshop.

Discussions on current outstanding issues and upcoming features such
as how to take advantage of the current next hop disaggregation in the kernel
took place.

More info:
https://www.netdevconf.org/0x13/session.html?workshop-FRRouting
Captions: 
	00:00:00,060 --> 00:00:06,589
welcome everyone this is the fr Aden

00:00:02,810 --> 00:00:10,410
workshop our goal today really is to

00:00:06,589 --> 00:00:12,330
talk about the direction and try to

00:00:10,410 --> 00:00:14,660
maybe make some decisions about how we

00:00:12,330 --> 00:00:18,270
want to handle things in the future and

00:00:14,660 --> 00:00:20,400
from my perspective I would would really

00:00:18,270 --> 00:00:21,630
like to have audience participation if

00:00:20,400 --> 00:00:26,250
you have questions feel free to raise

00:00:21,630 --> 00:00:31,710
your hand and and we can have that

00:00:26,250 --> 00:00:33,690
conversation all right oh end after the

00:00:31,710 --> 00:00:35,820
presentation if you want a sticker I

00:00:33,690 --> 00:00:39,090
have a whole bunch come free Hillary to

00:00:35,820 --> 00:00:42,090
get one all right by the way i'm donald

00:00:39,090 --> 00:00:44,700
sharp and this is David Lam partier we

00:00:42,090 --> 00:00:49,350
are both on the TSC committee for FR out

00:00:44,700 --> 00:01:15,509
and and we help Shepherd and move the

00:00:49,350 --> 00:01:22,799
project forward I guess so please make

00:01:15,509 --> 00:01:26,460
your interest start is this actually has

00:01:22,799 --> 00:01:34,140
a representation after this so we have

00:01:26,460 --> 00:01:35,939
only two couple the data came from do

00:01:34,140 --> 00:01:40,110
current currently in phases that we have

00:01:35,939 --> 00:01:43,439
so previously you have a compliant in

00:01:40,110 --> 00:01:46,530
choice using either to be back end or

00:01:43,439 --> 00:01:49,579
back end that start getting extended and

00:01:46,530 --> 00:01:53,960
now there is interest in having this

00:01:49,579 --> 00:01:58,430
more what you are and movie threaded and

00:01:53,960 --> 00:01:58,430
so this is I'm going to work and

00:02:01,000 --> 00:02:10,179
I believe it's in this room immediately

00:02:03,710 --> 00:02:10,179
after you're all right nice to meet you

00:02:14,690 --> 00:02:17,780
[Music]

00:02:29,170 --> 00:02:34,819
probably aware the Linux kernel is

00:02:32,450 --> 00:02:36,650
getting support for the abstraction of

00:02:34,819 --> 00:02:40,220
next top groups and what that

00:02:36,650 --> 00:02:44,799
effectively means is that you can talk

00:02:40,220 --> 00:02:47,120
about an ECM penis of your route via

00:02:44,799 --> 00:02:49,640
identifiers and when you install on the

00:02:47,120 --> 00:02:52,459
kernel you can just say install route a

00:02:49,640 --> 00:02:54,140
with next hop group B and it will

00:02:52,459 --> 00:02:56,030
automatically set it up for you so I see

00:02:54,140 --> 00:02:57,200
some concern do you have a does that

00:02:56,030 --> 00:03:03,170
make is that clear what I'm trying to

00:02:57,200 --> 00:03:05,840
say there no all right so the goal from

00:03:03,170 --> 00:03:07,670
that perspective is to allow the quicker

00:03:05,840 --> 00:03:09,799
insertion of routes into the kernel and

00:03:07,670 --> 00:03:15,170
what that is going to cause us to have

00:03:09,799 --> 00:03:18,620
to do is to bring in a change to zebra

00:03:15,170 --> 00:03:22,250
to allow us to talk about next hop

00:03:18,620 --> 00:03:26,359
groups and to also abstract next hop

00:03:22,250 --> 00:03:27,920
groups so that they're you only have one

00:03:26,359 --> 00:03:29,840
of them in the system for each next dive

00:03:27,920 --> 00:03:31,790
trip so currently and zebras I don't

00:03:29,840 --> 00:03:35,840
have it displayed here but each route

00:03:31,790 --> 00:03:37,910
entry will have its own next hop graded

00:03:35,840 --> 00:03:39,920
data structure and its own next hops and

00:03:37,910 --> 00:03:41,299
then surrounded tree one will have its

00:03:39,920 --> 00:03:42,799
own next ops route entry two will have

00:03:41,299 --> 00:03:44,269
its own next ops and what we're going to

00:03:42,799 --> 00:03:46,700
end up doing is changing the route

00:03:44,269 --> 00:03:48,650
entries so that each route entry one and

00:03:46,700 --> 00:03:50,720
two they both have the same next hop

00:03:48,650 --> 00:03:53,299
group so they'll both point to the same

00:03:50,720 --> 00:03:55,280
next hop group and so will reduce memory

00:03:53,299 --> 00:03:57,590
usage and also hopefully speed up

00:03:55,280 --> 00:03:59,520
insertion times into the ritalin screen

00:03:57,590 --> 00:04:03,840
all

00:03:59,520 --> 00:04:06,450
so it stated actually here no he's not

00:04:03,840 --> 00:04:08,250
he's got another he's got another so so

00:04:06,450 --> 00:04:10,530
David a Hearn is the guy doing the work

00:04:08,250 --> 00:04:13,980
in the Linux kernel and he has a

00:04:10,530 --> 00:04:15,870
presentation at the last net dev 12 that

00:04:13,980 --> 00:04:18,150
he talked about next hoc groups and how

00:04:15,870 --> 00:04:19,890
it was gonna work and as I understand it

00:04:18,150 --> 00:04:21,930
the patches for that will be going into

00:04:19,890 --> 00:04:24,330
the Linux kernel in the next couple of

00:04:21,930 --> 00:04:26,310
weeks or month they'll be well I

00:04:24,330 --> 00:04:59,670
shouldn't say going in they'll be put

00:04:26,310 --> 00:05:01,140
upstream for we actually have code right

00:04:59,670 --> 00:05:03,960
now will we

00:05:01,140 --> 00:05:05,700
so cumulus is working on a bit of code

00:05:03,960 --> 00:05:08,220
that to take advantage of the David a

00:05:05,700 --> 00:05:11,010
turns the kernel guy and he works a

00:05:08,220 --> 00:05:12,720
cumulus and and we actually have access

00:05:11,010 --> 00:05:13,710
to set of hatches in our I've got code

00:05:12,720 --> 00:05:15,810
going right now

00:05:13,710 --> 00:05:24,380
hopefully in the next couple weeks or

00:05:15,810 --> 00:05:24,380
month we'll have a request for that okay

00:05:42,320 --> 00:05:48,960
so to give you a little bit of context

00:05:44,520 --> 00:05:54,330
right now you can kind of choose if you

00:05:48,960 --> 00:05:56,550
want to you can I believe use the Vail

00:05:54,330 --> 00:06:00,600
3mf support that is in the kernel so you

00:05:56,550 --> 00:06:01,200
created your f must be wise and use the

00:06:00,600 --> 00:06:05,850
Vista

00:06:01,200 --> 00:06:08,340
is associated with that or caronian can

00:06:05,850 --> 00:06:11,160
work with networking spaces where each

00:06:08,340 --> 00:06:13,770
member in space is treated as a separate

00:06:11,160 --> 00:06:18,990
vrf so we cancel it out into a separate

00:06:13,770 --> 00:06:23,040
member information let's put this

00:06:18,990 --> 00:06:25,530
politely this visible support is causing

00:06:23,040 --> 00:06:28,410
a lot of maintenance work because the

00:06:25,530 --> 00:06:32,580
behavior and semantics are very similar

00:06:28,410 --> 00:06:35,430
between two models which we do have a

00:06:32,580 --> 00:06:38,360
PRS trying to implement route linking

00:06:35,430 --> 00:06:38,360
between brf's

00:06:46,700 --> 00:07:07,410
let's say it's far from trivial people

00:07:04,320 --> 00:07:33,210
here know whatever ami is and are using

00:07:07,410 --> 00:07:34,770
it is anyone using as well just to give

00:07:33,210 --> 00:07:36,540
a little bit more background part of the

00:07:34,770 --> 00:07:39,690
the original one of the original

00:07:36,540 --> 00:07:42,210
thoughts that we had was to allow FR out

00:07:39,690 --> 00:07:45,720
into to work kind of like Cisco's

00:07:42,210 --> 00:07:47,190
logical routers or VDCs and the original

00:07:45,720 --> 00:07:50,100
thought from my perspective was to use

00:07:47,190 --> 00:07:53,310
namespaces for that because namespace is

00:07:50,100 --> 00:07:55,260
really kind of map into the VDC world

00:07:53,310 --> 00:07:59,280
and the fact that it's a hard hard

00:07:55,260 --> 00:08:00,870
separation between the the the the

00:07:59,280 --> 00:08:06,750
different routing tables as well as the

00:08:00,870 --> 00:08:09,560
interfaces so one of the so so now that

00:08:06,750 --> 00:08:13,410
we have both verse and namespaces as

00:08:09,560 --> 00:08:14,910
ability to be used as verbs you kind of

00:08:13,410 --> 00:08:17,460
lose the ability to do

00:08:14,910 --> 00:08:19,620
logical routers using name spaces as

00:08:17,460 --> 00:08:21,840
well as verse and it gets into this

00:08:19,620 --> 00:08:23,250
weird level of a double level of

00:08:21,840 --> 00:08:25,890
indirection which i think is it a great

00:08:23,250 --> 00:08:27,990
way to to work and I think it also

00:08:25,890 --> 00:08:29,820
introduces a whole bunch of bugs and so

00:08:27,990 --> 00:08:31,920
one of the goals that we were hoping to

00:08:29,820 --> 00:08:35,430
get done today is to figure out what we

00:08:31,920 --> 00:08:37,320
want to do as a group with verse for

00:08:35,430 --> 00:08:40,800
some namespaces do we want to continue

00:08:37,320 --> 00:08:44,370
to support namespaces are there other

00:08:40,800 --> 00:08:47,430
opportunities for creating verse or

00:08:44,370 --> 00:08:50,220
using verbs on nonlin as kernels I know

00:08:47,430 --> 00:08:52,530
this is a Linux conference but BSD for

00:08:50,220 --> 00:08:54,480
instance has a abstraction too that

00:08:52,530 --> 00:08:58,740
could possibly let you use creative URF

00:08:54,480 --> 00:09:01,820
as well so does anyone have any concerns

00:08:58,740 --> 00:09:01,820
or questions about that

00:09:10,050 --> 00:09:17,490
you know I was using a fr4 as a

00:09:13,990 --> 00:09:19,740
replacement on traditional and legacy

00:09:17,490 --> 00:09:24,069
network equipment but if you are very

00:09:19,740 --> 00:09:28,170
favoring for sake cloud deployments

00:09:24,069 --> 00:09:34,329
where you have on top of rocks you know

00:09:28,170 --> 00:09:37,689
twenty fifty hundred of of networks and

00:09:34,329 --> 00:09:39,369
you would like to work in your isolated

00:09:37,689 --> 00:09:43,269
networking environment then you know

00:09:39,369 --> 00:09:50,019
that the the closest the neighbor it's

00:09:43,269 --> 00:09:52,980
the namespace and not the VFR so in

00:09:50,019 --> 00:10:17,860
which environment you'd like your

00:09:52,980 --> 00:10:20,889
product so small coming to that so I

00:10:17,860 --> 00:10:24,369
mean if you are favoring for namespace

00:10:20,889 --> 00:10:28,329
you have all these kind of armor of you

00:10:24,369 --> 00:10:31,769
know program ability in terms of the

00:10:28,329 --> 00:10:36,279
namespaces well you don't have all the

00:10:31,769 --> 00:10:38,170
program ability for the vrf type of site

00:10:36,279 --> 00:10:39,939
because you know the API you have to

00:10:38,170 --> 00:10:43,240
resort to see ally at some point of

00:10:39,939 --> 00:10:48,269
stuff and not to API and can you do

00:10:43,240 --> 00:10:51,519
everything with a I mean I mean in vrf

00:10:48,269 --> 00:10:55,769
when you set up your vrf and when so

00:10:51,519 --> 00:10:58,240
you'd like to program your hundreds of

00:10:55,769 --> 00:11:00,970
networks inside there on inside the

00:10:58,240 --> 00:11:04,420
cloud so typically you end up with a CA

00:11:00,970 --> 00:11:09,339
light type of configuring the instances

00:11:04,420 --> 00:11:15,339
of that so this is an intermediate step

00:11:09,339 --> 00:11:18,569
for configuring the environment while in

00:11:15,339 --> 00:11:22,780
namespace you don't have kind of CLI

00:11:18,569 --> 00:11:25,210
island so you go with our API of

00:11:22,780 --> 00:11:30,250
name space capabilities and you do

00:11:25,210 --> 00:11:33,910
whatever you are it is so I'm sure a

00:11:30,250 --> 00:11:35,440
little bit know if I have some more so

00:11:33,910 --> 00:11:39,340
first of all if I have some random

00:11:35,440 --> 00:11:41,530
container that is just a service is

00:11:39,340 --> 00:11:44,350
running in the cloud that one we

00:11:41,530 --> 00:11:46,570
wouldn't have anything to do with our

00:11:44,350 --> 00:11:49,000
audit because we would normally contain

00:11:46,570 --> 00:11:51,550
around a personality and if it is

00:11:49,000 --> 00:11:53,770
completely isolated and does nothing

00:11:51,550 --> 00:11:55,330
then there's also nothing to consider

00:11:53,770 --> 00:11:57,430
here because it's just an isolated

00:11:55,330 --> 00:12:01,660
service the distance completely separate

00:11:57,430 --> 00:12:04,210
copy of paper are if I'm configuring the

00:12:01,660 --> 00:12:06,400
router itself and I want to do we are

00:12:04,210 --> 00:12:09,280
asked in the second to set up I don't

00:12:06,400 --> 00:12:11,380
see a huge difference between issuing a

00:12:09,280 --> 00:12:14,770
bunch of by periodic commands to set up

00:12:11,380 --> 00:12:16,060
that we're at device or a bunch of here

00:12:14,770 --> 00:12:23,770
are commands that set up the network

00:12:16,060 --> 00:12:25,840
make space for this so I don't think any

00:12:23,770 --> 00:12:29,470
of the existing cloud orchestration

00:12:25,840 --> 00:12:32,290
stuff is useful for never make spaces

00:12:29,470 --> 00:12:34,360
that are being used as VRS so the reason

00:12:32,290 --> 00:12:36,910
I say that is in this case it's really

00:12:34,360 --> 00:12:39,190
just a networking space there's no no

00:12:36,910 --> 00:12:42,040
separate classes - no separate whatever

00:12:39,190 --> 00:12:43,780
else may be spacing you have it's it's

00:12:42,040 --> 00:12:48,010
essentially just a separate network

00:12:43,780 --> 00:12:49,420
stack for the same system and I really

00:12:48,010 --> 00:12:52,450
see that as more of a balance actually

00:12:49,420 --> 00:12:55,630
makes things invisible to be experienced

00:12:52,450 --> 00:12:58,600
admins and it also is a much more

00:12:55,630 --> 00:13:00,520
expensive abstraction so that for names

00:12:58,600 --> 00:13:03,130
based on the premise I believe more

00:13:00,520 --> 00:13:04,870
costly than the recognized so I think

00:13:03,130 --> 00:13:06,400
what we did interesting touch one is

00:13:04,870 --> 00:13:08,010
that if you want to have communication

00:13:06,400 --> 00:13:11,730
between

00:13:08,010 --> 00:13:14,380
namespaces you have to actually create a

00:13:11,730 --> 00:13:18,820
tap device that is inserted into each

00:13:14,380 --> 00:13:20,320
side and then that doesn't even count

00:13:18,820 --> 00:13:21,620
them so if you want to start doing a

00:13:20,320 --> 00:13:24,650
Bharathi kind of mission

00:13:21,620 --> 00:13:40,720
early earlier but with the L freedom

00:13:24,650 --> 00:13:40,720
device Dubrovnik is too simple uses I

00:14:01,600 --> 00:14:06,290
mean haven't you given your answer

00:14:03,950 --> 00:14:08,060
yourself I mean as you said right the

00:14:06,290 --> 00:14:10,340
the namespace is originally were meant

00:14:08,060 --> 00:14:11,990
for you know very strict isolation and

00:14:10,340 --> 00:14:14,780
that means you simply run another

00:14:11,990 --> 00:14:16,820
instance of FR right and the fact that

00:14:14,780 --> 00:14:21,170
you know with all type of workaround off

00:14:16,820 --> 00:14:23,270
v ethernet or so the namespaces have in

00:14:21,170 --> 00:14:25,730
the meantime been used for all type of

00:14:23,270 --> 00:14:28,000
crazy things probably had to do with the

00:14:25,730 --> 00:14:30,830
fact that the vrf code came a lot later

00:14:28,000 --> 00:14:33,470
right so now that the vrf code is there

00:14:30,830 --> 00:14:37,820
you know i think it's fairly logical to

00:14:33,470 --> 00:14:40,340
you know constrict FR to support via v

00:14:37,820 --> 00:14:41,720
RFS and then you know the namespace is

00:14:40,340 --> 00:14:43,270
only to the extent that if you're

00:14:41,720 --> 00:14:45,500
starting multiple instances

00:14:43,270 --> 00:14:48,410
independently of each others maybe just

00:14:45,500 --> 00:14:50,390
have global parameters or so which

00:14:48,410 --> 00:14:52,490
namespace therefore which config files

00:14:50,390 --> 00:15:19,000
and so because as you said they don't

00:14:52,490 --> 00:15:19,000
necessarily have a different plan to run

00:15:22,320 --> 00:15:25,499
[Music]

00:15:35,970 --> 00:15:39,009
[Music]

00:15:41,690 --> 00:15:51,000
this is what's been going on DGP said

00:15:48,870 --> 00:15:53,100
I'm sure most of you are aware that it

00:15:51,000 --> 00:15:56,040
contains extremely degraded sensitive

00:15:53,100 --> 00:15:58,410
and one of the things I have been

00:15:56,040 --> 00:16:01,140
thinking about doing was so its current

00:15:58,410 --> 00:16:04,680
behavior in BGP there is some around

00:16:01,140 --> 00:16:09,630
mode which is a data structure be used

00:16:04,680 --> 00:16:12,030
to track around the table BGP has its

00:16:09,630 --> 00:16:19,590
own you may call me DGP node which is

00:16:12,030 --> 00:16:24,780
this device data table is like 17 bytes

00:16:19,590 --> 00:16:27,990
of data and so every state will know in

00:16:24,780 --> 00:16:30,080
a BGP table takes up 160 bytes I have a

00:16:27,990 --> 00:16:33,570
whole BGP feed that's several thousand

00:16:30,080 --> 00:16:37,560
nodes and then the way we structure the

00:16:33,570 --> 00:16:40,050
table data structure and is that there

00:16:37,560 --> 00:16:43,290
is an extra probably 500 thousand nodes

00:16:40,050 --> 00:16:46,350
there are placeholders and then EDP we

00:16:43,290 --> 00:16:48,420
have so we have a GP node for every

00:16:46,350 --> 00:16:52,580
single one of those that's a hundred 60

00:16:48,420 --> 00:16:55,110
bytes versus the 80 bytes and that gets

00:16:52,580 --> 00:16:57,230
that started a whole bunch it's one of

00:16:55,110 --> 00:17:01,170
the things I've been kind of doing is is

00:16:57,230 --> 00:17:03,360
separating out the route new code and

00:17:01,170 --> 00:17:05,880
create a new data structure called b2b

00:17:03,360 --> 00:17:09,990
desk and this is going to follow up the

00:17:05,880 --> 00:17:12,120
same structure that's in zebra for panel

00:17:09,990 --> 00:17:15,000
table sitting zebra has the wrong code

00:17:12,120 --> 00:17:16,260
it's about a pointer to the rib deskey

00:17:15,000 --> 00:17:18,960
so we're going to model that with the

00:17:16,260 --> 00:17:20,910
b2b desk and we don't won't read it need

00:17:18,960 --> 00:17:24,450
to be decimal point unless there is an

00:17:20,910 --> 00:17:25,320
actual BGP data and so it's a that's

00:17:24,450 --> 00:17:26,880
kind of

00:17:25,320 --> 00:17:29,670
when their and the other thing that's

00:17:26,880 --> 00:17:32,880
come up recently is that there is this

00:17:29,670 --> 00:17:35,130
idea of southeast specific or extra

00:17:32,880 --> 00:17:39,440
information that we're sworn and if

00:17:35,130 --> 00:17:42,420
you're doing things like EP ends or if

00:17:39,440 --> 00:17:45,870
you're gonna be piano room flows back

00:17:42,420 --> 00:17:47,130
you'll end up with an extra pointer

00:17:45,870 --> 00:17:48,180
that's probably an extra two or three

00:17:47,130 --> 00:17:51,660
other facts as well

00:17:48,180 --> 00:17:56,340
so the goal from from that perspective

00:17:51,660 --> 00:17:58,500
is that is that if you're doing close

00:17:56,340 --> 00:18:00,810
back on your screen usually flows back

00:17:58,500 --> 00:18:04,020
you don't necessarily rely on external

00:18:00,810 --> 00:18:21,120
VPNs and so what we want to do is break

00:18:04,020 --> 00:18:24,480
up the extra pointer alright so so to

00:18:21,120 --> 00:18:27,600
the thing we'd like to do is break up

00:18:24,480 --> 00:18:33,540
the extra data into sake specific data

00:18:27,600 --> 00:18:35,250
that we can be loaded at runtime and we

00:18:33,540 --> 00:18:41,460
wanted to see if there is any input from

00:18:35,250 --> 00:18:43,560
the the audience here about ways that we

00:18:41,460 --> 00:18:46,950
could possibly bring up the data as well

00:18:43,560 --> 00:18:51,170
if there's been any thought there yeah

00:18:46,950 --> 00:18:51,170
it's the path info extra data

00:18:52,640 --> 00:18:58,340
so yeah speaking from engineer extending

00:18:56,330 --> 00:19:00,620
this is a kind of generic thing that

00:18:58,340 --> 00:19:01,790
everyone it's it's a lot of extra

00:19:00,620 --> 00:19:06,130
information that we need to keep up

00:19:01,790 --> 00:19:08,210
around in some conditional basis well

00:19:06,130 --> 00:19:10,090
once again we need to find a solution

00:19:08,210 --> 00:19:13,580
for it

00:19:10,090 --> 00:19:16,460
so the the curveball verses to create a

00:19:13,580 --> 00:19:19,549
like maybe an array of Safie consecutive

00:19:16,460 --> 00:19:21,740
have pointers that you can ask you that

00:19:19,549 --> 00:19:29,169
you would as you allocate memory for

00:19:21,740 --> 00:19:29,169
that we created that's the direction

00:19:35,049 --> 00:19:38,500
good questions

00:19:40,050 --> 00:19:50,700
okay okay

00:19:56,610 --> 00:20:01,630
mr. question on the previous slide when

00:19:59,470 --> 00:20:04,150
you do this memory rework how much

00:20:01,630 --> 00:20:30,100
memory are you going to save just an

00:20:04,150 --> 00:20:36,250
estimation for say still did not you

00:20:30,100 --> 00:20:39,790
know it's all right I think this new

00:20:36,250 --> 00:20:41,500
activity here our future use this new

00:20:39,790 --> 00:20:44,440
whether the data over here in the

00:20:41,500 --> 00:20:47,770
outside and you have your memories just

00:20:44,440 --> 00:20:49,360
to the roof and so you actually have to

00:20:47,770 --> 00:20:52,840
spend time thinking about

00:20:49,360 --> 00:20:55,870
I don't you structure your data and

00:20:52,840 --> 00:20:57,190
that's kind of the process this is the

00:20:55,870 --> 00:21:01,870
start of that process from our

00:20:57,190 --> 00:21:03,850
perspective you know I know it's not the

00:21:01,870 --> 00:21:05,920
final step I know there's gonna be more

00:21:03,850 --> 00:21:08,490
work there I just know that it's the

00:21:05,920 --> 00:21:08,490
break first

00:21:12,470 --> 00:21:18,610
okay so then come again this is where

00:21:17,330 --> 00:21:21,920
you're going to be a short one but

00:21:18,610 --> 00:21:27,920
here's to ask questions from the game

00:21:21,920 --> 00:21:32,150
our jobs properly our season the art kit

00:21:27,920 --> 00:21:35,360
that I can't pass for a common way of

00:21:32,150 --> 00:21:37,880
configuring and extracting spades from

00:21:35,360 --> 00:21:40,280
network devices basically it's the

00:21:37,880 --> 00:21:45,410
successor to XMP hopefully it's gonna

00:21:40,280 --> 00:21:51,050
cyclists with air support or internet

00:21:45,410 --> 00:21:54,290
for our four ribbon GE and I guess all

00:21:51,050 --> 00:21:58,580
of them use custom models so they don't

00:21:54,290 --> 00:22:06,070
use any of the IDF standardized models

00:21:58,580 --> 00:22:15,620
but that's step 2 they're basically just

00:22:06,070 --> 00:22:29,810
anyone has any questions oh you did the

00:22:15,620 --> 00:22:33,530
initial work for I'm not actually

00:22:29,810 --> 00:22:35,930
pregnant where any way of doing specific

00:22:33,530 --> 00:22:39,260
work this one time I think it's from

00:22:35,930 --> 00:22:41,630
from a TSE perspective I think it's just

00:22:39,260 --> 00:22:45,340
a matter of having a need for it

00:22:41,630 --> 00:22:45,340
I never companies are interested

00:22:46,930 --> 00:22:56,910
I haven't looked at that coat but would

00:22:51,340 --> 00:23:58,390
be interesting to understand if you know

00:22:56,910 --> 00:23:59,980
you know if you're in training in for

00:23:58,390 --> 00:24:02,080
monitoring like you know route change

00:23:59,980 --> 00:24:05,530
trekking or something like that then if

00:24:02,080 --> 00:24:07,210
you looked into young push yeah so

00:24:05,530 --> 00:24:09,310
because I mean that's kind of the yang

00:24:07,210 --> 00:24:12,010
framework that you may want to use to

00:24:09,310 --> 00:24:17,020
set up you know ongoing recurring you

00:24:12,010 --> 00:24:18,730
know data being sent back on whether net

00:24:17,020 --> 00:24:20,260
converse actually the best transport for

00:24:18,730 --> 00:24:24,730
that is yet another question right but

00:24:20,260 --> 00:24:27,030
in the end I think the first thing you

00:24:24,730 --> 00:24:27,030
want to

00:24:53,110 --> 00:25:00,890
so what is the status of the

00:24:57,050 --> 00:25:05,270
implementation yet and is it just you

00:25:00,890 --> 00:25:07,580
have tried something but it's not for

00:25:05,270 --> 00:25:09,830
example you cannot still configure

00:25:07,580 --> 00:25:12,680
through Annette coffee yet or it

00:25:09,830 --> 00:25:16,540
something is there but there's not so

00:25:12,680 --> 00:25:16,540
much implemented or what is this

00:25:32,350 --> 00:25:38,120
infrastructure support net Coleman

00:25:34,730 --> 00:25:40,790
Rascon and for that we have modules to

00:25:38,120 --> 00:25:44,420
integrate with both confidence is arepo'

00:25:40,790 --> 00:25:46,550
which are two different projects so as

00:25:44,420 --> 00:25:48,860
of now you can configure in Mart or fr

00:25:46,550 --> 00:25:52,880
using that conference call if you use

00:25:48,860 --> 00:25:55,130
these modules and basically the only

00:25:52,880 --> 00:25:56,600
issues that only a few demons working

00:25:55,130 --> 00:26:00,650
for that use this new infrastructure

00:25:56,600 --> 00:26:03,620
which were RIPTA with ng D and is SD by

00:26:00,650 --> 00:26:06,170
the manual so the goal in long term is

00:26:03,620 --> 00:26:09,740
to convert the remaining demons to use a

00:26:06,170 --> 00:26:11,900
yang modeling and and that's it it works

00:26:09,740 --> 00:26:14,210
now we have the whole infrastructure but

00:26:11,900 --> 00:26:17,660
it's only a matter of converting the

00:26:14,210 --> 00:26:20,480
rest demons so everything of a part can

00:26:17,660 --> 00:26:24,679
be can be configured in Mart or using

00:26:20,480 --> 00:26:27,740
that conf or whatever else and also and

00:26:24,679 --> 00:26:31,880
beyond that countin Rascon we also have

00:26:27,740 --> 00:26:35,630
a new jar PC model which can use to

00:26:31,880 --> 00:26:38,270
configure and monitor fr and we support

00:26:35,630 --> 00:26:41,059
both confirmation operational data our

00:26:38,270 --> 00:26:46,190
PCs and notifications so the whole

00:26:41,059 --> 00:26:52,400
package is supported so for the model

00:26:46,190 --> 00:26:55,560
itself re using kind of ITF based model

00:26:52,400 --> 00:26:57,670
or which are we using it

00:26:55,560 --> 00:27:00,010
everyone asked this question why you

00:26:57,670 --> 00:27:02,320
were using native models instead of

00:27:00,010 --> 00:27:06,730
using standard models so the thing is

00:27:02,320 --> 00:27:09,490
that the fr codebase is huge and convert

00:27:06,730 --> 00:27:11,350
them to use the yang infrastructure is

00:27:09,490 --> 00:27:13,750
already a huge challenge it requires

00:27:11,350 --> 00:27:15,850
lots of changes in code and we think

00:27:13,750 --> 00:27:19,180
that doing everything in a single step

00:27:15,850 --> 00:27:21,580
will be too much work too much changes

00:27:19,180 --> 00:27:25,720
in one time and it could lead to lots of

00:27:21,580 --> 00:27:28,090
birds so we decide to split this work

00:27:25,720 --> 00:27:31,600
and ensure different steps and the first

00:27:28,090 --> 00:27:36,300
step is to just convert the existence of

00:27:31,600 --> 00:27:41,080
like comments to like - - how can I say

00:27:36,300 --> 00:27:43,960
we can map the existing comments to a

00:27:41,080 --> 00:27:47,170
young model and then in the second step

00:27:43,960 --> 00:27:56,350
the idea is to effectively try to

00:27:47,170 --> 00:27:59,710
support the standard models natively v8

00:27:56,350 --> 00:28:02,440
models don't always reflect puranas

00:27:59,710 --> 00:28:04,750
abilities we have some features and

00:28:02,440 --> 00:28:08,560
functionality that are not in the

00:28:04,750 --> 00:28:11,800
standard models and and given the choice

00:28:08,560 --> 00:28:14,740
between dropping that functionality

00:28:11,800 --> 00:28:17,290
versus creating our own we're gonna be

00:28:14,740 --> 00:28:21,790
rough is what it will stuff do I'm not

00:28:17,290 --> 00:28:25,200
gonna be tied down by the community I

00:28:21,790 --> 00:28:29,580
don't believe should be tied down by the

00:28:25,200 --> 00:28:29,580
limited functionality models

00:28:31,070 --> 00:28:38,250
okay I think I agree that I think the

00:28:34,590 --> 00:29:12,720
standard is for if they're same thing if

00:28:38,250 --> 00:29:14,940
not the standard model so the my

00:29:12,720 --> 00:29:18,030
rationale for supporting this approach

00:29:14,940 --> 00:29:21,690
is that it is much easier to create an

00:29:18,030 --> 00:29:25,280
exact mapping off our stabilities began

00:29:21,690 --> 00:29:29,429
as a first step and then have a layer

00:29:25,280 --> 00:29:32,490
that just translates from one yellow to

00:29:29,429 --> 00:29:34,559
the proper standardized one and at that

00:29:32,490 --> 00:29:37,950
point since you're operating between the

00:29:34,559 --> 00:29:41,460
animals the the choice of tooling is

00:29:37,950 --> 00:29:44,460
much more why we can just I don't know

00:29:41,460 --> 00:29:45,929
leave leave see behind for example

00:29:44,460 --> 00:29:47,550
because C's look exactly the best

00:29:45,929 --> 00:29:55,260
language to do configuration

00:29:47,550 --> 00:29:58,800
manipulations like that and it can just

00:29:55,260 --> 00:30:00,690
be and it's I personally I definitely

00:29:58,800 --> 00:30:04,830
want to have support for respect for the

00:30:00,690 --> 00:30:06,780
standards most never are and in some

00:30:04,830 --> 00:30:09,210
cases I think there's another case we

00:30:06,780 --> 00:30:12,420
also don't quite support as much as what

00:30:09,210 --> 00:30:16,170
needs to make sense which is a bigger

00:30:12,420 --> 00:30:19,040
problem than the other way around but

00:30:16,170 --> 00:30:19,040
yeah

00:30:23,019 --> 00:30:33,919
you know actually I was impressed that

00:30:29,619 --> 00:30:36,889
this is a very simple function and just

00:30:33,919 --> 00:30:38,659
the slightest balls the API functions

00:30:36,889 --> 00:30:43,609
and it just a reverse to get the data

00:30:38,659 --> 00:30:50,299
out yeah the mobile lists are specific

00:30:43,609 --> 00:30:52,819
currently if I just I mean you should

00:30:50,299 --> 00:30:54,739
never feel confined by you know the IETF

00:30:52,819 --> 00:30:56,899
standards models right I mean it's a

00:30:54,739 --> 00:30:59,269
committee process it's basically lowest

00:30:56,899 --> 00:31:01,190
common denominator right so if not the

00:30:59,269 --> 00:31:03,349
majority of vendors implement something

00:31:01,190 --> 00:31:05,209
then basically it's not in the egg model

00:31:03,349 --> 00:31:07,429
so it's perfectly fine to do your own

00:31:05,209 --> 00:31:08,869
Jang model except for you know if you're

00:31:07,429 --> 00:31:12,559
doing something that's actually in some

00:31:08,869 --> 00:31:16,369
ITF RFC's and it's a standard thing and

00:31:12,559 --> 00:31:17,869
it's not in the ITF standard yang model

00:31:16,369 --> 00:31:20,029
then that yang model needs to be

00:31:17,869 --> 00:31:24,339
extended as opposed I mean that would be

00:31:20,029 --> 00:31:24,339
more work for you but always encouraged

00:31:28,899 --> 00:31:35,659
kind of a two questions is there concern

00:31:32,690 --> 00:31:37,489
that from a a protocol implementation

00:31:35,659 --> 00:31:39,409
for yang right now like the the

00:31:37,489 --> 00:31:41,719
implementations that are there that

00:31:39,409 --> 00:31:43,399
there will be let's say there's no

00:31:41,719 --> 00:31:45,019
interested party and adding it to be GP

00:31:43,399 --> 00:31:46,489
or OSPF right something along those

00:31:45,019 --> 00:31:50,059
lines so you're gonna have feature

00:31:46,489 --> 00:31:51,379
divergence within FR routing about what

00:31:50,059 --> 00:31:53,179
protocol you're using whether you can

00:31:51,379 --> 00:31:55,819
use it or not and then kind of the

00:31:53,179 --> 00:31:58,249
follow up to that is is there going to

00:31:55,819 --> 00:32:00,379
be a requirement for new features that

00:31:58,249 --> 00:32:17,539
are added that they're compliant or that

00:32:00,379 --> 00:32:21,639
they include the yang hoax as well I you

00:32:17,539 --> 00:32:21,639
know I said that there's I'm not aware

00:32:21,870 --> 00:32:28,320
I am aware people planning to do things

00:32:25,620 --> 00:32:31,289
like using that company into the future

00:32:28,320 --> 00:32:33,690
December got to be it and so I don't

00:32:31,289 --> 00:32:35,429
want to be up here saying company

00:32:33,690 --> 00:32:36,990
accident if you do that when they

00:32:35,429 --> 00:32:44,490
haven't announced it himself

00:32:36,990 --> 00:32:45,779
so that's kind of just about yeah I was

00:32:44,490 --> 00:32:48,539
gonna marry yes

00:32:45,779 --> 00:33:03,419
new features should probably use net

00:32:48,539 --> 00:33:05,039
copy an existing feature function and

00:33:03,419 --> 00:33:07,350
maybe you know for the standards bodies

00:33:05,039 --> 00:33:15,240
that was more of a should shall must

00:33:07,350 --> 00:33:28,100
type declaration act between for you

00:33:15,240 --> 00:33:43,320
verses that's okay okay

00:33:28,100 --> 00:33:54,090
so this is one of my peeps let's just

00:33:43,320 --> 00:33:58,260
say most of them so we basically have an

00:33:54,090 --> 00:34:01,679
ongoing effort to try and make our API

00:33:58,260 --> 00:34:04,409
is to suck less there's really stupid

00:34:01,679 --> 00:34:06,870
things in there like our hash table

00:34:04,409 --> 00:34:09,450
implementation uses a separate piece of

00:34:06,870 --> 00:34:11,369
memory with three pointers for each

00:34:09,450 --> 00:34:14,280
entry that just has next pointer in the

00:34:11,369 --> 00:34:15,159
data folder and that's really not what I

00:34:14,280 --> 00:34:17,679
notice you

00:34:15,159 --> 00:34:21,879
that load into the data structures on

00:34:17,679 --> 00:34:24,309
the patents and we've also grown

00:34:21,879 --> 00:34:28,259
somewhat concerned about safety of our

00:34:24,309 --> 00:34:30,700
API for human consumption so to speak

00:34:28,259 --> 00:34:33,789
there are quite a few pitfalls in the

00:34:30,700 --> 00:34:36,399
codebase where it's just far too easy to

00:34:33,789 --> 00:34:38,470
do something wrong and the only noticed

00:34:36,399 --> 00:34:44,409
a year later and it explodes on some

00:34:38,470 --> 00:34:46,359
installation that yeah one of the raid

00:34:44,409 --> 00:34:51,460
related topics is that we currently have

00:34:46,359 --> 00:34:54,129
a relatively strict procedure for

00:34:51,460 --> 00:34:57,339
getting rid of of old features there is

00:34:54,129 --> 00:35:02,799
a when we like a year to a year of the

00:34:57,339 --> 00:35:05,950
application period which is something

00:35:02,799 --> 00:35:10,420
that might be worth evaluating a logo or

00:35:05,950 --> 00:35:12,099
our document does say that in cases

00:35:10,420 --> 00:35:14,589
where it's not viable to keep the

00:35:12,099 --> 00:35:19,119
backwards compatibility and we will just

00:35:14,589 --> 00:35:22,180
drop it immediately but I don't think we

00:35:19,119 --> 00:35:24,970
have enough for our active contributors

00:35:22,180 --> 00:35:27,490
here to actively discuss procedure so

00:35:24,970 --> 00:35:32,380
let's talk about a seizure also it's

00:35:27,490 --> 00:35:38,380
boring and there's also that since we're

00:35:32,380 --> 00:35:42,009
growing more into a direction that it's

00:35:38,380 --> 00:35:45,549
it's becoming useful to apply concepts

00:35:42,009 --> 00:35:47,380
of immutability to to places where it's

00:35:45,549 --> 00:35:52,900
possible like like you to get new

00:35:47,380 --> 00:35:54,819
structures so the way of the kernel is

00:35:52,900 --> 00:35:59,440
in a lot of places where an object is

00:35:54,819 --> 00:36:02,470
allocated and after it's released in the

00:35:59,440 --> 00:36:04,150
Garcias amenities updated anymore and

00:36:02,470 --> 00:36:07,509
you just copy the entire thing if you

00:36:04,150 --> 00:36:09,730
need to change something and we are well

00:36:07,509 --> 00:36:13,869
I'm trying to get that into it for ours

00:36:09,730 --> 00:36:16,420
well doing doing filler so you can use

00:36:13,869 --> 00:36:18,250
spaces may be a bit of a far reach I

00:36:16,420 --> 00:36:19,630
don't know if anyone has any opinions

00:36:18,250 --> 00:36:23,559
about that that would be

00:36:19,630 --> 00:36:27,069
after vehicle as well other than that

00:36:23,559 --> 00:36:30,099
this is also just say well things are

00:36:27,069 --> 00:36:34,569
getting done slight I'm happy to take

00:36:30,099 --> 00:36:43,599
complaints about the mobility any

00:36:34,569 --> 00:36:46,329
related questions is that from our

00:36:43,599 --> 00:36:49,749
perspective the api's shouldn't be

00:36:46,329 --> 00:36:53,049
written in a way that allows you to make

00:36:49,749 --> 00:36:56,079
mistakes and that is a common theme with

00:36:53,049 --> 00:36:59,529
our current Lib directory is that it's

00:36:56,079 --> 00:37:01,479
very easy to intrude releases to do

00:36:59,529 --> 00:37:04,739
things that are both stupid and

00:37:01,479 --> 00:37:07,599
dangerous and so from my perspective I

00:37:04,739 --> 00:37:11,049
want to encourage people to spend time

00:37:07,599 --> 00:37:14,140
thinking about the API and how it can be

00:37:11,049 --> 00:37:16,180
used in a way that won't cause you to

00:37:14,140 --> 00:37:18,400
shoot up so I'm going to kind of say

00:37:16,180 --> 00:37:20,079
that but it's really important to me and

00:37:18,400 --> 00:37:21,940
I mean when people make changes to the

00:37:20,079 --> 00:37:24,640
little bit record that's the things I'm

00:37:21,940 --> 00:37:27,699
looking to happen even code in spent

00:37:24,640 --> 00:37:29,829
time think about is is how how we maybe

00:37:27,699 --> 00:37:32,160
is misuse this and how we can better

00:37:29,829 --> 00:37:32,160
shape

00:37:39,859 --> 00:37:50,099
well in some cases we can test things

00:37:48,809 --> 00:37:53,339
because we don't know how they're

00:37:50,099 --> 00:37:59,940
supposed to work which is one of our

00:37:53,339 --> 00:38:02,640
great situation via if people took ebay

00:37:59,940 --> 00:38:06,710
capi is protocol that we have between

00:38:02,640 --> 00:38:09,660
our various routing protocols the zebra

00:38:06,710 --> 00:38:13,950
centralized team that integrates all the

00:38:09,660 --> 00:38:16,369
configuration at Rodney that's right and

00:38:13,950 --> 00:38:18,480
there's essentially very little

00:38:16,369 --> 00:38:22,369
specification about how that's supposed

00:38:18,480 --> 00:38:22,369
to work especially for our cases

00:38:23,210 --> 00:38:32,789
documentation it's scarce and if we do

00:38:30,510 --> 00:38:37,289
well there are some questions here on

00:38:32,789 --> 00:38:39,289
how we're to document best that also

00:38:37,289 --> 00:38:43,079
extends to all users of implementation

00:38:39,289 --> 00:38:45,420
if if you remember the Yang's like the

00:38:43,079 --> 00:38:46,950
encode I had earlier you can see we have

00:38:45,420 --> 00:38:48,869
this you found the same you know source

00:38:46,950 --> 00:38:53,759
code each of which defines his new life

00:38:48,869 --> 00:38:55,589
function it's certainly possibility to

00:38:53,759 --> 00:38:58,890
put the documentation right there at the

00:38:55,589 --> 00:39:02,369
code which would improve our well member

00:38:58,890 --> 00:39:05,099
into updated maybe change the code I'm

00:39:02,369 --> 00:39:07,829
hopefully I again things that we didn't

00:39:05,099 --> 00:39:10,259
quite have enough for our active

00:39:07,829 --> 00:39:13,410
contributors here to really discuss this

00:39:10,259 --> 00:39:23,549
but if anyone has any food or comments

00:39:13,410 --> 00:39:27,089
on this so to further is all the cool

00:39:23,549 --> 00:39:32,220
bus change in CLI you're not that dated

00:39:27,089 --> 00:39:34,279
documentation and if you're at a new

00:39:32,220 --> 00:40:16,319
function

00:39:34,279 --> 00:40:19,440
so are you asking for someone who can

00:40:16,319 --> 00:40:22,589
document the existing API or are you

00:40:19,440 --> 00:40:33,599
asking the who writes a new code to

00:40:22,589 --> 00:40:37,109
write document properly but both years

00:40:33,599 --> 00:40:40,979
of history and for a long time it was

00:40:37,109 --> 00:40:42,900
okay to add a new feature and so we

00:40:40,979 --> 00:40:45,930
there are hundreds literally hundreds of

00:40:42,900 --> 00:40:51,140
features that people don't know about me

00:40:45,930 --> 00:40:51,140
I still find new features by the code

00:40:52,009 --> 00:40:58,229
and only way I knew about it was I

00:40:55,469 --> 00:41:03,630
happen to read that line of code that's

00:40:58,229 --> 00:41:07,619
it oh so so it's great that people buy

00:41:03,630 --> 00:41:09,089
the features and really just has a lot

00:41:07,619 --> 00:41:13,079
of features that people don't know about

00:41:09,089 --> 00:41:16,650
our views necessarily but not everyone

00:41:13,079 --> 00:41:19,130
reads code not every operator has the

00:41:16,650 --> 00:41:19,130
interest

00:41:19,799 --> 00:41:28,019
the ability to no it's just it's just

00:42:00,359 --> 00:42:38,170
the way any any current people want to

00:42:25,210 --> 00:42:40,809
know what the user is terrified by since

00:42:38,170 --> 00:42:44,619
you seem to be asking for operators so

00:42:40,809 --> 00:42:46,599
we an operator we run FRR as part of

00:42:44,619 --> 00:42:50,349
kumis Linux in our data center networks

00:42:46,599 --> 00:42:55,469
and so my team people don't generally

00:42:50,349 --> 00:43:00,039
have a traditional CLI background

00:42:55,469 --> 00:43:04,089
personally I do have that and I I feel

00:43:00,039 --> 00:43:07,869
very comfortable looking at things in in

00:43:04,089 --> 00:43:09,729
FRR now it's it's very like the old ways

00:43:07,869 --> 00:43:11,559
at the same time we provision everything

00:43:09,729 --> 00:43:15,579
using ansible and templates that works

00:43:11,559 --> 00:43:19,839
fine too and it's it's a nice mix of

00:43:15,579 --> 00:43:23,289
those words yeah I also I would like to

00:43:19,839 --> 00:43:26,079
thank you for for doing this because we

00:43:23,289 --> 00:43:26,499
started when our software vendor still

00:43:26,079 --> 00:43:28,390
used

00:43:26,499 --> 00:43:31,839
quagga and

00:43:28,390 --> 00:43:37,569
it's really improved the whole usability

00:43:31,839 --> 00:43:40,660
and of the system is Reve getting much

00:43:37,569 --> 00:43:42,940
nicer that's so yeah big big kudos to

00:43:40,660 --> 00:43:46,119
all the people involved here so we use

00:43:42,940 --> 00:43:49,480
mostly BGP for the classically spying

00:43:46,119 --> 00:43:50,890
data center network including the

00:43:49,480 --> 00:43:54,700
service it's also a nice thing because

00:43:50,890 --> 00:43:57,069
we run the same software well sometimes

00:43:54,700 --> 00:44:00,460
different versions whatever we get from

00:43:57,069 --> 00:44:02,170
a vendor or upstream on the service and

00:44:00,460 --> 00:44:04,299
then on the switches it's nice in our

00:44:02,170 --> 00:44:08,920
case we provision them using the same

00:44:04,299 --> 00:44:10,960
system sometimes same templates we do

00:44:08,920 --> 00:44:14,440
have sometimes regressions like right

00:44:10,960 --> 00:44:17,529
now we have a funny bug when we upgraded

00:44:14,440 --> 00:44:19,089
the root oo as our BGP pairings all the

00:44:17,529 --> 00:44:22,119
routes were no long I accept it because

00:44:19,089 --> 00:44:23,799
we were configuring some I know global

00:44:22,119 --> 00:44:27,490
ipv6 addresses where they were not

00:44:23,799 --> 00:44:30,279
expected but I mean it's just things

00:44:27,490 --> 00:44:32,230
that happen we have to learn how to how

00:44:30,279 --> 00:44:34,359
to navigate these changes we are not

00:44:32,230 --> 00:44:36,160
using upstream FRR maybe maybe we could

00:44:34,359 --> 00:44:39,519
I don't know how realistic that is on

00:44:36,160 --> 00:44:45,039
the switches we're using generally what

00:44:39,519 --> 00:44:48,099
we get from the vendor and yeah as I

00:44:45,039 --> 00:44:50,170
said I'm fairly happy it's it's gotten

00:44:48,099 --> 00:44:53,589
much much closer to something that I

00:44:50,170 --> 00:44:55,569
would like suggest my my former

00:44:53,589 --> 00:44:58,589
colleagues who still work with Cisco to

00:44:55,569 --> 00:45:05,079
look at as something that is actually

00:44:58,589 --> 00:45:07,180
usable so yeah yeah yeah the the so

00:45:05,079 --> 00:45:09,369
these people might in my former team

00:45:07,180 --> 00:45:13,000
they look more at things like net comp

00:45:09,369 --> 00:45:15,789
and yang and new practices so yeah I'd I

00:45:13,000 --> 00:45:17,769
think I'd like to echo for them that

00:45:15,789 --> 00:45:20,079
this is an interesting feel and of

00:45:17,769 --> 00:45:24,130
course it would be nice if you could try

00:45:20,079 --> 00:45:26,200
to embrace these on standards schemas

00:45:24,130 --> 00:45:29,619
like what the ITF produces also what I

00:45:26,200 --> 00:45:32,079
think open config produces it's it seems

00:45:29,619 --> 00:45:34,450
to be very influential and maybe more

00:45:32,079 --> 00:45:36,730
comprehensive that then what

00:45:34,450 --> 00:45:38,890
idea of kanji process actually I

00:45:36,730 --> 00:45:40,180
absolutely agree and again this is just

00:45:38,890 --> 00:45:43,320
the one step at a time

00:45:40,180 --> 00:45:43,320
[Music]

00:45:55,500 --> 00:45:58,800

YouTube URL: https://www.youtube.com/watch?v=SiIMN7hq1wc


