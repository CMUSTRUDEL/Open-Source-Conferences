Title: Netdev 0.1 - Distributing TC Classifier Action
Publication date: 2015-03-21
Playlist: Netdev 0.1 - Day 4 - Tuesday February 16, 2015
Description: 
	Distributing TC Classifier Action
Jamal Hadi Salim and Damascene M. Joachimpillai
February 2015

Description from netdev01.org:
  This proposal will discuss distributing the Linux Traffic Control (tc) filter-action subsystem packet processing across disparate nodes. The nodes could be a mix and match of containers, VMs, bare metal machines or ASICs.

A new tc Inter-Forwarding Engine (IFE) action is introduced based on ForCES WG Inter-FE LFB work (https://datatracker.ietf.org/doc/draft-ietf-forces-interfelfb/). The paper will go into both the implementation as well as the usage of the IFE tc action. Details on how to add new extensions to the IFE action will also be discussed.

https://www.netdev01.org

This video is licensed under Creative Commons Attribution-ShareAlike 4.0 International license. Feel free to download and distribute.
Captions: 
	00:00:06,259 --> 00:00:10,769
so I just finish this slides five

00:00:09,300 --> 00:00:14,490
minutes I think I finished them five

00:00:10,769 --> 00:00:18,900
minutes ago there's a paper so anything

00:00:14,490 --> 00:00:22,859
I'm missing from here you can glean off

00:00:18,900 --> 00:00:24,630
the paper this work actually the source

00:00:22,859 --> 00:00:29,010
of this work is forces working group of

00:00:24,630 --> 00:00:30,240
the ITF my cohort is DJ I know he missed

00:00:29,010 --> 00:00:37,980
his flight so he must be sitting

00:00:30,240 --> 00:00:41,309
somewhere here so let me just jump the

00:00:37,980 --> 00:00:43,649
basic premise is you start with and I'm

00:00:41,309 --> 00:00:47,610
not going into how what this graph is

00:00:43,649 --> 00:00:49,800
supposed to be so you start to say a

00:00:47,610 --> 00:00:51,539
policy graph of some phone you know

00:00:49,800 --> 00:00:55,559
here's a classifier followed by a series

00:00:51,539 --> 00:00:57,690
of actions with branches etc so if I

00:00:55,559 --> 00:01:00,239
have a TC classifier action that looks

00:00:57,690 --> 00:01:02,010
like that I'm not going into details of

00:01:00,239 --> 00:01:04,080
what each of these blobs is but it could

00:01:02,010 --> 00:01:07,500
be a classifier or an action right

00:01:04,080 --> 00:01:10,590
that's the starting point I can take

00:01:07,500 --> 00:01:13,229
that so sometimes the main problem is I

00:01:10,590 --> 00:01:17,820
have a machine that's slow this doesn't

00:01:13,229 --> 00:01:22,409
scale and slow is relative if I want to

00:01:17,820 --> 00:01:25,350
do a million flows and an x86 doesn't

00:01:22,409 --> 00:01:27,240
cut it anymore I would like not to be

00:01:25,350 --> 00:01:29,250
able to change the policies but rather

00:01:27,240 --> 00:01:33,000
scale by adding horizontally another

00:01:29,250 --> 00:01:35,600
machine that's one of the use cases so

00:01:33,000 --> 00:01:38,280
what you do is you take this graph and

00:01:35,600 --> 00:01:40,350
from a policy perspective decide I want

00:01:38,280 --> 00:01:44,340
to chop it off maybe right here and move

00:01:40,350 --> 00:01:45,869
this to another machine right so while I

00:01:44,340 --> 00:01:47,399
say it's a machine and it's actually my

00:01:45,869 --> 00:01:50,000
test cases not typically involve

00:01:47,399 --> 00:01:52,799
containers I have container one

00:01:50,000 --> 00:01:54,750
container two and I can chain them I can

00:01:52,799 --> 00:01:58,170
have this could be an if-else another

00:01:54,750 --> 00:02:02,640
container over there I have a small

00:01:58,170 --> 00:02:05,280
diagram I'm going to show so the so as

00:02:02,640 --> 00:02:09,530
you can see this diagram is actually now

00:02:05,280 --> 00:02:09,530
chopped with the two

00:02:10,259 --> 00:02:17,370
these three items here in the Triangle

00:02:14,099 --> 00:02:21,030
move to another machine so that's the

00:02:17,370 --> 00:02:26,549
whole purpose of this for this to work

00:02:21,030 --> 00:02:29,310
you need to be able to take packet data

00:02:26,549 --> 00:02:34,920
as well as packet metadata that's

00:02:29,310 --> 00:02:38,659
internal to Linux so for example so for

00:02:34,920 --> 00:02:41,489
example things as simple as skb marks or

00:02:38,659 --> 00:02:43,680
contract values of some form or other

00:02:41,489 --> 00:02:46,260
and you want to make sure that they go

00:02:43,680 --> 00:02:48,900
on the wire right there so when they

00:02:46,260 --> 00:02:50,700
come in over here you strip them off

00:02:48,900 --> 00:02:52,290
attach them to the s kbe

00:02:50,700 --> 00:02:55,230
or to the contract or to whatever

00:02:52,290 --> 00:02:56,879
internal structure and then the graph

00:02:55,230 --> 00:03:01,349
proceeds internally as if it was

00:02:56,879 --> 00:03:03,569
initiated in the same machine right so

00:03:01,349 --> 00:03:05,579
in order for that to work you need to be

00:03:03,569 --> 00:03:06,840
able to distribute metadata as well as

00:03:05,579 --> 00:03:10,170
you need to make sure that the number of

00:03:06,840 --> 00:03:13,230
edges and the node vertices on each node

00:03:10,170 --> 00:03:16,459
vertex don't change by that I mean if

00:03:13,230 --> 00:03:19,980
you look at any of these colored nodes

00:03:16,459 --> 00:03:23,099
whatever vertices whatever ages that

00:03:19,980 --> 00:03:26,040
existed before don't change so let's

00:03:23,099 --> 00:03:28,109
just pick one for example this guy there

00:03:26,040 --> 00:03:29,970
was something coming in something that

00:03:28,109 --> 00:03:32,190
may have branched to the yellow node or

00:03:29,970 --> 00:03:35,940
may have branched to this colorful node

00:03:32,190 --> 00:03:38,699
here go back you can see yes there's

00:03:35,940 --> 00:03:40,739
something coming in from the red guy and

00:03:38,699 --> 00:03:42,900
something going to the yellow and to

00:03:40,739 --> 00:03:47,190
this guy right so you want to maintain

00:03:42,900 --> 00:03:49,620
the age the ages to the node just simple

00:03:47,190 --> 00:03:51,239
graph theory and you want to maintain

00:03:49,620 --> 00:03:53,489
the number of vertices that are

00:03:51,239 --> 00:03:58,049
connected this guy they have to be the

00:03:53,489 --> 00:04:00,599
same right so those are the two

00:03:58,049 --> 00:04:05,970
requirements and they're met by this TC

00:04:00,599 --> 00:04:07,409
action basically this was the main use

00:04:05,970 --> 00:04:10,699
case that we were going after like I

00:04:07,409 --> 00:04:13,500
said we wanted to systolic lis

00:04:10,699 --> 00:04:15,780
horizontally scale the processing this

00:04:13,500 --> 00:04:19,349
is packet processing typically within

00:04:15,780 --> 00:04:21,049
the same frame or chassis or room not to

00:04:19,349 --> 00:04:23,940
say that this could not be used across

00:04:21,049 --> 00:04:25,950
networks but it's intended to be

00:04:23,940 --> 00:04:29,190
within the scope of a single domain

00:04:25,950 --> 00:04:30,270
right so you have packets coming in and

00:04:29,190 --> 00:04:33,150
then you decide okay I'm gonna keep

00:04:30,270 --> 00:04:35,940
adding new boards over here right so the

00:04:33,150 --> 00:04:37,860
IFE action sits and this is a simple

00:04:35,940 --> 00:04:40,860
graph which shows just piping of actions

00:04:37,860 --> 00:04:43,430
and classifies but nothing stopping you

00:04:40,860 --> 00:04:46,410
from having branches there or loops even

00:04:43,430 --> 00:04:47,880
so it comes to the IFE action which then

00:04:46,410 --> 00:04:50,190
distributes it across different nodes

00:04:47,880 --> 00:04:53,130
and of course you could build you could

00:04:50,190 --> 00:04:54,840
keep scaling your load balancing

00:04:53,130 --> 00:04:59,160
algorithm or whatever is built into your

00:04:54,840 --> 00:05:03,750
policy that programs the IFE and the

00:04:59,160 --> 00:05:05,400
return path and your responses could be

00:05:03,750 --> 00:05:07,470
coming back the same way they get

00:05:05,400 --> 00:05:12,740
demultiplex demultiplex and go back

00:05:07,470 --> 00:05:12,740
there does that make sense any questions

00:05:12,830 --> 00:05:20,910
ok so so well I showed that what we our

00:05:18,450 --> 00:05:22,650
main interest was in systolic processing

00:05:20,910 --> 00:05:25,710
like you know we want to scale we want

00:05:22,650 --> 00:05:27,120
to just keep adding blades and I use the

00:05:25,710 --> 00:05:28,680
same policies everywhere it's

00:05:27,120 --> 00:05:32,310
transparent to the user and I'm just

00:05:28,680 --> 00:05:35,880
scaling by getting more compute results

00:05:32,310 --> 00:05:39,390
out of plaster of these things there are

00:05:35,880 --> 00:05:41,070
the use cases one is I am in for

00:05:39,390 --> 00:05:45,770
encoding for example you may want to

00:05:41,070 --> 00:05:50,400
trace a flow so you can attach to it a

00:05:45,770 --> 00:05:53,960
debug information or you may want to do

00:05:50,400 --> 00:05:59,790
exception service handling for example

00:05:53,960 --> 00:06:01,800
vx LAN service exception handling

00:05:59,790 --> 00:06:03,230
basically you may want to do

00:06:01,800 --> 00:06:05,250
authentication and authorization

00:06:03,230 --> 00:06:08,430
information you may want encode that in

00:06:05,250 --> 00:06:10,770
there send something to some packets to

00:06:08,430 --> 00:06:15,300
a quarantine note that the invalidates

00:06:10,770 --> 00:06:17,669
them in and systemically keep adding

00:06:15,300 --> 00:06:19,440
this info and authorizing the packets

00:06:17,669 --> 00:06:22,980
across the node and then you install a

00:06:19,440 --> 00:06:24,840
rule to bypass the authentication you

00:06:22,980 --> 00:06:27,000
could just have versioning in for that

00:06:24,840 --> 00:06:30,120
lock this other guys running version 0.1

00:06:27,000 --> 00:06:31,560
you're running zero to compliance info

00:06:30,120 --> 00:06:33,270
again it's probably related to the

00:06:31,560 --> 00:06:35,610
authentication authorization where you

00:06:33,270 --> 00:06:36,790
quarantine some packets until you happy

00:06:35,610 --> 00:06:40,270
with them then you remove the

00:06:36,790 --> 00:06:42,250
for them I'm sure there's other use

00:06:40,270 --> 00:06:47,950
cases but these are ones I've come

00:06:42,250 --> 00:06:51,610
across ok so how do you set up this this

00:06:47,950 --> 00:06:55,210
action one way so you need two nodes if

00:06:51,610 --> 00:06:57,810
I go back to this diagram here you see

00:06:55,210 --> 00:07:01,000
there's an there's a source node on the

00:06:57,810 --> 00:07:03,430
egress port of that source node you

00:07:01,000 --> 00:07:05,770
attach an IFV action and all the ingress

00:07:03,430 --> 00:07:12,250
cue discs of this node you attach

00:07:05,770 --> 00:07:17,980
another IV action so essentially this TC

00:07:12,250 --> 00:07:20,320
rule shows the egress side you basically

00:07:17,980 --> 00:07:23,140
match and I have a test case that I used

00:07:20,320 --> 00:07:27,820
typically run with ICMP so I'm gonna

00:07:23,140 --> 00:07:31,120
match on if I see any IP packet protocol

00:07:27,820 --> 00:07:34,050
10 I give it a priority of 10 I'm gonna

00:07:31,120 --> 00:07:36,520
match for IP protocol 1 which is ICMP

00:07:34,050 --> 00:07:38,110
and I'm gonna run a bunch of actions but

00:07:36,520 --> 00:07:41,020
one of the other actions that I want Ron

00:07:38,110 --> 00:07:43,750
is this IFE so on the egress side I'm

00:07:41,020 --> 00:07:45,580
telling it to encode and some of these

00:07:43,750 --> 00:07:48,640
things are sort of optional but I added

00:07:45,580 --> 00:07:51,190
them here for clarity reasons as an

00:07:48,640 --> 00:07:54,190
example I could say I wanted to use an

00:07:51,190 --> 00:07:55,660
ether type of 0 X dead so there has to

00:07:54,190 --> 00:07:57,940
be synchronization between the source of

00:07:55,660 --> 00:08:01,960
the destination I wanted to allow the

00:07:57,940 --> 00:08:03,610
mark what that means is whatever you see

00:08:01,960 --> 00:08:05,290
on the skb mark I want you to grab that

00:08:03,610 --> 00:08:08,800
from the skb that you receive and

00:08:05,290 --> 00:08:11,350
encoded in in a TLV to send I don't want

00:08:08,800 --> 00:08:14,650
you to use the skb hash I don't care

00:08:11,350 --> 00:08:16,540
what is on the skb hash value

00:08:14,650 --> 00:08:20,920
I just want you to encode always value

00:08:16,540 --> 00:08:23,380
10 for this policy I want also to encode

00:08:20,920 --> 00:08:24,970
the cue mapping skb Cooma but I don't

00:08:23,380 --> 00:08:27,340
want it to use the one that's on the skb

00:08:24,970 --> 00:08:31,360
instead I want you to always in cut

00:08:27,340 --> 00:08:33,760
coded value of 17 and to share and I

00:08:31,360 --> 00:08:36,060
added this one here too so the synthesis

00:08:33,760 --> 00:08:38,890
of views is essentially an override I

00:08:36,060 --> 00:08:40,570
know the system has this has this field

00:08:38,890 --> 00:08:42,760
has this meta data but I don't want you

00:08:40,570 --> 00:08:44,530
to use the system's metadata the runtime

00:08:42,760 --> 00:08:47,100
metadata I wanted to use a static value

00:08:44,530 --> 00:08:47,100
that I said

00:08:47,710 --> 00:08:53,529
this shows how I can actually send an

00:08:49,870 --> 00:08:57,220
arbitrary field in the metadata they use

00:08:53,529 --> 00:09:01,660
sent fubar across or whatever that means

00:08:57,220 --> 00:09:03,070
is up to you and this shows that this is

00:09:01,660 --> 00:09:05,740
where you can do sort of load balancing

00:09:03,070 --> 00:09:07,140
use it select the next hop mark address

00:09:05,740 --> 00:09:10,480
by setting it

00:09:07,140 --> 00:09:12,760
everything is optional here in fact you

00:09:10,480 --> 00:09:15,040
may not have to specify any of these

00:09:12,760 --> 00:09:18,610
fields then magically all the values

00:09:15,040 --> 00:09:22,029
will be sent that that the system knows

00:09:18,610 --> 00:09:23,200
about so you can set the destination MAC

00:09:22,029 --> 00:09:26,820
address the ethertype

00:09:23,200 --> 00:09:28,810
the source MAC address and of course

00:09:26,820 --> 00:09:30,339
showing there there's a graph of this

00:09:28,810 --> 00:09:36,250
thing so you have actions that may

00:09:30,339 --> 00:09:40,300
follow so this is how you basically this

00:09:36,250 --> 00:09:41,950
is how you set this part right so the

00:09:40,300 --> 00:09:46,089
receiver has to receive now this

00:09:41,950 --> 00:09:48,370
metadata and they have to decode it and

00:09:46,089 --> 00:09:50,860
that's what this roads shows right so on

00:09:48,370 --> 00:09:54,100
the ingress side of the receiving node

00:09:50,860 --> 00:09:57,910
you have you look for the protocol 0x

00:09:54,100 --> 00:09:59,170
Ted which is what we said you match on

00:09:57,910 --> 00:10:02,290
everything I could have used a different

00:09:59,170 --> 00:10:05,050
classifier but this just for my testing

00:10:02,290 --> 00:10:08,410
this is what I use and you say decode

00:10:05,050 --> 00:10:13,330
and they allow syntax again that we saw

00:10:08,410 --> 00:10:16,510
before that says I want you to pick up

00:10:13,330 --> 00:10:18,850
to set the mark that you receive and

00:10:16,510 --> 00:10:23,709
then TLV encoding and stash it on the

00:10:18,850 --> 00:10:25,930
skb mark alright so there may be other

00:10:23,709 --> 00:10:29,470
fields there but this policy is saying

00:10:25,930 --> 00:10:31,180
to ignore them just use the skb mark and

00:10:29,470 --> 00:10:33,100
then when you're done with this I wanted

00:10:31,180 --> 00:10:34,990
to reclassify so reclassify basically

00:10:33,100 --> 00:10:38,110
goes back to the policy rules again and

00:10:34,990 --> 00:10:40,870
it's scanning now at this point after

00:10:38,110 --> 00:10:42,850
we've decoded the inner header shows

00:10:40,870 --> 00:10:45,910
that this is an IP packet so we're going

00:10:42,850 --> 00:10:47,470
to go backwards classify and we'll match

00:10:45,910 --> 00:10:49,450
on a second rule which say is looking

00:10:47,470 --> 00:10:53,680
for a protocol IP which is of lower

00:10:49,450 --> 00:10:56,740
priority and we're now going to look for

00:10:53,680 --> 00:11:00,490
the handle which is an skb mark of hex

00:10:56,740 --> 00:11:01,300
11 which is decimal 17 which I had set

00:11:00,490 --> 00:11:05,350
up earlier on

00:11:01,300 --> 00:11:11,500
here I think I had setup maybe not okay

00:11:05,350 --> 00:11:16,269
I did yeah yeah Kimmo up 17 and so

00:11:11,500 --> 00:11:17,950
eventually we will run on action because

00:11:16,269 --> 00:11:23,170
that packet came in coded from the other

00:11:17,950 --> 00:11:25,779
side with that valium right so that's

00:11:23,170 --> 00:11:27,610
how you said now this is I'm doing this

00:11:25,779 --> 00:11:29,140
as a human being typing TC but you can

00:11:27,610 --> 00:11:31,360
write an app in userspace that

00:11:29,140 --> 00:11:34,180
synchronizes across all machines and

00:11:31,360 --> 00:11:35,769
sets these values right and that's how

00:11:34,180 --> 00:11:37,930
you end up building let's say a cluster

00:11:35,769 --> 00:11:40,839
of this sort right you have a control

00:11:37,930 --> 00:11:42,190
app that just programs the hundred

00:11:40,839 --> 00:11:45,160
machines that exists over here maybe

00:11:42,190 --> 00:11:50,709
another 50 that exists on each tree

00:11:45,160 --> 00:11:55,329
hierarchy there and you're set so the

00:11:50,709 --> 00:11:59,709
wire format so as I say this is being

00:11:55,329 --> 00:12:04,600
standardized right now we have the

00:11:59,709 --> 00:12:08,680
original packet size which is now

00:12:04,600 --> 00:12:10,570
encoded with a new Ethernet header such

00:12:08,680 --> 00:12:12,760
as you know where the MAC address that I

00:12:10,570 --> 00:12:15,940
showed you earlier on typically what you

00:12:12,760 --> 00:12:18,160
do is inherit a Ethernet packet you

00:12:15,940 --> 00:12:21,370
received so this source destination

00:12:18,160 --> 00:12:24,850
addresses are the same as what the

00:12:21,370 --> 00:12:26,649
original packet was same the only thing

00:12:24,850 --> 00:12:29,800
that you will need to change is the

00:12:26,649 --> 00:12:32,740
ether type which we type we're trying to

00:12:29,800 --> 00:12:34,779
get an eye honor issued if the type hex

00:12:32,740 --> 00:12:38,770
Fe Fe which stands for Fe Fe

00:12:34,779 --> 00:12:40,149
communication however if you're an admin

00:12:38,770 --> 00:12:41,709
you can set whatever value you want

00:12:40,149 --> 00:12:44,770
there as long as all your machines know

00:12:41,709 --> 00:12:49,480
that the value that you set like beef is

00:12:44,770 --> 00:12:51,310
understood by everybody there is so

00:12:49,480 --> 00:12:53,290
however like I said you can override

00:12:51,310 --> 00:12:59,589
those values so the packet goes

00:12:53,290 --> 00:13:03,940
somewhere else then the way the little

00:12:59,589 --> 00:13:07,060
header there which is 16 bits expresses

00:13:03,940 --> 00:13:10,270
how deep the metadata values are so you

00:13:07,060 --> 00:13:12,490
can go up to 2 to the 16 this may I'll

00:13:10,270 --> 00:13:14,050
talk about the MTU issues afterwards but

00:13:12,490 --> 00:13:14,980
essentially you send this packet across

00:13:14,050 --> 00:13:16,540
the wire

00:13:14,980 --> 00:13:19,690
between the source from the source node

00:13:16,540 --> 00:13:22,480
and then when it gets to the destination

00:13:19,690 --> 00:13:23,949
node all this is stripped off and you're

00:13:22,480 --> 00:13:26,860
left with that which is the original

00:13:23,949 --> 00:13:31,560
packet that was being sent any questions

00:13:26,860 --> 00:13:31,560
on that yep mic

00:13:43,110 --> 00:13:52,690
so why not just use SFC SFC as in

00:13:50,110 --> 00:13:54,910
running over IP or no service function

00:13:52,690 --> 00:14:00,579
chain yeah you could use this to

00:13:54,910 --> 00:14:04,410
implement service changing I don't think

00:14:00,579 --> 00:14:04,410
those guys run over IP right they

00:14:09,060 --> 00:14:13,630
there's an ether type called service

00:14:10,990 --> 00:14:15,459
chaining yeah I don't I don't keep track

00:14:13,630 --> 00:14:17,670
of those guys I mean there's like a lot

00:14:15,459 --> 00:14:20,560
of noise going on there

00:14:17,670 --> 00:14:25,720
I know but there's a lot of vested

00:14:20,560 --> 00:14:27,760
economical interests there this is being

00:14:25,720 --> 00:14:34,920
standardized it's going to be a standard

00:14:27,760 --> 00:14:37,889
RFC not informational so

00:14:34,920 --> 00:14:39,480
challenges yes you have MTU challenges

00:14:37,889 --> 00:14:41,579
because if you keep adding head of

00:14:39,480 --> 00:14:46,019
fields and you expanding the ethernet

00:14:41,579 --> 00:14:47,459
packet you are going to have a very

00:14:46,019 --> 00:14:49,819
large pocket that is it gonna exceed

00:14:47,459 --> 00:14:52,049
them to you so one of the techniques is

00:14:49,819 --> 00:14:53,579
so there's two things one since we're

00:14:52,049 --> 00:14:58,379
using this internally let's say within a

00:14:53,579 --> 00:15:01,439
V's or within containers you can say the

00:14:58,379 --> 00:15:01,859
MTU to something very large like 64 K or

00:15:01,439 --> 00:15:04,410
whatever

00:15:01,859 --> 00:15:06,689
I think the loopback device today sets

00:15:04,410 --> 00:15:09,600
it about the default I have on my

00:15:06,689 --> 00:15:11,970
machine is about 64 K so I can set my

00:15:09,600 --> 00:15:17,579
container connections or VM connections

00:15:11,970 --> 00:15:18,869
to be a large empty you Valley the so

00:15:17,579 --> 00:15:20,730
that that's one technique you basically

00:15:18,869 --> 00:15:23,579
lie to the top layer that you know I

00:15:20,730 --> 00:15:28,169
have this large MTU so that's one way to

00:15:23,579 --> 00:15:30,809
do it the other way is what is we give

00:15:28,169 --> 00:15:33,709
you flexibility enough to say I only

00:15:30,809 --> 00:15:36,929
have 64 byte space therefore I'm gonna

00:15:33,709 --> 00:15:40,049
set my MTU to be whatever my value is

00:15:36,929 --> 00:15:41,759
plus 64 and anything that exceeds that

00:15:40,049 --> 00:15:45,149
the packet will be rejected you get an

00:15:41,759 --> 00:15:47,730
error message the Ethernet type we're

00:15:45,149 --> 00:15:48,660
struggling with we're gonna try and get

00:15:47,730 --> 00:15:54,600
one from Ayana

00:15:48,660 --> 00:15:58,639
however they does not require that you

00:15:54,600 --> 00:16:03,720
get asta to use a standard I on a

00:15:58,639 --> 00:16:07,649
derived ether type what you could do is

00:16:03,720 --> 00:16:10,949
you on the network this is force Rox

00:16:07,649 --> 00:16:12,959
level room level processing of packet to

00:16:10,949 --> 00:16:16,589
scale things now you could use it for

00:16:12,959 --> 00:16:21,509
service chaining absolutely but it's

00:16:16,589 --> 00:16:23,339
within the scope of your own domain so

00:16:21,509 --> 00:16:25,739
you could as long as you program what

00:16:23,339 --> 00:16:29,579
the ether type should be everybody

00:16:25,739 --> 00:16:33,179
should be able to comply to that there's

00:16:29,579 --> 00:16:36,929
a single admin point basically so again

00:16:33,179 --> 00:16:39,209
that's metadata metadata well how do I

00:16:36,929 --> 00:16:41,699
say to the other system that I'm sending

00:16:39,209 --> 00:16:43,649
you an escapee mark in my TLV do you

00:16:41,699 --> 00:16:45,389
standardize that or do you make it

00:16:43,649 --> 00:16:48,750
propriety hmm if you're running your own

00:16:45,389 --> 00:16:50,939
domain I guess you need to publish it so

00:16:48,750 --> 00:16:52,079
assuming this more than one admin even

00:16:50,939 --> 00:16:54,360
within your domain

00:16:52,079 --> 00:16:55,860
someone needs to set policies if you are

00:16:54,360 --> 00:16:58,050
doing it from a central point of view

00:16:55,860 --> 00:16:59,579
then it's easy if you have to interpret

00:16:58,050 --> 00:17:01,800
it with another organization then you

00:16:59,579 --> 00:17:04,770
need to change those values you need to

00:17:01,800 --> 00:17:06,659
be consistent what the IDF forces

00:17:04,770 --> 00:17:09,780
working group is is standardizing those

00:17:06,659 --> 00:17:13,110
meta IDs so there will be made IDs

00:17:09,780 --> 00:17:17,549
issued there'll be a space for vendor

00:17:13,110 --> 00:17:19,230
valued meta IDs but the key is those

00:17:17,549 --> 00:17:22,319
meta IDs need to be understood when I

00:17:19,230 --> 00:17:26,669
say TLV what is @t that tells me what a

00:17:22,319 --> 00:17:32,250
Kumar Kumar ping is or skb hash is or

00:17:26,669 --> 00:17:37,799
what is fubar right brings me to my next

00:17:32,250 --> 00:17:41,100
point sometimes in in order for me to

00:17:37,799 --> 00:17:42,539
discover what metadata is supported by

00:17:41,100 --> 00:17:46,980
specific system I have to be able to

00:17:42,539 --> 00:17:51,960
query the kernel and say tell me which

00:17:46,980 --> 00:17:55,350
metadata you support and what values I

00:17:51,960 --> 00:18:02,490
can set for it so I have maybe should

00:17:55,350 --> 00:18:05,510
show some quick header file here so if

00:18:02,490 --> 00:18:05,510
you look at the code

00:18:08,900 --> 00:18:14,940
here's one for skb you mark so there's a

00:18:12,120 --> 00:18:18,020
few things here so at the moment I have

00:18:14,940 --> 00:18:18,020
let's say TLV is

00:18:35,740 --> 00:18:43,820
so the field that has there's a few

00:18:41,990 --> 00:18:46,009
specific fields that are very important

00:18:43,820 --> 00:18:50,649
for this is future work by the way right

00:18:46,009 --> 00:18:50,649
now is still what the the discovery part

00:18:50,860 --> 00:18:55,340
you have an ID

00:18:53,269 --> 00:18:59,210
that's the Met ID it's defining some

00:18:55,340 --> 00:19:01,070
header file in Linux you have a name so

00:18:59,210 --> 00:19:04,070
I can I can find that this is about Q

00:19:01,070 --> 00:19:05,600
mob s giving a Q map you have a synopsis

00:19:04,070 --> 00:19:08,269
which is missing from here

00:19:05,600 --> 00:19:12,049
well that's future idea so I can

00:19:08,269 --> 00:19:17,779
actually query the kernel and say give

00:19:12,049 --> 00:19:26,870
me give me the ID give me the type let

00:19:17,779 --> 00:19:28,340
me find okay this is sorry it's a patch

00:19:26,870 --> 00:19:30,799
format but yeah I hope you can see that

00:19:28,340 --> 00:19:35,389
that you see the synopsis there it tells

00:19:30,799 --> 00:19:37,309
it what so if you're writing what I'm

00:19:35,389 --> 00:19:38,509
hoping to what I'm shooting for and I

00:19:37,309 --> 00:19:40,460
don't know if I'm gonna be successful of

00:19:38,509 --> 00:19:42,289
this is I don't want to rewrite every

00:19:40,460 --> 00:19:44,269
time somebody writes a new metadata I

00:19:42,289 --> 00:19:46,250
don't want them to rewrite any code in

00:19:44,269 --> 00:19:50,389
IP route to I want them to actually

00:19:46,250 --> 00:19:53,000
query the kernel and I want to retrieve

00:19:50,389 --> 00:19:58,539
the information to say that this is sk b

00:19:53,000 --> 00:20:01,429
mark it has a type of u-32 it's ID is FB

00:19:58,539 --> 00:20:04,009
whatever this value is defined as and

00:20:01,429 --> 00:20:05,509
it's not cyst so I can print a help sign

00:20:04,009 --> 00:20:09,129
or something this is very cheap because

00:20:05,509 --> 00:20:13,610
it's one per metadata metadata encoding

00:20:09,129 --> 00:20:14,750
right so basically because I suspect

00:20:13,610 --> 00:20:17,899
there'll be a lot of people writing

00:20:14,750 --> 00:20:22,149
metadata encoders we just don't want to

00:20:17,899 --> 00:20:22,149
have them rewrite the IP route too bad

00:20:23,830 --> 00:20:29,629
it gets really quick yeah those are very

00:20:27,259 --> 00:20:31,190
similar here because they were working

00:20:29,629 --> 00:20:32,090
on it's very similar to this right we

00:20:31,190 --> 00:20:34,309
want to be able to have the hardware

00:20:32,090 --> 00:20:35,990
tell you what it can support yes so know

00:20:34,309 --> 00:20:38,960
what the types it supports what fields

00:20:35,990 --> 00:20:40,190
and how they tool automatically you

00:20:38,960 --> 00:20:42,860
don't have to update our user space

00:20:40,190 --> 00:20:44,600
every team you add a new exactly so I I

00:20:42,860 --> 00:20:46,159
think I was trying to I keep telling

00:20:44,600 --> 00:20:46,950
saying this is what I wanted to talk to

00:20:46,159 --> 00:20:48,690
about net cough

00:20:46,950 --> 00:20:55,860
just never you guys hassled me that I

00:20:48,690 --> 00:20:58,140
never got to talk about this but that's

00:20:55,860 --> 00:20:59,820
that's what i meant by discovery i want

00:20:58,140 --> 00:21:03,590
to actually ask the colonel it tells me

00:20:59,820 --> 00:21:05,760
the name synopsis ids this is what the

00:21:03,590 --> 00:21:07,500
hardware does right we want to ask the

00:21:05,760 --> 00:21:08,910
hardware what do you write port yeah

00:21:07,500 --> 00:21:12,000
when ask the colonel what it supports

00:21:08,910 --> 00:21:18,030
yes users based a program coherent lee

00:21:12,000 --> 00:21:18,510
yes Oh Jamal yep over here right here

00:21:18,030 --> 00:21:21,090
yeah

00:21:18,510 --> 00:21:22,980
so I don't know if I if I just heard

00:21:21,090 --> 00:21:24,360
something that I what I think I just

00:21:22,980 --> 00:21:26,760
want to ask you if what I just heard the

00:21:24,360 --> 00:21:28,740
conversation was that it sounds to me

00:21:26,760 --> 00:21:30,060
like the the people that for instance

00:21:28,740 --> 00:21:32,330
building switch hardware that we were

00:21:30,060 --> 00:21:36,690
talking about in the previous talk are

00:21:32,330 --> 00:21:40,860
are suddenly saying wait a minute what

00:21:36,690 --> 00:21:42,930
if in fact the communication between the

00:21:40,860 --> 00:21:46,200
switch hardware and a Linux kernel

00:21:42,930 --> 00:21:49,050
looked exactly like the communication

00:21:46,200 --> 00:21:50,880
between your two containers that's what

00:21:49,050 --> 00:21:52,170
I thought I just heard no that what I

00:21:50,880 --> 00:21:56,100
know you're talking about

00:21:52,170 --> 00:21:58,440
discoverability of the how do I know can

00:21:56,100 --> 00:22:01,050
I you basically John has some similar

00:21:58,440 --> 00:22:04,620
technique to ask the hard way what can

00:22:01,050 --> 00:22:06,180
you do for me and a little more is a

00:22:04,620 --> 00:22:08,010
little more intimate than I'm suggesting

00:22:06,180 --> 00:22:09,480
right suggesting that the switch

00:22:08,010 --> 00:22:13,190
Hardware could look like it's a

00:22:09,480 --> 00:22:16,560
different TC classifier to

00:22:13,190 --> 00:22:17,850
across that you know there's some piece

00:22:16,560 --> 00:22:19,890
about hardware here let me just get

00:22:17,850 --> 00:22:21,990
maybe that was my whole question so it

00:22:19,890 --> 00:22:23,430
wasn't as is I thought there was like an

00:22:21,990 --> 00:22:26,130
epiphany that just happened here that's

00:22:23,430 --> 00:22:27,840
all but it wasn't do you want to we'll

00:22:26,130 --> 00:22:30,150
follow that up the only thing maybe I

00:22:27,840 --> 00:22:31,650
would add is it's it's it's actually

00:22:30,150 --> 00:22:34,800
useful to be able to have your your

00:22:31,650 --> 00:22:36,810
switch populate fields in the skb and

00:22:34,800 --> 00:22:43,110
send it into the stack for you know

00:22:36,810 --> 00:22:46,470
further classification okay so how do

00:22:43,110 --> 00:22:51,900
you add a new metadata extension you

00:22:46,470 --> 00:22:52,350
basically have to where the hell is that

00:22:51,900 --> 00:22:54,900
thing

00:22:52,350 --> 00:22:57,600
that is so I'm just going to show you in

00:22:54,900 --> 00:22:59,370
patch format you basically have to

00:22:57,600 --> 00:23:04,140
create a structure of that sort

00:22:59,370 --> 00:23:05,460
you define what the metadata IDs are the

00:23:04,140 --> 00:23:08,220
most important things are these methods

00:23:05,460 --> 00:23:12,270
that are supplied you know a Czech

00:23:08,220 --> 00:23:13,830
presence method and encode decode user

00:23:12,270 --> 00:23:17,130
space may want to ask you give me your

00:23:13,830 --> 00:23:19,500
metadata give me attributes you have an

00:23:17,130 --> 00:23:21,030
allocation method you have a release

00:23:19,500 --> 00:23:22,530
method because if you know you may have

00:23:21,030 --> 00:23:25,170
a complex structure we don't want to

00:23:22,530 --> 00:23:29,430
take care of that you just so if I

00:23:25,170 --> 00:23:31,320
quickly show the different methods using

00:23:29,430 --> 00:23:35,780
this patch so here's an escapee marking

00:23:31,320 --> 00:23:35,780
code right so what you do is essentially

00:23:38,660 --> 00:23:44,190
this your your encode method will be

00:23:41,640 --> 00:23:47,610
called whenever we recognize that we not

00:23:44,190 --> 00:23:49,610
we have to cut an escapee mark and in

00:23:47,610 --> 00:23:51,900
this case we grab it off this KB and

00:23:49,610 --> 00:23:53,730
then we check if we have a static

00:23:51,900 --> 00:23:57,120
overwrite value if we do then we're

00:23:53,730 --> 00:23:59,370
gonna use that value otherwise if this

00:23:57,120 --> 00:24:00,350
is false we're using the skb mark just

00:23:59,370 --> 00:24:03,300
that simple

00:24:00,350 --> 00:24:05,220
alright simple metadata this is very

00:24:03,300 --> 00:24:08,450
trivial as you can see and then of

00:24:05,220 --> 00:24:10,620
course we end up calling the encoder

00:24:08,450 --> 00:24:13,020
there's an encoder that takes it and

00:24:10,620 --> 00:24:17,240
puts it in big endian format for sending

00:24:13,020 --> 00:24:19,679
out on the wire for the decode part

00:24:17,240 --> 00:24:22,410
we're basically going to pass your piece

00:24:19,679 --> 00:24:26,250
of data which is the stripped out TLV

00:24:22,410 --> 00:24:28,559
the data part of the TLV use convert it

00:24:26,250 --> 00:24:33,540
to indian to the proper host Indian s

00:24:28,559 --> 00:24:38,700
and you stash it to this KB mark and

00:24:33,540 --> 00:24:41,550
this just checks if we we have this

00:24:38,700 --> 00:24:44,910
value or not the people give you more

00:24:41,550 --> 00:24:45,990
data so write those write this and in

00:24:44,910 --> 00:24:51,030
the future you don't have to write a

00:24:45,990 --> 00:24:53,510
single line of code for IP route 2 so at

00:24:51,030 --> 00:24:59,270
the risk of you coming here and beat me

00:24:53,510 --> 00:25:02,040
I'll try not to line protocol for

00:24:59,270 --> 00:25:06,270
serializing gasp KB metadata might be

00:25:02,040 --> 00:25:08,790
useful for other purposes than quality

00:25:06,270 --> 00:25:11,130
of service or other types of quality of

00:25:08,790 --> 00:25:16,420
service that are

00:25:11,130 --> 00:25:18,430
using TC so do you see a way or future

00:25:16,420 --> 00:25:20,920
implementation which something like this

00:25:18,430 --> 00:25:23,800
is used or implemented as a protocol

00:25:20,920 --> 00:25:27,100
handler and the receive bus instead of

00:25:23,800 --> 00:25:28,990
class action yeah just I guess I never

00:25:27,100 --> 00:25:31,200
thought of that but this I have to

00:25:28,990 --> 00:25:33,850
explain that this is a four standard

00:25:31,200 --> 00:25:35,410
right and enforces we have this concept

00:25:33,850 --> 00:25:38,500
of these nodes that I showed the graph

00:25:35,410 --> 00:25:40,990
thing right and then we just needed to

00:25:38,500 --> 00:25:42,670
distribute them sometimes it's a good

00:25:40,990 --> 00:25:45,940
thing when the big guys are not looking

00:25:42,670 --> 00:25:47,890
there and disrupting you so that's why

00:25:45,940 --> 00:25:51,220
we made progress basically but I can see

00:25:47,890 --> 00:25:52,840
that it will be useful Thanks

00:25:51,220 --> 00:25:55,270
there's actually there's a small piece

00:25:52,840 --> 00:25:56,830
this is where I wanted I was trying to

00:25:55,270 --> 00:25:59,440
get Martin to help me out on some of

00:25:56,830 --> 00:26:02,230
this thing so for example there's no

00:25:59,440 --> 00:26:05,230
doubt that you can take that metadata

00:26:02,230 --> 00:26:08,430
encoding in translate it into some

00:26:05,230 --> 00:26:10,450
propriety format like high gig which

00:26:08,430 --> 00:26:13,090
there's a lot of chip-to-chip

00:26:10,450 --> 00:26:15,300
interconnects that have their own thing

00:26:13,090 --> 00:26:19,450
of a zowie or something of that sort

00:26:15,300 --> 00:26:20,920
where you can they do encode metadata I

00:26:19,450 --> 00:26:23,230
think John you're telling me you're you

00:26:20,920 --> 00:26:27,040
guys also suppose some 64-bit field that

00:26:23,230 --> 00:26:28,990
I can write so what if I could take this

00:26:27,040 --> 00:26:32,620
and have a little proxy that actually

00:26:28,990 --> 00:26:34,150
translates between two chips using the

00:26:32,620 --> 00:26:36,790
efi action or some other action that

00:26:34,150 --> 00:26:39,400
follows IV action or before IV actually

00:26:36,790 --> 00:26:42,790
that encodes it into that format that

00:26:39,400 --> 00:26:44,230
the chip understands that's it's in the

00:26:42,790 --> 00:26:44,560
paper we say we mention that kind of

00:26:44,230 --> 00:26:46,240
thing

00:26:44,560 --> 00:26:49,480
and that's had something we had to deal

00:26:46,240 --> 00:26:52,630
with in our running implementation today

00:26:49,480 --> 00:26:56,110
that's serving a lot of flaws I would

00:26:52,630 --> 00:26:58,810
say so what are the future plans we

00:26:56,110 --> 00:27:00,550
don't have performance numbers we do

00:26:58,810 --> 00:27:03,160
believe this is extremely fast because

00:27:00,550 --> 00:27:05,800
the latency is say running this or

00:27:03,160 --> 00:27:07,450
running over UDP over foo this is gonna

00:27:05,800 --> 00:27:10,800
be a hell lot more faster because of the

00:27:07,450 --> 00:27:10,800
amount of code that's executed

00:27:10,860 --> 00:27:15,850
discoverability is work in progress I've

00:27:14,080 --> 00:27:18,250
been trying to get hold of John up for

00:27:15,850 --> 00:27:20,920
like John can we talk okay I have to run

00:27:18,250 --> 00:27:22,140
but we're hopefully gonna talk and maybe

00:27:20,920 --> 00:27:24,470
we'll come up with something that's

00:27:22,140 --> 00:27:26,870
convergent

00:27:24,470 --> 00:27:30,250
they hardware offload so I do believe

00:27:26,870 --> 00:27:32,990
that if I was to look at this stuff here

00:27:30,250 --> 00:27:36,620
right I can I should be able to have

00:27:32,990 --> 00:27:38,120
some hardware offload and this could be

00:27:36,620 --> 00:27:42,350
easily demonstrated with the rocker

00:27:38,120 --> 00:27:44,450
rocking rock where I actually received

00:27:42,350 --> 00:27:47,270
this in hard when ki mu for example I

00:27:44,450 --> 00:27:49,370
strip off the tlvs and attach them to

00:27:47,270 --> 00:27:53,630
DMA descriptors so by the time they get

00:27:49,370 --> 00:27:55,909
to drive this this DMA pointers or

00:27:53,630 --> 00:27:58,220
values are already set and I can

00:27:55,909 --> 00:28:00,890
transfer them to the appropriate skb

00:27:58,220 --> 00:28:04,909
matches or whatever that's something

00:28:00,890 --> 00:28:05,240
that is working progress as well what

00:28:04,909 --> 00:28:10,039
else

00:28:05,240 --> 00:28:11,240
oops yeah I just finished these slides I

00:28:10,039 --> 00:28:14,240
have a feeling I missed something that's

00:28:11,240 --> 00:28:17,000
in the paper I apologize but read the

00:28:14,240 --> 00:28:21,700
paper send questions I'll be posting

00:28:17,000 --> 00:28:21,700
dispatches any questions

00:28:24,780 --> 00:28:30,510
nobody liked it is anybody out there

00:28:27,390 --> 00:28:32,600
that thinks this is a real so what

00:28:30,510 --> 00:28:35,549
happens when you get an ia and a number

00:28:32,600 --> 00:28:37,860
what when you get a allocated Ethernet

00:28:35,549 --> 00:28:39,960
either type number for this stuff yeah

00:28:37,860 --> 00:28:42,270
so that's so that I think that's one of

00:28:39,960 --> 00:28:44,070
the things I missed right so we said we

00:28:42,270 --> 00:28:47,659
don't want to do the VX LAN angle you

00:28:44,070 --> 00:28:50,070
know how the X line guys went and I

00:28:47,659 --> 00:28:52,559
think one of the port numbers was used

00:28:50,070 --> 00:28:54,480
in Linux at an ITF when they're wise Dom

00:28:52,559 --> 00:28:56,880
decided that they want to allocate a

00:28:54,480 --> 00:28:58,590
different port number so we allow for

00:28:56,880 --> 00:29:01,020
you to set it basically from day one

00:28:58,590 --> 00:29:04,169
right so how far away are you from

00:29:01,020 --> 00:29:06,299
getting a number is out close close yeah

00:29:04,169 --> 00:29:07,770
we just have to make push it to RFC why

00:29:06,299 --> 00:29:10,110
don't you just wait until you have that

00:29:07,770 --> 00:29:12,299
number before you add this unnecessary

00:29:10,110 --> 00:29:17,580
at that point unnecessary flexibility to

00:29:12,299 --> 00:29:19,140
the I so in admin sense of you I should

00:29:17,580 --> 00:29:22,770
be able to set any value I want like in

00:29:19,140 --> 00:29:25,110
my network right this is essentially the

00:29:22,770 --> 00:29:29,700
domain of this is sort of within the

00:29:25,110 --> 00:29:32,010
scope of a cluster right my cluster this

00:29:29,700 --> 00:29:33,990
is another one this scenarios were from

00:29:32,010 --> 00:29:36,330
my perspective I want to put you into

00:29:33,990 --> 00:29:38,570
the smallest box as possible whereas you

00:29:36,330 --> 00:29:40,740
want the maximum flexibility just

00:29:38,570 --> 00:29:41,580
consider my point of view on this you

00:29:40,740 --> 00:29:42,809
okay

00:29:41,580 --> 00:29:46,500
does that mean I shouldn't send the

00:29:42,809 --> 00:29:48,240
punch I I think if you're gonna get the

00:29:46,500 --> 00:29:50,010
value in a couple weeks you might want

00:29:48,240 --> 00:29:52,350
to just sort of implementation with the

00:29:50,010 --> 00:29:53,820
fixed value and if it is really a useful

00:29:52,350 --> 00:29:59,370
feature to be able to put arbitrary

00:29:53,820 --> 00:30:01,049
types in there at it so the ITF doesn't

00:29:59,370 --> 00:30:04,760
deal with the I trip with the I Triple E

00:30:01,049 --> 00:30:07,140
there's a lot of politics I mean yeah

00:30:04,760 --> 00:30:09,650
right okay I'll leave the decision up to

00:30:07,140 --> 00:30:13,880
you for now okay all right thanks man

00:30:09,650 --> 00:30:13,880
all right so that was it

00:30:14,240 --> 00:30:18,410
any more comments questions

00:30:22,400 --> 00:30:25,570

YouTube URL: https://www.youtube.com/watch?v=BSlUOBxYjPY


