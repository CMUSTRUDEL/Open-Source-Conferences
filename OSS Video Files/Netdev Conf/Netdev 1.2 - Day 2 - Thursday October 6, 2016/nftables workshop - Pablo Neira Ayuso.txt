Title: nftables workshop - Pablo Neira Ayuso
Publication date: 2016-10-07
Playlist: Netdev 1.2 - Day 2 - Thursday October 6, 2016
Description: 
	http://netdevconf.org/1.2/session.html?pablo-nftable-workshop
Captions: 
	00:00:09,719 --> 00:00:17,400
this is mine okay what this is a enough

00:00:16,529 --> 00:00:20,250
signals workshop

00:00:17,400 --> 00:00:23,779
my name is Pablo and we are going to

00:00:20,250 --> 00:00:26,070
discuss some basically expose some

00:00:23,779 --> 00:00:28,410
changes that we have made on the next

00:00:26,070 --> 00:00:31,020
filter subsystem in the since last night

00:00:28,410 --> 00:00:35,010
that conference and also we are going to

00:00:31,020 --> 00:00:37,739
spend some time on on talking on on

00:00:35,010 --> 00:00:43,559
improvements that we have to farm on on

00:00:37,739 --> 00:00:47,399
the NF stables infrastructure so we are

00:00:43,559 --> 00:00:51,480
going to to start with Laura now that

00:00:47,399 --> 00:00:53,339
she's been she be a outreach she she's

00:00:51,480 --> 00:00:55,800
been working on on a thicker in the

00:00:53,339 --> 00:00:58,319
frame of that outreach program and she's

00:00:55,800 --> 00:01:00,149
been improving the load balancing

00:00:58,319 --> 00:01:02,190
infrastructure for enough stables

00:01:00,149 --> 00:01:05,489
basically with two new expressions that

00:01:02,190 --> 00:01:10,920
are the number generation and and they

00:01:05,489 --> 00:01:14,040
hash the hash expression and then I will

00:01:10,920 --> 00:01:19,380
let Florian discuss some ongoing work on

00:01:14,040 --> 00:01:22,620
on the new expression and I wouldn't

00:01:19,380 --> 00:01:27,710
have the discussions and presentations

00:01:22,620 --> 00:01:30,350
with some ideas but I have also

00:01:27,710 --> 00:01:37,800
considered interesting to discuss so

00:01:30,350 --> 00:01:40,070
Laura would you like to how does this

00:01:37,800 --> 00:01:40,070
work

00:01:49,579 --> 00:01:52,570
Oh blessing

00:01:58,140 --> 00:02:15,740
you know okay this is the we presented

00:02:10,770 --> 00:02:15,740
in the net that one one interview

00:02:16,700 --> 00:02:23,450
prototype so here we are going to see

00:02:20,390 --> 00:02:26,280
some development evolution that we made

00:02:23,450 --> 00:02:31,020
the review of some use cases that we

00:02:26,280 --> 00:02:34,080
presented some benchmarks in order to

00:02:31,020 --> 00:02:40,850
see in what state is this development

00:02:34,080 --> 00:02:44,660
and so what to do so regarding the

00:02:40,850 --> 00:02:48,540
evolution that we have been working on

00:02:44,660 --> 00:02:54,060
we include two main expressions in

00:02:48,540 --> 00:02:56,550
tables another generator with supposed

00:02:54,060 --> 00:03:00,600
to modes in grow meta incremental and

00:02:56,550 --> 00:03:05,280
random and provides the ability to scale

00:03:00,600 --> 00:03:09,900
values and add an offset in addition the

00:03:05,280 --> 00:03:13,410
hash expression it's able to Hajj any

00:03:09,900 --> 00:03:16,980
selector concatenation a currently is

00:03:13,410 --> 00:03:25,290
only one node with a support junking

00:03:16,980 --> 00:03:28,380
hash some examples regarding the number

00:03:25,290 --> 00:03:35,420
generator explosion which is based on

00:03:28,380 --> 00:03:38,160
the IP table X - X extensions statistics

00:03:35,420 --> 00:03:42,209
the geometric quantities used to

00:03:38,160 --> 00:03:46,230
generate our own roving scheduler for

00:03:42,209 --> 00:03:48,989
example here we are going to match our

00:03:46,230 --> 00:03:52,650
destination address with TCP destination

00:03:48,989 --> 00:03:59,609
port and we are going to apply a D not

00:03:52,650 --> 00:04:03,959
to incremental model - for two indexes

00:03:59,609 --> 00:04:06,379
that are stored in a map the

00:04:03,959 --> 00:04:10,500
the values are the destination addresses

00:04:06,379 --> 00:04:15,109
that are going to be substituted to the

00:04:10,500 --> 00:04:20,190
in the into the D nut also this

00:04:15,109 --> 00:04:23,610
expression is it could be able to to be

00:04:20,190 --> 00:04:29,550
used you know to generate series of

00:04:23,610 --> 00:04:31,770
numbers for example to mark packets for

00:04:29,550 --> 00:04:35,580
example marking packets so we could

00:04:31,770 --> 00:04:42,060
generate a series of numbers adding an

00:04:35,580 --> 00:04:46,650
offset in the random generation could be

00:04:42,060 --> 00:04:48,720
used for weight scheduler and as an

00:04:46,650 --> 00:04:52,710
example we could match a destination

00:04:48,720 --> 00:04:56,699
address and destination port a Nepali a

00:04:52,710 --> 00:05:02,610
dinner to a random module 2 which will

00:04:56,699 --> 00:05:04,889
be the two indexes of the map also it

00:05:02,610 --> 00:05:08,370
could be used to generate a series of

00:05:04,889 --> 00:05:12,690
numbers for example if we apply a after

00:05:08,370 --> 00:05:21,449
of 100 we call generate a serious

00:05:12,690 --> 00:05:26,190
between 100 and 102 in relax to the hash

00:05:21,449 --> 00:05:29,729
expression we could be used it could be

00:05:26,190 --> 00:05:32,159
used for persistence so if we match on

00:05:29,729 --> 00:05:35,460
the solution IP address and the

00:05:32,159 --> 00:05:39,330
destination TCP port we could apply a

00:05:35,460 --> 00:05:44,070
denied with a hashing function using the

00:05:39,330 --> 00:05:48,300
source address module 2 so for the same

00:05:44,070 --> 00:05:52,979
source address will be used one back-end

00:05:48,300 --> 00:05:58,080
or another the same thing here we could

00:05:52,979 --> 00:06:01,259
use a J hash to mark packets in regard

00:05:58,080 --> 00:06:05,180
to the source address and apply even a

00:06:01,259 --> 00:06:09,050
seed or an offset in order to generate

00:06:05,180 --> 00:06:09,050
series of hashing

00:06:10,130 --> 00:06:19,320
in order to use these new features we

00:06:14,370 --> 00:06:26,640
will need our new kernel get it down for

00:06:19,320 --> 00:06:32,990
8-0 rc4 with bunch and if next day

00:06:26,640 --> 00:06:35,910
library in a tnl greater than 1 0 6 and

00:06:32,990 --> 00:06:42,110
packet of any few tables built it down

00:06:35,910 --> 00:06:42,110
so point seven author is not resilient

00:06:42,410 --> 00:06:51,360
so we are going to review some use cases

00:06:45,360 --> 00:06:56,520
this is the definitive syntax for

00:06:51,360 --> 00:07:02,700
example for s not topology we need here

00:06:56,520 --> 00:07:07,170
we have posters athletes packet path so

00:07:02,700 --> 00:07:09,390
in this case they will be needs to

00:07:07,170 --> 00:07:12,150
change the source IP address and

00:07:09,390 --> 00:07:15,930
destination IP address to the back end

00:07:12,150 --> 00:07:20,270
so we will need to create a table with

00:07:15,930 --> 00:07:24,720
two chains for routing and post routine

00:07:20,270 --> 00:07:26,760
just one rule to create a match from

00:07:24,720 --> 00:07:28,410
destination address can certain

00:07:26,760 --> 00:07:36,240
destination address and destination port

00:07:28,410 --> 00:07:39,060
and apply a unit function to an

00:07:36,240 --> 00:07:42,500
incremental module three because we have

00:07:39,060 --> 00:07:48,060
three buttons it will generate a random

00:07:42,500 --> 00:07:51,810
scheduler with the map of three IP

00:07:48,060 --> 00:07:57,180
addresses it's needed for this topology

00:07:51,810 --> 00:08:01,890
to include a masquerade to be not

00:07:57,180 --> 00:08:05,730
transparent in the useless for

00:08:01,890 --> 00:08:10,200
detonation math not is a quite similar

00:08:05,730 --> 00:08:12,990
but in this place we will have four

00:08:10,200 --> 00:08:17,280
steps for the complete the path for a

00:08:12,990 --> 00:08:22,000
packet in this case we have to change

00:08:17,280 --> 00:08:25,000
the nation IP address on the back end

00:08:22,000 --> 00:08:30,250
needs to have the load balancing RPS our

00:08:25,000 --> 00:08:35,200
gateway so it's quite similar to the

00:08:30,250 --> 00:08:37,780
previous case in this case we have used

00:08:35,200 --> 00:08:42,130
the random function to create for

00:08:37,780 --> 00:08:45,060
example our world scheduler but here we

00:08:42,130 --> 00:08:48,760
are we're going to avoid the masquerade

00:08:45,060 --> 00:08:55,320
but it's neat to create the chaining

00:08:48,760 --> 00:09:01,060
post routing this is how you scale that

00:08:55,320 --> 00:09:05,220
we didn't take into consideration in the

00:09:01,060 --> 00:09:09,270
in the last talk but now that we have

00:09:05,220 --> 00:09:14,920
support in in a few tables from ingress

00:09:09,270 --> 00:09:18,010
we could make an approach for direct

00:09:14,920 --> 00:09:20,920
service return and there is a very tuned

00:09:18,010 --> 00:09:24,220
we have three steps to complete the

00:09:20,920 --> 00:09:27,460
packet path and web browser needs to

00:09:24,220 --> 00:09:33,910
change the source MAC address and

00:09:27,460 --> 00:09:38,020
destination MAC address so it's it's

00:09:33,910 --> 00:09:41,800
sufficient to create a chain with the

00:09:38,020 --> 00:09:48,420
hook ingress the device of the rubber

00:09:41,800 --> 00:09:51,700
Lancer and today just one rule that

00:09:48,420 --> 00:09:54,460
matches destination address and a

00:09:51,700 --> 00:09:59,170
destination port in this case will be

00:09:54,460 --> 00:10:04,930
UDP because this disused case is for non

00:09:59,170 --> 00:10:08,950
connection oriented we had to change the

00:10:04,930 --> 00:10:12,700
source address source MAC address to the

00:10:08,950 --> 00:10:15,760
MAC address of the load balancer and the

00:10:12,700 --> 00:10:20,700
destination MAC address to the MAC

00:10:15,760 --> 00:10:23,800
address of the back end I'm generated a

00:10:20,700 --> 00:10:27,490
spell scheduler in this case a round

00:10:23,800 --> 00:10:29,680
robin with three backends in this case

00:10:27,490 --> 00:10:34,270
the values of the map will be the MAC

00:10:29,680 --> 00:10:35,320
addresses and finally forward to the

00:10:34,270 --> 00:10:38,470
device

00:10:35,320 --> 00:10:44,860
for which it is going to compare to the

00:10:38,470 --> 00:10:47,560
backend for this place as in English we

00:10:44,860 --> 00:10:53,490
don't have connection information we

00:10:47,560 --> 00:11:00,730
can't load balancing do a balancing for

00:10:53,490 --> 00:11:05,800
connection-oriented connections so we

00:11:00,730 --> 00:11:11,550
could achieve that just having a Jay

00:11:05,800 --> 00:11:15,069
Hajj we call use the concatenation of

00:11:11,550 --> 00:11:19,600
the source address clearly and source

00:11:15,069 --> 00:11:21,490
address and so support these two values

00:11:19,600 --> 00:11:25,589
or registers are going to be a

00:11:21,490 --> 00:11:30,519
concatenated and then generator RJ has

00:11:25,589 --> 00:11:33,100
this heart will permit not only to

00:11:30,519 --> 00:11:37,930
create some kind of persistency for the

00:11:33,100 --> 00:11:44,050
connections but also to do some traffic

00:11:37,930 --> 00:11:47,399
sharing here we we have included the

00:11:44,050 --> 00:11:55,029
seed but in future releases will be

00:11:47,399 --> 00:11:57,490
optional in this cases I forgot that in

00:11:55,029 --> 00:12:01,240
this topology we have to include in the

00:11:57,490 --> 00:12:02,980
back end loopback interface which will

00:12:01,240 --> 00:12:09,130
have the at the address of the load

00:12:02,980 --> 00:12:13,209
balancer here we are going to represent

00:12:09,130 --> 00:12:19,139
some benchmarks the women in our lab

00:12:13,209 --> 00:12:25,300
environment so we used renovation for

00:12:19,139 --> 00:12:28,870
8:03 for a branch in next with two

00:12:25,300 --> 00:12:34,410
clients and three backends on one local

00:12:28,870 --> 00:12:34,410
answer each matching with two cores of

00:12:34,740 --> 00:12:46,649
3.53 GL each i five with

00:12:42,180 --> 00:12:48,380
two threads per core 4g about to

00:12:46,649 --> 00:12:51,630
intermix

00:12:48,380 --> 00:12:56,610
but matching some system tuning

00:12:51,630 --> 00:13:01,410
consideration from the just paper we are

00:12:56,610 --> 00:13:07,440
going to test the HTTP protocol we have

00:13:01,410 --> 00:13:12,720
tested that ipv4 ipv6 in this test the

00:13:07,440 --> 00:13:19,260
we never was saturated and the testing

00:13:12,720 --> 00:13:25,380
was along three thirty-seconds and we

00:13:19,260 --> 00:13:28,490
have also do some testing with LPS in

00:13:25,380 --> 00:13:35,850
order to knowing which states are these

00:13:28,490 --> 00:13:41,270
implementations so here we have that for

00:13:35,850 --> 00:13:45,720
example in not topologies we have a

00:13:41,270 --> 00:13:49,740
performance for NT s naught and in our

00:13:45,720 --> 00:13:56,209
topologies with a let v lv s only it's

00:13:49,740 --> 00:13:59,850
available as not so it's you it would be

00:13:56,209 --> 00:14:04,740
recommended to compare the is not mod of

00:13:59,850 --> 00:14:07,470
both it seems that it's not much more

00:14:04,740 --> 00:14:12,709
performance that we expected but we

00:14:07,470 --> 00:14:19,050
could we could see that with empty the

00:14:12,709 --> 00:14:21,000
the cpu is a slightly lower but the

00:14:19,050 --> 00:14:26,910
requests per second is also slightly

00:14:21,000 --> 00:14:31,440
lower than lv s in s not apology in

00:14:26,910 --> 00:14:34,459
years are this a better term we can we

00:14:31,440 --> 00:14:41,249
could rest get

00:14:34,459 --> 00:14:46,559
that empty it's almost self pouring five

00:14:41,249 --> 00:14:55,199
fifty four percent of CPU meanwhile LDS

00:14:46,559 --> 00:14:58,019
is almost five percent of CPU so LVS

00:14:55,199 --> 00:15:02,249
rich which is the same amount of

00:14:58,019 --> 00:15:07,739
requests per second we could get almost

00:15:02,249 --> 00:15:10,829
ten times faster with ingress with

00:15:07,739 --> 00:15:16,470
enough tables than there is a relative

00:15:10,829 --> 00:15:23,779
with obvious in ipv6 in general the

00:15:16,470 --> 00:15:27,329
rupees per seconds are higher the not

00:15:23,779 --> 00:15:37,069
topology is quite similar between them

00:15:27,329 --> 00:15:43,439
as I'm happy for India all we could get

00:15:37,069 --> 00:15:50,839
ft much more performance that LVS is

00:15:43,439 --> 00:15:50,839
almost six times faster than than LVS

00:15:51,199 --> 00:16:01,079
and well just for finishing some what to

00:15:55,529 --> 00:16:06,089
do we are going to work in a lab wait

00:16:01,079 --> 00:16:12,149
not from the hood ingress to improve the

00:16:06,089 --> 00:16:16,049
de NOC results comparing 2 lbs the user

00:16:12,149 --> 00:16:17,240
space and afterwards manager which will

00:16:16,049 --> 00:16:20,540
be

00:16:17,240 --> 00:16:24,970
allowed to search some more complex

00:16:20,540 --> 00:16:29,420
algorithms not only run roving or weight

00:16:24,970 --> 00:16:33,860
schedulers and also to manage the

00:16:29,420 --> 00:16:37,880
different topology easily finally our

00:16:33,860 --> 00:16:40,310
health monitor that could be the

00:16:37,880 --> 00:16:44,270
possibility to include some layers

00:16:40,310 --> 00:16:44,710
support so we could check our different

00:16:44,270 --> 00:16:48,010
layers

00:16:44,710 --> 00:16:52,370
they have checks of the back ends and

00:16:48,010 --> 00:16:54,530
some internal external monitors so the

00:16:52,370 --> 00:16:56,930
they watching who is performing a

00:16:54,530 --> 00:17:00,650
balancing doesn't need to have the

00:16:56,930 --> 00:17:05,300
health checker okay

00:17:00,650 --> 00:17:08,420
so this final talk I want to thank you

00:17:05,300 --> 00:17:11,540
for the operative problem for supporting

00:17:08,420 --> 00:17:13,880
this development and for sure so Paula

00:17:11,540 --> 00:17:24,860
who has been my mentor 20 say

00:17:13,880 --> 00:17:27,550
development thank you okay if you have

00:17:24,860 --> 00:17:27,550
any questions for Laura

00:17:29,700 --> 00:17:33,020
any question yeah

00:17:38,330 --> 00:17:44,360
if you people took them support

00:17:41,150 --> 00:17:48,190
inconsistent dashing weight consistent

00:17:44,360 --> 00:17:48,190
hashing no

00:18:03,990 --> 00:18:10,029
okay okay thank you so now when it

00:18:08,320 --> 00:18:13,059
before I with Florian that he's going to

00:18:10,029 --> 00:18:16,500
make a quick update on on the feet

00:18:13,059 --> 00:18:16,500
expression he's going to be working on

00:19:25,020 --> 00:19:28,520
come anyone go at this fullscreen

00:19:39,050 --> 00:19:45,390
Thanks yes thank you so I will talk a

00:19:42,960 --> 00:19:49,470
bit about the ongoing work on the

00:19:45,390 --> 00:19:53,190
expression to allow carrying the routing

00:19:49,470 --> 00:19:55,470
tables from enough tables so the

00:19:53,190 --> 00:19:57,780
motivation is basically to implement two

00:19:55,470 --> 00:20:00,720
features that IB tables respectively the

00:19:57,780 --> 00:20:03,270
ipv6 service has one is reverse parts

00:20:00,720 --> 00:20:04,620
filtering to check if reply to a packet

00:20:03,270 --> 00:20:07,430
would leave I at the same interface the

00:20:04,620 --> 00:20:10,110
packet arrived on we have such a native

00:20:07,430 --> 00:20:12,180
interface for RP filtering for I before

00:20:10,110 --> 00:20:16,140
but we do not have it in mistake for

00:20:12,180 --> 00:20:18,480
ipv6 so the the only way to do this

00:20:16,140 --> 00:20:20,880
currently is using the IP six tables Rob

00:20:18,480 --> 00:20:22,440
Liefeld image and the other feature that

00:20:20,880 --> 00:20:24,630
we would like to support in a table two

00:20:22,440 --> 00:20:26,790
is the address type matching which

00:20:24,630 --> 00:20:28,680
basically means that you can ask the

00:20:26,790 --> 00:20:29,730
colonel if what it sings about the

00:20:28,680 --> 00:20:31,380
source address or the destination

00:20:29,730 --> 00:20:33,900
address in a packet if it's a local

00:20:31,380 --> 00:20:35,340
address if it is a broadcast address

00:20:33,900 --> 00:20:39,150
know the card address and so on and so

00:20:35,340 --> 00:20:42,300
on this can for instance be used to turn

00:20:39,150 --> 00:20:45,390
the curl from a weekend or strong and

00:20:42,300 --> 00:20:46,740
models to only accept a packet for an IP

00:20:45,390 --> 00:20:50,010
address that is configured on the same

00:20:46,740 --> 00:20:52,620
interface for instance and because both

00:20:50,010 --> 00:20:54,960
of these IP tables matches partially

00:20:52,620 --> 00:20:57,330
overlapping features it makes sense to

00:20:54,960 --> 00:21:01,730
implement that in one go and kind of

00:20:57,330 --> 00:21:05,460
tables and that's the flip expression

00:21:01,730 --> 00:21:07,740
currently the syntax is basically to ask

00:21:05,460 --> 00:21:12,030
for fit and then you specify as a tube

00:21:07,740 --> 00:21:14,130
in the tuple syntax notation the inputs

00:21:12,030 --> 00:21:14,910
that you want a portion put into the

00:21:14,130 --> 00:21:18,180
flowy

00:21:14,910 --> 00:21:21,420
structure to perform the lookup and then

00:21:18,180 --> 00:21:24,720
you ask for the desired for the desired

00:21:21,420 --> 00:21:26,640
part of the resulting output in the only

00:21:24,720 --> 00:21:28,530
thing that is called implement the COI F

00:21:26,640 --> 00:21:32,940
interface so that many of tables would

00:21:28,530 --> 00:21:35,220
place the would ask for the routing

00:21:32,940 --> 00:21:37,800
table and then it would place the output

00:21:35,220 --> 00:21:41,370
interface that occurs if the packet will

00:21:37,800 --> 00:21:42,840
be sent out by up into a register but we

00:21:41,370 --> 00:21:43,530
could easily implement for instance E

00:21:42,840 --> 00:21:45,900
and output in

00:21:43,530 --> 00:21:48,780
first name or the rotten gateway or

00:21:45,900 --> 00:21:51,440
whatever fire things we want in the

00:21:48,780 --> 00:21:55,710
future we go also has I already said

00:21:51,440 --> 00:21:59,510
implement the type of the address for

00:21:55,710 --> 00:21:59,510
instance broadcast multicast and so on

00:22:00,410 --> 00:22:06,000
so what you can do for instance you can

00:22:03,330 --> 00:22:06,960
ask just to relook up on the source

00:22:06,000 --> 00:22:09,240
address and give you the output

00:22:06,960 --> 00:22:12,240
interface or you can combine it with the

00:22:09,240 --> 00:22:15,710
packet mark to also consider policy

00:22:12,240 --> 00:22:15,710
routing tables and so on

00:22:16,310 --> 00:22:21,810
the only problem currently is that in

00:22:19,140 --> 00:22:24,270
the IP tables match there's an invert

00:22:21,810 --> 00:22:26,250
option waken and the singer will

00:22:24,270 --> 00:22:28,350
automatically discard any packets that

00:22:26,250 --> 00:22:32,220
do not pass the reverse fast reverse

00:22:28,350 --> 00:22:33,690
path test but the problem is that in end

00:22:32,220 --> 00:22:35,940
of tables we do not have these kind of

00:22:33,690 --> 00:22:38,160
location operations at all because the

00:22:35,940 --> 00:22:41,880
end of tables expressions are supposed

00:22:38,160 --> 00:22:44,880
to be much more generic so we need

00:22:41,880 --> 00:22:48,870
somewhere to turn blue in that or it

00:22:44,880 --> 00:22:52,140
would be nice to implement it so what we

00:22:48,870 --> 00:22:54,960
would actually need is to ask for a

00:22:52,140 --> 00:22:59,490
comparison is it not the input interface

00:22:54,960 --> 00:23:03,480
and to do that what we call but I'm

00:22:59,490 --> 00:23:06,690
currently doing is I'm using 0 as an

00:23:03,480 --> 00:23:09,300
invalid result so what you can actually

00:23:06,690 --> 00:23:11,580
do you can you can ask if the output

00:23:09,300 --> 00:23:13,110
interface is equal to zero gravity equal

00:23:11,580 --> 00:23:16,530
to 0 that basically means the kernel has

00:23:13,110 --> 00:23:18,390
no idea and can't fulfill your request

00:23:16,530 --> 00:23:21,780
and come to go out the appropriate and

00:23:18,390 --> 00:23:23,970
interface this already works

00:23:21,780 --> 00:23:27,450
Pablo has a different suggestion

00:23:23,970 --> 00:23:31,740
interpreter and at a found keyword in a

00:23:27,450 --> 00:23:34,140
not found keyword the idea is that we

00:23:31,740 --> 00:23:36,630
need similar boolean tests for some

00:23:34,140 --> 00:23:38,460
other things for instance if you want to

00:23:36,630 --> 00:23:40,320
figure out whether a packet has an

00:23:38,460 --> 00:23:42,950
extension header for instance erotic

00:23:40,320 --> 00:23:45,360
stand ipv6 routing extension header

00:23:42,950 --> 00:23:46,800
that's currently also not possible and

00:23:45,360 --> 00:23:49,770
we need some solution for that so that

00:23:46,800 --> 00:23:51,150
would make sense to reuse that I will

00:23:49,770 --> 00:23:54,650
have a look at this table send me some

00:23:51,150 --> 00:23:54,650
Patras but I have to look at it

00:23:56,500 --> 00:24:04,760
so another idea that we had what it was

00:24:00,890 --> 00:24:06,649
them to tread explicit castor because

00:24:04,760 --> 00:24:09,980
right now whatever what will happen if

00:24:06,649 --> 00:24:12,950
you asked for for instance for for it

00:24:09,980 --> 00:24:16,029
affairs and stand in the tables tool

00:24:12,950 --> 00:24:18,200
will expect and expect type compatible

00:24:16,029 --> 00:24:21,200
expression on the right hand side of the

00:24:18,200 --> 00:24:22,940
of the equals operator so if you ask for

00:24:21,200 --> 00:24:25,220
instance for 0 and it will tell you that

00:24:22,940 --> 00:24:27,740
0 is not an interface name because it

00:24:25,220 --> 00:24:32,029
would expect something like e th 0 or L

00:24:27,740 --> 00:24:34,220
or whatever so what we debated in the

00:24:32,029 --> 00:24:36,200
past is whether we would had expected

00:24:34,220 --> 00:24:39,140
casting so you can override these type

00:24:36,200 --> 00:24:40,730
checks but from the current discussions

00:24:39,140 --> 00:24:42,799
it seems that it's deemed too ugly and

00:24:40,730 --> 00:24:47,390
it would just blow the syntax so we will

00:24:42,799 --> 00:24:52,279
probably opt for implicit conversions

00:24:47,390 --> 00:24:53,600
when the types are compatible those

00:24:52,279 --> 00:24:56,630
other commentators as basically

00:24:53,600 --> 00:24:59,149
everything is done except the ipv6 part

00:24:56,630 --> 00:25:01,909
2 which currently only compiles I have

00:24:59,149 --> 00:25:05,630
not yet had time to probably check it

00:25:01,909 --> 00:25:07,340
and the only thing that is currently

00:25:05,630 --> 00:25:09,289
supported is to get the output interface

00:25:07,340 --> 00:25:12,080
I will also implement the output

00:25:09,289 --> 00:25:13,700
interface name and once that once both

00:25:12,080 --> 00:25:16,100
is done I will send that to problem

00:25:13,700 --> 00:25:19,940
nothing that I will work on the address

00:25:16,100 --> 00:25:25,270
type matching to submerge the address

00:25:19,940 --> 00:25:25,270
type mention any tables so any questions

00:25:29,909 --> 00:25:35,010
no good Pablo hey thanks

00:26:13,370 --> 00:26:17,139
so I kind of see what was in addition

00:26:14,749 --> 00:26:17,139
here

00:26:21,980 --> 00:26:27,850
oh yes it's here okay

00:26:30,930 --> 00:26:42,680
I don't know how to use this Thanks

00:26:44,180 --> 00:26:52,190
there's the subscribe a bit of the DVD

00:26:50,120 --> 00:26:53,930
updates that have happened on on the net

00:26:52,190 --> 00:26:57,290
physically since the last net the

00:26:53,930 --> 00:26:59,990
comprehensive basically we now have our

00:26:57,290 --> 00:27:01,370
net name space hook this has been

00:26:59,990 --> 00:27:03,170
something that we B to can see for a

00:27:01,370 --> 00:27:04,790
while basically what we are trying to

00:27:03,170 --> 00:27:07,460
achieve its improve integration of

00:27:04,790 --> 00:27:10,220
netfilter with containers so now what is

00:27:07,460 --> 00:27:15,050
going on is that in AP tables instead of

00:27:10,220 --> 00:27:17,090
producer reasoning IP tables from IP

00:27:15,050 --> 00:27:21,050
tables all hoops by default in every

00:27:17,090 --> 00:27:23,270
container we we only reduce to the hooks

00:27:21,050 --> 00:27:25,790
that we need the approach that is being

00:27:23,270 --> 00:27:31,730
follow is since IP tables doesn't have a

00:27:25,790 --> 00:27:34,070
mechanism to explicitly register the the

00:27:31,730 --> 00:27:36,020
hooks that we eat contrary to any tables

00:27:34,070 --> 00:27:37,640
where we explicitly indicate what hooks

00:27:36,020 --> 00:27:42,380
we need the approach that are happening

00:27:37,640 --> 00:27:44,480
follow is to as soon as we list the rule

00:27:42,380 --> 00:27:49,130
set first time the hooks are registering

00:27:44,480 --> 00:27:50,870
on in the namespace so basically radius

00:27:49,130 --> 00:27:53,210
not to have any impact on in

00:27:50,870 --> 00:27:56,540
performative if I be able to know it's

00:27:53,210 --> 00:27:58,060
not usable which it has been a common

00:27:56,540 --> 00:28:01,490
complaint from from users that

00:27:58,060 --> 00:28:03,890
performant has been decreasing with no

00:28:01,490 --> 00:28:09,100
use case without having any use case

00:28:03,890 --> 00:28:11,870
probably labels so next thing is the

00:28:09,100 --> 00:28:15,430
informational name stays push the

00:28:11,870 --> 00:28:21,170
explode infrastructure out of the

00:28:15,430 --> 00:28:24,830
cabinet I'm in class so since then then

00:28:21,170 --> 00:28:26,780
we discovered that basically that code

00:28:24,830 --> 00:28:28,430
was not properly reviewed to ensure that

00:28:26,780 --> 00:28:30,620
all the blocks that we were receiving

00:28:28,430 --> 00:28:33,320
from user space with with a roasted

00:28:30,620 --> 00:28:36,200
configuration we're probably probably is

00:28:33,320 --> 00:28:41,360
sanitized so which is correct quite a

00:28:36,200 --> 00:28:43,010
few books there hopefully we got patches

00:28:41,360 --> 00:28:44,120
of it around they they have been they

00:28:43,010 --> 00:28:47,030
have been by thought they'd been

00:28:44,120 --> 00:28:49,160
backwater to this table and actually

00:28:47,030 --> 00:28:51,350
there are some people still putting up

00:28:49,160 --> 00:28:53,300
with box that has been already resolved

00:28:51,350 --> 00:28:54,560
which is good so it seems so far we

00:28:53,300 --> 00:28:57,120
found we have found all the problems

00:28:54,560 --> 00:29:02,260
that that were that

00:28:57,120 --> 00:29:03,910
another problem the very sparse related

00:29:02,260 --> 00:29:08,309
within namespaces the fact that a hash

00:29:03,910 --> 00:29:11,050
table that we were using in contract was

00:29:08,309 --> 00:29:15,059
pregnant namespace now we have one

00:29:11,050 --> 00:29:18,610
single hash table for all net namespaces

00:29:15,059 --> 00:29:21,190
and this was causing also problems

00:29:18,610 --> 00:29:24,309
because they are stable when it's large

00:29:21,190 --> 00:29:26,830
enough its uses the in Malad and we can

00:29:24,309 --> 00:29:28,059
basically use all the physical memory of

00:29:26,830 --> 00:29:32,830
the system which is not good at all

00:29:28,059 --> 00:29:34,809
another change is the alignment or the

00:29:32,830 --> 00:29:36,880
interconnect structure to catch line

00:29:34,809 --> 00:29:42,490
just following the same approach as the

00:29:36,880 --> 00:29:46,990
escape of the above catch this clip of

00:29:42,490 --> 00:29:50,400
structure and Florian also converted

00:29:46,990 --> 00:29:52,510
that hash table to e2 to use the generic

00:29:50,400 --> 00:29:54,700
resizable hash table implementations

00:29:52,510 --> 00:29:57,130
that we have already in the kernel and

00:29:54,700 --> 00:30:03,429
so before that we were having a known

00:29:57,130 --> 00:30:06,520
unknown hash table we have in contract

00:30:03,429 --> 00:30:10,929
in we have extension that allows us to

00:30:06,520 --> 00:30:15,280
place things that are not are not

00:30:10,929 --> 00:30:17,320
usually used but we found that a long

00:30:15,280 --> 00:30:19,809
time some of these fields were quite

00:30:17,320 --> 00:30:25,990
quite used quite offensive there

00:30:19,809 --> 00:30:31,170
specifically the zones were a contract

00:30:25,990 --> 00:30:33,580
extensions and now we are equal in the

00:30:31,170 --> 00:30:35,860
focus on time for some little time we

00:30:33,580 --> 00:30:39,220
have been including the zones on the on

00:30:35,860 --> 00:30:42,040
the hashing so we this the zone and all

00:30:39,220 --> 00:30:44,350
the files have been moved away from the

00:30:42,040 --> 00:30:51,880
extension so now on the extensions area

00:30:44,350 --> 00:30:55,420
we only have what is probably used we

00:30:51,880 --> 00:30:58,390
remove the IP IP contract see CTL

00:30:55,420 --> 00:31:00,250
compare compatible this drop interfaces

00:30:58,390 --> 00:31:03,130
are now gone it's been ten years in

00:31:00,250 --> 00:31:06,820
space being around so we

00:31:03,130 --> 00:31:09,340
we don't have three interfaces to user

00:31:06,820 --> 00:31:11,830
space anymore we only have two probably

00:31:09,340 --> 00:31:14,889
someday we can get rid of any contract

00:31:11,830 --> 00:31:18,669
CC TL and just rely on the net link

00:31:14,889 --> 00:31:24,370
interface so I mean 10 years I guess

00:31:18,669 --> 00:31:27,130
it's enough and also got rid of primers

00:31:24,370 --> 00:31:30,639
this discrete approach we don't even use

00:31:27,130 --> 00:31:34,720
a primary structure anymore in an F

00:31:30,639 --> 00:31:36,519
contract instead instead we we have a

00:31:34,720 --> 00:31:39,490
work here and it's basically sweeping

00:31:36,519 --> 00:31:44,019
over the tail and F contract objects and

00:31:39,490 --> 00:31:47,049
getting rid of them so so we reduce

00:31:44,019 --> 00:31:53,080
basically reduce on the memory side of

00:31:47,049 --> 00:31:55,840
the net contract objects the helper hi

00:31:53,080 --> 00:31:58,419
man was helping enabled by the photo I

00:31:55,840 --> 00:32:00,759
allow this thing has been crossing

00:31:58,419 --> 00:32:03,070
security problems if Leblon already

00:32:00,759 --> 00:32:05,230
wrote an article about this I've been

00:32:03,070 --> 00:32:06,759
but because because this has been the

00:32:05,230 --> 00:32:09,250
default behavior since the beginning we

00:32:06,759 --> 00:32:13,419
have to keep it around for a while not

00:32:09,250 --> 00:32:15,879
recommending to you to use it so now

00:32:13,419 --> 00:32:16,690
it's finally disabled you can still you

00:32:15,879 --> 00:32:21,340
still have a chance

00:32:16,690 --> 00:32:27,250
no to avoid breaking your setup by by

00:32:21,340 --> 00:32:29,379
enabling it by us C CDL but there is

00:32:27,250 --> 00:32:32,769
enough documentation about and we still

00:32:29,379 --> 00:32:35,309
encouraging users not to not to use this

00:32:32,769 --> 00:32:41,710
anymore and they have a limit extension

00:32:35,309 --> 00:32:45,820
also god improved by supporting 64 bits

00:32:41,710 --> 00:32:49,029
per second resolution and on the NSA

00:32:45,820 --> 00:32:51,909
both side what we got is native in a

00:32:49,029 --> 00:32:55,539
queue support through the bridge family

00:32:51,909 --> 00:32:58,029
so forth so far the DNF be nfq support

00:32:55,539 --> 00:33:00,690
was coming through from the preach

00:32:58,029 --> 00:33:03,820
natural to the BR netfilter

00:33:00,690 --> 00:33:06,580
infrastructure and there is known to be

00:33:03,820 --> 00:33:09,129
causing loss of problems and not working

00:33:06,580 --> 00:33:13,700
accept exactly in the way that beuter

00:33:09,129 --> 00:33:15,800
are expecting so

00:33:13,700 --> 00:33:20,840
this is basically another step to

00:33:15,800 --> 00:33:23,030
deprecate breaching the filter and cut

00:33:20,840 --> 00:33:26,360
off updates on the send infrastructure

00:33:23,030 --> 00:33:28,610
now we are supporting adjutant branch in

00:33:26,360 --> 00:33:33,290
the set representation we need to steal

00:33:28,610 --> 00:33:36,220
a bit of code on in useless place to to

00:33:33,290 --> 00:33:39,680
basically match this adjustment range

00:33:36,220 --> 00:33:40,550
while while updating so basically if we

00:33:39,680 --> 00:33:42,710
have to

00:33:40,550 --> 00:33:45,170
so what did happen how this part at this

00:33:42,710 --> 00:33:47,510
moment is that we keep both the best

00:33:45,170 --> 00:33:50,300
objection drained ranges in the inner

00:33:47,510 --> 00:33:52,220
kernel but it should be very easy to

00:33:50,300 --> 00:33:53,630
implement from user space with a logic

00:33:52,220 --> 00:33:55,910
that we already have internal space it

00:33:53,630 --> 00:33:59,030
should be very possible just to remove

00:33:55,910 --> 00:34:02,120
the outer and the inner of the two

00:33:59,030 --> 00:34:04,460
adjacent frames so do we just live in

00:34:02,120 --> 00:34:07,160
the kernel one single range so another

00:34:04,460 --> 00:34:11,540
thing is if the add create semantics for

00:34:07,160 --> 00:34:17,120
elements basically users with

00:34:11,540 --> 00:34:21,440
complaining about the fact that it was

00:34:17,120 --> 00:34:28,419
not very handy the fact that adding a

00:34:21,440 --> 00:34:33,710
new element would cause a exists error

00:34:28,419 --> 00:34:37,280
so what we have now is that if you use

00:34:33,710 --> 00:34:39,020
NFC add element and the element exists

00:34:37,280 --> 00:34:41,450
already it's not going to complain and

00:34:39,020 --> 00:34:44,149
if you use create is going to say the

00:34:41,450 --> 00:34:47,740
element exists so depending on what you

00:34:44,149 --> 00:34:53,690
need is one common command of another

00:34:47,740 --> 00:34:56,360
well as we have support for deletion of

00:34:53,690 --> 00:35:01,010
inactive elements which may sound a bit

00:34:56,360 --> 00:35:03,680
crazy but basically we're aiming to to

00:35:01,010 --> 00:35:07,160
have better support for robots robots

00:35:03,680 --> 00:35:09,680
they can put several rule updates in a

00:35:07,160 --> 00:35:12,560
single batch and in that single update

00:35:09,680 --> 00:35:15,650
you may can introduce this element and

00:35:12,560 --> 00:35:17,420
then delete it so what is going on now I

00:35:15,650 --> 00:35:19,310
said just a few the kernel is going to

00:35:17,420 --> 00:35:20,740
notice that the add an element that is

00:35:19,310 --> 00:35:23,110
going to be deleted

00:35:20,740 --> 00:35:28,000
yes we validate the whole thing so the

00:35:23,110 --> 00:35:28,890
element doesn't show up what else we

00:35:28,000 --> 00:35:32,290
have

00:35:28,890 --> 00:35:36,580
riho new command for us to flush salad

00:35:32,290 --> 00:35:38,170
outside elements of us sad I have this I

00:35:36,580 --> 00:35:41,860
have to submit bachelor they are already

00:35:38,170 --> 00:35:44,830
ready so we have to flush command as we

00:35:41,860 --> 00:35:47,470
have four tables we have to change and

00:35:44,830 --> 00:35:51,010
we have four no no no now I'm going to

00:35:47,470 --> 00:35:53,080
have it four sets you've got to look at

00:35:51,010 --> 00:35:54,520
an inverted dynamic set element

00:35:53,080 --> 00:35:57,250
insertions they were to look at is

00:35:54,520 --> 00:36:01,270
basically just matching if an element is

00:35:57,250 --> 00:36:03,700
not in a sad and for dynamics head same

00:36:01,270 --> 00:36:05,560
said element in such insertions a bit

00:36:03,700 --> 00:36:10,900
keep these expressions allows us to

00:36:05,560 --> 00:36:15,250
introduce elements in set from the

00:36:10,900 --> 00:36:17,380
packet path and the the idea is to use

00:36:15,250 --> 00:36:18,780
this because because the flow table of

00:36:17,380 --> 00:36:24,220
generic infrastructure that we have

00:36:18,780 --> 00:36:28,450
depends on this dynamic set we can if we

00:36:24,220 --> 00:36:31,359
specify a eight side for that table we

00:36:28,450 --> 00:36:33,760
can we can catch when when when filling

00:36:31,359 --> 00:36:36,250
that that that flow table but that is

00:36:33,760 --> 00:36:38,970
actually represented by a set it's it's

00:36:36,250 --> 00:36:41,350
full so we can we can catch the overflow

00:36:38,970 --> 00:36:43,630
scenario and decide what to do with the

00:36:41,350 --> 00:36:49,660
packet that is not actually fitting into

00:36:43,630 --> 00:36:51,520
the flow table okay we got the key new

00:36:49,660 --> 00:36:53,619
expressions the logger has as is just

00:36:51,520 --> 00:36:55,470
explained we have another two just

00:36:53,619 --> 00:36:58,570
drains and quota basically with pick

00:36:55,470 --> 00:37:01,090
semantics that we have four GU to dispel

00:36:58,570 --> 00:37:02,980
rows headed is basically every every

00:37:01,090 --> 00:37:05,619
rules control of expressions and those

00:37:02,980 --> 00:37:07,720
expressions are evaluated in an and and

00:37:05,619 --> 00:37:10,840
and fashion and then every rule is or or

00:37:07,720 --> 00:37:13,570
or so with this semantics we cannot

00:37:10,840 --> 00:37:15,609
express inverted range so we need a

00:37:13,570 --> 00:37:18,490
specific way it reaches pressure which

00:37:15,609 --> 00:37:20,410
is the easiest way to make it and the

00:37:18,490 --> 00:37:24,490
Prada is basically allowing to define

00:37:20,410 --> 00:37:26,500
code at four four packets are also based

00:37:24,490 --> 00:37:28,040
on on connection tracking information

00:37:26,500 --> 00:37:31,580
currently all the packaging

00:37:28,040 --> 00:37:33,260
nation is or the only packet holidays it

00:37:31,580 --> 00:37:34,760
is always contact information but it

00:37:33,260 --> 00:37:36,650
should be possible to in to explain it

00:37:34,760 --> 00:37:41,510
to you to relay on the contract

00:37:36,650 --> 00:37:45,410
information so this correlation can be

00:37:41,510 --> 00:37:48,410
plugged into the inter flow table so we

00:37:45,410 --> 00:37:50,570
can basically plate based on packets we

00:37:48,410 --> 00:37:53,870
can populate the flow table with me

00:37:50,570 --> 00:37:56,270
entries and if I a specific quarter for

00:37:53,870 --> 00:37:59,810
every new element that is introduced in

00:37:56,270 --> 00:38:04,670
the flow in the flow table called legal

00:37:59,810 --> 00:38:06,140
support that was missing and an FQ

00:38:04,670 --> 00:38:10,460
integration with match of the water

00:38:06,140 --> 00:38:11,690
lacking so we will explore the deeper

00:38:10,460 --> 00:38:14,990
structures are very money available and

00:38:11,690 --> 00:38:17,420
enough tables so Aniki really was

00:38:14,990 --> 00:38:20,030
implementing that way that basically

00:38:17,420 --> 00:38:22,370
makes it work exactly the same way that

00:38:20,030 --> 00:38:26,570
I picked able to operate so you need one

00:38:22,370 --> 00:38:28,670
rule configuration now you can use maps

00:38:26,570 --> 00:38:30,650
and using maps means that you with one

00:38:28,670 --> 00:38:34,250
single word you can decide to walk you

00:38:30,650 --> 00:38:36,710
you want to send a packet so that's very

00:38:34,250 --> 00:38:39,050
important exploit the map infrastructure

00:38:36,710 --> 00:38:43,130
so we basically reduce many many lots of

00:38:39,050 --> 00:38:45,800
fixes we've been also visiting the INF

00:38:43,130 --> 00:38:48,880
hopes people say in a foods are as low

00:38:45,800 --> 00:38:51,050
so we are going to get this posture so

00:38:48,880 --> 00:38:53,270
fast studying the confession is

00:38:51,050 --> 00:38:56,180
Doublemint list has been replaced by a

00:38:53,270 --> 00:38:59,990
single linked list and the next step is

00:38:56,180 --> 00:39:02,270
ongoing and and we we expect you to make

00:38:59,990 --> 00:39:04,760
it line in in the tree soon if the

00:39:02,270 --> 00:39:06,800
confession to a arrive it will help us

00:39:04,760 --> 00:39:09,440
to explore it a bit better the cache

00:39:06,800 --> 00:39:12,110
locality so basically we expect to find

00:39:09,440 --> 00:39:14,600
for hooks in the cache line so should

00:39:12,110 --> 00:39:16,460
speed up things hopefully we would like

00:39:14,600 --> 00:39:18,590
to duplicate the nf stop it's not

00:39:16,460 --> 00:39:20,630
exactly equivalent to an effect set of

00:39:18,590 --> 00:39:22,940
being discussing with Florian if this is

00:39:20,630 --> 00:39:26,060
only used by the bridge by the BR and a

00:39:22,940 --> 00:39:29,000
filter infrastructure that is something

00:39:26,060 --> 00:39:32,320
that is a side that is causing lots of

00:39:29,000 --> 00:39:35,840
problems and it got lots of design

00:39:32,320 --> 00:39:38,570
mistakes in it so we are just going to

00:39:35,840 --> 00:39:40,610
gather enough stuff out of the core

00:39:38,570 --> 00:39:43,670
the cause of adding a bit more code to

00:39:40,610 --> 00:39:47,450
the BR netfilter thing that is the only

00:39:43,670 --> 00:39:49,420
one is and using it so another thing is

00:39:47,450 --> 00:39:52,880
to get enough Q out of after Auto the

00:39:49,420 --> 00:39:56,450
record path so basically the idea is to

00:39:52,880 --> 00:39:59,720
together in a few handling plays it

00:39:56,450 --> 00:40:01,820
plays it in a new and if Q function and

00:39:59,720 --> 00:40:06,440
that and if Q function is going to be

00:40:01,820 --> 00:40:07,130
worked from from X T and a Q or from

00:40:06,440 --> 00:40:11,030
NFTE

00:40:07,130 --> 00:40:13,070
Q certainly and after this changes what

00:40:11,030 --> 00:40:15,590
we have we have in the tree is just

00:40:13,070 --> 00:40:18,200
handling for three birthdate so that

00:40:15,590 --> 00:40:21,620
basically except drop in stolen stolen

00:40:18,200 --> 00:40:25,580
just to say that you kind of know you or

00:40:21,620 --> 00:40:28,070
a user space application has taken the

00:40:25,580 --> 00:40:31,880
packet and not didn't return it so you

00:40:28,070 --> 00:40:34,250
just define it escape at so just very

00:40:31,880 --> 00:40:36,280
little verdicts to handle and actually

00:40:34,250 --> 00:40:39,470
very simple actions to pay on them and

00:40:36,280 --> 00:40:41,840
given that after that and if hoops law

00:40:39,470 --> 00:40:49,490
is going to become very small we can we

00:40:41,840 --> 00:41:05,450
can inline it other punks so we are

00:40:49,490 --> 00:41:09,860
looking into a 8086 research chip if it

00:41:05,450 --> 00:41:13,930
provides 253 hit 55 who entries in a tea

00:41:09,860 --> 00:41:16,370
can its rule base it provides matches

00:41:13,930 --> 00:41:22,280
basically you can match everything that

00:41:16,370 --> 00:41:24,440
frame up to 47 miles and it got actions

00:41:22,280 --> 00:41:26,890
and the cotton is a bit it's a bit

00:41:24,440 --> 00:41:30,470
different actually

00:41:26,890 --> 00:41:33,340
it's it got a flow table and this needs

00:41:30,470 --> 00:41:36,050
to be populated from the packet path so

00:41:33,340 --> 00:41:39,080
the fact that we receive from the open

00:41:36,050 --> 00:41:42,080
wrt people or leader basically are

00:41:39,080 --> 00:41:46,710
offloading our ears in the contract

00:41:42,080 --> 00:41:50,280
infrastructure to 280 table but this is

00:41:46,710 --> 00:41:52,109
actually quite far from the contact

00:41:50,280 --> 00:41:54,570
semantics contract is to lots of things

00:41:52,109 --> 00:41:56,700
so this is matching way better with the

00:41:54,570 --> 00:42:02,070
flora table definition that we have in

00:41:56,700 --> 00:42:07,349
NS tables so basically the idea is to to

00:42:02,070 --> 00:42:09,510
put these chairs just to define table

00:42:07,349 --> 00:42:10,740
whether with a flow table definition

00:42:09,510 --> 00:42:14,660
that's going to show up since the

00:42:10,740 --> 00:42:19,140
beginning already complete configure

00:42:14,660 --> 00:42:21,150
kind of a configuration and then you can

00:42:19,140 --> 00:42:22,589
easily be a standard facilities to this

00:42:21,150 --> 00:42:24,359
and that commands in a table just to

00:42:22,589 --> 00:42:26,270
list the content of the flow table of

00:42:24,359 --> 00:42:29,040
flashes or whatever you need

00:42:26,270 --> 00:42:30,960
the idea of law should be easy I mean

00:42:29,040 --> 00:42:33,900
with infrastructure first switch offload

00:42:30,960 --> 00:42:37,190
it should be also very easy with your

00:42:33,900 --> 00:42:39,510
mother just based on the NFT

00:42:37,190 --> 00:42:45,330
representation native representation

00:42:39,510 --> 00:42:46,589
just ameet the the MPI instruction so

00:42:45,330 --> 00:42:50,970
need to happen I've been looking at

00:42:46,589 --> 00:42:53,550
antibody that the National has submit to

00:42:50,970 --> 00:42:55,170
the death for BPA and I would expect

00:42:53,550 --> 00:43:02,810
that the driver for Nattie will be much

00:42:55,170 --> 00:43:06,410
more simple and another thing that it's

00:43:02,810 --> 00:43:09,510
got a very simple proof of concept you

00:43:06,410 --> 00:43:12,750
get some numbers

00:43:09,510 --> 00:43:15,660
it's a Jade using PPR escape the idea

00:43:12,750 --> 00:43:17,849
would be just to take the scene with the

00:43:15,660 --> 00:43:22,109
in here just take the the NFT

00:43:17,849 --> 00:43:25,530
representation and generate generate BPF

00:43:22,109 --> 00:43:28,109
echo this comes with many many good

00:43:25,530 --> 00:43:31,530
things as just reducing complexity quite

00:43:28,109 --> 00:43:34,740
a lot so we actually don't need to

00:43:31,530 --> 00:43:39,089
invoke pvp a very fire the enough tables

00:43:34,740 --> 00:43:41,970
from 10 will verify already that no

00:43:39,089 --> 00:43:46,440
crazy things happens no loops no no

00:43:41,970 --> 00:43:48,690
illegal stuff and the BBS code unit byte

00:43:46,440 --> 00:43:55,119
code generation will happen from from

00:43:48,690 --> 00:43:59,559
the kernel itself and that's

00:43:55,119 --> 00:44:01,809
so just to finish the lots of ongoing

00:43:59,559 --> 00:44:04,329
discussions about on probability and

00:44:01,809 --> 00:44:07,029
this conference so let's let's melt away

00:44:04,329 --> 00:44:09,339
the NFC where your the NFC approach for

00:44:07,029 --> 00:44:13,599
this problem so in an Estill we have a

00:44:09,339 --> 00:44:16,539
network specific VM it's facing four

00:44:13,599 --> 00:44:18,609
byte code verification we don't even

00:44:16,539 --> 00:44:20,740
pass pointers between our expressions

00:44:18,609 --> 00:44:22,690
that are our I mean our instructions we

00:44:20,740 --> 00:44:25,269
have very little expression that is

00:44:22,690 --> 00:44:32,369
instructions network a specific we have

00:44:25,269 --> 00:44:32,369
we can address register are 32 128 just

00:44:32,880 --> 00:44:37,750
provide an any interface Pacific very

00:44:35,559 --> 00:44:40,329
common interface that we we have already

00:44:37,750 --> 00:44:42,160
for other networking subsystem so that

00:44:40,329 --> 00:44:43,509
is factly the batteries are flexible so

00:44:42,160 --> 00:44:45,069
let's try to reuse the components that

00:44:43,509 --> 00:44:49,960
we have new kernel and if tables is in

00:44:45,069 --> 00:44:52,599
the kernel so what we can do is slowly

00:44:49,960 --> 00:44:54,700
exposed we when I we are now going to

00:44:52,599 --> 00:44:57,940
have a fifth pression we could use this

00:44:54,700 --> 00:45:02,500
fix its expression from ingress so we

00:44:57,940 --> 00:45:04,750
can just define our theta part you can

00:45:02,500 --> 00:45:08,319
remove the years but in case that for

00:45:04,750 --> 00:45:10,599
example we want to just look up on said

00:45:08,319 --> 00:45:13,930
and then decide on what interface to put

00:45:10,599 --> 00:45:17,549
the packet just make the rule to achieve

00:45:13,930 --> 00:45:20,980
this similar thing could be done with a

00:45:17,549 --> 00:45:22,210
socket expression so we basically look

00:45:20,980 --> 00:45:25,289
up for the socket and they find some

00:45:22,210 --> 00:45:28,299
since that back to deliver the packet I

00:45:25,289 --> 00:45:31,119
mean say many I will apply to all

00:45:28,299 --> 00:45:32,650
existing components so the best thing

00:45:31,119 --> 00:45:37,089
about raising the existing component in

00:45:32,650 --> 00:45:39,339
kernel is that applications kind of

00:45:37,089 --> 00:45:41,289
still years exist in early interfaces to

00:45:39,339 --> 00:45:43,509
configure them so potentially all

00:45:41,289 --> 00:45:48,400
existing applications would not need to

00:45:43,509 --> 00:45:53,619
be rebreathing to to to integrate with

00:45:48,400 --> 00:45:55,509
this approach so then we just plug this

00:45:53,619 --> 00:45:58,950
and a few instructions expressions we

00:45:55,509 --> 00:46:02,250
use the term to the first year so

00:45:58,950 --> 00:46:03,810
just like this this instructions just to

00:46:02,250 --> 00:46:06,750
define this path and the way you want

00:46:03,810 --> 00:46:10,320
and and the way to express all this will

00:46:06,750 --> 00:46:13,490
be rule base syntax that combined with

00:46:10,320 --> 00:46:15,570
the map infrastructure that we have

00:46:13,490 --> 00:46:19,220
resulted in our linear rules that

00:46:15,570 --> 00:46:23,460
inspection anymore basically we can just

00:46:19,220 --> 00:46:26,880
we will represent the whole set in a

00:46:23,460 --> 00:46:28,890
three fashion with mat that will point

00:46:26,880 --> 00:46:31,710
in the next in case we have to perform

00:46:28,890 --> 00:46:33,900
and then annex another lookup so with

00:46:31,710 --> 00:46:39,510
very little lookups we find what we have

00:46:33,900 --> 00:46:42,380
to do with so that's basically it so in

00:46:39,510 --> 00:46:42,380
case you have any question

00:46:50,390 --> 00:46:56,729
you know I've been asked here is some

00:46:53,369 --> 00:46:59,579
more plan on pretty city world where we

00:46:56,729 --> 00:46:59,999
debated before IPSec I think it is still

00:46:59,579 --> 00:47:02,509
missing

00:46:59,999 --> 00:47:06,569
yes this is missing actually I've been

00:47:02,509 --> 00:47:09,209
talking to stiffen it's nothing will

00:47:06,569 --> 00:47:12,019
like to find you you've been having a

00:47:09,209 --> 00:47:15,019
low-key in two days ago you like to talk

00:47:12,019 --> 00:47:15,019
yes

00:47:19,400 --> 00:47:24,290
so the reality is that most people

00:47:21,800 --> 00:47:27,860
actually don't really use the policy

00:47:24,290 --> 00:47:29,390
match they just ask for what the second

00:47:27,860 --> 00:47:32,420
ever is subject to like it's a

00:47:29,390 --> 00:47:34,460
prosthetic they don't most people don't

00:47:32,420 --> 00:47:38,120
use all these options where you can

00:47:34,460 --> 00:47:41,300
match the specific policies so one idea

00:47:38,120 --> 00:47:44,300
was to just add to extend the meta

00:47:41,300 --> 00:47:47,180
expression to ask is there a sec past

00:47:44,300 --> 00:47:50,270
time for the package that would be six

00:47:47,180 --> 00:47:51,770
line competitors using like that and

00:47:50,270 --> 00:47:54,440
that's probably what we will do and then

00:47:51,770 --> 00:47:57,050
if someone comes along and really has a

00:47:54,440 --> 00:48:02,080
use case where your meters to match

00:47:57,050 --> 00:48:02,080
specific policies them added later

00:48:04,880 --> 00:48:12,410
Thanks I wonder what your opinions are

00:48:09,380 --> 00:48:22,220
about that four six and not six four

00:48:12,410 --> 00:48:23,690
verses and of tables but it's I mean

00:48:22,220 --> 00:48:28,989
I've really seen implementations from

00:48:23,690 --> 00:48:31,220
other people that were very ugly indeed

00:48:28,989 --> 00:48:32,930
there are quite many of them on the

00:48:31,220 --> 00:48:35,779
internet also that uses face

00:48:32,930 --> 00:48:38,029
intimidation using is intact but it's

00:48:35,779 --> 00:48:39,410
something that we would like to we would

00:48:38,029 --> 00:48:43,190
like to have it shouldn't be very hard

00:48:39,410 --> 00:48:44,779
to to to make this fit into the

00:48:43,190 --> 00:48:47,569
infrastructure that we have we only need

00:48:44,779 --> 00:48:49,640
just to be a little careful in with

00:48:47,569 --> 00:48:52,700
contract we were going to have couples

00:48:49,640 --> 00:48:55,789
that are going to basically store

00:48:52,700 --> 00:48:58,279
information about IP for a b6o ip6 I'd

00:48:55,789 --> 00:49:01,759
be poor depending on on the direction of

00:48:58,279 --> 00:49:05,720
the packets and then many many many

00:49:01,759 --> 00:49:07,400
things like mapping ICMP this is a style

00:49:05,720 --> 00:49:09,619
of a many other people have to work on

00:49:07,400 --> 00:49:14,450
already so we can already have a look at

00:49:09,619 --> 00:49:18,019
what they did and just today so not sure

00:49:14,450 --> 00:49:19,759
do you have patches matter not based on

00:49:18,019 --> 00:49:24,049
enough tables I've been taking a look at

00:49:19,759 --> 00:49:27,529
making a device to basically do that but

00:49:24,049 --> 00:49:28,969
I'm wondering you know if EVP F or some

00:49:27,529 --> 00:49:30,680
sort of integration with enough tables

00:49:28,969 --> 00:49:38,569
or IP tables or something would be a

00:49:30,680 --> 00:49:43,640
better match later so we did the tested

00:49:38,569 --> 00:49:45,739
implementation in and but it doesn't

00:49:43,640 --> 00:49:49,670
support all the things but like the

00:49:45,739 --> 00:49:51,410
basic stuff is working I use it for

00:49:49,670 --> 00:49:53,210
condom for containers like when they

00:49:51,410 --> 00:49:57,890
have only ipv4 support and we can

00:49:53,210 --> 00:49:59,979
translate that so but yeah just as an

00:49:57,890 --> 00:49:59,979
example

00:50:02,740 --> 00:50:07,930
I guess I should get some consensus at

00:50:06,160 --> 00:50:13,660
some point about what is the right way

00:50:07,930 --> 00:50:17,710
to do this they're not not that 64 do

00:50:13,660 --> 00:50:20,680
you mean we have the infrastructure to

00:50:17,710 --> 00:50:22,510
make it I mean I see no reason to the

00:50:20,680 --> 00:50:27,609
can you see any reason to that prevents

00:50:22,510 --> 00:50:30,420
not introducing this Annette filter yeah

00:50:27,609 --> 00:50:30,420
I don't know what I'm asking

00:50:40,520 --> 00:50:44,520
so I think I looked at that a long long

00:50:42,690 --> 00:50:46,440
long time ago and maybe it didn't even

00:50:44,520 --> 00:50:49,550
look at the right place but it seemed

00:50:46,440 --> 00:50:52,140
like the the cooks are fundamentally not

00:50:49,550 --> 00:50:55,349
like they fundamentally weren't willing

00:50:52,140 --> 00:50:58,680
to turn a packet from one run proto into

00:50:55,349 --> 00:51:00,240
a different proto but perhaps I misread

00:50:58,680 --> 00:51:02,790
it right because obviously you have this

00:51:00,240 --> 00:51:04,230
ipv4 packet coming in and then at some

00:51:02,790 --> 00:51:06,390
point in the net filter Herc it turns

00:51:04,230 --> 00:51:07,770
into an ipv6 packet and you're kind of

00:51:06,390 --> 00:51:09,390
like you're in the wrong address family

00:51:07,770 --> 00:51:13,290
and so on so I don't know if that's is

00:51:09,390 --> 00:51:17,790
that now easy to do so your interface

00:51:13,290 --> 00:51:22,440
explicitly is an at 64 problem not for

00:51:17,790 --> 00:51:27,630
six potentially yes I didn't really

00:51:22,440 --> 00:51:32,790
spend on time on bad word receive

00:51:27,630 --> 00:51:34,859
patches as a bit of a hack and I using

00:51:32,790 --> 00:51:38,490
the area networking researcher to make

00:51:34,859 --> 00:51:41,220
it so I would look into that I now have

00:51:38,490 --> 00:51:43,520
a strong opinion on air but at this

00:51:41,220 --> 00:51:43,520
point

00:51:48,930 --> 00:51:53,920
but anyway I mean if it becomes

00:51:51,850 --> 00:51:57,760
unfeasible you'll be the first to know

00:51:53,920 --> 00:52:02,070
right it's not about we are going to

00:51:57,760 --> 00:52:02,070
push ahead with the colonel no way

00:52:06,860 --> 00:52:10,780
so if there are any any other question

00:52:18,440 --> 00:52:23,240
okay there are no more questions I think

00:52:20,990 --> 00:52:24,190
we will have a bit more time or break

00:52:23,240 --> 00:52:34,970
right

00:52:24,190 --> 00:52:37,240
good thank you oh he's already got rid

00:52:34,970 --> 00:52:37,240

YouTube URL: https://www.youtube.com/watch?v=wfWMPlZHQBk


