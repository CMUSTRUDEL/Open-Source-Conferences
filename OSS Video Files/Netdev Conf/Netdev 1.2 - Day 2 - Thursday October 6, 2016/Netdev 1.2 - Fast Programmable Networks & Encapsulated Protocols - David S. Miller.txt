Title: Netdev 1.2 - Fast Programmable Networks & Encapsulated Protocols - David S. Miller
Publication date: 2016-10-07
Playlist: Netdev 1.2 - Day 2 - Thursday October 6, 2016
Description: 
	http://netdevconf.org/1.2/session.html?david-miller-keynote
Captions: 
	00:00:09,639 --> 00:00:17,660
privilege of introducing our keynote

00:00:12,620 --> 00:00:18,980
speaker for today so I have been I guess

00:00:17,660 --> 00:00:22,579
working in Linux for about five years

00:00:18,980 --> 00:00:23,960
and I remember the first patch that I

00:00:22,579 --> 00:00:27,050
sent to net that it was actually

00:00:23,960 --> 00:00:28,460
received package steering and I don't

00:00:27,050 --> 00:00:30,380
know what I was doing I just sent the

00:00:28,460 --> 00:00:32,210
patch we'd actually had it running for a

00:00:30,380 --> 00:00:36,379
while looked pretty good to me so I sent

00:00:32,210 --> 00:00:38,420
it on met dev and the sky responds and

00:00:36,379 --> 00:00:40,520
he's like why would we need this we have

00:00:38,420 --> 00:00:44,019
this in hardware it's completely useless

00:00:40,520 --> 00:00:46,969
go away so the name was Dave Nolan and

00:00:44,019 --> 00:00:48,649
so I get this and I'm like what a jerk I

00:00:46,969 --> 00:00:52,550
mean he doesn't know anything about this

00:00:48,649 --> 00:00:54,319
so I did the wise thing I went and I

00:00:52,550 --> 00:00:56,269
looked under documentation right about

00:00:54,319 --> 00:00:59,059
how to submit a patch learn about

00:00:56,269 --> 00:01:02,510
persistence the idiosyncrasies of

00:00:59,059 --> 00:01:05,420
maintainer somehow got some good good

00:01:02,510 --> 00:01:08,240
guidelines on that so we listened to

00:01:05,420 --> 00:01:09,770
that and got the patches in and some

00:01:08,240 --> 00:01:13,719
more patches and things like that

00:01:09,770 --> 00:01:20,329
and since then I've learned a few things

00:01:13,719 --> 00:01:22,610
about Dave so one I don't comprehend how

00:01:20,329 --> 00:01:26,689
he handles this workload it's amazing

00:01:22,610 --> 00:01:29,780
it's so many patches coming in and he

00:01:26,689 --> 00:01:32,240
looks at all of them has knowledge

00:01:29,780 --> 00:01:36,259
across all of the networking subsystem

00:01:32,240 --> 00:01:39,590
can knows the details about everything

00:01:36,259 --> 00:01:42,590
so that's just an comprehensive and it's

00:01:39,590 --> 00:01:45,320
just amazing but one of the side effects

00:01:42,590 --> 00:01:46,579
of that is that you know we leverage

00:01:45,320 --> 00:01:49,609
that we're getting a lot of benefit out

00:01:46,579 --> 00:01:51,000
that so that's super important one of

00:01:49,609 --> 00:01:53,130
the other things I learned

00:01:51,000 --> 00:01:55,320
he admits this if you mean think

00:01:53,130 --> 00:02:00,960
personally it's easier to get your

00:01:55,320 --> 00:02:02,580
patches in so that's why I think

00:02:00,960 --> 00:02:05,190
conference like this is just awesome to

00:02:02,580 --> 00:02:08,009
have face time with Dave actually helps

00:02:05,190 --> 00:02:10,050
a lot but start saying and probably most

00:02:08,009 --> 00:02:13,110
important that I learned is he's just

00:02:10,050 --> 00:02:17,010
actually a nice guy genuinely genuinely

00:02:13,110 --> 00:02:20,730
nice really is interested in what we're

00:02:17,010 --> 00:02:23,000
doing the technology and I think his

00:02:20,730 --> 00:02:26,580
goal is purpose really is to facilitate

00:02:23,000 --> 00:02:29,690
moving us for getting an intern in there

00:02:26,580 --> 00:02:31,709
for it actually so I view it as

00:02:29,690 --> 00:02:34,950
considering the whole Internet and the

00:02:31,709 --> 00:02:37,170
value of links to it and the value of

00:02:34,950 --> 00:02:39,200
the networking stack to Linux to me this

00:02:37,170 --> 00:02:41,880
is like one of the critical pieces of

00:02:39,200 --> 00:02:44,160
the whole internet the whole world so

00:02:41,880 --> 00:02:49,170
it's not insignificant your

00:02:44,160 --> 00:02:51,630
contributions who is that attention to

00:02:49,170 --> 00:02:53,840
this our network maintainer illustrious

00:02:51,630 --> 00:02:53,840
leader

00:03:00,239 --> 00:03:04,870
this is a song yes it is so first of all

00:03:03,700 --> 00:03:06,190
I don't think I can live up to the

00:03:04,870 --> 00:03:11,099
expectations that has you've just been

00:03:06,190 --> 00:03:11,099
set forward by mr. Herbert thanks a lot

00:03:12,420 --> 00:03:18,730
so today we're going to talk about some

00:03:15,730 --> 00:03:21,610
important topics one is what I think is

00:03:18,730 --> 00:03:23,530
the feature of the year to be quite

00:03:21,610 --> 00:03:25,420
blunt and the other is something that we

00:03:23,530 --> 00:03:26,800
need to think really hard about whether

00:03:25,420 --> 00:03:28,840
we want to do or not is more of a

00:03:26,800 --> 00:03:33,910
controversial kind of not so

00:03:28,840 --> 00:03:36,250
straightforward issue so okay so let's

00:03:33,910 --> 00:03:37,900
talk about optimizations and where these

00:03:36,250 --> 00:03:41,160
optimizations occur where does packet

00:03:37,900 --> 00:03:44,700
processing occur why is this important

00:03:41,160 --> 00:03:46,780
so Linux has a really feature-rich

00:03:44,700 --> 00:03:47,830
networking stack and you can do all

00:03:46,780 --> 00:03:49,840
kinds of things you can do

00:03:47,830 --> 00:03:52,510
classification you can mangle packets

00:03:49,840 --> 00:03:54,190
you can have a million different ways of

00:03:52,510 --> 00:03:56,440
directing where the traffic goes by

00:03:54,190 --> 00:03:59,680
forwarding tables by net filter rules by

00:03:56,440 --> 00:04:02,620
mirrored actions and TC anything but

00:03:59,680 --> 00:04:03,730
this has a cost the cost is that you

00:04:02,620 --> 00:04:05,260
have to go all the way down into

00:04:03,730 --> 00:04:06,880
networking stack and commit to the

00:04:05,260 --> 00:04:10,390
entire networking stack in order to get

00:04:06,880 --> 00:04:12,190
these features and the call chains are

00:04:10,390 --> 00:04:14,019
quite deep sometimes there's memory

00:04:12,190 --> 00:04:17,430
references there's all this overhead I

00:04:14,019 --> 00:04:19,479
mean it's it's really a huge scope of

00:04:17,430 --> 00:04:20,890
what has to happen for all these

00:04:19,479 --> 00:04:22,780
features to be supported by Linux

00:04:20,890 --> 00:04:24,160
networking stack and that's why it's so

00:04:22,780 --> 00:04:25,900
hard to test the networking stack

00:04:24,160 --> 00:04:29,889
completely - these two things go hand in

00:04:25,900 --> 00:04:32,440
hand so if you've got rid of all that

00:04:29,889 --> 00:04:34,090
crap and you just went as low as you

00:04:32,440 --> 00:04:36,010
possibly could go then you could reach

00:04:34,090 --> 00:04:39,729
the theoretical optimal level of

00:04:36,010 --> 00:04:42,520
performance and but the thing is once

00:04:39,729 --> 00:04:44,139
you go low you lose all that that stuff

00:04:42,520 --> 00:04:46,510
that we like to use in Linux and

00:04:44,139 --> 00:04:49,960
theoretically we lose generality but not

00:04:46,510 --> 00:04:51,669
necessarily so so how do we make the

00:04:49,960 --> 00:04:56,440
impossible the seemingly impossible

00:04:51,669 --> 00:04:58,870
happen and enter X DP so XQ is the

00:04:56,440 --> 00:05:00,580
express data path what do you need to

00:04:58,870 --> 00:05:01,060
understand about this so the idea is

00:05:00,580 --> 00:05:04,090
that

00:05:01,060 --> 00:05:07,210
TP is a mechanism by which to run eb PF

00:05:04,090 --> 00:05:08,830
programs EVP f is the extension to the

00:05:07,210 --> 00:05:10,600
berkeley packet filter if you haven't

00:05:08,830 --> 00:05:13,389
heard about it yet but where have you

00:05:10,600 --> 00:05:16,120
been if not so Bowser explain a little

00:05:13,389 --> 00:05:20,620
bit about it it's a general abstraction

00:05:16,120 --> 00:05:22,240
for processing it executes spy codes and

00:05:20,620 --> 00:05:24,400
in the kernel we have various chits to

00:05:22,240 --> 00:05:27,430
execute this bytecode another important

00:05:24,400 --> 00:05:29,260
aspect of BPF and equal okay when I say

00:05:27,430 --> 00:05:30,310
PPF I'm going to meet EP PF so you can

00:05:29,260 --> 00:05:31,450
just gonna have to translate in your

00:05:30,310 --> 00:05:35,440
head while I'm talking for the rest of

00:05:31,450 --> 00:05:37,900
the slide we have just for BPF which

00:05:35,440 --> 00:05:40,750
means that we translate the BPF byte

00:05:37,900 --> 00:05:44,290
codes into CPU instructions which means

00:05:40,750 --> 00:05:48,240
it executes that CPU late the other

00:05:44,290 --> 00:05:51,250
thing that's really important is the

00:05:48,240 --> 00:05:53,500
restrict restrictions we place upon BPF

00:05:51,250 --> 00:05:55,270
programs this means that BPF executes in

00:05:53,500 --> 00:05:57,520
a sort of black box it can't access

00:05:55,270 --> 00:05:59,830
arbitrary Clairol memory it can't do

00:05:57,520 --> 00:06:01,930
arbitrary things inside the kernel it

00:05:59,830 --> 00:06:03,370
there's a set of things that it's

00:06:01,930 --> 00:06:05,500
allowed to do and if it needs to do

00:06:03,370 --> 00:06:08,229
certain things we have special helpers

00:06:05,500 --> 00:06:09,850
that BPF provides that the vp of program

00:06:08,229 --> 00:06:11,320
can call there are restrictions on what

00:06:09,850 --> 00:06:13,210
kind of tables that can access and how

00:06:11,320 --> 00:06:14,890
those tables are set up so if it wants

00:06:13,210 --> 00:06:16,990
to use data structures it can but only

00:06:14,890 --> 00:06:18,550
in a certain way it's really important

00:06:16,990 --> 00:06:20,650
that you think that this is this is an

00:06:18,550 --> 00:06:22,210
execution environment it sits in a very

00:06:20,650 --> 00:06:27,160
tightly controlled black box and that's

00:06:22,210 --> 00:06:30,280
really important so let's go back to how

00:06:27,160 --> 00:06:32,410
BPF applies to x DP x DP execute right

00:06:30,280 --> 00:06:35,169
in the receiving handler of the

00:06:32,410 --> 00:06:37,510
networking driver right as soon as the

00:06:35,169 --> 00:06:40,300
packet is pulled off the rig there is no

00:06:37,510 --> 00:06:42,280
earlier point that we could do packet

00:06:40,300 --> 00:06:44,380
processing than where the x TP hook is

00:06:42,280 --> 00:06:46,780
it is absolutely impossible to process

00:06:44,380 --> 00:06:48,639
the packet more quickly this is exactly

00:06:46,780 --> 00:06:52,270
as deep as you possibly can go with it

00:06:48,639 --> 00:06:55,630
with with hooks an execution of acadec a

00:06:52,270 --> 00:06:57,280
dies and packet handling um the other

00:06:55,630 --> 00:06:59,530
thing that's really important about this

00:06:57,280 --> 00:07:01,550
it why not you pull the packet off the

00:06:59,530 --> 00:07:04,790
ring we don't want to have that

00:07:01,550 --> 00:07:06,470
the SKF metadata that's critically

00:07:04,790 --> 00:07:07,940
important as well the location of the

00:07:06,470 --> 00:07:10,240
hook and the fact that we haven't

00:07:07,940 --> 00:07:13,190
committed to the metadata for the packet

00:07:10,240 --> 00:07:14,750
the escrow buffer is huge and in any

00:07:13,190 --> 00:07:16,430
everyone in this room who's ever tried

00:07:14,750 --> 00:07:18,260
to add a member to Esquibel know that

00:07:16,430 --> 00:07:20,600
that's I'm going to shoot that patch

00:07:18,260 --> 00:07:23,060
down almost immediately there would have

00:07:20,600 --> 00:07:25,190
to be I would have to solve world peace

00:07:23,060 --> 00:07:26,960
to allow it for me to allow you to add

00:07:25,190 --> 00:07:29,270
another member to SK but that's how bad

00:07:26,960 --> 00:07:32,120
it's gotten we've had cases in the past

00:07:29,270 --> 00:07:33,890
where I can even remember a case from 15

00:07:32,120 --> 00:07:36,800
to 20 years ago that just adding one

00:07:33,890 --> 00:07:40,690
member throughout the performance is 64

00:07:36,800 --> 00:07:43,970
when a simple benchmark by 20 to 30%

00:07:40,690 --> 00:07:47,300
it's serious business and the

00:07:43,970 --> 00:07:48,590
flexibility of the this this thing I

00:07:47,300 --> 00:07:50,450
talked about earlier when you have to go

00:07:48,590 --> 00:07:52,700
all the way in and commit to the entire

00:07:50,450 --> 00:07:55,130
networking stack and the cost there in

00:07:52,700 --> 00:07:56,690
the SK both metadata is a part of that

00:07:55,130 --> 00:07:57,500
overhead as well so that's another thing

00:07:56,690 --> 00:08:00,590
to consider

00:07:57,500 --> 00:08:03,380
then what xtp does is it defines a very

00:08:00,590 --> 00:08:05,390
absolute minimum piece of metadata state

00:08:03,380 --> 00:08:07,760
to operate on packets when you execute

00:08:05,390 --> 00:08:10,790
the BPF instructions this means you just

00:08:07,760 --> 00:08:12,950
get enough information to know where the

00:08:10,790 --> 00:08:15,140
packet data is and how long the buffer

00:08:12,950 --> 00:08:16,880
is the other restriction is that the

00:08:15,140 --> 00:08:18,770
buffer is linear which simplifies things

00:08:16,880 --> 00:08:20,450
as well so we want the absolute member

00:08:18,770 --> 00:08:22,910
piece of metadata to operate upon

00:08:20,450 --> 00:08:24,350
because allocating metadata is part of

00:08:22,910 --> 00:08:28,790
the cost of using the whole networking

00:08:24,350 --> 00:08:30,590
stack so but realize that because BPF

00:08:28,790 --> 00:08:32,930
determines the way the packet is

00:08:30,590 --> 00:08:34,430
processed this mechanism is completely

00:08:32,930 --> 00:08:37,340
generic you can do it people can do

00:08:34,430 --> 00:08:40,040
whatever they want with it so why do we

00:08:37,340 --> 00:08:42,350
need this thing in the first place so we

00:08:40,040 --> 00:08:45,830
absolutely must have an alternative to

00:08:42,350 --> 00:08:50,360
DP d KD DK is not something we want to

00:08:45,830 --> 00:08:56,200
drive forward DB TK is not Linux you can

00:08:50,360 --> 00:08:59,860
quote me on this DP DK again it's not

00:08:56,200 --> 00:09:08,170
Linux okay I believe agree with me

00:08:59,860 --> 00:09:11,220
DK is not Linux thank you that's

00:09:08,170 --> 00:09:15,459
definitely going on YouTube somewhere

00:09:11,220 --> 00:09:17,709
why is it not Linux this is important if

00:09:15,459 --> 00:09:21,610
I passes the Linux networking site it

00:09:17,709 --> 00:09:23,680
isn't an integral part of it it doesn't

00:09:21,610 --> 00:09:25,930
work alongside of it so once you use DP

00:09:23,680 --> 00:09:27,790
DK none of the facilities of the Linux

00:09:25,930 --> 00:09:30,430
and Linux networking stack are available

00:09:27,790 --> 00:09:33,040
at all it lives outside the realm of

00:09:30,430 --> 00:09:35,079
Linux completely it requires third-party

00:09:33,040 --> 00:09:37,930
modules and licensing that's not

00:09:35,079 --> 00:09:40,060
something we're all about either as we

00:09:37,930 --> 00:09:41,950
had to define its own security model for

00:09:40,060 --> 00:09:43,959
accessing the device outside of the

00:09:41,950 --> 00:09:47,500
kernel realm so they can do it CP DK

00:09:43,959 --> 00:09:49,779
stuff so we want to get away from this

00:09:47,500 --> 00:09:52,240
and we want to provide a way to solve

00:09:49,779 --> 00:09:54,250
the problems that people use DB DK for

00:09:52,240 --> 00:09:57,370
people love all the performance numbers

00:09:54,250 --> 00:10:00,180
that come out of DP DK but this is the

00:09:57,370 --> 00:10:03,130
cost you pay for that we can get all

00:10:00,180 --> 00:10:07,149
that without the side effect and that's

00:10:03,130 --> 00:10:08,860
what X DP is all about so I talked about

00:10:07,149 --> 00:10:11,019
the metadata here's what the metadata

00:10:08,860 --> 00:10:13,540
looks like it's just a start and an end

00:10:11,019 --> 00:10:15,310
pointer the EVPs program can look at the

00:10:13,540 --> 00:10:17,500
beanie and pack and start parsing using

00:10:15,310 --> 00:10:19,390
the data member and it knows that the

00:10:17,500 --> 00:10:21,220
packet goes until data end and it can

00:10:19,390 --> 00:10:24,399
implement whatever it wants to do with

00:10:21,220 --> 00:10:26,019
the packet in that point this means as a

00:10:24,399 --> 00:10:28,149
side effect that must be understood is

00:10:26,019 --> 00:10:30,220
that the packet is not read only the DBA

00:10:28,149 --> 00:10:32,440
epi program can mangle the data and this

00:10:30,220 --> 00:10:34,420
is useful for load balancing situations

00:10:32,440 --> 00:10:38,740
for routing for if you want to do fast

00:10:34,420 --> 00:10:40,420
and that inside of x x DP the packet is

00:10:38,740 --> 00:10:43,089
writable and that has implications for

00:10:40,420 --> 00:10:46,839
what the drivers need to do and for

00:10:43,089 --> 00:10:49,029
performance so when a DPF program

00:10:46,839 --> 00:10:49,820
running under the X TP is done and it's

00:10:49,029 --> 00:10:50,990
made

00:10:49,820 --> 00:10:53,180
Nation about what to do with the packet

00:10:50,990 --> 00:10:54,560
it returns an action code and that

00:10:53,180 --> 00:10:59,390
actually codes to find right now our

00:10:54,560 --> 00:11:02,210
boarded drop pass and transmit so what

00:10:59,390 --> 00:11:05,720
are these for enumeration values mean so

00:11:02,210 --> 00:11:07,010
drop means drop the packet do not pass

00:11:05,720 --> 00:11:10,010
it up to the rest of the networking

00:11:07,010 --> 00:11:12,320
stack and you can recycle that buffer

00:11:10,010 --> 00:11:16,310
back to the to the hardware that's the

00:11:12,320 --> 00:11:17,960
end ability is and means that the some

00:11:16,310 --> 00:11:19,430
internal error happened in the BPF

00:11:17,960 --> 00:11:22,040
program and currently we treat this like

00:11:19,430 --> 00:11:24,380
a drop for example why do we do it this

00:11:22,040 --> 00:11:27,560
way it should be done this way because

00:11:24,380 --> 00:11:31,250
if your intention of a BPF program is to

00:11:27,560 --> 00:11:32,930
drop dangerous traffic if the program

00:11:31,250 --> 00:11:34,490
has an error we don't want to let

00:11:32,930 --> 00:11:36,290
dangerous traffic still go through the

00:11:34,490 --> 00:11:38,150
network so did the choice for a night

00:11:36,290 --> 00:11:40,340
it's easy to argue the other way around

00:11:38,150 --> 00:11:47,200
some people want to say I rather not

00:11:40,340 --> 00:11:51,380
lose my legitimate traffic then then

00:11:47,200 --> 00:11:53,060
this right the other the next code is

00:11:51,380 --> 00:11:54,620
passed which means just accept the

00:11:53,060 --> 00:11:56,360
packet as we always did and put it all

00:11:54,620 --> 00:11:57,970
the way through the Linux networking

00:11:56,360 --> 00:12:01,550
stack that's straightforward

00:11:57,970 --> 00:12:04,250
it's behave as if xep was no longer

00:12:01,550 --> 00:12:06,770
there but keep in mind that the DPF

00:12:04,250 --> 00:12:08,780
program in the past case when it returns

00:12:06,770 --> 00:12:12,500
pass it could decide to mangle the

00:12:08,780 --> 00:12:14,240
packet in some way ok so it doesn't mean

00:12:12,500 --> 00:12:16,070
that BPF didn't do anything to the

00:12:14,240 --> 00:12:17,780
packet or change what would happen when

00:12:16,070 --> 00:12:20,150
the packets we see it just means that

00:12:17,780 --> 00:12:22,130
I've evaluated that you should pass the

00:12:20,150 --> 00:12:23,960
state of the packet it is an out with a

00:12:22,130 --> 00:12:27,410
mess can be up into the sack that's all

00:12:23,960 --> 00:12:30,500
of that means T X it means currently

00:12:27,410 --> 00:12:31,290
transmit this packet out of the same

00:12:30,500 --> 00:12:33,360
interface

00:12:31,290 --> 00:12:36,899
it arrived on so if you receive it on

00:12:33,360 --> 00:12:40,730
Nick zero transmitted out lick zero sits

00:12:36,899 --> 00:12:43,230
and this is currently a limitation of

00:12:40,730 --> 00:12:44,940
using the transmit feature and I'll go

00:12:43,230 --> 00:12:48,600
into that later about what we intend to

00:12:44,940 --> 00:12:50,699
do in the future with that but so how

00:12:48,600 --> 00:12:54,750
would you use this the simplest example

00:12:50,699 --> 00:12:56,670
is DDS DDoS mitigation you have an ACL

00:12:54,750 --> 00:12:59,040
is with a couple hundred thousand IP

00:12:56,670 --> 00:13:04,709
addresses in it or subnets or whatever

00:12:59,040 --> 00:13:07,259
and you put this into a BPF map the XMPP

00:13:04,709 --> 00:13:08,670
peer program parses the packet looks for

00:13:07,259 --> 00:13:10,500
the source address or whatever the key

00:13:08,670 --> 00:13:13,410
is that you use for BP with map for your

00:13:10,500 --> 00:13:16,130
ACLs looks it up in the table and gets a

00:13:13,410 --> 00:13:18,329
code result when of those XTP

00:13:16,130 --> 00:13:20,610
enumerations or some internal value that

00:13:18,329 --> 00:13:23,699
you translate into the XTP we turn

00:13:20,610 --> 00:13:26,730
values and if you found an entry in your

00:13:23,699 --> 00:13:29,069
ACL table you return the drop code and

00:13:26,730 --> 00:13:31,410
the packet buffer is returned to the

00:13:29,069 --> 00:13:34,050
hardware because of a drop code and the

00:13:31,410 --> 00:13:36,420
packet never enters the stack if it

00:13:34,050 --> 00:13:40,350
didn't fundamentally in them in the PPF

00:13:36,420 --> 00:13:42,630
map we'd return pass which means pass it

00:13:40,350 --> 00:13:48,240
up to the stack so that's how you can do

00:13:42,630 --> 00:13:50,880
DDoS mitigation another possible use

00:13:48,240 --> 00:13:52,740
case and this explains how the current

00:13:50,880 --> 00:13:54,870
TX mechanism could be used as static

00:13:52,740 --> 00:13:56,279
load balancing or not necessarily static

00:13:54,870 --> 00:13:58,920
but my example is a static load

00:13:56,279 --> 00:14:02,910
balancing so you have in a row

00:13:58,920 --> 00:14:04,320
a table of some sort that is a list of

00:14:02,910 --> 00:14:09,060
servers that you want to lower balance

00:14:04,320 --> 00:14:11,040
to behind the Machine and you parse the

00:14:09,060 --> 00:14:13,380
packet you pull out the lookup key and

00:14:11,040 --> 00:14:16,410
and you hash it and then you index them

00:14:13,380 --> 00:14:18,180
to your table of servers use that table

00:14:16,410 --> 00:14:20,310
to rewrite the IP headers and the MAC

00:14:18,180 --> 00:14:23,279
address and then you return the TX code

00:14:20,310 --> 00:14:26,160
the th code tells the driver transmitted

00:14:23,279 --> 00:14:28,440
out of the same physical work that the

00:14:26,160 --> 00:14:31,620
packet arrived on and don't pass it up

00:14:28,440 --> 00:14:33,060
into the stack okay so that's how we

00:14:31,620 --> 00:14:36,300
might do load balancing with the TX

00:14:33,060 --> 00:14:40,320
feature so I should tell you where this

00:14:36,300 --> 00:14:43,380
kind of comes from so what a lot of huge

00:14:40,320 --> 00:14:46,380
sites do run into the problem they run

00:14:43,380 --> 00:14:48,060
into is they they say okay we're

00:14:46,380 --> 00:14:50,339
starting small we want to do load

00:14:48,060 --> 00:14:52,170
balancing we use netfilter IPPs and

00:14:50,339 --> 00:14:54,329
everything kind of goes along we

00:14:52,170 --> 00:14:56,820
decently find for a little while then as

00:14:54,329 --> 00:14:59,370
traffic grades and demands get higher

00:14:56,820 --> 00:15:00,720
and higher it's just using the whole

00:14:59,370 --> 00:15:02,339
networking stack and going all the way

00:15:00,720 --> 00:15:04,230
internet filter and going all the way

00:15:02,339 --> 00:15:05,970
into IB BS this doesn't scale and

00:15:04,230 --> 00:15:08,940
doesn't provide the performance people

00:15:05,970 --> 00:15:13,709
want you can do load balancing your PPF

00:15:08,940 --> 00:15:16,709
and BPF Maps using this as a low latency

00:15:13,709 --> 00:15:18,360
very fast load balancing solution people

00:15:16,709 --> 00:15:20,480
use the PDK for this too

00:15:18,360 --> 00:15:24,899
other people have found other solutions

00:15:20,480 --> 00:15:27,660
solar restrictions that drive the design

00:15:24,899 --> 00:15:30,839
of x2p right now so each packet buffer

00:15:27,660 --> 00:15:32,519
must fit in a single page it is the

00:15:30,839 --> 00:15:35,730
primary area where changes are required

00:15:32,519 --> 00:15:37,290
in the drivers the reason why it's like

00:15:35,730 --> 00:15:39,660
this is because the metadata we wanted

00:15:37,290 --> 00:15:40,400
to keep as simple as possible so the EPF

00:15:39,660 --> 00:15:43,340
programs

00:15:40,400 --> 00:15:45,650
to deal with nonlinear buffers scatter

00:15:43,340 --> 00:15:47,630
gather or any of that complication we

00:15:45,650 --> 00:15:50,420
want to eliminate that completely from

00:15:47,630 --> 00:15:56,510
the from the realm of where these BPF

00:15:50,420 --> 00:15:58,550
programs have to understand right now

00:15:56,510 --> 00:16:00,170
when you install an SDP program on a

00:15:58,550 --> 00:16:02,990
device it applies to all the receive

00:16:00,170 --> 00:16:04,850
queues on the device there's no

00:16:02,990 --> 00:16:07,040
mechanism currently to say please

00:16:04,850 --> 00:16:09,740
execute this xdp program and on receive

00:16:07,040 --> 00:16:11,440
q3 and and that's something we want to

00:16:09,740 --> 00:16:13,820
do in the future and algorithm to that

00:16:11,440 --> 00:16:15,380
transmit as I discussed earlier can only

00:16:13,820 --> 00:16:19,030
occur on the same device that the route

00:16:15,380 --> 00:16:23,180
XDP program received the packet on the

00:16:19,030 --> 00:16:26,630
way we want to go from here I put our s

00:16:23,180 --> 00:16:29,840
QX EP instances so that's really the

00:16:26,630 --> 00:16:31,540
next level is and as all these trips

00:16:29,840 --> 00:16:34,700
that have multiple receive queues have

00:16:31,540 --> 00:16:36,290
filtering classification hardware inside

00:16:34,700 --> 00:16:39,890
which means that they could you could

00:16:36,290 --> 00:16:42,910
tell the card okay everything on port 80

00:16:39,890 --> 00:16:45,530
web traffic put it to receive q3

00:16:42,910 --> 00:16:47,780
therefore if you had an SDP program that

00:16:45,530 --> 00:16:50,960
wanted to operate only upon web traffic

00:16:47,780 --> 00:16:54,350
you could steer all of your traffic to

00:16:50,960 --> 00:16:57,980
go to C Q 3 and only instantiate the xcp

00:16:54,350 --> 00:16:59,270
program on that receive q3 then the rest

00:16:57,980 --> 00:17:00,860
of your traffic would go to the other

00:16:59,270 --> 00:17:02,690
queues and wouldn't have we didn't even

00:17:00,860 --> 00:17:05,690
try to execute the xdp program at all

00:17:02,690 --> 00:17:08,270
and you could take this on even further

00:17:05,690 --> 00:17:10,520
levels for example in choosing just

00:17:08,270 --> 00:17:13,610
detection systems like Sylacauga have

00:17:10,520 --> 00:17:15,170
complicated rule bases but at the top

00:17:13,610 --> 00:17:16,670
there's a certain level of filtering

00:17:15,170 --> 00:17:19,220
that's going to occur before they want

00:17:16,670 --> 00:17:21,290
to do things so for example you could

00:17:19,220 --> 00:17:24,110
you could have a certain set of keys

00:17:21,290 --> 00:17:26,209
that apply to some sets of filtering

00:17:24,110 --> 00:17:27,650
rules and have different xdp programs

00:17:26,209 --> 00:17:30,580
that execute for those classes of

00:17:27,650 --> 00:17:32,570
traffic that IBS is interested in so the

00:17:30,580 --> 00:17:33,590
possibilities are endless once we start

00:17:32,570 --> 00:17:35,720
getting the chip involved in

00:17:33,590 --> 00:17:37,040
pre-filtering the traffic pre siloing

00:17:35,720 --> 00:17:39,830
the traffic that you're interested in

00:17:37,040 --> 00:17:40,450
for specific XDP programmers next thing

00:17:39,830 --> 00:17:42,159
why do

00:17:40,450 --> 00:17:44,200
do forwarding to non same interfaces

00:17:42,159 --> 00:17:46,809
this is interesting if you want to do ab

00:17:44,200 --> 00:17:48,070
you want to do a bridge in XTP or you

00:17:46,809 --> 00:17:51,580
want to do a forward as simple

00:17:48,070 --> 00:17:53,440
forwarding mg and XTP you need also a

00:17:51,580 --> 00:17:55,360
point table because for the bridging

00:17:53,440 --> 00:17:57,490
case for example you need to know the

00:17:55,360 --> 00:18:00,100
set of interfaces that are relevant

00:17:57,490 --> 00:18:02,529
because you might have for example a

00:18:00,100 --> 00:18:04,389
flood operation and you don't want to

00:18:02,529 --> 00:18:06,880
flow to every index in the entire

00:18:04,389 --> 00:18:08,019
machine you want to flow to the port's

00:18:06,880 --> 00:18:09,519
that are involved with the boots that

00:18:08,019 --> 00:18:12,460
you're implementing with your xdp

00:18:09,519 --> 00:18:14,649
program okay there are other

00:18:12,460 --> 00:18:17,409
complications because once you leave the

00:18:14,649 --> 00:18:20,230
realm of the current driver you may have

00:18:17,409 --> 00:18:23,169
to redeem a map the page a nun map it

00:18:20,230 --> 00:18:25,299
from the current device the other thing

00:18:23,169 --> 00:18:27,309
is we're discussed about walking because

00:18:25,299 --> 00:18:29,620
one thing it's really nice right now is

00:18:27,309 --> 00:18:32,350
that the drivers tribal state to do the

00:18:29,620 --> 00:18:34,240
only transmitted with the XT DT X to the

00:18:32,350 --> 00:18:36,700
transmitted queue that's assigned to the

00:18:34,240 --> 00:18:39,100
current CPU therefore all the per CPU

00:18:36,700 --> 00:18:40,870
rocking optimizations apply and what we

00:18:39,100 --> 00:18:44,830
want to encourage is that everyone that

00:18:40,870 --> 00:18:46,690
supports x DP with this stuff applies

00:18:44,830 --> 00:18:48,880
the same rule so that we can eliminate

00:18:46,690 --> 00:18:50,500
the walking for all X DT X trends

00:18:48,880 --> 00:18:52,029
operations even if they go to a

00:18:50,500 --> 00:18:53,860
different device so we can always say

00:18:52,029 --> 00:18:55,960
that we'll use the transfer queue lot to

00:18:53,860 --> 00:18:57,610
this assigned to the CPU so that we can

00:18:55,960 --> 00:19:01,330
do per CPU optimizations with the

00:18:57,610 --> 00:19:03,429
walking no matter the destination what

00:19:01,330 --> 00:19:04,240
else can you do with xtp you can do an

00:19:03,429 --> 00:19:07,870
auto router

00:19:04,240 --> 00:19:12,399
Tom worked on that you can do Glos sis

00:19:07,870 --> 00:19:13,659
you can you can have you can pre put

00:19:12,399 --> 00:19:16,809
together all the metadata and

00:19:13,659 --> 00:19:18,820
information you need to collapse packets

00:19:16,809 --> 00:19:21,159
together and in a bundle if you do

00:19:18,820 --> 00:19:23,470
custom traffic sampling you could you

00:19:21,159 --> 00:19:25,960
can also customize statistic you can be

00:19:23,470 --> 00:19:27,250
like I want to track every single packet

00:19:25,960 --> 00:19:29,320
that go

00:19:27,250 --> 00:19:32,500
report any from source address proof

00:19:29,320 --> 00:19:34,720
barn bass and I want to collect a whole

00:19:32,500 --> 00:19:36,850
bunch of statistics in the BPF map that

00:19:34,720 --> 00:19:38,260
monitor this specific situation so

00:19:36,850 --> 00:19:40,330
dynamically you could upload

00:19:38,260 --> 00:19:42,430
xdp programs that see if a certain thing

00:19:40,330 --> 00:19:45,820
is happening for network diagnosis which

00:19:42,430 --> 00:19:48,970
i think is really cool socket freedom ox

00:19:45,820 --> 00:19:52,600
which is which i think is really a cool

00:19:48,970 --> 00:19:56,560
idea so right now when we go into the IP

00:19:52,600 --> 00:19:57,910
stock we look up before we even do a

00:19:56,560 --> 00:20:00,160
route little cup we look up if there's a

00:19:57,910 --> 00:20:01,990
TCP socket and if there is we use the

00:20:00,160 --> 00:20:05,080
route that's installed in the TCP socket

00:20:01,990 --> 00:20:06,640
to avoid the Rye lookup and if anyone's

00:20:05,080 --> 00:20:08,110
curious that's why we're moving the

00:20:06,640 --> 00:20:09,550
routing cash from the kernel was less

00:20:08,110 --> 00:20:13,060
expensive than it could have been in

00:20:09,550 --> 00:20:14,530
fact it performance increased when we

00:20:13,060 --> 00:20:18,160
remove the route in cash because of this

00:20:14,530 --> 00:20:20,860
hack but sock socket Deluxe eliminates

00:20:18,160 --> 00:20:22,990
one layer of the stacks overhead the

00:20:20,860 --> 00:20:25,360
routing book of if we did pre de MUX

00:20:22,990 --> 00:20:27,790
only in the driver we'd eliminate all

00:20:25,360 --> 00:20:30,310
this stuff in between - so it has a lot

00:20:27,790 --> 00:20:31,900
of potential for being an incredible

00:20:30,310 --> 00:20:33,760
optimization we could almost call

00:20:31,900 --> 00:20:35,920
directly into the TCP stack from the

00:20:33,760 --> 00:20:38,440
networking driver and not go through the

00:20:35,920 --> 00:20:40,450
whole rigmarole of all the layers that

00:20:38,440 --> 00:20:42,310
sit in between so this is this has some

00:20:40,450 --> 00:20:44,890
incredible so all the people who say I

00:20:42,310 --> 00:20:47,590
can't get whatever to millisecond

00:20:44,890 --> 00:20:49,210
latency with TCP receive we would start

00:20:47,590 --> 00:20:50,440
getting closer to that realm with this

00:20:49,210 --> 00:20:56,010
if we could go right from the driver

00:20:50,440 --> 00:20:58,630
will receive cue de-mux - tcp input I

00:20:56,010 --> 00:20:59,650
can't go any further than that except

00:20:58,630 --> 00:21:01,840
straight to use this space and that's

00:20:59,650 --> 00:21:04,480
what the our DMA guys go so I'll be

00:21:01,840 --> 00:21:08,080
giving you close to our DMA performance

00:21:04,480 --> 00:21:09,910
without all the side effects of going to

00:21:08,080 --> 00:21:10,870
our DMA so I think that's an important

00:21:09,910 --> 00:21:14,080
thing to understand that the

00:21:10,870 --> 00:21:17,170
capabilities that we have xdp are very

00:21:14,080 --> 00:21:19,470
far-reaching ok so that's the end of X

00:21:17,170 --> 00:21:20,900
DP and I want to reiterate two things

00:21:19,470 --> 00:21:26,380
execute

00:21:20,900 --> 00:21:30,740
the feature of the year and DP DJ is not

00:21:26,380 --> 00:21:32,360
Linux okay so now has moved to a more

00:21:30,740 --> 00:21:34,460
controversial topic encapsulated

00:21:32,360 --> 00:21:36,170
protocols then there lots of names

00:21:34,460 --> 00:21:39,230
thrown around for this one is transpose

00:21:36,170 --> 00:21:40,060
over UDP protocols and user space call

00:21:39,230 --> 00:21:42,590
it what you will

00:21:40,060 --> 00:21:44,750
so the basic idea is that we can

00:21:42,590 --> 00:21:48,260
encapsulate arbitrary transport

00:21:44,750 --> 00:21:52,040
protocols such as TCP in the GE GE is

00:21:48,260 --> 00:21:54,140
generic UDP encapsulation it has some

00:21:52,040 --> 00:21:56,180
petals that it defines after the UDP

00:21:54,140 --> 00:22:00,710
header it has a bunch of facilities that

00:21:56,180 --> 00:22:01,940
it can do and the interesting side note

00:22:00,710 --> 00:22:05,150
with this is that we can optionally

00:22:01,940 --> 00:22:06,710
encrypt the traffic as well because do

00:22:05,150 --> 00:22:10,670
you support encryption of the payload

00:22:06,710 --> 00:22:12,140
that it's it's it's encapsulating but

00:22:10,670 --> 00:22:14,300
what happens once you do this is that

00:22:12,140 --> 00:22:17,330
any user space application can

00:22:14,300 --> 00:22:19,100
encapsulate TCP and UDP using GRE and

00:22:17,330 --> 00:22:20,570
you put an entire TCP stack in user

00:22:19,100 --> 00:22:22,490
space and send it to Colonels that

00:22:20,570 --> 00:22:27,470
understand this Gigli encapsulation as

00:22:22,490 --> 00:22:29,480
well so the net result is we have TCP

00:22:27,470 --> 00:22:32,540
stacks in userspace because of this

00:22:29,480 --> 00:22:33,800
encapsulation technology so with some

00:22:32,540 --> 00:22:35,420
motivation why do people keep saying

00:22:33,800 --> 00:22:37,490
that they want something like this so

00:22:35,420 --> 00:22:39,680
fast supported propagation of new

00:22:37,490 --> 00:22:43,220
protocol features this this happens over

00:22:39,680 --> 00:22:44,600
and over again so Android at the time

00:22:43,220 --> 00:22:46,790
that this was proposed still didn't

00:22:44,600 --> 00:22:48,920
support TCP fast open which is important

00:22:46,790 --> 00:22:53,600
for decreasing the number of round trips

00:22:48,920 --> 00:22:55,070
you have for a TCP connection which is

00:22:53,600 --> 00:22:59,690
kind of interesting so the idea is that

00:22:55,070 --> 00:23:01,010
people would would push Android apps to

00:22:59,690 --> 00:23:03,800
Android phones that have this special

00:23:01,010 --> 00:23:06,620
TCP stack included that would support

00:23:03,800 --> 00:23:08,000
TCP fast open for example any big vendor

00:23:06,620 --> 00:23:09,470
could do this because they have the

00:23:08,000 --> 00:23:11,570
infrastructure and a data center to

00:23:09,470 --> 00:23:13,910
support gue TCP connections and their

00:23:11,570 --> 00:23:15,350
kernels and then push their apps with

00:23:13,910 --> 00:23:17,530
the special TCP stack that has the

00:23:15,350 --> 00:23:19,090
updates in it the theory is

00:23:17,530 --> 00:23:22,870
this would be an easier update model

00:23:19,090 --> 00:23:26,500
than Android and rock I guess that's

00:23:22,870 --> 00:23:28,180
setting the standard pretty low because

00:23:26,500 --> 00:23:29,830
the problem is Android Android doesn't

00:23:28,180 --> 00:23:33,640
move very quickly to new kernel versions

00:23:29,830 --> 00:23:36,910
I there's a lot of reasons it's a

00:23:33,640 --> 00:23:39,220
combination of cario restrictions so the

00:23:36,910 --> 00:23:41,110
handset maker restrictions on this whole

00:23:39,220 --> 00:23:42,070
week power and this whole ecosystem fits

00:23:41,110 --> 00:23:44,050
together right now

00:23:42,070 --> 00:23:45,960
anyway the issue exists and this is

00:23:44,050 --> 00:23:48,400
proposed as one possible solution to it

00:23:45,960 --> 00:23:49,660
the other one which i think is kind of

00:23:48,400 --> 00:23:52,170
interesting is we could eliminate

00:23:49,660 --> 00:23:55,230
middleboxes from the equation forever

00:23:52,170 --> 00:23:57,790
because once we start encrypting all the

00:23:55,230 --> 00:24:01,360
TCP connections out there and every TCP

00:23:57,790 --> 00:24:02,560
stream out there is encrypted the middle

00:24:01,360 --> 00:24:04,180
or boxes can't analyze the traffic

00:24:02,560 --> 00:24:07,060
anymore at all there's nothing they can

00:24:04,180 --> 00:24:09,940
say about what's in there so of course

00:24:07,060 --> 00:24:11,320
what law the middleware box people start

00:24:09,940 --> 00:24:12,520
get jumping up and down in their seats

00:24:11,320 --> 00:24:14,470
and they're little concerned about this

00:24:12,520 --> 00:24:17,110
so they've they've asked for things like

00:24:14,470 --> 00:24:18,760
can we add an option into the G routers

00:24:17,110 --> 00:24:20,500
that says what kind of traffic it's

00:24:18,760 --> 00:24:22,600
being used I can't think of anything

00:24:20,500 --> 00:24:25,120
other than the various purposes for that

00:24:22,600 --> 00:24:26,050
kind of tag so I don't think that's

00:24:25,120 --> 00:24:29,890
going to go anywhere

00:24:26,050 --> 00:24:31,780
so on the flip side of all this is a new

00:24:29,890 --> 00:24:34,510
firm making should we let it happen or

00:24:31,780 --> 00:24:38,050
not these precedents for doing this

00:24:34,510 --> 00:24:39,580
already if you look a quick which is the

00:24:38,050 --> 00:24:43,600
multiplex stream protocol that Hoover

00:24:39,580 --> 00:24:47,110
uses in chrome to accelerate web web

00:24:43,600 --> 00:24:49,090
transfers they do encapsulate over UDP

00:24:47,110 --> 00:24:50,320
and they do all these things that we're

00:24:49,090 --> 00:24:51,730
talking about in this part of the

00:24:50,320 --> 00:24:53,710
presentation so it's not like this

00:24:51,730 --> 00:24:55,570
hasn't been done before it's not as if

00:24:53,710 --> 00:24:56,830
it hasn't been deployed as I left so and

00:24:55,570 --> 00:24:58,860
hasn't tried to deal with all the

00:24:56,830 --> 00:25:03,370
deployment issues associated with quote

00:24:58,860 --> 00:25:07,630
so so losing practical matters once you

00:25:03,370 --> 00:25:09,539
start doing T review any issue with the

00:25:07,630 --> 00:25:11,519
geo geo so that

00:25:09,539 --> 00:25:13,879
this with tunnels also exist with tou

00:25:11,519 --> 00:25:16,399
because tou is a tunneling technology

00:25:13,879 --> 00:25:19,590
geocell is mostly a solved problem

00:25:16,399 --> 00:25:20,909
because one interesting trick that Alex

00:25:19,590 --> 00:25:24,239
and company have come up with is that

00:25:20,909 --> 00:25:27,479
look if the chip just wants to know

00:25:24,239 --> 00:25:30,720
we're non-constant headers and and where

00:25:27,479 --> 00:25:32,580
does the TCP part begin where I need to

00:25:30,720 --> 00:25:33,869
edit the headers and change sequence

00:25:32,580 --> 00:25:36,299
numbers and do all this kind of stuff

00:25:33,869 --> 00:25:38,190
and all you do wrong we would say okay

00:25:36,299 --> 00:25:39,659
here's the IP header and it's this many

00:25:38,190 --> 00:25:42,210
bytes and then the TCP happens

00:25:39,659 --> 00:25:44,460
afterwards if we just trick the card and

00:25:42,210 --> 00:25:46,830
say oh the IP header is really big it

00:25:44,460 --> 00:25:49,080
goes past the UDP header it goes past

00:25:46,830 --> 00:25:51,809
the GRE header and then that's how big

00:25:49,080 --> 00:25:54,570
the IP header the IP header is the chip

00:25:51,809 --> 00:25:56,190
can offload gso properly if you do this

00:25:54,570 --> 00:25:59,460
so that's an interesting aspect of

00:25:56,190 --> 00:26:02,159
transmit zero is a little bit trickier

00:25:59,460 --> 00:26:05,309
and the problem is that once we have the

00:26:02,159 --> 00:26:07,859
cards doing lro kind of things we don't

00:26:05,309 --> 00:26:10,499
have any way to apply the heuristics

00:26:07,859 --> 00:26:12,570
that we do for software GRL it's it's a

00:26:10,499 --> 00:26:17,070
seriously complicated problem there's

00:26:12,570 --> 00:26:22,019
been talk about BPF programs to do geoo

00:26:17,070 --> 00:26:23,519
properly it's a that's in flux and uncho

00:26:22,019 --> 00:26:26,580
so anyway so the thing to understand is

00:26:23,519 --> 00:26:28,769
that they're all floating issues once

00:26:26,580 --> 00:26:30,749
you start encapsulating TCP and UDP like

00:26:28,769 --> 00:26:34,159
this okay check something in the other

00:26:30,749 --> 00:26:37,440
stuff is still common straightforward

00:26:34,159 --> 00:26:39,869
other tou issues ecn is kinda

00:26:37,440 --> 00:26:41,940
interesting who owns the IP ec n bits

00:26:39,869 --> 00:26:44,009
ones tcp sits there underneath the UDP

00:26:41,940 --> 00:26:46,139
packet does the TCP stream or does the

00:26:44,009 --> 00:26:50,460
tunnel stream own those the EC n bits

00:26:46,139 --> 00:26:53,489
and IP header open question congestion

00:26:50,460 --> 00:26:56,549
control algorithms the being released

00:26:53,489 --> 00:26:59,129
recently they simply can't be done in a

00:26:56,549 --> 00:27:01,229
user space TCP so anytime someone brings

00:26:59,129 --> 00:27:03,539
a TCP stack in the user space they start

00:27:01,229 --> 00:27:06,149
realizing how big the scope of the

00:27:03,539 --> 00:27:09,960
problem is and the lko guys are seeing

00:27:06,149 --> 00:27:12,349
this as well.you in order to do BB all

00:27:09,960 --> 00:27:14,369
properly you need the fast queuing

00:27:12,349 --> 00:27:15,749
scheduler and you need to Payton

00:27:14,369 --> 00:27:19,139
specifically you need the pacing

00:27:15,749 --> 00:27:20,909
facilities provided by FQ you can't you

00:27:19,139 --> 00:27:23,700
lose that once you put the TCP stack in

00:27:20,909 --> 00:27:26,220
the user space that the packet scheduler

00:27:23,700 --> 00:27:27,419
sits in the kernel and the TCP thing is

00:27:26,220 --> 00:27:29,279
sitting in user space and they have no

00:27:27,419 --> 00:27:29,999
way to communicate pasting information

00:27:29,279 --> 00:27:33,659
between each other

00:27:29,999 --> 00:27:35,580
okay time your granularity and user

00:27:33,659 --> 00:27:38,849
space is an issue and this kind of also

00:27:35,580 --> 00:27:40,649
ties into the thing that is if that app

00:27:38,849 --> 00:27:42,599
gets scheduled out that means the whole

00:27:40,649 --> 00:27:43,919
TCP stack is getting scheduled out too

00:27:42,599 --> 00:27:45,239
and that means any delay

00:27:43,919 --> 00:27:48,239
incurred by the application which

00:27:45,239 --> 00:27:50,700
normally would be considered ok is now

00:27:48,239 --> 00:27:54,239
affecting network traffic which may not

00:27:50,700 --> 00:27:56,279
be okay which means that being able to

00:27:54,239 --> 00:27:58,710
suppress an app means you're able to

00:27:56,279 --> 00:28:00,599
suppress network traffic and the TCP

00:27:58,710 --> 00:28:04,710
stack from responding so if a reset came

00:28:00,599 --> 00:28:06,779
in or data packets came in they would

00:28:04,710 --> 00:28:08,879
just get queued up and they wouldn't be

00:28:06,779 --> 00:28:11,129
act or sacked or a processed at all

00:28:08,879 --> 00:28:12,720
about a TCP stack in the application so

00:28:11,129 --> 00:28:15,149
this is another thing that's that it

00:28:12,720 --> 00:28:18,179
could be an interesting issue so then

00:28:15,149 --> 00:28:20,609
you have another cool thing so during

00:28:18,179 --> 00:28:22,769
TCP stack Wednesday we transmit a packet

00:28:20,609 --> 00:28:25,769
because of sac information because of

00:28:22,769 --> 00:28:28,010
other loss indications or what or a time

00:28:25,769 --> 00:28:30,320
that has fired it doesn't clever

00:28:28,010 --> 00:28:31,670
it looks to see if the packet is

00:28:30,320 --> 00:28:33,620
swimming in the cute list or the

00:28:31,670 --> 00:28:35,420
transmitting of the driver and if it is

00:28:33,620 --> 00:28:38,420
it doesn't try to resend it because it

00:28:35,420 --> 00:28:40,220
knows that wherever it is in there once

00:28:38,420 --> 00:28:41,630
it gets unstuck it's going to end up

00:28:40,220 --> 00:28:43,190
getting sent to the network so sending

00:28:41,630 --> 00:28:44,720
it again and getting it into this pack

00:28:43,190 --> 00:28:46,760
that is stuck in background already

00:28:44,720 --> 00:28:48,770
serves no useful purpose whatsoever

00:28:46,760 --> 00:28:51,140
you're going to be able to do that in

00:28:48,770 --> 00:28:53,210
the user man TCP stack and I'm sure you

00:28:51,140 --> 00:28:54,950
if someone did a full audit you would

00:28:53,210 --> 00:28:56,870
find a large list of these kind of

00:28:54,950 --> 00:28:59,540
things that are impossible in a TCP or

00:28:56,870 --> 00:29:01,970
UDP stack that are possible with the

00:28:59,540 --> 00:29:03,860
integration of the TCP stack inside the

00:29:01,970 --> 00:29:06,470
kernel itself so that I think these are

00:29:03,860 --> 00:29:10,580
the things to take into consideration so

00:29:06,470 --> 00:29:13,760
this leads us to the the big question to

00:29:10,580 --> 00:29:15,530
everyone tou it's going to open up

00:29:13,760 --> 00:29:17,690
Pandora's box there really isn't a lot

00:29:15,530 --> 00:29:19,810
of backtracking we can do once we

00:29:17,690 --> 00:29:22,550
unleash this beast beast onto the world

00:29:19,810 --> 00:29:24,170
so we better understand what's going to

00:29:22,550 --> 00:29:25,870
happen as a side of that once you start

00:29:24,170 --> 00:29:28,600
doing stuff like this

00:29:25,870 --> 00:29:30,380
thing if we knew before set of

00:29:28,600 --> 00:29:32,000
fundamental restrictions from our

00:29:30,380 --> 00:29:35,240
previous few slides we would be okay

00:29:32,000 --> 00:29:37,040
with that we don't know so really this

00:29:35,240 --> 00:29:40,040
is this is a really interesting problem

00:29:37,040 --> 00:29:42,730
space I and another thing that really

00:29:40,040 --> 00:29:45,680
occurs to me when I think about this is

00:29:42,730 --> 00:29:47,480
the argument is that we can we can't get

00:29:45,680 --> 00:29:50,090
the new TCP features we can't update the

00:29:47,480 --> 00:29:53,570
kernel fast enough we can't update the

00:29:50,090 --> 00:29:56,030
update process is difficult slow and I'm

00:29:53,570 --> 00:29:56,420
thinking well maybe there's a reason for

00:29:56,030 --> 00:29:59,410
that

00:29:56,420 --> 00:30:04,880
as a side effect of all the checking and

00:29:59,410 --> 00:30:07,970
testing and regression checking and the

00:30:04,880 --> 00:30:10,880
protection that the provides it does

00:30:07,970 --> 00:30:13,280
take time to safely and properly update

00:30:10,880 --> 00:30:16,880
even a small component of the kernel

00:30:13,280 --> 00:30:18,850
like a single module so are you saying

00:30:16,880 --> 00:30:20,830
that here once you put this

00:30:18,850 --> 00:30:22,150
we've been a really nearly fluid

00:30:20,830 --> 00:30:23,860
whatever over the world that we come

00:30:22,150 --> 00:30:25,750
with a come up with every day to make

00:30:23,860 --> 00:30:27,430
performance faster and we all have to

00:30:25,750 --> 00:30:29,860
worry about bugs anymore because what it

00:30:27,430 --> 00:30:31,210
crushes the out that's fine we can

00:30:29,860 --> 00:30:34,480
survive that it's not going to take the

00:30:31,210 --> 00:30:37,600
whole system out I think people maybe

00:30:34,480 --> 00:30:40,090
would become careless and less careful

00:30:37,600 --> 00:30:42,190
with which should be a very fundamental

00:30:40,090 --> 00:30:44,380
aspect of the internet upgrading it on

00:30:42,190 --> 00:30:46,360
on image on machines and user space I

00:30:44,380 --> 00:30:49,510
think I think you can't have it both

00:30:46,360 --> 00:30:51,820
ways you can't say that the upgrading

00:30:49,510 --> 00:30:53,590
TCP carefully is important and at the

00:30:51,820 --> 00:30:56,530
same time say I want to upgrade it more

00:30:53,590 --> 00:30:58,750
quickly so I don't know where this all

00:30:56,530 --> 00:31:04,840
goes so that's all I have to say about

00:30:58,750 --> 00:31:08,680
tou at XTP I also would like to finish

00:31:04,840 --> 00:31:10,390
my talk by thanking Hajime song Sakura

00:31:08,680 --> 00:31:13,720
sana and their team of great people

00:31:10,390 --> 00:31:16,510
jamal Pablo anyone who's helped to make

00:31:13,720 --> 00:31:18,730
this conference the success has been so

00:31:16,510 --> 00:31:20,050
far I think everyone's really enjoying

00:31:18,730 --> 00:31:21,670
the conference so far and getting a lot

00:31:20,050 --> 00:31:23,070
of information in the interaction with

00:31:21,670 --> 00:31:24,970
other people that's helping them a lot

00:31:23,070 --> 00:31:27,540
so I just like to give a round of

00:31:24,970 --> 00:31:27,540
applause for

00:31:32,100 --> 00:31:43,080
so any questions they'd better be good

00:31:35,430 --> 00:31:45,650
ones um I'm kind of confused like you

00:31:43,080 --> 00:31:48,120
could have you could have done this in

00:31:45,650 --> 00:31:49,620
1979 right you could have written TCP

00:31:48,120 --> 00:31:52,710
inside users bison you could have sent

00:31:49,620 --> 00:31:54,420
UDP packets but the receiving end on the

00:31:52,710 --> 00:31:55,730
server might not understand the

00:31:54,420 --> 00:31:57,750
encapsulation that's what the

00:31:55,730 --> 00:31:59,700
implication is that in the data centers

00:31:57,750 --> 00:32:02,040
you have a kernel that understands TCP

00:31:59,700 --> 00:32:03,960
or UDP and you can update that quickly

00:32:02,040 --> 00:32:06,480
under your own constraints on the gyro

00:32:03,960 --> 00:32:09,630
controls outside of the handset

00:32:06,480 --> 00:32:11,460
ecosystem issues and then the users

00:32:09,630 --> 00:32:13,530
would have to get this user land thing

00:32:11,460 --> 00:32:15,360
so it's so really the question is do we

00:32:13,530 --> 00:32:16,860
want to support GL o for people who want

00:32:15,360 --> 00:32:18,000
to do this because if they want to do

00:32:16,860 --> 00:32:19,380
this they can do it on the server as

00:32:18,000 --> 00:32:20,520
well they can take whatever the 10x

00:32:19,380 --> 00:32:21,750
performance said it was like that you

00:32:20,520 --> 00:32:23,910
know whatever I'm just going to deal

00:32:21,750 --> 00:32:29,580
with it and on the server side you you

00:32:23,910 --> 00:32:32,430
don't because well so let's say big core

00:32:29,580 --> 00:32:34,580
backs y'see sends out their app with

00:32:32,430 --> 00:32:36,900
this TCP and user space thing all seven

00:32:34,580 --> 00:32:39,450
85 to 90 percent of all the received

00:32:36,900 --> 00:32:41,310
traffic is this TCP or UDP thing and

00:32:39,450 --> 00:32:43,380
they want to giro that crap

00:32:41,310 --> 00:32:45,530
there is no question whatsoever they

00:32:43,380 --> 00:32:48,510
want to be able to and they won and then

00:32:45,530 --> 00:32:50,310
now consider the case where all of your

00:32:48,510 --> 00:32:51,690
major apps have the TCP and user space

00:32:50,310 --> 00:32:55,440
thing on your phone you'll want to be

00:32:51,690 --> 00:32:58,820
doing goog row with that stat - do we do

00:32:55,440 --> 00:32:58,820
we do zero for quick

00:33:04,360 --> 00:33:11,960
the digital side on the on the server is

00:33:08,870 --> 00:33:17,540
not really useful because uh the clients

00:33:11,960 --> 00:33:20,840
and other to low rate anyway so it's not

00:33:17,540 --> 00:33:22,880
it's there but the the aggregation rate

00:33:20,840 --> 00:33:25,010
is that are like zero that something

00:33:22,880 --> 00:33:26,690
needs very small but like let's use

00:33:25,010 --> 00:33:28,580
Facebook as an example people gotta

00:33:26,690 --> 00:33:30,320
upload them cat pictures and those cat

00:33:28,580 --> 00:33:32,720
pictures Giro like you wouldn't believe

00:33:30,320 --> 00:33:35,060
not really because the packet are not

00:33:32,720 --> 00:33:36,890
coming into a single net people at the

00:33:35,060 --> 00:33:39,980
server side because the server side has

00:33:36,890 --> 00:33:42,650
like 40 unique and there's no way the

00:33:39,980 --> 00:33:46,720
sender know what is this discussion

00:33:42,650 --> 00:33:46,720
let's do it is our is our key role

00:33:47,230 --> 00:33:58,370
switching table deep enough I'm just

00:33:55,460 --> 00:33:59,930
saying the only younger gr1 nappy budget

00:33:58,370 --> 00:34:02,390
and you aren't going to get enough of

00:33:59,930 --> 00:34:08,560
the cat picture in one nappy budget

00:34:02,390 --> 00:34:08,560
right that's possible yeah but this okay

00:34:12,679 --> 00:34:19,500
one kid one could try to measure the

00:34:17,700 --> 00:34:21,330
performance impact under a realistic

00:34:19,500 --> 00:34:23,370
workload and try to make a decision

00:34:21,330 --> 00:34:25,080
based on that perhaps right because if

00:34:23,370 --> 00:34:26,520
because if your other jurors aren't

00:34:25,080 --> 00:34:28,200
going to help because you do this new

00:34:26,520 --> 00:34:29,400
space on the sender side you can do it

00:34:28,200 --> 00:34:32,370
and use the space on the receiver side

00:34:29,400 --> 00:34:35,970
whoa okay can we at least agree that on

00:34:32,370 --> 00:34:38,610
the on the client side qso helps get the

00:34:35,970 --> 00:34:40,590
cat picture out really quick no I don't

00:34:38,610 --> 00:34:42,480
know like yeah like I don't know that

00:34:40,590 --> 00:34:46,020
the chips that we won't even do anything

00:34:42,480 --> 00:34:49,800
right like you know it on Android I

00:34:46,020 --> 00:34:51,330
don't take the dorsal okay but I mean I

00:34:49,800 --> 00:34:54,600
don't know that they will really not

00:34:51,330 --> 00:34:56,550
cpu-bound it's you know the work blowing

00:34:54,600 --> 00:34:59,550
on 2g networks and area uploading the

00:34:56,550 --> 00:35:00,960
cat picture I mean to be honest there's

00:34:59,550 --> 00:35:02,430
so many iptables rules that you have to

00:35:00,960 --> 00:35:11,690
go see before either like hit the

00:35:02,430 --> 00:35:11,690
network you thought yeah anything else

00:35:11,990 --> 00:35:18,960
pepper one's hungry um forgive my

00:35:16,860 --> 00:35:21,720
anyways put some questions about the xtp

00:35:18,960 --> 00:35:24,510
stuffing so the deer end is that that's

00:35:21,720 --> 00:35:26,670
inclusive excuse me did the data end

00:35:24,510 --> 00:35:28,500
pointer and wesson it is inclusive or as

00:35:26,670 --> 00:35:31,410
when past the end it's one gosh again

00:35:28,500 --> 00:35:36,510
one past the end okay so i for the head

00:35:31,410 --> 00:35:38,160
plus one okay and and then does it I

00:35:36,510 --> 00:35:40,110
thought one thing I did really didn't

00:35:38,160 --> 00:35:43,440
get into is that the implication for the

00:35:40,110 --> 00:35:46,140
single page is that there's performance

00:35:43,440 --> 00:35:48,210
concerns and specifically in most

00:35:46,140 --> 00:35:49,440
drivers they they get pages to the

00:35:48,210 --> 00:35:52,440
collared card can chop them up

00:35:49,440 --> 00:35:54,390
arbitrarily so you'd give like an order

00:35:52,440 --> 00:35:56,430
one page and then the card could put

00:35:54,390 --> 00:35:58,110
several 1500 by packets into there and

00:35:56,430 --> 00:36:00,510
then you would you would amortize the

00:35:58,110 --> 00:36:02,370
allocation overhead so now we have this

00:36:00,510 --> 00:36:04,020
new problem where we have pages page

00:36:02,370 --> 00:36:05,430
application becomes an important

00:36:04,020 --> 00:36:06,900
performance issue and yes but has been

00:36:05,430 --> 00:36:09,090
doing a lot of work to work on page

00:36:06,900 --> 00:36:10,620
polls that are really quick and optimal

00:36:09,090 --> 00:36:12,740
and right now with a lot of drivers

00:36:10,620 --> 00:36:15,140
supporting xdp ordering is they have

00:36:12,740 --> 00:36:17,720
on page recycling mechanism that they're

00:36:15,140 --> 00:36:19,670
using to get rid of the performance loss

00:36:17,720 --> 00:36:21,380
that you get by going to xdv for a

00:36:19,670 --> 00:36:25,369
normal traffic but not an XDP traffic

00:36:21,380 --> 00:36:27,320
and in when the DPF program encounters

00:36:25,369 --> 00:36:29,450
the packet in this page does it know how

00:36:27,320 --> 00:36:30,710
much space in front of the packet if it

00:36:29,450 --> 00:36:32,780
wants to enlarge it on the ferry

00:36:30,710 --> 00:36:34,130
good question so one of the operations

00:36:32,780 --> 00:36:36,980
that we're discussing that we want to

00:36:34,130 --> 00:36:38,450
add is header push and pop and in order

00:36:36,980 --> 00:36:42,800
to do that we have to do something such

00:36:38,450 --> 00:36:45,380
as say the chip has to DMA start the

00:36:42,800 --> 00:36:47,540
Becker 256 bytes into the page and

00:36:45,380 --> 00:36:49,849
that's where you have 256 bytes of

00:36:47,540 --> 00:36:51,290
headroom to push and pop headers and so

00:36:49,849 --> 00:36:52,820
yes we've considered that and we will

00:36:51,290 --> 00:36:54,320
move towards supporting that kind of

00:36:52,820 --> 00:37:02,480
feature because then you could do TR you

00:36:54,320 --> 00:37:04,099
in HDPE sorry this this has been brought

00:37:02,480 --> 00:37:10,609
up as well and that those people hadn't

00:37:04,099 --> 00:37:16,790
are not discoverable at this point so in

00:37:10,609 --> 00:37:19,420
circular blow right now that's it okay

00:37:16,790 --> 00:37:19,420

YouTube URL: https://www.youtube.com/watch?v=NlMQ0i09HMU


