Title: Single Virtual function driver for current and future Intel Network devices - Anjali Singhai et al.
Publication date: 2016-10-07
Playlist: Netdev 1.2 - Day 2 - Thursday October 6, 2016
Description: 
	http://netdevconf.org/1.2/session.html?anjali-singhai
Captions: 
	00:00:09,600 --> 00:00:14,000
we'll get started my name is Jessie

00:00:12,450 --> 00:00:16,650
Brandenburg I work for Intel

00:00:14,000 --> 00:00:19,140
then I'm Anjali I think I chain I will

00:00:16,650 --> 00:00:22,770
turn to Lhasa we're gonna be talking

00:00:19,140 --> 00:00:25,500
today about the idea of a single virtual

00:00:22,770 --> 00:00:27,750
function device driver that will be

00:00:25,500 --> 00:00:29,640
future compatible so it's kind of a big

00:00:27,750 --> 00:00:34,399
change for us where we'll tell you about

00:00:29,640 --> 00:00:37,520
as of why wow what happened there okay

00:00:34,399 --> 00:00:41,970
so we'll talk a little bit today about

00:00:37,520 --> 00:00:46,740
the the problem that we see how we've

00:00:41,970 --> 00:00:48,720
evolved the the Silv networking some of

00:00:46,740 --> 00:00:50,250
our considerations and and the

00:00:48,720 --> 00:00:52,080
implementation that were that we're

00:00:50,250 --> 00:00:54,540
working on and then some of the

00:00:52,080 --> 00:00:57,590
challenges and the alternative things we

00:00:54,540 --> 00:00:57,590
might be able to do in the future

00:00:59,420 --> 00:01:03,239
excuse the highlighting on the slides it

00:01:01,860 --> 00:01:07,200
seems like a last-minute formatting

00:01:03,239 --> 00:01:08,189
difficulty we ran into so let us know if

00:01:07,200 --> 00:01:10,950
they're not readable and we'll do

00:01:08,189 --> 00:01:14,540
another version the so in a perfect

00:01:10,950 --> 00:01:17,340
world right customers today are

00:01:14,540 --> 00:01:19,890
deploying our hardware devices they have

00:01:17,340 --> 00:01:21,840
SR iov support so they have a separate

00:01:19,890 --> 00:01:26,330
driver for the SR IOB device and and

00:01:21,840 --> 00:01:26,330
physical function so the PF and the VF

00:01:26,479 --> 00:01:35,220
they would like to have backwards

00:01:32,340 --> 00:01:38,850
compatibility in the VM so what they

00:01:35,220 --> 00:01:40,740
want to have done is have a VF driver

00:01:38,850 --> 00:01:42,570
that stays in their VM image and it

00:01:40,740 --> 00:01:44,880
stays there forever and it doesn't have

00:01:42,570 --> 00:01:48,540
to change and it never breaks and

00:01:44,880 --> 00:01:51,840
there's no bugs and right but this is

00:01:48,540 --> 00:01:53,610
the perfect world you know they want all

00:01:51,840 --> 00:01:57,390
the advanced features exposed they want

00:01:53,610 --> 00:01:59,220
the speed of an SI o V interface and any

00:01:57,390 --> 00:02:02,010
new hardware would always just continue

00:01:59,220 --> 00:02:03,180
to work the other thing that they'd

00:02:02,010 --> 00:02:06,390
really like is that the low-level

00:02:03,180 --> 00:02:08,640
software like the drivers would stay the

00:02:06,390 --> 00:02:11,090
same so that it can last for multiple

00:02:08,640 --> 00:02:13,310
generations so for us the

00:02:11,090 --> 00:02:17,150
the the destination that we'd like to

00:02:13,310 --> 00:02:18,830
arrive at is customers who have many

00:02:17,150 --> 00:02:22,370
many many virtual machines that they

00:02:18,830 --> 00:02:26,060
have to deploy like Amazon's Cloud would

00:02:22,370 --> 00:02:27,769
be able to have many virtual machine

00:02:26,060 --> 00:02:29,269
images that have the same device that

00:02:27,769 --> 00:02:31,670
are installed and it doesn't need to be

00:02:29,269 --> 00:02:33,620
updated so if they get new hardware

00:02:31,670 --> 00:02:35,780
because hardware doesn't last forever

00:02:33,620 --> 00:02:38,060
they get new hardware they don't have to

00:02:35,780 --> 00:02:39,860
spin all their bef images all their VM

00:02:38,060 --> 00:02:45,019
images in order to update their device

00:02:39,860 --> 00:02:49,370
drivers for this or a V device so this

00:02:45,019 --> 00:02:50,930
idea would stretch us today because many

00:02:49,370 --> 00:02:54,290
and I think in many of the other vendors

00:02:50,930 --> 00:02:56,180
because the device drivers are changing

00:02:54,290 --> 00:02:58,190
each release they're changing each

00:02:56,180 --> 00:03:02,750
hardware release and it makes it so that

00:02:58,190 --> 00:03:04,910
the the the vendors have to spend

00:03:02,750 --> 00:03:06,980
hundreds or thousands of VM images to

00:03:04,910 --> 00:03:09,860
update their device driver which is a

00:03:06,980 --> 00:03:12,230
very large overhead and we've heard back

00:03:09,860 --> 00:03:14,629
in in no uncertain terms that this is

00:03:12,230 --> 00:03:25,459
not a variable not a very acceptable

00:03:14,629 --> 00:03:27,170
scenario so the other thing is we want

00:03:25,459 --> 00:03:29,359
feature compatibility right so like I

00:03:27,170 --> 00:03:30,889
said replace Hardware the the

00:03:29,359 --> 00:03:32,599
instructions here from our customers is

00:03:30,889 --> 00:03:36,170
don't change the VF driver unless you

00:03:32,599 --> 00:03:38,030
really really really have to so going

00:03:36,170 --> 00:03:40,609
back to a little bit of history for us

00:03:38,030 --> 00:03:42,470
the the evolution of SRO be enabled

00:03:40,609 --> 00:03:46,310
network device drivers we started back

00:03:42,470 --> 00:03:48,769
in time with the IDB bf driver

00:03:46,310 --> 00:03:51,290
it provided a you know kind of a basic

00:03:48,769 --> 00:03:55,579
connectivity not bringing any queues not

00:03:51,290 --> 00:03:58,459
very many interrupt vectors and it was

00:03:55,579 --> 00:04:01,310
on a one gig part later we went to the

00:03:58,459 --> 00:04:03,919
i-x to the EVF driver and it involves

00:04:01,310 --> 00:04:05,510
some the it had improved performance it

00:04:03,919 --> 00:04:07,630
had a better eise which like the

00:04:05,510 --> 00:04:10,700
Mellanox guys we're just talking about

00:04:07,630 --> 00:04:13,550
it had load balancing and

00:04:10,700 --> 00:04:14,989
have nothing to support and then the

00:04:13,550 --> 00:04:18,310
current generation that we have is the

00:04:14,989 --> 00:04:20,840
i-40 EVF driver today that driver is a

00:04:18,310 --> 00:04:22,610
VF driver that looks a lot like a PF

00:04:20,840 --> 00:04:25,460
driver in terms of its features and

00:04:22,610 --> 00:04:28,310
support and it you know if it could be

00:04:25,460 --> 00:04:30,860
even grow further if we wanted it to it

00:04:28,310 --> 00:04:39,310
has supports some you know up to eight

00:04:30,860 --> 00:04:42,380
cues multiple interrupt vectors etc so

00:04:39,310 --> 00:04:43,970
all of these devices all supported TX

00:04:42,380 --> 00:04:45,320
and rx check some offloads they give you

00:04:43,970 --> 00:04:52,880
the hardware support that you need to go

00:04:45,320 --> 00:04:55,520
fast in an SRO key device now my

00:04:52,880 --> 00:04:57,950
colleague Anjali would take over so

00:04:55,520 --> 00:05:00,710
going back to this so we had already in

00:04:57,950 --> 00:05:03,500
the kernel of three different VF drivers

00:05:00,710 --> 00:05:05,870
for SIV devices and this has been in the

00:05:03,500 --> 00:05:08,960
last six years I believe like we started

00:05:05,870 --> 00:05:11,840
in 2009 and by 2014 or 15

00:05:08,960 --> 00:05:13,910
we are theta three drivers and this is

00:05:11,840 --> 00:05:18,229
because we had three generations of SIV

00:05:13,910 --> 00:05:21,110
supported onyx and going by the trend we

00:05:18,229 --> 00:05:25,070
will be producing every two years a new

00:05:21,110 --> 00:05:26,960
VF driver right so that doesn't look

00:05:25,070 --> 00:05:30,580
really good to our customers and that's

00:05:26,960 --> 00:05:33,320
the problem we want to fix that this all

00:05:30,580 --> 00:05:35,810
hopefully gets combined into a single be

00:05:33,320 --> 00:05:38,150
a flower which is backward and forward

00:05:35,810 --> 00:05:41,150
compatible but at the same time it can

00:05:38,150 --> 00:05:45,880
expand to expose all the you know good

00:05:41,150 --> 00:05:47,780
qualities of you know filtering and

00:05:45,880 --> 00:05:49,520
performance improvements and all the

00:05:47,780 --> 00:05:51,350
stuff that always talking about that all

00:05:49,520 --> 00:05:55,820
the benefits that we get from asabi but

00:05:51,350 --> 00:06:04,840
also from a real switch level

00:05:55,820 --> 00:06:08,860
programming of forwarding those etc so

00:06:04,840 --> 00:06:11,870
we looked at what we got right now and

00:06:08,860 --> 00:06:14,180
we looked at what is something that we

00:06:11,870 --> 00:06:18,410
can preserve in the future that will

00:06:14,180 --> 00:06:22,390
give us the fast path you know for the

00:06:18,410 --> 00:06:25,510
packets going not south or east west

00:06:22,390 --> 00:06:27,300
but whatever else needs to happen to

00:06:25,510 --> 00:06:31,330
configure that SIV

00:06:27,300 --> 00:06:33,850
device may not be something that

00:06:31,330 --> 00:06:36,520
remained constant right over generations

00:06:33,850 --> 00:06:39,820
so so we looked at a less common

00:06:36,520 --> 00:06:43,480
denominator of what seems to stick and

00:06:39,820 --> 00:06:44,920
can be expanded in the future but the

00:06:43,480 --> 00:06:46,720
other things that are necessary to

00:06:44,920 --> 00:06:51,580
configure the device and that can be

00:06:46,720 --> 00:06:57,010
done on a control plane and so we come

00:06:51,580 --> 00:06:59,650
up we came up with the some set of

00:06:57,010 --> 00:07:01,480
features that are you know to be

00:06:59,650 --> 00:07:05,040
presented with the generations and we

00:07:01,480 --> 00:07:08,830
call it the base mode features and then

00:07:05,040 --> 00:07:11,500
built upon that something we're calling

00:07:08,830 --> 00:07:16,030
it the adaptive virtual function and

00:07:11,500 --> 00:07:18,720
this is something we will basis be we

00:07:16,030 --> 00:07:21,400
will be basing it on i-4 ebf travel and

00:07:18,720 --> 00:07:26,020
most likely rebranding it for our future

00:07:21,400 --> 00:07:29,200
devices you know I kind of flushed it

00:07:26,020 --> 00:07:32,860
down the base features that we would be

00:07:29,200 --> 00:07:34,840
preserving which is you know singer will

00:07:32,860 --> 00:07:41,940
check them in TS or floats the multi cue

00:07:34,840 --> 00:07:45,430
support or assess things like that so

00:07:41,940 --> 00:07:47,950
what does it mean to preserve some kind

00:07:45,430 --> 00:07:51,870
of base mode compatibility going forward

00:07:47,950 --> 00:07:55,120
and hardware software what that means is

00:07:51,870 --> 00:07:57,820
having a fixed register definitions in

00:07:55,120 --> 00:08:04,900
the hardware for some limited range of

00:07:57,820 --> 00:08:07,690
registers defined the base mode having a

00:08:04,900 --> 00:08:09,040
fixed metadata format for DMA this is

00:08:07,690 --> 00:08:13,300
the descriptor definitions for

00:08:09,040 --> 00:08:18,450
transferring to receive having some kind

00:08:13,300 --> 00:08:21,100
of a generic a mailbox which can work

00:08:18,450 --> 00:08:23,250
between the virtual function driver and

00:08:21,100 --> 00:08:26,110
the physical function driver so that

00:08:23,250 --> 00:08:29,260
whatever else that there we have

00:08:26,110 --> 00:08:31,210
travelease to configure it can do it

00:08:29,260 --> 00:08:34,960
through the PF driver in a generic

00:08:31,210 --> 00:08:36,729
fashion on the surface side what you

00:08:34,960 --> 00:08:39,459
need is

00:08:36,729 --> 00:08:41,409
some kind of a virtual channel on top of

00:08:39,459 --> 00:08:51,220
the generic mailbox which can be

00:08:41,409 --> 00:08:54,730
expanded for functionality okay so and

00:08:51,220 --> 00:08:59,379
the other thing that we could leave room

00:08:54,730 --> 00:09:02,110
for in hardware and software so that the

00:08:59,379 --> 00:09:04,089
real flower that we're calling that a

00:09:02,110 --> 00:09:07,389
PDF that was truly adaptive in the sense

00:09:04,089 --> 00:09:10,899
that it can go to take benefit of the

00:09:07,389 --> 00:09:13,439
next generation of products and not just

00:09:10,899 --> 00:09:18,119
limited to the base mode functionality

00:09:13,439 --> 00:09:20,439
so for that you would have to kind of

00:09:18,119 --> 00:09:23,199
make sure there's enough room to grow

00:09:20,439 --> 00:09:26,559
both in terms of the number of cues that

00:09:23,199 --> 00:09:28,749
the device will support on on a V on a V

00:09:26,559 --> 00:09:32,110
a function or and the number of

00:09:28,749 --> 00:09:34,569
interrupts so in the hardware

00:09:32,110 --> 00:09:39,459
definitions leave room to grow in that

00:09:34,569 --> 00:09:42,189
space and define the virtual function

00:09:39,459 --> 00:09:45,549
virtual channel on the on the mailbox in

00:09:42,189 --> 00:09:48,040
a way that it can expand to grow more

00:09:45,549 --> 00:09:54,519
and more negotiate more features with

00:09:48,040 --> 00:09:59,110
the PF okay and this highlighting is

00:09:54,519 --> 00:10:02,170
really bugging but I don't know this is

00:09:59,110 --> 00:10:03,819
a simple you know picture kind of

00:10:02,170 --> 00:10:06,309
demonstrating what we are trying to

00:10:03,819 --> 00:10:08,920
achieve there are two three different

00:10:06,309 --> 00:10:12,790
generations of internal Nick's down

00:10:08,920 --> 00:10:16,449
there with running three different PS

00:10:12,790 --> 00:10:20,499
drivers in the hypervisor but all of

00:10:16,449 --> 00:10:23,230
them supporting the same is supported by

00:10:20,499 --> 00:10:28,499
the same virtual function driver in the

00:10:23,230 --> 00:10:28,499
VMS okay thank you

00:10:30,340 --> 00:10:39,840
so yeah so this is the this is the idea

00:10:36,970 --> 00:10:45,400
that we never have to have a different

00:10:39,840 --> 00:10:53,200
virtual function driver ever again okay

00:10:45,400 --> 00:10:58,980
this start kind of goes away the design

00:10:53,200 --> 00:10:58,980
pattern that we were we base our AVF on

00:10:59,040 --> 00:11:06,190
so we will have a single device ID for

00:11:01,870 --> 00:11:09,279
all s IV devices going forward will

00:11:06,190 --> 00:11:12,250
preserve some base definition in the

00:11:09,279 --> 00:11:14,860
hardware make the via traver a dependent

00:11:12,250 --> 00:11:17,140
rather and not an independent driver and

00:11:14,860 --> 00:11:19,630
this is something that always talking

00:11:17,140 --> 00:11:21,160
again that it should be controls on the

00:11:19,630 --> 00:11:24,040
vs represent or rather than it

00:11:21,160 --> 00:11:25,450
controlling itself and and this was

00:11:24,040 --> 00:11:28,089
really valued with what we're doing here

00:11:25,450 --> 00:11:29,710
is if the severe tracker is a dependent

00:11:28,089 --> 00:11:32,290
driver it actually doesn't make any

00:11:29,710 --> 00:11:34,120
difference for itself but it lets the

00:11:32,290 --> 00:11:37,900
control plane which is in the hypervisor

00:11:34,120 --> 00:11:42,460
to decide what traffic ends up in the VF

00:11:37,900 --> 00:11:45,180
driver or what it can send so yeah so

00:11:42,460 --> 00:11:54,010
separate out the data and control plane

00:11:45,180 --> 00:11:57,970
and leave room for you know negotiation

00:11:54,010 --> 00:12:05,470
of advanced features that are proxy

00:11:57,970 --> 00:12:11,830
through the PF driver okay some some

00:12:05,470 --> 00:12:16,060
more on the implementation detail once

00:12:11,830 --> 00:12:19,870
we have a common read driver across

00:12:16,060 --> 00:12:21,760
multiple generations we we have to

00:12:19,870 --> 00:12:24,850
preserve the base registers and DMA

00:12:21,760 --> 00:12:28,000
metadata format in each generation the

00:12:24,850 --> 00:12:32,320
silicon so we kind of publish tab set

00:12:28,000 --> 00:12:34,800
and every device going forward has to

00:12:32,320 --> 00:12:34,800
honor that

00:12:37,740 --> 00:12:42,180
the same goes for the saucer virtual

00:12:40,350 --> 00:12:45,300
channel that we define for communication

00:12:42,180 --> 00:12:48,810
between the TF MVS it will have to be

00:12:45,300 --> 00:12:50,579
published and preserved so that we can

00:12:48,810 --> 00:12:56,279
talk in the same language between the

00:12:50,579 --> 00:13:02,390
pfm beer driver somewhere on the base

00:12:56,279 --> 00:13:06,510
features what we're doing is identifying

00:13:02,390 --> 00:13:09,930
you know at present say di for EVF

00:13:06,510 --> 00:13:12,029
driver supports for queues you know that

00:13:09,930 --> 00:13:16,350
needs to be preserved but at the same

00:13:12,029 --> 00:13:19,050
time we leave room for expansion in the

00:13:16,350 --> 00:13:23,730
in the register set same goes for the

00:13:19,050 --> 00:13:26,519
receipt queues MSX vectors I thought you

00:13:23,730 --> 00:13:29,720
and I should be all of them support RFS

00:13:26,519 --> 00:13:32,519
for multi cue load balancing

00:13:29,720 --> 00:13:38,250
functionality and that is a base feature

00:13:32,519 --> 00:13:42,060
that will be preserved you know text on

00:13:38,250 --> 00:13:48,810
TSO hash for GL all that stuff as base

00:13:42,060 --> 00:13:53,820
feature and should be preserved and you

00:13:48,810 --> 00:13:55,470
know so this is pretty much the you know

00:13:53,820 --> 00:13:59,610
total definition of what we call the

00:13:55,470 --> 00:14:04,529
base features in terms of you know how

00:13:59,610 --> 00:14:07,050
the capabilities so what are the

00:14:04,529 --> 00:14:09,720
external features that are you know the

00:14:07,050 --> 00:14:11,209
i-40 bf and and I should be be a support

00:14:09,720 --> 00:14:15,660
right now

00:14:11,209 --> 00:14:19,190
they support you know VLAN trunking from

00:14:15,660 --> 00:14:24,510
is this mode enabling for SLV devices

00:14:19,190 --> 00:14:28,680
encapsulation or floats they have waste

00:14:24,510 --> 00:14:34,880
program filters in the hardware I for TE

00:14:28,680 --> 00:14:38,220
supports our DNA client drivers as well

00:14:34,880 --> 00:14:39,959
and you know there are whole bunch of

00:14:38,220 --> 00:14:42,630
features that have been added in the

00:14:39,959 --> 00:14:45,360
present generation we have devices to

00:14:42,630 --> 00:14:48,190
make them more useful in the NFP use

00:14:45,360 --> 00:14:51,660
case so this

00:14:48,190 --> 00:14:54,370
is not based features but it remains

00:14:51,660 --> 00:14:57,370
since this is an adapter via travel it

00:14:54,370 --> 00:14:59,950
will still remain as part of i-40 VF but

00:14:57,370 --> 00:15:01,960
the way it will be done would be

00:14:59,950 --> 00:15:06,580
dependent on the underlying PF device

00:15:01,960 --> 00:15:08,380
under lying device right so there's no

00:15:06,580 --> 00:15:09,970
specific limit to whatever your device

00:15:08,380 --> 00:15:12,490
can do and hardware in the upcoming

00:15:09,970 --> 00:15:14,380
devices it is in terms of you know

00:15:12,490 --> 00:15:16,330
resource and capabilities and you know

00:15:14,380 --> 00:15:21,010
throughput and latency what whatnot it

00:15:16,330 --> 00:15:24,070
is just like a PS device but what we are

00:15:21,010 --> 00:15:26,470
trying to achieve here as we want to

00:15:24,070 --> 00:15:28,660
have a single control plane for all the

00:15:26,470 --> 00:15:30,400
PS and we apply drivers and should be in

00:15:28,660 --> 00:15:36,610
the hypervisor instead of VF having its

00:15:30,400 --> 00:15:39,180
own control plane what are the

00:15:36,610 --> 00:15:47,260
challenges in hiring a single VF driver

00:15:39,180 --> 00:15:51,370
for all devices since an internal driver

00:15:47,260 --> 00:15:53,440
is not a static thing the patches added

00:15:51,370 --> 00:15:57,130
their functionality is enabled and it

00:15:53,440 --> 00:16:00,160
keeps growing it would be it would be

00:15:57,130 --> 00:16:02,170
quite a challenge to make sure we are

00:16:00,160 --> 00:16:04,870
not breaking the base functionality and

00:16:02,170 --> 00:16:10,420
it can still work with limited feature

00:16:04,870 --> 00:16:12,760
set on the future devices it does

00:16:10,420 --> 00:16:15,880
increase the validation matrix quite a

00:16:12,760 --> 00:16:17,920
bit for us where when we are adding new

00:16:15,880 --> 00:16:19,810
features under the VF driver we have to

00:16:17,920 --> 00:16:23,650
now tester in all the supported devices

00:16:19,810 --> 00:16:25,240
which are you know from different they

00:16:23,650 --> 00:16:28,510
have different IPS underneath and stuff

00:16:25,240 --> 00:16:32,850
like that so having separate drivers did

00:16:28,510 --> 00:16:35,320
help us in the validation you know

00:16:32,850 --> 00:16:38,380
reducing the validation matrix quite a

00:16:35,320 --> 00:16:41,410
bit where when you change out for the VF

00:16:38,380 --> 00:16:43,570
you don't really have to test it on an

00:16:41,410 --> 00:16:45,730
antic or anything like that but you know

00:16:43,570 --> 00:16:47,500
this will enforce that anything that

00:16:45,730 --> 00:16:52,120
supports the base mode it has to be

00:16:47,500 --> 00:16:53,920
tested in all those devices and every

00:16:52,120 --> 00:16:57,490
pass can potentially break various model

00:16:53,920 --> 00:17:00,490
and make assumptions about online

00:16:57,490 --> 00:17:03,220
and capabilities so we this is this is

00:17:00,490 --> 00:17:03,879
the most challenging part with respect

00:17:03,220 --> 00:17:06,699
to base mode

00:17:03,879 --> 00:17:09,579
you know defining the base functionality

00:17:06,699 --> 00:17:12,929
in the hardware wasn't that hard or you

00:17:09,579 --> 00:17:15,880
know coming up with what the software

00:17:12,929 --> 00:17:17,380
design should be to make this possible

00:17:15,880 --> 00:17:19,240
it wasn't the hard part but I think this

00:17:17,380 --> 00:17:27,669
is where we will be spending a lot of

00:17:19,240 --> 00:17:28,960
time keeping it that way ok so you know

00:17:27,669 --> 00:17:31,539
just you went over what was the problem

00:17:28,960 --> 00:17:34,299
definition and this kind of summarizes

00:17:31,539 --> 00:17:41,590
what we with a user experience once we

00:17:34,299 --> 00:17:48,130
have a single VF driver so the idea here

00:17:41,590 --> 00:17:51,309
is if you were to pick Colonel X and in

00:17:48,130 --> 00:17:56,140
the driver it had a real flower which

00:17:51,309 --> 00:17:59,440
was a bf certified level it will sit on

00:17:56,140 --> 00:18:01,950
ten years from now and will run on the

00:17:59,440 --> 00:18:06,070
latest device that Intel releases right

00:18:01,950 --> 00:18:07,870
although if you were to take the latest

00:18:06,070 --> 00:18:09,159
ABS novel from the latest colonel at

00:18:07,870 --> 00:18:11,620
that time you will get more

00:18:09,159 --> 00:18:14,620
functionality but still you will still

00:18:11,620 --> 00:18:24,520
get basic connectivity with any old ADF

00:18:14,620 --> 00:18:30,250
driver yes so that's pretty much is what

00:18:24,520 --> 00:18:33,730
the users want we also had some of the

00:18:30,250 --> 00:18:36,940
you know considerations in - should we

00:18:33,730 --> 00:18:38,980
be considering offering word i/o like so

00:18:36,940 --> 00:18:41,289
what are you into you know there's

00:18:38,980 --> 00:18:45,600
already a what our driver could be make

00:18:41,289 --> 00:18:48,580
Intel devices have what I offload on it

00:18:45,600 --> 00:18:52,870
and instead of coming up with this ADF

00:18:48,580 --> 00:18:56,760
there we came of it there's some

00:18:52,870 --> 00:19:00,340
challenges there the way the word i/o

00:18:56,760 --> 00:19:02,559
bearings and are defined and they're not

00:19:00,340 --> 00:19:04,810
very awkward friendly is how we look at

00:19:02,559 --> 00:19:12,760
it they're too many interaction

00:19:04,810 --> 00:19:15,220
and pointers going the DM engine

00:19:12,760 --> 00:19:16,600
so instead of having an emulator device

00:19:15,220 --> 00:19:19,240
that what IO

00:19:16,600 --> 00:19:28,900
runs on you could hook it up to a real

00:19:19,240 --> 00:19:31,480
of ice so instead of sorry we're running

00:19:28,900 --> 00:19:35,890
could I still back it up within a CeraVe

00:19:31,480 --> 00:19:38,740
device that's what I mean so so then I

00:19:35,890 --> 00:19:42,160
don't have to provide my you know we

00:19:38,740 --> 00:19:45,760
have driver what is that - every device

00:19:42,160 --> 00:19:50,400
you want video to serve as your friend

00:19:45,760 --> 00:19:55,230
if you're a virtual function yes and so

00:19:50,400 --> 00:19:57,850
you know there is some looking into it

00:19:55,230 --> 00:20:01,750
definitely that we could do and if we

00:19:57,850 --> 00:20:04,150
are going through the what I 1.1 spec we

00:20:01,750 --> 00:20:06,700
may want to consider the option where it

00:20:04,150 --> 00:20:11,440
gets the benefit of his I we backed

00:20:06,700 --> 00:20:13,180
interfaces this could be a separate

00:20:11,440 --> 00:20:15,820
discussion but you know we just wanted

00:20:13,180 --> 00:20:18,220
to kind of bring it up that we did

00:20:15,820 --> 00:20:20,830
consider what is the solution

00:20:18,220 --> 00:20:24,010
why do users who are asking for a single

00:20:20,830 --> 00:20:27,340
VF driver want it and I think they like

00:20:24,010 --> 00:20:30,510
the water-style interfaces which are

00:20:27,340 --> 00:20:30,510
generate enough

00:20:34,750 --> 00:20:41,750
awesome because everything is going to

00:20:38,720 --> 00:20:47,720
be ebps now can't you just draw the EPS

00:20:41,750 --> 00:21:01,250
for the driver and doctor considerations

00:20:47,720 --> 00:21:03,170
for this okay future workforce

00:21:01,250 --> 00:21:06,559
publishing a standard specification for

00:21:03,170 --> 00:21:08,540
an AVF device what that also means is it

00:21:06,559 --> 00:21:11,480
once we have this host interface

00:21:08,540 --> 00:21:14,360
published for a BF device some other

00:21:11,480 --> 00:21:22,040
vendor could actually have their own

00:21:14,360 --> 00:21:24,919
device that supports that can use a VF

00:21:22,040 --> 00:21:27,830
as the driver right so it's almost like

00:21:24,919 --> 00:21:41,390
we are defining a specification for a

00:21:27,830 --> 00:21:43,610
device for this driver the biggest

00:21:41,390 --> 00:21:48,140
issues between having separate drivers

00:21:43,610 --> 00:21:49,460
was that we had code duplication and so

00:21:48,140 --> 00:21:53,210
that when there was a patch for the PF

00:21:49,460 --> 00:21:58,160
there was a patch with EF there wasn't

00:21:53,210 --> 00:22:01,570
which case EF was broken or how is the

00:21:58,160 --> 00:22:04,250
single driver model going to reduce or

00:22:01,570 --> 00:22:07,250
to fix this code duplication because I

00:22:04,250 --> 00:22:09,200
can still see going forward that we're

00:22:07,250 --> 00:22:11,030
going to have oh if we have a match for

00:22:09,200 --> 00:22:12,320
the PF we're gonna have to have a patch

00:22:11,030 --> 00:22:17,450
for this model

00:22:12,320 --> 00:22:20,120
you know this single EF driver so from

00:22:17,450 --> 00:22:21,559
our perspective the process right now it

00:22:20,120 --> 00:22:24,020
doesn't have to change for anything

00:22:21,559 --> 00:22:25,850
going upstream the Epstein development

00:22:24,020 --> 00:22:27,590
process doesn't change is slow down and

00:22:25,850 --> 00:22:30,440
in any way that the driver keeps

00:22:27,590 --> 00:22:34,429
advancing the cool part is is that the

00:22:30,440 --> 00:22:38,140
2017 VF driver that was locked into a VM

00:22:34,429 --> 00:22:41,240
image in 2017 will still run on a 2019

00:22:38,140 --> 00:22:42,000
hardware part that comes out in 2019 so

00:22:41,240 --> 00:22:45,020
you have this

00:22:42,000 --> 00:22:47,640
after ever and it will just work with

00:22:45,020 --> 00:22:48,900
new hardware and a new PF that it's

00:22:47,640 --> 00:22:50,820
never seen before right

00:22:48,900 --> 00:22:52,890
we'll have tested it hopefully of course

00:22:50,820 --> 00:22:54,960
but the idea is is that you get that

00:22:52,890 --> 00:22:57,630
future compatibility so the kernel keeps

00:22:54,960 --> 00:23:00,300
advancing right for 4.11 kernel has a

00:22:57,630 --> 00:23:02,670
new i-40 EPF driver 4.12 has a new i-40

00:23:00,300 --> 00:23:04,530
EPF driver with more patches in it the

00:23:02,670 --> 00:23:06,090
problem that you have is not addressed

00:23:04,530 --> 00:23:07,320
by this model at all the problem that

00:23:06,090 --> 00:23:09,270
you mentioned is not addressed by this

00:23:07,320 --> 00:23:11,250
model at all right we're talking but it

00:23:09,270 --> 00:23:12,450
definitely should be addressed we would

00:23:11,250 --> 00:23:14,430
like to make it so that the two were

00:23:12,450 --> 00:23:16,170
split there's a reason that that's

00:23:14,430 --> 00:23:18,780
happening upstream but it's not really

00:23:16,170 --> 00:23:21,920
relevant to the community it's more of a

00:23:18,780 --> 00:23:24,030
development process thing for us but

00:23:21,920 --> 00:23:25,380
actually one that I have it's kind of

00:23:24,030 --> 00:23:30,240
the inverse of what Jeff was just

00:23:25,380 --> 00:23:33,840
issuing I asked me about at what point

00:23:30,240 --> 00:23:36,240
do you quit adding new devices to an

00:23:33,840 --> 00:23:38,430
existing driver but if you will imagine

00:23:36,240 --> 00:23:40,950
if we had never forked a 1000 and

00:23:38,430 --> 00:23:44,940
everything going all the way back all

00:23:40,950 --> 00:23:47,490
ran on a 1,000 you know at what point do

00:23:44,940 --> 00:23:49,860
we stop adding backwards compatibility

00:23:47,490 --> 00:23:51,570
just for the sake of maintainability of

00:23:49,860 --> 00:23:53,160
the driver are we gonna somehow find a

00:23:51,570 --> 00:23:56,610
different way to split off things that

00:23:53,160 --> 00:23:58,140
we can lock the base mode driver while

00:23:56,610 --> 00:24:01,550
still having new drivers for the

00:23:58,140 --> 00:24:01,550
advanced functionality we're adding

00:24:05,240 --> 00:24:16,380
where we could have two drivers whereas

00:24:10,140 --> 00:24:19,260
you know what's that two drivers one of

00:24:16,380 --> 00:24:21,390
the person there's no driver which just

00:24:19,260 --> 00:24:23,580
does that limited thing and runs on

00:24:21,390 --> 00:24:25,080
every single device but we always have

00:24:23,580 --> 00:24:27,920
another backup layer which is an

00:24:25,080 --> 00:24:31,500
extended features driver in terms of

00:24:27,920 --> 00:24:33,750
maintenance it is no each other is not

00:24:31,500 --> 00:24:35,800
an easy solution either right and it's

00:24:33,750 --> 00:24:38,620
not a great user experience

00:24:35,800 --> 00:24:41,770
well if I have already you know install

00:24:38,620 --> 00:24:44,500
my kernel and you know pick the driver

00:24:41,770 --> 00:24:45,880
and then you know if I wanted an

00:24:44,500 --> 00:24:51,430
extended feature I have to actually

00:24:45,880 --> 00:24:52,930
rebuild or do something the the user

00:24:51,430 --> 00:24:54,400
experience should be transparent when

00:24:52,930 --> 00:24:56,350
they're going from base feature to an

00:24:54,400 --> 00:24:57,820
advanced feature that it should all be

00:24:56,350 --> 00:24:59,260
having done the same driver I mean

00:24:57,820 --> 00:25:02,260
that's the conclusion we came up with

00:24:59,260 --> 00:25:03,970
you're right but my concern concern is

00:25:02,260 --> 00:25:05,950
it might end up going the other way

00:25:03,970 --> 00:25:08,920
what you end up with is after a while

00:25:05,950 --> 00:25:10,540
you've added you know you're let's say

00:25:08,920 --> 00:25:12,790
we get up to the point of terabit you

00:25:10,540 --> 00:25:14,560
know ten years from now you know you're

00:25:12,790 --> 00:25:16,300
adding your terabit driver but in the

00:25:14,560 --> 00:25:18,640
process to your existing base for your

00:25:16,300 --> 00:25:20,680
40 gig drivers now who nobody uses

00:25:18,640 --> 00:25:21,880
anymore suddenly you know you've got a

00:25:20,680 --> 00:25:23,650
bunch of customers that are coming up

00:25:21,880 --> 00:25:25,780
because their stuff doesn't work anymore

00:25:23,650 --> 00:25:37,390
because you went and added new code

00:25:25,780 --> 00:25:40,540
without validating the old make sure it

00:25:37,390 --> 00:25:50,500
works on all those old devices as well

00:25:40,540 --> 00:25:52,780
right I think one of the things that

00:25:50,500 --> 00:25:54,340
that is important about doing it

00:25:52,780 --> 00:25:59,410
specifically for this is that the domain

00:25:54,340 --> 00:26:00,940
space is smaller a couple slides back

00:25:59,410 --> 00:26:02,350
they're pointing out they're gonna have

00:26:00,940 --> 00:26:03,790
the option extending these drivers so

00:26:02,350 --> 00:26:06,130
that they support what was it you had

00:26:03,790 --> 00:26:13,510
RDMA and several other different

00:26:06,130 --> 00:26:15,550
features so if a PMO could limit the VF

00:26:13,510 --> 00:26:17,800
from having any of those features well

00:26:15,550 --> 00:26:20,470
write the PF can limit the VF but see

00:26:17,800 --> 00:26:23,530
the problem is my concern is I just

00:26:20,470 --> 00:26:25,570
would prefer to have us see it see it

00:26:23,530 --> 00:26:29,560
through such that we have one base mode

00:26:25,570 --> 00:26:31,330
VF like with a two tupple ID and then a

00:26:29,560 --> 00:26:33,100
separate driver for your advanced

00:26:31,330 --> 00:26:36,720
features there under like a four couple

00:26:33,100 --> 00:26:41,260
ID so you could split the two up somehow

00:26:36,720 --> 00:26:42,340
just so you don't end up with one driver

00:26:41,260 --> 00:26:45,040
that ends up with a bunch of feature

00:26:42,340 --> 00:26:45,990
creep and maintainability issues for the

00:26:45,040 --> 00:26:47,880
base mode

00:26:45,990 --> 00:26:50,130
we probably should be forking it so we

00:26:47,880 --> 00:26:51,539
have a advanced features driver and a

00:26:50,130 --> 00:26:53,279
base feature stress yeah we actually

00:26:51,539 --> 00:26:57,090
thought through this a lot right we

00:26:53,279 --> 00:26:58,620
discussed this a bunch but and and what

00:26:57,090 --> 00:27:00,690
we decided and after talking with our

00:26:58,620 --> 00:27:02,370
validation is that either way you end up

00:27:00,690 --> 00:27:05,309
having to test both the same amount

00:27:02,370 --> 00:27:08,669
right you're really not earning yourself

00:27:05,309 --> 00:27:12,240
anything reducing the effort or reducing

00:27:08,669 --> 00:27:16,890
the creep like we said that the the

00:27:12,240 --> 00:27:18,690
biggest chunk of work is that you have

00:27:16,890 --> 00:27:21,000
to go back and do regression testing

00:27:18,690 --> 00:27:22,649
right on on these older let's say like

00:27:21,000 --> 00:27:26,309
you know the driver that came out in

00:27:22,649 --> 00:27:27,690
some distro in 2017 right or 2018 you

00:27:26,309 --> 00:27:31,020
got to make sure that driver still works

00:27:27,690 --> 00:27:33,480
on your new PF and hardware that you're

00:27:31,020 --> 00:27:35,340
shipping right so we do add a bunch of

00:27:33,480 --> 00:27:37,140
regression testing and I think that's

00:27:35,340 --> 00:27:38,490
one of the issues that that she was

00:27:37,140 --> 00:27:44,490
going to talk about on this slide right

00:27:38,490 --> 00:27:46,890
is the is that we want to make automated

00:27:44,490 --> 00:27:49,320
progression much easier than it is today

00:27:46,890 --> 00:27:50,610
by by doing some tricks and that's one

00:27:49,320 --> 00:27:52,909
thing we wanted to bring up here for a

00:27:50,610 --> 00:27:55,980
discussion point is how do you enable

00:27:52,909 --> 00:27:57,779
better testing of for instance these

00:27:55,980 --> 00:27:59,279
older devices right how do you force the

00:27:57,779 --> 00:28:01,440
device in the base mode should we use a

00:27:59,279 --> 00:28:03,059
Naomi to mention this now sure do you

00:28:01,440 --> 00:28:05,130
want you know should we use a Kay config

00:28:03,059 --> 00:28:07,020
option that lets you compile a driver

00:28:05,130 --> 00:28:09,240
that does like a reverse negotiation it

00:28:07,020 --> 00:28:11,490
always negotiates to the lowest right it

00:28:09,240 --> 00:28:14,460
forces the PF to advertise the lowest

00:28:11,490 --> 00:28:16,590
capability right out of the box so that

00:28:14,460 --> 00:28:19,260
you can test the base mode VF easily on

00:28:16,590 --> 00:28:21,000
some older VM image that you have that

00:28:19,260 --> 00:28:22,350
this is a problem right because normally

00:28:21,000 --> 00:28:24,720
you wouldn't ever want that from the

00:28:22,350 --> 00:28:26,460
from this high forty EVF driver right

00:28:24,720 --> 00:28:29,070
here that the PF driver would advertise

00:28:26,460 --> 00:28:30,330
you can have whatever you like right or

00:28:29,070 --> 00:28:34,740
you can have whatever I can give you

00:28:30,330 --> 00:28:36,960
that works so yeah we we didn't really

00:28:34,740 --> 00:28:38,580
like the idea either of doing two

00:28:36,960 --> 00:28:40,380
separate drivers with support for the

00:28:38,580 --> 00:28:42,779
same device ID because then you get into

00:28:40,380 --> 00:28:44,399
the which driver loads first problem and

00:28:42,779 --> 00:28:46,649
there's the kernel module load order

00:28:44,399 --> 00:28:49,559
thing but it gets ugly really fast and

00:28:46,649 --> 00:28:52,919
really hard to explain to users and why

00:28:49,559 --> 00:28:54,450
the other driver right you still have to

00:28:52,919 --> 00:28:56,220
allocate that base driver

00:28:54,450 --> 00:28:59,730
the new device I mean doesn't really

00:28:56,220 --> 00:29:01,830
solve the problem so in fact like the

00:28:59,730 --> 00:29:03,270
validation matrix would increase the you

00:29:01,830 --> 00:29:07,380
know two drivers there rather than a

00:29:03,270 --> 00:29:12,720
single driver yeah that's pretty much

00:29:07,380 --> 00:29:17,450
what we have and that's the model we are

00:29:12,720 --> 00:29:23,490
going with keeping it simple you know

00:29:17,450 --> 00:29:26,460
reduce you know the direct memory

00:29:23,490 --> 00:29:28,740
footprint in the vf2 just just the hot

00:29:26,460 --> 00:29:32,160
you know the hot bath and everything

00:29:28,740 --> 00:29:35,430
else is negotiated through the through

00:29:32,160 --> 00:29:39,930
the PM driver over the Wachau and that

00:29:35,430 --> 00:29:41,610
hopefully will give us you know a you

00:29:39,930 --> 00:29:43,940
know device driver model that lasts for

00:29:41,610 --> 00:29:43,940
many generations

00:29:45,980 --> 00:29:52,290
so if you upgrade your pilot you have

00:29:50,670 --> 00:29:53,820
the base feature set in the advanced

00:29:52,290 --> 00:29:55,410
feature set and only the base feature

00:29:53,820 --> 00:29:57,270
set is guaranteed to be future

00:29:55,410 --> 00:30:00,030
compatible so you could upgrade a

00:29:57,270 --> 00:30:01,980
physical NIC device and then the the ADF

00:30:00,030 --> 00:30:10,020
driver in the guests might see fewer

00:30:01,980 --> 00:30:12,630
features fewer features but if you were

00:30:10,020 --> 00:30:13,950
to go get the latest ad of driver you

00:30:12,630 --> 00:30:16,620
know you might still get all the

00:30:13,950 --> 00:30:18,360
extended features this was that you

00:30:16,620 --> 00:30:21,740
never have to upgrade that a BF driver

00:30:18,360 --> 00:30:27,660
in your fixed guest from the old days of

00:30:21,740 --> 00:30:31,020
you wouldn't have to break now is like

00:30:27,660 --> 00:30:33,660
when we put out a new device you either

00:30:31,020 --> 00:30:37,980
do not have a VF driver that can run it

00:30:33,660 --> 00:30:39,870
on it or there's some delay and any of

00:30:37,980 --> 00:30:41,760
the VMS that you might have created five

00:30:39,870 --> 00:30:44,130
years with the VF driver on it will not

00:30:41,760 --> 00:30:45,810
work on the new device right so we are

00:30:44,130 --> 00:30:48,390
solving only the basic connectivity

00:30:45,810 --> 00:30:50,250
problem going forward if you only

00:30:48,390 --> 00:30:52,560
extended features you still have to get

00:30:50,250 --> 00:30:54,220
the latest ADF driver all right so there

00:30:52,560 --> 00:30:57,850
is a risk if you upgrade

00:30:54,220 --> 00:31:04,809
the host the guests may see the

00:30:57,850 --> 00:31:06,340
reduction in feature set yes yeah if it

00:31:04,809 --> 00:31:07,929
gives the vendor a chance to slowly

00:31:06,340 --> 00:31:09,399
upgrade all their VM images that they

00:31:07,929 --> 00:31:11,590
wish to get the new features right it's

00:31:09,399 --> 00:31:13,690
kind of a it's it's not an either-or

00:31:11,590 --> 00:31:15,129
deal it's a you can move one from one

00:31:13,690 --> 00:31:19,600
working scenario to a better working

00:31:15,129 --> 00:31:21,820
scenario yeah the the you know this this

00:31:19,600 --> 00:31:24,730
horror definition that we've said is

00:31:21,820 --> 00:31:26,740
kind of we pared down what's what we

00:31:24,730 --> 00:31:28,870
think the minimum useful thing is for a

00:31:26,740 --> 00:31:30,879
via instance and that's what this

00:31:28,870 --> 00:31:32,590
basement is about and you know honestly

00:31:30,879 --> 00:31:34,240
if you have a programmable Nick or an

00:31:32,590 --> 00:31:36,789
FPGA based Nick or something you could

00:31:34,240 --> 00:31:39,490
probably write a hardware interface to

00:31:36,789 --> 00:31:41,409
this definition and advertise the device

00:31:39,490 --> 00:31:43,720
ID and our bf driver will load on it and

00:31:41,409 --> 00:31:45,909
right right you you can you could do

00:31:43,720 --> 00:31:48,100
that and any vendor could do that and

00:31:45,909 --> 00:31:49,840
other OSS could do that so think about

00:31:48,100 --> 00:31:52,509
this it enables a bunch of people all of

00:31:49,840 --> 00:31:54,730
a sudden right this driver once for on

00:31:52,509 --> 00:31:57,220
some random OS like an embedded or an

00:31:54,730 --> 00:31:58,720
IOT or whatever you want you know kind

00:31:57,220 --> 00:32:00,220
of scenario some other non Linux II

00:31:58,720 --> 00:32:01,659
thing or maybe some tiny Linux II thing

00:32:00,220 --> 00:32:04,059
and have it stay and we'll have it work

00:32:01,659 --> 00:32:06,610
for a long period of time it also

00:32:04,059 --> 00:32:10,330
hopefully reduces the you know the bug

00:32:06,610 --> 00:32:11,950
creep of you know an older VF driver if

00:32:10,330 --> 00:32:14,259
it has to fall back to base mode the PF

00:32:11,950 --> 00:32:16,480
can turn off features if it doesn't work

00:32:14,259 --> 00:32:17,620
or if you don't want it so you can you

00:32:16,480 --> 00:32:20,169
don't have an interface for today but

00:32:17,620 --> 00:32:23,200
you could tell the PF you know don't let

00:32:20,169 --> 00:32:26,379
this via have XY and Z feature right

00:32:23,200 --> 00:32:28,120
it's asking the PF for everything right

00:32:26,379 --> 00:32:29,320
it's asking the PF can I do this can I

00:32:28,120 --> 00:32:32,289
do that

00:32:29,320 --> 00:32:34,029
so that that's we kind of you know

00:32:32,289 --> 00:32:39,090
paired off the interface to what what

00:32:34,029 --> 00:32:39,090
work was necessary and what was optional

00:33:50,510 --> 00:33:57,720
once we publish a VF device any vendor

00:33:55,050 --> 00:33:58,650
could adapt it and we all have a common

00:33:57,720 --> 00:34:01,800
driver

00:33:58,650 --> 00:34:04,860
so it's vendor agnostic or we were tayo

00:34:01,800 --> 00:34:07,800
in such a way that it is it can get the

00:34:04,860 --> 00:34:11,850
benefits of SRV right so those are the

00:34:07,800 --> 00:34:13,590
two options here you wanted to add

00:34:11,850 --> 00:34:15,330
something does he know I was saying this

00:34:13,590 --> 00:34:16,950
is just this is our effort at starting

00:34:15,330 --> 00:34:18,780
at that point and we actually don't

00:34:16,950 --> 00:34:20,460
object at all to anybody coming along

00:34:18,780 --> 00:34:21,870
and implementing this interface right if

00:34:20,460 --> 00:34:23,540
they wanted to it's simple enough

00:34:21,870 --> 00:34:26,250
interface it's really pretty tiny

00:34:23,540 --> 00:34:28,020
the tricky part is the descriptor right

00:34:26,250 --> 00:34:29,790
has to kind of stay the same because the

00:34:28,020 --> 00:34:31,410
driver expects a particular layout of

00:34:29,790 --> 00:34:34,230
the ring and the way the descriptors

00:34:31,410 --> 00:34:35,310
work and it's of course targeted at our

00:34:34,230 --> 00:34:37,290
hardware because we wanted to make it

00:34:35,310 --> 00:34:38,580
work on our stuff to begin with but you

00:34:37,290 --> 00:34:41,400
know like I said if you have a versatile

00:34:38,580 --> 00:34:43,020
part and you can program it to export

00:34:41,400 --> 00:34:47,400
this interface then it'll just work

00:34:43,020 --> 00:34:49,710
should this work right I mean we're open

00:34:47,400 --> 00:34:51,270
to collaboration if we you know want to

00:34:49,710 --> 00:34:56,460
define something that is vendor agnostic

00:34:51,270 --> 00:34:57,300
and we can preserve it so you say that

00:34:56,460 --> 00:34:59,790
via to you

00:34:57,300 --> 00:35:02,640
when that one is not is direction

00:34:59,790 --> 00:35:04,860
because of perseverance and if you

00:35:02,640 --> 00:35:07,140
consider any kind of via the internet or

00:35:04,860 --> 00:35:09,540
something you because each supervisor as

00:35:07,140 --> 00:35:11,970
their own vinick's so where are all the

00:35:09,540 --> 00:35:13,890
efficiencies issued today's so why not

00:35:11,970 --> 00:35:15,690
coming with the software models that

00:35:13,890 --> 00:35:17,280
would fit some other models and maybe

00:35:15,690 --> 00:35:20,580
let's forget of your time as it is today

00:35:17,280 --> 00:35:22,410
but something new that will be usable

00:35:20,580 --> 00:35:28,320
for software i can as well as father

00:35:22,410 --> 00:35:30,090
beckons folks at Intel who are trying to

00:35:28,320 --> 00:35:32,340
pursue that option that can we define

00:35:30,090 --> 00:35:35,400
what our two or 1.1 whatever you call it

00:35:32,340 --> 00:35:38,610
the next specification forward IO which

00:35:35,400 --> 00:35:40,680
kind of gives us the option of having a

00:35:38,610 --> 00:35:42,900
real I or device behind it and has hired

00:35:40,680 --> 00:35:47,150
you back device so we get the benefit of

00:35:42,900 --> 00:35:50,760
Si we stupid but I'd the vendor agnostic

00:35:47,150 --> 00:35:54,420
quality of what iOS all right so that's

00:35:50,760 --> 00:35:56,340
a consideration as well and if you know

00:35:54,420 --> 00:35:58,350
whoever is working on the next back

00:35:56,340 --> 00:36:03,620
forward IO we would be really happy to

00:35:58,350 --> 00:36:03,620

YouTube URL: https://www.youtube.com/watch?v=eo8SqFAR550


