Title: TLS Receive Side Crypto Oï¬„oad
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 1 - Nov 08 2017
Description: 
	Speaker: Boris Pismenny, Ilya Lesokhin, Liran Liss
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?pismenny-tlscrypto-talk
Captions: 
	00:00:03,010 --> 00:00:10,030
okay hi I'm burst this talk is about

00:00:06,890 --> 00:00:14,330
TLS receive side of flow of crypto to

00:00:10,030 --> 00:00:18,919
network interface controls so we'll

00:00:14,330 --> 00:00:21,169
start with some background about TLS TLS

00:00:18,919 --> 00:00:23,660
has record protocol that carries

00:00:21,169 --> 00:00:27,619
application data so the user provides

00:00:23,660 --> 00:00:33,079
its data which is then being segmented

00:00:27,619 --> 00:00:35,989
into those records of 16k afterwards the

00:00:33,079 --> 00:00:38,350
data is encrypted in these chunks where

00:00:35,989 --> 00:00:41,570
an authentication tag has been gathered

00:00:38,350 --> 00:00:45,440
finally the TLS record header is added

00:00:41,570 --> 00:00:48,170
and those records are sent over the wire

00:00:45,440 --> 00:00:54,739
for example using TCP where it's

00:00:48,170 --> 00:00:58,370
segmented to MSS sized units so about

00:00:54,739 --> 00:01:00,440
TLS script offload ideally packets would

00:00:58,370 --> 00:01:04,030
be processed independently such is the

00:01:00,440 --> 00:01:08,570
case for IPSec and DTLS for example

00:01:04,030 --> 00:01:11,540
however in TLS each record is processed

00:01:08,570 --> 00:01:14,570
independently with a small caveat where

00:01:11,540 --> 00:01:17,390
there is an out-of-band TLS sequence

00:01:14,570 --> 00:01:21,649
number TLS record sequence number that

00:01:17,390 --> 00:01:24,439
is also required for decryption and so

00:01:21,649 --> 00:01:30,140
the NIC requires to maintain some states

00:01:24,439 --> 00:01:31,880
this state is needed to process in the

00:01:30,140 --> 00:01:34,100
next packet so state from the previous

00:01:31,880 --> 00:01:40,250
packet is required to process the next

00:01:34,100 --> 00:01:42,979
packet of the same record okay so

00:01:40,250 --> 00:01:45,649
motivation in the previous native talk

00:01:42,979 --> 00:01:46,670
I've presented the transmit side TLS

00:01:45,649 --> 00:01:48,680
script offload

00:01:46,670 --> 00:01:50,180
so we've met some performance

00:01:48,680 --> 00:01:53,420
measurements and I hope it would serve

00:01:50,180 --> 00:01:55,549
for motivation to perform Eric's crypto

00:01:53,420 --> 00:01:57,890
offload as well so what we've done we

00:01:55,549 --> 00:01:59,390
have we had a set up of to the own

00:01:57,890 --> 00:02:01,490
machines connected back to back using

00:01:59,390 --> 00:02:05,960
NIC that supports still a stick script

00:02:01,490 --> 00:02:09,200
offload called the de novo TLS and we're

00:02:05,960 --> 00:02:11,900
an IPF with a patch that makes it use

00:02:09,200 --> 00:02:14,430
open ssl to get the handshake up and

00:02:11,900 --> 00:02:17,299
then you can send data

00:02:14,430 --> 00:02:21,390
and we compared the following data paths

00:02:17,299 --> 00:02:23,430
the first is open SSL with SSL read and

00:02:21,390 --> 00:02:25,849
write which are the api's to send and

00:02:23,430 --> 00:02:28,590
receive data using the open SSL library

00:02:25,849 --> 00:02:30,690
second is colonel TLS with Shannon

00:02:28,590 --> 00:02:32,489
receive a door flow the receivers

00:02:30,690 --> 00:02:36,840
without offload but this end is using

00:02:32,489 --> 00:02:40,709
offload and and the final one is the TCP

00:02:36,840 --> 00:02:43,799
send and receive we compare how TCP just

00:02:40,709 --> 00:02:49,859
to get an upper limit to how much can we

00:02:43,799 --> 00:02:51,690
improve in this offload and everything

00:02:49,859 --> 00:02:53,940
has been normalized top and SSL so I'll

00:02:51,690 --> 00:02:56,160
explain the graph now so on the x-axis

00:02:53,940 --> 00:02:58,319
we have a record size and we present our

00:02:56,160 --> 00:03:00,060
single record size which is the the most

00:02:58,319 --> 00:03:03,870
interesting one the maximal record size

00:03:00,060 --> 00:03:06,870
of open a cell which is 16 K and on the

00:03:03,870 --> 00:03:08,430
y-axis we have speed-up which is

00:03:06,870 --> 00:03:11,099
normalized to the openness cell

00:03:08,430 --> 00:03:12,659
performance so so here on the left we

00:03:11,099 --> 00:03:16,859
have the open cell performance which is

00:03:12,659 --> 00:03:19,829
1 the normalized one in the middle we

00:03:16,859 --> 00:03:25,489
have the KTLA speed off load which is

00:03:19,829 --> 00:03:30,959
3.1 and on the left the left most one is

00:03:25,489 --> 00:03:34,049
vanilla TCP the the measurement here is

00:03:30,959 --> 00:03:35,700
the bandwidth divided by CP utilization

00:03:34,049 --> 00:03:38,459
the reason we use this measurement is

00:03:35,700 --> 00:03:40,829
because bandwidth just doesn't prove the

00:03:38,459 --> 00:03:45,930
bottleneck is the receive side which is

00:03:40,829 --> 00:03:48,209
doing crypto in its 100% CPU and so we

00:03:45,930 --> 00:03:50,010
hope that we could show bandwidth if we

00:03:48,209 --> 00:03:54,049
had the receive side or flawed and we

00:03:50,010 --> 00:04:00,359
would get free expand with more or less

00:03:54,049 --> 00:04:02,819
so this is our motivation here ok so

00:04:00,359 --> 00:04:07,410
Katie Ellis is now upstream we have a

00:04:02,819 --> 00:04:09,419
user space API to provide users with TLS

00:04:07,410 --> 00:04:12,030
inside the kernel would utilize data

00:04:09,419 --> 00:04:14,669
part currently it's only the same side

00:04:12,030 --> 00:04:17,910
but we we envision the receive side as

00:04:14,669 --> 00:04:19,500
well the user space today is that we

00:04:17,910 --> 00:04:21,660
start with the TCP connection you

00:04:19,500 --> 00:04:24,630
probably can't see this but I'll explain

00:04:21,660 --> 00:04:27,490
anyway you start with the TCP connection

00:04:24,630 --> 00:04:30,970
you open a socket as you usually do and

00:04:27,490 --> 00:04:35,139
then TLS is enabled using a socket

00:04:30,970 --> 00:04:37,539
option which replaces the send functions

00:04:35,139 --> 00:04:41,620
to TLS and functions which eventually

00:04:37,539 --> 00:04:45,030
call the TCP send functions so the

00:04:41,620 --> 00:04:48,300
extension to the receive side is

00:04:45,030 --> 00:04:51,729
relatively similar we had an additional

00:04:48,300 --> 00:04:54,460
socket option for the receive side it

00:04:51,729 --> 00:04:57,610
would TLS are except adoption and it

00:04:54,460 --> 00:04:59,560
replaces the TLS receive side functions

00:04:57,610 --> 00:05:03,370
and it disappears if cell functions with

00:04:59,560 --> 00:05:07,090
TLS receive side functions so here we

00:05:03,370 --> 00:05:19,210
have an example but you probably can't

00:05:07,090 --> 00:05:22,990
see okay so the model of crypt offload

00:05:19,210 --> 00:05:26,860
is quite similar in the receive by side

00:05:22,990 --> 00:05:28,690
to the transmit side we in the

00:05:26,860 --> 00:05:31,840
initialization phase we provide all the

00:05:28,690 --> 00:05:33,789
crypto material the five double TCP

00:05:31,840 --> 00:05:36,130
sequence number of the next ELS record

00:05:33,789 --> 00:05:39,630
and it's corresponding TLS record

00:05:36,130 --> 00:05:43,650
sequence number and those are provided

00:05:39,630 --> 00:05:48,000
through K TLS to Hardware eventually and

00:05:43,650 --> 00:05:48,000
what Haru is going to do is it's going

00:05:56,150 --> 00:06:03,690
and we're going to decrypt the payload

00:05:59,280 --> 00:06:06,090
of inorder incoming packets and those

00:06:03,690 --> 00:06:08,160
only so headers of these packets remain

00:06:06,090 --> 00:06:10,830
unmodified however the payload is being

00:06:08,160 --> 00:06:12,540
processed and decrypted so it's a pair

00:06:10,830 --> 00:06:15,270
packet indication of whether it was

00:06:12,540 --> 00:06:17,520
processed or not out of order packets

00:06:15,270 --> 00:06:21,420
are modified so we're going to have both

00:06:17,520 --> 00:06:24,480
ciphertext and plaintext packets Trevor

00:06:21,420 --> 00:06:26,190
leaned up the stack and it's a challenge

00:06:24,480 --> 00:06:28,740
we are going to solve and I'm going to

00:06:26,190 --> 00:06:30,660
talk about it in the next slide and this

00:06:28,740 --> 00:06:32,910
software stack is mainly unchanged the

00:06:30,660 --> 00:06:36,120
catalyst is just without crypto tcp/ip

00:06:32,910 --> 00:06:39,810
congestion memory control and everything

00:06:36,120 --> 00:06:42,270
else is just the same however we have

00:06:39,810 --> 00:06:45,450
these two additional bits to the skb

00:06:42,270 --> 00:06:47,550
that describe what was done to twitch

00:06:45,450 --> 00:06:52,440
packet and I'm going to touch about it a

00:06:47,550 --> 00:06:55,170
little bit more later on so about the

00:06:52,440 --> 00:06:57,090
data path we have a first path and we we

00:06:55,170 --> 00:06:59,970
have a slow path so the first path is

00:06:57,090 --> 00:07:01,680
that when everything has been processed

00:06:59,970 --> 00:07:05,250
all packets have been decrypted of which

00:07:01,680 --> 00:07:08,280
record and this code is it's running in

00:07:05,250 --> 00:07:09,780
KT less so it looks at the record that

00:07:08,280 --> 00:07:14,220
sees everything is decrypted it copies

00:07:09,780 --> 00:07:15,990
to user space and everything is good now

00:07:14,220 --> 00:07:17,700
for the for the slope of so the slope of

00:07:15,990 --> 00:07:21,030
is in two parts for the first part is

00:07:17,700 --> 00:07:21,900
what if sum of record is decrypted but

00:07:21,030 --> 00:07:25,350
not all of it

00:07:21,900 --> 00:07:28,380
so say offload was skip the packet for

00:07:25,350 --> 00:07:29,700
some reason or maybe it just stopped in

00:07:28,380 --> 00:07:32,940
the middle of a stream and from that

00:07:29,700 --> 00:07:34,980
moment onward nothing is a flowed so

00:07:32,940 --> 00:07:38,340
what we have here is for example as we

00:07:34,980 --> 00:07:40,590
show at the bottom that TLS record 2 is

00:07:38,340 --> 00:07:42,990
what we call partially decrypted or when

00:07:40,590 --> 00:07:45,090
one packet of these or some packets of

00:07:42,990 --> 00:07:47,610
this record but not all of them have

00:07:45,090 --> 00:07:49,470
been decrypted so we need to do what we

00:07:47,610 --> 00:07:51,630
call partial decryption and it's an

00:07:49,470 --> 00:07:54,150
algorithm that handles the situation and

00:07:51,630 --> 00:07:56,190
provides user space with the plaintext

00:07:54,150 --> 00:07:59,430
after authentication and we are going to

00:07:56,190 --> 00:08:03,840
touch on that in one of the following

00:07:59,430 --> 00:08:06,390
slides the other part of the slow path

00:08:03,840 --> 00:08:08,670
is what we call we synchronization when

00:08:06,390 --> 00:08:11,460
we get a TLS record that is

00:08:08,670 --> 00:08:13,470
fully ciphertext that is the entire

00:08:11,460 --> 00:08:16,530
record it hasn't been processed by

00:08:13,470 --> 00:08:19,890
hardware it means that hardware lost

00:08:16,530 --> 00:08:22,950
State and it cannot perform TLS offload

00:08:19,890 --> 00:08:25,440
anymore so it requires some additional

00:08:22,950 --> 00:08:28,290
information from software to be provided

00:08:25,440 --> 00:08:32,010
in order to to get it it's machine

00:08:28,290 --> 00:08:33,870
running again and for that we need the K

00:08:32,010 --> 00:08:36,630
TLS layer to call the driver with

00:08:33,870 --> 00:08:42,870
synchronization function to provide that

00:08:36,630 --> 00:08:45,140
metadata so going back to partial

00:08:42,870 --> 00:08:48,450
decryption how partial decryption works

00:08:45,140 --> 00:08:50,660
so here we present the partial

00:08:48,450 --> 00:08:53,970
decryption algorithm with a small

00:08:50,660 --> 00:08:56,490
asterisk up here that this algorithm is

00:08:53,970 --> 00:09:00,210
somewhat simplified to to help explain

00:08:56,490 --> 00:09:02,370
it better it does two passes on the data

00:09:00,210 --> 00:09:05,040
and an optimized algorithm could do it

00:09:02,370 --> 00:09:06,930
with a single pass and if anyone

00:09:05,040 --> 00:09:12,890
interested a I can talk about that later

00:09:06,930 --> 00:09:14,160
so how we do it is that we are going to

00:09:12,890 --> 00:09:17,130
re-encrypt

00:09:14,160 --> 00:09:19,470
the tailless record and then once we

00:09:17,130 --> 00:09:21,600
have the encrypted TLS record it's going

00:09:19,470 --> 00:09:25,500
to be decrypted and authenticate in

00:09:21,600 --> 00:09:28,020
software as we usually do so to Rhian

00:09:25,500 --> 00:09:29,400
crypt the TLS record we need to take

00:09:28,020 --> 00:09:30,930
this packet which was decrypted by

00:09:29,400 --> 00:09:33,360
hardware and reverse the operation and

00:09:30,930 --> 00:09:35,580
how it's done for instance for a s GCM

00:09:33,360 --> 00:09:38,640
which is a counter mode cipher is we are

00:09:35,580 --> 00:09:40,620
via KHOU with with the key stream so the

00:09:38,640 --> 00:09:42,870
key stream could be generated simply by

00:09:40,620 --> 00:09:45,090
encrypting zeros with the correct IV the

00:09:42,870 --> 00:09:47,340
IV is now it's plain text in the TLS

00:09:45,090 --> 00:09:50,160
record so we generate the key stream and

00:09:47,340 --> 00:09:52,530
then week so the decrypted back at the

00:09:50,160 --> 00:09:54,510
plant expect to obtain the decipher text

00:09:52,530 --> 00:09:56,070
so we saw the plaintext through the key

00:09:54,510 --> 00:09:58,470
stream we obtain the cipher text and we

00:09:56,070 --> 00:10:00,750
get a full ciphertext record which is

00:09:58,470 --> 00:10:02,340
decrypted and Infanta cated and the

00:10:00,750 --> 00:10:08,790
plaintext could be provided the user

00:10:02,340 --> 00:10:11,700
after indication so about

00:10:08,790 --> 00:10:14,370
resynchronization and after some packet

00:10:11,700 --> 00:10:17,130
is dropped some packets arrive out of

00:10:14,370 --> 00:10:20,160
order how do I loses the form state

00:10:17,130 --> 00:10:22,140
which is required to keep offloading TLS

00:10:20,160 --> 00:10:25,920
and we lose

00:10:22,140 --> 00:10:29,190
of TLS records inside the DCPS room the

00:10:25,920 --> 00:10:32,310
framing of TLS and we lose the TLS

00:10:29,190 --> 00:10:35,040
record sequence number for each frame so

00:10:32,310 --> 00:10:37,230
we need some assistance from software in

00:10:35,040 --> 00:10:39,120
diverse synchronization process catalyst

00:10:37,230 --> 00:10:41,490
require request the driver to

00:10:39,120 --> 00:10:43,980
synchronize for each record received

00:10:41,490 --> 00:10:47,280
which is still fully encrypted which

00:10:43,980 --> 00:10:48,900
hasn't been processed it provides the

00:10:47,280 --> 00:10:52,530
TCP sequence number of the track word

00:10:48,900 --> 00:10:54,960
and the TLS record sequence number and

00:10:52,530 --> 00:10:57,150
accordingly and driver attempts to

00:10:54,960 --> 00:10:58,230
secure as hardware and hopefully

00:10:57,150 --> 00:11:00,170
eventually it would be get

00:10:58,230 --> 00:11:02,520
resynchronized

00:11:00,170 --> 00:11:04,140
it's important to know that while

00:11:02,520 --> 00:11:06,420
hardware is out of sync it will not

00:11:04,140 --> 00:11:09,450
attempt to decrypt anything or to do any

00:11:06,420 --> 00:11:15,860
additional processing and until software

00:11:09,450 --> 00:11:18,590
confirms your synchronization okay so

00:11:15,860 --> 00:11:21,890
one of the challenges we have with

00:11:18,590 --> 00:11:24,950
initialization is that we have these

00:11:21,890 --> 00:11:27,900
sums in some sense it's race condition

00:11:24,950 --> 00:11:29,970
when we want to start offload we need to

00:11:27,900 --> 00:11:32,370
provide the most up-to-date state for

00:11:29,970 --> 00:11:33,810
the the tip of processing of data

00:11:32,370 --> 00:11:37,350
received by Nakuru

00:11:33,810 --> 00:11:40,410
so when the user says I want you to

00:11:37,350 --> 00:11:43,890
start offloading now it has seen the TCP

00:11:40,410 --> 00:11:47,220
byte stream up to some I don't know X

00:11:43,890 --> 00:11:50,070
bytes the TCP stacks seen looked a bit

00:11:47,220 --> 00:11:51,900
more it say it read Y bytes which is

00:11:50,070 --> 00:11:54,840
greater than X and the neck has seen

00:11:51,900 --> 00:11:58,260
even more it's seen Z bytes read and

00:11:54,840 --> 00:12:00,390
wine X so how do we need to get Z but

00:11:58,260 --> 00:12:04,700
software could provide it from user

00:12:00,390 --> 00:12:08,430
space only with the X a so we suggest to

00:12:04,700 --> 00:12:11,670
mitigations the force is when the user

00:12:08,430 --> 00:12:14,010
requests offload we could provide Y from

00:12:11,670 --> 00:12:17,880
the Katie Ellis layer just by walking

00:12:14,010 --> 00:12:20,310
the receive queue of TCP and scene where

00:12:17,880 --> 00:12:23,280
the records and providing the the newest

00:12:20,310 --> 00:12:25,740
one and the other is the recent flowing

00:12:23,280 --> 00:12:29,610
hardware where it needs to to help out

00:12:25,740 --> 00:12:35,400
in case we have said that it's greater

00:12:29,610 --> 00:12:38,790
than mine another challenge occurs in

00:12:35,400 --> 00:12:43,410
DLS cipher renegotiation so here we show

00:12:38,790 --> 00:12:45,210
the stages of the TLS handshake but I'm

00:12:43,410 --> 00:12:47,400
not going to walk through it what's

00:12:45,210 --> 00:12:51,540
important here is that there are two

00:12:47,400 --> 00:12:54,390
parts two essential parts a part where

00:12:51,540 --> 00:12:57,510
you use the old key and about we use the

00:12:54,390 --> 00:12:59,190
the new key so all the handshake of

00:12:57,510 --> 00:13:01,650
course using the old key at until a

00:12:59,190 --> 00:13:03,600
change side respect message is sent this

00:13:01,650 --> 00:13:06,510
message says that all following message

00:13:03,600 --> 00:13:08,550
will use the new key so here we show

00:13:06,510 --> 00:13:12,240
what's using the old keys and what's

00:13:08,550 --> 00:13:14,850
using the new keys in both sides in the

00:13:12,240 --> 00:13:20,130
client and the server in a full

00:13:14,850 --> 00:13:22,290
handshake of TLS so now that we know

00:13:20,130 --> 00:13:24,240
that everything after I change cypher

00:13:22,290 --> 00:13:25,770
spec is using the new keys what's the

00:13:24,240 --> 00:13:28,350
challenge so some all packets are

00:13:25,770 --> 00:13:31,560
received in order and we have a TLS

00:13:28,350 --> 00:13:34,529
renegotiation going on however hard way

00:13:31,560 --> 00:13:37,380
it didn't identify the change type

00:13:34,529 --> 00:13:42,600
respect message and now as a result it

00:13:37,380 --> 00:13:44,820
processed the packets of the encrypted

00:13:42,600 --> 00:13:46,350
using the new key using the Alt key and

00:13:44,820 --> 00:13:50,130
it got an error in application error

00:13:46,350 --> 00:13:52,680
since it's not the right key so how can

00:13:50,130 --> 00:13:54,510
we handle it what we suggest is that 1k

00:13:52,680 --> 00:13:57,270
TLS observes the change type respect

00:13:54,510 --> 00:14:00,180
message it would go it would stop Haru

00:13:57,270 --> 00:14:01,890
offload obviously since it's not helping

00:14:00,180 --> 00:14:04,020
and it will go over all packets received

00:14:01,890 --> 00:14:10,350
and we encrypt them since they won't

00:14:04,020 --> 00:14:12,570
decrypt it using the right key so here

00:14:10,350 --> 00:14:16,170
we we show an example of such a thing

00:14:12,570 --> 00:14:18,480
where a lock holds 1 & 2 encrypted using

00:14:16,170 --> 00:14:20,580
the Alt key and records free and for

00:14:18,480 --> 00:14:23,970
encrypted using the new key however

00:14:20,580 --> 00:14:26,220
Hardware decrypted these 3 packets 5 6 &

00:14:23,970 --> 00:14:31,070
7 using the old key which is wrong and

00:14:26,220 --> 00:14:31,070
it needs to be fixed somehow

00:14:31,250 --> 00:14:38,700
so to summarize we we had a few problems

00:14:35,490 --> 00:14:40,890
and we suggested some solutions so the

00:14:38,700 --> 00:14:43,020
first problem was that during

00:14:40,890 --> 00:14:46,230
initialization hardware already

00:14:43,020 --> 00:14:48,370
processed some TLS record that hasn't

00:14:46,230 --> 00:14:50,050
been seen by software

00:14:48,370 --> 00:14:52,899
and we solve it using resynchronization

00:14:50,050 --> 00:14:56,889
and some kernel assistance in processing

00:14:52,899 --> 00:15:02,170
TLS records the second problem was were

00:14:56,889 --> 00:15:04,480
doing normal data send some packet drop

00:15:02,170 --> 00:15:06,459
or we order occurred and hardware is out

00:15:04,480 --> 00:15:11,519
of sync so we solve it using the recent

00:15:06,459 --> 00:15:14,259
flow third when TLS who negotiates keys

00:15:11,519 --> 00:15:16,809
some data might be decrypted using the

00:15:14,259 --> 00:15:21,430
Alt key and we solve it using encryption

00:15:16,809 --> 00:15:24,069
indicate Els layer and finally if

00:15:21,430 --> 00:15:27,069
offload stops in the middle of record or

00:15:24,069 --> 00:15:28,480
skip some packets then we get partially

00:15:27,069 --> 00:15:30,639
decrypted records and we need to handle

00:15:28,480 --> 00:15:34,839
that and we have the partial decryption

00:15:30,639 --> 00:15:38,620
algorithm for that so some points for

00:15:34,839 --> 00:15:42,160
discussion we need to pass two bits of

00:15:38,620 --> 00:15:45,699
metadata in the skb first if any crypto

00:15:42,160 --> 00:15:51,970
was done and second if it was successful

00:15:45,699 --> 00:15:55,089
so this might not be trivial to adding

00:15:51,970 --> 00:15:57,040
bits of data to the skb another problem

00:15:55,089 --> 00:15:59,410
is that we need to prevent coalescing at

00:15:57,040 --> 00:16:02,980
all kinds of players between ciphertext

00:15:59,410 --> 00:16:04,990
and plaintext escapees for example tcp

00:16:02,980 --> 00:16:08,649
coli sergio must not call the ciphertext

00:16:04,990 --> 00:16:11,199
in plain text data and this leads us to

00:16:08,649 --> 00:16:12,819
the next challenge where the tcp out of

00:16:11,199 --> 00:16:14,679
order Q might get loaded with those

00:16:12,819 --> 00:16:19,899
plaintext ciphertext plaintext hypertext

00:16:14,679 --> 00:16:21,610
and SK B's and so we there are all kinds

00:16:19,899 --> 00:16:23,679
of solutions one is to encrypt

00:16:21,610 --> 00:16:27,699
everything one is to try to decrypt

00:16:23,679 --> 00:16:29,529
everything whenever possible to to merge

00:16:27,699 --> 00:16:33,730
those escapees whenever there's pressure

00:16:29,529 --> 00:16:36,249
and another point is what happens when

00:16:33,730 --> 00:16:38,350
we have crypto which was done however it

00:16:36,249 --> 00:16:40,600
wasn't successful assume you have one

00:16:38,350 --> 00:16:43,480
TCP packet with multiple TLS records

00:16:40,600 --> 00:16:45,879
inside and one of them had an error say

00:16:43,480 --> 00:16:47,769
the authentication failed or it's not

00:16:45,879 --> 00:16:52,360
even TLS till I stopped at some point

00:16:47,769 --> 00:16:55,569
and now you have TCP so what we suggest

00:16:52,360 --> 00:16:57,459
in such cases that Hardware viously it

00:16:55,569 --> 00:16:59,290
provides only those two bits of

00:16:57,459 --> 00:17:01,779
information that saying I I've processed

00:16:59,290 --> 00:17:02,200
it but at some error so Katie Ellis

00:17:01,779 --> 00:17:04,240
could

00:17:02,200 --> 00:17:05,770
the driver and the driver could reverse

00:17:04,240 --> 00:17:08,440
the operation and provide the original

00:17:05,770 --> 00:17:10,630
packet for such an occasion

00:17:08,440 --> 00:17:13,120
and finally TLS uses checksum

00:17:10,630 --> 00:17:16,360
unnecessary we must process TCP we must

00:17:13,120 --> 00:17:18,040
know how to CP it was correct we can't

00:17:16,360 --> 00:17:19,720
cross this package that had one checksum

00:17:18,040 --> 00:17:21,880
so if you already check the checksum and

00:17:19,720 --> 00:17:24,190
we've done everything checksum complete

00:17:21,880 --> 00:17:26,949
you might not be is meaningful

00:17:24,190 --> 00:17:28,780
moreover the TCP check sum that's been

00:17:26,949 --> 00:17:30,670
provided is provided over the cipher

00:17:28,780 --> 00:17:33,280
text and it has no cipher text it's only

00:17:30,670 --> 00:17:35,530
plaintext so what does this knife number

00:17:33,280 --> 00:17:39,570
mean when you provide checksum complete

00:17:35,530 --> 00:17:42,010
its it might be a little bit weird so

00:17:39,570 --> 00:17:53,380
any questions or comments I think that's

00:17:42,010 --> 00:17:55,830
the last slide I only worry about the

00:17:53,380 --> 00:17:59,110
lacquer checksum complete for optimizing

00:17:55,830 --> 00:18:00,840
tunnel encapsulation situations right

00:17:59,110 --> 00:18:03,430
because we have that optimization where

00:18:00,840 --> 00:18:05,470
you can use a zero checksum on the inner

00:18:03,430 --> 00:18:07,120
if you have a checksum complete on the I

00:18:05,470 --> 00:18:09,400
mean on the outer if you have a checksum

00:18:07,120 --> 00:18:10,690
complete on the inside so you might want

00:18:09,400 --> 00:18:13,630
to take this into consideration because

00:18:10,690 --> 00:18:16,270
Lodge logically the checksum you have it

00:18:13,630 --> 00:18:18,400
rightly but with for the data that's in

00:18:16,270 --> 00:18:19,660
the skb now it doesn't match up anymore

00:18:18,400 --> 00:18:22,330
so maybe there's some way we can

00:18:19,660 --> 00:18:26,170
represent that and still use the value

00:18:22,330 --> 00:18:28,420
somehow just a suggestion I need to

00:18:26,170 --> 00:18:30,520
think about it currently I don't know

00:18:28,420 --> 00:18:34,050
I'm not sure this is fine for now just

00:18:30,520 --> 00:18:34,050
thinking ahead ok

00:18:39,760 --> 00:18:53,830
I had noticed in reading the Kate TLS

00:18:49,720 --> 00:18:57,150
source that had no place do you call

00:18:53,830 --> 00:18:59,050
MEMS zero explicit on any secret keys

00:18:57,150 --> 00:19:01,540
wondering if this was a conscious

00:18:59,050 --> 00:19:04,090
decision that's a zero keys out and what

00:19:01,540 --> 00:19:05,890
the security reasoning is or it's just a

00:19:04,090 --> 00:19:09,340
simple oversight and if you'd accept

00:19:05,890 --> 00:19:11,740
hashes to add that or just what your

00:19:09,340 --> 00:19:13,900
mentality is on key zeroing well

00:19:11,740 --> 00:19:16,360
generally keys are always required to

00:19:13,900 --> 00:19:19,150
perform the encryption and decryption

00:19:16,360 --> 00:19:20,770
live currently in the upstream what

00:19:19,150 --> 00:19:24,060
you've probably seen is software K TLS

00:19:20,770 --> 00:19:26,290
where you must have keys all the time oh

00:19:24,060 --> 00:19:28,870
yeah I'm referring to this but what I

00:19:26,290 --> 00:19:32,980
mean is when you when you pass a key

00:19:28,870 --> 00:19:34,870
into the kernel usually it's important

00:19:32,980 --> 00:19:39,220
to then zero out the key when you're

00:19:34,870 --> 00:19:42,070
done using it the issue is that you're

00:19:39,220 --> 00:19:44,200
constantly using those keys in the

00:19:42,070 --> 00:19:46,330
kernel I mean at the end of the TLS

00:19:44,200 --> 00:19:47,950
session you're done using it and it's

00:19:46,330 --> 00:19:52,480
usually important to zero it out so that

00:19:47,950 --> 00:19:53,980
you have federal security CFC so send

00:19:52,480 --> 00:19:55,900
patches yeah if you don't zero it on

00:19:53,980 --> 00:20:00,300
destruction so make sense to zero it out

00:19:55,900 --> 00:20:00,300
sure all right awesome patches

00:20:21,639 --> 00:20:26,690
okay so the resync processing sounds

00:20:24,889 --> 00:20:28,639
kind of expensive in the case of packet

00:20:26,690 --> 00:20:30,610
loss have you measured it what rate of

00:20:28,639 --> 00:20:32,840
packet loss essentially this becomes

00:20:30,610 --> 00:20:35,450
perhaps more burdensome than simply

00:20:32,840 --> 00:20:37,519
doing it completely in software no we

00:20:35,450 --> 00:20:39,830
plan to do such measurements we actually

00:20:37,519 --> 00:20:42,590
blend an extensive paper on the subject

00:20:39,830 --> 00:20:45,440
an academic paper and we didn't tend to

00:20:42,590 --> 00:20:48,139
study those problems it really depends

00:20:45,440 --> 00:20:50,299
on how much we can optimize the software

00:20:48,139 --> 00:20:53,299
paths and how much do they cost compared

00:20:50,299 --> 00:20:55,639
to the half our offload paths so with

00:20:53,299 --> 00:20:59,299
one percent packet drops you would

00:20:55,639 --> 00:21:02,210
probably get 16 percent of about 16

00:20:59,299 --> 00:21:04,610
percent of TLS record that goes through

00:21:02,210 --> 00:21:06,080
the software path say you had only one

00:21:04,610 --> 00:21:10,220
packet drop and how to skipped and

00:21:06,080 --> 00:21:11,659
somehow keep offloading so it's going to

00:21:10,220 --> 00:21:13,909
be about that but then it depends how

00:21:11,659 --> 00:21:17,690
much these 16 percent is going to cost

00:21:13,909 --> 00:21:18,950
maybe it's already too much and it's not

00:21:17,690 --> 00:21:25,639
worth it we need to do those

00:21:18,950 --> 00:21:29,000
measurements differently just say I read

00:21:25,639 --> 00:21:31,429
comment so in Wireless when we do worse

00:21:29,000 --> 00:21:33,470
at the hands of like like ping pong I

00:21:31,429 --> 00:21:37,429
mean there's a lot of like out of

00:21:33,470 --> 00:21:38,990
sequence packets coming so it would be

00:21:37,429 --> 00:21:43,070
really good to actually see like you

00:21:38,990 --> 00:21:46,279
know the impact of the what is it you

00:21:43,070 --> 00:21:48,710
know the packet reordering rate on the

00:21:46,279 --> 00:21:52,220
performance of you know the hardware

00:21:48,710 --> 00:22:08,080
offload right so we need to do those

00:21:52,220 --> 00:22:15,009
measurements different yes okay let's

00:22:08,080 --> 00:22:15,009
give thanks

00:22:16,250 --> 00:22:20,390

YouTube URL: https://www.youtube.com/watch?v=ZsBrNsKrAag


