Title: XDP for the Rest of Us
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 1 - Nov 08 2017
Description: 
	Speaker: Andy Gospodarek, Jesper Dangaard Brouer
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?gospodarek-xdp-workshop
Captions: 
	00:00:02,020 --> 00:00:09,590
well welcome to our talk it's a it's a

00:00:06,709 --> 00:00:12,830
sequel yeah sequels are always better

00:00:09,590 --> 00:00:16,730
right isn't that the rule maybe only one

00:00:12,830 --> 00:00:19,340
all right so I'm Andy gasp adore ik

00:00:16,730 --> 00:00:23,110
Broadcom yeah I'm Jasper I'm with Red

00:00:19,340 --> 00:00:23,110
Hat obvious from Red Hat

00:00:23,230 --> 00:00:28,340
that's right so today we're gonna kind

00:00:25,490 --> 00:00:31,310
of continue our talk that we had earlier

00:00:28,340 --> 00:00:33,230
this year we talked about XDP and just

00:00:31,310 --> 00:00:36,829
talked about usability and how people

00:00:33,230 --> 00:00:37,880
can get involved that talk is still

00:00:36,829 --> 00:00:39,800
available we're not going to completely

00:00:37,880 --> 00:00:40,880
cover everything that we did there we're

00:00:39,800 --> 00:00:42,829
going to talk about some new things

00:00:40,880 --> 00:00:46,430
because people like new stuff and

00:00:42,829 --> 00:00:47,719
changes since then so like we said the

00:00:46,430 --> 00:00:50,570
motivation is the follow up from last

00:00:47,719 --> 00:00:52,250
time we did get a little bit less time

00:00:50,570 --> 00:00:53,690
this time so we'll write this on like

00:00:52,250 --> 00:00:56,030
the updates and we'll show you some new

00:00:53,690 --> 00:00:59,329
tools try to get everybody into the

00:00:56,030 --> 00:01:00,860
ecosystem alright yeah we're and we're

00:00:59,329 --> 00:01:01,690
still really motivate motivated to try

00:01:00,860 --> 00:01:05,960
to demystify

00:01:01,690 --> 00:01:07,790
XDP and II BPF by the way II BPF such a

00:01:05,960 --> 00:01:09,049
mouthful we're just gonna say BPF means

00:01:07,790 --> 00:01:10,790
the same thing

00:01:09,049 --> 00:01:13,490
but we want you to really understand how

00:01:10,790 --> 00:01:15,530
to consume and understand the technology

00:01:13,490 --> 00:01:18,530
because it is still at times a little

00:01:15,530 --> 00:01:21,350
confusing though you can't like click

00:01:18,530 --> 00:01:22,790
this right now there this is a link to

00:01:21,350 --> 00:01:27,170
our YouTube talk if you've got an hour

00:01:22,790 --> 00:01:28,549
and can't sleep it's great show it to

00:01:27,170 --> 00:01:31,630
your friends and family I'm sure we can

00:01:28,549 --> 00:01:34,159
get at least 200 views views on YouTube

00:01:31,630 --> 00:01:35,780
so so today what are we gonna learn

00:01:34,159 --> 00:01:37,340
let's let's talk about what yeah what

00:01:35,780 --> 00:01:39,020
you got present what you will get out of

00:01:37,340 --> 00:01:40,670
this this is sort of important for us

00:01:39,020 --> 00:01:44,049
that you actually get something out of

00:01:40,670 --> 00:01:45,950
this presentation so let's let's see

00:01:44,049 --> 00:01:47,960
alright so we kind of bring you up to

00:01:45,950 --> 00:01:50,060
date with what's happened in xtp since

00:01:47,960 --> 00:01:54,049
then highlight some of the recent

00:01:50,060 --> 00:01:55,820
changes yeah and we really want you to

00:01:54,049 --> 00:01:59,659
be like in the driver's seat for what we

00:01:55,820 --> 00:02:01,850
we perceive as like this new fast user

00:01:59,659 --> 00:02:03,710
programmable networking even Simon

00:02:01,850 --> 00:02:05,570
mentioned in his slide that we are like

00:02:03,710 --> 00:02:11,809
the cool kids on the block and after all

00:02:05,570 --> 00:02:13,249
filter matching things so and yeah we

00:02:11,809 --> 00:02:14,330
will teach you about some of the new

00:02:13,249 --> 00:02:16,850
tools

00:02:14,330 --> 00:02:18,500
and we'll see if we can you know talk

00:02:16,850 --> 00:02:20,930
about some new ideas for

00:02:18,500 --> 00:02:22,730
XDP and BPF use cases maybe go a little

00:02:20,930 --> 00:02:24,650
bit beyond some of the distributed

00:02:22,730 --> 00:02:27,080
denial-of-service stuff and load

00:02:24,650 --> 00:02:28,550
balanced or use cases it's not always

00:02:27,080 --> 00:02:31,880
that fun to just talk about how fast our

00:02:28,550 --> 00:02:34,220
application you drop packets people have

00:02:31,880 --> 00:02:35,930
kept claims that that do we're really

00:02:34,220 --> 00:02:37,430
good at dropping packets right we

00:02:35,930 --> 00:02:39,380
already know that but we actually want

00:02:37,430 --> 00:02:42,580
to go a little bit beyond some find some

00:02:39,380 --> 00:02:44,630
new use cases for this that's right so

00:02:42,580 --> 00:02:45,920
so what we're not going to learn we're

00:02:44,630 --> 00:02:48,410
not gonna talk about getting started

00:02:45,920 --> 00:02:49,880
with EBP F and xdp again that's covered

00:02:48,410 --> 00:02:51,860
in the talk we're not going to talk

00:02:49,880 --> 00:02:53,660
about the compiler tool chain that's

00:02:51,860 --> 00:02:55,970
there and it's great we're not going to

00:02:53,660 --> 00:02:57,050
talk about the the samples that are in

00:02:55,970 --> 00:02:59,090
the kernel tree right now and how

00:02:57,050 --> 00:03:02,350
they're split up how the object elf

00:02:59,090 --> 00:03:06,170
objects are split up or the loader or

00:03:02,350 --> 00:03:08,030
you know the right BPF syscalls yeah and

00:03:06,170 --> 00:03:10,160
then we have all this did like an t just

00:03:08,030 --> 00:03:11,600
covered like you have to that that we're

00:03:10,160 --> 00:03:12,830
not going to cover I grabbed the kernels

00:03:11,600 --> 00:03:15,050
are you have to use a side we have two

00:03:12,830 --> 00:03:16,970
maps going in here and have to be F by

00:03:15,050 --> 00:03:20,620
code we can modify the maps we have to

00:03:16,970 --> 00:03:22,670
Cisco land and the obvious told us this

00:03:20,620 --> 00:03:24,860
that's right we're not gonna cover any

00:03:22,670 --> 00:03:27,140
of this alright so watch that watch the

00:03:24,860 --> 00:03:29,720
video we have expanded before you can

00:03:27,140 --> 00:03:31,790
cuz right go watch anyway alright so

00:03:29,720 --> 00:03:36,950
here we are sort of the new era and user

00:03:31,790 --> 00:03:39,709
programmable networking yeah so we see

00:03:36,950 --> 00:03:42,080
this as a little layer in in the network

00:03:39,709 --> 00:03:45,410
stack this is basic for how we perceive

00:03:42,080 --> 00:03:49,430
a HTP so it's a programmable hook you

00:03:45,410 --> 00:03:51,380
can run before we allocate skb and we

00:03:49,430 --> 00:03:53,090
basically want you to use this new

00:03:51,380 --> 00:03:56,930
building block that we added for

00:03:53,090 --> 00:03:58,280
networking yeah it's really it operates

00:03:56,930 --> 00:04:02,209
it's the same layer as other bypass

00:03:58,280 --> 00:04:03,500
solutions like the DB DK in theory it

00:04:02,209 --> 00:04:04,790
operates it basically the same speed

00:04:03,500 --> 00:04:06,470
with the goal being that we have a low

00:04:04,790 --> 00:04:08,209
number of CPU instructions that operate

00:04:06,470 --> 00:04:09,530
on a per packet basis that's really the

00:04:08,209 --> 00:04:11,870
key to all this is minimizing the number

00:04:09,530 --> 00:04:14,570
of instructions that that are running on

00:04:11,870 --> 00:04:16,580
a per packet so we have raw access to

00:04:14,570 --> 00:04:18,049
the ethernet frame so it's before the sk

00:04:16,580 --> 00:04:19,609
buff exists so what we're saving is the

00:04:18,049 --> 00:04:22,970
allocation of the sk buff metadata

00:04:19,609 --> 00:04:24,650
essentially and it's this is in in the

00:04:22,970 --> 00:04:26,669
kernel tree right now it's been in the

00:04:24,650 --> 00:04:28,870
Linux kernel since for eight

00:04:26,669 --> 00:04:32,530
lots of hardware drivers have support

00:04:28,870 --> 00:04:33,310
for it now on the heels of the talk we

00:04:32,530 --> 00:04:37,620
had in April

00:04:33,310 --> 00:04:40,480
Dave proposed and Dave sent patches for

00:04:37,620 --> 00:04:42,580
now generic XDP so you don't have to

00:04:40,480 --> 00:04:43,750
have the full support in your driver for

00:04:42,580 --> 00:04:45,940
it if you want to write apps and test

00:04:43,750 --> 00:04:48,700
apps and that was in 412 filtra yeah so

00:04:45,940 --> 00:04:52,480
that's available now and the xdp

00:04:48,700 --> 00:04:55,389
programming language is EBP F it's upon

00:04:52,480 --> 00:04:58,000
to mention that EPP is bigger than right

00:04:55,389 --> 00:04:59,740
it's it's a complete like complete

00:04:58,000 --> 00:05:01,960
compiler tool chain which we're not

00:04:59,740 --> 00:05:05,800
going to talk about we promise that and

00:05:01,960 --> 00:05:09,610
but but XT piece just one hook that you

00:05:05,800 --> 00:05:11,650
use for for invoking EBP F and the real

00:05:09,610 --> 00:05:14,110
power actually come from if you actually

00:05:11,650 --> 00:05:16,169
combine many of these hooks in the

00:05:14,110 --> 00:05:18,940
kernel and you can do all kind of new

00:05:16,169 --> 00:05:20,260
interesting stuff and you always also

00:05:18,940 --> 00:05:22,870
have to wrap your head around that you

00:05:20,260 --> 00:05:24,970
can control this by maps and then your

00:05:22,870 --> 00:05:26,950
different programs can coordinate with

00:05:24,970 --> 00:05:33,850
each other truth is this this map this

00:05:26,950 --> 00:05:34,960
yet state so the combination we think

00:05:33,850 --> 00:05:38,620
the combination is really good because

00:05:34,960 --> 00:05:40,390
it's a combination of HTTP and + v PF

00:05:38,620 --> 00:05:44,110
that is that gives us this user

00:05:40,390 --> 00:05:45,700
programmable networking right the the

00:05:44,110 --> 00:05:47,860
some of the restrictions that EBP F

00:05:45,700 --> 00:05:49,690
places on you are really good I mean we

00:05:47,860 --> 00:05:50,830
could have just you know the kernel

00:05:49,690 --> 00:05:53,350
could have just created an area where

00:05:50,830 --> 00:05:54,580
you could plug in any random program you

00:05:53,350 --> 00:05:55,690
know and I mean we could have thought

00:05:54,580 --> 00:05:57,729
about creating a new kernel module

00:05:55,690 --> 00:06:00,460
infrastructure or some noted a new like

00:05:57,729 --> 00:06:02,500
standard C code in this hook but some

00:06:00,460 --> 00:06:05,650
visionary people figured out that it was

00:06:02,500 --> 00:06:07,210
better to we tries to Lotus BPF program

00:06:05,650 --> 00:06:10,479
there we get all the benefits of that

00:06:07,210 --> 00:06:14,220
and in it we can load this in a safe

00:06:10,479 --> 00:06:17,310
manner without having allowing to run

00:06:14,220 --> 00:06:19,210
direct C code and although all the

00:06:17,310 --> 00:06:21,700
programming errors that will crash the

00:06:19,210 --> 00:06:24,400
kernel there we don't have UPF in this

00:06:21,700 --> 00:06:27,430
hook which is provides security and

00:06:24,400 --> 00:06:29,560
sandboxing so the kernel is basically

00:06:27,430 --> 00:06:31,590
responsible just removing the package

00:06:29,560 --> 00:06:34,690
package passed this gave us this split

00:06:31,590 --> 00:06:36,849
now we have to prepare side it's maximum

00:06:34,690 --> 00:06:39,490
flexibility and maybe you want to talk

00:06:36,849 --> 00:06:40,180
about that yeah so so you end up with

00:06:39,490 --> 00:06:42,520
the ability

00:06:40,180 --> 00:06:43,690
to really do anything you want not

00:06:42,520 --> 00:06:45,639
anything you want but a lot of different

00:06:43,690 --> 00:06:47,229
things to packets as they come in and

00:06:45,639 --> 00:06:49,900
for example if administrators want to

00:06:47,229 --> 00:06:52,080
quickly make a change you don't have to

00:06:49,900 --> 00:06:54,310
upgrade a kernel you can do it quickly

00:06:52,080 --> 00:06:56,289
you can be I think we talked about like

00:06:54,310 --> 00:06:58,000
you could look you could for example if

00:06:56,289 --> 00:07:00,550
you get to peg aft if that's something

00:06:58,000 --> 00:07:01,990
to do with with with calling your

00:07:00,550 --> 00:07:03,699
network stack we could drop the packet

00:07:01,990 --> 00:07:06,460
in XTP because this before I locating

00:07:03,699 --> 00:07:08,800
the skp so we could drop security stop

00:07:06,460 --> 00:07:11,080
sequestration without upgrading the

00:07:08,800 --> 00:07:12,520
kernel right that's right and the great

00:07:11,080 --> 00:07:13,780
thing about this is you can only run if

00:07:12,520 --> 00:07:17,110
you want to you can just run the code

00:07:13,780 --> 00:07:19,150
you need for your specific use case so

00:07:17,110 --> 00:07:21,550
you're not accumulating a ton of a ton

00:07:19,150 --> 00:07:22,870
of bloat over time and and if you have a

00:07:21,550 --> 00:07:25,090
different if your use case changes you

00:07:22,870 --> 00:07:26,500
can quickly make a change the other

00:07:25,090 --> 00:07:28,660
great thing is this is in the kernel

00:07:26,500 --> 00:07:30,340
tree so it's maintained by the Linux

00:07:28,660 --> 00:07:33,610
kernel kernel community supported by the

00:07:30,340 --> 00:07:35,949
kernel community and like we said it

00:07:33,610 --> 00:07:38,080
swaps in and out very easily so you're

00:07:35,949 --> 00:07:40,479
not necessarily required to bring down

00:07:38,080 --> 00:07:42,580
your interface and restart your polling

00:07:40,479 --> 00:07:44,860
operations recompute everything it's

00:07:42,580 --> 00:07:46,539
just one atomic swap operation and your

00:07:44,860 --> 00:07:49,419
new program is up and running so that's

00:07:46,539 --> 00:07:52,030
a huge advantage from an uptime as as

00:07:49,419 --> 00:07:53,620
anybody that's worked on how devices

00:07:52,030 --> 00:07:55,630
connected to routers and switches before

00:07:53,620 --> 00:07:57,970
they they know that having having a port

00:07:55,630 --> 00:08:00,610
flap is something that you know makes

00:07:57,970 --> 00:08:02,470
the folks in your NOC get a page or you

00:08:00,610 --> 00:08:04,090
know you don't like some sort of message

00:08:02,470 --> 00:08:06,699
that no one likes to hear about so

00:08:04,090 --> 00:08:13,570
things like that make make xdp pretty

00:08:06,699 --> 00:08:15,970
awesome yeah so so if for for people

00:08:13,570 --> 00:08:19,750
that we have this sort of summary slide

00:08:15,970 --> 00:08:22,210
here what HTTP can do for you and and so

00:08:19,750 --> 00:08:24,789
I guess some people know it already but

00:08:22,210 --> 00:08:26,500
let's go or what what what what the kind

00:08:24,789 --> 00:08:30,699
of facilities that we are providing for

00:08:26,500 --> 00:08:34,419
you to to sew manipulates these these of

00:08:30,699 --> 00:08:36,190
these packets so HDPE can can read and

00:08:34,419 --> 00:08:38,919
modify the packet content it's quite

00:08:36,190 --> 00:08:41,620
quite strong powerful feature you could

00:08:38,919 --> 00:08:44,500
modify it we can push and pull hitters

00:08:41,620 --> 00:08:46,270
off that there's also very powerful

00:08:44,500 --> 00:08:48,550
powerful feature yeah I mean it's it

00:08:46,270 --> 00:08:50,800
sounds very basic but the great

00:08:48,550 --> 00:08:52,900
advantages for a variety of reasons if

00:08:50,800 --> 00:08:53,889
you wanted to for example if you had a

00:08:52,900 --> 00:08:56,019
new protocol coming in

00:08:53,889 --> 00:08:57,309
that was not necessarily supported by

00:08:56,019 --> 00:08:58,629
the linux kernel but you knew you could

00:08:57,309 --> 00:09:00,819
handle it you could pop that header off

00:08:58,629 --> 00:09:02,410
if you wanted to add a VLAN tag you

00:09:00,819 --> 00:09:05,079
could do that remove a VLAN tag you

00:09:02,410 --> 00:09:07,869
could do that a variety of different

00:09:05,079 --> 00:09:09,699
things that that that the more you think

00:09:07,869 --> 00:09:11,109
about the fact that this infrastructure

00:09:09,699 --> 00:09:14,199
is there the more ideas you come up with

00:09:11,109 --> 00:09:16,059
that are that are usable on top of that

00:09:14,199 --> 00:09:17,470
the primary interface is you have a

00:09:16,059 --> 00:09:20,799
program that we've said that connects

00:09:17,470 --> 00:09:22,480
and xdp has five different action codes

00:09:20,799 --> 00:09:23,769
that are returned yeah and if the famous

00:09:22,480 --> 00:09:26,919
one is drop right we have four days

00:09:23,769 --> 00:09:29,079
right so fast - protection feature which

00:09:26,919 --> 00:09:33,249
face off Facebook have have deployed and

00:09:29,079 --> 00:09:35,589
others are also looking at and then

00:09:33,249 --> 00:09:37,929
didn't and we have to pass it's it's

00:09:35,589 --> 00:09:40,119
people like the past operations just

00:09:37,929 --> 00:09:41,679
passing this this - the key to the

00:09:40,119 --> 00:09:43,359
normal criminal stack but it's quite

00:09:41,679 --> 00:09:45,669
important to understand that we actually

00:09:43,359 --> 00:09:47,319
have a powerful feature here because we

00:09:45,669 --> 00:09:48,790
could push push up pull headers and we

00:09:47,319 --> 00:09:50,529
can actually modify the packet before it

00:09:48,790 --> 00:09:55,649
was just a network stack that means we

00:09:50,529 --> 00:09:57,549
could actually change the flow from from

00:09:55,649 --> 00:09:59,230
controlling something right yeah and

00:09:57,549 --> 00:10:01,419
built-in by default with with this

00:09:59,230 --> 00:10:03,279
solution xtp pass means that you're not

00:10:01,419 --> 00:10:05,799
separated from the rest of the kernel

00:10:03,279 --> 00:10:09,009
stack I mean this is in-line operating

00:10:05,799 --> 00:10:12,279
there I mean other you know high speed

00:10:09,009 --> 00:10:14,169
data plane development kits you know

00:10:12,279 --> 00:10:16,839
aren't necessarily always connected to

00:10:14,169 --> 00:10:18,879
the kernel some of the advantages some

00:10:16,839 --> 00:10:20,709
of these idea came out that CloudFlare

00:10:18,879 --> 00:10:22,569
told me they had a bypass solution that

00:10:20,709 --> 00:10:24,339
they they needed to reject packets into

00:10:22,569 --> 00:10:26,019
the kernel I was like why do you have to

00:10:24,339 --> 00:10:27,699
reject it why don't you fill it in line

00:10:26,019 --> 00:10:29,589
and that was one of the reasons we

00:10:27,699 --> 00:10:31,929
created this infrastructure that's right

00:10:29,589 --> 00:10:34,299
and now they have talked heavily about

00:10:31,929 --> 00:10:37,509
usage of of xdp at this point they're

00:10:34,299 --> 00:10:39,789
they're in the fold all right so the

00:10:37,509 --> 00:10:41,199
other option is X DB T X which allows

00:10:39,789 --> 00:10:43,059
you to like we said we've already talked

00:10:41,199 --> 00:10:45,549
about modify push and pull headers make

00:10:43,059 --> 00:10:48,160
changes swap MAC addresses but you can

00:10:45,549 --> 00:10:51,249
send packets out the same interface drop

00:10:48,160 --> 00:10:52,839
pass TX and aborted these first floor

00:10:51,249 --> 00:10:54,789
operations with the main the main ones

00:10:52,839 --> 00:10:56,980
created when it was added to the kernel

00:10:54,789 --> 00:10:58,359
tree to start with one might wonder why

00:10:56,980 --> 00:11:00,579
would you want to just transmit it out

00:10:58,359 --> 00:11:02,350
but there is definitely the load balance

00:11:00,579 --> 00:11:04,119
use case or plenty of other use cases

00:11:02,350 --> 00:11:06,369
where you have other opportunities that

00:11:04,119 --> 00:11:07,240
your hardware's this one is to also use

00:11:06,369 --> 00:11:09,149
bye-bye

00:11:07,240 --> 00:11:11,980
book for the load balancer that's right

00:11:09,149 --> 00:11:13,870
so they were the primary motivation they

00:11:11,980 --> 00:11:17,800
wanted this in before we got the

00:11:13,870 --> 00:11:20,529
redirect so yeah then we have aborted

00:11:17,800 --> 00:11:22,270
which really is essentially the same as

00:11:20,529 --> 00:11:23,620
drop that'll be the action that happens

00:11:22,270 --> 00:11:25,930
your packets dropped but it gives you

00:11:23,620 --> 00:11:27,760
this great opportunity to catch this

00:11:25,930 --> 00:11:28,959
condition and modify it we actually have

00:11:27,760 --> 00:11:32,500
an example later we talked a little bit

00:11:28,959 --> 00:11:34,390
about the the power of abort so yeah so

00:11:32,500 --> 00:11:36,390
so the idea we deport that in your

00:11:34,390 --> 00:11:38,470
programming you could say of this this

00:11:36,390 --> 00:11:41,020
situation should not happen I want to

00:11:38,470 --> 00:11:43,240
drop the packet but I'm calling to port

00:11:41,020 --> 00:11:45,490
instead because that allows me later to

00:11:43,240 --> 00:11:48,010
attest a trace point to see and debug my

00:11:45,490 --> 00:11:50,910
program if any any packets hit this this

00:11:48,010 --> 00:11:53,649
code path so I can I can catch that and

00:11:50,910 --> 00:11:56,200
then we have the new kid on the block

00:11:53,649 --> 00:11:59,680
since last the redirect waken transmits

00:11:56,200 --> 00:12:00,850
austere packets out another NIC but a

00:11:59,680 --> 00:12:02,170
really powerful thing we're going to

00:12:00,850 --> 00:12:05,680
talk about is that week you can do

00:12:02,170 --> 00:12:07,420
steering by maps and I think will save a

00:12:05,680 --> 00:12:10,450
little bit for the latest lines Ceaser

00:12:07,420 --> 00:12:12,910
it's a teaser for later attention all

00:12:10,450 --> 00:12:16,959
right and all BPF programs as we

00:12:12,910 --> 00:12:18,970
mentioned interact or interact via

00:12:16,959 --> 00:12:20,470
helper functions they can look up and

00:12:18,970 --> 00:12:21,610
modify kernel state and again this is

00:12:20,470 --> 00:12:22,839
kind of a tightly constrained and

00:12:21,610 --> 00:12:25,089
controlled environment you can't just

00:12:22,839 --> 00:12:26,860
call any kernel function you want and

00:12:25,089 --> 00:12:30,940
that's you know in a lot of ways a good

00:12:26,860 --> 00:12:32,860
thing and also there are shared maps

00:12:30,940 --> 00:12:35,950
user space with other BPF programs can

00:12:32,860 --> 00:12:37,300
use the track state and and this is this

00:12:35,950 --> 00:12:39,399
is the as we mentioned the primary

00:12:37,300 --> 00:12:41,140
communication mechanism so the BPF

00:12:39,399 --> 00:12:42,990
program comes up it has maps that it's

00:12:41,140 --> 00:12:44,950
gonna look at that contain that are

00:12:42,990 --> 00:12:46,209
we're not gonna go into all the details

00:12:44,950 --> 00:12:47,649
of the types of maps we covered that in

00:12:46,209 --> 00:12:49,540
the last have to change your program

00:12:47,649 --> 00:12:51,430
model a little bit but use yeah it's a

00:12:49,540 --> 00:12:53,980
little bit of a shift but it works

00:12:51,430 --> 00:12:59,680
really well and it's a safe way to

00:12:53,980 --> 00:13:01,060
interact yeah so so we want such a

00:12:59,680 --> 00:13:03,339
scientist to cooperate didn't normally

00:13:01,060 --> 00:13:04,570
to expect like I think maybe yeah I mean

00:13:03,339 --> 00:13:05,829
we sort of covered this it should be

00:13:04,570 --> 00:13:07,660
pretty obvious at this point that this

00:13:05,829 --> 00:13:10,870
is not a bypass solution this is an

00:13:07,660 --> 00:13:12,190
in-line work with the kernel stack so we

00:13:10,870 --> 00:13:14,680
can teach the kernel things it doesn't

00:13:12,190 --> 00:13:16,300
know yet make new changes without

00:13:14,680 --> 00:13:17,860
upgrading the kernel we've talked to

00:13:16,300 --> 00:13:20,890
plenty of people who talked about the be

00:13:17,860 --> 00:13:21,250
PF @ x DP use cases we're not needing to

00:13:20,890 --> 00:13:22,720
update

00:13:21,250 --> 00:13:27,640
the kernel or reboot the box is

00:13:22,720 --> 00:13:30,370
extremely important so on the receive

00:13:27,640 --> 00:13:32,500
side we're capable of it we talked about

00:13:30,370 --> 00:13:34,510
justing packet headers maybe we could

00:13:32,500 --> 00:13:36,520
steer to a VLAN device steer somewhere

00:13:34,510 --> 00:13:39,190
else we also now there's a new feature

00:13:36,520 --> 00:13:41,260
it was just added to add some metadata

00:13:39,190 --> 00:13:43,420
into into the buffer that we pass around

00:13:41,260 --> 00:13:47,290
and maybe that could be used a little

00:13:43,420 --> 00:13:49,650
bit later by other programs as there are

00:13:47,290 --> 00:13:52,660
some use cases for it right now yeah

00:13:49,650 --> 00:13:54,400
yeah and I'm when you just want to

00:13:52,660 --> 00:13:55,900
transmit the packet back so well I can

00:13:54,400 --> 00:13:58,000
receive we adjusted the packet headers

00:13:55,900 --> 00:13:59,410
they could be like some kind of new

00:13:58,000 --> 00:14:01,630
encapsulation that the kernel doesn't

00:13:59,410 --> 00:14:04,240
know about we can cut that off and put

00:14:01,630 --> 00:14:07,420
it into a poisoned by VLAN and transmit

00:14:04,240 --> 00:14:09,820
side we could add another BPF program to

00:14:07,420 --> 00:14:12,450
to to Rhian capture and put this back on

00:14:09,820 --> 00:14:15,310
on the on the ASX be in this case and

00:14:12,450 --> 00:14:16,750
and when we're transmitting it out and

00:14:15,310 --> 00:14:18,190
that many there's actually many options

00:14:16,750 --> 00:14:20,710
you acted like you can hook into traffic

00:14:18,190 --> 00:14:22,360
control to socket filter and you can

00:14:20,710 --> 00:14:24,430
restore based on information from the

00:14:22,360 --> 00:14:26,320
map or the VLAN device so that's there's

00:14:24,430 --> 00:14:28,510
a lot of flexibility in this programming

00:14:26,320 --> 00:14:30,850
model of insect in with the network

00:14:28,510 --> 00:14:32,950
stack that most people don't realize I

00:14:30,850 --> 00:14:34,720
think that's what we're trying to yeah

00:14:32,950 --> 00:14:36,280
and so it is you know in this case

00:14:34,720 --> 00:14:37,210
you're writing separate programs for

00:14:36,280 --> 00:14:38,440
example you're gonna have one that's

00:14:37,210 --> 00:14:39,640
gonna handle rx and one that's gonna

00:14:38,440 --> 00:14:40,630
handle TX which is a little bit

00:14:39,640 --> 00:14:44,500
different than if you're familiar with

00:14:40,630 --> 00:14:46,330
other other existing technical power

00:14:44,500 --> 00:14:51,010
come from combining more of these hooks

00:14:46,330 --> 00:14:53,050
- that's right alright so where do we

00:14:51,010 --> 00:14:54,310
start how would you get going if you

00:14:53,050 --> 00:14:56,560
want to actually get involved in the xdp

00:14:54,310 --> 00:14:57,670
ecosystem all right so we're not gonna

00:14:56,560 --> 00:14:58,630
talk about all these mailing lists but

00:14:57,670 --> 00:15:00,010
here they are it's a great reference

00:14:58,630 --> 00:15:02,020
slide we're sure these slides will

00:15:00,010 --> 00:15:03,520
appear online later yeah in fact there's

00:15:02,020 --> 00:15:05,230
a question if someone posted to xdp

00:15:03,520 --> 00:15:06,400
newbies this morning you want to get

00:15:05,230 --> 00:15:09,420
involved and answer the question pretty

00:15:06,400 --> 00:15:11,920
quick come on shoot answer it maybe yeah

00:15:09,420 --> 00:15:14,380
anyone if not someone to get to it later

00:15:11,920 --> 00:15:14,890
we've also got great documentation yes

00:15:14,380 --> 00:15:17,410
pers

00:15:14,890 --> 00:15:19,750
Ben I would say I'm going to update it

00:15:17,410 --> 00:15:23,190
it's going to be ok ok just

00:15:19,750 --> 00:15:25,780
documentation then we'll remove the

00:15:23,190 --> 00:15:27,310
great essence into the kernel doc but

00:15:25,780 --> 00:15:29,980
Daniel actually wrote a pretty good

00:15:27,310 --> 00:15:32,480
guide which is published under under the

00:15:29,980 --> 00:15:35,430
cilium website

00:15:32,480 --> 00:15:37,530
absolutely all right so recent changes

00:15:35,430 --> 00:15:39,690
of interest since since April there's

00:15:37,530 --> 00:15:40,710
actually been quite a bit going on so

00:15:39,690 --> 00:15:42,150
we're gonna talk about sort of a

00:15:40,710 --> 00:15:45,780
constrained subset of those changes a

00:15:42,150 --> 00:15:49,020
small set you're mostly going to cover

00:15:45,780 --> 00:15:50,400
like introspection which is or something

00:15:49,020 --> 00:15:53,460
that people brought up and we have

00:15:50,400 --> 00:15:55,080
addressed yeah for a long time I think

00:15:53,460 --> 00:15:57,180
the the samples that exist in the kernel

00:15:55,080 --> 00:15:59,670
tree right now seem a little bit like

00:15:57,180 --> 00:16:01,020
magical it's not really clear how you

00:15:59,670 --> 00:16:03,240
might expand on those to write your own

00:16:01,020 --> 00:16:05,310
program you can run them it's pretty

00:16:03,240 --> 00:16:07,140
easy to run but they're not super

00:16:05,310 --> 00:16:09,300
functional so I just wanted to know

00:16:07,140 --> 00:16:11,580
what's running on my system right how do

00:16:09,300 --> 00:16:13,200
we know you know what if you you were

00:16:11,580 --> 00:16:14,430
running it it's an interactive app and

00:16:13,200 --> 00:16:19,500
then you change to know the window

00:16:14,430 --> 00:16:20,670
things like that so so martin and jakob

00:16:19,500 --> 00:16:26,640
changes are highlighted here pretty

00:16:20,670 --> 00:16:29,460
heavily so we've got as of right now 413

00:16:26,640 --> 00:16:30,510
BPF IDs for loaded programs and maps are

00:16:29,460 --> 00:16:33,390
available this gives us some

00:16:30,510 --> 00:16:34,740
introspection you can dump those from

00:16:33,390 --> 00:16:37,770
user space you can take a look at them

00:16:34,740 --> 00:16:39,870
the great thing is this was BPF tool was

00:16:37,770 --> 00:16:41,070
created and it's now part of the kernel

00:16:39,870 --> 00:16:44,400
tree as well I think as of like

00:16:41,070 --> 00:16:46,410
basically a month or so ago and you can

00:16:44,400 --> 00:16:47,580
start to inspect these objects so if you

00:16:46,410 --> 00:16:49,440
want to we'll have an example in a

00:16:47,580 --> 00:16:51,900
little bit but it's easy to list

00:16:49,440 --> 00:16:53,640
programs that are loaded XDP programs or

00:16:51,900 --> 00:16:55,590
BPF programs yeah and you might actually

00:16:53,640 --> 00:16:56,910
actually get like a little surprise when

00:16:55,590 --> 00:17:00,090
you when you do that actually because

00:16:56,910 --> 00:17:02,490
today OpenSSH and even if you're using

00:17:00,090 --> 00:17:04,860
taka are loading PPF programs you just

00:17:02,490 --> 00:17:07,070
don't know it but actually getting

00:17:04,860 --> 00:17:11,430
getting used in your life that's right

00:17:07,070 --> 00:17:13,709
and then then we have HTTP monitor which

00:17:11,430 --> 00:17:15,720
is based on just using trace plants it's

00:17:13,709 --> 00:17:19,170
not using HTTP self it's just monitoring

00:17:15,720 --> 00:17:21,150
or HTTP is doing so it's sort of a tool

00:17:19,170 --> 00:17:25,709
to help deepak what's going on and we

00:17:21,150 --> 00:17:28,050
have an example later okay so here's the

00:17:25,709 --> 00:17:31,280
first personal example IP link IP route

00:17:28,050 --> 00:17:35,280
2 also had some changes so we know we're

00:17:31,280 --> 00:17:37,200
right there with the HTTP that we can

00:17:35,280 --> 00:17:40,470
see that but now we also get out output

00:17:37,200 --> 00:17:43,590
with the ID number and what what cam

00:17:40,470 --> 00:17:45,660
uses ID number for what what can we use

00:17:43,590 --> 00:17:51,840
ID number for sound and oh yeah then I

00:17:45,660 --> 00:17:53,160
slide it's no real get back to the sorry

00:17:51,840 --> 00:17:55,380
we'll get back yeah sorry pay attention

00:17:53,160 --> 00:17:57,150
to the the highlighting was added by us

00:17:55,380 --> 00:17:59,070
so pay attention to that for in the

00:17:57,150 --> 00:18:01,410
program ID and the fact that the XTP is

00:17:59,070 --> 00:18:02,940
there but yeah we're gonna when you use

00:18:01,410 --> 00:18:05,700
this to inspect a little bit in a few

00:18:02,940 --> 00:18:07,470
minutes so BPF tool didn't really need

00:18:05,700 --> 00:18:08,850
to make this like a display of the man

00:18:07,470 --> 00:18:10,800
page or anything but we figured would

00:18:08,850 --> 00:18:12,390
just quickly show that the main

00:18:10,800 --> 00:18:15,360
operations are program operations and

00:18:12,390 --> 00:18:18,150
map operations yeah oh yes we want to

00:18:15,360 --> 00:18:21,830
say so to us that up the two main

00:18:18,150 --> 00:18:25,470
objects are map and program that's right

00:18:21,830 --> 00:18:29,460
so that you can perform all these

00:18:25,470 --> 00:18:31,140
operations on maps we'll take a look at

00:18:29,460 --> 00:18:32,940
an use case for what in a minute and

00:18:31,140 --> 00:18:38,250
then you can identify these maps in in

00:18:32,940 --> 00:18:39,660
various ways this tool is great you can

00:18:38,250 --> 00:18:43,560
also look at the programs that are

00:18:39,660 --> 00:18:45,990
running you can look at fit just various

00:18:43,560 --> 00:18:47,520
data that we've currently implemented we

00:18:45,990 --> 00:18:49,650
the kernel community and and that this

00:18:47,520 --> 00:18:51,870
tool is able to read yeah you can dump

00:18:49,650 --> 00:18:53,340
dump to like yeah right you can dump the

00:18:51,870 --> 00:18:55,050
program code which is a request from a

00:18:53,340 --> 00:18:56,580
long time ago like how do I see what's

00:18:55,050 --> 00:18:59,150
running how do I know what this what

00:18:56,580 --> 00:18:59,150
this code looks like

00:19:00,290 --> 00:19:05,160
alright so tie this back in to what we

00:19:02,940 --> 00:19:07,050
did before this is a program that was

00:19:05,160 --> 00:19:09,420
written essentially for the the

00:19:07,050 --> 00:19:13,350
discussion or the presentation in April

00:19:09,420 --> 00:19:16,140
this is a blacklist program that it's

00:19:13,350 --> 00:19:17,550
sort of a task for you right so I wrote

00:19:16,140 --> 00:19:20,370
this program you don't know what's going

00:19:17,550 --> 00:19:22,230
on and you can see I've loaded several

00:19:20,370 --> 00:19:25,580
maps here and we've highlighted some

00:19:22,230 --> 00:19:27,690
information right here that I'm asked

00:19:25,580 --> 00:19:29,760
anti-and to figure out if you can

00:19:27,690 --> 00:19:31,530
extract back right that's right okay so

00:19:29,760 --> 00:19:33,150
we know that that these maps are here

00:19:31,530 --> 00:19:34,710
which means there's a they're actually

00:19:33,150 --> 00:19:36,240
pin two files which means we also know

00:19:34,710 --> 00:19:37,830
there are file descriptors associated

00:19:36,240 --> 00:19:40,320
with these and we add it to the

00:19:37,830 --> 00:19:44,760
blacklist this IP address at some point

00:19:40,320 --> 00:19:46,710
both of these so so now we can run BPF

00:19:44,760 --> 00:19:49,680
program show and see what we have so we

00:19:46,710 --> 00:19:50,910
now see that we've got this one program

00:19:49,680 --> 00:19:53,640
running I don't know if you remember

00:19:50,910 --> 00:19:56,840
before from a few slides earlier it's

00:19:53,640 --> 00:19:58,980
now green and this tag is a hash

00:19:56,840 --> 00:19:59,460
computed by the kernel so that gives us

00:19:58,980 --> 00:20:02,070
a unique

00:19:59,460 --> 00:20:03,899
identify for our program we know when it

00:20:02,070 --> 00:20:07,200
was loaded we know the user to loaded it

00:20:03,899 --> 00:20:09,809
we know the sizes and we know that these

00:20:07,200 --> 00:20:12,539
are the five IDs that are associated

00:20:09,809 --> 00:20:14,399
with the BPF maps so now I say great

00:20:12,539 --> 00:20:16,649
show me all the BPF maps that are that

00:20:14,399 --> 00:20:18,210
exist on this on this one and here we go

00:20:16,649 --> 00:20:20,279
unsurprisingly five six seven eight nine

00:20:18,210 --> 00:20:21,960
correspond to these numbers here and

00:20:20,279 --> 00:20:24,600
we've got these different we can see

00:20:21,960 --> 00:20:26,549
there's a hash and four arrays how many

00:20:24,600 --> 00:20:29,220
entries am you see how made much memory

00:20:26,549 --> 00:20:31,080
right we can see the memory usage how

00:20:29,220 --> 00:20:33,480
many maximum number of entries and we

00:20:31,080 --> 00:20:36,000
have to just be cached to make if you're

00:20:33,480 --> 00:20:37,529
matching against the IP IP we want to

00:20:36,000 --> 00:20:39,630
block because this was the denial of

00:20:37,529 --> 00:20:44,370
service protection program that just

00:20:39,630 --> 00:20:45,870
filters a lot of IP addresses that's

00:20:44,370 --> 00:20:49,529
right so so now we're gonna take a look

00:20:45,870 --> 00:20:51,990
at the map 5 to see if we can see what's

00:20:49,529 --> 00:20:55,260
in there and understand if the the value

00:20:51,990 --> 00:20:57,840
we thought was there is there and we see

00:20:55,260 --> 00:21:00,000
that the only element in this map

00:20:57,840 --> 00:21:03,630
happens to be happens to have this key

00:21:00,000 --> 00:21:06,330
see 6 12 30 203 which boy that sounds

00:21:03,630 --> 00:21:08,250
really familiar this is supposed to be

00:21:06,330 --> 00:21:09,840
you map so that's why I did CPU shows up

00:21:08,250 --> 00:21:12,179
correct this is an eight-core system and

00:21:09,840 --> 00:21:13,710
this is technically a counter so if this

00:21:12,179 --> 00:21:15,480
program were running and we were getting

00:21:13,710 --> 00:21:19,080
a lot of traffic destined for IP address

00:21:15,480 --> 00:21:21,179
198 1853 what we would see is every time

00:21:19,080 --> 00:21:23,100
a core that was processing this frame

00:21:21,179 --> 00:21:24,929
received a frame with this IP address

00:21:23,100 --> 00:21:27,149
we'd see this value increment in this

00:21:24,929 --> 00:21:30,210
counter so this is nice

00:21:27,149 --> 00:21:31,770
if we didn't have this year we'd have to

00:21:30,210 --> 00:21:33,899
run some other program or this is a

00:21:31,770 --> 00:21:34,919
great way to see hey is my program

00:21:33,899 --> 00:21:36,240
that's supposed to read this map

00:21:34,919 --> 00:21:38,039
actually outputting the correct data

00:21:36,240 --> 00:21:39,630
previous to this there wasn't really a

00:21:38,039 --> 00:21:43,289
great option to do that you're just sort

00:21:39,630 --> 00:21:47,399
of hoping and that's not always a great

00:21:43,289 --> 00:21:49,200
strategy also we could take the same map

00:21:47,399 --> 00:21:52,260
you can dump it now with JSON support

00:21:49,200 --> 00:21:53,220
thanks to Quentin for that and if you're

00:21:52,260 --> 00:21:55,529
not sure if that's quite readable

00:21:53,220 --> 00:21:57,480
there's even a pretty output makes it

00:21:55,529 --> 00:21:58,649
much better so this this makes it so you

00:21:57,480 --> 00:21:59,940
can use this as a front-end for a

00:21:58,649 --> 00:22:02,850
programming interface rather than having

00:21:59,940 --> 00:22:04,529
to constantly and and now we have to

00:22:02,850 --> 00:22:06,149
keep it's a little bit funny that we

00:22:04,529 --> 00:22:08,220
have to keep spit out in this way but

00:22:06,149 --> 00:22:09,840
it's makes it it works and it's pretty

00:22:08,220 --> 00:22:12,210
common everything's sort of split up

00:22:09,840 --> 00:22:13,230
into chunks of that size with this tool

00:22:12,210 --> 00:22:15,090
so it takes a little bit of

00:22:13,230 --> 00:22:16,919
of getting used to but it's way better

00:22:15,090 --> 00:22:19,049
than we had in the past so this is

00:22:16,919 --> 00:22:20,309
awesome the JSON output is also cool

00:22:19,049 --> 00:22:22,500
because it gives us the opportunity to

00:22:20,309 --> 00:22:23,760
change this output pretty easily we feel

00:22:22,500 --> 00:22:25,830
pretty confident if you want a program I

00:22:23,760 --> 00:22:27,450
get you know we write programs to read

00:22:25,830 --> 00:22:28,790
the output you just use JSON and you're

00:22:27,450 --> 00:22:31,500
done

00:22:28,790 --> 00:22:33,270
so then kind of an example I went and

00:22:31,500 --> 00:22:35,070
loaded crazy I know

00:22:33,270 --> 00:22:38,490
another XDP program on another interface

00:22:35,070 --> 00:22:41,160
and so now the highlighted in yellow

00:22:38,490 --> 00:22:43,470
showed up so we've got you know a new

00:22:41,160 --> 00:22:45,120
program an idea of eight obviously a new

00:22:43,470 --> 00:22:47,270
tag that was computed we know it was

00:22:45,120 --> 00:22:50,419
loaded just a little bit later or

00:22:47,270 --> 00:22:53,280
exactly eight hours later apparently and

00:22:50,419 --> 00:22:55,950
we now know that there's a map IDs 14

00:22:53,280 --> 00:22:57,510
associated with one one map ID 14

00:22:55,950 --> 00:23:00,179
associated with it so I want to check

00:22:57,510 --> 00:23:01,890
that out and oh by the way you if you

00:23:00,179 --> 00:23:05,580
you recognize this you might realize

00:23:01,890 --> 00:23:08,190
this is this should be XD p2 that was

00:23:05,580 --> 00:23:10,080
run from the kernel source tree and and

00:23:08,190 --> 00:23:11,970
so now we can see into newer kernels it

00:23:10,080 --> 00:23:13,590
has this right to get the name out of

00:23:11,970 --> 00:23:17,520
yeah how cool is that so that's actually

00:23:13,590 --> 00:23:19,919
the name of the map so that's a pretty

00:23:17,520 --> 00:23:21,360
nice feature as well I think the program

00:23:19,919 --> 00:23:22,919
I was running earlier was actually

00:23:21,360 --> 00:23:24,929
compiled previously so the name wasn't

00:23:22,919 --> 00:23:26,309
there kind of an older Lib BPF got an

00:23:24,929 --> 00:23:31,140
example of how fast this stuff is moving

00:23:26,309 --> 00:23:34,890
which is great and I don't think I did a

00:23:31,140 --> 00:23:36,480
dump of that nope but that's and again

00:23:34,890 --> 00:23:37,410
this is just a great debugging tool this

00:23:36,480 --> 00:23:39,840
is kind of availability and

00:23:37,410 --> 00:23:42,480
serviceability that something like xdp

00:23:39,840 --> 00:23:45,540
needs alright yeah so this is this is

00:23:42,480 --> 00:23:47,220
the HTTP monitor as a you can use this

00:23:45,540 --> 00:23:49,919
as a debugging tool to see what's going

00:23:47,220 --> 00:23:53,010
on and in this case I am misconfigured

00:23:49,919 --> 00:23:56,040
something I'm using the the HTTP

00:23:53,010 --> 00:23:57,990
redirect action and I'm actually

00:23:56,040 --> 00:24:00,419
redirecting to to a CPU that doesn't

00:23:57,990 --> 00:24:02,520
exist so I'm in my program I'm calling

00:24:00,419 --> 00:24:06,480
about it or getting about it so I'm

00:24:02,520 --> 00:24:08,160
counting that and and and at the same

00:24:06,480 --> 00:24:12,450
time there's also some successful things

00:24:08,160 --> 00:24:18,299
going on this is this is a like a just a

00:24:12,450 --> 00:24:20,100
TCP or point force calls this this tests

00:24:18,299 --> 00:24:21,840
where we're just creating TCP

00:24:20,100 --> 00:24:25,529
connections back and forth so we're

00:24:21,840 --> 00:24:28,119
actually creating like 32,000

00:24:25,529 --> 00:24:29,979
connections per se TCP connections per

00:24:28,119 --> 00:24:31,839
second and this did this test and at the

00:24:29,979 --> 00:24:34,629
same time here we are basically dropping

00:24:31,839 --> 00:24:38,979
13 million packets per second and this

00:24:34,629 --> 00:24:40,959
this is this is fine easy right so but

00:24:38,979 --> 00:24:43,690
the program that was actually running in

00:24:40,959 --> 00:24:45,580
my program it my itself actually

00:24:43,690 --> 00:24:48,429
detected the situation in red over there

00:24:45,580 --> 00:24:52,029
then using a wrong destination CPU fine

00:24:48,429 --> 00:24:54,879
but I also load it in my program that

00:24:52,029 --> 00:24:57,690
I'm watching for exceptions so I am

00:24:54,879 --> 00:25:01,599
actually seeing that it takes ships in

00:24:57,690 --> 00:25:03,669
in in in the program itself here so I'm

00:25:01,599 --> 00:25:05,589
I'm catching yes I didn't need to use

00:25:03,669 --> 00:25:07,869
the atomiser tool because I actually

00:25:05,589 --> 00:25:09,700
chose to also also implement this in my

00:25:07,869 --> 00:25:14,979
own program to monitor this narrow space

00:25:09,700 --> 00:25:17,019
you can of course do that alright so

00:25:14,979 --> 00:25:19,089
these are great tools so far but as

00:25:17,019 --> 00:25:20,829
always whenever people have to point out

00:25:19,089 --> 00:25:23,679
problems with them will say patches are

00:25:20,829 --> 00:25:26,469
accepted so I think there's a ton of

00:25:23,679 --> 00:25:27,969
options you know as yes per mention

00:25:26,469 --> 00:25:29,469
maybe some more ways to do some some

00:25:27,969 --> 00:25:31,450
better printing some better decoding of

00:25:29,469 --> 00:25:34,570
the value stored in maps there are

00:25:31,450 --> 00:25:36,219
specifically some maps that are targeted

00:25:34,570 --> 00:25:37,329
at IP addresses so boy it sure would be

00:25:36,219 --> 00:25:40,419
great if those are just printed out as

00:25:37,329 --> 00:25:42,070
IP addresses also inspecting vpf

00:25:40,419 --> 00:25:44,379
programs before they're loaded it'd be

00:25:42,070 --> 00:25:46,450
great to be able to actually have a elf

00:25:44,379 --> 00:25:48,249
binary sitting on your system and check

00:25:46,450 --> 00:25:49,479
the tag on that compare that to the tag

00:25:48,249 --> 00:25:50,979
of the one that's running you should

00:25:49,479 --> 00:25:53,289
feel pretty confident that the the one

00:25:50,979 --> 00:25:54,789
that's running is the one you think you

00:25:53,289 --> 00:25:56,529
could also do some accumulation of

00:25:54,789 --> 00:25:58,839
results in person CPU maps because as

00:25:56,529 --> 00:26:00,779
we've both noted it's kind of a pain to

00:25:58,839 --> 00:26:02,739
add that up over and over again

00:26:00,779 --> 00:26:07,599
especially when you're using a counter

00:26:02,739 --> 00:26:09,609
that's across multiple CPUs yeah and it

00:26:07,599 --> 00:26:11,499
was the HDP - of course she was most

00:26:09,609 --> 00:26:13,269
essence so you can see examples but I

00:26:11,499 --> 00:26:15,099
could like if you want to bring make it

00:26:13,269 --> 00:26:16,929
usable like have maybe also have tation

00:26:15,099 --> 00:26:19,839
output that seems to like it to be a

00:26:16,929 --> 00:26:22,029
popular thing right and maybe have a

00:26:19,839 --> 00:26:24,399
lack of one shot option we're just I'm

00:26:22,029 --> 00:26:26,079
outputting the the stats and I could use

00:26:24,399 --> 00:26:29,019
that income but combined with the JSON

00:26:26,079 --> 00:26:30,729
output and pipe that into to to to to

00:26:29,019 --> 00:26:34,269
something that will display it in a

00:26:30,729 --> 00:26:36,669
smarter way right and then basically you

00:26:34,269 --> 00:26:38,380
can monitor than in an offensive manner

00:26:36,669 --> 00:26:40,750
so one of the great things in

00:26:38,380 --> 00:26:42,010
studying things I think about XDP and in

00:26:40,750 --> 00:26:43,360
these tools in particulars there's

00:26:42,010 --> 00:26:44,290
plenty of room for improvement so if

00:26:43,360 --> 00:26:45,610
you're looking for something to do

00:26:44,290 --> 00:26:48,760
you're not sure how to get involved

00:26:45,610 --> 00:26:50,170
we hope you'll yeah I encouraged by this

00:26:48,760 --> 00:26:53,470
have to move along with this little with

00:26:50,170 --> 00:26:56,320
you yeah okay all right so the reason

00:26:53,470 --> 00:26:59,530
some some recent change the Sui we added

00:26:56,320 --> 00:27:03,040
a way to transfer me to taser so so

00:26:59,530 --> 00:27:04,540
basically this is Daniels patch it's

00:27:03,040 --> 00:27:06,010
very recent patch but it's sort of

00:27:04,540 --> 00:27:08,770
important poke maybe people don't

00:27:06,010 --> 00:27:12,250
realize how important it it is but it's

00:27:08,770 --> 00:27:13,720
a generic way to to transfer some

00:27:12,250 --> 00:27:15,580
metadata information that get

00:27:13,720 --> 00:27:18,130
transferred to that can be used by other

00:27:15,580 --> 00:27:19,570
PPF programs for example TTC hook and

00:27:18,130 --> 00:27:23,290
that sort of creates a communication

00:27:19,570 --> 00:27:26,260
channel and it's it's implemented in a

00:27:23,290 --> 00:27:29,770
generic way which is really nice and

00:27:26,260 --> 00:27:32,580
it's part of the packet head room you

00:27:29,770 --> 00:27:34,990
could you could use this to like extract

00:27:32,580 --> 00:27:36,310
different information from the you

00:27:34,990 --> 00:27:39,550
choose something it makes the P program

00:27:36,310 --> 00:27:42,190
put in the meta data we we have a attach

00:27:39,550 --> 00:27:44,170
another Appa folk at the TC layer which

00:27:42,190 --> 00:27:45,730
will then extract information at this

00:27:44,170 --> 00:27:48,010
point we have created the sk p and we

00:27:45,730 --> 00:27:51,340
can now put a mark on the sk p based on

00:27:48,010 --> 00:27:56,170
some information we which we we found in

00:27:51,340 --> 00:27:57,820
the xt p program so yeah we probably

00:27:56,170 --> 00:28:01,150
probably to get rolling hey to do that

00:27:57,820 --> 00:28:02,620
but uh see ya and xdp redirect is the

00:28:01,150 --> 00:28:04,000
new return code since the last one so

00:28:02,620 --> 00:28:05,890
this is a great opportunity to send

00:28:04,000 --> 00:28:07,150
packets between two interfaces in the

00:28:05,890 --> 00:28:09,370
past it was just sending out the one

00:28:07,150 --> 00:28:10,630
that came in which at times doesn't seem

00:28:09,370 --> 00:28:13,030
quite as useful as being able to

00:28:10,630 --> 00:28:14,320
redirect to another interface or as yes

00:28:13,030 --> 00:28:17,920
per commented earlier being able to

00:28:14,320 --> 00:28:20,410
redirect via map is extra I want to

00:28:17,920 --> 00:28:22,600
highlight the innovative part is using

00:28:20,410 --> 00:28:24,580
maps to redirect because that means we

00:28:22,600 --> 00:28:25,780
did hopefully the last return coded in

00:28:24,580 --> 00:28:27,490
the drivers we don't have to touch the

00:28:25,780 --> 00:28:29,350
drivers but if we want to do a new type

00:28:27,490 --> 00:28:30,910
of redirection because we can just

00:28:29,350 --> 00:28:31,570
introduce a new map that does this

00:28:30,910 --> 00:28:35,050
redirection

00:28:31,570 --> 00:28:37,600
so I found that quite innovative it's

00:28:35,050 --> 00:28:40,150
it's not very obvious from from sort of

00:28:37,600 --> 00:28:42,040
the implementation but this redirect

00:28:40,150 --> 00:28:46,060
where maps actually give us the ability

00:28:42,040 --> 00:28:48,100
to receive bugging because we have

00:28:46,060 --> 00:28:50,800
implemented we have a flush operation

00:28:48,100 --> 00:28:52,180
after the napa powell is done which

00:28:50,800 --> 00:28:55,690
basically allow us to do

00:28:52,180 --> 00:28:58,090
like adaptive parking and without its

00:28:55,690 --> 00:29:02,490
using additional latency so we're just

00:28:58,090 --> 00:29:05,590
piggybacking on the normal nappy an IP

00:29:02,490 --> 00:29:08,740
system in the Linux kernel where we are

00:29:05,590 --> 00:29:11,230
adaptively turning on polling mode and

00:29:08,740 --> 00:29:18,600
disabling interrupts and in this way

00:29:11,230 --> 00:29:20,770
it's been working great since so yeah

00:29:18,600 --> 00:29:23,140
the well-known use cases we talked about

00:29:20,770 --> 00:29:25,380
DDoS load balancer forwarding between

00:29:23,140 --> 00:29:27,970
containers like cilium use case or

00:29:25,380 --> 00:29:30,130
rapidly prototyping new product new

00:29:27,970 --> 00:29:31,450
protocol extensions but also there's all

00:29:30,130 --> 00:29:34,410
kinds of crazy things that are maybe

00:29:31,450 --> 00:29:36,640
your unknown to the kernel you know I

00:29:34,410 --> 00:29:37,690
think the biggest thing that yes we're

00:29:36,640 --> 00:29:40,360
talked about and we know we're almost

00:29:37,690 --> 00:29:44,920
out of time feels like this is an Oscar

00:29:40,360 --> 00:29:46,080
speech and xdp redirect via CPU maps is

00:29:44,920 --> 00:29:48,520
really cool I think we should probably

00:29:46,080 --> 00:29:52,570
keep this one we just keep rolling yeah

00:29:48,520 --> 00:29:55,930
also then this does a cool patch 100

00:29:52,570 --> 00:29:57,640
amalia strike right offload routing you

00:29:55,930 --> 00:29:59,200
have the normal routing system in the

00:29:57,640 --> 00:30:01,510
leanest kernel throughout normal routing

00:29:59,200 --> 00:30:03,550
tables but we offload the routing to

00:30:01,510 --> 00:30:06,520
HTTP and use the existing set up but

00:30:03,550 --> 00:30:11,170
just route and optimize the performance

00:30:06,520 --> 00:30:13,450
via rates I think what I think that's

00:30:11,170 --> 00:30:19,510
fast I don't think that's a key stop a

00:30:13,450 --> 00:30:20,550
little bit before I yeah so we are out

00:30:19,510 --> 00:30:24,850
of time

00:30:20,550 --> 00:30:28,780
yes that's right so you can read the

00:30:24,850 --> 00:30:30,640
summary slides but yeah but I think we

00:30:28,780 --> 00:30:32,590
have a few seconds rift right yeah so we

00:30:30,640 --> 00:30:34,450
have that we want to highlight that this

00:30:32,590 --> 00:30:36,550
is an internal solution for for fast

00:30:34,450 --> 00:30:38,620
path right and we are we are getting

00:30:36,550 --> 00:30:39,910
programmable networking in satellite

00:30:38,620 --> 00:30:44,170
networks that just really powerful

00:30:39,910 --> 00:30:45,040
features we add in here and we think

00:30:44,170 --> 00:30:46,660
it'll be lower maintenance and

00:30:45,040 --> 00:30:49,270
deployment and it doesn't take over your

00:30:46,660 --> 00:30:50,590
NIC so it's a shared resource it doesn't

00:30:49,270 --> 00:30:52,360
take a look at we get very fine

00:30:50,590 --> 00:30:53,950
granularity you got to granular at a

00:30:52,360 --> 00:30:56,590
programming level watch what you want to

00:30:53,950 --> 00:31:00,750
do like DVD K takes all entire Nick we

00:30:56,590 --> 00:31:02,800
are providing the maximum flexibility

00:31:00,750 --> 00:31:04,030
yeah we can't we can't have a slide

00:31:02,800 --> 00:31:05,500
without thanks there's a ton of people

00:31:04,030 --> 00:31:11,350
that made this happen

00:31:05,500 --> 00:31:16,570
and we'd love to have it done more no

00:31:11,350 --> 00:31:18,519
thank you you can see these guys at the

00:31:16,570 --> 00:31:26,409
cloud bar tonight they they'll share

00:31:18,519 --> 00:31:33,370
drink with you and talk XDP Thanks time

00:31:26,409 --> 00:31:40,000
for no questions yeah okay you can get a

00:31:33,370 --> 00:31:43,149
question one so is it possible to do a

00:31:40,000 --> 00:31:48,639
xcp network redirect to something that

00:31:43,149 --> 00:31:51,700
doesn't run a piece a IFB to do a

00:31:48,639 --> 00:32:05,799
redirect to audit I didn't get that at

00:31:51,700 --> 00:32:16,269
IFP I'm not sure with it but buttocks

00:32:05,799 --> 00:32:17,980
XTP works on ingress already so yeah but

00:32:16,269 --> 00:32:19,960
III think cerium is actually already

00:32:17,980 --> 00:32:23,049
doing that they're loading a hook in the

00:32:19,960 --> 00:32:24,460
in the in the ingress hook out of TC so

00:32:23,049 --> 00:32:28,320
they I think they're actually doing an

00:32:24,460 --> 00:32:30,789
OD all right

00:32:28,320 --> 00:32:35,889
go share drink with these guys at cloud

00:32:30,789 --> 00:32:41,190
bar public service announcement yeah

00:32:35,889 --> 00:32:41,190

YouTube URL: https://www.youtube.com/watch?v=mGjz3lPgt8I


