Title: TC Flower Offâ€Œload
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 1 - Nov 08 2017
Description: 
	Speaker: Simon Horman
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?horman-tcflower-talk
Captions: 
	00:00:02,230 --> 00:00:06,700
so thanks everyone for coming along

00:00:04,390 --> 00:00:12,580
today I'm gonna be giving a little bit

00:00:06,700 --> 00:00:16,170
of an overview of TC flower what it is

00:00:12,580 --> 00:00:19,179
why it is what people are doing with it

00:00:16,170 --> 00:00:20,499
I'm with metronome we make smart Nick so

00:00:19,179 --> 00:00:26,759
there'll be an element of hardware

00:00:20,499 --> 00:00:32,650
offload to this talk as well all right

00:00:26,759 --> 00:00:35,500
so basically what TC flower allows you

00:00:32,650 --> 00:00:41,019
to do is to construct a match action

00:00:35,500 --> 00:00:42,910
data path so these days we have X D P

00:00:41,019 --> 00:00:44,949
and so on and this provides a different

00:00:42,910 --> 00:00:48,519
paradigm which allows you to do fully

00:00:44,949 --> 00:00:52,090
programmable packet processing but

00:00:48,519 --> 00:00:54,339
nonetheless a bit slightly older style

00:00:52,090 --> 00:00:56,910
match action data parser still quite

00:00:54,339 --> 00:01:00,269
useful and quite widely used I believe

00:00:56,910 --> 00:01:03,429
so I'll be talking about those today and

00:01:00,269 --> 00:01:06,700
so what is a match action data path what

00:01:03,429 --> 00:01:13,000
do we mean so your packet comes into the

00:01:06,700 --> 00:01:15,220
system about here and in some kind of

00:01:13,000 --> 00:01:17,259
classification takes place so typically

00:01:15,220 --> 00:01:21,640
this involves some code running through

00:01:17,259 --> 00:01:24,520
the packet examining headers populating

00:01:21,640 --> 00:01:26,530
some kind of key structure maybe

00:01:24,520 --> 00:01:27,549
selectively or maybe it runs through the

00:01:26,530 --> 00:01:30,070
whole header depending on the

00:01:27,549 --> 00:01:33,369
implementation it may also take into

00:01:30,070 --> 00:01:35,200
account metadata that may be somehow

00:01:33,369 --> 00:01:38,110
attached to the packet so for example

00:01:35,200 --> 00:01:40,960
the input port you usually know that but

00:01:38,110 --> 00:01:42,909
you may also know other things say it

00:01:40,960 --> 00:01:44,829
was previously tunnel that's been D

00:01:42,909 --> 00:01:47,020
capsulated they may be some information

00:01:44,829 --> 00:01:49,270
about the tunnel alder header

00:01:47,020 --> 00:01:51,399
available as metadata and you may want

00:01:49,270 --> 00:01:52,899
to add that to the key as well so then

00:01:51,399 --> 00:01:56,920
once you've got your key setup you do a

00:01:52,899 --> 00:01:59,530
lookup in your flow rules which usually

00:01:56,920 --> 00:02:01,060
pre-populated somehow and then if you've

00:01:59,530 --> 00:02:02,680
got a match then you get a bunch of

00:02:01,060 --> 00:02:04,990
actions and the actions could be

00:02:02,680 --> 00:02:06,969
something like drop it could be output

00:02:04,990 --> 00:02:09,429
it could be something slightly more

00:02:06,969 --> 00:02:12,400
complicated like add a VLAN but usually

00:02:09,429 --> 00:02:15,220
at the end you either drop or output and

00:02:12,400 --> 00:02:16,960
then from there you

00:02:15,220 --> 00:02:19,780
another action you meant Ford to another

00:02:16,960 --> 00:02:21,220
table so from from the match to the

00:02:19,780 --> 00:02:23,800
action you may go back and do another

00:02:21,220 --> 00:02:30,160
set of matches and that's what a match

00:02:23,800 --> 00:02:33,730
action data policies so TC flower allows

00:02:30,160 --> 00:02:36,750
us to construct these kind of things so

00:02:33,730 --> 00:02:40,030
TC flower is the match part of it so it

00:02:36,750 --> 00:02:43,060
implements the classification as I

00:02:40,030 --> 00:02:45,820
described just a moment ago it allows us

00:02:43,060 --> 00:02:49,540
to classify a quite a wide range of

00:02:45,820 --> 00:02:50,560
fields so of course L two fields and MAC

00:02:49,540 --> 00:02:54,520
address and so on

00:02:50,560 --> 00:02:57,490
VLANs MPLS moving a little further up

00:02:54,520 --> 00:03:00,520
the stack IP addresses and even to a

00:02:57,490 --> 00:03:04,330
limited extent L for things like UDP and

00:03:00,520 --> 00:03:06,490
TCP ports also tunnel metadata so the

00:03:04,330 --> 00:03:09,160
tunnel ID is that I guess the most

00:03:06,490 --> 00:03:11,080
obvious example but also things like the

00:03:09,160 --> 00:03:14,410
outer IP addresses and so on you can

00:03:11,080 --> 00:03:17,860
match on them and and the input port

00:03:14,410 --> 00:03:19,150
although this not strictly necessary at

00:03:17,860 --> 00:03:23,200
this point because the rules always

00:03:19,150 --> 00:03:25,450
attached to a port and then we have TC

00:03:23,200 --> 00:03:26,290
actions and these are being around for

00:03:25,450 --> 00:03:29,290
quite some time

00:03:26,290 --> 00:03:31,510
get constantly updated and improved and

00:03:29,290 --> 00:03:34,420
expanded on so we have peered at which

00:03:31,510 --> 00:03:37,769
is to go to to if you want to modify the

00:03:34,420 --> 00:03:41,709
packet data so if you wanted to modify

00:03:37,769 --> 00:03:43,269
one of the addresses at any layer or

00:03:41,709 --> 00:03:46,330
well at the ports or really any other

00:03:43,269 --> 00:03:48,760
part of the packet you can think of we

00:03:46,330 --> 00:03:52,239
have merge which is slightly non

00:03:48,760 --> 00:03:56,380
obviously named output action and we

00:03:52,239 --> 00:03:58,239
also have VLAN action there's others but

00:03:56,380 --> 00:04:04,000
these may be the most interesting in the

00:03:58,239 --> 00:04:08,320
context of this talk so here's an

00:04:04,000 --> 00:04:10,660
example of TC flower in action so those

00:04:08,320 --> 00:04:12,310
familiar with TC will make more of sense

00:04:10,660 --> 00:04:14,950
of this than those who aren't but

00:04:12,310 --> 00:04:16,890
basically firstly we establish a cue

00:04:14,950 --> 00:04:21,370
disk on the ingress rule which is

00:04:16,890 --> 00:04:25,120
basically allows us to attach of these

00:04:21,370 --> 00:04:27,300
flower rules to something and then the

00:04:25,120 --> 00:04:31,289
filter we're adding into e0

00:04:27,300 --> 00:04:35,340
it's going to be IP protocol the parent

00:04:31,289 --> 00:04:36,960
is the root so it's the topmost node and

00:04:35,340 --> 00:04:38,580
then here we are getting into flower

00:04:36,960 --> 00:04:40,409
land we're going to use the flower

00:04:38,580 --> 00:04:43,560
classifier to deal with this packet that

00:04:40,409 --> 00:04:47,310
we've selected we already know that it's

00:04:43,560 --> 00:04:48,259
IP but we want the IP protocol to be

00:04:47,310 --> 00:04:51,150
setp

00:04:48,259 --> 00:04:54,629
and then the destination port to be port

00:04:51,150 --> 00:04:58,530
80 and if those conditions are true then

00:04:54,629 --> 00:05:02,550
we drop the packet so did this example

00:04:58,530 --> 00:05:05,460
is completely arbitrary we could it

00:05:02,550 --> 00:05:06,930
could be UDP instead of TCP we could not

00:05:05,460 --> 00:05:09,419
match on the port we could match on the

00:05:06,930 --> 00:05:10,949
IP address we could not drop the packet

00:05:09,419 --> 00:05:17,490
we could output it it's it's just an

00:05:10,949 --> 00:05:22,590
example okay so I talked briefly about

00:05:17,490 --> 00:05:25,080
the implementation of flower mean one or

00:05:22,590 --> 00:05:29,639
two little quirks in it so firstly the

00:05:25,080 --> 00:05:31,169
it makes use of this subsystem in the in

00:05:29,639 --> 00:05:33,389
the networking stack called the floater

00:05:31,169 --> 00:05:35,819
sector which is shared by various other

00:05:33,389 --> 00:05:39,569
things so this is the same piece of code

00:05:35,819 --> 00:05:42,300
that generates the hash for RSS and so

00:05:39,569 --> 00:05:44,729
on it's used in a slightly different way

00:05:42,300 --> 00:05:46,710
in TC flower and I think it was decided

00:05:44,729 --> 00:05:48,449
in the last few days that this behavior

00:05:46,710 --> 00:05:49,979
will be breaking broken up a little bit

00:05:48,449 --> 00:05:55,229
but it will still be part of the flow

00:05:49,979 --> 00:05:57,750
dissector in the way the flow detector

00:05:55,229 --> 00:05:59,819
works in general is you describe which

00:05:57,750 --> 00:06:02,669
parts of the packet you want you're

00:05:59,819 --> 00:06:05,009
interested in so I can't remember the

00:06:02,669 --> 00:06:07,710
exact details of sort of my head but for

00:06:05,009 --> 00:06:11,219
example if you might say I want to

00:06:07,710 --> 00:06:14,479
dissect IP addresses and I want to

00:06:11,219 --> 00:06:17,279
dissect but I'm not interested at all in

00:06:14,479 --> 00:06:19,199
UDP port in ports layer for ports so

00:06:17,279 --> 00:06:22,409
that you would set up the description to

00:06:19,199 --> 00:06:26,159
say please do IP but don't do layer for

00:06:22,409 --> 00:06:33,960
and the section will only examine the

00:06:26,159 --> 00:06:36,690
packet as described by the request and

00:06:33,960 --> 00:06:39,479
the florida sector when it's extracting

00:06:36,690 --> 00:06:40,320
the data from the packet it seeds it

00:06:39,479 --> 00:06:43,440
into a

00:06:40,320 --> 00:06:46,970
the structure and then essentially that

00:06:43,440 --> 00:06:49,950
data structure is returned to the caller

00:06:46,970 --> 00:06:53,310
so in the case of flour that resulting

00:06:49,950 --> 00:06:56,460
data structure is then masked so a

00:06:53,310 --> 00:06:58,680
simple example of masking might be that

00:06:56,460 --> 00:07:01,760
instead of matching on an individual IP

00:06:58,680 --> 00:07:04,860
address you want to match in all IP

00:07:01,760 --> 00:07:07,370
addresses in a particular subnet so we

00:07:04,860 --> 00:07:11,130
can use a masking to achieve that and

00:07:07,370 --> 00:07:13,920
then the resulting masked key is then

00:07:11,130 --> 00:07:17,640
locked up in some kind of hash data

00:07:13,920 --> 00:07:20,220
structure and if there's a match the

00:07:17,640 --> 00:07:23,720
actions executed and these RTC actions

00:07:20,220 --> 00:07:25,740
if there's no match then processing

00:07:23,720 --> 00:07:28,080
continues as per the usual

00:07:25,740 --> 00:07:30,840
TC rules so it will basically look for

00:07:28,080 --> 00:07:32,670
the next classifier and if there's no

00:07:30,840 --> 00:07:39,060
more classifiers it will fall down

00:07:32,670 --> 00:07:41,400
through to the regular Linux stack so

00:07:39,060 --> 00:07:42,870
one thing to observe about the current

00:07:41,400 --> 00:07:46,280
implementation and it's not really a

00:07:42,870 --> 00:07:49,050
limitation in the design as such but

00:07:46,280 --> 00:07:52,680
currently you can only have one mask at

00:07:49,050 --> 00:07:55,140
a given priority level so this means

00:07:52,680 --> 00:07:57,000
that all the matching going on at a

00:07:55,140 --> 00:08:01,730
given priority level has the same mask

00:07:57,000 --> 00:08:03,900
but if your rule set has different masks

00:08:01,730 --> 00:08:08,190
also say you will have one set of rules

00:08:03,900 --> 00:08:10,230
that is matching on IP addresses and a

00:08:08,190 --> 00:08:13,080
different set of rules which is matching

00:08:10,230 --> 00:08:14,760
on IP addresses and ports then you would

00:08:13,080 --> 00:08:17,490
have to do these at a different priority

00:08:14,760 --> 00:08:20,430
level and it's up to the caller the user

00:08:17,490 --> 00:08:23,280
space who programs the rules to arrange

00:08:20,430 --> 00:08:27,090
the priority levels correctly so if you

00:08:23,280 --> 00:08:30,630
have disjoint flows by disjoint I mean

00:08:27,090 --> 00:08:33,390
that regardless of what the mask is no

00:08:30,630 --> 00:08:35,370
two flows can match the same packet then

00:08:33,390 --> 00:08:38,370
the ordering of the flows in terms of

00:08:35,370 --> 00:08:41,880
the priority levels is unimportant from

00:08:38,370 --> 00:08:43,950
a correctness point of view but if you

00:08:41,880 --> 00:08:46,320
have overlapping flows for some reason

00:08:43,950 --> 00:08:48,540
then you need to arrange such that the

00:08:46,320 --> 00:08:54,570
ones you want to hit first are

00:08:48,540 --> 00:08:56,820
considered first but a common use case

00:08:54,570 --> 00:08:59,850
for this is to use it in conjunction

00:08:56,820 --> 00:09:02,790
with OVS and in that case the flows are

00:08:59,850 --> 00:09:10,350
always disjoint so the ordering is not

00:09:02,790 --> 00:09:13,830
so important okay so one of the things

00:09:10,350 --> 00:09:16,350
that we can do with this is in a sense

00:09:13,830 --> 00:09:20,520
TC has two halves is a control plane and

00:09:16,350 --> 00:09:23,280
the data path and up until recently the

00:09:20,520 --> 00:09:27,450
data paths and the control plane of both

00:09:23,280 --> 00:09:31,050
in software but we can now use the same

00:09:27,450 --> 00:09:35,340
software this same control plane to

00:09:31,050 --> 00:09:37,020
configure a data path in hardware the

00:09:35,340 --> 00:09:40,650
data path in software is still there and

00:09:37,020 --> 00:09:42,270
any functionality that exists in

00:09:40,650 --> 00:09:45,120
hardware is also implemented in software

00:09:42,270 --> 00:09:47,190
so it's it should be the you should get

00:09:45,120 --> 00:09:50,640
the same behaviors it's just a question

00:09:47,190 --> 00:09:53,700
of performance but working for a

00:09:50,640 --> 00:09:55,890
hardware offload oriented company why

00:09:53,700 --> 00:09:58,620
would you want to offload the reasons

00:09:55,890 --> 00:10:01,080
are usually two of twofold one one or

00:09:58,620 --> 00:10:03,000
both of the reason one or both of the

00:10:01,080 --> 00:10:06,450
following two considerations is to give

00:10:03,000 --> 00:10:10,140
greater throughput oh and or to reduce

00:10:06,450 --> 00:10:13,470
the CPU utilization so once we get to a

00:10:10,140 --> 00:10:15,810
high packet rates that you might see say

00:10:13,470 --> 00:10:18,270
on 10 gigabit or above networks

00:10:15,810 --> 00:10:20,850
it could consume a lot of host CPU to

00:10:18,270 --> 00:10:22,710
process these packets if we push these

00:10:20,850 --> 00:10:25,440
to the hardware then the host CPU

00:10:22,710 --> 00:10:31,650
becomes free free other use something

00:10:25,440 --> 00:10:33,060
like that so a quick history of TC

00:10:31,650 --> 00:10:35,520
hardware offload and most of the credit

00:10:33,060 --> 00:10:38,610
here goes to John Foster been to is

00:10:35,520 --> 00:10:40,470
somewhere around here today so I was

00:10:38,610 --> 00:10:44,960
very surprised to find that the history

00:10:40,470 --> 00:10:49,170
goes way way back to to 639 which is

00:10:44,960 --> 00:10:52,710
about six years ago I think and it was

00:10:49,170 --> 00:10:54,420
first added to mq prior so this is just

00:10:52,710 --> 00:10:56,580
a queueing discipline you can't use it

00:10:54,420 --> 00:11:00,540
to construct data paths and so on like I

00:10:56,580 --> 00:11:04,299
just described but you can use it to to

00:11:00,540 --> 00:11:07,449
to program certain behavior into the

00:11:04,299 --> 00:11:09,429
regarding on how it Q's packets there's

00:11:07,449 --> 00:11:11,679
been long around for a long time and at

00:11:09,429 --> 00:11:15,549
that time this India set up TC was

00:11:11,679 --> 00:11:17,229
introduced and the relevance to that to

00:11:15,549 --> 00:11:22,029
what I'm talking today is it's the same

00:11:17,229 --> 00:11:26,199
India Oh that were using to offload TC

00:11:22,029 --> 00:11:31,389
today so in four point six so this is

00:11:26,199 --> 00:11:33,459
going back about 18 months ago now and

00:11:31,389 --> 00:11:35,349
it's a John added support for the you

00:11:33,459 --> 00:11:37,689
thirty-two classifier offload now you

00:11:35,349 --> 00:11:39,939
thirty-two functions quite differently

00:11:37,689 --> 00:11:41,799
to flower but it's conceptually similar

00:11:39,939 --> 00:11:44,529
in the sense that a packet comes into

00:11:41,799 --> 00:11:48,720
the system and it can match on it using

00:11:44,529 --> 00:11:54,729
some kind of user user configured

00:11:48,720 --> 00:11:56,259
parameters so skipping forwards to not

00:11:54,729 --> 00:11:59,049
quite the present but the present as of

00:11:56,259 --> 00:12:02,949
when I prepared materials for this for

00:11:59,049 --> 00:12:06,909
today for fifteen rc4 I don't think

00:12:02,949 --> 00:12:09,249
there's been sorry yeah see I made a

00:12:06,909 --> 00:12:12,759
mistake this is in the future but what I

00:12:09,249 --> 00:12:14,439
mean is for fourteen rc4 so basically a

00:12:12,759 --> 00:12:16,449
month ago and the future said shouldn't

00:12:14,439 --> 00:12:17,769
have changed since then in terms of

00:12:16,449 --> 00:12:22,419
what's going to be included in four

00:12:17,769 --> 00:12:27,489
fourteen so the following classifiers

00:12:22,419 --> 00:12:28,899
are BPF flower macho all supports some

00:12:27,489 --> 00:12:30,879
kind of offload or offload is

00:12:28,899 --> 00:12:33,659
implemented for all of these in some

00:12:30,879 --> 00:12:38,559
places and of course the mq pyro

00:12:33,659 --> 00:12:40,539
continues to be supported I just give a

00:12:38,559 --> 00:12:41,649
particular shout out to the people I

00:12:40,539 --> 00:12:43,419
work with natural on where you're

00:12:41,649 --> 00:12:48,249
supporting both the BPF and flower

00:12:43,419 --> 00:12:51,519
classifier and just a quick word about

00:12:48,249 --> 00:12:54,220
the actions so this this history here

00:12:51,519 --> 00:12:55,959
refers to to basically when the hook was

00:12:54,220 --> 00:12:58,329
added or when support was added for

00:12:55,959 --> 00:13:01,720
offloading a one classifier or another

00:12:58,329 --> 00:13:03,759
but what about the actions well their

00:13:01,720 --> 00:13:07,029
actions the way the TC works is actions

00:13:03,759 --> 00:13:09,279
are attached to your classifier so we

00:13:07,029 --> 00:13:11,379
don't need an extra hook or so on to

00:13:09,279 --> 00:13:13,659
offload the action you just get the

00:13:11,379 --> 00:13:15,279
bundle the flow the rule whatever you

00:13:13,659 --> 00:13:17,350
want to call it of information coming

00:13:15,279 --> 00:13:17,730
down to the driver which implements this

00:13:17,350 --> 00:13:25,360
and

00:13:17,730 --> 00:13:27,279
and then the driver can examine firstly

00:13:25,360 --> 00:13:28,629
the classifier and all the information

00:13:27,279 --> 00:13:32,649
in the classifier but then it gets the

00:13:28,629 --> 00:13:35,050
actions and for all of these or elements

00:13:32,649 --> 00:13:38,199
of the rule it can decide whether or not

00:13:35,050 --> 00:13:40,899
it wants to toe off floated or not

00:13:38,199 --> 00:13:42,490
so it might may choose to reject so for

00:13:40,899 --> 00:13:46,389
instance the metronome driver if it gets

00:13:42,490 --> 00:13:47,800
requests to to offload u32 classifier

00:13:46,389 --> 00:13:51,670
which it doesn't support it just rejects

00:13:47,800 --> 00:13:53,230
it if it gets requests to to offload

00:13:51,670 --> 00:13:54,730
something which it otherwise likes but

00:13:53,230 --> 00:13:58,149
it's using an action it doesn't support

00:13:54,730 --> 00:14:02,619
and doesn't support yet it rejects it so

00:13:58,149 --> 00:14:04,269
this is a I'll get a little bit more

00:14:02,619 --> 00:14:12,249
onto this flow and then the following

00:14:04,269 --> 00:14:16,480
slides ok so it's all very well to be

00:14:12,249 --> 00:14:18,309
able to program roles and one possible

00:14:16,480 --> 00:14:21,100
approach to this would be to kind of do

00:14:18,309 --> 00:14:24,370
it transparently without the user

00:14:21,100 --> 00:14:27,100
knowing so in that kind of scenario if

00:14:24,370 --> 00:14:28,899
you had a box I and then you plug in

00:14:27,100 --> 00:14:30,670
some new piece of hardware that gets off

00:14:28,899 --> 00:14:32,529
load or you upgrade the kernel so it

00:14:30,670 --> 00:14:34,540
supports the offload then suddenly

00:14:32,529 --> 00:14:36,550
without changing a configuration

00:14:34,540 --> 00:14:38,949
everything would go faster that would be

00:14:36,550 --> 00:14:40,689
a transparent model this is not the

00:14:38,949 --> 00:14:43,329
model that's supported the model is

00:14:40,689 --> 00:14:45,370
supported allows the user to control

00:14:43,329 --> 00:14:48,639
things and generally speaking to opt in

00:14:45,370 --> 00:14:51,819
so firstly the first level of

00:14:48,639 --> 00:14:54,309
configuration we have is a global on/off

00:14:51,819 --> 00:14:56,559
switch on a per device basis a per

00:14:54,309 --> 00:14:58,720
native basis of whether or not you want

00:14:56,559 --> 00:15:01,899
to allow TC offload so that would be for

00:14:58,720 --> 00:15:04,990
all types of of all the different

00:15:01,899 --> 00:15:10,269
classifiers so you can turn it on and

00:15:04,990 --> 00:15:15,579
off as per the example there the next

00:15:10,269 --> 00:15:19,299
layer is well the other layer is a per

00:15:15,579 --> 00:15:21,189
flow configuration so you may want to do

00:15:19,299 --> 00:15:23,139
some some offloading of flows but you

00:15:21,189 --> 00:15:28,089
may want to control the flow placement

00:15:23,139 --> 00:15:30,249
for some reason any reason so an example

00:15:28,089 --> 00:15:31,540
of a reason might be that you may have

00:15:30,249 --> 00:15:34,690
some hardware the cannolis

00:15:31,540 --> 00:15:36,670
for a limited number of flows and you

00:15:34,690 --> 00:15:39,160
may want to place the the more important

00:15:36,670 --> 00:15:41,500
ones by for some evaluation of important

00:15:39,160 --> 00:15:43,389
into the hardware and leave the other

00:15:41,500 --> 00:15:48,069
ones into software that would be one

00:15:43,389 --> 00:15:51,490
example there are others so in to allow

00:15:48,069 --> 00:15:55,630
this policy to be selected by the user

00:15:51,490 --> 00:15:57,930
and and reflected into Hardware we have

00:15:55,630 --> 00:16:01,540
to flag skip hardware and skip software

00:15:57,930 --> 00:16:03,399
so in the case of skip skip Hardware it

00:16:01,540 --> 00:16:05,920
just means don't add it to Hardware only

00:16:03,399 --> 00:16:08,160
add it to software and if you can't add

00:16:05,920 --> 00:16:10,540
it to software it's an error and

00:16:08,160 --> 00:16:12,160
unsurprisingly skip software is the

00:16:10,540 --> 00:16:15,069
opposite it means don't add it to

00:16:12,160 --> 00:16:17,350
software only add it to hardware and if

00:16:15,069 --> 00:16:19,360
you can't do that it's an error and then

00:16:17,350 --> 00:16:21,639
you have the default policy which is a

00:16:19,360 --> 00:16:24,639
bit undefined but in practice what it is

00:16:21,639 --> 00:16:27,100
is try to add it to hardware if the

00:16:24,639 --> 00:16:30,399
hardware is there regardless of what

00:16:27,100 --> 00:16:33,130
happens add it a software and only if it

00:16:30,399 --> 00:16:38,110
fails to be added to software then you

00:16:33,130 --> 00:16:39,550
get an error so this allows the

00:16:38,110 --> 00:16:41,350
placement of things that's very nice we

00:16:39,550 --> 00:16:43,810
can control where our flows are but it's

00:16:41,350 --> 00:16:46,300
also be nice to be able to inspect where

00:16:43,810 --> 00:16:48,100
they are so that's where these separate

00:16:46,300 --> 00:16:55,569
flags come in in hardware and not in

00:16:48,100 --> 00:16:57,160
hardware and these allow you to see

00:16:55,569 --> 00:17:00,310
where the flows are so I'll just show a

00:16:57,160 --> 00:17:02,889
quick example this is the same example

00:17:00,310 --> 00:17:05,380
as before except the depart in bode

00:17:02,889 --> 00:17:06,790
where I've said please skip hardware so

00:17:05,380 --> 00:17:09,309
what I'm saying is that flow that I

00:17:06,790 --> 00:17:12,069
showed before I want to only place that

00:17:09,309 --> 00:17:14,110
in Hardware which is a zero and if the

00:17:12,069 --> 00:17:17,880
zero doesn't support Hardware off load

00:17:14,110 --> 00:17:20,350
it's been turned off using his tool or

00:17:17,880 --> 00:17:22,360
for some reason this flow is not

00:17:20,350 --> 00:17:27,730
acceptable to the hardware then I'll get

00:17:22,360 --> 00:17:30,150
an error as it happens I didn't so here

00:17:27,730 --> 00:17:32,770
we this is the same flow again I'm just

00:17:30,150 --> 00:17:35,799
asking the kernel to tell me what it is

00:17:32,770 --> 00:17:38,470
and what's been reported here is that I

00:17:35,799 --> 00:17:40,450
asked for skip software and that it is

00:17:38,470 --> 00:17:41,679
present in hardware well in this case if

00:17:40,450 --> 00:17:42,830
it wasn't present in hardware it

00:17:41,679 --> 00:17:46,789
wouldn't be present at all

00:17:42,830 --> 00:17:50,210
but it it would be possible for say I

00:17:46,789 --> 00:17:52,789
had not used the skipped software flag

00:17:50,210 --> 00:17:54,200
but I had added it to advise device that

00:17:52,789 --> 00:17:56,690
supports offload then I would say that

00:17:54,200 --> 00:17:58,279
it's in hardware but I will it would

00:17:56,690 --> 00:18:03,679
also be in software because there would

00:17:58,279 --> 00:18:05,269
be no skip software flag okay okay so

00:18:03,679 --> 00:18:09,380
I'm actually kind of getting towards the

00:18:05,269 --> 00:18:11,200
end of this presentation so now I just

00:18:09,380 --> 00:18:19,809
like to talk briefly about some possible

00:18:11,200 --> 00:18:19,809
enhancements for for this implementation

00:18:21,039 --> 00:18:27,860
so one is just to extend the current

00:18:25,460 --> 00:18:29,840
static matching so currently we can for

00:18:27,860 --> 00:18:33,200
example to up which we can't do neighbor

00:18:29,840 --> 00:18:34,909
discovery the main problem with adding

00:18:33,200 --> 00:18:36,980
this kind of stuff is it adds complexity

00:18:34,909 --> 00:18:38,899
to the flow the sector and it can cause

00:18:36,980 --> 00:18:42,309
stuff to break for other people or just

00:18:38,899 --> 00:18:44,539
in general makes it code more complex

00:18:42,309 --> 00:18:46,039
it's also arguable that neighbor

00:18:44,539 --> 00:18:48,710
discovery in these kind of things aren't

00:18:46,039 --> 00:18:50,210
particularly good targets for offload

00:18:48,710 --> 00:18:54,380
which is one of the motivations for

00:18:50,210 --> 00:18:56,059
flower but hopefully in the long run we

00:18:54,380 --> 00:18:58,940
can resolve these complexity issues

00:18:56,059 --> 00:19:00,110
somehow and allowed these features to to

00:18:58,940 --> 00:19:03,169
happen so we can have a full

00:19:00,110 --> 00:19:05,389
implementation on the software side and

00:19:03,169 --> 00:19:08,029
and for more fully describe data data

00:19:05,389 --> 00:19:12,889
pass even if particular flows might not

00:19:08,029 --> 00:19:15,710
be good candidates for offloads you know

00:19:12,889 --> 00:19:17,809
we support err MPLS label stack entry

00:19:15,710 --> 00:19:19,220
matching which is kind of nice but I

00:19:17,809 --> 00:19:21,409
noticed when I was looking through the

00:19:19,220 --> 00:19:22,070
code not so long ago that it's not

00:19:21,409 --> 00:19:23,830
mousekeball

00:19:22,070 --> 00:19:27,289
this is kind of a trivial kind of update

00:19:23,830 --> 00:19:28,970
I did pretty much everything else that

00:19:27,289 --> 00:19:32,990
makes sense Tomas can be mosque so I

00:19:28,970 --> 00:19:34,789
think that should be added and then

00:19:32,990 --> 00:19:36,350
there's Geneva options there are the

00:19:34,789 --> 00:19:38,320
types of tunnel options too but in

00:19:36,350 --> 00:19:41,990
particular Genovese interesting because

00:19:38,320 --> 00:19:45,710
things like oven used Geneva and they

00:19:41,990 --> 00:19:48,610
use options to more accurately identify

00:19:45,710 --> 00:19:48,610
I think the tenant

00:19:48,910 --> 00:19:53,830
so this on the on the inside of the

00:19:52,240 --> 00:19:56,170
kernel this is not so hard to implement

00:19:53,830 --> 00:19:57,790
because the tunnel options are already

00:19:56,170 --> 00:20:00,640
extracted they're already available

00:19:57,790 --> 00:20:04,210
internally the main question is that a

00:20:00,640 --> 00:20:06,520
nice way to represent this to users so

00:20:04,210 --> 00:20:09,730
for example the first patch I sent not

00:20:06,520 --> 00:20:12,970
so long ago just exposes a bit mask a

00:20:09,730 --> 00:20:16,060
bite mask this is a byte string sorry

00:20:12,970 --> 00:20:17,920
this is not so great because it's just

00:20:16,060 --> 00:20:20,560
this mask of bytes you don't know what

00:20:17,920 --> 00:20:23,050
they mean and it does have structure

00:20:20,560 --> 00:20:25,660
which is T of e so we be better to

00:20:23,050 --> 00:20:28,530
expose it here V's but then you come up

00:20:25,660 --> 00:20:30,850
with this issue of should you match them

00:20:28,530 --> 00:20:34,840
dependent of the order or independent of

00:20:30,850 --> 00:20:36,610
the order I prefer for it to be order

00:20:34,840 --> 00:20:39,880
dependent because it's been nicer on the

00:20:36,610 --> 00:20:44,470
fast path but regardless I think we can

00:20:39,880 --> 00:20:45,790
we can add this especially now that once

00:20:44,470 --> 00:20:47,560
we untangle a bit from the flow

00:20:45,790 --> 00:20:52,720
dissector and it won't have impact on

00:20:47,560 --> 00:20:54,370
all the users okay and if my memory

00:20:52,720 --> 00:20:58,720
serves me correctly this is the last

00:20:54,370 --> 00:21:00,640
life so contract this is a bit hot topic

00:20:58,720 --> 00:21:02,380
and a cheat a net filter workshop down

00:21:00,640 --> 00:21:04,440
stairs they probably talk about it right

00:21:02,380 --> 00:21:04,440
now

00:21:04,950 --> 00:21:11,080
so everything flower can do so far in

00:21:07,990 --> 00:21:12,820
terms of app matching is stateless in

00:21:11,080 --> 00:21:14,890
the sense that it's just arrived from

00:21:12,820 --> 00:21:20,620
the packet it sees isn't there's no

00:21:14,890 --> 00:21:22,420
other information required but in

00:21:20,620 --> 00:21:23,950
writing security policies and so on it

00:21:22,420 --> 00:21:27,820
can be useful to have stateful

00:21:23,950 --> 00:21:30,460
information so you can write your data

00:21:27,820 --> 00:21:32,880
path in some data path rules in some way

00:21:30,460 --> 00:21:35,290
that the security aware and they perhaps

00:21:32,880 --> 00:21:40,540
don't allow new flows in one direction

00:21:35,290 --> 00:21:42,880
only in the other direction and so on so

00:21:40,540 --> 00:21:44,950
this requires quite some discussion and

00:21:42,880 --> 00:21:47,140
it's it's kind of in the incomplete but

00:21:44,950 --> 00:21:48,790
what open vids we switch does which

00:21:47,140 --> 00:21:52,420
seems like it could be good inspiration

00:21:48,790 --> 00:21:55,000
in this area in the century you have

00:21:52,420 --> 00:21:56,890
your match and you say ok well my SCTP

00:21:55,000 --> 00:21:59,140
port 80 packets just like the rule I had

00:21:56,890 --> 00:22:00,580
before I want to do something with them

00:21:59,140 --> 00:22:01,430
but I want to do something that state

00:22:00,580 --> 00:22:03,380
dependent

00:22:01,430 --> 00:22:05,750
now I think of it not sure if that makes

00:22:03,380 --> 00:22:10,490
sense with a CT period let's say TCP

00:22:05,750 --> 00:22:12,620
port 80 and so my action is I is some

00:22:10,490 --> 00:22:14,360
kind of contract action so the contract

00:22:12,620 --> 00:22:18,080
action would just feed the packet into

00:22:14,360 --> 00:22:19,610
the contract says system and then get

00:22:18,080 --> 00:22:21,890
some kind of state from contract

00:22:19,610 --> 00:22:23,450
subsystem out of it that says the you

00:22:21,890 --> 00:22:25,850
know is this connection new is it

00:22:23,450 --> 00:22:29,990
related is it this kind of information

00:22:25,850 --> 00:22:31,430
and then you go back to you match the

00:22:29,990 --> 00:22:34,220
second match which is different for this

00:22:31,430 --> 00:22:35,750
one and this one was will match the

00:22:34,220 --> 00:22:39,110
match they would include some kind of

00:22:35,750 --> 00:22:43,179
information of the contract so like if

00:22:39,110 --> 00:22:49,100
it's if it's new drop if it's connected

00:22:43,179 --> 00:22:53,030
pass or whatever so that would be what

00:22:49,100 --> 00:22:55,160
to do is described here and then of

00:22:53,030 --> 00:22:57,650
course as as an ongoing theme of

00:22:55,160 --> 00:23:01,160
offloading in my life but also in this

00:22:57,650 --> 00:23:05,020
presentation the idea would be to try to

00:23:01,160 --> 00:23:07,400
find some way to to to push that

00:23:05,020 --> 00:23:09,050
configuration down into the hardware but

00:23:07,400 --> 00:23:10,820
also of course provide the software

00:23:09,050 --> 00:23:18,380
implementation which would have to come

00:23:10,820 --> 00:23:18,830
first but it is quite sticky topic not

00:23:18,380 --> 00:23:20,660
steady

00:23:18,830 --> 00:23:23,929
it's a difficulty problem which will

00:23:20,660 --> 00:23:27,290
require more discussions okay

00:23:23,929 --> 00:23:28,670
as promised that was last slide so thank

00:23:27,290 --> 00:23:30,620
you very much for your time any

00:23:28,670 --> 00:23:34,670
questions

00:23:30,620 --> 00:23:37,120
also and if not please feel free to come

00:23:34,670 --> 00:23:37,120
up afterwards

00:23:37,260 --> 00:23:43,640
[Music]

00:23:39,460 --> 00:23:48,140
in your hardware do you support changing

00:23:43,640 --> 00:23:52,100
the flow key on the fly or you know the

00:23:48,140 --> 00:23:54,470
match feels they are configurable or you

00:23:52,100 --> 00:23:57,950
have like fixed matches that are you

00:23:54,470 --> 00:24:00,350
know I can give an example right you

00:23:57,950 --> 00:24:04,400
were matching something like a portable

00:24:00,350 --> 00:24:06,290
tcp/ip source and just address plus you

00:24:04,400 --> 00:24:08,780
know the I think I know where you're

00:24:06,290 --> 00:24:11,600
going with this could I support in the

00:24:08,780 --> 00:24:14,960
hardware matching on say a particular

00:24:11,600 --> 00:24:17,690
value at a particular offset yes exactly

00:24:14,960 --> 00:24:20,930
and so on yes so in the hardware side

00:24:17,690 --> 00:24:22,250
yes we could support well it's a bit of

00:24:20,930 --> 00:24:24,200
a misleading thing in the natural

00:24:22,250 --> 00:24:26,090
hardware is fully programmable so it a

00:24:24,200 --> 00:24:28,340
question of does the firmware implement

00:24:26,090 --> 00:24:29,600
it if it doesn't it could simply be

00:24:28,340 --> 00:24:33,530
added but I think actually it already

00:24:29,600 --> 00:24:35,930
does support it so right now your driver

00:24:33,530 --> 00:24:41,180
can to support any random kind of magic

00:24:35,930 --> 00:24:44,870
so that there so the driver can only do

00:24:41,180 --> 00:24:46,700
what the flower does and flower doesn't

00:24:44,870 --> 00:24:49,160
support that particular thing if flower

00:24:46,700 --> 00:24:50,630
was to get it the driver I think it

00:24:49,160 --> 00:25:02,350
would be very easy for us to support

00:24:50,630 --> 00:25:02,350
them nobody else okay

00:25:05,090 --> 00:25:08,820
thank you very much for your time and

00:25:06,650 --> 00:25:14,950
enjoy the rest of your week

00:25:08,820 --> 00:25:14,950

YouTube URL: https://www.youtube.com/watch?v=vCmpSLL-O8Y


