Title: Netfâ€Œilter mini-workshop
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 1 - Nov 08 2017
Description: 
	Speaker: Pablo Neira Ayuso
Friday November 08th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?ayuso-netfilter-workshop
Captions: 
	00:00:01,630 --> 00:00:06,490
filter updates since the last netfilter

00:00:04,330 --> 00:00:09,820
not net for the workshop sorry they need

00:00:06,490 --> 00:00:14,650
last night their conference and that

00:00:09,820 --> 00:00:16,869
happened six months ago so this is not

00:00:14,650 --> 00:00:18,279
that specifically a tutorial so for

00:00:16,869 --> 00:00:21,670
those that are not familiar with any

00:00:18,279 --> 00:00:23,439
tables yet I'm going to refer to the

00:00:21,670 --> 00:00:25,650
documentation that is available on the

00:00:23,439 --> 00:00:25,650
website

00:00:25,920 --> 00:00:32,710
it's basically Vicki NS table salt or

00:00:29,730 --> 00:00:37,390
it's starting to get quite complete we

00:00:32,710 --> 00:00:40,379
have a we have users requesting accounts

00:00:37,390 --> 00:00:44,309
on the in the VIP that are starting to

00:00:40,379 --> 00:00:46,510
to extend the documentation examples and

00:00:44,309 --> 00:00:48,280
so it's starting to look quite quite

00:00:46,510 --> 00:00:53,559
quite nice in my opinion now we have

00:00:48,280 --> 00:00:56,079
also the main page so not not expecting

00:00:53,559 --> 00:00:58,180
a tutorial specifically here I'm going

00:00:56,079 --> 00:01:01,960
to make incremental updates on what is

00:00:58,180 --> 00:01:03,489
going on also those updates are going to

00:01:01,960 --> 00:01:09,040
be related with the netfilter workshop

00:01:03,489 --> 00:01:11,470
it's in it's a very small conference

00:01:09,040 --> 00:01:13,060
that happens once a year to where it's a

00:01:11,470 --> 00:01:15,430
meeting basically where all that sort of

00:01:13,060 --> 00:01:18,520
developers meet to talk about ongoing

00:01:15,430 --> 00:01:21,130
development efforts and this time it

00:01:18,520 --> 00:01:24,189
happened a few months ago in following

00:01:21,130 --> 00:01:26,409
protocol and we have we had really a

00:01:24,189 --> 00:01:27,640
nice time there actually and we make

00:01:26,409 --> 00:01:29,890
quite a lot of progress in all the

00:01:27,640 --> 00:01:30,909
discussions we have and and I got to

00:01:29,890 --> 00:01:33,430
show you also a bit of performance

00:01:30,909 --> 00:01:35,799
numbers the performance numbers I'm

00:01:33,430 --> 00:01:40,090
going to show you are has been obtained

00:01:35,799 --> 00:01:42,579
through the piggy TEM bench X made more

00:01:40,090 --> 00:01:46,950
negative received that lhang lhang lhang

00:01:42,579 --> 00:01:50,619
name is a script that resides on samples

00:01:46,950 --> 00:01:58,600
Piketty gem folder in the linux kernel

00:01:50,619 --> 00:02:02,049
tree and basically the results they they

00:01:58,600 --> 00:02:05,020
I mean they they are observed from one

00:02:02,049 --> 00:02:06,729
single CPU and we are considering the

00:02:05,020 --> 00:02:12,430
smallest packet size so it's the worst

00:02:06,729 --> 00:02:14,780
case so as I said this is not a tutorial

00:02:12,430 --> 00:02:17,209
so you have the documentation

00:02:14,780 --> 00:02:20,090
and a famous group is replacing the

00:02:17,209 --> 00:02:24,860
existing ipv6 EB tables I repeat tables

00:02:20,090 --> 00:02:28,100
and we have a new release that happened

00:02:24,860 --> 00:02:32,239
just a few weeks ago three weeks ago

00:02:28,100 --> 00:02:35,739
it's an F stable 0.8 it has include 300

00:02:32,239 --> 00:02:41,630
around 300 comments since last time and

00:02:35,739 --> 00:02:45,250
we got 20 20 26 contributors so we have

00:02:41,630 --> 00:02:47,930
double the number we had last time

00:02:45,250 --> 00:02:50,060
well interval in terms of performance or

00:02:47,930 --> 00:02:54,709
dropping packets using the new ingress

00:02:50,060 --> 00:02:58,790
hook it's twice faster this is just

00:02:54,709 --> 00:03:01,040
showing the rule above I mean it's just

00:02:58,790 --> 00:03:04,160
there just to draw packets at the

00:03:01,040 --> 00:03:06,050
protein chain the the table is raw so

00:03:04,160 --> 00:03:07,000
it's quite quite early in the in the IP

00:03:06,050 --> 00:03:10,760
tables

00:03:07,000 --> 00:03:12,500
pipeline and we're getting around 6

00:03:10,760 --> 00:03:18,220
million packets per second but with an X

00:03:12,500 --> 00:03:23,269
tables who get double if we use a a set

00:03:18,220 --> 00:03:25,280
that was including 380 84 the number is

00:03:23,269 --> 00:03:27,019
I mean if we could we could even include

00:03:25,280 --> 00:03:29,209
more the number would be success a

00:03:27,019 --> 00:03:32,209
because basically behind behind that

00:03:29,209 --> 00:03:34,220
rule is is the bitmap said that it's

00:03:32,209 --> 00:03:36,850
being used so it's basically almost

00:03:34,220 --> 00:03:43,450
quite quite close to dropping one single

00:03:36,850 --> 00:03:45,799
one single port is so let's talk about

00:03:43,450 --> 00:03:49,040
the updates and happen on the city

00:03:45,799 --> 00:03:51,350
infrastructure so there were some there

00:03:49,040 --> 00:03:54,680
was some some some changes that went to

00:03:51,350 --> 00:03:58,450
went upstream related to make to make

00:03:54,680 --> 00:04:02,570
any staples go faster in for these set

00:03:58,450 --> 00:04:04,609
implementations that we have so so those

00:04:02,570 --> 00:04:08,269
are not familiar basically in NS tables

00:04:04,609 --> 00:04:12,290
we the the from user space what we

00:04:08,269 --> 00:04:14,299
provide is a description of of the of

00:04:12,290 --> 00:04:16,669
the set and specifically that we select

00:04:14,299 --> 00:04:20,150
we allow the user to select what what

00:04:16,669 --> 00:04:22,100
back end wants to use not but but we

00:04:20,150 --> 00:04:24,470
instead with the user needs to provide

00:04:22,100 --> 00:04:27,080
the number of elements are going out is

00:04:24,470 --> 00:04:28,520
going to to

00:04:27,080 --> 00:04:31,400
they said it's this is of course

00:04:28,520 --> 00:04:33,080
optional right but if this information

00:04:31,400 --> 00:04:34,220
if these indications have passed is the

00:04:33,080 --> 00:04:36,530
kernel that kind of can make a better

00:04:34,220 --> 00:04:39,139
decision because it's it's the current

00:04:36,530 --> 00:04:41,210
that is deciding what set back in is

00:04:39,139 --> 00:04:42,800
going to be used so it's not that we

00:04:41,210 --> 00:04:45,710
allow the user to say I want a hash

00:04:42,800 --> 00:04:47,750
table is it's more like you just

00:04:45,710 --> 00:04:50,210
describe what you want and the kernel

00:04:47,750 --> 00:04:53,419
has a routine to select what what is the

00:04:50,210 --> 00:04:55,610
best web backend for you and that to

00:04:53,419 --> 00:04:57,020
policies performance a memory the

00:04:55,610 --> 00:05:00,650
painting all the trade-offs you select

00:04:57,020 --> 00:05:05,030
it's going to also to change the set

00:05:00,650 --> 00:05:06,830
they set back in and all that happens

00:05:05,030 --> 00:05:09,259
because we have a big o-notation is

00:05:06,830 --> 00:05:12,319
basically an enum an enumeration it's

00:05:09,259 --> 00:05:13,699
attack that allows us to to classify the

00:05:12,319 --> 00:05:16,460
different the different set back in

00:05:13,699 --> 00:05:18,710
implementations that we have more

00:05:16,460 --> 00:05:22,310
descriptions that are available are the

00:05:18,710 --> 00:05:27,020
key lengths and just in case that we

00:05:22,310 --> 00:05:28,279
want intervals this is also important to

00:05:27,020 --> 00:05:30,229
make the selection

00:05:28,279 --> 00:05:32,509
they set back in implementations that we

00:05:30,229 --> 00:05:34,279
have basically three at this moment it's

00:05:32,509 --> 00:05:36,620
the hash table there are two variants

00:05:34,279 --> 00:05:39,259
fixed the hash table and a resizable

00:05:36,620 --> 00:05:44,479
hash table there is a bitmap that

00:05:39,259 --> 00:05:49,370
supports up to 16 16-bit keys at this

00:05:44,479 --> 00:05:50,599
moment and it's going to be always like

00:05:49,370 --> 00:05:52,610
that it otherwise thinks we're going to

00:05:50,599 --> 00:05:54,889
consume too much memory but wicked

00:05:52,610 --> 00:05:57,560
wicked also we are also planning to

00:05:54,889 --> 00:06:00,830
support ranges so sort of wicked wicked

00:05:57,560 --> 00:06:03,770
is a bitmap again to just to to build a

00:06:00,830 --> 00:06:06,589
small bitmap for some IP range for

00:06:03,770 --> 00:06:09,139
example indicating the both sides of the

00:06:06,589 --> 00:06:12,430
of the interval right so and then we

00:06:09,139 --> 00:06:16,789
have the the red black tree just for

00:06:12,430 --> 00:06:19,810
interrupts perfect size and so on so

00:06:16,789 --> 00:06:22,400
evaluating performance of the hash table

00:06:19,810 --> 00:06:25,789
just considering one single rule with a

00:06:22,400 --> 00:06:30,229
constant constant set so by constants

00:06:25,789 --> 00:06:32,360
and i i'm i'm referring to set that we

00:06:30,229 --> 00:06:34,430
assume that the number of elements are

00:06:32,360 --> 00:06:36,770
not going to change so with the

00:06:34,430 --> 00:06:39,380
resizable implementation we are getting

00:06:36,770 --> 00:06:40,409
11 million packets per second this is

00:06:39,380 --> 00:06:42,989
again

00:06:40,409 --> 00:06:45,179
packets had at ingress right so if we

00:06:42,989 --> 00:06:47,879
have fixed at the hash table where it's

00:06:45,179 --> 00:06:50,069
just it was just 150 more lines of code

00:06:47,879 --> 00:06:52,739
so it was not much was simply

00:06:50,069 --> 00:06:59,659
misrepresentation of our fixed size hash

00:06:52,739 --> 00:07:02,279
table and basically what we got with a

00:06:59,659 --> 00:07:03,749
constant set that looks like that it

00:07:02,279 --> 00:07:08,599
this is basically that command there

00:07:03,749 --> 00:07:12,419
it's allowing us to add an element to

00:07:08,599 --> 00:07:16,619
table X and set Y with these three

00:07:12,419 --> 00:07:20,099
elements so basically the user indicates

00:07:16,619 --> 00:07:22,379
the size either explicitly or implicitly

00:07:20,099 --> 00:07:24,539
if it's implicitly it's just by

00:07:22,379 --> 00:07:26,579
providing the number of elements and if

00:07:24,539 --> 00:07:28,709
it's explicitly it's going to happen by

00:07:26,579 --> 00:07:31,439
by using the size statement inside

00:07:28,709 --> 00:07:35,099
inside the set definition you see that

00:07:31,439 --> 00:07:37,949
rule that says NFT at set X Y and then

00:07:35,099 --> 00:07:39,899
type so this is specifying the data type

00:07:37,949 --> 00:07:42,479
of elements are going to be a stored in

00:07:39,899 --> 00:07:43,979
that set and then the size is is

00:07:42,479 --> 00:07:46,139
explicitly telling the kernel that this

00:07:43,979 --> 00:07:49,919
set is not going to have more than 128

00:07:46,139 --> 00:07:51,599
elements so all those indications as I

00:07:49,919 --> 00:07:53,279
said are useful to the kernel in that

00:07:51,599 --> 00:07:56,789
case is going to select the fixed size

00:07:53,279 --> 00:07:59,339
of table so and then inside the kernel

00:07:56,789 --> 00:08:02,099
we have two different two different

00:07:59,339 --> 00:08:05,219
lookup functions there are two optimized

00:08:02,099 --> 00:08:07,769
for 64-bit and 32-bit keys that is a

00:08:05,219 --> 00:08:10,979
slightly faster than the one that is for

00:08:07,769 --> 00:08:13,649
keys that are larger than 32-bit key the

00:08:10,979 --> 00:08:15,449
the one the larger the 32-bit keys

00:08:13,649 --> 00:08:18,179
basically is in man compare so that's

00:08:15,449 --> 00:08:22,189
what that says reason why the 16 other

00:08:18,179 --> 00:08:24,749
to be key is faster so we kind of have

00:08:22,189 --> 00:08:26,729
variant of the of the low-cut of the

00:08:24,749 --> 00:08:29,279
local fractions to perform to the phone

00:08:26,729 --> 00:08:35,039
to search for the element that we want

00:08:29,279 --> 00:08:37,919
to find in this intercept the bitmap the

00:08:35,039 --> 00:08:41,729
bitmap keeps a list of 16 dummy objects

00:08:37,919 --> 00:08:43,199
this dummy objects are dead to store

00:08:41,729 --> 00:08:45,660
comments and in the future to support

00:08:43,199 --> 00:08:47,939
timeouts to time at all another feature

00:08:45,660 --> 00:08:51,520
that is available in the city

00:08:47,939 --> 00:08:54,700
infrastructure basically it allows us to

00:08:51,520 --> 00:08:57,550
elements expires so you can populate a

00:08:54,700 --> 00:08:59,830
set with elements runtime and then at

00:08:57,550 --> 00:09:02,529
some point we see no packets hitting

00:08:59,830 --> 00:09:04,990
that element it's going to just going to

00:09:02,529 --> 00:09:07,420
release the the the element from the set

00:09:04,990 --> 00:09:09,580
it's not so this time our feature is not

00:09:07,420 --> 00:09:11,290
available in the set in the bitmap but

00:09:09,580 --> 00:09:13,660
it should be possible by using this

00:09:11,290 --> 00:09:16,180
dummy little objects this tabulated list

00:09:13,660 --> 00:09:18,279
of objects is there because I mean a

00:09:16,180 --> 00:09:20,770
bitmap the elements are compressed right

00:09:18,279 --> 00:09:22,779
so but to store we can we can place

00:09:20,770 --> 00:09:24,880
comments on every element or we can have

00:09:22,779 --> 00:09:26,140
this time out so in that case we cannot

00:09:24,880 --> 00:09:28,360
store that in a compressed

00:09:26,140 --> 00:09:30,580
representation right so that's why we

00:09:28,360 --> 00:09:33,339
have a list of this dummy odd objects

00:09:30,580 --> 00:09:35,649
that are going to store these extra mate

00:09:33,339 --> 00:09:37,110
information state information that we

00:09:35,649 --> 00:09:44,140
cannot store in the compress mode right

00:09:37,110 --> 00:09:45,760
so so this list is obviously no use from

00:09:44,140 --> 00:09:48,000
the packet path from the packet path we

00:09:45,760 --> 00:09:51,250
look up for matchings using the bitmap

00:09:48,000 --> 00:09:54,670
so this is all the useful from when when

00:09:51,250 --> 00:10:00,610
dumping back to user space the elements

00:09:54,670 --> 00:10:03,459
are so in the set and and what we didn't

00:10:00,610 --> 00:10:06,250
the performance number are quite good a

00:10:03,459 --> 00:10:07,930
better than hash table and and the red

00:10:06,250 --> 00:10:11,500
black tree that I'm going to show you in

00:10:07,930 --> 00:10:16,630
the next slide so it's 16 million

00:10:11,500 --> 00:10:19,029
packets per second is quite good and as

00:10:16,630 --> 00:10:23,310
I said we can only select this bitmap in

00:10:19,029 --> 00:10:23,310
case that keys are smaller than 16 bits

00:10:26,700 --> 00:10:33,610
the red black tree is an implementation

00:10:29,320 --> 00:10:37,000
that allows us to store ranges ranges

00:10:33,610 --> 00:10:38,800
are quite quite quite useful feature

00:10:37,000 --> 00:10:40,839
there are many people maintaining black

00:10:38,800 --> 00:10:47,440
list or what leads only on the Internet

00:10:40,839 --> 00:10:50,410
these days right so basically it's local

00:10:47,440 --> 00:10:52,930
it's me complexity so with two ranges

00:10:50,410 --> 00:10:55,270
the more ranges we have industry it's

00:10:52,930 --> 00:11:00,579
going to it's going to slightly go down

00:10:55,270 --> 00:11:02,620
in performance its anyway it's it's it

00:11:00,579 --> 00:11:05,760
now it is now lot less there was a

00:11:02,620 --> 00:11:05,760
central spin lock

00:11:06,230 --> 00:11:13,950
that we now removed using david hallwas

00:11:11,370 --> 00:11:15,540
idea for our way up our PC it's

00:11:13,950 --> 00:11:16,980
basically something that if doom SM

00:11:15,540 --> 00:11:18,930
mentioned it under during them in last

00:11:16,980 --> 00:11:20,820
night's little workshop basically we

00:11:18,930 --> 00:11:25,200
have a fast path where we can perform

00:11:20,820 --> 00:11:27,660
bloodless search on the rb3 but if there

00:11:25,200 --> 00:11:31,940
is any operation to update there are

00:11:27,660 --> 00:11:34,680
between going on then then we we just

00:11:31,940 --> 00:11:38,400
basically with we can see that that is

00:11:34,680 --> 00:11:40,530
going on through SEC lock and then we

00:11:38,400 --> 00:11:42,480
fall back to this low path so it's it's

00:11:40,530 --> 00:11:44,730
very rare that we are going to enter

00:11:42,480 --> 00:11:45,960
this low path and we relay on keep

00:11:44,730 --> 00:11:51,270
relying on this red black tree

00:11:45,960 --> 00:11:54,000
implementation so those are basically

00:11:51,270 --> 00:11:57,270
the three set back interpretation that

00:11:54,000 --> 00:11:59,370
we have at this stage that we've been

00:11:57,270 --> 00:12:06,120
lately optimizing to achieve better

00:11:59,370 --> 00:12:10,800
numbers in terms of features the onion

00:12:06,120 --> 00:12:12,540
features available in an F tables now

00:12:10,800 --> 00:12:14,460
it's possible to use the fib expression

00:12:12,540 --> 00:12:17,100
for those that are familiar with this

00:12:14,460 --> 00:12:22,230
new expression this basically allows us

00:12:17,100 --> 00:12:25,020
to inquire the flip engine to with with

00:12:22,230 --> 00:12:27,540
its it's actually very very flexible so

00:12:25,020 --> 00:12:29,160
you have a you have a topple that that

00:12:27,540 --> 00:12:31,560
you can use the different component to

00:12:29,160 --> 00:12:34,650
inquire to fit and and you can specify

00:12:31,560 --> 00:12:37,470
also what kind of result you want to

00:12:34,650 --> 00:12:40,800
fetch from from the tip for example the

00:12:37,470 --> 00:12:43,530
first rule above it's basically based on

00:12:40,800 --> 00:12:46,380
on on a top of compose of the source

00:12:43,530 --> 00:12:50,580
address and the input interface it's

00:12:46,380 --> 00:12:53,070
just asking for if it's asking for the

00:12:50,580 --> 00:12:54,690
output interface if it exists or not the

00:12:53,070 --> 00:12:56,490
missing says there is no output

00:12:54,690 --> 00:12:59,820
interface in that case and greens we are

00:12:56,490 --> 00:13:01,140
going to drop the traffic and then

00:12:59,820 --> 00:13:04,560
they'll build a example is a bit more

00:13:01,140 --> 00:13:06,210
elaborated using a map so taking taking

00:13:04,560 --> 00:13:13,260
the destination and drag on the mark and

00:13:06,210 --> 00:13:16,020
then based on the result of that on the

00:13:13,260 --> 00:13:18,450
type of entry that we get in the fit is

00:13:16,020 --> 00:13:19,830
the black hole probably hit private

00:13:18,450 --> 00:13:24,150
unreachable we are going to perform an

00:13:19,830 --> 00:13:26,070
action on the packet so um the main the

00:13:24,150 --> 00:13:28,500
main work this is work that that florian

00:13:26,070 --> 00:13:30,480
already made but the the new thing here

00:13:28,500 --> 00:13:32,670
is the basically pablo of the moodle

00:13:30,480 --> 00:13:34,800
that has been working under the the

00:13:32,670 --> 00:13:37,260
google Summer of Code program he added

00:13:34,800 --> 00:13:39,630
the support for this at the ingress hook

00:13:37,260 --> 00:13:42,780
so we can now perform the main feature

00:13:39,630 --> 00:13:45,090
for this it's the early river is reverse

00:13:42,780 --> 00:13:46,920
path filtering so we can before earlier

00:13:45,090 --> 00:13:48,840
reverse reverse path seasoning not

00:13:46,920 --> 00:13:50,310
needed to do this in improv routing

00:13:48,840 --> 00:13:52,470
anymore

00:13:50,310 --> 00:13:56,420
and again access all the features that

00:13:52,470 --> 00:13:59,880
this powerful fit expression provides

00:13:56,420 --> 00:14:04,350
also Florian he he's been working on on

00:13:59,880 --> 00:14:08,370
adding the the TCP option matching and

00:14:04,350 --> 00:14:09,930
mangling so so now we can match any any

00:14:08,370 --> 00:14:12,720
TCP option and we can also make on them

00:14:09,930 --> 00:14:15,920
this is specifically useful for the

00:14:12,720 --> 00:14:19,140
maximum segment size mangling

00:14:15,920 --> 00:14:21,000
specifically for DSL or I mean these are

00:14:19,140 --> 00:14:26,880
lines or there are five guidelines also

00:14:21,000 --> 00:14:29,940
calculating using pppoe right and those

00:14:26,880 --> 00:14:34,010
those need to adjust the maximum segment

00:14:29,940 --> 00:14:38,370
size in in TCP traffic not to break so

00:14:34,010 --> 00:14:40,530
we really we allow us to to say a fixed

00:14:38,370 --> 00:14:42,120
value but this is this is the more

00:14:40,530 --> 00:14:45,570
flexible way I mean this is basically

00:14:42,120 --> 00:14:51,420
going to consult the routing the the MSS

00:14:45,570 --> 00:14:53,730
from the route entry in the forwarding

00:14:51,420 --> 00:14:58,080
based and and based on that it's going

00:14:53,730 --> 00:15:03,500
to say the maximum segment size so what

00:14:58,080 --> 00:15:07,230
else now we used to have a limit of 32

00:15:03,500 --> 00:15:10,620
bytes for all objects that we have in

00:15:07,230 --> 00:15:14,550
and tables for tables chains and sets

00:15:10,620 --> 00:15:17,820
and and also for this table objects this

00:15:14,550 --> 00:15:21,900
is no longer like this we have extended

00:15:17,820 --> 00:15:24,660
this to 200 255 the reason why is that

00:15:21,900 --> 00:15:28,440
there are users asking to to map to

00:15:24,660 --> 00:15:30,060
place DNS names in their sets so

00:15:28,440 --> 00:15:31,920
basically the idea is that they have

00:15:30,060 --> 00:15:33,839
some sort of demon

00:15:31,920 --> 00:15:37,889
that is base is just falling for names

00:15:33,839 --> 00:15:41,459
and in populating the sets so this is

00:15:37,889 --> 00:15:43,560
this is our way to so they can just you

00:15:41,459 --> 00:15:45,779
say fill the rule set they can they can

00:15:43,560 --> 00:15:50,070
use names instead or instead all IP

00:15:45,779 --> 00:15:51,750
addresses I would recommend this way

00:15:50,070 --> 00:15:53,040
because we don't want to give the user

00:15:51,750 --> 00:15:55,230
the wrong impression that they can

00:15:53,040 --> 00:15:57,540
actually filter based on names in in IP

00:15:55,230 --> 00:15:59,610
tables it was because this was kind of

00:15:57,540 --> 00:16:02,160
sloppy and it was causing causing quite

00:15:59,610 --> 00:16:04,230
a lot of competition basically uses

00:16:02,160 --> 00:16:07,320
we're relying on this feature and every

00:16:04,230 --> 00:16:09,860
table was expanding a row with a name

00:16:07,320 --> 00:16:12,990
with every IP address we were resolving

00:16:09,860 --> 00:16:16,170
at common and common run time and that

00:16:12,990 --> 00:16:18,420
was not good so so with this approach

00:16:16,170 --> 00:16:20,579
people at least we expect that the users

00:16:18,420 --> 00:16:23,220
are going to be aware of what they do

00:16:20,579 --> 00:16:28,170
invites explicitly defining a set and

00:16:23,220 --> 00:16:30,690
and all this thing so um we now display

00:16:28,170 --> 00:16:32,880
a generation ID and process that has

00:16:30,690 --> 00:16:38,640
modified we've all said we have to come

00:16:32,880 --> 00:16:41,730
in face protocol so basically what it

00:16:38,640 --> 00:16:44,579
happens if we use NFC monitor is that if

00:16:41,730 --> 00:16:46,680
there is a transaction that is coming by

00:16:44,579 --> 00:16:49,649
other process we are going to receive

00:16:46,680 --> 00:16:51,839
the table chain and new rules sets

00:16:49,649 --> 00:16:55,230
whatever objects have has been added and

00:16:51,839 --> 00:16:57,149
then there is a line that indicates the

00:16:55,230 --> 00:17:00,540
new generation that has happen and the

00:16:57,149 --> 00:17:08,579
process the the process ID and the and

00:17:00,540 --> 00:17:11,150
and the name so what does now we are

00:17:08,579 --> 00:17:13,620
support for the limit is a full object

00:17:11,150 --> 00:17:15,569
before before the previous net that we

00:17:13,620 --> 00:17:18,630
only have two times its counters and

00:17:15,569 --> 00:17:20,880
quotas these stateful objects are a very

00:17:18,630 --> 00:17:24,480
very interesting feature basically what

00:17:20,880 --> 00:17:29,730
what this allows you to attach a name to

00:17:24,480 --> 00:17:30,120
a counter quota or limit and you can you

00:17:29,730 --> 00:17:33,780
can just

00:17:30,120 --> 00:17:38,990
atomically dump and reset a given

00:17:33,780 --> 00:17:42,450
counter you can also you can also

00:17:38,990 --> 00:17:45,490
specify a name to a given quota and

00:17:42,450 --> 00:17:48,250
reset it also atomically

00:17:45,490 --> 00:17:49,899
and it emitted a missing feature that we

00:17:48,250 --> 00:17:54,279
would like to have sir needs to update

00:17:49,899 --> 00:17:56,470
those objects by for example without

00:17:54,279 --> 00:17:58,529
without having to reload the ruleset

00:17:56,470 --> 00:18:03,580
basically the idea is that the user

00:17:58,529 --> 00:18:05,980
specify what object wants to update the

00:18:03,580 --> 00:18:08,409
the configuration let's say for example

00:18:05,980 --> 00:18:10,659
I want to rise the great limit for this

00:18:08,409 --> 00:18:12,610
object is without needing to reload the

00:18:10,659 --> 00:18:14,529
Rose rosette is going to be applying a

00:18:12,610 --> 00:18:16,570
different rate limit for that object so

00:18:14,529 --> 00:18:18,760
this is this is missing but it's at

00:18:16,570 --> 00:18:21,130
least in the domain the main pieces are

00:18:18,760 --> 00:18:24,850
now in place upstream so now you can

00:18:21,130 --> 00:18:29,820
just add a limit object this a first

00:18:24,850 --> 00:18:33,760
line is adding a limb one object but

00:18:29,820 --> 00:18:40,020
with that even break limit and the

00:18:33,760 --> 00:18:43,120
second one is another limit is 1040 24

00:18:40,020 --> 00:18:45,720
kilobyte seconds with a burst with also

00:18:43,120 --> 00:18:49,779
and then we can use this objects from

00:18:45,720 --> 00:18:51,220
from rules so you can also the nice

00:18:49,779 --> 00:18:55,960
thing is that you can you can use these

00:18:51,220 --> 00:19:00,309
stateful objects from from maps so the

00:18:55,960 --> 00:19:04,539
rule there it's adding a roll at the

00:19:00,309 --> 00:19:07,539
table filter chain for routing and you

00:19:04,539 --> 00:19:09,640
have limit name and the name is going to

00:19:07,539 --> 00:19:12,309
be selected based on what we look up

00:19:09,640 --> 00:19:13,659
from the map the key to look up for the

00:19:12,309 --> 00:19:16,390
limit that way we're going to apply is

00:19:13,659 --> 00:19:17,919
based on the TCP destination port so in

00:19:16,390 --> 00:19:22,360
case the packet is going to TCP

00:19:17,919 --> 00:19:29,529
destination port 443 so we apply the

00:19:22,360 --> 00:19:31,659
limit limb 1 ok so there's now a dry run

00:19:29,529 --> 00:19:34,179
mode support for this and the Chronos

00:19:31,659 --> 00:19:36,520
has been around for a while was missing

00:19:34,179 --> 00:19:40,330
inanity basically that is a new - -

00:19:36,520 --> 00:19:44,710
check option that you can place in front

00:19:40,330 --> 00:19:52,409
of a rule or also when loading our rule

00:19:44,710 --> 00:19:55,870
set via n ft minus F so the idea is that

00:19:52,409 --> 00:19:58,190
M we push we push the changes we want

00:19:55,870 --> 00:19:59,659
into the kernel so we have a

00:19:58,190 --> 00:20:01,730
enough tables we have two-phase commit

00:19:59,659 --> 00:20:04,009
protocol so we have a preparation phase

00:20:01,730 --> 00:20:05,779
and we have the comment phase right so

00:20:04,009 --> 00:20:08,210
what is going on is that we push the the

00:20:05,779 --> 00:20:09,590
updates to the kernel and the kernel is

00:20:08,210 --> 00:20:11,570
going to do all the preparation phase

00:20:09,590 --> 00:20:14,299
and we don't send a common message to

00:20:11,570 --> 00:20:16,340
the kernel so the kernel if the comment

00:20:14,299 --> 00:20:18,200
message the commit message is miss

00:20:16,340 --> 00:20:21,710
missing it's just basically going to

00:20:18,200 --> 00:20:24,139
rollback so all the changes that we do

00:20:21,710 --> 00:20:26,059
in that rule are going to be done in the

00:20:24,139 --> 00:20:28,789
preparation phase and then when entering

00:20:26,059 --> 00:20:31,490
the commit phase there is no comment

00:20:28,789 --> 00:20:32,029
command so the kernel says okay I have

00:20:31,490 --> 00:20:34,669
to rollback

00:20:32,029 --> 00:20:36,980
so this this is useful in case that you

00:20:34,669 --> 00:20:38,629
want to check if your rules head or your

00:20:36,980 --> 00:20:40,940
incremental update is going to apply to

00:20:38,629 --> 00:20:47,379
what you have without without actually

00:20:40,940 --> 00:20:47,379
performing any any update on him yes

00:20:55,140 --> 00:21:07,120
so you want you want to test if if if

00:20:59,680 --> 00:21:10,090
the rule is there or if yes this is

00:21:07,120 --> 00:21:12,610
testing if this rule would be added I

00:21:10,090 --> 00:21:15,880
mean it's testing if if the table X

00:21:12,610 --> 00:21:17,380
exists if there's chain Y exists and if

00:21:15,880 --> 00:21:20,980
there is any reference to for example

00:21:17,380 --> 00:21:22,600
the PCP chain exist also the UDP a chain

00:21:20,980 --> 00:21:25,810
exists so it's basically validating that

00:21:22,600 --> 00:21:28,690
the rule would apply cleaning today okay

00:21:25,810 --> 00:21:30,610
so same thing for today for the check

00:21:28,690 --> 00:21:34,000
for to to add the element is just going

00:21:30,610 --> 00:21:37,240
to check if if there is a table X that

00:21:34,000 --> 00:21:39,850
exists a a tip a said that's said that

00:21:37,240 --> 00:21:44,620
it says to and if we actually use if we

00:21:39,850 --> 00:21:48,070
use instead of that we use create create

00:21:44,620 --> 00:21:50,800
is the Colonel Bates out if that element

00:21:48,070 --> 00:21:53,650
exists already if you use create instead

00:21:50,800 --> 00:21:54,970
of act right so it's basically having

00:21:53,650 --> 00:21:58,240
the same semantics are we having that

00:21:54,970 --> 00:22:00,250
link so if you specify create and you

00:21:58,240 --> 00:22:01,480
use - manage check and that element see

00:22:00,250 --> 00:22:04,180
it's already you are going to you're

00:22:01,480 --> 00:22:07,750
going to hear a a element already exist

00:22:04,180 --> 00:22:12,250
exist message okay so it's basically

00:22:07,750 --> 00:22:13,930
this allows us just to test okay if the

00:22:12,250 --> 00:22:16,780
rule the rule will apply cleanly there

00:22:13,930 --> 00:22:22,960
is also now like at support from NS

00:22:16,780 --> 00:22:24,970
table scripts the the the NS table

00:22:22,960 --> 00:22:26,520
script support is quite quite in earlier

00:22:24,970 --> 00:22:29,020
state but it's something that we want to

00:22:26,520 --> 00:22:31,060
to develop and in the next slide I'll

00:22:29,020 --> 00:22:34,240
show you we we have more we've been

00:22:31,060 --> 00:22:36,100
discussing more ideas to integrate into

00:22:34,240 --> 00:22:37,540
the scripting capabilities that we have

00:22:36,100 --> 00:22:39,310
but now something that we called

00:22:37,540 --> 00:22:41,170
upstream is a change from it's not

00:22:39,310 --> 00:22:44,560
pristine and it's developer working for

00:22:41,170 --> 00:22:46,750
Intel basically the ideas is he wanted

00:22:44,560 --> 00:22:49,150
to have he wanted to have a white card

00:22:46,750 --> 00:22:51,040
support so now if you just specify our

00:22:49,150 --> 00:22:52,810
card inside a folder is we're just going

00:22:51,040 --> 00:22:55,000
to take all the files in that folder is

00:22:52,810 --> 00:22:58,420
going to be including that in

00:22:55,000 --> 00:23:00,490
alphanumeric order so do you so the user

00:22:58,420 --> 00:23:02,540
gets a deterministic wait to know what

00:23:00,490 --> 00:23:04,760
is going to be loaded and

00:23:02,540 --> 00:23:07,340
what in what order you are going to load

00:23:04,760 --> 00:23:09,620
all the the the policies that you have a

00:23:07,340 --> 00:23:10,850
split in different files right so this

00:23:09,620 --> 00:23:12,320
is quite quite convenient mean it

00:23:10,850 --> 00:23:13,880
speeding your policy any different files

00:23:12,320 --> 00:23:15,860
it is quite convenient because these

00:23:13,880 --> 00:23:18,140
there are things in your rule set that

00:23:15,860 --> 00:23:20,090
sometimes change dynamically in case

00:23:18,140 --> 00:23:23,150
that you keep blacklist or whitelist

00:23:20,090 --> 00:23:24,680
right so you can keep in in files

00:23:23,150 --> 00:23:26,300
part of your rules that are a study that

00:23:24,680 --> 00:23:28,640
I'm going not going to change and then

00:23:26,300 --> 00:23:30,650
all the parts that you want to change

00:23:28,640 --> 00:23:33,380
the card probably the generality

00:23:30,650 --> 00:23:37,420
dynamically but Sandeman right or some

00:23:33,380 --> 00:23:37,420
scripts are just running in a cron job

00:23:38,680 --> 00:23:44,390
so that is now upstream and now we have

00:23:42,530 --> 00:23:47,300
also the eco option the corruption is

00:23:44,390 --> 00:23:53,270
basically exposing the knelling eco flag

00:23:47,300 --> 00:23:56,090
semantics it's it's an option to to

00:23:53,270 --> 00:23:58,010
print to print exactly what the colonel

00:23:56,090 --> 00:24:01,910
has added in specifically this allows us

00:23:58,010 --> 00:24:05,330
to fetch the unique handle every rule

00:24:01,910 --> 00:24:08,870
comes with a unique handle number this

00:24:05,330 --> 00:24:10,430
unique handle number is useful to make

00:24:08,870 --> 00:24:12,830
sure that we are referring to the same

00:24:10,430 --> 00:24:14,780
rule a long time because you know robots

00:24:12,830 --> 00:24:16,970
they can be adding or deleting rules and

00:24:14,780 --> 00:24:18,200
if you want to make sure that the rule

00:24:16,970 --> 00:24:20,900
that you're consulting is exactly the

00:24:18,200 --> 00:24:23,150
same and not not another version of the

00:24:20,900 --> 00:24:25,940
rule that just was interesting was added

00:24:23,150 --> 00:24:27,800
later on you can just check this handle

00:24:25,940 --> 00:24:31,600
number with that we don't have handle

00:24:27,800 --> 00:24:33,710
numbers for tables chains and set so far

00:24:31,600 --> 00:24:36,050
but we are planning for that too

00:24:33,710 --> 00:24:36,980
so so this eco flag is basically when

00:24:36,050 --> 00:24:38,690
you add the command

00:24:36,980 --> 00:24:43,910
it's just printing the handle number

00:24:38,690 --> 00:24:49,220
that we that we that we got from the

00:24:43,910 --> 00:24:51,170
colonel during the narrative workshop

00:24:49,220 --> 00:24:53,570
we've been talking about sperm trimming

00:24:51,170 --> 00:24:56,390
is you know if you know this project

00:24:53,570 --> 00:25:00,320
that it's it's it's good to have a look

00:24:56,390 --> 00:25:03,350
at it frame is around since 2001 if you

00:25:00,320 --> 00:25:05,360
I mean it's quite easy to to realize

00:25:03,350 --> 00:25:09,050
that firm has been NF stable has been

00:25:05,360 --> 00:25:10,580
quite inspired by by by FEM right so

00:25:09,050 --> 00:25:12,410
it's there are many things in firm that

00:25:10,580 --> 00:25:15,740
that looks very similar in ft and n if

00:25:12,410 --> 00:25:16,250
he came later on so but the thing is up

00:25:15,740 --> 00:25:20,990
firmly

00:25:16,250 --> 00:25:24,290
what was made in Perl and it's it's it's

00:25:20,990 --> 00:25:27,200
actually using IP tables and in generate

00:25:24,290 --> 00:25:30,140
the rule so it's it's it's a translation

00:25:27,200 --> 00:25:33,320
layer basically it has its own syntax

00:25:30,140 --> 00:25:34,700
and the the syntax you have in infirm is

00:25:33,320 --> 00:25:37,610
going to be expanded into IP tables

00:25:34,700 --> 00:25:40,160
comments so firm comes with with set su

00:25:37,610 --> 00:25:43,040
board but those four for each element is

00:25:40,160 --> 00:25:44,870
going to expand its bound one rule so

00:25:43,040 --> 00:25:46,550
the bad thing about them is that the

00:25:44,870 --> 00:25:48,830
user is not quite aware of the number of

00:25:46,550 --> 00:25:52,310
rules that that you are placing in your

00:25:48,830 --> 00:25:54,440
rule set but some people like it because

00:25:52,310 --> 00:25:56,030
it's it's reducing the complexity that

00:25:54,440 --> 00:25:59,570
you have to deal with when maintaining

00:25:56,030 --> 00:26:02,120
it and iptables rule set frame also come

00:25:59,570 --> 00:26:05,930
with with features that are available in

00:26:02,120 --> 00:26:07,600
NFC was like inclusion of files and it

00:26:05,930 --> 00:26:09,710
comes with quite a lot of advanced

00:26:07,600 --> 00:26:11,300
scripting capabilities that we would

00:26:09,710 --> 00:26:13,820
like to have this is not yet available

00:26:11,300 --> 00:26:15,320
in NXT but it's something that we would

00:26:13,820 --> 00:26:18,410
like to have at some point this is the

00:26:15,320 --> 00:26:22,310
main features that we consider useful in

00:26:18,410 --> 00:26:24,560
the netfilter workshop so one of them is

00:26:22,310 --> 00:26:29,300
to allow - we have intent of tables we

00:26:24,560 --> 00:26:32,000
have support to define variables we

00:26:29,300 --> 00:26:33,770
would like to have support to to define

00:26:32,000 --> 00:26:35,870
this vibraphone from the command line so

00:26:33,770 --> 00:26:39,350
we would need to have something like NFC

00:26:35,870 --> 00:26:41,780
- - death and then you specify your

00:26:39,350 --> 00:26:44,210
variable name and your value so in case

00:26:41,780 --> 00:26:46,820
you have a variable in your rule set

00:26:44,210 --> 00:26:48,590
it's not that you have to define inside

00:26:46,820 --> 00:26:50,780
the file the value of that rule set we

00:26:48,590 --> 00:26:56,150
can do it from from the command line

00:26:50,780 --> 00:27:03,160
right another feature that is quite

00:26:56,150 --> 00:27:06,530
useful is this interactive mode the

00:27:03,160 --> 00:27:10,910
frame has its basically allowing us to

00:27:06,530 --> 00:27:12,620
test if a rule set is not locking you

00:27:10,910 --> 00:27:14,750
out from the system it's very useful for

00:27:12,620 --> 00:27:18,050
system administrator devops basically

00:27:14,750 --> 00:27:22,550
that are updating a rule set remotely

00:27:18,050 --> 00:27:24,560
and the want to make sure that that rule

00:27:22,550 --> 00:27:27,710
set is not locking you out right so it's

00:27:24,560 --> 00:27:29,500
basically just printing a question like

00:27:27,710 --> 00:27:33,250
would you like to apply the rule set

00:27:29,500 --> 00:27:36,190
after after just typing in firm - -

00:27:33,250 --> 00:27:38,679
interactive and you can specify a time

00:27:36,190 --> 00:27:42,039
out if you say yes then it applies the

00:27:38,679 --> 00:27:43,690
rule said otherwise if you don't say yes

00:27:42,039 --> 00:27:47,650
it's just going to roll back and take

00:27:43,690 --> 00:27:51,250
you to the previous situation so in case

00:27:47,650 --> 00:27:53,200
that you are on a SSH session you are

00:27:51,250 --> 00:27:55,299
going to recover control on the system

00:27:53,200 --> 00:27:56,500
right quite useful so this is something

00:27:55,299 --> 00:28:01,840
that we would like to have the external

00:27:56,500 --> 00:28:05,200
command even vacations or so frame comes

00:28:01,840 --> 00:28:09,460
with with this back takes thing is

00:28:05,200 --> 00:28:11,559
basically you can invoke commands for

00:28:09,460 --> 00:28:14,260
example in case you have a variable to

00:28:11,559 --> 00:28:16,240
set DNS servers IP address and you want

00:28:14,260 --> 00:28:18,250
to extract that from EDC resource or

00:28:16,240 --> 00:28:20,320
calm so you can just involve that

00:28:18,250 --> 00:28:21,730
command and then place that value into

00:28:20,320 --> 00:28:27,429
the firewall and then use it from the

00:28:21,730 --> 00:28:30,940
rule there has been quite quite a bit of

00:28:27,429 --> 00:28:35,130
work that has been done on to provide a

00:28:30,940 --> 00:28:37,690
high level library the leap NS tables

00:28:35,130 --> 00:28:43,090
there is initial support for a simple

00:28:37,690 --> 00:28:45,940
API this simple API basically allows us

00:28:43,090 --> 00:28:48,789
to what you have to do is just created a

00:28:45,940 --> 00:28:53,230
context object that is basically keeping

00:28:48,789 --> 00:28:55,659
all the states behind the scanner parser

00:28:53,230 --> 00:28:57,909
and evaluate evolution steps and finally

00:28:55,659 --> 00:29:01,090
pushing the command to do to the kernel

00:28:57,909 --> 00:29:02,940
and so it's basically keeping behind the

00:29:01,090 --> 00:29:06,010
curtain in all these states this this

00:29:02,940 --> 00:29:08,559
contract this country gives the context

00:29:06,010 --> 00:29:12,490
object and then there is a very simple

00:29:08,559 --> 00:29:14,409
command NFT run command from buffer you

00:29:12,490 --> 00:29:16,780
just Pat the contacts and you pass the

00:29:14,409 --> 00:29:20,200
string and the size of that string and

00:29:16,780 --> 00:29:23,740
you get a result of the command we we

00:29:20,200 --> 00:29:25,570
plan to support also batching so we've

00:29:23,740 --> 00:29:27,580
been discussing and batching API so the

00:29:25,570 --> 00:29:30,460
idea is that you keep adding new

00:29:27,580 --> 00:29:33,130
commands to a batch and now your Bash is

00:29:30,460 --> 00:29:34,539
ready you just call an F T run batch and

00:29:33,130 --> 00:29:38,440
it's going to push that back into the

00:29:34,539 --> 00:29:40,990
kernel so the idea is that for this

00:29:38,440 --> 00:29:41,720
high-level API that the user expressed

00:29:40,990 --> 00:29:44,480
things in

00:29:41,720 --> 00:29:46,880
the in the NFC syntax and this API just

00:29:44,480 --> 00:29:51,650
allows you to to push commands into the

00:29:46,880 --> 00:29:53,360
kernel there are quite a quite a bit of

00:29:51,650 --> 00:29:56,690
things to be done to provide a mode of

00:29:53,360 --> 00:29:59,180
advanced api and to have full control of

00:29:56,690 --> 00:30:01,640
nailing aiya this is this more for more

00:29:59,180 --> 00:30:03,740
advanced users so we would like to have

00:30:01,640 --> 00:30:07,610
is that is that the library provides

00:30:03,740 --> 00:30:11,360
very very simple API for those are don't

00:30:07,610 --> 00:30:15,080
know anything about net link details or

00:30:11,360 --> 00:30:16,790
kind of details and at the same time we

00:30:15,080 --> 00:30:18,860
would like to also provide an API that

00:30:16,790 --> 00:30:20,420
is quite flexible and quite powerful and

00:30:18,860 --> 00:30:23,060
allows you to do very advanced feature

00:30:20,420 --> 00:30:27,170
so those that don't want to know much

00:30:23,060 --> 00:30:29,720
about implementations details about any

00:30:27,170 --> 00:30:31,820
tables they can just integrate a

00:30:29,720 --> 00:30:35,450
third-party application to add new rules

00:30:31,820 --> 00:30:37,010
into the kernel and there you go so we

00:30:35,450 --> 00:30:39,920
are also planning for our more advanced

00:30:37,010 --> 00:30:41,930
API and you get new soon this API is

00:30:39,920 --> 00:30:44,270
still not exposed so there are all the

00:30:41,930 --> 00:30:48,080
changes that have happened in this are

00:30:44,270 --> 00:30:52,730
in the tree but we just need to expose

00:30:48,080 --> 00:30:56,770
the API that is a pretty small patch so

00:30:52,730 --> 00:31:00,020
we will have soon some example file and

00:30:56,770 --> 00:31:01,820
this will be this will be available in

00:31:00,020 --> 00:31:04,670
the next and if the version basically

00:31:01,820 --> 00:31:11,420
this is live and if tables high-level

00:31:04,670 --> 00:31:13,330
library what is on the contract side

00:31:11,420 --> 00:31:18,830
that's being quite a bit of updates from

00:31:13,330 --> 00:31:22,190
by florian so basically is peeling up

00:31:18,830 --> 00:31:26,150
net namespace removal by selected cost

00:31:22,190 --> 00:31:28,310
to synchronize and net many of these

00:31:26,150 --> 00:31:30,230
calls has been happening one after

00:31:28,310 --> 00:31:33,050
another every time that we were we were

00:31:30,230 --> 00:31:36,050
removing a namespace so now this is bad

00:31:33,050 --> 00:31:38,870
and we just call once and this is a

00:31:36,050 --> 00:31:40,820
speed and removal well as this

00:31:38,870 --> 00:31:41,870
connection the connection dragon

00:31:40,820 --> 00:31:45,110
extension infrastructure have been

00:31:41,870 --> 00:31:48,560
simplified so we have basically the main

00:31:45,110 --> 00:31:51,990
NS t NS contract object and kong object

00:31:48,560 --> 00:31:55,050
and this object was containing

00:31:51,990 --> 00:31:57,390
filters are accessed all the time and

00:31:55,050 --> 00:31:59,340
there were extensions that were actually

00:31:57,390 --> 00:32:02,220
accessed almost all the time that were

00:31:59,340 --> 00:32:04,020
plays out of the main memory the main

00:32:02,220 --> 00:32:08,850
area where we represent the contract

00:32:04,020 --> 00:32:10,410
object so the this was slow and in terms

00:32:08,850 --> 00:32:12,210
of locality it will not explode in

00:32:10,410 --> 00:32:15,360
localities quite good and also another

00:32:12,210 --> 00:32:17,100
problem is that we were also in the

00:32:15,360 --> 00:32:20,220
initial fax we were spending quite a bit

00:32:17,100 --> 00:32:24,570
of cycles calculating the extension area

00:32:20,220 --> 00:32:27,150
so it's so we are just basically

00:32:24,570 --> 00:32:29,550
recovering the balance so we kind of

00:32:27,150 --> 00:32:31,380
overdue a bit with abstractions and now

00:32:29,550 --> 00:32:33,120
we are running back a bit just to it's

00:32:31,380 --> 00:32:35,100
not that we remove we got this

00:32:33,120 --> 00:32:37,250
infrastructure remove the extensions are

00:32:35,100 --> 00:32:39,530
still there but now I'm the NF con

00:32:37,250 --> 00:32:42,929
object we have the fills that are

00:32:39,530 --> 00:32:46,860
usually that are useful for most users

00:32:42,929 --> 00:32:50,880
all the time and then the things that

00:32:46,860 --> 00:32:53,370
are are are still kept in in rar or slow

00:32:50,880 --> 00:32:56,610
path or filtered in the extension

00:32:53,370 --> 00:32:58,679
infrastructure for example all the the

00:32:56,610 --> 00:33:02,190
helper the connection tracking helper

00:32:58,679 --> 00:33:03,929
infrastructure all those alg right they

00:33:02,190 --> 00:33:06,000
are considered to be a slow path they

00:33:03,929 --> 00:33:07,650
are parsing the strings and so on so we

00:33:06,000 --> 00:33:12,090
keep all that in the in the connection

00:33:07,650 --> 00:33:15,420
tracking extension each researcher so he

00:33:12,090 --> 00:33:16,980
also reduces the memory footprint by by

00:33:15,420 --> 00:33:19,559
using a smaller a write all over the

00:33:16,980 --> 00:33:23,010
place now the contract object is a main

00:33:19,559 --> 00:33:25,980
change that is that contract hooks are

00:33:23,010 --> 00:33:27,600
released once we explicitly we provide

00:33:25,980 --> 00:33:30,210
an indication that we are going to use

00:33:27,600 --> 00:33:32,429
the states that are available in in

00:33:30,210 --> 00:33:36,600
contract so if you have a if you had a

00:33:32,429 --> 00:33:41,429
role with mine with - a mistake then the

00:33:36,600 --> 00:33:45,740
contract hooks are registered and this

00:33:41,429 --> 00:33:48,780
is basically just to save save cycles on

00:33:45,740 --> 00:33:50,490
this was specifically a problem with net

00:33:48,780 --> 00:33:52,620
namespaces because we mean you have lots

00:33:50,490 --> 00:33:56,160
of them contract if only one method

00:33:52,620 --> 00:33:58,020
spinning in space was registering was

00:33:56,160 --> 00:34:00,740
needing contract it was reasonable for

00:33:58,020 --> 00:34:04,570
them all then we move to a situation

00:34:00,740 --> 00:34:09,069
where we have a pair net namespace

00:34:04,570 --> 00:34:10,960
oops but but again if only one of them

00:34:09,069 --> 00:34:13,839
needs contract was getting released for

00:34:10,960 --> 00:34:16,929
all of them and now we basically only

00:34:13,839 --> 00:34:19,810
register them if you explicitly need it

00:34:16,929 --> 00:34:23,230
so it's it's the best the best approach

00:34:19,810 --> 00:34:28,300
that that we have now our scene right in

00:34:23,230 --> 00:34:30,669
terms of performance there is now a new

00:34:28,300 --> 00:34:32,679
approach to get rid of an assert flaws

00:34:30,669 --> 00:34:35,109
for this is EPS CTP and TCP flows

00:34:32,679 --> 00:34:38,859
basically contract was when it is under

00:34:35,109 --> 00:34:40,300
stress meaning that although these lots

00:34:38,859 --> 00:34:42,490
that we have in the table is getting

00:34:40,300 --> 00:34:45,129
full so there is a garbage collectors

00:34:42,490 --> 00:34:47,409
threader is going or going it's it's

00:34:45,129 --> 00:34:49,510
spinning over the table searching for

00:34:47,409 --> 00:34:52,540
flaws that are not assert basically that

00:34:49,510 --> 00:34:54,909
are not we the flow has not been fully

00:34:52,540 --> 00:34:57,250
established right and we are getting rid

00:34:54,909 --> 00:35:01,569
of them so that those are the candidates

00:34:57,250 --> 00:35:04,390
in trial in in case of stress situation

00:35:01,569 --> 00:35:06,940
we have no more fake contract object

00:35:04,390 --> 00:35:09,790
anymore for no tracking for greater

00:35:06,940 --> 00:35:11,800
cache efficiency and also there has been

00:35:09,790 --> 00:35:15,339
a quite a bit of box that has been

00:35:11,800 --> 00:35:16,869
solved by leading sank in terms of hash

00:35:15,339 --> 00:35:19,780
table resizing we have a routine of

00:35:16,869 --> 00:35:24,640
allows us to resize the connection

00:35:19,780 --> 00:35:27,550
tracking table runtime and and now those

00:35:24,640 --> 00:35:32,500
are fixed so something else I wanted to

00:35:27,550 --> 00:35:35,200
talk about in the net in in this

00:35:32,500 --> 00:35:38,079
workshop as the the flow of lot

00:35:35,200 --> 00:35:42,940
infrastructure there is a path set that

00:35:38,079 --> 00:35:46,690
I sent previous week basically the idea

00:35:42,940 --> 00:35:49,000
is to add a generic software flow table

00:35:46,690 --> 00:35:51,970
representation this flow table

00:35:49,000 --> 00:35:56,829
representation is going to hook in an

00:35:51,970 --> 00:35:58,839
effort to honk ingress and the idea is

00:35:56,829 --> 00:36:02,200
that for each packet of that hits the

00:35:58,839 --> 00:36:03,730
the if the software flow table we are

00:36:02,200 --> 00:36:07,180
going to check if there is an entry if

00:36:03,730 --> 00:36:09,280
there is an entry then we know what is

00:36:07,180 --> 00:36:12,010
the port where we should just forward

00:36:09,280 --> 00:36:15,790
the packet otherwise we just follow the

00:36:12,010 --> 00:36:17,349
classic rewarding path so if we have a

00:36:15,790 --> 00:36:17,940
head we're going to apply them in the

00:36:17,349 --> 00:36:19,440
madman

00:36:17,940 --> 00:36:21,990
if there is any we are going to

00:36:19,440 --> 00:36:24,240
decrement the TTL and just send it to

00:36:21,990 --> 00:36:28,109
the to the right board using they need

00:36:24,240 --> 00:36:30,119
lyrics me so we have a lazy approach to

00:36:28,109 --> 00:36:32,250
crucify it flows basically there is this

00:36:30,119 --> 00:36:34,200
this is more stateless si this thing so

00:36:32,250 --> 00:36:36,089
we have a timeout for all the entries

00:36:34,200 --> 00:36:37,859
that that time I'll timeout is going to

00:36:36,089 --> 00:36:41,520
be the same for all the entries and we

00:36:37,859 --> 00:36:43,049
if we see no more practical hitting

00:36:41,520 --> 00:36:48,210
hitting that entering the flow table

00:36:43,049 --> 00:36:49,410
it's going to let it expire so what what

00:36:48,210 --> 00:36:51,930
do you have to do if you want to use

00:36:49,410 --> 00:36:53,940
this new feature it's it's something

00:36:51,930 --> 00:36:56,520
that is configurable so it's a user that

00:36:53,940 --> 00:36:58,500
has to explicitly request this I've been

00:36:56,520 --> 00:37:02,400
observing for a while patches to do this

00:36:58,500 --> 00:37:04,890
transparently for some small router

00:37:02,400 --> 00:37:08,460
vendors it were patches that were

00:37:04,890 --> 00:37:10,319
applying to open wrt and it was in my

00:37:08,460 --> 00:37:12,089
opinion was not it was not right because

00:37:10,319 --> 00:37:14,400
it was it's something that is going to

00:37:12,089 --> 00:37:19,109
confuse confuse because it's changing

00:37:14,400 --> 00:37:21,450
semantics in a way that that it's just

00:37:19,109 --> 00:37:23,640
going to get user confused really so

00:37:21,450 --> 00:37:26,670
it's it's not going to work the way the

00:37:23,640 --> 00:37:29,160
users are I used to so so now this is

00:37:26,670 --> 00:37:30,420
this is this would be this will be

00:37:29,160 --> 00:37:33,180
configurable it's something that you

00:37:30,420 --> 00:37:37,500
have to specify in a rule so in case

00:37:33,180 --> 00:37:40,049
that you want to place TCP flows into

00:37:37,500 --> 00:37:43,289
that in that software flow table you had

00:37:40,049 --> 00:37:45,539
a rule that says IP protocol TCP that is

00:37:43,289 --> 00:37:47,760
going to be offload okay and that

00:37:45,539 --> 00:37:50,339
counter is basically just to check for

00:37:47,760 --> 00:37:52,410
how many how many flows are being hit by

00:37:50,339 --> 00:37:58,849
this rule are being offload to the flow

00:37:52,410 --> 00:38:02,190
table so when when when having a look at

00:37:58,849 --> 00:38:04,500
what we find in in the contract table we

00:38:02,190 --> 00:38:07,109
are going to have a new status bed this

00:38:04,500 --> 00:38:08,910
offload tag that is going to say that

00:38:07,109 --> 00:38:14,099
this flow has been a flow has been

00:38:08,910 --> 00:38:15,990
placed into into the flow table and when

00:38:14,099 --> 00:38:18,000
benchmarking this software flow table

00:38:15,990 --> 00:38:25,619
representation it's around three times

00:38:18,000 --> 00:38:27,089
faster basically using again the the

00:38:25,619 --> 00:38:29,750
same script that I mentioned before

00:38:27,089 --> 00:38:33,980
duplicating in bench ex-maid mode

00:38:29,750 --> 00:38:38,300
and exercising the if awarding path is a

00:38:33,980 --> 00:38:42,800
dummy device we were getting as I said

00:38:38,300 --> 00:38:45,800
three times more it's from 11.4 in 1.8

00:38:42,800 --> 00:38:50,450
million packets per second to fine point

00:38:45,800 --> 00:38:53,840
one so basically all this is just

00:38:50,450 --> 00:38:56,270
because we are skipping lookups for the

00:38:53,840 --> 00:38:58,609
flows and we excuse of lots of things

00:38:56,270 --> 00:39:01,190
that are basically happening in the in

00:38:58,609 --> 00:39:02,780
the standard forwarding path right so so

00:39:01,190 --> 00:39:06,770
only the initial packets at establish

00:39:02,780 --> 00:39:10,310
the the flow or are those are going to

00:39:06,770 --> 00:39:12,830
be following the classic warning back so

00:39:10,310 --> 00:39:15,130
and all these matches well with with

00:39:12,830 --> 00:39:17,390
what we have in in switches and Knicks

00:39:15,130 --> 00:39:20,480
so the many of them they come they come

00:39:17,390 --> 00:39:22,280
with built-in flow tables and as I said

00:39:20,480 --> 00:39:27,340
I've been observing patches out of tree

00:39:22,280 --> 00:39:29,900
to support this so what we could do is

00:39:27,340 --> 00:39:32,270
this this have a flow table needs to be

00:39:29,900 --> 00:39:35,240
configure apart from music Scott use a

00:39:32,270 --> 00:39:38,599
context so this is not going to mix well

00:39:35,240 --> 00:39:40,910
with the father we have packets going in

00:39:38,599 --> 00:39:43,670
what continent it's not going to mix

00:39:40,910 --> 00:39:45,050
well with where the fire that we if we

00:39:43,670 --> 00:39:47,089
try to configure this from the packet

00:39:45,050 --> 00:39:48,740
path from bottom half context right so

00:39:47,089 --> 00:39:50,839
what we need to do is is we are going to

00:39:48,740 --> 00:39:53,750
schedule taking the configuration

00:39:50,839 --> 00:39:57,109
through via via kernel kind of thread we

00:39:53,750 --> 00:39:58,400
all work you and so after you packets

00:39:57,109 --> 00:40:01,160
are going to still be flowing through

00:39:58,400 --> 00:40:03,170
through the software path this is going

00:40:01,160 --> 00:40:04,400
to be consistent to the user because for

00:40:03,170 --> 00:40:06,980
some bit of time we are going to relay

00:40:04,400 --> 00:40:09,440
on the software flow table and at some

00:40:06,980 --> 00:40:13,190
point one we get the configuration in

00:40:09,440 --> 00:40:18,740
the hard work done but we will follow

00:40:13,190 --> 00:40:20,540
you the hardware pack okay so so this is

00:40:18,740 --> 00:40:21,980
basically just because we need we need

00:40:20,540 --> 00:40:24,380
this kernel thread because we need to

00:40:21,980 --> 00:40:28,720
hold the MBL india and the i/o Mattox

00:40:24,380 --> 00:40:28,720
to to configure this

00:40:37,960 --> 00:40:43,010
yeah I think you could use asking why

00:40:40,310 --> 00:40:43,690
and a nomination yes yes sir yes that's

00:40:43,010 --> 00:40:47,090
a good point

00:40:43,690 --> 00:41:10,790
yes that's NDL flow flow upload and say

00:40:47,090 --> 00:41:13,130
in a nom nom yes yeah but I can show you

00:41:10,790 --> 00:41:15,619
the so that's basically it

00:41:13,130 --> 00:41:21,500
the topple how can you say okay I can

00:41:15,619 --> 00:41:23,510
get it larger okay so we have basically

00:41:21,500 --> 00:41:25,369
a topple it's just basically source and

00:41:23,510 --> 00:41:28,369
destination IP address and protocols

00:41:25,369 --> 00:41:35,960
numbers and for ID this actually could

00:41:28,369 --> 00:41:38,930
be when it basically what this is

00:41:35,960 --> 00:41:41,450
storing is also we have a topple for

00:41:38,930 --> 00:41:43,940
each reaction and it's a story it's

00:41:41,450 --> 00:41:47,710
storing the the the address is also

00:41:43,940 --> 00:41:47,710
denied mangling than it needs to happen

00:41:49,930 --> 00:41:53,710
no not yet

00:41:55,910 --> 00:41:59,940
yes we if we want to upload that to the

00:41:58,740 --> 00:42:02,790
hardware yes

00:41:59,940 --> 00:42:04,800
then we need we need to send this to say

00:42:02,790 --> 00:42:06,450
so the hardware needs to say needs to

00:42:04,800 --> 00:42:08,460
announce to the to the kernel that is

00:42:06,450 --> 00:42:12,000
suppose not feature so we can add this

00:42:08,460 --> 00:42:14,520
support for this I mean initially what

00:42:12,000 --> 00:42:17,130
the hardware I'm working it's it's

00:42:14,520 --> 00:42:20,160
actually very very small switch with

00:42:17,130 --> 00:42:22,050
only 4k 4k entries so we just get it

00:42:20,160 --> 00:42:24,660
basically infrastructure in and then we

00:42:22,050 --> 00:42:26,550
can extend in different instructions of

00:42:24,660 --> 00:42:29,700
all more features beautiful color were

00:42:26,550 --> 00:42:32,720
the kind to market intrumental discuss

00:42:29,700 --> 00:42:32,720
the area

00:42:39,330 --> 00:42:42,489
[Music]

00:43:00,730 --> 00:43:04,560
close driver do this

00:43:19,070 --> 00:43:21,580
yeah

00:43:28,869 --> 00:43:31,779
yeah this is something that it's going

00:43:30,339 --> 00:43:32,950
look at this as something that is going

00:43:31,779 --> 00:43:35,140
to integrate with all the features that

00:43:32,950 --> 00:43:36,549
we have in the kernel I mean if we are

00:43:35,140 --> 00:43:38,739
going to check if if there is no

00:43:36,549 --> 00:43:40,630
exponent not not thinking of Android but

00:43:38,739 --> 00:43:42,099
thinking in general if we have an X

00:43:40,630 --> 00:43:45,430
foreign policy it's just going to escape

00:43:42,099 --> 00:43:48,339
this flow of Lord if there is any IP

00:43:45,430 --> 00:43:49,989
option for example a ship so submitting

00:43:48,339 --> 00:43:52,109
instead mentions oh no I cannot offload

00:43:49,989 --> 00:43:56,049
this I need you need to follow the the

00:43:52,109 --> 00:43:58,930
standard awarding fatso so this is also

00:43:56,049 --> 00:44:00,190
providing us a degree some degree of

00:43:58,930 --> 00:44:02,799
integration with all the features that

00:44:00,190 --> 00:44:04,269
we have because we equate up for example

00:44:02,799 --> 00:44:05,940
it's not going to be part it ever going

00:44:04,269 --> 00:44:08,890
to break path and see here either

00:44:05,940 --> 00:44:10,930
because there the software forwarding

00:44:08,890 --> 00:44:13,239
path a classic forwarding path is going

00:44:10,930 --> 00:44:15,009
to with the initial packets it's going

00:44:13,239 --> 00:44:16,900
to make sure that the MTU is all right

00:44:15,009 --> 00:44:20,019
otherwise saying the fragmentation need

00:44:16,900 --> 00:44:21,960
them to do the activity to do the

00:44:20,019 --> 00:44:25,930
endpoints right with the next endpoints

00:44:21,960 --> 00:44:27,249
and so because if we do all this in

00:44:25,930 --> 00:44:30,190
hardware the hardware needs to have a

00:44:27,249 --> 00:44:31,900
bit path empirical evidence or very

00:44:30,190 --> 00:44:36,819
simple hardware is not going to happen

00:44:31,900 --> 00:44:38,710
so yeah ideally it would be good to have

00:44:36,819 --> 00:44:41,349
everything exactly in hardware but in

00:44:38,710 --> 00:44:45,009
practice them many chronic cases are are

00:44:41,349 --> 00:44:47,279
just going to break things so it's a

00:44:45,009 --> 00:44:47,279
trade-off

00:45:09,720 --> 00:45:13,520
no transparencies yes

00:45:23,310 --> 00:45:27,480
question is about how do you reflect

00:45:26,369 --> 00:45:28,710
differences between the hardware

00:45:27,480 --> 00:45:31,230
implementation the software

00:45:28,710 --> 00:45:32,910
implementation so if it's something like

00:45:31,230 --> 00:45:35,520
whether or not you have window tracking

00:45:32,910 --> 00:45:37,830
I think this would be a feature that the

00:45:35,520 --> 00:45:39,720
hardware should advertise somehow can be

00:45:37,830 --> 00:45:40,830
queried and and if you ask for window

00:45:39,720 --> 00:45:43,680
tracking and the hardware doesn't

00:45:40,830 --> 00:45:48,990
support it it's it's disallowed in the

00:45:43,680 --> 00:45:50,700
case of more subtle differences I think

00:45:48,990 --> 00:45:54,240
of a particular example but there must

00:45:50,700 --> 00:45:56,160
be many yeah this is maybe a bit

00:45:54,240 --> 00:45:59,340
unsolved but I think in general the idea

00:45:56,160 --> 00:46:00,960
of the opt-in is that you're saying so

00:45:59,340 --> 00:46:02,550
when we say contact what we're really

00:46:00,960 --> 00:46:04,800
talking about is a specific

00:46:02,550 --> 00:46:06,930
implementation of that that exists in

00:46:04,800 --> 00:46:10,470
the Linux kernel as of a certain version

00:46:06,930 --> 00:46:13,200
of the kernel by saying I want to

00:46:10,470 --> 00:46:14,970
offload or push the flow down to

00:46:13,200 --> 00:46:17,970
Hardware what you're saying is I want

00:46:14,970 --> 00:46:20,130
something that's like a contract and I'm

00:46:17,970 --> 00:46:23,910
I'm acknowledging that it may not be the

00:46:20,130 --> 00:46:30,359
same and as for how it differs and so on

00:46:23,910 --> 00:46:34,050
yeah that would be nice to know yeah but

00:46:30,359 --> 00:46:35,970
it is opt-in part of it is is is the

00:46:34,050 --> 00:46:37,470
basic answer to this question there and

00:46:35,970 --> 00:46:39,540
that's why it's not transparent because

00:46:37,470 --> 00:46:45,570
it's not a contract contract is as

00:46:39,540 --> 00:46:47,930
implemented by Linux is that right

00:46:45,570 --> 00:46:47,930
bubble

00:46:53,150 --> 00:46:59,410
yeah this is basically the material I

00:46:55,910 --> 00:46:59,410
have if you have any other questions yes

00:47:22,230 --> 00:47:26,570
reliable we just use the net

00:47:36,850 --> 00:47:40,210
his whole life

00:47:40,660 --> 00:47:46,789
yeah I would expect I would expect the

00:47:43,039 --> 00:47:48,079
we need we will need a at least on the

00:47:46,789 --> 00:47:51,380
driver side will burn in a garbage

00:47:48,079 --> 00:47:53,569
collector just to to go over I mean this

00:47:51,380 --> 00:47:56,119
Hardware usually can come with with some

00:47:53,569 --> 00:47:58,430
aging infrastructure so you can just

00:47:56,119 --> 00:48:00,439
check in in the registers is one of the

00:47:58,430 --> 00:48:02,449
entries has not seen packets for a while

00:48:00,439 --> 00:48:03,979
I think it will get rid of it but you

00:48:02,449 --> 00:48:05,420
mean you mean you are now getting that

00:48:03,979 --> 00:48:16,059
in sick with where the time is you have

00:48:05,420 --> 00:48:16,059
in contract right yeah

00:48:28,980 --> 00:48:35,830
the hardware and the software would no

00:48:32,320 --> 00:48:38,140
longer age it and so so it would be up

00:48:35,830 --> 00:48:40,000
to the driver to evict the flow on the

00:48:38,140 --> 00:48:42,040
software side and that could be either

00:48:40,000 --> 00:48:49,660
via polling or it could get an event

00:48:42,040 --> 00:48:52,540
from the hardware this yeah either

00:48:49,660 --> 00:48:56,350
polling or they're expecting events from

00:48:52,540 --> 00:48:58,150
the hardware yeah I don't don't think

00:48:56,350 --> 00:49:00,790
that's you want to manage all the timers

00:48:58,150 --> 00:49:04,270
in the hardware so I think it's much

00:49:00,790 --> 00:49:08,200
better than the Kenya will do polling in

00:49:04,270 --> 00:49:10,720
every time a month or so yeah it's up to

00:49:08,200 --> 00:49:12,490
but it can come from the from the from

00:49:10,720 --> 00:49:14,950
the kernel not to do this that's this

00:49:12,490 --> 00:49:16,000
the driver because that will be a code

00:49:14,950 --> 00:49:17,710
inside every driver

00:49:16,000 --> 00:49:19,090
yeah that's will implement that

00:49:17,710 --> 00:49:21,070
implemented the polling I think the

00:49:19,090 --> 00:49:23,590
polling can come from the upper layer

00:49:21,070 --> 00:49:28,290
from the contract itself then you can

00:49:23,590 --> 00:49:31,240
also update his own table and then the

00:49:28,290 --> 00:49:33,520
the user space can can watch what's

00:49:31,240 --> 00:49:35,950
what's the current status because if the

00:49:33,520 --> 00:49:37,990
hardware is already got the fin and

00:49:35,950 --> 00:49:40,840
close this connection I think the

00:49:37,990 --> 00:49:44,230
customer the user space diamond wants to

00:49:40,840 --> 00:49:47,369
see to so that's and we don't want to

00:49:44,230 --> 00:49:47,369
have events for everything

00:49:49,120 --> 00:49:52,120
yeah

00:49:53,140 --> 00:50:06,700
yeah yeah I mean at this stage what we

00:50:04,660 --> 00:50:08,230
have is that the the entry the entry in

00:50:06,700 --> 00:50:12,750
the connection travina has been off Lord

00:50:08,230 --> 00:50:16,120
has no timer its mid-coitus off load

00:50:12,750 --> 00:50:17,980
status beta has been set on and and that

00:50:16,120 --> 00:50:20,350
basically means that that that that flow

00:50:17,980 --> 00:50:21,610
has been pushed into into the flow table

00:50:20,350 --> 00:50:24,640
so it's a flow table that has to

00:50:21,610 --> 00:50:26,290
maintain the the the lead time out we

00:50:24,640 --> 00:50:28,840
can we can provide we can provide an

00:50:26,290 --> 00:50:30,790
ailing interface to the flow table so we

00:50:28,840 --> 00:50:33,880
could we can inspect to see how the

00:50:30,790 --> 00:50:38,920
timers look like in with regard what we

00:50:33,880 --> 00:50:40,210
have in in there and so I agree that it

00:50:38,920 --> 00:50:41,320
would be good to have common

00:50:40,210 --> 00:50:42,700
infrastructure if we can consolidate

00:50:41,320 --> 00:50:44,470
infrastructure for things that the

00:50:42,700 --> 00:50:48,010
drivers are going to repeat over all

00:50:44,470 --> 00:50:49,360
over again and again it's going to be

00:50:48,010 --> 00:50:51,790
better if we have it in a single place

00:50:49,360 --> 00:50:54,250
so just the driver says I won't pull him

00:50:51,790 --> 00:50:57,400
out or even mode and just relay relay on

00:50:54,250 --> 00:51:00,160
some routine that is going to do it from

00:50:57,400 --> 00:51:02,770
I think I would I would expect we need a

00:51:00,160 --> 00:51:04,690
couple of drivers at least or two three

00:51:02,770 --> 00:51:08,860
four drivers and they work we can see

00:51:04,690 --> 00:51:10,390
what we can we can consolidate so but

00:51:08,860 --> 00:51:12,040
yes that the kind of helper functions

00:51:10,390 --> 00:51:13,720
would be good to have depending on the

00:51:12,040 --> 00:51:23,410
approach that the driver follows a event

00:51:13,720 --> 00:51:25,120
base or a pole based event base would be

00:51:23,410 --> 00:51:27,220
a problem because if we're talking about

00:51:25,120 --> 00:51:29,140
a problem that we are facing right now

00:51:27,220 --> 00:51:32,020
that's customer are talking about

00:51:29,140 --> 00:51:36,340
millions of connections per second okay

00:51:32,020 --> 00:51:40,120
so to handle those kind of event it will

00:51:36,340 --> 00:51:41,620
be a problem so this is supposed to be a

00:51:40,120 --> 00:51:43,510
polling it's going to be something that

00:51:41,620 --> 00:51:45,550
will be event based we could even do

00:51:43,510 --> 00:51:47,580
something like nappy like if the number

00:51:45,550 --> 00:51:50,740
of events is - yeah but it's much more

00:51:47,580 --> 00:51:52,570
better to have a polling instead of if

00:51:50,740 --> 00:51:54,610
you want because the user that is

00:51:52,570 --> 00:51:56,440
looking for on the on those tables is

00:51:54,610 --> 00:51:58,720
looking once a second it's not looking

00:51:56,440 --> 00:52:01,660
it don't need to be event driven yeah

00:51:58,720 --> 00:52:02,650
I'm personally personally I'm not too

00:52:01,660 --> 00:52:04,410
worried about providing the

00:52:02,650 --> 00:52:06,320
infrastructure and I will let the driver

00:52:04,410 --> 00:52:08,870
people to decide what they

00:52:06,320 --> 00:52:19,480
it's better for the hardware I mean for

00:52:08,870 --> 00:52:21,890
me that's that should be fine yes but

00:52:19,480 --> 00:52:23,810
what you want to do batching you don't

00:52:21,890 --> 00:52:32,930
want to get notification for every

00:52:23,810 --> 00:52:36,800
connection you start the microphone

00:52:32,930 --> 00:52:38,810
every time so for every new connection

00:52:36,800 --> 00:52:41,390
you must have an event this is a new

00:52:38,810 --> 00:52:43,550
connection but the garbage collector can

00:52:41,390 --> 00:52:46,990
be much more efficient you don't need to

00:52:43,550 --> 00:52:46,990
get an event for every connection

00:53:07,340 --> 00:53:12,110
yes but I don't want to double it to get

00:53:09,750 --> 00:53:12,110
older

00:53:15,230 --> 00:53:25,930
ah so I have a question regarding the

00:53:22,270 --> 00:53:30,650
wireless LAN support you briefly mention

00:53:25,930 --> 00:53:32,480
the I want to have a rough sense how

00:53:30,650 --> 00:53:45,670
much of support we are thinking of or

00:53:32,480 --> 00:53:49,930
the planning in the following as

00:53:45,670 --> 00:53:53,930
everyone might be aware the wireless LAN

00:53:49,930 --> 00:53:57,020
poor headers are pretty notorious in two

00:53:53,930 --> 00:54:01,090
ways number one is D feels optionally or

00:53:57,020 --> 00:54:01,090
conditionally present virtual

00:54:04,840 --> 00:54:09,630
yeah Dwight sorry could you repeat the

00:54:07,600 --> 00:54:09,630
question

00:54:10,650 --> 00:54:17,770
thanks Simon this one is working thanks

00:54:15,190 --> 00:54:21,000
so the it is notorious in the following

00:54:17,770 --> 00:54:23,080
sense number one is the the fills are

00:54:21,000 --> 00:54:25,780
conditionally present or dynamically

00:54:23,080 --> 00:54:30,670
present second is the interpretation

00:54:25,780 --> 00:54:32,590
with each field is also dynamic so I was

00:54:30,670 --> 00:54:34,900
wondering whether when you briefly

00:54:32,590 --> 00:54:37,120
mention the wall and support in the the

00:54:34,900 --> 00:54:39,430
filter whether you are referring to the

00:54:37,120 --> 00:54:44,590
certain like IEP lab iptables level

00:54:39,430 --> 00:54:47,710
support or actually you were thinking of

00:54:44,590 --> 00:54:49,150
that dynamic support per packet so

00:54:47,710 --> 00:54:51,520
you're thinking you're thinking about

00:54:49,150 --> 00:54:54,280
you you're asking about protocols that

00:54:51,520 --> 00:54:57,610
have failed start may be present or not

00:54:54,280 --> 00:55:00,490
that's right so so that's it first first

00:54:57,610 --> 00:55:02,140
issue oh D the wireless LAN protocol

00:55:00,490 --> 00:55:03,790
right it can be there or not there

00:55:02,140 --> 00:55:06,400
depending on the condition second is

00:55:03,790 --> 00:55:07,300
that even if it is there we interpret

00:55:06,400 --> 00:55:13,750
that in a different way

00:55:07,300 --> 00:55:15,580
yeah yep so from my Wi-Fi point of view

00:55:13,750 --> 00:55:18,490
why would you ever run contract on a

00:55:15,580 --> 00:55:20,350
Wi-Fi frame why would you ever run

00:55:18,490 --> 00:55:24,310
contract on a Wi-Fi frame rather than

00:55:20,350 --> 00:55:27,820
the decoded Ethernet frame I mean where

00:55:24,310 --> 00:55:30,100
does this problem come in do you if

00:55:27,820 --> 00:55:32,110
they're not level control is one but it

00:55:30,100 --> 00:55:34,450
is after the convergence so when you

00:55:32,110 --> 00:55:37,960
received from the NFC when the receive

00:55:34,450 --> 00:55:40,330
the Wi-Fi frame then I believe that we

00:55:37,960 --> 00:55:42,220
have a desire to control them because

00:55:40,330 --> 00:55:48,070
not every packet or transactions are

00:55:42,220 --> 00:55:51,580
coming from the Ethernet nowadays I I

00:55:48,070 --> 00:55:52,900
don't buy it because if you if you want

00:55:51,580 --> 00:55:54,820
to receive Wi-Fi frames you have to do

00:55:52,900 --> 00:55:57,250
reordering you have to do a whole bunch

00:55:54,820 --> 00:55:59,890
of things and I don't see how you can do

00:55:57,250 --> 00:56:02,620
anything like contract before you run

00:55:59,890 --> 00:56:04,030
your Wi-Fi stack and once you've run all

00:56:02,620 --> 00:56:06,670
your Wi-Fi stack you might as well just

00:56:04,030 --> 00:56:10,120
convert to the Ethernet frame to the 802

00:56:06,670 --> 00:56:12,630
3 format and then run without all these

00:56:10,120 --> 00:56:12,630
problems

00:56:12,759 --> 00:56:17,029
understood to them what is what do you

00:56:14,779 --> 00:56:22,210
mean by we support the wireless LAN in

00:56:17,029 --> 00:56:22,210
the the filter what do you mean by that

00:56:23,019 --> 00:56:33,109
so that was my original question all

00:56:26,450 --> 00:56:35,450
right so if you can please share I mean

00:56:33,109 --> 00:56:40,609
we are the hooks that we have basically

00:56:35,450 --> 00:56:42,500
on the on day on are not going to see

00:56:40,609 --> 00:56:45,440
that kind of traffic right so I mean odd

00:56:42,500 --> 00:56:47,569
ingress it's so it's it's something that

00:56:45,440 --> 00:56:51,140
is staying behind the curtain off of the

00:56:47,569 --> 00:56:54,640
of the water stack so it's not that we

00:56:51,140 --> 00:56:54,640
we are seeing all these those details

00:57:04,010 --> 00:57:08,630
maybe I missed that you said something

00:57:06,410 --> 00:57:10,850
about Wi-Fi I didn't catch that but um

00:57:08,630 --> 00:57:13,910
yeah I don't see how any of this could

00:57:10,850 --> 00:57:15,530
even see Wi-Fi frames because they go

00:57:13,910 --> 00:57:17,359
away within the Wi-Fi stack before you

00:57:15,530 --> 00:57:19,070
get to the net div so as far as the user

00:57:17,359 --> 00:57:23,300
is concerned if they were to configure

00:57:19,070 --> 00:57:28,670
some sort of NAT or whatever across or

00:57:23,300 --> 00:57:30,230
anything like that across the across the

00:57:28,670 --> 00:57:31,760
Wi-Fi interface you would still

00:57:30,230 --> 00:57:34,310
configure it on the other net layer

00:57:31,760 --> 00:57:35,570
that's exposed by the Wi-Fi stack to the

00:57:34,310 --> 00:57:38,240
net dev right so the net de vista

00:57:35,570 --> 00:57:43,760
regular 802 3 frame well technically not

00:57:38,240 --> 00:57:45,560
a 2 to 3 but Diggs frame format so you'd

00:57:43,760 --> 00:57:49,180
you don't really see anything with the

00:57:45,560 --> 00:57:52,700
Wi-Fi specific stuff at that layer and

00:57:49,180 --> 00:57:54,950
so I don't I don't think this question

00:57:52,700 --> 00:57:56,960
ever will ever be asked like how do you

00:57:54,950 --> 00:57:58,369
deal with all the Wi-Fi formats because

00:57:56,960 --> 00:58:02,480
you don't really don't want to deal with

00:57:58,369 --> 00:58:04,640
that and you can't at this point because

00:58:02,480 --> 00:58:06,470
you see at that layer layer where this

00:58:04,640 --> 00:58:08,600
comes in you only see the other net

00:58:06,470 --> 00:58:10,820
frames if you really want to control

00:58:08,600 --> 00:58:13,190
deeper down in Wi-Fi and I'm not sure

00:58:10,820 --> 00:58:14,840
why you would want to you have you have

00:58:13,190 --> 00:58:16,790
to do something else so I'm not really

00:58:14,840 --> 00:58:19,520
sure where the whole Wi-Fi thing came in

00:58:16,790 --> 00:58:21,790
in this discussion but I don't think

00:58:19,520 --> 00:58:21,790
it's relevant

00:58:29,970 --> 00:58:39,670
Thanks

00:58:31,420 --> 00:58:44,910
any more questions yes could you could

00:58:39,670 --> 00:58:44,910
you pass my thanks

00:58:47,720 --> 00:58:54,809
another different topic at all we've

00:58:50,970 --> 00:58:55,859
been using in enjoying the BPF mature

00:58:54,809 --> 00:58:59,990
for iptables

00:58:55,859 --> 00:59:02,549
so a couple questions on that route

00:58:59,990 --> 00:59:05,280
first is there I understand it's not

00:59:02,549 --> 00:59:08,329
supported in enough tables yet do you

00:59:05,280 --> 00:59:11,520
envision it being supported there and

00:59:08,329 --> 00:59:18,349
two other questions it's currently a

00:59:11,520 --> 00:59:23,339
match option so would you consider or

00:59:18,349 --> 00:59:25,530
how would you see if we extend it or try

00:59:23,339 --> 00:59:30,150
to extend the match capabilities such as

00:59:25,530 --> 00:59:34,609
the ability to match according to or two

00:59:30,150 --> 00:59:39,630
to use from BPF in the match access

00:59:34,609 --> 00:59:42,030
contract state for example like the

00:59:39,630 --> 00:59:45,349
destination interface and on forwarding

00:59:42,030 --> 00:59:49,170
or something like that and how would you

00:59:45,349 --> 00:59:52,530
feel about or how what do you think

00:59:49,170 --> 00:59:57,240
about using vpf as a target from

00:59:52,530 --> 01:00:00,150
netfilter there is no support yet

00:59:57,240 --> 01:00:01,530
because no one has contributed so if

01:00:00,150 --> 01:00:04,710
there is anyone willing to contribute

01:00:01,530 --> 01:00:06,869
that and it has valid use case I don't I

01:00:04,710 --> 01:00:09,660
have no objections in general I would

01:00:06,869 --> 01:00:11,670
like to know though what what kind of

01:00:09,660 --> 01:00:13,619
thing you if possible what you're doing

01:00:11,670 --> 01:00:15,690
but whether BPF match in AP tables

01:00:13,619 --> 01:00:17,760
because now with NFT we have a different

01:00:15,690 --> 01:00:21,599
approach so we basically have our own

01:00:17,760 --> 01:00:24,540
virtual machine so probably it will be

01:00:21,599 --> 01:00:27,030
good to extend the instruction set that

01:00:24,540 --> 01:00:30,119
we have that is network specific to the

01:00:27,030 --> 01:00:32,430
what you need in in a way like that we

01:00:30,119 --> 01:00:34,380
can express through some new extension

01:00:32,430 --> 01:00:36,990
so depending on on your use case

01:00:34,380 --> 01:00:38,970
probably we can come up with something

01:00:36,990 --> 01:00:43,530
in specific for NFT then can't help you

01:00:38,970 --> 01:00:45,599
okay we're trying to leverage a lot of

01:00:43,530 --> 01:00:50,069
the work that's been done on BPF for

01:00:45,599 --> 01:00:52,740
example the maps that they're using with

01:00:50,069 --> 01:00:55,890
all the sort of sorts of maps and hash

01:00:52,740 --> 01:00:58,559
tables etc that they are using to be

01:00:55,890 --> 01:00:59,780
able to control a very elaborate policy

01:00:58,559 --> 01:01:02,270
engine

01:00:59,780 --> 01:01:08,480
from user space and being able to

01:01:02,270 --> 01:01:09,020
control it and and consult a database of

01:01:08,480 --> 01:01:11,270
maps

01:01:09,020 --> 01:01:14,450
that's populated by a process in the

01:01:11,270 --> 01:01:16,760
user space and BPF is very helpful and

01:01:14,450 --> 01:01:21,440
very useful in that sense and it's very

01:01:16,760 --> 01:01:25,970
you know it's we're leveraging all that

01:01:21,440 --> 01:01:28,640
work so so that's the basic let's say

01:01:25,970 --> 01:01:31,640
that's the basic premise and the ability

01:01:28,640 --> 01:01:34,190
to use it as a target would just be to

01:01:31,640 --> 01:01:36,140
in order to be able for example to pass

01:01:34,190 --> 01:01:37,940
information from one BPF program to

01:01:36,140 --> 01:01:40,970
another where you can't do that right

01:01:37,940 --> 01:01:43,430
now in a net filter because it's all

01:01:40,970 --> 01:01:46,690
only match it cannot set anything on the

01:01:43,430 --> 01:01:49,040
skb and it cannot do any modifications

01:01:46,690 --> 01:01:52,400
so we're trying to leverage all that

01:01:49,040 --> 01:01:54,710
power and in that filter I mean we have

01:01:52,400 --> 01:01:57,859
in any Sables we have we have the native

01:01:54,710 --> 01:02:01,190
set infrastructure so for all that list

01:01:57,859 --> 01:02:03,320
of high net services port

01:02:01,190 --> 01:02:05,330
I mean IP addresses whatever you have

01:02:03,320 --> 01:02:09,349
any any tuples that we can built because

01:02:05,330 --> 01:02:12,619
we also support compounds

01:02:09,349 --> 01:02:14,240
I would I would recommend you use the

01:02:12,619 --> 01:02:15,740
native infrastructure that we have to

01:02:14,240 --> 01:02:18,890
maintain all that because it's going to

01:02:15,740 --> 01:02:22,460
I mean it's going to integrate well with

01:02:18,890 --> 01:02:24,619
what we have and and I don't see any

01:02:22,460 --> 01:02:26,690
reason why the set infrastructure the

01:02:24,619 --> 01:02:28,609
BBFS is going to run any faster it's

01:02:26,690 --> 01:02:30,680
basically C code as we have so it's

01:02:28,609 --> 01:02:31,970
basically going to be the same but we

01:02:30,680 --> 01:02:33,440
are going to have everything integrated

01:02:31,970 --> 01:02:36,080
through the same interface so I would

01:02:33,440 --> 01:02:40,460
recommend that you the US then the

01:02:36,080 --> 01:02:42,619
native infrastructure then regarding

01:02:40,460 --> 01:02:43,970
regarding actions what kind of

01:02:42,619 --> 01:02:47,390
information you want to pass between

01:02:43,970 --> 01:02:51,470
with EMV PF problems I'm quite in Korea

01:02:47,390 --> 01:02:53,900
dibala for example one one program could

01:02:51,470 --> 01:02:56,869
do a classification and the other could

01:02:53,900 --> 01:02:59,690
do policy okay and they don't

01:02:56,869 --> 01:03:02,840
necessarily run at the same times on the

01:02:59,690 --> 01:03:05,030
same on the same hooks or on

01:03:02,840 --> 01:03:06,590
currently were using IP tables but on

01:03:05,030 --> 01:03:09,530
different IP table criteria we're

01:03:06,590 --> 01:03:11,360
running different programs and that's

01:03:09,530 --> 01:03:13,610
why we would like to be able to separate

01:03:11,360 --> 01:03:15,230
them and currently we're doing it you

01:03:13,610 --> 01:03:17,620
know we have to take a call between

01:03:15,230 --> 01:03:20,690
different programs and it's it's a

01:03:17,620 --> 01:03:22,730
cumbersome and being able to pass

01:03:20,690 --> 01:03:27,620
information from one to any other make

01:03:22,730 --> 01:03:29,300
sense to us okay I mean I would be very

01:03:27,620 --> 01:03:31,370
much we can have a discussion on offline

01:03:29,300 --> 01:03:33,110
if you like I'm very interested in the

01:03:31,370 --> 01:03:35,660
in the use case in use cases I mean we

01:03:33,110 --> 01:03:37,490
can extend what we have to do support

01:03:35,660 --> 01:03:39,560
near near scenarios and the new use case

01:03:37,490 --> 01:03:41,390
and I think I would I would prefer if we

01:03:39,560 --> 01:03:43,370
we have infrastructure that is generic

01:03:41,390 --> 01:03:45,200
and that integrates well into what we

01:03:43,370 --> 01:03:48,500
have before we follow that path because

01:03:45,200 --> 01:03:50,690
I mean for IP tables DBF match is

01:03:48,500 --> 01:03:52,250
basically all in quite a lot of

01:03:50,690 --> 01:03:55,340
flexibility in an infrastructure that is

01:03:52,250 --> 01:03:57,290
not flexible more actually so but with

01:03:55,340 --> 01:04:00,230
NFC with that we have our own little

01:03:57,290 --> 01:04:01,820
machine as I said it makes sense that

01:04:00,230 --> 01:04:03,620
probably to extended the instruction set

01:04:01,820 --> 01:04:06,650
that we have that is network specific to

01:04:03,620 --> 01:04:10,040
a new new new functionality that can

01:04:06,650 --> 01:04:13,040
that can allow people to do what would

01:04:10,040 --> 01:04:16,270
they need so so let's let's talk and now

01:04:13,040 --> 01:04:16,270
offline okay thanks

01:04:38,050 --> 01:04:40,890
mm-hmm

01:04:44,750 --> 01:04:47,930
so you're gonna you cannot get the

01:04:46,280 --> 01:04:56,480
socket information all the time from the

01:04:47,930 --> 01:04:58,810
packets they match the match for

01:04:56,480 --> 01:04:58,810
iptables

01:05:04,580 --> 01:05:06,640
Oh

01:05:18,550 --> 01:05:24,180
okay I don't have any moment to yelling

01:05:20,820 --> 01:05:24,180
thank you very much

01:05:25,200 --> 01:05:29,300
[Applause]

01:05:26,230 --> 01:05:29,300
[Music]

01:05:32,510 --> 01:05:35,619
[Music]

01:05:57,630 --> 01:06:00,269

YouTube URL: https://www.youtube.com/watch?v=iCj10vEKPrw


