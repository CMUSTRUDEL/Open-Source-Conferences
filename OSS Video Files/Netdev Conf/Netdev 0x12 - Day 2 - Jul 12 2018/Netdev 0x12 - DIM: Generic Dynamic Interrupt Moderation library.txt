Title: Netdev 0x12 - DIM: Generic Dynamic Interrupt Moderation library
Publication date: 2018-08-01
Playlist: Netdev 0x12 - Day 2 - Jul 12 2018
Description: 
	DIM lib is a net driver independent framework for dynamically tuning interrupt moderation recently merged in 4.16 and used by several drivers. It exposes an API which any driver may use in order to optimize its throughput, packet rate, latency and interrupt rate.

In this talk at Netdev 0x12 in Montreal on July 12th, 2018, Tal Gilboa went into details of the DIM workflow, algorithm used, how to integrate into your driver, and last but not least performance benefits.

More info:
https://netdevconf.org/0x12/session.html?dim-generic-dynamic-interrupt-moderation-library
Captions: 
	00:00:00,030 --> 00:00:06,690
so hi I'm tall I'm going to introduce

00:00:03,449 --> 00:00:14,790
Tim a library for dynamic interrupt

00:00:06,690 --> 00:00:17,580
moderation what's this thing do we have

00:00:14,790 --> 00:00:22,470
a scribe for this somebody wants to

00:00:17,580 --> 00:00:26,670
volunteer to scribe this talk I'm gonna

00:00:22,470 --> 00:00:29,630
have to pass it to him sorry thanks so

00:00:26,670 --> 00:00:32,340
before we start a little recognition to

00:00:29,630 --> 00:00:35,820
Gil enough the ad which came up with the

00:00:32,340 --> 00:00:39,030
algorithm and create the first version

00:00:35,820 --> 00:00:44,040
and two nd which came up with the idea

00:00:39,030 --> 00:00:47,219
to make the library generic and took it

00:00:44,040 --> 00:00:51,149
upon himself to actually do it so thanks

00:00:47,219 --> 00:00:53,940
to those guys okay

00:00:51,149 --> 00:00:57,270
what we are going to cover we're going

00:00:53,940 --> 00:00:59,399
to cover the reasons for packet

00:00:57,270 --> 00:01:01,640
interrupt moderation on the receive side

00:00:59,399 --> 00:01:04,439
it's not the only project matters but

00:01:01,640 --> 00:01:06,840
we'll focus on that

00:01:04,439 --> 00:01:09,630
static into a moderation points of

00:01:06,840 --> 00:01:12,119
failure where it's stops working very

00:01:09,630 --> 00:01:13,799
well and of course not dim what's good

00:01:12,119 --> 00:01:16,110
about it how its implemented was the

00:01:13,799 --> 00:01:18,570
algorithm and the performance benefits

00:01:16,110 --> 00:01:21,060
of course we're not going to cover the

00:01:18,570 --> 00:01:24,689
interrupts and interrupting handling in

00:01:21,060 --> 00:01:26,970
general and what is the exact static

00:01:24,689 --> 00:01:30,240
moderation methods and how they are

00:01:26,970 --> 00:01:33,240
implemented assume this is a common

00:01:30,240 --> 00:01:38,310
knowledge but if if not I'll try to

00:01:33,240 --> 00:01:42,899
explain a little bit okay so what what

00:01:38,310 --> 00:01:44,640
exactly is the problem we want we should

00:01:42,899 --> 00:01:46,770
moderate interrupts interrupts are

00:01:44,640 --> 00:01:50,790
basically or the handling of it erupts

00:01:46,770 --> 00:01:54,180
is basically utilizing CPU if we do it

00:01:50,790 --> 00:01:56,990
too often for not efficient enough we're

00:01:54,180 --> 00:01:59,549
going to wind up with CPU bottleneck

00:01:56,990 --> 00:02:02,909
what we're looking for is breaking the

00:01:59,549 --> 00:02:05,130
one-to-one ratio between pockets and the

00:02:02,909 --> 00:02:07,560
interrupts for these packets we want to

00:02:05,130 --> 00:02:10,369
have a lot of pockets or more than one

00:02:07,560 --> 00:02:12,110
pockets handled by a single interrupt

00:02:10,369 --> 00:02:14,720
and of course we want to do it without

00:02:12,110 --> 00:02:18,500
increasing latency or affect it

00:02:14,720 --> 00:02:20,660
affecting it very little when we focus

00:02:18,500 --> 00:02:24,140
on receive side interrupts or receive

00:02:20,660 --> 00:02:26,629
side packets most or all drivers can

00:02:24,140 --> 00:02:30,290
process more than one a packet from a

00:02:26,629 --> 00:02:32,780
single interrupt the QR a serial memory

00:02:30,290 --> 00:02:36,349
and it makes a lot of sense to access

00:02:32,780 --> 00:02:39,650
the packets together and not one by one

00:02:36,349 --> 00:02:43,840
and if we have multiple function calls

00:02:39,650 --> 00:02:46,880
for each packet is of course inefficient

00:02:43,840 --> 00:02:48,709
and the benefits again are clear

00:02:46,880 --> 00:02:51,380
let's function calls less CPU overhead

00:02:48,709 --> 00:02:56,290
and the serial access to memory we can

00:02:51,380 --> 00:02:56,290
utilize some data prefetch mechanisms

00:02:56,560 --> 00:03:01,970
okay so let's let's see where the static

00:03:00,769 --> 00:03:05,180
configuration breaks static

00:03:01,970 --> 00:03:07,280
configuration means I configured a timer

00:03:05,180 --> 00:03:09,410
and number of maximum number of frames

00:03:07,280 --> 00:03:12,799
that I am willing to wait for before I

00:03:09,410 --> 00:03:15,230
issue an interrupt so when we when we

00:03:12,799 --> 00:03:17,930
take a look at some numbers and trying

00:03:15,230 --> 00:03:19,930
to get to a 1 to 2 ratio just a 1 to 2

00:03:17,930 --> 00:03:23,560
ratio meaning two packets per interrupt

00:03:19,930 --> 00:03:29,109
let's start by looking at 100 Gig linked

00:03:23,560 --> 00:03:35,900
with default MTU 1500 bytes works on

00:03:29,109 --> 00:03:37,880
let's say just 8 channels a quick

00:03:35,900 --> 00:03:39,950
calculation shows us that we are going

00:03:37,880 --> 00:03:42,079
to get 1 million packets per second on

00:03:39,950 --> 00:03:45,139
average on each channel which translates

00:03:42,079 --> 00:03:48,019
to just below 1 micro second between

00:03:45,139 --> 00:03:51,079
packets and this means we can work with

00:03:48,019 --> 00:03:54,730
very short interval a virtual timer to

00:03:51,079 --> 00:03:57,169
get 2 packets per interrupt okay great

00:03:54,730 --> 00:04:00,290
what happens when we have a little

00:03:57,169 --> 00:04:02,959
little bit more channels like 32 again

00:04:00,290 --> 00:04:05,690
same calculations give us just below for

00:04:02,959 --> 00:04:08,480
a microsecond again with typical

00:04:05,690 --> 00:04:10,840
round-trip latency this is more than

00:04:08,480 --> 00:04:15,620
enough for lesson

00:04:10,840 --> 00:04:17,269
troubling number 2 to hurt the latency

00:04:15,620 --> 00:04:20,129
we can have for you microsecond timer

00:04:17,269 --> 00:04:22,690
and we're good to go but

00:04:20,129 --> 00:04:24,400
we are not all walking after one her gig

00:04:22,690 --> 00:04:26,560
we can look at the standard or what's

00:04:24,400 --> 00:04:29,470
going to be started the link speed 25

00:04:26,560 --> 00:04:31,539
gig and they have a very strong system

00:04:29,470 --> 00:04:34,090
with HF 48 cores I want to have channel

00:04:31,539 --> 00:04:37,060
per core and I'm starting to get a

00:04:34,090 --> 00:04:39,490
little trouble because now HQ does a

00:04:37,060 --> 00:04:41,979
very little work and average che a gap

00:04:39,490 --> 00:04:42,940
between packets is starting to get a

00:04:41,979 --> 00:04:45,669
little longer

00:04:42,940 --> 00:04:47,500
in this example around 23 microsecond

00:04:45,669 --> 00:04:50,020
and this is not good for us we need a

00:04:47,500 --> 00:04:52,690
very long time err in order just to get

00:04:50,020 --> 00:04:55,479
a 1 to 2 ratio we're not talking even

00:04:52,690 --> 00:04:57,009
more than that so this is the problem

00:04:55,479 --> 00:04:59,919
static configuration at some point

00:04:57,009 --> 00:05:01,449
wouldn't work work was because we were

00:04:59,919 --> 00:05:03,220
looking for an outer box solution we

00:05:01,449 --> 00:05:07,840
don't want to change the static

00:05:03,220 --> 00:05:11,800
configuration for each scenario ok so

00:05:07,840 --> 00:05:15,610
they suggested solution not sure what

00:05:11,800 --> 00:05:17,919
the scan office in a perfect world what

00:05:15,610 --> 00:05:19,960
we would like to find is some kind of

00:05:17,919 --> 00:05:22,750
mechanism that for every existing

00:05:19,960 --> 00:05:25,419
traffic pattern we it could find a

00:05:22,750 --> 00:05:27,849
moderation or moderation values that

00:05:25,419 --> 00:05:29,469
would optimize all metrics of course in

00:05:27,849 --> 00:05:31,419
real life it doesn't work that way

00:05:29,469 --> 00:05:34,990
there's a clear trade-off between

00:05:31,419 --> 00:05:37,419
metrics and traffic patterns or traffic

00:05:34,990 --> 00:05:41,110
in general is not very consistent right

00:05:37,419 --> 00:05:43,449
it changes in time we can't assume it

00:05:41,110 --> 00:05:46,599
would start in a in a certain way and

00:05:43,449 --> 00:05:47,949
just continue like that forever this

00:05:46,599 --> 00:05:49,930
means of course that every algorithm

00:05:47,949 --> 00:05:53,680
that we are going to implement is going

00:05:49,930 --> 00:05:57,009
to prefer so-called certain certain

00:05:53,680 --> 00:05:59,979
metrics over others it will have to take

00:05:57,009 --> 00:06:03,699
a decision if we would like to improve

00:05:59,979 --> 00:06:06,880
bandwidth even if it means to do it on

00:06:03,699 --> 00:06:10,180
the expense of the interrupt rate in

00:06:06,880 --> 00:06:11,949
deems case we are preferring packet rate

00:06:10,180 --> 00:06:14,650
or a bandwidth over the interrupt rate

00:06:11,949 --> 00:06:17,529
and we also taken care of latency by the

00:06:14,650 --> 00:06:22,599
exit left policy which I'll explain in

00:06:17,529 --> 00:06:24,250
details later we can see it in a more in

00:06:22,599 --> 00:06:28,900
a moment

00:06:24,250 --> 00:06:31,900
okay so the algorithm yeah we're not

00:06:28,900 --> 00:06:37,470
going to do anything that that

00:06:31,900 --> 00:06:42,190
complicated okay so we try to make it as

00:06:37,470 --> 00:06:44,920
simple as possible where what we do is

00:06:42,190 --> 00:06:46,990
sampling comparing and deciding what to

00:06:44,920 --> 00:06:49,690
do where we sampling the current state

00:06:46,990 --> 00:06:51,790
of the of the system comparing it

00:06:49,690 --> 00:06:54,370
comparing it to the previous cycle and

00:06:51,790 --> 00:06:55,960
then we decide what to do and the

00:06:54,370 --> 00:06:59,080
decision will be in the next slide we'll

00:06:55,960 --> 00:07:00,790
see exactly what we can do we decide

00:06:59,080 --> 00:07:02,830
what it's what is better than what what

00:07:00,790 --> 00:07:05,650
is worse as I described earlier but

00:07:02,830 --> 00:07:08,770
there's a more detailed calculation here

00:07:05,650 --> 00:07:11,530
and we use the feedback from the from

00:07:08,770 --> 00:07:18,580
the previous cycle to get a better

00:07:11,530 --> 00:07:21,940
decision okay so what dimmed in does is

00:07:18,580 --> 00:07:26,460
selecting a profile or recommending a

00:07:21,940 --> 00:07:29,440
profile to the user that's all it can do

00:07:26,460 --> 00:07:35,140
it distinguish between a support for

00:07:29,440 --> 00:07:38,500
timer reset for the interrogatory frame

00:07:35,140 --> 00:07:41,590
at time of the terminal start when I get

00:07:38,500 --> 00:07:43,330
an interrupt or if I don't support timer

00:07:41,590 --> 00:07:45,060
reset the profiles would be a bit

00:07:43,330 --> 00:07:47,400
different but the idea is the same and

00:07:45,060 --> 00:07:51,070
what's important to understand here that

00:07:47,400 --> 00:07:53,110
it's not that for certain data or

00:07:51,070 --> 00:07:55,690
certain sample I'm going to recommend a

00:07:53,110 --> 00:07:59,710
use profile number 3 or profile number 1

00:07:55,690 --> 00:08:01,419
I would only recommend to go right which

00:07:59,710 --> 00:08:03,100
means profile with indexes with the

00:08:01,419 --> 00:08:10,660
higher indexes or left to the lower

00:08:03,100 --> 00:08:12,669
indexes or stay put ok and for taking a

00:08:10,660 --> 00:08:16,180
decision we distinguished between two

00:08:12,669 --> 00:08:18,880
phases or States either we're on our way

00:08:16,180 --> 00:08:21,160
to the right side or the left side as I

00:08:18,880 --> 00:08:24,520
show before all we are currently parking

00:08:21,160 --> 00:08:26,920
meaning the less decision was to wasn't

00:08:24,520 --> 00:08:30,490
to change the

00:08:26,920 --> 00:08:33,850
their profile so in this case it's very

00:08:30,490 --> 00:08:36,130
simple will compare the the samples if

00:08:33,850 --> 00:08:39,130
we're going right and we see that

00:08:36,130 --> 00:08:41,380
current sample is better we continue all

00:08:39,130 --> 00:08:45,010
right if it's worse we'll switch sides

00:08:41,380 --> 00:08:47,830
and go left and of course vice versa if

00:08:45,010 --> 00:08:48,550
we were going left and if we are on the

00:08:47,830 --> 00:08:52,960
same state

00:08:48,550 --> 00:08:55,180
we'll just Park if we were parking again

00:08:52,960 --> 00:08:57,940
if there is no major change between the

00:08:55,180 --> 00:09:01,300
samples will just continue park this is

00:08:57,940 --> 00:09:03,790
in order to avoid a lot of toggling

00:09:01,300 --> 00:09:09,790
between between states between profile

00:09:03,790 --> 00:09:11,980
sorry and if were if we see difference a

00:09:09,790 --> 00:09:14,080
big difference in the in the samples

00:09:11,980 --> 00:09:16,660
will decide to go left and right and

00:09:14,080 --> 00:09:20,410
here is the exit left policy unless

00:09:16,660 --> 00:09:22,300
we're on the most left profile we will

00:09:20,410 --> 00:09:30,010
go left if well on the most left we have

00:09:22,300 --> 00:09:35,250
no way no choice but to go right okay

00:09:30,010 --> 00:09:39,280
some performance so here I compared

00:09:35,250 --> 00:09:43,660
kinetics for leaks 25 gig adapters this

00:09:39,280 --> 00:09:45,040
is mullennixes and I compared to two

00:09:43,660 --> 00:09:47,260
different scenarios scenarios one

00:09:45,040 --> 00:09:49,870
supports timer reset and the other

00:09:47,260 --> 00:09:53,350
doesn't support time at time I reset I

00:09:49,870 --> 00:09:56,670
compared to some somewhat favorable a

00:09:53,350 --> 00:10:00,430
static configuration favorable for

00:09:56,670 --> 00:10:02,440
bandwidth and this is just running a

00:10:00,430 --> 00:10:04,690
single TCP stream at full line rate

00:10:02,440 --> 00:10:09,220
there's no no real problem to get full

00:10:04,690 --> 00:10:11,590
line rate on on this scenario but you

00:10:09,220 --> 00:10:14,350
can easily see demons and the green and

00:10:11,590 --> 00:10:17,100
the static configuration is in blue the

00:10:14,350 --> 00:10:20,740
interrupt rate is significantly

00:10:17,100 --> 00:10:26,920
significantly lower on the time reset

00:10:20,740 --> 00:10:33,310
side this is because what dim does is it

00:10:26,920 --> 00:10:35,140
selects the longest so a shortage the

00:10:33,310 --> 00:10:37,420
timer that you can work with but still

00:10:35,140 --> 00:10:41,320
get the reset yeah if I ever

00:10:37,420 --> 00:10:42,910
hi your packets rate I can use I can use

00:10:41,320 --> 00:10:45,190
shorter timer because the packets are

00:10:42,910 --> 00:10:48,070
arriving and resetting the timer quicker

00:10:45,190 --> 00:10:51,640
if I have less packet rate or a slower

00:10:48,070 --> 00:10:55,660
packet rate I would have to use longer

00:10:51,640 --> 00:10:58,270
times and they issue that I'm I want to

00:10:55,660 --> 00:11:00,580
aggregate this much back as possible for

00:10:58,270 --> 00:11:04,480
issue the interrupt but I don't want to

00:11:00,580 --> 00:11:08,130
wait too long so the problem with time

00:11:04,480 --> 00:11:10,810
reset is the time between interrupts is

00:11:08,130 --> 00:11:13,450
we can know what the maximum would be

00:11:10,810 --> 00:11:15,250
but we can say for sure what it would be

00:11:13,450 --> 00:11:19,120
every time so we don't want to go

00:11:15,250 --> 00:11:22,810
overboard without timer reset what dim

00:11:19,120 --> 00:11:25,510
does is it always tried to get to a

00:11:22,810 --> 00:11:28,360
certain amount of frames aggregated

00:11:25,510 --> 00:11:30,160
between interrupts it's a set value if

00:11:28,360 --> 00:11:31,960
you look at the profiles that I show

00:11:30,160 --> 00:11:35,650
before it's always the same value and

00:11:31,960 --> 00:11:38,050
it's all only plays with the timer it

00:11:35,650 --> 00:11:41,590
would like to have the shortest timer

00:11:38,050 --> 00:11:43,060
that would still allow a full

00:11:41,590 --> 00:11:43,630
aggregation or as much aggregation as

00:11:43,060 --> 00:11:47,860
possible

00:11:43,630 --> 00:11:50,980
so again the difference is a bit if it's

00:11:47,860 --> 00:11:54,580
not the same as with the time I reset we

00:11:50,980 --> 00:11:58,470
can still see the benefit and of course

00:11:54,580 --> 00:12:01,150
just another word when I use a static 16

00:11:58,470 --> 00:12:03,580
1606 timer I'm starting to see issues

00:12:01,150 --> 00:12:04,750
with the latency so it's favorable the

00:12:03,580 --> 00:12:08,260
static epigraph is favorable for

00:12:04,750 --> 00:12:10,420
bandwidth but it does take a toll on the

00:12:08,260 --> 00:12:15,180
latency the dim configuration doesn't

00:12:10,420 --> 00:12:18,490
change anything with the latency sorry

00:12:15,180 --> 00:12:20,080
ok and another another experiment that

00:12:18,490 --> 00:12:25,060
we did is that we did this is for a

00:12:20,080 --> 00:12:29,170
Broadcom 25 gig adapter we ran 500 UDP

00:12:25,060 --> 00:12:33,540
streams over 8 queues and here you can

00:12:29,170 --> 00:12:37,300
see that this is a interrupt rate and

00:12:33,540 --> 00:12:41,190
packet rate as a function of the message

00:12:37,300 --> 00:12:45,370
size green is dim and blue and teal is

00:12:41,190 --> 00:12:48,520
static this is static 14 the timer is 14

00:12:45,370 --> 00:12:50,310
and frames is 15 this is the common

00:12:48,520 --> 00:12:52,529
values for this Nick

00:12:50,310 --> 00:12:56,120
and again what we can see here that

00:12:52,529 --> 00:12:59,810
start it B has a dim impact is

00:12:56,120 --> 00:13:02,520
significant it behaves very nice but

00:12:59,810 --> 00:13:05,029
from the nature of my job I have to show

00:13:02,520 --> 00:13:11,220
the bad stuff as well

00:13:05,029 --> 00:13:14,400
dim doesn't distinguish in the let's

00:13:11,220 --> 00:13:17,580
call it the quantity of the of the

00:13:14,400 --> 00:13:19,410
effect if if it prefers been weeds and

00:13:17,580 --> 00:13:22,589
it get a little improvement in

00:13:19,410 --> 00:13:27,060
bandwidths also it is not the expects of

00:13:22,589 --> 00:13:29,279
a large degradation or or a increase in

00:13:27,060 --> 00:13:30,630
interoperate it's it's good for him so

00:13:29,279 --> 00:13:33,210
this is something that we are going to

00:13:30,630 --> 00:13:37,890
work on but it's far from perfect and we

00:13:33,210 --> 00:13:39,900
can see it on the on the 1k scenario

00:13:37,890 --> 00:13:42,480
where we get slight improvement in

00:13:39,900 --> 00:13:49,339
bandwidth but all in packet rate but a

00:13:42,480 --> 00:13:52,950
huge increase in interrupts rate okay

00:13:49,339 --> 00:13:55,980
the usage is first of all documented in

00:13:52,950 --> 00:13:59,600
in a Linux documentation and the second

00:13:55,980 --> 00:14:02,820
is very very easy

00:13:59,600 --> 00:14:05,460
I'm not going to cover everything right

00:14:02,820 --> 00:14:09,270
now but you essentially have need to

00:14:05,460 --> 00:14:13,470
create the instance of deme in your

00:14:09,270 --> 00:14:15,600
driver dim doesn't know this this is for

00:14:13,470 --> 00:14:18,570
networking it doesn't care what you do

00:14:15,600 --> 00:14:21,690
with it all it does is comparing samples

00:14:18,570 --> 00:14:25,200
and give recommendations so as long as

00:14:21,690 --> 00:14:27,720
you going to use it properly and give it

00:14:25,200 --> 00:14:31,830
the correct correct data it should work

00:14:27,720 --> 00:14:35,940
well but it has no no way to to enforce

00:14:31,830 --> 00:14:39,480
that so create a dim instance per Q or

00:14:35,940 --> 00:14:44,750
not P or Q or whatever you want make

00:14:39,480 --> 00:14:52,170
sure to create a delayed work for

00:14:44,750 --> 00:14:56,839
actually taking the recommendation there

00:14:52,170 --> 00:14:59,340
changing the values in your driver and

00:14:56,839 --> 00:15:02,220
pretty much at

00:14:59,340 --> 00:15:04,710
at Nepal or wherever you you want you

00:15:02,220 --> 00:15:06,720
can call the Nadeem function and it

00:15:04,710 --> 00:15:09,120
would start the algorithm and return and

00:15:06,720 --> 00:15:11,990
called the delayed work once it done

00:15:09,120 --> 00:15:14,130
once it's done if it thinks that

00:15:11,990 --> 00:15:16,530
something need to be shipped to be

00:15:14,130 --> 00:15:20,270
changed sorry if he decides no change

00:15:16,530 --> 00:15:20,270
needed it wouldn't call the delayed work

00:15:20,510 --> 00:15:28,980
okay and what we have now and what are

00:15:24,060 --> 00:15:32,430
our future plans Jim was introduced as

00:15:28,980 --> 00:15:38,130
part of the America vive er at kernel

00:15:32,430 --> 00:15:42,600
4.8 it was made generic again by Andy at

00:15:38,130 --> 00:15:44,880
Cana 4.16 and it now supports or going

00:15:42,600 --> 00:15:46,860
to be to support adaptive teks as well

00:15:44,880 --> 00:15:51,240
not just adaptive Eric's as part of the

00:15:46,860 --> 00:15:54,930
rationale for 18j the drivers that use

00:15:51,240 --> 00:15:57,990
it currently are ml x5 Ethernet driver

00:15:54,930 --> 00:16:00,630
and broad combs the drivers different

00:15:57,990 --> 00:16:04,170
from travels and our plans for the

00:16:00,630 --> 00:16:05,910
future mostly stabilized the profile

00:16:04,170 --> 00:16:08,370
selection and reduce the algorithm

00:16:05,910 --> 00:16:10,860
overhead again fixing issues like I

00:16:08,370 --> 00:16:13,589
showed in the in the previous present

00:16:10,860 --> 00:16:17,100
previous slides that the decision that

00:16:13,589 --> 00:16:19,970
it's takes team takes is looks good on

00:16:17,100 --> 00:16:24,600
paper but have too much of a price to it

00:16:19,970 --> 00:16:28,920
and improve our debug abilities at the

00:16:24,600 --> 00:16:31,410
counters and debug data to to a better

00:16:28,920 --> 00:16:35,070
track what algorithm does where it goes

00:16:31,410 --> 00:16:38,750
white X from decisions and of course

00:16:35,070 --> 00:16:38,750
this way we can optimize it better

00:16:40,250 --> 00:16:43,250
questions

00:16:58,180 --> 00:17:05,350
so so does this kind of require

00:17:05,530 --> 00:17:13,940
high-resolution divers in in the nick

00:17:09,440 --> 00:17:16,130
hardware is most interpolation of things

00:17:13,940 --> 00:17:18,700
does what does it have somehow managed

00:17:16,130 --> 00:17:23,420
to work on hard without that support

00:17:18,700 --> 00:17:29,320
define high resolution like microseconds

00:17:23,420 --> 00:17:33,110
yeah so this works every Nick's that

00:17:29,320 --> 00:17:35,540
that supports the Linux interpolation

00:17:33,110 --> 00:17:38,900
already has to support it in microsecond

00:17:35,540 --> 00:17:41,000
resolution what we what we have must

00:17:38,900 --> 00:17:43,010
have in order for is for this to work

00:17:41,000 --> 00:17:46,430
properly is being able to change the

00:17:43,010 --> 00:17:49,520
values both of the timer and frames on

00:17:46,430 --> 00:17:51,470
runtime without crew recreating the

00:17:49,520 --> 00:17:53,390
queues because this would destroy the

00:17:51,470 --> 00:17:55,520
performance but the resolution is

00:17:53,390 --> 00:17:58,280
there's no change in the middle

00:17:55,520 --> 00:18:01,690
resolution between the static abilities

00:17:58,280 --> 00:18:01,690
to the dynamic ones

00:18:05,010 --> 00:18:08,250
and once

00:18:14,660 --> 00:18:21,450
okay looks good hey thanks

00:18:19,780 --> 00:18:26,440
[Music]

00:18:21,450 --> 00:18:26,440

YouTube URL: https://www.youtube.com/watch?v=ReY9qBP1iHE


