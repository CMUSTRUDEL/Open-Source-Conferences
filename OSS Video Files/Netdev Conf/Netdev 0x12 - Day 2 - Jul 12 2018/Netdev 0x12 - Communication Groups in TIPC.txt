Title: Netdev 0x12 - Communication Groups in TIPC
Publication date: 2018-08-01
Playlist: Netdev 0x12 - Day 2 - Jul 12 2018
Description: 
	Jon Maloy talked about the new TIPC Communication Groups on July 12th, 2018, at Netdev 0x12 in Montreal.
Communication groups which provide the basis for a performant and scalable kernel based broker-less message bus.

More info:
https://www.netdevconf.org/0x12/session.html?communication-groups-in-tipc
Captions: 
	00:00:28,730 --> 00:00:38,680
all right it's at the right slide all

00:00:36,170 --> 00:00:38,680
right we'll get started

00:00:39,220 --> 00:00:47,960
can I get a scribe for this talk

00:00:41,570 --> 00:00:49,760
someone to take notes on this that we

00:00:47,960 --> 00:00:52,370
would like to have the rest of the

00:00:49,760 --> 00:00:55,970
community get summaries before the

00:00:52,370 --> 00:00:58,059
papers get published Oh nobody's feeling

00:00:55,970 --> 00:01:18,259
guilty at all here who can I guilt

00:00:58,059 --> 00:01:19,820
you're doing okay thanks for okay my

00:01:18,259 --> 00:01:22,070
name is John Malloy I'm talking about

00:01:19,820 --> 00:01:23,930
working at the telco vendor Erickson and

00:01:22,070 --> 00:01:28,070
I'm going to talk about a new feature

00:01:23,930 --> 00:01:34,850
that was added to the tipsy service a

00:01:28,070 --> 00:01:40,060
few months ago to Linux so I think we

00:01:34,850 --> 00:01:44,179
need to go back here yeah and we call it

00:01:40,060 --> 00:01:45,530
tipsy communication groups and to

00:01:44,179 --> 00:01:49,700
understand this whole thing we need to

00:01:45,530 --> 00:01:53,440
have some background first Tipsy

00:01:49,700 --> 00:01:56,330
supports two messaging modes it's

00:01:53,440 --> 00:01:59,899
connection oriented messaging much like

00:01:56,330 --> 00:02:03,520
we know it from TCP but slightly

00:01:59,899 --> 00:02:06,440
different slightly different properties

00:02:03,520 --> 00:02:09,940
but that is not the subject of this talk

00:02:06,440 --> 00:02:13,340
and that second messaging mode is

00:02:09,940 --> 00:02:15,680
Datagram messaging also somewhat what we

00:02:13,340 --> 00:02:18,340
know way from UDP but also with the

00:02:15,680 --> 00:02:21,260
different properties

00:02:18,340 --> 00:02:23,959
what is different is and specific in

00:02:21,260 --> 00:02:25,790
tipsy is that únicos messaging or

00:02:23,959 --> 00:02:27,380
Datagram messaging can be done in two

00:02:25,790 --> 00:02:28,790
different or seven different ways and

00:02:27,380 --> 00:02:32,060
with different addresses we have to

00:02:28,790 --> 00:02:35,270
address types we have a socket socket

00:02:32,060 --> 00:02:38,900
address which not very surprisingly

00:02:35,270 --> 00:02:40,579
consists of a port number and a node

00:02:38,900 --> 00:02:42,260
number as you will see from a left here

00:02:40,579 --> 00:02:45,110
that is something you get from this

00:02:42,260 --> 00:02:47,629
when you create the socket and with that

00:02:45,110 --> 00:02:48,799
you can send únicos messages to one

00:02:47,629 --> 00:02:51,019
specific socket

00:02:48,799 --> 00:02:54,110
this address uniquely identifies a

00:02:51,019 --> 00:02:56,209
socket the second address type is what

00:02:54,110 --> 00:02:58,310
we call a service address you address

00:02:56,209 --> 00:03:00,260
services you don't know where this

00:02:58,310 --> 00:03:04,370
service is you just use this address and

00:03:00,260 --> 00:03:07,610
this consists also of two integers a

00:03:04,370 --> 00:03:09,260
type identifier and an instance service

00:03:07,610 --> 00:03:12,290
type identifier and an instance

00:03:09,260 --> 00:03:15,170
identifier both cept chosen by the user

00:03:12,290 --> 00:03:17,379
by the program when is writing its

00:03:15,170 --> 00:03:22,220
program and with this type of address

00:03:17,379 --> 00:03:23,629
you can send messages distribute message

00:03:22,220 --> 00:03:25,909
in two different ways you can use what

00:03:23,629 --> 00:03:28,000
we call any cost that is you send the

00:03:25,909 --> 00:03:32,180
message as a client sends a message and

00:03:28,000 --> 00:03:34,609
it will be delivered to any of the

00:03:32,180 --> 00:03:36,680
sockets if there's more than one that

00:03:34,609 --> 00:03:38,180
was bound to this particular address in

00:03:36,680 --> 00:03:42,920
this example here you'll see there are

00:03:38,180 --> 00:03:45,049
two bound to the same address and this

00:03:42,920 --> 00:03:48,019
selection is done on round-robin basis

00:03:45,049 --> 00:03:49,849
so this message said once under sending

00:03:48,019 --> 00:03:52,459
several messages they will not go to the

00:03:49,849 --> 00:03:55,160
same destination you can also use the

00:03:52,459 --> 00:03:58,190
same message type to use to send

00:03:55,160 --> 00:04:00,019
multicast messages that is you can

00:03:58,190 --> 00:04:01,970
choose that the messages arrive or

00:04:00,019 --> 00:04:07,459
deliver to all sockets who are bound to

00:04:01,970 --> 00:04:09,949
this particular address now of course

00:04:07,459 --> 00:04:12,949
there is a problem with this as always

00:04:09,949 --> 00:04:14,510
is we Datagram messaging you are not

00:04:12,949 --> 00:04:18,650
guaranteed that the message will be

00:04:14,510 --> 00:04:22,099
delivered because there is no end-to-end

00:04:18,650 --> 00:04:23,660
flow control chances are not better to

00:04:22,099 --> 00:04:25,669
have a levered here than whether you

00:04:23,660 --> 00:04:28,880
have a new DP because there is after all

00:04:25,669 --> 00:04:30,560
a delivery guarantee note to note there

00:04:28,880 --> 00:04:32,180
is a so-called link layer and Tipsy that

00:04:30,560 --> 00:04:34,729
will deliver them packets and a message

00:04:32,180 --> 00:04:38,599
as no to note but once they all have

00:04:34,729 --> 00:04:40,699
arrived at even when they have arrived

00:04:38,599 --> 00:04:43,340
at the destination socket they may still

00:04:40,699 --> 00:04:47,120
be tossed away simply because the

00:04:43,340 --> 00:04:48,519
destination buffer is overfilled so this

00:04:47,120 --> 00:04:51,649
is one problem

00:04:48,519 --> 00:04:54,379
the second problem is related to the

00:04:51,649 --> 00:04:55,939
other major or service activities

00:04:54,379 --> 00:04:57,969
delivering what we call service tracking

00:04:55,939 --> 00:05:00,800
and that is related to the same

00:04:57,969 --> 00:05:08,089
addressing type the service address it

00:05:00,800 --> 00:05:13,429
is possible for for client to subscribe

00:05:08,089 --> 00:05:15,739
for all binding and unbinding events to

00:05:13,429 --> 00:05:17,089
this particular address or address range

00:05:15,739 --> 00:05:19,249
if you look at the left hand side the

00:05:17,089 --> 00:05:23,029
client here has created a socket and you

00:05:19,249 --> 00:05:25,639
subscribe for service type number 42 and

00:05:23,029 --> 00:05:28,249
he wants to know about all bindings

00:05:25,639 --> 00:05:30,860
within the instance range zero to ten

00:05:28,249 --> 00:05:33,819
and then you see that on the right hand

00:05:30,860 --> 00:05:37,099
side there are two services binding to

00:05:33,819 --> 00:05:40,039
two instances within that range so the

00:05:37,099 --> 00:05:41,809
client will receive events about this

00:05:40,039 --> 00:05:43,699
and they will receive both the socket

00:05:41,809 --> 00:05:47,079
addresses that have been you or being

00:05:43,699 --> 00:05:50,479
used both bound to service address and

00:05:47,079 --> 00:05:53,209
the socket address that belongs to the

00:05:50,479 --> 00:05:56,929
socket now there is a problem with this

00:05:53,209 --> 00:05:58,729
approach to that is that the socket the

00:05:56,929 --> 00:06:02,329
client is okay the client is using for

00:05:58,729 --> 00:06:04,039
this for this subscription is a

00:06:02,329 --> 00:06:07,219
connection-oriented socket he connects

00:06:04,039 --> 00:06:09,919
to a dedicated internal topology service

00:06:07,219 --> 00:06:12,110
in tipsy so this socket cannot be used

00:06:09,919 --> 00:06:14,869
for traffic for sending messages other

00:06:12,110 --> 00:06:16,579
messages that also means that the events

00:06:14,869 --> 00:06:19,639
and the message will follow in different

00:06:16,579 --> 00:06:21,559
ports and there is no synchronization

00:06:19,639 --> 00:06:23,989
between these two so that also means

00:06:21,559 --> 00:06:27,259
it's fully possible for a client process

00:06:23,989 --> 00:06:29,089
to sending out the message it will end

00:06:27,259 --> 00:06:32,689
up in service of this doesn't yet know

00:06:29,089 --> 00:06:34,610
about the resume server may respond and

00:06:32,689 --> 00:06:36,499
he will actually surprise surprise

00:06:34,610 --> 00:06:38,050
receive messages from from the server he

00:06:36,499 --> 00:06:41,439
doesn't learn hasn't learned about yet

00:06:38,050 --> 00:06:45,279
the opposite may also happen

00:06:41,439 --> 00:06:48,349
the client may receive an event about

00:06:45,279 --> 00:06:50,449
the crash or unbinding or one of the

00:06:48,349 --> 00:06:52,489
servers where after he may actually

00:06:50,449 --> 00:06:53,749
receive a message from that server which

00:06:52,489 --> 00:06:57,469
has been lagging somewhere in a queue

00:06:53,749 --> 00:06:59,240
somewhere so this is a problem that may

00:06:57,469 --> 00:07:00,889
cause surprises for the programmers and

00:06:59,240 --> 00:07:03,699
they will have to deal with it which is

00:07:00,889 --> 00:07:03,699
not necessary

00:07:03,790 --> 00:07:08,870
so the solution to this which we came up

00:07:07,520 --> 00:07:12,170
with this is what they call

00:07:08,870 --> 00:07:14,870
communication groups we can initially

00:07:12,170 --> 00:07:17,060
think about it as multi cause groups

00:07:14,870 --> 00:07:20,360
because this is how the idea came up and

00:07:17,060 --> 00:07:23,840
this is how we started out with it the

00:07:20,360 --> 00:07:26,540
basic idea is that each socket keeps

00:07:23,840 --> 00:07:29,360
track needs keep continuous track of all

00:07:26,540 --> 00:07:32,660
other members of this group the socket

00:07:29,360 --> 00:07:34,520
joins a group by a I called the joint

00:07:32,660 --> 00:07:38,540
call here but it's reality asserts adopt

00:07:34,520 --> 00:07:40,820
where he he indicates a topple a group

00:07:38,540 --> 00:07:45,170
and a member topple two into integers

00:07:40,820 --> 00:07:47,780
and this is distributed via the

00:07:45,170 --> 00:07:49,460
distributed internal distributed binding

00:07:47,780 --> 00:07:54,470
table in tipsy to all the other sockets

00:07:49,460 --> 00:07:56,990
in that group so all circuits

00:07:54,470 --> 00:07:59,480
continuously knows about all of the

00:07:56,990 --> 00:08:01,700
circuits in the group and this makes it

00:07:59,480 --> 00:08:04,970
makes a lot of things possible which

00:08:01,700 --> 00:08:06,920
we'll see later of course if the socket

00:08:04,970 --> 00:08:08,810
knows about all the other members maybe

00:08:06,920 --> 00:08:13,240
the user could learn about it also and

00:08:08,810 --> 00:08:16,640
that is also possible here so the user

00:08:13,240 --> 00:08:18,980
he can choose to subscribe for new

00:08:16,640 --> 00:08:21,800
members and for members disappearing and

00:08:18,980 --> 00:08:24,380
he will receive an event about it and

00:08:21,800 --> 00:08:27,140
this event is nothing magic it's just an

00:08:24,380 --> 00:08:29,630
empty message an out-of-band message

00:08:27,140 --> 00:08:32,599
which will receive which contains

00:08:29,630 --> 00:08:33,830
information about accompanied with the

00:08:32,599 --> 00:08:36,590
information about the two sources

00:08:33,830 --> 00:08:38,750
addresses of the new member or the older

00:08:36,590 --> 00:08:41,510
disappeared member I should also mention

00:08:38,750 --> 00:08:44,300
here that when I say group and member

00:08:41,510 --> 00:08:46,280
here it's nothing but what I call a

00:08:44,300 --> 00:08:50,560
service address in the previous lives

00:08:46,280 --> 00:08:52,790
it's really a type and instance address

00:08:50,560 --> 00:08:58,360
but in this context we find it

00:08:52,790 --> 00:08:58,360
convenient to call it something else so

00:08:59,680 --> 00:09:03,890
because of this it's possible for the

00:09:02,210 --> 00:09:06,350
user and for the sockets to keep

00:09:03,890 --> 00:09:08,150
continuous track of its other members

00:09:06,350 --> 00:09:10,580
and the fact that the group is closed

00:09:08,150 --> 00:09:12,260
you will never receive be able to

00:09:10,580 --> 00:09:14,550
exchange one member will never be able

00:09:12,260 --> 00:09:19,020
to exchange messages with

00:09:14,550 --> 00:09:20,490
with sockets outside the group that

00:09:19,020 --> 00:09:21,690
makes it possible to introduce for

00:09:20,490 --> 00:09:27,900
instance flow control which you'll see

00:09:21,690 --> 00:09:29,880
later now once we have established this

00:09:27,900 --> 00:09:31,320
this concept or realized yeah but this

00:09:29,880 --> 00:09:33,410
can be used for more things we can

00:09:31,320 --> 00:09:35,520
actually do this for the unit cost

00:09:33,410 --> 00:09:37,380
feature we described earlier that

00:09:35,520 --> 00:09:40,410
Datagram unit cost it can be used for

00:09:37,380 --> 00:09:42,240
the anacostia we described earlier for

00:09:40,410 --> 00:09:45,390
the multi cost what was which was a

00:09:42,240 --> 00:09:47,540
problem we started to try to solve and a

00:09:45,390 --> 00:09:49,980
new messaging mode comes up here

00:09:47,540 --> 00:09:51,960
broadcasts group broadcast that means

00:09:49,980 --> 00:09:54,600
you can actually send this a message to

00:09:51,960 --> 00:09:57,680
all members of the group irrespective of

00:09:54,600 --> 00:10:01,950
the plan the members number member ID

00:09:57,680 --> 00:10:04,320
you just use the basic sent primitive

00:10:01,950 --> 00:10:06,870
which are all used to from the TCP for

00:10:04,320 --> 00:10:08,040
instance and the message will be

00:10:06,870 --> 00:10:11,850
delivered to all members

00:10:08,040 --> 00:10:13,500
irrespective and when you receive one of

00:10:11,850 --> 00:10:15,420
these messages it's just like in the

00:10:13,500 --> 00:10:17,580
previous slide when you received events

00:10:15,420 --> 00:10:20,010
in this case you received a message with

00:10:17,580 --> 00:10:29,550
data and accompany with the to source

00:10:20,010 --> 00:10:31,950
addresses of the of the message so to

00:10:29,550 --> 00:10:34,950
summarize so far we have established

00:10:31,950 --> 00:10:37,170
article communication groups the user

00:10:34,950 --> 00:10:40,530
can create its own group which means it

00:10:37,170 --> 00:10:43,260
can actually create its own private

00:10:40,530 --> 00:10:45,140
instances of a broker liske message bus

00:10:43,260 --> 00:10:47,700
but very low level at the socket level

00:10:45,140 --> 00:10:49,290
it will have the same addressing

00:10:47,700 --> 00:10:52,140
property properties as I described

00:10:49,290 --> 00:10:54,480
earlier and as we are used to build

00:10:52,140 --> 00:10:56,370
Tipsy for those who know it but it will

00:10:54,480 --> 00:10:57,720
have very different traffic properties

00:10:56,370 --> 00:11:00,450
which they will come back to it will be

00:10:57,720 --> 00:11:03,450
possible to avoid ever losing any

00:11:00,450 --> 00:11:05,120
messages and we have these for

00:11:03,450 --> 00:11:07,260
distribution methods I mentioned

00:11:05,120 --> 00:11:08,820
sequence order and delivery can be

00:11:07,260 --> 00:11:10,740
guaranteed and even between the

00:11:08,820 --> 00:11:12,390
different different even distribution

00:11:10,740 --> 00:11:15,089
methods which I'll come back to that was

00:11:12,390 --> 00:11:17,760
a tricky problem and what is more we can

00:11:15,089 --> 00:11:20,310
leverage l to Bro cost and UDP multi

00:11:17,760 --> 00:11:22,020
cost when we see that as favorable when

00:11:20,310 --> 00:11:24,440
we saw sending broadcast a multi costs

00:11:22,020 --> 00:11:24,440
in the group

00:11:24,560 --> 00:11:30,690
so this makes it possible to introduce

00:11:26,760 --> 00:11:32,850
em to end flow control and sock it to

00:11:30,690 --> 00:11:34,530
socket flow control and this means never

00:11:32,850 --> 00:11:36,930
messages will never be dropped because

00:11:34,530 --> 00:11:38,730
the destination buffer overflow we can

00:11:36,930 --> 00:11:41,040
use this mechanism both for multicast

00:11:38,730 --> 00:11:44,190
broadcast unicast any cost

00:11:41,040 --> 00:11:47,450
all the destiny distribution methods for

00:11:44,190 --> 00:11:50,190
point to point and point to multi-point

00:11:47,450 --> 00:11:52,580
we use just a regular sliding window

00:11:50,190 --> 00:11:55,290
algorithm it's nothing magic with that

00:11:52,580 --> 00:11:56,880
for the more tricky problem multi-point

00:11:55,290 --> 00:11:59,460
the point which have actually also

00:11:56,880 --> 00:12:01,110
solved we use a little little more

00:11:59,460 --> 00:12:08,340
elaborate matter it's still a sliding

00:12:01,110 --> 00:12:11,250
window but a little smarter so group uni

00:12:08,340 --> 00:12:12,960
costs I think I've already said what I

00:12:11,250 --> 00:12:14,810
needed to say about that so I just skip

00:12:12,960 --> 00:12:19,200
that slide

00:12:14,810 --> 00:12:21,870
group Yannick any cost also mentioned

00:12:19,200 --> 00:12:24,720
that there are two more things to add

00:12:21,870 --> 00:12:27,270
here the first thing is that apart from

00:12:24,720 --> 00:12:29,370
a round robin algorithms selecting

00:12:27,270 --> 00:12:33,690
between the members here the two members

00:12:29,370 --> 00:12:35,520
28 as you'll see here the sender will

00:12:33,690 --> 00:12:37,770
actually also look at the advertised

00:12:35,520 --> 00:12:39,030
window since we have low control now he

00:12:37,770 --> 00:12:42,570
will look look at the advertised window

00:12:39,030 --> 00:12:45,390
from his selected destination and if he

00:12:42,570 --> 00:12:48,150
finds that that window is too small he

00:12:45,390 --> 00:12:50,430
will look further until he finds one

00:12:48,150 --> 00:12:52,110
hopefully which has a big enough window

00:12:50,430 --> 00:12:55,290
and it will send a window send a message

00:12:52,110 --> 00:12:58,650
to that destination so this way we have

00:12:55,290 --> 00:13:02,820
actually achieved simple but powerful

00:12:58,650 --> 00:13:04,920
load balancing at the socket level of

00:13:02,820 --> 00:13:06,630
course it may happen that you don't find

00:13:04,920 --> 00:13:09,180
anybody with enough window to send a

00:13:06,630 --> 00:13:10,560
message and then as you would expect the

00:13:09,180 --> 00:13:13,290
socket or block correct will return e

00:13:10,560 --> 00:13:17,820
again until one of the members receive

00:13:13,290 --> 00:13:20,910
enough window another thing to mention

00:13:17,820 --> 00:13:24,300
here is that any socket the sender's

00:13:20,910 --> 00:13:27,300
okay can make itself eligible for for

00:13:24,300 --> 00:13:31,290
receiving its own messages it's what

00:13:27,300 --> 00:13:32,940
we've got a loopback option so if this

00:13:31,290 --> 00:13:37,470
member to the left the sending member

00:13:32,940 --> 00:13:38,230
who has member ID 60 here if it instead

00:13:37,470 --> 00:13:41,020
had member

00:13:38,230 --> 00:13:43,540
28 doesn't to other to the right he

00:13:41,020 --> 00:13:46,560
would receive his own share of his

00:13:43,540 --> 00:13:49,300
entire set this option he would reserve

00:13:46,560 --> 00:13:53,530
receive his own share of this any cost

00:13:49,300 --> 00:13:55,180
messages the same goes for multi cost he

00:13:53,530 --> 00:13:57,550
can make himself eligible for receiving

00:13:55,180 --> 00:14:02,590
loopback otherwise there is nothing more

00:13:57,550 --> 00:14:04,390
to add here and for broadcast he can he

00:14:02,590 --> 00:14:09,790
will he will send it out and he can make

00:14:04,390 --> 00:14:11,440
himself eligible for it now for the rest

00:14:09,790 --> 00:14:12,700
of this presentation to understand the

00:14:11,440 --> 00:14:15,820
rest of this presentation means some

00:14:12,700 --> 00:14:18,900
more background here and that is that in

00:14:15,820 --> 00:14:22,080
tip see we have traditionally a way of

00:14:18,900 --> 00:14:26,230
distributing reliable broad costs

00:14:22,080 --> 00:14:28,810
between nodes and once again not between

00:14:26,230 --> 00:14:31,210
sockets but Duty notes using what we

00:14:28,810 --> 00:14:34,690
call a broadcast links you actually you

00:14:31,210 --> 00:14:37,660
can send a message leveraging using l2

00:14:34,690 --> 00:14:39,940
on internet broadcast or you can use UDP

00:14:37,660 --> 00:14:41,680
multicast and a message will as you will

00:14:39,940 --> 00:14:45,040
see on the left hand side here deliver

00:14:41,680 --> 00:14:46,570
to all note indiscriminately all the

00:14:45,040 --> 00:14:49,120
blue dots here are nodes in this case

00:14:46,570 --> 00:14:51,430
they are not sockets and the message

00:14:49,120 --> 00:14:53,260
will be delivered by the switch or the

00:14:51,430 --> 00:14:55,840
switch infrastructure to all nodes in

00:14:53,260 --> 00:14:57,550
the whole cluster this of course may be

00:14:55,840 --> 00:14:59,560
a little wasteful if you look at the red

00:14:57,550 --> 00:15:05,050
dots here which actually which represent

00:14:59,560 --> 00:15:07,330
the actual destinations the dohsa

00:15:05,050 --> 00:15:10,600
sockets and you see here you have 20

00:15:07,330 --> 00:15:13,710
nodes and the message is delivered to

00:15:10,600 --> 00:15:16,270
all these nodes although there are only

00:15:13,710 --> 00:15:21,810
four actual destination distribute

00:15:16,270 --> 00:15:24,340
across three nodes so in this case the

00:15:21,810 --> 00:15:25,990
sender can try to be smarter he can

00:15:24,340 --> 00:15:29,410
identify that yeah there is actually

00:15:25,990 --> 00:15:31,600
only three destination nodes here so let

00:15:29,410 --> 00:15:33,670
me send this message as discrete

00:15:31,600 --> 00:15:35,430
messages to these nodes instead and let

00:15:33,670 --> 00:15:38,530
the node in turn be distributed to its

00:15:35,430 --> 00:15:40,960
sockets so that is possible to do and

00:15:38,530 --> 00:15:43,900
there are two reasons for wanting this

00:15:40,960 --> 00:15:46,600
the one is perceived efficiency of using

00:15:43,900 --> 00:15:48,040
bandwidth and using your CPU power the

00:15:46,600 --> 00:15:49,810
other one is that some infrastructures

00:15:48,040 --> 00:15:51,880
nowadays actually don't simply don't

00:15:49,810 --> 00:15:54,300
allow multi cause to be used in the

00:15:51,880 --> 00:15:58,990
well for instance some infrastructures

00:15:54,300 --> 00:16:01,750
so you can choose then the problem

00:15:58,990 --> 00:16:04,480
arises if you want on-the-fly

00:16:01,750 --> 00:16:08,200
for instance if a new member comes up so

00:16:04,480 --> 00:16:10,390
that you that Triggs the selection

00:16:08,200 --> 00:16:13,120
algorithm algorithm selection algorithm

00:16:10,390 --> 00:16:17,320
to say it's put it that way to switch

00:16:13,120 --> 00:16:19,480
methods which algorithm then this

00:16:17,320 --> 00:16:23,560
message will pass through different data

00:16:19,480 --> 00:16:25,360
ports and there is a risk of the message

00:16:23,560 --> 00:16:26,860
being delivered in out of order so we

00:16:25,360 --> 00:16:30,310
have to deal with that problem and we

00:16:26,860 --> 00:16:33,780
have done that and that is what we are

00:16:30,310 --> 00:16:47,710
doing on this slide shown on this slide

00:16:33,780 --> 00:16:52,270
so each each row cost ever sent out is

00:16:47,710 --> 00:16:54,760
contains sequence number and each member

00:16:52,270 --> 00:16:57,580
keeps track of which was the lost

00:16:54,760 --> 00:17:04,030
sequence broadcast sequence number it

00:16:57,580 --> 00:17:06,189
received from a certain socket so

00:17:04,030 --> 00:17:07,780
because of this when you receive a

00:17:06,189 --> 00:17:11,319
broadcast out of order because we are

00:17:07,780 --> 00:17:14,350
switched algorithm each receiving node

00:17:11,319 --> 00:17:16,060
will track this it receives maybe and it

00:17:14,350 --> 00:17:17,860
was n plus 1 and it was expecting

00:17:16,060 --> 00:17:19,810
message number and it will put it

00:17:17,860 --> 00:17:23,470
reordering queue and wait until the

00:17:19,810 --> 00:17:25,930
missing broadcast arrives and it will

00:17:23,470 --> 00:17:32,440
rearrange it and deliver it in in order

00:17:25,930 --> 00:17:34,180
that problem is solved also unit cost

00:17:32,440 --> 00:17:36,550
across the Allagash sequence er the

00:17:34,180 --> 00:17:38,620
guarantee and that covers also any cost

00:17:36,550 --> 00:17:41,280
because that is at the link level at the

00:17:38,620 --> 00:17:43,300
lower levels implemented as unicast

00:17:41,280 --> 00:17:44,950
here we don't need to do anything

00:17:43,300 --> 00:17:47,470
because that is already taken care of

00:17:44,950 --> 00:17:50,560
about the link layer inclusive delivery

00:17:47,470 --> 00:17:52,780
up to the socket layer so that comes by

00:17:50,560 --> 00:17:58,360
come for free with the already existing

00:17:52,780 --> 00:18:02,020
tips infrastructure then comes a more

00:17:58,360 --> 00:18:04,870
tricky problem what if I first send a

00:18:02,020 --> 00:18:05,810
unicast and then send a broadcast how do

00:18:04,870 --> 00:18:07,670
I guarantee that

00:18:05,810 --> 00:18:09,200
this broadcast is delivered to a

00:18:07,670 --> 00:18:11,720
particular node if you look at message

00:18:09,200 --> 00:18:14,030
number one here and and which is a unit

00:18:11,720 --> 00:18:15,770
cost and message number two which is a

00:18:14,030 --> 00:18:20,650
broker how do I guarantee that this node

00:18:15,770 --> 00:18:22,910
this socket number 28 member 28 I

00:18:20,650 --> 00:18:25,520
receives message number two after

00:18:22,910 --> 00:18:28,450
message number one and the trick here is

00:18:25,520 --> 00:18:31,040
we leverage this correctly cost

00:18:28,450 --> 00:18:33,170
replicated broadcast method at present

00:18:31,040 --> 00:18:35,330
presented earlier so the sender socket

00:18:33,170 --> 00:18:36,560
will keep track of what was a what type

00:18:35,330 --> 00:18:40,250
of message was the previous message

00:18:36,560 --> 00:18:42,550
message I sent so when somebody's trying

00:18:40,250 --> 00:18:44,990
to send a broadcast and in the second

00:18:42,550 --> 00:18:47,510
picture here here eyes okay the previous

00:18:44,990 --> 00:18:51,320
one was a unicast so I should send this

00:18:47,510 --> 00:18:53,720
as a replicated unicast and these

00:18:51,320 --> 00:18:59,300
messages all even the message to number

00:18:53,720 --> 00:19:01,970
28 will follow the same data path as as

00:18:59,300 --> 00:19:06,470
the others as the únicos so this way

00:19:01,970 --> 00:19:08,860
there is no risk of any real drink now

00:19:06,470 --> 00:19:11,570
conscious comes the next problem yes but

00:19:08,860 --> 00:19:13,280
it's all for the first message but we

00:19:11,570 --> 00:19:15,320
don't want to continue being forced to

00:19:13,280 --> 00:19:16,580
continue having the send broadcast as

00:19:15,320 --> 00:19:19,460
replicated a unicast

00:19:16,580 --> 00:19:21,080
for the for the future we want at some

00:19:19,460 --> 00:19:24,800
moment to be able to change the switch

00:19:21,080 --> 00:19:27,470
freely and then we have solved that in

00:19:24,800 --> 00:19:30,470
such a way that we let these correctly

00:19:27,470 --> 00:19:32,360
case to be replicate the broadcasts they

00:19:30,470 --> 00:19:34,130
contain a bit each each packet container

00:19:32,360 --> 00:19:35,420
or message contains a bit saying I want

00:19:34,130 --> 00:19:38,840
an acknowledge when you have received

00:19:35,420 --> 00:19:40,220
this so each the sender will actually

00:19:38,840 --> 00:19:42,320
stop and wait for all these

00:19:40,220 --> 00:19:44,930
technologists from all decks full it's

00:19:42,320 --> 00:19:46,910
known destinations and when he has

00:19:44,930 --> 00:19:49,190
received that he can go on sending other

00:19:46,910 --> 00:19:51,530
broadcast and at that moment he is free

00:19:49,190 --> 00:19:54,230
to choose broadcast algorithm as he

00:19:51,530 --> 00:19:58,720
wants either as true broadcast multicast

00:19:54,230 --> 00:19:58,720
or as replicated broadcast

00:20:05,570 --> 00:20:11,120
then comes the next problem which is the

00:20:08,690 --> 00:20:13,250
opposite and different and much more

00:20:11,120 --> 00:20:17,380
likely to happen actually what if I send

00:20:13,250 --> 00:20:20,150
a broadcast center censor broadcast and

00:20:17,380 --> 00:20:22,690
thereafter sense a unicast how do I

00:20:20,150 --> 00:20:25,070
guarantee that that the unicast does not

00:20:22,690 --> 00:20:28,250
bypass the broadcast and is delivered

00:20:25,070 --> 00:20:29,990
before the broadcast especially since

00:20:28,250 --> 00:20:32,179
the unit costs as we saw in some

00:20:29,990 --> 00:20:34,100
previous slides don't necessarily oh

00:20:32,179 --> 00:20:35,570
they don't need to contain their own

00:20:34,100 --> 00:20:39,500
seekers number because they don't have

00:20:35,570 --> 00:20:41,929
to the solution to that is also it's

00:20:39,500 --> 00:20:44,000
actually simple you let the unit cost

00:20:41,929 --> 00:20:50,650
contained abroad the sequence number or

00:20:44,000 --> 00:20:53,240
the previously sent probe cost so when

00:20:50,650 --> 00:20:57,380
this second unit cost on the right hand

00:20:53,240 --> 00:20:59,990
side is sent the receiver will realize

00:20:57,380 --> 00:21:01,910
ok I received number a unit cost here

00:20:59,990 --> 00:21:04,150
that is telling me that the pre the

00:21:01,910 --> 00:21:06,679
preceding broadcast was number n plus 1

00:21:04,150 --> 00:21:10,660
but I have actually only received number

00:21:06,679 --> 00:21:13,100
n so it will put the unit cost into its

00:21:10,660 --> 00:21:14,990
reordering queue wait for the missing

00:21:13,100 --> 00:21:18,140
broadcast and when that arrives it will

00:21:14,990 --> 00:21:24,950
reorder and deliver in order so that way

00:21:18,140 --> 00:21:27,950
we have solved this problem next problem

00:21:24,950 --> 00:21:30,919
is flow control and there we have point

00:21:27,950 --> 00:21:33,590
to point and multi-point point to

00:21:30,919 --> 00:21:35,270
multi-point and this is quite

00:21:33,590 --> 00:21:48,080
straightforward in reality because we

00:21:35,270 --> 00:21:51,169
have over here because we have a record

00:21:48,080 --> 00:21:54,230
each socket keeps a record for all the

00:21:51,169 --> 00:21:58,580
other members it can also keep an advert

00:21:54,230 --> 00:22:01,360
a window to that particular to each

00:21:58,580 --> 00:22:04,190
member and it will also keep an

00:22:01,360 --> 00:22:06,350
advertised how much it has advertised

00:22:04,190 --> 00:22:08,030
each other member at any moment so when

00:22:06,350 --> 00:22:12,230
this member number 60 is sending a

00:22:08,030 --> 00:22:13,850
message he will look at for instance if

00:22:12,230 --> 00:22:16,460
he is sending a broadcast he will look

00:22:13,850 --> 00:22:18,380
at the window for that for all members

00:22:16,460 --> 00:22:19,170
and find if there's anybody who has two

00:22:18,380 --> 00:22:20,280
small window

00:22:19,170 --> 00:22:22,380
have to wait until I have more

00:22:20,280 --> 00:22:23,820
advertisement for bells or if you're

00:22:22,380 --> 00:22:25,520
sending a unicast it just looks at the

00:22:23,820 --> 00:22:27,690
window for that particular destination

00:22:25,520 --> 00:22:30,080
nothing special without the naughty

00:22:27,690 --> 00:22:30,080
magic

00:22:30,930 --> 00:22:34,710
the next problem is a classic one and

00:22:33,600 --> 00:22:38,220
quite tricky one

00:22:34,710 --> 00:22:39,930
what if multiple members who all members

00:22:38,220 --> 00:22:43,110
decide that the same OMA to throw

00:22:39,930 --> 00:22:45,960
themselves on one particular member and

00:22:43,110 --> 00:22:47,610
send himself send a message to it it's

00:22:45,960 --> 00:22:49,530
quite easy to overwhelm it with the

00:22:47,610 --> 00:22:54,750
messages and overwhelmed receiver for

00:22:49,530 --> 00:22:56,310
that member turned 28 down there so we

00:22:54,750 --> 00:22:59,730
must not allow this to happen we must

00:22:56,310 --> 00:23:01,800
find us as reliable secure algorithm

00:22:59,730 --> 00:23:06,780
theoretically secure algorithmic or

00:23:01,800 --> 00:23:09,630
algorithmic and avoid that and the real

00:23:06,780 --> 00:23:12,000
problem here is that you cannot let one

00:23:09,630 --> 00:23:14,010
member if the group is big you cannot

00:23:12,000 --> 00:23:17,340
let this each member advertise a

00:23:14,010 --> 00:23:18,510
sufficiently reasonable lower window to

00:23:17,340 --> 00:23:20,490
all the other members in the group

00:23:18,510 --> 00:23:22,200
because then he is guaranteed to be

00:23:20,490 --> 00:23:24,240
overwhelmed at some moment so there must

00:23:22,200 --> 00:23:27,680
be some restraint to this some

00:23:24,240 --> 00:23:31,020
limitation and the way we have done that

00:23:27,680 --> 00:23:33,990
that is that we let each member set an

00:23:31,020 --> 00:23:36,660
absolute upper limit for how much it can

00:23:33,990 --> 00:23:41,450
be it allows itself to advertise

00:23:36,660 --> 00:23:41,450
combined to all the peer members and

00:23:41,630 --> 00:23:47,220
then he makes advertisement selectively

00:23:44,450 --> 00:23:50,310
so it doesn't treat all other members

00:23:47,220 --> 00:23:53,490
equally he starts out with giving them

00:23:50,310 --> 00:23:55,830
all a very small window just as big as

00:23:53,490 --> 00:23:58,550
needed for them to send one single

00:23:55,830 --> 00:24:03,900
maxsize message without being blocked

00:23:58,550 --> 00:24:05,910
then when he receives a message from one

00:24:03,900 --> 00:24:07,620
of these members then he would send it

00:24:05,910 --> 00:24:09,420
out a much bigger window and tell you

00:24:07,620 --> 00:24:12,120
can continue now so if he's making the

00:24:09,420 --> 00:24:14,010
assumption that if somebody is sending

00:24:12,120 --> 00:24:15,810
you a message it's likely that it will

00:24:14,010 --> 00:24:17,280
be more it's more likely that he will

00:24:15,810 --> 00:24:22,560
send more messages than anybody else

00:24:17,280 --> 00:24:24,270
will do and he keeps that in a active

00:24:22,560 --> 00:24:29,160
member list currently active member

00:24:24,270 --> 00:24:32,070
lists and giving this these members in

00:24:29,160 --> 00:24:32,960
that list continuously more window than

00:24:32,070 --> 00:24:35,190
the others

00:24:32,960 --> 00:24:37,320
then of course you will at some moment

00:24:35,190 --> 00:24:42,450
come to a limit when you have exhausted

00:24:37,320 --> 00:24:45,210
all your all your advertising resources

00:24:42,450 --> 00:24:46,919
and then some new member comes in and

00:24:45,210 --> 00:24:49,980
sends your message somebody who has just

00:24:46,919 --> 00:24:51,899
a minimum window and he also wants to

00:24:49,980 --> 00:24:54,750
become an active and a big have a big

00:24:51,899 --> 00:24:57,840
window what does what do we do then the

00:24:54,750 --> 00:25:00,059
receiver he will he will look at the

00:24:57,840 --> 00:25:02,279
list and he will look at who was the

00:25:00,059 --> 00:25:04,200
least active of the active one who was

00:25:02,279 --> 00:25:07,470
did which was longest the NGO who sent

00:25:04,200 --> 00:25:10,200
me a message and will pick up that

00:25:07,470 --> 00:25:12,240
Center that member send him a reclaim

00:25:10,200 --> 00:25:15,059
message and tell give me back summary

00:25:12,240 --> 00:25:16,860
window that advertised you because

00:25:15,059 --> 00:25:19,080
you're not using it anyway I need it for

00:25:16,860 --> 00:25:22,139
somebody else and he will receive a

00:25:19,080 --> 00:25:25,710
message back after a short while with

00:25:22,139 --> 00:25:27,240
this with this reimbursed advertisement

00:25:25,710 --> 00:25:31,009
and he can give it to the new guy so

00:25:27,240 --> 00:25:34,169
it's a sort of scheduling algorithm and

00:25:31,009 --> 00:25:35,370
this has turned out to work well and the

00:25:34,169 --> 00:25:38,970
only thing that would happen if you

00:25:35,370 --> 00:25:40,470
really start to overwhelm too many

00:25:38,970 --> 00:25:42,389
centers we start over wellness a

00:25:40,470 --> 00:25:44,519
receiver with too many messages is that

00:25:42,389 --> 00:25:47,250
the whole thing will start to go little

00:25:44,519 --> 00:25:52,740
slower but it will have a crash it'll

00:25:47,250 --> 00:25:54,720
never fail and given that this is not

00:25:52,740 --> 00:26:01,320
probably not very frequent occasions

00:25:54,720 --> 00:26:02,490
this is acceptable so one question that

00:26:01,320 --> 00:26:03,929
may arise when you hear this

00:26:02,490 --> 00:26:07,350
presentation is what can this be used

00:26:03,929 --> 00:26:09,090
for what is the idea with this first of

00:26:07,350 --> 00:26:11,759
all what we have created is it's a I

00:26:09,090 --> 00:26:14,279
would say it's a low level broker free

00:26:11,759 --> 00:26:16,860
message bus in its own right so you can

00:26:14,279 --> 00:26:18,809
buy just using sockets and doing sets or

00:26:16,860 --> 00:26:21,779
cups and send and the regular socket

00:26:18,809 --> 00:26:23,250
operations you can do use this as a

00:26:21,779 --> 00:26:24,809
message bus without a broker

00:26:23,250 --> 00:26:28,620
I broke a free message because that's a

00:26:24,809 --> 00:26:30,240
very strong point we do actually also

00:26:28,620 --> 00:26:32,039
have a small library on top of this to

00:26:30,240 --> 00:26:34,559
make it easier to use it but it's no

00:26:32,039 --> 00:26:36,269
obligation to use it and of course we

00:26:34,559 --> 00:26:38,039
could elaborate this and create some

00:26:36,269 --> 00:26:39,500
full-fledged messages on top of this

00:26:38,039 --> 00:26:43,830
which is something we are considering

00:26:39,500 --> 00:26:44,750
and other possibilities that we could we

00:26:43,830 --> 00:26:47,780
could

00:26:44,750 --> 00:26:51,650
port existing message buses like rabbit

00:26:47,780 --> 00:26:55,010
mq 0 mq drift etc too tipsy to make use

00:26:51,650 --> 00:26:57,410
of this broker free infrastructure when

00:26:55,010 --> 00:26:59,090
it comes to 0 mq it has already be

00:26:57,410 --> 00:27:02,840
important to tip seats it's worked with

00:26:59,090 --> 00:27:04,040
tipsy but we have so far not it's so far

00:27:02,840 --> 00:27:09,110
not taking advantage of the group

00:27:04,040 --> 00:27:10,880
messaging feature here another thing

00:27:09,110 --> 00:27:14,000
it's very useful for is keeping a very

00:27:10,880 --> 00:27:15,980
tight overview over the physical and

00:27:14,000 --> 00:27:17,660
software topology in a cluster because

00:27:15,980 --> 00:27:21,980
you will have immediate feedback for any

00:27:17,660 --> 00:27:25,820
changes up and down of nodes of no all

00:27:21,980 --> 00:27:28,040
sockets and if you combine this with for

00:27:25,820 --> 00:27:32,090
instance consensus protocol you may know

00:27:28,040 --> 00:27:33,980
about Paxos or raft then i think this

00:27:32,090 --> 00:27:36,280
would be a perfect match specially tips

00:27:33,980 --> 00:27:39,740
plus raft which is i think is the most

00:27:36,280 --> 00:27:41,870
most popular consensus of protocol now i

00:27:39,740 --> 00:27:45,530
think that will be a very exciting a

00:27:41,870 --> 00:27:48,050
very interesting combination to see so

00:27:45,530 --> 00:27:50,150
to summarize this whole thing what is

00:27:48,050 --> 00:27:53,150
the advantage of this over other models

00:27:50,150 --> 00:27:55,130
tcp or you can set about instead of

00:27:53,150 --> 00:27:58,370
course that a full brush of TCP

00:27:55,130 --> 00:27:59,810
connections or you can use TCP

00:27:58,370 --> 00:28:02,150
connections or you can use something

00:27:59,810 --> 00:28:05,590
else well first of all it connects it

00:28:02,150 --> 00:28:07,940
provides a sort of connection less

00:28:05,590 --> 00:28:09,440
messaging of local Datagram messaging

00:28:07,940 --> 00:28:11,180
flow with flow control I would claim

00:28:09,440 --> 00:28:16,400
although within a closed group but this

00:28:11,180 --> 00:28:18,980
group can be quite big you can also a

00:28:16,400 --> 00:28:21,170
loss free multi costs as I mentioned

00:28:18,980 --> 00:28:23,870
earlier as opposed to traditional UDP

00:28:21,170 --> 00:28:26,330
multi caused groups the programming

00:28:23,870 --> 00:28:28,940
model is very simple you have one single

00:28:26,330 --> 00:28:30,950
socket I need to all open and for that

00:28:28,940 --> 00:28:32,720
you can you can do sending you can

00:28:30,950 --> 00:28:35,060
receiving and you can even receive

00:28:32,720 --> 00:28:39,770
membership events in it directly in the

00:28:35,060 --> 00:28:41,870
socket it's a proper and sequence

00:28:39,770 --> 00:28:43,700
reality girl cardinality is guarantee

00:28:41,870 --> 00:28:46,700
without any effort whatsoever by the

00:28:43,700 --> 00:28:48,890
user then this of course is much more

00:28:46,700 --> 00:28:52,610
memory and if resource efficient than

00:28:48,890 --> 00:28:55,220
any other options you have one single

00:28:52,610 --> 00:28:57,410
for instance we know that a socket in

00:28:55,220 --> 00:29:02,320
Linux occupies

00:28:57,410 --> 00:29:02,320
4k quote from David Miller I think and

00:29:02,410 --> 00:29:07,520
if you would try to create this kind of

00:29:05,930 --> 00:29:10,580
group with a full mesh of TCP

00:29:07,520 --> 00:29:13,280
connections you would at each member you

00:29:10,580 --> 00:29:16,070
would end up with having it imagine you

00:29:13,280 --> 00:29:17,270
have a group of M and members at each

00:29:16,070 --> 00:29:20,300
members you would have to create any

00:29:17,270 --> 00:29:26,110
sockets so with the end times for K in

00:29:20,300 --> 00:29:29,990
memory just memory consumption and then

00:29:26,110 --> 00:29:31,730
also the communication the Tipsy group

00:29:29,990 --> 00:29:35,690
communication itself it needs only one

00:29:31,730 --> 00:29:38,210
socket plus one record internal record

00:29:35,690 --> 00:29:41,110
per destination this record is 80 bytes

00:29:38,210 --> 00:29:43,430
of size which is a huge difference so

00:29:41,110 --> 00:29:46,100
that's only the only memory you will

00:29:43,430 --> 00:29:48,560
occupy then you of course also got

00:29:46,100 --> 00:29:50,450
reservation if you use TCP or Tipsy

00:29:48,560 --> 00:29:54,680
connections you would reserve a full

00:29:50,450 --> 00:29:58,310
window for each socket in this case you

00:29:54,680 --> 00:30:02,180
reserved a big number of the minimal

00:29:58,310 --> 00:30:06,710
window size and as much smaller number

00:30:02,180 --> 00:30:09,610
of the maximum window size for four for

00:30:06,710 --> 00:30:13,510
advertisement and four receive cues

00:30:09,610 --> 00:30:16,310
another feature here is that since I

00:30:13,510 --> 00:30:17,750
never like to use timers also very

00:30:16,310 --> 00:30:21,890
undetermined istic in the behavior I

00:30:17,750 --> 00:30:24,320
always look for for deterministic

00:30:21,890 --> 00:30:27,290
solutions I have avoided timers in these

00:30:24,320 --> 00:30:29,390
solutions and it's fully possible this

00:30:27,290 --> 00:30:32,570
is also a very bandwidth efficient if

00:30:29,390 --> 00:30:36,020
you look to the full mesh alternative

00:30:32,570 --> 00:30:40,310
because we can use l2 broadcast or UDP

00:30:36,020 --> 00:30:42,140
multicast whenever it's possible and it

00:30:40,310 --> 00:30:43,610
scales we have tried this it scales to

00:30:42,140 --> 00:30:47,090
hundreds of members without any problems

00:30:43,610 --> 00:30:49,250
and it'll Evers leverages all the other

00:30:47,090 --> 00:30:51,980
known tips advantages like service

00:30:49,250 --> 00:30:54,400
addressing we don't know where no where

00:30:51,980 --> 00:30:58,100
our service is we just use this address

00:30:54,400 --> 00:31:00,200
of our own choice and also we will

00:30:58,100 --> 00:31:02,780
receive this immediate reception of

00:31:00,200 --> 00:31:07,280
membership events without any active

00:31:02,780 --> 00:31:09,110
monitoring of the peers if you want more

00:31:07,280 --> 00:31:10,720
information we have a home page for

00:31:09,110 --> 00:31:14,029
tipsy

00:31:10,720 --> 00:31:16,639
ww-why Pio or just type sit tip zero

00:31:14,029 --> 00:31:20,389
tayo will unify knit and we do have a

00:31:16,639 --> 00:31:23,000
project page at SourceForge you can try

00:31:20,389 --> 00:31:24,230
and that is where you'll find all

00:31:23,000 --> 00:31:27,230
information at the project page you'll

00:31:24,230 --> 00:31:31,519
find demos and test programs and stuff

00:31:27,230 --> 00:31:36,730
to download and API demos for instance

00:31:31,519 --> 00:31:39,759
for Java for Python for for a goal etc

00:31:36,730 --> 00:31:48,919
so that's what I had thank you very much

00:31:39,759 --> 00:31:50,240
questions hello I was wondering if you

00:31:48,919 --> 00:31:53,450
could talk a little bit more about your

00:31:50,240 --> 00:31:56,960
failure modes when nodes disappear for

00:31:53,450 --> 00:31:59,350
example in the case where new node is

00:31:56,960 --> 00:32:03,500
requesting a window and you need to

00:31:59,350 --> 00:32:05,450
release the window that was owned by

00:32:03,500 --> 00:32:07,009
another node which has like say it's

00:32:05,450 --> 00:32:09,019
Nick died or something and you're gonna

00:32:07,009 --> 00:32:11,539
say okay well in order to give you a

00:32:09,019 --> 00:32:13,519
window I need to yeah get my window back

00:32:11,539 --> 00:32:15,230
but then I never get a reply so then do

00:32:13,519 --> 00:32:16,429
you have some kind of time matter what

00:32:15,230 --> 00:32:16,820
what are your failure modes look like in

00:32:16,429 --> 00:32:19,970
practice

00:32:16,820 --> 00:32:21,590
yeah well this is taken care of I don't

00:32:19,970 --> 00:32:23,570
say it's trivial but it always has taken

00:32:21,590 --> 00:32:26,509
care of so if you're sending a message

00:32:23,570 --> 00:32:28,809
and receiving an act for instance and

00:32:26,509 --> 00:32:32,029
you instead discover that that

00:32:28,809 --> 00:32:32,740
destination disappeared that counts as

00:32:32,029 --> 00:32:37,580
an ACK

00:32:32,740 --> 00:32:40,009
so you can release the window or set the

00:32:37,580 --> 00:32:42,909
zero zero you're removed released remove

00:32:40,009 --> 00:32:45,590
the whole member record for that number

00:32:42,909 --> 00:32:49,250
and how do you detect that it

00:32:45,590 --> 00:32:50,870
disappeared some kind of this is as I

00:32:49,250 --> 00:32:53,659
mentioned earlier this internal

00:32:50,870 --> 00:32:55,850
distribution or topology service so each

00:32:53,659 --> 00:32:58,460
each socket each member socket is

00:32:55,850 --> 00:33:00,950
internally subscribing to this topology

00:32:58,460 --> 00:33:02,809
service and it will receive an event

00:33:00,950 --> 00:33:04,129
from this topology service that now this

00:33:02,809 --> 00:33:05,269
member disappeared and that will happen

00:33:04,129 --> 00:33:08,210
very fast

00:33:05,269 --> 00:33:09,889
normally immediately then there is some

00:33:08,210 --> 00:33:11,960
in synchronization issues to take care

00:33:09,889 --> 00:33:14,870
of just as I mention in my second slides

00:33:11,960 --> 00:33:16,700
that yes topology sir is telling you

00:33:14,870 --> 00:33:18,710
that it disappeared but what if a

00:33:16,700 --> 00:33:21,619
message shows up later from that one

00:33:18,710 --> 00:33:22,350
graph that guy and for that I have some

00:33:21,619 --> 00:33:23,940
internal message

00:33:22,350 --> 00:33:28,549
also that is taken care of so it's

00:33:23,940 --> 00:33:28,549
guarantee all of it awesome yeah

00:33:29,809 --> 00:33:36,390
any more questions okay no more

00:33:35,370 --> 00:33:40,070
questions okay

00:33:36,390 --> 00:33:40,070
thanks Joe yeah

00:33:40,220 --> 00:33:44,279

YouTube URL: https://www.youtube.com/watch?v=j47gnGyGZRc


