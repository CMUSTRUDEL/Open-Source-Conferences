Title: Netdev 1.2 - Advanced programmability and recent updates with tc's cls_bpf - Daniel Borkmann
Publication date: 2016-10-08
Playlist: Netdev 1.2 - Day 3 - Friday October 7, 2016
Description: 
	https://netdevconf.org/1.2/session.html?daniel-borkmann
Captions: 
	00:00:09,639 --> 00:00:17,470
today I would like to talk about CC and

00:00:12,980 --> 00:00:20,450
CLS PPF the work we've been doing mostly

00:00:17,470 --> 00:00:24,590
over the course of last met deaf since

00:00:20,450 --> 00:00:26,119
now basically this talk like in a

00:00:24,590 --> 00:00:29,689
previous net deaf I gave an overview

00:00:26,119 --> 00:00:34,040
about the EPF architecture in general

00:00:29,689 --> 00:00:38,420
and this one is like in some sense a

00:00:34,040 --> 00:00:40,100
continuation of it but we like in the

00:00:38,420 --> 00:00:42,440
sense that we want to go more into a

00:00:40,100 --> 00:00:45,350
deep dive of some of the features that

00:00:42,440 --> 00:00:48,019
have been added just to give you a big

00:00:45,350 --> 00:00:51,260
picture think before that already many

00:00:48,019 --> 00:00:54,469
times it's a so a PPF is an efficient

00:00:51,260 --> 00:00:56,350
and generic in carnal by quad engine

00:00:54,469 --> 00:01:01,309
that can solve specific problems

00:00:56,350 --> 00:01:05,780
specific use cases the it's used mainly

00:01:01,309 --> 00:01:09,229
in in three different context which is

00:01:05,780 --> 00:01:13,159
networking tracing and security

00:01:09,229 --> 00:01:17,119
sandboxing and networking to many users

00:01:13,159 --> 00:01:20,270
or not only to but main users are TC

00:01:17,119 --> 00:01:22,579
then xt p which is evolving we have it

00:01:20,270 --> 00:01:25,549
in circuit filters we've seen yesterday

00:01:22,579 --> 00:01:29,380
to talk on sericata we have it in s

00:01:25,549 --> 00:01:32,350
reuse part where we can do it the maxing

00:01:29,380 --> 00:01:35,810
for it for the tracing part there's

00:01:32,350 --> 00:01:38,600
there are like two front ends today

00:01:35,810 --> 00:01:44,299
where i can use it which is perf tool

00:01:38,600 --> 00:01:47,000
itself that cannot PPF programs or the

00:01:44,299 --> 00:01:49,219
BCC which is from the IO visor project

00:01:47,000 --> 00:01:51,170
which is another front and for doing

00:01:49,219 --> 00:01:55,789
mostly tracing it has a couple of

00:01:51,170 --> 00:01:58,490
tracing scripts in sandboxing it's like

00:01:55,789 --> 00:02:02,780
SATCOM I mean it's not really EPP F but

00:01:58,490 --> 00:02:05,179
like in the kernel it is but the front

00:02:02,780 --> 00:02:08,149
end there it's classic PPF recall and

00:02:05,179 --> 00:02:11,330
there's some work going on in putting

00:02:08,149 --> 00:02:14,180
EPP F into Linux security modules when L

00:02:11,330 --> 00:02:17,659
exams it's not yet merged but some stuff

00:02:14,180 --> 00:02:20,330
is brewing there as well for it for the

00:02:17,659 --> 00:02:23,540
TC subsystem the

00:02:20,330 --> 00:02:26,630
so we're looking into CLS ppf which is

00:02:23,540 --> 00:02:29,510
in some sense classifier but not only

00:02:26,630 --> 00:02:32,300
that you can also do actions as well and

00:02:29,510 --> 00:02:35,060
in that sense it can be attached to

00:02:32,300 --> 00:02:36,860
ingress and egress of the kernel

00:02:35,060 --> 00:02:39,380
networking data path and a typical

00:02:36,860 --> 00:02:42,620
workflow that you would have as you have

00:02:39,380 --> 00:02:44,840
like a restricted C program you compile

00:02:42,620 --> 00:02:47,150
that with LLVM it has new PDF back-end

00:02:44,840 --> 00:02:50,630
it generates an object file which is

00:02:47,150 --> 00:02:53,120
like a plugin and an elf file that TC

00:02:50,630 --> 00:02:55,220
can comparison boat into the kernel so

00:02:53,120 --> 00:02:56,900
those things happen user space and in

00:02:55,220 --> 00:03:00,940
the kernel side you have verified that

00:02:56,900 --> 00:03:04,790
make sure the program doesn't do various

00:03:00,940 --> 00:03:07,850
stuff like crushing the kernel or making

00:03:04,790 --> 00:03:09,080
it unstable and after that has been

00:03:07,850 --> 00:03:12,320
passed it goes into a just-in-time

00:03:09,080 --> 00:03:14,510
compiler and then the COS PPF part

00:03:12,320 --> 00:03:17,600
itself can take the program and hook it

00:03:14,510 --> 00:03:19,880
into the data path and last but not

00:03:17,600 --> 00:03:23,080
least if there's offload available then

00:03:19,880 --> 00:03:28,370
it could can also float it to hardware

00:03:23,080 --> 00:03:31,640
IC co sppf as a complementary part to

00:03:28,370 --> 00:03:34,820
the work that is ongoing for xdp in the

00:03:31,640 --> 00:03:36,920
sense that it works on all metalizer so

00:03:34,820 --> 00:03:38,330
you can also put this to a weave device

00:03:36,920 --> 00:03:41,180
for example from image in your

00:03:38,330 --> 00:03:42,500
containers it works on sk p as input

00:03:41,180 --> 00:03:44,840
contact so you have a couple of more

00:03:42,500 --> 00:03:47,030
information available and they can be

00:03:44,840 --> 00:03:51,170
hooked to not only the ingress but also

00:03:47,030 --> 00:03:53,239
egress so in the architecture itself it

00:03:51,170 --> 00:03:54,950
consists of I'm just going over just

00:03:53,239 --> 00:03:58,640
really quickly I'm sure it consists of

00:03:54,950 --> 00:04:00,890
11 64-bit registers some of them are

00:03:58,640 --> 00:04:02,570
general purpose some of them are have

00:04:00,890 --> 00:04:05,420
special purpose for example you have one

00:04:02,570 --> 00:04:07,430
that is at the tolls frame pointer then

00:04:05,420 --> 00:04:09,860
there are like a couple of registers

00:04:07,430 --> 00:04:12,680
which are for passing arguments and

00:04:09,860 --> 00:04:15,290
that's one specific for return code you

00:04:12,680 --> 00:04:19,549
can use it for it also has two bits up

00:04:15,290 --> 00:04:20,209
registers which in particular classic

00:04:19,549 --> 00:04:21,919
PPF

00:04:20,209 --> 00:04:24,440
like the transformation makes use of

00:04:21,919 --> 00:04:27,890
does a limited sex-based program counter

00:04:24,440 --> 00:04:30,440
implicitly the instructions there are 64

00:04:27,890 --> 00:04:33,060
bit wide the same like with classic vpf

00:04:30,440 --> 00:04:35,760
and you can have maximum photo 69

00:04:33,060 --> 00:04:37,320
instructions program like there was a

00:04:35,760 --> 00:04:39,750
couple of new instructions over the

00:04:37,320 --> 00:04:43,950
classic one like you have this call

00:04:39,750 --> 00:04:45,480
instruction can make use of helper cards

00:04:43,950 --> 00:04:48,270
what the thing is I'm going to talk a

00:04:45,480 --> 00:04:53,550
bit in a moment you have instructions

00:04:48,270 --> 00:04:56,850
for the whole 64-bit operations you have

00:04:53,550 --> 00:04:58,590
an Indian s conversion and so on and so

00:04:56,850 --> 00:05:00,470
forth there are a couple of core

00:04:58,590 --> 00:05:03,030
components that are important to know

00:05:00,470 --> 00:05:06,870
you have a so called contacts which is

00:05:03,030 --> 00:05:09,570
like like an input that the EVF program

00:05:06,870 --> 00:05:11,700
works on which can be which is different

00:05:09,570 --> 00:05:15,630
like can be an escapee in networking

00:05:11,700 --> 00:05:17,760
context for XTP it's a Aspen show and I

00:05:15,630 --> 00:05:22,080
think yesterday it's like a next EP buff

00:05:17,760 --> 00:05:24,660
it's something more shrink than that and

00:05:22,080 --> 00:05:26,970
form the pair from the tracing side its

00:05:24,660 --> 00:05:32,280
various other things like you're like

00:05:26,970 --> 00:05:35,910
registers from there currently in the

00:05:32,280 --> 00:05:39,000
system and yeah so you can read and

00:05:35,910 --> 00:05:40,620
write to this context so what you can

00:05:39,000 --> 00:05:43,400
read and write to it's being made sure

00:05:40,620 --> 00:05:48,539
by the verifier itself so that is

00:05:43,400 --> 00:05:51,030
restricted the same as how it is being

00:05:48,539 --> 00:05:55,229
accessed so that you don't have an

00:05:51,030 --> 00:05:56,669
underline access for example yeah let me

00:05:55,229 --> 00:05:58,590
have to help a function concept have a

00:05:56,669 --> 00:06:01,860
function there are part of the core

00:05:58,590 --> 00:06:05,340
kernel so no modular code can add or

00:06:01,860 --> 00:06:10,020
extend their own functionality to EPF it

00:06:05,340 --> 00:06:14,070
has to go into the corner of upstream if

00:06:10,020 --> 00:06:17,750
you want to make use of that and yeah so

00:06:14,070 --> 00:06:20,700
those type of functions they yeah they

00:06:17,750 --> 00:06:22,590
provide basically some some help for

00:06:20,700 --> 00:06:24,930
example if you have a socket buffer it

00:06:22,590 --> 00:06:28,680
can do some angling that otherwise the

00:06:24,930 --> 00:06:31,470
program itself cannot do did you have

00:06:28,680 --> 00:06:34,860
maps which are some efficient q-value

00:06:31,470 --> 00:06:38,039
stars in the kernel that ebf programs

00:06:34,860 --> 00:06:40,680
use those maps that can be arbitrarily

00:06:38,039 --> 00:06:44,370
shared which means one or more a PPF

00:06:40,680 --> 00:06:45,270
program can use the same map and it can

00:06:44,370 --> 00:06:47,910
also be shared

00:06:45,270 --> 00:06:51,090
only between those EPF programs but also

00:06:47,910 --> 00:06:54,300
between user space so they can also

00:06:51,090 --> 00:06:58,020
access it at the same time then tailor

00:06:54,300 --> 00:07:00,690
calls to the concept where one IVF

00:06:58,020 --> 00:07:03,930
program can call into another one and to

00:07:00,690 --> 00:07:07,110
redirect execution it doesn't return

00:07:03,930 --> 00:07:09,870
back to the to the previous one and

00:07:07,110 --> 00:07:12,690
there's a limit in how deep you can nest

00:07:09,870 --> 00:07:15,180
those Tara calls as well then we have

00:07:12,690 --> 00:07:18,150
object pinning which is interesting when

00:07:15,180 --> 00:07:19,830
you have for example TC loading programs

00:07:18,150 --> 00:07:21,389
into the kernel because everything from

00:07:19,830 --> 00:07:23,669
user space side is managed over file

00:07:21,389 --> 00:07:27,569
descriptor and you need to somehow keep

00:07:23,669 --> 00:07:30,630
that alive in some sense because other

00:07:27,569 --> 00:07:33,150
like management demons they want to

00:07:30,630 --> 00:07:35,639
access maps at a later point in time as

00:07:33,150 --> 00:07:38,699
well so you say your PIN for example

00:07:35,639 --> 00:07:41,940
maps to personification and then you can

00:07:38,699 --> 00:07:44,699
retrieve it later point yeah in the

00:07:41,940 --> 00:07:48,000
kernel itself since it doesn't have the

00:07:44,699 --> 00:07:52,889
classic PPF interpreter anymore it has

00:07:48,000 --> 00:07:56,039
to transform like it has to migrate

00:07:52,889 --> 00:07:58,889
those programs that still like TCP dump

00:07:56,039 --> 00:08:03,300
or other users load into from classic

00:07:58,889 --> 00:08:05,880
PDF into IPPF from the OEM site there's

00:08:03,300 --> 00:08:08,419
the already mentioned DVF back-end that

00:08:05,880 --> 00:08:10,610
we have that can generate code from

00:08:08,419 --> 00:08:15,630
front-end like see like see like

00:08:10,610 --> 00:08:18,719
clanging and kernel has various backends

00:08:15,630 --> 00:08:20,130
some some are still classic PPF some are

00:08:18,719 --> 00:08:23,039
IPPF as well

00:08:20,130 --> 00:08:26,759
management is over system call to be PF

00:08:23,039 --> 00:08:31,680
system call and with that also the api

00:08:26,759 --> 00:08:36,990
has to get stable so regarding the CLS

00:08:31,680 --> 00:08:38,610
PPF and also a new cutis that we added

00:08:36,990 --> 00:08:42,089
some time ago which is called

00:08:38,610 --> 00:08:44,279
CLS act to disk so this us acutest

00:08:42,089 --> 00:08:44,940
itself which is very simple similar to

00:08:44,279 --> 00:08:47,370
the ingress

00:08:44,940 --> 00:08:50,530
queue disk it's a basically a container

00:08:47,370 --> 00:08:55,240
for holding TC classifiers and

00:08:50,530 --> 00:08:57,700
and actions and it provides two central

00:08:55,240 --> 00:08:59,770
hooks into the kernel one on the English

00:08:57,700 --> 00:09:03,820
side it's like the same hook like you

00:08:59,770 --> 00:09:06,430
have in rescue disk but it's a net of

00:09:03,820 --> 00:09:09,310
receive SPB core and from the eager side

00:09:06,430 --> 00:09:11,020
it's deaf to Exmouth it's just for

00:09:09,310 --> 00:09:13,780
compatibility reasons why it's not in

00:09:11,020 --> 00:09:14,950
the English student secure self but yeah

00:09:13,780 --> 00:09:16,810
so does two hooks they are really

00:09:14,950 --> 00:09:21,970
powerful they're on central places and

00:09:16,810 --> 00:09:26,920
you can run the CLS PDF on top of that

00:09:21,970 --> 00:09:30,040
and yeah CF p PF as i said it runs also

00:09:26,920 --> 00:09:32,710
classic p PF which it was in very in the

00:09:30,040 --> 00:09:35,080
early days when it was submitted to the

00:09:32,710 --> 00:09:37,360
kernel and they've got extended you can

00:09:35,080 --> 00:09:40,480
do also atomic updates during one time

00:09:37,360 --> 00:09:44,410
either from USB PF side itself it's it's

00:09:40,480 --> 00:09:47,440
converted to RCU but also from from tear

00:09:44,410 --> 00:09:49,840
call from from tear calls they can also

00:09:47,440 --> 00:09:53,170
be updated and in that you have a fast

00:09:49,840 --> 00:09:56,770
path which means cos p PF can be run

00:09:53,170 --> 00:10:00,550
into action mode usually you would hook

00:09:56,770 --> 00:10:02,140
into various kind of actions but in in

00:10:00,550 --> 00:10:04,210
that case since if you graph program

00:10:02,140 --> 00:10:06,280
cannot really do everything by itself it

00:10:04,210 --> 00:10:09,610
can just return an action verdict and

00:10:06,280 --> 00:10:12,220
you're done with it so the way we use it

00:10:09,610 --> 00:10:15,280
for example in NTC is to just load a

00:10:12,220 --> 00:10:18,220
single object which does all the work

00:10:15,280 --> 00:10:20,680
and then we can already return which

00:10:18,220 --> 00:10:23,830
gives a better performance as well from

00:10:20,680 --> 00:10:26,850
software side and there's now also an

00:10:23,830 --> 00:10:30,370
offload interface the privates can use

00:10:26,850 --> 00:10:32,320
and so far we have one driver for that

00:10:30,370 --> 00:10:36,610
which is great I go into that a bit

00:10:32,320 --> 00:10:40,450
later in my talk the TC front-end it has

00:10:36,610 --> 00:10:42,220
the even if they have loader it's doing

00:10:40,450 --> 00:10:44,800
quite a bit of work in the sense that it

00:10:42,220 --> 00:10:48,490
has to pass all the sections from the

00:10:44,800 --> 00:10:50,320
object file sections can contain like

00:10:48,490 --> 00:10:52,240
data for map specifications that the

00:10:50,320 --> 00:10:54,240
kernel has to set up and push them to

00:10:52,240 --> 00:10:58,030
the pushover the DPF system call

00:10:54,240 --> 00:10:59,329
retrieve the file descriptor and then to

00:10:58,030 --> 00:11:01,579
see the some real

00:10:59,329 --> 00:11:03,739
in handling which means that injects the

00:11:01,579 --> 00:11:07,009
file descriptor into the specific

00:11:03,739 --> 00:11:09,559
instructions as a immediate value which

00:11:07,009 --> 00:11:11,809
the kernel then make sure that it

00:11:09,559 --> 00:11:15,889
accesses that can actually access this

00:11:11,809 --> 00:11:20,389
map and it also does object pinning and

00:11:15,889 --> 00:11:24,470
retrieving so that you can share d maps

00:11:20,389 --> 00:11:28,459
between various programs just to give

00:11:24,470 --> 00:11:31,160
you an example so you would come you

00:11:28,459 --> 00:11:34,910
would compile your program with what

00:11:31,160 --> 00:11:37,489
clang then you can add curious this

00:11:34,910 --> 00:11:40,699
euler's actuators to advise you can can

00:11:37,489 --> 00:11:43,009
show it that it's added then you have

00:11:40,699 --> 00:11:46,069
some simple comments like TC filter adds

00:11:43,009 --> 00:11:49,399
and specifies the device then you have

00:11:46,069 --> 00:11:51,889
to parent names one for ingress or

00:11:49,399 --> 00:11:54,610
egress and then you have to bps

00:11:51,889 --> 00:11:56,989
classifier direct action mode you

00:11:54,610 --> 00:11:59,089
specify the particular object and then

00:11:56,989 --> 00:12:02,600
some sections so there can be multiple

00:11:59,089 --> 00:12:05,269
programs contained in a single object

00:12:02,600 --> 00:12:07,839
file and you can specify which one you

00:12:05,269 --> 00:12:12,230
want to load based on the section name

00:12:07,839 --> 00:12:14,149
then you go into TC filter show and when

00:12:12,230 --> 00:12:17,509
you want to remove those specifiers

00:12:14,149 --> 00:12:19,939
again one extension that we added is

00:12:17,509 --> 00:12:24,470
that you don't have to specify the D

00:12:19,939 --> 00:12:27,919
priority and then it would remove if you

00:12:24,470 --> 00:12:30,079
just specify the parent itself in this

00:12:27,919 --> 00:12:32,329
case for example ingress or egress then

00:12:30,079 --> 00:12:35,449
it would remove all classifiers that are

00:12:32,329 --> 00:12:37,249
hooked into that and that's but at least

00:12:35,449 --> 00:12:43,160
you can of course also remove to do this

00:12:37,249 --> 00:12:43,790
yourself so some of the extensions so we

00:12:43,160 --> 00:12:46,309
have

00:12:43,790 --> 00:12:51,019
tunneling and having an encapsulation so

00:12:46,309 --> 00:12:55,429
with zero sppf supports collect metadata

00:12:51,019 --> 00:12:56,989
tunnels which is a nice way how to scale

00:12:55,429 --> 00:13:00,019
your tunnels because you only have a

00:12:56,989 --> 00:13:01,879
single net device which is set in to

00:13:00,019 --> 00:13:04,579
collect meter data mode so you don't

00:13:01,879 --> 00:13:06,049
have to have specific configurations for

00:13:04,579 --> 00:13:08,839
your tunnel

00:13:06,049 --> 00:13:10,329
these are replicated over multiple net

00:13:08,839 --> 00:13:13,269
devices what you just have a single

00:13:10,329 --> 00:13:16,179
supported for this infrastructure so far

00:13:13,269 --> 00:13:19,420
as we excellent genÃ¨ve jerry various IP

00:13:16,179 --> 00:13:21,910
an IP tunnels and probably in future

00:13:19,420 --> 00:13:25,239
maybe also other other encapsulations

00:13:21,910 --> 00:13:31,019
like goo i think possible to extend as

00:13:25,239 --> 00:13:34,209
well so that's like a key structure that

00:13:31,019 --> 00:13:37,209
PPF programs fill out on the on its

00:13:34,209 --> 00:13:39,179
under stack which is kind of a generic

00:13:37,209 --> 00:13:42,189
structure that we can then push into

00:13:39,179 --> 00:13:45,249
some of the helper functions that then

00:13:42,189 --> 00:13:48,369
convert to the specific tunnel tunneling

00:13:45,249 --> 00:13:50,949
in infrastructure for example to tunnel

00:13:48,369 --> 00:13:54,519
ID which can be been ID and we have

00:13:50,949 --> 00:13:57,670
before every six destination various

00:13:54,519 --> 00:14:00,639
other fields to us TTL like flow labels

00:13:57,670 --> 00:14:02,829
which is also interesting yeah

00:14:00,639 --> 00:14:06,939
and then for tunnel options themselves

00:14:02,829 --> 00:14:08,920
they're like rob lots which in case so

00:14:06,939 --> 00:14:12,009
so far only we excellent engineer

00:14:08,920 --> 00:14:14,079
support that and crew based policy in

00:14:12,009 --> 00:14:16,600
case of the x land for Geneva it's like

00:14:14,079 --> 00:14:19,059
like a teal we block like from their

00:14:16,600 --> 00:14:21,879
protocol itself which works fine I mean

00:14:19,059 --> 00:14:24,369
it's but so definitely that but at least

00:14:21,879 --> 00:14:26,739
we have a way to pass that down and it's

00:14:24,369 --> 00:14:31,029
generic still generic enough for all the

00:14:26,739 --> 00:14:32,379
various backends and I saw all this

00:14:31,029 --> 00:14:34,899
whole thing works it's like we have a

00:14:32,379 --> 00:14:39,399
way that you see structure which like it

00:14:34,899 --> 00:14:41,110
which is like a DC entry and basically

00:14:39,399 --> 00:14:43,259
that the tunneling information is

00:14:41,110 --> 00:14:46,809
attached to that so that when s QP

00:14:43,259 --> 00:14:48,639
passes through the driver itself can

00:14:46,809 --> 00:14:51,699
read out the data or it can fill it and

00:14:48,639 --> 00:14:54,850
receive for at a point time yeah and

00:14:51,699 --> 00:14:56,410
there are like four helpers to for

00:14:54,850 --> 00:15:00,509
getting and setting the tunnel

00:14:56,410 --> 00:15:00,509
information and to for adoptions

00:15:00,910 --> 00:15:07,960
so then something we added recently

00:15:04,480 --> 00:15:10,840
there are tacit access one go into some

00:15:07,960 --> 00:15:13,470
more details here from the classic vpf

00:15:10,840 --> 00:15:18,640
site there were like two instructions

00:15:13,470 --> 00:15:20,230
load so BPF LD for for an absolute load

00:15:18,640 --> 00:15:22,030
and for an indirect load in the regular

00:15:20,230 --> 00:15:25,720
means that you have a register and then

00:15:22,030 --> 00:15:28,690
an immediate value and then this is both

00:15:25,720 --> 00:15:32,380
added together for the actual location

00:15:28,690 --> 00:15:34,780
to load data from and this was basically

00:15:32,380 --> 00:15:38,280
carried into EBP F over from the classic

00:15:34,780 --> 00:15:42,010
version the reason for this is because

00:15:38,280 --> 00:15:43,870
the just-in-time compilers have an

00:15:42,010 --> 00:15:47,980
optimization for that so that you can

00:15:43,870 --> 00:15:51,850
access this faster because they cash skp

00:15:47,980 --> 00:15:53,800
data and some things in the the image

00:15:51,850 --> 00:15:57,120
itself so you don't have to call into

00:15:53,800 --> 00:16:00,460
some helper for that for example and

00:15:57,120 --> 00:16:02,290
away and they had to introduce some

00:16:00,460 --> 00:16:04,900
build and helpers for that you can load

00:16:02,290 --> 00:16:07,270
one two and four bytes then host engine

00:16:04,900 --> 00:16:10,270
is because it was - it simply was the

00:16:07,270 --> 00:16:13,690
way in in classic PPF as well

00:16:10,270 --> 00:16:17,230
the problem with that is also that they

00:16:13,690 --> 00:16:18,760
have some suboptimal extension exception

00:16:17,230 --> 00:16:21,760
handling in the sense when you have a

00:16:18,760 --> 00:16:24,040
wrong offset or then the program

00:16:21,760 --> 00:16:27,250
basically rewards which is fine for

00:16:24,040 --> 00:16:29,590
classic stuff but for EVP after you want

00:16:27,250 --> 00:16:34,300
to have some more graceful handling and

00:16:29,590 --> 00:16:38,050
that on that side and yeah then we have

00:16:34,300 --> 00:16:42,070
helper functions so we have a PPF SPB

00:16:38,050 --> 00:16:44,860
load byte helper you don't have to it

00:16:42,070 --> 00:16:47,320
doesn't require an eejit or LLVM special

00:16:44,860 --> 00:16:50,250
handling which is nice you can load

00:16:47,320 --> 00:16:52,090
multiple bytes or just more than the

00:16:50,250 --> 00:16:54,790
restrictions from the instructions

00:16:52,090 --> 00:16:56,940
themselves can it's only limited by this

00:16:54,790 --> 00:17:00,730
tech space itself

00:16:56,940 --> 00:17:02,170
it's loaded into this tag and because of

00:17:00,730 --> 00:17:06,240
the helper function itself you can also

00:17:02,170 --> 00:17:09,699
do exception handling then for the

00:17:06,240 --> 00:17:11,650
storing so first throwing themselves for

00:17:09,699 --> 00:17:13,720
storing itself there weren't any special

00:17:11,650 --> 00:17:17,350
instructions and classic PP I ever saw

00:17:13,720 --> 00:17:20,680
so helper was for EBP F helper was added

00:17:17,350 --> 00:17:24,010
a longer time god that can basically do

00:17:20,680 --> 00:17:25,750
this store data into the s key B so it

00:17:24,010 --> 00:17:27,579
also comes with the same properties and

00:17:25,750 --> 00:17:33,400
aspects of helpers themself

00:17:27,579 --> 00:17:35,710
you can handle exceptions and if it's

00:17:33,400 --> 00:17:37,720
and it does internally some stuff like

00:17:35,710 --> 00:17:41,050
I'm cloning SVP if it has two or it

00:17:37,720 --> 00:17:42,640
pulls in not only in your data if the

00:17:41,050 --> 00:17:45,490
amount of data you want to store and

00:17:42,640 --> 00:17:49,120
reaches further than just a linear part

00:17:45,490 --> 00:17:52,540
it has some other options like checksum

00:17:49,120 --> 00:17:55,600
updating or clearing hash yeah

00:17:52,540 --> 00:17:58,090
and the direct packet access itself it

00:17:55,600 --> 00:18:03,990
was added it also was added to XT piece

00:17:58,090 --> 00:18:08,560
or a little bit of the same properties a

00:18:03,990 --> 00:18:11,170
here it tries to combine at the

00:18:08,560 --> 00:18:14,880
advantage of both of them of both of the

00:18:11,170 --> 00:18:17,920
other methods they SP be context itself

00:18:14,880 --> 00:18:21,250
got two new members so data and data

00:18:17,920 --> 00:18:23,590
ends and they can be loaded into

00:18:21,250 --> 00:18:25,240
register directly which is nice you

00:18:23,590 --> 00:18:28,630
don't have to go over your stack

00:18:25,240 --> 00:18:31,360
necessarily it doesn't require any cheat

00:18:28,630 --> 00:18:33,370
or LVM special handling so it just works

00:18:31,360 --> 00:18:37,210
out of the box for the kernel from

00:18:33,370 --> 00:18:40,660
chrono side the complexity however was

00:18:37,210 --> 00:18:43,720
pushed more into the verifier in the

00:18:40,660 --> 00:18:47,650
sense that the verifier does some

00:18:43,720 --> 00:18:50,980
pattern matching it tracks like like

00:18:47,650 --> 00:18:53,890
some conditional when you have data plus

00:18:50,980 --> 00:18:56,890
X so plus a constant offset if that

00:18:53,890 --> 00:18:58,570
reaches further than the data end then

00:18:56,890 --> 00:19:00,540
you basically have two branches one is

00:18:58,570 --> 00:19:04,050
the two per and the other ones false and

00:19:00,540 --> 00:19:06,250
you have to track on both branches

00:19:04,050 --> 00:19:14,290
basically how much data you can actually

00:19:06,250 --> 00:19:15,850
access later on yeah so it also needs to

00:19:14,290 --> 00:19:20,400
take that into account and that you

00:19:15,850 --> 00:19:23,160
don't have things like overflows

00:19:20,400 --> 00:19:26,220
in your access so it is a bit

00:19:23,160 --> 00:19:31,290
complicated and did the details but

00:19:26,220 --> 00:19:34,140
seems to work fine so far and you also

00:19:31,290 --> 00:19:38,820
have the implicit exception handling

00:19:34,140 --> 00:19:41,840
that we saw from from earlier from from

00:19:38,820 --> 00:19:44,220
other methods as well because if its

00:19:41,840 --> 00:19:46,380
larger than data and and you can still

00:19:44,220 --> 00:19:50,370
do something like put some modification

00:19:46,380 --> 00:19:53,340
somewhere or push the message to for

00:19:50,370 --> 00:19:56,210
further debugging the white part it has

00:19:53,340 --> 00:19:58,800
to be strictly uncleaned of course and

00:19:56,210 --> 00:20:00,720
since this only works in linear part

00:19:58,800 --> 00:20:03,000
there's a helper that in case you really

00:20:00,720 --> 00:20:06,360
need to go further than that it you can

00:20:03,000 --> 00:20:08,310
pull in nonlinear data as well and you

00:20:06,360 --> 00:20:11,970
just need to do this probably once and

00:20:08,310 --> 00:20:14,070
then you can still access the rest like

00:20:11,970 --> 00:20:19,560
to normal direct access way with this

00:20:14,070 --> 00:20:21,690
single test so then the other feature is

00:20:19,560 --> 00:20:24,270
the event output notifications at the

00:20:21,690 --> 00:20:27,510
idea is basically that you have a helper

00:20:24,270 --> 00:20:29,850
function where I can push some data in

00:20:27,510 --> 00:20:32,850
from the kernel to the user space

00:20:29,850 --> 00:20:37,230
direction this this thing works over

00:20:32,850 --> 00:20:39,570
localized memory mapped and per CPU ring

00:20:37,230 --> 00:20:42,690
buffer busy from perf infrastructure the

00:20:39,570 --> 00:20:45,960
whole facility was originally in tracing

00:20:42,690 --> 00:20:49,080
and we found this pretty useful and also

00:20:45,960 --> 00:20:51,660
it was like low-hanging fruit Edit for

00:20:49,080 --> 00:20:53,460
the networking side as well for you to

00:20:51,660 --> 00:20:55,890
use this basic and either a busy paul if

00:20:53,460 --> 00:20:58,530
it wants to or it can define some wakeup

00:20:55,890 --> 00:21:00,630
events for it the number of your winds

00:20:58,530 --> 00:21:03,390
or like some water mark for the number

00:21:00,630 --> 00:21:06,210
of bytes and the nice thing about this

00:21:03,390 --> 00:21:08,370
is that the ring buffers let itself is

00:21:06,210 --> 00:21:10,320
fully programmable so this thing is not

00:21:08,370 --> 00:21:12,810
part of the you API and you can for

00:21:10,320 --> 00:21:15,450
example puts skb mark or whatever you

00:21:12,810 --> 00:21:17,880
have want to have this data in this

00:21:15,450 --> 00:21:21,330
thing and it's useful for things like

00:21:17,880 --> 00:21:22,830
sampling monitoring or debugging or if

00:21:21,330 --> 00:21:25,230
you have management daemons that need

00:21:22,830 --> 00:21:29,690
some push notifications to to act or to

00:21:25,230 --> 00:21:31,820
update maps for example we use this

00:21:29,690 --> 00:21:33,889
a project which is called psyllium that

00:21:31,820 --> 00:21:37,190
we are working on not going into the

00:21:33,889 --> 00:21:38,539
details of decision project too much but

00:21:37,190 --> 00:21:40,940
they ever used it for example as the

00:21:38,539 --> 00:21:44,419
drop monitor and we can do some policy

00:21:40,940 --> 00:21:47,059
learning with that we have like a packet

00:21:44,419 --> 00:21:49,879
tracing infrastructure where we can see

00:21:47,059 --> 00:21:53,179
that what what path the program takes

00:21:49,879 --> 00:21:56,600
through our code and it's also really

00:21:53,179 --> 00:21:59,950
useful as a trace print k replacement

00:21:56,600 --> 00:22:02,090
because tray spring case rather slow and

00:21:59,950 --> 00:22:04,220
tracing but also for networking site

00:22:02,090 --> 00:22:06,740
it's it's used here because you just put

00:22:04,220 --> 00:22:09,980
in some binary data instead of having

00:22:06,740 --> 00:22:14,659
the kernel having to assemble as a

00:22:09,980 --> 00:22:18,169
string for that then some words about

00:22:14,659 --> 00:22:21,919
just-in-time compilers about offloading

00:22:18,169 --> 00:22:24,620
and trade hardening so the EPF compilers

00:22:21,919 --> 00:22:29,840
that are available today are x86 their

00:22:24,620 --> 00:22:33,710
farm 64 PowerPC 64 and s/390 so they all

00:22:29,840 --> 00:22:37,669
support IPPF hopefully more to hopefully

00:22:33,710 --> 00:22:42,799
market compilers become the piper c64

00:22:37,669 --> 00:22:45,649
was initially or got merged just

00:22:42,799 --> 00:22:50,330
recently i think the initial merge was

00:22:45,649 --> 00:22:52,700
in 4.8 and like in in this window 4.9

00:22:50,330 --> 00:22:55,460
also the tail call support but edit

00:22:52,700 --> 00:22:58,100
because teleport take calls a bit more

00:22:55,460 --> 00:23:02,750
complicated so I could get it later on

00:22:58,100 --> 00:23:07,159
also for the arm 64 telecoil support was

00:23:02,750 --> 00:23:08,269
added for 4.9 along with some other

00:23:07,159 --> 00:23:09,919
optimizations

00:23:08,269 --> 00:23:12,679
the only things still missing is the

00:23:09,919 --> 00:23:15,110
atomic add but I guess that will also

00:23:12,679 --> 00:23:19,940
come soon but otherwise they're pretty

00:23:15,110 --> 00:23:23,929
much feature complete now there's also

00:23:19,940 --> 00:23:27,530
an offloading possibility as I initially

00:23:23,929 --> 00:23:31,010
mentioned so you can load EDF to

00:23:27,530 --> 00:23:33,230
to a to a Nick and this is supported by

00:23:31,010 --> 00:23:35,330
a metronome smart Nick's through a

00:23:33,230 --> 00:23:37,760
just-in-time compiler which is really

00:23:35,330 --> 00:23:39,560
great and there will be a talk later in

00:23:37,760 --> 00:23:41,270
the afternoon about how it's done in

00:23:39,560 --> 00:23:45,560
hearted stuff works so I encourage you

00:23:41,270 --> 00:23:47,480
to go there as well in terms of

00:23:45,560 --> 00:23:51,220
hardening there are some hardening

00:23:47,480 --> 00:23:54,560
measures and that are done by default so

00:23:51,220 --> 00:23:55,730
it so nothing that saw something that

00:23:54,560 --> 00:23:59,690
has nothing not to do it necessarily

00:23:55,730 --> 00:24:01,850
widgets is that the EPF image itself is

00:23:59,690 --> 00:24:03,620
being blocked as read-only for the

00:24:01,850 --> 00:24:05,870
interpreter part in case there are some

00:24:03,620 --> 00:24:08,480
corruptions but also for the for the

00:24:05,870 --> 00:24:11,690
resulting should image so if you use one

00:24:08,480 --> 00:24:14,000
of those jets I think except PowerPC 64

00:24:11,690 --> 00:24:16,070
there it's not the case but otherwise

00:24:14,000 --> 00:24:19,280
those pages are also locked as read-only

00:24:16,070 --> 00:24:22,550
they cannot be modified and by default

00:24:19,280 --> 00:24:25,040
they have like randomize start address

00:24:22,550 --> 00:24:27,470
where you have if so if you would jump

00:24:25,040 --> 00:24:30,410
into that area that is before that you

00:24:27,470 --> 00:24:33,200
would basically have like a trap and and

00:24:30,410 --> 00:24:36,830
your kernel the reason why this is done

00:24:33,200 --> 00:24:40,400
was because there was some some work on

00:24:36,830 --> 00:24:43,190
chip spraying if you explain a bit more

00:24:40,400 --> 00:24:46,700
than that it's basically you inject lots

00:24:43,190 --> 00:24:48,920
of programs into the kernel lots of for

00:24:46,700 --> 00:24:53,260
example socket filters from user space

00:24:48,920 --> 00:24:56,810
site and those constants that are put

00:24:53,260 --> 00:25:01,010
along with the programs they can for

00:24:56,810 --> 00:25:02,330
example also can contain some some some

00:25:01,010 --> 00:25:04,070
actual up codes from one of the

00:25:02,330 --> 00:25:05,660
architecture stuff and then if you have

00:25:04,070 --> 00:25:07,820
a box somewhere else in the car no

00:25:05,660 --> 00:25:09,530
liquid jump into that then we certainly

00:25:07,820 --> 00:25:12,310
want to avoid that right and that's why

00:25:09,530 --> 00:25:14,690
those measures are being added and

00:25:12,310 --> 00:25:17,500
recently from the kind of hardening

00:25:14,690 --> 00:25:24,440
project some researcher found out that

00:25:17,500 --> 00:25:26,870
there there's still some way to where we

00:25:24,440 --> 00:25:30,140
can have this randomized app where we

00:25:26,870 --> 00:25:32,210
can overcome this limitation so that's

00:25:30,140 --> 00:25:34,940
why we added the constant blinding

00:25:32,210 --> 00:25:36,500
infrastructure which basically means

00:25:34,940 --> 00:25:39,490
that those constants there they are

00:25:36,500 --> 00:25:42,970
basically blinded out so I cannot

00:25:39,490 --> 00:25:44,679
some arbitrary opcodes this is being

00:25:42,970 --> 00:25:48,309
added to assist ETL

00:25:44,679 --> 00:25:50,590
so if devalue pbft hardened certain wand

00:25:48,309 --> 00:25:54,250
and programs are constant lined for

00:25:50,590 --> 00:25:56,740
unprivileged users but not for

00:25:54,250 --> 00:25:59,820
privileged ones a route would only can

00:25:56,740 --> 00:26:03,370
still and enjoy the full performance of

00:25:59,820 --> 00:26:05,679
that you also have a mode 2 which is

00:26:03,370 --> 00:26:08,320
useful for testing you have this test

00:26:05,679 --> 00:26:10,390
suite in decon also we can make sure

00:26:08,320 --> 00:26:14,380
that we don't have any regressions there

00:26:10,390 --> 00:26:16,840
and yeah so what it does is basically it

00:26:14,380 --> 00:26:19,149
rewrites the instructions on the PPF

00:26:16,840 --> 00:26:21,730
instruction levels and it doesn't really

00:26:19,149 --> 00:26:23,710
have to touch much of the JIT compilers

00:26:21,730 --> 00:26:26,649
themselves so it can be easily supported

00:26:23,710 --> 00:26:28,539
and it rewrites those 32 and 64 bits

00:26:26,649 --> 00:26:31,120
which is also concerned because it's

00:26:28,539 --> 00:26:35,380
like worse more space for injecting

00:26:31,120 --> 00:26:38,440
stuff and it blinds those instructions

00:26:35,380 --> 00:26:40,840
and how it does it is basically you have

00:26:38,440 --> 00:26:42,669
randomized value you have like a helper

00:26:40,840 --> 00:26:47,500
register an additional one which is only

00:26:42,669 --> 00:26:49,120
visible for portraits and you randomize

00:26:47,500 --> 00:26:52,710
your original instructions or you

00:26:49,120 --> 00:26:56,590
basically XOR that one and you're stored

00:26:52,710 --> 00:26:57,940
in the first one and then you XOR and

00:26:56,590 --> 00:27:00,700
then you have a second instruction which

00:26:57,940 --> 00:27:02,970
your ex or with the previous one as well

00:27:00,700 --> 00:27:06,250
to get back to the original value and

00:27:02,970 --> 00:27:08,110
then you have to rewrite your original

00:27:06,250 --> 00:27:11,830
instructions or operation that you're

00:27:08,110 --> 00:27:14,980
doing from an immediate based or

00:27:11,830 --> 00:27:19,419
register based one so just to give you

00:27:14,980 --> 00:27:23,169
some example this is from the original

00:27:19,419 --> 00:27:26,919
blog post like you have a couple of in

00:27:23,169 --> 00:27:29,919
loads for for immediate and as you can

00:27:26,919 --> 00:27:32,590
see here if you and if you inject

00:27:29,919 --> 00:27:34,210
something like that then the resulting

00:27:32,590 --> 00:27:37,360
byte stream from the just in time

00:27:34,210 --> 00:27:43,510
compiler would look look like this first

00:27:37,360 --> 00:27:47,970
part here where the XY set and PQ and

00:27:43,510 --> 00:27:47,970
ours are part of the

00:27:48,110 --> 00:27:53,480
in injected instructions and if you jump

00:27:51,740 --> 00:27:56,360
off by one into this whole thing then

00:27:53,480 --> 00:27:58,669
you could suddenly execute those payload

00:27:56,360 --> 00:28:02,059
right so if you were blind all of the

00:27:58,669 --> 00:28:05,210
stuff out and it just rented my stuff so

00:28:02,059 --> 00:28:08,539
it you cannot really you would probably

00:28:05,210 --> 00:28:10,490
crash your machine you know whatever so

00:28:08,539 --> 00:28:12,500
this is just one example but of course

00:28:10,490 --> 00:28:17,360
all the instructions that are relevant

00:28:12,500 --> 00:28:21,350
are being blinded so just to give some

00:28:17,360 --> 00:28:23,659
summary of all of the stuff from the

00:28:21,350 --> 00:28:27,950
from the functionality side so you have

00:28:23,659 --> 00:28:30,260
to escape of shadow structure that has

00:28:27,950 --> 00:28:34,100
the for the escapee metadata access

00:28:30,260 --> 00:28:36,110
there are some of the members mapped for

00:28:34,100 --> 00:28:40,669
for that and the criminal like after

00:28:36,110 --> 00:28:42,860
verification time it rewrites the data

00:28:40,669 --> 00:28:44,240
to the access so in in the in your

00:28:42,860 --> 00:28:45,769
programs you use this underscore

00:28:44,240 --> 00:28:49,639
underscore SK path and you float this

00:28:45,769 --> 00:28:51,919
into the crowd and this dat instructions

00:28:49,639 --> 00:28:56,750
are rewritten to access the actual sqb

00:28:51,919 --> 00:28:59,029
data eventually and from from the

00:28:56,750 --> 00:29:02,149
helpers so basically the main areas that

00:28:59,029 --> 00:29:05,059
CL sppf covers is you have packet access

00:29:02,149 --> 00:29:08,750
and mangling you have Mac access there

00:29:05,059 --> 00:29:11,299
are per CPU maps also pre-allocated maps

00:29:08,750 --> 00:29:13,250
that you can access and update or delete

00:29:11,299 --> 00:29:15,289
from program side

00:29:13,250 --> 00:29:17,360
yeah helpers for checks on mangling

00:29:15,289 --> 00:29:19,570
where you can for example pass in just a

00:29:17,360 --> 00:29:22,399
div and this gets updated

00:29:19,570 --> 00:29:24,679
we have redirection forwarding so you

00:29:22,399 --> 00:29:27,620
can either clone skp and redirect from

00:29:24,679 --> 00:29:31,190
there or after the program exits it

00:29:27,620 --> 00:29:35,000
redirects the skb there's integration

00:29:31,190 --> 00:29:37,370
for sakura p1 then v2 some helpers for

00:29:35,000 --> 00:29:39,409
that then the tunneling stuff that I

00:29:37,370 --> 00:29:41,929
already explained you have some protocol

00:29:39,409 --> 00:29:45,769
you have helper for protocol migration

00:29:41,929 --> 00:29:49,340
where you can implement not 6:4

00:29:45,769 --> 00:29:51,639
functionality you have some packet size

00:29:49,340 --> 00:29:55,639
some restricted packet size mangling

00:29:51,639 --> 00:29:57,649
routing realms tail calls and so on so

00:29:55,639 --> 00:29:59,399
quite a bit of stuff that you can like

00:29:57,649 --> 00:30:02,929
like as building blocks that

00:29:59,399 --> 00:30:06,570
can tailor for your specific use case

00:30:02,929 --> 00:30:08,820
couple of next steps so the next thing

00:30:06,570 --> 00:30:12,359
I'm trying to look at this to have some

00:30:08,820 --> 00:30:15,139
collect metadata like API for for crypto

00:30:12,359 --> 00:30:22,589
integration so for example that we can

00:30:15,139 --> 00:30:25,830
manage things like mexic or IP sac on

00:30:22,589 --> 00:30:28,529
devices we definitely need to improve

00:30:25,830 --> 00:30:31,440
the verifier a bit in terms of logging

00:30:28,529 --> 00:30:33,210
so currently it dumps quite a lot of

00:30:31,440 --> 00:30:35,580
stuff and you probably don't need to

00:30:33,210 --> 00:30:37,529
have a look at all of this some code

00:30:35,580 --> 00:30:40,679
annotations would be really useful so

00:30:37,529 --> 00:30:43,169
you can trace why it's complaining and

00:30:40,679 --> 00:30:44,690
your original program we have to look

00:30:43,169 --> 00:30:47,339
into if there are some possibilities

00:30:44,690 --> 00:30:50,249
then we talked already at net conf about

00:30:47,339 --> 00:30:52,200
some better introspection facilities did

00:30:50,249 --> 00:30:54,690
you know what kind of stuff is running

00:30:52,200 --> 00:30:57,679
and the code signing what came also on

00:30:54,690 --> 00:31:03,059
the table which might be interesting

00:30:57,679 --> 00:31:06,629
from the testing and also sample code

00:31:03,059 --> 00:31:09,479
site it would be useful I think to have

00:31:06,629 --> 00:31:11,249
a whole bunch of tests in the carnal

00:31:09,479 --> 00:31:13,679
self testing framework so that also blue

00:31:11,249 --> 00:31:15,629
quartz possibly pick this stuff up and

00:31:13,679 --> 00:31:19,529
can make sure we don't regress on

00:31:15,629 --> 00:31:21,749
anything and of course the documentation

00:31:19,529 --> 00:31:24,349
so far but lurking behind on what the

00:31:21,749 --> 00:31:27,529
implementation statuses so we definitely

00:31:24,349 --> 00:31:30,539
like man pages and things like that and

00:31:27,529 --> 00:31:32,460
you have to improve from that as well so

00:31:30,539 --> 00:31:34,679
there's lots of stuff to do

00:31:32,460 --> 00:31:37,379
decoded it's all on get the kernel a

00:31:34,679 --> 00:31:41,070
torque so at and mainline kernel and IP

00:31:37,379 --> 00:31:42,919
are two three and I just talked a bit

00:31:41,070 --> 00:31:47,789
about two cerium stuff it's all ah

00:31:42,919 --> 00:31:51,389
software did remind me later for the

00:31:47,789 --> 00:31:52,469
next talk the Syrian project if you want

00:31:51,389 --> 00:31:56,700
to have a look at what we are doing

00:31:52,469 --> 00:31:58,979
there regarding vpf and containers it's

00:31:56,700 --> 00:32:01,469
also all open source on github that

00:31:58,979 --> 00:32:04,469
comes rasul IAM didn't cover it here but

00:32:01,469 --> 00:32:07,529
in case and otherwise and further

00:32:04,469 --> 00:32:09,809
information also on the paper like there

00:32:07,529 --> 00:32:11,230
from the net f 1.1 the previous paper

00:32:09,809 --> 00:32:12,519
about the architecture

00:32:11,230 --> 00:32:14,799
and some of the stuff I was talking

00:32:12,519 --> 00:32:16,769
about here with a bit of more simple

00:32:14,799 --> 00:32:20,169
code as well

00:32:16,769 --> 00:32:23,440
yeah and otherwise the documentation

00:32:20,169 --> 00:32:25,899
from the kernel tree and main pages and

00:32:23,440 --> 00:32:30,460
in case you still want some sticker

00:32:25,899 --> 00:32:33,940
I have PPF sticker here or outside case

00:32:30,460 --> 00:32:38,909
you're dressed in that anyway so are you

00:32:33,940 --> 00:32:38,909
some questions comments or thanks

00:32:44,740 --> 00:32:54,650
seems um I should install that update

00:32:48,800 --> 00:32:56,300
right okay all right if not then thanks

00:32:54,650 --> 00:33:00,730
a lot I mean I'll send the hallway so

00:32:56,300 --> 00:33:00,730

YouTube URL: https://www.youtube.com/watch?v=GwT9hRiqdUo


