Title: Linux Forwarding Stack Fastpath - Nishit Shah,  Jagdish Motwani
Publication date: 2016-10-07
Playlist: Netdev 1.2 - Day 3 - Friday October 7, 2016
Description: 
	http://netdevconf.org/1.2/session.html?nishit-shah
Captions: 
	00:00:18,540 --> 00:00:23,770
yeah yeah good morning myself nishat and

00:00:22,300 --> 00:00:26,110
I have my colleague Chuck dish with me

00:00:23,770 --> 00:00:28,000
so today we will be presenting our work

00:00:26,110 --> 00:00:31,300
we did to basically accelerate the

00:00:28,000 --> 00:00:33,640
forwarding stack of Linux without going

00:00:31,300 --> 00:00:35,190
to any user space or without using any

00:00:33,640 --> 00:00:39,430
hardware accelerators it is pure

00:00:35,190 --> 00:00:41,530
software based approach so agenda is

00:00:39,430 --> 00:00:43,600
like the objective and challenges then

00:00:41,530 --> 00:00:47,110
the proposed solution then how we

00:00:43,600 --> 00:00:48,580
basically ported the stateful firewall

00:00:47,110 --> 00:00:51,129
which is connection tracking and netting

00:00:48,580 --> 00:00:57,489
on this few performance numbers and

00:00:51,129 --> 00:01:01,180
future work and discussions okay so so

00:00:57,489 --> 00:01:03,129
focus here is mainly the Linux

00:01:01,180 --> 00:01:05,740
deployments as routers and the firewalls

00:01:03,129 --> 00:01:10,110
so which basically has the ipv4 or ipv6

00:01:05,740 --> 00:01:13,420
forwarding plus stateful firewall enough

00:01:10,110 --> 00:01:15,130
and improving the through poops of that

00:01:13,420 --> 00:01:17,650
that thing bit because we are mainly in

00:01:15,130 --> 00:01:19,720
that business where we sell this boxes

00:01:17,650 --> 00:01:23,200
as which kind of used as a

00:01:19,720 --> 00:01:24,640
next-generation firewalls so there has

00:01:23,200 --> 00:01:26,470
been a lot of work going like we

00:01:24,640 --> 00:01:28,210
discussed last day also today like the

00:01:26,470 --> 00:01:31,900
net channel package share Intel dpd

00:01:28,210 --> 00:01:33,820
quenette map all of them basically so

00:01:31,900 --> 00:01:35,830
the crux or all of them are basically

00:01:33,820 --> 00:01:37,120
having this processing techniques to

00:01:35,830 --> 00:01:38,770
improve the throughput which basically

00:01:37,120 --> 00:01:41,200
has the i/o batching pre-allocated

00:01:38,770 --> 00:01:43,560
packet buffers packet processing without

00:01:41,200 --> 00:01:45,820
skb allocations forward cash prefetching

00:01:43,560 --> 00:01:48,210
either the loculus path of reduced

00:01:45,820 --> 00:01:50,620
locking and memory mapped buffers but

00:01:48,210 --> 00:01:52,090
all of these frameworks are talking

00:01:50,620 --> 00:01:55,030
about moving the stuff into user space

00:01:52,090 --> 00:01:57,159
might look good for several applications

00:01:55,030 --> 00:01:59,890
but not a practical choice because it

00:01:57,159 --> 00:02:02,590
requires whole kind of networking stack

00:01:59,890 --> 00:02:05,880
to be ported on user space and linux is

00:02:02,590 --> 00:02:08,619
already there so I like to do that so

00:02:05,880 --> 00:02:12,280
yeah so what we did is like before

00:02:08,619 --> 00:02:13,690
starting the kind of so proposal

00:02:12,280 --> 00:02:15,370
physical is to integrate and enhance

00:02:13,690 --> 00:02:16,780
this networking stack with the fast

00:02:15,370 --> 00:02:20,350
packet processing technique mentioned

00:02:16,780 --> 00:02:23,860
earlier so in order to music

00:02:20,350 --> 00:02:25,420
this we first kind of data Apple to

00:02:23,860 --> 00:02:27,310
Apple composition not fully applied to

00:02:25,420 --> 00:02:28,840
apple because the nightmare and dpd case

00:02:27,310 --> 00:02:31,510
sample applications are like the tools

00:02:28,840 --> 00:02:34,060
or the toys and not a full full of

00:02:31,510 --> 00:02:35,860
forwarding stat but still we we compare

00:02:34,060 --> 00:02:37,270
that okay like what are the what is the

00:02:35,860 --> 00:02:41,500
difference India and that is a definite

00:02:37,270 --> 00:02:44,130
difference between the performance then

00:02:41,500 --> 00:02:46,210
what we do did is like at the first step

00:02:44,130 --> 00:02:50,170
like the instead of using the standard

00:02:46,210 --> 00:02:52,570
rxtx path we basically use the net map

00:02:50,170 --> 00:02:54,460
rings for receive and transmit so just

00:02:52,570 --> 00:02:56,320
just a quick overview like the net

00:02:54,460 --> 00:03:00,000
mappings are basically having the

00:02:56,320 --> 00:03:04,450
pre-allocated rxtx buffers and plea and

00:03:00,000 --> 00:03:06,820
the eye of etching capacities so and to

00:03:04,450 --> 00:03:08,980
use the nut mappings like basically you

00:03:06,820 --> 00:03:12,580
need to put any network interface card

00:03:08,980 --> 00:03:14,170
in that map mode so there is a few

00:03:12,580 --> 00:03:17,140
hundred lines of code required to change

00:03:14,170 --> 00:03:19,240
driver from a traditional way to put it

00:03:17,140 --> 00:03:21,910
in an act map mode so what it does is

00:03:19,240 --> 00:03:24,100
basically it Colonel Steele still sees

00:03:21,910 --> 00:03:26,770
the interface as a net device structure

00:03:24,100 --> 00:03:28,420
whereas the the data the RX and TX are

00:03:26,770 --> 00:03:34,330
basically kind of disconnected from the

00:03:28,420 --> 00:03:36,310
actual stack and and the way the vanilla

00:03:34,330 --> 00:03:38,620
network is like on the receive side the

00:03:36,310 --> 00:03:42,090
network framework ID is a hook in hook

00:03:38,620 --> 00:03:44,320
net map Alex I acted aces in the driver

00:03:42,090 --> 00:03:46,750
drivers nappy called that function and

00:03:44,320 --> 00:03:48,940
and from that basically wake up the user

00:03:46,750 --> 00:03:51,280
space process and then userspace process

00:03:48,940 --> 00:03:53,500
basically processes all the packets then

00:03:51,280 --> 00:03:55,210
on the transmit side the application

00:03:53,500 --> 00:03:57,610
basically fills the NAT mapping and then

00:03:55,210 --> 00:04:00,400
send it sense and that ring basically

00:03:57,610 --> 00:04:02,920
sent outside and all the receive and

00:04:00,400 --> 00:04:06,370
transmit are done in a batch so they

00:04:02,920 --> 00:04:09,730
have that I of etching okay so what we

00:04:06,370 --> 00:04:11,080
did in so in the modified approach like

00:04:09,730 --> 00:04:14,350
instead of waking up the user space

00:04:11,080 --> 00:04:16,270
process what we did is like we call the

00:04:14,350 --> 00:04:17,859
neck mubarak sink to get the packets in

00:04:16,270 --> 00:04:19,870
at my playing and packets processing

00:04:17,859 --> 00:04:21,850
colonel so at that point of time to

00:04:19,870 --> 00:04:24,730
basically fetch all the packets from the

00:04:21,850 --> 00:04:26,890
from the neck mapping and process that

00:04:24,730 --> 00:04:30,940
and instead of going into the user space

00:04:26,890 --> 00:04:33,010
we captive kept it in the colonel and

00:04:30,940 --> 00:04:35,380
now we have as we have that ring we have

00:04:33,010 --> 00:04:38,280
that batch and we basically run the for

00:04:35,380 --> 00:04:41,290
loop on that and process all the packets

00:04:38,280 --> 00:04:44,920
only thing we like once we have those

00:04:41,290 --> 00:04:47,860
packet those are yup so that is not know

00:04:44,920 --> 00:04:49,870
s kiddies allocated yet so what what we

00:04:47,860 --> 00:04:51,640
did there is we basically modified the

00:04:49,870 --> 00:04:53,350
routing code in a way that instead of

00:04:51,640 --> 00:04:58,150
skb that routing code is works on the

00:04:53,350 --> 00:04:59,950
packet data so did that we first come up

00:04:58,150 --> 00:05:01,720
with the idea of having a mini skb kind

00:04:59,950 --> 00:05:04,660
of thing which is typedef two main skd

00:05:01,720 --> 00:05:06,280
but that basically broke a break many of

00:05:04,660 --> 00:05:10,270
the things in the tcp stack and stuff

00:05:06,280 --> 00:05:12,550
like that then we basically created a

00:05:10,270 --> 00:05:14,110
small structure which are required the

00:05:12,550 --> 00:05:16,270
only fields which are required in the

00:05:14,110 --> 00:05:18,610
forwarding like the routing DST cache

00:05:16,270 --> 00:05:20,590
entries the contact pointers and other

00:05:18,610 --> 00:05:22,690
things and we change the code in a way

00:05:20,590 --> 00:05:25,030
like wherever it is required like we

00:05:22,690 --> 00:05:27,040
expect those free from skb and use the

00:05:25,030 --> 00:05:29,530
same code so that is logically that is

00:05:27,040 --> 00:05:31,510
no changing the actual code so routing

00:05:29,530 --> 00:05:33,040
is exactly the same way we are doing

00:05:31,510 --> 00:05:36,640
with skb or we are doing with them a

00:05:33,040 --> 00:05:39,520
packet may metadata so those are the

00:05:36,640 --> 00:05:41,410
changes and on the transmit side so just

00:05:39,520 --> 00:05:43,480
only the packet pointers are moved from

00:05:41,410 --> 00:05:46,480
the Adicts ring to TX wings basically

00:05:43,480 --> 00:05:47,830
those are the Rings we have and once we

00:05:46,480 --> 00:05:51,220
have the range filter we basically

00:05:47,830 --> 00:05:55,330
instructor Nick hate you you send the

00:05:51,220 --> 00:05:57,040
packets out and and once the Nick sends

00:05:55,330 --> 00:05:59,860
the packet that is basically no need to

00:05:57,040 --> 00:06:01,810
handle the callback functions because it

00:05:59,860 --> 00:06:06,040
is not required to basically not

00:06:01,810 --> 00:06:08,110
delocated free any memory there okay so

00:06:06,040 --> 00:06:10,060
this is just an high level diagram so

00:06:08,110 --> 00:06:12,880
from the Nappy pole that is neck my

00:06:10,060 --> 00:06:15,310
products i RQ net mubarak sink and from

00:06:12,880 --> 00:06:18,190
the RX inc now we have the batch of

00:06:15,310 --> 00:06:19,960
packets for each packet we call

00:06:18,190 --> 00:06:22,330
basically the doofus part function and

00:06:19,960 --> 00:06:25,000
second thing we implemented here is like

00:06:22,330 --> 00:06:27,940
so let's say in the naughty colvic you

00:06:25,000 --> 00:06:29,590
get the 64th packets n onto 64 packets

00:06:27,940 --> 00:06:32,919
like example like there are two output

00:06:29,590 --> 00:06:34,930
devices 32 packets going to each one and

00:06:32,919 --> 00:06:36,700
thirty two packets going to eat too so

00:06:34,930 --> 00:06:37,720
instead of sending each packet we

00:06:36,700 --> 00:06:39,780
basically created

00:06:37,720 --> 00:06:42,250
device wise matches and we basically

00:06:39,780 --> 00:06:44,830
send those matches directly on to the

00:06:42,250 --> 00:06:47,110
cards so here for each output device we

00:06:44,830 --> 00:06:52,990
basically send the 32 packets and

00:06:47,110 --> 00:06:56,170
packets in the match in the TX path okay

00:06:52,990 --> 00:06:59,170
and this is this is basically the high

00:06:56,170 --> 00:07:01,900
level do fastpass function so it first

00:06:59,170 --> 00:07:03,820
does all the sanity checks we have in IP

00:07:01,900 --> 00:07:05,230
received function so IP receive is just

00:07:03,820 --> 00:07:09,040
modified in a way like sanity's

00:07:05,230 --> 00:07:10,930
decoupled from Maine itii pa-c so we we

00:07:09,040 --> 00:07:12,760
call it from two places then standard

00:07:10,930 --> 00:07:18,160
route look up which is I pain put out

00:07:12,760 --> 00:07:20,080
slow then if that is a if that it is for

00:07:18,160 --> 00:07:23,430
this time basically for the control path

00:07:20,080 --> 00:07:26,020
packets are to access the device then we

00:07:23,430 --> 00:07:28,660
do the normal workflow where we allocate

00:07:26,020 --> 00:07:30,790
the skb and do the native receive skb on

00:07:28,660 --> 00:07:32,770
the other side if it isn't forwarding

00:07:30,790 --> 00:07:35,140
paths then we basically do the normal

00:07:32,770 --> 00:07:37,270
things the TTL decrement a neighbor look

00:07:35,140 --> 00:07:39,460
up and if if there is an neighbor

00:07:37,270 --> 00:07:41,980
already present in the arc cash with is

00:07:39,460 --> 00:07:44,820
basically do the Mac Mac up data and

00:07:41,980 --> 00:07:48,280
transmitted using the batch mode I you

00:07:44,820 --> 00:07:50,230
and so this so this neighbor look up

00:07:48,280 --> 00:07:52,720
route look up are on all the kernel

00:07:50,230 --> 00:07:58,419
functions nothing of loaded or nothing

00:07:52,720 --> 00:08:00,100
changed anywhere okay and this is so as

00:07:58,419 --> 00:08:01,570
I mentioned so as we are in Colonel so

00:08:00,100 --> 00:08:03,250
kernel stack is still used for the

00:08:01,570 --> 00:08:06,340
package which are either kind of not

00:08:03,250 --> 00:08:08,200
supported or porter or pasta or either

00:08:06,340 --> 00:08:12,220
not required to be on Fast Pass like the

00:08:08,200 --> 00:08:13,810
control pad x XS or the the protocol

00:08:12,220 --> 00:08:15,970
which are by nature are not that fast

00:08:13,810 --> 00:08:17,200
like the arc packets or the fragmented

00:08:15,970 --> 00:08:18,580
packets where we have the current

00:08:17,200 --> 00:08:20,979
limitation that we are not basically

00:08:18,580 --> 00:08:23,770
able to cue the packet somewhere but

00:08:20,979 --> 00:08:25,479
yeah so so we we have that model like if

00:08:23,770 --> 00:08:27,280
you have not supported on the first path

00:08:25,479 --> 00:08:29,650
you basically simply go to Colonel for

00:08:27,280 --> 00:08:33,310
that and just for the control plane

00:08:29,650 --> 00:08:36,479
traffic so this is again the vanilla

00:08:33,310 --> 00:08:38,589
vanilla and Ahmed implementation where

00:08:36,479 --> 00:08:41,710
where you have an at my transmit

00:08:38,589 --> 00:08:44,110
function up for the for the Tiber

00:08:41,710 --> 00:08:45,830
specific stuff and so this function is

00:08:44,110 --> 00:08:47,930
basically modified where we

00:08:45,830 --> 00:08:49,850
basically copy the skb data into the net

00:08:47,930 --> 00:08:52,220
mapping and then basically do a transmit

00:08:49,850 --> 00:08:54,500
so this is still a per packet but as we

00:08:52,220 --> 00:08:56,540
don't have that use case of so many

00:08:54,500 --> 00:08:59,630
packets coming from the stack or moving

00:08:56,540 --> 00:09:04,280
on moving to the stack it is okay with

00:08:59,630 --> 00:09:06,980
our use case okay and one more technique

00:09:04,280 --> 00:09:10,130
that we used here is like the forward

00:09:06,980 --> 00:09:12,800
cash prefetching so when we go through

00:09:10,130 --> 00:09:14,650
the sample applications of DP DK they

00:09:12,800 --> 00:09:18,230
basically use the forward prefetching

00:09:14,650 --> 00:09:19,970
where so now we have a match of packets

00:09:18,230 --> 00:09:22,820
in that mapping so what we did is alike

00:09:19,970 --> 00:09:24,830
for so if you have the n packets in

00:09:22,820 --> 00:09:27,260
nappy nappy call back like we basically

00:09:24,830 --> 00:09:29,240
first fetch the three packets and then

00:09:27,260 --> 00:09:31,220
while we process the first packet we

00:09:29,240 --> 00:09:33,050
instruct a prefetch for the fourth

00:09:31,220 --> 00:09:35,750
packet so by the time they basically

00:09:33,050 --> 00:09:38,570
process the packet we have the next

00:09:35,750 --> 00:09:42,380
packet in the cache already so this

00:09:38,570 --> 00:09:45,890
helps significant it on x86 and x64

00:09:42,380 --> 00:09:48,110
boxes where it it definitely increased

00:09:45,890 --> 00:09:50,810
performance by a lot where dede ayew is

00:09:48,110 --> 00:09:53,540
not supported DDI your boxes with the

00:09:50,810 --> 00:09:55,580
DDI your supported is having kind of no

00:09:53,540 --> 00:09:58,370
no throughput gains due to this because

00:09:55,580 --> 00:10:04,370
Dario itself sends a packet to l2 cache

00:09:58,370 --> 00:10:06,650
when it receives yeah so so now we have

00:10:04,370 --> 00:10:08,060
that basic setup there you have a code

00:10:06,650 --> 00:10:09,950
and you have a framework ready what

00:10:08,060 --> 00:10:12,050
makes we did is like the way we

00:10:09,950 --> 00:10:14,720
basically converted that outing code we

00:10:12,050 --> 00:10:16,400
basically again converted the connection

00:10:14,720 --> 00:10:20,420
tracking and the netting code on this on

00:10:16,400 --> 00:10:23,150
the same lines so so what we did is like

00:10:20,420 --> 00:10:25,490
from the dual function we first did the

00:10:23,150 --> 00:10:28,070
connection connection look up and and

00:10:25,490 --> 00:10:30,410
now the the connection lookup is not

00:10:28,070 --> 00:10:34,400
having any central lock so it is scaling

00:10:30,410 --> 00:10:35,960
very well and if what so so the idea is

00:10:34,400 --> 00:10:37,490
like we did the connection look up if

00:10:35,960 --> 00:10:39,170
you if it is the first packet of

00:10:37,490 --> 00:10:42,050
connection you continue the journey into

00:10:39,170 --> 00:10:44,420
the kernel stack where you have all your

00:10:42,050 --> 00:10:46,610
kind of the firewall rules or the item

00:10:44,420 --> 00:10:49,930
the rules in an appt tables or IP tables

00:10:46,610 --> 00:10:52,420
are using tighty sex and then basically

00:10:49,930 --> 00:10:55,910
with the con mukhtar

00:10:52,420 --> 00:10:58,009
you said some some mark just just an

00:10:55,910 --> 00:11:01,249
idea is like you said the Fast Pass Fast

00:10:58,009 --> 00:11:03,709
Pass mark to the two to say that okay

00:11:01,249 --> 00:11:06,199
the all all subsequent packets will be

00:11:03,709 --> 00:11:08,239
kind of processed by the FASTA and then

00:11:06,199 --> 00:11:10,549
for all subsequent packet again like

00:11:08,239 --> 00:11:13,189
once we did the connection like once we

00:11:10,549 --> 00:11:15,410
do the connection look up so we we got

00:11:13,189 --> 00:11:17,419
that flag and if it is in said like this

00:11:15,410 --> 00:11:20,540
is in the fast path we basically process

00:11:17,419 --> 00:11:24,919
that packet wire fast cut the new

00:11:20,540 --> 00:11:27,499
fastest module yeah and one more thing

00:11:24,919 --> 00:11:30,859
we other here is like florian proposed a

00:11:27,499 --> 00:11:34,549
patch where we're like once you so now

00:11:30,859 --> 00:11:36,859
before going into the details like so

00:11:34,549 --> 00:11:38,359
once we on the passport now we have to

00:11:36,859 --> 00:11:40,489
look ups one is the contact look up and

00:11:38,359 --> 00:11:42,619
one then one is that outlook up so to

00:11:40,489 --> 00:11:45,470
avoid to look up sweet is equally use

00:11:42,619 --> 00:11:48,350
this patch where only the like on the

00:11:45,470 --> 00:11:50,779
first packet the routing viously and we

00:11:48,350 --> 00:11:53,059
shall are cached in the contract and

00:11:50,779 --> 00:11:55,399
then subsequently you are not required

00:11:53,059 --> 00:11:56,839
to do the routing routing look up so

00:11:55,399 --> 00:11:59,929
then you do the contract look up you

00:11:56,839 --> 00:12:02,540
have those entries into is ready I think

00:11:59,929 --> 00:12:05,449
this patch is not yet upstream but I

00:12:02,540 --> 00:12:07,699
request Florian to basically push it

00:12:05,449 --> 00:12:15,470
because it actually helped a lot in in

00:12:07,699 --> 00:12:18,169
this case yeah okay so not sure this is

00:12:15,470 --> 00:12:21,829
visible good enough or not but yeah this

00:12:18,169 --> 00:12:25,610
is again the same so sanity checks so

00:12:21,829 --> 00:12:27,309
contact look up and then if if can mark

00:12:25,610 --> 00:12:30,499
is said then we basically follow the

00:12:27,309 --> 00:12:34,699
standard pad just five but but not going

00:12:30,499 --> 00:12:36,139
to go not kind of going into the skb

00:12:34,699 --> 00:12:38,209
path rather it is a more straightforward

00:12:36,139 --> 00:12:42,079
path with coming up the same functions

00:12:38,209 --> 00:12:44,919
and if not then is it that is the normal

00:12:42,079 --> 00:12:44,919
path we are following

00:12:46,160 --> 00:12:52,800
okay so here are some performance

00:12:49,980 --> 00:12:54,960
numbers with this changes so so this

00:12:52,800 --> 00:12:58,410
result I've taken on a single code so

00:12:54,960 --> 00:13:01,110
this are the single core cpu e52 680 2.5

00:12:58,410 --> 00:13:03,300
gigahertz and with 210g quotes connected

00:13:01,110 --> 00:13:05,460
and with everything like we are almost

00:13:03,300 --> 00:13:08,280
getting fired I'm through put increment

00:13:05,460 --> 00:13:12,000
just by a software changes not know any

00:13:08,280 --> 00:13:15,090
uploads are so one one more point worth

00:13:12,000 --> 00:13:16,980
noting here is like all the grr GA saw

00:13:15,090 --> 00:13:21,330
all the floors are disabled here it is

00:13:16,980 --> 00:13:23,070
pure without any uploading stuff so if

00:13:21,330 --> 00:13:25,050
so on the every puppet size we are

00:13:23,070 --> 00:13:28,110
getting almost Firestein throughput for

00:13:25,050 --> 00:13:31,470
the connect for the stateful firewall

00:13:28,110 --> 00:13:34,920
not even the routing and as it is a

00:13:31,470 --> 00:13:37,080
single core with just this one cpu it I

00:13:34,920 --> 00:13:39,690
remember like this is a 12 core cpu so

00:13:37,080 --> 00:13:41,340
that just a single core we are on five

00:13:39,690 --> 00:13:43,590
and two lmb bytes of packets we are

00:13:41,340 --> 00:13:47,810
easily reaching hundred gig on on this

00:13:43,590 --> 00:13:47,810
on the cpu with the stateful firewall

00:13:48,200 --> 00:13:55,080
yeah so future work currently we are as

00:13:53,490 --> 00:13:57,030
I mentioned we do not have a packet

00:13:55,080 --> 00:14:00,360
buffer holding support in net mapping so

00:13:57,030 --> 00:14:02,160
that's why we and and and that's why all

00:14:00,360 --> 00:14:04,070
the use cases where we are required the

00:14:02,160 --> 00:14:07,590
queuing we are not able to use it

00:14:04,070 --> 00:14:09,300
current so we are doing data copies when

00:14:07,590 --> 00:14:11,250
sending packet to Colonel network stack

00:14:09,300 --> 00:14:15,420
because those are the two different

00:14:11,250 --> 00:14:18,360
things so I had a word with chess / and

00:14:15,420 --> 00:14:21,110
it is page will not the cube ample to

00:14:18,360 --> 00:14:24,450
basically avoid the copies between them

00:14:21,110 --> 00:14:27,750
so XD p is definitely a possibility i

00:14:24,450 --> 00:14:29,760
basically remove we will be seeing like

00:14:27,750 --> 00:14:32,070
whether we can use we can remove the net

00:14:29,760 --> 00:14:34,680
map which is not the mainstream kernel

00:14:32,070 --> 00:14:37,590
and maybe we can use xtp here and have

00:14:34,680 --> 00:14:40,470
have this runny so that we can have that

00:14:37,590 --> 00:14:43,530
map map out and like the phosphor

00:14:40,470 --> 00:14:45,240
coating for bridge and basically the

00:14:43,530 --> 00:14:47,780
bridge and the transform at the first

00:14:45,240 --> 00:14:49,530
because that there will be a so we

00:14:47,780 --> 00:14:51,690
expect like that will be definitely

00:14:49,530 --> 00:14:56,750
gaining the ipsec or the transform

00:14:51,690 --> 00:14:56,750
transforms back and on the bridge path

00:14:57,100 --> 00:15:05,660
yeah so that's it questions so if I

00:15:03,740 --> 00:15:09,080
understand correctly so basically you

00:15:05,660 --> 00:15:10,790
have light metadata as packets coming

00:15:09,080 --> 00:15:13,250
into the stack and and you're using the

00:15:10,790 --> 00:15:14,450
existing fib look up infrastructure to

00:15:13,250 --> 00:15:16,340
look up the route and make decisions

00:15:14,450 --> 00:15:20,060
about how you forward things out to the

00:15:16,340 --> 00:15:21,590
network gang so long term one vision I

00:15:20,060 --> 00:15:23,930
have of how we're going to do all this

00:15:21,590 --> 00:15:27,850
is exactly as you kind of alluded to is

00:15:23,930 --> 00:15:31,010
perhaps use xdp for this then we get the

00:15:27,850 --> 00:15:32,870
area we get into discussion at that

00:15:31,010 --> 00:15:37,040
point is how do we share the tables

00:15:32,870 --> 00:15:38,540
between the internal memory state for

00:15:37,040 --> 00:15:41,600
the fib look-up tables the neighbor

00:15:38,540 --> 00:15:44,120
cache what have you and the BPF maps

00:15:41,600 --> 00:15:46,580
that the BPF programs can access and

00:15:44,120 --> 00:15:48,770
this is a this is a far-reaching issue

00:15:46,580 --> 00:15:51,200
and it's been hit already by the people

00:15:48,770 --> 00:15:53,510
who try to Tom Herbert and his team

00:15:51,200 --> 00:15:55,130
trying to do I la routers using xdp so

00:15:53,510 --> 00:15:57,230
this is kind of like an area where we

00:15:55,130 --> 00:15:59,270
need to do investigation figure out what

00:15:57,230 --> 00:16:01,910
the best model is and this gets even

00:15:59,270 --> 00:16:04,490
more interesting once we push BPF into

00:16:01,910 --> 00:16:06,320
hardware is like the NPS talk that just

00:16:04,490 --> 00:16:08,780
happened how do we synchronize state

00:16:06,320 --> 00:16:10,250
between the colonel and the BPF map

00:16:08,780 --> 00:16:12,320
that's sitting in there running xdp all

00:16:10,250 --> 00:16:13,610
the time so I really appreciate the work

00:16:12,320 --> 00:16:14,960
you did and the numbers you gave because

00:16:13,610 --> 00:16:16,550
it kind of gives us an idea of where we

00:16:14,960 --> 00:16:18,080
can go with this and now what's what's

00:16:16,550 --> 00:16:22,300
what's possible and that's always useful

00:16:18,080 --> 00:16:22,300
information thank you yeah thanks

00:16:24,690 --> 00:16:28,040
here the Commission

00:16:30,940 --> 00:16:34,450
did you slap

00:16:54,060 --> 00:17:00,670
okay i understand correctly that you're

00:16:57,280 --> 00:17:03,010
just using that matter neked next after

00:17:00,670 --> 00:17:05,440
within the canyon right and why didn't

00:17:03,010 --> 00:17:08,500
you the the body ones which is in the

00:17:05,440 --> 00:17:11,079
canyon the network repository has a

00:17:08,500 --> 00:17:15,040
patch to the open basic color data path

00:17:11,079 --> 00:17:16,930
acceleration the base fight the it uses

00:17:15,040 --> 00:17:19,270
it in can you open with it with your

00:17:16,930 --> 00:17:21,699
data palette is pretty thing after the

00:17:19,270 --> 00:17:25,600
fibrillar cups we change within the

00:17:21,699 --> 00:17:27,579
corner and but instead of the directory

00:17:25,600 --> 00:17:30,070
using net no panic it'll it is the

00:17:27,579 --> 00:17:32,950
softest which with net map okay the

00:17:30,070 --> 00:17:34,900
leading diet for example i think about

00:17:32,950 --> 00:17:37,360
some series of pocket are coming into

00:17:34,900 --> 00:17:39,340
them okay then the first packet goes to

00:17:37,360 --> 00:17:42,550
GV technique which stuck at the walt

00:17:39,340 --> 00:17:45,880
disney ok the next next bucket again was

00:17:42,550 --> 00:17:48,550
the picnic ok so i think if you do a kid

00:17:45,880 --> 00:17:52,500
I think every time access accessing too

00:17:48,550 --> 00:17:56,710
much money you have to obtain lock and

00:17:52,500 --> 00:17:59,350
the chicks DNA and unlock it something

00:17:56,710 --> 00:18:03,400
like this happens right so if you be the

00:17:59,350 --> 00:18:06,010
softest which the open net map you can

00:18:03,400 --> 00:18:07,690
do it packet beforehand for each

00:18:06,010 --> 00:18:10,870
destination thing that you can apply the

00:18:07,690 --> 00:18:13,270
cost for the x axis and looking so that

00:18:10,870 --> 00:18:16,090
I recommend using that part so I guess

00:18:13,270 --> 00:18:19,000
we like be used in the same way but I

00:18:16,090 --> 00:18:21,990
got that approach but ultimately like we

00:18:19,000 --> 00:18:24,550
are having those swings and we basically

00:18:21,990 --> 00:18:26,530
combine the packets with for the each

00:18:24,550 --> 00:18:28,420
output device and then basically

00:18:26,530 --> 00:18:30,490
transmitted in the batches ok so the

00:18:28,420 --> 00:18:32,380
base case you the group package before

00:18:30,490 --> 00:18:35,640
granted ok I'm not sure it is already

00:18:32,380 --> 00:18:35,640
there in a crap that you say

00:18:35,880 --> 00:18:39,150
let's talk later

00:18:45,340 --> 00:18:59,370
ok no more questions yeah thank you hope

00:18:56,500 --> 00:18:59,370

YouTube URL: https://www.youtube.com/watch?v=DTPxGXjJhPk


