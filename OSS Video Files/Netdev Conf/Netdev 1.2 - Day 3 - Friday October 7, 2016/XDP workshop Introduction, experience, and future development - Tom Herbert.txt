Title: XDP workshop Introduction, experience, and future development - Tom Herbert
Publication date: 2016-10-07
Playlist: Netdev 1.2 - Day 3 - Friday October 7, 2016
Description: 
	http://netdevconf.org/1.2/session.html?herbert-xdp-workshop
Captions: 
	00:00:10,730 --> 00:00:16,939
obviously we've had quite a bit of

00:00:12,260 --> 00:00:19,570
introduction to it so we have basically

00:00:16,939 --> 00:00:24,860
three presentations on the agenda

00:00:19,570 --> 00:00:28,099
covering mlx live work and then Seth

00:00:24,860 --> 00:00:30,890
which is project that while ways

00:00:28,099 --> 00:00:33,700
pursuing around next EP and then I only

00:00:30,890 --> 00:00:35,450
rather on barefoot which kind of related

00:00:33,700 --> 00:00:37,879
so I'm going to get a lot of

00:00:35,450 --> 00:00:40,219
introduction I think we've had plenty

00:00:37,879 --> 00:00:42,230
from Dave yesterday and others I do in

00:00:40,219 --> 00:00:44,239
any way near be the goals of xvp are

00:00:42,230 --> 00:00:47,179
pretty simple it's fast programmable

00:00:44,239 --> 00:00:50,719
portable high speed data and networking

00:00:47,179 --> 00:00:53,690
path and XDP in a nutshell it's

00:00:50,719 --> 00:00:54,620
programmable interface and as I

00:00:53,690 --> 00:00:57,319
mentioned we're going for high

00:00:54,620 --> 00:01:00,199
performance the term bare metal packet

00:00:57,319 --> 00:01:04,120
processing is probably appropriate here

00:01:00,199 --> 00:01:06,470
and the use cases

00:01:04,120 --> 00:01:08,510
what kind of undefined at this point I

00:01:06,470 --> 00:01:10,280
think we're and in some sense building a

00:01:08,510 --> 00:01:12,320
hammer we'll see how it's used

00:01:10,280 --> 00:01:14,420
hopefully most these cases will be

00:01:12,320 --> 00:01:16,360
beneficial but like a hammer or some

00:01:14,420 --> 00:01:19,700
people may be using it for interesting

00:01:16,360 --> 00:01:23,899
malicious cases but that's life I mean

00:01:19,700 --> 00:01:25,310
it's it's definitely a powerful kind of

00:01:23,899 --> 00:01:29,240
a powerful mechanism that we're building

00:01:25,310 --> 00:01:31,219
so we're quite aware of that so this is

00:01:29,240 --> 00:01:33,909
one picture I did want to bring up it

00:01:31,219 --> 00:01:36,289
kind of shows the xvp

00:01:33,909 --> 00:01:38,570
architectural way and the thing I wanted

00:01:36,289 --> 00:01:41,689
to point out is that this kind of hand

00:01:38,570 --> 00:01:44,060
box in the middle is where the xdp

00:01:41,689 --> 00:01:46,070
happens and the key is that the parsing

00:01:44,060 --> 00:01:49,399
processing BPF program is all the way

00:01:46,070 --> 00:01:52,670
down in the queue and the output from

00:01:49,399 --> 00:01:56,329
this is drop packet received into the

00:01:52,670 --> 00:01:59,539
local stack or forward packet so we have

00:01:56,329 --> 00:02:02,390
very simple action codes for these four

00:01:59,539 --> 00:02:07,729
things so that's kind of the overview of

00:02:02,390 --> 00:02:09,319
xtp and with that I will turn it over to

00:02:07,729 --> 00:02:12,879
Sayid who tell us about

00:02:09,319 --> 00:02:12,879
G and M Alexa

00:02:26,010 --> 00:02:29,189
this one

00:02:31,520 --> 00:02:35,360
okay do you hear me

00:02:35,910 --> 00:02:42,959
hello all my name is Edna Meade on the

00:02:39,239 --> 00:02:45,630
maintainer of the mx-5 dragger I'm here

00:02:42,959 --> 00:02:51,090
today to talk about mx-5 implementation

00:02:45,630 --> 00:02:54,239
of 60p so like to tell our story

00:02:51,090 --> 00:02:56,940
implementing xdb as things that second

00:02:54,239 --> 00:03:01,940
driver to implement xvp after in

00:02:56,940 --> 00:03:04,410
explorer i would like to visit some

00:03:01,940 --> 00:03:08,519
aspects in the difficulties and

00:03:04,410 --> 00:03:14,390
challenges making xpp possible over

00:03:08,519 --> 00:03:19,470
device driver i would like to visit some

00:03:14,390 --> 00:03:22,620
our implementation of of oryx mods and

00:03:19,470 --> 00:03:27,739
memory models that we have to change in

00:03:22,620 --> 00:03:30,390
order to make XTP a reality i will

00:03:27,739 --> 00:03:36,690
explain how do we implemented arts drop

00:03:30,390 --> 00:03:38,609
and forwarding in details and they at

00:03:36,690 --> 00:03:41,430
last we will discuss their performance

00:03:38,609 --> 00:03:44,329
numbers and to show how how great text

00:03:41,430 --> 00:03:48,299
appears and what what what future

00:03:44,329 --> 00:03:52,530
improvements we can add to the HTTP

00:03:48,299 --> 00:03:53,690
architecture so I assume everyone knows

00:03:52,530 --> 00:03:56,549
what it appears

00:03:53,690 --> 00:04:01,109
yesterday they visited all of the

00:03:56,549 --> 00:04:03,269
aspects of TP so I would like to talk

00:04:01,109 --> 00:04:06,060
about what is required from the device

00:04:03,269 --> 00:04:06,709
drivers in order to have XT being inside

00:04:06,060 --> 00:04:13,590
of them

00:04:06,709 --> 00:04:17,820
so X may be basically is is a mechanism

00:04:13,590 --> 00:04:21,329
to allow the an EP peer program to run

00:04:17,820 --> 00:04:25,500
over a packet as soon as it's as it as

00:04:21,329 --> 00:04:28,789
it arrives to the CPU after the bus

00:04:25,500 --> 00:04:32,389
driver fetch it from the hardware that

00:04:28,789 --> 00:04:37,789
bus driver should allow early drop

00:04:32,389 --> 00:04:39,860
before even an escapee is allocated the

00:04:37,789 --> 00:04:44,979
dress Hager should also grant right

00:04:39,860 --> 00:04:47,509
access to the packet for civil use cases

00:04:44,979 --> 00:04:52,060
and throughout the device driver also

00:04:47,509 --> 00:04:54,379
should allow hey there pop and posh so

00:04:52,060 --> 00:04:57,860
which means that the device drivers

00:04:54,379 --> 00:05:01,639
should also guarantee a Headroom

00:04:57,860 --> 00:05:04,879
and the theorem also the bus driver

00:05:01,639 --> 00:05:08,029
should respect attics forward request

00:05:04,879 --> 00:05:09,860
from a PDF program which also adds some

00:05:08,029 --> 00:05:13,550
complexity to the rx routine of the

00:05:09,860 --> 00:05:16,039
driver paper packet is basically a

00:05:13,550 --> 00:05:21,169
restriction it's not a requirement we

00:05:16,039 --> 00:05:26,270
will talk about that so why is it a

00:05:21,169 --> 00:05:29,300
straightforward comment' XTP over some

00:05:26,270 --> 00:05:31,629
device driver first of all we talked

00:05:29,300 --> 00:05:37,430
about the restriction of of xpp

00:05:31,629 --> 00:05:39,860
yesterday and it is not just simply just

00:05:37,430 --> 00:05:42,229
hook the TPPA program as soon as

00:05:39,860 --> 00:05:45,199
possible and that's it the memory models

00:05:42,229 --> 00:05:47,779
of the tracker has to be changed from

00:05:45,199 --> 00:05:50,629
before before if the TP there was only

00:05:47,779 --> 00:05:51,909
one state or two states of an aurochs

00:05:50,629 --> 00:05:55,460
butter

00:05:51,909 --> 00:05:57,409
it's either the RS buffer is sitting

00:05:55,460 --> 00:06:02,029
inside the hardware waiting for a packet

00:05:57,409 --> 00:06:06,469
to arrive or it's or it is received and

00:06:02,029 --> 00:06:09,259
it is now inside that stack so from

00:06:06,469 --> 00:06:14,389
before race KB was allocated from the

00:06:09,259 --> 00:06:18,169
jogger and the the stack freed freeze it

00:06:14,389 --> 00:06:20,509
so those are the only possible states

00:06:18,169 --> 00:06:23,839
now with xtp there are two more states

00:06:20,509 --> 00:06:27,020
and an aurochs buffer can be dropped or

00:06:23,839 --> 00:06:35,089
followed it back to the port it came

00:06:27,020 --> 00:06:37,969
from so I would like to discuss how can

00:06:35,089 --> 00:06:40,159
we implement those features and what

00:06:37,969 --> 00:06:42,459
complexity completes create a hat or a

00:06:40,159 --> 00:06:42,459
try

00:06:43,099 --> 00:06:51,199
also I have XTP hook and extremely

00:06:45,590 --> 00:06:53,810
restrictions as I said xD people who

00:06:51,199 --> 00:06:55,819
must run as soon as possible

00:06:53,810 --> 00:06:57,889
which which means that the

00:06:55,819 --> 00:07:00,919
implementation of XDP hope is dependent

00:06:57,889 --> 00:07:07,310
that the bus driver so it's not a vendor

00:07:00,919 --> 00:07:10,280
agnostic as well that the device driver

00:07:07,310 --> 00:07:12,680
should now I locate and preserve a

00:07:10,280 --> 00:07:14,840
headroom and the Tea Room for the STB

00:07:12,680 --> 00:07:19,490
program to manipulate a packet which

00:07:14,840 --> 00:07:21,770
wasn't there always the case also it

00:07:19,490 --> 00:07:23,659
will be forward itself as an order adds

00:07:21,770 --> 00:07:25,550
an order of magnitude to the complexity

00:07:23,659 --> 00:07:28,669
of the arcs routine adults attain from

00:07:25,550 --> 00:07:30,710
before was only responsible of receiving

00:07:28,669 --> 00:07:37,689
receiving packets and passing them to

00:07:30,710 --> 00:07:42,560
the stack now has to support two new

00:07:37,689 --> 00:07:45,190
operations drop and forward which means

00:07:42,560 --> 00:07:48,889
that the art buffer might be kept in the

00:07:45,190 --> 00:07:50,599
device driver for smithing and the

00:07:48,889 --> 00:07:55,759
driver must wait for the Schmidt

00:07:50,599 --> 00:08:00,250
operation to complete also arcs for

00:07:55,759 --> 00:08:04,310
forwarding from our expect that adds

00:08:00,250 --> 00:08:06,949
more code to the to the arcs path which

00:08:04,310 --> 00:08:13,969
will hurt the death and destruction

00:08:06,949 --> 00:08:15,560
cache and also we have latency basic

00:08:13,969 --> 00:08:18,620
passing bills are paid chunk to the

00:08:15,560 --> 00:08:23,870
forward to the to the forwarding routine

00:08:18,620 --> 00:08:26,839
of the XDP will mean that if the page if

00:08:23,870 --> 00:08:29,000
the the device driver using numeral

00:08:26,839 --> 00:08:32,390
model which produces web pages and the

00:08:29,000 --> 00:08:37,010
pitch has multi users now now a page can

00:08:32,390 --> 00:08:38,570
be also has two packets one of them now

00:08:37,010 --> 00:08:43,060
we went to the stack and other packet

00:08:38,570 --> 00:08:46,880
with back to the device as xtp forward

00:08:43,060 --> 00:08:52,090
requested and this is not allowed by XTP

00:08:46,880 --> 00:08:55,750
so so solution for that should

00:08:52,090 --> 00:08:58,480
instead of pet fragments or buffer which

00:08:55,750 --> 00:09:02,170
we we we should only allow a page per

00:08:58,480 --> 00:09:04,990
packet and this is where page per packet

00:09:02,170 --> 00:09:08,790
requirements come from and we can

00:09:04,990 --> 00:09:12,490
support we can resolve all the

00:09:08,790 --> 00:09:15,760
performance reductions with the park

00:09:12,490 --> 00:09:23,350
staging and bulking which just barrier

00:09:15,760 --> 00:09:27,670
and suggest one more challenge that how

00:09:23,350 --> 00:09:32,410
can we extend X to the program on the

00:09:27,670 --> 00:09:34,930
fly and there were two suggestions to do

00:09:32,410 --> 00:09:37,510
that one of them are see you locking

00:09:34,930 --> 00:09:40,240
mechanism which was introduced and then

00:09:37,510 --> 00:09:42,850
it will explore driver for my tested I

00:09:40,240 --> 00:09:46,000
think was a little bit complex so I

00:09:42,850 --> 00:09:48,220
suggested another solution to have no

00:09:46,000 --> 00:09:50,950
peace in chronic nervous synchronization

00:09:48,220 --> 00:09:53,080
and they simply out the aurochs routine

00:09:50,950 --> 00:09:57,130
for a moment it's change of the exchange

00:09:53,080 --> 00:10:01,690
Allah programs and resume their Oryx

00:09:57,130 --> 00:10:03,850
routines so I would like you now to

00:10:01,690 --> 00:10:06,970
discuss there and the two are its modes

00:10:03,850 --> 00:10:12,370
we have in our driver why both of them

00:10:06,970 --> 00:10:16,060
before xdp we cannot just simply as I

00:10:12,370 --> 00:10:18,400
said run the extra few we needed to

00:10:16,060 --> 00:10:24,130
change their our memory modules just to

00:10:18,400 --> 00:10:27,910
make xtp satisfied and happy with our

00:10:24,130 --> 00:10:31,720
memory module so I will go off the topic

00:10:27,910 --> 00:10:34,210
for a moment here and explain how or are

00:10:31,720 --> 00:10:37,060
its mode to work the first one we call

00:10:34,210 --> 00:10:40,570
is a linked list receive queue which is

00:10:37,060 --> 00:10:44,170
a the configure the conventional how its

00:10:40,570 --> 00:10:48,010
mode that most of the drivers now

00:10:44,170 --> 00:10:51,520
implement which simply means that a

00:10:48,010 --> 00:10:53,260
knowledge ring have a harder to script

00:10:51,520 --> 00:10:56,320
the script or per packet and the packet

00:10:53,260 --> 00:11:01,080
and that scripture points to an area of

00:10:56,320 --> 00:11:01,080
memory with at least a size of in tu

00:11:02,040 --> 00:11:07,590
and also before exhibit any minute start

00:11:06,120 --> 00:11:10,620
you next our driver we had a

00:11:07,590 --> 00:11:14,850
pre-allocated escapees and there and we

00:11:10,620 --> 00:11:19,620
mapped the the skb in our data buffer

00:11:14,850 --> 00:11:20,850
the exit of the hardware so once a

00:11:19,620 --> 00:11:23,250
packet arrives the escapees

00:11:20,850 --> 00:11:26,070
pre-allocated and it's really really

00:11:23,250 --> 00:11:28,320
there so this is not good for xt p first

00:11:26,070 --> 00:11:32,370
of all because we had to carry xt p if

00:11:28,320 --> 00:11:35,910
the result is trout also it wasn't a

00:11:32,370 --> 00:11:41,520
paper packet so we had to change the

00:11:35,910 --> 00:11:45,110
member model to support XP p the

00:11:41,520 --> 00:11:49,020
advantage of this this approach is that

00:11:45,110 --> 00:11:51,990
allocating this KB from 32 kilobytes

00:11:49,020 --> 00:11:54,480
escapee a locator was really fast and we

00:11:51,990 --> 00:11:56,700
lost that and we had to come up with

00:11:54,480 --> 00:12:01,730
some solution like page cache and page

00:11:56,700 --> 00:12:04,050
pools to overcome the Integra Dacian

00:12:01,730 --> 00:12:06,690
also a one disadvantage of this approach

00:12:04,050 --> 00:12:08,790
is that I think this is also true for

00:12:06,690 --> 00:12:12,540
most of the drivers there is a lot of

00:12:08,790 --> 00:12:17,910
memory waste i will visualize and

00:12:12,540 --> 00:12:22,790
explain in this slide so this is an

00:12:17,910 --> 00:12:25,680
example of an RX ring animals v it was

00:12:22,790 --> 00:12:28,050
kb pre-allocated and really waiting for

00:12:25,680 --> 00:12:30,330
incoming packets

00:12:28,050 --> 00:12:34,730
let's assume the fact those packets are

00:12:30,330 --> 00:12:38,640
really small 64 kilobyte or 64 bytes and

00:12:34,730 --> 00:12:41,490
each packet will now consume 1 s kb and

00:12:38,640 --> 00:12:45,230
as we see here the remainder of the s kb

00:12:41,490 --> 00:12:48,180
part the Skip million our board is name

00:12:45,230 --> 00:12:51,540
is going to waste and this is why we

00:12:48,180 --> 00:12:57,300
came up with what we call starting our Q

00:12:51,540 --> 00:13:02,100
and byte stream or exposure ring so this

00:12:57,300 --> 00:13:03,900
is the situation before X V P so for x

00:13:02,100 --> 00:13:06,960
DP we came up with this is the following

00:13:03,900 --> 00:13:11,160
solution now instead of escapees we have

00:13:06,960 --> 00:13:15,269
a page for the

00:13:11,160 --> 00:13:21,269
guitar and now Skippy's or I'll get it

00:13:15,269 --> 00:13:23,940
or built on demand using build skb also

00:13:21,269 --> 00:13:27,899
we we made sure we have enough Headroom

00:13:23,940 --> 00:13:30,569
and tear on of the size of the shared

00:13:27,899 --> 00:13:33,420
info just to make bill disk a be happy

00:13:30,569 --> 00:13:37,860
and make it work again this works

00:13:33,420 --> 00:13:39,810
perfectly for sk b XD p and this is our

00:13:37,860 --> 00:13:43,139
current solution for its DP which is

00:13:39,810 --> 00:13:52,709
upstream but we are still not happy with

00:13:43,139 --> 00:13:54,029
the memory waste so this is yeah we now

00:13:52,709 --> 00:13:57,120
with the solution also the page

00:13:54,029 --> 00:13:58,829
alligator becomes the bottleneck and we

00:13:57,120 --> 00:14:02,160
came up with the paid pool and paid

00:13:58,829 --> 00:14:07,699
recycling mechanism to overcome this

00:14:02,160 --> 00:14:11,370
degradation but i stole the memory waste

00:14:07,699 --> 00:14:13,500
still there and this is why we have what

00:14:11,370 --> 00:14:18,800
we call sliding our queue and by stream

00:14:13,500 --> 00:14:21,600
buffering well the idea here is that

00:14:18,800 --> 00:14:23,670
first of all you need the hardware

00:14:21,600 --> 00:14:26,610
support of this feature which we have

00:14:23,670 --> 00:14:30,660
which we have in our kinetics for leaks

00:14:26,610 --> 00:14:34,829
and all the upcoming generation of our

00:14:30,660 --> 00:14:38,519
hardware but idea here is that each

00:14:34,829 --> 00:14:41,819
hardware descriptor has points to more

00:14:38,519 --> 00:14:46,980
than an MTU buffer it can point to any

00:14:41,819 --> 00:14:49,920
any size of buffer you want and one one

00:14:46,980 --> 00:14:53,639
hardware descriptor can serve more than

00:14:49,920 --> 00:14:57,959
one packet so really there is no

00:14:53,639 --> 00:15:00,420
memories I will visualize later the

00:14:57,959 --> 00:15:02,670
advantages is that we don't have to

00:15:00,420 --> 00:15:05,339
access the hardware and write back but

00:15:02,670 --> 00:15:07,680
the script or on each packet comm can be

00:15:05,339 --> 00:15:12,829
done once there the old avatar is

00:15:07,680 --> 00:15:15,389
consumed we will have to write back the

00:15:12,829 --> 00:15:18,839
larger descriptor to back to the

00:15:15,389 --> 00:15:21,449
hardware go to the arc string on current

00:15:18,839 --> 00:15:21,870
configured configuration is 1600

00:15:21,449 --> 00:15:25,440
destroyed

00:15:21,870 --> 00:15:30,170
descriptive verses 1 1 K in there the

00:15:25,440 --> 00:15:33,630
previous model and each one points to

00:15:30,170 --> 00:15:36,900
128 kilobytes you can do the math it can

00:15:33,630 --> 00:15:41,430
serve a lot small packets also a lot o

00:15:36,900 --> 00:15:45,870
into your packets and if you will there

00:15:41,430 --> 00:15:48,529
is more packet packet burst tolerance no

00:15:45,870 --> 00:15:51,270
memory waste also until organist ik

00:15:48,529 --> 00:15:53,820
since it doesn't depends on in them to

00:15:51,270 --> 00:15:56,130
you you can help even jump frame into 9

00:15:53,820 --> 00:15:58,470
K and the same model will work without

00:15:56,130 --> 00:16:03,210
even change without even they are

00:15:58,470 --> 00:16:05,460
locating the range one disadvantage is

00:16:03,210 --> 00:16:09,810
that xt p will not work with this model

00:16:05,460 --> 00:16:14,400
because paid per packet is it's not true

00:16:09,810 --> 00:16:17,820
here so this is a visualization for this

00:16:14,400 --> 00:16:21,570
model you can't we can we see here that

00:16:17,820 --> 00:16:25,620
our ring has only two pages the hata for

00:16:21,570 --> 00:16:32,720
only two pages let's assume those pages

00:16:25,620 --> 00:16:34,980
are huge pages and for for for the

00:16:32,720 --> 00:16:38,070
previous example we have two packets

00:16:34,980 --> 00:16:40,230
here and 200 descriptor the two packets

00:16:38,070 --> 00:16:41,940
now do not need to each one does not

00:16:40,230 --> 00:16:44,730
need to go to a different descriptor

00:16:41,940 --> 00:16:47,820
both can go continuously to that the

00:16:44,730 --> 00:16:52,410
same descriptor and consuming the bottle

00:16:47,820 --> 00:16:55,640
without leaving gaps in between also for

00:16:52,410 --> 00:16:58,800
as a future for 40 meter walk for GDP

00:16:55,640 --> 00:17:01,830
assuming that xdp will not require

00:16:58,800 --> 00:17:05,939
pitch-perfect anymore

00:17:01,830 --> 00:17:09,990
we can do the following bakit packets

00:17:05,939 --> 00:17:14,100
can still go continuously into a byte

00:17:09,990 --> 00:17:15,990
stream buffer we can make sure from

00:17:14,100 --> 00:17:17,730
hardware that the hardware will preserve

00:17:15,990 --> 00:17:20,370
a Headroom and the terror room which is

00:17:17,730 --> 00:17:25,380
a well known for its VP and also we can

00:17:20,370 --> 00:17:28,110
tell the hardware do not plant across

00:17:25,380 --> 00:17:30,260
pages each new packet if it's if it does

00:17:28,110 --> 00:17:30,260
not

00:17:30,410 --> 00:17:36,960
cannot be inserted continuing physically

00:17:33,630 --> 00:17:39,990
continuously to a page we can skip that

00:17:36,960 --> 00:17:46,620
so the the second descriptor or an or

00:17:39,990 --> 00:17:51,030
the second page also we can do other

00:17:46,620 --> 00:17:53,610
zero pages most pages for straining

00:17:51,030 --> 00:17:55,980
darkroom it does not have to be huge

00:17:53,610 --> 00:17:59,340
pages and continue it and physically

00:17:55,980 --> 00:18:03,450
continuous we can in our hardware we

00:17:59,340 --> 00:18:06,350
support virtual mapping so we can get

00:18:03,450 --> 00:18:09,210
descriptor we can allocate 32 pages and

00:18:06,350 --> 00:18:10,770
map them forward into one descriptor

00:18:09,210 --> 00:18:13,380
into the hardware and the hardware can

00:18:10,770 --> 00:18:16,500
see it see them see them as virtually

00:18:13,380 --> 00:18:20,330
continuous so there is no issue of

00:18:16,500 --> 00:18:23,990
having starting are you working with

00:18:20,330 --> 00:18:23,990
order zero pages

00:18:28,890 --> 00:18:34,440
yeah also order this video pages is good

00:18:31,529 --> 00:18:38,159
for the case where the dose effects a

00:18:34,440 --> 00:18:44,010
cure we will not have a memory

00:18:38,159 --> 00:18:47,909
fragmentation and also the zero pages

00:18:44,010 --> 00:18:51,630
works well with page pool and page

00:18:47,909 --> 00:18:54,750
recycling mechanism we added some more

00:18:51,630 --> 00:18:57,299
advantages of this model is that the

00:18:54,750 --> 00:18:59,970
nick demerits now can write to a

00:18:57,299 --> 00:19:02,519
continuous buffer which is the bitter

00:18:59,970 --> 00:19:08,760
fordham a cache and performance lissa a

00:19:02,519 --> 00:19:11,909
new cache misses also posting them a

00:19:08,760 --> 00:19:14,700
buffer in a page granularity is is more

00:19:11,909 --> 00:19:19,279
natural and as I said this is empty

00:19:14,700 --> 00:19:22,260
agnostic some numbers here

00:19:19,279 --> 00:19:24,419
comparing the the first model with the

00:19:22,260 --> 00:19:28,740
second one as we see here the first

00:19:24,419 --> 00:19:32,880
model can only handle one q1k packets

00:19:28,740 --> 00:19:38,389
for for one pairs but this mode the new

00:19:32,880 --> 00:19:38,389
model can can we do the math can handle

00:19:39,139 --> 00:19:47,490
32 32 care packets and if you are

00:19:44,159 --> 00:19:50,789
talking about 64 byte packets as we see

00:19:47,490 --> 00:19:54,870
here there are almost no drops up to 32

00:19:50,789 --> 00:20:03,240
care package and we see small drops once

00:19:54,870 --> 00:20:05,370
we spend there the best what one

00:20:03,240 --> 00:20:09,260
downside of this model is that currently

00:20:05,370 --> 00:20:13,289
the camera does not does not have a

00:20:09,260 --> 00:20:17,039
normal day PII to configure their the

00:20:13,289 --> 00:20:19,889
arcs buffer and the size the only API we

00:20:17,039 --> 00:20:22,860
have is to configure the ring size which

00:20:19,889 --> 00:20:26,190
means how many descriptors we want so we

00:20:22,860 --> 00:20:29,130
might need to add in the future a normal

00:20:26,190 --> 00:20:31,950
API to configure starting out hood or

00:20:29,130 --> 00:20:36,450
the the byte stream buffering

00:20:31,950 --> 00:20:37,860
mechanism let's go back to XTP I will

00:20:36,450 --> 00:20:39,690
talk about the implementation details

00:20:37,860 --> 00:20:46,730
and we will discuss the performance

00:20:39,690 --> 00:20:52,470
number numbers we got with next EP okay

00:20:46,730 --> 00:20:57,179
exhibits drop in order to to have it's

00:20:52,470 --> 00:20:59,429
DP available into our driver we had as I

00:20:57,179 --> 00:21:02,850
said we had to do a lot for factoring

00:20:59,429 --> 00:21:10,260
and changing the memory module to to be

00:21:02,850 --> 00:21:14,639
suitable with XTP as I said we needed to

00:21:10,260 --> 00:21:18,029
change the XTP model at the memory model

00:21:14,639 --> 00:21:23,539
to have a page per packet we needed to

00:21:18,029 --> 00:21:27,000
preserve a a head room and the Terran

00:21:23,539 --> 00:21:31,169
with the size of official info in order

00:21:27,000 --> 00:21:33,419
to make Buddhist give you or and we had

00:21:31,169 --> 00:21:36,240
to add a page cache pool to cover the

00:21:33,419 --> 00:21:38,760
performance adduction and for XTP drop

00:21:36,240 --> 00:21:40,590
action we recycle the page back to the

00:21:38,760 --> 00:21:43,049
into the hardware which was really fast

00:21:40,590 --> 00:21:45,960
and this is where we see the good

00:21:43,049 --> 00:21:50,309
performance for xdp pairs we just build

00:21:45,960 --> 00:21:54,059
this kV and pass to the stack as I said

00:21:50,309 --> 00:21:56,250
for it is DP program exchange we for a

00:21:54,059 --> 00:21:58,139
teeny tiny amount of time with the saber

00:21:56,250 --> 00:22:00,240
bar to handling and we never

00:21:58,139 --> 00:22:03,090
synchronized to flush over and ongoing

00:22:00,240 --> 00:22:06,179
work and going running in xtb programs

00:22:03,090 --> 00:22:08,850
we quickly exchange the program enable

00:22:06,179 --> 00:22:10,889
back the receive queue of the ring and

00:22:08,850 --> 00:22:15,960
nap schedule in case we missed some

00:22:10,889 --> 00:22:18,389
packets for ticks forwarding it was a

00:22:15,960 --> 00:22:21,419
little bit more complicated than that

00:22:18,389 --> 00:22:24,960
we added a dedicated thick string for

00:22:21,419 --> 00:22:27,269
the for each Oryx ring and we made sure

00:22:24,960 --> 00:22:31,169
that the Oryx page is a writable so it's

00:22:27,269 --> 00:22:33,450
the people so IPPF programs can modify

00:22:31,169 --> 00:22:38,429
the packets and send it send them back

00:22:33,450 --> 00:22:42,440
to the step to the report when XDP ticks

00:22:38,429 --> 00:22:44,480
we we put back both

00:22:42,440 --> 00:22:47,210
the packet into the HDPE dedicated thick

00:22:44,480 --> 00:22:51,020
string there is a place available of

00:22:47,210 --> 00:22:54,230
course we don't push the X doorbell yet

00:22:51,020 --> 00:22:58,580
maybe we have more packets as in nappy

00:22:54,230 --> 00:23:02,660
and a nappy loop we are processing more

00:22:58,580 --> 00:23:05,030
and more packets or want to only flush

00:23:02,660 --> 00:23:08,240
or send the tick's packets at the end of

00:23:05,030 --> 00:23:12,470
that loop we do not release the and

00:23:08,240 --> 00:23:15,890
recycle pages yet we only handle the

00:23:12,470 --> 00:23:20,410
pages once the Teague's routine and the

00:23:15,890 --> 00:23:23,750
text completion gets back from hardware

00:23:20,410 --> 00:23:27,110
we also added a small like Macca's

00:23:23,750 --> 00:23:32,780
mechanism as I said one snappy new never

00:23:27,110 --> 00:23:36,260
loop complete and if xtp thick secured

00:23:32,780 --> 00:23:39,440
one at least once we push the TX toriel

00:23:36,260 --> 00:23:43,700
and notify the hardware of outgoing

00:23:39,440 --> 00:23:47,830
packets from xtp ok a little bit

00:23:43,700 --> 00:23:50,750
performance numbers I'm here comparing

00:23:47,830 --> 00:23:54,460
the only solution to solution we had to

00:23:50,750 --> 00:23:58,430
drop packets before is VP was with the

00:23:54,460 --> 00:24:02,980
TC filter to drop packets from hardware

00:23:58,430 --> 00:24:06,560
we got to 5.3 million packets per second

00:24:02,980 --> 00:24:14,030
with xtp first drop we with this model

00:24:06,560 --> 00:24:17,420
we got to 16 0.5 which is which is a lot

00:24:14,030 --> 00:24:19,330
faster and with XT Peaks meat as we see

00:24:17,420 --> 00:24:24,140
here it's less than first drop because

00:24:19,330 --> 00:24:28,360
we waste more CPU for forelimb packets

00:24:24,140 --> 00:24:35,360
but I'm sure this is much better than

00:24:28,360 --> 00:24:39,290
the ipv4 forwarding those numbers as

00:24:35,360 --> 00:24:43,220
well scale nicely if you increase the

00:24:39,290 --> 00:24:45,730
number of course and for Janelle here I

00:24:43,220 --> 00:24:47,970
have a number for you for when you

00:24:45,730 --> 00:24:51,180
really afford the

00:24:47,970 --> 00:24:53,760
I will filter to the TC filter to the

00:24:51,180 --> 00:24:55,680
hardware we get 46 million packets per

00:24:53,760 --> 00:24:59,180
second and we can do more because this

00:24:55,680 --> 00:25:02,310
is was this number was limited with my

00:24:59,180 --> 00:25:08,130
ex meter but what's really talking about

00:25:02,310 --> 00:25:09,140
XDP here so this is off topic once more

00:25:08,130 --> 00:25:12,860
not here

00:25:09,140 --> 00:25:16,680
thanks with in that last test so don't

00:25:12,860 --> 00:25:19,620
this was my earlier point in the email

00:25:16,680 --> 00:25:22,410
exchange this phone wasn't the best use

00:25:19,620 --> 00:25:25,770
case right if I can drop at 46 million

00:25:22,410 --> 00:25:30,600
packets per second in hardware or NIC

00:25:25,770 --> 00:25:42,150
like this I don't see the point of using

00:25:30,600 --> 00:25:43,890
that as a use case for the ML X 5 so

00:25:42,150 --> 00:25:46,500
it's it's like anything else and we have

00:25:43,890 --> 00:25:48,690
to start with comparisons right so if

00:25:46,500 --> 00:25:50,010
you compare this against the stack great

00:25:48,690 --> 00:25:52,440
if you compare it against the hardware

00:25:50,010 --> 00:25:54,960
not so great but the point here is that

00:25:52,440 --> 00:25:57,660
this is this is the test case to begin

00:25:54,960 --> 00:26:00,570
with we're trying to run at the speed of

00:25:57,660 --> 00:26:03,630
the CPU there is no doubt that hardware

00:26:00,570 --> 00:26:05,640
can do stuff faster but then hardware is

00:26:03,630 --> 00:26:07,620
it as programmable as this so this

00:26:05,640 --> 00:26:10,290
package drop becomes denial of service

00:26:07,620 --> 00:26:12,360
attack where I'm dropping packets with

00:26:10,290 --> 00:26:14,610
pattern XYZ am I going to do that and

00:26:12,360 --> 00:26:16,650
the hardware as easily as xgp so just

00:26:14,610 --> 00:26:19,080
think of the packet drop is not in

00:26:16,650 --> 00:26:21,240
itself useful but it's a very important

00:26:19,080 --> 00:26:28,260
test and also running this on a single

00:26:21,240 --> 00:26:30,300
CPU is also important one more thing a

00:26:28,260 --> 00:26:33,540
PPF program is more powerful than any

00:26:30,300 --> 00:26:35,790
hardware filter so this one can't afford

00:26:33,540 --> 00:26:40,980
I'm sorry can we wrap it up so young

00:26:35,790 --> 00:26:43,620
sonken yeah sure finger on I I think

00:26:40,980 --> 00:26:48,600
that's it future improvement as I said

00:26:43,620 --> 00:26:55,270
we need to do more work for rx staging

00:26:48,600 --> 00:26:57,580
and bulking to Manaus also xdp TX

00:26:55,270 --> 00:26:59,980
more instruction to the arts routine so

00:26:57,580 --> 00:27:04,270
we have to do the staging and to be

00:26:59,980 --> 00:27:06,610
properly to have better performance I'm

00:27:04,270 --> 00:27:09,460
not sure about the second one if we

00:27:06,610 --> 00:27:12,880
remove the requirement of a vegetable

00:27:09,460 --> 00:27:15,190
packet to be really good because with

00:27:12,880 --> 00:27:17,560
studying our cue the our first trial we

00:27:15,190 --> 00:27:20,170
did with xdb we got 232 million packets

00:27:17,560 --> 00:27:23,140
per second with starting our queue which

00:27:20,170 --> 00:27:26,650
is not good for exhibiting that do fetch

00:27:23,140 --> 00:27:33,490
per packet also having a dedicated

00:27:26,650 --> 00:27:35,740
xtp Oryx rings might might give us a

00:27:33,490 --> 00:27:39,510
good separation between 60p flows and

00:27:35,740 --> 00:27:42,580
normal flows and when we wouldn't add

00:27:39,510 --> 00:27:47,590
more complexity to the normal stack

00:27:42,580 --> 00:27:50,110
received flow one more thing zero copy I

00:27:47,590 --> 00:27:54,040
think this is the only gap we have left

00:27:50,110 --> 00:27:58,080
to close against the PDK and maybe net

00:27:54,040 --> 00:28:01,990
channels can solve that I'm not sure so

00:27:58,080 --> 00:28:05,940
yeah that's it one reminder Leviticus

00:28:01,990 --> 00:28:05,940
not Linux it's the peers

00:28:17,120 --> 00:28:23,270
no this is quoted from Daiso thank you

00:28:21,660 --> 00:28:31,490
dude

00:28:23,270 --> 00:28:31,490
yeah questions okay thank you

00:29:15,950 --> 00:29:18,950
yeah

00:29:42,220 --> 00:29:45,220
close

00:29:55,090 --> 00:29:58,090
closely

00:30:12,400 --> 00:30:22,340
okay okay this is even solo and yen

00:30:20,059 --> 00:30:25,190
it's my colleague we are from Bali we

00:30:22,340 --> 00:30:27,380
have been working on something at CDP

00:30:25,190 --> 00:30:29,870
today I'm going to introduce what we

00:30:27,380 --> 00:30:31,010
have done and also want to listen to

00:30:29,870 --> 00:30:36,200
your input

00:30:31,010 --> 00:30:39,710
typically the okay the first thing right

00:30:36,200 --> 00:30:45,460
when we talk about XDP firstly we are

00:30:39,710 --> 00:30:45,460
talking about some fast IO Network IO

00:30:47,380 --> 00:30:52,940
yes in the last year's people side

00:30:50,420 --> 00:30:56,750
TPD can not map can do they try to do

00:30:52,940 --> 00:30:59,120
better i but the thing is why we have

00:30:56,750 --> 00:31:01,280
been utilized those things we didn't

00:30:59,120 --> 00:31:04,040
think really TPD case a hand loading

00:31:01,280 --> 00:31:06,350
food for networking because you have to

00:31:04,040 --> 00:31:11,120
rebuild everything this information we

00:31:06,350 --> 00:31:14,330
used maybe three years 53 years ago in

00:31:11,120 --> 00:31:26,240
several conferences but yeah we have

00:31:14,330 --> 00:31:30,460
been thinking this way even at a remark

00:31:26,240 --> 00:31:33,650
that we develop this four years ago and

00:31:30,460 --> 00:31:36,170
for some different purpose originally

00:31:33,650 --> 00:31:39,500
it was for virtualization because we

00:31:36,170 --> 00:31:43,340
were running the different Linux relief

00:31:39,500 --> 00:31:47,059
and in different environments so we

00:31:43,340 --> 00:31:50,510
needed some fast Network IO driver

00:31:47,059 --> 00:31:52,929
framework for this work so in the design

00:31:50,510 --> 00:31:56,860
a framework basically to handle the

00:31:52,929 --> 00:32:00,440
virtual switch traffic also for us back

00:31:56,860 --> 00:32:03,290
the party the police water sewage

00:32:00,440 --> 00:32:05,750
today's and we supported many drivers

00:32:03,290 --> 00:32:06,380
fluid levels in the house for all car

00:32:05,750 --> 00:32:09,410
Mellanox

00:32:06,380 --> 00:32:12,200
and the Inuits or those 10 gig and 40

00:32:09,410 --> 00:32:17,350
gig things also some accelerators says

00:32:12,200 --> 00:32:17,350
for it possible salary can but Sicilians

00:33:56,869 --> 00:34:05,969
- somehow SDP because he now is trying

00:34:00,899 --> 00:34:10,500
to do much faster IO and network

00:34:05,969 --> 00:34:13,470
processing this highlight items were

00:34:10,500 --> 00:34:17,339
done the Tokyo over for XD p

00:34:13,470 --> 00:34:20,159
particularly verily we have done the

00:34:17,339 --> 00:34:24,529
management memory management metadata

00:34:20,159 --> 00:34:24,529
and some other things

00:34:42,399 --> 00:34:47,859
- sighs the pike hair2wear recycle and

00:34:52,990 --> 00:35:00,410
when you also convert a packet

00:34:55,639 --> 00:35:19,210
throughout KD so we modify the function

00:35:00,410 --> 00:35:23,270
to make sure you don't we titrate

00:35:19,210 --> 00:35:25,210
against using links break and obvious

00:35:23,270 --> 00:35:28,460
you see forty percent performance

00:35:25,210 --> 00:35:30,830
increment with a they also see forty

00:35:28,460 --> 00:35:33,260
percent improvement also we've had two

00:35:30,830 --> 00:35:39,920
Deep Sea joking early doping with one

00:35:33,260 --> 00:35:40,700
steep you tried with twenty man impact

00:35:39,920 --> 00:35:48,050
the Prosecco

00:35:40,700 --> 00:35:48,650
let's see some numbers numbers from 40

00:35:48,050 --> 00:35:51,170
gig

00:35:48,650 --> 00:35:53,540
Nick that is not saying that the better

00:35:51,170 --> 00:35:57,140
one right because we so different the

00:35:53,540 --> 00:36:00,710
numbers we just use the first one to to

00:35:57,140 --> 00:36:03,920
show the numbers so any means as well as

00:36:00,710 --> 00:36:13,790
I CDP will see the power of packet you

00:36:03,920 --> 00:36:15,290
take a look have a packet and drop it to

00:36:13,790 --> 00:36:17,720
the person performance that the software

00:36:15,290 --> 00:36:20,660
can get from power

00:36:17,720 --> 00:36:26,080
we saw this one features right you can

00:36:20,660 --> 00:36:26,080
simply 1229 need in factor per second

00:37:51,400 --> 00:38:04,310
that's very amusing transmit more on the

00:37:58,460 --> 00:38:05,810
packaging yes yeah okay I don't know why

00:38:04,310 --> 00:38:08,900
the numbers aren't much much larger I

00:38:05,810 --> 00:38:11,030
mean even on two-year old machines I was

00:38:08,900 --> 00:38:13,900
seeing 15 million almost 15 million

00:38:11,030 --> 00:38:13,900
packets per second

00:38:40,190 --> 00:39:54,240
so we are working memory is you get from

00:39:41,220 --> 00:39:59,790
the two together take a DNA and take the

00:39:54,240 --> 00:40:08,630
processing execute such as q and r

00:39:59,790 --> 00:40:08,630
execute so that one

00:40:12,580 --> 00:40:19,820
then maybe the very simple to convert or

00:40:16,340 --> 00:40:23,920
take it to a skivvy without anything

00:40:19,820 --> 00:40:23,920
that appeals to the buffer to sin page

00:40:26,740 --> 00:40:34,330
metadata you can customize your metadata

00:40:30,050 --> 00:40:34,330
for the package for different purpose

00:40:42,910 --> 00:40:48,620
some it as Facebook we have made some

00:40:46,220 --> 00:40:51,290
major Chinese firstly we are treated as

00:40:48,620 --> 00:40:55,070
DB code to be able to forward to a

00:40:51,290 --> 00:40:58,790
different metal device including what we

00:40:55,070 --> 00:41:03,680
need like the user or the host and I say

00:40:58,790 --> 00:41:07,270
Adina we can support some customizable

00:41:03,680 --> 00:41:10,730
metadata and also reserve the hider room

00:41:07,270 --> 00:41:13,160
and then below the told me to kill and

00:41:10,730 --> 00:41:16,660
actually the original implement reason

00:41:13,160 --> 00:41:20,150
is to avoid looking for that has neat

00:41:16,660 --> 00:41:21,560
technique you but what the face we saw

00:41:20,150 --> 00:41:24,470
also so different things

00:41:21,560 --> 00:41:26,750
it is a lot of recently performance is

00:41:24,470 --> 00:41:29,750
my data that you need rid of the

00:41:26,750 --> 00:41:33,590
hardware the advances to the more

00:41:29,750 --> 00:41:39,500
kinetic you can simple e with an EQ kill

00:41:33,590 --> 00:41:42,410
for a TDP forwarding here is the current

00:41:39,500 --> 00:41:52,400
weather we have in the cold of course we

00:41:42,410 --> 00:41:56,110
can we discuss more in detail we are all

00:41:52,400 --> 00:41:58,940
these changes to the activity to have it

00:41:56,110 --> 00:42:02,270
that's being attacked under to the

00:41:58,940 --> 00:42:05,960
review and hopefully you can anyone will

00:42:02,270 --> 00:42:10,510
be welcome to review our code and see

00:42:05,960 --> 00:42:14,270
what we need to improve also discussing

00:42:10,510 --> 00:42:19,660
how to share the metadata so might the

00:42:14,270 --> 00:42:19,660
mangoes a CD few publications if I

00:42:22,119 --> 00:42:29,630
another cost because it is more kinetic

00:42:26,860 --> 00:42:33,410
whether we should define some more

00:42:29,630 --> 00:42:36,890
simple metadata the research phase and

00:42:33,410 --> 00:42:39,890
is being developed how to accelerate the

00:42:36,890 --> 00:42:42,410
hosting to celebrate her also

00:42:39,890 --> 00:42:45,830
visualizations of heart particularly hot

00:42:42,410 --> 00:42:47,450
who supported the water sewage are true

00:42:45,830 --> 00:42:51,130
to have a type of water switch

00:42:47,450 --> 00:42:54,770
performance and the load balancer since

00:42:51,130 --> 00:42:57,800
ok justice so the information I need

00:42:54,770 --> 00:42:59,869
questions yeah could you precise what

00:42:57,800 --> 00:43:12,590
kind of change you didn't get freeze

00:42:59,869 --> 00:43:15,230
could be just for my escape meditative

00:43:12,590 --> 00:43:17,240
past the end of the packet data so in

00:43:15,230 --> 00:43:19,369
KPS could be he checks his all this is a

00:43:17,240 --> 00:43:21,530
linear thing that just has the SK power

00:43:19,369 --> 00:43:23,720
plus the data just through the out the

00:43:21,530 --> 00:43:25,430
memory object up once so there's no

00:43:23,720 --> 00:43:27,230
separation between the network metadata

00:43:25,430 --> 00:43:29,990
allocation and the packet data

00:43:27,230 --> 00:43:32,330
allocation that's why it's faster so how

00:43:29,990 --> 00:43:34,970
about all the other paths that might

00:43:32,330 --> 00:43:36,440
changes can be heard like PS k be expand

00:43:34,970 --> 00:43:40,280
stuff like that they have to allocate a

00:43:36,440 --> 00:43:41,810
new SKT head so but they emotion only

00:43:40,280 --> 00:43:44,240
one point in the stack but apparently

00:43:41,810 --> 00:43:47,869
they had to change a lot of points it's

00:43:44,240 --> 00:43:50,570
not a phrase could be there's a change

00:43:47,869 --> 00:43:51,740
in the model for sqb management for sure

00:43:50,570 --> 00:43:52,730
and there's a lot of places that need to

00:43:51,740 --> 00:43:56,900
be changed yes I agree

00:43:52,730 --> 00:44:02,869
yeah there's changes in the pre-k three

00:43:56,900 --> 00:44:08,060
escapees the variously specifically

00:44:02,869 --> 00:44:11,150
there's a signature of the other side so

00:44:08,060 --> 00:44:13,609
that when you said we were freed as KB

00:44:11,150 --> 00:44:17,720
you have to check this if this is from

00:44:13,609 --> 00:44:19,940
our packet if it is then using our free

00:44:17,720 --> 00:44:23,750
escapee watching otherwise

00:44:19,940 --> 00:44:25,770
you did not so this is kind of you can

00:44:23,750 --> 00:44:31,670
have some more improvement

00:44:25,770 --> 00:44:34,080
but this is current rate and you know

00:44:31,670 --> 00:44:36,180
and one thing that's nice about this is

00:44:34,080 --> 00:44:37,980
that if you have if we have our

00:44:36,180 --> 00:44:39,300
configuration where XTP traffic is

00:44:37,980 --> 00:44:41,820
shared on the queue with normal stack

00:44:39,300 --> 00:44:43,980
traffic the transition into a full-blood

00:44:41,820 --> 00:44:48,180
skp object is really fast we don't incur

00:44:43,980 --> 00:44:52,020
another allocation it's really nice and

00:44:48,180 --> 00:44:58,980
I like added more comment on the forward

00:44:52,020 --> 00:45:02,220
apart the Year close to 10 million PPS

00:44:58,980 --> 00:45:04,440
this progressive we actually added we

00:45:02,220 --> 00:45:08,850
change a little bit of the forwarding

00:45:04,440 --> 00:45:11,310
mechanism of xdp so because the normal

00:45:08,850 --> 00:45:14,880
actually P forwarding which is bouncing

00:45:11,310 --> 00:45:17,730
back to the original interface but will

00:45:14,880 --> 00:45:22,800
make some changes so that we can

00:45:17,730 --> 00:45:27,030
actually forward into different any that

00:45:22,800 --> 00:45:29,130
device so that locking is required so

00:45:27,030 --> 00:45:34,650
that's why we see the difference between

00:45:29,130 --> 00:45:39,660
the data numbers so this number actually

00:45:34,650 --> 00:45:42,119
the 9.6 number is basically sending it's

00:45:39,660 --> 00:45:44,970
also been suppressing back but if you

00:45:42,119 --> 00:45:47,690
want actual for the different interface

00:45:44,970 --> 00:45:50,850
which could be a different drivers

00:45:47,690 --> 00:45:54,300
different hardware it could be a little

00:45:50,850 --> 00:45:57,119
bit slower than this and also we can

00:45:54,300 --> 00:46:02,160
actually forward to a virtual device

00:45:57,119 --> 00:46:06,150
like a big pair so that so just using

00:46:02,160 --> 00:46:13,950
the year stop xm8 standard static Smith

00:46:06,150 --> 00:46:18,410
function so so we see some kind of like

00:46:13,950 --> 00:46:21,240
at six million people's because the

00:46:18,410 --> 00:46:23,790
since they're the one side outside the

00:46:21,240 --> 00:46:34,050
actual sent for the the protocol started

00:46:23,790 --> 00:46:34,930
jobs so because we actually serve actual

00:46:34,050 --> 00:46:39,130
forward to the

00:46:34,930 --> 00:46:41,410
the virtual Nick so that's the

00:46:39,130 --> 00:46:45,660
difference I think so yeah we will have

00:46:41,410 --> 00:46:48,849
some changes on that XD people reading

00:46:45,660 --> 00:46:52,230
semantics but I don't know if it is good

00:46:48,849 --> 00:46:55,779
or bad but we did a tree study the

00:46:52,230 --> 00:47:03,029
experiment experiment say we actually

00:46:55,779 --> 00:47:08,010
can the BGF code can actually change our

00:47:03,029 --> 00:48:09,190
metadata partial so you can keep your

00:47:08,010 --> 00:48:11,339
index and then in the depends on a lot

00:48:09,190 --> 00:48:14,589
of icing piece coming out of this thing

00:48:11,339 --> 00:48:18,130
I see there's no i simpiy that because

00:48:14,589 --> 00:48:23,859
of the drop of destination or what some

00:48:18,130 --> 00:48:27,010
unreachable like you start your results

00:48:23,859 --> 00:48:34,130
then so there's like if you don't have

00:48:27,010 --> 00:48:36,259
the important listening so you can son

00:48:34,130 --> 00:48:38,029
1,000 i simpiy message back per second

00:48:36,259 --> 00:48:40,660
so it's not going to kill the

00:48:38,029 --> 00:48:40,660
performance

00:48:43,720 --> 00:48:54,540
yeah other questions we have the nest

00:48:46,500 --> 00:48:54,540
presenter thank you

00:49:07,390 --> 00:49:13,960
right good morning everyone my name is

00:49:10,990 --> 00:49:17,440
Prem general Kadam with barefoot

00:49:13,960 --> 00:49:20,920
networks today I want to demonstrate to

00:49:17,440 --> 00:49:23,470
you what we have done as far as getting

00:49:20,920 --> 00:49:27,100
one of the xtp use cases which is an

00:49:23,470 --> 00:49:29,410
isle a router to run on our switch so

00:49:27,100 --> 00:49:33,880
this is running on the switch not the

00:49:29,410 --> 00:49:36,550
server so just to kind of set the

00:49:33,880 --> 00:49:40,030
context what I'm going to show today is

00:49:36,550 --> 00:49:43,240
what's happening on that nbe the network

00:49:40,030 --> 00:49:45,160
virtualization edge box as far as

00:49:43,240 --> 00:49:50,230
running back functionality on the server

00:49:45,160 --> 00:49:52,450
I think Tom covered it yesterday showed

00:49:50,230 --> 00:49:53,980
how the flow works and everything so

00:49:52,450 --> 00:49:56,320
this is basically taking that same

00:49:53,980 --> 00:50:03,040
functionality and running it on a top of

00:49:56,320 --> 00:50:06,240
X which so here's a quick set up for the

00:50:03,040 --> 00:50:10,180
demo so we have two tow phenol switches

00:50:06,240 --> 00:50:12,070
with two hosts connected to them the

00:50:10,180 --> 00:50:14,560
hosts are non Iowa hosts

00:50:12,070 --> 00:50:17,980
they're communicating using sir

00:50:14,560 --> 00:50:21,280
addresses and Tofino switches will do

00:50:17,980 --> 00:50:24,220
the translation from sir to ila Nile a

00:50:21,280 --> 00:50:26,470
back to sir so this is all happening on

00:50:24,220 --> 00:50:30,850
the switch the host doesn't know

00:50:26,470 --> 00:50:32,650
anything about this so just to give a

00:50:30,850 --> 00:50:34,270
little bit more context what what is

00:50:32,650 --> 00:50:38,770
stuff we now what is barefoot Tofino

00:50:34,270 --> 00:50:42,280
it's a 6.5 terabits per second fully

00:50:38,770 --> 00:50:46,360
programmable ethernet switch ASIC quite

00:50:42,280 --> 00:50:51,250
the beast actually have sixty five

00:50:46,360 --> 00:50:53,470
hundred Gigabit Ethernet ports on it the

00:50:51,250 --> 00:50:55,720
full user program abilities that ship

00:50:53,470 --> 00:50:58,960
using p4 so you can write any program on

00:50:55,720 --> 00:51:01,510
p4 use our compiler put it on the switch

00:50:58,960 --> 00:51:03,730
it runs that line right some of the

00:51:01,510 --> 00:51:07,000
things we can do we can do a full top of

00:51:03,730 --> 00:51:12,640
X which functionality we can do a load

00:51:07,000 --> 00:51:14,350
balancer firewall dos int is in band

00:51:12,640 --> 00:51:17,950
network telemetry you can do things like

00:51:14,350 --> 00:51:19,540
you know per packet visibility

00:51:17,950 --> 00:51:22,869
actually any type of packet processing

00:51:19,540 --> 00:51:26,410
we do and all of your trends at six

00:51:22,869 --> 00:51:28,300
point five Hertz per second so there is

00:51:26,410 --> 00:51:30,730
also a program called switched or p4

00:51:28,300 --> 00:51:33,310
which we have written it implements all

00:51:30,730 --> 00:51:35,710
the data plane features that you would

00:51:33,310 --> 00:51:37,869
need on a typical top-of-rack switch or

00:51:35,710 --> 00:51:43,630
a spine switch or a course which

00:51:37,869 --> 00:51:45,609
whatever it's a fully developed and also

00:51:43,630 --> 00:51:48,790
open source this is quite a big deal

00:51:45,609 --> 00:51:50,890
because if you want to get visibility

00:51:48,790 --> 00:51:53,770
into the data plane of the Opera racks

00:51:50,890 --> 00:51:55,450
which they're all kind of close you

00:51:53,770 --> 00:51:57,190
don't know how things are done so this

00:51:55,450 --> 00:51:58,410
one gives you full visibility into the

00:51:57,190 --> 00:52:01,030
pipeline

00:51:58,410 --> 00:52:03,430
that's what not the least it's not an

00:52:01,030 --> 00:52:06,849
FPGA it's not an NP you is not a CPU

00:52:03,430 --> 00:52:10,119
it's an Ethernet ASIC it runs at six

00:52:06,849 --> 00:52:11,770
point five terabytes per second just to

00:52:10,119 --> 00:52:13,930
give you some pictures this is how it

00:52:11,770 --> 00:52:17,320
looks I couldn't carry it here it's

00:52:13,930 --> 00:52:20,829
quite heavy and I don't think it'll get

00:52:17,320 --> 00:52:24,609
through customs this is another picture

00:52:20,829 --> 00:52:29,349
with the top off even the LEDs are

00:52:24,609 --> 00:52:31,960
programmable just kidding okay so this

00:52:29,349 --> 00:52:34,569
is this is just to give the context now

00:52:31,960 --> 00:52:37,950
a little bit more details on how we

00:52:34,569 --> 00:52:40,660
accomplish this so we start with our

00:52:37,950 --> 00:52:43,720
switch dot before program which has all

00:52:40,660 --> 00:52:46,210
the features that you need in a top iraq

00:52:43,720 --> 00:52:49,990
switch and then we modified it to add

00:52:46,210 --> 00:52:51,700
the ILA functionality to it so then we

00:52:49,990 --> 00:52:55,869
take that program run it through a p4

00:52:51,700 --> 00:52:58,240
compiler it generates the machine code

00:52:55,869 --> 00:53:01,089
for barefoot Tofino so we download that

00:52:58,240 --> 00:53:03,430
onto the switch then it also generates

00:53:01,089 --> 00:53:07,150
api so these are auto generated using

00:53:03,430 --> 00:53:09,190
the compiler and those api's are you

00:53:07,150 --> 00:53:10,720
know mated with a control plane right

00:53:09,190 --> 00:53:14,260
now we're using a simple Python script

00:53:10,720 --> 00:53:15,790
as a control plane and then there is a

00:53:14,260 --> 00:53:18,190
control plane interaction happening

00:53:15,790 --> 00:53:21,990
where you can you know program the table

00:53:18,190 --> 00:53:21,990
insert entries and all that stuff

00:53:23,290 --> 00:53:28,150
so this back to the demo setup right so

00:53:26,530 --> 00:53:30,160
this is what's happening so these are

00:53:28,150 --> 00:53:33,550
just the details on what addresses we

00:53:30,160 --> 00:53:35,620
are using the store address with I'll a

00:53:33,550 --> 00:53:38,980
prefix of four four four four slash

00:53:35,620 --> 00:53:44,050
sixty-four is used so the end hosts are

00:53:38,980 --> 00:53:48,490
just using their addresses the 0 1 and 0

00:53:44,050 --> 00:53:50,800
two addresses and all the translation

00:53:48,490 --> 00:53:55,810
into ila happens on the switch and you

00:53:50,800 --> 00:54:01,330
can see at the top the let's see where

00:53:55,810 --> 00:54:05,050
the laser is ok so this is the

00:54:01,330 --> 00:54:07,180
translated aisle address this is the sir

00:54:05,050 --> 00:54:10,390
address so the both both phones have the

00:54:07,180 --> 00:54:12,670
sir addresses on them so to FINA is

00:54:10,390 --> 00:54:15,340
basically looking this address up in its

00:54:12,670 --> 00:54:19,330
tables and then rewriting the address to

00:54:15,340 --> 00:54:21,190
the aisle address one thing to note is

00:54:19,330 --> 00:54:23,290
it's also doing this checksum neutral

00:54:21,190 --> 00:54:25,360
translation so it's actually going to

00:54:23,290 --> 00:54:28,810
set the cheques in neutral bit and then

00:54:25,360 --> 00:54:32,500
are just the last few bytes to make sure

00:54:28,810 --> 00:54:34,210
that the checksum doesn't get invalid so

00:54:32,500 --> 00:54:36,250
the packet goes from here to this guy

00:54:34,210 --> 00:54:38,680
and this guy just translates it back to

00:54:36,250 --> 00:54:40,600
this address and sensor to the host the

00:54:38,680 --> 00:54:42,400
host don't know this is happening but

00:54:40,600 --> 00:54:45,970
you know the switch is doing both the

00:54:42,400 --> 00:54:49,680
translations so with that I'm going to

00:54:45,970 --> 00:54:49,680
attempt to run the demo

00:54:56,200 --> 00:55:06,549
so what we have here is a vagrant boss

00:55:00,150 --> 00:55:09,220
let me just do this and we use a tool

00:55:06,549 --> 00:55:14,040
called mini net to set up these switches

00:55:09,220 --> 00:55:14,040
and the hosts and set up the network

00:55:18,460 --> 00:55:22,270
it's setting up the host country in

00:55:21,309 --> 00:55:24,369
their addresses

00:55:22,270 --> 00:55:28,530
setting up the switches installing

00:55:24,369 --> 00:55:28,530
entries and

00:55:33,760 --> 00:55:39,070
okay it's setup so now I have the

00:55:36,940 --> 00:55:40,990
mignonette CLI and from here I'm

00:55:39,070 --> 00:55:44,410
actually going to ping the two hosts and

00:55:40,990 --> 00:55:46,510
then I'm going to login to the docker

00:55:44,410 --> 00:55:49,570
containers that are simulating the

00:55:46,510 --> 00:55:54,180
switch and do a TCP dump and show you

00:55:49,570 --> 00:56:01,290
the translator address right so let's go

00:55:54,180 --> 00:56:01,290
so this is switch one

00:56:07,789 --> 00:56:14,499
so this is my switch 1 and this is

00:56:15,519 --> 00:56:31,309
switch to ok so let me just run the TCP

00:56:23,509 --> 00:56:33,380
dump over here as you can see in the you

00:56:31,309 --> 00:56:37,329
know up so you can already see the

00:56:33,380 --> 00:56:37,329
translation but let me run it life

00:56:43,200 --> 00:56:52,859
okay dissipate dump is running so h1 as

00:56:51,059 --> 00:56:55,680
you can see this is host 1

00:56:52,859 --> 00:56:59,910
can you guess the it or did I have to

00:56:55,680 --> 00:57:07,319
increase the fun okay so this is host 1

00:56:59,910 --> 00:57:09,930
and H 2 is config this is host to and

00:57:07,319 --> 00:57:13,130
I'm just gonna pain from host 1 to host

00:57:09,930 --> 00:57:13,130
you and let's see what happens

00:57:18,870 --> 00:57:26,400
okay suppose I may just increase this so

00:57:24,150 --> 00:57:28,710
as you can see this is switch 1 and

00:57:26,400 --> 00:57:33,780
switch two so the address is getting

00:57:28,710 --> 00:57:35,160
translated you know from so you should

00:57:33,780 --> 00:57:37,500
actually look at this translation

00:57:35,160 --> 00:57:41,070
because that's the direction towards

00:57:37,500 --> 00:57:44,130
hosts - it got translated into the aisle

00:57:41,070 --> 00:57:46,290
address checksum neutral better set and

00:57:44,130 --> 00:57:49,580
then the checks of neutral correction is

00:57:46,290 --> 00:57:55,830
done and then the same thing over here

00:57:49,580 --> 00:57:58,340
there is it so going to one changed so

00:57:55,830 --> 00:57:58,340
it's actually

00:58:03,309 --> 00:58:07,780
should probably pinging a little bit

00:58:05,450 --> 00:58:07,780
longer

00:58:15,320 --> 00:58:18,880
some reason

00:58:21,490 --> 00:58:26,550
anyway one one set I can show I think

00:58:23,830 --> 00:58:29,020
maybe I'm not showing the right

00:58:26,550 --> 00:58:31,089
interface on this side but you can see

00:58:29,020 --> 00:58:33,430
the translation happening on both both

00:58:31,089 --> 00:58:34,990
ways right you can see that here both

00:58:33,430 --> 00:58:38,339
addresses are getting translated from

00:58:34,990 --> 00:58:41,470
cell address Riley and Annihilator sir

00:58:38,339 --> 00:58:43,780
so that's the that's the extent of the

00:58:41,470 --> 00:58:48,040
demo if you want to see the code so this

00:58:43,780 --> 00:58:49,960
is what we have done to enable ila in or

00:58:48,040 --> 00:58:52,390
switch start before these are just I'll

00:58:49,960 --> 00:58:58,330
actions added to our regular ipv6

00:58:52,390 --> 00:59:00,869
processing if you open an ipv6 stop

00:58:58,330 --> 00:59:00,869
before

00:59:04,790 --> 00:59:09,140
so all we needed to do with the regular

00:59:07,130 --> 00:59:11,920
ipv6 processing that we're already doing

00:59:09,140 --> 00:59:14,690
is I had a couple more actions to do ila

00:59:11,920 --> 00:59:18,260
and then all the crest pointing api's

00:59:14,690 --> 00:59:20,900
and everything that is needed to

00:59:18,260 --> 00:59:24,950
configure this stuff in the hardware is

00:59:20,900 --> 00:59:27,920
auto-generated so that's the sextant of

00:59:24,950 --> 00:59:32,570
the denim and we can we can do all the

00:59:27,920 --> 00:59:39,430
xtp related use cases in our switch we

00:59:32,570 --> 00:59:39,430
just showcased ila for now any questions

00:59:42,930 --> 00:59:50,700
okay there's no questions before I leave

00:59:46,920 --> 00:59:51,270
we just want to give thanks to a few

00:59:50,700 --> 00:59:53,670
people

00:59:51,270 --> 00:59:57,029
first Malad sure if he's the engineer

00:59:53,670 --> 01:00:00,390
who worked on this it's not me he did

00:59:57,029 --> 01:00:02,520
all the work I'm just showing it and Tom

01:00:00,390 --> 01:00:05,039
Herbert thanks for reviewing what he did

01:00:02,520 --> 01:00:06,900
and also thanks to the organizers and

01:00:05,039 --> 01:00:09,960
Tom for giving us this opportunity to

01:00:06,900 --> 01:00:15,529
prison so if you have any questions feel

01:00:09,960 --> 01:00:17,640
free to shoot them at me or come grab me

01:00:15,529 --> 01:00:23,369
I'm wondering have you measured the

01:00:17,640 --> 01:00:26,400
performance of this pen so no not yet so

01:00:23,369 --> 01:00:29,579
we can actually do it on our hardware we

01:00:26,400 --> 01:00:33,270
haven't done that yet this is just you

01:00:29,579 --> 01:00:36,089
know simulator switch right okay and

01:00:33,270 --> 01:00:39,000
then how do you see the relationship

01:00:36,089 --> 01:00:41,789
between P 4 and X GPS obviously this is

01:00:39,000 --> 01:00:44,579
not X DP but you've mentioned that

01:00:41,789 --> 01:00:47,549
handles all the XDP use cases do you

01:00:44,579 --> 01:00:49,619
foresee a translation from XD p2 p4 I

01:00:47,549 --> 01:00:52,470
would how would that work yeah that's

01:00:49,619 --> 01:00:56,339
that's a good topic actually I mean it

01:00:52,470 --> 01:00:58,529
goes along the lines of what gilad was

01:00:56,339 --> 01:01:01,380
saying earlier and also the natural

01:00:58,529 --> 01:01:03,750
numbers are dealing with right now it's

01:01:01,380 --> 01:01:05,430
like hey this is what xtp does ok let's

01:01:03,750 --> 01:01:09,180
do it in p4 so I know that's what's

01:01:05,430 --> 01:01:12,150
happening right translation I mean

01:01:09,180 --> 01:01:15,539
there's a p40 BPF compiler already

01:01:12,150 --> 01:01:19,410
available john has one you know there's

01:01:15,539 --> 01:01:23,059
one in Iowa sir it's not something we

01:01:19,410 --> 01:01:25,230
haven't we have fully grappled with yet

01:01:23,059 --> 01:01:28,710
having thought about this a bit it's

01:01:25,230 --> 01:01:33,210
it's quite easy however you say it's

01:01:28,710 --> 01:01:35,940
some conceivable to go from p40 BPF and

01:01:33,210 --> 01:01:38,339
yeah and index DP with the right set of

01:01:35,940 --> 01:01:40,020
helper functions and metadata we would

01:01:38,339 --> 01:01:42,720
need to add a few helper functions and a

01:01:40,020 --> 01:01:45,359
few things didn't make this work but for

01:01:42,720 --> 01:01:47,579
example we can do it and this the

01:01:45,359 --> 01:01:51,420
classifier ingress classifier today and

01:01:47,579 --> 01:01:52,150
without much trouble like going the

01:01:51,420 --> 01:01:54,069
other way

01:01:52,150 --> 01:01:56,740
quite the challenge right because you're

01:01:54,069 --> 01:01:58,660
taking a p4 model of a switch ASIC and

01:01:56,740 --> 01:02:02,130
trying to load an instruction set into

01:01:58,660 --> 01:02:05,799
that yeah and I'm not convinced that the

01:02:02,130 --> 01:02:07,029
that there's that that actually a can be

01:02:05,799 --> 01:02:10,029
done and B that there's a whole lot of

01:02:07,029 --> 01:02:11,140
value in going that way but I would

01:02:10,029 --> 01:02:13,510
definitely be interested to hear if

01:02:11,140 --> 01:02:14,260
anybody is really interested in trying

01:02:13,510 --> 01:02:16,359
to do that

01:02:14,260 --> 01:02:19,630
it's the same question is trying to jet

01:02:16,359 --> 01:02:21,940
on to build a jet for fixed Asics right

01:02:19,630 --> 01:02:24,789
from the EPF it's like the space of

01:02:21,940 --> 01:02:27,039
programs that would actually be that

01:02:24,789 --> 01:02:28,450
could actually do this with so small

01:02:27,039 --> 01:02:30,089
compared to the sort of universal

01:02:28,450 --> 01:02:34,180
programs that you can write in an

01:02:30,089 --> 01:02:37,029
instruction set language so as least as

01:02:34,180 --> 01:02:40,660
my thoughts on it so yeah yeah I agree I

01:02:37,029 --> 01:02:42,339
think yeah this is something we've been

01:02:40,660 --> 01:02:44,380
trying to look at but when we tried to

01:02:42,339 --> 01:02:50,349
see how we can take EBP F and then

01:02:44,380 --> 01:02:52,650
translate it back to before yeah wasn't

01:02:50,349 --> 01:02:52,650
clear

01:02:53,180 --> 01:02:56,180
this

01:03:00,140 --> 01:03:07,829
if EPP if doesn't make sense to use it

01:03:03,029 --> 01:03:09,569
just because it exists if you can

01:03:07,829 --> 01:03:11,359
yeah you can transfer it one way if he

01:03:09,569 --> 01:03:14,789
it's not easy to go the other way

01:03:11,359 --> 01:03:15,809
you know yes you have the bread slicer

01:03:14,789 --> 01:03:26,059
you don't have to use it to slice

01:03:15,809 --> 01:03:28,319
oranges so I mean yeah of course

01:03:26,059 --> 01:03:30,509
one thing that's interesting to me here

01:03:28,319 --> 01:03:33,180
is you've got this general-purpose

01:03:30,509 --> 01:03:35,099
language which has very small and struct

01:03:33,180 --> 01:03:37,079
like EB PF has very simple instructions

01:03:35,099 --> 01:03:39,329
right and you can only do whatever and

01:03:37,079 --> 01:03:41,519
many of them per clock and you know the

01:03:39,329 --> 01:03:42,690
the power is limited and then you have

01:03:41,519 --> 01:03:44,279
these things which have extremely

01:03:42,690 --> 01:03:46,319
complicated you've got like these

01:03:44,279 --> 01:03:50,549
trailer matches on very very wide teak

01:03:46,319 --> 01:03:54,660
MN trees and they're super fast and you

01:03:50,549 --> 01:03:56,759
can't do anything else with them so if

01:03:54,660 --> 01:04:00,119
we think about like what what sort of

01:03:56,759 --> 01:04:02,369
hybrid could we build that would give

01:04:00,119 --> 01:04:04,499
you both of these and like could you

01:04:02,369 --> 01:04:07,079
build this stuff into EBP ephes could

01:04:04,499 --> 01:04:08,609
you have you obviously can't do it using

01:04:07,079 --> 01:04:10,559
a p PF instructions of any reasonable

01:04:08,609 --> 01:04:12,900
speed it's way too slow right but I've

01:04:10,559 --> 01:04:14,459
had calls just like if a PP I've has a

01:04:12,900 --> 01:04:16,140
way to call the hardware functionality

01:04:14,459 --> 01:04:18,329
you could kind of write the main problem

01:04:16,140 --> 01:04:20,279
EBP F and then use these sophisticated

01:04:18,329 --> 01:04:22,949
matches I don't know if that makes sense

01:04:20,279 --> 01:04:26,940
but yeah I think the abstract model on

01:04:22,949 --> 01:04:28,739
which a BPF operates on and the abstract

01:04:26,940 --> 01:04:32,160
model on which peaceful operates on are

01:04:28,739 --> 01:04:34,049
different like I think you brought up a

01:04:32,160 --> 01:04:36,569
good example right I mean tea camps

01:04:34,049 --> 01:04:40,410
these are switch has T cans in it and

01:04:36,569 --> 01:04:42,209
it's very fast so how do you translate

01:04:40,410 --> 01:04:43,739
like let's say you describe a tea

01:04:42,209 --> 01:04:48,269
comment before how do you transfer that

01:04:43,739 --> 01:04:50,640
in T BPF it breaks you know so yeah can

01:04:48,269 --> 01:04:52,709
you take the cord and put it in into our

01:04:50,640 --> 01:04:55,680
hardware yes but you will not be using

01:04:52,709 --> 01:04:58,440
the full full power of it right so this

01:04:55,680 --> 01:05:00,709
is oh yeah we're still trying to figure

01:04:58,440 --> 01:05:00,709
it out

01:05:05,620 --> 01:05:09,150

YouTube URL: https://www.youtube.com/watch?v=lpJk_HcCLnQ


