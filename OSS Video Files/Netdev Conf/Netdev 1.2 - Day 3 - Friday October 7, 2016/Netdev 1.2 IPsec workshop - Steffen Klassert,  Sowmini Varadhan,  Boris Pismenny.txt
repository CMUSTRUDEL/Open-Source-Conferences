Title: Netdev 1.2 IPsec workshop - Steffen Klassert,  Sowmini Varadhan,  Boris Pismenny
Publication date: 2016-10-08
Playlist: Netdev 1.2 - Day 3 - Friday October 7, 2016
Description: 
	https://netdevconf.org/1.2/session.html?steffen-klassert
Captions: 
	00:00:09,760 --> 00:00:17,510
okay so welcome to your tech workshop

00:00:15,189 --> 00:00:20,300
justice Oh program for today

00:00:17,510 --> 00:00:22,160
so first I will give a shirt a cassette

00:00:20,300 --> 00:00:26,239
status update so what's happened since

00:00:22,160 --> 00:00:28,550
last time we met at not off and then it

00:00:26,239 --> 00:00:30,529
used to be like a sec configuration

00:00:28,550 --> 00:00:34,010
tutorial but unfortunately we have to

00:00:30,529 --> 00:00:38,270
skip this due to technical problems so

00:00:34,010 --> 00:00:40,700
we go ahead done and do the IPSec crypto

00:00:38,270 --> 00:00:43,489
offload for Network Devices talk and

00:00:40,700 --> 00:00:46,850
after that we have a presentation about

00:00:43,489 --> 00:00:49,129
the IPSec flow cash removal and after

00:00:46,850 --> 00:00:52,039
that Hannes jumped in and wants to

00:00:49,129 --> 00:00:55,339
present the to-do list on IPSec what can

00:00:52,039 --> 00:00:59,149
be done for the next time so let's start

00:00:55,339 --> 00:01:01,039
with status update so the last time I'm

00:00:59,149 --> 00:01:04,430
not tough we had discussion on how to

00:01:01,039 --> 00:01:07,940
avoid the copy on rice and IPSec data

00:01:04,430 --> 00:01:10,150
path so the problem here is that most of

00:01:07,940 --> 00:01:12,380
the ESP data frames are linearized

00:01:10,150 --> 00:01:15,740
because we need rightful bottles for the

00:01:12,380 --> 00:01:19,910
crypto operations so when in between we

00:01:15,740 --> 00:01:21,770
solved that it is on the TX part we use

00:01:19,910 --> 00:01:24,830
separate source and destination buffers

00:01:21,770 --> 00:01:27,920
for the Cresta crypto so next or copy is

00:01:24,830 --> 00:01:29,840
not needed anymore there on the RX site

00:01:27,920 --> 00:01:31,850
we did it a little bit different so we

00:01:29,840 --> 00:01:34,970
linearize only if the buffer is really

00:01:31,850 --> 00:01:38,500
not right for so with these two changes

00:01:34,970 --> 00:01:41,260
we fix this and the networking layer but

00:01:38,500 --> 00:01:44,480
unfortunately a new problem appeared

00:01:41,260 --> 00:01:47,030
because some crypto algorithms just

00:01:44,480 --> 00:01:48,770
linearized if we do not pass a linear

00:01:47,030 --> 00:01:52,130
buffer which is kind of unfortunate

00:01:48,770 --> 00:01:56,050
tuned because in particular because GCM

00:01:52,130 --> 00:01:58,790
ans I know it does this but I learned

00:01:56,050 --> 00:02:01,490
this week that I'm not the only one with

00:01:58,790 --> 00:02:03,950
this problem the kth people have the

00:02:01,490 --> 00:02:05,840
problem - and also I learned that there

00:02:03,950 --> 00:02:08,090
is already a better implementation of

00:02:05,840 --> 00:02:10,879
that but it's just not with Linux kernel

00:02:08,090 --> 00:02:13,640
so in case we can get that in the Linux

00:02:10,879 --> 00:02:18,079
kernel we would get rid of the copy and

00:02:13,640 --> 00:02:21,360
write problem entirely so so far on copy

00:02:18,079 --> 00:02:23,340
and write next thing

00:02:21,360 --> 00:02:25,920
the thing that I call the practice point

00:02:23,340 --> 00:02:28,860
of splitting for diesel buffers this

00:02:25,920 --> 00:02:32,760
feature was already on the slide of

00:02:28,860 --> 00:02:35,670
Alexander died talk yesterday so I'm

00:02:32,760 --> 00:02:38,040
rushing a bit over this so what

00:02:35,670 --> 00:02:40,350
generally the thing is zero can build

00:02:38,040 --> 00:02:42,210
buffers will frac list and a problem

00:02:40,350 --> 00:02:45,000
just leads to general forwarding problem

00:02:42,210 --> 00:02:47,370
because we can't offload such process to

00:02:45,000 --> 00:02:50,640
hardware they have to be linearized

00:02:47,370 --> 00:02:53,730
fully in the stack and this problem was

00:02:50,640 --> 00:02:56,060
soft recently we just split these

00:02:53,730 --> 00:03:00,000
buffers I deflect fretless pointer into

00:02:56,060 --> 00:03:02,459
tears Oh affordable buffers and yes a

00:03:00,000 --> 00:03:05,100
set fixed recently and it's main line

00:03:02,459 --> 00:03:09,900
with an external version so we are done

00:03:05,100 --> 00:03:12,630
here next thing we have last time as we

00:03:09,900 --> 00:03:15,750
wanted to add a zero code path for IPSec

00:03:12,630 --> 00:03:18,150
so all we have to do here is just we

00:03:15,750 --> 00:03:21,120
have to add to zero handles for eitc

00:03:18,150 --> 00:03:23,670
protocols but so we had a small problem

00:03:21,120 --> 00:03:25,980
to the gets discussed last time because

00:03:23,670 --> 00:03:28,320
if we do that we don't see the IPSec

00:03:25,980 --> 00:03:30,560
packets in the stack anymore and we're

00:03:28,320 --> 00:03:33,989
not sure if everybody is happy with that

00:03:30,560 --> 00:03:37,739
so the question appeared if this should

00:03:33,989 --> 00:03:41,400
be configurable somehow aside from just

00:03:37,739 --> 00:03:44,489
disabling GL completely and so by now

00:03:41,400 --> 00:03:46,769
we've solved that by doing a kassak

00:03:44,489 --> 00:03:48,989
offloading of the config option so the

00:03:46,769 --> 00:03:51,630
user can choose if you want you have to

00:03:48,989 --> 00:03:54,450
start Isikoff Loden and if you choose to

00:03:51,630 --> 00:03:57,090
do so so he's probably aware that you

00:03:54,450 --> 00:03:59,269
won't see these packets anymore so I

00:03:57,090 --> 00:04:03,120
think we are good here too

00:03:59,269 --> 00:04:06,150
next thing we had last time is going to

00:04:03,120 --> 00:04:10,620
the JIT path we wanted to do something

00:04:06,150 --> 00:04:15,360
for geo so qu and what we wanted to do

00:04:10,620 --> 00:04:17,700
here is we wanted to move the this.o

00:04:15,360 --> 00:04:20,250
handling from the transfer forms layer

00:04:17,700 --> 00:04:22,160
more to the network cut to the generic

00:04:20,250 --> 00:04:25,020
Jizo layer at layer two

00:04:22,160 --> 00:04:29,190
unfortunately we face some bigger

00:04:25,020 --> 00:04:31,169
problems there so just scan works kind

00:04:29,190 --> 00:04:34,950
of good if we can offload the Crypt

00:04:31,169 --> 00:04:37,620
operations to a network card but on

00:04:34,950 --> 00:04:40,380
fortunately it does not work so well if

00:04:37,620 --> 00:04:42,750
we're doing sastra crypto and the reason

00:04:40,380 --> 00:04:44,760
for that is that in software crypto the

00:04:42,750 --> 00:04:47,460
Crypt operations can return as internals

00:04:44,760 --> 00:04:50,280
and we have really problems to handle

00:04:47,460 --> 00:04:53,040
this in the GSO layer we tried it and I

00:04:50,280 --> 00:04:56,160
faced all sort of problems so I have no

00:04:53,040 --> 00:04:59,360
idea how to do this currently so this is

00:04:56,160 --> 00:05:04,590
deferred until we have solution for that

00:04:59,360 --> 00:05:08,040
okay that's the status for the GSL going

00:05:04,590 --> 00:05:10,530
further what about scalability problem

00:05:08,040 --> 00:05:12,690
here is that we need for each packet

00:05:10,530 --> 00:05:15,120
several locks to do the state and the

00:05:12,690 --> 00:05:17,400
policy lookups and apparently it just

00:05:15,120 --> 00:05:20,940
doesn't scale well with multiple

00:05:17,400 --> 00:05:25,380
parallel flows this problem was solved

00:05:20,940 --> 00:05:27,450
recently we just converted the packet

00:05:25,380 --> 00:05:30,570
path to our see you this work was done

00:05:27,450 --> 00:05:34,310
by florian restful and this country main

00:05:30,570 --> 00:05:36,090
line with the next kernel version so

00:05:34,310 --> 00:05:39,510
what do we get from that

00:05:36,090 --> 00:05:43,200
let's see some performance numbers so I

00:05:39,510 --> 00:05:48,480
did tunnel mode forwarding tests I used

00:05:43,200 --> 00:05:49,650
GCM AES and I with ipv4 and TCP my setup

00:05:48,480 --> 00:05:53,670
was the following

00:05:49,650 --> 00:05:58,140
I used two IPSec gateways which with 72

00:05:53,670 --> 00:05:59,310
cars each and 16 10g with Nick's as a

00:05:58,140 --> 00:06:02,660
traffic generator

00:05:59,310 --> 00:06:07,200
I used a sperm test center and with this

00:06:02,660 --> 00:06:11,250
test setup I measured a baseline back in

00:06:07,200 --> 00:06:15,230
April with 3.8 G bit per second for a

00:06:11,250 --> 00:06:19,350
single flow so let's see where we get

00:06:15,230 --> 00:06:21,840
now currently with recent Mad Max and

00:06:19,350 --> 00:06:25,950
TRF see patches I've posted recently

00:06:21,840 --> 00:06:28,380
we've got for a single flow 5.7 G bit

00:06:25,950 --> 00:06:31,650
per second which is an improvement from

00:06:28,380 --> 00:06:34,530
almost 2 G bit which is quite nice I

00:06:31,650 --> 00:06:37,320
think and also I think we are not

00:06:34,530 --> 00:06:39,720
completely done here the back part is

00:06:37,320 --> 00:06:41,700
still not completely optimized I think

00:06:39,720 --> 00:06:46,140
with a little bit we're back we can get

00:06:41,700 --> 00:06:47,729
out more there so let's go ahead and see

00:06:46,140 --> 00:06:51,900
what happens for

00:06:47,729 --> 00:06:54,960
multiflo so again that's not nap next

00:06:51,900 --> 00:06:59,309
the RFC patches and receive size scaling

00:06:54,960 --> 00:07:01,259
with 16 B Direction souls I've got 155 G

00:06:59,309 --> 00:07:04,050
but per second for IPSec which is quite

00:07:01,259 --> 00:07:07,199
impressive I think I mean I want to

00:07:04,050 --> 00:07:10,139
mansion so to theoretical limit after

00:07:07,199 --> 00:07:11,249
setup is 160 G but per second so we are

00:07:10,139 --> 00:07:13,710
almost there

00:07:11,249 --> 00:07:16,080
I think the rest we lack here is

00:07:13,710 --> 00:07:18,150
particle overhead for right to sack so

00:07:16,080 --> 00:07:23,550
if you have more network cuts just can

00:07:18,150 --> 00:07:27,509
do better properly yes not everything

00:07:23,550 --> 00:07:33,149
maybe the off yeah I think I in you

00:07:27,509 --> 00:07:34,889
study to tell each of course I mean

00:07:33,149 --> 00:07:37,879
tough still if if you have more network

00:07:34,889 --> 00:07:43,979
cards you can do better or if you use

00:07:37,879 --> 00:07:51,029
its big packet size and to size yes

00:07:43,979 --> 00:07:54,810
right so after that last time we thought

00:07:51,029 --> 00:07:59,729
about what about getting I to second to

00:07:54,810 --> 00:08:02,370
hardware and from that we did a lot the

00:07:59,729 --> 00:08:07,800
last half-year so we implemented an

00:08:02,370 --> 00:08:10,080
IPSec hardware offloading API and Nara

00:08:07,800 --> 00:08:12,959
not a Linux 5 driver was converted to

00:08:10,080 --> 00:08:17,009
use that API and we've got finally all

00:08:12,959 --> 00:08:18,779
this works on marinids connected for so

00:08:17,009 --> 00:08:21,629
I don't want to go in detail here

00:08:18,779 --> 00:08:24,779
because Boris will tell more about that

00:08:21,629 --> 00:08:28,139
in a minute so this means we currently

00:08:24,779 --> 00:08:32,069
have one user for this offloading API

00:08:28,139 --> 00:08:35,010
but we are probably get one more because

00:08:32,069 --> 00:08:37,709
Intel's recently working she gets IPSec

00:08:35,010 --> 00:08:41,510
offload Frattini antics next to earth

00:08:37,709 --> 00:08:45,300
which chef supports in hardware 40 sec -

00:08:41,510 --> 00:08:51,589
so depths stays up there that's all i

00:08:45,300 --> 00:08:51,589
want to say next one is Boris

00:08:51,640 --> 00:09:01,540
oh yeah

00:08:58,640 --> 00:09:01,540
No

00:09:17,330 --> 00:09:24,750
okay Thank You Stefan we actually

00:09:21,120 --> 00:09:26,730
started this work at native 1.1 we saw

00:09:24,750 --> 00:09:29,160
the ipsec performance problems and we

00:09:26,730 --> 00:09:33,300
had this idea for crypto offload and

00:09:29,160 --> 00:09:35,640
this is how this work began so this

00:09:33,300 --> 00:09:39,270
presentation is about crypto offload for

00:09:35,640 --> 00:09:41,190
IPSec network devices so we'll start

00:09:39,270 --> 00:09:45,060
with some motivation in the model which

00:09:41,190 --> 00:09:47,040
is somewhat similar to TLS after that

00:09:45,060 --> 00:09:51,570
we'll discuss all the challenges that we

00:09:47,040 --> 00:09:54,990
have for IPSec and the unique parts of

00:09:51,570 --> 00:09:58,050
the stack that benefited and had also

00:09:54,990 --> 00:10:00,750
unique problems related to IPSec encrypt

00:09:58,050 --> 00:10:03,330
offload and then we'll discuss some

00:10:00,750 --> 00:10:05,120
performance results using descriptor of

00:10:03,330 --> 00:10:08,690
thought and the current status

00:10:05,120 --> 00:10:17,370
limitations of this approach future work

00:10:08,690 --> 00:10:21,450
and that's about it so from equation we

00:10:17,370 --> 00:10:23,370
have similarly - what - what we

00:10:21,450 --> 00:10:25,380
presented with TLS and there is an

00:10:23,370 --> 00:10:27,750
existing memory model for crypto flow

00:10:25,380 --> 00:10:31,140
today with the PCI when you go three

00:10:27,750 --> 00:10:35,270
times and it's not as good you also get

00:10:31,140 --> 00:10:38,400
extra latency from going over the PCI so

00:10:35,270 --> 00:10:43,140
this is not a very good model for packet

00:10:38,400 --> 00:10:46,890
processing and also it is not possible

00:10:43,140 --> 00:10:50,190
to do LS o or checksum of floats when

00:10:46,890 --> 00:10:52,650
you use anything other than a NIC that

00:10:50,190 --> 00:10:54,540
supports crypto so that's a big

00:10:52,650 --> 00:10:58,400
performance loss and we're going to show

00:10:54,540 --> 00:11:02,250
that during the presentation so the

00:10:58,400 --> 00:11:04,080
software model for this approach is one

00:11:02,250 --> 00:11:08,540
where the software is responsible for

00:11:04,080 --> 00:11:11,190
all packet processing this includes all

00:11:08,540 --> 00:11:15,030
framing of the packet there according to

00:11:11,190 --> 00:11:17,100
all protocols and the IPSec protocol

00:11:15,030 --> 00:11:20,550
entirely the replay protection the

00:11:17,100 --> 00:11:23,220
policies everything except encryption

00:11:20,550 --> 00:11:25,320
basically where the Nick is responsible

00:11:23,220 --> 00:11:28,860
for encrypting decrypting authenticated

00:11:25,320 --> 00:11:32,300
packets and go through the device

00:11:28,860 --> 00:11:35,940
while packets that fell authentication

00:11:32,300 --> 00:11:38,570
they remain unmodified so if software

00:11:35,940 --> 00:11:43,470
decides to do something else about those

00:11:38,570 --> 00:11:46,110
it is still possible generally all of

00:11:43,470 --> 00:11:49,019
this API follows main principle of

00:11:46,110 --> 00:11:51,300
software fallback where hardware might

00:11:49,019 --> 00:11:53,640
not encrypt or decrypt something and

00:11:51,300 --> 00:11:55,740
software handles it and software can

00:11:53,640 --> 00:11:58,290
decide when it wants to encrypt

00:11:55,740 --> 00:12:01,160
something by itself and when it wants to

00:11:58,290 --> 00:12:04,140
offload it to Hardware if it's possible

00:12:01,160 --> 00:12:05,700
and all operations that are performed by

00:12:04,140 --> 00:12:10,170
Hardware can also be performed by

00:12:05,700 --> 00:12:12,029
software that that also means that many

00:12:10,170 --> 00:12:15,510
times you need to have some kind of

00:12:12,029 --> 00:12:18,089
synchronization so software and hardware

00:12:15,510 --> 00:12:20,250
don't get out of sync that doesn't mean

00:12:18,089 --> 00:12:25,260
that we need to synchronize hardware and

00:12:20,250 --> 00:12:27,480
software it just done implicitly and so

00:12:25,260 --> 00:12:30,089
for those of you that aren't really

00:12:27,480 --> 00:12:35,579
familiar with IPSec this is how it looks

00:12:30,089 --> 00:12:38,579
like so we have an IP packet here on the

00:12:35,579 --> 00:12:42,720
dirac on the left side an IP TCP packet

00:12:38,579 --> 00:12:46,290
and once IPSec is applied we get an

00:12:42,720 --> 00:12:49,260
additional IP header that's called

00:12:46,290 --> 00:12:50,850
tunnel mode yes we tunnel mode and we

00:12:49,260 --> 00:12:53,120
get an additional ESP header that

00:12:50,850 --> 00:12:56,310
includes an SPI and a sequence number

00:12:53,120 --> 00:12:58,380
where the yellow part is the original

00:12:56,310 --> 00:13:01,440
packet and an IV which is used by the

00:12:58,380 --> 00:13:04,260
encryption and all the yellow part is

00:13:01,440 --> 00:13:06,570
encrypted and authenticated also notice

00:13:04,260 --> 00:13:08,970
that there's a trailer here it also

00:13:06,570 --> 00:13:11,430
belongs to the IPSec protocol which

00:13:08,970 --> 00:13:13,920
includes padding padding length and the

00:13:11,430 --> 00:13:16,560
protocol here inside which is IP for

00:13:13,920 --> 00:13:19,829
tunnel mode and the authentication data

00:13:16,560 --> 00:13:23,370
at the end and all this thing is

00:13:19,829 --> 00:13:25,949
authenticated so the yellow part is

00:13:23,370 --> 00:13:28,920
encrypted and all of the payload is

00:13:25,949 --> 00:13:32,579
authenticated so let's begin with our

00:13:28,920 --> 00:13:35,130
challenges so the first challenge is LS

00:13:32,579 --> 00:13:38,010
all so as I've mentioned earlier it is

00:13:35,130 --> 00:13:39,800
not possible to do so without crypto

00:13:38,010 --> 00:13:42,739
offload to the Nick

00:13:39,800 --> 00:13:44,540
and let's see why so there are few

00:13:42,739 --> 00:13:47,420
requirements to perform Allah Saudi

00:13:44,540 --> 00:13:49,540
forces checksum offload for any

00:13:47,420 --> 00:13:51,829
segmentation that this performed

00:13:49,540 --> 00:13:56,059
checksum has to be done for any segment

00:13:51,829 --> 00:13:59,689
that is created and as we saw in the

00:13:56,059 --> 00:14:02,209
previous slide all the TCP header part

00:13:59,689 --> 00:14:04,100
is encrypted so if it's already

00:14:02,209 --> 00:14:08,600
encrypted it is impossible by hardware

00:14:04,100 --> 00:14:10,999
to do the checksum also we need to

00:14:08,600 --> 00:14:12,860
generate the IPSec trailer because the

00:14:10,999 --> 00:14:17,029
software when it does just so it doesn't

00:14:12,860 --> 00:14:18,739
have any method of adding trailers to

00:14:17,029 --> 00:14:20,779
each and every one of the segments and

00:14:18,739 --> 00:14:23,720
the trailer has to be unique for every

00:14:20,779 --> 00:14:28,309
segment so it's not the same one for all

00:14:23,720 --> 00:14:31,160
of them and finally we need to use the

00:14:28,309 --> 00:14:33,920
correct IP for each packet since four

00:14:31,160 --> 00:14:36,199
protocols like a is GCM the high V has

00:14:33,920 --> 00:14:37,639
to be unique and we can't just copy the

00:14:36,199 --> 00:14:40,129
IV for each and every one of the

00:14:37,639 --> 00:14:42,290
segments and that would break the

00:14:40,129 --> 00:14:47,329
encryption so the IV needs to be

00:14:42,290 --> 00:14:49,970
incremented as well also the ESP

00:14:47,329 --> 00:14:54,259
sequence number has to be incremented so

00:14:49,970 --> 00:14:55,670
that's also unusual of course in the TCP

00:14:54,259 --> 00:14:59,059
sequence numbers need to be incremented

00:14:55,670 --> 00:15:01,339
as well so if you look at it

00:14:59,059 --> 00:15:03,920
schematically we say that we need to

00:15:01,339 --> 00:15:07,339
touch free places in the packet and all

00:15:03,920 --> 00:15:09,290
of them are encrypted the IV needs to be

00:15:07,339 --> 00:15:12,379
updated for it's just soft segment the

00:15:09,290 --> 00:15:15,049
TCP check sum needs to be updated and

00:15:12,379 --> 00:15:19,600
the trailer needs to be needs to be

00:15:15,049 --> 00:15:22,699
generated and populated by hardware so

00:15:19,600 --> 00:15:27,559
those are the challenges for LSO

00:15:22,699 --> 00:15:29,559
implementation the next challenging

00:15:27,559 --> 00:15:33,019
thing is checksum offload

00:15:29,559 --> 00:15:35,449
so without crypt offload it is

00:15:33,019 --> 00:15:37,309
impossible and with crypto of thought it

00:15:35,449 --> 00:15:40,579
becomes possible however there are a few

00:15:37,309 --> 00:15:44,410
problems so the problem we had here is

00:15:40,579 --> 00:15:48,399
that the IPSec packet has a trailer and

00:15:44,410 --> 00:15:51,620
currently both our hardware and the API

00:15:48,399 --> 00:15:55,550
defined at the checksum partial

00:15:51,620 --> 00:15:56,480
it works from a certain offset up to the

00:15:55,550 --> 00:15:59,480
end of the packet

00:15:56,480 --> 00:16:01,760
however in IPSec packets we have a

00:15:59,480 --> 00:16:05,720
trailer which should not be included in

00:16:01,760 --> 00:16:10,060
the TCP check sum and that that's a

00:16:05,720 --> 00:16:13,370
problem for our device and generally for

00:16:10,060 --> 00:16:15,260
passing packets to the device driver

00:16:13,370 --> 00:16:18,470
where you have a trailer and you expect

00:16:15,260 --> 00:16:21,440
checksum of code so we fought off two

00:16:18,470 --> 00:16:24,490
possible solutions for this problem the

00:16:21,440 --> 00:16:27,160
first one is that when IPSec packets are

00:16:24,490 --> 00:16:29,450
floated the encryption is offloaded

00:16:27,160 --> 00:16:31,940
we'll send those pockets without a

00:16:29,450 --> 00:16:34,040
trailer and it would be generated by

00:16:31,940 --> 00:16:36,740
hardware similarly to the way we do it

00:16:34,040 --> 00:16:39,200
with LSO where it is necessary and

00:16:36,740 --> 00:16:41,900
unavoidable or in a different solution

00:16:39,200 --> 00:16:44,320
where the driver will pass the solid

00:16:41,900 --> 00:16:48,350
IPSec packet and you remove the trailer

00:16:44,320 --> 00:16:53,180
and then let Hardware process it as it

00:16:48,350 --> 00:16:55,160
does so that's the transmit side for the

00:16:53,180 --> 00:16:57,589
receive side we need to offload checksum

00:16:55,160 --> 00:17:00,260
complete where you have a similar

00:16:57,589 --> 00:17:02,630
however simple problem where hardware

00:17:00,260 --> 00:17:05,449
performs the checksum for the entire

00:17:02,630 --> 00:17:08,089
packet starting from the IP however it

00:17:05,449 --> 00:17:11,660
includes the trailer and it needs to be

00:17:08,089 --> 00:17:15,350
removed so it's not as problematic as

00:17:11,660 --> 00:17:19,640
the transmit side but it is still

00:17:15,350 --> 00:17:22,370
unusual so here it is schematically we

00:17:19,640 --> 00:17:24,949
need to calculate the checksum before

00:17:22,370 --> 00:17:26,870
the encryption or after decryption but

00:17:24,949 --> 00:17:29,660
you don't want to include that part in

00:17:26,870 --> 00:17:35,300
the end where we have the trailer which

00:17:29,660 --> 00:17:37,820
is unrelated to TCP and the last

00:17:35,300 --> 00:17:41,270
challenge we had is the IV processing

00:17:37,820 --> 00:17:43,550
why the generation so for L so we need

00:17:41,270 --> 00:17:47,540
Hardware to generate the IV for each

00:17:43,550 --> 00:17:49,520
packet for the IV to be unique and this

00:17:47,540 --> 00:17:50,080
is what has to be done according to the

00:17:49,520 --> 00:17:53,300
RFC

00:17:50,080 --> 00:17:55,429
however the RFC doesn't define how it

00:17:53,300 --> 00:17:58,910
should be done or how uniqueness should

00:17:55,429 --> 00:18:02,570
be ensured and in Linux we have a

00:17:58,910 --> 00:18:05,029
special mechanism called SEC IV that

00:18:02,570 --> 00:18:09,700
it takes a sequence number expose it

00:18:05,029 --> 00:18:12,830
with the salt and then uses it as an IV

00:18:09,700 --> 00:18:15,620
this is something that is really little

00:18:12,830 --> 00:18:18,740
specific and it's not generic in any way

00:18:15,620 --> 00:18:21,470
and since we needed to create the IV in

00:18:18,740 --> 00:18:24,080
hardware and software might generate

00:18:21,470 --> 00:18:27,980
packets that are not encrypted by the

00:18:24,080 --> 00:18:30,919
hardware so we have to make sure that

00:18:27,980 --> 00:18:33,380
IVs don't repeat when they are generated

00:18:30,919 --> 00:18:34,090
by software and when they're generated

00:18:33,380 --> 00:18:37,669
by hardware

00:18:34,090 --> 00:18:41,539
so the way we implemented this is by

00:18:37,669 --> 00:18:45,440
implementing SEC IV in hardware we

00:18:41,539 --> 00:18:47,330
basically we pass the salt to the device

00:18:45,440 --> 00:18:52,220
and the device performs this XOR

00:18:47,330 --> 00:18:56,779
operation for all IPSec packets that are

00:18:52,220 --> 00:18:59,000
floated so this is how we got through

00:18:56,779 --> 00:19:04,399
this however I'm not sure if the Intel

00:18:59,000 --> 00:19:06,590
device supports such a faint or not so

00:19:04,399 --> 00:19:10,120
this is how it looks schematically we

00:19:06,590 --> 00:19:19,009
have two so this IV here using the salt

00:19:10,120 --> 00:19:23,090
generated by sec IV and okay so we did

00:19:19,009 --> 00:19:25,700
some performance tests for this of all

00:19:23,090 --> 00:19:29,029
in the performance tests we have and I

00:19:25,700 --> 00:19:32,210
see a packet generator here below and we

00:19:29,029 --> 00:19:34,429
send packets to one machine where we

00:19:32,210 --> 00:19:37,250
perform IPSec so the packets or TCP

00:19:34,429 --> 00:19:40,220
packets they are being encrypted by a

00:19:37,250 --> 00:19:42,769
crypto floating device decrypted by

00:19:40,220 --> 00:19:46,850
another crypto holding device and then

00:19:42,769 --> 00:19:49,129
routed back to the IPCA machine so all

00:19:46,850 --> 00:19:52,129
the links here are 40 gigantic 40

00:19:49,129 --> 00:19:57,500
gigabit NICs connectives for mobile

00:19:52,129 --> 00:20:00,230
product and we send 40 gigabit over on

00:19:57,500 --> 00:20:03,620
the currents midline and then packets

00:20:00,230 --> 00:20:06,259
get dropped because the CPU can handle

00:20:03,620 --> 00:20:10,789
much more so let's see the performance

00:20:06,259 --> 00:20:12,780
results so on the left side we see which

00:20:10,789 --> 00:20:14,909
direction are we looking at and

00:20:12,780 --> 00:20:18,240
then the there are two metrics

00:20:14,909 --> 00:20:22,320
throughput in CPU and so for a single

00:20:18,240 --> 00:20:26,039
stream we get 4.5 Giga bits from North

00:20:22,320 --> 00:20:29,700
flawed and 25.5 for the transmit side

00:20:26,039 --> 00:20:35,159
for flow so that's like five times more

00:20:29,700 --> 00:20:37,890
and and for the CPU is obviously only

00:20:35,159 --> 00:20:41,159
100 percent for this case for the

00:20:37,890 --> 00:20:44,610
receive side and we get for no float

00:20:41,159 --> 00:20:48,150
also 4.5 have a widow float we get a

00:20:44,610 --> 00:20:51,900
little bit less we get 18.2 gigabits per

00:20:48,150 --> 00:20:54,330
second so that's a little bit less so at

00:20:51,900 --> 00:20:56,429
the end we get only 18 Giga bits even

00:20:54,330 --> 00:21:03,299
though the transmit side could do even

00:20:56,429 --> 00:21:05,760
more so the current status of this

00:21:03,299 --> 00:21:08,700
product and our efforts for the hardware

00:21:05,760 --> 00:21:12,510
driver that we support ESP version 4

00:21:08,700 --> 00:21:14,730
tunnel mod with areas GCM we supported

00:21:12,510 --> 00:21:17,580
us all checksum offload and this IV

00:21:14,730 --> 00:21:19,460
processing we have some statistics that

00:21:17,580 --> 00:21:23,700
show what was encrypted by Hardware

00:21:19,460 --> 00:21:25,710
using if tool and we exported the

00:21:23,700 --> 00:21:28,950
capabilities that I provided by the

00:21:25,710 --> 00:21:31,110
IPSec stack in the IPSec target of

00:21:28,950 --> 00:21:34,110
support for this API for us before and 6

00:21:31,110 --> 00:21:36,750
their support for gso and the checksum

00:21:34,110 --> 00:21:39,030
offload support and in userspace we

00:21:36,750 --> 00:21:42,539
implemented patches for IP route 2 and

00:21:39,030 --> 00:21:44,909
for strongswan basically a user can

00:21:42,539 --> 00:21:49,260
define which security Association is

00:21:44,909 --> 00:21:51,919
going to be offloaded and which isn't so

00:21:49,260 --> 00:21:56,580
he has control at fine general

00:21:51,919 --> 00:22:00,630
granularity from the limitation side we

00:21:56,580 --> 00:22:03,600
cannot support any IP fragments so those

00:22:00,630 --> 00:22:06,330
are processed in software and the stack

00:22:03,600 --> 00:22:10,380
ensures that the crypto folding device

00:22:06,330 --> 00:22:13,440
doesn't get any of those packets so we

00:22:10,380 --> 00:22:15,510
don't have a problem there another

00:22:13,440 --> 00:22:17,780
limitation is that although the packets

00:22:15,510 --> 00:22:20,370
must be routed of the awful dynne device

00:22:17,780 --> 00:22:22,420
because we don't want to send plaintext

00:22:20,370 --> 00:22:25,780
through another device

00:22:22,420 --> 00:22:28,360
and that's an issue for discussion how

00:22:25,780 --> 00:22:31,930
do we overcome this problem can we do

00:22:28,360 --> 00:22:36,930
some software phobic there or do we have

00:22:31,930 --> 00:22:39,340
any other solution for this problem for

00:22:36,930 --> 00:22:42,420
the future the next thing that we are

00:22:39,340 --> 00:22:46,870
going to do is implement transport mode

00:22:42,420 --> 00:22:52,420
in the upcoming couple of months then we

00:22:46,870 --> 00:22:54,340
get to ipv6 ASC BC with sha Wan extended

00:22:52,420 --> 00:22:55,810
sequence numbers and there is an

00:22:54,340 --> 00:22:58,060
interesting issue because hardware needs

00:22:55,810 --> 00:23:00,760
to maintain this state for extended

00:22:58,060 --> 00:23:04,360
sequence numbers so it becomes less

00:23:00,760 --> 00:23:08,170
stateful it needs to be maintained

00:23:04,360 --> 00:23:09,910
somehow and following that we could do

00:23:08,170 --> 00:23:11,890
some encapsulation support currently we

00:23:09,910 --> 00:23:15,040
support only tunnel mode if you want to

00:23:11,890 --> 00:23:19,690
do an American capsulation we should

00:23:15,040 --> 00:23:21,820
think how to introduce such support the

00:23:19,690 --> 00:23:25,840
next point is offloading replay

00:23:21,820 --> 00:23:27,580
protection and we actually need to

00:23:25,840 --> 00:23:30,190
offload replay protection mainly because

00:23:27,580 --> 00:23:33,070
we want to do our cess using the in your

00:23:30,190 --> 00:23:37,090
headers Phi P SEC something which

00:23:33,070 --> 00:23:40,900
becomes possible with crypto offload we

00:23:37,090 --> 00:23:42,850
don't do it today mainly because if we

00:23:40,900 --> 00:23:47,920
would have done it then there would be a

00:23:42,850 --> 00:23:50,950
scalability issue since if the XFM state

00:23:47,920 --> 00:23:53,200
is being handled by two CPUs and the

00:23:50,950 --> 00:23:55,120
reply protection would cause the X from

00:23:53,200 --> 00:24:00,780
state to bounce between those CPUs and

00:23:55,120 --> 00:24:03,700
we wouldn't get much benefit from it so

00:24:00,780 --> 00:24:06,550
we do use the SPI but you want to use

00:24:03,700 --> 00:24:09,070
the inner headers in the IPSec packet

00:24:06,550 --> 00:24:16,390
you have the you know TCP ports and I

00:24:09,070 --> 00:24:18,400
people know not all the time the

00:24:16,390 --> 00:24:21,250
question was in assessing the spi is not

00:24:18,400 --> 00:24:23,080
strong enough and why well when you're

00:24:21,250 --> 00:24:24,970
using tunnel mode you can have a tunnel

00:24:23,080 --> 00:24:27,520
mode for example between two sites and

00:24:24,970 --> 00:24:30,160
many different users that are using this

00:24:27,520 --> 00:24:32,440
tunnel so what you get is that all those

00:24:30,160 --> 00:24:39,670
users have the same spi

00:24:32,440 --> 00:24:42,100
it doesn't scale really well we're

00:24:39,670 --> 00:24:44,170
actually facing this from our guys so

00:24:42,100 --> 00:24:46,180
they want to only have IPSec for

00:24:44,170 --> 00:24:48,520
specifically speed flow which is defined

00:24:46,180 --> 00:24:49,870
by the service port that means the other

00:24:48,520 --> 00:24:52,060
side is a transient force so you don't

00:24:49,870 --> 00:24:54,310
have too much control over the SPI it

00:24:52,060 --> 00:24:55,420
gets selected for you so this is

00:24:54,310 --> 00:24:56,980
something else going out stephane as

00:24:55,420 --> 00:24:58,060
well so when you're especially need a

00:24:56,980 --> 00:24:59,970
transport for you kind of lose that

00:24:58,060 --> 00:25:05,170
control and it gets a little bit hairy

00:24:59,970 --> 00:25:06,730
so it's not a trivial problem you would

00:25:05,170 --> 00:25:08,440
like to use the SPI but you cannot

00:25:06,730 --> 00:25:10,360
really pick the SPI because you end up

00:25:08,440 --> 00:25:15,310
having like if you try to define the

00:25:10,360 --> 00:25:19,060
whole SI DB and SPD you end up with for

00:25:15,310 --> 00:25:21,340
closer to delimit so I think you're good

00:25:19,060 --> 00:25:23,170
if you have fine-grained security

00:25:21,340 --> 00:25:25,090
associations if you have just one

00:25:23,170 --> 00:25:26,920
security Association that takes

00:25:25,090 --> 00:25:30,820
everything then you probably need to

00:25:26,920 --> 00:25:32,710
look inside because if you just have one

00:25:30,820 --> 00:25:44,620
security Association everything goes to

00:25:32,710 --> 00:25:46,990
your same CPU if we don't what's in the

00:25:44,620 --> 00:25:51,370
ipv6 header how do you call the flow ID

00:25:46,990 --> 00:25:57,130
yeah can we use that I'm not sure I'm

00:25:51,370 --> 00:25:58,720
not familiar with what is possible so

00:25:57,130 --> 00:26:00,790
the SPI is supposed to be the thing that

00:25:58,720 --> 00:26:02,260
covers both ipv4 and ipv6 right solving

00:26:00,790 --> 00:26:05,940
the ipv6 problem and not solving the

00:26:02,260 --> 00:26:05,940
ipv4 plan is not good enough so

00:26:10,020 --> 00:26:20,590
so we have not support ipv6 that's a

00:26:12,580 --> 00:26:22,510
different problem okay so let's continue

00:26:20,590 --> 00:26:24,660
we have some slides about the

00:26:22,510 --> 00:26:29,080
implementation details of this solution

00:26:24,660 --> 00:26:31,930
so we've added a new and do called xrm

00:26:29,080 --> 00:26:35,530
DevOps which is used to offload the SI

00:26:31,930 --> 00:26:38,080
entry to hardware basically there is an

00:26:35,530 --> 00:26:41,590
ADD operation which attempts to offload

00:26:38,080 --> 00:26:43,930
so mixer for M State it might fail if

00:26:41,590 --> 00:26:46,060
Hardware doesn't support some part of

00:26:43,930 --> 00:26:48,060
the XFM State for example the crypto

00:26:46,060 --> 00:26:50,770
algorithm isn't supported or the

00:26:48,060 --> 00:26:53,410
protocol isn't supported for example aah

00:26:50,770 --> 00:26:55,930
or maybe there's some encapsulation

00:26:53,410 --> 00:26:59,850
being involved or for any other reason

00:26:55,930 --> 00:27:04,750
if you offload it might fail and

00:26:59,850 --> 00:27:07,450
software needs to handle that then we we

00:27:04,750 --> 00:27:09,640
have the the release part when we delete

00:27:07,450 --> 00:27:11,950
the ascent we defeat we separated into

00:27:09,640 --> 00:27:14,740
two functions because we don't want to

00:27:11,950 --> 00:27:17,380
free device memory while we an atomic

00:27:14,740 --> 00:27:19,780
context so this is why it is separate

00:27:17,380 --> 00:27:23,260
the delete actually stops offload and

00:27:19,780 --> 00:27:26,380
free releases hardware memory and the

00:27:23,260 --> 00:27:28,750
final function it is used to check that

00:27:26,380 --> 00:27:33,400
the certain packet a certain sk b could

00:27:28,750 --> 00:27:36,100
be offloaded it is many useful for

00:27:33,400 --> 00:27:38,860
checking that the sk b will actually be

00:27:36,100 --> 00:27:42,330
offloaded before the decision is made

00:27:38,860 --> 00:27:45,370
and if this function returns true then

00:27:42,330 --> 00:27:49,270
the stock one could rely on hardware to

00:27:45,370 --> 00:27:51,870
offload this packet so that's for the

00:27:49,270 --> 00:27:55,660
and the O's for the receive flow

00:27:51,870 --> 00:27:57,790
hardware identifies offloaded IPSec

00:27:55,660 --> 00:28:02,110
packets according to the guest IP and

00:27:57,790 --> 00:28:04,270
the SPI I mentioned earlier once in a

00:28:02,110 --> 00:28:06,790
floated packet is identified it is being

00:28:04,270 --> 00:28:08,680
decrypted and authenticated by hardware

00:28:06,790 --> 00:28:11,110
and the completion contains the

00:28:08,680 --> 00:28:12,820
information of the result of the

00:28:11,110 --> 00:28:17,110
decryption operation and if it's

00:28:12,820 --> 00:28:20,210
exceeded the frail driver receives the

00:28:17,110 --> 00:28:24,350
result it populates the

00:28:20,210 --> 00:28:28,010
for the skb which usually is done in

00:28:24,350 --> 00:28:31,610
Excel for input since hardware already

00:28:28,010 --> 00:28:34,520
knows which XFM state was used it

00:28:31,610 --> 00:28:37,430
populates the sack path and as part of

00:28:34,520 --> 00:28:39,860
the sack path which we expanded we tell

00:28:37,430 --> 00:28:42,950
the stack what was the result of the

00:28:39,860 --> 00:28:47,210
offload operation if crypto was done and

00:28:42,950 --> 00:28:49,700
was it done successfully so once we get

00:28:47,210 --> 00:28:52,270
to access firm input we could skip

00:28:49,700 --> 00:28:55,550
decryption and authentication and

00:28:52,270 --> 00:28:57,950
extra-firm state lookup all already has

00:28:55,550 --> 00:29:00,530
been completed by hardware and Driver

00:28:57,950 --> 00:29:02,480
and we only need to process the headers

00:29:00,530 --> 00:29:05,540
and to perform checks on complete and

00:29:02,480 --> 00:29:09,620
everyone is happy you should note that

00:29:05,540 --> 00:29:12,950
if you look at TCP dump you see ESP

00:29:09,620 --> 00:29:15,530
packets with plain text so that might be

00:29:12,950 --> 00:29:19,880
unusual and maybe even useful some of

00:29:15,530 --> 00:29:22,460
you for the transmit flow on XFM output

00:29:19,880 --> 00:29:25,640
we perform a check to see if X affirmed

00:29:22,460 --> 00:29:28,910
offload is ok so we check the skb could

00:29:25,640 --> 00:29:31,370
be offloaded and if the answer is yes

00:29:28,910 --> 00:29:35,360
then we could rely on the device to

00:29:31,370 --> 00:29:37,550
offload we also populate the sack path

00:29:35,360 --> 00:29:40,280
from transmit which is somewhat unusual

00:29:37,550 --> 00:29:42,950
because previously it was used only on

00:29:40,280 --> 00:29:45,380
the receive side and we used that to

00:29:42,950 --> 00:29:49,340
indicate for Hardware that this packet

00:29:45,380 --> 00:29:52,970
is going to be offloaded and also we set

00:29:49,340 --> 00:29:55,730
the encapsulation field of the skb since

00:29:52,970 --> 00:29:57,950
if you don't encrypt then the packet is

00:29:55,730 --> 00:30:01,040
actually a tunnel packet and it's

00:29:57,950 --> 00:30:06,890
encapsulated it has an inner IP and TCP

00:30:01,040 --> 00:30:11,900
header that could be used in x-ray mode

00:30:06,890 --> 00:30:14,390
which one when we get gso packet we only

00:30:11,900 --> 00:30:17,270
need to add the ESP header we don't

00:30:14,390 --> 00:30:20,900
actually need to add any trailer and as

00:30:17,270 --> 00:30:23,630
discussed earlier with LSO we generated

00:30:20,900 --> 00:30:25,760
the trailer anyway in hardware

00:30:23,630 --> 00:30:27,320
there is also an additional replay

00:30:25,760 --> 00:30:29,480
protection mechanism that handles

00:30:27,320 --> 00:30:31,460
geocell pockets since you need to count

00:30:29,480 --> 00:30:34,429
each and every one of

00:30:31,460 --> 00:30:41,059
the segments that are going to leave the

00:30:34,429 --> 00:30:44,169
device so at the network device we look

00:30:41,059 --> 00:30:49,520
at the sack buff of the skb and see if

00:30:44,169 --> 00:30:51,350
offload is expected if yes then we

00:30:49,520 --> 00:30:54,710
perform the offload we set all the

00:30:51,350 --> 00:30:57,649
fields and if needed we perform also and

00:30:54,710 --> 00:31:03,020
checksum offload by leveraging the inner

00:30:57,649 --> 00:31:06,860
header pointers finally if we choose in

00:31:03,020 --> 00:31:08,149
the API to use the trailer in all

00:31:06,860 --> 00:31:12,080
packets who need to remove the trailer

00:31:08,149 --> 00:31:15,970
if it's required so that's it any

00:31:12,080 --> 00:31:15,970
questions Mike

00:31:21,700 --> 00:31:26,080
so a couple of things

00:31:23,679 --> 00:31:32,529
vennett about ipv6 keen on the future

00:31:26,080 --> 00:31:33,879
list has been registered so this might

00:31:32,529 --> 00:31:36,389
be more of a general question but I

00:31:33,879 --> 00:31:40,059
think it will relate to my next comment

00:31:36,389 --> 00:31:45,219
how close are we to DTLS being a drop-in

00:31:40,059 --> 00:31:46,989
replacement for IPSec with regards to

00:31:45,219 --> 00:31:49,330
accelerating and so yesterday we had to

00:31:46,989 --> 00:31:51,999
talk about TLS acceleration this is

00:31:49,330 --> 00:31:54,580
IPSec DTLS looks to me like it's more

00:31:51,999 --> 00:31:57,700
like IPSec how far do you think we are

00:31:54,580 --> 00:32:06,639
from doing the same thing we just did in

00:31:57,700 --> 00:32:08,019
DTLS that's a very good question

00:32:06,639 --> 00:32:10,509
there are many protocols that are

00:32:08,019 --> 00:32:13,960
related to IPSec in a similar way where

00:32:10,509 --> 00:32:16,509
each packet is encrypted independently

00:32:13,960 --> 00:32:19,749
of others other examples are mark 6 a

00:32:16,509 --> 00:32:22,629
quick and DTLS as you've mentioned for

00:32:19,749 --> 00:32:24,940
all of those while it might seem very

00:32:22,629 --> 00:32:27,399
similar the API will probably be a

00:32:24,940 --> 00:32:30,580
little bit different for example you can

00:32:27,399 --> 00:32:33,700
look at all the unique quirks you have

00:32:30,580 --> 00:32:35,710
with IPSec where you need to do TSO

00:32:33,700 --> 00:32:40,269
which for example you don't need to do

00:32:35,710 --> 00:32:42,309
for DTLS for any reason so it doesn't

00:32:40,269 --> 00:32:46,979
exist over there this problem and the

00:32:42,309 --> 00:32:50,289
checksum offload also doesn't exist so

00:32:46,979 --> 00:32:52,269
I'm going to disagree with that and this

00:32:50,289 --> 00:32:56,139
is a good lead-in to my second comment

00:32:52,269 --> 00:32:58,139
so one of the other slides he had the

00:32:56,139 --> 00:33:03,039
idea that you want to support

00:32:58,139 --> 00:33:06,129
IPSec with VX land and genÃ¨ve I have no

00:33:03,039 --> 00:33:08,889
idea how you would do that the problem

00:33:06,129 --> 00:33:11,440
is these protocols are designed for an

00:33:08,889 --> 00:33:15,219
outer IP header and in an IP header and

00:33:11,440 --> 00:33:16,839
then transport payload so for instance

00:33:15,219 --> 00:33:18,279
if you wanted to be a tunnel version of

00:33:16,839 --> 00:33:18,800
IPSec you would actually end up having

00:33:18,279 --> 00:33:22,250
three

00:33:18,800 --> 00:33:24,890
IP headers in this packet once you

00:33:22,250 --> 00:33:28,610
support ipv6 that's 120 bytes of

00:33:24,890 --> 00:33:34,250
overhead and IP headers I don't see how

00:33:28,610 --> 00:33:36,230
that flies those protocols have really

00:33:34,250 --> 00:33:38,930
thought at all about how to do security

00:33:36,230 --> 00:33:42,980
if they did it right what they would do

00:33:38,930 --> 00:33:45,260
is put a be TLS inside of that be TLS is

00:33:42,980 --> 00:33:47,360
natural fit for UDP but then now you

00:33:45,260 --> 00:33:52,250
would have something that looks like say

00:33:47,360 --> 00:33:57,860
IP header UDP header VX LAN header and

00:33:52,250 --> 00:33:59,780
then D TLS and then embedded packet so

00:33:57,860 --> 00:34:02,270
the advantage of that is now reusing

00:33:59,780 --> 00:34:07,130
DTLS but in that case you would want the

00:34:02,270 --> 00:34:08,900
TSO the lro and things like that that is

00:34:07,130 --> 00:34:12,290
gonna be much better than IPSec which i

00:34:08,900 --> 00:34:13,820
think is is going to be a bearer to try

00:34:12,290 --> 00:34:15,710
to wedge into the encapsulation

00:34:13,820 --> 00:34:18,380
protocols they're much more I mean in

00:34:15,710 --> 00:34:19,070
vol 2 D TLS so Tom what problem are you

00:34:18,380 --> 00:34:22,250
trying to solve

00:34:19,070 --> 00:34:24,710
if the IPSec is between is entering from

00:34:22,250 --> 00:34:27,560
the inner the from the guest to another

00:34:24,710 --> 00:34:31,640
guest you have to do that anyway right

00:34:27,560 --> 00:34:33,650
so I don't want three headers anything

00:34:31,640 --> 00:34:43,880
about that if the guest wants to have IP

00:34:33,650 --> 00:34:46,070
second to end with another guest some

00:34:43,880 --> 00:34:50,210
other questions and we have two more

00:34:46,070 --> 00:34:54,140
presentations so please discuss it later

00:34:50,210 --> 00:34:55,820
so just a couple of words I haven't

00:34:54,140 --> 00:34:57,980
considered DTLS as an encapsulation

00:34:55,820 --> 00:34:59,390
protocol but just as another protocol as

00:34:57,980 --> 00:35:01,940
encapsulation it's really interesting

00:34:59,390 --> 00:35:03,890
and you do have all those are so

00:35:01,940 --> 00:35:07,040
problems that need to be handled and we

00:35:03,890 --> 00:35:08,810
should look into this you mentioned the

00:35:07,040 --> 00:35:10,580
issue of the trailers I think you have

00:35:08,810 --> 00:35:13,370
to put them in for two reasons the first

00:35:10,580 --> 00:35:14,450
reason is the length the skp has to be

00:35:13,370 --> 00:35:15,980
true to what you're going to put onto

00:35:14,450 --> 00:35:18,770
the wire all the way to the staff just

00:35:15,980 --> 00:35:21,800
in case something happens like an empty

00:35:18,770 --> 00:35:26,090
you change or MSS event or whatever also

00:35:21,800 --> 00:35:27,790
in the case of you mentioned if we threw

00:35:26,090 --> 00:35:30,250
out changes every end up sending

00:35:27,790 --> 00:35:32,859
krypter off ipsec offloaded package to a

00:35:30,250 --> 00:35:34,630
non IPSec offloading device the fix-up

00:35:32,859 --> 00:35:37,510
code needs to have the trailer there if

00:35:34,630 --> 00:35:38,920
we decide to fix up the packet it which

00:35:37,510 --> 00:35:41,050
is a policy decision we could decide to

00:35:38,920 --> 00:35:43,210
drop such packets to write well I'm

00:35:41,050 --> 00:35:44,830
saying if we do decide to fixed it up we

00:35:43,210 --> 00:35:46,000
need all that information in there the

00:35:44,830 --> 00:35:48,850
packet to do what the hardware would

00:35:46,000 --> 00:35:50,350
have done okay I think the most

00:35:48,850 --> 00:35:51,880
important aspect is that the length has

00:35:50,350 --> 00:35:54,880
to be exactly what's gonna end up on the

00:35:51,880 --> 00:35:56,859
wire after you set off load I think

00:35:54,880 --> 00:36:01,600
that's not really possible if yourself

00:35:56,859 --> 00:36:06,400
backups because oh yes I want your

00:36:01,600 --> 00:36:08,650
trailer should be a we have to okay okay

00:36:06,400 --> 00:36:10,540
sit yet Jesus so packets are different

00:36:08,650 --> 00:36:12,550
yeah right

00:36:10,540 --> 00:36:13,930
but for the non gso case I think you

00:36:12,550 --> 00:36:16,119
have to absolutely have the trailer

00:36:13,930 --> 00:36:17,740
there that's what we're going to do okay

00:36:16,119 --> 00:36:19,510
then that's fine so you you're

00:36:17,740 --> 00:36:22,090
questioning what in that slide was what

00:36:19,510 --> 00:36:24,040
to do in the Dro case no no I wanted to

00:36:22,090 --> 00:36:27,220
make sure that we are on the same page

00:36:24,040 --> 00:36:29,920
so I put it like yes see you you have to

00:36:27,220 --> 00:36:33,010
adjust that see some end to whatever the

00:36:29,920 --> 00:36:38,020
card expects it wants the trailer is

00:36:33,010 --> 00:36:39,609
there or not you may not even need to

00:36:38,020 --> 00:36:41,200
really adjust the checksum end one

00:36:39,609 --> 00:36:43,810
possibility would be to just take the

00:36:41,200 --> 00:36:45,460
checksum for the trailer and include

00:36:43,810 --> 00:36:47,500
that in your partial checksum and then

00:36:45,460 --> 00:36:51,930
it just cancels it out that's exactly

00:36:47,500 --> 00:36:55,890
what we do so okay so thank you boys

00:36:51,930 --> 00:36:55,890
so next one story on

00:37:11,700 --> 00:37:15,630
so we are long time so I will just skip

00:37:14,010 --> 00:37:18,059
to the numbers because that's the only

00:37:15,630 --> 00:37:20,640
thing that's actually relevant here so

00:37:18,059 --> 00:37:23,160
what if we remove it and we will get

00:37:20,640 --> 00:37:27,299
around 30% performance it for small

00:37:23,160 --> 00:37:29,040
packets which is quite big if you test

00:37:27,299 --> 00:37:30,480
with bigger packets like one thousand

00:37:29,040 --> 00:37:32,160
four hundred thousand five hundred then

00:37:30,480 --> 00:37:38,160
it will be roughly ten to twelve percent

00:37:32,160 --> 00:37:39,839
performance it the problem is that the

00:37:38,160 --> 00:37:41,849
flow cap can be brought into a state

00:37:39,839 --> 00:37:43,500
where it actually is really suboptimal

00:37:41,849 --> 00:37:45,089
and you can never get a hit and you

00:37:43,500 --> 00:37:47,490
always have to take a slow path and in

00:37:45,089 --> 00:37:49,290
that in those cases not having it's

00:37:47,490 --> 00:37:51,480
located just actually a big bonus and

00:37:49,290 --> 00:37:55,200
you can get up to 60 to 70 percent more

00:37:51,480 --> 00:37:57,750
performance if you have bad traffic

00:37:55,200 --> 00:38:04,799
patterns that exploit flow cache

00:37:57,750 --> 00:38:09,049
behavior looking at perc top with the

00:38:04,799 --> 00:38:11,940
flow ket you will see that the flow cash

00:38:09,049 --> 00:38:14,430
lookup is not actually very expensive so

00:38:11,940 --> 00:38:17,970
it's pretty much down the line on was

00:38:14,430 --> 00:38:20,220
about one or two percent in Perth and if

00:38:17,970 --> 00:38:22,980
you get rid of it and suddenly you will

00:38:20,220 --> 00:38:25,950
have a farm resort and create bond law

00:38:22,980 --> 00:38:27,569
in the hot path because normally that

00:38:25,950 --> 00:38:30,000
function will only be executed whenever

00:38:27,569 --> 00:38:32,750
you install a new flow into the cache

00:38:30,000 --> 00:38:35,790
and suddenly that becomes a hot path

00:38:32,750 --> 00:38:39,480
nowadays after we got rid of the locks

00:38:35,790 --> 00:38:41,309
in the in that function and rely on RC

00:38:39,480 --> 00:38:43,170
you alone it will no longer have the

00:38:41,309 --> 00:38:46,260
problem that we run into scalability

00:38:43,170 --> 00:38:48,990
problems with several CPUs what we do

00:38:46,260 --> 00:38:51,329
have two problem that the extra overhead

00:38:48,990 --> 00:38:53,900
of just instantiating and deleting the

00:38:51,329 --> 00:38:57,420
additional UC transformer entries

00:38:53,900 --> 00:39:00,059
expense of the atomic operations to get

00:38:57,420 --> 00:39:04,200
a reference on the policy and in the

00:39:00,059 --> 00:39:06,690
state will become a problem on the MTU

00:39:04,200 --> 00:39:09,059
initialization graphs the spin lock and

00:39:06,690 --> 00:39:10,500
everything starts to show up so I

00:39:09,059 --> 00:39:12,780
believe we can get a bit more

00:39:10,500 --> 00:39:14,910
performance out of this just by

00:39:12,780 --> 00:39:17,579
optimizing for that

00:39:14,910 --> 00:39:20,400
to my surprise I do not believe that we

00:39:17,579 --> 00:39:22,779
have an algorithmic problem with slow

00:39:20,400 --> 00:39:24,309
algorithms in the resolver

00:39:22,779 --> 00:39:28,839
function so I do not believe that this

00:39:24,309 --> 00:39:31,089
will need major rework so that's

00:39:28,839 --> 00:39:39,400
basically it and I would defer to honest

00:39:31,089 --> 00:39:43,479
- hi I'm acting as a proxy here for poor

00:39:39,400 --> 00:39:45,880
Boutros give me some points to raise in

00:39:43,479 --> 00:39:58,029
regards what he would like to see from

00:39:45,880 --> 00:40:00,969
that subsystem is that we might need to

00:39:58,029 --> 00:40:04,539
have his pee encapsulation inside TCP

00:40:00,969 --> 00:40:09,630
packets so the RC basically looks like

00:40:04,539 --> 00:40:11,890
that the authentication process is done

00:40:09,630 --> 00:40:14,619
with steel s so that would be like

00:40:11,890 --> 00:40:18,099
memory less handshaking in the beginning

00:40:14,619 --> 00:40:20,380
which probably can make be done this is

00:40:18,099 --> 00:40:21,909
Katie Ellis or like in userspace and

00:40:20,380 --> 00:40:23,739
after that we would have to pass a

00:40:21,909 --> 00:40:27,729
socket down to the except for him there

00:40:23,739 --> 00:40:29,409
where we would do the further data

00:40:27,729 --> 00:40:32,499
transmission they use people to call it

00:40:29,409 --> 00:40:35,169
inside the TCP connection it looks like

00:40:32,499 --> 00:40:36,999
except we could actually reuse maybe TCP

00:40:35,169 --> 00:40:39,880
sockets so we don't need to like we

00:40:36,999 --> 00:40:42,279
don't end up in this s TT mess I don't

00:40:39,880 --> 00:40:45,669
know if there's some possibility to like

00:40:42,279 --> 00:40:47,769
easily and switch off combustion control

00:40:45,669 --> 00:40:50,279
behavior and let the inner TCP packets

00:40:47,769 --> 00:40:50,279
handle that

00:40:59,150 --> 00:41:04,410
so give everyone some context in case

00:41:01,860 --> 00:41:06,830
you missed the abomination that just

00:41:04,410 --> 00:41:10,440
came through the microphone

00:41:06,830 --> 00:41:13,130
what stt is is they try to use TCP as a

00:41:10,440 --> 00:41:15,960
transport layer they tunnel traffic into

00:41:13,130 --> 00:41:18,480
stt why do they do this they think that

00:41:15,960 --> 00:41:20,280
it's a great idea because all Hardware

00:41:18,480 --> 00:41:22,140
chips out there support check something

00:41:20,280 --> 00:41:23,130
off load and all these and G ro and GS

00:41:22,140 --> 00:41:26,850
oh and all these things

00:41:23,130 --> 00:41:29,940
the problem is TCP is not a Datagram

00:41:26,850 --> 00:41:32,010
protocol and middleboxes and shaping

00:41:29,940 --> 00:41:35,180
devices and all these things on the

00:41:32,010 --> 00:41:37,890
entire internet for that for that matter

00:41:35,180 --> 00:41:39,810
expect TCP to behave in a certain way

00:41:37,890 --> 00:41:42,830
and once you start using it as a

00:41:39,810 --> 00:41:44,940
transport layer a Datagram based thing

00:41:42,830 --> 00:41:47,880
all that goes out the window

00:41:44,940 --> 00:41:49,530
for example if intermediate router is

00:41:47,880 --> 00:41:52,440
dropping packets with an algorithm like

00:41:49,530 --> 00:41:56,240
red to try to initiate back off of TCP

00:41:52,440 --> 00:41:58,620
flows these stt streams do not back off

00:41:56,240 --> 00:41:59,370
they keep sending at the maximum rate

00:41:58,620 --> 00:42:01,770
that they can get through the

00:41:59,370 --> 00:42:03,600
intermediate router this is going to

00:42:01,770 --> 00:42:05,520
blow up every single piece of work that

00:42:03,600 --> 00:42:06,990
we've done with cubic high start and now

00:42:05,520 --> 00:42:09,510
bbr and all these other congestion

00:42:06,990 --> 00:42:13,980
control algorithms so any time I hear

00:42:09,510 --> 00:42:17,520
someone using TCP as a transport as a

00:42:13,980 --> 00:42:19,050
way to tunnel traffic I just I just

00:42:17,520 --> 00:42:21,210
don't like the idea in the first place

00:42:19,050 --> 00:42:31,050
I am absolutely miss you the the point

00:42:21,210 --> 00:42:32,550
is that it's widely used like the sex

00:42:31,050 --> 00:42:35,640
stuff seems to be like coming up as this

00:42:32,550 --> 00:42:37,830
open cannot any connect from Cisco the

00:42:35,640 --> 00:42:40,280
questions like if they do that in future

00:42:37,830 --> 00:42:43,340
user space or not on the other side

00:42:40,280 --> 00:42:45,620
you think we can actually he was a

00:42:43,340 --> 00:42:47,750
full-blown TCP socket so we do

00:42:45,620 --> 00:42:49,580
commercial control on it and just like

00:42:47,750 --> 00:42:51,140
that's it peace apart from the kernel

00:42:49,580 --> 00:42:52,700
and if the multiple visit where you can

00:42:51,140 --> 00:42:55,520
do whatever the ramp would be nice I

00:42:52,700 --> 00:43:00,260
just note to you so we do I would simply

00:42:55,520 --> 00:43:02,270
do like normal TCP themself in user

00:43:00,260 --> 00:43:03,620
space and send it over a normal TCP

00:43:02,270 --> 00:43:05,690
socket and we could be none the wiser

00:43:03,620 --> 00:43:08,570
and I would recommend it that's what

00:43:05,690 --> 00:43:09,620
they pursue if they absolutely if they

00:43:08,570 --> 00:43:11,540
absolutely have to have the

00:43:09,620 --> 00:43:17,150
functionality they can open TCP sockets

00:43:11,540 --> 00:43:18,830
in user space and just send in the user

00:43:17,150 --> 00:43:20,330
space and then we pass it on - except

00:43:18,830 --> 00:43:21,920
for em to get like four correct routine

00:43:20,330 --> 00:43:23,900
behavior auto-peep play tricks miss

00:43:21,920 --> 00:43:26,750
toughen up or stuff like that so I'm in

00:43:23,900 --> 00:43:28,670
this URL but I really want to hand this

00:43:26,750 --> 00:43:30,500
problem off the users face if they want

00:43:28,670 --> 00:43:32,030
to do stupid stuff like this over TCP

00:43:30,500 --> 00:43:34,100
sockets I really don't want to support

00:43:32,030 --> 00:43:36,080
this as a first as a first order

00:43:34,100 --> 00:43:43,970
facility inside the kernel it really is

00:43:36,080 --> 00:43:45,800
bad microphone are they using SCT or

00:43:43,970 --> 00:43:49,070
just full-blown TCP I thought it was

00:43:45,800 --> 00:43:50,660
full on TCP because stt hacks the whole

00:43:49,070 --> 00:44:00,890
TCP state machine it tries to make it

00:43:50,660 --> 00:44:02,240
stateless it tries to and also that they

00:44:00,890 --> 00:44:03,980
do a full-blown to your left hand shake

00:44:02,240 --> 00:44:07,610
and then they switch to something which

00:44:03,980 --> 00:44:09,020
is PPP mode yeah but like STD fake

00:44:07,610 --> 00:44:10,400
source port number so that it can get

00:44:09,020 --> 00:44:11,810
easy and be from the intermediate

00:44:10,400 --> 00:44:13,820
routers they don't care about itself

00:44:11,810 --> 00:44:15,410
they say like connecting for for three

00:44:13,820 --> 00:44:17,300
or four thousand five hundred TCP and

00:44:15,410 --> 00:44:19,600
that's it and they don't talk about that

00:44:17,300 --> 00:44:19,600
in there

00:44:22,810 --> 00:44:28,520
absolutely not acceptable what should be

00:44:25,910 --> 00:44:32,300
done about it I think the premise is

00:44:28,520 --> 00:44:34,040
invalid I I think getting doing any of

00:44:32,300 --> 00:44:37,310
this supporting any aspect of this in a

00:44:34,040 --> 00:44:38,660
kernel is really a non-starter I don't

00:44:37,310 --> 00:44:40,490
think I could use that I guys Ghazi I

00:44:38,660 --> 00:44:42,200
would such as so busy can be to

00:44:40,490 --> 00:44:45,340
connection setup and stuff and that

00:44:42,200 --> 00:44:45,340
intended on the common

00:44:51,130 --> 00:45:54,560
because like it's terrible to have a

00:45:52,760 --> 00:45:56,330
next year except for I'm transform that

00:45:54,560 --> 00:45:58,700
has a template that sends it to a ton

00:45:56,330 --> 00:46:00,050
interface and then you you take the you

00:45:58,700 --> 00:46:06,380
take the payload and you stuff it into

00:46:00,050 --> 00:46:08,090
TCP or something to a ton interface in

00:46:06,380 --> 00:46:09,950
the time interface and get associated to

00:46:08,090 --> 00:46:11,990
the XFM and then april to the

00:46:09,950 --> 00:46:14,690
encapsulation but where's the tcp then

00:46:11,990 --> 00:46:16,790
again so uses face you send it on your

00:46:14,690 --> 00:46:26,330
TCP socket at supper you to you from a

00:46:16,790 --> 00:46:31,880
town file script and the second point is

00:46:26,330 --> 00:46:35,680
like host names socket so as KB's so

00:46:31,880 --> 00:46:35,680
there's some requests that basically

00:46:36,490 --> 00:46:39,500
opportunistic encryption should happen

00:46:38,330 --> 00:46:41,870
in the internet so basically have the

00:46:39,500 --> 00:46:44,260
connection to every other system should

00:46:41,870 --> 00:46:44,260
be encrypted

00:47:34,079 --> 00:47:38,380
because when you send the King

00:47:36,280 --> 00:47:40,210
information to the demon to another

00:47:38,380 --> 00:47:42,760
netlink attribute then the King demon

00:47:40,210 --> 00:48:02,380
does the DNS lookup and other stuff to

00:47:42,760 --> 00:48:04,540
do to resolve the program there was a

00:48:02,380 --> 00:48:05,980
stock option that stuck a string into

00:48:04,540 --> 00:48:08,109
the socket and then we try to do is send

00:48:05,980 --> 00:48:09,700
for the first time so we have to resolve

00:48:08,109 --> 00:48:12,309
the transform and we send the message to

00:48:09,700 --> 00:48:13,809
the King demon it goes to the kingdom we

00:48:12,309 --> 00:48:21,099
gets an attribute that has the string in

00:48:13,809 --> 00:48:22,569
it that comes out of the sockets mean we

00:48:21,099 --> 00:48:24,549
actually have to start at some hope a

00:48:22,569 --> 00:48:26,380
diagram if you want to support that in

00:48:24,549 --> 00:48:29,140
the connected case we can basically just

00:48:26,380 --> 00:48:31,250
refer to as KB SK and then get the

00:48:29,140 --> 00:48:34,730
string out of the socket

00:48:31,250 --> 00:48:37,340
the case well it might be to do this USC

00:48:34,730 --> 00:48:39,710
message yes you could stick it into the

00:48:37,340 --> 00:48:40,160
to transform entries or something like

00:48:39,710 --> 00:48:42,080
this

00:48:40,160 --> 00:48:45,740
that doesn't work because you have to

00:48:42,080 --> 00:48:47,570
have a Breanna entry to talk in the

00:48:45,740 --> 00:48:49,849
first place anyways so you always need

00:48:47,570 --> 00:48:53,840
some pieces transform state hang off the

00:48:49,849 --> 00:48:57,109
packet in order to even figure out if

00:48:53,840 --> 00:48:58,340
you can resolve an IPSec path or not so

00:48:57,109 --> 00:49:00,109
anything that's configured with this

00:48:58,340 --> 00:49:01,550
string we get these dummy transform

00:49:00,109 --> 00:49:03,790
entries that have the reference to the

00:49:01,550 --> 00:49:07,910
string no matter what if the SK is

00:49:03,790 --> 00:49:12,349
connectionless or not sorry I couldn't

00:49:07,910 --> 00:49:14,030
follow so I would say we have like a SPD

00:49:12,349 --> 00:49:15,950
entry which basically says like I want

00:49:14,030 --> 00:49:17,900
to encrypt everything and then we

00:49:15,950 --> 00:49:19,670
basically have the I sitting on top of

00:49:17,900 --> 00:49:21,349
that and then I open Firefox to some web

00:49:19,670 --> 00:49:23,570
site and then I need to have this this

00:49:21,349 --> 00:49:25,190
hostname from the Firefox all inside the

00:49:23,570 --> 00:49:49,250
Ikey demon right and that is to go

00:49:25,190 --> 00:49:50,839
through the covers all traffic that

00:49:49,250 --> 00:49:53,300
might be using the strings that the

00:49:50,839 --> 00:49:55,220
applications choose but there's a many

00:49:53,300 --> 00:49:57,020
to one relationship there's one policy

00:49:55,220 --> 00:49:58,910
there's many strings that's the problem

00:49:57,020 --> 00:50:01,030
you can't just stick it into the single

00:49:58,910 --> 00:50:03,500
policy that covers everything exactly

00:50:01,030 --> 00:50:06,380
what I'm saying is you could instantiate

00:50:03,500 --> 00:50:08,030
doubly dummy transformed state objects

00:50:06,380 --> 00:50:14,270
that hang off the skp that can track

00:50:08,030 --> 00:50:15,530
what we were trying to do hmm okay so

00:50:14,270 --> 00:50:17,480
the next thing is probably interesting

00:50:15,530 --> 00:50:19,010
to that nerd guys because like that was

00:50:17,480 --> 00:50:20,960
less interesting that's kind of also

00:50:19,010 --> 00:50:24,500
very difficult for me David so we have

00:50:20,960 --> 00:50:26,300
this problem that shot two truncation

00:50:24,500 --> 00:50:31,450
which was used to not be circus in the

00:50:26,300 --> 00:50:33,630
carnivals 96 bit right not defined and

00:50:31,450 --> 00:50:37,230
basically the whole world

00:50:33,630 --> 00:50:39,779
the FCC says we need to use 1 and 28 but

00:50:37,230 --> 00:50:40,980
and that causes a drop ability problems

00:50:39,779 --> 00:50:42,720
between and what because I think

00:50:40,980 --> 00:50:45,210
actually an alerts the user seventies

00:50:42,720 --> 00:50:48,000
expert and and we should that's because

00:50:45,210 --> 00:50:51,960
like the ike demons on android don't

00:50:48,000 --> 00:50:55,049
upgrade the truncation 228 or we're not

00:50:51,960 --> 00:50:57,869
linked we have to add a new string into

00:50:55,049 --> 00:51:01,500
the transform tables it's actually there

00:50:57,869 --> 00:51:03,000
you can configure array so we have like

00:51:01,500 --> 00:51:04,799
two words out there right now like

00:51:03,000 --> 00:51:07,200
Apogee Cisco's the chancellor's problem

00:51:04,799 --> 00:51:09,210
but basically everyone upgraded to one

00:51:07,200 --> 00:51:11,730
or 28 right now and the questions like

00:51:09,210 --> 00:51:20,880
should be maybe also like set the

00:51:11,730 --> 00:51:24,059
default 120 yes okay this the page was

00:51:20,880 --> 00:51:25,829
actually three times rejected so I can

00:51:24,059 --> 00:51:30,440
tell me how to fix it in userspace

00:51:25,829 --> 00:51:30,440
I just don't understand that you're okay

00:51:30,619 --> 00:51:52,529
okay okay so I can I said you like more

00:51:37,910 --> 00:51:55,829
Sentosa patch for the default change so

00:51:52,529 --> 00:51:57,660
we violate the RCC bug except it's been

00:51:55,829 --> 00:52:00,539
around for a long time yes but it is a

00:51:57,660 --> 00:52:06,839
bug the whole world violates the urgent

00:52:00,539 --> 00:52:08,430
pointer location by one so it's other

00:52:06,839 --> 00:52:10,799
questions are like should we get like

00:52:08,430 --> 00:52:14,940
rate limited acquires for bad IPSec SP

00:52:10,799 --> 00:52:18,509
eyes it will type in like fast the

00:52:14,940 --> 00:52:24,900
reestablishment of IPSec keys probably

00:52:18,509 --> 00:52:30,720
not a big issue I think IPSec we as any

00:52:24,900 --> 00:52:32,849
display is seen is that a buck okay

00:52:30,720 --> 00:52:35,460
sorry I just got this information like

00:52:32,849 --> 00:52:37,380
what I should talk about the next thing

00:52:35,460 --> 00:52:40,430
is also a little bit controversial and

00:52:37,380 --> 00:52:40,430
so this

00:52:40,790 --> 00:52:50,050
actually do tunnel mode negotiations and

00:52:44,560 --> 00:52:52,550
not needs to be you sit in front of the

00:52:50,050 --> 00:52:54,830
except for any manipulation so it can

00:52:52,550 --> 00:53:08,390
actually do the nothing inside the

00:52:54,830 --> 00:53:10,490
tunnel it's complicated the phone is

00:53:08,390 --> 00:53:12,980
like that basically if you have one

00:53:10,490 --> 00:53:14,770
destination and you have two users

00:53:12,980 --> 00:53:17,090
behind not they could have the same

00:53:14,770 --> 00:53:19,400
private IP address inside they're not

00:53:17,090 --> 00:53:22,700
and if they do the tunnel negotiation

00:53:19,400 --> 00:53:27,050
they would talk to the same they would

00:53:22,700 --> 00:53:28,850
use the same in the tunnel at peace when

00:53:27,050 --> 00:53:30,740
talking to the same destination so the

00:53:28,850 --> 00:53:33,290
destination could not actually use IP

00:53:30,740 --> 00:53:37,490
address to know to which which path to

00:53:33,290 --> 00:53:38,690
talk to and that's why they so far as I

00:53:37,490 --> 00:53:39,890
understood the protocol it's like a

00:53:38,690 --> 00:53:42,500
little bit difficult to understand

00:53:39,890 --> 00:53:44,210
offseason is that they actually discover

00:53:42,500 --> 00:53:47,450
the outer IP address and then is that

00:53:44,210 --> 00:53:50,210
I'm not true to actually do destination

00:53:47,450 --> 00:53:57,740
not inside the tunnel does the

00:53:50,210 --> 00:54:09,830
discovered route IP address okay I see

00:53:57,740 --> 00:54:14,470
no opinion on that so we are already

00:54:09,830 --> 00:54:14,470

YouTube URL: https://www.youtube.com/watch?v=bCVc6o3JxK8


