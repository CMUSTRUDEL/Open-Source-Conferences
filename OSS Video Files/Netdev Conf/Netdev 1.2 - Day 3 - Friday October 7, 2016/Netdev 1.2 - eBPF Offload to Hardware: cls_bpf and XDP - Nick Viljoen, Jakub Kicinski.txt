Title: Netdev 1.2 - eBPF Offload to Hardware: cls_bpf and XDP - Nick Viljoen, Jakub Kicinski
Publication date: 2016-10-08
Playlist: Netdev 1.2 - Day 3 - Friday October 7, 2016
Description: 
	https://netdevconf.org/1.2/session.html?jakub-kicinski
Captions: 
	00:00:30,470 --> 00:00:33,160
we go

00:00:35,560 --> 00:00:44,540
thank you everyone Oh moved on too

00:00:40,010 --> 00:00:46,030
quickly so what we are going to talk to

00:00:44,540 --> 00:00:53,239
you guys are it's all going wrong now

00:00:46,030 --> 00:00:55,670
yep what me and Jakob we're going to

00:00:53,239 --> 00:01:01,059
talk about today is just about using

00:00:55,670 --> 00:01:04,369
EVPs offload with CL sppf and xdp and

00:01:01,059 --> 00:01:05,540
pushing it to hardware as you can see

00:01:04,369 --> 00:01:10,160
I've just pointed out a little nick

00:01:05,540 --> 00:01:11,660
there that is MP u base Nick so what

00:01:10,160 --> 00:01:13,130
we've done is actually as the

00:01:11,660 --> 00:01:15,470
combination of the approaches you guys

00:01:13,130 --> 00:01:18,680
see I've seen so far for that is taking

00:01:15,470 --> 00:01:20,479
MP u and actually put it onto a Nick and

00:01:18,680 --> 00:01:22,369
then run that so it's really aimed right

00:01:20,479 --> 00:01:26,750
at the compute node here what we're

00:01:22,369 --> 00:01:28,460
doing this is kind of a motivation this

00:01:26,750 --> 00:01:30,289
is where we came from

00:01:28,460 --> 00:01:32,899
the fundamental problem when you're

00:01:30,289 --> 00:01:36,110
doing what we're doing as a MP base Nick

00:01:32,899 --> 00:01:37,990
company is that you know fully

00:01:36,110 --> 00:01:40,550
programmable hardware could do anything

00:01:37,990 --> 00:01:42,800
so we run into this problem of what I

00:01:40,550 --> 00:01:45,770
call whack-a-mole which is where we end

00:01:42,800 --> 00:01:48,679
up with sort of custom code for custom

00:01:45,770 --> 00:01:50,119
purposes over and over again because you

00:01:48,679 --> 00:01:53,810
end up with a client client wants to

00:01:50,119 --> 00:01:57,080
offload X you write code client uses

00:01:53,810 --> 00:01:59,780
code the you end up patching up kernels

00:01:57,080 --> 00:02:02,869
you end up spending a lot of time now

00:01:59,780 --> 00:02:06,619
that's difficult for us because it's

00:02:02,869 --> 00:02:07,880
hard to get the actual customers to buy

00:02:06,619 --> 00:02:09,229
interpreters they know it's sticky

00:02:07,880 --> 00:02:12,319
because once they're using it they kind

00:02:09,229 --> 00:02:13,849
of stuck with it and then it's huge risk

00:02:12,319 --> 00:02:16,489
for us because we have to spend a lot of

00:02:13,849 --> 00:02:18,650
time working on it and then at the last

00:02:16,489 --> 00:02:21,170
moment a client could say no we don't

00:02:18,650 --> 00:02:24,340
want this so that kind of pushed us to

00:02:21,170 --> 00:02:26,360
actually think actually instead of

00:02:24,340 --> 00:02:28,069
keeping on thinking what we should

00:02:26,360 --> 00:02:30,020
offload next what we should also next

00:02:28,069 --> 00:02:33,800
which is talking about how we do this

00:02:30,020 --> 00:02:38,569
offload and that's kind of why we ended

00:02:33,800 --> 00:02:40,700
up with VPS why it's it's a well-defined

00:02:38,569 --> 00:02:44,060
framework the instruction set Maps well

00:02:40,700 --> 00:02:47,020
to what are sort of our risk based CPUs

00:02:44,060 --> 00:02:49,520
on our MP you can do

00:02:47,020 --> 00:02:51,590
it's totally defined but actually still

00:02:49,520 --> 00:02:54,190
highly stateful which helps for us we've

00:02:51,590 --> 00:02:56,390
got a lot of memory on that chip and

00:02:54,190 --> 00:02:59,200
we've got and we've got actually quite

00:02:56,390 --> 00:03:03,739
low latencies were able to use that well

00:02:59,200 --> 00:03:05,720
with the BPF model and also there's some

00:03:03,739 --> 00:03:07,850
sort of intrinsic paralyzation with it

00:03:05,720 --> 00:03:09,140
which really helps us seeing as we've

00:03:07,850 --> 00:03:12,080
got you know a huge amount of cores

00:03:09,140 --> 00:03:14,209
running at once and then the final point

00:03:12,080 --> 00:03:17,630
is actually it's it's gaining traction

00:03:14,209 --> 00:03:19,640
it's used in TCS used in xdp these are

00:03:17,630 --> 00:03:21,470
great hooks for us to use I mean you've

00:03:19,640 --> 00:03:23,450
seen one we've been speaking in the last

00:03:21,470 --> 00:03:24,709
couple of days people suggest things

00:03:23,450 --> 00:03:26,510
like you know I think Tom mentioned gr

00:03:24,709 --> 00:03:27,769
oh oh yeah there was a discussion

00:03:26,510 --> 00:03:30,260
earlier about you know whether we could

00:03:27,769 --> 00:03:32,380
use BPF for various other things have

00:03:30,260 --> 00:03:34,610
been mentioned in the context of IPPs

00:03:32,380 --> 00:03:37,160
there's so many different ways we can

00:03:34,610 --> 00:03:39,709
use this and suddenly instead of us

00:03:37,160 --> 00:03:41,510
having to go and whack moles guys can

00:03:39,709 --> 00:03:42,890
write their BPF code for their kernel

00:03:41,510 --> 00:03:44,780
and then we can just transparent it

00:03:42,890 --> 00:03:46,190
offload that and that's really the

00:03:44,780 --> 00:03:48,500
motivation and that's where we came from

00:03:46,190 --> 00:03:53,329
and that's why we think this is an

00:03:48,500 --> 00:03:54,530
approach which is interesting target

00:03:53,329 --> 00:03:59,000
architectures are going to quickly run

00:03:54,530 --> 00:04:00,799
through actually what the NFP mpu is so

00:03:59,000 --> 00:04:02,180
we've got a large group of fully

00:04:00,799 --> 00:04:04,280
programmable what we call flow

00:04:02,180 --> 00:04:06,980
processing cores these are small wrist

00:04:04,280 --> 00:04:08,600
CPUs there are raised into

00:04:06,980 --> 00:04:13,010
general-purpose islands where you've got

00:04:08,600 --> 00:04:14,420
program on each Island there's also some

00:04:13,010 --> 00:04:18,410
specialist islands which can do things

00:04:14,420 --> 00:04:19,940
like crypto some sort of memory accesses

00:04:18,410 --> 00:04:22,220
of P all the different types of things

00:04:19,940 --> 00:04:24,140
but the main the main sort of structure

00:04:22,220 --> 00:04:24,919
are these islands which are

00:04:24,140 --> 00:04:28,280
general-purpose

00:04:24,919 --> 00:04:31,430
with 12 of these processors on them a

00:04:28,280 --> 00:04:33,289
loading memory attached them as well so

00:04:31,430 --> 00:04:35,390
you've got on each one of these islands

00:04:33,289 --> 00:04:38,930
you've put sort of about 320 kilobytes

00:04:35,390 --> 00:04:41,630
of low latency SRAM arranged into two

00:04:38,930 --> 00:04:43,010
different parts and memory then also

00:04:41,630 --> 00:04:46,090
you've got a megabytes investor arm on

00:04:43,010 --> 00:04:48,530
the Nick 2 gigabytes of vram on the Nick

00:04:46,090 --> 00:04:49,850
what we're showing here sorry about the

00:04:48,530 --> 00:04:51,470
word salad here on the right hand side

00:04:49,850 --> 00:04:53,870
this is just a quick picture just to

00:04:51,470 --> 00:04:55,789
kind of always show you guys the process

00:04:53,870 --> 00:04:57,289
of what happens where the packets come

00:04:55,789 --> 00:04:58,919
in there's a sort of a system of pre

00:04:57,289 --> 00:05:01,319
classification

00:04:58,919 --> 00:05:03,270
the packets of the two kilobytes gets

00:05:01,319 --> 00:05:05,580
stored within the CTM so they're on the

00:05:03,270 --> 00:05:07,860
island itself to be able to be do lots

00:05:05,580 --> 00:05:10,590
of low latency accesses manage the

00:05:07,860 --> 00:05:11,999
packet use them a lot and then they get

00:05:10,590 --> 00:05:18,659
passed on through to the house this is

00:05:11,999 --> 00:05:20,879
obviously the receive path so on to the

00:05:18,659 --> 00:05:22,379
next one I said definitely quickly

00:05:20,879 --> 00:05:24,479
illustrate you know what happens when

00:05:22,379 --> 00:05:26,460
and show some super super super early

00:05:24,479 --> 00:05:28,620
super initial benchmarks that need to be

00:05:26,460 --> 00:05:31,860
taken with you know lots of lots of salt

00:05:28,620 --> 00:05:35,430
and health warnings so really what

00:05:31,860 --> 00:05:38,460
happens when we use BPF is we have

00:05:35,430 --> 00:05:41,330
certain islands which have which have

00:05:38,460 --> 00:05:44,159
BPF code on them so they get used as

00:05:41,330 --> 00:05:45,509
they can either so they're used as part

00:05:44,159 --> 00:05:46,919
of the whole structure so there are

00:05:45,509 --> 00:05:48,960
other islands things will pass through

00:05:46,919 --> 00:05:51,389
there are no sono islands there are

00:05:48,960 --> 00:05:58,110
other Emmys or FPC's things will pass

00:05:51,389 --> 00:05:59,999
through but EVP FF BC we're looking at

00:05:58,110 --> 00:06:02,460
about three million packets per second

00:05:59,999 --> 00:06:06,560
for a right let's redirect bear in mind

00:06:02,460 --> 00:06:09,089
our between 72 and 120 of these on npu

00:06:06,560 --> 00:06:12,719
and two point eight million packets per

00:06:09,089 --> 00:06:14,219
second for a reading arrive per sec that

00:06:12,719 --> 00:06:16,020
obviously does not scale because we're

00:06:14,219 --> 00:06:17,669
not going to have one of those we're not

00:06:16,020 --> 00:06:20,250
going to have an EVP F running on every

00:06:17,669 --> 00:06:22,020
single one of those but if we had let's

00:06:20,250 --> 00:06:23,939
say for power island and six islands

00:06:22,020 --> 00:06:29,159
that's already a a pretty compelling

00:06:23,939 --> 00:06:31,110
case so this is just to go into the

00:06:29,159 --> 00:06:33,930
actual FPC and just give you guys some

00:06:31,110 --> 00:06:35,610
idea of what's on there you've really

00:06:33,930 --> 00:06:37,969
got you've got so you've got a care of

00:06:35,610 --> 00:06:41,999
instructions store you've got have got

00:06:37,969 --> 00:06:43,620
128 a registers and B registers so we

00:06:41,999 --> 00:06:47,449
have a full prone system rather than a

00:06:43,620 --> 00:06:53,909
two operand system like x86 or UPF and

00:06:47,449 --> 00:06:56,879
we have 60 128 Reed 128 right transfer

00:06:53,909 --> 00:06:58,889
registers as well as 128 next neighbor

00:06:56,879 --> 00:07:00,899
registers which you can use a spill or

00:06:58,889 --> 00:07:03,330
overflow or just gives you a bit more

00:07:00,899 --> 00:07:05,909
flexibility the numbers as shown here

00:07:03,330 --> 00:07:08,339
are path thread so we have 8

00:07:05,909 --> 00:07:10,230
cooperatively multiplex thread power

00:07:08,339 --> 00:07:12,180
each one of these FPC's

00:07:10,230 --> 00:07:15,030
so that's how we hide late and see

00:07:12,180 --> 00:07:16,590
that's how we can make sure that memory

00:07:15,030 --> 00:07:23,040
axes in the cylinder actually cost you

00:07:16,590 --> 00:07:25,100
cycles and also another key thing is

00:07:23,040 --> 00:07:27,690
with the code store so we've got a K of

00:07:25,100 --> 00:07:29,820
instructions which we can store power

00:07:27,690 --> 00:07:31,770
FPC but you can actually link up to our

00:07:29,820 --> 00:07:33,990
pcs together and then you've got 16 care

00:07:31,770 --> 00:07:36,870
of a store so you can share code stores

00:07:33,990 --> 00:07:40,620
between different of pcs which allows

00:07:36,870 --> 00:07:42,900
you to build much bigger programs so

00:07:40,620 --> 00:07:45,870
just to quickly show just some key

00:07:42,900 --> 00:07:49,260
points about mapping EBP f4 actually to

00:07:45,870 --> 00:07:51,330
the NFP you'll notice one of the key

00:07:49,260 --> 00:07:55,620
things is that we have 32-bit registers

00:07:51,330 --> 00:07:56,640
and EVPs 64 bits so here's one of the

00:07:55,620 --> 00:07:58,560
key things we're going to be talking

00:07:56,640 --> 00:08:00,570
about but there's some optimization we

00:07:58,560 --> 00:08:03,750
can do there the LLVM compiler tends to

00:08:00,570 --> 00:08:05,160
push out a lot of lu 64 instructions we

00:08:03,750 --> 00:08:07,290
don't actually need those a lot of the

00:08:05,160 --> 00:08:09,720
time so we can push them down into

00:08:07,290 --> 00:08:10,680
32-bit instructions it just compresses

00:08:09,720 --> 00:08:13,500
things it just gives better performance

00:08:10,680 --> 00:08:14,520
and just save cycles so these are the

00:08:13,500 --> 00:08:15,540
kinds of things that we're going to be

00:08:14,520 --> 00:08:19,350
looking at when we're doing these

00:08:15,540 --> 00:08:22,860
mappings other things that are important

00:08:19,350 --> 00:08:25,290
are obviously we'll put this stack or

00:08:22,860 --> 00:08:28,110
end up in Elm m+ of maybe a little bit

00:08:25,290 --> 00:08:30,570
of CLS and the maps will push across the

00:08:28,110 --> 00:08:32,280
other memories and then we what we do is

00:08:30,570 --> 00:08:34,560
you've got a obviously a sort of caching

00:08:32,280 --> 00:08:38,820
system alright keep things keep things

00:08:34,560 --> 00:08:40,290
fast and my little final little bit is

00:08:38,820 --> 00:08:42,210
just to quickly just show sort of the

00:08:40,290 --> 00:08:44,340
programming model this has been

00:08:42,210 --> 00:08:46,320
mentioned by I think Daniel or by loads

00:08:44,340 --> 00:08:47,820
of guys this week so I'm I'm not going

00:08:46,320 --> 00:08:50,580
to do a laminate Jakob will go into the

00:08:47,820 --> 00:08:52,560
details in a sec but the key thing is

00:08:50,580 --> 00:08:54,150
just that what we're doing is it's the

00:08:52,560 --> 00:08:57,240
same path all the way through to the

00:08:54,150 --> 00:09:00,420
verifier then we just have our own NFP

00:08:57,240 --> 00:09:02,010
PPF jet we're reusing a lot of the

00:09:00,420 --> 00:09:03,300
kernel infrastructure sorry a lot of the

00:09:02,010 --> 00:09:06,230
verifier infrastructure that's already

00:09:03,300 --> 00:09:08,880
there within our are within our jet

00:09:06,230 --> 00:09:10,170
that's motivated some of the recent

00:09:08,880 --> 00:09:12,120
actions with trackable going to more

00:09:10,170 --> 00:09:15,110
detail of but it's led to things like

00:09:12,120 --> 00:09:17,190
the creation of VPS verified right

00:09:15,110 --> 00:09:19,900
because that just means we can reuse a

00:09:17,190 --> 00:09:21,310
lot of the infrastructure so this is

00:09:19,900 --> 00:09:24,070
be kind of the start this is the

00:09:21,310 --> 00:09:25,690
overview yak of now we'll go into sort

00:09:24,070 --> 00:09:27,190
of the depth and explain exactly what

00:09:25,690 --> 00:09:32,290
we've opportunity so far what the next

00:09:27,190 --> 00:09:34,510
plans are and where we're going super I

00:09:32,290 --> 00:09:37,410
can give you this are you happy about

00:09:34,510 --> 00:09:37,410
one awesome

00:09:47,790 --> 00:09:54,480
by describing the the EPF infrastructure

00:09:52,330 --> 00:09:58,090
and how it looked before we added our

00:09:54,480 --> 00:10:02,070
our extension and our code so in this

00:09:58,090 --> 00:10:04,920
diagram on the Left we can see the EBP F

00:10:02,070 --> 00:10:09,940
infrastructure that lives in current BPF

00:10:04,920 --> 00:10:12,700
that includes the EPF system call the

00:10:09,940 --> 00:10:15,160
verifier the the code that performs the

00:10:12,700 --> 00:10:17,940
other modifications and checks and then

00:10:15,160 --> 00:10:19,930
cause into the their host JIT and

00:10:17,940 --> 00:10:21,640
basically the the user space

00:10:19,930 --> 00:10:24,250
applications will use the this

00:10:21,640 --> 00:10:28,470
infrastructure - hello EVP ed programs

00:10:24,250 --> 00:10:30,730
into the car and then use control

00:10:28,470 --> 00:10:33,610
applications like which are network

00:10:30,730 --> 00:10:37,780
specific - to pin to basically attach

00:10:33,610 --> 00:10:41,380
the CB PF program into TC so in TC it

00:10:37,780 --> 00:10:46,030
will be GS b PF or to attach it to the

00:10:41,380 --> 00:10:47,260
driver in the XD p path and i mean this

00:10:46,030 --> 00:10:50,470
probably doesn't require much

00:10:47,260 --> 00:10:54,600
explanation the the this is sort of the

00:10:50,470 --> 00:10:57,220
pocket path through obviously and in xep

00:10:54,600 --> 00:10:59,190
we can do the processing before the skb

00:10:57,220 --> 00:11:01,360
is built for TC we have to build a CD

00:10:59,190 --> 00:11:05,220
and department processing happens

00:11:01,360 --> 00:11:08,200
slightly later in the start and here we

00:11:05,220 --> 00:11:14,250
showing the the in yellow the elements

00:11:08,200 --> 00:11:17,620
of the stack which we have changed or

00:11:14,250 --> 00:11:21,880
added so I'm starting from the top right

00:11:17,620 --> 00:11:25,510
we have extended series PPF with all the

00:11:21,880 --> 00:11:28,180
elements that are needed for the TC

00:11:25,510 --> 00:11:30,550
offload and so basically the Skip

00:11:28,180 --> 00:11:33,940
software's keep Hardware flags we have

00:11:30,550 --> 00:11:36,760
extended the TC offload object and which

00:11:33,940 --> 00:11:38,830
gets passed into the driver this is this

00:11:36,760 --> 00:11:42,820
is based basically on the work that

00:11:38,830 --> 00:11:44,830
Jones did John did for you for Tito and

00:11:42,820 --> 00:11:48,270
obviously the driver we had to add the

00:11:44,830 --> 00:11:48,270
antia for set of TC

00:11:48,569 --> 00:11:53,769
infrastructure to read statistics from

00:11:50,560 --> 00:11:56,290
the card and obviously the translator as

00:11:53,769 --> 00:11:58,540
well and last but not least we have

00:11:56,290 --> 00:12:02,079
extended the verifier to be able to

00:11:58,540 --> 00:12:03,579
reuse the in kind of verifier for our

00:12:02,079 --> 00:12:06,189
own verification and basically as a

00:12:03,579 --> 00:12:09,220
basis for analysis and parsing that we

00:12:06,189 --> 00:12:13,569
need to do to be able to to translate

00:12:09,220 --> 00:12:20,019
the EPF into our machine code so in this

00:12:13,569 --> 00:12:22,389
case the control cause of of the of TC

00:12:20,019 --> 00:12:25,689
and xdp we'll be attaching the program

00:12:22,389 --> 00:12:27,279
so if the program reaches TC it will all

00:12:25,689 --> 00:12:28,959
the relevant information will be put in

00:12:27,279 --> 00:12:32,889
the offload object and it will hit the

00:12:28,959 --> 00:12:35,050
driver in XDP obviously the program's

00:12:32,889 --> 00:12:36,490
attached to the driver directly so once

00:12:35,050 --> 00:12:39,790
the the program reaches the driver

00:12:36,490 --> 00:12:44,110
either set up TC india or it's attached

00:12:39,790 --> 00:12:46,180
to http the driver will attempt to

00:12:44,110 --> 00:12:49,300
perform the offload and if everything

00:12:46,180 --> 00:12:53,170
goes successful the EBP of motion the vp

00:12:49,300 --> 00:12:55,149
of program loaded on the card and the

00:12:53,170 --> 00:12:57,160
packet the packet path will be in the

00:12:55,149 --> 00:13:00,519
camera will basically look sort of like

00:12:57,160 --> 00:13:03,279
this so i try to show here that the part

00:13:00,519 --> 00:13:07,029
that goes on that pocket goes to the car

00:13:03,279 --> 00:13:10,149
without hitting the XD p or TC path but

00:13:07,029 --> 00:13:11,800
we are reserving sort of reserving the

00:13:10,149 --> 00:13:14,680
right to fall back to the software

00:13:11,800 --> 00:13:17,620
implementation if we need that and

00:13:14,680 --> 00:13:20,829
obviously the the the of the statistics

00:13:17,620 --> 00:13:22,660
module basically using the same

00:13:20,829 --> 00:13:25,089
infrastructure that I think Amir added

00:13:22,660 --> 00:13:27,670
for for flour we are reporting

00:13:25,089 --> 00:13:32,680
statistics to see - TC to populate the

00:13:27,670 --> 00:13:35,410
action and basically action statistics a

00:13:32,680 --> 00:13:37,959
few words about the translation and the

00:13:35,410 --> 00:13:40,029
verification that we perform so

00:13:37,959 --> 00:13:41,949
basically the first step when we get the

00:13:40,029 --> 00:13:43,240
vpf program to the drivers to check if

00:13:41,949 --> 00:13:46,809
the hardware is capable of performing

00:13:43,240 --> 00:13:50,079
the offload and we also read from the

00:13:46,809 --> 00:13:53,019
card some information about that about

00:13:50,079 --> 00:13:57,390
the data path so that includes on jump

00:13:53,019 --> 00:14:00,930
targets and like the maximal image sizes

00:13:57,390 --> 00:14:02,790
like that the card can can accept and so

00:14:00,930 --> 00:14:06,000
common instructions basic and can be

00:14:02,790 --> 00:14:09,209
loaded into the data graph and once we

00:14:06,000 --> 00:14:12,570
read that we will call into the verifier

00:14:09,209 --> 00:14:17,700
so in the verify we added a new entry

00:14:12,570 --> 00:14:19,800
point entry point to perform the

00:14:17,700 --> 00:14:21,959
verification the the problem that we had

00:14:19,800 --> 00:14:24,089
with a verifier is today the the

00:14:21,959 --> 00:14:26,610
standard verification in DB PF is

00:14:24,089 --> 00:14:28,500
performed together with some

00:14:26,610 --> 00:14:31,769
modifications so basically when user

00:14:28,500 --> 00:14:34,589
space loads BPF program it will perform

00:14:31,769 --> 00:14:36,839
verifications and then using the state

00:14:34,589 --> 00:14:38,700
that is collected for verification the

00:14:36,839 --> 00:14:42,180
verifier will perform modifications

00:14:38,700 --> 00:14:45,570
which are basically sort of as daniel

00:14:42,180 --> 00:14:48,089
was talking on his talk these are

00:14:45,570 --> 00:14:51,209
changing the offsets for for the context

00:14:48,089 --> 00:14:53,820
accesses and and and things like that so

00:14:51,209 --> 00:14:55,680
so we had to add a verifier entry point

00:14:53,820 --> 00:14:59,700
which will just perform the verification

00:14:55,680 --> 00:15:03,329
and won't do the take context and other

00:14:59,700 --> 00:15:06,120
modifications to the programs and we

00:15:03,329 --> 00:15:08,490
also exposed the very fire state so that

00:15:06,120 --> 00:15:11,399
we can basically from the driver's side

00:15:08,490 --> 00:15:15,440
see what the verifier is it's processing

00:15:11,399 --> 00:15:18,480
and we give a verifier a callback which

00:15:15,440 --> 00:15:20,640
which is invoked for every instructions

00:15:18,480 --> 00:15:24,630
of the verified traverses and this way

00:15:20,640 --> 00:15:27,089
we can basically use the verifier to

00:15:24,630 --> 00:15:30,180
perform driver specific checks so we we

00:15:27,089 --> 00:15:33,240
find that to to check basically whether

00:15:30,180 --> 00:15:35,370
the the program will be whether we will

00:15:33,240 --> 00:15:37,110
be able to offer the program whether the

00:15:35,370 --> 00:15:39,870
hardware will be capable of handling it

00:15:37,110 --> 00:15:42,180
and what the verification is is being

00:15:39,870 --> 00:15:45,360
performed we also collect some metadata

00:15:42,180 --> 00:15:47,910
about the program now we collect some

00:15:45,360 --> 00:15:50,730
instruction states basically to help us

00:15:47,910 --> 00:15:53,490
with the translation later and once the

00:15:50,730 --> 00:15:55,750
verification is successful do some

00:15:53,490 --> 00:15:58,180
optimization or generate the

00:15:55,750 --> 00:16:02,230
the machine code and load it onto the

00:15:58,180 --> 00:16:07,090
card so a quick look at the car at the

00:16:02,230 --> 00:16:09,130
sort of device path as Nick described we

00:16:07,090 --> 00:16:11,230
have multiple processing cores that are

00:16:09,130 --> 00:16:13,660
dedicated to the EBP up on the card

00:16:11,230 --> 00:16:15,160
these are shown here in blue I'm on the

00:16:13,660 --> 00:16:19,030
right hand side we have the statistics

00:16:15,160 --> 00:16:21,880
and and the maps in the card memory what

00:16:19,030 --> 00:16:26,650
I'm mostly want to concentrate on here

00:16:21,880 --> 00:16:29,260
is the orange and yellow big bits in the

00:16:26,650 --> 00:16:32,920
middle on the left so I'm trying to show

00:16:29,260 --> 00:16:36,700
how the packet information is populated

00:16:32,920 --> 00:16:41,140
and handed over to the kernel basically

00:16:36,700 --> 00:16:44,290
the the gray data path in the card on

00:16:41,140 --> 00:16:46,960
the top on the bottom left will perform

00:16:44,290 --> 00:16:48,460
all the standard processing that that is

00:16:46,960 --> 00:16:50,170
needed for the NIC and at this point the

00:16:48,460 --> 00:16:52,450
packet basically has the same state as

00:16:50,170 --> 00:16:54,330
it would have when it's arriving in the

00:16:52,450 --> 00:16:57,400
car and I expander

00:16:54,330 --> 00:16:59,440
so invoking UPF at this point is pretty

00:16:57,400 --> 00:17:02,440
pretty natural and we have all the

00:16:59,440 --> 00:17:04,060
information that is needed but we also

00:17:02,440 --> 00:17:06,520
want to pass some of the information

00:17:04,060 --> 00:17:09,550
that the EPF would produce up into the

00:17:06,520 --> 00:17:12,760
driver and basically to be able to

00:17:09,550 --> 00:17:15,959
populate skb fields and we do that by

00:17:12,760 --> 00:17:17,949
prepending to the pocket

00:17:15,959 --> 00:17:19,990
basically arbitrary we can prevent

00:17:17,949 --> 00:17:22,510
arbitrary metadata we have a formatter

00:17:19,990 --> 00:17:25,150
of prepending metadata to the pocket and

00:17:22,510 --> 00:17:27,220
we can and this is shown in the

00:17:25,150 --> 00:17:28,780
basically in the center of the slide we

00:17:27,220 --> 00:17:30,820
have the pocket and we just push

00:17:28,780 --> 00:17:34,660
information in front of it and we use

00:17:30,820 --> 00:17:36,700
that to pass things like the skb mark

00:17:34,660 --> 00:17:41,350
for instance today we also use that for

00:17:36,700 --> 00:17:43,780
directions basically to when there is a

00:17:41,350 --> 00:17:46,750
redirection done by the EPF program to a

00:17:43,780 --> 00:17:51,040
port which is not part of the card

00:17:46,750 --> 00:17:52,870
and we will have to pass the if index up

00:17:51,040 --> 00:17:54,700
to the the driver and then performed

00:17:52,870 --> 00:17:56,470
every direction in the driver so where

00:17:54,700 --> 00:17:58,630
was the metadata basically to pass the

00:17:56,470 --> 00:17:59,150
IP index for our directions another

00:17:58,630 --> 00:18:02,630
thing that

00:17:59,150 --> 00:18:07,520
use this for producing is TC return

00:18:02,630 --> 00:18:09,260
codes because unlike XDP in TC the

00:18:07,520 --> 00:18:11,809
pocket can show up in the kernel stack

00:18:09,260 --> 00:18:14,240
in the kind of path for two reasons you

00:18:11,809 --> 00:18:16,270
can either be accepted and this is

00:18:14,240 --> 00:18:19,250
referring mostly to the direct action

00:18:16,270 --> 00:18:19,790
action know that Daniel was talking

00:18:19,250 --> 00:18:22,309
about earlier

00:18:19,790 --> 00:18:25,970
so what EBP F program is returning that

00:18:22,309 --> 00:18:28,490
you see return code directly and in this

00:18:25,970 --> 00:18:29,870
mode we can get a basically the pocket

00:18:28,490 --> 00:18:32,059
in the kind of a path either because

00:18:29,870 --> 00:18:34,220
it's accepted or because the filter

00:18:32,059 --> 00:18:37,850
didn't match so the code was either ok

00:18:34,220 --> 00:18:41,300
or unspecified and we have to be able to

00:18:37,850 --> 00:18:44,330
basically differentiate between the two

00:18:41,300 --> 00:18:46,340
so we have to replant the full return

00:18:44,330 --> 00:18:51,050
code to their pocket and and and be able

00:18:46,340 --> 00:18:53,270
to look at it in in TC later on and we

00:18:51,050 --> 00:18:55,640
also have in the description we have

00:18:53,270 --> 00:18:58,250
some bits which we can use for to mark

00:18:55,640 --> 00:19:00,230
whether the pocket has already been

00:18:58,250 --> 00:19:02,929
processed by BPF on the card which

00:19:00,230 --> 00:19:07,570
enables doing some interesting things

00:19:02,929 --> 00:19:07,570
with the software for work in the kernel

00:19:07,630 --> 00:19:11,570
overview of the actions and

00:19:09,820 --> 00:19:13,760
modifications that we basically can

00:19:11,570 --> 00:19:16,220
perform the card obviously most ALU

00:19:13,760 --> 00:19:20,600
operations we have supported right right

00:19:16,220 --> 00:19:22,910
away we can do arbitrary pocket

00:19:20,600 --> 00:19:25,820
modifications we hope to have the basic

00:19:22,910 --> 00:19:28,610
math support soon and obviously we can

00:19:25,820 --> 00:19:32,630
perform as I said operations on the on

00:19:28,610 --> 00:19:33,950
the pocket metadata like RX Kush and

00:19:32,630 --> 00:19:36,440
stuff like that because already

00:19:33,950 --> 00:19:39,520
populated by the device later profit the

00:19:36,440 --> 00:19:42,260
point that we get the pocket basically

00:19:39,520 --> 00:19:42,710
and on the action side we can do all the

00:19:42,260 --> 00:19:45,380
basic

00:19:42,710 --> 00:19:48,080
xdp actions so that would be redirection

00:19:45,380 --> 00:19:50,300
to therefore that pocket came in came

00:19:48,080 --> 00:19:52,400
from a job and and passed with all the

00:19:50,300 --> 00:19:55,629
modifications and the metadata that have

00:19:52,400 --> 00:19:57,950
been attached we are only using

00:19:55,629 --> 00:20:00,999
direction to the force from which the

00:19:57,950 --> 00:20:05,570
pocket King right now because unlike

00:20:00,999 --> 00:20:07,610
simpler TC offload EVP F can be for EVP

00:20:05,570 --> 00:20:10,220
F we can't tell at the translation time

00:20:07,610 --> 00:20:12,139
basically to which part the direction

00:20:10,220 --> 00:20:15,019
will happen because the IIF index can be

00:20:12,139 --> 00:20:18,440
looked at from them up or or even

00:20:15,019 --> 00:20:21,080
computed so we have to do some form of

00:20:18,440 --> 00:20:23,809
lookup and we basically translate the I

00:20:21,080 --> 00:20:25,909
F index into a device port so we will

00:20:23,809 --> 00:20:28,070
basically we have a plan to reuse the

00:20:25,909 --> 00:20:30,980
maps likewise well when we have the maps

00:20:28,070 --> 00:20:34,869
will use the maps to to map between eye

00:20:30,980 --> 00:20:39,109
appendices and and device ports on the

00:20:34,869 --> 00:20:40,759
on at runtime and if there is a nice

00:20:39,109 --> 00:20:42,350
basically and the I have indexes notes

00:20:40,759 --> 00:20:44,389
on the cart as I said previously will

00:20:42,350 --> 00:20:49,039
just fall back to driver doing the right

00:20:44,389 --> 00:20:55,039
direction a few words about the map

00:20:49,039 --> 00:20:55,700
support at this it has been studying the

00:20:55,039 --> 00:21:00,549
morning already

00:20:55,700 --> 00:21:05,149
obviously EPF is a stateful stateful

00:21:00,549 --> 00:21:07,669
stateful processing so and we are facing

00:21:05,149 --> 00:21:11,659
here some problems which which have not

00:21:07,669 --> 00:21:15,320
been faced before basically if the BPF

00:21:11,659 --> 00:21:16,879
is modifying the state and the kind of

00:21:15,320 --> 00:21:19,279
data process modifying the state at the

00:21:16,879 --> 00:21:22,850
same time there is basically no way for

00:21:19,279 --> 00:21:26,749
us to to synchronize this reasonable

00:21:22,850 --> 00:21:28,580
performance so we have to find ways

00:21:26,749 --> 00:21:31,940
around it and basically we have

00:21:28,580 --> 00:21:34,340
identified three mark use cases like the

00:21:31,940 --> 00:21:37,249
the three use cases of maps that we'll

00:21:34,340 --> 00:21:39,590
be targeting initially and the first one

00:21:37,249 --> 00:21:41,149
is basically the only mark where the EBP

00:21:39,590 --> 00:21:45,109
have program that we offload is only

00:21:41,149 --> 00:21:47,119
reading the map and this will be this

00:21:45,109 --> 00:21:49,730
can be offloaded pretty easily by just

00:21:47,119 --> 00:21:51,649
read are reflecting all the

00:21:49,730 --> 00:21:53,299
date operation of the mark and keeping

00:21:51,649 --> 00:21:56,380
like a shadow copy of the mark in the

00:21:53,299 --> 00:21:59,690
device the other use case is when the

00:21:56,380 --> 00:22:02,510
there's of region updates from the

00:21:59,690 --> 00:22:06,830
program dis applauded and in this case

00:22:02,510 --> 00:22:10,090
we will basically try to add to the map

00:22:06,830 --> 00:22:13,490
infrastructure a way of cleaning on

00:22:10,090 --> 00:22:15,470
ownership of the map so that we can

00:22:13,490 --> 00:22:17,210
ensure that we are basically are

00:22:15,470 --> 00:22:20,510
offloaded programs the only program that

00:22:17,210 --> 00:22:22,309
is using the map and then we can just

00:22:20,510 --> 00:22:25,010
place the map entirely in the device

00:22:22,309 --> 00:22:26,750
memory and if any other EPF programs

00:22:25,010 --> 00:22:29,630
trying to attach to them up in the kind

00:22:26,750 --> 00:22:32,539
of data in the kernel space will just

00:22:29,630 --> 00:22:35,659
refuse that and and because that can

00:22:32,539 --> 00:22:37,850
cause changes in in the behavior that

00:22:35,659 --> 00:22:40,789
may be unexpected today I will only do

00:22:37,850 --> 00:22:44,059
the read/write of thought when the user

00:22:40,789 --> 00:22:46,010
is specifically asking for hardware only

00:22:44,059 --> 00:22:49,610
so so setting the skip software

00:22:46,010 --> 00:22:51,169
basically the software fragment EC and

00:22:49,610 --> 00:22:53,779
there are some other interesting use

00:22:51,169 --> 00:22:57,260
cases which we see here

00:22:53,779 --> 00:23:00,370
like for instance maps which are written

00:22:57,260 --> 00:23:04,100
to on you of the atomic at operation

00:23:00,370 --> 00:23:07,399
about the forwarding is not dependent on

00:23:04,100 --> 00:23:09,440
the on the value that is being updated

00:23:07,399 --> 00:23:13,070
to the atomic add which is basically a

00:23:09,440 --> 00:23:16,850
static use case one can think about of

00:23:13,070 --> 00:23:19,070
this as a situation where the maps are

00:23:16,850 --> 00:23:22,220
populated from the other space but from

00:23:19,070 --> 00:23:25,159
from user space or kernel space but the

00:23:22,220 --> 00:23:28,010
the audit program will perform atomic as

00:23:25,159 --> 00:23:30,769
on part of the value in the map two

00:23:28,010 --> 00:23:34,279
together study to collect statistics and

00:23:30,769 --> 00:23:37,370
this should be possible to support by

00:23:34,279 --> 00:23:41,120
basically when the user space is trying

00:23:37,370 --> 00:23:42,950
to read statistics to read them up just

00:23:41,120 --> 00:23:44,630
collecting all the copies of the map

00:23:42,950 --> 00:23:47,230
from the kernel space and from the

00:23:44,630 --> 00:23:50,929
device and adding them up or just

00:23:47,230 --> 00:23:54,019
presenting them as if they were for CPU

00:23:50,929 --> 00:23:54,830
maps and this should be pretty easy to

00:23:54,019 --> 00:23:56,000
do

00:23:54,830 --> 00:23:58,669
all those use cases should be pretty

00:23:56,000 --> 00:23:59,809
easy to identify using the verifier

00:23:58,669 --> 00:24:04,750
infrastructure that we carry in the

00:23:59,809 --> 00:24:07,750
condo maybe work slight additions and

00:24:04,750 --> 00:24:10,580
obviously we can support multiple maps

00:24:07,750 --> 00:24:12,110
at the same time so these are just the

00:24:10,580 --> 00:24:16,360
use cases that we can have a mix of them

00:24:12,110 --> 00:24:18,710
for every program that we offered and

00:24:16,360 --> 00:24:21,080
the other interesting topics apart from

00:24:18,710 --> 00:24:23,090
what maps here is obviously the

00:24:21,080 --> 00:24:26,360
optimizations that we have to do and

00:24:23,090 --> 00:24:28,399
because um UPF was directed at 64-bit

00:24:26,360 --> 00:24:30,919
architectures so there there's some

00:24:28,399 --> 00:24:32,720
space for for doing optimizations and

00:24:30,919 --> 00:24:34,220
the most basic one that we have already

00:24:32,720 --> 00:24:37,490
talked about on the mailing list a

00:24:34,220 --> 00:24:41,570
little bit was is tracking which

00:24:37,490 --> 00:24:45,080
operations need only 32 bits of state as

00:24:41,570 --> 00:24:48,080
Nick said allow the embankment is is

00:24:45,080 --> 00:24:50,240
generating only 64 bit ALU operations

00:24:48,080 --> 00:24:52,510
today even when they are not needed so

00:24:50,240 --> 00:24:55,789
even if we are using you thirty two

00:24:52,510 --> 00:24:59,090
variables the back end will generate you

00:24:55,789 --> 00:25:01,760
42 will generate 64-bit operations and

00:24:59,090 --> 00:25:02,929
then basically mask out the upper parts

00:25:01,760 --> 00:25:04,880
of the registers which is really

00:25:02,929 --> 00:25:08,179
wasteful for 32-bit architecture such as

00:25:04,880 --> 00:25:11,419
ours and we would like to look at ways

00:25:08,179 --> 00:25:14,990
or basically converting that that back

00:25:11,419 --> 00:25:16,669
into 32-bit logic and the big question

00:25:14,990 --> 00:25:18,799
with this is whether we should try to do

00:25:16,669 --> 00:25:21,980
this in the kernel by extending the

00:25:18,799 --> 00:25:25,010
verifier or just trying to push the

00:25:21,980 --> 00:25:26,990
optimizations into our VM doing it in

00:25:25,010 --> 00:25:29,360
the Canaries has always obvious

00:25:26,990 --> 00:25:31,039
disadvantages but having more

00:25:29,360 --> 00:25:33,440
infrastructure for EBP in the corner

00:25:31,039 --> 00:25:38,240
will probably prove useful in the future

00:25:33,440 --> 00:25:40,429
so we have to decide if this is the cost

00:25:38,240 --> 00:25:43,820
that we are willing to pay doing it in

00:25:40,429 --> 00:25:45,710
the VM is simpler but on the other hand

00:25:43,820 --> 00:25:48,230
when we do something in the LLVM and

00:25:45,710 --> 00:25:50,059
then relate later loaded into kernel we

00:25:48,230 --> 00:25:52,990
can't really trust where the user space

00:25:50,059 --> 00:25:55,909
tells us so we have to perform some

00:25:52,990 --> 00:25:57,169
revalidation later and this validation

00:25:55,909 --> 00:25:58,630
since we don't have the kind of

00:25:57,169 --> 00:26:00,940
infrastructure very

00:25:58,630 --> 00:26:03,850
advanced at the moment would be very

00:26:00,940 --> 00:26:06,400
simple so probably if we do LLVM we

00:26:03,850 --> 00:26:09,010
would only be able to do a sort of all

00:26:06,400 --> 00:26:11,920
or nothing approach where the problem is

00:26:09,010 --> 00:26:14,770
either 32-bit or 64-bit only instead of

00:26:11,920 --> 00:26:19,540
doing the the logic basically per

00:26:14,770 --> 00:26:21,300
instruction so yeah that's that's

00:26:19,540 --> 00:26:26,050
something that we have to think about

00:26:21,300 --> 00:26:27,400
carefully there are simple optimizations

00:26:26,050 --> 00:26:30,760
that we are definitely looking to and

00:26:27,400 --> 00:26:33,340
some of them will be useful also for the

00:26:30,760 --> 00:26:36,850
hostage it's like basically the fact

00:26:33,340 --> 00:26:39,400
that we have our machine code is has

00:26:36,850 --> 00:26:42,010
three operands so the destination of

00:26:39,400 --> 00:26:45,430
current is explicit we can eliminate

00:26:42,010 --> 00:26:47,290
most of the moves in the EBP F and we

00:26:45,430 --> 00:26:49,840
think that if we do it in a generic way

00:26:47,290 --> 00:26:52,600
and probably some of the cost it's for

00:26:49,840 --> 00:26:54,880
are more for PowerPC and such could be

00:26:52,600 --> 00:26:56,430
able should be able to benefit from that

00:26:54,880 --> 00:26:59,050
as well

00:26:56,430 --> 00:27:00,370
we have also on the on the course we

00:26:59,050 --> 00:27:01,990
have some instructions which are

00:27:00,370 --> 00:27:05,020
optimized for packet processing like

00:27:01,990 --> 00:27:05,980
extracting fields from from headers but

00:27:05,020 --> 00:27:07,750
that should be a pretty easy

00:27:05,980 --> 00:27:10,150
optimization which we will definitely

00:27:07,750 --> 00:27:12,580
look into in the future and that's

00:27:10,150 --> 00:27:15,220
basically coming down to doing masks

00:27:12,580 --> 00:27:19,150
shifts and simple open ALU operations in

00:27:15,220 --> 00:27:22,120
in a single cycle on the target

00:27:19,150 --> 00:27:24,670
I obviously you have to look at doing

00:27:22,120 --> 00:27:27,370
some more advanced to register

00:27:24,670 --> 00:27:31,810
allocation for because we have well for

00:27:27,370 --> 00:27:34,060
registers on the device and using making

00:27:31,810 --> 00:27:37,120
better use of the memory architecture

00:27:34,060 --> 00:27:39,580
that we have which basically means doing

00:27:37,120 --> 00:27:42,100
some clever caching of the data that

00:27:39,580 --> 00:27:49,750
we're reading and now I will hand it

00:27:42,100 --> 00:27:52,420
back to Nick yeah me yeah just some

00:27:49,750 --> 00:27:55,600
housekeeping just to show this is real

00:27:52,420 --> 00:27:58,600
they have actually put some demos up so

00:27:55,600 --> 00:28:04,120
you can get to the demos by YouTube or

00:27:58,600 --> 00:28:06,040
also we have thank you we also have open

00:28:04,120 --> 00:28:07,570
an F peter org which is sort of our sort

00:28:06,040 --> 00:28:09,410
of open website where you can get the

00:28:07,570 --> 00:28:12,770
SDK so if you want to play around

00:28:09,410 --> 00:28:14,990
NFP itself and do things like that you

00:28:12,770 --> 00:28:17,090
can get all that up there there's also

00:28:14,990 --> 00:28:18,530
loads of webinars we had academics sort

00:28:17,090 --> 00:28:19,760
of doing stuff over the last year so

00:28:18,530 --> 00:28:21,890
there's loads of content up there if you

00:28:19,760 --> 00:28:25,850
want to check things out and then just

00:28:21,890 --> 00:28:30,170
just to conclude you know CLS BPF and

00:28:25,850 --> 00:28:31,250
xdp are awesome but we feel that we can

00:28:30,170 --> 00:28:33,950
take some of the things they're doing

00:28:31,250 --> 00:28:36,470
and push that out of the push that off

00:28:33,950 --> 00:28:40,160
cpu and basically save you a bit of

00:28:36,470 --> 00:28:42,830
money and increase the use of offload in

00:28:40,160 --> 00:28:44,090
good ways we believe this works a step

00:28:42,830 --> 00:28:46,550
in the right direction there's no that

00:28:44,090 --> 00:28:51,730
needs to be done still and that's pretty

00:28:46,550 --> 00:28:51,730
much all we have I think thanks everyone

00:28:56,890 --> 00:28:59,890
questions

00:29:04,660 --> 00:29:09,440
so the first question was wrecking by

00:29:07,160 --> 00:29:11,960
them if you want to get some to try out

00:29:09,440 --> 00:29:15,410
does it open in a funeral you can buy on

00:29:11,960 --> 00:29:17,720
that so you can think of a few there's a

00:29:15,410 --> 00:29:19,250
looser instructions there on how to get

00:29:17,720 --> 00:29:21,380
this base fuel up and running

00:29:19,250 --> 00:29:24,040
it's basically and end up leading to you

00:29:21,380 --> 00:29:27,140
emailing me for some firmware and stuff

00:29:24,040 --> 00:29:29,720
which isn't you know it's not production

00:29:27,140 --> 00:29:30,650
ready yet it's not there yet but yeah go

00:29:29,720 --> 00:29:33,170
on there

00:29:30,650 --> 00:29:34,549
grab some cards and we can talk and just

00:29:33,170 --> 00:29:40,400
basically you end up emailing me and

00:29:34,549 --> 00:29:42,110
we'll send you some stuff so first of

00:29:40,400 --> 00:29:45,110
all I think there's this world is super

00:29:42,110 --> 00:29:47,030
exciting it's not just not just the

00:29:45,110 --> 00:29:48,890
potential actually to have this sort of

00:29:47,030 --> 00:29:51,400
programmability what I really like about

00:29:48,890 --> 00:29:55,130
this is this is a great way to validate

00:29:51,400 --> 00:29:59,270
the portability of xtp so I really

00:29:55,130 --> 00:30:01,669
encourage to continue in that vent the

00:29:59,270 --> 00:30:03,710
question is have you looked at what it

00:30:01,669 --> 00:30:06,980
would take to support either a stateful

00:30:03,710 --> 00:30:09,710
or quasi state full offload so for

00:30:06,980 --> 00:30:11,960
instance something like LRO would be it

00:30:09,710 --> 00:30:13,130
seems like a perfect fit for this but

00:30:11,960 --> 00:30:14,750
obviously there's gonna be some

00:30:13,130 --> 00:30:17,470
idiosyncrasies about that have you

00:30:14,750 --> 00:30:17,470
thought through those

00:30:21,800 --> 00:30:28,560
so we thought about doing other NGO and

00:30:25,410 --> 00:30:30,000
we can definitely do that but that yeah

00:30:28,560 --> 00:30:33,030
I mean reusing basically the same

00:30:30,000 --> 00:30:36,870
infrastructure just as I said we when we

00:30:33,030 --> 00:30:40,080
do the image when you generate the code

00:30:36,870 --> 00:30:42,060
there is some parts of the of the agenda

00:30:40,080 --> 00:30:44,820
of the translator which are basically

00:30:42,060 --> 00:30:47,460
dependent on information that we read

00:30:44,820 --> 00:30:50,700
from the card so so the translator is

00:30:47,460 --> 00:30:52,050
basically ready from for using for

00:30:50,700 --> 00:30:55,080
generating code for different

00:30:52,050 --> 00:30:57,750
environments whether it's it's for XDP

00:30:55,080 --> 00:31:00,540
in CLS BPF whether it's going to be Dro

00:30:57,750 --> 00:31:05,330
so I think and if there is demand with

00:31:00,540 --> 00:31:05,330
good chips under gr Oh

00:31:09,539 --> 00:31:31,919
I mean this hog was almost designed for

00:31:28,950 --> 00:31:36,929
BPF it means yeah perfect npu for PPF

00:31:31,919 --> 00:31:38,429
yeah on the fly so 32-bit registers yeah

00:31:36,929 --> 00:31:40,259
yeah I mean the thing is that the

00:31:38,429 --> 00:31:41,970
programs don't really need the 64-bit

00:31:40,259 --> 00:31:44,489
logic I mean I think it's just the

00:31:41,970 --> 00:31:46,710
easiest way to do the sort of immediate

00:31:44,489 --> 00:31:49,710
representation in EVPs because the

00:31:46,710 --> 00:31:53,580
target calls are 64 bits so it just a 64

00:31:49,710 --> 00:31:56,399
bit and I already know like instructions

00:31:53,580 --> 00:31:59,820
with with carry in EBP F so you can't

00:31:56,399 --> 00:32:03,149
chain two 32-bit instructions to do a 64

00:31:59,820 --> 00:32:05,999
bit so did the default is doing always

00:32:03,149 --> 00:32:08,279
64 bit but when we look at the programs

00:32:05,999 --> 00:32:18,090
that they don't really need 64 bit logic

00:32:08,279 --> 00:32:20,789
like 99% of the time metadata for the

00:32:18,090 --> 00:32:21,929
packet and by also saying that you need

00:32:20,789 --> 00:32:29,099
to leave some Headroom

00:32:21,929 --> 00:32:33,899
so put the metadata for that yeah so we

00:32:29,099 --> 00:32:38,669
basically we had this design tin to the

00:32:33,899 --> 00:32:41,070
the the the the sort of receive path for

00:32:38,669 --> 00:32:42,299
a long time did there's a information in

00:32:41,070 --> 00:32:43,979
the descriptor the tell you how much

00:32:42,299 --> 00:32:46,649
metadata is prepended and then we also

00:32:43,979 --> 00:32:48,720
cover the farmer is telling the driver

00:32:46,649 --> 00:32:50,369
how much what's the maximum size of the

00:32:48,720 --> 00:32:52,919
metadata that can be prevented and then

00:32:50,369 --> 00:32:54,389
you can adjust your erics buffers so

00:32:52,919 --> 00:33:00,379
that you can always have the space for

00:32:54,389 --> 00:33:00,379
it like on the driver side so be ready

00:33:10,630 --> 00:33:18,590
anybody else right

00:33:16,490 --> 00:33:20,830
thank you very much thanks for listening

00:33:18,590 --> 00:33:20,830

YouTube URL: https://www.youtube.com/watch?v=-5BzT1ch19s


