Title: Netdev1.2 Using SR-IOV offloads with Open-vSwitch and similar applications - Rony Efraim, Or Gerlitz
Publication date: 2016-10-08
Playlist: Netdev 1.2 - Day 3 - Friday October 7, 2016
Description: 
	https://netdevconf.org/1.2/session.html?rony-efraim-1
Captions: 
	00:00:17,420 --> 00:00:28,279
I think this is the last session right

00:00:22,450 --> 00:00:31,509
so so again my name is only 5'4 Mellanox

00:00:28,279 --> 00:00:35,420
I'm already presented today things and

00:00:31,509 --> 00:00:39,800
now we want to go over how to if you

00:00:35,420 --> 00:00:43,429
remember all present the SLV awkward and

00:00:39,800 --> 00:00:48,410
how we can do it what the component that

00:00:43,429 --> 00:00:50,780
we had to the hardware sorry to the

00:00:48,410 --> 00:00:55,070
linux and now I want to show how we can

00:00:50,780 --> 00:00:57,710
use it and to do like a switch that is

00:00:55,070 --> 00:01:05,030
using it and kind of a switch we took us

00:00:57,710 --> 00:01:08,510
as the open V switch of course so I want

00:01:05,030 --> 00:01:14,899
to remind you what what we had so we add

00:01:08,510 --> 00:01:17,450
the basic basic stuff so we of course

00:01:14,899 --> 00:01:20,720
the representor one that's they act like

00:01:17,450 --> 00:01:24,100
a virtual port but this is the port of

00:01:20,720 --> 00:01:26,719
the switch the side of inside the switch

00:01:24,100 --> 00:01:33,770
in order to do the receive transmit

00:01:26,719 --> 00:01:35,990
packets counters doing state and of

00:01:33,770 --> 00:01:38,479
course the second thing that we need

00:01:35,990 --> 00:01:41,689
it's the flows so the Falls is done

00:01:38,479 --> 00:01:43,610
through TC so you can add the config the

00:01:41,689 --> 00:01:45,259
flow configuration you can do ACL you

00:01:43,610 --> 00:01:49,280
can do the forwarding anything that's

00:01:45,259 --> 00:01:52,070
needed and of course the same thing you

00:01:49,280 --> 00:01:54,500
use in order to read the counters you

00:01:52,070 --> 00:01:56,090
have a counters of course for each port

00:01:54,500 --> 00:01:58,789
what you need to have also hunters for

00:01:56,090 --> 00:02:03,140
flows if you want to do aging and those

00:01:58,789 --> 00:02:06,469
things kind of stuff and we already

00:02:03,140 --> 00:02:08,360
extended the TC interface to support the

00:02:06,469 --> 00:02:15,890
excellent so that's the building blocks

00:02:08,360 --> 00:02:21,890
that I'm going to use so again but here

00:02:15,890 --> 00:02:24,950
over the slow doctor passports

00:02:21,890 --> 00:02:31,150
can I can use the infrastructure that we

00:02:24,950 --> 00:02:33,500
build in order to have a switch so we

00:02:31,150 --> 00:02:37,450
behavior that if you don't have any

00:02:33,500 --> 00:02:42,050
folding wheels so we give this port

00:02:37,450 --> 00:02:44,330
sorry we give a pocket that is coming in

00:02:42,050 --> 00:02:47,110
the different does is to take it out to

00:02:44,330 --> 00:02:52,550
the to the main code to the main CPU and

00:02:47,110 --> 00:02:56,750
let the software process it so in order

00:02:52,550 --> 00:03:00,050
to process it we using of course the to

00:02:56,750 --> 00:03:02,720
represent the pockets have a Miss in the

00:03:00,050 --> 00:03:04,640
hardware go to the representor and then

00:03:02,720 --> 00:03:07,489
your presenter is giving to the software

00:03:04,640 --> 00:03:10,160
switch that decide how what to do with

00:03:07,489 --> 00:03:13,520
this pocket probably what he will do he

00:03:10,160 --> 00:03:17,180
will try to to find to look on his

00:03:13,520 --> 00:03:19,459
tables what need to be done and to try

00:03:17,180 --> 00:03:21,200
to populate it to the harder because the

00:03:19,459 --> 00:03:24,260
idea is to do it everything in the

00:03:21,200 --> 00:03:27,110
harbor so he will probably called the TC

00:03:24,260 --> 00:03:29,330
command in order to that then the

00:03:27,110 --> 00:03:34,580
following packet we will follow the

00:03:29,330 --> 00:03:36,920
harbor and he also be the send this

00:03:34,580 --> 00:03:38,540
packet of course on the representor port

00:03:36,920 --> 00:03:40,910
in order that the pocket that's go to

00:03:38,540 --> 00:03:50,630
the slope will continue on his way to

00:03:40,910 --> 00:03:53,890
the to his destination okay we editor

00:03:50,630 --> 00:03:56,420
flown into the into the hardware and

00:03:53,890 --> 00:03:58,820
what happened when you have a have your

00:03:56,420 --> 00:04:01,630
upload for that is that you don't have

00:03:58,820 --> 00:04:05,570
the card and you don't have any traffic

00:04:01,630 --> 00:04:08,959
in the on the slow path on the CPU so

00:04:05,570 --> 00:04:10,730
what if we will try to do the aging you

00:04:08,959 --> 00:04:12,350
look on the counters and the counters

00:04:10,730 --> 00:04:13,430
will see zero because they're not

00:04:12,350 --> 00:04:17,450
traffic in the harbor

00:04:13,430 --> 00:04:20,120
sorry they're not traffic in the on the

00:04:17,450 --> 00:04:22,729
on the software everything is going

00:04:20,120 --> 00:04:25,400
through the hardware so in order to do

00:04:22,729 --> 00:04:27,300
that we need to project to collect the

00:04:25,400 --> 00:04:30,150
counters have

00:04:27,300 --> 00:04:32,910
the hardware we use the TC in order to

00:04:30,150 --> 00:04:34,860
do that because this the same interface

00:04:32,910 --> 00:04:37,949
that we at the world this is the same

00:04:34,860 --> 00:04:41,550
interface that easily can get you the

00:04:37,949 --> 00:04:43,620
statistic of that and then of course we

00:04:41,550 --> 00:04:45,240
collect with the statistic usually a

00:04:43,620 --> 00:04:47,759
switch what we'll do a collect statistic

00:04:45,240 --> 00:04:52,759
every 30 seconds we'll see the one that

00:04:47,759 --> 00:04:58,379
has not been used and will age them and

00:04:52,759 --> 00:05:01,440
so that's how we use the statistics from

00:04:58,379 --> 00:05:03,030
the TC in order to do the aging and also

00:05:01,440 --> 00:05:08,819
counters if you want to debug and

00:05:03,030 --> 00:05:10,620
everything everything as we require the

00:05:08,819 --> 00:05:12,090
you we want to debug you want to see the

00:05:10,620 --> 00:05:35,699
traffic you want to see that everything

00:05:12,090 --> 00:05:38,250
is flowing and if it's not and we can't

00:05:35,699 --> 00:05:40,229
understand that there are sometimes need

00:05:38,250 --> 00:05:43,020
to be a policy not attack into the

00:05:40,229 --> 00:05:45,539
hardware because not every time you need

00:05:43,020 --> 00:05:49,860
to you want to take everything to the

00:05:45,539 --> 00:05:53,880
hardware and sometimes a pure policy

00:05:49,860 --> 00:05:58,590
decision like you want to say that's a

00:05:53,880 --> 00:06:01,500
specific flow you want to to limit this

00:05:58,590 --> 00:06:03,810
bandwidth to do to do any special things

00:06:01,500 --> 00:06:06,150
or even to debug you know what sometimes

00:06:03,810 --> 00:06:08,279
you want a special file to go to the

00:06:06,150 --> 00:06:10,590
through the through the kernel in order

00:06:08,279 --> 00:06:15,029
that you want to do to the Bible maybe

00:06:10,590 --> 00:06:17,310
to do a PCP dump on them even so this is

00:06:15,029 --> 00:06:22,620
a special cases sometimes are a policy

00:06:17,310 --> 00:06:24,779
that come from from the system that's

00:06:22,620 --> 00:06:27,300
want to do it and of course there are

00:06:24,779 --> 00:06:29,819
cases that's the hardware is not

00:06:27,300 --> 00:06:31,560
supporting things so the idea if the

00:06:29,819 --> 00:06:35,490
hardware is not supporting it of course

00:06:31,560 --> 00:06:36,050
we want to continue to work so what we

00:06:35,490 --> 00:06:38,840
are doing

00:06:36,050 --> 00:06:43,490
we're handling it in the software so the

00:06:38,840 --> 00:06:45,740
software will do the job this will give

00:06:43,490 --> 00:06:48,979
us a full solution that's in any case

00:06:45,740 --> 00:06:52,870
because some time even that we will be

00:06:48,979 --> 00:06:52,870
the best hardware for the current time

00:06:57,250 --> 00:07:06,039
and so the idea that we can in the

00:07:07,900 --> 00:08:10,580
environment so if we switch sorry and

00:08:07,699 --> 00:08:18,409
user part every pocket is coming to the

00:08:10,580 --> 00:08:20,990
kernel match defaulting the pocket into

00:08:18,409 --> 00:08:24,919
the actions if not the pocket is going

00:08:20,990 --> 00:08:27,529
to Union space for a very small path and

00:08:24,919 --> 00:08:30,620
then he can compare it to all the table

00:08:27,529 --> 00:08:32,779
the open flow table the the bridge

00:08:30,620 --> 00:08:37,269
configuration the macula in the spanning

00:08:32,779 --> 00:08:39,589
tree and all other configurations and

00:08:37,269 --> 00:08:41,810
decided what he is going to do with this

00:08:39,589 --> 00:08:43,860
pocket after he collect the information

00:08:41,810 --> 00:08:48,509
from all the

00:08:43,860 --> 00:08:52,249
and then we use the camel as a cache so

00:08:48,509 --> 00:08:54,689
easy for you get the same puppet again

00:08:52,249 --> 00:08:57,509
we know what you didn't to do is that we

00:08:54,689 --> 00:09:00,269
don't need to do to go all over the all

00:08:57,509 --> 00:09:08,430
the tables so the kind of the camel

00:09:00,269 --> 00:09:12,600
double is bring a cache what we we did

00:09:08,430 --> 00:09:16,319
with the obvious offload a hardware

00:09:12,600 --> 00:09:21,029
acceleration so we keep we keep the same

00:09:16,319 --> 00:09:26,249
idea but we have another layer below so

00:09:21,029 --> 00:09:28,620
this is the lower one so it's and we

00:09:26,249 --> 00:09:31,410
extend the same idea so the pocket is

00:09:28,620 --> 00:09:33,209
coming to the hard way if there are no

00:09:31,410 --> 00:09:36,480
match in the hardware it'll go to the

00:09:33,209 --> 00:09:39,149
care about the pop if it's not handling

00:09:36,480 --> 00:09:42,059
the Camerata path it's going to the user

00:09:39,149 --> 00:09:44,939
space and when the flow is configured

00:09:42,059 --> 00:09:48,720
from the we switch from the user space

00:09:44,939 --> 00:09:51,360
he can configure it to the data path of

00:09:48,720 --> 00:09:55,490
the colonel or even to do it to take a

00:09:51,360 --> 00:10:02,939
glory level inside to the hardware

00:09:55,490 --> 00:10:05,519
according to the policy how I'm going to

00:10:02,939 --> 00:10:09,360
accelerate it so again what we have

00:10:05,519 --> 00:10:11,639
which we have the same model of open

00:10:09,360 --> 00:10:15,019
with which the user get they have the

00:10:11,639 --> 00:10:17,850
same experience he use the same tools

00:10:15,019 --> 00:10:21,029
everything is the same he have an open

00:10:17,850 --> 00:10:24,180
flow support he have all the options

00:10:21,029 --> 00:10:27,540
talk everything is working the same she

00:10:24,180 --> 00:10:33,029
used to but you get the hardware

00:10:27,540 --> 00:10:42,360
acceleration for that we already have a

00:10:33,029 --> 00:10:45,029
better for that them of course on you

00:10:42,360 --> 00:10:45,750
but don't have it right now and we have

00:10:45,029 --> 00:10:51,209
a very

00:10:45,750 --> 00:10:53,129
performance numbers so our performing

00:10:51,209 --> 00:10:56,250
some that we are using for the excellent

00:10:53,129 --> 00:11:00,740
we do a vehicle an encapsulation for the

00:10:56,250 --> 00:11:04,110
traffic and you have about 25 or 30

00:11:00,740 --> 00:11:09,149
million packets per second without any

00:11:04,110 --> 00:11:10,769
CPU that is needed to know to do that so

00:11:09,149 --> 00:11:15,449
we feel campaign because the cooperation

00:11:10,769 --> 00:11:18,720
we come the the one that we are

00:11:15,449 --> 00:11:22,470
comparing to is a is a DP decay it's not

00:11:18,720 --> 00:11:25,620
a Linux yeah we know but we compare it

00:11:22,470 --> 00:11:28,769
to the DPD k open V switch and we got a

00:11:25,620 --> 00:11:31,620
much better performance with zero CPU

00:11:28,769 --> 00:11:35,699
because usually a DP decay of the S is

00:11:31,620 --> 00:11:39,600
for a using a more coarse in order to

00:11:35,699 --> 00:11:42,300
afford 10 or 15 million packet per

00:11:39,600 --> 00:11:45,860
second and we get another double than

00:11:42,300 --> 00:11:50,639
that and without any code that's

00:11:45,860 --> 00:11:52,860
required to do that and the server can

00:11:50,639 --> 00:11:54,839
use those phone calls extra cost in

00:11:52,860 --> 00:11:58,110
other took Janet to have another VM

00:11:54,839 --> 00:12:04,889
that's more than a single VM with 4

00:11:58,110 --> 00:12:09,110
cores so this is the the performance

00:12:04,889 --> 00:12:14,699
that we are having things are very nice

00:12:09,110 --> 00:12:18,899
and of course in order to do that this

00:12:14,699 --> 00:12:23,000
is a rollers we we need to check to make

00:12:18,899 --> 00:12:23,000
a little bit change of the open V switch

00:12:23,420 --> 00:12:28,740
this is the internal structure what is

00:12:26,160 --> 00:12:33,059
not colored this is the current

00:12:28,740 --> 00:12:37,790
structure of the open V switch and we

00:12:33,059 --> 00:12:42,660
want to use the same invite the same

00:12:37,790 --> 00:12:47,490
without extending any any block of open

00:12:42,660 --> 00:12:49,570
V switch to do it just use the same

00:12:47,490 --> 00:12:54,390
imply so what

00:12:49,570 --> 00:12:58,030
we did we have the blue box that is an

00:12:54,390 --> 00:13:02,800
internal level of obvious it's called a

00:12:58,030 --> 00:13:04,810
dpi F provider so what we did we have a

00:13:02,800 --> 00:13:07,750
new deeper provider a hardware

00:13:04,810 --> 00:13:10,210
acceleration provider that is consulting

00:13:07,750 --> 00:13:14,170
the policy what you do if to har would

00:13:10,210 --> 00:13:16,360
be awkward it or not and if it decided

00:13:14,170 --> 00:13:21,040
to harbor offload it then you go through

00:13:16,360 --> 00:13:23,020
the TC API and configured the hardware

00:13:21,040 --> 00:13:27,370
with a skip software this is the concept

00:13:23,020 --> 00:13:32,650
of a TC and if not he is using the old

00:13:27,370 --> 00:13:34,810
epi F that's the different one the DPI F

00:13:32,650 --> 00:13:40,060
net link that is currently used in order

00:13:34,810 --> 00:13:42,460
to configure the camera data pop in and

00:13:40,060 --> 00:13:45,850
in that way we have a very very thin

00:13:42,460 --> 00:13:52,540
layer just is reusing all the current

00:13:45,850 --> 00:13:54,160
code and and not harming and any any of

00:13:52,540 --> 00:13:59,770
this which implementation that is not

00:13:54,160 --> 00:14:01,000
needed the hardware of a new already is

00:13:59,770 --> 00:14:04,420
submit an RFC

00:14:01,000 --> 00:14:08,470
almost a week ago and we have some

00:14:04,420 --> 00:14:15,300
discussion of that of course but we

00:14:08,470 --> 00:14:15,300
didn't got any painful objection

00:14:23,000 --> 00:14:36,240
that's all any thought ideas comment so

00:14:33,899 --> 00:14:37,980
the whole field through TC to look at

00:14:36,240 --> 00:14:39,630
the hardware off the rules for the aging

00:14:37,980 --> 00:14:43,040
out how long does that scale of you're a

00:14:39,630 --> 00:14:43,040
very large number of rules

00:14:45,260 --> 00:14:52,680
thank you better we didn't easy

00:14:49,830 --> 00:14:57,750
interface but now we know that we need

00:14:52,680 --> 00:15:02,300
to to see how the TC is functioning

00:14:57,750 --> 00:15:07,860
because we our customers are looking for

00:15:02,300 --> 00:15:10,350
ten thousand rules per second for should

00:15:07,860 --> 00:15:14,070
the PC interface work we I think we did

00:15:10,350 --> 00:15:17,640
some tests to see that Minh rules per

00:15:14,070 --> 00:15:19,380
second it's working very well that could

00:15:17,640 --> 00:15:21,990
be that's when we will scale out you see

00:15:19,380 --> 00:15:24,570
that do we have some performance issue

00:15:21,990 --> 00:15:30,660
and so we need to test it of course we

00:15:24,570 --> 00:15:34,350
understand that and we think about other

00:15:30,660 --> 00:15:36,410
options if they require to to extend the

00:15:34,350 --> 00:15:39,209
performance maybe to do bulking or maybe

00:15:36,410 --> 00:15:41,390
others optimization that need to be done

00:15:39,209 --> 00:15:41,390
there

00:15:46,750 --> 00:15:53,060
so this might be a little I guess

00:15:49,910 --> 00:15:55,700
off-topic for you but it looks like this

00:15:53,060 --> 00:15:58,820
is pretty generic in terms of an offload

00:15:55,700 --> 00:16:01,040
interface right one of the interesting

00:15:58,820 --> 00:16:04,160
things we could do and hopefully

00:16:01,040 --> 00:16:09,040
somebody will will figure this out if we

00:16:04,160 --> 00:16:12,050
move the similar functionality and xtp

00:16:09,040 --> 00:16:14,660
have OVS offload I guess they'll be on

00:16:12,050 --> 00:16:18,920
load into xtp then that might be an

00:16:14,660 --> 00:16:21,459
interesting comparison versus DP DK just

00:16:18,920 --> 00:16:24,620
a thought I think we're there vmware guy

00:16:21,459 --> 00:16:26,890
might be an interesting project to do in

00:16:24,620 --> 00:16:26,890
the future

00:16:27,370 --> 00:16:34,070
yes again this is a different approach

00:16:30,110 --> 00:16:37,279
because he the main the hosts don't see

00:16:34,070 --> 00:16:39,050
the pocket and husband doesn't see the

00:16:37,279 --> 00:16:40,279
packet in xvp either I think I think

00:16:39,050 --> 00:16:44,269
that's one of the things we glossed over

00:16:40,279 --> 00:16:49,430
no you still get a pocket that is coming

00:16:44,269 --> 00:16:51,769
and you need the xdp to to work on it a

00:16:49,430 --> 00:16:58,550
little bit and to for the pocket to the

00:16:51,769 --> 00:17:00,380
VM and approach you have a zero I think

00:16:58,550 --> 00:17:04,669
the point is that if you made an

00:17:00,380 --> 00:17:07,160
odourless to x DP fast path and an x DP

00:17:04,669 --> 00:17:12,770
too hard or fast path you would kind of

00:17:07,160 --> 00:17:16,549
get this for free it doesn't seem to

00:17:12,770 --> 00:17:18,110
make sense for this case right so you

00:17:16,549 --> 00:17:22,600
are asking you to put all the flaws

00:17:18,110 --> 00:17:22,600
basically in x DP which sounds strange

00:17:24,449 --> 00:17:34,019
with its another approach you know you

00:17:29,159 --> 00:17:35,460
not utilize the hardware you could you

00:17:34,019 --> 00:17:36,299
could put the switch in there and put

00:17:35,460 --> 00:17:38,179
all the flaws

00:17:36,299 --> 00:17:40,950
how many flows do you have in there

00:17:38,179 --> 00:17:43,679
Millions okay so now you have millions

00:17:40,950 --> 00:17:46,009
of flowers in XTP not sure if that's the

00:17:43,679 --> 00:17:46,009
right approach

00:17:52,580 --> 00:18:03,240
you also Dex VPN to the hardware

00:17:55,110 --> 00:18:05,070
afterwards right XDP this is a standard

00:18:03,240 --> 00:18:11,659
silicon it's not been named a

00:18:05,070 --> 00:18:17,490
multiprocessor one there's not associate

00:18:11,659 --> 00:18:21,600
it's a standard NIC so the same works

00:18:17,490 --> 00:18:23,850
also for therefore the Intel guys the

00:18:21,600 --> 00:18:28,860
same concept you don't need to have SOC

00:18:23,850 --> 00:18:31,139
that's can do the EBP a powerful it's

00:18:28,860 --> 00:18:32,610
just the same problem we had earlier

00:18:31,139 --> 00:18:34,470
right it's a fixed ASIC and you're

00:18:32,610 --> 00:18:36,379
trying to take a EBP F instruction set

00:18:34,470 --> 00:18:38,429
down to it it's quite a challenging task

00:18:36,379 --> 00:18:42,960
but for a lot of folks it doesn't make

00:18:38,429 --> 00:18:48,779
it the IEP f12 they MP or something then

00:18:42,960 --> 00:18:50,220
I think it makes perfect sense so right

00:18:48,779 --> 00:18:51,870
from the audience perspective looking at

00:18:50,220 --> 00:18:53,279
this where does this module in the

00:18:51,870 --> 00:18:56,700
middle that figures out it can also do

00:18:53,279 --> 00:18:58,860
something else I mean if there's a xdp

00:18:56,700 --> 00:19:00,899
thing that sits there in the same model

00:18:58,860 --> 00:19:04,519
it could do that but it wouldn't be flow

00:19:00,899 --> 00:19:07,169
this would be obviously but this kind of

00:19:04,519 --> 00:19:11,070
states with the hardware the Hellenic

00:19:07,169 --> 00:19:13,080
says the same approach could be used for

00:19:11,070 --> 00:19:15,509
for offloading to other places I mean

00:19:13,080 --> 00:19:17,850
proposes a policy gone true for how to

00:19:15,509 --> 00:19:20,600
offload things and there may be the xep

00:19:17,850 --> 00:19:20,600
thing happens I know

00:19:23,010 --> 00:19:29,440
I'm not saying you couldn't do it I'm

00:19:25,240 --> 00:19:31,900
just saying that this Hydra can can do

00:19:29,440 --> 00:19:37,350
it ten times faster with ten times more

00:19:31,900 --> 00:19:41,590
flows piece of hardware would do better

00:19:37,350 --> 00:19:43,870
by current yeah do we need some sort of

00:19:41,590 --> 00:19:50,500
lookup functions or tecum equivalents in

00:19:43,870 --> 00:19:52,060
in a BPF yeah it can it can do it will

00:19:50,500 --> 00:19:54,730
be about ten times smaller with ten

00:19:52,060 --> 00:19:57,700
times less the flows you take a concept

00:19:54,730 --> 00:19:59,800
like a table concept or something that

00:19:57,700 --> 00:20:04,030
is networking concept you want to

00:19:59,800 --> 00:20:07,060
compile it to an EVP F but the habibi PF

00:20:04,030 --> 00:20:10,540
the harbor's can do pack classification

00:20:07,060 --> 00:20:12,280
for doing other actions so the way this

00:20:10,540 --> 00:20:16,960
we want to optimize the others to do

00:20:12,280 --> 00:20:20,050
their EVP F is missing nothing just like

00:20:16,960 --> 00:20:22,150
you know I don't know 8086 isn't missing

00:20:20,050 --> 00:20:24,640
anything right yeah if you could retire

00:20:22,150 --> 00:20:27,060
100 BPF instructions for flops or maybe

00:20:24,640 --> 00:20:30,130
you could do this but what you need is a

00:20:27,060 --> 00:20:31,960
256 wide that match instruction and ebps

00:20:30,130 --> 00:20:35,980
then you can start doing stuff that's at

00:20:31,960 --> 00:20:36,910
the speed that you need to do it but

00:20:35,980 --> 00:20:38,710
that's kind of my point

00:20:36,910 --> 00:20:40,810
maybe we need higher level primitives in

00:20:38,710 --> 00:20:43,480
vpf like what you can imagine

00:20:40,810 --> 00:20:46,420
I'll put it very simply there's no in

00:20:43,480 --> 00:20:52,750
hell you can beat this static functions

00:20:46,420 --> 00:20:54,550
that exist in this ASIC with x DP you

00:20:52,750 --> 00:20:58,150
can find another piece of hardware yeah

00:20:54,550 --> 00:21:02,530
this snake is too advanced for to

00:20:58,150 --> 00:21:07,000
replace with x DP it has the exact

00:21:02,530 --> 00:21:08,380
functions needed I think it's a question

00:21:07,000 --> 00:21:11,530
figuring out what the right thing

00:21:08,380 --> 00:21:13,450
primitives are flux field is different

00:21:11,530 --> 00:21:16,780
this has fixed functions that are needed

00:21:13,450 --> 00:21:18,370
for this feature right so what I'm

00:21:16,780 --> 00:21:19,960
saying is this thing has fixed functions

00:21:18,370 --> 00:21:22,150
and it's awesome it's super fast it can

00:21:19,960 --> 00:21:23,410
do it can do stuffs of EBP F will never

00:21:22,150 --> 00:21:25,780
be able to match because it's running

00:21:23,410 --> 00:21:27,610
8086 instruction sets and you can't

00:21:25,780 --> 00:21:29,660
retire 100 EBP F instructions per clock

00:21:27,610 --> 00:21:32,990
so you can't go as fast as this thing

00:21:29,660 --> 00:21:35,570
but important if you had any Bab bps the

00:21:32,990 --> 00:21:37,520
ability to do what @e cam can do then

00:21:35,570 --> 00:21:40,190
suddenly you can do this stuff but you

00:21:37,520 --> 00:21:41,960
can do the like the like the well

00:21:40,190 --> 00:21:43,490
business logic or whatever you can

00:21:41,960 --> 00:21:45,770
actually have the control flow be any

00:21:43,490 --> 00:21:47,660
BPF program and you can do the superfast

00:21:45,770 --> 00:21:49,460
hardware stuff by just delegating that

00:21:47,660 --> 00:21:54,350
to the hardware and so you can build a

00:21:49,460 --> 00:21:55,580
hybrid right so I think it makes sense I

00:21:54,350 --> 00:21:56,960
mean xt p is pretty early and we're

00:21:55,580 --> 00:21:59,420
still working out the infrastructure but

00:21:56,960 --> 00:22:02,690
it makes sense to at some point look at

00:21:59,420 --> 00:22:06,920
optimizations like the 256 bit registers

00:22:02,690 --> 00:22:10,450
and hardware intrinsic you know that we

00:22:06,920 --> 00:22:12,680
could add to something like e BPF i

00:22:10,450 --> 00:22:15,020
think that would be a good direction and

00:22:12,680 --> 00:22:16,670
you probably could get quite a bit of

00:22:15,020 --> 00:22:19,430
improvement over the existing e BPF

00:22:16,670 --> 00:22:21,160
programs if you started to look at you

00:22:19,430 --> 00:22:23,480
know kind of other instructions

00:22:21,160 --> 00:22:24,800
intrinsics and wide you know wide

00:22:23,480 --> 00:22:27,740
instructions and stuff like that for

00:22:24,800 --> 00:22:29,060
sure and close that close that gap and

00:22:27,740 --> 00:22:34,040
keep the flexibility I think that would

00:22:29,060 --> 00:22:35,210
be quick and a good good experiment to

00:22:34,040 --> 00:22:37,340
go and run and see how close it can

00:22:35,210 --> 00:22:39,560
actually get I mean you're going to end

00:22:37,340 --> 00:22:41,540
up with a lot of duplication of effort

00:22:39,560 --> 00:22:44,480
here between different vendors trying to

00:22:41,540 --> 00:22:47,440
implement similar awful mechanisms or

00:22:44,480 --> 00:22:50,300
other chips with slightly different

00:22:47,440 --> 00:22:54,200
architectures right and if we just had

00:22:50,300 --> 00:22:59,680
one mechanism to offload this into an XT

00:22:54,200 --> 00:22:59,680
PE BPF like sufficiently generic syntax

00:23:01,570 --> 00:23:05,750
we have two modes we have the

00:23:04,040 --> 00:23:07,850
instruction set mode and then we have

00:23:05,750 --> 00:23:10,730
the fixed ASIC mode and I have a really

00:23:07,850 --> 00:23:12,940
hard time trying to wrap my head around

00:23:10,730 --> 00:23:15,350
how those two can be merged into one

00:23:12,940 --> 00:23:19,720
high-level language it's been tried and

00:23:15,350 --> 00:23:22,250
failed in various forums for years I

00:23:19,720 --> 00:23:24,110
think the pragmatic way to resolve it is

00:23:22,250 --> 00:23:25,280
to have two modes a fixed basic mode

00:23:24,110 --> 00:23:27,200
that all the fixed dates that guys have

00:23:25,280 --> 00:23:29,990
to use and then an instruction based

00:23:27,200 --> 00:23:32,150
mode that the NPU and the x86 and

00:23:29,990 --> 00:23:34,040
PowerPC sees and arms the world can use

00:23:32,150 --> 00:23:36,410
I think you can look at it as kind of

00:23:34,040 --> 00:23:39,290
you first do fixed level matching that

00:23:36,410 --> 00:23:40,550
is like tecum implementable and only

00:23:39,290 --> 00:23:43,280
then do you run the

00:23:40,550 --> 00:23:45,290
the fixed instructions afterwards but as

00:23:43,280 --> 00:23:47,090
input to those fixed instructions you

00:23:45,290 --> 00:23:50,780
kind of already has information about

00:23:47,090 --> 00:23:52,640
which rule from the Tcat matched which

00:23:50,780 --> 00:23:55,580
potentially allows you to eliminate a

00:23:52,640 --> 00:23:57,500
large part of the parsing in the BPF

00:23:55,580 --> 00:24:00,140
yeah there's another actually there's

00:23:57,500 --> 00:24:01,550
some there's a few prototypes have seen

00:24:00,140 --> 00:24:03,110
for this actually where they use the

00:24:01,550 --> 00:24:05,090
hardware as a front-end parser for the

00:24:03,110 --> 00:24:06,850
back for the backend x86 so the x86

00:24:05,090 --> 00:24:09,380
doesn't have actually doing it parsing

00:24:06,850 --> 00:24:10,370
this scheme is not specific to x86 I

00:24:09,380 --> 00:24:12,650
take that work for any sort of

00:24:10,370 --> 00:24:14,000
construction based system where where

00:24:12,650 --> 00:24:15,590
you use a hydro pressure that can do

00:24:14,000 --> 00:24:16,880
everything in a couple cycles or clocks

00:24:15,590 --> 00:24:18,110
or whatever and then it comes into the

00:24:16,880 --> 00:24:20,270
system with the tag that tells you

00:24:18,110 --> 00:24:23,960
exactly what the what the packet is and

00:24:20,270 --> 00:24:26,780
then you have the flexibility to append

00:24:23,960 --> 00:24:30,170
you're kind of more flexible engine that

00:24:26,780 --> 00:24:33,590
lives behind this so those schemes exist

00:24:30,170 --> 00:24:35,570
it's just whether or not they fit what

00:24:33,590 --> 00:24:39,050
you mentioned it's not like you folding

00:24:35,570 --> 00:24:41,990
all not oscillating all the forwarding

00:24:39,050 --> 00:24:43,850
what do you mean you take the folding

00:24:41,990 --> 00:24:46,460
stuff that you can do in the silicon or

00:24:43,850 --> 00:24:49,460
the parsing all those kind of thing and

00:24:46,460 --> 00:24:51,530
give you a flow ID and then you do the

00:24:49,460 --> 00:24:52,700
action of a forwarding in this office I

00:24:51,530 --> 00:24:54,200
think that's the model I mean that's the

00:24:52,700 --> 00:24:56,060
model that you're doing here I think

00:24:54,200 --> 00:24:58,510
I'll go pointing now maybe is that our

00:24:56,060 --> 00:25:02,000
other models of doing this reprocessing

00:24:58,510 --> 00:25:03,500
one being that the hardware can provide

00:25:02,000 --> 00:25:05,380
hints to the software and the software

00:25:03,500 --> 00:25:08,240
can use those hints yes so this

00:25:05,380 --> 00:25:10,310
presented last negative conference the

00:25:08,240 --> 00:25:12,290
the same approach but this is a

00:25:10,310 --> 00:25:17,450
different approach we want to offload

00:25:12,290 --> 00:25:19,279
all understand that

00:25:17,450 --> 00:25:21,470
because you are offloading all of it but

00:25:19,279 --> 00:25:26,029
it's not generic to over hardware right

00:25:21,470 --> 00:25:28,429
and why not because if I take my random

00:25:26,029 --> 00:25:30,200
NIC that I have that does 10 gigabits it

00:25:28,429 --> 00:25:31,580
doesn't have this architecture and it

00:25:30,200 --> 00:25:34,549
doesn't have this driver and all this

00:25:31,580 --> 00:25:36,679
logic in it and I can run normal Linux

00:25:34,549 --> 00:25:44,059
on it and it works just fine but I can't

00:25:36,679 --> 00:25:45,799
get off load like this how do I pull for

00:25:44,059 --> 00:25:49,789
kind of a switch because if you take

00:25:45,799 --> 00:25:55,190
like an and I think John and imperial

00:25:49,789 --> 00:25:57,169
make the 40 gig also suppose that's

00:25:55,190 --> 00:25:59,539
support a similar model it's just it's a

00:25:57,169 --> 00:26:02,419
common architecture follow these sneaks

00:25:59,539 --> 00:26:04,010
that do offloads well if it's common

00:26:02,419 --> 00:26:06,679
architecture then we should have common

00:26:04,010 --> 00:26:09,860
support for it that's what is showing

00:26:06,679 --> 00:26:13,279
I think metronome also support kind of

00:26:09,860 --> 00:26:15,919
thing I think the different API not the

00:26:13,279 --> 00:26:17,779
TC but they're also optimizing for

00:26:15,919 --> 00:26:20,080
specific functions only there's a few

00:26:17,779 --> 00:26:23,929
functions exposed that everybody has

00:26:20,080 --> 00:26:29,330
right then those few functions should be

00:26:23,929 --> 00:26:32,570
somewhere in the VPS logic available but

00:26:29,330 --> 00:26:37,490
VP visa is one approach yeah why not

00:26:32,570 --> 00:26:38,809
before why not other TC because because

00:26:37,490 --> 00:26:40,730
we're just ending up with too much of

00:26:38,809 --> 00:26:42,409
this it's it's hard to wrap your head

00:26:40,730 --> 00:26:46,370
around all the different mechanisms it's

00:26:42,409 --> 00:26:48,889
hard to program why do we not write the

00:26:46,370 --> 00:26:51,200
kernel in Java C C++ and C sharp in

00:26:48,889 --> 00:26:52,669
Objective C because nobody wants to

00:26:51,200 --> 00:26:54,350
learn five different languages to do

00:26:52,669 --> 00:26:56,960
kernel programming right so this is

00:26:54,350 --> 00:27:00,380
basically the same thing you kind of

00:26:56,960 --> 00:27:04,070
want to make everything generic to one

00:27:00,380 --> 00:27:10,399
specific interface not to five different

00:27:04,070 --> 00:27:13,630
interfaces okay not the necklace neck in

00:27:10,399 --> 00:27:13,630
native language for other

00:27:15,990 --> 00:27:23,250
so um it's almost sex and I think we're

00:27:18,840 --> 00:27:24,840
at holding a little bit look the

00:27:23,250 --> 00:27:26,100
operating system comment is true but

00:27:24,840 --> 00:27:28,200
there are different operating systems

00:27:26,100 --> 00:27:31,560
and there's going to be different

00:27:28,200 --> 00:27:33,780
implementations of this so my only my

00:27:31,560 --> 00:27:36,570
only point here is as long as something

00:27:33,780 --> 00:27:38,370
like this is an open architecture as

00:27:36,570 --> 00:27:40,290
long as if I want to add say a new

00:27:38,370 --> 00:27:42,570
protocol I don't have to go out and buy

00:27:40,290 --> 00:27:45,120
a new hardware to support that if it's

00:27:42,570 --> 00:27:47,460
open and programmable we're going to

00:27:45,120 --> 00:27:49,760
have different models of this and again

00:27:47,460 --> 00:27:52,260
if you look at the the offload model as

00:27:49,760 --> 00:27:54,900
long as this is truly offloading

00:27:52,260 --> 00:27:57,030
something that was done in the Coronel

00:27:54,900 --> 00:28:00,990
are now being done in the hardware which

00:27:57,030 --> 00:28:03,600
OBS says I think it fits the model that

00:28:00,990 --> 00:28:06,960
were aspiring to trying to force

00:28:03,600 --> 00:28:08,850
everything into a BPF model you know

00:28:06,960 --> 00:28:11,100
it's like Janelle said that's that's not

00:28:08,850 --> 00:28:13,530
necessarily easy and I don't think we

00:28:11,100 --> 00:28:15,300
need to try to do that we're gonna have

00:28:13,530 --> 00:28:18,120
different use cases for different things

00:28:15,300 --> 00:28:20,850
and I said it before and I'll say it

00:28:18,120 --> 00:28:23,070
again the host is not a switch and here

00:28:20,850 --> 00:28:24,450
we are definitely take advantage of a

00:28:23,070 --> 00:28:27,420
switch capability it'd be great to have

00:28:24,450 --> 00:28:30,270
that in BPF but I don't think we can at

00:28:27,420 --> 00:28:32,190
this point try to force that model

00:28:30,270 --> 00:28:33,480
across the board we are going to have p4

00:28:32,190 --> 00:28:36,750
we're going to apparently over yes

00:28:33,480 --> 00:28:39,060
probably a few others and BPF over time

00:28:36,750 --> 00:28:41,010
maybe these converged but I think this

00:28:39,060 --> 00:28:43,230
discussion is is too early to have

00:28:41,010 --> 00:28:48,860
whether or not we can convert everything

00:28:43,230 --> 00:28:48,860
to one one super uber offload model

00:28:51,020 --> 00:29:48,970
we're running out of time all right yeah

00:30:11,140 --> 00:30:43,550
today we're in this 64,000 I mean to

00:30:41,240 --> 00:30:48,410
turn you to point what he was saying he

00:30:43,550 --> 00:30:53,360
tried put 64,000 in DB in xdp or we get

00:30:48,410 --> 00:30:55,870
a magnitude less per second that was a

00:30:53,360 --> 00:30:55,870
point I guess

00:30:56,890 --> 00:31:01,570
I didn't mean to make it to I don't

00:31:00,190 --> 00:31:03,480
think anyone's disputing that this would

00:31:01,570 --> 00:31:07,000
be a slow in software

00:31:03,480 --> 00:31:12,760
obviously it's just that it could then

00:31:07,000 --> 00:31:17,980
be offloaded right into steps is there's

00:31:12,760 --> 00:31:25,830
no real API to XDP this right something

00:31:17,980 --> 00:31:25,830

YouTube URL: https://www.youtube.com/watch?v=r043RtJn0CM


