Title: Netdev 0x12 - Netfilter mini-workshop
Publication date: 2018-07-31
Playlist: Netdev 0x12 - Day 1 - Jul 11 2018
Description: 
	Pablo Neira Ayuso chaired at Netdev 0x12 in Montreal on July 11th, 2018 in a mini netfilter workshop session with face to face discussions on different netfilter topics.

More info:
https://www.netdevconf.org/0x12/session.html?netfilter-mini-workshop
Captions: 
	00:00:01,760 --> 00:00:08,519
hi yes okay so um welcome everyone to

00:00:07,830 --> 00:00:11,070
the netfilter

00:00:08,519 --> 00:00:12,660
mini workshop so it's going to be me

00:00:11,070 --> 00:00:15,269
that is going to be talking all the time

00:00:12,660 --> 00:00:18,449
so while I try to pull some people in

00:00:15,269 --> 00:00:20,369
during the discussions too so well my

00:00:18,449 --> 00:00:27,740
name is Pablo for those that don't know

00:00:20,369 --> 00:00:32,040
me and I'm the Builder maintainer so I

00:00:27,740 --> 00:00:34,620
got to make a quick summary of what has

00:00:32,040 --> 00:00:37,380
happened in netfilter in the last six

00:00:34,620 --> 00:00:40,410
months since the last net web conference

00:00:37,380 --> 00:00:41,910
and then I will make also a summary of

00:00:40,410 --> 00:00:46,079
what has happened in the net photo

00:00:41,910 --> 00:00:50,250
workshop that we that we had just weeks

00:00:46,079 --> 00:00:53,010
ago idiom in Germany and also I'm going

00:00:50,250 --> 00:00:55,440
to make another pass on top of the flow

00:00:53,010 --> 00:00:58,140
table bypass support that was discussed

00:00:55,440 --> 00:01:01,980
in the previous conference but got

00:00:58,140 --> 00:01:04,559
matched up stream back in January so

00:01:01,980 --> 00:01:07,710
it's been already awhile and we got some

00:01:04,559 --> 00:01:09,840
changes on that front and some and also

00:01:07,710 --> 00:01:14,909
I'm going to take a bit of time on on

00:01:09,840 --> 00:01:18,630
the RFC that Stefan and me sent as I

00:01:14,909 --> 00:01:21,330
joined work basically to combine the

00:01:18,630 --> 00:01:26,820
idea of the flow table with the GRL

00:01:21,330 --> 00:01:33,799
engine to to provide a new fast

00:01:26,820 --> 00:01:41,670
forwarding path so so what happened

00:01:33,799 --> 00:01:47,399
upstream in the meantime so we're gonna

00:01:41,670 --> 00:01:50,210
we got a patch to speed up X tables rule

00:01:47,399 --> 00:01:54,570
set updates basically using a new

00:01:50,210 --> 00:01:57,200
locking approach it's something that

00:01:54,570 --> 00:02:04,909
basically is improving performance for

00:01:57,200 --> 00:02:09,000
improving rules a long time for all the

00:02:04,909 --> 00:02:11,280
IP tables basically for IP tables ip6

00:02:09,000 --> 00:02:12,319
tables eb tables ARP tables everyone

00:02:11,280 --> 00:02:15,590
that is using the

00:02:12,319 --> 00:02:18,170
Abell interface we also got lots of

00:02:15,590 --> 00:02:21,019
sanitization fixes one other thing think

00:02:18,170 --> 00:02:25,120
that didn't happen - to the X tables

00:02:21,019 --> 00:02:27,889
interface is that by when it was written

00:02:25,120 --> 00:02:31,549
it was supposed to be always behind the

00:02:27,889 --> 00:02:35,030
the net I mean curtain but that changed

00:02:31,549 --> 00:02:39,469
once we got all this infrastructure

00:02:35,030 --> 00:02:42,139
called leverage by but name is basis

00:02:39,469 --> 00:02:46,639
right so it specifically user name

00:02:42,139 --> 00:02:50,299
spaces so now I mean basically we've

00:02:46,639 --> 00:02:53,299
been discovering a long time along the

00:02:50,299 --> 00:02:55,459
last last years that there were not

00:02:53,299 --> 00:02:57,379
sufficient sufficient sanitization in

00:02:55,459 --> 00:02:59,359
that interface we've got fixes to

00:02:57,379 --> 00:03:03,439
improve that situation many of the

00:02:59,359 --> 00:03:06,859
existing robots that are basically

00:03:03,439 --> 00:03:08,359
searching for creating malformed blobs

00:03:06,859 --> 00:03:10,879
are out push into the kernel has been

00:03:08,359 --> 00:03:12,859
also helping a lot in that front so we

00:03:10,879 --> 00:03:16,669
also remove a defensive check that we

00:03:12,859 --> 00:03:18,949
have had in net filter actually since

00:03:16,669 --> 00:03:20,840
basically the beginning of it so it's

00:03:18,949 --> 00:03:24,349
code that has been there for almost 20

00:03:20,840 --> 00:03:26,329
years and it was checking for malformed

00:03:24,349 --> 00:03:29,840
ipv4 header and that was not possible

00:03:26,329 --> 00:03:31,489
you know anymore because since 2011

00:03:29,840 --> 00:03:34,159
there is a patch that is basically not

00:03:31,489 --> 00:03:37,280
allowing to inject malformed ipv4

00:03:34,159 --> 00:03:39,560
packets from the front row of sockets so

00:03:37,280 --> 00:03:42,280
it is code the code that used to be in

00:03:39,560 --> 00:03:45,229
the fast path just a branch that is

00:03:42,280 --> 00:03:50,750
basically gone for all existing IP table

00:03:45,229 --> 00:03:55,090
table variants it's there is also a

00:03:50,750 --> 00:03:55,090
speed ups in in terms of net namespace

00:03:55,419 --> 00:03:59,599
release in it from the various paths

00:03:57,769 --> 00:04:01,939
basically there were there were lots of

00:03:59,599 --> 00:04:03,889
synchronized RCU calls there and they

00:04:01,939 --> 00:04:06,590
are quite expensive you make several of

00:04:03,889 --> 00:04:09,469
them in a row so now they are gone and

00:04:06,590 --> 00:04:13,389
this is quite quite faster

00:04:09,469 --> 00:04:16,669
we got segment routing for ipv6 and

00:04:13,389 --> 00:04:20,229
which is basically an extension for for

00:04:16,669 --> 00:04:20,229
the IP for IP 6 tables

00:04:21,560 --> 00:04:26,340
there is a new feature that is allowing

00:04:24,449 --> 00:04:29,430
you to filter traffic before the

00:04:26,340 --> 00:04:34,770
fragmentation so now you can load the

00:04:29,430 --> 00:04:36,449
role table before the different

00:04:34,770 --> 00:04:39,060
maintainer and in traditionally this has

00:04:36,449 --> 00:04:42,870
happened always after so it's a module

00:04:39,060 --> 00:04:46,470
parameter that you can specify so so by

00:04:42,870 --> 00:04:48,780
when the AP table underscore raw module

00:04:46,470 --> 00:04:50,970
is loaded you can you can specify where

00:04:48,780 --> 00:04:54,300
to to the difficulty the filter where

00:04:50,970 --> 00:04:56,370
you want to do the filter so in a VBS

00:04:54,300 --> 00:05:03,120
the main thing that happen is immaculate

00:04:56,370 --> 00:05:05,490
support that the god contribute and in

00:05:03,120 --> 00:05:10,289
his tables we got also a bunch of

00:05:05,490 --> 00:05:11,360
updates rulesets god lucid updates god

00:05:10,289 --> 00:05:17,789
got to speed up

00:05:11,360 --> 00:05:22,520
also it's actually much faster now if

00:05:17,789 --> 00:05:22,520
you try with with latest latest colonel

00:05:23,240 --> 00:05:30,599
we got a new interface that allows you

00:05:26,699 --> 00:05:34,500
to to inquire the corner to know if an

00:05:30,599 --> 00:05:36,150
element belongs to a given set so it's

00:05:34,500 --> 00:05:38,340
basically control playing code that was

00:05:36,150 --> 00:05:40,409
missing in the netting interface that is

00:05:38,340 --> 00:05:43,800
now available also the code for NF

00:05:40,409 --> 00:05:47,819
tables is there so synthesis looks a bit

00:05:43,800 --> 00:05:50,490
like an FTE get element and then you

00:05:47,819 --> 00:05:51,860
specify in between the curly braces what

00:05:50,490 --> 00:05:54,629
element you are searching for

00:05:51,860 --> 00:05:56,610
we got timeout support for interval sets

00:05:54,629 --> 00:06:00,389
as is a feature that has been missing

00:05:56,610 --> 00:06:05,729
for a bit there are people building wide

00:06:00,389 --> 00:06:08,279
black lists based on intervals and they

00:06:05,729 --> 00:06:10,169
were asking for this type of support so

00:06:08,279 --> 00:06:12,360
now it's already there there is

00:06:10,169 --> 00:06:15,690
basically IPSec support is still missing

00:06:12,360 --> 00:06:18,479
a few a few features that are needed by

00:06:15,690 --> 00:06:20,909
the users they've been reporting that is

00:06:18,479 --> 00:06:23,759
not still complete so we will see

00:06:20,909 --> 00:06:25,620
another iteration on this support the

00:06:23,759 --> 00:06:28,589
code limit support is already there too

00:06:25,620 --> 00:06:31,289
so and I explained how what is the

00:06:28,589 --> 00:06:33,330
approach we have followed which is

00:06:31,289 --> 00:06:35,280
significantly different

00:06:33,330 --> 00:06:37,319
from what we have in AP tables it's

00:06:35,280 --> 00:06:39,180
partially reusing the infrastructure

00:06:37,319 --> 00:06:42,419
that we have in AP tables but it's

00:06:39,180 --> 00:06:46,259
slightly different and we also got 60 B

00:06:42,419 --> 00:06:47,909
64-bit handles to uniquely identifies

00:06:46,259 --> 00:06:52,319
all objects that we create enough tables

00:06:47,909 --> 00:06:54,539
that is also interesting to identify to

00:06:52,319 --> 00:06:57,810
make sure that you keep referring to the

00:06:54,539 --> 00:07:02,900
same object a long time connection

00:06:57,810 --> 00:07:06,180
tracking we got we got a fix for a

00:07:02,900 --> 00:07:09,569
long-standing problem that is basically

00:07:06,180 --> 00:07:13,409
that connection tracking could drop

00:07:09,569 --> 00:07:18,389
packets are racing to insert contract

00:07:13,409 --> 00:07:22,620
entries from the confirmation path and

00:07:18,389 --> 00:07:26,210
this problem is quite easy to trigger if

00:07:22,620 --> 00:07:26,210
you combine it with an FQ

00:07:26,729 --> 00:07:31,740
so basically what we are doing now is

00:07:29,879 --> 00:07:34,229
that from the NF cube path we have a

00:07:31,740 --> 00:07:36,060
roll team that is going to check if one

00:07:34,229 --> 00:07:38,879
of the packets lost a race it's going to

00:07:36,060 --> 00:07:40,710
trigger a real lookup and it's going to

00:07:38,879 --> 00:07:44,250
touch the the contract the contract

00:07:40,710 --> 00:07:47,039
entry that actually won't race and it's

00:07:44,250 --> 00:07:49,500
also going to undo the mangling that

00:07:47,039 --> 00:07:51,629
happen to the packet at lost race that

00:07:49,500 --> 00:07:55,259
needs to needs to be needs to happen

00:07:51,629 --> 00:07:57,719
otherwise for example we may get a

00:07:55,259 --> 00:07:58,889
different source port it is not it's not

00:07:57,719 --> 00:08:01,650
going to work it's going to break the

00:07:58,889 --> 00:08:03,419
flow so that code is already upstream

00:08:01,650 --> 00:08:06,089
and it would show up in the next kernel

00:08:03,419 --> 00:08:10,680
release in the next kernel official

00:08:06,089 --> 00:08:12,419
release and then the the new flow table

00:08:10,680 --> 00:08:17,900
bypass infrastructure that I will

00:08:12,419 --> 00:08:17,900
describe in this presentation too so

00:08:26,060 --> 00:08:33,690
so we had a nice little workshop quite

00:08:28,410 --> 00:08:37,590
recently just a few weeks ago in Berlin

00:08:33,690 --> 00:08:40,110
in Germany it was a meeting where

00:08:37,590 --> 00:08:42,960
they've seeks quoting people basically

00:08:40,110 --> 00:08:47,600
the four active members and one of their

00:08:42,960 --> 00:08:51,540
marriages and 13 developers contributors

00:08:47,600 --> 00:08:53,370
we met together we join and and we were

00:08:51,540 --> 00:08:56,970
basically we spent three days several

00:08:53,370 --> 00:08:59,640
days in a row discussing ongoing

00:08:56,970 --> 00:09:02,460
developments main topics as you could

00:08:59,640 --> 00:09:07,130
expect we're including quite a lot of

00:09:02,460 --> 00:09:10,470
talks about NF tables specifically

00:09:07,130 --> 00:09:13,830
progress on the leap and F tables

00:09:10,470 --> 00:09:16,650
library JSON support the interaction

00:09:13,830 --> 00:09:21,720
with IP tables and also some

00:09:16,650 --> 00:09:24,390
miscellaneous debate on on how to how to

00:09:21,720 --> 00:09:26,430
improve integration with with firewall

00:09:24,390 --> 00:09:30,590
de and what was missing with regards to

00:09:26,430 --> 00:09:33,840
what IP side supports load-balancing

00:09:30,590 --> 00:09:37,770
updates to because we now we have a new

00:09:33,840 --> 00:09:41,940
user space software daemon that you can

00:09:37,770 --> 00:09:44,250
use to configure load balancing and a

00:09:41,940 --> 00:09:47,210
number of missing features specifically

00:09:44,250 --> 00:09:52,950
the content connection tracking

00:09:47,210 --> 00:09:57,270
fine-grain timeout timeout policy in the

00:09:52,950 --> 00:09:59,960
code limit support and IPSec there were

00:09:57,270 --> 00:10:09,030
also updates on bridge net filter and

00:09:59,960 --> 00:10:14,640
the flow table bypass so the live enough

00:10:09,030 --> 00:10:19,740
tables is an effort that has been that

00:10:14,640 --> 00:10:23,510
has been leader by by Phil Souter it's

00:10:19,740 --> 00:10:26,580
available since enough tables 0.9.0 and

00:10:23,510 --> 00:10:29,550
it the API is quite simple it's

00:10:26,580 --> 00:10:32,580
basically we are providing two to two

00:10:29,550 --> 00:10:33,720
new interfaces this NFT run command from

00:10:32,580 --> 00:10:36,029
buffer so you just

00:10:33,720 --> 00:10:39,360
a buffer and this context object that I

00:10:36,029 --> 00:10:41,459
will just show you how it looks like and

00:10:39,360 --> 00:10:44,579
that is another variant that allows you

00:10:41,459 --> 00:10:46,949
to pass a file that you want to that you

00:10:44,579 --> 00:10:50,250
want to run you're going to load into

00:10:46,949 --> 00:10:52,829
the kernel so this is just basically

00:10:50,250 --> 00:10:54,300
providing a native interface for

00:10:52,829 --> 00:10:56,970
third-party applications that we can

00:10:54,300 --> 00:10:59,040
start or stop telling people to use the

00:10:56,970 --> 00:11:01,740
big command-line utilities that it has

00:10:59,040 --> 00:11:03,949
been so far the main interface that

00:11:01,740 --> 00:11:05,819
we've been offering in in iptables

00:11:03,949 --> 00:11:09,860
specifically we've been pointing to

00:11:05,819 --> 00:11:14,339
users to use the IP tables restore

00:11:09,860 --> 00:11:16,399
command and now hopefully we are going

00:11:14,339 --> 00:11:20,250
to have something better

00:11:16,399 --> 00:11:23,819
so what else basically filled he he

00:11:20,250 --> 00:11:27,360
created he he added this this interfaces

00:11:23,819 --> 00:11:29,610
to to create to allocate the the

00:11:27,360 --> 00:11:31,199
contract the the context object and

00:11:29,610 --> 00:11:33,629
really say that this context object is

00:11:31,199 --> 00:11:36,509
going to be used to configure how you

00:11:33,629 --> 00:11:38,879
want the library to behave so we wanted

00:11:36,509 --> 00:11:42,420
to offer a very simple API to start with

00:11:38,879 --> 00:11:45,480
so this simple API as you as you could

00:11:42,420 --> 00:11:49,230
see it's just taking a string in in NFT

00:11:45,480 --> 00:11:50,879
in an FCE command line format so and

00:11:49,230 --> 00:11:53,149
then if you want to modify the behavior

00:11:50,879 --> 00:11:57,899
you just use one of the setter or getter

00:11:53,149 --> 00:12:00,089
that we have to to configure the context

00:11:57,899 --> 00:12:04,139
object so for example if you want to run

00:12:00,089 --> 00:12:07,139
a if you want to make a dry run you just

00:12:04,139 --> 00:12:09,750
set that right right run flag on the

00:12:07,139 --> 00:12:13,500
context object and you just run the the

00:12:09,750 --> 00:12:15,959
NFT command using the the the native API

00:12:13,500 --> 00:12:18,120
or for example its roof of a strip of

00:12:15,959 --> 00:12:20,579
stateful information well listing for

00:12:18,120 --> 00:12:24,990
example in case you don't care about the

00:12:20,579 --> 00:12:27,930
existing counters or for example if in

00:12:24,990 --> 00:12:30,449
case of a quota object if you don't want

00:12:27,930 --> 00:12:33,559
to store or get in the listing how many

00:12:30,449 --> 00:12:35,939
bytes has has been already consumed so

00:12:33,559 --> 00:12:37,769
so it's basically just removing all the

00:12:35,939 --> 00:12:39,959
stateful information from from the

00:12:37,769 --> 00:12:44,790
classic xpressions objects that we have

00:12:39,959 --> 00:12:45,929
that are sorry need internally you could

00:12:44,790 --> 00:12:47,580
also enable the debugging information

00:12:45,929 --> 00:12:49,590
you could display this six

00:12:47,580 --> 00:12:52,970
for bid handles that we have in all

00:12:49,590 --> 00:12:55,440
objects now and lots of many other

00:12:52,970 --> 00:12:58,410
things that you could configure but for

00:12:55,440 --> 00:13:02,940
most people just creating the context

00:12:58,410 --> 00:13:06,560
object and then running commands through

00:13:02,940 --> 00:13:10,410
the API that I just shown it should be

00:13:06,560 --> 00:13:12,090
should be should be fine there is also a

00:13:10,410 --> 00:13:14,580
number of interfaces that allows you to

00:13:12,090 --> 00:13:18,270
decide what to do with the output and

00:13:14,580 --> 00:13:19,560
also with the errors that happen so

00:13:18,270 --> 00:13:22,440
basically it's and you can configure

00:13:19,560 --> 00:13:26,850
them to print the output to a buffer or

00:13:22,440 --> 00:13:28,830
also to a file descriptor so and the

00:13:26,850 --> 00:13:33,750
default behavior is to print that

00:13:28,830 --> 00:13:36,480
through the standard or the error using

00:13:33,750 --> 00:13:41,520
the standard output or the the the

00:13:36,480 --> 00:13:44,460
standard error output will also finish

00:13:41,520 --> 00:13:49,380
the JSON support so also available since

00:13:44,460 --> 00:13:52,470
since the latest released it comes with

00:13:49,380 --> 00:13:54,750
with listing and parsing support I still

00:13:52,470 --> 00:13:56,940
missing monitor mode and tracing mode

00:13:54,750 --> 00:13:59,730
the monitor mode is quite convenient in

00:13:56,940 --> 00:14:01,350
case you want to track rule set updates

00:13:59,730 --> 00:14:02,880
it's a feature that has been missing IP

00:14:01,350 --> 00:14:06,660
tables for a long time now it's a very

00:14:02,880 --> 00:14:10,980
volatile Ft so and there is also the

00:14:06,660 --> 00:14:14,460
tracing mode that is easily it allows

00:14:10,980 --> 00:14:17,910
you to debug an existing rule set to see

00:14:14,460 --> 00:14:22,080
what what path the packet is following

00:14:17,910 --> 00:14:23,970
when evaluating the rule set this

00:14:22,080 --> 00:14:26,730
tracing mode and monitoring mode can be

00:14:23,970 --> 00:14:29,610
combined they are working with existing

00:14:26,730 --> 00:14:31,650
tooling but there is no way to express

00:14:29,610 --> 00:14:34,080
this in Jason yeah but it's just a

00:14:31,650 --> 00:14:35,580
matter of time and then stabilize in the

00:14:34,080 --> 00:14:38,280
format that we had some discussions

00:14:35,580 --> 00:14:41,310
about some big changes that may happen

00:14:38,280 --> 00:14:45,210
but most likely it's really quite good

00:14:41,310 --> 00:14:49,350
and stable so so we can just freeze it

00:14:45,210 --> 00:14:53,100
soon it's just to show you how it looks

00:14:49,350 --> 00:14:56,700
a bit this simple example in case you

00:14:53,100 --> 00:14:59,060
want to match the IP protocol field and

00:14:56,700 --> 00:15:00,340
you want to match any of these protocols

00:14:59,060 --> 00:15:02,650
so it

00:15:00,340 --> 00:15:06,100
the representations you look like match

00:15:02,650 --> 00:15:07,750
and the land you express what you have

00:15:06,100 --> 00:15:10,900
on the leg left hand side that is

00:15:07,750 --> 00:15:12,850
basically the key and then on your right

00:15:10,900 --> 00:15:16,510
hand side you're going to have values or

00:15:12,850 --> 00:15:18,580
sets and then in this example you have

00:15:16,510 --> 00:15:21,100
basically that you want to match a

00:15:18,580 --> 00:15:24,970
payload you're going to specify the

00:15:21,100 --> 00:15:26,980
protocol through the name field and then

00:15:24,970 --> 00:15:28,810
at the end through the yes through the

00:15:26,980 --> 00:15:34,000
name DSM field and then filled for the

00:15:28,810 --> 00:15:36,250
for the packets fill and as you can see

00:15:34,000 --> 00:15:38,410
there is no it's not that

00:15:36,250 --> 00:15:40,690
from the Jason hi from the Jason

00:15:38,410 --> 00:15:44,200
representation for lip and of tables we

00:15:40,690 --> 00:15:46,290
don't we don't provide a low-level

00:15:44,200 --> 00:15:50,170
interface I mean we don't provide

00:15:46,290 --> 00:15:55,230
offsets access to offsets to offset to

00:15:50,170 --> 00:15:59,200
base to so it's you're going to refer to

00:15:55,230 --> 00:16:03,820
to product to fill that are available in

00:15:59,200 --> 00:16:05,440
in in the headers so it's it's it's an

00:16:03,820 --> 00:16:07,540
interface today that is high girl level

00:16:05,440 --> 00:16:11,339
that what we have what we offer in live

00:16:07,540 --> 00:16:13,960
an F table 11 ft NL that is actually

00:16:11,339 --> 00:16:15,910
allowing you to do all that but it is

00:16:13,960 --> 00:16:17,620
something that is tricky and it's better

00:16:15,910 --> 00:16:18,940
if the user doesn't have to know

00:16:17,620 --> 00:16:21,310
because there are fields that are

00:16:18,940 --> 00:16:22,450
complicated like like let's say it IP

00:16:21,310 --> 00:16:24,790
dscp

00:16:22,450 --> 00:16:28,300
so building an expression for that fill

00:16:24,790 --> 00:16:30,310
is not so straightforward and you have

00:16:28,300 --> 00:16:35,740
to end up doing bit shifts and so on

00:16:30,310 --> 00:16:38,710
so with this API is it's just we just

00:16:35,740 --> 00:16:40,330
you just specify what you need and you

00:16:38,710 --> 00:16:44,080
go and internally it's going to generate

00:16:40,330 --> 00:16:47,410
the expression that is going to match

00:16:44,080 --> 00:16:49,060
what you what you want so and then at

00:16:47,410 --> 00:16:51,790
the end of it you have an action there

00:16:49,060 --> 00:16:55,300
is a new thing there that is basically

00:16:51,790 --> 00:17:00,610
because the this action has no no

00:16:55,300 --> 00:17:03,760
parameters no no options what else there

00:17:00,610 --> 00:17:09,100
were we had also miscellanea discussions

00:17:03,760 --> 00:17:11,530
on nf tables and IP tables integration

00:17:09,100 --> 00:17:14,120
so basically here Florian first of all

00:17:11,530 --> 00:17:18,709
he was pointing that able be good

00:17:14,120 --> 00:17:21,910
- if if we improve interaction between

00:17:18,709 --> 00:17:27,410
NF stables and IP tables so basically

00:17:21,910 --> 00:17:29,030
show show our way to the user make it

00:17:27,410 --> 00:17:32,690
make it easy to the user to identify

00:17:29,030 --> 00:17:35,270
that both tools are being used at the

00:17:32,690 --> 00:17:38,150
same time so just in case you have some

00:17:35,270 --> 00:17:40,010
software generating rules automatically

00:17:38,150 --> 00:17:42,650
and then you are typing rules by

00:17:40,010 --> 00:17:45,860
yourself and in case that for example

00:17:42,650 --> 00:17:50,960
this software is adding is adding rules

00:17:45,860 --> 00:17:53,840
to IP tables while you are adding rules

00:17:50,960 --> 00:17:56,660
to nft and then things could go wrong

00:17:53,840 --> 00:17:58,460
because both policies could contradict

00:17:56,660 --> 00:18:00,559
each other and then things may not work

00:17:58,460 --> 00:18:02,210
and debugging all that without giving

00:18:00,559 --> 00:18:05,480
providing some degree of visibility

00:18:02,210 --> 00:18:08,540
between the different tools is actually

00:18:05,480 --> 00:18:12,980
quite convenient so the outcome from

00:18:08,540 --> 00:18:15,620
these discussions was to at least

00:18:12,980 --> 00:18:18,980
display and notice when when calling IP

00:18:15,620 --> 00:18:23,300
tables safe or also when when listing

00:18:18,980 --> 00:18:25,100
the rule set in an ST - to make it to

00:18:23,300 --> 00:18:27,800
make it clear to the user to make it

00:18:25,100 --> 00:18:30,860
transparent to the user that that both

00:18:27,800 --> 00:18:33,080
tools are being mixed so just to make it

00:18:30,860 --> 00:18:36,320
easier for debugging it's something it's

00:18:33,080 --> 00:18:37,790
quite simple approach we discussed all

00:18:36,320 --> 00:18:41,540
there are approaches more complicated

00:18:37,790 --> 00:18:44,929
ones like for example taking the IP IP

00:18:41,540 --> 00:18:47,360
tables binary blob and translating that

00:18:44,929 --> 00:18:49,220
into the NFT net beam format and so on

00:18:47,360 --> 00:18:51,380
but all that is too complicated and it's

00:18:49,220 --> 00:18:53,990
going to take too much time so we

00:18:51,380 --> 00:18:56,140
decided to go for this simple the most

00:18:53,990 --> 00:19:00,340
simple approach by now and see I think

00:18:56,140 --> 00:19:02,360
wait for feedback to see how things go

00:19:00,340 --> 00:19:05,030
Florian proposed to rename the other

00:19:02,360 --> 00:19:07,130
tables compact to X tables it seems that

00:19:05,030 --> 00:19:09,710
people who like this compact thing it's

00:19:07,130 --> 00:19:12,800
it's not a nice name so now it's being

00:19:09,710 --> 00:19:14,600
renamed and there are more things that

00:19:12,800 --> 00:19:18,040
are actually happening and we also

00:19:14,600 --> 00:19:21,440
because it was very easy to to implement

00:19:18,040 --> 00:19:23,270
monitor mode for these X tables and to

00:19:21,440 --> 00:19:25,610
get events for free

00:19:23,270 --> 00:19:29,000
so now we

00:19:25,610 --> 00:19:31,790
and iptables money to X tables - monitor

00:19:29,000 --> 00:19:33,520
tolling that you could use so this

00:19:31,790 --> 00:19:36,380
compatibility layer is exactly is

00:19:33,520 --> 00:19:40,070
starting to do more of things that that

00:19:36,380 --> 00:19:43,610
we envisioned originally so actually

00:19:40,070 --> 00:19:46,850
it's something that the oldest ideas

00:19:43,610 --> 00:19:49,790
came HAP I mean where were discuss

00:19:46,850 --> 00:19:51,799
already time ago but because we were

00:19:49,790 --> 00:19:55,970
trying to give if give preference to and

00:19:51,799 --> 00:20:00,410
to and FTA to the new tooling we just

00:19:55,970 --> 00:20:03,890
left them behind but now we are probably

00:20:00,410 --> 00:20:06,590
resurrecting all this stuff so so now

00:20:03,890 --> 00:20:16,330
all these IP tables combat stuff got

00:20:06,590 --> 00:20:16,330
renamed and we may see progress in

00:20:16,419 --> 00:20:21,950
implementing more native translations

00:20:19,790 --> 00:20:24,230
from from what what it used to be the IP

00:20:21,950 --> 00:20:27,950
tables compared to native and a table so

00:20:24,230 --> 00:20:30,770
basically the idea here is that at this

00:20:27,950 --> 00:20:33,890
stage if you call IP tables compat or

00:20:30,770 --> 00:20:36,280
these new X tables command line tool

00:20:33,890 --> 00:20:39,890
what it happens is that we are going to

00:20:36,280 --> 00:20:43,970
use the native and s tables engine but

00:20:39,890 --> 00:20:45,860
we still rely on an extension the kernel

00:20:43,970 --> 00:20:49,160
and whose name is n ft underscore

00:20:45,860 --> 00:20:51,919
compound and this n ft underscore combat

00:20:49,160 --> 00:20:55,700
is basically calling the X tables the

00:20:51,919 --> 00:20:57,980
classic X tables matches and targets but

00:20:55,700 --> 00:21:02,660
we could do it slightly more and what we

00:20:57,980 --> 00:21:04,549
could do is that for simple matches like

00:21:02,660 --> 00:21:06,290
all the existing protocol matches that

00:21:04,549 --> 00:21:08,150
we have we could add a T sector

00:21:06,290 --> 00:21:14,140
infrastructure that will allows us to

00:21:08,150 --> 00:21:18,770
basically route this matches to to some

00:21:14,140 --> 00:21:23,860
user space extension that will translate

00:21:18,770 --> 00:21:27,500
that to a native matching on TCP so so

00:21:23,860 --> 00:21:29,510
bottom line is we could use more we

00:21:27,500 --> 00:21:34,540
could do more native representation and

00:21:29,510 --> 00:21:37,270
off of what we represent in X tables

00:21:34,540 --> 00:21:39,550
there is a regression test food

00:21:37,270 --> 00:21:45,460
that's it that has been contributed by

00:21:39,550 --> 00:21:48,310
Yoshi she sent initial patches we have

00:21:45,460 --> 00:21:52,630
we have very very very very little tests

00:21:48,310 --> 00:21:54,550
so far but it's going to we are going to

00:21:52,630 --> 00:21:57,190
make progress on that front - it's a the

00:21:54,550 --> 00:21:58,980
ball was missing we actually already had

00:21:57,190 --> 00:22:01,380
iptables regression regression

00:21:58,980 --> 00:22:02,590
infrastructure it's a Python based

00:22:01,380 --> 00:22:05,710
infrastructure

00:22:02,590 --> 00:22:07,630
it's a script that basically just it

00:22:05,710 --> 00:22:09,610
takes commands it's going to insert them

00:22:07,630 --> 00:22:11,140
into the kernel and then it's going to

00:22:09,610 --> 00:22:12,850
check if the listing matches with what

00:22:11,140 --> 00:22:15,400
we inserted so it's basically just

00:22:12,850 --> 00:22:19,830
exercising the the control the control

00:22:15,400 --> 00:22:22,380
plane and but we needed more

00:22:19,830 --> 00:22:25,030
sophisticated testing basically

00:22:22,380 --> 00:22:26,950
specifically for iptables restores and

00:22:25,030 --> 00:22:29,380
safe there are lots of configurations

00:22:26,950 --> 00:22:32,290
there that you could use that you could

00:22:29,380 --> 00:22:35,770
combine and those interactions are not

00:22:32,290 --> 00:22:38,200
so obvious and basically when we were

00:22:35,770 --> 00:22:40,930
testing the iptables compiled on now X

00:22:38,200 --> 00:22:44,230
tables we were realizing that we

00:22:40,930 --> 00:22:49,620
realized that we really needed something

00:22:44,230 --> 00:22:53,920
that was going to to do more extensive

00:22:49,620 --> 00:22:57,250
testing on on all this combination so

00:22:53,920 --> 00:23:00,100
it's we're making programs on that front

00:22:57,250 --> 00:23:03,910
in IP said Joseph classic she was

00:23:00,100 --> 00:23:07,300
talking about him he basically made a

00:23:03,910 --> 00:23:12,760
very very nice summary of what IP said

00:23:07,300 --> 00:23:17,920
supports already and comparing it to

00:23:12,760 --> 00:23:20,710
what we have in NF tables so and and

00:23:17,920 --> 00:23:26,950
what is basically left that is not much

00:23:20,710 --> 00:23:28,990
is there is no there is no way that we

00:23:26,950 --> 00:23:32,230
can combine set intervals all offset

00:23:28,990 --> 00:23:34,480
with a prefix prefix elements within

00:23:32,230 --> 00:23:37,150
concatenation so something like what you

00:23:34,480 --> 00:23:40,060
can see there on that example cannot

00:23:37,150 --> 00:23:42,610
it's not supported so and it seems that

00:23:40,060 --> 00:23:45,820
it's something that user has been asking

00:23:42,610 --> 00:23:48,340
for it for a while and and now there is

00:23:45,820 --> 00:23:50,290
also a garver that is the firewall

00:23:48,340 --> 00:23:52,630
domaine Turner done it set so it's

00:23:50,290 --> 00:23:54,340
something that Joseph mentioned at the

00:23:52,630 --> 00:23:57,610
conference that he will take a stop at

00:23:54,340 --> 00:23:59,260
it and and he will implement it so

00:23:57,610 --> 00:24:01,590
basically to achieve this this

00:23:59,260 --> 00:24:03,790
flexibility is not asserted is so

00:24:01,590 --> 00:24:06,400
performin because they did a structure

00:24:03,790 --> 00:24:08,020
that we have to use it's going to take a

00:24:06,400 --> 00:24:10,390
bit of scientist to find the matching

00:24:08,020 --> 00:24:11,830
but it's it seems that people like it a

00:24:10,390 --> 00:24:14,230
lot so we are going to support it

00:24:11,830 --> 00:24:20,040
anytime soon there is another feature

00:24:14,230 --> 00:24:23,140
that is this force flag that is

00:24:20,040 --> 00:24:27,850
basically allowing you from dynamic sets

00:24:23,140 --> 00:24:29,670
to to remove an element in case the set

00:24:27,850 --> 00:24:33,400
is full already

00:24:29,670 --> 00:24:36,160
so it's just basically removing the

00:24:33,400 --> 00:24:41,430
first element that you find in the in

00:24:36,160 --> 00:24:44,290
the in the packet and there is another

00:24:41,430 --> 00:24:46,480
flag that is this no match flag that is

00:24:44,290 --> 00:24:48,820
basically inverting the matching

00:24:46,480 --> 00:24:51,580
criteria it's not going to work with the

00:24:48,820 --> 00:24:55,750
existing rb3 implementation that we have

00:24:51,580 --> 00:24:59,050
so we will need a new set blackened to

00:24:55,750 --> 00:25:00,790
support this flag so and then just upon

00:24:59,050 --> 00:25:02,830
mentioning that he was going to do have

00:25:00,790 --> 00:25:05,230
a look at the support in a try three

00:25:02,830 --> 00:25:12,400
matching a try to try three data

00:25:05,230 --> 00:25:18,550
structure yes and there's no match flag

00:25:12,400 --> 00:25:22,300
needs to work to for the NFC get element

00:25:18,550 --> 00:25:24,400
command so it's basically in case that

00:25:22,300 --> 00:25:26,530
you want to test from the front your

00:25:24,400 --> 00:25:28,450
control plane if an element belongs to a

00:25:26,530 --> 00:25:31,690
set for those people that are basically

00:25:28,450 --> 00:25:34,000
building assets and populating the set

00:25:31,690 --> 00:25:36,700
the sets with elements from the packet

00:25:34,000 --> 00:25:39,910
path if you want to check if that if a

00:25:36,700 --> 00:25:42,730
given element is in that set you could

00:25:39,910 --> 00:25:44,530
you should be able to also to invert

00:25:42,730 --> 00:25:47,170
matching criteria and specify there's no

00:25:44,530 --> 00:25:51,220
match thing so that's basically what is

00:25:47,170 --> 00:25:53,580
what is missing compared to your knife

00:25:51,220 --> 00:25:53,580
tables

00:25:55,060 --> 00:25:59,330
firewall Dirac Garber as I said he was

00:25:57,890 --> 00:26:02,900
making a presentation during the Nets

00:25:59,330 --> 00:26:05,110
Fulton workshop to to make comments on

00:26:02,900 --> 00:26:08,840
what was missing from the f5 all the

00:26:05,110 --> 00:26:12,050
perspective for those are not familiar

00:26:08,840 --> 00:26:15,950
with five all these actually enabled by

00:26:12,050 --> 00:26:19,880
the fold in several distributions soocer

00:26:15,950 --> 00:26:24,140
fedora red-hot basically it's written in

00:26:19,880 --> 00:26:27,320
Python it supports d-bus and so far it's

00:26:24,140 --> 00:26:31,370
it's calling commands it's basically

00:26:27,320 --> 00:26:32,870
invoking the binary now it's fully it

00:26:31,370 --> 00:26:35,270
fully works the good news is that it's

00:26:32,870 --> 00:26:38,240
working fully with and if tables native

00:26:35,270 --> 00:26:39,530
it natively but also with with what used

00:26:38,240 --> 00:26:43,220
to be the combat layer

00:26:39,530 --> 00:26:46,580
didn't your X tables - there isn't going

00:26:43,220 --> 00:26:49,850
word to use the net EDD library that is

00:26:46,580 --> 00:26:52,640
now available that fill finished so

00:26:49,850 --> 00:26:55,640
anytime soon firewall D is not going to

00:26:52,640 --> 00:26:59,090
be invoking commands anymore and then

00:26:55,640 --> 00:27:04,070
the requirements from Eric Garver were

00:26:59,090 --> 00:27:07,340
basically the support for interval set

00:27:04,070 --> 00:27:08,830
or prefix elements with perfect elements

00:27:07,340 --> 00:27:11,480
with concatenations

00:27:08,830 --> 00:27:14,900
that I just mentioned and also he would

00:27:11,480 --> 00:27:18,470
like to see and he would like to see

00:27:14,900 --> 00:27:21,080
support for the nat chain from the IANA

00:27:18,470 --> 00:27:23,650
family there is something that should be

00:27:21,080 --> 00:27:23,650
easy to do

00:27:25,340 --> 00:27:30,590
louder gardenia she was talking about

00:27:27,740 --> 00:27:37,070
the daemon that she quite recently

00:27:30,590 --> 00:27:40,670
released current version is 0.2 this

00:27:37,070 --> 00:27:42,890
nftl p is a user space demon that is

00:27:40,670 --> 00:27:44,900
that aims to provide an easy way to

00:27:42,890 --> 00:27:47,510
configure and have tables the NF tables

00:27:44,900 --> 00:27:51,050
infrastructure in in add in load

00:27:47,510 --> 00:27:52,820
balancing environments so it performs

00:27:51,050 --> 00:27:55,310
health checks at different levels like

00:27:52,820 --> 00:28:00,350
making sure that there is a neighbor

00:27:55,310 --> 00:28:02,460
entry route replies to the ICMP are

00:28:00,350 --> 00:28:05,910
correct

00:28:02,460 --> 00:28:10,380
reach ability from from layer for TCP

00:28:05,910 --> 00:28:13,800
also check for HTTP service working

00:28:10,380 --> 00:28:18,030
being available and there is a debian

00:28:13,800 --> 00:28:23,040
package available now actually quite

00:28:18,030 --> 00:28:28,500
quite recently up streamed this NFC load

00:28:23,040 --> 00:28:30,870
balancer supports three modes they call

00:28:28,500 --> 00:28:33,090
it one of the node the mode is as nice a

00:28:30,870 --> 00:28:34,860
sauce snap but it's actually not just

00:28:33,090 --> 00:28:38,490
doing sauce not it's actually doing

00:28:34,860 --> 00:28:40,080
masquerade plus T not so it's emulating

00:28:38,490 --> 00:28:42,630
the proxy behavior that seems to be

00:28:40,080 --> 00:28:46,560
something that system administrator

00:28:42,630 --> 00:28:48,240
DevOps are asking for sometimes so there

00:28:46,560 --> 00:28:51,810
is also a denied mode that is just

00:28:48,240 --> 00:28:57,000
purely a destination up mode and that

00:28:51,810 --> 00:28:59,190
there is direct server return and soon

00:28:57,000 --> 00:29:00,660
there will be a new mode there will be

00:28:59,190 --> 00:29:04,350
support for a new mode that is the

00:29:00,660 --> 00:29:05,880
stateless denied mode all the

00:29:04,350 --> 00:29:08,130
infrastructure to support this in the

00:29:05,880 --> 00:29:09,960
kernel and NFT is already available so

00:29:08,130 --> 00:29:15,150
it's a matter of adding the missing bits

00:29:09,960 --> 00:29:17,280
to user space so so basically the idea

00:29:15,150 --> 00:29:19,440
of this stateless knot is something that

00:29:17,280 --> 00:29:22,080
it's going to sit in between the tena

00:29:19,440 --> 00:29:26,220
the classic Dena mode and the direct

00:29:22,080 --> 00:29:29,370
server return and so it's likely easier

00:29:26,220 --> 00:29:34,740
to set up than the dsr it's less

00:29:29,370 --> 00:29:36,930
performance that the dsr mode but as i

00:29:34,740 --> 00:29:39,030
said it's it's simpler it's it's much

00:29:36,930 --> 00:29:42,360
easier to configure and it's going to

00:29:39,030 --> 00:29:44,760
cost less less troubles in case you do

00:29:42,360 --> 00:29:46,590
something wrong in your network so some

00:29:44,760 --> 00:29:52,530
people some people have concerns about

00:29:46,590 --> 00:29:53,730
the SR regarding problems that may

00:29:52,530 --> 00:29:56,040
happen in the in the network

00:29:53,730 --> 00:29:59,460
if you don't configure it right so so

00:29:56,040 --> 00:30:02,730
they prefer to go for something that is

00:29:59,460 --> 00:30:06,420
safer so what we will see this this this

00:30:02,730 --> 00:30:09,120
mode soon - they are supporting for

00:30:06,420 --> 00:30:12,060
schedulers at this stage is one is

00:30:09,120 --> 00:30:15,810
weight-based round-robin hash and also

00:30:12,060 --> 00:30:18,870
sim symmetric hashing is available the

00:30:15,810 --> 00:30:22,950
ft-lb demonsaw Forte's IP 456 it

00:30:18,870 --> 00:30:26,490
provides a REST API and the

00:30:22,950 --> 00:30:28,290
configuration files it is using JSON and

00:30:26,490 --> 00:30:32,190
it's coming also without an automated

00:30:28,290 --> 00:30:34,620
test infrastructure so the configuration

00:30:32,190 --> 00:30:37,020
looks like this basically you have to

00:30:34,620 --> 00:30:39,090
define farms you place a name on the

00:30:37,020 --> 00:30:41,580
farm and then you configure virtual

00:30:39,090 --> 00:30:43,560
address and ports you can figure also

00:30:41,580 --> 00:30:47,070
the load balancing mode that you want to

00:30:43,560 --> 00:30:49,920
use for what protocol you want to apply

00:30:47,070 --> 00:30:52,290
the the load balancing approach also the

00:30:49,920 --> 00:30:57,330
scheduler and then you have to specify

00:30:52,290 --> 00:30:59,340
the backends and so basically the IP

00:30:57,330 --> 00:31:01,320
before developing for addresses of the

00:30:59,340 --> 00:31:05,130
backends and in case weight is needed or

00:31:01,320 --> 00:31:08,550
priority the state allows you to take to

00:31:05,130 --> 00:31:12,450
take up or down given back-end you could

00:31:08,550 --> 00:31:16,080
also the priority for forms allows you

00:31:12,450 --> 00:31:17,520
to define to define a load high

00:31:16,080 --> 00:31:19,950
availability scenario so you could have

00:31:17,520 --> 00:31:22,020
a form that is going to behave as a

00:31:19,950 --> 00:31:25,170
primary and you could define another

00:31:22,020 --> 00:31:26,850
form that is going to act as a backup so

00:31:25,170 --> 00:31:28,860
if there is a problem a form you're

00:31:26,850 --> 00:31:30,810
going to fall back in a different form

00:31:28,860 --> 00:31:32,430
to a different founder is active that is

00:31:30,810 --> 00:31:32,970
going to be replacing the one that is

00:31:32,430 --> 00:31:34,950
failing

00:31:32,970 --> 00:31:37,770
so all that kind of flexibility that

00:31:34,950 --> 00:31:41,370
they want to have so what is what is

00:31:37,770 --> 00:31:43,260
happening from foreign NFT is exactly

00:31:41,370 --> 00:31:46,050
something like this dissing ft-lb is

00:31:43,260 --> 00:31:49,680
generating rules and those rules look

00:31:46,050 --> 00:31:55,190
like this so do it's creating a map so

00:31:49,680 --> 00:31:55,190
this map with the tcp services its

00:31:55,610 --> 00:32:00,530
contains elements of the r

00:31:57,510 --> 00:32:03,060
concatenations those concatenations are

00:32:00,530 --> 00:32:05,760
basically the topple has the following

00:32:03,060 --> 00:32:10,500
components it's ipv4 address then the

00:32:05,760 --> 00:32:14,370
service and a verdict and then from the

00:32:10,500 --> 00:32:16,820
protein chain what we are going to do is

00:32:14,370 --> 00:32:21,570
that we are going to find and matching

00:32:16,820 --> 00:32:23,700
in the map and based on that we are

00:32:21,570 --> 00:32:26,860
going to apply the action and then when

00:32:23,700 --> 00:32:30,920
when going to the the via

00:32:26,860 --> 00:32:35,960
one chain from there we have the rule

00:32:30,920 --> 00:32:38,240
that it's going to apply the load

00:32:35,960 --> 00:32:41,960
balancing based on the hashing so the

00:32:38,240 --> 00:32:49,210
net chain below on the on the vs one

00:32:41,960 --> 00:32:53,750
chain it's basically just hashing on the

00:32:49,210 --> 00:32:57,800
ipv4 source address supplying models to

00:32:53,750 --> 00:33:01,250
and then based on that we are going to

00:32:57,800 --> 00:33:05,510
obtain the destination nap that is going

00:33:01,250 --> 00:33:09,350
to be applied to the packet this is this

00:33:05,510 --> 00:33:11,240
infrastructure is using the stateful nap

00:33:09,350 --> 00:33:13,160
infrastructure that that we have in net

00:33:11,240 --> 00:33:15,250
filter so this only applies to the first

00:33:13,160 --> 00:33:17,840
packet and then followed by packets are

00:33:15,250 --> 00:33:19,490
mangled based on that infamy or the not

00:33:17,840 --> 00:33:20,900
information that is configure this is

00:33:19,490 --> 00:33:25,700
stored in the connection tracking system

00:33:20,900 --> 00:33:27,920
I mean the the rule said that that

00:33:25,700 --> 00:33:35,300
results from this is quite elegant even

00:33:27,920 --> 00:33:38,050
in my opinion and compared to - I mean

00:33:35,300 --> 00:33:43,490
trying to express this in IP tables is

00:33:38,050 --> 00:33:48,170
it's possible but the rule set is is not

00:33:43,490 --> 00:33:51,590
so nice so in case you want to support a

00:33:48,170 --> 00:33:58,190
new filter surface let's say we want to

00:33:51,590 --> 00:34:00,050
support HTTP for 400 400 40 43 so it's

00:33:58,190 --> 00:34:03,110
just a matter of adding a new element to

00:34:00,050 --> 00:34:05,030
the map and then just adding the chain

00:34:03,110 --> 00:34:07,700
that is going to do the load balancing

00:34:05,030 --> 00:34:10,940
between the new back-end server so it's

00:34:07,700 --> 00:34:16,030
so making incremental updates on this

00:34:10,940 --> 00:34:19,550
rule set is is is quite natural actually

00:34:16,030 --> 00:34:22,010
all this is being generated by an ft-lb

00:34:19,550 --> 00:34:24,500
so it's not something that just it's

00:34:22,010 --> 00:34:27,190
just to show you what is what the

00:34:24,500 --> 00:34:27,190
diamond is doing

00:34:28,690 --> 00:34:35,540
another topic during the initial torture

00:34:31,220 --> 00:34:37,250
was the current limit support so for

00:34:35,540 --> 00:34:39,440
those that don't know about cut limit

00:34:37,250 --> 00:34:41,330
it's an extension in iptables that

00:34:39,440 --> 00:34:45,400
allows you to rate limit the number of

00:34:41,330 --> 00:34:53,090
connections per sources or destination

00:34:45,400 --> 00:34:56,510
you can also apply net masks matching

00:34:53,090 --> 00:34:59,590
rate limiting based on on a on a network

00:34:56,510 --> 00:35:02,900
a specific Network set meant but this

00:34:59,590 --> 00:35:04,630
from time to time there are users coming

00:35:02,900 --> 00:35:06,860
to the manor list and asking for more

00:35:04,630 --> 00:35:08,810
matching criteria so it's not that

00:35:06,860 --> 00:35:10,940
flexible and extending support for this

00:35:08,810 --> 00:35:12,770
in IP tables it's going to trigger more

00:35:10,940 --> 00:35:17,720
kernel code and it's going to blow the

00:35:12,770 --> 00:35:19,250
extension so with when when when looking

00:35:17,720 --> 00:35:22,250
into it called lemon and supporting this

00:35:19,250 --> 00:35:23,540
in an ft we wanted to to provide the

00:35:22,250 --> 00:35:24,830
kind of flexibility to that way in

00:35:23,540 --> 00:35:27,800
having enough tables so you can

00:35:24,830 --> 00:35:30,260
basically use any selector to apply the

00:35:27,800 --> 00:35:32,510
the rate-limiting that is basically the

00:35:30,260 --> 00:35:36,350
idea and also combine it with

00:35:32,510 --> 00:35:39,140
concatenations and so on so the

00:35:36,350 --> 00:35:41,900
structure that we have in next equal

00:35:39,140 --> 00:35:46,220
limit looks like it's a hash table and

00:35:41,900 --> 00:35:48,110
then for each know that we are going to

00:35:46,220 --> 00:35:51,620
find in a hash table there is an RV tree

00:35:48,110 --> 00:35:53,620
and then in the RB 3 for each in each

00:35:51,620 --> 00:35:56,360
node we are going to find a linked list

00:35:53,620 --> 00:35:58,730
so the operation looks like we are going

00:35:56,360 --> 00:36:01,430
to hash the key and that is going to

00:35:58,730 --> 00:36:03,860
give us the robbery tree and then we can

00:36:01,430 --> 00:36:06,500
we are going to perform the lookup on

00:36:03,860 --> 00:36:08,060
that key on the arbitrate that we obtain

00:36:06,500 --> 00:36:14,780
and that we are going to get a list and

00:36:08,060 --> 00:36:18,850
then in that list we have a we have con

00:36:14,780 --> 00:36:23,330
notes this disc on limit notes are not

00:36:18,850 --> 00:36:26,510
are not contract objects but they

00:36:23,330 --> 00:36:29,300
basically store the connection tracking

00:36:26,510 --> 00:36:31,900
topple so basically the idea when when

00:36:29,300 --> 00:36:34,130
column it was done was to avoid

00:36:31,900 --> 00:36:35,980
dependencies between direct dependencies

00:36:34,130 --> 00:36:38,720
with between the connection tracking and

00:36:35,980 --> 00:36:41,269
called limit itself and avoid brief

00:36:38,720 --> 00:36:44,519
reference counting and so on

00:36:41,269 --> 00:36:46,650
so and there is a garbage collector that

00:36:44,519 --> 00:36:47,849
is going to run from the packet path

00:36:46,650 --> 00:36:49,710
that is going to remove the stale

00:36:47,849 --> 00:36:53,039
objects basically that garbage collector

00:36:49,710 --> 00:37:00,059
what is doing is that for each packet is

00:36:53,039 --> 00:37:03,029
going to look at 4:44 a matching color

00:37:00,059 --> 00:37:06,569
limit note but if there is not while

00:37:03,029 --> 00:37:09,359
while walking on on the list

00:37:06,569 --> 00:37:13,619
it's going to check for called limits

00:37:09,359 --> 00:37:17,400
notes are stale and in and they are

00:37:13,619 --> 00:37:19,619
going to be removed so this this

00:37:17,400 --> 00:37:21,660
approach of doing the garbage collecting

00:37:19,619 --> 00:37:27,750
from from from the packet path is

00:37:21,660 --> 00:37:33,900
because called limit is designed to to

00:37:27,750 --> 00:37:36,210
overcome scenarios where we have an

00:37:33,900 --> 00:37:43,740
attacker is going to create many many

00:37:36,210 --> 00:37:45,509
many many many many flows so the idea is

00:37:43,740 --> 00:37:48,839
to not to wait for a garbage collector

00:37:45,509 --> 00:37:52,789
from from user context to run just to

00:37:48,839 --> 00:37:55,710
that garbage collection from from the

00:37:52,789 --> 00:37:58,619
from the packet path so this is how a

00:37:55,710 --> 00:38:00,809
cool limit index index tables work so

00:37:58,619 --> 00:38:02,609
now then saurian he came up with an F

00:38:00,809 --> 00:38:06,720
cone count infrastructure so basically

00:38:02,609 --> 00:38:08,759
the idea was he just plays the code that

00:38:06,720 --> 00:38:12,660
is that could be shared between an F

00:38:08,759 --> 00:38:18,299
tables and IP tables so the the original

00:38:12,660 --> 00:38:21,390
API was basically quite simple just an

00:38:18,299 --> 00:38:26,789
initialize function that I was going to

00:38:21,390 --> 00:38:30,359
give us this hash table plus RP 3 plus

00:38:26,789 --> 00:38:32,549
lists and then a way to destroy that and

00:38:30,359 --> 00:38:35,519
then a way to count just passing that

00:38:32,549 --> 00:38:38,339
data structure and a key and the topple

00:38:35,519 --> 00:38:40,259
and his own it was going to tell us this

00:38:38,339 --> 00:38:43,380
is the amount of connections that are

00:38:40,259 --> 00:38:46,529
actually matching this key criteria but

00:38:43,380 --> 00:38:51,220
then I extend that myself to support at

00:38:46,529 --> 00:38:55,549
least API so basically the idea is to

00:38:51,220 --> 00:38:58,609
just to extract the least data structure

00:38:55,549 --> 00:39:00,770
that we have because the goal was to

00:38:58,609 --> 00:39:05,599
reuse the existing enough table set

00:39:00,770 --> 00:39:13,400
infrastructure instead of instead of

00:39:05,599 --> 00:39:15,740
instead of building again this is the

00:39:13,400 --> 00:39:20,180
structures that we already had in in in

00:39:15,740 --> 00:39:23,750
a generic way and if tables so what I

00:39:20,180 --> 00:39:25,700
did is just it was just to take exactly

00:39:23,750 --> 00:39:27,680
whatever what it was the bare minimum

00:39:25,700 --> 00:39:30,589
thing that we could that we could reuse

00:39:27,680 --> 00:39:33,380
so this this API is allowing us to make

00:39:30,589 --> 00:39:36,589
lookups on the list to check for a given

00:39:33,380 --> 00:39:38,750
topple that is matching cities own and

00:39:36,589 --> 00:39:44,150
then this added flag is something that

00:39:38,750 --> 00:39:46,460
it's going to signal us that that that

00:39:44,150 --> 00:39:51,140
entry was not found and that we can add

00:39:46,460 --> 00:39:52,940
it there is the odd interface that we

00:39:51,140 --> 00:39:55,549
can use to add new notes and and then

00:39:52,940 --> 00:40:01,970
the free is going to just release the

00:39:55,549 --> 00:40:07,270
list so from the user playing from the

00:40:01,970 --> 00:40:07,270
NFT command-line this looks like this

00:40:07,329 --> 00:40:15,410
basically we have a new extension study

00:40:13,220 --> 00:40:17,240
the NFT and the score column limit that

00:40:15,410 --> 00:40:20,930
this new extension is going to store

00:40:17,240 --> 00:40:24,140
just the list of con limit objects so it

00:40:20,930 --> 00:40:27,230
no hash table no arbitrary so then you

00:40:24,140 --> 00:40:31,760
have to create a set then in case the

00:40:27,230 --> 00:40:36,230
criteria is going to be lets say the IP

00:40:31,760 --> 00:40:43,510
ve the ipv4 address and then we are just

00:40:36,230 --> 00:40:46,549
going to refer to that set from the rule

00:40:43,510 --> 00:40:48,200
3 is also in case I mean a very very

00:40:46,549 --> 00:40:51,819
simple way to use this would would be

00:40:48,200 --> 00:40:54,890
just to involve city count and then

00:40:51,819 --> 00:40:57,500
check if the if it's matching so if we

00:40:54,890 --> 00:41:00,289
are having more than two connections and

00:40:57,500 --> 00:41:03,070
then drop this is something that we

00:41:00,289 --> 00:41:06,980
don't support in IP tables

00:41:03,070 --> 00:41:11,840
but the smart way and the way to to

00:41:06,980 --> 00:41:13,370
actually achieve exactly a mapping with

00:41:11,840 --> 00:41:15,400
what we have in every tables is to

00:41:13,370 --> 00:41:21,020
combine it with with the meters or

00:41:15,400 --> 00:41:23,870
actually just dynamic dynamic sets so

00:41:21,020 --> 00:41:26,750
the idea would be to basically in the

00:41:23,870 --> 00:41:31,040
example there we are just matching new

00:41:26,750 --> 00:41:34,460
connections go into port 22 to SSH and

00:41:31,040 --> 00:41:37,070
then this meter XY set is basically a

00:41:34,460 --> 00:41:39,620
set is going to be dynamically populated

00:41:37,070 --> 00:41:45,920
from the packet path so based on the

00:41:39,620 --> 00:41:47,300
ipv4 source address for each IP ipv4

00:41:45,920 --> 00:41:51,670
source address we are going to add an

00:41:47,300 --> 00:41:55,400
entry into the XY set set or meter as is

00:41:51,670 --> 00:41:59,660
as it is in this example and then for

00:41:55,400 --> 00:42:03,640
each entry if the current limit counter

00:41:59,660 --> 00:42:07,160
goes over to then we are going just to

00:42:03,640 --> 00:42:08,570
count because of that counter expression

00:42:07,160 --> 00:42:12,050
that we have and then reject that

00:42:08,570 --> 00:42:13,430
connection so something to be done yeah

00:42:12,050 --> 00:42:15,080
it is something that we don't support in

00:42:13,430 --> 00:42:16,970
every table so basically with the con

00:42:15,080 --> 00:42:18,830
limit super NFC we're going to way more

00:42:16,970 --> 00:42:23,240
things and in a view tables we can just

00:42:18,830 --> 00:42:26,210
we can we can exactly mimic the the the

00:42:23,240 --> 00:42:28,550
same behavior but we can also the fixed

00:42:26,210 --> 00:42:30,680
policies using the the object

00:42:28,550 --> 00:42:33,470
infrastructure so you can create a city

00:42:30,680 --> 00:42:38,150
counter object and this city counter

00:42:33,470 --> 00:42:39,470
object let's call it bad guy one we are

00:42:38,150 --> 00:42:41,720
going to set a policy that is going to

00:42:39,470 --> 00:42:44,840
be over to and then also by what bad guy

00:42:41,720 --> 00:42:49,100
it to and set a policy of if connections

00:42:44,840 --> 00:42:50,960
go over six then match and then from the

00:42:49,100 --> 00:42:52,790
rule we are going to refer to these two

00:42:50,960 --> 00:42:58,400
these objects and we could use a map to

00:42:52,790 --> 00:43:01,310
quickly find what city counter objects

00:42:58,400 --> 00:43:03,800
is going to be applied so it's it's

00:43:01,310 --> 00:43:07,460
basically as you can read their a CD

00:43:03,800 --> 00:43:10,730
count name and then based on the ipv4

00:43:07,460 --> 00:43:13,720
address we are going to look up for the

00:43:10,730 --> 00:43:16,690
object that represents the

00:43:13,720 --> 00:43:19,480
the current limit policy this is this is

00:43:16,690 --> 00:43:22,330
this synthesis is tentative so it's not

00:43:19,480 --> 00:43:24,970
yet implemented we can probably use an F

00:43:22,330 --> 00:43:28,570
T ad called limit instead of City

00:43:24,970 --> 00:43:30,490
counter or something like that so it's

00:43:28,570 --> 00:43:32,830
something that needs yet to be reviewed

00:43:30,490 --> 00:43:35,230
but the idea is the infrastructure is is

00:43:32,830 --> 00:43:38,770
already there in the kernel so it's just

00:43:35,230 --> 00:43:40,870
matter of supporting so as I said we

00:43:38,770 --> 00:43:43,000
could use any any key criteria to

00:43:40,870 --> 00:43:46,240
implement con con limit so it's not that

00:43:43,000 --> 00:43:49,120
we have to stick to ipv4 source or

00:43:46,240 --> 00:43:50,950
destination address something else is

00:43:49,120 --> 00:43:52,690
this harsh Allah has been working on

00:43:50,950 --> 00:43:54,670
this it's not a corner another feature

00:43:52,690 --> 00:43:59,230
is missing in left tables that is define

00:43:54,670 --> 00:44:01,390
grain timeout support so in IP tables we

00:43:59,230 --> 00:44:05,080
have the NF net link CD timeout

00:44:01,390 --> 00:44:08,170
infrastructure that in in that allows

00:44:05,080 --> 00:44:12,780
you to specify to specify timeout

00:44:08,170 --> 00:44:15,160
policies for connection tracking for

00:44:12,780 --> 00:44:19,990
given a number of connections that are

00:44:15,160 --> 00:44:22,570
matching some criteria so because

00:44:19,990 --> 00:44:25,030
sometimes the global the global timeout

00:44:22,570 --> 00:44:27,220
policy that is available for connection

00:44:25,030 --> 00:44:30,370
tracking is not it's not fitting well

00:44:27,220 --> 00:44:35,470
for what you need so the work that she

00:44:30,370 --> 00:44:37,600
is done basically is to to to us support

00:44:35,470 --> 00:44:39,760
for what we was missing the kernel and

00:44:37,600 --> 00:44:43,210
then in the control plane we will have

00:44:39,760 --> 00:44:45,640
something like these we will create city

00:44:43,210 --> 00:44:46,930
timeout objects and then you are going

00:44:45,640 --> 00:44:48,760
to set a name for the policy you're

00:44:46,930 --> 00:44:51,070
going to apply do you have to restrict

00:44:48,760 --> 00:44:54,880
the police to a given layer for protocol

00:44:51,070 --> 00:44:59,650
and then you can specify the timeouts if

00:44:54,880 --> 00:45:01,900
you don't if you don't refer to any

00:44:59,650 --> 00:45:04,480
specific timeout we are going to use the

00:45:01,900 --> 00:45:07,240
default value so in this case we just

00:45:04,480 --> 00:45:09,490
define a policy one for TCP that is just

00:45:07,240 --> 00:45:11,860
going to reuse the existing timeout but

00:45:09,490 --> 00:45:13,260
for establish or for in wait are going

00:45:11,860 --> 00:45:15,760
to they are going to use different

00:45:13,260 --> 00:45:17,290
different values wait wait shorter so

00:45:15,760 --> 00:45:19,960
it's a way more aggressive timeout

00:45:17,290 --> 00:45:21,970
policy you could also device policy to

00:45:19,960 --> 00:45:24,790
and then again you can look up for the

00:45:21,970 --> 00:45:26,680
policy using Maps very quickly so the

00:45:24,790 --> 00:45:27,520
city time model is going to be apply

00:45:26,680 --> 00:45:31,120
it's going to be

00:45:27,520 --> 00:45:33,130
on the ipv4 source address and then we

00:45:31,120 --> 00:45:35,770
are going to take the the policy that

00:45:33,130 --> 00:45:38,320
that applies we could we could not just

00:45:35,770 --> 00:45:40,780
use IP for source address but we could

00:45:38,320 --> 00:45:44,650
also use any concatenation any key that

00:45:40,780 --> 00:45:46,990
is actually supported by NF tables so

00:45:44,650 --> 00:45:50,920
it's just very fast way to look up for

00:45:46,990 --> 00:45:52,480
policies and apply them there were

00:45:50,920 --> 00:45:54,520
discussions to internet photo workshop

00:45:52,480 --> 00:45:56,050
also about bridge no filter I don't know

00:45:54,520 --> 00:45:57,640
if you're familiar with this piece of

00:45:56,050 --> 00:46:02,100
code but it's the piece of code that is

00:45:57,640 --> 00:46:05,640
enabling interaction of IP tables with

00:46:02,100 --> 00:46:07,900
with the bridge layer so basically this

00:46:05,640 --> 00:46:13,750
infrastructure would worked like it

00:46:07,900 --> 00:46:16,630
follows one you take a bridge packet

00:46:13,750 --> 00:46:19,750
then to you you turn it into something

00:46:16,630 --> 00:46:21,580
that looks like an IP packet and by

00:46:19,750 --> 00:46:23,470
doing so you have to touch the routing

00:46:21,580 --> 00:46:25,630
information so it is a touching a fake

00:46:23,470 --> 00:46:28,360
round and then it's injected into the IP

00:46:25,630 --> 00:46:30,400
net for two hooks so it was kind of a

00:46:28,360 --> 00:46:32,680
hack that was done at the time to

00:46:30,400 --> 00:46:35,380
provide transparent access to the IP

00:46:32,680 --> 00:46:38,020
tables features so by the time this was

00:46:35,380 --> 00:46:41,020
written IP tables was IP tables and IP

00:46:38,020 --> 00:46:44,440
six tables were already offering way way

00:46:41,020 --> 00:46:52,320
more features than than what ebay table

00:46:44,440 --> 00:46:55,890
supports so so this is kind of software

00:46:52,320 --> 00:46:58,090
kind of glue code that was made to

00:46:55,890 --> 00:47:00,730
problem with this infrastructure is that

00:46:58,090 --> 00:47:02,260
there are a number of corner cases that

00:47:00,730 --> 00:47:04,930
we are aware of that are not working

00:47:02,260 --> 00:47:08,050
exactly that is not working exactly the

00:47:04,930 --> 00:47:11,440
way the user is expecting so it's it has

00:47:08,050 --> 00:47:14,500
its own problems it it requires a match

00:47:11,440 --> 00:47:18,760
specific fist step match that allows you

00:47:14,500 --> 00:47:22,330
to match the original input or awkward

00:47:18,760 --> 00:47:25,060
interface for the packet given that for

00:47:22,330 --> 00:47:30,070
bridge packets the the the input

00:47:25,060 --> 00:47:31,900
interface is going to be the bridge the

00:47:30,070 --> 00:47:34,330
it's performing also header is stripping

00:47:31,900 --> 00:47:35,620
like for example removing pppoe that is

00:47:34,330 --> 00:47:38,510
something that it was not going to be

00:47:35,620 --> 00:47:43,010
fine for IP tables itself

00:47:38,510 --> 00:47:45,410
and so basically many of these

00:47:43,010 --> 00:47:51,110
discussions were about how to remove s

00:47:45,410 --> 00:47:53,120
key B and F breach field because we

00:47:51,110 --> 00:47:55,790
cannot use the control buffer because

00:47:53,120 --> 00:47:57,950
the packet has been rejected well by

00:47:55,790 --> 00:48:02,930
when we injected into into the net

00:47:57,950 --> 00:48:05,150
filter hooks we could go we could just

00:48:02,930 --> 00:48:10,460
specifically for for local packets they

00:48:05,150 --> 00:48:12,290
could go into the real IP stack and it

00:48:10,460 --> 00:48:13,880
was going to override what we have in

00:48:12,290 --> 00:48:17,660
the control buffer so it's not the right

00:48:13,880 --> 00:48:20,270
area to use it so we we are not in full

00:48:17,660 --> 00:48:21,890
control on the control buffer so another

00:48:20,270 --> 00:48:24,260
possibility that is what Florian is

00:48:21,890 --> 00:48:27,790
proposing is to just to scratch one

00:48:24,260 --> 00:48:32,770
single bit in the escape buff and then

00:48:27,790 --> 00:48:36,830
have keep a hash-table to restore these

00:48:32,770 --> 00:48:40,280
state information basically this NF

00:48:36,830 --> 00:48:43,760
breach info structure is just annotating

00:48:40,280 --> 00:48:46,340
all the mangling that we are doing in

00:48:43,760 --> 00:48:49,430
the packet to make it look like like

00:48:46,340 --> 00:48:52,100
native IP packet something to restore

00:48:49,430 --> 00:48:55,460
bad things to make it when drain ejected

00:48:52,100 --> 00:48:59,600
dream getting it back to the bridge so

00:48:55,460 --> 00:49:01,550
it's it's kind of a scratch pad area so

00:48:59,600 --> 00:49:03,770
the idea would be to place all this

00:49:01,550 --> 00:49:08,180
information a hash table use the escape

00:49:03,770 --> 00:49:10,280
address to perform the lookups another

00:49:08,180 --> 00:49:12,590
topic was the flow table bypass is

00:49:10,280 --> 00:49:18,230
something that is already upstream since

00:49:12,590 --> 00:49:19,580
January this year it's an idea that we

00:49:18,230 --> 00:49:21,980
already discussed in the previous

00:49:19,580 --> 00:49:24,410
conference but given that it's been

00:49:21,980 --> 00:49:27,050
upstream I think it's relevant to talk

00:49:24,410 --> 00:49:30,950
about it again and make a second pass to

00:49:27,050 --> 00:49:31,670
see to describe how it's how it is

00:49:30,950 --> 00:49:34,490
looking like

00:49:31,670 --> 00:49:37,280
so basically configuration is quite

00:49:34,490 --> 00:49:39,500
simple barely with one flow table off

00:49:37,280 --> 00:49:42,200
jet and then with one single rule you

00:49:39,500 --> 00:49:46,730
can specify what flows are going to

00:49:42,200 --> 00:49:50,360
follow this flow table bypass so there

00:49:46,730 --> 00:49:51,600
you define a flow table F and then that

00:49:50,360 --> 00:49:53,810
flow table F

00:49:51,600 --> 00:49:56,340
you have to specify where to hook it

00:49:53,810 --> 00:49:58,530
it's going to be at the ingress so far

00:49:56,340 --> 00:50:01,230
the only hope that we support for it and

00:49:58,530 --> 00:50:04,350
then priority allows you to in case that

00:50:01,230 --> 00:50:06,210
you have a filter chain and an F tables

00:50:04,350 --> 00:50:08,730
to filter traffic from an ingress you

00:50:06,210 --> 00:50:11,160
could also place that chain before the

00:50:08,730 --> 00:50:14,490
flow table thing and then you have to

00:50:11,160 --> 00:50:19,950
specify what what interfaces are going

00:50:14,490 --> 00:50:23,580
to be bound to to this flow table just

00:50:19,950 --> 00:50:24,780
eth0 on one simple configuration and

00:50:23,580 --> 00:50:28,230
then from the chain we are going to

00:50:24,780 --> 00:50:30,600
specify that TCP packets are going to be

00:50:28,230 --> 00:50:33,270
added to this flow table and that means

00:50:30,600 --> 00:50:35,160
that the connection tracking system is

00:50:33,270 --> 00:50:37,380
not going to be responsible for that

00:50:35,160 --> 00:50:43,740
flow anymore that's why we get this

00:50:37,380 --> 00:50:47,340
offload flag and then what it happens is

00:50:43,740 --> 00:50:50,010
that every time a packet kicks in from

00:50:47,340 --> 00:50:52,020
the ingress hook we are going to make a

00:50:50,010 --> 00:50:55,110
lookup at the flow table if there is an

00:50:52,020 --> 00:50:58,350
entry then we follow the fast path for

00:50:55,110 --> 00:51:00,690
the fast path we are just basically

00:50:58,350 --> 00:51:03,780
going to take the packet the flow table

00:51:00,690 --> 00:51:05,490
entry is storing is catching the route

00:51:03,780 --> 00:51:07,050
so we are going to touch the route to

00:51:05,490 --> 00:51:09,360
the packet and we are just going to push

00:51:07,050 --> 00:51:11,190
it out to the neighbor layer front rest

00:51:09,360 --> 00:51:12,810
for transmission so we are going we're

00:51:11,190 --> 00:51:17,220
going to bypass the classic forwarding

00:51:12,810 --> 00:51:22,470
path if the packet doesn't have an entry

00:51:17,220 --> 00:51:24,300
in the flow table it means that it is it

00:51:22,470 --> 00:51:28,590
is a packet that we are seeing for first

00:51:24,300 --> 00:51:29,820
time or that we didn't confirm yet that

00:51:28,590 --> 00:51:32,750
we want to place in the flow table

00:51:29,820 --> 00:51:36,510
because because the rule that we

00:51:32,750 --> 00:51:39,390
specified to do we specifically used to

00:51:36,510 --> 00:51:41,640
specify what flows our place in the flow

00:51:39,390 --> 00:51:45,150
table could use any matching criteria we

00:51:41,640 --> 00:51:47,640
could postpone our in the entry into the

00:51:45,150 --> 00:51:51,600
flow table after for example ten packets

00:51:47,640 --> 00:51:54,390
or apply any any matching criteria

00:51:51,600 --> 00:51:55,890
actually so it's not that from the first

00:51:54,390 --> 00:52:00,120
packet this is going to apply it right

00:51:55,890 --> 00:52:01,650
so so once for these packets that don't

00:52:00,120 --> 00:52:03,720
follow the fast path we just follow the

00:52:01,650 --> 00:52:05,070
classic forwarding path so they go

00:52:03,720 --> 00:52:07,050
pouring the

00:52:05,070 --> 00:52:09,450
we do the routing decision and then if

00:52:07,050 --> 00:52:11,190
it's not for us we go forward and then

00:52:09,450 --> 00:52:15,390
for the forward chain is where we can

00:52:11,190 --> 00:52:17,460
place this flow of load action so the

00:52:15,390 --> 00:52:20,310
flow of a flow of blood action has been

00:52:17,460 --> 00:52:23,610
done in a way that so the this is admin

00:52:20,310 --> 00:52:26,730
is aware that all the laws that are

00:52:23,610 --> 00:52:28,650
being forward can be placed into the

00:52:26,730 --> 00:52:30,450
flow table right so because locally

00:52:28,650 --> 00:52:35,910
generated traffic needs to follow the

00:52:30,450 --> 00:52:38,360
classic path so so that's how it looks

00:52:35,910 --> 00:52:40,500
like this is just about their bows

00:52:38,360 --> 00:52:42,330
explanation of that says for each packet

00:52:40,500 --> 00:52:45,090
we extract a topple we perform that look

00:52:42,330 --> 00:52:47,070
up there is a mist we follow the classic

00:52:45,090 --> 00:52:49,770
forwarding path and if there is a hit we

00:52:47,070 --> 00:52:51,510
attach the route and then if the packet

00:52:49,770 --> 00:52:54,140
is over empty you then need suspicion

00:52:51,510 --> 00:52:57,270
handling so I need to follow slow path

00:52:54,140 --> 00:52:58,890
the flow table infrastructure I forgot

00:52:57,270 --> 00:53:04,710
to mention but it integrates with with

00:52:58,890 --> 00:53:06,720
the NAT infrastructure so we are going

00:53:04,710 --> 00:53:10,620
to apply from the flow table path not

00:53:06,720 --> 00:53:14,040
mangling the needs to be done also TTL

00:53:10,620 --> 00:53:15,420
is going to be decremented and then we

00:53:14,040 --> 00:53:18,060
just send the packet through through

00:53:15,420 --> 00:53:23,280
neighbor or ex meet so it's a garbage

00:53:18,060 --> 00:53:26,480
collector that is removing flow table

00:53:23,280 --> 00:53:30,420
entries for which we haven't seen

00:53:26,480 --> 00:53:32,040
packets for a while but there is also in

00:53:30,420 --> 00:53:34,830
the case of TCP there is a mechanism

00:53:32,040 --> 00:53:36,420
that allows us to to to give back

00:53:34,830 --> 00:53:40,380
control to the connection tracking

00:53:36,420 --> 00:53:42,870
system that is basically for TCP reset

00:53:40,380 --> 00:53:45,150
and same packets we pass them with

00:53:42,870 --> 00:53:50,130
bustin up to - classic for warning path

00:53:45,150 --> 00:53:57,300
again so so we can again from reevaluate

00:53:50,130 --> 00:54:01,140
what to do with it in software just a

00:53:57,300 --> 00:54:05,060
pure flow table approach it was it is

00:54:01,140 --> 00:54:07,650
already reporting better numbers is

00:54:05,060 --> 00:54:13,050
close to three times faster that a

00:54:07,650 --> 00:54:15,000
classic rewarding path I was using one

00:54:13,050 --> 00:54:17,280
of the scripts that is in in the kernel

00:54:15,000 --> 00:54:18,109
tree one single CPU and a smallest

00:54:17,280 --> 00:54:22,700
packet size and

00:54:18,109 --> 00:54:25,190
Piketty Jen so it's already

00:54:22,700 --> 00:54:28,039
significantly faster and then there is

00:54:25,190 --> 00:54:36,319
another topic that is the hardware

00:54:28,039 --> 00:54:40,880
offload support so Nick switches they

00:54:36,319 --> 00:54:45,789
are coming with with tables with

00:54:40,880 --> 00:54:45,789
infrastructures that allows us to define

00:54:46,059 --> 00:54:50,630
fast rewarding path of pockets on all

00:54:48,529 --> 00:54:51,440
paths to decide to the CPU to the host

00:54:50,630 --> 00:54:54,650
right

00:54:51,440 --> 00:54:58,430
so there is to add infrastructure to it

00:54:54,650 --> 00:55:00,470
- - that integrates to the flow table to

00:54:58,430 --> 00:55:07,549
the flow table soft representation so we

00:55:00,470 --> 00:55:09,440
can get by enabling one flag we can we

00:55:07,549 --> 00:55:12,460
can specify we can we can inquire we can

00:55:09,440 --> 00:55:15,589
tell the colonel - to use the the

00:55:12,460 --> 00:55:19,130
hardware offload support if it's

00:55:15,589 --> 00:55:22,249
available in this in the given piece of

00:55:19,130 --> 00:55:23,900
hardware so so if in case know that in

00:55:22,249 --> 00:55:25,640
case that the hardware doesn't come with

00:55:23,900 --> 00:55:28,190
support from highway offload from the

00:55:25,640 --> 00:55:30,109
control plane we are we are just going

00:55:28,190 --> 00:55:31,519
to react that we is going to say no we

00:55:30,109 --> 00:55:33,950
don't support this what we can do is

00:55:31,519 --> 00:55:35,779
software only so we have the software

00:55:33,950 --> 00:55:39,140
only mode and it is the hardware

00:55:35,779 --> 00:55:40,849
supported through these offload slack we

00:55:39,140 --> 00:55:42,739
are going to turn on and then packets

00:55:40,849 --> 00:55:44,359
are not going to only a few packets are

00:55:42,739 --> 00:55:48,410
going to follow the the software path

00:55:44,359 --> 00:55:51,220
and then follow our packets with they

00:55:48,410 --> 00:55:53,569
will follow as soon as we configure the

00:55:51,220 --> 00:55:56,180
the hardware offload facility they will

00:55:53,569 --> 00:56:00,019
follow the the hardware path so they are

00:55:56,180 --> 00:56:03,140
not going to be seen by the host this

00:56:00,019 --> 00:56:07,809
infrastructure also is can can be mixed

00:56:03,140 --> 00:56:12,309
with it seems that with with typical

00:56:07,809 --> 00:56:16,059
routers with wireless and switch

00:56:12,309 --> 00:56:16,059
chipsets that

00:56:17,700 --> 00:56:25,990
that provider and a facility that allows

00:56:20,380 --> 00:56:29,080
allows us to inject packets in what they

00:56:25,990 --> 00:56:32,230
call some in the inner transmit transmit

00:56:29,080 --> 00:56:34,090
path it's just a way to so both chipsets

00:56:32,230 --> 00:56:35,590
can enter edit each other it's something

00:56:34,090 --> 00:56:40,750
that can be supported also with this

00:56:35,590 --> 00:56:42,310
infrastructure so and that is there are

00:56:40,750 --> 00:56:44,740
a number of vendors already interested

00:56:42,310 --> 00:56:46,150
in this the infrastructure is quite a

00:56:44,740 --> 00:56:47,920
small is only two hundred lines of code

00:56:46,150 --> 00:56:52,840
the generic how we offload

00:56:47,920 --> 00:56:56,650
infrastructure and then the needed code

00:56:52,840 --> 00:56:59,590
from the driver side that's all so so

00:56:56,650 --> 00:57:03,790
hopefully we will get a client for this

00:56:59,590 --> 00:57:08,110
code soon so we can upstream it we need

00:57:03,790 --> 00:57:11,130
also either one new and the old hook or

00:57:08,110 --> 00:57:15,580
we could reuse the existing TC setup

00:57:11,130 --> 00:57:17,620
hook for it so I spent a significant

00:57:15,580 --> 00:57:22,450
amount of time talking to to Jericho and

00:57:17,620 --> 00:57:25,450
also due to other switch maintained

00:57:22,450 --> 00:57:26,920
years and outcome of that discussion was

00:57:25,450 --> 00:57:33,700
that it will be good to have one single

00:57:26,920 --> 00:57:35,320
entry point and so probably will the see

00:57:33,700 --> 00:57:41,860
soon patches on in the in that direction

00:57:35,320 --> 00:57:45,640
on the mailing list yes and another

00:57:41,860 --> 00:57:47,530
derivative work related to the flow

00:57:45,640 --> 00:57:53,320
table infrastructure is at PAX said that

00:57:47,530 --> 00:57:56,800
was sent just weeks ago that is provided

00:57:53,320 --> 00:57:59,410
any fast warning path so basically the

00:57:56,800 --> 00:58:06,850
idea is to do to do the lookup even

00:57:59,410 --> 00:58:10,150
earlier and so not at ingress but from

00:58:06,850 --> 00:58:14,950
from the year-old layer so it's way

00:58:10,150 --> 00:58:18,040
before the tabs and overall ideas to

00:58:14,950 --> 00:58:20,230
avoid reiterative raleigh lookups and

00:58:18,040 --> 00:58:21,880
combine it with gr all on engine so we

00:58:20,230 --> 00:58:23,680
could do batching just basically the

00:58:21,880 --> 00:58:28,900
idea is to create a chain of escape

00:58:23,680 --> 00:58:31,450
buffs and then pass this chain to the

00:58:28,900 --> 00:58:35,930
neighbor ex meet path

00:58:31,450 --> 00:58:37,310
so this this chain of ska buffs is

00:58:35,930 --> 00:58:40,250
something that the classic rewarding

00:58:37,310 --> 00:58:42,110
path that doesn't doesn't cannot cannot

00:58:40,250 --> 00:58:43,850
handle a movement we will need to make

00:58:42,110 --> 00:58:46,610
way more changes to the customer body

00:58:43,850 --> 00:58:50,390
parts to to get advantage from this new

00:58:46,610 --> 00:58:52,340
representation so but to keep so to keep

00:58:50,390 --> 00:58:55,550
it simple given that this chain of

00:58:52,340 --> 00:58:56,810
packet was what's going to trigger lots

00:58:55,550 --> 00:59:01,160
of changes for the casting forwarding

00:58:56,810 --> 00:59:02,750
path we just considered that they were

00:59:01,160 --> 00:59:05,630
just going to follow the neighborhood

00:59:02,750 --> 00:59:08,300
Smit path and custom forwarding path is

00:59:05,630 --> 00:59:09,890
not going to see them so and then in

00:59:08,300 --> 00:59:12,080
case that there is no matching there is

00:59:09,890 --> 00:59:13,910
no entering the flow table what we do is

00:59:12,080 --> 00:59:17,119
we just follow this low path that is

00:59:13,910 --> 00:59:24,740
just pass the packet to the generic ero

00:59:17,119 --> 00:59:27,710
handler so configuration is as I said

00:59:24,740 --> 00:59:30,230
quite simple as the only change is that

00:59:27,710 --> 00:59:34,820
you have to specify this new ally angers

00:59:30,230 --> 00:59:36,740
hook and then from the policy on the

00:59:34,820 --> 00:59:38,930
forward chain you are going to specify

00:59:36,740 --> 00:59:42,830
what flows are placed into into the flow

00:59:38,930 --> 00:59:46,430
table and then Stefan was collecting

00:59:42,830 --> 00:59:49,730
some numbers in his step that's bad so

00:59:46,430 --> 00:59:52,910
basically the the this new fast warding

00:59:49,730 --> 00:59:57,410
path was performing faster than TCP with

00:59:52,910 --> 01:00:00,140
TSO thing is that this chain of packets

00:59:57,410 --> 01:00:01,970
we cannot the driver cannot use TSO

01:00:00,140 --> 01:00:06,200
because it's even need even need

01:00:01,970 --> 01:00:08,119
actually euro hardware support to to

01:00:06,200 --> 01:00:10,550
take advantage of advantage from this

01:00:08,119 --> 01:00:13,010
new representation so well basically it

01:00:10,550 --> 01:00:16,490
was slightly just slightly faster than

01:00:13,010 --> 01:00:20,869
TSO but for three DP we really get

01:00:16,490 --> 01:00:24,980
better numbers so it's it's modern

01:00:20,869 --> 01:00:26,960
double right and and also a significant

01:00:24,980 --> 01:00:28,700
improvement for for ESP so when

01:00:26,960 --> 01:00:31,220
combining this infrastructure with IP

01:00:28,700 --> 01:00:34,720
sets also built IPSec also things were

01:00:31,220 --> 01:00:37,670
going faster so

01:00:34,720 --> 01:00:40,420
yeah stiff and you were here and in case

01:00:37,670 --> 01:00:44,150
you want to say anything

01:00:40,420 --> 01:00:47,590
yeah so that's it yes there are there

01:00:44,150 --> 01:00:49,730
are recent patches from Edward Cree the

01:00:47,590 --> 01:00:51,590
following us like add a slightly

01:00:49,730 --> 01:00:55,220
different approach so basically he's

01:00:51,590 --> 01:00:56,750
adding new infrastructure to instead of

01:00:55,220 --> 01:00:59,060
using the G ro

01:00:56,750 --> 01:01:01,760
layer it's just new infrastructure that

01:00:59,060 --> 01:01:07,960
allows us to build this chain of SK

01:01:01,760 --> 01:01:07,960
buffs and we can probably explore

01:01:08,770 --> 01:01:18,950
rewriting this this flat set on top of

01:01:11,690 --> 01:01:21,940
that and yes this is what I have so in

01:01:18,950 --> 01:01:21,940
case you have any question

01:01:24,680 --> 01:01:27,680
Mike

01:01:32,560 --> 01:01:40,400
did you check the your purchase after

01:01:36,710 --> 01:01:42,890
applying the edward edward scree patch

01:01:40,400 --> 01:01:47,510
that improves performance with the lists

01:01:42,890 --> 01:01:52,849
and the UDP segmentation no I

01:01:47,510 --> 01:01:55,070
didn't know yeah not yes yes yes our

01:01:52,849 --> 01:01:57,710
idea the idea is to have a look at what

01:01:55,070 --> 01:02:01,220
Edward has done and see if we can

01:01:57,710 --> 01:02:02,990
combine this but said with his idea with

01:02:01,220 --> 01:02:13,070
this Whitney infrastructure that he's

01:02:02,990 --> 01:02:15,080
providing hi Rajesh Khanna at Red Hat so

01:02:13,070 --> 01:02:18,410
for the connection tracking offload with

01:02:15,080 --> 01:02:20,480
hard Hardware offload it's been more

01:02:18,410 --> 01:02:23,380
than a year since it's been percolating

01:02:20,480 --> 01:02:26,000
on the side and you presented that

01:02:23,380 --> 01:02:28,070
you're waiting for the drivers and the

01:02:26,000 --> 01:02:30,790
hardware vendors are waiting on you so

01:02:28,070 --> 01:02:33,230
it seems to be like a log jam or a

01:02:30,790 --> 01:02:35,390
contentious issue so how do we move

01:02:33,230 --> 01:02:38,000
along how how can we work together to

01:02:35,390 --> 01:02:40,730
make it accelerate and have it offloaded

01:02:38,000 --> 01:02:42,470
because all the obvious offload is not

01:02:40,730 --> 01:02:45,200
working right now because every single

01:02:42,470 --> 01:02:47,270
OpenStack use case and ovn use case

01:02:45,200 --> 01:02:50,180
needs connection tracking mm-hmm

01:02:47,270 --> 01:02:51,890
so all that good work is there in place

01:02:50,180 --> 01:02:53,599
it's part of the distributions but

01:02:51,890 --> 01:02:55,700
without connection tracking it's all

01:02:53,599 --> 01:02:57,200
goes to the software path so how do we

01:02:55,700 --> 01:02:59,450
accelerate this how do we get to the

01:02:57,200 --> 01:03:02,630
next step yeah that's a very good

01:02:59,450 --> 01:03:05,030
question I mean I mean so far it's

01:03:02,630 --> 01:03:09,339
process seems to be the process is

01:03:05,030 --> 01:03:11,599
rather slow I mean actually a bit

01:03:09,339 --> 01:03:15,140
disappointing with with the pace but

01:03:11,599 --> 01:03:17,869
it's it's it's going to happen at some

01:03:15,140 --> 01:03:19,910
point and hopefully I mean I've been

01:03:17,869 --> 01:03:21,470
receiving probably emails from from many

01:03:19,910 --> 01:03:24,140
hardware vendors that are making

01:03:21,470 --> 01:03:27,440
progress and hopefully we'll get a

01:03:24,140 --> 01:03:30,770
driver anytime soon I was expecting to

01:03:27,440 --> 01:03:32,390
get these faster really but yeah and

01:03:30,770 --> 01:03:34,700
it's not something that depend on me but

01:03:32,390 --> 01:03:40,730
I mean I'm just doing all what I can or

01:03:34,700 --> 01:03:43,630
the best to to to speed it up so I will

01:03:40,730 --> 01:03:46,300
be very very glad to see a driver soon

01:03:43,630 --> 01:03:48,790
hi honey for Mellanox so we are working

01:03:46,300 --> 01:03:51,430
on that I think in the netfilter you met

01:03:48,790 --> 01:03:55,150
the two guys from three guys from Elinor

01:03:51,430 --> 01:03:58,330
start working on that we having now

01:03:55,150 --> 01:04:02,170
appears internally that's is using your

01:03:58,330 --> 01:04:04,540
code and and TC together in order to

01:04:02,170 --> 01:04:07,540
have an obvious offload for that and of

01:04:04,540 --> 01:04:10,810
course when we have some RFC code that

01:04:07,540 --> 01:04:14,680
we can share we will share it and want

01:04:10,810 --> 01:04:17,200
to have it as si you say read it said we

01:04:14,680 --> 01:04:19,150
want to have the idea is to have an

01:04:17,200 --> 01:04:21,010
obvious offload that can do the

01:04:19,150 --> 01:04:25,000
connection tracking and do a harder

01:04:21,010 --> 01:04:27,060
awful for that so we see it from a lot

01:04:25,000 --> 01:04:29,220
of customers that that were to be needin

01:04:27,060 --> 01:04:31,720
that's what we're doing

01:04:29,220 --> 01:04:35,560
yeah that's great I mean and so I hope

01:04:31,720 --> 01:04:38,770
at the end of the year hopefully we can

01:04:35,560 --> 01:04:42,940
get it in oh that's great yes yes yes I

01:04:38,770 --> 01:04:44,680
got it but also from from open wrt and

01:04:42,940 --> 01:04:46,300
they are working on a date on a

01:04:44,680 --> 01:04:48,370
different segment in the in the hardware

01:04:46,300 --> 01:04:50,920
market with with smaller smaller

01:04:48,370 --> 01:04:55,780
chipsets and they seem to be also making

01:04:50,920 --> 01:04:59,640
progress they told me so hopefully we

01:04:55,780 --> 01:05:02,980
can we can get one of these drivers will

01:04:59,640 --> 01:05:06,240
soon land in the tree and so we can

01:05:02,980 --> 01:05:08,110
justify inclusion of this new hardware

01:05:06,240 --> 01:05:09,580
infrastructure this generic

01:05:08,110 --> 01:05:11,140
infrastructure - super hard we're all

01:05:09,580 --> 01:05:13,060
flawed into the kernel because without

01:05:11,140 --> 01:05:17,530
without a client it's not justified I

01:05:13,060 --> 01:05:21,700
mean the the software speed-up is was

01:05:17,530 --> 01:05:24,580
was good enough to to justify the

01:05:21,700 --> 01:05:27,850
software infrastructure itself but to go

01:05:24,580 --> 01:05:29,350
a step further we need a client to mean

01:05:27,850 --> 01:05:30,670
- to get the hardware offload

01:05:29,350 --> 01:05:35,680
infrastructure we obviously need a

01:05:30,670 --> 01:05:37,500
client another question we've got

01:05:35,680 --> 01:05:41,110
connection tracking do we have some

01:05:37,500 --> 01:05:44,650
testing of performance of how many flow

01:05:41,110 --> 01:05:48,400
we can create in a second because we

01:05:44,650 --> 01:05:50,560
also start with the obvious that's

01:05:48,400 --> 01:05:52,450
working through TC to add rules and then

01:05:50,560 --> 01:05:54,460
we understand that's okay we're talking

01:05:52,450 --> 01:05:55,690
about a lot of rules when we talk a lot

01:05:54,460 --> 01:05:58,599
it's mean million

01:05:55,690 --> 01:06:00,400
and when everything was in the software

01:05:58,599 --> 01:06:02,079
so the numbers was low because the

01:06:00,400 --> 01:06:03,520
performance was low when we're taking

01:06:02,079 --> 01:06:06,670
them to the heart rate when we talk

01:06:03,520 --> 01:06:09,880
about 100 Gig Nick and we can process

01:06:06,670 --> 01:06:13,180
more than 20 million packets per second

01:06:09,880 --> 01:06:15,220
inside the harbor so all the numbers are

01:06:13,180 --> 01:06:18,750
is going up and the number of flows is

01:06:15,220 --> 01:06:20,799
going up so do we have some benchmark or

01:06:18,750 --> 01:06:23,770
things that's done for connection

01:06:20,799 --> 01:06:26,859
tracking that's we know how what is the

01:06:23,770 --> 01:06:27,490
maximum number do you have some test in

01:06:26,859 --> 01:06:30,730
that area

01:06:27,490 --> 01:06:33,670
I got reports from people that have it

01:06:30,730 --> 01:06:38,619
have been evaluating it and they report

01:06:33,670 --> 01:06:41,200
millions of entries per second so okay

01:06:38,619 --> 01:06:42,700
so it's good news yeah because when we

01:06:41,200 --> 01:06:46,349
start to work with this you understand

01:06:42,700 --> 01:06:49,900
that TC didn't scale well with number of

01:06:46,349 --> 01:06:53,670
million routes so now we've do some

01:06:49,900 --> 01:06:57,599
fixes there in order to do improve it

01:06:53,670 --> 01:07:03,160
yes I think I think yes I think the main

01:06:57,599 --> 01:07:05,500
main constraint so far is it's having

01:07:03,160 --> 01:07:09,180
the driver in so we can we can start

01:07:05,500 --> 01:07:12,700
collecting numbers and also measuring

01:07:09,180 --> 01:07:14,380
what is the magnitude of the boost that

01:07:12,700 --> 01:07:18,099
the hardware offload is going to provide

01:07:14,380 --> 01:07:24,309
and and so on but the software planes so

01:07:18,099 --> 01:07:26,799
far I mean it's it's fine and the

01:07:24,309 --> 01:07:28,750
numbers we that I got reported is they

01:07:26,799 --> 01:07:30,490
are also good enough so I don't think I

01:07:28,750 --> 01:07:33,490
would inspect the bottleneck on that

01:07:30,490 --> 01:07:36,970
okay so numbers of millions is not

01:07:33,490 --> 01:07:40,480
something that is new to you it's

01:07:36,970 --> 01:07:43,770
something that's worked in the past yes

01:07:40,480 --> 01:07:43,770
ok good news

01:07:48,340 --> 01:07:52,420
yes if you have any other question

01:08:05,369 --> 01:08:10,769
hello question about the flow table

01:08:07,650 --> 01:08:12,539
mechanism I wonder is it that currently

01:08:10,769 --> 01:08:15,150
it's used only for forwarding packets

01:08:12,539 --> 01:08:17,580
right but would it be usable as a

01:08:15,150 --> 01:08:20,989
generic kind of a flawed mechanism for

01:08:17,580 --> 01:08:25,279
example if packets Traverse like Sdn

01:08:20,989 --> 01:08:28,940
architec like Sdn interfaces inside the

01:08:25,279 --> 01:08:31,230
network stack for example then then

01:08:28,940 --> 01:08:32,909
subsequent packets that for example go

01:08:31,230 --> 01:08:34,679
to a specific MAC a villain can go

01:08:32,909 --> 01:08:37,319
directly there using the flow table

01:08:34,679 --> 01:08:38,849
would it be yes you mean you mean this

01:08:37,319 --> 01:08:40,199
or more information on the flow table

01:08:38,849 --> 01:08:42,569
and actions or what to do with the

01:08:40,199 --> 01:08:44,869
packet right so we just get a packet and

01:08:42,569 --> 01:08:47,489
then we do the VLAN and we push it out

01:08:44,869 --> 01:08:49,469
things like about it stuff like that for

01:08:47,489 --> 01:08:53,000
example or for example if the packet is

01:08:49,469 --> 01:08:55,830
locally destined but still we would

01:08:53,000 --> 01:08:57,299
avoid although for example if it's a Mac

01:08:55,830 --> 01:08:59,670
villain then we would avoid the hash

01:08:57,299 --> 01:09:03,719
table or just go directly to the man yes

01:08:59,670 --> 01:09:05,279
yes that should be possible I think this

01:09:03,719 --> 01:09:07,589
is basically this is basically going in

01:09:05,279 --> 01:09:12,299
the in the direction of there is a very

01:09:07,589 --> 01:09:14,099
old RFC from Rossi Russell it's probably

01:09:12,299 --> 01:09:15,480
more than ten years old and he was

01:09:14,099 --> 01:09:22,049
proposed in something like the ground

01:09:15,480 --> 01:09:24,540
only fide flow catch and it's basically

01:09:22,049 --> 01:09:26,580
going in in the in what it's basically

01:09:24,540 --> 01:09:29,369
describing what would you what you're

01:09:26,580 --> 01:09:30,869
telling so it's just accumulate all

01:09:29,369 --> 01:09:32,969
actions all things that need to be done

01:09:30,869 --> 01:09:35,580
on the packet just do one lookup and

01:09:32,969 --> 01:09:38,759
then push it all to the destination to

01:09:35,580 --> 01:09:40,259
the interface what you need so yes I

01:09:38,759 --> 01:09:42,119
think I think this could be extended to

01:09:40,259 --> 01:09:45,509
to achieve all that kind of flexibility

01:09:42,119 --> 01:09:49,380
and also it will be interesting to

01:09:45,509 --> 01:09:51,980
explore what hard work can do because

01:09:49,380 --> 01:09:54,719
the more things we can map to hardware

01:09:51,980 --> 01:09:58,110
we can the more we can consider

01:09:54,719 --> 01:10:01,800
extensions of that infrastructure to to

01:09:58,110 --> 01:10:05,330
enable those fast paths with with with

01:10:01,800 --> 01:10:05,330
the flexibility that we need

01:10:07,210 --> 01:10:11,870
so so regarding the hardware who said we

01:10:10,430 --> 01:10:14,600
can we know that's how you can do it

01:10:11,870 --> 01:10:18,050
that's we're already in today doing with

01:10:14,600 --> 01:10:21,710
it instead with the TC infrastructure

01:10:18,050 --> 01:10:23,840
and of course now I think that is a good

01:10:21,710 --> 01:10:26,270
place that's it's coming from the

01:10:23,840 --> 01:10:30,560
connection tracking that we will have a

01:10:26,270 --> 01:10:33,469
single end do so hardware offload then

01:10:30,560 --> 01:10:35,719
we can from the hardware perspective the

01:10:33,469 --> 01:10:39,350
driver we will have a single interface

01:10:35,719 --> 01:10:43,160
that configure everything suits can will

01:10:39,350 --> 01:10:45,730
work the same so all those all those

01:10:43,160 --> 01:10:48,680
requests to have an open flow

01:10:45,730 --> 01:10:50,600
infrastructure to the driver will be a

01:10:48,680 --> 01:10:54,440
single interface because today we are

01:10:50,600 --> 01:10:58,370
supporting obvious offload that is also

01:10:54,440 --> 01:11:00,680
kind of open flow and we are today we're

01:10:58,370 --> 01:11:03,350
going through TC to do that to make it

01:11:00,680 --> 01:11:07,160
to take it to the outer but of course

01:11:03,350 --> 01:11:09,620
netfilter n ft it's from our the same so

01:11:07,160 --> 01:11:15,219
we just need to have an API that's will

01:11:09,620 --> 01:11:15,219
call yeah a fatty

01:11:18,700 --> 01:11:24,430
any other question something to discuss

01:11:28,809 --> 01:11:33,280
yeah I would like to say thanks to

01:11:30,309 --> 01:11:34,840
Mellanox for me some Nicks that will

01:11:33,280 --> 01:11:36,610
allow me to test this infrastructure

01:11:34,840 --> 01:11:41,440
when we want once we get the driver and

01:11:36,610 --> 01:11:47,400
also I have received hardware from other

01:11:41,440 --> 01:11:51,869
vendors so I'm always glad to receive

01:11:47,400 --> 01:11:56,889
any piece of hardware the composition is

01:11:51,869 --> 01:11:59,320
can potentially be used to they can

01:11:56,889 --> 01:12:03,789
potentially be extended to support to

01:11:59,320 --> 01:12:06,309
support this offloads so so just let me

01:12:03,789 --> 01:12:08,909
know in case that you have something

01:12:06,309 --> 01:12:12,369
that I can have a look so it's always

01:12:08,909 --> 01:12:16,270
good when designing infrastructure to

01:12:12,369 --> 01:12:20,530
know what hard work can do so we we just

01:12:16,270 --> 01:12:23,770
keep an eye on on implementing things in

01:12:20,530 --> 01:12:25,389
a way that the divisions that already

01:12:23,770 --> 01:12:33,909
cover the use cases that we are going to

01:12:25,389 --> 01:12:35,390
need so just let me know okay thank you

01:12:33,909 --> 01:12:40,770
very much

01:12:35,390 --> 01:12:40,770

YouTube URL: https://www.youtube.com/watch?v=0hqfzp6tpZo


