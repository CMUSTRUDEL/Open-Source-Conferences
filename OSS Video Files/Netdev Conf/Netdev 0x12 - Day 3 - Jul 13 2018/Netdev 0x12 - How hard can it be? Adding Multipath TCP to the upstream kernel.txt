Title: Netdev 0x12 - How hard can it be? Adding Multipath TCP to the upstream kernel
Publication date: 2018-08-01
Playlist: Netdev 0x12 - Day 3 - Jul 13 2018
Description: 
	Mat Martineau, Matthieu Baerts, Christoph Paasch, and Peter Krystad have been working on kernel Multipath TCP (RFC 6824) support.

There have been difficulties in the past in upstreaming this implementation due to its invasive architecture; however, the authors feel that they have better understanding since the last time they showed up at netdev conf 0.1:
The current MPTCP implementation has moved from it research-y origins and is already used by millions of devices in production environments. The protocol standardization is also now complete. For these reasons the authors feel that experience has gained them a lot of insight and they are ready to move forward with upstreaming.

In this talk, Mat Martineau and Matthieu Baerts gave a gentle introduction of Multipath TCP and mentioned some uses cases already in production. They discussed the challenges faced - both resolved and
ongoing. More importantly they looked for feedback on how to best revamp the current implementation for upstreaming purposes.

This talk takes place on July 13th, 2018 at Netdev 0x12 in Montreal.

More info:
https://www.netdevconf.org/0x12/session.html?how-hard-can-it-be-adding-multipath-tcp-to-the-upstream-kernel
Captions: 
	00:00:00,030 --> 00:00:06,089
all right so we also have Eric Tim as it

00:00:04,560 --> 00:00:09,719
was remote he's going to participate in

00:00:06,089 --> 00:00:11,990
this let this start let's get started

00:00:09,719 --> 00:00:11,990
thing

00:00:17,970 --> 00:00:22,920
welcome to this presentation about

00:00:19,830 --> 00:00:24,990
multipath TCP and here we will mainly

00:00:22,920 --> 00:00:28,439
talk about how hard it can be to add

00:00:24,990 --> 00:00:31,859
multiple TCP to the upstream kernel so

00:00:28,439 --> 00:00:33,059
we are here with matt martino from intel

00:00:31,859 --> 00:00:34,980
i'm matsuba

00:00:33,059 --> 00:00:37,620
from tessa res but we also have a

00:00:34,980 --> 00:00:40,829
Christoph part for me Intel and Peter

00:00:37,620 --> 00:00:43,829
Chris that from from Apple sorry and

00:00:40,829 --> 00:00:46,770
Chris and Peter Chris ad from Inter they

00:00:43,829 --> 00:00:49,520
are both in the audience of course

00:00:46,770 --> 00:00:51,870
please feel free to interrupt us

00:00:49,520 --> 00:00:53,879
especially if you have crazy ideas about

00:00:51,870 --> 00:00:58,109
how to solve the challenges that we will

00:00:53,879 --> 00:00:59,760
present and yeah if you are disturbing

00:00:58,109 --> 00:01:01,379
because we are both much you here don't

00:00:59,760 --> 00:01:02,940
hesitate to just ask question to

00:01:01,379 --> 00:01:07,740
Christophe over there it will maybe be

00:01:02,940 --> 00:01:11,400
easier okay so we will start with an

00:01:07,740 --> 00:01:13,200
introduction of multipath TCP but this

00:01:11,400 --> 00:01:16,200
time we're not going too deeply into

00:01:13,200 --> 00:01:18,180
details about this protocol first

00:01:16,200 --> 00:01:20,909
because the protocol is what it is we

00:01:18,180 --> 00:01:22,500
cannot change it and secondly because

00:01:20,909 --> 00:01:25,229
it's not the first time that we are

00:01:22,500 --> 00:01:28,259
presenting multipath TCP and let def not

00:01:25,229 --> 00:01:30,990
us and particularly but what we will do

00:01:28,259 --> 00:01:32,340
is just to present a few bits to

00:01:30,990 --> 00:01:36,869
understand the challenge that we are

00:01:32,340 --> 00:01:40,650
facing so or goal here is to explain why

00:01:36,869 --> 00:01:42,869
multipass TCP is super cool so why we

00:01:40,650 --> 00:01:45,210
need it upstream but also to get some

00:01:42,869 --> 00:01:47,579
feedback to start discussion about the

00:01:45,210 --> 00:01:50,180
design what we have started and what we

00:01:47,579 --> 00:01:50,180
will do later

00:01:50,479 --> 00:01:56,460
so about multipath TCP in one sentence

00:01:53,790 --> 00:01:58,649
it allowed to exchange data for a signal

00:01:56,460 --> 00:02:01,590
connection of indifferent paths and it

00:01:58,649 --> 00:02:03,750
can be simultaneously so we are breaking

00:02:01,590 --> 00:02:07,200
the assumption that one connection is

00:02:03,750 --> 00:02:09,270
linked to 5-tuple so thanks to that we

00:02:07,200 --> 00:02:11,640
can have more redundancy we can have

00:02:09,270 --> 00:02:15,420
more bandwidth we can support some and

00:02:11,640 --> 00:02:17,610
overall mobility use cases it's not a

00:02:15,420 --> 00:02:19,830
new protocol because there is an RFC

00:02:17,610 --> 00:02:24,630
about that there is also working at the

00:02:19,830 --> 00:02:26,700
IETF and so it's not new in the linux

00:02:24,630 --> 00:02:30,990
world because the first implementation

00:02:26,700 --> 00:02:34,320
started in march 2009 there were many

00:02:30,990 --> 00:02:35,790
version before that we also support most

00:02:34,320 --> 00:02:38,850
of the latest

00:02:35,790 --> 00:02:43,020
LTS kernel and we are still supporting

00:02:38,850 --> 00:02:45,840
the latest one also it's not new in

00:02:43,020 --> 00:02:48,810
production because mptp is already

00:02:45,840 --> 00:02:50,880
neighbor on million of devices and our

00:02:48,810 --> 00:02:55,560
different use case that we will present

00:02:50,880 --> 00:02:57,480
just after this so speaking about use

00:02:55,560 --> 00:02:59,519
cases we have the first one

00:02:57,480 --> 00:03:03,030
it's the classical one it's about the

00:02:59,519 --> 00:03:06,860
smartphone use case and more

00:03:03,030 --> 00:03:10,530
specifically about walk out scenario

00:03:06,860 --> 00:03:13,140
it's many kind of famous with multiple

00:03:10,530 --> 00:03:15,510
ccp with voice streaming application and

00:03:13,140 --> 00:03:17,940
virtual assistance so we have for

00:03:15,510 --> 00:03:20,060
example siri in iOS they start it with

00:03:17,940 --> 00:03:22,950
that but it's important to note that

00:03:20,060 --> 00:03:26,010
multipass tcp was also in some samsung

00:03:22,950 --> 00:03:29,489
and LG android phone but only in some

00:03:26,010 --> 00:03:32,489
countries like South Korea so if we come

00:03:29,489 --> 00:03:34,320
back to the use case with Siri you can

00:03:32,489 --> 00:03:37,350
imagine that you have real smart phone

00:03:34,320 --> 00:03:40,260
your ad you are Tomo at your auto and

00:03:37,350 --> 00:03:43,079
what you are connected to the Wi-Fi and

00:03:40,260 --> 00:03:45,030
you want to get some very important

00:03:43,079 --> 00:03:47,940
information like where you can find the

00:03:45,030 --> 00:03:50,100
best poutine in Montreal so you are

00:03:47,940 --> 00:03:52,410
doing that you are getting out and what

00:03:50,100 --> 00:03:55,260
happened of course you are going to be

00:03:52,410 --> 00:03:56,700
slowly disconnected from the Wi-Fi but

00:03:55,260 --> 00:03:58,019
as you all know it's difficult to know

00:03:56,700 --> 00:04:02,519
when you are really disconnected

00:03:58,019 --> 00:04:03,930
especially for the server side so when

00:04:02,519 --> 00:04:06,150
you are in this situation without

00:04:03,930 --> 00:04:08,970
multipath TCP you will need to have a

00:04:06,150 --> 00:04:12,480
new connection to retransmit the data

00:04:08,970 --> 00:04:14,700
maybe and that's the only solution that

00:04:12,480 --> 00:04:17,100
can be costly and then can be

00:04:14,700 --> 00:04:18,810
frustrating especially for the user but

00:04:17,100 --> 00:04:20,340
don't forget also about Siri because

00:04:18,810 --> 00:04:23,280
they got the answer but they were not

00:04:20,340 --> 00:04:25,350
able to provide this answer to the to

00:04:23,280 --> 00:04:28,640
the user very frustrating

00:04:25,350 --> 00:04:32,640
so thanks to multipath TCP you can have

00:04:28,640 --> 00:04:35,000
two connection one it's one multipath

00:04:32,640 --> 00:04:38,190
TCP connection but you will have to TCP

00:04:35,000 --> 00:04:41,730
connection under that one over the Wi-Fi

00:04:38,190 --> 00:04:43,290
one over the cellular network and thanks

00:04:41,730 --> 00:04:46,260
to the if you are getting disconnected

00:04:43,290 --> 00:04:48,150
with the same scenario then that's not

00:04:46,260 --> 00:04:50,270
an issue because you can directly have

00:04:48,150 --> 00:04:53,340
packet going over the cellular network

00:04:50,270 --> 00:04:59,000
so if you know the Wi-Fi that's fine

00:04:53,340 --> 00:05:01,440
it's really transparent for the user

00:04:59,000 --> 00:05:02,940
another use get a time that we would

00:05:01,440 --> 00:05:06,540
like to present here is the one about

00:05:02,940 --> 00:05:09,150
hybrid access network so it has been

00:05:06,540 --> 00:05:11,310
discussed at the broadband forum there

00:05:09,150 --> 00:05:13,590
is a technical document the technical

00:05:11,310 --> 00:05:16,140
report document about that and it's

00:05:13,590 --> 00:05:19,680
reported by Tesla as Swiss come and OVH

00:05:16,140 --> 00:05:23,730
companies for example so what they saw

00:05:19,680 --> 00:05:25,710
is that the telco operate or they have

00:05:23,730 --> 00:05:28,590
some client that are very far from the

00:05:25,710 --> 00:05:31,680
DSL street cabinet it's very difficult

00:05:28,590 --> 00:05:34,800
and also very very costly for them for

00:05:31,680 --> 00:05:38,880
these few people to get a better

00:05:34,800 --> 00:05:41,040
internet connection one solution for

00:05:38,880 --> 00:05:44,250
that because many tell cooperate or they

00:05:41,040 --> 00:05:47,550
already own both the cellular and fixed

00:05:44,250 --> 00:05:52,920
network they could combine in fact the

00:05:47,550 --> 00:05:56,610
two networks to get better bandwidth so

00:05:52,920 --> 00:05:58,950
to do that it's kind of simple but trust

00:05:56,610 --> 00:06:01,680
me it's not for the software parameters

00:05:58,950 --> 00:06:06,030
for the software company but you can

00:06:01,680 --> 00:06:09,270
have a TCP to MP TCP proxy you can put

00:06:06,030 --> 00:06:10,890
it in the DSL CPE and then you have the

00:06:09,270 --> 00:06:13,500
TCP connection coming from the

00:06:10,890 --> 00:06:16,350
smartphone the laptop etc they go to the

00:06:13,500 --> 00:06:18,600
router the router is doing a proxy to be

00:06:16,350 --> 00:06:20,640
able to use both the fixed and mobile

00:06:18,600 --> 00:06:23,580
network and use the available capacity

00:06:20,640 --> 00:06:25,710
of the cellular network for example of

00:06:23,580 --> 00:06:28,110
course you will need the N server to

00:06:25,710 --> 00:06:33,470
support multi pass tcp so it's easier to

00:06:28,110 --> 00:06:33,470
put an server at the telco cloud

00:06:33,970 --> 00:06:39,670
so that's it for the use cases when yeah

00:06:37,240 --> 00:06:42,250
I have to admit that we were expecting

00:06:39,670 --> 00:06:44,740
at this point to have some shouting in

00:06:42,250 --> 00:06:47,290
the audience saying that odd and P TCP

00:06:44,740 --> 00:06:50,710
does Oh Sun but why it's nothing in

00:06:47,290 --> 00:06:52,510
upstream while it's not in the stream

00:06:50,710 --> 00:06:56,110
and it's maybe easy to say that but it's

00:06:52,510 --> 00:06:58,570
quite complex and we will explain why it

00:06:56,110 --> 00:07:04,060
is so complicated to add multipass TCP

00:06:58,570 --> 00:07:06,940
in the kernel so first I have a perfect

00:07:04,060 --> 00:07:10,690
audience to say that Linux TCP is highly

00:07:06,940 --> 00:07:14,650
optimized so any change can become can

00:07:10,690 --> 00:07:17,140
be complex to introduce I already talked

00:07:14,650 --> 00:07:20,980
about the current implementation it

00:07:17,140 --> 00:07:23,710
works very well but first it had been

00:07:20,980 --> 00:07:26,860
built to support experiment and rapid

00:07:23,710 --> 00:07:30,040
changes but it's kind of not generic

00:07:26,860 --> 00:07:32,890
enough by generic enough we want to say

00:07:30,040 --> 00:07:35,370
that usually the vendor or the current

00:07:32,890 --> 00:07:38,669
vendor they can't figure the system to

00:07:35,370 --> 00:07:41,320
have it working for their use case

00:07:38,669 --> 00:07:43,330
sometime even the vendor they fully

00:07:41,320 --> 00:07:45,580
control all the environment the

00:07:43,330 --> 00:07:49,150
end-to-end environment so it's kind of

00:07:45,580 --> 00:07:52,870
easy to use this kernel it's also

00:07:49,150 --> 00:07:55,960
important to note that most user or all

00:07:52,870 --> 00:07:58,860
user of this kernel and they use it

00:07:55,960 --> 00:08:01,300
because they want to have MP TCP support

00:07:58,860 --> 00:08:08,470
so it's not a big deal if we are

00:08:01,300 --> 00:08:10,150
affecting TCP connections but we we

00:08:08,470 --> 00:08:13,630
wanted to create a new group and that's

00:08:10,150 --> 00:08:17,020
what we we did to upstream multipass TCP

00:08:13,630 --> 00:08:19,150
because we want it upstream but we also

00:08:17,020 --> 00:08:22,990
want to have the new implementation that

00:08:19,150 --> 00:08:25,180
doesn't affect the TCP stack so we don't

00:08:22,990 --> 00:08:27,430
want to introduce any performance

00:08:25,180 --> 00:08:29,040
regression if it's possible we want to

00:08:27,430 --> 00:08:31,050
have something easy to maintain

00:08:29,040 --> 00:08:33,599
straightforward to configure and

00:08:31,050 --> 00:08:36,099
something that can be used in variety of

00:08:33,599 --> 00:08:41,650
deployment not without modifying the

00:08:36,099 --> 00:08:43,690
kernel for example one last important

00:08:41,650 --> 00:08:47,130
point maybe the most important why it is

00:08:43,690 --> 00:08:51,010
so complicated is that MPT kids may

00:08:47,130 --> 00:08:53,320
extension to TCP and it overlaps so much

00:08:51,010 --> 00:08:57,640
with it so we could think that impede

00:08:53,320 --> 00:09:01,120
see Pete does this theory just on top of

00:08:57,640 --> 00:09:03,910
the of some TCP flow that we can that we

00:09:01,120 --> 00:09:06,390
also called TCP sub flow and you have

00:09:03,910 --> 00:09:09,010
just a nice the prevention of the layers

00:09:06,390 --> 00:09:12,910
but we will see later that there are a

00:09:09,010 --> 00:09:14,680
lot of interaction between the layers

00:09:12,910 --> 00:09:17,320
the different layers and of course it's

00:09:14,680 --> 00:09:22,570
the theory is not really what we have in

00:09:17,320 --> 00:09:26,820
practice the prom that we have are

00:09:22,570 --> 00:09:29,620
mainly linked to the protocol challenges

00:09:26,820 --> 00:09:32,260
so we'll just present here just a few

00:09:29,620 --> 00:09:36,910
example about the challenges that the

00:09:32,260 --> 00:09:40,750
protocol gave us where for example the

00:09:36,910 --> 00:09:43,120
TCP sequence number of course in TCP you

00:09:40,750 --> 00:09:45,130
need it to ensure the in order delivery

00:09:43,120 --> 00:09:47,680
we will need something like that for

00:09:45,130 --> 00:09:49,930
tests for mpg CP for the whole

00:09:47,680 --> 00:09:52,960
connection it's easy to understand that

00:09:49,930 --> 00:09:56,980
with just this schema here you want to

00:09:52,960 --> 00:10:00,190
send ABCDE F and you can see that you

00:09:56,980 --> 00:10:04,090
can send data over the the two sub

00:10:00,190 --> 00:10:06,760
flowed to the two paths so for that

00:10:04,090 --> 00:10:08,620
maybe you will have ABC EF on one pass

00:10:06,760 --> 00:10:11,260
and maybe that's what will come first

00:10:08,620 --> 00:10:14,980
and on C will come later so to solve

00:10:11,260 --> 00:10:17,680
that kind of easy it's like with TCP you

00:10:14,980 --> 00:10:20,290
need to add what we call a data sequence

00:10:17,680 --> 00:10:22,480
number if you do that you will know that

00:10:20,290 --> 00:10:26,620
ABC need to be delivered to the

00:10:22,480 --> 00:10:29,140
application before see the pro is that

00:10:26,620 --> 00:10:30,700
yeah that's good to have a data sequence

00:10:29,140 --> 00:10:32,770
number but we need to put it somewhere

00:10:30,700 --> 00:10:38,080
and we will need to put it in the TCP

00:10:32,770 --> 00:10:39,900
option that's what the protocol say so

00:10:38,080 --> 00:10:44,650
if we look at the different layer here

00:10:39,900 --> 00:10:46,870
the application will send the data so it

00:10:44,650 --> 00:10:49,380
will come from the socket layer to the

00:10:46,870 --> 00:10:52,600
MP TCP layer that's fine

00:10:49,380 --> 00:10:55,900
the impedes CPA layer simply select the

00:10:52,600 --> 00:10:58,380
TCP sub flow okay but then you are in

00:10:55,900 --> 00:11:00,270
the TCP stack here and

00:10:58,380 --> 00:11:03,030
that's the moment where we you will need

00:11:00,270 --> 00:11:04,950
to fill in the TCP header and that's so

00:11:03,030 --> 00:11:07,710
the moment where you will have to put

00:11:04,950 --> 00:11:08,850
the TCP option so what the SS you need

00:11:07,710 --> 00:11:10,950
to put in it

00:11:08,850 --> 00:11:13,860
so of course you will you are in the TCP

00:11:10,950 --> 00:11:19,110
stack but you will need to come back to

00:11:13,860 --> 00:11:21,450
the NPC p1 another challenge that we

00:11:19,110 --> 00:11:25,590
have with the protocol is the signaling

00:11:21,450 --> 00:11:28,320
options so for the signaling option we

00:11:25,590 --> 00:11:30,300
can come back to the you scale of the

00:11:28,320 --> 00:11:32,250
smartphone you are disconnected from the

00:11:30,300 --> 00:11:35,400
Wi-Fi and what you want to do is to

00:11:32,250 --> 00:11:37,650
signal to notify the end server that you

00:11:35,400 --> 00:11:41,430
had a problem with your Wi-Fi interface

00:11:37,650 --> 00:11:43,470
so it can remove the address so what

00:11:41,430 --> 00:11:49,790
happened is that you gotten into a

00:11:43,470 --> 00:11:53,210
notification MPCP got a notification so

00:11:49,790 --> 00:11:55,800
simple it will select the sub flow okay

00:11:53,210 --> 00:11:58,950
but here what happened is that the empty

00:11:55,800 --> 00:12:01,170
TCP layer need to send a TCP act with

00:11:58,950 --> 00:12:04,290
some particular option and that's

00:12:01,170 --> 00:12:07,110
something that is not possible for the

00:12:04,290 --> 00:12:10,080
moment generation the Linux kernel so we

00:12:07,110 --> 00:12:14,340
will need to modify the TCP stack to be

00:12:10,080 --> 00:12:16,440
able to do that if we look at the other

00:12:14,340 --> 00:12:18,510
side when we received this remove

00:12:16,440 --> 00:12:22,530
address on the server side for example

00:12:18,510 --> 00:12:25,790
we will receive a TCP ack so it will go

00:12:22,530 --> 00:12:30,000
to the TCP stack but first it's not

00:12:25,790 --> 00:12:33,330
duplicate ACK it's a particular TCP ACK

00:12:30,000 --> 00:12:35,850
that for once will not be dropped it we

00:12:33,330 --> 00:12:38,760
need to go through the TCP stack and go

00:12:35,850 --> 00:12:41,450
to the MPCP step so that's awesome I

00:12:38,760 --> 00:12:44,910
chose the Queen to do to the TCP stack

00:12:41,450 --> 00:12:48,360
also what we can see here is that you

00:12:44,910 --> 00:12:54,330
receive something on one set flow and it

00:12:48,360 --> 00:12:56,760
effect another TCP saw flow we saw the

00:12:54,330 --> 00:12:58,500
problem here with with the remove

00:12:56,760 --> 00:13:01,470
address but there are also other

00:12:58,500 --> 00:13:05,000
signaling option with multipass tcp we

00:13:01,470 --> 00:13:05,000
will need to support of course

00:13:13,170 --> 00:13:22,810
hello so moving on from there the

00:13:18,510 --> 00:13:26,260
question is how how do we fit in with

00:13:22,810 --> 00:13:30,880
the existing code in in the net sub

00:13:26,260 --> 00:13:33,690
system so to start out there are some

00:13:30,880 --> 00:13:35,920
parts that actually do that

00:13:33,690 --> 00:13:41,260
you know integrate pretty well and

00:13:35,920 --> 00:13:46,300
that's where the implementation is is

00:13:41,260 --> 00:13:48,340
layered and that well excuse me where MP

00:13:46,300 --> 00:13:51,460
TCP has aspects that are nicely layered

00:13:48,340 --> 00:13:54,520
and there are parts of the networking

00:13:51,460 --> 00:13:56,730
subsystem then where the that aspect of

00:13:54,520 --> 00:14:00,840
the implementation is layered as well so

00:13:56,730 --> 00:14:04,060
what we can do is define our own

00:14:00,840 --> 00:14:06,670
prototype IP proto and P TCP and that

00:14:04,060 --> 00:14:09,130
allows us to create our own MP DCP sock

00:14:06,670 --> 00:14:11,380
as a top layer that's an intermediary

00:14:09,130 --> 00:14:15,490
for all the interaction between

00:14:11,380 --> 00:14:19,840
multipath TCP and user space and what

00:14:15,490 --> 00:14:27,510
that can do is then create our own TCP

00:14:19,840 --> 00:14:27,510
sockets like like RDS or RK CM and

00:14:27,690 --> 00:14:35,040
manage those decide what to get sent to

00:14:30,660 --> 00:14:37,770
each one and so forth then since we're

00:14:35,040 --> 00:14:41,490
using those sockets within the kernel we

00:14:37,770 --> 00:14:44,970
have a little more rich interfaces going

00:14:41,490 --> 00:14:49,470
down than just the regular socket API so

00:14:44,970 --> 00:14:53,430
for example we can set up the mapping

00:14:49,470 --> 00:15:00,830
data for multi path TCP packet configure

00:14:53,430 --> 00:15:06,170
that and then use TCP send pages to wrap

00:15:00,830 --> 00:15:11,880
wrap an skb around our outgoing data

00:15:06,170 --> 00:15:14,160
correlate that with the mapping data

00:15:11,880 --> 00:15:19,020
going out and continue from there and

00:15:14,160 --> 00:15:23,580
then on the on the input side we can

00:15:19,020 --> 00:15:28,110
have access to SK B's from the received

00:15:23,580 --> 00:15:30,290
queue which allows us to see the TCP

00:15:28,110 --> 00:15:33,150
sequence numbers which we again need to

00:15:30,290 --> 00:15:36,960
figure out what order to present things

00:15:33,150 --> 00:15:38,910
to the the user layer and then at the

00:15:36,960 --> 00:15:43,040
lower layer layer with the IP networking

00:15:38,910 --> 00:15:48,090
core we have per socket callbacks from

00:15:43,040 --> 00:15:49,680
from IP that led us add its represented

00:15:48,090 --> 00:15:54,150
on this diagram as the sub flow ops

00:15:49,680 --> 00:15:56,790
where we can sort of intercept the calls

00:15:54,150 --> 00:15:59,700
coming back for especially for incoming

00:15:56,790 --> 00:16:02,640
connections and do do a little extra

00:15:59,700 --> 00:16:08,630
work before before TCP sees the

00:16:02,640 --> 00:16:08,630
connections to to do what NP tcp means

00:16:09,050 --> 00:16:15,990
so fitting with the topic of our talk

00:16:13,950 --> 00:16:21,210
well what is what is the challenge here

00:16:15,990 --> 00:16:24,030
and one of them is indirect call

00:16:21,210 --> 00:16:26,220
inefficiency so you know as a si

00:16:24,030 --> 00:16:29,130
programmer that's kind of one of the one

00:16:26,220 --> 00:16:32,700
of the hammers you have to solve a

00:16:29,130 --> 00:16:35,220
problem is to take a direct function

00:16:32,700 --> 00:16:37,980
call that that does one specific thing

00:16:35,220 --> 00:16:41,640
and you know turn it into a pointer and

00:16:37,980 --> 00:16:44,070
then you can plug in what you need at

00:16:41,640 --> 00:16:46,020
you know configuration time so if we're

00:16:44,070 --> 00:16:48,810
creating a multipath TCP socket we could

00:16:46,020 --> 00:16:51,720
just say oh well call this instead and

00:16:48,810 --> 00:16:55,680
then and then carry on to the regular

00:16:51,720 --> 00:16:58,050
functionality from there but indirect

00:16:55,680 --> 00:17:03,440
calls are not as efficient as they used

00:16:58,050 --> 00:17:06,900
to be with with speculation disabled

00:17:03,440 --> 00:17:10,320
yeah it it was always necessary to

00:17:06,900 --> 00:17:12,089
justify adding an indirect you know

00:17:10,320 --> 00:17:13,829
replacing something a direct call with

00:17:12,089 --> 00:17:17,850
an indirect call but now it's very

00:17:13,829 --> 00:17:19,800
closely scrutinized and you know there's

00:17:17,850 --> 00:17:22,320
effort going into optimizing existing

00:17:19,800 --> 00:17:28,650
calls or even you know removing them as

00:17:22,320 --> 00:17:30,330
possible another limitation is that well

00:17:28,650 --> 00:17:32,970
another limitation that comes into play

00:17:30,330 --> 00:17:37,020
with multi path TCP is that we have this

00:17:32,970 --> 00:17:42,750
sort of correlated data mapping data

00:17:37,020 --> 00:17:44,760
between the the packet payload and the

00:17:42,750 --> 00:17:49,340
TCP options that we want to populate for

00:17:44,760 --> 00:17:51,260
that specific packet and the

00:17:49,340 --> 00:17:53,000
you know you look at the problem these

00:17:51,260 --> 00:17:55,100
things that seems obvious to do is okay

00:17:53,000 --> 00:17:58,460
well I just want to attach some extra

00:17:55,100 --> 00:18:02,360
data to each a packet and with struct sk

00:17:58,460 --> 00:18:06,020
buff and sk be shared info that is

00:18:02,360 --> 00:18:09,980
allocated along with the payload those

00:18:06,020 --> 00:18:12,980
are already you know we've got 232 320

00:18:09,980 --> 00:18:16,550
bytes and those already depending on

00:18:12,980 --> 00:18:17,990
your kernel configuration and we you

00:18:16,550 --> 00:18:20,390
know we don't want to make those bigger

00:18:17,990 --> 00:18:23,630
and and you know we can't the maintainer

00:18:20,390 --> 00:18:29,090
x' won't and we're not asking them to so

00:18:23,630 --> 00:18:33,820
we need to find alternate solutions so

00:18:29,090 --> 00:18:37,430
in terms of what we've been working on

00:18:33,820 --> 00:18:40,400
and the first thing here is something

00:18:37,430 --> 00:18:46,340
that we have sent as an RFC patch set to

00:18:40,400 --> 00:18:51,560
the net dev list already and in an

00:18:46,340 --> 00:18:54,140
approach to NP tcp we we took our our

00:18:51,560 --> 00:18:55,820
first strategy was to say well there

00:18:54,140 --> 00:18:58,010
there are places that we need to hook

00:18:55,820 --> 00:18:59,930
into the TCP stack there's existing

00:18:58,010 --> 00:19:01,790
functionality already in the TCP

00:18:59,930 --> 00:19:06,740
implementation that we think has some

00:19:01,790 --> 00:19:09,140
common requirements and so what if we

00:19:06,740 --> 00:19:12,020
you know built some common

00:19:09,140 --> 00:19:13,700
infrastructure we could introduce that

00:19:12,020 --> 00:19:16,430
we could refactor the existing

00:19:13,700 --> 00:19:20,770
functionality to take advantage of it

00:19:16,430 --> 00:19:25,850
and so the first thing we did was built

00:19:20,770 --> 00:19:29,330
an API that would let you register a set

00:19:25,850 --> 00:19:32,300
of handlers for specific TCP option

00:19:29,330 --> 00:19:34,760
numbers that would either parse them

00:19:32,300 --> 00:19:36,620
coming in or allow you to write them

00:19:34,760 --> 00:19:43,040
going out and just configure that per

00:19:36,620 --> 00:19:47,420
socket so we did that we refactored TCP

00:19:43,040 --> 00:19:49,310
md5 and SMC it had the benefits for the

00:19:47,420 --> 00:19:52,550
TCP core in terms of you know we were

00:19:49,310 --> 00:19:57,070
able to remove 53 if deaths for those

00:19:52,550 --> 00:19:59,919
two bits of functionality and net

00:19:57,070 --> 00:20:02,380
removed about 750 lines from the TCP

00:19:59,919 --> 00:20:04,299
core itself you know not not counting

00:20:02,380 --> 00:20:09,330
the md5 and SMC code that was moved off

00:20:04,299 --> 00:20:13,289
to you know specific files for those so

00:20:09,330 --> 00:20:15,909
we you know sent that out as an RFC and

00:20:13,289 --> 00:20:17,860
the two main pieces of feedback we got

00:20:15,909 --> 00:20:19,780
was you know one it was adding indirect

00:20:17,860 --> 00:20:23,020
calls and the timing for this was

00:20:19,780 --> 00:20:27,760
January 2018 so that was a hot topic at

00:20:23,020 --> 00:20:29,860
the time and still is and second thing

00:20:27,760 --> 00:20:34,390
was that when we submitted this it was

00:20:29,860 --> 00:20:37,960
since it only involved md5 and an SMC it

00:20:34,390 --> 00:20:40,179
did not give the the community of

00:20:37,960 --> 00:20:42,640
reviewers or maintainer x' perspective

00:20:40,179 --> 00:20:44,440
into how multipath tcp would use it so

00:20:42,640 --> 00:20:47,740
they they just didn't have that context

00:20:44,440 --> 00:20:50,400
when reviewing it so you know what

00:20:47,740 --> 00:20:54,510
submerged but we got that feedback to

00:20:50,400 --> 00:20:57,370
build MP TCP first and propose that and

00:20:54,510 --> 00:21:00,450
build abstraction later when we have

00:20:57,370 --> 00:21:05,020
when everybody has the context available

00:21:00,450 --> 00:21:06,460
another thing we're doing is reducing

00:21:05,020 --> 00:21:09,520
the amount of kernel code that we need

00:21:06,460 --> 00:21:10,960
in order to you know reach the full

00:21:09,520 --> 00:21:13,929
feature set eventually so there's

00:21:10,960 --> 00:21:17,020
certain functionality for multipath TCP

00:21:13,929 --> 00:21:20,380
kind of control plane connection with

00:21:17,020 --> 00:21:23,320
what we call path management where you

00:21:20,380 --> 00:21:27,850
establish additional TCP flows in

00:21:23,320 --> 00:21:30,640
parallel and so those are relative you

00:21:27,850 --> 00:21:33,250
know compared to the data plane those

00:21:30,640 --> 00:21:35,320
are relatively infrequent and not very

00:21:33,250 --> 00:21:38,140
latency sensitive so we can reduce our

00:21:35,320 --> 00:21:40,900
kernel footprint offer more flexibility

00:21:38,140 --> 00:21:44,860
in terms of how systems you know managed

00:21:40,900 --> 00:21:49,330
at policy for those operations

00:21:44,860 --> 00:21:54,159
and one more element of what code we've

00:21:49,330 --> 00:21:55,990
been sharing so we do have our own NPD

00:21:54,159 --> 00:21:57,460
CPF streaming community mailing list so

00:21:55,990 --> 00:22:01,590
that we can coordinate amongst each

00:21:57,460 --> 00:22:05,500
other and you know share ideas kind of

00:22:01,590 --> 00:22:07,450
get get our selves coordinated before

00:22:05,500 --> 00:22:09,220
sending proposals to net dev and one

00:22:07,450 --> 00:22:13,870
thing that we've shared in that context

00:22:09,220 --> 00:22:16,600
is addressing that's that problem of the

00:22:13,870 --> 00:22:19,269
the socket buffer is SK B's being a

00:22:16,600 --> 00:22:24,820
certain size and not having the space to

00:22:19,269 --> 00:22:28,210
add the data we wanted so modified SK

00:22:24,820 --> 00:22:30,880
buff well act more SK be shared info so

00:22:28,210 --> 00:22:34,600
that we could add additional payload at

00:22:30,880 --> 00:22:39,730
the end of the shared info and this this

00:22:34,600 --> 00:22:41,559
was transparent to normal users it was

00:22:39,730 --> 00:22:43,179
not it's not allocated for you know a

00:22:41,559 --> 00:22:46,990
regular TCP connection or anywhere else

00:22:43,179 --> 00:22:49,179
in the system and it could you know pass

00:22:46,990 --> 00:22:53,309
through the TCP stack and existing code

00:22:49,179 --> 00:22:58,029
transparently as well sure go ahead

00:22:53,309 --> 00:23:00,940
so I'm a little puzzled why SK buff

00:22:58,029 --> 00:23:02,500
isn't sufficient I think the implication

00:23:00,940 --> 00:23:06,070
here is I have to add a lot of data to

00:23:02,500 --> 00:23:10,120
it but it's not clear to me why and

00:23:06,070 --> 00:23:13,090
multipath TCP this becomes a major issue

00:23:10,120 --> 00:23:15,220
could you give examples of the actual

00:23:13,090 --> 00:23:18,840
data or what what's lacking from the a

00:23:15,220 --> 00:23:21,700
buff that FMP TCP need sure sure

00:23:18,840 --> 00:23:24,130
well to I mean for example the existing

00:23:21,700 --> 00:23:28,120
Linux implementation has it extends the

00:23:24,130 --> 00:23:29,799
SK buff control block to contain like

00:23:28,120 --> 00:23:33,700
the additional sequence numbers at the

00:23:29,799 --> 00:23:37,960
the top and TMP TCP level but I mean to

00:23:33,700 --> 00:23:41,620
to jump ahead like C B's there right so

00:23:37,960 --> 00:23:44,080
we have 40 bytes of space in an sk buff

00:23:41,620 --> 00:23:46,120
right and if you go in from TCP to MP

00:23:44,080 --> 00:23:48,679
TCP that's a private interface so that

00:23:46,120 --> 00:23:54,190
CB should be available are you using it

00:23:48,679 --> 00:23:56,629
um well the so the issue is that we need

00:23:54,190 --> 00:23:59,899
like for example when transmitting when

00:23:56,629 --> 00:24:01,490
we're supplying the map data that map

00:23:59,899 --> 00:24:03,619
data it needs to pass all the way

00:24:01,490 --> 00:24:05,360
through the TCP stack and be available

00:24:03,619 --> 00:24:07,580
when we're writing the options and so

00:24:05,360 --> 00:24:12,200
you know TCP itself is making use of the

00:24:07,580 --> 00:24:15,019
control block and and so you know we

00:24:12,200 --> 00:24:17,779
just don't have room to well I mean so

00:24:15,019 --> 00:24:21,139
NP TCP and TCP could be somewhat tightly

00:24:17,779 --> 00:24:23,899
coupled where if I send if I send from

00:24:21,139 --> 00:24:25,730
MP TCP and a TCP maybe just tell TCP oh

00:24:23,899 --> 00:24:27,740
yeah by the way that control block has a

00:24:25,730 --> 00:24:30,379
special meaning we're normally it might

00:24:27,740 --> 00:24:32,840
not or something like that okay so yeah

00:24:30,379 --> 00:24:34,759
I think this is this is a little risky

00:24:32,840 --> 00:24:36,980
if we go down the path we know we have

00:24:34,759 --> 00:24:40,129
to extend SK buffer this one specific

00:24:36,980 --> 00:24:43,070
protocol right that's that's a hard

00:24:40,129 --> 00:24:47,210
premise to start with exactly and and in

00:24:43,070 --> 00:24:50,690
implementing it we saw that and and also

00:24:47,210 --> 00:24:54,019
in in seeing like the complexity that

00:24:50,690 --> 00:24:57,230
was required to allocate and populate

00:24:54,019 --> 00:24:58,610
the extended control block and you know

00:24:57,230 --> 00:25:00,830
the fact that it's shared between

00:24:58,610 --> 00:25:02,119
different SK buff clones it's just kind

00:25:00,830 --> 00:25:03,860
of shown in this diagram where we have

00:25:02,119 --> 00:25:06,710
to struct SK buffs pointing into the

00:25:03,860 --> 00:25:10,090
same shared structure so what we learned

00:25:06,710 --> 00:25:13,220
was this is not the way we want to do it

00:25:10,090 --> 00:25:14,629
yeah well Erik if you have a quick

00:25:13,220 --> 00:25:17,419
question others will let him finish in

00:25:14,629 --> 00:25:21,549
then okay line up okay

00:25:17,419 --> 00:25:24,259
yeah do you mean yeah we can hear you

00:25:21,549 --> 00:25:27,529
actually the size of the Escobar is not

00:25:24,259 --> 00:25:31,190
really critical if you can afford not

00:25:27,529 --> 00:25:34,340
clearing part of it every skb location

00:25:31,190 --> 00:25:37,580
right now the STB CB is freed when you

00:25:34,340 --> 00:25:40,789
do the SK be a lot but you could even

00:25:37,580 --> 00:25:43,249
truly add another structure like one to

00:25:40,789 --> 00:25:44,980
cache line after the SK

00:25:43,249 --> 00:25:48,409
at the end of the stable without

00:25:44,980 --> 00:25:51,820
clearing at every SBB location and that

00:25:48,409 --> 00:25:51,820
will be actually noticed

00:25:54,010 --> 00:26:02,440
like an SUV shrimpo is a bit difficult

00:25:59,770 --> 00:26:06,010
because it makes videos

00:26:02,440 --> 00:26:09,540
SKB head and with the camera power up to

00:26:06,010 --> 00:26:15,280
allocation strategy it can have some

00:26:09,540 --> 00:26:18,250
huge effect actually all right yeah so I

00:26:15,280 --> 00:26:20,500
think you know given those things we've

00:26:18,250 --> 00:26:23,919
learned we I think kind of took a step

00:26:20,500 --> 00:26:26,200
back and figured out we could instead of

00:26:23,919 --> 00:26:31,570
including the data with the SUV itself

00:26:26,200 --> 00:26:34,570
we can in a you know tease you know sub

00:26:31,570 --> 00:26:38,020
flow version of a tcp sock we could have

00:26:34,570 --> 00:26:40,080
some alternate queues for for the

00:26:38,020 --> 00:26:42,460
mapping data that would allow us to

00:26:40,080 --> 00:26:43,900
implement that in parallel with the

00:26:42,460 --> 00:26:46,179
received view and then praten you know

00:26:43,900 --> 00:26:48,820
have those I think it ends up working

00:26:46,179 --> 00:26:52,450
better for MV TCP to kind of not take

00:26:48,820 --> 00:26:58,510
this obvious path of just trying to pack

00:26:52,450 --> 00:27:01,480
it in the sk bus um so what are we

00:26:58,510 --> 00:27:07,480
working on right now so our our current

00:27:01,480 --> 00:27:10,809
focus is working towards a RFC patch

00:27:07,480 --> 00:27:12,820
that for negative we we have on our

00:27:10,809 --> 00:27:16,419
mailing list and sharing kind of

00:27:12,820 --> 00:27:18,580
developing a a prototype with kind of

00:27:16,419 --> 00:27:20,350
cleaner layer separation you know using

00:27:18,580 --> 00:27:23,830
these ideas that we're coming up with

00:27:20,350 --> 00:27:25,570
for a more up streamable NP tcp and

00:27:23,830 --> 00:27:28,330
we're taking in parallel with that

00:27:25,570 --> 00:27:31,929
taking the existing multi path TCP

00:27:28,330 --> 00:27:35,559
implementation and pulling features out

00:27:31,929 --> 00:27:39,970
of it you know basically forking the

00:27:35,559 --> 00:27:43,600
version that is in use for the existing

00:27:39,970 --> 00:27:45,340
use cases that Matthew mentioned and you

00:27:43,600 --> 00:27:48,070
know pairing that down so that you know

00:27:45,340 --> 00:27:52,919
we have a better picture of what that

00:27:48,070 --> 00:27:56,260
minimal code set is and then we can

00:27:52,919 --> 00:27:57,910
combine those two approaches to to come

00:27:56,260 --> 00:28:00,130
up with something you know leveraging

00:27:57,910 --> 00:28:02,799
existing code where we can and and doing

00:28:00,130 --> 00:28:06,210
something simpler and in addition

00:28:02,799 --> 00:28:10,419
starting starting work on our user space

00:28:06,210 --> 00:28:13,380
MPT CBD daemon that would handle some of

00:28:10,419 --> 00:28:13,380
the control plane tasks

00:28:16,120 --> 00:28:21,470
yeah just to conclude you we also want

00:28:19,010 --> 00:28:25,760
to conclude in a in a positive way

00:28:21,470 --> 00:28:28,130
so we sing and we hope that you are sure

00:28:25,760 --> 00:28:33,740
that there is a demon to have impede cpf

00:28:28,130 --> 00:28:37,070
stream so what we want is to build stuff

00:28:33,740 --> 00:28:41,360
around TCP as much as we can without

00:28:37,070 --> 00:28:43,370
modifying it but after this tour you can

00:28:41,360 --> 00:28:46,399
understand that we need to make some

00:28:43,370 --> 00:28:49,360
minimal changes to the TCP stop core or

00:28:46,399 --> 00:28:52,519
even to to do Network stack with the skb

00:28:49,360 --> 00:28:55,370
but we want to pay attention a lot to

00:28:52,519 --> 00:28:59,360
the performance impact so we think that

00:28:55,370 --> 00:29:01,340
it's a challenge but we can do it if you

00:28:59,360 --> 00:29:04,039
would like to have more details there is

00:29:01,340 --> 00:29:06,320
a wiki there is a mailing list a git

00:29:04,039 --> 00:29:09,620
repository so don't hesitate to have a

00:29:06,320 --> 00:29:11,450
look also feel free to start a

00:29:09,620 --> 00:29:13,820
discussion now we can continue them

00:29:11,450 --> 00:29:17,299
later on the mailing list or wherever

00:29:13,820 --> 00:29:19,809
you want and we hope that the upstream

00:29:17,299 --> 00:29:23,210
process will lead to a better MPCP

00:29:19,809 --> 00:29:26,450
implementation thank you if you have any

00:29:23,210 --> 00:29:29,049
question don't worry Christophe is there

00:29:26,450 --> 00:29:29,049
okay

00:29:31,979 --> 00:29:37,869
so there was this car there was this

00:29:35,320 --> 00:29:41,109
slide about using IP for MP TCP and he

00:29:37,869 --> 00:29:43,869
said oh just like RDS and KCM right but

00:29:41,109 --> 00:29:46,779
that's a problem if I have to change my

00:29:43,869 --> 00:29:48,940
application to put an IP proton P TCP I

00:29:46,779 --> 00:29:50,829
can just as well use SAT P I don't need

00:29:48,940 --> 00:29:52,509
to use MP TCP at that point all right

00:29:50,829 --> 00:29:53,349
the whole idea behind MP TCP was this

00:29:52,509 --> 00:29:55,690
was supposed to be completely

00:29:53,349 --> 00:29:57,639
transparent under the hood it will just

00:29:55,690 --> 00:29:59,440
use the multipath thing and everything

00:29:57,639 --> 00:30:01,839
would be cool and that's not going to be

00:29:59,440 --> 00:30:04,509
true anymore the other problem with have

00:30:01,839 --> 00:30:07,299
requiring me to put IP port or MP TCP in

00:30:04,509 --> 00:30:09,069
my socket call is how is TLS going to

00:30:07,299 --> 00:30:12,279
work this is also problem we had with

00:30:09,069 --> 00:30:15,039
already s by the way right it's possible

00:30:12,279 --> 00:30:16,509
you would have problems with TLS even if

00:30:15,039 --> 00:30:21,089
you just made it transparent but now

00:30:16,509 --> 00:30:21,089
you've made it I'm not possible even

00:30:22,649 --> 00:30:29,769
okay so as far as the the TLS problem

00:30:26,979 --> 00:30:32,440
are you referring to the internal TLS or

00:30:29,769 --> 00:30:42,729
just TLS in general TLS in general users

00:30:32,440 --> 00:30:45,609
pasty of us so TLS in general should not

00:30:42,729 --> 00:30:49,089
be a problem because it's runs on top of

00:30:45,609 --> 00:30:50,919
a reliable byte stream so and MPGs be

00:30:49,089 --> 00:30:53,049
exposes a reliable byte stream to the

00:30:50,919 --> 00:30:55,959
application respect to your first

00:30:53,049 --> 00:30:58,479
comment was why are we changing the api

00:30:55,959 --> 00:31:00,789
where i amputees please promise was that

00:30:58,479 --> 00:31:05,739
it's just transparent for application

00:31:00,789 --> 00:31:10,059
right there are well two reasons first

00:31:05,739 --> 00:31:12,039
of all MVP itself is introducing an

00:31:10,059 --> 00:31:14,529
overhead compared to regular TCP just

00:31:12,039 --> 00:31:16,839
because it's it's more than TCP right it

00:31:14,529 --> 00:31:20,769
can't be from a performance perspective

00:31:16,839 --> 00:31:24,009
be equivalent to TCP and so if we by

00:31:20,769 --> 00:31:26,349
default opt in everybody to MP TCP right

00:31:24,009 --> 00:31:28,029
they will all be paying a slight cost a

00:31:26,349 --> 00:31:30,999
very small one but they will be paying

00:31:28,029 --> 00:31:35,799
one so that's the first reason and the

00:31:30,999 --> 00:31:38,649
second reason is because to be able to

00:31:35,799 --> 00:31:40,179
use MP TCP the user needs to or the

00:31:38,649 --> 00:31:42,190
application and/or

00:31:40,179 --> 00:31:46,179
the system administrator

00:31:42,190 --> 00:31:48,639
to expose or configure policies on how

00:31:46,179 --> 00:31:52,450
to use MBT CP because like let's say you

00:31:48,639 --> 00:31:55,539
have Wi-Fi and cell and you are using

00:31:52,450 --> 00:31:56,860
your doing web browsing so normally you

00:31:55,539 --> 00:31:59,590
wouldn't want to bring up the cellular

00:31:56,860 --> 00:32:02,139
interface for just because you are using

00:31:59,590 --> 00:32:05,440
MP TCP transparently so there's some

00:32:02,139 --> 00:32:07,210
more the the MPTP stack needs more

00:32:05,440 --> 00:32:09,370
context to actually make its decisions

00:32:07,210 --> 00:32:11,379
and so by mayor changing the API will

00:32:09,370 --> 00:32:12,909
make it explicit yes this is different

00:32:11,379 --> 00:32:17,049
and the application needs to provide

00:32:12,909 --> 00:32:19,480
that context but there is a difference

00:32:17,049 --> 00:32:21,429
between setting policy with Cisco or IP

00:32:19,480 --> 00:32:23,320
tables rented netfilter or something as

00:32:21,429 --> 00:32:26,049
opposed to asking me to recompile my

00:32:23,320 --> 00:32:27,580
binary we have considered using MPT

00:32:26,049 --> 00:32:29,139
simply because we don't have ready

00:32:27,580 --> 00:32:30,820
compiled binaries but we can set this

00:32:29,139 --> 00:32:32,679
policy through some other external meals

00:32:30,820 --> 00:32:34,899
and this is just changed when you put I

00:32:32,679 --> 00:32:36,549
people don't be TCP in there now I have

00:32:34,899 --> 00:32:40,659
to rewrite my application and recompile

00:32:36,549 --> 00:32:42,220
it and that's not cool alright so we we

00:32:40,659 --> 00:32:44,409
have it there are a couple options for

00:32:42,220 --> 00:32:46,299
that for for one if you have a system

00:32:44,409 --> 00:32:50,289
where you know you want to make use of

00:32:46,299 --> 00:32:52,389
multipath TCP we could say add assist

00:32:50,289 --> 00:32:56,860
control that when you said you know any

00:32:52,389 --> 00:32:58,690
stream I not adding this any Lusaka DPR

00:32:56,860 --> 00:33:01,659
I just leave the pine oil and make this

00:32:58,690 --> 00:33:04,240
configurable by some other means the

00:33:01,659 --> 00:33:06,879
other point is you never touched on the

00:33:04,240 --> 00:33:10,000
coupled congestion control at all that's

00:33:06,879 --> 00:33:12,730
pretty intense and as far as I remember

00:33:10,000 --> 00:33:14,440
that's all based on we know TCP how will

00:33:12,730 --> 00:33:15,970
that fit with PBR and all the newer

00:33:14,440 --> 00:33:20,080
things coming up the better things

00:33:15,970 --> 00:33:24,159
coming up let me try to answer that

00:33:20,080 --> 00:33:25,570
question again so the couple called MPT

00:33:24,159 --> 00:33:28,029
speed does not require a couple of

00:33:25,570 --> 00:33:30,669
congestion control and the couple

00:33:28,029 --> 00:33:34,409
congestion control is based on Reno and

00:33:30,669 --> 00:33:36,730
it had it's not up-to-date with current

00:33:34,409 --> 00:33:38,559
congestion control research right and

00:33:36,730 --> 00:33:40,360
it's more like it was a very interesting

00:33:38,559 --> 00:33:41,320
research project a couple congestion

00:33:40,360 --> 00:33:42,970
control

00:33:41,320 --> 00:33:45,879
showed some interesting properties on

00:33:42,970 --> 00:33:48,039
how you can do congestion control when

00:33:45,879 --> 00:33:49,929
using two sub TCP sub flows and you are

00:33:48,039 --> 00:33:52,149
combining the congestion there but it

00:33:49,929 --> 00:33:54,070
does not MPT speed does not require a

00:33:52,149 --> 00:33:55,050
couple of contrast model you can use bbr

00:33:54,070 --> 00:33:57,210
was MP tspn

00:33:55,050 --> 00:34:01,280
we'll just work there's no problem to

00:33:57,210 --> 00:34:03,900
that yeah I think maybe one thing that

00:34:01,280 --> 00:34:06,300
we didn't get emphasized when we were

00:34:03,900 --> 00:34:09,179
speaking we do mention in the paper is

00:34:06,300 --> 00:34:11,370
the couple to receive Windows between

00:34:09,179 --> 00:34:13,770
the sub flows and that that being a

00:34:11,370 --> 00:34:15,240
source of complexity right but the

00:34:13,770 --> 00:34:17,429
problem statement behind a couple

00:34:15,240 --> 00:34:24,960
congestion control remains so that has

00:34:17,429 --> 00:34:26,640
to be solved right I think that depends

00:34:24,960 --> 00:34:28,890
on a use case variety the problem

00:34:26,640 --> 00:34:31,350
statement about couple congestion

00:34:28,890 --> 00:34:33,390
control is what if in the end your to

00:34:31,350 --> 00:34:35,790
TCP sub flows go over the same

00:34:33,390 --> 00:34:38,909
bottleneck right and then you will get

00:34:35,790 --> 00:34:40,890
double exactly that's a problem of

00:34:38,909 --> 00:34:42,270
unfairness you might the most applause

00:34:40,890 --> 00:34:47,210
you create the more throughput you get

00:34:42,270 --> 00:34:49,800
and so on I think it's a problem but

00:34:47,210 --> 00:34:51,360
while applications already can create

00:34:49,800 --> 00:34:55,880
just multiple TCP connections if they

00:34:51,360 --> 00:34:59,520
want to do that so it will make it worse

00:34:55,880 --> 00:35:04,560
maybe yes maybe no I'm not so sure I

00:34:59,520 --> 00:35:06,060
think it's the question of fairness so I

00:35:04,560 --> 00:35:07,290
think there needs to be a roadmap on how

00:35:06,060 --> 00:35:08,130
we're going to deal with that and

00:35:07,290 --> 00:35:10,560
especially if you're talking about

00:35:08,130 --> 00:35:12,570
integration of the kernel well it should

00:35:10,560 --> 00:35:14,220
be fairly easy to add the couple

00:35:12,570 --> 00:35:16,350
congestion control into this model right

00:35:14,220 --> 00:35:18,810
and you say it's based on Reno there's

00:35:16,350 --> 00:35:21,630
MP cubic also so a couple congestion

00:35:18,810 --> 00:35:23,460
control based on cubic so there's

00:35:21,630 --> 00:35:25,560
research coming up that will probably at

00:35:23,460 --> 00:35:26,760
one point integrate BPR and ok I just

00:35:25,560 --> 00:35:35,850
want to make the point that you know you

00:35:26,760 --> 00:35:37,950
have to look about that so a couple of

00:35:35,850 --> 00:35:41,460
things first of all thank you for doing

00:35:37,950 --> 00:35:44,790
this it's really important and I can

00:35:41,460 --> 00:35:48,230
give you the context for this so if we

00:35:44,790 --> 00:35:52,290
don't have multipath TCP in Linux and

00:35:48,230 --> 00:35:54,360
it's being deployed this is creating the

00:35:52,290 --> 00:35:56,880
need for an alternative solution so what

00:35:54,360 --> 00:36:00,720
we're seeing in IETF now is the idea of

00:35:56,880 --> 00:36:03,000
a multipath TCP proxy so

00:36:00,720 --> 00:36:04,650
so we know this is being deployed and in

00:36:03,000 --> 00:36:07,200
Korean parts of Asian what they're doing

00:36:04,650 --> 00:36:09,390
is since we can't get server support

00:36:07,200 --> 00:36:10,800
they claim that can get client support

00:36:09,390 --> 00:36:12,990
since we can't get server support

00:36:10,800 --> 00:36:16,110
oh we'll just put more proxies in the

00:36:12,990 --> 00:36:17,970
network to do multipath CCP and of

00:36:16,110 --> 00:36:19,800
course when they did that they said oh

00:36:17,970 --> 00:36:22,560
this isn't just going to be good for

00:36:19,800 --> 00:36:24,750
multipath TCP let's make it a generic

00:36:22,560 --> 00:36:26,250
proxy that can handle any new TCP

00:36:24,750 --> 00:36:28,620
options so whenever you introduce a new

00:36:26,250 --> 00:36:30,720
TCP option now instead of actually

00:36:28,620 --> 00:36:32,580
supporting @nn we could just put

00:36:30,720 --> 00:36:34,830
something in the middle as an interim

00:36:32,580 --> 00:36:37,500
solution until we get the full

00:36:34,830 --> 00:36:39,510
deployment well we know we're in our own

00:36:37,500 --> 00:36:41,160
solutions like this go right so you

00:36:39,510 --> 00:36:42,870
can't have an interim solution if you

00:36:41,160 --> 00:36:46,140
don't have a plan to actually get to the

00:36:42,870 --> 00:36:47,520
final solution so multipad TCP is

00:36:46,140 --> 00:36:49,530
especially interesting because there is

00:36:47,520 --> 00:36:52,650
quite a bit of history here it's already

00:36:49,530 --> 00:36:54,900
been kind of proposed in Linux I think a

00:36:52,650 --> 00:36:57,510
few times last time was actually several

00:36:54,900 --> 00:36:59,460
years ago and the feedback was always

00:36:57,510 --> 00:37:02,790
pretty consistent this thing is just way

00:36:59,460 --> 00:37:07,140
too invasive too many lines of change in

00:37:02,790 --> 00:37:10,290
TCP what have you so my plea is actually

00:37:07,140 --> 00:37:12,870
be persistent if the network maintainer

00:37:10,290 --> 00:37:14,430
needs a fine case of French wine or

00:37:12,870 --> 00:37:18,630
something like that by all means send it

00:37:14,430 --> 00:37:20,550
to them but please continue with this

00:37:18,630 --> 00:37:23,340
get it in because the alternatives on

00:37:20,550 --> 00:37:26,310
the Internet are really unpleasant at

00:37:23,340 --> 00:37:28,590
least in my opinion for the particulars

00:37:26,310 --> 00:37:32,790
I think these are details to be worked

00:37:28,590 --> 00:37:34,170
out having a new a new socket type I

00:37:32,790 --> 00:37:37,680
kind of agree with you so many but I

00:37:34,170 --> 00:37:39,450
also it's like having something there

00:37:37,680 --> 00:37:43,080
it's almost better than nothing and we

00:37:39,450 --> 00:37:44,760
could evolve that so if that's a shorter

00:37:43,080 --> 00:37:46,470
path actually get something in and then

00:37:44,760 --> 00:37:48,840
involve it that might actually be a

00:37:46,470 --> 00:37:50,250
reasonable approach so that hopefully

00:37:48,840 --> 00:37:54,990
there's a little bit of flexibility

00:37:50,250 --> 00:37:58,260
there sure incremental passengers yeah

00:37:54,990 --> 00:38:00,360
thanks Tom and I think it's something I

00:37:58,260 --> 00:38:02,400
didn't I didn't speak about as in-depth

00:38:00,360 --> 00:38:03,930
as I intended but but yeah our goal is

00:38:02,400 --> 00:38:06,950
to have the initial basic implementation

00:38:03,930 --> 00:38:10,350
so that we do have kind of a foothold to

00:38:06,950 --> 00:38:11,960
develop additional features and see what

00:38:10,350 --> 00:38:14,690
the community needs and

00:38:11,960 --> 00:38:17,690
yes you had like a statement that you

00:38:14,690 --> 00:38:20,260
removed X number of lines it would be

00:38:17,690 --> 00:38:23,720
good to track a number of changes to

00:38:20,260 --> 00:38:25,640
core networking like in TCP and then

00:38:23,720 --> 00:38:27,260
just general lines of code so we

00:38:25,640 --> 00:38:30,170
probably don't care nearly as much if

00:38:27,260 --> 00:38:32,180
you have like multipath TCP module then

00:38:30,170 --> 00:38:34,640
as long as that's well-written can be

00:38:32,180 --> 00:38:36,950
whatever in lines of code by going into

00:38:34,640 --> 00:38:38,810
major surgery on TCP or the socket layer

00:38:36,950 --> 00:38:40,190
that's probably where people like Eric

00:38:38,810 --> 00:38:47,950
are going to start your help give a lot

00:38:40,190 --> 00:39:00,650
of scrutiny right right thank you Eric

00:38:47,950 --> 00:39:04,490
Eric yeah what anything go ahead say can

00:39:00,650 --> 00:39:08,870
you hear me yes yeah so I'm fully

00:39:04,490 --> 00:39:11,510
supportive of this MP TCP effort the

00:39:08,870 --> 00:39:14,960
recent addition of TRS & KCM in the

00:39:11,510 --> 00:39:18,340
camel showed how layer implementation

00:39:14,960 --> 00:39:21,530
could be done and I think MPCP

00:39:18,340 --> 00:39:25,430
can absolutely be done on the same way

00:39:21,530 --> 00:39:30,610
so if yeah so I'm fully supportive of

00:39:25,430 --> 00:39:30,610
that and I will help you with if needed

00:39:38,259 --> 00:39:49,839
all right I think all right you thank

00:39:42,319 --> 00:39:49,839

YouTube URL: https://www.youtube.com/watch?v=bwh5pr2uxgQ


