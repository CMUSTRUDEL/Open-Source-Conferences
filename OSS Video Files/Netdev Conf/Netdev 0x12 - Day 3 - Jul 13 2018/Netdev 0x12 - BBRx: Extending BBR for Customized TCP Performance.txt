Title: Netdev 0x12 - BBRx: Extending BBR for Customized TCP Performance
Publication date: 2018-08-01
Playlist: Netdev 0x12 - Day 3 - Jul 13 2018
Description: 
	The future of optimal TCP involves robots! On July 13th, 2018 at Netdev 0x12 in Montreal, Jae Won Chung discussed an extension to BBR called BBRx which is loosely coupled to machine learning.
He described how they study TCP path attributes in user space at runtime to find an optimal throughput-delay operating point. The results are then fed back to the kernel to tweak it.

Performance of BBRx is evaluated in both LTE mobile as well as telco wireline environments and compared with classical CUBIC and BBR.

More info:
https://www.netdevconf.org/0x12/session.html?bbrx-extending-bbr-for-customized-tcp-performance
Captions: 
	00:00:00,230 --> 00:00:08,150
hello hey thanks for you know inviting

00:00:05,549 --> 00:00:13,519
me for this to this wonderful conference

00:00:08,150 --> 00:00:16,980
I'm going to talk about BB rx basically

00:00:13,519 --> 00:00:20,640
we are we actually have extended to be

00:00:16,980 --> 00:00:24,050
BR to do a little little better control

00:00:20,640 --> 00:00:27,539
of the what is it the the bottleneck

00:00:24,050 --> 00:00:28,619
treating the light so that's basically

00:00:27,539 --> 00:00:33,540
what I'm going to actually you know

00:00:28,619 --> 00:00:36,290
present today so the objectives are like

00:00:33,540 --> 00:00:38,670
you know seems like BB R is going to be

00:00:36,290 --> 00:00:40,230
promising it's actually promising

00:00:38,670 --> 00:00:44,850
next-gen TCP congestion avoidance

00:00:40,230 --> 00:00:47,399
candidate but you know still has a room

00:00:44,850 --> 00:00:50,460
for performance improvement especially

00:00:47,399 --> 00:00:54,960
for a better better better management of

00:00:50,460 --> 00:00:56,940
bottleneck queuing delay so and when I

00:00:54,960 --> 00:01:01,670
was actually working on congestion

00:00:56,940 --> 00:01:05,460
management for wireless communications

00:01:01,670 --> 00:01:09,540
you know usually everybody wants to

00:01:05,460 --> 00:01:11,670
actually have minimum delay and that's

00:01:09,540 --> 00:01:14,430
the first objective and then what are

00:01:11,670 --> 00:01:16,470
you know cheap the maximum throughput

00:01:14,430 --> 00:01:19,320
but you know in our case it was slightly

00:01:16,470 --> 00:01:21,860
different so because you know as a

00:01:19,320 --> 00:01:26,009
wireless provider we always wanted to

00:01:21,860 --> 00:01:28,950
say oh our what is that the speed of our

00:01:26,009 --> 00:01:33,479
network is the fastest and then they

00:01:28,950 --> 00:01:36,560
actually worried about the delay so I

00:01:33,479 --> 00:01:40,530
was actually seeking to seeking for

00:01:36,560 --> 00:01:42,630
mechanism so that I can you know manage

00:01:40,530 --> 00:01:48,110
the dequeuing delay better from the

00:01:42,630 --> 00:01:52,649
source perspective so then basically

00:01:48,110 --> 00:01:54,689
then so when we a need to actually

00:01:52,649 --> 00:01:58,350
deploy a congestion you know management

00:01:54,689 --> 00:02:00,570
algorithm basically we are trying to

00:01:58,350 --> 00:02:02,640
actually practically deploy learning

00:02:00,570 --> 00:02:04,530
techniques to ensure the optimum TCP

00:02:02,640 --> 00:02:06,780
performance all the time I mean there

00:02:04,530 --> 00:02:08,610
was another aspect of it so basically we

00:02:06,780 --> 00:02:10,440
don't we I was actually scared to

00:02:08,610 --> 00:02:12,670
introduce like learning algorithm within

00:02:10,440 --> 00:02:15,370
the kernel but you know

00:02:12,670 --> 00:02:17,490
we try to actually figure out hey how

00:02:15,370 --> 00:02:20,380
can we actually use a learning algorithm

00:02:17,490 --> 00:02:24,490
in the user space and just you know

00:02:20,380 --> 00:02:26,920
slowly configure the condition parameter

00:02:24,490 --> 00:02:30,630
so that we can actually achieve the best

00:02:26,920 --> 00:02:33,430
you know TCP performance in a in our

00:02:30,630 --> 00:02:35,770
durant radio access network so basically

00:02:33,430 --> 00:02:42,040
that was you know another objective that

00:02:35,770 --> 00:02:44,820
we were looking at okay so so the theory

00:02:42,040 --> 00:02:48,910
behind the of the BB RX basically we

00:02:44,820 --> 00:02:51,130
introduced api controller into BB r when

00:02:48,910 --> 00:02:54,910
i actually so the BB r from the first

00:02:51,130 --> 00:02:57,880
time say it was actually estimating the

00:02:54,910 --> 00:03:00,100
bandwidth and that actually reminds me

00:02:57,880 --> 00:03:02,560
of my old work like you know twenty

00:03:00,100 --> 00:03:05,709
something years ago i actually was

00:03:02,560 --> 00:03:07,870
working on rate based PID controller for

00:03:05,709 --> 00:03:10,410
active queue management so active queue

00:03:07,870 --> 00:03:13,800
management means like you know the

00:03:10,410 --> 00:03:17,079
congested router actually come up with

00:03:13,800 --> 00:03:19,540
with the marking probability congestion

00:03:17,079 --> 00:03:23,110
notification probably and with that

00:03:19,540 --> 00:03:28,120
probably either marks or drop the packet

00:03:23,110 --> 00:03:30,850
so that the the a imd based no tcp

00:03:28,120 --> 00:03:32,920
source can adjust this rate and it's an

00:03:30,850 --> 00:03:39,700
indirect control rather than directly

00:03:32,920 --> 00:03:43,769
controlling to TCP sender so and I was

00:03:39,700 --> 00:03:47,400
actually looking at the DPI controller

00:03:43,769 --> 00:03:50,380
parameter configuration for my

00:03:47,400 --> 00:03:52,360
schoolwork so basically this is this

00:03:50,380 --> 00:03:59,350
algorithm is actually very simple so P

00:03:52,360 --> 00:04:01,060
is actually uh the the ecn the

00:03:59,350 --> 00:04:02,890
congestion notification probability and

00:04:01,060 --> 00:04:06,360
basically conditional notification

00:04:02,890 --> 00:04:10,269
probably will be actually increased by

00:04:06,360 --> 00:04:14,920
my see a gamma C which is which is

00:04:10,269 --> 00:04:17,829
basically my target bandwidth for this

00:04:14,920 --> 00:04:19,870
ad box so times the Delta Gamma C is

00:04:17,829 --> 00:04:23,500
basically how many packets to actually

00:04:19,870 --> 00:04:26,260
deliver I know they I want and basically

00:04:23,500 --> 00:04:28,870
I can actually do and then

00:04:26,260 --> 00:04:30,970
like you know what is what is the number

00:04:28,870 --> 00:04:35,020
of bytes I actually received this dis

00:04:30,970 --> 00:04:37,930
Apple and minus q0 is actually my target

00:04:35,020 --> 00:04:42,250
true and basically the queue length and

00:04:37,930 --> 00:04:45,160
then the queue is basically a to current

00:04:42,250 --> 00:04:47,680
queue length that I actually see and so

00:04:45,160 --> 00:04:51,160
this is basically a basic you know peer

00:04:47,680 --> 00:04:53,440
control algorithm so when I'm actually

00:04:51,160 --> 00:04:56,250
out while I'm actually trying to move

00:04:53,440 --> 00:05:00,010
this to the traffic source the TCP

00:04:56,250 --> 00:05:02,460
basically I don't really need you know

00:05:00,010 --> 00:05:05,140
packet the congestion notification

00:05:02,460 --> 00:05:07,960
probabilities so I'm using the same

00:05:05,140 --> 00:05:10,540
logic but in term instead of trying to

00:05:07,960 --> 00:05:12,100
find like you know P I'm just gonna use

00:05:10,540 --> 00:05:14,170
like you know number of bytes that I

00:05:12,100 --> 00:05:19,690
need to send for this a box so I just

00:05:14,170 --> 00:05:21,850
replace the P with B's then basically

00:05:19,690 --> 00:05:25,750
I'm want to actually you know work with

00:05:21,850 --> 00:05:30,220
the rate so I divided you know booth and

00:05:25,750 --> 00:05:32,980
by Delta the ad hoc size which will

00:05:30,220 --> 00:05:34,900
actually give give you the R and if you

00:05:32,980 --> 00:05:39,280
actually you know on the right side if

00:05:34,900 --> 00:05:41,770
you rewrite then it actually comes

00:05:39,280 --> 00:05:46,180
becomes like you know 1 minus alpha

00:05:41,770 --> 00:05:50,170
times R plus you know alpha times gamma

00:05:46,180 --> 00:05:53,140
C so basically this term is more like in

00:05:50,170 --> 00:05:56,590
a weighted average and it actually

00:05:53,140 --> 00:05:59,620
becomes I can actually just rewrite as a

00:05:56,590 --> 00:06:01,480
in a gamma C because anyway is the

00:05:59,620 --> 00:06:06,970
estimation of the you know the bandwidth

00:06:01,480 --> 00:06:10,300
and and basically uh and also the Q

00:06:06,970 --> 00:06:12,130
minus Q 0 if you actually divided by C

00:06:10,300 --> 00:06:16,540
then it actually becomes the the queuing

00:06:12,130 --> 00:06:18,730
delay so and so the the the PID

00:06:16,540 --> 00:06:22,150
controller Goutham becomes just as

00:06:18,730 --> 00:06:24,310
simple as this but the the gotcha here

00:06:22,150 --> 00:06:25,780
is I don't know the queuing delay okay

00:06:24,310 --> 00:06:30,190
so how do I actually has to meet the

00:06:25,780 --> 00:06:33,280
queuing delay basically the measured rd

00:06:30,190 --> 00:06:36,490
t minus TR 0 which is actually mini

00:06:33,280 --> 00:06:40,270
martyt would be a good estimate of D

00:06:36,490 --> 00:06:44,200
minus d0 but we probably going to have

00:06:40,270 --> 00:06:48,460
estimation noisier because I'm actually

00:06:44,200 --> 00:06:53,680
measuring the the D minus t0 with our

00:06:48,460 --> 00:06:56,410
minus r0 at the source okay so but I

00:06:53,680 --> 00:06:58,630
mean if you actually look at this this

00:06:56,410 --> 00:07:03,010
is actually the control function that

00:06:58,630 --> 00:07:06,820
actually used by the ABC at the the ABC

00:07:03,010 --> 00:07:10,810
switch so I'm actually going to use the

00:07:06,820 --> 00:07:15,900
same control function that ABC uses in

00:07:10,810 --> 00:07:21,640
to be BR and if you look at this

00:07:15,900 --> 00:07:23,290
BB R is basically a so the BB R is

00:07:21,640 --> 00:07:27,010
basically if you actually set the the

00:07:23,290 --> 00:07:31,600
beta equals to 0 and gamma goes to 1

00:07:27,010 --> 00:07:33,790
then basically it becomes a PBR so so I

00:07:31,600 --> 00:07:35,560
mean the control function that I'm just

00:07:33,790 --> 00:07:40,150
rewriting to r02

00:07:35,560 --> 00:07:42,190
you know K divided by 4 times R mean so

00:07:40,150 --> 00:07:44,680
that I just want to make it discreet so

00:07:42,190 --> 00:07:47,010
that if I want to increase the the RTT

00:07:44,680 --> 00:07:51,670
my target ET I just need to increase the

00:07:47,010 --> 00:07:55,030
decay from 4 to 5 or 6 or something like

00:07:51,670 --> 00:07:57,370
that so so this is exactly the control

00:07:55,030 --> 00:08:04,000
function that I've implemented into the

00:07:57,370 --> 00:08:06,040
VBR okay okay so I just want to say that

00:08:04,000 --> 00:08:11,470
vp r is a special case of bv r x where

00:08:06,040 --> 00:08:15,040
gamma equals 1 and beta equals to 0 ok

00:08:11,470 --> 00:08:17,260
so code added so the red line is

00:08:15,040 --> 00:08:23,080
actually what i added to the DBPR main

00:08:17,260 --> 00:08:25,740
function so so this is the BB our main

00:08:23,080 --> 00:08:29,130
function is actually called every act

00:08:25,740 --> 00:08:31,360
event and what it does is actually

00:08:29,130 --> 00:08:32,860
estimate the bandwidth and then create

00:08:31,360 --> 00:08:36,310
the model and stuff like that and then

00:08:32,860 --> 00:08:37,840
get the bandwidth and if the red line is

00:08:36,310 --> 00:08:40,090
not there then it's just a set the

00:08:37,840 --> 00:08:43,060
pacing right to do the bandwidth but I

00:08:40,090 --> 00:08:48,900
just call my function just call like VBR

00:08:43,060 --> 00:08:52,150
x target bandwidth and that is going to

00:08:48,900 --> 00:08:53,810
just implement the what is it the PR

00:08:52,150 --> 00:08:57,750
logic based on the

00:08:53,810 --> 00:09:01,080
the RTT the instant RTT value available

00:08:57,750 --> 00:09:07,350
in the the rate sample basically it's as

00:09:01,080 --> 00:09:10,400
simple as that okay so the what I did

00:09:07,350 --> 00:09:16,260
was I used the baseline I mean the Linux

00:09:10,400 --> 00:09:18,990
for 4.15 18 and in order to actually add

00:09:16,260 --> 00:09:23,100
a little more you know variables I had

00:09:18,990 --> 00:09:26,700
to increase the size of the private the

00:09:23,100 --> 00:09:32,100
control the see a structure from 88 to

00:09:26,700 --> 00:09:35,790
104 and also I added like know a little

00:09:32,100 --> 00:09:37,470
more TCP information VP rx information

00:09:35,790 --> 00:09:43,530
to the TCC and for that I'm gonna

00:09:37,470 --> 00:09:47,100
actually talk about a little later ok so

00:09:43,530 --> 00:09:49,020
now the problem is I just throw in the

00:09:47,100 --> 00:09:51,680
API controller so how do I actually

00:09:49,020 --> 00:09:55,470
configure this thing that is actually

00:09:51,680 --> 00:09:58,860
usually when I was in school people just

00:09:55,470 --> 00:10:01,050
stopped here and then just say a disc

00:09:58,860 --> 00:10:02,880
control I actually added you know

00:10:01,050 --> 00:10:04,770
introduced this controller it works

00:10:02,880 --> 00:10:07,740
great on this environment and then

00:10:04,770 --> 00:10:09,570
basically that was it but I actually had

00:10:07,740 --> 00:10:13,770
to go a little beyond that because you

00:10:09,570 --> 00:10:18,600
know I I was I need to actually you know

00:10:13,770 --> 00:10:21,150
do I need to implement this thing for

00:10:18,600 --> 00:10:23,450
carriers right so I actually looked into

00:10:21,150 --> 00:10:29,220
like how can I actually come up with

00:10:23,450 --> 00:10:31,920
better you know parameters so basically

00:10:29,220 --> 00:10:35,070
the target utilisation gamma is actually

00:10:31,920 --> 00:10:37,590
easy just set to one I mean setting to

00:10:35,070 --> 00:10:41,520
one doesn't really mean like tonight I

00:10:37,590 --> 00:10:43,110
don't really I really go against the of

00:10:41,520 --> 00:10:45,030
the queueing theory but you know anyways

00:10:43,110 --> 00:10:47,220
estimate so it doesn't really matter if

00:10:45,030 --> 00:10:50,220
you're not really convinced then you can

00:10:47,220 --> 00:10:53,460
actually set it to 0.9999 whatever the

00:10:50,220 --> 00:10:56,670
value you want or you can actually set

00:10:53,460 --> 00:10:58,710
it to 0.98 it depends on what you want I

00:10:56,670 --> 00:11:02,010
mean if you want like little more um

00:10:58,710 --> 00:11:04,020
delay sensitive if you don't want to

00:11:02,010 --> 00:11:06,270
actually build up the other queue then

00:11:04,020 --> 00:11:10,020
probably 9.8

00:11:06,270 --> 00:11:13,140
or 0.98 word 0.97 my might be a good

00:11:10,020 --> 00:11:15,900
value so what is the airport I actually

00:11:13,140 --> 00:11:19,830
said that back to them in Myanmar TT in

00:11:15,900 --> 00:11:23,250
the code then the target are TT deciding

00:11:19,830 --> 00:11:25,020
factor K is actually has to be greater

00:11:23,250 --> 00:11:27,690
than four but I don't know what what the

00:11:25,020 --> 00:11:29,550
good value should be I mean in normal in

00:11:27,690 --> 00:11:32,910
normal situation probably four is

00:11:29,550 --> 00:11:35,220
actually the best because for personal

00:11:32,910 --> 00:11:37,770
use of your computer I mean you don't

00:11:35,220 --> 00:11:39,900
really need to actually get get used

00:11:37,770 --> 00:11:42,450
like no hundred percent of your you know

00:11:39,900 --> 00:11:45,660
bandwidth so probably mean your target

00:11:42,450 --> 00:11:47,490
or TT should be the mean RTT setting the

00:11:45,660 --> 00:11:50,550
target 82 million our TT should actually

00:11:47,490 --> 00:11:53,190
do but if you really want to optimize

00:11:50,550 --> 00:11:55,140
like you know throughput then you might

00:11:53,190 --> 00:11:57,660
want to actually build up a queue little

00:11:55,140 --> 00:12:00,240
more and that's actually a tricky

00:11:57,660 --> 00:12:04,140
problem to and also this reduced P I

00:12:00,240 --> 00:12:08,580
parameter beta the range is basically

00:12:04,140 --> 00:12:10,710
greater than 0 and less than 1 but you

00:12:08,580 --> 00:12:13,200
know how do I actually come up with this

00:12:10,710 --> 00:12:14,910
you know value is actually another a

00:12:13,200 --> 00:12:18,080
hard problem to solve

00:12:14,910 --> 00:12:28,410
it's not that hard but it's harder than

00:12:18,080 --> 00:12:31,800
gamma or Delta so basically in PI

00:12:28,410 --> 00:12:35,700
controller PR control is is kind of

00:12:31,800 --> 00:12:39,720
sensitive to our TT if our TT actually

00:12:35,700 --> 00:12:42,600
grow then the system may you know go

00:12:39,720 --> 00:12:45,600
into what do you call it like you know

00:12:42,600 --> 00:12:48,150
unstable condition where they have a lot

00:12:45,600 --> 00:12:50,400
of like you know or is it the bandwidth

00:12:48,150 --> 00:12:51,900
and including delay actually swinging so

00:12:50,400 --> 00:12:55,890
you really need to actually make sure

00:12:51,900 --> 00:13:00,750
the you know the debate of avalue right

00:12:55,890 --> 00:13:02,940
for the environment so there are there

00:13:00,750 --> 00:13:06,110
are two methods that you can actually

00:13:02,940 --> 00:13:09,900
use you can actually use the frequency

00:13:06,110 --> 00:13:13,050
response analysis basically you just

00:13:09,900 --> 00:13:16,110
need to model this simple algorithm and

00:13:13,050 --> 00:13:17,950
add the delay component to it and then

00:13:16,110 --> 00:13:20,440
just do the

00:13:17,950 --> 00:13:22,300
with frequency response analysis to

00:13:20,440 --> 00:13:25,660
actually come up with what would be the

00:13:22,300 --> 00:13:28,390
the safe range of you know beta actually

00:13:25,660 --> 00:13:31,330
its beta beta over Delta but you know

00:13:28,390 --> 00:13:33,370
since you actually said to Delta to mean

00:13:31,330 --> 00:13:37,810
R DT that's how you can actually come up

00:13:33,370 --> 00:13:40,810
with or can we actually come up with you

00:13:37,810 --> 00:13:42,790
know says the the right value

00:13:40,810 --> 00:13:46,260
empirically I'm using a learning

00:13:42,790 --> 00:13:49,960
algorithm that was what our focus was on

00:13:46,260 --> 00:13:51,910
so basically we want to actually read

00:13:49,960 --> 00:13:54,550
the the peripheral statistics from the

00:13:51,910 --> 00:13:57,130
TCP stack give it to the learning agent

00:13:54,550 --> 00:14:00,870
in a user space and that user space will

00:13:57,130 --> 00:14:06,070
actually slowly you know investigate the

00:14:00,870 --> 00:14:09,190
TCP performance and reconfigure the what

00:14:06,070 --> 00:14:13,240
is it to configure the the module

00:14:09,190 --> 00:14:15,190
parameter for the PBR X so we actually

00:14:13,240 --> 00:14:21,970
wanted to go to that direction so we

00:14:15,190 --> 00:14:24,370
evaluated this okay so so the learning

00:14:21,970 --> 00:14:26,320
agent what it does is actually it

00:14:24,370 --> 00:14:28,810
actually subscribe to the TCP flows that

00:14:26,320 --> 00:14:34,120
via net link socket so basically

00:14:28,810 --> 00:14:36,880
whatever the TCP terminates we actually

00:14:34,120 --> 00:14:40,360
getting the TCP stats I mean it's

00:14:36,880 --> 00:14:42,840
actually shown on the right side you

00:14:40,360 --> 00:14:45,910
know get this information and basically

00:14:42,840 --> 00:14:47,920
then what we do is we classified the TCP

00:14:45,910 --> 00:14:50,050
flows in two different bins based on the

00:14:47,920 --> 00:14:53,050
reported bottleneck bandwidth and the

00:14:50,050 --> 00:14:56,080
minimo RTT because we could actually use

00:14:53,050 --> 00:14:59,590
one class for testing and then we

00:14:56,080 --> 00:15:01,930
actually decided to use multiple bins

00:14:59,590 --> 00:15:06,100
because that might actually work better

00:15:01,930 --> 00:15:09,480
and for each class traffic class pain we

00:15:06,100 --> 00:15:12,180
compute the average utility of flows

00:15:09,480 --> 00:15:14,470
when enough samples are collected

00:15:12,180 --> 00:15:16,570
basically the default was actually 40

00:15:14,470 --> 00:15:18,730
but you know basically one when we

00:15:16,570 --> 00:15:23,370
actually get the underflow samples then

00:15:18,730 --> 00:15:28,270
we compute the average utility and and

00:15:23,370 --> 00:15:30,580
basically using the PCC we just so Viva

00:15:28,270 --> 00:15:31,509
Chi and then what was the Allegro or

00:15:30,580 --> 00:15:33,910
something

00:15:31,509 --> 00:15:37,799
we actually used the Allegro utility

00:15:33,910 --> 00:15:41,709
function to compute the the utility for

00:15:37,799 --> 00:15:45,939
for those flows average of those flows

00:15:41,709 --> 00:15:48,369
and then we then basically becomes like

00:15:45,939 --> 00:15:51,429
fine a problem optimization problem of

00:15:48,369 --> 00:15:53,919
finding minimum K and the corresponding

00:15:51,429 --> 00:15:55,989
beta that is the highest utility average

00:15:53,919 --> 00:15:59,980
utility so that's how we actually

00:15:55,989 --> 00:16:03,730
approached and basically the learning

00:15:59,980 --> 00:16:08,579
agent is in updating the BP rx kernel

00:16:03,730 --> 00:16:10,899
module parameters so but this actually

00:16:08,579 --> 00:16:13,239
we really need to actually make sure

00:16:10,899 --> 00:16:15,549
that in order to actually use the

00:16:13,239 --> 00:16:17,199
learning algorithm gradient actually

00:16:15,549 --> 00:16:20,199
descendant but in this case ascendant

00:16:17,199 --> 00:16:20,859
because the shapes are actually no the

00:16:20,199 --> 00:16:23,799
other way around

00:16:20,859 --> 00:16:25,299
we we need to actually make sure that

00:16:23,799 --> 00:16:27,790
this is actually convex function

00:16:25,299 --> 00:16:29,589
otherwise we can't really apply the

00:16:27,790 --> 00:16:35,309
gradient ascent algorithm on it

00:16:29,589 --> 00:16:39,039
so so we did some tests so we actually

00:16:35,309 --> 00:16:44,259
this this graph actually shows the

00:16:39,039 --> 00:16:46,959
utility of in terms of so we we increase

00:16:44,259 --> 00:16:52,449
the x-axis is actually beta it's

00:16:46,959 --> 00:16:56,319
actually a hundred times beta and we we

00:16:52,449 --> 00:16:57,699
actually what is it the queue length I

00:16:56,319 --> 00:17:00,100
mean we actually increase the queue

00:16:57,699 --> 00:17:01,769
length of the bottleneck bandwidth of

00:17:00,100 --> 00:17:04,720
the bottleneck link and then you know

00:17:01,769 --> 00:17:11,069
plot the the utility value we actually

00:17:04,720 --> 00:17:13,000
came up we actually saw so the so I

00:17:11,069 --> 00:17:18,909
forget like you know what was the

00:17:13,000 --> 00:17:20,230
bandwidth available yeah I think I

00:17:18,909 --> 00:17:25,240
forget to actually you know put that

00:17:20,230 --> 00:17:27,939
information here but anyway so so the

00:17:25,240 --> 00:17:31,659
thing is it actually shows the convex

00:17:27,939 --> 00:17:34,620
function which is actually good so bbr X

00:17:31,659 --> 00:17:37,269
actually becomes the bbr for small beta

00:17:34,620 --> 00:17:39,370
we actually test it with zero beta

00:17:37,269 --> 00:17:42,970
equals to zero point zero one which is

00:17:39,370 --> 00:17:44,240
actually 1 in this graph and basically

00:17:42,970 --> 00:17:47,150
and you tow

00:17:44,240 --> 00:17:49,309
lower flow utility due to overflows as

00:17:47,150 --> 00:17:51,020
bottleneck buffer size is actually

00:17:49,309 --> 00:17:53,630
reduced okay

00:17:51,020 --> 00:17:56,030
so that's actually one observation that

00:17:53,630 --> 00:17:59,929
we actually made from this graph and

00:17:56,030 --> 00:18:02,780
also the other thing is a large beta

00:17:59,929 --> 00:18:04,820
beyond the optimal value which is seems

00:18:02,780 --> 00:18:09,980
like you know zero point six in this

00:18:04,820 --> 00:18:13,190
case the decrease the utility due to

00:18:09,980 --> 00:18:15,140
control instead of instability basically

00:18:13,190 --> 00:18:20,780
we actually observed a large magnitude

00:18:15,140 --> 00:18:23,750
of Cydonia so sign pattern of the hi

00:18:20,780 --> 00:18:26,150
queuing delay followed by the link link

00:18:23,750 --> 00:18:28,130
utilization and that once they actually

00:18:26,150 --> 00:18:30,050
go over so we are actually reacting too

00:18:28,130 --> 00:18:32,240
fast basically that's what it means

00:18:30,050 --> 00:18:37,460
if that's the case we will actually have

00:18:32,240 --> 00:18:40,340
you know less utility so but the good

00:18:37,460 --> 00:18:45,500
thing is the system has wide range of

00:18:40,340 --> 00:18:48,020
stable beta range in this case about 0.2

00:18:45,500 --> 00:18:50,570
2.6 providing a large margin of

00:18:48,020 --> 00:18:52,370
configuration freedom and that we

00:18:50,570 --> 00:18:57,559
thought was actually know pretty cool

00:18:52,370 --> 00:19:00,190
thing okay so this actually shows the

00:18:57,559 --> 00:19:03,920
same utility versus like you know beta

00:19:00,190 --> 00:19:07,120
for different bandwidth so we actually

00:19:03,920 --> 00:19:11,929
increase the bandwidth you know to 15

00:19:07,120 --> 00:19:13,760
50ml BPS to 35 mega BPS 275 million VPS

00:19:11,929 --> 00:19:15,410
and then test with like you know

00:19:13,760 --> 00:19:18,350
different our titties this time

00:19:15,410 --> 00:19:21,140
so we also increase the the RTT from 25

00:19:18,350 --> 00:19:24,920
millisecond to 175 minutes i can see how

00:19:21,140 --> 00:19:29,000
the shape changes so interesting thing

00:19:24,920 --> 00:19:29,900
is as expected when the art it is low is

00:19:29,000 --> 00:19:33,940
pre flat

00:19:29,900 --> 00:19:37,040
if our TT is getting larger and larger

00:19:33,940 --> 00:19:41,570
the sweet spot is actually moving to the

00:19:37,040 --> 00:19:43,610
left side and also getting narrower so

00:19:41,570 --> 00:19:47,929
that was what we actually figure out so

00:19:43,610 --> 00:19:54,080
basically um even though it's okay to

00:19:47,929 --> 00:19:56,510
maybe set it up to 45 0.45 or 0.5 no

00:19:54,080 --> 00:19:58,070
beta to that will probably work well on

00:19:56,510 --> 00:20:02,660
most of the cases you

00:19:58,070 --> 00:20:05,510
if you really want to you know configure

00:20:02,660 --> 00:20:10,070
the debater right for your environment

00:20:05,510 --> 00:20:12,730
then basically we actually concluded

00:20:10,070 --> 00:20:15,770
that you you need no multiple

00:20:12,730 --> 00:20:18,530
configurations of beta according to the

00:20:15,770 --> 00:20:27,680
the capacity and delay of the system

00:20:18,530 --> 00:20:30,440
okay so so we that's that's the reason

00:20:27,680 --> 00:20:32,470
why we we actually propose the network

00:20:30,440 --> 00:20:36,380
condition based configuration approach

00:20:32,470 --> 00:20:39,440
and PBR X Center start with the default

00:20:36,380 --> 00:20:43,610
parameter which is actually set to beta

00:20:39,440 --> 00:20:46,340
equals to 0.45 K equals to 4 and vpr X

00:20:43,610 --> 00:20:49,070
Center refers to the table you know

00:20:46,340 --> 00:20:51,500
when entering the the probe that way

00:20:49,070 --> 00:20:53,360
state basically you know probe bandwidth

00:20:51,500 --> 00:20:57,200
state is actually happening every eight

00:20:53,360 --> 00:21:00,560
RTT right I think the you know it goes

00:20:57,200 --> 00:21:03,850
to the proving RTT you go for the the

00:21:00,560 --> 00:21:07,730
bandwidth check more bandwidth check

00:21:03,850 --> 00:21:09,950
every eight RTT I believe so that's when

00:21:07,730 --> 00:21:13,460
this table is actually looked up again

00:21:09,950 --> 00:21:15,800
to see if there is a you know parameter

00:21:13,460 --> 00:21:19,450
change most likely they won't be a

00:21:15,800 --> 00:21:25,160
primary change for the lifetime of the

00:21:19,450 --> 00:21:27,470
the flow but in mobile word where if

00:21:25,160 --> 00:21:30,590
you're actually driving then it's

00:21:27,470 --> 00:21:33,620
possible that the network condition

00:21:30,590 --> 00:21:35,140
changes and maybe you might need to

00:21:33,620 --> 00:21:37,540
actually change the beta value to

00:21:35,140 --> 00:21:41,990
optimize it father

00:21:37,540 --> 00:21:43,760
okay so and the learning agent daemon is

00:21:41,990 --> 00:21:45,740
actually updating each pin separately

00:21:43,760 --> 00:21:49,190
basically you know it once you actually

00:21:45,740 --> 00:21:51,490
get the enough sample then it just do

00:21:49,190 --> 00:21:54,890
two great in ascendant and then see if

00:21:51,490 --> 00:21:57,770
you know a better beta or the better

00:21:54,890 --> 00:22:01,910
cake and actually be enough found okay

00:21:57,770 --> 00:22:05,780
so basically that's that's basically the

00:22:01,910 --> 00:22:08,360
mechanism so it's a little bit shameful

00:22:05,780 --> 00:22:10,610
that I was not able to evaluate very

00:22:08,360 --> 00:22:11,240
thoroughly so I'm going to actually you

00:22:10,610 --> 00:22:15,559
know give

00:22:11,240 --> 00:22:17,990
the preliminary evaluation result so so

00:22:15,559 --> 00:22:20,360
this the first case is the general

00:22:17,990 --> 00:22:23,600
purpose configuration my first goal is

00:22:20,360 --> 00:22:27,890
delay and then Cooper so if that is the

00:22:23,600 --> 00:22:30,770
case I hold on one second

00:22:27,890 --> 00:22:34,010
before so that's basically what I wanted

00:22:30,770 --> 00:22:38,480
to achieve so this actually shows you

00:22:34,010 --> 00:22:42,620
the emulation topology you know I have a

00:22:38,480 --> 00:22:45,800
host with you know two iperf one one

00:22:42,620 --> 00:22:47,630
hyper server and white one iperf client

00:22:45,800 --> 00:22:50,179
running the Kline is actually pumping

00:22:47,630 --> 00:22:53,870
data to the server so I actually set up

00:22:50,179 --> 00:22:59,390
a an emulation that work like this and

00:22:53,870 --> 00:23:04,070
then I actually set the net en and token

00:22:59,390 --> 00:23:06,290
bucket filter on the vias and you don't

00:23:04,070 --> 00:23:09,170
really need to do this but I actually

00:23:06,290 --> 00:23:13,070
installed the the natty em on the the

00:23:09,170 --> 00:23:15,110
container side to give in this case 25

00:23:13,070 --> 00:23:17,390
milliseconds so I actually divided the

00:23:15,110 --> 00:23:19,550
the 25 millisecond into two or twelve

00:23:17,390 --> 00:23:24,830
millisecond and in 13 millisecond it's

00:23:19,550 --> 00:23:27,470
just to just to make as close to the

00:23:24,830 --> 00:23:29,720
real environment but I don't think it's

00:23:27,470 --> 00:23:33,950
really knitted but anyway so that's the

00:23:29,720 --> 00:23:40,850
the emulation topology that I used okay

00:23:33,950 --> 00:23:43,490
so so since you are in normal case if

00:23:40,850 --> 00:23:45,890
I'm actually targeting to have minimum

00:23:43,490 --> 00:23:51,020
delay basically I don't want any queuing

00:23:45,890 --> 00:23:54,320
delay at D what is it too congested you

00:23:51,020 --> 00:23:56,030
know bottleneck point because once you

00:23:54,320 --> 00:23:57,860
know the currying delay is actually you

00:23:56,030 --> 00:24:01,070
know you have a consistent queuing delay

00:23:57,860 --> 00:24:05,240
then it's actually very tricky because

00:24:01,070 --> 00:24:09,290
remember we actually use the you know r0

00:24:05,240 --> 00:24:13,010
which is actually a minimum RTT to do to

00:24:09,290 --> 00:24:14,770
compute like you know what is it and and

00:24:13,010 --> 00:24:19,010
a lot of like control is based on the

00:24:14,770 --> 00:24:22,390
the r0 so once the the the queuing delay

00:24:19,010 --> 00:24:25,159
is growing up in the bottom the routers

00:24:22,390 --> 00:24:28,009
DB are control might be actually

00:24:25,159 --> 00:24:31,879
off and that is one you know one of the

00:24:28,009 --> 00:24:34,639
reason I believe you know that actually

00:24:31,879 --> 00:24:37,609
cause some or is the unfairness and

00:24:34,639 --> 00:24:39,859
stuff like that so basically what the

00:24:37,609 --> 00:24:41,809
first goal here is I don't want any

00:24:39,859 --> 00:24:43,970
trading delay and in this case I would

00:24:41,809 --> 00:24:48,320
actually set the decay equals to four

00:24:43,970 --> 00:24:51,710
and gamma cos 0.98 or even maybe point

00:24:48,320 --> 00:24:55,970
nine point ninety five so and actually

00:24:51,710 --> 00:25:03,019
did the test you know using 0.98 and K

00:24:55,970 --> 00:25:05,509
equals to four and the network sorry

00:25:03,019 --> 00:25:09,289
this is not 10-minute recess error it's

00:25:05,509 --> 00:25:10,369
actually a hundred mega bps yeah it was

00:25:09,289 --> 00:25:18,950
a hundred mega grief yes

00:25:10,369 --> 00:25:22,519
so whoops so it was 100 Mbps and the the

00:25:18,950 --> 00:25:24,379
round-trip time of the system was 25

00:25:22,519 --> 00:25:27,080
millisecond and then the queue length I

00:25:24,379 --> 00:25:33,049
said to 132 millisecond and then run

00:25:27,080 --> 00:25:35,330
cubic run be BR and ran PPR X so the

00:25:33,049 --> 00:25:37,099
bandwidth you're like the if you look at

00:25:35,330 --> 00:25:40,609
the the link utilization and know the

00:25:37,099 --> 00:25:44,749
bandwidth the throughput basically the

00:25:40,609 --> 00:25:46,519
cubic was eighty eight point six the BPR

00:25:44,749 --> 00:25:49,970
was actually doing better ninety four

00:25:46,519 --> 00:25:51,799
point six and the BP rx was actually

00:25:49,970 --> 00:25:57,489
with this configuration was actually

00:25:51,799 --> 00:26:02,929
doing slightly you know lower than PPR

00:25:57,489 --> 00:26:07,639
92.9 metal bps okay so this actually

00:26:02,929 --> 00:26:11,239
shows the outstanding window and the RTT

00:26:07,639 --> 00:26:12,739
of the cubic so as expected if you

00:26:11,239 --> 00:26:15,590
actually we know work on congestion

00:26:12,739 --> 00:26:18,229
control the leftmost graph is is very

00:26:15,590 --> 00:26:20,779
you should be very familiar with it and

00:26:18,229 --> 00:26:24,139
then the BB R is actually in the middle

00:26:20,779 --> 00:26:25,999
as you can see it BB r is actually you

00:26:24,139 --> 00:26:28,539
know doing the good job at like no

00:26:25,999 --> 00:26:31,429
staying at the or is it the bandwidth

00:26:28,539 --> 00:26:33,979
bottleneck man with sending at the

00:26:31,429 --> 00:26:35,800
bottom that bandwidth but the Q was

00:26:33,979 --> 00:26:39,010
actually going up and down

00:26:35,800 --> 00:26:41,680
- I think 80 80 millisecond and going

00:26:39,010 --> 00:26:47,350
down and stuff like that if you look at

00:26:41,680 --> 00:26:51,970
the the BB rx basically the cue was just

00:26:47,350 --> 00:26:58,180
also oscillating around the the path RTT

00:26:51,970 --> 00:27:03,160
and so basically this is the test with

00:26:58,180 --> 00:27:05,620
one flow and okay so basically what this

00:27:03,160 --> 00:27:07,570
section shows is VBR control function is

00:27:05,620 --> 00:27:09,690
actually a PBR X control function is

00:27:07,570 --> 00:27:13,240
actually achieving what is trying to do

00:27:09,690 --> 00:27:17,080
but is it going to be true for multiple

00:27:13,240 --> 00:27:20,860
flows so I actually did increase the

00:27:17,080 --> 00:27:27,760
number of flow to four and then you know

00:27:20,860 --> 00:27:29,620
look at the same thing so basically so

00:27:27,760 --> 00:27:35,170
if you actually look at the BP rx

00:27:29,620 --> 00:27:40,090
the RTT the rtt is still you know around

00:27:35,170 --> 00:27:43,240
the system RTT and if you look at all

00:27:40,090 --> 00:27:46,180
four flows of our T TS I just look at

00:27:43,240 --> 00:27:49,000
the all four flows of the RTT they were

00:27:46,180 --> 00:27:51,580
actually staying very low so it seems

00:27:49,000 --> 00:27:52,660
like you know baby BRX is actually doing

00:27:51,580 --> 00:27:54,700
what it's supposed to do

00:27:52,660 --> 00:27:58,780
I mean I'm not really saying that I

00:27:54,700 --> 00:28:00,220
can't really conclude right now but you

00:27:58,780 --> 00:28:03,040
know I really need to actually do a

00:28:00,220 --> 00:28:07,960
little more testing on it but as of now

00:28:03,040 --> 00:28:10,810
it seems pretty promising okay so the

00:28:07,960 --> 00:28:15,070
next thing is if I really want to

00:28:10,810 --> 00:28:19,320
actually configure the BP rx to achieve

00:28:15,070 --> 00:28:22,870
good put first and then delay then

00:28:19,320 --> 00:28:24,400
basically the things that we we actually

00:28:22,870 --> 00:28:26,710
introduced like you know using the

00:28:24,400 --> 00:28:29,050
learning agent and all that thing will

00:28:26,710 --> 00:28:31,570
be probably needed because we don't know

00:28:29,050 --> 00:28:34,780
which K value greater than four will be

00:28:31,570 --> 00:28:37,300
the will be the best k value for to

00:28:34,780 --> 00:28:42,430
actually achieve the ghupat but minimize

00:28:37,300 --> 00:28:45,370
the delay okay so I haven't actually

00:28:42,430 --> 00:28:48,610
showed that here but I actually set the

00:28:45,370 --> 00:28:49,610
decay equals to 6 in this case gamma it

00:28:48,610 --> 00:28:52,970
goes to what I said

00:28:49,610 --> 00:28:56,120
one and then no K equals to 6 then in

00:28:52,970 --> 00:28:59,540
another run I actually said the K equals

00:28:56,120 --> 00:29:02,960
day in this graph what I would like to

00:28:59,540 --> 00:29:06,610
actually show is how to decree in July I

00:29:02,960 --> 00:29:09,620
mean the rtt is actually oscillating so

00:29:06,610 --> 00:29:14,390
basically if you actually read the the

00:29:09,620 --> 00:29:17,570
average RTT when the decay was set to 6

00:29:14,390 --> 00:29:21,650
which means like 1.5 of our mean RTT it

00:29:17,570 --> 00:29:24,380
was it was about 32 or somewhere 37 or

00:29:21,650 --> 00:29:27,740
somewhere and then when I actually set

00:29:24,380 --> 00:29:29,870
the decay eco state the queuing the

00:29:27,740 --> 00:29:33,320
delay the RTT was actually Austin a

00:29:29,870 --> 00:29:36,590
oscillating around 50 milliseconds where

00:29:33,320 --> 00:29:39,110
the the system martyt was set to 25

00:29:36,590 --> 00:29:44,660
millisecond so it seems like the control

00:29:39,110 --> 00:29:49,030
is actually working well so then we

00:29:44,660 --> 00:29:53,660
actually bring this to the real word so

00:29:49,030 --> 00:29:59,270
we actually we installed the DB rx into

00:29:53,660 --> 00:30:03,470
one of our server in Texas and you know

00:29:59,270 --> 00:30:07,730
did the 100 megabyte file download and

00:30:03,470 --> 00:30:08,350
then basically just compare with BB R&B

00:30:07,730 --> 00:30:12,140
BRX

00:30:08,350 --> 00:30:14,299
in this case we actually set the the

00:30:12,140 --> 00:30:19,669
gamma goes to 1 and k equals to 6

00:30:14,299 --> 00:30:21,620
meeting like 1.5 of the mean RT t so we

00:30:19,669 --> 00:30:24,080
really need more time to actually

00:30:21,620 --> 00:30:26,210
evaluate this but it seems like the BB

00:30:24,080 --> 00:30:32,690
Rx is actually you know working pretty

00:30:26,210 --> 00:30:35,809
well and it was able to reduce the you

00:30:32,690 --> 00:30:39,559
know manage the RTT in the range that we

00:30:35,809 --> 00:30:41,600
want and for some reason I don't I don't

00:30:39,559 --> 00:30:43,820
know if this is this particular run or

00:30:41,600 --> 00:30:46,910
not but you know it was actually

00:30:43,820 --> 00:30:49,220
finishing earlier than BB r because VBR

00:30:46,910 --> 00:30:51,350
was actually timing out in the first

00:30:49,220 --> 00:30:54,020
like two to three seconds

00:30:51,350 --> 00:30:59,210
it actually pushed too much and then it

00:30:54,020 --> 00:31:01,910
got RTO but it seems like this mechanism

00:30:59,210 --> 00:31:02,919
would be a good candidate to play with

00:31:01,910 --> 00:31:06,580
for

00:31:02,919 --> 00:31:09,460
wireless network okay by the way we

00:31:06,580 --> 00:31:12,549
actually tested this in a good RF

00:31:09,460 --> 00:31:17,559
condition okay which is si and are some

00:31:12,549 --> 00:31:24,489
single si eye on our R of 25 DB or

00:31:17,559 --> 00:31:26,850
larger okay okay so summary so BP rx we

00:31:24,489 --> 00:31:31,809
introduced API control function to be BR

00:31:26,850 --> 00:31:34,869
we export the of the per-flow tcp

00:31:31,809 --> 00:31:39,039
special user space you know via net link

00:31:34,869 --> 00:31:41,129
socket and the learning agent is it

00:31:39,039 --> 00:31:45,429
actually depth of utility function to

00:31:41,129 --> 00:31:48,460
score average tcp see a performance

00:31:45,429 --> 00:31:50,889
adjust the DB RX control parameter to

00:31:48,460 --> 00:31:55,600
ill the best utility while keeping the

00:31:50,889 --> 00:31:57,609
the RTT to the minimum so this is

00:31:55,600 --> 00:32:00,730
actually loosely coupled like you know

00:31:57,609 --> 00:32:02,739
tcp tuning feedback control loop probe

00:32:00,730 --> 00:32:04,899
on this controller battery provides an

00:32:02,739 --> 00:32:07,389
oval way we think - ashley monitor and

00:32:04,899 --> 00:32:09,879
adjust the tcp parameter per the

00:32:07,389 --> 00:32:12,700
performance goal in real time while

00:32:09,879 --> 00:32:14,289
minimizing the risk of deploying they

00:32:12,700 --> 00:32:18,190
preaching the learning algorithm in the

00:32:14,289 --> 00:32:19,480
fast path wow this is long but i think

00:32:18,190 --> 00:32:23,369
this is what we are trying to achieve

00:32:19,480 --> 00:32:27,730
and okay so current status so

00:32:23,369 --> 00:32:29,220
preliminary evaluation result looked

00:32:27,730 --> 00:32:32,470
good

00:32:29,220 --> 00:32:34,210
the BB RX reduces the shallow buffer

00:32:32,470 --> 00:32:35,950
overflow we actually tested that as well

00:32:34,210 --> 00:32:39,249
even though we actually didn't show you

00:32:35,950 --> 00:32:41,859
here and customize the the tcp

00:32:39,249 --> 00:32:43,989
performance alt that approach it looks

00:32:41,859 --> 00:32:46,809
pretty promising

00:32:43,989 --> 00:32:50,139
and we actually proposed the kernel

00:32:46,809 --> 00:32:52,210
patch to get the TCP congestion control

00:32:50,139 --> 00:32:55,259
information via net link sake wrongful

00:32:52,210 --> 00:33:00,090
termination event that was not there so

00:32:55,259 --> 00:33:04,090
actually Jamal is in process of you know

00:33:00,090 --> 00:33:06,639
you know submitting to patch and bbr X

00:33:04,090 --> 00:33:09,519
and T TCP stack collector

00:33:06,639 --> 00:33:12,750
code is available at the gate up

00:33:09,519 --> 00:33:20,039
location I just put it up today

00:33:12,750 --> 00:33:23,760
okay so future work more evaluation and

00:33:20,039 --> 00:33:25,950
then and I would really love to evaluate

00:33:23,760 --> 00:33:27,570
the fair and so Mon bébé are ex flow I

00:33:25,950 --> 00:33:31,860
mean I don't really want to spend more

00:33:27,570 --> 00:33:34,140
time on like evaluating vvr X versus

00:33:31,860 --> 00:33:36,659
cubic because it's two different

00:33:34,140 --> 00:33:38,820
mechanism going for two different goals

00:33:36,659 --> 00:33:41,730
and I don't think it's gonna achieve the

00:33:38,820 --> 00:33:44,940
the fairness I mean depends on what how

00:33:41,730 --> 00:33:47,130
you define the fairness however bbr X

00:33:44,940 --> 00:33:49,590
may actually do a little better in terms

00:33:47,130 --> 00:33:52,500
of fairness because because of this you

00:33:49,590 --> 00:33:56,130
know reacting to the queuing delay it

00:33:52,500 --> 00:34:00,030
may actually have better chance by you

00:33:56,130 --> 00:34:02,940
know from the what is it the game theory

00:34:00,030 --> 00:34:04,919
perspective if if you are trying to play

00:34:02,940 --> 00:34:06,690
a game to win and everybody is like

00:34:04,919 --> 00:34:08,220
doing that and that actually gives you a

00:34:06,690 --> 00:34:11,250
better perform and very fairness

00:34:08,220 --> 00:34:14,700
performance however what we actually did

00:34:11,250 --> 00:34:16,849
saw was bbr was actually two not

00:34:14,700 --> 00:34:18,899
aggressive it's once it actually no

00:34:16,849 --> 00:34:20,369
estimate the bandwidth is actually stay

00:34:18,899 --> 00:34:24,080
with that you know stay with the

00:34:20,369 --> 00:34:26,970
bandwidth and only one that one out of a

00:34:24,080 --> 00:34:29,210
30 T is just broke for the bandwidth so

00:34:26,970 --> 00:34:31,470
if you're just doing a little more

00:34:29,210 --> 00:34:34,530
frequent like you know bandwidth

00:34:31,470 --> 00:34:36,540
adjustment based on the queue length RTT

00:34:34,530 --> 00:34:38,790
grow and less that might actually you

00:34:36,540 --> 00:34:41,070
know impact their fairness a little bit

00:34:38,790 --> 00:34:46,109
so that is another future work that I

00:34:41,070 --> 00:34:47,700
would like to see the review and also if

00:34:46,109 --> 00:34:50,339
you like the peer control function

00:34:47,700 --> 00:34:55,080
variations such as one used in ABC ABC

00:34:50,339 --> 00:34:58,920
is very similar but what it does is it

00:34:55,080 --> 00:35:00,930
actually reduce the transmission rate

00:34:58,920 --> 00:35:02,250
the bandwidth the target bandwidth the

00:35:00,930 --> 00:35:04,890
part it doesn't actually increase when

00:35:02,250 --> 00:35:06,930
the P I controls as increasing it

00:35:04,890 --> 00:35:09,060
doesn't increase but it only decrease I

00:35:06,930 --> 00:35:10,440
mean probably they have their own reason

00:35:09,060 --> 00:35:14,220
because they want to actually minimize

00:35:10,440 --> 00:35:16,380
the RTT not the opportunity to cream

00:35:14,220 --> 00:35:18,780
delay and therefore I think this is

00:35:16,380 --> 00:35:22,980
another good variation to actually test

00:35:18,780 --> 00:35:32,190
with with BB rx

00:35:22,980 --> 00:35:35,579
okay any questions I had a quick

00:35:32,190 --> 00:35:39,359
question about how you envision this

00:35:35,579 --> 00:35:41,160
coexisting with cubic or Reno or are you

00:35:39,359 --> 00:35:43,740
imagining this is just targeting at

00:35:41,160 --> 00:35:45,810
scenarios like a cellular operator who

00:35:43,740 --> 00:35:47,220
might terminate TCP connections and and

00:35:45,810 --> 00:35:49,800
know that all of the traffic on their

00:35:47,220 --> 00:35:54,720
network was this flavor of bbr or

00:35:49,800 --> 00:35:57,960
something yeah I mean that's actually

00:35:54,720 --> 00:36:01,619
tough question so in the the pet word I

00:35:57,960 --> 00:36:04,859
think it works great if you really want

00:36:01,619 --> 00:36:06,750
to actually make this to be used in

00:36:04,859 --> 00:36:10,170
public I think we need to actually look

00:36:06,750 --> 00:36:12,480
at it but I I don't think the the goal

00:36:10,170 --> 00:36:16,920
should be having the equal bandwidth

00:36:12,480 --> 00:36:18,869
allocation with cubic I don't think it

00:36:16,920 --> 00:36:20,099
can be achievable because it's two

00:36:18,869 --> 00:36:24,030
different mechanism however

00:36:20,099 --> 00:36:26,060
if if it's not really starting the

00:36:24,030 --> 00:36:29,730
tekubi I think that should be fine

00:36:26,060 --> 00:36:31,349
that's my opinion only but yeah I guess

00:36:29,730 --> 00:36:34,740
my concern was more in the direction of

00:36:31,349 --> 00:36:37,200
it seems like if if this algorithm would

00:36:34,740 --> 00:36:39,839
run coexisting with Reno or cubic then

00:36:37,200 --> 00:36:43,500
the Reno or cubic would continue to grow

00:36:39,839 --> 00:36:46,380
the queue and this would back off and

00:36:43,500 --> 00:36:50,130
eventually have been nothing like Vegas

00:36:46,380 --> 00:36:51,960
or a Lola I guess yeah so yeah I mean

00:36:50,130 --> 00:36:54,569
it's - I think that's still are

00:36:51,960 --> 00:36:57,420
concerned because this mechanism will

00:36:54,569 --> 00:36:59,369
actually so the cubic is going to

00:36:57,420 --> 00:37:01,910
actually increase the queuing delay and

00:36:59,369 --> 00:37:06,540
then this guy is actually backing up so

00:37:01,910 --> 00:37:10,230
in this case probably the PBR X will

00:37:06,540 --> 00:37:12,060
actually have low bandwidth allocation

00:37:10,230 --> 00:37:14,369
but it does sound like this is targeted

00:37:12,060 --> 00:37:16,650
more at sooner than our operators who

00:37:14,369 --> 00:37:19,260
might happen to know that they control

00:37:16,650 --> 00:37:21,210
all the congestion control algorithms on

00:37:19,260 --> 00:37:24,060
their network is that right right okay

00:37:21,210 --> 00:37:25,740
so it's anyway per device queue and we

00:37:24,060 --> 00:37:28,500
don't really have too many flows per

00:37:25,740 --> 00:37:31,170
device I mean concurrently happening so

00:37:28,500 --> 00:37:34,339
this would be a you know a very good you

00:37:31,170 --> 00:37:34,339
know mechanism to consider

00:37:34,440 --> 00:37:39,520
hi very interesting work I definitely

00:37:37,690 --> 00:37:43,210
want to look at the patches on your

00:37:39,520 --> 00:37:48,400
github in one of your graph I think it

00:37:43,210 --> 00:37:52,200
was the SEC third last slide that I

00:37:48,400 --> 00:37:55,990
noticed I had this one so the left one

00:37:52,200 --> 00:37:58,930
so at one period between the second two

00:37:55,990 --> 00:38:01,180
to three PV I was ramping up like nuts

00:37:58,930 --> 00:38:03,820
while BB r ex was doing the exact

00:38:01,180 --> 00:38:10,240
opposite and insight why they are going

00:38:03,820 --> 00:38:13,300
in completely different directions not

00:38:10,240 --> 00:38:14,830
really at this point I can't really give

00:38:13,300 --> 00:38:16,780
you so so what is the question so can

00:38:14,830 --> 00:38:19,570
you actually point out so how come like

00:38:16,780 --> 00:38:22,690
between second two to Street BB are

00:38:19,570 --> 00:38:26,740
ramps up to you know like basically oh I

00:38:22,690 --> 00:38:28,990
see so so this is a little tricky but

00:38:26,740 --> 00:38:31,120
you know basically at one art when our

00:38:28,990 --> 00:38:33,910
queue actually happens this is actually

00:38:31,120 --> 00:38:39,340
measured by the looking at the act so

00:38:33,910 --> 00:38:42,370
the RTT goes up but if so the BP rx was

00:38:39,340 --> 00:38:44,920
actually going into draining phase and

00:38:42,370 --> 00:38:48,250
therefore it was actually going down so

00:38:44,920 --> 00:38:50,950
if so basically it was it was lucky that

00:38:48,250 --> 00:38:53,350
it didn't actually cause the law RTO and

00:38:50,950 --> 00:38:57,160
then it actually went to the draining

00:38:53,350 --> 00:38:59,740
face to the what is that the the normal

00:38:57,160 --> 00:39:02,500
face that I believe is what's happening

00:38:59,740 --> 00:39:06,430
here okay so the in fly that comes down

00:39:02,500 --> 00:39:09,570
from the cliff is the nosedive of the in

00:39:06,430 --> 00:39:14,170
fly is because of the training yeah and

00:39:09,570 --> 00:39:17,020
BB rx did not do the training because

00:39:14,170 --> 00:39:20,800
for BB Rx is actually he went down first

00:39:17,020 --> 00:39:23,200
and then came back up or BB rx did the

00:39:20,800 --> 00:39:25,150
training PBR actually is also doing the

00:39:23,200 --> 00:39:27,250
draining so that logic is exactly the

00:39:25,150 --> 00:39:29,980
same but even the draining face on that

00:39:27,250 --> 00:39:31,920
we are actually adjusting based on out

00:39:29,980 --> 00:39:36,040
the bandwidth based on the queuing delay

00:39:31,920 --> 00:39:38,740
hey so yes I I really have to actually

00:39:36,040 --> 00:39:41,740
look into look more detail into it but

00:39:38,740 --> 00:39:44,110
that's basically what he's doing so the

00:39:41,740 --> 00:39:46,640
amount of code that I the code that I

00:39:44,110 --> 00:39:50,120
just showed you is the the only

00:39:46,640 --> 00:39:51,920
the logical change to the VBR okay yeah

00:39:50,120 --> 00:39:53,720
if you have choices that you can show us

00:39:51,920 --> 00:39:57,230
I'm happy to look at the bbro

00:39:53,720 --> 00:39:59,990
okay yeah I guess a quick guess would be

00:39:57,230 --> 00:40:02,990
perhaps that the omen calculation didn't

00:39:59,990 --> 00:40:05,990
account for sacs I've seen this in TCP

00:40:02,990 --> 00:40:08,090
trays for example I think we'll think

00:40:05,990 --> 00:40:10,430
that the outstanding window is actually

00:40:08,090 --> 00:40:13,280
twice what it is because half of that is

00:40:10,430 --> 00:40:15,080
actually sacked so that might be what's

00:40:13,280 --> 00:40:17,750
happening here is that basically the B

00:40:15,080 --> 00:40:20,240
VXR sees that the delay is growing and

00:40:17,750 --> 00:40:22,910
it drains just in time to avoid loss or

00:40:20,240 --> 00:40:25,970
as bbr starts taking losses sees a bunch

00:40:22,910 --> 00:40:28,520
of stuff sacked and maybe this number it

00:40:25,970 --> 00:40:30,890
doesn't take account of the sacks and so

00:40:28,520 --> 00:40:32,780
the bbr looks like it's twice what it

00:40:30,890 --> 00:40:35,660
ought to be or something that's one

00:40:32,780 --> 00:40:40,250
thing one possibility anyway okay thank

00:40:35,660 --> 00:40:44,670
you hey thanks Jay thank you

00:40:40,250 --> 00:40:47,860
[Music]

00:40:44,670 --> 00:40:47,860

YouTube URL: https://www.youtube.com/watch?v=PeYPqnLhUuc


