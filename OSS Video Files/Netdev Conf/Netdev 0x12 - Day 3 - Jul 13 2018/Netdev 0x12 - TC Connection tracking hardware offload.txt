Title: Netdev 0x12 - TC Connection tracking hardware offload
Publication date: 2018-08-01
Playlist: Netdev 0x12 - Day 3 - Jul 13 2018
Description: 
	Rony Efraim was back again for Netdev 0x12 in Montreal on July 13th, 2018.
At netdev 2.2 he and Guy Shattah discussed and demonstrated a PoC to add connection tracking support[1].
They have taken the feedback given to them in Seoul and and gained more insight.

In this talk, Rony briefly discussed the existing offloading mechanisms already used by TC, the addition of connection tracking within TC, and in more detail, ways to implement offloading of connection tracking.

More info:
https://www.netdevconf.org/0x12/session.html?implementing-tc-connection-tracking-offload

[1]https://www.youtube.com/watch?v=2CcKzGOdyP0
Captions: 
	00:00:02,990 --> 00:00:06,230
hi good morning

00:00:06,950 --> 00:00:11,730
some I'm running from Mellanox and I

00:00:09,900 --> 00:00:14,070
want to talk about the connection

00:00:11,730 --> 00:00:17,670
tracking that's our already spoke last

00:00:14,070 --> 00:00:20,609
time the last night ever and now because

00:00:17,670 --> 00:00:22,680
we are a vendor that's want to take

00:00:20,609 --> 00:00:24,810
everything to the hardware so I will

00:00:22,680 --> 00:00:32,689
speak of how we're going to take the

00:00:24,810 --> 00:00:32,689
connection tracking into the hardware so

00:00:38,800 --> 00:00:48,469
this is not the last slide deck but okay

00:00:41,960 --> 00:00:50,360
I'm fine so the connection crackling

00:00:48,469 --> 00:00:52,460
first I want to explain what is

00:00:50,360 --> 00:00:54,440
connection tracking that's all the

00:00:52,460 --> 00:00:59,269
audience will understand me not to fall

00:00:54,440 --> 00:01:01,940
asleep so connect tracking is kind of a

00:00:59,269 --> 00:01:04,190
basic thing that's using in firewall in

00:01:01,940 --> 00:01:07,820
order to understand when connection is

00:01:04,190 --> 00:01:09,830
starting and a TCP connection so you're

00:01:07,820 --> 00:01:11,690
looking on the scenes in AK and where

00:01:09,830 --> 00:01:14,810
the connection is closed on the fin or

00:01:11,690 --> 00:01:18,380
if it's a reset so there is a code in

00:01:14,810 --> 00:01:23,179
the kernel called the contract that is

00:01:18,380 --> 00:01:27,470
used for connection tracking it's part

00:01:23,179 --> 00:01:30,259
of the net filter and it's doing for

00:01:27,470 --> 00:01:31,970
every packet two things first he

00:01:30,259 --> 00:01:34,190
identify if it's a new connection if

00:01:31,970 --> 00:01:36,890
it's it's already know this connection

00:01:34,190 --> 00:01:39,229
have a hash table of all the current

00:01:36,890 --> 00:01:42,079
connection and for every connection

00:01:39,229 --> 00:01:44,210
everybody validate and not open a new

00:01:42,079 --> 00:01:46,729
entry for this connection he is doing a

00:01:44,210 --> 00:01:49,670
TCP for TCP is doing also window

00:01:46,729 --> 00:01:52,040
validation so for every packet and you

00:01:49,670 --> 00:01:56,210
need to exam and that is in the current

00:01:52,040 --> 00:01:57,890
TCP window and if it is he is updating

00:01:56,210 --> 00:02:03,380
his information you know that the

00:01:57,890 --> 00:02:04,909
windows is progressing so this is the

00:02:03,380 --> 00:02:10,310
two things that connection tracking is

00:02:04,909 --> 00:02:14,480
doing today so I am coming and from and

00:02:10,310 --> 00:02:17,209
we are doing a obvious offload for it's

00:02:14,480 --> 00:02:19,700
just for example of course we have some

00:02:17,209 --> 00:02:23,989
customer that's working with our taken

00:02:19,700 --> 00:02:27,590
without obvious that consume it for

00:02:23,989 --> 00:02:34,130
cloud proposal proposals but without a

00:02:27,590 --> 00:02:36,340
of yes have some proprietary and using

00:02:34,130 --> 00:02:41,630
the same concept so for obvious

00:02:36,340 --> 00:02:43,940
connection tracking city we also want to

00:02:41,630 --> 00:02:47,150
use the same so ok so I'll explain how

00:02:43,940 --> 00:02:48,710
it work today with obvious so obvious is

00:02:47,150 --> 00:02:50,900
using this

00:02:48,710 --> 00:02:52,370
the colonel connection tracking the

00:02:50,900 --> 00:02:57,440
contract from the netfilter

00:02:52,370 --> 00:02:59,300
and it's forwarded to the to the model

00:02:57,440 --> 00:03:01,580
of site after the connection tracking

00:02:59,300 --> 00:03:04,780
get the information from the connection

00:03:01,580 --> 00:03:07,490
tracking if it's a new establish or and

00:03:04,780 --> 00:03:10,730
the status of the connection tracking

00:03:07,490 --> 00:03:12,410
and then you have another table that's

00:03:10,730 --> 00:03:14,570
can specify okay if it's in your

00:03:12,410 --> 00:03:17,600
connection those are the action if it's

00:03:14,570 --> 00:03:20,890
already established that's the action

00:03:17,600 --> 00:03:23,810
probably you open you allow usually you

00:03:20,890 --> 00:03:25,130
allow to open a connection so it's a new

00:03:23,810 --> 00:03:29,870
connection can be come from one

00:03:25,130 --> 00:03:38,690
direction and the other way it's only

00:03:29,870 --> 00:03:41,810
available if it's establish okay so the

00:03:38,690 --> 00:03:48,350
concept that so we want to take take it

00:03:41,810 --> 00:03:51,490
to the hardware so first today already

00:03:48,350 --> 00:03:54,710
today we're using TC to hardware offload

00:03:51,490 --> 00:03:58,090
other obvious things into the hardware

00:03:54,710 --> 00:04:03,170
so we want to use of course the same and

00:03:58,090 --> 00:04:06,080
and we also understand that connection

00:04:03,170 --> 00:04:08,480
tracking it is used by using the

00:04:06,080 --> 00:04:12,470
contract in the kernel so we also want

00:04:08,480 --> 00:04:19,180
to use that so now we need that TC will

00:04:12,470 --> 00:04:22,430
call connection tracking called city but

00:04:19,180 --> 00:04:25,070
even that we want to take everything to

00:04:22,430 --> 00:04:27,920
the hardware we don't thinks and we

00:04:25,070 --> 00:04:30,170
don't want to take the creation of a new

00:04:27,920 --> 00:04:33,800
connection into the hardware so we want

00:04:30,170 --> 00:04:36,950
that's every packet the first packet

00:04:33,800 --> 00:04:39,470
first few the the scenes in AK of a

00:04:36,950 --> 00:04:40,970
connection will go to the software the

00:04:39,470 --> 00:04:44,090
software will decide what you want to do

00:04:40,970 --> 00:04:47,090
with that and only while the connection

00:04:44,090 --> 00:04:49,990
is established then we want to take it

00:04:47,090 --> 00:04:49,990
to the hardware

00:04:56,580 --> 00:05:06,099
so the software should look like okay I

00:05:02,439 --> 00:05:08,159
have kisi tables and one of the tape one

00:05:06,099 --> 00:05:12,520
of the action in the connection in a

00:05:08,159 --> 00:05:15,099
sari in the TC TC filter will be go to

00:05:12,520 --> 00:05:17,709
connection tracking so in the software

00:05:15,099 --> 00:05:20,409
we indeed will do the same we send the

00:05:17,709 --> 00:05:22,449
packet to the connection tracking and

00:05:20,409 --> 00:05:24,969
the connection tracking will identify

00:05:22,449 --> 00:05:28,029
the packet open a new connection if

00:05:24,969 --> 00:05:30,490
needed and will return and information

00:05:28,029 --> 00:05:31,479
on this pocket and there is already

00:05:30,490 --> 00:05:38,020
today

00:05:31,479 --> 00:05:42,039
SKB in city state that you can see what

00:05:38,020 --> 00:05:46,709
is the connection is the state after the

00:05:42,039 --> 00:05:50,949
connection tracking goes over it and

00:05:46,709 --> 00:05:54,369
then in the next table on the TC we can

00:05:50,949 --> 00:06:01,659
do some lookup according to the

00:05:54,369 --> 00:06:10,240
connection information that we got okay

00:06:01,659 --> 00:06:18,189
let's explain so two more so to more

00:06:10,240 --> 00:06:21,219
detail so okay okay so what what we need

00:06:18,189 --> 00:06:23,800
to add to TC is two things first to

00:06:21,219 --> 00:06:26,499
allow to specify a way to go to

00:06:23,800 --> 00:06:29,169
connection tracking and this is

00:06:26,499 --> 00:06:31,749
approximately the same as obvious is

00:06:29,169 --> 00:06:35,800
using today the kernel but now it will

00:06:31,749 --> 00:06:37,959
be a true T C so you have a rule you can

00:06:35,800 --> 00:06:40,269
say rule as I mentioned before you can

00:06:37,959 --> 00:06:43,360
specify go to connection tracking and

00:06:40,269 --> 00:06:45,879
give some more information like how you

00:06:43,360 --> 00:06:48,490
want to continue when you go do you have

00:06:45,879 --> 00:06:51,539
a zone or other information that you

00:06:48,490 --> 00:06:54,430
want to give to the connection tracking

00:06:51,539 --> 00:06:57,509
so this will be a new action in the

00:06:54,430 --> 00:06:57,509
connect in the TC

00:06:59,740 --> 00:07:05,740
and also a new match to match according

00:07:04,060 --> 00:07:08,350
to the cool according to the action to

00:07:05,740 --> 00:07:11,020
the state that came back from the

00:07:08,350 --> 00:07:12,520
connection tracking so when a packet is

00:07:11,020 --> 00:07:19,120
coming back from the connection tracking

00:07:12,520 --> 00:07:22,630
and we want to see what is the state for

00:07:19,120 --> 00:07:26,470
it is it establish if it's invalid if

00:07:22,630 --> 00:07:35,160
it's related there are many options that

00:07:26,470 --> 00:07:38,770
can be B and here's some an example I

00:07:35,160 --> 00:07:41,530
always also present it last year for

00:07:38,770 --> 00:07:44,020
example of how a city command line will

00:07:41,530 --> 00:07:46,900
look like so as you can see there are

00:07:44,020 --> 00:07:51,190
matches in the first line and an action

00:07:46,900 --> 00:07:53,680
go to connection tracking and how you

00:07:51,190 --> 00:07:55,380
can how you continue because you go into

00:07:53,680 --> 00:07:58,300
connection tracking and probably want to

00:07:55,380 --> 00:08:00,550
do a look-up on the value that is coming

00:07:58,300 --> 00:08:09,520
back and this is the example of the

00:08:00,550 --> 00:08:14,020
second okay and now we want to take it

00:08:09,520 --> 00:08:15,730
to the hardware so we want to take a

00:08:14,020 --> 00:08:18,400
general case of course of connection

00:08:15,730 --> 00:08:19,870
tracking because people we can do first

00:08:18,400 --> 00:08:25,450
connection tracking another connection

00:08:19,870 --> 00:08:28,690
tracking to have and to do some branch

00:08:25,450 --> 00:08:31,480
in the tables like because it's it's

00:08:28,690 --> 00:08:34,210
softer and DUP and mineral powder is

00:08:31,480 --> 00:08:37,780
also very flexible and other that it it

00:08:34,210 --> 00:08:41,680
also can support that so here for

00:08:37,780 --> 00:08:43,480
example you can see that in the upper

00:08:41,680 --> 00:08:47,860
table we are going to connection

00:08:43,480 --> 00:08:50,110
tracking for example and few tables and

00:08:47,860 --> 00:08:52,690
we continue with tables and down below

00:08:50,110 --> 00:08:54,700
there is a split what you want to do

00:08:52,690 --> 00:08:58,300
with a new connection and what you want

00:08:54,700 --> 00:08:59,890
to do with establish connection so this

00:08:58,300 --> 00:09:02,700
is the concept that what the customer

00:08:59,890 --> 00:09:02,700
wanted to have

00:09:07,480 --> 00:09:14,780
okay and what we want to do is okay we

00:09:12,710 --> 00:09:16,970
know that's a pocket one the husband we

00:09:14,780 --> 00:09:19,460
want the pocket the will to connection

00:09:16,970 --> 00:09:22,130
tracking so we take the packet to the

00:09:19,460 --> 00:09:24,650
connection tracking and the connection

00:09:22,130 --> 00:09:27,590
tracking is processing this is happening

00:09:24,650 --> 00:09:34,520
in the software so the we are processing

00:09:27,590 --> 00:09:38,770
if it's a scenes in arc and continue its

00:09:34,520 --> 00:09:41,090
then it's still done in the software and

00:09:38,770 --> 00:09:42,920
what we doing in the heart that's the

00:09:41,090 --> 00:09:44,060
concept to say as explained before so

00:09:42,920 --> 00:09:46,760
what we are doing in order to maintain

00:09:44,060 --> 00:09:48,710
that we have a table inside the hardware

00:09:46,760 --> 00:09:53,210
that's doing a match on the five top oh

00:09:48,710 --> 00:09:56,360
this is the green box down there so if

00:09:53,210 --> 00:09:58,280
the packet is I have a match in this

00:09:56,360 --> 00:09:59,600
file for this five topple it's means

00:09:58,280 --> 00:10:02,050
that we already process it and we

00:09:59,600 --> 00:10:05,210
understand what we need to do if not

00:10:02,050 --> 00:10:07,310
this packet is unknown for the hardware

00:10:05,210 --> 00:10:09,560
and it's doing a Miss and going to the

00:10:07,310 --> 00:10:13,310
software when this packet is going to

00:10:09,560 --> 00:10:15,950
the software he is going to the OB to be

00:10:13,310 --> 00:10:17,960
forwarded by the connection by the TC

00:10:15,950 --> 00:10:19,940
sorry that will send the packet to the

00:10:17,960 --> 00:10:24,770
connection tracking as I explained

00:10:19,940 --> 00:10:27,440
before and what then is happening that's

00:10:24,770 --> 00:10:30,080
when the packet inside the connection

00:10:27,440 --> 00:10:33,230
connection tracking is going to

00:10:30,080 --> 00:10:35,150
establish then is the time that we said

00:10:33,230 --> 00:10:38,750
okay we understand now does this

00:10:35,150 --> 00:10:41,510
connection is already open and we want

00:10:38,750 --> 00:10:43,940
all the packet that is following it from

00:10:41,510 --> 00:10:46,700
the same connection will be handled by

00:10:43,940 --> 00:10:50,180
the hardware so what we are doing is

00:10:46,700 --> 00:10:53,500
adding a rule to the connect to the this

00:10:50,180 --> 00:10:57,800
green table with the specific five tuple

00:10:53,500 --> 00:11:01,940
so all the packet that is following by

00:10:57,800 --> 00:11:04,520
this connection for following packets of

00:11:01,940 --> 00:11:08,300
this connection next time then that will

00:11:04,520 --> 00:11:10,910
arrive to their to the hardware as you

00:11:08,300 --> 00:11:12,760
mention mention before are going to the

00:11:10,910 --> 00:11:16,490
connections are going to the table and

00:11:12,760 --> 00:11:18,680
we may NP and doing a match on the green

00:11:16,490 --> 00:11:22,310
table and whoops we do have

00:11:18,680 --> 00:11:24,920
this five couple okay so we do they have

00:11:22,310 --> 00:11:28,640
this five topple and we know this is

00:11:24,920 --> 00:11:31,070
established in established state so we

00:11:28,640 --> 00:11:34,610
know that we can continue so we mark the

00:11:31,070 --> 00:11:37,370
packet as established and let the packet

00:11:34,610 --> 00:11:39,830
continue to go on the other table and

00:11:37,370 --> 00:11:41,720
then we actually we see another match

00:11:39,830 --> 00:11:44,029
it's this I'm talking that's happening

00:11:41,720 --> 00:11:47,690
inside the huddle and match on the

00:11:44,029 --> 00:11:50,660
connection state because we know this

00:11:47,690 --> 00:11:54,649
connection we already find it in the

00:11:50,660 --> 00:11:56,300
green box the match on the five topple

00:11:54,649 --> 00:11:59,209
we know what is the state of this

00:11:56,300 --> 00:12:01,790
connection we have some metadata on the

00:11:59,209 --> 00:12:05,720
pocket that's spaces so let's tell us

00:12:01,790 --> 00:12:08,089
what is the state of this connection so

00:12:05,720 --> 00:12:10,610
we can continue and parsing according to

00:12:08,089 --> 00:12:13,279
this metadata so if it's established we

00:12:10,610 --> 00:12:17,200
can continue and do the other rules

00:12:13,279 --> 00:12:26,650
according to the how it was configured

00:12:17,200 --> 00:12:31,910
by by the TC I hope that it was

00:12:26,650 --> 00:12:36,890
understood I have a quiz later so be

00:12:31,910 --> 00:12:40,580
ready of course

00:12:36,890 --> 00:12:43,360
so connection tracking is using today by

00:12:40,580 --> 00:12:45,440
net filter so we don't doing it

00:12:43,360 --> 00:12:47,750
everything well on a safe because we

00:12:45,440 --> 00:12:54,170
need you know to put our fingers inside

00:12:47,750 --> 00:12:58,420
so we're of course working with Pablo

00:12:54,170 --> 00:13:03,020
that's also doing the same thing for

00:12:58,420 --> 00:13:04,910
offloading connection tracking so we are

00:13:03,020 --> 00:13:09,200
working with him to find the right way

00:13:04,910 --> 00:13:12,170
to do that so there was a few guys from

00:13:09,200 --> 00:13:14,570
Mellanox that participate in the net

00:13:12,170 --> 00:13:18,470
filter that was a month ago in Berlin

00:13:14,570 --> 00:13:21,980
and work with him Oba on it as he also

00:13:18,470 --> 00:13:26,270
mentioned and we want to find the quick

00:13:21,980 --> 00:13:29,360
that the best way that we can convey can

00:13:26,270 --> 00:13:32,030
use this code of that Pablo is they

00:13:29,360 --> 00:13:33,920
already didn't RFC it

00:13:32,030 --> 00:13:36,050
and I think it took back a little bit

00:13:33,920 --> 00:13:38,960
before because they're not what there

00:13:36,050 --> 00:13:44,350
wasn't a hardware that can support it so

00:13:38,960 --> 00:13:48,190
of course we want to support it what we

00:13:44,350 --> 00:13:53,270
so we hope that's and we will have an

00:13:48,190 --> 00:13:56,990
appeal see something this month and to

00:13:53,270 --> 00:14:01,070
have a valid solution that's all by end

00:13:56,990 --> 00:14:06,770
of the year I know that it sounds I'm

00:14:01,070 --> 00:14:08,890
promising I hope that that's we will do

00:14:06,770 --> 00:14:08,890
it

00:14:19,320 --> 00:14:27,310
over it so what we want to so we as I

00:14:25,600 --> 00:14:32,590
mentioned we want to start with TCP

00:14:27,310 --> 00:14:35,890
because this is our more attraction and

00:14:32,590 --> 00:14:37,990
it's a need to be done but we also have

00:14:35,890 --> 00:14:40,810
customer that's asking for a UDP of

00:14:37,990 --> 00:14:44,550
course and even for ICMP how they offer

00:14:40,810 --> 00:14:49,930
for that so UDP is less challenging

00:14:44,550 --> 00:14:52,330
because this there are no sins in our

00:14:49,930 --> 00:14:55,960
but there are other things that also a

00:14:52,330 --> 00:14:58,660
problem you don't have fin for UDP so

00:14:55,960 --> 00:15:01,720
you need to figure out when to age this

00:14:58,660 --> 00:15:04,990
connection and in order to do that we

00:15:01,720 --> 00:15:08,560
need counters delay that's we do have

00:15:04,990 --> 00:15:10,600
counters already today with TC but that

00:15:08,560 --> 00:15:13,360
will be per connection that we need to

00:15:10,600 --> 00:15:18,070
have counters in order to maintain the

00:15:13,360 --> 00:15:19,780
edging and another thing that's

00:15:18,070 --> 00:15:22,510
currently we want to start with a very

00:15:19,780 --> 00:15:24,390
simple connection tracking that's as I

00:15:22,510 --> 00:15:26,620
mentioned in the first slide a

00:15:24,390 --> 00:15:30,460
connection tracking in the kernel doing

00:15:26,620 --> 00:15:33,130
two things he's going on the connection

00:15:30,460 --> 00:15:35,310
and identify the state of the connection

00:15:33,130 --> 00:15:39,490
is doing tracking on the connections and

00:15:35,310 --> 00:15:42,310
while the connection is valid he is

00:15:39,490 --> 00:15:44,560
validating that's all the packet for

00:15:42,310 --> 00:15:45,160
every packet that is going through this

00:15:44,560 --> 00:15:48,850
connection

00:15:45,160 --> 00:15:52,510
he is validating the TCP window so this

00:15:48,850 --> 00:15:56,080
is something that's our current hardware

00:15:52,510 --> 00:15:59,830
is not supporting and we want to add it

00:15:56,080 --> 00:16:03,550
so that's it will be done by the

00:15:59,830 --> 00:16:06,130
hardware but that's will code that we

00:16:03,550 --> 00:16:08,800
also will add of course after we finish

00:16:06,130 --> 00:16:11,190
the first version and that is doing it

00:16:08,800 --> 00:16:14,200
without the connection tracking because

00:16:11,190 --> 00:16:17,290
it's also need to maintain and for this

00:16:14,200 --> 00:16:19,300
information of the how you create this

00:16:17,290 --> 00:16:21,550
connection and send this information to

00:16:19,300 --> 00:16:24,130
the hardware that you can continue and

00:16:21,550 --> 00:16:26,440
understand the TCP window and doing the

00:16:24,130 --> 00:16:30,970
person the person for that and validated

00:16:26,440 --> 00:16:32,630
all this packet are validate according

00:16:30,970 --> 00:16:53,000
to the for anticipate windows

00:16:32,630 --> 00:16:55,880
progressing thank you questions yeah so

00:16:53,000 --> 00:16:58,400
what sort of connection clacking do you

00:16:55,880 --> 00:16:59,810
know I have in mind for UDP UDP is

00:16:58,400 --> 00:17:01,790
connectionless what connection tracking

00:16:59,810 --> 00:17:04,819
can you do I mean at most you can track

00:17:01,790 --> 00:17:06,350
ICMP errors or something what do you

00:17:04,819 --> 00:17:09,140
have in mind for a UDP connection

00:17:06,350 --> 00:17:11,540
tracking so for UDP connection tracking

00:17:09,140 --> 00:17:13,160
I want to do the same to go to the

00:17:11,540 --> 00:17:16,069
connection tracking model inside the

00:17:13,160 --> 00:17:19,069
kernel UDP is connectionless so what are

00:17:16,069 --> 00:17:20,930
you tracking so that's what is done

00:17:19,069 --> 00:17:23,510
today also you connection tracking

00:17:20,930 --> 00:17:27,079
already today the contract in the kernel

00:17:23,510 --> 00:17:31,760
in the net filter already today can

00:17:27,079 --> 00:17:34,460
maintain UDP so I want to obey to the

00:17:31,760 --> 00:17:36,770
same thing so the concept will be the

00:17:34,460 --> 00:17:39,530
same the first bucket if it's unknown

00:17:36,770 --> 00:17:41,450
it's going to the software and there is

00:17:39,530 --> 00:17:43,760
a software path that's really go to the

00:17:41,450 --> 00:17:45,650
connection tracking I don't want to

00:17:43,760 --> 00:17:48,230
invent anything here and you and also

00:17:45,650 --> 00:17:50,630
UDP could be fragmented so your first

00:17:48,230 --> 00:17:52,640
packet may not necessarily be the first

00:17:50,630 --> 00:17:55,820
packet it may be the second packet out

00:17:52,640 --> 00:17:59,980
of the first fragment a fragment yes so

00:17:55,820 --> 00:18:02,390
the ruling is okay so the way to enforce

00:17:59,980 --> 00:18:05,530
connection tracking actually when you

00:18:02,390 --> 00:18:08,270
have a firewall is that you allow a

00:18:05,530 --> 00:18:10,700
connection to be open from single

00:18:08,270 --> 00:18:14,030
direction it's mean that's a typical

00:18:10,700 --> 00:18:16,580
example will be okay if it's establish

00:18:14,030 --> 00:18:19,310
it's okay to go from each of the side

00:18:16,580 --> 00:18:22,490
but if it's a new connection it's only

00:18:19,310 --> 00:18:27,230
allowed like if you fire think about

00:18:22,490 --> 00:18:29,750
your home and firewall you only allow a

00:18:27,230 --> 00:18:32,570
new connection to be opened from inside

00:18:29,750 --> 00:18:35,120
the house from your home you don't allow

00:18:32,570 --> 00:18:37,220
that any connection that is coming from

00:18:35,120 --> 00:18:38,840
in its what will be an evil that is

00:18:37,220 --> 00:18:42,190
trying to open a connection from the

00:18:38,840 --> 00:18:45,440
outside inside to your to your home so

00:18:42,190 --> 00:18:48,860
this concept is for

00:18:45,440 --> 00:18:51,170
you usually done participe but also can

00:18:48,860 --> 00:18:52,760
be a way for UDP so this is also done

00:18:51,170 --> 00:18:55,970
for today for UDP if it's a new

00:18:52,760 --> 00:18:58,340
connection and the rules say it's only

00:18:55,970 --> 00:19:01,420
allowed to be opened from this direction

00:18:58,340 --> 00:19:03,410
on according to this specific

00:19:01,420 --> 00:19:06,500
consideration so that's what will

00:19:03,410 --> 00:19:08,660
reinforce yes just to extend the

00:19:06,500 --> 00:19:10,190
information that you're providing on the

00:19:08,660 --> 00:19:14,330
connection tracking system already comes

00:19:10,190 --> 00:19:18,530
with the fermentation support it is

00:19:14,330 --> 00:19:20,600
required right right up front before the

00:19:18,530 --> 00:19:23,000
packet is pass through the contract so

00:19:20,600 --> 00:19:24,980
that is already solved and and the other

00:19:23,000 --> 00:19:28,000
thing is about the EDPs connection less

00:19:24,980 --> 00:19:30,620
by but we're doing poor poor man

00:19:28,000 --> 00:19:34,550
tracking that says we consider the

00:19:30,620 --> 00:19:37,490
packets that we are seeing after 180

00:19:34,550 --> 00:19:39,380
seconds with no packet since that we can

00:19:37,490 --> 00:19:41,770
we go see that the flow has expired

00:19:39,380 --> 00:19:41,770
so it's

00:19:47,220 --> 00:19:53,910
for the connection tracking offloading

00:19:50,700 --> 00:19:56,520
so my question is could you talk a

00:19:53,910 --> 00:19:59,400
little bit about the hardware you are

00:19:56,520 --> 00:20:02,370
using for the offloading and is this

00:19:59,400 --> 00:20:07,080
connection tracking only supported by

00:20:02,370 --> 00:20:08,670
Mellanox hardware so I don't think that

00:20:07,080 --> 00:20:11,190
this connection tracking can be support

00:20:08,670 --> 00:20:13,770
only by Mellanox I think for to do that

00:20:11,190 --> 00:20:18,090
to implement this concept you just need

00:20:13,770 --> 00:20:22,800
to have a match a on a five tuple and to

00:20:18,090 --> 00:20:28,340
have a metadata so I I think that other

00:20:22,800 --> 00:20:31,290
vendor also can implement it thank you

00:20:28,340 --> 00:20:34,200
because there is still in this solution

00:20:31,290 --> 00:20:37,380
there is no TCP window validation and

00:20:34,200 --> 00:20:41,310
tricky thing that you need to implement

00:20:37,380 --> 00:20:44,400
in the harder but it just may have a met

00:20:41,310 --> 00:20:46,080
match on a five tuple and a metadata so

00:20:44,400 --> 00:20:48,210
I think most of the hard the modern

00:20:46,080 --> 00:20:51,510
hundred that's supporting that I didn't

00:20:48,210 --> 00:20:54,600
validate and of course all the other

00:20:51,510 --> 00:20:56,940
vendor that's one two participant modern

00:20:54,600 --> 00:20:59,610
welcome to to join the effort to see

00:20:56,940 --> 00:21:01,260
that's it's neatly they needs and you so

00:20:59,610 --> 00:21:03,210
if you need you know to do some

00:21:01,260 --> 00:21:07,170
modification to support other vendors of

00:21:03,210 --> 00:21:09,870
course we're not we are open source and

00:21:07,170 --> 00:21:19,920
we want everybody to work this is the

00:21:09,870 --> 00:21:22,080
better for the ecosystem thank you so if

00:21:19,920 --> 00:21:25,590
I understand correctly so we're saying

00:21:22,080 --> 00:21:27,210
that basically that connect the flow is

00:21:25,590 --> 00:21:29,610
offloaded after the connection is

00:21:27,210 --> 00:21:33,260
established so the syn synack and act

00:21:29,610 --> 00:21:35,820
packets go to the software after the

00:21:33,260 --> 00:21:39,110
three-way handshake then you are

00:21:35,820 --> 00:21:43,230
offloading the flow to the hardware

00:21:39,110 --> 00:21:45,240
right right okay so but the later

00:21:43,230 --> 00:21:49,340
packets you are not validating the later

00:21:45,240 --> 00:21:53,100
packets of the flow in hardware right so

00:21:49,340 --> 00:21:55,380
so what you mean not validating we are

00:21:53,100 --> 00:21:57,870
just verifying that there is a match in

00:21:55,380 --> 00:21:58,070
this five top oh okay and the flood and

00:21:57,870 --> 00:22:01,400
the

00:21:58,070 --> 00:22:03,560
flags of course is only acts it's no

00:22:01,400 --> 00:22:06,080
reset no it's if it's a restore Finn

00:22:03,560 --> 00:22:09,050
it's also going to the software and of

00:22:06,080 --> 00:22:11,210
course it's a another scene it's also

00:22:09,050 --> 00:22:13,040
need to go to the software so just

00:22:11,210 --> 00:22:18,500
validating that's the packet contain

00:22:13,040 --> 00:22:20,840
only act flags and then we are

00:22:18,500 --> 00:22:22,900
forwarding it if it's not we let the

00:22:20,840 --> 00:22:25,850
software handle it

00:22:22,900 --> 00:22:27,380
okay so basically you know for the true

00:22:25,850 --> 00:22:31,340
connection tracking we need to also

00:22:27,380 --> 00:22:34,610
support the window window whether the

00:22:31,340 --> 00:22:35,900
packet is between the TCP window that is

00:22:34,610 --> 00:22:38,330
missing and is there anything else

00:22:35,900 --> 00:22:40,970
missing that the connection tracking

00:22:38,330 --> 00:22:43,720
does in software or is the just the

00:22:40,970 --> 00:22:46,820
window management is the only part that

00:22:43,720 --> 00:22:49,790
needs to be done to support the full

00:22:46,820 --> 00:22:52,280
connection track in hardware so yes the

00:22:49,790 --> 00:22:57,040
TCP window is the only thing that is

00:22:52,280 --> 00:22:59,870
missing in order to have an exact tcp

00:22:57,040 --> 00:23:06,650
match for what is done today in the

00:22:59,870 --> 00:23:08,360
kernel but i s also pablo did is also

00:23:06,650 --> 00:23:11,030
doing an offload for connection tracking

00:23:08,360 --> 00:23:13,130
its software offload so it's currently

00:23:11,030 --> 00:23:16,820
it's not air and going to the hardware

00:23:13,130 --> 00:23:19,520
but also there he is bypassing all the

00:23:16,820 --> 00:23:22,970
window validation part and i think also

00:23:19,520 --> 00:23:26,660
in the software is so a he so that's its

00:23:22,970 --> 00:23:31,400
again i think to time or something that

00:23:26,660 --> 00:23:36,370
pablo around enough yes so basically so

00:23:31,400 --> 00:23:38,690
yeah basically what we have now is we

00:23:36,370 --> 00:23:40,250
could because the connection tracking

00:23:38,690 --> 00:23:42,950
system is quite complex and supports

00:23:40,250 --> 00:23:46,040
lots of features it was not a good fit

00:23:42,950 --> 00:23:49,160
to to map it exactly to what hard work

00:23:46,040 --> 00:23:50,870
can do so what we what we have

00:23:49,160 --> 00:23:52,490
introduced as a new infrastructure that

00:23:50,870 --> 00:23:56,480
we call it a flow table then filter

00:23:52,490 --> 00:24:00,080
infrastructure that basically it is

00:23:56,480 --> 00:24:04,070
hooking a hash table at the ingress hook

00:24:00,080 --> 00:24:06,950
and in software and then for each packet

00:24:04,070 --> 00:24:08,690
that kicks in we look at for for an

00:24:06,950 --> 00:24:10,970
entry in the table and if there is

00:24:08,690 --> 00:24:11,650
matching then we just know what to do

00:24:10,970 --> 00:24:13,660
with the packet

00:24:11,650 --> 00:24:18,400
so we just place it in the destination

00:24:13,660 --> 00:24:21,130
Nick via the neighbor layer so what it

00:24:18,400 --> 00:24:23,800
happens is that the idea is that and the

00:24:21,130 --> 00:24:27,220
patches that I posted and that Ronnie is

00:24:23,800 --> 00:24:30,790
talking about is basically just we are

00:24:27,220 --> 00:24:32,980
going to from a work you for an eternal

00:24:30,790 --> 00:24:34,809
threat we are going to spin over the the

00:24:32,980 --> 00:24:36,400
entries in this in the software flow

00:24:34,809 --> 00:24:38,290
table that can be a flow that can be

00:24:36,400 --> 00:24:41,170
that we can configure in part in

00:24:38,290 --> 00:24:43,900
hardware and then once the configuration

00:24:41,170 --> 00:24:46,059
is done the house is not going to see

00:24:43,900 --> 00:24:47,710
any packet so that's basically the idea

00:24:46,059 --> 00:24:51,640
so it's a very very simple

00:24:47,710 --> 00:24:54,040
representation just to map the basic

00:24:51,640 --> 00:24:56,080
feature so that the hardware the

00:24:54,040 --> 00:24:58,179
hardware that I had access can do and

00:24:56,080 --> 00:25:00,460
then we can move on and keep extending

00:24:58,179 --> 00:25:04,000
it to to incrementally support more

00:25:00,460 --> 00:25:06,490
features as Hardware shows more

00:25:04,000 --> 00:25:10,900
capabilities and we could do that in a

00:25:06,490 --> 00:25:13,990
way that that is transparent to using

00:25:10,900 --> 00:25:15,760
the user in the sense that depending on

00:25:13,990 --> 00:25:17,980
the hardware what the hardware can do

00:25:15,760 --> 00:25:19,660
from the control plane the user could

00:25:17,980 --> 00:25:21,460
configure things that won't want to be

00:25:19,660 --> 00:25:23,559
done and if the hardware doesn't support

00:25:21,460 --> 00:25:28,420
it we could say I don't support this so

00:25:23,559 --> 00:25:30,929
the user is is aware of what real what

00:25:28,420 --> 00:25:33,640
the hardware can do actually so that's

00:25:30,929 --> 00:25:36,309
basically the the idea behind the flow

00:25:33,640 --> 00:25:37,750
table infrastructure so it's it's kind

00:25:36,309 --> 00:25:42,429
of a simplification of the connection

00:25:37,750 --> 00:25:48,540
tracking when it is basically using it

00:25:42,429 --> 00:25:48,540
it requires it to to work

00:25:53,050 --> 00:25:59,960
Thanks yeah so so I refined astute

00:25:57,890 --> 00:26:02,060
publish idea but you're suggesting that

00:25:59,960 --> 00:26:04,790
you will discover the hacker can do and

00:26:02,060 --> 00:26:07,220
reduce the feature set focus with

00:26:04,790 --> 00:26:11,960
clearly in his case window tracking is

00:26:07,220 --> 00:26:16,130
missing yes but I'm not aware of how

00:26:11,960 --> 00:26:18,590
hard will say it may not be necessary

00:26:16,130 --> 00:26:19,970
CPUs you can implement it I'm not aware

00:26:18,590 --> 00:26:22,640
of for how do that is doing it today

00:26:19,970 --> 00:26:24,170
yeah it could be so in some cases you

00:26:22,640 --> 00:26:27,290
won't need it maybe in that case you go

00:26:24,170 --> 00:26:30,320
you send things to software if someone

00:26:27,290 --> 00:26:31,700
really wants the TCP window yeah but

00:26:30,320 --> 00:26:34,280
your suggestion is what that you'll

00:26:31,700 --> 00:26:36,200
query the hardware to see what it's

00:26:34,280 --> 00:26:40,460
capable of tracking and then decide

00:26:36,200 --> 00:26:44,030
which features say to download yes the

00:26:40,460 --> 00:26:45,680
user and I mean it's not all it window

00:26:44,030 --> 00:26:47,600
tracking but there are way more features

00:26:45,680 --> 00:26:50,480
that we do need software checks and

00:26:47,600 --> 00:26:52,880
validation for example I mean a number

00:26:50,480 --> 00:26:55,310
of things that are I've already

00:26:52,880 --> 00:26:57,620
supported that and and and that we

00:26:55,310 --> 00:26:59,330
currently kind of easily map because of

00:26:57,620 --> 00:27:02,150
the hardware that we have checked so as

00:26:59,330 --> 00:27:05,780
Hardware start supporting more features

00:27:02,150 --> 00:27:07,430
we can extend that model ok so I I had a

00:27:05,780 --> 00:27:10,460
slightly different question almost like

00:27:07,430 --> 00:27:12,620
what so Minos are asking why is UDP

00:27:10,460 --> 00:27:15,230
special or ICMP isn't that like 5-tuple

00:27:12,620 --> 00:27:19,370
should be sufficient to to describe what

00:27:15,230 --> 00:27:25,970
UDP is so yes it is so I think the

00:27:19,370 --> 00:27:29,090
difference between ok so the question

00:27:25,970 --> 00:27:30,620
was if you can't describe a five tuple

00:27:29,090 --> 00:27:38,480
you can probably only have four in that

00:27:30,620 --> 00:27:41,990
case yeah right right when you have

00:27:38,480 --> 00:27:45,800
fragmentation yes so I think fragment so

00:27:41,990 --> 00:27:48,050
for TCP it's easy because you're using

00:27:45,800 --> 00:27:50,450
don't fragment so you don't suppose to

00:27:48,050 --> 00:27:52,610
see any fragment and also in the real

00:27:50,450 --> 00:27:56,810
world we are talking about people that

00:27:52,610 --> 00:27:59,600
ask for performance usually even that is

00:27:56,810 --> 00:28:04,400
the UDP you don't do fragments fragments

00:27:59,600 --> 00:28:05,600
mean less performance and we we don't

00:28:04,400 --> 00:28:09,430
want to come

00:28:05,600 --> 00:28:11,870
the hardware to do an IP

00:28:09,430 --> 00:28:13,130
defragmentation because you need to

00:28:11,870 --> 00:28:15,140
store the path where it's very

00:28:13,130 --> 00:28:17,510
complicated and we don't believe that

00:28:15,140 --> 00:28:19,250
it's worth it I don't see many customers

00:28:17,510 --> 00:28:21,130
that's want to work in this environment

00:28:19,250 --> 00:28:24,290
of course we will have a solution

00:28:21,130 --> 00:28:27,290
software will handle it okay

00:28:24,290 --> 00:28:28,940
so the other question is I couldn't

00:28:27,290 --> 00:28:31,850
quite tell what your criteria for

00:28:28,940 --> 00:28:32,990
deciding which floor gets offset it

00:28:31,850 --> 00:28:36,320
sounds like you you

00:28:32,990 --> 00:28:40,160
you'll offload everything no so the

00:28:36,320 --> 00:28:42,380
criteria is TC TC decide which packet

00:28:40,160 --> 00:28:44,300
according to TC rules you decide when

00:28:42,380 --> 00:28:46,580
you want to go to connection tracking so

00:28:44,300 --> 00:28:49,970
you have the criteria can be any match

00:28:46,580 --> 00:28:53,560
on on TC that is we're supporting today

00:28:49,970 --> 00:28:56,870
so TC will decide based on static policy

00:28:53,560 --> 00:29:00,890
all right note that the hydro has only

00:28:56,870 --> 00:29:04,640
1024 entries and so there's a million

00:29:00,890 --> 00:29:07,460
flows so if you look on this slide you

00:29:04,640 --> 00:29:10,880
see there is a DOS what we are already

00:29:07,460 --> 00:29:13,400
supporting today with TC so we're doing

00:29:10,880 --> 00:29:15,560
TC uploads for tables no no you'll have

00:29:13,400 --> 00:29:18,680
a new action that's that's fine but

00:29:15,560 --> 00:29:20,450
there has to be a criteria if if a flow

00:29:18,680 --> 00:29:23,360
has only two packets would you offload

00:29:20,450 --> 00:29:26,000
that or if the flow okay you talk about

00:29:23,360 --> 00:29:27,230
that oh yes so or you only have ten

00:29:26,000 --> 00:29:28,610
entries so you're gonna offload a

00:29:27,230 --> 00:29:31,610
hundred thousand flows into the hardware

00:29:28,610 --> 00:29:35,180
you had we can only support 1024 let's

00:29:31,610 --> 00:29:36,830
say it's not but yeah yeah I figured

00:29:35,180 --> 00:29:39,830
you'd say that but there's some other

00:29:36,830 --> 00:29:42,230
highway that doesn't have right so first

00:29:39,830 --> 00:29:44,090
if it's a new connection all the syn

00:29:42,230 --> 00:29:46,730
synack is done in the software we

00:29:44,090 --> 00:29:48,770
already asked also public to to add a

00:29:46,730 --> 00:29:51,380
new kind of a new feature that's for

00:29:48,770 --> 00:29:52,880
short live connection you don't want to

00:29:51,380 --> 00:29:56,450
take it to the harder because if it's a

00:29:52,880 --> 00:29:58,880
very very small and I said small you

00:29:56,450 --> 00:30:03,260
know even can be a small gift that you'd

00:29:58,880 --> 00:30:06,800
taken with TCP for your web browser it's

00:30:03,260 --> 00:30:09,800
just few packets the overhead of the syn

00:30:06,800 --> 00:30:13,520
synack is already done the fin is also

00:30:09,800 --> 00:30:16,670
can be processed in the need to be

00:30:13,520 --> 00:30:19,050
process right so if it's few packets all

00:30:16,670 --> 00:30:21,900
the over to take it to the hardware

00:30:19,050 --> 00:30:24,780
we're not sure it's will benefit okay so

00:30:21,900 --> 00:30:27,180
only elephant so we want to only to to

00:30:24,780 --> 00:30:30,090
offload the connections that we see

00:30:27,180 --> 00:30:32,550
that's passed three four pack who sets

00:30:30,090 --> 00:30:35,070
that criteria so this criteria is done

00:30:32,550 --> 00:30:37,560
by the software as you remember the box

00:30:35,070 --> 00:30:40,050
is adding to the to the green table is

00:30:37,560 --> 00:30:44,430
the software so the software can decide

00:30:40,050 --> 00:30:46,020
if it's after the the syn syn ack is

00:30:44,430 --> 00:30:48,960
immediately going and put it in the

00:30:46,020 --> 00:30:51,060
software in the India howler or is

00:30:48,960 --> 00:30:54,300
delaying it to see that he is getting mu

00:30:51,060 --> 00:30:57,150
for a few more packets and like decide

00:30:54,300 --> 00:31:00,450
whether know if you see five packets or

00:30:57,150 --> 00:31:02,220
ten packets we don't want to go to a

00:31:00,450 --> 00:31:05,190
larger number because what is happening

00:31:02,220 --> 00:31:08,940
that is the TCP window is starting to

00:31:05,190 --> 00:31:12,330
open so the latest so the delay will be

00:31:08,940 --> 00:31:14,820
very short between packets and then you

00:31:12,330 --> 00:31:17,370
will have a reorder issue because you

00:31:14,820 --> 00:31:19,890
have a software path and once in and

00:31:17,370 --> 00:31:22,290
while you move it to the hardware there

00:31:19,890 --> 00:31:25,170
is a split inside the silicon and the

00:31:22,290 --> 00:31:29,700
slow path could be slower and you will

00:31:25,170 --> 00:31:32,400
have reorder in the TCP so we don't want

00:31:29,700 --> 00:31:35,430
to do you know to let customer use it's

00:31:32,400 --> 00:31:37,620
okay after you forward the 1k packets

00:31:35,430 --> 00:31:41,550
then go take it to the harder because

00:31:37,620 --> 00:31:45,090
then you will see a reorder and what a

00:31:41,550 --> 00:31:48,930
few packets this is a topical very very

00:31:45,090 --> 00:31:51,780
shortly short-lived connections small

00:31:48,930 --> 00:31:53,430
mice as they call and that's what you

00:31:51,780 --> 00:31:54,930
want you don't want to take to the

00:31:53,430 --> 00:31:56,430
hardware okay so there's a feature

00:31:54,930 --> 00:31:58,920
that's going to be added to contract

00:31:56,430 --> 00:32:04,200
that you're going to use or is yes

00:31:58,920 --> 00:32:07,050
okay so actually the connection tracking

00:32:04,200 --> 00:32:10,020
is a security feature right unless we do

00:32:07,050 --> 00:32:12,990
window tracking I don't think see a

00:32:10,020 --> 00:32:16,410
value in just offloading into Hardware

00:32:12,990 --> 00:32:19,290
after three after a few packets it's a

00:32:16,410 --> 00:32:21,740
it's a fast path so you have to you have

00:32:19,290 --> 00:32:24,480
to look at this as just of just a way to

00:32:21,740 --> 00:32:25,110
to get more performance it's just a fast

00:32:24,480 --> 00:32:26,610
path oh sorry

00:32:25,110 --> 00:32:28,080
you have to trade off between your

00:32:26,610 --> 00:32:29,910
requirements if you really want to do

00:32:28,080 --> 00:32:31,620
full validation then you have to follow

00:32:29,910 --> 00:32:32,880
the software path obviously because the

00:32:31,620 --> 00:32:33,960
solver that is more flex

00:32:32,880 --> 00:32:37,320
and you could do everything from there

00:32:33,960 --> 00:32:38,790
but in case you need to improve

00:32:37,320 --> 00:32:40,950
performance then you can do a trade of

00:32:38,790 --> 00:32:43,680
it you can get 90% of the packets going

00:32:40,950 --> 00:32:45,540
through the silicon with just performing

00:32:43,680 --> 00:32:50,520
the initial validation from the software

00:32:45,540 --> 00:32:52,230
so then you get a trade off so the good

00:32:50,520 --> 00:32:53,940
thing about this I mean my opinion is

00:32:52,230 --> 00:32:56,340
that you get all the flexibility that

00:32:53,940 --> 00:32:57,960
you have in software for the initial

00:32:56,340 --> 00:33:00,060
classification of those packets because

00:32:57,960 --> 00:33:02,340
the policy is going to apply to only

00:33:00,060 --> 00:33:05,190
very little packets that are coming

00:33:02,340 --> 00:33:08,220
initially in that flow so and then and

00:33:05,190 --> 00:33:11,400
then once once after once you match your

00:33:08,220 --> 00:33:13,860
criteria you decide to push that flow

00:33:11,400 --> 00:33:17,070
into it into the hardware and you can do

00:33:13,860 --> 00:33:18,480
that whenever you want so I mean it's

00:33:17,070 --> 00:33:19,770
not it's not necessarily that you have

00:33:18,480 --> 00:33:21,810
to do once that connection is

00:33:19,770 --> 00:33:24,840
established but you could you could even

00:33:21,810 --> 00:33:27,090
postpone that and then you until you

00:33:24,840 --> 00:33:30,440
basically play tune in with that

00:33:27,090 --> 00:33:30,440
trade-off and you design what you need

00:33:33,050 --> 00:33:39,720
so remember that you're talking about

00:33:36,900 --> 00:33:41,580
the last leg that is not done today in

00:33:39,720 --> 00:33:44,220
the hardware but according to the

00:33:41,580 --> 00:33:48,210
software implementation it will be done

00:33:44,220 --> 00:33:50,430
and can be done so just a way on the way

00:33:48,210 --> 00:33:53,040
now we're starting with not doing the

00:33:50,430 --> 00:33:55,710
window validation because there is no

00:33:53,040 --> 00:33:57,900
hundred that is supporting that what we

00:33:55,710 --> 00:34:01,680
will have it in the future but also

00:33:57,900 --> 00:34:03,720
today when we talk about validation we

00:34:01,680 --> 00:34:06,180
will validate that's the check somewhere

00:34:03,720 --> 00:34:07,920
okay the tcp the IP checksum okay the

00:34:06,180 --> 00:34:09,590
TCP check sum okay because that's every

00:34:07,920 --> 00:34:12,600
outages are all ready to do doing today

00:34:09,590 --> 00:34:15,690
we validate that we are working with

00:34:12,600 --> 00:34:18,899
familiar with this five couple we are

00:34:15,690 --> 00:34:22,320
validating the TCP flags that is not a

00:34:18,899 --> 00:34:24,510
sin or a new scene or fee nor reset so

00:34:22,320 --> 00:34:27,899
we validated that is only in acts

00:34:24,510 --> 00:34:30,899
packets so that's a validation that can

00:34:27,899 --> 00:34:33,060
easily be done today so we're doing a

00:34:30,899 --> 00:34:35,879
lot of validation what is not what is

00:34:33,060 --> 00:34:39,000
missing right now it's to do a window

00:34:35,879 --> 00:34:42,379
validation and we we see many customers

00:34:39,000 --> 00:34:45,419
that's already today implementing it

00:34:42,379 --> 00:34:47,159
kind of faith connection tracking and

00:34:45,419 --> 00:34:49,409
bypass the window

00:34:47,159 --> 00:34:52,020
because of the performance it's a

00:34:49,409 --> 00:34:54,960
performance seat and as Pablo did the

00:34:52,020 --> 00:34:56,460
testing it on on a server you can double

00:34:54,960 --> 00:35:01,289
the performance if you just remove the

00:34:56,460 --> 00:35:03,500
original validation so it's it's a

00:35:01,289 --> 00:35:07,020
question what the customer willing to

00:35:03,500 --> 00:35:10,349
pay in order to get performance for the

00:35:07,020 --> 00:35:13,109
current version and of course it's

00:35:10,349 --> 00:35:16,490
always in hardware you know it's tech

00:35:13,109 --> 00:35:19,200
more time a little bit to add the things

00:35:16,490 --> 00:35:22,140
so we will have it in the next hour

00:35:19,200 --> 00:35:24,960
how do ok we're going to pull bubbly

00:35:22,140 --> 00:35:33,059
have another comment you know maker yeah

00:35:24,960 --> 00:35:34,650
we'll pull Ronnie to the penalty box hey

00:35:33,059 --> 00:35:36,599
you go and harass him on the corner

00:35:34,650 --> 00:35:39,920
while we prepare for the next talk thank

00:35:36,599 --> 00:35:39,920
you thank you

00:35:41,040 --> 00:35:44,609
[Music]

00:35:41,530 --> 00:35:44,609

YouTube URL: https://www.youtube.com/watch?v=_EZ8-AcTJ4w


