Title: Netdev 0x13 - Is Reimplementation of network stack a good idea or not
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 2 - Track 1 + 2 - Mar 21 2019
Description: 
	Hajime Tazaki is a man on a mission.
We have seen him before talking about the Linux Kernel Library (LKL) whose intention was to take the whole of the linux kernel network stack and make it available in user space. He has since been staring at other possible candidates for user space network stacks.

Hajime tries to come up with some metrics on how to measure "maturity" of network stack
implementations: Using network protocol conformance tests of various IETF standards (RFCs) across multiple userspace network stack implementations.

In this talk, he shares the preliminary results, findings of buggy implementations, and possible testing framework that is going to be used going forward

https://netdevconf.org/0x13/session.html?talk-reimp-stack
Captions: 
	00:00:00,030 --> 00:00:08,610
so how everybody my name is Hajime and

00:00:06,150 --> 00:00:12,990
I'm going to talk about the methods that

00:00:08,610 --> 00:00:16,199
in general not about some particular

00:00:12,990 --> 00:00:21,060
feature of the network but more broader

00:00:16,199 --> 00:00:24,090
sense so this talk and this work has

00:00:21,060 --> 00:00:28,080
been started based on my personal

00:00:24,090 --> 00:00:30,390
trician about why there are so many

00:00:28,080 --> 00:00:32,369
Network stack implementation available

00:00:30,390 --> 00:00:36,500
and the why people are trying to

00:00:32,369 --> 00:00:39,840
implement network start again energy and

00:00:36,500 --> 00:00:42,450
the network stack in this talk can be

00:00:39,840 --> 00:00:44,820
defined as a collection of the

00:00:42,450 --> 00:00:49,739
implementation of the network protocols

00:00:44,820 --> 00:00:52,370
as well as the network related program

00:00:49,739 --> 00:00:54,930
software like a network interface cable

00:00:52,370 --> 00:01:01,410
abscess management stuff like a packet

00:00:54,930 --> 00:01:03,120
scheduling and the example of the

00:01:01,410 --> 00:01:07,320
availability of the network stack

00:01:03,120 --> 00:01:09,270
implementation as I shown as I mentioned

00:01:07,320 --> 00:01:14,659
before there are so many network stack

00:01:09,270 --> 00:01:18,450
implementation available and there are

00:01:14,659 --> 00:01:21,570
newly implemented network stuff which is

00:01:18,450 --> 00:01:23,790
used for the pure user space network

00:01:21,570 --> 00:01:26,220
stack purposes like if you have

00:01:23,790 --> 00:01:29,220
application but if you don't want to use

00:01:26,220 --> 00:01:32,970
the network stack in the host operating

00:01:29,220 --> 00:01:34,860
system you can do it inside a user space

00:01:32,970 --> 00:01:36,630
application by attaching the networks

00:01:34,860 --> 00:01:41,189
have implemented implementation inside

00:01:36,630 --> 00:01:46,049
the application like in this as shown in

00:01:41,189 --> 00:01:48,000
this side empty CP or sister is kind of

00:01:46,049 --> 00:01:50,790
example that can be categorized under

00:01:48,000 --> 00:01:54,710
this use cases and this user space

00:01:50,790 --> 00:01:57,450
native stock is usually used with the

00:01:54,710 --> 00:02:00,630
networks that bypass technology or color

00:01:57,450 --> 00:02:04,890
bypass technology like DP DK or net

00:02:00,630 --> 00:02:08,350
month and the others are also thinking

00:02:04,890 --> 00:02:11,970
about to adapt to this idea into

00:02:08,350 --> 00:02:15,370
at the container runtime like a google

00:02:11,970 --> 00:02:19,810
distant team to this the divisor which

00:02:15,370 --> 00:02:23,080
is based on the go round based gimmicks

00:02:19,810 --> 00:02:25,480
emulator with them the same and they

00:02:23,080 --> 00:02:27,120
also have their own networks that

00:02:25,480 --> 00:02:31,270
implementation will be turning the goal

00:02:27,120 --> 00:02:37,540
and it is used inside the container on

00:02:31,270 --> 00:02:38,860
time and the other example is used as my

00:02:37,540 --> 00:02:40,710
network stock implementation in the

00:02:38,860 --> 00:02:44,290
unique honor

00:02:40,710 --> 00:02:48,040
Lincoln is kind of the single address

00:02:44,290 --> 00:02:50,230
space single Process Model operating

00:02:48,040 --> 00:02:53,200
system which is useful for the guest

00:02:50,230 --> 00:02:57,670
operating system in the cloud of it and

00:02:53,200 --> 00:03:01,030
cloud environment and there are so many

00:02:57,670 --> 00:03:03,540
academic papers available implementing

00:03:01,030 --> 00:03:06,580
the discontinued Nakano technology and

00:03:03,540 --> 00:03:09,100
the lwi piece which is one of the

00:03:06,580 --> 00:03:12,540
networks and implementation is kind of

00:03:09,100 --> 00:03:16,870
popular software used by this kind of

00:03:12,540 --> 00:03:18,760
project and other projects using their

00:03:16,870 --> 00:03:23,320
own network stack implementation is

00:03:18,760 --> 00:03:25,570
always spring they are originally

00:03:23,320 --> 00:03:28,590
polished FreeBSD Network stack

00:03:25,570 --> 00:03:31,660
implementation to the UNIX operating

00:03:28,590 --> 00:03:35,140
system and they are trying to maintain

00:03:31,660 --> 00:03:37,450
the latest previously features as well

00:03:35,140 --> 00:03:41,220
as the providing the kampachi ABI

00:03:37,450 --> 00:03:44,050
comparability to the application side

00:03:41,220 --> 00:03:47,800
and a red hot recently announced that

00:03:44,050 --> 00:03:50,470
the new project which is called ukm I

00:03:47,800 --> 00:03:55,240
guess unique arnelle Linux on cylinder

00:03:50,470 --> 00:03:57,310
and I don't see any source code from the

00:03:55,240 --> 00:03:59,680
this project but their announcement

00:03:57,310 --> 00:04:02,440
mentioned that the data trying to port

00:03:59,680 --> 00:04:04,420
the Linux code as a form of the in

00:04:02,440 --> 00:04:09,430
kernel way to provide a single address

00:04:04,420 --> 00:04:11,860
space operating system so I try to

00:04:09,430 --> 00:04:15,940
summarize those kind of project in the

00:04:11,860 --> 00:04:19,479
single table and they have a different

00:04:15,940 --> 00:04:20,400
very different feature set of the each

00:04:19,479 --> 00:04:23,340
net

00:04:20,400 --> 00:04:26,210
and some of them only implemented the

00:04:23,340 --> 00:04:30,120
particular protocols of the network's

00:04:26,210 --> 00:04:32,249
implementation some of them were ported

00:04:30,120 --> 00:04:34,020
from the existing operating system that

00:04:32,249 --> 00:04:36,449
could also be based on what we based as

00:04:34,020 --> 00:04:39,270
I mentioned before and the lamp corner

00:04:36,449 --> 00:04:42,979
is based on the net VSD counted in order

00:04:39,270 --> 00:04:42,979
to utilize the user space network

00:04:45,349 --> 00:04:50,249
so there are different implementation

00:04:48,900 --> 00:04:53,520
because they have a different motivation

00:04:50,249 --> 00:04:55,740
for the layer software so some of them

00:04:53,520 --> 00:04:59,129
were there he wanted to have a highly

00:04:55,740 --> 00:05:01,740
optimized network stack in terms of the

00:04:59,129 --> 00:05:04,289
performance wise or some of them already

00:05:01,740 --> 00:05:08,069
cared about the small footprint of the

00:05:04,289 --> 00:05:11,699
resource usages but they are not some

00:05:08,069 --> 00:05:13,349
always the feature-rich then some

00:05:11,699 --> 00:05:15,599
implementation doesn't have a particular

00:05:13,349 --> 00:05:18,719
feature of the network protocols wisdom

00:05:15,599 --> 00:05:24,750
from and I was wondering why did all

00:05:18,719 --> 00:05:29,009
this what happened I was trying to

00:05:24,750 --> 00:05:31,740
understand the whole picture of this

00:05:29,009 --> 00:05:34,050
kind of situation and they try to

00:05:31,740 --> 00:05:37,919
categorize the how to implement such a

00:05:34,050 --> 00:05:43,069
network of networks track and some of

00:05:37,919 --> 00:05:46,169
them are implemented from scratch

00:05:43,069 --> 00:05:55,169
without any difference that any

00:05:46,169 --> 00:06:03,750
different default cause code bases in

00:05:55,169 --> 00:06:06,569
this ppm TCP and the mirror choice based

00:06:03,750 --> 00:06:12,419
on the whole camel implemented a network

00:06:06,569 --> 00:06:15,409
start from scratch with this and this in

00:06:12,419 --> 00:06:18,779
these categories they have their own

00:06:15,409 --> 00:06:23,310
motivation but it usually missing plugs

00:06:18,779 --> 00:06:26,819
some of the important feature I'm not

00:06:23,310 --> 00:06:30,469
sure but it's not going to be it's not

00:06:26,819 --> 00:06:30,469
going to be implemented in the future

00:06:31,230 --> 00:06:38,790
and some of them are implemented as by

00:06:35,490 --> 00:06:42,870
porting resistant code bases as I

00:06:38,790 --> 00:06:45,840
mentioned we fund so the protein is also

00:06:42,870 --> 00:06:49,020
effective way to do something

00:06:45,840 --> 00:06:52,740
differently with the same software code

00:06:49,020 --> 00:06:56,100
bases but it is also hard to follow up

00:06:52,740 --> 00:06:58,830
or catch up the latest fixes or latest

00:06:56,100 --> 00:07:01,950
update of the original source code if

00:06:58,830 --> 00:07:04,380
both called growing different and

00:07:01,950 --> 00:07:06,660
separately the synchronization between

00:07:04,380 --> 00:07:10,730
the original code and the new newly

00:07:06,660 --> 00:07:13,970
implemented one is difficult to achieve

00:07:10,730 --> 00:07:17,520
so in order to eliminate such a potent

00:07:13,970 --> 00:07:19,490
the headache of the porting effort the

00:07:17,520 --> 00:07:23,750
any kind of technology has been

00:07:19,490 --> 00:07:26,490
introduced by it was originally with the

00:07:23,750 --> 00:07:28,740
terminology was originally used by the

00:07:26,490 --> 00:07:33,390
metal base big line of the lamp funded

00:07:28,740 --> 00:07:36,120
project and the Linux kernel library

00:07:33,390 --> 00:07:39,660
which is which I have been working heavy

00:07:36,120 --> 00:07:42,540
on recently and use the model unit is

00:07:39,660 --> 00:07:46,050
also following this idea the idea of the

00:07:42,540 --> 00:07:49,350
any color is good additional layer into

00:07:46,050 --> 00:07:51,840
the monolithic kernel and try to provide

00:07:49,350 --> 00:07:54,510
a different environment execution

00:07:51,840 --> 00:07:56,190
environment in not only in the kernel

00:07:54,510 --> 00:07:58,710
space execution

00:07:56,190 --> 00:08:01,260
typical municipal economy but also to

00:07:58,710 --> 00:08:09,510
provide the user specific execution for

00:08:01,260 --> 00:08:11,580
example so the question here that I want

00:08:09,510 --> 00:08:15,230
to answer is the implementation of the

00:08:11,580 --> 00:08:18,900
network stack a good idea or not and

00:08:15,230 --> 00:08:21,420
from now on from the following slides

00:08:18,900 --> 00:08:24,890
and the death of the my talk and try to

00:08:21,420 --> 00:08:27,840
answer this question has no by

00:08:24,890 --> 00:08:32,540
conducting at the measurement study with

00:08:27,840 --> 00:08:35,520
the experiment and kind of experiment so

00:08:32,540 --> 00:08:38,610
what what I am doing as the experiment

00:08:35,520 --> 00:08:43,409
is trying to measure the feature

00:08:38,610 --> 00:08:46,649
richness or mature honest but

00:08:43,409 --> 00:08:49,680
by measuring the conformance level of

00:08:46,649 --> 00:08:50,990
the network stack implementation by the

00:08:49,680 --> 00:08:54,540
Tesla tools

00:08:50,990 --> 00:08:58,529
why I'm doing this measurement is I want

00:08:54,540 --> 00:09:00,480
to have a metric to measure the maturity

00:08:58,529 --> 00:09:02,670
of the network's not implementation

00:09:00,480 --> 00:09:05,149
because there are so many numbers of the

00:09:02,670 --> 00:09:09,509
different networks are implementations

00:09:05,149 --> 00:09:12,959
and how I am doing this measurement is

00:09:09,509 --> 00:09:19,980
using the external tools which is called

00:09:12,959 --> 00:09:21,449
Ixia amble the fit test suite so exci

00:09:19,980 --> 00:09:25,949
amble is the kind of proprietary

00:09:21,449 --> 00:09:28,560
software which is trying to validate the

00:09:25,949 --> 00:09:31,920
conformance of the network structure

00:09:28,560 --> 00:09:35,040
NATO protocol implementation to the ITF

00:09:31,920 --> 00:09:38,339
standards or other seeds so it is

00:09:35,040 --> 00:09:40,500
usually used for not for this kinds of

00:09:38,339 --> 00:09:44,670
particular answering the particular

00:09:40,500 --> 00:09:47,310
questions of the person but try to

00:09:44,670 --> 00:09:50,699
improve the product implementation

00:09:47,310 --> 00:09:53,370
before releasing the software in the in

00:09:50,699 --> 00:09:55,459
the market so the customer for this

00:09:53,370 --> 00:09:59,370
software is usually the router in the

00:09:55,459 --> 00:10:06,029
network stack vendors rating system

00:09:59,370 --> 00:10:09,560
vendors so how it works how the XMB

00:10:06,029 --> 00:10:15,500
works in general so this is the basic

00:10:09,560 --> 00:10:15,500
example of basic setup of the intestate

00:10:15,529 --> 00:10:26,069
so so the test suite which is called

00:10:20,990 --> 00:10:28,139
unveil is starting at the starting by

00:10:26,069 --> 00:10:31,399
emulating the topology for the

00:10:28,139 --> 00:10:35,610
particular test so in this example this

00:10:31,399 --> 00:10:39,000
so left left boxes is the tester node

00:10:35,610 --> 00:10:42,089
and the light boxes is the device and

00:10:39,000 --> 00:10:45,000
networks up under the test and in this

00:10:42,089 --> 00:10:47,939
simple example this just connect a

00:10:45,000 --> 00:10:52,410
single network interface till the

00:10:47,939 --> 00:10:55,160
network's device under test and after

00:10:52,410 --> 00:10:58,610
setting up this emanated

00:10:55,160 --> 00:11:02,720
they tested note triggered the some

00:10:58,610 --> 00:11:05,390
packet to the network stack and I tried

00:11:02,720 --> 00:11:07,870
to wait the expected response from the

00:11:05,390 --> 00:11:10,760
network's that's fine

00:11:07,870 --> 00:11:14,660
so it's for example if you if the left

00:11:10,760 --> 00:11:18,910
side not transmit the up request packet

00:11:14,660 --> 00:11:21,230
and they expect some expected proper

00:11:18,910 --> 00:11:24,940
applicants pocket from the network stack

00:11:21,230 --> 00:11:32,660
the tester not just another Deportes

00:11:24,940 --> 00:11:38,110
discussants and succeeded so for the

00:11:32,660 --> 00:11:43,160
test that I'm going to present later we

00:11:38,110 --> 00:11:45,410
use the the two Linux boxes so for the

00:11:43,160 --> 00:11:47,660
tests are not we use the slightly not

00:11:45,410 --> 00:11:50,600
society but the older version dominicana

00:11:47,660 --> 00:11:53,780
which is the requirement for this test a

00:11:50,600 --> 00:11:57,410
software and the device under test for

00:11:53,780 --> 00:12:00,230
the device under test we use the full

00:11:57,410 --> 00:12:04,400
415 color for the host operating system

00:12:00,230 --> 00:12:07,070
and the most of the tests using the you

00:12:04,400 --> 00:12:10,910
displays network so a network stack for

00:12:07,070 --> 00:12:17,480
the most of the test is not based on

00:12:10,910 --> 00:12:19,940
this 415 cannon and we tested the seven

00:12:17,480 --> 00:12:23,060
defined test suite visiting here from

00:12:19,940 --> 00:12:25,550
the up to the ipv6 neighbor discovery

00:12:23,060 --> 00:12:27,980
protocol we are also trying to do a

00:12:25,550 --> 00:12:30,560
transport protocol conformance test but

00:12:27,980 --> 00:12:35,480
we didn't have much time to express I

00:12:30,560 --> 00:12:38,030
explained here in this talk so for the

00:12:35,480 --> 00:12:41,840
device under the test we also use the

00:12:38,030 --> 00:12:44,690
same software as it defined

00:12:41,840 --> 00:12:46,960
implementation for this for the network

00:12:44,690 --> 00:12:46,960
stack

00:12:48,780 --> 00:12:57,000
and then the conducting by conducting

00:12:52,560 --> 00:13:06,530
this measurement we have us we have a

00:12:57,000 --> 00:13:09,620
bunch of the result cryptic to

00:13:06,530 --> 00:13:16,190
understand each of the tests generate

00:13:09,620 --> 00:13:19,650
such a failure in consensus

00:13:16,190 --> 00:13:26,700
inconclusively report from the each of

00:13:19,650 --> 00:13:29,640
the disks and this is the summary of the

00:13:26,700 --> 00:13:35,070
order that I have gotten from the

00:13:29,640 --> 00:13:42,180
measurement study and the how you can be

00:13:35,070 --> 00:13:44,670
dismembers so the each of the number of

00:13:42,180 --> 00:13:46,580
the past succeeded test divided the

00:13:44,670 --> 00:13:50,580
number of the total number of the test

00:13:46,580 --> 00:13:57,360
and some of the red colored desert shows

00:13:50,580 --> 00:14:02,430
the some particular information like for

00:13:57,360 --> 00:14:04,560
for example the sister isn't because

00:14:02,430 --> 00:14:07,260
sister only support a single network

00:14:04,560 --> 00:14:10,380
interface card to be configured some of

00:14:07,260 --> 00:14:12,480
the test is not conducted and that's why

00:14:10,380 --> 00:14:15,450
because that's why the number of the

00:14:12,480 --> 00:14:20,850
total test for example IP before it's

00:14:15,450 --> 00:14:24,840
lower than the others and for the

00:14:20,850 --> 00:14:27,000
Lampkin case they have this kind of

00:14:24,840 --> 00:14:30,480
support to configure the much per

00:14:27,000 --> 00:14:34,500
interface but during the test and the

00:14:30,480 --> 00:14:37,320
land kernel crashes during the test so

00:14:34,500 --> 00:14:39,780
it we cannot continue to the other risk

00:14:37,320 --> 00:14:41,490
of the test so that's why a number of

00:14:39,780 --> 00:14:46,920
the total number of the test is lower

00:14:41,490 --> 00:14:51,480
than users and as you can see the most

00:14:46,920 --> 00:14:53,880
of the some of the implementation like a

00:14:51,480 --> 00:14:57,029
sister from sis attempt TCP

00:14:53,880 --> 00:15:00,870
which doesn't which double don't have a

00:14:57,029 --> 00:15:04,380
ipv6 implementations all those tests are

00:15:00,870 --> 00:15:06,120
not conducted but the D bizarre recently

00:15:04,380 --> 00:15:08,459
announced that they were going they are

00:15:06,120 --> 00:15:11,220
going to support ipv6 in the future so

00:15:08,459 --> 00:15:11,970
it's gonna be different if I conduct

00:15:11,220 --> 00:15:15,990
again

00:15:11,970 --> 00:15:18,600
this test and the Linux kernel library

00:15:15,990 --> 00:15:22,079
and the Linux kernel should be

00:15:18,600 --> 00:15:26,130
equivalent from the this kind of test

00:15:22,079 --> 00:15:28,980
wizard but we can see some differences

00:15:26,130 --> 00:15:34,730
between them which I am not sure what is

00:15:28,980 --> 00:15:39,810
the root cause of its problem and the

00:15:34,730 --> 00:15:44,850
era WIP one of the full scratch based

00:15:39,810 --> 00:15:47,610
implementation shows the cupboard all

00:15:44,850 --> 00:15:50,360
the protocol support from this seven

00:15:47,610 --> 00:15:55,769
different test suite but it showed some

00:15:50,360 --> 00:16:00,569
some lower score compared to the Linux

00:15:55,769 --> 00:16:02,910
implementation for example but the

00:16:00,569 --> 00:16:05,360
number of the number that I show in this

00:16:02,910 --> 00:16:10,230
table has contains some of the

00:16:05,360 --> 00:16:12,449
misleading information like some of the

00:16:10,230 --> 00:16:16,259
test requires the additional

00:16:12,449 --> 00:16:20,779
configuration to the network stack for

00:16:16,259 --> 00:16:20,779
example someone that s required the

00:16:21,050 --> 00:16:27,089
modification to the internal state like

00:16:23,310 --> 00:16:31,079
creating the up entry before the test or

00:16:27,089 --> 00:16:36,180
Center and sending the IPC ICMP requests

00:16:31,079 --> 00:16:38,069
from the network stack side but most of

00:16:36,180 --> 00:16:41,550
them doesn't have such a fit such a

00:16:38,069 --> 00:16:43,110
dynamic configuration from a network

00:16:41,550 --> 00:16:44,329
stack implementation for example the

00:16:43,110 --> 00:16:48,449
most of the user space network

00:16:44,329 --> 00:16:52,410
segmentation only has only have a static

00:16:48,449 --> 00:16:55,380
configuration file which can be which

00:16:52,410 --> 00:17:00,019
can be did during the boots boots lab

00:16:55,380 --> 00:17:00,019
processes so after running such

00:17:02,080 --> 00:17:10,060
state so in that case in such acts test

00:17:05,620 --> 00:17:14,440
doesn't have those kind of tests will be

00:17:10,060 --> 00:17:19,420
failed and some of the error or failure

00:17:14,440 --> 00:17:21,790
is added to the ambiguous ambiguity of

00:17:19,420 --> 00:17:25,810
the space creation so if you are

00:17:21,790 --> 00:17:30,070
familiar with the idea of RFC it you can

00:17:25,810 --> 00:17:34,240
often see the main statement on the

00:17:30,070 --> 00:17:37,510
specification which can be interpreted

00:17:34,240 --> 00:17:38,890
as a with implementation had the option

00:17:37,510 --> 00:17:43,030
to behave

00:17:38,890 --> 00:17:46,300
blah blah blah or other way so it's such

00:17:43,030 --> 00:17:51,610
an obvious tip makes that as a test

00:17:46,300 --> 00:17:56,350
failure so I'm going to show the some of

00:17:51,610 --> 00:17:59,080
the example that I found the I found

00:17:56,350 --> 00:18:03,040
other area of during this test so this

00:17:59,080 --> 00:18:07,540
is an example of the AB test with the

00:18:03,040 --> 00:18:10,900
simple topologies and some of that this

00:18:07,540 --> 00:18:14,980
test tried to send out requests akkad

00:18:10,900 --> 00:18:18,670
from the designer and the expected

00:18:14,980 --> 00:18:21,450
response of this test is not to respond

00:18:18,670 --> 00:18:24,010
the applicants pocket from this

00:18:21,450 --> 00:18:28,900
applicants because the hardware typeset

00:18:24,010 --> 00:18:31,000
is unknown information so the

00:18:28,900 --> 00:18:32,740
specification says it should not respond

00:18:31,000 --> 00:18:34,930
out response pocket but there's some of

00:18:32,740 --> 00:18:37,660
the implementation right a sister and

00:18:34,930 --> 00:18:43,240
the net basically the sponsorship out

00:18:37,660 --> 00:18:45,040
requests the other failure that I also

00:18:43,240 --> 00:18:50,800
found in the Linux kernel and the

00:18:45,040 --> 00:18:56,650
National Library is the icmpv6 messages

00:18:50,800 --> 00:19:01,210
and so in this case the Linux boxes is

00:18:56,650 --> 00:19:04,750
running as a router and the host one

00:19:01,210 --> 00:19:07,840
node in the top most one not in the top

00:19:04,750 --> 00:19:12,970
one tried to send the ICMP requests to

00:19:07,840 --> 00:19:14,950
the host to but this Linux was cannot

00:19:12,970 --> 00:19:17,860
resolve the next hop the other

00:19:14,950 --> 00:19:21,460
so the next hope so in this case the

00:19:17,860 --> 00:19:23,050
standard said that the doubt are not

00:19:21,460 --> 00:19:27,510
based upon the destination unreachable

00:19:23,050 --> 00:19:32,890
messages is there a reason called the

00:19:27,510 --> 00:19:38,410
pre address and address unreachable but

00:19:32,890 --> 00:19:40,510
the Linux not respond with zero this can

00:19:38,410 --> 00:19:43,330
be kind of corner case that the the

00:19:40,510 --> 00:19:44,710
standard this is not confirmed to the

00:19:43,330 --> 00:19:49,950
standard in the current implementation

00:19:44,710 --> 00:19:49,950
not 4:15 corner

00:19:54,960 --> 00:20:01,540
other failure that I found in the most

00:19:58,000 --> 00:20:05,350
of the implementation is the the

00:20:01,540 --> 00:20:09,370
behavior with the ICMP address mask

00:20:05,350 --> 00:20:12,940
request so no implementation or respond

00:20:09,370 --> 00:20:15,100
this pocket and I guess nobody because

00:20:12,940 --> 00:20:22,000
nobody uses this feature nobody is

00:20:15,100 --> 00:20:25,540
worried about this failure so this is

00:20:22,000 --> 00:20:27,460
and this is the kind of summary from the

00:20:25,540 --> 00:20:30,340
observation of this measurement study

00:20:27,460 --> 00:20:32,310
and the most of the implementation the

00:20:30,340 --> 00:20:37,570
half of the implementation doesn't have

00:20:32,310 --> 00:20:41,400
ipv6 implementation because nobody not

00:20:37,570 --> 00:20:41,400
so many people require such a feature

00:20:42,060 --> 00:21:07,330
some of the implementation has doesn't

00:20:45,070 --> 00:21:08,920
have a ipv4 some of the only support a

00:21:07,330 --> 00:21:14,260
single interface configuration

00:21:08,920 --> 00:21:17,220
configuration so to highlight what I

00:21:14,260 --> 00:21:21,340
found from the Linux implementation the

00:21:17,220 --> 00:21:23,559
measurement study so most of the tests

00:21:21,340 --> 00:21:25,570
are succeeded with the Linux

00:21:23,559 --> 00:21:29,919
mutation but some of the test my faith

00:21:25,570 --> 00:21:31,899
failed as I mentioned in short so those

00:21:29,919 --> 00:21:40,570
are the list this is a list of the

00:21:31,899 --> 00:21:46,799
failed tests mentioned with the

00:21:40,570 --> 00:21:53,830
different code number of the SNP p6 and

00:21:46,799 --> 00:21:58,090
top two favorite tests the fragmented

00:21:53,830 --> 00:22:02,019
pocket at the router node but I found

00:21:58,090 --> 00:22:16,899
that if I uninstalled

00:22:02,019 --> 00:22:22,149
the net filter filter modules should be

00:22:16,899 --> 00:22:24,669
demanded for the future so that's almost

00:22:22,149 --> 00:22:27,039
it so my message from this measurement

00:22:24,669 --> 00:22:33,309
study is the maturing the network stack

00:22:27,039 --> 00:22:35,289
is usually hard but using the full

00:22:33,309 --> 00:22:44,619
scratch implementation tempting because

00:22:35,289 --> 00:22:48,460
the you have a fully free option free

00:22:44,619 --> 00:22:51,669
option to to do what you want to do

00:22:48,460 --> 00:22:54,549
without any restriction to the existing

00:22:51,669 --> 00:22:57,899
implementation but using long live

00:22:54,549 --> 00:23:03,909
network stuff is also a good option to

00:22:57,899 --> 00:23:12,809
utilize the maturity network stack so

00:23:03,909 --> 00:23:12,809
thank you for your time any questions

00:23:13,889 --> 00:23:24,399
you your spreadsheet we're showing all

00:23:19,809 --> 00:23:26,379
the different implementations do some of

00:23:24,399 --> 00:23:31,149
this yeah that one no next

00:23:26,379 --> 00:23:36,330
I guess Linux when you say 1991 what

00:23:31,149 --> 00:23:36,330
just the 1991 kernel version or just

00:23:39,990 --> 00:23:54,250
okay so this hasn't changed since 1991

00:23:43,769 --> 00:23:56,259
what do you mean which one of these

00:23:54,250 --> 00:23:57,970
don't matter right it doesn't matter

00:23:56,259 --> 00:24:00,340
even if you implement it from scratch is

00:23:57,970 --> 00:24:02,980
there a specific test that doesn't

00:24:00,340 --> 00:24:05,710
matter if it market like I think you

00:24:02,980 --> 00:24:09,220
showed one at these like very important

00:24:05,710 --> 00:24:11,350
test cases you must pass these to be I

00:24:09,220 --> 00:24:15,190
think you showed one which is a corner

00:24:11,350 --> 00:24:18,490
case or something a feature that nobody

00:24:15,190 --> 00:24:21,369
uses anyways but but anvil seems to want

00:24:18,490 --> 00:24:28,090
to test it because it's in the spec how

00:24:21,369 --> 00:24:30,549
many of these are like in that area yeah

00:24:28,090 --> 00:24:32,860
that's the one that caught my eye that

00:24:30,549 --> 00:24:35,970
nobody actually even uses this so this

00:24:32,860 --> 00:24:38,440
case or the implementation failed

00:24:35,970 --> 00:24:44,230
because it's an obscure feature that

00:24:38,440 --> 00:24:46,679
nobody has probably implemented yes it's

00:24:44,230 --> 00:25:04,629
actually optimized for the Cisco IOS

00:24:46,679 --> 00:25:11,710
implementation so your message is don't

00:25:04,629 --> 00:25:13,720
try to implement this it's been but you

00:25:11,710 --> 00:25:14,740
know you can reinvent the wheel but

00:25:13,720 --> 00:25:19,320
maybe you'll have a little hole in

00:25:14,740 --> 00:25:19,320
everything okay thanks

00:25:21,450 --> 00:25:26,679
so first of all I love the title of the

00:25:24,700 --> 00:25:30,999
talk very provocative so that's pretty

00:25:26,679 --> 00:25:34,389
cool one thought though so when we look

00:25:30,999 --> 00:25:35,369
at all these open source user space

00:25:34,389 --> 00:25:39,460
stacks

00:25:35,369 --> 00:25:41,409
one measurement of the quality that you

00:25:39,460 --> 00:25:42,790
might want to think about is what is the

00:25:41,409 --> 00:25:46,450
development community

00:25:42,790 --> 00:25:48,010
- so I see all of these and I've heard

00:25:46,450 --> 00:25:50,770
of them mm-hmm

00:25:48,010 --> 00:25:52,270
but I don't know like if I wanted to do

00:25:50,770 --> 00:25:55,690
a user's face stack I wouldn't know

00:25:52,270 --> 00:25:57,340
where to begin because what is one of

00:25:55,690 --> 00:25:58,240
the metrics is is this thing actually

00:25:57,340 --> 00:26:00,610
support it

00:25:58,240 --> 00:26:02,890
do we have thousands of developers like

00:26:00,610 --> 00:26:07,570
we do in Linux so I think that it's

00:26:02,890 --> 00:26:08,740
great information that just one thing

00:26:07,570 --> 00:26:11,050
that might you might want to think about

00:26:08,740 --> 00:26:15,280
adding is as a measurement of the

00:26:11,050 --> 00:26:17,950
quality of these Oboro the user space

00:26:15,280 --> 00:26:22,990
only in the tax documents maybe we buy

00:26:17,950 --> 00:26:26,170
the have the biggest community you know

00:26:22,990 --> 00:26:30,700
or any of these considered like default

00:26:26,170 --> 00:26:39,000
4d PDK I know some of them like an empty

00:26:30,700 --> 00:26:39,000
CP how they communicate

00:26:46,490 --> 00:26:51,900

YouTube URL: https://www.youtube.com/watch?v=68Oq6XBNYFI


