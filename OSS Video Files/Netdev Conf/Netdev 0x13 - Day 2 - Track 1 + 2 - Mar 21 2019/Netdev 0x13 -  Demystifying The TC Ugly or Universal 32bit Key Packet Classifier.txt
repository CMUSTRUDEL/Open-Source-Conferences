Title: Netdev 0x13 -  Demystifying The TC Ugly or Universal 32bit Key Packet Classifier
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 2 - Track 1 + 2 - Mar 21 2019
Description: 
	Jamal Hadi Salim digs deep into the ugly^WBeatiful 32 bit TC classifier.
U32 is the mother of all classifiers in the linux kernel. It is the only native classifier that can be taught by a user policy "how to" classify based on user traffic heuristics. U32 is a low level classifier operating on packet-offset-length-value. Sometimes this could be confusing for the faint-hearted.

In this talk, Jamal digs deep into u32-land to show basic principles and expose flexibility
for customization. He illustrates customization use cases for a small(hundreds of rules)
and a medium sized (10s of thousands of rules) LAN access control and provides
performance numbers.

More info:
https://www.netdevconf.org/0x13/news.html?talk-tc-u-classifier
Captions: 
	00:00:00,030 --> 00:00:07,890
okay yeah so there's a lot of fake news

00:00:04,200 --> 00:00:10,849
on you 32 on the internet that's why I'm

00:00:07,890 --> 00:00:10,849
doing this talk okay

00:00:11,540 --> 00:00:17,010
no more fake news so the you 32

00:00:15,120 --> 00:00:20,400
classifier has been around since about

00:00:17,010 --> 00:00:22,260
kernel 2.1 this once in a while does

00:00:20,400 --> 00:00:26,189
some maintenance bug fixes but it's

00:00:22,260 --> 00:00:28,740
pretty stable it once in a while some

00:00:26,189 --> 00:00:32,250
guy who wants to make it perfect shows

00:00:28,740 --> 00:00:34,410
up like Alvaro the other day making

00:00:32,250 --> 00:00:36,450
fixes make sure if you have this

00:00:34,410 --> 00:00:37,260
condition matching with that something

00:00:36,450 --> 00:00:39,230
is gonna break

00:00:37,260 --> 00:00:42,239
but in general it's been pretty stable

00:00:39,230 --> 00:00:45,390
okay the problem this is not to talk

00:00:42,239 --> 00:00:47,969
about TC although I'm just going to

00:00:45,390 --> 00:00:54,329
mention that the classifier action block

00:00:47,969 --> 00:00:57,120
is where you 32 fits in close it though

00:00:54,329 --> 00:00:58,649
and you have a net device which connects

00:00:57,120 --> 00:01:00,660
which has a cue disk attached to it

00:00:58,649 --> 00:01:03,120
either on the ingress or egress which

00:01:00,660 --> 00:01:04,049
then has a classifier action block if

00:01:03,120 --> 00:01:07,380
you want to do some really cool things

00:01:04,049 --> 00:01:09,510
then you know you could also have

00:01:07,380 --> 00:01:12,150
multiple devices connecting to are using

00:01:09,510 --> 00:01:16,680
a connection action look as a matter of

00:01:12,150 --> 00:01:19,530
fact and if I take this and look peek

00:01:16,680 --> 00:01:23,189
inside you a connection action block has

00:01:19,530 --> 00:01:26,100
multiple chains with the diff with

00:01:23,189 --> 00:01:28,200
default there's only one and you can

00:01:26,100 --> 00:01:29,909
have different kinds of classifiers so

00:01:28,200 --> 00:01:36,689
you can have a firewall fw mark

00:01:29,909 --> 00:01:39,270
classifier you can have BPF but one of

00:01:36,689 --> 00:01:41,939
these so I'm gonna be looking at one

00:01:39,270 --> 00:01:46,799
kind of classifier that you 32 that TC

00:01:41,939 --> 00:01:48,479
supports called you 32 and I have the

00:01:46,799 --> 00:01:51,180
answer for you Tom this is the

00:01:48,479 --> 00:01:52,649
classifier you're looking for I hope I

00:01:51,180 --> 00:01:55,020
hope to be able to convince you by the

00:01:52,649 --> 00:01:57,060
end of this it's been around forever its

00:01:55,020 --> 00:01:58,740
stable you can go back to come to let

00:01:57,060 --> 00:02:03,299
one run your scripts and you'll walk the

00:01:58,740 --> 00:02:06,770
same way okay so what is what does you

00:02:03,299 --> 00:02:11,790
32 do it's a very low-level classifier

00:02:06,770 --> 00:02:13,170
so it confuses people sometimes that's

00:02:11,790 --> 00:02:18,840
the other reason I'm here other than the

00:02:13,170 --> 00:02:20,160
fake news so a you specify it knows you

00:02:18,840 --> 00:02:22,920
have to know how your packet format

00:02:20,160 --> 00:02:28,470
looks like specifies an offset into that

00:02:22,920 --> 00:02:32,970
packet to to which you specify a mask a

00:02:28,470 --> 00:02:35,550
32-bit mask you grab the result of the

00:02:32,970 --> 00:02:39,390
ending of those two fields and you match

00:02:35,550 --> 00:02:41,819
it against the value so that's all you

00:02:39,390 --> 00:02:44,730
32 years and how you end up composing

00:02:41,819 --> 00:02:48,150
your policy based on just this tool just

00:02:44,730 --> 00:02:52,200
this simple row that's where the

00:02:48,150 --> 00:02:54,750
richness is it supports both exact exact

00:02:52,200 --> 00:02:58,860
matches which means I can just say match

00:02:54,750 --> 00:03:02,730
10 1000 100 it supports prefix which is

00:02:58,860 --> 00:03:04,830
the routing guys use a slash 32 24 16

00:03:02,730 --> 00:03:09,569
and also supports tannery

00:03:04,830 --> 00:03:15,180
I can just say match 0 the mask is 0 X F

00:03:09,569 --> 00:03:16,349
0 F 0 F 0 if I wanted so vary the tick

00:03:15,180 --> 00:03:19,650
and people will understand what that

00:03:16,349 --> 00:03:21,540
means and with those rules with those

00:03:19,650 --> 00:03:23,489
three possibilities of matching which is

00:03:21,540 --> 00:03:25,590
actually p4 seems to be specifying

00:03:23,489 --> 00:03:30,870
tannery exact and prefix matches as well

00:03:25,590 --> 00:03:35,819
i can specify a policy what officer to

00:03:30,870 --> 00:03:40,140
use and what kind of mask to use and the

00:03:35,819 --> 00:03:42,420
result to compare against so because it

00:03:40,140 --> 00:03:45,030
uses these basic rules you can actually

00:03:42,420 --> 00:03:47,390
teach it how to classify for you and i'm

00:03:45,030 --> 00:03:51,780
gonna try and explain those details I

00:03:47,390 --> 00:03:54,900
should also emphasize that script

00:03:51,780 --> 00:03:56,430
ability is very important in that you

00:03:54,900 --> 00:03:59,150
don't have to go and change the kernel

00:03:56,430 --> 00:04:02,700
yes because you've discovered you've got

00:03:59,150 --> 00:04:06,090
genÃ¨ve head or that you want to support

00:04:02,700 --> 00:04:07,799
IFE or they knew i affair telemetry or

00:04:06,090 --> 00:04:10,290
whatever you don't have to right change

00:04:07,799 --> 00:04:12,959
the kernel you just have to change you

00:04:10,290 --> 00:04:17,340
have to teach you 32 where your offsets

00:04:12,959 --> 00:04:19,799
are what they should look like and in

00:04:17,340 --> 00:04:22,259
fact as I'll show later it has ways to

00:04:19,799 --> 00:04:24,750
compute as well how how to jump around

00:04:22,259 --> 00:04:25,990
the packets in order to satisfy your

00:04:24,750 --> 00:04:27,280
matches

00:04:25,990 --> 00:04:28,750
right so that's what I mean by

00:04:27,280 --> 00:04:35,169
scriptable it's the only scriptable

00:04:28,750 --> 00:04:37,449
colonel classified here's here's the the

00:04:35,169 --> 00:04:40,330
basics of you 32 and I'm going to a

00:04:37,449 --> 00:04:43,810
cassette I'll show both altar with an IP

00:04:40,330 --> 00:04:48,069
packet so here's an IP packet if you

00:04:43,810 --> 00:04:50,110
want an exact match of 1000 100 you

00:04:48,069 --> 00:04:54,310
specify it in a very low level

00:04:50,110 --> 00:04:59,229
definition say I want you to march 32

00:04:54,310 --> 00:05:01,030
bits with this value and that mask at

00:04:59,229 --> 00:05:03,639
offset number 12 which is right there

00:05:01,030 --> 00:05:06,940
so you take this source back so once you

00:05:03,639 --> 00:05:10,210
stole this into the kernel when the

00:05:06,940 --> 00:05:15,250
package shows up this rule will be taken

00:05:10,210 --> 00:05:17,530
and if it match it is either matches or

00:05:15,250 --> 00:05:19,539
it doesn't right so that's what an exact

00:05:17,530 --> 00:05:23,199
prefix looks like you see the ffs there

00:05:19,539 --> 00:05:29,740
if I want to specify a subnet or

00:05:23,199 --> 00:05:31,210
slash 100 I mean 10/20 for this is how

00:05:29,740 --> 00:05:33,430
I'll specify see them I just changed the

00:05:31,210 --> 00:05:35,310
mask and if I want to specify the

00:05:33,430 --> 00:05:38,889
protocol field which is that offset 8

00:05:35,310 --> 00:05:42,190
right here that protocol field you know

00:05:38,889 --> 00:05:44,800
I I would write out the mask of that

00:05:42,190 --> 00:05:47,289
sort and I want to match it to protocol

00:05:44,800 --> 00:05:48,490
number one that's the nibble there is

00:05:47,289 --> 00:05:51,909
enable or yeah

00:05:48,490 --> 00:05:53,919
and I simply it's got matching ICMP

00:05:51,909 --> 00:05:55,210
right so tannery matches these things

00:05:53,919 --> 00:06:06,280
that are in the middle I can specify

00:05:55,210 --> 00:06:09,750
different masks right yeah mark 10 hex

00:06:06,280 --> 00:06:09,750
that's a hex right 100

00:06:13,790 --> 00:06:20,300
but but is it I could also I think what

00:06:16,910 --> 00:06:22,100
I did is I entered it as 1000 100 / 24

00:06:20,300 --> 00:06:24,290
using the more human-friendly way of

00:06:22,100 --> 00:06:27,470
describing this and in the kernel showed

00:06:24,290 --> 00:06:35,600
up like that right somebody saying

00:06:27,470 --> 00:06:42,920
something 64 sorry what 16 yes you're

00:06:35,600 --> 00:06:45,440
right 16.0 zero 100 okay so now how does

00:06:42,920 --> 00:06:48,080
it look like in the kernel I so I'm

00:06:45,440 --> 00:06:51,290
gonna show you a bit of an animation

00:06:48,080 --> 00:06:53,510
here this is what we enter right when I

00:06:51,290 --> 00:06:56,630
do a dump of the ruling from the kernel

00:06:53,510 --> 00:06:59,210
this is what I see right now - a lot of

00:06:56,630 --> 00:07:03,290
people this looks very mysterious or

00:06:59,210 --> 00:07:05,570
u-32 very bizarre-looking output right

00:07:03,290 --> 00:07:10,100
but I'm gonna try and impress you with

00:07:05,570 --> 00:07:12,020
some animation here so here this

00:07:10,100 --> 00:07:16,880
actually has a lot of meaning and I'm

00:07:12,020 --> 00:07:18,980
hoping that I can describe those details

00:07:16,880 --> 00:07:21,620
to you so they chain as I had shown

00:07:18,980 --> 00:07:24,290
earlier this is a just a TC chain all

00:07:21,620 --> 00:07:26,900
the chains when you specify any filter

00:07:24,290 --> 00:07:30,530
if you had said flour there to say that

00:07:26,900 --> 00:07:33,920
this is protocol IP because that's what

00:07:30,530 --> 00:07:36,140
you specified a priority of one the

00:07:33,920 --> 00:07:40,490
classifier type is you have 32 and it's

00:07:36,140 --> 00:07:48,280
on chain 0 okay so that maps to the

00:07:40,490 --> 00:07:51,860
chain in this diagram the FH 800 colon

00:07:48,280 --> 00:07:56,420
specifies there a table when I install a

00:07:51,860 --> 00:07:59,300
rule I the kernel automatically installs

00:07:56,420 --> 00:08:02,720
a root table a hash table that's you 32

00:07:59,300 --> 00:08:08,390
works on hash tables and by default it's

00:08:02,720 --> 00:08:10,430
it has the ID of X 800 X 800 so so

00:08:08,390 --> 00:08:13,310
that's what that means 800 and then you

00:08:10,430 --> 00:08:15,650
notice a colon there and the other thing

00:08:13,310 --> 00:08:18,020
it shows here is it created a hash table

00:08:15,650 --> 00:08:18,740
of only one bucket see the one bucket

00:08:18,020 --> 00:08:24,710
bucket 0

00:08:18,740 --> 00:08:26,660
it's called divisor of 1 so to even

00:08:24,710 --> 00:08:27,650
expand further in the next slide so here

00:08:26,660 --> 00:08:29,630
it talks about the way

00:08:27,650 --> 00:08:32,029
the chain is this describes what table

00:08:29,630 --> 00:08:35,779
it is and this here this is going to now

00:08:32,029 --> 00:08:38,839
describe more details right there you go

00:08:35,779 --> 00:08:41,150
so there's three things issues so

00:08:38,839 --> 00:08:44,330
there's a hash table there's a bucket ID

00:08:41,150 --> 00:08:47,510
and there's the match ID or the key node

00:08:44,330 --> 00:08:49,210
ID so these numbers here 800 maps to

00:08:47,510 --> 00:08:52,250
that one there

00:08:49,210 --> 00:08:56,779
the missing 0 there there's a 0 here

00:08:52,250 --> 00:08:59,060
which matches 2 to the back at 0 and the

00:08:56,779 --> 00:09:06,410
800 hex matches to the 800 hex which is

00:08:59,060 --> 00:09:12,110
the ID so that's what I have so it has

00:09:06,410 --> 00:09:15,560
hash buckets in hash tables which each

00:09:12,110 --> 00:09:17,360
hash bucket will have a key note so in

00:09:15,560 --> 00:09:20,150
fact what I'm going to demonstrate later

00:09:17,360 --> 00:09:21,860
on is you can keep adding I got to be

00:09:20,150 --> 00:09:26,060
fair to the guys on this side you got to

00:09:21,860 --> 00:09:27,529
keep adding rules and you can specify

00:09:26,060 --> 00:09:35,660
exactly what they should be installed

00:09:27,529 --> 00:09:37,550
right so here is if you just keep adding

00:09:35,660 --> 00:09:39,140
blindly you know the kernel will just

00:09:37,550 --> 00:09:41,570
add them to the root table there's only

00:09:39,140 --> 00:09:43,790
one root table is the default table so

00:09:41,570 --> 00:09:44,930
it's gonna keep adding them right so you

00:09:43,790 --> 00:09:47,240
can see it becomes a linked list

00:09:44,930 --> 00:09:48,970
essentially it's not very fast so

00:09:47,240 --> 00:09:51,290
packets are going to be looked up and

00:09:48,970 --> 00:09:53,480
we'll walk the link list until we find

00:09:51,290 --> 00:09:58,430
out much and we execute the action

00:09:53,480 --> 00:10:02,779
intended right not very efficient

00:09:58,430 --> 00:10:04,490
but you can add extra tables right if I

00:10:02,779 --> 00:10:06,680
add if I change my priority to a

00:10:04,490 --> 00:10:07,300
different one so the priorities go this

00:10:06,680 --> 00:10:11,150
way

00:10:07,300 --> 00:10:12,980
priority n n plus M I can have different

00:10:11,150 --> 00:10:17,029
if the type protocols so this is

00:10:12,980 --> 00:10:18,650
protocol X let's say IP and now I have

00:10:17,029 --> 00:10:22,940
another route table added for that

00:10:18,650 --> 00:10:25,339
priority so there are multiple tables

00:10:22,940 --> 00:10:30,110
that can be added and this tends to map

00:10:25,339 --> 00:10:32,720
very well with hard way okay so in fact

00:10:30,110 --> 00:10:34,070
you can do genius things like this if

00:10:32,720 --> 00:10:35,120
you know what you're doing and I'm

00:10:34,070 --> 00:10:37,820
hoping people know what they're doing

00:10:35,120 --> 00:10:39,980
after this right you can actually have a

00:10:37,820 --> 00:10:41,570
series of high of tables that can be

00:10:39,980 --> 00:10:43,940
interconnected to each other

00:10:41,570 --> 00:10:46,220
from port to port all right you can put

00:10:43,940 --> 00:10:48,199
this on the ingress put some of it on

00:10:46,220 --> 00:10:50,389
the egress and just keep redirecting and

00:10:48,199 --> 00:10:54,110
sending things and packets just keep

00:10:50,389 --> 00:10:55,820
walking keep getting classified and in

00:10:54,110 --> 00:10:57,560
as a matter of fact you can train it

00:10:55,820 --> 00:10:59,959
based on your traffic patterns this is

00:10:57,560 --> 00:11:01,579
very important right so not only can you

00:10:59,959 --> 00:11:04,279
train it based on what new Protocol's

00:11:01,579 --> 00:11:06,709
you have but also based on what traffic

00:11:04,279 --> 00:11:08,690
patterns you have on your network and

00:11:06,709 --> 00:11:10,970
optimize the hell out of it just for

00:11:08,690 --> 00:11:14,089
your network okay you don't have to

00:11:10,970 --> 00:11:18,519
write generic algorithms that everybody

00:11:14,089 --> 00:11:22,069
uses and submit a paper to SiC on right

00:11:18,519 --> 00:11:26,149
so I'm gonna show an example of this

00:11:22,069 --> 00:11:29,980
right here is an example of something we

00:11:26,149 --> 00:11:34,279
use in our land right we've a slash 24

00:11:29,980 --> 00:11:36,350
we build cascading of tables it's good

00:11:34,279 --> 00:11:39,350
it's got an access control list where

00:11:36,350 --> 00:11:43,160
any IP addresses were recognized will

00:11:39,350 --> 00:11:45,800
eventually fall through from the top

00:11:43,160 --> 00:11:49,819
layer tables and end up a default rule

00:11:45,800 --> 00:11:53,569
that just drops it and logs right and I

00:11:49,819 --> 00:11:55,699
have some animation for this okay here

00:11:53,569 --> 00:11:57,920
you go so this is how you add a table so

00:11:55,699 --> 00:12:03,889
I just I'm just adding a table for with

00:11:57,920 --> 00:12:05,990
256 buckets okay that's the that's what

00:12:03,889 --> 00:12:10,779
shows up so I've called this table I've

00:12:05,990 --> 00:12:15,639
given it an ID table ID 1 okay then

00:12:10,779 --> 00:12:15,639
yeah the handle is how I specify the ID

00:12:15,910 --> 00:12:23,540
the divisor is how I specify the buckets

00:12:20,589 --> 00:12:28,430
now I'm going to add a rule to that

00:12:23,540 --> 00:12:32,949
which says too much at offset 12 again

00:12:28,430 --> 00:12:35,750
the source IP and this looks funny but

00:12:32,949 --> 00:12:38,569
don't worry about what that means but

00:12:35,750 --> 00:12:40,069
I'm gonna add a rule okay and what's

00:12:38,569 --> 00:12:41,839
important is I'm going to specify

00:12:40,069 --> 00:12:46,730
exactly what this rule should be added

00:12:41,839 --> 00:12:48,760
right you see the the address I'm gonna

00:12:46,730 --> 00:12:51,189
specify the address in the hash table

00:12:48,760 --> 00:12:54,269
where it should be added right there

00:12:51,189 --> 00:12:56,999
hash table 1 1

00:12:54,269 --> 00:12:59,399
that means go to address number table

00:12:56,999 --> 00:13:01,559
one bucket one and I wanted to add that

00:12:59,399 --> 00:13:04,079
thing there and I could have specified

00:13:01,559 --> 00:13:06,389
what the ID is but I let the colonel

00:13:04,079 --> 00:13:10,999
give me one so it gave me eight hex 800

00:13:06,389 --> 00:13:10,999
it likes hex 800 for some reason okay

00:13:12,470 --> 00:13:20,040
okay I said that already

00:13:15,589 --> 00:13:22,139
okay next I am going now to so this is

00:13:20,040 --> 00:13:27,300
the leaf table right if I if I go back

00:13:22,139 --> 00:13:30,059
to my previous diagram that is I've just

00:13:27,300 --> 00:13:32,220
created that table then right now the

00:13:30,059 --> 00:13:34,769
packets come this way but right now this

00:13:32,220 --> 00:13:36,629
leaf no leaf table is not connected so

00:13:34,769 --> 00:13:38,339
I'm gonna create a root table and then

00:13:36,629 --> 00:13:44,629
link them you see how I said it link

00:13:38,339 --> 00:13:44,629
there okay so how do I do that

00:13:46,189 --> 00:13:53,459
here you go I that's the rule right TC

00:13:50,730 --> 00:13:57,059
field to add I tell it exactly where to

00:13:53,459 --> 00:13:59,429
go I ask you that on a hash table 800 X

00:13:57,059 --> 00:14:02,549
800 it's unfortunately this you have to

00:13:59,429 --> 00:14:05,100
if you specify this assumed as X bucket

00:14:02,549 --> 00:14:10,290
0 you know remember the dot there the

00:14:05,100 --> 00:14:13,129
two columns I want it to match on 16

00:14:10,290 --> 00:14:18,629
this time we got it right here

00:14:13,129 --> 00:14:25,019
1600 at slash okay this was intended to

00:14:18,629 --> 00:14:27,240
be FF all the way to here and how would

00:14:25,019 --> 00:14:29,730
you select so so first to much on the

00:14:27,240 --> 00:14:38,160
16-0 sir this is correct 1600 slash

00:14:29,730 --> 00:14:40,319
eight okay and then you select this is a

00:14:38,160 --> 00:14:42,869
keyword called hash key that selects the

00:14:40,319 --> 00:14:44,639
bucket for the next table okay so I'm

00:14:42,869 --> 00:14:48,329
going to use the last octet to select a

00:14:44,639 --> 00:14:51,420
bucket so an address like a B is 1600

00:14:48,329 --> 00:14:57,889
one is going to end up on bucket one did

00:14:51,420 --> 00:14:57,889
that make sense or is it yes

00:15:02,360 --> 00:15:06,170
okay the experimental one is correct

00:15:04,860 --> 00:15:08,580
this one here is correct

00:15:06,170 --> 00:15:10,490
you guys have to just say good things

00:15:08,580 --> 00:15:12,840
okay

00:15:10,490 --> 00:15:17,640
yeah that I think that one is correct

00:15:12,840 --> 00:15:24,540
right okay so it's that I have a BC 1/32

00:15:17,640 --> 00:15:27,690
254 so alright moving forward so

00:15:24,540 --> 00:15:30,660
basically I can keep creating this these

00:15:27,690 --> 00:15:39,630
hash keys to specify what the bucket IDs

00:15:30,660 --> 00:15:43,170
is so what I've demonstrated so far is I

00:15:39,630 --> 00:15:44,790
can go to any offset of any packet don't

00:15:43,170 --> 00:15:46,410
have to know anything about it but at

00:15:44,790 --> 00:15:49,650
this point I've still been assuming that

00:15:46,410 --> 00:15:51,900
these packets are not of variable size

00:15:49,650 --> 00:15:55,760
right what if you have a TLV or you have

00:15:51,900 --> 00:15:59,690
a TCP option or an IP option right so

00:15:55,760 --> 00:16:02,570
that week my friends we can do as well

00:15:59,690 --> 00:16:09,470
right

00:16:02,570 --> 00:16:13,380
so you you can specify a way for you 32

00:16:09,470 --> 00:16:16,830
to compute on your behalf

00:16:13,380 --> 00:16:22,530
where the next table so first you say

00:16:16,830 --> 00:16:26,820
I'm gonna I'm gonna use the IP source IP

00:16:22,530 --> 00:16:29,970
if it matches please look at the header

00:16:26,820 --> 00:16:33,420
length I want you to compute to take

00:16:29,970 --> 00:16:36,350
that as a competition for the next

00:16:33,420 --> 00:16:41,640
header to to to that I'm gonna add rules

00:16:36,350 --> 00:16:46,110
passed at this point so I say I just

00:16:41,640 --> 00:16:47,940
wanted it to match a TCP port right but

00:16:46,110 --> 00:16:49,800
you know there may be IP options there

00:16:47,940 --> 00:16:51,720
so I want to compute the fact that there

00:16:49,800 --> 00:16:54,560
may be optional fields that follow the

00:16:51,720 --> 00:16:59,220
main header all right so the keyword is

00:16:54,560 --> 00:17:01,200
so something like this right so packet I

00:16:59,220 --> 00:17:04,350
have said that too much it's the same

00:17:01,200 --> 00:17:06,810
thing from before ABCD slash 24 much

00:17:04,350 --> 00:17:09,959
protocol TCP so I'm going to say look

00:17:06,810 --> 00:17:12,040
I'm interested in TCP packets I wanted

00:17:09,959 --> 00:17:17,860
to use the last octet

00:17:12,040 --> 00:17:21,760
as the key as the bucket ID for the next

00:17:17,860 --> 00:17:23,920
table not for this table and for your

00:17:21,760 --> 00:17:24,730
next offset in that second table which

00:17:23,920 --> 00:17:28,170
is Table one

00:17:24,730 --> 00:17:31,480
I want you to use the IP header length

00:17:28,170 --> 00:17:36,160
take that value shift it to the two by

00:17:31,480 --> 00:17:39,370
six bits and then add that and then at

00:17:36,160 --> 00:17:41,290
that field is going to be a new there's

00:17:39,370 --> 00:17:46,300
some key words here that field is going

00:17:41,290 --> 00:17:50,920
to be your new offset zero right so what

00:17:46,300 --> 00:17:54,250
I'm doing here is I've taken every every

00:17:50,920 --> 00:17:55,180
horse in that slash 24 and I have

00:17:54,250 --> 00:17:57,040
computed

00:17:55,180 --> 00:18:06,730
I'm just looking at if it's going too

00:17:57,040 --> 00:18:15,280
much ssh put 22 is this is this gelling

00:18:06,730 --> 00:18:20,770
with you guys I think so okay all right

00:18:15,280 --> 00:18:24,940
so having say that they are Hardware

00:18:20,770 --> 00:18:28,840
offloads existing I had an Intel x DB e

00:18:24,940 --> 00:18:33,190
in at the office so try to play it off

00:18:28,840 --> 00:18:35,230
those u-32 I look in the kernel code the

00:18:33,190 --> 00:18:39,370
Chelsea O's the three models of Chelsea

00:18:35,230 --> 00:18:41,800
au natural oh my and I I don't know this

00:18:39,370 --> 00:18:44,590
STM mark who that is but they do offload

00:18:41,800 --> 00:18:47,410
you 32 into the headway okay so again

00:18:44,590 --> 00:18:49,090
not we're not talking here about oh yeah

00:18:47,410 --> 00:18:52,870
we support the five tuple classified

00:18:49,090 --> 00:18:57,240
which is Tom's main comment that flower

00:18:52,870 --> 00:19:00,550
has this 25 or 26 or 30 classifications

00:18:57,240 --> 00:19:03,490
that it supports because I guess it came

00:19:00,550 --> 00:19:05,080
from open flow and that humans

00:19:03,490 --> 00:19:06,760
understand when they see sauce IP we

00:19:05,080 --> 00:19:09,910
don't care about that what you can do

00:19:06,760 --> 00:19:11,770
with with with you 32 is you can read

00:19:09,910 --> 00:19:14,380
wrappers around it you can write a

00:19:11,770 --> 00:19:16,660
wrapper that when configured in the

00:19:14,380 --> 00:19:19,570
hardware or in the kernel it's a source

00:19:16,660 --> 00:19:22,690
IP alright in fact they exist but nobody

00:19:19,570 --> 00:19:24,549
who uses you that to really seems to

00:19:22,690 --> 00:19:26,769
care that much about that

00:19:24,549 --> 00:19:30,159
okay so how do you enable how do I float

00:19:26,769 --> 00:19:34,139
just like in any offload a flow TT see

00:19:30,159 --> 00:19:39,190
you turn on turn it on with its tool

00:19:34,139 --> 00:19:40,899
here's a rule you add it on the ingress

00:19:39,190 --> 00:19:43,330
assuming you have an ingress you say on

00:19:40,899 --> 00:19:47,440
protocol IP I'm gonna give it a priority

00:19:43,330 --> 00:19:58,149
of 10 and a trick question for you what

00:19:47,440 --> 00:20:06,549
is 800 : 0 : 1 mean anybody bucket 1 at

00:19:58,149 --> 00:20:10,149
table 800 X 800 bucket bucket 0 and node

00:20:06,549 --> 00:20:12,940
ID the keynote is 1 right I'm just

00:20:10,149 --> 00:20:15,039
saying God so I assuming a single table

00:20:12,940 --> 00:20:17,440
only the root table is available there's

00:20:15,039 --> 00:20:21,399
only one hash bucket I have just added

00:20:17,440 --> 00:20:25,389
it to that I'm asking you to match 1600

00:20:21,399 --> 00:20:27,190
/ well I don't think in either 100 and I

00:20:25,389 --> 00:20:29,019
don't want to put skip software means

00:20:27,190 --> 00:20:30,849
don't put this in software at all

00:20:29,019 --> 00:20:36,070
go straight to the hardware and give it

00:20:30,849 --> 00:20:37,959
a class ID of 1 1 okay so the ax GBE at

00:20:36,070 --> 00:20:41,889
the time I was playing with it and I

00:20:37,959 --> 00:20:44,709
contacted the Intel folks I'm Rita who

00:20:41,889 --> 00:20:46,659
fixed some issues for me is a co-author

00:20:44,709 --> 00:20:52,690
and verified all this this is all true

00:20:46,659 --> 00:20:53,200
ok so it can you can add up to 20 45

00:20:52,690 --> 00:20:56,289
rules

00:20:53,200 --> 00:21:00,700
I don't ask me what 20 why such a number

00:20:56,289 --> 00:21:03,339
you know 2043 it can match only on those

00:21:00,700 --> 00:21:08,529
tuples source destination IP v4 v6

00:21:03,339 --> 00:21:10,779
protocol sauce test so it decides for me

00:21:08,529 --> 00:21:14,049
that those those are the only things you

00:21:10,779 --> 00:21:17,379
know support ok it can drop it can

00:21:14,049 --> 00:21:20,139
accept packets I love this class ID

00:21:17,379 --> 00:21:21,849
feature I don't know if the Mellanox

00:21:20,139 --> 00:21:24,190
guys are here but that's a fantastic

00:21:21,849 --> 00:21:29,499
feature I can actually specify the class

00:21:24,190 --> 00:21:32,469
ideas say 1 : 1 and the hardware would

00:21:29,499 --> 00:21:34,960
take that and in and send it to DMA ring

00:21:32,469 --> 00:21:37,109
0 right so I'm actually telling it where

00:21:34,960 --> 00:21:37,109
to go

00:21:37,480 --> 00:21:44,560
the skb edit same thing as uh as

00:21:40,560 --> 00:21:47,320
Mellanox when Ronnie and Amir were here

00:21:44,560 --> 00:21:48,910
before and for some weird reason don't

00:21:47,320 --> 00:21:51,060
ask me why it seems all these hardware

00:21:48,910 --> 00:21:55,870
vendors like to support only 15 bits

00:21:51,060 --> 00:21:57,970
right so that is also not upstream and

00:21:55,870 --> 00:21:59,770
you can do a redirect but only when you

00:21:57,970 --> 00:22:01,900
have SR iove which i'm not interested in

00:21:59,770 --> 00:22:05,170
and an offloaded v mark VLAN so you can

00:22:01,900 --> 00:22:08,740
actually put your own hand coded load

00:22:05,170 --> 00:22:09,910
balancer from TC you're teaching the

00:22:08,740 --> 00:22:11,500
hardware and it's gonna start load

00:22:09,910 --> 00:22:12,970
balancing across mark feelings and you

00:22:11,500 --> 00:22:16,420
could throw those in containers etc

00:22:12,970 --> 00:22:17,770
there's other features that i that this

00:22:16,420 --> 00:22:20,290
hardware supports i just didn't have

00:22:17,770 --> 00:22:22,630
time we just wanted to do a quick paper

00:22:20,290 --> 00:22:26,440
for the conference so we haven't looked

00:22:22,630 --> 00:22:27,970
much into those details okay so i want

00:22:26,440 --> 00:22:31,650
to do some performance analysis and show

00:22:27,970 --> 00:22:36,250
some numbers so we created a baseline

00:22:31,650 --> 00:22:38,920
set of where we match every packet and

00:22:36,250 --> 00:22:42,010
see it and just redirect it it comes on

00:22:38,920 --> 00:22:45,460
one port guess there's only one rule in

00:22:42,010 --> 00:22:47,650
the route table the next is we match we

00:22:45,460 --> 00:22:49,540
had to 54 and we pretend to be a dumb

00:22:47,650 --> 00:22:53,470
users we just add things and doesn't

00:22:49,540 --> 00:22:55,030
tell the kernel where to insert them so

00:22:53,470 --> 00:22:58,960
they all get inserted in the root table

00:22:55,030 --> 00:23:01,240
bucket 0 the next one is i'm gonna

00:22:58,960 --> 00:23:04,000
optimize it based on that table I showed

00:23:01,240 --> 00:23:06,340
you earlier with 255 our users and third

00:23:04,000 --> 00:23:07,180
only say what if we had 64 thousand

00:23:06,340 --> 00:23:10,630
users and want to see what the

00:23:07,180 --> 00:23:12,340
performance difference is okay so the

00:23:10,630 --> 00:23:14,950
sixty-four thousand users if you're

00:23:12,340 --> 00:23:18,520
curious looks like this we have two

00:23:14,950 --> 00:23:22,090
levels of hash lookups ok so I should

00:23:18,520 --> 00:23:24,520
say that with this if I in my case I'm

00:23:22,090 --> 00:23:27,400
interested in 64,000 source IP addresses

00:23:24,520 --> 00:23:30,280
I can find any address in tool and three

00:23:27,400 --> 00:23:32,410
lookups right so that's the beauty of

00:23:30,280 --> 00:23:37,210
this my traffic patterns requires me to

00:23:32,410 --> 00:23:40,300
just look up on source IP on the ingress

00:23:37,210 --> 00:23:43,660
I can now look I can guarantee you that

00:23:40,300 --> 00:23:45,910
I'll find that IP in 3 lookups ok

00:23:43,660 --> 00:23:47,920
in in the previous example we're sure

00:23:45,910 --> 00:23:51,480
254 uses I can guarantee you'll find the

00:23:47,920 --> 00:23:53,490
lookup in to now if you you can

00:23:51,480 --> 00:23:56,250
right some very optimized thing we'll do

00:23:53,490 --> 00:23:57,750
it in one and a half but this is

00:23:56,250 --> 00:24:00,510
scriptable okay I didn't have to change

00:23:57,750 --> 00:24:04,890
anything in the kernel and I can I can

00:24:00,510 --> 00:24:05,970
do variable header sizes etc okay so

00:24:04,890 --> 00:24:07,650
this is the test setup

00:24:05,970 --> 00:24:10,980
I found this tool called we found the

00:24:07,650 --> 00:24:14,460
tool called TRX that generates traffic

00:24:10,980 --> 00:24:18,720
at high speed yeah it runs DB DK we have

00:24:14,460 --> 00:24:21,090
some really old clunky hardware so it

00:24:18,720 --> 00:24:23,270
sends on one direction the system on the

00:24:21,090 --> 00:24:25,530
test is another piece of hardware that

00:24:23,270 --> 00:24:28,230
will run on all those three test cases

00:24:25,530 --> 00:24:30,090
it's a very very old piece of hardware

00:24:28,230 --> 00:24:35,090
it's the only one that had ixd PE on it

00:24:30,090 --> 00:24:38,250
like from 10 years ago it's an Zeon v2

00:24:35,090 --> 00:24:40,320
and when you put it up it tells you very

00:24:38,250 --> 00:24:42,510
clearly that this thing would support

00:24:40,320 --> 00:24:44,670
wire speed okay it looks at the the PCI

00:24:42,510 --> 00:24:46,050
bus is very old if you try to send

00:24:44,670 --> 00:24:48,360
bi-directional traffic in probably to

00:24:46,050 --> 00:24:52,650
like 60 70 percent the paper will have

00:24:48,360 --> 00:24:55,710
more details on this and so what we what

00:24:52,650 --> 00:24:57,690
we did is we used our SS to default to 8

00:24:55,710 --> 00:24:59,460
we were trying to reduce the variable

00:24:57,690 --> 00:25:02,430
the system on the test is the classify

00:24:59,460 --> 00:25:06,320
okay so we don't want any noise get rid

00:25:02,430 --> 00:25:08,910
of the cutest clock by using mq prior

00:25:06,320 --> 00:25:14,810
and so all the tests will basically

00:25:08,910 --> 00:25:17,910
match and send or drop when it fails ok

00:25:14,810 --> 00:25:21,840
so we try to reduce the variables as

00:25:17,910 --> 00:25:24,600
much as we could okay so next this is

00:25:21,840 --> 00:25:26,580
how the egress path looks like there is

00:25:24,600 --> 00:25:29,310
no queue this clock at all packets come

00:25:26,580 --> 00:25:31,820
in the mq prior will select one of the

00:25:29,310 --> 00:25:33,840
rings off it goes ok so if you look

00:25:31,820 --> 00:25:38,820
you'll hardly see anything the only

00:25:33,840 --> 00:25:43,890
reason we have the the the queue disk

00:25:38,820 --> 00:25:46,770
there which is b54 was on occasion we'd

00:25:43,890 --> 00:25:48,600
see packets coming in go out and then

00:25:46,770 --> 00:25:50,910
the ring is full and they get Riku to

00:25:48,600 --> 00:25:52,890
software right the next time they'll get

00:25:50,910 --> 00:25:55,500
DQ'd from there and pushed back into the

00:25:52,890 --> 00:25:58,170
kernel into the hardware this is the old

00:25:55,500 --> 00:26:00,900
beast we're on we only used one of these

00:25:58,170 --> 00:26:03,540
Numa nodes and you can see their ports I

00:26:00,900 --> 00:26:05,010
think two of these was going out sharing

00:26:03,540 --> 00:26:07,020
the PCI bus

00:26:05,010 --> 00:26:09,270
which was already insufficient for one

00:26:07,020 --> 00:26:11,070
and we're using it for two so we can't

00:26:09,270 --> 00:26:12,480
do wire speed on this thing right but

00:26:11,070 --> 00:26:14,130
still that software could be a

00:26:12,480 --> 00:26:16,350
bottleneck there's a there's a lot of

00:26:14,130 --> 00:26:19,080
problems with this thing but we just

00:26:16,350 --> 00:26:22,500
wanted to do some quick comparative

00:26:19,080 --> 00:26:26,610
analysis okay so here's our results when

00:26:22,500 --> 00:26:29,240
we run the baseline all it did was it

00:26:26,610 --> 00:26:32,100
had one rule too much everything

00:26:29,240 --> 00:26:34,200
redirect it to the other port we were

00:26:32,100 --> 00:26:38,640
able to about nine million packets per

00:26:34,200 --> 00:26:42,360
second right when we sorry I'm sorry

00:26:38,640 --> 00:26:45,240
this is the baseline with no no no rules

00:26:42,360 --> 00:26:48,050
at all the one rule too much all is what

00:26:45,240 --> 00:26:50,790
I just described it has a TC ingress

00:26:48,050 --> 00:26:54,180
rule which must want everything and

00:26:50,790 --> 00:26:57,000
redirect it to the egress port this is

00:26:54,180 --> 00:26:59,310
the one when we added I don't think I

00:26:57,000 --> 00:27:02,220
should be using this so here this on

00:26:59,310 --> 00:27:04,920
this one we added 200 this is the damn

00:27:02,220 --> 00:27:07,530
user adding rules without specifying

00:27:04,920 --> 00:27:09,390
where they should be added as you can

00:27:07,530 --> 00:27:11,880
see it dropped to about 2 million

00:27:09,390 --> 00:27:14,550
packets per second here's what we took

00:27:11,880 --> 00:27:16,920
this exact same setup and we built a set

00:27:14,550 --> 00:27:20,040
of hash tables this was a single hashed

00:27:16,920 --> 00:27:22,860
extra hash table and we put each rule in

00:27:20,040 --> 00:27:25,950
one bucket you can see we were able to

00:27:22,860 --> 00:27:28,110
shoot close to 7 million and this is the

00:27:25,950 --> 00:27:33,510
one with which I said was 64,000 users

00:27:28,110 --> 00:27:35,820
as you can see it's close to almost the

00:27:33,510 --> 00:27:38,010
same speed as as one match this is with

00:27:35,820 --> 00:27:44,940
a single match look at that that's with

00:27:38,010 --> 00:27:45,840
64,000 possible matches right I'm going

00:27:44,940 --> 00:27:48,290
to stop you and see if there's any

00:27:45,840 --> 00:27:54,350
questions I still have some time or

00:27:48,290 --> 00:27:54,350
comments ok

00:28:08,200 --> 00:28:15,070
so Jamil I didn't quite follow the part

00:28:11,980 --> 00:28:18,009
where you were doing the offset and the

00:28:15,070 --> 00:28:22,529
shift is that actually something that

00:28:18,009 --> 00:28:24,639
can be done in a TC command yes yes so

00:28:22,529 --> 00:28:27,190
it's done in the connell you tell the

00:28:24,639 --> 00:28:29,830
colonel how you want it done so

00:28:27,190 --> 00:28:33,999
theoretically so for example there was a

00:28:29,830 --> 00:28:35,409
TC protocol field if I start with the

00:28:33,999 --> 00:28:38,409
assumption that my first packet is

00:28:35,409 --> 00:28:42,460
Ethernet in theory we could just do this

00:28:38,409 --> 00:28:45,029
chaining and find the ether type and

00:28:42,460 --> 00:28:49,149
then go to that and then go to that and

00:28:45,029 --> 00:28:52,090
exactly so this is so I think your

00:28:49,149 --> 00:28:53,679
presentation was current state and more

00:28:52,090 --> 00:28:56,019
tutorial so bear in mind a

00:28:53,679 --> 00:28:58,299
forward-looking stuff now entering into

00:28:56,019 --> 00:28:59,739
and this makes me realize that probably

00:28:58,299 --> 00:29:02,559
a little harsh on the network vendors

00:28:59,739 --> 00:29:05,679
since we're kind of guilty of the same

00:29:02,559 --> 00:29:08,769
thing and some of the kernel kernel

00:29:05,679 --> 00:29:10,629
stuff but if we step back and look at

00:29:08,769 --> 00:29:13,090
the the essence of the problem so this

00:29:10,629 --> 00:29:15,970
is the match action part of network

00:29:13,090 --> 00:29:17,980
processing and that's required certainly

00:29:15,970 --> 00:29:19,539
once we get into the IP header we want

00:29:17,980 --> 00:29:22,600
to match an IP address that's very

00:29:19,539 --> 00:29:24,789
common in order to do that though this

00:29:22,600 --> 00:29:27,489
clearly shows we have to get into that

00:29:24,789 --> 00:29:30,100
header yes so it's really not match

00:29:27,489 --> 00:29:34,450
action what it really is is parse match

00:29:30,100 --> 00:29:36,730
action so parsing gets us the header

00:29:34,450 --> 00:29:38,919
we're interested in and then within that

00:29:36,730 --> 00:29:41,470
we do matches on the fields in the

00:29:38,919 --> 00:29:42,730
header and then take the action so so

00:29:41,470 --> 00:29:45,070
that it's a slightly different

00:29:42,730 --> 00:29:47,350
philosophy because parsing means you you

00:29:45,070 --> 00:29:51,039
collect your head as first into some

00:29:47,350 --> 00:29:53,409
well and so it turns out this to me this

00:29:51,039 --> 00:29:54,970
looks a lot like the p4 model they

00:29:53,409 --> 00:29:57,999
actually do they actually segment it

00:29:54,970 --> 00:30:00,279
into the parsing level match action and

00:29:57,999 --> 00:30:01,929
then I guess they have some sort of

00:30:00,279 --> 00:30:04,690
weird there is a slight difference the

00:30:01,929 --> 00:30:06,820
the p4 is sort of more like probably the

00:30:04,690 --> 00:30:08,559
dye sector we have you collect all the

00:30:06,820 --> 00:30:10,419
headers and then you use them for

00:30:08,559 --> 00:30:12,340
something you actually have a data

00:30:10,419 --> 00:30:14,830
structure which has so the p4 people

00:30:12,340 --> 00:30:18,309
pass the packets and put them in some

00:30:14,830 --> 00:30:21,129
construct and then you use them to to

00:30:18,309 --> 00:30:22,090
march and then execute an action this is

00:30:21,129 --> 00:30:24,640
doing a runtime

00:30:22,090 --> 00:30:26,620
I'm just walking the packet and as I

00:30:24,640 --> 00:30:28,659
find things I'm saying yeah this matches

00:30:26,620 --> 00:30:32,679
I don't collect anything right

00:30:28,659 --> 00:30:34,570
I don't store any intermediate data

00:30:32,679 --> 00:30:38,440
structure that then gets used to do the

00:30:34,570 --> 00:30:41,529
match okay so my second comment again

00:30:38,440 --> 00:30:44,950
this is forward-looking mm-hmm so the TC

00:30:41,529 --> 00:30:47,260
command-line format very hard for me to

00:30:44,950 --> 00:30:49,299
parse so what happens is sometimes I'll

00:30:47,260 --> 00:30:50,740
use TC I've read the man page and I'll

00:30:49,299 --> 00:30:53,980
figure out the command they come back a

00:30:50,740 --> 00:30:56,200
month later it would be really really

00:30:53,980 --> 00:31:01,169
nice to have an easy language to

00:30:56,200 --> 00:31:04,600
front-end that I don't disagree you know

00:31:01,169 --> 00:31:07,409
it's hard to for humans to read any BNF

00:31:04,600 --> 00:31:09,880
grammar ok this it has a PMF grammar

00:31:07,409 --> 00:31:12,370
which is correct

00:31:09,880 --> 00:31:14,169
formal complete but it's intended for

00:31:12,370 --> 00:31:16,960
machines really so someone needs to

00:31:14,169 --> 00:31:18,909
write a beautiful thing on top of it but

00:31:16,960 --> 00:31:20,500
at the assembler level I think this is a

00:31:18,909 --> 00:31:23,649
very good fit that's that's what I was

00:31:20,500 --> 00:31:25,630
trying to say I mean for instance like

00:31:23,649 --> 00:31:27,850
if I want to get the source address out

00:31:25,630 --> 00:31:30,070
of an IP packet instead of expressing

00:31:27,850 --> 00:31:31,929
that as a numerical all set I wish I

00:31:30,070 --> 00:31:35,020
could just say give it a data structure

00:31:31,929 --> 00:31:37,750
and say source address and put source

00:31:35,020 --> 00:31:40,059
instead of some weird some number that I

00:31:37,750 --> 00:31:41,799
have to compute so it's just I mean it's

00:31:40,059 --> 00:31:44,230
kind of obvious right its ease of use so

00:31:41,799 --> 00:31:47,500
we like to yeah this is like assembly

00:31:44,230 --> 00:31:49,480
and we want to go up to a non assembly

00:31:47,500 --> 00:31:53,380
language no I don't disagree I'm saying

00:31:49,480 --> 00:31:54,789
that by itself it's too low-level if you

00:31:53,380 --> 00:31:58,390
know what you're doing you can write

00:31:54,789 --> 00:32:00,669
your own scripts and there's been

00:31:58,390 --> 00:32:03,760
attempts even if you look at TC the u-32

00:32:00,669 --> 00:32:06,039
is syntax you'll see actually English

00:32:03,760 --> 00:32:08,909
syntax which is IP sauce and then you

00:32:06,039 --> 00:32:13,360
specify the source in in quiet octet

00:32:08,909 --> 00:32:16,149
right but power users probably don't use

00:32:13,360 --> 00:32:21,279
it that much but point taken

00:32:16,149 --> 00:32:22,659
right any other question so how do I

00:32:21,279 --> 00:32:26,260
offend us why you're not implementing

00:32:22,659 --> 00:32:28,480
this Ronnie why why are you implementing

00:32:26,260 --> 00:32:30,850
flower ok I can see you need to you need

00:32:28,480 --> 00:32:32,350
to make humans happy in the age of

00:32:30,850 --> 00:32:34,679
automation do you really care about

00:32:32,350 --> 00:32:34,679
humans

00:32:38,440 --> 00:32:45,730
yeah so because look it can do it can do

00:32:43,250 --> 00:32:48,590
all the crap that the industry

00:32:45,730 --> 00:32:50,179
marketeers are putting out okay okay you

00:32:48,590 --> 00:32:52,580
can do this look who is the customer

00:32:50,179 --> 00:32:54,770
that's using it what why does it depend

00:32:52,580 --> 00:32:56,090
on the customer you can write some I see

00:32:54,770 --> 00:33:04,580
okay you answered my question I guess

00:32:56,090 --> 00:33:07,059
you boss my new boss okay but look at

00:33:04,580 --> 00:33:10,039
that beautiful diagram I drew do you see

00:33:07,059 --> 00:33:13,610
just take this and send it you can do

00:33:10,039 --> 00:33:17,149
this yes we can yeah you don't have to

00:33:13,610 --> 00:33:21,260
write any new code that's what we spoke

00:33:17,149 --> 00:33:24,740
I think before kind of a before well

00:33:21,260 --> 00:33:28,419
it's before is you know so that's the

00:33:24,740 --> 00:33:28,419
point the processing part is unnecessary

00:33:32,710 --> 00:33:38,840
yeah we do support you 32 but the point

00:33:36,380 --> 00:33:40,220
that tom was making is very valid the

00:33:38,840 --> 00:33:42,830
way Hardware is done

00:33:40,220 --> 00:33:45,260
you don't unite the parsing and the

00:33:42,830 --> 00:33:48,500
classification together because that

00:33:45,260 --> 00:33:49,850
makes for a very many tables this is

00:33:48,500 --> 00:33:51,620
what would happen here as well that

00:33:49,850 --> 00:33:53,059
you're taking you know one action at a

00:33:51,620 --> 00:33:54,740
time you're matching one table then

00:33:53,059 --> 00:33:56,630
saying okay now I have another header

00:33:54,740 --> 00:33:58,190
I'll match that and then I'll match

00:33:56,630 --> 00:34:00,529
another one so that makes a lot of

00:33:58,190 --> 00:34:02,779
tables so the way the Asics are

00:34:00,529 --> 00:34:04,820
optimized you definitely do the parsing

00:34:02,779 --> 00:34:06,230
upfront and then you have the

00:34:04,820 --> 00:34:09,230
classification table so that you reduce

00:34:06,230 --> 00:34:12,109
the number of tables you have so that

00:34:09,230 --> 00:34:13,909
definitely comes the way the p4 is done

00:34:12,109 --> 00:34:17,720
you separator the parsing from the

00:34:13,909 --> 00:34:20,330
classification it fits the asic it much

00:34:17,720 --> 00:34:23,359
better but I mean the only thing that I

00:34:20,330 --> 00:34:24,710
would say is flour as compared to you 32

00:34:23,359 --> 00:34:27,260
you third you is definitely better

00:34:24,710 --> 00:34:29,270
because of the flexibility you get which

00:34:27,260 --> 00:34:31,820
flour doesn't give me in terms of

00:34:29,270 --> 00:34:34,010
defining new fields or whatever

00:34:31,820 --> 00:34:36,770
the only other complaint that we've had

00:34:34,010 --> 00:34:40,540
is you know some of the actions and

00:34:36,770 --> 00:34:43,849
which is missing from both in case of

00:34:40,540 --> 00:34:45,770
flour and you 32 and I you know we have

00:34:43,849 --> 00:34:49,270
talked about it what we could do about

00:34:45,770 --> 00:34:55,909
extending actions which is which

00:34:49,270 --> 00:34:58,640
something that we still need to solve so

00:34:55,909 --> 00:35:02,900
yeah if that's Hardware inquire requires

00:34:58,640 --> 00:35:04,520
that you have to parse first then for

00:35:02,900 --> 00:35:06,770
some reason I'm imagining that you have

00:35:04,520 --> 00:35:08,840
multiple Hardware tables anymore

00:35:06,770 --> 00:35:14,180
comments to either I'm still keeping the

00:35:08,840 --> 00:35:17,600
time here so thanks you have any okay so

00:35:14,180 --> 00:35:20,900
your your message is show me the money

00:35:17,600 --> 00:35:24,410
right somebody there wants to somebody

00:35:20,900 --> 00:35:33,290
wants to say some yeah give me the

00:35:24,410 --> 00:35:38,119
cookie hi speaking from another vendor

00:35:33,290 --> 00:35:40,100
company who we do FPGA S&P for ya

00:35:38,119 --> 00:35:42,560
I'd like to second that the idea that

00:35:40,100 --> 00:35:46,880
you really want to do the parsing first

00:35:42,560 --> 00:35:49,580
and then any kind of matching because in

00:35:46,880 --> 00:35:51,800
the in for FPGA is at least it's a big

00:35:49,580 --> 00:35:53,480
pipe on the packet processing starts at

00:35:51,800 --> 00:35:55,400
some point and goes goes through the

00:35:53,480 --> 00:35:58,880
pipeline it has to be it has to be

00:35:55,400 --> 00:36:01,490
parsed you can't afford to do parsing in

00:35:58,880 --> 00:36:04,430
the people in the middle but the other

00:36:01,490 --> 00:36:07,369
question is regarding this you 32 do you

00:36:04,430 --> 00:36:12,859
know of any effort or idea to actually

00:36:07,369 --> 00:36:15,260
do p4 to you 32 translation is there any

00:36:12,859 --> 00:36:17,450
effort because other mentioned that it's

00:36:15,260 --> 00:36:21,830
difficult to understand all of this and

00:36:17,450 --> 00:36:25,060
it might be used for relevant to try use

00:36:21,830 --> 00:36:28,160
p4 syntax and to compile it into these

00:36:25,060 --> 00:36:31,190
you 32 syntax tom did you want to

00:36:28,160 --> 00:36:35,390
comment to that or oh yeah oh you're

00:36:31,190 --> 00:36:35,960
taking up you you don't say something to

00:36:35,390 --> 00:36:39,530
that effect

00:36:35,960 --> 00:36:41,060
Oh Mike okay we there's a lot of

00:36:39,530 --> 00:36:42,859
interested parties maybe we should get

00:36:41,060 --> 00:36:44,420
together some coffee good coffee in

00:36:42,859 --> 00:36:47,030
Prague and talk about this stuff right

00:36:44,420 --> 00:36:52,100
tom is one I know probably the vendors

00:36:47,030 --> 00:36:55,190
and generally Ronnie we get we can we

00:36:52,100 --> 00:36:57,619
can sure if you guys say that you have

00:36:55,190 --> 00:36:59,540
to parse fast in order to make the

00:36:57,619 --> 00:37:00,610
hardware more effective then alright I'm

00:36:59,540 --> 00:37:02,410
not gonna argue with that

00:37:00,610 --> 00:37:05,110
right and the but the passing is what

00:37:02,410 --> 00:37:07,840
they should be maybe describable in a

00:37:05,110 --> 00:37:09,790
human friendly way but the idea of you

00:37:07,840 --> 00:37:11,680
know I'm gonna add yet another 25th

00:37:09,790 --> 00:37:14,590
tuple and open flow that's ridiculous

00:37:11,680 --> 00:37:18,280
okay that's it's a problem and flower

00:37:14,590 --> 00:37:20,530
models after after you got to change the

00:37:18,280 --> 00:37:22,030
kernel it has to so the idea the script

00:37:20,530 --> 00:37:23,740
ability has to be maintained in my

00:37:22,030 --> 00:37:24,970
opinion that I can I I don't have to

00:37:23,740 --> 00:37:27,730
change the whatever's in the data path

00:37:24,970 --> 00:37:30,880
know it this is a great background tool

00:37:27,730 --> 00:37:33,660
but getting it a p4 front-end that would

00:37:30,880 --> 00:37:36,460
be user understandable so B P for

00:37:33,660 --> 00:37:38,320
hardware friendly or stuff it could be

00:37:36,460 --> 00:37:42,100
something that could really add some

00:37:38,320 --> 00:37:43,900
usability value to this as the time keep

00:37:42,100 --> 00:37:46,830
on going say this last committee and

00:37:43,900 --> 00:37:46,830
then we go for break okay

00:37:46,950 --> 00:37:53,920
so I mean this is this request for p4 is

00:37:51,430 --> 00:37:56,680
not any different from like why not do

00:37:53,920 --> 00:37:58,990
EVP F to generate TC right as well I

00:37:56,680 --> 00:38:01,210
mean yes we have any ways to define

00:37:58,990 --> 00:38:05,530
everything before defines a pipeline a

00:38:01,210 --> 00:38:07,780
classifier and parcel and a Matt action

00:38:05,530 --> 00:38:09,940
table right I mean like if you say P for

00:38:07,780 --> 00:38:13,480
generates TC then you have to support a

00:38:09,940 --> 00:38:14,950
much richer back and on the on the TC

00:38:13,480 --> 00:38:16,480
side then you would otherwise otherwise

00:38:14,950 --> 00:38:19,090
you're now creating artificial

00:38:16,480 --> 00:38:20,440
constraints that the user never knows it

00:38:19,090 --> 00:38:23,080
when I write the P for program I don't

00:38:20,440 --> 00:38:24,610
know what it's going into there there

00:38:23,080 --> 00:38:26,650
may be a case and I think there is a

00:38:24,610 --> 00:38:29,560
case for saying there is a minimum set

00:38:26,650 --> 00:38:31,330
of P for primitives but at that point

00:38:29,560 --> 00:38:32,650
you are back to TC primitives and you

00:38:31,330 --> 00:38:34,840
might as well just stick to the TC

00:38:32,650 --> 00:38:37,090
primitives right so so I think there is

00:38:34,840 --> 00:38:40,330
a uniformity question we need to address

00:38:37,090 --> 00:38:41,740
I hope that I enlightened people a

00:38:40,330 --> 00:38:43,390
little bit on you 32 they know a little

00:38:41,740 --> 00:38:48,700
more than they did before they walked in

00:38:43,390 --> 00:38:50,070
here all right with and with that thank

00:38:48,700 --> 00:38:53,979
you everybody

00:38:50,070 --> 00:38:53,979

YouTube URL: https://www.youtube.com/watch?v=kykJx8hP0lw


