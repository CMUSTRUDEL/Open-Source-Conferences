Title: Netdev 0x13 - switch Live migration Support For Virtio With SRIOV VF Datapath
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 2 - Track 1 + 2 - Mar 21 2019
Description: 
	Or Gerlitz talks about support to handle virtio with SRIOV live-migration.

As of kernel 4.18 the virtio guest driver uses the SRIOV VF channel when it can or otherwise falls back to the classical the para-virtual channel. With this setup live-migration of VMs running under SRIOV is possible.
Or Gerlitz and Parav Pandit  propose a design based on the switchdev mode for
NIC host drivers.

More info:
https://netdevconf.org/0x13/session.html?talk-v-switch-virtio-sriov-vf-datapath
Captions: 
	00:00:00,030 --> 00:00:04,650
okay so hi everyone or girl it's from

00:00:03,210 --> 00:00:08,760
Mullenix and this is a joint work with

00:00:04,650 --> 00:00:15,420
vou and parov I'm going to be talking

00:00:08,760 --> 00:00:17,430
about the vs weak side of SRA or V live

00:00:15,420 --> 00:00:20,850
migration with SFI of E but I will have

00:00:17,430 --> 00:00:23,430
to do some quick reminders for you which

00:00:20,850 --> 00:00:26,130
will be quick because it's it's a

00:00:23,430 --> 00:00:28,769
background so if you go back in previous

00:00:26,130 --> 00:00:32,189
natives we're talking about the fact

00:00:28,769 --> 00:00:33,630
that SRV has few drawbacks and one of

00:00:32,189 --> 00:00:37,079
them that live migration is not

00:00:33,630 --> 00:00:41,059
supported I think it was in Seol were a

00:00:37,079 --> 00:00:44,969
few few guys we're talking about that

00:00:41,059 --> 00:00:48,420
also in a workshop and later a solution

00:00:44,969 --> 00:00:51,030
has been decided by the community that

00:00:48,420 --> 00:00:53,190
if you want to use virtual functions on

00:00:51,030 --> 00:00:54,930
the one hand but on the other hand you

00:00:53,190 --> 00:00:58,859
want to use you want to have support for

00:00:54,930 --> 00:01:01,050
live migration some solution was found

00:00:58,859 --> 00:01:05,339
that integrates with Vittorio and I will

00:01:01,050 --> 00:01:08,460
sketch it quickly and my focus today

00:01:05,339 --> 00:01:10,560
will be on the hypervisor set because in

00:01:08,460 --> 00:01:12,810
virtualization you have virtual NIC in

00:01:10,560 --> 00:01:15,210
the VM and you have some virtual switch

00:01:12,810 --> 00:01:23,090
on the hypervisor so I will quickly

00:01:15,210 --> 00:01:26,790
sketch what solution was decided for the

00:01:23,090 --> 00:01:28,770
how do you how does the guest site looks

00:01:26,790 --> 00:01:31,439
when you want to apply live migration

00:01:28,770 --> 00:01:36,750
and so on the one hand and other one on

00:01:31,439 --> 00:01:39,540
the other hand use s r io v and how does

00:01:36,750 --> 00:01:41,040
it looks what are what is the gay side

00:01:39,540 --> 00:01:42,869
of thing and then I will move to the

00:01:41,040 --> 00:01:47,579
hypervisor side which is the focus of my

00:01:42,869 --> 00:01:49,290
talk today I will sketch your

00:01:47,579 --> 00:01:53,820
requirement and then I will do a crash

00:01:49,290 --> 00:01:56,130
reminder on how switch them on the suite

00:01:53,820 --> 00:02:00,180
of mode of managing V switches from

00:01:56,130 --> 00:02:01,829
Nick's and then I will go to my what

00:02:00,180 --> 00:02:03,600
were what we did in this work with the

00:02:01,829 --> 00:02:06,750
how do you how do you do live migration

00:02:03,600 --> 00:02:10,259
with this so this is actually jumping

00:02:06,750 --> 00:02:13,710
directly into the water this is the VM

00:02:10,259 --> 00:02:16,020
side of this the commute that the

00:02:13,710 --> 00:02:18,690
solution that was made by the community

00:02:16,020 --> 00:02:21,420
so again bear in mind that you want this

00:02:18,690 --> 00:02:26,750
VM to use a virtual function which is

00:02:21,420 --> 00:02:28,860
pass through into the VM and that's what

00:02:26,750 --> 00:02:30,570
that's what you want to do on the

00:02:28,860 --> 00:02:33,120
steady-state like when live migration is

00:02:30,570 --> 00:02:36,240
not running people want an accelerated

00:02:33,120 --> 00:02:40,650
way to do networking in a VM using path

00:02:36,240 --> 00:02:44,250
through device okay the way it was

00:02:40,650 --> 00:02:46,260
decided to to implement that for live

00:02:44,250 --> 00:02:48,810
migration is something we call in the

00:02:46,260 --> 00:02:50,970
community a three-three native model and

00:02:48,810 --> 00:02:51,930
this is this is called punitive model

00:02:50,970 --> 00:02:54,240
because there are three networks

00:02:51,930 --> 00:02:56,430
involved which I'll explain but there

00:02:54,240 --> 00:02:58,080
are other models of net VSD and other

00:02:56,430 --> 00:03:00,960
hypervisor which are two native or one a

00:02:58,080 --> 00:03:04,370
dev by the way Michelle silk in the

00:03:00,960 --> 00:03:06,990
metal so you can the Vertigo maintainer

00:03:04,370 --> 00:03:09,300
actually made this week an excellent

00:03:06,990 --> 00:03:11,580
blog post that explains the the VM side

00:03:09,300 --> 00:03:18,780
and he sent it on the net of mailing

00:03:11,580 --> 00:03:20,580
list your me fellows here so I recommend

00:03:18,780 --> 00:03:22,440
everyone to read the blog post you

00:03:20,580 --> 00:03:24,720
explain this in details here I will just

00:03:22,440 --> 00:03:27,540
have to to run over this because it's

00:03:24,720 --> 00:03:31,530
just a background to my to my work so in

00:03:27,540 --> 00:03:33,900
the spirit of model under a vm mq and

00:03:31,530 --> 00:03:35,970
new directives the via telnet on the

00:03:33,900 --> 00:03:38,040
high on the vm actually gives birth to a

00:03:35,970 --> 00:03:39,270
failover device so it's the only

00:03:38,040 --> 00:03:43,260
creature on earth that gives birth to

00:03:39,270 --> 00:03:45,660
his mother and it's an upper device and

00:03:43,260 --> 00:03:49,020
it was done that this way in purpose

00:03:45,660 --> 00:03:52,050
like we will look in the community and

00:03:49,020 --> 00:04:00,780
this work of course is of sweetheart

00:03:52,050 --> 00:04:03,710
from intel also here ah hi so so under

00:04:00,780 --> 00:04:08,190
vmm directive under a bit which a

00:04:03,710 --> 00:04:11,220
vertical feature bit the Vittorio device

00:04:08,190 --> 00:04:14,430
instantiate an upper device which is a

00:04:11,220 --> 00:04:16,560
special made simply bonding or teaming

00:04:14,430 --> 00:04:19,049
teaming creature

00:04:16,560 --> 00:04:21,630
okay and it again it was made it was

00:04:19,049 --> 00:04:23,820
made this way in purpose people were

00:04:21,630 --> 00:04:26,040
looking for a solution which is zero

00:04:23,820 --> 00:04:27,210
touch from the VM application standpoint

00:04:26,040 --> 00:04:29,669
they don't

00:04:27,210 --> 00:04:32,190
see all this all this happening it's

00:04:29,669 --> 00:04:35,160
where the colonel goes up in the VM and

00:04:32,190 --> 00:04:37,349
there's the vio net they get hey you are

00:04:35,160 --> 00:04:39,960
now standby so they instantiate the

00:04:37,349 --> 00:04:42,599
upper device the failover device and and

00:04:39,960 --> 00:04:44,250
they put herself as the standby and the

00:04:42,599 --> 00:04:47,699
tricky part of it that there is a very

00:04:44,250 --> 00:04:49,830
simple criteria to hook the primary

00:04:47,699 --> 00:04:52,139
device the virtual function device into

00:04:49,830 --> 00:04:53,940
this fail of a scheme is just find

00:04:52,139 --> 00:04:56,639
another device on the system that has

00:04:53,940 --> 00:04:59,280
the same arc at rest that this is it so

00:04:56,639 --> 00:05:02,099
again the veldt IO device goes up

00:04:59,280 --> 00:05:04,110
instantiate a failover device and the

00:05:02,099 --> 00:05:06,300
failover device would hook the virtual

00:05:04,110 --> 00:05:09,030
function device if it has the same Mac

00:05:06,300 --> 00:05:10,500
and it was you and it would use it as

00:05:09,030 --> 00:05:13,229
long as it's up and running

00:05:10,500 --> 00:05:15,360
if the vs if the virtual function device

00:05:13,229 --> 00:05:17,699
is hot unplug it out as we'll see in a

00:05:15,360 --> 00:05:19,500
minute for in live migration or if it

00:05:17,699 --> 00:05:21,960
doesn't have a carrier it goes back to

00:05:19,500 --> 00:05:24,780
the standby so again this is it very

00:05:21,960 --> 00:05:26,130
simple model and the VM the VM

00:05:24,780 --> 00:05:28,830
application the whole network is the

00:05:26,130 --> 00:05:30,750
stack of the VM like the IP address or

00:05:28,830 --> 00:05:34,139
whatever they bind to the upper device

00:05:30,750 --> 00:05:36,210
so that's the that's that's the guest

00:05:34,139 --> 00:05:38,039
side of thing and again in

00:05:36,210 --> 00:05:39,000
virtualization you always have a

00:05:38,039 --> 00:05:42,690
back-end

00:05:39,000 --> 00:05:45,150
in the hypervisor if it's very inert net

00:05:42,690 --> 00:05:48,599
so it's the classical backends of many

00:05:45,150 --> 00:05:51,810
types of devices McVie tap also in SRA

00:05:48,599 --> 00:05:53,340
of a small tweaking and what we're doing

00:05:51,810 --> 00:05:54,780
dealing with the switch death mode there

00:05:53,340 --> 00:05:57,000
is some software back-end in the

00:05:54,780 --> 00:05:59,250
hypervisor the representers which I'll

00:05:57,000 --> 00:06:01,320
explain later but it also has a hardware

00:05:59,250 --> 00:06:04,259
back-end so it's that's why it's a

00:06:01,320 --> 00:06:06,120
dashed line it's less more sophisticated

00:06:04,259 --> 00:06:08,580
so again this is just text that

00:06:06,120 --> 00:06:12,539
explained what I said we have a three

00:06:08,580 --> 00:06:16,590
native model and at the critera to hook

00:06:12,539 --> 00:06:19,800
so once we the system is up and running

00:06:16,590 --> 00:06:24,210
we have we have accelerated data past

00:06:19,800 --> 00:06:27,240
the VM is uses uses and this was

00:06:24,210 --> 00:06:30,719
introduced by her and company in it from

00:06:27,240 --> 00:06:32,550
Intel in fall 18 and he's starting to

00:06:30,719 --> 00:06:35,400
appear register in these drawers okay

00:06:32,550 --> 00:06:37,020
the standard bit was added to the

00:06:35,400 --> 00:06:39,630
virtual specification and we are waiting

00:06:37,020 --> 00:06:40,860
for the qmu

00:06:39,630 --> 00:06:42,270
patches pro that

00:06:40,860 --> 00:06:45,690
talking about my calendar in the break

00:06:42,270 --> 00:06:47,400
so this is a fairly new stuff and it's

00:06:45,690 --> 00:06:51,210
in VMs and now let's talk about the

00:06:47,400 --> 00:06:53,820
hypervisor so how how that once we have

00:06:51,210 --> 00:06:56,580
this built up generally speaking how

00:06:53,820 --> 00:07:00,090
would we want to use that in in live

00:06:56,580 --> 00:07:02,850
migration so as I said the idea is that

00:07:00,090 --> 00:07:05,610
because there is a net device that the

00:07:02,850 --> 00:07:08,610
whole VM Network stack sits on the upper

00:07:05,610 --> 00:07:10,830
device the failover device on the steady

00:07:08,610 --> 00:07:13,230
state we want to use that and when live

00:07:10,830 --> 00:07:15,510
migration start what we want to do is to

00:07:13,230 --> 00:07:18,900
unhurt unplug the virtual function the

00:07:15,510 --> 00:07:21,420
VM then the failover device would would

00:07:18,900 --> 00:07:23,430
go to use the the via telnet the power

00:07:21,420 --> 00:07:25,230
virtual nut Channel and live migration

00:07:23,430 --> 00:07:27,360
empower virtual are good friends for

00:07:25,230 --> 00:07:30,450
maybe 10 years or Moana right now so

00:07:27,360 --> 00:07:32,160
it's a solved problem okay so on the

00:07:30,450 --> 00:07:34,130
migrated or what I call the migrated out

00:07:32,160 --> 00:07:37,050
host when we start this live migration

00:07:34,130 --> 00:07:40,020
the hypervisor would unplug the virtual

00:07:37,050 --> 00:07:42,480
function the guest would do the failover

00:07:40,020 --> 00:07:44,970
to the standby and then the guest runs

00:07:42,480 --> 00:07:47,970
whisperer virtual now we can run live

00:07:44,970 --> 00:07:51,150
migration continue as usual in the

00:07:47,970 --> 00:07:54,630
migrate in host the the large migration

00:07:51,150 --> 00:07:59,640
is finalized and then the hypervisor hot

00:07:54,630 --> 00:08:01,320
plugs the VF and it can be in this case

00:07:59,640 --> 00:08:03,410
flexible it can be another via from

00:08:01,320 --> 00:08:06,240
another it doesn't have to be the same

00:08:03,410 --> 00:08:08,850
whatever it just has to be the same a

00:08:06,240 --> 00:08:10,950
criteria and then the guest runs again

00:08:08,850 --> 00:08:16,770
with the VF data pass ok so this is the

00:08:10,950 --> 00:08:18,720
basics of the of the idea how how how

00:08:16,770 --> 00:08:20,910
the VM sites looks and what the

00:08:18,720 --> 00:08:22,770
hypervisor has to do but there's

00:08:20,910 --> 00:08:24,630
something else the hypervisor I provide

00:08:22,770 --> 00:08:26,460
the highest to do and it deals with the

00:08:24,630 --> 00:08:29,360
with the switching with the virtual

00:08:26,460 --> 00:08:33,420
switching on the that has to do with my

00:08:29,360 --> 00:08:37,380
virtualization okay so what requirement

00:08:33,420 --> 00:08:40,140
we would we would pose for such scheme

00:08:37,380 --> 00:08:42,150
in the hypervisor of course we want to

00:08:40,140 --> 00:08:45,360
do we want to make sure that switching

00:08:42,150 --> 00:08:47,580
to into and out of the VM would be over

00:08:45,360 --> 00:08:49,260
the data path in action so if if we're

00:08:47,580 --> 00:08:50,940
in the steady state we want to go

00:08:49,260 --> 00:08:52,770
through the accelerator data path if we

00:08:50,940 --> 00:08:53,400
are during migration we want to go

00:08:52,770 --> 00:08:56,640
through the No

00:08:53,400 --> 00:08:58,890
accelerated at the pass okay because we

00:08:56,640 --> 00:09:01,230
are dealing with SR iov we have to take

00:08:58,890 --> 00:09:02,850
care of both of the virtual switch in

00:09:01,230 --> 00:09:07,590
the hypervisor and the embedded switch

00:09:02,850 --> 00:09:10,770
in the Nick okay we we wanted to climb a

00:09:07,590 --> 00:09:13,650
bit higher so we want to also support a

00:09:10,770 --> 00:09:17,220
hybrid and open setup so some VMs use

00:09:13,650 --> 00:09:20,300
this this stuff some VMs don't use this

00:09:17,220 --> 00:09:23,790
stuff so it's an open environment and

00:09:20,300 --> 00:09:26,190
for nikah for is which there are two

00:09:23,790 --> 00:09:28,560
approaches in in linux once it's there

00:09:26,190 --> 00:09:30,780
what we call the legacy mode we call

00:09:28,560 --> 00:09:36,350
this the switch dev mode so the legacy

00:09:30,780 --> 00:09:37,610
mode can still be used probably somehow

00:09:36,350 --> 00:09:39,840
[Music]

00:09:37,610 --> 00:09:42,210
maybe not addressing all the requirement

00:09:39,840 --> 00:09:44,640
but some of them and and I'm not going

00:09:42,210 --> 00:09:47,940
to explain it today this is a work by by

00:09:44,640 --> 00:09:51,170
Mitchell Michael and the Jen's and it's

00:09:47,940 --> 00:09:51,170
it's working

00:09:54,320 --> 00:10:01,590
once my slider but it's in the backup I

00:09:57,420 --> 00:10:03,120
won't go there you can you can see it

00:10:01,590 --> 00:10:06,600
and I will talk today about the switch

00:10:03,120 --> 00:10:08,310
dev mode so before how do I propose to

00:10:06,600 --> 00:10:11,250
do live migration and in the switch the

00:10:08,310 --> 00:10:15,980
mode before I'll do that I'll have a

00:10:11,250 --> 00:10:19,410
crashed reminder on the switch the mode

00:10:15,980 --> 00:10:22,410
so the thing in the and until in the

00:10:19,410 --> 00:10:24,960
switch EV mode for Rosario V is that we

00:10:22,410 --> 00:10:26,250
have representation in the hypervisor we

00:10:24,960 --> 00:10:28,470
have a software representation in the

00:10:26,250 --> 00:10:31,020
hypervisor for the port of the embedded

00:10:28,470 --> 00:10:33,270
switch so we linux everything is a

00:10:31,020 --> 00:10:36,660
native or if I don't know what so this

00:10:33,270 --> 00:10:38,940
representation is of course a device and

00:10:36,660 --> 00:10:41,700
and they resemble the the back in a way

00:10:38,940 --> 00:10:43,860
the back end the back end the devices

00:10:41,700 --> 00:10:48,030
that help our virtualization has you can

00:10:43,860 --> 00:10:51,990
plug them to virtual switch model and

00:10:48,030 --> 00:10:54,000
this representation used for both in

00:10:51,990 --> 00:10:58,590
this scheme when we say an offload a

00:10:54,000 --> 00:11:00,420
traffic we means that you have you have

00:10:58,590 --> 00:11:01,980
a virtual function run in a VM and you

00:11:00,420 --> 00:11:04,350
have embedded switch but sometimes the

00:11:01,980 --> 00:11:06,150
traffic do go through the hypervisor we

00:11:04,350 --> 00:11:06,840
refer to this traffic as the underflow

00:11:06,150 --> 00:11:08,520
dead one

00:11:06,840 --> 00:11:10,920
typically it's the first packet of a

00:11:08,520 --> 00:11:12,480
flow if you have a system such as

00:11:10,920 --> 00:11:14,970
obvious which is used as a normal rule

00:11:12,480 --> 00:11:16,620
and learning or or sometimes you don't

00:11:14,970 --> 00:11:18,510
offload all the traffic for instance you

00:11:16,620 --> 00:11:21,300
wanna you don't want to offload the ARB

00:11:18,510 --> 00:11:24,870
floods because they teach you stuff and

00:11:21,300 --> 00:11:27,150
the way to offload stuff which is common

00:11:24,870 --> 00:11:31,590
among multiple driver is through TC

00:11:27,150 --> 00:11:34,740
flower and this is upstream for few

00:11:31,590 --> 00:11:37,380
years by now since 2016 kind of for that

00:11:34,740 --> 00:11:41,310
eight and also there is some integration

00:11:37,380 --> 00:11:44,330
into obvious but also for two years by

00:11:41,310 --> 00:11:46,920
now in OpenStack in are your levels

00:11:44,330 --> 00:11:50,220
obvious contains a TC flower offloading

00:11:46,920 --> 00:11:53,190
library and it used by various distros

00:11:50,220 --> 00:11:54,360
and also the companies that here if

00:11:53,190 --> 00:11:56,640
instance Malick's we have a solution

00:11:54,360 --> 00:12:00,290
called a sub two or a sub squared and

00:11:56,640 --> 00:12:02,640
other versions have heavy too but this

00:12:00,290 --> 00:12:05,270
and my example of today would also use

00:12:02,640 --> 00:12:08,040
obvious but you can do it we have some

00:12:05,270 --> 00:12:10,130
some customers that use this scheme but

00:12:08,040 --> 00:12:13,650
without obvious they wrote their own

00:12:10,130 --> 00:12:15,720
libraries one thing that we did

00:12:13,650 --> 00:12:18,960
successful here is that we're not

00:12:15,720 --> 00:12:21,300
married to obviously we we use TC so you

00:12:18,960 --> 00:12:23,790
can people build the or can own solution

00:12:21,300 --> 00:12:27,660
they're using TC how this is how this

00:12:23,790 --> 00:12:32,580
looks like and this is a bit tricky and

00:12:27,660 --> 00:12:35,790
not super accurate diagram so you have

00:12:32,580 --> 00:12:39,600
the hardware is switch and the East

00:12:35,790 --> 00:12:43,560
which has those yellow half orange ports

00:12:39,600 --> 00:12:45,420
so each virtual function has their own

00:12:43,560 --> 00:12:46,980
port which are report one two and three

00:12:45,420 --> 00:12:51,840
in this example and you have the uplink

00:12:46,980 --> 00:12:54,120
port also the DPF has the report and

00:12:51,840 --> 00:12:55,380
this is the East which and what is

00:12:54,120 --> 00:12:57,120
called their obvious East which is what

00:12:55,380 --> 00:12:59,040
I'm referring here as which they switch

00:12:57,120 --> 00:13:01,950
over there you have the software

00:12:59,040 --> 00:13:03,960
representations which representers for

00:13:01,950 --> 00:13:06,920
all the the V port and there should be

00:13:03,960 --> 00:13:09,810
also represented for the uplink and and

00:13:06,920 --> 00:13:12,060
the tricky thing is that if traffic is

00:13:09,810 --> 00:13:13,830
offloaded it doesn't go to the software

00:13:12,060 --> 00:13:16,500
representation it's only on better

00:13:13,830 --> 00:13:19,830
switch but if a certain flow is on

00:13:16,500 --> 00:13:20,510
offloaded it it is hooked out from the

00:13:19,830 --> 00:13:24,170
embedded

00:13:20,510 --> 00:13:26,090
switch back to the virtual switch so the

00:13:24,170 --> 00:13:29,480
gain of all this is that in the end of

00:13:26,090 --> 00:13:31,160
the day the the virtual switch is except

00:13:29,480 --> 00:13:33,890
for this library that as the offloading

00:13:31,160 --> 00:13:35,570
is unaware because they keep using their

00:13:33,890 --> 00:13:38,270
own model where they have their switch

00:13:35,570 --> 00:13:39,650
and there are virtual ports in software

00:13:38,270 --> 00:13:42,170
presentation like they would do for

00:13:39,650 --> 00:13:44,480
virtual or for containers as was

00:13:42,170 --> 00:13:46,370
explained to Denny Vth environment so

00:13:44,480 --> 00:13:48,440
this is another build up I'm doing

00:13:46,370 --> 00:13:50,660
towards the the live migration I started

00:13:48,440 --> 00:13:52,520
with the VM side and then I explained

00:13:50,660 --> 00:13:56,480
how switch of mode looks on the

00:13:52,520 --> 00:13:58,250
hypervisor now I'm going to actually to

00:13:56,480 --> 00:14:00,380
the live migration I will talk about

00:13:58,250 --> 00:14:02,180
again some requirements we want to

00:14:00,380 --> 00:14:08,480
impose what is this is a suggestion

00:14:02,180 --> 00:14:10,970
solution and some more details so we

00:14:08,480 --> 00:14:12,740
want to use a model where one port

00:14:10,970 --> 00:14:16,130
represent the VM because the VM is a

00:14:12,740 --> 00:14:19,010
compute entity and we didn't want the

00:14:16,130 --> 00:14:21,290
model on the hypervisor to be actually

00:14:19,010 --> 00:14:23,450
the switch model on the hypervisor to be

00:14:21,290 --> 00:14:27,770
actually aware that there are two paths

00:14:23,450 --> 00:14:29,870
to go into this VM so we want we want we

00:14:27,770 --> 00:14:31,640
wanted it to be unmodified the the

00:14:29,870 --> 00:14:33,680
switch component for instance obvious

00:14:31,640 --> 00:14:36,680
whether we wanted them to see a single

00:14:33,680 --> 00:14:38,870
port that represents the VM even though

00:14:36,680 --> 00:14:41,060
there are two ways to go into the VM we

00:14:38,870 --> 00:14:44,330
wanted to support a hybrid setup and

00:14:41,060 --> 00:14:47,330
also we post another advanced

00:14:44,330 --> 00:14:49,640
requirement is that and this is also a

00:14:47,330 --> 00:14:51,790
bit confusing we wanted to support a

00:14:49,640 --> 00:14:54,080
small neck environment which is

00:14:51,790 --> 00:14:56,990
different from conventional a hypervisor

00:14:54,080 --> 00:14:59,030
environment because we said that an

00:14:56,990 --> 00:15:02,000
virtualization each channel to the VM

00:14:59,030 --> 00:15:03,830
has a back-end in the hypervisor so in

00:15:02,000 --> 00:15:05,780
smart NIC it's possible that the power

00:15:03,830 --> 00:15:08,570
will chose back end with reside on the

00:15:05,780 --> 00:15:11,300
host but the SR iov back end will reside

00:15:08,570 --> 00:15:12,800
on the semantics embedded CPU so we

00:15:11,300 --> 00:15:17,570
wanted to do something that eventually

00:15:12,800 --> 00:15:19,120
can also support this requirement ok so

00:15:17,570 --> 00:15:21,920
what is the suggested solution

00:15:19,120 --> 00:15:24,590
surprisingly we want to we actually

00:15:21,920 --> 00:15:27,650
suggest to bond the representations on

00:15:24,590 --> 00:15:31,930
the hypervisor and and stick this bonded

00:15:27,650 --> 00:15:34,210
port into the into the V switch ok

00:15:31,930 --> 00:15:36,040
once we do that from the standpoint of

00:15:34,210 --> 00:15:38,290
the V switch software for example of yes

00:15:36,040 --> 00:15:40,150
the flow based forwarding is applied

00:15:38,290 --> 00:15:42,370
over this port okay

00:15:40,150 --> 00:15:43,930
they see one probe that represent the VM

00:15:42,370 --> 00:15:45,700
they see packets coming and going from

00:15:43,930 --> 00:15:47,230
this port so they would treat this

00:15:45,700 --> 00:15:49,660
process the product represent the VM it

00:15:47,230 --> 00:15:53,140
applies applies their data pass rules

00:15:49,660 --> 00:15:54,670
with respect to this port okay and to

00:15:53,140 --> 00:15:57,490
address the second requirement of the

00:15:54,670 --> 00:16:00,580
smart NIC and so on we further made it

00:15:57,490 --> 00:16:04,150
complex we decided to use a second

00:16:00,580 --> 00:16:05,470
Hardware function other than the VL

00:16:04,150 --> 00:16:08,800
virtual function which is passed through

00:16:05,470 --> 00:16:13,300
to the VM and stitch it to connect it to

00:16:08,800 --> 00:16:16,290
the power of virtual back-end ok so how

00:16:13,300 --> 00:16:19,180
does it look like after we did all this

00:16:16,290 --> 00:16:20,830
crazy thing so again I'm looking on the

00:16:19,180 --> 00:16:23,710
left hand side you'll see one VM on the

00:16:20,830 --> 00:16:27,520
right that's 9 second VM so the probable

00:16:23,710 --> 00:16:30,430
the accelerated pass is actually ends up

00:16:27,520 --> 00:16:32,050
more simple because we have the VF which

00:16:30,430 --> 00:16:33,940
is pass through into device it has a

00:16:32,050 --> 00:16:35,500
dashed line to the representor because

00:16:33,940 --> 00:16:38,280
it's a dash because sometimes it goes to

00:16:35,500 --> 00:16:41,020
Hardware sometimes to software and this

00:16:38,280 --> 00:16:43,150
left represent au goes to a virtual

00:16:41,020 --> 00:16:44,590
function represent a bond on the right

00:16:43,150 --> 00:16:47,580
side we see the via telnet

00:16:44,590 --> 00:16:50,050
we used a Mac Vita which is a standard

00:16:47,580 --> 00:16:52,240
Vertov back-end but we use it in

00:16:50,050 --> 00:16:54,850
pass-through mode and we stitch it to a

00:16:52,240 --> 00:16:57,100
second Hardware function now to avoid

00:16:54,850 --> 00:16:59,140
further complication here let's assume

00:16:57,100 --> 00:17:01,300
that I'm using a second virtual function

00:16:59,140 --> 00:17:03,400
that I'm now imposing a requirement to

00:17:01,300 --> 00:17:06,220
actually allocate two virtual functions

00:17:03,400 --> 00:17:10,420
per VM yesterday we had the Hobby

00:17:06,220 --> 00:17:12,010
offload session and we actually made a

00:17:10,420 --> 00:17:14,589
proposal of a lightweight Hardware

00:17:12,010 --> 00:17:16,600
functions but it's irrelevant to

00:17:14,589 --> 00:17:18,010
understand this of today so I prefer to

00:17:16,600 --> 00:17:20,020
use a virtual function here which is the

00:17:18,010 --> 00:17:22,330
term that people are aware so this

00:17:20,020 --> 00:17:24,790
design suggest to use two virtual

00:17:22,330 --> 00:17:27,130
functions per VM one for the VM

00:17:24,790 --> 00:17:28,990
accelerated path and one for the VM a

00:17:27,130 --> 00:17:31,420
non accelerated path but on the

00:17:28,990 --> 00:17:33,370
hypervisor this virtual function has

00:17:31,420 --> 00:17:35,710
also represented and we burned both of

00:17:33,370 --> 00:17:37,750
them ok so what we see on the left side

00:17:35,710 --> 00:17:39,220
we see one virtual function represent

00:17:37,750 --> 00:17:41,260
our bond on the right side another bond

00:17:39,220 --> 00:17:43,060
so these are two parts of the virtual

00:17:41,260 --> 00:17:45,510
switch and the third part is the uplink

00:17:43,060 --> 00:17:50,200
ok

00:17:45,510 --> 00:17:52,809
now just quickly why do we want to use

00:17:50,200 --> 00:18:01,440
the second harder function so this way

00:17:52,809 --> 00:18:06,520
we can as I said support smart Nick and

00:18:01,440 --> 00:18:08,409
but even before that because we did we

00:18:06,520 --> 00:18:11,650
did it so it's a bit of counterintuitive

00:18:08,409 --> 00:18:13,570
because we used acceleration in the

00:18:11,650 --> 00:18:16,840
hypervisor for the non accelerated data

00:18:13,570 --> 00:18:18,789
path from the standpoint of the of the

00:18:16,840 --> 00:18:20,860
if you if you think about how switching

00:18:18,789 --> 00:18:24,010
is done here it is always done in

00:18:20,860 --> 00:18:26,140
hardware even if you're doing live

00:18:24,010 --> 00:18:28,780
migration which is a bit confusing but

00:18:26,140 --> 00:18:31,150
it works so so so you don't have

00:18:28,780 --> 00:18:33,970
yesterday we had the hard offload

00:18:31,150 --> 00:18:36,010
session and there was some proposal from

00:18:33,970 --> 00:18:37,900
pitiful metronome on quality of service

00:18:36,010 --> 00:18:41,020
and he also explained the weird cases

00:18:37,900 --> 00:18:42,730
where you have a mixture of how two data

00:18:41,020 --> 00:18:45,789
pass and software data pass for a packet

00:18:42,730 --> 00:18:48,340
it's very confusing and not not working

00:18:45,789 --> 00:18:49,690
well so in this case you always the the

00:18:48,340 --> 00:18:52,299
switching is always done in hardware

00:18:49,690 --> 00:18:54,400
even if even during migration okay

00:18:52,299 --> 00:18:55,990
because there is a piece in holder which

00:18:54,400 --> 00:18:57,460
is tied to the hypervisor and this still

00:18:55,990 --> 00:19:01,179
works ok even though it's during a

00:18:57,460 --> 00:19:03,460
migration so that is why we decided to

00:19:01,179 --> 00:19:05,799
do this way again technically it's being

00:19:03,460 --> 00:19:07,390
done by Mac Vita pass-through mode and a

00:19:05,799 --> 00:19:09,520
second how to function in the and the

00:19:07,390 --> 00:19:12,030
Mac light up configuration is supported

00:19:09,520 --> 00:19:16,570
by standard libvirt

00:19:12,030 --> 00:19:21,280
and it can be lightweight one okay now

00:19:16,570 --> 00:19:23,620
how would this work in this case we use

00:19:21,280 --> 00:19:25,600
the standard bonding or teaming it

00:19:23,620 --> 00:19:29,200
doesn't have to be this special made 0

00:19:25,600 --> 00:19:31,030
touch fill of a model but again it's a

00:19:29,200 --> 00:19:35,320
simple variant of bonding it's the

00:19:31,030 --> 00:19:37,750
active backup one and of course what we

00:19:35,320 --> 00:19:40,480
want to do you want we want that this

00:19:37,750 --> 00:19:41,620
bonding has when live migration isn't in

00:19:40,480 --> 00:19:46,120
action with live formation is not

00:19:41,620 --> 00:19:47,980
running we want this bonding to to go

00:19:46,120 --> 00:19:49,750
the active the active side of the

00:19:47,980 --> 00:19:51,070
bonding in the active side of eventually

00:19:49,750 --> 00:19:53,320
switching after offloading which I'll

00:19:51,070 --> 00:19:55,750
explain will be the accelerated pass

00:19:53,320 --> 00:19:57,350
that the pass through VM the virtual

00:19:55,750 --> 00:19:59,929
function and what

00:19:57,350 --> 00:20:02,630
during migration Asda said the the

00:19:59,929 --> 00:20:06,860
provisioning software the QM you would

00:20:02,630 --> 00:20:08,990
unplug the virtual function they would

00:20:06,860 --> 00:20:11,120
unplug the virtual function from the VM

00:20:08,990 --> 00:20:13,100
the one on the left and then we want the

00:20:11,120 --> 00:20:15,770
bonding we want them to do two things

00:20:13,100 --> 00:20:18,049
actually we want them to unplug the

00:20:15,770 --> 00:20:20,090
virtual function the path of virtual

00:20:18,049 --> 00:20:21,919
function for the VM and we want them to

00:20:20,090 --> 00:20:24,080
give a kick to the bonding driver and

00:20:21,919 --> 00:20:26,030
say hey you should do the bonding

00:20:24,080 --> 00:20:30,140
instance say hey you should failover to

00:20:26,030 --> 00:20:32,150
the standby it can be also zero attach

00:20:30,140 --> 00:20:35,390
but it depends on the vendor femur

00:20:32,150 --> 00:20:37,400
if the thermal can emit an event to all

00:20:35,390 --> 00:20:40,309
the representor weather where the

00:20:37,400 --> 00:20:42,860
virtual function is untouched unplugged

00:20:40,309 --> 00:20:44,840
from the VM I would personally prefer

00:20:42,860 --> 00:20:47,840
not to count on vendor filmers and that

00:20:44,840 --> 00:20:48,830
rather patch the the hypervisor to do

00:20:47,840 --> 00:20:50,659
this bonding failover

00:20:48,830 --> 00:20:53,470
it's very simple because the IP person

00:20:50,659 --> 00:20:59,330
no they are doing live migration right

00:20:53,470 --> 00:21:01,130
and the slope as the slope as for this

00:20:59,330 --> 00:21:03,650
scheme would work as usual because slope

00:21:01,130 --> 00:21:05,390
s is softer so even though we forced

00:21:03,650 --> 00:21:06,980
this pass from how to truly represent oh

00:21:05,390 --> 00:21:11,270
and it goes through the bonding it's

00:21:06,980 --> 00:21:13,309
this is standard and and here comes the

00:21:11,270 --> 00:21:15,140
the the the essence of the thing how

00:21:13,309 --> 00:21:18,110
would the offloading look like so one

00:21:15,140 --> 00:21:20,270
thing we're in mind that flows our

00:21:18,110 --> 00:21:23,960
ingress so you always come into in a

00:21:20,270 --> 00:21:27,260
switch so ingress of basically made of a

00:21:23,960 --> 00:21:30,620
soft spot some matching manipulation and

00:21:27,260 --> 00:21:32,780
then forwarding okay so what we have to

00:21:30,620 --> 00:21:34,850
deal with is that we have to care when

00:21:32,780 --> 00:21:37,280
we look and how these flow looks so in

00:21:34,850 --> 00:21:40,900
the general case the source port is a is

00:21:37,280 --> 00:21:43,309
this bond bond that I described so the

00:21:40,900 --> 00:21:45,980
the virtual switch will configure the

00:21:43,309 --> 00:21:49,429
flow over the bond device and now you

00:21:45,980 --> 00:21:51,860
have to make sure because you cannot

00:21:49,429 --> 00:21:53,539
decide on the hardware you want to

00:21:51,860 --> 00:21:54,770
handle in the hypervisor the case where

00:21:53,539 --> 00:21:57,169
the VM would send you through the

00:21:54,770 --> 00:21:59,179
accelerated pass or the non accelerated

00:21:57,169 --> 00:22:01,010
pass you don't want to start let's say

00:21:59,179 --> 00:22:02,480
you have thousands or millions of flow

00:22:01,010 --> 00:22:06,080
you don't want to start reinstalling

00:22:02,480 --> 00:22:07,820
them you realize migration so

00:22:06,080 --> 00:22:09,650
you what we want to do is want to

00:22:07,820 --> 00:22:11,960
install the ingress flow on the bond and

00:22:09,650 --> 00:22:13,790
then configure it to the hardware in a

00:22:11,960 --> 00:22:17,300
way that it would work no matter from

00:22:13,790 --> 00:22:18,830
which channel it would come so TC in TC

00:22:17,300 --> 00:22:22,430
dance through something called TC block

00:22:18,830 --> 00:22:25,730
sharing the virtual switch obvious

00:22:22,430 --> 00:22:29,360
installed the flow on the on the bond

00:22:25,730 --> 00:22:31,430
device but before that when obvious sees

00:22:29,360 --> 00:22:35,330
this is also a patch in I suppose from

00:22:31,430 --> 00:22:37,760
John from metronym that obvious actually

00:22:35,330 --> 00:22:40,240
shows the TC blocks of the bond with the

00:22:37,760 --> 00:22:42,560
two lower devices and when you do that

00:22:40,240 --> 00:22:44,120
when you show the block between multiple

00:22:42,560 --> 00:22:46,250
devices you install the role on the

00:22:44,120 --> 00:22:48,080
block but it is replayed by the kernel

00:22:46,250 --> 00:22:52,280
to all the offloading drivers for the

00:22:48,080 --> 00:22:55,190
instances so this is one thing the other

00:22:52,280 --> 00:22:57,440
thing is that when you look on the

00:22:55,190 --> 00:23:01,390
destination of a flow if this

00:22:57,440 --> 00:23:03,950
destination is a bonded port we actually

00:23:01,390 --> 00:23:08,360
require from the hardware driver to

00:23:03,950 --> 00:23:10,640
properly support a simple H a lag port

00:23:08,360 --> 00:23:12,890
in their purchase virtual switch model

00:23:10,640 --> 00:23:15,410
so they could they could they could

00:23:12,890 --> 00:23:18,980
accept a flow that goes into a bond and

00:23:15,410 --> 00:23:21,860
realize that in practice in real time it

00:23:18,980 --> 00:23:25,670
can go through one of two V ports in

00:23:21,860 --> 00:23:27,680
their embedded switch and and when when

00:23:25,670 --> 00:23:31,120
the Lugg is being changed in from the

00:23:27,680 --> 00:23:33,890
active to the standby they should again

00:23:31,120 --> 00:23:36,230
smartly program that like a switch table

00:23:33,890 --> 00:23:39,410
that goes you have n flows going into a

00:23:36,230 --> 00:23:41,090
VM so you don't want to reinstall all

00:23:39,410 --> 00:23:43,040
the N flows during or emulation you want

00:23:41,090 --> 00:23:44,540
to do some you want to have there some

00:23:43,040 --> 00:23:46,520
table that either goes left or right

00:23:44,540 --> 00:23:48,830
okay and a during migration you just

00:23:46,520 --> 00:23:55,490
want to do one change on this table so

00:23:48,830 --> 00:23:58,730
this is done by the model which this is

00:23:55,490 --> 00:24:01,430
also exists done by the ml xsw guys a

00:23:58,730 --> 00:24:03,830
few years ago there is a vent called

00:24:01,430 --> 00:24:07,430
change lower estate for bonding so the

00:24:03,830 --> 00:24:11,060
offloading driver has to properly track

00:24:07,430 --> 00:24:16,040
this event and do the change when when

00:24:11,060 --> 00:24:19,450
the when the the hypervisor changes the

00:24:16,040 --> 00:24:21,250
the channel so so this is it so

00:24:19,450 --> 00:24:24,040
this is all supported in the core

00:24:21,250 --> 00:24:26,440
networking start we made it to work on

00:24:24,040 --> 00:24:30,549
ml x5 we had to do some patches mostly

00:24:26,440 --> 00:24:32,320
for the second part but also it's it's

00:24:30,549 --> 00:24:34,570
an open suggestion for other vendors

00:24:32,320 --> 00:24:36,910
there is no currently no change is

00:24:34,570 --> 00:24:40,809
required in the kernel other than on the

00:24:36,910 --> 00:24:44,860
offloading driver and hopefully other

00:24:40,809 --> 00:24:47,500
people do that so to summarize the the

00:24:44,860 --> 00:24:50,530
build up we use representor for both

00:24:47,500 --> 00:24:53,799
channels we apply bonding on the

00:24:50,530 --> 00:24:56,790
representation we set the bond as the VM

00:24:53,799 --> 00:24:59,559
data pass and then we do failover and

00:24:56,790 --> 00:25:02,080
the the tricky part is in the hardware

00:24:59,559 --> 00:25:06,630
driver to do this proper configuration

00:25:02,080 --> 00:25:06,630
for the ingress thing and increasing

00:25:06,990 --> 00:25:15,390
okay so okay thank a few questions if

00:25:12,850 --> 00:25:15,390
there are such

00:25:52,050 --> 00:25:56,740
so this is really good or I mean this is

00:25:55,150 --> 00:25:58,650
pretty much how we would have gone

00:25:56,740 --> 00:26:08,680
forward with the live migration stuff

00:25:58,650 --> 00:26:12,370
once we have switched a support so just

00:26:08,680 --> 00:26:14,230
don't break a schmuck villain the part

00:26:12,370 --> 00:26:16,120
that I didn't quite get is when we are

00:26:14,230 --> 00:26:18,220
doing the bond for the representers

00:26:16,120 --> 00:26:21,160
right adding your TC rules on the bond

00:26:18,220 --> 00:26:23,200
and you're saying that you you know the

00:26:21,160 --> 00:26:25,780
lower devices would get that TC rule

00:26:23,200 --> 00:26:28,630
depending on if you do if you share the

00:26:25,780 --> 00:26:33,130
TC block between the bond and the two

00:26:28,630 --> 00:26:35,200
representers you create a TC block and

00:26:33,130 --> 00:26:39,070
then you share it between all these

00:26:35,200 --> 00:26:43,000
three and then it's something nice work

00:26:39,070 --> 00:26:44,590
of jury thank you if that once you do

00:26:43,000 --> 00:26:46,840
that the binding typically when you

00:26:44,590 --> 00:26:48,730
install it TC role in the oldest so with

00:26:46,840 --> 00:26:50,740
so many examples in this conference of

00:26:48,730 --> 00:26:52,330
installing TC rule so will you would

00:26:50,740 --> 00:26:55,060
always create a queue disk on a device

00:26:52,330 --> 00:26:56,950
and then add the rule to the device now

00:26:55,060 --> 00:26:58,390
you read the role to the block and if

00:26:56,950 --> 00:27:00,610
you read the rule to the block the

00:26:58,390 --> 00:27:03,520
colonel is replaying the rule to all the

00:27:00,610 --> 00:27:05,230
devices involved in this block so so and

00:27:03,520 --> 00:27:07,030
then you're offloading driver needs to

00:27:05,230 --> 00:27:08,800
understand how to properly upload it

00:27:07,030 --> 00:27:10,540
into your hologram right because I mean

00:27:08,800 --> 00:27:12,520
you are going to keep one and active and

00:27:10,540 --> 00:27:14,770
the other in the failover mode so your

00:27:12,520 --> 00:27:16,360
driver has to make sure that you can do

00:27:14,770 --> 00:27:20,020
it in multiple ways typically on switch

00:27:16,360 --> 00:27:23,530
ASIC the blocking is more Pro is has a

00:27:20,020 --> 00:27:25,480
better suitable so you do not duplicate

00:27:23,530 --> 00:27:28,240
everything on Nick how do it's more

00:27:25,480 --> 00:27:29,800
tricky currently in the patches that I

00:27:28,240 --> 00:27:32,350
made it in am Alex five it was a naive

00:27:29,800 --> 00:27:35,050
approach to actually duplicate these

00:27:32,350 --> 00:27:36,790
rules the ingress side of them but you

00:27:35,050 --> 00:27:38,410
can also do it smartly we have a design

00:27:36,790 --> 00:27:40,810
to do it smartly without the application

00:27:38,410 --> 00:27:42,280
it depends on your firmware API if your

00:27:40,810 --> 00:27:45,730
framer api's allows you to define a

00:27:42,280 --> 00:27:47,170
block and then bind to this block this

00:27:45,730 --> 00:27:48,910
is it this is what you need because you

00:27:47,170 --> 00:27:51,850
want to support it no matter how it

00:27:48,910 --> 00:27:54,730
comes from the VM right yeah and I mean

00:27:51,850 --> 00:27:57,640
there is one more extension I don't know

00:27:54,730 --> 00:28:00,190
if you have thought about it because the

00:27:57,640 --> 00:28:04,300
Windows driver does this that instead of

00:28:00,190 --> 00:28:05,860
use when you do the flooding you have a

00:28:04,300 --> 00:28:07,240
broadcast or multicast packet coming in

00:28:05,860 --> 00:28:10,480
and it's coming in the slow path instead

00:28:07,240 --> 00:28:12,820
of injecting back into your Asura beam

00:28:10,480 --> 00:28:15,400
or the pass-through interface you can

00:28:12,820 --> 00:28:17,680
actually send it on okay so so again

00:28:15,400 --> 00:28:20,110
windows yes Windows has too few

00:28:17,680 --> 00:28:22,360
differences one they use like the wind

00:28:20,110 --> 00:28:25,030
windows power virtual rival right it's

00:28:22,360 --> 00:28:26,470
an Linux driver net VSC so they were

00:28:25,030 --> 00:28:28,330
guests in linux and they supported that

00:28:26,470 --> 00:28:30,550
we've spotted it before us but now we

00:28:28,330 --> 00:28:32,560
are fighting back so we need VC they

00:28:30,550 --> 00:28:34,870
used to native model and the VM and they

00:28:32,560 --> 00:28:37,570
also as you said sometimes also on the

00:28:34,870 --> 00:28:39,910
steady-state they use the accelerator

00:28:37,570 --> 00:28:44,200
pass but this is excuse me broken

00:28:39,910 --> 00:28:46,540
because it's indeed that also on the on

00:28:44,200 --> 00:28:48,100
the steady-state you can set packet from

00:28:46,540 --> 00:28:50,640
the VM to the hypervisor in two

00:28:48,100 --> 00:28:52,600
different ways right but how do you know

00:28:50,640 --> 00:29:02,620
in the hypervisor

00:28:52,600 --> 00:29:05,260
which mode like you don't have way to

00:29:02,620 --> 00:29:07,150
actually negotiate with the guest which

00:29:05,260 --> 00:29:10,180
channel is used only the guest knows

00:29:07,150 --> 00:29:14,860
that okay when in the steady state I

00:29:10,180 --> 00:29:16,750
mean okay yeah so so excuse me for

00:29:14,860 --> 00:29:18,730
fighting back but I don't think it's a

00:29:16,750 --> 00:29:21,670
big deal that they they like to send the

00:29:18,730 --> 00:29:25,210
ops from here and not from here yeah I

00:29:21,670 --> 00:29:26,710
mean and in our solution at least you're

00:29:25,210 --> 00:29:28,120
still going to in the slope at you are

00:29:26,710 --> 00:29:30,100
still going to go over the PCI bus

00:29:28,120 --> 00:29:32,020
because you're backing out the Mac so

00:29:30,100 --> 00:29:33,700
there isn't a benefit there but yeah I

00:29:32,020 --> 00:29:40,000
mean okay I just wanted to point out

00:29:33,700 --> 00:29:44,880
okay thank you the this solution can

00:29:40,000 --> 00:29:49,389
work with the hosts with our DMA traffic

00:29:44,880 --> 00:29:52,509
okay so thank you

00:29:49,389 --> 00:29:56,769
so this solution if we look on the VM

00:29:52,509 --> 00:29:59,230
side of thing it doesn't support our DMA

00:29:56,769 --> 00:30:03,129
because the failover is also only for

00:29:59,230 --> 00:30:05,590
TCP IP traffic okay what what this

00:30:03,129 --> 00:30:07,600
solution says that during migration new

00:30:05,590 --> 00:30:10,359
hot unplug the virtual function from the

00:30:07,600 --> 00:30:13,179
VM and then there are DMA connections

00:30:10,359 --> 00:30:16,179
are broken but it's still in practice

00:30:13,179 --> 00:30:19,450
you can still use it because many

00:30:16,179 --> 00:30:20,710
applications they don't use if you let's

00:30:19,450 --> 00:30:23,049
say you have a storage application in

00:30:20,710 --> 00:30:25,480
the VM you have typically you have some

00:30:23,049 --> 00:30:27,190
block layer or some shim layer that it

00:30:25,480 --> 00:30:29,769
runs over and these layers many times

00:30:27,190 --> 00:30:31,269
support on unplug so if you have a mount

00:30:29,769 --> 00:30:33,909
point in the VM which is built

00:30:31,269 --> 00:30:35,649
eventually over our DMA the mount will

00:30:33,909 --> 00:30:37,899
not be functional during migration but

00:30:35,649 --> 00:30:40,179
it will not die if your all DNA either

00:30:37,899 --> 00:30:46,230
knows to plug back and we assume the

00:30:40,179 --> 00:30:46,230

YouTube URL: https://www.youtube.com/watch?v=fcjfCRL8ldA


