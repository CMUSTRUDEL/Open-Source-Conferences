Title: Netdev 1.1 - nftables from ingress
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 2 - Thursday February 11, 2016
Description: 
	Pablo Neira Ayuso
February 2016
Captions: 
	00:00:00,709 --> 00:00:07,560
so just let's make a show introduction

00:00:04,319 --> 00:00:09,690
to NF tables tables is a network

00:00:07,560 --> 00:00:11,990
specifically little machine it's it's

00:00:09,690 --> 00:00:18,750
very extensible it currently supports

00:00:11,990 --> 00:00:20,189
addressing at 32 and 128-bit size in the

00:00:18,750 --> 00:00:22,230
research the register area is very

00:00:20,189 --> 00:00:25,769
basically a scratch pad area where you

00:00:22,230 --> 00:00:29,910
can play whatever information using to

00:00:25,769 --> 00:00:32,279
an alignment and we have a very simple

00:00:29,910 --> 00:00:34,920
white coat verification we don't pass

00:00:32,279 --> 00:00:40,579
pointers between our what I will define

00:00:34,920 --> 00:00:43,260
as expressions so these this keeps the

00:00:40,579 --> 00:00:45,390
vcore verification structure very simple

00:00:43,260 --> 00:00:46,860
in the sense that the worst-case thing

00:00:45,390 --> 00:00:52,079
that can happen if you are not using

00:00:46,860 --> 00:00:55,140
libraries and the the utilities and is

00:00:52,079 --> 00:00:57,300
that you mean yet just invalid values

00:00:55,140 --> 00:00:59,010
and the virtual machine is basically not

00:00:57,300 --> 00:01:05,720
going out not to do anything but it's

00:00:59,010 --> 00:01:08,010
not going to crush your kind of good so

00:01:05,720 --> 00:01:10,350
and if it was also comes with an

00:01:08,010 --> 00:01:12,390
indignant in front and in this case we

00:01:10,350 --> 00:01:15,720
implemented for an definitely we

00:01:12,390 --> 00:01:20,340
implemented a batch in support that

00:01:15,720 --> 00:01:22,790
allows us to send very large messages

00:01:20,340 --> 00:01:26,820
from user space to kernel space

00:01:22,790 --> 00:01:30,509
typically this batch message is a

00:01:26,820 --> 00:01:32,880
structure in a way that you can put put

00:01:30,509 --> 00:01:35,549
in all the table and change and all

00:01:32,880 --> 00:01:39,420
object definitions that I show you just

00:01:35,549 --> 00:01:43,290
the rafter and that big message with all

00:01:39,420 --> 00:01:46,259
those netlink messages so it's a big

00:01:43,290 --> 00:01:50,280
message without lots of nested nelly

00:01:46,259 --> 00:01:53,970
messages are barred from kernel space

00:01:50,280 --> 00:01:56,100
and then using that intermediate isn't

00:01:53,970 --> 00:01:58,380
that representation that tlv

00:01:56,100 --> 00:02:04,740
representationally netlink provides with

00:01:58,380 --> 00:02:09,229
we transform to we transform that to the

00:02:04,740 --> 00:02:09,229
internal of your presentation sorry

00:02:16,459 --> 00:02:25,980
and I think will be implements a two

00:02:19,980 --> 00:02:29,209
phase commit protocol so basically every

00:02:25,980 --> 00:02:33,209
update that you apply into your rule set

00:02:29,209 --> 00:02:37,739
it shows up on the packet path in our or

00:02:33,209 --> 00:02:39,780
known fashion so if processing a batch

00:02:37,739 --> 00:02:43,620
in between the batch there is some error

00:02:39,780 --> 00:02:45,269
for example some invalid parameter that

00:02:43,620 --> 00:02:48,390
has been passed to any of this

00:02:45,269 --> 00:02:52,140
prescience that built that builds the

00:02:48,390 --> 00:02:55,860
rule the batch processing is going to

00:02:52,140 --> 00:02:58,049
keep going searching for more errors and

00:02:55,860 --> 00:03:00,900
in one go is going to tell user space

00:02:58,049 --> 00:03:03,299
how many rules could not be applied so

00:03:00,900 --> 00:03:07,680
it's not it's not that on the first

00:03:03,299 --> 00:03:12,030
error we are going to bail out what else

00:03:07,680 --> 00:03:14,930
we also have better dynamic incremental

00:03:12,030 --> 00:03:20,700
update support and that better is

00:03:14,930 --> 00:03:24,840
related to with regard to IP tables so

00:03:20,700 --> 00:03:26,489
basically and it compared to the

00:03:24,840 --> 00:03:29,160
equitable representation we don't have a

00:03:26,489 --> 00:03:31,590
big binary blob but we have we are using

00:03:29,160 --> 00:03:34,380
a linked list to represent the rule set

00:03:31,590 --> 00:03:35,880
and so this allows us to resolve the

00:03:34,380 --> 00:03:39,079
problems that we have with it with Anna

00:03:35,880 --> 00:03:42,060
tables regarding is the state fulness of

00:03:39,079 --> 00:03:46,799
matches in targets that we have so now

00:03:42,060 --> 00:03:48,959
if you update your rule set all the

00:03:46,799 --> 00:03:51,420
remaining states in your rules are going

00:03:48,959 --> 00:03:53,700
to stay there inevitable there are some

00:03:51,420 --> 00:03:56,760
matches that are actually supporting the

00:03:53,700 --> 00:03:59,010
are keeping the states on updates but

00:03:56,760 --> 00:04:01,950
it's we are using it kind of clergy

00:03:59,010 --> 00:04:04,370
hacks to get this going such as passing

00:04:01,950 --> 00:04:08,340
and pointer to use the space then um a

00:04:04,370 --> 00:04:09,840
passing it back then expecting that that

00:04:08,340 --> 00:04:11,819
pointer is going to still go there I

00:04:09,840 --> 00:04:13,769
mean very nasty things just to keep

00:04:11,819 --> 00:04:22,510
states there with an X tables we don't

00:04:13,769 --> 00:04:25,550
need that anymore what else so

00:04:22,510 --> 00:04:29,630
we also are providing currently a user

00:04:25,550 --> 00:04:33,650
space library it's this library is the

00:04:29,630 --> 00:04:37,820
low level one is lib nft NL the analysis

00:04:33,650 --> 00:04:39,980
for netlink and we also have plans to

00:04:37,820 --> 00:04:43,390
provide a high level library this is the

00:04:39,980 --> 00:04:48,650
hybrid level library will be based on

00:04:43,390 --> 00:04:50,240
the nft the nft code so we are not we

00:04:48,650 --> 00:04:52,490
been discussed for a while this

00:04:50,240 --> 00:04:57,800
high-level library that will allow so

00:04:52,490 --> 00:05:00,650
stupid to to provide a more abstract

00:04:57,800 --> 00:05:02,810
representation that part of the absurd

00:05:00,650 --> 00:05:05,330
abstract representation I'm going to

00:05:02,810 --> 00:05:11,900
refer to eat in the next presentation

00:05:05,330 --> 00:05:14,090
about switch tabs support so so far we

00:05:11,900 --> 00:05:17,030
what we have available is a live in a

00:05:14,090 --> 00:05:19,640
tnl so it's basically a library that

00:05:17,030 --> 00:05:22,580
that that contains some helpers

00:05:19,640 --> 00:05:25,570
functions and basically match the

00:05:22,580 --> 00:05:34,790
objects that that we can create for from

00:05:25,570 --> 00:05:38,600
from user space and we also have the NFC

00:05:34,790 --> 00:05:46,250
common line tool this command line tool

00:05:38,600 --> 00:05:48,650
is provides also scripting comes with

00:05:46,250 --> 00:05:52,670
scripting support so that I show you in

00:05:48,650 --> 00:05:56,360
this presentation and also a interactive

00:05:52,670 --> 00:05:58,310
shell that is that doesn't have so far

00:05:56,360 --> 00:06:00,800
auto completion but there are already

00:05:58,310 --> 00:06:02,720
people interested in getting Donna that

00:06:00,800 --> 00:06:04,910
has them that have have certain patches

00:06:02,720 --> 00:06:06,980
to the mainly laser we we should we

00:06:04,910 --> 00:06:10,130
should soon have it so that that

00:06:06,980 --> 00:06:13,730
interactive shell is implemented is

00:06:10,130 --> 00:06:16,340
based on libre line and wait so if we

00:06:13,730 --> 00:06:17,690
add the missing code we should really

00:06:16,340 --> 00:06:23,470
take advantage of all the features that

00:06:17,690 --> 00:06:30,290
are available in the library what else

00:06:23,470 --> 00:06:33,319
so since linux kernel for the two we got

00:06:30,290 --> 00:06:37,229
any ingress who

00:06:33,319 --> 00:06:40,709
this English is obviously coming before

00:06:37,229 --> 00:06:43,589
the older / routing hooks that we had in

00:06:40,709 --> 00:06:48,299
FL tirso and it's happening from layer

00:06:43,589 --> 00:06:50,909
to it yes thereafter it's just after DC

00:06:48,299 --> 00:06:52,619
in the TC ingress hook provides

00:06:50,909 --> 00:06:55,789
transparent access to the oldest 18

00:06:52,619 --> 00:06:59,699
fission and petite potential we usage of

00:06:55,789 --> 00:07:02,579
other netfilter building blocks but that

00:06:59,699 --> 00:07:11,360
is not implemented so far but they they

00:07:02,579 --> 00:07:19,559
should learn anytime soon on the tree so

00:07:11,360 --> 00:07:21,829
what is how how is how does nft did uses

00:07:19,559 --> 00:07:24,989
place to work it's basically a kind of

00:07:21,829 --> 00:07:27,269
second Pilar so it's a compiler that

00:07:24,989 --> 00:07:29,309
that takes it takes an input from

00:07:27,269 --> 00:07:32,879
command line but can also take it from

00:07:29,309 --> 00:07:34,769
from a file so that all the content all

00:07:32,879 --> 00:07:37,259
the rules that I in that file our

00:07:34,769 --> 00:07:41,999
processes in in a patch so basically the

00:07:37,259 --> 00:07:44,399
the nft compiler it takes based on the

00:07:41,999 --> 00:07:50,099
syntax that you can see there it's this

00:07:44,399 --> 00:07:52,229
one means add a new rule to the net the

00:07:50,099 --> 00:07:56,849
family that is the one that we are going

00:07:52,229 --> 00:07:58,819
to focus in this tutorial and that is

00:07:56,849 --> 00:08:01,679
they want to provide the ingress hook so

00:07:58,819 --> 00:08:03,419
they're added to the table filter this

00:08:01,679 --> 00:08:07,379
this we i'm assuming already that i

00:08:03,419 --> 00:08:09,179
created a filter table i show you more

00:08:07,379 --> 00:08:15,769
information on the developed all on the

00:08:09,179 --> 00:08:19,499
objects just in a few minutes so these

00:08:15,769 --> 00:08:22,769
specifies the table and then we get the

00:08:19,499 --> 00:08:25,919
chain in this case days we assume there

00:08:22,769 --> 00:08:28,499
is already an ingress chain so then we

00:08:25,919 --> 00:08:31,499
matching the VLAN ID and an IP source

00:08:28,499 --> 00:08:33,870
address and then in case of matching be

00:08:31,499 --> 00:08:36,329
our update in a counter so this

00:08:33,870 --> 00:08:39,059
generates the following byte code is

00:08:36,329 --> 00:08:41,519
basically in first places we are in

00:08:39,059 --> 00:08:43,590
greece we can we have to validate the

00:08:41,519 --> 00:08:50,820
input interface

00:08:43,590 --> 00:08:57,060
is a ethernet interface then we check

00:08:50,820 --> 00:08:59,850
for the effort I on the in the other

00:08:57,060 --> 00:09:05,250
type in this case we look at the compare

00:08:59,850 --> 00:09:11,780
that says VLAN this ETA HP villain and

00:09:05,250 --> 00:09:11,780
then after that we are checking for the

00:09:11,990 --> 00:09:18,150
Davina ID there is a bit bitwise there

00:09:15,120 --> 00:09:20,880
on expression that this vice is

00:09:18,150 --> 00:09:24,780
basically taking the bits that we need

00:09:20,880 --> 00:09:29,370
to compare this is the 12 bits that

00:09:24,780 --> 00:09:32,070
represent the villa villa an ID and then

00:09:29,370 --> 00:09:35,610
we're comparing that with the villain ID

00:09:32,070 --> 00:09:39,290
number the ville already value and after

00:09:35,610 --> 00:09:47,640
that we check again in lynn layer if the

00:09:39,290 --> 00:09:53,160
next type is IP and then from the

00:09:47,640 --> 00:09:55,200
network offset we have basically with

00:09:53,160 --> 00:09:58,980
with the bitwise expression again we are

00:09:55,200 --> 00:10:01,320
getting we are getting rid of the bits

00:09:58,980 --> 00:10:05,400
that we don't want to compare based on

00:10:01,320 --> 00:10:10,710
this see IDR and then we compare it and

00:10:05,400 --> 00:10:12,480
then we apply the action so in the next

00:10:10,710 --> 00:10:16,530
day was the argon everything that is

00:10:12,480 --> 00:10:19,830
under this these square brackets are

00:10:16,530 --> 00:10:26,750
expressions so in this case we've got 1

00:10:19,830 --> 00:10:30,650
2 3 4 5 6 7 8 9 10 11 12 and 13

00:10:26,750 --> 00:10:32,880
expressions this we use the term

00:10:30,650 --> 00:10:34,860
expression all the time from Colonel

00:10:32,880 --> 00:10:37,860
spaceman from user space will make a

00:10:34,860 --> 00:10:44,670
distinction between expressions and

00:10:37,860 --> 00:10:47,880
statements so so what is nft do it as a

00:10:44,670 --> 00:10:51,390
compiler is from users basis is parsing

00:10:47,880 --> 00:10:54,690
the nft syntax it's generating the apps

00:10:51,390 --> 00:10:56,130
abstract syntax tree and then there is

00:10:54,690 --> 00:10:58,410
an evaluation instead

00:10:56,130 --> 00:11:00,810
just to validate that to make sure that

00:10:58,410 --> 00:11:02,940
all the information in that episode not

00:11:00,810 --> 00:11:06,660
that syntax representation that abstract

00:11:02,940 --> 00:11:08,310
representation is correct otherwise we

00:11:06,660 --> 00:11:10,680
have a second step to validate over

00:11:08,310 --> 00:11:14,280
allow to use a space in case there is

00:11:10,680 --> 00:11:16,890
something inconsistent so after the

00:11:14,280 --> 00:11:20,790
evaluation we get that decorated apps

00:11:16,890 --> 00:11:22,680
abstract syntax tree and then we compile

00:11:20,790 --> 00:11:26,130
it basically we generate regenerate the

00:11:22,680 --> 00:11:29,220
the bytecode in the link format and then

00:11:26,130 --> 00:11:31,800
we send into kernel space when

00:11:29,220 --> 00:11:37,170
retrieving the configuration what we do

00:11:31,800 --> 00:11:39,740
is this we get a nothing message then in

00:11:37,170 --> 00:11:43,230
link message is transformed back to the

00:11:39,740 --> 00:11:45,060
AST representation the user is that we

00:11:43,230 --> 00:11:47,070
call proposed process is basically a

00:11:45,060 --> 00:11:50,010
valuation step in the other direction

00:11:47,070 --> 00:11:53,190
and then we text if I the output so the

00:11:50,010 --> 00:11:56,420
user gets slightly with the user gets

00:11:53,190 --> 00:11:59,430
water body it has push into the corner

00:11:56,420 --> 00:12:03,330
so what obvious we we have in NS tables

00:11:59,430 --> 00:12:06,270
we have table change rules and so if we

00:12:03,330 --> 00:12:12,620
want to create a table in E in the net

00:12:06,270 --> 00:12:15,840
web internet the family so in this case

00:12:12,620 --> 00:12:20,510
I'm useful it's not a very useful name

00:12:15,840 --> 00:12:23,330
but just to emphasize on the fact that

00:12:20,510 --> 00:12:29,640
you can use any name for your tables now

00:12:23,330 --> 00:12:33,180
and this table is a container of Base

00:12:29,640 --> 00:12:35,910
chains and on-base chains and this this

00:12:33,180 --> 00:12:40,530
paste chains and on-base change oh they

00:12:35,910 --> 00:12:43,110
determine the the data path of the way

00:12:40,530 --> 00:12:50,520
the way the packets are are going to

00:12:43,110 --> 00:12:52,050
traverse the the rule set so the in on

00:12:50,520 --> 00:12:54,150
the second on the second item we have a

00:12:52,050 --> 00:12:57,330
neti add chains this is basically adding

00:12:54,150 --> 00:12:59,760
a chain for another family at the food

00:12:57,330 --> 00:13:04,890
table and the name of this chain is bar

00:12:59,760 --> 00:13:06,960
and then between the curly braces what

00:13:04,890 --> 00:13:09,089
you have is we define the time of chain

00:13:06,960 --> 00:13:11,550
in case of ingress with so far

00:13:09,089 --> 00:13:13,470
only have the filter type then we

00:13:11,550 --> 00:13:16,639
specify the hook that is ingress and

00:13:13,470 --> 00:13:21,240
then we have to indicate the device and

00:13:16,639 --> 00:13:25,100
then the priority really is a sign

00:13:21,240 --> 00:13:27,749
interior integer and the assignment air

00:13:25,100 --> 00:13:33,089
determines if you have more chains what

00:13:27,749 --> 00:13:38,370
the order and my- are placed before

00:13:33,089 --> 00:13:42,209
positive one and then this is just the

00:13:38,370 --> 00:13:44,069
answer item we can have we are just

00:13:42,209 --> 00:13:47,189
adding a simple rule to counter all

00:13:44,069 --> 00:13:49,800
traffic going through that chain we can

00:13:47,189 --> 00:13:53,040
you can also assign materials you can

00:13:49,800 --> 00:13:54,360
also define on based change don't

00:13:53,040 --> 00:13:56,550
normally change the main difference

00:13:54,360 --> 00:14:03,509
between on base chains and base change

00:13:56,550 --> 00:14:06,509
is that there is no this part here it's

00:14:03,509 --> 00:14:09,149
missing so we are not specifying the the

00:14:06,509 --> 00:14:12,180
hook point this these non base change

00:14:09,149 --> 00:14:16,920
don't see any traffic unless there is a

00:14:12,180 --> 00:14:20,069
rule indicating a jump or I go to action

00:14:16,920 --> 00:14:23,420
to them through the this jump basically

00:14:20,069 --> 00:14:26,100
we can implement the similar a similar

00:14:23,420 --> 00:14:29,429
behavior to with achieve by calling a

00:14:26,100 --> 00:14:33,059
function since the the jump into a chain

00:14:29,429 --> 00:14:35,610
means evaluate all those rules in that

00:14:33,059 --> 00:14:38,370
chain and then after that evaluation it

00:14:35,610 --> 00:14:43,490
goes back to the to do to the base

00:14:38,370 --> 00:14:50,579
change that keeps evaluating and then

00:14:43,490 --> 00:14:53,459
for us we have the we have the rules and

00:14:50,579 --> 00:14:59,429
rules are a composite of expressions

00:14:53,459 --> 00:15:03,230
this expressions and allows us to to

00:14:59,429 --> 00:15:05,879
match any payload and meet information

00:15:03,230 --> 00:15:09,509
all the operations are generic so

00:15:05,879 --> 00:15:13,769
basically any key that you want to to to

00:15:09,509 --> 00:15:15,959
use to defer to to search for matching

00:15:13,769 --> 00:15:19,430
you can you can use any any kind of key

00:15:15,959 --> 00:15:23,120
and any of these operations you get

00:15:19,430 --> 00:15:28,070
you can use the different than you can

00:15:23,120 --> 00:15:32,839
use arranged you can use lists greater

00:15:28,070 --> 00:15:37,970
than you can use also prefixes these

00:15:32,839 --> 00:15:40,220
prefixes you are not only not only for

00:15:37,970 --> 00:15:43,190
addresses you can also use them for meat

00:15:40,220 --> 00:15:46,930
information we can use bitwise

00:15:43,190 --> 00:15:50,149
operations comparisons and also we can

00:15:46,930 --> 00:15:52,060
set values but these set values that the

00:15:50,149 --> 00:15:54,830
one last example should not be there

00:15:52,060 --> 00:15:59,300
what we call it statements so the

00:15:54,830 --> 00:16:03,350
statements are in this case these are

00:15:59,300 --> 00:16:06,890
mmm these are I only provide to stem

00:16:03,350 --> 00:16:08,870
examples but the 4nf tables counters are

00:16:06,890 --> 00:16:12,770
also statements so what we have here is

00:16:08,870 --> 00:16:15,260
a we are sitting the mark value and we

00:16:12,770 --> 00:16:18,860
also in the second example what we are

00:16:15,260 --> 00:16:20,690
doing is that we are setting we are

00:16:18,860 --> 00:16:23,630
mangling the destination as an address

00:16:20,690 --> 00:16:27,350
so we also have the payload capability

00:16:23,630 --> 00:16:31,310
magnum capabilities we also have the set

00:16:27,350 --> 00:16:37,029
of maps so the first example shows how

00:16:31,310 --> 00:16:37,029
to shows how to

00:16:37,370 --> 00:16:46,980
and define a literal set little sets

00:16:41,459 --> 00:16:49,320
they they are specified between curly

00:16:46,980 --> 00:16:57,420
braces so basically what we have in this

00:16:49,320 --> 00:17:00,810
first rule is we add a we add a to the

00:16:57,420 --> 00:17:04,620
food table the chain bar we are adding a

00:17:00,810 --> 00:17:10,589
set for that is going to match this

00:17:04,620 --> 00:17:12,750
nation tcp ports or 20 to 80 and 443 and

00:17:10,589 --> 00:17:16,620
in case of matching it's going to pop a

00:17:12,750 --> 00:17:21,990
single counter and in case this this

00:17:16,620 --> 00:17:25,169
little sets cannot be updated so they

00:17:21,990 --> 00:17:28,169
are constant in case you need not

00:17:25,169 --> 00:17:31,350
dynamic updates for your sets do you

00:17:28,169 --> 00:17:34,320
have to declare set in this way so

00:17:31,350 --> 00:17:38,250
basically you have to specify to what

00:17:34,320 --> 00:17:42,990
table you want to what you want to add

00:17:38,250 --> 00:17:47,450
set set tables are the the objects

00:17:42,990 --> 00:17:51,570
higher in the area of objects so every

00:17:47,450 --> 00:17:57,000
every object is always is contained by a

00:17:51,570 --> 00:18:04,080
table ok so this white least object it

00:17:57,000 --> 00:18:09,360
contains single ipv4 addresses and and

00:18:04,080 --> 00:18:11,730
and basically here then we are adding a

00:18:09,360 --> 00:18:14,160
rule that indicates this indicates that

00:18:11,730 --> 00:18:18,330
we re-enroll to the nether family food

00:18:14,160 --> 00:18:21,809
chain bar food table sorry a bar chain

00:18:18,330 --> 00:18:24,419
and then the destination address is what

00:18:21,809 --> 00:18:28,440
is contained this ad means take the what

00:18:24,419 --> 00:18:31,250
is contained in this in this set

00:18:28,440 --> 00:18:36,510
declaration in the whitelist declaration

00:18:31,250 --> 00:18:39,510
then we have this um counter increment

00:18:36,510 --> 00:18:41,790
and then we are inserting the packet so

00:18:39,510 --> 00:18:45,419
how do we add an element to a set a

00:18:41,790 --> 00:18:46,540
simple way we use the element keyword so

00:18:45,419 --> 00:18:49,840
we are adding an element

00:18:46,540 --> 00:18:52,270
oh this should be this dose should be AP

00:18:49,840 --> 00:18:54,460
this would be net that sorry so not

00:18:52,270 --> 00:18:57,910
there foo and why at least and these two

00:18:54,460 --> 00:18:59,380
elements are out to the whitelist sad so

00:18:57,910 --> 00:19:04,720
initially it sets can be auntie of

00:18:59,380 --> 00:19:06,250
course and and in case we want to we can

00:19:04,720 --> 00:19:12,280
use the generic infrastructure available

00:19:06,250 --> 00:19:14,560
in sets to to provide to provide

00:19:12,280 --> 00:19:19,200
mappings how the mappings how this maps

00:19:14,560 --> 00:19:23,950
work so basically this room here it says

00:19:19,200 --> 00:19:27,880
duplicate traffic to a given IP source

00:19:23,950 --> 00:19:30,490
address this is also yeah this example

00:19:27,880 --> 00:19:33,640
is incorrect because um we should use

00:19:30,490 --> 00:19:36,730
two should be this should be we can use

00:19:33,640 --> 00:19:38,560
on a nice is correct sorry yes fine so i

00:19:36,730 --> 00:19:41,950
got confused so basically this is adding

00:19:38,560 --> 00:19:45,910
a rule that duplicates all traffic to

00:19:41,950 --> 00:19:48,940
given this nation based on the IP so i

00:19:45,910 --> 00:19:51,970
feel so happy source IP source address

00:19:48,940 --> 00:19:54,970
so if the episodes address is one dot

00:19:51,970 --> 00:19:57,880
one dot one is under this network set

00:19:54,970 --> 00:20:03,040
man the trophy is going to be duplicated

00:19:57,880 --> 00:20:04,750
to eth0 and in case is 20 to 20 in this

00:20:03,040 --> 00:20:08,890
network set man is going to be

00:20:04,750 --> 00:20:15,370
duplicated to 21 so potentially we can

00:20:08,890 --> 00:20:20,320
we can use any key for to provide these

00:20:15,370 --> 00:20:23,140
mappings and not only we also have this

00:20:20,320 --> 00:20:27,790
kind of maps the verdict maps 13 maps

00:20:23,140 --> 00:20:29,740
allows us to jump or to issue and

00:20:27,790 --> 00:20:33,580
verdict actions as such an excel ball

00:20:29,740 --> 00:20:38,500
drop to the matching packet it provides

00:20:33,580 --> 00:20:41,440
very very fast lookups so in this case

00:20:38,500 --> 00:20:45,760
we create to gnome 3 non-base chains at

00:20:41,440 --> 00:20:47,740
the net family table food the TCP chain

00:20:45,760 --> 00:20:52,450
EDP change icmp chain and

00:20:47,740 --> 00:20:58,780
these basically based on the IP protocol

00:20:52,450 --> 00:21:01,870
here in K so in case of matching TCP its

00:20:58,780 --> 00:21:09,309
jump into the TCP change so we can build

00:21:01,870 --> 00:21:11,380
a tree of change where since this is

00:21:09,309 --> 00:21:14,350
using the settings to structure finding

00:21:11,380 --> 00:21:17,470
the the jump should be very fast what

00:21:14,350 --> 00:21:24,940
else in sets we have set slight set

00:21:17,470 --> 00:21:29,679
timeouts and say timeouts they basically

00:21:24,940 --> 00:21:32,590
this a timeout consists of indicated the

00:21:29,679 --> 00:21:37,780
indicated indicate indeed the timeout up

00:21:32,590 --> 00:21:39,760
sorry the time out the timeout statement

00:21:37,780 --> 00:21:42,760
state this timeout statement basically

00:21:39,760 --> 00:21:44,800
indicates the the lifetime of the

00:21:42,760 --> 00:21:47,800
elements are going to be added to the

00:21:44,800 --> 00:21:51,760
set this is global thing so in this case

00:21:47,800 --> 00:21:54,190
with to the whitelist we are adding ipv4

00:21:51,760 --> 00:21:58,240
addresses and the lifetime for these

00:21:54,190 --> 00:22:01,390
elements is one hour so if we add these

00:21:58,240 --> 00:22:05,650
elements here through the element

00:22:01,390 --> 00:22:08,650
command what it happens that after that

00:22:05,650 --> 00:22:12,120
time they they expire we can also

00:22:08,650 --> 00:22:15,100
specify lifetime to the elements at a

00:22:12,120 --> 00:22:22,540
very often grain in am offering it

00:22:15,100 --> 00:22:25,150
anyway so if we use a flag timeout this

00:22:22,540 --> 00:22:27,490
flag allows us to indicate a lifetime of

00:22:25,150 --> 00:22:29,230
the element when we insert it so we can

00:22:27,490 --> 00:22:34,860
have different timeouts depending on the

00:22:29,230 --> 00:22:34,860
element you have any questions so far

00:22:37,400 --> 00:22:50,330
okay we can also add comments this

00:22:44,870 --> 00:22:52,340
comments are useful to to to remember

00:22:50,330 --> 00:22:57,800
the purpose of that rule or the element

00:22:52,340 --> 00:23:01,250
so in case that we in the first example

00:22:57,800 --> 00:23:04,430
above we are matching the cynacian

00:23:01,250 --> 00:23:05,930
address 8080 date 08 encounter we are

00:23:04,430 --> 00:23:08,060
increasing the counter accepting and

00:23:05,930 --> 00:23:10,280
then there is a comment the comments are

00:23:08,060 --> 00:23:14,630
also need to be placed always at the end

00:23:10,280 --> 00:23:16,490
of the rule and this is just reminded us

00:23:14,630 --> 00:23:20,770
that it's a role match in the google dns

00:23:16,490 --> 00:23:25,390
and we can also use these comments in in

00:23:20,770 --> 00:23:28,460
in the st. infrastructure basically we

00:23:25,390 --> 00:23:33,500
in this case we create a dns whiteley

00:23:28,460 --> 00:23:35,630
said and we added two elements included

00:23:33,500 --> 00:23:37,220
the comments because corresponding

00:23:35,630 --> 00:23:44,000
comments 1 different comment for each

00:23:37,220 --> 00:23:49,300
element another very powerful feature of

00:23:44,000 --> 00:23:49,300
NS tables are the concatenations so

00:23:49,420 --> 00:23:57,420
currently these concatenations are

00:23:52,340 --> 00:23:59,850
limited to a number of keys that have

00:23:57,420 --> 00:24:07,050
well defined data types so if you try to

00:23:59,850 --> 00:24:09,330
use them with with 85 but the generic

00:24:07,050 --> 00:24:11,490
integer data type I mean they are there

00:24:09,330 --> 00:24:16,440
are kids that rely in turn on the NF

00:24:11,490 --> 00:24:19,250
tables has the keys have a specific data

00:24:16,440 --> 00:24:22,770
type so we can validate the input data

00:24:19,250 --> 00:24:28,140
corresponds to tour de the key expects

00:24:22,770 --> 00:24:30,660
so country and there are something like

00:24:28,140 --> 00:24:32,880
16 data types and generate the tops are

00:24:30,660 --> 00:24:34,860
integer so this is not working for

00:24:32,880 --> 00:24:37,440
integer so far but it should be a matter

00:24:34,860 --> 00:24:38,850
of updating the user space code isn't

00:24:37,440 --> 00:24:43,680
it's not that we need an update on the

00:24:38,850 --> 00:24:45,210
kernel for that so the goal is that in

00:24:43,680 --> 00:24:48,930
the short run will have support for

00:24:45,210 --> 00:24:50,670
every every key and how this

00:24:48,930 --> 00:24:57,120
concatenation works is basically we use

00:24:50,670 --> 00:25:06,060
the dot the dot symbol and here we are

00:24:57,120 --> 00:25:08,990
adding is a rule to specify a a a a

00:25:06,060 --> 00:25:12,480
topple come up with three components

00:25:08,990 --> 00:25:16,020
basically these sores Ethernet ethernet

00:25:12,480 --> 00:25:18,750
address the IP source address and the

00:25:16,020 --> 00:25:21,360
TCP destination so all the elements in

00:25:18,750 --> 00:25:25,680
this every every every concatenation

00:25:21,360 --> 00:25:27,930
isn't is an unique element so in case of

00:25:25,680 --> 00:25:31,470
matching this source ethernet address

00:25:27,930 --> 00:25:34,440
these IP source address on this TCP port

00:25:31,470 --> 00:25:37,740
we can apply an action days we can also

00:25:34,440 --> 00:25:39,930
combine it with the verdict maps I mean

00:25:37,740 --> 00:25:41,910
every feature that I am showing in this

00:25:39,930 --> 00:25:43,670
tutorial can be combined or should be it

00:25:41,910 --> 00:25:46,860
should be possible to combine and

00:25:43,670 --> 00:25:49,230
limitations on this is we don't support

00:25:46,860 --> 00:25:52,530
some people ask me to ask for Rangers

00:25:49,230 --> 00:25:53,940
here but that's not that's not easy to

00:25:52,530 --> 00:25:57,080
implement we didn't find so far a nice

00:25:53,940 --> 00:25:57,080
way to make it so

00:26:01,789 --> 00:26:08,619
and we can also of course is

00:26:04,369 --> 00:26:16,639
concatenations in set declarations so

00:26:08,619 --> 00:26:19,639
these this declaration is negating that

00:26:16,639 --> 00:26:23,690
at the time that is going to the DB be

00:26:19,639 --> 00:26:26,119
set contains our topple with two

00:26:23,690 --> 00:26:32,019
component this Ethernet address address

00:26:26,119 --> 00:26:35,799
and the ipv4 address and then using the

00:26:32,019 --> 00:26:48,409
element command we can populate the the

00:26:35,799 --> 00:26:51,320
the reset statement well as i said we we

00:26:48,409 --> 00:26:53,179
are still working to run on finishing

00:26:51,320 --> 00:26:56,649
support for many of the other remaining

00:26:53,179 --> 00:26:59,869
building blocks the new filter already

00:26:56,649 --> 00:27:02,929
integrates so so far some of the

00:26:59,869 --> 00:27:07,009
statements we have apart from from the

00:27:02,929 --> 00:27:11,269
basic ones are for example the rate

00:27:07,009 --> 00:27:17,659
limit the first rule basically is

00:27:11,269 --> 00:27:19,729
matching on traffic data and we can also

00:27:17,659 --> 00:27:24,080
specify the ports parameter to indicate

00:27:19,729 --> 00:27:28,789
and be the number of parts that you can

00:27:24,080 --> 00:27:30,379
go over the limit and and also in the

00:27:28,789 --> 00:27:33,739
second in the second example we are

00:27:30,379 --> 00:27:36,099
showing instead of using the traffic

00:27:33,739 --> 00:27:41,289
data by using per packet a rate-limiting

00:27:36,099 --> 00:27:47,499
so in this case this this indicates that

00:27:41,289 --> 00:27:51,200
that we are we will be if matching four

00:27:47,499 --> 00:27:55,479
packets below this rate a ten packets

00:27:51,200 --> 00:27:58,759
per second and you can also use the over

00:27:55,479 --> 00:28:03,470
key word to indicate my to match when

00:27:58,759 --> 00:28:06,860
the limit is over the specified

00:28:03,470 --> 00:28:10,370
a traffic data or or a packet packet

00:28:06,860 --> 00:28:13,340
packets per second and to perform an

00:28:10,370 --> 00:28:15,679
action on van and we can also duplicate

00:28:13,340 --> 00:28:18,350
and forward traffic it can be very

00:28:15,679 --> 00:28:21,140
useful in case that we want to have a

00:28:18,350 --> 00:28:23,990
fast path to to pass packets from

00:28:21,140 --> 00:28:27,440
ingress 22 given destination to even

00:28:23,990 --> 00:28:29,600
container and the application for in

00:28:27,440 --> 00:28:33,320
case that you want to have a you want to

00:28:29,600 --> 00:28:36,799
inspect the traffic in a different in a

00:28:33,320 --> 00:28:47,080
different system or the difference

00:28:36,799 --> 00:28:52,190
nation to restore the rule set and

00:28:47,080 --> 00:28:55,340
basically what we have is oh this is

00:28:52,190 --> 00:28:58,580
this energy is this this is this is not

00:28:55,340 --> 00:29:00,500
right this thing okay this an empty is

00:28:58,580 --> 00:29:02,539
not required so it with you you have to

00:29:00,500 --> 00:29:04,070
the first line of your script should be

00:29:02,539 --> 00:29:06,169
flushed but also in case you want to

00:29:04,070 --> 00:29:09,650
make sure that there is no any know any

00:29:06,169 --> 00:29:11,539
object in your rule set before you apply

00:29:09,650 --> 00:29:15,650
the one that you want to do you're going

00:29:11,539 --> 00:29:19,059
to have in your file and this NFC lists

00:29:15,650 --> 00:29:22,580
this should be double double greater

00:29:19,059 --> 00:29:24,230
just to concatenate the the output of it

00:29:22,580 --> 00:29:26,480
another mistake effects it on the

00:29:24,230 --> 00:29:29,030
slidable publish so you have it

00:29:26,480 --> 00:29:30,320
correctly and and then in case that we

00:29:29,030 --> 00:29:32,960
want to restore the rules that we used

00:29:30,320 --> 00:29:36,980
in minus f everything that is passed

00:29:32,960 --> 00:29:43,130
through minus f is applying atomic

00:29:36,980 --> 00:29:46,250
fashion from the colonel and in case do

00:29:43,130 --> 00:29:52,010
you want to monitor updates you can use

00:29:46,250 --> 00:29:54,260
the monitor command ft and you can also

00:29:52,010 --> 00:29:58,940
filter based on the kind of objects that

00:29:54,260 --> 00:30:00,799
you're using so after this this quick

00:29:58,940 --> 00:30:03,320
presentation I'm going to make some like

00:30:00,799 --> 00:30:05,179
life examples it at times if the time

00:30:03,320 --> 00:30:08,150
allows so we also have support for

00:30:05,179 --> 00:30:09,710
scripting this scripting basically at

00:30:08,150 --> 00:30:12,740
the beginning of your file indicated

00:30:09,710 --> 00:30:14,390
this file is 4ft and then you can

00:30:12,740 --> 00:30:15,510
increase in case you want to include all

00:30:14,390 --> 00:30:17,400
the rule sets you have

00:30:15,510 --> 00:30:19,920
you have to use the include keyboard and

00:30:17,400 --> 00:30:23,640
then you can also define variables in

00:30:19,920 --> 00:30:26,100
this case it's a set composed of several

00:30:23,640 --> 00:30:28,950
elements but it could be also a single

00:30:26,100 --> 00:30:31,470
element and then when I front you're all

00:30:28,950 --> 00:30:35,250
set refer to these variables you all

00:30:31,470 --> 00:30:37,530
have to use the dollar and and also you

00:30:35,250 --> 00:30:39,510
can include comments so this is a very

00:30:37,530 --> 00:30:40,710
typical feature that uses has been

00:30:39,510 --> 00:30:42,950
requesting that they have been

00:30:40,710 --> 00:30:46,230
implemented in shell scripts in iptables

00:30:42,950 --> 00:30:48,330
but doing implemented this in chile

00:30:46,230 --> 00:30:52,980
scripts is problematic in the sense that

00:30:48,330 --> 00:30:56,220
you are basically defeating the the

00:30:52,980 --> 00:30:59,700
atomic the atomic rooster update speak

00:30:56,220 --> 00:31:02,430
because in a shell script all the rules

00:30:59,700 --> 00:31:04,830
will be applied one after another and I

00:31:02,430 --> 00:31:07,380
mean one rule you commit one rule you

00:31:04,830 --> 00:31:11,210
come in so so it's not going to show up

00:31:07,380 --> 00:31:22,770
in an atomic fashion to the packet path

00:31:11,210 --> 00:31:24,900
so and in case you you want to access

00:31:22,770 --> 00:31:27,540
the code i'll show you some code now so

00:31:24,900 --> 00:31:34,020
to show you you understand the basic the

00:31:27,540 --> 00:31:36,120
basic the basic internals of NF tables

00:31:34,020 --> 00:31:37,710
and the days also access you have access

00:31:36,120 --> 00:31:41,370
to the library the low-level library and

00:31:37,710 --> 00:31:43,500
nft and all these are in the get that

00:31:41,370 --> 00:31:46,860
photo dot are positive that we have a

00:31:43,500 --> 00:31:48,870
wiki page in case you want to contribute

00:31:46,860 --> 00:31:52,320
you can drop me a line and i'll create

00:31:48,870 --> 00:31:55,440
you an account and also we have a

00:31:52,320 --> 00:31:59,100
rampage and in case you find box and you

00:31:55,440 --> 00:32:03,180
can you get you can file them to book

00:31:59,100 --> 00:32:06,330
sale on each photo or so and now i'm

00:32:03,180 --> 00:32:14,690
going to show you a bit of code so what

00:32:06,330 --> 00:32:14,690
is the first

00:32:19,250 --> 00:32:32,270
okay first I need to connect I will

00:32:29,070 --> 00:32:32,270
increase the font now ok

00:32:43,140 --> 00:32:45,200
you

00:32:54,370 --> 00:32:59,840
Sisk

00:32:56,840 --> 00:32:59,840
ok

00:33:14,260 --> 00:33:18,390
so I'll show you from the three then

00:33:33,670 --> 00:33:41,130
so front front colonel basically we have

00:33:42,390 --> 00:33:51,070
we have the main the main file is NF

00:33:46,900 --> 00:33:53,140
tables API this well the two main fights

00:33:51,070 --> 00:33:57,670
are the NFC buzz API in a stable score

00:33:53,140 --> 00:34:00,360
these NS tables API implements the net

00:33:57,670 --> 00:34:02,770
be in front end and all the object

00:34:00,360 --> 00:34:07,030
generation and the comment on a warpath

00:34:02,770 --> 00:34:15,150
and and from core what you can find is

00:34:07,030 --> 00:34:18,850
basically the the the packet matching

00:34:15,150 --> 00:34:25,890
ending so let's see if this loads

00:34:18,850 --> 00:34:25,890
otherwise I'll fall back to my own copy

00:34:30,560 --> 00:34:45,060
it seems to today turn us all working

00:34:33,210 --> 00:34:49,470
it's not working fine good so so let's

00:34:45,060 --> 00:34:52,740
let's have a look at the function this

00:34:49,470 --> 00:34:55,860
nft do chain is the by classifying

00:34:52,740 --> 00:35:02,850
function so basically here what we have

00:34:55,860 --> 00:35:06,840
is we have Tracy in the new tracing the

00:35:02,850 --> 00:35:08,640
tracing code for the trace rules and

00:35:06,840 --> 00:35:11,280
matching that we also have support in F

00:35:08,640 --> 00:35:13,470
tables we have it into fashions we have

00:35:11,280 --> 00:35:15,480
the generic onion infrastructure that

00:35:13,470 --> 00:35:18,470
has been implemented advise the tracing

00:35:15,480 --> 00:35:21,090
through another link another one that is

00:35:18,470 --> 00:35:24,110
compatible with the one that I used to

00:35:21,090 --> 00:35:29,670
have in iptables and that is basically

00:35:24,110 --> 00:35:33,360
printing messages to the to the log to

00:35:29,670 --> 00:35:40,830
the log buffering so what we're doing

00:35:33,360 --> 00:35:43,500
here is that is initially we fetch the

00:35:40,830 --> 00:35:46,860
current we have to fetch the generation

00:35:43,500 --> 00:35:50,670
cursor this cursor indicates what is the

00:35:46,860 --> 00:35:53,730
current generation we have two possible

00:35:50,670 --> 00:35:57,300
generations the one risk current the one

00:35:53,730 --> 00:35:59,250
that is and that is in the past or in

00:35:57,300 --> 00:36:01,890
the future for that we use all the time

00:35:59,250 --> 00:36:04,700
the same same bit so with two with only

00:36:01,890 --> 00:36:07,290
two bits with be implemented generation

00:36:04,700 --> 00:36:10,550
infrastructure that we have so basically

00:36:07,290 --> 00:36:13,950
here we are iterating over over the the

00:36:10,550 --> 00:36:16,410
rule sets the rules set that the rules

00:36:13,950 --> 00:36:19,320
are attached to a chain in the unlikely

00:36:16,410 --> 00:36:21,570
case that the rule is inactive we skip

00:36:19,320 --> 00:36:26,460
it so in case that this is a rule that

00:36:21,570 --> 00:36:29,600
the user is performing and an update and

00:36:26,460 --> 00:36:34,200
it's not in the current generation

00:36:29,600 --> 00:36:37,710
otherwise and we iterate over the list

00:36:34,200 --> 00:36:42,450
of expressions that are part of our rule

00:36:37,710 --> 00:36:45,240
and we have here an optimization to to

00:36:42,450 --> 00:36:48,390
to perform comparison faster without

00:36:45,240 --> 00:36:53,700
using main compartment compare and and

00:36:48,390 --> 00:36:57,720
also to fetch short database is smaller

00:36:53,700 --> 00:37:02,540
than 24 bits and otherwise we fall back

00:36:57,720 --> 00:37:05,250
on the generic evaluation that that is

00:37:02,540 --> 00:37:07,320
that is part of the expression I'll show

00:37:05,250 --> 00:37:11,520
you I'll show you how expression looks

00:37:07,320 --> 00:37:14,310
like so basically expressions looks like

00:37:11,520 --> 00:37:18,830
let's have a look at the comparison so

00:37:14,310 --> 00:37:22,050
this is the comparison expression and

00:37:18,830 --> 00:37:24,930
this is the the binary layout of the

00:37:22,050 --> 00:37:26,910
comparison expression this is part of

00:37:24,930 --> 00:37:29,820
the rule is not exposed to use the space

00:37:26,910 --> 00:37:33,500
and then we have an eval function this

00:37:29,820 --> 00:37:35,790
advanced functions this is one function

00:37:33,500 --> 00:37:37,859
it's basically the one that is called

00:37:35,790 --> 00:37:41,040
from from the packet path in this case

00:37:37,859 --> 00:37:47,730
we are comparing just to make sure it

00:37:41,040 --> 00:37:50,300
just did for all these operations and in

00:37:47,730 --> 00:37:52,859
case of mid-match we just stopped

00:37:50,300 --> 00:37:59,420
searching for more matches in these in

00:37:52,859 --> 00:37:59,420
this rule so then after that we have the

00:37:59,839 --> 00:38:06,690
we have usually a unit code this any

00:38:02,970 --> 00:38:10,980
code it basically parses the netting

00:38:06,690 --> 00:38:15,230
attributes and and represent them into

00:38:10,980 --> 00:38:18,800
the binary in the internal binary layout

00:38:15,230 --> 00:38:22,109
and then we have a dump function just to

00:38:18,800 --> 00:38:26,940
do to put back information to use the

00:38:22,109 --> 00:38:30,780
spacing in case the users requests it

00:38:26,940 --> 00:38:37,430
requires a rule set and then we have

00:38:30,780 --> 00:38:42,750
this expression ops is true Easter this

00:38:37,430 --> 00:38:46,070
this expression this in this case we

00:38:42,750 --> 00:38:50,099
have a fast in it because we are using

00:38:46,070 --> 00:38:50,930
that is another cmp fast ops because we

00:38:50,099 --> 00:38:54,260
can open

00:38:50,930 --> 00:38:55,670
load overload expression so we one

00:38:54,260 --> 00:38:57,740
single expression half can have

00:38:55,670 --> 00:39:00,309
different flavors these different

00:38:57,740 --> 00:39:06,760
flavors are the timings through these

00:39:00,309 --> 00:39:09,890
select ops call back so this select ops

00:39:06,760 --> 00:39:12,290
operation dislike up based on what we

00:39:09,890 --> 00:39:16,010
get from from user space from the

00:39:12,290 --> 00:39:18,710
netting API it's going to decide what

00:39:16,010 --> 00:39:21,020
what implementation of the comparison is

00:39:18,710 --> 00:39:23,930
going to use in case that the comparison

00:39:21,020 --> 00:39:26,180
is the amount of data that we want to

00:39:23,930 --> 00:39:28,369
compare is less than you 32 we use the

00:39:26,180 --> 00:39:34,819
fast comparison otherwise we use men

00:39:28,369 --> 00:39:37,490
compared and this is the CMT type so we

00:39:34,819 --> 00:39:40,180
want we always have one expression type

00:39:37,490 --> 00:39:43,760
but a expression type can have multiple

00:39:40,180 --> 00:39:45,680
multiple operations and then basically

00:39:43,760 --> 00:39:47,420
what we have here is just the

00:39:45,680 --> 00:39:53,720
registration and unregister a shin of

00:39:47,420 --> 00:39:57,559
the expressions in k with ok going back

00:39:53,720 --> 00:40:01,099
to the to have a look at the API this

00:39:57,559 --> 00:40:06,079
implements the net link front end so we

00:40:01,099 --> 00:40:09,980
have infrastructure two to three user

00:40:06,079 --> 00:40:12,589
research families we currently have six

00:40:09,980 --> 00:40:15,200
families IPAB six we have inet family

00:40:12,589 --> 00:40:18,680
design it family a family that basically

00:40:15,200 --> 00:40:21,829
sees both ipv4 and ipv6 traffic's from

00:40:18,680 --> 00:40:24,920
any of the existing I before 96 hooks is

00:40:21,829 --> 00:40:29,630
there just to simplify configurations

00:40:24,920 --> 00:40:36,940
you for dual stack scenarios so we have

00:40:29,630 --> 00:40:41,650
ipv6 a bridge for for bridging we have a

00:40:36,940 --> 00:40:47,839
RP we have net Deb and I think I said

00:40:41,650 --> 00:40:49,250
everything ok so we have the

00:40:47,839 --> 00:40:50,740
infrastructure to look up for the

00:40:49,250 --> 00:40:53,680
families

00:40:50,740 --> 00:40:55,750
we have context and we here we have the

00:40:53,680 --> 00:40:58,420
transaction objects transaction object

00:40:55,750 --> 00:41:02,860
is basically allocating a destruction

00:40:58,420 --> 00:41:04,570
object is this stores the the message to

00:41:02,860 --> 00:41:06,550
type the last trigger the netting

00:41:04,570 --> 00:41:09,820
message type that has trigger this

00:41:06,550 --> 00:41:12,340
transaction and context information that

00:41:09,820 --> 00:41:14,950
is useful when we apply the rule so from

00:41:12,340 --> 00:41:17,050
the comic path we have also

00:41:14,950 --> 00:41:21,280
infrastructure to restore big chains and

00:41:17,050 --> 00:41:23,530
reissue them to unregister releaser who

00:41:21,280 --> 00:41:26,830
looks basically based change this one

00:41:23,530 --> 00:41:32,770
hook into the net filter infrastructure

00:41:26,830 --> 00:41:34,840
and lots of functions just to add delete

00:41:32,770 --> 00:41:38,619
objects we have this function that

00:41:34,840 --> 00:41:41,380
basically allows us to check if if the

00:41:38,619 --> 00:41:43,210
object is currently active is it is if

00:41:41,380 --> 00:41:46,869
the object will be active in the next

00:41:43,210 --> 00:41:48,130
generation if we have to if we want to

00:41:46,869 --> 00:41:49,600
activate the object in the next

00:41:48,130 --> 00:41:50,980
generation it won't activate it

00:41:49,600 --> 00:41:52,330
deactivated in the next generation

00:41:50,980 --> 00:41:56,859
basically this means that is going to be

00:41:52,330 --> 00:42:01,270
delete or in case we want to clear the

00:41:56,859 --> 00:42:05,590
generation mask once we have applied the

00:42:01,270 --> 00:42:08,140
rule set from the commit back as i said

00:42:05,590 --> 00:42:11,920
lots of functions to operate with

00:42:08,140 --> 00:42:18,300
objects and then we have we have the

00:42:11,920 --> 00:42:18,300
specific functions for to handle tables

00:42:18,990 --> 00:42:26,940
it's lots of quite a lot of boilerplate

00:42:21,510 --> 00:42:29,920
netting code just to just a scheme to

00:42:26,940 --> 00:42:31,660
avoid exposing the diviner layout and

00:42:29,920 --> 00:42:33,900
having more flexibility to change it in

00:42:31,660 --> 00:42:33,900
the future

00:42:33,950 --> 00:42:43,190
and what else I can show you so this is

00:42:39,530 --> 00:42:45,460
basically lots of net net decode I got

00:42:43,190 --> 00:42:49,040
straight forward to the comet face ok

00:42:45,460 --> 00:42:53,869
anibal face we don't have much more time

00:42:49,040 --> 00:42:57,430
ten minutes so oh so I got to show you

00:42:53,869 --> 00:43:00,770
the comet pass on the board path and

00:42:57,430 --> 00:43:12,230
then if you have any question you let me

00:43:00,770 --> 00:43:15,500
know so quick look ok so this is the

00:43:12,230 --> 00:43:17,450
committee the committee step so we have

00:43:15,500 --> 00:43:18,619
in the two phase commit protocol that we

00:43:17,450 --> 00:43:21,530
have basically we have a preparation

00:43:18,619 --> 00:43:24,790
phase and and and the activation phase

00:43:21,530 --> 00:43:27,650
the in the preparation phase we just

00:43:24,790 --> 00:43:30,560
create all the objects that we need to

00:43:27,650 --> 00:43:32,839
add or in case that they need to be they

00:43:30,560 --> 00:43:36,310
need to be deleted we we mark them we

00:43:32,839 --> 00:43:40,130
mark them as objects that will be that

00:43:36,310 --> 00:43:42,859
will be removed in the next generation

00:43:40,130 --> 00:43:44,720
ok so in preparation phase we are all

00:43:42,859 --> 00:43:48,380
the all the objects that we need and we

00:43:44,720 --> 00:43:50,030
also deactivate or mark for the

00:43:48,380 --> 00:43:53,380
activation in the next generation and

00:43:50,030 --> 00:43:58,790
basically we do is we take a copy of the

00:43:53,380 --> 00:44:00,109
next generation cursor and we use

00:43:58,790 --> 00:44:02,869
synchronous you to make sure that all

00:44:00,109 --> 00:44:08,380
packets has left previous generation

00:44:02,869 --> 00:44:11,710
before we start removing all objects and

00:44:08,380 --> 00:44:13,730
then we trade over the combat list too

00:44:11,710 --> 00:44:17,810
depending on the transaction title is

00:44:13,730 --> 00:44:19,260
based on the net link message type we

00:44:17,810 --> 00:44:23,160
are going to

00:44:19,260 --> 00:44:26,850
make effective the heat changes that we

00:44:23,160 --> 00:44:34,530
did in the preparation phase so this is

00:44:26,850 --> 00:44:39,860
basically in case of new rules we're

00:44:34,530 --> 00:44:42,330
just clearing clearing the generation

00:44:39,860 --> 00:44:45,180
generation mask notifying the rule

00:44:42,330 --> 00:44:49,940
through through net links with us and

00:44:45,180 --> 00:44:49,940
then destroying the transaction object

00:44:50,300 --> 00:44:57,840
we also have for the upward path in case

00:44:53,670 --> 00:45:00,690
that we have a object that is invalid or

00:44:57,840 --> 00:45:03,990
that is not that the colonel it doesn't

00:45:00,690 --> 00:45:09,480
it doesn't it doesn't go through the the

00:45:03,990 --> 00:45:11,700
colonel validation code or through the

00:45:09,480 --> 00:45:14,070
the net lien validation what it happens

00:45:11,700 --> 00:45:19,530
is that we have to undo what would with

00:45:14,070 --> 00:45:22,020
what we've done so in case of new rules

00:45:19,530 --> 00:45:23,610
for example what we did in the

00:45:22,020 --> 00:45:27,050
preparation phase is creating the rule

00:45:23,610 --> 00:45:32,040
object and certain it into the list so

00:45:27,050 --> 00:45:35,910
for the new rule what we have to do is

00:45:32,040 --> 00:45:41,430
we have to delete the rule object is not

00:45:35,910 --> 00:45:45,570
active and then later on after we have

00:45:41,430 --> 00:45:48,060
the aboard release phase where we get

00:45:45,570 --> 00:45:55,080
rid of all these memory areas by

00:45:48,060 --> 00:46:01,200
releasing them okay so basically with

00:45:55,080 --> 00:46:04,710
with the NF + f NF tables API we have

00:46:01,200 --> 00:46:07,620
the cornet in front and the NF tables

00:46:04,710 --> 00:46:10,140
core we have the packet matching engine

00:46:07,620 --> 00:46:12,870
and then we put it with the nft on the

00:46:10,140 --> 00:46:14,940
score and a given name we implement the

00:46:12,870 --> 00:46:16,290
expressions so the expressions to

00:46:14,940 --> 00:46:18,930
provide the instruction set for a

00:46:16,290 --> 00:46:20,820
beautiful machine and basically with all

00:46:18,930 --> 00:46:22,810
those components we have we have the

00:46:20,820 --> 00:46:27,520
tube we have we have all the

00:46:22,810 --> 00:46:29,830
machine of the NFP was provide so that's

00:46:27,520 --> 00:46:32,160
basically do you have do you have any

00:46:29,830 --> 00:46:32,160
question

00:46:44,069 --> 00:46:51,569
okay here he says we have five minutes

00:46:46,289 --> 00:46:56,239
more right okay okay if night if there

00:46:51,569 --> 00:46:56,239

YouTube URL: https://www.youtube.com/watch?v=Y3C1BvP2KN8


