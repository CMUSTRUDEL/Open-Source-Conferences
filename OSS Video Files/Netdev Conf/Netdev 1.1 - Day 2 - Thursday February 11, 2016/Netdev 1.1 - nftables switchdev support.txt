Title: Netdev 1.1 - nftables switchdev support
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 2 - Thursday February 11, 2016
Description: 
	Pablo Neira Ayuso
February 2016
Captions: 
	00:00:01,040 --> 00:00:06,450
so John and other people can have a look

00:00:04,230 --> 00:00:07,470
at in and provide feedback I got to

00:00:06,450 --> 00:00:08,849
provide some information all that

00:00:07,470 --> 00:00:10,860
internal representation to here in this

00:00:08,849 --> 00:00:12,809
in this presentation so basically the

00:00:10,860 --> 00:00:14,519
steps are if switch this is available

00:00:12,809 --> 00:00:15,870
from the comet path of netfilter that I

00:00:14,519 --> 00:00:18,270
did off and if tables i'll show you

00:00:15,870 --> 00:00:21,750
before is this is checked just just

00:00:18,270 --> 00:00:24,689
before committing the changes in

00:00:21,750 --> 00:00:30,480
software so if there is switched a super

00:00:24,689 --> 00:00:37,760
available we involve switch tab and then

00:00:30,480 --> 00:00:41,160
we enable the offload flag and then from

00:00:37,760 --> 00:00:43,350
from the switched function we are going

00:00:41,160 --> 00:00:47,899
to call we are what we are going to

00:00:43,350 --> 00:00:49,800
invoke the front-end normalization to

00:00:47,899 --> 00:00:51,930
obtain the intermediate representation

00:00:49,800 --> 00:00:53,699
and that it intermediate representation

00:00:51,930 --> 00:00:57,629
is going to be heavily based on n fables

00:00:53,699 --> 00:01:00,079
it's a setup it's a list of statements

00:00:57,629 --> 00:01:02,219
where you can fight expressions and

00:01:00,079 --> 00:01:05,760
there are helpless functions that you

00:01:02,219 --> 00:01:07,500
can use to walk over the tree and to

00:01:05,760 --> 00:01:11,130
generate the howl representation or to

00:01:07,500 --> 00:01:12,930
get it into hard work so how is this

00:01:11,130 --> 00:01:17,130
intermediate representation how does it

00:01:12,930 --> 00:01:19,200
look like so as a set similar model to

00:01:17,130 --> 00:01:24,509
what we have in userspace so this is

00:01:19,200 --> 00:01:26,040
what Patrick design time ago so just for

00:01:24,509 --> 00:01:28,670
matching the representation is very

00:01:26,040 --> 00:01:32,130
simple so if we have a want to match

00:01:28,670 --> 00:01:35,220
payload the payload is represented as on

00:01:32,130 --> 00:01:37,500
a base offset a length so on the we will

00:01:35,220 --> 00:01:38,939
have a relation relational expression

00:01:37,500 --> 00:01:42,479
and that relational expression on the

00:01:38,939 --> 00:01:44,909
left hand side has a has a plate load

00:01:42,479 --> 00:01:48,060
expression with this information based

00:01:44,909 --> 00:01:49,740
off to the left and on the left hands on

00:01:48,060 --> 00:01:53,250
the right hand side we get we get the

00:01:49,740 --> 00:01:55,439
value that we want to match and and all

00:01:53,250 --> 00:01:58,950
the validation of this input data

00:01:55,439 --> 00:02:00,960
happens from the corresponding front end

00:01:58,950 --> 00:02:03,390
in this case is any tables that is

00:02:00,960 --> 00:02:06,600
taking care that making sure that what

00:02:03,390 --> 00:02:08,450
we have it to already care of making

00:02:06,600 --> 00:02:10,520
sure that the payload is correct and

00:02:08,450 --> 00:02:12,020
also the value is man

00:02:10,520 --> 00:02:15,830
exactly the same left that we want to

00:02:12,020 --> 00:02:21,680
match and so all the kind of things that

00:02:15,830 --> 00:02:24,020
you usually need can be some bitwise

00:02:21,680 --> 00:02:26,090
operation in this case and example

00:02:24,020 --> 00:02:27,920
showing on the right side we have a

00:02:26,090 --> 00:02:31,340
relational on the left hand side we have

00:02:27,920 --> 00:02:33,770
a binary operation it can be whatever

00:02:31,340 --> 00:02:36,650
bitwise operation that we D and then on

00:02:33,770 --> 00:02:39,260
the sign again we get the meter Demeter

00:02:36,650 --> 00:02:42,740
expression that will indicate with the

00:02:39,260 --> 00:02:45,740
label the net information that you want

00:02:42,740 --> 00:02:49,250
to match on the right hand side of the

00:02:45,740 --> 00:02:52,010
money operation what we get is is the

00:02:49,250 --> 00:02:54,020
value that will be used to perform the

00:02:52,010 --> 00:02:56,960
bitwise operation and on the right hand

00:02:54,020 --> 00:02:59,570
side of the relational operation of the

00:02:56,960 --> 00:03:01,400
relational expressions sorry what we

00:02:59,570 --> 00:03:06,560
have is the value that we want to match

00:03:01,400 --> 00:03:10,040
so the idea is this is this is for for a

00:03:06,560 --> 00:03:12,140
matching payload or meet information

00:03:10,040 --> 00:03:15,250
will have this kind of stuff we also

00:03:12,140 --> 00:03:20,090
have expression to represent our prefix

00:03:15,250 --> 00:03:22,220
also to represent our range and so with

00:03:20,090 --> 00:03:24,590
with this with this thing it should be

00:03:22,220 --> 00:03:27,320
possible to represent the common they

00:03:24,590 --> 00:03:30,620
come on matching operations of our

00:03:27,320 --> 00:03:37,300
perform only on the on the packet

00:03:30,620 --> 00:03:40,580
weather payload or meet information so

00:03:37,300 --> 00:03:43,820
the existing expressions available the a

00:03:40,580 --> 00:03:46,820
is T stands for absurd abstract syntax

00:03:43,820 --> 00:03:52,160
tree so we have a relational value meet

00:03:46,820 --> 00:03:55,310
up a load binary operation and this is

00:03:52,160 --> 00:03:57,470
this is the how the expression looks

00:03:55,310 --> 00:04:00,650
like basically we have a type of

00:03:57,470 --> 00:04:03,590
expression that is basically one of this

00:04:00,650 --> 00:04:06,860
possible one of these in the

00:04:03,590 --> 00:04:09,920
distillation and then we have operation

00:04:06,860 --> 00:04:12,650
cease operations indicate in case is in

00:04:09,920 --> 00:04:14,360
case it's a relational we indicate what

00:04:12,650 --> 00:04:16,579
kind of relational is if it's a

00:04:14,360 --> 00:04:22,280
comparison is greater than its

00:04:16,579 --> 00:04:26,599
stan is it's a and or X or whatever then

00:04:22,280 --> 00:04:31,960
we have a field that is unique to all

00:04:26,599 --> 00:04:34,099
all expressions that is length and then

00:04:31,960 --> 00:04:36,139
the possible expression that we have as

00:04:34,099 --> 00:04:38,780
we said we have a value we have meet up

00:04:36,139 --> 00:04:41,360
a load relational binary operation so

00:04:38,780 --> 00:04:44,060
the available the value is just a

00:04:41,360 --> 00:04:47,629
structure currently is an ft data and

00:04:44,060 --> 00:04:51,409
then NFC data is it's just in a country

00:04:47,629 --> 00:04:53,240
is a array of 128 where is the maximum

00:04:51,409 --> 00:04:54,889
length that we can use to address data

00:04:53,240 --> 00:04:57,050
in ennis tables but this could be any

00:04:54,889 --> 00:04:59,870
arbitrary amount of data every any

00:04:57,050 --> 00:05:02,389
arbitrary length then we have a meter

00:04:59,870 --> 00:05:04,099
that we have an enumeration in this case

00:05:02,389 --> 00:05:05,840
we are using the nft eliminations

00:05:04,099 --> 00:05:08,090
already but could be could be

00:05:05,840 --> 00:05:09,889
generalized so we have a enumeration

00:05:08,090 --> 00:05:12,529
with with all the meeting information

00:05:09,889 --> 00:05:15,889
aires that week a couple of matching

00:05:12,529 --> 00:05:20,690
from an other front s not all enf tables

00:05:15,889 --> 00:05:23,330
and then we have the payload that

00:05:20,690 --> 00:05:27,169
indicates base and upset the length we

00:05:23,330 --> 00:05:29,960
have it here above already and in case

00:05:27,169 --> 00:05:31,460
of relational or binary operation we

00:05:29,960 --> 00:05:35,900
have a left-hand side and right hand

00:05:31,460 --> 00:05:42,500
side so it's appointed to to to to

00:05:35,900 --> 00:05:44,240
another another expression so these

00:05:42,500 --> 00:05:48,229
expressions as i said we use them for

00:05:44,240 --> 00:05:49,400
matching but for actions we have any net

00:05:48,229 --> 00:05:51,740
sales we have what we call the

00:05:49,400 --> 00:05:53,779
statements and and basically the

00:05:51,740 --> 00:05:55,520
statement expression is an in a

00:05:53,779 --> 00:05:58,550
statement that he used to match that is

00:05:55,520 --> 00:06:01,490
built based on an expression good then

00:05:58,550 --> 00:06:04,000
we have the pillow the statement on the

00:06:01,490 --> 00:06:07,419
meet a statement these are these are

00:06:04,000 --> 00:06:11,240
specifically the purpose of these are

00:06:07,419 --> 00:06:13,940
they are designed to mangle payload or

00:06:11,240 --> 00:06:16,339
meet information so we have a steamin

00:06:13,940 --> 00:06:19,430
expression for matching payload and

00:06:16,339 --> 00:06:23,000
meter and we have the payload statement

00:06:19,430 --> 00:06:26,209
to mangle payload and pale and meet a

00:06:23,000 --> 00:06:28,169
statement to modify the meat information

00:06:26,209 --> 00:06:29,849
and

00:06:28,169 --> 00:06:31,740
in this case we only support so far in

00:06:29,849 --> 00:06:33,090
my batt said I also board to two

00:06:31,740 --> 00:06:34,979
possible actions that are counter or

00:06:33,090 --> 00:06:36,960
verdict but we could have we could add

00:06:34,979 --> 00:06:42,990
more action there that can be mapped

00:06:36,960 --> 00:06:44,699
into hardware so and how does the this

00:06:42,990 --> 00:06:47,400
statement looks like is basically at

00:06:44,699 --> 00:06:51,740
least because the the tree is

00:06:47,400 --> 00:06:54,029
implemented as a tree of statements

00:06:51,740 --> 00:06:56,999
absolute help statements and then we

00:06:54,029 --> 00:06:59,610
have a statement time the semi time

00:06:56,999 --> 00:07:03,659
indicates the the enemy rate that is

00:06:59,610 --> 00:07:05,789
numeration these variables and then we

00:07:03,659 --> 00:07:08,999
have in this case I have a pointer to

00:07:05,789 --> 00:07:11,909
the expression but we will have also in

00:07:08,999 --> 00:07:14,669
case it's a pillow pillow the statement

00:07:11,909 --> 00:07:17,089
made a statement counter whatever and we

00:07:14,669 --> 00:07:19,199
have the definition of those of the

00:07:17,089 --> 00:07:23,430
information that those statement has to

00:07:19,199 --> 00:07:25,050
store there okay so now after this what

00:07:23,430 --> 00:07:27,719
we have is as I said at least of

00:07:25,050 --> 00:07:30,689
statement and this statement can be a

00:07:27,719 --> 00:07:32,610
statement of expression kind that

00:07:30,689 --> 00:07:35,610
contains the tree that specify what we

00:07:32,610 --> 00:07:37,860
want to match and then another statement

00:07:35,610 --> 00:07:39,930
with probably again another expression

00:07:37,860 --> 00:07:41,879
indicating what we want to match pelo

00:07:39,930 --> 00:07:44,699
the meter and they're probably another

00:07:41,879 --> 00:07:46,229
statement that indicates the action that

00:07:44,699 --> 00:07:48,149
we walk to phone the packet and then

00:07:46,229 --> 00:07:49,789
again if there is another action to

00:07:48,149 --> 00:07:54,810
perform that is not terminal another

00:07:49,789 --> 00:07:57,080
action to be done good so we have

00:07:54,810 --> 00:08:00,270
functions to allocate expressions

00:07:57,080 --> 00:08:03,970
indicating the the expression type to

00:08:00,270 --> 00:08:06,920
destroy them and we have also

00:08:03,970 --> 00:08:08,870
functions do to allocate the statements

00:08:06,920 --> 00:08:11,570
and release the list of statements this

00:08:08,870 --> 00:08:13,270
is what I need so far in my pad set then

00:08:11,570 --> 00:08:16,010
we have a function this nft to linearize

00:08:13,270 --> 00:08:18,230
this LF stated in your eyes is very

00:08:16,010 --> 00:08:20,350
similar to to the Middle East was sent

00:08:18,230 --> 00:08:22,730
as a patch would be part that is

00:08:20,350 --> 00:08:26,540
basically to this in a call back in DC

00:08:22,730 --> 00:08:31,970
that name I think was a oversee the name

00:08:26,540 --> 00:08:33,950
is in it you need output or what I

00:08:31,970 --> 00:08:35,720
forgot anyway and this is linearized

00:08:33,950 --> 00:08:37,160
function we are using the same

00:08:35,720 --> 00:08:38,960
definition that we use in NS tables

00:08:37,160 --> 00:08:40,850
could be different name we can find a

00:08:38,960 --> 00:08:44,750
different areas so basically the idea is

00:08:40,850 --> 00:08:47,060
that we pass a in the case on NF tables

00:08:44,750 --> 00:08:49,310
we we passed the rule the binary

00:08:47,060 --> 00:08:50,720
representation of the rule and that by

00:08:49,310 --> 00:08:54,470
the representation of the rule is what

00:08:50,720 --> 00:08:56,240
is going to be transformed to this

00:08:54,470 --> 00:09:01,300
intermediate representation that there's

00:08:56,240 --> 00:09:04,430
all results in a list of of statements

00:09:01,300 --> 00:09:06,590
so this is basically what we needed to

00:09:04,430 --> 00:09:08,420
add to the expressions expressions in

00:09:06,590 --> 00:09:11,390
the tables are basically the extensions

00:09:08,420 --> 00:09:16,760
so for every extension that I have is a

00:09:11,390 --> 00:09:19,880
new annealed linearized function that is

00:09:16,760 --> 00:09:22,610
going is basically going to two compared

00:09:19,880 --> 00:09:24,890
to convert that software representation

00:09:22,610 --> 00:09:27,290
in binary to the intermediate

00:09:24,890 --> 00:09:31,250
representation so we don't have we don't

00:09:27,290 --> 00:09:33,310
have that we didn't touch the we didn't

00:09:31,250 --> 00:09:35,690
mention the hardware presentation so far

00:09:33,310 --> 00:09:37,550
okay so this is more or less how looks

00:09:35,690 --> 00:09:42,730
like i have in my past half meter

00:09:37,550 --> 00:09:45,680
payload cmp bitwise and counter and also

00:09:42,730 --> 00:09:48,430
verdict and but other actions should be

00:09:45,680 --> 00:09:53,240
very easy i mean the statements are

00:09:48,430 --> 00:09:56,060
easier to to map so on the back end with

00:09:53,240 --> 00:09:59,330
part circle graph is represented through

00:09:56,060 --> 00:10:03,470
these and we basically in this case we

00:09:59,330 --> 00:10:07,720
only have two on this is only for the

00:10:03,470 --> 00:10:10,550
the expressions the other other other

00:10:07,720 --> 00:10:13,440
statements this is for matches

00:10:10,550 --> 00:10:17,220
protocol payload and meet information so

00:10:13,440 --> 00:10:21,329
we have a description that is this

00:10:17,220 --> 00:10:24,930
description specifies what the hardware

00:10:21,329 --> 00:10:27,000
can do and basically we will pass the

00:10:24,930 --> 00:10:30,449
base intermediate representation or

00:10:27,000 --> 00:10:32,610
syntax three and we will call the cold

00:10:30,449 --> 00:10:36,329
box we will involve the cold facts that

00:10:32,610 --> 00:10:44,730
are set in this description structures

00:10:36,329 --> 00:10:48,149
to to populate the the backend internal

00:10:44,730 --> 00:10:50,339
representation ok so the protocol

00:10:48,149 --> 00:10:52,440
description basically contain the base

00:10:50,339 --> 00:10:54,389
we are going to have a tree or protocol

00:10:52,440 --> 00:10:56,699
descriptions if you like if you look at

00:10:54,389 --> 00:10:58,860
here if you look here these protocols is

00:10:56,699 --> 00:11:01,410
any Rio of protocol description this is

00:10:58,860 --> 00:11:04,079
indicating the upper layer protocols up

00:11:01,410 --> 00:11:06,870
on this so the ice show you but the

00:11:04,079 --> 00:11:09,990
first structure define is that the base

00:11:06,870 --> 00:11:11,970
is link will be link layer and then that

00:11:09,990 --> 00:11:13,769
link layer would indicate what can be

00:11:11,970 --> 00:11:16,350
what can be on what is possible to have

00:11:13,769 --> 00:11:18,540
on top of all that leading the air and

00:11:16,350 --> 00:11:23,100
also indicated the protocol number type

00:11:18,540 --> 00:11:26,670
of that link layer okay so basically we

00:11:23,100 --> 00:11:29,069
build that three or so from link layer

00:11:26,670 --> 00:11:30,480
they will have network the definition of

00:11:29,069 --> 00:11:32,339
possible protocol that we have that we

00:11:30,480 --> 00:11:34,769
can find on the network layer and then

00:11:32,339 --> 00:11:37,050
later on the possible protocol that we

00:11:34,769 --> 00:11:42,269
can find on transport based on what we

00:11:37,050 --> 00:11:45,420
have on the network layer okay and at

00:11:42,269 --> 00:11:47,550
the same time we have I'll show you we

00:11:45,420 --> 00:11:49,529
have context we have this this structure

00:11:47,550 --> 00:11:53,160
i call it the state but probably will

00:11:49,529 --> 00:11:55,319
rename it to sit here x2 context this so

00:11:53,160 --> 00:12:02,040
this asked this a substantive tree

00:11:55,319 --> 00:12:05,189
expression is basically the the the

00:12:02,040 --> 00:12:08,189
expression the the statement expression

00:12:05,189 --> 00:12:12,360
that we want to represent in hardware

00:12:08,189 --> 00:12:16,529
and and this state is basically stores

00:12:12,360 --> 00:12:19,130
context so instead instead of in case

00:12:16,529 --> 00:12:22,850
when we have a rule we have different

00:12:19,130 --> 00:12:26,560
matches and probably one or more

00:12:22,850 --> 00:12:29,720
chance good so instead of transforming

00:12:26,560 --> 00:12:33,769
those matches individually into her

00:12:29,720 --> 00:12:35,149
representation well it's not not when we

00:12:33,769 --> 00:12:36,920
don't only do that we don't only do that

00:12:35,149 --> 00:12:40,149
internally we don't all you do that

00:12:36,920 --> 00:12:43,310
information I mean we we keep context we

00:12:40,149 --> 00:12:46,160
based on what we see we can annotate

00:12:43,310 --> 00:12:54,310
what what it makes sense to to have

00:12:46,160 --> 00:12:57,370
after I mean if let's say if I see a

00:12:54,310 --> 00:13:00,440
link layer matching a third type

00:12:57,370 --> 00:13:05,269
protocol and says IP what it makes sense

00:13:00,440 --> 00:13:08,420
to find next is an is any any possible

00:13:05,269 --> 00:13:11,779
IP IP matching otherwise it is not

00:13:08,420 --> 00:13:13,819
correct good so and and all these

00:13:11,779 --> 00:13:16,880
context information is stored there and

00:13:13,819 --> 00:13:20,089
it's it's basically global to to the

00:13:16,880 --> 00:13:23,600
hell rule that we are cheating into

00:13:20,089 --> 00:13:25,490
hardware so but the method the Middle

00:13:23,600 --> 00:13:29,149
East limited description is is way more

00:13:25,490 --> 00:13:31,279
simple we only have one single with a

00:13:29,149 --> 00:13:37,519
half a tree and we'll have the ideas to

00:13:31,279 --> 00:13:39,649
have a list of labels that identify all

00:13:37,519 --> 00:13:42,139
the information that can be that can be

00:13:39,649 --> 00:13:46,880
that is possible to modify into the

00:13:42,139 --> 00:13:51,130
power so these the context thing the

00:13:46,880 --> 00:13:54,139
state object that is local to the to the

00:13:51,130 --> 00:13:56,240
transformation that happens on when when

00:13:54,139 --> 00:14:00,019
we represented that roll into the

00:13:56,240 --> 00:14:04,540
hardware looks like these we have a

00:14:00,019 --> 00:14:06,949
pointer to the to the device device

00:14:04,540 --> 00:14:09,649
description we also have we have a

00:14:06,949 --> 00:14:13,069
pointer to the context this context as I

00:14:09,649 --> 00:14:16,339
said tell us and on the link layer it

00:14:13,069 --> 00:14:18,949
tell us the protocol out that we that we

00:14:16,339 --> 00:14:20,779
will that we got from user space on a

00:14:18,949 --> 00:14:23,750
link layer then if we use a space

00:14:20,779 --> 00:14:27,259
indicated network what kind of protocol

00:14:23,750 --> 00:14:31,309
on the network on a lower layer and then

00:14:27,259 --> 00:14:33,649
also TCP or in case so far it's limited

00:14:31,309 --> 00:14:34,550
to transport but if we could we could

00:14:33,649 --> 00:14:37,010
use this contest too

00:14:34,550 --> 00:14:39,790
stuck in case we have multiple headers

00:14:37,010 --> 00:14:44,000
tunnels header or whatever we could just

00:14:39,790 --> 00:14:47,240
generalize this context so it is we push

00:14:44,000 --> 00:14:49,779
into the stack of context the the

00:14:47,240 --> 00:14:53,510
protocols that we are seeing and then

00:14:49,779 --> 00:14:56,470
that tree that protocol tree tell us

00:14:53,510 --> 00:15:01,310
what is possible to find next right so

00:14:56,470 --> 00:15:03,560
and there is a function to transform

00:15:01,310 --> 00:15:06,670
basically this helper function it's

00:15:03,560 --> 00:15:10,070
going to walk the list of statements and

00:15:06,670 --> 00:15:12,290
base of the base protocol description

00:15:10,070 --> 00:15:15,589
every device has to have a base protocol

00:15:12,290 --> 00:15:18,170
description and we have a we have

00:15:15,589 --> 00:15:20,890
pointer to the to the structure that

00:15:18,170 --> 00:15:22,850
internally represents the hardware

00:15:20,890 --> 00:15:24,019
representation that halves did that it

00:15:22,850 --> 00:15:27,589
is the structure that we have to

00:15:24,019 --> 00:15:29,329
populate in hardware and there is

00:15:27,589 --> 00:15:31,519
another function to update context so

00:15:29,329 --> 00:15:34,760
based on the on the base so based on

00:15:31,519 --> 00:15:38,170
deck from the protocol where we that we

00:15:34,760 --> 00:15:41,630
have seen we we can update it indicated

00:15:38,170 --> 00:15:46,220
in this space this given base for this

00:15:41,630 --> 00:15:51,380
given protocol do update context the

00:15:46,220 --> 00:15:54,050
definition looks a bit like these so we

00:15:51,380 --> 00:15:57,290
have link layer for the link that your

00:15:54,050 --> 00:16:01,010
header for Ethernet then upon it we have

00:15:57,290 --> 00:16:03,829
ipv4 ipv6 and then so this is the

00:16:01,010 --> 00:16:06,050
protocol up on the link layer we have

00:16:03,829 --> 00:16:08,560
the cold but the function that that we

00:16:06,050 --> 00:16:12,020
invoked the function that we involved

00:16:08,560 --> 00:16:15,110
for parsing the internet protocol for

00:16:12,020 --> 00:16:22,339
transforming into hardware the ethernet

00:16:15,110 --> 00:16:29,000
protocol fields and then here we have

00:16:22,339 --> 00:16:31,370
the for the upper upper protocol IP and

00:16:29,000 --> 00:16:35,480
then here references to the definition

00:16:31,370 --> 00:16:38,050
of TCP UDP so this is how it from any

00:16:35,480 --> 00:16:41,540
tables basically the idea is to have a

00:16:38,050 --> 00:16:43,790
flag a new flag for change that indicate

00:16:41,540 --> 00:16:47,750
that this change is going to be

00:16:43,790 --> 00:16:50,540
uploaded to switch them and you object

00:16:47,750 --> 00:16:52,730
is switched up and then we are going to

00:16:50,540 --> 00:16:56,780
pass the ideas to pass that list of

00:16:52,730 --> 00:17:02,320
statements so the idea is that the

00:16:56,780 --> 00:17:05,990
driver uses the helper functions to walk

00:17:02,320 --> 00:17:08,300
that this small tree this list of

00:17:05,990 --> 00:17:12,350
statements and interpolate internal

00:17:08,300 --> 00:17:20,510
reputation I include the handle for the

00:17:12,350 --> 00:17:22,700
deletion case too and yes so basically

00:17:20,510 --> 00:17:24,560
from the committee path did he has to

00:17:22,700 --> 00:17:27,020
check as I said check if enough if

00:17:24,560 --> 00:17:28,820
switch tab is available call any stable

00:17:27,020 --> 00:17:31,430
comments which day before the software

00:17:28,820 --> 00:17:33,410
comp man just to make sure that see if

00:17:31,430 --> 00:17:35,150
the hardware has failed not normalize

00:17:33,410 --> 00:17:37,640
the NF tables software representation

00:17:35,150 --> 00:17:40,610
into the syntax DD the intermediate

00:17:37,640 --> 00:17:44,900
representation or AST abstracts industry

00:17:40,610 --> 00:17:47,000
or call it the way you prefer past that

00:17:44,900 --> 00:17:49,730
in turn intermediate representation as

00:17:47,000 --> 00:17:52,760
acid-treated object and then from the

00:17:49,730 --> 00:17:54,110
driver walk the internal representation

00:17:52,760 --> 00:17:56,750
tirmidhi eight representation i generate

00:17:54,110 --> 00:18:01,220
the hardware internal rotation so that's

00:17:56,750 --> 00:18:05,570
basically i'm closing to get to run out

00:18:01,220 --> 00:18:09,760
of time if you have any question can

00:18:05,570 --> 00:18:09,760
someone please pass the mic

00:18:12,890 --> 00:18:19,740
so you've implemented rocker back end

00:18:15,990 --> 00:18:23,340
for this yeah I'm wondering do you have

00:18:19,740 --> 00:18:25,830
any plans or Jenny start on doing it on

00:18:23,340 --> 00:18:27,810
real hardware like a real real-life test

00:18:25,830 --> 00:18:30,470
to see how well it matches up with the

00:18:27,810 --> 00:18:33,360
sort of thing that Hardware expects a

00:18:30,470 --> 00:18:34,950
very happy to work on any real Howard

00:18:33,360 --> 00:18:38,610
implementation to I mean so far what I

00:18:34,950 --> 00:18:42,270
have access is rocker so if someone

00:18:38,610 --> 00:18:56,970
provides access to any nails ib w it BB

00:18:42,270 --> 00:18:59,150
grade any other question thank you very

00:18:56,970 --> 00:18:59,150

YouTube URL: https://www.youtube.com/watch?v=_mpPvKsxOho


