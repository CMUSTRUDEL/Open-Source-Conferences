Title: Netdev 1.1 - Describing datapath processing from userspace policy
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 2 - Thursday February 11, 2016
Description: 
	Brenden Blanco, John Fastabend
February 2016
Captions: 
	00:00:00,469 --> 00:00:11,429
so I guess we're ready to start the the

00:00:06,420 --> 00:00:14,790
topic today is script describing data

00:00:11,429 --> 00:00:16,619
planes using user space policy my name

00:00:14,790 --> 00:00:20,420
is Brendan I'm going to talk a little

00:00:16,619 --> 00:00:23,539
bit about some work that we've done

00:00:20,420 --> 00:00:29,519
along with from here from here from

00:00:23,539 --> 00:00:31,500
barefoot and to and we'll talk about

00:00:29,519 --> 00:00:33,870
what we talked about um later on there's

00:00:31,500 --> 00:00:35,670
also some other people that think Ramez

00:00:33,870 --> 00:00:38,250
a different talk so we'll have a couple

00:00:35,670 --> 00:00:41,270
different topics and it's a bob and we

00:00:38,250 --> 00:00:48,360
have actually probably a bit of time so

00:00:41,270 --> 00:00:51,390
let's keep it interactive so the work

00:00:48,360 --> 00:00:54,660
that we've been trying to do is trying

00:00:51,390 --> 00:00:58,250
to answer this question in the context

00:00:54,660 --> 00:01:01,980
of the Linux kernel with whether we can

00:00:58,250 --> 00:01:04,650
describe a data plan using a high-level

00:01:01,980 --> 00:01:07,470
language or a description of some sort

00:01:04,650 --> 00:01:09,390
and whether we can implement that in the

00:01:07,470 --> 00:01:16,070
in the particular use cases that I have

00:01:09,390 --> 00:01:19,619
in BPF and the high-level language that

00:01:16,070 --> 00:01:23,850
that we're using actually is or the

00:01:19,619 --> 00:01:29,780
domain of from here so first we'll start

00:01:23,850 --> 00:01:33,240
off with all right yeah sure this is a

00:01:29,780 --> 00:01:44,700
like a really short working overview of

00:01:33,240 --> 00:01:48,570
what before is I have a few that's good

00:01:44,700 --> 00:01:50,820
okay I'm a few other slides on this and

00:01:48,570 --> 00:01:54,540
the later presentation that let's go

00:01:50,820 --> 00:01:57,210
through this quickly so this is these

00:01:54,540 --> 00:02:00,229
are the three main sections of a p4

00:01:57,210 --> 00:02:03,090
program before is a programming language

00:02:00,229 --> 00:02:06,680
it's not a protocol it's not a software

00:02:03,090 --> 00:02:10,229
it's a programming language so there's

00:02:06,680 --> 00:02:13,620
three main parts to the program parser

00:02:10,229 --> 00:02:15,360
and there's Harrod

00:02:13,620 --> 00:02:19,170
directions and then there's a control

00:02:15,360 --> 00:02:23,930
flow so what you see on the right hand

00:02:19,170 --> 00:02:26,459
side is like a fairly abstracted out

00:02:23,930 --> 00:02:30,060
pipeline so there's a parser in the

00:02:26,459 --> 00:02:33,569
front there's a multiple stages which

00:02:30,060 --> 00:02:36,090
operate on some metadata that the parser

00:02:33,569 --> 00:02:37,920
produces and then at the end of the

00:02:36,090 --> 00:02:40,379
pipeline there's a D parser or a

00:02:37,920 --> 00:02:42,900
synthesizer whatever you want to call it

00:02:40,379 --> 00:02:45,720
puts the packet back together and sends

00:02:42,900 --> 00:02:49,620
it out this is like a typical pipeline

00:02:45,720 --> 00:02:52,019
in a hardware switch so like I said

00:02:49,620 --> 00:02:55,650
there's header declarations which

00:02:52,019 --> 00:02:57,209
basically tell what the different fields

00:02:55,650 --> 00:02:59,640
in the header are you know what's the

00:02:57,209 --> 00:03:01,440
width is things like that and then

00:02:59,640 --> 00:03:04,230
there's a partial program which is a

00:03:01,440 --> 00:03:06,359
state machine which tells you how to

00:03:04,230 --> 00:03:11,569
parse an incoming packet with these

00:03:06,359 --> 00:03:14,579
headers and then stitching the actual

00:03:11,569 --> 00:03:17,519
match action units or the pipeline

00:03:14,579 --> 00:03:20,970
stages is the control flow program which

00:03:17,519 --> 00:03:23,639
basically operates on some tables then

00:03:20,970 --> 00:03:26,819
looking up information that is in the

00:03:23,639 --> 00:03:28,440
metadata in the tables and then taking

00:03:26,819 --> 00:03:30,810
some actions which would be

00:03:28,440 --> 00:03:34,530
modifications to the packet and so the

00:03:30,810 --> 00:03:39,450
packet moves along and comes up here's a

00:03:34,530 --> 00:03:42,319
example syntax for a header declaration

00:03:39,450 --> 00:03:46,859
here we're showing a metadata

00:03:42,319 --> 00:03:51,359
declaration it's also a header type as

00:03:46,859 --> 00:03:55,260
you can see has a bunch of fields width

00:03:51,359 --> 00:03:56,699
of the fields so the top is the actual

00:03:55,260 --> 00:03:59,639
declaration the bottom is the

00:03:56,699 --> 00:04:02,250
instantiation so just to give you a

00:03:59,639 --> 00:04:04,709
high-level overview of what before is

00:04:02,250 --> 00:04:06,510
and how how the program looks I think

00:04:04,709 --> 00:04:12,660
Brendan is going to go through an actual

00:04:06,510 --> 00:04:14,370
p4 program in a little bit so then to

00:04:12,660 --> 00:04:17,940
give a little bit of background on the

00:04:14,370 --> 00:04:22,009
other piece of this puzzle so BPF which

00:04:17,940 --> 00:04:25,360
many of you probably are also aware it's

00:04:22,009 --> 00:04:28,900
of engine or kind of a lightweight

00:04:25,360 --> 00:04:32,030
instruction set inside the kernel that's

00:04:28,900 --> 00:04:33,469
that you can execute instructions and in

00:04:32,030 --> 00:04:35,960
the in the case of networking that I

00:04:33,469 --> 00:04:38,259
mean there are many different places

00:04:35,960 --> 00:04:40,460
besides networking that you can use BPF

00:04:38,259 --> 00:04:44,360
but in the net that networking specific

00:04:40,460 --> 00:04:48,650
one you can take SK buffs from different

00:04:44,360 --> 00:04:52,159
hooks run the instruction set or run

00:04:48,650 --> 00:04:53,750
your program against each packet and you

00:04:52,159 --> 00:04:57,530
get the use of some kernel helper

00:04:53,750 --> 00:05:01,729
functions and you're able to interact

00:04:57,530 --> 00:05:03,949
with maps and arrays to read and write

00:05:01,729 --> 00:05:07,340
entries or to use to direct the control

00:05:03,949 --> 00:05:10,849
flow of the program and then to send the

00:05:07,340 --> 00:05:13,699
Esquivel out to may be redirected or to

00:05:10,849 --> 00:05:17,210
modify it and there's also a system call

00:05:13,699 --> 00:05:20,979
so from user space and this in our case

00:05:17,210 --> 00:05:24,860
was a QR code code load that gets

00:05:20,979 --> 00:05:27,889
translated into C and then into PDF and

00:05:24,860 --> 00:05:30,590
you also have handles to those those in

00:05:27,889 --> 00:05:34,219
kernel map objects that you can interact

00:05:30,590 --> 00:05:37,339
with and maybe some API that you use to

00:05:34,219 --> 00:05:41,779
expose a even higher level access to

00:05:37,339 --> 00:05:45,949
this so just a bit of review these are

00:05:41,779 --> 00:05:50,000
some of the EPF you know bits you get as

00:05:45,949 --> 00:05:54,319
stacks and load stores function calls

00:05:50,000 --> 00:05:56,539
Maps and so on and you can attach it to

00:05:54,319 --> 00:06:02,479
various and networking related hook

00:05:56,539 --> 00:06:04,879
points so in to to be able to get p4

00:06:02,479 --> 00:06:08,300
into the kernel we have to go through

00:06:04,879 --> 00:06:11,539
this kind of workflow we have some tools

00:06:08,300 --> 00:06:13,009
that that make this automatic so you can

00:06:11,539 --> 00:06:14,719
take a p4 program in this in this

00:06:13,009 --> 00:06:18,949
example we use a kind of a pseudo

00:06:14,719 --> 00:06:22,339
routing program that just doesn't some

00:06:18,949 --> 00:06:25,729
very simple nodding like actions but

00:06:22,339 --> 00:06:29,180
that gets translated by a script into a

00:06:25,729 --> 00:06:32,930
c program and then it goes through some

00:06:29,180 --> 00:06:34,810
clang and LLVM so you take the c program

00:06:32,930 --> 00:06:38,320
and you might rewrite it

00:06:34,810 --> 00:06:43,570
are modified a little bit too to be

00:06:38,320 --> 00:06:46,720
ready to to load into into b PF and then

00:06:43,570 --> 00:06:48,550
you'll get that into EPF instructions

00:06:46,720 --> 00:06:51,210
and load that through a system call so

00:06:48,550 --> 00:06:56,940
that you can actually do this on the fly

00:06:51,210 --> 00:07:01,090
and so taking these two things together

00:06:56,940 --> 00:07:04,300
p for program and the PPF runtime we

00:07:01,090 --> 00:07:08,020
would like to be able to define the data

00:07:04,300 --> 00:07:10,419
planes and to be able to build kind of a

00:07:08,020 --> 00:07:13,720
little network inside of the kernel to

00:07:10,419 --> 00:07:17,860
to run these customized customized

00:07:13,720 --> 00:07:20,620
customized engines and so in a demo that

00:07:17,860 --> 00:07:21,790
I'm about to show we'll have it's a

00:07:20,620 --> 00:07:23,639
little bit simpler than this there's not

00:07:21,790 --> 00:07:29,020
the green part on the right but there's

00:07:23,639 --> 00:07:32,320
two net devices that will be sending

00:07:29,020 --> 00:07:33,940
packets back and forth between this P

00:07:32,320 --> 00:07:40,500
port program that's this compiled into

00:07:33,940 --> 00:07:40,500
PDF so alright any questions so far

00:07:43,800 --> 00:07:51,550
so here we have Anna left in the on the

00:07:47,860 --> 00:07:54,880
left is a p4 program and on the right

00:07:51,550 --> 00:07:56,710
hand side is the corresponding C program

00:07:54,880 --> 00:07:59,020
I'm gonna switch back and forth these

00:07:56,710 --> 00:08:01,060
two and quickly go through some of the

00:07:59,020 --> 00:08:02,979
different parts later I mentioned so we

00:08:01,060 --> 00:08:06,070
have our header definitions so this is a

00:08:02,979 --> 00:08:09,250
V for only example you have a Ethernet

00:08:06,070 --> 00:08:13,900
and before and on the sea side we have

00:08:09,250 --> 00:08:17,050
the same we have the v4 header and done

00:08:13,900 --> 00:08:19,979
here in Ethernet header the right hand

00:08:17,050 --> 00:08:23,470
side was all automatically generated and

00:08:19,979 --> 00:08:25,300
we have so we just have those two

00:08:23,470 --> 00:08:28,419
headers then we have the definition of

00:08:25,300 --> 00:08:31,330
our start state and the first thing

00:08:28,419 --> 00:08:34,630
we'll do is parse Ethernet and the right

00:08:31,330 --> 00:08:36,159
hand side come back to some of those

00:08:34,630 --> 00:08:41,589
sections later so on the right hand side

00:08:36,159 --> 00:08:43,810
we'll have our parse Ethernet state we

00:08:41,589 --> 00:08:45,100
have a couple so this a little bit the

00:08:43,810 --> 00:08:49,079
some of the code is a little bit

00:08:45,100 --> 00:08:52,170
sprinkle that's not necessarily linear

00:08:49,079 --> 00:08:53,819
we have instances of the different

00:08:52,170 --> 00:08:55,110
header objects that's the people program

00:08:53,819 --> 00:08:58,230
wants to keep us at the parsing each

00:08:55,110 --> 00:08:59,639
packet which is annotated here you see a

00:08:58,230 --> 00:09:02,870
note here that there are some things

00:08:59,639 --> 00:09:05,730
that we can't do in this this alpha

00:09:02,870 --> 00:09:08,129
version of the before the BBF which is

00:09:05,730 --> 00:09:11,040
did for instance to calculate or verify

00:09:08,129 --> 00:09:12,600
checksums there's difference in logic

00:09:11,040 --> 00:09:14,850
between how people are treated pockets

00:09:12,600 --> 00:09:17,189
and how the the kernel treats and DPF

00:09:14,850 --> 00:09:24,059
treats back so I'm left to converge on

00:09:17,189 --> 00:09:27,779
that that's one of the to do so after we

00:09:24,059 --> 00:09:30,110
pressed Ethernet will parse ipv4 so that

00:09:27,779 --> 00:09:38,399
will involve extracting the ipv4 header

00:09:30,110 --> 00:09:41,749
and we can see the generated code on the

00:09:38,399 --> 00:09:46,170
right hand side will see thir net and

00:09:41,749 --> 00:09:48,050
here we see a little bit of the the beta

00:09:46,170 --> 00:09:49,949
nature of the the program so these are

00:09:48,050 --> 00:09:54,749
the C code that's generated is

00:09:49,949 --> 00:09:56,490
definitely suboptimal but it works and

00:09:54,749 --> 00:09:59,730
this is kind of low-hanging fruit that

00:09:56,490 --> 00:10:02,749
we can that will can work to improve so

00:09:59,730 --> 00:10:08,339
this will extract the fields from the

00:10:02,749 --> 00:10:11,339
skb justin source MAC address for either

00:10:08,339 --> 00:10:15,360
type and so on and we'll copy that into

00:10:11,339 --> 00:10:20,850
a destructive the ether even at around

00:10:15,360 --> 00:10:23,370
the BP up stack parse ipv4 in the same

00:10:20,850 --> 00:10:25,350
way and the the generated code here can

00:10:23,370 --> 00:10:27,839
keep track of all that it's offset in a

00:10:25,350 --> 00:10:35,699
way that people are is meant to

00:10:27,839 --> 00:10:38,339
understand it so the other so at the end

00:10:35,699 --> 00:10:41,939
of the parser right so we'll we have our

00:10:38,339 --> 00:10:43,709
control flow so there's this pipeline

00:10:41,939 --> 00:10:46,319
here that the prime engine will start

00:10:43,709 --> 00:10:48,050
with ingress we have we have two primary

00:10:46,319 --> 00:10:53,279
States here which ingress and egress

00:10:48,050 --> 00:10:58,110
ingress will first do a mapping of port

00:10:53,279 --> 00:10:59,579
to broadcast domain so the first thing

00:10:58,110 --> 00:11:01,830
we'll do is we'll take the port mapping

00:10:59,579 --> 00:11:05,310
this is a table definition in

00:11:01,830 --> 00:11:07,920
or so will this table definition reads

00:11:05,310 --> 00:11:11,160
the ingress part which I think happens

00:11:07,920 --> 00:11:13,290
to be a 16-bit unsigned so this is the

00:11:11,160 --> 00:11:16,890
key of this table in the action of the

00:11:13,290 --> 00:11:20,850
table is to save the value set broadcast

00:11:16,890 --> 00:11:23,940
domain will keep the broadcast domain in

00:11:20,850 --> 00:11:26,880
a metadata patter instance and we can

00:11:23,940 --> 00:11:30,170
find the corresponding C code so the C

00:11:26,880 --> 00:11:34,020
code will look up the ingress report and

00:11:30,170 --> 00:11:37,530
this does a BPF map lookup so this is

00:11:34,020 --> 00:11:40,920
kind of a helper syntax to be able to

00:11:37,530 --> 00:11:46,710
look up in BPF tables in a sad way and

00:11:40,920 --> 00:11:50,010
then we'll we'll save for instance on so

00:11:46,710 --> 00:11:51,450
in the next table that will look up if

00:11:50,010 --> 00:11:55,770
we go back to the ingress pipeline so

00:11:51,450 --> 00:12:01,370
we'll translate from the broadcast

00:11:55,770 --> 00:12:05,490
domain into vrf so this particular of

00:12:01,370 --> 00:12:09,930
routing programs of supports multiple

00:12:05,490 --> 00:12:13,830
routing domains and so the broadcast

00:12:09,930 --> 00:12:19,020
mean will once we know that we can save

00:12:13,830 --> 00:12:23,790
the vrf index and the next one is it

00:12:19,020 --> 00:12:26,000
will do a ipv4 good lookup now the this

00:12:23,790 --> 00:12:29,280
is the other major copy out of this

00:12:26,000 --> 00:12:33,410
lemon area version which is that we only

00:12:29,280 --> 00:12:36,060
support exact map lookups there's no

00:12:33,410 --> 00:12:37,980
there's already plenty of infrastructure

00:12:36,060 --> 00:12:39,870
in the kernel so we don't there's

00:12:37,980 --> 00:12:43,200
there's no need to you know duplicate

00:12:39,870 --> 00:12:46,860
that sorry and integrating that would be

00:12:43,200 --> 00:12:50,760
a future work so in this case we have an

00:12:46,860 --> 00:12:53,990
exact match of yep the two tuple of PRF

00:12:50,760 --> 00:12:58,320
and best address to be able to find the

00:12:53,990 --> 00:13:01,860
next hop for this packet so assuming

00:12:58,320 --> 00:13:04,740
with that we find the next hop we'll

00:13:01,860 --> 00:13:06,150
take that next hop and the last thing on

00:13:04,740 --> 00:13:10,550
that we have to do an ingress which is

00:13:06,150 --> 00:13:13,960
to figure out which output port to

00:13:10,550 --> 00:13:17,529
descend this packet out

00:13:13,960 --> 00:13:20,740
so next hop we'll look up the next stop

00:13:17,529 --> 00:13:22,630
index and turn it into pepper and the

00:13:20,740 --> 00:13:25,420
last thing that happens so we switch to

00:13:22,630 --> 00:13:27,330
the egress pipeline we're assuming that

00:13:25,420 --> 00:13:31,990
our next hop index was valid

00:13:27,330 --> 00:13:36,300
we'll do a rewrite source deaths Mac

00:13:31,990 --> 00:13:39,790
action and write that into a packet and

00:13:36,300 --> 00:13:41,470
then we're done and we can see and the

00:13:39,790 --> 00:13:43,899
right-hand side go through that same

00:13:41,470 --> 00:13:51,670
same state machine here translated into

00:13:43,899 --> 00:13:55,510
C so we have broadcast domain so whoever

00:13:51,670 --> 00:13:59,140
your F and we'll take our constructor

00:13:55,510 --> 00:14:02,709
our key and pass it to the PPF map

00:13:59,140 --> 00:14:06,670
lookup so we'll look up on the in that

00:14:02,709 --> 00:14:11,410
table and say the next hop index if the

00:14:06,670 --> 00:14:17,410
result was found and on the egress will

00:14:11,410 --> 00:14:21,490
or the last one will next stop and jump

00:14:17,410 --> 00:14:25,810
down to the so there's would be right so

00:14:21,490 --> 00:14:29,680
we there's some we'll take the the value

00:14:25,810 --> 00:14:33,580
from the map entry that was found and

00:14:29,680 --> 00:14:36,760
save it into our Ethernet Ethernet

00:14:33,580 --> 00:14:39,640
header instance and then in the V parser

00:14:36,760 --> 00:14:43,150
will take all of those the fields that

00:14:39,640 --> 00:14:45,940
are and all the this trucks and write

00:14:43,150 --> 00:14:48,120
them back into the packet again this is

00:14:45,940 --> 00:14:50,170
some of this is definitely suboptimal

00:14:48,120 --> 00:14:52,870
could be collapsed into a lot fewer

00:14:50,170 --> 00:14:54,580
rights or some of these are no ops and

00:14:52,870 --> 00:14:57,459
that's pretty easy compiler optimization

00:14:54,580 --> 00:14:59,650
work to eliminate all of those actors

00:14:57,459 --> 00:15:04,180
who actually the LLVM compiler will do

00:14:59,650 --> 00:15:05,680
it for you depending on it does this

00:15:04,180 --> 00:15:07,209
expense of a case it actually does it

00:15:05,680 --> 00:15:09,370
may be sure depending on the version I

00:15:07,209 --> 00:15:10,959
looked at some of the output of this and

00:15:09,370 --> 00:15:16,839
it I don't maybe in the way that this

00:15:10,959 --> 00:15:20,260
was generated really let's yeah if you

00:15:16,839 --> 00:15:24,180
have your version that happens to be a

00:15:20,260 --> 00:15:24,180
little smarter we can show that

00:15:24,920 --> 00:15:32,390
and yeah that's the nice thing for all

00:15:28,130 --> 00:15:35,450
this this C code it goes through all of

00:15:32,390 --> 00:15:41,300
the you know the LLVM optimizations BPF

00:15:35,450 --> 00:15:44,269
is the bytecode that are the the backend

00:15:41,300 --> 00:15:45,829
for PDF that's in LLVM is has pretty

00:15:44,269 --> 00:15:47,420
much or has most of the x86

00:15:45,829 --> 00:15:53,480
optimizations available to it it's very

00:15:47,420 --> 00:15:55,510
x x86 like and so it's the PPF that it

00:15:53,480 --> 00:16:00,860
spits out whoa

00:15:55,510 --> 00:16:04,060
he tends to work pretty well and last

00:16:00,860 --> 00:16:06,649
but not least so that program

00:16:04,060 --> 00:16:13,300
go ahead and i'll run this on my laptop

00:16:06,649 --> 00:16:17,029
and set up this couple namespaces with

00:16:13,300 --> 00:16:19,339
we can see here we have a small rest

00:16:17,029 --> 00:16:21,649
interface where we can have an

00:16:19,339 --> 00:16:26,829
automatically generated rest API based

00:16:21,649 --> 00:16:31,990
on those BPF table definitions so that

00:16:26,829 --> 00:16:31,990
we already have you know an api for this

00:16:54,900 --> 00:17:12,820
her name's mrs. and you're a pink so VPI

00:17:02,140 --> 00:17:15,780
program and so imposing the so looking

00:17:12,820 --> 00:17:19,600
at the different parts of d foreign BPF

00:17:15,780 --> 00:17:22,390
did find a way that to mix those two and

00:17:19,600 --> 00:17:25,480
i mean it's it's really really but

00:17:22,390 --> 00:17:26,860
that's it's definitely useful and there

00:17:25,480 --> 00:17:29,200
are a lot of some improvements remains

00:17:26,860 --> 00:17:31,540
so previously you couldn't do for

00:17:29,200 --> 00:17:34,420
instance any header modifications and

00:17:31,540 --> 00:17:38,680
and that's we added that support so

00:17:34,420 --> 00:17:41,160
recently and some of the things that we

00:17:38,680 --> 00:17:44,140
have to do so check some support so to

00:17:41,160 --> 00:17:49,570
converge on the the view of the world

00:17:44,140 --> 00:17:52,540
between p4 and EPF like that before has

00:17:49,570 --> 00:17:55,390
the idea that you should be able to push

00:17:52,540 --> 00:17:58,540
and pop arbitrary headers which you

00:17:55,390 --> 00:18:00,670
can't do with BPF they're definitely

00:17:58,540 --> 00:18:01,780
some restrictions and tricks the

00:18:00,670 --> 00:18:05,350
implementation that have to be sorted

00:18:01,780 --> 00:18:08,470
out and integrating of the know the

00:18:05,350 --> 00:18:09,940
colonel data structures with as one of

00:18:08,470 --> 00:18:10,540
the BPO options would might be

00:18:09,940 --> 00:18:13,810
interesting

00:18:10,540 --> 00:18:19,290
definitely the front end needs a lot of

00:18:13,810 --> 00:18:23,820
lot of work any other things that was

00:18:19,290 --> 00:18:30,240
that's what we've been working on and

00:18:23,820 --> 00:18:30,240
any questions or thoughts on that yes

00:18:32,850 --> 00:18:38,650
yeah so i I've been having this

00:18:37,000 --> 00:18:42,130
discussion so I don't know for the Lexi

00:18:38,650 --> 00:18:45,070
but yeah it's a good programming

00:18:42,130 --> 00:18:47,260
language I'm trying to see from the past

00:18:45,070 --> 00:18:52,650
the composition but way too if you go

00:18:47,260 --> 00:18:56,380
back like a couple of slides that right

00:18:52,650 --> 00:18:58,540
don't mean to be facetious but what is

00:18:56,380 --> 00:19:01,420
it that this composition does that TC

00:18:58,540 --> 00:19:03,850
doesn't do I stand the generation of the

00:19:01,420 --> 00:19:07,480
code you know I take EBP f : you can

00:19:03,850 --> 00:19:08,320
generate the different blobs that's what

00:19:07,480 --> 00:19:11,290
the LLVM

00:19:08,320 --> 00:19:14,280
that's what the EVP f does in others

00:19:11,290 --> 00:19:19,450
could this have been generating just TC

00:19:14,280 --> 00:19:22,600
pathways or graphs so so perhaps this

00:19:19,450 --> 00:19:25,000
specific example could happen but

00:19:22,600 --> 00:19:28,380
they're definitely cases that you can't

00:19:25,000 --> 00:19:28,380
handle with some of the stuff today

00:19:29,580 --> 00:19:37,900
imagine classifying on state using the

00:19:33,400 --> 00:19:40,780
Maps right you only want to match the

00:19:37,900 --> 00:19:43,780
the next packet if it's the packet in

00:19:40,780 --> 00:19:47,230
front of it had I don't know some label

00:19:43,780 --> 00:19:51,010
in the ipv6 header the critic that could

00:19:47,230 --> 00:19:56,820
I have written a TC probe program that

00:19:51,010 --> 00:19:59,500
is are injected in there and hand coded

00:19:56,820 --> 00:20:02,560
how things should be processed right so

00:19:59,500 --> 00:20:04,660
the PPF program itself which sits as an

00:20:02,560 --> 00:20:08,710
action for example there's a p4 sits on

00:20:04,660 --> 00:20:11,320
top of TC right I think you're more

00:20:08,710 --> 00:20:13,810
commenting on EBP f versus TC than p4

00:20:11,320 --> 00:20:17,140
versus TC right I'm so much back to

00:20:13,810 --> 00:20:19,000
smoke p4 versus T C as the TC as the

00:20:17,140 --> 00:20:21,040
grammar which is able to describe a

00:20:19,000 --> 00:20:22,720
graph of sure sure and you context

00:20:21,040 --> 00:20:25,150
before their own telling you 32 if you

00:20:22,720 --> 00:20:28,050
like yeah you could have output for

00:20:25,150 --> 00:20:30,520
example yes you could have output you 32

00:20:28,050 --> 00:20:31,720
classification or it was to BPM that but

00:20:30,520 --> 00:20:33,340
I have no problem with it's the

00:20:31,720 --> 00:20:37,360
composition which i think is the basis

00:20:33,340 --> 00:20:41,350
for before I'm wondering what will that

00:20:37,360 --> 00:20:43,240
creatures have output a TC script for

00:20:41,350 --> 00:20:47,080
example yeah I think that should be

00:20:43,240 --> 00:20:49,420
possible definitely looking into it

00:20:47,080 --> 00:20:51,430
there's there's a lot of similarities

00:20:49,420 --> 00:20:53,980
but yes there's a lot of similarities is

00:20:51,430 --> 00:20:58,210
what I'm trying to say right so I'm not

00:20:53,980 --> 00:20:58,810
arguing that you can use B BPF as one of

00:20:58,210 --> 00:21:02,020
those blocks

00:20:58,810 --> 00:21:06,070
or all of the blocks for that one it's

00:21:02,020 --> 00:21:06,610
the composition but share that sounds

00:21:06,070 --> 00:21:08,500
reasonable

00:21:06,610 --> 00:21:12,570
all right how many why those probably

00:21:08,500 --> 00:21:12,570
look at it yeah okay thanks

00:21:19,250 --> 00:21:24,360
yeah I would like to go it's indirect

00:21:21,570 --> 00:21:25,860
system I mean I don't see I'm going to

00:21:24,360 --> 00:21:27,900
talk about Tec but I got to tell my

00:21:25,860 --> 00:21:29,190
mother and if they will send after

00:21:27,900 --> 00:21:31,760
spending some time reading the

00:21:29,190 --> 00:21:34,260
specifications and study this thing

00:21:31,760 --> 00:21:37,890
question is that I don't see anything

00:21:34,260 --> 00:21:39,990
that could be it could be also not owned

00:21:37,890 --> 00:21:47,130
by enough tables and we already have a

00:21:39,990 --> 00:21:48,330
thing into it so yeah I'm not convinced

00:21:47,130 --> 00:21:49,770
that you're gonna come up with one

00:21:48,330 --> 00:21:51,690
language that everyone's gonna write it

00:21:49,770 --> 00:21:56,220
and it's gonna be the one language right

00:21:51,690 --> 00:21:58,440
maybe we have see other things right I

00:21:56,220 --> 00:22:02,700
mean we have enough tables and TCE and

00:21:58,440 --> 00:22:05,100
before I don't know I think coming up

00:22:02,700 --> 00:22:05,580
with a universal language it's just not

00:22:05,100 --> 00:22:08,400
gonna happen

00:22:05,580 --> 00:22:09,960
I don't actually think it's harmful time

00:22:08,400 --> 00:22:13,020
more than one language that sits in

00:22:09,960 --> 00:22:15,600
front of everything great and I mean

00:22:13,020 --> 00:22:17,460
another way to look at I mean the I mean

00:22:15,600 --> 00:22:19,920
this is using all the existing

00:22:17,460 --> 00:22:21,870
functionality there's I mean nothing no

00:22:19,920 --> 00:22:25,950
modifications or actually no no new

00:22:21,870 --> 00:22:28,560
kernel code used to do these things it's

00:22:25,950 --> 00:22:30,420
I mean it's already flexible fairly

00:22:28,560 --> 00:22:32,700
flexible and I mean if the user wants to

00:22:30,420 --> 00:22:35,460
define programs in this way it's it's

00:22:32,700 --> 00:22:41,310
possible I think it's first of all in

00:22:35,460 --> 00:22:42,780
the same I mean it's it's flexible as if

00:22:41,310 --> 00:22:47,820
you have come in flexible because it

00:22:42,780 --> 00:22:50,820
especially relying on it and mm-hm

00:22:47,820 --> 00:22:55,320
well I mean what is the the argument to

00:22:50,820 --> 00:22:57,720
bring up with a new way to express data

00:22:55,320 --> 00:22:59,340
data path we have ways to spread out

00:22:57,720 --> 00:23:02,160
into the economy if we are going to push

00:22:59,340 --> 00:23:05,040
another front end that that we can

00:23:02,160 --> 00:23:13,860
basically do with what we have is I mean

00:23:05,040 --> 00:23:16,440
to me it's hard to justify it's just

00:23:13,860 --> 00:23:18,720
another another language I think I have

00:23:16,440 --> 00:23:22,740
you know I mean we could argue about

00:23:18,720 --> 00:23:24,240
syntax and all that fun stuff but sure

00:23:22,740 --> 00:23:26,700
you think you can do with nf2 you then

00:23:24,240 --> 00:23:36,830
use an FTE scrambler

00:23:26,700 --> 00:23:36,830
right mommy honey don't turn off yet

00:23:40,970 --> 00:23:46,309
performance analysis of this how will

00:23:46,369 --> 00:23:52,559
with this this translation no we haven't

00:23:50,460 --> 00:23:55,710
done any performance analysis I mean of

00:23:52,559 --> 00:23:57,590
stock DPF there's definitely people have

00:23:55,710 --> 00:24:07,019
been talking about that all week I guess

00:23:57,590 --> 00:24:08,279
with this one no yep and I mean at this

00:24:07,019 --> 00:24:10,080
point I think it's premature because

00:24:08,279 --> 00:24:23,399
there's I mean there's all the

00:24:10,080 --> 00:24:25,499
low-hanging fruits already there I have

00:24:23,399 --> 00:24:27,210
a question about the I think it's maybe

00:24:25,499 --> 00:24:29,539
two slides after this two missing

00:24:27,210 --> 00:24:32,700
features yes

00:24:29,539 --> 00:24:40,759
which part of these are missing in BPF

00:24:32,700 --> 00:24:46,320
and which in before in your opinion the

00:24:40,759 --> 00:24:49,590
DPF would be a push pop header and check

00:24:46,320 --> 00:24:51,690
some support check some support might be

00:24:49,590 --> 00:24:55,590
doable in different ways but I think

00:24:51,690 --> 00:24:58,399
there's even some some thoughts on

00:24:55,590 --> 00:25:00,629
better ways to do check some with in BPF

00:24:58,399 --> 00:25:02,429
you know disregarding mean even people

00:25:00,629 --> 00:25:06,029
are there's there's already a helper for

00:25:02,429 --> 00:25:08,100
doing check sums and it's somewhat

00:25:06,029 --> 00:25:10,289
limited and I think there is already

00:25:08,100 --> 00:25:15,710
some some patches for that not from you

00:25:10,289 --> 00:25:18,659
know and the table types is that's I

00:25:15,710 --> 00:25:20,970
mean that's just been talked about so

00:25:18,659 --> 00:25:23,070
and I think the per CPU ash tables as

00:25:20,970 --> 00:25:32,629
they go those good in you know

00:25:23,070 --> 00:25:32,629
Aleksei it helps performance though yeah

00:25:36,020 --> 00:25:45,419
and I think that I mean that that was I

00:25:38,760 --> 00:25:47,250
mean in the poorest so I just meant

00:25:45,419 --> 00:25:48,570
fronted optimizations right there's a

00:25:47,250 --> 00:25:51,450
lot of things you can use to build

00:25:48,570 --> 00:25:54,600
better back-end code we get some per CPU

00:25:51,450 --> 00:25:56,159
stuff things like that so I definitely

00:25:54,600 --> 00:25:58,799
have a use case for pushing or popping

00:25:56,159 --> 00:26:01,980
Hatter's need be a BPF independent from

00:25:58,799 --> 00:26:03,419
the p4 part so I think I think the

00:26:01,980 --> 00:26:05,539
biggest one for me would be the in cap

00:26:03,419 --> 00:26:12,330
and D cap stuff where I figure that out

00:26:05,539 --> 00:26:14,640
also just yeah so when you mention that

00:26:12,330 --> 00:26:18,630
there's no single language that we will

00:26:14,640 --> 00:26:20,700
all agree on to a large extent BPF is

00:26:18,630 --> 00:26:23,850
that single language right so like

00:26:20,700 --> 00:26:25,710
looping is is missing there but how much

00:26:23,850 --> 00:26:28,320
is missing and how much of that is

00:26:25,710 --> 00:26:31,230
missing because PPF was not used or

00:26:28,320 --> 00:26:34,230
what's used in for unprivileged users

00:26:31,230 --> 00:26:36,720
and our restrictions in the language

00:26:34,230 --> 00:26:43,440
that we're basically willing to let go

00:26:36,720 --> 00:26:44,730
for these use cases I guess I'm not

00:26:43,440 --> 00:26:48,120
quite sure what the minute question is

00:26:44,730 --> 00:26:50,490
occasion maybe say that again sorry John

00:26:48,120 --> 00:26:54,330
you mentioned that people probably not

00:26:50,490 --> 00:26:56,760
agree on a composition language with

00:26:54,330 --> 00:27:00,360
which to compose from owner of multiple

00:26:56,760 --> 00:27:03,990
BBF programs but BPF itself is you know

00:27:00,360 --> 00:27:06,990
a very expressive language missing some

00:27:03,990 --> 00:27:08,820
obvious features like loops to what

00:27:06,990 --> 00:27:09,929
extent is BPF not just that one language

00:27:08,820 --> 00:27:12,570
that you're looking for if you're

00:27:09,929 --> 00:27:15,150
willing to so I think that BPF has a

00:27:12,570 --> 00:27:17,120
little too low level for most folks

00:27:15,150 --> 00:27:23,610
right you're not going to write

00:27:17,120 --> 00:27:24,780
specifications and P DPF right so but so

00:27:23,610 --> 00:27:26,100
that I think there's a need for a high

00:27:24,780 --> 00:27:27,450
level of something higher level and

00:27:26,100 --> 00:27:28,799
that's why we have the you know the C

00:27:27,450 --> 00:27:30,390
language you can compile down right

00:27:28,799 --> 00:27:31,650
which works fairly well yeah I think

00:27:30,390 --> 00:27:33,390
there's probably room for a

00:27:31,650 --> 00:27:34,530
domain-specific language in the

00:27:33,390 --> 00:27:36,840
networking side

00:27:34,530 --> 00:27:40,130
I think p4 is kind of a first attempt at

00:27:36,840 --> 00:27:43,500
some of that and I suspect it'll evolve

00:27:40,130 --> 00:27:44,770
going forward so yeah I think you might

00:27:43,500 --> 00:27:46,090
see others too you know

00:27:44,770 --> 00:27:49,560
I don't think that p4 will be the only

00:27:46,090 --> 00:27:58,330
thing around yep

00:27:49,560 --> 00:28:00,070
thanks yes Oh another question I guess

00:27:58,330 --> 00:28:03,130
you have piece of hardware that offloads

00:28:00,070 --> 00:28:05,680
this are you planning to take BPF till

00:28:03,130 --> 00:28:07,720
it translated into hardware some of your

00:28:05,680 --> 00:28:11,770
assembler code or whatever from wherever

00:28:07,720 --> 00:28:14,310
you are however you program it does that

00:28:11,770 --> 00:28:18,370
work even have another extra insulation

00:28:14,310 --> 00:28:20,860
yeah that waits to be seen right I mean

00:28:18,370 --> 00:28:24,490
right now if there's a P for

00:28:20,860 --> 00:28:26,350
programmable target you can load the

00:28:24,490 --> 00:28:28,360
data plane description that is written

00:28:26,350 --> 00:28:32,050
in before into the target directly and

00:28:28,360 --> 00:28:34,450
then manipulate that using the Linux

00:28:32,050 --> 00:28:35,230
kernel utilities so that's one way of

00:28:34,450 --> 00:28:37,330
doing it

00:28:35,230 --> 00:28:40,050
the other one is actually doing the

00:28:37,330 --> 00:28:40,050
hardware

00:28:49,540 --> 00:29:07,940
all right there any more questions so we

00:28:52,340 --> 00:29:11,630
can call it good there okay okay so this

00:29:07,940 --> 00:29:15,590
was one of the ideas that was floated

00:29:11,630 --> 00:29:17,930
around to use the P for program or a P

00:29:15,590 --> 00:29:22,130
for pipeline as a back-end for switch

00:29:17,930 --> 00:29:24,440
tab you know what what's the reasons for

00:29:22,130 --> 00:29:26,920
that I'll dive into it a little bit

00:29:24,440 --> 00:29:29,030
we've done a little bit of work on this

00:29:26,920 --> 00:29:30,800
at barefoot networks

00:29:29,030 --> 00:29:34,160
Parag is the one who did most of the

00:29:30,800 --> 00:29:38,110
work so I'm going to just go or what we

00:29:34,160 --> 00:29:42,680
have done so far if you look at any

00:29:38,110 --> 00:29:44,390
switching ASIC kinda has the pipeline

00:29:42,680 --> 00:29:47,660
like this there's the ingress portion

00:29:44,390 --> 00:29:49,970
there's the egress portion there's

00:29:47,660 --> 00:29:54,020
usually a parser in the front the parser

00:29:49,970 --> 00:29:57,410
at the end sometimes there is no D

00:29:54,020 --> 00:29:59,720
parser before going to the queueing you

00:29:57,410 --> 00:30:03,260
know replication engine but typically

00:29:59,720 --> 00:30:10,940
this is how it looks and P for maps to

00:30:03,260 --> 00:30:14,620
this type of you know pipeline model so

00:30:10,940 --> 00:30:19,790
what's the scope of P 4 P 4 was actually

00:30:14,620 --> 00:30:22,190
developed to be used on p4 programmable

00:30:19,790 --> 00:30:25,130
hardware targets and that was the main

00:30:22,190 --> 00:30:28,520
use so in a traditional switch you have

00:30:25,130 --> 00:30:30,920
a fixed function ASIC with a fixed data

00:30:28,520 --> 00:30:34,490
plane being controlled by a you know an

00:30:30,920 --> 00:30:38,000
SDK a control plane and that's how it

00:30:34,490 --> 00:30:41,300
looks on the top and then in a p4

00:30:38,000 --> 00:30:43,520
defined switch it looks like this in the

00:30:41,300 --> 00:30:47,060
bottom there's a programmable data plane

00:30:43,520 --> 00:30:50,960
that you can give the pipeline

00:30:47,060 --> 00:30:53,000
description using a p4 program and you

00:30:50,960 --> 00:30:55,820
load that into the programmable data

00:30:53,000 --> 00:30:58,160
plane and that becomes your pipeline and

00:30:55,820 --> 00:30:59,750
then you control that pipeline using a

00:30:58,160 --> 00:31:05,520
control plane

00:30:59,750 --> 00:31:07,500
like any other switch so before is not

00:31:05,520 --> 00:31:10,410
open flow I think this is just kind of

00:31:07,500 --> 00:31:12,570
showing the relationship between you

00:31:10,410 --> 00:31:15,120
know where p4 sits and we're open flus

00:31:12,570 --> 00:31:18,120
it's open flow is in the middle the blue

00:31:15,120 --> 00:31:21,930
boxes before is actually at the switch

00:31:18,120 --> 00:31:23,900
ASIC or the forwarding plane level

00:31:21,930 --> 00:31:30,990
there's been some confusion on this

00:31:23,900 --> 00:31:34,080
layer that so switch dev and p4 so in

00:31:30,990 --> 00:31:36,120
switch dev if you want control of p4

00:31:34,080 --> 00:31:38,520
device you would like you should have a

00:31:36,120 --> 00:31:40,800
p4 driver so that's the the whole

00:31:38,520 --> 00:31:42,690
motivation for this so sometime in the

00:31:40,800 --> 00:31:46,950
future you'll get it before programmable

00:31:42,690 --> 00:31:50,220
trip you want to be able to come control

00:31:46,950 --> 00:31:50,670
that using switch dev and how would you

00:31:50,220 --> 00:31:53,160
do it

00:31:50,670 --> 00:31:56,190
you need a p4 driver and switch to that

00:31:53,160 --> 00:31:58,490
that maps to switch there and takes the

00:31:56,190 --> 00:32:01,410
commands and pushes it to the hardware

00:31:58,490 --> 00:32:04,550
so since we don't have such a hardware

00:32:01,410 --> 00:32:09,920
yet we started working with rocker and

00:32:04,550 --> 00:32:12,300
we added be for support to to the rocker

00:32:09,920 --> 00:32:15,300
so I don't know how many of you were

00:32:12,300 --> 00:32:18,600
here the last native Scot kind of

00:32:15,300 --> 00:32:22,580
presented this and as a future work he

00:32:18,600 --> 00:32:25,380
mentioned possibility of a p4 world and

00:32:22,580 --> 00:32:27,930
that is what we have worked on you also

00:32:25,380 --> 00:32:30,600
talked about an e BPF world that's also

00:32:27,930 --> 00:32:35,400
a possibility so once you have this

00:32:30,600 --> 00:32:38,340
support for a p4 pipeline you know you

00:32:35,400 --> 00:32:42,230
can you can load that into rocker and

00:32:38,340 --> 00:32:45,240
test it you can load new functionality

00:32:42,230 --> 00:32:48,210
described in a p4 program and then

00:32:45,240 --> 00:32:50,100
tested using switch dev so I think it

00:32:48,210 --> 00:32:57,810
helps in the development of switch stuff

00:32:50,100 --> 00:33:01,290
and testing of it so here's what we did

00:32:57,810 --> 00:33:06,150
to add before support so there's the p4

00:33:01,290 --> 00:33:10,490
worlds support that's been done in the

00:33:06,150 --> 00:33:13,330
rocker driver as well as rocker device

00:33:10,490 --> 00:33:16,059
it's not up streamed or anything

00:33:13,330 --> 00:33:20,489
it's still work in progress but we've

00:33:16,059 --> 00:33:25,739
also implemented a EPI for pipe pipeline

00:33:20,489 --> 00:33:25,739
that runs in a rocker emulated device

00:33:27,779 --> 00:33:34,710
this is how a rocker with p4 pipelines

00:33:31,779 --> 00:33:38,470
will look you can you can actually

00:33:34,710 --> 00:33:41,289
connect these ports to Linux Linux

00:33:38,470 --> 00:33:44,200
networking stack and then we actually

00:33:41,289 --> 00:33:46,779
were able to port the ports that were on

00:33:44,200 --> 00:33:49,269
off DPA and the ports that were on the

00:33:46,779 --> 00:33:55,509
p4 pipeline put them on a Linux bridge

00:33:49,269 --> 00:33:57,730
and test traffic between them here's an

00:33:55,509 --> 00:34:00,580
example before program that was actually

00:33:57,730 --> 00:34:04,720
used in in rocker

00:34:00,580 --> 00:34:08,230
it's a fairly simple one just as you

00:34:04,720 --> 00:34:16,389
know Mac lookup and ipv4 address lookup

00:34:08,230 --> 00:34:18,879
and switches it more program so then

00:34:16,389 --> 00:34:22,389
there is this switch start v4 program

00:34:18,879 --> 00:34:27,040
which is supposed to be a more robust or

00:34:22,389 --> 00:34:32,349
a more comprehensive description of a

00:34:27,040 --> 00:34:36,069
top of rack or a spine switch it has a

00:34:32,349 --> 00:34:39,849
bunch of features in it description for

00:34:36,069 --> 00:34:42,790
ingress pipeline ingress by plane these

00:34:39,849 --> 00:34:45,389
are the features more features are

00:34:42,790 --> 00:34:51,369
getting added it's already open sourced

00:34:45,389 --> 00:34:53,619
available on github so on the ingress

00:34:51,369 --> 00:34:56,770
pipeline essentially it parses the

00:34:53,619 --> 00:35:00,609
packet that's the you know fields into a

00:34:56,770 --> 00:35:03,099
metadata structure Maps the input port

00:35:00,609 --> 00:35:05,559
to an egress interface derives wheel and

00:35:03,099 --> 00:35:09,180
all the standard stuff that a switch

00:35:05,559 --> 00:35:11,980
does you know on the ingress pipeline

00:35:09,180 --> 00:35:14,049
Donal if it's a tunnel packet do you

00:35:11,980 --> 00:35:16,720
need to terminate it or not if you need

00:35:14,049 --> 00:35:20,280
to terminate it get the inside headers

00:35:16,720 --> 00:35:22,809
put them into metadata things like that

00:35:20,280 --> 00:35:25,569
standard egress pipeline functions

00:35:22,809 --> 00:35:27,190
stripped VLAN headers you know if the

00:35:25,569 --> 00:35:31,750
tunnel needs to be decap

00:35:27,190 --> 00:35:33,609
you know take off headers if this packet

00:35:31,750 --> 00:35:36,970
needs to be sent on at all you know put

00:35:33,609 --> 00:35:38,680
on headers if you need to add any VLAN

00:35:36,970 --> 00:35:41,170
headers you know all the packet mods are

00:35:38,680 --> 00:35:42,970
happening in the US by plane there's

00:35:41,170 --> 00:35:45,670
also a host interface if you want to

00:35:42,970 --> 00:35:48,660
send packets to the host CPU you know

00:35:45,670 --> 00:35:53,200
you can encapsulate it in a CPU header a

00:35:48,660 --> 00:35:56,440
and send it to CPU or you can receive

00:35:53,200 --> 00:35:58,390
packets from the CPU and then bypass the

00:35:56,440 --> 00:36:01,030
whole pipeline and send it out on an

00:35:58,390 --> 00:36:04,440
eager sport or you can send it through

00:36:01,030 --> 00:36:07,599
the pipeline get the normal lookups done

00:36:04,440 --> 00:36:10,780
so this program is there you can

00:36:07,599 --> 00:36:14,349
actually you know run this in a

00:36:10,780 --> 00:36:17,859
simulated model and test it and it's

00:36:14,349 --> 00:36:20,730
continuously evolving it'll be good to

00:36:17,859 --> 00:36:25,030
have this as a back-end for switch stuff

00:36:20,730 --> 00:36:28,500
because it has a lot more features so

00:36:25,030 --> 00:36:30,490
that's part of some of the future work

00:36:28,500 --> 00:36:33,430
something that we're looking at is how

00:36:30,490 --> 00:36:36,210
to complete the world support in rocker

00:36:33,430 --> 00:36:39,609
working a Giri

00:36:36,210 --> 00:36:41,800
you know implement second P for world so

00:36:39,609 --> 00:36:45,099
you can switch packets between two P for

00:36:41,800 --> 00:36:47,440
worlds talked about the upgrading the P

00:36:45,099 --> 00:36:50,349
for program and eventually there will be

00:36:47,440 --> 00:36:54,940
a you know before driver for job stock

00:36:50,349 --> 00:36:56,319
before so question so well this I look

00:36:54,940 --> 00:36:58,960
at this and I can see let's say abroad

00:36:56,319 --> 00:37:02,230
comes wage or the metal box which it's

00:36:58,960 --> 00:37:03,640
not very exciting right yeah I guess the

00:37:02,230 --> 00:37:06,730
it was a proof point that you can

00:37:03,640 --> 00:37:09,430
actually generate this code yeah so but

00:37:06,730 --> 00:37:11,410
if you to offload this you could just

00:37:09,430 --> 00:37:14,740
use current facilities that are used

00:37:11,410 --> 00:37:17,410
let's say someone off los FTB is a CL

00:37:14,740 --> 00:37:22,599
apples there's nothing very exciting

00:37:17,410 --> 00:37:25,359
basically in this specific example yeah

00:37:22,599 --> 00:37:27,520
this is just showing so you didn't need

00:37:25,359 --> 00:37:29,800
any extra facilities what I'm trying to

00:37:27,520 --> 00:37:31,210
say for this specific example you didn't

00:37:29,800 --> 00:37:35,530
need any extra facility than what the

00:37:31,210 --> 00:37:36,910
metal box so it you would need if you go

00:37:35,530 --> 00:37:37,850
back to your diagram we are showing the

00:37:36,910 --> 00:37:40,280
offload

00:37:37,850 --> 00:37:42,200
you know I mean the more interesting

00:37:40,280 --> 00:37:45,200
scenario would be where you have loops

00:37:42,200 --> 00:37:48,160
for example or what do you guys call it

00:37:45,200 --> 00:37:51,290
when you go back that way yeah

00:37:48,160 --> 00:37:54,140
that's kind of different I mean a lot of

00:37:51,290 --> 00:37:57,260
these chips don't support that yeah I

00:37:54,140 --> 00:38:03,590
mean the capabilities of the hardware

00:37:57,260 --> 00:38:06,440
target will dictate some of that I mean

00:38:03,590 --> 00:38:09,050
what we're showing here is like if if

00:38:06,440 --> 00:38:12,680
you have a P for programmable target or

00:38:09,050 --> 00:38:17,360
chip that's fine so it depends on what

00:38:12,680 --> 00:38:19,430
the chip exposes and it's if you go back

00:38:17,360 --> 00:38:26,030
to your diagram way of showing how which

00:38:19,430 --> 00:38:27,410
one things are there that I am NOT so

00:38:26,030 --> 00:38:29,320
for that specific example I don't know

00:38:27,410 --> 00:38:36,500
why you would need anything that's

00:38:29,320 --> 00:38:37,580
specific to people right you could you

00:38:36,500 --> 00:38:39,620
know something yeah yeah

00:38:37,580 --> 00:38:41,030
it just provides you a way that lets say

00:38:39,620 --> 00:38:45,980
stimulate your switch before it's

00:38:41,030 --> 00:38:47,420
already that's fine but if you're doing

00:38:45,980 --> 00:38:50,420
switch dev what would you switch off

00:38:47,420 --> 00:38:51,770
loading it you can offload it's not like

00:38:50,420 --> 00:38:58,280
your own everything you already have the

00:38:51,770 --> 00:39:00,710
FTB's and all the adorable the thing

00:38:58,280 --> 00:39:03,260
that he can do right so his limitations

00:39:00,710 --> 00:39:05,990
of the rocker driver capabilities which

00:39:03,260 --> 00:39:08,680
today is mostly as l2 a simple l3 device

00:39:05,990 --> 00:39:12,380
right so if you had some cool whiz-bang

00:39:08,680 --> 00:39:14,150
TC like feature and the rocker driver

00:39:12,380 --> 00:39:16,430
implemented that through and through I

00:39:14,150 --> 00:39:19,130
guess it does now doesn't it I'm looking

00:39:16,430 --> 00:39:21,050
at you Joe this is the TC stuff in the

00:39:19,130 --> 00:39:23,150
rocker drivers will know and I never

00:39:21,050 --> 00:39:27,140
added it a rocker I think I had just hit

00:39:23,150 --> 00:39:29,840
a real hardware right if it did then he

00:39:27,140 --> 00:39:32,240
could simulate that end to end with the

00:39:29,840 --> 00:39:35,710
p4 program that was adapted for it

00:39:32,240 --> 00:39:39,440
that's that's the point so like so

00:39:35,710 --> 00:39:41,060
anything my question is do you need

00:39:39,440 --> 00:39:43,250
anything new is what I'm trying to say

00:39:41,060 --> 00:39:46,330
other than switch Dave as it exists

00:39:43,250 --> 00:39:48,770
we'll know okay thank you

00:39:46,330 --> 00:39:50,630
are you gonna try to push this to qemu

00:39:48,770 --> 00:39:53,660
like all the updates and

00:39:50,630 --> 00:39:55,250
is that the planet Venus so but actually

00:39:53,660 --> 00:39:57,500
I want to go back to something Georgia

00:39:55,250 --> 00:39:59,599
said that Brock our driver is probably

00:39:57,500 --> 00:40:02,089
dead so you want to change this picture

00:39:59,599 --> 00:40:04,700
you want to get rocker this this slide

00:40:02,089 --> 00:40:08,240
in the future not a driver part with the

00:40:04,700 --> 00:40:10,220
rocker device the next year picture

00:40:08,240 --> 00:40:12,349
shouldn't have that block at all and it

00:40:10,220 --> 00:40:13,970
should be a qmu device the next year

00:40:12,349 --> 00:40:17,890
picture is something like this right

00:40:13,970 --> 00:40:17,890
there's that there's the device itself

00:40:25,900 --> 00:40:31,029
so yeah I mean that's all I have any

00:40:28,519 --> 00:40:31,029
other question

00:40:36,960 --> 00:40:48,140
any other topics comments it's a Boff we

00:40:43,830 --> 00:40:50,880
solved everything already yesterday good

00:40:48,140 --> 00:40:52,820
all right thanks I think there's some

00:40:50,880 --> 00:40:55,910
other talks going on in the other room

00:40:52,820 --> 00:40:55,910

YouTube URL: https://www.youtube.com/watch?v=8nsMJ6SeLbc


