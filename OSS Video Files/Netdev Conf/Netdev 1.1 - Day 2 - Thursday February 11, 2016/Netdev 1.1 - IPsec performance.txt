Title: Netdev 1.1 - IPsec performance
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 2 - Thursday February 11, 2016
Description: 
	Steffen Klassert
February 2016
Captions: 
	00:00:00,120 --> 00:00:06,690
okay so welcome to the IPSec bath today

00:00:04,350 --> 00:00:08,940
I want to talk about some problems we

00:00:06,690 --> 00:00:14,400
are facing when we try to improve the

00:00:08,940 --> 00:00:18,449
IPSec performance recently so these are

00:00:14,400 --> 00:00:20,310
my topics and the idea is that I give a

00:00:18,449 --> 00:00:24,000
short introduction on each topic and

00:00:20,310 --> 00:00:26,340
then I have some questions on these

00:00:24,000 --> 00:00:30,080
topics where I hope to get some answers

00:00:26,340 --> 00:00:33,809
or at least some discussion on it okay

00:00:30,080 --> 00:00:37,559
so let's start with the first topic that

00:00:33,809 --> 00:00:40,980
is we want to avoid frame copy in IPSec

00:00:37,559 --> 00:00:43,290
so what's the problem here

00:00:40,980 --> 00:00:45,420
the problem is that most of the data

00:00:43,290 --> 00:00:48,000
frames are linearized before we have to

00:00:45,420 --> 00:00:48,480
pass that to regrip the layer so why is

00:00:48,000 --> 00:00:50,460
that

00:00:48,480 --> 00:00:53,520
just this because the crypto layer

00:00:50,460 --> 00:00:56,640
descriptor in place so we have to pass

00:00:53,520 --> 00:00:59,010
writable buffers to decrypt the layer

00:00:56,640 --> 00:01:03,019
and that we are doing just by linearize

00:00:59,010 --> 00:01:07,320
it and after that the buffer is writable

00:01:03,019 --> 00:01:10,619
so we want to avoid this and how we want

00:01:07,320 --> 00:01:12,270
to do this well on our excite that's

00:01:10,619 --> 00:01:15,630
pretty easy because we can know if the

00:01:12,270 --> 00:01:18,509
buffer is writable it's just that it

00:01:15,630 --> 00:01:21,590
does not need to be cloned or the chief

00:01:18,509 --> 00:01:24,330
shared flag must not be set in this case

00:01:21,590 --> 00:01:25,979
we can just write to the buffer so the

00:01:24,330 --> 00:01:29,990
solution is pretty easy we just

00:01:25,979 --> 00:01:34,409
linearize if the buffer is not writable

00:01:29,990 --> 00:01:37,229
so on the transmitted part it's a little

00:01:34,409 --> 00:01:40,380
bit more complicated because IPSec pegs

00:01:37,229 --> 00:01:42,240
usually have a trailer so we need a

00:01:40,380 --> 00:01:45,840
space to copy the trailer to the bar

00:01:42,240 --> 00:01:47,880
phone so here we have to somehow expand

00:01:45,840 --> 00:01:51,439
the tail of the buffer to get the

00:01:47,880 --> 00:01:54,630
trailer on it so what can we do here

00:01:51,439 --> 00:01:56,430
well the solution would be we could just

00:01:54,630 --> 00:02:00,869
add page fragment with the tail Webster

00:01:56,430 --> 00:02:03,540
buffer but there is a small problem this

00:02:00,869 --> 00:02:06,270
works in all cases it works just if we

00:02:03,540 --> 00:02:10,440
really have at least one slot free to

00:02:06,270 --> 00:02:13,050
add this fragment so question here would

00:02:10,440 --> 00:02:17,310
be can we instrument somehow

00:02:13,050 --> 00:02:22,590
that to generate these kind of offers an

00:02:17,310 --> 00:02:26,700
12 on local sent it's probably possible

00:02:22,590 --> 00:02:28,910
because this Petrus use high order page

00:02:26,700 --> 00:02:32,310
so we have not more than three to four

00:02:28,910 --> 00:02:35,670
fragments to buffer and actually when I

00:02:32,310 --> 00:02:39,780
tried to implement that I started try it

00:02:35,670 --> 00:02:42,210
and I strange paths and took me quite a

00:02:39,780 --> 00:02:44,490
while to debug that and it turned out

00:02:42,210 --> 00:02:46,890
the problem was that the crypto layer

00:02:44,490 --> 00:02:48,330
always assumed to have ordinal pages and

00:02:46,890 --> 00:02:51,480
scatter lists which is kind of

00:02:48,330 --> 00:02:55,890
incompatible to how we generate buffers

00:02:51,480 --> 00:02:58,200
in the networking so first question here

00:02:55,890 --> 00:03:01,020
would be Oh is there a reason for that

00:02:58,200 --> 00:03:04,140
or can we just change the crypto layer

00:03:01,020 --> 00:03:06,240
to handle high order pages like

00:03:04,140 --> 00:03:09,270
networking is tacit

00:03:06,240 --> 00:03:11,340
I mean Chinese crypto layer is not that

00:03:09,270 --> 00:03:13,200
hard to sustain with a couple of small

00:03:11,340 --> 00:03:15,480
patches but I'm actually not sure if I'm

00:03:13,200 --> 00:03:16,950
allowed to do that so it's the reason

00:03:15,480 --> 00:03:20,070
that the crypto layer real stuff

00:03:16,950 --> 00:03:24,660
I mean anyone familiar with a crypto

00:03:20,070 --> 00:03:29,070
layer who could yeah yeah I started to

00:03:24,660 --> 00:03:33,870
but I was not exactly sure no you should

00:03:29,070 --> 00:03:36,900
talk to the crypto guys so let's

00:03:33,870 --> 00:03:40,770
continue forwarding since a couple of

00:03:36,900 --> 00:03:43,470
years we build on general receive a full

00:03:40,770 --> 00:03:45,660
size buffers with reckless and the

00:03:43,470 --> 00:03:48,750
problem with this kind of buffers that

00:03:45,660 --> 00:03:51,180
we count add page fragments with IPSec

00:03:48,750 --> 00:03:53,580
tables to these buffers because all

00:03:51,180 --> 00:03:58,500
slots are full and we even have requests

00:03:53,580 --> 00:04:00,270
on it so I mean even to a general

00:03:58,500 --> 00:04:02,489
forwarding problem because such buffers

00:04:00,270 --> 00:04:04,200
can be off lock the hardware so we need

00:04:02,489 --> 00:04:06,750
to linearize and second them in the

00:04:04,200 --> 00:04:10,290
stack which is for performance really

00:04:06,750 --> 00:04:12,090
bad so it's not just knife is that

00:04:10,290 --> 00:04:13,920
problem everybody who wants to for work

00:04:12,090 --> 00:04:19,140
sucks about packets will face this

00:04:13,920 --> 00:04:21,180
problem so question here is when we can

00:04:19,140 --> 00:04:23,340
find some contents build fair buffers

00:04:21,180 --> 00:04:26,520
for local receive and for more

00:04:23,340 --> 00:04:30,690
the commitment question was done by Eric

00:04:26,520 --> 00:04:36,570
de musset and I talked to him and he has

00:04:30,690 --> 00:04:39,419
already some so yeah we just measure

00:04:36,570 --> 00:04:43,980
patch to be able to limit the number of

00:04:39,419 --> 00:04:48,090
frag in TCP stack so the idea was to

00:04:43,980 --> 00:04:51,450
extend this the use of this control in a

00:04:48,090 --> 00:04:55,440
year or a year so you can limit the

00:04:51,450 --> 00:04:57,900
number of frag on the input pass so if

00:04:55,440 --> 00:04:59,970
you want to limit to ten just set this

00:04:57,900 --> 00:05:03,720
control to 10 so the default limit is

00:04:59,970 --> 00:05:10,380
being 17 normally this rag list should

00:05:03,720 --> 00:05:13,940
no longer be built anywhere by Jo so

00:05:10,380 --> 00:05:13,940
that basically you revert on this patch

00:05:15,889 --> 00:05:23,639
I'm totally okay with the proxy but at

00:05:21,720 --> 00:05:26,520
the same time that would mean that if we

00:05:23,639 --> 00:05:29,729
for example limit the number of skb of

00:05:26,520 --> 00:05:31,470
frags you're not able to use IPSec over

00:05:29,729 --> 00:05:34,440
other meteors anymore because the reason

00:05:31,470 --> 00:05:36,419
is like to provide an upper limit and it

00:05:34,440 --> 00:05:39,900
doesn't so it's a replacement for max

00:05:36,419 --> 00:05:41,850
for for the maximum and that doesn't

00:05:39,900 --> 00:05:45,950
really mean that you can now go beyond

00:05:41,850 --> 00:05:50,760
that maximum so probably we need to 12

00:05:45,950 --> 00:05:56,910
the idea is to no not anymore generated

00:05:50,760 --> 00:05:59,400
frag list now general I mean if the

00:05:56,910 --> 00:06:01,590
fretless is full we can fall back and

00:05:59,400 --> 00:06:05,340
copy the buffered us we can do always

00:06:01,590 --> 00:06:08,880
but I want really to writer so the idea

00:06:05,340 --> 00:06:17,460
is to have one slot free for that

00:06:08,880 --> 00:06:24,960
trailer and the way there was this issue

00:06:17,460 --> 00:06:27,600
with some remember if they had infinim

00:06:24,960 --> 00:06:29,230
um they wanted to add a frag like

00:06:27,600 --> 00:06:31,000
exactly the same

00:06:29,230 --> 00:06:33,400
then you they have the same problem of

00:06:31,000 --> 00:06:38,680
having to lien arise that's why they put

00:06:33,400 --> 00:06:42,580
this this patch you know into TCP stack

00:06:38,680 --> 00:06:44,080
to limit the number of fragment but that

00:06:42,580 --> 00:06:46,570
was only a part of the program because

00:06:44,080 --> 00:06:54,520
they were not addressing the earlier or

00:06:46,570 --> 00:07:11,830
the turn layer so it was the first start

00:06:54,520 --> 00:07:14,790
photo okay so and I would like to

00:07:11,830 --> 00:07:19,150
propose something more a drastic and

00:07:14,790 --> 00:07:22,210
then finding in your minute solution

00:07:19,150 --> 00:07:25,390
just for IPSec but something which will

00:07:22,210 --> 00:07:27,100
probably require to make much more

00:07:25,390 --> 00:07:29,500
drastic and vast changes in the Linux

00:07:27,100 --> 00:07:31,540
kernel but this is based on past

00:07:29,500 --> 00:07:33,310
experience with other operating system

00:07:31,540 --> 00:07:37,360
namely vxworks

00:07:33,310 --> 00:07:42,100
that I think that the best thing is to

00:07:37,360 --> 00:07:45,550
add kernel configuration option which

00:07:42,100 --> 00:07:48,910
would be reserved head and tail room for

00:07:45,550 --> 00:07:57,850
skb buffers for certain operations for

00:07:48,910 --> 00:08:00,070
example IPSec and okay and yes I didn't

00:07:57,850 --> 00:08:03,310
say it easy but I think that's a lot of

00:08:00,070 --> 00:08:05,170
a much more bigger investment right but

00:08:03,310 --> 00:08:08,950
I think it would pay off because I up

00:08:05,170 --> 00:08:12,370
hit the same problems writing a virtual

00:08:08,950 --> 00:08:15,330
kernel driver back three three and a

00:08:12,370 --> 00:08:15,330
half years ago and

00:08:26,320 --> 00:08:32,450
TCB same message you are allocating skb

00:08:29,630 --> 00:08:34,700
but you are putting the data in Franklin

00:08:32,450 --> 00:08:40,660
so the the tail room is no longer

00:08:34,700 --> 00:08:40,660
available for the crypto radio so anyway

00:08:44,260 --> 00:08:48,590
we're going to have tail room we have to

00:08:46,760 --> 00:08:50,360
pull the data out of the pages so the

00:08:48,590 --> 00:09:02,630
headers can be and that's what we want

00:08:50,360 --> 00:09:05,060
to avoid okay so let's continue next

00:09:02,630 --> 00:09:06,950
topic would be general receive offload

00:09:05,060 --> 00:09:11,000
we want to add the generic receive a

00:09:06,950 --> 00:09:14,210
float for IPSec and what we have to do

00:09:11,000 --> 00:09:17,240
we just have to add handles right beside

00:09:14,210 --> 00:09:20,240
protocols I did that code is there and

00:09:17,240 --> 00:09:22,340
it works pretty well I think there's

00:09:20,240 --> 00:09:25,490
well just one minor problem I see with

00:09:22,340 --> 00:09:27,950
that and that is because now the stat

00:09:25,490 --> 00:09:31,400
doesn't see itÃ­s at PAX anymore 2:30

00:09:27,950 --> 00:09:33,440
speedom just your critics packets and I

00:09:31,400 --> 00:09:38,720
decide that packs are completely gone

00:09:33,440 --> 00:09:41,540
from the RX / part so question is should

00:09:38,720 --> 00:09:44,470
we make this somehow configurable or can

00:09:41,540 --> 00:09:47,120
we just switch the default to 0

00:09:44,470 --> 00:09:49,550
I'm not sure how the users would react

00:09:47,120 --> 00:09:52,700
if you update your kernel and suddenly

00:09:49,550 --> 00:09:55,400
all the setbacks are done be a bad

00:09:52,700 --> 00:09:57,460
experience I don't know any thoughts on

00:09:55,400 --> 00:09:57,460
that

00:10:09,040 --> 00:10:13,970
well I think it would be rather drastic

00:10:12,079 --> 00:10:15,920
because also it effects of course the

00:10:13,970 --> 00:10:17,899
packet filtering rule sets and so on and

00:10:15,920 --> 00:10:19,699
and I think it effects basically all

00:10:17,899 --> 00:10:21,560
part of the user space setup so I

00:10:19,699 --> 00:10:23,089
understand why I want to do it but I

00:10:21,560 --> 00:10:26,750
think it has a huge potential of

00:10:23,089 --> 00:10:29,630
breaking a lot of configurations maybe

00:10:26,750 --> 00:10:33,920
for at least not not yet not behaving

00:10:29,630 --> 00:10:38,420
like the expected so I'm very I would be

00:10:33,920 --> 00:10:42,800
very careful with such changes I mean

00:10:38,420 --> 00:10:44,360
the performance is really huge no doubt

00:10:42,800 --> 00:10:46,430
no doubt but making it the default

00:10:44,360 --> 00:10:48,740
automatically yes sure that's why I'm

00:10:46,430 --> 00:10:51,259
asking I mean we could do it somehow

00:10:48,740 --> 00:10:53,690
configural maybe just that we push

00:10:51,259 --> 00:10:57,370
security Association to a device and

00:10:53,690 --> 00:10:59,990
only these security Association we do it

00:10:57,370 --> 00:11:02,000
can you explain why the stack does not

00:10:59,990 --> 00:11:07,940
see IPSec packets because I don't

00:11:02,000 --> 00:11:10,310
understand TCP time to tap us after we

00:11:07,940 --> 00:11:14,089
decrypt the passes if we do that left to

00:11:10,310 --> 00:11:16,579
zero handlers so we decrypt packets and

00:11:14,089 --> 00:11:20,810
maybe we aggregate these peoples of that

00:11:16,579 --> 00:11:23,329
and we push them up to the stack and tap

00:11:20,810 --> 00:11:25,220
for TCP dump it shortly before we enter

00:11:23,329 --> 00:11:29,630
layer three packets are already

00:11:25,220 --> 00:11:34,149
decrypted there yeah but you still see

00:11:29,630 --> 00:11:37,550
the packet okay

00:11:34,149 --> 00:11:40,670
so first thing I do want to set up and I

00:11:37,550 --> 00:11:47,360
but I mean when we use TCP dump on

00:11:40,670 --> 00:11:52,310
normal general packets TCP don't show a

00:11:47,360 --> 00:11:58,880
single packet so a single IP header or a

00:11:52,310 --> 00:12:04,399
single TCP header but maybe a little

00:11:58,880 --> 00:12:07,279
difference because well we should maybe

00:12:04,399 --> 00:12:09,260
you should know that sometimes I guess

00:12:07,279 --> 00:12:11,240
the problem basically is the tutorials

00:12:09,260 --> 00:12:14,000
short for a long time that you

00:12:11,240 --> 00:12:16,250
verify your IPSec is working that you

00:12:14,000 --> 00:12:23,390
can TCP dump on the interface and use a

00:12:16,250 --> 00:12:30,350
new speed and I think probably other

00:12:23,390 --> 00:12:34,420
people we do the same so I guess I agree

00:12:30,350 --> 00:12:37,640
with how I that it might be problematic

00:12:34,420 --> 00:12:40,760
there is one way to do that would be to

00:12:37,640 --> 00:12:42,649
by default on the door general but this

00:12:40,760 --> 00:12:48,260
is about zero for IPSec if the

00:12:42,649 --> 00:12:51,649
promiscuous flag is set or whatever we

00:12:48,260 --> 00:12:55,850
could push security associations to the

00:12:51,649 --> 00:12:57,860
network interface and we just do zero

00:12:55,850 --> 00:13:00,320
for the security Association they're

00:12:57,860 --> 00:13:04,339
present at a network interface or the

00:13:00,320 --> 00:13:08,270
user knows what it's doing so we have a

00:13:04,339 --> 00:13:10,250
similar setup today right with them like

00:13:08,270 --> 00:13:11,990
the exon or any kind of tunnel packet

00:13:10,250 --> 00:13:15,200
right we often have a separate adapter

00:13:11,990 --> 00:13:17,930
that gets the inner headers so you sniff

00:13:15,200 --> 00:13:20,240
on the outer headers if you sniff on the

00:13:17,930 --> 00:13:22,190
physical port and you get the inner

00:13:20,240 --> 00:13:24,800
headers if you sneak up on the VX land

00:13:22,190 --> 00:13:26,990
device right so could we if you need to

00:13:24,800 --> 00:13:28,250
do investigation or debug up the network

00:13:26,990 --> 00:13:30,350
I don't think it's unfair to say you

00:13:28,250 --> 00:13:32,720
have to do something extra when you're

00:13:30,350 --> 00:13:40,190
doing that you've exec with TSM 0 right

00:13:32,720 --> 00:13:41,510
so IPSec IPSec so um my question is I

00:13:40,190 --> 00:13:44,120
don't know if we could instantiate a

00:13:41,510 --> 00:13:47,089
debug device on the fly that would let

00:13:44,120 --> 00:13:50,120
you have the two layers it should you

00:13:47,089 --> 00:13:51,980
need them it's just a thought you know

00:13:50,120 --> 00:13:54,770
to do a separation of responsibilities

00:13:51,980 --> 00:13:57,890
right as it stands today if you turn off

00:13:54,770 --> 00:13:59,240
dro on the physical interface you know

00:13:57,890 --> 00:14:01,310
that's that's the spot where you turn

00:13:59,240 --> 00:14:03,020
the knob is on the physical interface

00:14:01,310 --> 00:14:04,820
then you just turn off to your Oh even

00:14:03,020 --> 00:14:06,350
though it's a stack thing you're the

00:14:04,820 --> 00:14:11,450
only place that you have a control is on

00:14:06,350 --> 00:14:13,459
the physical interface right so yeah or

00:14:11,450 --> 00:14:15,230
you just you know when you when you say

00:14:13,459 --> 00:14:16,760
I pealing create device something maybe

00:14:15,230 --> 00:14:18,560
it has the side effect of turning off

00:14:16,760 --> 00:14:21,279
the arrow on the physical device and so

00:14:18,560 --> 00:14:21,279
you get this debug

00:14:22,230 --> 00:14:25,350
or maybe we just make it dependent on

00:14:23,670 --> 00:14:28,230
the promised flag and in case we have

00:14:25,350 --> 00:14:30,620
promised you push both packets up at the

00:14:28,230 --> 00:14:33,540
stake so we just copies IPSec one and

00:14:30,620 --> 00:14:35,600
make it like a debug framing escapee and

00:14:33,540 --> 00:14:38,280
drop it after it received the AF packet

00:14:35,600 --> 00:14:40,230
handler that might also be like

00:14:38,280 --> 00:14:42,630
affecting in future we have probably

00:14:40,230 --> 00:14:45,540
offloading for IPSec and I guess that

00:14:42,630 --> 00:14:48,570
people also want to like edit Li debug

00:14:45,540 --> 00:14:54,780
the receiving frames even so offloading

00:14:48,570 --> 00:14:57,360
is an effect I think region I'm gonna

00:14:54,780 --> 00:15:00,870
drag this too long and sorry I think it

00:14:57,360 --> 00:15:02,790
I mean we have educated users for a

00:15:00,870 --> 00:15:04,770
decade now that they will not see the

00:15:02,790 --> 00:15:07,770
decrypted packets on IPSec and this is

00:15:04,770 --> 00:15:10,530
the way how things should behave and I

00:15:07,770 --> 00:15:13,170
mean doing a change okay nice and good

00:15:10,530 --> 00:15:14,820
but it would be very different from what

00:15:13,170 --> 00:15:18,800
people have been used to ever since

00:15:14,820 --> 00:15:18,800
IPSec was integrated into the mainline

00:15:24,680 --> 00:15:29,400
yeah but it's as a user you don't

00:15:26,850 --> 00:15:38,240
explicitly do something to enable you

00:15:29,400 --> 00:15:38,240
specifically choose the heart knows what

00:15:40,070 --> 00:15:50,520
okay so let's continue so let's move on

00:15:47,910 --> 00:15:54,510
to the transmitted part we want to do

00:15:50,520 --> 00:15:57,780
DSL for a sec - so actually we have

00:15:54,510 --> 00:15:59,490
already yourself for transforms but

00:15:57,780 --> 00:16:01,560
itself it happens really early at

00:15:59,490 --> 00:16:04,980
transforms layer so what we want to do

00:16:01,560 --> 00:16:07,530
is now we want to move to existing geo

00:16:04,980 --> 00:16:09,750
though code path from the transforms

00:16:07,530 --> 00:16:12,120
layer to the generic geo layer at layer

00:16:09,750 --> 00:16:14,700
to crosstown we have longer the big

00:16:12,120 --> 00:16:19,110
packets and a stack and don't need to

00:16:14,700 --> 00:16:22,410
process each small path packet so how to

00:16:19,110 --> 00:16:24,600
do this well the idea is that we just do

00:16:22,410 --> 00:16:26,850
the tunnel and or transport mode and

00:16:24,600 --> 00:16:29,880
capsulation at the transport layer and

00:16:26,850 --> 00:16:33,630
we just add a dummy if P error that well

00:16:29,880 --> 00:16:36,050
the practice Marcus ESP and after that

00:16:33,630 --> 00:16:38,720
we do well we pushed package

00:16:36,050 --> 00:16:41,660
the big packet an encrypted down the

00:16:38,720 --> 00:16:44,089
stack and at the geocell layer we add

00:16:41,660 --> 00:16:47,480
fuli's Pierrot informations and do the

00:16:44,089 --> 00:16:49,610
decryption Zanna segments there so I

00:16:47,480 --> 00:16:53,839
have code for that tool where it's in

00:16:49,610 --> 00:16:55,970
some cases but there are problems so one

00:16:53,839 --> 00:16:57,829
of the problem is how to handle a

00:16:55,970 --> 00:16:58,549
synchronous crypto operations and the G

00:16:57,829 --> 00:17:00,829
is all there

00:16:58,549 --> 00:17:05,779
the G so Larry isn't prepared for that

00:17:00,829 --> 00:17:08,390
at all so well I actually I don't

00:17:05,779 --> 00:17:11,419
exactly know how to do that and then

00:17:08,390 --> 00:17:14,000
immediately our question what came to my

00:17:11,419 --> 00:17:17,809
mind was I mean what are we doing when

00:17:14,000 --> 00:17:20,059
the NIC driver says it's busy after as

00:17:17,809 --> 00:17:22,189
in transcript operation so now we have

00:17:20,059 --> 00:17:26,299
some packet and we have to do something

00:17:22,189 --> 00:17:31,159
with that so what I mean I can offer

00:17:26,299 --> 00:17:34,100
some possible solutions on that so for

00:17:31,159 --> 00:17:36,830
question one one thing that came to my

00:17:34,100 --> 00:17:39,500
mind as well just at callbacks for each

00:17:36,830 --> 00:17:42,320
gso handler but when I start a movement

00:17:39,500 --> 00:17:44,779
that I immediately noticed that well we

00:17:42,320 --> 00:17:46,970
have to act really for each and every

00:17:44,779 --> 00:17:51,020
protocol handler callback and that's not

00:17:46,970 --> 00:17:54,500
going to work I mean this awful so I

00:17:51,020 --> 00:17:57,080
thought well what else can we do so next

00:17:54,500 --> 00:18:00,169
thing came to mind maybe we could use

00:17:57,080 --> 00:18:05,659
some kind of cryptic you disk just would

00:18:00,169 --> 00:18:08,500
answer both questions but it's not

00:18:05,659 --> 00:18:11,480
really what I wanted to have there and

00:18:08,500 --> 00:18:13,659
cubics usually are configurable and that

00:18:11,480 --> 00:18:19,580
one would definitely not be configurable

00:18:13,659 --> 00:18:21,679
so I skipped this and next thing what I

00:18:19,580 --> 00:18:24,380
thought what we could do is well we

00:18:21,679 --> 00:18:27,740
could just handle the encapsulation at

00:18:24,380 --> 00:18:29,690
the GSO layer for the segments and if

00:18:27,740 --> 00:18:31,909
you returned from geo so we do the

00:18:29,690 --> 00:18:35,120
crypto operations in this case we can

00:18:31,909 --> 00:18:38,510
handle as in transcript or so just would

00:18:35,120 --> 00:18:42,470
answer question 1 but not question 2 so

00:18:38,510 --> 00:18:45,320
looking at question 2 one thing what we

00:18:42,470 --> 00:18:47,960
could do we could just and here to pack

00:18:45,320 --> 00:18:49,460
the Gantt ridiculous but then we run

00:18:47,960 --> 00:18:49,940
again the whole queue displayer we

00:18:49,460 --> 00:18:52,370
account

00:18:49,940 --> 00:18:55,420
pack twice the key risk and it's

00:18:52,370 --> 00:19:00,890
probably not a really good solution

00:18:55,420 --> 00:19:03,530
so what else we could for example take a

00:19:00,890 --> 00:19:06,230
separate queue and process it with the

00:19:03,530 --> 00:19:10,490
TX often that's how I currently

00:19:06,230 --> 00:19:13,400
implemented it and it sort of works so

00:19:10,490 --> 00:19:24,310
these are my solutions I had to that but

00:19:13,400 --> 00:19:37,280
maybe so a synchronous crypto means that

00:19:24,310 --> 00:19:39,950
the crypto operation and I mean its head

00:19:37,280 --> 00:19:44,930
of line blocking right the GST operation

00:19:39,950 --> 00:19:48,230
happens after the DQ disc while you are

00:19:44,930 --> 00:19:51,830
supposed to to put the data on the real

00:19:48,230 --> 00:19:54,740
device so if you take a lot of time to

00:19:51,830 --> 00:19:56,450
perform the operation you have an ID or

00:19:54,740 --> 00:20:02,230
device you don't send anything on the

00:19:56,450 --> 00:20:02,230
device I don't think

00:20:04,750 --> 00:20:10,909
as internal scrupulous for example if

00:20:07,730 --> 00:20:13,549
you use enough and I and a few you and

00:20:10,909 --> 00:20:16,519
it is not free then it kills us to work

00:20:13,549 --> 00:20:18,649
you and tells you that it does the

00:20:16,519 --> 00:20:22,340
crypto operation lighter and you have to

00:20:18,649 --> 00:20:24,799
handle the phone would it make sense to

00:20:22,340 --> 00:20:26,510
just remove awesome coolness hooked

00:20:24,799 --> 00:20:28,909
operation speed that makes them

00:20:26,510 --> 00:20:32,600
synchronous by so I know for example

00:20:28,909 --> 00:20:34,700
that recent into into chips like have a

00:20:32,600 --> 00:20:37,789
faster epics safe and ethics Vista

00:20:34,700 --> 00:20:40,730
operation so you basically disable

00:20:37,789 --> 00:20:44,899
preemption force the FP who state out

00:20:40,730 --> 00:20:46,880
into some scratch space process like 64

00:20:44,899 --> 00:20:50,380
packets and then to the ethics restore

00:20:46,880 --> 00:20:54,190
and able preemption and send that out I

00:20:50,380 --> 00:20:56,809
mean would require changes there

00:20:54,190 --> 00:21:00,860
probably makes more sense to me than all

00:20:56,809 --> 00:21:02,809
of your possible solution so I think the

00:21:00,860 --> 00:21:04,149
problem here is that the GSO failure

00:21:02,809 --> 00:21:08,720
runs

00:21:04,149 --> 00:21:11,450
pH so we broke the bottom health I'm not

00:21:08,720 --> 00:21:20,299
sure you can do all this stuff anyway

00:21:11,450 --> 00:21:22,100
because back to work you even so I just

00:21:20,299 --> 00:21:26,120
have to continue somehow and I need to

00:21:22,100 --> 00:21:30,169
call that from the crypto layer if I do

00:21:26,120 --> 00:21:34,159
it the way that I just do the

00:21:30,169 --> 00:21:36,799
encapsulation for the set nuns at Jesus

00:21:34,159 --> 00:21:39,440
oh and then I wait until all combats are

00:21:36,799 --> 00:21:42,409
done and after that I mean it I mean you

00:21:39,440 --> 00:21:49,760
cannot wait here in Europe you're not

00:21:42,409 --> 00:21:51,230
supposed rest I just do well I push it

00:21:49,760 --> 00:21:52,610
to the crypto layer and then I process

00:21:51,230 --> 00:21:58,659
the next part that and wait what the

00:21:52,610 --> 00:21:58,659
crypto layers do it works but it's not

00:22:02,529 --> 00:22:06,529
exactly the right person is entering at

00:22:04,970 --> 00:22:09,590
the right point in time because I would

00:22:06,529 --> 00:22:11,659
wonder if doing it at that late point

00:22:09,590 --> 00:22:13,940
where actually the cutest already wants

00:22:11,659 --> 00:22:15,549
to push the package of the device adding

00:22:13,940 --> 00:22:17,350
additional D later I think is

00:22:15,549 --> 00:22:19,299
just a cosmetic or additional a

00:22:17,350 --> 00:22:22,210
synchronicity is not just a cosmetic

00:22:19,299 --> 00:22:24,220
issue but it basically confuses the

00:22:22,210 --> 00:22:26,470
entire Q discipline and the scheduling

00:22:24,220 --> 00:22:27,730
of outbound packets so I'm wondering

00:22:26,470 --> 00:22:31,950
whether this is really something that

00:22:27,730 --> 00:22:33,970
should be done at this point or not I

00:22:31,950 --> 00:22:36,009
understand why you want to do it but

00:22:33,970 --> 00:22:37,840
still it upsets any but the most basic

00:22:36,009 --> 00:22:42,279
scheduling that you want to do with the

00:22:37,840 --> 00:22:45,249
packets and on the transmitted path may

00:22:42,279 --> 00:22:49,179
be one idea would be to make the GSO

00:22:45,249 --> 00:22:52,259
stuff for crypto or a synchronous before

00:22:49,179 --> 00:22:54,639
the in queueing on the cuties

00:22:52,259 --> 00:22:57,100
because you are in process context and

00:22:54,639 --> 00:23:01,090
you can do whatever we want and it

00:22:57,100 --> 00:23:04,659
doesn't prevent other threats from the

00:23:01,090 --> 00:23:10,690
idea of the crypto something in front of

00:23:04,659 --> 00:23:14,109
the cutest do everything and push it we

00:23:10,690 --> 00:23:15,970
want J so you know to avoid traversing

00:23:14,109 --> 00:23:20,139
the IP stack and might not be drawers

00:23:15,970 --> 00:23:22,749
like for every single emesis the cubic

00:23:20,139 --> 00:23:30,220
stuff itself from nodes are you doing

00:23:22,749 --> 00:23:32,080
here it is for sure but it's not if it's

00:23:30,220 --> 00:23:35,460
based things absolutely a nightmare

00:23:32,080 --> 00:23:35,460
world you know

00:23:41,650 --> 00:23:48,430
I would like to offer a different point

00:23:44,560 --> 00:23:53,500
of view application which are real time

00:23:48,430 --> 00:23:56,590
sensitive you do have some kind of

00:23:53,500 --> 00:23:58,900
challenge working with Linux and some of

00:23:56,590 --> 00:24:03,730
these challenges have been addressed by

00:23:58,900 --> 00:24:06,460
the RT patch and I think we have to be a

00:24:03,730 --> 00:24:09,820
little bit careful when we introduce

00:24:06,460 --> 00:24:12,520
changes which might make blocking at the

00:24:09,820 --> 00:24:17,770
bottom half for a long time or awful

00:24:12,520 --> 00:24:20,710
things too soft I refuse which in turn

00:24:17,770 --> 00:24:25,030
and make the next RT patch even more

00:24:20,710 --> 00:24:28,690
challenging and we might want to I know

00:24:25,030 --> 00:24:30,910
once again I'm probably offering maybe

00:24:28,690 --> 00:24:34,360
some more drastic change the Linux

00:24:30,910 --> 00:24:36,820
kernel but I think we do have to you

00:24:34,360 --> 00:24:38,980
know take an open mind the approach and

00:24:36,820 --> 00:24:41,800
consider doing things a little bit

00:24:38,980 --> 00:24:44,500
differently maybe offering things to

00:24:41,800 --> 00:24:46,930
kernel threads so you know we won't have

00:24:44,500 --> 00:24:49,690
blocking at the bottom half and they

00:24:46,930 --> 00:24:51,700
won't ever know all kind of flow time

00:24:49,690 --> 00:24:53,980
applications like voice having a

00:24:51,700 --> 00:24:58,650
deterrent delay yeah I know it's once

00:24:53,980 --> 00:25:01,840
again a very big change in how the

00:24:58,650 --> 00:25:03,760
linings ferrule networking works but at

00:25:01,840 --> 00:25:05,980
least maybe for this specific case I

00:25:03,760 --> 00:25:07,500
think we should you know at least give

00:25:05,980 --> 00:25:09,730
it a thought you can always know

00:25:07,500 --> 00:25:13,390
disqualify it after thinking for five

00:25:09,730 --> 00:25:15,550
minutes but you know that I think that

00:25:13,390 --> 00:25:17,530
the alternative that going for in our

00:25:15,550 --> 00:25:19,920
software queue bottom half approach or

00:25:17,530 --> 00:25:22,510
long blocking and then having a lot of

00:25:19,920 --> 00:25:25,570
problems with written applications are

00:25:22,510 --> 00:25:31,270
having to make another patch which will

00:25:25,570 --> 00:25:33,670
be very difficult to integrate and we

00:25:31,270 --> 00:25:36,490
exit immediately after offloading the

00:25:33,670 --> 00:25:39,700
operation so crypto we had said but

00:25:36,490 --> 00:25:42,330
anyway we keep it configurable so use

00:25:39,700 --> 00:25:42,330
real time

00:25:44,150 --> 00:25:50,520
yeah I'm just you know talking about

00:25:47,370 --> 00:25:56,160
suggestion here and possible solution q2

00:25:50,520 --> 00:26:00,480
at the bottoms or on Franco let's move

00:25:56,160 --> 00:26:02,550
on close sometime so wanted to present

00:26:00,480 --> 00:26:05,220
some performance numbers what we got I

00:26:02,550 --> 00:26:07,950
mean the numbers were shown already

00:26:05,220 --> 00:26:10,500
yesterday and so in his talk she

00:26:07,950 --> 00:26:12,570
measured transport performance I'm

00:26:10,500 --> 00:26:15,300
startled by the baseline what we

00:26:12,570 --> 00:26:16,950
currently get and here we get two points

00:26:15,300 --> 00:26:18,870
it's deep it's per second if we just

00:26:16,950 --> 00:26:23,580
manage that performance without crypto

00:26:18,870 --> 00:26:27,690
if we use crypto we're at 2.10 per

00:26:23,580 --> 00:26:31,620
second so if we add our changes with it

00:26:27,690 --> 00:26:34,020
recently we increase from two point six

00:26:31,620 --> 00:26:36,420
G bit presence to AG bit per sentence

00:26:34,020 --> 00:26:38,970
pure staff performance what is what I

00:26:36,420 --> 00:26:41,100
think the huge improvement and even for

00:26:38,970 --> 00:26:42,810
the crypto case we can double the

00:26:41,100 --> 00:26:47,760
performance with that so I think it's

00:26:42,810 --> 00:26:49,590
worth to consider this since so and then

00:26:47,760 --> 00:26:51,480
we looked at a bottlenecks where they

00:26:49,590 --> 00:26:53,220
are now so if you just know stack

00:26:51,480 --> 00:26:55,620
performance the bottlenecks are the

00:26:53,220 --> 00:26:58,230
second duration and checksumming of the

00:26:55,620 --> 00:26:59,550
segments and if you decrypt oh well

00:26:58,230 --> 00:27:02,010
that's pretty clear crypto is the

00:26:59,550 --> 00:27:06,060
bottleneck if you look at these two

00:27:02,010 --> 00:27:08,040
bottlenecks then it comes to your what

00:27:06,060 --> 00:27:11,160
are the next steps so we have to somehow

00:27:08,040 --> 00:27:13,890
move segmentation and operations away

00:27:11,160 --> 00:27:17,400
from the network and CPUs so how to do

00:27:13,890 --> 00:27:20,280
that well I can offer two solutions one

00:27:17,400 --> 00:27:23,070
that what I'm doing currently I separate

00:27:20,280 --> 00:27:26,430
into networking and crypto CPUs with the

00:27:23,070 --> 00:27:28,860
parallel crypto template this where it's

00:27:26,430 --> 00:27:31,110
kind of good but it helps only

00:27:28,860 --> 00:27:35,130
unencrypted bottleneck the segmentation

00:27:31,110 --> 00:27:39,840
remains other solution rule would be to

00:27:35,130 --> 00:27:41,940
ask hardware to do IPSec operations that

00:27:39,840 --> 00:27:45,090
would solve the segmentation and decrypt

00:27:41,940 --> 00:27:48,690
the bottleneck and exactly does this

00:27:45,090 --> 00:27:51,720
leads to the next topic we want to add

00:27:48,690 --> 00:27:55,170
somehow Hardware offload for IPSec so

00:27:51,720 --> 00:27:57,870
how should just be done well here

00:27:55,170 --> 00:28:01,650
I'm basically free all I want to have is

00:27:57,870 --> 00:28:04,140
that the API is using should be pretty

00:28:01,650 --> 00:28:07,290
close or save further after Jesus owed

00:28:04,140 --> 00:28:08,760
zero API we're using and the stack

00:28:07,290 --> 00:28:09,930
because I want to consider this as a

00:28:08,760 --> 00:28:13,710
software fallback

00:28:09,930 --> 00:28:15,960
so question would be how should the API

00:28:13,710 --> 00:28:19,200
for IPSec Hardware floats should look

00:28:15,960 --> 00:28:25,920
like or more general what would Nick

00:28:19,200 --> 00:28:27,210
driver need from stack so but here I

00:28:25,920 --> 00:28:30,720
would need input from the driver

00:28:27,210 --> 00:28:46,140
developers when anyone wants to speak up

00:28:30,720 --> 00:28:48,450
here high-polished fluminox will walk in

00:28:46,140 --> 00:28:52,280
consume my IPSec offloads at the moment

00:28:48,450 --> 00:28:55,800
and what we would require from the stack

00:28:52,280 --> 00:28:58,340
is two things

00:28:55,800 --> 00:29:03,440
the first is an ability to mark

00:28:58,340 --> 00:29:03,440
decrypted packets so IPSec

00:29:03,950 --> 00:29:09,270
so I decide wouldn't decrypt and

00:29:06,360 --> 00:29:14,970
wouldn't attempt to the crypt and the

00:29:09,270 --> 00:29:18,650
second thing is the ability to mark the

00:29:14,970 --> 00:29:21,420
si has floated so we could recognize

00:29:18,650 --> 00:29:25,260
that we have it in the hardware and

00:29:21,420 --> 00:29:27,000
deleted edit push down somehow the

00:29:25,260 --> 00:29:32,150
security association to the hardware

00:29:27,000 --> 00:29:32,150
here but not policies right right

00:30:04,809 --> 00:30:10,960
okay first of all I mean that's comment

00:30:09,200 --> 00:30:14,360
yesterday I would like to repeat that

00:30:10,960 --> 00:30:17,419
here all flow does not have to be to a

00:30:14,360 --> 00:30:20,690
Knick driver once again and I think into

00:30:17,419 --> 00:30:25,039
has representative in in this conference

00:30:20,690 --> 00:30:27,409
but Intel has to offload shapes called

00:30:25,039 --> 00:30:29,510
Cave Creek and Kawada Creek which it is

00:30:27,409 --> 00:30:33,440
pure offload without Nicks so you can

00:30:29,510 --> 00:30:36,559
take the buffer son it to the encryption

00:30:33,440 --> 00:30:41,230
or decryption hardware and get a result

00:30:36,559 --> 00:30:44,090
back and does not involve any any need

00:30:41,230 --> 00:30:49,070
so I think that should be separate as

00:30:44,090 --> 00:30:51,590
well only helps if we can do TFO and

00:30:49,070 --> 00:30:53,840
crypto so we have to push a big packets

00:30:51,590 --> 00:31:00,679
to the network card because we have to

00:30:53,840 --> 00:31:02,450
segment before we do the crypto we talk

00:31:00,679 --> 00:31:10,940
- how about Zoo because he's been doing

00:31:02,450 --> 00:31:18,770
the Intel devices how about I considered

00:31:10,940 --> 00:31:20,480
even if you try to think even see the

00:31:18,770 --> 00:31:23,120
whole idea of having the crypto

00:31:20,480 --> 00:31:26,840
dominique is that you avoid the passing

00:31:23,120 --> 00:31:29,000
the PCI bus twice wants to send the

00:31:26,840 --> 00:31:32,450
packet to the crypto and shine then

00:31:29,000 --> 00:31:34,429
three times so that's are you doing so

00:31:32,450 --> 00:31:38,000
you cannot say oh it just use a crypto

00:31:34,429 --> 00:31:41,539
and I'm on dedicated hardware it's

00:31:38,000 --> 00:31:45,470
better to use that it's faster three

00:31:41,539 --> 00:31:48,350
times faster once again this is very

00:31:45,470 --> 00:31:51,470
system dependent because some systems

00:31:48,350 --> 00:31:54,799
are limited by CP resources and not by a

00:31:51,470 --> 00:31:58,669
I have PCI Express resources you have

00:31:54,799 --> 00:32:01,669
system which am like perhaps 16 lines of

00:31:58,669 --> 00:32:04,820
Gentry which is a lot a lot of bandwidth

00:32:01,669 --> 00:32:07,549
but rich ate your hundred percent safe

00:32:04,820 --> 00:32:10,789
utilizations so you're not worried about

00:32:07,549 --> 00:32:17,419
the last of Iowa bandwidth but you

00:32:10,789 --> 00:32:20,149
worried about awfully CPU maybe we can

00:32:17,419 --> 00:32:27,669
talk offline for a topic later I think a

00:32:20,149 --> 00:32:31,519
couple of people want to meet so if one

00:32:27,669 --> 00:32:34,669
final topic it was this was we are still

00:32:31,519 --> 00:32:38,450
some read/write loves in transforms code

00:32:34,669 --> 00:32:40,039
was proposed from Eric also topic not

00:32:38,450 --> 00:32:43,599
sure if you want to talk too much about

00:32:40,039 --> 00:32:46,959
it I think it just needs a volunteer

00:32:43,599 --> 00:32:46,959

YouTube URL: https://www.youtube.com/watch?v=JSbU5YE8Hc0


