Title: Netdev 1.1 - Bridge filtering with nftables
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 2 - Thursday February 11, 2016
Description: 
	Florian Westphal
February 2016
Captions: 
	00:00:00,000 --> 00:00:06,420
so I would like to talk a bit about

00:00:02,389 --> 00:00:08,880
filtering on Linux bridges as an

00:00:06,420 --> 00:00:10,380
introduction I would first like to

00:00:08,880 --> 00:00:13,920
review what we currently have in place

00:00:10,380 --> 00:00:16,560
in the colonel so the bridge module

00:00:13,920 --> 00:00:21,000
basically just like the inet an ipv6

00:00:16,560 --> 00:00:23,850
deck places a couple of foot points at

00:00:21,000 --> 00:00:26,279
strategic places and the bridge path for

00:00:23,850 --> 00:00:28,230
instance we have a bridge pre routing

00:00:26,279 --> 00:00:31,710
which is a bit of a misnomer cuz it

00:00:28,230 --> 00:00:33,300
should actually be a pre bridging code

00:00:31,710 --> 00:00:38,040
because the obviously doesn't do

00:00:33,300 --> 00:00:41,219
routing and just like the I needs deck

00:00:38,040 --> 00:00:44,550
we can register callbacks that are

00:00:41,219 --> 00:00:46,980
invoked at these locations and callbacks

00:00:44,550 --> 00:00:48,899
can then decide on what to do with the

00:00:46,980 --> 00:00:53,129
packet just something like dropping or

00:00:48,899 --> 00:00:55,230
continuing on to the next rule this is

00:00:53,129 --> 00:00:58,170
an overview we have five hooks just like

00:00:55,230 --> 00:01:01,129
with ipv4 ipv6 the only major difference

00:00:58,170 --> 00:01:04,320
is that if in the case of local delivery

00:01:01,129 --> 00:01:06,840
the packet will obviously end up in the

00:01:04,320 --> 00:01:08,790
ipv4 ipv6 deck first and we will also

00:01:06,840 --> 00:01:15,000
traverse the IP tables or artistic

00:01:08,790 --> 00:01:17,250
stables or NF tables IP rules the

00:01:15,000 --> 00:01:18,960
current state was EB tables which is the

00:01:17,250 --> 00:01:21,810
old tool that we have in place for

00:01:18,960 --> 00:01:23,880
filtering as basically it was cloned off

00:01:21,810 --> 00:01:26,130
iptables more than a decade ago and

00:01:23,880 --> 00:01:28,829
hasn't seen a lot of development since

00:01:26,130 --> 00:01:29,970
then it only has a couple of stateless

00:01:28,829 --> 00:01:32,040
mattress for instance you can mention

00:01:29,970 --> 00:01:35,070
VLAN ID or the packet type or the packet

00:01:32,040 --> 00:01:36,630
mark and it has some rudimentary support

00:01:35,070 --> 00:01:40,799
for stateless network address

00:01:36,630 --> 00:01:42,360
translation on the mac addresses there

00:01:40,799 --> 00:01:44,240
are no stateful matches there is no

00:01:42,360 --> 00:01:47,189
connection tracking nothing at all and

00:01:44,240 --> 00:01:49,200
even worse the eb tables code can't even

00:01:47,189 --> 00:01:51,509
call into generic x table targets are

00:01:49,200 --> 00:01:53,159
modules so all the functionality to do

00:01:51,509 --> 00:01:55,290
that you want an EBT abels you have to

00:01:53,159 --> 00:01:59,939
copy and paste into the into an eb

00:01:55,290 --> 00:02:01,710
tables module what we do have instead is

00:01:59,939 --> 00:02:03,299
something that's called call iptables

00:02:01,710 --> 00:02:07,110
there is a module called bridge

00:02:03,299 --> 00:02:09,090
netfilter and if you load that and you

00:02:07,110 --> 00:02:11,290
can tell the bridge code to do an up

00:02:09,090 --> 00:02:15,040
call into the generic IP or I

00:02:11,290 --> 00:02:16,780
six netfilter code pass the upside is

00:02:15,040 --> 00:02:18,640
that we gain access to all the

00:02:16,780 --> 00:02:20,829
functionality that we have in iptables

00:02:18,640 --> 00:02:24,099
Winston's connection tracking and

00:02:20,829 --> 00:02:25,659
network address translation but the

00:02:24,099 --> 00:02:27,720
downside is that there are actually many

00:02:25,659 --> 00:02:30,459
many problems with that approach

00:02:27,720 --> 00:02:32,890
especially some subdue race conditions

00:02:30,459 --> 00:02:35,170
and other things because obviously in

00:02:32,890 --> 00:02:37,329
div before netfilter pass assumes that

00:02:35,170 --> 00:02:39,760
it's called from the IP pass and from

00:02:37,329 --> 00:02:42,040
the bridge pass so we have to do save

00:02:39,760 --> 00:02:43,989
and restore operations on the escapee

00:02:42,040 --> 00:02:46,530
control buffer because it's owned by the

00:02:43,989 --> 00:02:49,150
bridge layer and not by the inet layer

00:02:46,530 --> 00:02:51,669
there are some usability issues for

00:02:49,150 --> 00:02:53,230
instance in eb tables the input

00:02:51,669 --> 00:02:55,389
interface is to bridgeport and in

00:02:53,230 --> 00:02:59,439
iptables it will be the bridge itself so

00:02:55,389 --> 00:03:05,379
the logical interface there's met feelin

00:02:59,439 --> 00:03:08,379
is very messy because to do belong up

00:03:05,379 --> 00:03:10,689
calls we have to to remove to VLAN

00:03:08,379 --> 00:03:13,139
header and software from the bridge net

00:03:10,689 --> 00:03:15,729
further module and do the up call

00:03:13,139 --> 00:03:17,859
because the router it does not care what

00:03:15,729 --> 00:03:20,530
we learn is or what ethernet is it only

00:03:17,859 --> 00:03:23,169
looks at the network and transport

00:03:20,530 --> 00:03:25,840
headers so if you wanted to VLAN header

00:03:23,169 --> 00:03:27,459
on a villain filtering on a a namorada

00:03:25,840 --> 00:03:30,909
you would just look at the input

00:03:27,459 --> 00:03:38,049
interface name and not care what the

00:03:30,909 --> 00:03:40,329
actual type is connection tracking is

00:03:38,049 --> 00:03:41,590
supported or available with cisco IP

00:03:40,329 --> 00:03:43,989
tables and the good news is it will

00:03:41,590 --> 00:03:45,849
actually work unless there are some

00:03:43,989 --> 00:03:47,829
special cases involved so for instance

00:03:45,849 --> 00:03:50,349
it will not really work if you have

00:03:47,829 --> 00:03:52,569
different bridges or be lands that share

00:03:50,349 --> 00:03:56,669
overlapping IP addresses because

00:03:52,569 --> 00:04:06,220
contract has no notion of interfaces or

00:03:56,669 --> 00:04:07,900
different VLAN IDs so if you do it there

00:04:06,220 --> 00:04:09,909
will be problems because we will

00:04:07,900 --> 00:04:11,259
erroneously match packets as established

00:04:09,909 --> 00:04:12,699
even if they are from a completely

00:04:11,259 --> 00:04:14,500
unrelated connection because to the

00:04:12,699 --> 00:04:18,130
contract engine it will look as if they

00:04:14,500 --> 00:04:21,400
are the same when they are not if you

00:04:18,130 --> 00:04:23,130
use n fq then you will basically always

00:04:21,400 --> 00:04:26,289
get Colonel crashes sooner than later

00:04:23,130 --> 00:04:30,430
because with a nephew that means the

00:04:26,289 --> 00:04:34,930
Pakatan will be will be checked as in

00:04:30,430 --> 00:04:36,789
crow mostly and unfortunately the design

00:04:34,930 --> 00:04:39,880
of the contract engine takes advantage

00:04:36,789 --> 00:04:42,009
of certain things that will never happen

00:04:39,880 --> 00:04:43,630
in a router but it will happen in a

00:04:42,009 --> 00:04:45,550
bridge for instance when packets have to

00:04:43,630 --> 00:04:52,569
be flooded to several reports at once

00:04:45,550 --> 00:04:54,490
and we just clone escapees and we also

00:04:52,569 --> 00:04:56,080
have very ugly code to cope with network

00:04:54,490 --> 00:04:58,270
address translation in the bridge so for

00:04:56,080 --> 00:05:00,160
instance if the bridge bridge net

00:04:58,270 --> 00:05:04,270
whittaker detects that the IP address

00:05:00,160 --> 00:05:06,789
has changed it has to do look up of of

00:05:04,270 --> 00:05:08,949
the neighbor cache took very for a new

00:05:06,789 --> 00:05:10,150
destination MAC address and things like

00:05:08,949 --> 00:05:13,840
that so we have all these layering

00:05:10,150 --> 00:05:18,159
violations was invoking routing routing

00:05:13,840 --> 00:05:22,599
code from the bridge and furthermore to

00:05:18,159 --> 00:05:25,360
cope with all of this the escaping skb

00:05:22,599 --> 00:05:27,430
data structure has an extra pointer to

00:05:25,360 --> 00:05:30,430
store various extra information such

00:05:27,430 --> 00:05:34,000
such as the bridge in port bridge out

00:05:30,430 --> 00:05:36,430
port and some scratched space to store

00:05:34,000 --> 00:05:38,560
original headers that are only used

00:05:36,430 --> 00:05:40,539
because of this call iptables more than

00:05:38,560 --> 00:05:42,610
we could just remove that as well if we

00:05:40,539 --> 00:05:47,620
could find a way to do without call

00:05:42,610 --> 00:05:48,699
every tables and so in summary if you

00:05:47,620 --> 00:05:51,219
want to do filtering on a bridge you

00:05:48,699 --> 00:05:52,930
basically always have to do both EB

00:05:51,219 --> 00:05:54,490
tables and iptables because they are

00:05:52,930 --> 00:05:58,389
basically completely testing feature

00:05:54,490 --> 00:06:00,219
sets we have long-standing stability

00:05:58,389 --> 00:06:03,039
problems that really can't fix other

00:06:00,219 --> 00:06:04,690
than adding extra locking to contract

00:06:03,039 --> 00:06:06,520
itself which is praying that because

00:06:04,690 --> 00:06:10,320
it's not this locking is not needed for

00:06:06,520 --> 00:06:10,320
the normal route in case and

00:06:10,680 --> 00:06:14,800
traditionally the net filter hooks are

00:06:12,969 --> 00:06:18,520
always / network name space and not

00:06:14,800 --> 00:06:22,690
Britt not preparatory interface so if

00:06:18,520 --> 00:06:25,330
you have a system that has a lot of

00:06:22,690 --> 00:06:28,090
virtual machines and you have 100 or 200

00:06:25,330 --> 00:06:30,159
pictures and you only need filtering on

00:06:28,090 --> 00:06:32,169
a single bridge then all packets that

00:06:30,159 --> 00:06:35,550
reverse any bridge will pay the extra

00:06:32,169 --> 00:06:35,550
hook invocation overhead

00:06:37,630 --> 00:06:46,160
so there are two major features that are

00:06:42,080 --> 00:06:50,870
missing for men of tables 2 for the NF

00:06:46,160 --> 00:06:52,640
tables bread family one is n fq and if Q

00:06:50,870 --> 00:06:55,430
means that you can pass a packet to use

00:06:52,640 --> 00:06:56,960
the space via a knitting socket and then

00:06:55,430 --> 00:06:59,510
use the space can drop or accept the

00:06:56,960 --> 00:07:02,840
packet as synchronously you can also

00:06:59,510 --> 00:07:06,470
rewrite or replace packet payload and if

00:07:02,840 --> 00:07:08,500
Q itself is a family agnostic but there

00:07:06,470 --> 00:07:11,300
is a back-end connect connected to it

00:07:08,500 --> 00:07:14,150
that is currently limited to IP one or

00:07:11,300 --> 00:07:16,580
end ipv6 because the back end has to do

00:07:14,150 --> 00:07:18,290
things like check if you space change

00:07:16,580 --> 00:07:21,500
the IP address and then it has to do

00:07:18,290 --> 00:07:23,270
rerouting and things like that from a

00:07:21,500 --> 00:07:24,980
user space point of view you basically

00:07:23,270 --> 00:07:26,510
get a net link message with some

00:07:24,980 --> 00:07:29,300
attributes such as the family or the

00:07:26,510 --> 00:07:31,820
hook that cute a packet the input and

00:07:29,300 --> 00:07:33,230
output interface indexes the packet and

00:07:31,820 --> 00:07:35,360
of mark and of course the packet payload

00:07:33,230 --> 00:07:39,140
and the packet payload will always start

00:07:35,360 --> 00:07:41,390
from the network header because we will

00:07:39,140 --> 00:07:44,180
just take everything from skp data until

00:07:41,390 --> 00:07:49,730
to the end and drove that user space so

00:07:44,180 --> 00:07:51,650
any layer to information is also lost so

00:07:49,730 --> 00:07:53,330
to implement it for a bridge the most

00:07:51,650 --> 00:07:54,710
simple solution would be to just push

00:07:53,330 --> 00:07:57,560
and pull the ethernet header right

00:07:54,710 --> 00:08:00,620
before we can create an editing message

00:07:57,560 --> 00:08:04,640
to use the space so that use space would

00:08:00,620 --> 00:08:06,350
simply see a payload that starts with

00:08:04,640 --> 00:08:08,630
the misleading header instead of the

00:08:06,350 --> 00:08:10,880
network error but unfortunately on

00:08:08,630 --> 00:08:15,410
second thought that does not work so

00:08:10,880 --> 00:08:18,110
well because on linux we always do VLAN

00:08:15,410 --> 00:08:21,260
header strip stripping so if it's a veal

00:08:18,110 --> 00:08:24,590
and and user space will not see the VLAN

00:08:21,260 --> 00:08:27,740
header at all so we would have to either

00:08:24,590 --> 00:08:30,770
antec and stuff to be done headed back

00:08:27,740 --> 00:08:34,610
which is bit of silly because we have to

00:08:30,770 --> 00:08:36,830
under work that we already did and we

00:08:34,610 --> 00:08:38,990
also can't really detect when you space

00:08:36,830 --> 00:08:41,000
has changed dl to whether such as

00:08:38,990 --> 00:08:43,430
inserted a new villain header or

00:08:41,000 --> 00:08:46,100
whatever because we would have to pull a

00:08:43,430 --> 00:08:46,730
different amount of bites back to fix up

00:08:46,100 --> 00:08:51,240
the

00:08:46,730 --> 00:08:53,730
skp data pointer again so it's so it

00:08:51,240 --> 00:08:56,820
seems preferable to just add new netlink

00:08:53,730 --> 00:08:59,640
attributes for storing the layer 2

00:08:56,820 --> 00:09:01,950
header and the VLAN header and the bonus

00:08:59,640 --> 00:09:03,990
point for doing that we would get

00:09:01,950 --> 00:09:08,910
basically native or ingress family

00:09:03,990 --> 00:09:10,980
support for free as well because if we

00:09:08,910 --> 00:09:13,320
do any of queueing on in breast and

00:09:10,980 --> 00:09:15,870
obviously use the space would have to

00:09:13,320 --> 00:09:19,350
implement all possible layer two headers

00:09:15,870 --> 00:09:22,380
to skip to the network header but if we

00:09:19,350 --> 00:09:24,930
keep it as a separate attribute and user

00:09:22,380 --> 00:09:27,500
space doesn't need to know any special

00:09:24,930 --> 00:09:32,370
things about delay or to header and

00:09:27,500 --> 00:09:34,560
it'll basically just work so the plan

00:09:32,370 --> 00:09:37,890
has already said just add new attributes

00:09:34,560 --> 00:09:41,370
and then use skp mec header and push

00:09:37,890 --> 00:09:43,230
that to use the space for VLAN we will

00:09:41,370 --> 00:09:45,120
do pretty much the same thing so we will

00:09:43,230 --> 00:09:48,600
just see realize the media data that is

00:09:45,120 --> 00:09:52,110
stored in the skb instead of untagging

00:09:48,600 --> 00:09:54,360
and that would later also allow you

00:09:52,110 --> 00:09:56,400
space to add or insert villain headers

00:09:54,360 --> 00:09:59,670
so the colonel would just have to check

00:09:56,400 --> 00:10:01,230
for instance if there's a if if a new

00:09:59,670 --> 00:10:03,089
villain attribute has a period or if

00:10:01,230 --> 00:10:06,150
there is a villain attributed zero

00:10:03,089 --> 00:10:07,680
length to remove VLAN and so on so while

00:10:06,150 --> 00:10:10,440
I don't plan to implement that at the

00:10:07,680 --> 00:10:13,800
moment at least with that design we

00:10:10,440 --> 00:10:19,650
would not prevent us in any way from

00:10:13,800 --> 00:10:22,740
later adding such support next problem

00:10:19,650 --> 00:10:24,810
overlapping addresses so originally I

00:10:22,740 --> 00:10:29,520
thought we might be able to solve that

00:10:24,810 --> 00:10:32,670
in an automatic way but it turns out

00:10:29,520 --> 00:10:37,050
that it's not so nice to resolve these

00:10:32,670 --> 00:10:39,660
problems and we can already partially

00:10:37,050 --> 00:10:42,390
work around it with iptables with the

00:10:39,660 --> 00:10:44,399
contract target by stuffing the

00:10:42,390 --> 00:10:46,079
contracts that have overlapping errors

00:10:44,399 --> 00:10:47,990
in two distinct zones the zone is

00:10:46,079 --> 00:10:51,089
basically just a 16-bit identifier that

00:10:47,990 --> 00:10:54,930
is taken as an additional key when doing

00:10:51,089 --> 00:10:57,779
contract lookups so even if the unwired

00:10:54,930 --> 00:10:59,660
addresses are the same a lookup would no

00:10:57,779 --> 00:11:03,270
longer find the other

00:10:59,660 --> 00:11:06,210
conflicting tuple to work whereas manual

00:11:03,270 --> 00:11:08,130
setup and it's not very efficient when

00:11:06,210 --> 00:11:11,610
you have lots of veal and because

00:11:08,130 --> 00:11:13,950
iptables has linear evaluations so if

00:11:11,610 --> 00:11:15,900
you have 1000 VLANs and you want to

00:11:13,950 --> 00:11:18,360
stuff those in 1,000 distinct zones you

00:11:15,900 --> 00:11:20,430
need 1,000 revolts but yeah fortunately

00:11:18,360 --> 00:11:24,839
we now have NF tables and it's not

00:11:20,430 --> 00:11:26,910
really a problem with NF tables so as I

00:11:24,839 --> 00:11:28,500
said we could try an automatic

00:11:26,910 --> 00:11:32,279
extraction of the VLAN ID and use that

00:11:28,500 --> 00:11:35,070
as a ninja Turkey but if for instance

00:11:32,279 --> 00:11:37,950
you would want to do connection tracking

00:11:35,070 --> 00:11:40,320
not with this villain but with IP

00:11:37,950 --> 00:11:42,089
packets embedded say inside pppoe frames

00:11:40,320 --> 00:11:44,480
then you would have to do colonel

00:11:42,089 --> 00:11:47,940
changes and that's not really nice nice

00:11:44,480 --> 00:11:49,980
furthermore overlapping addresses could

00:11:47,940 --> 00:11:53,490
also happen with distinct bridges

00:11:49,980 --> 00:11:57,750
instead of just different vlans so that

00:11:53,490 --> 00:12:00,330
doesn't work either so it doesn't seem

00:11:57,750 --> 00:12:02,850
too bad after all to just enforce manual

00:12:00,330 --> 00:12:04,589
configuration for this and in any of

00:12:02,850 --> 00:12:06,870
tables we don't have the linear rules

00:12:04,589 --> 00:12:09,630
that problem anyway because you can just

00:12:06,870 --> 00:12:13,170
use things like naps too for instance

00:12:09,630 --> 00:12:18,960
map villain IDs to zones or input

00:12:13,170 --> 00:12:21,750
interfaces or whatever for connection

00:12:18,960 --> 00:12:25,160
tracking on the bridge the plan is

00:12:21,750 --> 00:12:29,490
basically to add contract expression

00:12:25,160 --> 00:12:31,410
that serves essen has two functions so

00:12:29,490 --> 00:12:34,080
it first of all it would tell the

00:12:31,410 --> 00:12:39,360
colonel that it now has to do connection

00:12:34,080 --> 00:12:41,100
tracking in this in the given hook so we

00:12:39,360 --> 00:12:43,620
will not have to enable contract

00:12:41,100 --> 00:12:47,850
unconditionally like we do now bc and IP

00:12:43,620 --> 00:12:50,550
or ipv6 tech and it will also serve as

00:12:47,850 --> 00:12:53,130
the ingress point so you could for

00:12:50,550 --> 00:12:56,700
instance restrict connection tracking to

00:12:53,130 --> 00:12:58,529
particular subnets and not have the

00:12:56,700 --> 00:13:03,360
overhead for all the traffic that's all

00:12:58,529 --> 00:13:05,810
that's crossing the bridge the problem

00:13:03,360 --> 00:13:09,390
is that you would still need some

00:13:05,810 --> 00:13:11,130
unconditional hooks for things like

00:13:09,390 --> 00:13:11,760
confirmation basically the confirmation

00:13:11,130 --> 00:13:15,480
is

00:13:11,760 --> 00:13:16,920
for a new packet we don't commit the

00:13:15,480 --> 00:13:20,910
contract to the main table right away

00:13:16,920 --> 00:13:22,590
but we first remember it locally and so

00:13:20,910 --> 00:13:23,850
that if the packet is going to be

00:13:22,590 --> 00:13:29,190
dropped we don't have the overhead of

00:13:23,850 --> 00:13:30,960
committing it to the full table so the

00:13:29,190 --> 00:13:32,490
confirmation just happens at the end of

00:13:30,960 --> 00:13:34,610
the rules that reversal if there was no

00:13:32,490 --> 00:13:36,870
drop then we can put it into the table

00:13:34,610 --> 00:13:40,980
what we also have things like helpers

00:13:36,870 --> 00:13:42,600
and we have to detect have we have to do

00:13:40,980 --> 00:13:45,090
things like detect when a packet is

00:13:42,600 --> 00:13:48,170
related to an existing connection that

00:13:45,090 --> 00:13:53,010
affects for instance ipv4 pass on to you

00:13:48,170 --> 00:13:55,800
so you you can't really expect that a

00:13:53,010 --> 00:13:59,700
user knows what kinds of packets will

00:13:55,800 --> 00:14:02,160
possibly match the the traffic that the

00:13:59,700 --> 00:14:07,380
user wants to do connection tracking

00:14:02,160 --> 00:14:09,690
with also a big difference will be that

00:14:07,380 --> 00:14:11,280
there will be no tracking from the

00:14:09,690 --> 00:14:13,230
bridge for outgoing connections because

00:14:11,280 --> 00:14:15,570
if you have locally generated traffic

00:14:13,230 --> 00:14:18,390
and it will already have passed through

00:14:15,570 --> 00:14:21,600
the IP and IPS or ipv6 deck so they are

00:14:18,390 --> 00:14:23,340
those are already trekked anyway so

00:14:21,600 --> 00:14:27,450
basically all that we need is a kind of

00:14:23,340 --> 00:14:29,520
in on in on the input pass we just have

00:14:27,450 --> 00:14:31,650
to basically look at skb protocol and

00:14:29,520 --> 00:14:36,750
then do not call either into the ipv4 or

00:14:31,650 --> 00:14:38,040
ipv6 connection checking engine so we

00:14:36,750 --> 00:14:41,190
would end up with something like this

00:14:38,040 --> 00:14:43,530
you would have to add in post routing

00:14:41,190 --> 00:14:46,370
which should really be post bridging but

00:14:43,530 --> 00:14:48,540
okay helper and confirmation hooks

00:14:46,370 --> 00:14:51,270
confirmation to just commit to the main

00:14:48,540 --> 00:14:53,790
table and helper to make sure that if we

00:14:51,270 --> 00:14:56,010
have things like FTP or a sip or

00:14:53,790 --> 00:14:58,860
whatever that we can create the

00:14:56,010 --> 00:15:01,500
appropriate entries in the expectation

00:14:58,860 --> 00:15:03,750
table to correctly decode traffic that

00:15:01,500 --> 00:15:05,250
is not directly directly matching the

00:15:03,750 --> 00:15:07,230
tubule but somehow related to the

00:15:05,250 --> 00:15:11,790
traffic for instance the voice channel

00:15:07,230 --> 00:15:16,280
in zip we would have to add something to

00:15:11,790 --> 00:15:20,570
pre routing to handle reply traffic so

00:15:16,280 --> 00:15:25,120
so we can also for instance handle and

00:15:20,570 --> 00:15:28,130
IP differently defragmentation there

00:15:25,120 --> 00:15:31,400
we would not not do anything an input

00:15:28,130 --> 00:15:33,290
because as I already mentioned if the

00:15:31,400 --> 00:15:35,150
traffic is for the local bridge then we

00:15:33,290 --> 00:15:38,090
will do an up call into the IP stick

00:15:35,150 --> 00:15:45,500
anyway and we can handle that with the

00:15:38,090 --> 00:15:47,180
code we already have in place so one

00:15:45,500 --> 00:15:51,580
question that we are we are sometimes

00:15:47,180 --> 00:15:53,600
confronted with is how you can disable

00:15:51,580 --> 00:15:56,090
defragmentation on a particular

00:15:53,600 --> 00:15:58,730
interface and the answer is that in

00:15:56,090 --> 00:16:01,010
iptables or IP six tables you cannot do

00:15:58,730 --> 00:16:03,100
that because once the NF defrag IP

00:16:01,010 --> 00:16:04,760
something module is loaded

00:16:03,100 --> 00:16:07,490
defragmentation just happens

00:16:04,760 --> 00:16:12,610
automatically for traffic that is

00:16:07,490 --> 00:16:16,370
passing a router and in ipv4 and ipv6

00:16:12,610 --> 00:16:18,770
there is a phony deploy dependency from

00:16:16,370 --> 00:16:20,450
contract on defragmentation so if you

00:16:18,770 --> 00:16:22,310
load the contract module the defect

00:16:20,450 --> 00:16:26,480
module is loaded automatically as well

00:16:22,310 --> 00:16:28,250
although there is no technical strict

00:16:26,480 --> 00:16:29,840
technical reason for doing that we just

00:16:28,250 --> 00:16:33,400
have to do that to make sure that we can

00:16:29,840 --> 00:16:35,240
correctly look up any transport header

00:16:33,400 --> 00:16:36,560
because if you wouldn't do the

00:16:35,240 --> 00:16:39,020
fragmentation and you have fragments

00:16:36,560 --> 00:16:40,370
than you can't tell if they match any

00:16:39,020 --> 00:16:46,550
traffic that you already have in the

00:16:40,370 --> 00:16:48,380
contract table so we kind of have this

00:16:46,550 --> 00:16:50,810
conflict between usability and have it

00:16:48,380 --> 00:16:52,040
automatically and configurability was to

00:16:50,810 --> 00:16:53,420
do things like I don't want

00:16:52,040 --> 00:16:57,320
defragmentation on this particular

00:16:53,420 --> 00:16:59,780
interface so the best ideas so far to

00:16:57,320 --> 00:17:03,350
get all of this is to also add a defrag

00:16:59,780 --> 00:17:07,730
expression so that users could for

00:17:03,350 --> 00:17:09,620
instance a please do not do please only

00:17:07,730 --> 00:17:11,480
do the fragmentation if it's if the

00:17:09,620 --> 00:17:20,480
packet is not arriving on a particular

00:17:11,480 --> 00:17:23,329
interface so too depending fully on this

00:17:20,480 --> 00:17:25,550
however doesn't really play nice with

00:17:23,329 --> 00:17:28,189
contract related handling because as

00:17:25,550 --> 00:17:30,500
already said if you have a fragment then

00:17:28,189 --> 00:17:33,420
you have no idea if it matches an

00:17:30,500 --> 00:17:38,590
expectation or an existing connection

00:17:33,420 --> 00:17:41,230
so um it seems best to basically add

00:17:38,590 --> 00:17:43,480
such an defrag expression so that if you

00:17:41,230 --> 00:17:46,090
do not do not need contract at all and

00:17:43,480 --> 00:17:47,620
for instance just want to do n fq and

00:17:46,090 --> 00:17:51,030
you can use the defrag expression to

00:17:47,620 --> 00:17:54,340
have a fully programmable

00:17:51,030 --> 00:17:56,290
defragmentation process but once you

00:17:54,340 --> 00:17:57,910
depend on contract and ask for

00:17:56,290 --> 00:18:00,430
connection tracking then the defrag

00:17:57,910 --> 00:18:03,940
would still be forced on by default

00:18:00,430 --> 00:18:06,400
everywhere because as I already said if

00:18:03,940 --> 00:18:08,590
we don't do it we will end up in

00:18:06,400 --> 00:18:13,960
situations where we can't match packets

00:18:08,590 --> 00:18:16,390
to contact entries so what spending I'm

00:18:13,960 --> 00:18:20,470
currently in the process of implementing

00:18:16,390 --> 00:18:23,590
this as outlined in the slides and I

00:18:20,470 --> 00:18:26,260
will try to avoid dependency so if you

00:18:23,590 --> 00:18:28,720
do connection tracking on the bridge it

00:18:26,260 --> 00:18:30,910
will not auto load for instance the ipv6

00:18:28,720 --> 00:18:33,460
contract module and it will depend on

00:18:30,910 --> 00:18:37,090
the user to load the appropriate layer 3

00:18:33,460 --> 00:18:40,840
tracker I'm not planning to add net

00:18:37,090 --> 00:18:42,670
support because once you do a network

00:18:40,840 --> 00:18:46,090
address translation on a bridge you

00:18:42,670 --> 00:18:48,220
always force the user to also add a full

00:18:46,090 --> 00:18:49,900
routing table so that we can figure out

00:18:48,220 --> 00:18:52,090
where to send a packet or for instance

00:18:49,900 --> 00:18:54,340
if you do not it could mean that the

00:18:52,090 --> 00:18:55,870
packet has to leave not we had a bridge

00:18:54,340 --> 00:18:59,620
but we are some completely unrelated

00:18:55,870 --> 00:19:02,470
interface and that was always confusing

00:18:59,620 --> 00:19:04,090
to users we wonder why that transparent

00:19:02,470 --> 00:19:06,730
proxy isn't working and you have to tell

00:19:04,090 --> 00:19:11,500
them yeah you have to add ipv6 routes

00:19:06,730 --> 00:19:15,510
for that to work things like that so to

00:19:11,500 --> 00:19:19,030
get net you could still for instance use

00:19:15,510 --> 00:19:20,710
the user set expression to change the

00:19:19,030 --> 00:19:23,800
mac address to the local mac address and

00:19:20,710 --> 00:19:26,170
then have the packet pushed up to the IP

00:19:23,800 --> 00:19:32,580
stack to enter the normal routing path

00:19:26,170 --> 00:19:32,580
to solve that so any questions

00:19:47,430 --> 00:19:58,840
we heard a lot of problem at least with

00:19:55,390 --> 00:20:02,340
kernel 2.6 with encountered a lot of

00:19:58,840 --> 00:20:05,220
problems when users would open a lot of

00:20:02,340 --> 00:20:07,780
connections and the connection tracking

00:20:05,220 --> 00:20:11,080
sit by default would I don't remember

00:20:07,780 --> 00:20:13,450
the limit for the connections but that

00:20:11,080 --> 00:20:15,490
timeout for removing the connections

00:20:13,450 --> 00:20:18,340
from the connection tracking table would

00:20:15,490 --> 00:20:22,300
be something like one hour of five hours

00:20:18,340 --> 00:20:25,150
of in Liam Angus and we just end up that

00:20:22,300 --> 00:20:28,120
because we had so many sip calls we just

00:20:25,150 --> 00:20:30,760
start to run out of connections in the

00:20:28,120 --> 00:20:34,510
connection trucker who just drop sip sip

00:20:30,760 --> 00:20:37,840
calls and just to give you the tip if

00:20:34,510 --> 00:20:40,540
you're going to get it again into you

00:20:37,840 --> 00:20:44,470
know making connection fracking for sip

00:20:40,540 --> 00:20:47,410
calls try not to get into this pitiful

00:20:44,470 --> 00:20:49,960
and limit the time out to something more

00:20:47,410 --> 00:20:53,710
reasonable than ours something like in a

00:20:49,960 --> 00:20:56,050
one-minute make the default you know the

00:20:53,710 --> 00:20:59,170
sysctl default for the number of

00:20:56,050 --> 00:21:03,940
connections racking big enough and just

00:20:59,170 --> 00:21:07,000
you know maybe think of some may be

00:21:03,940 --> 00:21:09,820
better plan to handle the case when you

00:21:07,000 --> 00:21:12,520
run out of connection fracking they've

00:21:09,820 --> 00:21:18,010
been bypassed the connection tracking

00:21:12,520 --> 00:21:21,400
rather than drops it calls yeah okay we

00:21:18,010 --> 00:21:23,560
could check the behavior of the early

00:21:21,400 --> 00:21:27,220
drop code but i would have to revisit

00:21:23,560 --> 00:21:28,960
that you can also there is a timeout

00:21:27,220 --> 00:21:32,620
infrastructure so you can specify a

00:21:28,960 --> 00:21:34,960
different time out to specified a time

00:21:32,620 --> 00:21:39,450
out policy for traffic that uni we have

00:21:34,960 --> 00:21:41,620
cd timeout thing probably it's going to

00:21:39,450 --> 00:21:44,620
avoid problems that you are noticing

00:21:41,620 --> 00:21:47,190
with high timeouts while keeping the

00:21:44,620 --> 00:21:52,440
same the default timeout for

00:21:47,190 --> 00:21:55,800
flows yeah we had there are sis controls

00:21:52,440 --> 00:21:57,690
that we used to bypass it but I'm just

00:21:55,800 --> 00:22:00,150
giving the tip because sometimes when

00:21:57,690 --> 00:22:04,050
you start implementing stuff you did not

00:22:00,150 --> 00:22:06,360
suspect when you want product out that

00:22:04,050 --> 00:22:09,020
this is the result and you go out and

00:22:06,360 --> 00:22:13,220
then suddenly getting to you know some

00:22:09,020 --> 00:22:18,000
situation where a combination of a few

00:22:13,220 --> 00:22:21,000
conditions and make the product

00:22:18,000 --> 00:22:24,150
dysfunctional to to some point and that

00:22:21,000 --> 00:22:27,390
the tip is not how you know i'm not

00:22:24,150 --> 00:22:31,200
looking at how to bypass it and just how

00:22:27,390 --> 00:22:35,160
to correctly design the system in a head

00:22:31,200 --> 00:22:39,510
to prevent new users new programmers

00:22:35,160 --> 00:22:41,730
were not aware of exactly how things are

00:22:39,510 --> 00:22:44,730
implementing a linux kernel to get in

00:22:41,730 --> 00:22:46,890
the same pitch fall again so this is my

00:22:44,730 --> 00:22:48,390
video then then if i understand

00:22:46,890 --> 00:22:52,380
correctly the problem is with the sippy

00:22:48,390 --> 00:22:57,750
sip helper right yep so we'll be good to

00:22:52,380 --> 00:22:59,160
debug what to the park to see helper and

00:22:57,750 --> 00:23:01,530
with with the product that is

00:22:59,160 --> 00:23:03,840
interacting with egg to see what it's

00:23:01,530 --> 00:23:05,600
not not not being interpreted the right

00:23:03,840 --> 00:23:08,880
way I mean the SIP proxy is basically

00:23:05,600 --> 00:23:14,930
party in the city messages it's a quite

00:23:08,880 --> 00:23:17,280
intensive task is string matching and so

00:23:14,930 --> 00:23:20,610
probably there is something in the in

00:23:17,280 --> 00:23:24,200
some of the sort of phone heart phones

00:23:20,610 --> 00:23:27,630
are you using or all pvx that is not

00:23:24,200 --> 00:23:30,120
it's not that the helper is not liking

00:23:27,630 --> 00:23:34,500
for some reason so we good to to the

00:23:30,120 --> 00:23:36,810
park to get to the seed problem that is

00:23:34,500 --> 00:23:38,520
causing a program and they bug be the

00:23:36,810 --> 00:23:43,170
helper and and find the reason so we can

00:23:38,520 --> 00:23:46,620
fix it know what I mean even if the sip

00:23:43,170 --> 00:23:49,650
is okay I mean there isn't a automatic

00:23:46,620 --> 00:23:52,320
tracking and once you start tracking sit

00:23:49,650 --> 00:23:54,780
cause they are allocated one con a

00:23:52,320 --> 00:23:57,870
connection tracking entry in the table

00:23:54,780 --> 00:23:59,030
and then it stays there for at least one

00:23:57,870 --> 00:24:01,250
hour don't remember the

00:23:59,030 --> 00:24:03,500
exact time out even if everything is

00:24:01,250 --> 00:24:05,840
okay and then you make another call

00:24:03,500 --> 00:24:08,960
another call and table just start to

00:24:05,840 --> 00:24:12,680
grow them till you run out of entries

00:24:08,960 --> 00:24:14,900
connection tracking entries and then the

00:24:12,680 --> 00:24:18,230
next step call you want to open there

00:24:14,900 --> 00:24:25,670
are no more free entries to add to the

00:24:18,230 --> 00:24:28,490
tables we just have to drop calls yes

00:24:25,670 --> 00:24:31,730
and they see I mean currently with we

00:24:28,490 --> 00:24:33,560
have we can also the you can disable the

00:24:31,730 --> 00:24:36,650
automatic the dramatic sip helper

00:24:33,560 --> 00:24:39,160
assignment this abroad entry that is

00:24:36,650 --> 00:24:41,750
currently enabled by default and the

00:24:39,160 --> 00:24:44,990
plan is to because of problems that are

00:24:41,750 --> 00:24:48,770
equally blown and all the people found

00:24:44,990 --> 00:24:51,020
on these automatic helper thing and from

00:24:48,770 --> 00:24:53,630
a security point of view the plan it's

00:24:51,020 --> 00:24:55,070
been already enabled this behavior the

00:24:53,630 --> 00:24:57,950
behavior that we have it's been enabled

00:24:55,070 --> 00:25:00,230
for already quite a long time so the

00:24:57,950 --> 00:25:02,570
plan is to disable that behavior so user

00:25:00,230 --> 00:25:05,840
has to explicitly indicate what helper

00:25:02,570 --> 00:25:09,110
they need for what kind of flows is that

00:25:05,840 --> 00:25:12,200
what you need yes if the default would

00:25:09,110 --> 00:25:14,600
be a off I think it would be way better

00:25:12,200 --> 00:25:16,430
because I I know how to bypass it but

00:25:14,600 --> 00:25:17,930
you know once you know chip to a

00:25:16,430 --> 00:25:20,270
customer and the customer start

00:25:17,930 --> 00:25:22,700
complaining and then telling him to

00:25:20,270 --> 00:25:25,220
start making it an embedded system and

00:25:22,700 --> 00:25:27,590
start making all kind of a setting to

00:25:25,220 --> 00:25:30,830
the sis control or the proc file system

00:25:27,590 --> 00:25:32,180
or whatever its you know yeah that's

00:25:30,830 --> 00:25:33,770
another good for business that's not a

00:25:32,180 --> 00:25:35,840
good reason to disable it I mean wait we

00:25:33,770 --> 00:25:42,880
have already more good reasons to

00:25:35,840 --> 00:25:45,530
disable these automatic stuff and so so

00:25:42,880 --> 00:25:49,160
the fault of all behavior should be

00:25:45,530 --> 00:25:52,670
change any time soon to to request users

00:25:49,160 --> 00:25:54,500
to I mean we've been with in announcing

00:25:52,670 --> 00:25:57,590
this for a long time I changing this

00:25:54,500 --> 00:26:00,350
behavior and so we probably already it's

00:25:57,590 --> 00:26:04,100
been a life it's 34 years already so

00:26:00,350 --> 00:26:19,750
they're probably ready to to move thank

00:26:04,100 --> 00:26:19,750

YouTube URL: https://www.youtube.com/watch?v=fcQikLA6Tjg


