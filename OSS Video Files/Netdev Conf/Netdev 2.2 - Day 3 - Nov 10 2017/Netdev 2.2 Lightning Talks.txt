Title: Netdev 2.2 Lightning Talks
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 3 - Nov 10 2017
Description: 
	Many Speakers
Friday November 10th, 2017 
Seoul, Korea
Captions: 
	00:00:01,099 --> 00:00:07,190
lightning talks means you get about five

00:00:04,130 --> 00:00:11,269
or six minutes I need to look for a

00:00:07,190 --> 00:00:12,620
volunteer who can do this for the after

00:00:11,269 --> 00:00:14,870
because I have something that I have to

00:00:12,620 --> 00:00:16,369
be at at 4:20 so I have a volunteer who

00:00:14,870 --> 00:00:17,720
can just pass the mic to people every

00:00:16,369 --> 00:00:19,009
five or six minutes Senate wins people

00:00:17,720 --> 00:00:22,489
thank you very much

00:00:19,009 --> 00:00:24,410
come on up I have the list of the talks

00:00:22,489 --> 00:00:30,290
so you can call them out edge as you

00:00:24,410 --> 00:00:33,500
need to so no slides talking only and

00:00:30,290 --> 00:00:35,660
you get between five or six minutes if

00:00:33,500 --> 00:00:38,840
there is a minute left or whatever at

00:00:35,660 --> 00:00:40,640
the end I don't think it's safe to allow

00:00:38,840 --> 00:00:42,650
questions to be asked you can talk in

00:00:40,640 --> 00:00:44,420
the hallway or together at dinner or

00:00:42,650 --> 00:00:46,100
whatever you wish to sort things out

00:00:44,420 --> 00:00:48,020
it'll just take time away from the next

00:00:46,100 --> 00:00:49,460
person so please be considerate to

00:00:48,020 --> 00:00:51,950
everyone else and the Lightning talks

00:00:49,460 --> 00:00:54,770
and things will go smoothly and everyone

00:00:51,950 --> 00:00:56,329
will be happy and I would like to thank

00:00:54,770 --> 00:00:58,160
everyone for submitting a lightning talk

00:00:56,329 --> 00:01:00,170
this is something new we're doing this

00:00:58,160 --> 00:01:01,700
time and I hope this goes very well so

00:01:00,170 --> 00:01:10,790
maybe it can be done again in the future

00:01:01,700 --> 00:01:12,590
so thank you very much I think everybody

00:01:10,790 --> 00:01:14,840
knows me by now my name is Angelus

00:01:12,590 --> 00:01:17,960
engaging and I think the first speaker

00:01:14,840 --> 00:01:21,310
is archaea and he wants to talk about

00:01:17,960 --> 00:01:21,310
SRV live migration

00:01:27,210 --> 00:01:31,890
stop the presentation might confuse

00:01:29,650 --> 00:01:31,890
people

00:01:42,460 --> 00:01:47,510
okay

00:01:43,690 --> 00:01:53,630
so I'll talk about live migration with

00:01:47,510 --> 00:01:55,549
SR iov so s ROV is by far the best

00:01:53,630 --> 00:01:58,940
solution performance wise

00:01:55,549 --> 00:02:01,430
it gives direct pass through from the VN

00:01:58,940 --> 00:02:05,630
directly to the device which yields low

00:02:01,430 --> 00:02:08,000
latency low CPU ttle ization and the

00:02:05,630 --> 00:02:11,890
highest message rate so it's by far the

00:02:08,000 --> 00:02:11,890
best performance solution

00:02:12,080 --> 00:02:15,980
one of the main blockers from for

00:02:14,360 --> 00:02:19,790
deployment for us or even cloud

00:02:15,980 --> 00:02:22,450
deployments was the lack of flexibility

00:02:19,790 --> 00:02:27,019
because you needed to rely on the switch

00:02:22,450 --> 00:02:29,450
on the device but as lately devices are

00:02:27,019 --> 00:02:34,970
getting more sophisticated and more

00:02:29,450 --> 00:02:41,750
flexible switches this this problem gets

00:02:34,970 --> 00:02:43,910
eliminated so the next thing that kind

00:02:41,750 --> 00:02:46,970
of block deployment of SRV is live

00:02:43,910 --> 00:02:51,380
migration this is a basic feature for

00:02:46,970 --> 00:02:53,989
cloud deployment to move VMs from around

00:02:51,380 --> 00:02:55,640
physical machines and to do it while

00:02:53,989 --> 00:02:57,430
they're keeping them online as much as

00:02:55,640 --> 00:03:00,200
possible

00:02:57,430 --> 00:03:04,220
so this is becoming a main blocker for

00:03:00,200 --> 00:03:09,200
every deployment so what is the problem

00:03:04,220 --> 00:03:12,760
to do a live migration with SR iov well

00:03:09,200 --> 00:03:15,739
the main problem is the DMA accesses

00:03:12,760 --> 00:03:18,590
without s array of each incoming packet

00:03:15,739 --> 00:03:24,500
goes through the hypervisor and being a

00:03:18,590 --> 00:03:26,810
memo to the VM but with SRO V that the

00:03:24,500 --> 00:03:31,160
the packet is directly written to the VM

00:03:26,810 --> 00:03:34,730
space without host CPU intervention and

00:03:31,160 --> 00:03:38,600
the problem with that is that DMA

00:03:34,730 --> 00:03:41,120
accesses do not mark pages as dirty when

00:03:38,600 --> 00:03:43,519
the the NIC writes to the page directly

00:03:41,120 --> 00:03:45,920
with a DMA the page is not written as

00:03:43,519 --> 00:03:48,010
dirty and this causes the problem

00:03:45,920 --> 00:03:51,769
because when you want to make great

00:03:48,010 --> 00:03:53,040
machine I mean in doing like migration

00:03:51,769 --> 00:03:56,760
the hypervisor

00:03:53,040 --> 00:03:59,010
starts to copy the the memory of the VM

00:03:56,760 --> 00:04:02,819
while it is working this is called the

00:03:59,010 --> 00:04:05,909
warm-up phase and it realized this

00:04:02,819 --> 00:04:10,260
warm-up phase copying the pages relies

00:04:05,909 --> 00:04:13,349
on mark on the fact that if the VM will

00:04:10,260 --> 00:04:16,079
access pages it already copied to the

00:04:13,349 --> 00:04:18,030
destination machine then the hypervisor

00:04:16,079 --> 00:04:20,070
will see that the page was dirtied and

00:04:18,030 --> 00:04:26,190
it will know to copy it again

00:04:20,070 --> 00:04:28,770
and at some stage the machine is on the

00:04:26,190 --> 00:04:30,660
source machine is being stopped and then

00:04:28,770 --> 00:04:35,580
all the dirty pages are copied to the

00:04:30,660 --> 00:04:38,100
destination machine once again but so

00:04:35,580 --> 00:04:39,479
the problem with DMA is that the pages

00:04:38,100 --> 00:04:42,690
are being dirty but the hypervisor

00:04:39,479 --> 00:04:45,150
cannot know it this is the main really

00:04:42,690 --> 00:04:53,160
the main problem for migrating machines

00:04:45,150 --> 00:04:56,610
using SR iov now people started to put

00:04:53,160 --> 00:04:59,580
solution to this problem but in my

00:04:56,610 --> 00:05:02,520
opinion they are not resolving the real

00:04:59,580 --> 00:05:06,270
problem and bypassing it with some

00:05:02,520 --> 00:05:10,590
vendor specific solutions the solution

00:05:06,270 --> 00:05:15,090
since so far was to rely on having in

00:05:10,590 --> 00:05:17,760
the vm in addition to the VF of death or

00:05:15,090 --> 00:05:21,419
AV attached to the VM also a pair of ear

00:05:17,760 --> 00:05:25,050
device and then when wanting to migrate

00:05:21,419 --> 00:05:28,110
the VM they detach the VF disabled as a

00:05:25,050 --> 00:05:30,599
review on the source machine rely on the

00:05:28,110 --> 00:05:35,820
power of it device to continue

00:05:30,599 --> 00:05:40,530
connectivity for the VM and then this

00:05:35,820 --> 00:05:44,400
way they kind of awkwardly overcome the

00:05:40,530 --> 00:05:49,820
DMA dirtying solution and in addition to

00:05:44,400 --> 00:05:55,410
that the the solution pushed so far is

00:05:49,820 --> 00:05:59,669
is part of it vendor specific and it

00:05:55,410 --> 00:06:02,820
also replicates what they do is that

00:05:59,669 --> 00:06:05,330
they enslave in the VM the power viewed

00:06:02,820 --> 00:06:09,379
driver and slays the

00:06:05,330 --> 00:06:11,539
PF and this is also code replication

00:06:09,379 --> 00:06:15,620
because we already have in linux

00:06:11,539 --> 00:06:19,129
enslavement drivers such as the linux

00:06:15,620 --> 00:06:24,740
blonde or linux teaming and this is a

00:06:19,129 --> 00:06:27,889
kind of replication of logic and it also

00:06:24,740 --> 00:06:32,180
realized so it's also part of it

00:06:27,889 --> 00:06:34,550
specific because so if you continue

00:06:32,180 --> 00:06:36,710
going this way so each power v

00:06:34,550 --> 00:06:39,069
technology will have to reinvent its own

00:06:36,710 --> 00:06:42,259
solution which is bad

00:06:39,069 --> 00:06:44,030
replicating existing code and it

00:06:42,259 --> 00:06:45,949
basically relies on having the power of

00:06:44,030 --> 00:06:48,349
weird which is not necessarily needed

00:06:45,949 --> 00:06:50,300
some people might not want power of it

00:06:48,349 --> 00:06:53,539
and still want to copy so the real

00:06:50,300 --> 00:06:56,030
solution should be resolved the real

00:06:53,539 --> 00:06:59,240
problem of the dma dirt and some guy

00:06:56,030 --> 00:07:01,340
Alec standard oh I already suggested how

00:06:59,240 --> 00:07:06,590
to resolve it I think about two years

00:07:01,340 --> 00:07:09,289
ago simply was not kept pushing it so we

00:07:06,590 --> 00:07:11,479
need to ramp it ramp it up and then

00:07:09,289 --> 00:07:13,490
slave and logic should be generic and

00:07:11,479 --> 00:07:17,389
not pervert

00:07:13,490 --> 00:07:20,060
driver specific have an Eric enslavement

00:07:17,389 --> 00:07:22,699
logic that's the way I think I think we

00:07:20,060 --> 00:07:34,190
should resolve the SRA or V live

00:07:22,699 --> 00:07:36,050
migration issue so I guess we'll take

00:07:34,190 --> 00:07:39,259
the questions later because there was a

00:07:36,050 --> 00:07:41,870
lot of hallway talk about this so the

00:07:39,259 --> 00:07:45,199
next presenter is Eric doomsday and he

00:07:41,870 --> 00:07:53,060
wants to talk about modular IP for TCP

00:07:45,199 --> 00:07:57,169
UDP yes so the idea is very simple even

00:07:53,060 --> 00:08:00,020
really ipv4 will be shut down in 20

00:07:57,169 --> 00:08:03,830
years something so I think it's time for

00:08:00,020 --> 00:08:05,990
us to to prepare that and so at Google

00:08:03,830 --> 00:08:08,000
we have some various hacks trying to

00:08:05,990 --> 00:08:10,490
disable ipv4 on the host so that we can

00:08:08,000 --> 00:08:13,860
test that old application actually can

00:08:10,490 --> 00:08:16,980
run on ipv6 pure network right

00:08:13,860 --> 00:08:20,130
so what if instead of adding pure hacks

00:08:16,980 --> 00:08:22,980
in the camera we prepare this transition

00:08:20,130 --> 00:08:27,060
and so the idea would be to have a way

00:08:22,980 --> 00:08:29,580
to compile the kernel without ipv4

00:08:27,060 --> 00:08:30,210
support at all that's pretty pretty

00:08:29,580 --> 00:08:33,630
simple

00:08:30,210 --> 00:08:36,570
and then another idea another point I

00:08:33,630 --> 00:08:39,300
want to make is to make more things

00:08:36,570 --> 00:08:41,130
modular so that you can unload a module

00:08:39,300 --> 00:08:45,750
and reload a new version of the module

00:08:41,130 --> 00:08:48,870
in case you discover a very concerning

00:08:45,750 --> 00:08:51,510
bug and you want to fix like in TCP

00:08:48,870 --> 00:08:54,600
stack or UDP stack whatever and so right

00:08:51,510 --> 00:08:56,700
now we have all these things in the

00:08:54,600 --> 00:08:59,070
static VM Linux so the only way you can

00:08:56,700 --> 00:09:03,060
fix a bug is to do some live patching

00:08:59,070 --> 00:09:06,750
which a bit high key or reboot the host

00:09:03,060 --> 00:09:28,470
so that's the thing I am we need to work

00:09:06,750 --> 00:09:31,260
on on the future I think that's it now

00:09:28,470 --> 00:09:33,630
you can compile the kernel without ipv6

00:09:31,260 --> 00:09:37,190
but you cannot compile it with a ipv4

00:09:33,630 --> 00:09:40,320
right now so we need a way to move the

00:09:37,190 --> 00:09:43,670
common code outside of the ipv4 and so

00:09:40,320 --> 00:09:48,360
and then later have a way to compile

00:09:43,670 --> 00:09:51,750
ipv4 as a model and by extension or

00:09:48,360 --> 00:09:54,810
anything that can be using the network

00:09:51,750 --> 00:09:58,890
we already have HTTP as a model why why

00:09:54,810 --> 00:10:01,770
not TCP and UDP that's very simple or up

00:09:58,890 --> 00:10:06,680
and D whatever all this protocol support

00:10:01,770 --> 00:10:06,680
protocol could be loaded as motors

00:10:08,580 --> 00:10:13,919
[Applause]

00:10:15,550 --> 00:10:30,100
the next speaker is pj risque wigs and

00:10:19,180 --> 00:10:33,879
he's going to talk about skb diet so

00:10:30,100 --> 00:10:35,439
this came up actually in some work that

00:10:33,879 --> 00:10:39,339
I was attempting to do on enabling

00:10:35,439 --> 00:10:41,679
double VLAN which right now we don't

00:10:39,339 --> 00:10:43,660
have very good support to indicate up

00:10:41,679 --> 00:10:46,689
the s tag in the stack right we only

00:10:43,660 --> 00:10:49,959
have one VLAN field and we either

00:10:46,689 --> 00:10:53,230
terminate down in the driver and just

00:10:49,959 --> 00:10:54,819
toss it aside or we don't strip the tags

00:10:53,230 --> 00:10:56,139
out with the hardware at all and we just

00:10:54,819 --> 00:10:57,189
passed the entire frame up and let the

00:10:56,139 --> 00:11:01,959
software take care of it

00:10:57,189 --> 00:11:03,160
so I remember hearing Dave's voice in

00:11:01,959 --> 00:11:06,639
the back of my head thou shalt not add

00:11:03,160 --> 00:11:08,079
something to the skb so I took a closer

00:11:06,639 --> 00:11:10,959
look at some of the things that we might

00:11:08,079 --> 00:11:13,990
be able to pull out and it was kind of a

00:11:10,959 --> 00:11:15,699
off the top of my head proposal I'm

00:11:13,990 --> 00:11:18,399
looking at pulling things out like the

00:11:15,699 --> 00:11:21,999
encapsulation stuff into its own set of

00:11:18,399 --> 00:11:23,800
off floats trucks and then if we have

00:11:21,999 --> 00:11:27,249
maybe multiple layers of encapsulation

00:11:23,800 --> 00:11:30,819
we can build a list on demand and then

00:11:27,249 --> 00:11:32,139
refer to them from the SK buff so I

00:11:30,819 --> 00:11:34,300
wanted to throw that out there and see

00:11:32,139 --> 00:11:36,009
how many people wanted to yell oh you

00:11:34,300 --> 00:11:39,249
mean what do we have today

00:11:36,009 --> 00:11:42,120
SKB outer Mach header and this stuff the

00:11:39,249 --> 00:11:45,519
offsets so we have the inner Mack header

00:11:42,120 --> 00:11:48,309
you know yeah all of the inner ones

00:11:45,519 --> 00:11:50,470
that's one set right so that's for some

00:11:48,309 --> 00:11:52,360
of the in some of the end cap stuff that

00:11:50,470 --> 00:11:54,819
we have right now but in addition to

00:11:52,360 --> 00:11:59,589
that we would need to add the s tag

00:11:54,819 --> 00:12:01,240
support right for outer veal and if we

00:11:59,589 --> 00:12:03,999
wanted to support Hardware stripping of

00:12:01,240 --> 00:12:06,490
both inner and outer C tagging as tag

00:12:03,999 --> 00:12:10,179
right which we can't do and indicate up

00:12:06,490 --> 00:12:11,829
the stack today so if we can pull those

00:12:10,179 --> 00:12:14,410
out into their own kind of offload

00:12:11,829 --> 00:12:16,360
Struck's pull them out of the the sk

00:12:14,410 --> 00:12:17,920
buff and then only allocate them when we

00:12:16,360 --> 00:12:21,660
need them right if we don't have a VLAN

00:12:17,920 --> 00:12:21,660
there's no need to allocate that man

00:12:22,029 --> 00:12:27,920
oran cap d cap stuff like that I don't I

00:12:25,339 --> 00:12:33,410
do think that that's many skb fields

00:12:27,920 --> 00:12:35,870
have no existence outside of the the

00:12:33,410 --> 00:12:38,240
honing path like expect more it's a bit

00:12:35,870 --> 00:12:40,279
which is really could be a prostitute

00:12:38,240 --> 00:12:42,019
variable because we just set it right

00:12:40,279 --> 00:12:43,970
before calling no and no static Smith of

00:12:42,019 --> 00:12:46,160
the driver so we absolutely could use

00:12:43,970 --> 00:12:47,839
the Pacific variable and I think the

00:12:46,160 --> 00:12:50,990
inner hater all this stuff could be

00:12:47,839 --> 00:12:53,000
something outside of the skb which could

00:12:50,990 --> 00:12:55,610
be used only on the context of the color

00:12:53,000 --> 00:12:57,620
I I don't think it makes any sense to

00:12:55,610 --> 00:13:00,649
store skb somewhere in the queue with

00:12:57,620 --> 00:13:04,130
this live information this yeah I don't

00:13:00,649 --> 00:13:06,829
think this this is really needed at most

00:13:04,130 --> 00:13:09,019
it could be you know easily passed again

00:13:06,829 --> 00:13:10,970
from the header and start again the

00:13:09,019 --> 00:13:13,550
passing and find again the inner header

00:13:10,970 --> 00:13:16,360
if we really want them it's Jimmy and

00:13:13,550 --> 00:13:20,240
just pull them out altogether

00:13:16,360 --> 00:13:23,000
yeah completely okay well that goes with

00:13:20,240 --> 00:13:26,360
the title of skp diet if we adding in

00:13:23,000 --> 00:13:29,990
another pointer we mean adding an yet

00:13:26,360 --> 00:13:35,720
another allocation in the Fast Pass I'm

00:13:29,990 --> 00:13:37,760
not sure it's going to find okay so if I

00:13:35,720 --> 00:13:42,490
pull out the inner headers then I can

00:13:37,760 --> 00:13:45,560
add the outer VLAN tag yeah maybe

00:13:42,490 --> 00:13:52,480
all right that was really about it any

00:13:45,560 --> 00:13:52,480
other comments questions tonight Thanks

00:13:54,730 --> 00:14:02,620
okay next we have Lorenzo quality and

00:13:58,339 --> 00:14:02,620
he's gonna talk about EBP F for Android

00:14:10,870 --> 00:14:18,860
yeah so we not EBP iPhone Android as

00:14:15,680 --> 00:14:20,000
such but just a little bit of it we the

00:14:18,860 --> 00:14:24,980
first thing we're looking at is

00:14:20,000 --> 00:14:26,839
replacing xtq tag UID which is what

00:14:24,980 --> 00:14:29,680
powers this screen which is you know

00:14:26,839 --> 00:14:33,139
which app has used how much data and

00:14:29,680 --> 00:14:35,120
right now this is powered by xtq

00:14:33,139 --> 00:14:38,899
taglioti which is three thousand lines

00:14:35,120 --> 00:14:42,019
of a dope tree code and it's it's slow

00:14:38,899 --> 00:14:45,050
it grabs locks all the time it crashes

00:14:42,019 --> 00:14:47,060
when Eric changes the TCP structure this

00:14:45,050 --> 00:14:49,250
you know when when somebody adds a new

00:14:47,060 --> 00:14:51,440
field or like adds a new type of non

00:14:49,250 --> 00:14:54,970
full socket to crashes and so it's got a

00:14:51,440 --> 00:14:57,529
lot of maintenance burden and so we

00:14:54,970 --> 00:15:01,130
we're looking at replacing this with EBP

00:14:57,529 --> 00:15:02,839
F we relying on the C group filter hooks

00:15:01,130 --> 00:15:05,779
that were introduced I think around four

00:15:02,839 --> 00:15:07,579
six four seven because they get they are

00:15:05,779 --> 00:15:09,920
the only things that will give us the

00:15:07,579 --> 00:15:12,290
right information in terms of being able

00:15:09,920 --> 00:15:14,569
to access the UID of the app because the

00:15:12,290 --> 00:15:17,779
UID in Android is the app so accessing

00:15:14,569 --> 00:15:20,750
the app and also being able to count

00:15:17,779 --> 00:15:22,220
both ingress and egress and actually

00:15:20,750 --> 00:15:24,170
having the SK be available so they're

00:15:22,220 --> 00:15:27,709
only the only those hooks will do what

00:15:24,170 --> 00:15:28,910
we want so we have a program that's

00:15:27,709 --> 00:15:33,170
running all the time in the kernel

00:15:28,910 --> 00:15:34,399
updating data to maps and we have code

00:15:33,170 --> 00:15:37,010
and user space that's going to scrape

00:15:34,399 --> 00:15:39,769
them scrape the maps and additionally

00:15:37,010 --> 00:15:41,600
the user space code is going to when an

00:15:39,769 --> 00:15:43,310
app wants to tag a socket cuz napkin

00:15:41,600 --> 00:15:44,839
arbitrarily tag a socket with a

00:15:43,310 --> 00:15:46,610
particular value that's important to it

00:15:44,839 --> 00:15:48,769
when an app does this it's going to

00:15:46,610 --> 00:15:50,540
we're going to send our RPC to a

00:15:48,769 --> 00:15:51,860
privileged process that's going to write

00:15:50,540 --> 00:15:54,170
an entry into a map because we don't

00:15:51,860 --> 00:15:58,759
want random apps to be writing to BPF

00:15:54,170 --> 00:16:00,800
maps for security reasons so we have

00:15:58,759 --> 00:16:03,529
this coming up right now it's targeting

00:16:00,800 --> 00:16:05,870
4.9 which doesn't exist in any real

00:16:03,529 --> 00:16:07,480
device well not any currently sold

00:16:05,870 --> 00:16:11,320
device yet but

00:16:07,480 --> 00:16:14,800
eventually he will get 24.9 and so let's

00:16:11,320 --> 00:16:16,570
see we it's a relatively good fit but we

00:16:14,800 --> 00:16:18,670
have a few observations that first of

00:16:16,570 --> 00:16:20,740
all it's way more complicated than the

00:16:18,670 --> 00:16:22,389
original code was right I mean even

00:16:20,740 --> 00:16:24,130
though it's 3,000 lines of internal code

00:16:22,389 --> 00:16:25,899
at least it's one monolithic entity that

00:16:24,130 --> 00:16:27,519
you can reason about but now we have it

00:16:25,899 --> 00:16:30,720
like a big complicated system with lots

00:16:27,519 --> 00:16:32,800
of moving parts user space kernel space

00:16:30,720 --> 00:16:34,720
fortunately we don't believe we need to

00:16:32,800 --> 00:16:36,760
do any synchronization but if we did

00:16:34,720 --> 00:16:38,170
we'd you know you can't use locks

00:16:36,760 --> 00:16:39,880
between the kernel user space because

00:16:38,170 --> 00:16:41,889
the system will deadlock so it's it's

00:16:39,880 --> 00:16:44,170
it's kind of interesting very different

00:16:41,889 --> 00:16:46,779
programming level okay

00:16:44,170 --> 00:16:49,290
also many management you can't like

00:16:46,779 --> 00:16:51,579
resize a map once you've created it so

00:16:49,290 --> 00:16:54,160
unless you sort of create a new one and

00:16:51,579 --> 00:16:57,040
copy all the entries and you basically

00:16:54,160 --> 00:16:58,949
stuck with what you have and while it's

00:16:57,040 --> 00:17:01,990
ok for us to fail a socket tagging

00:16:58,949 --> 00:17:04,990
request from an app it's not never ok to

00:17:01,990 --> 00:17:06,400
say that an app can do network traffic

00:17:04,990 --> 00:17:08,470
without appearing in the data usage

00:17:06,400 --> 00:17:11,140
screen that's just not acceptable ever

00:17:08,470 --> 00:17:12,880
so we have to separate the maps because

00:17:11,140 --> 00:17:14,829
there are essentially fixed size we have

00:17:12,880 --> 00:17:17,169
to make sure that the UID map is

00:17:14,829 --> 00:17:18,850
separate from the tag map and in queue

00:17:17,169 --> 00:17:20,650
tag you 'ti you could just call K malloc

00:17:18,850 --> 00:17:22,870
and it would you know you just add a new

00:17:20,650 --> 00:17:24,790
tag but here you can't do that so well

00:17:22,870 --> 00:17:26,760
that will need garbage collection

00:17:24,790 --> 00:17:30,340
security model is not very fine-grained

00:17:26,760 --> 00:17:32,950
and also we and we're fixing some of

00:17:30,340 --> 00:17:35,140
that with selinux holes also these the

00:17:32,950 --> 00:17:37,090
EBP FC group filter call sites are

00:17:35,140 --> 00:17:38,770
really scatter around right if you

00:17:37,090 --> 00:17:43,750
there's a bunch of hooks that count

00:17:38,770 --> 00:17:45,549
packets and we had to we sent maybe five

00:17:43,750 --> 00:17:47,530
six patches upstream but count different

00:17:45,549 --> 00:17:50,350
types of packets we still have not

00:17:47,530 --> 00:17:51,880
figured out how to count ipv6 and X you

00:17:50,350 --> 00:17:52,960
don't receive a lot of you don't send a

00:17:51,880 --> 00:17:54,640
lot of sin acts on an Android device

00:17:52,960 --> 00:17:55,690
right so for now we're not going to cap

00:17:54,640 --> 00:17:58,780
you know we're not going to send them

00:17:55,690 --> 00:18:00,700
but it's kind of emblematic of I think a

00:17:58,780 --> 00:18:02,350
model which were these hooks are

00:18:00,700 --> 00:18:04,720
basically just all over the place and

00:18:02,350 --> 00:18:06,280
there's no like for net filter right

00:18:04,720 --> 00:18:07,929
you've got for insertion points you've

00:18:06,280 --> 00:18:10,090
got whatever you know you've got pre

00:18:07,929 --> 00:18:12,010
routing post routing and so on but for

00:18:10,090 --> 00:18:13,809
PPP efforts are like very ad hoc there's

00:18:12,010 --> 00:18:17,320
no like structure and where you put the

00:18:13,809 --> 00:18:20,159
hooks IPSec well except for M is always

00:18:17,320 --> 00:18:20,159
fun but

00:18:20,169 --> 00:18:23,379
I think will will have a handle on that

00:18:21,879 --> 00:18:26,679
we'll just estimate the overhead and put

00:18:23,379 --> 00:18:28,179
it in a map somewhere and yeah and then

00:18:26,679 --> 00:18:30,009
we you know crash recovery is also

00:18:28,179 --> 00:18:31,929
interesting because before this data was

00:18:30,009 --> 00:18:33,279
all in the kernel and now some of its in

00:18:31,929 --> 00:18:35,379
user space some of this in the kernel

00:18:33,279 --> 00:18:36,909
when the user space crashes you have to

00:18:35,379 --> 00:18:39,129
sort of reload the data from the kernel

00:18:36,909 --> 00:18:40,929
again so it's more complicated but it

00:18:39,129 --> 00:18:42,940
will be upstream and so we won't have

00:18:40,929 --> 00:18:44,889
any out of tree hacks so that's that's

00:18:42,940 --> 00:18:48,249
good and we're looking forward to it and

00:18:44,889 --> 00:18:50,200
once this is done will do will it'll

00:18:48,249 --> 00:18:51,970
it'll give us a lot more visibility into

00:18:50,200 --> 00:18:55,090
other network traffic types for example

00:18:51,970 --> 00:18:56,769
for TCP we're gonna scrape suck diag but

00:18:55,090 --> 00:18:58,960
for UDP we don't have that it's just not

00:18:56,769 --> 00:19:01,179
in the socket structures so we'll use

00:18:58,960 --> 00:19:03,159
the BPF maps to do TCP traffic

00:19:01,179 --> 00:19:04,899
accounting and and performance

00:19:03,159 --> 00:19:18,759
measurement and so on so we're looking

00:19:04,899 --> 00:19:21,159
forward to that that was next we have

00:19:18,759 --> 00:19:24,369
Shannon Nelson and he wants to talk

00:19:21,159 --> 00:19:24,970
about Mac VLAN acceleration you know

00:19:24,369 --> 00:19:28,590
better

00:19:24,970 --> 00:19:28,590
hooks for offload support

00:19:33,390 --> 00:19:36,799
so how many people here use Mac VLAN for

00:19:36,090 --> 00:19:39,450
anything

00:19:36,799 --> 00:19:43,799
couple of people okay does it work for

00:19:39,450 --> 00:19:47,370
you no yes no yeah there's a couple

00:19:43,799 --> 00:19:48,770
problems with it who owns it yeah

00:19:47,370 --> 00:19:51,809
there's one problem

00:19:48,770 --> 00:19:53,280
so I don't have any solutions I have

00:19:51,809 --> 00:19:56,460
mostly a bunch of questions that I've

00:19:53,280 --> 00:19:57,809
had in mind I've had Mac VLAN on the

00:19:56,460 --> 00:19:59,520
mind as a couple people will tell you

00:19:57,809 --> 00:20:02,250
for quite a while but I just haven't had

00:19:59,520 --> 00:20:04,650
a whole lot of time to worry about it I

00:20:02,250 --> 00:20:07,429
used to work for Intel I helped work on

00:20:04,650 --> 00:20:09,960
some of the fort ville I for TE driver

00:20:07,429 --> 00:20:12,990
and early on it was supposed to be a

00:20:09,960 --> 00:20:17,220
really good supporter of things like Mac

00:20:12,990 --> 00:20:19,559
VLAN vs I offload kind of stuff and that

00:20:17,220 --> 00:20:22,350
never really happened

00:20:19,559 --> 00:20:24,200
I'm turns out I've got a little bit of

00:20:22,350 --> 00:20:27,900
time to work on something like that now

00:20:24,200 --> 00:20:29,220
if anyone knows who Alex dike is he's

00:20:27,900 --> 00:20:30,870
working on it and he doesn't want me to

00:20:29,220 --> 00:20:34,110
touch it right now but I annoyed him by

00:20:30,870 --> 00:20:36,660
sending him patches anyway so I think

00:20:34,110 --> 00:20:39,540
that's moving along but there are some

00:20:36,660 --> 00:20:42,690
issues that we've seen the model that

00:20:39,540 --> 00:20:45,270
Mac VLAN has for offload doesn't quite

00:20:42,690 --> 00:20:47,190
match what we need to do in some of the

00:20:45,270 --> 00:20:50,910
bits of hardware and so we're looking at

00:20:47,190 --> 00:20:53,070
how can we change the model are there

00:20:50,910 --> 00:20:57,410
things that other people need different

00:20:53,070 --> 00:21:00,419
in the model one specific example is

00:20:57,410 --> 00:21:03,929
when you do the add station to do the

00:21:00,419 --> 00:21:06,980
offload of a Mac VLAN the driver returns

00:21:03,929 --> 00:21:09,990
a magic cookie your acceleration prove

00:21:06,980 --> 00:21:12,179
value whatever it is but the driver

00:21:09,990 --> 00:21:15,120
never gets it back in the stack except

00:21:12,179 --> 00:21:16,940
for doing select hue and of course any

00:21:15,120 --> 00:21:18,990
time you try to implement a select queue

00:21:16,940 --> 00:21:20,480
someone goes and slaps your hand because

00:21:18,990 --> 00:21:24,900
you're not supposed to use that anymore

00:21:20,480 --> 00:21:28,020
so the acceleration prove the magic

00:21:24,900 --> 00:21:29,850
cookie you get is pretty much useless so

00:21:28,020 --> 00:21:31,440
how can we change the API to make that a

00:21:29,850 --> 00:21:36,210
little more useful at least for the X

00:21:31,440 --> 00:21:38,630
MIT if not for some other of the met dev

00:21:36,210 --> 00:21:38,630
indios

00:21:39,680 --> 00:21:44,130
how many drivers are there how many

00:21:42,660 --> 00:21:47,040
pieces of hardware are there that could

00:21:44,130 --> 00:21:47,670
actually do max VLAN offloads do we have

00:21:47,040 --> 00:21:51,330
any idea

00:21:47,670 --> 00:21:54,180
I know IX GBE does it now more or less I

00:21:51,330 --> 00:21:57,420
for de can do it and hopefully we'll be

00:21:54,180 --> 00:21:58,260
doing it in the next few months this FM

00:21:57,420 --> 00:22:03,600
10k do it

00:21:58,260 --> 00:22:11,010
I think if M yes okay yes I was thinking

00:22:03,600 --> 00:22:13,050
FM 10k had it but I wasn't sure okay

00:22:11,010 --> 00:22:20,270
have you been playing with it does it

00:22:13,050 --> 00:22:20,270
work for you okay good did you

00:22:20,440 --> 00:22:26,239
to Maalox okay good good yeah I was

00:22:23,779 --> 00:22:28,070
playing with I was looking at a Mellanox

00:22:26,239 --> 00:22:29,359
card and trying to do just Mac VLAN

00:22:28,070 --> 00:22:31,639
stuff and it didn't look like it had a

00:22:29,359 --> 00:22:33,440
whole lot of individual cues or

00:22:31,639 --> 00:22:37,249
individual addresses that you could

00:22:33,440 --> 00:22:40,879
assign to it but we talked about that

00:22:37,249 --> 00:22:42,379
separately that's one of the things that

00:22:40,879 --> 00:22:45,169
you need to be able to do is make sure

00:22:42,379 --> 00:22:48,440
that you can shove MAC addresses down

00:22:45,169 --> 00:22:50,059
into your your Hardware filter so that

00:22:48,440 --> 00:22:52,459
it can find them separately and stick

00:22:50,059 --> 00:22:54,229
them onto a separate queue and then how

00:22:52,459 --> 00:22:56,690
do you manage those separate queues you

00:22:54,229 --> 00:22:58,479
have just one queue for this address or

00:22:56,690 --> 00:23:01,219
can you do a collection of queues and

00:22:58,479 --> 00:23:03,889
then manage how that collection of

00:23:01,219 --> 00:23:06,739
queues gets priorities or get some

00:23:03,889 --> 00:23:09,700
filtering magic going those are some

00:23:06,739 --> 00:23:09,700
things we're trying to work with

00:23:09,789 --> 00:23:16,159
software model I see bugs every once in

00:23:12,889 --> 00:23:17,779
a while in how the mac VLAN is working

00:23:16,159 --> 00:23:21,200
with bridging or isn't working with

00:23:17,779 --> 00:23:22,879
bridging should it be passing all the

00:23:21,200 --> 00:23:24,429
broadcast across tor should it be

00:23:22,879 --> 00:23:26,509
shoving them down and out the NIC

00:23:24,429 --> 00:23:30,049
there's still some work being done on

00:23:26,509 --> 00:23:32,029
some of that and I think Mac V tap could

00:23:30,049 --> 00:23:38,269
use a little bit of work in along with

00:23:32,029 --> 00:23:41,839
that so I guess one of my biggest

00:23:38,269 --> 00:23:43,609
questions is is there a plan does anyone

00:23:41,839 --> 00:23:46,129
have a plan of their own is there a

00:23:43,609 --> 00:23:51,499
general community plan on what to do

00:23:46,129 --> 00:23:53,269
with this I'm seeing blank stares that

00:23:51,499 --> 00:23:57,919
was my that was my question that was

00:23:53,269 --> 00:24:01,190
what I was thinking I'd like to have at

00:23:57,919 --> 00:24:05,029
least some acknowledgment that here are

00:24:01,190 --> 00:24:06,200
some things we need to do everyone we

00:24:05,029 --> 00:24:07,729
got several different people who are

00:24:06,200 --> 00:24:09,139
saying we need to work on this we need

00:24:07,729 --> 00:24:11,329
to fix this or we need to get it working

00:24:09,139 --> 00:24:15,469
on ours but I don't know that anyone's

00:24:11,329 --> 00:24:18,229
working together on it yet is that true

00:24:15,469 --> 00:24:20,479
I heard there are some discussions I

00:24:18,229 --> 00:24:22,729
guess in the TC workshop that may have

00:24:20,479 --> 00:24:24,889
been talking about that and but I didn't

00:24:22,729 --> 00:24:27,229
happen to make it feel discuss we had

00:24:24,889 --> 00:24:28,879
whenever you're presenting a TC workshop

00:24:27,229 --> 00:24:31,669
and while doing the disco Mac villain

00:24:28,879 --> 00:24:33,200
has has some switching which is either

00:24:31,669 --> 00:24:36,920
within the Mac live ileandra

00:24:33,200 --> 00:24:38,960
in the hardware and and beyond waiting

00:24:36,920 --> 00:24:40,580
in the main page the software model for

00:24:38,960 --> 00:24:42,440
the switching is not transparent to the

00:24:40,580 --> 00:24:45,350
kernel so it's written on the you do a

00:24:42,440 --> 00:24:46,790
mode you can you send it and so I'm

00:24:45,350 --> 00:24:49,580
noting the thing that it might be a

00:24:46,790 --> 00:24:51,140
problem and maybe it's not the correct

00:24:49,580 --> 00:24:53,300
thing to do and maybe we should stop

00:24:51,140 --> 00:24:56,060
develop this driver and and go to

00:24:53,300 --> 00:24:58,190
approach which is which base like a Vth

00:24:56,060 --> 00:25:00,140
or top that you have you have a

00:24:58,190 --> 00:25:02,720
representation of report and you plug it

00:25:00,140 --> 00:25:04,190
into a kernel switching element and you

00:25:02,720 --> 00:25:06,980
understand what's going on because one

00:25:04,190 --> 00:25:08,900
of the example that Giri gave us that if

00:25:06,980 --> 00:25:12,710
you take create a Mac villain device and

00:25:08,900 --> 00:25:14,480
you put it into a namespace now it's

00:25:12,710 --> 00:25:16,250
it's gone you cannot see it from the

00:25:14,480 --> 00:25:18,260
hypervisor so how the hell packets go

00:25:16,250 --> 00:25:20,570
there right the gada because some

00:25:18,260 --> 00:25:22,490
internal detail in the implementation of

00:25:20,570 --> 00:25:24,230
our deal of the Mac villian drivers lets

00:25:22,490 --> 00:25:27,320
them go there on the other hand you've

00:25:24,230 --> 00:25:29,420
got darker saying use this as a way to

00:25:27,320 --> 00:25:31,190
get your your specific traffic channel

00:25:29,420 --> 00:25:32,810
straight to your container in practice

00:25:31,190 --> 00:25:34,820
and say there are maybe three or four

00:25:32,810 --> 00:25:36,800
ways to have container networking right

00:25:34,820 --> 00:25:38,690
you have a Mac VLAN you have Vth you

00:25:36,800 --> 00:25:40,610
have BPF you'll probably have more yeah

00:25:38,690 --> 00:25:42,740
maybe we should not support all of them

00:25:40,610 --> 00:25:45,140
if one of them is is a bit broken where

00:25:42,740 --> 00:25:49,940
she maybe we should at least stop can't

00:25:45,140 --> 00:25:51,560
stop develop it not extend it okay I

00:25:49,940 --> 00:25:52,520
don't expect to solve these things I

00:25:51,560 --> 00:25:54,920
just wanted to bring them now I don't

00:25:52,520 --> 00:25:56,600
have to do in the next net can't talk

00:25:54,920 --> 00:25:58,190
about it a lot or have some lots of

00:25:56,600 --> 00:26:05,720
email and on the mailing list I don't

00:25:58,190 --> 00:26:10,780
see any other I've got a whole nother

00:26:05,720 --> 00:26:10,780
five or six minutes thank you

00:26:11,350 --> 00:26:16,580
do I have a customer that's working with

00:26:13,610 --> 00:26:18,320
Mac VLANs well I have I have management

00:26:16,580 --> 00:26:24,110
who said yeah go work on Mac VLANs a

00:26:18,320 --> 00:26:26,810
little bit the customers who use Mac

00:26:24,110 --> 00:26:30,760
villain on Ike's GB and I think Jamal

00:26:26,810 --> 00:26:30,760
was here AT&T uses that so

00:26:33,789 --> 00:26:38,029
community consensus maybe we can go to

00:26:35,960 --> 00:26:40,600
AT&T and other customers to Jamal and

00:26:38,029 --> 00:26:42,649
and tell them hey that's something I

00:26:40,600 --> 00:26:45,230
wouldn't think they would be opposed to

00:26:42,649 --> 00:26:46,879
it if we I mean most of the container

00:26:45,230 --> 00:26:48,769
acceleration is going in the direction

00:26:46,879 --> 00:26:51,110
where you would need lots of these

00:26:48,769 --> 00:26:53,600
virtual interfaces we poured our VM DQ

00:26:51,110 --> 00:26:55,249
interfaces and if Mac villain is not the

00:26:53,600 --> 00:26:56,990
right fit because it does not fit into

00:26:55,249 --> 00:26:58,639
the switch type model then we go with

00:26:56,990 --> 00:26:59,210
the we eat pair acceleration or

00:26:58,639 --> 00:27:03,409
something like that

00:26:59,210 --> 00:27:07,119
Oh Mac we're on with the Mac we don't

00:27:03,409 --> 00:27:11,539
represent oh sure yeah I mean either way

00:27:07,119 --> 00:27:12,980
pretty sure that switch based switching

00:27:11,539 --> 00:27:14,509
solution is more correct something that

00:27:12,980 --> 00:27:17,179
you care for a presentation to how you

00:27:14,509 --> 00:27:19,220
switch the containers and another end

00:27:17,179 --> 00:27:21,429
point which is within the container and

00:27:19,220 --> 00:27:23,720
that has also nice alignment with SRV

00:27:21,429 --> 00:27:25,820
where this is the model user and of

00:27:23,720 --> 00:27:27,799
course physical switches yeah I wouldn't

00:27:25,820 --> 00:27:29,389
disagree because with SRV we went the

00:27:27,799 --> 00:27:31,159
legacy route first where it became

00:27:29,389 --> 00:27:33,110
invisible and it was a problem and then

00:27:31,159 --> 00:27:35,869
we had to invent the switch there out so

00:27:33,110 --> 00:27:37,399
now we already know that it it works you

00:27:35,869 --> 00:27:38,809
know best for a survey then we do the

00:27:37,399 --> 00:27:40,340
same thing for the container right we

00:27:38,809 --> 00:27:50,600
fix this for a survey now let's fix it

00:27:40,340 --> 00:27:54,440
yeah I guess we have a few more minutes

00:27:50,600 --> 00:27:57,679
if anybody else mustard oh sorry

00:27:54,440 --> 00:28:00,279
oh is that right okay I guess we're done

00:27:57,679 --> 00:28:00,279

YouTube URL: https://www.youtube.com/watch?v=NE9j74M0P7w


