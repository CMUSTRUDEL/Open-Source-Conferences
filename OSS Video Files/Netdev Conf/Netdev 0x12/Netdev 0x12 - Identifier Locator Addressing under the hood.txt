Title: Netdev 0x12 - Identifier Locator Addressing under the hood
Publication date: 2018-08-01
Playlist: Netdev 0x12
Description: 
	ILA has come a long way since the netdev 0.1 days.
In this talk at Netdev 0x12 in Montreal on July 13th, 2018, Tom Herbert provided an overview of the ILA protocol, motivation and use cases. He further provided an update of protocol standardization efforts and then explored ILA implementation internals of both kernel and user space. Finally Tom ran a demo of a simulated RAN-in-a-box.

More info:
https://www.netdevconf.org/0x12/session.html?identifier-locator-addressing-under-the-hood
Captions: 
	00:00:00,420 --> 00:00:05,879
my name is Tom Herbert I'm going to talk

00:00:02,370 --> 00:00:07,470
about identifier locator addressing this

00:00:05,879 --> 00:00:10,740
time around it's me more about the

00:00:07,470 --> 00:00:12,990
implementation so hopefully some of you

00:00:10,740 --> 00:00:15,630
are at least familiar with this that's

00:00:12,990 --> 00:00:17,760
been a proposal we've had going on and

00:00:15,630 --> 00:00:21,779
gets three or four years now started at

00:00:17,760 --> 00:00:23,670
Facebook and then kind of a grew into

00:00:21,779 --> 00:00:26,070
some IETF of amount of start at Google I

00:00:23,670 --> 00:00:26,410
can't remember no anyway next slide

00:00:26,070 --> 00:00:29,780
please

00:00:26,410 --> 00:00:29,780
[Music]

00:00:33,469 --> 00:00:42,030
I thought I thought it was voice

00:00:36,300 --> 00:00:45,480
recognition so sorry okay so I only in a

00:00:42,030 --> 00:00:48,570
nutshell it's a mobile mobility type of

00:00:45,480 --> 00:00:51,210
protocol and this is using a tripe of

00:00:48,570 --> 00:00:53,879
address transformation where we split IP

00:00:51,210 --> 00:00:56,160
v ipv6 addresses into a locator and

00:00:53,879 --> 00:00:59,160
identifier so locator is kind of like

00:00:56,160 --> 00:01:02,039
the wearer of the packet and identifier

00:00:59,160 --> 00:01:05,309
is the who so the analogy I usually use

00:01:02,039 --> 00:01:07,530
is somebody has both an address where

00:01:05,309 --> 00:01:09,030
they they might live but they also have

00:01:07,530 --> 00:01:11,010
a name so if I want to send a packet to

00:01:09,030 --> 00:01:14,340
somebody I give the address and the name

00:01:11,010 --> 00:01:15,630
on the mailing envelope and if that

00:01:14,340 --> 00:01:18,000
person happens to go to a different

00:01:15,630 --> 00:01:20,070
house or get in their car their name

00:01:18,000 --> 00:01:21,720
does not change so that's their identity

00:01:20,070 --> 00:01:24,210
so that remains with them but their

00:01:21,720 --> 00:01:26,340
location does and in order to send to

00:01:24,210 --> 00:01:27,840
them I have to now update their location

00:01:26,340 --> 00:01:30,360
but there are identity remains the same

00:01:27,840 --> 00:01:31,979
hopefully I can find that so the analogy

00:01:30,360 --> 00:01:34,259
is pretty strong keep it in mind because

00:01:31,979 --> 00:01:36,869
as we go go through with this we'll see

00:01:34,259 --> 00:01:41,060
that the kind of the address lookup for

00:01:36,869 --> 00:01:43,200
names it has a lot of parallels to that

00:01:41,060 --> 00:01:46,350
so some important things applications

00:01:43,200 --> 00:01:49,740
they only see identifiers in this sort

00:01:46,350 --> 00:01:51,540
of protocol locator is the current

00:01:49,740 --> 00:01:54,390
location and as we mentioned that can

00:01:51,540 --> 00:01:56,549
change the lookup that I just mentioned

00:01:54,390 --> 00:01:59,610
as a sort of database that map's

00:01:56,549 --> 00:02:02,850
identifiers to locators it's really like

00:01:59,610 --> 00:02:05,610
a lookup table so tom is at this address

00:02:02,850 --> 00:02:10,739
so we kind of match those two pieces of

00:02:05,610 --> 00:02:12,180
information aisle a nodes do address

00:02:10,739 --> 00:02:12,830
transformation so this gets a little

00:02:12,180 --> 00:02:14,960
more into

00:02:12,830 --> 00:02:17,270
that the details of the protocol and a

00:02:14,960 --> 00:02:21,290
slide that'll show that a little bit in

00:02:17,270 --> 00:02:26,540
a little bit and one important thing

00:02:21,290 --> 00:02:29,390
about ila it is not NAT its address

00:02:26,540 --> 00:02:30,680
transformation and this came up on one

00:02:29,390 --> 00:02:32,690
of the mailing lists a little while ago

00:02:30,680 --> 00:02:35,120
the fundamental difference is that

00:02:32,690 --> 00:02:40,220
there's no loss of information door

00:02:35,120 --> 00:02:42,470
during and ila transformation so going

00:02:40,220 --> 00:02:45,110
back to the analogy if I send a letter

00:02:42,470 --> 00:02:47,690
through the post office and they might

00:02:45,110 --> 00:02:50,060
they might rewrite the addressing to be

00:02:47,690 --> 00:02:51,890
or my name or something that to be some

00:02:50,060 --> 00:02:54,260
other location and use that for

00:02:51,890 --> 00:02:55,940
forwarding the the packet they might put

00:02:54,260 --> 00:02:58,790
in another envelope for instance to send

00:02:55,940 --> 00:03:01,160
it to to the local post office at that

00:02:58,790 --> 00:03:04,010
local post office all that information

00:03:01,160 --> 00:03:06,860
is removed and we get back to this was

00:03:04,010 --> 00:03:11,090
the original packet or letter so a

00:03:06,860 --> 00:03:13,820
important thing highlight not not so

00:03:11,090 --> 00:03:16,940
this pictorially is the addressing and

00:03:13,820 --> 00:03:20,390
transformation of ila so you can imagine

00:03:16,940 --> 00:03:21,470
at the top we have an ipv6 address it

00:03:20,390 --> 00:03:23,750
split down the middle

00:03:21,470 --> 00:03:26,060
in a canonical fashion so the top 64

00:03:23,750 --> 00:03:27,920
bits are what we call a syrup reflect

00:03:26,060 --> 00:03:30,350
standard interface representation or

00:03:27,920 --> 00:03:32,720
identifier representation and the bottom

00:03:30,350 --> 00:03:35,959
is the identifier so the identifier is

00:03:32,720 --> 00:03:37,459
that component that is constant within

00:03:35,959 --> 00:03:41,330
the network or with and within the

00:03:37,459 --> 00:03:43,760
domain so every host every VM every

00:03:41,330 --> 00:03:44,840
individual individually addressable note

00:03:43,760 --> 00:03:47,510
for instance would have a unique

00:03:44,840 --> 00:03:50,360
identifier it's in 64-bit space so

00:03:47,510 --> 00:03:52,100
that's that's pretty reasonable the Cir

00:03:50,360 --> 00:03:55,430
prefix is really the routing component

00:03:52,100 --> 00:03:58,520
of this the Cir prefix to start with is

00:03:55,430 --> 00:04:00,680
very generic for instance all of the

00:03:58,520 --> 00:04:02,959
nodes in a particular could share the

00:04:00,680 --> 00:04:05,120
same cert prefix that actually might

00:04:02,959 --> 00:04:08,510
just be the routable prefix for say a

00:04:05,120 --> 00:04:11,150
provider that's running ila within their

00:04:08,510 --> 00:04:14,810
network so it could even be globally

00:04:11,150 --> 00:04:17,989
routable the transformation occurs when

00:04:14,810 --> 00:04:20,989
we rearrange that sir prefix and

00:04:17,989 --> 00:04:23,240
actually the the second line should

00:04:20,989 --> 00:04:24,710
actually say locate locator so the cert

00:04:23,240 --> 00:04:26,420
prefix is written into something called

00:04:24,710 --> 00:04:27,920
a locator and this is

00:04:26,420 --> 00:04:29,450
mountable within the network and this is

00:04:27,920 --> 00:04:31,400
the part where we use this to get

00:04:29,450 --> 00:04:35,690
packets to where they're going the

00:04:31,400 --> 00:04:38,300
analog to an encapsulation is when we do

00:04:35,690 --> 00:04:40,730
an encapsulation say a VX land and

00:04:38,300 --> 00:04:43,430
capsulation or IP and IP we put an extra

00:04:40,730 --> 00:04:46,190
IP header on the outside of a packet and

00:04:43,430 --> 00:04:48,940
that destination address is now really

00:04:46,190 --> 00:04:51,230
the locator so ila is is very simple

00:04:48,940 --> 00:04:52,460
kind of almost a simple form of

00:04:51,230 --> 00:04:55,190
encapsulation or compressed

00:04:52,460 --> 00:04:57,590
encapsulation from that point of view so

00:04:55,190 --> 00:04:59,900
this transformation to a locator is done

00:04:57,590 --> 00:05:03,650
in order for the packet to transit the

00:04:59,900 --> 00:05:05,350
network and at the peer like I said at

00:05:03,650 --> 00:05:07,100
some pure endpoint there's a reverse

00:05:05,350 --> 00:05:09,740
transformation to get back to the

00:05:07,100 --> 00:05:12,170
original packet so this is a little more

00:05:09,740 --> 00:05:14,120
topology topological as to what the

00:05:12,170 --> 00:05:18,620
packet is doing so you can imagine the

00:05:14,120 --> 00:05:21,200
source some application running they get

00:05:18,620 --> 00:05:24,860
a Sur address a server address is that

00:05:21,200 --> 00:05:26,990
the common prefix plus the identifier so

00:05:24,860 --> 00:05:30,170
in this case the prefix might be the

00:05:26,990 --> 00:05:32,420
quad 3 the colon colon 1 is the

00:05:30,170 --> 00:05:34,760
identifier so applications see this

00:05:32,420 --> 00:05:36,740
they're very visible they don't convey

00:05:34,760 --> 00:05:39,860
specific location information they can

00:05:36,740 --> 00:05:41,510
be in DNS very public so the source

00:05:39,860 --> 00:05:44,560
sends a packet and somewhere in the path

00:05:41,510 --> 00:05:47,000
we have to deduce where is this

00:05:44,560 --> 00:05:49,220
identifier which is indicated by the

00:05:47,000 --> 00:05:50,720
colon colon 1 where is that node

00:05:49,220 --> 00:05:53,150
actually located so it's going to be

00:05:50,720 --> 00:05:56,210
somewhere but that could be a mobile

00:05:53,150 --> 00:05:57,620
destination so in the beginning this

00:05:56,210 --> 00:06:00,830
might go to something called an ila

00:05:57,620 --> 00:06:03,260
router which does the lookup on the IP

00:06:00,830 --> 00:06:05,900
address or at least the identifier that

00:06:03,260 --> 00:06:07,640
map's it to a locator the locator is

00:06:05,900 --> 00:06:10,550
that that routable prefix that actually

00:06:07,640 --> 00:06:12,470
gets to the destination where the node

00:06:10,550 --> 00:06:14,750
is currently at so in this case the

00:06:12,470 --> 00:06:16,490
locator is quad 2 colon 1

00:06:14,750 --> 00:06:20,990
that's what's basically saying there's a

00:06:16,490 --> 00:06:22,700
64-bit prefix that's assigned to some

00:06:20,990 --> 00:06:25,820
intermediate node and possibly even the

00:06:22,700 --> 00:06:28,880
end host but in some node that is the

00:06:25,820 --> 00:06:31,820
location of this particular identifier

00:06:28,880 --> 00:06:33,920
so the transformation happens in line

00:06:31,820 --> 00:06:36,890
with first we do the lookup then we do

00:06:33,920 --> 00:06:39,290
the transformation there is an overwrite

00:06:36,890 --> 00:06:40,190
of 64 bits and the top bits of the

00:06:39,290 --> 00:06:42,380
destination

00:06:40,190 --> 00:06:44,230
then the packets is sent back into the

00:06:42,380 --> 00:06:47,690
network and now it has an actual

00:06:44,230 --> 00:06:51,050
routable locator to it so the packet

00:06:47,690 --> 00:06:54,590
gets routed to the destination where the

00:06:51,050 --> 00:06:57,080
note is that is currently at and at that

00:06:54,590 --> 00:06:59,420
point when it's received we have to undo

00:06:57,080 --> 00:07:01,640
this process we have to get back to the

00:06:59,420 --> 00:07:04,040
original packet so we just simply

00:07:01,640 --> 00:07:07,250
transform reverse transform that quat to

00:07:04,040 --> 00:07:11,110
: 1 calling : 1 back 2 quad 3 calling :

00:07:07,250 --> 00:07:13,400
1 and so the application at the end its

00:07:11,110 --> 00:07:15,140
destination address that it sees on its

00:07:13,400 --> 00:07:19,160
packets is again the quad 3 :

00:07:15,140 --> 00:07:21,920
hole-in-one so this is a pretty simple

00:07:19,160 --> 00:07:24,350
concept one thing that would be nice is

00:07:21,920 --> 00:07:25,430
to eliminate the triangular routing here

00:07:24,350 --> 00:07:28,190
so do we always want to have to go

00:07:25,430 --> 00:07:29,780
through this ila router so to do order

00:07:28,190 --> 00:07:31,670
to do that we do have a concept of

00:07:29,780 --> 00:07:34,430
redirects this is very similar to an

00:07:31,670 --> 00:07:37,760
ICMP redirect and the idea is if the

00:07:34,430 --> 00:07:40,340
router gets a packet it might want to

00:07:37,760 --> 00:07:42,380
send back redirect information to

00:07:40,340 --> 00:07:44,240
towards the source at least saying

00:07:42,380 --> 00:07:46,910
there's a better path you can do the

00:07:44,240 --> 00:07:50,570
aisle a transformation yourself so

00:07:46,910 --> 00:07:53,120
that's what number 3 would do and that

00:07:50,570 --> 00:07:57,260
goes back to the source and then at

00:07:53,120 --> 00:07:59,960
after that like in 0.5 the sources can

00:07:57,260 --> 00:08:01,520
actually send direct directly so this is

00:07:59,960 --> 00:08:03,740
actually kind of a two-level routing

00:08:01,520 --> 00:08:06,380
hierarchy so the ila routers you can

00:08:03,740 --> 00:08:09,200
imagine those are actually fairly high

00:08:06,380 --> 00:08:11,510
load routers in the network and maybe

00:08:09,200 --> 00:08:14,419
the devices towards the source are at

00:08:11,510 --> 00:08:16,460
the source or more caches for ila and

00:08:14,419 --> 00:08:17,900
they just have a working set and as long

00:08:16,460 --> 00:08:19,550
as it worth in that working set we can

00:08:17,900 --> 00:08:21,350
avoid the triangular routing and get a

00:08:19,550 --> 00:08:22,580
very direct path this is going to have a

00:08:21,350 --> 00:08:25,640
lot to do with how we want to achieve

00:08:22,580 --> 00:08:29,210
low latency or super low latency and

00:08:25,640 --> 00:08:32,450
networks by getting down to the most

00:08:29,210 --> 00:08:34,849
direct path in mobile so that instead of

00:08:32,450 --> 00:08:36,110
going five hops deep into the network we

00:08:34,849 --> 00:08:38,120
can only go maybe two or three

00:08:36,110 --> 00:08:43,849
so there'll be a lot of latency savings

00:08:38,120 --> 00:08:45,410
there a few benefits of ila and it's no

00:08:43,849 --> 00:08:48,260
protocol overhead so like I said

00:08:45,410 --> 00:08:51,050
encapsulation not involved no extension

00:08:48,260 --> 00:08:53,720
headers are required that has a few

00:08:51,050 --> 00:08:56,090
ramifications so one of the things

00:08:53,720 --> 00:08:58,190
there's no typical tunneling issues

00:08:56,090 --> 00:08:59,900
anytime we do tunneling within the

00:08:58,190 --> 00:09:01,970
network we have to consider what happens

00:08:59,900 --> 00:09:05,060
if when we increase the size of the

00:09:01,970 --> 00:09:06,500
packet it exceeds them to you so that is

00:09:05,060 --> 00:09:08,540
a little bit of a pain to deal with and

00:09:06,500 --> 00:09:10,580
it's multiple use case so we started

00:09:08,540 --> 00:09:14,480
this as a way to do data center

00:09:10,580 --> 00:09:16,400
virtualization it's kind of morphed into

00:09:14,480 --> 00:09:19,010
also a mobility solution for mobile

00:09:16,400 --> 00:09:20,780
networks in the mobile networks this

00:09:19,010 --> 00:09:22,280
would be a mechanism to provide anchor

00:09:20,780 --> 00:09:25,190
alyssum ability particularly the

00:09:22,280 --> 00:09:26,780
redirect mechanism may help there we're

00:09:25,190 --> 00:09:29,950
also advocating strong privacy in

00:09:26,780 --> 00:09:33,590
addressing this has a lot to do with the

00:09:29,950 --> 00:09:36,230
exposure of kind of personally

00:09:33,590 --> 00:09:38,120
identifiable information in addresses so

00:09:36,230 --> 00:09:41,630
you can imagine if I have a mobile

00:09:38,120 --> 00:09:44,300
network and my node bees which are

00:09:41,630 --> 00:09:46,490
basically the the end devices at cell

00:09:44,300 --> 00:09:49,940
towers those have a very specific

00:09:46,490 --> 00:09:52,730
location and if my locator is exactly

00:09:49,940 --> 00:09:55,640
the address of one of these ena B n

00:09:52,730 --> 00:09:59,270
systems if somebody sees that they see

00:09:55,640 --> 00:10:01,760
they're sending to their friend or maybe

00:09:59,270 --> 00:10:02,900
not even their friend ex-girlfriend or

00:10:01,760 --> 00:10:04,820
something that they're sending to them

00:10:02,900 --> 00:10:06,980
we don't want them to be able to look at

00:10:04,820 --> 00:10:10,790
that the actual addresses and figure out

00:10:06,980 --> 00:10:13,100
where they are with any specificity so

00:10:10,790 --> 00:10:14,480
we want to keep that kind of hidden so

00:10:13,100 --> 00:10:17,030
iolite does have those components

00:10:14,480 --> 00:10:19,070
there's also some more general how do we

00:10:17,030 --> 00:10:22,040
do privacy and addressing that we're

00:10:19,070 --> 00:10:24,350
looking at flexible and scalable control

00:10:22,040 --> 00:10:26,780
plane resistance to denial of service

00:10:24,350 --> 00:10:29,330
this is kind of interesting especially

00:10:26,780 --> 00:10:30,920
with a redirect mechanism there are some

00:10:29,330 --> 00:10:33,860
properties that make this more appealing

00:10:30,920 --> 00:10:38,060
than say more like an ARP type of

00:10:33,860 --> 00:10:40,150
mechanism where you request the the next

00:10:38,060 --> 00:10:42,890
hop in the eyalet and you get a response

00:10:40,150 --> 00:10:45,800
so the reason we don't like that is

00:10:42,890 --> 00:10:49,250
because a lot of this could be user

00:10:45,800 --> 00:10:51,140
driven and say a mobile network where if

00:10:49,250 --> 00:10:53,180
we don't every time the user creates a a

00:10:51,140 --> 00:10:55,010
new destination we're doing this long

00:10:53,180 --> 00:10:58,190
look up installing packets and things

00:10:55,010 --> 00:10:59,720
like that so denial service is a really

00:10:58,190 --> 00:11:02,750
critical component of this especially in

00:10:59,720 --> 00:11:04,570
the control plane and then we have an

00:11:02,750 --> 00:11:07,020
upstream kernel Pat the data path

00:11:04,570 --> 00:11:10,860
there's also some other work

00:11:07,020 --> 00:11:12,780
VPP has something and we also have a XDP

00:11:10,860 --> 00:11:16,410
implementation but today we're look at

00:11:12,780 --> 00:11:19,140
the kernel side only so I was speaking

00:11:16,410 --> 00:11:22,590
of the kernel so I always been an

00:11:19,140 --> 00:11:24,870
upstream Linux since about 4.3 the

00:11:22,590 --> 00:11:26,520
modern version came in at 4.15 this was

00:11:24,870 --> 00:11:30,570
actually changing how we do some of the

00:11:26,520 --> 00:11:33,930
check sums and how we integrate types

00:11:30,570 --> 00:11:34,700
into the the ILA kind of address

00:11:33,930 --> 00:11:37,860
structure

00:11:34,700 --> 00:11:40,950
it's a kernel module it's ila loads

00:11:37,860 --> 00:11:43,140
pretty easily one of the big wins was

00:11:40,950 --> 00:11:46,560
lightweight tunnels once we have that

00:11:43,140 --> 00:11:48,570
that allows us to integrate the ila

00:11:46,560 --> 00:11:50,730
processing the i/o Lee I only look up

00:11:48,570 --> 00:11:52,350
into the routing table so on a host is

00:11:50,730 --> 00:11:55,380
especially important because then we can

00:11:52,350 --> 00:11:58,470
cache the route lookup in TCP connection

00:11:55,380 --> 00:12:01,650
so i la can be done without any sort of

00:11:58,470 --> 00:12:03,900
lookups on the transmit path and then

00:12:01,650 --> 00:12:08,120
receive path we hooked into the pre

00:12:03,900 --> 00:12:11,460
routing hook we needed something before

00:12:08,120 --> 00:12:13,530
major packet processing early D MUX

00:12:11,460 --> 00:12:16,380
happens so we use that as a routing hook

00:12:13,530 --> 00:12:18,360
pretty lightweight that's where we do

00:12:16,380 --> 00:12:20,700
the reverse transformation after packets

00:12:18,360 --> 00:12:24,080
received with IO and IL a destination

00:12:20,700 --> 00:12:28,100
and then as I mentioned we have ila and

00:12:24,080 --> 00:12:31,290
VPP and x DP so in terms of performance

00:12:28,100 --> 00:12:34,200
this is the latest performance numbers I

00:12:31,290 --> 00:12:36,390
ran it's kind of a grand view of all the

00:12:34,200 --> 00:12:39,480
major encapsulations

00:12:36,390 --> 00:12:42,990
and includes segments routing in ipv6

00:12:39,480 --> 00:12:44,880
and these basically divide up into some

00:12:42,990 --> 00:12:46,160
major categories so all of the IP and IP

00:12:44,880 --> 00:12:48,600
encapsulations

00:12:46,160 --> 00:12:51,860
especially the UDP ones are pretty much

00:12:48,600 --> 00:12:54,150
the same same latency same performance

00:12:51,860 --> 00:12:58,290
kind of makes sense so once we get the

00:12:54,150 --> 00:13:00,210
the checksum squared away get hash for

00:12:58,290 --> 00:13:02,060
ecmp and RSS squared away it works out

00:13:00,210 --> 00:13:05,420
pretty well

00:13:02,060 --> 00:13:05,420
IP and IP

00:13:07,190 --> 00:13:12,180
that you d p encapsulation this one can

00:13:10,830 --> 00:13:13,920
go either way so it says one thing I

00:13:12,180 --> 00:13:16,530
should mention is a lot of the

00:13:13,920 --> 00:13:18,210
performance difference here is dependent

00:13:16,530 --> 00:13:20,140
on the hardware accelerations in

00:13:18,210 --> 00:13:24,880
particular checksum offload

00:13:20,140 --> 00:13:27,820
or SS so this was done on a thinkin

00:13:24,880 --> 00:13:30,580
Intel I'd have to check it but whatever

00:13:27,820 --> 00:13:34,480
it is it's supported IP ipv6 and ipv6

00:13:30,580 --> 00:13:36,430
encapsulation because we got actually

00:13:34,480 --> 00:13:38,440
didn't support it for our SS but it

00:13:36,430 --> 00:13:40,990
might have supported for checksum so we

00:13:38,440 --> 00:13:42,730
got kind of a lower GPS but if you look

00:13:40,990 --> 00:13:44,830
at the encapsulations because they have

00:13:42,730 --> 00:13:47,200
our SS for UDP we actually got much

00:13:44,830 --> 00:13:50,590
higher throughput pretty typical what we

00:13:47,200 --> 00:13:52,960
see if there are SS work start dozen in

00:13:50,590 --> 00:13:55,570
this sort of test so segment routing was

00:13:52,960 --> 00:13:57,850
kind of interesting and kind of had

00:13:55,570 --> 00:14:01,000
mixed results so the segment routing in

00:13:57,850 --> 00:14:04,420
line which is where in order to do our

00:14:01,000 --> 00:14:06,370
SS over the port's or checksum some

00:14:04,420 --> 00:14:09,970
checksum offload you would actually need

00:14:06,370 --> 00:14:11,860
the device to parse over the segment

00:14:09,970 --> 00:14:13,750
routing headers but segment routing end

00:14:11,860 --> 00:14:16,600
cap apparently worked fine so that was

00:14:13,750 --> 00:14:19,000
kind of or I guess is a vice-versa some

00:14:16,600 --> 00:14:20,500
one of them works one of them didn't but

00:14:19,000 --> 00:14:22,690
I lay the thing I wanted to point out

00:14:20,500 --> 00:14:24,940
here it actually is the the closest of

00:14:22,690 --> 00:14:26,380
any overlay overlay technique or

00:14:24,940 --> 00:14:30,040
encapsulation technique that I was able

00:14:26,380 --> 00:14:33,160
to test so it's about 3.3 percent within

00:14:30,040 --> 00:14:35,260
native ipv6 so that's almost purely just

00:14:33,160 --> 00:14:38,350
the the processing overhead there's in

00:14:35,260 --> 00:14:40,960
this test there was one lookup simple

00:14:38,350 --> 00:14:42,790
hash lookup and then the overhead to

00:14:40,960 --> 00:14:44,590
manipulate the package so it's probably

00:14:42,790 --> 00:14:50,290
pretty close to as fast as we're gonna

00:14:44,590 --> 00:14:53,110
get for an overlay technique so I'll a

00:14:50,290 --> 00:14:55,420
control plane this is the part where we

00:14:53,110 --> 00:14:58,230
manage the mapping tables and this is a

00:14:55,420 --> 00:15:01,150
whole topic in itself it's definitely

00:14:58,230 --> 00:15:04,030
and in some sense it's elaborate date

00:15:01,150 --> 00:15:07,150
well it's elaborate routing router

00:15:04,030 --> 00:15:09,910
daemon our decision there was to

00:15:07,150 --> 00:15:11,980
actually use database to do the backend

00:15:09,910 --> 00:15:14,410
information so this is kind of an lieu

00:15:11,980 --> 00:15:16,810
of using a routing protocol so we are

00:15:14,410 --> 00:15:18,910
seeing kind of this trend towards

00:15:16,810 --> 00:15:21,880
routing systems I think Facebook

00:15:18,910 --> 00:15:24,550
actually has a great example where an

00:15:21,880 --> 00:15:26,760
actual database is used to synchronize

00:15:24,550 --> 00:15:29,920
the information new convergence and

00:15:26,760 --> 00:15:31,570
things like that so right now we're

00:15:29,920 --> 00:15:32,940
using Redis this could turn into a

00:15:31,570 --> 00:15:36,150
distributed hash table

00:15:32,940 --> 00:15:38,370
or or other possibilities but the the

00:15:36,150 --> 00:15:40,350
important characteristic here is this is

00:15:38,370 --> 00:15:43,800
a fixed-length lookup so it's a simple

00:15:40,350 --> 00:15:45,150
key value lookup database is great for

00:15:43,800 --> 00:15:47,430
that key value stores are great for that

00:15:45,150 --> 00:15:50,040
and we actually divide this up into

00:15:47,430 --> 00:15:52,410
three databases so I'll kind of have

00:15:50,040 --> 00:15:54,450
some little more information on that but

00:15:52,410 --> 00:15:57,840
there's a locator database identify our

00:15:54,450 --> 00:15:59,700
mapping so in the github you can also

00:15:57,840 --> 00:16:02,310
find a number of executables to control

00:15:59,700 --> 00:16:04,680
this so there's some control demons and

00:16:02,310 --> 00:16:06,540
also a CLI that allows inspection of the

00:16:04,680 --> 00:16:12,150
databases in specs in the mapping table

00:16:06,540 --> 00:16:15,380
and kind of to control the mobility so

00:16:12,150 --> 00:16:19,410
the architecture of the user components

00:16:15,380 --> 00:16:21,150
there's three major types of nodes in a

00:16:19,410 --> 00:16:22,740
la ila

00:16:21,150 --> 00:16:25,860
routers I already mentioned those are

00:16:22,740 --> 00:16:27,690
kind of the the central points once the

00:16:25,860 --> 00:16:30,090
packets routed to annihilate router

00:16:27,690 --> 00:16:32,880
it's expected to be Oh to convert the

00:16:30,090 --> 00:16:35,250
server address to annihilate address or

00:16:32,880 --> 00:16:36,990
the route doesn't exist so they are kind

00:16:35,250 --> 00:16:40,230
of authoritative from that point of view

00:16:36,990 --> 00:16:42,300
kind of like a router and a normal

00:16:40,230 --> 00:16:45,470
router in that sense we do know that

00:16:42,300 --> 00:16:48,510
there's potentially a lot of mapping so

00:16:45,470 --> 00:16:50,940
every node for instance potentially has

00:16:48,510 --> 00:16:52,380
its own mapping so scalability comes up

00:16:50,940 --> 00:16:54,630
very quickly in these sort of mapping

00:16:52,380 --> 00:16:56,010
systems so these effectively become

00:16:54,630 --> 00:16:57,840
hosts routes you could have millions and

00:16:56,010 --> 00:16:59,820
millions these so scalability on

00:16:57,840 --> 00:17:01,770
something like a Nile a router is going

00:16:59,820 --> 00:17:04,439
to be important and that quickly gets us

00:17:01,770 --> 00:17:06,120
into we need to shard the mapping space

00:17:04,439 --> 00:17:07,560
in order to have multiple routers and

00:17:06,120 --> 00:17:09,990
each of them takes care of part of this

00:17:07,560 --> 00:17:11,880
space and then in a real deployment

00:17:09,990 --> 00:17:14,430
you'd obviously want to replicate each

00:17:11,880 --> 00:17:16,770
of those routers to some extent an eye

00:17:14,430 --> 00:17:19,170
only node on the other hand is more of

00:17:16,770 --> 00:17:21,949
the the end point in the network towards

00:17:19,170 --> 00:17:24,360
the user it does two things one is it

00:17:21,949 --> 00:17:26,069
handles the eyalet to store address

00:17:24,360 --> 00:17:29,520
translations so when packets are coming

00:17:26,069 --> 00:17:31,740
in to an end device for instance with an

00:17:29,520 --> 00:17:33,390
ila address this is a location that

00:17:31,740 --> 00:17:34,710
actually transforms a packet in

00:17:33,390 --> 00:17:36,360
preparation to give it to the

00:17:34,710 --> 00:17:38,820
application so it's kind of the terminal

00:17:36,360 --> 00:17:40,560
point for ionely there is something

00:17:38,820 --> 00:17:41,760
called an ila host which is the same

00:17:40,560 --> 00:17:44,580
thing but it's actually host site

00:17:41,760 --> 00:17:45,210
functionality the only difference there

00:17:44,580 --> 00:17:46,470
is

00:17:45,210 --> 00:17:48,570
and ila host actually has some

00:17:46,470 --> 00:17:50,370
opportunities to integrate with some

00:17:48,570 --> 00:17:52,169
other parts of the stack like like I

00:17:50,370 --> 00:17:55,679
mentioned the TCP in the early d MUX

00:17:52,169 --> 00:17:57,179
so the Ilam is the management plane

00:17:55,679 --> 00:17:59,669
that's where the databases are housed

00:17:57,179 --> 00:18:01,770
and where we have a control daemon so

00:17:59,669 --> 00:18:04,860
all of the management goes through this

00:18:01,770 --> 00:18:07,500
and the il am basically programs the ila

00:18:04,860 --> 00:18:10,890
routers with some sort of protocol and

00:18:07,500 --> 00:18:12,960
they may actually new outers themselves

00:18:10,890 --> 00:18:15,299
might actually talk with the AI LAN over

00:18:12,960 --> 00:18:19,250
a caching protocol and then the pink

00:18:15,299 --> 00:18:19,250
line is kind of a simple data path

00:18:23,809 --> 00:18:28,590
reference topology somewhat too much

00:18:26,580 --> 00:18:30,690
about this it kind of is a similar

00:18:28,590 --> 00:18:33,450
description of what I just described so

00:18:30,690 --> 00:18:37,049
the ila routers all the edges those

00:18:33,450 --> 00:18:39,510
would be kind of the analog of border

00:18:37,049 --> 00:18:41,880
routers probably the same location and

00:18:39,510 --> 00:18:43,380
ila ends would be in the network these

00:18:41,880 --> 00:18:45,860
would be where caches or house close to

00:18:43,380 --> 00:18:49,260
the user and then your ila hosts may be

00:18:45,860 --> 00:18:51,750
mobile edge computing or host like that

00:18:49,260 --> 00:18:54,059
where we're interested in optimizing the

00:18:51,750 --> 00:18:58,580
the application so it makes sense but

00:18:54,059 --> 00:19:02,909
ila in conjunction with the actual host

00:18:58,580 --> 00:19:05,309
so given that I do have a demo and this

00:19:02,909 --> 00:19:08,570
is the the kind of the demo topology

00:19:05,309 --> 00:19:11,760
it's basically a mobile network in a box

00:19:08,570 --> 00:19:14,240
so the way this is structured it's going

00:19:11,760 --> 00:19:16,500
to use network namespaces and Linux so

00:19:14,240 --> 00:19:18,779
the things in parentheses are all the

00:19:16,500 --> 00:19:20,730
different namespaces and this kind of a

00:19:18,779 --> 00:19:23,730
construction jam you laid a mobile

00:19:20,730 --> 00:19:26,279
network so the ran simulates the the

00:19:23,730 --> 00:19:28,380
backbone we have an internet host out

00:19:26,279 --> 00:19:32,130
there talks through a gateway into the

00:19:28,380 --> 00:19:34,230
the radio network and then there's some

00:19:32,130 --> 00:19:36,210
number of a node bees again this kind of

00:19:34,230 --> 00:19:39,299
the base stations so I have ten of those

00:19:36,210 --> 00:19:43,500
and below that or each of those has ten

00:19:39,299 --> 00:19:46,409
and hosts user equipment in mobile

00:19:43,500 --> 00:19:48,840
terminology so the database is the

00:19:46,409 --> 00:19:53,279
locator and they identify ER these

00:19:48,840 --> 00:19:55,080
describe the the components what it in

00:19:53,279 --> 00:19:57,120
identifiers are in the system

00:19:55,080 --> 00:19:58,460
what locators are in the system the

00:19:57,120 --> 00:19:59,930
initial mapping

00:19:58,460 --> 00:20:03,740
is in the identifier locator day

00:19:59,930 --> 00:20:05,510
database to identify related database to

00:20:03,740 --> 00:20:08,120
locate our database and then the mapping

00:20:05,510 --> 00:20:11,990
database is more the operational one in

00:20:08,120 --> 00:20:15,260
this case we don't have a control plane

00:20:11,990 --> 00:20:16,340
yet or a specific control plane protocol

00:20:15,260 --> 00:20:23,120
everything's done through a shared

00:20:16,340 --> 00:20:25,250
database so before I go to the demo let

00:20:23,120 --> 00:20:27,740
me talk a little bit about the futures

00:20:25,250 --> 00:20:29,800
so one of the things we want to have is

00:20:27,740 --> 00:20:33,620
something called high lamp Isle a

00:20:29,800 --> 00:20:35,060
mapping protocol this is a cash

00:20:33,620 --> 00:20:38,120
management protocol so if you remember

00:20:35,060 --> 00:20:39,800
the ILA ends might have a cache this

00:20:38,120 --> 00:20:41,270
would be something that handles the ILA

00:20:39,800 --> 00:20:43,730
redirects for instance so we do have a

00:20:41,270 --> 00:20:46,070
protocol for that my personal preference

00:20:43,730 --> 00:20:49,340
is that we just move this all to TCP and

00:20:46,070 --> 00:20:51,830
rest and then have a nice simple yet

00:20:49,340 --> 00:20:54,410
extensible protocol to say here's the

00:20:51,830 --> 00:20:56,480
identifier here's the map go ahead and

00:20:54,410 --> 00:20:59,090
use this from now on so shouldn't be too

00:20:56,480 --> 00:21:00,140
complex but given the way these sort of

00:20:59,090 --> 00:21:06,140
things work I'm sure there'd be

00:21:00,140 --> 00:21:10,040
extensions and what-have-you and so the

00:21:06,140 --> 00:21:13,070
other thing is there's an alternative

00:21:10,040 --> 00:21:15,050
approach so in a normal type of mapping

00:21:13,070 --> 00:21:17,870
system you have a lookup it happens on

00:21:15,050 --> 00:21:20,960
every packet say when a packet hits an

00:21:17,870 --> 00:21:22,730
ila router there's a lookup as I

00:21:20,960 --> 00:21:25,010
mentioned this can be very expensive

00:21:22,730 --> 00:21:26,810
there could be completely different

00:21:25,010 --> 00:21:29,360
alternatives where we actually somehow

00:21:26,810 --> 00:21:31,820
carry the locator information in the

00:21:29,360 --> 00:21:36,170
data packets themselves and the idea is

00:21:31,820 --> 00:21:37,820
we tell the the end application we give

00:21:36,170 --> 00:21:42,050
it some token we actually call it

00:21:37,820 --> 00:21:45,440
tickets and in our proposal we give the

00:21:42,050 --> 00:21:47,840
end host a ticket and say put this on to

00:21:45,440 --> 00:21:49,340
an extension header and we understand

00:21:47,840 --> 00:21:51,290
what it is you probably don't but this

00:21:49,340 --> 00:21:54,860
somehow encodes the locator information

00:21:51,290 --> 00:21:56,840
so when the packet is sent say from a ue

00:21:54,860 --> 00:21:58,610
goes into the network if it's sending to

00:21:56,840 --> 00:22:01,760
the internet there's actually no need

00:21:58,610 --> 00:22:03,260
for ila because the destination is on

00:22:01,760 --> 00:22:05,330
the internet so the packets just routed

00:22:03,260 --> 00:22:07,850
normally the interesting case is usually

00:22:05,330 --> 00:22:10,130
coming back so in packets enter a

00:22:07,850 --> 00:22:11,780
network a mobile network we have to find

00:22:10,130 --> 00:22:11,929
the destination for them so that's where

00:22:11,780 --> 00:22:15,499
we

00:22:11,929 --> 00:22:16,970
the lookup normally but in this case if

00:22:15,499 --> 00:22:20,149
we have the information attached on the

00:22:16,970 --> 00:22:21,799
outgoing and somehow the server is smart

00:22:20,149 --> 00:22:24,529
enough to reflect that information on

00:22:21,799 --> 00:22:26,090
reply packets then those reply packets

00:22:24,529 --> 00:22:28,909
that come in they have this information

00:22:26,090 --> 00:22:31,279
attached and this router at the border

00:22:28,909 --> 00:22:32,960
can actually look at that and say oh the

00:22:31,279 --> 00:22:34,549
locator is embedded in here I can just

00:22:32,960 --> 00:22:36,700
use that information and send directly

00:22:34,549 --> 00:22:38,980
so we don't need to lookup and

00:22:36,700 --> 00:22:41,509
conceptually this may be out of scale

00:22:38,980 --> 00:22:43,269
the number of nodes scaling is going to

00:22:41,509 --> 00:22:46,039
be a big issue here for various reasons

00:22:43,269 --> 00:22:48,110
even today we we need about a billion

00:22:46,039 --> 00:22:50,869
nodes but that could go much higher with

00:22:48,110 --> 00:22:54,169
some of our addressing models so there's

00:22:50,869 --> 00:23:00,590
probably some other things with that but

00:22:54,169 --> 00:23:05,179
I would like to do the demo so we'll see

00:23:00,590 --> 00:23:08,570
how this one goes so all of this is

00:23:05,179 --> 00:23:12,789
available in github and what we're going

00:23:08,570 --> 00:23:12,789
to do first is create that topology

00:23:22,580 --> 00:23:26,720
so what it's doing it's creating that

00:23:25,190 --> 00:23:29,480
we're namespaces the first few things

00:23:26,720 --> 00:23:31,760
we're creating the Redis databases so as

00:23:29,480 --> 00:23:35,570
I mentioned there are three and those

00:23:31,760 --> 00:23:38,060
primarily run in the ran namespace then

00:23:35,570 --> 00:23:40,340
we created the ten a node B's and then

00:23:38,060 --> 00:23:42,050
we created the work let's see one the

00:23:40,340 --> 00:23:43,970
Yui so we're creating the hundred you

00:23:42,050 --> 00:23:46,820
E's and then after this we'll attach

00:23:43,970 --> 00:23:48,320
them obviously this is pretty slow so I

00:23:46,820 --> 00:23:55,580
think it's has a lot to do with

00:23:48,320 --> 00:23:56,930
scripting and kind of this the interface

00:23:55,580 --> 00:23:58,400
model is pretty crazy so we're you

00:23:56,930 --> 00:24:01,010
having a lot of network interfaces I

00:23:58,400 --> 00:24:03,140
think moving forward when we get a

00:24:01,010 --> 00:24:04,360
little closer to full-scale aisle a

00:24:03,140 --> 00:24:06,650
deployment we're obviously going to need

00:24:04,360 --> 00:24:09,280
better emulator of this be able to

00:24:06,650 --> 00:24:13,460
create networks much larger

00:24:09,280 --> 00:24:15,760
automatically and emulate them so it's

00:24:13,460 --> 00:24:19,840
almost done with first 100 you ease and

00:24:15,760 --> 00:24:19,840
let me prepare the next step

00:24:37,730 --> 00:24:43,399
so as I mentioned code is on github one

00:24:41,269 --> 00:24:47,000
of the things we try to do is make it

00:24:43,399 --> 00:24:48,950
really easy to build so one thing they

00:24:47,000 --> 00:24:51,049
noticed doing user space development

00:24:48,950 --> 00:24:53,299
kernel was complexity this actually has

00:24:51,049 --> 00:24:55,100
a pretty simple built environment once

00:24:53,299 --> 00:24:59,269
you get into some users face stuff it's

00:24:55,100 --> 00:25:01,309
pretty crazy on the number of modules

00:24:59,269 --> 00:25:04,700
packages you need to actually build

00:25:01,309 --> 00:25:08,649
something reasonable okay so first thing

00:25:04,700 --> 00:25:08,649
let's check out the network namespaces

00:25:11,950 --> 00:25:16,340
so a whole bunch of network namespaces

00:25:14,480 --> 00:25:19,669
so they're labeled Yui you node B

00:25:16,340 --> 00:25:24,380
there's I ran one gateway one if we look

00:25:19,669 --> 00:25:28,909
at the interfaces for one of these you

00:25:24,380 --> 00:25:31,970
know B's basically every every interface

00:25:28,909 --> 00:25:35,389
wherever Yui became a virtual interface

00:25:31,970 --> 00:25:37,039
so when you note B has ten southbound

00:25:35,389 --> 00:25:38,929
network interfaces then on one

00:25:37,039 --> 00:25:42,049
northbound that goes into the upper

00:25:38,929 --> 00:25:44,330
layer which in this case is the RAM so

00:25:42,049 --> 00:25:48,409
all that seems to be set up and we can

00:25:44,330 --> 00:25:51,070
look at the various tables that were

00:25:48,409 --> 00:25:51,070
constructed

00:25:52,330 --> 00:25:58,240
so this is the locator less I mentioned

00:25:55,510 --> 00:26:00,130
the first number is just the index so

00:25:58,240 --> 00:26:02,380
every locator has a simple index and

00:26:00,130 --> 00:26:05,920
then the next number is actually a

00:26:02,380 --> 00:26:10,630
64-bit real locator so locator number

00:26:05,920 --> 00:26:12,370
two simply has 2017 : 0 0 : 2 so this

00:26:10,630 --> 00:26:13,540
pretty arbitrary but this is the part

00:26:12,370 --> 00:26:15,040
that's going to be routable on the

00:26:13,540 --> 00:26:20,560
network so effectively this is the

00:26:15,040 --> 00:26:26,170
address of an ila node so we can do the

00:26:20,560 --> 00:26:28,720
same thing for the identifier table so

00:26:26,170 --> 00:26:30,400
this is a list of all the identifiers so

00:26:28,720 --> 00:26:31,900
I've had similar format so the first

00:26:30,400 --> 00:26:35,500
number is just an index that we can

00:26:31,900 --> 00:26:38,820
reference whatever identifier we want by

00:26:35,500 --> 00:26:41,080
an index the next number is the server

00:26:38,820 --> 00:26:42,850
address for that so the first part is

00:26:41,080 --> 00:26:45,700
that quad 3 again as a syrup refix

00:26:42,850 --> 00:26:47,980
that's our prefix and then the number

00:26:45,700 --> 00:26:50,800
after that is just the identifier and

00:26:47,980 --> 00:26:52,660
it's a simple incrementing counter so

00:26:50,800 --> 00:26:54,340
those are the first two databases and as

00:26:52,660 --> 00:26:56,440
I mentioned those are mostly used in the

00:26:54,340 --> 00:26:58,450
in the control plane the one that

00:26:56,440 --> 00:27:00,820
actually kind of drives the

00:26:58,450 --> 00:27:04,900
instantiation of the mappings of the

00:27:00,820 --> 00:27:06,100
mappings and the kernel is the mapping

00:27:04,900 --> 00:27:08,980
database so this has a little more

00:27:06,100 --> 00:27:12,310
information some information that could

00:27:08,980 --> 00:27:20,880
be used by the kernel so if you look at

00:27:12,310 --> 00:27:20,880
the if you look at the the routes

00:27:27,160 --> 00:27:34,720
so the routes at the top were actually

00:27:31,210 --> 00:27:37,330
the ILA LWT routes these are fully

00:27:34,720 --> 00:27:39,550
instantiated so the first thing is just

00:27:37,330 --> 00:27:42,310
a simple destination so these become

00:27:39,550 --> 00:27:46,060
host routes on this system and then the

00:27:42,310 --> 00:27:50,320
ILA LWT specific information follows

00:27:46,060 --> 00:27:52,000
that so there's a few there are a few

00:27:50,320 --> 00:27:54,400
options here so one of the most

00:27:52,000 --> 00:27:57,160
important ones is checksum so when we do

00:27:54,400 --> 00:28:00,340
the ILA transformation we do want to

00:27:57,160 --> 00:28:02,950
maintain TCP and UDP checksum so it's

00:28:00,340 --> 00:28:06,910
actually a nice trick that was created

00:28:02,950 --> 00:28:09,370
by some of the ipv6 type ev4 network

00:28:06,910 --> 00:28:12,730
transformation it's possible to actually

00:28:09,370 --> 00:28:15,130
maintain the checksum which might have

00:28:12,730 --> 00:28:17,470
this include the pseudo header in say

00:28:15,130 --> 00:28:20,050
TCP or UDP checksum maintain that

00:28:17,470 --> 00:28:21,730
checksum to be correct even in flight so

00:28:20,050 --> 00:28:23,530
we're changing the destination address

00:28:21,730 --> 00:28:25,420
normally that would affect the checksum

00:28:23,530 --> 00:28:26,620
and make it incorrect but it turns out

00:28:25,420 --> 00:28:28,540
if you make an equivalent change

00:28:26,620 --> 00:28:30,880
somewhere in the packet to offset the

00:28:28,540 --> 00:28:33,870
change just made then it's kind of a

00:28:30,880 --> 00:28:37,150
checksum neutral thing so pretty good

00:28:33,870 --> 00:28:40,000
discussion on that on some of the

00:28:37,150 --> 00:28:42,070
original work for ipv6 translation so I

00:28:40,000 --> 00:28:49,410
just adopt that or just adopted some of

00:28:42,070 --> 00:28:52,660
that the other things there are some

00:28:49,410 --> 00:28:54,660
concept of different typed addresses so

00:28:52,660 --> 00:28:59,470
we can support multicast for instance

00:28:54,660 --> 00:29:05,140
there's an ipv4 over ipv6 format and

00:28:59,470 --> 00:29:07,630
this one is the canonical 64 64 split

00:29:05,140 --> 00:29:09,220
those are kind of optional so per site

00:29:07,630 --> 00:29:12,370
you may or may not use something like

00:29:09,220 --> 00:29:15,450
that so now let's try to crank up some

00:29:12,370 --> 00:29:15,450
crank up some traffic

00:29:20,800 --> 00:29:26,110
so by the way most of these commands the

00:29:23,800 --> 00:29:29,830
first argument is running in a in the

00:29:26,110 --> 00:29:33,850
network namespace so that's the argument

00:29:29,830 --> 00:29:41,140
that follows the command so for instance

00:29:33,850 --> 00:29:45,520
here we're running okay so here we're

00:29:41,140 --> 00:29:48,780
running TCP dump on any node B and then

00:29:45,520 --> 00:29:52,440
it's dumping that northbound interface

00:29:48,780 --> 00:29:52,440
so if we ping

00:30:07,310 --> 00:30:12,230
so here we are pinging and if we look at

00:30:10,400 --> 00:30:14,450
TCP dump the thing to notice is the

00:30:12,230 --> 00:30:18,440
destination addresses so we're pinging

00:30:14,450 --> 00:30:22,790
quad 358 but you'll notice the address

00:30:18,440 --> 00:30:27,530
on the wire is let's see so the ICMP

00:30:22,790 --> 00:30:32,300
requests is quad or 2017 : zero zero

00:30:27,530 --> 00:30:35,030
nine so that's the locator of quad 3 :

00:30:32,300 --> 00:30:39,140
home to 58 and then the identifier

00:30:35,030 --> 00:30:41,450
portion is this crazy one three one sees

00:30:39,140 --> 00:30:43,370
it that's actually a result of the

00:30:41,450 --> 00:30:45,470
checksum neutral so the checksum neutral

00:30:43,370 --> 00:30:48,970
fits in there that's actually the

00:30:45,470 --> 00:30:51,350
correct value for identifier one so the

00:30:48,970 --> 00:30:52,910
remote peer knows too when it does

00:30:51,350 --> 00:30:55,340
reverse transformation to undo the

00:30:52,910 --> 00:30:58,070
checksum neutral and it will wind up at

00:30:55,340 --> 00:31:00,680
the original destination so you also

00:30:58,070 --> 00:31:02,480
notice that the replies also are doing

00:31:00,680 --> 00:31:05,450
ila so we're coming in to this address

00:31:02,480 --> 00:31:07,910
and they have a similar transformation

00:31:05,450 --> 00:31:09,800
so I oh they can definitely be applied

00:31:07,910 --> 00:31:13,220
in both directions however you also

00:31:09,800 --> 00:31:14,750
notice a source address does not do ila

00:31:13,220 --> 00:31:17,530
so we never actually do ila in the

00:31:14,750 --> 00:31:26,480
source address it's only destination

00:31:17,530 --> 00:31:30,430
so now let's get TCP dump so basically

00:31:26,480 --> 00:31:33,950
we have one you a ping into another and

00:31:30,430 --> 00:31:38,830
let's see what happens when the UE were

00:31:33,950 --> 00:31:38,830
pinging goes off the network

00:31:42,870 --> 00:31:49,750
so the Sun attached it so meaning now

00:31:47,800 --> 00:31:52,690
this year we went out of range it's not

00:31:49,750 --> 00:31:55,000
really attached to anyone so it's out of

00:31:52,690 --> 00:31:57,490
it so what happens ping stop says it as

00:31:55,000 --> 00:31:59,290
it should and systems don't knows about

00:31:57,490 --> 00:32:01,150
it but doesn't have any location so many

00:31:59,290 --> 00:32:04,450
packets just are dropped because there's

00:32:01,150 --> 00:32:07,030
no route to it so sometime later but

00:32:04,450 --> 00:32:08,200
maybe this is a car and it comes back in

00:32:07,030 --> 00:32:14,080
the network but now it comes to a

00:32:08,200 --> 00:32:17,860
completely different cell site so we can

00:32:14,080 --> 00:32:19,270
reattach that node node number 88 now

00:32:17,860 --> 00:32:23,530
instead of being on I think I was eight

00:32:19,270 --> 00:32:25,390
before now it's on you know b3 so it

00:32:23,530 --> 00:32:28,330
went from one to the other so that

00:32:25,390 --> 00:32:31,480
process actually is very specific in the

00:32:28,330 --> 00:32:33,190
mobile world caught handover if you

00:32:31,480 --> 00:32:36,820
remember the discussion we had yesterday

00:32:33,190 --> 00:32:39,700
on super low latency it's one thing to

00:32:36,820 --> 00:32:41,470
have super low latency in the data path

00:32:39,700 --> 00:32:43,150
which I think something like ila would

00:32:41,470 --> 00:32:45,040
provide but you also have to consider

00:32:43,150 --> 00:32:47,770
this case where I have an application

00:32:45,040 --> 00:32:50,230
running and just by virtue of passing

00:32:47,770 --> 00:32:51,970
from one cell side to another I really

00:32:50,230 --> 00:32:55,210
can't afford to take a several hundred

00:32:51,970 --> 00:32:57,880
millisecond hit so the latency for this

00:32:55,210 --> 00:32:59,740
actually becomes very imperative and it

00:32:57,880 --> 00:33:01,510
is a difficult problem because it has a

00:32:59,740 --> 00:33:04,840
lot to do with how to get the control

00:33:01,510 --> 00:33:07,660
plane the actual radio networks and all

00:33:04,840 --> 00:33:08,860
of those to coop cooperate there's some

00:33:07,660 --> 00:33:10,960
interesting solutions some people

00:33:08,860 --> 00:33:13,330
actually when you know you're going to

00:33:10,960 --> 00:33:15,429
transform or move to somebody else

00:33:13,330 --> 00:33:16,320
actually fork packets and like replicate

00:33:15,429 --> 00:33:20,350
them so there's some interesting

00:33:16,320 --> 00:33:23,660
possibilities there any any case I think

00:33:20,350 --> 00:33:26,719
that's all I had are there any questions

00:33:23,660 --> 00:33:26,719
[Music]

00:33:33,640 --> 00:33:41,590
so what's the difference between this

00:33:35,380 --> 00:33:43,150
and Lisp excuse me so what's the

00:33:41,590 --> 00:33:46,540
difference between what you're proposing

00:33:43,150 --> 00:33:47,320
you're an Lisp unless you've never heard

00:33:46,540 --> 00:33:52,980
of have you heard of Lisp

00:33:47,320 --> 00:33:52,980
yeah sure Lisp is an encapsulation and

00:33:53,100 --> 00:33:58,090
for this purpose we can divide the world

00:33:55,510 --> 00:34:02,140
into two two types of things so one is

00:33:58,090 --> 00:34:04,000
more address transformation you can

00:34:02,140 --> 00:34:06,850
almost argue that nad actually has some

00:34:04,000 --> 00:34:10,659
of these similar properties and Lisp is

00:34:06,850 --> 00:34:13,119
an encapsulation the primary difference

00:34:10,659 --> 00:34:16,090
here is simply we're not adding anything

00:34:13,119 --> 00:34:19,119
to the packet so a packet sent from an

00:34:16,090 --> 00:34:21,310
application say a TCP packet the address

00:34:19,119 --> 00:34:24,100
is transformed on the network it's still

00:34:21,310 --> 00:34:26,889
TCP which does have a big advantage

00:34:24,100 --> 00:34:31,690
because networks have been built out to

00:34:26,889 --> 00:34:34,450
support TCP UDP there are already aware

00:34:31,690 --> 00:34:36,190
of that also has the advantage we're not

00:34:34,450 --> 00:34:38,950
adding we're not making packet headers

00:34:36,190 --> 00:34:41,050
bigger if you look at the IOT space for

00:34:38,950 --> 00:34:43,419
instance packets are getting are getting

00:34:41,050 --> 00:34:46,119
actually getting smaller so a packet

00:34:43,419 --> 00:34:48,399
from a sensor may have 100 bytes if

00:34:46,119 --> 00:34:51,840
we're adding another 200 bytes on that

00:34:48,399 --> 00:34:54,669
or 300 bytes like some of some of these

00:34:51,840 --> 00:34:56,740
more rich functionalities could have so

00:34:54,669 --> 00:34:58,810
list 4 segment routing you end up having

00:34:56,740 --> 00:35:00,790
a lot of packet overhead for a little

00:34:58,810 --> 00:35:02,650
little data so you would think in the

00:35:00,790 --> 00:35:03,730
modern modern world this isn't an issue

00:35:02,650 --> 00:35:06,250
but there are still bandwidth

00:35:03,730 --> 00:35:07,330
constrained links we know from low pan

00:35:06,250 --> 00:35:10,330
and things like that where this is

00:35:07,330 --> 00:35:12,070
actually actually compelling so in some

00:35:10,330 --> 00:35:14,170
sense it accomplishes some similar goals

00:35:12,070 --> 00:35:17,020
it is identifier locator but the

00:35:14,170 --> 00:35:19,510
mechanisms and in particular the packet

00:35:17,020 --> 00:35:21,130
format are pretty different the control

00:35:19,510 --> 00:35:23,050
plane actually could be leveraged and we

00:35:21,130 --> 00:35:25,150
are talking with the list guys and some

00:35:23,050 --> 00:35:27,990
others could there be a command control

00:35:25,150 --> 00:35:27,990
plane to control this

00:35:29,330 --> 00:35:33,350
any any more questions

00:35:40,910 --> 00:35:45,160
alright I'll take that as a no thank you

00:35:43,339 --> 00:35:49,420
thanks Tom

00:35:45,160 --> 00:35:49,420

YouTube URL: https://www.youtube.com/watch?v=XmIs8xTUnns


