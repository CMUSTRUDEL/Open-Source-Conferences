Title: Netdev 0x12 - Achieving super low latency for critical real world Internet applications - Workshop
Publication date: 2018-07-31
Playlist: Netdev 0x12
Description: 
	Tom Herbert chaired a session which went into requirements for achieving super
low latency for critical real world Internet applications.

Field applications and IoT require low latency (we are talking Sub 10 msecs),
high throughput and secure, and highly reliable communications.  Think traffic
intersection monitoring, remote surgery, industrial robotics, etc.  How do we
get there on Linux?

He attempted to motivate the discussion with a live physical demo of traffic
intersection using a slot car track.

More info:
https://www.netdevconf.org/0x12/session.html?achieving-super-low-latency-for-critical-real-world-internet-applications
Captions: 
	00:00:00,560 --> 00:00:09,570
okay I guess we can get started

00:00:06,180 --> 00:00:11,910
so my name is Tom Herbert first of all I

00:00:09,570 --> 00:00:12,570
want to make a special shout-out to

00:00:11,910 --> 00:00:14,929
jamel's

00:00:12,570 --> 00:00:17,400
organizing the conference also

00:00:14,929 --> 00:00:19,500
committing I was actually the so called

00:00:17,400 --> 00:00:20,789
Shepherd forward which means I got to

00:00:19,500 --> 00:00:22,470
watch them do their work and actually

00:00:20,789 --> 00:00:25,619
couldn't do anything

00:00:22,470 --> 00:00:28,199
Roopa was the chair and then we had I

00:00:25,619 --> 00:00:30,830
think eight others who did a lot of work

00:00:28,199 --> 00:00:46,110
to actually look at each presentation

00:00:30,830 --> 00:00:48,750
its technical merit okay so I'm going to

00:00:46,110 --> 00:00:53,910
talk a little bit about achieving super

00:00:48,750 --> 00:00:56,760
low latency workshop I guess the point

00:00:53,910 --> 00:01:00,210
of this is more or less to raise the

00:00:56,760 --> 00:01:02,100
problem try to get people thinking about

00:01:00,210 --> 00:01:05,100
it there's a lot of pieces to the end

00:01:02,100 --> 00:01:11,490
goal it is quite ambitious what we're

00:01:05,100 --> 00:01:14,280
trying to do so super low latency

00:01:11,490 --> 00:01:20,400
obviously has a lot of meetings so for

00:01:14,280 --> 00:01:22,409
instance we hear a lot about talking

00:01:20,400 --> 00:01:25,020
about super low latency on the internet

00:01:22,409 --> 00:01:28,049
so this is what user perceived latency

00:01:25,020 --> 00:01:31,670
would be and the reason we need this is

00:01:28,049 --> 00:01:41,820
in real-time applications so imagine

00:01:31,670 --> 00:01:45,329
self-driving cars mobile surgery various

00:01:41,820 --> 00:01:47,909
cases where super latency is critical

00:01:45,329 --> 00:01:54,500
and when we talk about super low latency

00:01:47,909 --> 00:01:54,500
and veritably it really is about latency

00:01:55,200 --> 00:02:01,799
so if we say we have a five millisecond

00:01:57,240 --> 00:02:11,179
latency because we want to serve AR that

00:02:01,799 --> 00:02:11,179
really means the variance what have you

00:02:12,270 --> 00:02:16,830
and the other part about this sometimes

00:02:15,270 --> 00:02:18,570
people tend to forget it's not just a

00:02:16,830 --> 00:02:21,570
data path the control path halston

00:02:18,570 --> 00:02:24,720
becomes part of the latency and as we

00:02:21,570 --> 00:02:26,640
know like a TCP set up time or security

00:02:24,720 --> 00:02:29,220
set up the security Association set up

00:02:26,640 --> 00:02:31,290
time these things can often be orders of

00:02:29,220 --> 00:02:34,920
magnitude greater than what we consider

00:02:31,290 --> 00:02:37,170
to see in a real world application and

00:02:34,920 --> 00:02:39,240
mobile device driving down the street in

00:02:37,170 --> 00:02:40,980
the car for instance guessing from one

00:02:39,240 --> 00:02:42,560
cell to another there's this thing

00:02:40,980 --> 00:02:46,050
called handover and there's a lot of

00:02:42,560 --> 00:02:48,420
change to that how fast you can recover

00:02:46,050 --> 00:02:49,980
and get to get back on path for the

00:02:48,420 --> 00:02:52,590
application it's critical after it

00:02:49,980 --> 00:02:55,440
passes from one to another so we're

00:02:52,590 --> 00:02:59,160
going to be looking at kind of both of

00:02:55,440 --> 00:03:02,100
those this is some numbers I pulled off

00:02:59,160 --> 00:03:05,280
the web I found a nice paper that was

00:03:02,100 --> 00:03:10,410
specifically about a our augmented

00:03:05,280 --> 00:03:14,850
reality and augmented back with few

00:03:10,410 --> 00:03:16,830
extra numbers so at the 500 millisecond

00:03:14,850 --> 00:03:18,540
one and a half second range this is

00:03:16,830 --> 00:03:21,530
actually you typically consider the

00:03:18,540 --> 00:03:24,660
human latency in an automobile accident

00:03:21,530 --> 00:03:27,180
500 milliseconds so they do the studies

00:03:24,660 --> 00:03:30,330
they found that people are so distracted

00:03:27,180 --> 00:03:32,180
that they just assume that you can 500

00:03:30,330 --> 00:03:40,830
milliseconds a second to make a decision

00:03:32,180 --> 00:03:42,690
so that's kind of what can we go down

00:03:40,830 --> 00:03:45,210
from that about a quarter of a second

00:03:42,690 --> 00:03:49,260
that's the average human reaction time

00:03:45,210 --> 00:03:51,590
for visual stimuli when you get down to

00:03:49,260 --> 00:04:01,080
about 200 milliseconds this is when

00:03:51,590 --> 00:04:03,690
speech starts to be the baseline for

00:04:01,080 --> 00:04:06,210
what a great car driver he was about 200

00:04:03,690 --> 00:04:08,580
milliseconds but once we go P like that

00:04:06,210 --> 00:04:11,959
we start to get into kind of the

00:04:08,580 --> 00:04:11,959
subconscious types of

00:04:12,230 --> 00:04:16,970
so about 20 milliseconds that's where

00:04:15,410 --> 00:04:21,950
you can actually start to detect

00:04:16,970 --> 00:04:24,169
differences and say our visual input 10

00:04:21,950 --> 00:04:26,660
milliseconds haptic delay that's been at

00:04:24,169 --> 00:04:29,030
the touch so if you have a Wii

00:04:26,660 --> 00:04:31,400
controller that shakes millisecond

00:04:29,030 --> 00:04:32,570
latency for perception but what are the

00:04:31,400 --> 00:04:35,540
more interesting ones all the way down

00:04:32,570 --> 00:04:40,810
to 5 milliseconds this is later so

00:04:35,540 --> 00:04:44,660
called cyber sickness so device and

00:04:40,810 --> 00:04:53,229
there's a jitter or 5 milliseconds in

00:04:44,660 --> 00:04:53,229
that so 5 milliseconds to really push

00:05:00,310 --> 00:05:04,669
interactions so what kind of

00:05:03,169 --> 00:05:07,160
applications are there so we mentioned

00:05:04,669 --> 00:05:09,650
augmented reality we are gaming is going

00:05:07,160 --> 00:05:12,740
to be very interested in this certainly

00:05:09,650 --> 00:05:15,110
a lot of application of the IOT space I

00:05:12,740 --> 00:05:17,510
would consider self-driving cars traffic

00:05:15,110 --> 00:05:22,700
systems some of those clearly factory

00:05:17,510 --> 00:05:24,500
floor robotics also they tend to have

00:05:22,700 --> 00:05:26,450
some interesting and kind of common

00:05:24,500 --> 00:05:29,750
characteristics one of those is multi

00:05:26,450 --> 00:05:32,240
dimensional input this kind of dovetails

00:05:29,750 --> 00:05:38,260
into the applying machine learning and

00:05:32,240 --> 00:05:38,260
AI very complex sophisticated systems

00:05:39,130 --> 00:05:44,510
almost conflicting goals you're trying

00:05:41,270 --> 00:05:47,000
to do incredibly complex things like a

00:05:44,510 --> 00:05:49,220
human very quick quicker than a person

00:05:47,000 --> 00:05:51,919
so we get in the computer vision AI

00:05:49,220 --> 00:05:54,020
machine learning and at some point these

00:05:51,919 --> 00:05:56,090
do become life or death kind of

00:05:54,020 --> 00:05:58,880
decisions we've already seen this with

00:05:56,090 --> 00:06:03,680
the self-driving cars they make a

00:05:58,880 --> 00:06:05,210
mistake this maintaining that latency

00:06:03,680 --> 00:06:11,389
guarantee actually becomes quite

00:06:05,210 --> 00:06:16,970
critical in certain environments so one

00:06:11,389 --> 00:06:20,440
of the more interesting traffic

00:06:16,970 --> 00:06:20,440
intersection so you can imagine

00:06:21,169 --> 00:06:25,069
there's lights there may be cameras

00:06:23,509 --> 00:06:28,009
there's the destra hands there's cars

00:06:25,069 --> 00:06:30,319
some of them self-driving most people

00:06:28,009 --> 00:06:32,629
have a smartphone so the question is how

00:06:30,319 --> 00:06:34,219
do we modernize this in order to get the

00:06:32,629 --> 00:06:37,460
most efficiency through this

00:06:34,219 --> 00:06:40,370
intersection but also make it safe so

00:06:37,460 --> 00:06:42,680
this is in some sense its futuristic the

00:06:40,370 --> 00:06:46,779
the ultimate goal is we could like

00:06:42,680 --> 00:06:46,779
eliminate traffic lights everything the

00:06:47,229 --> 00:06:56,060
intersection so it turns out that people

00:06:53,979 --> 00:06:57,949
have already thought about this so

00:06:56,060 --> 00:07:00,259
there's some nice computer simulations

00:06:57,949 --> 00:07:02,870
you can look these up this particular

00:07:00,259 --> 00:07:05,419
one actually I've seen at an IETF and a

00:07:02,870 --> 00:07:06,139
5g conference and it's really really

00:07:05,419 --> 00:07:12,139
cool

00:07:06,139 --> 00:07:15,740
so the idea is the infrastructure they

00:07:12,139 --> 00:07:17,180
get their token intersection so very

00:07:15,740 --> 00:07:20,110
much like a networking problem right so

00:07:17,180 --> 00:07:22,400
these could be packets trying to

00:07:20,110 --> 00:07:26,150
probably miss packet loss is really bad

00:07:22,400 --> 00:07:29,330
here we can't lose cars and corruption

00:07:26,150 --> 00:07:32,029
is also really bad so the tolerances for

00:07:29,330 --> 00:07:33,650
error very very slight automation

00:07:32,029 --> 00:07:36,649
actually reduces the tolerance for error

00:07:33,650 --> 00:07:49,129
because the numbers that we projected

00:07:36,649 --> 00:07:52,550
before so that was kind of some

00:07:49,129 --> 00:07:55,520
motivation for me to look at this

00:07:52,550 --> 00:07:58,430
problem what's one thing to do a

00:07:55,520 --> 00:08:01,099
computer simulation but in the real

00:07:58,430 --> 00:08:02,870
world things are different so I brought

00:08:01,099 --> 00:08:17,599
a little bit of the real real world with

00:08:02,870 --> 00:08:19,750
me today simulation I'll try to bring it

00:08:17,599 --> 00:08:19,750
up

00:08:25,450 --> 00:08:29,320
at the the bits and bytes and also there

00:08:28,060 --> 00:08:33,790
are some fun modes where you can raise

00:08:29,320 --> 00:08:37,240
the computer and things like that but

00:08:33,790 --> 00:08:41,320
let me actually try to try to run this

00:08:37,240 --> 00:08:44,430
you get an idea some of the problems

00:08:41,320 --> 00:08:44,430
that we face in the real world

00:09:28,480 --> 00:09:35,110
so it's possible to display the screen

00:09:31,390 --> 00:09:35,110
because I switch it goes

00:09:43,940 --> 00:10:01,709
okay so the idea of the the slot for

00:09:58,680 --> 00:10:04,110
simulation emulates an intersection so

00:10:01,709 --> 00:10:06,990
we have a traffic intersection for

00:10:04,110 --> 00:10:08,550
cameras light it on poles if you

00:10:06,990 --> 00:10:10,740
probably see these are pretty common now

00:10:08,550 --> 00:10:13,649
but the idea of these cameras is they're

00:10:10,740 --> 00:10:15,480
going to sense the vehicles and if they

00:10:13,649 --> 00:10:18,300
detect the possibility of collision like

00:10:15,480 --> 00:10:20,430
two cars are coming in one is going to

00:10:18,300 --> 00:10:23,370
yield and while the other one through so

00:10:20,430 --> 00:10:25,709
it becomes in theory it should emulate

00:10:23,370 --> 00:10:37,170
the computer simulation so in order to

00:10:25,709 --> 00:10:40,019
do this kind of a process first thing I

00:10:37,170 --> 00:10:47,959
do crank up a car and there's a learning

00:10:40,019 --> 00:10:47,959
step so

00:11:05,949 --> 00:11:13,429
so what I'm doing right now teaching the

00:11:10,519 --> 00:11:14,659
system where what the lanes are so we

00:11:13,429 --> 00:11:18,129
don't have to pre-programmed the lanes

00:11:14,659 --> 00:11:18,129
it kind of can adapt to

00:12:07,420 --> 00:12:14,390
so pick Lane is one Green Lane as

00:12:12,140 --> 00:12:16,160
another looks like we're missing part of

00:12:14,390 --> 00:12:18,470
the lane there so that'll be interesting

00:12:16,160 --> 00:12:20,510
so the algorithm this does that is

00:12:18,470 --> 00:12:26,090
actually really trivial it's basically a

00:12:20,510 --> 00:12:28,700
mutex so the entry points are cars

00:12:26,090 --> 00:12:30,440
coming this way cars coming this way

00:12:28,700 --> 00:12:32,870
the potential collision is there's cars

00:12:30,440 --> 00:12:35,180
in both of the critical regions so the

00:12:32,870 --> 00:12:39,320
simple mutex says if somebody's already

00:12:35,180 --> 00:12:42,340
there yield the other car okay

00:12:39,320 --> 00:12:42,340
so now we actually try it

00:13:10,980 --> 00:13:17,600
okay so here we go my go slower speed

00:13:14,040 --> 00:13:17,600
since we didn't quite get clearly

00:14:01,100 --> 00:14:08,630
somebody moved by the way it's not it's

00:14:04,950 --> 00:14:08,630
not adaptable 250-foot Gillian's

00:15:42,350 --> 00:15:46,490
okay so anyway that's it

00:15:56,550 --> 00:16:18,540
a lot of people Urgell people died in

00:16:03,990 --> 00:16:20,959
this by the way anyway so yeah like I

00:16:18,540 --> 00:16:24,029
said if you want a closer look at this

00:16:20,959 --> 00:16:43,230
I'll try to run it bits and bytes

00:16:24,029 --> 00:16:44,560
tomorrow 30 frames per second so we're

00:16:43,230 --> 00:16:47,670
already up to

00:16:44,560 --> 00:16:47,670
[Music]

00:17:28,169 --> 00:17:35,519
okay oh so good so let me this is

00:17:31,509 --> 00:17:35,519
actually recording I can try to run this

00:17:45,779 --> 00:17:51,610
so here you can see the blue car stops

00:17:48,429 --> 00:17:54,159
blue car stops they're taking turns over

00:17:51,610 --> 00:17:56,980
car slowed down so the blue car went so

00:17:54,159 --> 00:17:58,779
it really has no bias toward speed it's

00:17:56,980 --> 00:18:00,489
just running the kind of place of the

00:17:58,779 --> 00:18:02,230
mutual exclusion algorithm so ever

00:18:00,489 --> 00:18:06,190
enters the intersection first kind of

00:18:02,230 --> 00:18:08,289
wins there is a mode where we can do

00:18:06,190 --> 00:18:09,850
manual control on one side and computer

00:18:08,289 --> 00:18:14,049
control in other so that's been erased

00:18:09,850 --> 00:18:16,259
the computer it's better but the

00:18:14,049 --> 00:18:21,999
computer can't keep up

00:18:16,259 --> 00:18:36,009
can't trust margin of error goes and

00:18:21,999 --> 00:18:38,889
then when it's two people doing it so

00:18:36,009 --> 00:18:42,480
definitely prove proof that something's

00:18:38,889 --> 00:18:42,480
good computer can do better

00:18:47,450 --> 00:18:55,050
okay so let's just quick overview of the

00:18:52,920 --> 00:18:57,270
simulation so OpenCV we're doing

00:18:55,050 --> 00:19:00,860
background substitution to identify

00:18:57,270 --> 00:19:03,210
motion motion identifies the vehicles

00:19:00,860 --> 00:19:07,440
literary no controller talking to

00:19:03,210 --> 00:19:09,480
h-bridge drive 12 12 volts on the track

00:19:07,440 --> 00:19:11,760
it's really thump track by the way so

00:19:09,480 --> 00:19:19,020
like modern rock tracks have radio

00:19:11,760 --> 00:19:30,150
control does get the idea and so it's a

00:19:19,020 --> 00:19:31,530
pretty good simulation so with did what

00:19:30,150 --> 00:19:34,980
can we learn from this first of all

00:19:31,530 --> 00:19:36,750
worlds a messy place there's error when

00:19:34,980 --> 00:19:38,700
you send a command to something it may

00:19:36,750 --> 00:19:41,340
or may not respond on it quickly there's

00:19:38,700 --> 00:19:43,380
always variances and that's not even

00:19:41,340 --> 00:19:45,150
late or networking technically there's

00:19:43,380 --> 00:19:48,420
no networking in here yet this is all

00:19:45,150 --> 00:19:53,340
just computer running the simulation but

00:19:48,420 --> 00:19:55,280
between the cameras the controller there

00:19:53,340 --> 00:20:26,250
would be networking involved in there

00:19:55,280 --> 00:20:30,290
that would be seems like the data really

00:20:26,250 --> 00:20:30,290
has to be processed very close to the

00:20:31,070 --> 00:20:38,400
critical so even in this case we're

00:20:34,950 --> 00:20:44,429
going to 30 frames per second HD try to

00:20:38,400 --> 00:20:47,720
have this little laptop easy solution

00:20:44,429 --> 00:20:49,669
just shrink the picture

00:20:47,720 --> 00:20:53,620
so this is going to be very very common

00:20:49,669 --> 00:20:56,509
in these sort of applications even with

00:20:53,620 --> 00:20:58,909
greatest projections of 5g I think they

00:20:56,509 --> 00:21:02,870
can keep up with devices trying to

00:20:58,909 --> 00:21:04,490
process this sort of data an interesting

00:21:02,870 --> 00:21:06,950
networking problem or at least what I

00:21:04,490 --> 00:21:08,029
consider networking problem matching who

00:21:06,950 --> 00:21:10,549
you're talking to

00:21:08,029 --> 00:21:11,720
with who you're looking at so in some

00:21:10,549 --> 00:21:13,580
sense we may have a network connection

00:21:11,720 --> 00:21:40,669
to something but now it's also

00:21:13,580 --> 00:21:42,429
interested in a lot of security issues

00:21:40,669 --> 00:21:56,659
and things like that

00:21:42,429 --> 00:22:12,980
how do I know exactly and then way

00:21:56,659 --> 00:23:31,250
better than this so how do we get there

00:22:12,980 --> 00:23:32,809
- because significant across

00:23:31,250 --> 00:23:37,279
coordination that's going to be required

00:23:32,809 --> 00:23:39,700
I would divided up the whole problem

00:23:37,279 --> 00:23:42,889
into core area so network architecture

00:23:39,700 --> 00:23:45,529
protocols implementation and ecosystem

00:23:42,889 --> 00:23:48,320
so each of these have similar staying

00:23:45,529 --> 00:23:50,779
characteristics so network architecture

00:23:48,320 --> 00:23:53,240
there is a fundamental limit here that

00:23:50,779 --> 00:23:55,100
we can't overcome the speed of life so

00:23:53,240 --> 00:23:58,990
if I want to have say 1 millisecond

00:23:55,100 --> 00:23:58,990
latency which is being talented by

00:24:00,009 --> 00:24:18,289
Justice Beetle I puts me miles we have a

00:24:09,769 --> 00:24:21,139
speed limit so we have 93 miles so

00:24:18,289 --> 00:24:23,600
physically server client has to be close

00:24:21,139 --> 00:24:25,279
you cannot go back to the data center or

00:24:23,600 --> 00:24:28,039
halfway around the world for each query

00:24:25,279 --> 00:24:29,480
so a lot of this stuff is being pushed

00:24:28,039 --> 00:24:31,700
into the network this is where it gets

00:24:29,480 --> 00:24:34,369
so called edge computing from but

00:24:31,700 --> 00:24:36,309
servers are really close to to the

00:24:34,369 --> 00:24:40,990
source so we see them popping up and

00:24:36,309 --> 00:24:55,940
central offices base stations or

00:24:40,990 --> 00:25:00,250
intersections also and there's two

00:24:55,940 --> 00:25:00,250
reasons do that one is more hops means

00:25:05,250 --> 00:25:09,930
there but also just fundamental fact the

00:25:07,800 --> 00:25:11,730
more hops you have that produces

00:25:09,930 --> 00:25:14,670
reliability and obviously in these

00:25:11,730 --> 00:25:20,970
applications reliability is like super

00:25:14,670 --> 00:25:25,140
critical to so we need a lot of work and

00:25:20,970 --> 00:25:27,080
routers to do control queuing since

00:25:25,140 --> 00:25:29,010
there are not a lot of hops and

00:25:27,080 --> 00:25:31,080
theoretically not a lot of queuing

00:25:29,010 --> 00:25:32,940
really not a lot of opportunity to do

00:25:31,080 --> 00:25:35,430
fasting fast from fancy traffic

00:25:32,940 --> 00:25:38,250
engineering so we just need to be quick

00:25:35,430 --> 00:25:39,840
and precise for this type of traffic so

00:25:38,250 --> 00:25:47,550
the network does have to be architected

00:25:39,840 --> 00:25:49,470
to provide that so protocols kind of

00:25:47,550 --> 00:25:52,830
another interesting one people say well

00:25:49,470 --> 00:25:57,090
can use TCP for these applications maybe

00:25:52,830 --> 00:25:58,740
maybe not latency but there's going to

00:25:57,090 --> 00:26:01,200
be some sort of application protocols

00:25:58,740 --> 00:26:03,300
that that are designed for this but

00:26:01,200 --> 00:26:05,310
beyond the application protocol we can

00:26:03,300 --> 00:26:07,680
also consider what's the underlying

00:26:05,310 --> 00:26:11,070
protocol so obviously we wanted to be IP

00:26:07,680 --> 00:26:14,040
but in this world is also this mobile

00:26:11,070 --> 00:26:19,260
component so devices are going around we

00:26:14,040 --> 00:26:21,000
want to converge say to handover as

00:26:19,260 --> 00:26:24,210
quickly as possible so we need to

00:26:21,000 --> 00:26:29,070
consider that fewer RTT solutions TCP

00:26:24,210 --> 00:26:31,230
fast open TLS security security these

00:26:29,070 --> 00:26:34,590
are obviously critical so our GTS would

00:26:31,230 --> 00:26:36,390
be a killer in this environment in

00:26:34,590 --> 00:26:39,150
addition to data playing control planes

00:26:36,390 --> 00:26:41,250
and I have a lot to do with this one

00:26:39,150 --> 00:26:44,370
thing I should mention if you consider

00:26:41,250 --> 00:26:46,320
the scope and the scalability these

00:26:44,370 --> 00:26:51,120
applications these networks it's pretty

00:26:46,320 --> 00:26:59,520
much eventually if you're considering

00:26:51,120 --> 00:27:02,060
that every mobile device mobility

00:26:59,520 --> 00:27:02,060
becomes

00:27:03,610 --> 00:27:08,200
the other thing that we constantly have

00:27:06,879 --> 00:27:11,440
to consider like I mentioned before

00:27:08,200 --> 00:27:13,210
security and das abilities so how do you

00:27:11,440 --> 00:27:15,190
prevent it now of service attacks denial

00:27:13,210 --> 00:27:18,610
of service attack on this really bad

00:27:15,190 --> 00:27:23,139
somebody these these are here by the way

00:27:18,610 --> 00:27:25,450
in order to prevent overshoot where the

00:27:23,139 --> 00:27:26,679
cameras actually detect movement so that

00:27:25,450 --> 00:27:29,369
would be an interesting denial of

00:27:26,679 --> 00:28:05,859
service attack and I've actually heard

00:27:29,369 --> 00:28:41,879
some implementations this is the black

00:28:05,859 --> 00:28:44,399
hole in the other end so between those

00:28:41,879 --> 00:28:51,879
attack of the killer microseconds we're

00:28:44,399 --> 00:28:56,070
a few microsecond that's why a lot of

00:28:51,879 --> 00:29:00,359
the optimizations that are stack are

00:28:56,070 --> 00:29:00,359
however there's a

00:29:03,800 --> 00:29:12,610
say do cash preloads everywhere and

00:29:09,560 --> 00:29:12,610
you're an eventual mark you'll see oh

00:29:29,350 --> 00:29:44,710
but it turns out that so sure you can do

00:30:44,710 --> 00:31:03,770
so it's good protocol but we actually

00:30:47,300 --> 00:31:06,730
see more this group to consider how to

00:31:03,770 --> 00:31:06,730
make sure that

00:31:13,370 --> 00:31:19,910
some of the other expenses are really

00:31:16,640 --> 00:31:21,740
good one of the other issues and this is

00:31:19,910 --> 00:31:24,020
kind of kind of wraps everything

00:31:21,740 --> 00:31:27,410
together if you really want to achieve

00:31:24,020 --> 00:31:29,420
this the super slow application visible

00:31:27,410 --> 00:31:32,540
latency we have to consider the whole

00:31:29,420 --> 00:31:36,830
ecosystem that's the application the

00:31:32,540 --> 00:31:38,450
network the OS the pass all of these

00:31:36,830 --> 00:31:41,360
have to work and this is something that

00:31:38,450 --> 00:31:44,060
I think we haven't really been very good

00:31:41,360 --> 00:31:46,040
at industry how do you get these guys

00:31:44,060 --> 00:31:48,710
actually work together to achieve these

00:31:46,040 --> 00:31:56,750
goals so to a large extent they've been

00:31:48,710 --> 00:31:58,340
siloed for various reasons even it's

00:31:56,750 --> 00:32:01,220
often the case that the people make in

00:31:58,340 --> 00:32:03,500
the POS networking stack the people

00:32:01,220 --> 00:32:05,990
deploying at the people who are building

00:32:03,500 --> 00:32:08,710
the hardware infrastructure sweetberry

00:32:05,990 --> 00:32:11,750
disjoint groups and they often have

00:32:08,710 --> 00:32:14,150
interesting the conflicting goals right

00:32:11,750 --> 00:32:15,830
so we know that there's a lot of network

00:32:14,150 --> 00:32:19,250
devices out there that want to provide

00:32:15,830 --> 00:32:21,050
your firewall for you could also do that

00:32:19,250 --> 00:32:26,600
my question is can actually work

00:32:21,050 --> 00:32:31,250
together so when we do something that

00:32:26,600 --> 00:33:10,340
maintain good abstractions solution

00:32:31,250 --> 00:33:18,710
seems to be network by the way but that

00:33:10,340 --> 00:33:20,630
really doesn't work services the

00:33:18,710 --> 00:33:23,179
application may need that how do we get

00:33:20,630 --> 00:33:30,809
the application

00:33:23,179 --> 00:33:34,470
and abstract fashion so that consists

00:33:30,809 --> 00:33:36,780
into the reverse thing Network in signal

00:33:34,470 --> 00:33:39,600
to the application so we've already seen

00:33:36,780 --> 00:33:42,750
each again a great technology but what

00:33:39,600 --> 00:33:45,990
if this becomes more complicated what if

00:33:42,750 --> 00:33:48,320
we network can say for certain paths

00:33:45,990 --> 00:33:51,600
there's a better route so there are some

00:33:48,320 --> 00:33:53,520
some work being done on this usually

00:33:51,600 --> 00:33:56,669
starts with the higher layer because it

00:33:53,520 --> 00:34:00,200
is networking talking to us but

00:33:56,669 --> 00:34:00,200
eventually iOS will be involved

00:34:08,899 --> 00:34:16,490
but in case all of this combination of

00:34:12,419 --> 00:34:16,490
protocols implementation configuration

00:34:20,870 --> 00:34:24,000
[Music]

00:34:56,580 --> 00:35:41,520
so it's obviously too

00:36:40,869 --> 00:37:05,069
so I think the and even when you do that

00:37:07,890 --> 00:37:21,690
but there's so many other factors so

00:37:17,950 --> 00:37:21,690
there's no way to make this

00:39:18,370 --> 00:39:21,370
okay

00:39:22,400 --> 00:39:50,620
there definitely have been other

00:39:25,250 --> 00:39:54,560
proposals socket API so my advice to

00:39:50,620 --> 00:39:56,660
taken that approaches what what do you

00:39:54,560 --> 00:39:59,750
need to actually get what you would if

00:39:56,660 --> 00:40:02,690
you need to do a complete rewrite at the

00:39:59,750 --> 00:40:15,920
lowest layer like in the kernel that's

00:40:02,690 --> 00:40:19,550
going to be a problem in Linux we have

00:40:15,920 --> 00:40:22,000
this requirement to be general and to

00:40:19,550 --> 00:40:22,000
support

00:40:23,150 --> 00:42:25,220
on the other hand we are in this with a

00:40:37,580 --> 00:42:27,040
new API and say that's my believes is

00:42:25,220 --> 00:42:30,140
there should be a lot of commonality

00:42:27,040 --> 00:42:32,839
between these so for instance in the

00:42:30,140 --> 00:42:36,260
network signaling

00:42:32,839 --> 00:42:38,339
seems to me that could be one one method

00:42:36,260 --> 00:42:41,930
the network is offering different

00:42:38,339 --> 00:42:44,220
services so one network may be offering

00:42:41,930 --> 00:42:50,059
video chat service definitely would be

00:42:44,220 --> 00:42:50,059
something compelling latency requirement

00:43:00,829 --> 00:43:07,550
so the application says Network

00:45:30,329 --> 00:45:34,990
object recognition so let me give you an

00:45:32,859 --> 00:45:36,430
example of an interesting scenario so

00:45:34,990 --> 00:45:43,079
you're driving down the street and you

00:45:36,430 --> 00:45:43,079
see something in the road what do you do

00:45:44,430 --> 00:45:54,640
so differently without any more context

00:45:52,290 --> 00:45:56,650
what if you solve this thing had a

00:45:54,640 --> 00:45:59,260
previous behavior say was floating

00:45:56,650 --> 00:46:01,869
around in the sky because and then it

00:45:59,260 --> 00:46:06,010
landed so now you see this and you

00:46:01,869 --> 00:46:08,589
detected that now if you're the

00:46:06,010 --> 00:46:11,230
self-driving car what is it all it sees

00:46:08,589 --> 00:46:14,160
is an object in the road I can't

00:46:11,230 --> 00:46:17,350
identify it so I'm gonna swerve even

00:46:14,160 --> 00:46:20,580
there was actually one of the

00:46:17,350 --> 00:46:20,580
[Music]

00:46:30,720 --> 00:46:35,920
it's it's part it's it's object

00:46:33,280 --> 00:46:37,960
recognitions the networking component of

00:46:35,920 --> 00:46:40,870
that obviously is just kind of the

00:46:37,960 --> 00:46:43,750
backend but in order to do this you

00:46:40,870 --> 00:46:44,740
actually need a huge amount of logic

00:46:43,750 --> 00:46:46,000
that's that's the reason why

00:46:44,740 --> 00:46:49,530
self-driving cars really are hard

00:46:46,000 --> 00:46:51,940
problem it's a very open open scenario

00:46:49,530 --> 00:46:54,070
so when I presented a couple of times

00:46:51,940 --> 00:46:56,170
ago with net dev I pointed out that your

00:46:54,070 --> 00:46:58,720
average 15 year old learning how to

00:46:56,170 --> 00:47:00,850
drive still has more intelligence than

00:46:58,720 --> 00:47:03,940
all the computers in the world and the

00:47:00,850 --> 00:47:06,430
ability to biota to sense things in 15

00:47:03,940 --> 00:47:08,170
years of real-world experience that you

00:47:06,430 --> 00:47:10,540
can apply to this completely different

00:47:08,170 --> 00:47:12,790
application so I guess let's back to the

00:47:10,540 --> 00:47:16,600
API question so the API in your average

00:47:12,790 --> 00:47:21,270
50 you're learning to drive for API but

00:47:16,600 --> 00:47:21,270
at least it's malleable and they

00:47:50,880 --> 00:48:22,780
obviously huge so I mean it's think of

00:48:07,570 --> 00:48:26,280
it as what we can do with you so hundred

00:48:22,780 --> 00:48:26,280
years from now obvious to solve problems

00:48:27,900 --> 00:48:32,220
right now you've seen a lot of

00:48:32,270 --> 00:48:36,349
and the interesting thing about the

00:48:34,880 --> 00:48:42,829
self-driving cars every time there's an

00:48:36,349 --> 00:48:44,890
accident whenever we can do to improve

00:48:42,829 --> 00:48:44,890

YouTube URL: https://www.youtube.com/watch?v=qFk3xArSIzU


