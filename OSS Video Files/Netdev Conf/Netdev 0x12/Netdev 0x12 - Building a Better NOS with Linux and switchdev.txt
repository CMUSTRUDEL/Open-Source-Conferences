Title: Netdev 0x12 - Building a Better NOS with Linux and switchdev
Publication date: 2018-08-01
Playlist: Netdev 0x12
Description: 
	Amen to the Whitebox! Whitebox! Whitebox! chants. But the emerging creed of "Open" networking operating systems (NOS) is sadly still plagued with ASIC vendor SDKs and the proprietary and legacy baggage they carry. Vendor SDKs quarks impact control performance and dictate how control and datapath APIs look like. The SDK glue creates undue burden on operational interfaces design: config, debug-ability, and monitoring all suffer just so the NOS can adapt to the many every vendor SDKs.

The switchdev and related hardware offload interfaces revolution in Linux have matured over the last few years. They provide a singular, cleaner interface to ASIC features. No different than other hardware offloaded by Linux - the hardware vendor provides a driver and leaves the innovation to the NOS and applications.

Shrijeet Mukherjee and David Ahern have been in the dragons den of vendor SDKs and have come out scathed but wiser.
In this talk on July 12th, 2018, at Netdev 0x12 in Montreal, David Ahern discussed typical software architectures for a NOS and introduced a path for transitioning SDK based solutions to Switchdev and related offloads.

More info:
https://www.netdevconf.org/0x12/session.html?building-a-better-nos-with-linux-and-switchdev
Captions: 
	00:00:01,250 --> 00:00:06,600
all right hello everyone my name is

00:00:04,350 --> 00:00:09,599
David Ahern I work for cumulus networks

00:00:06,600 --> 00:00:11,700
and I want to talk to you about why I

00:00:09,599 --> 00:00:13,639
believe switch to have an lennox make

00:00:11,700 --> 00:00:16,920
for a better network operating system

00:00:13,639 --> 00:00:18,690
the the motivation for this talk is some

00:00:16,920 --> 00:00:21,420
prototyping work that was done this past

00:00:18,690 --> 00:00:23,580
year and I guess you could say this is

00:00:21,420 --> 00:00:25,980
the second time Sergey comes up with a

00:00:23,580 --> 00:00:28,410
harebrained idea that I have to go off

00:00:25,980 --> 00:00:30,840
and try to implement and in the end I

00:00:28,410 --> 00:00:38,340
end up liking what you know the original

00:00:30,840 --> 00:00:40,920
idea so let's see how do I all right I

00:00:38,340 --> 00:00:42,570
think I got this all right so I listed

00:00:40,920 --> 00:00:44,879
this in the nuts and bolts talks as

00:00:42,570 --> 00:00:47,280
opposed to moonshot because I'm really

00:00:44,879 --> 00:00:49,410
hoping that this is something that

00:00:47,280 --> 00:00:51,480
becomes a reality as opposed to a pipe

00:00:49,410 --> 00:00:54,149
dream that may or may not come to

00:00:51,480 --> 00:00:55,530
fruition so let's start by talking about

00:00:54,149 --> 00:00:57,239
you know putting some context around

00:00:55,530 --> 00:00:59,190
this and what is this white box

00:00:57,239 --> 00:01:02,879
disaggregation open networking kind of

00:00:59,190 --> 00:01:04,650
movement get into how how open

00:01:02,879 --> 00:01:06,299
networking has kind of forced some

00:01:04,650 --> 00:01:08,610
evolution in network operating systems

00:01:06,299 --> 00:01:10,560
and then get into that next step which

00:01:08,610 --> 00:01:12,570
is how do we make Linux the operating

00:01:10,560 --> 00:01:15,439
system of the data center with an ASIC

00:01:12,570 --> 00:01:15,439
driver in the kernel

00:01:16,070 --> 00:01:22,680
so legacy networking started off as as

00:01:19,890 --> 00:01:25,140
complete silos you know everything's was

00:01:22,680 --> 00:01:26,520
by the vendor or from the vendor so you

00:01:25,140 --> 00:01:28,070
get your hardware from the vendor you

00:01:26,520 --> 00:01:30,960
get your software from the vendor

00:01:28,070 --> 00:01:32,610
everything was closed source highly

00:01:30,960 --> 00:01:34,799
interdependent blobs you really couldn't

00:01:32,610 --> 00:01:36,780
do much without the vendor so you had to

00:01:34,799 --> 00:01:38,670
go to them for consulting you had to go

00:01:36,780 --> 00:01:40,229
for the to them for their servicing it's

00:01:38,670 --> 00:01:42,000
just kind of how the network was built

00:01:40,229 --> 00:01:44,360
or how that the industry was built at

00:01:42,000 --> 00:01:44,360
that time

00:01:46,210 --> 00:01:50,260
the point of white box switches in

00:01:48,520 --> 00:01:52,210
disaggregation is to start to break

00:01:50,260 --> 00:01:55,300
apart those silos to kind of bring them

00:01:52,210 --> 00:01:57,340
down so with white box switches Asics

00:01:55,300 --> 00:01:59,560
are getting commoditized you can go into

00:01:57,340 --> 00:02:02,710
any hardware vendor of your choice and

00:01:59,560 --> 00:02:04,270
then go to a legacy or networking

00:02:02,710 --> 00:02:06,220
operating system vendor of your choice

00:02:04,270 --> 00:02:09,399
to put the two together and deploy your

00:02:06,220 --> 00:02:12,400
switch so that's the theory but the

00:02:09,399 --> 00:02:13,780
reality is it's still very much silo

00:02:12,400 --> 00:02:17,170
based in terms of how the network

00:02:13,780 --> 00:02:18,580
operating system is designed which kind

00:02:17,170 --> 00:02:22,570
of gets into that next part of this

00:02:18,580 --> 00:02:24,520
which is open networking you know open

00:02:22,570 --> 00:02:27,280
networking today still pretty much says

00:02:24,520 --> 00:02:30,280
you can pick a vendor and install their

00:02:27,280 --> 00:02:32,170
OS onto your white box switch but it's

00:02:30,280 --> 00:02:33,670
still a whole bunch of interdependent

00:02:32,170 --> 00:02:35,770
blobs we still haven't gotten to that

00:02:33,670 --> 00:02:37,900
point where like we have with cumulus

00:02:35,770 --> 00:02:41,620
Linux where it's a completely open Linux

00:02:37,900 --> 00:02:44,560
model so I guess that really comes down

00:02:41,620 --> 00:02:46,840
to then what is the word open mean right

00:02:44,560 --> 00:02:48,640
because those open mean that the vendor

00:02:46,840 --> 00:02:51,299
allows you to get shell access on the

00:02:48,640 --> 00:02:53,830
box does open mean you get root access

00:02:51,299 --> 00:02:56,560
okay you've got root access on a switch

00:02:53,830 --> 00:02:58,959
what does that mean that you can run

00:02:56,560 --> 00:03:00,910
Linux commands not just Linux commands

00:02:58,959 --> 00:03:03,730
to see process scheduling but Linux

00:03:00,910 --> 00:03:07,420
commands to do configuration changes to

00:03:03,730 --> 00:03:09,670
the network or to do a shot no shot on

00:03:07,420 --> 00:03:13,090
interface for example you know how far

00:03:09,670 --> 00:03:15,640
can I go can I install an agent my own

00:03:13,090 --> 00:03:17,980
agent written against Linux api's that

00:03:15,640 --> 00:03:21,130
can inject routes some some custom route

00:03:17,980 --> 00:03:23,980
entries into the kernel can I have a

00:03:21,130 --> 00:03:26,080
networking program that will use Linux

00:03:23,980 --> 00:03:28,180
API is to open a socket and communicate

00:03:26,080 --> 00:03:30,640
with a peer and how that communication

00:03:28,180 --> 00:03:35,200
happened over front panel ports to me

00:03:30,640 --> 00:03:38,290
open really means Linux AP is are taking

00:03:35,200 --> 00:03:40,540
full presence right so Linux is about

00:03:38,290 --> 00:03:43,000
building blocks this this notion that

00:03:40,540 --> 00:03:44,739
you've got an implementation for vrf

00:03:43,000 --> 00:03:48,910
you've got an implementation from pls or

00:03:44,739 --> 00:03:50,739
VX LAN or how routing is done and you

00:03:48,910 --> 00:03:53,250
can assemble those blocks as you need to

00:03:50,739 --> 00:03:57,639
for your particular deployment situation

00:03:53,250 --> 00:03:58,890
right so that's the actual end goal is

00:03:57,639 --> 00:04:01,560
to

00:03:58,890 --> 00:04:04,410
move more and more to the linux AP is to

00:04:01,560 --> 00:04:05,490
enable the innovation that lennox you

00:04:04,410 --> 00:04:07,319
know the linux becomes your

00:04:05,490 --> 00:04:09,390
infrastructure and then you build on top

00:04:07,319 --> 00:04:14,970
of that as you want for your specific

00:04:09,390 --> 00:04:16,410
deployments so then we get into how

00:04:14,970 --> 00:04:18,900
network operating systems are evolving

00:04:16,410 --> 00:04:21,090
you know at the heart of this this

00:04:18,900 --> 00:04:22,680
movement really is Linux Linux is kind

00:04:21,090 --> 00:04:25,740
of dominating the data center it's

00:04:22,680 --> 00:04:27,510
driving a lot of the changes that legacy

00:04:25,740 --> 00:04:31,080
network vendors are being asked to do

00:04:27,510 --> 00:04:34,470
and this this evolution is going from

00:04:31,080 --> 00:04:37,710
what was all userspace stacks to some

00:04:34,470 --> 00:04:40,470
data in the kernel to kernel api's to

00:04:37,710 --> 00:04:43,230
the next step is moving the ecig driver

00:04:40,470 --> 00:04:45,240
from a user space sdk-based and getting

00:04:43,230 --> 00:04:47,540
that driver into the kernel so you have

00:04:45,240 --> 00:04:52,680
a true natural order to things and linux

00:04:47,540 --> 00:04:55,430
right so if that's the end goal what's

00:04:52,680 --> 00:04:55,430
our limitation

00:04:59,540 --> 00:05:03,080
switches today we have a lot of

00:05:01,430 --> 00:05:05,180
similarities between Russia's a

00:05:03,080 --> 00:05:07,040
commodity switches today have a lot of

00:05:05,180 --> 00:05:09,670
similarities to other nodes in the

00:05:07,040 --> 00:05:11,780
network data center into a data center

00:05:09,670 --> 00:05:13,520
you've got load balancers you got

00:05:11,780 --> 00:05:15,680
firewalls you got servers you've got

00:05:13,520 --> 00:05:18,650
hosts all of this stuff is running Linux

00:05:15,680 --> 00:05:21,590
they all use commodity CPUs they all use

00:05:18,650 --> 00:05:23,630
commodity storage devices PCI buses they

00:05:21,590 --> 00:05:25,370
have management NICs they they have a

00:05:23,630 --> 00:05:27,350
very similar operational model in the

00:05:25,370 --> 00:05:29,300
sense of needing to be racked they need

00:05:27,350 --> 00:05:31,700
to be dead initial configuration for

00:05:29,300 --> 00:05:33,290
deployment and even the monitoring and

00:05:31,700 --> 00:05:37,130
the servicing aspects of it have a lot

00:05:33,290 --> 00:05:40,370
of common similarities so again coming

00:05:37,130 --> 00:05:43,070
back to the why or switch is still

00:05:40,370 --> 00:05:45,950
different the the big reason is that

00:05:43,070 --> 00:05:48,500
switches today are still driven by SDKs

00:05:45,950 --> 00:05:50,300
if you want to install a route on a

00:05:48,500 --> 00:05:52,100
front panel port or you'll install a

00:05:50,300 --> 00:05:54,140
route that makes packets move between

00:05:52,100 --> 00:05:59,420
front panel ports you have to go through

00:05:54,140 --> 00:06:01,930
a vendors SDK if you want to it looks

00:05:59,420 --> 00:06:05,060
like that did not come out well anyway

00:06:01,930 --> 00:06:06,740
if you wanted to bring a link up or

00:06:05,060 --> 00:06:09,230
bring a link down or to retrieve

00:06:06,740 --> 00:06:11,480
statistics from that link all of that

00:06:09,230 --> 00:06:13,970
has to be funneled through an SDK and

00:06:11,480 --> 00:06:17,270
that SDK is typically running through

00:06:13,970 --> 00:06:19,670
some user space process that's something

00:06:17,270 --> 00:06:21,890
like an ASIC da user space driver which

00:06:19,670 --> 00:06:24,140
links with the SDK and then does all the

00:06:21,890 --> 00:06:26,810
programming through it which kind of

00:06:24,140 --> 00:06:28,430
makes it the center point of a network

00:06:26,810 --> 00:06:32,410
operating system so anything you want to

00:06:28,430 --> 00:06:36,680
do you have to funnel it to that process

00:06:32,410 --> 00:06:38,750
so that that that idea that you have a

00:06:36,680 --> 00:06:41,600
user space process that's programming

00:06:38,750 --> 00:06:43,820
the hardware kind of creates to use

00:06:41,600 --> 00:06:45,830
these architectures where everything

00:06:43,820 --> 00:06:49,100
runs in user space even though you're

00:06:45,830 --> 00:06:52,220
running Linux on the hardware it's not

00:06:49,100 --> 00:06:53,720
really used so the the early network

00:06:52,220 --> 00:06:55,790
operating systems were all highly

00:06:53,720 --> 00:06:58,760
interdependent processes they had their

00:06:55,790 --> 00:07:00,700
own IPC they had their own CLI their own

00:06:58,760 --> 00:07:02,330
database for storing that configuration

00:07:00,700 --> 00:07:04,940
everything stayed in user space

00:07:02,330 --> 00:07:06,500
everything was highly customized so

00:07:04,940 --> 00:07:09,140
Linux was your network operating our

00:07:06,500 --> 00:07:12,850
Linux was your boot operating system but

00:07:09,140 --> 00:07:12,850
it wasn't really used outside of that

00:07:19,110 --> 00:07:21,990
sorry when I get up here in front of

00:07:20,700 --> 00:07:23,760
these bright lights I tend to talk

00:07:21,990 --> 00:07:25,230
really fast and my brain just kind of

00:07:23,760 --> 00:07:27,180
going crazy so I have some notes in

00:07:25,230 --> 00:07:28,830
front of me that I kind of help to kind

00:07:27,180 --> 00:07:30,570
of slow down and use some key points I

00:07:28,830 --> 00:07:32,790
want to make so that's why I keep

00:07:30,570 --> 00:07:34,380
looking down at you know in my flying

00:07:32,790 --> 00:07:36,510
through this too fast or am i trying to

00:07:34,380 --> 00:07:42,360
get my message across so just bear with

00:07:36,510 --> 00:07:44,040
me on that one all right so if you

00:07:42,360 --> 00:07:45,780
really look at if you take a step back

00:07:44,040 --> 00:07:47,850
and look at these legacy network

00:07:45,780 --> 00:07:51,390
operating systems they really come as a

00:07:47,850 --> 00:07:54,060
big black box right you have no insights

00:07:51,390 --> 00:07:56,250
into what the processes are doing other

00:07:54,060 --> 00:07:58,140
than that CLI which is the vendors way

00:07:56,250 --> 00:08:00,000
of saying this is how we want you to

00:07:58,140 --> 00:08:02,100
access our operating system this is how

00:08:00,000 --> 00:08:04,820
we want you to make changes this is how

00:08:02,100 --> 00:08:07,020
we want you to make any kind of

00:08:04,820 --> 00:08:08,910
statistics or debugging or

00:08:07,020 --> 00:08:10,470
serviceability kind of things we want

00:08:08,910 --> 00:08:13,110
you to go through our CLI because it

00:08:10,470 --> 00:08:15,620
knows how to talk to to the rest of the

00:08:13,110 --> 00:08:15,620
processes

00:08:22,520 --> 00:08:27,889
all right

00:08:25,039 --> 00:08:31,309
so overtime the Linux operating system

00:08:27,889 --> 00:08:33,860
begins to dominate right so in the 2000

00:08:31,309 --> 00:08:35,389
mid 2000 early 2000s when these legacy

00:08:33,860 --> 00:08:36,979
network operating systems were first

00:08:35,389 --> 00:08:38,990
started you know they were kind of

00:08:36,979 --> 00:08:41,329
scared of lennox so we're scared of the

00:08:38,990 --> 00:08:43,639
GPL issues the Linux networking stack

00:08:41,329 --> 00:08:45,019
itself wasn't really performant it

00:08:43,639 --> 00:08:47,480
wasn't scaling didn't have some of the

00:08:45,019 --> 00:08:48,769
features that were needed for what an

00:08:47,480 --> 00:08:51,589
operating system network operating

00:08:48,769 --> 00:08:55,730
system needed but then Linux becomes a

00:08:51,589 --> 00:08:57,500
take off for servers and in time network

00:08:55,730 --> 00:08:59,810
operators people with data centers are

00:08:57,500 --> 00:09:01,250
kind of like you know I have this agent

00:08:59,810 --> 00:09:03,620
that I run everywhere and I really want

00:09:01,250 --> 00:09:04,940
to install that agent on that switch and

00:09:03,620 --> 00:09:07,010
I want to have it be able to communicate

00:09:04,940 --> 00:09:11,300
and collect statistics or things that I

00:09:07,010 --> 00:09:13,100
want it to do and because the switch is

00:09:11,300 --> 00:09:14,630
running Linux it seems kind of logical

00:09:13,100 --> 00:09:16,550
of hey well why can't I just put this

00:09:14,630 --> 00:09:19,399
agent on the switch and let it work and

00:09:16,550 --> 00:09:21,980
the SDK vendors I mean the network

00:09:19,399 --> 00:09:23,360
vendors are kind of like well you know

00:09:21,980 --> 00:09:25,819
if you want to run something in our

00:09:23,360 --> 00:09:29,000
switch we're gonna have to give you this

00:09:25,819 --> 00:09:30,949
SDK that you can link your process to

00:09:29,000 --> 00:09:32,420
right so coming back to this thing right

00:09:30,949 --> 00:09:34,160
you know I keep saying it's the Linux

00:09:32,420 --> 00:09:36,290
operating system is running on the

00:09:34,160 --> 00:09:39,290
hardware but yet it's not really using

00:09:36,290 --> 00:09:40,970
any the api's so if you want to run open

00:09:39,290 --> 00:09:43,279
source software or your own software

00:09:40,970 --> 00:09:44,870
that typically uses Linux api's to

00:09:43,279 --> 00:09:46,790
communicate you're gonna have to

00:09:44,870 --> 00:09:49,490
recompile it against this network

00:09:46,790 --> 00:09:51,500
vendors sdk so it can link up to the

00:09:49,490 --> 00:09:53,449
mothership and it knows how to you know

00:09:51,500 --> 00:09:55,250
that that SDK that the network vendors

00:09:53,449 --> 00:09:56,569
provide it knows how to tap into the

00:09:55,250 --> 00:09:58,550
mothership and get the information

00:09:56,569 --> 00:10:01,279
you're asking which is a really poor way

00:09:58,550 --> 00:10:04,940
to to have this you know openness and

00:10:01,279 --> 00:10:06,740
interoperability right so that was kind

00:10:04,940 --> 00:10:11,139
of that next step that for first push as

00:10:06,740 --> 00:10:11,139
linux begins to take off for networking

00:10:11,529 --> 00:10:17,750
so then the vendors get an idea okay one

00:10:16,220 --> 00:10:20,449
of the core constructs of Linux

00:10:17,750 --> 00:10:21,769
networking is a net device so it kind of

00:10:20,449 --> 00:10:24,649
it's an anchor for everything from

00:10:21,769 --> 00:10:27,170
addresses to routes to filters ACLs etc

00:10:24,649 --> 00:10:28,910
so let's create a net device for each

00:10:27,170 --> 00:10:31,880
one of the front panel ports right

00:10:28,910 --> 00:10:36,550
fairly easy to do ASIC vendors these

00:10:31,880 --> 00:10:36,550
days have have drivers that allow you to

00:10:36,910 --> 00:10:42,130
creating front panel treating that

00:10:38,769 --> 00:10:44,560
devices front panel ports that gives you

00:10:42,130 --> 00:10:47,079
a way to give a presence and to allow

00:10:44,560 --> 00:10:50,319
things like a link down link up kind of

00:10:47,079 --> 00:10:52,810
mentality but how much data then does

00:10:50,319 --> 00:10:55,300
the vendor put into the kernel do you

00:10:52,810 --> 00:10:57,009
try to create routes in the kernel do

00:10:55,300 --> 00:10:59,680
you put all the routes or some of the

00:10:57,009 --> 00:11:02,139
routes do you try to put brf's in the

00:10:59,680 --> 00:11:04,269
kernel what about your VLANs like how

00:11:02,139 --> 00:11:08,589
much networking data if you're gonna go

00:11:04,269 --> 00:11:10,720
this this direction do you put in right

00:11:08,589 --> 00:11:13,180
in the short of it is if you're not

00:11:10,720 --> 00:11:14,920
putting all of your data into the kernel

00:11:13,180 --> 00:11:17,350
what you're really doing is creating an

00:11:14,920 --> 00:11:19,899
ad-hoc solution right you're wanting to

00:11:17,350 --> 00:11:22,930
communicate over ver Fae but you're

00:11:19,899 --> 00:11:24,670
really communicating over FB or you're

00:11:22,930 --> 00:11:27,790
wanting to collect Network statistics

00:11:24,670 --> 00:11:30,519
and you you run the typical api's for

00:11:27,790 --> 00:11:32,110
linux and you get nothing back because

00:11:30,519 --> 00:11:33,790
it wasn't implemented that the vendor

00:11:32,110 --> 00:11:37,540
didn't expect you to want to do that

00:11:33,790 --> 00:11:39,970
particular direction right so then that

00:11:37,540 --> 00:11:44,079
kind of leads to the next stop which is

00:11:39,970 --> 00:11:46,389
okay let's move to more networking in

00:11:44,079 --> 00:11:48,220
the Linux which and this is getting into

00:11:46,389 --> 00:11:50,170
more widely the cumulus networks

00:11:48,220 --> 00:11:53,620
approach to a network operating system

00:11:50,170 --> 00:11:56,019
we still have this SDK so we still have

00:11:53,620 --> 00:11:59,350
to do all the programming through it but

00:11:56,019 --> 00:12:03,759
we're gonna allow full-on API is within

00:11:59,350 --> 00:12:06,850
the kernel we're gonna let you use the

00:12:03,759 --> 00:12:08,949
RT not link API to create devices we're

00:12:06,850 --> 00:12:10,899
going mean yeah it's great devices do it

00:12:08,949 --> 00:12:12,670
to configure features we're gonna allow

00:12:10,899 --> 00:12:14,709
you to run commands like you know

00:12:12,670 --> 00:12:18,880
interface managers like I up up down to

00:12:14,709 --> 00:12:20,620
or after our RF or your open source

00:12:18,880 --> 00:12:22,810
routing daemon all these things are just

00:12:20,620 --> 00:12:26,740
gonna work because they're just using

00:12:22,810 --> 00:12:29,709
Linux right so as we start making this

00:12:26,740 --> 00:12:32,649
step in this direction we're opening up

00:12:29,709 --> 00:12:35,589
the entire Linux ecosystem because if

00:12:32,649 --> 00:12:37,870
you know the Linux API is you put it on

00:12:35,589 --> 00:12:40,990
a Linux based switch and it's just gonna

00:12:37,870 --> 00:12:45,180
work okay so that's that's kind of the

00:12:40,990 --> 00:12:47,430
end goal is this direction of the

00:12:45,180 --> 00:12:50,250
the network operating system is really

00:12:47,430 --> 00:12:53,250
just Lennox and the programming of the

00:12:50,250 --> 00:12:55,440
SDK is happening by listening to the

00:12:53,250 --> 00:12:57,600
notifications from the kernel and you're

00:12:55,440 --> 00:12:59,130
not building a nas around the fact that

00:12:57,600 --> 00:13:00,870
you got a program at ASIC you're

00:12:59,130 --> 00:13:03,690
building the nas around a set of API s

00:13:00,870 --> 00:13:07,160
that can be programmed and used as you

00:13:03,690 --> 00:13:07,160
choose to choose to do that

00:13:16,150 --> 00:13:21,339
so one point I didn't want to make about

00:13:18,279 --> 00:13:23,650
these these front panel port net dubs so

00:13:21,339 --> 00:13:26,860
the fact that vendor drivers are that

00:13:23,650 --> 00:13:30,339
ASIC vendors are creating kernel drivers

00:13:26,860 --> 00:13:32,320
that know how to instantiate front panel

00:13:30,339 --> 00:13:34,120
ports net devs front panel ports and

00:13:32,320 --> 00:13:36,550
know how to efficiently distribute those

00:13:34,120 --> 00:13:38,980
packets to those net devs it kind of

00:13:36,550 --> 00:13:41,020
shows that these ASIC vendors are seeing

00:13:38,980 --> 00:13:42,339
this trend where you want to use more

00:13:41,020 --> 00:13:44,140
and more the Linux currently you want to

00:13:42,339 --> 00:13:48,070
make it more the center point of your OS

00:13:44,140 --> 00:13:50,529
as opposed to and of an add-on that that

00:13:48,070 --> 00:13:54,760
nos vendors are reluctantly allowing

00:13:50,529 --> 00:13:59,230
people to use so what's the next step in

00:13:54,760 --> 00:14:02,200
this right we've got more and more of

00:13:59,230 --> 00:14:04,900
the stuff moving to - Lennox I mean

00:14:02,200 --> 00:14:07,600
moving to the Linux api's but we still

00:14:04,900 --> 00:14:09,279
have this SDK hassle so for example one

00:14:07,600 --> 00:14:12,700
of the limitations that we've got is

00:14:09,279 --> 00:14:14,350
etool throw the vendor driver will

00:14:12,700 --> 00:14:16,600
create net devs with front panel ports

00:14:14,350 --> 00:14:18,400
it doesn't enter it doesn't handle equal

00:14:16,600 --> 00:14:20,800
ops so you can't do all one

00:14:18,400 --> 00:14:22,540
configuration unless you add do

00:14:20,800 --> 00:14:24,490
something fancy to add on those hooks

00:14:22,540 --> 00:14:28,900
which is something that we do for free

00:14:24,490 --> 00:14:33,010
cumulative so we keep making forward

00:14:28,900 --> 00:14:35,260
progress in in terms of allowing people

00:14:33,010 --> 00:14:36,760
to use Linux the capabilities of Linux

00:14:35,260 --> 00:14:37,900
from a feature set and from a

00:14:36,760 --> 00:14:41,620
scalability and from a performance

00:14:37,900 --> 00:14:44,290
perspective but so from from overall big

00:14:41,620 --> 00:14:46,450
picture we're much better in the open

00:14:44,290 --> 00:14:48,490
networking piece of that but we still

00:14:46,450 --> 00:14:54,339
have a few limitations that we have to

00:14:48,490 --> 00:14:58,029
continue to to evolve - and so that next

00:14:54,339 --> 00:15:00,279
step then is moving ASIC driver from

00:14:58,029 --> 00:15:03,250
user space down into the kernel and

00:15:00,279 --> 00:15:04,900
that's the point of switch stuff so

00:15:03,250 --> 00:15:07,420
switch dev says you've got a kernel

00:15:04,900 --> 00:15:10,089
driver that knows how to listen to

00:15:07,420 --> 00:15:12,010
notifications inside the kernel when

00:15:10,089 --> 00:15:14,500
someone creates a vrf when someone adds

00:15:12,010 --> 00:15:18,010
a route when someone had to be a VLAN

00:15:14,500 --> 00:15:19,630
the kernel driver the driver running in

00:15:18,010 --> 00:15:21,520
the kernel Lissa's those notifications

00:15:19,630 --> 00:15:25,260
says oh I'm going to do the same

00:15:21,520 --> 00:15:25,260
programming down into the ASIC

00:15:25,330 --> 00:15:32,149
now to to make that happen some new API

00:15:30,080 --> 00:15:34,430
is came into existence like the devil

00:15:32,149 --> 00:15:37,550
Inc API for example which allow some

00:15:34,430 --> 00:15:41,269
kind of unique configuration from from

00:15:37,550 --> 00:15:43,730
an ASIC perspective as opposed to a net

00:15:41,269 --> 00:15:45,740
dev perspective but it's just again it's

00:15:43,730 --> 00:15:48,769
still standard API is that have been

00:15:45,740 --> 00:15:51,440
created that you can write tools to and

00:15:48,769 --> 00:15:53,380
and do standard configuration right we

00:15:51,440 --> 00:15:56,450
it's not like you have to go through

00:15:53,380 --> 00:16:03,769
some custom vendor based piece of piece

00:15:56,450 --> 00:16:05,750
of code so how do we get there if we

00:16:03,769 --> 00:16:07,820
believe that switch dev is the future

00:16:05,750 --> 00:16:11,420
and switched of is that is that better

00:16:07,820 --> 00:16:14,120
model how do we get ASIC benders to

00:16:11,420 --> 00:16:15,920
support the switch dev model they've got

00:16:14,120 --> 00:16:17,870
their legacy way of doing things like

00:16:15,920 --> 00:16:20,269
you you want to move forward with open

00:16:17,870 --> 00:16:22,430
not working but the old world is also

00:16:20,269 --> 00:16:25,850
trying to hang on to its model they want

00:16:22,430 --> 00:16:28,310
their revenues done their way and how do

00:16:25,850 --> 00:16:31,160
you then influence an ASIC vendor to

00:16:28,310 --> 00:16:33,050
create not not an SDK but an internal

00:16:31,160 --> 00:16:35,360
driver it's a lot of work to move

00:16:33,050 --> 00:16:37,220
between the two so you want to prove

00:16:35,360 --> 00:16:38,839
that it's best but you need their

00:16:37,220 --> 00:16:42,130
drivers to work in the kernel to prove

00:16:38,839 --> 00:16:42,130
that so how do we get there

00:16:44,790 --> 00:16:50,790
and now we're getting into this kind of

00:16:47,430 --> 00:16:54,870
forward-looking point of you know we

00:16:50,790 --> 00:16:58,740
want to we want to get somewhere but we

00:16:54,870 --> 00:17:00,510
don't have the set of software that we

00:16:58,740 --> 00:17:03,330
need to make it happen so we've got to

00:17:00,510 --> 00:17:05,310
kind of jump through some hoops to prove

00:17:03,330 --> 00:17:06,930
that this Linux this the switch dev

00:17:05,310 --> 00:17:11,550
model is gonna be in the direction that

00:17:06,930 --> 00:17:13,260
we want to go so what we've proposed

00:17:11,550 --> 00:17:18,089
what we've prototyped over this past

00:17:13,260 --> 00:17:20,760
year was how do we transition SDKs into

00:17:18,089 --> 00:17:23,850
the switch dev world and one way to do

00:17:20,760 --> 00:17:26,670
that is to create a common layer that

00:17:23,850 --> 00:17:29,040
all switch dev drivers can use so if you

00:17:26,670 --> 00:17:30,870
look at all those events that a switch

00:17:29,040 --> 00:17:35,100
dev driver has to deal with net dev

00:17:30,870 --> 00:17:37,860
events net events internal notifiers for

00:17:35,100 --> 00:17:40,320
fib changes deviling operations etool

00:17:37,860 --> 00:17:42,690
operations it's a lot of overhead that

00:17:40,320 --> 00:17:44,850
some ASIC vendor is gonna have to deal

00:17:42,690 --> 00:17:49,170
with for every version of their of their

00:17:44,850 --> 00:17:54,240
Asics so the idea here is to create a

00:17:49,170 --> 00:17:57,750
common layer that that vendors can use

00:17:54,240 --> 00:18:00,450
it'll handle this it'll handle a lot of

00:17:57,750 --> 00:18:03,120
the internal aspects of it and then has

00:18:00,450 --> 00:18:06,210
this mapping between kernel objects and

00:18:03,120 --> 00:18:08,610
ASIC objects right so now you've

00:18:06,210 --> 00:18:12,680
simplified what an ASIC vendor has to do

00:18:08,610 --> 00:18:12,680
to work in the switch to world

00:18:20,520 --> 00:18:23,840
all right so

00:18:24,760 --> 00:18:31,180
the big question here right aren't SDKs

00:18:28,390 --> 00:18:32,590
proprietary blobs you know a lot of

00:18:31,180 --> 00:18:34,840
Linux purists are probably out there

00:18:32,590 --> 00:18:37,030
thinking wait a minute why is this Linux

00:18:34,840 --> 00:18:38,800
guy the Solenn external guy saying well

00:18:37,030 --> 00:18:40,960
let's move for piyah Terry blobs into

00:18:38,800 --> 00:18:44,170
the kernel but you have to face reality

00:18:40,960 --> 00:18:46,750
and the reality is an ASIC vendor is not

00:18:44,170 --> 00:18:49,450
going to move to this new world just

00:18:46,750 --> 00:18:54,370
because oh it's cool and it's new you've

00:18:49,450 --> 00:18:57,250
got to you've got a you you've got to

00:18:54,370 --> 00:19:00,250
kind of show that it's the best way and

00:18:57,250 --> 00:19:06,340
push them in a direction and and provide

00:19:00,250 --> 00:19:08,610
the data to do that right Linux Linux is

00:19:06,340 --> 00:19:11,950
not just an OS for hobbyists it's really

00:19:08,610 --> 00:19:16,000
driven by businesses these days right so

00:19:11,950 --> 00:19:18,250
chemos didn't pay me to work on BRF for

00:19:16,000 --> 00:19:21,330
the kernel just for fun it's it's a part

00:19:18,250 --> 00:19:23,830
of making the Linux operating system a

00:19:21,330 --> 00:19:26,500
true network operating system model

00:19:23,830 --> 00:19:28,870
right and so a part of that what I'm

00:19:26,500 --> 00:19:30,580
getting at is businesses are doing this

00:19:28,870 --> 00:19:36,000
because this is the right way forward

00:19:30,580 --> 00:19:39,250
and sometimes certain aspects of

00:19:36,000 --> 00:19:40,810
hardware that the vendors don't want to

00:19:39,250 --> 00:19:42,520
move to this new world they don't want

00:19:40,810 --> 00:19:43,570
to open up their code or because they

00:19:42,520 --> 00:19:45,940
consider that to be something

00:19:43,570 --> 00:19:47,410
proprietary to them so you look at

00:19:45,940 --> 00:19:50,650
things like the Indus trapper that was

00:19:47,410 --> 00:19:53,560
needed in the 2000s where Wi-Fi drivers

00:19:50,650 --> 00:19:56,410
didn't work in an external but over time

00:19:53,560 --> 00:20:01,480
they did so if we can use something like

00:19:56,410 --> 00:20:02,860
CLS W as a stepping stone to to get ASIC

00:20:01,480 --> 00:20:06,160
benders on board with this approach

00:20:02,860 --> 00:20:09,550
right the end result if we get there is

00:20:06,160 --> 00:20:11,050
the best one but maybe we have to kind

00:20:09,550 --> 00:20:13,090
of hold our noses through some some

00:20:11,050 --> 00:20:17,790
intermediate stops to get these

00:20:13,090 --> 00:20:17,790
proprietary SDKs to to move over

00:20:19,100 --> 00:20:24,980
and then in the end what we get to is

00:20:23,350 --> 00:20:28,070
Linux everywhere

00:20:24,980 --> 00:20:30,230
true Linux everywhere right not kind of

00:20:28,070 --> 00:20:31,610
sort of Linux running the boot part of

00:20:30,230 --> 00:20:34,299
it or the file systems or the memory

00:20:31,610 --> 00:20:36,950
management or the process scheduling but

00:20:34,299 --> 00:20:38,450
Lennox is the same on a server it's the

00:20:36,950 --> 00:20:40,789
same on a load balancer it's the same on

00:20:38,450 --> 00:20:42,320
a firewall same on a switch you get to

00:20:40,789 --> 00:20:44,240
use your same tools if you're using

00:20:42,320 --> 00:20:45,710
ansible to configure things you can

00:20:44,240 --> 00:20:48,799
configure a switch just like you've done

00:20:45,710 --> 00:20:51,860
everything else right so this is the the

00:20:48,799 --> 00:20:54,559
the true openness part of it and so this

00:20:51,860 --> 00:21:02,990
is the at you know that the best end

00:20:54,559 --> 00:21:05,000
goal right so what would an idea be

00:21:02,990 --> 00:21:07,750
without proof concept right like I said

00:21:05,000 --> 00:21:11,059
I spent some time working on a prototype

00:21:07,750 --> 00:21:12,700
so I'm not putting names on this because

00:21:11,059 --> 00:21:16,279
I don't think the names are relevant

00:21:12,700 --> 00:21:18,620
what's really important here is trying

00:21:16,279 --> 00:21:23,019
again to prove the switch dev model is

00:21:18,620 --> 00:21:27,019
best and to kind of gain some data that

00:21:23,019 --> 00:21:29,269
pushes that direction so one of the

00:21:27,019 --> 00:21:32,659
prototypes I did it's it's an unnamed

00:21:29,269 --> 00:21:35,450
vendors SDK running in the kernel the

00:21:32,659 --> 00:21:37,639
backend operations the way that CL SW

00:21:35,450 --> 00:21:39,919
will talk to the SDK is through the Sai

00:21:37,639 --> 00:21:42,529
interface as I think was mentioned

00:21:39,919 --> 00:21:46,039
yesterday most ASIC vendors today

00:21:42,529 --> 00:21:48,559
support site so it no work was needed

00:21:46,039 --> 00:21:51,500
there sai is not the best interface for

00:21:48,559 --> 00:21:54,320
an internal operations like this but it

00:21:51,500 --> 00:21:56,870
let me focus on this proof of concept as

00:21:54,320 --> 00:22:00,379
opposed to hmm how do I talk to this SDK

00:21:56,870 --> 00:22:05,779
and the kernel so the three cases that I

00:22:00,379 --> 00:22:08,779
compared a typical user space SDK the

00:22:05,779 --> 00:22:13,039
one switch dev model that exists and

00:22:08,779 --> 00:22:15,559
then the CL SW SDK as a way of bringing

00:22:13,039 --> 00:22:19,269
the SDK down into the kernel getting

00:22:15,559 --> 00:22:23,269
this true basic driver model going and

00:22:19,269 --> 00:22:26,270
kind of comparing not just operational

00:22:23,269 --> 00:22:28,580
efficiencies of it but but

00:22:26,270 --> 00:22:30,110
you know again it said collecting the

00:22:28,580 --> 00:22:34,640
data that shows this is a better way to

00:22:30,110 --> 00:22:38,990
do something so one of the test cases

00:22:34,640 --> 00:22:40,880
was reboot so if you look at some of the

00:22:38,990 --> 00:22:42,140
legacy thinking around networking you

00:22:40,880 --> 00:22:42,950
know you get requests for things like

00:22:42,140 --> 00:22:45,380
iss-you

00:22:42,950 --> 00:22:47,330
which an in service software update and

00:22:45,380 --> 00:22:49,610
the idea is you don't want to take down

00:22:47,330 --> 00:22:51,770
your switch to do an upgrade on software

00:22:49,610 --> 00:22:54,410
but anyone who's ever worked at those

00:22:51,770 --> 00:22:55,790
features know they're super complex they

00:22:54,410 --> 00:22:59,810
rarely ever work the way they're

00:22:55,790 --> 00:23:01,580
supposed to so how can we get around it

00:22:59,810 --> 00:23:04,670
well the way you get around it is by

00:23:01,580 --> 00:23:06,740
making things simpler and faster so for

00:23:04,670 --> 00:23:09,650
example if you've got a running switch

00:23:06,740 --> 00:23:11,180
and you can do a key exact into new into

00:23:09,650 --> 00:23:14,420
a new kernel and start running new

00:23:11,180 --> 00:23:16,310
software right the downtime there if you

00:23:14,420 --> 00:23:18,650
start making that faster and faster the

00:23:16,310 --> 00:23:20,780
downtime becomes lower and lower so the

00:23:18,650 --> 00:23:23,240
idea of meaning NISS you can just go

00:23:20,780 --> 00:23:24,770
away right so you start having multiple

00:23:23,240 --> 00:23:26,510
links you start having multiple or

00:23:24,770 --> 00:23:29,240
multiple switches and you start doing

00:23:26,510 --> 00:23:32,330
that in a way that they're super fast so

00:23:29,240 --> 00:23:35,060
I compared the K exact time so I've got

00:23:32,330 --> 00:23:37,640
connectivity between H 1 and H 2 so 2

00:23:35,060 --> 00:23:41,420
hosts s 1 is the switch that keeps

00:23:37,640 --> 00:23:44,450
changing and the intent is if I do this

00:23:41,420 --> 00:23:46,460
K exact how long how many missed packets

00:23:44,450 --> 00:23:48,800
don't get how many missed packets are

00:23:46,460 --> 00:23:50,480
done during the time it takes to load

00:23:48,800 --> 00:23:54,250
the new software and get it operational

00:23:50,480 --> 00:23:57,380
and when you have to go up to user space

00:23:54,250 --> 00:23:59,900
you know you're you're really delaying

00:23:57,380 --> 00:24:02,210
the ability to initialize the asic and

00:23:59,900 --> 00:24:04,760
push the configuration down to it when

00:24:02,210 --> 00:24:07,400
that ASIC driver is in the kernel as a

00:24:04,760 --> 00:24:10,160
part of the boot sequence it will you

00:24:07,400 --> 00:24:12,380
know scan the PCI bus see the the ID for

00:24:10,160 --> 00:24:14,990
the ASIC load the driver for it the

00:24:12,380 --> 00:24:17,870
driver will say oh this is a switch

00:24:14,990 --> 00:24:20,960
whatever it has 48 front panel ports I'm

00:24:17,870 --> 00:24:22,340
going to create 48 net devices continue

00:24:20,960 --> 00:24:25,430
know the kernel continues on its boot

00:24:22,340 --> 00:24:27,770
process interface manager it comes up it

00:24:25,430 --> 00:24:31,340
puts the in address config on to the

00:24:27,770 --> 00:24:33,800
interfaces FRR starts up it peers with

00:24:31,340 --> 00:24:36,140
its neighbor gets a route installs it

00:24:33,800 --> 00:24:37,680
into the kernel kernel sees it installs

00:24:36,140 --> 00:24:40,680
into hardware

00:24:37,680 --> 00:24:42,930
it's not right forwarding happens so

00:24:40,680 --> 00:24:44,520
when you when you compare that SDK

00:24:42,930 --> 00:24:47,610
approach where you have to wait till

00:24:44,520 --> 00:24:50,700
user space starts to initialize the ASIC

00:24:47,610 --> 00:24:52,980
there's a much longer delay right so

00:24:50,700 --> 00:24:56,700
being in the kernel can cut that reboot

00:24:52,980 --> 00:25:00,510
time by almost a factor of three right

00:24:56,700 --> 00:25:03,960
which is which is huge another test I

00:25:00,510 --> 00:25:06,180
was working on was route conversions but

00:25:03,960 --> 00:25:08,670
unfortunately the SDK and the kernel

00:25:06,180 --> 00:25:11,910
approach was barfing after 4300 routes

00:25:08,670 --> 00:25:15,180
so it's clearly a sign that you can't

00:25:11,910 --> 00:25:17,010
just take an SDK do some wrappers drop

00:25:15,180 --> 00:25:18,960
it into the kernel so you do got to get

00:25:17,010 --> 00:25:22,380
the ASIC vendors kind of onboard to make

00:25:18,960 --> 00:25:24,330
some changes but with the CL SW approach

00:25:22,380 --> 00:25:27,090
the idea is that they don't have to go

00:25:24,330 --> 00:25:29,520
all in they can make some baby steps in

00:25:27,090 --> 00:25:32,730
that direction first be able to run

00:25:29,520 --> 00:25:34,350
their SDK and the kernel allow the

00:25:32,730 --> 00:25:37,470
external hookups to happen through

00:25:34,350 --> 00:25:40,680
something like CL SW and then in time

00:25:37,470 --> 00:25:42,200
you know they'll figure out that hey oh

00:25:40,680 --> 00:25:44,930
this is a much better model where

00:25:42,200 --> 00:25:47,460
customers are happier things are faster

00:25:44,930 --> 00:25:50,310
we can do our ASIC drivers a little bit

00:25:47,460 --> 00:25:52,530
easier by doing this kernel approach

00:25:50,310 --> 00:25:58,680
that would hopefully be the end result

00:25:52,530 --> 00:26:00,390
of this and unfortunately I guess yeah

00:25:58,680 --> 00:26:02,670
those are the the convergence numbers I

00:26:00,390 --> 00:26:06,810
had to kind of drop out of this because

00:26:02,670 --> 00:26:09,420
of because that SDK approach but I do

00:26:06,810 --> 00:26:12,180
think in the end we're gonna see that

00:26:09,420 --> 00:26:14,580
this is a much lighter much faster much

00:26:12,180 --> 00:26:18,210
simpler model it brings the natural

00:26:14,580 --> 00:26:20,430
order of Linux from you know natural

00:26:18,210 --> 00:26:22,920
order of how Linux works and boots to

00:26:20,430 --> 00:26:26,250
switches and it's gonna be a good thing

00:26:22,920 --> 00:26:29,700
for open networking so at that point I'm

00:26:26,250 --> 00:26:31,620
done and I'll take any questions that do

00:26:29,700 --> 00:26:35,360
not involve why would I put a

00:26:31,620 --> 00:26:35,360
proprietary SDK in the kernel

00:26:36,440 --> 00:26:47,190
all right questions comments or should I

00:26:41,970 --> 00:26:48,690
go yes I am I'm gonna be a contrarian

00:26:47,190 --> 00:26:51,590
and ask you why do you want to put this

00:26:48,690 --> 00:26:54,420
DK and is this ik is this economic

00:26:51,590 --> 00:27:00,740
economical reasons I mean are we giving

00:26:54,420 --> 00:27:04,980
up - I'm gonna name names Broadcom right

00:27:00,740 --> 00:27:07,710
so is it a preference like so let's go

00:27:04,980 --> 00:27:09,300
back to graphics drivers for example

00:27:07,710 --> 00:27:12,540
right we have proprietary graphics

00:27:09,300 --> 00:27:15,510
drivers that work in kernel mode back in

00:27:12,540 --> 00:27:17,730
the 2000s Wi-Fi drivers did not work

00:27:15,510 --> 00:27:19,980
with Linux because the vendors were like

00:27:17,730 --> 00:27:23,820
why do I care about that at hobby OS

00:27:19,980 --> 00:27:26,430
right it takes time for vendors to

00:27:23,820 --> 00:27:28,260
decide this is a model I want to support

00:27:26,430 --> 00:27:30,720
and this is a model I want to that's

00:27:28,260 --> 00:27:33,300
gonna work well for my business right so

00:27:30,720 --> 00:27:35,310
when you look at the SDK approach you

00:27:33,300 --> 00:27:37,470
know start naming names you know you've

00:27:35,310 --> 00:27:40,020
got your Cisco's your wrist --is your

00:27:37,470 --> 00:27:44,280
junipers all those legacy vendors who

00:27:40,020 --> 00:27:47,400
have their ties with the ASIC vendors

00:27:44,280 --> 00:27:50,100
right and their push on them so if they

00:27:47,400 --> 00:27:52,350
start getting scared by the switch dev

00:27:50,100 --> 00:27:53,880
approach or by at the linux model you

00:27:52,350 --> 00:27:56,610
know they can put some pressure on on

00:27:53,880 --> 00:27:57,720
the ecig vendors right and so the Nasik

00:27:56,610 --> 00:27:59,460
vendors are having to kind of make that

00:27:57,720 --> 00:28:02,760
call so it's really the old world

00:27:59,460 --> 00:28:05,790
wanting to hold on to what they have and

00:28:02,760 --> 00:28:07,260
and denying the new world but sooner or

00:28:05,790 --> 00:28:09,300
later the new world is gonna kick in

00:28:07,260 --> 00:28:11,490
it's just a matter of when do they give

00:28:09,300 --> 00:28:13,980
up you know stop stop doing the

00:28:11,490 --> 00:28:16,470
deniability thing and I think with with

00:28:13,980 --> 00:28:17,850
the way the the white box movement is

00:28:16,470 --> 00:28:19,920
happening the way the open networking

00:28:17,850 --> 00:28:21,750
movement is happening we're going to get

00:28:19,920 --> 00:28:23,580
there the only question is how much

00:28:21,750 --> 00:28:27,090
resistance do you have to overcome and

00:28:23,580 --> 00:28:28,830
if we can do something like running the

00:28:27,090 --> 00:28:31,200
SDK in the kernel mode and hook it up

00:28:28,830 --> 00:28:33,930
through CLS W to do the switch dev

00:28:31,200 --> 00:28:35,880
approach and we can speed that up then

00:28:33,930 --> 00:28:37,440
it's it's only for the benefit of

00:28:35,880 --> 00:28:41,910
everyone

00:28:37,440 --> 00:28:45,160
like I think probably the vendors are

00:28:41,910 --> 00:28:49,600
too and to co-author this you can't ask

00:28:45,160 --> 00:28:51,250
questions I want to answer so rather

00:28:49,600 --> 00:28:53,440
than make it a negative statement right

00:28:51,250 --> 00:28:55,330
I think and since you use the graphics

00:28:53,440 --> 00:28:56,650
as an example if you looked at what

00:28:55,330 --> 00:28:58,350
happened in graphics if you look at what

00:28:56,650 --> 00:29:00,880
happened in life I actually the demand

00:28:58,350 --> 00:29:03,550
created the answer if you look at what

00:29:00,880 --> 00:29:04,990
Intel did with the 1,000 driver in the

00:29:03,550 --> 00:29:07,000
next phase the demand create at the

00:29:04,990 --> 00:29:09,250
market the question I think for this

00:29:07,000 --> 00:29:11,710
audience more than anybody else is is

00:29:09,250 --> 00:29:13,660
the demand going to be there and I think

00:29:11,710 --> 00:29:15,970
and we've made this case before that

00:29:13,660 --> 00:29:18,490
having Linux has sort of your data

00:29:15,970 --> 00:29:21,640
center operating system having complete

00:29:18,490 --> 00:29:24,280
transparency is obviously a drag or a

00:29:21,640 --> 00:29:26,140
drag towards good or towards the answer

00:29:24,280 --> 00:29:28,210
we're looking for but I think the bigger

00:29:26,140 --> 00:29:30,100
point that is being shown here is that

00:29:28,210 --> 00:29:31,390
there is also a drag in terms of

00:29:30,100 --> 00:29:33,490
efficiency in terms of actual

00:29:31,390 --> 00:29:35,470
performance and throughput and that if

00:29:33,490 --> 00:29:37,870
you can get to that as sort of if that

00:29:35,470 --> 00:29:39,450
becomes the ideal goal eventually the

00:29:37,870 --> 00:29:41,980
market will pull in that direction

00:29:39,450 --> 00:29:44,200
independent of resistance or whatnot

00:29:41,980 --> 00:29:45,880
there will be absolute positive thing to

00:29:44,200 --> 00:29:48,550
get out of it and it's unconditional

00:29:45,880 --> 00:29:50,680
actually so if you look at the numbers

00:29:48,550 --> 00:29:52,600
that we could that we did get but I

00:29:50,680 --> 00:29:54,730
expect those numbers will be fantastic

00:29:52,600 --> 00:29:56,650
as well if the artificial hurdles

00:29:54,730 --> 00:29:58,750
weren't there and urk exact number which

00:29:56,650 --> 00:30:00,250
is about a 3x improvement this is this

00:29:58,750 --> 00:30:02,680
is an absolute improvement right it's

00:30:00,250 --> 00:30:06,000
not it's not like open to interpretation

00:30:02,680 --> 00:30:06,000
it's not fake news

00:30:09,110 --> 00:30:14,909
some of the legacy vendors make all that

00:30:11,429 --> 00:30:17,299
fake news but no it is something that's

00:30:14,909 --> 00:30:20,520
it's fairly easy to see once you can

00:30:17,299 --> 00:30:23,190
move that SDK out of user space and drop

00:30:20,520 --> 00:30:26,400
it into the kernel and and have it work

00:30:23,190 --> 00:30:28,440
in line you see the you see the

00:30:26,400 --> 00:30:35,280
performance speed up immediately it's

00:30:28,440 --> 00:30:37,710
something it's easy to reproduce and I

00:30:35,280 --> 00:30:39,059
do want to point out that is you know I

00:30:37,710 --> 00:30:41,429
can say I get up here from these bright

00:30:39,059 --> 00:30:43,590
lights and kind of forget a whole lot of

00:30:41,429 --> 00:30:45,150
comments I do want to point out that the

00:30:43,590 --> 00:30:47,460
switch to have approach really is

00:30:45,150 --> 00:30:50,280
enabled and really as possible because

00:30:47,460 --> 00:30:51,870
of the the time and the at work effort

00:30:50,280 --> 00:30:54,330
and development that's happened within

00:30:51,870 --> 00:30:56,820
the Linux kernel making it feature

00:30:54,330 --> 00:30:58,710
comparable and and perform it scalable

00:30:56,820 --> 00:31:01,080
and all that kind of stuff so it's it's

00:30:58,710 --> 00:31:02,340
been the work of you know everyone who's

00:31:01,080 --> 00:31:04,799
focused on this new open networking

00:31:02,340 --> 00:31:06,690
movement focusing on the Linux kernel

00:31:04,799 --> 00:31:09,270
and making it better that's enabling the

00:31:06,690 --> 00:31:12,630
switch to have approach to happen so I

00:31:09,270 --> 00:31:15,450
could okay so the DP DK guys could is it

00:31:12,630 --> 00:31:17,760
fair to say I'll put a switch in user

00:31:15,450 --> 00:31:20,720
space and I just I'll do the switch dev

00:31:17,760 --> 00:31:24,539
model it's a binary blob in user space

00:31:20,720 --> 00:31:26,820
using DP DK what's the difference you're

00:31:24,539 --> 00:31:30,450
putting some binary blob and SDK in the

00:31:26,820 --> 00:31:33,059
kernel which is belongs to some vendor

00:31:30,450 --> 00:31:35,520
and obvious using Linux as a control

00:31:33,059 --> 00:31:38,600
pantech control interface based so it

00:31:35,520 --> 00:31:41,909
gets into how do you want to configure

00:31:38,600 --> 00:31:44,640
administer monitor service your switches

00:31:41,909 --> 00:31:46,320
and I guess what I meant that I would

00:31:44,640 --> 00:31:49,049
make with the switch to have approach is

00:31:46,320 --> 00:31:51,240
that you're not having to reinvent

00:31:49,049 --> 00:31:54,240
everything just because you have a

00:31:51,240 --> 00:31:56,309
switch right the DB d DP DK approach

00:31:54,240 --> 00:31:58,890
it's all customized right

00:31:56,309 --> 00:32:00,630
there's no I mean actually not link to

00:31:58,890 --> 00:32:03,090
configure why not I mean I could send

00:32:00,630 --> 00:32:05,669
things to user space what's that I could

00:32:03,090 --> 00:32:07,440
I could run IP route to commands nature

00:32:05,669 --> 00:32:09,900
to the kernel punt him back to user

00:32:07,440 --> 00:32:13,169
space yes and talk to something in in DB

00:32:09,900 --> 00:32:15,870
DK sure would that be acceptable patches

00:32:13,169 --> 00:32:18,000
like that have been rejected so far why

00:32:15,870 --> 00:32:20,470
why is this any different

00:32:18,000 --> 00:32:21,850
would give me an example of patches that

00:32:20,470 --> 00:32:24,730
have been rich I think six winned I'd

00:32:21,850 --> 00:32:28,000
put up some patches Nikolas can always

00:32:24,730 --> 00:32:29,740
last name because I mean I think it's

00:32:28,000 --> 00:32:31,300
well known that that's the cumulus model

00:32:29,740 --> 00:32:35,530
is that we have the we are stuck with

00:32:31,300 --> 00:32:37,390
the user space SDK right and we want to

00:32:35,530 --> 00:32:39,190
have the Linux API is for the

00:32:37,390 --> 00:32:42,400
configuring the monitoring and all that

00:32:39,190 --> 00:32:43,510
so you can run IP rl2 or FRR or whatever

00:32:42,400 --> 00:32:46,030
you want to and userspace

00:32:43,510 --> 00:32:47,830
it put stuff into the kernel and then

00:32:46,030 --> 00:32:49,390
the notifications go up to user space

00:32:47,830 --> 00:32:52,120
and it's listening and able to program

00:32:49,390 --> 00:32:54,910
hardware right so if you're using that

00:32:52,120 --> 00:32:56,820
approach a DP DK and a user space SDK

00:32:54,910 --> 00:33:00,670
they're really kind of the same thing

00:32:56,820 --> 00:33:04,150
yeah but that there's been no objections

00:33:00,670 --> 00:33:05,950
to it anyways

00:33:04,150 --> 00:33:08,230
I don't be the only guy asking questions

00:33:05,950 --> 00:33:11,440
anybody else or should we just go for

00:33:08,230 --> 00:33:14,500
lunch I can't believe nobody else is

00:33:11,440 --> 00:33:18,340
asking anybody remote he just suggested

00:33:14,500 --> 00:33:21,400
oh there's actually questions okay hold

00:33:18,340 --> 00:33:24,250
on question number one from remote once

00:33:21,400 --> 00:33:27,460
CLS IDO do you want to do this or should

00:33:24,250 --> 00:33:31,300
I say it where you can just tell me you

00:33:27,460 --> 00:33:32,110
mic and speak there's no mic okay he

00:33:31,300 --> 00:33:37,390
doesn't have a mic

00:33:32,110 --> 00:33:39,880
I want the CLS W mode only prolong the

00:33:37,390 --> 00:33:43,720
transition to the full switch dev model

00:33:39,880 --> 00:33:45,250
and it will supposedly let vendors get

00:33:43,720 --> 00:33:51,120
the benefits of the internal approach

00:33:45,250 --> 00:33:53,740
but without open sourcing anything yes

00:33:51,120 --> 00:33:56,980
remote come from someone with JP

00:33:53,740 --> 00:33:59,560
initials certainly you can make that

00:33:56,980 --> 00:34:01,750
argument right but what do we have today

00:33:59,560 --> 00:34:04,780
so switch dev model started I think it

00:34:01,750 --> 00:34:07,390
was about four years ago and there's one

00:34:04,780 --> 00:34:08,830
driver and the kernel full-featured ASIC

00:34:07,390 --> 00:34:13,750
driver in the kernel right and that's

00:34:08,830 --> 00:34:17,130
Mel axes so what's gonna get the other

00:34:13,750 --> 00:34:20,080
vendors to say yes I like this approach

00:34:17,130 --> 00:34:22,030
adding more overhead to them isn't going

00:34:20,080 --> 00:34:24,880
to make them jump to this new approach

00:34:22,030 --> 00:34:26,590
right but if you can alleviate some of

00:34:24,880 --> 00:34:28,630
their overhead if you take away this

00:34:26,590 --> 00:34:30,750
this need to handle all those events and

00:34:28,630 --> 00:34:33,899
and their knowledge that's needed

00:34:30,750 --> 00:34:35,940
you just say you know what just get your

00:34:33,899 --> 00:34:38,040
current get your STK to run in the

00:34:35,940 --> 00:34:39,720
kernel right so that means it

00:34:38,040 --> 00:34:41,820
understands atomic context it

00:34:39,720 --> 00:34:43,860
understands how to do memory allocations

00:34:41,820 --> 00:34:45,570
it understands how to do you know the

00:34:43,860 --> 00:34:47,220
polling thread for the front panel ports

00:34:45,570 --> 00:34:49,980
are done through a kernel thread instead

00:34:47,220 --> 00:34:53,220
of user space thread and then it knows

00:34:49,980 --> 00:34:56,700
how to register operations with the CL

00:34:53,220 --> 00:34:59,760
SW module and you've really lightened

00:34:56,700 --> 00:35:03,570
what they need to do to move to the new

00:34:59,760 --> 00:35:06,150
world so the hope would be okay if this

00:35:03,570 --> 00:35:09,750
models better and this models faster

00:35:06,150 --> 00:35:11,220
then and you're giving us a way to put

00:35:09,750 --> 00:35:14,520
our toe in the water without having to

00:35:11,220 --> 00:35:17,480
go all-in right you're doing what you

00:35:14,520 --> 00:35:21,570
can to nudge nudge when you don't own

00:35:17,480 --> 00:35:23,490
the ASIC you own the hardware and the

00:35:21,570 --> 00:35:26,610
driver yourself right that's the most

00:35:23,490 --> 00:35:29,130
that Outsiders can do is to nudge in to

00:35:26,610 --> 00:35:32,220
help for the record I'm not convinced

00:35:29,130 --> 00:35:35,540
but and I would I never thought I'll

00:35:32,220 --> 00:35:39,140
hear this at the native conference but

00:35:35,540 --> 00:35:39,140
anybody else has a question

00:35:40,370 --> 00:35:47,220
all right Oh somebody that's a cheap and

00:35:44,910 --> 00:35:50,000
quick sure yeah quick question so can

00:35:47,220 --> 00:35:54,330
you compare the effort that is required

00:35:50,000 --> 00:35:56,130
by a vendor if they rent the switch to

00:35:54,330 --> 00:36:00,510
approach versus the new approach like

00:35:56,130 --> 00:36:03,450
what what work do they need to do so

00:36:00,510 --> 00:36:04,740
arguably if you're a new vendor and

00:36:03,450 --> 00:36:06,420
you're wanting to move to the switch dev

00:36:04,740 --> 00:36:08,760
model that was kind of what I was

00:36:06,420 --> 00:36:10,830
getting at with this overhead you have

00:36:08,760 --> 00:36:13,500
to understand the kernel way you have to

00:36:10,830 --> 00:36:15,840
understand what it what a net DevOps are

00:36:13,500 --> 00:36:18,630
what the equal ops are what the deviling

00:36:15,840 --> 00:36:20,280
cops are what the switch dev ops are you

00:36:18,630 --> 00:36:22,740
had a whole bunch of operations handlers

00:36:20,280 --> 00:36:25,410
then you got to get into things like the

00:36:22,740 --> 00:36:26,880
net events for if there's a hash policy

00:36:25,410 --> 00:36:29,130
change you got to make the hardware and

00:36:26,880 --> 00:36:31,530
software the same you got to understand

00:36:29,130 --> 00:36:33,260
the the net dev events when a VLAN gets

00:36:31,530 --> 00:36:37,020
added when the links going up and down

00:36:33,260 --> 00:36:40,569
there's a there's arguably a lot of

00:36:37,020 --> 00:36:43,809
overhead to get that first driver in

00:36:40,569 --> 00:36:45,999
and the point of Celeste of you is just

00:36:43,809 --> 00:36:48,549
to lighten not to basically say let's

00:36:45,999 --> 00:36:51,189
let's create a common layer we're gonna

00:36:48,549 --> 00:36:53,439
help vendor drivers get there by

00:36:51,189 --> 00:36:55,929
creating this common layer that does the

00:36:53,439 --> 00:36:58,119
stuff for them and now you just give me

00:36:55,929 --> 00:36:59,739
a set of operations that say here's how

00:36:58,119 --> 00:37:01,179
you create a route here's how you delete

00:36:59,739 --> 00:37:03,369
a route here's how you create a VLAN

00:37:01,179 --> 00:37:05,559
here's how you delete ugly on VLAN so

00:37:03,369 --> 00:37:08,140
you you've reduced what the vendor has

00:37:05,559 --> 00:37:10,119
to do to just a set of operations that

00:37:08,140 --> 00:37:11,890
taps into the rest DK something they're

00:37:10,119 --> 00:37:13,779
already familiar with with the Sai

00:37:11,890 --> 00:37:20,619
approach or with the typical user space

00:37:13,779 --> 00:37:22,630
approach to programming the basic follow

00:37:20,619 --> 00:37:24,489
up question I think one of the vendors

00:37:22,630 --> 00:37:28,299
here has already done the switch step

00:37:24,489 --> 00:37:29,859
right so be good to hear what what their

00:37:28,299 --> 00:37:31,989
experience was I mean looks like they

00:37:29,859 --> 00:37:34,059
went through the the previous exercise

00:37:31,989 --> 00:37:37,419
of understanding what the kernel needs

00:37:34,059 --> 00:37:41,469
and all and full disclosure I yeah I I

00:37:37,419 --> 00:37:44,410
do know the LX w ml x SW driver pretty

00:37:41,469 --> 00:37:48,249
well and perhaps that's where a lot of

00:37:44,410 --> 00:37:49,689
CL SW code came from right I wasn't

00:37:48,249 --> 00:37:52,959
trying to reinvent that wheel I'm just

00:37:49,689 --> 00:37:54,789
trying to do this this push in a

00:37:52,959 --> 00:37:57,099
direction that you believe is the right

00:37:54,789 --> 00:37:58,869
direction but not reinventing a lot of

00:37:57,099 --> 00:38:04,299
wheels and if they've done a lot of

00:37:58,869 --> 00:38:07,839
really good work to track fib events to

00:38:04,299 --> 00:38:09,489
track linked events to take that code

00:38:07,839 --> 00:38:13,059
and try to bring it into a common layer

00:38:09,489 --> 00:38:14,049
again it could simplify their driver as

00:38:13,059 --> 00:38:16,779
well the Mellanox

00:38:14,049 --> 00:38:18,579
driver as well so it really is you know

00:38:16,779 --> 00:38:20,229
everything about network operating

00:38:18,579 --> 00:38:22,199
systems and in really technology in

00:38:20,229 --> 00:38:25,479
general it's all evolutionary and

00:38:22,199 --> 00:38:27,429
someone blazes it blazes a path and

00:38:25,479 --> 00:38:28,929
creates a capability and someone else

00:38:27,429 --> 00:38:30,519
comes along and says that's great it was

00:38:28,929 --> 00:38:31,900
great stepping stone I'm gonna take that

00:38:30,519 --> 00:38:33,219
and I'm gonna make it tweaked or I'm

00:38:31,900 --> 00:38:35,650
gonna take that and generalize it and

00:38:33,219 --> 00:38:38,439
use it in other places so it's it really

00:38:35,650 --> 00:38:40,689
is a part of that natural evolution so I

00:38:38,439 --> 00:38:43,029
want to add to that comment right it's

00:38:40,689 --> 00:38:45,609
really there were two sentences that

00:38:43,029 --> 00:38:47,979
were used that I think are fundamentally

00:38:45,609 --> 00:38:50,919
flawed one is this is not switch dev

00:38:47,979 --> 00:38:52,980
versus this approach this approach just

00:38:50,919 --> 00:38:55,650
formalizes an interface that makes it

00:38:52,980 --> 00:38:58,830
easier to engage into the switch to have

00:38:55,650 --> 00:39:00,420
morale to to David's point it's not it's

00:38:58,830 --> 00:39:02,160
not that there are two different

00:39:00,420 --> 00:39:04,619
strategies in fact even the code might

00:39:02,160 --> 00:39:06,930
be the same it's more the fact that if

00:39:04,619 --> 00:39:08,609
you are a vendor today and you think

00:39:06,930 --> 00:39:11,760
about how you're going to integrate very

00:39:08,609 --> 00:39:12,960
deeply with the Linux kernel you're not

00:39:11,760 --> 00:39:15,390
thinking about what the right

00:39:12,960 --> 00:39:17,940
abstraction is for other devices as well

00:39:15,390 --> 00:39:19,500
and and one of this will or one of the

00:39:17,940 --> 00:39:21,030
goals of this attempt was to try and

00:39:19,500 --> 00:39:23,130
build that abstraction the first thing

00:39:21,030 --> 00:39:24,750
the second thing is it's an abstraction

00:39:23,130 --> 00:39:27,660
interface there is it does not

00:39:24,750 --> 00:39:29,369
fundamentally imply a binary blob there

00:39:27,660 --> 00:39:32,940
is nothing that stops people from

00:39:29,369 --> 00:39:36,750
submitting the code in in an open way

00:39:32,940 --> 00:39:39,030
but today fundamentally making it such

00:39:36,750 --> 00:39:41,880
that you say before you can even commit

00:39:39,030 --> 00:39:44,010
or understand or test the market-- you

00:39:41,880 --> 00:39:47,430
have to go through legal and understand

00:39:44,010 --> 00:39:49,410
what open sourcing means is it's a

00:39:47,430 --> 00:39:52,140
progress killer and this gives you the

00:39:49,410 --> 00:39:54,060
option to understand for yourself what

00:39:52,140 --> 00:39:56,070
it is that you're going to get and then

00:39:54,060 --> 00:39:58,500
decide what your course of action has to

00:39:56,070 --> 00:40:02,340
be there is nothing implicit in this

00:39:58,500 --> 00:40:07,170
that says binary blob in fact it's not

00:40:02,340 --> 00:40:09,060
even a stated goal okay maybe we'll

00:40:07,170 --> 00:40:11,970
carry this afterwards I guess a there's

00:40:09,060 --> 00:40:13,750
two rooms we have that we'll just give a

00:40:11,970 --> 00:40:18,199
round of applause for David

00:40:13,750 --> 00:40:18,199

YouTube URL: https://www.youtube.com/watch?v=CfgjbHivdQ8


