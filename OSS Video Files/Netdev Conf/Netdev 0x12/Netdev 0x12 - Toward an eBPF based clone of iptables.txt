Title: Netdev 0x12 - Toward an eBPF based clone of iptables
Publication date: 2018-07-31
Playlist: Netdev 0x12
Description: 
	Recently there had been discussions for the replacement of iptables with an eBPF-based approach.

In this moonshot talk, Fulvio Risso discussed at Netdev 0x12 in Montreal on July 12th, 2018, what his team felt was needed to make such a transition. Is eBPF ready to replace iptables?

More info:
https://www.netdevconf.org/0x12/session.html?toward-an-ebpf-based-clone-of-iptables
Captions: 
	00:00:03,170 --> 00:00:08,400
okay good money everybody thanks for

00:00:06,480 --> 00:00:11,969
attending to this stall this morning and

00:00:08,400 --> 00:00:14,160
tech also to the sponsors that you can

00:00:11,969 --> 00:00:18,810
see on the slides that made this work

00:00:14,160 --> 00:00:23,869
possible so this work I started several

00:00:18,810 --> 00:00:27,029
months ago in November 2018 as applied

00:00:23,869 --> 00:00:30,179
research university project in our

00:00:27,029 --> 00:00:34,140
University in Italy so in our group we

00:00:30,179 --> 00:00:37,290
started to work on the eb PF technology

00:00:34,140 --> 00:00:39,960
several time ago and at some point last

00:00:37,290 --> 00:00:42,899
year we decided to take these new

00:00:39,960 --> 00:00:46,170
challenges so try to implement a complex

00:00:42,899 --> 00:00:50,910
application network application in eb PF

00:00:46,170 --> 00:00:52,969
and sooner or later we decided that that

00:00:50,910 --> 00:00:54,239
complicated application could be

00:00:52,969 --> 00:00:57,030
iptables

00:00:54,239 --> 00:01:00,539
so the original idea last year was let's

00:00:57,030 --> 00:01:03,870
try to implement IP tables using this

00:01:00,539 --> 00:01:06,530
EVP of technology and see how this works

00:01:03,870 --> 00:01:10,770
I mean if this technology is really

00:01:06,530 --> 00:01:16,020
already to go in in this kind of very

00:01:10,770 --> 00:01:19,290
complex stuff IP table was let's say by

00:01:16,020 --> 00:01:22,500
chance was a choice simply because a

00:01:19,290 --> 00:01:24,720
beatable is known or is considered in

00:01:22,500 --> 00:01:27,900
some sense having some limitation in

00:01:24,720 --> 00:01:31,680
term of true with performance and EB PF

00:01:27,900 --> 00:01:34,710
with xdp is considered to be very fast

00:01:31,680 --> 00:01:37,860
so every tables is considered as low a

00:01:34,710 --> 00:01:40,530
eb PF is considered fast let's put it

00:01:37,860 --> 00:01:44,100
together and try to see what happens so

00:01:40,530 --> 00:01:49,170
okay this talk is about our experience

00:01:44,100 --> 00:01:53,220
in implementing this right so first part

00:01:49,170 --> 00:01:57,960
of my talk is what we do what we did so

00:01:53,220 --> 00:02:01,950
far in fact we divided our work in four

00:01:57,960 --> 00:02:05,180
main challenges of forming objectives

00:02:01,950 --> 00:02:09,030
and definitely the first objective is to

00:02:05,180 --> 00:02:12,690
preserve the IP table semantics so the

00:02:09,030 --> 00:02:13,440
objective is if the user configures our

00:02:12,690 --> 00:02:16,860
feet

00:02:13,440 --> 00:02:19,140
rose in IP table by the way IP table for

00:02:16,860 --> 00:02:22,410
the time being is just filtering rules

00:02:19,140 --> 00:02:26,160
for us we're not considering netting

00:02:22,410 --> 00:02:29,280
rules I can tell you a little bit later

00:02:26,160 --> 00:02:32,550
about netting so if the user comes

00:02:29,280 --> 00:02:36,990
configures filtering rule maybe in the

00:02:32,550 --> 00:02:40,560
input chain we have to emulate exactly

00:02:36,990 --> 00:02:43,080
that behavior with a BBFS so if the user

00:02:40,560 --> 00:02:44,910
configures the the rule in a input chain

00:02:43,080 --> 00:02:47,550
it means that the traffic that is

00:02:44,910 --> 00:02:49,680
forwarded by the machine is not affected

00:02:47,550 --> 00:02:52,590
by that filtering role

00:02:49,680 --> 00:02:54,990
this seems trivial unfortunately the

00:02:52,590 --> 00:02:58,680
current architecture that we have in EBP

00:02:54,990 --> 00:03:00,750
F is a little bit different from what we

00:02:58,680 --> 00:03:03,120
have in that filter so as you can see in

00:03:00,750 --> 00:03:06,360
the slides there are a lot of paths in a

00:03:03,120 --> 00:03:08,340
net filter that take decision so the

00:03:06,360 --> 00:03:10,110
packet comes go to the night it goes to

00:03:08,340 --> 00:03:13,500
the route in decision and then it can

00:03:10,110 --> 00:03:15,740
cross either the input chain or the

00:03:13,500 --> 00:03:19,010
forward chain

00:03:15,740 --> 00:03:21,900
unfortunately in EBP F the hook point

00:03:19,010 --> 00:03:24,660
let's consider just the input because

00:03:21,900 --> 00:03:28,380
the output is just a specular so the

00:03:24,660 --> 00:03:30,720
input whole point is just the influent

00:03:28,380 --> 00:03:33,480
of the internal filter child that means

00:03:30,720 --> 00:03:36,570
that all packets are are coming there so

00:03:33,480 --> 00:03:39,690
is not easiest not trivial there to

00:03:36,570 --> 00:03:42,330
distinguish what is going on so if the

00:03:39,690 --> 00:03:45,750
packet will cross the input chain will

00:03:42,330 --> 00:03:49,800
cross the the forward chain so that was

00:03:45,750 --> 00:03:53,010
the main objective the main point here

00:03:49,800 --> 00:03:56,670
and so we had to implement of course our

00:03:53,010 --> 00:04:00,090
code in the EBP F who either is the P or

00:03:56,670 --> 00:04:02,910
RTC doesn't doesn't matter right now but

00:04:00,090 --> 00:04:06,180
we have to implement this code by a

00:04:02,910 --> 00:04:10,290
cascade of two blocks so the packet

00:04:06,180 --> 00:04:12,780
comes to the TC xdp Luca is intercepted

00:04:10,290 --> 00:04:15,720
it goes to a first block that we call

00:04:12,780 --> 00:04:18,120
ingress chain selector that is a piece

00:04:15,720 --> 00:04:20,280
of code that is dynamically generated

00:04:18,120 --> 00:04:22,289
that has to predict whether the packet

00:04:20,280 --> 00:04:24,870
that will cross the English Channel the

00:04:22,289 --> 00:04:26,790
forward chain the pollution is in fact

00:04:24,870 --> 00:04:29,670
rather simple because I mean

00:04:26,790 --> 00:04:32,100
if the packet is directed to a local

00:04:29,670 --> 00:04:35,010
destination which means an IP configured

00:04:32,100 --> 00:04:37,320
in the root namespace okay then the

00:04:35,010 --> 00:04:41,280
packet is related to local process so as

00:04:37,320 --> 00:04:43,410
to cross the English ale vice versa the

00:04:41,280 --> 00:04:47,190
packet has to cross the forward shell

00:04:43,410 --> 00:04:49,890
and under seed so our basic architecture

00:04:47,190 --> 00:04:52,110
is made by this English change selector

00:04:49,890 --> 00:04:54,630
that is dynamically created and

00:04:52,110 --> 00:04:56,610
configured of course because you can add

00:04:54,630 --> 00:04:59,100
the new interface into the system you

00:04:56,610 --> 00:05:01,320
can change the IP address that you have

00:04:59,100 --> 00:05:03,690
in the system and the English translator

00:05:01,320 --> 00:05:07,230
has to be updated dynamically in order

00:05:03,690 --> 00:05:09,780
to emulate the behavior of IP tables and

00:05:07,230 --> 00:05:12,900
then the English translator based on the

00:05:09,780 --> 00:05:15,000
result of the prediction logic it will

00:05:12,900 --> 00:05:17,340
follow the packet to the English chain

00:05:15,000 --> 00:05:19,890
on the order or all the forward chain

00:05:17,340 --> 00:05:22,620
and then from there it goes again

00:05:19,890 --> 00:05:25,290
to netfilter and then goes to the Linux

00:05:22,620 --> 00:05:27,420
stack and obviously the same thing

00:05:25,290 --> 00:05:29,490
happens for the packets that crossing

00:05:27,420 --> 00:05:35,310
the network stack in the other direction

00:05:29,490 --> 00:05:38,670
that cross the output chain second

00:05:35,310 --> 00:05:40,380
objective key objective is a fast

00:05:38,670 --> 00:05:42,420
matching algorithm that we started

00:05:40,380 --> 00:05:45,690
saying that the IP table is little bit

00:05:42,420 --> 00:05:49,860
slow and the reason basically is that IP

00:05:45,690 --> 00:05:53,520
tables is using a linear search in in

00:05:49,860 --> 00:05:56,370
order to match filter rules so that's an

00:05:53,520 --> 00:05:58,050
easy way if we want to compete with a

00:05:56,370 --> 00:05:59,990
linear search I mean there are plenty of

00:05:58,050 --> 00:06:03,360
options that we can go faster

00:05:59,990 --> 00:06:07,020
unfortunately that's not that much easy

00:06:03,360 --> 00:06:11,190
in a BBF because the matching algorithm

00:06:07,020 --> 00:06:14,880
that has to be implemented in IPPF as to

00:06:11,190 --> 00:06:17,310
undergo according to all the the

00:06:14,880 --> 00:06:19,770
limitation that the BBF technology has

00:06:17,310 --> 00:06:22,920
so for instance in a BBF you don't have

00:06:19,770 --> 00:06:25,800
memory available for you you have maps

00:06:22,920 --> 00:06:28,080
available for you which means max are

00:06:25,800 --> 00:06:31,590
structural memory so you have to

00:06:28,080 --> 00:06:33,960
implement an algorithm that can be that

00:06:31,590 --> 00:06:37,650
is feasible with the current structure

00:06:33,960 --> 00:06:40,040
of the maps that are available in a BBF

00:06:37,650 --> 00:06:41,990
I just forgot to mention

00:06:40,040 --> 00:06:45,290
one of the key point of our project that

00:06:41,990 --> 00:06:47,330
was do not touch the Linux kernel so

00:06:45,290 --> 00:06:50,120
let's try to implement everything with

00:06:47,330 --> 00:06:52,760
the vanilla kernel so the kernel may

00:06:50,120 --> 00:06:55,690
evolve over time but we have to take

00:06:52,760 --> 00:06:59,120
into account this limitation so

00:06:55,690 --> 00:07:01,790
implementing a new map in IPPF was not

00:06:59,120 --> 00:07:05,470
the option so at the end of the story we

00:07:01,790 --> 00:07:07,970
choose let's say very old algorithm

00:07:05,470 --> 00:07:11,090
matching algorithm that is the linear

00:07:07,970 --> 00:07:15,440
bit better search this was presented 20

00:07:11,090 --> 00:07:19,220
years ago and that divided the matching

00:07:15,440 --> 00:07:24,800
into a set of matching steps each

00:07:19,220 --> 00:07:27,590
matching step works on a given field of

00:07:24,800 --> 00:07:30,260
the of the rules so in this very simple

00:07:27,590 --> 00:07:33,230
example I configure five rules in IP

00:07:30,260 --> 00:07:36,890
tables all operating on the input chains

00:07:33,230 --> 00:07:39,710
and those rules are checking the value

00:07:36,890 --> 00:07:42,800
of IP destination address protocol in

00:07:39,710 --> 00:07:45,860
either TCP UDP or whatever and the

00:07:42,800 --> 00:07:48,560
destination port okay so in this case we

00:07:45,860 --> 00:07:50,720
have to arrange a pipeline or three

00:07:48,560 --> 00:07:52,940
logical blocks one that is the

00:07:50,720 --> 00:07:56,660
destination IP one that operates on a

00:07:52,940 --> 00:07:58,940
protocol and the other that operates on

00:07:56,660 --> 00:08:01,670
the destination port so when a packet

00:07:58,940 --> 00:08:03,980
comes is matched first on the next

00:08:01,670 --> 00:08:06,700
destination IP and you can see that the

00:08:03,980 --> 00:08:10,790
table here as only two values so

00:08:06,700 --> 00:08:12,590
whatever the the IP destination address

00:08:10,790 --> 00:08:18,650
is it's fine

00:08:12,590 --> 00:08:21,680
or it is a 10000 eight which 0 0 0 / 8

00:08:18,650 --> 00:08:24,170
which means a rule number five and each

00:08:21,680 --> 00:08:25,400
table is coupled with a value so the

00:08:24,170 --> 00:08:28,160
value of the field that we were

00:08:25,400 --> 00:08:28,580
interested in and a bit vector a bit

00:08:28,160 --> 00:08:31,220
fatter

00:08:28,580 --> 00:08:34,460
has a size equal to number of rules so

00:08:31,220 --> 00:08:36,680
we have five rows so we have five bits

00:08:34,460 --> 00:08:40,040
in the bit vector and this bit better

00:08:36,680 --> 00:08:44,240
has a bit at one if the rule is matched

00:08:40,040 --> 00:08:47,300
with that value so you can see that if

00:08:44,240 --> 00:08:50,960
the value is zero zero so a whatever IP

00:08:47,300 --> 00:08:52,880
address is fine the material rules are

00:08:50,960 --> 00:08:57,020
the first four and

00:08:52,880 --> 00:08:59,090
if the value is 1000 0/8 the mature

00:08:57,020 --> 00:09:02,990
rules are all because also the fifth

00:08:59,090 --> 00:09:05,270
rule is matched so the algorithm works

00:09:02,990 --> 00:09:07,880
by steps so it says the destination IP

00:09:05,270 --> 00:09:10,490
each has the protocol and then it puts

00:09:07,880 --> 00:09:15,050
the results of the bit vector in a

00:09:10,490 --> 00:09:17,630
bitwise and and in the end the bitwise

00:09:15,050 --> 00:09:20,630
and of all the processing step give you

00:09:17,630 --> 00:09:23,750
all the rules that are satisfied since

00:09:20,630 --> 00:09:27,320
rules are configured in order so the

00:09:23,750 --> 00:09:28,910
highest priority rule first the most

00:09:27,320 --> 00:09:31,820
significant bit in the resulting big

00:09:28,910 --> 00:09:34,280
vector will give you the matching rule

00:09:31,820 --> 00:09:36,110
so this is an example if the packet

00:09:34,280 --> 00:09:38,840
comes with those parameters IP

00:09:36,110 --> 00:09:42,560
destination 10-1 and blada and protocol

00:09:38,840 --> 00:09:46,610
TCP tang so in the first step will match

00:09:42,560 --> 00:09:48,890
the first sorry the last value in the

00:09:46,610 --> 00:09:52,160
table in the second processing step it

00:09:48,890 --> 00:09:55,430
matches the TCP is in fact TCP so there

00:09:52,160 --> 00:09:57,530
are other rules potentially matching and

00:09:55,430 --> 00:10:00,530
the deter the processing step it matches

00:09:57,530 --> 00:10:04,040
the value 80 of the port then you can do

00:10:00,530 --> 00:10:07,550
a bitwise and across all the bit vector

00:10:04,040 --> 00:10:10,100
and the most significant bit in the

00:10:07,550 --> 00:10:12,740
resulting bit better says that this roll

00:10:10,100 --> 00:10:16,130
number one is the one that matches this

00:10:12,740 --> 00:10:18,770
packet okay so I just spent a little bit

00:10:16,130 --> 00:10:22,130
of time on tear that is 20 years old but

00:10:18,770 --> 00:10:24,830
anyway what is in interesting at this

00:10:22,130 --> 00:10:27,400
point is how we implement this algorithm

00:10:24,830 --> 00:10:33,160
and we implement this algorithm as a

00:10:27,400 --> 00:10:37,100
cascade of eb PF models made by in fact

00:10:33,160 --> 00:10:41,990
n plus 2 models where n is the number of

00:10:37,100 --> 00:10:43,520
fields that we are operating on so in

00:10:41,990 --> 00:10:45,890
case we have three fields like in the

00:10:43,520 --> 00:10:49,460
previous example we have three models

00:10:45,890 --> 00:10:51,950
that match each field individually plus

00:10:49,460 --> 00:10:53,600
two additional programs one at the

00:10:51,950 --> 00:10:57,500
beginning of the chain that does the

00:10:53,600 --> 00:11:00,200
header parsing like was proposed by

00:10:57,500 --> 00:11:03,250
before yesterday so on and the last

00:11:00,200 --> 00:11:05,710
BPF program which is the the

00:11:03,250 --> 00:11:08,320
the last of the chain that basically

00:11:05,710 --> 00:11:11,050
checks the first bit mostly if you can

00:11:08,320 --> 00:11:13,450
beat at one and checks in fact which is

00:11:11,050 --> 00:11:15,640
the rule that matches it updates counter

00:11:13,450 --> 00:11:19,420
and it implements the action whether the

00:11:15,640 --> 00:11:26,080
packet has to be accepted or or or drop

00:11:19,420 --> 00:11:28,660
it so the first message is a EB F is is

00:11:26,080 --> 00:11:31,960
good enough in order to implement even a

00:11:28,660 --> 00:11:34,870
complex algorithm subject to the the

00:11:31,960 --> 00:11:36,970
problem that we said before so that you

00:11:34,870 --> 00:11:39,130
cannot do whatever you want because of

00:11:36,970 --> 00:11:41,500
the availability of Maps so data

00:11:39,130 --> 00:11:44,920
structure but in terms of cascading on

00:11:41,500 --> 00:11:48,340
logical block is pretty good also we

00:11:44,920 --> 00:11:50,560
have to extend a little bit the current

00:11:48,340 --> 00:11:52,560
code in order to facilitate the dynamic

00:11:50,560 --> 00:11:54,250
creation of those programs and

00:11:52,560 --> 00:11:57,190
connecting those program together

00:11:54,250 --> 00:11:59,650
because as long as you create a simple

00:11:57,190 --> 00:12:01,420
one program that's fine but if you were

00:11:59,650 --> 00:12:04,240
trying to connect different programs

00:12:01,420 --> 00:12:06,130
together it turns out that the code is a

00:12:04,240 --> 00:12:07,840
little bit difficult to write so we have

00:12:06,130 --> 00:12:10,420
to write a library in order to

00:12:07,840 --> 00:12:12,280
facilitate this dynamic creation of the

00:12:10,420 --> 00:12:18,190
blocks and linking of the blocks

00:12:12,280 --> 00:12:19,720
together second each BPF program so in

00:12:18,190 --> 00:12:22,320
the pipeline in the middle of the

00:12:19,720 --> 00:12:25,240
pipeline is dynamically created and

00:12:22,320 --> 00:12:27,160
injected only what is needed so if we

00:12:25,240 --> 00:12:29,880
were operating on three fields we will

00:12:27,160 --> 00:12:33,190
have a three intermediate block it

00:12:29,880 --> 00:12:35,230
intermediate programs that operate on

00:12:33,190 --> 00:12:38,230
those three fields if at some point the

00:12:35,230 --> 00:12:40,150
user asked me because it configures

00:12:38,230 --> 00:12:43,530
another rule that operates on a fourth

00:12:40,150 --> 00:12:46,030
field ok we have to modify the the

00:12:43,530 --> 00:12:47,589
pipeline inject a new program that

00:12:46,030 --> 00:12:52,330
operates on the fourth field that is

00:12:47,589 --> 00:12:53,980
needed that's nice at least for my

00:12:52,330 --> 00:12:56,830
perspective because it means that the

00:12:53,980 --> 00:12:58,450
pipeline is the namely adjusted based on

00:12:56,830 --> 00:13:01,330
the rules you have so you don't have

00:12:58,450 --> 00:13:04,360
processing overhead because you have to

00:13:01,330 --> 00:13:07,630
support many fields which maybe are not

00:13:04,360 --> 00:13:09,730
used you can dynamically create this

00:13:07,630 --> 00:13:12,339
pipeline and inject only the programs

00:13:09,730 --> 00:13:15,010
that are actually needed according to

00:13:12,339 --> 00:13:16,880
your rules so three fields three by

00:13:15,010 --> 00:13:19,910
three three step of the pipeline five

00:13:16,880 --> 00:13:22,820
fields in jet due to to progress more

00:13:19,910 --> 00:13:26,240
and this is dynamically updated so

00:13:22,820 --> 00:13:30,950
blocks are added and removed pretty

00:13:26,240 --> 00:13:33,700
easily even more each step of the

00:13:30,950 --> 00:13:36,170
pipeline can be customized with the

00:13:33,700 --> 00:13:40,430
partial matching algorithm that is the

00:13:36,170 --> 00:13:43,100
best for the field so logically the

00:13:40,430 --> 00:13:46,700
algorithm is just a matching on the

00:13:43,100 --> 00:13:49,610
field per step but the algorithm that is

00:13:46,700 --> 00:13:54,440
used to perform that single matching is

00:13:49,610 --> 00:13:57,740
not specified so you can use lookup like

00:13:54,440 --> 00:13:59,960
an ash mapper you can use an exotic or

00:13:57,740 --> 00:14:03,020
ancient cup you can use a longest prefix

00:13:59,960 --> 00:14:06,110
match whatever and also those algorithms

00:14:03,020 --> 00:14:07,940
can be changed dynamically so based on

00:14:06,110 --> 00:14:10,400
on the the value that you have if you

00:14:07,940 --> 00:14:12,350
have maybe two values like two ports

00:14:10,400 --> 00:14:16,190
okay you can just implement the code

00:14:12,350 --> 00:14:19,400
like a couple of ifs if value is X or it

00:14:16,190 --> 00:14:21,620
is a Y and that's it if you have more

00:14:19,400 --> 00:14:24,590
values you can implement the code as a

00:14:21,620 --> 00:14:27,500
map or whatever so the other message is

00:14:24,590 --> 00:14:30,560
that the dynamic creation of the code

00:14:27,500 --> 00:14:32,900
and update of the code in the BPF allows

00:14:30,560 --> 00:14:35,720
you to tune each single processing step

00:14:32,900 --> 00:14:37,580
based exactly on the rules you have on

00:14:35,720 --> 00:14:40,760
the values you have and you can choose

00:14:37,580 --> 00:14:42,110
the namely the sub algorithm that is

00:14:40,760 --> 00:14:46,430
best for you

00:14:42,110 --> 00:14:50,900
in this case other passing is done

00:14:46,430 --> 00:14:54,170
building already said that one of the

00:14:50,900 --> 00:14:56,570
problem we had is that at the end after

00:14:54,170 --> 00:14:59,480
the matching each step you have to

00:14:56,570 --> 00:15:02,660
perform a bitwise operation on the bit

00:14:59,480 --> 00:15:05,570
vector and the big factor as size equal

00:15:02,660 --> 00:15:10,640
to the numbers or rules that you have so

00:15:05,570 --> 00:15:14,990
in our case we support up to 8 K rules

00:15:10,640 --> 00:15:17,030
which may be bigger or or small

00:15:14,990 --> 00:15:19,880
depending on your use case but I mean

00:15:17,030 --> 00:15:23,660
that's the limit we have simply because

00:15:19,880 --> 00:15:26,810
in a BBF we cannot support rule sorry

00:15:23,660 --> 00:15:28,970
loops so the loop has to be unrolled the

00:15:26,810 --> 00:15:31,279
dynamically so we generate

00:15:28,970 --> 00:15:33,439
of course in our only the loop and at

00:15:31,279 --> 00:15:36,019
some point will reach another problem

00:15:33,439 --> 00:15:38,839
that is the number of instruction is

00:15:36,019 --> 00:15:43,269
becoming too big and so the validator in

00:15:38,839 --> 00:15:49,310
EB PF blocks our code but anyway it K is

00:15:43,269 --> 00:15:53,209
for the time being reasonable this is

00:15:49,310 --> 00:15:56,810
basically what in the previous slide I

00:15:53,209 --> 00:15:59,779
called as a input chain or forward chain

00:15:56,810 --> 00:16:04,129
so that single block that was depicted

00:15:59,779 --> 00:16:06,860
in in blue is in fact a cascade of EBP F

00:16:04,129 --> 00:16:12,759
program dynamically created and updated

00:16:06,860 --> 00:16:15,949
and so on so good a bed of this

00:16:12,759 --> 00:16:18,560
algorithm I mean the the the the

00:16:15,949 --> 00:16:20,930
algorithm is not the most important

00:16:18,560 --> 00:16:23,449
thing so the algorithm is used in order

00:16:20,930 --> 00:16:26,779
to go faster but the algorithm be

00:16:23,449 --> 00:16:28,699
changed over time even if the ebf is

00:16:26,779 --> 00:16:31,519
enriched with new type of maps that

00:16:28,699 --> 00:16:34,189
allow you to implement more

00:16:31,519 --> 00:16:37,430
sophisticated algorithm so let's see as

00:16:34,189 --> 00:16:40,959
a proof of concept that in EBP F we can

00:16:37,430 --> 00:16:45,350
do complex things and implement complex

00:16:40,959 --> 00:16:47,449
algorithm but complex algorithm third

00:16:45,350 --> 00:16:50,980
objective connection tracking connection

00:16:47,449 --> 00:16:55,189
tracking is very important a lot of

00:16:50,980 --> 00:16:57,259
physical setup in IP tables use

00:16:55,189 --> 00:16:59,870
connection tracking or the filter like

00:16:57,259 --> 00:17:02,990
filter only established allow only

00:16:59,870 --> 00:17:04,490
established connection and so on so we

00:17:02,990 --> 00:17:06,439
had to support connection tracking

00:17:04,490 --> 00:17:08,390
unfortunately the connection tracking

00:17:06,439 --> 00:17:11,329
that is available in Linux is not

00:17:08,390 --> 00:17:16,280
available right now in an a BBF program

00:17:11,329 --> 00:17:19,370
because it's executed in netfilter

00:17:16,280 --> 00:17:21,740
and we don't have any help from a BPF

00:17:19,370 --> 00:17:24,919
program to get as to that information

00:17:21,740 --> 00:17:28,370
that is already kept by by Linux so we

00:17:24,919 --> 00:17:30,409
are to implement our own connection

00:17:28,370 --> 00:17:32,030
tracking so we implemented a set of

00:17:30,409 --> 00:17:34,730
models for the connection tracking of

00:17:32,030 --> 00:17:37,850
course our implementation that is done

00:17:34,730 --> 00:17:39,890
entirely in EBP F is much more primitive

00:17:37,850 --> 00:17:40,450
compared to the implementation that we

00:17:39,890 --> 00:17:43,630
have

00:17:40,450 --> 00:17:45,340
Ranelagh filter and the resulting

00:17:43,630 --> 00:17:47,890
architecture at the point

00:17:45,340 --> 00:17:50,890
with the connection tracking is even

00:17:47,890 --> 00:17:54,040
more complicated so just an overview of

00:17:50,890 --> 00:17:56,260
the overall architecture so you have the

00:17:54,040 --> 00:17:58,870
packet that comes goes into the ingress

00:17:56,260 --> 00:18:00,790
change selector and then has to cross an

00:17:58,870 --> 00:18:03,160
additional module that is the update

00:18:00,790 --> 00:18:04,990
session a labelled packet that is the

00:18:03,160 --> 00:18:06,880
connection track the first module of the

00:18:04,990 --> 00:18:09,310
connection tracking so when the packet

00:18:06,880 --> 00:18:12,040
comes into that module that model

00:18:09,310 --> 00:18:14,800
understand the packet supports the

00:18:12,040 --> 00:18:17,620
packet and then it checks whether that

00:18:14,800 --> 00:18:19,540
packet will trigger a change in the

00:18:17,620 --> 00:18:21,490
connection table so maybe it's the first

00:18:19,540 --> 00:18:22,930
packet of a new session so you have to

00:18:21,490 --> 00:18:26,860
create a new entry in the connection

00:18:22,930 --> 00:18:30,490
table second step always in that block

00:18:26,860 --> 00:18:34,990
before the English filtering chain that

00:18:30,490 --> 00:18:36,730
packet is labeled with current status of

00:18:34,990 --> 00:18:39,310
the connection so that the English chain

00:18:36,730 --> 00:18:41,680
or the forwarding channel whatever the

00:18:39,310 --> 00:18:44,920
filtering chain can actually filter the

00:18:41,680 --> 00:18:47,800
packet based on the on that state was

00:18:44,920 --> 00:18:49,810
based on the connection tracking then

00:18:47,800 --> 00:18:52,090
the packet crosses the filtering chain

00:18:49,810 --> 00:18:53,890
of course and then goes to the second

00:18:52,090 --> 00:18:56,440
block of the connection tracking which

00:18:53,890 --> 00:18:59,530
is called the store section and that

00:18:56,440 --> 00:19:02,470
block is basically storing in the

00:18:59,530 --> 00:19:05,320
connection tracking the X exact value in

00:19:02,470 --> 00:19:06,910
case the the packet changed the value of

00:19:05,320 --> 00:19:10,290
the connection tracking table because

00:19:06,910 --> 00:19:14,590
you know maybe the packet triggered the

00:19:10,290 --> 00:19:17,680
creation a new entry so this second

00:19:14,590 --> 00:19:21,190
block after the ingress and whatever is

00:19:17,680 --> 00:19:23,800
chained is just there because we update

00:19:21,190 --> 00:19:25,750
the connection trade tracking table only

00:19:23,800 --> 00:19:27,850
if the packet survives the filter

00:19:25,750 --> 00:19:30,570
otherwise if the packet doesn't survive

00:19:27,850 --> 00:19:34,480
the filter because it's being dropped by

00:19:30,570 --> 00:19:36,160
by the filter in China we don't have to

00:19:34,480 --> 00:19:38,140
update the connection tracking because

00:19:36,160 --> 00:19:40,360
the packet was discarded so that's the

00:19:38,140 --> 00:19:43,750
reason we have connection tracking

00:19:40,360 --> 00:19:47,179
split in two models one before and the

00:19:43,750 --> 00:19:49,429
other after the filtering

00:19:47,179 --> 00:19:52,839
feeder blocks because there are many

00:19:49,429 --> 00:19:55,820
filtering blocks something that is not

00:19:52,839 --> 00:19:58,249
evident from this slide is that when you

00:19:55,820 --> 00:20:01,969
enable the connection tracking in fact

00:19:58,249 --> 00:20:05,149
you enable those blocks so update and

00:20:01,969 --> 00:20:08,679
store session and so on on both input

00:20:05,149 --> 00:20:11,749
and sorry on both the ingress and egress

00:20:08,679 --> 00:20:13,820
hooks and the reason is that even if you

00:20:11,749 --> 00:20:16,009
have filter only maybe on the English

00:20:13,820 --> 00:20:18,169
traffic the connection tracking has to

00:20:16,009 --> 00:20:21,259
work on both incoming and outgoing

00:20:18,169 --> 00:20:24,619
traffic because as to complete so follow

00:20:21,259 --> 00:20:27,769
the TCP is take a state machine and so

00:20:24,619 --> 00:20:30,109
on so in any case you have to intercept

00:20:27,769 --> 00:20:34,070
also the packets that are exiting from

00:20:30,109 --> 00:20:36,529
from your host so this will introduce an

00:20:34,070 --> 00:20:38,359
additional overhead because the

00:20:36,529 --> 00:20:41,239
necessity to intercept Pakistan in

00:20:38,359 --> 00:20:46,239
ingress and egress because of the

00:20:41,239 --> 00:20:48,219
connection tracking limitation ok

00:20:46,239 --> 00:20:53,570
limitation of this approach is that

00:20:48,219 --> 00:20:56,080
obviously is not as fast and as complete

00:20:53,570 --> 00:21:00,679
as the Linux kernel implementation

00:20:56,080 --> 00:21:03,049
advantages that it works in EBP FSO that

00:21:00,679 --> 00:21:05,719
was something that we needed because

00:21:03,049 --> 00:21:07,489
there were no helpers that allow to get

00:21:05,719 --> 00:21:12,349
access to the existing connection

00:21:07,489 --> 00:21:14,989
tracking final objective is to preserve

00:21:12,349 --> 00:21:17,179
IP table syntax preserve repeatable

00:21:14,989 --> 00:21:20,059
centers very simple very stupid so if

00:21:17,179 --> 00:21:23,259
the user typed something - a input

00:21:20,059 --> 00:21:25,940
terminal - P TCP and so on we have to

00:21:23,259 --> 00:21:30,799
guarantee the user exactly the same

00:21:25,940 --> 00:21:34,070
common line syntax for our club there's

00:21:30,799 --> 00:21:37,849
a problem though the fact that we can

00:21:34,070 --> 00:21:40,700
not claim that our clone is 100%

00:21:37,849 --> 00:21:42,649
compatible with IP tables not because of

00:21:40,700 --> 00:21:44,869
the Samanta the semantics absolutely

00:21:42,649 --> 00:21:48,229
guaranteed the problem are the features

00:21:44,869 --> 00:21:51,080
we cannot support right now 100% of the

00:21:48,229 --> 00:21:55,249
features that are available in a HEPA

00:21:51,080 --> 00:21:57,349
filter AP table sorry so our solution

00:21:55,249 --> 00:22:00,669
has been to create two executable

00:21:57,349 --> 00:22:04,629
starting from IP tables

00:22:00,669 --> 00:22:08,289
was cold so we duplicated the DPF solid

00:22:04,629 --> 00:22:10,359
reputable source code and as the people

00:22:08,289 --> 00:22:12,730
independent picture over there

00:22:10,359 --> 00:22:14,980
we called the two executable one

00:22:12,730 --> 00:22:17,590
iptables the vanilla one and the other

00:22:14,980 --> 00:22:20,289
BTF iptables with exactly the same

00:22:17,590 --> 00:22:26,499
syntax so that the user can choose which

00:22:20,289 --> 00:22:29,289
one which executable as to us to call in

00:22:26,499 --> 00:22:32,320
case the command is supported VP fib

00:22:29,289 --> 00:22:36,609
tables will translate this common

00:22:32,320 --> 00:22:38,619
internally so in Lib IPTC intercept the

00:22:36,609 --> 00:22:41,080
command in instead of sending the

00:22:38,619 --> 00:22:44,230
command to the Linux kernel unit link it

00:22:41,080 --> 00:22:47,230
cause shell script that cause arrest

00:22:44,230 --> 00:22:49,149
server that an implementation detail so

00:22:47,230 --> 00:22:53,499
a server that actually implements the

00:22:49,149 --> 00:22:56,529
BBF iptables demo and that implements

00:22:53,499 --> 00:22:59,649
the control path so that it creates all

00:22:56,529 --> 00:23:03,700
the BBF programs and so on inject the

00:22:59,649 --> 00:23:06,580
programs in in the kernel so in case the

00:23:03,700 --> 00:23:10,059
common is not supported by VP fib tables

00:23:06,580 --> 00:23:14,820
at this new executable returns an error

00:23:10,059 --> 00:23:17,980
and the user can choose whether to start

00:23:14,820 --> 00:23:22,149
send a command with traditional IP

00:23:17,980 --> 00:23:24,309
tables executors so we can allow both in

00:23:22,149 --> 00:23:25,710
the same at the same time in the in the

00:23:24,309 --> 00:23:28,899
system

00:23:25,710 --> 00:23:35,289
okay performance evaluation so is it

00:23:28,899 --> 00:23:38,350
really faster or not so of course if you

00:23:35,289 --> 00:23:42,840
increase the number of rules you can see

00:23:38,350 --> 00:23:45,549
there in 7000 rules you can see that our

00:23:42,840 --> 00:23:48,970
implementation is definitely faster that

00:23:45,549 --> 00:23:52,149
I already said before it's faster to go

00:23:48,970 --> 00:23:55,230
faster than a linear search on me what

00:23:52,149 --> 00:23:58,899
is a little bit interesting here is that

00:23:55,230 --> 00:24:01,629
in fact we're losing a little bit when

00:23:58,899 --> 00:24:03,789
the number of rules is very small so

00:24:01,629 --> 00:24:06,249
when we have no rules and when we have

00:24:03,789 --> 00:24:11,159
fewer rules in the in the picture I just

00:24:06,249 --> 00:24:13,840
reported zero and one IP table is faster

00:24:11,159 --> 00:24:16,270
currently we're working on this gap

00:24:13,840 --> 00:24:19,270
so we're pretty much confident that we

00:24:16,270 --> 00:24:22,210
can reduce this gap basically there are

00:24:19,270 --> 00:24:24,760
some lookups in map that can be avoided

00:24:22,210 --> 00:24:27,400
and some optimization that we can do but

00:24:24,760 --> 00:24:31,900
the message is that in case the number

00:24:27,400 --> 00:24:34,330
of rules is limited we cannot go faster

00:24:31,900 --> 00:24:36,610
okay so I mean we are relying that

00:24:34,330 --> 00:24:39,990
basically with we probably will be

00:24:36,610 --> 00:24:43,870
aligned with iptables

00:24:39,990 --> 00:24:46,870
this is the same numbers but not on UDP

00:24:43,870 --> 00:24:49,149
traffic this is for TCP traffic so we

00:24:46,870 --> 00:24:52,990
check the number of connections that are

00:24:49,149 --> 00:24:56,020
currently being forwarded by client to a

00:24:52,990 --> 00:24:59,740
server a server is Apache so using the

00:24:56,020 --> 00:25:02,529
traditional Apache benchmark number of

00:24:59,740 --> 00:25:05,799
rules in this case is 1,000 just because

00:25:02,529 --> 00:25:08,350
we tested with 1000 you can see an

00:25:05,799 --> 00:25:11,919
advantage in our implementation vpf

00:25:08,350 --> 00:25:16,330
iptables compared to IP tables the

00:25:11,919 --> 00:25:18,340
baseline is just no rules so what we can

00:25:16,330 --> 00:25:20,500
get in term of connection per seconds

00:25:18,340 --> 00:25:22,990
when there are no rules and the two

00:25:20,500 --> 00:25:25,480
graphs refer to different page size so

00:25:22,990 --> 00:25:29,200
one is minimal page 87 bytes and the

00:25:25,480 --> 00:25:33,250
other is an original page with 11k and

00:25:29,200 --> 00:25:35,770
bytes latency latency we are always

00:25:33,250 --> 00:25:38,289
better than IP tables very simple test

00:25:35,770 --> 00:25:40,149
with two machines at being between one

00:25:38,289 --> 00:25:42,429
machine to the other and then back in

00:25:40,149 --> 00:25:46,360
order to don't have problems with the

00:25:42,429 --> 00:25:49,960
timestamp we already had a talk talking

00:25:46,360 --> 00:25:52,690
about timing okay the results confirm

00:25:49,960 --> 00:25:55,000
that we are always better than the

00:25:52,690 --> 00:25:58,600
traditional IP tables own at least from

00:25:55,000 --> 00:26:01,179
the latency perspective we are good okay

00:25:58,600 --> 00:26:03,309
future work I will skip this part

00:26:01,179 --> 00:26:08,230
because of time concerned but you have

00:26:03,309 --> 00:26:13,570
this part on the paper and on the on the

00:26:08,230 --> 00:26:16,480
slides that I have here I will move to

00:26:13,570 --> 00:26:20,799
the lesson learned so what we learn from

00:26:16,480 --> 00:26:23,620
this activity and the first thing that

00:26:20,799 --> 00:26:27,280
we learned is that we started our

00:26:23,620 --> 00:26:27,549
project by let's say a replacing IP date

00:26:27,280 --> 00:26:30,039
was

00:26:27,549 --> 00:26:32,440
because that's what we had in mind and

00:26:30,039 --> 00:26:35,710
what we wanted to do in order to

00:26:32,440 --> 00:26:39,279
validate a BBF so from our perspective

00:26:35,710 --> 00:26:42,879
the BBF is started to be good enough to

00:26:39,279 --> 00:26:44,739
implement complex application but if we

00:26:42,879 --> 00:26:48,100
change a little bit the focus and we say

00:26:44,739 --> 00:26:50,919
okay but what about if we would like to

00:26:48,100 --> 00:26:52,649
go really in production with our clone

00:26:50,919 --> 00:26:56,080
of iptables

00:26:52,649 --> 00:27:00,369
is it the right approach a king we do

00:26:56,080 --> 00:27:04,679
better than what we did so far okay then

00:27:00,369 --> 00:27:06,850
we can we can have a little bit of

00:27:04,679 --> 00:27:09,970
discussion on that and the biggest

00:27:06,850 --> 00:27:12,070
problem that we found here is that with

00:27:09,970 --> 00:27:16,359
the current architecture with the EBP F

00:27:12,070 --> 00:27:22,149
and that filter so mixing both your a

00:27:16,359 --> 00:27:25,320
sort of take one of them so you cannot

00:27:22,149 --> 00:27:28,239
mix EBP F or is hard to mix a BBF

00:27:25,320 --> 00:27:30,309
services and net filters before a bunch

00:27:28,239 --> 00:27:32,519
of reasons like we already said for the

00:27:30,309 --> 00:27:36,340
connection tracking that is not possible

00:27:32,519 --> 00:27:39,129
so for instance when we started to think

00:27:36,340 --> 00:27:43,779
about what about IP tables supporting

00:27:39,129 --> 00:27:46,179
also NAT can we use the net of IP filter

00:27:43,779 --> 00:27:49,299
so net filter or do we have to implement

00:27:46,179 --> 00:27:51,549
our own net and the answer is we have to

00:27:49,299 --> 00:27:54,309
implement our own net so we have to

00:27:51,549 --> 00:27:58,210
start from scratch implement a net in IP

00:27:54,309 --> 00:28:01,539
filter so in BPF while the net is there

00:27:58,210 --> 00:28:04,749
we cannot reduce it and the reason is

00:28:01,539 --> 00:28:09,190
mainly because there are only a few

00:28:04,749 --> 00:28:13,090
hooks available so before and after net

00:28:09,190 --> 00:28:15,489
filter there are no hooks inside net

00:28:13,090 --> 00:28:19,509
filter is set so it's not possible for

00:28:15,489 --> 00:28:22,359
us to say okay let's replace selectively

00:28:19,509 --> 00:28:24,929
a component in the filter maybe just the

00:28:22,359 --> 00:28:29,049
future in part or maybe just an odd part

00:28:24,929 --> 00:28:31,720
because we have to introduce this chain

00:28:29,049 --> 00:28:36,129
selection logics or prediction logic and

00:28:31,720 --> 00:28:38,950
and that's really an immerse the first

00:28:36,129 --> 00:28:41,440
message that would like to send here is

00:28:38,950 --> 00:28:44,409
that probably it would be nice

00:28:41,440 --> 00:28:47,110
to have a new set of hooks across all

00:28:44,409 --> 00:28:48,789
the net feature that King allowed to

00:28:47,110 --> 00:28:52,299
move from let's say a competition

00:28:48,789 --> 00:28:55,389
approach you can either choose a BBF for

00:28:52,299 --> 00:28:57,669
ornette filter but not both into a more

00:28:55,389 --> 00:29:00,190
cooperative approach where you can

00:28:57,669 --> 00:29:02,679
choose dynamically which component in

00:29:00,190 --> 00:29:05,019
that filter has to be used and natively

00:29:02,679 --> 00:29:09,639
and which other component can be maybe

00:29:05,019 --> 00:29:14,379
emulated in any BBF suffering some one

00:29:09,639 --> 00:29:17,049
of the reason we feel this may be

00:29:14,379 --> 00:29:20,169
interesting is that there is no way to

00:29:17,049 --> 00:29:22,950
get a perfect matching algorithm so

00:29:20,169 --> 00:29:26,379
there are people talking yesterday about

00:29:22,950 --> 00:29:29,139
massive number rule updates per second

00:29:26,379 --> 00:29:32,379
okay in case of our algorithm is

00:29:29,139 --> 00:29:36,100
reasonably faster but it doesn't support

00:29:32,379 --> 00:29:38,409
a very fast rule update so anyway just

00:29:36,100 --> 00:29:40,539
just to say that use cases are different

00:29:38,409 --> 00:29:43,509
and the perfect matching algorithm

00:29:40,539 --> 00:29:46,179
doesn't exist this is only on your your

00:29:43,509 --> 00:29:49,509
use case what about if you would like to

00:29:46,179 --> 00:29:52,240
implement our perfect matching algorithm

00:29:49,509 --> 00:29:54,429
okay it should be nice at that point to

00:29:52,240 --> 00:29:57,220
have a net filter with more hooks so

00:29:54,429 --> 00:29:59,889
that we can just replace that piece of

00:29:57,220 --> 00:30:03,879
the future and keep the rest as it is

00:29:59,889 --> 00:30:06,759
that is good enough okay so that's an

00:30:03,879 --> 00:30:12,059
example of more cooperative approach

00:30:06,759 --> 00:30:15,429
between the two words third message is

00:30:12,059 --> 00:30:17,740
replacing or offloading IP table so we

00:30:15,429 --> 00:30:19,750
started with our original goal let's

00:30:17,740 --> 00:30:23,019
implement a bit about the blah blah so

00:30:19,750 --> 00:30:25,779
the replacement approach but if we

00:30:23,019 --> 00:30:28,509
change a little bit our perspective and

00:30:25,779 --> 00:30:31,389
we move to this audience that is

00:30:28,509 --> 00:30:34,539
probably interested in not in EBP equity

00:30:31,389 --> 00:30:37,840
in other things we can say that probably

00:30:34,539 --> 00:30:40,120
it makes also more sense in general in

00:30:37,840 --> 00:30:44,259
order to investigate for the future it

00:30:40,120 --> 00:30:49,840
may make more sense to try to offload

00:30:44,259 --> 00:30:52,539
part of the IP table rule into a BPF

00:30:49,840 --> 00:30:54,519
program that is maybe wrong executed at

00:30:52,539 --> 00:30:55,040
the beginning of the show maybe even in

00:30:54,519 --> 00:30:57,920
the

00:30:55,040 --> 00:31:00,050
so I think about denial-of-service

00:30:57,920 --> 00:31:03,170
mitigate and so when you have to filter

00:31:00,050 --> 00:31:05,150
a lot of IP packets based on the source

00:31:03,170 --> 00:31:08,300
address or something like that so

00:31:05,150 --> 00:31:11,120
instead of replacing IP tables it makes

00:31:08,300 --> 00:31:14,390
sense also to think about offloading

00:31:11,120 --> 00:31:17,930
part of IP tables into EBP F which by

00:31:14,390 --> 00:31:19,610
the way is to my understanding in some

00:31:17,930 --> 00:31:23,810
sense similar to the approach that is

00:31:19,610 --> 00:31:29,150
taken by the BBF filter that is came to

00:31:23,810 --> 00:31:31,550
the kernel recently connection tracking

00:31:29,150 --> 00:31:33,620
is a good point that connection tracking

00:31:31,550 --> 00:31:35,540
is very important and we need more work

00:31:33,620 --> 00:31:38,390
on the connection tracking and possibly

00:31:35,540 --> 00:31:40,940
within more integration with net filter

00:31:38,390 --> 00:31:43,820
because implementing connection tracking

00:31:40,940 --> 00:31:49,130
like the one that is already there in a

00:31:43,820 --> 00:31:53,660
BBF is probably not feasible conclusion

00:31:49,130 --> 00:31:58,340
I'm here so this is our work alright in

00:31:53,660 --> 00:32:01,250
the last month probably 100% compatible

00:31:58,340 --> 00:32:04,430
version of IP tables or replacement of a

00:32:01,250 --> 00:32:06,860
be table maybe it's not good idea I

00:32:04,430 --> 00:32:08,440
reduced the first version looks more

00:32:06,860 --> 00:32:11,660
appealing

00:32:08,440 --> 00:32:15,710
ebf is good enough right now to

00:32:11,660 --> 00:32:18,320
implement rather complex matching

00:32:15,710 --> 00:32:19,760
algorithm so that's that's good also the

00:32:18,320 --> 00:32:24,290
pipeline that we can create dynamic

00:32:19,760 --> 00:32:25,940
leaking increase the performance and

00:32:24,290 --> 00:32:30,730
allow us to optimize the code

00:32:25,940 --> 00:32:34,480
dynamically a better cooperation with

00:32:30,730 --> 00:32:38,390
Linux net filter in term of hooks or

00:32:34,480 --> 00:32:42,410
helper is definitely good way to explore

00:32:38,390 --> 00:32:43,010
for the future and so on the end of the

00:32:42,410 --> 00:32:46,010
talk

00:32:43,010 --> 00:32:47,750
sorry for not having time for a demo but

00:32:46,010 --> 00:32:50,240
I have everything working on my laptop

00:32:47,750 --> 00:32:52,730
so if you will don't trust me okay you

00:32:50,240 --> 00:32:57,620
can come to my laptop I will give you

00:32:52,730 --> 00:33:01,090
the keyboard hello yeah net filter

00:32:57,620 --> 00:33:04,370
people here Erik Pablo

00:33:01,090 --> 00:33:05,450
can we are two questions only none of

00:33:04,370 --> 00:33:08,360
the new filter guys are here

00:33:05,450 --> 00:33:14,960
there's Pablo okay

00:33:08,360 --> 00:33:20,730
all right well going public okay

00:33:14,960 --> 00:33:23,670
two questions on please so first comment

00:33:20,730 --> 00:33:26,820
great talk and I agree I think custom

00:33:23,670 --> 00:33:28,650
not a custom but expanding the iptables

00:33:26,820 --> 00:33:30,360
hook such that you can run EVP have

00:33:28,650 --> 00:33:32,430
programs optionally would be the right

00:33:30,360 --> 00:33:34,950
answer in fact I would recommend that we

00:33:32,430 --> 00:33:37,740
go look and see if you can build an IP

00:33:34,950 --> 00:33:39,180
tables context for EVP F that's special

00:33:37,740 --> 00:33:40,710
to IP tables because there's a lot of

00:33:39,180 --> 00:33:42,570
very common functions that you're going

00:33:40,710 --> 00:33:43,860
to keep repeating over and over again

00:33:42,570 --> 00:33:46,980
and we might end up with an

00:33:43,860 --> 00:33:48,630
unnecessarily large set of helpers if we

00:33:46,980 --> 00:33:50,130
don't do this correctly right because

00:33:48,630 --> 00:33:53,640
you know I need that field

00:33:50,130 --> 00:33:55,200
I need that particular match so I think

00:33:53,640 --> 00:33:57,060
it would be a good thing to think about

00:33:55,200 --> 00:33:59,100
what that formal interface needs to be

00:33:57,060 --> 00:34:03,720
but that's a comment the question I had

00:33:59,100 --> 00:34:06,750
was the latency results that you saw for

00:34:03,720 --> 00:34:09,510
low counts doesn't seem to make sense to

00:34:06,750 --> 00:34:11,370
me like a BPF program where you are

00:34:09,510 --> 00:34:12,930
having to duplicate work which iptables

00:34:11,370 --> 00:34:15,930
will benefit from because it's getting

00:34:12,930 --> 00:34:17,550
pre parsed packets for low counts you

00:34:15,930 --> 00:34:19,140
should have seen higher latency is what

00:34:17,550 --> 00:34:21,300
I would have expected do you have any

00:34:19,140 --> 00:34:26,880
theory on why the latency was better

00:34:21,300 --> 00:34:28,290
everywhere no no I have to admit that

00:34:26,880 --> 00:34:30,510
there is another problem in those

00:34:28,290 --> 00:34:33,690
results so those results are a little

00:34:30,510 --> 00:34:36,450
bit higher than what I expected so

00:34:33,690 --> 00:34:39,780
having latest in a server that is close

00:34:36,450 --> 00:34:41,790
to one millisecond is too much to me so

00:34:39,780 --> 00:34:44,700
the problem is related to the fact that

00:34:41,790 --> 00:34:48,210
we made the test last the last two days

00:34:44,700 --> 00:34:50,640
I was already here and I cannot make

00:34:48,210 --> 00:34:53,520
sure that there are some strange

00:34:50,640 --> 00:34:56,070
mistakes somewhere but anyway we we

00:34:53,520 --> 00:35:00,090
tested both what software ly exactly in

00:34:56,070 --> 00:35:02,700
the same condition so to me is an

00:35:00,090 --> 00:35:07,200
indication that the latency may may be

00:35:02,700 --> 00:35:10,590
good in our in our case for the price

00:35:07,200 --> 00:35:13,170
precise number okay please wait we have

00:35:10,590 --> 00:35:15,810
to refine a worker write a scientific

00:35:13,170 --> 00:35:17,880
paper put all the stuff like a

00:35:15,810 --> 00:35:21,120
confidence interval and someone that was

00:35:17,880 --> 00:35:21,600
not person in the story so we have to

00:35:21,120 --> 00:35:24,390
make

00:35:21,600 --> 00:35:28,830
more serious workers so let's think

00:35:24,390 --> 00:35:30,300
about numbers al okay thank you a quick

00:35:28,830 --> 00:35:33,120
comment on the latency measurement so

00:35:30,300 --> 00:35:35,130
you may want to look into more advanced

00:35:33,120 --> 00:35:36,150
ways to measure it like using super nut

00:35:35,130 --> 00:35:37,980
prefer something like that because

00:35:36,150 --> 00:35:41,910
usually we're interested and latency

00:35:37,980 --> 00:35:44,730
under load not just ping latency I don't

00:35:41,910 --> 00:35:49,320
know okay I'll I'll give you a quick

00:35:44,730 --> 00:35:52,770
comment or I wanted to ask about the

00:35:49,320 --> 00:35:55,710
performance number you presented in

00:35:52,770 --> 00:35:57,960
particular what did the real set you

00:35:55,710 --> 00:36:00,750
were using for the big number of rules

00:35:57,960 --> 00:36:06,030
like ties thousands look like my point

00:36:00,750 --> 00:36:07,290
is the thing I realized when you

00:36:06,030 --> 00:36:10,350
describe the algorithm is that

00:36:07,290 --> 00:36:13,620
essentially you have to check the packet

00:36:10,350 --> 00:36:16,050
against all the rules anytime in the

00:36:13,620 --> 00:36:19,560
real life you want to arrange your rules

00:36:16,050 --> 00:36:22,890
to handle most of the packets within the

00:36:19,560 --> 00:36:26,270
first few rules so like things like

00:36:22,890 --> 00:36:29,340
local traffic you don't care about or

00:36:26,270 --> 00:36:33,120
packets in established state and so on

00:36:29,340 --> 00:36:36,270
so was your rule said some real-life

00:36:33,120 --> 00:36:40,350
rule set or just random bunch of rules

00:36:36,270 --> 00:36:43,410
okay good question so the rule was the

00:36:40,350 --> 00:36:47,000
rule set was a set of let's say fake

00:36:43,410 --> 00:36:51,750
rooms operating on IP destination source

00:36:47,000 --> 00:36:54,510
board and so on and last rule let's call

00:36:51,750 --> 00:36:56,640
it default that was a setting everything

00:36:54,510 --> 00:36:59,490
and the traffic was generated in order

00:36:56,640 --> 00:37:03,260
to match the last role okay so we're in

00:36:59,490 --> 00:37:06,570
those condition let's say not probably

00:37:03,260 --> 00:37:09,900
realistic condition but in those

00:37:06,570 --> 00:37:13,020
condition in which the last rule was was

00:37:09,900 --> 00:37:16,680
matched so probably if you have a

00:37:13,020 --> 00:37:20,100
different mix of rules like the one we

00:37:16,680 --> 00:37:22,980
said the the result may be different our

00:37:20,100 --> 00:37:25,200
problem here is that we may need the

00:37:22,980 --> 00:37:28,710
cooperation of companies in order to

00:37:25,200 --> 00:37:31,800
have a realistic rosette that's Magnum

00:37:28,710 --> 00:37:34,710
I universe it's difficult for me to ever

00:37:31,800 --> 00:37:37,619
a realistic rule set and see how things

00:37:34,710 --> 00:37:39,599
are actually working so I'm really open

00:37:37,619 --> 00:37:42,150
to any collaboration in this point in

00:37:39,599 --> 00:37:42,750
order to validate the prototype in a

00:37:42,150 --> 00:37:44,880
better way

00:37:42,750 --> 00:37:46,380
okay we you're not gonna get the penalty

00:37:44,880 --> 00:37:48,720
box so we're gonna allow one more

00:37:46,380 --> 00:37:52,140
comment question and then I'm sorry

00:37:48,720 --> 00:37:55,020
we're out of time so we do have two

00:37:52,140 --> 00:37:57,480
rooms that you can book and they're free

00:37:55,020 --> 00:37:59,430
right conference room a smaller one and

00:37:57,480 --> 00:38:05,339
a big one you can talk to full view but

00:37:59,430 --> 00:38:08,400
Rupa gets the last word we go to Nate

00:38:05,339 --> 00:38:10,650
filter guy yeah it's just a question so

00:38:08,400 --> 00:38:13,260
basically the development of IPT board

00:38:10,650 --> 00:38:15,990
is stopped in 2008 because we are now

00:38:13,260 --> 00:38:17,220
working on an F table so it will be

00:38:15,990 --> 00:38:19,589
interesting to compare the performance

00:38:17,220 --> 00:38:21,869
of the latest an F table with a decent

00:38:19,589 --> 00:38:23,369
hood set and you can even use something

00:38:21,869 --> 00:38:25,470
like flow table and when you can compare

00:38:23,369 --> 00:38:28,430
the performance so we can have an idea

00:38:25,470 --> 00:38:29,609
of what you are bringing with the system

00:38:28,430 --> 00:38:32,730
yes

00:38:29,609 --> 00:38:35,010
your computer right right so of course

00:38:32,730 --> 00:38:38,550
any table is one of the let's say

00:38:35,010 --> 00:38:41,310
competitor but I would like to stress

00:38:38,550 --> 00:38:43,200
the objective of this project at the

00:38:41,310 --> 00:38:46,470
beginning so we didn't want to create

00:38:43,200 --> 00:38:49,859
the best firewall around we just wanted

00:38:46,470 --> 00:38:51,780
to create something that was a clone of

00:38:49,859 --> 00:38:54,960
IP tables in term of syntax and

00:38:51,780 --> 00:38:57,359
semantics and so on so I'm pretty sure

00:38:54,960 --> 00:39:00,270
that there are best firewalls around

00:38:57,359 --> 00:39:03,119
best algorithm but we have to look at

00:39:00,270 --> 00:39:07,380
the entire picture so let's create a

00:39:03,119 --> 00:39:11,310
clone of IP table so that what

00:39:07,380 --> 00:39:14,130
adjustment is that yes it's useless to

00:39:11,310 --> 00:39:15,750
compare with something quite old instead

00:39:14,130 --> 00:39:18,390
of looking at what we can do the best

00:39:15,750 --> 00:39:21,089
with the current solution ear canal yes

00:39:18,390 --> 00:39:23,220
your target is currently but at the

00:39:21,089 --> 00:39:26,339
point the performance should be also

00:39:23,220 --> 00:39:28,320
checked with a better algorithm so we

00:39:26,339 --> 00:39:31,140
choose the linear bit better search

00:39:28,320 --> 00:39:33,869
because it was easier to implement

00:39:31,140 --> 00:39:36,510
probably if we move to tuple search or

00:39:33,869 --> 00:39:39,440
something similar we can get even better

00:39:36,510 --> 00:39:42,430
performance so that does so the

00:39:39,440 --> 00:39:44,829
objective was not just pure performance

00:39:42,430 --> 00:39:46,300
was just a project that was try to

00:39:44,829 --> 00:39:49,839
emulate iptables

00:39:46,300 --> 00:39:52,900
with with a BBF and then there are a lot

00:39:49,839 --> 00:39:56,349
of improvement you can do across the

00:39:52,900 --> 00:39:57,730
entire architecture okay I'm just gonna

00:39:56,349 --> 00:40:00,099
move you ask you to move off the stage

00:39:57,730 --> 00:40:03,309
just I'm sorry not to get rid of you but

00:40:00,099 --> 00:40:05,680
this plenty of time just so the other

00:40:03,309 --> 00:40:10,210
speaker can get prepared and I'll give

00:40:05,680 --> 00:40:12,160
Rupa the last word I just wanted a

00:40:10,210 --> 00:40:15,670
comment on your question about more

00:40:12,160 --> 00:40:17,890
hooks you're constrained by TC more TC

00:40:15,670 --> 00:40:21,130
hooks right basically especially

00:40:17,890 --> 00:40:23,859
implementing not outside of the kernel

00:40:21,130 --> 00:40:25,300
I think the constraint hope constraint

00:40:23,859 --> 00:40:28,150
has been raised in other context before

00:40:25,300 --> 00:40:30,910
so there is discussions going on about

00:40:28,150 --> 00:40:33,790
more hooks because just ingress and

00:40:30,910 --> 00:40:35,190
egress hook won't help you yeah I just

00:40:33,790 --> 00:40:39,660
want to let you know that there is

00:40:35,190 --> 00:40:39,660

YouTube URL: https://www.youtube.com/watch?v=Lfq9sXhNSDE


