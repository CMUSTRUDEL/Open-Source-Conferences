Title: Netdev 0x13 -  Paced Chirping   Rethinking TCP start up
Publication date: 2019-05-03
Playlist: Netdev 0x13 - Day 2 - Track 2 - Mar 21 2019
Description: 
	Joakim Misund and Bob Briscoe talk about Paced Chirping.

TCP slow start faces a dilemma: Either you take too long to ramp up or you ramp up too fast
and cause significant queuing delays.  Paced Chirping gets a flow to achieve
fast acceleration with virtually no queuing delay

The implementation extends the kernel's pacing framework to allow a congestion control
module to create "chirps" with desired characteristics. Bob describes
the implementation and how one would use the extensions.

More info:
https://netdevconf.org/0x13/news.html?talk-chirp
Captions: 
	00:00:00,030 --> 00:00:06,240
yeah works now yeah I'm use it I have to

00:00:04,080 --> 00:00:08,639
bend to the microphone

00:00:06,240 --> 00:00:11,880
my name is Yogi mitten I'm a PhD student

00:00:08,639 --> 00:00:14,370
at the University of Oslo and I have

00:00:11,880 --> 00:00:17,699
worked together together with Bob on

00:00:14,370 --> 00:00:19,590
this algorithm called paste chirping I'm

00:00:17,699 --> 00:00:23,760
not feeling well today I'm flying back

00:00:19,590 --> 00:00:26,539
to Oslo at 12 so he will do the talk and

00:00:23,760 --> 00:00:27,750
I will sit there until I have to leave

00:00:26,539 --> 00:00:29,250
yeah

00:00:27,750 --> 00:00:35,430
he doesn't know the codes I'm the only

00:00:29,250 --> 00:00:40,010
one I've seen the code yeah this

00:00:35,430 --> 00:00:40,010
position is very tedious minutes

00:00:41,660 --> 00:00:46,410
yeah so I was ill before I came here and

00:00:44,430 --> 00:00:53,730
I hope that I was going to get better

00:00:46,410 --> 00:00:57,780
but I'm getting worse he's always

00:00:53,730 --> 00:01:06,720
feeling fatigued and you know keep going

00:00:57,780 --> 00:01:12,330
so let's try and do this so this is a

00:01:06,720 --> 00:01:13,610
way to improve the startup of TCP even

00:01:12,330 --> 00:01:16,650
though I'm giving this talk it's not

00:01:13,610 --> 00:01:20,880
directly related to the last talk this

00:01:16,650 --> 00:01:23,850
is about wall for all TTP's so it's not

00:01:20,880 --> 00:01:26,700
just about l4s it's a delay based system

00:01:23,850 --> 00:01:30,060
doesn't use ecn although it could use

00:01:26,700 --> 00:01:32,280
ECM to improve it in the future so I

00:01:30,060 --> 00:01:34,110
just need to make that context switch

00:01:32,280 --> 00:01:36,350
because you've just seen me talking

00:01:34,110 --> 00:01:39,450
about something else right

00:01:36,350 --> 00:01:41,040
having said that because we're

00:01:39,450 --> 00:01:44,399
interested in thisi TCP most of our

00:01:41,040 --> 00:01:48,329
testing has been with DC TCP in for a

00:01:44,399 --> 00:01:50,729
datacenter type scenario and for stuff

00:01:48,329 --> 00:01:53,579
like that and T to be program so on but

00:01:50,729 --> 00:01:55,439
it is intended to be for all and T to be

00:01:53,579 --> 00:01:57,990
and in fact yo Keem has been using this

00:01:55,439 --> 00:02:02,780
on his laptop just all the time you know

00:01:57,990 --> 00:02:02,780
it's and the codes available so

00:02:03,090 --> 00:02:08,849
I hope everyone here knows what tcp

00:02:05,579 --> 00:02:10,860
slow-start is but essentially it's a

00:02:08,849 --> 00:02:12,780
it's a trade off the point here is a

00:02:10,860 --> 00:02:14,099
trade-off between how fast you

00:02:12,780 --> 00:02:19,920
accelerate and how much you overshoot

00:02:14,099 --> 00:02:22,319
and what pace chirping does is break

00:02:19,920 --> 00:02:27,349
that dilemma it gets you out of that

00:02:22,319 --> 00:02:30,209
dilemma so you can get up to speed

00:02:27,349 --> 00:02:33,150
faster and faster as as link rates

00:02:30,209 --> 00:02:42,060
increase without having to overshoot

00:02:33,150 --> 00:02:48,500
anymore and the there is another problem

00:02:42,060 --> 00:02:52,830
that this slide shows which is that in a

00:02:48,500 --> 00:02:56,720
shallow buffered or low ecn threshold

00:02:52,830 --> 00:03:01,140
environment it's very difficult to stop

00:02:56,720 --> 00:03:05,459
tcp or stop the slow start hitting the

00:03:01,140 --> 00:03:09,030
ecn threshold before you get up to speed

00:03:05,459 --> 00:03:10,410
and so what tends to happen is here you

00:03:09,030 --> 00:03:13,370
come out of slow start early and then

00:03:10,410 --> 00:03:15,390
you start an additive increase and

00:03:13,370 --> 00:03:18,359
similarly when you've already got one

00:03:15,390 --> 00:03:20,400
flow in a bit later another you know

00:03:18,359 --> 00:03:21,780
this this is sort of what kind of second

00:03:20,400 --> 00:03:25,859
thing you've got a German another flow

00:03:21,780 --> 00:03:29,069
comes in it hits the threshold because

00:03:25,859 --> 00:03:30,750
the other flow is already in there and

00:03:29,069 --> 00:03:32,310
it has to do an additive increase to

00:03:30,750 --> 00:03:39,600
come in rather than the slow start to

00:03:32,310 --> 00:03:42,060
come in and so yeah then you've also got

00:03:39,600 --> 00:03:44,069
yeah these are about the problem not

00:03:42,060 --> 00:03:47,310
this is without pace chirping you've

00:03:44,069 --> 00:03:49,560
also got the problem here where the slow

00:03:47,310 --> 00:03:53,850
start causes spikes of queuing delay so

00:03:49,560 --> 00:03:56,459
you've got a potentially nice actually

00:03:53,850 --> 00:04:00,359
it's a real shame that dave has walked

00:03:56,459 --> 00:04:03,359
out because he could use this as well in

00:04:00,359 --> 00:04:05,069
in what he's doing but anyway I just

00:04:03,359 --> 00:04:07,409
noticed

00:04:05,069 --> 00:04:09,599
so you got so you've got low delay in

00:04:07,409 --> 00:04:11,549
general but you're it's your slow starts

00:04:09,599 --> 00:04:14,519
that are really causing those high

00:04:11,549 --> 00:04:17,009
percentiles of you know it's all those

00:04:14,519 --> 00:04:22,889
spikes from new flows coming in that are

00:04:17,009 --> 00:04:25,320
causing your delay problem so what pace

00:04:22,889 --> 00:04:29,789
chirping does some of you may know the

00:04:25,320 --> 00:04:34,789
toolpath chirp it's it's a it's a way to

00:04:29,789 --> 00:04:37,919
test the capacity of a other path and

00:04:34,789 --> 00:04:41,570
we're using these chirps to estimate the

00:04:37,919 --> 00:04:45,120
capacity as the flow is accelerating

00:04:41,570 --> 00:04:46,770
it's it's not only useful at a flow

00:04:45,120 --> 00:04:48,570
start it's obviously also useful when

00:04:46,770 --> 00:04:50,580
you do a slow start after an idle or

00:04:48,570 --> 00:04:53,430
instead of a slow start after an idle

00:04:50,580 --> 00:04:59,160
and we've also been experimenting on

00:04:53,430 --> 00:05:00,960
using it when you detect that you could

00:04:59,160 --> 00:05:03,349
go faster while you're in congestion

00:05:00,960 --> 00:05:07,979
avoidance as well

00:05:03,349 --> 00:05:09,479
it's delay based actually you say

00:05:07,979 --> 00:05:11,130
primarily delay based in your slide but

00:05:09,479 --> 00:05:16,440
its delay based there's no primarily

00:05:11,130 --> 00:05:21,389
about it yeah and it's not just for l4s

00:05:16,440 --> 00:05:25,110
as I said at the start and and really

00:05:21,389 --> 00:05:26,760
the idea is that it's to become a closed

00:05:25,110 --> 00:05:28,400
loop startup algorithm because at the

00:05:26,760 --> 00:05:32,190
moment we have an algorithm that's just

00:05:28,400 --> 00:05:33,810
hard coded this is how you start until

00:05:32,190 --> 00:05:36,150
you find the top and it's got no

00:05:33,810 --> 00:05:37,710
information it's running blind until you

00:05:36,150 --> 00:05:38,940
get to the top where is what this is

00:05:37,710 --> 00:05:40,610
trying to do is get information as

00:05:38,940 --> 00:05:43,699
quickly as possible

00:05:40,610 --> 00:05:46,710
you know preffer in the first round to

00:05:43,699 --> 00:05:51,449
find where you think the top is but with

00:05:46,710 --> 00:05:53,729
a very noisy estimate because as we're

00:05:51,449 --> 00:05:59,550
getting faster they're exponential

00:05:53,729 --> 00:06:03,270
increase of slowstar is taking more and

00:05:59,550 --> 00:06:06,389
more round-trip times to get up to speed

00:06:03,270 --> 00:06:07,830
and so the old around trip times the

00:06:06,389 --> 00:06:09,630
informations become stale anyway so

00:06:07,830 --> 00:06:11,699
there wasn't any point doing them what

00:06:09,630 --> 00:06:15,150
you want is to get information in the

00:06:11,699 --> 00:06:16,860
most recent round tip time and get up

00:06:15,150 --> 00:06:18,300
there very quickly there's no point

00:06:16,860 --> 00:06:26,509
having done all that stuff in the

00:06:18,300 --> 00:06:30,300
passed by the time you get to the top so

00:06:26,509 --> 00:06:32,430
what is a chirp it's a group of packets

00:06:30,300 --> 00:06:35,159
sent at an increasing rate the name

00:06:32,430 --> 00:06:37,680
comes from Radio where you're scanning

00:06:35,159 --> 00:06:42,210
the frequencies and it's realized by a

00:06:37,680 --> 00:06:47,069
decreasing into packet gap do correct me

00:06:42,210 --> 00:06:49,590
if I say anything wrong you you're

00:06:47,069 --> 00:06:50,940
aiming for an average packet gap from

00:06:49,590 --> 00:06:52,949
your previous estimates of where you

00:06:50,940 --> 00:06:55,080
think the rate is and you're you're

00:06:52,949 --> 00:06:58,740
scanning around that rate on a per

00:06:55,080 --> 00:07:00,990
packet basis so you're testing in this

00:06:58,740 --> 00:07:05,090
case with a 16 packet you're testing 15

00:07:00,990 --> 00:07:10,490
rates with one rate between each packet

00:07:05,090 --> 00:07:14,969
and you look at the extreme coming back

00:07:10,490 --> 00:07:20,340
to see when the gaps you're putting into

00:07:14,969 --> 00:07:24,719
the front become stretched out which

00:07:20,340 --> 00:07:27,690
means you got a picture over here but

00:07:24,719 --> 00:07:29,580
essentially the extreme has that same in

00:07:27,690 --> 00:07:31,889
two packet gap up to a point and then it

00:07:29,580 --> 00:07:34,080
flattens out which shows that the the

00:07:31,889 --> 00:07:35,130
available capacity of the link can't get

00:07:34,080 --> 00:07:37,080
better than that

00:07:35,130 --> 00:07:40,069
so it's much better than packet pair

00:07:37,080 --> 00:07:43,830
that's why it's using the pasture tool

00:07:40,069 --> 00:07:52,620
and you can you can vary the geometry

00:07:43,830 --> 00:07:58,800
and everything of it right so pace to

00:07:52,620 --> 00:08:03,629
chirping is about taking that church

00:07:58,800 --> 00:08:06,870
idea and testing multiple places across

00:08:03,629 --> 00:08:09,449
the round-trip time looking for other

00:08:06,870 --> 00:08:14,879
traffic and trying to find the available

00:08:09,449 --> 00:08:16,529
capacity and you have these guard

00:08:14,879 --> 00:08:19,319
intervals between the chirps so each

00:08:16,529 --> 00:08:21,120
each rectangle here represents in with a

00:08:19,319 --> 00:08:23,639
16 in it represents one of these 16

00:08:21,120 --> 00:08:26,639
packet chirps I know this is a a

00:08:23,639 --> 00:08:30,530
packager and so on and so what we're

00:08:26,639 --> 00:08:35,840
doing instead of increasing the window

00:08:30,530 --> 00:08:38,510
in any in the paced way we're doing this

00:08:35,840 --> 00:08:40,520
this chirping and then pacing the chirps

00:08:38,510 --> 00:08:43,130
that we're treating the chirps as units

00:08:40,520 --> 00:08:46,010
and the reason we're pacing the chirps

00:08:43,130 --> 00:08:50,180
is that guard interval allows the queue

00:08:46,010 --> 00:08:57,620
to relax so you pump it and then relax

00:08:50,180 --> 00:08:59,000
and it then give and then you pump it

00:08:57,620 --> 00:09:00,800
again and relax pump it again relax all

00:08:59,000 --> 00:09:02,600
it within a round-trip time you've not

00:09:00,800 --> 00:09:04,430
yet got any acts of what you just did

00:09:02,600 --> 00:09:06,530
but you're assuming you might have been

00:09:04,430 --> 00:09:08,420
wrong so that's why you've been relaxing

00:09:06,530 --> 00:09:11,570
it because you don't know whether you

00:09:08,420 --> 00:09:13,100
were right and then when you get all the

00:09:11,570 --> 00:09:15,560
information back in the next round

00:09:13,100 --> 00:09:17,390
you've got a better estimate and you can

00:09:15,560 --> 00:09:18,740
start putting your church closer

00:09:17,390 --> 00:09:24,040
together with a smaller guard interval

00:09:18,740 --> 00:09:30,560
and encode that you know teams written

00:09:24,040 --> 00:09:33,110
before he was ill the guard interval we

00:09:30,560 --> 00:09:34,370
we squeeze it up depending on the

00:09:33,110 --> 00:09:36,500
variance of all the measurements you're

00:09:34,370 --> 00:09:38,060
getting so the more solid your

00:09:36,500 --> 00:09:40,070
measurement the faster you can go out

00:09:38,060 --> 00:09:44,260
because that's probably means you've got

00:09:40,070 --> 00:09:46,190
a clean straight Ethernet link and

00:09:44,260 --> 00:09:47,390
you're getting every measurement the

00:09:46,190 --> 00:09:48,920
same so you can go straight there

00:09:47,390 --> 00:09:49,640
whereas if you've got very variable

00:09:48,920 --> 00:09:51,050
measurements

00:09:49,640 --> 00:09:52,670
you've probably got other traffic there

00:09:51,050 --> 00:09:54,590
and you need to be a bit more careful or

00:09:52,670 --> 00:09:56,900
you've got a radio link or something and

00:09:54,590 --> 00:10:08,170
and so you start and taking longer to

00:09:56,900 --> 00:10:08,170
prou right anything yeah okay

00:10:08,680 --> 00:10:12,410
so there's another picture of the same

00:10:10,670 --> 00:10:13,990
thing with the chirps getting close

00:10:12,410 --> 00:10:17,330
together and then a guard interval and

00:10:13,990 --> 00:10:22,450
your sequence space is obviously moving

00:10:17,330 --> 00:10:26,320
to the right so this is what you can get

00:10:22,450 --> 00:10:29,750
looks pretty good you know straight up

00:10:26,320 --> 00:10:38,330
and that without post chirping is on the

00:10:29,750 --> 00:10:40,010
right so you've got one flow coming in

00:10:38,330 --> 00:10:42,430
straight up to the top two flows coming

00:10:40,010 --> 00:10:52,899
in nearly straight convergence

00:10:42,430 --> 00:10:55,839
and so on so I want to try and get the

00:10:52,899 --> 00:10:57,010
implementation only in a queue there's

00:10:55,839 --> 00:11:00,330
to be oh yeah of course

00:10:57,010 --> 00:11:04,390
those last plots were the throughput

00:11:00,330 --> 00:11:07,810
then the important thing is the queue

00:11:04,390 --> 00:11:09,730
instead of without you had these these

00:11:07,810 --> 00:11:11,320
pulse it you know this was slow start

00:11:09,730 --> 00:11:21,070
this is our cue

00:11:11,320 --> 00:11:23,250
now you know I think we're talking super

00:11:21,070 --> 00:11:25,930
different from what right

00:11:23,250 --> 00:11:29,020
yeah we're getting you know in that in

00:11:25,930 --> 00:11:40,050
the hundreds of microseconds cue instead

00:11:29,020 --> 00:11:40,050
of in the multi milliseconds right now

00:11:41,160 --> 00:12:04,180
yeah so yeah the code is available at

00:12:00,520 --> 00:12:08,560
this github to change to the kernel is

00:12:04,180 --> 00:12:11,860
another git hub but it's pointed to by

00:12:08,560 --> 00:12:13,630
by reading the file here so just access

00:12:11,860 --> 00:12:18,310
this and you can download the kernel

00:12:13,630 --> 00:12:20,110
look at the changes and tripe a trapping

00:12:18,310 --> 00:12:24,730
outs I mean it's not production ready

00:12:20,110 --> 00:12:27,339
yet but I hope to to make it in the

00:12:24,730 --> 00:12:31,200
future yeah

00:12:27,339 --> 00:12:34,470
so there are two to this is really

00:12:31,200 --> 00:12:34,470
really bad

00:12:38,000 --> 00:12:45,899
does this work

00:12:39,600 --> 00:12:49,350
yeah great so there are two major

00:12:45,899 --> 00:12:52,829
changes there are changes to the kernel

00:12:49,350 --> 00:12:55,920
itself to the TCP stack and changes to

00:12:52,829 --> 00:12:57,990
the dates entity species module which

00:12:55,920 --> 00:13:02,190
actually implements the page stripping

00:12:57,990 --> 00:13:05,550
logic so the logic itself is in a CC

00:13:02,190 --> 00:13:10,680
module and we made some changes to the

00:13:05,550 --> 00:13:17,790
kernel to be able to send chirps using

00:13:10,680 --> 00:13:28,500
the internal pacing framework yeah so

00:13:17,790 --> 00:13:31,019
this is a sorry this is a call graph of

00:13:28,500 --> 00:13:34,470
what's happening when page shopping is

00:13:31,019 --> 00:13:38,430
run you have the congestion for module

00:13:34,470 --> 00:13:42,600
in the top rights and you have the TCP

00:13:38,430 --> 00:13:45,170
stack in the bottom and on the left so

00:13:42,600 --> 00:13:47,310
this is module indicates to the

00:13:45,170 --> 00:13:50,940
dismissed act that it wants to share per

00:13:47,310 --> 00:13:53,190
se is chirping and then when the TCP

00:13:50,940 --> 00:13:55,740
stack has some data it checks if the CC

00:13:53,190 --> 00:13:58,050
module wants to chirp and if it doesn't

00:13:55,740 --> 00:14:02,010
have an a chirp description it is it

00:13:58,050 --> 00:14:05,279
asks the conjectural module for a

00:14:02,010 --> 00:14:10,470
description through a new callback

00:14:05,279 --> 00:14:13,949
called new chirp the implementation then

00:14:10,470 --> 00:14:16,560
fills in the chirp description under

00:14:13,949 --> 00:14:22,110
turn 0 to indicate that it wants to send

00:14:16,560 --> 00:14:25,110
packets and then the TCP stack realizes

00:14:22,110 --> 00:14:29,610
the chair by introducing appropriate

00:14:25,110 --> 00:14:33,620
gaps in between packets or segments yeah

00:14:29,610 --> 00:14:37,680
that's that's the implementation and

00:14:33,620 --> 00:14:39,929
yeah my mind isn't working very well

00:14:37,680 --> 00:14:52,559
right now so

00:14:39,929 --> 00:15:00,689
I think I will just stuff there yeah

00:14:52,559 --> 00:15:03,149
he's gonna go home and get ya so the

00:15:00,689 --> 00:15:05,869
important point here is that the it uses

00:15:03,149 --> 00:15:07,860
the internal placing framework that

00:15:05,869 --> 00:15:11,309
you're charring and Eric and everyone

00:15:07,860 --> 00:15:13,589
added but instead of using it for a

00:15:11,309 --> 00:15:15,209
constant rate it's it's we've added a

00:15:13,589 --> 00:15:20,519
structure in there at the chirp

00:15:15,209 --> 00:15:23,879
structure so that you it basically goes

00:15:20,519 --> 00:15:25,290
through and tells you when when then

00:15:23,879 --> 00:15:28,410
when the next packet needs to be

00:15:25,290 --> 00:15:32,069
released which is effectively what

00:15:28,410 --> 00:15:33,660
pacing does but this is using it to put

00:15:32,069 --> 00:15:42,959
different times between the packets run

00:15:33,660 --> 00:15:45,929
the same time so and essentially that's

00:15:42,959 --> 00:15:51,029
to get information back because if you

00:15:45,929 --> 00:15:53,339
just pace and send it I know say your

00:15:51,029 --> 00:15:54,449
link is 100 maybe you don't know it is

00:15:53,339 --> 00:15:58,319
because that's the whole point of doing

00:15:54,449 --> 00:16:01,589
slow start and you pace it absolutely

00:15:58,319 --> 00:16:03,059
accurately at 90 Meg you'll get you

00:16:01,589 --> 00:16:06,029
don't know you still don't have any

00:16:03,059 --> 00:16:08,549
information as to whether you're going

00:16:06,029 --> 00:16:13,040
to going to have problems some time when

00:16:08,549 --> 00:16:19,230
you go a bit faster so the idea is is to

00:16:13,040 --> 00:16:21,689
not pay for going up so you describe it

00:16:19,230 --> 00:16:24,959
the the Thunder part what about the

00:16:21,689 --> 00:16:27,059
receiver part how you change the thing

00:16:24,959 --> 00:16:37,169
because it looks like a bit of a high

00:16:27,059 --> 00:16:43,110
start and Kubik there's no change to

00:16:37,169 --> 00:16:45,569
receive its sender only the the the this

00:16:43,110 --> 00:16:47,369
is this is where my knowledge runs out

00:16:45,569 --> 00:16:50,220
because I only discovered yesterday that

00:16:47,369 --> 00:16:51,030
yo Keem has solved the problem of July

00:16:50,220 --> 00:16:54,420
tax

00:16:51,030 --> 00:16:57,420
which I I didn't know he done I thought

00:16:54,420 --> 00:17:01,080
that was an outstanding problem but he's

00:16:57,420 --> 00:17:04,940
done a heuristic there but shouldn't be

00:17:01,080 --> 00:17:14,850
a problem here because you send at least

00:17:04,940 --> 00:17:18,500
two segments per job so I mean he it's

00:17:14,850 --> 00:17:20,970
just that the heuristic in Linux that

00:17:18,500 --> 00:17:24,210
tries to detect slow when slow start

00:17:20,970 --> 00:17:27,060
ends in the receiver can confuse you

00:17:24,210 --> 00:17:30,990
because here all right at the chirp

00:17:27,060 --> 00:17:40,020
confuse it okay okay yeah though said

00:17:30,990 --> 00:17:47,100
that I started my training yeah this is

00:17:40,020 --> 00:17:50,490
sender only you're heavily relying on

00:17:47,100 --> 00:17:52,320
the ACK spacing how do you solve the

00:17:50,490 --> 00:17:57,060
problem of ACK aggregation and

00:17:52,320 --> 00:17:58,170
multiplexing that's why at the moment

00:17:57,060 --> 00:18:03,570
we're describing this as research

00:17:58,170 --> 00:18:06,930
because what we've done what are

00:18:03,570 --> 00:18:09,510
proposing quick is to have a sender

00:18:06,930 --> 00:18:12,420
control over the over the over the act

00:18:09,510 --> 00:18:15,120
ratio for the receiver that's going to

00:18:12,420 --> 00:18:16,710
take longer to get into TCP you know but

00:18:15,120 --> 00:18:20,250
that's why this is this is research

00:18:16,710 --> 00:18:22,800
because the sort of logic of it is that

00:18:20,250 --> 00:18:24,690
if you're running a big server like you

00:18:22,800 --> 00:18:27,840
know Eric at Google or something like

00:18:24,690 --> 00:18:30,510
that the idea is that yes you don't want

00:18:27,840 --> 00:18:33,150
to be turning ax all the time but if if

00:18:30,510 --> 00:18:35,760
you can have the ax facing for the long

00:18:33,150 --> 00:18:37,530
running video staff but although all the

00:18:35,760 --> 00:18:41,120
slow starts you ask them to send more

00:18:37,530 --> 00:18:43,680
you more acts to get more information so

00:18:41,120 --> 00:18:46,830
you get sender control over that over

00:18:43,680 --> 00:18:50,180
the over the delayed act ratio of the

00:18:46,830 --> 00:18:53,670
receivers but but that's you know that's

00:18:50,180 --> 00:18:56,940
but but I meant know what the server

00:18:53,670 --> 00:18:59,220
does but access points Wi-Fi access

00:18:56,940 --> 00:19:02,160
points for example do that or when the

00:18:59,220 --> 00:19:04,140
party schedule like the packets or get

00:19:02,160 --> 00:19:09,420
get our slot on the Wi-Fi

00:19:04,140 --> 00:19:14,220
yeah so I probably should jump to your

00:19:09,420 --> 00:19:15,809
team's future work which is you know

00:19:14,220 --> 00:19:21,870
Wi-Fi and doctors and things like that

00:19:15,809 --> 00:19:24,630
he's currently try modifying the the

00:19:21,870 --> 00:19:27,150
logic inside the chirp to deal with

00:19:24,630 --> 00:19:28,679
these variable rate links because you

00:19:27,150 --> 00:19:31,590
essentially have a filtering algorithm

00:19:28,679 --> 00:19:34,320
in there to filter out the noise and I

00:19:31,590 --> 00:19:35,730
mean path does a fairly good job of that

00:19:34,320 --> 00:19:40,620
and that's that's that's what we're

00:19:35,730 --> 00:19:42,870
using at the moment to sort of and Elte

00:19:40,620 --> 00:19:44,429
similar where you've got essentially a

00:19:42,870 --> 00:19:45,510
discontinuous link this there's nothing

00:19:44,429 --> 00:19:48,360
and then does a lot and does nothing

00:19:45,510 --> 00:19:51,120
then it does a lot and so you need your

00:19:48,360 --> 00:19:53,070
church to be long enough and then you

00:19:51,120 --> 00:19:59,010
filter that in that noise out of the

00:19:53,070 --> 00:20:00,480
system yes it's as I say y'all came to

00:19:59,010 --> 00:20:03,090
using it day to day and mostly over

00:20:00,480 --> 00:20:04,650
Wi-Fi and it seems to work but we

00:20:03,090 --> 00:20:08,250
haven't done the full meter you know

00:20:04,650 --> 00:20:10,200
instrumentation of it over Wi-Fi would

00:20:08,250 --> 00:20:13,309
we've just you know started on Ethernet

00:20:10,200 --> 00:20:16,650
what we wanted to bring it here because

00:20:13,309 --> 00:20:19,080
this is this is an area that looks like

00:20:16,650 --> 00:20:20,340
it's got a lot of potential and we

00:20:19,080 --> 00:20:22,590
thought other people might want to try

00:20:20,340 --> 00:20:25,410
and be you know get together a bunch of

00:20:22,590 --> 00:20:26,880
people to work on it together but

00:20:25,410 --> 00:20:29,460
bearing in mind that your Keens got to

00:20:26,880 --> 00:20:34,710
get a PhD out of it so he wants to do

00:20:29,460 --> 00:20:38,640
something novel as well you know okay

00:20:34,710 --> 00:20:41,640
I just go back one that's how you use it

00:20:38,640 --> 00:20:51,059
by the way which is exactly what I was

00:20:41,640 --> 00:20:53,570
just saying so at the point any more

00:20:51,059 --> 00:20:53,570
questions

00:21:00,600 --> 00:21:04,639
so take mine okay

00:21:15,660 --> 00:21:22,450
yeah so have you actually tested this in

00:21:19,240 --> 00:21:24,100
the more live environment where the

00:21:22,450 --> 00:21:28,030
bottom that gives actually shared with

00:21:24,100 --> 00:21:33,130
other flows that actually yeah so that's

00:21:28,030 --> 00:21:35,020
that's the whole point the the the

00:21:33,130 --> 00:21:38,560
reason for to using these chirps is that

00:21:35,020 --> 00:21:40,420
and yes is the answer to that and the

00:21:38,560 --> 00:21:46,660
reason for using chirps rather than just

00:21:40,420 --> 00:21:51,460
say a microburst is that they as they

00:21:46,660 --> 00:21:53,530
get closer together they sort of if

00:21:51,460 --> 00:21:55,720
there's other traffic there the packets

00:21:53,530 --> 00:21:57,250
sort of run between the other packets

00:21:55,720 --> 00:21:58,690
and until they get close enough together

00:21:57,250 --> 00:22:01,680
and then they start building at a queue

00:21:58,690 --> 00:22:05,110
so a church finds the available capacity

00:22:01,680 --> 00:22:06,490
whereas something like a microburst all

00:22:05,110 --> 00:22:07,690
the packets go in between the other

00:22:06,490 --> 00:22:10,510
packets and it gives you the actual

00:22:07,690 --> 00:22:11,590
competitive the capacity without taking

00:22:10,510 --> 00:22:13,030
account of the traffic and that's why

00:22:11,590 --> 00:22:18,360
we're using chirps in the first place

00:22:13,030 --> 00:22:21,100
and that seems to work very well ok so

00:22:18,360 --> 00:22:24,130
that's actually one comment and then the

00:22:21,100 --> 00:22:25,720
other one is actually you know wiris the

00:22:24,130 --> 00:22:28,300
environment like you know the bandwidth

00:22:25,720 --> 00:22:31,000
changes I radically yeah so in that case

00:22:28,300 --> 00:22:35,140
it seems like you know you can actually

00:22:31,000 --> 00:22:38,080
cause like what is it like immature

00:22:35,140 --> 00:22:42,850
you know bandwidth estimation in some

00:22:38,080 --> 00:22:44,920
cases and stuff so not sure if so yeah I

00:22:42,850 --> 00:22:47,890
mean there's a lot more to do on on on

00:22:44,920 --> 00:22:51,850
radio environments the the intuition

00:22:47,890 --> 00:22:53,680
there is that if you're using slow start

00:22:51,850 --> 00:22:56,460
what I said that there's start you've

00:22:53,680 --> 00:22:59,050
done all these you know lower-level

00:22:56,460 --> 00:23:01,390
earlier rounds that gave you no

00:22:59,050 --> 00:23:04,180
information so what we're trying to do

00:23:01,390 --> 00:23:06,790
is get recent information and then

00:23:04,180 --> 00:23:09,400
rather than going straight to that we go

00:23:06,790 --> 00:23:11,230
near to it and then get better

00:23:09,400 --> 00:23:13,540
information and go nearer to it and so

00:23:11,230 --> 00:23:15,400
the information we're getting is in one

00:23:13,540 --> 00:23:19,930
or two rounds so it's much more recent

00:23:15,400 --> 00:23:21,990
less stale information about what the

00:23:19,930 --> 00:23:25,180
rate is so we can get there more quickly

00:23:21,990 --> 00:23:26,260
that's that's the intuition and it's

00:23:25,180 --> 00:23:29,980
sort of

00:23:26,260 --> 00:23:32,230
you know it's working so the intuition

00:23:29,980 --> 00:23:34,360
looks correct which is why we want other

00:23:32,230 --> 00:23:36,610
people to to work with us there's no way

00:23:34,360 --> 00:23:42,179
that this is you know ready for

00:23:36,610 --> 00:23:42,179
primetime yet but it seems seems cool

00:23:49,650 --> 00:23:54,450
I guess that's the other context switch

00:23:53,010 --> 00:23:56,850
from the last talk the last talk was

00:23:54,450 --> 00:23:59,790
much more you know years of research on

00:23:56,850 --> 00:24:01,559
it this is like yo Kim's master's

00:23:59,790 --> 00:24:04,460
project looked convincing and now he's

00:24:01,559 --> 00:24:04,460
doing a PhD on it

00:24:11,700 --> 00:24:14,700
okay

00:24:18,500 --> 00:24:28,400
where are we now in terms of brakes and

00:24:21,990 --> 00:24:28,400

YouTube URL: https://www.youtube.com/watch?v=UCUtudQ33Pc


