Title: TCP-BPF: Programmatically tuning TCP behavior through BPF
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 2 - Nov 09 2017
Description: 
	Speaker: Lawrence Brakmo
Friday November 09th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?brakmo-tcpbpf-talk
Captions: 
	00:00:01,929 --> 00:00:06,780
we're getting started

00:00:03,640 --> 00:00:06,780
[Music]

00:00:24,710 --> 00:00:31,130
so I'm gonna be talking about TCP BPF

00:00:27,619 --> 00:00:34,770
Steven mentioned yesterday that the

00:00:31,130 --> 00:00:40,680
driving force for his work with X Nattie

00:00:34,770 --> 00:00:42,570
aim was to be able to work with x DP the

00:00:40,680 --> 00:00:45,180
driving force for this project was an

00:00:42,570 --> 00:00:48,600
excuse to be able to use a really cool

00:00:45,180 --> 00:00:50,490
logo for BPF right I guess that's all I

00:00:48,600 --> 00:00:54,960
wanted to do and without working with

00:00:50,490 --> 00:00:58,200
TCP you know I came up with the TCP vpf

00:00:54,960 --> 00:01:01,850
project so the main goal the project was

00:00:58,200 --> 00:01:05,460
achieve really early on have a cool logo

00:01:01,850 --> 00:01:06,259
the second part took a little more time

00:01:05,460 --> 00:01:10,409
than that

00:01:06,259 --> 00:01:13,200
so we networked in and with TCP we have

00:01:10,409 --> 00:01:15,229
a lot of parameters that we can set so

00:01:13,200 --> 00:01:18,960
for example the buffer size is in TCP

00:01:15,229 --> 00:01:21,240
right if the buffer size is too small

00:01:18,960 --> 00:01:23,990
connections with large shorty T's will

00:01:21,240 --> 00:01:27,600
not be able to shoot the full throughput

00:01:23,990 --> 00:01:30,060
if the buffer is too large even though

00:01:27,600 --> 00:01:32,760
it's supposed to be dynamic adjustable

00:01:30,060 --> 00:01:34,200
in Linux in many instances connections

00:01:32,760 --> 00:01:37,200
with smaller titties within the data

00:01:34,200 --> 00:01:42,030
center can end up using megabytes of

00:01:37,200 --> 00:01:45,290
buffer space so the goal for these was

00:01:42,030 --> 00:01:47,820
to be able to have a mechanism to have a

00:01:45,290 --> 00:01:55,170
finer and programmatically be able to

00:01:47,820 --> 00:01:57,360
tune parameters in TCP okay so TCP BPF

00:01:55,170 --> 00:01:58,170
is a framework for be able to

00:01:57,360 --> 00:02:04,170
programmatically

00:01:58,170 --> 00:02:06,030
optimize TCP parameters for example we

00:02:04,170 --> 00:02:07,830
can use flow information to make

00:02:06,030 --> 00:02:10,530
decisions we can look at that PBA

00:02:07,830 --> 00:02:13,470
addresses the port numbers and using

00:02:10,530 --> 00:02:15,450
that for example we could tune for flows

00:02:13,470 --> 00:02:17,730
between a data center so we know the

00:02:15,450 --> 00:02:20,069
flow is within the data center we can

00:02:17,730 --> 00:02:22,680
decide to force and use small buffers so

00:02:20,069 --> 00:02:25,139
they cannot grow on their own we can

00:02:22,680 --> 00:02:27,359
also set up a small Xin RTO so rather

00:02:25,139 --> 00:02:28,740
than having to wait one second if the

00:02:27,359 --> 00:02:30,990
sim packet is lost

00:02:28,740 --> 00:02:32,970
which was meted you know we could just

00:02:30,990 --> 00:02:35,010
wait ten milliseconds we know it should

00:02:32,970 --> 00:02:37,650
get there much faster than that in a

00:02:35,010 --> 00:02:40,470
data center and we could also clamp the

00:02:37,650 --> 00:02:43,050
congestion window because you know we

00:02:40,470 --> 00:02:44,820
know that with a hundred packets that's

00:02:43,050 --> 00:02:50,960
enough to fill the pipe within a data

00:02:44,820 --> 00:02:50,960
center similarly if through the IP

00:02:51,920 --> 00:02:59,880
address or we know we are having

00:02:56,990 --> 00:03:02,250
whatever our network flow will set the

00:02:59,880 --> 00:03:04,560
box to be large we will increase the

00:03:02,250 --> 00:03:07,580
initial congestion window maybe to be

00:03:04,560 --> 00:03:09,930
you know a hundred packets we know our

00:03:07,580 --> 00:03:11,550
network is strong you know when I'm

00:03:09,930 --> 00:03:14,250
going to a user this is like within our

00:03:11,550 --> 00:03:22,830
company and we can also set a larger

00:03:14,250 --> 00:03:27,600
receive window in addition to the flow

00:03:22,830 --> 00:03:30,300
information we can also use applications

00:03:27,600 --> 00:03:33,120
to apply BPF Maps to make decisions such

00:03:30,300 --> 00:03:36,240
as vpf prefix maps so we have

00:03:33,120 --> 00:03:39,180
information about how IP addresses map

00:03:36,240 --> 00:03:44,220
to geographic locations we can use that

00:03:39,180 --> 00:03:45,600
in our programs to make decisions and we

00:03:44,220 --> 00:03:48,240
can make rules that apply to whole

00:03:45,600 --> 00:03:50,910
organization much easier because we can

00:03:48,240 --> 00:03:54,810
have a sip program to make decisions as

00:03:50,910 --> 00:03:59,760
opposed to you know having to happen

00:03:54,810 --> 00:04:01,050
data center rules with a peer route we

00:03:59,760 --> 00:04:03,120
also don't need to modify that the

00:04:01,050 --> 00:04:04,710
applications or the libraries this is

00:04:03,120 --> 00:04:06,990
going to be a separate vpf program that

00:04:04,710 --> 00:04:13,860
we can load and make things like that so

00:04:06,990 --> 00:04:15,900
it's a lot easier to change policies so

00:04:13,860 --> 00:04:17,250
what are the alternatives you know for a

00:04:15,900 --> 00:04:20,340
lot of these we can use the second

00:04:17,250 --> 00:04:22,680
option to set parameters you know like

00:04:20,340 --> 00:04:23,940
buffer sizes the drawback is that we

00:04:22,680 --> 00:04:27,090
need to modify the application sort the

00:04:23,940 --> 00:04:28,680
libraries and typically the people doing

00:04:27,090 --> 00:04:30,660
those applications or libraries are not

00:04:28,680 --> 00:04:32,700
necessarily networking experts they may

00:04:30,660 --> 00:04:35,850
not know what is the best thing to do or

00:04:32,700 --> 00:04:37,800
even the conditions on the information

00:04:35,850 --> 00:04:38,970
may change with time and then you need

00:04:37,800 --> 00:04:41,250
to change the libraries or the

00:04:38,970 --> 00:04:42,569
applications which is a lot harder and

00:04:41,250 --> 00:04:43,949
also the policy started

00:04:42,569 --> 00:04:47,309
application or library which is not

00:04:43,949 --> 00:04:49,800
ideal we can use is controlled but these

00:04:47,309 --> 00:04:52,080
are very course even if we use a network

00:04:49,800 --> 00:04:54,629
namespaces these are very coarse

00:04:52,080 --> 00:04:57,509
controls to the earth we can also use IP

00:04:54,629 --> 00:05:01,409
route but then the rules are more

00:04:57,509 --> 00:05:03,360
restricted okay in many instances like I

00:05:01,409 --> 00:05:06,330
mentioned before if we are using others

00:05:03,360 --> 00:05:07,979
prefixes to decide whether two hosts are

00:05:06,330 --> 00:05:10,349
in the same data center they're going to

00:05:07,979 --> 00:05:14,459
need to you know you may need to change

00:05:10,349 --> 00:05:17,339
your rules if things changed a little

00:05:14,459 --> 00:05:20,159
bit like you have now you have a new you

00:05:17,339 --> 00:05:21,659
know IP address class you know now it's

00:05:20,159 --> 00:05:28,169
not only just a prefix match but it's a

00:05:21,659 --> 00:05:29,909
little bit different so what are the

00:05:28,169 --> 00:05:34,709
users like a mission before the idea is

00:05:29,909 --> 00:05:37,050
to optimize per flow TCP parameters so

00:05:34,709 --> 00:05:38,939
for example within an organization we

00:05:37,050 --> 00:05:41,869
could enable new features you know like

00:05:38,939 --> 00:05:45,330
am i Facebook we may have some

00:05:41,869 --> 00:05:46,860
experimental TCP header options and we

00:05:45,330 --> 00:05:52,169
only enable them if we're talking to

00:05:46,860 --> 00:05:54,180
within our own machines so typically in

00:05:52,169 --> 00:05:56,459
the past you know what we had to do is

00:05:54,180 --> 00:05:57,749
in the kernel we put some rules to

00:05:56,459 --> 00:05:59,579
determine whether we're talking to

00:05:57,749 --> 00:06:01,019
somebody internally and then this rule

00:05:59,579 --> 00:06:04,019
could change and then we would not be

00:06:01,019 --> 00:06:05,789
able to upstream some things because you

00:06:04,019 --> 00:06:08,490
know they are related to these changes

00:06:05,789 --> 00:06:10,680
with this maybe PAF is totally separate

00:06:08,490 --> 00:06:13,079
you know it's a VPS program that can

00:06:10,680 --> 00:06:15,569
make these decisions and the kernel will

00:06:13,079 --> 00:06:17,369
just query the BPF program are we you

00:06:15,569 --> 00:06:20,089
know is this an internal connection yes

00:06:17,369 --> 00:06:22,619
okay I'm going to do these other things

00:06:20,089 --> 00:06:24,149
you know for external traffic we will

00:06:22,619 --> 00:06:27,059
change parameters in user congestion

00:06:24,149 --> 00:06:29,999
window and can also be used for

00:06:27,059 --> 00:06:32,699
experimenting you know like the same

00:06:29,999 --> 00:06:35,369
with an inoculation window with these

00:06:32,699 --> 00:06:38,490
TTP vpf programs we could do experiments

00:06:35,369 --> 00:06:40,589
where dynamically we'll learn what are

00:06:38,490 --> 00:06:42,839
the best initial window based on subnet

00:06:40,589 --> 00:06:44,610
information and we could possibly also

00:06:42,839 --> 00:06:46,439
collect information about the

00:06:44,610 --> 00:06:48,689
performance of the connection to

00:06:46,439 --> 00:06:51,300
fine-tune it to the side you know this

00:06:48,689 --> 00:06:54,120
is the right value we are having to wait

00:06:51,300 --> 00:06:56,190
you know collect data analyze it in user

00:06:54,120 --> 00:07:02,670
space and then make decisions you could

00:06:56,190 --> 00:07:03,630
be done within the kernel so now I'm

00:07:02,670 --> 00:07:06,630
going to talk a little bit about the

00:07:03,630 --> 00:07:09,690
internals of TCP BPF you know TCP BPM is

00:07:06,630 --> 00:07:12,840
a new BPF type program and I like unlike

00:07:09,690 --> 00:07:15,270
most existing VPS programs that are

00:07:12,840 --> 00:07:16,890
usually called from one entry point the

00:07:15,270 --> 00:07:20,910
same program is called from many places

00:07:16,890 --> 00:07:25,800
within the network stack therefore we

00:07:20,910 --> 00:07:28,080
use an up field to specify either that a

00:07:25,800 --> 00:07:30,270
value is desire when it's being called

00:07:28,080 --> 00:07:33,300
so for example we want to know the

00:07:30,270 --> 00:07:36,570
initial time up to using us when we're

00:07:33,300 --> 00:07:39,720
sending us in RTO for a sim packet for

00:07:36,570 --> 00:07:43,310
at for its RTO or we may want to get an

00:07:39,720 --> 00:07:46,770
initial receive window or whether this

00:07:43,310 --> 00:07:49,290
connection it needs to you CCN so for

00:07:46,770 --> 00:07:50,820
example we're using DC tcp when we send

00:07:49,290 --> 00:07:53,370
a syn packet we need to know whether we

00:07:50,820 --> 00:07:56,490
see and should be an error or not or for

00:07:53,370 --> 00:08:01,080
example what I call the base RTT and

00:07:56,490 --> 00:08:04,410
this is an RTT value that is a sensible

00:08:01,080 --> 00:08:05,700
number where we get full throughput but

00:08:04,410 --> 00:08:08,640
we don't have what knock on just in the

00:08:05,700 --> 00:08:11,280
network so for example within a data

00:08:08,640 --> 00:08:13,890
center where the RTT may be in the order

00:08:11,280 --> 00:08:16,320
of 20 to 40 microseconds we can set it

00:08:13,890 --> 00:08:19,050
up to eighty microseconds so this takes

00:08:16,320 --> 00:08:21,360
the value of the minner TT that is used

00:08:19,050 --> 00:08:24,960
by many delay based congestion controls

00:08:21,360 --> 00:08:27,600
like an b or b BR but because we know

00:08:24,960 --> 00:08:30,210
our environment we can just specify it

00:08:27,600 --> 00:08:32,940
we don't need to make the algorithm

00:08:30,210 --> 00:08:36,090
finder on its own we know we're in a

00:08:32,940 --> 00:08:39,570
data center we can specify it there's no

00:08:36,090 --> 00:08:43,860
need to have a learning algorithm

00:08:39,570 --> 00:08:47,250
determinate but the OP feel can also

00:08:43,860 --> 00:08:49,740
specify besides the stored value can

00:08:47,250 --> 00:08:53,960
also specify connection state or a place

00:08:49,740 --> 00:08:57,060
in the code an example is you know when

00:08:53,960 --> 00:09:00,050
we're initially 8 initialization a

00:08:57,060 --> 00:09:02,430
connection you know in TCP connect state

00:09:00,050 --> 00:09:05,040
you know we can set the center receive

00:09:02,430 --> 00:09:08,700
buffer sizes for the connection or when

00:09:05,040 --> 00:09:09,690
the Arctic connection is established we

00:09:08,700 --> 00:09:11,930
can set

00:09:09,690 --> 00:09:14,100
window clamp or congestion algorithm and

00:09:11,930 --> 00:09:16,650
understand for the passive establishment

00:09:14,100 --> 00:09:18,240
who Cancer Center certain things and

00:09:16,650 --> 00:09:19,890
these are the ones that are supported

00:09:18,240 --> 00:09:23,810
right now but there's a lot more coming

00:09:19,890 --> 00:09:23,810
within the next month or so

00:09:24,800 --> 00:09:32,310
so BPF programs have a structure that

00:09:30,840 --> 00:09:34,140
that is passed between the colonel and

00:09:32,310 --> 00:09:36,570
the b PF program and they are to be used

00:09:34,140 --> 00:09:38,790
for this structure there's the BPS

00:09:36,570 --> 00:09:43,410
program view and there's the internal

00:09:38,790 --> 00:09:46,230
colonel view so for TCP BPF programs

00:09:43,410 --> 00:09:48,050
also known as cyclops programs the

00:09:46,230 --> 00:09:52,380
structure currently looks like this

00:09:48,050 --> 00:09:56,630
there's an app a feel for the up feel

00:09:52,380 --> 00:10:01,500
for replies either you know 32 bit or 32

00:09:56,630 --> 00:10:04,740
x 480 bit reply we also have the family

00:10:01,500 --> 00:10:10,080
the remote and local ipv4 ipv6 addresses

00:10:04,740 --> 00:10:13,080
work local and remote ports so the BPF

00:10:10,080 --> 00:10:15,810
program will just it wants to know the

00:10:13,080 --> 00:10:20,580
ipv6 address you will just access this

00:10:15,810 --> 00:10:23,430
field directly and that would be map you

00:10:20,580 --> 00:10:27,210
know directly to accessing the right

00:10:23,430 --> 00:10:29,970
socket structure there is no overhead

00:10:27,210 --> 00:10:32,340
crossover these much the instructions in

00:10:29,970 --> 00:10:35,970
the compiler when they're compiled are

00:10:32,340 --> 00:10:37,770
just directly accesses from the kernel

00:10:35,970 --> 00:10:40,200
the same structure looks like this is

00:10:37,770 --> 00:10:43,470
appointed to the socket and the app and

00:10:40,200 --> 00:10:46,770
the reply so when the BPF program wants

00:10:43,470 --> 00:10:49,260
to read the port number the same port

00:10:46,770 --> 00:10:52,530
number that is translated into a in

00:10:49,260 --> 00:10:56,330
direct access to the socket and to the

00:10:52,530 --> 00:10:56,330
right field in the TCP socket structure

00:11:02,240 --> 00:11:08,400
there's also some helper functions for

00:11:06,030 --> 00:11:11,070
set socket options and this mimic what

00:11:08,400 --> 00:11:13,560
is available as subsurf what is

00:11:11,070 --> 00:11:16,290
available for the application so to be

00:11:13,560 --> 00:11:20,880
able to to set their receive and send

00:11:16,290 --> 00:11:23,379
buffer sizes priority by placing rate to

00:11:20,880 --> 00:11:24,970
mark TCP congestion

00:11:23,379 --> 00:11:27,099
I added two new ones one is for the

00:11:24,970 --> 00:11:32,589
initial window and the other one is for

00:11:27,099 --> 00:11:34,449
the congestion window clamp and there's

00:11:32,589 --> 00:11:36,399
a helper for get up gets a corruption

00:11:34,449 --> 00:11:40,059
which right now Lucas supports

00:11:36,399 --> 00:11:42,299
congestion and I should mention that in

00:11:40,059 --> 00:11:45,399
the structure that I mentioned before

00:11:42,299 --> 00:11:47,499
where I really had this is their easy to

00:11:45,399 --> 00:11:50,679
add new ones right soak wherever we want

00:11:47,499 --> 00:11:51,879
to access from the TCP socket state we

00:11:50,679 --> 00:11:53,859
can just add it here

00:11:51,879 --> 00:12:02,189
and we just need to add the write code

00:11:53,859 --> 00:12:05,439
in the BPF translator compiler to

00:12:02,189 --> 00:12:08,169
convert the accesses to these fields to

00:12:05,439 --> 00:12:10,659
access it into the socket structure with

00:12:08,169 --> 00:12:14,220
no overhead and I do plan to our ha a

00:12:10,659 --> 00:12:14,220
lot more fields in the near future

00:12:16,739 --> 00:12:26,649
okay so how are these you so T's PPP F

00:12:22,119 --> 00:12:32,439
is a C Group D to BP f type program so

00:12:26,649 --> 00:12:34,589
it attaches to a C Group B to and for

00:12:32,439 --> 00:12:37,720
those one or two familiar with it you

00:12:34,589 --> 00:12:43,419
know we make a directory we mount a C

00:12:37,720 --> 00:12:47,049
group into it we create a specific C

00:12:43,419 --> 00:12:49,089
group to who in this case for simplicity

00:12:47,049 --> 00:12:52,179
right now I'm creating a new bash and

00:12:49,089 --> 00:12:54,579
then adding it to the C group so now I

00:12:52,179 --> 00:12:57,850
will send the runs in this shell will be

00:12:54,579 --> 00:13:03,220
running in the full C group B - so if I

00:12:57,850 --> 00:13:05,379
run net per for iperf it will be in DC

00:13:03,220 --> 00:13:07,869
group - and any VP of program that I

00:13:05,379 --> 00:13:12,539
attached to this group would apply to

00:13:07,869 --> 00:13:12,539
those connections from those programs

00:13:13,529 --> 00:13:20,259
then to load a BPF program there's a you

00:13:17,229 --> 00:13:21,970
know program called loads or cups you

00:13:20,259 --> 00:13:25,329
give it that the group and you give it

00:13:21,970 --> 00:13:30,489
the program and you know these problems

00:13:25,329 --> 00:13:33,100
are just C programs that are compiled in

00:13:30,489 --> 00:13:35,619
a specific way and in the kernel three

00:13:33,100 --> 00:13:36,730
under samples BPF there's all the

00:13:35,619 --> 00:13:39,220
existing

00:13:36,730 --> 00:13:42,910
CCP vpf programs there plus many other

00:13:39,220 --> 00:13:44,769
ones the - elf flag just makes the

00:13:42,910 --> 00:13:48,220
loading program stay in a loop and I'll

00:13:44,769 --> 00:13:51,240
put the log buffer of BPF so that if you

00:13:48,220 --> 00:13:54,310
put the wagon purposes you have write

00:13:51,240 --> 00:14:00,899
print statements that will be printed

00:13:54,310 --> 00:14:05,139
here after you know in this program here

00:14:00,899 --> 00:14:07,750
and to remove a PBS program you you know

00:14:05,139 --> 00:14:16,690
you just specify the - our flag and the

00:14:07,750 --> 00:14:19,050
C group so let's look at an example C so

00:14:16,690 --> 00:14:22,149
this is an example - tuning for

00:14:19,050 --> 00:14:24,399
connections within a data center okay so

00:14:22,149 --> 00:14:30,430
this specifies the type of BPF program

00:14:24,399 --> 00:14:33,370
is a sacrum and we are passing it you

00:14:30,430 --> 00:14:34,930
know the destructor that I showed you

00:14:33,370 --> 00:14:37,029
earlier on that has all the different

00:14:34,930 --> 00:14:39,130
fields and specifying that the buffer

00:14:37,029 --> 00:14:41,889
size for connection within a data center

00:14:39,130 --> 00:14:44,920
the buffer size would be 150 thousand

00:14:41,889 --> 00:14:47,649
bytes the initial timeout for the scene

00:14:44,920 --> 00:14:49,480
would be 10 milliseconds the congestion

00:14:47,649 --> 00:14:51,310
window clamp would be a hundred so a

00:14:49,480 --> 00:14:54,850
hundred packet doesn't have to achieve

00:14:51,310 --> 00:14:56,529
ten gigabits per second and here what

00:14:54,850 --> 00:14:58,690
I'm doing here just checking that the

00:14:56,529 --> 00:15:01,480
first five point five bites of the Apple

00:14:58,690 --> 00:15:04,000
six addresses are the same and in this

00:15:01,480 --> 00:15:07,449
scenario this happens it means that both

00:15:04,000 --> 00:15:14,980
hosts are in the same data center and if

00:15:07,449 --> 00:15:20,800
that happens then you know I will handle

00:15:14,980 --> 00:15:22,810
the apps the call from the BPF the entry

00:15:20,800 --> 00:15:28,930
point for the BPF program right the

00:15:22,810 --> 00:15:32,680
recall so I added some calls in certain

00:15:28,930 --> 00:15:36,850
places on the TCP code path to call the

00:15:32,680 --> 00:15:39,370
BPF program so if I'm called to give a

00:15:36,850 --> 00:15:41,680
time I need timeout I will give it 10

00:15:39,370 --> 00:15:42,190
milliseconds so if the sim packet is

00:15:41,680 --> 00:15:44,019
lost

00:15:42,190 --> 00:15:47,370
it will only wait 10 milliseconds to

00:15:44,019 --> 00:15:50,259
resend it you know it would be very fast

00:15:47,370 --> 00:15:53,319
when we're trying to

00:15:50,259 --> 00:15:56,889
a call to create the active connection I

00:15:53,319 --> 00:15:58,449
will set the the buffer sizes of 150,000

00:15:56,889 --> 00:16:02,970
bytes because I do not need more than

00:15:58,449 --> 00:16:05,350
that Toshio food throughput for one flow

00:16:02,970 --> 00:16:07,749
and I could do things here like I also

00:16:05,350 --> 00:16:09,309
change the congestion control etc

00:16:07,749 --> 00:16:14,529
there's other examples like that in the

00:16:09,309 --> 00:16:16,779
samples BPF directory once the

00:16:14,529 --> 00:16:22,059
connection is established I will set up

00:16:16,779 --> 00:16:24,759
the clamp to be hundred packets so what

00:16:22,059 --> 00:16:27,669
happens when we do this so I run a small

00:16:24,759 --> 00:16:29,559
experiment for had three centers within

00:16:27,669 --> 00:16:33,639
Iraq sending you know through one

00:16:29,559 --> 00:16:36,149
receiver this piece art Angie and the

00:16:33,639 --> 00:16:39,539
art it is and the order of 20

00:16:36,149 --> 00:16:44,379
microseconds and I did

00:16:39,539 --> 00:16:48,129
so for each host I was running one

00:16:44,379 --> 00:16:50,259
stream to ten kilo byte are pieces

00:16:48,129 --> 00:16:52,509
back-to-back and a number of one

00:16:50,259 --> 00:16:55,809
megabyte are pieces and this X goes from

00:16:52,509 --> 00:16:57,549
1 2 4 8 16 you are trying to increase

00:16:55,809 --> 00:17:01,119
the amount of congestion going to the

00:16:57,549 --> 00:17:03,220
receiver so what happens when I'm doing

00:17:01,119 --> 00:17:08,199
this so this is the the rate for the 1

00:17:03,220 --> 00:17:12,309
megabyte are pieces the blue one is

00:17:08,199 --> 00:17:14,470
cubic and the red one is cubic with the

00:17:12,309 --> 00:17:16,659
PPF program running the tcp BPS program

00:17:14,470 --> 00:17:19,569
running that you know optimizer for the

00:17:16,659 --> 00:17:24,250
data center in all of these cases the

00:17:19,569 --> 00:17:27,100
the good boot or the 1 megabytes RPC is

00:17:24,250 --> 00:17:30,159
about the same however the number of

00:17:27,100 --> 00:17:35,919
retransmissions is quite different you

00:17:30,159 --> 00:17:36,970
know up to this is about 33 flows total

00:17:35,919 --> 00:17:39,850
going to one receiver

00:17:36,970 --> 00:17:42,429
there's no retransmissions when you send

00:17:39,850 --> 00:17:44,440
a tcp BPF program once i had you know i

00:17:42,429 --> 00:17:46,269
double the number of flows then I'm

00:17:44,440 --> 00:17:47,740
having with transmissions and the

00:17:46,269 --> 00:17:50,110
performance you know degress a little

00:17:47,740 --> 00:17:53,049
bit but the one megabyte RPC is the same

00:17:50,110 --> 00:17:58,960
but it's different however is the effect

00:17:53,049 --> 00:18:01,419
on the on that 10 kilobyte our pcs right

00:17:58,960 --> 00:18:03,530
so these flows are competing there are 2

00:18:01,419 --> 00:18:05,480
kilobyte RPC is competing with

00:18:03,530 --> 00:18:08,660
stream and many more megabyte are pcs

00:18:05,480 --> 00:18:11,600
and when we're using the TP BPF program

00:18:08,660 --> 00:18:13,670
then thank you'll abide achieves a much

00:18:11,600 --> 00:18:16,630
higher throughput right four times as

00:18:13,670 --> 00:18:19,190
much we're not seeing the typical

00:18:16,630 --> 00:18:23,360
unfairness we see like with cubic

00:18:19,190 --> 00:18:25,670
between different sides of our pcs so if

00:18:23,360 --> 00:18:28,130
you cared for your molar flow to achieve

00:18:25,670 --> 00:18:30,110
good troop would this is the right thing

00:18:28,130 --> 00:18:31,790
to do right and it's you remember for

00:18:30,110 --> 00:18:34,040
the previous one that will make up our

00:18:31,790 --> 00:18:36,200
pcs were about the same right very small

00:18:34,040 --> 00:18:38,180
change but because I only have like to

00:18:36,200 --> 00:18:40,400
think about our pcs in one case I

00:18:38,180 --> 00:18:42,050
achieve four times the throughput than

00:18:40,400 --> 00:18:45,940
in the other cases and as I increase the

00:18:42,050 --> 00:18:48,590
number of flows that throughput is

00:18:45,940 --> 00:18:50,240
decreasing because you know there are

00:18:48,590 --> 00:18:56,150
more flows competing so this is to be

00:18:50,240 --> 00:18:58,670
expected and this last one shows you the

00:18:56,150 --> 00:19:00,050
latencies for the you know when we're

00:18:58,670 --> 00:19:02,150
running obviously you know because the

00:19:00,050 --> 00:19:08,660
good puts are better the latest is are

00:19:02,150 --> 00:19:12,080
much lower so the the bars represent and

00:19:08,660 --> 00:19:14,870
50% latencies and the Diamonds represent

00:19:12,080 --> 00:19:17,600
the 99% latencies and you know there

00:19:14,870 --> 00:19:20,360
ever have accepted the point when we

00:19:17,600 --> 00:19:22,490
start having losses and then it just

00:19:20,360 --> 00:19:30,080
behaves the same once we cannot control

00:19:22,490 --> 00:19:35,230
the losses okay so next steps for TCP

00:19:30,080 --> 00:19:38,990
vpf the first one is to increase the

00:19:35,230 --> 00:19:42,250
number of the state that is available

00:19:38,990 --> 00:19:47,150
for the PPF program you know things like

00:19:42,250 --> 00:19:50,150
let's see for example be able to set the

00:19:47,150 --> 00:19:52,370
the class or topple service for the

00:19:50,150 --> 00:19:54,650
connection so in many instances you know

00:19:52,370 --> 00:19:59,330
like in many environments we do it

00:19:54,650 --> 00:20:01,340
through you know IP tables or xdp etc

00:19:59,330 --> 00:20:03,910
what this is doing it like when the

00:20:01,340 --> 00:20:07,280
connection is established is setting it

00:20:03,910 --> 00:20:09,500
okay and then that's it you know we read

00:20:07,280 --> 00:20:11,030
inside the TCP state is going to use

00:20:09,500 --> 00:20:14,870
that class we don't have to worry about

00:20:11,030 --> 00:20:17,330
it there's no more overhead and this is

00:20:14,870 --> 00:20:19,070
useful for example when one in DC TCP

00:20:17,330 --> 00:20:22,119
because many times we need to have two

00:20:19,070 --> 00:20:26,840
different cues for DC TCP traffic and

00:20:22,119 --> 00:20:31,519
Kubik traffic for fairness you know to

00:20:26,840 --> 00:20:34,129
do to change flow labels and to also be

00:20:31,519 --> 00:20:36,289
able to implement more interesting

00:20:34,129 --> 00:20:38,570
algorithms for changing deuteron

00:20:36,289 --> 00:20:40,730
transmissions for example so we also

00:20:38,570 --> 00:20:44,960
want to add access to congestion window

00:20:40,730 --> 00:20:47,059
as threshold our TTS etc so the tcp BPS

00:20:44,960 --> 00:20:49,970
program can use that information to make

00:20:47,059 --> 00:20:52,039
decisions you know to adapt to so how do

00:20:49,970 --> 00:20:53,809
I tell you right now more our static

00:20:52,039 --> 00:20:58,100
type decisions that are done initially

00:20:53,809 --> 00:21:01,009
based on some information but I think we

00:20:58,100 --> 00:21:03,230
can also support dynamic tuning of

00:21:01,009 --> 00:21:13,730
parameters based on the state of the

00:21:03,230 --> 00:21:16,940
flow I also want to add more entry

00:21:13,730 --> 00:21:21,320
points for TCP vpf for example for when

00:21:16,940 --> 00:21:23,840
we have an RT on a retransmit and this

00:21:21,320 --> 00:21:25,759
have lower rate of cause normally unless

00:21:23,840 --> 00:21:28,690
you're running bbr obviously because

00:21:25,759 --> 00:21:33,230
then you have more retransmits

00:21:28,690 --> 00:21:35,840
let's see for example also when we when

00:21:33,230 --> 00:21:37,249
we have a new Minard TT there could be

00:21:35,840 --> 00:21:38,869
another entry point because we can make

00:21:37,249 --> 00:21:42,379
we may want to do things differently I

00:21:38,869 --> 00:21:44,539
also when packets are receiver sent this

00:21:42,379 --> 00:21:46,820
would be a high rate of cold so what I

00:21:44,539 --> 00:21:49,820
want to do is to have a bitmap inside

00:21:46,820 --> 00:21:52,070
the TCP state to determine whether we're

00:21:49,820 --> 00:21:54,369
going to be doing the calls to the

00:21:52,070 --> 00:21:55,580
disappear program so this will be

00:21:54,369 --> 00:21:56,960
perfume

00:21:55,580 --> 00:22:00,440
and with the connection is established

00:21:56,960 --> 00:22:02,480
we could decide whether for this flow

00:22:00,440 --> 00:22:04,429
this particular flow whether we're going

00:22:02,480 --> 00:22:05,950
to enable the callback for the RT or so

00:22:04,429 --> 00:22:11,090
the Ritter's needs or for every packet

00:22:05,950 --> 00:22:13,070
so for example you can envision always

00:22:11,090 --> 00:22:14,749
doing the RTO and then being able to

00:22:13,070 --> 00:22:16,340
change floor layer or their retransmits

00:22:14,749 --> 00:22:18,320
and be able to change floor labels or

00:22:16,340 --> 00:22:20,989
change conditioner algorithm when it's

00:22:18,320 --> 00:22:23,840
behaving you know badly for example or

00:22:20,989 --> 00:22:28,369
maybe for like point 1 percent of the

00:22:23,840 --> 00:22:30,259
flows you could enable to get more code

00:22:28,369 --> 00:22:31,070
box to do analysis of the behavior of

00:22:30,259 --> 00:22:33,500
the flows but

00:22:31,070 --> 00:22:35,509
because you can control the percentage

00:22:33,500 --> 00:22:37,700
of flow they're going to be calling you

00:22:35,509 --> 00:22:40,039
can limit the overhead overall on the

00:22:37,700 --> 00:22:41,870
system for doing it and the idea is that

00:22:40,039 --> 00:22:43,519
this would be normally be disabled and

00:22:41,870 --> 00:22:45,320
when you study the connection you would

00:22:43,519 --> 00:22:46,970
determine you with the side your VPS

00:22:45,320 --> 00:22:56,090
program with the side whether it wants

00:22:46,970 --> 00:22:59,720
to enable the callbacks or not I also

00:22:56,090 --> 00:23:04,879
I'm playing with the idea to add support

00:22:59,720 --> 00:23:06,889
to for TCP header options in BPF so

00:23:04,879 --> 00:23:12,169
there would be an entry point and a BPF

00:23:06,889 --> 00:23:14,860
program will decide whether you know to

00:23:12,169 --> 00:23:17,809
add to the packet header a new option

00:23:14,860 --> 00:23:19,580
right and this could be done for example

00:23:17,809 --> 00:23:21,860
you're experimenting with a new option

00:23:19,580 --> 00:23:25,220
for a new feature you could do it in the

00:23:21,860 --> 00:23:26,899
TCP vpf program assuming of course that

00:23:25,220 --> 00:23:32,029
everything else you need to do it is

00:23:26,899 --> 00:23:33,950
accessible to the vpf program but in

00:23:32,029 --> 00:23:35,659
many environments we play with this a

00:23:33,950 --> 00:23:43,340
lot and it would be a lot cleaner for us

00:23:35,659 --> 00:23:46,330
to do it this way and finally I'm toying

00:23:43,340 --> 00:23:49,279
with the idea of having a BPF base

00:23:46,330 --> 00:23:52,580
congestion control so we create a new

00:23:49,279 --> 00:23:55,009
module for congestion control called you

00:23:52,580 --> 00:23:57,769
know TCP BPF congestion algorithm that

00:23:55,009 --> 00:24:01,460
Cori will do is we would call a BPF

00:23:57,769 --> 00:24:03,409
program to you know do whatever it needs

00:24:01,460 --> 00:24:05,840
to do and the reason for doing this is

00:24:03,409 --> 00:24:08,419
that when we are experimenting in data

00:24:05,840 --> 00:24:10,250
centers many times we have many versions

00:24:08,419 --> 00:24:11,929
of the kernel so it's not feasible to

00:24:10,250 --> 00:24:13,009
have modules you know that that will go

00:24:11,929 --> 00:24:15,379
for the coordinate because we had just

00:24:13,009 --> 00:24:18,710
too many of those doing it would be PFE

00:24:15,379 --> 00:24:21,379
would allow to experiment by changing

00:24:18,710 --> 00:24:24,679
the parameters testing ideas in a

00:24:21,379 --> 00:24:26,600
running data center and you probably

00:24:24,679 --> 00:24:28,610
would not be a tcp BPF program it would

00:24:26,600 --> 00:24:31,250
be a new type of the PF program that

00:24:28,610 --> 00:24:35,419
will probably use the same structure to

00:24:31,250 --> 00:24:38,480
share the information and I have 48

00:24:35,419 --> 00:24:48,890
seconds or quit now

00:24:38,480 --> 00:24:51,940
any questions I guess I have a more

00:24:48,890 --> 00:24:55,460
general question ma'am maybe it's too

00:24:51,940 --> 00:24:57,170
big yeah well I'm not from you I'm kind

00:24:55,460 --> 00:25:00,080
of wondering what is a real constraint

00:24:57,170 --> 00:25:03,130
of BPF here you know I mean you have

00:25:00,080 --> 00:25:05,420
access to the your noble access to the

00:25:03,130 --> 00:25:06,980
you you have a you only have the access

00:25:05,420 --> 00:25:09,230
that you're willing to give it right so

00:25:06,980 --> 00:25:12,020
for example the access I have for the IP

00:25:09,230 --> 00:25:13,130
addresses is read-only yeah and if you

00:25:12,020 --> 00:25:18,110
want to give it access to congestion

00:25:13,130 --> 00:25:20,420
window etc then you know it's up to

00:25:18,110 --> 00:25:22,400
whomever does that to decide whether it

00:25:20,420 --> 00:25:26,330
would be read-only or write read and

00:25:22,400 --> 00:25:29,690
write or what right okay so you know

00:25:26,330 --> 00:25:33,290
obviously we don't want the neo D to

00:25:29,690 --> 00:25:36,520
keep up stretches - did you stay welcome

00:25:33,290 --> 00:25:39,200
but bunch of stay may you know I guess

00:25:36,520 --> 00:25:41,120
the basic constraint is you cannot let

00:25:39,200 --> 00:25:43,280
the kernel crash right otherwise you

00:25:41,120 --> 00:25:46,610
know if the if you can put you know you

00:25:43,280 --> 00:25:48,650
can fog you can play okay buddy for

00:25:46,610 --> 00:25:50,030
example lately let's say that you had a

00:25:48,650 --> 00:25:52,460
feel for congestion window and you're

00:25:50,030 --> 00:25:55,100
allowed to be right right hmm well you

00:25:52,460 --> 00:25:57,110
know it like you could add instruction

00:25:55,100 --> 00:25:59,360
so that when they said it that you

00:25:57,110 --> 00:26:00,620
cannot be zero for example right it want

00:25:59,360 --> 00:26:02,720
to be one or morning did they talk to

00:26:00,620 --> 00:26:04,490
put zero it will actually be a one all

00:26:02,720 --> 00:26:04,880
right I mean you could force those kind

00:26:04,490 --> 00:26:07,010
of things

00:26:04,880 --> 00:26:08,120
okay and it would just it's so much in

00:26:07,010 --> 00:26:10,760
language you know it would be a nice

00:26:08,120 --> 00:26:13,430
test but it would be probably a cheap if

00:26:10,760 --> 00:26:16,070
you want to do right but I think it's

00:26:13,430 --> 00:26:18,200
kind of painful if you want to make it

00:26:16,070 --> 00:26:21,530
as very poor for you so I'm adding more

00:26:18,200 --> 00:26:24,020
more a new entry point right I don't

00:26:21,530 --> 00:26:27,860
know if there's a one catch-all where

00:26:24,020 --> 00:26:29,630
you you know I often use capable to do

00:26:27,860 --> 00:26:33,260
all kinds of crazy yesterday I said

00:26:29,630 --> 00:26:36,440
capable point and receive new TV what is

00:26:33,260 --> 00:26:38,720
it called establish whatever I catch

00:26:36,440 --> 00:26:40,370
everything right right that ecuador's in

00:26:38,720 --> 00:26:42,380
there right you can for somebody I want

00:26:40,370 --> 00:26:43,970
to set the scene RTO to be small you

00:26:42,380 --> 00:26:47,630
need to do it before you send a syn

00:26:43,970 --> 00:26:49,760
packet right okay if you want to enable

00:26:47,630 --> 00:26:52,080
ACN you have to do it before you send

00:26:49,760 --> 00:26:54,120
the same packet mmm right so it

00:26:52,080 --> 00:26:56,220
I thought like you that I if I do just

00:26:54,120 --> 00:26:58,110
when this condition establish order to

00:26:56,220 --> 00:27:00,570
do everything but I realized that no the

00:26:58,110 --> 00:27:02,730
same with the buffer sizes said said in

00:27:00,570 --> 00:27:06,149
the send buffer size needs to be done

00:27:02,730 --> 00:27:08,399
very early as opposed to there is the 48

00:27:06,149 --> 00:27:09,750
for an active connection as opposed to a

00:27:08,399 --> 00:27:10,880
passive connection that you can do it

00:27:09,750 --> 00:27:22,679
when that connection is established

00:27:10,880 --> 00:27:24,570
right so okay thanks so how many entry

00:27:22,679 --> 00:27:41,940
points are there currently right now

00:27:24,570 --> 00:27:47,370
there's well let's go back okay 1 2 3 4

00:27:41,940 --> 00:27:49,620
4 value and 1 2 3 4 the state so there's

00:27:47,370 --> 00:27:52,799
7 right now but I would like to offer

00:27:49,620 --> 00:27:55,380
like RTO you know rigorous meet and a

00:27:52,799 --> 00:27:56,159
couple of other ones I need you know

00:27:55,380 --> 00:27:58,320
they all had to be a discussion

00:27:56,159 --> 00:28:01,169
obviously we want to go crazy doing it

00:27:58,320 --> 00:28:03,389
but as long as we can make a case that

00:28:01,169 --> 00:28:08,880
it has value I think it's reasonable to

00:28:03,389 --> 00:28:11,850
do it do you have or supplying to

00:28:08,880 --> 00:28:14,070
upstream this stream already so it's or

00:28:11,850 --> 00:28:17,519
13 yeah okay the new stuff that I'm

00:28:14,070 --> 00:28:19,649
talking about for the next steps is that

00:28:17,519 --> 00:28:21,809
I'm working on that I'm hoping to have

00:28:19,649 --> 00:28:27,419
patches you know before the end of the

00:28:21,809 --> 00:28:30,559
year for most of the stuff okay I'm

00:28:27,419 --> 00:28:30,559
gonna make this the last question

00:28:33,299 --> 00:28:40,679
I guess this is a Verne of your question

00:28:38,039 --> 00:28:42,389
so I would love to use this we have all

00:28:40,679 --> 00:28:43,919
right right now Android we ship every

00:28:42,389 --> 00:28:45,600
follow script or over to a privileged

00:28:43,919 --> 00:28:48,840
process because we want to set so mark

00:28:45,600 --> 00:28:51,029
based on policy right and I can almost

00:28:48,840 --> 00:28:53,489
use your code except your code gets run

00:28:51,029 --> 00:28:57,149
after the routing lookup happens you run

00:28:53,489 --> 00:28:59,690
in TCP connect this one here runs in TCP

00:28:57,149 --> 00:29:03,149
connect and I need it in TCP v6 connect

00:28:59,690 --> 00:29:05,519
so great like now we add this to TCP v6

00:29:03,149 --> 00:29:07,139
Connect which is like you know 20 lines

00:29:05,519 --> 00:29:09,659
of code before your estate your connect

00:29:07,139 --> 00:29:11,580
CB runs and we had another hook and then

00:29:09,659 --> 00:29:13,470
we add one to UDP and then I'm happy

00:29:11,580 --> 00:29:15,960
right so but I guess the question is

00:29:13,470 --> 00:29:17,759
like you know when I guess maybe that's

00:29:15,960 --> 00:29:19,200
a question for David like at what point

00:29:17,759 --> 00:29:21,690
do we stop at what point do we need

00:29:19,200 --> 00:29:23,340
essentially a programmatic way of like

00:29:21,690 --> 00:29:25,169
expressing ok when you call this

00:29:23,340 --> 00:29:26,460
function run this hook because otherwise

00:29:25,169 --> 00:29:28,980
we're just gonna litter this stuff with

00:29:26,460 --> 00:29:34,379
hooks and eventually it's gonna be more

00:29:28,980 --> 00:29:38,940
hooks than code I don't know per

00:29:34,379 --> 00:29:42,149
function but on a name so I think here

00:29:38,940 --> 00:29:44,759
is the elegance and the art of BPF is

00:29:42,149 --> 00:29:47,100
the careful selection of words place two

00:29:44,759 --> 00:29:49,739
hooks and what helpers do we provide for

00:29:47,100 --> 00:29:53,369
BPF programs and so that's that's kind

00:29:49,739 --> 00:29:56,249
like it's kind of like just how you

00:29:53,369 --> 00:29:57,809
would design any set of api's for people

00:29:56,249 --> 00:29:59,489
to use we have to be very careful about

00:29:57,809 --> 00:30:01,519
how we choose where and when to do this

00:29:59,489 --> 00:30:05,340
and how much to expose to the programs

00:30:01,519 --> 00:30:06,629
also keep in mind that BPF is itself is

00:30:05,340 --> 00:30:08,639
meant to be a safe constrained

00:30:06,629 --> 00:30:11,070
environment so we always have all these

00:30:08,639 --> 00:30:12,929
considerations to take in when we design

00:30:11,070 --> 00:30:14,399
these things so I agree with you that

00:30:12,929 --> 00:30:15,659
things could get out of control but I

00:30:14,399 --> 00:30:16,980
can assure you there are a lot of people

00:30:15,659 --> 00:30:20,909
who are gonna push back if that every

00:30:16,980 --> 00:30:26,570
starts to happen yet which we're gonna

00:30:20,909 --> 00:30:26,570
go on the honor system so to speak ok

00:30:28,280 --> 00:30:33,660
so I like the honor system answer but

00:30:31,530 --> 00:30:35,670
like just here right like one of the

00:30:33,660 --> 00:30:37,140
points that was made is are you calling

00:30:35,670 --> 00:30:38,940
connect before the same packet is sent

00:30:37,140 --> 00:30:41,190
after the same packet isn't like this

00:30:38,940 --> 00:30:43,500
that connect can become six calls like

00:30:41,190 --> 00:30:45,450
that right because I want to intercept

00:30:43,500 --> 00:30:47,880
the use case here is send and receive

00:30:45,450 --> 00:30:49,860
but maybe I want to look at the VIP

00:30:47,880 --> 00:30:51,900
before I go and maybe I want to do port

00:30:49,860 --> 00:30:54,480
validations and I want connect

00:30:51,900 --> 00:30:56,330
preconnect posts then I want something

00:30:54,480 --> 00:30:58,770
else so I think I think the risk is

00:30:56,330 --> 00:31:01,500
going to be very real unless we go in

00:30:58,770 --> 00:31:03,510
and say present this in a more

00:31:01,500 --> 00:31:05,580
structured way I mean you had the bitmap

00:31:03,510 --> 00:31:07,200
suggestion right like that says here's a

00:31:05,580 --> 00:31:08,970
list of function calls and only these

00:31:07,200 --> 00:31:12,420
are enabled at this point but even then

00:31:08,970 --> 00:31:14,130
I yeah I know the pushback people like

00:31:12,420 --> 00:31:15,420
is one is sitting right in front of you

00:31:14,130 --> 00:31:18,000
and it's going to be like what the hell

00:31:15,420 --> 00:31:20,820
there's there's instruction hit or I

00:31:18,000 --> 00:31:23,820
cash it for this I I like it and I'm

00:31:20,820 --> 00:31:26,910
okay thankfully it's not so expensive

00:31:23,820 --> 00:31:30,060
because this is all once per flow right

00:31:26,910 --> 00:31:32,850
so yes no no I

00:31:30,060 --> 00:31:34,790
I understand it still but in that as bad

00:31:32,850 --> 00:31:40,080
as I mean if you look at the TCP

00:31:34,790 --> 00:31:41,970
instructions you know per packet but but

00:31:40,080 --> 00:31:43,680
yes no no I agree that we're gonna have

00:31:41,970 --> 00:31:44,220
to be careful okay cut you mother break

00:31:43,680 --> 00:31:47,270
please

00:31:44,220 --> 00:31:47,270
let's give him a warm

00:31:47,390 --> 00:31:51,729

YouTube URL: https://www.youtube.com/watch?v=bPw440ybp-c


