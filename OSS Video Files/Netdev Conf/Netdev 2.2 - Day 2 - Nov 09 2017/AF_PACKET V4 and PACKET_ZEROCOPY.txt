Title: AF_PACKET V4 and PACKET_ZEROCOPY
Publication date: 2018-03-15
Playlist: Netdev 2.2 - Day 2 - Nov 09 2017
Description: 
	Speaker: Magnus Karlsson, Björn Töpel, John Fastabend
Friday November 09th, 2017 
Seoul, Korea
https://www.netdevconf.org/2.2/session.html?karlsson-afpacket-talk
Captions: 
	00:00:01,550 --> 00:00:06,270
okay hi there my name is magnus carlsen

00:00:04,200 --> 00:00:09,990
I work at the Intel office in Stockholm

00:00:06,270 --> 00:00:12,510
Sweden with low level software and also

00:00:09,990 --> 00:00:15,300
with hardware actually currently focused

00:00:12,510 --> 00:00:17,460
on telco networking type devices

00:00:15,300 --> 00:00:21,390
stuff like that and have a to partners

00:00:17,460 --> 00:00:23,989
in crime here hey I'm beyond and I'm

00:00:21,390 --> 00:00:27,509
working with - basis Stockholm as well

00:00:23,989 --> 00:00:29,880
and John fest event I introduced myself

00:00:27,509 --> 00:00:32,430
earlier but this is one of my networking

00:00:29,880 --> 00:00:36,810
projects and I worked for covalent IO

00:00:32,430 --> 00:00:37,970
and give it back to these guys here ok

00:00:36,810 --> 00:00:44,400
thank you

00:00:37,970 --> 00:00:46,170
so what is this about not that okay so

00:00:44,400 --> 00:00:49,380
what's the motivation here so if you

00:00:46,170 --> 00:00:51,210
take a bunch of networking developers

00:00:49,380 --> 00:00:54,510
and you ask them what's your preferred

00:00:51,210 --> 00:00:56,760
platform my guess is that like 99.9% of

00:00:54,510 --> 00:00:58,980
them will say Linux because it has lots

00:00:56,760 --> 00:01:01,380
of good features it works and they're

00:00:58,980 --> 00:01:05,009
used to it but what if now you have like

00:01:01,380 --> 00:01:06,840
a dpi application and you want to use

00:01:05,009 --> 00:01:08,429
something like a packet but it doesn't

00:01:06,840 --> 00:01:11,069
give you the performance you need I mean

00:01:08,429 --> 00:01:13,200
you can't add as many cores to the

00:01:11,069 --> 00:01:15,299
system as you want maybe because there's

00:01:13,200 --> 00:01:17,069
no service that large or maybe because

00:01:15,299 --> 00:01:19,499
if you add that many cores to your

00:01:17,069 --> 00:01:21,479
system the price of that system will be

00:01:19,499 --> 00:01:23,700
out of range and you can't sell your

00:01:21,479 --> 00:01:26,189
product so what are the solution set

00:01:23,700 --> 00:01:28,560
what do you do well today you got might

00:01:26,189 --> 00:01:30,719
go to something like you know a caveum

00:01:28,560 --> 00:01:33,389
you know and where they are their

00:01:30,719 --> 00:01:37,289
proprietary hardware SDK or you might

00:01:33,389 --> 00:01:39,329
buy a NIC card for like high frequency

00:01:37,289 --> 00:01:41,670
trading or high-performance computing

00:01:39,329 --> 00:01:43,679
with their own proprietary hardware

00:01:41,670 --> 00:01:44,310
stack a we might code something like the

00:01:43,679 --> 00:01:46,259
PDK

00:01:44,310 --> 00:01:48,149
I mean firm with these are the heart use

00:01:46,259 --> 00:01:50,819
they're not like AF packet I mean you

00:01:48,149 --> 00:01:52,289
have to rewrite you have to use them you

00:01:50,819 --> 00:01:58,139
can also go to something like piei frame

00:01:52,289 --> 00:02:00,149
net map or DMA you know some of these to

00:01:58,139 --> 00:02:02,279
have you know little or no integration

00:02:00,149 --> 00:02:04,229
to Linux especially the the two top ones

00:02:02,279 --> 00:02:06,179
they have no integration to Linux so a

00:02:04,229 --> 00:02:08,069
lot of things will not work and we're

00:02:06,179 --> 00:02:10,290
carrying in that map they're not in

00:02:08,069 --> 00:02:12,510
Linux so I had some problems too

00:02:10,290 --> 00:02:12,780
already me is in Linux but it's not part

00:02:12,510 --> 00:02:18,570
of

00:02:12,780 --> 00:02:21,240
Linux net subsystem so what if we then

00:02:18,570 --> 00:02:24,480
could take you know the functionality in

00:02:21,240 --> 00:02:26,310
ease of use of a packet in Linux with

00:02:24,480 --> 00:02:28,110
the networking performance of this

00:02:26,310 --> 00:02:29,880
latter solution so take some of the

00:02:28,110 --> 00:02:31,440
goodness and the good stuff that I've

00:02:29,880 --> 00:02:34,320
developed here and our DNA in that map

00:02:31,440 --> 00:02:38,150
and transfer it to AF packet so how can

00:02:34,320 --> 00:02:40,800
we do that that's the problem statement

00:02:38,150 --> 00:02:42,240
so our proposed solution is then to

00:02:40,800 --> 00:02:44,820
introduce a new fast packet processing

00:02:42,240 --> 00:02:47,310
interface in Linux and we simply quote a

00:02:44,820 --> 00:02:51,270
packet v4 because it should be logical

00:02:47,310 --> 00:02:55,170
continuation to you know v2 and v3 yes

00:02:51,270 --> 00:02:58,800
no system calls in the data path by

00:02:55,170 --> 00:03:03,800
default it's copy mode just like v2 and

00:02:58,800 --> 00:03:06,989
v3 but you can enable a true zero copy

00:03:03,800 --> 00:03:09,720
mode and that is what's going to give

00:03:06,989 --> 00:03:13,440
you most of the performance bang for the

00:03:09,720 --> 00:03:15,930
buck and without node the DMA buffers

00:03:13,440 --> 00:03:16,410
are mapped straight into user space from

00:03:15,930 --> 00:03:18,750
the NIC

00:03:16,410 --> 00:03:20,370
so it's really true zero copy but note

00:03:18,750 --> 00:03:22,110
that the hardware descriptors are only

00:03:20,370 --> 00:03:25,140
mapped to the kernel they are not

00:03:22,110 --> 00:03:28,470
visible from user space user space only

00:03:25,140 --> 00:03:30,570
sees virtual descriptors these are the

00:03:28,470 --> 00:03:32,280
v4 descriptors so the corner will

00:03:30,570 --> 00:03:34,530
translate the hardware descriptors to

00:03:32,280 --> 00:03:38,190
the virtual v4 descriptors but the

00:03:34,530 --> 00:03:40,190
packet to go straight into user space so

00:03:38,190 --> 00:03:42,750
one very important thing here is that

00:03:40,190 --> 00:03:45,000
this zero copy mode requires hardware

00:03:42,750 --> 00:03:47,430
steering support for untrusted

00:03:45,000 --> 00:03:50,700
applications because if you have two

00:03:47,430 --> 00:03:53,220
destinations two processes then the

00:03:50,700 --> 00:03:55,650
horror has to make the decision on where

00:03:53,220 --> 00:03:56,880
to go there is if you have a port or a

00:03:55,650 --> 00:03:58,799
piece of order where everything just

00:03:56,880 --> 00:04:00,239
goes to a single destination then your

00:03:58,799 --> 00:04:02,160
course you don't need power steering but

00:04:00,239 --> 00:04:04,680
you have two or more then you do need

00:04:02,160 --> 00:04:07,320
this if you don't have that you have to

00:04:04,680 --> 00:04:09,000
copy the packet now tend to use the

00:04:07,320 --> 00:04:12,840
space and then of course it's not true

00:04:09,000 --> 00:04:16,200
zero compared more our goal here is to

00:04:12,840 --> 00:04:18,180
hit 40 gigabits a second which is liner

00:04:16,200 --> 00:04:20,070
it for 40 gigabit card on a single core

00:04:18,180 --> 00:04:22,860
for larger packets and about 30

00:04:20,070 --> 00:04:25,680
gigabytes a second for small packets 64

00:04:22,860 --> 00:04:27,660
bytes that's our goal

00:04:25,680 --> 00:04:29,160
and if you see where did we do the

00:04:27,660 --> 00:04:31,110
implementation if you look at the

00:04:29,160 --> 00:04:32,940
picture here then most of the

00:04:31,110 --> 00:04:35,070
implementation here is in the new v4

00:04:32,940 --> 00:04:38,669
socket layer we have some code in that

00:04:35,070 --> 00:04:40,080
Linux Nikki driver and also some piece

00:04:38,669 --> 00:04:43,470
of code on top of that there's no

00:04:40,080 --> 00:04:45,630
changes or no contributions at all into

00:04:43,470 --> 00:04:47,850
the general path of the I net you know

00:04:45,630 --> 00:04:54,090
Datagram sockets but no call there it's

00:04:47,850 --> 00:04:56,210
only for the a packet path so just to

00:04:54,090 --> 00:04:58,740
give a high-level summary of the results

00:04:56,210 --> 00:05:01,680
so we have implemented this before in a

00:04:58,740 --> 00:05:04,620
packet dot see it also requires for the

00:05:01,680 --> 00:05:06,979
zero copy node to new and the O's to be

00:05:04,620 --> 00:05:08,970
implementing the driver for this support

00:05:06,979 --> 00:05:10,440
also introduced something we'll call

00:05:08,970 --> 00:05:12,780
back to the race to facilitate this

00:05:10,440 --> 00:05:14,820
implementation to give you know really

00:05:12,780 --> 00:05:16,770
good performance and also to abstract

00:05:14,820 --> 00:05:19,830
away some parts of they're not the v4

00:05:16,770 --> 00:05:23,400
implementation we also try to integrate

00:05:19,830 --> 00:05:26,009
it with HTTP so that if you implement

00:05:23,400 --> 00:05:30,060
this zero copies support you also get

00:05:26,009 --> 00:05:30,630
xtp support for free is within quotation

00:05:30,060 --> 00:05:32,880
marks

00:05:30,630 --> 00:05:34,650
nothing's every for free so it has to be

00:05:32,880 --> 00:05:36,210
always has to be some rearrangement of

00:05:34,650 --> 00:05:40,340
stuff but really it should really

00:05:36,210 --> 00:05:44,400
facilitate xtp integration in their tree

00:05:40,340 --> 00:05:46,830
results so we did this we have a couple

00:05:44,400 --> 00:05:49,349
of test programs and we took this RFC

00:05:46,830 --> 00:05:51,360
that we have out for a ride and with v4

00:05:49,349 --> 00:05:53,360
and package zero copy we got like six to

00:05:51,360 --> 00:05:55,830
forty times the throughput of v2 and v3

00:05:53,360 --> 00:05:58,740
what do you think is is good on an

00:05:55,830 --> 00:06:02,190
iPhone Inuk we get 40 gigabit line rate

00:05:58,740 --> 00:06:05,310
to rx on one single core for large

00:06:02,190 --> 00:06:09,210
packets but we're not there for TX and

00:06:05,310 --> 00:06:11,610
not for small packets either so we

00:06:09,210 --> 00:06:13,139
really need much more than my session

00:06:11,610 --> 00:06:15,599
work we haven't really started off my

00:06:13,139 --> 00:06:18,000
session work to tell you the truth we

00:06:15,599 --> 00:06:20,099
focus a lot of things but still think I

00:06:18,000 --> 00:06:22,949
mean it looks looks very promising the

00:06:20,099 --> 00:06:24,180
performance and it's this whole thing

00:06:22,949 --> 00:06:25,949
even if you can get performance like

00:06:24,180 --> 00:06:27,570
this you should lessen the need for SRB

00:06:25,949 --> 00:06:29,039
because we see some use cases where

00:06:27,570 --> 00:06:30,840
people you see use virtual function

00:06:29,039 --> 00:06:33,419
straight up to use the space you know

00:06:30,840 --> 00:06:35,460
with all the disadvantages of that and

00:06:33,419 --> 00:06:36,670
hopefully with this they stop doing that

00:06:35,460 --> 00:06:41,770
and using a real interface

00:06:36,670 --> 00:06:42,310
instead okay so that was the elevator

00:06:41,770 --> 00:06:45,580
pitch

00:06:42,310 --> 00:06:47,140
very long elevator but still so what are

00:06:45,580 --> 00:06:48,640
we going to do so we're first going to

00:06:47,140 --> 00:06:50,860
talk about this new interface before

00:06:48,640 --> 00:06:53,350
this is the interface towards between

00:06:50,860 --> 00:06:54,880
kernel in user space and after that go

00:06:53,350 --> 00:06:58,200
into the details of the zero copy

00:06:54,880 --> 00:07:00,340
support and how that's implemented

00:06:58,200 --> 00:07:02,500
especially how to implement will packet

00:07:00,340 --> 00:07:05,680
erase after that and then we get into

00:07:02,500 --> 00:07:09,010
the xdp integration of this because xep

00:07:05,680 --> 00:07:10,480
is exciting in in terms of v4 we think

00:07:09,010 --> 00:07:13,330
we can do a lot of cool things we accept

00:07:10,480 --> 00:07:15,970
in conjunction with v4 and then we'll

00:07:13,330 --> 00:07:17,440
show you performance results speculate a

00:07:15,970 --> 00:07:19,660
little bit about future work especially

00:07:17,440 --> 00:07:23,020
we're going to tell you a lot about the

00:07:19,660 --> 00:07:25,630
work around RFC and then conclude just

00:07:23,020 --> 00:07:30,130
note something here so we publish this

00:07:25,630 --> 00:07:32,710
RFC last week so this talk is all based

00:07:30,130 --> 00:07:35,290
on that RFC and during this this stage

00:07:32,710 --> 00:07:38,140
we've got lots of feedback from you that

00:07:35,290 --> 00:07:40,270
will change that horsey for sure so we

00:07:38,140 --> 00:07:42,610
try to weave in that feedback into this

00:07:40,270 --> 00:07:45,760
talk but just you know maybe they

00:07:42,610 --> 00:07:47,470
stopped the paper it's all about the RFC

00:07:45,760 --> 00:07:55,060
it's not about the next version of the

00:07:47,470 --> 00:07:57,540
RC yes and we should admit something the

00:07:55,060 --> 00:08:01,390
RFC actually did not compile on motorola

00:07:57,540 --> 00:08:02,920
68000 build robot told us so if you're

00:08:01,390 --> 00:08:07,020
planning on taking this RFC on the ride

00:08:02,920 --> 00:08:07,020
on your amiga you should wait for the v2

00:08:07,770 --> 00:08:12,190
okay so what's the motivation about a

00:08:10,210 --> 00:08:15,220
new interface so why did you do that I

00:08:12,190 --> 00:08:17,380
mean so for before we really wanted to

00:08:15,220 --> 00:08:19,390
support through zero copy mode in order

00:08:17,380 --> 00:08:21,160
to do that has to be simple because

00:08:19,390 --> 00:08:24,160
always simple you have to have linear

00:08:21,160 --> 00:08:26,590
buffers and just doing it as simple as

00:08:24,160 --> 00:08:29,230
powerful as possible yeah not having

00:08:26,590 --> 00:08:32,140
many features in it should be simple and

00:08:29,230 --> 00:08:35,740
rather stupid we also want to eliminate

00:08:32,140 --> 00:08:39,280
copies for TX and buffering so if you

00:08:35,740 --> 00:08:40,930
get a packet in on rx you want to do

00:08:39,280 --> 00:08:42,729
something with it maybe inspect it and

00:08:40,930 --> 00:08:45,010
then we send it out again you should not

00:08:42,729 --> 00:08:47,350
have to compete in two at the expo

00:08:45,010 --> 00:08:48,820
should be no coffee stirrer so if

00:08:47,350 --> 00:08:50,850
something arrives an aurochs you should

00:08:48,820 --> 00:08:54,760
be able to send it out without a copy

00:08:50,850 --> 00:08:56,529
which is good for DPR him also if you

00:08:54,760 --> 00:08:58,949
want to buffer this let's say you have

00:08:56,529 --> 00:09:01,449
some higher-level reassembly need to do

00:08:58,949 --> 00:09:04,829
maybe their IP packets are fragmented

00:09:01,449 --> 00:09:08,680
for example then you should not have to

00:09:04,829 --> 00:09:10,149
copy this packet out of the buffer in

00:09:08,680 --> 00:09:11,769
order just to keep it around for a

00:09:10,149 --> 00:09:13,959
couple of milliseconds or you know a

00:09:11,769 --> 00:09:17,860
second you should just be able to leave

00:09:13,959 --> 00:09:20,529
it and then send it so avoiding copies

00:09:17,860 --> 00:09:22,570
in application to we also want to have

00:09:20,529 --> 00:09:25,540
two transparent error reporting on every

00:09:22,570 --> 00:09:28,649
packet if you want that so why is that

00:09:25,540 --> 00:09:32,519
important well if you have a system like

00:09:28,649 --> 00:09:36,070
you know this these things mobile phones

00:09:32,519 --> 00:09:38,889
the value of your data is going to

00:09:36,070 --> 00:09:42,550
deteriorate very very quickly because

00:09:38,889 --> 00:09:44,579
the data that you send it's actually

00:09:42,550 --> 00:09:47,320
tuned towards the interface in the air

00:09:44,579 --> 00:09:49,930
so it's only good for a single moment

00:09:47,320 --> 00:09:52,630
and if you send it at that moment it's

00:09:49,930 --> 00:09:54,730
gonna have very low error rate but if

00:09:52,630 --> 00:09:56,680
you resend it the same rate of five

00:09:54,730 --> 00:10:00,100
milliseconds later you might have

00:09:56,680 --> 00:10:01,720
hundreds layers so it's really important

00:10:00,100 --> 00:10:03,730
if you can't send something that you

00:10:01,720 --> 00:10:04,990
know it immediately and either just

00:10:03,730 --> 00:10:06,850
resend it immediately or they say

00:10:04,990 --> 00:10:08,050
there's no point if I send it now I'm

00:10:06,850 --> 00:10:08,380
going to install performance of the

00:10:08,050 --> 00:10:12,579
system

00:10:08,380 --> 00:10:14,050
so for tell comes that telco paceman

00:10:12,579 --> 00:10:17,019
stacks and stuff like that that's very

00:10:14,050 --> 00:10:19,779
important and of course we want it to be

00:10:17,019 --> 00:10:22,420
faster than v2 and v3 if it's not what

00:10:19,779 --> 00:10:25,120
we're doing this and also to be

00:10:22,420 --> 00:10:26,589
integrated xtp and will tell you much

00:10:25,120 --> 00:10:28,449
more about that and beyond me tell you

00:10:26,589 --> 00:10:31,410
much more about that later why we think

00:10:28,449 --> 00:10:33,459
that's important and also one other goal

00:10:31,410 --> 00:10:34,750
we're not really there yet if you

00:10:33,459 --> 00:10:36,370
actually implement this zero copy

00:10:34,750 --> 00:10:39,100
support in arriving we want you to get

00:10:36,370 --> 00:10:42,069
XD please support for free in there it

00:10:39,100 --> 00:10:46,000
should just be integrated into it so

00:10:42,069 --> 00:10:49,260
those are the costs so if you look at

00:10:46,000 --> 00:10:52,180
the format so what does it look like so

00:10:49,260 --> 00:10:54,399
we have two descriptor links or x2

00:10:52,180 --> 00:10:56,010
crypsis and TX descriptors just like in

00:10:54,399 --> 00:10:58,899
v2 v3

00:10:56,010 --> 00:11:03,399
but they look different so this is the

00:10:58,899 --> 00:11:05,980
descriptor format here so we start with

00:11:03,399 --> 00:11:09,399
they're having an ID here and this is

00:11:05,980 --> 00:11:11,860
the idea of a buffer so you can see here

00:11:09,399 --> 00:11:14,260
there's no buffers data buffers

00:11:11,860 --> 00:11:16,000
following the descriptor all data

00:11:14,260 --> 00:11:20,200
buffers are in this packet buffer over

00:11:16,000 --> 00:11:21,850
here so descriptor entries point to what

00:11:20,200 --> 00:11:24,040
packet buffer so there's an indirection

00:11:21,850 --> 00:11:26,830
for example the one there means that

00:11:24,040 --> 00:11:29,529
okay my data is in description number

00:11:26,830 --> 00:11:33,940
one over in the packet buffer and of

00:11:29,529 --> 00:11:36,910
course 22 there so it is 32 bit ID then

00:11:33,940 --> 00:11:38,950
we have a length offset to stalee where

00:11:36,910 --> 00:11:42,610
the data starts so you can have metadata

00:11:38,950 --> 00:11:45,399
and and and things like data headroom

00:11:42,610 --> 00:11:48,520
and we also have an error when you sing

00:11:45,399 --> 00:11:51,160
a message so you can get errors back and

00:11:48,520 --> 00:11:54,010
there's a set of flags and also some

00:11:51,160 --> 00:11:58,060
padding because we want this descriptor

00:11:54,010 --> 00:12:01,029
to be 16 bytes so you can fit for honest

00:11:58,060 --> 00:12:03,310
if you have a 64 byte cache line so we

00:12:01,029 --> 00:12:03,520
Pat it up with an extra for there to get

00:12:03,310 --> 00:12:05,670
that

00:12:03,520 --> 00:12:08,170
[Music]

00:12:05,670 --> 00:12:12,790
something to note here there's no data

00:12:08,170 --> 00:12:16,959
header in v4 and the reason for that is

00:12:12,790 --> 00:12:19,600
performance if this is a packet get in

00:12:16,959 --> 00:12:21,250
or X wanna sing on one core you have the

00:12:19,600 --> 00:12:24,070
application very likely on another core

00:12:21,250 --> 00:12:26,500
then we won't don't want that core to

00:12:24,070 --> 00:12:31,600
touch the data it should be touched by

00:12:26,500 --> 00:12:33,579
you know user space instead if both the

00:12:31,600 --> 00:12:34,890
core receiving the interrupts and doing

00:12:33,579 --> 00:12:38,260
this translation the driver and

00:12:34,890 --> 00:12:41,649
application touches the data we can get

00:12:38,260 --> 00:12:43,750
the promised decrease up to 50% so half

00:12:41,649 --> 00:12:45,880
the performance because you have to read

00:12:43,750 --> 00:12:46,959
in all your data into one cache and it

00:12:45,880 --> 00:12:50,020
has to be transferred over to the other

00:12:46,959 --> 00:12:51,880
one that's expensive and also another

00:12:50,020 --> 00:12:55,500
reason for not having a data format is

00:12:51,880 --> 00:12:59,350
that you can just use the next delivery

00:12:55,500 --> 00:13:01,270
so we don't have to you know translate

00:12:59,350 --> 00:13:03,980
everything so we think that's a you know

00:13:01,270 --> 00:13:06,740
a good thing here

00:13:03,980 --> 00:13:08,389
not here in this example Rx and TX use

00:13:06,740 --> 00:13:11,720
the same packet buffer it's not a

00:13:08,389 --> 00:13:14,810
requirement but if they do then of

00:13:11,720 --> 00:13:16,970
course you can just not have to copy

00:13:14,810 --> 00:13:18,680
anything if you go get them hack it into

00:13:16,970 --> 00:13:19,880
Rx and you're gonna reason something

00:13:18,680 --> 00:13:22,250
onto the X you don't have to copy

00:13:19,880 --> 00:13:25,339
anything if you for example get this

00:13:22,250 --> 00:13:26,690
packet buffer one in on rx you can just

00:13:25,339 --> 00:13:29,420
say oh I want to reason that you just

00:13:26,690 --> 00:13:33,399
put this one into the TX descriptor here

00:13:29,420 --> 00:13:33,399
and it will send that no cops

00:13:34,329 --> 00:13:40,880
something importantly was that we pasted

00:13:36,740 --> 00:13:43,519
this ring from Michael circles early

00:13:40,880 --> 00:13:46,850
proposal microcircuit on his Verta a 1.1

00:13:43,519 --> 00:13:47,839
but it has diverged after that but we

00:13:46,850 --> 00:13:49,910
didn't want to invent something

00:13:47,839 --> 00:13:52,519
completely new so we said let's take

00:13:49,910 --> 00:13:55,100
something good that we like and just use

00:13:52,519 --> 00:13:58,519
it but after that you know we're tayo

00:13:55,100 --> 00:14:01,579
1.1 has diverged and we have diverged

00:13:58,519 --> 00:14:03,410
and I don't know I mean if it's a good

00:14:01,579 --> 00:14:05,420
thing or not to track where tie or

00:14:03,410 --> 00:14:08,779
because it's standard we have no idea

00:14:05,420 --> 00:14:10,250
when it's gonna actually be done any

00:14:08,779 --> 00:14:13,699
spot they're also gonna be you know have

00:14:10,250 --> 00:14:16,550
input from Microsoft VMware it's gonna

00:14:13,699 --> 00:14:20,029
support block devices and things that we

00:14:16,550 --> 00:14:23,540
don't care about so what we did base it

00:14:20,029 --> 00:14:31,160
on that and same thing for here it's

00:14:23,540 --> 00:14:33,620
based on Michael circus proposal so how

00:14:31,160 --> 00:14:34,370
do you then use this so this looks very

00:14:33,620 --> 00:14:35,930
familiar

00:14:34,370 --> 00:14:37,940
if you familiar with AF packet which

00:14:35,930 --> 00:14:41,300
most of you are of course this is just

00:14:37,940 --> 00:14:43,190
pseudocode if you try compile this he

00:14:41,300 --> 00:14:47,680
won't work and if it does compile you

00:14:43,190 --> 00:14:50,839
should probably change your compiler so

00:14:47,680 --> 00:14:53,630
if I just create a socket as usual and

00:14:50,839 --> 00:14:55,970
then you state that okay I want packet

00:14:53,630 --> 00:14:57,560
version before and then we have

00:14:55,970 --> 00:15:00,560
something new here we have the packet

00:14:57,560 --> 00:15:03,319
memory set socket opt and this registers

00:15:00,560 --> 00:15:07,490
that packet buffer that memory that you

00:15:03,319 --> 00:15:09,620
saw in the other picture so you can you

00:15:07,490 --> 00:15:12,620
know Malik recent memory we can end up a

00:15:09,620 --> 00:15:14,930
piece of memory and register there so

00:15:12,620 --> 00:15:17,270
why do you register memory from user

00:15:14,930 --> 00:15:19,220
space it's just because

00:15:17,270 --> 00:15:20,570
a little bit more flexibility so you can

00:15:19,220 --> 00:15:23,810
actually use something like huge pages

00:15:20,570 --> 00:15:25,670
you can say I'm going to map an area

00:15:23,810 --> 00:15:30,080
with huge pages and I'm going to

00:15:25,670 --> 00:15:31,490
register that as my packet buffer and

00:15:30,080 --> 00:15:34,160
then you have something recognized it's

00:15:31,490 --> 00:15:37,790
a packet or extreme packet TX ring just

00:15:34,160 --> 00:15:40,130
like before and look registers your take

00:15:37,790 --> 00:15:44,140
security ring and your X descriptor ring

00:15:40,130 --> 00:15:46,340
and then you buy into an interface and

00:15:44,140 --> 00:15:50,150
what happens after that okay so you

00:15:46,340 --> 00:15:52,070
should go back so let me give you some

00:15:50,150 --> 00:15:56,630
examples here's what happens on Rx and

00:15:52,070 --> 00:16:00,170
TX so when when you start with rx I mean

00:15:56,630 --> 00:16:02,210
use the space now owns all offers

00:16:00,170 --> 00:16:04,460
because it was allocated in user space

00:16:02,210 --> 00:16:06,770
so first thing the user space program

00:16:04,460 --> 00:16:09,920
needs to do is actually send down some

00:16:06,770 --> 00:16:12,530
buffers to the kernel and if you're a

00:16:09,920 --> 00:16:14,540
program that it's never gonna send

00:16:12,530 --> 00:16:17,120
anything unless it gets something in

00:16:14,540 --> 00:16:18,580
oryx you can just take you know let's

00:16:17,120 --> 00:16:23,500
say you have a hundred twenty eight

00:16:18,580 --> 00:16:26,000
descriptor rings or entries and 1024

00:16:23,500 --> 00:16:28,430
packet buffers you can just take one and

00:16:26,000 --> 00:16:30,140
twenty eight of your packet buffers just

00:16:28,430 --> 00:16:32,810
send them down to the kernel because you

00:16:30,140 --> 00:16:35,660
know you're not gonna need them and what

00:16:32,810 --> 00:16:37,360
happens then is that okay or X the the

00:16:35,660 --> 00:16:43,070
kernel value will then take this

00:16:37,360 --> 00:16:45,350
register with a yeah with the with the

00:16:43,070 --> 00:16:47,660
hardware and start tailing them out so

00:16:45,350 --> 00:16:50,870
the application in user space will then

00:16:47,660 --> 00:16:53,720
that get buffers back with pointers to

00:16:50,870 --> 00:16:55,430
buffers that the driver has filled in so

00:16:53,720 --> 00:16:57,890
it can say okay you got four zero one

00:16:55,430 --> 00:17:00,950
four and five and they know how packets

00:16:57,890 --> 00:17:03,680
in them and as soon as user space is

00:17:00,950 --> 00:17:06,140
done with this maybe as process zero and

00:17:03,680 --> 00:17:08,480
one it just writes here on one in a say

00:17:06,140 --> 00:17:11,630
ya know you can fill them out in again I

00:17:08,480 --> 00:17:14,180
don't need them anymore an TX works in

00:17:11,630 --> 00:17:16,490
in a similar way but of course it's

00:17:14,180 --> 00:17:19,339
opposite them user space is the producer

00:17:16,490 --> 00:17:22,940
so you spaces okay I want to transmit

00:17:19,339 --> 00:17:24,440
buffer two three four and five and it is

00:17:22,940 --> 00:17:27,490
writes two three four and five

00:17:24,440 --> 00:17:29,890
the colonel will then say okay

00:17:27,490 --> 00:17:32,679
I have sent three three four and five

00:17:29,890 --> 00:17:35,799
they're completed now you can you know

00:17:32,679 --> 00:17:40,059
we use them if you want to so that's the

00:17:35,799 --> 00:17:42,370
way it works and not something that you

00:17:40,059 --> 00:17:44,380
know packet buffers they can be private

00:17:42,370 --> 00:17:46,870
I mean by default particular should be

00:17:44,380 --> 00:17:50,649
shared between processes if you do an

00:17:46,870 --> 00:17:52,120
nmap with map shared you work your child

00:17:50,649 --> 00:17:54,100
will actually inherit the packet buffer

00:17:52,120 --> 00:17:57,010
so you can share them between process

00:17:54,100 --> 00:17:59,289
but you have to do it explicitly the RX

00:17:57,010 --> 00:18:01,539
and TX descriptor rings are never shared

00:17:59,289 --> 00:18:03,720
they always private on every single

00:18:01,539 --> 00:18:03,720
process

00:18:06,299 --> 00:18:11,049
and what we have here then after you've

00:18:09,640 --> 00:18:12,549
done the bind is something that's

00:18:11,049 --> 00:18:15,460
optional and this is actually turning on

00:18:12,549 --> 00:18:17,980
the zero copy support so some feedback

00:18:15,460 --> 00:18:20,980
that web Gordon is that okay you know

00:18:17,980 --> 00:18:24,130
let's forget about this and just use two

00:18:20,980 --> 00:18:29,020
instead of doing a an AF packet V for

00:18:24,130 --> 00:18:33,120
just just do a new AF a new address you

00:18:29,020 --> 00:18:35,529
know do you know what we call a EF

00:18:33,120 --> 00:18:38,830
capture EF zero copy or something like

00:18:35,529 --> 00:18:43,179
that and if you use that new socket ID

00:18:38,830 --> 00:18:45,700
then you assume zero copy if the driver

00:18:43,179 --> 00:18:48,669
has support to zero copy you get zero

00:18:45,700 --> 00:18:50,500
copy if it doesn't have it you get you

00:18:48,669 --> 00:18:52,809
know a fallback support which is the

00:18:50,500 --> 00:18:56,940
copy mode and then you don't actually

00:18:52,809 --> 00:19:00,370
need this at all you can just remove it

00:18:56,940 --> 00:19:01,929
but after that then it's just a normal

00:19:00,370 --> 00:19:04,240
program you have a loop you read your

00:19:01,929 --> 00:19:11,950
message you process it you write it out

00:19:04,240 --> 00:19:13,240
again so pretty familiar if you look at

00:19:11,950 --> 00:19:15,970
them at the packet zero copy what's the

00:19:13,240 --> 00:19:19,059
basic principle here if you look at the

00:19:15,970 --> 00:19:21,640
left part of the diagram this is what

00:19:19,059 --> 00:19:24,520
you know v2 v3 and v4 in copy mode

00:19:21,640 --> 00:19:26,200
without the zero copied works it's like

00:19:24,520 --> 00:19:28,179
all the descriptors of the hardware and

00:19:26,200 --> 00:19:31,419
the packet buffer is owned by the kernel

00:19:28,179 --> 00:19:33,580
and it takes care of it and translate

00:19:31,419 --> 00:19:36,100
this and copies them out in into the

00:19:33,580 --> 00:19:39,059
application in userspace the difference

00:19:36,100 --> 00:19:39,059
with zero copies that

00:19:39,280 --> 00:19:43,240
the packet buffer of the naquadria

00:19:41,110 --> 00:19:45,880
straight into user space but note that

00:19:43,240 --> 00:19:47,530
the others are still the same the RX and

00:19:45,880 --> 00:19:49,030
TX descriptors are only mapped to the

00:19:47,530 --> 00:19:52,780
kernel only visible by the kernel and

00:19:49,030 --> 00:19:54,340
then these descriptors are translated

00:19:52,780 --> 00:19:58,650
out into the v4 descriptors in user

00:19:54,340 --> 00:20:01,480
space but the packets come straight out

00:19:58,650 --> 00:20:04,270
so each packet application needs its own

00:20:01,480 --> 00:20:07,330
packet buffer and tx/rx cube pair

00:20:04,270 --> 00:20:08,890
that's important but you can share them

00:20:07,330 --> 00:20:11,230
if you want to but you can never share

00:20:08,890 --> 00:20:15,640
the aurochs antiques descriptor rings

00:20:11,230 --> 00:20:18,280
they need to be separate so that

00:20:15,640 --> 00:20:21,700
security in isolation requirements o40

00:20:18,280 --> 00:20:23,050
company so first of all I mean first

00:20:21,700 --> 00:20:25,480
thing you need to ensure user space

00:20:23,050 --> 00:20:28,570
should not be able to crush kernel or

00:20:25,480 --> 00:20:30,010
other processes and uses which should

00:20:28,570 --> 00:20:32,800
not be able to read or write any kernel

00:20:30,010 --> 00:20:34,720
data and use the page should not be able

00:20:32,800 --> 00:20:36,940
to read and write packet from any other

00:20:34,720 --> 00:20:38,890
process unless you know the packet

00:20:36,940 --> 00:20:41,350
market explicitly shared if it's

00:20:38,890 --> 00:20:43,620
explicitly shed I want it to be shared

00:20:41,350 --> 00:20:45,910
so then that's kind of a feature instant

00:20:43,620 --> 00:20:48,310
so requirement if an untrusted

00:20:45,910 --> 00:20:51,490
application with v4 is that you need

00:20:48,310 --> 00:20:54,460
hardware packets theory if you have more

00:20:51,490 --> 00:20:56,080
than one consumer of the packets so if

00:20:54,460 --> 00:20:59,170
they're multiple destinations you need

00:20:56,080 --> 00:21:01,420
to program flow director or something

00:20:59,170 --> 00:21:02,890
else you know in unique in order to

00:21:01,420 --> 00:21:05,590
steer these packets to the right

00:21:02,890 --> 00:21:07,060
destination if that's not available

00:21:05,590 --> 00:21:09,060
because you have really old nick

00:21:07,060 --> 00:21:12,040
hardware or because you have a very

00:21:09,060 --> 00:21:15,130
funky protocol that's not supported or

00:21:12,040 --> 00:21:16,600
some classification need to do then the

00:21:15,130 --> 00:21:19,780
corner needs to own the packet buffer

00:21:16,600 --> 00:21:21,520
and copy the data out into user space so

00:21:19,780 --> 00:21:23,360
at that point it's not through zero copy

00:21:21,520 --> 00:21:26,430
anymore it is a copy

00:21:23,360 --> 00:21:26,430
[Music]

00:21:29,790 --> 00:21:38,290
Thank You boys

00:21:32,130 --> 00:21:42,030
so let's dig into the implementation so

00:21:38,290 --> 00:21:42,030
we sent out the rc4

00:21:55,710 --> 00:22:02,950
so what's the plan fish is really

00:22:00,460 --> 00:22:05,950
twofold so first there's adding the new

00:22:02,950 --> 00:22:06,820
restructure into a packet and then

00:22:05,950 --> 00:22:09,880
there's the neighbor is there a

00:22:06,820 --> 00:22:12,610
compliment so zero cough isn't able to

00:22:09,880 --> 00:22:15,250
be too new device operations and yours

00:22:12,610 --> 00:22:16,600
and the problem is when you add new when

00:22:15,250 --> 00:22:20,110
the onus is that you rely on other

00:22:16,600 --> 00:22:21,730
people too so why don't you go was to

00:22:20,110 --> 00:22:23,820
okay how do we do this as simple as

00:22:21,730 --> 00:22:23,820
possible

00:22:25,050 --> 00:22:31,780
we do that by private instructor for

00:22:28,930 --> 00:22:37,900
that and also try to abstract away stuff

00:22:31,780 --> 00:22:43,960
like yeah descriptor format animal uses

00:22:37,900 --> 00:22:45,880
based interaction also even though when

00:22:43,960 --> 00:22:50,140
when enables terracotta we still want to

00:22:45,880 --> 00:23:02,760
be able to have so if the driver has to

00:22:50,140 --> 00:23:02,760
be support we still want support

00:23:12,750 --> 00:23:21,030
that hopefully goes

00:23:16,580 --> 00:23:23,610
so what the pakery other is is it's a

00:23:21,030 --> 00:23:29,160
collection of frames that represent

00:23:23,610 --> 00:23:31,380
packets you use the populate function to

00:23:29,160 --> 00:23:38,280
pool frames from um

00:23:31,380 --> 00:23:39,810
and on the rabbit when when when the

00:23:38,280 --> 00:23:42,570
frames are added to the factory they're

00:23:39,810 --> 00:23:43,980
also validated so that means that when

00:23:42,570 --> 00:23:57,120
the driver starts using the frames

00:23:43,980 --> 00:24:01,050
within the factory they're all so the

00:23:57,120 --> 00:24:09,320
driver starts using the frames use the

00:24:01,050 --> 00:24:15,060
frame and when it's done by changing the

00:24:09,320 --> 00:24:19,740
the Barbican flashback these ways to use

00:24:15,060 --> 00:24:21,510
them for we can using the flash so

00:24:19,740 --> 00:24:26,150
that's sort of you populate the factory

00:24:21,510 --> 00:24:26,150
is populate and then your attorney too

00:24:26,840 --> 00:24:35,870
on top of that we have functions to eat

00:24:31,610 --> 00:24:40,270
through at this array and also to get

00:24:35,870 --> 00:24:40,270
some vegetable frameset which is a view

00:24:49,600 --> 00:25:05,690
and we're using this structure pretty

00:24:53,150 --> 00:25:08,180
much everywhere so we're using another

00:25:05,690 --> 00:25:19,610
way of unit back-trace as an out there

00:25:08,180 --> 00:25:26,720
so you can answer driver asked just walk

00:25:19,610 --> 00:25:29,810
down so this is the I for you got just

00:25:26,720 --> 00:25:32,420
an exam is how we use the foundry so

00:25:29,810 --> 00:25:34,480
first what's not shown here in the Oryx

00:25:32,420 --> 00:25:41,930
path is the setup face

00:25:34,480 --> 00:25:44,060
so when we enable the ricotta we we walk

00:25:41,930 --> 00:25:51,170
the hardwood descriptor ring I feel it

00:25:44,060 --> 00:25:55,310
where the buffers so we feel the hormone

00:25:51,170 --> 00:25:58,550
scrip drinks with empty frames and tell

00:25:55,310 --> 00:26:01,640
the device to stop receiving things so

00:25:58,550 --> 00:26:04,820
thank you writes on the wire and we end

00:26:01,640 --> 00:26:07,940
up the market tells the cannoli

00:26:04,820 --> 00:26:11,860
hey there's joking there's stuff to be

00:26:07,940 --> 00:26:14,180
done so we went to the handle here and

00:26:11,860 --> 00:26:16,910
this part is real simple so you just

00:26:14,180 --> 00:26:19,309
walk the hardware descriptor ring if the

00:26:16,910 --> 00:26:21,590
hard work has filled in

00:26:19,309 --> 00:26:25,280
the ring we update the corresponding

00:26:21,590 --> 00:26:35,270
entry in the back we'll do this for each

00:26:25,280 --> 00:26:40,100
entry and then we flash it back to and

00:26:35,270 --> 00:26:42,559
we also when when we sort of cleared

00:26:40,100 --> 00:26:45,890
this ring was allocating new entries and

00:26:42,559 --> 00:26:54,620
we use the pack the pack trade not only

00:26:45,890 --> 00:26:58,610
keeps the state or outstanding also on

00:26:54,620 --> 00:27:00,860
the equal path it's somewhat simpler the

00:26:58,610 --> 00:27:10,630
one difference is that we instead of the

00:27:00,860 --> 00:27:22,340
hardware nation we do send message

00:27:10,630 --> 00:27:27,679
driver enters the handler waste them on

00:27:22,340 --> 00:27:31,730
the hard-wearing we tell the whole boot

00:27:27,679 --> 00:27:34,150
store transfer to complete went through

00:27:31,730 --> 00:27:34,150
the handle again

00:27:45,250 --> 00:27:52,539
all right so I'm just a showcase we also

00:27:49,690 --> 00:27:55,150
implement the beef for so which is

00:27:52,539 --> 00:27:59,070
important under the current

00:27:55,150 --> 00:27:59,070
implementation only support oh it works

00:27:59,970 --> 00:28:12,750
so obviously that's useful but well the

00:28:06,460 --> 00:28:15,520
version that's both Sailor Venus be

00:28:12,750 --> 00:28:17,710
anyway so in this case it well zero

00:28:15,520 --> 00:28:38,610
carbon able in both ends is really easy

00:28:17,710 --> 00:28:38,610
so you take one each right so as I said

00:28:39,630 --> 00:29:00,370
we won't end so the goal was to have

00:28:44,880 --> 00:29:04,289
when you flush so in the North Sea we're

00:29:00,370 --> 00:29:04,289
doing that bicep Falls monopoly

00:29:04,950 --> 00:29:12,139
but it is to execute each each spring

00:29:15,350 --> 00:29:22,830
so one minor detail is that if you

00:29:20,159 --> 00:29:26,279
execute an existing program that's

00:29:22,830 --> 00:29:44,330
foreign zero barbecue for equality pass

00:29:26,279 --> 00:29:52,190
pass keys so we did some tests on

00:29:44,330 --> 00:29:52,190
velocity this is a police here sandwich

00:29:52,220 --> 00:30:03,139
and it's the the benchmark is only

00:30:18,710 --> 00:30:21,799
[Music]

00:30:33,360 --> 00:30:48,850
during all the traffic thank you

00:30:37,210 --> 00:30:52,270
I'm working right so this is for 64 byte

00:30:48,850 --> 00:30:57,790
packets and FBL knees in support which

00:30:52,270 --> 00:31:07,050
is people speak for around four

00:30:57,790 --> 00:31:24,430
different scenarios first which is a

00:31:07,050 --> 00:31:26,170
performer is some comments on their

00:31:24,430 --> 00:31:30,610
solitaire so as you can see it with

00:31:26,170 --> 00:31:35,200
obvious about 24 fasted own copy

00:31:30,610 --> 00:31:40,540
versions asked for palpable it sort of

00:31:35,200 --> 00:31:43,630
makes back so receiving sometimes we're

00:31:40,540 --> 00:31:45,280
afraid to go down the aurochs but 40s or

00:31:43,630 --> 00:31:49,080
still there's a lot of things to do

00:31:45,280 --> 00:31:49,080
there how the baths were doing

00:31:51,650 --> 00:31:58,360
we need to have around me both TAS the

00:31:55,460 --> 00:31:58,360
Morrisons ain't soft

00:32:09,160 --> 00:32:14,510
[Music]

00:32:11,200 --> 00:32:16,910
what's interesting here compared to the

00:32:14,510 --> 00:32:24,520
others that we're seeing the v2 v3 saw

00:32:16,910 --> 00:32:27,760
referred from so we're about 10% faster

00:32:24,520 --> 00:32:27,760
because worth

00:32:28,420 --> 00:32:36,770
asked for zero copy were line rate for

00:32:32,530 --> 00:32:42,110
article but again the TX path is home

00:32:36,770 --> 00:32:44,770
through optimized the tiniest of course

00:32:42,110 --> 00:32:44,770
outline dates

00:32:52,350 --> 00:32:58,259
all right so let's go back - cookie so

00:32:55,820 --> 00:33:00,600
one thing that we realized when we come

00:32:58,259 --> 00:33:02,429
under day and the old abadox was that if

00:33:00,600 --> 00:33:09,409
you sort of squint your eyes you can see

00:33:02,429 --> 00:33:13,139
that that extremely direct and yellow

00:33:09,409 --> 00:33:16,950
squash there's somewhat similar we're

00:33:13,139 --> 00:33:21,870
using so one idea that I had was maybe

00:33:16,950 --> 00:33:44,669
we could extend the existing HTTP NGOs

00:33:21,870 --> 00:33:50,730
to support our asked for s for ingress

00:33:44,669 --> 00:33:57,200
it may be possible to add some kind

00:33:50,730 --> 00:33:57,200
video that we too

00:34:09,750 --> 00:34:19,599
ideally we would like to have an NGO

00:34:13,000 --> 00:34:21,460
that's not strictly - and then the other

00:34:19,599 --> 00:34:23,669
way to reuse things would be with some

00:34:21,460 --> 00:34:23,669
minor

00:34:30,490 --> 00:34:38,320
right we want more well I thought one

00:34:35,770 --> 00:34:41,560
thought that it would use xp for me by

00:34:38,320 --> 00:34:43,570
the spirit or so for example your

00:34:41,560 --> 00:34:47,589
neighbor zero copy and then you had XP

00:34:43,570 --> 00:34:56,970
program say can we translate the deep or

00:34:47,589 --> 00:34:56,970
descriptor to say to use the same time

00:34:57,180 --> 00:35:01,950
that would have a however need a new

00:35:10,290 --> 00:35:14,310
yeah so you know receive has something

00:35:12,760 --> 00:35:16,660
called capacity for own which is a

00:35:14,310 --> 00:35:22,270
communion functions and when you and

00:35:16,660 --> 00:35:24,640
when you execute program we passed a

00:35:22,270 --> 00:35:27,220
copy to over the data to date comes back

00:35:24,640 --> 00:35:35,260
we call that but that's one special

00:35:27,220 --> 00:35:37,210
spirit seems more reasonable to use by

00:35:35,260 --> 00:35:44,859
extending the rest we instead of adding

00:35:37,210 --> 00:35:46,839
a new action which is another talk about

00:35:44,859 --> 00:35:48,640
their what made it would make sounds

00:35:46,839 --> 00:35:51,520
that had one it's a programmer being

00:35:48,640 --> 00:35:57,700
because the program that you enabled for

00:35:51,520 --> 00:36:00,839
0 of a juice might not be or you don't

00:35:57,700 --> 00:36:00,839
want that to be say

00:36:13,850 --> 00:36:20,550
our see Tulsa stuff too

00:36:16,740 --> 00:36:25,980
and after this offers lots more

00:36:20,550 --> 00:36:27,870
nosiness but yeah before this office we

00:36:25,980 --> 00:36:30,270
had a number of things we wanted to do

00:36:27,870 --> 00:36:32,910
we never see what's up we have some

00:36:30,270 --> 00:36:36,710
problems where they used to face ring

00:36:32,910 --> 00:36:38,760
structure if you have a loop cited

00:36:36,710 --> 00:36:41,310
system work either

00:36:38,760 --> 00:36:43,260
the uses basically is much faster than

00:36:41,310 --> 00:36:44,730
the coroner will see as much as the

00:36:43,260 --> 00:36:46,350
Jesus based which i think is always

00:36:44,730 --> 00:36:46,890
valid indicates it's also gonna be in

00:36:46,350 --> 00:36:49,080
balance

00:36:46,890 --> 00:36:50,970
the current drink star she gets into

00:36:49,080 --> 00:36:54,780
performance problems because there's

00:36:50,970 --> 00:36:57,330
lots of contention on that like and I

00:36:54,780 --> 00:36:59,400
think there was a post by Markus RP and

00:36:57,330 --> 00:37:02,940
some patch or another ring structure

00:36:59,400 --> 00:37:05,160
where he noticed it this so we have to

00:37:02,940 --> 00:37:07,350
get away from that I think that's gonna

00:37:05,160 --> 00:37:11,190
be a common case that one of them will

00:37:07,350 --> 00:37:13,110
try to hit this this a new pony

00:37:11,190 --> 00:37:14,700
toward you know at least for a while and

00:37:13,110 --> 00:37:16,880
that actually brings down performance or

00:37:14,700 --> 00:37:19,860
the whole system because yeah lots of

00:37:16,880 --> 00:37:21,690
immune system

00:37:19,860 --> 00:37:24,510
another thing network problem with is

00:37:21,690 --> 00:37:27,840
that if you have an asymmetric system

00:37:24,510 --> 00:37:29,490
where you have a process that confuse

00:37:27,840 --> 00:37:33,360
package like just arcs and you have

00:37:29,490 --> 00:37:35,580
another possible that's 50 X then of

00:37:33,360 --> 00:37:37,290
course you're not on it you receive also

00:37:35,580 --> 00:37:39,810
packets but if you're not going to stand

00:37:37,290 --> 00:37:42,420
back lots of pockets with all that

00:37:39,810 --> 00:37:44,550
process and with the country starts you

00:37:42,420 --> 00:37:46,470
need to mark even if you descending now

00:37:44,550 --> 00:37:49,770
empty stuff you need to mark every

00:37:46,470 --> 00:37:51,540
single descriptor what we need instead

00:37:49,770 --> 00:37:55,440
is something that we said okay just

00:37:51,540 --> 00:37:58,830
returned 512 descriptors to Colonel and

00:37:55,440 --> 00:38:00,630
just use them I just you know modifying

00:37:58,830 --> 00:38:03,900
a point or something we don't want to go

00:38:00,630 --> 00:38:06,270
through 512 entries and marking that's

00:38:03,900 --> 00:38:08,610
but it kind of instructor work works

00:38:06,270 --> 00:38:11,820
very well for the soon at the case where

00:38:08,610 --> 00:38:14,720
you know the same process actually does

00:38:11,820 --> 00:38:14,720
authorities

00:38:15,580 --> 00:38:21,950
and yes continue next to integration in

00:38:18,410 --> 00:38:24,860
factories optimized performs we haven't

00:38:21,950 --> 00:38:27,530
really started up a copy hat we need to

00:38:24,860 --> 00:38:31,250
show a lot more love I think also to

00:38:27,530 --> 00:38:33,800
expand what will take care that was

00:38:31,250 --> 00:38:37,880
Anita SPD to be for conversions that you

00:38:33,800 --> 00:38:40,430
ought to not be able to support it about

00:38:37,880 --> 00:38:44,030
a device between two processes where one

00:38:40,430 --> 00:38:48,800
of us might please you know STDs other

00:38:44,030 --> 00:38:51,620
misuses before also supports our shared

00:38:48,800 --> 00:38:56,240
party poppers we contacted network does

00:38:51,620 --> 00:38:58,520
not support also that the packet buffer

00:38:56,240 --> 00:39:01,010
is unnecessarily clean for virtual

00:38:58,520 --> 00:39:05,660
devices that just slopped be from us we

00:39:01,010 --> 00:39:07,460
should just get rid of that and then we

00:39:05,660 --> 00:39:09,320
have unifying the before and sqb there's

00:39:07,460 --> 00:39:13,700
a path in the i-40 driver to make it

00:39:09,320 --> 00:39:16,100
simpler and smaller and also support for

00:39:13,700 --> 00:39:20,630
packet spanning multiple frames so

00:39:16,100 --> 00:39:21,980
currently they can only be one frame and

00:39:20,630 --> 00:39:24,110
the last thing is this associate the

00:39:21,980 --> 00:39:27,050
packet array implementation from the v4

00:39:24,110 --> 00:39:30,890
q structure today the packet array

00:39:27,050 --> 00:39:33,530
internally assumes that it is gonna put

00:39:30,890 --> 00:39:35,180
these packets in a v4 format but if you

00:39:33,530 --> 00:39:38,840
want to implement something like 2x DP

00:39:35,180 --> 00:39:40,310
rewrite this kit to rewrite support you

00:39:38,840 --> 00:39:42,230
know it might be worth our unit on the

00:39:40,310 --> 00:39:44,360
other side or you know be - who knows

00:39:42,230 --> 00:39:46,760
something else so then that needs to be

00:39:44,360 --> 00:39:49,100
disassociated and you need to do that in

00:39:46,760 --> 00:39:51,710
that tip before a populate and flush and

00:39:49,100 --> 00:39:54,140
also for the SQL case you need that

00:39:51,710 --> 00:39:55,910
because you might produce it into an skb

00:39:54,140 --> 00:39:58,130
instead I cross to the corner for

00:39:55,910 --> 00:40:01,160
example and of course there's lots of

00:39:58,130 --> 00:40:04,190
things that you detected so that we need

00:40:01,160 --> 00:40:05,870
to do for example do a lot of the pre

00:40:04,190 --> 00:40:08,090
patches to the i-40 colonel

00:40:05,870 --> 00:40:12,020
- just condensate exactly what's needed

00:40:08,090 --> 00:40:14,030
for the zero copy support and lots of

00:40:12,020 --> 00:40:16,400
other things that we need to go and do

00:40:14,030 --> 00:40:18,740
and some of the things that you suggest

00:40:16,400 --> 00:40:20,860
will actually completely change the

00:40:18,740 --> 00:40:23,900
title of this talk and make it obsolete

00:40:20,860 --> 00:40:25,959
for example if we say it's a packet

00:40:23,900 --> 00:40:33,640
capture if like a zero copy then yeah

00:40:25,959 --> 00:40:36,069
we need to fix that too and yes future

00:40:33,640 --> 00:40:37,359
work I mean we will be very busy with

00:40:36,069 --> 00:40:40,779
the first one so there will probably be

00:40:37,359 --> 00:40:42,609
no future work but we need to get a

00:40:40,779 --> 00:40:44,380
proper patch set and the suggestion

00:40:42,609 --> 00:40:48,209
there was just focus on orcs to start

00:40:44,380 --> 00:40:50,410
with just drop the TX so we'll do that

00:40:48,209 --> 00:40:52,150
you might want to try implementing the

00:40:50,410 --> 00:40:54,400
zero copy support or other device I mean

00:40:52,150 --> 00:40:56,529
I will just try to but does it work for

00:40:54,400 --> 00:40:58,599
other ones I mean we really need to try

00:40:56,529 --> 00:41:02,799
out a few to know if it's if it's the

00:40:58,599 --> 00:41:04,689
right way or not and we really need to

00:41:02,799 --> 00:41:06,579
try this interface out on real workloads

00:41:04,689 --> 00:41:08,439
so we've been using micro benchmarks

00:41:06,579 --> 00:41:11,289
micro benchmarks is just micro

00:41:08,439 --> 00:41:13,630
benchmarks it's very far from real a TCP

00:41:11,289 --> 00:41:16,680
dump is also simple we need some real

00:41:13,630 --> 00:41:19,269
workloads and see if this really flies

00:41:16,680 --> 00:41:21,279
so that's I think that's very important

00:41:19,269 --> 00:41:24,609
that's I think they've said we don't

00:41:21,279 --> 00:41:28,029
want to do V 1 V 2 V 3 V 4 of what this

00:41:24,609 --> 00:41:32,709
you know and so on d5 so let's try it to

00:41:28,029 --> 00:41:35,319
get right yes and what we want talked

00:41:32,709 --> 00:41:37,900
about need to get up the performance of

00:41:35,319 --> 00:41:40,059
T X star maybe get rid of that Cisco

00:41:37,900 --> 00:41:45,249
Lloyd just try to get rid it from the rx

00:41:40,059 --> 00:41:47,890
cordless and packet steering using x TP

00:41:45,249 --> 00:41:49,809
and meta data support with the meta data

00:41:47,890 --> 00:41:51,789
support hopefully we can just ride on

00:41:49,809 --> 00:41:55,059
the meta data support in xtp here

00:41:51,789 --> 00:41:58,119
because we don't assume a specific data

00:41:55,059 --> 00:42:00,640
format and we don't write anything into

00:41:58,119 --> 00:42:02,650
the data so hopefully we can use right

00:42:00,640 --> 00:42:08,890
on the meta data support the next deeply

00:42:02,650 --> 00:42:11,709
that's our hope right so acknowledgments

00:42:08,890 --> 00:42:14,229
so thank you very much guys alexey

00:42:11,709 --> 00:42:17,529
Alexander yes Bert you know for all your

00:42:14,229 --> 00:42:19,809
comments on the early RC draft you you

00:42:17,529 --> 00:42:21,779
got to see before it was sent out you

00:42:19,809 --> 00:42:24,429
really helped improve the quality of it

00:42:21,779 --> 00:42:27,579
and also want to help thank some

00:42:24,429 --> 00:42:29,619
internal colleagues Rami Geoff Farooqi

00:42:27,579 --> 00:42:32,410
you helped with the code and you know

00:42:29,619 --> 00:42:34,749
performance results and tests and stuff

00:42:32,410 --> 00:42:36,459
like that and also developers are

00:42:34,749 --> 00:42:38,460
already main at math differing I mean

00:42:36,459 --> 00:42:41,040
you know you would

00:42:38,460 --> 00:42:43,140
first so really for the datapath there's

00:42:41,040 --> 00:42:45,300
lots of inspiration from that so thank

00:42:43,140 --> 00:42:46,859
you and also of course thank you all for

00:42:45,300 --> 00:42:52,859
all your comments you know and feedback

00:42:46,859 --> 00:42:54,839
during this this stays so finally to

00:42:52,859 --> 00:42:57,150
conclude so we introduced the safe

00:42:54,839 --> 00:43:01,339
packet before and packet zero copy for

00:42:57,150 --> 00:43:03,890
getting better if packet performs and

00:43:01,339 --> 00:43:05,790
tightly integrated with XDP and

00:43:03,890 --> 00:43:07,640
introduce something called packet arrays

00:43:05,790 --> 00:43:11,430
to facilitate the implementation and

00:43:07,640 --> 00:43:12,810
also to improve performance for it and

00:43:11,430 --> 00:43:14,099
we showed that at least on the fourth

00:43:12,810 --> 00:43:16,050
well Nick you could get sixty to forty

00:43:14,099 --> 00:43:19,550
times the performance improvements for

00:43:16,050 --> 00:43:21,540
some simple micro benchmark that we had

00:43:19,550 --> 00:43:23,099
there's still lots of performance

00:43:21,540 --> 00:43:25,290
optimization work to be performed we

00:43:23,099 --> 00:43:28,589
haven't really started our zone we think

00:43:25,290 --> 00:43:29,820
we can we can do better for sure so and

00:43:28,589 --> 00:43:30,839
there's lots of exciting exit the

00:43:29,820 --> 00:43:33,030
extension I think that possibly

00:43:30,839 --> 00:43:36,300
conjunction with an interface like this

00:43:33,030 --> 00:43:38,310
but that's definite for future work so I

00:43:36,300 --> 00:44:02,730
think future looks you know bright and

00:43:38,310 --> 00:44:08,010
promising and full of work thank you hi

00:44:02,730 --> 00:44:09,930
this looks great I'm sure we are

00:44:08,010 --> 00:44:12,660
absolutely not the primary use case of

00:44:09,930 --> 00:44:15,450
this code but we have a packet

00:44:12,660 --> 00:44:17,339
translation daemon that uses packet our

00:44:15,450 --> 00:44:19,080
x-ray and then turns the packets around

00:44:17,339 --> 00:44:21,510
translates them between ipv4 and ipv6

00:44:19,080 --> 00:44:23,520
and then spits smile again and this

00:44:21,510 --> 00:44:25,830
looks like it's a would be a really good

00:44:23,520 --> 00:44:28,410
fit for it except I don't quite

00:44:25,830 --> 00:44:30,750
understand the steering and coexistence

00:44:28,410 --> 00:44:33,450
strategy you say Nick has to support

00:44:30,750 --> 00:44:34,980
Hardware steering but I don't know you

00:44:33,450 --> 00:44:36,540
know what that means it does it mean

00:44:34,980 --> 00:44:39,060
like we can push down a BPF filter and

00:44:36,540 --> 00:44:42,660
say give me only these packets and send

00:44:39,060 --> 00:44:45,310
them up only to this socket or is it

00:44:42,660 --> 00:44:50,180
sort of much more invasive than that

00:44:45,310 --> 00:44:51,410
all right so the default mode without

00:44:50,180 --> 00:44:56,870
any steering that they were talking

00:44:51,410 --> 00:45:01,010
about would be just send all right

00:44:56,870 --> 00:45:04,220
tickets some more time so let me try to

00:45:01,010 --> 00:45:06,830
restart this then so that this binds to

00:45:04,220 --> 00:45:08,660
a specific hardware ring so and they get

00:45:06,830 --> 00:45:09,800
the way you get zero copy is then every

00:45:08,660 --> 00:45:11,960
packet that comes into that hardware

00:45:09,800 --> 00:45:13,580
ring gets zero copied into user space so

00:45:11,960 --> 00:45:15,680
you you could bind to all of the

00:45:13,580 --> 00:45:17,510
hardware rings and get every packet that

00:45:15,680 --> 00:45:20,360
ever that goes into the Nick into user

00:45:17,510 --> 00:45:21,500
space is zero copied and then there

00:45:20,360 --> 00:45:23,660
would be no filtering it would just be

00:45:21,500 --> 00:45:25,700
all packet to go to your v4 v6

00:45:23,660 --> 00:45:28,790
translator or whatever you have in user

00:45:25,700 --> 00:45:30,680
space but there are cases where you only

00:45:28,790 --> 00:45:32,810
want specific types of packets like you

00:45:30,680 --> 00:45:35,140
might never want non IP packets in this

00:45:32,810 --> 00:45:37,490
case right makes perfect sense

00:45:35,140 --> 00:45:39,440
yeah but because we're doing the zero

00:45:37,490 --> 00:45:42,560
copy we need to let the hardware know

00:45:39,440 --> 00:45:45,020
not to put those kinds of packets on the

00:45:42,560 --> 00:45:46,790
Rings that are bound to the user space

00:45:45,020 --> 00:45:48,110
because of the zero copy because the

00:45:46,790 --> 00:45:51,200
hardware is actually doing the DMA into

00:45:48,110 --> 00:45:53,230
user space and so the way the mechanism

00:45:51,200 --> 00:45:55,700
to do this is any of the hardware

00:45:53,230 --> 00:45:57,650
offload kind of steering mechanisms that

00:45:55,700 --> 00:45:59,000
we have in the kernel today and so flow

00:45:57,650 --> 00:46:02,510
director is one of them which lets you

00:45:59,000 --> 00:46:04,700
push down a like usually it's a tuple or

00:46:02,510 --> 00:46:06,710
you say I want these IP addresses or I

00:46:04,700 --> 00:46:07,970
want this protocol type down into the

00:46:06,710 --> 00:46:11,240
hardware and say send all that traffic

00:46:07,970 --> 00:46:12,530
to q1 so you could do something in this

00:46:11,240 --> 00:46:15,110
case like say I want all of the IP

00:46:12,530 --> 00:46:16,670
packets to be on Q's two three and four

00:46:15,110 --> 00:46:18,620
and I'm gonna bind my application to

00:46:16,670 --> 00:46:20,630
those and anything that's not that type

00:46:18,620 --> 00:46:22,870
should go to q1 and B it's ARP or

00:46:20,630 --> 00:46:25,640
something like this

00:46:22,870 --> 00:46:27,890
the BPF comment is interesting because

00:46:25,640 --> 00:46:29,390
some hardware can offload BPF you could

00:46:27,890 --> 00:46:31,820
imagine that this type of hardware could

00:46:29,390 --> 00:46:33,760
then say using this BPF filter send it

00:46:31,820 --> 00:46:36,550
to this queue that does the zero copy

00:46:33,760 --> 00:46:40,160
that answer the question

00:46:36,550 --> 00:46:42,230
yeah we in this case we we have a

00:46:40,160 --> 00:46:43,940
dedicated ipv6 address that we could use

00:46:42,230 --> 00:46:45,380
and we just say like don't pass the

00:46:43,940 --> 00:46:47,450
static colonel networking stack at all

00:46:45,380 --> 00:46:49,280
because because then I have packet v3

00:46:47,450 --> 00:46:52,010
right the packets go both to your socket

00:46:49,280 --> 00:46:54,290
into the kernel and you do that to here

00:46:52,010 --> 00:46:56,690
and before except you can't do zero copy

00:46:54,290 --> 00:46:57,740
right so but yes in our case we just

00:46:56,690 --> 00:47:00,130
passed down say hey

00:46:57,740 --> 00:47:02,060
anything that comes to this v6 address

00:47:00,130 --> 00:47:04,460
essentially though we're bypassing the

00:47:02,060 --> 00:47:06,080
stack right for packets to the ipv6 or

00:47:04,460 --> 00:47:07,520
us which push down this flow it comes to

00:47:06,080 --> 00:47:09,320
our socket which is what we want

00:47:07,520 --> 00:47:11,540
actually but yeah because because of the

00:47:09,320 --> 00:47:14,330
zero copy nature of the DMA you have to

00:47:11,540 --> 00:47:16,190
do the copy and yes you just push down a

00:47:14,330 --> 00:47:17,510
filter for your ipv6 address it'll

00:47:16,190 --> 00:47:19,369
always get into user space zero copied

00:47:17,510 --> 00:47:20,900
and then you'll do your translation and

00:47:19,369 --> 00:47:31,430
send it wherever else it needs to go at

00:47:20,900 --> 00:47:32,930
that point I just want to quickly

00:47:31,430 --> 00:47:36,350
reiterate something we discussed that

00:47:32,930 --> 00:47:38,690
net comp when John presented this design

00:47:36,350 --> 00:47:40,340
of this and we were talking about doing

00:47:38,690 --> 00:47:43,100
a separate address family like AF

00:47:40,340 --> 00:47:46,340
capture or something like that I think

00:47:43,100 --> 00:47:47,720
it would be preferred to have a software

00:47:46,340 --> 00:47:49,790
implementation where copies are

00:47:47,720 --> 00:47:51,740
performed if the NGOs are in present so

00:47:49,790 --> 00:47:53,750
that applications can be written to this

00:47:51,740 --> 00:47:55,910
API regardless of the presence of

00:47:53,750 --> 00:47:57,290
hardware support and transparently they

00:47:55,910 --> 00:47:59,119
would take advantage of this hardware

00:47:57,290 --> 00:48:00,680
support should they then run that

00:47:59,119 --> 00:48:02,570
application on a machine that has it so

00:48:00,680 --> 00:48:04,310
I think that's an important aspect of

00:48:02,570 --> 00:48:06,680
thing looking forward about how to

00:48:04,310 --> 00:48:11,830
design this so just please keep that in

00:48:06,680 --> 00:48:11,830
mind agreed

00:48:12,970 --> 00:48:18,050
so early on you mentioned you you viewed

00:48:15,800 --> 00:48:21,970
this as replacing some SR iov use cases

00:48:18,050 --> 00:48:21,970
could you expand on that a little bit

00:48:23,470 --> 00:48:28,940
sure so and they can add more to this I

00:48:27,080 --> 00:48:30,920
think there was some known limitations

00:48:28,940 --> 00:48:35,119
the best ROV for instance you only

00:48:30,920 --> 00:48:36,230
allowed 64 or 128 VFS on a NIC that

00:48:35,119 --> 00:48:37,550
might have thousands of queues and

00:48:36,230 --> 00:48:39,320
filters for you know the ability to

00:48:37,550 --> 00:48:41,570
filter thousands of different kind of

00:48:39,320 --> 00:48:43,369
flows this type of interface wouldn't

00:48:41,570 --> 00:48:44,570
have any of those limitations so in

00:48:43,369 --> 00:48:46,190
theory you could have thousands of these

00:48:44,570 --> 00:48:48,560
applications all doing zero copy based

00:48:46,190 --> 00:48:50,030
on different flows and only these guys

00:48:48,560 --> 00:48:53,390
they might know more about platform

00:48:50,030 --> 00:48:58,520
things and also for this like to tell

00:48:53,390 --> 00:49:00,770
applications it's quite you know common

00:48:58,520 --> 00:49:03,140
that people just put the EF scene to use

00:49:00,770 --> 00:49:04,790
the space to get the performance but of

00:49:03,140 --> 00:49:05,760
course that hurts cause your hardware

00:49:04,790 --> 00:49:07,730
dependent and

00:49:05,760 --> 00:49:10,560
a lot of other things that are not good

00:49:07,730 --> 00:49:12,570
so if you can get rid of that you can

00:49:10,560 --> 00:49:14,790
also get bifurcation which is horrible

00:49:12,570 --> 00:49:16,920
if you have a long maintenance cycle of

00:49:14,790 --> 00:49:19,770
your software lots of other problems so

00:49:16,920 --> 00:49:22,920
if you can get rid of that thing of you

00:49:19,770 --> 00:49:26,690
know just exposing sr v FS into user

00:49:22,920 --> 00:49:26,690
space that's worth a lot

00:49:30,450 --> 00:49:34,680
I noticed the complete lack of any

00:49:32,670 --> 00:49:37,530
mention of offloads I'm wondering if you

00:49:34,680 --> 00:49:41,520
have any ideas or comments in particular

00:49:37,530 --> 00:49:43,020
check some minion segmentation no

00:49:41,520 --> 00:49:45,060
actually are not I mean we're thinking

00:49:43,020 --> 00:49:47,000
about that even in the metadata work to

00:49:45,060 --> 00:49:49,590
to tackle that but we don't have any

00:49:47,000 --> 00:49:51,180
offload support but it's important it

00:49:49,590 --> 00:49:53,850
should be there some of them are really

00:49:51,180 --> 00:50:00,300
important so but we haven't we haven't

00:49:53,850 --> 00:50:02,970
tackled that yet just want to comment on

00:50:00,300 --> 00:50:05,760
the SRA of a limitation you mentioned so

00:50:02,970 --> 00:50:08,460
the number of EFS is the limitation you

00:50:05,760 --> 00:50:10,530
mentioned I guess it's implementation

00:50:08,460 --> 00:50:14,400
specific right it's not the spec

00:50:10,530 --> 00:50:17,780
limitation there are some limitations on

00:50:14,400 --> 00:50:21,360
the spec right the maximum number of EF

00:50:17,780 --> 00:50:24,090
based on the TCI spec but I think this

00:50:21,360 --> 00:50:26,580
pick allows thousands of them not 64 or

00:50:24,090 --> 00:50:28,140
the numbers like this depends on how you

00:50:26,580 --> 00:50:30,120
implement the PCIe spec and

00:50:28,140 --> 00:50:33,060
device-specific so a lot of devices have

00:50:30,120 --> 00:50:36,840
fairly limited PCI a number of years

00:50:33,060 --> 00:50:38,190
that they support and maybe somebody

00:50:36,840 --> 00:50:40,830
who's more familiar with the actual

00:50:38,190 --> 00:50:43,820
hardware spec and speak to it but most

00:50:40,830 --> 00:50:47,910
hardware that I have as a limit of 128 I

00:50:43,820 --> 00:50:50,820
know how hard we mix that support more

00:50:47,910 --> 00:50:53,970
so is that much more there are how doing

00:50:50,820 --> 00:50:56,700
exist approach much more if you if you

00:50:53,970 --> 00:50:59,610
look at the PCI spec its eight bits max

00:50:56,700 --> 00:51:03,780
because it right am I correct

00:50:59,610 --> 00:51:06,510
16 16 bits but you can you can you can

00:51:03,780 --> 00:51:09,390
simulate your own VF from from your host

00:51:06,510 --> 00:51:11,670
to the host if you have an internal chip

00:51:09,390 --> 00:51:15,120
I don't think it doesn't

00:51:11,670 --> 00:51:17,640
I think the point here is a little bit

00:51:15,120 --> 00:51:20,190
the John's thing is a little bit

00:51:17,640 --> 00:51:23,250
right when if you're doing granularity

00:51:20,190 --> 00:51:24,809
of a device everything buffers queues

00:51:23,250 --> 00:51:26,549
everything needs to be bound and

00:51:24,809 --> 00:51:29,910
assigned upfront because if you have

00:51:26,549 --> 00:51:31,529
let's say of 64 devices 63 of them need

00:51:29,910 --> 00:51:33,599
to be provisioned you can't do it later

00:51:31,529 --> 00:51:35,339
if you are doing it on a per flow basis

00:51:33,599 --> 00:51:37,829
you can change the assignment and the

00:51:35,339 --> 00:51:39,750
binding as a flow comes online and I

00:51:37,829 --> 00:51:43,680
think it gives you better utilization

00:51:39,750 --> 00:51:45,809
and flexibility this is a great this is

00:51:43,680 --> 00:51:50,400
another reason not to try to reallocate

00:51:45,809 --> 00:51:52,799
or VF I think you can similarly also

00:51:50,400 --> 00:52:00,960
change the assignment of VF to a user

00:51:52,799 --> 00:52:08,369
process dynamically so not so I can take

00:52:00,960 --> 00:52:10,470
it offline someone else with triggers

00:52:08,369 --> 00:52:12,930
restart be more than the scalability I

00:52:10,470 --> 00:52:15,269
think what you're providing is you know

00:52:12,930 --> 00:52:17,460
you create a VM you are probably signing

00:52:15,269 --> 00:52:20,369
up for a particular interface what I or

00:52:17,460 --> 00:52:22,259
whatever you know you really don't want

00:52:20,369 --> 00:52:24,690
to transition that so you have your ring

00:52:22,259 --> 00:52:27,390
structure defined in the you know the

00:52:24,690 --> 00:52:29,940
virtual interface either director sign

00:52:27,390 --> 00:52:32,910
one or emulated one with this you're

00:52:29,940 --> 00:52:34,410
getting almost the close performance of

00:52:32,910 --> 00:52:36,269
a director sign interface because you're

00:52:34,410 --> 00:52:37,980
doing a direct copy of your packets

00:52:36,269 --> 00:52:39,240
although you're doing your descriptor

00:52:37,980 --> 00:52:42,480
translation which gives you the freedom

00:52:39,240 --> 00:52:44,940
of having a very independent ring

00:52:42,480 --> 00:52:47,190
structure in your VM and it is not bound

00:52:44,940 --> 00:52:49,349
to what is implemented in the hardware I

00:52:47,190 --> 00:52:57,480
think that's the that's the most

00:52:49,349 --> 00:53:00,240
important point here anybody else so

00:52:57,480 --> 00:53:02,099
regarding to small pockets so I think

00:53:00,240 --> 00:53:07,890
this is currently the issue how you

00:53:02,099 --> 00:53:09,720
handle a small 64 bytes performance do

00:53:07,890 --> 00:53:13,019
you have any idea how to resolve that

00:53:09,720 --> 00:53:15,000
because do you know what what problem I

00:53:13,019 --> 00:53:17,039
is talking about specifically I'm

00:53:15,000 --> 00:53:18,660
talking about if as you see in the

00:53:17,039 --> 00:53:20,730
performance test the the problem that's

00:53:18,660 --> 00:53:22,380
for every descriptor you need to do

00:53:20,730 --> 00:53:25,619
something so if it's a small pockets

00:53:22,380 --> 00:53:28,140
then the packet per second will be not

00:53:25,619 --> 00:53:29,760
efficient yeah I mean getting more than

00:53:28,140 --> 00:53:32,250
33 million pack

00:53:29,760 --> 00:53:35,220
up to 40 or 50 is that what you want

00:53:32,250 --> 00:53:36,600
yeah I mean we know we have some

00:53:35,220 --> 00:53:39,000
problems with the ring structure because

00:53:36,600 --> 00:53:41,520
it creates lots of cash bouncing effects

00:53:39,000 --> 00:53:44,220
for example that we need to get rid of

00:53:41,520 --> 00:53:46,680
so I don't know how much you'll gain by

00:53:44,220 --> 00:53:49,250
doing that we also noticed that it's

00:53:46,680 --> 00:53:52,440
really important to look at the I cache

00:53:49,250 --> 00:53:53,820
and really optimize the code for having

00:53:52,440 --> 00:53:56,190
everything in the I cache so it's

00:53:53,820 --> 00:53:58,680
actually better usually to go through

00:53:56,190 --> 00:54:02,940
the data multiple times and but have

00:53:58,680 --> 00:54:04,950
better I cash rate ratio or better a

00:54:02,940 --> 00:54:06,030
cache miss rate you could say or hit for

00:54:04,950 --> 00:54:07,920
it

00:54:06,030 --> 00:54:09,710
so there are lots of things we can do

00:54:07,920 --> 00:54:13,410
but I don't know how much they're gonna

00:54:09,710 --> 00:54:15,480
you know impact this but we haven't

00:54:13,410 --> 00:54:17,790
really performance optimized this we I

00:54:15,480 --> 00:54:19,230
mean when we wrote the paper well you

00:54:17,790 --> 00:54:20,970
know we started measuring this and of

00:54:19,230 --> 00:54:23,670
course we discover things that oh oh oh

00:54:20,970 --> 00:54:24,990
you know we need to fix this so we fixed

00:54:23,670 --> 00:54:26,730
a couple of things but mainly in the

00:54:24,990 --> 00:54:29,670
zero copy case to get you to this but

00:54:26,730 --> 00:54:31,410
there's much more to do and also in this

00:54:29,670 --> 00:54:34,650
packet I want one thing we wanted to do

00:54:31,410 --> 00:54:37,020
is study the optimal access pattern of

00:54:34,650 --> 00:54:39,119
your data and your your instructions

00:54:37,020 --> 00:54:42,060
it's actually not very obvious so you

00:54:39,119 --> 00:54:45,540
wanted to hide that in in there so that

00:54:42,060 --> 00:54:47,310
you when you fetch these frames from the

00:54:45,540 --> 00:54:49,680
buffer you get it in the in the correct

00:54:47,310 --> 00:54:51,600
order that's optimal for that for the

00:54:49,680 --> 00:54:53,790
hardware with no order prefetches none

00:54:51,600 --> 00:54:56,940
of that has been implemented but that's

00:54:53,790 --> 00:54:59,609
a goal that we have I don't know what

00:54:56,940 --> 00:55:01,170
we'll get to but I would surprise if we

00:54:59,609 --> 00:55:02,910
can't get higher than this then I'll

00:55:01,170 --> 00:55:05,040
I'll eat my hat

00:55:02,910 --> 00:55:06,869
next net of you know you can put ketchup

00:55:05,040 --> 00:55:11,720
on it or something but we want to be

00:55:06,869 --> 00:55:11,720
stuffed at least okay thanks

00:55:24,620 --> 00:55:31,500
um I had a couple questions the first

00:55:28,170 --> 00:55:34,200
one was I assume you've got to deal with

00:55:31,500 --> 00:55:37,620
all these nasty cases like I got a

00:55:34,200 --> 00:55:40,020
malicious application that asks for a

00:55:37,620 --> 00:55:43,080
half packet before and then em I'm at em

00:55:40,020 --> 00:55:46,830
on maps the buffer that it told you was

00:55:43,080 --> 00:55:50,370
the ring and things like that or it

00:55:46,830 --> 00:55:52,290
crashes and rebounds and yeah and

00:55:50,370 --> 00:55:55,680
disables the record in the middle of it

00:55:52,290 --> 00:55:57,210
yes or at one of the processes just

00:55:55,680 --> 00:56:01,770
disables the record people that I want

00:55:57,210 --> 00:56:04,830
to keep sit on there's all those there's

00:56:01,770 --> 00:56:07,800
all these new corner cases the other one

00:56:04,830 --> 00:56:11,370
is part of the issue out a lot of these

00:56:07,800 --> 00:56:16,560
interfaces is how to do polling or an

00:56:11,370 --> 00:56:20,090
event based model application or one or

00:56:16,560 --> 00:56:23,280
the other or both or trading it off and

00:56:20,090 --> 00:56:27,630
that's often a very tough thing to deal

00:56:23,280 --> 00:56:31,740
with and on the VF side it would be nice

00:56:27,630 --> 00:56:35,220
to be able to do this on a VF because or

00:56:31,740 --> 00:56:37,020
a ring that's in some part of a VF

00:56:35,220 --> 00:56:40,110
because you could even get to the

00:56:37,020 --> 00:56:43,680
extreme of a docker container that wants

00:56:40,110 --> 00:56:48,660
to do this on a VF that's been passed to

00:56:43,680 --> 00:56:51,210
it so don't say it only works on the PF

00:56:48,660 --> 00:56:54,570
it only works on the host side because

00:56:51,210 --> 00:56:56,870
that will limit it a lot because the

00:56:54,570 --> 00:56:59,970
real problems we have today are

00:56:56,870 --> 00:57:03,120
networking that going through eight

00:56:59,970 --> 00:57:05,210
layers to get to an application and the

00:57:03,120 --> 00:57:08,100
latency performance is terrible because

00:57:05,210 --> 00:57:09,840
it's going through eight layers and I

00:57:08,100 --> 00:57:12,270
look at this is a great way to get rid

00:57:09,840 --> 00:57:14,340
of that if we can continue to make that

00:57:12,270 --> 00:57:17,540
punch through all the way up to the

00:57:14,340 --> 00:57:17,540
application yeah good point

00:57:18,200 --> 00:57:22,100
okay anyone else

00:57:24,700 --> 00:57:29,370
[Music]

00:57:26,150 --> 00:57:36,540
do we get lunch now we want to thank you

00:57:29,370 --> 00:57:38,720
first thank you so I can only give one

00:57:36,540 --> 00:57:38,720

YouTube URL: https://www.youtube.com/watch?v=RSFX7z1qF2g


