Title: Netdev 0.1 - Hardware Offloading BoF (Part 5 of 9) - IPQ806x Hardware Accelerator
Publication date: 2015-04-07
Playlist: Netdev 0.1 - Day 2 - Sunday February 15, 2015
Description: 
	IPQ806x Hardware Accelerator
Mathieu Olivari
February 2015

Part 5 of 9 in the Hardware Offloading BoF series

This video is licensed under Creative Commons Attribution-ShareAlike 4.0 International license. Feel free to download and distribute.
Captions: 
	00:00:05,040 --> 00:00:14,469
okay so so my name is a mature design I

00:00:08,830 --> 00:00:16,840
work for her welcome so the I I came

00:00:14,469 --> 00:00:20,020
with her so the idea was basically that

00:00:16,840 --> 00:00:23,489
we had this discussion on hardware

00:00:20,020 --> 00:00:26,380
acceleration of herding the cattle and

00:00:23,489 --> 00:00:29,619
we have met we have actual products

00:00:26,380 --> 00:00:32,920
today which are in production which are

00:00:29,619 --> 00:00:37,980
using a hardware acceleration a lot so

00:00:32,920 --> 00:00:42,339
we wanted to come and show what we did

00:00:37,980 --> 00:00:46,570
and how this product works maybe so I

00:00:42,339 --> 00:00:49,809
came my work constantly Nina I worker at

00:00:46,570 --> 00:00:54,489
in open wrt so we have an open debris

00:00:49,809 --> 00:00:58,659
artifact in ink working for the SOC

00:00:54,489 --> 00:01:00,940
infuse that we have I came with stolen

00:00:58,659 --> 00:01:04,890
been so that is the the brain of all

00:01:00,940 --> 00:01:07,030
this hardware acceleration so we the

00:01:04,890 --> 00:01:12,970
architecture he has been in place for 10

00:01:07,030 --> 00:01:14,350
years so the these products are the

00:01:12,970 --> 00:01:18,640
networking part of workers were

00:01:14,350 --> 00:01:21,610
previously atolls and you become there

00:01:18,640 --> 00:01:24,760
are mainly designed for home gateways so

00:01:21,610 --> 00:01:26,530
it's very different from the kind of

00:01:24,760 --> 00:01:32,020
products that we've been mostly talking

00:01:26,530 --> 00:01:35,290
about so far the IDS the these products

00:01:32,020 --> 00:01:38,260
contains a lot of features are on the

00:01:35,290 --> 00:01:40,750
same hardware so they are they need to

00:01:38,260 --> 00:01:45,190
be able to handle a lot of traffic for

00:01:40,750 --> 00:01:48,280
home so up to a gigabit plus 2 Wi-Fi so

00:01:45,190 --> 00:01:50,050
it's very important and it has to be

00:01:48,280 --> 00:01:54,250
done pretty much CPU which drives the

00:01:50,050 --> 00:01:58,470
needle acceleration and still we need to

00:01:54,250 --> 00:02:01,060
put in place a lot of firewall holes are

00:01:58,470 --> 00:02:06,130
some time do some deep packet inspection

00:02:01,060 --> 00:02:09,940
and no fancy features like that so the

00:02:06,130 --> 00:02:15,099
way we design this is a flow based off

00:02:09,940 --> 00:02:15,840
load most of the with most of the

00:02:15,099 --> 00:02:18,840
decision

00:02:15,840 --> 00:02:22,260
is actually happening in Linux and by

00:02:18,840 --> 00:02:26,599
design we really wanted to volley nukes

00:02:22,260 --> 00:02:26,599
to be the master for any kind of a flood

00:02:27,140 --> 00:02:35,250
so we basically try to leverage or the

00:02:32,010 --> 00:02:37,739
net filter whatever decision comes out

00:02:35,250 --> 00:02:41,340
of Linux we want to make sure that it

00:02:37,739 --> 00:02:44,190
goes in the hardware there's an idea we

00:02:41,340 --> 00:02:46,260
wanted it to be transparent without

00:02:44,190 --> 00:02:49,319
involved in any kind of user advanced

00:02:46,260 --> 00:02:51,660
configuration I same too so it's similar

00:02:49,319 --> 00:02:55,410
to like the idea that was presented

00:02:51,660 --> 00:02:59,160
previously and we have to accelerate our

00:02:55,410 --> 00:03:01,680
kind of protocol like anything you can

00:02:59,160 --> 00:03:08,160
find on the home network which is IP v4

00:03:01,680 --> 00:03:11,010
v6 not pppoe encapsulation l2tp and the

00:03:08,160 --> 00:03:14,569
line and we also she bought the hard

00:03:11,010 --> 00:03:14,569
work can accelerate also two disks

00:03:16,040 --> 00:03:21,510
another interesting that thing that the

00:03:19,440 --> 00:03:24,239
hard way is doing is for the statistics

00:03:21,510 --> 00:03:26,190
it's slightly different than what I was

00:03:24,239 --> 00:03:29,940
presented for the switch framework as an

00:03:26,190 --> 00:03:33,900
example where we don't create the

00:03:29,940 --> 00:03:36,420
statistics when we actually want to read

00:03:33,900 --> 00:03:39,470
the statistics the static city are

00:03:36,420 --> 00:03:42,720
automatically reported by the femur and

00:03:39,470 --> 00:03:44,519
the few muah the host is then like

00:03:42,720 --> 00:03:46,650
taking out the statistic and propagating

00:03:44,519 --> 00:03:49,819
them to the different network devices

00:03:46,650 --> 00:03:49,819
and contract and so on

00:03:51,910 --> 00:03:58,810
so the font and the way we designed this

00:03:55,540 --> 00:04:02,830
is because it's an architecture that's

00:03:58,810 --> 00:04:05,800
been in place for a long time it's been

00:04:02,830 --> 00:04:09,400
done in a modular way and we tried not

00:04:05,800 --> 00:04:13,030
to modify the linux kernel's internal so

00:04:09,400 --> 00:04:16,120
we have a separate database which

00:04:13,030 --> 00:04:19,000
actually sits on the post cutting wood

00:04:16,120 --> 00:04:21,100
so we registers and hedgehogs it scans

00:04:19,000 --> 00:04:24,880
the first packet and once we have a

00:04:21,100 --> 00:04:26,080
parser which passes it figures out the

00:04:24,880 --> 00:04:29,770
operation which has been done in the

00:04:26,080 --> 00:04:34,840
packet and instead the floor in the in

00:04:29,770 --> 00:04:37,900
DNS esta muerto gnss level we also

00:04:34,840 --> 00:04:41,650
interact so the basically the front end

00:04:37,900 --> 00:04:46,390
is a kind of monitoring or dis events in

00:04:41,650 --> 00:04:49,090
the system it enters the contract

00:04:46,390 --> 00:04:53,070
destroy on walls to know when the

00:04:49,090 --> 00:04:58,240
contract when the connection is dead and

00:04:53,070 --> 00:05:05,680
same thing for bonding and interface our

00:04:58,240 --> 00:05:08,620
events up down and so on so the TCP

00:05:05,680 --> 00:05:12,880
occasion is like very basic the NSS cool

00:05:08,620 --> 00:05:16,060
how can you go back a slide so the Linux

00:05:12,880 --> 00:05:21,430
contract that's in the stack itself not

00:05:16,060 --> 00:05:25,060
in yes so we had to what we do we are

00:05:21,430 --> 00:05:28,750
here to the weekend we actually put a

00:05:25,060 --> 00:05:31,600
mechanism which was removed in a 26 28 I

00:05:28,750 --> 00:05:36,850
believe to be notified whenever contract

00:05:31,600 --> 00:05:38,640
is a DDT our connection is DDT so we

00:05:36,850 --> 00:05:43,090
register into this mechanism and the

00:05:38,640 --> 00:05:44,800
contract then get notifies you whenever

00:05:43,090 --> 00:05:46,419
you digital connection so you can then

00:05:44,800 --> 00:05:48,940
propagate the information to the harbor

00:05:46,419 --> 00:05:51,040
ok so then on your packets per second I

00:05:48,940 --> 00:05:53,080
assume you weren't doing a connection

00:05:51,040 --> 00:05:55,750
turnover that was all fixed connection

00:05:53,080 --> 00:05:57,700
yes you might you might want to test it

00:05:55,750 --> 00:05:59,830
because in this model contract would be

00:05:57,700 --> 00:06:01,870
the bottleneck if you had a lot of

00:05:59,830 --> 00:06:06,160
connection terms that's just true

00:06:01,870 --> 00:06:10,390
so you I believe you you pay a little

00:06:06,160 --> 00:06:12,460
bit more in term of a cpu usage when you

00:06:10,390 --> 00:06:16,500
add in the deep contract but then all

00:06:12,460 --> 00:06:20,080
your flaws are all your flaws get

00:06:16,500 --> 00:06:21,670
offloaded anyway and for this kind of

00:06:20,080 --> 00:06:23,470
application which is a homo altar you're

00:06:21,670 --> 00:06:25,390
never going to get a million connection

00:06:23,470 --> 00:06:27,910
at the at the same time you are going to

00:06:25,390 --> 00:06:33,000
get maybe a 100,000 something like that

00:06:27,910 --> 00:06:39,190
which is a one application homo auto

00:06:33,000 --> 00:06:40,750
okay so I mean that yes but that's the

00:06:39,190 --> 00:06:48,010
kind of trade-off you can make on this

00:06:40,750 --> 00:06:52,420
product you begin so the gnss camera is

00:06:48,010 --> 00:06:54,100
very by default is very i would say done

00:06:52,420 --> 00:06:58,840
if you don't program it is going to

00:06:54,100 --> 00:07:01,720
forward everything to the host the net

00:06:58,840 --> 00:07:07,060
at the post hooding time the database is

00:07:01,720 --> 00:07:09,820
going to catch the packet and pass it if

00:07:07,060 --> 00:07:11,320
it's a packet or flow that we want to

00:07:09,820 --> 00:07:16,720
accelerate then is going to program the

00:07:11,320 --> 00:07:18,820
hardware and put it ask really quick how

00:07:16,720 --> 00:07:21,160
you decide if it should be offloaded to

00:07:18,820 --> 00:07:24,280
the hardware or not but and yeah and

00:07:21,160 --> 00:07:26,050
then maybe also do you allow for states

00:07:24,280 --> 00:07:27,730
where you have not everything that

00:07:26,050 --> 00:07:31,120
you're doing in software is offload the

00:07:27,730 --> 00:07:32,470
hardware because I mean the 11 model is

00:07:31,120 --> 00:07:34,210
to just mere everything but that's

00:07:32,470 --> 00:07:36,670
that's not a model that everybody wants

00:07:34,210 --> 00:07:38,110
to use right you there's a lot of cases

00:07:36,670 --> 00:07:40,570
where software wants to handle things on

00:07:38,110 --> 00:07:41,980
some unique way from hardware and so any

00:07:40,570 --> 00:07:46,980
model we have I think needs to support

00:07:41,980 --> 00:07:46,980
kind of both do you want to yeah

00:07:51,270 --> 00:07:56,199
so I'll help out a little here I'm Saul

00:07:54,249 --> 00:08:00,009
cavy by the way and i work for qualcomm

00:07:56,199 --> 00:08:02,409
obviously um the ECM the connection

00:08:00,009 --> 00:08:05,259
manager basically makes the decision by

00:08:02,409 --> 00:08:08,050
default that it is going to want to

00:08:05,259 --> 00:08:11,080
accelerate something it has hooks into

00:08:08,050 --> 00:08:13,719
it that basically our classifiers that

00:08:11,080 --> 00:08:15,939
it can do in line in the kernel as well

00:08:13,719 --> 00:08:18,669
as a net link out to user space

00:08:15,939 --> 00:08:20,979
application that would be able to make

00:08:18,669 --> 00:08:23,500
decisions right and we actually have

00:08:20,979 --> 00:08:26,800
examples of both of those and then they

00:08:23,500 --> 00:08:30,009
can essentially delay for a period of

00:08:26,800 --> 00:08:32,969
time or delay forever depending on what

00:08:30,009 --> 00:08:35,229
you're trying to do whether or not that

00:08:32,969 --> 00:08:37,709
connection will get accelerated or not

00:08:35,229 --> 00:08:41,010
whether or not something in Linux or in

00:08:37,709 --> 00:08:43,659
the linux networking in the kernel or

00:08:41,010 --> 00:08:46,240
something for whatever reason you decide

00:08:43,659 --> 00:08:49,660
you don't want to offload and accelerate

00:08:46,240 --> 00:08:52,240
the connection and so then then your

00:08:49,660 --> 00:08:54,339
your application will then tell Linux to

00:08:52,240 --> 00:08:58,290
program the flow in the hardware so the

00:08:54,339 --> 00:09:00,550
way this works is the just turn on okay

00:08:58,290 --> 00:09:04,600
the way this works is the connection

00:09:00,550 --> 00:09:07,660
manager wants to do the offload until

00:09:04,600 --> 00:09:09,220
some men of the classifiers say I've

00:09:07,660 --> 00:09:10,959
determined we're not off loading this at

00:09:09,220 --> 00:09:15,190
which point we give up trying to offload

00:09:10,959 --> 00:09:17,470
it so is the the policy then is part of

00:09:15,190 --> 00:09:19,930
the connection tracker in that kernel or

00:09:17,470 --> 00:09:21,610
sorry I'm a mess so our view on policy

00:09:19,930 --> 00:09:23,440
is very interesting it's been fun to

00:09:21,610 --> 00:09:26,290
actually listen to the discussion here

00:09:23,440 --> 00:09:29,079
because from our perspective our goal is

00:09:26,290 --> 00:09:31,209
that the NSS firmware and hardware make

00:09:29,079 --> 00:09:33,220
no policy decisions and we're offloading

00:09:31,209 --> 00:09:35,140
them to the colonel and of course the

00:09:33,220 --> 00:09:37,000
colonel networking guys say we don't

00:09:35,140 --> 00:09:39,459
want to make any policy decisions we're

00:09:37,000 --> 00:09:43,510
trying to offload that above above us to

00:09:39,459 --> 00:09:46,329
the layer on user space in truth this is

00:09:43,510 --> 00:09:48,310
left up to linux and we have customers

00:09:46,329 --> 00:09:50,500
that modify the connection manager to

00:09:48,310 --> 00:09:52,209
add their own things in fact whatever

00:09:50,500 --> 00:09:54,310
they want to do everyone's writing their

00:09:52,209 --> 00:09:56,980
own module to implement their policy in

00:09:54,310 --> 00:09:58,899
the kernel or or up into user space we

00:09:56,980 --> 00:10:00,699
have examples where when people have

00:09:58,899 --> 00:10:02,410
done it users and user space programs

00:10:00,699 --> 00:10:04,899
the hardware user space

00:10:02,410 --> 00:10:08,019
does not program their users proof user

00:10:04,899 --> 00:10:10,480
space says okay I'm willing to have you

00:10:08,019 --> 00:10:13,000
offload this and the connection manager

00:10:10,480 --> 00:10:15,750
is the actual thing that because what we

00:10:13,000 --> 00:10:18,550
do which is really interesting from a

00:10:15,750 --> 00:10:20,949
design perspective as we wanted linux to

00:10:18,550 --> 00:10:23,649
just work so we actually have to go in

00:10:20,949 --> 00:10:26,050
and well I won't let Matthew keep going

00:10:23,649 --> 00:10:33,220
ok let us get getraer and Matthew life I

00:10:26,050 --> 00:10:44,370
answer that question yeah so that's

00:10:33,220 --> 00:10:44,370
pretty much how it works thank you sigh

00:10:45,029 --> 00:10:50,139
so for the destroy all it's very similar

00:10:48,519 --> 00:10:53,649
so at this point the flu is actually I

00:10:50,139 --> 00:10:57,129
did the NSS film well if it sees a TCP

00:10:53,649 --> 00:10:58,569
packet are with the fin flag set is

00:10:57,129 --> 00:11:01,600
going to forward it automatically to

00:10:58,569 --> 00:11:04,149
linux can't hike will send an event a

00:11:01,600 --> 00:11:06,310
twitch will register to saying that the

00:11:04,149 --> 00:11:09,220
connection is destroyed and we forget

00:11:06,310 --> 00:11:16,199
propagate that to the cannon to the FML

00:11:09,220 --> 00:11:19,779
sorry and and and then what is removed

00:11:16,199 --> 00:11:23,529
so this is an example of the kind of API

00:11:19,779 --> 00:11:27,279
that the key my expects today so it's

00:11:23,529 --> 00:11:30,490
slightly a good similar ideas with the

00:11:27,279 --> 00:11:32,740
flow API legend presented our but it's

00:11:30,490 --> 00:11:35,459
it's clearly not the pipeline pipeline

00:11:32,740 --> 00:11:40,769
with one stage depends on how you see it

00:11:35,459 --> 00:11:45,540
we basically need 52 pearls if we need

00:11:40,769 --> 00:11:47,920
if we want to do like pvp encapsulation

00:11:45,540 --> 00:11:51,069
if you want to do any kind of course

00:11:47,920 --> 00:11:53,470
obviously PRI marketing then we can

00:11:51,069 --> 00:11:56,079
specify it also in the message same

00:11:53,470 --> 00:11:58,910
thing for the LAN and can do up to two

00:11:56,079 --> 00:12:03,230
villains so

00:11:58,910 --> 00:12:06,029
yeah the we also get similar message to

00:12:03,230 --> 00:12:08,730
that the Fiamma is sending to the host

00:12:06,029 --> 00:12:16,260
weekly to update stats for certain

00:12:08,730 --> 00:12:18,029
connection or for any net device so this

00:12:16,260 --> 00:12:22,260
is dissolved status message typically

00:12:18,029 --> 00:12:24,600
are the ECM so r is listening for these

00:12:22,260 --> 00:12:27,720
events and they are coming regularly

00:12:24,600 --> 00:12:30,660
it's like I think every second if I'm if

00:12:27,720 --> 00:12:33,230
I'm correct r and the auto kind of

00:12:30,660 --> 00:12:35,790
message are only per device is going to

00:12:33,230 --> 00:12:39,209
update of the device counter like it

00:12:35,790 --> 00:12:41,690
done at PvP and for the contract then

00:12:39,209 --> 00:12:44,130
going to lay the contract obviously a

00:12:41,690 --> 00:12:47,730
part of the modifications we had to do

00:12:44,130 --> 00:12:51,480
for that is we had to modify pretty much

00:12:47,730 --> 00:12:54,990
every protocol every encapsulation layer

00:12:51,480 --> 00:12:58,470
like pvp layer l2tp air so that it

00:12:54,990 --> 00:13:03,170
exposes interface to be able to update

00:12:58,470 --> 00:13:03,170
that from an external module

00:13:04,590 --> 00:13:11,820
and last but not least we have we the

00:13:10,260 --> 00:13:18,570
hard work and also do like you disk

00:13:11,820 --> 00:13:21,900
acceleration so with similar cutest that

00:13:18,570 --> 00:13:25,560
what is in the camera so pretty much the

00:13:21,900 --> 00:13:28,950
way it's implemented is it's basically

00:13:25,560 --> 00:13:32,220
we try to get this same behavior of the

00:13:28,950 --> 00:13:36,840
IQ disk in TC so same command same

00:13:32,220 --> 00:13:42,030
syntax just added the NSS prefix to the

00:13:36,840 --> 00:13:45,360
queue disk and and basically if you do

00:13:42,030 --> 00:13:47,580
that then we have a Semite module which

00:13:45,360 --> 00:13:49,410
would go take care of it and program the

00:13:47,580 --> 00:13:54,420
hard work accordingly so linux will be

00:13:49,410 --> 00:13:57,900
pretty much bathroom and all the two

00:13:54,420 --> 00:14:00,510
discs will happen in all the policy and

00:13:57,900 --> 00:14:06,450
scheduling will happen in the in the

00:14:00,510 --> 00:14:08,870
femoral yep any question oh so do you

00:14:06,450 --> 00:14:08,870
want to handle

00:14:11,019 --> 00:14:20,480
what does anybody it just it seems like

00:14:17,329 --> 00:14:24,620
we want to not embed the decision to

00:14:20,480 --> 00:14:27,310
always offload sometimes offload and you

00:14:24,620 --> 00:14:33,440
know I have this policy into the kernel

00:14:27,310 --> 00:14:34,970
and if you don't do that then it sounds

00:14:33,440 --> 00:14:37,870
like you need user space to tell you

00:14:34,970 --> 00:14:41,089
when to program flows into the kernel or

00:14:37,870 --> 00:14:42,529
into the into the hardware i'm doing i'm

00:14:41,089 --> 00:14:44,630
just trying to merge these two together

00:14:42,529 --> 00:14:46,490
so let me actually introduce Ben

00:14:44,630 --> 00:14:49,160
menchaca who's from the group that

00:14:46,490 --> 00:14:51,950
actually uses the same technology but

00:14:49,160 --> 00:14:55,120
from user space and have him talk some

00:14:51,950 --> 00:14:57,890
of how that sort of classification works

00:14:55,120 --> 00:14:59,360
yeah so first I think I would disagree a

00:14:57,890 --> 00:15:03,079
little bit was saying that it's it's

00:14:59,360 --> 00:15:06,019
done by the colonel it's done by the

00:15:03,079 --> 00:15:08,750
colonel in the same way that a contract

00:15:06,019 --> 00:15:09,980
creates connections right that's

00:15:08,750 --> 00:15:11,240
something that contract does that's

00:15:09,980 --> 00:15:13,130
inside the colonel that's done by the

00:15:11,240 --> 00:15:15,740
colonel but that doesn't mean that it's

00:15:13,130 --> 00:15:18,290
making policy decisions so the policies

00:15:15,740 --> 00:15:21,290
decisions are all made by sensors or

00:15:18,290 --> 00:15:23,839
detectors that plug in to ECM right

00:15:21,290 --> 00:15:25,449
which could be in our case for example

00:15:23,839 --> 00:15:28,130
it's something that runs in userspace

00:15:25,449 --> 00:15:30,829
listens to lib pcap you know

00:15:28,130 --> 00:15:32,570
statistically sampling connections makes

00:15:30,829 --> 00:15:34,519
decisions based on what the flow is

00:15:32,570 --> 00:15:36,320
whether or not to accelerate it if it's

00:15:34,519 --> 00:15:39,500
BitTorrent maybe we want to accelerate

00:15:36,320 --> 00:15:41,630
it if it's an HTTP flow maybe we want to

00:15:39,500 --> 00:15:43,220
do parental controls something like that

00:15:41,630 --> 00:15:47,029
and we don't want to accelerate it right

00:15:43,220 --> 00:15:50,570
so all the module is doing is just

00:15:47,029 --> 00:15:52,910
telling ACM the detector said yes or the

00:15:50,570 --> 00:15:55,880
titer said no there may be 10 of these

00:15:52,910 --> 00:15:57,949
detectors that register and all of them

00:15:55,880 --> 00:16:02,140
have to say yes or one of them has to

00:15:57,949 --> 00:16:02,140
say no for it to make a policy decision

00:16:02,529 --> 00:16:07,910
and the detectives are in user space or

00:16:05,360 --> 00:16:10,550
so they were in user space some of them

00:16:07,910 --> 00:16:12,649
are in kernel space different people so

00:16:10,550 --> 00:16:15,070
you know different third-party vendors

00:16:12,649 --> 00:16:17,510
may have already had their for example a

00:16:15,070 --> 00:16:19,430
virus detection or whatever it is they

00:16:17,510 --> 00:16:22,190
may have had it as a kernel module the

00:16:19,430 --> 00:16:25,449
API is both colonel API and then there's

00:16:22,190 --> 00:16:25,449
a net link API to user space

00:16:26,130 --> 00:16:31,240
so I think we're constantly having this

00:16:28,660 --> 00:16:36,010
discussion about so going back to the l3

00:16:31,240 --> 00:16:38,590
forwarding example in order to make IP

00:16:36,010 --> 00:16:40,840
route add commands behave transparently

00:16:38,590 --> 00:16:43,600
with a switch there's a certain minimal

00:16:40,840 --> 00:16:46,210
amount of policy necessary to realize

00:16:43,600 --> 00:16:48,670
that end result and that's this is kind

00:16:46,210 --> 00:16:51,910
of like another instance of that

00:16:48,670 --> 00:16:53,350
decision making process and it's we're

00:16:51,910 --> 00:16:55,240
always playing around where the wood to

00:16:53,350 --> 00:17:01,990
put this line and I know that's what

00:16:55,240 --> 00:17:03,910
you're really concerned about I think

00:17:01,990 --> 00:17:06,130
one of the differences in this case is

00:17:03,910 --> 00:17:08,230
that it's actually just flow offloading

00:17:06,130 --> 00:17:10,810
for individual flaws and it's completely

00:17:08,230 --> 00:17:12,070
transparent so it actually doesn't

00:17:10,810 --> 00:17:13,900
matter so much because of the

00:17:12,070 --> 00:17:15,910
transparency I mean they're supporting

00:17:13,900 --> 00:17:18,040
basically all the features they are not

00:17:15,910 --> 00:17:21,100
for userspace they're supporting the

00:17:18,040 --> 00:17:23,950
regular commands they are supporting

00:17:21,100 --> 00:17:26,080
let's say using bonding whatever all the

00:17:23,950 --> 00:17:28,780
features you can use so basically from

00:17:26,080 --> 00:17:30,340
the users user space perspective it's

00:17:28,780 --> 00:17:32,980
completely transparent it basically it

00:17:30,340 --> 00:17:34,540
doesn't exist so it really doesn't

00:17:32,980 --> 00:17:36,040
matter if you have a policy decision in

00:17:34,540 --> 00:17:38,530
the kernel or not I mean which they

00:17:36,040 --> 00:17:43,690
don't in the strict sense but it really

00:17:38,530 --> 00:17:45,310
doesn't matter actually I think so one

00:17:43,690 --> 00:17:47,590
of the things that we've done that a

00:17:45,310 --> 00:17:50,080
heck is interesting which ultimately is

00:17:47,590 --> 00:17:54,670
interesting in terms of this meeting is

00:17:50,080 --> 00:17:57,400
that Matthew talked about sort of what I

00:17:54,670 --> 00:18:00,790
call the touch points which are places

00:17:57,400 --> 00:18:04,930
in the linux kernel where today we

00:18:00,790 --> 00:18:06,970
either need information which we have

00:18:04,930 --> 00:18:10,330
trouble getting and therefore had to add

00:18:06,970 --> 00:18:13,420
an api or we want to give information ie

00:18:10,330 --> 00:18:15,220
typically statistics that we have that

00:18:13,420 --> 00:18:17,530
there's no concept in the linux kernel

00:18:15,220 --> 00:18:19,480
for updating and i think that one of the

00:18:17,530 --> 00:18:21,910
goals that we had was to make those

00:18:19,480 --> 00:18:26,320
touch points since we've now gone

00:18:21,910 --> 00:18:28,330
through a kernel version I you know sub

00:18:26,320 --> 00:18:30,310
number of girdle versions the goal

00:18:28,330 --> 00:18:32,950
clearly with that is to make those as

00:18:30,310 --> 00:18:34,510
light as possible and so one area of

00:18:32,950 --> 00:18:36,039
course that would help a great deal is

00:18:34,510 --> 00:18:39,039
to work through how

00:18:36,039 --> 00:18:41,200
we would get those into the upstream

00:18:39,039 --> 00:18:44,379
community so that we don't have to keep

00:18:41,200 --> 00:18:47,499
um you know essentially doing this each

00:18:44,379 --> 00:18:50,409
release and rather have them as part of

00:18:47,499 --> 00:18:52,899
how the native networking subsystems

00:18:50,409 --> 00:18:54,429
work so that's an area where r I'm

00:18:52,899 --> 00:18:56,440
actually interested in working with the

00:18:54,429 --> 00:19:00,239
upstream community I'd like to never

00:18:56,440 --> 00:19:04,179
support a touch point so to speak right

00:19:00,239 --> 00:19:06,429
some of someone from this site actually

00:19:04,179 --> 00:19:07,809
I actually but as you're the second pin

00:19:06,429 --> 00:19:13,149
to the system because normally on that

00:19:07,809 --> 00:19:15,609
side so I I think i mean i agree with

00:19:13,149 --> 00:19:17,590
patrick i'm wondering though if that ECM

00:19:15,609 --> 00:19:25,450
module could be generalized so other

00:19:17,590 --> 00:19:27,639
people could use it so yeah I I

00:19:25,450 --> 00:19:29,559
definitely think the answer is yes I

00:19:27,639 --> 00:19:31,359
also think at the same time it could

00:19:29,559 --> 00:19:33,429
probably be minimized a lot of the

00:19:31,359 --> 00:19:34,960
reason that we maintain ECM is because

00:19:33,429 --> 00:19:38,649
because of the patch sets that we

00:19:34,960 --> 00:19:41,259
currently choose to carry right so a lot

00:19:38,649 --> 00:19:44,249
of that data could so as an example with

00:19:41,259 --> 00:19:48,009
every connection currently we carry

00:19:44,249 --> 00:19:49,479
statistics in our database that you know

00:19:48,009 --> 00:19:51,549
that came from our firmware and then we

00:19:49,479 --> 00:19:53,229
update the contract database well if we

00:19:51,549 --> 00:19:54,789
had a hook directly in contract that

00:19:53,229 --> 00:19:57,369
would if a connection is marked as

00:19:54,789 --> 00:19:59,679
offloaded would go query a net device

00:19:57,369 --> 00:20:01,659
that we specify for stats or would query

00:19:59,679 --> 00:20:03,129
another table for stats we wouldn't have

00:20:01,659 --> 00:20:05,320
to maintain that in our database there's

00:20:03,129 --> 00:20:07,570
a list of those if we eliminate all of

00:20:05,320 --> 00:20:09,789
them we don't need to see it all so

00:20:07,570 --> 00:20:14,559
that's there's there's two house to that

00:20:09,789 --> 00:20:17,649
question I guess no yeah yeah ultimately

00:20:14,559 --> 00:20:20,169
you have to have something which is a

00:20:17,649 --> 00:20:22,450
policy based decision that says to

00:20:20,169 --> 00:20:24,429
accelerate or not to accelerate right if

00:20:22,450 --> 00:20:26,259
you're going to do DPI and you're doing

00:20:24,429 --> 00:20:28,929
that on the main CPU and you want to

00:20:26,259 --> 00:20:30,580
look at every packet you can't then at

00:20:28,929 --> 00:20:32,919
the same time decide to offload it so

00:20:30,580 --> 00:20:35,559
something right some piece of logic

00:20:32,919 --> 00:20:37,899
right and I personally don't want us

00:20:35,559 --> 00:20:40,840
carrying that logic I'd much prefer that

00:20:37,899 --> 00:20:44,619
logic be carried within Linux the ECM is

00:20:40,840 --> 00:20:46,840
serving that purpose today okay um do

00:20:44,619 --> 00:20:49,510
something super so the other thing we

00:20:46,840 --> 00:20:51,910
forgot to say the

00:20:49,510 --> 00:20:55,570
actually most of it is it's not upstream

00:20:51,910 --> 00:20:59,170
but it's open source so it's accessible

00:20:55,570 --> 00:21:06,340
and God or added on which is the website

00:20:59,170 --> 00:21:07,810
that quark amuse is to discuss it's open

00:21:06,340 --> 00:21:11,920
sourced but not upstream so it's all

00:21:07,810 --> 00:21:15,580
available on coda roar well we talked

00:21:11,920 --> 00:21:18,880
previously about the design concept wall

00:21:15,580 --> 00:21:20,950
privately and from my opinion for this

00:21:18,880 --> 00:21:23,080
kind of devices pretty much what I would

00:21:20,950 --> 00:21:24,850
have done it's pretty close to what I

00:21:23,080 --> 00:21:28,030
think is the correct way to do that

00:21:24,850 --> 00:21:29,920
except the pro sprouting hook my opinion

00:21:28,030 --> 00:21:31,480
it belongs into the device where you

00:21:29,920 --> 00:21:33,790
actually don't have to try to figure out

00:21:31,480 --> 00:21:35,770
how the packet got there you simply know

00:21:33,790 --> 00:21:38,670
it got there and at that point you don't

00:21:35,770 --> 00:21:40,810
have to do any analysis of routes of

00:21:38,670 --> 00:21:42,910
bonding or whatever you simply know the

00:21:40,810 --> 00:21:44,860
device cut here I have to the flow is

00:21:42,910 --> 00:21:46,900
here I have to offload it regarding the

00:21:44,860 --> 00:21:50,380
connection tracking hook that also makes

00:21:46,900 --> 00:21:52,270
sense to call down my opinion if this

00:21:50,380 --> 00:21:53,680
would be generalized I think it's

00:21:52,270 --> 00:21:55,300
perfectly fine to add something like

00:21:53,680 --> 00:21:57,220
that to connection tracking to query for

00:21:55,300 --> 00:21:58,570
life connections to get statistic

00:21:57,220 --> 00:22:02,440
updates and that's basically all you

00:21:58,570 --> 00:22:04,570
need i think and and the device starts

00:22:02,440 --> 00:22:06,640
thing that should be tied in with what

00:22:04,570 --> 00:22:07,840
rupa was talking about it that's one of

00:22:06,640 --> 00:22:10,450
the things we talked about when you're

00:22:07,840 --> 00:22:11,800
doing hardware offloads stats is one of

00:22:10,450 --> 00:22:13,720
the problems and we have to figure out a

00:22:11,800 --> 00:22:14,980
way to get that data back in so just

00:22:13,720 --> 00:22:17,520
like bridging we have this hook we're

00:22:14,980 --> 00:22:20,620
going to have a contract up to you yeah

00:22:17,520 --> 00:22:21,850
we should just build a generic hardware

00:22:20,620 --> 00:22:24,790
is going to give me some more

00:22:21,850 --> 00:22:27,610
information about this device hook for

00:22:24,790 --> 00:22:28,870
the connection tracking connection

00:22:27,610 --> 00:22:30,280
tracking offload what is actually

00:22:28,870 --> 00:22:32,320
important is to find out of the

00:22:30,280 --> 00:22:34,360
connection is still alive or not so why

00:22:32,320 --> 00:22:37,120
doing that you problem you will update

00:22:34,360 --> 00:22:40,300
the Congress as well yeah push but use

00:22:37,120 --> 00:22:43,960
the same method is what I'm saying yeah

00:22:40,300 --> 00:22:45,940
I guess for us we also have a switch

00:22:43,960 --> 00:22:47,920
device that we support in addition to

00:22:45,940 --> 00:22:50,050
this to this device and one of the

00:22:47,920 --> 00:22:51,910
difficulties that we have is from a

00:22:50,050 --> 00:22:53,800
software perspective recognizing that if

00:22:51,910 --> 00:22:55,960
we accelerate a connection in the switch

00:22:53,800 --> 00:22:58,150
which also has acceleration similar to

00:22:55,960 --> 00:22:59,890
what we do we lose all of those

00:22:58,150 --> 00:23:02,560
contracts stats and that's my intention

00:22:59,890 --> 00:23:03,340
and by design for that switch but being

00:23:02,560 --> 00:23:05,290
aware of that

00:23:03,340 --> 00:23:07,030
knowing as an application if I

00:23:05,290 --> 00:23:08,710
accelerate it there i'm losing my per

00:23:07,030 --> 00:23:10,360
connection statistics that's a very

00:23:08,710 --> 00:23:12,910
important thing and it's something that

00:23:10,360 --> 00:23:15,820
we can't we can't really know today

00:23:12,910 --> 00:23:17,680
about the hardware right do you want to

00:23:15,820 --> 00:23:19,960
lose your stats as them no no I don't

00:23:17,680 --> 00:23:22,420
want to but the point is if I chose to

00:23:19,960 --> 00:23:24,160
accelerate in the switch instead of

00:23:22,420 --> 00:23:27,400
choosing to accelerate in a system like

00:23:24,160 --> 00:23:29,530
this I lose contract updates i lose

00:23:27,400 --> 00:23:31,420
contract statistics user space is no

00:23:29,530 --> 00:23:33,370
longer rationale for the so what we do

00:23:31,420 --> 00:23:35,590
our answer to that is we create a tap

00:23:33,370 --> 00:23:37,840
device and we put the stats there yes so

00:23:35,590 --> 00:23:39,970
you still have the ability to query the

00:23:37,840 --> 00:23:44,400
stats and user space knows they exist

00:23:39,970 --> 00:23:49,270
it's just some devices don't you yeah

00:23:44,400 --> 00:23:53,430
okay so we are running low on time any

00:23:49,270 --> 00:23:58,680
other questions for matthew and qualcomm

00:23:53,430 --> 00:23:58,680

YouTube URL: https://www.youtube.com/watch?v=gci-pB9Fshk


