Title: Netdev 0.1 - Hardware Offloading BoF (Part 1 of 9)
Publication date: 2015-04-07
Playlist: Netdev 0.1 - Day 2 - Sunday February 15, 2015
Description: 
	Hardware Offloading BoF
Shrijeet Mukherjee
February 2015


Part 1 of 9 in the Hardware Offloading BoF series

Description from netdev01.org:
 Networking is all about interoperation and best way to achieve that is to use an open implementation with consistent interfaces as provided by the Linux kernel.

Currently packet processing offloading in Linux networking is being extended to support different capabilities which may have conflicting interests. A sample space is by:

    NICs that support acceleration of certain packet paths
        May include basic L2 processing
        May include flow processing
    Switches that support basic managed L2 support
    ASICs that support L2/3 and ACLs
    Switches that can pretend to be a multi-ported nic
    NICs that are multiported
        And support VEPA mode
        And support EVB mode
        Can learn, manage timers or need hypervisor/OS support to manage them
        PCIe level virtualization
    NPUs and speacial purpose packet processors that
        mangling operations in
        Load balancing at Application/L3/L2 layers
        IPSEC offload
        More complex flow graph offload

To provide uniformity in interfaces, the control interfaces via standard kernel APIs are used; and consensus needs to be reached on the different offload interfaces.

This BOF intends to bring together all the stakeholders and gather guidelines that need to be agreed upon so as to not stifle innovation, but also ensure that the concept of a Linux networking interfaces do not get diluted in the process. 


This video is licensed under Creative Commons Attribution-ShareAlike 4.0 International license. Feel free to download and distribute.
Captions: 
	00:00:03,259 --> 00:00:09,000
all right I guess we're gonna get

00:00:05,490 --> 00:00:14,009
started then I think I see everybody I

00:00:09,000 --> 00:00:14,790
need to see whereas the Feldman don't

00:00:14,009 --> 00:00:18,680
see a Furman

00:00:14,790 --> 00:00:18,680
there is the Feldman what what timing

00:00:24,670 --> 00:00:35,650
I heard anybody know anybody we should

00:00:28,450 --> 00:00:38,710
wait for we go alright so welcome

00:00:35,650 --> 00:00:40,840
everybody seemingly this buff is going

00:00:38,710 --> 00:00:42,699
to answer all of the universe's problems

00:00:40,840 --> 00:00:44,050
and questions and everything else in

00:00:42,699 --> 00:00:46,090
between

00:00:44,050 --> 00:00:49,960
so clearly the answer is going to be

00:00:46,090 --> 00:00:54,190
that we'll get nothing done but the the

00:00:49,960 --> 00:00:57,070
I actually wanted to cover two major

00:00:54,190 --> 00:00:59,140
points and I think it's it behooves us

00:00:57,070 --> 00:01:00,430
all as part of this community to keep

00:00:59,140 --> 00:01:02,799
that in mind for everything that we're

00:01:00,430 --> 00:01:05,590
going to talk about today the number one

00:01:02,799 --> 00:01:08,260
thing is that Linux as a networking

00:01:05,590 --> 00:01:10,799
model has to be something that we all

00:01:08,260 --> 00:01:14,710
have to preserve and work to preserving

00:01:10,799 --> 00:01:17,560
because if we don't have the ability to

00:01:14,710 --> 00:01:20,560
talk about the Linux networking stack as

00:01:17,560 --> 00:01:22,210
something that is inviolate that's

00:01:20,560 --> 00:01:24,130
something that's very predictable then

00:01:22,210 --> 00:01:25,720
the end result becomes that

00:01:24,130 --> 00:01:29,219
interoperation between different

00:01:25,720 --> 00:01:31,869
companies groups products technologies

00:01:29,219 --> 00:01:35,079
it runs the risk of going down the unix

00:01:31,869 --> 00:01:37,600
way right it's all perfectly symmetric

00:01:35,079 --> 00:01:39,250
and applicable as an API or as per

00:01:37,600 --> 00:01:40,719
standards but when you actually try to

00:01:39,250 --> 00:01:43,450
use it against each other it doesn't

00:01:40,719 --> 00:01:46,149
work and I think that's the only sort of

00:01:43,450 --> 00:01:48,310
high level theme that I want to make

00:01:46,149 --> 00:01:51,039
sure we all follow the second thing I

00:01:48,310 --> 00:01:52,960
want to say is that at least from my

00:01:51,039 --> 00:01:55,570
perspective the goal here is not to try

00:01:52,960 --> 00:01:58,509
to answer questions as much as not

00:01:55,570 --> 00:02:01,329
necessarily ask them but exchange ideas

00:01:58,509 --> 00:02:04,630
make sure that people who have if

00:02:01,329 --> 00:02:07,450
dissenting if open if at all opinions

00:02:04,630 --> 00:02:09,210
that say that might be popular consensus

00:02:07,450 --> 00:02:11,200
but that doesn't address my use case

00:02:09,210 --> 00:02:14,680
this would be the place to have that

00:02:11,200 --> 00:02:18,700
conversation so having said that I put

00:02:14,680 --> 00:02:20,860
together a fantasy agenda and we'll go

00:02:18,700 --> 00:02:22,810
through the list real quick and then

00:02:20,860 --> 00:02:25,170
you'll see some of the topics have names

00:02:22,810 --> 00:02:27,880
associated with them because people have

00:02:25,170 --> 00:02:31,240
upfront done some preparation for it and

00:02:27,880 --> 00:02:34,330
ask for slots in some cases I have put

00:02:31,240 --> 00:02:36,099
people's names there because it's good

00:02:34,330 --> 00:02:37,599
to surprise people from time to time so

00:02:36,099 --> 00:02:38,050
if you are seeing a name there for the

00:02:37,599 --> 00:02:45,250
first

00:02:38,050 --> 00:02:47,170
right now surprise and and I'm sure

00:02:45,250 --> 00:02:49,840
there are more people here who might

00:02:47,170 --> 00:02:51,370
want to talk about certain topics let's

00:02:49,840 --> 00:02:52,750
keep this informal the reason why we

00:02:51,370 --> 00:02:55,450
have a lot of time is we have two

00:02:52,750 --> 00:02:58,690
different sections or segments of time

00:02:55,450 --> 00:03:00,250
let's keep it open have the discussions

00:02:58,690 --> 00:03:02,410
we need to have which was why I was

00:03:00,250 --> 00:03:04,600
hoping we could all sit a little closer

00:03:02,410 --> 00:03:07,180
as a group but I was told for privacy

00:03:04,600 --> 00:03:10,060
reasons the video cameras will not swing

00:03:07,180 --> 00:03:13,540
to the back and if you're going to talk

00:03:10,060 --> 00:03:17,500
you'll have to come up here and and be

00:03:13,540 --> 00:03:21,400
in front of the camera so with that

00:03:17,500 --> 00:03:23,890
let's let the games begin unless there

00:03:21,400 --> 00:03:30,610
are other things points that people want

00:03:23,890 --> 00:03:32,560
to raise before we start okay so let's

00:03:30,610 --> 00:03:33,720
start with the topic that has seen some

00:03:32,560 --> 00:03:36,040
discussion

00:03:33,720 --> 00:03:37,810
Patrick was I was just talking with

00:03:36,040 --> 00:03:39,580
Patrick about this at lunch I know

00:03:37,810 --> 00:03:43,420
Patrick has had lots of discussions with

00:03:39,580 --> 00:03:46,709
the with the Linux networking heads so

00:03:43,420 --> 00:03:50,500
to say about it and that is mostly about

00:03:46,709 --> 00:03:53,440
about capacity management and explicit

00:03:50,500 --> 00:03:58,480
capability management whether or not we

00:03:53,440 --> 00:04:00,520
have a a box that is got some capability

00:03:58,480 --> 00:04:02,980
and whether we can extend that in

00:04:00,520 --> 00:04:05,620
software or not and whether we can

00:04:02,980 --> 00:04:07,300
handle for example more outs than what

00:04:05,620 --> 00:04:10,120
the hardware can do or more ACL than

00:04:07,300 --> 00:04:12,600
what the hardware can do or more bridge

00:04:10,120 --> 00:04:15,459
FTB entries and what the hardware can do

00:04:12,600 --> 00:04:17,560
me personally I think I have a very

00:04:15,459 --> 00:04:20,830
explicit position because we are very

00:04:17,560 --> 00:04:23,290
focused on the data center space and in

00:04:20,830 --> 00:04:25,150
that failure has to be deterministic and

00:04:23,290 --> 00:04:27,419
guaranteed if it's not going to work in

00:04:25,150 --> 00:04:30,820
Hardware it might as well not work but

00:04:27,419 --> 00:04:32,860
since Patrick you were talking about it

00:04:30,820 --> 00:04:38,230
maybe you want to suggest that you were

00:04:32,860 --> 00:04:43,080
talking about yeah right now why not

00:04:38,230 --> 00:04:43,080
I mean we can do it informative

00:04:59,420 --> 00:05:10,020
yeah well we were just talking about how

00:05:07,230 --> 00:05:13,110
to handle when hardware capacity is

00:05:10,020 --> 00:05:17,730
exceeded and the problem seems to be

00:05:13,110 --> 00:05:19,980
that it's hard to take individual when

00:05:17,730 --> 00:05:22,050
you offload routes and how to capacity

00:05:19,980 --> 00:05:23,430
is exceeded it's apparently hard to take

00:05:22,050 --> 00:05:24,900
individual routes out of hardware

00:05:23,430 --> 00:05:26,490
because you have a default route in

00:05:24,900 --> 00:05:28,680
hardware so basically you will change

00:05:26,490 --> 00:05:30,870
how Road and goes so this doesn't seem

00:05:28,680 --> 00:05:32,310
to be an option my question was whether

00:05:30,870 --> 00:05:35,520
it's possible to remove the default

00:05:32,310 --> 00:05:37,200
route at which point you get a lot more

00:05:35,520 --> 00:05:38,820
flexibility because you at that point

00:05:37,200 --> 00:05:41,070
you can take each individual route out

00:05:38,820 --> 00:05:44,040
and pass it to software without actually

00:05:41,070 --> 00:05:46,400
changing the packet flow well except for

00:05:44,040 --> 00:05:50,870
my not reordering issues of course but

00:05:46,400 --> 00:05:54,660
so again a lot more flexibility and I

00:05:50,870 --> 00:05:58,320
guess my point was it's best to have

00:05:54,660 --> 00:06:00,720
some automatic resolution mechanism the

00:05:58,320 --> 00:06:02,520
hopper provides some counters where you

00:06:00,720 --> 00:06:04,650
can actually measure activity of the

00:06:02,520 --> 00:06:05,910
router if they're used or not and if you

00:06:04,650 --> 00:06:08,130
have like five hundred thousand routes

00:06:05,910 --> 00:06:09,900
and offloaded to a hardware it's very

00:06:08,130 --> 00:06:12,660
likely that most of them won't be used

00:06:09,900 --> 00:06:15,120
at all so my opinion was if the default

00:06:12,660 --> 00:06:16,919
route is not very actively used because

00:06:15,120 --> 00:06:19,050
it's only used for local services like

00:06:16,919 --> 00:06:21,600
DNS resolution or something or that the

00:06:19,050 --> 00:06:23,550
best solution would be to simply take

00:06:21,600 --> 00:06:24,900
the default route out under the

00:06:23,550 --> 00:06:27,360
assumption that it's not seeing much

00:06:24,900 --> 00:06:29,430
traffic anyway and at that point you

00:06:27,360 --> 00:06:32,070
gain the flexibility to take all the

00:06:29,430 --> 00:06:34,880
inactive routes out and when you exceed

00:06:32,070 --> 00:06:37,050
hardware capabilities and basically the

00:06:34,880 --> 00:06:39,690
conflict resolution mechanism becomes

00:06:37,050 --> 00:06:41,160
very simple under the presumption that

00:06:39,690 --> 00:06:43,560
you are able to take out the default

00:06:41,160 --> 00:06:46,700
route and well that was basically our

00:06:43,560 --> 00:06:46,700
discussion during lunch

00:06:54,430 --> 00:06:59,130
I'm actually not sure why I'm holding

00:06:56,770 --> 00:07:01,600
the talk now

00:06:59,130 --> 00:07:05,980
hi this is kind of inevitable sie masz

00:07:01,600 --> 00:07:07,510
will get up here now so uh actually I

00:07:05,980 --> 00:07:13,630
had a discussion with Patrick last night

00:07:07,510 --> 00:07:15,040
on these topics too so uh so one of the

00:07:13,630 --> 00:07:17,470
things I want to address first off is

00:07:15,040 --> 00:07:20,770
that I think a primary goal in all this

00:07:17,470 --> 00:07:22,360
is that tools that work today continue

00:07:20,770 --> 00:07:23,950
to work whether you garlis it whether

00:07:22,360 --> 00:07:26,500
you have any hardware offloaded by 7:00

00:07:23,950 --> 00:07:28,570
tonight that being said this is how we

00:07:26,500 --> 00:07:30,100
get into this the discussion of what

00:07:28,570 --> 00:07:34,930
what do we do when capacity is reached

00:07:30,100 --> 00:07:38,080
etc etc initially there were some ideas

00:07:34,930 --> 00:07:41,290
whereabouts so ok so there come two

00:07:38,080 --> 00:07:44,620
realms of conflicting needs in this

00:07:41,290 --> 00:07:45,940
space ok so me as the kernel network and

00:07:44,620 --> 00:07:48,250
maintainer I want the comb to be as

00:07:45,940 --> 00:07:49,540
simple as possible so I like the things

00:07:48,250 --> 00:07:52,300
that are very simple and pop up all the

00:07:49,540 --> 00:07:55,120
policy up to the user space ok on the

00:07:52,300 --> 00:07:57,550
other hand users want things that just

00:07:55,120 --> 00:07:58,930
do what they've told them to do and if

00:07:57,550 --> 00:08:00,880
today with the software based

00:07:58,930 --> 00:08:03,850
implementation it does exit it probably

00:08:00,880 --> 00:08:06,880
should still do X in order to do that I

00:08:03,850 --> 00:08:08,410
can't meet my goal of maximal minimalism

00:08:06,880 --> 00:08:11,890
of the kernel there has to be some level

00:08:08,410 --> 00:08:14,080
of policy actually we talked about that

00:08:11,890 --> 00:08:16,300
yesterday during dinner and we were

00:08:14,080 --> 00:08:18,160
talking about not really the case they

00:08:16,300 --> 00:08:19,990
are facing and we were talking about a

00:08:18,160 --> 00:08:21,910
case where you have dealing with tens of

00:08:19,990 --> 00:08:24,040
routes but the hata apparently has kept

00:08:21,910 --> 00:08:26,050
its capacity for half a million routes

00:08:24,040 --> 00:08:27,460
so at that point the routes are not

00:08:26,050 --> 00:08:30,010
added manually anymore but it's

00:08:27,460 --> 00:08:32,170
definitely added by a demon so this is

00:08:30,010 --> 00:08:34,840
where you would where you can easily put

00:08:32,170 --> 00:08:37,840
the conflict resolution mechanism the

00:08:34,840 --> 00:08:39,670
kernel can't stay as simple and the case

00:08:37,840 --> 00:08:41,230
is different if you have like ten tens

00:08:39,670 --> 00:08:43,000
of Rods to offload at that point there

00:08:41,230 --> 00:08:45,340
will most likely be created manually and

00:08:43,000 --> 00:08:47,470
in that case if the user explicitly

00:08:45,340 --> 00:08:49,810
creates around my point of view is that

00:08:47,470 --> 00:08:51,550
it should become active and it should

00:08:49,810 --> 00:08:54,010
not fail the user explicitly told you

00:08:51,550 --> 00:08:57,040
you wants that route so for transparency

00:08:54,010 --> 00:08:58,870
reasons it should actually behave it

00:08:57,040 --> 00:09:00,640
should do what he told the hopper to do

00:08:58,870 --> 00:09:04,180
so if it can't handle that it should

00:09:00,640 --> 00:09:05,690
pull the rods out I agree and also at at

00:09:04,180 --> 00:09:07,400
the point in time

00:09:05,690 --> 00:09:09,740
that we're adding all these new

00:09:07,400 --> 00:09:12,410
facilities we also have to have a way to

00:09:09,740 --> 00:09:13,670
say please signal me an error if you

00:09:12,410 --> 00:09:15,590
can't fit it in the hardware I would

00:09:13,670 --> 00:09:17,000
like a notification oh okay that's one

00:09:15,590 --> 00:09:18,800
way of doing this yeah sure

00:09:17,000 --> 00:09:21,470
the other way is to take something like

00:09:18,800 --> 00:09:24,980
John pastor Ben's discovery mechanism

00:09:21,470 --> 00:09:26,330
and then it's your you you should figure

00:09:24,980 --> 00:09:28,400
out what the hardware is capable of

00:09:26,330 --> 00:09:29,180
doing and build your tables to that in

00:09:28,400 --> 00:09:31,190
that mechanism

00:09:29,180 --> 00:09:32,750
I completely agree um this also applies

00:09:31,190 --> 00:09:34,790
to the much smaller devices if you

00:09:32,750 --> 00:09:36,890
design some system based on some very

00:09:34,790 --> 00:09:38,750
small chip which only has capacity for

00:09:36,890 --> 00:09:40,640
like five routes and in my opinion it's

00:09:38,750 --> 00:09:42,470
your responsibility to take care of not

00:09:40,640 --> 00:09:44,480
exceeding these capabilities or else

00:09:42,470 --> 00:09:47,680
fall back to software but it's basically

00:09:44,480 --> 00:09:49,760
a system designers problem and not the

00:09:47,680 --> 00:09:53,030
kernel shouldn't be shouldn't deal with

00:09:49,760 --> 00:09:54,530
that stuff right so very beginning all

00:09:53,030 --> 00:09:56,780
the commands should just work as they do

00:09:54,530 --> 00:09:59,360
today yeah so that's the baseline that

00:09:56,780 --> 00:10:00,620
we have to deal with okay I want to also

00:09:59,360 --> 00:10:02,930
go on to something that Patrick

00:10:00,620 --> 00:10:06,190
discussed earlier the the large system

00:10:02,930 --> 00:10:08,720
versus the big system discussion I

00:10:06,190 --> 00:10:11,450
almost want to say that you don't want

00:10:08,720 --> 00:10:12,770
this what would a person who has the

00:10:11,450 --> 00:10:15,170
capacity for that and has that many

00:10:12,770 --> 00:10:16,670
routes what they're offloading is the

00:10:15,170 --> 00:10:18,020
fact that no matter what route lookup

00:10:16,670 --> 00:10:20,450
has asked me it will be done in hardware

00:10:18,020 --> 00:10:22,370
yeah right do you understand that we

00:10:20,450 --> 00:10:24,290
could because that that that's the do a

00:10:22,370 --> 00:10:25,670
seeing ability of the remote entity is

00:10:24,290 --> 00:10:27,590
that they can but they can get into a

00:10:25,670 --> 00:10:30,280
slow path of you absolutely my point

00:10:27,590 --> 00:10:33,170
with these half a million of routes was

00:10:30,280 --> 00:10:35,120
you will have the active routes will be

00:10:33,170 --> 00:10:37,430
specific routes the default route most

00:10:35,120 --> 00:10:39,590
likely will only be used for some local

00:10:37,430 --> 00:10:41,210
services like DNS or whatever um so the

00:10:39,590 --> 00:10:44,720
default route won't be aware we active

00:10:41,210 --> 00:10:46,850
rod which so you it's possible to push

00:10:44,720 --> 00:10:48,290
this one to the CPU if you don't have

00:10:46,850 --> 00:10:50,030
the default route at that point you gain

00:10:48,290 --> 00:10:51,530
a lot of flexibility in managing in

00:10:50,030 --> 00:10:53,089
deciding which one to take out and which

00:10:51,530 --> 00:10:54,860
one to leave in and the heart where

00:10:53,089 --> 00:10:57,200
apparently provides the information to

00:10:54,860 --> 00:10:59,480
make the decision right so actually we

00:10:57,200 --> 00:11:02,480
are doing exactly that today right so we

00:10:59,480 --> 00:11:04,760
use gleaning to learn

00:11:02,480 --> 00:11:06,589
you and we will send things up we don't

00:11:04,760 --> 00:11:09,199
send the default route up we say

00:11:06,589 --> 00:11:12,199
unlearned neighbors up today and it

00:11:09,199 --> 00:11:15,380
works reasonably well we let our resolve

00:11:12,199 --> 00:11:17,570
through the CPU and we eventually fill

00:11:15,380 --> 00:11:19,670
in the details default route has the

00:11:17,570 --> 00:11:22,029
potential of it being a meltdown case

00:11:19,670 --> 00:11:24,350
because you a poorly designed to work

00:11:22,029 --> 00:11:25,310
everyone is expecting all routes to be

00:11:24,350 --> 00:11:27,050
forwarded through the default route

00:11:25,310 --> 00:11:29,120
you'll have a problem but I think I

00:11:27,050 --> 00:11:31,760
think the the part that you were getting

00:11:29,120 --> 00:11:33,139
today was reasonably common enough right

00:11:31,760 --> 00:11:34,579
if you have a generic signaling

00:11:33,139 --> 00:11:37,130
mechanism and let's say the switch dev

00:11:34,579 --> 00:11:38,750
driver or whoever else as I mean

00:11:37,130 --> 00:11:41,329
actually in some sense this has to be

00:11:38,750 --> 00:11:44,029
the net there SRV all of those drivers

00:11:41,329 --> 00:11:48,440
saying I have a capacity that I am about

00:11:44,029 --> 00:11:50,089
to exceed and with some skid some user

00:11:48,440 --> 00:11:52,190
space policy manager has to tell me how

00:11:50,089 --> 00:11:54,350
I'm going to newly implemented

00:11:52,190 --> 00:11:57,649
user-space component yeah because

00:11:54,350 --> 00:11:59,630
everything exists right now the question

00:11:57,649 --> 00:12:00,920
is if it does need to be a new component

00:11:59,630 --> 00:12:02,600
I mean if you're dealing with half a

00:12:00,920 --> 00:12:04,160
million routes those routes will have

00:12:02,600 --> 00:12:05,449
been added by routing team and so let

00:12:04,160 --> 00:12:08,089
this one take care of the conflict

00:12:05,449 --> 00:12:10,069
resolution as well I guess what I'm

00:12:08,089 --> 00:12:12,610
saying is something like quagga could be

00:12:10,069 --> 00:12:12,610
exceeded

00:12:16,010 --> 00:12:23,510
another important point i want to make

00:12:18,139 --> 00:12:25,519
is it's not that i don't care exactly

00:12:23,510 --> 00:12:27,230
how these things are implemented but why

00:12:25,519 --> 00:12:29,569
do you care about our two things first

00:12:27,230 --> 00:12:31,220
is that we come to we decide what to do

00:12:29,569 --> 00:12:32,800
and then we have a very good story about

00:12:31,220 --> 00:12:35,959
why we made the decisions we made

00:12:32,800 --> 00:12:37,730
because someone's gonna say you've

00:12:35,959 --> 00:12:39,589
designed things in such a way that I

00:12:37,730 --> 00:12:41,480
don't think my Hardware component can

00:12:39,589 --> 00:12:42,829
optimally be supported by Linux it was

00:12:41,480 --> 00:12:44,449
that why did you make this trade-off we

00:12:42,829 --> 00:12:46,519
have to be able to tell them why we did

00:12:44,449 --> 00:12:48,079
everything we did so that's what's

00:12:46,519 --> 00:12:50,240
important to me because people are gonna

00:12:48,079 --> 00:12:51,470
tell me that we made a bad decision I'm

00:12:50,240 --> 00:12:54,470
gonna have to be come up with a good

00:12:51,470 --> 00:12:57,860
response to that challenge so so

00:12:54,470 --> 00:13:00,460
actually along those notes I don't know

00:12:57,860 --> 00:13:03,580
if people noticed

00:13:00,460 --> 00:13:05,560
we have an ether pad setup and Scot up

00:13:03,580 --> 00:13:07,230
here is going to be adding all the

00:13:05,560 --> 00:13:10,480
things that Dave and Patrick just said

00:13:07,230 --> 00:13:12,040
and and anybody else can go ahead and

00:13:10,480 --> 00:13:14,320
add them because this is one of the

00:13:12,040 --> 00:13:16,180
things that needs to come out of this

00:13:14,320 --> 00:13:19,720
meeting is some rationalization for all

00:13:16,180 --> 00:13:21,430
the thoughts that we write we were

00:13:19,720 --> 00:13:24,250
talking yesterday about adding specific

00:13:21,430 --> 00:13:27,130
flags to the route at command so you can

00:13:24,250 --> 00:13:29,980
say basically edit or Hardware fail and

00:13:27,130 --> 00:13:31,420
I was opposing that under the

00:13:29,980 --> 00:13:33,520
circumstances that you're dealing with

00:13:31,420 --> 00:13:36,340
our devices worry a few rules and it

00:13:33,520 --> 00:13:39,130
will happen with manually added rules if

00:13:36,340 --> 00:13:40,570
you have a routing daemon I don't uphold

00:13:39,130 --> 00:13:42,400
that point I think if you have a routing

00:13:40,570 --> 00:13:44,080
daemon this flag makes sense I guess for

00:13:42,400 --> 00:13:47,230
intelligence yes it seems to make sense

00:13:44,080 --> 00:13:49,930
to me for and also it's also valuable

00:13:47,230 --> 00:13:52,180
because that flag can be used on dumps

00:13:49,930 --> 00:13:54,940
to tell the user what entries are

00:13:52,180 --> 00:13:56,350
actually in the harddrive diagnosis and

00:13:54,940 --> 00:14:01,030
also for adding intelligence on the

00:13:56,350 --> 00:14:02,680
configuration side so there's one point

00:14:01,030 --> 00:14:05,170
which I don't think has been discussed

00:14:02,680 --> 00:14:08,670
very much which I sort of came up with

00:14:05,170 --> 00:14:13,750
that while reviewing John faster bans

00:14:08,670 --> 00:14:15,790
reads dump back on January 20th one of

00:14:13,750 --> 00:14:19,150
the things while offloading to Hardware

00:14:15,790 --> 00:14:21,610
is great we need some way to be able to

00:14:19,150 --> 00:14:25,420
to have the limits that the hardware has

00:14:21,610 --> 00:14:27,880
in software because otherwise people who

00:14:25,420 --> 00:14:30,040
are developing applications routing

00:14:27,880 --> 00:14:32,590
daemons protocol implementations and

00:14:30,040 --> 00:14:37,300
what aren't they won't be able to see

00:14:32,590 --> 00:14:40,260
how their their their work gets gets

00:14:37,300 --> 00:14:46,030
constrained by these things we have it

00:14:40,260 --> 00:14:47,530
it's called the rocker switch or you

00:14:46,030 --> 00:14:49,480
could we can make that software switch

00:14:47,530 --> 00:14:52,210
do what have whatever limitations you

00:14:49,480 --> 00:14:53,590
want to simulate and then you run it

00:14:52,210 --> 00:14:56,070
with the rocker switching qmu and see

00:14:53,590 --> 00:14:59,380
what happens with all your self-worth

00:14:56,070 --> 00:15:02,560
except I'm not willing to accept that

00:14:59,380 --> 00:15:04,300
the rocker switch is has the same

00:15:02,560 --> 00:15:06,820
limitations that a lot of things where

00:15:04,300 --> 00:15:08,920
it's a piece of software we can extend

00:15:06,820 --> 00:15:11,500
it to do whatever you would like so live

00:15:08,920 --> 00:15:12,329
the one complication that rocker would

00:15:11,500 --> 00:15:15,759
have a hard time

00:15:12,329 --> 00:15:17,860
emulating is the dynamic like the shared

00:15:15,759 --> 00:15:20,889
table case right where like if you if

00:15:17,860 --> 00:15:23,379
you had a LPM and you used v6 entries

00:15:20,889 --> 00:15:25,149
you might lose twice you might lose four

00:15:23,379 --> 00:15:27,189
times the capacity based on how things

00:15:25,149 --> 00:15:28,839
are tracked so I think the point Ben is

00:15:27,189 --> 00:15:31,480
making is we need a signaling mechanism

00:15:28,839 --> 00:15:32,920
that says here's the live state through

00:15:31,480 --> 00:15:35,019
the driver but that's a driver interface

00:15:32,920 --> 00:15:37,920
right it's something that can be

00:15:35,019 --> 00:15:41,680
presented through the driver interfaces

00:15:37,920 --> 00:15:43,300
yes yes to a degree I mean like a lot a

00:15:41,680 --> 00:15:45,730
lot of the complexities that you end up

00:15:43,300 --> 00:15:47,290
with in hardware some of the hardware

00:15:45,730 --> 00:15:49,059
that's out on the market like the the

00:15:47,290 --> 00:15:51,430
easy chip is one of these you can only

00:15:49,059 --> 00:15:55,629
do certain operations at certain

00:15:51,430 --> 00:15:58,480
pipeline stages and and the rocker you

00:15:55,629 --> 00:16:00,040
might be able to to put that in but I

00:15:58,480 --> 00:16:02,110
mean a lot of it is going to have to

00:16:00,040 --> 00:16:03,790
come back from the hardware vendors who

00:16:02,110 --> 00:16:06,879
are doing this they have to have to show

00:16:03,790 --> 00:16:10,089
us the the model that they require so

00:16:06,879 --> 00:16:11,649
that we can actually go and emulate it

00:16:10,089 --> 00:16:15,639
all I can take for this is that you want

00:16:11,649 --> 00:16:18,129
a facility but that is easy to provide a

00:16:15,639 --> 00:16:20,019
model that could be simulated in

00:16:18,129 --> 00:16:21,579
software and whether it's rocker chip

00:16:20,019 --> 00:16:22,839
the rocker chip driver or something else

00:16:21,579 --> 00:16:24,790
you don't care as long as you can

00:16:22,839 --> 00:16:27,660
simulate a capacity issue or a

00:16:24,790 --> 00:16:27,660
restriction

00:16:27,820 --> 00:16:32,290
can I have two thinks that first you

00:16:30,639 --> 00:16:33,370
don't know necessarily the underlying

00:16:32,290 --> 00:16:35,589
implementation of the hardware

00:16:33,370 --> 00:16:39,130
absolutely well do you get a multi-layer

00:16:35,589 --> 00:16:41,199
try doing various things and the number

00:16:39,130 --> 00:16:43,260
of layers are coming to the fact that

00:16:41,199 --> 00:16:46,120
are very hard to emulate without knowing

00:16:43,260 --> 00:16:47,889
extreme details of of the underlying

00:16:46,120 --> 00:16:50,800
forwarding plane the second point I

00:16:47,889 --> 00:16:53,889
wanted to bring up is as far as being

00:16:50,800 --> 00:16:56,529
able to swap out inactive routes you

00:16:53,889 --> 00:16:58,660
have to be prepared for very dramatic

00:16:56,529 --> 00:17:02,050
changes in networks if you have a large

00:16:58,660 --> 00:17:04,150
number of routes learn via BGP and then

00:17:02,050 --> 00:17:05,439
you have an IEP set of routes you may

00:17:04,150 --> 00:17:07,630
have a large number of routes that are

00:17:05,439 --> 00:17:10,480
completely inactive if you have an IVIG

00:17:07,630 --> 00:17:13,600
Peachy change that happens and all of a

00:17:10,480 --> 00:17:15,730
sudden half your routing table gets lit

00:17:13,600 --> 00:17:18,220
up that wasn't lit up before and that

00:17:15,730 --> 00:17:20,589
looks very disruptive to your network as

00:17:18,220 --> 00:17:22,360
you reinstall each of those routes to

00:17:20,589 --> 00:17:25,750
try to figure out what you can get rid

00:17:22,360 --> 00:17:28,179
of because your old routes are still not

00:17:25,750 --> 00:17:30,130
necessarily phased out to the point

00:17:28,179 --> 00:17:31,809
where you can make that decision so you

00:17:30,130 --> 00:17:34,179
can end up with a bubble in time where

00:17:31,809 --> 00:17:36,970
massive disruption is happening at your

00:17:34,179 --> 00:17:39,390
box we're a competitive Cisco box which

00:17:36,970 --> 00:17:42,810
happen to be still at capacity

00:17:39,390 --> 00:17:50,130
is going to be smooth so that's a

00:17:42,810 --> 00:17:52,500
challenge so full challenge yeah even

00:17:50,130 --> 00:17:55,110
even I think what Patrick's general

00:17:52,500 --> 00:17:57,090
model was it's a lazy update it's not

00:17:55,110 --> 00:17:59,580
you're not actively following the hot

00:17:57,090 --> 00:18:01,950
list it's really a capacity management

00:17:59,580 --> 00:18:03,660
thing right so if you say you you're at

00:18:01,950 --> 00:18:05,790
IUP flip you had a whole bunch of routes

00:18:03,660 --> 00:18:07,530
that went hot all of a sudden it's going

00:18:05,790 --> 00:18:09,270
to be lazily leaked in and you will see

00:18:07,530 --> 00:18:14,640
reorder for all the ones that went from

00:18:09,270 --> 00:18:17,340
software to hardware you're gonna see

00:18:14,640 --> 00:18:18,780
drops you're dropping but for the time

00:18:17,340 --> 00:18:20,070
being and you're also disruptive to the

00:18:18,780 --> 00:18:24,030
network at the point where you already

00:18:20,070 --> 00:18:26,040
had disruption yep so for a customer to

00:18:24,030 --> 00:18:26,520
deploy that that's a very very good

00:18:26,040 --> 00:18:28,980
point

00:18:26,520 --> 00:18:30,990
so what is this what is the solution to

00:18:28,980 --> 00:18:33,450
the capacity issue that doesn't add any

00:18:30,990 --> 00:18:36,300
disruption the solution that a capacity

00:18:33,450 --> 00:18:39,320
issue is to really understand that what

00:18:36,300 --> 00:18:41,700
you want to sell is a box that clearly

00:18:39,320 --> 00:18:45,450
does a certain thing when capacity is

00:18:41,700 --> 00:18:47,340
exceeded so in many boxes to swap out is

00:18:45,450 --> 00:18:50,190
exactly what you want particularly small

00:18:47,340 --> 00:18:51,030
little boxes like that edge routers sure

00:18:50,190 --> 00:18:54,000
it's awesome

00:18:51,030 --> 00:18:55,640
data center it's probably great what I'm

00:18:54,000 --> 00:18:58,530
saying is we also need another mechanism

00:18:55,640 --> 00:19:01,290
where you can say here's the capacity of

00:18:58,530 --> 00:19:04,650
the underlying thing quagga you need to

00:19:01,290 --> 00:19:05,880
break down and stop what well this is

00:19:04,650 --> 00:19:07,350
similar to the model that Jennifer and

00:19:05,880 --> 00:19:08,670
Cisco and Eric's and everybody else that

00:19:07,350 --> 00:19:10,800
I work with agree I mean the main

00:19:08,670 --> 00:19:13,740
problem is you're exceeding the limits

00:19:10,800 --> 00:19:16,020
so it's hard to have some clearly

00:19:13,740 --> 00:19:23,490
defined behavior after that the

00:19:16,020 --> 00:19:25,610
alternative it's an operational point of

00:19:23,490 --> 00:19:25,610
view

00:19:26,850 --> 00:19:30,899
what I'm saying is that you need both

00:19:31,950 --> 00:19:38,049
yeah that's of course I mean developer

00:19:35,470 --> 00:19:42,340
point of view I need to be able to say

00:19:38,049 --> 00:19:43,929
how my box is gonna work up - sure I

00:19:42,340 --> 00:19:45,429
mean the policy should be in user space

00:19:43,929 --> 00:19:47,440
and it should be of course I mean you

00:19:45,429 --> 00:19:49,749
can of course I guess implement multiple

00:19:47,440 --> 00:19:52,419
policies or make it programmable or

00:19:49,749 --> 00:19:54,190
something I just think the alternative

00:19:52,419 --> 00:19:57,639
we were talking about during the answer

00:19:54,190 --> 00:19:59,649
would be to have manually configured

00:19:57,639 --> 00:20:01,119
fall backs like pulling out individual

00:19:59,649 --> 00:20:02,619
host routes and falling back to some

00:20:01,119 --> 00:20:04,149
bigger prefix and taking some different

00:20:02,619 --> 00:20:06,129
route and hoping that the return traffic

00:20:04,149 --> 00:20:07,690
will still work and so on which also

00:20:06,129 --> 00:20:09,879
seems like a solution but it seems very

00:20:07,690 --> 00:20:10,809
difficult and labor-intensive to

00:20:09,879 --> 00:20:15,039
actually make this work

00:20:10,809 --> 00:20:16,450
so yes it's kind of your fault it seems

00:20:15,039 --> 00:20:17,649
like a problem but I would say it seems

00:20:16,450 --> 00:20:19,840
like a problem to actually do that I

00:20:17,649 --> 00:20:21,190
think a reasonable default I'm sure you

00:20:19,840 --> 00:20:23,139
might have a huge use case where it's

00:20:21,190 --> 00:20:24,609
not good enough but I think for default

00:20:23,139 --> 00:20:26,529
it seems to make sense to me to

00:20:24,609 --> 00:20:29,440
automatically well try to pull out stuff

00:20:26,529 --> 00:20:31,809
based on usage and if it's not good

00:20:29,440 --> 00:20:34,929
enough then you have to manually well

00:20:31,809 --> 00:20:37,419
specify a more fine great policy I think

00:20:34,929 --> 00:20:40,419
it's great to have that I'm saying yes

00:20:37,419 --> 00:20:42,730
from our boxes we want to be able to

00:20:40,419 --> 00:20:44,649
have multiple routing protocols or

00:20:42,730 --> 00:20:48,279
multiple routing suites be able to drop

00:20:44,649 --> 00:20:50,739
down on our box okay so in that world I

00:20:48,279 --> 00:20:52,600
don't want I want each one of those

00:20:50,739 --> 00:20:57,700
Suites to be able to get the feedback

00:20:52,600 --> 00:21:00,970
that I to be able to get the capability

00:20:57,700 --> 00:21:05,200
ahead of time so they don't because I

00:21:00,970 --> 00:21:09,580
can't fall back to the swap out yeah but

00:21:05,200 --> 00:21:12,789
so I'm given if you have this thing yeah

00:21:09,580 --> 00:21:14,679
yeah sure if you have this feedback like

00:21:12,789 --> 00:21:16,419
you know in advance at what point you

00:21:14,679 --> 00:21:18,730
will break down how would you prevent it

00:21:16,419 --> 00:21:19,989
this is so that's I mean the reason why

00:21:18,730 --> 00:21:23,230
part of the reason I wrote the flow API

00:21:19,989 --> 00:21:24,850
was to get this kind of ahead of time

00:21:23,230 --> 00:21:26,619
feedback right if you can look at the

00:21:24,850 --> 00:21:28,119
table and you kind of know the size and

00:21:26,619 --> 00:21:30,879
you know how its laid out you can know

00:21:28,119 --> 00:21:33,700
when it's gonna break and knowing when

00:21:30,879 --> 00:21:36,759
it's break now user space can adapt some

00:21:33,700 --> 00:21:38,169
policy on top of it I don't I might have

00:21:36,759 --> 00:21:38,590
a policy that I think is great and you

00:21:38,169 --> 00:21:40,509
might have

00:21:38,590 --> 00:21:42,399
you think is great and you might have a

00:21:40,509 --> 00:21:44,769
different one but but it's it's a user

00:21:42,399 --> 00:21:46,840
space problem now and the kernel isn't

00:21:44,769 --> 00:21:50,080
trying to enforce my version of a good

00:21:46,840 --> 00:21:52,690
policy yeah so we are about to exceed

00:21:50,080 --> 00:21:54,249
this slots time limit and I think we've

00:21:52,690 --> 00:21:56,860
generally agreed that it's a user space

00:21:54,249 --> 00:21:58,990
policy with a kernel driver indication

00:21:56,860 --> 00:22:02,139
but the colonel must have some minimal

00:21:58,990 --> 00:22:04,450
policy to make things work as is I think

00:22:02,139 --> 00:22:06,669
breaking existing model is not an option

00:22:04,450 --> 00:22:09,210
so minimal policy but some in the kernel

00:22:06,669 --> 00:22:13,049
and in the rest up to logic intelligence

00:22:09,210 --> 00:22:13,049
yeah sounds great

00:22:21,240 --> 00:22:32,679
how many penalty box so the next thing I

00:22:30,610 --> 00:22:34,960
want to talk about was just the device

00:22:32,679 --> 00:22:39,490
models that are emerging in the device

00:22:34,960 --> 00:22:41,649
driver for emerging mix emerging

00:22:39,490 --> 00:22:43,629
switches clearly we have a switch dev

00:22:41,649 --> 00:22:47,440
option that's going to go do its thing

00:22:43,629 --> 00:22:51,789
and we have the SR RV device drivers we

00:22:47,440 --> 00:22:53,470
have EVB implementations we have Peppa

00:22:51,789 --> 00:22:56,649
implementations this that and whatnot

00:22:53,470 --> 00:22:59,289
and and I think going forward I think

00:22:56,649 --> 00:23:01,389
it's important for us as a group to look

00:22:59,289 --> 00:23:02,710
at what is the baseline kind of like

00:23:01,389 --> 00:23:05,320
what you said yesterday what is the

00:23:02,710 --> 00:23:08,220
baseline of emerging Nix for example is

00:23:05,320 --> 00:23:10,509
learning a baseline feature or is

00:23:08,220 --> 00:23:12,970
unknown learning switches that also

00:23:10,509 --> 00:23:15,309
happen to have SRV something that we

00:23:12,970 --> 00:23:18,279
build the whole system around because if

00:23:15,309 --> 00:23:23,169
we say as a unified system that FTB down

00:23:18,279 --> 00:23:26,769
offload works the same way as on a enoch

00:23:23,169 --> 00:23:29,769
or eise which nick and on a physical

00:23:26,769 --> 00:23:32,409
switch it makes a lot of the user space

00:23:29,769 --> 00:23:35,139
policy application methods models

00:23:32,409 --> 00:23:37,029
understandings a lot simpler so i don't

00:23:35,139 --> 00:23:39,309
have a real answer then and for people

00:23:37,029 --> 00:23:42,399
who don't know in my past life I built a

00:23:39,309 --> 00:23:43,869
very fancy as Nick that has a funny

00:23:42,399 --> 00:23:45,190
characteristic that the software is

00:23:43,869 --> 00:23:48,629
available to everybody but most of

00:23:45,190 --> 00:23:49,810
you've never seen this is Co Nick but

00:23:48,629 --> 00:23:51,610
and

00:23:49,810 --> 00:23:54,430
the switches and I see that there's a

00:23:51,610 --> 00:23:56,080
lot of lot of friction in the two spaces

00:23:54,430 --> 00:23:59,830
and there doesn't need to be I think the

00:23:56,080 --> 00:24:01,450
models can be easy to unify it looks

00:23:59,830 --> 00:24:04,180
like Andy is trying to say something so

00:24:01,450 --> 00:24:06,340
we'll go with that well it's not

00:24:04,180 --> 00:24:08,920
exclusively answering your immediate

00:24:06,340 --> 00:24:10,960
question I just want to make sure that I

00:24:08,920 --> 00:24:12,730
can get a plug in for tomorrow I've

00:24:10,960 --> 00:24:13,660
given a kind of a kind of a talk on this

00:24:12,730 --> 00:24:14,710
I think it's probably a little bit

00:24:13,660 --> 00:24:17,020
outside of the scope of what we're doing

00:24:14,710 --> 00:24:18,550
here but I think it's clear that one of

00:24:17,020 --> 00:24:22,150
them the difficult challenges that we're

00:24:18,550 --> 00:24:23,800
seeing is that companies who have things

00:24:22,150 --> 00:24:24,820
that are companies who are wondering how

00:24:23,800 --> 00:24:26,770
to write a switch to have compatible

00:24:24,820 --> 00:24:29,260
driver are wondering where to go next

00:24:26,770 --> 00:24:31,630
and how to get there and we've spent the

00:24:29,260 --> 00:24:33,220
last like eight months talking and

00:24:31,630 --> 00:24:36,340
talking I think people are starting to

00:24:33,220 --> 00:24:38,110
understand but I don't want to beat that

00:24:36,340 --> 00:24:40,390
dead horse too much right now so 10:30

00:24:38,110 --> 00:24:42,340
tomorrow I'm not sure what room it'll be

00:24:40,390 --> 00:24:43,750
in but we'll talk about sort of a path

00:24:42,340 --> 00:24:50,410
and a progression if you're interested

00:24:43,750 --> 00:24:53,290
in opening up maybe you can explain I

00:24:50,410 --> 00:24:57,190
didn't 100% follow why what is the

00:24:53,290 --> 00:24:59,380
problem with learning capable Nick or

00:24:57,190 --> 00:25:00,910
speech versus in a non learning I just

00:24:59,380 --> 00:25:05,530
didn't 100% follow what would be the

00:25:00,910 --> 00:25:07,330
implication of requiring a support my

00:25:05,530 --> 00:25:10,030
point wasn't that there's a difference

00:25:07,330 --> 00:25:13,540
my point was if you say that layer 2

00:25:10,030 --> 00:25:17,230
behavior is X right the Linux kernel

00:25:13,540 --> 00:25:18,940
driver of flawed mechanism is X so if

00:25:17,230 --> 00:25:21,310
it's a layer to switch it fundamentally

00:25:18,940 --> 00:25:23,170
does learning it fundamentally does

00:25:21,310 --> 00:25:25,510
understand what's a local Mac what's a

00:25:23,170 --> 00:25:26,980
remote Mac maybe we can say it also

00:25:25,510 --> 00:25:29,800
fundamentally does be excellent given

00:25:26,980 --> 00:25:32,380
everything else we know that model

00:25:29,800 --> 00:25:35,650
doesn't need to be different between a

00:25:32,380 --> 00:25:37,450
vaper implementation which is actually

00:25:35,650 --> 00:25:38,080
so the problem okay maybe let's start it

00:25:37,450 --> 00:25:40,900
in Reverse

00:25:38,080 --> 00:25:43,720
the reason why we have Mac Veta Mac Vela

00:25:40,900 --> 00:25:46,150
and this mode and pass-through mode and

00:25:43,720 --> 00:25:48,370
add this and every obvious has been

00:25:46,150 --> 00:25:50,050
because a lot of different models have

00:25:48,370 --> 00:25:53,260
been trying to fit and we've tried to

00:25:50,050 --> 00:25:55,870
look for each model to reach its

00:25:53,260 --> 00:25:59,170
ultimate sort of manifestation the

00:25:55,870 --> 00:26:01,390
perfect ideal but if we had actually

00:25:59,170 --> 00:26:03,610
instead I think today's take a step back

00:26:01,390 --> 00:26:05,140
and we say there's a bunch of component

00:26:03,610 --> 00:26:06,610
functions that all of these guys do that

00:26:05,140 --> 00:26:08,470
are common right the bridging thing is

00:26:06,610 --> 00:26:11,470
fairly simple it looks up a Mac villain

00:26:08,470 --> 00:26:14,290
and it forwards always if it's going to

00:26:11,470 --> 00:26:16,299
do vapor sure it still a Mac we learn

00:26:14,290 --> 00:26:18,390
forward the offload can be something

00:26:16,299 --> 00:26:22,240
that the driver could hide for example

00:26:18,390 --> 00:26:23,950
so is the time now correct to take a

00:26:22,240 --> 00:26:26,190
step back and say all forward-looking

00:26:23,950 --> 00:26:28,660
drivers should unify to some common

00:26:26,190 --> 00:26:31,299
common functional behavior so the reason

00:26:28,660 --> 00:26:32,950
why I said learning was nixed

00:26:31,299 --> 00:26:35,380
traditionally even there Sarah vinick's

00:26:32,950 --> 00:26:37,750
have not had learning as an option but

00:26:35,380 --> 00:26:39,490
that's we can make that go away right I

00:26:37,750 --> 00:26:43,090
mean we can ask for it to go so you're

00:26:39,490 --> 00:26:44,320
really looking for a minimal set yeah my

00:26:43,090 --> 00:26:45,940
stipend would be I think it would be

00:26:44,320 --> 00:26:49,240
really helpful if we can bring all the

00:26:45,940 --> 00:26:51,070
DSA drivers switches on board as well so

00:26:49,240 --> 00:26:53,020
I think we should include them in this

00:26:51,070 --> 00:27:00,250
discussion they should be defining which

00:26:53,020 --> 00:27:06,100
is the minimal set of features gilad

00:27:00,250 --> 00:27:11,830
form easy cheap by the way hi I'm glad

00:27:06,100 --> 00:27:14,380
for me I am glad for me zi chip for

00:27:11,830 --> 00:27:16,360
those who don't know just like a

00:27:14,380 --> 00:27:19,750
sentence I really like the idea of like

00:27:16,360 --> 00:27:21,520
some common way so the kernel and

00:27:19,750 --> 00:27:24,340
certainly the users wouldn't care right

00:27:21,520 --> 00:27:25,960
at least for the common function there's

00:27:24,340 --> 00:27:28,720
just one danger I think we should be

00:27:25,960 --> 00:27:31,390
aware of we find a common function we

00:27:28,720 --> 00:27:32,620
should make sure we don't make it okay

00:27:31,390 --> 00:27:35,380
so we're going for the lowest common

00:27:32,620 --> 00:27:37,690
denominator right that's all right have

00:27:35,380 --> 00:27:39,880
something common absolutely we also have

00:27:37,690 --> 00:27:41,500
some way that if later you know we add

00:27:39,880 --> 00:27:43,150
something to do an external networking

00:27:41,500 --> 00:27:44,770
stack and there's some hundred can

00:27:43,150 --> 00:27:47,290
support this and maybe other that can

00:27:44,770 --> 00:27:49,419
that doesn't mean that we can't all flow

00:27:47,290 --> 00:27:51,250
to the huddlecam I kind of think that

00:27:49,419 --> 00:27:55,030
John festive in his approach gets us

00:27:51,250 --> 00:27:57,610
closer to that area so there's the two

00:27:55,030 --> 00:27:59,620
just two sides aspects of this I think

00:27:57,610 --> 00:28:02,410
John Foster Ben's work is great for the

00:27:59,620 --> 00:28:04,150
the end-all-be-all thing where you we

00:28:02,410 --> 00:28:05,530
know exactly the physical layout of the

00:28:04,150 --> 00:28:08,169
hardware and we can explicitly load

00:28:05,530 --> 00:28:10,570
filtering rules or forwarding database

00:28:08,169 --> 00:28:12,250
entries explicitly in any way shape or

00:28:10,570 --> 00:28:14,290
form and then build things on top of

00:28:12,250 --> 00:28:16,240
that at the same time I think it was

00:28:14,290 --> 00:28:17,170
also important that we had an explicit

00:28:16,240 --> 00:28:18,700
support

00:28:17,170 --> 00:28:21,160
for just bridge forwarding and now

00:28:18,700 --> 00:28:23,820
coming up with Scott Feldman's work

00:28:21,160 --> 00:28:26,530
explicitly supporting l-3 forwarding and

00:28:23,820 --> 00:28:28,510
learning how the trade-offs and the

00:28:26,530 --> 00:28:30,280
policy decisions work on there and then

00:28:28,510 --> 00:28:31,930
at some point in time maybe implement

00:28:30,280 --> 00:28:35,470
these things in terms of John festivals

00:28:31,930 --> 00:28:37,780
work so I think John stuff is more about

00:28:35,470 --> 00:28:39,490
maximum flexibility knowing exactly what

00:28:37,780 --> 00:28:40,870
the hardware is capable of and then that

00:28:39,490 --> 00:28:42,370
would allow us to build things on top of

00:28:40,870 --> 00:28:43,840
it but in the beginning we have to work

00:28:42,370 --> 00:28:50,950
on specific problems and see how they

00:28:43,840 --> 00:28:53,350
work out including Nicks and everything

00:28:50,950 --> 00:28:57,910
right I mean I mean John's just John's

00:28:53,350 --> 00:28:59,350
work could be used to expose yeah it's

00:28:57,910 --> 00:29:04,360
not geared to that now but there's

00:28:59,350 --> 00:29:07,930
nothing blocking it from doing so so I

00:29:04,360 --> 00:29:11,290
look to comment like to add a comment so

00:29:07,930 --> 00:29:14,050
John Foster Ben's be all you can be

00:29:11,290 --> 00:29:19,930
and this gentleman's here they may be

00:29:14,050 --> 00:29:24,430
slightly different use cases you you

00:29:19,930 --> 00:29:28,480
wanna speak okay you you've been put on

00:29:24,430 --> 00:29:31,330
the spot so you know those John's is

00:29:28,480 --> 00:29:34,630
very old level he's is much higher level

00:29:31,330 --> 00:29:37,840
building blocks so if we're gonna cut

00:29:34,630 --> 00:29:39,550
off for everybody then I'm okay with

00:29:37,840 --> 00:29:41,260
having three abstractions it's a I

00:29:39,550 --> 00:29:43,320
figure out where what we should do all

00:29:41,260 --> 00:29:43,320
right

00:29:44,750 --> 00:29:47,919
well you know what

00:29:55,420 --> 00:30:04,420
you think you did maybe I can say two

00:30:01,720 --> 00:30:06,130
things I'd be happy to have bigger

00:30:04,420 --> 00:30:07,540
building blocks on top the flow API if

00:30:06,130 --> 00:30:09,280
there's a way we can do it or maybe we

00:30:07,540 --> 00:30:11,980
can model bigger blocks in terms of the

00:30:09,280 --> 00:30:14,260
flow API not opposed to working it as

00:30:11,980 --> 00:30:15,670
needed and then the other thing I think

00:30:14,260 --> 00:30:18,130
there was a question about a software

00:30:15,670 --> 00:30:20,650
testable thing earlier yeah one idea I

00:30:18,130 --> 00:30:23,290
had was to if you could use the flow API

00:30:20,650 --> 00:30:25,630
to query the device a real device and

00:30:23,290 --> 00:30:29,110
then we could use it to initialize

00:30:25,630 --> 00:30:30,550
Rocker I'm looking at Scot maybe but I

00:30:29,110 --> 00:30:33,640
think that'd be cool because then you

00:30:30,550 --> 00:30:35,950
have a rocker where you kind of have a

00:30:33,640 --> 00:30:37,240
world that map to of the hardware device

00:30:35,950 --> 00:30:39,070
and we could kind of do this

00:30:37,240 --> 00:30:48,820
automatically right as we load rocker

00:30:39,070 --> 00:30:50,890
right so just a question or comment

00:30:48,820 --> 00:30:53,050
whatever about that

00:30:50,890 --> 00:30:55,240
we keep talking about how to offload

00:30:53,050 --> 00:30:56,470
which is which is fine you know I work

00:30:55,240 --> 00:30:59,170
for a hardware company but I keep

00:30:56,470 --> 00:31:01,510
thinking where's the hardware and

00:30:59,170 --> 00:31:03,790
offload right and what I mean by that is

00:31:01,510 --> 00:31:06,490
if you have a Linux system and it's

00:31:03,790 --> 00:31:09,340
running just for an example okay in a

00:31:06,490 --> 00:31:11,050
virtual machine anything outside it that

00:31:09,340 --> 00:31:13,390
they can request services via the flow

00:31:11,050 --> 00:31:16,030
API is offload does it have to be

00:31:13,390 --> 00:31:18,520
Hardware no it could be you know V

00:31:16,030 --> 00:31:20,650
switch or whatever and the reason I

00:31:18,520 --> 00:31:23,560
think it's important that is that once

00:31:20,650 --> 00:31:25,420
you realize it's offload not Hardware

00:31:23,560 --> 00:31:27,850
offload you realize we're really talking

00:31:25,420 --> 00:31:29,710
about enabling Linux to do some kind of

00:31:27,850 --> 00:31:31,930
distributed data plane now it sounds

00:31:29,710 --> 00:31:33,850
like a big name but and the reason

00:31:31,930 --> 00:31:36,490
that's important and great is what

00:31:33,850 --> 00:31:38,350
you're saying is that we already have

00:31:36,490 --> 00:31:41,620
you know if we want and can hook it hook

00:31:38,350 --> 00:31:43,690
it up something that will let us play

00:31:41,620 --> 00:31:45,730
out all the limits and so on once you

00:31:43,690 --> 00:31:47,350
don't say it's a hard work now you're

00:31:45,730 --> 00:31:49,090
just saying I'm talking something can

00:31:47,350 --> 00:31:51,730
give you these listed services I don't

00:31:49,090 --> 00:31:53,740
care how it does it right so open V

00:31:51,730 --> 00:31:55,930
switch can connect it to a rocker or

00:31:53,740 --> 00:31:57,370
something can be that thing right it's

00:31:55,930 --> 00:32:00,190
definitely the case that someone's gonna

00:31:57,370 --> 00:32:02,550
try to provide hypervisor virtualization

00:32:00,190 --> 00:32:05,160
support for switch off loads

00:32:02,550 --> 00:32:06,990
through the host so that would be useful

00:32:05,160 --> 00:32:09,330
as well because someone's gonna have to

00:32:06,990 --> 00:32:11,340
provide a model and export what what the

00:32:09,330 --> 00:32:15,210
your part of the capabilities are able

00:32:11,340 --> 00:32:17,550
to do my comment is is just and I'm

00:32:15,210 --> 00:32:19,470
ending here but be really useful to stop

00:32:17,550 --> 00:32:21,090
talking about the harder offload even

00:32:19,470 --> 00:32:26,400
though you know I'm a hardware guy is

00:32:21,090 --> 00:32:28,890
just offloaded ok thank you so so so the

00:32:26,400 --> 00:32:32,610
question that arises to me and in having

00:32:28,890 --> 00:32:35,220
looked at John's patches is that they

00:32:32,610 --> 00:32:37,860
don't too much is left up to the drivers

00:32:35,220 --> 00:32:40,680
we need if we're going to go down this

00:32:37,860 --> 00:32:42,840
path of using this as a new model for

00:32:40,680 --> 00:32:45,420
things we have to define the building

00:32:42,840 --> 00:32:46,800
blocks and such and it will end up being

00:32:45,420 --> 00:32:49,290
that there are there are quite a few

00:32:46,800 --> 00:32:51,210
different ones of them like for example

00:32:49,290 --> 00:32:54,090
the realtek chip that i've been playing

00:32:51,210 --> 00:33:00,410
with it has the interesting quirk that

00:32:54,090 --> 00:33:02,760
it's a combination hash table + cam and

00:33:00,410 --> 00:33:04,800
different hardware have different

00:33:02,760 --> 00:33:06,660
hashing algorithms have different sizes

00:33:04,800 --> 00:33:09,780
of cams different restrictions on where

00:33:06,660 --> 00:33:12,450
you can put entries and all this and if

00:33:09,780 --> 00:33:14,460
we just leave it as wide open we're like

00:33:12,450 --> 00:33:16,920
John has in places where it's defining

00:33:14,460 --> 00:33:19,170
some of these elements of the pipeline

00:33:16,920 --> 00:33:21,210
using strings to identify them we don't

00:33:19,170 --> 00:33:24,690
know what the the characteristics and

00:33:21,210 --> 00:33:26,940
behavior of the MIS it's my opinion and

00:33:24,690 --> 00:33:29,250
my belief that we should be adding any

00:33:26,940 --> 00:33:32,190
of the the the buildings blocks that

00:33:29,250 --> 00:33:34,920
actual Hardware uses we should have a

00:33:32,190 --> 00:33:37,680
software implementation that that does

00:33:34,920 --> 00:33:41,280
something similar to this and III don't

00:33:37,680 --> 00:33:43,590
think that we can necessarily want to

00:33:41,280 --> 00:33:46,560
have to rely on it being an external

00:33:43,590 --> 00:33:50,840
part of something like queuing them but

00:33:46,560 --> 00:33:53,060
I mean that's how about other people

00:33:50,840 --> 00:33:54,380
you have any ideas about modeling a

00:33:53,060 --> 00:33:58,220
hardware that does something like that

00:33:54,380 --> 00:34:03,890
so maybe I what I would say is is is the

00:33:58,220 --> 00:34:05,630
T cam implementation particularly

00:34:03,890 --> 00:34:07,130
important I mean can we I think we need

00:34:05,630 --> 00:34:09,470
to abstract whether it's a tkm whether

00:34:07,130 --> 00:34:11,930
it's a some kind of other implementation

00:34:09,470 --> 00:34:13,520
that's not yes but there are lots of t

00:34:11,930 --> 00:34:15,100
camera implementations out of there and

00:34:13,520 --> 00:34:17,510
they all have slightly different

00:34:15,100 --> 00:34:19,850
restrictions on so what they can so one

00:34:17,510 --> 00:34:21,110
thing I had is in the in the table

00:34:19,850 --> 00:34:23,480
layout of those patches there's table

00:34:21,110 --> 00:34:25,400
attributes and what I was thinking one

00:34:23,480 --> 00:34:27,080
thought I had was that if your table

00:34:25,400 --> 00:34:28,610
behaved some slightly way different we

00:34:27,080 --> 00:34:31,610
could standardize a set of attributes

00:34:28,610 --> 00:34:32,960
that describe it yes but going to be a

00:34:31,610 --> 00:34:34,250
little careful to keep that set minimal

00:34:32,960 --> 00:34:36,530
right we don't want to have a burr

00:34:34,250 --> 00:34:39,680
device but we also need to have code

00:34:36,530 --> 00:34:41,750
that shows us this is how it behaves if

00:34:39,680 --> 00:34:48,140
I don't have hardware X yet I want to

00:34:41,750 --> 00:34:50,000
know how it which I I wouldn't be

00:34:48,140 --> 00:34:52,520
opposed to doing that on my Crocker okay

00:34:50,000 --> 00:34:53,990
right I really but then you're going to

00:34:52,520 --> 00:34:55,720
end up in the same problem that you were

00:34:53,990 --> 00:34:58,340
actually pointing out earlier which is

00:34:55,720 --> 00:35:00,560
so for example you might say I have a

00:34:58,340 --> 00:35:03,230
slow T cam that requires special gated

00:35:00,560 --> 00:35:06,080
access to lines because it's optimized

00:35:03,230 --> 00:35:09,800
for the fast access path and your slow

00:35:06,080 --> 00:35:12,200
method might be different from John slow

00:35:09,800 --> 00:35:13,820
method and in your case it's do

00:35:12,200 --> 00:35:16,280
individual rights in John's case it's

00:35:13,820 --> 00:35:18,520
send a bunch of Pio rights and wait for

00:35:16,280 --> 00:35:20,750
an acknowledge and then send a DMA and I

00:35:18,520 --> 00:35:22,160
don't think we're at this point yeah I

00:35:20,750 --> 00:35:23,390
think yeah we have to build the

00:35:22,160 --> 00:35:25,150
infrastructure first and then decide

00:35:23,390 --> 00:35:27,620
what we're going to plop on top of it

00:35:25,150 --> 00:35:29,990
another thing I want to bring up in this

00:35:27,620 --> 00:35:32,600
discussion is every single person I've

00:35:29,990 --> 00:35:35,410
talked to as a different a has a

00:35:32,600 --> 00:35:37,850
different opinion on policy B is

00:35:35,410 --> 00:35:40,820
familiar with zero or one implementation

00:35:37,850 --> 00:35:44,240
of these things there are a few people I

00:35:40,820 --> 00:35:46,190
just I talked to a note two or more so I

00:35:44,240 --> 00:35:47,660
think there's a learning process for a

00:35:46,190 --> 00:35:49,280
lot of people figuring out what the

00:35:47,660 --> 00:35:51,290
scope actual scope is out there for what

00:35:49,280 --> 00:35:52,280
hard work can do and I think maybe we're

00:35:51,290 --> 00:35:53,570
going to get some of that out of this

00:35:52,280 --> 00:35:55,940
discussion here because we have people

00:35:53,570 --> 00:35:57,560
talking about specific needs but I don't

00:35:55,940 --> 00:35:59,450
want to get tangled into details of what

00:35:57,560 --> 00:36:01,700
every single person does we can hash it

00:35:59,450 --> 00:36:03,680
out on the mailing list for discussion

00:36:01,700 --> 00:36:05,660
that's something I absolutely agree with

00:36:03,680 --> 00:36:09,380
that Jerry Jerry and I were talking

00:36:05,660 --> 00:36:13,309
about that over lunch and you even with

00:36:09,380 --> 00:36:15,980
John earlier and yes we do need to start

00:36:13,309 --> 00:36:18,380
getting code that shows some of what

00:36:15,980 --> 00:36:20,809
this is out there so that we can start

00:36:18,380 --> 00:36:22,880
figuring out what parts are common and

00:36:20,809 --> 00:36:25,000
what part parts it's the reason we have

00:36:22,880 --> 00:36:28,460
the rocket driver because there was no

00:36:25,000 --> 00:36:33,859
diving board that could get us going we

00:36:28,460 --> 00:36:36,200
had to create ourselves so so that's a

00:36:33,859 --> 00:36:38,089
I'm sure nobody read the screen but

00:36:36,200 --> 00:36:40,549
that's actually the next topic which is

00:36:38,089 --> 00:36:42,430
managed it's perfect it's manage things

00:36:40,549 --> 00:36:44,930
as discrete devices or as generic

00:36:42,430 --> 00:36:47,240
pipelines and it sounds like what we

00:36:44,930 --> 00:36:49,430
just said is try to build a generic

00:36:47,240 --> 00:36:51,950
pipeline using flow API components for

00:36:49,430 --> 00:36:54,019
now and we'll call them discrete devices

00:36:51,950 --> 00:36:57,170
and maybe over time discrete device

00:36:54,019 --> 00:37:05,329
models will emerge and we will go from

00:36:57,170 --> 00:37:07,420
there I just wanted to say a few word so

00:37:05,329 --> 00:37:10,099
it's most of the time it is true that

00:37:07,420 --> 00:37:11,809
whoever's working for vendor like into

00:37:10,099 --> 00:37:13,910
like John familiar with Intel stuff so

00:37:11,809 --> 00:37:15,859
just like one implementation 100 there

00:37:13,910 --> 00:37:18,559
is somebody is the chip guys like only

00:37:15,859 --> 00:37:20,539
familiar with is the chip I sort of

00:37:18,559 --> 00:37:22,640
actually have a luxury to know several

00:37:20,539 --> 00:37:24,319
different implementation but they cannot

00:37:22,640 --> 00:37:27,650
share any of the stuff because of

00:37:24,319 --> 00:37:30,200
India's so the prent I think that we're

00:37:27,650 --> 00:37:32,089
where I'm going with this the troika is

00:37:30,200 --> 00:37:34,759
actually the framework for all of us to

00:37:32,089 --> 00:37:35,869
share our internal implementations for

00:37:34,759 --> 00:37:38,720
all the vendors out of the

00:37:35,869 --> 00:37:41,480
interrelationship metronome everyone

00:37:38,720 --> 00:37:43,819
Mellanox rocker is a free place to

00:37:41,480 --> 00:37:45,410
expose not your internal details around

00:37:43,819 --> 00:37:48,619
those secrets that you have in a

00:37:45,410 --> 00:37:50,059
hardware but of how the subtle features

00:37:48,619 --> 00:37:53,180
of the hardware that you plan in to do

00:37:50,059 --> 00:37:54,619
and I think that's based on this common

00:37:53,180 --> 00:37:56,359
common framework we'll be able to

00:37:54,619 --> 00:37:59,589
actually define the proper areas on top

00:37:56,359 --> 00:37:59,589
how to expose it and so on

00:38:02,300 --> 00:38:07,260
good point

00:38:04,230 --> 00:38:09,800
anybody with those India's want to stand

00:38:07,260 --> 00:38:09,800
up and explain

00:38:19,500 --> 00:38:23,290
just for the benefit of anybody who

00:38:21,970 --> 00:38:24,880
hasn't looked at your patch series John

00:38:23,290 --> 00:38:26,320
can you kind of go into a little bit of

00:38:24,880 --> 00:38:28,390
detail as what some of the primitives of

00:38:26,320 --> 00:38:31,109
your flow api is so that you can kind of

00:38:28,390 --> 00:38:37,630
understand what the discrete devices are

00:38:31,109 --> 00:38:41,890
good Segway might do that now all right

00:38:37,630 --> 00:38:45,040
so so basically what I did is I tried to

00:38:41,890 --> 00:38:48,690
provide a an abstracted model of our

00:38:45,040 --> 00:38:51,130
device and I do have a couple devices

00:38:48,690 --> 00:38:53,290
but you're right they're both very Intel

00:38:51,130 --> 00:38:54,640
so you know I'm definitely looking for

00:38:53,290 --> 00:38:56,590
feedback from other people who have

00:38:54,640 --> 00:38:59,619
different devices how well it Maps but

00:38:56,590 --> 00:39:01,570
the basic idea is that we'll expose the

00:38:59,619 --> 00:39:04,240
headers that the hardware supports along

00:39:01,570 --> 00:39:08,050
with the how the headers are put

00:39:04,240 --> 00:39:09,460
together and what I mean by that is you

00:39:08,050 --> 00:39:11,350
know you know you may support so many

00:39:09,460 --> 00:39:14,140
stacked VLAN headers and so many stacked

00:39:11,350 --> 00:39:15,580
MPLS labels or something like this and

00:39:14,140 --> 00:39:19,359
through a kind of a graph you can

00:39:15,580 --> 00:39:21,130
describe how the hardware header parser

00:39:19,359 --> 00:39:23,440
actually help deep it can go into

00:39:21,130 --> 00:39:25,030
packets and in this way you can say that

00:39:23,440 --> 00:39:28,030
this Hardware can match on these fields

00:39:25,030 --> 00:39:29,859
and and so on and then the next piece is

00:39:28,030 --> 00:39:33,580
that we explored a set of actions and

00:39:29,859 --> 00:39:34,930
that the actions are say kind of what

00:39:33,580 --> 00:39:36,340
the actions that the hardware support

00:39:34,930 --> 00:39:40,210
seen as some standard ones would be like

00:39:36,340 --> 00:39:43,480
set field you know Papa header push a

00:39:40,210 --> 00:39:44,830
header drop a packet forward so there's

00:39:43,480 --> 00:39:47,320
kind of a minimal set of kind of

00:39:44,830 --> 00:39:52,869
standard header actions that that will

00:39:47,320 --> 00:39:53,859
probably need to standardize and the

00:39:52,869 --> 00:39:56,350
important thing would be to kind of

00:39:53,859 --> 00:40:02,550
minimalize that set I hope I don't want

00:39:56,350 --> 00:40:05,140
to have a hey I wrote this so this is a

00:40:02,550 --> 00:40:08,140
something I wrote to kind of try to

00:40:05,140 --> 00:40:11,200
describe to other folks what what I'm

00:40:08,140 --> 00:40:13,750
working on and it's available obviously

00:40:11,200 --> 00:40:15,250
and so then the idea is to have a

00:40:13,750 --> 00:40:17,500
minimal set of actions that describe

00:40:15,250 --> 00:40:20,350
kind of a large array of hardware and

00:40:17,500 --> 00:40:21,790
the API I have now I think as we

00:40:20,350 --> 00:40:23,230
discussed a couple days ago I probably

00:40:21,790 --> 00:40:25,810
need to do a better job of kind of

00:40:23,230 --> 00:40:27,820
defining those in the next version but

00:40:25,810 --> 00:40:29,980
the idea would be then hardware can push

00:40:27,820 --> 00:40:31,119
out I support up push up set field on

00:40:29,980 --> 00:40:33,460
these fields I support

00:40:31,119 --> 00:40:36,339
these types of headers I can pop these

00:40:33,460 --> 00:40:39,460
types of headers and so on and then the

00:40:36,339 --> 00:40:41,079
next piece is tables and so the idea is

00:40:39,460 --> 00:40:43,059
that this is kind of a model that works

00:40:41,079 --> 00:40:45,910
pretty well for devices that look like

00:40:43,059 --> 00:40:48,519
table pipelines which are the devices I

00:40:45,910 --> 00:40:52,180
have I can say it works well for both

00:40:48,519 --> 00:40:53,910
Nicks and switch switches you know

00:40:52,180 --> 00:40:56,049
obviously doesn't cover every possible

00:40:53,910 --> 00:41:03,789
abstraction model that your device has

00:40:56,049 --> 00:41:06,220
even my devices have things that even my

00:41:03,789 --> 00:41:07,569
devices have things that are not in this

00:41:06,220 --> 00:41:10,900
model you know like I haven't tried to

00:41:07,569 --> 00:41:12,519
tackle QoS for example but I'm kind of

00:41:10,900 --> 00:41:14,019
firmly in this camp that we're gonna

00:41:12,519 --> 00:41:17,019
have to do this in stages there's not

00:41:14,019 --> 00:41:18,519
gonna be a whole implementation that we

00:41:17,019 --> 00:41:21,640
push into the kernel all at once and

00:41:18,519 --> 00:41:24,309
it's right for every device right so

00:41:21,640 --> 00:41:26,259
this is kind of the first piece so the

00:41:24,309 --> 00:41:29,349
tables are exposed as this pipeline of

00:41:26,259 --> 00:41:31,450
tables it's a tables support headers and

00:41:29,349 --> 00:41:32,920
actions so you can say I have a I have a

00:41:31,450 --> 00:41:35,940
route table that supports matching only

00:41:32,920 --> 00:41:38,609
l3 and the actions are setting the IP

00:41:35,940 --> 00:41:40,869
fields and decrementing the TTL and

00:41:38,609 --> 00:41:42,489
pushing a VLAN and so on and so forth

00:41:40,869 --> 00:41:44,739
whatever you you you know you think

00:41:42,489 --> 00:41:46,809
routing table should be doing and then

00:41:44,739 --> 00:41:49,210
you know following the routing table is

00:41:46,809 --> 00:41:51,309
an ACL table it supports the drop action

00:41:49,210 --> 00:41:54,249
and it has can match on a big array of

00:41:51,309 --> 00:41:56,710
fields and so on so this is kind of how

00:41:54,249 --> 00:41:58,839
you but you put this all together and

00:41:56,710 --> 00:42:02,140
then you you know you say how the tables

00:41:58,839 --> 00:42:04,059
are actually arranged and then this gets

00:42:02,140 --> 00:42:05,789
pushed into user space via net link and

00:42:04,059 --> 00:42:09,190
there's some kernel code to ensure that

00:42:05,789 --> 00:42:13,210
the model is correct you didn't do you

00:42:09,190 --> 00:42:16,210
didn't export kind of wrong things or

00:42:13,210 --> 00:42:18,730
you didn't do any of this and then you

00:42:16,210 --> 00:42:20,499
can set we have a set rule and delete

00:42:18,730 --> 00:42:22,029
rule now so you can add rules to the

00:42:20,499 --> 00:42:24,190
tables and remove rules from the tables

00:42:22,029 --> 00:42:25,569
and the kernel will do things like

00:42:24,190 --> 00:42:28,059
verify that those rules are valid for

00:42:25,569 --> 00:42:29,499
those tables you know we could add

00:42:28,059 --> 00:42:30,759
additional validation logic to ensure

00:42:29,499 --> 00:42:32,910
that there's you know it's not just

00:42:30,759 --> 00:42:35,109
blatantly dumb thing to be doing

00:42:32,910 --> 00:42:36,849
maybe loops would be one of those phones

00:42:35,109 --> 00:42:37,930
like category if a user tries to add a

00:42:36,849 --> 00:42:40,349
loop let's just not let him do that

00:42:37,930 --> 00:42:43,180
because this which will go into some

00:42:40,349 --> 00:42:46,390
tailspin and not work anymore

00:42:43,180 --> 00:42:48,090
so and that's the basic primitives I

00:42:46,390 --> 00:42:51,610
guess and then this gets pushed out into

00:42:48,090 --> 00:42:54,340
user space after this kind of core

00:42:51,610 --> 00:42:56,650
module from the kernel and then user

00:42:54,340 --> 00:42:57,970
space can can read these you can do

00:42:56,650 --> 00:43:01,030
things in user space like look at

00:42:57,970 --> 00:43:04,030
multiple devices and try to normalize

00:43:01,030 --> 00:43:05,620
headers so you can say I have four

00:43:04,030 --> 00:43:07,630
devices in the system and they support

00:43:05,620 --> 00:43:09,460
this kind of super set of headers but

00:43:07,630 --> 00:43:12,070
the the intersection of all the headers

00:43:09,460 --> 00:43:15,130
is this you can do the same things with

00:43:12,070 --> 00:43:16,390
actions the other thing that's kind of

00:43:15,130 --> 00:43:18,580
interesting to do I guess with with

00:43:16,390 --> 00:43:20,080
applications is to tell the hardware

00:43:18,580 --> 00:43:21,550
that this is my minimal set and I'm not

00:43:20,080 --> 00:43:23,110
gonna run my application in hardware

00:43:21,550 --> 00:43:26,500
unless you support these fields in these

00:43:23,110 --> 00:43:28,360
actions and this gets you kind of a an

00:43:26,500 --> 00:43:29,530
application that's not directly bound to

00:43:28,360 --> 00:43:30,610
the hardware necessarily I mean

00:43:29,530 --> 00:43:31,750
obviously if the hardware doesn't

00:43:30,610 --> 00:43:35,140
support the features you need you can't

00:43:31,750 --> 00:43:36,550
run it on the hardware well that's it's

00:43:35,140 --> 00:43:38,620
the fact of life I guess then that's how

00:43:36,550 --> 00:43:41,490
Hardware works so you'd have to run it

00:43:38,620 --> 00:43:43,630
in software then that's the the basic

00:43:41,490 --> 00:43:51,030
outline I think I'm talking about like

00:43:43,630 --> 00:43:54,100
half an hour about this tomorrow so so

00:43:51,030 --> 00:43:57,340
the one question I think which was on

00:43:54,100 --> 00:44:00,730
everybody's mind which interface becomes

00:43:57,340 --> 00:44:03,130
the master of this what what like how do

00:44:00,730 --> 00:44:05,710
do we really we're iterating through to

00:44:03,130 --> 00:44:07,090
kind of separate paths right now is we

00:44:05,710 --> 00:44:08,650
don't know where this converges at the

00:44:07,090 --> 00:44:11,020
end well

00:44:08,650 --> 00:44:14,950
what what I'm just sort of question I'm

00:44:11,020 --> 00:44:19,000
pondering is if you have like do we make

00:44:14,950 --> 00:44:22,210
the TC implementation in the kernel go

00:44:19,000 --> 00:44:24,820
and be subservient to this or master of

00:44:22,210 --> 00:44:27,250
this like should it be then be going and

00:44:24,820 --> 00:44:29,020
and taking these things and compare I

00:44:27,250 --> 00:44:30,700
haven't seen Patrick Popeye's chair that

00:44:29,020 --> 00:44:33,600
fast before so maybe you want to step

00:44:30,700 --> 00:44:33,600
aside for a second

00:44:34,130 --> 00:44:39,900
yeah looked a lot of that stuff in

00:44:37,890 --> 00:44:44,400
regard to smaller devices like Broadcom

00:44:39,900 --> 00:44:46,410
RIA Tech small routers and my opinion is

00:44:44,400 --> 00:44:48,509
I mean they all do something quite

00:44:46,410 --> 00:44:50,430
similar they do flow offloading in the

00:44:48,509 --> 00:44:52,650
Nick at the end and collect all that

00:44:50,430 --> 00:44:56,940
information try to push it my opinion is

00:44:52,650 --> 00:44:58,799
they're doing it pretty much wrong some

00:44:56,940 --> 00:45:01,200
things of that are fine I think the

00:44:58,799 --> 00:45:03,329
kernel should stay in control always if

00:45:01,200 --> 00:45:07,559
you're considering flow offloading if

00:45:03,329 --> 00:45:09,269
you configure something using TC the T C

00:45:07,559 --> 00:45:11,099
should be in control because it's

00:45:09,269 --> 00:45:12,809
basically what the user used to use and

00:45:11,099 --> 00:45:15,569
also there might be different utilities

00:45:12,809 --> 00:45:17,489
you don't need to reinvent the wheel you

00:45:15,569 --> 00:45:19,170
might have these utilities and if the

00:45:17,489 --> 00:45:20,700
hardware is capable of performing the

00:45:19,170 --> 00:45:22,319
action the user configured then it

00:45:20,700 --> 00:45:23,729
should be pushed to the hardware if it's

00:45:22,319 --> 00:45:26,099
not it should stay in software is my

00:45:23,729 --> 00:45:30,029
opinion that also goes for nad for

00:45:26,099 --> 00:45:31,950
routing for I mean for tagging whatever

00:45:30,029 --> 00:45:33,299
I mean try to offload as much as

00:45:31,950 --> 00:45:34,890
possible and as soon as it's not

00:45:33,299 --> 00:45:37,440
possible anymore I mean we're talking

00:45:34,890 --> 00:45:39,359
about flows you can't keep individual

00:45:37,440 --> 00:45:41,430
flows out and have different flows

00:45:39,359 --> 00:45:44,039
handled by the hardware so it's not

00:45:41,430 --> 00:45:46,829
really a problem as soon as let's say

00:45:44,039 --> 00:45:48,029
the user configures HDB there must be a

00:45:46,829 --> 00:45:51,299
reason why it's doing that

00:45:48,029 --> 00:45:52,619
so he probably wants the HTTP features

00:45:51,299 --> 00:45:55,259
and if the hardware doesn't isn't

00:45:52,619 --> 00:45:58,079
capable of providing that then take it

00:45:55,259 --> 00:45:59,249
out of the hardware so I think just to

00:45:58,079 --> 00:46:00,630
repeat something you said earlier I

00:45:59,249 --> 00:46:02,690
think you should be left up to you you

00:46:00,630 --> 00:46:05,039
said something that got me off there

00:46:02,690 --> 00:46:06,269
that you should offload everything into

00:46:05,039 --> 00:46:08,400
the hardware until there's no more to

00:46:06,269 --> 00:46:11,819
offload it that's a policy decision from

00:46:08,400 --> 00:46:13,619
the user correct well basically yes the

00:46:11,819 --> 00:46:15,569
assumption is the user already expressed

00:46:13,619 --> 00:46:18,809
what what you wanted or and reconfigure

00:46:15,569 --> 00:46:24,029
that statics for clarifying be like a

00:46:18,809 --> 00:46:27,299
feature flag right on the net of code

00:46:24,029 --> 00:46:29,759
that you out my friend so f DB add I can

00:46:27,299 --> 00:46:32,400
specify that to sit in the kernel to be

00:46:29,759 --> 00:46:34,410
offloaded or to evolve to happen I set a

00:46:32,400 --> 00:46:35,969
policy I think it's preferable to have a

00:46:34,410 --> 00:46:38,099
transparency at that point if the

00:46:35,969 --> 00:46:39,809
hardware's capable and if it doesn't

00:46:38,099 --> 00:46:42,499
make any difference for the user then

00:46:39,809 --> 00:46:45,979
offload it of course I mean it's just

00:46:42,499 --> 00:46:45,979
Mike Mike Mike

00:46:49,610 --> 00:46:57,030
so the issue with some of the off flow

00:46:54,120 --> 00:47:00,870
discussion sometimes the hardware and

00:46:57,030 --> 00:47:03,150
it's fast paths can do order three or

00:47:00,870 --> 00:47:04,800
four five orders of magnitude more than

00:47:03,150 --> 00:47:06,810
with the hard work that then what you

00:47:04,800 --> 00:47:08,040
can do in software so if you so if you

00:47:06,810 --> 00:47:10,170
try and do with some of this stuff in

00:47:08,040 --> 00:47:12,270
software all sudden your entire network

00:47:10,170 --> 00:47:15,360
grinds to a halt yes I fully agree I

00:47:12,270 --> 00:47:19,830
mean so you can't just say if somebody

00:47:15,360 --> 00:47:21,990
configures it it's has to has to happen

00:47:19,830 --> 00:47:23,880
in software you can't do in Hardware in

00:47:21,990 --> 00:47:26,130
cases where that doesn't work no that's

00:47:23,880 --> 00:47:27,630
not correct in my opinion I mean we do

00:47:26,130 --> 00:47:29,070
have the same problem right now if I

00:47:27,630 --> 00:47:30,630
configure my hardware to do something

00:47:29,070 --> 00:47:32,130
which it doesn't support it doesn't

00:47:30,630 --> 00:47:34,020
matter if I do offloading or not if the

00:47:32,130 --> 00:47:36,750
CPUs too weak it can't do it it would

00:47:34,020 --> 00:47:38,820
break that's no difference to offloading

00:47:36,750 --> 00:47:40,560
at all the main problem is the main

00:47:38,820 --> 00:47:41,880
question is if I configure something do

00:47:40,560 --> 00:47:43,230
I really want it to happen or not I

00:47:41,880 --> 00:47:45,030
might configure something which is not

00:47:43,230 --> 00:47:46,860
working actually which is breaking down

00:47:45,030 --> 00:47:48,480
my system sure but I still told my

00:47:46,860 --> 00:47:50,400
system to do it try it and then I will

00:47:48,480 --> 00:47:53,550
see if it breaks or not but if I tell my

00:47:50,400 --> 00:47:56,820
system to huge use for instance HTTP I

00:47:53,550 --> 00:47:59,580
expect the result to be my traffic

00:47:56,820 --> 00:48:00,930
shaped according to HTTP and if my

00:47:59,580 --> 00:48:02,640
system is not capable of doing that

00:48:00,930 --> 00:48:05,850
because it's too weak well bad luck and

00:48:02,640 --> 00:48:08,280
I will notice and I will decide if I

00:48:05,850 --> 00:48:10,350
will do something differently or not but

00:48:08,280 --> 00:48:12,270
still I have expressed my what I want a

00:48:10,350 --> 00:48:14,550
harder to do or the system to do the

00:48:12,270 --> 00:48:26,250
offloading is just part of a system but

00:48:14,550 --> 00:48:28,080
it's not in control of the system load

00:48:26,250 --> 00:48:29,820
it I might not want to do it I agree

00:48:28,080 --> 00:48:33,060
that you should have some mechanism to

00:48:29,820 --> 00:48:35,250
figure out what happened yes there's

00:48:33,060 --> 00:48:37,190
there's no there's no the thing is we're

00:48:35,250 --> 00:48:39,720
talking about flows here and not about

00:48:37,190 --> 00:48:41,160
enabling complete offload so it's kind

00:48:39,720 --> 00:48:43,740
of different because of the flows I'm

00:48:41,160 --> 00:48:45,360
the not offloading stuff happens at

00:48:43,740 --> 00:48:46,890
packet processing time basically so

00:48:45,360 --> 00:48:50,800
there is nothing to give feedback to

00:48:46,890 --> 00:48:55,780
it's nothing you can do actually

00:48:50,800 --> 00:48:58,240
I think there's something fundamentally

00:48:55,780 --> 00:48:59,980
different right so far all our users

00:48:58,240 --> 00:49:01,360
were expecting softer performance that I

00:48:59,980 --> 00:49:03,400
will not have and used software

00:49:01,360 --> 00:49:05,260
interfaces and expected harder

00:49:03,400 --> 00:49:08,140
performance and with this kind of API

00:49:05,260 --> 00:49:10,750
we'll have users which require harder

00:49:08,140 --> 00:49:13,330
performance and they have to be ensure

00:49:10,750 --> 00:49:14,830
it has to be guaranteed that their part

00:49:13,330 --> 00:49:16,600
that the performance requirements are

00:49:14,830 --> 00:49:18,670
met otherwise it should not be

00:49:16,600 --> 00:49:20,230
configurable it's again it's a different

00:49:18,670 --> 00:49:21,760
set of use cases it's Enterprise

00:49:20,230 --> 00:49:23,590
switching these gates I think we've been

00:49:21,760 --> 00:49:25,210
talking about here maybe you can you can

00:49:23,590 --> 00:49:28,380
add to that actually can I just say one

00:49:25,210 --> 00:49:31,210
thing real quick do not neglect the

00:49:28,380 --> 00:49:33,730
operational cost of things well my point

00:49:31,210 --> 00:49:36,210
of view of somebody I've worked at the

00:49:33,730 --> 00:49:38,590
biggest routing vendors out there and

00:49:36,210 --> 00:49:41,290
you're constantly bombarded with what

00:49:38,590 --> 00:49:42,550
are your operational costs so if you're

00:49:41,290 --> 00:49:45,490
configuring something in the heat of the

00:49:42,550 --> 00:49:48,490
moment to deal with a networking problem

00:49:45,490 --> 00:49:50,440
an attack or something like that you

00:49:48,490 --> 00:49:52,600
want to have feedback that the thing

00:49:50,440 --> 00:49:53,950
that I just entered is actually going to

00:49:52,600 --> 00:49:58,660
be disruptive to the box that I entered

00:49:53,950 --> 00:50:01,630
it on so sometimes you know that what

00:49:58,660 --> 00:50:03,880
you entered is a low probability thing

00:50:01,630 --> 00:50:05,290
and it's okay but you need the feedback

00:50:03,880 --> 00:50:08,470
and the feedback has got to come from

00:50:05,290 --> 00:50:11,770
the kernel yeah but I see what you're

00:50:08,470 --> 00:50:13,990
saying my opinion is that the user

00:50:11,770 --> 00:50:15,310
actually I mean if he's this is

00:50:13,990 --> 00:50:16,900
specialized hardware if he adds

00:50:15,310 --> 00:50:19,060
something like that he should know what

00:50:16,900 --> 00:50:21,580
the hardware is capable of or not and

00:50:19,060 --> 00:50:24,220
sure you can't provide feedback but I

00:50:21,580 --> 00:50:26,830
guess that would be probably up to the

00:50:24,220 --> 00:50:29,500
user space utilities to figure out if

00:50:26,830 --> 00:50:31,150
it's where do you want to try to provide

00:50:29,500 --> 00:50:32,590
feedback for flow offloading I mean the

00:50:31,150 --> 00:50:35,080
offloading happens during packet

00:50:32,590 --> 00:50:37,120
processing so I so via seemingly going

00:50:35,080 --> 00:50:41,610
back in circles on this one was their

00:50:37,120 --> 00:50:44,020
hand up agree so I think I think it's

00:50:41,610 --> 00:50:46,420
for all the use cases we talked about

00:50:44,020 --> 00:50:48,280
just like what Thomas said I think there

00:50:46,420 --> 00:50:50,080
are definitely use cases where automatic

00:50:48,280 --> 00:50:53,200
remedial action would be surprising to

00:50:50,080 --> 00:50:54,790
people actually not so I think whatever

00:50:53,200 --> 00:50:56,470
happens there might be even if the

00:50:54,790 --> 00:50:58,630
kernel automatically has a remedial

00:50:56,470 --> 00:51:00,250
policy there has to be an override and

00:50:58,630 --> 00:51:02,260
that I think addresses your concern well

00:51:00,250 --> 00:51:04,370
you say anybody deploying Enterprise

00:51:02,260 --> 00:51:07,610
switching for example or Gateway routers

00:51:04,370 --> 00:51:09,260
we'll set the policy up top to say don't

00:51:07,610 --> 00:51:12,820
take remedial action without telling I

00:51:09,260 --> 00:51:17,090
get to decide what the remedy

00:51:12,820 --> 00:51:22,370
necessarily you know you want feedback

00:51:17,090 --> 00:51:24,620
that it happened but but it's a

00:51:22,370 --> 00:51:28,310
userspace process problem that has to

00:51:24,620 --> 00:51:31,250
come from the kernel because you don't

00:51:28,310 --> 00:51:33,200
know you can't from n number of users

00:51:31,250 --> 00:51:36,530
based processes whether it's configuring

00:51:33,200 --> 00:51:38,420
TC TC or protocol or policy or something

00:51:36,530 --> 00:51:40,670
like that it's independent of what the

00:51:38,420 --> 00:51:47,630
hardware can do and you don't want to

00:51:40,670 --> 00:51:54,440
have yes but there's no mechanism to do

00:51:47,630 --> 00:51:57,080
that so we need to write that so Patrick

00:51:54,440 --> 00:51:59,690
this is this this stuff is why I said we

00:51:57,080 --> 00:52:00,950
need a boolean bit that says if you

00:51:59,690 --> 00:52:02,570
can't put in the hardware let me know

00:52:00,950 --> 00:52:05,030
and don't put it don't put the rule in

00:52:02,570 --> 00:52:06,830
yeah sure I'm just wondering how the

00:52:05,030 --> 00:52:08,150
kernel is supposed to provide any

00:52:06,830 --> 00:52:10,490
feedback because if you're talking about

00:52:08,150 --> 00:52:12,110
flow offloading basically the question

00:52:10,490 --> 00:52:14,150
whether flow can be offloaded or not can

00:52:12,110 --> 00:52:16,880
be made once the packet the flow has

00:52:14,150 --> 00:52:19,040
been handled and software and the kernel

00:52:16,880 --> 00:52:20,690
can't know before it actually hits some

00:52:19,040 --> 00:52:22,130
feature before the flow hits some page

00:52:20,690 --> 00:52:23,780
we're talking about the space where

00:52:22,130 --> 00:52:25,900
people are adding routes or ACLs and

00:52:23,780 --> 00:52:28,250
stuff like this yeah but okay that's

00:52:25,900 --> 00:52:29,450
that kind of that's what they're

00:52:28,250 --> 00:52:31,160
concerned yes but that's kind of

00:52:29,450 --> 00:52:34,880
different I think I'm from from

00:52:31,160 --> 00:52:37,040
offloading well yes for instance like

00:52:34,880 --> 00:52:39,050
yeah I'm mainly talking about smaller

00:52:37,040 --> 00:52:42,710
devices of course I'm like the regular

00:52:39,050 --> 00:52:44,390
home router and these devices make the

00:52:42,710 --> 00:52:46,130
decision based on the actual packet

00:52:44,390 --> 00:52:48,770
processing the packet gets processed and

00:52:46,130 --> 00:52:50,720
once it the processing is complete the

00:52:48,770 --> 00:52:53,360
offloading decision gets made so there's

00:52:50,720 --> 00:52:55,640
basically you would have to predict what

00:52:53,360 --> 00:52:57,950
happens to the packet to decide if it's

00:52:55,640 --> 00:52:59,450
capable of getting offloaded or not so

00:52:57,950 --> 00:53:01,190
you have to make a prediction of the

00:52:59,450 --> 00:53:02,690
entire behavior of the packet path of

00:53:01,190 --> 00:53:04,820
everything which will be applied to the

00:53:02,690 --> 00:53:07,250
packet which is a very hard thing to do

00:53:04,820 --> 00:53:08,720
correctly um so it's my questions at

00:53:07,250 --> 00:53:10,670
what point would you provide feedback

00:53:08,720 --> 00:53:12,740
when you configure something you would

00:53:10,670 --> 00:53:16,870
have to predict the outcome of a packet

00:53:12,740 --> 00:53:18,440
classification routing net whatever

00:53:16,870 --> 00:53:19,819
process and this is where

00:53:18,440 --> 00:53:22,310
difficult to do I don't think it's

00:53:19,819 --> 00:53:24,800
possible to do that in a way that

00:53:22,310 --> 00:53:26,150
doesn't leave tons of open holes or

00:53:24,800 --> 00:53:28,160
corner cases which are not handled

00:53:26,150 --> 00:53:30,260
correctly the thing another thing that

00:53:28,160 --> 00:53:32,119
that's that hasn't been said explicitly

00:53:30,260 --> 00:53:34,190
is that yes it is true that we have

00:53:32,119 --> 00:53:36,349
multiple api's we're working on to solve

00:53:34,190 --> 00:53:38,960
different aspects of this problem and

00:53:36,349 --> 00:53:40,130
there's lots of overlap and it is it

00:53:38,960 --> 00:53:41,630
could be the case that it's somewhere

00:53:40,130 --> 00:53:43,819
down the line we figure out that all you

00:53:41,630 --> 00:53:45,140
know this particular set of apos was the

00:53:43,819 --> 00:53:47,210
right trade-off and that's what we

00:53:45,140 --> 00:53:48,650
should converge to and it's possible

00:53:47,210 --> 00:53:50,089
that some of these driver interfaces

00:53:48,650 --> 00:53:51,800
we're designing now might not even exist

00:53:50,089 --> 00:53:54,230
five or six years from now as we convert

00:53:51,800 --> 00:53:55,910
things I guess one of the advantages of

00:53:54,230 --> 00:53:57,460
only having one driver right now is that

00:53:55,910 --> 00:54:00,440
we don't have a lot of to convert

00:53:57,460 --> 00:54:01,819
if we get rid of get rid of one set of

00:54:00,440 --> 00:54:03,800
api's but at some point we're gonna

00:54:01,819 --> 00:54:06,560
reach critical mass and we have to make

00:54:03,800 --> 00:54:08,450
sure our interfaces are pretty damn

00:54:06,560 --> 00:54:09,859
solid at that point actually regarding

00:54:08,450 --> 00:54:12,790
the question previously about

00:54:09,859 --> 00:54:16,400
information available without an NDA

00:54:12,790 --> 00:54:19,700
these vendor SDKs for the small the Rio

00:54:16,400 --> 00:54:22,160
tech Broadcom etc SDKs they include some

00:54:19,700 --> 00:54:24,950
crappy drivers which are not high

00:54:22,160 --> 00:54:26,569
quality but they contain enough

00:54:24,950 --> 00:54:27,619
information to easily figure out what

00:54:26,569 --> 00:54:29,060
the hardware is actually doing and

00:54:27,619 --> 00:54:31,280
capable off by looking at the headers

00:54:29,060 --> 00:54:32,690
and the hardware descriptors etc and

00:54:31,280 --> 00:54:34,400
these are available so anyone

00:54:32,690 --> 00:54:38,359
interesting can quite easily um get a

00:54:34,400 --> 00:54:41,270
tas of actually I think for the smaller

00:54:38,359 --> 00:54:43,430
devices I know there is a fair amount of

00:54:41,270 --> 00:54:46,190
interest for people to also contribute

00:54:43,430 --> 00:54:48,440
specs to open source so if we can put

00:54:46,190 --> 00:54:50,839
enough of the framework in place I think

00:54:48,440 --> 00:54:52,310
you'll see I mean I I can connect

00:54:50,839 --> 00:54:53,660
individual people who might have some

00:54:52,310 --> 00:55:00,040
interest to some of these companies as

00:54:53,660 --> 00:55:03,560
well okay so I just had a comment about

00:55:00,040 --> 00:55:05,900
the feedback API and mentioning that you

00:55:03,560 --> 00:55:06,890
know a lot of times and hardware really

00:55:05,900 --> 00:55:07,819
don't want to make much of a comment

00:55:06,890 --> 00:55:10,970
here because I don't want to prolong the

00:55:07,819 --> 00:55:12,200
conversation but there's situations in

00:55:10,970 --> 00:55:13,339
which several network functions are

00:55:12,200 --> 00:55:15,349
going to be implemented by shared

00:55:13,339 --> 00:55:17,359
hardware and in those cases where we're

00:55:15,349 --> 00:55:19,250
trying to solve this problem we're sort

00:55:17,359 --> 00:55:20,420
of ruining our capabilities mechanism

00:55:19,250 --> 00:55:22,730
that we discussed a little while ago

00:55:20,420 --> 00:55:24,680
whereby you know you originally are told

00:55:22,730 --> 00:55:25,880
I can handle 10 million routes but all

00:55:24,680 --> 00:55:27,319
of a sudden TC wants to do some

00:55:25,880 --> 00:55:29,890
filtering and it's unshared hardware and

00:55:27,319 --> 00:55:34,040
that capability is now incorrect

00:55:29,890 --> 00:55:36,590
I'm sorry to poop on the party but you

00:55:34,040 --> 00:55:38,270
got like five minutes or less yes yeah I

00:55:36,590 --> 00:55:41,660
know I know I'm is another session at

00:55:38,270 --> 00:55:42,860
yeah so for the next five minutes we're

00:55:41,660 --> 00:55:48,200
gonna have jury come up you're gonna

00:55:42,860 --> 00:55:49,490
rearrange a little bit so yeah oh five

00:55:48,200 --> 00:55:52,070
minutes is it okay

00:55:49,490 --> 00:55:56,120
alright we're doing questions for five

00:55:52,070 --> 00:55:58,670
minutes I guess go on it okay so I'm one

00:55:56,120 --> 00:56:00,710
of the sites that does essentially home

00:55:58,670 --> 00:56:02,540
routing and one of the things that I

00:56:00,710 --> 00:56:06,230
look at when I listen to people talk

00:56:02,540 --> 00:56:08,210
about offload is that you see the create

00:56:06,230 --> 00:56:10,790
and delete of how you want to handle a

00:56:08,210 --> 00:56:14,660
flow going down to hardware but you have

00:56:10,790 --> 00:56:17,450
to update Linux to keep all of its state

00:56:14,660 --> 00:56:19,340
in track all right we've designed this

00:56:17,450 --> 00:56:22,400
so that that's what happens so that so

00:56:19,340 --> 00:56:24,500
when we add a route we added so it's not

00:56:22,400 --> 00:56:26,510
just the route it's can its contract has

00:56:24,500 --> 00:56:29,630
to be kept up-to-date if you're doing

00:56:26,510 --> 00:56:33,140
PPP we will have some we definitely plan

00:56:29,630 --> 00:56:34,880
on having to solve our tables have the

00:56:33,140 --> 00:56:37,220
state oh you mean like contract and

00:56:34,880 --> 00:56:39,410
stuff yeah yeah if I might write how do

00:56:37,220 --> 00:56:41,330
you get it's not that from the hard work

00:56:39,410 --> 00:56:43,070
quite load it's quite easy information

00:56:41,330 --> 00:56:44,510
back up into the kernel it's quite easy

00:56:43,070 --> 00:56:46,310
you don't need a lot of information

00:56:44,510 --> 00:56:48,500
basically the connection tracking and

00:56:46,310 --> 00:56:50,300
software has timers so if it doesn't see

00:56:48,500 --> 00:56:52,730
any packet on the CPU the timers were at

00:56:50,300 --> 00:56:54,650
some point expires so instead of killing

00:56:52,730 --> 00:56:56,300
the floor you will call back to the

00:56:54,650 --> 00:56:59,120
hardware and credit for this exact flow

00:56:56,300 --> 00:57:01,310
is it still active if if it is active

00:56:59,120 --> 00:57:02,630
you reschedule the timer if not you do

00:57:01,310 --> 00:57:04,580
the regular software processing

00:57:02,630 --> 00:57:06,110
regarding counters and stuff like that

00:57:04,580 --> 00:57:07,790
I'm at the point where the user actually

00:57:06,110 --> 00:57:09,380
requests the counters at that point you

00:57:07,790 --> 00:57:11,540
hurry back to the hardware but it's very

00:57:09,380 --> 00:57:13,850
few cases where we actually need to do

00:57:11,540 --> 00:57:15,650
that in connection tracking the only

00:57:13,850 --> 00:57:20,290
thing which actually requires active

00:57:15,650 --> 00:57:20,290
flow status timers that's it

00:57:20,760 --> 00:57:24,930
and in general the model would be you

00:57:23,280 --> 00:57:27,000
want to leverage netlink as much as

00:57:24,930 --> 00:57:31,640
possible right you want to send signals

00:57:27,000 --> 00:57:31,640
back to the colonel send it to nothing

00:57:32,270 --> 00:57:38,160
yeah yeah so let's let me just close

00:57:35,460 --> 00:57:41,130
them so people know that we are going to

00:57:38,160 --> 00:57:44,670
do another session right so this we had

00:57:41,130 --> 00:57:46,080
anticipated the popularity so we're

00:57:44,670 --> 00:57:52,740
going to have another two and a half

00:57:46,080 --> 00:57:55,020
hour session is that right yeah the last

00:57:52,740 --> 00:57:57,540
person talking is going to shut down the

00:57:55,020 --> 00:57:58,830
mic before they leave that's the

00:57:57,540 --> 00:58:01,650
strategy so we're going to continue

00:57:58,830 --> 00:58:04,770
again and we do have an agenda as you

00:58:01,650 --> 00:58:06,690
can see so just so you get a good quick

00:58:04,770 --> 00:58:09,180
chance to take a look at where you stand

00:58:06,690 --> 00:58:12,600
we finished with John so Mihai is going

00:58:09,180 --> 00:58:15,750
to talk about p4 jury about TC and some

00:58:12,600 --> 00:58:18,450
flow rebuttals is that the right way to

00:58:15,750 --> 00:58:21,330
say it yeah we're gonna have Gilad from

00:58:18,450 --> 00:58:24,630
easy to talk a little bit we're gonna

00:58:21,330 --> 00:58:25,860
talk about how capacity indication and

00:58:24,630 --> 00:58:30,140
some of the things that we're doing in

00:58:25,860 --> 00:58:33,360
the switch dev space and then we have

00:58:30,140 --> 00:58:35,930
Scott's going to talk about rocker this

00:58:33,360 --> 00:58:37,770
might be one of the surprise items

00:58:35,930 --> 00:58:42,770
Sanjay's son is going to talk about

00:58:37,770 --> 00:58:48,770
switch abstraction API URI if he is here

00:58:42,770 --> 00:58:53,640
is already here okay

00:58:48,770 --> 00:58:58,020
wasn't he hosting the second session or

00:58:53,640 --> 00:59:04,080
something like that I saw her yesterday

00:58:58,020 --> 00:59:06,360
ah missing and we have oliveira from

00:59:04,080 --> 00:59:08,670
Qualcomm and finally I want to talk a

00:59:06,360 --> 00:59:10,430
little bit about features I know Hannes

00:59:08,670 --> 00:59:13,590
wanted to talk about a few things from

00:59:10,430 --> 00:59:15,960
l3 offload capability perspective and

00:59:13,590 --> 00:59:20,040
things that Linux could do better at

00:59:15,960 --> 00:59:21,570
system-wide load balancing etc so as you

00:59:20,040 --> 00:59:25,490
can see it's a very short agenda will be

00:59:21,570 --> 00:59:28,750
done in 15 minutes in the next session

00:59:25,490 --> 00:59:33,160
so see you in

00:59:28,750 --> 00:59:37,320
two hours two hours I Jamal

00:59:33,160 --> 00:59:41,859
two hours we continue in two hours here

00:59:37,320 --> 00:59:45,450
here 4:30 with Cu in fourth at 4:30

00:59:41,859 --> 00:59:45,450

YouTube URL: https://www.youtube.com/watch?v=58m1brbQtg0


