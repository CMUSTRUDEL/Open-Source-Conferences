Title: Netdev 0.1 - Hardware Offloading BoF (Part 8 of 9) - nftables
Publication date: 2015-04-07
Playlist: Netdev 0.1 - Day 2 - Sunday February 15, 2015
Description: 
	nftables as interface for ACL HW offload
Pablo Neira Ayuso
February 2015

Part 8 of 9 in the Hardware Offloading BoF series

This video is licensed under Creative Commons Attribution-ShareAlike 4.0 International license. Feel free to download and distribute.
Captions: 
	00:00:07,280 --> 00:00:12,990
okay I'm pollinator in part of the

00:00:10,010 --> 00:00:14,940
stables team and I'm going to talk about

00:00:12,990 --> 00:00:18,270
I'm going to repeat the presentation

00:00:14,940 --> 00:00:21,020
that i made in the net cost that we had

00:00:18,270 --> 00:00:23,400
just a couple of days before these

00:00:21,020 --> 00:00:26,970
conference so I'm going to talk about

00:00:23,400 --> 00:00:29,250
enough tables as an interface for ACL

00:00:26,970 --> 00:00:32,430
the hard way of loading which goes

00:00:29,250 --> 00:00:40,770
basically in the direction of using the

00:00:32,430 --> 00:00:43,559
existing interfaces to offload ACL so so

00:00:40,770 --> 00:00:44,850
we basically sped nft the software side

00:00:43,559 --> 00:00:48,719
to be more expressive than done

00:00:44,850 --> 00:00:50,940
expressive than hardware so if but

00:00:48,719 --> 00:00:52,500
anyway that is something that we don't

00:00:50,940 --> 00:00:56,280
support in software should be easy to

00:00:52,500 --> 00:00:57,629
extend so so we will get it thinking in

00:00:56,280 --> 00:01:02,340
sync with something that is not just

00:00:57,629 --> 00:01:05,040
supported so what we have is what we

00:01:02,340 --> 00:01:07,979
expect our matches like packet filter we

00:01:05,040 --> 00:01:10,200
are going to match metadata and actions

00:01:07,979 --> 00:01:15,420
yes mangled packet field made a data

00:01:10,200 --> 00:01:17,070
except drop and so on and so the

00:01:15,420 --> 00:01:20,909
proposal goes in the direction of adding

00:01:17,070 --> 00:01:24,990
a new hardware family and that what we

00:01:20,909 --> 00:01:28,290
currently have 55 hard work formulas and

00:01:24,990 --> 00:01:30,570
this Harbor family is a family that when

00:01:28,290 --> 00:01:35,880
at creating a table you will indicate

00:01:30,570 --> 00:01:38,220
that this table ISA ISA it is hardware

00:01:35,880 --> 00:01:42,210
so all the rules that the user will

00:01:38,220 --> 00:01:44,520
introduce we will go to we go to Harvard

00:01:42,210 --> 00:01:48,149
ed the user we have full knowledge that

00:01:44,520 --> 00:01:54,060
what word what equality configures goes

00:01:48,149 --> 00:01:55,350
to hardware we need some NGOs to to pass

00:01:54,060 --> 00:01:57,509
configuration to the driver and the

00:01:55,350 --> 00:02:00,619
driver will have to deal with with what

00:01:57,509 --> 00:02:05,570
we pass any tables will will behave as a

00:02:00,619 --> 00:02:09,270
catch of the existing configuration and

00:02:05,570 --> 00:02:11,910
we as we been discussing we provide a

00:02:09,270 --> 00:02:17,250
unified interface to configure the ACA

00:02:11,910 --> 00:02:20,970
in Linux so as I said we are a new

00:02:17,250 --> 00:02:24,590
hardware family symantec a ladies this

00:02:20,970 --> 00:02:27,540
family is expected to be before ingress

00:02:24,590 --> 00:02:30,930
we also need up in nineteen of tables we

00:02:27,540 --> 00:02:33,900
have different chain types and in this

00:02:30,930 --> 00:02:37,710
case we would add a filter change type

00:02:33,900 --> 00:02:39,840
for this table it would be a dummy chain

00:02:37,710 --> 00:02:41,880
in the sense that it will not reduce

00:02:39,840 --> 00:02:47,600
there any software hook so it would be

00:02:41,880 --> 00:02:50,610
just behaves as a list of rules and then

00:02:47,600 --> 00:02:53,280
we will restrict to all yellow base

00:02:50,610 --> 00:02:55,710
change so we will not have jumps or go

00:02:53,280 --> 00:02:59,580
to the numbers change it no don't base

00:02:55,710 --> 00:03:02,760
change so basically the idea goes in the

00:02:59,580 --> 00:03:05,400
direction of arm creating we already do

00:03:02,760 --> 00:03:08,130
the duties in user space is something

00:03:05,400 --> 00:03:10,500
that Patrick did in the what we call the

00:03:08,130 --> 00:03:14,090
the linearized path basically the idea

00:03:10,500 --> 00:03:16,230
is to take the dinner link message and

00:03:14,090 --> 00:03:18,630
we are going to convert in some

00:03:16,230 --> 00:03:21,620
intermediate data structure which is

00:03:18,630 --> 00:03:24,510
basically a tree a very small tree we

00:03:21,620 --> 00:03:26,670
initially a consider passing the

00:03:24,510 --> 00:03:29,220
funneling message but that was going to

00:03:26,670 --> 00:03:31,920
be a bit amazed so this intermediate

00:03:29,220 --> 00:03:33,810
data structure just a list of what we

00:03:31,920 --> 00:03:37,680
call the statements and those statements

00:03:33,810 --> 00:03:42,060
basically they they may be they are they

00:03:37,680 --> 00:03:45,989
are the root of very very small trees

00:03:42,060 --> 00:03:47,940
basically couple of relational in that

00:03:45,989 --> 00:03:53,520
case what would you have there is just

00:03:47,940 --> 00:03:55,440
expressing matching payload payloads are

00:03:53,520 --> 00:03:59,700
represented as a base offset and laugh

00:03:55,440 --> 00:04:03,290
and we are masking what we get from the

00:03:59,700 --> 00:04:07,500
from the packet and we are going to

00:04:03,290 --> 00:04:09,600
compare it then again fetching data from

00:04:07,500 --> 00:04:14,340
the payload comparing and just issuing a

00:04:09,600 --> 00:04:19,650
verdict this this small tree we attach

00:04:14,340 --> 00:04:22,289
it to the nft rule up yet and in the two

00:04:19,650 --> 00:04:25,740
phase commit protocol that we implement

00:04:22,289 --> 00:04:29,340
in nft once we have parts the entire

00:04:25,740 --> 00:04:35,699
bache containing all the rules what it

00:04:29,340 --> 00:04:37,139
happen is that for each for each for

00:04:35,699 --> 00:04:40,500
each transaction object that contains

00:04:37,139 --> 00:04:45,199
the command that needs to be needs to be

00:04:40,500 --> 00:04:49,319
performed we call NF tables come in and

00:04:45,199 --> 00:04:53,630
we pass to the to the device using the N

00:04:49,319 --> 00:04:57,240
do the the list of transactional objects

00:04:53,630 --> 00:04:59,729
in the first step the the driver will

00:04:57,240 --> 00:05:01,500
evaluate if the transaction Italy

00:04:59,729 --> 00:05:03,569
software sanction objects contain things

00:05:01,500 --> 00:05:08,750
that are that the driver that the

00:05:03,569 --> 00:05:08,750
hardware is capable of offloading and

00:05:08,840 --> 00:05:16,020
basically the driver we have to create

00:05:12,509 --> 00:05:20,880
the internal representation of that rule

00:05:16,020 --> 00:05:23,580
object then in second step one we make

00:05:20,880 --> 00:05:28,440
sure that all of the rules can be

00:05:23,580 --> 00:05:32,039
expressed in hardware we basically push

00:05:28,440 --> 00:05:34,860
it into into the hardware otherwise just

00:05:32,039 --> 00:05:37,710
returned an error and indicate the to

00:05:34,860 --> 00:05:41,900
userspace what has happened no operation

00:05:37,710 --> 00:05:47,300
not supported or flow tables is full or

00:05:41,900 --> 00:05:47,300
whatever reason yeah

00:05:50,510 --> 00:05:57,450
I'm just wondering if we are having on

00:05:54,120 --> 00:06:02,210
the colonel site some ND all flow

00:05:57,450 --> 00:06:05,370
program call back already why are we not

00:06:02,210 --> 00:06:07,470
centralizing the conversion to well why

00:06:05,370 --> 00:06:09,090
we are we having the drivers interpret

00:06:07,470 --> 00:06:11,520
and if tabas internal stuff instead of

00:06:09,090 --> 00:06:13,890
doing one conversion and into like the

00:06:11,520 --> 00:06:19,380
driver representation the the floor

00:06:13,890 --> 00:06:21,660
representation I don't I mean he's like

00:06:19,380 --> 00:06:24,420
for example John faster bands flow

00:06:21,660 --> 00:06:26,190
abstraction to implement the actual

00:06:24,420 --> 00:06:29,490
programming of the hardware like we

00:06:26,190 --> 00:06:31,760
could have an MA nft to flow flow rule

00:06:29,490 --> 00:06:34,080
conversion layer and that use existing

00:06:31,760 --> 00:06:35,700
the hardware interface that we're going

00:06:34,080 --> 00:06:37,680
to have for an NGO up we're going to

00:06:35,700 --> 00:06:39,450
have to actually program the hardware

00:06:37,680 --> 00:06:42,510
that's what he's trying to say yeah

00:06:39,450 --> 00:06:43,980
exactly so you mean by passing indeed

00:06:42,510 --> 00:06:46,050
the interface the enough tables

00:06:43,980 --> 00:06:47,970
interface I don't know I think well

00:06:46,050 --> 00:06:50,580
basically the drivers are going to

00:06:47,970 --> 00:06:53,220
export some some flow programming

00:06:50,580 --> 00:06:55,500
interface exactly and it seems more

00:06:53,220 --> 00:06:57,270
reasonable to do the conversion of the

00:06:55,500 --> 00:06:59,460
end of terrace research some generic

00:06:57,270 --> 00:07:01,260
flow representation in end of tales and

00:06:59,460 --> 00:07:03,960
then pass that flow stuff to the dr

00:07:01,260 --> 00:07:05,550
exactly no I probably I editing money to

00:07:03,960 --> 00:07:07,350
explain in finer so the conversion

00:07:05,550 --> 00:07:09,270
happens in F tables is not not even

00:07:07,350 --> 00:07:11,700
driver yeah so the drivers wouldn't have

00:07:09,270 --> 00:07:15,630
NF taiba cific India all functions but

00:07:11,700 --> 00:07:20,670
just the generic flow yo at API yes I

00:07:15,630 --> 00:07:22,800
exactly okay thanks yes you can also

00:07:20,670 --> 00:07:24,270
verify at that point using the flow API

00:07:22,800 --> 00:07:31,050
whether you'd be able to program in army

00:07:24,270 --> 00:07:32,970
exactly sucky mmm thanks okay so um well

00:07:31,050 --> 00:07:34,440
basically the idea is that we can be

00:07:32,970 --> 00:07:36,900
used although uses based software that

00:07:34,440 --> 00:07:41,580
we have including the nft and all the

00:07:36,900 --> 00:07:44,130
low-level use of space libraries and the

00:07:41,580 --> 00:07:46,260
the user we only need to well it would

00:07:44,130 --> 00:07:48,660
build we will build the batch in the

00:07:46,260 --> 00:07:51,930
same way it does just only need to

00:07:48,660 --> 00:07:54,270
specify a new NF netfilter protocol

00:07:51,930 --> 00:07:58,760
family to indicate that the message is

00:07:54,270 --> 00:07:58,760
targeted to to to the hardware

00:07:59,899 --> 00:08:04,579
we will need also a service to inquire

00:08:02,159 --> 00:08:08,309
the capabilities of the hardware so

00:08:04,579 --> 00:08:10,709
basically the user we will be able to to

00:08:08,309 --> 00:08:13,619
know what what it can do a word what can

00:08:10,709 --> 00:08:16,379
do and what cannot and that three I

00:08:13,619 --> 00:08:20,239
think what we need I've been discussing

00:08:16,379 --> 00:08:22,379
this with Patrick we could reuse it for

00:08:20,239 --> 00:08:25,109
gdns tables with it within another

00:08:22,379 --> 00:08:28,579
feature so um can be useful for more

00:08:25,109 --> 00:08:31,979
more more things not only teasing I

00:08:28,579 --> 00:08:34,189
guess that part is quite independent of

00:08:31,979 --> 00:08:36,990
hardware floating I mean the

00:08:34,189 --> 00:08:38,339
representation of the tree I mean it was

00:08:36,990 --> 00:08:39,539
really independent of the hardware

00:08:38,339 --> 00:08:42,990
server I mean you were talking about

00:08:39,539 --> 00:08:45,629
doing EVP f compilation basically but I

00:08:42,990 --> 00:08:49,050
think it's quite a different subject yes

00:08:45,629 --> 00:08:52,439
if I would entirely yes my segment was

00:08:49,050 --> 00:08:56,420
that it's good but because we can even

00:08:52,439 --> 00:08:56,420
reuse it so that's all I mean

00:09:05,880 --> 00:09:11,610
will it work even without creating that

00:09:08,790 --> 00:09:14,670
hardware chain will a seamless offload

00:09:11,610 --> 00:09:16,380
work if you if the hardware supports it

00:09:14,670 --> 00:09:19,740
if the driver supports it and if you're

00:09:16,380 --> 00:09:21,930
creating the usual nft rules and you

00:09:19,740 --> 00:09:24,420
want your rules in the kernel to be

00:09:21,930 --> 00:09:26,910
synced to hardware will that also work

00:09:24,420 --> 00:09:30,150
in this model the seamless model the

00:09:26,910 --> 00:09:32,700
problem is that we have rules that we

00:09:30,150 --> 00:09:34,530
can represent in hardware and we cannot

00:09:32,700 --> 00:09:36,000
I mean that we cannot represent in

00:09:34,530 --> 00:09:38,790
hardware we have to represent any

00:09:36,000 --> 00:09:41,700
software or so we we need explicit

00:09:38,790 --> 00:09:44,220
semantics to know what the user needs to

00:09:41,700 --> 00:09:47,190
know what what goes into highway of what

00:09:44,220 --> 00:09:50,160
I mean that reordering of the rules I

00:09:47,190 --> 00:09:52,710
mean we will happen will be ordering the

00:09:50,160 --> 00:09:54,630
switchdriver can decide that and reject

00:09:52,710 --> 00:09:58,020
the rules in that case right and we can

00:09:54,630 --> 00:10:00,060
have policies to actually reject or and

00:09:58,020 --> 00:10:01,830
if an application is so interested in

00:10:00,060 --> 00:10:03,810
knowing the hardware details there can

00:10:01,830 --> 00:10:06,870
be another path to request for that

00:10:03,810 --> 00:10:08,520
information so I think this is this is

00:10:06,870 --> 00:10:10,650
just another instance of the policy

00:10:08,520 --> 00:10:13,140
select yeah his again his approach is

00:10:10,650 --> 00:10:15,000
I'm going to create a special box where

00:10:13,140 --> 00:10:16,890
the user expressed an intention that you

00:10:15,000 --> 00:10:18,870
you have to put this in there or let me

00:10:16,890 --> 00:10:22,130
know that it's not possible otherwise I

00:10:18,870 --> 00:10:22,130
don't want any of the rules to be loaded

00:10:23,990 --> 00:10:29,250
well Pablo already mentioned that there

00:10:27,330 --> 00:10:32,010
are big semantic differences between

00:10:29,250 --> 00:10:33,810
hooking and rerouting hooking in forward

00:10:32,010 --> 00:10:36,660
or hooking directly before the colonel

00:10:33,810 --> 00:10:38,100
is even invoked so um if I got your

00:10:36,660 --> 00:10:40,740
question correct you are asking about

00:10:38,100 --> 00:10:43,260
some transparent offloading of the

00:10:40,740 --> 00:10:45,210
existence I don't think that's really

00:10:43,260 --> 00:10:47,400
possible to do because they're really

00:10:45,210 --> 00:10:49,830
big differences in the what kind of

00:10:47,400 --> 00:10:53,400
packets you get to see I mean an input

00:10:49,830 --> 00:10:55,920
for instance we have its ipv4 packets we

00:10:53,400 --> 00:10:59,190
know that they have we had some header

00:10:55,920 --> 00:11:01,020
checks in forward routing has already be

00:10:59,190 --> 00:11:03,150
done and all that stuff this is

00:11:01,020 --> 00:11:05,190
semantics which the rules can rely on

00:11:03,150 --> 00:11:08,250
the chains can rely on for instance you

00:11:05,190 --> 00:11:10,320
can do a forward match in the input in

00:11:08,250 --> 00:11:12,360
the hard way of course oh it relies on

00:11:10,320 --> 00:11:15,089
routing information and the semantics

00:11:12,360 --> 00:11:16,920
are quite different so I think this is

00:11:15,089 --> 00:11:17,910
actually the right approach to say we

00:11:16,920 --> 00:11:20,190
are in

00:11:17,910 --> 00:11:23,790
a different spot in the networking

00:11:20,190 --> 00:11:26,160
processing path right now and so and

00:11:23,790 --> 00:11:29,910
represent that as a different chain so

00:11:26,160 --> 00:11:31,140
Patrick the other reason I don't want to

00:11:29,910 --> 00:11:32,370
do the verification in the drivers

00:11:31,140 --> 00:11:34,230
because it's going to be duplicated

00:11:32,370 --> 00:11:36,030
across every driver it like if you if

00:11:34,230 --> 00:11:37,680
you do their model incorrectly then the

00:11:36,030 --> 00:11:39,660
core can know if the flow is legal or

00:11:37,680 --> 00:11:41,640
not right so we can write that code once

00:11:39,660 --> 00:11:43,890
and not have everyone rewrite it right

00:11:41,640 --> 00:11:45,330
but those are kind of so first to

00:11:43,890 --> 00:11:48,000
address for patrick said we are actually

00:11:45,330 --> 00:11:50,130
doing what you just said today Tim

00:11:48,000 --> 00:11:51,690
listening supports that what we do is we

00:11:50,130 --> 00:11:54,060
scrape the rules out of the colonel

00:11:51,690 --> 00:11:56,610
weary compile all the things that we

00:11:54,060 --> 00:11:58,020
said out that we reassemble the rules to

00:11:56,610 --> 00:12:00,990
the hardware capability and we stick it

00:11:58,020 --> 00:12:05,400
into hardware and we handle the proper

00:12:00,990 --> 00:12:07,950
positioning by Jane it's painful I know

00:12:05,400 --> 00:12:09,840
he said right so it's painful but the

00:12:07,950 --> 00:12:11,430
downside is here's the reason why

00:12:09,840 --> 00:12:14,100
anything else would be for us very

00:12:11,430 --> 00:12:18,510
problematic the way people are doing

00:12:14,100 --> 00:12:21,330
things today ah even the people who are

00:12:18,510 --> 00:12:25,950
deploying with again enterprise big

00:12:21,330 --> 00:12:28,320
Cisco boxes they model their entire ACL

00:12:25,950 --> 00:12:31,350
policy their security policy using Linux

00:12:28,320 --> 00:12:32,970
virtual machines up front before they

00:12:31,350 --> 00:12:35,580
actually go deploy it just so that they

00:12:32,970 --> 00:12:38,190
know that these policies would do what I

00:12:35,580 --> 00:12:40,440
expected to do and what we want to be

00:12:38,190 --> 00:12:42,750
able to what cumulus has done is say

00:12:40,440 --> 00:12:45,390
just take those same IP table rules dump

00:12:42,750 --> 00:12:47,220
them in it works if we introduce now

00:12:45,390 --> 00:12:49,080
model that says oh but now you also have

00:12:47,220 --> 00:12:51,360
to make the choice that this will get

00:12:49,080 --> 00:12:53,430
selected for Hardware versus what would

00:12:51,360 --> 00:12:55,350
run any of you it breaks our model

00:12:53,430 --> 00:12:57,980
completely I'm very sure that it's

00:12:55,350 --> 00:13:01,350
basically impossibility to a semantic

00:12:57,980 --> 00:13:02,610
equivalent translation of and that's one

00:13:01,350 --> 00:13:04,860
of the points if you want if you're

00:13:02,610 --> 00:13:06,690
simulating transparency and then you

00:13:04,860 --> 00:13:09,390
need also to be equivalent in what

00:13:06,690 --> 00:13:10,890
you're doing the basic rules had sorts

00:13:09,390 --> 00:13:12,750
with the rule which is based on

00:13:10,890 --> 00:13:14,250
connection tracking state at that point

00:13:12,750 --> 00:13:16,110
your vigil gundu me that when you fed

00:13:14,250 --> 00:13:18,630
already it's basically the first rule

00:13:16,110 --> 00:13:20,610
you have counters at what which point

00:13:18,630 --> 00:13:23,640
you fail and it now conquers people so

00:13:20,610 --> 00:13:26,520
so what we the choice we made was we

00:13:23,640 --> 00:13:28,520
have a pre IP table processor that

00:13:26,520 --> 00:13:31,200
basically sets up and does a

00:13:28,520 --> 00:13:33,420
asynchronous query of hardware so the

00:13:31,200 --> 00:13:35,760
validations that John was talking about

00:13:33,420 --> 00:13:38,430
we do the validation and we'll pre will

00:13:35,760 --> 00:13:41,970
prevail the rule if it wasn't going to

00:13:38,430 --> 00:13:45,360
pass so maybe a day and it's not always

00:13:41,970 --> 00:13:47,100
just about translation see we don't want

00:13:45,360 --> 00:13:48,930
to have the same rules in software that

00:13:47,100 --> 00:13:50,820
we have in hardware and you can't do it

00:13:48,930 --> 00:13:52,170
if you don't separate the chains no as

00:13:50,820 --> 00:13:53,340
you may want to process something in

00:13:52,170 --> 00:13:55,890
Hardware differently then you're gonna

00:13:53,340 --> 00:13:57,810
process it and software for a bunch of

00:13:55,890 --> 00:13:59,280
reasons that's not our requirement is we

00:13:57,810 --> 00:14:01,080
won the exact same rules and software

00:13:59,280 --> 00:14:02,520
and hardware that's what you can do it

00:14:01,080 --> 00:14:06,120
in user space and translate it down in

00:14:02,520 --> 00:14:08,100
two into the his uh every chain and

00:14:06,120 --> 00:14:10,110
we're not seeing we are not okay with

00:14:08,100 --> 00:14:11,700
this model I think this should this can

00:14:10,110 --> 00:14:14,040
also be present it's just that the

00:14:11,700 --> 00:14:16,470
seamless off should be a la moral 40

00:14:14,040 --> 00:14:18,300
yeah it can't be the only model yeah

00:14:16,470 --> 00:14:20,100
exactly I was just about to sit and say

00:14:18,300 --> 00:14:22,140
the same thing and I think we all agree

00:14:20,100 --> 00:14:23,850
that model is beautiful but it's not for

00:14:22,140 --> 00:14:27,060
everybody and I think they have some

00:14:23,850 --> 00:14:29,280
side effects um and I think both my own

00:14:27,060 --> 00:14:31,500
I kind of agree with Patrick because I

00:14:29,280 --> 00:14:33,390
and I tried to mate the same statement

00:14:31,500 --> 00:14:35,670
before I think it was not understood I

00:14:33,390 --> 00:14:37,650
think we should have both models frankly

00:14:35,670 --> 00:14:40,440
because I love what you're doing and I

00:14:37,650 --> 00:14:42,090
would actually love to use it but I kind

00:14:40,440 --> 00:14:44,550
of think that we cannot I cannot solve

00:14:42,090 --> 00:14:47,490
all the use cases that's so the over i

00:14:44,550 --> 00:14:49,680
totally agree that the overlap model is

00:14:47,490 --> 00:14:52,560
required completely like there's no

00:14:49,680 --> 00:14:55,370
question about that but do not have the

00:14:52,560 --> 00:14:57,720
symmetric the pure symmetric model means

00:14:55,370 --> 00:15:00,330
fundamentally to us it means that linux

00:14:57,720 --> 00:15:02,070
as an enterprise control plane will have

00:15:00,330 --> 00:15:04,320
to make people choose that it's not just

00:15:02,070 --> 00:15:07,920
linux it's linux but with the hardware

00:15:04,320 --> 00:15:10,170
offload offshoot if you will and that's

00:15:07,920 --> 00:15:13,350
a choice we don't want to push people in

00:15:10,170 --> 00:15:15,570
I just wanted to add Thomas's statement

00:15:13,350 --> 00:15:17,250
I'm a big fan of doing stuff

00:15:15,570 --> 00:15:18,750
transparently if it's possible but I

00:15:17,250 --> 00:15:20,820
don't see in this case that it's

00:15:18,750 --> 00:15:22,230
actually possible so I don't understand

00:15:20,820 --> 00:15:24,120
how you can actually translate those

00:15:22,230 --> 00:15:25,590
rules put them in the hardware and

00:15:24,120 --> 00:15:27,930
simulate that it's actually the same

00:15:25,590 --> 00:15:29,430
thing which is happening so I don't

00:15:27,930 --> 00:15:31,050
really see how this could possibly work

00:15:29,430 --> 00:15:34,020
we have a switch somewhere here we can

00:15:31,050 --> 00:15:35,940
show you you're you're referring to IP

00:15:34,020 --> 00:15:37,290
table I we're talking NF tables which

00:15:35,940 --> 00:15:39,030
are these on and off tables you're right

00:15:37,290 --> 00:15:41,460
this is this is all decks tables

00:15:39,030 --> 00:15:44,730
iptables yeah you're right so and and

00:15:41,460 --> 00:15:45,180
just to make you feel better my reaction

00:15:44,730 --> 00:15:53,070
too

00:15:45,180 --> 00:15:54,600
of tables was oh crap so so so you're

00:15:53,070 --> 00:15:56,430
right i mean enough tables is a lot more

00:15:54,600 --> 00:15:58,680
powerful and there is a lot of semantics

00:15:56,430 --> 00:16:00,300
and actually my i was referring to

00:15:58,680 --> 00:16:02,070
iptables i wasn't expecting you to

00:16:00,300 --> 00:16:04,080
offload the nft ever saw this kind of

00:16:02,070 --> 00:16:05,610
and if type is actually it should make

00:16:04,080 --> 00:16:07,320
it easier to generate the hardware

00:16:05,610 --> 00:16:09,900
filters because we are basically using

00:16:07,320 --> 00:16:11,250
the same parameter ization but from the

00:16:09,900 --> 00:16:12,600
semantics point of view it doesn't

00:16:11,250 --> 00:16:14,340
really make a difference because as I

00:16:12,600 --> 00:16:16,290
was saying most rule sets will include

00:16:14,340 --> 00:16:18,480
something which is impossible to offload

00:16:16,290 --> 00:16:21,060
in a semantically equivalent way in one

00:16:18,480 --> 00:16:23,070
of the first expressions matches rules

00:16:21,060 --> 00:16:24,720
very soon in the beginning so I don't

00:16:23,070 --> 00:16:26,550
see how you can actually do that now

00:16:24,720 --> 00:16:28,950
what we do in that case is we fail the

00:16:26,550 --> 00:16:31,290
rule we we tell the user that this rule

00:16:28,950 --> 00:16:33,390
is not hardware accelerated and thereby

00:16:31,290 --> 00:16:35,030
your last transaction is completely

00:16:33,390 --> 00:16:37,200
faced so at that point you have to

00:16:35,030 --> 00:16:39,360
separate the rule sets you have to pull

00:16:37,200 --> 00:16:41,910
individual rules all you say okay yeah

00:16:39,360 --> 00:16:45,600
we are going to at that point you have

00:16:41,910 --> 00:16:49,230
to deal with overlap with Nova level I

00:16:45,600 --> 00:16:51,600
mean rules to overlap and reality and so

00:16:49,230 --> 00:16:53,270
in our use case it's not that is not the

00:16:51,600 --> 00:16:55,500
case what what we've seen right i mean

00:16:53,270 --> 00:16:58,380
enterprise people typically are putting

00:16:55,500 --> 00:17:00,330
1020 not the vonage but within the data

00:16:58,380 --> 00:17:03,900
center 10 20 30 rules it's mostly

00:17:00,330 --> 00:17:05,820
preventing crosstalk and as i said

00:17:03,900 --> 00:17:07,890
they'll model it on a vm will make sure

00:17:05,820 --> 00:17:09,510
they'll deploy it on a view and then see

00:17:07,890 --> 00:17:11,220
if they can accelerate it in harder if

00:17:09,510 --> 00:17:13,260
you have something very simple where it

00:17:11,220 --> 00:17:15,060
just have let's say you're using a

00:17:13,260 --> 00:17:17,760
couple of port numbers a couple of very

00:17:15,060 --> 00:17:18,870
simple a CL so i can see that you can do

00:17:17,760 --> 00:17:20,160
that and that you can't do that

00:17:18,870 --> 00:17:23,730
transparently that's our ninety percent

00:17:20,160 --> 00:17:27,060
use kids your use case yes yes yes I get

00:17:23,730 --> 00:17:28,410
that um I mean I not as opposed to doing

00:17:27,060 --> 00:17:32,400
that if it's very clear and very

00:17:28,410 --> 00:17:35,160
possible and that's all she saying but

00:17:32,400 --> 00:17:38,700
don't everything I'm saying it's a from

00:17:35,160 --> 00:17:40,500
that can I season yeah haha Patrick you

00:17:38,700 --> 00:17:41,910
basically want just separate that

00:17:40,500 --> 00:17:43,800
there's some rules that get offloaded

00:17:41,910 --> 00:17:47,460
and some that don't right that's your

00:17:43,800 --> 00:17:50,010
end goal basically yes sure um my

00:17:47,460 --> 00:17:52,680
opinion is if you want yes it's van Gogh

00:17:50,010 --> 00:17:54,210
yeah right right so you if it does it

00:17:52,680 --> 00:17:57,510
doesn't have to be in a chain it could

00:17:54,210 --> 00:17:58,800
be user intent that's or control intent

00:17:57,510 --> 00:18:00,660
that tells you that

00:17:58,800 --> 00:18:02,460
did this to be offloaded the chain is

00:18:00,660 --> 00:18:03,930
basically just an abstraction because

00:18:02,460 --> 00:18:06,270
we're dealing with chains so we're

00:18:03,930 --> 00:18:08,700
trying to use the same representation

00:18:06,270 --> 00:18:10,860
which we always do the network yeah can

00:18:08,700 --> 00:18:12,480
I add a rule to a chain that offloads

00:18:10,860 --> 00:18:15,660
and a chain that as an offload at the

00:18:12,480 --> 00:18:18,000
same time sure okay if I then we're

00:18:15,660 --> 00:18:19,530
probably saying the same thing yes I

00:18:18,000 --> 00:18:21,330
guess so I mean his point was

00:18:19,530 --> 00:18:22,890
transparency because the rules that is

00:18:21,330 --> 00:18:25,800
tested in a simulated environment

00:18:22,890 --> 00:18:28,200
without offloading capabilities and so

00:18:25,800 --> 00:18:30,420
once his customers have tested their

00:18:28,200 --> 00:18:35,970
rule sets they don't feel comfortable

00:18:30,420 --> 00:18:39,150
moving them to a different chain well it

00:18:35,970 --> 00:18:41,250
seems to be bureaucratic yeah they have

00:18:39,150 --> 00:18:43,410
yeah there's some markets which are like

00:18:41,250 --> 00:18:44,820
that so I'll Thomas I think we're

00:18:43,410 --> 00:18:47,070
actually going in circles and doing the

00:18:44,820 --> 00:18:48,690
same thing or saying the same thing we

00:18:47,070 --> 00:18:51,000
understand that we cannot upload

00:18:48,690 --> 00:18:53,570
everything and we need user intent to

00:18:51,000 --> 00:18:56,250
define a policy and how to do it and

00:18:53,570 --> 00:18:58,530
what I think what we learned today is

00:18:56,250 --> 00:18:59,550
that we want every hard of capability

00:18:58,530 --> 00:19:01,770
that we offer we want to have a

00:18:59,550 --> 00:19:03,900
background in software if we can fall

00:19:01,770 --> 00:19:07,530
back to the CPU so there's always a cpu

00:19:03,900 --> 00:19:09,600
slow path so I in my view intent in this

00:19:07,530 --> 00:19:12,320
case is I don't want anything to fall to

00:19:09,600 --> 00:19:14,880
the CPU if I choose not to be right

00:19:12,320 --> 00:19:16,320
coming back to pablos proposal I think

00:19:14,880 --> 00:19:18,690
it makes sense to express us like that

00:19:16,320 --> 00:19:21,060
and regarding your problems um I would

00:19:18,690 --> 00:19:24,900
simply add some emulation for the

00:19:21,060 --> 00:19:26,520
hardware chain which can actually make

00:19:24,900 --> 00:19:28,050
your customers feel comfortable that

00:19:26,520 --> 00:19:31,620
they actually tested in the crochet

00:19:28,050 --> 00:19:33,870
simply rename the family name or you

00:19:31,620 --> 00:19:36,420
could load the hardware chain on your

00:19:33,870 --> 00:19:37,680
initial software implementation it would

00:19:36,420 --> 00:19:38,880
do the software it would go through the

00:19:37,680 --> 00:19:43,080
software stack it wouldn't go into a

00:19:38,880 --> 00:19:44,910
piece of hardware yes yes so but

00:19:43,080 --> 00:19:46,170
otherwise I think Pablo's proposal makes

00:19:44,910 --> 00:19:49,140
it makes a lot of sense to have a

00:19:46,170 --> 00:19:51,600
semantical well to have a clear split

00:19:49,140 --> 00:19:53,010
between the offloaded stuff in the norm

00:19:51,600 --> 00:19:54,900
I think independent of anything we're

00:19:53,010 --> 00:19:57,660
discussing here with the nft hardware

00:19:54,900 --> 00:20:00,090
thing it is worth investigating whether

00:19:57,660 --> 00:20:01,710
we can make a safe subset of hardware

00:20:00,090 --> 00:20:03,630
off loadable things on the other tables

00:20:01,710 --> 00:20:06,930
and and we can determine if that's

00:20:03,630 --> 00:20:08,820
semantically feasible yeah I I have some

00:20:06,930 --> 00:20:11,400
it's worth looking into yes I did that

00:20:08,820 --> 00:20:12,330
already about ten years ago we made a

00:20:11,400 --> 00:20:14,250
study for come

00:20:12,330 --> 00:20:16,140
the end actually the result was the

00:20:14,250 --> 00:20:18,779
normal rules that with failed in the

00:20:16,140 --> 00:20:20,760
first couple to three on lines basically

00:20:18,779 --> 00:20:26,370
everything we tell the people to do in a

00:20:20,760 --> 00:20:28,320
row set we make it fail can I ask you

00:20:26,370 --> 00:20:32,549
one more question Paolo do you mind if I

00:20:28,320 --> 00:20:35,640
have a chain / / table because I think

00:20:32,549 --> 00:20:38,370
that solves my my my set rules problem

00:20:35,640 --> 00:20:40,409
if I can have a chain / table all your

00:20:38,370 --> 00:20:42,419
nft stuff still works I just have

00:20:40,409 --> 00:20:44,639
instead of having one chain I'll have 5

00:20:42,419 --> 00:20:46,500
why do you want to have several chains

00:20:44,639 --> 00:20:47,970
because in the actual hardware I have a

00:20:46,500 --> 00:20:49,470
pipeline and I have different they're

00:20:47,970 --> 00:20:51,510
executed in different orders so you have

00:20:49,470 --> 00:20:54,179
different different ACA to ACL tables

00:20:51,510 --> 00:20:56,250
yes and I also can do go tues so I could

00:20:54,179 --> 00:20:58,889
relax your go to restrictions a little

00:20:56,250 --> 00:21:01,409
bit I mean I obviously maybe first you

00:20:58,889 --> 00:21:03,450
want to start simple but you could relax

00:21:01,409 --> 00:21:05,789
the kind of strange that way back at all

00:21:03,450 --> 00:21:09,120
with reverse they always reverse the all

00:21:05,789 --> 00:21:11,940
the tables I mean that's what the go

00:21:09,120 --> 00:21:13,559
code to is for great you actually you do

00:21:11,940 --> 00:21:16,440
support jumps between the tables right

00:21:13,559 --> 00:21:18,299
I'm so actually I think we should expose

00:21:16,440 --> 00:21:19,710
the capabilities of the hardware

00:21:18,299 --> 00:21:22,950
basically if the hardware supports

00:21:19,710 --> 00:21:25,110
multiple what you called heads in NF

00:21:22,950 --> 00:21:27,990
tables language it would be change I

00:21:25,110 --> 00:21:29,580
guess we should support basically create

00:21:27,990 --> 00:21:32,779
and by default allow you to populate

00:21:29,580 --> 00:21:36,419
them allow you to add jumps between them

00:21:32,779 --> 00:21:38,399
and and then we could use the get flow

00:21:36,419 --> 00:21:41,190
stuff that we have either either

00:21:38,399 --> 00:21:43,380
embedded in this API somehow or just as

00:21:41,190 --> 00:21:45,510
its own API and you can get the get all

00:21:43,380 --> 00:21:48,840
the capabilities and then i have my set

00:21:45,510 --> 00:21:54,539
kind of functionality but in a more I

00:21:48,840 --> 00:21:57,590
guess friendly way I guess any okay

00:21:54,539 --> 00:21:57,590
thank thank you

00:22:02,490 --> 00:22:06,240
I was just want to say that I would love

00:22:04,440 --> 00:22:08,070
to have the same functionality in TC so

00:22:06,240 --> 00:22:10,980
I can have a quarter of our kitties can

00:22:08,070 --> 00:22:13,380
just add my you are you working on that

00:22:10,980 --> 00:22:16,380
well this was planned from the beginning

00:22:13,380 --> 00:22:21,170
basically are to be able I mean nobody

00:22:16,380 --> 00:22:31,020
likes TC classification except drama and

00:22:21,170 --> 00:22:33,210
this I mean I think we had we had 15

00:22:31,020 --> 00:22:35,610
years to make that code workable in some

00:22:33,210 --> 00:22:38,130
way we had vernis gcng at some point but

00:22:35,610 --> 00:22:39,660
it's gone and I don't think it will

00:22:38,130 --> 00:22:41,670
happen in the next 15 years actually

00:22:39,660 --> 00:22:43,200
people will still fight Ian well and

00:22:41,670 --> 00:22:45,900
we'll still have to read the source code

00:22:43,200 --> 00:22:56,130
to actually use that stuff so we have

00:22:45,900 --> 00:22:57,990
the classifications so yeah it's not so

00:22:56,130 --> 00:23:00,270
it's not so easy to actually hook that

00:22:57,990 --> 00:23:02,460
up and represent it in a natural fashion

00:23:00,270 --> 00:23:04,320
but this is definitely something I've

00:23:02,460 --> 00:23:06,929
been thinking about for a long time and

00:23:04,320 --> 00:23:10,490
we're going to do it at some point if

00:23:06,929 --> 00:23:12,630
you I have offloaded TC into a hard way

00:23:10,490 --> 00:23:15,990
like you say ten years ago I did

00:23:12,630 --> 00:23:18,179
attained at least ten years ago it works

00:23:15,990 --> 00:23:21,240
it it's a not sure it's a good fit now

00:23:18,179 --> 00:23:23,670
if you unexposed pipelines I agree that

00:23:21,240 --> 00:23:26,250
you know having them those pipelines as

00:23:23,670 --> 00:23:30,840
tables will make more sense however we

00:23:26,250 --> 00:23:33,270
can expose pipelines as well I don't I

00:23:30,840 --> 00:23:37,170
think that you can just displace TC with

00:23:33,270 --> 00:23:39,120
NFTE out of the blue sorry I think

00:23:37,170 --> 00:23:41,040
Thomas's question was more if we would

00:23:39,120 --> 00:23:43,230
be able to use NF tables for TC

00:23:41,040 --> 00:23:46,140
classification not about offloading any

00:23:43,230 --> 00:23:47,820
of that part we also not going to get

00:23:46,140 --> 00:23:49,530
rid of TC of course not we're going to

00:23:47,820 --> 00:23:51,990
provide an alternative classification

00:23:49,530 --> 00:23:53,400
system which sure we're not going to

00:23:51,990 --> 00:23:55,650
break that stuff I mean we're just going

00:23:53,400 --> 00:23:58,140
to provide I was headed laughs yesterday

00:23:55,650 --> 00:24:00,929
because we were saying don't rewrite it

00:23:58,140 --> 00:24:03,150
don't write another one this was

00:24:00,929 --> 00:24:05,730
actually the intention of course to also

00:24:03,150 --> 00:24:08,250
be there is a lot of value in my opinion

00:24:05,730 --> 00:24:10,380
and B being able to use the same

00:24:08,250 --> 00:24:12,660
classification language for all these

00:24:10,380 --> 00:24:14,140
different classification systems so this

00:24:12,660 --> 00:24:16,510
is an obvious

00:24:14,140 --> 00:24:17,950
thing to do in my opinion language yet

00:24:16,510 --> 00:24:19,630
probably don't have much disagreement on

00:24:17,950 --> 00:24:22,420
that so you're saying you can have n ft

00:24:19,630 --> 00:24:26,680
presenter language that may work with TC

00:24:22,420 --> 00:24:28,570
with the TC infrastructure also the same

00:24:26,680 --> 00:24:31,180
capabilities of course basically TCU

00:24:28,570 --> 00:24:33,910
will invoke the NF tables classification

00:24:31,180 --> 00:24:51,090
engine and that one will return some

00:24:33,910 --> 00:24:55,150
closet years hey yeah i'm just not well

00:24:51,090 --> 00:24:58,240
clear you have some ngos and at some

00:24:55,150 --> 00:25:00,670
stage the rule gets passed down to the

00:24:58,240 --> 00:25:02,800
india yeah the resource of transaction

00:25:00,670 --> 00:25:04,870
object every transaction object is a

00:25:02,800 --> 00:25:07,870
container of basically containing the

00:25:04,870 --> 00:25:09,730
command I contains the object and any

00:25:07,870 --> 00:25:12,100
context information that is required to

00:25:09,730 --> 00:25:13,660
perform the command ok so the object

00:25:12,100 --> 00:25:16,030
comes down to the indio and the india

00:25:13,660 --> 00:25:17,740
hose attached to a device yeah the end

00:25:16,030 --> 00:25:19,990
the NDL received the lease of

00:25:17,740 --> 00:25:23,770
transaction and it's going to trade for

00:25:19,990 --> 00:25:28,120
24 for each transaction object so so

00:25:23,770 --> 00:25:29,680
many question is it was not that um how

00:25:28,120 --> 00:25:32,110
does it associate the object with the

00:25:29,680 --> 00:25:34,660
device and uh and the following question

00:25:32,110 --> 00:25:36,490
is the situation where actually multiple

00:25:34,660 --> 00:25:39,160
devices are associated with the same

00:25:36,490 --> 00:25:41,110
object and if so how does what if one

00:25:39,160 --> 00:25:43,660
has the capability to do an offload and

00:25:41,110 --> 00:25:47,110
the other one doesn't yeah you have to

00:25:43,660 --> 00:25:48,820
associate the UM the base chain to do to

00:25:47,110 --> 00:25:53,370
the device okay so there's a clear

00:25:48,820 --> 00:25:53,370
association yes change yes thank you

00:25:53,850 --> 00:26:00,760
okay now I'm even more scared so I think

00:25:58,210 --> 00:26:02,020
that is exactly was okay number one I

00:26:00,760 --> 00:26:03,820
want to make sure that we instead of

00:26:02,020 --> 00:26:06,310
calling it hardware maybe we call it off

00:26:03,820 --> 00:26:08,590
load because at least then the emulated

00:26:06,310 --> 00:26:10,870
model is something that makes sense

00:26:08,590 --> 00:26:13,750
otherwise telling customers you're going

00:26:10,870 --> 00:26:15,040
to run emulated chains on and you're

00:26:13,750 --> 00:26:19,750
going to call them Hardware makes no

00:26:15,040 --> 00:26:21,640
sense at all and so I I'm not sure I

00:26:19,750 --> 00:26:23,110
fully understood what he said so if I

00:26:21,640 --> 00:26:25,450
have two devices with two different

00:26:23,110 --> 00:26:27,280
capabilities am I going to now have to

00:26:25,450 --> 00:26:27,730
mark I guess that you have to make

00:26:27,280 --> 00:26:31,120
another

00:26:27,730 --> 00:26:40,390
of tea table okay perfect good answer

00:26:31,120 --> 00:26:42,820
yes no no it's one per device yeah well

00:26:40,390 --> 00:26:46,180
we actually won change their device the

00:26:42,820 --> 00:26:47,500
idea well I mean we just talked about if

00:26:46,180 --> 00:26:49,270
the hardware actually supports multiple

00:26:47,500 --> 00:26:51,730
chains and jumps we can also expose

00:26:49,270 --> 00:26:54,220
those it would be one table 1 table 1

00:26:51,730 --> 00:26:57,090
table per device and I you have some

00:26:54,220 --> 00:26:59,920
explicit bind operation basically and

00:26:57,090 --> 00:27:02,290
using the exported floor capabilities we

00:26:59,920 --> 00:27:03,820
can use a half user space command line

00:27:02,290 --> 00:27:05,410
front and say okay you using something

00:27:03,820 --> 00:27:09,130
which is not supported in hardware and

00:27:05,410 --> 00:27:16,150
fail and basically it should do what you

00:27:09,130 --> 00:27:18,010
expect repeat Dave's plea it might be

00:27:16,150 --> 00:27:19,900
worth doing the survey again at least

00:27:18,010 --> 00:27:22,090
for the class of devices we are looking

00:27:19,900 --> 00:27:25,450
at i think there is a very high number

00:27:22,090 --> 00:27:27,940
of device capabilities that will fit in

00:27:25,450 --> 00:27:31,030
the base that connection tracking is

00:27:27,940 --> 00:27:34,030
clearly not an option but there is well

00:27:31,030 --> 00:27:36,310
I we don't need to take a survey i guess

00:27:34,030 --> 00:27:39,550
i mean it's of course imaginable if you

00:27:36,310 --> 00:27:43,050
have some very specific simple ACLs then

00:27:39,550 --> 00:27:46,480
it's possible to do that i believe you

00:27:43,050 --> 00:27:48,160
that's not the question by definition

00:27:46,480 --> 00:27:50,220
anything that would be fitting into the

00:27:48,160 --> 00:27:55,330
nmt hardware table would fit into this

00:27:50,220 --> 00:27:57,250
sub safe subset yes i magically yes the

00:27:55,330 --> 00:27:58,750
transparent stuff basically what i was

00:27:57,250 --> 00:28:00,610
saying everything we have been telling

00:27:58,750 --> 00:28:03,100
people for 10 years for building a

00:28:00,610 --> 00:28:05,920
generic rule set will make it fail and

00:28:03,100 --> 00:28:08,920
that's of course the generic case is

00:28:05,920 --> 00:28:11,580
very much impossible to do and it's not

00:28:08,920 --> 00:28:11,580
even both

00:28:19,810 --> 00:28:24,880
I think we're delving into Holly

00:28:22,270 --> 00:28:34,480
discussion we will find some solution

00:28:24,880 --> 00:28:44,470
for that but Pablo many more slides how

00:28:34,480 --> 00:28:45,880
many more slides no good question I on

00:28:44,470 --> 00:28:49,420
your last slide to mention you want to

00:28:45,880 --> 00:28:54,190
digital of NFC tables how like

00:28:49,420 --> 00:28:55,690
specifically you think to do but I was

00:28:54,190 --> 00:28:58,690
just consider indeed that this

00:28:55,690 --> 00:29:00,850
intermediate a data structure could be

00:28:58,690 --> 00:29:03,610
used I mean it would be very easy to

00:29:00,850 --> 00:29:07,570
walk so then you couldn't meet the

00:29:03,610 --> 00:29:10,960
instructions to build the the full the

00:29:07,570 --> 00:29:12,910
full block containing the the EVPs

00:29:10,960 --> 00:29:16,710
instruction I mean probably you don't

00:29:12,910 --> 00:29:20,020
you understand but the details I mean I

00:29:16,710 --> 00:29:21,640
still don't understand but it doesn't

00:29:20,020 --> 00:29:23,140
have any specific plans but he thinks

00:29:21,640 --> 00:29:25,150
that the data structures that would be

00:29:23,140 --> 00:29:27,070
used to pass the rules down to the

00:29:25,150 --> 00:29:29,830
hardware for the nmt hardware table case

00:29:27,070 --> 00:29:32,920
could be beneficial in facilitating a BP

00:29:29,830 --> 00:29:34,900
of implementation I think it was even

00:29:32,920 --> 00:29:36,790
more generic what problem and he was

00:29:34,900 --> 00:29:39,700
meaning that the structures were using

00:29:36,790 --> 00:29:41,470
internally in NF tables I they asked

00:29:39,700 --> 00:29:43,390
basically it can be used to jet which is

00:29:41,470 --> 00:29:45,490
of course true but not really directly

00:29:43,390 --> 00:29:48,150
related to any kind of hardware or

00:29:45,490 --> 00:29:50,380
generate not hardware but offloading

00:29:48,150 --> 00:29:52,930
basically sure you have the Aston you

00:29:50,380 --> 00:29:54,760
can use it to generate some different

00:29:52,930 --> 00:29:56,230
code we're generating netlink hold and

00:29:54,760 --> 00:29:58,810
quotes and we can of course also

00:29:56,230 --> 00:30:01,860
generate eb PF but it's something it's a

00:29:58,810 --> 00:30:05,820
very different subject basically yeah

00:30:01,860 --> 00:30:05,820
Thank You Pablo thank

00:30:06,210 --> 00:30:08,270

YouTube URL: https://www.youtube.com/watch?v=gt77gCdsdc0


