Title: Netdev 1.1 - The CLASShoFIREs: who's got your back?
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 1 - Wednesday February 10, 2016
Description: 
	Jamal Hadi Salim, Lucas Bates
February 2016
Comparing the performance of 3 different tc classifiers: bpf, flower and u32
Captions: 
	00:00:00,020 --> 00:00:07,500
okay so I'm going to talk about

00:00:04,940 --> 00:00:13,650
performance analysis of three different

00:00:07,500 --> 00:00:14,610
TC classifiers that look as an idea we

00:00:13,650 --> 00:00:16,560
thought is going to be done around

00:00:14,610 --> 00:00:19,949
Christmas that didn't happen took about

00:00:16,560 --> 00:00:21,330
six to eight weeks of our time and we we

00:00:19,949 --> 00:00:23,670
don't think this this is not what we

00:00:21,330 --> 00:00:26,310
ended we were we thought we're going to

00:00:23,670 --> 00:00:27,720
eventually end up doing but that's the

00:00:26,310 --> 00:00:29,310
result it's a lot of slides so I'm

00:00:27,720 --> 00:00:33,329
probably going to skip a lot of the

00:00:29,310 --> 00:00:35,370
introductory stuff linux traffic control

00:00:33,329 --> 00:00:37,350
if you don't know what it is there's a

00:00:35,370 --> 00:00:38,489
paper in negative 01 go ahead and read

00:00:37,350 --> 00:00:43,710
it I'm not going to spend a lot of time

00:00:38,489 --> 00:00:47,250
on this other than to say there's a

00:00:43,710 --> 00:00:48,780
couple of hooks on an egress port egress

00:00:47,250 --> 00:00:53,070
side of a port and an ingress side of a

00:00:48,780 --> 00:00:55,680
port you can have classifiers of variety

00:00:53,070 --> 00:00:57,480
of classifiers select a packet which

00:00:55,680 --> 00:01:01,260
then gets exercised through an action

00:00:57,480 --> 00:01:03,120
and may eventually get cute and will be

00:01:01,260 --> 00:01:05,070
scheduled when you have multiple queues

00:01:03,120 --> 00:01:07,470
it will be scheduled out of those one of

00:01:05,070 --> 00:01:09,240
those cues depending on the scheduling

00:01:07,470 --> 00:01:13,350
algorithm so if you have deficit round

00:01:09,240 --> 00:01:16,080
robin it may end up being one one or

00:01:13,350 --> 00:01:21,600
several packets out of each queue that's

00:01:16,080 --> 00:01:23,009
going out on over here I'm not going to

00:01:21,600 --> 00:01:25,229
give a lot of details you go and read

00:01:23,009 --> 00:01:30,990
the paper because we don't have a lot of

00:01:25,229 --> 00:01:32,549
time for this just to focus on the small

00:01:30,990 --> 00:01:36,270
subset where you have the classifiers

00:01:32,549 --> 00:01:39,900
and the actions you typically have a

00:01:36,270 --> 00:01:41,159
bunch of classification rules each of

00:01:39,900 --> 00:01:44,399
which may be a totally different

00:01:41,159 --> 00:01:48,240
classification algorithm and when that

00:01:44,399 --> 00:01:50,430
match is an action gets executed my the

00:01:48,240 --> 00:01:56,490
talk today is just to focus on the

00:01:50,430 --> 00:02:00,930
portion here which is on the different

00:01:56,490 --> 00:02:02,430
classification algun so TC allows you to

00:02:00,930 --> 00:02:04,820
have many different types of classifiers

00:02:02,430 --> 00:02:08,220
the paradigm

00:02:04,820 --> 00:02:12,690
is that you cannot have one specific

00:02:08,220 --> 00:02:15,660
classifier that is capable of doing

00:02:12,690 --> 00:02:17,640
everything or has the best algorithm for

00:02:15,660 --> 00:02:19,740
ever that in the future should we decide

00:02:17,640 --> 00:02:23,250
to make changes we can replace that

00:02:19,740 --> 00:02:26,700
classification algorithm with with the

00:02:23,250 --> 00:02:28,830
latest sitcom paper so that is the

00:02:26,700 --> 00:02:30,090
overriding principle that we allow many

00:02:28,830 --> 00:02:31,920
different classifiers unfortunately that

00:02:30,090 --> 00:02:33,540
sometimes brings usability issues

00:02:31,920 --> 00:02:37,970
because if you use to one classify that

00:02:33,540 --> 00:02:40,590
as X 2 poles or does string searches

00:02:37,970 --> 00:02:41,970
when a new one is introduced they may be

00:02:40,590 --> 00:02:46,070
slightly different syntax and there's

00:02:41,970 --> 00:02:46,070
complaints about that usability aspect

00:02:46,910 --> 00:02:53,910
so what was the motivation for us to do

00:02:50,490 --> 00:02:55,530
this talk there was over the last year

00:02:53,910 --> 00:02:57,990
there have been two new classifiers one

00:02:55,530 --> 00:03:00,810
is flower written by erie which i'm

00:02:57,990 --> 00:03:03,630
going to touch on in the BPF from

00:03:00,810 --> 00:03:05,550
danielle and if you want to call it

00:03:03,630 --> 00:03:08,840
extended vpf although we're not looking

00:03:05,550 --> 00:03:13,590
at the extended vpf in our talk was

00:03:08,840 --> 00:03:15,240
Thomas he tweeted a joke last year when

00:03:13,590 --> 00:03:17,820
I said I haven't done any performance

00:03:15,240 --> 00:03:20,340
analysis since 2005 that was a

00:03:17,820 --> 00:03:22,730
motivation I can't believe I put that

00:03:20,340 --> 00:03:25,140
bullet for him and it's not here and

00:03:22,730 --> 00:03:26,880
this looked like a really easy paper

00:03:25,140 --> 00:03:27,980
right so when I first laid eyes oh yeah

00:03:26,880 --> 00:03:31,200
we're just going to measure performance

00:03:27,980 --> 00:03:33,690
free classifieds how had that can be can

00:03:31,200 --> 00:03:36,239
that be so i started working on this

00:03:33,690 --> 00:03:39,390
then as i was sweating I bumped into

00:03:36,239 --> 00:03:42,600
look us in the hallway and I convinced

00:03:39,390 --> 00:03:43,920
him to work with me because I you know

00:03:42,600 --> 00:03:47,640
you're going to be done by next weekend

00:03:43,920 --> 00:03:49,200
it turned out that it wasn't you I was

00:03:47,640 --> 00:03:57,890
being delusional think it was an easy

00:03:49,200 --> 00:04:01,110
thing to do so you know two months later

00:03:57,890 --> 00:04:02,489
we are not completely done we think

00:04:01,110 --> 00:04:05,810
we'll have another paper for the next

00:04:02,489 --> 00:04:09,890
conference that builds up on this work

00:04:05,810 --> 00:04:14,150
yeah we've done a lot of work on sdn out

00:04:09,890 --> 00:04:16,519
in a day job where we do a lot of SC

00:04:14,150 --> 00:04:18,620
flaw processing

00:04:16,519 --> 00:04:20,419
so you I was more curious after all

00:04:18,620 --> 00:04:24,800
these years how does linux compare

00:04:20,419 --> 00:04:28,220
there's also a lot of discussion on how

00:04:24,800 --> 00:04:30,770
good DP DK is or net map or things of

00:04:28,220 --> 00:04:35,629
that variant that they outperform linux

00:04:30,770 --> 00:04:38,900
ten to one in a typical run right so i

00:04:35,629 --> 00:04:43,340
was curious i wanted to find out right

00:04:38,900 --> 00:04:45,500
so that was the motivation you check the

00:04:43,340 --> 00:04:49,190
time just again we think so you get to

00:04:45,500 --> 00:04:51,259
the final slides so our system on the

00:04:49,190 --> 00:04:53,780
test we are not interested in doing a

00:04:51,259 --> 00:04:54,979
hash on a group of flaws that's so

00:04:53,780 --> 00:04:59,750
boring right now we know we don't want

00:04:54,979 --> 00:05:02,840
to RF you Cadel or the other hashing

00:04:59,750 --> 00:05:04,909
algorithms do to sort of identify by

00:05:02,840 --> 00:05:07,130
five two poles what a group of flaws

00:05:04,909 --> 00:05:09,610
looks like we wanted to do path floor

00:05:07,130 --> 00:05:12,740
because that's what we do in the asics

00:05:09,610 --> 00:05:14,569
analysis each flow must at minimal have

00:05:12,740 --> 00:05:19,250
counters right you guys count packets

00:05:14,569 --> 00:05:23,750
and bites st. and it's some in some

00:05:19,250 --> 00:05:26,060
cases received as well and so one of the

00:05:23,750 --> 00:05:29,830
hardest things that took us in this long

00:05:26,060 --> 00:05:35,210
journey is how do you run this test and

00:05:29,830 --> 00:05:37,789
be fair to the users the different

00:05:35,210 --> 00:05:40,060
classifiers we are testing because a lot

00:05:37,789 --> 00:05:44,900
of you know benchmarking could be a

00:05:40,060 --> 00:05:47,539
marketing game if you wish or you know

00:05:44,900 --> 00:05:50,000
biased in most cases so we were trying

00:05:47,539 --> 00:05:53,120
we have three classifiers the different

00:05:50,000 --> 00:05:55,699
algorithms they behave differently under

00:05:53,120 --> 00:05:58,190
different constraints and how do we come

00:05:55,699 --> 00:06:01,310
up with a set of test cases that would

00:05:58,190 --> 00:06:04,909
be fair to so we don't bias one against

00:06:01,310 --> 00:06:12,949
the other so in others compare oranges

00:06:04,909 --> 00:06:14,539
to oranges so flour EVP f or a slide i'm

00:06:12,949 --> 00:06:16,990
sorry i should say classical BPF because

00:06:14,539 --> 00:06:19,430
we didn't get to the EBP f part and then

00:06:16,990 --> 00:06:21,979
compare that we need to pick something

00:06:19,430 --> 00:06:26,839
that existed for some time so we picked

00:06:21,979 --> 00:06:28,909
you 32 because probably you 32 is the

00:06:26,839 --> 00:06:30,009
most popular TC classify at this point

00:06:28,909 --> 00:06:32,289
is also the most

00:06:30,009 --> 00:06:37,779
x-pro if you want to use it beyond its

00:06:32,289 --> 00:06:39,879
basic features it so you 32 also we

00:06:37,779 --> 00:06:42,550
figured okay we could optimize you 32 so

00:06:39,879 --> 00:06:44,949
farmers was also motivation in this case

00:06:42,550 --> 00:06:48,460
we're going to have fun if we can make

00:06:44,949 --> 00:06:50,649
this thing we can show the power of your

00:06:48,460 --> 00:07:01,330
32 a little bit we're going to flex its

00:06:50,649 --> 00:07:03,639
muscles are we doing on time ok so I'm

00:07:01,330 --> 00:07:05,349
going to talk about I do not have a lot

00:07:03,639 --> 00:07:09,279
of time to talk about the details of

00:07:05,349 --> 00:07:12,249
each classifier but in the case of EBP f

00:07:09,279 --> 00:07:20,319
what you can see is a pointer I could

00:07:12,249 --> 00:07:23,499
use a pointer or I'll just so I BPF

00:07:20,319 --> 00:07:27,459
works by it's got a machine language

00:07:23,499 --> 00:07:31,029
where you have a few by instructions if

00:07:27,459 --> 00:07:33,490
I had a second set of if I could project

00:07:31,029 --> 00:07:34,959
another one if I had another projector i

00:07:33,490 --> 00:07:39,069
would show you the machine code that it

00:07:34,959 --> 00:07:41,050
outputs there's a lot of users of EBP f

00:07:39,069 --> 00:07:43,059
most popular probably as all the

00:07:41,050 --> 00:07:46,860
sniffers tcpdump why shark underneath

00:07:43,059 --> 00:07:49,659
there and pick up which injects BPF

00:07:46,860 --> 00:07:53,559
machine code or byte code into the

00:07:49,659 --> 00:07:56,589
kernel at a socket filter level in it's

00:07:53,559 --> 00:07:58,990
a classification very powerful classify

00:07:56,589 --> 00:08:01,870
it comes with machine instructions to

00:07:58,990 --> 00:08:03,809
load and to compare that's it and it has

00:08:01,870 --> 00:08:10,899
a bunch of registers so the classical

00:08:03,809 --> 00:08:13,809
BPF has two registers 32-bit the EBP f

00:08:10,899 --> 00:08:20,019
which Alexei discussed in negative 01

00:08:13,809 --> 00:08:21,939
has a bunch more registers and a bunch

00:08:20,019 --> 00:08:23,889
more 64-bit instructions as opposed to

00:08:21,939 --> 00:08:25,779
32 bit so it's a lot more power that has

00:08:23,889 --> 00:08:27,879
been extended but that's not what I'm

00:08:25,779 --> 00:08:31,180
discussing I did not have time to get to

00:08:27,879 --> 00:08:33,550
it so we are not going to talk about EBP

00:08:31,180 --> 00:08:37,949
F in this talk we're just talking about

00:08:33,550 --> 00:08:43,149
what exists today on the CLS BPF and

00:08:37,949 --> 00:08:43,900
where it uses the extended by code but

00:08:43,149 --> 00:08:46,420
we're not going to

00:08:43,900 --> 00:08:49,600
going to a lot of details what you need

00:08:46,420 --> 00:08:52,690
to see is this is our BPF classification

00:08:49,600 --> 00:08:56,200
rule would look like you have a bunch of

00:08:52,690 --> 00:08:58,690
instructions which load a packet offset

00:08:56,200 --> 00:09:00,820
of some form and then does a compared to

00:08:58,690 --> 00:09:04,060
what's to be expected and if it succeeds

00:09:00,820 --> 00:09:06,700
it proceeds to return the true if it

00:09:04,060 --> 00:09:08,650
doesn't it's a false Linux did extend

00:09:06,700 --> 00:09:12,910
vpf so that you can actually return

00:09:08,650 --> 00:09:14,680
something more than true or false so

00:09:12,910 --> 00:09:18,120
that's a Linux extension right so that's

00:09:14,680 --> 00:09:18,120
why I said let the classical next wave

00:09:18,240 --> 00:09:26,830
BPF is a Ford AG as you can see it's a

00:09:23,100 --> 00:09:29,170
it's unidirectional it can branch but it

00:09:26,830 --> 00:09:31,660
can't look back right there's no loops

00:09:29,170 --> 00:09:33,190
and because it's machine code

00:09:31,660 --> 00:09:34,720
instructions is why different

00:09:33,190 --> 00:09:37,090
classifiers have different attributes

00:09:34,720 --> 00:09:39,940
it's machine code essentially so you

00:09:37,090 --> 00:09:44,110
have earlier instructions basically

00:09:39,940 --> 00:09:46,270
registers Lord instructions compare you

00:09:44,110 --> 00:09:48,940
can very easily take that instruction

00:09:46,270 --> 00:09:52,870
set and map it to any cpu instruction

00:09:48,940 --> 00:09:54,850
set so just in time compilers evolved

00:09:52,870 --> 00:09:57,340
over time so now about every

00:09:54,850 --> 00:10:00,160
architecture Linux has BPF with a get

00:09:57,340 --> 00:10:01,510
built in so when you're running bytecode

00:10:00,160 --> 00:10:05,470
in the colonel you're running machine

00:10:01,510 --> 00:10:08,040
instructions right and I believe are the

00:10:05,470 --> 00:10:12,340
operating systems have that these days

00:10:08,040 --> 00:10:17,170
right what did BPF classic the

00:10:12,340 --> 00:10:21,840
classifier that's from vpf the CLS BPF

00:10:17,170 --> 00:10:24,970
does is it you can take now instead of

00:10:21,840 --> 00:10:27,250
the single program led like the big

00:10:24,970 --> 00:10:30,280
blowup you can actually take multiple

00:10:27,250 --> 00:10:32,710
and combine them right so now you can

00:10:30,280 --> 00:10:37,780
have little programs or little prague

00:10:32,710 --> 00:10:41,070
let that can be serialized see the gray

00:10:37,780 --> 00:10:45,240
box there is essentially one of those

00:10:41,070 --> 00:10:50,290
right and now you can actually see

00:10:45,240 --> 00:10:54,370
realize them you can also have them look

00:10:50,290 --> 00:10:56,590
back so you can have branches as well as

00:10:54,370 --> 00:10:57,600
loops if you want it as I was showing

00:10:56,590 --> 00:11:00,130
you earlier on

00:10:57,600 --> 00:11:01,570
this is what TC allows you to do is you

00:11:00,130 --> 00:11:03,670
can actually look back and pick another

00:11:01,570 --> 00:11:05,890
role based on some condition of your

00:11:03,670 --> 00:11:08,410
choice based on what the action that you

00:11:05,890 --> 00:11:15,790
want to execute next so we basically end

00:11:08,410 --> 00:11:21,190
up adding loops Daniel a workman was

00:11:15,790 --> 00:11:24,520
probably here wrote the CLS BPF Erie

00:11:21,190 --> 00:11:26,380
uses a existing vpf best linux packet

00:11:24,520 --> 00:11:28,900
filter the code is the same basically

00:11:26,380 --> 00:11:33,300
BPF program round it's the same as used

00:11:28,900 --> 00:11:35,380
on socket as is it isn't on the TCC LS

00:11:33,300 --> 00:11:37,600
there's also another extension that was

00:11:35,380 --> 00:11:39,730
made where BPF bytecode could be used

00:11:37,600 --> 00:11:42,640
for actions I'm not going to talk about

00:11:39,730 --> 00:11:44,700
that right we didn't have done like I

00:11:42,640 --> 00:11:47,740
said we started thinking this is simple

00:11:44,700 --> 00:11:52,540
real as you are delusional and just had

00:11:47,740 --> 00:11:56,020
to focus on a specific set of tests so

00:11:52,540 --> 00:11:59,050
what T seek that basically allows for

00:11:56,020 --> 00:12:00,670
PPF to have is you don't need this big

00:11:59,050 --> 00:12:03,690
monolithic code now you can actually

00:12:00,670 --> 00:12:05,620
have small pieces of object code that

00:12:03,690 --> 00:12:12,100
combined together produce a more

00:12:05,620 --> 00:12:14,260
meaningful result in the ability to

00:12:12,100 --> 00:12:15,880
create loops flower is the other

00:12:14,260 --> 00:12:18,550
classifier that we were interested in it

00:12:15,880 --> 00:12:20,860
was written by erie it started he stole

00:12:18,550 --> 00:12:24,850
it so net dev 01 you represented a paper

00:12:20,860 --> 00:12:28,090
or he was demonstrating how to do flower

00:12:24,850 --> 00:12:31,450
to the open floor 15 14 tuple or

00:12:28,090 --> 00:12:34,120
whatever using TC when it's a bit of the

00:12:31,450 --> 00:12:35,920
patches david miller suggested to going

00:12:34,120 --> 00:12:40,780
to go back and see if you can tie to the

00:12:35,920 --> 00:12:42,930
flow cash so this classifies to utilize

00:12:40,780 --> 00:12:45,790
'as the Linux flow cash which is

00:12:42,930 --> 00:12:48,130
populated at different stages of the of

00:12:45,790 --> 00:12:52,000
the count stack so if your if your

00:12:48,130 --> 00:12:54,760
packet is coming in from the and on an

00:12:52,000 --> 00:12:57,940
ingress side the flow cash is built up

00:12:54,760 --> 00:13:02,650
as you traverse or you bubble up

00:12:57,940 --> 00:13:05,260
different layers of the stack and if you

00:13:02,650 --> 00:13:09,379
are going out outdoors towards the

00:13:05,260 --> 00:13:12,289
egress Thanks you're

00:13:09,379 --> 00:13:14,720
if you're going down the stack you are

00:13:12,289 --> 00:13:17,149
basically the cloak ashes built at the

00:13:14,720 --> 00:13:19,729
different layers by the time you hit the

00:13:17,149 --> 00:13:21,919
egress port you got the flow cash fully

00:13:19,729 --> 00:13:27,709
constructed and you can use that to

00:13:21,919 --> 00:13:29,989
classify so very clever idea and this in

00:13:27,709 --> 00:13:31,459
my opinion should be in under real

00:13:29,989 --> 00:13:33,019
circumstances will be the best

00:13:31,459 --> 00:13:36,769
classifier you can use if you want to

00:13:33,019 --> 00:13:38,419
use it with Linux because it's getting

00:13:36,769 --> 00:13:45,259
for free all this floor cash that was

00:13:38,419 --> 00:13:47,589
already existing and therefore could be

00:13:45,259 --> 00:13:51,439
the most effective now in other words i

00:13:47,589 --> 00:13:54,609
was a bit unfair in this test we as i'll

00:13:51,439 --> 00:13:57,109
demonstrate because we made flower

00:13:54,609 --> 00:13:58,939
rebuild its floor cash every single time

00:13:57,109 --> 00:14:00,789
during the test so it's the worst case

00:13:58,939 --> 00:14:02,989
scenario that flower can perform is

00:14:00,789 --> 00:14:05,449
unfortunately I we try to be fair

00:14:02,989 --> 00:14:06,979
oranges with oranges but we flower we

00:14:05,449 --> 00:14:16,489
may have been a little unfair in our

00:14:06,979 --> 00:14:19,549
tests so basically works okay so when a

00:14:16,489 --> 00:14:22,519
packet comes into flower you the flower

00:14:19,549 --> 00:14:25,729
algorithm checks if it has the cash if

00:14:22,519 --> 00:14:28,279
it's cached already in others does the

00:14:25,729 --> 00:14:29,959
is the flow cash for that packet

00:14:28,279 --> 00:14:33,889
existing otherwise it reconstruct it

00:14:29,959 --> 00:14:38,449
caused the whole slew of flow cash

00:14:33,889 --> 00:14:40,729
builders and then it looks in into its

00:14:38,449 --> 00:14:43,759
database which is an our hash table

00:14:40,729 --> 00:14:46,879
there's a bunch of mem compares and if

00:14:43,759 --> 00:14:48,549
it finds it it proceeds to return to

00:14:46,879 --> 00:14:51,169
execute the actions associated with that

00:14:48,549 --> 00:14:54,079
rule if it doesn't find it then you know

00:14:51,169 --> 00:14:58,069
it returns to the calling classification

00:14:54,079 --> 00:14:59,449
code so our hash table is another thing

00:14:58,069 --> 00:15:02,659
that showed up over the last year it's

00:14:59,449 --> 00:15:07,220
optimized for key based hash table

00:15:02,659 --> 00:15:08,629
implementation so that's how the

00:15:07,220 --> 00:15:10,819
algorithm works and it currently

00:15:08,629 --> 00:15:12,769
supports source destination mark if the

00:15:10,819 --> 00:15:14,989
type source destination IP source

00:15:12,769 --> 00:15:17,269
destination transport pod ingress which

00:15:14,989 --> 00:15:19,699
part if it was being routed or switched

00:15:17,269 --> 00:15:20,690
which product came on there's a few

00:15:19,699 --> 00:15:22,400
other

00:15:20,690 --> 00:15:25,520
flow cash attributes that are not being

00:15:22,400 --> 00:15:29,780
used at the moment mpls labels vlan-id

00:15:25,520 --> 00:15:33,320
is Gary keys and even tipsy and as new

00:15:29,780 --> 00:15:35,300
fields are being added over time onto

00:15:33,320 --> 00:15:38,990
the floor cash flowers should be able to

00:15:35,300 --> 00:15:42,650
make use of them so very nice classified

00:15:38,990 --> 00:15:44,320
very human friendly so the people are

00:15:42,650 --> 00:15:47,330
complaining about TC not being friendly

00:15:44,320 --> 00:15:48,620
you you will like flower and if I had

00:15:47,330 --> 00:15:53,980
another projector we could we could have

00:15:48,620 --> 00:15:57,260
demonstrated it for you all right so now

00:15:53,980 --> 00:16:00,770
the only the ugly 30 it's actually

00:15:57,260 --> 00:16:02,600
called the ugly 32 classifier or it's

00:16:00,770 --> 00:16:05,330
not you doesn't stand for one sign it

00:16:02,600 --> 00:16:06,440
stands for ugly or universal you can

00:16:05,330 --> 00:16:08,030
drink the source code you'll see it at

00:16:06,440 --> 00:16:10,580
the very top it says this is the

00:16:08,030 --> 00:16:11,720
universal or sorry I can I don't have

00:16:10,580 --> 00:16:13,730
another projector but I could have shown

00:16:11,720 --> 00:16:17,060
you the comment is pretty funny actually

00:16:13,730 --> 00:16:19,490
it deserves a t-shirt or is on the

00:16:17,060 --> 00:16:23,060
universal or ugly classified that's what

00:16:19,490 --> 00:16:24,830
you stands for right so I'm not going to

00:16:23,060 --> 00:16:30,760
go into a lot of details other than say

00:16:24,830 --> 00:16:33,860
that it's very nicely constructed a

00:16:30,760 --> 00:16:36,620
series of hash tables that you can

00:16:33,860 --> 00:16:38,660
script so if you know your traffic

00:16:36,620 --> 00:16:41,570
patterns or you know exactly what you

00:16:38,660 --> 00:16:44,300
want to classify with you 32 you can

00:16:41,570 --> 00:16:45,560
build your multi try which is actually

00:16:44,300 --> 00:16:50,530
with something we're going to be showing

00:16:45,560 --> 00:16:56,210
this in one of our tests is you can take

00:16:50,530 --> 00:16:58,310
hash on some source IP pointed to

00:16:56,210 --> 00:17:01,910
another hash table which hashes on a

00:16:58,310 --> 00:17:04,640
destination IP so you can reduce a

00:17:01,910 --> 00:17:06,319
million flow look up to maybe four or

00:17:04,640 --> 00:17:08,230
five if you wished but you have to know

00:17:06,319 --> 00:17:12,410
how you want to arrange your traffic

00:17:08,230 --> 00:17:17,780
lookups right so every hash table has an

00:17:12,410 --> 00:17:19,910
address hex 800 is the default IP is the

00:17:17,780 --> 00:17:22,100
default hash table ID so when you just

00:17:19,910 --> 00:17:24,020
add rules without looking at how they

00:17:22,100 --> 00:17:26,449
added they all added to hash table

00:17:24,020 --> 00:17:29,179
number 800 which has only one packet is

00:17:26,449 --> 00:17:32,270
back at zero and then there's a linked

00:17:29,179 --> 00:17:33,049
list that follows and the filters reside

00:17:32,270 --> 00:17:36,379
over here

00:17:33,049 --> 00:17:39,710
so each filter has a 32 bit address if

00:17:36,379 --> 00:17:42,049
you go and add a roll and then you dump

00:17:39,710 --> 00:17:46,940
it you'll see some weird numbers of this

00:17:42,049 --> 00:17:48,769
phone right to say hash table ID hash I

00:17:46,940 --> 00:17:50,869
think this is referred to as a hash

00:17:48,769 --> 00:17:54,980
table bucket I could be wrong I don't

00:17:50,869 --> 00:17:57,619
have anything in front of me and the

00:17:54,980 --> 00:18:00,230
node ID node ID is one of these so each

00:17:57,619 --> 00:18:04,159
node has another ID so if I look at this

00:18:00,230 --> 00:18:06,499
the study to be key to the filter it

00:18:04,159 --> 00:18:09,340
tells me how I traverse this too much to

00:18:06,499 --> 00:18:13,190
find the filter and each filter has an

00:18:09,340 --> 00:18:14,809
offset length so you say look at this

00:18:13,190 --> 00:18:17,809
offset on the parking Lizzy offset 12

00:18:14,809 --> 00:18:24,109
which is my IP header is source IP I

00:18:17,809 --> 00:18:26,269
think much with the following value much

00:18:24,109 --> 00:18:28,759
use the following mask and it has to be

00:18:26,269 --> 00:18:30,289
the following value so very powerful

00:18:28,759 --> 00:18:31,970
from a machine level describes this is

00:18:30,289 --> 00:18:35,179
moment if you are writing an automated

00:18:31,970 --> 00:18:39,139
our programmatic kind of application

00:18:35,179 --> 00:18:40,940
this would be fantastic to use so and

00:18:39,139 --> 00:18:44,450
you can have a bunch of these North

00:18:40,940 --> 00:18:47,659
nodes by default is a linked list so

00:18:44,450 --> 00:18:53,600
when you just blindly add rules they get

00:18:47,659 --> 00:18:55,669
added into a line list so it's a bit

00:18:53,600 --> 00:18:57,230
tricky it's not as user friendly but you

00:18:55,669 --> 00:18:58,669
don't have to know these details if you

00:18:57,230 --> 00:19:00,559
just you're running your home router or

00:18:58,669 --> 00:19:02,929
a small router you can just add them in

00:19:00,559 --> 00:19:05,450
a linked list what the power it provides

00:19:02,929 --> 00:19:09,129
is you can this is an example of how you

00:19:05,450 --> 00:19:12,379
can rearrange the rules that you should

00:19:09,129 --> 00:19:17,029
set your first hash table to say on back

00:19:12,379 --> 00:19:19,850
at zero I wanted to look at this mask at

00:19:17,029 --> 00:19:21,559
offset 12 and if it matches I wanted to

00:19:19,850 --> 00:19:25,220
use hash table number one the link 1

00:19:21,559 --> 00:19:27,669
points to the hash table 1 and then on

00:19:25,220 --> 00:19:31,279
each of these buckets you had rules

00:19:27,669 --> 00:19:36,440
right so you could do this in a bash

00:19:31,279 --> 00:19:39,019
script and what is important is to be

00:19:36,440 --> 00:19:41,450
able to understand what you're trying to

00:19:39,019 --> 00:19:43,759
mask on you're telling the packet as it

00:19:41,450 --> 00:19:46,480
as it comes in how to traverse during

00:19:43,759 --> 00:19:51,490
its lookups and eventually find

00:19:46,480 --> 00:19:57,280
a march which is preceded by an action

00:19:51,490 --> 00:20:04,990
or a graph of actions to compute anybody

00:19:57,280 --> 00:20:07,510
confused anybody who hasn't used u32 I'm

00:20:04,990 --> 00:20:12,220
surprised the majority have used it okay

00:20:07,510 --> 00:20:15,100
I'm not in hostile territory here but

00:20:12,220 --> 00:20:19,570
but basically the power is that I can

00:20:15,100 --> 00:20:21,549
script things I can totally look at what

00:20:19,570 --> 00:20:25,900
my traffic patterns are for example and

00:20:21,549 --> 00:20:27,070
I can I can create an optimal hash table

00:20:25,900 --> 00:20:28,840
for me so if I have customers who are

00:20:27,070 --> 00:20:31,240
running PvP which is why I've seen most

00:20:28,840 --> 00:20:33,580
people do this well is I can optimize so

00:20:31,240 --> 00:20:35,290
with two lookups I can find what flow it

00:20:33,580 --> 00:20:39,000
is exactly and I can have counters

00:20:35,290 --> 00:20:42,390
wavery flow right and I've seen people

00:20:39,000 --> 00:20:45,520
talk about some really huge numbers now

00:20:42,390 --> 00:20:47,559
BPF is the other one that is capable of

00:20:45,520 --> 00:20:49,929
doing this extended vpf if you write a

00:20:47,559 --> 00:20:51,580
little program you can achieve similar

00:20:49,929 --> 00:20:57,640
goal but you have to write a program as

00:20:51,580 --> 00:21:00,220
opposed to writing a script so now comes

00:20:57,640 --> 00:21:02,679
back to what do you want to measure for

00:21:00,220 --> 00:21:05,080
testing how do we do a fair test oranges

00:21:02,679 --> 00:21:07,000
oranges so there are several metrics we

00:21:05,080 --> 00:21:09,070
could look at one was data path

00:21:07,000 --> 00:21:12,730
throughput performance if I add subtle

00:21:09,070 --> 00:21:20,799
rules using where the classifier is you

00:21:12,730 --> 00:21:22,360
32 vs BPF versus flower what is how many

00:21:20,799 --> 00:21:24,100
packets per second can I get that's

00:21:22,360 --> 00:21:27,490
always the easy thing to do right you

00:21:24,100 --> 00:21:29,200
you want to just add these rules fire a

00:21:27,490 --> 00:21:32,620
bunch of packets and see what the output

00:21:29,200 --> 00:21:35,679
is so that was an easy one so we were we

00:21:32,620 --> 00:21:37,630
our first goal was to tag it i'm going

00:21:35,679 --> 00:21:39,130
to send i'm gonna install a rule i don't

00:21:37,630 --> 00:21:41,770
know where yet because that that's

00:21:39,130 --> 00:21:44,049
always the challenge and fire a bunch of

00:21:41,770 --> 00:21:45,940
packets and see how many of them

00:21:44,049 --> 00:21:48,160
actually make it out of there in a

00:21:45,940 --> 00:21:49,600
specific period of time what is the

00:21:48,160 --> 00:21:52,750
packets per second what's the bytes per

00:21:49,600 --> 00:21:56,250
second the other one was which is a

00:21:52,750 --> 00:21:56,250
little tricky was if we could

00:21:56,690 --> 00:22:02,220
measure the latency right so I've added

00:21:59,130 --> 00:22:03,780
rules what is the Latin see on the

00:22:02,220 --> 00:22:06,240
packet so i'm going to send a packet

00:22:03,780 --> 00:22:08,070
find a way to measure that at the time

00:22:06,240 --> 00:22:12,750
it entered the rule from that to the

00:22:08,070 --> 00:22:18,179
time it departed what latin see was five

00:22:12,750 --> 00:22:22,350
minutes well okay i don't know if we

00:22:18,179 --> 00:22:23,340
have time to finish this okay so we just

00:22:22,350 --> 00:22:28,380
focused on the data throughput

00:22:23,340 --> 00:22:32,780
performance next is how do we pick a

00:22:28,380 --> 00:22:35,760
system under test that was reasonable to

00:22:32,780 --> 00:22:38,669
to test one of the things we were

00:22:35,760 --> 00:22:40,500
shooting for is we want to reduce the

00:22:38,669 --> 00:22:42,210
effect of logs because our system under

00:22:40,500 --> 00:22:45,840
test is they classify okay we're not

00:22:42,210 --> 00:22:47,929
here to test what the cutest clock looks

00:22:45,840 --> 00:22:50,610
like it just gets in the way of saying

00:22:47,929 --> 00:22:53,640
if the queue disk is overhead how do we

00:22:50,610 --> 00:22:55,140
get to the to our system of tests we're

00:22:53,640 --> 00:22:57,600
not here to test drivers we don't want

00:22:55,140 --> 00:23:01,620
to test the i-40 e to see what overhead

00:22:57,600 --> 00:23:05,490
it has before it hits the classifier we

00:23:01,620 --> 00:23:07,080
so we tried our best to just focus on

00:23:05,490 --> 00:23:09,750
the system on the test which is the

00:23:07,080 --> 00:23:11,100
classifier right so this is how we pick

00:23:09,750 --> 00:23:12,419
up the battle scenes there's several

00:23:11,100 --> 00:23:16,890
places we could have another performance

00:23:12,419 --> 00:23:18,870
over here or over here and it was hard

00:23:16,890 --> 00:23:22,950
to start selecting we had to select one

00:23:18,870 --> 00:23:27,240
spot and justify why right so in order

00:23:22,950 --> 00:23:28,890
to reduce the overhead we this is this

00:23:27,240 --> 00:23:30,780
was initially our goal okay we were

00:23:28,890 --> 00:23:33,000
going to send packets from outside come

00:23:30,780 --> 00:23:35,309
to some driver and then measure

00:23:33,000 --> 00:23:37,020
performance at different spots and as

00:23:35,309 --> 00:23:40,169
well we're going to send packets from

00:23:37,020 --> 00:23:42,059
package Gina above but it needed us not

00:23:40,169 --> 00:23:43,740
to bypass the cutest because filters are

00:23:42,059 --> 00:23:46,400
attached to kiddies the current package

00:23:43,740 --> 00:23:52,650
and only always bypass the cue disk

00:23:46,400 --> 00:23:54,510
right so okay at that point we say okay

00:23:52,650 --> 00:23:56,490
let's get rid of the drive all over head

00:23:54,510 --> 00:23:58,860
okay we will put a dummy device here

00:23:56,490 --> 00:24:00,539
instead of a real driver which will just

00:23:58,860 --> 00:24:02,700
suck the packets a little just drop them

00:24:00,539 --> 00:24:05,539
and then on the ingress we're going to

00:24:02,700 --> 00:24:09,200
get rid of every driver and

00:24:05,539 --> 00:24:11,899
state just send packets up through the

00:24:09,200 --> 00:24:13,399
ingress hope for packaging so it

00:24:11,899 --> 00:24:14,720
pretends it's coming from a driver but

00:24:13,399 --> 00:24:20,869
it doesn't have the override of dealing

00:24:14,720 --> 00:24:22,729
with the driver and so this looked like

00:24:20,869 --> 00:24:25,700
the battle scene eventually right

00:24:22,729 --> 00:24:28,460
there's a bunch of places we could put

00:24:25,700 --> 00:24:32,989
drops and measure the performance of

00:24:28,460 --> 00:24:35,059
their classifiers as we went through

00:24:32,989 --> 00:24:36,830
this we realize two weeks later we

00:24:35,059 --> 00:24:40,669
realize we have thousands of tests we

00:24:36,830 --> 00:24:43,279
had to run so we needed to narrow it to

00:24:40,669 --> 00:24:46,070
just one spot and then either the

00:24:43,279 --> 00:24:50,229
ingress or the egress pick one right so

00:24:46,070 --> 00:24:53,269
some of our tests so we have the device

00:24:50,229 --> 00:24:57,379
yeah so we picked up this Intel narc

00:24:53,269 --> 00:25:00,679
which is a little device locus is just

00:24:57,379 --> 00:25:02,029
going to grab the device it's a nice em

00:25:00,679 --> 00:25:07,340
it's a nice device you can put in your

00:25:02,029 --> 00:25:12,019
backpack it's got a quad is an i7 quad

00:25:07,340 --> 00:25:15,109
core 3.1 gigahertz we bought the fastest

00:25:12,019 --> 00:25:18,679
rom we could find which was 16 gig of

00:25:15,109 --> 00:25:21,379
1600 megahertz may bring it up here and

00:25:18,679 --> 00:25:24,369
we picked a column and the colonel we

00:25:21,379 --> 00:25:30,739
picked at that point was net next 441

00:25:24,369 --> 00:25:34,429
rc1 and there's some issues with with

00:25:30,739 --> 00:25:37,429
flour and we had to patch package in to

00:25:34,429 --> 00:25:41,450
not bypass the queue desk the ink rescue

00:25:37,429 --> 00:25:45,409
disk so that's our test setup we picked

00:25:41,450 --> 00:25:46,820
the colonel that's the device if anybody

00:25:45,409 --> 00:25:53,599
wants to pay attention afterwards you

00:25:46,820 --> 00:25:57,349
can come up on CS all right so as I was

00:25:53,599 --> 00:25:59,509
pointing out this was a battle scene

00:25:57,349 --> 00:26:01,549
right so one of the first drops is here

00:25:59,509 --> 00:26:04,220
we say okay let's send a packet all the

00:26:01,549 --> 00:26:06,940
way here and and drop the package here

00:26:04,220 --> 00:26:09,919
then we are going to add the acute disk

00:26:06,940 --> 00:26:11,749
not classic no rules we want to see the

00:26:09,919 --> 00:26:18,470
overhead of the queue desk itself and

00:26:11,749 --> 00:26:19,670
then eventually so as you can see

00:26:18,470 --> 00:26:23,630
dropping at ipic

00:26:19,670 --> 00:26:25,220
Eve was now this is where I put these

00:26:23,630 --> 00:26:26,810
numbers on purpose they show megabits

00:26:25,220 --> 00:26:30,680
per second as opposed to packets per

00:26:26,810 --> 00:26:31,940
second what we observed is it doesn't

00:26:30,680 --> 00:26:33,890
matter what the packet sizes the

00:26:31,940 --> 00:26:35,210
performance was the PPS was consistent

00:26:33,890 --> 00:26:36,890
regardless of the packet size which

00:26:35,210 --> 00:26:39,290
means the overhead of dealing with every

00:26:36,890 --> 00:26:41,570
packet was the same regardless of the

00:26:39,290 --> 00:26:43,040
tests we did so now I'm playing some

00:26:41,570 --> 00:26:44,570
marketing here for you I'm

00:26:43,040 --> 00:26:48,020
going to just show the megabits per

00:26:44,570 --> 00:26:50,540
second you can see that dropping at IP

00:26:48,020 --> 00:26:53,210
receive Linux can do up to 250 gigabits

00:26:50,540 --> 00:26:58,040
per second right at 250 gigabits per

00:26:53,210 --> 00:27:00,730
second but of course that is not very

00:26:58,040 --> 00:27:05,900
meaningful it's about 1,000 byte packets

00:27:00,730 --> 00:27:07,070
at 1,000 byte packet here you can see

00:27:05,900 --> 00:27:08,540
that we hit about two hundred fifty

00:27:07,070 --> 00:27:11,630
gigabytes and it's almost it's not

00:27:08,540 --> 00:27:14,570
exactly linear but it varies on the

00:27:11,630 --> 00:27:17,210
packet size I guess I'm not going to be

00:27:14,570 --> 00:27:24,100
able to finish the presentation here yep

00:27:17,210 --> 00:27:24,100
we should I saw is it 30 minutes already

00:27:28,630 --> 00:27:37,340
okay conclusions I'm just going to jump

00:27:35,780 --> 00:27:41,120
I think all the slides are important

00:27:37,340 --> 00:27:43,610
here's IP receive with one roll one

00:27:41,120 --> 00:27:46,730
tuple you can see the different

00:27:43,610 --> 00:27:50,960
classifiers that we selected in their

00:27:46,730 --> 00:27:53,090
performance eventually we looked at the

00:27:50,960 --> 00:27:55,760
packet size and as I say they different

00:27:53,090 --> 00:27:57,860
the packet sizes we there's no variance

00:27:55,760 --> 00:28:05,120
the minimum and the maximum of about ten

00:27:57,860 --> 00:28:08,990
rounds was very minimal so we cut out

00:28:05,120 --> 00:28:10,490
the fact that we needed to do the we

00:28:08,990 --> 00:28:12,020
just pick the average every single time

00:28:10,490 --> 00:28:14,690
we didn't have to bother capturing the

00:28:12,020 --> 00:28:16,400
minimum the maximum packet sizes as I

00:28:14,690 --> 00:28:19,100
said didn't matter as you can see that

00:28:16,400 --> 00:28:21,560
as we've all read the packet size the

00:28:19,100 --> 00:28:23,570
packets per second with just dropping a

00:28:21,560 --> 00:28:26,420
type II receive was in the 30 million

00:28:23,570 --> 00:28:28,790
range again please observe this is one

00:28:26,420 --> 00:28:33,590
CP okay we're not trying to multi to run

00:28:28,790 --> 00:28:36,110
this on multiple CPUs and as we and all

00:28:33,590 --> 00:28:37,760
of them basically had it doesn't matter

00:28:36,110 --> 00:28:42,440
the Pacus eyes so we end up picking for

00:28:37,760 --> 00:28:44,510
tests just the final packet size we then

00:28:42,440 --> 00:28:48,710
ignored vpf because b pfg two is always

00:28:44,510 --> 00:28:50,740
better and the one versus file 52 pause

00:28:48,710 --> 00:28:53,180
we figured 52 poses a better test

00:28:50,740 --> 00:28:54,860
instead of one and you can see the

00:28:53,180 --> 00:28:57,070
difference is not very huge for all the

00:28:54,860 --> 00:28:59,660
classifiers at ten twenty byte packets

00:28:57,070 --> 00:29:03,350
we use five to go because it's more

00:28:59,660 --> 00:29:06,350
realistic this is this is something I'm

00:29:03,350 --> 00:29:08,270
going to go to your Spurs ball should

00:29:06,350 --> 00:29:10,040
all come its network performance we

00:29:08,270 --> 00:29:11,780
observe some very strange numbers with

00:29:10,040 --> 00:29:14,360
just black hole routing as you can see

00:29:11,780 --> 00:29:17,090
if I drop that IEP receive and alex is

00:29:14,360 --> 00:29:19,610
probably going to argue about this that

00:29:17,090 --> 00:29:24,980
we saw performance drop by about ten

00:29:19,610 --> 00:29:26,900
times we have the device with us we have

00:29:24,980 --> 00:29:29,990
the performance numbers we can sure we

00:29:26,900 --> 00:29:31,430
can repeat this test again at this point

00:29:29,990 --> 00:29:33,830
we decided not to do anything towards

00:29:31,430 --> 00:29:35,840
the forwarding we baseline the egress

00:29:33,830 --> 00:29:37,550
which is you know staking packets from

00:29:35,840 --> 00:29:39,500
packaging on the egress and sending them

00:29:37,550 --> 00:29:45,110
down and we're in

00:29:39,500 --> 00:29:47,540
we decided to drop this test as well so

00:29:45,110 --> 00:29:48,710
taking stock of what all the baseline so

00:29:47,540 --> 00:29:50,210
up to this point we're just doing

00:29:48,710 --> 00:29:54,230
baselining okay we're not really running

00:29:50,210 --> 00:29:55,730
the test what we realized was the

00:29:54,230 --> 00:29:58,280
ingress can handle a lot of throughput

00:29:55,730 --> 00:29:59,810
there's things that slower we could

00:29:58,280 --> 00:30:01,490
probably prove their performance it's

00:29:59,810 --> 00:30:04,150
not the cutest that was the overhead is

00:30:01,490 --> 00:30:08,750
the routing code at this point is the

00:30:04,150 --> 00:30:11,950
lesson to take I believe we if we had

00:30:08,750 --> 00:30:14,150
put slower round like 1333 megahertz

00:30:11,950 --> 00:30:16,970
profiles were showing that the problem

00:30:14,150 --> 00:30:19,430
was not so much the CPU cycles it was

00:30:16,970 --> 00:30:21,920
the mem comes and the mem sets that's

00:30:19,430 --> 00:30:23,510
what was showing on display so I wanted

00:30:21,920 --> 00:30:25,100
to go and buy some ram which is slower

00:30:23,510 --> 00:30:27,260
but it's very hard to find slow around

00:30:25,100 --> 00:30:29,570
these days so we have 16 make a hundred

00:30:27,260 --> 00:30:34,100
megahertz where we could find out 1333

00:30:29,570 --> 00:30:35,600
megahertz Ram dim so eventually we

00:30:34,100 --> 00:30:36,950
settle on just doing things on the

00:30:35,600 --> 00:30:41,750
egress and dropping the packet in

00:30:36,950 --> 00:30:45,200
accounting for it that's it so this is

00:30:41,750 --> 00:30:47,630
where we ended up running the tests you

00:30:45,200 --> 00:30:49,700
can see the different again I said I was

00:30:47,630 --> 00:30:51,590
being unfair to BP to flower because

00:30:49,700 --> 00:30:57,260
flower every time had to recompute the

00:30:51,590 --> 00:31:00,710
flow cash BPF jit versus you 32 years I

00:30:57,260 --> 00:31:04,250
chose little better as you can see from

00:31:00,710 --> 00:31:06,140
the PPS numbers then we said okay now

00:31:04,250 --> 00:31:10,010
let's start wearing the number flows and

00:31:06,140 --> 00:31:12,860
number rules you can see that as with

00:31:10,010 --> 00:31:15,080
one flow versus to a sustained was this

00:31:12,860 --> 00:31:16,910
one hundred and thousand everything

00:31:15,080 --> 00:31:19,160
collapses it collapses because this is a

00:31:16,910 --> 00:31:21,320
single link list and if you want to see

00:31:19,160 --> 00:31:24,740
the details you can see that you 32

00:31:21,320 --> 00:31:26,810
outperform them but you know it's kind

00:31:24,740 --> 00:31:29,510
of embarrassing when you can win with a

00:31:26,810 --> 00:31:32,270
single rule you can do in the 200 gig

00:31:29,510 --> 00:31:36,110
range and with a thousand rules you're

00:31:32,270 --> 00:31:38,390
down to 463 megabits per second and last

00:31:36,110 --> 00:31:41,690
we decided okay we're going to script

00:31:38,390 --> 00:31:46,220
you 32 as I was describing earlier to

00:31:41,690 --> 00:31:49,940
march 64,000 flows and these are the

00:31:46,220 --> 00:31:52,110
numbers so here's one floor only with

00:31:49,940 --> 00:31:54,059
one rule with you 32 here

00:31:52,110 --> 00:31:58,170
thousand rules here's the scripted

00:31:54,059 --> 00:32:00,059
version of you 32 with 64,000 flaws and

00:31:58,170 --> 00:32:03,540
rules basically packaging is generating

00:32:00,059 --> 00:32:05,790
64,000 flows as opposed to the one flaw

00:32:03,540 --> 00:32:08,309
it does here or a thousand that it does

00:32:05,790 --> 00:32:11,520
here and we have 64,000 rules that are

00:32:08,309 --> 00:32:14,040
split into a multi try hash with three

00:32:11,520 --> 00:32:16,830
levels so follow cups I can find any

00:32:14,040 --> 00:32:18,570
flow out of the 64,000 or flows in for

00:32:16,830 --> 00:32:22,230
lookups we do not spend a lot of time

00:32:18,570 --> 00:32:24,230
doing this there's a few cultures I'll

00:32:22,230 --> 00:32:29,820
break I probably talk about them in the

00:32:24,230 --> 00:32:31,320
performance buff I don't know how much

00:32:29,820 --> 00:32:34,740
time I have but you know there's the

00:32:31,320 --> 00:32:37,770
Iron Triangle you pick between classify

00:32:34,740 --> 00:32:39,929
here the peak performance usability or

00:32:37,770 --> 00:32:41,970
extensibility so I'm going to hand away

00:32:39,929 --> 00:32:46,620
from this see that as far as performance

00:32:41,970 --> 00:32:49,799
is cosine u 32 is still very good as far

00:32:46,620 --> 00:32:53,600
as extensibility BPF is the winner as

00:32:49,799 --> 00:33:00,270
far as usability a flower is the winner

00:32:53,600 --> 00:33:01,650
right and sorry i skim through this some

00:33:00,270 --> 00:33:03,000
of this stuff but the paper will and the

00:33:01,650 --> 00:33:05,480
slides will be online and the paper will

00:33:03,000 --> 00:33:08,600
have a lot more details thanks your mom

00:33:05,480 --> 00:33:08,600

YouTube URL: https://www.youtube.com/watch?v=I5BOJO5ibRY


