Title: Netdev 1.1 - Securing traffic tunnelled over L3
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 1 - Wednesday February 10, 2016
Description: 
	Sowmini Varadhan
February 2016
Captions: 
	00:00:00,410 --> 00:00:07,290
so um we're short on time so I can go

00:00:04,170 --> 00:00:09,690
ahead and get started so I'll be talking

00:00:07,290 --> 00:00:11,340
about the problem of securing network

00:00:09,690 --> 00:00:15,059
traffic that's tunneled over kernel

00:00:11,340 --> 00:00:16,859
managed TCP and UDP sockets essentially

00:00:15,059 --> 00:00:21,600
what we're looking at is with all the

00:00:16,859 --> 00:00:23,010
recent advances in data center and cloud

00:00:21,600 --> 00:00:25,470
technologies we have a lot of these

00:00:23,010 --> 00:00:27,750
kernel managed TCP and UDP sockets and

00:00:25,470 --> 00:00:30,029
we're looking more and more at the

00:00:27,750 --> 00:00:31,890
problem of finding a uniform way to give

00:00:30,029 --> 00:00:33,870
privacy integrity protection and

00:00:31,890 --> 00:00:36,450
authentication of the traffic going

00:00:33,870 --> 00:00:37,739
through these sites so on a mailing list

00:00:36,450 --> 00:00:40,680
we've talked about two ways of doing

00:00:37,739 --> 00:00:41,969
this one is to use TLS and DTLS so first

00:00:40,680 --> 00:00:44,219
I'll go over the pros and cons of that

00:00:41,969 --> 00:00:46,829
approach we've also talked about using

00:00:44,219 --> 00:00:48,270
IPSec and its impact on performance so

00:00:46,829 --> 00:00:51,500
I'll talk about the pros and cons of

00:00:48,270 --> 00:00:54,090
that I've done some instrumentation of

00:00:51,500 --> 00:00:55,620
IPSec impact on performance using micro

00:00:54,090 --> 00:00:57,300
benchmarks so I talked about what I

00:00:55,620 --> 00:01:01,829
found so far things that need to be

00:00:57,300 --> 00:01:03,359
fixed and how to take this forward so

00:01:01,829 --> 00:01:05,790
stepping back and looking at the problem

00:01:03,359 --> 00:01:07,890
you're trying to solve we have a lot of

00:01:05,790 --> 00:01:09,960
kernel UDP sockets coming to us from

00:01:07,890 --> 00:01:13,229
things like the expand GUI genève and

00:01:09,960 --> 00:01:15,030
other and vo3 solutions we also have

00:01:13,229 --> 00:01:18,110
some recent interest in kernel TCP

00:01:15,030 --> 00:01:20,759
sockets from things like KCM and RDS TCP

00:01:18,110 --> 00:01:22,350
so in all these cases what we're trying

00:01:20,759 --> 00:01:24,420
to do is provide triple-a that is

00:01:22,350 --> 00:01:26,549
authentication in authorization auditing

00:01:24,420 --> 00:01:28,820
and privacy and we're trying to do this

00:01:26,549 --> 00:01:31,409
without burning up too much performance

00:01:28,820 --> 00:01:33,000
there is some unavoidable cost with

00:01:31,409 --> 00:01:34,740
crypto but we want to keep that down to

00:01:33,000 --> 00:01:36,329
a minimum and we don't want to be

00:01:34,740 --> 00:01:39,570
leaking performance everywhere else so

00:01:36,329 --> 00:01:41,220
that's one requirement the other is we

00:01:39,570 --> 00:01:43,020
are talking about data center and

00:01:41,220 --> 00:01:44,850
cluster and things like that which have

00:01:43,020 --> 00:01:47,820
very strict requirements around failover

00:01:44,850 --> 00:01:49,680
and h.a so whatever security solution

00:01:47,820 --> 00:01:52,110
you provide must be a complete security

00:01:49,680 --> 00:01:52,409
solution without regressing on these

00:01:52,110 --> 00:01:56,130
other

00:01:52,409 --> 00:01:57,390
failover and ata features so to

00:01:56,130 --> 00:01:59,369
understand how to solve the problem

00:01:57,390 --> 00:02:02,759
let's first look at what happens here

00:01:59,369 --> 00:02:04,680
from a very high level the for these

00:02:02,759 --> 00:02:07,110
kernel sockets the application data can

00:02:04,680 --> 00:02:09,239
come from a number of places it could be

00:02:07,110 --> 00:02:10,910
coming from a virtual machine for VX van

00:02:09,239 --> 00:02:12,680
from a database

00:02:10,910 --> 00:02:16,460
occasion for things like RDS or from

00:02:12,680 --> 00:02:18,830
HTTP to 4k cm in most cases what happens

00:02:16,460 --> 00:02:21,050
is that that application data gets

00:02:18,830 --> 00:02:23,600
encapsulated in an other control plane

00:02:21,050 --> 00:02:27,280
header so the x-man adds a DX LAN header

00:02:23,600 --> 00:02:30,290
over the tenant ID genève adds OBS state

00:02:27,280 --> 00:02:32,450
RDS adds port numbers and other stuff so

00:02:30,290 --> 00:02:34,280
after that when you tunnel the data and

00:02:32,450 --> 00:02:35,840
the other side that control plane header

00:02:34,280 --> 00:02:38,720
is used to figure out how to debug the

00:02:35,840 --> 00:02:42,500
packet and and deliver it to the right

00:02:38,720 --> 00:02:45,470
service so the privacy and security

00:02:42,500 --> 00:02:47,240
concern here is that the traffic that is

00:02:45,470 --> 00:02:49,370
going out over these kernel sockets

00:02:47,240 --> 00:02:52,550
which can traverse long internet paths

00:02:49,370 --> 00:02:54,410
is going out and clear today it's been

00:02:52,550 --> 00:02:56,330
okay so far because we haven't really

00:02:54,410 --> 00:02:57,920
achieved the scale that you can achieve

00:02:56,330 --> 00:03:00,080
with these things but that's rapidly

00:02:57,920 --> 00:03:02,180
changing right and as we go to multi

00:03:00,080 --> 00:03:04,520
tenant and cloud environments there are

00:03:02,180 --> 00:03:06,470
three things that you need to secure one

00:03:04,520 --> 00:03:08,150
is that because you can traverse long

00:03:06,470 --> 00:03:10,520
internet paths the intermediate nodes

00:03:08,150 --> 00:03:13,190
cannot be trusted so you have to protect

00:03:10,520 --> 00:03:15,020
the tenant payload you have to protect

00:03:13,190 --> 00:03:16,940
your protocol header itself yours you

00:03:15,020 --> 00:03:19,340
need header or your VX LAN header or

00:03:16,940 --> 00:03:21,410
your ideas header or whatever header and

00:03:19,340 --> 00:03:22,730
then you have to protect the control

00:03:21,410 --> 00:03:26,150
frame especially if you are using

00:03:22,730 --> 00:03:28,220
something like RDS TCP or KCM we know

00:03:26,150 --> 00:03:30,080
that TCP is vulnerable to reset attacks

00:03:28,220 --> 00:03:33,860
sequence number attacks and so on so you

00:03:30,080 --> 00:03:36,740
have to protect that plain as well so

00:03:33,860 --> 00:03:40,760
let's start with let's start with the

00:03:36,740 --> 00:03:42,650
privacy for tenant traffic issue so what

00:03:40,760 --> 00:03:44,870
we don't want is attackers in the middle

00:03:42,650 --> 00:03:46,910
which are untrusted nodes to be able to

00:03:44,870 --> 00:03:49,070
snoop or impersonate the endpoints and

00:03:46,910 --> 00:03:51,830
that's not a new problem we've solved

00:03:49,070 --> 00:03:53,989
this before for SSH we use TLS eg TLS of

00:03:51,830 --> 00:03:56,060
the socket layer this is great because

00:03:53,989 --> 00:03:58,160
it gives you per user authentication

00:03:56,060 --> 00:04:00,739
it's implemented at the application

00:03:58,160 --> 00:04:03,140
level not the kernel so it's easier to

00:04:00,739 --> 00:04:05,060
support in multiple environments but

00:04:03,140 --> 00:04:09,170
it's hard to map that to a kernel socket

00:04:05,060 --> 00:04:12,140
model for one thing when you talk about

00:04:09,170 --> 00:04:14,239
things like RDS and KCM these are using

00:04:12,140 --> 00:04:17,959
new protocol families using PF RDS and

00:04:14,239 --> 00:04:20,030
PF KCM which today's good new TLS and

00:04:17,959 --> 00:04:21,260
open SSL libraries do not recognize so

00:04:20,030 --> 00:04:23,750
you would have to make a lot of changes

00:04:21,260 --> 00:04:24,380
there the other approach that has been

00:04:23,750 --> 00:04:27,640
discussed

00:04:24,380 --> 00:04:30,170
is to use TLS on the kernel socket layer

00:04:27,640 --> 00:04:32,450
the problem is there is no TLS in the

00:04:30,170 --> 00:04:33,470
kernel and no one wants to move to your

00:04:32,450 --> 00:04:35,120
last at the kernel because it's a

00:04:33,470 --> 00:04:37,460
complex protocol it has a complex

00:04:35,120 --> 00:04:39,610
handshake and control plane so that's

00:04:37,460 --> 00:04:42,470
not any something anyone is eager to do

00:04:39,610 --> 00:04:44,360
what we have discussed is to split TLS

00:04:42,470 --> 00:04:46,670
to a control plane which is which

00:04:44,360 --> 00:04:48,950
negotiates parameters in user space and

00:04:46,670 --> 00:04:51,680
the data plane where it gets encrypted

00:04:48,950 --> 00:04:53,450
using those parameters right so this has

00:04:51,680 --> 00:04:56,090
been the basis of a couple of proposals

00:04:53,450 --> 00:04:57,800
one was made by Netflix for an encrypted

00:04:56,090 --> 00:04:59,330
send file they found a lot of

00:04:57,800 --> 00:05:00,830
interesting things so I'm going to spend

00:04:59,330 --> 00:05:03,440
a few slides talking about what they

00:05:00,830 --> 00:05:06,650
found it's also the basis for the recent

00:05:03,440 --> 00:05:08,390
Katie Ellis RFC so it would be good to

00:05:06,650 --> 00:05:11,570
understand the lessons learned from the

00:05:08,390 --> 00:05:13,130
Netflix experience so a Netflix paper

00:05:11,570 --> 00:05:15,080
there's a point over here to it

00:05:13,130 --> 00:05:17,300
basically looks at an open connected

00:05:15,080 --> 00:05:19,310
lines what they were trying to do is

00:05:17,300 --> 00:05:21,620
they had a web server that gets a client

00:05:19,310 --> 00:05:23,510
request for an object on disk it

00:05:21,620 --> 00:05:26,270
retrieves the object into a local buffer

00:05:23,510 --> 00:05:28,250
and puts it and sends it up so the

00:05:26,270 --> 00:05:30,110
encryption they obviously to do it is to

00:05:28,250 --> 00:05:31,910
do it in the user space what they were

00:05:30,110 --> 00:05:33,980
trying to do is avoid the bounce from

00:05:31,910 --> 00:05:36,290
kernel to user space and by trying to do

00:05:33,980 --> 00:05:38,810
a send file on the file descriptor and

00:05:36,290 --> 00:05:41,480
send the stuff out on the socket

00:05:38,810 --> 00:05:44,480
descriptor without ever going into user

00:05:41,480 --> 00:05:45,650
space but to do that the kernel would

00:05:44,480 --> 00:05:47,840
need to know how to encrypt the data

00:05:45,650 --> 00:05:48,860
right and what they proposed is the

00:05:47,840 --> 00:05:51,380
split tiaras

00:05:48,860 --> 00:05:53,570
they split TLS to the session management

00:05:51,380 --> 00:05:56,210
and user space and do the encryption in

00:05:53,570 --> 00:05:58,130
the kernel now one important thing to

00:05:56,210 --> 00:06:01,190
keep in mind as you read that paper is

00:05:58,130 --> 00:06:03,050
that their primary scope was just to see

00:06:01,190 --> 00:06:04,520
if they could accelerate encryption they

00:06:03,050 --> 00:06:06,320
were not trying to provide a complete

00:06:04,520 --> 00:06:08,810
security solution they were not trying

00:06:06,320 --> 00:06:11,360
to provide a kernel TLS so that allowed

00:06:08,810 --> 00:06:13,820
them to optimize some of the things

00:06:11,360 --> 00:06:15,650
which they did right so very quickly

00:06:13,820 --> 00:06:17,720
they found out that when you split TLS

00:06:15,650 --> 00:06:20,270
like that you're doing something to TLS

00:06:17,720 --> 00:06:21,650
that was not intended by TLS so TLS

00:06:20,270 --> 00:06:23,990
thinks that everything is going on the

00:06:21,650 --> 00:06:26,420
same string so once one side figures out

00:06:23,990 --> 00:06:29,210
the encryption parameters it sends the

00:06:26,420 --> 00:06:31,010
ccs the change cipher suite after that

00:06:29,210 --> 00:06:33,380
everything that goes behind that can be

00:06:31,010 --> 00:06:34,940
encrypted with that ccs information

00:06:33,380 --> 00:06:36,560
right the assumption being that the

00:06:34,940 --> 00:06:37,139
other side will first process the ccs

00:06:36,560 --> 00:06:38,610
and then

00:06:37,139 --> 00:06:40,800
all the encrypted data so everything

00:06:38,610 --> 00:06:43,319
will be fine right but this has been

00:06:40,800 --> 00:06:45,060
broken by the split TLS model and they

00:06:43,319 --> 00:06:46,590
point out a few other cases freaking a

00:06:45,060 --> 00:06:48,360
whole number of other cases where this

00:06:46,590 --> 00:06:50,430
makes the thing quite complex to do the

00:06:48,360 --> 00:06:52,740
full bounty elapsed in the kernel right

00:06:50,430 --> 00:06:54,659
and one note in their paper is that when

00:06:52,740 --> 00:06:56,370
you consider that messages in the TCP

00:06:54,659 --> 00:06:58,139
stream may arrive out of order

00:06:56,370 --> 00:06:59,849
adding TLS for both sending and

00:06:58,139 --> 00:07:02,460
receiving adds a lot of complexity to

00:06:59,849 --> 00:07:04,710
the kernel right so making note of that

00:07:02,460 --> 00:07:06,749
they paper over all this complexity by

00:07:04,710 --> 00:07:08,999
saying they only do the sender side of

00:07:06,749 --> 00:07:10,800
TLS and and that's they're allowed to do

00:07:08,999 --> 00:07:14,699
that because they only care to see if

00:07:10,800 --> 00:07:16,409
they've activated send file and in the

00:07:14,699 --> 00:07:18,900
end they find that they didn't actually

00:07:16,409 --> 00:07:21,689
get a big performance improvement they

00:07:18,900 --> 00:07:24,479
nail that down for BSD to some an extra

00:07:21,689 --> 00:07:27,029
be copy it's possible that in Linux you

00:07:24,479 --> 00:07:29,310
won't have that big copy overhead but

00:07:27,029 --> 00:07:30,930
the problem arrays you have a kernel

00:07:29,310 --> 00:07:33,689
socket you need a complete security

00:07:30,930 --> 00:07:35,460
solution you cannot just paper over all

00:07:33,689 --> 00:07:37,409
those asynchronicity issues you need to

00:07:35,460 --> 00:07:39,539
be able to handle wreaking you need to

00:07:37,409 --> 00:07:41,819
be able to handle all the the both

00:07:39,539 --> 00:07:43,289
receiver side and the sender side so all

00:07:41,819 --> 00:07:47,129
the day synchronicity you cannot just

00:07:43,289 --> 00:07:48,599
hand able bit right and in addition to

00:07:47,129 --> 00:07:49,979
all the things they point out so the

00:07:48,599 --> 00:07:52,139
things they point out are primarily

00:07:49,979 --> 00:07:54,930
where the control plane changes state

00:07:52,139 --> 00:07:56,370
and the data plane needs to catch up but

00:07:54,930 --> 00:07:58,860
when you talk about data center and

00:07:56,370 --> 00:08:01,229
cluster you have the opposite problem as

00:07:58,860 --> 00:08:02,699
well your data plane can restart and

00:08:01,229 --> 00:08:04,500
your control plane needs to be poked it

00:08:02,699 --> 00:08:06,270
needs to be in tandem with that alright

00:08:04,500 --> 00:08:07,860
so examples where this can happen so

00:08:06,270 --> 00:08:09,930
we're talking data center we're talking

00:08:07,860 --> 00:08:11,580
cloud we're talking cluster so you have

00:08:09,930 --> 00:08:14,339
address and service migration you have

00:08:11,580 --> 00:08:17,039
load balancing for RDS CCP you could be

00:08:14,339 --> 00:08:18,389
patching the key of the kernel module

00:08:17,039 --> 00:08:20,909
and you want to restart the kernel

00:08:18,389 --> 00:08:24,300
socket in most cases you probably also

00:08:20,909 --> 00:08:26,069
want to restart the control plane there

00:08:24,300 --> 00:08:28,229
is one case where you can actually very

00:08:26,069 --> 00:08:30,120
likely want to do this which is that in

00:08:28,229 --> 00:08:31,589
all of these cases what happens is that

00:08:30,120 --> 00:08:33,029
there's this control plane header which

00:08:31,589 --> 00:08:34,589
tells you how to dmax the packet you

00:08:33,029 --> 00:08:36,269
have this vehicle on header already as

00:08:34,589 --> 00:08:37,409
header or whatever which looks at the

00:08:36,269 --> 00:08:41,219
packet and says this is who I should

00:08:37,409 --> 00:08:42,570
give it to if that is found to be bad it

00:08:41,219 --> 00:08:44,820
means something has been compromised

00:08:42,570 --> 00:08:46,410
very likely you want to start reeking

00:08:44,820 --> 00:08:47,790
you cannot just say I'll move on to the

00:08:46,410 --> 00:08:49,290
next packet sometimes you cannot even

00:08:47,790 --> 00:08:50,300
move on to the next packet for our IDs

00:08:49,290 --> 00:08:52,820
in KCM

00:08:50,300 --> 00:08:55,070
your length might be clobbered so in

00:08:52,820 --> 00:08:56,150
those cases the data plane restarts you

00:08:55,070 --> 00:08:57,860
need to kick the control plane and

00:08:56,150 --> 00:09:01,790
restart as well so we have the opposite

00:08:57,860 --> 00:09:03,350
a synchronicity as well plus there was

00:09:01,790 --> 00:09:05,450
the other requirement which I mentioned

00:09:03,350 --> 00:09:08,720
early on which is that you need to

00:09:05,450 --> 00:09:11,270
secure the control plane for TCP TCP

00:09:08,720 --> 00:09:13,610
Reno from routing and from BGP that it

00:09:11,270 --> 00:09:15,980
is vulnerable to reset attacks sequence

00:09:13,610 --> 00:09:18,860
number attacks and when you are coming

00:09:15,980 --> 00:09:20,630
things in TCP as you are with already as

00:09:18,860 --> 00:09:22,550
in KCM you need to protect that as well

00:09:20,630 --> 00:09:25,040
and there is another additional twist

00:09:22,550 --> 00:09:26,750
here which is that for RDS and for KCM

00:09:25,040 --> 00:09:31,430
we are doing this Datagram over stream

00:09:26,750 --> 00:09:32,660
and we are promising ordered guaranteed

00:09:31,430 --> 00:09:35,780
delivery and all that good stuff right

00:09:32,660 --> 00:09:37,760
so what how that is actually done is the

00:09:35,780 --> 00:09:39,500
application sends down a Datagram the

00:09:37,760 --> 00:09:41,570
kernel breaks that up into TCP segments

00:09:39,500 --> 00:09:43,670
and it keeps sending those segments

00:09:41,570 --> 00:09:44,990
until the ACK numbers coming back tells

00:09:43,670 --> 00:09:47,570
me that the whole Datagram has been

00:09:44,990 --> 00:09:49,400
received so if someone can inject bad

00:09:47,570 --> 00:09:52,010
act numbers or fake act numbers into the

00:09:49,400 --> 00:09:54,050
stream this algorithm is blown right it

00:09:52,010 --> 00:09:55,640
cannot work so you do really need to

00:09:54,050 --> 00:09:57,800
protect the TCP control plane as well

00:09:55,640 --> 00:09:59,210
and then there was the H a case I

00:09:57,800 --> 00:10:01,070
mentioned earlier which is that the

00:09:59,210 --> 00:10:02,780
receiver is looking at the RDS header if

00:10:01,070 --> 00:10:06,560
that's bad you need to rekey so you

00:10:02,780 --> 00:10:08,690
cannot avoid that so it's possible that

00:10:06,560 --> 00:10:10,820
you can take TLS you can split it up and

00:10:08,690 --> 00:10:12,290
make all of this work it's possible that

00:10:10,820 --> 00:10:14,960
you can do that solve all the

00:10:12,290 --> 00:10:16,480
asynchronicity with enough code with

00:10:14,960 --> 00:10:18,170
enough people you can do anything but

00:10:16,480 --> 00:10:20,930
there's no need to do that

00:10:18,170 --> 00:10:22,610
IPSec already does this IPSec already

00:10:20,930 --> 00:10:24,110
comes with a split controller and data

00:10:22,610 --> 00:10:25,550
plane the data plane is already in the

00:10:24,110 --> 00:10:29,090
kernel the bugs have been shaken out

00:10:25,550 --> 00:10:30,560
over the years it's already there so in

00:10:29,090 --> 00:10:33,080
the next few slides I'm going to go over

00:10:30,560 --> 00:10:34,670
the basic definitions of IPSec might be

00:10:33,080 --> 00:10:37,160
obvious most people in this room but

00:10:34,670 --> 00:10:39,020
just for the normative reference I'll go

00:10:37,160 --> 00:10:42,380
over that and then we'll talk about the

00:10:39,020 --> 00:10:45,470
IPSec performance footprint so what is

00:10:42,380 --> 00:10:47,300
IPSec IPSec stands for IP security it is

00:10:45,470 --> 00:10:48,950
a suite of protocols that allows you to

00:10:47,300 --> 00:10:51,980
encrypt your data you do this by adding

00:10:48,950 --> 00:10:54,140
the ESP header or you can just do a

00:10:51,980 --> 00:10:56,120
syndication with the auth header to

00:10:54,140 --> 00:10:57,950
define IPSec on your traffic you have to

00:10:56,120 --> 00:11:00,870
define the security Association which is

00:10:57,950 --> 00:11:03,600
basically at least a pair of IP address

00:11:00,870 --> 00:11:04,950
in points in our case because we're

00:11:03,600 --> 00:11:07,170
talking about Colonel TCP and UDP

00:11:04,950 --> 00:11:08,730
sockets you can usually specify more

00:11:07,170 --> 00:11:09,390
because you probably know more about the

00:11:08,730 --> 00:11:11,580
four tuple

00:11:09,390 --> 00:11:14,760
so you can specify your si which is the

00:11:11,580 --> 00:11:16,800
IPSec flow more precisely the control

00:11:14,760 --> 00:11:19,500
plane for IPSec is Ike internet key

00:11:16,800 --> 00:11:21,839
exchange packages like strongswan and

00:11:19,500 --> 00:11:23,550
open Swan allow you to specify your keys

00:11:21,839 --> 00:11:24,960
in a number of base pre-shared keys

00:11:23,550 --> 00:11:28,980
certificate authority there's a lot of

00:11:24,960 --> 00:11:32,640
features so in our case we do want to

00:11:28,980 --> 00:11:34,320
provide privacy so P I will be biased

00:11:32,640 --> 00:11:36,630
towards ESP for the talk but that's

00:11:34,320 --> 00:11:38,940
without any loss of generality the

00:11:36,630 --> 00:11:41,040
interesting thing about ESP is that it

00:11:38,940 --> 00:11:43,140
adds an ESP header and a trailer an

00:11:41,040 --> 00:11:45,720
interesting thing in the ESP header is

00:11:43,140 --> 00:11:49,170
the SPI the security parameter index

00:11:45,720 --> 00:11:52,290
this is a 32-bit number which uniquely

00:11:49,170 --> 00:11:53,460
identifies your IPSec flow and we'll be

00:11:52,290 --> 00:11:56,160
coming back to this later when I talk

00:11:53,460 --> 00:11:58,080
about receive side hashing the other

00:11:56,160 --> 00:11:59,730
things in the fact sheet for ESP there

00:11:58,080 --> 00:12:01,830
is a sequence number to protect against

00:11:59,730 --> 00:12:03,240
replay attacks the trailer keeps track

00:12:01,830 --> 00:12:04,710
of the original protocol that's just

00:12:03,240 --> 00:12:10,140
what you would see the wire when you

00:12:04,710 --> 00:12:12,720
parse the packet so IPSec can be used in

00:12:10,140 --> 00:12:14,279
transport mode or in tunnel mode which

00:12:12,720 --> 00:12:16,589
mode you use defines how much you

00:12:14,279 --> 00:12:17,940
encrypt so if you are using IPSec in

00:12:16,589 --> 00:12:20,670
transport mode you would apply the

00:12:17,940 --> 00:12:22,589
transform on the TCP or UDP header and

00:12:20,670 --> 00:12:23,700
the data you would not change the IP

00:12:22,589 --> 00:12:25,860
header so you would not change the

00:12:23,700 --> 00:12:28,050
routing in tunnel mode you take your

00:12:25,860 --> 00:12:30,270
whole IP packet you encapsulated inside

00:12:28,050 --> 00:12:33,360
another IP packet and the inner packet

00:12:30,270 --> 00:12:36,180
is transformed so this is used to the

00:12:33,360 --> 00:12:37,980
VPN case where the outer IP packet

00:12:36,180 --> 00:12:40,920
contains the VPN source and Harriman's

00:12:37,980 --> 00:12:42,750
so for data center and for cluster our

00:12:40,920 --> 00:12:44,850
routing information usually comes to us

00:12:42,750 --> 00:12:47,640
from a cloud controller or cluster

00:12:44,850 --> 00:12:49,320
topology so usually transport mode is

00:12:47,640 --> 00:12:52,800
sufficient but tunnel mode is there if

00:12:49,320 --> 00:12:54,750
you want it so IPSec is fully featured

00:12:52,800 --> 00:12:56,040
and it has all the things we want the

00:12:54,750 --> 00:12:57,600
data player in the kernel the control

00:12:56,040 --> 00:12:59,850
plane and user space lots of ways to

00:12:57,600 --> 00:13:01,350
specify keys and so on the only thing we

00:12:59,850 --> 00:13:04,170
haven't talked about is the performance

00:13:01,350 --> 00:13:06,360
profile so for the rest of the talk I

00:13:04,170 --> 00:13:09,360
will be going over the performance

00:13:06,360 --> 00:13:11,700
profile of IPSec as we have found from

00:13:09,360 --> 00:13:14,450
initio micro benchmarks this is still an

00:13:11,700 --> 00:13:16,340
ongoing process because of the lack of

00:13:14,450 --> 00:13:17,930
I mostly talk about why we are doing the

00:13:16,340 --> 00:13:21,040
things we're doing the actual boss will

00:13:17,930 --> 00:13:24,320
discuss tomorrow in the IPSec discussion

00:13:21,040 --> 00:13:26,420
so what I started off with was a micro

00:13:24,320 --> 00:13:28,730
benchmark using iperf single-stream I

00:13:26,420 --> 00:13:31,460
looked at throughput and the CPU

00:13:28,730 --> 00:13:34,550
utilization I used 2 X 5 force of the

00:13:31,460 --> 00:13:36,440
10g line in between so for the initial

00:13:34,550 --> 00:13:38,330
exploration I found that the features

00:13:36,440 --> 00:13:39,980
that most impact performance our

00:13:38,330 --> 00:13:41,870
segmentation offload and receive are

00:13:39,980 --> 00:13:44,390
flawed so I tried modifying those

00:13:41,870 --> 00:13:47,270
parameters for both Clare traffic and

00:13:44,390 --> 00:13:50,240
for encrypted traffic and IPSec itself I

00:13:47,270 --> 00:13:51,830
tried three different cases one is null

00:13:50,240 --> 00:13:53,870
encryption that means you don't do any

00:13:51,830 --> 00:13:55,490
crypto you just add the ESP header and

00:13:53,870 --> 00:13:57,260
trailer this just tells you the

00:13:55,490 --> 00:13:59,630
theoretical maximum performance you can

00:13:57,260 --> 00:14:02,480
get then I try two types of encryption

00:13:59,630 --> 00:14:04,580
one is GCM 256 which is what is

00:14:02,480 --> 00:14:07,280
recommended by NIST the 256 is the key

00:14:04,580 --> 00:14:08,900
size and I also tried cesium 128 which

00:14:07,280 --> 00:14:09,410
is the one that used to be recommended

00:14:08,900 --> 00:14:11,930
by NIST

00:14:09,410 --> 00:14:14,000
so the difference between GCM and CCM is

00:14:11,930 --> 00:14:15,680
that GCM is parallelizable in Hardware

00:14:14,000 --> 00:14:19,400
so it tends to be a little bit faster

00:14:15,680 --> 00:14:21,320
then so in the next slide I'll actually

00:14:19,400 --> 00:14:23,200
show the histogram with the results but

00:14:21,320 --> 00:14:26,150
what you will see there is seven cases

00:14:23,200 --> 00:14:29,060
for for Claire traffic and three Friday

00:14:26,150 --> 00:14:30,560
SEC for clear traffic I tried Harvard

00:14:29,060 --> 00:14:32,600
everything with a default so it's

00:14:30,560 --> 00:14:34,490
Hardware offloads then I tried it with

00:14:32,600 --> 00:14:36,230
software offloads then I tried just dro

00:14:34,490 --> 00:14:38,060
and just year so just to see what the

00:14:36,230 --> 00:14:40,640
effect of losing offload isn't in your

00:14:38,060 --> 00:14:42,920
traffic and then I tried the three IPSec

00:14:40,640 --> 00:14:44,720
is null encryption which should be just

00:14:42,920 --> 00:14:48,650
like the clear traffic with Hardware

00:14:44,720 --> 00:14:50,330
defaults and then the crypto cases so

00:14:48,650 --> 00:14:52,340
this is what you see that that % numbers

00:14:50,330 --> 00:14:55,520
you see on top are the peak CPU

00:14:52,340 --> 00:14:57,200
utilization so the leftmost line is with

00:14:55,520 --> 00:14:59,120
all Hardware off roads so this is a 10 G

00:14:57,200 --> 00:15:00,710
line so that's getting as close line

00:14:59,120 --> 00:15:03,050
speed as you can get it's a 9 point

00:15:00,710 --> 00:15:04,310
something all right so that's good then

00:15:03,050 --> 00:15:05,990
when you go when you take away the

00:15:04,310 --> 00:15:07,910
hardware offload your CPU utilization

00:15:05,990 --> 00:15:10,100
grows goes up you're still getting

00:15:07,910 --> 00:15:13,160
pretty good throughput but then when I

00:15:10,100 --> 00:15:15,080
remove the offloads it drops even for

00:15:13,160 --> 00:15:17,780
clear traffic for the green lines right

00:15:15,080 --> 00:15:20,030
and the CPU utilization grows up so that

00:15:17,780 --> 00:15:21,640
tells you that offload has a lot to do

00:15:20,030 --> 00:15:24,770
with performance even for clear traffic

00:15:21,640 --> 00:15:27,650
now when you apply IPSec what's

00:15:24,770 --> 00:15:28,579
happening is that the IPSec transform

00:15:27,650 --> 00:15:30,769
needs to be applied

00:15:28,579 --> 00:15:33,639
after segmentation because it works on

00:15:30,769 --> 00:15:36,980
the TCP header right so today's

00:15:33,639 --> 00:15:38,720
automatically disabled with offloads

00:15:36,980 --> 00:15:40,610
when you up when it sees IPSec on the

00:15:38,720 --> 00:15:42,860
socket so that is one reason why the

00:15:40,610 --> 00:15:45,769
first red line is so far from the first

00:15:42,860 --> 00:15:48,499
green line plus there is another reason

00:15:45,769 --> 00:15:50,239
you would expect that the ESP null is

00:15:48,499 --> 00:15:52,429
pretty close to clear traffic with our

00:15:50,239 --> 00:15:54,319
offloads there is still a big difference

00:15:52,429 --> 00:15:56,269
and that difference I found was because

00:15:54,319 --> 00:15:59,209
you also lose some of the benefits of

00:15:56,269 --> 00:16:00,529
RSS in RFS and even that can be

00:15:59,209 --> 00:16:02,569
mitigated so I'll talk about that as

00:16:00,529 --> 00:16:04,069
well and the last two cases just tells

00:16:02,569 --> 00:16:11,089
you the penalty of paying for crypto

00:16:04,069 --> 00:16:12,529
with respect to yes B no so what I found

00:16:11,089 --> 00:16:14,629
and that's the third bullet here

00:16:12,529 --> 00:16:16,489
basically I had to manually place the I

00:16:14,629 --> 00:16:19,069
per process on one CPU and the IARC

00:16:16,489 --> 00:16:20,360
using another c-came otherwise I was not

00:16:19,069 --> 00:16:21,739
getting the same thing as clear traffic

00:16:20,360 --> 00:16:29,209
with weather

00:16:21,739 --> 00:16:30,920
so d I was using GCM 256 which my

00:16:29,209 --> 00:16:32,089
understanding is it goes through AES and

00:16:30,920 --> 00:16:36,100
ISO and as you make even through

00:16:32,089 --> 00:16:36,100
hardware I went through the priority so

00:16:36,189 --> 00:16:41,509
so to summarize what I just said in the

00:16:39,139 --> 00:16:42,889
previous slide right so offload is very

00:16:41,509 --> 00:16:45,110
important to performance and then you

00:16:42,889 --> 00:16:47,089
apply IPSec we're disabling offload

00:16:45,110 --> 00:16:50,329
today because we're saying oh I need the

00:16:47,089 --> 00:16:52,819
TCP header first the other thing was the

00:16:50,329 --> 00:16:54,829
thing with hyper placement and irq

00:16:52,819 --> 00:16:57,799
balancing right I was using losing some

00:16:54,829 --> 00:16:59,239
of the RSS RFS benefits and there was

00:16:57,799 --> 00:17:01,160
also this was discussed on the list

00:16:59,239 --> 00:17:03,169
there are some things in the IPSec code

00:17:01,160 --> 00:17:05,299
which can be done better there was an SK

00:17:03,169 --> 00:17:08,059
be cow data and a few other things so

00:17:05,299 --> 00:17:09,589
some of those things were cleaned up for

00:17:08,059 --> 00:17:12,439
the numbers I'll be showing as well

00:17:09,589 --> 00:17:14,809
there's still work to be done there so

00:17:12,439 --> 00:17:16,850
the first thing was at least for gso and

00:17:14,809 --> 00:17:19,069
ero these are software implementations

00:17:16,850 --> 00:17:21,529
so you could potentially extend them to

00:17:19,069 --> 00:17:22,909
do IPSec at the right point after taking

00:17:21,529 --> 00:17:25,909
care of the offload right so that would

00:17:22,909 --> 00:17:27,709
be do the IP sick after gso segmentation

00:17:25,909 --> 00:17:29,630
and do the decrypt before you do the

00:17:27,709 --> 00:17:30,889
error chorus so turned out stephane

00:17:29,630 --> 00:17:32,419
class it was also looking at the same

00:17:30,889 --> 00:17:35,179
thing for the giro site so we put our

00:17:32,419 --> 00:17:36,919
work together and when we try to combine

00:17:35,179 --> 00:17:39,049
thing this is what you get for the same

00:17:36,919 --> 00:17:40,850
setup right the software performance has

00:17:39,049 --> 00:17:42,260
gone up significantly you've gone from 2

00:17:40,850 --> 00:17:44,510
gigabits per second to 8

00:17:42,260 --> 00:17:46,240
right this is almost close to what you

00:17:44,510 --> 00:17:49,280
were getting with clearer traffic with

00:17:46,240 --> 00:17:51,650
sovereign's the CPU utilization has

00:17:49,280 --> 00:17:53,750
peaked and that's not good right and

00:17:51,650 --> 00:17:56,150
this is this hurts even more when you go

00:17:53,750 --> 00:17:58,790
to GCM 256 because I was not able to go

00:17:56,150 --> 00:18:01,580
more than 4.5 gigabits per second right

00:17:58,790 --> 00:18:04,100
on this and a hundred percent CPA so

00:18:01,580 --> 00:18:05,660
that tells me that this is time to start

00:18:04,100 --> 00:18:07,250
looking at hardware offloads because

00:18:05,660 --> 00:18:09,049
this is the best you can do in software

00:18:07,250 --> 00:18:11,990
there might still be things you could

00:18:09,049 --> 00:18:13,250
fix but I think that to get the real 10

00:18:11,990 --> 00:18:17,030
gig you would have to go to hardware

00:18:13,250 --> 00:18:18,980
offers and when I talk to some Intel

00:18:17,030 --> 00:18:21,620
people they told me that the 10g NICs

00:18:18,980 --> 00:18:24,320
Niantic to anvil satiable already

00:18:21,620 --> 00:18:26,929
supports IPSec offload and it looks like

00:18:24,320 --> 00:18:29,470
Microsoft has the DDI eyes and DK eyes

00:18:26,929 --> 00:18:31,790
for this but the Linux stack does not

00:18:29,470 --> 00:18:34,400
this is something I'm hoping to develop

00:18:31,790 --> 00:18:37,040
this week I was talking to a few more

00:18:34,400 --> 00:18:38,660
Intel people today might not be there

00:18:37,040 --> 00:18:41,090
might be more to this than meets the eye

00:18:38,660 --> 00:18:45,410
so one of the things we need to explore

00:18:41,090 --> 00:18:47,240
is how to do Hardware offer so the other

00:18:45,410 --> 00:18:50,480
thing was the flow hashing on the

00:18:47,240 --> 00:18:53,030
receive side so today's RSS and RFS

00:18:50,480 --> 00:18:55,130
classifies things based on flows that

00:18:53,030 --> 00:18:57,020
are defined on IP addresses and port

00:18:55,130 --> 00:18:59,900
numbers TCP and UDP port numbers

00:18:57,020 --> 00:19:01,730
so when IPSec was applied in assumes

00:18:59,900 --> 00:19:04,610
that the port number has been encrypted

00:19:01,730 --> 00:19:06,470
and does not do a very good job of doing

00:19:04,610 --> 00:19:08,270
the flow classification right so that's

00:19:06,470 --> 00:19:09,710
why I was losing the benefit of that so

00:19:08,270 --> 00:19:11,600
what I instead had to do I had to

00:19:09,710 --> 00:19:13,700
manually put the irq on one place and

00:19:11,600 --> 00:19:16,850
the I per process in another to get the

00:19:13,700 --> 00:19:19,250
best possible performance but it doesn't

00:19:16,850 --> 00:19:21,740
have to be this way right there is the

00:19:19,250 --> 00:19:24,559
SPI which identifies the IPSec flow

00:19:21,740 --> 00:19:26,600
which is it is a 32-bit number and when

00:19:24,559 --> 00:19:28,190
you are doing ESP it conveniently falls

00:19:26,600 --> 00:19:30,290
in the same place as the TCP and UDP

00:19:28,190 --> 00:19:32,780
port numbers so even the hardware should

00:19:30,290 --> 00:19:34,880
not need too much change to mark to use

00:19:32,780 --> 00:19:36,890
that right the question was raised on

00:19:34,880 --> 00:19:38,390
the list is it is it orchid actually

00:19:36,890 --> 00:19:41,240
correct to do that and the answer is yes

00:19:38,390 --> 00:19:43,340
because the SA minimally identifies the

00:19:41,240 --> 00:19:44,510
IP endpoint addresses so it's not it

00:19:43,340 --> 00:19:46,850
doesn't make things worse

00:19:44,510 --> 00:19:48,440
it does make things better for our case

00:19:46,850 --> 00:19:50,530
because we can make this flow pretty

00:19:48,440 --> 00:19:53,140
specific based on the port numbers

00:19:50,530 --> 00:19:54,880
besides the the final argument is we are

00:19:53,140 --> 00:19:56,919
already doing this infrared reports off

00:19:54,880 --> 00:19:58,990
set to do on the TX path so we just need

00:19:56,919 --> 00:20:01,270
to do this uniformly everywhere right

00:19:58,990 --> 00:20:03,429
and I think it should also be fairly

00:20:01,270 --> 00:20:06,780
easy to get the drivers to process this

00:20:03,429 --> 00:20:09,280
when you're on a hash based on the ESP

00:20:06,780 --> 00:20:11,020
so to leave time for questions I'll just

00:20:09,280 --> 00:20:13,000
stop here and talk about what's going on

00:20:11,020 --> 00:20:15,850
right now one is to look at the hardware

00:20:13,000 --> 00:20:18,940
offload of IPSec where I'm hoping this

00:20:15,850 --> 00:20:20,830
will reduce the CPU utilization the

00:20:18,940 --> 00:20:22,750
Microsoft API looks like they're pushing

00:20:20,830 --> 00:20:25,179
the security Association to the driver

00:20:22,750 --> 00:20:28,270
and keeping that updated as the fifth

00:20:25,179 --> 00:20:31,809
changes I don't know if how well that

00:20:28,270 --> 00:20:34,059
worked and what what how what what minor

00:20:31,809 --> 00:20:35,890
might have more to say on this then we

00:20:34,059 --> 00:20:38,710
need better receive side flow hashing

00:20:35,890 --> 00:20:40,240
and hardware and software the flow hash

00:20:38,710 --> 00:20:43,240
can come to us from the NIC there's also

00:20:40,240 --> 00:20:44,679
other things we there's an FD R hash

00:20:43,240 --> 00:20:46,059
there are F near misses that are going

00:20:44,679 --> 00:20:47,140
on so I don't know if we can use the FD

00:20:46,059 --> 00:20:50,260
a better so that's another thing to

00:20:47,140 --> 00:20:52,510
explore we also need to work on the

00:20:50,260 --> 00:20:54,070
software paths itself even the 8

00:20:52,510 --> 00:20:56,559
gigabits per second can might get better

00:20:54,070 --> 00:20:58,539
at that point and then move on to more

00:20:56,559 --> 00:21:01,330
benchmarks macro benchmarks try real

00:20:58,539 --> 00:21:03,940
database workloads try this from a VM

00:21:01,330 --> 00:21:11,940
try more difficult things and just a

00:21:03,940 --> 00:21:11,940
simple I told us so questions comments I

00:21:15,299 --> 00:21:22,120
I think that you could I don't know

00:21:19,240 --> 00:21:23,860
I hope they will respond but in my

00:21:22,120 --> 00:21:25,210
opinion you if you try to fix that to

00:21:23,860 --> 00:21:26,409
deal with all the cases of a

00:21:25,210 --> 00:21:29,409
synchronicity you'll just end up

00:21:26,409 --> 00:21:30,640
inventing a third modern IPSec right

00:21:29,409 --> 00:21:32,500
because you would have to solve all the

00:21:30,640 --> 00:21:34,870
things IPSec check out over the years so

00:21:32,500 --> 00:21:38,100
you can do it but I think we might so

00:21:34,870 --> 00:21:38,100
just clean up IPSec at a point

00:21:41,539 --> 00:21:47,989
first one regarding the hash function

00:21:44,830 --> 00:21:51,970
you'll know previous slides you

00:21:47,989 --> 00:21:51,970
mentioned that you hash also by ports

00:21:54,070 --> 00:22:03,590
with IP fragmentation for UDP that is

00:22:01,909 --> 00:22:05,090
that is something I was actually asking

00:22:03,590 --> 00:22:08,029
someone yesterday I don't know how the

00:22:05,090 --> 00:22:10,159
RSS RFS code today works on that I think

00:22:08,029 --> 00:22:11,659
that if you have IP fragmentation they

00:22:10,159 --> 00:22:53,090
assume we are already going in the slow

00:22:11,659 --> 00:22:53,659
path so you don't have our you know the

00:22:53,090 --> 00:22:56,960
qat

00:22:53,659 --> 00:22:59,779
I didn't quite catch what chip you

00:22:56,960 --> 00:23:09,129
mentioned acuity Intel has to chip start

00:22:59,779 --> 00:23:09,129
you cannot replace it I have to decline

00:23:10,509 --> 00:23:13,729
I would certainly be interested in

00:23:12,619 --> 00:23:16,179
trying that I was not aware of this

00:23:13,729 --> 00:23:16,179
thank you

00:23:19,580 --> 00:23:29,570
we can say you know I need this I think

00:23:27,889 --> 00:23:34,279
Jesse brown was mentioning this to me

00:23:29,570 --> 00:23:35,629
this morning the qat yes something I

00:23:34,279 --> 00:23:37,429
have to look into but that's another

00:23:35,629 --> 00:23:51,529
ongoing wound thing this is hardly done

00:23:37,429 --> 00:23:53,720
here yes that's that's why I said the

00:23:51,529 --> 00:23:55,340
ESP DSP I conveniently Falls in the

00:23:53,720 --> 00:23:57,139
right place so it should be easy for

00:23:55,340 --> 00:23:58,820
them to modify themselves - that's a lot

00:23:57,139 --> 00:24:05,869
easier than the offload part that's what

00:23:58,820 --> 00:24:08,499
Antonio keeps talking the vendors and

00:24:05,869 --> 00:24:08,499
saying don't get scared

00:24:22,869 --> 00:24:35,929
you could use the time or two for that

00:24:25,220 --> 00:24:37,309
if you that's what that's no I just

00:24:35,929 --> 00:24:39,259
started with micro benchmarks and this

00:24:37,309 --> 00:24:42,669
was actually quite to start with to week

00:24:39,259 --> 00:24:42,669
of its per second was quite depressing

00:24:44,889 --> 00:25:03,200
yeah in this case that's why I'm working

00:24:55,070 --> 00:25:04,549
with step transparent yeah so Stephan

00:25:03,200 --> 00:25:05,899
Rubick I don't have Stefan's here but

00:25:04,549 --> 00:25:07,519
Stefan's going to was looking at that

00:25:05,899 --> 00:25:09,320
quietiy in quite a lot of detail so

00:25:07,519 --> 00:25:12,799
he'll talk about that tomorrow in his IT

00:25:09,320 --> 00:25:14,299
sector but the numbers were similar he

00:25:12,799 --> 00:25:16,899
was also capping off at four gigabits

00:25:14,299 --> 00:25:16,899
per second

00:25:23,070 --> 00:25:26,070

YouTube URL: https://www.youtube.com/watch?v=0x67kqF9DpM


