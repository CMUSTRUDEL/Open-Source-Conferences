Title: Netdev 1.1 - Networking in your pocket: how the Linux networking stack is made to work...
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 1 - Wednesday February 10, 2016
Description: 
	Full title: "Networking in your pocket: how the Linux networking stack is made to work on Android devices"
Lorenzo Colitti
February 2016
Captions: 
	00:00:00,079 --> 00:00:04,950
thank you yes sir my name is Lorenzo

00:00:02,580 --> 00:00:06,870
khalili my part of the Android

00:00:04,950 --> 00:00:08,880
networking team the core team which does

00:00:06,870 --> 00:00:14,059
link layer independent stuff is Wi-Fi

00:00:08,880 --> 00:00:16,109
there's telephony and there's us so a

00:00:14,059 --> 00:00:18,810
little bit of what I'll be talking about

00:00:16,109 --> 00:00:20,600
how mobile devices sort of has different

00:00:18,810 --> 00:00:24,420
needs than a lot of other Linux

00:00:20,600 --> 00:00:26,550
networking stack users then what we you

00:00:24,420 --> 00:00:28,890
know how what we built around the limits

00:00:26,550 --> 00:00:31,769
that working stack to do what users

00:00:28,890 --> 00:00:34,230
expect the phone to do and what's

00:00:31,769 --> 00:00:38,969
upstream was not upstream and what we

00:00:34,230 --> 00:00:41,340
might do after that so one of the things

00:00:38,969 --> 00:00:43,950
that's different about mobile networking

00:00:41,340 --> 00:00:47,760
is that it it has needs that people

00:00:43,950 --> 00:00:50,039
might not sort of immediately understand

00:00:47,760 --> 00:00:52,020
are different from a lot of other users

00:00:50,039 --> 00:00:54,629
like data centers or home machines or

00:00:52,020 --> 00:00:58,079
whatever the phone is very different

00:00:54,629 --> 00:01:01,920
from a data center I mean we do both at

00:00:58,079 --> 00:01:03,300
Google so we kind of know but so you

00:01:01,920 --> 00:01:05,129
know phone moves all the time it's

00:01:03,300 --> 00:01:06,360
connected to networks that have varying

00:01:05,129 --> 00:01:07,890
quality it's connected to multiple

00:01:06,360 --> 00:01:10,500
networks at the same time pretty much

00:01:07,890 --> 00:01:13,170
all the time it connects to different

00:01:10,500 --> 00:01:15,540
link types it's got to deal with bad

00:01:13,170 --> 00:01:16,549
networks low quality signals fading

00:01:15,540 --> 00:01:19,830
signals

00:01:16,549 --> 00:01:21,270
you know captive portals disconnected

00:01:19,830 --> 00:01:22,530
networks that don't go anywhere but you

00:01:21,270 --> 00:01:25,590
need to use them anyway to connect to

00:01:22,530 --> 00:01:27,900
your wireless printer it's got lots of

00:01:25,590 --> 00:01:31,049
power issues it's got limited bandwidth

00:01:27,900 --> 00:01:32,610
sometimes it has to be metered it's got

00:01:31,049 --> 00:01:33,869
a sandbox bottle between different

00:01:32,610 --> 00:01:36,780
locations you have to have per

00:01:33,869 --> 00:01:38,970
application routing is there's very

00:01:36,780 --> 00:01:40,770
different problem set very different

00:01:38,970 --> 00:01:44,040
challenges from same machine sitting in

00:01:40,770 --> 00:01:46,110
a data center it doesn't have as much

00:01:44,040 --> 00:01:48,780
performance the scalability work as say

00:01:46,110 --> 00:01:50,100
machine and data center so that makes it

00:01:48,780 --> 00:01:53,670
a little bit easier on us it's also

00:01:50,100 --> 00:01:55,500
fairly slow you know the chips we have a

00:01:53,670 --> 00:01:57,030
fairly slow they get into thermal

00:01:55,500 --> 00:02:00,210
throttling very easy it's this very

00:01:57,030 --> 00:02:04,170
different networking environment and the

00:02:00,210 --> 00:02:05,939
main challenge I think it's it's very

00:02:04,170 --> 00:02:07,439
fundamental challenge is that it's it's

00:02:05,939 --> 00:02:09,509
the phone is connected to multiple

00:02:07,439 --> 00:02:10,539
networks pretty much all the time so if

00:02:09,509 --> 00:02:12,129
you've got

00:02:10,539 --> 00:02:13,450
a phone it's on Wi-Fi you'll have

00:02:12,129 --> 00:02:15,670
probably you'll have at least two

00:02:13,450 --> 00:02:17,379
networks up you'll have an IP network

00:02:15,670 --> 00:02:21,670
that goes to the carrier's core network

00:02:17,379 --> 00:02:23,500
for IMS and voice signaling and SMS and

00:02:21,670 --> 00:02:26,079
things like that and then you'll have

00:02:23,500 --> 00:02:28,209
you know you'll have Wi-Fi up and you

00:02:26,079 --> 00:02:29,980
might have mobile data up if some app is

00:02:28,209 --> 00:02:31,180
requesting it if you're on Wi-Fi and you

00:02:29,980 --> 00:02:32,470
want to send it immerse you have to

00:02:31,180 --> 00:02:34,959
bring up the cell network which is a

00:02:32,470 --> 00:02:36,579
different IP interface that's still on

00:02:34,959 --> 00:02:38,859
the cell network what's different

00:02:36,579 --> 00:02:40,329
interface and so all these things are up

00:02:38,859 --> 00:02:42,639
at the same time they come and go you

00:02:40,329 --> 00:02:44,739
need to do seamless switching because

00:02:42,639 --> 00:02:46,480
you know when you get home you want to

00:02:44,739 --> 00:02:49,269
be able to get onto your Wi-Fi network

00:02:46,480 --> 00:02:50,650
very quickly and you want to leave TCP

00:02:49,269 --> 00:02:52,180
connections that were established on

00:02:50,650 --> 00:02:53,709
let's say the cell network that you want

00:02:52,180 --> 00:02:55,959
to leave them up until you know for a

00:02:53,709 --> 00:02:57,220
few seconds until you actually establish

00:02:55,959 --> 00:02:58,510
everything on the new network and you

00:02:57,220 --> 00:03:00,280
have to tell the apps that the network

00:02:58,510 --> 00:03:01,720
has changed and that way you actually

00:03:00,280 --> 00:03:04,090
end up having to do is you have to shoot

00:03:01,720 --> 00:03:05,739
all their TCP connections so they don't

00:03:04,090 --> 00:03:07,689
get blocked on Reed's that will never

00:03:05,739 --> 00:03:10,359
complete because you take away their IP

00:03:07,689 --> 00:03:12,340
address and normally in minutes it's

00:03:10,359 --> 00:03:13,930
just the TCP connection just sits there

00:03:12,340 --> 00:03:16,690
hoping the IP address might come back

00:03:13,930 --> 00:03:17,889
you know and usually it doesn't come

00:03:16,690 --> 00:03:19,419
back quickly enough for that to make

00:03:17,889 --> 00:03:20,769
sense so what we do is every every

00:03:19,419 --> 00:03:23,949
networks retreat close these P

00:03:20,769 --> 00:03:25,859
connections we have to deal with ipv6

00:03:23,949 --> 00:03:28,690
that's actually complicates the

00:03:25,859 --> 00:03:30,729
architecture in a few ways as we'll see

00:03:28,690 --> 00:03:32,799
but you know this it's just not an

00:03:30,729 --> 00:03:34,449
option not to you know not an option not

00:03:32,799 --> 00:03:36,430
to have it as a first-class citizen if

00:03:34,449 --> 00:03:38,470
you look at Android usage in the u.s.

00:03:36,430 --> 00:03:40,359
cell networks the majority of it is

00:03:38,470 --> 00:03:44,109
actually a pv6 today it's this more than

00:03:40,359 --> 00:03:46,109
it's more than 50% okay it's got lots of

00:03:44,109 --> 00:03:48,400
power challenges neo power is a

00:03:46,109 --> 00:03:50,349
fascinating subject very challenging

00:03:48,400 --> 00:03:53,470
topic that's we won't necessarily go

00:03:50,349 --> 00:03:55,269
into here but it does do things like

00:03:53,470 --> 00:03:58,959
when you have a kernel timer that

00:03:55,269 --> 00:04:00,879
doesn't take away clock the timer might

00:03:58,959 --> 00:04:03,549
fire after one second after five minutes

00:04:00,879 --> 00:04:05,409
of passed so it'll so it's it's actually

00:04:03,549 --> 00:04:11,530
quite interesting when you have that

00:04:05,409 --> 00:04:13,840
sort of event and we have to run the the

00:04:11,530 --> 00:04:17,680
the kernels that we run are not the

00:04:13,840 --> 00:04:20,299
newest and that's mostly up to the OEMs

00:04:17,680 --> 00:04:23,090
and system and SOC vendors

00:04:20,299 --> 00:04:24,259
but you know the new Nexus 5 runs 3.4

00:04:23,090 --> 00:04:27,169
and

00:04:24,259 --> 00:04:31,190
the Nexus 7 first generation used to run

00:04:27,169 --> 00:04:32,960
3.1 and so we have to run on a variety

00:04:31,190 --> 00:04:35,360
of different kernel versions every

00:04:32,960 --> 00:04:38,389
device has its own kernel tree it's sort

00:04:35,360 --> 00:04:40,659
of quite challenging even to know that

00:04:38,389 --> 00:04:42,860
you have the right commits in your trees

00:04:40,659 --> 00:04:44,720
also you have to do stuff that users

00:04:42,860 --> 00:04:46,400
expect the thing to be able to define to

00:04:44,720 --> 00:04:48,169
be able to do and it's not something

00:04:46,400 --> 00:04:50,120
that this top-class machine will do it

00:04:48,169 --> 00:04:52,129
needs to be connected they when you're

00:04:50,120 --> 00:04:55,430
on cell data and you're getting you know

00:04:52,129 --> 00:04:57,409
email syncing and chat messages coming

00:04:55,430 --> 00:04:59,900
in and you connect to a captive portal

00:04:57,409 --> 00:05:01,669
Wi-Fi users don't you want the network

00:04:59,900 --> 00:05:03,169
to stop working as we said on the

00:05:01,669 --> 00:05:06,080
captive portal of Wi-Fi waiting for

00:05:03,169 --> 00:05:08,110
loggin what we do is we bring up the

00:05:06,080 --> 00:05:10,009
Wi-Fi network in the background we do a

00:05:08,110 --> 00:05:11,810
validation check we see if it has a

00:05:10,009 --> 00:05:14,449
captive portal and if so we give you the

00:05:11,810 --> 00:05:16,879
ability to log in right that means that

00:05:14,449 --> 00:05:18,889
you have to have like robust first-class

00:05:16,879 --> 00:05:20,780
support for you know connecting on

00:05:18,889 --> 00:05:22,280
multiple networks and when that when

00:05:20,780 --> 00:05:24,020
you're using the weak host bubble that

00:05:22,280 --> 00:05:25,159
really doesn't work well so we have to

00:05:24,020 --> 00:05:27,080
build a bunch of infrastructure around

00:05:25,159 --> 00:05:29,719
the we Coast model to make this stuff

00:05:27,080 --> 00:05:31,310
work other things you know when you

00:05:29,719 --> 00:05:33,620
people want to connect to their wireless

00:05:31,310 --> 00:05:36,229
printers or wireless cameras a GoPro

00:05:33,620 --> 00:05:37,729
camera you'd like to be able to access

00:05:36,229 --> 00:05:39,289
the internet at the same time as you do

00:05:37,729 --> 00:05:40,580
this so you have to have different for

00:05:39,289 --> 00:05:44,719
application routing or per socket

00:05:40,580 --> 00:05:46,490
routing and so on and applications we

00:05:44,719 --> 00:05:49,310
want to be able to select this you know

00:05:46,490 --> 00:05:50,569
and MSA MMS app needs to be able to

00:05:49,310 --> 00:05:52,940
bring up the cell network and bind to

00:05:50,569 --> 00:05:55,909
that network and then we have data usage

00:05:52,940 --> 00:05:57,669
tracking which you know is you know

00:05:55,909 --> 00:06:02,060
fairly complicated as we'll see later on

00:05:57,669 --> 00:06:04,610
per user VPNs things like that here's

00:06:02,060 --> 00:06:06,770
one simple thing that we you know since

00:06:04,610 --> 00:06:08,930
you know 6.0 we do if you connect to a

00:06:06,770 --> 00:06:10,310
wireless network that's disconnected so

00:06:08,930 --> 00:06:11,990
you connect to a wireless ap that

00:06:10,310 --> 00:06:14,509
doesn't have internet backhaul or you

00:06:11,990 --> 00:06:16,129
connect to a wireless printer the device

00:06:14,509 --> 00:06:17,629
will ask you do you want to connect to

00:06:16,129 --> 00:06:19,729
this network because it doesn't go

00:06:17,629 --> 00:06:21,500
anywhere and in order to do this you

00:06:19,729 --> 00:06:22,439
have to have the ability to at least you

00:06:21,500 --> 00:06:24,209
know do dns on the

00:06:22,439 --> 00:06:25,349
around network - you know open a TCP

00:06:24,209 --> 00:06:27,239
connection on the background network

00:06:25,349 --> 00:06:28,439
when you switch to that network the TCP

00:06:27,239 --> 00:06:29,669
connections they were established on it

00:06:28,439 --> 00:06:33,569
needs to stay on that the old ones need

00:06:29,669 --> 00:06:35,099
to be torn out its own so this looks

00:06:33,569 --> 00:06:38,039
very simple but you know it has to have

00:06:35,099 --> 00:06:40,349
solid infrastructure behind it so what

00:06:38,039 --> 00:06:41,989
do we do so a lot of a lot of the

00:06:40,349 --> 00:06:45,989
complexity that we have is actually

00:06:41,989 --> 00:06:47,580
emulating the strong host model within

00:06:45,989 --> 00:06:50,550
the Linux networking expect particularly

00:06:47,580 --> 00:06:56,909
ipv6 is solidly based on the weak host

00:06:50,550 --> 00:06:57,869
model the and the RFC 6-7 24 so source

00:06:56,909 --> 00:07:02,189
address and destination address

00:06:57,869 --> 00:07:05,759
selection basically are implemented in

00:07:02,189 --> 00:07:09,179
terms of the weak house model and so you

00:07:05,759 --> 00:07:10,499
can't use the t-mobile or whatever you

00:07:09,179 --> 00:07:12,749
know that you can't use your cell

00:07:10,499 --> 00:07:14,550
network IP address on Wi-Fi it doesn't

00:07:12,749 --> 00:07:17,339
work you can't use the DNS servers on

00:07:14,550 --> 00:07:18,659
Wi-Fi it doesn't work so there are a few

00:07:17,339 --> 00:07:21,239
things that you say okay well how do you

00:07:18,659 --> 00:07:22,800
fix as well just use bind and use source

00:07:21,239 --> 00:07:24,929
address routing well it turns out they

00:07:22,800 --> 00:07:26,159
can't actually do that because the

00:07:24,929 --> 00:07:27,539
application doesn't know which of the

00:07:26,159 --> 00:07:30,990
three or four addresses on ancient

00:07:27,539 --> 00:07:33,300
device to bind to and with with Auto

00:07:30,990 --> 00:07:34,649
Kampf with ipv6 Auto Kampf IP addresses

00:07:33,300 --> 00:07:38,249
can appear at any time so you have lots

00:07:34,649 --> 00:07:41,339
of racism in terms of okay so AP

00:07:38,249 --> 00:07:43,079
addresses you call connect and that

00:07:41,339 --> 00:07:45,300
doesn't really work up and chooses your

00:07:43,079 --> 00:07:48,029
source or us and then a new address

00:07:45,300 --> 00:07:50,550
appears and so basically which source

00:07:48,029 --> 00:07:52,619
address to use depends on the DNS lookup

00:07:50,550 --> 00:07:54,599
and so you have to do a DNS lookup

00:07:52,619 --> 00:07:56,099
figure out the destination address based

00:07:54,599 --> 00:07:57,300
on the destination addresses do a bunch

00:07:56,099 --> 00:07:58,739
of routing lookups to figure out the

00:07:57,300 --> 00:08:01,399
source dress that you want to use and

00:07:58,739 --> 00:08:04,860
putting that in the APIs is sort of

00:08:01,399 --> 00:08:07,050
unfitting yo it's you know not it's

00:08:04,860 --> 00:08:09,059
complicated and and doesn't seem to be

00:08:07,050 --> 00:08:11,489
the right thing to burn in apps with you

00:08:09,059 --> 00:08:12,509
can't use a so binded device because a

00:08:11,489 --> 00:08:15,449
network might have more than one

00:08:12,509 --> 00:08:17,729
interface we have this 464xlat thing

00:08:15,449 --> 00:08:21,079
which uses two interfaces one on top of

00:08:17,729 --> 00:08:23,729
each other to do ipv4 our v6 translation

00:08:21,079 --> 00:08:25,110
you can't use IP tables if you care

00:08:23,729 --> 00:08:28,139
about your source address because IP

00:08:25,110 --> 00:08:29,699
tables gets to touch the packet way way

00:08:28,139 --> 00:08:31,949
way after the source address has been

00:08:29,699 --> 00:08:33,870
selected and basically your only option

00:08:31,949 --> 00:08:36,459
at that point is to force rewrite the

00:08:33,870 --> 00:08:38,260
source address which basically means

00:08:36,459 --> 00:08:41,139
you've got the wrong MTU you've got the

00:08:38,260 --> 00:08:43,029
wrong MSS and so on and so forth in

00:08:41,139 --> 00:08:44,680
namespaces at the time we looked at this

00:08:43,029 --> 00:08:46,829
it was you know they were very limited

00:08:44,680 --> 00:08:49,180
in terms of what we could do with them

00:08:46,829 --> 00:08:51,490
you know and into a physical interface

00:08:49,180 --> 00:08:53,380
could only be in one namespace so that

00:08:51,490 --> 00:08:56,380
was I don't know if the situation has

00:08:53,380 --> 00:08:59,130
gotten better but again you know there's

00:08:56,380 --> 00:09:03,519
kernels that we run or can be fairly

00:08:59,130 --> 00:09:05,320
quite a lot behind that upstream so what

00:09:03,519 --> 00:09:08,470
do we do we ended up using multiple

00:09:05,320 --> 00:09:12,639
routing tables fairly sophisticated set

00:09:08,470 --> 00:09:14,050
of IP rules with with we use a socket

00:09:12,639 --> 00:09:16,630
mark extensive stock it marked

00:09:14,050 --> 00:09:18,459
extensively the application visible

00:09:16,630 --> 00:09:22,810
concept is this thing called the network

00:09:18,459 --> 00:09:25,660
it's a Java API and there's a

00:09:22,810 --> 00:09:27,250
corresponding NDK API as well it's

00:09:25,660 --> 00:09:29,050
loosely equivalent to the ITF

00:09:27,250 --> 00:09:32,050
provisioning domain which is essentially

00:09:29,050 --> 00:09:35,110
a set of interfaces or a set of network

00:09:32,050 --> 00:09:37,810
resources that are in one that you know

00:09:35,110 --> 00:09:39,579
roll up to one administrative domain one

00:09:37,810 --> 00:09:43,120
master so you know your Wi-Fi would be

00:09:39,579 --> 00:09:44,920
one and you're your cell network would

00:09:43,120 --> 00:09:46,240
be another but if you know the Wi-Fi

00:09:44,920 --> 00:09:48,040
network and the cell network were

00:09:46,240 --> 00:09:49,510
provided by the same carrier you would

00:09:48,040 --> 00:09:51,790
try to put those in the same

00:09:49,510 --> 00:09:53,800
provisioning domain it's not something

00:09:51,790 --> 00:09:55,630
we support today but it's it's loosely

00:09:53,800 --> 00:09:58,420
equivalent to a network in many cases

00:09:55,630 --> 00:10:01,990
it's an interface but it's not not quite

00:09:58,420 --> 00:10:04,540
not not always we bind connections to

00:10:01,990 --> 00:10:06,790
networks so for example when you when

00:10:04,540 --> 00:10:08,890
you establish a connection on on your

00:10:06,790 --> 00:10:10,510
mobile network interface that TCP

00:10:08,890 --> 00:10:12,790
connection is running cool you'd only

00:10:10,510 --> 00:10:14,350
have one network now Wi-Fi comes up the

00:10:12,790 --> 00:10:15,880
default route you know in a normal

00:10:14,350 --> 00:10:18,430
system the default route would switch to

00:10:15,880 --> 00:10:20,319
Wi-Fi and that cell connection is dead

00:10:18,430 --> 00:10:22,000
in the water it's sending out packets on

00:10:20,319 --> 00:10:24,569
Wi-Fi with the cell networks no stress

00:10:22,000 --> 00:10:27,550
it doesn't work so what we do is when

00:10:24,569 --> 00:10:31,510
when an app uses the networking api's or

00:10:27,550 --> 00:10:33,910
when when it calls connect we set the

00:10:31,510 --> 00:10:36,209
socket mark in its socket that binds it

00:10:33,910 --> 00:10:37,889
to that network so it

00:10:36,209 --> 00:10:40,499
a bond to that network for the lifetime

00:10:37,889 --> 00:10:42,059
of the connection we do other things for

00:10:40,499 --> 00:10:45,779
you know incoming connections as well

00:10:42,059 --> 00:10:47,850
and api's then we have each Apple on

00:10:45,779 --> 00:10:50,519
Android is its own user ID so we have

00:10:47,850 --> 00:10:53,759
well what we do is we have in kernel

00:10:50,519 --> 00:10:56,490
support for you per UID routing which

00:10:53,759 --> 00:11:02,249
mostly works we'll talk about that a

00:10:56,490 --> 00:11:04,199
little bit more later so we have one

00:11:02,249 --> 00:11:05,999
routing table per interface a lot of

00:11:04,199 --> 00:11:07,740
this complexity by the way is is due to

00:11:05,999 --> 00:11:09,689
the interaction with of the strong host

00:11:07,740 --> 00:11:11,790
model and particularly ipv6 auto

00:11:09,689 --> 00:11:14,910
configuration where addresses can show

00:11:11,790 --> 00:11:17,189
up basically at any time and so we don't

00:11:14,910 --> 00:11:20,040
do auto companies or space we do it in

00:11:17,189 --> 00:11:22,259
kernel space and so we can't afford to

00:11:20,040 --> 00:11:24,059
have any sort of rule that's based on IP

00:11:22,259 --> 00:11:25,829
address because it's pretty much out of

00:11:24,059 --> 00:11:28,619
date as soon as we add it because some

00:11:25,829 --> 00:11:32,519
other other you know you you get an RT M

00:11:28,619 --> 00:11:34,619
new adder and you know when they address

00:11:32,519 --> 00:11:36,089
happens but if someone's called connect

00:11:34,619 --> 00:11:40,439
in the meantime the source service might

00:11:36,089 --> 00:11:43,470
be wrong so we basically put different

00:11:40,439 --> 00:11:44,879
you put roots for in a particular

00:11:43,470 --> 00:11:47,339
interface in a routing table that's

00:11:44,879 --> 00:11:50,160
particular to that interface and network

00:11:47,339 --> 00:11:51,509
is one or more interfaces and the the

00:11:50,160 --> 00:11:55,220
sort of the main routing table is pretty

00:11:51,509 --> 00:11:57,720
much empty usually it's it's used for

00:11:55,220 --> 00:12:00,660
recursive loop root lookups inside the

00:11:57,720 --> 00:12:02,819
kernel when you do IP route default via

00:12:00,660 --> 00:12:05,009
blah and then the kernel has to do the

00:12:02,819 --> 00:12:06,240
lookup for blah and so we'll see later

00:12:05,009 --> 00:12:09,509
in the rules that's only allowed for

00:12:06,240 --> 00:12:11,040
route basically but the nice thing is

00:12:09,509 --> 00:12:14,249
that we don't have to worry about IP

00:12:11,040 --> 00:12:17,879
addresses at all so IEP rule will select

00:12:14,249 --> 00:12:19,679
the network if you match an IP rule that

00:12:17,879 --> 00:12:21,629
rule will look up a particular ruling

00:12:19,679 --> 00:12:22,920
table and it will point to a particular

00:12:21,629 --> 00:12:25,230
interface which is in a particular

00:12:22,920 --> 00:12:26,670
network if you now if you want to change

00:12:25,230 --> 00:12:29,329
the default Network you change the

00:12:26,670 --> 00:12:32,040
default rule easy done

00:12:29,329 --> 00:12:34,769
we support the rule select for Marx

00:12:32,040 --> 00:12:36,809
which is you know the implicit marks

00:12:34,769 --> 00:12:40,410
which are established on connect the API

00:12:36,809 --> 00:12:42,809
is set the marks and they also use we

00:12:40,410 --> 00:12:45,379
make you know so blind advice or IP

00:12:42,809 --> 00:12:49,629
packet info socket options we

00:12:45,379 --> 00:12:49,629
those like particular networks and so on

00:12:49,839 --> 00:12:56,599
so because that's so mark requires

00:12:53,720 --> 00:12:58,789
captain admin we when an app calls

00:12:56,599 --> 00:13:00,679
connect or uses the socket API as we

00:12:58,789 --> 00:13:02,720
send the FD off to a privileged process

00:13:00,679 --> 00:13:06,199
so there can be stamped and then we

00:13:02,720 --> 00:13:07,729
return it because connect is going to be

00:13:06,199 --> 00:13:10,399
hitting the network anyway it's not

00:13:07,729 --> 00:13:12,739
necessarily a very big latency hit so we

00:13:10,399 --> 00:13:15,799
have C library shims for connect that

00:13:12,739 --> 00:13:17,179
just proxy the VFD over to a tonight to

00:13:15,799 --> 00:13:19,309
use the space name and privilege call

00:13:17,179 --> 00:13:21,649
that D which has kept that admin and so

00:13:19,309 --> 00:13:23,989
on for incoming connections we have some

00:13:21,649 --> 00:13:28,549
kernel a little bit of curl magic that

00:13:23,989 --> 00:13:31,549
applies that the S key B mark to mask a

00:13:28,549 --> 00:13:35,479
mark marks contain the network ID and

00:13:31,549 --> 00:13:37,389
some permissions so this is what I don't

00:13:35,479 --> 00:13:40,099
know if you can read any of this at all

00:13:37,389 --> 00:13:42,079
but this is what the rules look like you

00:13:40,099 --> 00:13:46,519
can see there are a lot of them some of

00:13:42,079 --> 00:13:48,619
them select for traffic that's where

00:13:46,519 --> 00:13:51,529
you've selected an interface by sa bind

00:13:48,619 --> 00:13:51,919
device or IP packet info or things like

00:13:51,529 --> 00:13:54,169
that

00:13:51,919 --> 00:13:56,059
most of them select for marks there's

00:13:54,169 --> 00:13:58,309
difference between implicit marks and

00:13:56,059 --> 00:14:00,769
explicit marks then there's some

00:13:58,309 --> 00:14:02,869
permission bits and protect bits

00:14:00,769 --> 00:14:04,339
the nice thing again is that there are

00:14:02,869 --> 00:14:06,199
no IP addresses in here there's no

00:14:04,339 --> 00:14:09,709
there's no source based routing there's

00:14:06,199 --> 00:14:11,809
all that all these tables actually one

00:14:09,709 --> 00:14:13,359
simplifying assumption is that most

00:14:11,809 --> 00:14:16,009
networks that Android connects to

00:14:13,359 --> 00:14:18,799
basically has a default route and so we

00:14:16,009 --> 00:14:21,350
if the system is mostly optimized for

00:14:18,799 --> 00:14:23,600
that it doesn't do complicated routing

00:14:21,350 --> 00:14:27,249
it basically assumes that you're you're

00:14:23,600 --> 00:14:31,399
connecting to an internet access network

00:14:27,249 --> 00:14:33,439
but so this is fairly complicated we

00:14:31,399 --> 00:14:35,509
have to build a lot of infrastructure

00:14:33,439 --> 00:14:38,319
just to do something that there's strong

00:14:35,509 --> 00:14:40,879
host model basically would do for us so

00:14:38,319 --> 00:14:44,119
we have these all these routing rules we

00:14:40,879 --> 00:14:47,299
have to shim the sockets to the netd and

00:14:44,119 --> 00:14:48,709
so there's also you fundamental

00:14:47,299 --> 00:14:51,260
limitations in this approach which

00:14:48,709 --> 00:14:53,540
aren't really necessarily a big deal

00:14:51,260 --> 00:14:56,030
in normal usage but they are sort of

00:14:53,540 --> 00:14:57,350
things that there are problems for

00:14:56,030 --> 00:14:58,850
example like the socket mark and a

00:14:57,350 --> 00:15:02,120
network is decided before the routing

00:14:58,850 --> 00:15:03,710
lookup so it's not always correct you

00:15:02,120 --> 00:15:05,510
pick a socket mark and that's basically

00:15:03,710 --> 00:15:07,490
the network that you were deciding to

00:15:05,510 --> 00:15:09,560
try to connect on but if then you match

00:15:07,490 --> 00:15:12,500
you know if you're actually connecting

00:15:09,560 --> 00:15:14,060
to the loopback address your the routing

00:15:12,500 --> 00:15:17,600
table if you actually hit is the local

00:15:14,060 --> 00:15:20,690
table which is at the top of that at the

00:15:17,600 --> 00:15:22,100
top of the list of rules so that what

00:15:20,690 --> 00:15:23,360
that means is that you can't look at a

00:15:22,100 --> 00:15:25,580
socket mark and figure out what

00:15:23,360 --> 00:15:29,090
connection or what interface that that

00:15:25,580 --> 00:15:31,580
that connection is actually it's not

00:15:29,090 --> 00:15:32,930
easy really it's not really possible to

00:15:31,580 --> 00:15:34,910
support multiple networks on the same

00:15:32,930 --> 00:15:37,340
interface we're using this bubble it's

00:15:34,910 --> 00:15:39,290
just too much there's we need a lot more

00:15:37,340 --> 00:15:41,000
help from the curl for that we need to

00:15:39,290 --> 00:15:43,400
tag IP addresses and routes with a

00:15:41,000 --> 00:15:45,110
particular network ID so the ITF is is

00:15:43,400 --> 00:15:46,790
working on the API for this they've

00:15:45,110 --> 00:15:48,260
defined an architecture which is really

00:15:46,790 --> 00:15:50,600
quite good this is a multiple versioning

00:15:48,260 --> 00:15:53,000
domain architecture RFC seven five five

00:15:50,600 --> 00:15:56,270
six what we do is pretty much based on

00:15:53,000 --> 00:15:59,390
that and Eric actually my colleague is

00:15:56,270 --> 00:16:01,490
working in the in the myth ITF myth

00:15:59,390 --> 00:16:02,810
working group to figure out what an API

00:16:01,490 --> 00:16:04,910
for selecting network should look like

00:16:02,810 --> 00:16:06,410
and once that's done we might sort of

00:16:04,910 --> 00:16:08,810
try to implement that ellipse and up

00:16:06,410 --> 00:16:10,520
screamin we do not want to try to

00:16:08,810 --> 00:16:12,020
implement major pieces of fact should I

00:16:10,520 --> 00:16:16,070
love you without an RFC behind us

00:16:12,020 --> 00:16:20,980
because it my sort of can lead to

00:16:16,070 --> 00:16:24,760
controversy so what do we do

00:16:20,980 --> 00:16:28,250
what is the stack rely on in the kernel

00:16:24,760 --> 00:16:31,160
so some of this stuff is upstream for

00:16:28,250 --> 00:16:32,810
example you know we mostly use socket

00:16:31,160 --> 00:16:34,490
marks all the time so everything that

00:16:32,810 --> 00:16:37,970
the kernel originates has a mark of zero

00:16:34,490 --> 00:16:39,890
so what how do we deal with that well

00:16:37,970 --> 00:16:41,030
fortunately most of the time that the

00:16:39,890 --> 00:16:42,710
kernel does something it's either

00:16:41,030 --> 00:16:45,170
interface specific like happy v6

00:16:42,710 --> 00:16:47,390
neighbor discovery or it's a reply to a

00:16:45,170 --> 00:16:49,280
different packet and it's a reply to a

00:16:47,390 --> 00:16:51,140
different packet you just use the same

00:16:49,280 --> 00:16:52,880
mark as the original packet and so you

00:16:51,140 --> 00:16:53,779
can use iptables to mark stuff that

00:16:52,880 --> 00:16:55,430
comes in

00:16:53,779 --> 00:16:57,139
and the colonel will just reflect that

00:16:55,430 --> 00:17:01,029
mark and say we'll go out on the same

00:16:57,139 --> 00:17:03,529
network and we there's a Siskel that we

00:17:01,029 --> 00:17:06,439
that we added with it was upstream for

00:17:03,529 --> 00:17:08,179
that incoming connections need to be

00:17:06,439 --> 00:17:09,980
bound to the right network based on

00:17:08,179 --> 00:17:12,230
where the syn packet arrived cuz an

00:17:09,980 --> 00:17:14,059
application just wants to listen to : :

00:17:12,230 --> 00:17:15,459
it doesn't want to listen to : : on a

00:17:14,059 --> 00:17:19,549
particular network

00:17:15,459 --> 00:17:22,579
so the accepts is call will write the

00:17:19,549 --> 00:17:26,000
skb mark into the socket market

00:17:22,579 --> 00:17:29,809
these are upstream since 3.15 a few

00:17:26,000 --> 00:17:31,039
things with ipv6 may be one of the major

00:17:29,809 --> 00:17:32,840
issues here is that the kernel is

00:17:31,039 --> 00:17:36,230
perfectly happy to use you know say your

00:17:32,840 --> 00:17:37,909
mobile data ipv6 address on Wi-Fi if the

00:17:36,230 --> 00:17:39,919
Wi-Fi address happens to be tentative

00:17:37,909 --> 00:17:41,960
and so during duplicate address

00:17:39,919 --> 00:17:43,909
detection or if the why of it the ipv6

00:17:41,960 --> 00:17:46,309
configuration and Wi-Fi is incomplete it

00:17:43,909 --> 00:17:47,929
has a default route but no address it'll

00:17:46,309 --> 00:17:49,520
do the wrong thing and it'll get stuck

00:17:47,929 --> 00:17:51,679
particularly if you have a DNS server on

00:17:49,520 --> 00:17:54,080
Wi-Fi you'll get terrible performance

00:17:51,679 --> 00:17:55,669
because of all the DNS resolvers falls

00:17:54,080 --> 00:17:57,530
back after 5 seconds and so on

00:17:55,669 --> 00:18:02,899
so we we have these simple Cisco tools

00:17:57,530 --> 00:18:05,179
that are tweaks the VPN uses UID based

00:18:02,899 --> 00:18:07,580
routing that's not upstream it's

00:18:05,179 --> 00:18:10,820
actually fairly simple it's it's

00:18:07,580 --> 00:18:14,570
basically you call sock no sock GI UID

00:18:10,820 --> 00:18:17,179
in a bunch of places it mostly works it

00:18:14,570 --> 00:18:19,159
falls over exactly where the xt owner

00:18:17,179 --> 00:18:20,960
module falls over which is when the

00:18:19,159 --> 00:18:22,399
socket is orphaned that has no user

00:18:20,960 --> 00:18:24,350
space socket attached to it

00:18:22,399 --> 00:18:27,320
you can't find out which you idea it was

00:18:24,350 --> 00:18:29,270
so if you're sending a fin for something

00:18:27,320 --> 00:18:30,409
that's sent to close socket that's been

00:18:29,270 --> 00:18:34,149
closed or if you're sending a reset for

00:18:30,409 --> 00:18:37,130
something that's closed it's incorrect

00:18:34,149 --> 00:18:38,690
that's sort of relatively easy you could

00:18:37,130 --> 00:18:40,700
just write back the market you could

00:18:38,690 --> 00:18:43,309
write back the UID into the into the

00:18:40,700 --> 00:18:45,590
protocol so get from the UID in the user

00:18:43,309 --> 00:18:48,169
space socket that's not hard to solve we

00:18:45,590 --> 00:18:49,909
don't solve that we're not quite sure

00:18:48,169 --> 00:18:51,710
what to do with this we could attempt to

00:18:49,909 --> 00:18:53,780
we can attempt to upstream it again

00:18:51,710 --> 00:18:55,880
given that we've been using it you know

00:18:53,780 --> 00:18:58,700
it's been quite useful you know for a

00:18:55,880 --> 00:19:00,649
couple of years one way to do this

00:18:58,700 --> 00:19:02,510
alternatively would be to have a bigger

00:19:00,649 --> 00:19:03,350
socket mark so we could stuff the UID

00:19:02,510 --> 00:19:06,559
into the socket

00:19:03,350 --> 00:19:08,750
mark are you ID is a big for historical

00:19:06,559 --> 00:19:11,630
reasons there in a hundred thousand user

00:19:08,750 --> 00:19:16,400
blocks so not even a lying on power of

00:19:11,630 --> 00:19:18,260
two boundaries it turns out but we we

00:19:16,400 --> 00:19:20,450
could try it again or we could try to I

00:19:18,260 --> 00:19:22,460
don't know we could have a 64-bit socket

00:19:20,450 --> 00:19:25,070
mark where only the bottom 32 bits make

00:19:22,460 --> 00:19:26,150
it into the SK buff we're not sure what

00:19:25,070 --> 00:19:27,980
to do with this you know feedback

00:19:26,150 --> 00:19:29,750
welcome if you have a bright idea but we

00:19:27,980 --> 00:19:31,400
do need to have different routing tables

00:19:29,750 --> 00:19:33,830
on a per app basis that's just the hard

00:19:31,400 --> 00:19:37,100
requirement we can't not do that

00:19:33,830 --> 00:19:39,830
so here's another one that did make it

00:19:37,100 --> 00:19:41,780
upstream recently we had this evil si yo

00:19:39,830 --> 00:19:44,840
si kill at our iron control since

00:19:41,780 --> 00:19:46,909
senator of 2009 which scans the TCP hash

00:19:44,840 --> 00:19:52,100
tables and closes all connections using

00:19:46,909 --> 00:19:55,159
PCP done it was full of races it you

00:19:52,100 --> 00:19:57,710
know it every time Eric changed the you

00:19:55,159 --> 00:20:00,049
changed the TCP socket structure it

00:19:57,710 --> 00:20:02,419
would crash because you know that we

00:20:00,049 --> 00:20:04,580
couldn't find you know forget what it is

00:20:02,419 --> 00:20:06,409
that we like oh we yeah we cool stuff

00:20:04,580 --> 00:20:07,789
that's not in listen self-care it's not

00:20:06,409 --> 00:20:11,480
in a time waits ok it would fall over

00:20:07,789 --> 00:20:14,330
and it's also not very flexible so we

00:20:11,480 --> 00:20:16,100
recently upstream soft destroy and you

00:20:14,330 --> 00:20:17,720
know we can now kill individual sockets

00:20:16,100 --> 00:20:20,900
which actually quite useful to do stuff

00:20:17,720 --> 00:20:22,640
like better connection closing when a

00:20:20,900 --> 00:20:23,780
VPN comes up you want the connections

00:20:22,640 --> 00:20:25,429
that are now dead in the water because

00:20:23,780 --> 00:20:26,900
everything is forced through the VPN you

00:20:25,429 --> 00:20:28,700
want those connections to stop working

00:20:26,900 --> 00:20:30,890
to be closed so that the app can

00:20:28,700 --> 00:20:32,600
reestablish them and so things like

00:20:30,890 --> 00:20:34,250
mobile they'd always on also when you

00:20:32,600 --> 00:20:36,080
want to keep mobile data up in the

00:20:34,250 --> 00:20:37,370
background but not actually use it so

00:20:36,080 --> 00:20:39,799
that you don't want the user to spend

00:20:37,370 --> 00:20:41,390
money then you can close those TCP

00:20:39,799 --> 00:20:43,460
connections and give apps that are

00:20:41,390 --> 00:20:46,340
unprivileged no access to the cell

00:20:43,460 --> 00:20:47,539
network interface right and then you can

00:20:46,340 --> 00:20:51,470
actually keep the mobile data connection

00:20:47,539 --> 00:20:53,929
always on their usage accounting this is

00:20:51,470 --> 00:20:57,530
an area that's particularly far behind

00:20:53,929 --> 00:21:01,309
upstream one of the challenges here is

00:20:57,530 --> 00:21:03,370
that it tracks it tracks bytes for every

00:21:01,309 --> 00:21:07,730
combination of UID which is an app and

00:21:03,370 --> 00:21:09,440
network interface and so it's fairly

00:21:07,730 --> 00:21:12,559
expensive to do that in terms of

00:21:09,440 --> 00:21:14,110
iptables rules and IP tables is quite

00:21:12,559 --> 00:21:16,570
hard for us to use for reasons

00:21:14,110 --> 00:21:19,480
- later but so what we do is we have

00:21:16,570 --> 00:21:21,669
this xtq tag UID module which implements

00:21:19,480 --> 00:21:25,659
64-bit socket tags and it's kind of this

00:21:21,669 --> 00:21:28,720
bolt on thing which replaces the

00:21:25,659 --> 00:21:31,390
implementation of the owner socket

00:21:28,720 --> 00:21:34,690
exists iptables module so it's literally

00:21:31,390 --> 00:21:37,149
a drop-in replacement but it does love

00:21:34,690 --> 00:21:39,250
all these things and it it publishes

00:21:37,149 --> 00:21:41,169
stats in proc and we depend on that to

00:21:39,250 --> 00:21:43,029
do data usage accounting because when

00:21:41,169 --> 00:21:44,710
users go and go to the mobile network

00:21:43,029 --> 00:21:46,990
settings and say okay which of my apps

00:21:44,710 --> 00:21:52,000
use data well that's where it comes from

00:21:46,990 --> 00:21:53,889
so so yeah I think this was before or

00:21:52,000 --> 00:21:56,380
said I'm not aware of all the state this

00:21:53,889 --> 00:21:58,090
is before our time but a discussion

00:21:56,380 --> 00:22:02,049
about streaming this a few years ago

00:21:58,090 --> 00:22:03,789
didn't really reach a conclusion the

00:22:02,049 --> 00:22:06,490
rate-limiting sorry the the bandwidth

00:22:03,789 --> 00:22:08,950
limiting relies of xt quota to module

00:22:06,490 --> 00:22:10,510
it uses an ED filter and if logs suck it

00:22:08,950 --> 00:22:12,580
for notifications which is deprecated

00:22:10,510 --> 00:22:14,500
it's just actually removed in 3.18 which

00:22:12,580 --> 00:22:18,580
were so we'll have to figure something

00:22:14,500 --> 00:22:20,350
out there and so on so by the way the

00:22:18,580 --> 00:22:25,659
versions that are in use at the moment

00:22:20,350 --> 00:22:30,460
are Nexus 6p and Nexus 5x use 310 still

00:22:25,659 --> 00:22:34,899
and the pixel C uses sweet on 18 so it's

00:22:30,460 --> 00:22:36,760
slightly in Europe but it's fairly

00:22:34,899 --> 00:22:39,700
ancient versions from the perspective of

00:22:36,760 --> 00:22:41,860
this graph and of course we everything

00:22:39,700 --> 00:22:43,360
that we upstream we back port it and we

00:22:41,860 --> 00:22:44,950
have the unit test for it and so on

00:22:43,360 --> 00:22:47,559
because we onion 20 different branches

00:22:44,950 --> 00:22:49,289
and so we have we have we were lying in

00:22:47,559 --> 00:22:53,470
a test to tell us what's in there or not

00:22:49,289 --> 00:22:56,799
okay so on growing challenges well we

00:22:53,470 --> 00:22:58,179
have to do this properly problem of our

00:22:56,799 --> 00:22:59,850
own making of course you know there's

00:22:58,179 --> 00:23:02,190
the lots of backporting now the

00:22:59,850 --> 00:23:03,419
problem the hair is that the that the

00:23:02,190 --> 00:23:06,929
kernel versions they're used for

00:23:03,419 --> 00:23:09,860
particular SOC are really determined by

00:23:06,929 --> 00:23:14,490
the SOC vendor when that SOC ships and

00:23:09,860 --> 00:23:19,799
it does not get updated and I don't know

00:23:14,490 --> 00:23:21,090
why this is and it is sort of there is

00:23:19,799 --> 00:23:23,010
something that can be done to bring them

00:23:21,090 --> 00:23:25,440
a little bit more closer to reality but

00:23:23,010 --> 00:23:27,270
the support multitude to actual new

00:23:25,440 --> 00:23:31,740
kernels but the support model for these

00:23:27,270 --> 00:23:33,750
is is as I understand it there is a

00:23:31,740 --> 00:23:37,230
distinction between pre-sales support

00:23:33,750 --> 00:23:39,179
and post sales support and you know it's

00:23:37,230 --> 00:23:42,510
a sort of that associate vendor business

00:23:39,179 --> 00:23:44,159
bubble and they are not necessarily

00:23:42,510 --> 00:23:45,840
other OEMs as well you know if you look

00:23:44,159 --> 00:23:48,510
at the Android ecosystem they're not as

00:23:45,840 --> 00:23:50,669
sort of excited about let's say like

00:23:48,510 --> 00:23:52,500
Google and Nexus devices about upgrading

00:23:50,669 --> 00:23:56,640
software in the fields there's not so

00:23:52,500 --> 00:23:58,620
much of that you know it's not a it's

00:23:56,640 --> 00:24:02,610
not necessarily very appreciated by OEMs

00:23:58,620 --> 00:24:04,440
and SOC vendors so that's an ongoing

00:24:02,610 --> 00:24:05,909
challenge we're gonna try to make some

00:24:04,440 --> 00:24:07,440
headway we do try to back port

00:24:05,909 --> 00:24:09,200
everything so eventually we won't have

00:24:07,440 --> 00:24:12,750
to carry these outlook free patches

00:24:09,200 --> 00:24:14,850
iptables rules so iptables is a is a

00:24:12,750 --> 00:24:16,559
funny thing right we we basically for

00:24:14,850 --> 00:24:18,840
connect sec IP tables that's our api

00:24:16,559 --> 00:24:21,780
because there's no real kernel API it's

00:24:18,840 --> 00:24:23,250
it's sort of very there's rulings all

00:24:21,780 --> 00:24:25,169
over the place do not use this this is

00:24:23,250 --> 00:24:26,760
on I've API use the by PT instead well

00:24:25,169 --> 00:24:29,820
we can't link to live by PT cuz we're

00:24:26,760 --> 00:24:31,169
Apache licensed and live by PT is GPL so

00:24:29,820 --> 00:24:32,610
it's not like we're trying to do

00:24:31,169 --> 00:24:34,500
something proprietary it's just that the

00:24:32,610 --> 00:24:37,409
licenses aren't compatible so we're

00:24:34,500 --> 00:24:39,900
basically four can exact and because

00:24:37,409 --> 00:24:42,299
iptables grabs the LOC looks at all the

00:24:39,900 --> 00:24:43,860
rule bases rule databases which can be

00:24:42,299 --> 00:24:45,990
quite longer than right it takes all the

00:24:43,860 --> 00:24:49,320
rules that twelve Turtles the bits in

00:24:45,990 --> 00:24:51,210
memory and it writes them back it takes

00:24:49,320 --> 00:24:52,559
you know 30 to 50 milliseconds and we

00:24:51,210 --> 00:24:54,480
have all these things where when the

00:24:52,559 --> 00:24:56,190
user turns off background data we have

00:24:54,480 --> 00:24:57,990
to update all the rules and so we sit

00:24:56,190 --> 00:24:59,669
there for I don't know a few seconds

00:24:57,990 --> 00:25:02,190
doing fork and exec you IP tables in a

00:24:59,669 --> 00:25:04,289
loop and that's how it's done and on

00:25:02,190 --> 00:25:06,390
boot - we have you know a couple of

00:25:04,289 --> 00:25:08,460
seconds if you sit there I pee tables

00:25:06,390 --> 00:25:10,259
rules you know so

00:25:08,460 --> 00:25:12,690
we can sort of do something about that

00:25:10,259 --> 00:25:15,960
move 20 tables restore but you know and

00:25:12,690 --> 00:25:18,570
eventually we can my understanding is

00:25:15,960 --> 00:25:19,860
that n F tables is better faster to

00:25:18,570 --> 00:25:22,619
update but of course when you're running

00:25:19,860 --> 00:25:25,769
3.10 and if tables and is in the future

00:25:22,619 --> 00:25:28,230
for you so but any in general anything

00:25:25,769 --> 00:25:31,110
that doesn't have a kernel API and a GPL

00:25:28,230 --> 00:25:34,799
only user space API is hard for us to

00:25:31,110 --> 00:25:36,299
use because of the licensing issues what

00:25:34,799 --> 00:25:39,869
we're looking for what we're looking at

00:25:36,299 --> 00:25:43,289
now and this is sadly not good news for

00:25:39,869 --> 00:25:45,720
this crowd still is that we because of

00:25:43,289 --> 00:25:47,879
the power issues when you wake up the

00:25:45,720 --> 00:25:52,019
main CPU you're spending 250

00:25:47,879 --> 00:25:54,840
milliseconds for 204 200 250 milliamps

00:25:52,019 --> 00:25:58,919
or 200 milliseconds it's very expensive

00:25:54,840 --> 00:26:00,990
and so even if you're basically all you

00:25:58,919 --> 00:26:03,720
do is you turn around and you you fire

00:26:00,990 --> 00:26:06,450
up the CPU and you and you drop the

00:26:03,720 --> 00:26:08,879
packet you've spent whatever a 0.01

00:26:06,450 --> 00:26:10,710
floor milliamp hours and so if the

00:26:08,879 --> 00:26:12,360
network you're on likes to send you ipv6

00:26:10,710 --> 00:26:14,129
ruber advertisements every three seconds

00:26:12,360 --> 00:26:18,690
you're toast right your battery will

00:26:14,129 --> 00:26:20,820
last a few hours and so what we're doing

00:26:18,690 --> 00:26:23,279
is we're basically gonna push these

00:26:20,820 --> 00:26:25,769
filters down into the hardware but we

00:26:23,279 --> 00:26:27,360
can't really use the kernel api's that I

00:26:25,769 --> 00:26:29,639
know are being discussed now because

00:26:27,360 --> 00:26:31,169
we're so far behind upstream so what

00:26:29,639 --> 00:26:33,389
we're doing is we're gonna use the

00:26:31,169 --> 00:26:35,399
chipset Howell's to push these filters

00:26:33,389 --> 00:26:37,169
down we define our own filtering

00:26:35,399 --> 00:26:41,070
language because BPF instructions are so

00:26:37,169 --> 00:26:43,559
big 8 bytes the Wi-Fi chips that has 2k

00:26:41,070 --> 00:26:44,779
of memory that we can use and so you

00:26:43,559 --> 00:26:46,679
know it's sort of not necessarily

00:26:44,779 --> 00:26:49,980
certainly not what you would use to

00:26:46,679 --> 00:26:51,570
build a Linux switch on so and also

00:26:49,980 --> 00:26:53,730
there's some keepalive offloading we'd

00:26:51,570 --> 00:26:55,710
like to do TCP keeper lives not sure how

00:26:53,730 --> 00:26:56,879
to do that yet I think TCP repair might

00:26:55,710 --> 00:26:58,860
do what we want because we need the

00:26:56,879 --> 00:27:01,630
sequence number to generate a TCP packet

00:26:58,860 --> 00:27:03,790
but I haven't looked at that yet

00:27:01,630 --> 00:27:06,730
so that was yeah that was pretty much

00:27:03,790 --> 00:27:08,230
what I had you know happy to take

00:27:06,730 --> 00:27:10,150
questions here happy to take questions

00:27:08,230 --> 00:27:16,140
anywhere find me I'm in a red zone of

00:27:10,150 --> 00:27:16,140
red Android jacket feedback welcome

00:27:16,559 --> 00:27:33,130
okay that's anyone have any question

00:27:18,730 --> 00:27:34,870
yeah wait wait wait as far as many of

00:27:33,130 --> 00:27:36,429
these api is including that filtering

00:27:34,870 --> 00:27:36,940
api is concerned and we can talk about

00:27:36,429 --> 00:27:42,280
it tomorrow

00:27:36,940 --> 00:27:46,350
also dude is there any any reason to go

00:27:42,280 --> 00:27:48,940
with kind of what you said a proprietary

00:27:46,350 --> 00:27:50,799
interface rather than designing an

00:27:48,940 --> 00:27:52,840
upstream interface and and then back

00:27:50,799 --> 00:27:54,490
porting that in some way even if that

00:27:52,840 --> 00:27:56,290
means adding it as a proprietary

00:27:54,490 --> 00:27:59,140
interface for instance here you could

00:27:56,290 --> 00:28:01,059
say hey you know what we can't use BPF

00:27:59,140 --> 00:28:02,559
on the chip right but we could use BPF

00:28:01,059 --> 00:28:05,530
to configure it and then have the driver

00:28:02,559 --> 00:28:07,330
or some mid layer actually go and get it

00:28:05,530 --> 00:28:09,790
into the hardware right rather than

00:28:07,330 --> 00:28:12,700
ditching it into what we do now we did

00:28:09,790 --> 00:28:13,990
it into x86 or MIPS or whatever

00:28:12,700 --> 00:28:15,250
instructions right we could say hey

00:28:13,990 --> 00:28:17,640
we'll get it into the hardware

00:28:15,250 --> 00:28:19,870
interpreter and make it smarter that way

00:28:17,640 --> 00:28:22,030
because then we avoid having all these

00:28:19,870 --> 00:28:23,470
you know here's a new API that Android

00:28:22,030 --> 00:28:25,000
is going to use and then androids gonna

00:28:23,470 --> 00:28:27,220
use it for two years and then it's going

00:28:25,000 --> 00:28:29,820
to go away because hey we decided we

00:28:27,220 --> 00:28:32,830
need this other new cool feature right I

00:28:29,820 --> 00:28:34,690
think I think the reality is that given

00:28:32,830 --> 00:28:36,309
how far we are behind upstream if we

00:28:34,690 --> 00:28:38,679
only use any sort of major functionality

00:28:36,309 --> 00:28:40,720
that you guys are developing now I mean

00:28:38,679 --> 00:28:42,160
that the cherry-picks are it's basically

00:28:40,720 --> 00:28:44,860
impossible to use it in the field

00:28:42,160 --> 00:28:50,140
because no I agree I mean I'm not saying

00:28:44,860 --> 00:28:52,120
that youyou we should we should get like

00:28:50,140 --> 00:28:53,740
all the same API and we cherry pick the

00:28:52,120 --> 00:28:56,110
code and whatever right but I'm saying

00:28:53,740 --> 00:28:58,120
like if we can at least converge as far

00:28:56,110 --> 00:29:00,610
as what the API is doing is concerned

00:28:58,120 --> 00:29:02,799
then sure we might back for that and we

00:29:00,610 --> 00:29:05,320
as a vendor might have to pack for that

00:29:02,799 --> 00:29:07,780
as some vendor API or something right

00:29:05,320 --> 00:29:09,490
that's specific but then if we move

00:29:07,780 --> 00:29:11,320
forward once we once we start moving

00:29:09,490 --> 00:29:12,230
forward we start moving this all into

00:29:11,320 --> 00:29:14,690
mainline

00:29:12,230 --> 00:29:16,669
it should become some some more generic

00:29:14,690 --> 00:29:18,980
API or should become some more central

00:29:16,669 --> 00:29:20,510
API not be a vendor specific API right

00:29:18,980 --> 00:29:23,030
but then if we kind of start

00:29:20,510 --> 00:29:25,100
standardizing on this API first and then

00:29:23,030 --> 00:29:26,570
we just say okay now let's see how how

00:29:25,100 --> 00:29:28,250
do we back port this okay this might be

00:29:26,570 --> 00:29:30,200
ugly right back porting it will not be

00:29:28,250 --> 00:29:33,230
trivial we might back wear it as a

00:29:30,200 --> 00:29:35,090
completely separate API but at least as

00:29:33,230 --> 00:29:36,650
far as the semantics of it are concerned

00:29:35,090 --> 00:29:39,320
we've kind of defined them upstream

00:29:36,650 --> 00:29:41,960
already right and the the contain the

00:29:39,320 --> 00:29:43,520
the semantics and what what we're

00:29:41,960 --> 00:29:45,049
transporting as far as the data the

00:29:43,520 --> 00:29:48,200
filter is in this case whatever is

00:29:45,049 --> 00:29:50,120
concerned right I mean my to be honest

00:29:48,200 --> 00:29:51,620
my my hope is that this community will

00:29:50,120 --> 00:29:53,090
come up with an API that we'll be able

00:29:51,620 --> 00:29:54,440
to use in three years and we'll just

00:29:53,090 --> 00:29:57,260
throw away what we have the moment

00:29:54,440 --> 00:30:01,850
that's that's really part of it part of

00:29:57,260 --> 00:30:03,169
the challenge here is that we make until

00:30:01,850 --> 00:30:06,679
it's something that's well understood in

00:30:03,169 --> 00:30:08,270
the standard we are actually providing

00:30:06,679 --> 00:30:11,330
the filtering engine and asking the

00:30:08,270 --> 00:30:13,429
firmware manufacturers to run it so we

00:30:11,330 --> 00:30:16,669
have some C code and say don't you just

00:30:13,429 --> 00:30:19,010
take the C code don't touch it run it on

00:30:16,669 --> 00:30:23,900
your firmware or did it you know run it

00:30:19,010 --> 00:30:25,880
and it well so the code is very far away

00:30:23,900 --> 00:30:27,440
that could the code for the hardware

00:30:25,880 --> 00:30:29,750
abstraction layers is very far away from

00:30:27,440 --> 00:30:32,870
the kernel it's all sorts of code

00:30:29,750 --> 00:30:34,400
management concerns it's not but but my

00:30:32,870 --> 00:30:35,750
hope is Inc one when this thing is

00:30:34,400 --> 00:30:37,130
actually part of mainline we will

00:30:35,750 --> 00:30:38,510
actually switch to use but that's that's

00:30:37,130 --> 00:30:40,370
the thing right it's not never going to

00:30:38,510 --> 00:30:42,970
be part of mainline if you're if no

00:30:40,370 --> 00:30:46,669
one's pushing it right so you know if we

00:30:42,970 --> 00:30:48,500
as a vendor we would say hey you know no

00:30:46,669 --> 00:30:50,750
we have to add this engine to our chip

00:30:48,500 --> 00:30:52,190
to support Google but in some ways in my

00:30:50,750 --> 00:30:54,350
car should be a lot easier if Google

00:30:52,190 --> 00:30:56,540
works if the Android user space were to

00:30:54,350 --> 00:30:57,890
give us a BPS program and we would say

00:30:56,540 --> 00:31:00,169
hey we you know we don't have to run

00:30:57,890 --> 00:31:02,210
your filtering engine we can take this

00:31:00,169 --> 00:31:05,450
BPF program and jet it compile it

00:31:02,210 --> 00:31:07,850
optimize it for our device as it's more

00:31:05,450 --> 00:31:10,309
with the small JIT interpreter like the

00:31:07,850 --> 00:31:12,200
x86 JIT I mean our chip isn't running

00:31:10,309 --> 00:31:13,730
x86 obviously but you know it's

00:31:12,200 --> 00:31:17,780
different in some cpu so we could take

00:31:13,730 --> 00:31:21,590
BPF validate it get it into our native

00:31:17,780 --> 00:31:23,570
code or even you know some some engine

00:31:21,590 --> 00:31:25,200
code and then I think to the device and

00:31:23,570 --> 00:31:27,660
that would give a get us to

00:31:25,200 --> 00:31:29,250
ok so now we've got all the api's it's

00:31:27,660 --> 00:31:31,680
already standard right it's a standard

00:31:29,250 --> 00:31:33,540
vpf API that we have upstream we just

00:31:31,680 --> 00:31:35,790
have to tie it to the right device into

00:31:33,540 --> 00:31:37,770
the right filters and then we don't come

00:31:35,790 --> 00:31:39,300
up with the whole new way of hey you

00:31:37,770 --> 00:31:41,370
know if you've got this little filter

00:31:39,300 --> 00:31:43,770
engine blob that only runs on this

00:31:41,370 --> 00:31:46,800
filter engine that google c code wrote

00:31:43,770 --> 00:31:48,800
that someone at google wrote that you

00:31:46,800 --> 00:31:52,200
don't have to run inside your chip and

00:31:48,800 --> 00:31:53,790
you've got your your your much closer to

00:31:52,200 --> 00:31:55,740
actually having something that could go

00:31:53,790 --> 00:31:57,420
upstream right because this is never

00:31:55,740 --> 00:31:58,950
going to go upstream that way right i

00:31:57,420 --> 00:32:01,110
mean no one else is gonna implement that

00:31:58,950 --> 00:32:03,750
if they're not forced to work in android

00:32:01,110 --> 00:32:09,720
ok so then i mean part of the part of

00:32:03,750 --> 00:32:14,640
the issue is this stuff runs on vendors

00:32:09,720 --> 00:32:18,000
that have very low margins and so it has

00:32:14,640 --> 00:32:20,040
to be very accessible in terms of you

00:32:18,000 --> 00:32:21,660
know how much work it is to implement so

00:32:20,040 --> 00:32:22,980
everybody you don't give them the exact

00:32:21,660 --> 00:32:24,660
same filter engine that you were

00:32:22,980 --> 00:32:26,820
speaking about and say hey you know i've

00:32:24,660 --> 00:32:29,280
also got this JIT that takes BPF and

00:32:26,820 --> 00:32:31,830
translate it into that filter engine so

00:32:29,280 --> 00:32:34,350
if you're doing the lowest cost we have

00:32:31,830 --> 00:32:36,960
a BP f-22 a PF translator of course

00:32:34,350 --> 00:32:39,300
right if you take that and you stick it

00:32:36,960 --> 00:32:40,950
into the kernel you say hey you know you

00:32:39,300 --> 00:32:43,170
we have I mean I don't know how they do

00:32:40,950 --> 00:32:46,050
whatever right but it's not going to be

00:32:43,170 --> 00:32:48,330
a massive amount of code so if you take

00:32:46,050 --> 00:32:49,650
on a baby that's not the monopolize if

00:32:48,330 --> 00:32:52,320
there any other questions maybe you

00:32:49,650 --> 00:33:02,190
should take this one I mean we should

00:32:52,320 --> 00:33:05,210
or we can cycles yeah yeah yeah so I

00:33:02,190 --> 00:33:05,210
need a push thing

00:33:10,920 --> 00:33:16,800
you said something about ipv6 dad and

00:33:13,650 --> 00:33:18,300
how that collides with the fault route

00:33:16,800 --> 00:33:19,740
selection any elaborate I mean I don't

00:33:18,300 --> 00:33:21,450
see the connection he said because you

00:33:19,740 --> 00:33:27,390
use a source based address the route

00:33:21,450 --> 00:33:29,430
selection or something I wouldn't say

00:33:27,390 --> 00:33:32,040
there's a conflict I think the the

00:33:29,430 --> 00:33:33,510
architecture is very much shaped one of

00:33:32,040 --> 00:33:36,780
the things that shapes the architecture

00:33:33,510 --> 00:33:39,540
is the fact that ipv6 is important and

00:33:36,780 --> 00:33:41,250
it has multiple addresses and it uses

00:33:39,540 --> 00:33:44,670
the weak host bubble and the addresses

00:33:41,250 --> 00:33:47,460
can change at any time those are sorry

00:33:44,670 --> 00:33:48,990
what does that have to do with that dad

00:33:47,460 --> 00:33:51,800
is just saying I have a unique address

00:33:48,990 --> 00:33:54,690
Oh dad like duplicated reservations Oh

00:33:51,800 --> 00:33:56,280
easy when when you're doing dad your des

00:33:54,690 --> 00:33:58,500
is transitive and it's deep referred

00:33:56,280 --> 00:34:00,600
with respect to everything so a vanilla

00:33:58,500 --> 00:34:02,550
stack will use the address on the wrong

00:34:00,600 --> 00:34:05,040
interface over the address that you're

00:34:02,550 --> 00:34:10,919
using dad for so this is why we upstream

00:34:05,040 --> 00:34:12,690
the I forget where it is no you just

00:34:10,919 --> 00:34:14,220
have to embrace it and use it properly

00:34:12,690 --> 00:34:16,230
you used to have to make sure that when

00:34:14,220 --> 00:34:18,120
it's doing dad you'll you won't use the

00:34:16,230 --> 00:34:22,800
address on the wrong interface now our

00:34:18,120 --> 00:34:25,649
c6 724 was written our c6 724 actually

00:34:22,800 --> 00:34:27,179
recommends the strong host Buttle RFC

00:34:25,649 --> 00:34:29,940
but the kernel implementation over six

00:34:27,179 --> 00:34:32,460
724 you're saying that default route

00:34:29,940 --> 00:34:33,870
would be selected based on a non

00:34:32,460 --> 00:34:36,179
tentative address and that's the problem

00:34:33,870 --> 00:34:38,100
the default route is selected using the

00:34:36,179 --> 00:34:40,800
routing table and then source address

00:34:38,100 --> 00:34:42,390
selection runs and it doesn't one of the

00:34:40,800 --> 00:34:44,370
parameters where you choose the source

00:34:42,390 --> 00:34:45,810
address is which interface you're going

00:34:44,370 --> 00:34:47,610
to send out the packet it's not the

00:34:45,810 --> 00:34:49,110
highest priority parameter so if there

00:34:47,610 --> 00:34:51,270
are other things like oh this address is

00:34:49,110 --> 00:34:53,220
tentative I can't use it that wins the

00:34:51,270 --> 00:34:55,409
other question was you said binary

00:34:53,220 --> 00:34:58,620
device is not acceptable the packet

00:34:55,409 --> 00:34:59,940
invoice fine you can't use so binary

00:34:58,620 --> 00:35:07,350
device because the network might have

00:34:59,940 --> 00:35:10,140
more than one interface so binary

00:35:07,350 --> 00:35:11,730
devices your main mechanism you don't we

00:35:10,140 --> 00:35:13,560
didn't want to buy we didn't want to

00:35:11,730 --> 00:35:15,940
strongly tie one

00:35:13,560 --> 00:35:17,650
interfaces and networks because you

00:35:15,940 --> 00:35:19,210
might want to have a network that's

00:35:17,650 --> 00:35:20,650
two-headed for example when you have a

00:35:19,210 --> 00:35:22,960
carry network that also does carry a

00:35:20,650 --> 00:35:25,720
Wi-Fi you have the same IP address but

00:35:22,960 --> 00:35:27,190
we do if you do use so bind advise if

00:35:25,720 --> 00:35:29,350
your route which are not on Android

00:35:27,190 --> 00:35:32,020
usually it does work because we have

00:35:29,350 --> 00:35:33,880
rules that select the OEF parameter in

00:35:32,020 --> 00:35:38,770
the flow lookup and they select the

00:35:33,880 --> 00:35:41,410
right network I'm sorry but we don't

00:35:38,770 --> 00:35:44,980
have more time for this talk tomorrow we

00:35:41,410 --> 00:35:47,170
have a full track for the Linux wireless

00:35:44,980 --> 00:35:48,880
board shop where people can join to

00:35:47,170 --> 00:35:53,940
discuss all these problems and fix

00:35:48,880 --> 00:35:53,940

YouTube URL: https://www.youtube.com/watch?v=dMp21rAp9Hw


