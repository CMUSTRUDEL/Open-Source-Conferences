Title: Netdev 1.1 - HW High-Availability and Link Aggregation for Ethernet switch and NIC RDMA...
Publication date: 2016-03-10
Playlist: Netdev 1.1 - Day 1 - Wednesday February 10, 2016
Description: 
	Full title: "HW High-Availability and Link Aggregation for Ethernet switch and NIC RDMA using Linux bonding/team"
Or Gerlitz, Tzahi Oved
February 2016
Captions: 
	00:00:04,040 --> 00:00:09,870
okay I hi everybody it's a fee in myself

00:00:06,870 --> 00:00:12,450
I'm mellanox and we'll be talking about

00:00:09,870 --> 00:00:14,400
high availability how do you use Linux

00:00:12,450 --> 00:00:19,140
existing high availability mechanism to

00:00:14,400 --> 00:00:21,359
control traffic which is actually either

00:00:19,140 --> 00:00:23,490
totally or halfway offloaded from the

00:00:21,359 --> 00:00:26,099
colonel so you want to use existing

00:00:23,490 --> 00:00:28,109
mechanism to influence traffic which

00:00:26,099 --> 00:00:30,539
does not pass through the colonel and

00:00:28,109 --> 00:00:34,110
we'll use a few examples one of physical

00:00:30,539 --> 00:00:41,399
switch and one of the major effect and

00:00:34,110 --> 00:00:42,719
another one for SRV so just small

00:00:41,399 --> 00:00:44,850
background this audience I guess

00:00:42,719 --> 00:00:46,800
everybody knows and the colonel does the

00:00:44,850 --> 00:00:48,600
bonding mechanism which is I'm sure it

00:00:46,800 --> 00:00:51,270
was into dot for maybe even before into

00:00:48,600 --> 00:00:53,820
the to Colonel it's a legacy driver and

00:00:51,270 --> 00:00:58,289
in Colonel 323 jury which is here

00:00:53,820 --> 00:01:01,680
introduce the team driver hi so but both

00:00:58,289 --> 00:01:03,660
those drivers they would expose us what

00:01:01,680 --> 00:01:06,060
we call a software device or virtually

00:01:03,660 --> 00:01:07,590
device that control other near devices

00:01:06,060 --> 00:01:11,430
and applies the high availability on

00:01:07,590 --> 00:01:12,930
them and in the in the kernel shall go

00:01:11,430 --> 00:01:16,830
on in the napkins are going we call them

00:01:12,930 --> 00:01:18,540
upper devices and the load and the other

00:01:16,830 --> 00:01:20,700
devices are called Laura devices i

00:01:18,540 --> 00:01:22,170
personally also prefer because it's more

00:01:20,700 --> 00:01:25,409
politically correct and master and slave

00:01:22,170 --> 00:01:28,439
I don't want to use the word slave which

00:01:25,409 --> 00:01:31,310
is not funny it does rather typically

00:01:28,439 --> 00:01:35,100
have different mode of operation either

00:01:31,310 --> 00:01:38,210
only high availability or also load

00:01:35,100 --> 00:01:41,490
balancing and of course the I Triple E

00:01:38,210 --> 00:01:45,180
lacp lag is supported and this is maybe

00:01:41,490 --> 00:01:47,070
the most general an interesting case as

00:01:45,180 --> 00:01:51,659
I said bonding is legacy and tim is more

00:01:47,070 --> 00:01:54,540
is newer the team driver is more modular

00:01:51,659 --> 00:01:58,110
and flexible you can easily extend it

00:01:54,540 --> 00:02:01,610
and also the state machine is managing

00:01:58,110 --> 00:02:04,500
user space so there is a demon librarian

00:02:01,610 --> 00:02:06,780
but they both they are both used in the

00:02:04,500 --> 00:02:08,490
kernel and also the mechanism will

00:02:06,780 --> 00:02:11,970
introduce will

00:02:08,490 --> 00:02:16,920
today the notifiers were recently also

00:02:11,970 --> 00:02:19,800
enhanced by jiri that you could use the

00:02:16,920 --> 00:02:21,390
framework we are proposing we're showing

00:02:19,800 --> 00:02:22,800
today would work for both of them it's

00:02:21,390 --> 00:02:30,360
not that you have to have your right to

00:02:22,800 --> 00:02:32,160
write your code to one of them so so

00:02:30,360 --> 00:02:34,860
what we are trying to talk on today so

00:02:32,160 --> 00:02:37,050
so again the idea that you have net

00:02:34,860 --> 00:02:41,910
devices and you would configure bonding

00:02:37,050 --> 00:02:43,770
or teaming on them and then the state

00:02:41,910 --> 00:02:45,540
machine of linux or bond will determine

00:02:43,770 --> 00:02:47,010
how the traffic goes either the lacp

00:02:45,540 --> 00:02:48,780
state machine or the bonding testing

00:02:47,010 --> 00:02:50,790
machine but then it would influence

00:02:48,780 --> 00:02:53,460
traffic that does not pass for the

00:02:50,790 --> 00:02:55,740
colonel networking stack so what what

00:02:53,460 --> 00:02:58,740
type of traffic is that a natural

00:02:55,740 --> 00:03:00,390
example is a physical switch where the

00:02:58,740 --> 00:03:02,100
recently introduced which the framework

00:03:00,390 --> 00:03:04,760
would would under this framework it's

00:03:02,100 --> 00:03:07,230
each part of the switch is a net device

00:03:04,760 --> 00:03:08,460
and if you're only using slow path of

00:03:07,230 --> 00:03:09,780
course the traffic goes to the colonel

00:03:08,460 --> 00:03:12,000
but at some point let's say you build a

00:03:09,780 --> 00:03:13,440
linux bridge once on top of that and at

00:03:12,000 --> 00:03:15,930
that point the traffic starts to be

00:03:13,440 --> 00:03:17,880
offloaded now you want to naturally you

00:03:15,930 --> 00:03:19,380
would like to about to build a log of

00:03:17,880 --> 00:03:21,180
two or more parts of the switch so how

00:03:19,380 --> 00:03:22,740
would you do that each part is

00:03:21,180 --> 00:03:25,110
represented as a net device as I said

00:03:22,740 --> 00:03:26,940
you do bonding and then this bonding is

00:03:25,110 --> 00:03:28,680
reflected into the hardware that's

00:03:26,940 --> 00:03:31,860
that's the first okay that's the first

00:03:28,680 --> 00:03:35,490
example for 100 gigabit switch the

00:03:31,860 --> 00:03:37,980
mellanox emily them mlx SW a driver and

00:03:35,490 --> 00:03:40,500
this solution for bonding for teaming

00:03:37,980 --> 00:03:42,240
and lag is up striven four to five the

00:03:40,500 --> 00:03:45,480
second year is the second and the third

00:03:42,240 --> 00:03:48,720
use case our phone Nick a 40 gigaba can

00:03:45,480 --> 00:03:50,640
coming soon 100 give its Nick so of

00:03:48,720 --> 00:03:54,150
course in the Nick if each part of the

00:03:50,640 --> 00:03:57,270
nick is isn't it is a device as well and

00:03:54,150 --> 00:03:59,460
you have this audio my stock where there

00:03:57,270 --> 00:04:01,020
are DMA traffic I'll explain later a bit

00:03:59,460 --> 00:04:02,490
what is are they made for the native

00:04:01,020 --> 00:04:04,980
audience some people not familiar with

00:04:02,490 --> 00:04:07,470
that so when you open it all the amazed

00:04:04,980 --> 00:04:09,300
section the control plane of the atom a

00:04:07,470 --> 00:04:10,490
stack does use the network stack for

00:04:09,300 --> 00:04:12,740
stuff like local

00:04:10,490 --> 00:04:14,000
look up an address resolution but once

00:04:12,740 --> 00:04:16,130
you establish the ultimate connection

00:04:14,000 --> 00:04:17,810
it's offloaded now you want this

00:04:16,130 --> 00:04:20,750
offloaded connection to be highly

00:04:17,810 --> 00:04:24,560
available under the Linux networking

00:04:20,750 --> 00:04:27,560
stack we'll see how this is done so so

00:04:24,560 --> 00:04:31,580
this is a this is one case when you bond

00:04:27,560 --> 00:04:33,110
two parts of the of the nick in the

00:04:31,580 --> 00:04:34,400
networking stack and you open an audio

00:04:33,110 --> 00:04:36,920
may section and this audience may

00:04:34,400 --> 00:04:39,410
session become slightly available this

00:04:36,920 --> 00:04:41,210
is one thing and the other thing is sr

00:04:39,410 --> 00:04:43,550
and this is upstream with them Alex

00:04:41,210 --> 00:04:47,480
programming in photo 0 and the other use

00:04:43,550 --> 00:04:49,820
case is sr IOV you would like to expose

00:04:47,480 --> 00:04:52,520
an interface to a virtual machine which

00:04:49,820 --> 00:04:54,290
is only also highly available but it

00:04:52,520 --> 00:04:55,910
should be transparent to them like you

00:04:54,290 --> 00:04:57,560
don't want them to run any bonding or

00:04:55,910 --> 00:05:02,090
teaming or something you want to do

00:04:57,560 --> 00:05:04,130
something on the hypervisor that that in

00:05:02,090 --> 00:05:06,200
a way the pot you give them is a virtual

00:05:04,130 --> 00:05:08,360
port so they are not affiliated

00:05:06,200 --> 00:05:10,640
necessary with fault one or two of the

00:05:08,360 --> 00:05:12,200
nic you want them to run the traffic and

00:05:10,640 --> 00:05:13,550
don't current and their traffic can be

00:05:12,200 --> 00:05:15,740
of course the plane internet and also

00:05:13,550 --> 00:05:18,650
how do you may ok and this is also

00:05:15,740 --> 00:05:21,500
abstain in ml x 4 ways for that five and

00:05:18,650 --> 00:05:25,580
this is the 40 gig work we did with mlx

00:05:21,500 --> 00:05:27,140
form and the next the next on the line

00:05:25,580 --> 00:05:29,150
what sake will explain later and show

00:05:27,140 --> 00:05:31,940
the architecture is for the ml x 52 over

00:05:29,150 --> 00:05:34,280
100 gigabit and this is hopefully coming

00:05:31,940 --> 00:05:35,510
soon so that's that's a slide of the

00:05:34,280 --> 00:05:38,690
motivation what we are trying to show

00:05:35,510 --> 00:05:40,370
today ok so let's start with the Sun

00:05:38,690 --> 00:05:42,470
background there is a mechanism called

00:05:40,370 --> 00:05:46,430
the network notifiers which is used for

00:05:42,470 --> 00:05:49,010
this to implement that so the not the

00:05:46,430 --> 00:05:51,380
network notifier is a is a notification

00:05:49,010 --> 00:05:54,380
which is sent to subscribe consumers in

00:05:51,380 --> 00:05:57,050
the stack on a change which is either

00:05:54,380 --> 00:05:59,300
going to happen soon or just happened it

00:05:57,050 --> 00:06:00,950
it's not only about the tech it's just

00:05:59,300 --> 00:06:02,840
it's a change which either is going to

00:06:00,950 --> 00:06:05,480
happen soon or it happened you'll see

00:06:02,840 --> 00:06:07,760
why we need both of them the

00:06:05,480 --> 00:06:09,530
notification contains what's going to

00:06:07,760 --> 00:06:11,750
happen like there's a type of event and

00:06:09,530 --> 00:06:14,720
the affected parties for instance in the

00:06:11,750 --> 00:06:17,120
in this case you would tell you will

00:06:14,720 --> 00:06:19,150
tell the lower device hey your upper is

00:06:17,120 --> 00:06:20,720
going to change and this is your appt ok

00:06:19,150 --> 00:06:24,260
order

00:06:20,720 --> 00:06:26,000
has been changed in this is Europe so

00:06:24,260 --> 00:06:27,500
the relevant notification voted a

00:06:26,000 --> 00:06:29,510
discussion is something called three

00:06:27,500 --> 00:06:32,390
change upper which means your upper is

00:06:29,510 --> 00:06:35,570
going to be changed soon or change upper

00:06:32,390 --> 00:06:39,110
between your upper has been changed the

00:06:35,570 --> 00:06:43,940
driver can let's see how do you use that

00:06:39,110 --> 00:06:47,570
in our case you know how there is a is

00:06:43,940 --> 00:06:50,900
an is not unlimited so some

00:06:47,570 --> 00:06:52,400
configuration doesn't make sense so the

00:06:50,900 --> 00:06:53,690
driver of the hardwood driver went to

00:06:52,400 --> 00:06:56,060
get the preach and Java a notification

00:06:53,690 --> 00:06:58,880
there can refuse that the case say hey

00:06:56,060 --> 00:07:01,940
we don't support it so the user space

00:06:58,880 --> 00:07:03,890
operation will fail or they can say okay

00:07:01,940 --> 00:07:05,630
we're fine with that so that's the

00:07:03,890 --> 00:07:08,690
preaching Japan notification and then

00:07:05,630 --> 00:07:10,880
comes the change is wired and there's a

00:07:08,690 --> 00:07:13,580
second notification hey you're you're

00:07:10,880 --> 00:07:15,410
now part of the lag so you have to

00:07:13,580 --> 00:07:17,720
configure hardware right because you

00:07:15,410 --> 00:07:22,130
want the hardware to actually start

00:07:17,720 --> 00:07:23,930
performing in this lag okay let's see

00:07:22,130 --> 00:07:27,800
how does it work for the physical switch

00:07:23,930 --> 00:07:30,500
case so in this case you have as we said

00:07:27,800 --> 00:07:32,510
in the switch their framework each part

00:07:30,500 --> 00:07:34,580
is represented by a net device so in

00:07:32,510 --> 00:07:37,460
this case we have two ports sw1p one and

00:07:34,580 --> 00:07:40,250
sw1p to the 22 process of the switch and

00:07:37,460 --> 00:07:43,010
want to put them in the vlog so the IP

00:07:40,250 --> 00:07:45,169
route to command would be I padding said

00:07:43,010 --> 00:07:49,430
they've sw1p one master you must do now

00:07:45,169 --> 00:07:51,110
is team zero so initially the team

00:07:49,430 --> 00:07:53,210
driver will will call into the core

00:07:51,110 --> 00:07:56,419
networking stack and they will send this

00:07:53,210 --> 00:07:59,090
pre change a pair notification and as I

00:07:56,419 --> 00:08:01,940
said in this case for instance currently

00:07:59,090 --> 00:08:04,250
the mlx SW driver would refuse this if

00:08:01,940 --> 00:08:05,990
it's not an lacp lag if it's other time

00:08:04,250 --> 00:08:09,229
because that's it that's what we want to

00:08:05,990 --> 00:08:10,880
support now so if it's not a lie CP or

00:08:09,229 --> 00:08:12,650
if there is something other we we can

00:08:10,880 --> 00:08:16,220
knock it and then the change doesn't

00:08:12,650 --> 00:08:18,169
happen if we don't knock it the

00:08:16,220 --> 00:08:20,570
operation continues and then we get the

00:08:18,169 --> 00:08:24,169
second notification and what we do at

00:08:20,570 --> 00:08:25,970
this point is that we observe that it's

00:08:24,169 --> 00:08:28,490
a new log is being created for this

00:08:25,970 --> 00:08:30,560
physical switch so you so the first

00:08:28,490 --> 00:08:30,810
action is to create this slug with the

00:08:30,560 --> 00:08:32,940
ha

00:08:30,810 --> 00:08:35,550
and the second action is to add this

00:08:32,940 --> 00:08:37,169
port into this leg okay so that that

00:08:35,550 --> 00:08:41,659
what happens when you put the first part

00:08:37,169 --> 00:08:44,219
into the log the second the second that

00:08:41,659 --> 00:08:46,650
when it's being done on the second port

00:08:44,219 --> 00:08:49,830
so again we still have the bridge in the

00:08:46,650 --> 00:08:51,420
upper we confirm its ok and then it the

00:08:49,830 --> 00:08:53,610
change-up I we see that this slug

00:08:51,420 --> 00:08:58,160
already exists so we just add this port

00:08:53,610 --> 00:09:02,120
into this lock ok any questions on this

00:08:58,160 --> 00:09:10,230
use case of the physical switch someone

00:09:02,120 --> 00:09:12,120
yes how you want to do yeah so you

00:09:10,230 --> 00:09:13,980
offload the datapath obviously what

00:09:12,120 --> 00:09:15,240
happens to the control part is the lacp

00:09:13,980 --> 00:09:19,050
is that I fell asleep if I guess go to

00:09:15,240 --> 00:09:21,660
the sea arc thank you so the way the way

00:09:19,050 --> 00:09:24,930
the harder is configured is that lacp

00:09:21,660 --> 00:09:27,330
packets and I believe also igmp in all

00:09:24,930 --> 00:09:29,580
the contests brakiri incorrect answer

00:09:27,330 --> 00:09:31,890
lacp packets and the igmp and other

00:09:29,580 --> 00:09:34,860
stuff still goes into the CPU so it's

00:09:31,890 --> 00:09:37,589
excellent so the slope has noted CPU the

00:09:34,860 --> 00:09:41,220
data path flows to the other okay good

00:09:37,589 --> 00:09:43,110
thank you so again correct so the lacp

00:09:41,220 --> 00:09:44,760
state machines is still in the house all

00:09:43,110 --> 00:09:47,339
the controlling of stuff is still done

00:09:44,760 --> 00:09:53,960
by the CPU and only the data pass is

00:09:47,339 --> 00:09:57,270
offloaded ok ok let's move to the second

00:09:53,960 --> 00:09:59,730
ok so now the scary slide on how do you

00:09:57,270 --> 00:10:01,260
may in the dev conference joking so what

00:09:59,730 --> 00:10:04,620
is our dma are they made sense for

00:10:01,260 --> 00:10:07,500
remote direct memory access it's a stack

00:10:04,620 --> 00:10:10,860
which was introduced in 2 6 2 6 12 10

00:10:07,500 --> 00:10:14,100
years ago and this tag supports multiple

00:10:10,860 --> 00:10:15,570
transport for RDMA our primary interest

00:10:14,100 --> 00:10:17,400
here of course the native is the rock

00:10:15,570 --> 00:10:20,850
what we call rocky or the AMIA will

00:10:17,400 --> 00:10:22,470
converge internet which is a standard my

00:10:20,850 --> 00:10:23,940
dis stuck just for your general

00:10:22,470 --> 00:10:26,790
knowledge support other transport such

00:10:23,940 --> 00:10:30,240
as InfiniBand in europe if we focus we

00:10:26,790 --> 00:10:33,600
focus on rocky today so rocky v 2 is

00:10:30,240 --> 00:10:36,209
upstream in folded 5 and it is actually

00:10:33,600 --> 00:10:38,040
a tunneling of a UDP so those are the MA

00:10:36,209 --> 00:10:38,870
packets are actually UDP packets which

00:10:38,040 --> 00:10:43,010
are reserved

00:10:38,870 --> 00:10:47,089
vote and and under the UDP does those

00:10:43,010 --> 00:10:49,730
RDMA packets and it uses the plane ipv4

00:10:47,089 --> 00:10:53,240
ipv6 addressing of the ethernet nic so

00:10:49,730 --> 00:10:54,920
an audio mayanic that support rocky and

00:10:53,240 --> 00:10:57,380
Alex we have two connected free and

00:10:54,920 --> 00:10:59,270
connect this fall each one of them

00:10:57,380 --> 00:11:02,060
exposes purporting net device to the

00:10:59,270 --> 00:11:05,060
opening system which with that support

00:11:02,060 --> 00:11:10,000
ipv4 ipv6 and those addresses are using

00:11:05,060 --> 00:11:12,770
are used to establish the rocky sessions

00:11:10,000 --> 00:11:14,600
rocky applications used to api's one

00:11:12,770 --> 00:11:16,160
called the RT make CM and everyone

00:11:14,600 --> 00:11:19,089
called verbs the other museum is for the

00:11:16,160 --> 00:11:24,920
control pass diversity for the data pass

00:11:19,089 --> 00:11:26,540
an RD macm includes three steps one is

00:11:24,920 --> 00:11:29,120
address resolution which is a local

00:11:26,540 --> 00:11:31,010
route look up and are poor ND to resolve

00:11:29,120 --> 00:11:32,839
the address of the other side second

00:11:31,010 --> 00:11:34,520
step is called wat resolution which is

00:11:32,839 --> 00:11:35,720
only relevant for InfiniBand network is

00:11:34,520 --> 00:11:38,120
determining the past with Indian

00:11:35,720 --> 00:11:40,339
filaments subnet and the third stage is

00:11:38,120 --> 00:11:42,950
the connection establishment how to how

00:11:40,339 --> 00:11:45,700
to wire those Adam a connection between

00:11:42,950 --> 00:11:48,589
the notes and then you can offload it so

00:11:45,700 --> 00:11:50,480
the trick is that the first step the

00:11:48,589 --> 00:11:55,370
address resolution is done by the

00:11:50,480 --> 00:11:56,990
network stack and that's and we use IP

00:11:55,370 --> 00:11:59,450
addresses and that's that's our

00:11:56,990 --> 00:12:01,970
injection point to have the network

00:11:59,450 --> 00:12:03,500
stack to control the atomistic the

00:12:01,970 --> 00:12:05,300
website p i just for general knowledge

00:12:03,500 --> 00:12:07,279
it's appropriate to such as send receive

00:12:05,300 --> 00:12:09,260
and Paula knows and this is offloaded

00:12:07,279 --> 00:12:12,470
once you have the Ottoman connection you

00:12:09,260 --> 00:12:16,970
are already offloaded from the network

00:12:12,470 --> 00:12:19,370
stack and it uses something called RDM a

00:12:16,970 --> 00:12:21,500
device which is IB structure and this

00:12:19,370 --> 00:12:24,020
each audio MIDI vas has association with

00:12:21,500 --> 00:12:26,390
the net device so that your that's your

00:12:24,020 --> 00:12:28,700
crash course for dma and another thing

00:12:26,390 --> 00:12:33,410
that in in our case in mellanox the RDM

00:12:28,700 --> 00:12:36,050
a kernel slow pass also used for the for

00:12:33,410 --> 00:12:40,279
wiring userspace internet traffic such

00:12:36,050 --> 00:12:42,410
as DP DK so it plain internet traffic

00:12:40,279 --> 00:12:44,060
that is offloaded to userspace the

00:12:42,410 --> 00:12:47,329
control paths also goes to the colonel

00:12:44,060 --> 00:12:48,580
just the detail that we can influence

00:12:47,329 --> 00:12:55,190
our

00:12:48,580 --> 00:12:59,270
solution honey ok so now and nothing

00:12:55,190 --> 00:13:04,790
will explain the model for the RDM a DJ

00:12:59,270 --> 00:13:08,420
ok thanks so I'll use this mic again yes

00:13:04,790 --> 00:13:12,200
so basically what we described in this

00:13:08,420 --> 00:13:14,090
slide is how we see the native model

00:13:12,200 --> 00:13:17,360
versus virtualization which we'll see in

00:13:14,090 --> 00:13:21,010
next slide are we basically expose

00:13:17,360 --> 00:13:24,230
bonding and how actually bonding is

00:13:21,010 --> 00:13:26,510
supported for RMA device and user mode

00:13:24,230 --> 00:13:28,940
Internet as as all described in the

00:13:26,510 --> 00:13:32,060
previous slide so basically we wanted to

00:13:28,940 --> 00:13:34,880
have a very basic use and feel for users

00:13:32,060 --> 00:13:37,310
they can use the same tools same use and

00:13:34,880 --> 00:13:39,590
feel as they do today with Linux bonding

00:13:37,310 --> 00:13:45,620
or theming models all configuration is

00:13:39,590 --> 00:13:49,100
the same so basically in for Rocky we

00:13:45,620 --> 00:13:51,410
have hardware based transport object we

00:13:49,100 --> 00:13:53,840
call them pupae pewter and tease

00:13:51,410 --> 00:14:00,230
transport interface send those are

00:13:53,840 --> 00:14:03,950
objects for send send the transport so

00:14:00,230 --> 00:14:07,400
basically we've added to those a hard

00:14:03,950 --> 00:14:10,610
object a pop of T called port affinity

00:14:07,400 --> 00:14:14,900
so basically user can on creation time

00:14:10,610 --> 00:14:20,480
specify which actual ports those objects

00:14:14,900 --> 00:14:25,400
to do a favor so that's for the user

00:14:20,480 --> 00:14:28,490
mode internet and REM a bypass code and

00:14:25,400 --> 00:14:31,250
for the actual RDMA devices themselves

00:14:28,490 --> 00:14:34,550
that are associated with 0 and eighth

00:14:31,250 --> 00:14:36,230
one those are the devices that will

00:14:34,550 --> 00:14:39,080
discussed also in the previous slide we

00:14:36,230 --> 00:14:42,140
basically unregister them whenever we

00:14:39,080 --> 00:14:44,630
detect there's a bonding whenever we

00:14:42,140 --> 00:14:46,460
detect that if their parent devices

00:14:44,630 --> 00:14:48,350
their net devs are being enslaved to a

00:14:46,460 --> 00:14:50,240
bonding or demon girl model so we

00:14:48,350 --> 00:14:56,270
basically unregister them and register

00:14:50,240 --> 00:14:58,360
them so we notify current users the

00:14:56,270 --> 00:15:02,019
configuration a change you need to

00:14:58,360 --> 00:15:05,680
established your resources and whenever

00:15:02,019 --> 00:15:07,870
we bring them up they are basically kind

00:15:05,680 --> 00:15:11,320
of stubbed devices devices that are used

00:15:07,870 --> 00:15:14,920
for port management so that are not used

00:15:11,320 --> 00:15:17,850
for traffic similar to 80 and eighth one

00:15:14,920 --> 00:15:24,370
that are being enslaved mostly useful

00:15:17,850 --> 00:15:26,440
port management and whenever we detect

00:15:24,370 --> 00:15:28,930
all this enslavement and we see that it

00:15:26,440 --> 00:15:32,320
is associated with the same device we

00:15:28,930 --> 00:15:34,930
basically instantiate a new RDMA device

00:15:32,320 --> 00:15:38,019
that is associated with the with the

00:15:34,930 --> 00:15:40,899
bonding with a demon model so we now

00:15:38,019 --> 00:15:42,730
have a single net that is represented

00:15:40,899 --> 00:15:46,510
toward you the stack it has its own IP

00:15:42,730 --> 00:15:53,640
address and we have similar using feel

00:15:46,510 --> 00:15:57,100
for the RDM a device now how basically

00:15:53,640 --> 00:15:59,980
hashing for the RDMA device is being

00:15:57,100 --> 00:16:01,870
done so basically this is a general

00:15:59,980 --> 00:16:07,060
implementation each vendor can choose

00:16:01,870 --> 00:16:08,920
its own its own pic how to route the

00:16:07,060 --> 00:16:11,170
commands of course this is alone only

00:16:08,920 --> 00:16:13,990
control pad how to watch those commands

00:16:11,170 --> 00:16:16,269
of creating the health of object to the

00:16:13,990 --> 00:16:20,860
actual hardware in our implementation we

00:16:16,269 --> 00:16:25,360
typically use pf0 for routing those

00:16:20,860 --> 00:16:27,760
commands again it's only a way to get

00:16:25,360 --> 00:16:30,010
into the hardware the actual physical

00:16:27,760 --> 00:16:33,850
port that is being chosen as I described

00:16:30,010 --> 00:16:37,720
earlier through the port affinity of the

00:16:33,850 --> 00:16:41,740
transport object attribute regarding

00:16:37,720 --> 00:16:45,360
link aggregation in lacp so whenever

00:16:41,740 --> 00:16:48,699
linux bonding is configured with NAC p

00:16:45,360 --> 00:16:53,290
it actually implements the acp protocol

00:16:48,699 --> 00:16:56,230
in software in the bonding model or we

00:16:53,290 --> 00:17:01,260
plan to also add support that lacp will

00:16:56,230 --> 00:17:04,630
be running in the house Oh firmer

00:17:01,260 --> 00:17:07,020
basically it is required for many

00:17:04,630 --> 00:17:10,450
physical functions to

00:17:07,020 --> 00:17:15,490
physical port mappings like flexed n and

00:17:10,450 --> 00:17:18,850
n for but also in one week only multi

00:17:15,490 --> 00:17:21,580
host environment where a single Nick

00:17:18,850 --> 00:17:24,339
silicon can can be used by multiple

00:17:21,580 --> 00:17:28,690
physical machines I will touch this in

00:17:24,339 --> 00:17:33,340
the last slide as well a few words about

00:17:28,690 --> 00:17:37,140
the Hubble bond model so basically this

00:17:33,340 --> 00:17:40,810
is the actual logic in the hardware that

00:17:37,140 --> 00:17:43,750
that implements the data path for send

00:17:40,810 --> 00:17:47,020
and receiving the RDMA traffic and the

00:17:43,750 --> 00:17:54,760
user mode Ethernet traffic from the

00:17:47,020 --> 00:17:59,110
right port so basically network network

00:17:54,760 --> 00:18:01,690
traffic like IP stack traffic TV traffic

00:17:59,110 --> 00:18:03,880
is being sent from the physical port to

00:18:01,690 --> 00:18:09,930
the matching native and up the stack and

00:18:03,880 --> 00:18:13,570
for RDMA traffic we basically choose the

00:18:09,930 --> 00:18:20,590
pf0 in our implementation as I mentioned

00:18:13,570 --> 00:18:24,340
earlier now in the next slide I will

00:18:20,590 --> 00:18:28,690
touch I will discuss how basically we

00:18:24,340 --> 00:18:30,490
want to expose ldm a bonding in the

00:18:28,690 --> 00:18:34,600
virtual case the earlier slide was the

00:18:30,490 --> 00:18:37,540
native case so we see two options and we

00:18:34,600 --> 00:18:41,200
would like to support both of them the

00:18:37,540 --> 00:18:45,310
first option is more for legacy and what

00:18:41,200 --> 00:18:52,120
users was usually configured configured

00:18:45,310 --> 00:18:56,140
today so in our plans to support silv

00:18:52,120 --> 00:18:58,630
games and nano salvi pm's our through

00:18:56,140 --> 00:19:00,000
this as you see in this slide is

00:18:58,630 --> 00:19:04,020
basically we have

00:19:00,000 --> 00:19:06,300
the linux OBS bridge which is the

00:19:04,020 --> 00:19:09,720
software presentation for the hardware

00:19:06,300 --> 00:19:13,500
is which so basically we can see on the

00:19:09,720 --> 00:19:16,740
right that s I of IBM's are connected

00:19:13,500 --> 00:19:19,640
through their matching virtual function

00:19:16,740 --> 00:19:24,600
they have a represent or net device

00:19:19,640 --> 00:19:26,910
endorsed stack we have 80 which

00:19:24,600 --> 00:19:29,390
represents the uplink all of these are

00:19:26,910 --> 00:19:32,910
associated with the Linux which device

00:19:29,390 --> 00:19:36,990
which is the architecture of the switch

00:19:32,910 --> 00:19:39,870
device and these are connected or

00:19:36,990 --> 00:19:45,720
enslaved the Linux bridge also we have

00:19:39,870 --> 00:19:47,850
the on the upper of the slide we see the

00:19:45,720 --> 00:19:51,600
nano soil Vivian's that are connected

00:19:47,850 --> 00:19:56,280
through the vth to the Linux bridge and

00:19:51,600 --> 00:19:58,020
we also can see the internal leg of the

00:19:56,280 --> 00:20:02,130
Knox bridge which is connected to the

00:19:58,020 --> 00:20:04,860
actual hypervisor actual BF stack this

00:20:02,130 --> 00:20:08,910
exposes than the negative of usually BR

00:20:04,860 --> 00:20:11,550
0 it has its own IP for the hypervisor

00:20:08,910 --> 00:20:13,980
stack and on top of that we basically

00:20:11,550 --> 00:20:15,780
instantiate the ldm a device with the

00:20:13,980 --> 00:20:19,620
same mechanics i discussed in the

00:20:15,780 --> 00:20:22,260
earlier slide so again we have for

00:20:19,620 --> 00:20:27,210
bonding sorry for the name of the bridge

00:20:22,260 --> 00:20:31,140
we have BR 0 and the associated RDMA

00:20:27,210 --> 00:20:33,540
device for the native voice so just a

00:20:31,140 --> 00:20:37,290
few words of traffic flow here so

00:20:33,540 --> 00:20:40,770
basically SFI of IBM's can send traffic

00:20:37,290 --> 00:20:43,590
directly through the VF to the wire or

00:20:40,770 --> 00:20:46,020
the other VMS but they can also

00:20:43,590 --> 00:20:49,470
according to obvious sarah's can go to

00:20:46,020 --> 00:20:51,330
what we call slow path or miss Beth can

00:20:49,470 --> 00:20:53,730
go up the stack through their own

00:20:51,330 --> 00:20:56,820
representer and do the switching in

00:20:53,730 --> 00:20:58,980
software to the Linux the bridge so both

00:20:56,820 --> 00:21:02,100
options are supported so just this is

00:20:58,980 --> 00:21:03,910
just a recap and later owners and show

00:21:02,100 --> 00:21:06,130
you how

00:21:03,910 --> 00:21:10,750
we're bonding is supported in this

00:21:06,130 --> 00:21:13,990
configuration go quickly to the next

00:21:10,750 --> 00:21:16,780
slide which is which represents the

00:21:13,990 --> 00:21:18,790
option to well basically in this option

00:21:16,780 --> 00:21:20,530
we don't the only difference between the

00:21:18,790 --> 00:21:23,140
first and the second is that in this

00:21:20,530 --> 00:21:27,660
option we don't use the internal link a

00:21:23,140 --> 00:21:31,000
leg of the linux of vs bridge we use

00:21:27,660 --> 00:21:35,050
basically instantiate kind of virtual

00:21:31,000 --> 00:21:38,260
port in the linux which device for the

00:21:35,050 --> 00:21:42,130
beer for the hypervisor itself so you

00:21:38,260 --> 00:21:45,490
can see that there's no bl0 leg the apps

00:21:42,130 --> 00:21:49,630
up uplink now is being represented by a

00:21:45,490 --> 00:21:53,530
rep fe 0 which is enslaved the bridge

00:21:49,630 --> 00:21:55,690
we've added a representative for if 0 in

00:21:53,530 --> 00:22:00,150
the linux bridge which is basically

00:21:55,690 --> 00:22:04,890
connected to 80 the interface that is

00:22:00,150 --> 00:22:07,960
serving the hypervisor so in this way

00:22:04,890 --> 00:22:11,340
the hypervisor is kind of first-class

00:22:07,960 --> 00:22:15,250
citizen as that gets the same uploads as

00:22:11,340 --> 00:22:19,750
the VMS for instance if we want to do

00:22:15,250 --> 00:22:23,500
the enjoy in the PF form hardware based

00:22:19,750 --> 00:22:25,480
reporting then with an internal leg we

00:22:23,500 --> 00:22:26,770
basically go up the stack and the

00:22:25,480 --> 00:22:30,400
forwarding is being done through the

00:22:26,770 --> 00:22:34,660
linux bridge many implementation do that

00:22:30,400 --> 00:22:37,510
by Miss flow so this traffic gets most

00:22:34,660 --> 00:22:42,340
penalty because this traffic goes up

00:22:37,510 --> 00:22:45,730
only if it doesn't match any of the vm

00:22:42,340 --> 00:22:47,110
actual vm matches and in this case we

00:22:45,730 --> 00:22:49,960
have a specific holding in the hardware

00:22:47,110 --> 00:22:51,970
that we plump in the mac villain or five

00:22:49,960 --> 00:22:58,860
double or whatever rule but forwards the

00:22:51,970 --> 00:23:01,180
traffic to the actual it's zero native

00:22:58,860 --> 00:23:04,750
of course we can introduce some

00:23:01,180 --> 00:23:04,990
optimizations to the option one where we

00:23:04,750 --> 00:23:07,360
may

00:23:04,990 --> 00:23:09,730
ethically asrani my colleague presented

00:23:07,360 --> 00:23:15,610
earlier we can add the kind of flow tag

00:23:09,730 --> 00:23:18,280
for the PF also so whenever that bf is

00:23:15,610 --> 00:23:21,190
using the internal egg we can also aid

00:23:18,280 --> 00:23:24,130
the software based folding by having a

00:23:21,190 --> 00:23:28,230
floater that specify that classified

00:23:24,130 --> 00:23:28,230
that is being classified in the harder

00:23:29,490 --> 00:23:36,910
so now how basically are they male

00:23:34,809 --> 00:23:40,240
bonding fits in in the virtualization

00:23:36,910 --> 00:23:43,000
model so we can see in this slide I know

00:23:40,240 --> 00:23:45,120
there's many details but we we've seen

00:23:43,000 --> 00:23:48,610
most of them in the earlier slide so

00:23:45,120 --> 00:23:52,480
basically we can see here the time we

00:23:48,610 --> 00:23:54,429
have two physical ports highlighting the

00:23:52,480 --> 00:23:58,090
changes we have two physical ports we

00:23:54,429 --> 00:24:02,679
have now represented for the two uplands

00:23:58,090 --> 00:24:04,929
we have represen and now Rep he won and

00:24:02,679 --> 00:24:07,240
those represent us are basically

00:24:04,929 --> 00:24:12,100
connected on slipped to the Linux

00:24:07,240 --> 00:24:16,300
bonding and then enslaved to the Linux

00:24:12,100 --> 00:24:17,650
bridge so basically on the Left we can

00:24:16,300 --> 00:24:19,690
see the ultimate device for the

00:24:17,650 --> 00:24:24,070
hypervisor it's a single device same

00:24:19,690 --> 00:24:26,770
same as before but all the logic of the

00:24:24,070 --> 00:24:29,920
bonding is being done in the linux

00:24:26,770 --> 00:24:32,950
bonding model for the tcp/ip stack and

00:24:29,920 --> 00:24:37,360
in the huddle bound in the East which

00:24:32,950 --> 00:24:40,960
and now for our GMA and the user mode

00:24:37,360 --> 00:24:45,190
ethernet and for the virtual machines

00:24:40,960 --> 00:24:49,410
the SRV virtual machines we basically

00:24:45,190 --> 00:24:52,960
have several options one of them is

00:24:49,410 --> 00:24:54,820
basically allocate or associate each

00:24:52,960 --> 00:24:57,640
virtual machine which a different

00:24:54,820 --> 00:25:01,480
physical port this this way we do the

00:24:57,640 --> 00:25:03,220
load balancing and the other option in

00:25:01,480 --> 00:25:03,970
this option is basically transparent for

00:25:03,220 --> 00:25:06,460
the vm

00:25:03,970 --> 00:25:08,230
there was no need for 12 installation in

00:25:06,460 --> 00:25:11,260
the VMS of establishing kind of a

00:25:08,230 --> 00:25:13,840
bonding model same same interface is

00:25:11,260 --> 00:25:15,610
being instantiated in the single

00:25:13,840 --> 00:25:18,340
interface is being instantiated in the

00:25:15,610 --> 00:25:21,030
VMS but for users that want to control

00:25:18,340 --> 00:25:23,230
the hash or maybe are more used to the

00:25:21,030 --> 00:25:25,780
linux bombing hash of the stuff is

00:25:23,230 --> 00:25:27,790
sophisticated or more extended

00:25:25,780 --> 00:25:30,820
capabilities of the team inc model of

00:25:27,790 --> 00:25:39,790
defining the hash they can associate to

00:25:30,820 --> 00:25:43,120
VX to a vm h VF from HP f h VF from HP f

00:25:39,790 --> 00:25:46,720
and then on top of that build a bonding

00:25:43,120 --> 00:25:50,080
or teaming model and slave and the same

00:25:46,720 --> 00:25:52,810
those negatives in the vm itself so

00:25:50,080 --> 00:25:58,300
basically both configurations can can be

00:25:52,810 --> 00:26:01,180
supported regarding a che so a

00:25:58,300 --> 00:26:04,540
functionality I didn't mention is that

00:26:01,180 --> 00:26:07,570
the hardware is capable on Fame over to

00:26:04,540 --> 00:26:10,780
basically remap the transport objects

00:26:07,570 --> 00:26:13,960
that I mentioned before from actual

00:26:10,780 --> 00:26:16,870
physical part to the to form the failing

00:26:13,960 --> 00:26:18,520
physical point to the actual active port

00:26:16,870 --> 00:26:20,920
so this is transparent this is done in

00:26:18,520 --> 00:26:23,290
hardware and whenever the failed port

00:26:20,920 --> 00:26:26,050
comes back the traffic goes back to the

00:26:23,290 --> 00:26:28,030
active report that was originally

00:26:26,050 --> 00:26:32,680
associated with a with the transport

00:26:28,030 --> 00:26:35,470
object so this is basically the

00:26:32,680 --> 00:26:40,150
virtualization and Adam a year are

00:26:35,470 --> 00:26:43,290
bonding this light is more to show you

00:26:40,150 --> 00:26:45,940
that also whenever you use tunneling and

00:26:43,290 --> 00:26:49,450
how we're basically paneling fits in

00:26:45,940 --> 00:26:52,480
also tunneling in this configuration can

00:26:49,450 --> 00:26:56,440
support our DM bonding and it's very

00:26:52,480 --> 00:26:59,470
similar to what was described before so

00:26:56,440 --> 00:27:02,860
basically the change agents here are

00:26:59,470 --> 00:27:04,240
mostly on the left where we see here the

00:27:02,860 --> 00:27:09,040
obvious

00:27:04,240 --> 00:27:13,660
vehicle on bridge that is associated

00:27:09,040 --> 00:27:17,470
with a UDP IP stack of the vehicle and

00:27:13,660 --> 00:27:21,520
device so basically tunneling traffic

00:27:17,470 --> 00:27:23,559
from slope app can golf on non SVM's

00:27:21,520 --> 00:27:27,090
through the Linux bridge through the

00:27:23,559 --> 00:27:31,059
obvious tweaks language and encapsulated

00:27:27,090 --> 00:27:33,190
through the vehicle aneta files and in

00:27:31,059 --> 00:27:36,700
combination with hardwell encapsulation

00:27:33,190 --> 00:27:38,980
in the capsulation the SRV VMS goes

00:27:36,700 --> 00:27:42,309
through the VF until the embedded switch

00:27:38,980 --> 00:27:47,320
and enjoy the encapsulation in the

00:27:42,309 --> 00:27:49,090
hardware and instantiating bonding in

00:27:47,320 --> 00:27:52,620
this configuration is the same we

00:27:49,090 --> 00:27:58,179
basically have added the represent of a

00:27:52,620 --> 00:28:01,000
v1 and associate an associate v-0 and

00:27:58,179 --> 00:28:04,720
pay one with a bonding model I'm running

00:28:01,000 --> 00:28:08,980
out of time so I'll show the last slide

00:28:04,720 --> 00:28:11,230
very quickly so one more exciting

00:28:08,980 --> 00:28:15,100
feature that we have here is the multi

00:28:11,230 --> 00:28:17,920
PCI socket Nick as I discussed before we

00:28:15,100 --> 00:28:19,540
we do have a feature which we call

00:28:17,920 --> 00:28:23,830
mostly host where we basically can

00:28:19,540 --> 00:28:25,840
connect a single Nick to multiple cpus

00:28:23,830 --> 00:28:30,070
and in in this configuration we

00:28:25,840 --> 00:28:33,270
basically use a single server a single

00:28:30,070 --> 00:28:37,360
server to connect those several links so

00:28:33,270 --> 00:28:41,350
basically the Nick shows to the system

00:28:37,360 --> 00:28:44,200
as a multi endpoint and Nick where each

00:28:41,350 --> 00:28:47,350
endpoint resides on a different bus or a

00:28:44,200 --> 00:28:51,280
different cpu socket so basically

00:28:47,350 --> 00:28:53,549
instead of sending from one cpu through

00:28:51,280 --> 00:28:56,039
the QPI to the

00:28:53,549 --> 00:29:00,389
root complex and the neck you can

00:28:56,039 --> 00:29:03,480
basically bypass the QPI and send the

00:29:00,389 --> 00:29:06,779
traffic from the cpu directly to the

00:29:03,480 --> 00:29:11,009
local root complex and to the to the

00:29:06,779 --> 00:29:13,769
neck so how is this related to the Linux

00:29:11,009 --> 00:29:15,749
bonding so basically in such a

00:29:13,769 --> 00:29:19,289
configuration you represent to network

00:29:15,749 --> 00:29:21,419
devices in one server you can work in

00:29:19,289 --> 00:29:24,269
such a configuration if your application

00:29:21,419 --> 00:29:29,059
is aware of multiple networks and can

00:29:24,269 --> 00:29:30,989
actually decide our d MOOCs in

00:29:29,059 --> 00:29:36,299
internally how to choose the right

00:29:30,989 --> 00:29:38,789
native ok so in this configuration we

00:29:36,299 --> 00:29:40,799
basically use the Linux or bonding tube

00:29:38,789 --> 00:29:42,539
and those two net devices have the same

00:29:40,799 --> 00:29:46,619
user feel we have a single net device

00:29:42,539 --> 00:29:50,340
exposed to the stack and and enjoy this

00:29:46,619 --> 00:29:53,899
qpi by bus I'll stop here because yeah

00:29:50,340 --> 00:29:53,899
we have no more time sorry

00:29:59,539 --> 00:30:01,600

YouTube URL: https://www.youtube.com/watch?v=eiQCiJrC8Fk


