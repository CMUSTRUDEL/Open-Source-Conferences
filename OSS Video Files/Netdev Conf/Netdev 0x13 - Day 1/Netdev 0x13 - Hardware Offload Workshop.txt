Title: Netdev 0x13 - Hardware Offload Workshop
Publication date: 2019-05-20
Playlist: Netdev 0x13 - Day 1
Description: 
	Roopa Prabhu and Or Gerlitz co-chair the Hardware Offload workshop.

The primary goal of this workshop was to discuss recent
updates and futures to network hardware offload APIâ€™s
and infrastructure in the Linux kernel.

More info:
https://www.netdevconf.org/0x13/session.html?workshop-hardware-offload
Captions: 
	00:00:00,030 --> 00:00:08,880
another one again my name is Ruth I can

00:00:03,899 --> 00:00:11,790
use networks I kingless actually creates

00:00:08,880 --> 00:00:14,519
a distribution a mass for sweetie six

00:00:11,790 --> 00:00:17,250
and that's why we're involved in

00:00:14,519 --> 00:00:19,260
hardware Florida Jesus that's what I'm

00:00:17,250 --> 00:00:23,270
going to be talking about sharing a

00:00:19,260 --> 00:00:23,270
little bit of updates from that world so

00:00:24,199 --> 00:00:28,080
just

00:00:25,350 --> 00:00:30,179
Jambu switches it off load updates just

00:00:28,080 --> 00:00:33,660
like what we did last year or the last

00:00:30,179 --> 00:00:36,420
letter there have been many things going

00:00:33,660 --> 00:00:39,600
on I know there are many delicate

00:00:36,420 --> 00:00:42,210
updates many developers here who have

00:00:39,600 --> 00:00:46,890
have made those updates their references

00:00:42,210 --> 00:00:50,070
to them one is health centralized device

00:00:46,890 --> 00:00:52,379
collectively and this is the same Julie

00:00:50,070 --> 00:00:56,000
talked about in the network shop and

00:00:52,379 --> 00:00:59,789
then there's deviling parameters and

00:00:56,000 --> 00:01:02,879
abstract configure we do pass

00:00:59,789 --> 00:01:05,220
configuration parameters to traverse so

00:01:02,879 --> 00:01:09,720
that link is sort of becoming the net

00:01:05,220 --> 00:01:12,090
link Hardware a trimaran API and then

00:01:09,720 --> 00:01:15,420
the last row switched a box with moon

00:01:12,090 --> 00:01:18,060
moved to modifiers so it's strange about

00:01:15,420 --> 00:01:21,810
five years ago we did the first talk

00:01:18,060 --> 00:01:24,869
about switch in agneta and introducing

00:01:21,810 --> 00:01:27,150
switch to bots and over the years years

00:01:24,869 --> 00:01:31,290
with experience we learned that no

00:01:27,150 --> 00:01:34,140
defiers which are six events in from

00:01:31,290 --> 00:01:35,980
subsystems to which drivers can leverage

00:01:34,140 --> 00:01:37,870
so I know mlx

00:01:35,980 --> 00:01:41,070
that is the penalty Jacek dragon the

00:01:37,870 --> 00:01:42,220
pearl uses a lot of those modifiers and

00:01:41,070 --> 00:01:43,960
slowly

00:01:42,220 --> 00:01:46,180
most of the switch that offs have been

00:01:43,960 --> 00:01:48,130
moved to those early fires

00:01:46,180 --> 00:01:53,440
so we saw the last one can get a vote

00:01:48,130 --> 00:01:58,660
last week or something okay so there are

00:01:53,440 --> 00:02:03,430
multiple topics being discussed on meta

00:01:58,660 --> 00:02:04,960
bundesliga reasons they are I have some

00:02:03,430 --> 00:02:07,720
vested interest and are linked down

00:02:04,960 --> 00:02:11,700
reasons there is a catch

00:02:07,720 --> 00:02:16,120
series which is being floated by Peter

00:02:11,700 --> 00:02:20,380
from the rocks on l1 reasons for a time

00:02:16,120 --> 00:02:22,060
and as a nas linked down dividing a link

00:02:20,380 --> 00:02:24,610
down at first thing what you do or a

00:02:22,060 --> 00:02:26,830
system is going check l1 at every layer

00:02:24,610 --> 00:02:30,730
you go and check first l1 by each tool

00:02:26,830 --> 00:02:33,070
and then you're going to check if MSTP

00:02:30,730 --> 00:02:36,130
or HTTP petitioners at the port down and

00:02:33,070 --> 00:02:39,850
that's why the port is down or bonding

00:02:36,130 --> 00:02:41,470
or e2 rocked really is not converging

00:02:39,850 --> 00:02:43,660
and that's why the link is down so it's

00:02:41,470 --> 00:02:46,750
you go to each of these students and

00:02:43,660 --> 00:02:51,130
check until you find the reason why the

00:02:46,750 --> 00:02:54,130
game is done so I think this having

00:02:51,130 --> 00:02:54,870
reason code for a link down main display

00:02:54,130 --> 00:02:57,870
the night

00:02:54,870 --> 00:03:01,640
show or even eat two will be really

00:02:57,870 --> 00:03:05,220
useful and has been asked from a lot of

00:03:01,640 --> 00:03:07,019
people who use your sisters actually

00:03:05,220 --> 00:03:10,080
most of the switches vendors do support

00:03:07,019 --> 00:03:13,500
them even protocol implementation link

00:03:10,080 --> 00:03:16,049
downs that we are our PDE or in life

00:03:13,500 --> 00:03:18,840
that is the multiple main switch side

00:03:16,049 --> 00:03:21,120
software that can also put a link down

00:03:18,840 --> 00:03:23,040
by Abby I collect wrote it down

00:03:21,120 --> 00:03:29,190
attribute that is a net lead applicant

00:03:23,040 --> 00:03:32,390
on in a polling so CI movie who's not

00:03:29,190 --> 00:03:32,390
here but I'm just

00:03:35,329 --> 00:03:48,150
oh so yeah so I just wanted to bring

00:03:46,709 --> 00:03:49,620
this up I think you've been discussing

00:03:48,150 --> 00:03:51,390
on the meeting us and they continue to

00:03:49,620 --> 00:03:55,769
start saying that it would be nice to

00:03:51,390 --> 00:03:58,230
have even protocol reasons which cause a

00:03:55,769 --> 00:04:00,239
link down we shown somewhere else I know

00:03:58,230 --> 00:04:01,709
if tool is where people go and look I

00:04:00,239 --> 00:04:04,290
know you through was brought up on the

00:04:01,709 --> 00:04:05,970
list as well whether because the link

00:04:04,290 --> 00:04:08,819
status is also to say relates to learn

00:04:05,970 --> 00:04:11,639
having disabling reason there will also

00:04:08,819 --> 00:04:18,959
be good but single API to serve our

00:04:11,639 --> 00:04:20,639
purpose will be okay however stats yeah

00:04:18,959 --> 00:04:23,220
I didn't get the memo from the DC

00:04:20,639 --> 00:04:25,620
workshop I think you guys have talked a

00:04:23,220 --> 00:04:29,789
lot about stuff and you can jump in and

00:04:25,620 --> 00:04:32,580
then you talk about stats but yeah

00:04:29,789 --> 00:04:34,590
there's a lot of stats related stuff

00:04:32,580 --> 00:04:36,240
going on in the rest of the subsystems

00:04:34,590 --> 00:04:39,900
apart when TC as well

00:04:36,240 --> 00:04:40,540
one is the RTM stats API basic ETS

00:04:39,900 --> 00:04:42,340
conducts

00:04:40,540 --> 00:04:45,520
some time now it's a little easier to

00:04:42,340 --> 00:04:48,310
get shots and the idea is to convert all

00:04:45,520 --> 00:04:52,270
the stats in the system to use the CPI

00:04:48,310 --> 00:04:55,390
if possible right so today the stats

00:04:52,270 --> 00:04:58,620
available there are the net dev stats

00:04:55,390 --> 00:05:03,580
and the ones that you get from nd you

00:04:58,620 --> 00:05:06,370
get stat 64 and then Bridgeville and

00:05:03,580 --> 00:05:07,720
stats mpls stats so all the new stats

00:05:06,370 --> 00:05:10,810
that have been added are available

00:05:07,720 --> 00:05:12,730
through this new strat CPM and in this

00:05:10,810 --> 00:05:15,310
case you have you can just query stats

00:05:12,730 --> 00:05:17,280
in the colonel unlike the stats that you

00:05:15,310 --> 00:05:19,810
get from the link terms this is

00:05:17,280 --> 00:05:22,060
efficient now

00:05:19,810 --> 00:05:24,310
Jakub there are some patches from Jakub

00:05:22,060 --> 00:05:26,500
which tried to add hardware stats to

00:05:24,310 --> 00:05:29,110
this and again there has been a

00:05:26,500 --> 00:05:30,910
discussion going on upstream and I don't

00:05:29,110 --> 00:05:34,000
think those patches have gone in yet but

00:05:30,910 --> 00:05:37,330
it would be nice to not give up on it to

00:05:34,000 --> 00:05:39,040
like starts the custom starts that if

00:05:37,330 --> 00:05:41,290
tool provides which are really handy and

00:05:39,040 --> 00:05:43,060
if those don't move to this API then

00:05:41,290 --> 00:05:44,740
people will not leave it to Lenny

00:05:43,060 --> 00:05:49,140
through a little bit you'll start

00:05:44,740 --> 00:05:49,140
they'll keep using it forever so

00:05:51,350 --> 00:05:57,610
so hardware's flex stats or counters so

00:05:55,010 --> 00:06:00,050
there is the switch ASIC supports

00:05:57,610 --> 00:06:02,240
something called flexible counters which

00:06:00,050 --> 00:06:04,880
is a pool of counters which you can

00:06:02,240 --> 00:06:11,620
attach to any network and point on any

00:06:04,880 --> 00:06:14,480
network like villains or VX LAN / route

00:06:11,620 --> 00:06:17,000
and it each counter actually provides

00:06:14,480 --> 00:06:19,600
packets and bytes counters this has

00:06:17,000 --> 00:06:25,000
recently come up for us in context of

00:06:19,600 --> 00:06:28,010
multicast routing it is very useful to

00:06:25,000 --> 00:06:30,830
have counters per route counters and the

00:06:28,010 --> 00:06:32,690
way people are used to using these in

00:06:30,830 --> 00:06:35,960
other systems and others which Asics is

00:06:32,690 --> 00:06:39,290
by attaching a counter on demand because

00:06:35,960 --> 00:06:41,030
hardware resources are finite and you if

00:06:39,290 --> 00:06:43,760
you're scaling to millions of routes you

00:06:41,030 --> 00:06:46,210
don't want to be enabling stats on all

00:06:43,760 --> 00:06:48,020
those routes so you can attach

00:06:46,210 --> 00:06:50,120
dynamically when you're debugging you

00:06:48,020 --> 00:06:52,820
can attach a counter to a routing

00:06:50,120 --> 00:06:55,100
endpoint for example so kernel doesn't

00:06:52,820 --> 00:06:57,320
linux doesn't have that for instance I

00:06:55,100 --> 00:07:00,560
mean there is no be not limited by

00:06:57,320 --> 00:07:04,370
hardware resources today and stats are

00:07:00,560 --> 00:07:07,010
mostly enabled by default for net dev

00:07:04,370 --> 00:07:09,410
stats but not so it depends on

00:07:07,010 --> 00:07:10,970
subsystems for example VLANs we do have

00:07:09,410 --> 00:07:13,730
the LAN starts in the bridge driver and

00:07:10,970 --> 00:07:15,980
per VLAN purport per VLAN starts as well

00:07:13,730 --> 00:07:16,910
but these are not enabled by default you

00:07:15,980 --> 00:07:21,650
have to enable them

00:07:16,910 --> 00:07:24,560
I think MPLS is also a on demand stats

00:07:21,650 --> 00:07:27,110
now even routes we don't want to arable

00:07:24,560 --> 00:07:29,630
routes by routes routing starts by

00:07:27,110 --> 00:07:32,470
default on all routes obviously it has

00:07:29,630 --> 00:07:32,470
to be a per route

00:07:32,920 --> 00:07:35,920
counter

00:07:41,840 --> 00:07:46,850
okay getting Colonel stats and parity

00:07:43,910 --> 00:07:49,430
with hardware stats the main limitation

00:07:46,850 --> 00:07:51,650
is here now the per route starts again

00:07:49,430 --> 00:07:55,250
and per forwarding Bridge forwarding

00:07:51,650 --> 00:07:57,770
entry starts as well again this came

00:07:55,250 --> 00:08:01,270
this for this applies to both IP routes

00:07:57,770 --> 00:08:05,510
and IP m our routes multicast routes and

00:08:01,270 --> 00:08:07,130
there is a bunch of global SNMP stats

00:08:05,510 --> 00:08:09,080
that are available today like in no

00:08:07,130 --> 00:08:10,790
routes and out no routes which need to

00:08:09,080 --> 00:08:13,280
move to the new stats API that's

00:08:10,790 --> 00:08:15,350
something we'll work on and I think

00:08:13,280 --> 00:08:16,850
these are only available I don't know if

00:08:15,350 --> 00:08:19,880
they were they are available to divine

00:08:16,850 --> 00:08:23,240
net link there is a proc net SNMP file

00:08:19,880 --> 00:08:27,380
which I think that start - s users as

00:08:23,240 --> 00:08:29,960
well so I think our TM stats API is that

00:08:27,380 --> 00:08:35,589
I pleased to provide net length support

00:08:29,960 --> 00:08:37,789
for them some notes on per route stats

00:08:35,589 --> 00:08:41,599
this is I'm not given it much thought

00:08:37,789 --> 00:08:44,060
but it would be similar to something

00:08:41,599 --> 00:08:48,530
like nf tables which is a boiler rule

00:08:44,060 --> 00:08:51,350
stat packets and byte counters probably

00:08:48,530 --> 00:08:54,410
a yeah not discussed it with david yet

00:08:51,350 --> 00:08:57,890
but some RTA are tributes to carry these

00:08:54,410 --> 00:09:00,380
routes and today routes don't support a

00:08:57,890 --> 00:09:02,960
set counter operation you can only

00:09:00,380 --> 00:09:04,790
provide a counter flag when you are

00:09:02,960 --> 00:09:08,600
adding the route or you can use the

00:09:04,790 --> 00:09:12,530
replace command so you can probably do

00:09:08,600 --> 00:09:15,230
that as well and those are the examples

00:09:12,530 --> 00:09:18,440
and IP route 2 - s is usually how you

00:09:15,230 --> 00:09:22,070
dump counters for for many of the

00:09:18,440 --> 00:09:24,620
commands in IP route - IP mr starts

00:09:22,070 --> 00:09:27,680
today actually there is a an IBM our

00:09:24,620 --> 00:09:30,709
stats but it shows the usage last used

00:09:27,680 --> 00:09:33,490
time I think that is applicable to IP

00:09:30,709 --> 00:09:33,490
routes as well

00:09:33,710 --> 00:09:42,300
the last thing I think is we hooks for

00:09:37,230 --> 00:09:45,390
Hardware stats so we know that the NED

00:09:42,300 --> 00:09:48,980
of stats has the get start 64 goes into

00:09:45,390 --> 00:09:51,330
Ivor's do have those implemented and

00:09:48,980 --> 00:09:54,750
adhere hardware starts to software stats

00:09:51,330 --> 00:09:58,940
this needs to extend to bridge VLAN

00:09:54,750 --> 00:10:04,140
stats for example because these ASIC

00:09:58,940 --> 00:10:07,500
drivers they do maintain VLAN stats the

00:10:04,140 --> 00:10:09,779
same thing for and VLAN device in l3

00:10:07,500 --> 00:10:13,529
board which is not a bridge VLAN

00:10:09,779 --> 00:10:16,020
interface you can throw well you will

00:10:13,529 --> 00:10:18,390
need to provide a hook in the a to 2.1 q

00:10:16,020 --> 00:10:20,790
driver as well same thing goes for VX

00:10:18,390 --> 00:10:23,400
lan i think we will see some of these

00:10:20,790 --> 00:10:25,740
stats and I think ml X as W is the

00:10:23,400 --> 00:10:29,040
probably the only driver that is capable

00:10:25,740 --> 00:10:34,680
of getting those stats today from

00:10:29,040 --> 00:10:37,709
hardware and new route starts of course

00:10:34,680 --> 00:10:41,520
when you have hardware counter resource

00:10:37,709 --> 00:10:43,950
management well then the software

00:10:41,520 --> 00:10:46,380
counter is backed by a hardware counter

00:10:43,950 --> 00:10:49,920
then you will need some way to say that

00:10:46,380 --> 00:10:52,529
a particular hardware counter resource

00:10:49,920 --> 00:10:55,529
is not available and I think yeah coups

00:10:52,529 --> 00:10:58,560
patches deals with some of that with

00:10:55,529 --> 00:11:00,810
partial stats from hardware or no stats

00:10:58,560 --> 00:11:02,730
from hardware and so on so some of that

00:11:00,810 --> 00:11:05,000
infrastructure can be used can be used

00:11:02,730 --> 00:11:05,000
here

00:11:07,860 --> 00:11:14,330
that's all I have

00:11:10,980 --> 00:11:14,330
any questions so far

00:11:23,040 --> 00:11:29,819
so but when you say add Hardware stats

00:11:26,639 --> 00:11:31,379
does that mean expose Hardware stats or

00:11:29,819 --> 00:11:33,240
can we actually are you talking about

00:11:31,379 --> 00:11:37,709
actually adding new stats in the

00:11:33,240 --> 00:11:39,509
hardware like programmable yeah program

00:11:37,709 --> 00:11:42,600
I'm talking about programmable stats and

00:11:39,509 --> 00:11:44,399
actually getting the stats so when

00:11:42,600 --> 00:11:46,920
you're querying for Bridgeville and

00:11:44,399 --> 00:11:51,350
starts today even if it's backed by a

00:11:46,920 --> 00:11:54,089
hardware violence driver like the ML xsw

00:11:51,350 --> 00:11:56,699
we don't have a hook from the bridge

00:11:54,089 --> 00:12:01,110
driver to get the grab the VLAN starts

00:11:56,699 --> 00:12:05,459
from M lxw right so it's it's supposed

00:12:01,110 --> 00:12:07,560
to hook at that's needed but also what

00:12:05,459 --> 00:12:09,000
what the actual stats are right so if I

00:12:07,560 --> 00:12:10,589
want to create a completely new type of

00:12:09,000 --> 00:12:12,689
stat for a completely new type of

00:12:10,589 --> 00:12:14,160
protocol mm-hm I'm assuming that's

00:12:12,689 --> 00:12:16,560
separate from the hook so the hook

00:12:14,160 --> 00:12:21,410
should be generic to allow any sort of

00:12:16,560 --> 00:12:21,410
stats yes yes that makes sense

00:12:27,690 --> 00:12:32,460
I had a question for EM lxw guys

00:12:30,060 --> 00:12:34,320
actually are you guys implementing VLAN

00:12:32,460 --> 00:12:51,510
stats anytime Hardware wheel and starts

00:12:34,320 --> 00:12:53,220
no well maybe I do news no okay actually

00:12:51,510 --> 00:12:55,170
all the into Linux support the VLAN

00:12:53,220 --> 00:12:58,680
starts but you're right like there is no

00:12:55,170 --> 00:13:01,170
way to pull the standard and recently

00:12:58,680 --> 00:13:03,750
Nikolay added LACP well LACP does it

00:13:01,170 --> 00:13:06,930
have a hardware packing but VLAN stats

00:13:03,750 --> 00:13:11,570
for bridge drivers so both global and

00:13:06,930 --> 00:13:11,570
per VLAN and most Hardware supported

00:13:17,720 --> 00:13:23,049
[Applause]

00:13:46,600 --> 00:13:49,700
[Music]

00:13:50,060 --> 00:13:53,060
yeah

00:14:03,350 --> 00:14:08,180
I

00:14:04,970 --> 00:14:11,330
I'm ago I woke at the Mellanox and I go

00:14:08,180 --> 00:14:13,690
maintain the Emily xsw driver with Jerry

00:14:11,330 --> 00:14:13,690
Pico

00:14:13,980 --> 00:14:24,300
and today's topic we want to talk about

00:14:18,710 --> 00:14:29,550
visibility of packet drops inside the

00:14:24,300 --> 00:14:32,130
house okay so I will give a background

00:14:29,550 --> 00:14:36,270
to make sure that we are all on the same

00:14:32,130 --> 00:14:37,920
page I will give the motivation for what

00:14:36,270 --> 00:14:44,190
you want to talk about and the proposed

00:14:37,920 --> 00:14:47,070
solution so what is the switch the

00:14:44,190 --> 00:14:49,920
correct way to look at it is basically a

00:14:47,070 --> 00:14:55,950
server that has a really big PCI card

00:14:49,920 --> 00:14:59,610
attached and this really big PCI card as

00:14:55,950 --> 00:15:02,550
a switch issac that does the packet

00:14:59,610 --> 00:15:06,740
switching instead of the CPU that is

00:15:02,550 --> 00:15:06,740
attached to this PCI card

00:15:06,920 --> 00:15:13,100
and the way we model it in the kernel is

00:15:10,100 --> 00:15:19,579
that each font panel port is represented

00:15:13,100 --> 00:15:24,139
as an a device and this allows us to

00:15:19,579 --> 00:15:26,239
basically magically offload the huddle

00:15:24,139 --> 00:15:28,989
data path into the ASIC so if you take

00:15:26,239 --> 00:15:32,179
two ports and you put them in a bridge

00:15:28,989 --> 00:15:38,529
we can fold packets between them based

00:15:32,179 --> 00:15:38,529
on the FDB okay which is inside the ASIC

00:15:41,240 --> 00:15:48,860
so in this picture I show like different

00:15:45,240 --> 00:15:51,330
paths packet can take inside the

00:15:48,860 --> 00:15:55,440
Camerons data path as well as in the

00:15:51,330 --> 00:15:58,050
ASIC so for example a packet can do

00:15:55,440 --> 00:16:04,470
bridging in which case it just goes from

00:15:58,050 --> 00:16:08,460
left to right and it can make hit ACL

00:16:04,470 --> 00:16:11,010
rules at ingress and egress TC rules or

00:16:08,460 --> 00:16:13,980
the packet can do routing in which case

00:16:11,010 --> 00:16:16,140
its destination and source mark needs to

00:16:13,980 --> 00:16:18,510
be replaced by the neighbor subsystem

00:16:16,140 --> 00:16:22,920
and then it goes and does bridging again

00:16:18,510 --> 00:16:24,900
and gets out of the EcoSport or you can

00:16:22,920 --> 00:16:26,730
do week slams so you go from the bridge

00:16:24,900 --> 00:16:29,790
the week's line you do voting in the

00:16:26,730 --> 00:16:31,950
underlay and then go out you can do IP

00:16:29,790 --> 00:16:35,640
an IP in which case you do routing twice

00:16:31,950 --> 00:16:37,670
and this is enabled by the Linux kernel

00:16:35,640 --> 00:16:41,790
by different modules in the Linux kernel

00:16:37,670 --> 00:16:45,720
and we basically reflect this data path

00:16:41,790 --> 00:16:47,880
into this switch Asics so today

00:16:45,720 --> 00:16:50,540
America's W supports spectrum one and

00:16:47,880 --> 00:16:50,540
spectrum to

00:16:52,410 --> 00:16:58,950
so as you saw the different packet can

00:16:56,040 --> 00:17:03,570
take different paths in the kernel and

00:16:58,950 --> 00:17:07,429
in the ASIC and these paths can be

00:17:03,570 --> 00:17:11,670
potentially very complex like each

00:17:07,429 --> 00:17:13,620
module that you see here can be very

00:17:11,670 --> 00:17:18,449
complex and can account for various

00:17:13,620 --> 00:17:20,819
drops of why a packet was dropped so

00:17:18,449 --> 00:17:22,500
today when we want to debug the software

00:17:20,819 --> 00:17:25,319
data path and we want to understand why

00:17:22,500 --> 00:17:28,650
or where a packet was dropped we have

00:17:25,319 --> 00:17:30,630
the tools to do it but in case the

00:17:28,650 --> 00:17:33,470
packet wasn't dropped by the kernel and

00:17:30,630 --> 00:17:35,820
it was doped instead by the switch a6

00:17:33,470 --> 00:17:37,500
because really the point is that the

00:17:35,820 --> 00:17:40,230
camera will not see the packets the

00:17:37,500 --> 00:17:42,900
camera will not follow them they instead

00:17:40,230 --> 00:17:45,570
the AC could follow them then basically

00:17:42,900 --> 00:17:47,730
we we have no way to know why the packet

00:17:45,570 --> 00:17:49,970
was dropped and why it did not reach its

00:17:47,730 --> 00:17:49,970
destination

00:17:51,830 --> 00:17:56,930
so I will cover the way that we can

00:17:56,240 --> 00:18:00,320
today

00:17:56,930 --> 00:18:03,260
monotone packet drops in the software

00:18:00,320 --> 00:18:05,570
data path in the kernel and then I will

00:18:03,260 --> 00:18:12,170
go over the proposed solution for the

00:18:05,570 --> 00:18:14,060
output data path so when you want to

00:18:12,170 --> 00:18:17,770
drop a packet you should really call a

00:18:14,060 --> 00:18:21,200
function called K free as KB and this

00:18:17,770 --> 00:18:24,470
function has a trace point in it and to

00:18:21,200 --> 00:18:26,690
which you can attach a probe and one

00:18:24,470 --> 00:18:31,370
model that makes use of this is drop

00:18:26,690 --> 00:18:36,410
monitor which was introduced in 2009 by

00:18:31,370 --> 00:18:39,230
in hormone and it walks over generic net

00:18:36,410 --> 00:18:42,290
link and it's a chat it attaches a probe

00:18:39,230 --> 00:18:47,390
to this ties point and periodically it

00:18:42,290 --> 00:18:50,270
will send you from where k free sk b was

00:18:47,390 --> 00:18:53,440
called and how many times okay so in

00:18:50,270 --> 00:18:59,210
this example you can see that I think I

00:18:53,440 --> 00:19:02,870
like 77 packets that were dropped due to

00:18:59,210 --> 00:19:05,720
IP 'evil and this is because

00:19:02,870 --> 00:19:13,690
I inserted a black hole out that was

00:19:05,720 --> 00:19:17,180
dropping these packets another way to

00:19:13,690 --> 00:19:19,880
debug these drops is by using perf and

00:19:17,180 --> 00:19:23,270
gathering stack crisis and then you can

00:19:19,880 --> 00:19:27,920
see all the paths the packet did until

00:19:23,270 --> 00:19:31,820
it was doped okay so in this case the

00:19:27,920 --> 00:19:35,210
packet was routed and eventually dropped

00:19:31,820 --> 00:19:37,510
by IP a hole was IP received an IPO then

00:19:35,210 --> 00:19:37,510
carefully

00:19:40,330 --> 00:19:47,639
but we lack this visibility when the

00:19:42,999 --> 00:19:50,109
datapath is completely offloaded and

00:19:47,639 --> 00:19:53,349
when the packet folding is done by the

00:19:50,109 --> 00:19:56,409
switch ASIC and one example I want to

00:19:53,349 --> 00:20:00,639
give is a recent issue that I got in

00:19:56,409 --> 00:20:03,719
which a certain user ad like spine oh I

00:20:00,639 --> 00:20:08,080
don't know it was super spine heavy and

00:20:03,719 --> 00:20:11,109
it was connected to four top of rack

00:20:08,080 --> 00:20:14,019
switches and in this picture you can see

00:20:11,109 --> 00:20:19,169
that actually only two links ad traffic

00:20:14,019 --> 00:20:22,119
going over them the rest were idle and

00:20:19,169 --> 00:20:24,669
they noticed in their testing that when

00:20:22,119 --> 00:20:29,229
they disabled these to either links the

00:20:24,669 --> 00:20:31,989
see they still see packet drops on on

00:20:29,229 --> 00:20:37,989
links that supposedly shouldn't be

00:20:31,989 --> 00:20:40,690
affected okay so for like a couple of

00:20:37,989 --> 00:20:43,209
milliseconds that they saw that they had

00:20:40,690 --> 00:20:47,139
like major packet loss and they didn't

00:20:43,209 --> 00:20:51,149
know why and we started debugging this

00:20:47,139 --> 00:20:55,629
issue and the immediate suspect was the

00:20:51,149 --> 00:21:00,099
driver but I couldn't find any reason

00:20:55,629 --> 00:21:03,370
why this would make the switch a sick

00:21:00,099 --> 00:21:06,999
dog packets and then

00:21:03,370 --> 00:21:10,240
I I said okay this is very unlikely but

00:21:06,999 --> 00:21:14,440
maybe the way that this outing demon is

00:21:10,240 --> 00:21:17,019
is implementing a router place where

00:21:14,440 --> 00:21:20,379
it's going from fall neck stops in to to

00:21:17,019 --> 00:21:22,600
is by deleting the order out with the

00:21:20,379 --> 00:21:25,929
fall next stops and then inserting a new

00:21:22,600 --> 00:21:27,820
out with to next next stops and I said

00:21:25,929 --> 00:21:30,190
it doesn't make sense because then you

00:21:27,820 --> 00:21:33,370
have this couple of milliseconds where

00:21:30,190 --> 00:21:35,440
there is no out so buckets adopt and

00:21:33,370 --> 00:21:39,970
when I looked at the code this is

00:21:35,440 --> 00:21:42,580
exactly what I saw so I knew what was

00:21:39,970 --> 00:21:46,539
the problem but only by eliminating

00:21:42,580 --> 00:21:48,639
other reasons and eventually I had to

00:21:46,539 --> 00:21:52,889
look at this outing demons called and

00:21:48,639 --> 00:21:52,889
this is not it's not that far

00:22:01,520 --> 00:22:06,150
so during this period when after you

00:22:04,620 --> 00:22:07,590
delete the old route and insert the new

00:22:06,150 --> 00:22:11,390
out there is no route in packets are

00:22:07,590 --> 00:22:11,390
being dropped and we didn't know why so

00:22:13,790 --> 00:22:21,030
we want to introduce a new mechanism

00:22:17,940 --> 00:22:23,190
that will give us similar visibility to

00:22:21,030 --> 00:22:27,600
what we have and when we try to debug

00:22:23,190 --> 00:22:32,310
the software data path and it relies on

00:22:27,600 --> 00:22:35,250
the fact that your device you're walking

00:22:32,310 --> 00:22:39,000
with can send packets that he decided to

00:22:35,250 --> 00:22:42,780
drop to the host to the CPU okay and

00:22:39,000 --> 00:22:47,070
tell you why he decided to send these

00:22:42,780 --> 00:22:52,170
packets through the CPU so today for

00:22:47,070 --> 00:22:55,020
example each packet that is sent from

00:22:52,170 --> 00:22:57,690
the ASIC across the PCI bus to the CPU

00:22:55,020 --> 00:23:03,930
we know exactly why it was sent it can

00:22:57,690 --> 00:23:05,310
be like a route that is it's a local

00:23:03,930 --> 00:23:08,190
route and you want to locally receive

00:23:05,310 --> 00:23:11,300
this packet so because some ACL is

00:23:08,190 --> 00:23:14,460
trapping these packets to the CPU but

00:23:11,300 --> 00:23:17,550
another reason can be like Noah Oh black

00:23:14,460 --> 00:23:21,350
hole out or angels SDP filter or ingress

00:23:17,550 --> 00:23:21,350
villain filter okay

00:23:21,620 --> 00:23:27,900
so we have these packets coming from the

00:23:24,420 --> 00:23:31,110
ASIC with metadata of why the ASIC

00:23:27,900 --> 00:23:33,630
decided to drop them and the English

00:23:31,110 --> 00:23:37,890
port and time stamp and some drops out

00:23:33,630 --> 00:23:39,900
so the eggless port and all these

00:23:37,890 --> 00:23:41,940
reasons are like standardized they are

00:23:39,900 --> 00:23:44,970
not papaya today reasons they I have a

00:23:41,940 --> 00:23:48,570
very long list of reasons of why the

00:23:44,970 --> 00:23:50,430
device decided to drop a packet and for

00:23:48,570 --> 00:23:54,420
each reason I have a reference in the

00:23:50,430 --> 00:23:57,000
kernel that says if this packet were to

00:23:54,420 --> 00:24:01,620
be switched by the kernel this is where

00:23:57,000 --> 00:24:05,160
it would be dropped and we want to allow

00:24:01,620 --> 00:24:09,060
the user to filter certain drops for

00:24:05,160 --> 00:24:11,990
example on some networks dropping

00:24:09,060 --> 00:24:14,810
packets due to a black hole route can be

00:24:11,990 --> 00:24:18,390
normal and in which case you want to

00:24:14,810 --> 00:24:20,640
tell the device don't send us packets

00:24:18,390 --> 00:24:24,110
that you decided to drop due to a black

00:24:20,640 --> 00:24:24,110
hole out because this is Valley

00:24:25,679 --> 00:24:31,039
so

00:24:27,770 --> 00:24:34,549
filtering based on individual reasons is

00:24:31,039 --> 00:24:38,799
one granularity but we also want to

00:24:34,549 --> 00:24:43,820
allow users to filter based on entire

00:24:38,799 --> 00:24:45,470
stages in the pipeline for example ACL

00:24:43,820 --> 00:24:49,309
drops or layer two drops or layer 3

00:24:45,470 --> 00:24:51,520
drops or buffer drops and these are all

00:24:49,309 --> 00:24:54,289
like standardized groups and studying

00:24:51,520 --> 00:24:58,880
standardised reasons that can be later

00:24:54,289 --> 00:25:01,760
on extended by other users that have

00:24:58,880 --> 00:25:04,760
different use cases like I mainly

00:25:01,760 --> 00:25:07,549
focused on switch a6 but the same

00:25:04,760 --> 00:25:12,130
mechanism can be used for also for East

00:25:07,549 --> 00:25:12,130
witches on hypervisors okay

00:25:15,240 --> 00:25:22,750
so just to make sure that we all

00:25:18,490 --> 00:25:26,410
understand the terminology when a packet

00:25:22,750 --> 00:25:28,570
is sent from the asic from the device to

00:25:26,410 --> 00:25:31,810
the CPU we say that this packet was

00:25:28,570 --> 00:25:34,560
trapped okay this I checked this is not

00:25:31,810 --> 00:25:36,280
only common to us this is like

00:25:34,560 --> 00:25:42,160
terminology that is used across

00:25:36,280 --> 00:25:45,540
different vendors and we as I said

00:25:42,160 --> 00:25:48,490
before we want to allow users to filter

00:25:45,540 --> 00:25:53,640
certain drops or certain group of drops

00:25:48,490 --> 00:25:57,580
and this kind of configuration is

00:25:53,640 --> 00:26:01,210
specific to BAC if it's not specific to

00:25:57,580 --> 00:26:05,770
an a device to a single front panel port

00:26:01,210 --> 00:26:09,820
so given that we need to configure this

00:26:05,770 --> 00:26:12,160
mechanism this mechanism is specific to

00:26:09,820 --> 00:26:16,420
the ASIC instance and not to report then

00:26:12,160 --> 00:26:19,840
we think that using dev link through by

00:26:16,420 --> 00:26:23,710
mentioned to configure it and monitor

00:26:19,840 --> 00:26:25,680
these drops is a good choice and the way

00:26:23,710 --> 00:26:29,350
we envision this will look like is that

00:26:25,680 --> 00:26:32,170
the packet will be dropped by the ASIC

00:26:29,350 --> 00:26:36,030
at the bottom will be sent across the

00:26:32,170 --> 00:26:39,660
PCI bus or whatever bus you are using

00:26:36,030 --> 00:26:41,250
to the CPU to the caramel the camera

00:26:39,660 --> 00:26:43,350
we're seeing okay I got this packet

00:26:41,250 --> 00:26:45,300
because I mean the driver in the kind of

00:26:43,350 --> 00:26:47,850
Racine okay I got this packet because it

00:26:45,300 --> 00:26:50,420
was dropped due to this reason and it

00:26:47,850 --> 00:26:53,880
will generate an ethnic message using

00:26:50,420 --> 00:26:56,220
dev link and send this packet to use of

00:26:53,880 --> 00:26:58,140
space along with the relevant metadata

00:26:56,220 --> 00:27:01,850
such as the da Prez and dingus port

00:26:58,140 --> 00:27:04,700
export and so on

00:27:01,850 --> 00:27:08,300
[Music]

00:27:04,700 --> 00:27:13,490
so SSL we want to use dev link and the

00:27:08,300 --> 00:27:15,110
proposed API is to basically enable or

00:27:13,490 --> 00:27:18,050
disable the entire mechanism it's

00:27:15,110 --> 00:27:22,970
disabled by default obviously and filter

00:27:18,050 --> 00:27:26,390
based on a group or specific tab and if

00:27:22,970 --> 00:27:29,540
you want to monitor current drops you

00:27:26,390 --> 00:27:31,690
can just do with every link packet

00:27:29,540 --> 00:27:31,690
monitor

00:27:31,900 --> 00:27:38,890
which will give you the packet along

00:27:34,900 --> 00:27:41,860
with the metadata and if you only want

00:27:38,890 --> 00:27:43,570
to get statistics like you don't care

00:27:41,860 --> 00:27:45,820
about individual packets you only want

00:27:43,570 --> 00:27:50,290
to know like how many packets will drop

00:27:45,820 --> 00:27:52,950
due to each reason we can use an EBP a

00:27:50,290 --> 00:27:56,020
filter on the anything socket and just

00:27:52,950 --> 00:27:58,770
share these counters using any PF map

00:27:56,020 --> 00:27:58,770
with user space

00:27:59,080 --> 00:28:07,769
I also have like backup slides for the

00:28:03,580 --> 00:28:10,330
moe low level API the National KPI but I

00:28:07,769 --> 00:28:13,739
don't have enough time and we can go

00:28:10,330 --> 00:28:13,739
over it later if you want

00:28:18,520 --> 00:28:21,579
[Music]

00:28:28,630 --> 00:28:33,730
all right this is really cool I like it

00:28:32,170 --> 00:28:35,440
I know Neil would be disappointed if we

00:28:33,730 --> 00:28:37,180
you know patched drop monitor too much

00:28:35,440 --> 00:28:40,210
but it would be interesting to think

00:28:37,180 --> 00:28:42,370
about unifying sort of the two yeah

00:28:40,210 --> 00:28:43,570
maybe a man that's a to be a longer term

00:28:42,370 --> 00:28:45,430
goal I think this infrastructure is

00:28:43,570 --> 00:28:47,770
great but long term would be great if he

00:28:45,430 --> 00:28:49,660
could run drop monitor and instead of

00:28:47,770 --> 00:28:51,070
just printing out like a line number and

00:28:49,660 --> 00:28:53,010
function we could actually add some

00:28:51,070 --> 00:28:55,330
something along the lines of the

00:28:53,010 --> 00:28:57,760
extended act message we could come up

00:28:55,330 --> 00:28:59,290
with a standard format of you know drop

00:28:57,760 --> 00:29:00,550
because it was a black hole route and

00:28:59,290 --> 00:29:03,130
that would be they would appear drop

00:29:00,550 --> 00:29:05,740
monitor and that would work on hardware

00:29:03,130 --> 00:29:10,510
or software for example so you probably

00:29:05,740 --> 00:29:15,820
thought about this yeah I considered

00:29:10,510 --> 00:29:20,650
using top monitor but it has different

00:29:15,820 --> 00:29:24,400
use cases then the harder I think and

00:29:20,650 --> 00:29:27,280
also in most cases we can do better than

00:29:24,400 --> 00:29:28,930
top monitor because for example due to

00:29:27,280 --> 00:29:33,610
the way the code is constructed in the

00:29:28,930 --> 00:29:36,070
kernel the same line in the code is used

00:29:33,610 --> 00:29:39,070
to drop packets due to different reasons

00:29:36,070 --> 00:29:41,410
for example black hole outs and

00:29:39,070 --> 00:29:43,570
reachable allowed no out all discarded

00:29:41,410 --> 00:29:46,060
in the same line of code and we can

00:29:43,570 --> 00:29:47,880
differentiate between all of them so

00:29:46,060 --> 00:29:49,870
yeah I think that'd be an argument for

00:29:47,880 --> 00:29:50,230
improving the way they draw monitor

00:29:49,870 --> 00:29:51,520
works

00:29:50,230 --> 00:29:53,140
yeah cuz I agree with you I've looked at

00:29:51,520 --> 00:29:55,960
it and thought which one of these is it

00:29:53,140 --> 00:29:57,820
but yeah also dope monitor doesn't give

00:29:55,960 --> 00:29:58,510
you the original packet for some reason

00:29:57,820 --> 00:30:01,900
only

00:29:58,510 --> 00:30:04,530
how many times kfb skv was pulled from

00:30:01,900 --> 00:30:04,530
each line

00:30:04,580 --> 00:30:09,479
yes this strengthening if structure

00:30:07,440 --> 00:30:11,759
looks reminds me a bit to the IP tables

00:30:09,479 --> 00:30:14,369
I mean every tables you can enable trace

00:30:11,759 --> 00:30:16,739
you can use the trace target and then

00:30:14,369 --> 00:30:19,169
you can see where the packet is going

00:30:16,739 --> 00:30:20,879
what what what rules are matching or

00:30:19,169 --> 00:30:23,219
what's the reason what's the rule that

00:30:20,879 --> 00:30:24,659
is dropping a packet so I wonder if we

00:30:23,219 --> 00:30:27,570
could add something similar to the rug

00:30:24,659 --> 00:30:30,080
to the routing engine for example so you

00:30:27,570 --> 00:30:33,719
have a toggle that you can enable and

00:30:30,080 --> 00:30:35,659
also using rules in the routing using

00:30:33,719 --> 00:30:38,909
the IP route just to say I want to trace

00:30:35,659 --> 00:30:40,769
so you enable this routing did

00:30:38,909 --> 00:30:43,109
straitening software and we map this to

00:30:40,769 --> 00:30:46,379
hardware so it looks like this

00:30:43,109 --> 00:30:49,369
infrastructure is missing in in in the

00:30:46,379 --> 00:30:49,369
rod engine and in other

00:30:53,170 --> 00:31:00,520
so ASL drops are also supported but if

00:30:57,130 --> 00:31:02,830
you're using the TC action draw like you

00:31:00,520 --> 00:31:04,900
want to know the perfect package took

00:31:02,830 --> 00:31:07,650
inside the AC this is what you're

00:31:04,900 --> 00:31:11,320
talking about you know what I mean is

00:31:07,650 --> 00:31:15,490
yes at similar tracing capabilities to

00:31:11,320 --> 00:31:19,570
other subsystems like route to the rod

00:31:15,490 --> 00:31:22,360
engine to TC so yes through policy use

00:31:19,570 --> 00:31:26,230
the user can specify what kind of what

00:31:22,360 --> 00:31:28,360
kind of traces he wants to get and then

00:31:26,230 --> 00:31:30,820
just mapped up to the hardware which is

00:31:28,360 --> 00:31:34,360
more or less what I have seen right now

00:31:30,820 --> 00:31:38,050
in your presentation so I think it's a

00:31:34,360 --> 00:31:42,240
bit different like I don't think we can

00:31:38,050 --> 00:31:44,919
give you specific points well a pocket

00:31:42,240 --> 00:31:47,980
specific hooks in the hardware packet

00:31:44,919 --> 00:31:49,510
went we can only have specific really

00:31:47,980 --> 00:31:53,880
specific reasons for why I decided to

00:31:49,510 --> 00:31:53,880
drop it but I will look into it

00:32:05,679 --> 00:32:08,679
yeah

00:32:10,960 --> 00:32:17,290
okay yeah so my concern about this and

00:32:14,860 --> 00:32:18,940
it probably is pretty obvious if I'm

00:32:17,290 --> 00:32:21,640
receiving nothing but packets that I'm

00:32:18,940 --> 00:32:23,920
dropping and I'm trying to pipe all this

00:32:21,640 --> 00:32:26,500
stuff up into user space obviously I'm

00:32:23,920 --> 00:32:28,390
gonna overwhelm the interface yeah so I

00:32:26,500 --> 00:32:31,840
don't see how this could replace actual

00:32:28,390 --> 00:32:35,680
statistics in an operational use case

00:32:31,840 --> 00:32:37,270
for tracing it might be fine but I'm

00:32:35,680 --> 00:32:39,310
dropping a million packets per second or

00:32:37,270 --> 00:32:42,940
whatever there has to be statistics and

00:32:39,310 --> 00:32:45,010
presumably if I'm trying to find the

00:32:42,940 --> 00:32:47,080
needle in the haystack in those

00:32:45,010 --> 00:32:48,850
statistics like that one instance of

00:32:47,080 --> 00:32:50,530
packets and really understanding and

00:32:48,850 --> 00:32:53,860
everything else a denial of service

00:32:50,530 --> 00:32:57,070
attack how do you read that out other

00:32:53,860 --> 00:32:58,960
than we have the specific statistics or

00:32:57,070 --> 00:33:01,780
I figure I don't know how you would

00:32:58,960 --> 00:33:02,260
filter for the interesting stuff can you

00:33:01,780 --> 00:33:07,510
comment on that

00:33:02,260 --> 00:33:09,880
yeah so obviously this doesn't this

00:33:07,510 --> 00:33:12,880
mechanism doesn't mean that we don't

00:33:09,880 --> 00:33:14,620
want to extend the counters that we

00:33:12,880 --> 00:33:17,140
currently have and we want to expose

00:33:14,620 --> 00:33:20,900
more of them

00:33:17,140 --> 00:33:22,880
it just needs it just serves like a

00:33:20,900 --> 00:33:25,160
different purpose to tell you exactly

00:33:22,880 --> 00:33:28,670
why it was locked and regarding

00:33:25,160 --> 00:33:29,870
your comment about like millions of

00:33:28,670 --> 00:33:36,260
packets being dropped

00:33:29,870 --> 00:33:41,950
so there we configure policies between

00:33:36,260 --> 00:33:46,010
the ASIC and the CPU so that for each

00:33:41,950 --> 00:33:48,049
reason for which trap reason we have a

00:33:46,010 --> 00:33:51,410
different policy that is saying how many

00:33:48,049 --> 00:33:53,980
packets the ASIC is allowed to send to

00:33:51,410 --> 00:33:53,980
the CPU

00:33:56,929 --> 00:34:00,450
for this reason in this time c'mon I got

00:33:59,239 --> 00:34:07,289
this

00:34:00,450 --> 00:34:08,970
mm-hmm really care about specific yeah I

00:34:07,289 --> 00:34:10,589
don't need to count each one in

00:34:08,970 --> 00:34:13,010
userspace I just need the hardware to

00:34:10,589 --> 00:34:13,010
count those

00:34:15,750 --> 00:34:21,760
the difference is I want you to program

00:34:19,020 --> 00:34:25,740
exactly what the statistics are which

00:34:21,760 --> 00:34:25,740
means I need multiple reasons

00:34:29,500 --> 00:34:37,030
today my point is it's really hard to

00:34:32,830 --> 00:34:41,620
eliminate statistics by just sending out

00:34:37,030 --> 00:34:45,210
yeah yeah so obviously we don't want to

00:34:41,620 --> 00:34:48,909
eliminate statistics we just want to

00:34:45,210 --> 00:34:52,369
augment them with more data

00:34:48,909 --> 00:34:52,369
[Music]

00:34:53,650 --> 00:34:59,340
[Applause]

00:35:07,300 --> 00:35:15,460
so I'm Mario litleo from Mellanox used

00:35:12,370 --> 00:35:22,110
to other companies but no one ox now and

00:35:15,460 --> 00:35:22,110
I want to describe the topic of marvel

00:35:24,170 --> 00:35:27,940
a little bit Marvel for a short time

00:35:40,230 --> 00:35:46,599
anyway I want to describe a problem a

00:35:45,099 --> 00:35:50,440
topic that we've encountered and some

00:35:46,599 --> 00:35:54,160
measures of dealing with it recovering

00:35:50,440 --> 00:35:55,569
from the problem and at least according

00:35:54,160 --> 00:35:57,550
to our understanding this should be

00:35:55,569 --> 00:36:00,520
applicable to any hardware vendor so

00:35:57,550 --> 00:36:03,430
also interested to know how other people

00:36:00,520 --> 00:36:05,700
if they encounter it and how they deal

00:36:03,430 --> 00:36:05,700
with it

00:36:07,170 --> 00:36:15,609
right so I'll try to go quickly through

00:36:13,109 --> 00:36:18,040
defining what the problem is and its

00:36:15,609 --> 00:36:19,510
impacts some existing mitigations but

00:36:18,040 --> 00:36:23,050
which are which help but are ultimately

00:36:19,510 --> 00:36:25,660
not sufficient and describe possible

00:36:23,050 --> 00:36:28,050
solutions and what we did and how it

00:36:25,660 --> 00:36:34,869
ties in to perhaps some other features

00:36:28,050 --> 00:36:38,260
time permitting so a doorbell is

00:36:34,869 --> 00:36:40,180
basically a short message for from the

00:36:38,260 --> 00:36:43,440
host of the device updating the status

00:36:40,180 --> 00:36:43,440
of a cute

00:36:44,000 --> 00:36:50,180
it could be an l2 Q or Rd make you or a

00:36:47,240 --> 00:36:54,740
slow path you doesn't matter classic

00:36:50,180 --> 00:36:56,570
example is a producer update and there

00:36:54,740 --> 00:36:59,300
are many dribbling entities right there

00:36:56,570 --> 00:37:01,010
could be many many l2 cues or many are

00:36:59,300 --> 00:37:04,340
do you make ups actually I think that

00:37:01,010 --> 00:37:06,140
all presentation is going to describe

00:37:04,340 --> 00:37:08,060
something that will increase the

00:37:06,140 --> 00:37:15,109
possibility of hitting this with more

00:37:08,060 --> 00:37:16,550
cues and but the problem that we're that

00:37:15,109 --> 00:37:18,560
I'm describing is is when we have a

00:37:16,550 --> 00:37:22,670
large number of cues there are all

00:37:18,560 --> 00:37:25,099
sending doorbell messages the DQ rate

00:37:22,670 --> 00:37:26,780
within the device from so all these all

00:37:25,099 --> 00:37:30,410
these messages basically go into a queue

00:37:26,780 --> 00:37:33,140
of the device and that Q gets DQ'd by

00:37:30,410 --> 00:37:36,170
the devices it's updating the Q context

00:37:33,140 --> 00:37:37,700
that it carries within it but there is a

00:37:36,170 --> 00:37:39,050
limited rate at which this can be and

00:37:37,700 --> 00:37:42,800
even if it's a very fast rate that we r

00:37:39,050 --> 00:37:45,080
DQ ajiz there's basically there's almost

00:37:42,800 --> 00:37:46,970
no bound on the incoming rate because

00:37:45,080 --> 00:37:49,640
you can always add more CPU stronger

00:37:46,970 --> 00:37:52,609
CPUs to deal with this and if you have

00:37:49,640 --> 00:37:55,760
all the CPUs of a very fast machine only

00:37:52,609 --> 00:37:58,630
sending durable messages because we have

00:37:55,760 --> 00:38:02,420
a very large amount of Q's at some point

00:37:58,630 --> 00:38:04,780
we the device might be losing troubling

00:38:02,420 --> 00:38:04,780
messages

00:38:05,420 --> 00:38:10,250
so what happens if we overflow the queue

00:38:07,790 --> 00:38:12,380
and we lose global messages so this is

00:38:10,250 --> 00:38:14,290
just a diagram right showing the various

00:38:12,380 --> 00:38:16,820
different types of dribbling messages

00:38:14,290 --> 00:38:18,830
doubling entities they can reach the

00:38:16,820 --> 00:38:22,130
device and by the way these exist in

00:38:18,830 --> 00:38:24,580
very indifferent subsystems within the

00:38:22,130 --> 00:38:28,400
kernel right so when I'll describe

00:38:24,580 --> 00:38:30,350
possible mitigations and solutions one

00:38:28,400 --> 00:38:33,760
of the challenges is trying to implement

00:38:30,350 --> 00:38:38,080
something across you know all of these

00:38:33,760 --> 00:38:42,260
locations in the kernel so possible

00:38:38,080 --> 00:38:43,880
impacts if we do not have any recovery

00:38:42,260 --> 00:38:46,580
mechanism for losing d'Oro messages

00:38:43,880 --> 00:38:51,050
could be the l2 teks time-out watchdog

00:38:46,580 --> 00:38:53,690
right probably everybody knows if it's

00:38:51,050 --> 00:38:56,150
an l2 or an our DMA we can get a kewpie

00:38:53,690 --> 00:38:58,640
or CQ error if it's a slow path queue

00:38:56,150 --> 00:39:00,920
that had its message dropped due to the

00:38:58,640 --> 00:39:03,890
overflow then we have a slow path

00:39:00,920 --> 00:39:05,300
message timeout and the recovery

00:39:03,890 --> 00:39:07,160
procedures for these errors can be

00:39:05,300 --> 00:39:10,430
pretty painful right ACK you could close

00:39:07,160 --> 00:39:13,250
the entire PF device would be reset or

00:39:10,430 --> 00:39:14,900
the entire device would be reset so we

00:39:13,250 --> 00:39:19,690
definitely want to avoid these types of

00:39:14,900 --> 00:39:22,190
errors so going quickly through some

00:39:19,690 --> 00:39:24,920
mitigations that already exists so one

00:39:22,190 --> 00:39:26,330
of them is the except more an escapee

00:39:24,920 --> 00:39:28,310
which is a very useful feature that

00:39:26,330 --> 00:39:30,860
basically lets the driver know that

00:39:28,310 --> 00:39:32,660
there are more doorbells upcoming on

00:39:30,860 --> 00:39:34,320
this queue so we don't have to send each

00:39:32,660 --> 00:39:39,780
one

00:39:34,320 --> 00:39:42,240
if we are able to send the information

00:39:39,780 --> 00:39:43,920
that we wanted to send an ad or an

00:39:42,240 --> 00:39:45,450
adorable for this packet at a later

00:39:43,920 --> 00:39:46,950
doorbell then we can just avoid sending

00:39:45,450 --> 00:39:49,590
it put the packet on the ring and not

00:39:46,950 --> 00:39:51,030
send the doorbell throttling down the

00:39:49,590 --> 00:39:53,460
amount of drug bills that we're gonna

00:39:51,030 --> 00:39:54,960
send due to this queue but ultimately

00:39:53,460 --> 00:39:57,360
this is not sufficient because there

00:39:54,960 --> 00:40:00,030
could be more and more queues right it

00:39:57,360 --> 00:40:02,610
only helps for this specific ltq if we

00:40:00,030 --> 00:40:04,860
have hundreds or thousands or tens of

00:40:02,610 --> 00:40:06,290
thousands of l2 queues then basically

00:40:04,860 --> 00:40:10,380
the expect more doesn't help us at all

00:40:06,290 --> 00:40:12,300
and similarly in our DMA post list is

00:40:10,380 --> 00:40:14,340
something similar single queue single

00:40:12,300 --> 00:40:16,020
doorbell for multiple messages but again

00:40:14,340 --> 00:40:18,890
if we have sufficient amount of queues

00:40:16,020 --> 00:40:18,890
it doesn't

00:40:21,530 --> 00:40:26,930
okay so what can we do we can be very

00:40:23,810 --> 00:40:29,450
fast right dick you really quickly but

00:40:26,930 --> 00:40:32,600
like I said ultimately if we bring to

00:40:29,450 --> 00:40:38,180
the problem enough compute power on the

00:40:32,600 --> 00:40:40,970
host side it's bound to fail another

00:40:38,180 --> 00:40:43,310
solution which is pretty nasty but can

00:40:40,970 --> 00:40:46,300
be done is to stall the CPU from the

00:40:43,310 --> 00:40:50,600
device device not returning credit on

00:40:46,300 --> 00:40:52,430
like when we're getting near overflow we

00:40:50,600 --> 00:40:56,210
can stop returning PCI credits basically

00:40:52,430 --> 00:40:58,040
stalling the CPU when it's PCI right but

00:40:56,210 --> 00:41:02,330
this would slow down does it basically

00:40:58,040 --> 00:41:03,530
stop stall the CPU and obviously I has a

00:41:02,330 --> 00:41:04,700
bad effect in the system in general

00:41:03,530 --> 00:41:08,310
especially if you're doing other things

00:41:04,700 --> 00:41:09,730
with your system it's not what you want

00:41:08,310 --> 00:41:12,080
[Music]

00:41:09,730 --> 00:41:14,300
by the way another possible solution

00:41:12,080 --> 00:41:18,350
that's not listed right here but is sort

00:41:14,300 --> 00:41:19,850
of maintained on the host somehow

00:41:18,350 --> 00:41:21,740
distributed across all your door billing

00:41:19,850 --> 00:41:23,930
entities the depth of that queue and the

00:41:21,740 --> 00:41:25,700
device and throttle yourself not to

00:41:23,930 --> 00:41:28,070
overwhelm it but that's again very

00:41:25,700 --> 00:41:29,780
difficult to scale to millions of store

00:41:28,070 --> 00:41:33,980
building entities and requires very deep

00:41:29,780 --> 00:41:36,070
buffering there's also not not a good

00:41:33,980 --> 00:41:41,109
solution because it's not scalable

00:41:36,070 --> 00:41:43,940
finally the solution I wanted to present

00:41:41,109 --> 00:41:46,040
we've been doing in upstream recently

00:41:43,940 --> 00:41:48,950
which is a recovery mechanism recovery

00:41:46,040 --> 00:41:52,430
procedure in the driver so there's a big

00:41:48,950 --> 00:41:53,510
assumption in my recovery solution which

00:41:52,430 --> 00:41:56,780
I don't know if applies to everybody

00:41:53,510 --> 00:41:58,790
which is that the double msgs are

00:41:56,780 --> 00:42:01,850
recoverable in the sense that if I

00:41:58,790 --> 00:42:03,590
discover that a few double msgs for a

00:42:01,850 --> 00:42:07,280
specific you have been lost

00:42:03,590 --> 00:42:09,970
I can resend the last one again and it

00:42:07,280 --> 00:42:12,920
will be like an aggregate effect

00:42:09,970 --> 00:42:14,900
basically convey all the information for

00:42:12,920 --> 00:42:17,180
that queue to the device so I don't have

00:42:14,900 --> 00:42:20,930
to find to reset every message there was

00:42:17,180 --> 00:42:23,270
just the last one again last the current

00:42:20,930 --> 00:42:26,890
state of the queue can be retransmitted

00:42:23,270 --> 00:42:29,000
to the device and that's efficient

00:42:26,890 --> 00:42:32,480
assuming that is that is the case and

00:42:29,000 --> 00:42:35,390
you have a device that can get doorbells

00:42:32,480 --> 00:42:38,570
in this aggregate of fashion then comes

00:42:35,390 --> 00:42:41,810
the question which so when we discover

00:42:38,570 --> 00:42:45,290
that an overflow happens which ones well

00:42:41,810 --> 00:42:47,840
do we want to recover and this really

00:42:45,290 --> 00:42:49,520
depends on the quality of the

00:42:47,840 --> 00:42:51,320
information that your device can can

00:42:49,520 --> 00:42:53,270
deliver if it tells you exactly which

00:42:51,320 --> 00:42:54,440
queues were overflowed or just an

00:42:53,270 --> 00:42:55,970
overflow occurred and then you basically

00:42:54,440 --> 00:42:59,750
need to recover every one because you

00:42:55,970 --> 00:43:01,840
don't know where the drop occurred at

00:42:59,750 --> 00:43:04,130
this solution might seem a little bit

00:43:01,840 --> 00:43:05,750
strange fighting fire with fire because

00:43:04,130 --> 00:43:07,580
we lost we're in a situation we're

00:43:05,750 --> 00:43:08,810
losing doorbells so let's read or bill

00:43:07,580 --> 00:43:11,359
all the cues again so we're adding more

00:43:08,810 --> 00:43:14,520
doorbells to the problem but again since

00:43:11,359 --> 00:43:16,900
they're aggregative we're basically

00:43:14,520 --> 00:43:18,310
even if we lose a lot of the troubles

00:43:16,900 --> 00:43:18,790
even if we lose a high percent of the

00:43:18,310 --> 00:43:20,650
doorbells

00:43:18,790 --> 00:43:22,360
if we keep read or billing on all the

00:43:20,650 --> 00:43:26,320
cute bees we're updating the status for

00:43:22,360 --> 00:43:28,120
for all of them so getting better

00:43:26,320 --> 00:43:30,760
information from the device and which

00:43:28,120 --> 00:43:36,640
cues needed is best but even if we don't

00:43:30,760 --> 00:43:38,710
have that the solution works okay so up

00:43:36,640 --> 00:43:42,640
to here is just stating what the problem

00:43:38,710 --> 00:43:44,050
is and some of the solutions like there

00:43:42,640 --> 00:43:46,180
if there are any questions and also like

00:43:44,050 --> 00:43:49,860
to hear from the other hardware vendors

00:43:46,180 --> 00:43:49,860
they also encountered this problem

00:44:02,059 --> 00:44:06,709
I I'm not sure I agree with your

00:44:04,459 --> 00:44:09,379
characterization of the problem the in

00:44:06,709 --> 00:44:12,499
case of doorbell overflow if you're

00:44:09,379 --> 00:44:15,259
taking a modern CPU we can run way

00:44:12,499 --> 00:44:18,439
greater than like a gentry by 8 or Gen 4

00:44:15,259 --> 00:44:20,479
by 16 type PCI connections which means

00:44:18,439 --> 00:44:22,939
you lose PCI credits the moment you lose

00:44:20,479 --> 00:44:25,729
PCI credits you've stalled the PCI root

00:44:22,939 --> 00:44:28,219
complex which means now your NIC is dead

00:44:25,729 --> 00:44:30,109
it's got nothing else going on right

00:44:28,219 --> 00:44:32,389
it's not just a CPU it's not just a

00:44:30,109 --> 00:44:34,789
resettable condition and you do not have

00:44:32,389 --> 00:44:37,249
pci credit so that you can send the next

00:44:34,789 --> 00:44:39,919
doorbell update so that you can fix it

00:44:37,249 --> 00:44:41,869
if if your condition that you're hitting

00:44:39,919 --> 00:44:45,079
is the case that you could actually get

00:44:41,869 --> 00:44:48,079
it across PCI and n:q it in the device

00:44:45,079 --> 00:44:52,149
fast enough then and only then is your

00:44:48,079 --> 00:44:54,979
solution going to work I accept that but

00:44:52,149 --> 00:44:57,229
so I have encountered a real life

00:44:54,979 --> 00:45:02,089
solution we're losing doorbells but

00:44:57,229 --> 00:45:03,559
because that Q is overflown but right so

00:45:02,089 --> 00:45:06,219
that's a that's an assumption of a

00:45:03,559 --> 00:45:08,329
hardware design that you have a leaky

00:45:06,219 --> 00:45:11,659
destination Q right basically you're

00:45:08,329 --> 00:45:14,269
draining PCI fast enough that you can

00:45:11,659 --> 00:45:16,099
take the output out depending on your

00:45:14,269 --> 00:45:19,159
route complex that may or may not always

00:45:16,099 --> 00:45:20,329
be true except that this is very so this

00:45:19,159 --> 00:45:21,859
entire thing comes from a specific

00:45:20,329 --> 00:45:23,029
hardware vendor right we encounter a

00:45:21,859 --> 00:45:25,419
problem and solve it I'm really

00:45:23,029 --> 00:45:27,919
interested to hear about the other ones

00:45:25,419 --> 00:45:29,869
sure so I guess I'll my high-level

00:45:27,919 --> 00:45:31,729
comment is this generally it won't apply

00:45:29,869 --> 00:45:35,779
generically unless and until you have

00:45:31,729 --> 00:45:38,149
this very special setup where right no

00:45:35,779 --> 00:45:39,469
no the problem is very relevant I mean

00:45:38,149 --> 00:45:40,699
the current solution right now is you

00:45:39,469 --> 00:45:42,979
have a dead machine at the end of the

00:45:40,699 --> 00:45:44,859
day because you are out of PCI credits

00:45:42,979 --> 00:45:47,539
your only option is a reset which is a

00:45:44,859 --> 00:45:48,340
root complex reset which is a host reset

00:45:47,539 --> 00:45:52,710
at that point

00:45:48,340 --> 00:45:59,590
right so any other hardware vendors have

00:45:52,710 --> 00:46:03,730
encountered the problem thank you

00:45:59,590 --> 00:46:08,230
so in Mellanox devices we don't we don't

00:46:03,730 --> 00:46:10,450
back pressure the PCI so it will always

00:46:08,230 --> 00:46:13,030
have it will always have credits for

00:46:10,450 --> 00:46:16,750
doubles that's one thing and the second

00:46:13,030 --> 00:46:21,190
thing is that we see doorbell being lost

00:46:16,750 --> 00:46:23,770
is very rare we still so we have

00:46:21,190 --> 00:46:25,690
hardware mechanism for that so if if

00:46:23,770 --> 00:46:28,450
that will happen we have hardware

00:46:25,690 --> 00:46:32,290
mechanism that it will recover itself

00:46:28,450 --> 00:46:34,420
and just continue how does the hardware

00:46:32,290 --> 00:46:37,480
read from the host the global state

00:46:34,420 --> 00:46:40,060
because we never stop the double so part

00:46:37,480 --> 00:46:45,790
of the information is being kept and it

00:46:40,060 --> 00:46:47,590
remembers that it has doorbell and the

00:46:45,790 --> 00:46:49,570
information from the host yes so you

00:46:47,590 --> 00:46:51,670
register with the hardware the virtual

00:46:49,570 --> 00:46:53,890
address on the host that the whole thing

00:46:51,670 --> 00:46:58,120
it knows all its SKUs so it understand

00:46:53,890 --> 00:47:01,630
already how to where to fetch the

00:46:58,120 --> 00:47:04,600
doorbell right so actually that's pretty

00:47:01,630 --> 00:47:07,300
similar to what we do although some some

00:47:04,600 --> 00:47:08,860
of that is done in software right but so

00:47:07,300 --> 00:47:13,060
let me describe a little bit more in

00:47:08,860 --> 00:47:15,720
detail sure our own solution so

00:47:13,060 --> 00:47:19,540
basically what what we've implemented is

00:47:15,720 --> 00:47:21,430
maintaining a database of all the

00:47:19,540 --> 00:47:23,860
troubling entities that we've got

00:47:21,430 --> 00:47:28,110
regardless of whether they are for fast

00:47:23,860 --> 00:47:33,810
path or slow bad for our D mayor

00:47:28,110 --> 00:47:36,900
even for storage where we register them

00:47:33,810 --> 00:47:44,670
all and set up and keep track of them

00:47:36,900 --> 00:47:46,530
and so whether we are in in our DMA or

00:47:44,670 --> 00:47:48,270
l2 or even the storage substance

00:47:46,530 --> 00:47:53,250
subsystems we also have storage drivers

00:47:48,270 --> 00:47:57,300
in this device we just register the area

00:47:53,250 --> 00:47:57,690
and host which is keeping the verbal

00:47:57,300 --> 00:47:58,890
state

00:47:57,690 --> 00:48:02,490
this is registration with the driver

00:47:58,890 --> 00:48:05,340
right not with the device and when this

00:48:02,490 --> 00:48:09,930
when the problem occurs we can traverse

00:48:05,340 --> 00:48:13,140
this list and obtain the cue data and

00:48:09,930 --> 00:48:15,180
read or they'll basically refreshing all

00:48:13,140 --> 00:48:20,130
of the drawer those with their most

00:48:15,180 --> 00:48:21,660
current state and this is useful because

00:48:20,130 --> 00:48:23,220
this is sort of an under the hood

00:48:21,660 --> 00:48:24,840
solution in the sense that the drawer

00:48:23,220 --> 00:48:26,220
billing entities themselves do two

00:48:24,840 --> 00:48:28,640
queues or already make users whatever

00:48:26,220 --> 00:48:31,320
are unaware that it's happening only at

00:48:28,640 --> 00:48:32,850
creation or teardown they need to

00:48:31,320 --> 00:48:38,060
register with the mechanism but they're

00:48:32,850 --> 00:48:38,060
unaware that this is occurring

00:48:38,410 --> 00:48:43,640
[Music]

00:48:40,910 --> 00:48:45,710
right so it is a special case so

00:48:43,640 --> 00:48:47,420
question on that how do you recognize

00:48:45,710 --> 00:48:48,920
the condition how do you know that this

00:48:47,420 --> 00:48:50,270
condition has happened so we get an

00:48:48,920 --> 00:48:52,390
attention from the device where the

00:48:50,270 --> 00:48:55,910
device can can indicate the

00:48:52,390 --> 00:48:57,830
overflow has occurred ah okay so your

00:48:55,910 --> 00:49:01,130
condition your trigger is that I

00:48:57,830 --> 00:49:03,800
actually went past and somebody wrote an

00:49:01,130 --> 00:49:05,690
a20 end of my cue that's your trigger so

00:49:03,800 --> 00:49:07,550
I also have an almost full threshold

00:49:05,690 --> 00:49:09,230
which I can configure right so I can

00:49:07,550 --> 00:49:11,150
react even before the problem happens

00:49:09,230 --> 00:49:14,000
okay so you're signaling to the driver

00:49:11,150 --> 00:49:18,400
before you get to the full condition

00:49:14,000 --> 00:49:18,400
that you might have to recycle me again

00:49:20,290 --> 00:49:25,070
[Music]

00:49:21,550 --> 00:49:27,470
okay so a bit of a complexity is the

00:49:25,070 --> 00:49:30,560
right combined buffer some of you might

00:49:27,470 --> 00:49:34,340
know as a method when the doorbell is

00:49:30,560 --> 00:49:37,040
basically not an atomic message of 32 or

00:49:34,340 --> 00:49:38,720
64 bytes but a full packet that's being

00:49:37,040 --> 00:49:43,190
flushed into the drawer bell or some

00:49:38,720 --> 00:49:46,520
inline data but that can also be handled

00:49:43,190 --> 00:49:48,830
if we recognize that it happens and the

00:49:46,520 --> 00:49:50,270
device does not process because the

00:49:48,830 --> 00:49:52,700
problem could be that we get partial

00:49:50,270 --> 00:49:54,350
messages right we get part of a right

00:49:52,700 --> 00:49:56,840
combined message and the rest was

00:49:54,350 --> 00:49:57,910
dropped but that can be handled because

00:49:56,840 --> 00:50:01,300
the

00:49:57,910 --> 00:50:03,010
if we read or bill all the QPS again it

00:50:01,300 --> 00:50:07,380
might not be a right combined message

00:50:03,010 --> 00:50:10,780
but there is a non right combined or non

00:50:07,380 --> 00:50:18,820
in mind fall back for any for every such

00:50:10,780 --> 00:50:20,770
case so I have time so just a few more

00:50:18,820 --> 00:50:23,320
seconds so for few so one of the things

00:50:20,770 --> 00:50:25,120
that we've discovered from this is

00:50:23,320 --> 00:50:27,100
they're getting more useful information

00:50:25,120 --> 00:50:32,680
from the hardware and exactly which cue

00:50:27,100 --> 00:50:36,910
peas or cues or drawing entities have

00:50:32,680 --> 00:50:38,980
experienced the overflow can make the

00:50:36,910 --> 00:50:40,510
recovery more efficient of course we

00:50:38,980 --> 00:50:42,820
won't have to recover everything but

00:50:40,510 --> 00:50:46,039
just those specific use

00:50:42,820 --> 00:50:46,039
[Music]

00:50:47,020 --> 00:50:52,480
and the existing mitigations that that

00:50:49,450 --> 00:50:54,670
we have in colonel so especially on

00:50:52,480 --> 00:50:56,290
rocky which which is a great contributor

00:50:54,670 --> 00:50:58,780
to this problem if you have a mix of l2

00:50:56,290 --> 00:51:01,170
and rocky walk you can easily scale to

00:50:58,780 --> 00:51:04,750
millions of q Peas

00:51:01,170 --> 00:51:06,430
unlike ethernet where the mitigation is

00:51:04,750 --> 00:51:07,710
basically always in place the Explorer

00:51:06,430 --> 00:51:10,510
it's part of the SDP

00:51:07,710 --> 00:51:13,240
post list depends on the rock the

00:51:10,510 --> 00:51:16,840
application whether or not to use so use

00:51:13,240 --> 00:51:19,470
it more to avoid this problem all right

00:51:16,840 --> 00:51:19,470
any questions

00:51:28,770 --> 00:51:33,900
so the solution which are proposing the

00:51:31,410 --> 00:51:36,060
right combining buffer if you use that

00:51:33,900 --> 00:51:38,490
wouldn't you have partial rights and

00:51:36,060 --> 00:51:41,190
partial reads those type of protection

00:51:38,490 --> 00:51:42,750
on the bus directly so the point I was

00:51:41,190 --> 00:51:45,000
trying to make is that we already use

00:51:42,750 --> 00:51:48,540
right combine buffers and the double

00:51:45,000 --> 00:51:52,110
overflow problem leads us in this case

00:51:48,540 --> 00:51:53,970
exactly to that - you might have half of

00:51:52,110 --> 00:51:56,670
a half of a right combined message and

00:51:53,970 --> 00:52:01,950
then you've lost the rest but because

00:51:56,670 --> 00:52:03,900
the at least in our case in the inline

00:52:01,950 --> 00:52:06,390
cases where we use the right combine we

00:52:03,900 --> 00:52:09,510
always put backup in place right so we

00:52:06,390 --> 00:52:11,340
put the packet on the ring as well as

00:52:09,510 --> 00:52:13,380
sending it directly into the door so if

00:52:11,340 --> 00:52:16,410
this happens basically device stops

00:52:13,380 --> 00:52:18,150
handling right right combined or inline

00:52:16,410 --> 00:52:20,820
messages but we flush all of the

00:52:18,150 --> 00:52:22,050
existing ones and rely and the packet

00:52:20,820 --> 00:52:23,550
that's already in the ring right so we

00:52:22,050 --> 00:52:26,700
lose the low-latency that we might have

00:52:23,550 --> 00:52:32,220
had but we maintain correctness right

00:52:26,700 --> 00:52:36,830
still do the correct data saying it is

00:52:32,220 --> 00:52:36,830
handled through the postal rates right

00:52:40,860 --> 00:52:46,050
[Applause]

00:53:00,920 --> 00:53:04,790
yeah excellence hasn't started yes I was

00:53:03,620 --> 00:53:08,740
gonna ask for a short technical

00:53:04,790 --> 00:53:10,670
extension but yeah that's just rubbish

00:53:08,740 --> 00:53:14,750
accident

00:53:10,670 --> 00:53:16,820
so I'm Peter Joseph and Fearon working

00:53:14,750 --> 00:53:19,180
for metronome and I'll be talking about

00:53:16,820 --> 00:53:23,740
quality of service English rate limiting

00:53:19,180 --> 00:53:23,740
which I assume I need to use this

00:53:30,660 --> 00:53:39,460
okay so first off let's just talk about

00:53:35,880 --> 00:53:41,290
QoS in aqs for OBS and particularly what

00:53:39,460 --> 00:53:42,700
we are going to talk about now we're

00:53:41,290 --> 00:53:45,250
going to talk about English rate

00:53:42,700 --> 00:53:47,850
limiting greatly limiting or policing so

00:53:45,250 --> 00:53:50,470
I might use those terms interchangeably

00:53:47,850 --> 00:53:51,550
but I'm referring to ingress rate

00:53:50,470 --> 00:53:57,480
limiting

00:53:51,550 --> 00:54:01,360
well I'm not talking about years sure

00:53:57,480 --> 00:54:02,770
this doesn't complicate it anyway what

00:54:01,360 --> 00:54:04,840
I'm not going to talk about right now

00:54:02,770 --> 00:54:05,870
obviously we can we can talk about the

00:54:04,840 --> 00:54:07,590
questions

00:54:05,870 --> 00:54:11,650
[Music]

00:54:07,590 --> 00:54:15,840
flow based metering said with vo said

00:54:11,650 --> 00:54:19,450
queue shaping on egress so in terms of

00:54:15,840 --> 00:54:20,800
English rate limiting we're talking

00:54:19,450 --> 00:54:25,540
about English rate limiting from the

00:54:20,800 --> 00:54:27,650
perspective of too soft I guess from the

00:54:25,540 --> 00:54:30,020
perspective of the hypervisor

00:54:27,650 --> 00:54:33,530
so that's the English traffic on tap

00:54:30,020 --> 00:54:36,080
zero in the in the diagram I shamefully

00:54:33,530 --> 00:54:37,850
shamefully stole this diagram just for

00:54:36,080 --> 00:54:41,980
what it's worth but you'll see the

00:54:37,850 --> 00:54:45,260
source data so let's look at OBS

00:54:41,980 --> 00:54:50,090
traditionally your book or before TC

00:54:45,260 --> 00:54:53,240
offload if we configure a rate limiter

00:54:50,090 --> 00:54:56,480
in OBS without having TC offloads enable

00:54:53,240 --> 00:54:59,510
obvious would go and configure of TC

00:54:56,480 --> 00:55:01,430
filter with the basic classifier this is

00:54:59,510 --> 00:55:04,490
what judicially does and then uses

00:55:01,430 --> 00:55:08,240
policing for yeah for reckoning

00:55:04,490 --> 00:55:11,120
so this rules slightly cut off for what

00:55:08,240 --> 00:55:16,430
it's worth but you'll see a more full

00:55:11,120 --> 00:55:19,630
term later on now what OBS has done here

00:55:16,430 --> 00:55:19,630
implicitly is

00:55:19,970 --> 00:55:27,320
it's created an inherent priority so our

00:55:23,840 --> 00:55:30,080
TC policer will grab the packet first

00:55:27,320 --> 00:55:32,720
get the packet first and then only after

00:55:30,080 --> 00:55:35,900
it has hand of the packet the Colonel

00:55:32,720 --> 00:55:38,810
OBS data path gets the packets so there

00:55:35,900 --> 00:55:41,920
is this inherited priority already now

00:55:38,810 --> 00:55:45,290
if we fast forward a bit and we enable

00:55:41,920 --> 00:55:49,400
rate limiting I am able to see offload

00:55:45,290 --> 00:55:50,060
and we try again to configure a rate an

00:55:49,400 --> 00:55:54,380
answer

00:55:50,060 --> 00:55:56,000
OBS will reply in the logs recently for

00:55:54,380 --> 00:55:59,510
leasing with offload isn't supported

00:55:56,000 --> 00:56:01,880
meaning that we can't support rate

00:55:59,510 --> 00:56:04,840
limiting when you have TC offload

00:56:01,880 --> 00:56:08,599
enabled so it ignores your rate limit

00:56:04,840 --> 00:56:15,250
now just be warned

00:56:08,599 --> 00:56:17,920
now yeah so if we look at

00:56:15,250 --> 00:56:19,390
how to correct this or how to fix this

00:56:17,920 --> 00:56:21,970
the first thing that you might think

00:56:19,390 --> 00:56:25,210
maybe let's go ahead and just remove

00:56:21,970 --> 00:56:28,240
this restriction and allow OVS to

00:56:25,210 --> 00:56:31,410
install this basic basic filter but

00:56:28,240 --> 00:56:34,869
worth with the TT offloads well that's

00:56:31,410 --> 00:56:40,630
insufficient not sufficient so I'm gonna

00:56:34,869 --> 00:56:43,619
work and partly because many because

00:56:40,630 --> 00:56:47,380
this ordering issue this priority issue

00:56:43,619 --> 00:56:49,329
we don't know which part of the data or

00:56:47,380 --> 00:56:50,859
which filter will get grabbed the packet

00:56:49,329 --> 00:56:53,339
first and it will actually depend on

00:56:50,859 --> 00:56:57,790
when you configure your regular matter

00:56:53,339 --> 00:57:01,510
so we do need to introduce priority

00:56:57,790 --> 00:57:05,079
somehow and additionally the basic

00:57:01,510 --> 00:57:08,440
filter is not iq4 offload we actually

00:57:05,079 --> 00:57:10,869
prefer something like nacho or even the

00:57:08,440 --> 00:57:12,280
flower classifier we decided on in the

00:57:10,869 --> 00:57:13,630
meantime we've decided on the match oh

00:57:12,280 --> 00:57:18,460
because it more closely follows the

00:57:13,630 --> 00:57:21,819
design of es so we've gone head with all

00:57:18,460 --> 00:57:23,740
classes website but I mean it's it's

00:57:21,819 --> 00:57:27,640
feasible using a classifier as well for

00:57:23,740 --> 00:57:29,619
the rate limiter then secondly what we

00:57:27,640 --> 00:57:33,940
did is we introduced the notion of

00:57:29,619 --> 00:57:37,810
priorities and OBS reserved priority so

00:57:33,940 --> 00:57:40,060
we've moved on our traditional TC data

00:57:37,810 --> 00:57:44,319
path which which by the way is

00:57:40,060 --> 00:57:46,930
implemented with TC flower but we've

00:57:44,319 --> 00:57:49,780
moved that on with a priority offset so

00:57:46,930 --> 00:57:51,790
all those rules will get installed at an

00:57:49,780 --> 00:57:55,089
offset priority and we reserve the

00:57:51,790 --> 00:57:58,410
highest priority for something like Ray

00:57:55,089 --> 00:58:02,820
Clemence question yeah sure

00:57:58,410 --> 00:58:05,580
where is ovation what okay when you

00:58:02,820 --> 00:58:07,680
reserved desert so axis gonna user

00:58:05,580 --> 00:58:10,410
install this so you have to go through

00:58:07,680 --> 00:58:13,020
the agent well they they go through OBS

00:58:10,410 --> 00:58:15,390
so I do have an example at the end

00:58:13,020 --> 00:58:18,090
there's obvious Carol's but that we will

00:58:15,390 --> 00:58:21,510
use to configure and I think that'll

00:58:18,090 --> 00:58:25,110
answer your question but yeah the user

00:58:21,510 --> 00:58:27,720
that the user of OBS doesn't see the

00:58:25,110 --> 00:58:35,910
priority this is all in and handled by

00:58:27,720 --> 00:58:38,880
OBS okay so by doing this we can then

00:58:35,910 --> 00:58:41,190
actually get Hardware offload wishes

00:58:38,880 --> 00:58:46,080
which is great and some vendors can do

00:58:41,190 --> 00:58:47,760
this already and unfortunately we're not

00:58:46,080 --> 00:58:51,600
completely there we're still left with

00:58:47,760 --> 00:58:53,220
two issues and the first issue is what I

00:58:51,600 --> 00:58:55,920
like to call the software hardware issue

00:58:53,220 --> 00:58:58,350
is when you're to lead that your TC

00:58:55,920 --> 00:59:02,160
policer is installed and software but

00:58:58,350 --> 00:59:04,530
your subsequent filters there are at

00:59:02,160 --> 00:59:08,190
lower priority get gets offloaded to

00:59:04,530 --> 00:59:10,530
smart Nick this will at the very least

00:59:08,190 --> 00:59:11,850
reduce performance and what I'm talking

00:59:10,530 --> 00:59:13,410
about performance I'm not just talking

00:59:11,850 --> 00:59:15,270
about throughput because packets willing

00:59:13,410 --> 00:59:17,390
to fall back to to the hosts for

00:59:15,270 --> 00:59:19,110
processing so there's definitely

00:59:17,390 --> 00:59:21,930
performance it in terms of throughput

00:59:19,110 --> 00:59:23,970
but you'll take but also your CPU will

00:59:21,930 --> 00:59:27,720
now need to handle these packets which

00:59:23,970 --> 00:59:32,089
we dearly want to avoid happening

00:59:27,720 --> 00:59:35,790
so that's that's the performance issue

00:59:32,089 --> 00:59:38,780
apart from that if you're smart neck is

00:59:35,790 --> 00:59:43,650
not aware that this rate limiter is

00:59:38,780 --> 00:59:46,290
installed in software first we could

00:59:43,650 --> 00:59:47,790
break semantics so the packet would get

00:59:46,290 --> 00:59:49,800
to the smart make it now needs to

00:59:47,790 --> 00:59:51,480
realize it needs to fall back to the

00:59:49,800 --> 00:59:53,609
house and if it's not aware that it

00:59:51,480 --> 00:59:56,520
needs to fall back it'll directly go to

00:59:53,609 --> 00:59:58,980
TC filters and just ignore your rate

00:59:56,520 --> 01:00:01,220
limiter without telling you so this

00:59:58,980 --> 01:00:03,390
could be a serious issue

01:00:01,220 --> 01:00:05,910
second issues without but I call the

01:00:03,390 --> 01:00:07,890
hardware software issue that's just the

01:00:05,910 --> 01:00:09,690
reverse again we'll see lower

01:00:07,890 --> 01:00:13,859
performance again packets will need to

01:00:09,690 --> 01:00:16,050
fall back to do the house but at least

01:00:13,859 --> 01:00:19,790
then hopefully we've dropped some of

01:00:16,050 --> 01:00:21,690
them because of the rate limiter but

01:00:19,790 --> 01:00:24,450
most smoth NICs

01:00:21,690 --> 01:00:28,740
at least know when a filter has not been

01:00:24,450 --> 01:00:31,589
installed in hardware and know that it

01:00:28,740 --> 01:00:33,450
is in fact installed in software in

01:00:31,589 --> 01:00:38,849
terms of the TC data path so in this

01:00:33,450 --> 01:00:39,960
particular case we still expect smart

01:00:38,849 --> 01:00:41,520
next to function correctly

01:00:39,960 --> 01:00:43,829
oh that's the system as a whole to

01:00:41,520 --> 01:00:46,140
function correctly now we do have two

01:00:43,829 --> 01:00:50,000
solutions we've selected the first

01:00:46,140 --> 01:00:52,950
solution just based on simplicity and

01:00:50,000 --> 01:00:54,420
it's for in particular group we're not

01:00:52,950 --> 01:00:56,099
caring about the hardware software one

01:00:54,420 --> 01:00:57,119
because we're assuming the semantics is

01:00:56,099 --> 01:01:00,089
fine and you're going to live with the

01:00:57,119 --> 01:01:03,329
performance here but in the software

01:01:00,089 --> 01:01:05,190
hardware case we've reverted back to the

01:01:03,329 --> 01:01:07,430
original semantics of not allowing you

01:01:05,190 --> 01:01:11,450
to install subsequent

01:01:07,430 --> 01:01:13,700
filters or not sorry that's the second

01:01:11,450 --> 01:01:17,170
solution we've reverted to the original

01:01:13,700 --> 01:01:23,060
semantics of not allowing you to install

01:01:17,170 --> 01:01:26,270
police when you yeah saying police is

01:01:23,060 --> 01:01:27,620
not a neighbor isn't supported but what

01:01:26,270 --> 01:01:30,950
you could also have done is you could

01:01:27,620 --> 01:01:33,020
have had OVS force all TC filters or

01:01:30,950 --> 01:01:34,880
subsequent TC filters that implements

01:01:33,020 --> 01:01:37,340
the data path to be installed in

01:01:34,880 --> 01:01:41,450
software as well sorry that was a bit

01:01:37,340 --> 01:01:44,870
rough so now we get to the example and I

01:01:41,450 --> 01:01:46,040
think Jamal this should also similar to

01:01:44,870 --> 01:01:48,170
most questions but this is just

01:01:46,040 --> 01:01:50,570
shamelessly stolen from the obvious

01:01:48,170 --> 01:01:52,280
documentation so hopefully you guys will

01:01:50,570 --> 01:01:54,440
get the slide somewhere be able to

01:01:52,280 --> 01:01:59,270
follow that otherwise you just look it

01:01:54,440 --> 01:02:00,920
up on the OBS website but essentially

01:01:59,270 --> 01:02:02,240
what we're going to do here is we're

01:02:00,920 --> 01:02:04,460
going to set up to be M so we're gonna

01:02:02,240 --> 01:02:06,530
write them at BM one-to-one megabits per

01:02:04,460 --> 01:02:08,000
second and BM to to 10 megabits per

01:02:06,530 --> 01:02:10,880
second then we're going to use net birth

01:02:08,000 --> 01:02:12,980
to confirm those results and then

01:02:10,880 --> 01:02:19,220
there's just some useful scuttles that

01:02:12,980 --> 01:02:23,090
or tools that we use along the way my

01:02:19,220 --> 01:02:24,170
favorite ones so enabling TC or Fleur

01:02:23,090 --> 01:02:26,780
this is pretty standard

01:02:24,170 --> 01:02:29,450
I'm just hardware or float true and then

01:02:26,780 --> 01:02:32,120
TC policy was none you can also set this

01:02:29,450 --> 01:02:34,400
to skip software or other things but by

01:02:32,120 --> 01:02:39,260
default this is fairly the stat of

01:02:34,400 --> 01:02:42,530
standard practice to to use TC possible

01:02:39,260 --> 01:02:46,520
TC floats then we go and add bridges and

01:02:42,530 --> 01:02:47,910
interfaces so obvious scuttle at your

01:02:46,520 --> 01:02:50,339
zero

01:02:47,910 --> 01:02:56,519
nowadays I call this beer exit and then

01:02:50,339 --> 01:02:58,140
I delete it in protest but basically we

01:02:56,519 --> 01:03:02,690
just add our bridges we add our

01:02:58,140 --> 01:03:07,140
interfaces and you'll note that I've

01:03:02,690 --> 01:03:10,759
slightly edited the diagram to just

01:03:07,140 --> 01:03:15,359
represent our net death names instead

01:03:10,759 --> 01:03:18,390
then this is where Jamal's question

01:03:15,359 --> 01:03:21,029
comes in so this is the via scuttle that

01:03:18,390 --> 01:03:23,190
you will be using to configure the right

01:03:21,029 --> 01:03:27,440
limiter and this will translate to a

01:03:23,190 --> 01:03:32,640
match all a filter with police action

01:03:27,440 --> 01:03:35,630
with the priority of one in a obvious

01:03:32,640 --> 01:03:37,589
TTC and then we'll offload that

01:03:35,630 --> 01:03:42,329
subsequently what you can do is

01:03:37,589 --> 01:03:43,890
configure your flows now in terms of

01:03:42,329 --> 01:03:45,809
configuring flow so you could have used

01:03:43,890 --> 01:03:47,759
normal here as well but this is just a

01:03:45,809 --> 01:03:53,870
point in illustrate these we expect to

01:03:47,759 --> 01:03:55,680
be translated to TC flower filters and

01:03:53,870 --> 01:03:58,110
[Music]

01:03:55,680 --> 01:04:02,910
yeah and they should you work in unison

01:03:58,110 --> 01:04:05,370
so we then fire up net perf on bm1 net

01:04:02,910 --> 01:04:07,710
server on my measurement host this is

01:04:05,370 --> 01:04:10,470
all just from the game from the obvious

01:04:07,710 --> 01:04:13,470
documentation obvious example use case

01:04:10,470 --> 01:04:16,560
and we see we get about 1 millisecond

01:04:13,470 --> 01:04:20,280
regular as we can repeat it on vm 2 and

01:04:16,560 --> 01:04:22,020
we'll see 10 megabits per second then we

01:04:20,280 --> 01:04:27,800
get to see some of these useful cool

01:04:22,020 --> 01:04:30,710
tools so via via scheduled show just

01:04:27,800 --> 01:04:32,850
shows us our interface names which is

01:04:30,710 --> 01:04:35,820
important for the next step if you want

01:04:32,850 --> 01:04:38,370
to see what rectum is configured to so

01:04:35,820 --> 01:04:40,410
you use list interface to see and go

01:04:38,370 --> 01:04:42,750
look for ingress so this is just a grip

01:04:40,410 --> 01:04:47,490
on ingress police policing burst and

01:04:42,750 --> 01:04:50,700
right to go see that and then this is

01:04:47,490 --> 01:04:53,790
probably the most important one this is

01:04:50,700 --> 01:04:59,390
TC 4 to show that basically shows that

01:04:53,790 --> 01:05:01,980
we have a lessor installed that

01:04:59,390 --> 01:05:04,230
implements our rate limiter at high

01:05:01,980 --> 01:05:06,420
priority and thanks to Jamal for

01:05:04,230 --> 01:05:08,880
pointing this out in one call has action

01:05:06,420 --> 01:05:12,090
drop continue which allows it to go to

01:05:08,880 --> 01:05:16,020
the next high part of the next highest

01:05:12,090 --> 01:05:23,150
priority which is our flower classifier

01:05:16,020 --> 01:05:23,150
with the simple merge redirect action

01:05:24,299 --> 01:05:30,569
yeah that's that's it for me any

01:05:27,029 --> 01:05:32,879
questions so actually this slide the one

01:05:30,569 --> 01:05:34,799
that you show is there may be an

01:05:32,879 --> 01:05:37,589
unconventional or uncommon case where

01:05:34,799 --> 01:05:39,259
you drop from software data how software

01:05:37,589 --> 01:05:43,589
data passed to have your data pass it

01:05:39,259 --> 01:05:46,529
wouldn't be a production right just know

01:05:43,589 --> 01:05:48,629
it's not you're completely right sorry

01:05:46,529 --> 01:05:50,339
you're referring to the not in Hardware

01:05:48,629 --> 01:05:54,899
portion the other that should have been

01:05:50,339 --> 01:05:56,249
in Hardware apologies yeah yeah that

01:05:54,899 --> 01:05:58,499
this is actually one of the error

01:05:56,249 --> 01:06:00,209
situations it's really hard to build

01:05:58,499 --> 01:06:01,889
production system when data passed

01:06:00,209 --> 01:06:03,989
packets go come how does data passes

01:06:01,889 --> 01:06:07,439
over the other path could be exceptional

01:06:03,989 --> 01:06:10,739
not yeah yeah it's okay that the model

01:06:07,439 --> 01:06:14,039
supports that but you should aim to yeah

01:06:10,739 --> 01:06:16,349
yeah yeah yeah so so what it's supposed

01:06:14,039 --> 01:06:18,539
to do is both it should be in Hardware

01:06:16,349 --> 01:06:21,419
obviously and if you go back to the

01:06:18,539 --> 01:06:23,699
first if I get this thing to point

01:06:21,419 --> 01:06:25,619
correctly I think this example had in

01:06:23,699 --> 01:06:27,439
Hardware I was just being inconsistent

01:06:25,619 --> 01:06:29,909
and lazy

01:06:27,439 --> 01:06:31,969
so apology said this this should have

01:06:29,909 --> 01:06:37,489
been just should have said in hardware

01:06:31,969 --> 01:06:37,489
and this any other questions

01:06:39,090 --> 01:06:42,240
to mouth

01:06:43,030 --> 01:06:51,890
hi so why you choose they use priority

01:06:46,460 --> 01:06:54,050
you know change well I I guess we at

01:06:51,890 --> 01:06:56,570
some point we did discuss chains and

01:06:54,050 --> 01:07:00,290
priorities just seem to be a more

01:06:56,570 --> 01:07:03,980
natural match for for obs

01:07:00,290 --> 01:07:05,630
but I guess we can discuss chains so we

01:07:03,980 --> 01:07:08,540
know we just discussing chain in any

01:07:05,630 --> 01:07:10,250
case for obvious for recirculation for

01:07:08,540 --> 01:07:14,330
example yeah

01:07:10,250 --> 01:07:16,420
so the recirculation this might be a

01:07:14,330 --> 01:07:20,330
little bit of a different use case I

01:07:16,420 --> 01:07:23,870
don't know mention yes you can start

01:07:20,330 --> 01:07:24,980
with priority number plus something you

01:07:23,870 --> 01:07:27,980
can do the same thing with chain

01:07:24,980 --> 01:07:32,000
currently we starting working with chain

01:07:27,980 --> 01:07:35,330
zero chain plus something yeah I had

01:07:32,000 --> 01:07:37,430
learned when we discussed it we realized

01:07:35,330 --> 01:07:39,710
that both software model and how to

01:07:37,430 --> 01:07:42,770
implementation supports the suppose it's

01:07:39,710 --> 01:07:45,920
also without chains so we we kind of say

01:07:42,770 --> 01:07:47,660
hey let's do it simple I think if I

01:07:45,920 --> 01:07:50,150
remember correctly we discuss it on the

01:07:47,660 --> 01:07:54,230
community cause yeah we did we did have

01:07:50,150 --> 01:07:56,960
this we did consider the chains and then

01:07:54,230 --> 01:07:59,510
and what we're doing with the old API of

01:07:56,960 --> 01:08:01,400
the I building set rough rate because

01:07:59,510 --> 01:08:03,830
currently today when customer is asking

01:08:01,400 --> 01:08:07,730
how I can do that we point them to the

01:08:03,830 --> 01:08:10,340
old API of virtual functions we do it

01:08:07,730 --> 01:08:13,690
only as a back door Ronnie yeah no this

01:08:10,340 --> 01:08:13,690
is the way to do that because there is

01:08:17,460 --> 01:08:24,000
yeah so they asked I asked in switch the

01:08:21,240 --> 01:08:25,740
mode today you call it's kind of a hawk

01:08:24,000 --> 01:08:28,620
that's we're still supporting the old

01:08:25,740 --> 01:08:31,970
API of the legacy that I building set

01:08:28,620 --> 01:08:39,290
laughs usual function so the question is

01:08:31,970 --> 01:08:44,640
how his work we want to go to two

01:08:39,290 --> 01:08:45,900
different tours will offload the I know

01:08:44,640 --> 01:08:48,360
you're joking it's a mellow rock star

01:08:45,900 --> 01:08:50,640
but it's good we're open company so we

01:08:48,360 --> 01:08:52,710
want to go to to an approach of

01:08:50,640 --> 01:08:54,930
offloading polishers it applies to the

01:08:52,710 --> 01:09:02,580
OVS use case and also to other use cases

01:08:54,930 --> 01:09:04,950
right so this is just the just to give a

01:09:02,580 --> 01:09:08,130
little background the the reason I would

01:09:04,950 --> 01:09:11,400
go with this approach is because this is

01:09:08,130 --> 01:09:15,060
the OVS approach right so for for for my

01:09:11,400 --> 01:09:17,940
use case this make sense no I totally

01:09:15,060 --> 01:09:20,430
get smack sense it's it's good I didn't

01:09:17,940 --> 01:09:28,850
say just some small comments okay that's

01:09:20,430 --> 01:09:28,850
fine doing our job it's fine together

01:09:30,820 --> 01:09:46,680
okay do you prefer me to

01:09:48,480 --> 01:09:56,200
okay so I'll I've talked today about

01:09:53,610 --> 01:09:59,080
scalable hardware of how the functions

01:09:56,200 --> 01:10:03,000
we call it scalable how offloads this is

01:09:59,080 --> 01:10:07,330
work being done by per Rev for the

01:10:03,000 --> 01:10:09,970
kinetics devices but he was working a

01:10:07,330 --> 01:10:13,810
lot recently on the software model and

01:10:09,970 --> 01:10:16,270
GV picker and also Jason invested lots

01:10:13,810 --> 01:10:18,330
of thinking about the software model I'm

01:10:16,270 --> 01:10:25,720
I was less involved but I'm happily

01:10:18,330 --> 01:10:26,890
presenting that so what do we whatever

01:10:25,720 --> 01:10:30,190
we want to talk about we want to both

01:10:26,890 --> 01:10:32,410
talk about scalable hardware functions

01:10:30,190 --> 01:10:35,080
we call it how to offload but the point

01:10:32,410 --> 01:10:39,190
is to get a large amount of hardware

01:10:35,080 --> 01:10:41,470
functions for various use case that will

01:10:39,190 --> 01:10:43,990
see that we needed that so what will be

01:10:41,470 --> 01:10:45,940
the software model to do that and why

01:10:43,990 --> 01:10:53,560
and why did we choose this software

01:10:45,940 --> 01:10:56,170
model so PC is our Iove exists for a

01:10:53,560 --> 01:10:58,000
long time and also Linux a few years ago

01:10:56,170 --> 01:10:59,950
we kind of finally introduced a nice

01:10:58,000 --> 01:11:01,900
software model for that for the back end

01:10:59,950 --> 01:11:04,510
devices for the software side of the V

01:11:01,900 --> 01:11:07,990
switch but it's not really scalable you

01:11:04,510 --> 01:11:10,180
can maybe have tens of them somehow 128

01:11:07,990 --> 01:11:12,880
or a bit more but it's not going to work

01:11:10,180 --> 01:11:15,700
for a very large number of devices

01:11:12,880 --> 01:11:20,440
specifically for containers that have

01:11:15,700 --> 01:11:23,820
very short-lived and other use cases so

01:11:20,440 --> 01:11:23,820
we want we want to find something that

01:11:24,039 --> 01:11:31,909
deploys in a faster rate has a more

01:11:26,719 --> 01:11:34,760
scalable range and we want with this is

01:11:31,909 --> 01:11:36,440
one thing and we just kind of discussed

01:11:34,760 --> 01:11:38,719
the various options in native

01:11:36,440 --> 01:11:42,860
conferences I remember at least three or

01:11:38,719 --> 01:11:45,289
four times and it always crashed or

01:11:42,860 --> 01:11:48,829
didn't work out because we didn't we

01:11:45,289 --> 01:11:52,849
didn't we didn't plug well to the V port

01:11:48,829 --> 01:11:55,460
model which by nature existing in SR

01:11:52,849 --> 01:11:57,650
Iovine all vendors supports that

01:11:55,460 --> 01:11:59,000
so all windows I believe have something

01:11:57,650 --> 01:12:00,469
that even if you don't call it this way

01:11:59,000 --> 01:12:02,659
you have embedded switch in your

01:12:00,469 --> 01:12:04,670
hardware because when you virtualize the

01:12:02,659 --> 01:12:06,920
hardware you have virtual ports and you

01:12:04,670 --> 01:12:09,650
have to to do some sort of switching

01:12:06,920 --> 01:12:12,079
between them even if it's limited

01:12:09,650 --> 01:12:14,480
switching like the vapor stuff stuff of

01:12:12,079 --> 01:12:16,550
let's say Intel chips were 10 or 12

01:12:14,480 --> 01:12:22,329
years ago or the modern mode modern NICs

01:12:16,550 --> 01:12:27,710
that can do not only vapor switching so

01:12:22,329 --> 01:12:30,730
the solution we propose is to on the one

01:12:27,710 --> 01:12:33,020
hand if one days or iov but still split

01:12:30,730 --> 01:12:35,150
this is the hardware solution that we

01:12:33,020 --> 01:12:36,920
proposed and I the more to stick stuff

01:12:35,150 --> 01:12:41,270
is the social model out commit to in a

01:12:36,920 --> 01:12:43,789
minute so we want to - this is also some

01:12:41,270 --> 01:12:46,159
I believe that other vendors could do

01:12:43,789 --> 01:12:49,039
that maybe all of them to split a PCI

01:12:46,159 --> 01:12:52,730
device into more modern smaller sub

01:12:49,039 --> 01:12:56,059
devices that its sub device has its own

01:12:52,730 --> 01:12:58,789
l2 cues or audio make use whatever but

01:12:56,059 --> 01:13:00,770
it has a V port representation in

01:12:58,789 --> 01:13:02,809
hardware that can plug to all what we do

01:13:00,770 --> 01:13:04,730
in obvious we talk about it here and the

01:13:02,809 --> 01:13:07,639
name space resources that it has some

01:13:04,730 --> 01:13:10,420
segregation and security and all of this

01:13:07,639 --> 01:13:12,710
stuff and then if we manage to do that

01:13:10,420 --> 01:13:14,620
the nice thing is that we can leverage

01:13:12,710 --> 01:13:16,180
this switch there

01:13:14,620 --> 01:13:20,260
infrastructure in the kernel which is

01:13:16,180 --> 01:13:23,320
there since kernel 4.8 2016 and applies

01:13:20,260 --> 01:13:26,920
in OBS and tala literal align all the in

01:13:23,320 --> 01:13:31,240
the echo system that would be a good

01:13:26,920 --> 01:13:35,260
nice win one other thing that we want to

01:13:31,240 --> 01:13:37,240
require is that we want to also to be

01:13:35,260 --> 01:13:45,460
applicable for smart NIC environment

01:13:37,240 --> 01:13:48,640
okay so there was a proposal to create a

01:13:45,460 --> 01:13:50,350
virtual a new virtual bus in Linux it

01:13:48,640 --> 01:13:53,290
was extended of something that proposed

01:13:50,350 --> 01:13:55,810
ten years ago for KVM and was not

01:13:53,290 --> 01:13:59,980
accepted and it was reviewed with Greg

01:13:55,810 --> 01:14:02,350
KH and the other guys and after some

01:13:59,980 --> 01:14:05,140
review cycles I was less involved

01:14:02,350 --> 01:14:08,380
eventually people realized that in

01:14:05,140 --> 01:14:09,910
further ten of the kernel a new sub

01:14:08,380 --> 01:14:12,850
system was introduced called MIDI

01:14:09,910 --> 01:14:14,800
devices and this is a this software

01:14:12,850 --> 01:14:19,900
model of the MIDI devices are very good

01:14:14,800 --> 01:14:22,960
fit to what we want to do here so I will

01:14:19,900 --> 01:14:24,340
not introduce you fully now to meditate

01:14:22,960 --> 01:14:24,640
devices I don't have enough time for

01:14:24,340 --> 01:14:28,330
that

01:14:24,640 --> 01:14:31,480
but it has a notion of mediately device

01:14:28,330 --> 01:14:35,830
driver and made a device that does this

01:14:31,480 --> 01:14:38,860
as pointing okay so there is a mediator

01:14:35,830 --> 01:14:43,840
device driver driver and mediated device

01:14:38,860 --> 01:14:47,610
and there is a bus for them and these

01:14:43,840 --> 01:14:52,150
are the the blue pieces on below and

01:14:47,610 --> 01:14:55,060
then what is needed is a is a control

01:14:52,150 --> 01:14:58,090
plane knob to add create and query those

01:14:55,060 --> 01:15:01,270
MIDI devices in the Nick use case those

01:14:58,090 --> 01:15:03,220
many devices in the kernel were recently

01:15:01,270 --> 01:15:05,200
render the introducing for the ten were

01:15:03,220 --> 01:15:08,200
more for GPUs and other stuff in Vidya

01:15:05,200 --> 01:15:09,550
and or other drivers but now we we we

01:15:08,200 --> 01:15:11,530
have the cool use cases from Nick

01:15:09,550 --> 01:15:13,570
drivers in the kernel I know that in

01:15:11,530 --> 01:15:14,719
user space in DP BK Intel doing lots of

01:15:13,570 --> 01:15:16,429
work on

01:15:14,719 --> 01:15:19,729
the VDP a but but this is a kernel

01:15:16,429 --> 01:15:23,119
implementation so what you would do you

01:15:19,729 --> 01:15:27,400
would used the dove link control plane

01:15:23,119 --> 01:15:31,760
to create create configure destroy those

01:15:27,400 --> 01:15:34,849
those instances and then the vendor has

01:15:31,760 --> 01:15:36,469
to write to register a driver with the

01:15:34,849 --> 01:15:39,349
MIDI devices infrastructure in the

01:15:36,469 --> 01:15:43,280
kernel and then when when an instance is

01:15:39,349 --> 01:15:44,719
created in the end of the day for

01:15:43,280 --> 01:15:47,269
instance in our case we would create

01:15:44,719 --> 01:15:50,300
three devices we create a new device and

01:15:47,269 --> 01:15:53,090
our DMA device and a representer further

01:15:50,300 --> 01:15:56,300
for the four days which are DMA support

01:15:53,090 --> 01:15:58,489
of course optional the broadcast the

01:15:56,300 --> 01:16:03,039
broader use case would be of course an a

01:15:58,489 --> 01:16:06,619
device and then once you have any device

01:16:03,039 --> 01:16:09,889
which is based on this so we have an a

01:16:06,619 --> 01:16:12,139
device we can prevent in it to container

01:16:09,889 --> 01:16:13,789
to namespace right obviously we talked

01:16:12,139 --> 01:16:16,849
about it today but on the other hand

01:16:13,789 --> 01:16:18,199
this net device is built on something

01:16:16,849 --> 01:16:20,449
which is in software is immediately

01:16:18,199 --> 01:16:23,239
device but in hardware it's somehow to a

01:16:20,449 --> 01:16:26,030
function that has a V port so now you

01:16:23,239 --> 01:16:28,369
can use this V pot in your obvious or

01:16:26,030 --> 01:16:30,800
your other V switch control plane and

01:16:28,369 --> 01:16:33,229
start to do offloading so so what you

01:16:30,800 --> 01:16:35,690
got you got you got a protocol device

01:16:33,229 --> 01:16:38,960
and a device that has its own Hardware

01:16:35,690 --> 01:16:41,110
queues is own resources and SS resources

01:16:38,960 --> 01:16:43,309
and you can map it to a container or

01:16:41,110 --> 01:16:46,249
whatever applications that you use the

01:16:43,309 --> 01:16:48,679
PDK even but you also have of course the

01:16:46,249 --> 01:16:50,749
other members but and also you have a

01:16:48,679 --> 01:16:54,199
representation in in the vase which so

01:16:50,749 --> 01:16:55,429
you got it this is what we all the times

01:16:54,199 --> 01:16:58,610
about all the times we were talking

01:16:55,429 --> 01:17:02,659
about models so it's always not

01:16:58,610 --> 01:17:04,519
incomplete and hopefully so we got it so

01:17:02,659 --> 01:17:06,979
we got something that it is how we

01:17:04,519 --> 01:17:09,860
offloaded network function which has a

01:17:06,979 --> 01:17:12,409
this rich representation yes so I can

01:17:09,860 --> 01:17:15,139
move it to a container or I can

01:17:12,409 --> 01:17:18,139
in our implementation you cannot map it

01:17:15,139 --> 01:17:20,780
to a virtual machine but because the

01:17:18,139 --> 01:17:22,969
driver the the the the driver that

01:17:20,780 --> 01:17:25,780
control that is emilie x5 will not vfi

01:17:22,969 --> 01:17:29,150
oh but this for if if someone else

01:17:25,780 --> 01:17:31,040
driver can support it with vfi oh it

01:17:29,150 --> 01:17:34,250
will be also applicable to virtual

01:17:31,040 --> 01:17:36,170
machines the model supports that so you

01:17:34,250 --> 01:17:39,800
need to do s arriv'd in order for it to

01:17:36,170 --> 01:17:41,870
be vm compatible is that true no no you

01:17:39,800 --> 01:17:43,040
forget for my sorry you have only the

01:17:41,870 --> 01:17:45,409
physical function you have a bare-metal

01:17:43,040 --> 01:17:47,270
now you start to carve more and more

01:17:45,409 --> 01:17:49,790
many other devices on this single

01:17:47,270 --> 01:17:51,710
function and in our implementation you

01:17:49,790 --> 01:17:53,389
can only map them to container or other

01:17:51,710 --> 01:17:55,580
use cases but you cannot map them to a

01:17:53,389 --> 01:17:57,080
virtual machine if you want to send it

01:17:55,580 --> 01:17:59,989
to a virtual machine you have to use VF

01:17:57,080 --> 01:18:06,110
io and it's not the scope of today but

01:17:59,989 --> 01:18:07,909
it supports that you can create as many

01:18:06,110 --> 01:18:11,630
few press as you want because you do

01:18:07,909 --> 01:18:13,880
have a hardware function now you have

01:18:11,630 --> 01:18:15,710
you have a envelopes we call it sub

01:18:13,880 --> 01:18:17,570
function but it's not the point here

01:18:15,710 --> 01:18:20,270
it's just in the name we give it so

01:18:17,570 --> 01:18:22,880
again it's it's it's a bit so you have

01:18:20,270 --> 01:18:25,310
from PCI point of view you have one

01:18:22,880 --> 01:18:27,620
function the physical function in our

01:18:25,310 --> 01:18:29,750
implementation we take some bar of this

01:18:27,620 --> 01:18:32,150
function and we split it to multiple

01:18:29,750 --> 01:18:33,530
functions but the software

01:18:32,150 --> 01:18:37,219
representation it's something called

01:18:33,530 --> 01:18:38,870
MIDI 80 device and then you have the

01:18:37,219 --> 01:18:40,460
software position of the function in the

01:18:38,870 --> 01:18:42,409
kernel and then you have an edifice

01:18:40,460 --> 01:18:44,120
created on this madman and then you

01:18:42,409 --> 01:18:46,820
could put in a container and so on let

01:18:44,120 --> 01:18:49,159
me ask you so I create this thing I

01:18:46,820 --> 01:18:51,080
guess with what IP link is deafening

01:18:49,159 --> 01:18:53,060
or div link okay so I created it shows

01:18:51,080 --> 01:18:55,340
up as a net Dave I move it to a

01:18:53,060 --> 01:18:57,469
container right in start using it and I

01:18:55,340 --> 01:19:00,980
can do how do L float on it I'll do

01:18:57,469 --> 01:19:03,380
awful for the switching this container

01:19:00,980 --> 01:19:05,560
has a native which has real hard work

01:19:03,380 --> 01:19:07,240
used right there cupid's already unique

01:19:05,560 --> 01:19:08,830
damn it's not soft recuse it's hard work

01:19:07,240 --> 01:19:10,660
you do that's right but so I can I can

01:19:08,830 --> 01:19:13,570
basically can I install filters then

01:19:10,660 --> 01:19:15,640
that get offloaded yes oh you can do

01:19:13,570 --> 01:19:18,040
more naturally you can do the filters on

01:19:15,640 --> 01:19:20,430
the now you have a model for we switch

01:19:18,040 --> 01:19:22,720
so you can do the filters there

01:19:20,430 --> 01:19:26,650
okay you have a represent all we're

01:19:22,720 --> 01:19:32,080
talking about the were talking about

01:19:26,650 --> 01:19:33,880
represent of a fury okay okay this is so

01:19:32,080 --> 01:19:36,910
if you're using the MDF infrastructure

01:19:33,880 --> 01:19:39,130
isn't that the via fire stop you have a

01:19:36,910 --> 01:19:48,250
choice in MgO if to use vfa or not it's

01:19:39,130 --> 01:19:52,720
not mandatory I cannot comment on that I

01:19:48,250 --> 01:19:55,480
don't know I so here here again so

01:19:52,720 --> 01:19:59,650
here's the here's the we have one PCI

01:19:55,480 --> 01:20:02,860
device the PF my device a PDF device in

01:19:59,650 --> 01:20:06,000
this example and then we put multiple

01:20:02,860 --> 01:20:08,770
instances on the on the on the M dev bus

01:20:06,000 --> 01:20:10,330
in here with you your ID is 0 and then 1

01:20:08,770 --> 01:20:14,280
and so on and so forth and each one of

01:20:10,330 --> 01:20:20,920
them correspond to protocol device like

01:20:14,280 --> 01:20:24,010
and then which is in the middle that the

01:20:20,920 --> 01:20:25,870
blue then the light blue is the RDMA and

01:20:24,010 --> 01:20:27,700
and on the left side the green one is

01:20:25,870 --> 01:20:30,520
the one that represents the a switch

01:20:27,700 --> 01:20:34,150
side okay as soon as you create this

01:20:30,520 --> 01:20:37,150
creature we in our case the driver with

01:20:34,150 --> 01:20:39,340
with with react and create 3 3 devices

01:20:37,150 --> 01:20:42,070
but on the general case again it's it's

01:20:39,340 --> 01:20:44,140
one net device device another net device

01:20:42,070 --> 01:20:46,630
which is the NIC the virtual Nick you

01:20:44,140 --> 01:20:48,640
hand to the container later and then the

01:20:46,630 --> 01:20:51,700
switch port which is also has an a

01:20:48,640 --> 01:20:52,750
device is the representor so one basic

01:20:51,700 --> 01:20:57,160
question I guess how's this different

01:20:52,750 --> 01:20:59,710
from the VF because in the VF stuff each

01:20:57,160 --> 01:21:01,870
such a device is back up by PCI

01:20:59,710 --> 01:21:03,270
different function and here we have one

01:21:01,870 --> 01:21:06,270
function that correspond to multiple

01:21:03,270 --> 01:21:06,270
devices

01:21:17,130 --> 01:21:25,770
so you said you're not using IVF io is

01:21:21,210 --> 01:21:27,510
the there is a copy involved what is

01:21:25,770 --> 01:21:31,200
there a copy involved from the container

01:21:27,510 --> 01:21:33,300
packets no because it's a it's a

01:21:31,200 --> 01:21:35,280
hardware cue and we don't map it to a

01:21:33,300 --> 01:21:37,430
virtual machine so it's it's our

01:21:35,280 --> 01:21:40,470
implementation is more limited than the

01:21:37,430 --> 01:21:45,690
general case because we all hook on the

01:21:40,470 --> 01:21:48,810
same PCI function but we still do some

01:21:45,690 --> 01:21:50,820
separations so it's it's I'm trying to

01:21:48,810 --> 01:21:53,070
understand the separation because you

01:21:50,820 --> 01:21:55,260
don't have any separation is internal to

01:21:53,070 --> 01:21:59,880
our implementation but the software

01:21:55,260 --> 01:22:03,390
model uses the mm devs so from otherwise

01:21:59,880 --> 01:22:05,520
you guys interview invented there is

01:22:03,390 --> 01:22:08,070
model of MIDI devices so maybe the

01:22:05,520 --> 01:22:10,710
device is a bunch of cues which are

01:22:08,070 --> 01:22:13,320
somehow related and if your hard work

01:22:10,710 --> 01:22:16,200
and support VF IO you can also do knife

01:22:13,320 --> 01:22:18,350
thing with that right yes yeah it's VM

01:22:16,200 --> 01:22:21,720
DQ and I mean we

01:22:18,350 --> 01:22:23,550
yes but V mdq this is the stuff that we

01:22:21,720 --> 01:22:25,950
didn't converge on all those conferences

01:22:23,550 --> 01:22:27,480
because if you just VN use VM BQ we

01:22:25,950 --> 01:22:32,670
didn't have representation for the a

01:22:27,480 --> 01:22:34,080
switch right no yes and I believe your I

01:22:32,670 --> 01:22:36,120
don't know and if you can comment or a

01:22:34,080 --> 01:22:38,610
natural number you think you can support

01:22:36,120 --> 01:22:42,650
it some you you want to give it them the

01:22:38,610 --> 01:22:42,650
micro okay

01:22:42,840 --> 01:22:55,030
and that's one oh man what do you think

01:22:45,420 --> 01:22:56,440
I could always use more words so yeah

01:22:55,030 --> 01:22:58,060
this is something that very similar that

01:22:56,440 --> 01:22:59,740
we talked about because I think there

01:22:58,060 --> 01:23:01,270
are a lot of limitations you described

01:22:59,740 --> 01:23:03,670
or limitations that we see as well so

01:23:01,270 --> 01:23:05,110
I'm glad you're presenting this and you

01:23:03,670 --> 01:23:12,490
know hey these beat us to the punch but

01:23:05,110 --> 01:23:14,710
that's okay so is there a reason the

01:23:12,490 --> 01:23:17,950
current McQuillan approach is not

01:23:14,710 --> 01:23:20,320
suitable yes because if you think about

01:23:17,950 --> 01:23:22,480
it draw it on a piece of paper for Mack

01:23:20,320 --> 01:23:24,700
the bank villain approach you don't you

01:23:22,480 --> 01:23:26,650
don't have a software model to put rules

01:23:24,700 --> 01:23:37,720
that coming from the VM it's only

01:23:26,650 --> 01:23:40,120
one-sided but only for one direction you

01:23:37,720 --> 01:23:42,820
have this patch from John's first invent

01:23:40,120 --> 01:23:45,090
but it's only do half of the work think

01:23:42,820 --> 01:23:45,090
about it

01:23:47,369 --> 01:23:53,679
it's confusing this feature that you

01:23:50,349 --> 01:23:56,739
have actually one more question you

01:23:53,679 --> 01:23:58,960
mentioned about subdividing the bar for

01:23:56,739 --> 01:24:00,419
each of those yes this is implementation

01:23:58,960 --> 01:24:03,789
[Music]

01:24:00,419 --> 01:24:06,429
yes but you could you could do it in

01:24:03,789 --> 01:24:09,069
multiple ways the point is that if you

01:24:06,429 --> 01:24:22,869
know to plug to the M dev sub system

01:24:09,069 --> 01:24:27,219
right so let's see if it's really yes so

01:24:22,869 --> 01:24:31,689
I explained that yes these are details

01:24:27,219 --> 01:24:33,760
there which are less important so again

01:24:31,689 --> 01:24:36,369
we use the MDF sub system which is

01:24:33,760 --> 01:24:39,219
exists and has an ecosystem with it it

01:24:36,369 --> 01:24:42,339
was hopefully cool and easy to

01:24:39,219 --> 01:24:44,109
understand by users we we also used how

01:24:42,339 --> 01:24:46,559
we managed to get into the hardware

01:24:44,109 --> 01:24:50,439
model of having a vport for each just

01:24:46,559 --> 01:24:52,629
such entity and now we can make use of

01:24:50,439 --> 01:24:55,569
that one use case the obvious use case

01:24:52,629 --> 01:24:59,760
is containers we have another use cases

01:24:55,569 --> 01:25:04,629
that I will tomorrow I have a session on

01:24:59,760 --> 01:25:08,919
live migration with virtual functions so

01:25:04,629 --> 01:25:11,199
we we do we use those new as mediated

01:25:08,919 --> 01:25:13,269
devices for the host side of this live

01:25:11,199 --> 01:25:16,089
migration build up and tomorrow it will

01:25:13,269 --> 01:25:19,539
be too complex to explain that

01:25:16,089 --> 01:25:21,579
just remember this for tomorrow no

01:25:19,539 --> 01:25:23,600
remember the stuff that when I will talk

01:25:21,579 --> 01:25:25,550
about other

01:25:23,600 --> 01:25:28,210
how to function I will refer to this

01:25:25,550 --> 01:25:28,210
these guys

01:25:39,170 --> 01:25:49,830
and today that no no joking yes yes all

01:25:46,830 --> 01:25:51,390
right good okay so when you I guess your

01:25:49,830 --> 01:25:53,100
implementation is still internal at this

01:25:51,390 --> 01:25:55,740
point or of you know no it's an RFC

01:25:53,100 --> 01:26:00,240
nndof okay all right mr. memo that's

01:25:55,740 --> 01:26:02,940
good it's not a it's not a full

01:26:00,240 --> 01:26:08,370
implementation but it's the it has all

01:26:02,940 --> 01:26:10,410
the excuse me all the binding points for

01:26:08,370 --> 01:26:13,170
the deviling for like you can see the

01:26:10,410 --> 01:26:15,960
skeleton of watch what ops you have to

01:26:13,170 --> 01:26:17,970
expose that the the M Alex five-part is

01:26:15,960 --> 01:26:22,080
Morris skeleton but it has all the

01:26:17,970 --> 01:26:24,410
registrations for them okay perfect you

01:26:22,080 --> 01:26:24,410
can copy

01:26:24,489 --> 01:26:30,790
so first question is another resource

01:26:27,790 --> 01:26:31,930
that's limiting the amount of these

01:26:30,790 --> 01:26:36,580
devices you might be able to create

01:26:31,930 --> 01:26:38,050
could be the MSA expectations are up

01:26:36,580 --> 01:26:40,630
limitation I mean this is what I know

01:26:38,050 --> 01:26:42,730
maybe I mean I think we show the IR cues

01:26:40,630 --> 01:26:46,000
between as I said it's not a real it's

01:26:42,730 --> 01:26:48,070
not a fully virtualized so for instance

01:26:46,000 --> 01:26:49,989
I like use our shared but maybe it's

01:26:48,070 --> 01:26:52,210
good you don't want to have tens of

01:26:49,989 --> 01:26:54,400
thousands or fry like user agree it's

01:26:52,210 --> 01:26:57,160
good but can't does that break the model

01:26:54,400 --> 01:27:01,030
for the separation between them yeah

01:26:57,160 --> 01:27:04,380
it's a good question I'm not we have to

01:27:01,030 --> 01:27:04,380
see on the implementation

01:27:07,659 --> 01:27:14,139
somewhat security yes but as long as you

01:27:11,199 --> 01:27:16,600
don't you don't map it to virtual

01:27:14,139 --> 01:27:21,150
machines it can still be secure I

01:27:16,600 --> 01:27:21,150
believe okay

01:27:25,380 --> 01:27:32,460
the dev link yeah it's a dev link we

01:27:30,030 --> 01:27:34,830
forgot to do here a slide one RFC and

01:27:32,460 --> 01:27:36,600
they are I've seen that we present we

01:27:34,830 --> 01:27:39,300
really show the flow so initially you

01:27:36,600 --> 01:27:42,030
generate some UUID and then you use this

01:27:39,300 --> 01:27:44,580
year I do is dev link to create the new

01:27:42,030 --> 01:27:45,930
device deaflink is just the hook to get

01:27:44,580 --> 01:27:51,660
into the kernel to the MDF

01:27:45,930 --> 01:27:53,520
infrastructure yes but again the Anjali

01:27:51,660 --> 01:28:03,150
and Arielle the patches are on a dev so

01:27:53,520 --> 01:28:04,890
do comment there okay sorry do you plan

01:28:03,150 --> 01:28:09,680
to implement some kind of program

01:28:04,890 --> 01:28:12,750
ability to the s embodied switch like

01:28:09,680 --> 01:28:15,870
between the between these new novel

01:28:12,750 --> 01:28:19,590
represent ORS for example you can you

01:28:15,870 --> 01:28:25,190
can XDP redirect or XDP drop between

01:28:19,590 --> 01:28:27,090
those so okay so the the the light green

01:28:25,190 --> 01:28:30,360
devices here that we call port

01:28:27,090 --> 01:28:32,280
representers the control plane to the

01:28:30,360 --> 01:28:34,860
control plane knob to configure them is

01:28:32,280 --> 01:28:38,190
DC flower this is also something that we

01:28:34,860 --> 01:28:41,820
kind of de facto standardizing in our

01:28:38,190 --> 01:28:45,270
small community it's more of a switch

01:28:41,820 --> 01:28:48,840
it's it's less of xdp way of programming

01:28:45,270 --> 01:28:50,370
for a NIC it's more for open its moral

01:28:48,840 --> 01:28:52,500
thinking about more of open flow rules

01:28:50,370 --> 01:28:54,720
that you have a source port a match in

01:28:52,500 --> 01:28:56,430
action an action can be dropped forward

01:28:54,720 --> 01:28:59,550
but you can also apply villain push and

01:28:56,430 --> 01:29:02,250
pop over the network's soon connection

01:28:59,550 --> 01:29:05,150
tracking these are the more more the

01:29:02,250 --> 01:29:05,150
type you work with this

01:29:09,550 --> 01:29:13,750
yes on the Virtual NIC you can put the

01:29:11,560 --> 01:29:19,360
XDP of course yes on the on the on the

01:29:13,750 --> 01:29:25,720
on the automated yes so sorry for thank

01:29:19,360 --> 01:29:29,110
you so so I think you can see it very

01:29:25,720 --> 01:29:30,450
very the same way as we working with

01:29:29,110 --> 01:29:34,420
switch dev today

01:29:30,450 --> 01:29:36,220
switch dev mode so for s r io v for

01:29:34,420 --> 01:29:39,250
virtual functions it's actually the same

01:29:36,220 --> 01:29:42,840
thing almost but without the PCI stuff

01:29:39,250 --> 01:29:48,310
so instead of slicing the PCI to PCI

01:29:42,840 --> 01:29:52,750
functions it slicing it for M depth each

01:29:48,310 --> 01:29:55,270
vendor can contain another so it is up

01:29:52,750 --> 01:29:57,300
to the vendor to implement another and

01:29:55,270 --> 01:30:00,010
to support whatever it is supporting and

01:29:57,300 --> 01:30:02,350
what is the other way and the other side

01:30:00,010 --> 01:30:04,390
of the this nativists that's of course

01:30:02,350 --> 01:30:07,600
the representor of the switchboard I

01:30:04,390 --> 01:30:09,430
think info for this the question of the

01:30:07,600 --> 01:30:12,190
Mac villain I think it's also can be

01:30:09,430 --> 01:30:16,990
work if we will still support it in the

01:30:12,190 --> 01:30:19,120
legacy mode even yeah you don't want to

01:30:16,990 --> 01:30:22,540
represent or don't have one you can

01:30:19,120 --> 01:30:24,880
still have the same same thing so but

01:30:22,540 --> 01:30:26,860
it's a standard in a device you have

01:30:24,880 --> 01:30:28,870
tuned a device as you mentioned okay

01:30:26,860 --> 01:30:31,900
so there are two new device what made a

01:30:28,870 --> 01:30:34,210
single device it's like you probe the

01:30:31,900 --> 01:30:36,220
virtual function it's a full in a device

01:30:34,210 --> 01:30:41,080
that can support everything it can

01:30:36,220 --> 01:30:43,570
support xdp it can support also TC for

01:30:41,080 --> 01:30:48,490
slope for that you can use the hardware

01:30:43,570 --> 01:30:51,430
but is the the harder of the port the

01:30:48,490 --> 01:30:53,320
virtual port so everything is can be

01:30:51,430 --> 01:30:56,670
supported it can be extended depending

01:30:53,320 --> 01:30:56,670
on the hardware limitation of course

01:30:57,040 --> 01:31:00,920
so we were going between multiple

01:30:59,810 --> 01:31:03,290
choices over the years in this

01:31:00,920 --> 01:31:06,440
conference and we took the Vth approach

01:31:03,290 --> 01:31:08,450
but we didn't do a Vth within the we

01:31:06,440 --> 01:31:10,970
didn't edit offload to the Vth driver

01:31:08,450 --> 01:31:13,190
but we choose an attitude that allows

01:31:10,970 --> 01:31:17,870
allows us to come with the hardware way

01:31:13,190 --> 01:31:19,310
of doing Vth but but the drivers that

01:31:17,870 --> 01:31:20,930
runs in the container is different is

01:31:19,310 --> 01:31:23,150
the vendor driver is the broad common

01:31:20,930 --> 01:31:28,120
natural normal longs driver and just the

01:31:23,150 --> 01:31:32,210
device it is working on is this stuff

01:31:28,120 --> 01:31:35,240
and I just want to mention that the idea

01:31:32,210 --> 01:31:37,040
was more for containers because if you

01:31:35,240 --> 01:31:39,170
use virtual functions for a virtual

01:31:37,040 --> 01:31:41,720
machine then you have a resource

01:31:39,170 --> 01:31:43,310
limitation on the PCI and here you want

01:31:41,720 --> 01:31:44,990
something and you didn't even and one

01:31:43,310 --> 01:31:48,470
you want to create more of a virtual

01:31:44,990 --> 01:31:50,720
function you need to reset the PCI the

01:31:48,470 --> 01:31:54,350
virtual function numbers and here you

01:31:50,720 --> 01:31:55,970
can create them dynamically for for

01:31:54,350 --> 01:31:58,730
containers for it containers you get a

01:31:55,970 --> 01:32:01,790
new device you can create using an

01:31:58,730 --> 01:32:04,900
obvious a CNI that's implementing and we

01:32:01,790 --> 01:32:09,350
also support kind of that we implemented

01:32:04,900 --> 01:32:12,260
CA Knights like for a noir CNI and also

01:32:09,350 --> 01:32:15,650
for now for OVA and CNI that's using

01:32:12,260 --> 01:32:18,020
obvious both of them it's using the same

01:32:15,650 --> 01:32:20,210
order of Aldo and instead of giving them

01:32:18,020 --> 01:32:22,220
the via ths that using today we just

01:32:20,210 --> 01:32:26,160
give them a representor and a native and

01:32:22,220 --> 01:32:30,610
everything continue to work the same

01:32:26,160 --> 01:32:36,270
you what how do you create them so it's

01:32:30,610 --> 01:32:36,270
of course a hard limitation absence I

01:32:38,430 --> 01:32:42,130
know you're trying to dis you man you

01:32:40,390 --> 01:32:51,790
dr. Mac villains like when you it's

01:32:42,130 --> 01:32:54,550
broken I always like I mean I have an e

01:32:51,790 --> 01:32:57,850
an take it works well the one nice thing

01:32:54,550 --> 01:33:01,300
is that I can use things like load

01:32:57,850 --> 01:33:03,550
balancing even with RSS okay and I can

01:33:01,300 --> 01:33:05,740
shove them into different containers and

01:33:03,550 --> 01:33:06,880
and start sending packets through the

01:33:05,740 --> 01:33:09,820
different mic feelings in different

01:33:06,880 --> 01:33:11,860
containers something as trivial as RSS

01:33:09,820 --> 01:33:13,630
for example but it doesn't have a proper

01:33:11,860 --> 01:33:15,550
switching model Jamal we were talking

01:33:13,630 --> 01:33:16,870
about this yes the switching mode let's

01:33:15,550 --> 01:33:19,420
like talk about the infinite number of

01:33:16,870 --> 01:33:22,360
times so why do you can you offload

01:33:19,420 --> 01:33:25,000
rules in hardware in this yes yes yes

01:33:22,360 --> 01:33:27,640
and I can do everything that I could do

01:33:25,000 --> 01:33:32,370
on a traditional Mellanox port for you

01:33:27,640 --> 01:33:36,800
yes okay thank you guys

01:33:32,370 --> 01:33:36,800

YouTube URL: https://www.youtube.com/watch?v=H3JJX-kd15A


