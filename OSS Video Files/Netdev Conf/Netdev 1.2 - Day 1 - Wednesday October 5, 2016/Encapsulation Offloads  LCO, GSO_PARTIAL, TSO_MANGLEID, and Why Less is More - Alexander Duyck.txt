Title: Encapsulation Offloads  LCO, GSO_PARTIAL, TSO_MANGLEID, and Why Less is More - Alexander Duyck
Publication date: 2016-10-06
Playlist: Netdev 1.2 - Day 1 - Wednesday October 5, 2016
Description: 
	http://netdevconf.org/1.2/session.html?alexander-duyck
Captions: 
	00:00:11,600 --> 00:00:16,410
35 minutes yep okay as long as like okay

00:00:14,430 --> 00:00:18,930
guy get moving here in to attack lot of

00:00:16,410 --> 00:00:21,300
technical topics really quick so my name

00:00:18,930 --> 00:00:25,890
is Alexander Dyke I'm an open source

00:00:21,300 --> 00:00:28,290
technologist with intel corporation I'm

00:00:25,890 --> 00:00:30,509
here to cover some work i actually did

00:00:28,290 --> 00:00:35,989
was working for mirantis which is

00:00:30,509 --> 00:00:39,210
actually an OpenStack provider basically

00:00:35,989 --> 00:00:43,040
whoever be covering is encapsulation

00:00:39,210 --> 00:00:47,430
offloads specifically LCL geo so partial

00:00:43,040 --> 00:00:54,420
tishomingo ID and why les is actually

00:00:47,430 --> 00:00:55,829
more so overall agenda gap start out

00:00:54,420 --> 00:00:59,610
with some basics Emma be getting pretty

00:00:55,829 --> 00:01:01,860
technical on this specifically just to

00:00:59,610 --> 00:01:04,589
give a brief overview of checksums and

00:01:01,860 --> 00:01:06,000
UDP encapsulation some of the work

00:01:04,589 --> 00:01:08,220
that's already been done by others to

00:01:06,000 --> 00:01:10,320
address this specifically remote

00:01:08,220 --> 00:01:12,750
checksum offload by Tom Herbert and

00:01:10,320 --> 00:01:16,830
local checksum also which is some work

00:01:12,750 --> 00:01:20,130
that was done by Edward Cree and then

00:01:16,830 --> 00:01:22,800
again to the work I did on gso partial

00:01:20,130 --> 00:01:26,159
or partial GSS a partial generic

00:01:22,800 --> 00:01:28,020
segmentation offload tcep segmentation

00:01:26,159 --> 00:01:31,560
offer with ID mingling which are

00:01:28,020 --> 00:01:33,120
referring to as TSO mango ID y last

00:01:31,560 --> 00:01:36,330
functionality actually gives us the

00:01:33,120 --> 00:01:41,840
chance to do more and some conclusions

00:01:36,330 --> 00:01:45,119
and future work so starting off with

00:01:41,840 --> 00:01:47,220
just the basics of checksums for those

00:01:45,119 --> 00:01:49,340
aren't familiar with checksums basically

00:01:47,220 --> 00:01:52,970
it's the basic data verification

00:01:49,340 --> 00:01:57,479
approach taken by TCP UDP and I need the

00:01:52,970 --> 00:01:58,780
ipv4 the logic what you're basically

00:01:57,479 --> 00:02:00,790
doing is you're going to go

00:01:58,780 --> 00:02:03,250
and performer ones complement checks a

00:02:00,790 --> 00:02:05,590
one can ones complement sum of all the

00:02:03,250 --> 00:02:07,420
data the final result should be an all

00:02:05,590 --> 00:02:10,959
ones value which is considered negative

00:02:07,420 --> 00:02:14,110
zero technically zero is equivalent but

00:02:10,959 --> 00:02:15,069
for other purposes is the zero we are

00:02:14,110 --> 00:02:17,440
concerned with is going to be negative

00:02:15,069 --> 00:02:20,770
zero specifically because in the case of

00:02:17,440 --> 00:02:24,250
GDP 0 represents no checksum offload at

00:02:20,770 --> 00:02:29,459
all and so i'll refer to negative zero

00:02:24,250 --> 00:02:31,810
meaning the all apps value going forward

00:02:29,459 --> 00:02:34,750
one of the advantages to doing it as a

00:02:31,810 --> 00:02:37,030
ones complement some is you have carries

00:02:34,750 --> 00:02:40,030
are creating to both halves of the value

00:02:37,030 --> 00:02:42,970
so the upper eight bits will carry into

00:02:40,030 --> 00:02:44,500
the lower bits as AK not lower eight

00:02:42,970 --> 00:02:46,630
bits casing theater so it doesn't

00:02:44,500 --> 00:02:48,100
actually matter for byte ordering so if

00:02:46,630 --> 00:02:49,750
you're on a little Indian system a big

00:02:48,100 --> 00:02:51,069
Indian system just going cheering

00:02:49,750 --> 00:02:52,739
performing that one's complement some

00:02:51,069 --> 00:02:55,780
will give you the same value regardless

00:02:52,739 --> 00:02:58,209
of byte ordering as long as you're still

00:02:55,780 --> 00:03:02,739
doing this it's just a 16-bit somebody

00:02:58,209 --> 00:03:05,079
that you're looking at sea then on most

00:03:02,739 --> 00:03:07,380
architectures we end up with is it's

00:03:05,079 --> 00:03:09,850
implemented some form of ADD with Carey

00:03:07,380 --> 00:03:10,600
basically just going through and adding

00:03:09,850 --> 00:03:12,310
whatever

00:03:10,600 --> 00:03:16,210
you have into your next value as you add

00:03:12,310 --> 00:03:19,450
it together so a good example being you

00:03:16,210 --> 00:03:21,580
add one to the all apps are all runs

00:03:19,450 --> 00:03:22,900
value it should give you the value of

00:03:21,580 --> 00:03:26,470
one as a result because you're

00:03:22,900 --> 00:03:29,410
essentially adding 0 2 number so 1 plus

00:03:26,470 --> 00:03:30,700
0 which in this case is all ones the

00:03:29,410 --> 00:03:32,650
first iteration through it would give

00:03:30,700 --> 00:03:34,720
you 0 but there's a one in the carry

00:03:32,650 --> 00:03:36,610
field so you add that back in it it

00:03:34,720 --> 00:03:38,620
gives you back one that's how the

00:03:36,610 --> 00:03:41,830
identity properties kind of work for the

00:03:38,620 --> 00:03:45,790
ones complement checksum you wanted to

00:03:41,830 --> 00:03:48,100
compliment some and so in terms of

00:03:45,790 --> 00:03:49,830
generating the sums themselves there's a

00:03:48,100 --> 00:03:52,750
few basic rules for saying this all up

00:03:49,830 --> 00:03:54,340
in the case of ipv4 what you end up

00:03:52,750 --> 00:03:56,650
doing is just populate the checksum

00:03:54,340 --> 00:04:00,820
value with zero you want to go through

00:03:56,650 --> 00:04:02,290
some of the whole value and you probably

00:04:00,820 --> 00:04:04,360
the ones that you get the ones

00:04:02,290 --> 00:04:07,210
complement of that value and you saw

00:04:04,360 --> 00:04:09,370
that as the checksum and then by doing

00:04:07,210 --> 00:04:12,250
that we can then do is go through and

00:04:09,370 --> 00:04:14,440
validate you add the entire ones

00:04:12,250 --> 00:04:18,190
complement some of the IP header what

00:04:14,440 --> 00:04:20,440
you should get is the negative zero all

00:04:18,190 --> 00:04:26,710
ones value and then you know that that

00:04:20,440 --> 00:04:29,140
checksum is valid the TCP and UDP gets a

00:04:26,710 --> 00:04:31,650
little bit more complicated in the case

00:04:29,140 --> 00:04:34,090
of TCP and UDP we have the idea of a

00:04:31,650 --> 00:04:36,460
pseudo header which is included as part

00:04:34,090 --> 00:04:38,320
of the checksum it's not at any actual

00:04:36,460 --> 00:04:40,720
data that's part of the transport but

00:04:38,320 --> 00:04:43,270
it's something that gets added in and

00:04:40,720 --> 00:04:44,630
those extra fields usually consist of

00:04:43,270 --> 00:04:47,330
the source ipv

00:04:44,630 --> 00:04:50,540
ipv6 addresses same thing for the

00:04:47,330 --> 00:04:53,720
destination a protocol number which gets

00:04:50,540 --> 00:04:55,520
added up to 16 bits in the byte order

00:04:53,720 --> 00:05:00,080
that you're processing in so if you're

00:04:55,520 --> 00:05:01,100
processing remember you'll be big endian

00:05:00,080 --> 00:05:03,410
if you're processing everything in the

00:05:01,100 --> 00:05:05,180
native network byte order to embed it

00:05:03,410 --> 00:05:09,620
from an 8-bit value to a 16-bit

00:05:05,180 --> 00:05:11,810
big-endian value and then the length so

00:05:09,620 --> 00:05:14,990
you add those all together you store

00:05:11,810 --> 00:05:17,900
that one's complement some in the 04

00:05:14,990 --> 00:05:20,840
check some value for the transport so

00:05:17,900 --> 00:05:24,230
when we ask for something like netif f

00:05:20,840 --> 00:05:26,690
hardware see some as a feature we expect

00:05:24,230 --> 00:05:28,340
to have that value populated so then

00:05:26,690 --> 00:05:29,720
from that point on the hardware can just

00:05:28,340 --> 00:05:31,670
start at that point compute the whole

00:05:29,720 --> 00:05:33,140
checksum and store it in the resultant

00:05:31,670 --> 00:05:39,800
offset value which happens to be where

00:05:33,140 --> 00:05:41,900
we stored the pseudo checksum so that's

00:05:39,800 --> 00:05:44,240
the basics have checked some now we

00:05:41,900 --> 00:05:46,250
start getting into the basics of gdp

00:05:44,240 --> 00:05:48,890
encapsulation which in the grand scheme

00:05:46,250 --> 00:05:50,930
of things is all fairly simple until

00:05:48,890 --> 00:05:52,760
well it's complicated when you start

00:05:50,930 --> 00:05:55,070
think taking off roads into account so

00:05:52,760 --> 00:05:57,500
basic idea here i'm showing you you have

00:05:55,070 --> 00:05:58,700
a standard tcp frame we put together so

00:05:57,500 --> 00:06:00,560
we want to send it across the tunnel

00:05:58,700 --> 00:06:03,110
let's see the single laser pointer yet

00:06:00,560 --> 00:06:04,640
so what we end up doing is we stop in

00:06:03,110 --> 00:06:06,790
this case i'm using VX Lana is an

00:06:04,640 --> 00:06:10,250
example but this could be any kind of

00:06:06,790 --> 00:06:17,180
UDP metod be any kind of tunnel metadata

00:06:10,250 --> 00:06:18,350
so we could have foo Janine then doing a

00:06:17,180 --> 00:06:19,850
lot of different types you can basically

00:06:18,350 --> 00:06:21,800
stick on here and three you can even

00:06:19,850 --> 00:06:23,630
just have nothing and just have a tunnel

00:06:21,800 --> 00:06:26,030
that's basically just based on pure port

00:06:23,630 --> 00:06:28,280
number if you wanted to but essentially

00:06:26,030 --> 00:06:29,810
you have this extra UDP section that

00:06:28,280 --> 00:06:31,580
you're adding so you can move this

00:06:29,810 --> 00:06:33,860
entire section across to the other end

00:06:31,580 --> 00:06:35,200
and then script that header off and move

00:06:33,860 --> 00:06:38,050
this your awesome network as though

00:06:35,200 --> 00:06:44,380
it's all one to one logical Oh two

00:06:38,050 --> 00:06:45,580
segments so you're saying it that piece

00:06:44,380 --> 00:06:48,030
of it makes it easy but it always

00:06:45,580 --> 00:06:50,620
suddenly have all these complications

00:06:48,030 --> 00:06:53,020
one of the big ones being existing

00:06:50,620 --> 00:06:54,850
Hardware sees a UDP packet it thinks

00:06:53,020 --> 00:06:59,830
okay it's you p packet I'm across as a

00:06:54,850 --> 00:07:01,690
UDP packet well it adds some certain

00:06:59,830 --> 00:07:04,060
complications in addition we're dealing

00:07:01,690 --> 00:07:06,460
with switches that want to be able to

00:07:04,060 --> 00:07:08,470
add these headers switches traditionally

00:07:06,460 --> 00:07:13,000
don't add and remove checksums two

00:07:08,470 --> 00:07:14,710
packets so in these specification for

00:07:13,000 --> 00:07:16,990
the excellent for instance they suggest

00:07:14,710 --> 00:07:19,810
that you should not use the outer

00:07:16,990 --> 00:07:21,910
checksum and set it to zero the problem

00:07:19,810 --> 00:07:24,220
is okay then as a Knick you were seeing

00:07:21,910 --> 00:07:26,290
the frame that's UDP no checks emma kate

00:07:24,220 --> 00:07:32,920
is pats up the stack which means now

00:07:26,290 --> 00:07:35,470
we've lost our SS arts checksum gr 0 etc

00:07:32,920 --> 00:07:36,910
passing up the stack that way and so we

00:07:35,470 --> 00:07:38,590
have to start doing some parsing and

00:07:36,910 --> 00:07:41,560
software to try to counteract some of

00:07:38,590 --> 00:07:44,560
that but like i said we just lost

00:07:41,560 --> 00:07:47,110
checksum that makes GRL harder in

00:07:44,560 --> 00:07:49,510
addition the hard was trying to do

00:07:47,110 --> 00:07:50,890
something like TSO we can't segment it

00:07:49,510 --> 00:07:52,420
if we don't know how to deal with those

00:07:50,890 --> 00:07:54,730
extra headers that were added onto the

00:07:52,420 --> 00:07:55,990
frame so it's another complication in

00:07:54,730 --> 00:08:00,670
all is so we need to find a way to work

00:07:55,990 --> 00:08:03,250
around that I mean in addition we start

00:08:00,670 --> 00:08:06,730
having other problems in that

00:08:03,250 --> 00:08:09,360
presentation earlier just adding a ipv6

00:08:06,730 --> 00:08:11,920
extension header you know broke ixgbe

00:08:09,360 --> 00:08:13,330
you know it couldn't do TX check sums at

00:08:11,920 --> 00:08:15,040
that point well the same kind of thing

00:08:13,330 --> 00:08:15,569
goes on for UTV checksums well you I'll

00:08:15,040 --> 00:08:16,860
always tell

00:08:15,569 --> 00:08:19,259
as how is it supposed to know where the

00:08:16,860 --> 00:08:20,759
tunnels headers are going to add code

00:08:19,259 --> 00:08:23,099
tell the drivers going and parsing

00:08:20,759 --> 00:08:26,699
looking for that we definitely don't

00:08:23,099 --> 00:08:30,240
have to do that but some have to find a

00:08:26,699 --> 00:08:32,279
way to address that so actually what I

00:08:30,240 --> 00:08:35,669
ended up doing is in the case of the

00:08:32,279 --> 00:08:37,519
intel drivers as we grow tall the driver

00:08:35,669 --> 00:08:40,469
code to simplify it made it all

00:08:37,519 --> 00:08:44,579
essentially knit net hardware checks

00:08:40,469 --> 00:08:46,709
them compliant the reason being is

00:08:44,579 --> 00:08:49,649
there's essentially two different

00:08:46,709 --> 00:08:51,540
approaches to check sums there's the IPC

00:08:49,649 --> 00:08:55,680
some feature which is floating around

00:08:51,540 --> 00:08:57,360
out there the IP pmipv6 one as well most

00:08:55,680 --> 00:08:59,639
of those usually end up doing some sort

00:08:57,360 --> 00:09:00,839
of parsing inside the packet which means

00:08:59,639 --> 00:09:02,670
they have to be able to recognize the

00:09:00,839 --> 00:09:04,920
protocols in order to be able to do a

00:09:02,670 --> 00:09:07,889
checksum offload the advantage of netif

00:09:04,920 --> 00:09:10,170
hardware checksum is the stack just says

00:09:07,889 --> 00:09:13,079
your texas types here you write your

00:09:10,170 --> 00:09:14,370
resultant value there go and so if we

00:09:13,079 --> 00:09:16,190
can support that approach then the

00:09:14,370 --> 00:09:19,980
tunnels become easy for us to do the

00:09:16,190 --> 00:09:21,420
inner TX check sums on but there's some

00:09:19,980 --> 00:09:24,480
other complication still I need to get

00:09:21,420 --> 00:09:26,009
to in a second here on that the other

00:09:24,480 --> 00:09:32,670
piece being yeah like I said can't do

00:09:26,009 --> 00:09:35,100
TSL then yeah see so the other piece in

00:09:32,670 --> 00:09:38,250
all of this is we end up with more

00:09:35,100 --> 00:09:40,980
regions to check some so if we have an

00:09:38,250 --> 00:09:42,750
outer UDP header and we want to do

00:09:40,980 --> 00:09:44,759
checks them on it then we're actually

00:09:42,750 --> 00:09:46,529
asking to do two different checksums at

00:09:44,759 --> 00:09:49,380
the same time so you've won for the TCP

00:09:46,529 --> 00:09:50,639
header and one for the UDP header most

00:09:49,380 --> 00:09:54,750
hardware at this point is designed to

00:09:50,639 --> 00:09:56,220
just do one which you know for when we

00:09:54,750 --> 00:09:57,930
only had to deal with this one that was

00:09:56,220 --> 00:09:59,160
great but not we've got the potential

00:09:57,930 --> 00:10:00,959
for two of that has additional

00:09:59,160 --> 00:10:04,009
complications so we need to start

00:10:00,959 --> 00:10:06,689
finding ways to deal with that that's

00:10:04,009 --> 00:10:10,079
where we start out with us adding some

00:10:06,689 --> 00:10:13,560
new offloads so Tom going to work on

00:10:10,079 --> 00:10:15,300
providing remote checksum offload so

00:10:13,560 --> 00:10:17,639
what we end up doing since we know we

00:10:15,300 --> 00:10:18,930
have to do with checksum and this UDP

00:10:17,639 --> 00:10:21,270
checks and was overlapping

00:10:18,930 --> 00:10:23,580
region that was covered by the TCP

00:10:21,270 --> 00:10:25,529
checksum instead of providing two

00:10:23,580 --> 00:10:27,839
methods of outing the data just focus it

00:10:25,529 --> 00:10:29,070
all down to one and so all you need to

00:10:27,839 --> 00:10:31,410
do is include a little bit of metadata

00:10:29,070 --> 00:10:33,570
with the VX land header in this case or

00:10:31,410 --> 00:10:37,470
whatever your tunnel header is so that

00:10:33,570 --> 00:10:38,670
it knows ok this check sums being

00:10:37,470 --> 00:10:42,060
deferred because we know this is going

00:10:38,670 --> 00:10:44,220
to be encapsulated and so we'll have the

00:10:42,060 --> 00:10:45,690
remote checksum off of data here we'll

00:10:44,220 --> 00:10:48,480
put the packet out on the wire with just

00:10:45,690 --> 00:10:50,070
its outer checksum on the receiver when

00:10:48,480 --> 00:10:52,080
it d capsulate sit and sends a packet

00:10:50,070 --> 00:10:54,089
somewhere else at that point if you

00:10:52,080 --> 00:10:56,279
invert this outer checksum into an inner

00:10:54,089 --> 00:10:59,970
checksum and then let it move across the

00:10:56,279 --> 00:11:02,310
network still this works but also add

00:10:59,970 --> 00:11:03,510
some complications specifically since

00:11:02,310 --> 00:11:07,440
we're now carrying some more metadata

00:11:03,510 --> 00:11:09,630
here it means the TX segmentation

00:11:07,440 --> 00:11:12,270
offloads have to be aware of it and so

00:11:09,630 --> 00:11:13,740
if you end up with some offload here

00:11:12,270 --> 00:11:15,810
where we're actually like in the case of

00:11:13,740 --> 00:11:17,940
our CEO fortunately for VX plan it

00:11:15,810 --> 00:11:20,880
doesn't change the actual header format

00:11:17,940 --> 00:11:23,459
but for protocols that would it require

00:11:20,880 --> 00:11:28,470
extra headers it might make things more

00:11:23,459 --> 00:11:30,930
complicated so we ended up looking to

00:11:28,470 --> 00:11:34,589
another solution on all this that being

00:11:30,930 --> 00:11:36,170
local checksum offload this is something

00:11:34,589 --> 00:11:38,580
that would create actually thought up

00:11:36,170 --> 00:11:40,680
basically it comes down to as I can

00:11:38,580 --> 00:11:43,290
mention before when we've already to

00:11:40,680 --> 00:11:46,290
check some what we end up with is we

00:11:43,290 --> 00:11:49,410
should get the all the negative zero

00:11:46,290 --> 00:11:51,570
answer if we do the checksum from the

00:11:49,410 --> 00:11:54,240
end of data to here and we fold in the

00:11:51,570 --> 00:11:58,200
pseudo header checksum so that means at

00:11:54,240 --> 00:12:00,540
this point we know that the resultant

00:11:58,200 --> 00:12:03,930
checksum for all of this should be the

00:12:00,540 --> 00:12:07,680
inverse of the pseudo header checksum so

00:12:03,930 --> 00:12:09,170
knowing that instead of having to do to

00:12:07,680 --> 00:12:11,670
check something over all of the data

00:12:09,170 --> 00:12:13,920
this UDP header checksum can actually be

00:12:11,670 --> 00:12:15,250
shortened quite a bit this is like you

00:12:13,920 --> 00:12:18,430
know for instance if we're doing

00:12:15,250 --> 00:12:22,000
this also cancels itself out so then

00:12:18,430 --> 00:12:24,580
you're really need to do an IPL UDP

00:12:22,000 --> 00:12:26,170
checks them over this region and then

00:12:24,580 --> 00:12:30,520
adjust for this pseudo header and that's

00:12:26,170 --> 00:12:32,140
pretty much it for ipv6 it's a little

00:12:30,520 --> 00:12:34,960
bit more complicated because we don't

00:12:32,140 --> 00:12:36,400
have the ipv4 cancelling out but we can

00:12:34,960 --> 00:12:38,610
essentially still only have to do a

00:12:36,400 --> 00:12:40,840
checksum over this region and the

00:12:38,610 --> 00:12:42,580
hardware itself can take care of doing

00:12:40,840 --> 00:12:46,350
the awkward for this region see

00:12:42,580 --> 00:12:48,790
advantages in the case of larger planes

00:12:46,350 --> 00:12:50,380
this region can be handled by hardware

00:12:48,790 --> 00:12:52,510
and we're only having to do this region

00:12:50,380 --> 00:12:55,600
in software and that gives us the

00:12:52,510 --> 00:12:57,760
advantage of this most likely in case I

00:12:55,600 --> 00:13:00,460
dv6 work we had 70 bytes in the case

00:12:57,760 --> 00:13:02,380
ipv4 it's only about 15 that we have to

00:13:00,460 --> 00:13:04,090
perform two checks them on but doing a

00:13:02,380 --> 00:13:05,560
check so a map few bytes is considerably

00:13:04,090 --> 00:13:11,230
faster than having to do it for an

00:13:05,560 --> 00:13:13,030
entire 1500 MTU Datagram so it allows us

00:13:11,230 --> 00:13:14,770
to basically avoid having to focus the

00:13:13,030 --> 00:13:16,660
hardware checksum on the payload data

00:13:14,770 --> 00:13:19,240
which ends up being a significant saving

00:13:16,660 --> 00:13:21,730
since before what was happening is we do

00:13:19,240 --> 00:13:24,040
this check sum in software and then also

00:13:21,730 --> 00:13:25,390
this one the hardware and so there ended

00:13:24,040 --> 00:13:26,980
up being no gain at all because we're

00:13:25,390 --> 00:13:29,010
having to do basic both a hardware

00:13:26,980 --> 00:13:35,680
checks them off load and this software

00:13:29,010 --> 00:13:37,630
checksum so knowing all that we went to

00:13:35,680 --> 00:13:38,800
really got lco implemented and then the

00:13:37,630 --> 00:13:40,000
question is is there a way we can

00:13:38,800 --> 00:13:42,370
actually somehow apply this to

00:13:40,000 --> 00:13:47,380
segmentation offload so that's why I

00:13:42,370 --> 00:13:49,660
started looking into this case being I

00:13:47,380 --> 00:13:52,420
wanted to be able to support putting a

00:13:49,660 --> 00:13:55,690
check some out here specifically because

00:13:52,420 --> 00:13:57,520
most hardware well actually I'll take a

00:13:55,690 --> 00:13:58,990
step back so when arcielo was

00:13:57,520 --> 00:14:02,260
implemented one of the things Tom

00:13:58,990 --> 00:14:04,900
introduced was a concept of converting

00:14:02,260 --> 00:14:07,000
the outer checksum into the inner

00:14:04,900 --> 00:14:08,950
checksum so you can basically carry it

00:14:07,000 --> 00:14:11,840
forward and you converge what's called

00:14:08,950 --> 00:14:13,280
checksum complete we're just going to

00:14:11,840 --> 00:14:15,500
drivers do this we wouldn't have to do

00:14:13,280 --> 00:14:18,200
all these extra hoops but this thing

00:14:15,500 --> 00:14:21,260
would take the autocheck 7 and use it to

00:14:18,200 --> 00:14:23,000
validate the inner checksum and so on

00:14:21,260 --> 00:14:25,940
hardware that supports just UDP check

00:14:23,000 --> 00:14:28,220
sums if this is populated with the

00:14:25,940 --> 00:14:30,470
checksum value then we can make use of

00:14:28,220 --> 00:14:32,840
gr 0 and that gives us much better

00:14:30,470 --> 00:14:38,990
throughput from what I've seen I can get

00:14:32,840 --> 00:14:41,630
somewhere about six gigabits without GRL

00:14:38,990 --> 00:14:43,550
or received without any kind of rx check

00:14:41,630 --> 00:14:45,860
some out tunnel recognizing arts

00:14:43,550 --> 00:14:49,160
checksum offload but I have this outer

00:14:45,860 --> 00:14:51,230
UDP checksum present then I can move it

00:14:49,160 --> 00:14:54,920
about 12 bigots 11 to 12 gigabits

00:14:51,230 --> 00:14:57,680
depending on the hardware setup so what

00:14:54,920 --> 00:14:58,670
I wanted to do is take all this harder

00:14:57,680 --> 00:15:00,920
that's out there that's starting to

00:14:58,670 --> 00:15:03,650
recognize how to perform TSO for a

00:15:00,920 --> 00:15:05,960
tunnel Datagram and make it so that it

00:15:03,650 --> 00:15:08,510
could do TSO for a tunnel Datagram with

00:15:05,960 --> 00:15:11,300
the auto UDP checksum so you could have

00:15:08,510 --> 00:15:15,290
a homogeneous environment and improve

00:15:11,300 --> 00:15:16,940
the overall performance so I started

00:15:15,290 --> 00:15:18,700
looking into this I found a couple of

00:15:16,940 --> 00:15:21,320
things that kind of started to happen

00:15:18,700 --> 00:15:23,860
specifically when you segment a frame

00:15:21,320 --> 00:15:27,050
like this like just doing it in software

00:15:23,860 --> 00:15:29,900
that the checksum for all of these

00:15:27,050 --> 00:15:32,810
packets except for the last was exactly

00:15:29,900 --> 00:15:34,280
the same value every one of these UDP

00:15:32,810 --> 00:15:36,500
checksums had the exact same value

00:15:34,280 --> 00:15:39,800
except for the last one and what it

00:15:36,500 --> 00:15:42,230
turned out to be is essentially all the

00:15:39,800 --> 00:15:46,700
data appear was canceling itself out so

00:15:42,230 --> 00:15:49,340
ipv4 has a length field in it and a

00:15:46,700 --> 00:15:51,770
third the length field will vary between

00:15:49,340 --> 00:15:53,170
these last two the other piece that fire

00:15:51,770 --> 00:15:55,600
TV for that varies is the

00:15:53,170 --> 00:15:57,910
a field I didn't need to worry about it

00:15:55,600 --> 00:16:00,100
the check some frightening for will

00:15:57,910 --> 00:16:03,070
cancel out that ID field so that by

00:16:00,100 --> 00:16:06,760
winds up being a wash in the final

00:16:03,070 --> 00:16:07,959
result same thing for tcp all I had to

00:16:06,760 --> 00:16:09,279
worry about was the pseudo header

00:16:07,959 --> 00:16:12,190
checksum and those values don't change

00:16:09,279 --> 00:16:14,500
as long as the length is fixed so i

00:16:12,190 --> 00:16:17,440
could do is i only need to compute this

00:16:14,500 --> 00:16:20,380
value once and somehow stuff it into all

00:16:17,440 --> 00:16:23,500
of these spots and that this last piece

00:16:20,380 --> 00:16:25,420
I had to do something else with so the

00:16:23,500 --> 00:16:26,980
idea I came up with is well I'll just go

00:16:25,420 --> 00:16:30,459
ahead and chop this off into an even

00:16:26,980 --> 00:16:32,589
multiple of MSS popular the value here

00:16:30,459 --> 00:16:34,449
they gotta cross my fingers and see what

00:16:32,589 --> 00:16:36,760
happens start testing hardware to see

00:16:34,449 --> 00:16:39,579
what they're doing with this value my

00:16:36,760 --> 00:16:41,230
hope was maybe it's dumb hardware I'll

00:16:39,579 --> 00:16:43,000
just stuck in whatever I gave it

00:16:41,230 --> 00:16:44,500
assuming that I was going to give it

00:16:43,000 --> 00:16:48,070
zero but instead of just carries it

00:16:44,500 --> 00:16:50,949
through that's pretty much what it ended

00:16:48,070 --> 00:16:54,670
up doing so I I was actually starting

00:16:50,949 --> 00:16:55,870
out with high for TE use my test then

00:16:54,670 --> 00:16:57,370
moved on to some other parts actually

00:16:55,870 --> 00:17:00,550
had a couple mellanox next I could test

00:16:57,370 --> 00:17:02,170
with as well but basically later that

00:17:00,550 --> 00:17:04,329
finding is whatever value you stepped in

00:17:02,170 --> 00:17:07,020
here in almost all cases it would just

00:17:04,329 --> 00:17:10,660
get replicated so I could do is

00:17:07,020 --> 00:17:12,610
calculate this everything before the TCP

00:17:10,660 --> 00:17:15,250
header essentially as though i was

00:17:12,610 --> 00:17:17,589
actually sending a single frame and then

00:17:15,250 --> 00:17:19,240
the rest of this can all be segmented by

00:17:17,589 --> 00:17:20,559
the hardware it would have no impact on

00:17:19,240 --> 00:17:23,260
any of the checksums there any of the

00:17:20,559 --> 00:17:25,329
data up front here and so i could hand

00:17:23,260 --> 00:17:27,130
that to the hardware at would segment it

00:17:25,329 --> 00:17:29,860
like it was a normal frame the other

00:17:27,130 --> 00:17:31,270
thing I found is it looks like the TSO

00:17:29,860 --> 00:17:33,160
code by default if you're especially

00:17:31,270 --> 00:17:36,190
under stress this gives you even

00:17:33,160 --> 00:17:37,600
multiple MSS segments anyway often than

00:17:36,190 --> 00:17:39,400
not I didn't see this little trailer

00:17:37,600 --> 00:17:41,850
just always in at the MSS chunks as long

00:17:39,400 --> 00:17:45,760
as you're you know saturating the wire

00:17:41,850 --> 00:17:47,520
and so that made it so essentially I had

00:17:45,760 --> 00:17:49,080
you know this whole section could it be

00:17:47,520 --> 00:17:50,340
replica especially

00:17:49,080 --> 00:17:51,750
kiss ipv6 I could just basically

00:17:50,340 --> 00:17:55,140
replicate everything from here to the

00:17:51,750 --> 00:17:57,000
end kiss ipv4 I have the ID fields out

00:17:55,140 --> 00:17:58,169
of way about the other than that this

00:17:57,000 --> 00:18:04,230
whole block is essentially being

00:17:58,169 --> 00:18:07,350
replicated by the hardware but I got me

00:18:04,230 --> 00:18:10,140
thinking so that whole block like I

00:18:07,350 --> 00:18:11,880
mentioned here this whole thing is

00:18:10,140 --> 00:18:13,470
essentially replicated I had it written

00:18:11,880 --> 00:18:14,730
down and the hardware is just

00:18:13,470 --> 00:18:17,429
duplicating it for the most part the

00:18:14,730 --> 00:18:19,980
only difference being the ipv4 ID fields

00:18:17,429 --> 00:18:21,870
would vary and so I started thinking to

00:18:19,980 --> 00:18:23,580
myself is there some way I could make it

00:18:21,870 --> 00:18:25,019
so I could do tunnel offloads on

00:18:23,580 --> 00:18:28,799
hardware that doesn't actually support

00:18:25,019 --> 00:18:32,130
tunnel offloads so I started looking

00:18:28,799 --> 00:18:34,169
into it kiss ipv6 I can just support it

00:18:32,130 --> 00:18:36,000
done instant win if I can just come up

00:18:34,169 --> 00:18:38,399
with a way of getting that whole header

00:18:36,000 --> 00:18:42,299
to be replicated that works great for me

00:18:38,399 --> 00:18:46,500
the only problem is ipv4 ID field so I

00:18:42,299 --> 00:18:48,600
started looking into it more for the

00:18:46,500 --> 00:18:51,539
most part TCP flows always set the DF

00:18:48,600 --> 00:18:52,740
bit so that being the case we don't have

00:18:51,539 --> 00:18:55,380
to worry about the head is being

00:18:52,740 --> 00:18:57,720
fragmented so then why do we care about

00:18:55,380 --> 00:18:59,549
the ID field did some more digging it

00:18:57,720 --> 00:19:01,260
turns out there's even an RFC that

00:18:59,549 --> 00:19:03,809
states you're not supposed to be looking

00:19:01,260 --> 00:19:07,289
at the ID field unless you can actually

00:19:03,809 --> 00:19:08,940
fragment the packet and so instead of

00:19:07,289 --> 00:19:11,100
looking at it that's like okay well in

00:19:08,940 --> 00:19:13,409
that case maybe I'll just go ahead and

00:19:11,100 --> 00:19:18,149
help on a driver in this case being

00:19:13,409 --> 00:19:19,740
ixgbe I added a feature a different

00:19:18,149 --> 00:19:22,919
feature initiative delighted up coming

00:19:19,740 --> 00:19:26,279
up with was this feature fight neta fpso

00:19:22,919 --> 00:19:29,340
mingle ID it basically means 40 so as

00:19:26,279 --> 00:19:32,000
long as DF fifth set let the hardware do

00:19:29,340 --> 00:19:32,960
whatever it wants with the IP I

00:19:32,000 --> 00:19:35,240
I don't care if you want to replicate

00:19:32,960 --> 00:19:37,760
the one you've got go for it if you want

00:19:35,240 --> 00:19:41,300
to increment go for it just go ahead and

00:19:37,760 --> 00:19:42,860
do it the one got you on that though is

00:19:41,300 --> 00:19:45,980
that you get it quite a bit of pushback

00:19:42,860 --> 00:19:48,080
because essentially the case of jro with

00:19:45,980 --> 00:19:51,890
gso we can potentially end up losing

00:19:48,080 --> 00:19:54,230
data because the ipi ipv4 ids aren't

00:19:51,890 --> 00:19:56,270
getting the same necessarily as they

00:19:54,230 --> 00:19:58,520
were coming in to relieve it right now

00:19:56,270 --> 00:20:00,710
and disabled by default they're pretty

00:19:58,520 --> 00:20:02,750
much any hardware that can support TSO

00:20:00,710 --> 00:20:06,320
right now is getting the hardware flag

00:20:02,750 --> 00:20:09,500
hardware feature flag for this set so it

00:20:06,320 --> 00:20:11,210
could turn it on the basically giving

00:20:09,500 --> 00:20:13,540
there was some other cases that came up

00:20:11,210 --> 00:20:16,790
that could actually benefit from this

00:20:13,540 --> 00:20:19,040
the submit result I ended up working /

00:20:16,790 --> 00:20:21,200
suffice GBE but the most of the intel

00:20:19,040 --> 00:20:23,150
drivers had a similar mechanism well as

00:20:21,200 --> 00:20:25,430
actually doing as I was cheating they

00:20:23,150 --> 00:20:27,860
have this concept of IP and IP tunnel

00:20:25,430 --> 00:20:30,820
support which really wasn't really IP

00:20:27,860 --> 00:20:34,400
nike tell support is support a flexible

00:20:30,820 --> 00:20:36,590
l3 header size so i can specify any

00:20:34,400 --> 00:20:38,870
length up to 511 bytes as my l three

00:20:36,590 --> 00:20:40,820
heather so i went ahead and started

00:20:38,870 --> 00:20:43,640
saying okay you're gonna skip everything

00:20:40,820 --> 00:20:44,960
except for the other header main reason

00:20:43,640 --> 00:20:46,640
i had to keep the outer header is

00:20:44,960 --> 00:20:49,520
because i had to be able to increment

00:20:46,640 --> 00:20:53,570
the ipid in the outer header because the

00:20:49,520 --> 00:20:54,830
UDP tunnels do not support where mrs.

00:20:53,570 --> 00:20:57,020
have the DF bit because they don't

00:20:54,830 --> 00:20:59,840
support pop into you discovery and

00:20:57,020 --> 00:21:02,210
whatnot so you they're always going to

00:20:59,840 --> 00:21:04,970
be fragmenta Buhl's so i do have to keep

00:21:02,210 --> 00:21:06,920
this field intact but everything

00:21:04,970 --> 00:21:12,440
accurate i can basically skip as though

00:21:06,920 --> 00:21:14,840
it's one giant IP option let's see and

00:21:12,440 --> 00:21:16,430
then yeah and so as long as none of

00:21:14,840 --> 00:21:18,760
these fields have to be modified i can

00:21:16,430 --> 00:21:21,320
go ahead and support TSO on the hardware

00:21:18,760 --> 00:21:21,680
the one gotcha like i said as treating

00:21:21,320 --> 00:21:24,410
this

00:21:21,680 --> 00:21:26,660
one giant IP option as it turned out the

00:21:24,410 --> 00:21:29,000
ipv4 header was trying to compute the

00:21:26,660 --> 00:21:32,360
checksum over this entire region so I

00:21:29,000 --> 00:21:33,830
had to take the checksum first how to

00:21:32,360 --> 00:21:35,420
actually take the checksum for this

00:21:33,830 --> 00:21:37,960
entire region and stuff it in here

00:21:35,420 --> 00:21:40,400
instead of 0 to see the checksum itself

00:21:37,960 --> 00:21:41,900
what to do that then it went to check

00:21:40,400 --> 00:21:43,820
some of that whole thing and cannot

00:21:41,900 --> 00:21:46,100
cancel that out they'd only did that bit

00:21:43,820 --> 00:21:54,200
so it's a bit of a dirty hack but it

00:21:46,100 --> 00:21:55,670
actually makes it all work so got that

00:21:54,200 --> 00:21:57,680
out there pushed couple patches and

00:21:55,670 --> 00:21:58,760
actually try to get some feedback one of

00:21:57,680 --> 00:22:01,160
the things actually came up as

00:21:58,760 --> 00:22:03,830
everything is that was doing apparently

00:22:01,160 --> 00:22:05,870
people doing ipv6 died be4 translation

00:22:03,830 --> 00:22:09,050
we're suddenly jumping to join with this

00:22:05,870 --> 00:22:11,180
because they got grls support one of the

00:22:09,050 --> 00:22:13,190
things that as a result of this I had a

00:22:11,180 --> 00:22:16,100
stable support fixed ID on the GRL side

00:22:13,190 --> 00:22:19,310
so in the process I basically added a

00:22:16,100 --> 00:22:21,500
new gso type called fixed ID which

00:22:19,310 --> 00:22:24,020
basically means i saw this packet coming

00:22:21,500 --> 00:22:27,440
in and the ipid was not changing so it's

00:22:24,020 --> 00:22:29,120
this value for all packets gives EG RL

00:22:27,440 --> 00:22:31,880
bound with segments side it's that

00:22:29,120 --> 00:22:33,500
unless you have the mango ID on so that

00:22:31,880 --> 00:22:37,610
the grand scheme of things basically it

00:22:33,500 --> 00:22:42,100
gives us a way to deal with things that

00:22:37,610 --> 00:22:46,220
are already mangling the ipv4 ID field

00:22:42,100 --> 00:22:47,600
see ya so you like this real quick so

00:22:46,220 --> 00:22:49,700
yeah basing that result with all of this

00:22:47,600 --> 00:22:52,280
stuff as I saw a fairly significant

00:22:49,700 --> 00:22:53,870
performance gain I didn't want to

00:22:52,280 --> 00:22:55,350
actually say the numbers for it because

00:22:53,870 --> 00:22:59,370
it's kind of hard for me too

00:22:55,350 --> 00:23:01,500
the cataloging exactly because like Nick

00:22:59,370 --> 00:23:06,179
I was testing on like in the case of

00:23:01,500 --> 00:23:08,429
ixgbe as actually testing from the PF to

00:23:06,179 --> 00:23:10,020
a BF and the farmers I didn't have

00:23:08,429 --> 00:23:11,940
enough pcie bandwidth to actually

00:23:10,020 --> 00:23:14,549
measure the link in between as I hit the

00:23:11,940 --> 00:23:17,610
pcie rate limit so I was bottlenecks I

00:23:14,549 --> 00:23:20,309
couldn't tell the actual game I guess he

00:23:17,610 --> 00:23:22,230
had gone from six to fifteen gigabits

00:23:20,309 --> 00:23:24,150
for throughput and it's like okay well I

00:23:22,230 --> 00:23:26,130
can't go any faster cuz that's the same

00:23:24,150 --> 00:23:28,260
level i was getting if i did just TSO

00:23:26,130 --> 00:23:30,570
across it without the tunnel so i was

00:23:28,260 --> 00:23:32,010
basically capped at pcie at that one by

00:23:30,570 --> 00:23:36,179
looking like at least a two to three x

00:23:32,010 --> 00:23:39,659
gain photos through put on all that but

00:23:36,179 --> 00:23:41,429
yeah some basic lessons learned everyone

00:23:39,659 --> 00:23:44,690
should really look at translating the

00:23:41,429 --> 00:23:46,950
drivers to support net or piracy some

00:23:44,690 --> 00:23:50,070
anything we're having to push protocols

00:23:46,950 --> 00:23:52,559
is just going to be painful going

00:23:50,070 --> 00:23:55,260
forward there's too many things getting

00:23:52,559 --> 00:23:57,210
added too quickly to the protocol stacks

00:23:55,260 --> 00:23:58,650
for us to keep up with all of it

00:23:57,210 --> 00:24:00,390
basically every time there's a new

00:23:58,650 --> 00:24:02,490
tunnel ally that's like okay you offer

00:24:00,390 --> 00:24:03,900
bliss now as well do we really wanna go

00:24:02,490 --> 00:24:05,760
through a relay all the drivers to add

00:24:03,900 --> 00:24:07,860
that to all of their little parsers that

00:24:05,760 --> 00:24:11,130
they can all recognize that they do or

00:24:07,860 --> 00:24:15,539
they don't support it I prefer did not

00:24:11,130 --> 00:24:18,360
have to do that the other piece checks

00:24:15,539 --> 00:24:20,669
them unnecessary that this is basically

00:24:18,360 --> 00:24:22,289
what all of this is working around is

00:24:20,669 --> 00:24:30,770
the fact that we don't have support for

00:24:22,289 --> 00:24:32,760
this if we had checked some complete

00:24:30,770 --> 00:24:34,260
drivers that supported that basically

00:24:32,760 --> 00:24:36,630
reporting the checks them for the entire

00:24:34,260 --> 00:24:39,990
packet up to but not including the

00:24:36,630 --> 00:24:42,179
ethernet header then what we'd be able

00:24:39,990 --> 00:24:45,030
to do is just use that work backwards

00:24:42,179 --> 00:24:46,740
but the problem is we don't have that so

00:24:45,030 --> 00:24:48,059
we need to have an outer UDP checksum

00:24:46,740 --> 00:24:50,039
present which means you have to have the

00:24:48,059 --> 00:24:52,350
two texts per packet which is why we had

00:24:50,039 --> 00:24:53,730
all this extra complication if we didn't

00:24:52,350 --> 00:24:55,710
have that then the received cyber just

00:24:53,730 --> 00:24:59,370
be able to say okay here I got to check

00:24:55,710 --> 00:25:01,770
someone work it backwards and the last

00:24:59,370 --> 00:25:04,080
eight is parsing based yet parsing is

00:25:01,770 --> 00:25:05,610
just unreliable one of these I was

00:25:04,080 --> 00:25:07,620
kicking myself for is actually had to go

00:25:05,610 --> 00:25:09,270
back and is trying to work on you know

00:25:07,620 --> 00:25:10,650
tens of being a lot of drivers I was

00:25:09,270 --> 00:25:12,809
working on right start testing it's like

00:25:10,650 --> 00:25:14,299
okay the easiest test for me we'll see

00:25:12,809 --> 00:25:19,380
whether or not this is working unless on

00:25:14,299 --> 00:25:20,760
20 b VX way imports on this device and

00:25:19,380 --> 00:25:23,520
after they did about me on like in the

00:25:20,760 --> 00:25:27,360
case i 40 i think it's 16 all of a

00:25:23,520 --> 00:25:29,460
sudden yeah the farm is just craters so

00:25:27,360 --> 00:25:31,919
like with that one it was I get path to

00:25:29,460 --> 00:25:34,500
16 ports and then all of a sudden I'm

00:25:31,919 --> 00:25:35,640
looking at you know six cubits for

00:25:34,500 --> 00:25:38,429
received because it's not doing the

00:25:35,640 --> 00:25:39,900
receive checksum offload anymore but

00:25:38,429 --> 00:25:43,409
fortunately the kiss the Intel parts

00:25:39,900 --> 00:25:44,429
most of them do the TX auds in a generic

00:25:43,409 --> 00:25:45,900
enough way that they're just looking at

00:25:44,429 --> 00:25:47,100
the offsets they don't care about what

00:25:45,900 --> 00:25:49,590
the actual tunnel type is it's just

00:25:47,100 --> 00:25:51,990
received side that's a pad that really

00:25:49,590 --> 00:25:52,500
everyone is where we get into the TX

00:25:51,990 --> 00:25:54,900
pass

00:25:52,500 --> 00:25:56,520
on this staff good example that being

00:25:54,900 --> 00:25:59,010
the FN 10k which I'm kind of kicking

00:25:56,520 --> 00:26:01,140
myself for I fought against it but this

00:25:59,010 --> 00:26:03,990
had sports 1 quart for tunnel off roads

00:26:01,140 --> 00:26:06,150
and the problem is that one point with

00:26:03,990 --> 00:26:07,680
the tunnel alkaloids is both TX and rx

00:26:06,150 --> 00:26:11,850
so if you go often that you have to kill

00:26:07,680 --> 00:26:13,320
all the TX offloads on the part to some

00:26:11,850 --> 00:26:14,610
extent we're working around that and the

00:26:13,320 --> 00:26:18,150
driver could at this point because we've

00:26:14,610 --> 00:26:19,950
got the Zen do features check which is

00:26:18,150 --> 00:26:22,770
basically now becoming this list of okay

00:26:19,950 --> 00:26:25,410
what can't I offload we have to go swim

00:26:22,770 --> 00:26:27,420
stripped features off the features flags

00:26:25,410 --> 00:26:28,980
before we can actually transmit the

00:26:27,420 --> 00:26:32,150
parks you have to verify this point

00:26:28,980 --> 00:26:34,110
whether or not you know you de tunnel

00:26:32,150 --> 00:26:36,300
segmentation really needs you to be

00:26:34,110 --> 00:26:38,970
tunnel segmentation or does it just mean

00:26:36,300 --> 00:26:41,130
this one little tiny piece over here but

00:26:38,970 --> 00:26:42,840
you know okay well we straight off of it

00:26:41,130 --> 00:26:45,840
yeah we turn off all the offloads can't

00:26:42,840 --> 00:26:47,250
support anything it becomes people to do

00:26:45,840 --> 00:26:48,600
that's why I really think we need to get

00:26:47,250 --> 00:26:50,880
to the point where things are just

00:26:48,600 --> 00:26:52,920
generic simple you know check them

00:26:50,880 --> 00:26:54,690
completely and never thought i would

00:26:52,920 --> 00:26:57,750
check some just those two at minimum

00:26:54,690 --> 00:26:59,670
gives you so much improvement gives you

00:26:57,750 --> 00:27:02,240
12 gigs for throughput on at least the

00:26:59,670 --> 00:27:05,430
intel parts why he'll just you know just

00:27:02,240 --> 00:27:06,810
the outer checksum and that and net have

00:27:05,430 --> 00:27:09,390
have I'll go check some gave me 12 gigs

00:27:06,810 --> 00:27:11,070
a throughput vs 6 you're talking about

00:27:09,390 --> 00:27:14,400
doubling performance with just those two

00:27:11,070 --> 00:27:17,000
changes it definitely be worth it just

00:27:14,400 --> 00:27:24,110
to have everybody try to move over that

00:27:17,000 --> 00:27:25,980
so as far as conclusions such see um

00:27:24,110 --> 00:27:27,840
obviously what this ends up being is

00:27:25,980 --> 00:27:29,730
essentially aperture it's a translation

00:27:27,840 --> 00:27:31,350
I had to make except the hardware could

00:27:29,730 --> 00:27:33,960
somehow understand this and that's why

00:27:31,350 --> 00:27:36,539
doing here the funny thing is you know I

00:27:33,960 --> 00:27:39,840
took parts was it web I'm trying to

00:27:36,539 --> 00:27:42,480
think e 2 599 is what nine ten years old

00:27:39,840 --> 00:27:44,100
I got it running about as fast as a

00:27:42,480 --> 00:27:46,620
knife or te wood with the same kind of

00:27:44,100 --> 00:27:48,630
tunnel type just because the TX

00:27:46,620 --> 00:27:50,429
descriptors are flexible enough that can

00:27:48,630 --> 00:27:52,320
do a few little dirty hacks and yeah

00:27:50,429 --> 00:27:56,100
okay there I got support for this tunnel

00:27:52,320 --> 00:27:58,280
type for segmentation offload and so

00:27:56,100 --> 00:28:01,260
doing that I was able to just double the

00:27:58,280 --> 00:28:02,880
RX throughput you know get the TX to the

00:28:01,260 --> 00:28:05,250
point where I couldn't even really max

00:28:02,880 --> 00:28:08,490
out the TX because I hit pcie limits

00:28:05,250 --> 00:28:11,010
before I even got that far no the ends

00:28:08,490 --> 00:28:12,840
up being something where the the less

00:28:11,010 --> 00:28:14,909
complicated you can make this hard we're

00:28:12,840 --> 00:28:17,429
going forward the easier this would make

00:28:14,909 --> 00:28:19,919
it for us the software engineers now

00:28:17,429 --> 00:28:21,809
just basic things like you know with gsm

00:28:19,919 --> 00:28:23,539
partial dis plans wasn't looking at as

00:28:21,809 --> 00:28:25,710
thinking i could almost get away with

00:28:23,539 --> 00:28:27,090
supporting just about anything going

00:28:25,710 --> 00:28:31,830
forward you know i can almost make

00:28:27,090 --> 00:28:35,220
hardware that would have chia social

00:28:31,830 --> 00:28:36,960
support all i need is an offset and a

00:28:35,220 --> 00:28:39,090
checksum offset and that's it yeah

00:28:36,960 --> 00:28:41,100
because I didn't have to change any of

00:28:39,090 --> 00:28:45,960
those other headers anymore so the

00:28:41,100 --> 00:28:48,090
simpler we can keep this the better the

00:28:45,960 --> 00:28:49,669
fact is this is already starting to kick

00:28:48,090 --> 00:28:55,789
out other things so we ended up doing

00:28:49,669 --> 00:28:58,500
worked with Steven classic on getting

00:28:55,789 --> 00:29:01,620
support for supporting progress in

00:28:58,500 --> 00:29:03,780
directly on devices that don't support

00:29:01,620 --> 00:29:06,419
progress because what we can do is just

00:29:03,780 --> 00:29:07,960
okay instead of doing the final Gina so

00:29:06,419 --> 00:29:11,080
and I will split

00:29:07,960 --> 00:29:12,970
apart I'll just break it into just frags

00:29:11,080 --> 00:29:14,770
sk bees and said ones that have fried

00:29:12,970 --> 00:29:16,060
list on it you know you end up saving

00:29:14,770 --> 00:29:21,070
yourself a lot of trouble when you don't

00:29:16,060 --> 00:29:22,990
have to break up pack it up into 40s k

00:29:21,070 --> 00:29:26,710
box you like to do three because you

00:29:22,990 --> 00:29:30,520
know you got your chain of the three

00:29:26,710 --> 00:29:36,130
escapees with 16 descriptor 16 pages

00:29:30,520 --> 00:29:38,200
each relax put on this I'm so ki

00:29:36,130 --> 00:29:40,320
debating it myself but I'm wondering if

00:29:38,200 --> 00:29:44,620
I should enable TSM angle ID by default

00:29:40,320 --> 00:29:47,440
the fact is it's an ipv4 ID for packets

00:29:44,620 --> 00:29:49,870
that have the DF bit set specs as you're

00:29:47,440 --> 00:29:51,940
not supposed to look I'm not sure how

00:29:49,870 --> 00:29:54,310
many cases it would actually hurt to

00:29:51,940 --> 00:29:55,750
just turn this on by default the fact is

00:29:54,310 --> 00:29:57,880
when we actually see performance gain

00:29:55,750 --> 00:29:59,380
for a number of other cases you know if

00:29:57,880 --> 00:30:02,050
you're doing I can be sixth ipv4

00:29:59,380 --> 00:30:04,000
translation it converts the ID feel 20

00:30:02,050 --> 00:30:05,620
do you really want to make somebody have

00:30:04,000 --> 00:30:07,120
to pay an extra penalty to in order to

00:30:05,620 --> 00:30:11,590
rot that off somewhere else or we just

00:30:07,120 --> 00:30:15,460
let them mingle the ipv4 ID it's just

00:30:11,590 --> 00:30:18,310
kind of a thought and all that but yeah

00:30:15,460 --> 00:30:19,810
at the same time it's you know it's one

00:30:18,310 --> 00:30:21,100
as we there's going to be a corner case

00:30:19,810 --> 00:30:22,030
similar that comes back to bite us and

00:30:21,100 --> 00:30:23,710
that's why I'm kind of worried about

00:30:22,030 --> 00:30:25,290
with that that's why I'm not one hundred

00:30:23,710 --> 00:30:28,230
percent certain I should do it or not

00:30:25,290 --> 00:30:33,240
they might but that I think that's all

00:30:28,230 --> 00:30:33,240
Adam so yeah questions

00:30:37,639 --> 00:30:42,289
so I'm yeah I definitely think this

00:30:40,489 --> 00:30:43,849
reflects a lot of great work over the

00:30:42,289 --> 00:30:47,149
years and if you think about where we

00:30:43,849 --> 00:30:49,969
started and where we are you know

00:30:47,149 --> 00:30:53,320
Edwards lco I think that was almost like

00:30:49,969 --> 00:30:56,690
a scientific discovery so G is a partial

00:30:53,320 --> 00:30:58,299
well I'm said like a work here so the

00:30:56,690 --> 00:31:00,950
way i like to think about this is

00:30:58,299 --> 00:31:03,559
there's five basic offloads that we need

00:31:00,950 --> 00:31:08,119
out of a neck RSS receive checks own

00:31:03,559 --> 00:31:10,729
transmit checksum tso and lr 0 so this

00:31:08,119 --> 00:31:12,889
first four actually I think we're pretty

00:31:10,729 --> 00:31:15,079
close to saying they're solved problems

00:31:12,889 --> 00:31:16,639
which is really quite so you can mention

00:31:15,079 --> 00:31:18,679
urss but I think we're just assuming

00:31:16,639 --> 00:31:20,539
that when we didn't you tpain

00:31:18,679 --> 00:31:22,070
capsulation we use a source port to get

00:31:20,539 --> 00:31:23,959
married rupee and that's kind of solved

00:31:22,070 --> 00:31:26,570
and their seeds checksum offload

00:31:23,959 --> 00:31:28,519
transmen checksum offload those are

00:31:26,570 --> 00:31:32,690
solved by the thing we mentioned we're

00:31:28,519 --> 00:31:35,239
so partial solves using TSO so the one

00:31:32,690 --> 00:31:39,229
outstanding one we have now is out front

00:31:35,239 --> 00:31:41,450
LR 0 LOL implies that we have to parse

00:31:39,229 --> 00:31:44,269
the packet your hardware and then we get

00:31:41,450 --> 00:31:46,820
into your problem of hardware specific

00:31:44,269 --> 00:31:48,109
parsers yep so I think we might be at

00:31:46,820 --> 00:31:51,139
the point where we should start to

00:31:48,109 --> 00:31:55,579
figure out can we actually do generic

00:31:51,139 --> 00:31:58,369
lro way talking about like bi xdp right

00:31:55,579 --> 00:31:59,879
now imagine oh that would be a generic

00:31:58,369 --> 00:32:02,579
girona

00:31:59,879 --> 00:32:05,879
new for both but in the case of a

00:32:02,579 --> 00:32:09,179
generic LOL could we load the BPF

00:32:05,879 --> 00:32:12,809
program or something equivalent to do

00:32:09,179 --> 00:32:14,669
the lro logic and hellenistic Lee had

00:32:12,809 --> 00:32:17,819
with LR 0 is its complete black box

00:32:14,669 --> 00:32:20,549
right we have no idea what what the

00:32:17,819 --> 00:32:21,989
device is doing name like lament timers

00:32:20,549 --> 00:32:24,149
we wonder so my god so a lot of us have

00:32:21,989 --> 00:32:26,759
already turned off LRO for that reason

00:32:24,149 --> 00:32:28,409
if it was programmable we may actually

00:32:26,759 --> 00:32:31,709
be able to bring that back into the fold

00:32:28,409 --> 00:32:33,539
so this might be the next frontier of

00:32:31,709 --> 00:32:35,819
the offloads to figure out the LRO

00:32:33,539 --> 00:32:39,419
problem yeah I don't know if that's the

00:32:35,819 --> 00:32:40,919
thing is that's that's the but I think

00:32:39,419 --> 00:32:42,479
to some said that might end up being the

00:32:40,919 --> 00:32:43,919
Trojan horse for vendors to say yeah no

00:32:42,479 --> 00:32:45,959
forget it we have to have the parsers

00:32:43,919 --> 00:32:49,229
that would be my one concern with all

00:32:45,959 --> 00:32:52,799
that well because remember on the list

00:32:49,229 --> 00:32:55,469
we had this other problem if somebody

00:32:52,799 --> 00:32:57,839
wants to do check some unnecessary on an

00:32:55,469 --> 00:32:59,489
inner header right half of course that

00:32:57,839 --> 00:33:01,679
they have to parse the encapsulation

00:32:59,489 --> 00:33:05,099
when we had this problem is their best

00:33:01,679 --> 00:33:07,399
just basing this on UDP port number yet

00:33:05,099 --> 00:33:09,959
which is technically incorrect right and

00:33:07,399 --> 00:33:11,459
it's okay if they're just kind of doing

00:33:09,959 --> 00:33:14,849
checksum all float but if somebody was

00:33:11,459 --> 00:33:17,069
trying to do lr 0 and that wasn't what

00:33:14,849 --> 00:33:19,440
we thought it was because you did p port

00:33:17,069 --> 00:33:21,929
numbers don't have for meaning in the

00:33:19,440 --> 00:33:25,469
network right Becca and a mingling

00:33:21,929 --> 00:33:27,779
packet so in one sense people are going

00:33:25,469 --> 00:33:29,249
to do this anyway so maybe we need to to

00:33:27,779 --> 00:33:31,199
figure out what is the correct way to do

00:33:29,249 --> 00:33:33,599
this we need something down the device

00:33:31,199 --> 00:33:35,309
that's very specific that says this type

00:33:33,599 --> 00:33:38,459
of packet is actually what the host

00:33:35,309 --> 00:33:41,159
thinks it is you're allowed to allow to

00:33:38,459 --> 00:33:43,409
deal with it so we might need this in

00:33:41,159 --> 00:33:46,589
the long run area I think eventually

00:33:43,409 --> 00:33:48,809
they're going to have this and using LRO

00:33:46,589 --> 00:33:50,399
as kind of the case study over the next

00:33:48,809 --> 00:33:52,529
like I said maybe the next frontier

00:33:50,399 --> 00:33:53,969
might be worth looking at ya know

00:33:52,529 --> 00:33:55,440
someone says that's probably true

00:33:53,969 --> 00:33:58,739
because I know I'm was it i think the

00:33:55,440 --> 00:34:01,889
upper limit right now for gr 0 is I'm

00:33:58,739 --> 00:34:08,069
singing well depends on the set up but i

00:34:01,889 --> 00:34:11,159
think i was running about 15 gigs for

00:34:08,069 --> 00:34:11,750
single supplier no it was 12 for single

00:34:11,159 --> 00:34:14,389
cpu if

00:34:11,750 --> 00:34:17,120
turned off all that like turbo mode and

00:34:14,389 --> 00:34:19,970
all of that stuff so that was also in a

00:34:17,120 --> 00:34:21,080
fairly low clock so but yeah that's one

00:34:19,970 --> 00:34:22,280
thing is we starting to these hundred

00:34:21,080 --> 00:34:23,810
gig parts it's going to be probably

00:34:22,280 --> 00:34:26,149
going to be a resurgence of LRO I'd

00:34:23,810 --> 00:34:28,520
imagine so some extent yeah we're

00:34:26,149 --> 00:34:29,629
probably going to need it but we're

00:34:28,520 --> 00:34:31,700
willing to go through and strongly

00:34:29,629 --> 00:34:34,070
define at this point exactly what fields

00:34:31,700 --> 00:34:36,950
need to match there are four it all come

00:34:34,070 --> 00:34:41,149
together on that so on Mannix fatigue II

00:34:36,950 --> 00:34:44,000
we reach 34 beat you with one call with

00:34:41,149 --> 00:34:47,480
tunnels no justice to your room yeah

00:34:44,000 --> 00:34:49,879
just hero without tell us yeah but we

00:34:47,480 --> 00:34:52,340
are the chances i wrote is it it's not a

00:34:49,879 --> 00:34:57,080
big deal though Giroux unique is your

00:34:52,340 --> 00:34:58,910
go-to to the leather goods people yeah

00:34:57,080 --> 00:35:00,980
well have to take a look at the code

00:34:58,910 --> 00:35:04,370
again but yeah so when i was testing out

00:35:00,980 --> 00:35:06,830
i was maxing out at about 12 so but as I

00:35:04,370 --> 00:35:08,960
said turn off all the turbo mode and all

00:35:06,830 --> 00:35:10,880
that so his base clock and then on top

00:35:08,960 --> 00:35:11,990
of it it's like a my systems when those

00:35:10,880 --> 00:35:13,880
ones where it's I've got like eighty

00:35:11,990 --> 00:35:17,410
eight cores so the clocks aren't running

00:35:13,880 --> 00:35:22,670
all that fast in the first place so

00:35:17,410 --> 00:35:24,700
there are 88 threads anyway so any other

00:35:22,670 --> 00:35:24,700
questions

00:35:31,400 --> 00:35:35,490
the pastors from like virtual machines

00:35:34,020 --> 00:35:37,290
so that those are all handled properly

00:35:35,490 --> 00:35:39,150
so inside the vm they can have the right

00:35:37,290 --> 00:35:41,340
settings so that the when the packets

00:35:39,150 --> 00:35:42,870
get encapsulated or just bridged they

00:35:41,340 --> 00:35:47,130
end up being just check some in the

00:35:42,870 --> 00:35:49,260
hardware without having issues so you're

00:35:47,130 --> 00:35:51,690
talking about like going from tap

00:35:49,260 --> 00:35:54,330
interface down and all that is well the

00:35:51,690 --> 00:35:55,620
GSF partial doesn't actually run on the

00:35:54,330 --> 00:35:59,240
tap interface itself is really just

00:35:55,620 --> 00:36:02,480
passing that as a TSO so what happens is

00:35:59,240 --> 00:36:05,370
all this basic eterna remember does

00:36:02,480 --> 00:36:08,340
shoot this top I don't remember off top

00:36:05,370 --> 00:36:10,610
of my head of tap supports the be host

00:36:08,340 --> 00:36:14,550
supports passing tunneled frames or not

00:36:10,610 --> 00:36:17,220
don't think it does as far as no I think

00:36:14,550 --> 00:36:19,440
it only does TSO so i'll come down

00:36:17,220 --> 00:36:21,270
usually gets into like open V switch or

00:36:19,440 --> 00:36:23,190
a bridge gets encapsulating to be

00:36:21,270 --> 00:36:24,570
excellent at that point so basically all

00:36:23,190 --> 00:36:26,880
the stuff I was calling out here

00:36:24,570 --> 00:36:29,580
normally happens just before we hand it

00:36:26,880 --> 00:36:31,560
off to hardware and so the gsl partial

00:36:29,580 --> 00:36:34,740
kicking in the geocell layer at the Nick

00:36:31,560 --> 00:36:35,910
itself so up in the software devices we

00:36:34,740 --> 00:36:37,140
shouldn't need to actually do this it's

00:36:35,910 --> 00:36:38,580
just when we get down into the actual

00:36:37,140 --> 00:36:40,350
transition to hardware that then we have

00:36:38,580 --> 00:36:44,220
to go ahead and segment it before we

00:36:40,350 --> 00:36:46,260
actually put it on the wire so as far as

00:36:44,220 --> 00:36:48,890
i know i don't think any play another

00:36:46,260 --> 00:36:50,910
good i or any of that are supporting

00:36:48,890 --> 00:36:52,530
geocell partials right now it's only

00:36:50,910 --> 00:36:55,760
hardware devices i'm enabling that

00:36:52,530 --> 00:36:55,760
functionality on so

00:37:04,400 --> 00:37:11,930
yeah I think how much time thank you a

00:37:09,500 --> 00:37:13,910
question about who's doing all this ipv6

00:37:11,930 --> 00:37:15,289
to vie for translation I wasn't aware

00:37:13,910 --> 00:37:16,849
forgive my ignorance if I wasn't aware

00:37:15,289 --> 00:37:19,760
if there was nastics for code that it

00:37:16,849 --> 00:37:23,059
made it into the kernel or not I think

00:37:19,760 --> 00:37:25,640
it's like cell phone providers etc doing

00:37:23,059 --> 00:37:26,900
it I believe I'm trying to remember now

00:37:25,640 --> 00:37:30,049
accepts the thing this is an email

00:37:26,900 --> 00:37:32,240
thread from like six to nine months ago

00:37:30,049 --> 00:37:34,400
so can't remember off the top of my head

00:37:32,240 --> 00:37:35,809
if you go searching though somewhere in

00:37:34,400 --> 00:37:39,829
the thread somebody brought up the whole

00:37:35,809 --> 00:37:42,049
ipv6 to ipv4 translation having the ipid

00:37:39,829 --> 00:37:43,640
peeled zero that and there's rfcs that

00:37:42,049 --> 00:37:47,559
call out how to translate between the

00:37:43,640 --> 00:37:47,559
two they specified set the value to zero

00:38:01,340 --> 00:38:04,609

YouTube URL: https://www.youtube.com/watch?v=u2YqKXdvAMc


