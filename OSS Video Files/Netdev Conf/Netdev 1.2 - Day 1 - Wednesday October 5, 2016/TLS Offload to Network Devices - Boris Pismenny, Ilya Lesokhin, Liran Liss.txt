Title: TLS Offload to Network Devices - Boris Pismenny, Ilya Lesokhin, Liran Liss
Publication date: 2016-10-06
Playlist: Netdev 1.2 - Day 1 - Wednesday October 5, 2016
Description: 
	http://netdevconf.org/1.2/session.html?boris-pismenny
Captions: 
	00:00:09,540 --> 00:00:12,830
five minutes

00:00:31,180 --> 00:00:37,129
hi so this talk is about

00:00:34,489 --> 00:00:40,010
TLS crypto offload to network devices

00:00:37,129 --> 00:00:43,010
and during this talk I will focus on the

00:00:40,010 --> 00:00:44,829
transmit side of crypto fraud we have

00:00:43,010 --> 00:00:47,930
some work on the receive side however

00:00:44,829 --> 00:00:50,629
due to the limited time frame I will not

00:00:47,930 --> 00:00:53,899
discuss it during this session we can

00:00:50,629 --> 00:00:56,059
talk about it offline later and so I

00:00:53,899 --> 00:00:59,479
will start with motivating this work

00:00:56,059 --> 00:01:03,140
crypto offload to network devices then

00:00:59,479 --> 00:01:05,479
we'll review some existing models for

00:01:03,140 --> 00:01:09,170
crypto fraud and finally we will discuss

00:01:05,479 --> 00:01:13,150
the proposed solution namely also to the

00:01:09,170 --> 00:01:16,579
network device and propose an API and

00:01:13,150 --> 00:01:19,159
having discussion on the challenges and

00:01:16,579 --> 00:01:22,490
the problems that we encountered

00:01:19,159 --> 00:01:27,290
implementing a proof of concept for this

00:01:22,490 --> 00:01:30,350
model so let's begin and so for

00:01:27,290 --> 00:01:33,860
motivation we've made a simple test

00:01:30,350 --> 00:01:39,530
where we compared to TLS Cypress suits

00:01:33,860 --> 00:01:41,630
where the first was a s 128 GCM versus

00:01:39,530 --> 00:01:45,560
the null cipher suit where the null

00:01:41,630 --> 00:01:51,020
cipher suit implements the TLS record

00:01:45,560 --> 00:01:53,840
protocol and it doesn't do the

00:01:51,020 --> 00:01:58,909
encryption so it's sending plaintext but

00:01:53,840 --> 00:02:01,940
it's still doing the SSL protocol so in

00:01:58,909 --> 00:02:06,619
the table we have on the Left column the

00:02:01,940 --> 00:02:08,810
Cypress or GCM and now Cypress hood on

00:02:06,619 --> 00:02:11,080
the middle column we have CPU time split

00:02:08,810 --> 00:02:14,510
to user time system time and a

00:02:11,080 --> 00:02:16,519
percentage use percentage and on the

00:02:14,510 --> 00:02:19,310
right column we have bandwidth so we see

00:02:16,519 --> 00:02:21,439
that with AES GCM we get only 60

00:02:19,310 --> 00:02:25,069
gigabytes and with the null surface soup

00:02:21,439 --> 00:02:28,670
we get about 10 and the encryption which

00:02:25,069 --> 00:02:32,870
is done using a SNA in this case and

00:02:28,670 --> 00:02:34,999
perform the user space takes 0.5 4

00:02:32,870 --> 00:02:37,990
seconds we're using the null cipher

00:02:34,999 --> 00:02:41,390
suits in text only 0.8

00:02:37,990 --> 00:02:44,150
so those numbers are somewhat different

00:02:41,390 --> 00:02:48,500
from what we presented our guests will

00:02:44,150 --> 00:02:50,440
discuss those offline and see why the

00:02:48,500 --> 00:02:54,560
way why do we see those differences

00:02:50,440 --> 00:02:56,030
however the amount of processing that is

00:02:54,560 --> 00:02:59,500
required for encryption is still

00:02:56,030 --> 00:03:03,500
significant so holding the lease is

00:02:59,500 --> 00:03:07,880
still useful so moving on to existing

00:03:03,500 --> 00:03:11,740
solutions the first solution is TCP

00:03:07,880 --> 00:03:11,740
offload engine that supports TLS

00:03:11,770 --> 00:03:17,060
disappear our search engine so generally

00:03:14,240 --> 00:03:19,250
not something that is going to be

00:03:17,060 --> 00:03:20,330
accepted in the linux kernel in the

00:03:19,250 --> 00:03:24,110
upcoming years

00:03:20,330 --> 00:03:26,660
so those solutions probably want to be

00:03:24,110 --> 00:03:31,010
upstream and there are many many reasons

00:03:26,660 --> 00:03:35,330
why those solutions are inferior to

00:03:31,010 --> 00:03:37,970
other solutions there are not as robust

00:03:35,330 --> 00:03:40,880
as the existing TCP stacks that are

00:03:37,970 --> 00:03:44,750
difficult to maintain and update and

00:03:40,880 --> 00:03:48,820
although they use the TCP stack in the

00:03:44,750 --> 00:03:52,700
Euro space has improved greatly while

00:03:48,820 --> 00:03:54,910
TCP offload engines failed to keep up

00:03:52,700 --> 00:03:57,410
with the user implementation of TCP

00:03:54,910 --> 00:03:59,840
although it lags behind on the

00:03:57,410 --> 00:04:03,050
congestion control and with transmission

00:03:59,840 --> 00:04:05,959
algorithms that are implemented in the

00:04:03,050 --> 00:04:08,450
user space stack so for those reasons

00:04:05,959 --> 00:04:11,959
and others those solutions aren't

00:04:08,450 --> 00:04:16,160
accepted moving on to another category

00:04:11,959 --> 00:04:18,859
of encryption allowed those memory to

00:04:16,160 --> 00:04:23,390
memory encryption of thought where the

00:04:18,859 --> 00:04:25,760
host prepares special descriptors for

00:04:23,390 --> 00:04:28,970
the data that needs to be encrypted and

00:04:25,760 --> 00:04:32,600
those descriptors are read by a crypto

00:04:28,970 --> 00:04:35,000
device and presumably a PCI card that

00:04:32,600 --> 00:04:36,680
encrypts the payload and then provides a

00:04:35,000 --> 00:04:40,150
completely interrupt that has been

00:04:36,680 --> 00:04:43,150
completed and has been encrypted and

00:04:40,150 --> 00:04:46,900
then the host can resume processing so

00:04:43,150 --> 00:04:49,150
this round trip over the PCI has

00:04:46,900 --> 00:04:51,370
additional latency and

00:04:49,150 --> 00:04:55,810
so consumes additional resources that

00:04:51,370 --> 00:04:59,130
might have been used otherwise so this

00:04:55,810 --> 00:05:03,130
is why this solution is inferior and

00:04:59,130 --> 00:05:05,110
moving on to our proposed solution where

00:05:03,130 --> 00:05:09,100
the encryption is moved into the network

00:05:05,110 --> 00:05:12,550
device and this solution the NIC holds

00:05:09,100 --> 00:05:15,190
the encryption state and it encrypts and

00:05:12,550 --> 00:05:19,300
decrypts packets in flight as they move

00:05:15,190 --> 00:05:22,630
on through the network device in this

00:05:19,300 --> 00:05:27,520
way the ciphertext is never held in the

00:05:22,630 --> 00:05:31,120
CPU memory so the CPU only sees

00:05:27,520 --> 00:05:35,080
plaintext data and the network always

00:05:31,120 --> 00:05:37,810
sees the encrypted data we have a single

00:05:35,080 --> 00:05:42,220
PCI round-trip unlike the memory to

00:05:37,810 --> 00:05:44,230
memory model and overall we reduced

00:05:42,220 --> 00:05:49,390
latency since the encryption isn't

00:05:44,230 --> 00:05:52,270
performed on the CPU host so before

00:05:49,390 --> 00:05:54,280
jumping to the software stack when using

00:05:52,270 --> 00:05:57,270
your load let's review it will review

00:05:54,280 --> 00:06:00,970
once again the TLS record protocol and

00:05:57,270 --> 00:06:02,860
specifically with the use case of K TLS

00:06:00,970 --> 00:06:05,770
presented in the previous presentation

00:06:02,860 --> 00:06:08,950
so the user space provides a big chunk

00:06:05,770 --> 00:06:12,430
of data which is fragmented to 16 K

00:06:08,950 --> 00:06:15,490
pieces by K TLS so here is a transition

00:06:12,430 --> 00:06:19,420
to the user space in kernel space those

00:06:15,490 --> 00:06:25,060
16 K chunks later encrypted and

00:06:19,420 --> 00:06:28,590
authenticated and in K TLS then the TLS

00:06:25,060 --> 00:06:32,110
record header is added and finally those

00:06:28,590 --> 00:06:34,810
data pieces are passed into the tip into

00:06:32,110 --> 00:06:37,810
the TCP stack where they're segmented to

00:06:34,810 --> 00:06:42,010
NSS chunk pieces and transmitted over

00:06:37,810 --> 00:06:48,190
the network so how is this modified when

00:06:42,010 --> 00:06:52,180
we add the crypto offload to to a camel

00:06:48,190 --> 00:06:56,010
so first of all our approach integrates

00:06:52,180 --> 00:06:59,810
with the catalyst so we added another

00:06:56,010 --> 00:07:03,260
socket option for assault and

00:06:59,810 --> 00:07:07,280
this is specified then all the crypto

00:07:03,260 --> 00:07:10,610
state is passed to the huddle and from

00:07:07,280 --> 00:07:14,240
that moment onward this say TLS

00:07:10,610 --> 00:07:17,360
connection is being floated so the user

00:07:14,240 --> 00:07:23,240
provides plain state plaintext data to K

00:07:17,360 --> 00:07:26,990
TLS and Katie LS prepares records so it

00:07:23,240 --> 00:07:29,570
adds the authentication tag from the

00:07:26,990 --> 00:07:32,419
previous slide and the TLS record header

00:07:29,570 --> 00:07:35,810
however the plaintext remains the same

00:07:32,419 --> 00:07:40,970
and those TOS records the plaintext

00:07:35,810 --> 00:07:43,729
records passed into the TCP stack where

00:07:40,970 --> 00:07:47,560
eventually they reach the NIC is TCP

00:07:43,729 --> 00:07:51,350
segments and those TCP segments will be

00:07:47,560 --> 00:07:56,120
encrypted by the network device once

00:07:51,350 --> 00:07:59,479
they leave the device so we support

00:07:56,120 --> 00:08:03,560
currently only as GM the issues who is

00:07:59,479 --> 00:08:06,620
supporting a CBC pls 1.3 those ciphers

00:08:03,560 --> 00:08:10,539
will be deprecated and only surfaced as

00:08:06,620 --> 00:08:12,680
a as GCM and ChaCha poly which are

00:08:10,539 --> 00:08:15,530
supported which are supported by this

00:08:12,680 --> 00:08:18,190
device will be supported in the future

00:08:15,530 --> 00:08:21,400
so we don't see a problem with it

00:08:18,190 --> 00:08:25,250
overall the software stack remains

00:08:21,400 --> 00:08:27,620
unchanged maybe even simplified since

00:08:25,250 --> 00:08:30,979
kts doesn't needs to deal with the

00:08:27,620 --> 00:08:32,810
encryption at all and the tcp/ip stack

00:08:30,979 --> 00:08:36,229
isn't changed the congestion control

00:08:32,810 --> 00:08:39,080
memory management all remain the same so

00:08:36,229 --> 00:08:41,630
we keep the benefits of having all the

00:08:39,080 --> 00:08:44,959
control and software when the device is

00:08:41,630 --> 00:08:48,700
limited to a set of encryption

00:08:44,959 --> 00:08:48,700
operations in the crypts no Corrections

00:08:50,790 --> 00:08:57,090
so moving on to a comparison of TLS

00:08:55,800 --> 00:09:01,770
crypto float

00:08:57,090 --> 00:09:03,960
compared to other encryption protocols

00:09:01,770 --> 00:09:07,560
that are somewhat different

00:09:03,960 --> 00:09:09,360
for example IB second DTLS our packet

00:09:07,560 --> 00:09:11,900
based encryption protocols meaning that

00:09:09,360 --> 00:09:15,110
each packet could be encrypted

00:09:11,900 --> 00:09:20,940
independently of any other pocket

00:09:15,110 --> 00:09:25,190
however with TLS it is different where

00:09:20,940 --> 00:09:29,190
until us each record is encrypted

00:09:25,190 --> 00:09:32,700
individually and as you can see on the

00:09:29,190 --> 00:09:35,460
right side we have two TLS records and

00:09:32,700 --> 00:09:40,590
which was split into three TCP packets

00:09:35,460 --> 00:09:42,360
and in order to increase pocket veto we

00:09:40,590 --> 00:09:46,160
need to have the encryption state at the

00:09:42,360 --> 00:09:49,080
end of packet p1 so there's a dependency

00:09:46,160 --> 00:09:50,940
so when we need to encrypt packet be -

00:09:49,080 --> 00:09:54,050
we need some state from a previous

00:09:50,940 --> 00:09:58,680
packet so how do we need to maintain

00:09:54,050 --> 00:10:05,970
intermediate record state for each TLS

00:09:58,680 --> 00:10:09,330
record so moving on to how we

00:10:05,970 --> 00:10:13,560
implemented it in the driver so the two

00:10:09,330 --> 00:10:16,680
paths a fast path and a slow path for

00:10:13,560 --> 00:10:19,560
the fast path when we do the following

00:10:16,680 --> 00:10:23,820
we first check that the socket is being

00:10:19,560 --> 00:10:26,730
floated rather than a new member of the

00:10:23,820 --> 00:10:28,140
socket sk offloaded if the socket is a

00:10:26,730 --> 00:10:30,810
floating proceeded to the following

00:10:28,140 --> 00:10:34,770
check let's check if the TCP sequence

00:10:30,810 --> 00:10:37,110
number is matching to the expected TCP

00:10:34,770 --> 00:10:39,840
sequence number from the moment the

00:10:37,110 --> 00:10:43,460
first load we are tracking the expected

00:10:39,840 --> 00:10:48,570
TCP sequence number in the driver so we

00:10:43,460 --> 00:10:51,150
in order to encrypt a packet if the if

00:10:48,570 --> 00:10:53,610
the packet being sent is the following

00:10:51,150 --> 00:10:56,880
packet is the in sequence packet then

00:10:53,610 --> 00:10:59,760
this packet can be encrypted without any

00:10:56,880 --> 00:11:03,160
additional work and we get all the

00:10:59,760 --> 00:11:07,120
benefits for flowed however

00:11:03,160 --> 00:11:09,670
when the second check fails meaning that

00:11:07,120 --> 00:11:12,910
the TCP sequence number isn't the

00:11:09,670 --> 00:11:15,610
expected TCP sequence number so we need

00:11:12,910 --> 00:11:19,480
to do a little bit more work we call

00:11:15,610 --> 00:11:22,000
this flow missing flow where we need to

00:11:19,480 --> 00:11:26,040
fix the TLS context in Hardware so how

00:11:22,000 --> 00:11:31,090
do I maintain a run in TLS context for a

00:11:26,040 --> 00:11:34,060
TLS socket and if for example packet p5

00:11:31,090 --> 00:11:37,720
is being retransmitted for some reason

00:11:34,060 --> 00:11:40,690
then in order to offer the encryption of

00:11:37,720 --> 00:11:44,380
this packet we need to fix the hardware

00:11:40,690 --> 00:11:46,540
TLS context so the way we do it is that

00:11:44,380 --> 00:11:50,770
we need to provide the data of TLS

00:11:46,540 --> 00:11:54,010
record number two in order to encrypt

00:11:50,770 --> 00:12:00,040
pocket p5 so this includes packet before

00:11:54,010 --> 00:12:01,690
and a part of packet III so this is the

00:12:00,040 --> 00:12:06,700
slow path and we need access to this

00:12:01,690 --> 00:12:08,530
data of TLS record number two so the

00:12:06,700 --> 00:12:11,320
requirements for this switching is that

00:12:08,530 --> 00:12:15,220
software needs to keep track of TLS

00:12:11,320 --> 00:12:18,670
records and to provide a mapping from an

00:12:15,220 --> 00:12:19,390
skb to the first u.s. record that is

00:12:18,670 --> 00:12:24,610
part of that

00:12:19,390 --> 00:12:26,890
SKB finally we need to prevent the

00:12:24,610 --> 00:12:29,890
release of data from TLS record

00:12:26,890 --> 00:12:32,460
- even though packets be free and before

00:12:29,890 --> 00:12:35,320
might have been acknowledged previously

00:12:32,460 --> 00:12:37,480
they cannot be released from memory

00:12:35,320 --> 00:12:40,000
since packet p5 might be retransmitted

00:12:37,480 --> 00:12:44,440
and we will need to access this data

00:12:40,000 --> 00:12:48,120
later so schematically when we are doing

00:12:44,440 --> 00:12:53,080
a recent flow for skb number 2 here

00:12:48,120 --> 00:12:56,800
which consists of fully skb fragments

00:12:53,080 --> 00:12:59,050
were the first it has some piece of data

00:12:56,800 --> 00:13:01,000
from TLS record 1 and some piece of

00:12:59,050 --> 00:13:03,960
later from TLS record 2 and the other

00:13:01,000 --> 00:13:07,000
two are coming from TLS record number 2

00:13:03,960 --> 00:13:09,060
then the recent flow will need to have

00:13:07,000 --> 00:13:12,190
access to TLS record number 1 and

00:13:09,060 --> 00:13:15,910
provide data that is pointer to sk b1

00:13:12,190 --> 00:13:16,640
which is from TLS record 1 and this data

00:13:15,910 --> 00:13:18,890
must know

00:13:16,640 --> 00:13:22,160
be released from memory even though skb

00:13:18,890 --> 00:13:26,840
one might have been freed or released

00:13:22,160 --> 00:13:29,360
previously so our proposed solution is

00:13:26,840 --> 00:13:31,730
to divide the implementation in the

00:13:29,360 --> 00:13:35,030
following manner between K TLS TCP and

00:13:31,730 --> 00:13:38,200
the driver so Katie Ellis holds

00:13:35,030 --> 00:13:42,770
reference for the TLS record a catalyst

00:13:38,200 --> 00:13:46,490
catalyst provides those pages to the TCP

00:13:42,770 --> 00:13:48,260
stack so it builds those pages initially

00:13:46,490 --> 00:13:52,550
and it takes an additional reference to

00:13:48,260 --> 00:13:55,670
those pages and this reference is used

00:13:52,550 --> 00:13:58,270
in a mapping between TCP sequence

00:13:55,670 --> 00:14:01,340
numbers and TLS records

00:13:58,270 --> 00:14:05,600
well this mapping will be later used by

00:14:01,340 --> 00:14:09,560
the driver the mapping is exposed to the

00:14:05,600 --> 00:14:13,160
driver so it can access it from TCP we

00:14:09,560 --> 00:14:18,350
require an additional callback used by K

00:14:13,160 --> 00:14:20,060
TLS this callback is used to release

00:14:18,350 --> 00:14:23,600
acknowledge TLS records

00:14:20,060 --> 00:14:28,010
so when TCP is releasing memory that has

00:14:23,600 --> 00:14:30,650
been acknowledged it goes through an

00:14:28,010 --> 00:14:32,350
additional call to Katie Ellis where we

00:14:30,650 --> 00:14:35,750
check if the record has been

00:14:32,350 --> 00:14:38,450
acknowledged completely and then we can

00:14:35,750 --> 00:14:41,150
release the memory from this record and

00:14:38,450 --> 00:14:44,930
a final the driver will check if

00:14:41,150 --> 00:14:45,710
everything is required and if it is it

00:14:44,930 --> 00:14:50,420
will query

00:14:45,710 --> 00:14:58,280
k TLS to get the required data for the

00:14:50,420 --> 00:15:03,080
recent flow so this slide so shows some

00:14:58,280 --> 00:15:08,290
preliminary performance results which we

00:15:03,080 --> 00:15:12,320
got only just now using this pod method

00:15:08,290 --> 00:15:15,950
currently we support only small records

00:15:12,320 --> 00:15:19,100
so this is very initial however with

00:15:15,950 --> 00:15:23,000
time we will have more advanced results

00:15:19,100 --> 00:15:25,280
so in the table we see a comparison

00:15:23,000 --> 00:15:27,420
between TCP green TLS which is a user

00:15:25,280 --> 00:15:30,580
space implementation of Thiele

00:15:27,420 --> 00:15:32,950
colonel TLS and somewhat old version

00:15:30,580 --> 00:15:36,370
from three months ago and katie ellis

00:15:32,950 --> 00:15:38,980
with a flood support and roadshow

00:15:36,370 --> 00:15:41,770
through port and Scipio so we tcp with

00:15:38,980 --> 00:15:45,070
the from ten to twenty three jacob it's

00:15:41,770 --> 00:15:46,810
for a second and those whole

00:15:45,070 --> 00:15:50,530
measurements are from the transmit side

00:15:46,810 --> 00:15:53,770
only so the cpu is 100% in all cases

00:15:50,530 --> 00:15:58,500
with new TLS with the five gigabit with

00:15:53,770 --> 00:16:02,950
catalyst for and we offload we see eight

00:15:58,500 --> 00:16:07,390
again those the results for areas GCM

00:16:02,950 --> 00:16:11,230
with snow TLS records with larger TLS

00:16:07,390 --> 00:16:13,780
reports of 16k we might see some

00:16:11,230 --> 00:16:16,000
somewhat different results but in any

00:16:13,780 --> 00:16:21,850
case the offload of encryption you're

00:16:16,000 --> 00:16:24,280
still going to be significant so some

00:16:21,850 --> 00:16:26,890
discussion items regarding the

00:16:24,280 --> 00:16:30,040
implementation the first challenge we

00:16:26,890 --> 00:16:33,820
have and we didn't know how to cope with

00:16:30,040 --> 00:16:37,839
is routing changes all packets being

00:16:33,820 --> 00:16:40,150
offloaded which plaintext must not go to

00:16:37,839 --> 00:16:43,750
a different device so if the routing

00:16:40,150 --> 00:16:47,920
decision changes during transmission we

00:16:43,750 --> 00:16:51,280
need to either have some what some way

00:16:47,920 --> 00:16:54,580
to do a software fallback or a manner to

00:16:51,280 --> 00:16:57,250
prevent this routing change for those

00:16:54,580 --> 00:17:00,220
packets so this is the first challenge

00:16:57,250 --> 00:17:03,010
the second challenge is whether we need

00:17:00,220 --> 00:17:06,069
to add a new protocol family FK TLS

00:17:03,010 --> 00:17:08,110
offload since in the current

00:17:06,069 --> 00:17:14,319
implementation the way we did it is

00:17:08,110 --> 00:17:17,680
simply add an if to the kt less sent

00:17:14,319 --> 00:17:19,150
message and send page calls where we

00:17:17,680 --> 00:17:20,770
check if it's of all that we call one

00:17:19,150 --> 00:17:23,260
function otherwise we call different

00:17:20,770 --> 00:17:26,230
function might have been simple to just

00:17:23,260 --> 00:17:31,960
have another socket family and that's it

00:17:26,230 --> 00:17:34,900
and the third discussion item is the use

00:17:31,960 --> 00:17:38,080
of the original TCP socket which they've

00:17:34,900 --> 00:17:41,650
mentioned in his presentation as well

00:17:38,080 --> 00:17:45,760
the socket is being destroyed if there

00:17:41,650 --> 00:17:50,020
is some handshake message or a left

00:17:45,760 --> 00:17:52,000
message in catalyst and a well for fold

00:17:50,020 --> 00:17:56,200
this also presents a problem if someone

00:17:52,000 --> 00:17:58,690
is using the original TCP socket while

00:17:56,200 --> 00:18:00,730
the socket is being offloaded we expect

00:17:58,690 --> 00:18:03,520
to encrypt all the payload that's going

00:18:00,730 --> 00:18:06,130
out of this socket and if the original

00:18:03,520 --> 00:18:08,590
TCP socket is used then the user is

00:18:06,130 --> 00:18:13,660
supposed to encrypt it and that presents

00:18:08,590 --> 00:18:15,070
a challenge we could overcome this in

00:18:13,660 --> 00:18:17,440
many different ways

00:18:15,070 --> 00:18:20,920
we just need to decide what is the best

00:18:17,440 --> 00:18:23,410
since even protocol messages which

00:18:20,920 --> 00:18:25,570
aren't application data they are still

00:18:23,410 --> 00:18:27,940
being encrypted and the benefits of

00:18:25,570 --> 00:18:31,750
encryption offload will apply to these

00:18:27,940 --> 00:18:34,480
case as well the first item is memory

00:18:31,750 --> 00:18:36,850
accounting since we need to do the

00:18:34,480 --> 00:18:40,360
accounting of the TLS records which are

00:18:36,850 --> 00:18:43,300
maintained in catalyst how would we

00:18:40,360 --> 00:18:46,390
approach this problem and the last item

00:18:43,300 --> 00:18:49,570
I have some slides for it zero copy sent

00:18:46,390 --> 00:18:51,550
file will be possible using crypto so

00:18:49,570 --> 00:18:54,730
that's what I've tried to mention

00:18:51,550 --> 00:18:56,860
earlier doing Dave stock when we do send

00:18:54,730 --> 00:18:58,960
file and we use encryption then the

00:18:56,860 --> 00:19:01,630
encryption you can think of it as a copy

00:18:58,960 --> 00:19:04,420
since you can't encrypt the data that's

00:19:01,630 --> 00:19:06,190
in the page cache you can think of it as

00:19:04,420 --> 00:19:09,520
encryption and not as a copy but it's

00:19:06,190 --> 00:19:11,650
somewhat similar so we we could get a

00:19:09,520 --> 00:19:14,440
zero copy send file when we use

00:19:11,650 --> 00:19:17,680
encryption offload where we use the

00:19:14,440 --> 00:19:19,870
original data from the page cache that

00:19:17,680 --> 00:19:24,520
is being sent in the similar manner to

00:19:19,870 --> 00:19:27,400
what we do with central using TCP and I

00:19:24,520 --> 00:19:29,710
have some slides that show a particular

00:19:27,400 --> 00:19:32,410
issue regarding this problem so I'll go

00:19:29,710 --> 00:19:35,200
this side and then we'll come back to

00:19:32,410 --> 00:19:39,340
the discussion items so when we do is

00:19:35,200 --> 00:19:42,100
you a copy sent file with crypto offload

00:19:39,340 --> 00:19:43,900
and Katie Ellis adds the TLS header used

00:19:42,100 --> 00:19:45,820
data from the page cache and that's a

00:19:43,900 --> 00:19:49,050
dummy authentication tab that is going

00:19:45,820 --> 00:19:51,390
to be filled by hardware and

00:19:49,050 --> 00:19:53,580
when we send the payload then it is

00:19:51,390 --> 00:19:56,310
encrypted by the network device however

00:19:53,580 --> 00:19:59,520
it is possible that some packet has been

00:19:56,310 --> 00:20:02,820
dropped while others have been received

00:19:59,520 --> 00:20:06,120
by the other side and once we have a

00:20:02,820 --> 00:20:09,480
retransmission then with Hardware

00:20:06,120 --> 00:20:11,880
offload we will do everything and the

00:20:09,480 --> 00:20:12,990
authentication tag will be calculated

00:20:11,880 --> 00:20:15,960
for the new payload

00:20:12,990 --> 00:20:19,080
however the receiving side might have

00:20:15,960 --> 00:20:20,940
received some of the old payload so the

00:20:19,080 --> 00:20:25,260
authentication type check will sell

00:20:20,940 --> 00:20:29,310
because we will have like mixed payload

00:20:25,260 --> 00:20:30,660
on the receiving side and while if we

00:20:29,310 --> 00:20:32,280
didn't your script or thought we

00:20:30,660 --> 00:20:34,440
wouldn't have this problem because all

00:20:32,280 --> 00:20:38,280
the data has been encrypted you can

00:20:34,440 --> 00:20:40,680
think of it as a problem or or a benefit

00:20:38,280 --> 00:20:44,400
because the receiving side doesn't

00:20:40,680 --> 00:20:47,670
receive data that is both stale and new

00:20:44,400 --> 00:20:51,510
it identifies this problem and has an

00:20:47,670 --> 00:20:53,250
authentication tax failure however it is

00:20:51,510 --> 00:20:55,860
still a peculiar interesting issue that

00:20:53,250 --> 00:20:58,410
occurs only with steals offload and

00:20:55,860 --> 00:21:01,230
another benefit of using crypto fraud is

00:20:58,410 --> 00:21:04,890
obviously you don't see ciphertext when

00:21:01,230 --> 00:21:06,420
you're using TCP dump so you could see

00:21:04,890 --> 00:21:10,800
the plaintext data and perform

00:21:06,420 --> 00:21:12,570
manipulations of plaintext data so

00:21:10,800 --> 00:21:16,220
that's it thank you now return to the

00:21:12,570 --> 00:21:16,220
discussion sites for any questions

00:21:18,970 --> 00:21:21,870
Mike

00:21:34,600 --> 00:21:41,390
is they offload actually work on the

00:21:37,640 --> 00:21:46,100
virtualized environment as well well we

00:21:41,390 --> 00:21:48,530
haven't considered environments like SRV

00:21:46,100 --> 00:21:50,720
would this use case I believe it is

00:21:48,530 --> 00:21:53,090
completely possible since there are no

00:21:50,720 --> 00:21:55,220
special challenges with providing the

00:21:53,090 --> 00:21:58,400
crypto context however we didn't

00:21:55,220 --> 00:22:04,040
consider it thoroughly with the resource

00:21:58,400 --> 00:22:06,410
management of ritual machines etc okay

00:22:04,040 --> 00:22:08,630
what about like in a darker environment

00:22:06,410 --> 00:22:10,700
and stuff like that and is there any

00:22:08,630 --> 00:22:13,040
security concern I mean if we actually

00:22:10,700 --> 00:22:15,350
try to offload to the hardware no I

00:22:13,040 --> 00:22:17,090
don't think it will be any problem it's

00:22:15,350 --> 00:22:18,950
just another service provided by the

00:22:17,090 --> 00:22:21,500
kernel the kernel of the virtual machine

00:22:18,950 --> 00:22:25,630
could do this preparation for offload

00:22:21,500 --> 00:22:25,630
and the device could support it

00:22:38,590 --> 00:22:44,180
so you mentioned in the slide here about

00:22:41,540 --> 00:22:47,720
a new protocol family please avoid this

00:22:44,180 --> 00:22:50,060
because that's the last thing we want to

00:22:47,720 --> 00:22:52,220
do if we're going to add a new facility

00:22:50,060 --> 00:22:53,660
that provides TLS over TCP sockets it

00:22:52,220 --> 00:22:55,100
has to be consistent regardless of

00:22:53,660 --> 00:22:56,660
whether there's a hardware awful lot

00:22:55,100 --> 00:22:59,990
behind it or not it should be completely

00:22:56,660 --> 00:23:02,570
invisible to the application because

00:22:59,990 --> 00:23:04,370
it's one thing to get all applications

00:23:02,570 --> 00:23:06,740
and libraries out there to add support

00:23:04,370 --> 00:23:09,230
for afk TLS it's it's going to be

00:23:06,740 --> 00:23:12,230
impossible and a serious burden to add

00:23:09,230 --> 00:23:13,810
to new mechanisms for supporting this I

00:23:12,230 --> 00:23:19,070
don't think it's reasonable to have to

00:23:13,810 --> 00:23:24,320
okay as for the zero copy son file

00:23:19,070 --> 00:23:26,450
situation I my personal opinion is that

00:23:24,320 --> 00:23:28,490
it's it's really shouldn't support it

00:23:26,450 --> 00:23:29,990
because obviously the data can change

00:23:28,490 --> 00:23:31,490
from underneath the application we don't

00:23:29,990 --> 00:23:32,960
want to lock pages down that's the whole

00:23:31,490 --> 00:23:34,610
reason we do sun falls because it

00:23:32,960 --> 00:23:36,260
doesn't synchronize with the page cache

00:23:34,610 --> 00:23:39,470
at all just no locking involves no

00:23:36,260 --> 00:23:40,910
synchronization and as you showed it's

00:23:39,470 --> 00:23:42,830
we would need to have the entire

00:23:40,910 --> 00:23:45,020
security context and we transmit the

00:23:42,830 --> 00:23:48,620
older packets to fix this up if the

00:23:45,020 --> 00:23:50,840
content changes underneath you could

00:23:48,620 --> 00:23:52,400
work around this is to copy and you're

00:23:50,840 --> 00:23:55,040
trying to avoid copy in the first place

00:23:52,400 --> 00:23:56,960
I think it's not desirable to have stale

00:23:55,040 --> 00:23:59,560
data in the receiver side I totally

00:23:56,960 --> 00:24:01,640
agree with you so I think the model

00:23:59,560 --> 00:24:03,800
you're gonna have to do a read and a

00:24:01,640 --> 00:24:05,990
write to do crypto offload over this

00:24:03,800 --> 00:24:08,720
needs to be socket and that's why I talk

00:24:05,990 --> 00:24:11,090
a lot about the doing in the crypto

00:24:08,720 --> 00:24:12,770
layer assembler versions that do copies

00:24:11,090 --> 00:24:14,240
directly in another user space because

00:24:12,770 --> 00:24:16,010
for a commodity hardware that's going to

00:24:14,240 --> 00:24:18,770
be the fastest implementation possible

00:24:16,010 --> 00:24:20,390
in my personal opinion so I really don't

00:24:18,770 --> 00:24:21,860
see a solution for the zero copy Sun

00:24:20,390 --> 00:24:24,200
file a situation where the data can

00:24:21,860 --> 00:24:25,310
change underneath as it can so unless

00:24:24,200 --> 00:24:28,840
someone comes up with a brilliant idea

00:24:25,310 --> 00:24:28,840
we might have to punt on that for now

00:24:30,480 --> 00:24:35,580
can you go back in your thread you

00:24:32,369 --> 00:24:42,929
mentioned TCP of the exclaim something

00:24:35,580 --> 00:24:45,269
oh yeah so Kolkata lesson typically not

00:24:42,929 --> 00:24:53,609
XQ to really that prodigy theorist

00:24:45,269 --> 00:24:55,830
recalls what does it mean exactly so the

00:24:53,609 --> 00:24:58,320
problem we can have with this is that

00:24:55,830 --> 00:25:03,299
you can receive a malicious ACK the

00:24:58,320 --> 00:25:07,700
receiver can pretend the buffer was sent

00:25:03,299 --> 00:25:11,369
while it's still in unique transmit ring

00:25:07,700 --> 00:25:15,679
so the risk is you could actually free

00:25:11,369 --> 00:25:18,269
memory while it's still in use by the

00:25:15,679 --> 00:25:20,460
knick-knack packet can be sent in

00:25:18,269 --> 00:25:24,389
advance power by a malicious receiver

00:25:20,460 --> 00:25:27,179
pretending he actually good Beckett okay

00:25:24,389 --> 00:25:29,399
so you could have a race here on free

00:25:27,179 --> 00:25:31,980
something which is still used by the NIC

00:25:29,399 --> 00:25:36,179
and so you could crash the host the NIC

00:25:31,980 --> 00:25:37,679
is not saving the data it's not it

00:25:36,179 --> 00:25:40,230
doesn't have any additional reference

00:25:37,679 --> 00:25:48,330
beyond what exists today so at what

00:25:40,230 --> 00:25:51,239
point we use this extra data k TL s we

00:25:48,330 --> 00:25:53,609
need to build the tailless records it

00:25:51,239 --> 00:25:58,739
takes an additional reference on the

00:25:53,609 --> 00:26:01,940
data that it has constructed so once the

00:25:58,739 --> 00:26:06,690
data is passed into TCP when TCP

00:26:01,940 --> 00:26:10,649
decreases the reference count for the SK

00:26:06,690 --> 00:26:12,899
be Fred the data is not free yet because

00:26:10,649 --> 00:26:15,869
Katie Ellis holds a reference for this

00:26:12,899 --> 00:26:19,350
data and only when when this function is

00:26:15,869 --> 00:26:21,149
called for Katie OS it checks if the TLS

00:26:19,350 --> 00:26:25,970
record has been fully acknowledged and

00:26:21,149 --> 00:26:25,970
then the TLS record is freedom

00:26:26,270 --> 00:26:33,830
he frees the sharing info which frees

00:26:29,420 --> 00:26:37,220
the reference - so I was going to work

00:26:33,830 --> 00:26:41,570
with the GSO being disabled is about

00:26:37,220 --> 00:26:44,440
whatever completely understand why do

00:26:41,570 --> 00:26:49,790
you need to store that novice KB okay so

00:26:44,440 --> 00:26:52,040
the problem when you need to rethink the

00:26:49,790 --> 00:26:55,130
state of encryption for example here

00:26:52,040 --> 00:26:57,500
when you send skb number two and the

00:26:55,130 --> 00:26:59,900
hardware doesn't have the state to

00:26:57,500 --> 00:27:04,910
encrypt it it needs to get this state

00:26:59,900 --> 00:27:08,090
and this state is present at record 1 in

00:27:04,910 --> 00:27:10,880
the data of record 1 so we keep record

00:27:08,090 --> 00:27:13,880
one in memory until skb number 2 is

00:27:10,880 --> 00:27:15,620
acknowledged by disappear so I'm telling

00:27:13,880 --> 00:27:19,280
you the escapee can be acknowledged

00:27:15,620 --> 00:27:22,580
while all this is still in flight so you

00:27:19,280 --> 00:27:24,910
need something else should be

00:27:22,580 --> 00:27:27,559
automatically freed when the scatino

00:27:24,910 --> 00:27:45,020
adding some hoopty neurotics disappear

00:27:27,559 --> 00:27:46,700
whatever its it seems to me so just to

00:27:45,020 --> 00:27:49,280
be clear so you're talking about is

00:27:46,700 --> 00:27:51,950
you're having to maintain so for example

00:27:49,280 --> 00:27:54,320
your TLS record 1 is shown as occupying

00:27:51,950 --> 00:27:58,100
essentially three pages in this example

00:27:54,320 --> 00:27:59,240
3 scatter got other elements yes well

00:27:58,100 --> 00:28:01,580
you're having to do is make an extra

00:27:59,240 --> 00:28:04,070
call to free record one once you've

00:28:01,580 --> 00:28:06,410
transmitted the third page in that

00:28:04,070 --> 00:28:08,960
sequence right once if he's acknowledged

00:28:06,410 --> 00:28:10,820
right so see he said he is having to

00:28:08,960 --> 00:28:13,520
free something extra above and beyond

00:28:10,820 --> 00:28:16,250
but the pages should stay as long as SK

00:28:13,520 --> 00:28:17,900
b1 is in there so he's holding two

00:28:16,250 --> 00:28:20,320
counts on each of those pages is what

00:28:17,900 --> 00:28:20,320
he's doing

00:28:23,350 --> 00:28:27,380
well no the he's saying the K TLS has to

00:28:26,120 --> 00:28:30,020
free record one

00:28:27,380 --> 00:28:32,450
once he's transmitted the third scatter

00:28:30,020 --> 00:28:36,049
gather element in there because then

00:28:32,450 --> 00:28:38,000
he's fully transmitted record one and he

00:28:36,049 --> 00:28:40,100
no longer needs the data from it they

00:28:38,000 --> 00:28:43,010
can then move on to record - I thought

00:28:40,100 --> 00:28:44,630
that the idea is that all these SK bees

00:28:43,010 --> 00:28:46,370
have an extra reference to the TLS

00:28:44,630 --> 00:28:48,080
record from the beginning of it like as

00:28:46,370 --> 00:28:50,779
an object as a separate object and then

00:28:48,080 --> 00:28:52,250
inside came free skb when the final

00:28:50,779 --> 00:28:54,200
weapons goes away both two devices

00:28:52,250 --> 00:28:56,179
reference and move we transmit cues

00:28:54,200 --> 00:28:57,529
reference goes it pops out this we're

00:28:56,179 --> 00:29:00,049
just talking about an extra destructor

00:28:57,529 --> 00:29:01,490
than essentially some extra destruction

00:29:00,049 --> 00:29:02,600
like the init bridge info and all the

00:29:01,490 --> 00:29:03,950
other because it just sounds like the

00:29:02,600 --> 00:29:06,169
driver is doing some sort of custom

00:29:03,950 --> 00:29:07,490
thing when it's calling in to KT LS and

00:29:06,169 --> 00:29:12,380
doing its own destructor from the sound

00:29:07,490 --> 00:29:16,760
of it no pages is their problem if you

00:29:12,380 --> 00:29:18,649
are doing it with page references as

00:29:16,760 --> 00:29:21,590
long as you release it only when the

00:29:18,649 --> 00:29:25,700
last reference to the SK be goes away

00:29:21,590 --> 00:29:27,470
yeah it has to happen on the left count

00:29:25,700 --> 00:29:28,940
go to zero because other people can be

00:29:27,470 --> 00:29:31,279
referencing to other people places of

00:29:28,940 --> 00:29:33,289
the stack well you take lessons as long

00:29:31,279 --> 00:29:35,029
as you are using those pages right but

00:29:33,289 --> 00:29:36,860
the TCP stack has a reference to run the

00:29:35,029 --> 00:29:38,360
retransmit queue and you'll have a

00:29:36,860 --> 00:29:40,250
reference when you're transmitting and

00:29:38,360 --> 00:29:41,750
yeah I'm saying that the important issue

00:29:40,250 --> 00:29:46,029
is that when only when all these things

00:29:41,750 --> 00:29:46,029
go away can you release that data

00:29:54,800 --> 00:30:00,670

YouTube URL: https://www.youtube.com/watch?v=T6ZvLNy8uUw


