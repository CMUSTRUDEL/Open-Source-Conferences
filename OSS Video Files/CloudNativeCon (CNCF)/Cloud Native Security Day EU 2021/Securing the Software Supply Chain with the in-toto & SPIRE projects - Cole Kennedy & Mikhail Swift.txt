Title: Securing the Software Supply Chain with the in-toto & SPIRE projects - Cole Kennedy & Mikhail Swift
Publication date: 2021-05-04
Playlist: Cloud Native Security Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Securing the Software Supply Chain with the in-toto and SPIRE projects - Cole Kennedy & Mikhail Swift BoxBoat Technologies

A software supply chain is the set of steps required to test, build, deploy, and assure a software release. Verification of the build policy through a cryptographically attestable process is required to give software artifact consumers the confidence to install software releases on mission-critical systems. In this talk, we will discuss the current gaps in the open-source eco-systems and demonstrate a cryptographically attestable software pipeline with automated certificate issuance.
Captions: 
	00:00:00,160 --> 00:00:03,679
hello everyone welcome to our talk

00:00:02,000 --> 00:00:07,680
securing the supply chain

00:00:03,679 --> 00:00:07,680
xero trust builds with intel inspire

00:00:08,080 --> 00:00:11,440
let me start by introducing my myself

00:00:10,160 --> 00:00:14,480
there i am right there

00:00:11,440 --> 00:00:15,280
um i'm a solutions architect at box boat

00:00:14,480 --> 00:00:17,760
technology

00:00:15,280 --> 00:00:18,480
i also lead a lot of our technical

00:00:17,760 --> 00:00:20,880
initiatives

00:00:18,480 --> 00:00:22,080
are at box boat dealing with the federal

00:00:20,880 --> 00:00:24,880
and high compliance

00:00:22,080 --> 00:00:25,920
industries um i'm a contributor to the

00:00:24,880 --> 00:00:28,480
cncf

00:00:25,920 --> 00:00:30,080
sig security supply chain working group

00:00:28,480 --> 00:00:33,200
right now we are working

00:00:30,080 --> 00:00:35,440
on a supply chain security white paper

00:00:33,200 --> 00:00:37,120
hopefully by the time you see this video

00:00:35,440 --> 00:00:37,760
it will be released or soon to be

00:00:37,120 --> 00:00:40,640
released so

00:00:37,760 --> 00:00:44,719
so be on the lookout for that um i'll be

00:00:40,640 --> 00:00:47,280
posting it on my linkedin and twitter

00:00:44,719 --> 00:00:48,160
once that becomes available i work in

00:00:47,280 --> 00:00:50,800
defense

00:00:48,160 --> 00:00:51,360
banking and utilities you know generally

00:00:50,800 --> 00:00:53,680
those

00:00:51,360 --> 00:00:56,079
high compliance environments or high

00:00:53,680 --> 00:00:58,239
compliance verticals

00:00:56,079 --> 00:01:00,079
right they they all want to move to

00:00:58,239 --> 00:01:02,399
devsec ops but they have

00:01:00,079 --> 00:01:03,280
all this baggage and regulation involved

00:01:02,399 --> 00:01:06,479
with it

00:01:03,280 --> 00:01:08,640
it makes it very very difficult to do

00:01:06,479 --> 00:01:10,880
that so so we help them out there

00:01:08,640 --> 00:01:11,760
and then with me i have michael swift

00:01:10,880 --> 00:01:14,560
he's an amazing

00:01:11,760 --> 00:01:15,680
engineer he's a devops engineer with us

00:01:14,560 --> 00:01:18,080
at box boat

00:01:15,680 --> 00:01:19,280
as well he he contributes with me to

00:01:18,080 --> 00:01:22,080
that white paper

00:01:19,280 --> 00:01:23,360
i talked about and then he works on the

00:01:22,080 --> 00:01:25,759
us air force

00:01:23,360 --> 00:01:27,759
platform one so he helps bring some of

00:01:25,759 --> 00:01:29,280
their mission partners on board

00:01:27,759 --> 00:01:32,000
so if you think like these large

00:01:29,280 --> 00:01:34,479
traditional slow-moving uh defense

00:01:32,000 --> 00:01:35,759
integrators right they need to as the

00:01:34,479 --> 00:01:38,000
u.s air force moves

00:01:35,759 --> 00:01:40,079
into a devsec ops environment they need

00:01:38,000 --> 00:01:42,479
to bring these large

00:01:40,079 --> 00:01:44,079
uh so mikhail's working on a team that

00:01:42,479 --> 00:01:45,759
is really helping enable

00:01:44,079 --> 00:01:48,640
one of those large integrators to to

00:01:45,759 --> 00:01:51,680
work in that u.s air force platform

00:01:48,640 --> 00:01:51,680
i'm really proud of the work

00:01:51,759 --> 00:01:54,880
and then i'll talk about a little bit

00:01:53,040 --> 00:01:58,240
about boxboat we are

00:01:54,880 --> 00:02:01,439
a professional services uh

00:01:58,240 --> 00:02:02,640
company i like to call say cloud native

00:02:01,439 --> 00:02:04,240
integrators

00:02:02,640 --> 00:02:05,680
so we can take your you know your

00:02:04,240 --> 00:02:07,119
business requirements and then we take

00:02:05,680 --> 00:02:08,319
the cloud native landscape

00:02:07,119 --> 00:02:10,160
and come up with a plan to really

00:02:08,319 --> 00:02:12,959
accelerate your your devops journey and

00:02:10,160 --> 00:02:15,040
your digital monitor

00:02:12,959 --> 00:02:16,959
uh but let's get to the problem at hand

00:02:15,040 --> 00:02:20,480
right um

00:02:16,959 --> 00:02:22,560
there was some stuff that happened

00:02:20,480 --> 00:02:23,680
this past winter and it really kind of

00:02:22,560 --> 00:02:26,239
shook the entire

00:02:23,680 --> 00:02:28,000
industry um security administrators are

00:02:26,239 --> 00:02:31,680
finally trying to figure out that

00:02:28,000 --> 00:02:33,040
they have no way to assess the risk

00:02:31,680 --> 00:02:33,760
level of software running on their

00:02:33,040 --> 00:02:37,360
systems right

00:02:33,760 --> 00:02:40,160
it's a system based upon trust um

00:02:37,360 --> 00:02:42,160
and that's a problem right because a lot

00:02:40,160 --> 00:02:42,879
of organizations don't even sign their

00:02:42,160 --> 00:02:45,280
artifacts

00:02:42,879 --> 00:02:46,879
or any other metadata we look at the

00:02:45,280 --> 00:02:48,480
open source community right it's even a

00:02:46,879 --> 00:02:51,120
larger problem

00:02:48,480 --> 00:02:52,720
and it all goes back to right how do we

00:02:51,120 --> 00:02:54,080
sign those artifacts right it becomes

00:02:52,720 --> 00:02:55,680
very difficult especially when you're a

00:02:54,080 --> 00:02:57,920
large distributed organization

00:02:55,680 --> 00:03:00,879
to distributing those pr that private

00:02:57,920 --> 00:03:02,879
key material and certain consistency

00:03:00,879 --> 00:03:04,480
if you've ever worked in a large

00:03:02,879 --> 00:03:07,519
corporation and

00:03:04,480 --> 00:03:08,720
have tried to do some sort of request

00:03:07,519 --> 00:03:10,640
for certificates

00:03:08,720 --> 00:03:11,760
you understand that the process is

00:03:10,640 --> 00:03:13,360
different everywhere

00:03:11,760 --> 00:03:14,879
and it's generally very streamlined

00:03:13,360 --> 00:03:16,840
right it's something that that takes you

00:03:14,879 --> 00:03:19,920
know multiple levels of approval

00:03:16,840 --> 00:03:22,239
uh it can take multiple days

00:03:19,920 --> 00:03:23,599
so it's just a really difficult thing to

00:03:22,239 --> 00:03:25,519
do

00:03:23,599 --> 00:03:27,680
and all this really boils down to is

00:03:25,519 --> 00:03:28,480
that sometimes when we deliver software

00:03:27,680 --> 00:03:30,400
faster

00:03:28,480 --> 00:03:32,799
we're really delivering vulnerabilities

00:03:30,400 --> 00:03:34,879
in this high compliance environment

00:03:32,799 --> 00:03:36,400
defense banking utilities right that's

00:03:34,879 --> 00:03:39,040
just not acceptable

00:03:36,400 --> 00:03:40,879
we'd rather be slow and decades behind

00:03:39,040 --> 00:03:42,959
than have a system that's vulnerable

00:03:40,879 --> 00:03:44,480
um now we all know that you know

00:03:42,959 --> 00:03:46,400
existing systems that haven't been

00:03:44,480 --> 00:03:48,159
patched are vulnerable

00:03:46,400 --> 00:03:50,159
but we can't introduce neuter

00:03:48,159 --> 00:03:52,080
vulnerabilities into a system

00:03:50,159 --> 00:03:53,439
uh and we just can't move fast enough to

00:03:52,080 --> 00:03:57,439
have the assurance that we

00:03:53,439 --> 00:03:59,120
we know that that's happened so

00:03:57,439 --> 00:04:01,120
when i opened this talk i talked about

00:03:59,120 --> 00:04:02,319
zero trust that's a that's a big

00:04:01,120 --> 00:04:04,480
marketing

00:04:02,319 --> 00:04:06,640
and i kind of want to break that down a

00:04:04,480 --> 00:04:06,640
little

00:04:06,799 --> 00:04:13,040
and there's this idea right that

00:04:11,599 --> 00:04:14,480
that zero trust architecture is a

00:04:13,040 --> 00:04:15,680
product that you can buy but that that's

00:04:14,480 --> 00:04:18,239
just not the case right it's an

00:04:15,680 --> 00:04:20,160
architecture it's a design decision that

00:04:18,239 --> 00:04:21,519
that your company or your organization

00:04:20,160 --> 00:04:24,000
needs to make

00:04:21,519 --> 00:04:24,960
um and i like to distill zero trust

00:04:24,000 --> 00:04:27,680
architect

00:04:24,960 --> 00:04:28,000
three three points so you have identity

00:04:27,680 --> 00:04:30,800
that

00:04:28,000 --> 00:04:32,639
is your workload's identity based upon

00:04:30,800 --> 00:04:34,320
the attributes of that the immutable

00:04:32,639 --> 00:04:37,360
attributes of that workload

00:04:34,320 --> 00:04:38,400
such as a container hash the process

00:04:37,360 --> 00:04:40,560
binary

00:04:38,400 --> 00:04:42,080
hash right there has to be something

00:04:40,560 --> 00:04:44,639
about that workload that

00:04:42,080 --> 00:04:46,479
uniquely identifies it or identifies it

00:04:44,639 --> 00:04:48,720
as a part of a group

00:04:46,479 --> 00:04:50,320
the same goes for users right identity

00:04:48,720 --> 00:04:52,240
is not just workload identity right

00:04:50,320 --> 00:04:53,600
most of us understand identity as a user

00:04:52,240 --> 00:04:56,160
identity

00:04:53,600 --> 00:04:57,759
so we need to have strong identity

00:04:56,160 --> 00:05:01,280
systems for both users

00:04:57,759 --> 00:05:03,440
and work the next part is policy right

00:05:01,280 --> 00:05:04,960
so traditionally when we talk about

00:05:03,440 --> 00:05:06,720
policy we're talking about

00:05:04,960 --> 00:05:08,160
organizational policy right

00:05:06,720 --> 00:05:09,919
what can users do what can

00:05:08,160 --> 00:05:11,199
administrators do what are our left and

00:05:09,919 --> 00:05:13,680
right limbs

00:05:11,199 --> 00:05:15,520
generally in a traditional architecture

00:05:13,680 --> 00:05:16,960
you have your policy that's managed by a

00:05:15,520 --> 00:05:18,400
change control board so you'll bring a

00:05:16,960 --> 00:05:20,080
change to that change control board and

00:05:18,400 --> 00:05:22,800
they'll examine the policy to

00:05:20,080 --> 00:05:25,440
know hey is this going to go can this go

00:05:22,800 --> 00:05:28,160
into production based upon

00:05:25,440 --> 00:05:29,919
it's a very slow process it really

00:05:28,160 --> 00:05:31,199
doesn't work with a devsecops

00:05:29,919 --> 00:05:33,120
methodology

00:05:31,199 --> 00:05:35,039
um so what we do in the zero trust

00:05:33,120 --> 00:05:36,160
architecture is we take that policy and

00:05:35,039 --> 00:05:38,479
we

00:05:36,160 --> 00:05:40,080
we enable it as policy as code right so

00:05:38,479 --> 00:05:43,120
we have our left and right limits

00:05:40,080 --> 00:05:46,000
defined as some piece of automation

00:05:43,120 --> 00:05:47,280
um you know open policy agent is a great

00:05:46,000 --> 00:05:49,680
tool to do this

00:05:47,280 --> 00:05:51,600
and then finally we have control right

00:05:49,680 --> 00:05:53,600
what is actually taking these identity

00:05:51,600 --> 00:05:57,280
documents and policy documents

00:05:53,600 --> 00:05:57,280
to make decisions in the system

00:05:58,240 --> 00:06:03,759
so an example here may be that you know

00:06:01,440 --> 00:06:05,360
if you have a network policy that says

00:06:03,759 --> 00:06:06,800
two workloads can talk to each other

00:06:05,360 --> 00:06:07,280
right you need some sort of controller

00:06:06,800 --> 00:06:09,680
that

00:06:07,280 --> 00:06:10,960
that actuates those ip tables to make

00:06:09,680 --> 00:06:13,759
that

00:06:10,960 --> 00:06:15,440
so when you have these three things

00:06:13,759 --> 00:06:17,120
working together you do have a zero

00:06:15,440 --> 00:06:18,080
trust architecture and you take these

00:06:17,120 --> 00:06:19,759
three ideas

00:06:18,080 --> 00:06:21,759
and you can apply them to just about any

00:06:19,759 --> 00:06:25,039
problem in your space

00:06:21,759 --> 00:06:26,880
and design it securely so when we apply

00:06:25,039 --> 00:06:28,479
it to the ci cd pipeline we see that

00:06:26,880 --> 00:06:31,520
there's a

00:06:28,479 --> 00:06:32,639
traditional cicd pipeline all of the

00:06:31,520 --> 00:06:34,560
data

00:06:32,639 --> 00:06:36,560
that is collected or generated during

00:06:34,560 --> 00:06:39,680
the build process it's thrown away

00:06:36,560 --> 00:06:40,560
and not distributed along with the

00:06:39,680 --> 00:06:42,479
artifact

00:06:40,560 --> 00:06:44,160
that that metadata is extremely

00:06:42,479 --> 00:06:48,080
important to a testing of the

00:06:44,160 --> 00:06:49,599
validity of of that software that it was

00:06:48,080 --> 00:06:50,400
built on the machines you expected it to

00:06:49,599 --> 00:06:52,160
be built on

00:06:50,400 --> 00:06:53,680
it was built by the compilers you

00:06:52,160 --> 00:06:55,840
expected it to be built on

00:06:53,680 --> 00:06:57,919
there was no man-in-the-middle attacks

00:06:55,840 --> 00:06:59,440
that that modified the code in between

00:06:57,919 --> 00:07:02,080
these different processes

00:06:59,440 --> 00:07:03,680
you you want to have that assurance that

00:07:02,080 --> 00:07:05,199
your vendors did the right thing there

00:07:03,680 --> 00:07:07,680
before you deploy

00:07:05,199 --> 00:07:08,639
uh the software into mission critical

00:07:07,680 --> 00:07:11,039
systems

00:07:08,639 --> 00:07:11,759
and right now we're placing our trust in

00:07:11,039 --> 00:07:14,080
the pro

00:07:11,759 --> 00:07:16,240
we're saying okay you sign that artifact

00:07:14,080 --> 00:07:18,479
so we're gonna trust it in our system

00:07:16,240 --> 00:07:19,599
and you know the events of this past

00:07:18,479 --> 00:07:22,400
winter or

00:07:19,599 --> 00:07:23,840
past year in 2020 with uh with some of

00:07:22,400 --> 00:07:25,199
the supply chain attacks we've seen

00:07:23,840 --> 00:07:26,960
we just see that that's not the case

00:07:25,199 --> 00:07:30,400
right we cannot

00:07:26,960 --> 00:07:31,360
trust external processes in our mission

00:07:30,400 --> 00:07:33,440
critical systems

00:07:31,360 --> 00:07:35,759
we need to place trust and data not the

00:07:33,440 --> 00:07:35,759
process

00:07:36,000 --> 00:07:40,080
so this means we need to move to a

00:07:39,280 --> 00:07:42,160
system of

00:07:40,080 --> 00:07:44,000
evidence-based trust rather than a

00:07:42,160 --> 00:07:47,199
signature based

00:07:44,000 --> 00:07:51,039
um and this is this is somewhat of a

00:07:47,199 --> 00:07:53,919
new idea i know uh the ntia

00:07:51,039 --> 00:07:55,840
and mitre have been working on this the

00:07:53,919 --> 00:07:57,360
past couple

00:07:55,840 --> 00:07:58,879
and there's a paper called deliver

00:07:57,360 --> 00:08:00,319
uncompromised that that might have

00:07:58,879 --> 00:08:03,039
released

00:08:00,319 --> 00:08:07,039
a couple months ago and really kind of

00:08:03,039 --> 00:08:10,400
explains this concept and expands upon

00:08:07,039 --> 00:08:12,080
and you have this idea of an this is a

00:08:10,400 --> 00:08:15,120
piece of metadata that is

00:08:12,080 --> 00:08:17,039
emitted from each step of the build

00:08:15,120 --> 00:08:18,240
so if we take those s-bombs assigned

00:08:17,039 --> 00:08:20,160
s-bombs and

00:08:18,240 --> 00:08:22,080
you know put them all together we and

00:08:20,160 --> 00:08:23,199
use it and deliver them to the execution

00:08:22,080 --> 00:08:24,960
phase right

00:08:23,199 --> 00:08:26,960
we can actually use a controller at the

00:08:24,960 --> 00:08:29,919
execution phase to determine whether we

00:08:26,960 --> 00:08:31,680
trust that software

00:08:29,919 --> 00:08:34,320
and that allows our system

00:08:31,680 --> 00:08:36,159
administrators to examine that software

00:08:34,320 --> 00:08:38,479
to make sure that it does meet that

00:08:36,159 --> 00:08:40,560
organizational policy

00:08:38,479 --> 00:08:41,599
we're placing our trust in signed data

00:08:40,560 --> 00:08:44,159
we're placing our trust

00:08:41,599 --> 00:08:45,680
in public key infrastructure not the

00:08:44,159 --> 00:08:49,200
process when we move to an

00:08:45,680 --> 00:08:49,200
evidence-based trust model for

00:08:51,920 --> 00:08:56,240
the problem is that miner actually

00:08:54,080 --> 00:08:59,440
didn't release an implementation or any

00:08:56,240 --> 00:09:01,680
implementation guidance on

00:08:59,440 --> 00:09:02,560
so at box what we kind of took it upon

00:09:01,680 --> 00:09:05,200
ourselves uh

00:09:02,560 --> 00:09:07,440
you know we we've been working in supply

00:09:05,200 --> 00:09:09,120
chain and supply chain security for

00:09:07,440 --> 00:09:11,279
you know the entire history of our

00:09:09,120 --> 00:09:12,720
company it's what we do

00:09:11,279 --> 00:09:14,320
traditionally we've been focused on

00:09:12,720 --> 00:09:15,600
delivering software faster but as we

00:09:14,320 --> 00:09:16,480
move into these high compliance

00:09:15,600 --> 00:09:18,480
environments they have

00:09:16,480 --> 00:09:20,000
new requirements right they want to

00:09:18,480 --> 00:09:22,080
actually be able to trust that

00:09:20,000 --> 00:09:23,600
that software so we started looking at

00:09:22,080 --> 00:09:25,920
the in toto

00:09:23,600 --> 00:09:27,360
project um and toto is a great project

00:09:25,920 --> 00:09:29,200
it does what we need to do right it

00:09:27,360 --> 00:09:31,040
emits those s-bombs that metadata that

00:09:29,200 --> 00:09:32,160
signed metadata for each stage of the

00:09:31,040 --> 00:09:34,320
build

00:09:32,160 --> 00:09:36,000
it allows us to verify that by an

00:09:34,320 --> 00:09:38,640
out-of-band uh

00:09:36,000 --> 00:09:39,760
policy enforcement uh they call that a

00:09:38,640 --> 00:09:41,120
layout file

00:09:39,760 --> 00:09:42,640
right so that when you put these

00:09:41,120 --> 00:09:44,399
together it allows you to

00:09:42,640 --> 00:09:47,120
cryptographically verify

00:09:44,399 --> 00:09:49,040
the build process wherever you are right

00:09:47,120 --> 00:09:49,600
so we can we can verify that build

00:09:49,040 --> 00:09:51,600
process

00:09:49,600 --> 00:09:53,440
at the execution phase not having to

00:09:51,600 --> 00:09:56,720
rely on

00:09:53,440 --> 00:10:00,399
um trust of of that that

00:09:56,720 --> 00:10:00,399
business process from that vendor that

00:10:00,800 --> 00:10:05,839
so how does this actually work so uh

00:10:06,160 --> 00:10:10,560
then total effectively decouples the

00:10:08,480 --> 00:10:12,720
build policy from the build process

00:10:10,560 --> 00:10:14,480
itself so in a traditional build process

00:10:12,720 --> 00:10:17,920
you may have

00:10:14,480 --> 00:10:19,440
a gitlab ci pipeline that that is

00:10:17,920 --> 00:10:20,720
enforced at some point right but if

00:10:19,440 --> 00:10:22,320
you're using

00:10:20,720 --> 00:10:24,480
but once you leave that git lab

00:10:22,320 --> 00:10:26,560
environment or that ci environment

00:10:24,480 --> 00:10:28,160
you have no way to validate that right

00:10:26,560 --> 00:10:29,200
so what in total does is it gives us

00:10:28,160 --> 00:10:32,720
this out-of-band

00:10:29,200 --> 00:10:34,320
validation um in this in this diagram

00:10:32,720 --> 00:10:36,079
you see there's a project owner diana

00:10:34,320 --> 00:10:37,360
right she's going to define what that

00:10:36,079 --> 00:10:39,920
build policy is

00:10:37,360 --> 00:10:40,640
she can say hey all my builds need to

00:10:39,920 --> 00:10:44,000
meet

00:10:40,640 --> 00:10:45,040
certain criteria um and then each of the

00:10:44,000 --> 00:10:47,279
functionaries

00:10:45,040 --> 00:10:48,800
here are responsible for fulfilling or

00:10:47,279 --> 00:10:52,560
satisfying

00:10:48,800 --> 00:10:54,480
those requirements each functionary

00:10:52,560 --> 00:10:56,560
which could also be it could be a person

00:10:54,480 --> 00:10:58,839
or an actual build step

00:10:56,560 --> 00:11:00,160
does require a private key to sign that

00:10:58,839 --> 00:11:02,560
metadata

00:11:00,160 --> 00:11:03,680
which kind of causes some issues when we

00:11:02,560 --> 00:11:05,839
bring this into an enterprise

00:11:03,680 --> 00:11:08,880
environment

00:11:05,839 --> 00:11:10,959
so enter spiffy spire uh you know we're

00:11:08,880 --> 00:11:12,320
not gonna do a real big deep dive into

00:11:10,959 --> 00:11:15,120
what spiffy spire

00:11:12,320 --> 00:11:16,880
uh is and how it works there's a lot of

00:11:15,120 --> 00:11:18,480
really really great talks on that and a

00:11:16,880 --> 00:11:21,519
great active community

00:11:18,480 --> 00:11:23,200
uh but spiffy is the

00:11:21,519 --> 00:11:24,959
spire is the implementation of the

00:11:23,200 --> 00:11:26,640
spiffy apis it's a

00:11:24,959 --> 00:11:28,720
reference implementation is what we used

00:11:26,640 --> 00:11:31,760
in this project here

00:11:28,720 --> 00:11:34,000
and spire allows us to issue

00:11:31,760 --> 00:11:34,880
identities in the form of x509

00:11:34,000 --> 00:11:37,680
certificates

00:11:34,880 --> 00:11:38,720
to workloads based upon their immutable

00:11:37,680 --> 00:11:41,680
attribute

00:11:38,720 --> 00:11:43,120
container hash what user there's there's

00:11:41,680 --> 00:11:43,760
a lot of different selectors that we can

00:11:43,120 --> 00:11:46,640
pick on

00:11:43,760 --> 00:11:47,760
including you know what machine that

00:11:46,640 --> 00:11:49,519
they're being built on

00:11:47,760 --> 00:11:51,839
in one of our engagement we're actually

00:11:49,519 --> 00:11:52,560
able to tie issuing these identities

00:11:51,839 --> 00:11:56,800
down to

00:11:52,560 --> 00:11:58,480
a the public hash of that tpm key

00:11:56,800 --> 00:12:00,079
on that machine right so we can

00:11:58,480 --> 00:12:01,519
cryptographically prove that builds

00:12:00,079 --> 00:12:04,000
happen on a specific

00:12:01,519 --> 00:12:04,000
machine

00:12:06,160 --> 00:12:11,440
all right and so

00:12:09,440 --> 00:12:12,880
this allows us to register these

00:12:11,440 --> 00:12:15,040
functionaries through the

00:12:12,880 --> 00:12:16,000
spire registration and once we've

00:12:15,040 --> 00:12:17,360
registered these

00:12:16,000 --> 00:12:19,360
these functionaries to the spire

00:12:17,360 --> 00:12:21,760
registration api

00:12:19,360 --> 00:12:23,519
those functionaries are issued the keys

00:12:21,760 --> 00:12:24,800
that we specify and then they can sign

00:12:23,519 --> 00:12:28,800
that metadata

00:12:24,800 --> 00:12:28,800
and the whole process becomes automated

00:12:29,760 --> 00:12:35,839
you know we are able to again

00:12:33,519 --> 00:12:37,680
attest to the machine it was running on

00:12:35,839 --> 00:12:40,880
or the cloud environment was running on

00:12:37,680 --> 00:12:44,000
as well as a specific workload

00:12:40,880 --> 00:12:44,000
that is running on the

00:12:44,720 --> 00:12:49,200
when we take those two projects and put

00:12:46,240 --> 00:12:51,040
them together it allows us to create an

00:12:49,200 --> 00:12:53,040
automated architecture that that

00:12:51,040 --> 00:12:54,720
implements that reference design that

00:12:53,040 --> 00:12:56,160
that we talked about earlier that

00:12:54,720 --> 00:12:57,920
might have released that deliver

00:12:56,160 --> 00:13:01,360
uncompromised paper

00:12:57,920 --> 00:13:03,360
um allows us to tell

00:13:01,360 --> 00:13:04,560
allows us to attest for the workload

00:13:03,360 --> 00:13:07,120
identity right

00:13:04,560 --> 00:13:08,800
what who built the software and where it

00:13:07,120 --> 00:13:10,800
was built

00:13:08,800 --> 00:13:11,839
and allows us to pass that information

00:13:10,800 --> 00:13:15,920
downstream

00:13:11,839 --> 00:13:15,920
to consumers of the software so they can

00:13:18,839 --> 00:13:23,839
actually

00:13:20,800 --> 00:13:25,279
so without further ado i'm going to pass

00:13:23,839 --> 00:13:26,240
it over to mikhail and he's going to

00:13:25,279 --> 00:13:30,480
actually go over

00:13:26,240 --> 00:13:30,480
a demonstration of this working out

00:13:31,360 --> 00:13:34,480
damn thanks cole i'm going to give a

00:13:33,040 --> 00:13:36,480
quick demo of the work that we've done

00:13:34,480 --> 00:13:38,320
within toto inspire

00:13:36,480 --> 00:13:39,839
we have a sample hello world project

00:13:38,320 --> 00:13:41,440
here

00:13:39,839 --> 00:13:43,600
as part of this hello world project we

00:13:41,440 --> 00:13:46,480
defined a simple build pipeline

00:13:43,600 --> 00:13:47,440
it clones build both a binary and a

00:13:46,480 --> 00:13:49,519
docker image

00:13:47,440 --> 00:13:52,079
scans a docker image and then finally

00:13:49,519 --> 00:13:55,519
uses in toto to verify that image before

00:13:52,079 --> 00:13:57,279
it publishes it to a docker registry

00:13:55,519 --> 00:13:58,800
the only difference between this and any

00:13:57,279 --> 00:14:00,480
other pipeline that you've probably seen

00:13:58,800 --> 00:14:03,920
is that we wrap every command

00:14:00,480 --> 00:14:04,560
in an in total run this allows in toto

00:14:03,920 --> 00:14:06,399
to capture

00:14:04,560 --> 00:14:08,720
any materials which are things that we

00:14:06,399 --> 00:14:10,160
use in our built on our stage

00:14:08,720 --> 00:14:12,000
and products which are things that we

00:14:10,160 --> 00:14:14,079
create in our state

00:14:12,000 --> 00:14:15,519
we are also connecting to the spiffy

00:14:14,079 --> 00:14:18,560
spire

00:14:15,519 --> 00:14:20,880
socket which allows us to get ease and

00:14:18,560 --> 00:14:21,839
do some workload uh attestation to make

00:14:20,880 --> 00:14:23,680
sure that

00:14:21,839 --> 00:14:26,800
we're actually verified to do this and

00:14:23,680 --> 00:14:29,279
we're a trusted workload

00:14:26,800 --> 00:14:30,480
and then finally it just wraps our git

00:14:29,279 --> 00:14:34,000
clone or whatever

00:14:30,480 --> 00:14:34,000
else we're going to run here

00:14:35,279 --> 00:14:38,720
and we can see this reflected in our in

00:14:37,440 --> 00:14:40,480
total layout

00:14:38,720 --> 00:14:42,240
the layout is what's going to tell in

00:14:40,480 --> 00:14:44,800
toto what each step

00:14:42,240 --> 00:14:46,320
should do who's allowed to do that step

00:14:44,800 --> 00:14:48,320
as a functionary

00:14:46,320 --> 00:14:51,040
and then what materials and what

00:14:48,320 --> 00:14:53,279
products are expected for each step

00:14:51,040 --> 00:14:55,120
so everything here has to match what

00:14:53,279 --> 00:14:57,839
happens in our pipeline

00:14:55,120 --> 00:14:59,440
for example if our command doesn't match

00:14:57,839 --> 00:15:01,279
and toto will throw warnings

00:14:59,440 --> 00:15:03,600
it won't outright fail because sometimes

00:15:01,279 --> 00:15:05,839
commands not matching as expected

00:15:03,600 --> 00:15:07,440
there are some things you may your

00:15:05,839 --> 00:15:09,360
variables that may vary that you just

00:15:07,440 --> 00:15:11,199
won't know ahead of time

00:15:09,360 --> 00:15:12,800
but everything else such as our

00:15:11,199 --> 00:15:16,320
materials will fail

00:15:12,800 --> 00:15:19,120
and cause a hard failure on verification

00:15:16,320 --> 00:15:20,000
so for example in our in our clone stage

00:15:19,120 --> 00:15:21,600
we are saying

00:15:20,000 --> 00:15:22,959
we don't need any materials we should

00:15:21,600 --> 00:15:24,320
not have any materials because we're

00:15:22,959 --> 00:15:27,279
cloning

00:15:24,320 --> 00:15:27,920
we're going to create everything in our

00:15:27,279 --> 00:15:29,120
folder

00:15:27,920 --> 00:15:31,759
saying that we basically clear it

00:15:29,120 --> 00:15:33,360
created the world when we clone

00:15:31,759 --> 00:15:35,040
then as part of our build stage we're

00:15:33,360 --> 00:15:36,959
going to say our build command should be

00:15:35,040 --> 00:15:38,800
go build

00:15:36,959 --> 00:15:41,120
and then our expected materials must

00:15:38,800 --> 00:15:43,839
match our products from our clone state

00:15:41,120 --> 00:15:45,519
so this prevents any files from changing

00:15:43,839 --> 00:15:47,440
any files from being added

00:15:45,519 --> 00:15:49,199
things like that in between stages and

00:15:47,440 --> 00:15:51,519
making sure we only use

00:15:49,199 --> 00:15:54,480
files that we created in the clone step

00:15:51,519 --> 00:15:56,240
and our build step

00:15:54,480 --> 00:15:59,839
and then the final part of the in total

00:15:56,240 --> 00:16:02,240
stage is the inspection and verification

00:15:59,839 --> 00:16:03,120
so by default in total we'll look at

00:16:02,240 --> 00:16:05,120
every single

00:16:03,120 --> 00:16:06,959
metadata prevented by each of these

00:16:05,120 --> 00:16:08,000
steps and it'll make sure that the

00:16:06,959 --> 00:16:10,320
materials and products

00:16:08,000 --> 00:16:11,600
match your defined rules you can also

00:16:10,320 --> 00:16:13,680
define this

00:16:11,600 --> 00:16:16,240
inspection stage which may do extra

00:16:13,680 --> 00:16:18,959
stuff that you define

00:16:16,240 --> 00:16:20,880
in our case in our previous build image

00:16:18,959 --> 00:16:24,320
stage we tarred up our file

00:16:20,880 --> 00:16:25,519
our docker image and now we're going to

00:16:24,320 --> 00:16:28,639
say that

00:16:25,519 --> 00:16:30,399
this docker image bar that we have now

00:16:28,639 --> 00:16:31,920
must match the one that was created from

00:16:30,399 --> 00:16:34,480
the build image stage

00:16:31,920 --> 00:16:36,480
so if someone were to download a target

00:16:34,480 --> 00:16:37,440
copy of our image they'd be able to

00:16:36,480 --> 00:16:39,920
verify

00:16:37,440 --> 00:16:41,440
with the signed metadata that the image

00:16:39,920 --> 00:16:44,720
they have was the same one that we

00:16:41,440 --> 00:16:47,680
created as part of our build process

00:16:44,720 --> 00:16:50,000
the final part that we added is this

00:16:47,680 --> 00:16:52,959
root case

00:16:50,000 --> 00:16:54,800
by d are currently today entoto allows

00:16:52,959 --> 00:16:58,160
you to sign metadata

00:16:54,800 --> 00:17:00,000
and verify functionaries with dpg and

00:16:58,160 --> 00:17:02,560
public private key pairs that are

00:17:00,000 --> 00:17:04,400
embedded in this layout

00:17:02,560 --> 00:17:06,160
with our integration with spiffy we

00:17:04,400 --> 00:17:07,039
wanted to make sure that we could sign

00:17:06,160 --> 00:17:09,600
metadata

00:17:07,039 --> 00:17:10,480
with any key and certificate pair

00:17:09,600 --> 00:17:14,000
belonging

00:17:10,480 --> 00:17:15,760
to a trusted root so as part of that we

00:17:14,000 --> 00:17:17,679
added in the root

00:17:15,760 --> 00:17:19,039
certificate as part of the layout

00:17:17,679 --> 00:17:21,760
that'll then be signed by

00:17:19,039 --> 00:17:23,520
another trusted key one that could be

00:17:21,760 --> 00:17:26,319
pre-shared between bill agents

00:17:23,520 --> 00:17:29,760
and anyone who needs to verify in a

00:17:26,319 --> 00:17:29,760
separate out-of-band process

00:17:30,240 --> 00:17:34,880
from there each step we added to a cert

00:17:32,799 --> 00:17:37,200
constraint field too

00:17:34,880 --> 00:17:38,480
this is saying that certain attributes

00:17:37,200 --> 00:17:41,120
of our certificate

00:17:38,480 --> 00:17:42,320
must match these things so for example

00:17:41,120 --> 00:17:45,280
the clone

00:17:42,320 --> 00:17:46,559
any common name is okay we want this

00:17:45,280 --> 00:17:49,039
specific uri

00:17:46,559 --> 00:17:50,320
in our certificate and this is a spiffy

00:17:49,039 --> 00:17:54,559
id that

00:17:50,320 --> 00:17:59,200
will be in any key made by our

00:17:54,559 --> 00:17:59,200
fifi agent and provided to our builders

00:17:59,520 --> 00:18:02,559
the show how when toto can catch

00:18:00,960 --> 00:18:03,440
unexpected things from happening in your

00:18:02,559 --> 00:18:04,559
build process

00:18:03,440 --> 00:18:06,480
you can take a look at this merge

00:18:04,559 --> 00:18:08,640
request i've opened

00:18:06,480 --> 00:18:10,240
and here i'm just adding a line after

00:18:08,640 --> 00:18:13,039
our main function

00:18:10,240 --> 00:18:14,080
this is printing this shouldn't be here

00:18:13,039 --> 00:18:16,880
as our opening

00:18:14,080 --> 00:18:18,480
statement in our main function doing

00:18:16,880 --> 00:18:20,080
this outside of in toto run

00:18:18,480 --> 00:18:22,480
so in toto should have no idea this

00:18:20,080 --> 00:18:24,559
happened if i take a look at our build

00:18:22,480 --> 00:18:27,360
property volume for this merge request

00:18:24,559 --> 00:18:28,559
i see it's failing image verification if

00:18:27,360 --> 00:18:31,440
we take a look as to why

00:18:28,559 --> 00:18:33,520
it's in failing the inspection step for

00:18:31,440 --> 00:18:35,120
artifact verification failed for step

00:18:33,520 --> 00:18:36,480
build materials may not go were

00:18:35,120 --> 00:18:39,679
disallowed by the rule

00:18:36,480 --> 00:18:40,400
disallow star as part of our rules for

00:18:39,679 --> 00:18:42,400
verification

00:18:40,400 --> 00:18:44,240
for our build stage we said that

00:18:42,400 --> 00:18:46,400
everything used as materials had to

00:18:44,240 --> 00:18:48,080
match the products from our clone

00:18:46,400 --> 00:18:50,720
since that didn't it got caught by the

00:18:48,080 --> 00:18:52,080
disallow star stage

00:18:50,720 --> 00:18:54,160
you can distribute your in total

00:18:52,080 --> 00:18:56,000
metadata from these build stages so that

00:18:54,160 --> 00:18:58,080
anyone who gets your software and the

00:18:56,000 --> 00:18:59,200
metadata can verify that you are the one

00:18:58,080 --> 00:19:01,520
who built it

00:18:59,200 --> 00:19:02,480
and that they can trust it when you

00:19:01,520 --> 00:19:05,039
start to combine

00:19:02,480 --> 00:19:07,200
in toto with things such as reproducible

00:19:05,039 --> 00:19:09,120
builds and distributed builds

00:19:07,200 --> 00:19:10,720
it really gives you a strong idea of

00:19:09,120 --> 00:19:11,600
maybe when a build environment has just

00:19:10,720 --> 00:19:14,080
diverged

00:19:11,600 --> 00:19:15,919
and is producing different builds or

00:19:14,080 --> 00:19:17,200
maybe something malicious is going on in

00:19:15,919 --> 00:19:19,760
that build environment and you need to

00:19:17,200 --> 00:19:21,440
dig in deeper

00:19:19,760 --> 00:19:22,799
if you want to play with our code we've

00:19:21,440 --> 00:19:26,240
published it here on github

00:19:22,799 --> 00:19:29,520
on the box vote and toto golang repo

00:19:26,240 --> 00:19:32,799
thank you and i'll hand it back to cole

00:19:29,520 --> 00:19:35,840
as you can see we built a system with

00:19:32,799 --> 00:19:39,840
both intel inspire that allows us

00:19:35,840 --> 00:19:43,760
validity the trustworthy software

00:19:39,840 --> 00:19:48,880
decouple we'll be sticking around for

00:19:43,760 --> 00:19:48,880

YouTube URL: https://www.youtube.com/watch?v=4lFbdkB62QI


