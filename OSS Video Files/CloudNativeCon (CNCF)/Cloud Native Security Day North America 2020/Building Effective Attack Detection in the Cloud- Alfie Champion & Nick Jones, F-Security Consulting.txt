Title: Building Effective Attack Detection in the Cloud- Alfie Champion & Nick Jones, F-Security Consulting
Publication date: 2020-11-25
Playlist: Cloud Native Security Day North America 2020
Description: 
	Building Effective Attack Detection in the Cloud - Alfie Champion & Nick Jones, F-Security Consulting

The cloud has significantly altered the nature of attack detection, and many of the common data sources and attacker TTPs that security teams have been looking for on premise have changed or are no longer relevant. A lack of public threat intelligence has hindered development of industry knowledge bases, such as the MITRE ATT&CK framework, and the nature of many cloud-native attacker TTPs make it challenging to separate the malicious from the benign.  Based on ﬁrst-hand experience attacking and defending large enterprises, this talk will share what Alfie and Nick have learned about detecting attacks against cloud-native environments. They will cover how the cloud has changed the detection landscape, the key data sources to leverage, and how to plan and prioritise your cloud detection use cases. They'll also discuss how to validate your detection, including a demonstration of Leonidas, an open source framework for automatically validating detection capability in the cloud.
Captions: 
	00:00:00,080 --> 00:00:03,199
welcome to building effective attack

00:00:02,080 --> 00:00:05,200
detection in the cloud

00:00:03,199 --> 00:00:07,839
uh today presenting you've got nick

00:00:05,200 --> 00:00:08,320
jones and alfie champion um i'm nick i

00:00:07,839 --> 00:00:10,000
run

00:00:08,320 --> 00:00:11,759
our global cloud security team at

00:00:10,000 --> 00:00:13,759
f-secure uh when i'm not

00:00:11,759 --> 00:00:15,839
working on people's cloud security i do

00:00:13,759 --> 00:00:18,000
attack detection which is why i'm here

00:00:15,839 --> 00:00:19,920
um and alfie's sort of the reverse alfie

00:00:18,000 --> 00:00:21,039
yeah yeah absolutely uh so i lead up the

00:00:19,920 --> 00:00:22,400
uh global

00:00:21,039 --> 00:00:24,320
attack detection service for rescue

00:00:22,400 --> 00:00:25,439
consulting uh and likewise much like

00:00:24,320 --> 00:00:27,599
nick in my spare time

00:00:25,439 --> 00:00:29,119
i've kind of flipped focus on on

00:00:27,599 --> 00:00:31,840
building some really wonderful things in

00:00:29,119 --> 00:00:31,840
cloud

00:00:35,360 --> 00:00:38,480
so first up and we're going to be

00:00:36,719 --> 00:00:40,160
talking about the differences between

00:00:38,480 --> 00:00:41,760
on-premise and cloud attack detection

00:00:40,160 --> 00:00:43,520
and there's quite a few key differences

00:00:41,760 --> 00:00:46,239
there i think to focus in on

00:00:43,520 --> 00:00:46,800
um secondly what's an attack are likely

00:00:46,239 --> 00:00:48,000
to do

00:00:46,800 --> 00:00:49,440
and what are they going to try in your

00:00:48,000 --> 00:00:50,960
environments what should you be looking

00:00:49,440 --> 00:00:52,719
for

00:00:50,960 --> 00:00:54,800
and then lastly um one of the things

00:00:52,719 --> 00:00:55,520
we've learned over our last year or two

00:00:54,800 --> 00:00:57,120
working on this

00:00:55,520 --> 00:00:59,920
is very much that there's an awful lot

00:00:57,120 --> 00:01:01,920
we can learn from the the devops

00:00:59,920 --> 00:01:04,000
um you know tips and tricks things to do

00:01:01,920 --> 00:01:07,680
that really help level up your cloud

00:01:04,000 --> 00:01:07,680
attack detection capability long term

00:01:09,520 --> 00:01:12,720
absolutely so first thing to consider

00:01:11,840 --> 00:01:14,479
then is

00:01:12,720 --> 00:01:16,640
the difference when it comes to on-prem

00:01:14,479 --> 00:01:17,360
versus cloud is this already a solved

00:01:16,640 --> 00:01:19,119
problem

00:01:17,360 --> 00:01:20,880
and can we apply the same learnings from

00:01:19,119 --> 00:01:22,000
on-premises section that we've done for

00:01:20,880 --> 00:01:24,880
a while now

00:01:22,000 --> 00:01:26,159
and apply those to cloud well we take a

00:01:24,880 --> 00:01:28,720
look um

00:01:26,159 --> 00:01:30,560
in some ways yes yes there are some very

00:01:28,720 --> 00:01:32,240
very obvious similarities so

00:01:30,560 --> 00:01:34,320
you consider things like the the

00:01:32,240 --> 00:01:35,040
automation of attacks or scalability of

00:01:34,320 --> 00:01:37,280
those we see

00:01:35,040 --> 00:01:38,960
this kind of never-ending cycle of um

00:01:37,280 --> 00:01:40,240
exploits being released and then kind of

00:01:38,960 --> 00:01:40,720
proof of concepts being released and

00:01:40,240 --> 00:01:42,479
then some

00:01:40,720 --> 00:01:44,159
some widespread scanning and an

00:01:42,479 --> 00:01:45,600
exploitation taking place

00:01:44,159 --> 00:01:47,840
that's still a thing there are some kind

00:01:45,600 --> 00:01:50,159
of cloud variations of that so you see

00:01:47,840 --> 00:01:51,920
um exposure credentials in things like

00:01:50,159 --> 00:01:54,079
public s3 buckets or

00:01:51,920 --> 00:01:56,320
inadvertently kind of pushed to public

00:01:54,079 --> 00:01:57,600
code repositories like github

00:01:56,320 --> 00:02:00,000
and then there's also kind of a new

00:01:57,600 --> 00:02:00,320
flavor um of attack which is that kind

00:02:00,000 --> 00:02:02,479
of

00:02:00,320 --> 00:02:04,320
as mata defines it as resource hijacking

00:02:02,479 --> 00:02:06,399
kind of the crypto mining type stuff

00:02:04,320 --> 00:02:08,399
obviously even more so with this kind of

00:02:06,399 --> 00:02:10,319
a similarity there with on-prem

00:02:08,399 --> 00:02:12,400
when it comes to ransomware being

00:02:10,319 --> 00:02:14,879
definitely in vogue as it were so

00:02:12,400 --> 00:02:16,000
there's a lot of that going on but a lot

00:02:14,879 --> 00:02:18,800
of that to some degree

00:02:16,000 --> 00:02:20,239
is covered by some of the the managed

00:02:18,800 --> 00:02:21,599
service kind of the idf stuff that you

00:02:20,239 --> 00:02:23,360
see from cloud providers the likes of

00:02:21,599 --> 00:02:25,680
guard duty that provide things

00:02:23,360 --> 00:02:26,800
um there relating to kind of scanning

00:02:25,680 --> 00:02:28,560
activity to

00:02:26,800 --> 00:02:30,480
kind of beaking out to known bad ips

00:02:28,560 --> 00:02:31,760
that kind of thing what we're looking at

00:02:30,480 --> 00:02:33,760
and certainly is where we spend most of

00:02:31,760 --> 00:02:36,239
our time kind of pushes up that

00:02:33,760 --> 00:02:37,599
that pyramid from the opportunistic

00:02:36,239 --> 00:02:39,440
exploitation so

00:02:37,599 --> 00:02:40,959
um using the instance of metadata

00:02:39,440 --> 00:02:42,720
service which has obviously been

00:02:40,959 --> 00:02:45,040
um quite quite well known when it comes

00:02:42,720 --> 00:02:46,720
to cloud instance exploitation

00:02:45,040 --> 00:02:48,000
and then moving up into that targeted

00:02:46,720 --> 00:02:49,920
attack where it's like rather than just

00:02:48,000 --> 00:02:51,440
that indiscriminate or opportunistic

00:02:49,920 --> 00:02:52,400
what would it look like for a

00:02:51,440 --> 00:02:54,400
sophisticated

00:02:52,400 --> 00:02:56,000
uh attacker to target you specifically

00:02:54,400 --> 00:02:56,480
and the assets that you you have within

00:02:56,000 --> 00:02:57,920
cloud

00:02:56,480 --> 00:03:00,640
so that's where we've been focusing

00:02:57,920 --> 00:03:02,159
really um

00:03:00,640 --> 00:03:03,280
when we look at this from a detective

00:03:02,159 --> 00:03:04,480
standpoint we start looking at the

00:03:03,280 --> 00:03:06,159
telemetry that's like the raw

00:03:04,480 --> 00:03:08,720
ingredients for detection right

00:03:06,159 --> 00:03:10,800
um on-prem there's there's three obvious

00:03:08,720 --> 00:03:12,159
sources there so the first is is kind of

00:03:10,800 --> 00:03:13,360
endpoint telemetry so

00:03:12,159 --> 00:03:15,360
you know like endpoint detection and

00:03:13,360 --> 00:03:17,360
response edr agents are obviously

00:03:15,360 --> 00:03:19,120
hugely valuable there for process

00:03:17,360 --> 00:03:20,400
creations and kind of registry changes

00:03:19,120 --> 00:03:22,239
et cetera et cetera

00:03:20,400 --> 00:03:23,519
we've also got network telemetry which

00:03:22,239 --> 00:03:25,200
hosts talks to each other

00:03:23,519 --> 00:03:26,799
things like kind of port scanning or

00:03:25,200 --> 00:03:27,280
kind of domain enumeration would end up

00:03:26,799 --> 00:03:29,120
with some

00:03:27,280 --> 00:03:30,799
some noise coming from that and then

00:03:29,120 --> 00:03:31,840
we've also got application telemetry as

00:03:30,799 --> 00:03:32,640
well so the way that people are

00:03:31,840 --> 00:03:34,959
interacting with

00:03:32,640 --> 00:03:36,879
potentially our internet-facing assets

00:03:34,959 --> 00:03:38,640
um what telemetry does that provide is

00:03:36,879 --> 00:03:40,319
there any way that we can provide

00:03:38,640 --> 00:03:41,840
some kind of insight into mrs activity

00:03:40,319 --> 00:03:44,720
using that

00:03:41,840 --> 00:03:46,159
if we now look at cloud all of that is

00:03:44,720 --> 00:03:48,000
is relevant um

00:03:46,159 --> 00:03:49,920
but we now have this this layer above

00:03:48,000 --> 00:03:50,400
the control plane telemetry that kind of

00:03:49,920 --> 00:03:51,920
almost

00:03:50,400 --> 00:03:54,000
encompassing everything we've just

00:03:51,920 --> 00:03:56,400
spoken about you consider an environment

00:03:54,000 --> 00:03:57,840
um for just a kind of classic on-prem

00:03:56,400 --> 00:03:59,280
application tech stack

00:03:57,840 --> 00:04:00,560
you could be that you have the endpoint

00:03:59,280 --> 00:04:02,080
telemetry still from the operating

00:04:00,560 --> 00:04:03,439
systems hosting that stuff

00:04:02,080 --> 00:04:05,200
it could be that you have the network's

00:04:03,439 --> 00:04:05,439
limitatory of how those the various kind

00:04:05,200 --> 00:04:06,879
of

00:04:05,439 --> 00:04:08,560
front-end and back-end services interact

00:04:06,879 --> 00:04:09,599
with each other and then you've got the

00:04:08,560 --> 00:04:10,799
application telemetry

00:04:09,599 --> 00:04:13,040
of the thing that you've written and

00:04:10,799 --> 00:04:14,560
you're now hosting but now we have

00:04:13,040 --> 00:04:16,160
this this surrounding layer which is the

00:04:14,560 --> 00:04:18,160
control plane where we're

00:04:16,160 --> 00:04:20,000
interacting with that api so all of the

00:04:18,160 --> 00:04:20,720
major providers expose that api that you

00:04:20,000 --> 00:04:22,160
can use

00:04:20,720 --> 00:04:23,840
to do any number of things within the

00:04:22,160 --> 00:04:27,360
account that could be from spinning up

00:04:23,840 --> 00:04:27,759
and um virtual machines to provisioning

00:04:27,360 --> 00:04:29,280
um

00:04:27,759 --> 00:04:31,199
accounts with new permissions that kind

00:04:29,280 --> 00:04:32,800
of thing so there's a whole load of new

00:04:31,199 --> 00:04:34,000
telemetry that we have our disposal as

00:04:32,800 --> 00:04:35,600
defenders

00:04:34,000 --> 00:04:38,639
and there's also these three sources

00:04:35,600 --> 00:04:40,639
within that that square there that are

00:04:38,639 --> 00:04:42,000
of varying importance depending on what

00:04:40,639 --> 00:04:43,520
your stack actually looks like what

00:04:42,000 --> 00:04:45,120
you're hosting in cloud if obviously

00:04:43,520 --> 00:04:46,000
you're not using any endpoint anymore

00:04:45,120 --> 00:04:47,759
there's no

00:04:46,000 --> 00:04:49,199
equivalent there's no ec2 or virtual

00:04:47,759 --> 00:04:50,479
machines there then obviously that

00:04:49,199 --> 00:04:51,759
doesn't really come into play anymore

00:04:50,479 --> 00:04:53,120
and that's one of the key learnings for

00:04:51,759 --> 00:04:54,800
us is kind of where

00:04:53,120 --> 00:04:57,840
telemetry sources are applicable and

00:04:54,800 --> 00:04:57,840
where maybe they aren't anymore

00:04:58,479 --> 00:05:02,160
another major finding or kind of

00:05:00,639 --> 00:05:04,000
experience point for us i guess is

00:05:02,160 --> 00:05:05,280
around context and that comes down to

00:05:04,000 --> 00:05:07,039
when you're dealing with an environment

00:05:05,280 --> 00:05:08,400
that is purpose built

00:05:07,039 --> 00:05:10,320
the actions that take place in that

00:05:08,400 --> 00:05:11,280
environment are very much based on the

00:05:10,320 --> 00:05:12,720
purpose of

00:05:11,280 --> 00:05:15,039
everything in there every asset in there

00:05:12,720 --> 00:05:16,880
so we consider a given kind of i am user

00:05:15,039 --> 00:05:18,960
for instance in aws

00:05:16,880 --> 00:05:20,320
if that's upgraded it's privileges so in

00:05:18,960 --> 00:05:21,919
some for some reason

00:05:20,320 --> 00:05:23,280
it is now kind of an admin it can do

00:05:21,919 --> 00:05:25,120
from high level actions and cause a

00:05:23,280 --> 00:05:27,520
major impact

00:05:25,120 --> 00:05:28,479
how that user obtained those privileges

00:05:27,520 --> 00:05:31,199
could be of of

00:05:28,479 --> 00:05:33,120
huge kind of significance and if that

00:05:31,199 --> 00:05:34,880
that change is done by a

00:05:33,120 --> 00:05:36,639
cicd continuous integration continuous

00:05:34,880 --> 00:05:38,080
delivery user it could be that's

00:05:36,639 --> 00:05:39,280
completely benign that's the expected

00:05:38,080 --> 00:05:41,520
behavior in which case

00:05:39,280 --> 00:05:43,600
we're okay with that but the very same

00:05:41,520 --> 00:05:44,240
change made by an admin user that has no

00:05:43,600 --> 00:05:47,360
2fa

00:05:44,240 --> 00:05:49,120
potentially was like a gip enriched

00:05:47,360 --> 00:05:51,120
location there you could say this is

00:05:49,120 --> 00:05:52,720
entirely odd you know this is completely

00:05:51,120 --> 00:05:53,919
unexpected and in which case

00:05:52,720 --> 00:05:55,600
this is something that we should raise

00:05:53,919 --> 00:05:56,080
and we should pursue as an investigation

00:05:55,600 --> 00:05:59,039
so

00:05:56,080 --> 00:05:59,039
context is key

00:06:00,000 --> 00:06:04,240
and all of that kind of stuff considered

00:06:02,479 --> 00:06:06,639
and kind of acknowledged

00:06:04,240 --> 00:06:08,080
what we're facing now is is far more

00:06:06,639 --> 00:06:09,600
complicated than that in terms of things

00:06:08,080 --> 00:06:11,440
like the interconnectivity between these

00:06:09,600 --> 00:06:13,199
services you start dealing with

00:06:11,440 --> 00:06:14,479
tons of third-party services where your

00:06:13,199 --> 00:06:16,800
crown jewels as it were

00:06:14,479 --> 00:06:18,560
are no longer in in a single place in a

00:06:16,800 --> 00:06:20,319
data center you can kind of point to

00:06:18,560 --> 00:06:21,759
they're obviously hosted in a plethora

00:06:20,319 --> 00:06:22,880
of other services that we see there so

00:06:21,759 --> 00:06:25,039
be that cloud providers

00:06:22,880 --> 00:06:26,319
in the traditional kind of aws as your

00:06:25,039 --> 00:06:28,560
gcp kind of sense

00:06:26,319 --> 00:06:30,000
but that could also be um using like

00:06:28,560 --> 00:06:31,440
office 365 or slack for our

00:06:30,000 --> 00:06:33,280
communications et cetera and the trust

00:06:31,440 --> 00:06:34,960
boundary between those

00:06:33,280 --> 00:06:36,720
is obviously a major point for us to

00:06:34,960 --> 00:06:37,520
investigate and the visibility into

00:06:36,720 --> 00:06:39,280
those various

00:06:37,520 --> 00:06:40,960
um third-party services and the log

00:06:39,280 --> 00:06:42,479
sources they provide is going to be

00:06:40,960 --> 00:06:43,680
hugely important as we go forward so

00:06:42,479 --> 00:06:44,479
nick i know you've got a point on this

00:06:43,680 --> 00:06:46,160
one

00:06:44,479 --> 00:06:47,680
yes so we've had some recent experience

00:06:46,160 --> 00:06:48,240
with one client were working with for

00:06:47,680 --> 00:06:50,000
example

00:06:48,240 --> 00:06:50,960
where they had a primary cloud provider

00:06:50,000 --> 00:06:51,840
that they were hosting all their

00:06:50,960 --> 00:06:53,520
applications in

00:06:51,840 --> 00:06:55,520
but their source code was in github they

00:06:53,520 --> 00:06:56,400
were running jenkins for their ci cd

00:06:55,520 --> 00:06:59,520
they had

00:06:56,400 --> 00:07:00,880
uh what else g suite for their and their

00:06:59,520 --> 00:07:01,680
mail and their documents and all these

00:07:00,880 --> 00:07:03,840
kinds of things

00:07:01,680 --> 00:07:04,800
and so we had quite a variety of

00:07:03,840 --> 00:07:06,400
different um

00:07:04,800 --> 00:07:08,240
sort of infrastructure service platforms

00:07:06,400 --> 00:07:11,039
and service and software as a service

00:07:08,240 --> 00:07:12,639
and packages that were were in play that

00:07:11,039 --> 00:07:14,080
we were ingesting logs from and that we

00:07:12,639 --> 00:07:16,000
were able to use to

00:07:14,080 --> 00:07:17,759
track attacker activity platform to

00:07:16,000 --> 00:07:19,520
platform and you know that works out

00:07:17,759 --> 00:07:22,319
quite well but it did take a bit of

00:07:19,520 --> 00:07:25,520
effort to get all of that together

00:07:22,319 --> 00:07:27,120
yeah and so you know i think one of the

00:07:25,520 --> 00:07:29,440
the key things that we've learned

00:07:27,120 --> 00:07:31,360
is around um actually like how you

00:07:29,440 --> 00:07:34,720
design your cloud detection stack

00:07:31,360 --> 00:07:36,000
um so first off um centralizing

00:07:34,720 --> 00:07:37,680
everything is pretty important i

00:07:36,000 --> 00:07:38,319
wouldn't necessarily say we need to go

00:07:37,680 --> 00:07:40,080
for

00:07:38,319 --> 00:07:41,360
feeding all the data into one central

00:07:40,080 --> 00:07:42,880
location particularly

00:07:41,360 --> 00:07:45,280
but you need to make sure that it is

00:07:42,880 --> 00:07:48,240
easy for your analysts to take a look at

00:07:45,280 --> 00:07:50,479
one incidence in one thing and then

00:07:48,240 --> 00:07:52,319
pivot from that data point into

00:07:50,479 --> 00:07:54,400
other data sources in other applications

00:07:52,319 --> 00:07:55,520
cloud providers and whatever makes sense

00:07:54,400 --> 00:07:57,360
and you know one of the things we've

00:07:55,520 --> 00:07:59,360
noticed is that the harder it is for

00:07:57,360 --> 00:08:00,879
analysts to jump between

00:07:59,360 --> 00:08:03,199
data sources from different systems and

00:08:00,879 --> 00:08:05,280
environments uh the less likely they are

00:08:03,199 --> 00:08:06,720
to actively track down and investigate

00:08:05,280 --> 00:08:08,479
um some of these things to the degree

00:08:06,720 --> 00:08:09,840
that it needs to or it takes so long

00:08:08,479 --> 00:08:12,160
that they don't have the bandwidth to

00:08:09,840 --> 00:08:13,520
handle everything that's coming in so

00:08:12,160 --> 00:08:14,560
very important that that is right i

00:08:13,520 --> 00:08:17,440
think and that we

00:08:14,560 --> 00:08:17,919
support the analysts in generating uh or

00:08:17,440 --> 00:08:19,919
in

00:08:17,919 --> 00:08:22,319
developing their use cases right and

00:08:19,919 --> 00:08:24,479
having that sort of access

00:08:22,319 --> 00:08:25,680
and first up though and data sources

00:08:24,479 --> 00:08:27,280
before we start talking about where we

00:08:25,680 --> 00:08:28,879
put this data and there's a couple of

00:08:27,280 --> 00:08:29,680
key data sources i think that we need to

00:08:28,879 --> 00:08:32,159
dive in on

00:08:29,680 --> 00:08:34,000
and first off you've got the control

00:08:32,159 --> 00:08:35,919
plane audit logs and secondly the

00:08:34,000 --> 00:08:37,440
the service specific looks so by control

00:08:35,919 --> 00:08:40,320
plane audit logs what i mean there

00:08:37,440 --> 00:08:41,519
are cloud trail for aws audit log in

00:08:40,320 --> 00:08:45,200
azure terms and

00:08:41,519 --> 00:08:46,959
kubernetes um what these give you is

00:08:45,200 --> 00:08:48,959
visibility of all administrative actions

00:08:46,959 --> 00:08:50,000
taken within an environment any api call

00:08:48,959 --> 00:08:52,000
that's made

00:08:50,000 --> 00:08:53,519
gets logged there right so we can track

00:08:52,000 --> 00:08:54,480
creation modification deletion of

00:08:53,519 --> 00:08:56,880
resources

00:08:54,480 --> 00:08:58,320
and we can track access in some cases

00:08:56,880 --> 00:08:59,839
and we've got

00:08:58,320 --> 00:09:00,959
essentially all the visibility we could

00:08:59,839 --> 00:09:02,720
want of everything that's happening at

00:09:00,959 --> 00:09:04,000
the control plane layer coming out of

00:09:02,720 --> 00:09:05,519
that one data source

00:09:04,000 --> 00:09:06,959
so that really is critical if you only

00:09:05,519 --> 00:09:07,519
get one data source turned on in your

00:09:06,959 --> 00:09:10,160
environment

00:09:07,519 --> 00:09:11,920
that's the one to pick and then for

00:09:10,160 --> 00:09:14,320
service specific logs um

00:09:11,920 --> 00:09:15,440
essentially what these are are logs

00:09:14,320 --> 00:09:18,000
generated by

00:09:15,440 --> 00:09:21,279
your s3 buckets by your lambda functions

00:09:18,000 --> 00:09:22,800
by your kms key access

00:09:21,279 --> 00:09:24,399
cases where the the cloud native

00:09:22,800 --> 00:09:25,200
services the the past things you're

00:09:24,399 --> 00:09:27,600
using

00:09:25,200 --> 00:09:29,519
are generating their own logs and those

00:09:27,600 --> 00:09:32,240
those tend to be very high fidelity

00:09:29,519 --> 00:09:33,120
uh if you analyze them right they also

00:09:32,240 --> 00:09:36,160
tend to generate

00:09:33,120 --> 00:09:37,600
a lot of data and so typically we find

00:09:36,160 --> 00:09:39,279
clients benefit from turning these on on

00:09:37,600 --> 00:09:41,120
a case-by-case basis

00:09:39,279 --> 00:09:42,399
so you might have an s3 bucket that's

00:09:41,120 --> 00:09:43,920
full of really important information

00:09:42,399 --> 00:09:44,720
having access logs for that is probably

00:09:43,920 --> 00:09:46,240
worthwhile

00:09:44,720 --> 00:09:48,399
equally if you've got an s3 bucket set

00:09:46,240 --> 00:09:49,760
up to just serve our um

00:09:48,399 --> 00:09:51,200
static content for a website for

00:09:49,760 --> 00:09:53,279
instance you probably don't need the

00:09:51,200 --> 00:09:55,680
logs for that so much right so

00:09:53,279 --> 00:09:57,600
it's about turning these on case by case

00:09:55,680 --> 00:09:59,120
working out what you need them for

00:09:57,600 --> 00:10:00,640
and then enabling them accordingly

00:09:59,120 --> 00:10:05,839
rather than just blanket drowning your

00:10:00,640 --> 00:10:05,839
analysts in data from them i think

00:10:06,959 --> 00:10:11,360
yeah absolutely so when we're kind of

00:10:10,000 --> 00:10:12,399
well equipped we know what it is we

00:10:11,360 --> 00:10:14,399
should be logging we're going to

00:10:12,399 --> 00:10:16,000
know what the data sources are the

00:10:14,399 --> 00:10:17,519
question then comes in terms of

00:10:16,000 --> 00:10:19,040
what is it that we're looking for then

00:10:17,519 --> 00:10:20,240
and then that comes down to the threat

00:10:19,040 --> 00:10:21,200
intelligence problem when it comes to

00:10:20,240 --> 00:10:22,880
cloud so

00:10:21,200 --> 00:10:24,959
if we just look here left and right

00:10:22,880 --> 00:10:27,120
we've got the the mitre attack um

00:10:24,959 --> 00:10:28,000
matrix there and on the left you can see

00:10:27,120 --> 00:10:29,760
the on-premise

00:10:28,000 --> 00:10:31,680
version of that and on the right you can

00:10:29,760 --> 00:10:32,160
see um the cloud equivalent there and i

00:10:31,680 --> 00:10:34,560
think it's

00:10:32,160 --> 00:10:36,480
obvious um that the on-premise version

00:10:34,560 --> 00:10:38,079
is far more populated with with the

00:10:36,480 --> 00:10:40,399
techniques across the kill chain

00:10:38,079 --> 00:10:41,600
um than the cloud one is and i think

00:10:40,399 --> 00:10:43,120
there's obvious reasons for that the

00:10:41,600 --> 00:10:45,040
first of course is that the on-prem

00:10:43,120 --> 00:10:48,079
version has been around for much longer

00:10:45,040 --> 00:10:49,360
um but the way that this this matrix

00:10:48,079 --> 00:10:50,959
ultimately gets populated

00:10:49,360 --> 00:10:52,480
is through threatened so it through

00:10:50,959 --> 00:10:54,399
reports um

00:10:52,480 --> 00:10:55,760
findings there of malicious activity

00:10:54,399 --> 00:10:57,839
that have been found

00:10:55,760 --> 00:10:59,440
um and that's what ultimately it makes

00:10:57,839 --> 00:11:00,560
its way into this and that's how we know

00:10:59,440 --> 00:11:01,920
kind of what to look for so it's a

00:11:00,560 --> 00:11:03,360
little bit of a chicken and egg in terms

00:11:01,920 --> 00:11:04,640
of we need to know what to look for so

00:11:03,360 --> 00:11:05,600
we rely on attack for that kind of

00:11:04,640 --> 00:11:07,360
visibility

00:11:05,600 --> 00:11:09,440
but then attack itself relies on us

00:11:07,360 --> 00:11:11,680
providing those reports um to kind of

00:11:09,440 --> 00:11:14,240
fulfill it in terms of its potential

00:11:11,680 --> 00:11:17,120
so there's a lot there that you know we

00:11:14,240 --> 00:11:20,720
need to know what to look for right

00:11:17,120 --> 00:11:22,720
so what is an attacker likely to do well

00:11:20,720 --> 00:11:24,959
for us the most obvious place for us to

00:11:22,720 --> 00:11:26,959
kind of rely on to find that information

00:11:24,959 --> 00:11:29,120
is in the environments that we exploit

00:11:26,959 --> 00:11:31,200
as part of our consultancy work

00:11:29,120 --> 00:11:32,720
um and i think probably it's fair to say

00:11:31,200 --> 00:11:33,360
they can be distilled into one of these

00:11:32,720 --> 00:11:35,200
kind of four

00:11:33,360 --> 00:11:36,880
categories and the first is identity

00:11:35,200 --> 00:11:39,920
management or mismanagement

00:11:36,880 --> 00:11:41,440
um and using our ability to kind of

00:11:39,920 --> 00:11:42,640
exploit those misconfigurations that

00:11:41,440 --> 00:11:43,200
allow us to elevate privileges and

00:11:42,640 --> 00:11:45,200
ultimately

00:11:43,200 --> 00:11:46,399
take control of cloud environments the

00:11:45,200 --> 00:11:48,160
second is

00:11:46,399 --> 00:11:50,160
pivoting from other environments so that

00:11:48,160 --> 00:11:52,160
could be starting off on premise

00:11:50,160 --> 00:11:53,519
that could be through some other um kind

00:11:52,160 --> 00:11:55,200
of internet facing asset

00:11:53,519 --> 00:11:56,639
obtaining some level of access

00:11:55,200 --> 00:11:57,839
escalating to the point where we can put

00:11:56,639 --> 00:11:58,720
ourselves in the relevant groups

00:11:57,839 --> 00:11:59,600
potentially if there's some kind of

00:11:58,720 --> 00:12:01,279
single sign-on

00:11:59,600 --> 00:12:02,800
to ultimately arrive at the cloud

00:12:01,279 --> 00:12:03,839
environment with administrative

00:12:02,800 --> 00:12:06,240
privilege

00:12:03,839 --> 00:12:07,839
um the third is is source code

00:12:06,240 --> 00:12:09,279
management and continuous delivery

00:12:07,839 --> 00:12:10,399
which we'll cover up in a second and

00:12:09,279 --> 00:12:11,440
then the last is application

00:12:10,399 --> 00:12:12,720
vulnerabilities so

00:12:11,440 --> 00:12:13,839
we're going to take a little a little

00:12:12,720 --> 00:12:16,639
look into that that source code

00:12:13,839 --> 00:12:16,639
management one now

00:12:18,880 --> 00:12:22,240
so when we talk about source code

00:12:20,480 --> 00:12:23,600
management and continuous delivery here

00:12:22,240 --> 00:12:25,360
and really what we're talking about is

00:12:23,600 --> 00:12:26,959
an attacker targeting either the code

00:12:25,360 --> 00:12:28,079
repositories where your

00:12:26,959 --> 00:12:30,000
application code or your

00:12:28,079 --> 00:12:33,279
infrastructure's code is stored

00:12:30,000 --> 00:12:35,200
or the delivery pipelines um that

00:12:33,279 --> 00:12:36,800
take what's in those repositories and

00:12:35,200 --> 00:12:38,000
either build the relevant cloud

00:12:36,800 --> 00:12:39,440
resources or deploy

00:12:38,000 --> 00:12:41,200
the right application containers in the

00:12:39,440 --> 00:12:43,279
right places and

00:12:41,200 --> 00:12:44,800
in many respects this is sort of tier

00:12:43,279 --> 00:12:46,320
zero for your cloud security

00:12:44,800 --> 00:12:48,160
everyone always thinks about hardening

00:12:46,320 --> 00:12:50,000
down what's in the cloud and we've seen

00:12:48,160 --> 00:12:52,240
quite a few cases where

00:12:50,000 --> 00:12:53,600
people don't apply the same diligence to

00:12:52,240 --> 00:12:55,120
the supporting systems

00:12:53,600 --> 00:12:57,040
especially from a from a detection

00:12:55,120 --> 00:12:57,600
standpoint um you know being able to

00:12:57,040 --> 00:12:59,440
track

00:12:57,600 --> 00:13:01,120
who's doing what to your pipelines into

00:12:59,440 --> 00:13:02,480
your source code actually is pretty

00:13:01,120 --> 00:13:04,240
important now that these are

00:13:02,480 --> 00:13:06,079
core components of the security of your

00:13:04,240 --> 00:13:07,680
entire platform if an attacker

00:13:06,079 --> 00:13:08,720
compromises either the pipelines or the

00:13:07,680 --> 00:13:10,240
source code delivery

00:13:08,720 --> 00:13:12,000
they can take control of basically

00:13:10,240 --> 00:13:12,320
everything right yeah you know we can we

00:13:12,000 --> 00:13:14,560
can

00:13:12,320 --> 00:13:15,680
deploy pretty much anything we want into

00:13:14,560 --> 00:13:18,160
the cloud from there

00:13:15,680 --> 00:13:19,920
and especially when we often find that

00:13:18,160 --> 00:13:21,440
the roles that those pipelines are

00:13:19,920 --> 00:13:23,760
running as the access they have

00:13:21,440 --> 00:13:25,040
um is very privileged perhaps often more

00:13:23,760 --> 00:13:27,200
so than it needs to be

00:13:25,040 --> 00:13:28,880
so i think that's quite a key thing to

00:13:27,200 --> 00:13:30,560
factor in really um it's one that we

00:13:28,880 --> 00:13:32,240
we exploit regularly ourselves on

00:13:30,560 --> 00:13:33,519
consultancy engagements

00:13:32,240 --> 00:13:34,880
and i think it's a matter of time before

00:13:33,519 --> 00:13:37,440
we start hearing about attackers doing

00:13:34,880 --> 00:13:40,000
that um you know if we're not already

00:13:37,440 --> 00:13:40,800
so we've covered off then the telemetry

00:13:40,000 --> 00:13:41,920
sources so

00:13:40,800 --> 00:13:43,839
you know what are we going to use for

00:13:41,920 --> 00:13:45,680
our detections and we're taking a look

00:13:43,839 --> 00:13:47,519
at some of the attacks that we've seen

00:13:45,680 --> 00:13:49,120
um over there kind of kind of four key

00:13:47,519 --> 00:13:50,639
areas there so

00:13:49,120 --> 00:13:52,480
how do we start then how do we action

00:13:50,639 --> 00:13:54,720
this how do we build the effective

00:13:52,480 --> 00:13:56,320
attack detection and i think the the

00:13:54,720 --> 00:13:57,360
methodology that we've employed over the

00:13:56,320 --> 00:13:59,360
past year

00:13:57,360 --> 00:14:00,639
um is kind of summed up with this model

00:13:59,360 --> 00:14:00,959
here so the first thing that we're gonna

00:14:00,639 --> 00:14:02,560
do

00:14:00,959 --> 00:14:04,160
is threat model the environment

00:14:02,560 --> 00:14:05,680
understand

00:14:04,160 --> 00:14:07,440
which could be targeted what would the

00:14:05,680 --> 00:14:09,519
attack paths look like hypothetic

00:14:07,440 --> 00:14:10,480
hypothetically going from initial

00:14:09,519 --> 00:14:11,839
compromise

00:14:10,480 --> 00:14:13,600
right through to achieving some

00:14:11,839 --> 00:14:16,160
objective and what that objective is is

00:14:13,600 --> 00:14:17,120
again defined by the the specifics of

00:14:16,160 --> 00:14:18,480
your environment

00:14:17,120 --> 00:14:20,160
if you're hosting some some sensitive

00:14:18,480 --> 00:14:20,880
data there then likely is that that's

00:14:20,160 --> 00:14:22,480
going to be

00:14:20,880 --> 00:14:24,320
um the objective for those attack paths

00:14:22,480 --> 00:14:26,160
that's going to be the end goal

00:14:24,320 --> 00:14:27,360
so once you've defined what those attack

00:14:26,160 --> 00:14:28,399
paths could look like we need to

00:14:27,360 --> 00:14:29,920
prioritize we'd

00:14:28,399 --> 00:14:31,760
say which of these have the highest

00:14:29,920 --> 00:14:33,279
impact which of them potentially

00:14:31,760 --> 00:14:34,639
is going to get the the attacker from a

00:14:33,279 --> 00:14:35,600
to b in the most expedient way if

00:14:34,639 --> 00:14:37,760
there's an obvious part

00:14:35,600 --> 00:14:38,880
and obvious exposure and then that's the

00:14:37,760 --> 00:14:40,560
kind of path that we need to be paying

00:14:38,880 --> 00:14:42,720
most attention to

00:14:40,560 --> 00:14:44,880
and then we need to understand the like

00:14:42,720 --> 00:14:46,720
atomic attacker actions that comprise

00:14:44,880 --> 00:14:48,480
those those end-to-end attacks so the

00:14:46,720 --> 00:14:49,519
ttps the tactics the techniques the

00:14:48,480 --> 00:14:51,199
procedures

00:14:49,519 --> 00:14:54,320
what is an attacker going to do step by

00:14:51,199 --> 00:14:55,839
step to achieve this objective

00:14:54,320 --> 00:14:57,360
and then the most obvious step is

00:14:55,839 --> 00:14:59,760
verifying that us

00:14:57,360 --> 00:15:01,760
as defenders have the telemetry we need

00:14:59,760 --> 00:15:03,199
um to spot those things so if we have a

00:15:01,760 --> 00:15:04,959
given attack type

00:15:03,199 --> 00:15:06,000
against a given service we can take a

00:15:04,959 --> 00:15:07,360
look at that and say do we have the

00:15:06,000 --> 00:15:09,440
service specific logs

00:15:07,360 --> 00:15:10,800
do we have the cloud travel api commands

00:15:09,440 --> 00:15:12,000
that relate to that

00:15:10,800 --> 00:15:13,839
and in which case we're probably in a

00:15:12,000 --> 00:15:15,279
good place to start step five which is

00:15:13,839 --> 00:15:16,160
actually executing those attacker

00:15:15,279 --> 00:15:18,480
actions

00:15:16,160 --> 00:15:20,079
and understand end to end if we have the

00:15:18,480 --> 00:15:21,680
detection cases that work

00:15:20,079 --> 00:15:23,360
or even as like a step zero

00:15:21,680 --> 00:15:25,120
understanding what they might look like

00:15:23,360 --> 00:15:26,720
so we can say okay this is the specific

00:15:25,120 --> 00:15:28,000
api events um

00:15:26,720 --> 00:15:29,600
that we can look for we can start

00:15:28,000 --> 00:15:30,160
building detections and fine-tuning

00:15:29,600 --> 00:15:31,920
those

00:15:30,160 --> 00:15:35,600
um to ultimately detect them should we

00:15:31,920 --> 00:15:35,600
replay those attacks at a later date

00:15:36,480 --> 00:15:40,959
so i think one of the key messages that

00:15:38,399 --> 00:15:42,079
we've learned and working with

00:15:40,959 --> 00:15:43,839
a combination of this sort of the

00:15:42,079 --> 00:15:44,959
operational teams in some of these uh

00:15:43,839 --> 00:15:46,880
these environments

00:15:44,959 --> 00:15:48,720
but also from the perspective of

00:15:46,880 --> 00:15:50,959
detection one of the

00:15:48,720 --> 00:15:52,480
most powerful things you can do as a

00:15:50,959 --> 00:15:53,920
detection team in general not

00:15:52,480 --> 00:15:56,079
just in the cloud but especially in the

00:15:53,920 --> 00:15:57,199
cloud space and is move towards

00:15:56,079 --> 00:16:00,639
detection as code

00:15:57,199 --> 00:16:02,800
basically and define your detections

00:16:00,639 --> 00:16:04,480
in a machine readable format something

00:16:02,800 --> 00:16:06,959
that you can easily version control

00:16:04,480 --> 00:16:08,000
and that you can update over time and it

00:16:06,959 --> 00:16:09,600
provides an easy mean

00:16:08,000 --> 00:16:11,279
to share knowledge within the team if

00:16:09,600 --> 00:16:11,839
it's a common format that everyone can

00:16:11,279 --> 00:16:13,920
read

00:16:11,839 --> 00:16:15,440
and then rather than just talking about

00:16:13,920 --> 00:16:17,199
particular attacker activity at a higher

00:16:15,440 --> 00:16:17,759
level and how it works and explain these

00:16:17,199 --> 00:16:19,440
things

00:16:17,759 --> 00:16:20,959
and to your more junior analysts they

00:16:19,440 --> 00:16:22,000
can go in and read the detections and

00:16:20,959 --> 00:16:23,680
really understand

00:16:22,000 --> 00:16:24,880
um you know exactly what this this

00:16:23,680 --> 00:16:25,519
particular technique's going to do under

00:16:24,880 --> 00:16:27,279
the hood

00:16:25,519 --> 00:16:29,519
and we've seen a few key projects in the

00:16:27,279 --> 00:16:32,720
open source space around that um already

00:16:29,519 --> 00:16:34,639
and not least sigma and which is an

00:16:32,720 --> 00:16:37,199
agnostic set of rules and that you can

00:16:34,639 --> 00:16:39,440
compile down then to splunk or queue

00:16:37,199 --> 00:16:41,440
whilst you're running um we've also seen

00:16:39,440 --> 00:16:42,240
some interesting efforts with um jupiter

00:16:41,440 --> 00:16:45,440
notebooks

00:16:42,240 --> 00:16:47,199
um to build out a set of playbooks that

00:16:45,440 --> 00:16:48,639
you can run to hunt for specific

00:16:47,199 --> 00:16:51,040
attacker activity

00:16:48,639 --> 00:16:52,880
um so we took all of this and over the

00:16:51,040 --> 00:16:53,440
course of the last year or so we've been

00:16:52,880 --> 00:16:55,440
working

00:16:53,440 --> 00:16:57,040
on um moving a lot of this stuff into

00:16:55,440 --> 00:16:59,600
the cloud at which point

00:16:57,040 --> 00:17:01,680
we ended up with leonidas which is an

00:16:59,600 --> 00:17:04,400
open source tool we've we've released

00:17:01,680 --> 00:17:06,559
um so essentially the idea with leonidas

00:17:04,400 --> 00:17:07,520
is that you have your security team your

00:17:06,559 --> 00:17:09,120
analysts the

00:17:07,520 --> 00:17:11,120
purple team as red teamers who are

00:17:09,120 --> 00:17:13,839
executing these test cases as well

00:17:11,120 --> 00:17:15,520
and and they define themselves a new ttp

00:17:13,839 --> 00:17:16,400
that's committed into a into a

00:17:15,520 --> 00:17:18,640
repository

00:17:16,400 --> 00:17:20,160
and we then have a cicd pipeline that

00:17:18,640 --> 00:17:20,720
actually builds out a serverless

00:17:20,160 --> 00:17:24,240
function

00:17:20,720 --> 00:17:26,400
based on those um definitions uh we then

00:17:24,240 --> 00:17:28,079
expose that serverless function to the

00:17:26,400 --> 00:17:29,919
purple team and they can use that to

00:17:28,079 --> 00:17:30,640
execute attacks so you make a single web

00:17:29,919 --> 00:17:32,559
request

00:17:30,640 --> 00:17:33,760
and to execute a particular attack at

00:17:32,559 --> 00:17:35,440
ttp

00:17:33,760 --> 00:17:37,200
um that's executed against whatever

00:17:35,440 --> 00:17:39,360
target resources you've got set up

00:17:37,200 --> 00:17:40,880
and we then feed those logs uh straight

00:17:39,360 --> 00:17:42,320
into the the scene

00:17:40,880 --> 00:17:44,960
and you can then have your analysts hunt

00:17:42,320 --> 00:17:49,039
for the activity that we just executed

00:17:44,960 --> 00:17:49,039
and by this api that we've exposed

00:17:49,280 --> 00:17:52,559
so i think one of the most critical

00:17:51,120 --> 00:17:54,080
things to it is that um

00:17:52,559 --> 00:17:55,440
it's a fairly easy format to work with

00:17:54,080 --> 00:17:55,919
the definitions are quite short and

00:17:55,440 --> 00:17:58,400
sweet

00:17:55,919 --> 00:18:00,240
and the underlying framework takes care

00:17:58,400 --> 00:18:02,880
of basically everything about how the

00:18:00,240 --> 00:18:04,240
api itself functions um including how

00:18:02,880 --> 00:18:06,000
different identities within the cloud

00:18:04,240 --> 00:18:06,640
are handled you know for aws you can

00:18:06,000 --> 00:18:08,799
hand it

00:18:06,640 --> 00:18:11,840
roles to assume you can hand it um

00:18:08,799 --> 00:18:13,679
access keys and secret access key pairs

00:18:11,840 --> 00:18:16,000
and all the analyst has to do is write a

00:18:13,679 --> 00:18:17,360
single one or two of python to say

00:18:16,000 --> 00:18:19,039
essentially call this botox 3 function

00:18:17,360 --> 00:18:22,240
for aws or the azure apis

00:18:19,039 --> 00:18:25,440
for azure um and so we uh

00:18:22,240 --> 00:18:27,679
we then generate that into an api

00:18:25,440 --> 00:18:30,000
that runs inside that service function

00:18:27,679 --> 00:18:33,440
these definitions also then contain

00:18:30,000 --> 00:18:35,600
um detection cases so we write the

00:18:33,440 --> 00:18:36,960
sigma rules into the same place that we

00:18:35,600 --> 00:18:38,320
we write the detection

00:18:36,960 --> 00:18:40,559
so that you've got a single file that

00:18:38,320 --> 00:18:41,039
defines exactly how to execute the

00:18:40,559 --> 00:18:42,720
attack

00:18:41,039 --> 00:18:44,640
uh exactly how to detect it and that

00:18:42,720 --> 00:18:46,160
lives as a single source of truth for

00:18:44,640 --> 00:18:47,600
this attacker ttp that we

00:18:46,160 --> 00:18:49,280
we have here and we can take this

00:18:47,600 --> 00:18:51,039
definition and we can compile it down

00:18:49,280 --> 00:18:52,799
to to work with the same platform that

00:18:51,039 --> 00:18:54,720
we're using

00:18:52,799 --> 00:18:56,160
and we can also generate documentation

00:18:54,720 --> 00:18:57,600
off it so one of the really powerful

00:18:56,160 --> 00:18:59,600
things we've found with this is it's an

00:18:57,600 --> 00:19:01,600
opportunity to embed

00:18:59,600 --> 00:19:02,880
uh human contacts and notes about your

00:19:01,600 --> 00:19:04,080
organization's specific environments

00:19:02,880 --> 00:19:06,000
within your organization

00:19:04,080 --> 00:19:07,360
to say things like this probably is

00:19:06,000 --> 00:19:08,880
usually malicious but in the case of

00:19:07,360 --> 00:19:10,720
these two particular projects

00:19:08,880 --> 00:19:12,400
their aws accounts do this all the time

00:19:10,720 --> 00:19:13,840
for business reasons x y and z

00:19:12,400 --> 00:19:15,760
so therefore factor that in when you're

00:19:13,840 --> 00:19:17,440
triaging these events

00:19:15,760 --> 00:19:19,440
um and that's that's proven pretty

00:19:17,440 --> 00:19:22,960
useful too

00:19:19,440 --> 00:19:24,799
so um let's let's demo it so this is

00:19:22,960 --> 00:19:27,440
leonidas this is the

00:19:24,799 --> 00:19:28,960
web api that we expose that uh allows

00:19:27,440 --> 00:19:30,400
you to execute those test cases that

00:19:28,960 --> 00:19:33,679
i've just been talking about

00:19:30,400 --> 00:19:35,840
and this is built by a aws native ci cd

00:19:33,679 --> 00:19:37,679
pipeline for azure and gcp we're

00:19:35,840 --> 00:19:38,320
building out using their native tooling

00:19:37,679 --> 00:19:39,760
as well

00:19:38,320 --> 00:19:41,600
right now this is hosted in a lambda

00:19:39,760 --> 00:19:42,400
function with an api gateway in front of

00:19:41,600 --> 00:19:43,840
it

00:19:42,400 --> 00:19:45,520
and you can see here we've got a range

00:19:43,840 --> 00:19:46,160
of different test cases across the miter

00:19:45,520 --> 00:19:48,720
kill chain

00:19:46,160 --> 00:19:50,000
so let's dig into to one of them as an

00:19:48,720 --> 00:19:53,120
example

00:19:50,000 --> 00:19:55,120
perhaps we have some i am access and we

00:19:53,120 --> 00:19:55,760
have a user that we've created as a

00:19:55,120 --> 00:19:57,919
backdoor

00:19:55,760 --> 00:19:59,760
and so let's add a policy to to that

00:19:57,919 --> 00:20:00,400
user and you can see here not only can

00:19:59,760 --> 00:20:02,159
we pass in

00:20:00,400 --> 00:20:04,320
the user in the policy that we're trying

00:20:02,159 --> 00:20:06,880
to target here but also actually we can

00:20:04,320 --> 00:20:09,760
pass in a variety of identity based data

00:20:06,880 --> 00:20:10,159
to allow leonidas to execute the test

00:20:09,760 --> 00:20:12,880
case

00:20:10,159 --> 00:20:14,000
as something other than itself and it

00:20:12,880 --> 00:20:16,159
comes with an

00:20:14,000 --> 00:20:18,720
i am role and the permissions for that i

00:20:16,159 --> 00:20:21,840
am role are automatically generated

00:20:18,720 --> 00:20:23,200
by the build scripts but it's beneficial

00:20:21,840 --> 00:20:24,720
to be able to trigger test cases as a

00:20:23,200 --> 00:20:25,840
range of different identities so in the

00:20:24,720 --> 00:20:28,880
case of aws

00:20:25,840 --> 00:20:30,799
uh we can also pass in an arm that's

00:20:28,880 --> 00:20:31,919
for a role that we wish to assume or we

00:20:30,799 --> 00:20:34,320
can pass in an

00:20:31,919 --> 00:20:35,679
access key secret access key key pair we

00:20:34,320 --> 00:20:37,360
can also specify obviously the the

00:20:35,679 --> 00:20:39,520
region that we're trying to target

00:20:37,360 --> 00:20:40,640
now this interface is quite nice for

00:20:39,520 --> 00:20:43,039
exploring the api

00:20:40,640 --> 00:20:44,480
but for security reasons in order to

00:20:43,039 --> 00:20:46,240
trigger any of these test cases you need

00:20:44,480 --> 00:20:49,520
to supply an api parameter

00:20:46,240 --> 00:20:51,840
api key parameter sorry alongside it

00:20:49,520 --> 00:20:52,640
um in order to to get that executing

00:20:51,840 --> 00:20:55,520
properly

00:20:52,640 --> 00:20:56,480
so you can either use leo which is a

00:20:55,520 --> 00:20:58,799
command line

00:20:56,480 --> 00:21:01,200
tool that runs uh encapsulates these

00:20:58,799 --> 00:21:03,360
apis you run it locally and it speaks to

00:21:01,200 --> 00:21:04,640
the leonidas api but actually we've had

00:21:03,360 --> 00:21:07,280
quite a lot of success

00:21:04,640 --> 00:21:08,320
uh working with jupiter so jupiter for

00:21:07,280 --> 00:21:11,120
those who aren't familiar

00:21:08,320 --> 00:21:11,440
is uh essentially a web-based interface

00:21:11,120 --> 00:21:13,760
to

00:21:11,440 --> 00:21:15,280
a python interpreter and that allows you

00:21:13,760 --> 00:21:18,480
to embed code in and long

00:21:15,280 --> 00:21:20,000
documents document content and generate

00:21:18,480 --> 00:21:21,360
graphs and tables and all of these kinds

00:21:20,000 --> 00:21:22,720
of things it's a pretty popular data

00:21:21,360 --> 00:21:23,919
science tool but we've also found it

00:21:22,720 --> 00:21:25,360
very effective

00:21:23,919 --> 00:21:27,600
in the detection and purple teaming

00:21:25,360 --> 00:21:29,919
space so here what we're doing

00:21:27,600 --> 00:21:31,600
is uh you know we've got this leonidas

00:21:29,919 --> 00:21:32,880
api endpoint it's the same one we were

00:21:31,600 --> 00:21:35,840
looking at previously

00:21:32,880 --> 00:21:37,120
um and so we're going to load in the set

00:21:35,840 --> 00:21:39,440
of test cases

00:21:37,120 --> 00:21:41,039
from this case config and the leonidas

00:21:39,440 --> 00:21:42,480
framework will also generate this this

00:21:41,039 --> 00:21:43,520
yaml file for you that defines all the

00:21:42,480 --> 00:21:45,039
test cases

00:21:43,520 --> 00:21:47,440
but you can see here we've got all the

00:21:45,039 --> 00:21:49,760
test cases then loaded in

00:21:47,440 --> 00:21:50,720
into this jupyter notebook and so for

00:21:49,760 --> 00:21:53,840
instance

00:21:50,720 --> 00:21:55,840
we were looking at the

00:21:53,840 --> 00:21:58,320
adding policy to a user one before you

00:21:55,840 --> 00:21:59,840
can see that here row number 35 and so

00:21:58,320 --> 00:22:01,280
we'll make use of that in a bit but then

00:21:59,840 --> 00:22:01,840
to start actually triggering some test

00:22:01,280 --> 00:22:03,520
cases

00:22:01,840 --> 00:22:05,520
uh you can see here we're calling run

00:22:03,520 --> 00:22:05,840
case as a simple wrapper function around

00:22:05,520 --> 00:22:08,880
that

00:22:05,840 --> 00:22:10,240
um that http api

00:22:08,880 --> 00:22:12,080
and we're going to call get caller

00:22:10,240 --> 00:22:14,080
identity which you run

00:22:12,080 --> 00:22:15,919
to tell you who you are what the

00:22:14,080 --> 00:22:16,880
identity of the the current user or

00:22:15,919 --> 00:22:18,960
entity is

00:22:16,880 --> 00:22:19,919
and so here you can see um leonidas has

00:22:18,960 --> 00:22:22,080
assumed a role

00:22:19,919 --> 00:22:24,159
um it's this leonardo's devop role and

00:22:22,080 --> 00:22:25,600
so that's the the default i am role that

00:22:24,159 --> 00:22:27,200
the lambda function has assigned to it

00:22:25,600 --> 00:22:28,320
when it executes to allow it to interact

00:22:27,200 --> 00:22:32,000
with the aws

00:22:28,320 --> 00:22:32,960
apis themselves so let's assume now that

00:22:32,000 --> 00:22:36,559
we are an attacker

00:22:32,960 --> 00:22:38,000
we have a vulnerability in this lambda

00:22:36,559 --> 00:22:39,679
function that has allowed us to gain

00:22:38,000 --> 00:22:41,600
some sort of code execution or command

00:22:39,679 --> 00:22:42,880
injection or something and so we're now

00:22:41,600 --> 00:22:45,200
um

00:22:42,880 --> 00:22:47,919
executing these uh attacker actions

00:22:45,200 --> 00:22:51,200
against the underlying aws account

00:22:47,919 --> 00:22:52,559
so first off let's uh enumerate these

00:22:51,200 --> 00:22:54,720
guard duty detectors that might be

00:22:52,559 --> 00:22:56,080
listening to us and so in this case we

00:22:54,720 --> 00:22:58,720
can see guard duty

00:22:56,080 --> 00:22:59,280
uh is running we've got detector id here

00:22:58,720 --> 00:23:00,880
so

00:22:59,280 --> 00:23:02,400
if we try and do anything too obvious

00:23:00,880 --> 00:23:04,320
guard duty might spot us

00:23:02,400 --> 00:23:05,679
um but also let's take a look at whether

00:23:04,320 --> 00:23:06,880
they've got any cloud trails in the

00:23:05,679 --> 00:23:08,960
current region

00:23:06,880 --> 00:23:10,480
so here we can see we've actually got

00:23:08,960 --> 00:23:11,280
two cloud trails listening to us if

00:23:10,480 --> 00:23:12,559
their

00:23:11,280 --> 00:23:14,080
defenders are paying attention we

00:23:12,559 --> 00:23:15,440
probably will get spotted but we're

00:23:14,080 --> 00:23:17,200
going to carry on anyway

00:23:15,440 --> 00:23:19,440
and what we're going to try and do now

00:23:17,200 --> 00:23:22,640
is add an iron user

00:23:19,440 --> 00:23:24,240
the leonardis function i am role comes

00:23:22,640 --> 00:23:25,280
with a certain set permissions defined

00:23:24,240 --> 00:23:27,360
in the test cases

00:23:25,280 --> 00:23:28,480
to allow it to always execute these

00:23:27,360 --> 00:23:30,799
these particular

00:23:28,480 --> 00:23:32,320
test cases that it's built with so we

00:23:30,799 --> 00:23:33,360
know this is going to succeed

00:23:32,320 --> 00:23:34,720
obviously if you've got permissions

00:23:33,360 --> 00:23:36,320
boundaries or other things configured it

00:23:34,720 --> 00:23:37,679
might not but for the sake of this

00:23:36,320 --> 00:23:39,679
exercise um you know we're going to

00:23:37,679 --> 00:23:42,159
create a new user um

00:23:39,679 --> 00:23:43,520
so we've got this new user created um we

00:23:42,159 --> 00:23:46,159
passed in here into

00:23:43,520 --> 00:23:47,919
uh into that api call and we're now

00:23:46,159 --> 00:23:49,360
going to add an api key to that user to

00:23:47,919 --> 00:23:52,159
make sure that we can

00:23:49,360 --> 00:23:53,360
interact with aws as that user for good

00:23:52,159 --> 00:23:55,120
measure we're also going to add on the

00:23:53,360 --> 00:23:56,559
administrator access managed policy

00:23:55,120 --> 00:23:57,840
obviously pretty bad practice but it

00:23:56,559 --> 00:23:58,480
makes the rest of the demo work quite

00:23:57,840 --> 00:24:00,480
nicely

00:23:58,480 --> 00:24:02,000
so we've now done that and what we can

00:24:00,480 --> 00:24:03,760
now start doing is

00:24:02,000 --> 00:24:05,600
running other test cases using those

00:24:03,760 --> 00:24:07,600
access keys that we generated previously

00:24:05,600 --> 00:24:09,360
that are in our jupyter notebook

00:24:07,600 --> 00:24:11,039
so i'm going to rerun that get caller

00:24:09,360 --> 00:24:12,799
identity test case but you can see now

00:24:11,039 --> 00:24:14,320
we're actually passing in this

00:24:12,799 --> 00:24:17,039
set of credentials that we've defined

00:24:14,320 --> 00:24:19,200
here and so if we run that now you'll

00:24:17,039 --> 00:24:22,240
see that when we come back

00:24:19,200 --> 00:24:24,799
from the caller identity call we're now

00:24:22,240 --> 00:24:26,400
running as a user account in fact the

00:24:24,799 --> 00:24:29,039
user account we just created

00:24:26,400 --> 00:24:31,200
and so we've changed the entity that

00:24:29,039 --> 00:24:33,600
we're executing these test cases as

00:24:31,200 --> 00:24:34,320
and this allows us to simulate a variety

00:24:33,600 --> 00:24:36,080
of different

00:24:34,320 --> 00:24:37,679
sort of attackers start points and

00:24:36,080 --> 00:24:39,039
assume different types of breaches these

00:24:37,679 --> 00:24:42,240
kinds of things

00:24:39,039 --> 00:24:44,320
so then what we can do from here we can

00:24:42,240 --> 00:24:45,679
list the secrets in secrets manager um

00:24:44,320 --> 00:24:46,720
you know we're now an attacker who's

00:24:45,679 --> 00:24:49,760
poking around

00:24:46,720 --> 00:24:52,480
uh trying to find uh secret data or

00:24:49,760 --> 00:24:54,080
steal further uh access keys credentials

00:24:52,480 --> 00:24:56,960
to get further into the environment

00:24:54,080 --> 00:24:58,480
um and it turns out we've got a secret

00:24:56,960 --> 00:24:59,520
it's called leonardo's created secrets

00:24:58,480 --> 00:25:02,400
so what we're going to do

00:24:59,520 --> 00:25:03,840
is uh grab the contents of that with

00:25:02,400 --> 00:25:05,600
another leonardo's test case

00:25:03,840 --> 00:25:08,080
and you can see here we've got some some

00:25:05,600 --> 00:25:10,480
secret data coming back from the

00:25:08,080 --> 00:25:12,320
aws apis there so what we've done is

00:25:10,480 --> 00:25:13,919
we've executed an entire kill chain

00:25:12,320 --> 00:25:15,600
and we've simulated an application

00:25:13,919 --> 00:25:16,640
vulnerability inside the lambda function

00:25:15,600 --> 00:25:18,960
as a start point

00:25:16,640 --> 00:25:19,679
we've done some enumeration to see who

00:25:18,960 --> 00:25:21,919
we are

00:25:19,679 --> 00:25:22,880
what uh defenses are likely to be

00:25:21,919 --> 00:25:25,360
watching for us

00:25:22,880 --> 00:25:27,600
um we've created a persistence mechanism

00:25:25,360 --> 00:25:28,000
by creating an ion user adding an api

00:25:27,600 --> 00:25:31,039
key to

00:25:28,000 --> 00:25:32,960
it adding some iron permissions to that

00:25:31,039 --> 00:25:34,720
user that we just created and then we've

00:25:32,960 --> 00:25:36,159
used that new user to enumerate the

00:25:34,720 --> 00:25:37,840
contents of secrets manager

00:25:36,159 --> 00:25:40,000
and dump some secrets out and we've done

00:25:37,840 --> 00:25:42,000
all of that in a programmatic fashion

00:25:40,000 --> 00:25:43,520
and in a way that doesn't rely on the

00:25:42,000 --> 00:25:45,360
analysts having an underlying

00:25:43,520 --> 00:25:47,360
understanding of what these test cases

00:25:45,360 --> 00:25:48,960
are how the aws apis work

00:25:47,360 --> 00:25:51,520
and we're simply triggering the test

00:25:48,960 --> 00:25:57,440
cases and the individual ttps one by one

00:25:51,520 --> 00:25:59,840
as part of this larger kill chain

00:25:57,440 --> 00:26:00,880
now one of the benefits to leonidas is

00:25:59,840 --> 00:26:02,320
not only do we

00:26:00,880 --> 00:26:04,480
have the ability to trigger these test

00:26:02,320 --> 00:26:05,440
cases automatically it also generates

00:26:04,480 --> 00:26:06,960
its own logs

00:26:05,440 --> 00:26:08,400
so you can compare and contrast them

00:26:06,960 --> 00:26:10,240
with what you're seeing in your scene

00:26:08,400 --> 00:26:12,080
and what alerts you've got firing

00:26:10,240 --> 00:26:13,919
so let's jump into the the latest set of

00:26:12,080 --> 00:26:17,200
logs here

00:26:13,919 --> 00:26:17,919
and so what we'll find is yeah looking

00:26:17,200 --> 00:26:19,679
at the top

00:26:17,919 --> 00:26:22,000
you can see we've got an sts get caller

00:26:19,679 --> 00:26:22,880
identity call followed by lisgaard duty

00:26:22,000 --> 00:26:24,400
detectors

00:26:22,880 --> 00:26:26,720
enumerate cloud trails for a given

00:26:24,400 --> 00:26:29,120
region these are are all the test cases

00:26:26,720 --> 00:26:30,960
and you can see here that the arguments

00:26:29,120 --> 00:26:31,760
we're passing in are also represented so

00:26:30,960 --> 00:26:33,679
we can track

00:26:31,760 --> 00:26:35,760
uh exactly how the test cases were

00:26:33,679 --> 00:26:37,679
executed what parameters were passed in

00:26:35,760 --> 00:26:39,200
and if we go down to where we then run

00:26:37,679 --> 00:26:41,840
the second caller identity

00:26:39,200 --> 00:26:42,640
you can see also that the access key id

00:26:41,840 --> 00:26:45,440
that we passed in

00:26:42,640 --> 00:26:46,720
is recorded and we have that on record

00:26:45,440 --> 00:26:49,039
so that we can understand

00:26:46,720 --> 00:26:49,840
what uh entity these these test cases

00:26:49,039 --> 00:26:52,240
will run as

00:26:49,840 --> 00:26:54,080
we can feed all this data into a

00:26:52,240 --> 00:26:56,000
centralized logging platform or leave it

00:26:54,080 --> 00:26:57,919
in cloudwatch in fact if you prefer

00:26:56,000 --> 00:26:59,120
but we can diff this then against what

00:26:57,919 --> 00:27:00,400
we're seeing in the scene

00:26:59,120 --> 00:27:02,320
and it allows us to get a better

00:27:00,400 --> 00:27:04,320
understanding of whether our test cases

00:27:02,320 --> 00:27:06,159
worked or not

00:27:04,320 --> 00:27:08,080
and we have those logs there for

00:27:06,159 --> 00:27:09,600
posterity uh it doesn't require the

00:27:08,080 --> 00:27:10,799
analysts to take detailed notes as they

00:27:09,600 --> 00:27:14,159
go because everything they do is

00:27:10,799 --> 00:27:14,159
recorded automatically for you

00:27:14,799 --> 00:27:18,960
okay so one of the other really powerful

00:27:17,120 --> 00:27:20,399
things then is off the back of that

00:27:18,960 --> 00:27:22,399
we've got leonidas running we can

00:27:20,399 --> 00:27:23,760
execute these test cases we can look at

00:27:22,399 --> 00:27:25,440
the logs in our scene

00:27:23,760 --> 00:27:28,000
but actually leonidas itself also

00:27:25,440 --> 00:27:30,159
produces his own set of logs as to

00:27:28,000 --> 00:27:31,760
what attacker actions were executed and

00:27:30,159 --> 00:27:33,440
you know what parameters what context

00:27:31,760 --> 00:27:35,200
what resources they targeted

00:27:33,440 --> 00:27:36,880
and we can actually feed all of that

00:27:35,200 --> 00:27:37,919
somewhere as well into your scene or to

00:27:36,880 --> 00:27:40,240
another platform

00:27:37,919 --> 00:27:42,000
and we can then essentially diff the use

00:27:40,240 --> 00:27:43,360
cases that were triggered in leonidas

00:27:42,000 --> 00:27:45,120
against the

00:27:43,360 --> 00:27:46,480
events in the scene and we can see

00:27:45,120 --> 00:27:47,440
whether the detections that we were

00:27:46,480 --> 00:27:49,679
expecting to

00:27:47,440 --> 00:27:51,360
trigger and you know either as alerts or

00:27:49,679 --> 00:27:53,440
as tags or whatever else

00:27:51,360 --> 00:27:55,039
whether those happen in the correct way

00:27:53,440 --> 00:27:55,760
and that means that over time actually

00:27:55,039 --> 00:27:57,760
we can

00:27:55,760 --> 00:27:59,200
regression test improvements to our

00:27:57,760 --> 00:28:02,480
detective capability right

00:27:59,200 --> 00:28:05,039
we can add additional test cases

00:28:02,480 --> 00:28:05,840
uh additional use cases even we can then

00:28:05,039 --> 00:28:07,360
verify

00:28:05,840 --> 00:28:09,760
that doing so hasn't broken any others

00:28:07,360 --> 00:28:11,440
we can update uh test cases to

00:28:09,760 --> 00:28:13,039
to match new changes by the cloud

00:28:11,440 --> 00:28:14,960
providers catch additional things

00:28:13,039 --> 00:28:16,559
uh we can verify that we've not backslid

00:28:14,960 --> 00:28:18,159
in the process and actually that means

00:28:16,559 --> 00:28:20,159
then we can iterate much faster because

00:28:18,159 --> 00:28:23,279
we're confident in our ability to

00:28:20,159 --> 00:28:23,279
catch mistakes as we go

00:28:25,440 --> 00:28:30,399
yeah absolutely so conclusions then

00:28:28,480 --> 00:28:31,520
well it might sound corny but i guess

00:28:30,399 --> 00:28:33,360
the ultimate thing here is that

00:28:31,520 --> 00:28:34,799
detection is a journey right so

00:28:33,360 --> 00:28:36,720
your cloud environments are changing all

00:28:34,799 --> 00:28:38,000
the time and that could be because

00:28:36,720 --> 00:28:39,200
you're implementing new features you're

00:28:38,000 --> 00:28:41,120
changing the way you do that you're

00:28:39,200 --> 00:28:43,200
changing the services that you utilize

00:28:41,120 --> 00:28:44,559
so ultimately your detection has to

00:28:43,200 --> 00:28:47,360
change with it

00:28:44,559 --> 00:28:48,880
um we can also think about context think

00:28:47,360 --> 00:28:50,799
about how important that is

00:28:48,880 --> 00:28:52,320
and not only is that case of you know it

00:28:50,799 --> 00:28:54,320
might seem as though that's an issue for

00:28:52,320 --> 00:28:56,000
you that's that's to your disadvantage

00:28:54,320 --> 00:28:57,600
you can actually use that to make more

00:28:56,000 --> 00:28:59,360
effective detections if you know

00:28:57,600 --> 00:29:01,919
the behaviors of your environment inside

00:28:59,360 --> 00:29:03,200
out any deviation from that could build

00:29:01,919 --> 00:29:05,600
a high fidelity alert

00:29:03,200 --> 00:29:06,799
so you can use that to your advantage um

00:29:05,600 --> 00:29:08,960
and then lastly

00:29:06,799 --> 00:29:10,480
as we kind of discussed here that threat

00:29:08,960 --> 00:29:12,720
intelligence problem not knowing what

00:29:10,480 --> 00:29:14,640
bad looks like what we should hunt for

00:29:12,720 --> 00:29:16,720
the ability to codify and ultimately

00:29:14,640 --> 00:29:18,000
share the use cases that you build

00:29:16,720 --> 00:29:19,919
is going to aid knowledge sharing and

00:29:18,000 --> 00:29:22,399
ultimately help all of us to to build

00:29:19,919 --> 00:29:23,919
more effective crowd detection really

00:29:22,399 --> 00:29:25,440
and then we talked about that threat

00:29:23,919 --> 00:29:27,039
modelling process going end-to-end

00:29:25,440 --> 00:29:28,480
identifying attack paths

00:29:27,039 --> 00:29:30,399
identifying potential needs for new

00:29:28,480 --> 00:29:31,919
telemetry or to kind of decommission

00:29:30,399 --> 00:29:33,600
something we're not using anymore

00:29:31,919 --> 00:29:35,200
that constant cycle is something we can

00:29:33,600 --> 00:29:36,960
use to make sure that we're always

00:29:35,200 --> 00:29:41,840
kind of the most equipped we can be to

00:29:36,960 --> 00:29:41,840
detect malicious activity in the cloud

00:29:42,720 --> 00:29:46,640
and then lastly um you know please do a

00:29:45,440 --> 00:29:48,080
go with leonidas let me know what you

00:29:46,640 --> 00:29:48,640
think of it and it's available up on

00:29:48,080 --> 00:29:51,840
github

00:29:48,640 --> 00:29:53,279
f-secure labs slash leonidas we

00:29:51,840 --> 00:29:55,200
currently support aws

00:29:53,279 --> 00:29:56,720
azure and gcp are actually pretty close

00:29:55,200 --> 00:29:57,440
to being done we're getting pretty far

00:29:56,720 --> 00:29:59,440
with that now

00:29:57,440 --> 00:30:00,960
um at the moment we've got 45 test cases

00:29:59,440 --> 00:30:02,480
for aws you know you saw some of the

00:30:00,960 --> 00:30:03,120
demo earlier there's quite a few others

00:30:02,480 --> 00:30:05,279
too

00:30:03,120 --> 00:30:06,240
um go play with it see what you think

00:30:05,279 --> 00:30:08,559
and let me know

00:30:06,240 --> 00:30:09,600
uh you know equally those test cases are

00:30:08,559 --> 00:30:10,559
up there because they've what we've

00:30:09,600 --> 00:30:12,240
needed so far

00:30:10,559 --> 00:30:13,840
but actually um they're pretty easy to

00:30:12,240 --> 00:30:16,080
write so please do contribute your own

00:30:13,840 --> 00:30:18,399
pull requests more than welcome

00:30:16,080 --> 00:30:21,200
awesome yeah and that's it from us thank

00:30:18,399 --> 00:30:21,200

YouTube URL: https://www.youtube.com/watch?v=XkLXO4o2gnQ


