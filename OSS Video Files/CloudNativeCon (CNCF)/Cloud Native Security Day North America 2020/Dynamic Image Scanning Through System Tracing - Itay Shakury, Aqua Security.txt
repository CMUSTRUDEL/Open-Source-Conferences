Title: Dynamic Image Scanning Through System Tracing - Itay Shakury, Aqua Security
Publication date: 2020-11-25
Playlist: Cloud Native Security Day North America 2020
Description: 
	Dynamic Image Scanning Through System Tracing - Itay Shakury, Aqua Security

As security practices and tools for application scanning are becoming increasingly popular, malicious actors are introducing sophisticated techniques to obfuscate their intent and evade those scanning tools. The malware they create cannot be detected using static analysis or signatures, but dynamic analysis that runs the application and observes its activity can trace the entire chain of events and help you detect those threats.  In this talk we introduce Dynamic scanning and discuss how it relates to two other security approaches: Static scanning and Runtime security. We will then show how operating system tracing is key to implementing dynamic scanning as we explore common behavioral patterns of malware, and discuss how these threats can be uncovered using open source tools.
Captions: 
	00:00:00,000 --> 00:00:04,000
hi everyone thank you for joining my

00:00:02,159 --> 00:00:06,160
name is itai shakuri

00:00:04,000 --> 00:00:08,880
and i work for aqua security on open

00:00:06,160 --> 00:00:11,280
source security related projects

00:00:08,880 --> 00:00:13,040
mostly for the cloud native ecosystem

00:00:11,280 --> 00:00:15,759
lately i've been working on a

00:00:13,040 --> 00:00:17,600
project that is a system tracing tool

00:00:15,759 --> 00:00:20,720
and its integration into

00:00:17,600 --> 00:00:22,320
a dynamic image scanning product and i

00:00:20,720 --> 00:00:24,400
wanted to share with you

00:00:22,320 --> 00:00:25,680
first of all uh the concept of dynamic

00:00:24,400 --> 00:00:28,320
image scanning the way that

00:00:25,680 --> 00:00:29,519
we perceive it and also the relationship

00:00:28,320 --> 00:00:32,399
between this

00:00:29,519 --> 00:00:32,800
and other concepts that you are familiar

00:00:32,399 --> 00:00:35,120
with

00:00:32,800 --> 00:00:37,040
maybe you're using today and also i

00:00:35,120 --> 00:00:40,000
wanted to talk about system tracing

00:00:37,040 --> 00:00:41,520
and how important it is for dynamic

00:00:40,000 --> 00:00:43,040
image scanning and how we can leverage

00:00:41,520 --> 00:00:45,760
that

00:00:43,040 --> 00:00:46,480
so to start the discussion i would like

00:00:45,760 --> 00:00:49,039
to first

00:00:46,480 --> 00:00:50,640
uh discuss what we have today with

00:00:49,039 --> 00:00:53,520
container scanning

00:00:50,640 --> 00:00:54,719
so i'm going to look at trivia which is

00:00:53,520 --> 00:00:58,079
a popular

00:00:54,719 --> 00:00:58,879
open source container scanning tool full

00:00:58,079 --> 00:01:00,960
disclaimer

00:00:58,879 --> 00:01:03,600
it's being built by my team in aqua but

00:01:00,960 --> 00:01:05,199
this is just an example for any

00:01:03,600 --> 00:01:06,960
container scanning tool most of them

00:01:05,199 --> 00:01:08,960
work the same way

00:01:06,960 --> 00:01:10,880
so here i'm asking trivi to scan this

00:01:08,960 --> 00:01:13,119
image it's drupal image which is a

00:01:10,880 --> 00:01:17,439
popular content management system

00:01:13,119 --> 00:01:20,720
trivia will discover that this image is

00:01:17,439 --> 00:01:22,479
based from alpine and because of that it

00:01:20,720 --> 00:01:23,439
will look for alpine packages that were

00:01:22,479 --> 00:01:26,400
installed using

00:01:23,439 --> 00:01:27,680
apk and then it will understand that

00:01:26,400 --> 00:01:30,240
this image was

00:01:27,680 --> 00:01:32,240
the software is using php so it will

00:01:30,240 --> 00:01:35,360
also look for a composer

00:01:32,240 --> 00:01:38,000
um a software installed using composer

00:01:35,360 --> 00:01:39,280
and similarly there are some javascript

00:01:38,000 --> 00:01:41,360
components in there so

00:01:39,280 --> 00:01:43,119
3d will also look at the yarn file that

00:01:41,360 --> 00:01:45,840
it found in order to

00:01:43,119 --> 00:01:46,960
obtain the list of software uh relating

00:01:45,840 --> 00:01:48,960
to javascript

00:01:46,960 --> 00:01:50,479
the goal here is to compile a list of

00:01:48,960 --> 00:01:52,320
install software within the compo

00:01:50,479 --> 00:01:53,520
within the container and most

00:01:52,320 --> 00:01:56,560
importantly the

00:01:53,520 --> 00:01:58,240
versions because in the next step we're

00:01:56,560 --> 00:01:59,920
going to compare this list

00:01:58,240 --> 00:02:02,399
with the database of known

00:01:59,920 --> 00:02:05,040
vulnerabilities this is the other piece

00:02:02,399 --> 00:02:06,320
of any container scanning tool for

00:02:05,040 --> 00:02:08,560
trivia because

00:02:06,320 --> 00:02:10,000
it's open source and we build the

00:02:08,560 --> 00:02:11,760
database itself

00:02:10,000 --> 00:02:13,280
in github and we store actually the

00:02:11,760 --> 00:02:14,800
database inside of github

00:02:13,280 --> 00:02:17,760
it's very easy to go ahead and see what

00:02:14,800 --> 00:02:20,239
we're doing there so just for example

00:02:17,760 --> 00:02:21,520
we aggregate vulnerability information

00:02:20,239 --> 00:02:24,879
from different sources

00:02:21,520 --> 00:02:26,560
for example nvd which is a great

00:02:24,879 --> 00:02:28,640
comprehensive database of

00:02:26,560 --> 00:02:31,519
vulnerabilities

00:02:28,640 --> 00:02:32,400
we also consider different advisories

00:02:31,519 --> 00:02:34,879
and lists

00:02:32,400 --> 00:02:36,959
that publish their own security

00:02:34,879 --> 00:02:39,599
advisories and vulnerabilities

00:02:36,959 --> 00:02:40,319
we even go as far as looking inside of

00:02:39,599 --> 00:02:42,720
the code

00:02:40,319 --> 00:02:44,000
of some projects that we are interested

00:02:42,720 --> 00:02:47,280
in in this case

00:02:44,000 --> 00:02:50,800
you see an example from alpine if

00:02:47,280 --> 00:02:52,959
we know that we can parse some security

00:02:50,800 --> 00:02:54,560
vulnerabilities from these sources there

00:02:52,959 --> 00:02:56,560
are many other different sources that

00:02:54,560 --> 00:02:59,360
goes into the tree database

00:02:56,560 --> 00:03:00,720
but the result is just a simple database

00:02:59,360 --> 00:03:04,720
of

00:03:00,720 --> 00:03:07,280
vulnerabilities and the affected

00:03:04,720 --> 00:03:09,040
software and then we can go ahead and

00:03:07,280 --> 00:03:11,440
cross reference the list

00:03:09,040 --> 00:03:12,800
of vulnerabilities with the list of the

00:03:11,440 --> 00:03:15,120
software that we found inside of the

00:03:12,800 --> 00:03:18,319
container and we see here that law dash

00:03:15,120 --> 00:03:20,480
which is a javascript dependency library

00:03:18,319 --> 00:03:21,599
has a high severity vulnerability

00:03:20,480 --> 00:03:25,440
because of the

00:03:21,599 --> 00:03:27,840
417-15 version that we were using

00:03:25,440 --> 00:03:28,959
so great this is this is a very useful

00:03:27,840 --> 00:03:32,400
thing that any

00:03:28,959 --> 00:03:34,239
static image scanning tool can uh

00:03:32,400 --> 00:03:36,159
can give us discovering known

00:03:34,239 --> 00:03:39,040
vulnerabilities

00:03:36,159 --> 00:03:41,440
what else what else can we learn by

00:03:39,040 --> 00:03:43,560
statically scanning the image

00:03:41,440 --> 00:03:45,120
so another another thing is

00:03:43,560 --> 00:03:47,120
misconfigurations

00:03:45,120 --> 00:03:49,120
unlike vulnerabilities where

00:03:47,120 --> 00:03:51,680
vulnerabilities are basically bugs

00:03:49,120 --> 00:03:54,319
in the software in the dependencies that

00:03:51,680 --> 00:03:56,480
needs to be fixed upstream

00:03:54,319 --> 00:03:58,000
misconfiguration is not about bugs it's

00:03:56,480 --> 00:04:01,599
mostly about

00:03:58,000 --> 00:04:03,439
improper usage of the software and

00:04:01,599 --> 00:04:06,000
if we look out there we see a lot of

00:04:03,439 --> 00:04:06,799
examples for misconfigured container

00:04:06,000 --> 00:04:08,560
images

00:04:06,799 --> 00:04:09,840
that we could have detected just by

00:04:08,560 --> 00:04:12,720
scanning the image

00:04:09,840 --> 00:04:14,720
for example people using the default

00:04:12,720 --> 00:04:18,160
settings for the software

00:04:14,720 --> 00:04:20,880
and wasn't adapting it for uh production

00:04:18,160 --> 00:04:22,000
people uh leaving a lot of unnecessarily

00:04:20,880 --> 00:04:24,479
open ports

00:04:22,000 --> 00:04:25,280
uh tls settings which were incorrectly

00:04:24,479 --> 00:04:27,919
configured

00:04:25,280 --> 00:04:28,639
people even use uh sorry people even

00:04:27,919 --> 00:04:31,520
forget

00:04:28,639 --> 00:04:33,520
their passwords and the keys inside of

00:04:31,520 --> 00:04:36,960
the code inside of the containers

00:04:33,520 --> 00:04:39,280
so these are all examples for things

00:04:36,960 --> 00:04:41,919
that we could easily have discovered

00:04:39,280 --> 00:04:44,400
just by looking at the container image

00:04:41,919 --> 00:04:44,400
itself

00:04:44,479 --> 00:04:50,960
so vulnerabilities misconfigurations

00:04:47,680 --> 00:04:52,479
what else can we understand just by

00:04:50,960 --> 00:04:56,080
analyzing the

00:04:52,479 --> 00:04:59,199
image at rest so another thing

00:04:56,080 --> 00:05:00,800
is a malware we can uh

00:04:59,199 --> 00:05:02,720
the container itself is just a bunch of

00:05:00,800 --> 00:05:04,240
files right so we can take

00:05:02,720 --> 00:05:06,560
any number of files from within the

00:05:04,240 --> 00:05:07,759
container and use the traditional

00:05:06,560 --> 00:05:11,120
anti-malware

00:05:07,759 --> 00:05:13,199
tools in order to identify those

00:05:11,120 --> 00:05:14,479
files and see if any of them appears to

00:05:13,199 --> 00:05:18,080
be malicious

00:05:14,479 --> 00:05:20,800
these are all examples for the benefits

00:05:18,080 --> 00:05:21,759
of static image scanning just by looking

00:05:20,800 --> 00:05:25,600
at the image

00:05:21,759 --> 00:05:29,520
at rest we can learn a lot about

00:05:25,600 --> 00:05:29,520
what this container is up to

00:05:31,199 --> 00:05:35,520
so what do you think if you're scanning

00:05:33,199 --> 00:05:37,680
containers today is this

00:05:35,520 --> 00:05:38,720
satisfactory to you do you feel secure

00:05:37,680 --> 00:05:42,080
after you

00:05:38,720 --> 00:05:44,080
scan your container images so my

00:05:42,080 --> 00:05:45,360
my claim here is that you shouldn't be

00:05:44,080 --> 00:05:48,800
because there is an

00:05:45,360 --> 00:05:51,280
entire category of risks that

00:05:48,800 --> 00:05:53,680
simply cannot be detected using static

00:05:51,280 --> 00:05:57,039
image scanning

00:05:53,680 --> 00:05:59,840
and one example for that

00:05:57,039 --> 00:06:01,199
is uh evasive malware that we have

00:05:59,840 --> 00:06:04,639
observed in the while

00:06:01,199 --> 00:06:07,840
so this is an example for an image

00:06:04,639 --> 00:06:09,759
in docker hub that passed

00:06:07,840 --> 00:06:11,759
all of the scans it has no known

00:06:09,759 --> 00:06:13,520
vulnerabilities no misconfigurations no

00:06:11,759 --> 00:06:16,240
known malware

00:06:13,520 --> 00:06:17,520
but when you run it you see the entry

00:06:16,240 --> 00:06:20,800
point here on the right

00:06:17,520 --> 00:06:23,680
there is an encoded base64 encoded

00:06:20,800 --> 00:06:24,479
string here that is essentially a

00:06:23,680 --> 00:06:27,520
malware

00:06:24,479 --> 00:06:30,800
encoded as uh his characters

00:06:27,520 --> 00:06:34,080
and only at runtime the script will

00:06:30,800 --> 00:06:37,039
uh unpack this and run it

00:06:34,080 --> 00:06:37,600
so if you were to scan this script you

00:06:37,039 --> 00:06:39,840
know it's

00:06:37,600 --> 00:06:41,199
it's a string it's a weird string but

00:06:39,840 --> 00:06:43,520
it's not necessarily malicious

00:06:41,199 --> 00:06:45,120
not a lot of static scanning tools will

00:06:43,520 --> 00:06:45,840
be able to understand what's going on

00:06:45,120 --> 00:06:47,840
here

00:06:45,840 --> 00:06:49,199
but when you run the image it's very

00:06:47,840 --> 00:06:53,199
easy to see

00:06:49,199 --> 00:06:56,880
that it is actually executing a malware

00:06:53,199 --> 00:06:58,880
and this is not a made up example

00:06:56,880 --> 00:07:00,800
our research team has recently uncovered

00:06:58,880 --> 00:07:04,639
a big operation

00:07:00,800 --> 00:07:06,560
of the group that has used uh and abused

00:07:04,639 --> 00:07:07,360
docker hub in order to distribute

00:07:06,560 --> 00:07:10,000
malware

00:07:07,360 --> 00:07:12,319
in seemingly legitimate containers where

00:07:10,000 --> 00:07:13,039
the end goal was to run crypto mining

00:07:12,319 --> 00:07:16,960
tools

00:07:13,039 --> 00:07:18,319
on your servers um and

00:07:16,960 --> 00:07:20,080
my point here you can go ahead and read

00:07:18,319 --> 00:07:22,080
the blog post if you want but my point

00:07:20,080 --> 00:07:25,840
here is that this is real

00:07:22,080 --> 00:07:28,000
this happens and the fact that we are

00:07:25,840 --> 00:07:29,360
trusting dockerhub in this case

00:07:28,000 --> 00:07:32,400
dockerhub has no

00:07:29,360 --> 00:07:34,720
fault here they're just storing files

00:07:32,400 --> 00:07:35,520
but the fact that we are trusting the

00:07:34,720 --> 00:07:38,639
source

00:07:35,520 --> 00:07:41,759
here blindly is an open door

00:07:38,639 --> 00:07:42,560
there's a actually an entire category of

00:07:41,759 --> 00:07:45,360
uh

00:07:42,560 --> 00:07:46,879
of the risks here that is called supply

00:07:45,360 --> 00:07:49,680
chain attacks

00:07:46,879 --> 00:07:51,680
and this is where uh the hackers will

00:07:49,680 --> 00:07:53,520
not even target your

00:07:51,680 --> 00:07:55,120
your servers they will not try to hack

00:07:53,520 --> 00:07:57,360
you directly

00:07:55,120 --> 00:07:59,440
instead they will target your supply

00:07:57,360 --> 00:08:01,919
chain that you already trust

00:07:59,440 --> 00:08:03,840
think about where you store your source

00:08:01,919 --> 00:08:07,440
code today

00:08:03,840 --> 00:08:10,639
think about where you build and test

00:08:07,440 --> 00:08:12,400
and produce artifacts your cicd pipeline

00:08:10,639 --> 00:08:14,879
think about where you store artifacts

00:08:12,400 --> 00:08:17,280
today and how you deliver

00:08:14,879 --> 00:08:19,440
those artifacts into production each

00:08:17,280 --> 00:08:21,599
each and every one of those

00:08:19,440 --> 00:08:22,639
chain in the links is a point of

00:08:21,599 --> 00:08:25,039
interest to

00:08:22,639 --> 00:08:26,720
the attacker because if they compromise

00:08:25,039 --> 00:08:28,879
one of them

00:08:26,720 --> 00:08:30,720
most likely their malware will be able

00:08:28,879 --> 00:08:34,959
to find its way into your servers

00:08:30,720 --> 00:08:34,959
because you already trust this pipeline

00:08:36,240 --> 00:08:42,800
so to summarize

00:08:40,080 --> 00:08:43,279
static image scanning can tell us a lot

00:08:42,800 --> 00:08:45,120
about

00:08:43,279 --> 00:08:47,040
the container and it's very important to

00:08:45,120 --> 00:08:49,600
scan our containers

00:08:47,040 --> 00:08:51,680
we learn about the known vulnerabilities

00:08:49,600 --> 00:08:52,800
we learn about misconfigurations maybe

00:08:51,680 --> 00:08:56,240
and maybe even about

00:08:52,800 --> 00:08:59,120
malware inside of the container

00:08:56,240 --> 00:09:00,240
but there's also an entire category of

00:08:59,120 --> 00:09:03,279
risks

00:09:00,240 --> 00:09:05,519
that we were overlooking

00:09:03,279 --> 00:09:07,560
we've discussed evasive malware there's

00:09:05,519 --> 00:09:10,880
also

00:09:07,560 --> 00:09:12,480
unknown vulnerabilities there's also

00:09:10,880 --> 00:09:14,640
more sophisticated attacks that are

00:09:12,480 --> 00:09:18,240
harder to scan for

00:09:14,640 --> 00:09:21,519
my point is that the image itself

00:09:18,240 --> 00:09:22,160
at rest can also can only tell us so

00:09:21,519 --> 00:09:24,240
much

00:09:22,160 --> 00:09:25,680
about what the container will do at

00:09:24,240 --> 00:09:27,440
runtime and the best

00:09:25,680 --> 00:09:28,880
way to understand what the container

00:09:27,440 --> 00:09:32,959
will do at runtime

00:09:28,880 --> 00:09:36,160
is to run it and this is where

00:09:32,959 --> 00:09:39,360
system tracing also enters the

00:09:36,160 --> 00:09:41,920
the picture because

00:09:39,360 --> 00:09:42,959
system tracing allows us to understand

00:09:41,920 --> 00:09:44,560
what's happening

00:09:42,959 --> 00:09:46,080
from the operating system point of view

00:09:44,560 --> 00:09:48,240
this is something that

00:09:46,080 --> 00:09:49,760
the malware the software that's running

00:09:48,240 --> 00:09:54,320
inside of the container

00:09:49,760 --> 00:09:56,560
cannot simply evade or escape

00:09:54,320 --> 00:09:58,320
so i would like to show you now a quick

00:09:56,560 --> 00:10:01,040
demonstration of what it means

00:09:58,320 --> 00:10:02,839
to detect a malicious behavior using

00:10:01,040 --> 00:10:05,839
system

00:10:02,839 --> 00:10:05,839
tracing

00:10:06,959 --> 00:10:16,360
all right so we will start

00:10:11,440 --> 00:10:19,680
by looking at an example for

00:10:16,360 --> 00:10:22,959
a script similar to the one that uh

00:10:19,680 --> 00:10:24,640
i showed you in the slides and uh you

00:10:22,959 --> 00:10:27,920
see here the the very

00:10:24,640 --> 00:10:30,800
long basics before encoded string

00:10:27,920 --> 00:10:32,079
and in the end there is a there's a

00:10:30,800 --> 00:10:34,079
command to decode

00:10:32,079 --> 00:10:36,880
it and to make it an executable and to

00:10:34,079 --> 00:10:38,880
execute it and then just as a disguise

00:10:36,880 --> 00:10:40,160
show that something something else is

00:10:38,880 --> 00:10:43,200
happening

00:10:40,160 --> 00:10:43,200
if we run this

00:10:43,680 --> 00:10:47,519
this is called evasive script we see

00:10:46,720 --> 00:10:50,240
hello world

00:10:47,519 --> 00:10:51,680
this is being printed by the malware and

00:10:50,240 --> 00:10:53,530
we see i'm good

00:10:51,680 --> 00:10:54,800
which is the

00:10:53,530 --> 00:10:58,959
[Music]

00:10:54,800 --> 00:10:58,959
the disguise of the script

00:10:59,200 --> 00:11:03,920
now if the malware didn't uh naturally

00:11:01,760 --> 00:11:04,320
print hello world to us how would we

00:11:03,920 --> 00:11:06,240
able

00:11:04,320 --> 00:11:07,440
how would we be able to understand that

00:11:06,240 --> 00:11:11,360
this script had it

00:11:07,440 --> 00:11:11,839
hides another executable we could read

00:11:11,360 --> 00:11:14,079
it

00:11:11,839 --> 00:11:15,040
yeah but if this wasn't a script if this

00:11:14,079 --> 00:11:18,640
was

00:11:15,040 --> 00:11:21,040
an executable maybe even an obfuscated

00:11:18,640 --> 00:11:24,160
executable that's harder to

00:11:21,040 --> 00:11:26,800
manually analyze then would be in

00:11:24,160 --> 00:11:27,440
some kind of trouble so um this is where

00:11:26,800 --> 00:11:30,800
tracing

00:11:27,440 --> 00:11:33,200
comes in i'm going to use a very

00:11:30,800 --> 00:11:34,320
popular tool that's called s trace this

00:11:33,200 --> 00:11:38,240
is uh

00:11:34,320 --> 00:11:40,399
a very common linux toolbox kind of tool

00:11:38,240 --> 00:11:43,519
uh it allows us to trace system calls

00:11:40,399 --> 00:11:47,440
from the operating system point of view

00:11:43,519 --> 00:11:50,560
and i'm going to run the the same

00:11:47,440 --> 00:11:51,440
uh script except i'm prefixing it with

00:11:50,560 --> 00:11:54,160
the command

00:11:51,440 --> 00:11:55,360
s trace i also want to tell it exactly

00:11:54,160 --> 00:11:58,480
what to trace

00:11:55,360 --> 00:12:01,360
so i will say trace

00:11:58,480 --> 00:12:03,200
equals exactly e exactly e is the name

00:12:01,360 --> 00:12:05,120
of the system called that's being

00:12:03,200 --> 00:12:06,800
used to ask the operating system to

00:12:05,120 --> 00:12:10,000
execute something

00:12:06,800 --> 00:12:12,800
if we do that we see the same

00:12:10,000 --> 00:12:15,200
result here hello world and good um in

00:12:12,800 --> 00:12:18,560
the output but also we see

00:12:15,200 --> 00:12:21,440
all of the exactly ee calls and

00:12:18,560 --> 00:12:21,440
we see here that

00:12:21,760 --> 00:12:27,440
this file was executed and again this

00:12:25,360 --> 00:12:30,160
time it was a script so we know

00:12:27,440 --> 00:12:32,079
that it was in there but think about a

00:12:30,160 --> 00:12:35,760
different case where this was

00:12:32,079 --> 00:12:39,839
a uh a binary where it wasn't so easy to

00:12:35,760 --> 00:12:39,839
understand what's going on in there

00:12:40,800 --> 00:12:44,800
actually let's take a look at an example

00:12:43,279 --> 00:12:49,360
like this

00:12:44,800 --> 00:12:51,279
so here i have another example

00:12:49,360 --> 00:12:53,519
it's the same hello world application

00:12:51,279 --> 00:12:56,000
that was the malware

00:12:53,519 --> 00:12:56,000
this time

00:12:57,440 --> 00:13:04,839
this is the manual itself this time i am

00:13:00,480 --> 00:13:07,200
hiding it within this hello world dot

00:13:04,839 --> 00:13:09,680
text

00:13:07,200 --> 00:13:11,200
it's it feels similar to this to the

00:13:09,680 --> 00:13:14,480
previous example where we

00:13:11,200 --> 00:13:15,200
uh we reheat it within a script but this

00:13:14,480 --> 00:13:18,240
time

00:13:15,200 --> 00:13:20,079
it will not be that easy to discover it

00:13:18,240 --> 00:13:23,120
first of all this is a binary

00:13:20,079 --> 00:13:26,399
so if we

00:13:23,120 --> 00:13:29,279
look at the binary itself yeah

00:13:26,399 --> 00:13:30,560
nothing really readable for us here it's

00:13:29,279 --> 00:13:33,600
just binary data

00:13:30,560 --> 00:13:34,000
this is one thing second of all if we

00:13:33,600 --> 00:13:37,360
trace

00:13:34,000 --> 00:13:40,480
it using the same x-trace

00:13:37,360 --> 00:13:43,760
command and we ask it to

00:13:40,480 --> 00:13:47,040
trace exactly

00:13:43,760 --> 00:13:50,160
remember that in the previous example

00:13:47,040 --> 00:13:53,360
we saw that

00:13:50,160 --> 00:13:54,959
the script was started

00:13:53,360 --> 00:13:57,040
and then other processes started and

00:13:54,959 --> 00:14:01,040
then explicitly

00:13:57,040 --> 00:14:03,839
the malware itself had started

00:14:01,040 --> 00:14:03,839
and this time

00:14:04,079 --> 00:14:08,560
i'm going to see a different result i

00:14:06,720 --> 00:14:13,199
only see the execution

00:14:08,560 --> 00:14:16,320
of the of the host of the of the

00:14:13,199 --> 00:14:17,199
wrapping binary there is no exact ve

00:14:16,320 --> 00:14:19,120
malware here

00:14:17,199 --> 00:14:22,240
even though we know because we see the

00:14:19,120 --> 00:14:26,320
output that hello world

00:14:22,240 --> 00:14:26,320
was invoked and this is not hello world

00:14:26,399 --> 00:14:33,600
so how can we still detect it

00:14:29,600 --> 00:14:36,639
so this is where behavioral

00:14:33,600 --> 00:14:37,040
analysis comes into the picture so far

00:14:36,639 --> 00:14:40,240
we

00:14:37,040 --> 00:14:41,760
we've seen an example for how tracing

00:14:40,240 --> 00:14:42,399
can help us understand what's going on

00:14:41,760 --> 00:14:45,040
so we can

00:14:42,399 --> 00:14:46,399
yeah we can look for exactly e and so on

00:14:45,040 --> 00:14:48,959
but in this case we need

00:14:46,399 --> 00:14:50,880
something more powerful we need to learn

00:14:48,959 --> 00:14:54,160
about the behavioral pattern

00:14:50,880 --> 00:14:54,880
of this of this technique and then we

00:14:54,160 --> 00:14:58,000
can

00:14:54,880 --> 00:15:01,199
detect it so i'm going

00:14:58,000 --> 00:15:04,399
to add a few um

00:15:01,199 --> 00:15:06,240
events to trace here not only exactly

00:15:04,399 --> 00:15:10,560
here i want to look also at

00:15:06,240 --> 00:15:10,560
map and and protect

00:15:11,120 --> 00:15:14,720
these two system calls are used to

00:15:13,600 --> 00:15:17,920
allocate memory

00:15:14,720 --> 00:15:19,360
uh manage its uh permissions uh

00:15:17,920 --> 00:15:20,320
basically to manage memory for the

00:15:19,360 --> 00:15:22,560
process

00:15:20,320 --> 00:15:24,399
and i do this because i know that the

00:15:22,560 --> 00:15:27,920
packed version

00:15:24,399 --> 00:15:29,920
is using um is using

00:15:27,920 --> 00:15:31,279
this technique in order to hide the

00:15:29,920 --> 00:15:34,079
embedded binary

00:15:31,279 --> 00:15:35,839
so this time we see the same exact v of

00:15:34,079 --> 00:15:37,360
the hello world that pack this is the

00:15:35,839 --> 00:15:40,160
entry point

00:15:37,360 --> 00:15:41,279
we still don't see any other exactly e

00:15:40,160 --> 00:15:44,240
for the

00:15:41,279 --> 00:15:45,839
embedded malware but we do see a

00:15:44,240 --> 00:15:47,600
suspicious pattern here

00:15:45,839 --> 00:15:48,880
we see that that the process has

00:15:47,600 --> 00:15:52,079
allocated

00:15:48,880 --> 00:15:55,759
um has allocated a memory region

00:15:52,079 --> 00:15:57,920
and it has actually made it executable

00:15:55,759 --> 00:15:58,959
as we can see here this is necessary for

00:15:57,920 --> 00:16:01,040
it to

00:15:58,959 --> 00:16:03,199
execute the binary data that it writes

00:16:01,040 --> 00:16:06,480
into this memory region

00:16:03,199 --> 00:16:10,720
and if we compare this to the trace

00:16:06,480 --> 00:16:14,480
of the regular

00:16:10,720 --> 00:16:15,839
hello world we see that it is very very

00:16:14,480 --> 00:16:18,399
different

00:16:15,839 --> 00:16:19,360
here we see just exactly it and here we

00:16:18,399 --> 00:16:23,839
see

00:16:19,360 --> 00:16:23,839
a whole load of suspicious activity

00:16:24,000 --> 00:16:28,720
okay so this was about how we can

00:16:29,120 --> 00:16:34,480
how we can understand

00:16:32,240 --> 00:16:36,000
what the software do to our art that we

00:16:34,480 --> 00:16:39,519
are running is doing

00:16:36,000 --> 00:16:42,800
by observing its behavioral patterns

00:16:39,519 --> 00:16:45,519
we have done it manually this time but

00:16:42,800 --> 00:16:47,519
soon we will see how we can also use

00:16:45,519 --> 00:16:50,720
more sophisticated tools to help us in

00:16:47,519 --> 00:16:52,720
this analysis

00:16:50,720 --> 00:16:55,279
all right so let's move back to the

00:16:52,720 --> 00:16:55,279
slides

00:17:01,360 --> 00:17:06,959
okay so we have seen

00:17:04,559 --> 00:17:08,000
how we can use system tracing you know

00:17:06,959 --> 00:17:08,799
to understand the software that's

00:17:08,000 --> 00:17:11,520
running

00:17:08,799 --> 00:17:12,240
in the containers uh maybe some of you

00:17:11,520 --> 00:17:15,919
think this

00:17:12,240 --> 00:17:19,199
sounds familiar maybe it rings a bell uh

00:17:15,919 --> 00:17:22,480
we have been using similar techniques

00:17:19,199 --> 00:17:24,799
in production to uh

00:17:22,480 --> 00:17:25,600
to prevent from certain things to happen

00:17:24,799 --> 00:17:28,480
onto alert

00:17:25,600 --> 00:17:30,559
this is often called runtime security or

00:17:28,480 --> 00:17:33,280
random protection

00:17:30,559 --> 00:17:33,679
it's nothing new right uh there's a lot

00:17:33,280 --> 00:17:35,440
of

00:17:33,679 --> 00:17:36,799
mature solutions in the market for

00:17:35,440 --> 00:17:38,559
runtime security

00:17:36,799 --> 00:17:40,400
and what it means is that we are going

00:17:38,559 --> 00:17:41,840
to monitor everything that happens in

00:17:40,400 --> 00:17:45,039
production

00:17:41,840 --> 00:17:47,280
we are going to analyze

00:17:45,039 --> 00:17:48,640
this stream of events and we are going

00:17:47,280 --> 00:17:51,440
to look for suspicious

00:17:48,640 --> 00:17:53,360
patterns and if we if we find something

00:17:51,440 --> 00:17:53,760
then we were going to alert or we can

00:17:53,360 --> 00:17:57,440
even

00:17:53,760 --> 00:18:00,000
block it from ever happening um

00:17:57,440 --> 00:18:00,640
again this is not new the company that i

00:18:00,000 --> 00:18:02,000
work for

00:18:00,640 --> 00:18:04,640
is one of the leading vendors in this

00:18:02,000 --> 00:18:06,720
space so

00:18:04,640 --> 00:18:09,440
there's there's a mature market for

00:18:06,720 --> 00:18:12,640
these kind of solutions

00:18:09,440 --> 00:18:14,160
but my argument here is that if we are

00:18:12,640 --> 00:18:14,960
dealing with malware and trying to

00:18:14,160 --> 00:18:19,039
assess

00:18:14,960 --> 00:18:20,880
the containers won't be won't it be

00:18:19,039 --> 00:18:23,200
even better to make this assessment

00:18:20,880 --> 00:18:24,960
earlier in the pipeline why are we

00:18:23,200 --> 00:18:26,320
waiting for the containers to be running

00:18:24,960 --> 00:18:29,360
in production in order to

00:18:26,320 --> 00:18:31,440
observe their behavior in other words

00:18:29,360 --> 00:18:35,120
what i'm saying here is

00:18:31,440 --> 00:18:37,760
let's shift left and use the

00:18:35,120 --> 00:18:40,559
the same techniques or technology that

00:18:37,760 --> 00:18:44,000
we have been using for random security

00:18:40,559 --> 00:18:45,919
but use it earlier in the pipeline

00:18:44,000 --> 00:18:48,080
when we build the container where we

00:18:45,919 --> 00:18:51,200
test it and so on

00:18:48,080 --> 00:18:52,799
now this is not simply taking the same

00:18:51,200 --> 00:18:53,840
product and running it in a different

00:18:52,799 --> 00:18:56,000
place

00:18:53,840 --> 00:18:58,320
because there are different constraints

00:18:56,000 --> 00:18:59,679
here we can actually tailor the product

00:18:58,320 --> 00:19:03,679
to fit

00:18:59,679 --> 00:19:07,520
the to fit its new place in the pipeline

00:19:03,679 --> 00:19:08,720
in the in the pre-production environment

00:19:07,520 --> 00:19:12,160
and this is what we call dynamic

00:19:08,720 --> 00:19:14,559
scanning so this solution will now

00:19:12,160 --> 00:19:15,760
also run the containers inside of an

00:19:14,559 --> 00:19:17,520
ephemera sandbox

00:19:15,760 --> 00:19:19,440
right because we are not running the

00:19:17,520 --> 00:19:21,039
containers in production anymore we need

00:19:19,440 --> 00:19:24,400
to run them somewhere else

00:19:21,039 --> 00:19:26,480
and these are untrusted software so

00:19:24,400 --> 00:19:27,919
in ephemeral sandbox sound like good

00:19:26,480 --> 00:19:29,760
solution

00:19:27,919 --> 00:19:30,960
we can also use more comprehensive

00:19:29,760 --> 00:19:33,679
tracing

00:19:30,960 --> 00:19:34,480
when we do it in this stage i will

00:19:33,679 --> 00:19:36,880
explain

00:19:34,480 --> 00:19:38,160
this point very soon and we can also

00:19:36,880 --> 00:19:41,600
automate

00:19:38,160 --> 00:19:43,440
this into into a

00:19:41,600 --> 00:19:44,799
a solution that we can integrate into

00:19:43,440 --> 00:19:46,640
existing processes

00:19:44,799 --> 00:19:48,880
think that uh whenever you do a pull

00:19:46,640 --> 00:19:50,960
request you can now

00:19:48,880 --> 00:19:52,240
spin up in ephemeral sandbox run the

00:19:50,960 --> 00:19:54,480
container in there

00:19:52,240 --> 00:19:56,720
it is heavily heavily instrumented and

00:19:54,480 --> 00:19:57,520
you have all of the same heuristics that

00:19:56,720 --> 00:20:00,240
you've used for

00:19:57,520 --> 00:20:01,280
random security but even more uh this

00:20:00,240 --> 00:20:03,919
time

00:20:01,280 --> 00:20:06,400
and you are able to flag this container

00:20:03,919 --> 00:20:08,240
as suspicious or safe

00:20:06,400 --> 00:20:09,520
before it reaches production actually

00:20:08,240 --> 00:20:12,559
before it reaches

00:20:09,520 --> 00:20:14,720
even your container registry

00:20:12,559 --> 00:20:15,840
and i want to emphasize the fact that

00:20:14,720 --> 00:20:17,840
this is not

00:20:15,840 --> 00:20:19,679
the same as runtime security because it

00:20:17,840 --> 00:20:22,559
is quite similar

00:20:19,679 --> 00:20:23,679
but not the same there are different

00:20:22,559 --> 00:20:26,799
constraints here

00:20:23,679 --> 00:20:28,159
and we need to even leverage

00:20:26,799 --> 00:20:30,320
these different contract different

00:20:28,159 --> 00:20:32,960
constraints in order to build

00:20:30,320 --> 00:20:34,080
a solution that is tailored for this new

00:20:32,960 --> 00:20:37,520
place

00:20:34,080 --> 00:20:39,520
in random security in production

00:20:37,520 --> 00:20:41,200
we always aspire to minimize the

00:20:39,520 --> 00:20:44,799
overhead

00:20:41,200 --> 00:20:47,919
of everything that that we add there

00:20:44,799 --> 00:20:50,000
but in dynamic scanning there is not

00:20:47,919 --> 00:20:52,559
there's no such requirement these are

00:20:50,000 --> 00:20:53,600
ad hoc environments that we spin up just

00:20:52,559 --> 00:20:56,159
for the sake of uh

00:20:53,600 --> 00:20:58,880
testing the containers we can turn on

00:20:56,159 --> 00:21:01,360
the verbosity to the maximum

00:20:58,880 --> 00:21:02,320
we don't really care we can even collect

00:21:01,360 --> 00:21:04,640
more

00:21:02,320 --> 00:21:05,919
kinds of information for example we can

00:21:04,640 --> 00:21:08,880
run a tcp dump

00:21:05,919 --> 00:21:10,559
while we're at it why not we can collect

00:21:08,880 --> 00:21:14,320
a lot more information

00:21:10,559 --> 00:21:16,240
in higher fidelity and the more data we

00:21:14,320 --> 00:21:19,600
have the better decisions we can make

00:21:16,240 --> 00:21:21,200
and so this is just one example for uh

00:21:19,600 --> 00:21:23,520
why the constraints are different and

00:21:21,200 --> 00:21:26,000
why the the resulting product

00:21:23,520 --> 00:21:27,919
might look different another example is

00:21:26,000 --> 00:21:30,799
that in production we have to make

00:21:27,919 --> 00:21:31,840
quick decisions this makes sense right

00:21:30,799 --> 00:21:34,080
because

00:21:31,840 --> 00:21:36,159
the runtime protection solution is in

00:21:34,080 --> 00:21:39,840
the critical path

00:21:36,159 --> 00:21:42,960
we don't want to delay uh too much

00:21:39,840 --> 00:21:44,480
the the decision-making process but with

00:21:42,960 --> 00:21:46,240
dynamic scanning

00:21:44,480 --> 00:21:48,400
we don't have this con this constraints

00:21:46,240 --> 00:21:51,760
we can take as long as we need to

00:21:48,400 --> 00:21:54,640
in order to make decisions we can use

00:21:51,760 --> 00:21:56,240
uh more complicated algorithms to to

00:21:54,640 --> 00:21:58,720
test or to make the decisions we can

00:21:56,240 --> 00:22:01,840
even defer the decisions

00:21:58,720 --> 00:22:03,760
so we can see that if something

00:22:01,840 --> 00:22:05,039
specific happens we can flag this

00:22:03,760 --> 00:22:07,120
container for

00:22:05,039 --> 00:22:08,400
someone else some security researcher to

00:22:07,120 --> 00:22:10,720
take a deeper look at

00:22:08,400 --> 00:22:11,440
later on this is a privilege that we

00:22:10,720 --> 00:22:13,520
have with

00:22:11,440 --> 00:22:15,120
dynamic scanning and we don't have this

00:22:13,520 --> 00:22:17,520
with front-end security

00:22:15,120 --> 00:22:19,280
another example for the differences is

00:22:17,520 --> 00:22:22,400
that in production

00:22:19,280 --> 00:22:25,360
the stakes are much much higher

00:22:22,400 --> 00:22:27,200
everything is high impact but with

00:22:25,360 --> 00:22:30,240
dynamic scanning

00:22:27,200 --> 00:22:34,640
this is a fake environment it's not real

00:22:30,240 --> 00:22:37,200
uh customer data so we can actually let

00:22:34,640 --> 00:22:38,400
the malware run to completion and do

00:22:37,200 --> 00:22:40,799
what it wanted to do

00:22:38,400 --> 00:22:41,760
maybe we will learn something about it

00:22:40,799 --> 00:22:44,559
that we

00:22:41,760 --> 00:22:45,440
that we couldn't have because we had to

00:22:44,559 --> 00:22:48,559
stop it short

00:22:45,440 --> 00:22:52,080
in production so my point here is just

00:22:48,559 --> 00:22:55,280
to explain why dynamic scanning

00:22:52,080 --> 00:22:56,240
is not runtime security yes it is using

00:22:55,280 --> 00:22:59,840
system tracing

00:22:56,240 --> 00:23:02,480
it is using even similar terminology or

00:22:59,840 --> 00:23:03,520
technologies but because the constraints

00:23:02,480 --> 00:23:05,840
are different

00:23:03,520 --> 00:23:06,840
we can build two different products that

00:23:05,840 --> 00:23:10,000
each one of them

00:23:06,840 --> 00:23:10,480
leverages the uh the constraints to its

00:23:10,000 --> 00:23:12,880
own

00:23:10,480 --> 00:23:12,880
benefit

00:23:15,280 --> 00:23:18,640
all right so now i want to explain what

00:23:17,679 --> 00:23:22,159
i meant earlier

00:23:18,640 --> 00:23:23,679
when i said advanced tracing so in the

00:23:22,159 --> 00:23:26,960
demo that we saw earlier

00:23:23,679 --> 00:23:30,080
i used s trace a very popular and very

00:23:26,960 --> 00:23:34,159
effective tool to trace

00:23:30,080 --> 00:23:36,960
the system calls that a process makes

00:23:34,159 --> 00:23:37,840
but we cannot speak about system tracing

00:23:36,960 --> 00:23:41,520
today

00:23:37,840 --> 00:23:43,840
without mentioning ebpf and this is not

00:23:41,520 --> 00:23:44,720
going to be an introduction to ebpf

00:23:43,840 --> 00:23:47,919
there are other

00:23:44,720 --> 00:23:51,360
uh sessions that cover that but

00:23:47,919 --> 00:23:54,640
i think the tbpf is such a

00:23:51,360 --> 00:23:57,760
an impactful and critical component

00:23:54,640 --> 00:24:01,120
that affects system tracing today

00:23:57,760 --> 00:24:03,440
that we need to mention it so

00:24:01,120 --> 00:24:05,440
ebpf is just a subsystem in the linux

00:24:03,440 --> 00:24:06,000
kernel that allows you to run your own

00:24:05,440 --> 00:24:09,200
code

00:24:06,000 --> 00:24:10,640
within the linux canon and

00:24:09,200 --> 00:24:12,400
this is very unique because if you

00:24:10,640 --> 00:24:15,919
wanted to do something similar to that

00:24:12,400 --> 00:24:19,039
before ebpf you had to

00:24:15,919 --> 00:24:21,120
maybe build a kernel module and load it

00:24:19,039 --> 00:24:23,039
so that means that the code that you

00:24:21,120 --> 00:24:27,039
write this kernel model

00:24:23,039 --> 00:24:27,919
is essentially at the same level as the

00:24:27,039 --> 00:24:29,760
kernel

00:24:27,919 --> 00:24:31,120
it has the same privileges it has the

00:24:29,760 --> 00:24:33,679
same

00:24:31,120 --> 00:24:35,840
blast radius and when we talk about

00:24:33,679 --> 00:24:39,679
security products

00:24:35,840 --> 00:24:42,720
it is um not so easy to convince

00:24:39,679 --> 00:24:45,279
a security-minded customer to run

00:24:42,720 --> 00:24:46,960
some arbitrary kernel module and

00:24:45,279 --> 00:24:47,840
basically load it into their production

00:24:46,960 --> 00:24:49,520
environment

00:24:47,840 --> 00:24:51,440
which means that it can do everything

00:24:49,520 --> 00:24:53,520
that it wants to do

00:24:51,440 --> 00:24:55,760
ebpf allows us to load our programs into

00:24:53,520 --> 00:24:56,480
the kernel in a safe way in an isolated

00:24:55,760 --> 00:25:00,159
way

00:24:56,480 --> 00:25:02,640
so that means that the the risk is lower

00:25:00,159 --> 00:25:03,840
and it also has a lot of different kinds

00:25:02,640 --> 00:25:06,880
of integrations

00:25:03,840 --> 00:25:08,159
one of them is tracing so we can do

00:25:06,880 --> 00:25:08,799
everything that we wanted to do with

00:25:08,159 --> 00:25:10,400
tracing

00:25:08,799 --> 00:25:12,400
even more than asteroids and i'm going

00:25:10,400 --> 00:25:15,760
to show it

00:25:12,400 --> 00:25:16,640
very soon in a safe way in a more

00:25:15,760 --> 00:25:18,960
performant in

00:25:16,640 --> 00:25:19,840
in a more performant way and this is

00:25:18,960 --> 00:25:23,120
really why the

00:25:19,840 --> 00:25:24,640
ebpf is so important today uh by the way

00:25:23,120 --> 00:25:28,240
the name edpf

00:25:24,640 --> 00:25:31,360
um doesn't really make sense today uh

00:25:28,240 --> 00:25:34,799
it carries a lot of uh legacy with it

00:25:31,360 --> 00:25:35,120
it originated as a packet filter utility

00:25:34,799 --> 00:25:37,360
to

00:25:35,120 --> 00:25:38,159
to filter the packets in the kernel and

00:25:37,360 --> 00:25:41,039
then

00:25:38,159 --> 00:25:42,159
it was related to berkeley's uh bsd and

00:25:41,039 --> 00:25:45,600
then it was extended

00:25:42,159 --> 00:25:46,960
to to do more than this

00:25:45,600 --> 00:25:49,200
this is why it's called extended

00:25:46,960 --> 00:25:52,640
extended berkeley packet filter

00:25:49,200 --> 00:25:54,799
ebpf not a lot of uh

00:25:52,640 --> 00:25:56,400
not not a very meaningful name today but

00:25:54,799 --> 00:25:58,480
still this is the name and the

00:25:56,400 --> 00:26:01,279
technology itself is amazing

00:25:58,480 --> 00:26:01,679
um so in a high level what it means is

00:26:01,279 --> 00:26:03,039
that

00:26:01,679 --> 00:26:05,120
the application is going to run

00:26:03,039 --> 00:26:07,520
somewhere on the stack in user space

00:26:05,120 --> 00:26:08,960
in a container it's going it's going to

00:26:07,520 --> 00:26:10,480
make a system call at some point or

00:26:08,960 --> 00:26:13,120
another because

00:26:10,480 --> 00:26:14,240
every resource that it needs to work

00:26:13,120 --> 00:26:18,240
with

00:26:14,240 --> 00:26:20,240
a network called if right into a file

00:26:18,240 --> 00:26:21,760
everything has to go through the

00:26:20,240 --> 00:26:24,480
operating system

00:26:21,760 --> 00:26:25,760
and this is where we're at because we

00:26:24,480 --> 00:26:28,559
have injected

00:26:25,760 --> 00:26:29,760
our ebpf probes into the kernel we will

00:26:28,559 --> 00:26:33,600
be waiting there

00:26:29,760 --> 00:26:34,720
and intercepting those requests from the

00:26:33,600 --> 00:26:37,120
applications

00:26:34,720 --> 00:26:40,240
and at this point of interception we can

00:26:37,120 --> 00:26:44,240
do a lot of interesting things

00:26:40,240 --> 00:26:47,520
so this is a very very high level

00:26:44,240 --> 00:26:49,840
explanation of what ebpf means for us

00:26:47,520 --> 00:26:50,799
and this is what we are using for our

00:26:49,840 --> 00:26:54,000
container

00:26:50,799 --> 00:26:55,840
scanning tool we've actually took this

00:26:54,000 --> 00:26:59,360
work and open source it

00:26:55,840 --> 00:27:02,690
and we have a project on github

00:26:59,360 --> 00:27:03,760
that is called tracy and

00:27:02,690 --> 00:27:07,600
[Music]

00:27:03,760 --> 00:27:10,559
this is basically the engine

00:27:07,600 --> 00:27:11,840
behind our commercial offering container

00:27:10,559 --> 00:27:14,799
scanning tools

00:27:11,840 --> 00:27:17,440
so it is completely open source under a

00:27:14,799 --> 00:27:20,880
permissive license apache 2.

00:27:17,440 --> 00:27:23,520
we have external contributors and

00:27:20,880 --> 00:27:24,640
it is uh it is very interesting uh

00:27:23,520 --> 00:27:27,360
project for you to

00:27:24,640 --> 00:27:28,799
look at if you are interested in ebtf or

00:27:27,360 --> 00:27:31,120
system tracing

00:27:28,799 --> 00:27:32,399
what's special about this project

00:27:31,120 --> 00:27:34,720
besides the fact that

00:27:32,399 --> 00:27:35,840
it provides similar functionality to s

00:27:34,720 --> 00:27:38,960
trace

00:27:35,840 --> 00:27:39,760
but it is safer and a lot more

00:27:38,960 --> 00:27:43,039
performant

00:27:39,760 --> 00:27:43,520
by the way what's interesting about it

00:27:43,039 --> 00:27:46,840
is that

00:27:43,520 --> 00:27:49,039
it it was built for security so when we

00:27:46,840 --> 00:27:52,559
instrument

00:27:49,039 --> 00:27:55,840
a function in the kernel we can not only

00:27:52,559 --> 00:27:58,799
uh report it like asterisk does

00:27:55,840 --> 00:28:00,080
we can we can do a lot of more

00:27:58,799 --> 00:28:02,480
interesting things with it that i'm

00:28:00,080 --> 00:28:04,399
going to show in a second

00:28:02,480 --> 00:28:06,480
and we can also trace other things

00:28:04,399 --> 00:28:09,360
besides system cost this is

00:28:06,480 --> 00:28:10,880
something very unique we can also

00:28:09,360 --> 00:28:13,200
instrument

00:28:10,880 --> 00:28:14,000
just arbitrary functions within the

00:28:13,200 --> 00:28:16,480
kernel

00:28:14,000 --> 00:28:18,320
that we're interested in and this

00:28:16,480 --> 00:28:21,360
produces

00:28:18,320 --> 00:28:24,960
a much higher quality of data for us to

00:28:21,360 --> 00:28:27,360
analyze in order to detect behavioral

00:28:24,960 --> 00:28:27,360
patterns

00:28:28,799 --> 00:28:35,440
all right so what we're going to do now

00:28:32,559 --> 00:28:36,960
is to take a look at tracy and see how

00:28:35,440 --> 00:28:39,679
it can help us

00:28:36,960 --> 00:28:42,840
solve a few issues some of them we have

00:28:39,679 --> 00:28:45,840
already started to discuss

00:28:42,840 --> 00:28:45,840
previously

00:28:51,120 --> 00:28:53,440
right

00:28:56,960 --> 00:29:01,760
so you remember that packed binary that

00:29:00,000 --> 00:29:04,799
we have

00:29:01,760 --> 00:29:06,960
looked at previously using s trace

00:29:04,799 --> 00:29:09,279
we were able to manually detect that it

00:29:06,960 --> 00:29:12,559
was using stress i want to first of all

00:29:09,279 --> 00:29:17,039
show you how it is done using tracy so

00:29:12,559 --> 00:29:17,039
i'm going to run tracy

00:29:18,000 --> 00:29:27,840
let's do this

00:29:30,399 --> 00:29:34,399
all right so this is tracy and there's a

00:29:33,039 --> 00:29:35,360
lot of options here i'm not going to

00:29:34,399 --> 00:29:37,600
cover them all

00:29:35,360 --> 00:29:40,240
i'm just at this point trying to reach

00:29:37,600 --> 00:29:42,399
the same result as we have

00:29:40,240 --> 00:29:43,440
done with s trace so i'm telling it to

00:29:42,399 --> 00:29:46,559
trace exact

00:29:43,440 --> 00:29:52,000
to the e i'm telling it to trace

00:29:46,559 --> 00:29:55,600
emma and i'm telling you to trace

00:29:52,000 --> 00:29:59,120
and protect right

00:29:55,600 --> 00:30:03,279
and i'm also going to prepare

00:29:59,120 --> 00:30:06,320
to run my hello world

00:30:03,279 --> 00:30:10,480
the pact version let's

00:30:06,320 --> 00:30:14,320
start tracy is now registering the

00:30:10,480 --> 00:30:16,960
the ebtf probes and we can now run

00:30:14,320 --> 00:30:18,000
the binary and we see a very similar

00:30:16,960 --> 00:30:22,080
output to what we

00:30:18,000 --> 00:30:25,120
have seen before we see exactly

00:30:22,080 --> 00:30:27,760
for the entry point we see the m-up and

00:30:25,120 --> 00:30:27,760
then protect

00:30:28,799 --> 00:30:32,559
system calls we see that the arguments

00:30:31,760 --> 00:30:35,200
to these calls

00:30:32,559 --> 00:30:37,600
in this case that someone requested a

00:30:35,200 --> 00:30:40,960
executable memory region

00:30:37,600 --> 00:30:43,440
so far pretty similar to space

00:30:40,960 --> 00:30:44,559
now i'm going to do the same but to turn

00:30:43,440 --> 00:30:46,720
on this

00:30:44,559 --> 00:30:48,840
very interesting flag that's called

00:30:46,720 --> 00:30:53,600
security

00:30:48,840 --> 00:30:53,600
events security events

00:30:56,159 --> 00:31:02,840
and oh sorry

00:30:59,919 --> 00:31:04,880
how did i miss you security alerts my

00:31:02,840 --> 00:31:06,720
dad

00:31:04,880 --> 00:31:08,000
i'm going to run the same packed

00:31:06,720 --> 00:31:12,159
executable

00:31:08,000 --> 00:31:15,600
and this time almost the same output

00:31:12,159 --> 00:31:19,440
but this time you can see here that

00:31:15,600 --> 00:31:22,559
we have a new kind of alerts here

00:31:19,440 --> 00:31:23,200
mem prot alert and this is basically

00:31:22,559 --> 00:31:26,080
tracy

00:31:23,200 --> 00:31:26,799
telling us hey we've noticed that the

00:31:26,080 --> 00:31:28,480
protection

00:31:26,799 --> 00:31:30,880
of this memory region has changed to

00:31:28,480 --> 00:31:34,480
executable this is a notable

00:31:30,880 --> 00:31:36,240
um event this is not raw data this was

00:31:34,480 --> 00:31:37,840
not collected from the operating system

00:31:36,240 --> 00:31:40,559
this is security insight

00:31:37,840 --> 00:31:41,600
that tracy is adding on top of the raw

00:31:40,559 --> 00:31:43,519
data

00:31:41,600 --> 00:31:45,519
eventually you can see here a state

00:31:43,519 --> 00:31:48,480
machine that is tracking the

00:31:45,519 --> 00:31:49,200
behavioral pattern and it results in

00:31:48,480 --> 00:31:52,159
this

00:31:49,200 --> 00:31:54,720
final alert that protection change to

00:31:52,159 --> 00:31:57,600
executable which is

00:31:54,720 --> 00:31:59,840
a trigger point that you can react to so

00:31:57,600 --> 00:32:01,840
this is very cool tracy is not only

00:31:59,840 --> 00:32:05,440
surfacing raw data

00:32:01,840 --> 00:32:06,559
it is actually producing security

00:32:05,440 --> 00:32:08,480
insights

00:32:06,559 --> 00:32:11,039
but you know tracy can do something even

00:32:08,480 --> 00:32:14,799
better it can actually collect

00:32:11,039 --> 00:32:17,440
the evidence for the security incident

00:32:14,799 --> 00:32:19,200
in this case the embedded binary that

00:32:17,440 --> 00:32:22,320
was run from memory

00:32:19,200 --> 00:32:25,760
it can actually capture this memory

00:32:22,320 --> 00:32:28,960
uh region into a file that you can later

00:32:25,760 --> 00:32:30,559
go on and investigate this is super cool

00:32:28,960 --> 00:32:33,679
so i'm going to run the same

00:32:30,559 --> 00:32:36,320
i will tell tracy to capture

00:32:33,679 --> 00:32:36,720
uh memory files and i'm going to tell it

00:32:36,320 --> 00:32:39,120
to

00:32:36,720 --> 00:32:40,399
clear the output directory before he

00:32:39,120 --> 00:32:43,519
does that

00:32:40,399 --> 00:32:47,279
so run this again

00:32:43,519 --> 00:32:50,159
and run the back version again

00:32:47,279 --> 00:32:51,760
almost the same output except this time

00:32:50,159 --> 00:32:55,039
where we see the

00:32:51,760 --> 00:32:57,360
this uh alert from tracy we also see

00:32:55,039 --> 00:33:00,640
that saving data to

00:32:57,360 --> 00:33:04,240
this file this is the addition

00:33:00,640 --> 00:33:07,200
and we can take a look at this file here

00:33:04,240 --> 00:33:07,200
uh if we look at

00:33:07,519 --> 00:33:11,200
temp tracy this is by default the output

00:33:09,360 --> 00:33:14,320
directory where tracy saves

00:33:11,200 --> 00:33:17,360
stuff we can see that

00:33:14,320 --> 00:33:20,320
we have this same file here and this

00:33:17,360 --> 00:33:23,279
file the contents of this file this is

00:33:20,320 --> 00:33:26,080
not a memory dump this is not the entire

00:33:23,279 --> 00:33:26,880
16 gigabyte of memory this is the

00:33:26,080 --> 00:33:30,480
precise

00:33:26,880 --> 00:33:34,159
memory region that triggered

00:33:30,480 --> 00:33:39,840
this alert so if we take a look

00:33:34,159 --> 00:33:39,840
inside of this file

00:33:41,519 --> 00:33:45,760
so it's under this directory this is the

00:33:44,320 --> 00:33:47,360
name

00:33:45,760 --> 00:33:49,600
so this is the binary data it's not

00:33:47,360 --> 00:33:53,039
readable for us but this is the same

00:33:49,600 --> 00:33:54,880
binary data that you would find if you

00:33:53,039 --> 00:33:56,320
if you were to take a look at the

00:33:54,880 --> 00:34:00,000
original

00:33:56,320 --> 00:34:03,760
embedded binary which is

00:34:00,000 --> 00:34:06,720
the hello world binary it's basically

00:34:03,760 --> 00:34:07,200
the same binary data and you can take

00:34:06,720 --> 00:34:10,800
this

00:34:07,200 --> 00:34:14,399
evidence and analyze it investigate it

00:34:10,800 --> 00:34:15,760
and so on all right so some very cool

00:34:14,399 --> 00:34:19,599
stuff here

00:34:15,760 --> 00:34:21,520
with tracy and by the way this is what i

00:34:19,599 --> 00:34:25,679
meant earlier when i said

00:34:21,520 --> 00:34:27,839
how um ebpf is such a game changer

00:34:25,679 --> 00:34:29,359
for us or for anyone who is doing uh

00:34:27,839 --> 00:34:32,399
system tracing today

00:34:29,359 --> 00:34:33,520
because this is actually running our own

00:34:32,399 --> 00:34:35,679
programs

00:34:33,520 --> 00:34:37,359
in the kernel at the point of

00:34:35,679 --> 00:34:40,639
interception we can do

00:34:37,359 --> 00:34:42,079
all of this very cool stuff we can track

00:34:40,639 --> 00:34:44,800
this state machine

00:34:42,079 --> 00:34:45,280
of uh of behavioral pattern within the

00:34:44,800 --> 00:34:49,679
kernel

00:34:45,280 --> 00:34:53,280
we can copy bits of information

00:34:49,679 --> 00:34:53,599
uh into the um into the user space just

00:34:53,280 --> 00:34:55,919
to

00:34:53,599 --> 00:34:57,520
save it aside we can do a lot of other

00:34:55,919 --> 00:35:00,400
cool stuff

00:34:57,520 --> 00:35:01,680
and uh we actually have a lot of

00:35:00,400 --> 00:35:04,560
interesting things

00:35:01,680 --> 00:35:05,440
for anyone who is interested in system

00:35:04,560 --> 00:35:08,800
tracing

00:35:05,440 --> 00:35:10,400
we've seen the a capture option with the

00:35:08,800 --> 00:35:12,480
mem

00:35:10,400 --> 00:35:13,839
option but we have like capturing of

00:35:12,480 --> 00:35:16,400
executed files

00:35:13,839 --> 00:35:18,560
capturing of written files we have the

00:35:16,400 --> 00:35:21,599
security alerts that we discussed

00:35:18,560 --> 00:35:22,720
we have events which are not only system

00:35:21,599 --> 00:35:24,800
calls we also

00:35:22,720 --> 00:35:25,839
support tracing arbitrary kernel

00:35:24,800 --> 00:35:29,440
functions

00:35:25,839 --> 00:35:32,560
we have container tracing specifically

00:35:29,440 --> 00:35:34,160
so a lot of uh very interesting

00:35:32,560 --> 00:35:37,160
capabilities here

00:35:34,160 --> 00:35:39,599
for a system tracing tool that is

00:35:37,160 --> 00:35:43,280
security-minded

00:35:39,599 --> 00:35:45,680
and tracy is built in the open

00:35:43,280 --> 00:35:48,480
and we welcome you to participate and

00:35:45,680 --> 00:35:48,480
tell us what you think

00:35:48,560 --> 00:35:52,160
and and tracy i remind you is the engine

00:35:50,720 --> 00:35:54,960
for our dynamic scanning

00:35:52,160 --> 00:35:55,760
solution and this session was about

00:35:54,960 --> 00:35:59,200
dynamic

00:35:55,760 --> 00:36:03,280
scanning of containers so i hope

00:35:59,200 --> 00:36:08,320
now maybe it all starting to

00:36:03,280 --> 00:36:11,200
tie together for you how static scanning

00:36:08,320 --> 00:36:13,280
relates to dynamic scanning which

00:36:11,200 --> 00:36:17,119
relates to runtime security

00:36:13,280 --> 00:36:20,160
and how system tracing is enabling

00:36:17,119 --> 00:36:22,560
this dynamic scanning technology i think

00:36:20,160 --> 00:36:23,839
one of my goals here today was to

00:36:22,560 --> 00:36:27,200
explain why

00:36:23,839 --> 00:36:30,320
dynamic scanning is

00:36:27,200 --> 00:36:31,520
distinct from static scanning and from

00:36:30,320 --> 00:36:34,880
runtime security

00:36:31,520 --> 00:36:36,560
even though it draws similar

00:36:34,880 --> 00:36:38,839
characteristics in some ways

00:36:36,560 --> 00:36:40,000
similar technology to random security or

00:36:38,839 --> 00:36:43,119
similar

00:36:40,000 --> 00:36:47,520
requirements such as static scanning

00:36:43,119 --> 00:36:50,640
but still it is a piece of its own

00:36:47,520 --> 00:36:54,480
and i hope that you find this

00:36:50,640 --> 00:36:56,160
idea interesting if you do then

00:36:54,480 --> 00:36:59,440
you can start to explore dynamic

00:36:56,160 --> 00:36:59,440
scanning of your images as well

00:37:01,280 --> 00:37:05,200
so thank you everyone this has been

00:37:03,680 --> 00:37:07,920
great fun

00:37:05,200 --> 00:37:08,480
i think we have a few more minutes for

00:37:07,920 --> 00:37:10,800
questions

00:37:08,480 --> 00:37:11,760
if you don't make it this time you can

00:37:10,800 --> 00:37:15,200
reach out to me

00:37:11,760 --> 00:37:18,720
personally over at twitter i'm at itaisk

00:37:15,200 --> 00:37:23,200
and i wish you a

00:37:18,720 --> 00:37:23,200

YouTube URL: https://www.youtube.com/watch?v=_N_knaHCAv8


