Title: Rust-based, Secure and Lightweight Container Runtime for Embedded Systems - Manabu Sugimoto, Sony
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Rust-based, Secure and Lightweight Container Runtime for Embedded Systems - Manabu Sugimoto, Sony Group Corporation

Linux container is a lightweight virtualization technology that provides isolation and containment for applications. Recently, the container has been adopted by embedded systems because the mechanism is attractive to resource-constrained systems. Unfortunately, the existing container runtimes such as runc do not provide sufficient security and performance for mission-critical embedded systems. This talk presents a rust-based container runtime for embedded systems that enables the container to run at high speed while reducing the runtime memory usage. The runtime has an original fast-startup mechanism that starts the container by leveraging the pre-created container. Furthermore, the runtime offers a fine-grained access control using the new seccomp notify feature. The evaluation shows that the runtime launches the container 7.4x faster with 4.4x less memory usage than runc.
Captions: 
	00:00:00,000 --> 00:00:04,560
hello everyone and welcome to my talk

00:00:02,480 --> 00:00:06,480
today i'd like to talk about

00:00:04,560 --> 00:00:10,559
rust based secure and lightweight

00:00:06,480 --> 00:00:10,559
container on time for emitted systems

00:00:10,639 --> 00:00:13,679
my name is manuel sigmotor i'm a system

00:00:12,559 --> 00:00:17,359
software engineer at

00:00:13,679 --> 00:00:19,680
sony id center my research interests

00:00:17,359 --> 00:00:22,720
are container virtualization unicornos

00:00:19,680 --> 00:00:22,720
and linux kernel

00:00:23,279 --> 00:00:26,880
here is the ultra outline of my

00:00:25,119 --> 00:00:28,960
presentation first

00:00:26,880 --> 00:00:30,880
i'd like to start by talking about linux

00:00:28,960 --> 00:00:32,480
container virtualization and container

00:00:30,880 --> 00:00:34,719
runtime software

00:00:32,480 --> 00:00:36,559
second i want to share how we have

00:00:34,719 --> 00:00:37,440
managed these containers on embedded

00:00:36,559 --> 00:00:39,680
systems

00:00:37,440 --> 00:00:41,840
and the problems of existing control

00:00:39,680 --> 00:00:43,840
alone times

00:00:41,840 --> 00:00:46,000
then let me introduce our raspberries

00:00:43,840 --> 00:00:49,039
secure and lightweight container on time

00:00:46,000 --> 00:00:51,280
optimized for embedded systems after

00:00:49,039 --> 00:00:52,960
that i will show the evaluation of our

00:00:51,280 --> 00:00:55,120
raspberries runtime

00:00:52,960 --> 00:00:56,160
finally i'll talk about the future work

00:00:55,120 --> 00:00:57,440
of our runtime

00:00:56,160 --> 00:00:59,840
under the conclusion of this

00:00:57,440 --> 00:00:59,840
presentation

00:01:00,640 --> 00:01:04,720
so let's start with the first

00:01:02,399 --> 00:01:06,960
introduction

00:01:04,720 --> 00:01:09,040
linux container provides isolation and

00:01:06,960 --> 00:01:11,040
containment for applications

00:01:09,040 --> 00:01:13,439
and this mechanism can prevent the text

00:01:11,040 --> 00:01:15,600
from interested applications

00:01:13,439 --> 00:01:17,360
recently the container has been utilized

00:01:15,600 --> 00:01:19,680
increasingly in embedded

00:01:17,360 --> 00:01:21,360
systems because techniques is more

00:01:19,680 --> 00:01:23,520
attractive to resource concerning the

00:01:21,360 --> 00:01:25,360
systems due to the lightweight

00:01:23,520 --> 00:01:26,560
these containers are created by the

00:01:25,360 --> 00:01:29,920
software it's called

00:01:26,560 --> 00:01:29,920
called container on time

00:01:30,159 --> 00:01:33,840
what is container on time container on

00:01:32,560 --> 00:01:36,000
time is the software that

00:01:33,840 --> 00:01:38,159
spawns and runs containers and is

00:01:36,000 --> 00:01:40,960
responsible for the mechanics of running

00:01:38,159 --> 00:01:43,040
the containers the container runtimes

00:01:40,960 --> 00:01:45,040
such as rancid sometimes are referred to

00:01:43,040 --> 00:01:46,799
as rollable runtimes

00:01:45,040 --> 00:01:48,960
the container runtimes are compatible

00:01:46,799 --> 00:01:50,880
with ocr runtime specification

00:01:48,960 --> 00:01:54,079
to be able to receive requests from

00:01:50,880 --> 00:01:57,600
higher layers such as container d

00:01:54,079 --> 00:01:59,680
rci stands for open container initiative

00:01:57,600 --> 00:02:01,920
as you already know containers are

00:01:59,680 --> 00:02:04,960
implemented using linux namespaces

00:02:01,920 --> 00:02:07,200
c groups capabilities and so on

00:02:04,960 --> 00:02:09,360
so the library controller on time are

00:02:07,200 --> 00:02:12,640
responsible for setting up these linux

00:02:09,360 --> 00:02:12,640
features for containers

00:02:12,879 --> 00:02:16,160
this slide shows the software stack of

00:02:14,720 --> 00:02:18,720
its container on time

00:02:16,160 --> 00:02:19,920
red supports users create containers by

00:02:18,720 --> 00:02:21,840
kubernetes

00:02:19,920 --> 00:02:23,760
first kubernetes of kubernetes

00:02:21,840 --> 00:02:25,280
communicates with high level container

00:02:23,760 --> 00:02:28,640
on time such as container d

00:02:25,280 --> 00:02:30,720
and cryo through cli crs stands for

00:02:28,640 --> 00:02:33,120
container on time interface

00:02:30,720 --> 00:02:34,239
second however runtime employ images

00:02:33,120 --> 00:02:36,959
from registries

00:02:34,239 --> 00:02:37,440
manage them and hands order to available

00:02:36,959 --> 00:02:41,040
runtime

00:02:37,440 --> 00:02:42,879
through all ci lastly notable runtimes

00:02:41,040 --> 00:02:46,800
such as run c create and launch the

00:02:42,879 --> 00:02:46,800
containers using the linux features

00:02:47,120 --> 00:02:52,319
so today's topic is here we're relatable

00:02:49,360 --> 00:02:52,319
control on time

00:02:52,400 --> 00:02:57,440
now i'd like to talk about the

00:02:54,000 --> 00:02:59,280
motivation of our study

00:02:57,440 --> 00:03:01,200
first i'll talk about the requirements

00:02:59,280 --> 00:03:03,200
of embedded systems

00:03:01,200 --> 00:03:04,319
the main difference between general

00:03:03,200 --> 00:03:06,000
purpose systems and

00:03:04,319 --> 00:03:07,680
embedded systems is that embedded

00:03:06,000 --> 00:03:09,440
systems have more restrictions than

00:03:07,680 --> 00:03:11,200
server systems

00:03:09,440 --> 00:03:12,720
in resource constraining the systems the

00:03:11,200 --> 00:03:15,040
memory size is small

00:03:12,720 --> 00:03:16,480
stretch capacity is lower and the cpu is

00:03:15,040 --> 00:03:18,720
not high

00:03:16,480 --> 00:03:20,159
in the case of mission clinical systems

00:03:18,720 --> 00:03:22,080
real-time applications

00:03:20,159 --> 00:03:24,080
run with critical functionality on the

00:03:22,080 --> 00:03:27,120
systems and the systems are

00:03:24,080 --> 00:03:28,720
longer life cycles than servers so we

00:03:27,120 --> 00:03:29,120
needed to manage containers while

00:03:28,720 --> 00:03:32,560
meeting

00:03:29,120 --> 00:03:35,120
these requirements

00:03:32,560 --> 00:03:36,480
how we land continue runtime on such

00:03:35,120 --> 00:03:38,400
embedded systems

00:03:36,480 --> 00:03:40,400
it is difficult to use kubernetes or

00:03:38,400 --> 00:03:42,319
docker on embedded systems because those

00:03:40,400 --> 00:03:44,080
software includes performance overhead

00:03:42,319 --> 00:03:45,280
and high resource usage to manage

00:03:44,080 --> 00:03:47,280
containers

00:03:45,280 --> 00:03:48,879
for example kubernetes and the docker

00:03:47,280 --> 00:03:51,040
includes a high level runtime that

00:03:48,879 --> 00:03:52,560
manages container images

00:03:51,040 --> 00:03:54,720
in the case of the mission critical

00:03:52,560 --> 00:03:56,720
systems we cannot ignore the overhead

00:03:54,720 --> 00:03:58,840
because response time on the system

00:03:56,720 --> 00:04:00,560
should be high for real-time

00:03:58,840 --> 00:04:02,560
applications

00:04:00,560 --> 00:04:04,319
in addition the right operations shot in

00:04:02,560 --> 00:04:06,560
the live span or emmc

00:04:04,319 --> 00:04:07,680
that stands for embedded multimedia card

00:04:06,560 --> 00:04:10,400
that is a standard

00:04:07,680 --> 00:04:12,480
specification of embedded memory please

00:04:10,400 --> 00:04:14,720
look at the figure on the left

00:04:12,480 --> 00:04:17,040
a demo sub such as darkerly always

00:04:14,720 --> 00:04:18,959
writes up rights to metadata files in

00:04:17,040 --> 00:04:21,440
mounts on emmc of embedded

00:04:18,959 --> 00:04:22,400
systems we want to avoid the right

00:04:21,440 --> 00:04:24,320
applications

00:04:22,400 --> 00:04:27,120
as much as possible to extend the

00:04:24,320 --> 00:04:29,280
lifespan of the emmc

00:04:27,120 --> 00:04:31,040
to solve these problems we learned a lot

00:04:29,280 --> 00:04:32,000
about content among time along on the

00:04:31,040 --> 00:04:34,160
systems

00:04:32,000 --> 00:04:36,639
in the figure on the right container on

00:04:34,160 --> 00:04:38,560
timelines without any services

00:04:36,639 --> 00:04:42,400
in this way we can manage containers

00:04:38,560 --> 00:04:44,560
effectively on the systems

00:04:42,400 --> 00:04:46,320
however the existing container on times

00:04:44,560 --> 00:04:47,759
should have some problems in terms of

00:04:46,320 --> 00:04:49,759
security and the right way

00:04:47,759 --> 00:04:51,440
we realize the runtimes on embedded

00:04:49,759 --> 00:04:54,960
systems because runtimes are not

00:04:51,440 --> 00:04:57,199
optimized for systems first in terms of

00:04:54,960 --> 00:04:59,520
security linux capabilities are not fine

00:04:57,199 --> 00:05:02,080
land access control

00:04:59,520 --> 00:05:04,000
when a user wants to use a ping command

00:05:02,080 --> 00:05:05,039
the user needs to have a cab network

00:05:04,000 --> 00:05:07,919
capability

00:05:05,039 --> 00:05:10,320
however cabinet role also allows users

00:05:07,919 --> 00:05:12,560
to run up spoofing attacks

00:05:10,320 --> 00:05:13,520
second the looters container by username

00:05:12,560 --> 00:05:16,320
spaces is

00:05:13,520 --> 00:05:18,320
very strict for the systems the username

00:05:16,320 --> 00:05:21,039
space allows the containers that

00:05:18,320 --> 00:05:23,680
are pre um privileged outside the name

00:05:21,039 --> 00:05:25,520
space to have root privileges

00:05:23,680 --> 00:05:27,680
but at the same time limiting their

00:05:25,520 --> 00:05:29,120
scope of that privilege to the name

00:05:27,680 --> 00:05:31,280
space

00:05:29,120 --> 00:05:33,120
however the reader's container cannot

00:05:31,280 --> 00:05:35,199
emulate all system code because the

00:05:33,120 --> 00:05:37,360
containers in the username space cannot

00:05:35,199 --> 00:05:40,000
manipulate the global resources

00:05:37,360 --> 00:05:40,880
in the systems in the case of the

00:05:40,000 --> 00:05:42,800
embedded systems

00:05:40,880 --> 00:05:44,400
it is not good because some embedded

00:05:42,800 --> 00:05:46,720
system embedded applications

00:05:44,400 --> 00:05:48,080
needed to access devices via such mount

00:05:46,720 --> 00:05:50,720
system core

00:05:48,080 --> 00:05:53,120
second in terms of lightweight container

00:05:50,720 --> 00:05:53,440
setup time is not fast enough for real

00:05:53,120 --> 00:05:55,919
time

00:05:53,440 --> 00:05:58,080
system most container long time such as

00:05:55,919 --> 00:05:59,759
ranci are written in guru language

00:05:58,080 --> 00:06:01,280
the language is very good but

00:05:59,759 --> 00:06:03,280
unfortunately the

00:06:01,280 --> 00:06:04,639
application binary size is big for the

00:06:03,280 --> 00:06:06,560
embedded systems and the garbage

00:06:04,639 --> 00:06:08,639
collection by go run time increase high

00:06:06,560 --> 00:06:11,120
cpu utilization

00:06:08,639 --> 00:06:14,000
so we have to solve the problems in

00:06:11,120 --> 00:06:14,000
embedded systems

00:06:14,080 --> 00:06:19,199
okay now i'll talk proposal to solve

00:06:16,479 --> 00:06:22,000
these problems

00:06:19,199 --> 00:06:23,600
here i propose sl run time that is rust

00:06:22,000 --> 00:06:26,160
based secure and the light which could

00:06:23,600 --> 00:06:28,639
turn on on timing for embedded systems

00:06:26,160 --> 00:06:29,759
sm runtime is implemented freely in rust

00:06:28,639 --> 00:06:32,000
with modern flights

00:06:29,759 --> 00:06:34,479
and lca compatible minimal container on

00:06:32,000 --> 00:06:36,479
time for embedded systems

00:06:34,479 --> 00:06:37,680
slr on time is largely divided into a

00:06:36,479 --> 00:06:40,240
secure mechanism and

00:06:37,680 --> 00:06:41,360
right-wing mechanism in the secure

00:06:40,240 --> 00:06:42,960
features

00:06:41,360 --> 00:06:44,960
isolation by container for high

00:06:42,960 --> 00:06:46,479
dependability the essential runtime

00:06:44,960 --> 00:06:49,280
has a fine landing access control and

00:06:46,479 --> 00:06:51,599
the memory safety by rust forcibility

00:06:49,280 --> 00:06:53,680
in the lightweight mechanism raw memory

00:06:51,599 --> 00:06:55,520
usage and the smaller binary sizes from

00:06:53,680 --> 00:06:57,599
the benefits for the rest

00:06:55,520 --> 00:06:59,919
and the first setup that is our original

00:06:57,599 --> 00:07:01,840
features and their real-time support for

00:06:59,919 --> 00:07:04,319
embedded

00:07:01,840 --> 00:07:07,039
i'll explain these mechanisms in detail

00:07:04,319 --> 00:07:07,039
later slide

00:07:07,280 --> 00:07:12,639
here you can see the compiling table of

00:07:09,680 --> 00:07:14,639
srn time and existing container on times

00:07:12,639 --> 00:07:16,960
its runtime is more lightweight and

00:07:14,639 --> 00:07:17,599
secure than their existing controller on

00:07:16,960 --> 00:07:20,720
time

00:07:17,599 --> 00:07:21,919
the finally size base runtime is 2.63

00:07:20,720 --> 00:07:24,400
megabyte

00:07:21,919 --> 00:07:26,319
so that is much smaller resiliency

00:07:24,400 --> 00:07:26,960
container long-term radical developed by

00:07:26,319 --> 00:07:29,440
oracle

00:07:26,960 --> 00:07:30,160
is also implemented in rus-like external

00:07:29,440 --> 00:07:32,400
time

00:07:30,160 --> 00:07:33,360
however the development was stopped in

00:07:32,400 --> 00:07:35,520
00:07:33,360 --> 00:07:36,960
and the repository has already been

00:07:35,520 --> 00:07:39,120
archived

00:07:36,960 --> 00:07:41,520
the rust features and creates use in

00:07:39,120 --> 00:07:44,000
radical have been updated because rust

00:07:41,520 --> 00:07:46,240
is a fast growing language

00:07:44,000 --> 00:07:50,080
compared to radical acronym time is the

00:07:46,240 --> 00:07:50,080
latest rats based content around time

00:07:51,520 --> 00:07:56,879
why did we choose ras over golang or cc

00:07:54,240 --> 00:07:59,039
practice to develop content around time

00:07:56,879 --> 00:08:00,639
the answer is that rust is a great fit

00:07:59,039 --> 00:08:03,120
for embedded systems

00:08:00,639 --> 00:08:04,800
first the performance is equivalent to

00:08:03,120 --> 00:08:06,960
cc press press

00:08:04,800 --> 00:08:09,039
second last guarantees memory safety

00:08:06,960 --> 00:08:11,120
without garbage collection

00:08:09,039 --> 00:08:14,080
third the rust community has awesome

00:08:11,120 --> 00:08:15,919
place for developing the content on time

00:08:14,080 --> 00:08:17,280
i'll introduce this phrase in the next

00:08:15,919 --> 00:08:19,919
slide

00:08:17,280 --> 00:08:21,199
lastly ras ffizer stands for following

00:08:19,919 --> 00:08:24,639
function interface is

00:08:21,199 --> 00:08:26,560
very helpful to bind linux api go rank

00:08:24,639 --> 00:08:28,319
adapted by many existing container

00:08:26,560 --> 00:08:30,240
runtimes is also good

00:08:28,319 --> 00:08:31,520
but has some limitations in embedded

00:08:30,240 --> 00:08:33,599
systems

00:08:31,520 --> 00:08:35,839
the goal has a problem interacting with

00:08:33,599 --> 00:08:38,080
name spaces by go run time

00:08:35,839 --> 00:08:40,399
in addition the application finally says

00:08:38,080 --> 00:08:42,240
is big compared to rust and they go

00:08:40,399 --> 00:08:45,760
based around time include performance

00:08:42,240 --> 00:08:45,760
overhead by garbage collection

00:08:47,120 --> 00:08:51,279
here i'd like to share the clients for

00:08:49,120 --> 00:08:54,080
developing the container on time

00:08:51,279 --> 00:08:55,600
rust has already a useful class for

00:08:54,080 --> 00:08:58,480
creating containers such as

00:08:55,600 --> 00:09:00,000
capability remit c group second and

00:08:58,480 --> 00:09:02,080
things like that

00:09:00,000 --> 00:09:03,839
passively phrase is used for the fine

00:09:02,080 --> 00:09:04,320
grained access control of the slr on

00:09:03,839 --> 00:09:06,160
time

00:09:04,320 --> 00:09:09,120
and the co-affinity is used for the

00:09:06,160 --> 00:09:11,200
excel on time real time support

00:09:09,120 --> 00:09:13,360
as you already know we can develop the

00:09:11,200 --> 00:09:15,519
software easily using crafts or json

00:09:13,360 --> 00:09:18,959
bitmaps or ci of json format to

00:09:15,519 --> 00:09:18,959
interrupt data structures

00:09:19,440 --> 00:09:22,800
this slide shows that srm times

00:09:21,360 --> 00:09:24,800
architecture overview

00:09:22,800 --> 00:09:26,000
in the next few slides i will show the

00:09:24,800 --> 00:09:29,440
lightweight mechanism

00:09:26,000 --> 00:09:33,120
and secure mechanism first

00:09:29,440 --> 00:09:33,519
lightweight mechanism i will explain the

00:09:33,120 --> 00:09:37,600
first

00:09:33,519 --> 00:09:39,600
setup feature the process up around

00:09:37,600 --> 00:09:41,600
choose a container speedly by leveraging

00:09:39,600 --> 00:09:44,080
a pre-created container

00:09:41,600 --> 00:09:45,760
by using the first setup sron time can

00:09:44,080 --> 00:09:48,080
omit time before initializing the

00:09:45,760 --> 00:09:50,720
runtime and creating the container

00:09:48,080 --> 00:09:51,200
faster setup replaces only the execution

00:09:50,720 --> 00:09:53,760
process

00:09:51,200 --> 00:09:55,760
inside the container at a setup so the

00:09:53,760 --> 00:09:58,480
runtime can be used as a configuration

00:09:55,760 --> 00:10:00,000
except for the execution process this

00:09:58,480 --> 00:10:00,959
feature is useful because some

00:10:00,000 --> 00:10:02,720
containers use

00:10:00,959 --> 00:10:04,959
actually same configuration such as the

00:10:02,720 --> 00:10:05,519
namespaces capabilities and things like

00:10:04,959 --> 00:10:07,519
that

00:10:05,519 --> 00:10:09,120
except for the execution process inside

00:10:07,519 --> 00:10:10,800
the container

00:10:09,120 --> 00:10:14,000
please look at the figure on the left

00:10:10,800 --> 00:10:16,560
side now some containers are created

00:10:14,000 --> 00:10:18,640
these containers do not align yet after

00:10:16,560 --> 00:10:19,279
that when you need to run a real-time

00:10:18,640 --> 00:10:22,160
application

00:10:19,279 --> 00:10:23,360
srn term replaces the dummy process with

00:10:22,160 --> 00:10:25,839
real-time application

00:10:23,360 --> 00:10:27,040
you want to run please look at the

00:10:25,839 --> 00:10:29,120
figure on the right

00:10:27,040 --> 00:10:30,320
the normal run has initializing runtime

00:10:29,120 --> 00:10:32,640
creating a container

00:10:30,320 --> 00:10:33,519
and starting the container phase in the

00:10:32,640 --> 00:10:35,760
case of the first

00:10:33,519 --> 00:10:37,760
setup you can reduce the time of

00:10:35,760 --> 00:10:39,200
initializing return time and creating

00:10:37,760 --> 00:10:41,200
the container

00:10:39,200 --> 00:10:44,480
so it is possible to run the container

00:10:41,200 --> 00:10:44,480
faster than normal run

00:10:44,640 --> 00:10:48,800
in addition slr on time has a real time

00:10:46,720 --> 00:10:51,519
support feature that enables runtime to

00:10:48,800 --> 00:10:54,079
set a cpu affinity advanced setup

00:10:51,519 --> 00:10:56,320
by using the future users can set cpu

00:10:54,079 --> 00:10:58,800
affinity depending on the cpu rolled at

00:10:56,320 --> 00:10:58,800
a setup

00:10:59,360 --> 00:11:02,880
here i'd like to talk about the control

00:11:01,360 --> 00:11:05,600
flow of the first setup and

00:11:02,880 --> 00:11:08,399
real-time support red supports a user

00:11:05,600 --> 00:11:10,480
creates a container by slr on time

00:11:08,399 --> 00:11:12,839
first the user prepares a container

00:11:10,480 --> 00:11:15,839
configuration file config.json in

00:11:12,839 --> 00:11:16,959
advance the configuration describes the

00:11:15,839 --> 00:11:20,160
dummy process as an

00:11:16,959 --> 00:11:22,399
execution processing system container

00:11:20,160 --> 00:11:25,279
after that the user issues create

00:11:22,399 --> 00:11:28,079
application and sr on time initializing

00:11:25,279 --> 00:11:28,880
the container based on the configuration

00:11:28,079 --> 00:11:30,720
at the end of

00:11:28,880 --> 00:11:32,560
this phase the container collection is

00:11:30,720 --> 00:11:35,519
complete and all settings about

00:11:32,560 --> 00:11:36,560
container initialization are complete at

00:11:35,519 --> 00:11:38,800
this point

00:11:36,560 --> 00:11:41,519
the container goes into a clay create

00:11:38,800 --> 00:11:44,640
status and slam time and monitors are a

00:11:41,519 --> 00:11:46,880
file descriptor then when the user wants

00:11:44,640 --> 00:11:49,279
to run the container using process setup

00:11:46,880 --> 00:11:51,279
the user creates the processor json

00:11:49,279 --> 00:11:53,040
describes the real-time process to be

00:11:51,279 --> 00:11:56,160
executed inside the container

00:11:53,040 --> 00:11:58,480
and the cpu core that is due the process

00:11:56,160 --> 00:11:59,360
then the user runs the first setup and

00:11:58,480 --> 00:12:01,279
the slr runtime

00:11:59,360 --> 00:12:02,720
writes the contents of the first startup

00:12:01,279 --> 00:12:05,040
configuration

00:12:02,720 --> 00:12:07,440
at the moment since the container that

00:12:05,040 --> 00:12:09,680
is waiting can read

00:12:07,440 --> 00:12:11,360
file descriptor just run runtime causes

00:12:09,680 --> 00:12:13,839
the container to resume

00:12:11,360 --> 00:12:16,240
execution so as long time sets the

00:12:13,839 --> 00:12:19,440
process under the container runs

00:12:16,240 --> 00:12:19,440
execution process

00:12:19,920 --> 00:12:25,279
now let me move on the secure mechanism

00:12:22,160 --> 00:12:27,040
of srn time

00:12:25,279 --> 00:12:28,399
alright explains the fine gland access

00:12:27,040 --> 00:12:32,880
control this is

00:12:28,399 --> 00:12:34,800
here it's a runtime the fine line access

00:12:32,880 --> 00:12:37,200
control enables the routers containers

00:12:34,800 --> 00:12:39,040
to execute the system code safely

00:12:37,200 --> 00:12:40,800
by using this fine blend access control

00:12:39,040 --> 00:12:41,440
feature the looters container can

00:12:40,800 --> 00:12:43,839
emulate

00:12:41,440 --> 00:12:45,680
even system course that changes gravel

00:12:43,839 --> 00:12:47,760
resources because the final and access

00:12:45,680 --> 00:12:49,440
control server emulates assessment core

00:12:47,760 --> 00:12:51,360
in user space on the behalf of the

00:12:49,440 --> 00:12:53,279
container based on the security policy

00:12:51,360 --> 00:12:57,120
that is set in advanced by the

00:12:53,279 --> 00:12:59,279
administrator please look at the figure

00:12:57,120 --> 00:13:01,680
now we have the root raise container a

00:12:59,279 --> 00:13:03,680
and b and the fine gland access control

00:13:01,680 --> 00:13:05,760
server with the security policy that

00:13:03,680 --> 00:13:06,240
allows container aid to the mount tempe

00:13:05,760 --> 00:13:08,160
fs

00:13:06,240 --> 00:13:10,079
and the profits container b from zooming

00:13:08,160 --> 00:13:12,240
amount temperatures

00:13:10,079 --> 00:13:15,519
if container a does mount temperatures

00:13:12,240 --> 00:13:18,079
the server catches the mount system call

00:13:15,519 --> 00:13:19,279
before executing it checks whether the

00:13:18,079 --> 00:13:21,360
destination of the

00:13:19,279 --> 00:13:22,800
amount is temperature under the

00:13:21,360 --> 00:13:26,560
performance a performance

00:13:22,800 --> 00:13:28,959
amount on behalf of the container a

00:13:26,560 --> 00:13:30,880
thanks to this mechanism the router's

00:13:28,959 --> 00:13:32,240
containers can issue the mount system

00:13:30,880 --> 00:13:34,560
call safely

00:13:32,240 --> 00:13:35,279
if container b does not does mount

00:13:34,560 --> 00:13:37,279
tempest

00:13:35,279 --> 00:13:38,880
the server denies amount because of the

00:13:37,279 --> 00:13:41,199
security policy

00:13:38,880 --> 00:13:43,360
this fine land access control mechanism

00:13:41,199 --> 00:13:45,760
is achieved using the new sitcom notify

00:13:43,360 --> 00:13:45,760
feature

00:13:45,920 --> 00:13:50,639
here i'll explain the second notified

00:13:48,399 --> 00:13:54,320
feature that is introduced in linux

00:13:50,639 --> 00:13:56,560
5.0 the second nullify provides a way to

00:13:54,320 --> 00:13:57,839
handle a particular system call in user

00:13:56,560 --> 00:14:00,000
space

00:13:57,839 --> 00:14:01,680
now in this example we have a container

00:14:00,000 --> 00:14:02,560
and a second agent which handles the

00:14:01,680 --> 00:14:05,040
system course

00:14:02,560 --> 00:14:07,199
on behalf of the container first the

00:14:05,040 --> 00:14:09,680
container will issue a system call

00:14:07,199 --> 00:14:12,160
second second catches a cisco call and

00:14:09,680 --> 00:14:15,279
executes a ppf program and the bpf

00:14:12,160 --> 00:14:17,600
returns notify after that

00:14:15,279 --> 00:14:18,959
sitcom asks the circum agent to want to

00:14:17,600 --> 00:14:21,279
run the system call

00:14:18,959 --> 00:14:22,880
and the agent makes a decision on

00:14:21,279 --> 00:14:24,240
whether the container performs the

00:14:22,880 --> 00:14:26,320
seismical

00:14:24,240 --> 00:14:28,079
to make the decision to set compensation

00:14:26,320 --> 00:14:31,199
to read the seismic or arguments

00:14:28,079 --> 00:14:33,440
and validate the system goal if okay the

00:14:31,199 --> 00:14:35,839
agent performs the system goal on behalf

00:14:33,440 --> 00:14:38,399
of the behalf of the process and

00:14:35,839 --> 00:14:40,079
otherwise rejects the systemic goal

00:14:38,399 --> 00:14:43,440
when the agent can successfully

00:14:40,079 --> 00:14:45,760
successfully execute a multi-system call

00:14:43,440 --> 00:14:48,800
agent sets the return value and return

00:14:45,760 --> 00:14:48,800
it to the container

00:14:49,120 --> 00:14:53,199
here this slide shows how their

00:14:51,440 --> 00:14:54,880
experimental implements find glenda

00:14:53,199 --> 00:14:55,920
access control using the cell comp

00:14:54,880 --> 00:14:58,480
notify

00:14:55,920 --> 00:15:00,720
first a system administrator launches a

00:14:58,480 --> 00:15:03,120
final and access control server resolute

00:15:00,720 --> 00:15:05,120
before starting a container

00:15:03,120 --> 00:15:07,120
second user runs a container using

00:15:05,120 --> 00:15:08,880
config.json that describes the set

00:15:07,120 --> 00:15:10,720
combinatory

00:15:08,880 --> 00:15:12,800
a few months ago ocl on time

00:15:10,720 --> 00:15:15,920
specification added the second notify

00:15:12,800 --> 00:15:18,240
support to use it in containers

00:15:15,920 --> 00:15:18,959
in the configuration file listener first

00:15:18,240 --> 00:15:21,040
specifies

00:15:18,959 --> 00:15:23,760
the path of unix domain socket which is

00:15:21,040 --> 00:15:25,680
used by the component for action

00:15:23,760 --> 00:15:28,000
a user will create a router's container

00:15:25,680 --> 00:15:30,959
using with configuration

00:15:28,000 --> 00:15:31,600
after srm term receives a create request

00:15:30,959 --> 00:15:33,440
address

00:15:31,600 --> 00:15:36,320
runtime initializes a container and

00:15:33,440 --> 00:15:38,480
creates a second notify file descriptor

00:15:36,320 --> 00:15:41,839
then the runtime passes the descriptor

00:15:38,480 --> 00:15:41,839
to the server

00:15:42,000 --> 00:15:46,959
i will show the demo of findland access

00:15:44,399 --> 00:15:46,959
control

00:15:50,000 --> 00:15:53,120
our config.json describes that execution

00:15:52,480 --> 00:15:56,720
process is

00:15:53,120 --> 00:15:59,199
shell and the username space

00:15:56,720 --> 00:16:00,320
setting and there's a comp notify

00:15:59,199 --> 00:16:04,079
configuration

00:16:00,320 --> 00:16:05,920
in this demo a limits mount seismic call

00:16:04,079 --> 00:16:07,839
please look at the top right first i

00:16:05,920 --> 00:16:09,600
want to find land access control server

00:16:07,839 --> 00:16:10,959
that allows the container to the mount

00:16:09,600 --> 00:16:13,920
only when the destination

00:16:10,959 --> 00:16:15,839
is flew directly second runs in routers

00:16:13,920 --> 00:16:18,639
container buyers along time

00:16:15,839 --> 00:16:19,440
the user id is not root is root inside

00:16:18,639 --> 00:16:22,320
the container

00:16:19,440 --> 00:16:23,600
but on the host messenger user is

00:16:22,320 --> 00:16:26,880
non-loot

00:16:23,600 --> 00:16:28,720
now if he is not mounted when i try to

00:16:26,880 --> 00:16:31,040
mount bar the mount fed to because

00:16:28,720 --> 00:16:32,639
destination buys not allowed suburb

00:16:31,040 --> 00:16:34,320
you can see the error message in the

00:16:32,639 --> 00:16:37,519
server

00:16:34,320 --> 00:16:40,320
however if i mount food directly the

00:16:37,519 --> 00:16:42,880
mount was successful

00:16:40,320 --> 00:16:43,680
or we can confirm that the food directly

00:16:42,880 --> 00:16:51,839
is mounted

00:16:43,680 --> 00:16:51,839
correctly inside the rootless container

00:16:53,199 --> 00:16:57,519
now let me move on the evaluation of esl

00:16:56,000 --> 00:16:59,440
on time

00:16:57,519 --> 00:17:00,639
the aberration goals are measuring two

00:16:59,440 --> 00:17:02,800
types of start time

00:17:00,639 --> 00:17:04,720
normal run and faster setup and the

00:17:02,800 --> 00:17:05,280
memory consumption of the container on

00:17:04,720 --> 00:17:07,439
times

00:17:05,280 --> 00:17:09,760
the existing runtimes that we use in

00:17:07,439 --> 00:17:10,319
this evaluation runs to see singularity

00:17:09,760 --> 00:17:12,480
run c

00:17:10,319 --> 00:17:13,919
series and right curve in the

00:17:12,480 --> 00:17:15,520
experimental setup

00:17:13,919 --> 00:17:17,839
original runtimes uses the same

00:17:15,520 --> 00:17:19,439
config.json

00:17:17,839 --> 00:17:21,520
remove the c grip's configuration

00:17:19,439 --> 00:17:22,480
because s runtime does not support it

00:17:21,520 --> 00:17:24,079
yet

00:17:22,480 --> 00:17:26,000
then we learn the container runtimes

00:17:24,079 --> 00:17:28,640
alone without any client tools

00:17:26,000 --> 00:17:31,200
the container executes to execute true

00:17:28,640 --> 00:17:33,360
commands inside the containers

00:17:31,200 --> 00:17:35,200
the result of a startup time shows that

00:17:33,360 --> 00:17:36,960
sron time is the fastest among the

00:17:35,200 --> 00:17:39,039
existing continental run times

00:17:36,960 --> 00:17:41,280
because the runtime is minimal please

00:17:39,039 --> 00:17:43,280
look at the graph on the left side

00:17:41,280 --> 00:17:46,160
the normal round of srn time achieves

00:17:43,280 --> 00:17:48,240
7.4 times speed up compared to run c

00:17:46,160 --> 00:17:50,160
the radical is also rust based container

00:17:48,240 --> 00:17:51,679
on time but restaurant time is much

00:17:50,160 --> 00:17:53,360
faster than regular

00:17:51,679 --> 00:17:55,360
please look at the graph on the right

00:17:53,360 --> 00:17:58,400
side process setup time

00:17:55,360 --> 00:18:01,840
is a 5.1 millisecond and first up

00:17:58,400 --> 00:18:02,559
start up achieves 1.5 times speed up

00:18:01,840 --> 00:18:05,840
compared to

00:18:02,559 --> 00:18:08,160
the normal run here this slide shows the

00:18:05,840 --> 00:18:09,919
memory usage of the container runtimes

00:18:08,160 --> 00:18:13,760
the result of the memory usage shows

00:18:09,919 --> 00:18:16,480
that sron time is 3.824

00:18:13,760 --> 00:18:17,679
and it is small compared to go based or

00:18:16,480 --> 00:18:19,679
controller end times

00:18:17,679 --> 00:18:21,600
the important point here is that srn

00:18:19,679 --> 00:18:23,760
times memory usage is equivalent to

00:18:21,600 --> 00:18:25,440
serum written in c language

00:18:23,760 --> 00:18:27,520
c is the most preferred language for

00:18:25,440 --> 00:18:31,039
embedded systems paragraphs is also a

00:18:27,520 --> 00:18:31,039
great fit for the systems

00:18:31,200 --> 00:18:36,880
let me move on the last section summary

00:18:34,240 --> 00:18:37,600
here i'll talk about the future work

00:18:36,880 --> 00:18:39,679
first of all

00:18:37,600 --> 00:18:41,280
we need to make sr long time fully

00:18:39,679 --> 00:18:42,799
compliant with australian time

00:18:41,280 --> 00:18:44,880
specification

00:18:42,799 --> 00:18:46,320
currently sr antenna does not support

00:18:44,880 --> 00:18:48,480
some features such as c

00:18:46,320 --> 00:18:51,280
groups or ci and things like that

00:18:48,480 --> 00:18:53,679
because serrante is a research prototype

00:18:51,280 --> 00:18:55,360
second we need to enable kubernetes to

00:18:53,679 --> 00:18:58,080
use excel on time

00:18:55,360 --> 00:18:59,760
lastly we plan to integrate slr on time

00:18:58,080 --> 00:19:00,480
into cate containers because cadet

00:18:59,760 --> 00:19:02,640
community

00:19:00,480 --> 00:19:05,440
has already developed their container

00:19:02,640 --> 00:19:08,320
runtime in rust

00:19:05,440 --> 00:19:10,160
conclusion first rash language is a

00:19:08,320 --> 00:19:12,240
great fit for america's system due to

00:19:10,160 --> 00:19:13,039
the small manually fit plant and binary

00:19:12,240 --> 00:19:14,960
size

00:19:13,039 --> 00:19:17,039
in addition rust guarantees memory

00:19:14,960 --> 00:19:19,039
safety without any overhead

00:19:17,039 --> 00:19:21,280
so we developed rust-based container

00:19:19,039 --> 00:19:23,039
on-time information embedded systems

00:19:21,280 --> 00:19:24,880
our runtime has the first asylum

00:19:23,039 --> 00:19:28,000
mechanism they're fine grand access

00:19:24,880 --> 00:19:29,919
control for embedded systems

00:19:28,000 --> 00:19:32,400
the evaluation shows that the runtime

00:19:29,919 --> 00:19:33,840
launch is a container 7.4 times faster

00:19:32,400 --> 00:19:36,880
than run c and the runtime

00:19:33,840 --> 00:19:39,760
memory usage is equivalent to see basic

00:19:36,880 --> 00:19:41,919
runtime

00:19:39,760 --> 00:19:45,520
this is all for my presentation thank

00:19:41,919 --> 00:19:45,520

YouTube URL: https://www.youtube.com/watch?v=pA3Wg3GAaew


