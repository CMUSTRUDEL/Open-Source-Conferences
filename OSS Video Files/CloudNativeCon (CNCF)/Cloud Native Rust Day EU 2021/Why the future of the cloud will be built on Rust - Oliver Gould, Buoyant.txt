Title: Why the future of the cloud will be built on Rust - Oliver Gould, Buoyant
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Why the future of the cloud will be built on Rust - Oliver Gould, Buoyant

For consideration as a keynote. In this presentation, Oliver Gould, creator of Linkerd---the first CNCF project to incorporate Rust, and a major driver of the early Rust networking ecosystem---will present an argument that the future of cloud software and the cloud native ecosystem will be tied to the Rust programming language. Oliver will argue that, while Go is the lingua franca of the *current* cloud native ecosystem, Rust will be the lingua franca--or at least one lingua franca---of the *future* ecosystem. He will draw parallels between the constraints of cloud environments, the core principles of the cloud native ecosystem, and the principles of Rust itself, grounded in concrete examples from Linkerd's Rust proxy as well as other projects. Finally, he will present a roadmap for the future of Rust in the cloud native world, both as captured by the CNCF ecosystem and beyond.
Captions: 
	00:00:00,080 --> 00:00:06,480
hi thanks for coming this talk is about

00:00:03,919 --> 00:00:07,440
why rust is going to be a foundational

00:00:06,480 --> 00:00:08,960
technology

00:00:07,440 --> 00:00:10,559
to the future of cloud native

00:00:08,960 --> 00:00:12,160
infrastructure

00:00:10,559 --> 00:00:14,799
before i get to that let me introduce

00:00:12,160 --> 00:00:17,119
myself my name is oliver gould

00:00:14,799 --> 00:00:19,039
these are my dogs and i'm the creator of

00:00:17,119 --> 00:00:21,600
a project called linkery a service mesh

00:00:19,039 --> 00:00:23,600
that's been part of cncf since 2016.

00:00:21,600 --> 00:00:25,599
i'm also the cto of a company called

00:00:23,600 --> 00:00:26,480
buoyant where we make this and some

00:00:25,599 --> 00:00:30,000
other

00:00:26,480 --> 00:00:30,880
infrastructure tools before that i

00:00:30,000 --> 00:00:32,399
worked at

00:00:30,880 --> 00:00:34,239
internet companies like twitter and

00:00:32,399 --> 00:00:36,000
yahoo really focused on production

00:00:34,239 --> 00:00:37,760
operations and infrastructure

00:00:36,000 --> 00:00:40,800
and that's really the lens to which this

00:00:37,760 --> 00:00:40,800
talk is going to be delivered

00:00:41,600 --> 00:00:45,920
this talks basically three parts first i

00:00:44,079 --> 00:00:48,079
want to take you through

00:00:45,920 --> 00:00:49,360
a brief history of the cloud from my

00:00:48,079 --> 00:00:51,280
perspective

00:00:49,360 --> 00:00:53,039
next i want to get into the details of

00:00:51,280 --> 00:00:54,480
why i think russ is so important to

00:00:53,039 --> 00:00:56,559
cloud technology

00:00:54,480 --> 00:00:58,000
and then we'll wrap this up with a quick

00:00:56,559 --> 00:01:00,690
tour of

00:00:58,000 --> 00:01:03,199
the rust toolkit that we use in linkery

00:01:00,690 --> 00:01:06,880
[Music]

00:01:03,199 --> 00:01:08,320
so i want to emphasize this is

00:01:06,880 --> 00:01:10,000
when we talk about the history this is

00:01:08,320 --> 00:01:10,479
the history from my perspective like all

00:01:10,000 --> 00:01:13,119
history

00:01:10,479 --> 00:01:14,640
subjective and so if you may have been

00:01:13,119 --> 00:01:15,840
in the industry through this whole time

00:01:14,640 --> 00:01:18,000
you may have a slightly different

00:01:15,840 --> 00:01:19,600
perspective of things that's fine

00:01:18,000 --> 00:01:21,040
but i i think it's important to set the

00:01:19,600 --> 00:01:22,799
table for for

00:01:21,040 --> 00:01:26,080
where where we've come from before we

00:01:22,799 --> 00:01:29,200
talk about where we're going

00:01:26,080 --> 00:01:32,880
so when i entered the industry when i

00:01:29,200 --> 00:01:36,560
started working at yahoo in 2007

00:01:32,880 --> 00:01:39,119
yahoo was a big old internet company

00:01:36,560 --> 00:01:40,720
they had literally millions of physical

00:01:39,119 --> 00:01:42,159
hosts that were managed

00:01:40,720 --> 00:01:44,399
and they were managed by dozens of

00:01:42,159 --> 00:01:46,000
hardware teams people and data centers

00:01:44,399 --> 00:01:48,640
people provisioning hardware

00:01:46,000 --> 00:01:50,240
and also dozens of system and teams so

00:01:48,640 --> 00:01:52,079
our team in production operations was

00:01:50,240 --> 00:01:53,759
one of many responsible for managing

00:01:52,079 --> 00:01:55,920
these hosts these fleet of hosts across

00:01:53,759 --> 00:01:57,360
the world

00:01:55,920 --> 00:01:59,360
because of this because of all these

00:01:57,360 --> 00:02:00,560
legacy systems that accrued over time it

00:01:59,360 --> 00:02:04,320
was extremely

00:02:00,560 --> 00:02:07,600
heterogeneous lots of freebsd

00:02:04,320 --> 00:02:09,920
linux creeping in os versions

00:02:07,600 --> 00:02:11,680
configurations proliferated in every

00:02:09,920 --> 00:02:13,920
different way but the idea here

00:02:11,680 --> 00:02:15,520
is that they are largely what they call

00:02:13,920 --> 00:02:17,840
pets and not cattle

00:02:15,520 --> 00:02:20,720
really bespoke configurations for

00:02:17,840 --> 00:02:20,720
millions of hosts

00:02:21,360 --> 00:02:24,480
it also at the time if you wanted to get

00:02:23,280 --> 00:02:26,879
hardware

00:02:24,480 --> 00:02:28,480
if you wanted a new server you had to go

00:02:26,879 --> 00:02:29,040
to something called the hardware request

00:02:28,480 --> 00:02:31,440
committee

00:02:29,040 --> 00:02:33,280
hardware review committee and this was

00:02:31,440 --> 00:02:34,800
literally a meeting with the cto of the

00:02:33,280 --> 00:02:37,280
company david philo

00:02:34,800 --> 00:02:39,760
where you'd justify your need for a

00:02:37,280 --> 00:02:43,519
server or for a fleet of servers

00:02:39,760 --> 00:02:45,360
and it was you know undoubtedly slow and

00:02:43,519 --> 00:02:46,560
laborious and a little bit stressful to

00:02:45,360 --> 00:02:48,480
get hardware

00:02:46,560 --> 00:02:50,160
and this was done to save costs and make

00:02:48,480 --> 00:02:52,239
sure we're using things efficiently

00:02:50,160 --> 00:02:54,000
but it's really a different way of

00:02:52,239 --> 00:02:55,920
requiring for getting hardware than we

00:02:54,000 --> 00:02:57,440
do today

00:02:55,920 --> 00:02:59,040
and the first problem i really started

00:02:57,440 --> 00:03:00,400
working on there the problem i worked on

00:02:59,040 --> 00:03:02,080
through most of my time at yahoo was

00:03:00,400 --> 00:03:05,360
config management

00:03:02,080 --> 00:03:06,879
so across these millions of hosts

00:03:05,360 --> 00:03:08,879
how do we make sure that they get

00:03:06,879 --> 00:03:09,200
security patches how do we make sure

00:03:08,879 --> 00:03:11,040
that

00:03:09,200 --> 00:03:12,800
new users of the company get access to

00:03:11,040 --> 00:03:14,640
the host or when a user leaves the

00:03:12,800 --> 00:03:15,440
company that they no longer have access

00:03:14,640 --> 00:03:17,280
to the host

00:03:15,440 --> 00:03:19,680
how do we manage the proliferation of

00:03:17,280 --> 00:03:20,720
configuration this is a hard problem and

00:03:19,680 --> 00:03:23,280
we worked on this

00:03:20,720 --> 00:03:25,680
for for years and this wasn't unique to

00:03:23,280 --> 00:03:25,680
yahoo

00:03:26,080 --> 00:03:30,239
lots of companies at the time were going

00:03:28,319 --> 00:03:30,720
through similar problems they all had to

00:03:30,239 --> 00:03:32,879
manage

00:03:30,720 --> 00:03:34,400
hosts to be connected to the internet

00:03:32,879 --> 00:03:36,799
securely

00:03:34,400 --> 00:03:37,599
and so the proliferation of projects

00:03:36,799 --> 00:03:40,000
came around this

00:03:37,599 --> 00:03:40,799
first cf engine long time ago written in

00:03:40,000 --> 00:03:43,519
c

00:03:40,799 --> 00:03:46,400
and then you know in the mid 2000s to

00:03:43,519 --> 00:03:49,120
late 2000s we saw new products coming on

00:03:46,400 --> 00:03:50,959
mostly in ruby or python projects like

00:03:49,120 --> 00:03:54,239
puppet chef ansible and of course

00:03:50,959 --> 00:03:55,120
others and the job of a config

00:03:54,239 --> 00:03:59,599
management

00:03:55,120 --> 00:04:01,360
system is kind of simple a little bit

00:03:59,599 --> 00:04:02,879
they mostly have to run commands and

00:04:01,360 --> 00:04:04,480
generate templates these scripting

00:04:02,879 --> 00:04:06,720
languages that were really coming to

00:04:04,480 --> 00:04:07,439
popularity at the time were good fit for

00:04:06,720 --> 00:04:09,280
that

00:04:07,439 --> 00:04:11,360
they're they're system scripting

00:04:09,280 --> 00:04:13,280
languages

00:04:11,360 --> 00:04:15,439
and the real job of config management

00:04:13,280 --> 00:04:17,759
systems is to make the host

00:04:15,439 --> 00:04:19,600
able to run an application and

00:04:17,759 --> 00:04:21,440
frequently config management systems

00:04:19,600 --> 00:04:22,720
were responsible for actually deploying

00:04:21,440 --> 00:04:25,199
code for getting

00:04:22,720 --> 00:04:27,360
application software ready to run this

00:04:25,199 --> 00:04:30,160
meant there's a pretty tight coupling

00:04:27,360 --> 00:04:31,440
between your hostess database and your

00:04:30,160 --> 00:04:34,880
actual

00:04:31,440 --> 00:04:38,639
application it's not

00:04:34,880 --> 00:04:38,639
really where we are today obviously

00:04:38,960 --> 00:04:45,040
around the same time so early

00:04:42,080 --> 00:04:45,919
well really throughout the early 2000s

00:04:45,040 --> 00:04:48,880
we saw

00:04:45,919 --> 00:04:50,320
a new proliferation of virtualization

00:04:48,880 --> 00:04:52,639
technology come online

00:04:50,320 --> 00:04:54,479
so projects like freebsd jails kind of

00:04:52,639 --> 00:04:57,759
in the earlier side and then

00:04:54,479 --> 00:04:59,280
zen and solaris and building up to linux

00:04:57,759 --> 00:05:01,600
c groups which so much of what we're

00:04:59,280 --> 00:05:03,600
talking about today is built on

00:05:01,600 --> 00:05:05,680
really the job of these virtualization

00:05:03,600 --> 00:05:08,400
technologies made

00:05:05,680 --> 00:05:11,600
systems multi-tenant so no longer do i

00:05:08,400 --> 00:05:12,560
have to have a single host with a single

00:05:11,600 --> 00:05:16,080
application

00:05:12,560 --> 00:05:19,039
or even a single user or customer

00:05:16,080 --> 00:05:21,440
now i can run multiple operating systems

00:05:19,039 --> 00:05:24,240
on a single piece of hardware

00:05:21,440 --> 00:05:25,280
and this really really change the game

00:05:24,240 --> 00:05:27,520
of course all this

00:05:25,280 --> 00:05:30,000
stuff is very low level operating system

00:05:27,520 --> 00:05:31,759
that's maybe written in c at best but

00:05:30,000 --> 00:05:32,960
also lots of assembly to get this stuff

00:05:31,759 --> 00:05:34,320
done because you're virtualizing

00:05:32,960 --> 00:05:37,520
hardware you're actually

00:05:34,320 --> 00:05:40,560
you know mimicking what a machine does

00:05:37,520 --> 00:05:41,680
this gave birth to a new set of products

00:05:40,560 --> 00:05:43,199
and services

00:05:41,680 --> 00:05:44,960
that we really call what we call the

00:05:43,199 --> 00:05:46,880
cloud today and it really

00:05:44,960 --> 00:05:48,400
made the data center as a service or

00:05:46,880 --> 00:05:51,440
data center as a product

00:05:48,400 --> 00:05:52,960
and ec2 is probably the first

00:05:51,440 --> 00:05:56,240
widely available one of these and of

00:05:52,960 --> 00:05:56,240
course in many have followed since

00:05:57,199 --> 00:06:01,280
and i remember having a conversation

00:05:58,800 --> 00:06:04,880
with a colleague with netflix and

00:06:01,280 --> 00:06:05,199
probably 2009 or 2010 where he told me

00:06:04,880 --> 00:06:07,759
how

00:06:05,199 --> 00:06:09,759
netflix was moving from their aix

00:06:07,759 --> 00:06:11,199
mainframe so netflix originally was on

00:06:09,759 --> 00:06:13,520
ax mainframes

00:06:11,199 --> 00:06:14,960
uh and how they were moving to aws and

00:06:13,520 --> 00:06:18,000
this made no sense to me

00:06:14,960 --> 00:06:20,160
again i was working at yahoo with these

00:06:18,000 --> 00:06:21,520
massive fleets of bespoke systems and

00:06:20,160 --> 00:06:24,400
the idea that

00:06:21,520 --> 00:06:25,039
a growing popular internet company would

00:06:24,400 --> 00:06:27,440
go

00:06:25,039 --> 00:06:30,319
to amazon's infrastructure it didn't

00:06:27,440 --> 00:06:33,680
make any sense to me

00:06:30,319 --> 00:06:34,080
boy was i wrong huh so the great thing

00:06:33,680 --> 00:06:36,400
about

00:06:34,080 --> 00:06:37,840
this as we all know is that it made

00:06:36,400 --> 00:06:40,000
service accessible

00:06:37,840 --> 00:06:42,080
there's no longer a hardware review

00:06:40,000 --> 00:06:45,440
committee i have to go to

00:06:42,080 --> 00:06:46,880
to get a new server there's no longer

00:06:45,440 --> 00:06:49,759
some of the data center i

00:06:46,880 --> 00:06:50,319
have to call to get out to fix a server

00:06:49,759 --> 00:06:52,960
and

00:06:50,319 --> 00:06:53,680
i now just have an api and a credit card

00:06:52,960 --> 00:06:55,840
and i

00:06:53,680 --> 00:06:57,280
get access to a server i get an internet

00:06:55,840 --> 00:06:59,440
connected server

00:06:57,280 --> 00:07:01,520
this means as students we actually can

00:06:59,440 --> 00:07:02,080
just get online and get server

00:07:01,520 --> 00:07:04,720
technology

00:07:02,080 --> 00:07:06,080
easily and as startups and businesses we

00:07:04,720 --> 00:07:06,880
get access to these things without

00:07:06,080 --> 00:07:08,880
having to

00:07:06,880 --> 00:07:10,000
get data center contracts or any of the

00:07:08,880 --> 00:07:12,319
kind of overhead that's really

00:07:10,000 --> 00:07:13,919
associated with the time before this

00:07:12,319 --> 00:07:16,639
the other interesting thing here is that

00:07:13,919 --> 00:07:18,639
linux is really tied to this right

00:07:16,639 --> 00:07:20,400
linux does not generally require

00:07:18,639 --> 00:07:22,560
licenses to operate

00:07:20,400 --> 00:07:24,560
and so this was a great fit i no longer

00:07:22,560 --> 00:07:25,520
have to get a microsoft or whatever

00:07:24,560 --> 00:07:28,800
license

00:07:25,520 --> 00:07:30,080
to get into prod i now just get a free

00:07:28,800 --> 00:07:31,919
operating system

00:07:30,080 --> 00:07:34,000
and i also no longer have to worry about

00:07:31,919 --> 00:07:36,880
the vast array of

00:07:34,000 --> 00:07:38,720
driver compatibility issues which were

00:07:36,880 --> 00:07:41,120
kind of a headache before this

00:07:38,720 --> 00:07:41,919
so now i can just make an api call click

00:07:41,120 --> 00:07:43,599
a button

00:07:41,919 --> 00:07:45,120
and i get a server that's ready to

00:07:43,599 --> 00:07:47,599
operate on the internet which is

00:07:45,120 --> 00:07:51,440
great really reduces the barriers to

00:07:47,599 --> 00:07:51,440
getting involved in server technology

00:07:51,520 --> 00:07:55,520
however there's some downsides here

00:07:54,160 --> 00:07:56,560
we're still dealing with her

00:07:55,520 --> 00:07:58,960
hooks even though we're dealing with

00:07:56,560 --> 00:08:01,039
virtual hosts vms we still have

00:07:58,960 --> 00:08:02,800
hosts as our primary abstraction which

00:08:01,039 --> 00:08:04,240
means config management is still a big

00:08:02,800 --> 00:08:04,960
problem which is why we have all these

00:08:04,240 --> 00:08:08,639
configmatic

00:08:04,960 --> 00:08:10,400
companies coming online in projects

00:08:08,639 --> 00:08:12,319
we also have no control over the

00:08:10,400 --> 00:08:13,520
hardware using very little control of

00:08:12,319 --> 00:08:15,919
the hardware we're using

00:08:13,520 --> 00:08:18,080
which means we have kind of less

00:08:15,919 --> 00:08:21,520
reliability there we don't

00:08:18,080 --> 00:08:23,520
no longer are we trying to have one

00:08:21,520 --> 00:08:25,120
super power machine stay online all the

00:08:23,520 --> 00:08:26,000
time now we're kind of dealing in a

00:08:25,120 --> 00:08:28,080
world where systems

00:08:26,000 --> 00:08:29,520
might fail and we can't call any data or

00:08:28,080 --> 00:08:30,000
deal with them we really have to

00:08:29,520 --> 00:08:33,039
consider

00:08:30,000 --> 00:08:35,440
variable variable performance

00:08:33,039 --> 00:08:37,200
no longer do i have exclusive access to

00:08:35,440 --> 00:08:40,000
a machine i might have

00:08:37,200 --> 00:08:41,200
other you know other businesses running

00:08:40,000 --> 00:08:42,240
on this machine that are dealing with

00:08:41,200 --> 00:08:45,279
lots of traffic

00:08:42,240 --> 00:08:46,800
and so these concerns end up changing

00:08:45,279 --> 00:08:47,680
how we actually think about operating

00:08:46,800 --> 00:08:50,399
services

00:08:47,680 --> 00:08:51,600
we have a whole new set of failures soft

00:08:50,399 --> 00:08:53,920
failures

00:08:51,600 --> 00:08:56,000
more frequent failures and this kind of

00:08:53,920 --> 00:08:57,279
gives birth to a new way of testing a

00:08:56,000 --> 00:08:59,440
new methodology

00:08:57,279 --> 00:09:03,279
called chaos testing also coming out of

00:08:59,440 --> 00:09:03,279
netflix probably in 2011 or so

00:09:05,040 --> 00:09:08,399
building on that so this is kind of by

00:09:07,120 --> 00:09:11,680
the time we met twitter

00:09:08,399 --> 00:09:13,519
in 2010 we have a new set of

00:09:11,680 --> 00:09:16,800
technologies coming online that really

00:09:13,519 --> 00:09:19,519
decouple applications from hosts

00:09:16,800 --> 00:09:20,959
so no longer do we as as someone who's

00:09:19,519 --> 00:09:21,600
operating a service do i have to think

00:09:20,959 --> 00:09:24,000
about

00:09:21,600 --> 00:09:26,000
config management or ssh into a host or

00:09:24,000 --> 00:09:27,600
kind of all the overhead of that

00:09:26,000 --> 00:09:29,440
now what we're thinking of through

00:09:27,600 --> 00:09:31,279
projects like mesos and aurora

00:09:29,440 --> 00:09:34,000
are i just want to ship my workload i

00:09:31,279 --> 00:09:36,560
want to write software build an artifact

00:09:34,000 --> 00:09:37,519
get it running and this was really great

00:09:36,560 --> 00:09:40,240
for twitter

00:09:37,519 --> 00:09:41,920
and other you know growing scaling

00:09:40,240 --> 00:09:45,360
companies uber

00:09:41,920 --> 00:09:47,120
lyft etc where you

00:09:45,360 --> 00:09:48,560
now now need to focus on developer

00:09:47,120 --> 00:09:50,080
productivity we have

00:09:48,560 --> 00:09:52,000
hundreds of engineers how do we get them

00:09:50,080 --> 00:09:53,839
to write software ship under prod

00:09:52,000 --> 00:09:55,600
quickly without having to think about

00:09:53,839 --> 00:09:58,399
all the operational overhead how do we

00:09:55,600 --> 00:10:00,160
stratify that separate that

00:09:58,399 --> 00:10:01,279
the downsides of these projects were

00:10:00,160 --> 00:10:02,480
that they were really operationally

00:10:01,279 --> 00:10:05,519
complex

00:10:02,480 --> 00:10:08,720
it was pretty hard or if not impossible

00:10:05,519 --> 00:10:09,920
to run a full mesos cluster on your

00:10:08,720 --> 00:10:11,600
laptop

00:10:09,920 --> 00:10:12,959
um you actually need quite a bit of

00:10:11,600 --> 00:10:14,720
hardware to get started

00:10:12,959 --> 00:10:16,320
or you need some pretty beefy cloud

00:10:14,720 --> 00:10:17,839
boxes to get started

00:10:16,320 --> 00:10:20,079
and so there is some overhead here this

00:10:17,839 --> 00:10:20,560
is not a broadly accessible technology

00:10:20,079 --> 00:10:24,480
that didn't

00:10:20,560 --> 00:10:25,120
get started with also we're dealing with

00:10:24,480 --> 00:10:28,640
a lot of

00:10:25,120 --> 00:10:31,680
you know jvm runtime which comes with

00:10:28,640 --> 00:10:34,000
runtime costs overhead memory cpu and

00:10:31,680 --> 00:10:36,079
operational costs in terms of debugging

00:10:34,000 --> 00:10:37,680
gc and things like that

00:10:36,079 --> 00:10:39,200
and in this world we're dealing with you

00:10:37,680 --> 00:10:42,399
know highly just

00:10:39,200 --> 00:10:44,320
highly dynamic systems where where mesos

00:10:42,399 --> 00:10:47,200
may reschedule pods or

00:10:44,320 --> 00:10:48,640
instances without there being any kind

00:10:47,200 --> 00:10:50,160
of user involvement and so we have to

00:10:48,640 --> 00:10:51,360
deal with things like service discovery

00:10:50,160 --> 00:10:53,360
and load balancing

00:10:51,360 --> 00:10:54,800
and retries and timeouts and all the

00:10:53,360 --> 00:10:56,959
things that kind of

00:10:54,800 --> 00:10:58,000
are necessary to manage services of the

00:10:56,959 --> 00:11:00,320
scale

00:10:58,000 --> 00:11:01,839
and so twitter we were working on a

00:11:00,320 --> 00:11:04,320
library called finagle

00:11:01,839 --> 00:11:06,880
and that's really what came to be the

00:11:04,320 --> 00:11:09,600
core of the first version of linkedin

00:11:06,880 --> 00:11:11,680
and so you know as we dealt with all of

00:11:09,600 --> 00:11:13,519
these production issues and dealt with

00:11:11,680 --> 00:11:15,279
making communication more reliable in

00:11:13,519 --> 00:11:16,720
this library called finagle

00:11:15,279 --> 00:11:19,040
the idea with linker to you as well how

00:11:16,720 --> 00:11:20,560
do we package that up into a proxy

00:11:19,040 --> 00:11:24,880
and make that accessible to folks who

00:11:20,560 --> 00:11:24,880
are not writing software with finagle

00:11:26,399 --> 00:11:29,920
following that or kind of around the

00:11:28,000 --> 00:11:32,079
same time there's what

00:11:29,920 --> 00:11:33,120
the you know a new set of technologies

00:11:32,079 --> 00:11:35,519
coming on

00:11:33,120 --> 00:11:36,959
that what we call cloud native so it

00:11:35,519 --> 00:11:39,680
really kind of starts with docker

00:11:36,959 --> 00:11:40,399
in a lot of ways so docker is building

00:11:39,680 --> 00:11:41,680
on linux c

00:11:40,399 --> 00:11:43,920
groups the technology we're talking

00:11:41,680 --> 00:11:46,079
about a little bit ago

00:11:43,920 --> 00:11:47,600
and docker makes it possible as many of

00:11:46,079 --> 00:11:50,399
you know i'm sure

00:11:47,600 --> 00:11:51,519
to package up an application and ship it

00:11:50,399 --> 00:11:54,000
somewhere

00:11:51,519 --> 00:11:55,040
and get it running with resource

00:11:54,000 --> 00:11:57,760
constraints

00:11:55,040 --> 00:11:59,680
and so it kind of avoid you know it

00:11:57,760 --> 00:12:00,480
pulls in parts of the config management

00:11:59,680 --> 00:12:02,959
story

00:12:00,480 --> 00:12:03,760
and isolates them into a binary that

00:12:02,959 --> 00:12:05,760
really is

00:12:03,760 --> 00:12:07,600
almost a whole operating system running

00:12:05,760 --> 00:12:09,839
in a binary

00:12:07,600 --> 00:12:11,519
and kubernetes extends that model and

00:12:09,839 --> 00:12:14,720
makes it possible to

00:12:11,519 --> 00:12:18,160
take a cluster of servers and just run

00:12:14,720 --> 00:12:18,160
these docker containers anywhere

00:12:19,600 --> 00:12:23,519
and with that we have this heavy

00:12:21,600 --> 00:12:25,279
reliance on the network

00:12:23,519 --> 00:12:27,519
what we call you know microservice

00:12:25,279 --> 00:12:29,839
architectures are tiny

00:12:27,519 --> 00:12:31,600
services that are distributed in a data

00:12:29,839 --> 00:12:33,600
center or in a cluster

00:12:31,600 --> 00:12:34,720
and they communicate over the network

00:12:33,600 --> 00:12:38,320
and so tools like

00:12:34,720 --> 00:12:39,279
grpc and envoy and linkerd fit into this

00:12:38,320 --> 00:12:42,639
world

00:12:39,279 --> 00:12:44,480
to really focus on

00:12:42,639 --> 00:12:46,800
managing the complexity of a dynamic

00:12:44,480 --> 00:12:46,800
system

00:12:46,959 --> 00:12:50,000
so we deal with fault tolerance we deal

00:12:49,200 --> 00:12:52,480
with the fact that we

00:12:50,000 --> 00:12:53,040
have to load balance and a lot of these

00:12:52,480 --> 00:12:54,720
things

00:12:53,040 --> 00:12:56,079
kubernetes and linker d especially

00:12:54,720 --> 00:12:58,639
docker as well

00:12:56,079 --> 00:13:00,000
focus on user experience on reducing the

00:12:58,639 --> 00:13:02,480
costs of managing it

00:13:00,000 --> 00:13:03,200
getting started of understanding it to

00:13:02,480 --> 00:13:05,200
make it

00:13:03,200 --> 00:13:07,120
accessible for application owners to get

00:13:05,200 --> 00:13:09,600
running and so we focus on

00:13:07,120 --> 00:13:10,160
applications and not hosts we're finally

00:13:09,600 --> 00:13:13,360
broken

00:13:10,160 --> 00:13:15,760
that those barriers down

00:13:13,360 --> 00:13:17,200
so let me take a little detour and

00:13:15,760 --> 00:13:18,800
describe what linguine is in case you

00:13:17,200 --> 00:13:20,320
don't know

00:13:18,800 --> 00:13:22,399
and then we'll get into why this is so

00:13:20,320 --> 00:13:24,000
important for rust

00:13:22,399 --> 00:13:26,160
so linguine is a service mission what a

00:13:24,000 --> 00:13:29,920
service mesh is it's a pattern

00:13:26,160 --> 00:13:32,720
of deploying rich data planes

00:13:29,920 --> 00:13:34,079
as generally as a proxy as sidecar proxy

00:13:32,720 --> 00:13:36,399
that deal with this communication

00:13:34,079 --> 00:13:38,720
complexity and so we have to deal with

00:13:36,399 --> 00:13:41,120
load balancing over a set of instances a

00:13:38,720 --> 00:13:42,000
set of replicas in a cluster and i have

00:13:41,120 --> 00:13:44,000
to deal with

00:13:42,000 --> 00:13:45,440
making sure that everything gets tls by

00:13:44,000 --> 00:13:46,160
default because i may not trust the

00:13:45,440 --> 00:13:47,760
network

00:13:46,160 --> 00:13:49,199
that i'm running and i also want to have

00:13:47,760 --> 00:13:49,920
identity on either side of this i want

00:13:49,199 --> 00:13:51,519
to know

00:13:49,920 --> 00:13:54,639
which workload is talking which workload

00:13:51,519 --> 00:13:57,279
and that's easily done through tls

00:13:54,639 --> 00:13:57,920
and so what we do is we deploy a proxy

00:13:57,279 --> 00:14:00,639
sidecar

00:13:57,920 --> 00:14:01,040
next to every application instance and

00:14:00,639 --> 00:14:02,880
this

00:14:01,040 --> 00:14:04,560
helps manage communication and

00:14:02,880 --> 00:14:06,399
complexity

00:14:04,560 --> 00:14:07,839
this is really in in linguity there's

00:14:06,399 --> 00:14:08,800
kind of two halves of this we have a

00:14:07,839 --> 00:14:11,199
control plane

00:14:08,800 --> 00:14:12,720
which talks to the kubernetes api which

00:14:11,199 --> 00:14:16,399
deals with

00:14:12,720 --> 00:14:20,160
a lot of the configuration and discovery

00:14:16,399 --> 00:14:21,680
and the fact that things are dynamic and

00:14:20,160 --> 00:14:23,120
feeding them to proxies and the proxies

00:14:21,680 --> 00:14:24,480
are supposed to be very lightweight

00:14:23,120 --> 00:14:26,639
small

00:14:24,480 --> 00:14:28,560
instances that can fit you know many

00:14:26,639 --> 00:14:32,079
many many on a host

00:14:28,560 --> 00:14:32,079
to serve this this traffic

00:14:32,480 --> 00:14:36,399
and we can kind of look at it like this

00:14:34,079 --> 00:14:38,079
right where we have the kubernetes api

00:14:36,399 --> 00:14:40,000
kubernetes is of course written

00:14:38,079 --> 00:14:41,440
go and we have a link red control plane

00:14:40,000 --> 00:14:44,720
which is also today where we

00:14:41,440 --> 00:14:46,320
go and we chose go for the control plane

00:14:44,720 --> 00:14:48,560
because it's so coupled to the

00:14:46,320 --> 00:14:51,920
kubernetes api

00:14:48,560 --> 00:14:52,959
because we are we want to use client go

00:14:51,920 --> 00:14:54,720
we don't want to have to write a

00:14:52,959 --> 00:14:56,639
kubernetes client from scratch and think

00:14:54,720 --> 00:14:57,760
about all the complexity of what's in a

00:14:56,639 --> 00:15:00,160
kubernetes client

00:14:57,760 --> 00:15:01,440
and this is again three plus years ago

00:15:00,160 --> 00:15:03,839
when we were starting

00:15:01,440 --> 00:15:05,120
we wanted linker d's control plane to be

00:15:03,839 --> 00:15:06,560
you know feel like part of the

00:15:05,120 --> 00:15:08,959
kubernetes ecosystem

00:15:06,560 --> 00:15:11,040
so we chose go for that but when we

00:15:08,959 --> 00:15:14,160
start went to write the proxy

00:15:11,040 --> 00:15:18,800
the sidecar proxy we chose rust

00:15:14,160 --> 00:15:20,720
and that has been a great experience

00:15:18,800 --> 00:15:23,040
um but when we were starting it was

00:15:20,720 --> 00:15:24,800
really rough around the edges we had to

00:15:23,040 --> 00:15:26,240
bootstrap ourselves we had to build lots

00:15:24,800 --> 00:15:27,440
of technology we invest heavily in the

00:15:26,240 --> 00:15:30,240
rust ecosystem

00:15:27,440 --> 00:15:30,240
to make this work

00:15:35,120 --> 00:15:42,399
and so why is rust going to happen now

00:15:38,880 --> 00:15:44,800
what what about this moment meet why is

00:15:42,399 --> 00:15:48,000
russ so appealing to us

00:15:44,800 --> 00:15:50,720
to us in this point of time

00:15:48,000 --> 00:15:52,079
well rust gives us a bunch of primitives

00:15:50,720 --> 00:15:53,199
to build components right it's a

00:15:52,079 --> 00:15:56,079
programming language

00:15:53,199 --> 00:15:57,199
which which focuses on safety efficiency

00:15:56,079 --> 00:15:59,279
and composability

00:15:57,199 --> 00:16:01,120
and really on making developers

00:15:59,279 --> 00:16:04,320
productive right though

00:16:01,120 --> 00:16:05,360
i as an engineer can write a data plane

00:16:04,320 --> 00:16:08,560
proxy a

00:16:05,360 --> 00:16:11,199
you know a micro service proxy

00:16:08,560 --> 00:16:12,240
and i can do that with high confidence

00:16:11,199 --> 00:16:16,240
that it's not going to have

00:16:12,240 --> 00:16:18,560
memory leaks or memory safety issues

00:16:16,240 --> 00:16:20,160
and that will do the job well and we

00:16:18,560 --> 00:16:21,680
want to use this to build cloud native

00:16:20,160 --> 00:16:24,560
technology and so the cloud native

00:16:21,680 --> 00:16:26,480
systems are again dynamic network fault

00:16:24,560 --> 00:16:29,199
tolerant and loosely coupled

00:16:26,480 --> 00:16:30,639
and so these things end up actually

00:16:29,199 --> 00:16:32,320
aligning pretty closely and i'm going to

00:16:30,639 --> 00:16:34,560
get into why

00:16:32,320 --> 00:16:36,160
but first let me take you back to the

00:16:34,560 --> 00:16:38,560
osi model

00:16:36,160 --> 00:16:40,560
this is one of my favorite pictures

00:16:38,560 --> 00:16:43,600
every talk i do has this but

00:16:40,560 --> 00:16:44,880
we look at the application stack or the

00:16:43,600 --> 00:16:46,560
networking stack

00:16:44,880 --> 00:16:48,079
and we see all these layers but really

00:16:46,560 --> 00:16:50,720
what we're talking about for for

00:16:48,079 --> 00:16:52,880
applications for the people building

00:16:50,720 --> 00:16:55,040
websites and and user-facing

00:16:52,880 --> 00:16:57,360
applications this is how the world looks

00:16:55,040 --> 00:16:58,480
they should only really care about their

00:16:57,360 --> 00:17:00,399
application logic

00:16:58,480 --> 00:17:01,759
whether it's tweets or pictures or

00:17:00,399 --> 00:17:03,519
payments or whatever

00:17:01,759 --> 00:17:05,600
and maybe the presentation whether

00:17:03,519 --> 00:17:07,360
that's jason or protobuf or

00:17:05,600 --> 00:17:08,640
you know the details of how it's

00:17:07,360 --> 00:17:10,959
rendered and then

00:17:08,640 --> 00:17:11,760
shared but everything beneath that is

00:17:10,959 --> 00:17:14,079
infrastructure

00:17:11,760 --> 00:17:16,240
it's the cloud but somebody has to build

00:17:14,079 --> 00:17:18,400
that stuff and that stuff is us

00:17:16,240 --> 00:17:20,079
and so you know down at the bottom we

00:17:18,400 --> 00:17:20,799
have physical layers and link layers

00:17:20,079 --> 00:17:23,839
which are really

00:17:20,799 --> 00:17:27,039
you know part of the cloud providers or

00:17:23,839 --> 00:17:29,760
or data center or hardware right

00:17:27,039 --> 00:17:31,440
and in this middle glue layer is where

00:17:29,760 --> 00:17:32,880
we spend all our time as infrastructure

00:17:31,440 --> 00:17:34,400
developers

00:17:32,880 --> 00:17:37,280
we built things like linker d and

00:17:34,400 --> 00:17:40,480
kubernetes really fit into this

00:17:37,280 --> 00:17:43,440
middle blue layer that is you know not

00:17:40,480 --> 00:17:43,440
talked about too much

00:17:45,280 --> 00:17:49,600
this so what we're all becoming is

00:17:47,919 --> 00:17:50,799
system programmers anyone working in the

00:17:49,600 --> 00:17:52,720
cloud native space

00:17:50,799 --> 00:17:54,320
is really not an application developer

00:17:52,720 --> 00:17:57,440
applications are

00:17:54,320 --> 00:17:58,880
end user facing system programmers

00:17:57,440 --> 00:18:00,559
build software that supports

00:17:58,880 --> 00:18:02,960
applications

00:18:00,559 --> 00:18:04,640
and generally these things have to be

00:18:02,960 --> 00:18:06,080
highly trustworthy

00:18:04,640 --> 00:18:07,760
meaning that they're going to work

00:18:06,080 --> 00:18:08,880
safely and correctly and they're

00:18:07,760 --> 00:18:10,880
generally

00:18:08,880 --> 00:18:12,000
have you know pretty tight performance

00:18:10,880 --> 00:18:14,160
requirements

00:18:12,000 --> 00:18:15,520
and this is really where rust fits in

00:18:14,160 --> 00:18:17,679
rust is a native

00:18:15,520 --> 00:18:18,640
language meaning reaction compiled a

00:18:17,679 --> 00:18:21,919
native code

00:18:18,640 --> 00:18:26,080
we're not running in a you know a

00:18:21,919 --> 00:18:27,919
jit or a runtime a vm

00:18:26,080 --> 00:18:30,000
and so we have access to low-level

00:18:27,919 --> 00:18:32,080
memory primitives and things like that

00:18:30,000 --> 00:18:34,559
but we also need to do that safely and

00:18:32,080 --> 00:18:35,600
that's where i think rust really shines

00:18:34,559 --> 00:18:38,000
and so i'm going to walk through some

00:18:35,600 --> 00:18:39,520
comparisons i'm going to compare it to

00:18:38,000 --> 00:18:41,280
go because go is

00:18:39,520 --> 00:18:43,039
what i know well and really what is the

00:18:41,280 --> 00:18:44,640
kind of state of the art in the cloud

00:18:43,039 --> 00:18:47,440
native

00:18:44,640 --> 00:18:49,280
and we'll talk about where rust really

00:18:47,440 --> 00:18:52,240
makes improvements over the current

00:18:49,280 --> 00:18:53,840
uh the current state of things so here's

00:18:52,240 --> 00:18:57,360
a really simple example

00:18:53,840 --> 00:19:00,960
a function that fails

00:18:57,360 --> 00:19:03,600
and i call it and i ignore the error

00:19:00,960 --> 00:19:05,039
this is a great this is a bug right if

00:19:03,600 --> 00:19:07,039
something fails we should

00:19:05,039 --> 00:19:08,880
have to handle it and russ makes that

00:19:07,039 --> 00:19:10,080
really easy and it uses the type system

00:19:08,880 --> 00:19:12,720
to do that so one of the

00:19:10,080 --> 00:19:13,919
big advantages of rust has a really nice

00:19:12,720 --> 00:19:18,799
type system and types

00:19:13,919 --> 00:19:21,120
let us express constraints in a much

00:19:18,799 --> 00:19:22,320
richer way and really the goal of all of

00:19:21,120 --> 00:19:25,360
what we're doing here

00:19:22,320 --> 00:19:27,280
is taking things that might fail one

00:19:25,360 --> 00:19:29,120
at runtime when the application's

00:19:27,280 --> 00:19:31,039
running and trying to make them fail

00:19:29,120 --> 00:19:33,200
before we even build the thing before we

00:19:31,039 --> 00:19:35,039
test it as early as possible during the

00:19:33,200 --> 00:19:36,799
compilation phase and rust really excels

00:19:35,039 --> 00:19:39,360
at this so here

00:19:36,799 --> 00:19:40,559
same function that just fails if we

00:19:39,360 --> 00:19:42,160
ignore the error

00:19:40,559 --> 00:19:44,160
russ will actually emit a compiler

00:19:42,160 --> 00:19:45,440
warning in linkerity this will prevent

00:19:44,160 --> 00:19:47,039
linker d from building

00:19:45,440 --> 00:19:49,200
and we'll have to fix this before we go

00:19:47,039 --> 00:19:49,200
on

00:19:49,280 --> 00:19:56,000
another example pretty similar

00:19:52,320 --> 00:19:58,400
here is a place where i access

00:19:56,000 --> 00:19:59,520
an initialized value and we've had this

00:19:58,400 --> 00:20:02,720
type of bug

00:19:59,520 --> 00:20:05,200
in the linkedin control plane or cli uh

00:20:02,720 --> 00:20:05,840
countless times more times than i can

00:20:05,200 --> 00:20:08,400
character

00:20:05,840 --> 00:20:09,440
that i than i wish right this this is a

00:20:08,400 --> 00:20:13,520
a big

00:20:09,440 --> 00:20:15,520
pain in my neck um

00:20:13,520 --> 00:20:17,600
and russ again makes this simple with a

00:20:15,520 --> 00:20:18,840
type system so no longer can i

00:20:17,600 --> 00:20:21,200
access something that hasn't been

00:20:18,840 --> 00:20:22,880
initialized if i try to do that

00:20:21,200 --> 00:20:24,640
i'll actually get a compilation error i

00:20:22,880 --> 00:20:26,880
have to deal with the fact

00:20:24,640 --> 00:20:27,840
that something may not be set there's no

00:20:26,880 --> 00:20:30,159
null value

00:20:27,840 --> 00:20:30,880
and rust option is the closest thing we

00:20:30,159 --> 00:20:32,559
have where it

00:20:30,880 --> 00:20:34,559
either exists or doesn't but it's part

00:20:32,559 --> 00:20:38,000
of the type system to fix this

00:20:34,559 --> 00:20:39,679
i actually have to i can get the same

00:20:38,000 --> 00:20:42,080
thing that same runtime failure that i

00:20:39,679 --> 00:20:43,760
would get and go but i actually have to

00:20:42,080 --> 00:20:47,280
document that i have to write

00:20:43,760 --> 00:20:49,120
expect with an error message

00:20:47,280 --> 00:20:50,640
so no longer just sight faulting because

00:20:49,120 --> 00:20:52,159
i did something dumb

00:20:50,640 --> 00:20:55,280
rust makes me deal with these things

00:20:52,159 --> 00:20:55,280
before i even compile

00:20:59,919 --> 00:21:03,520
similarly concurrency becomes a big

00:21:01,520 --> 00:21:04,159
issue especially in a proxy like linker

00:21:03,520 --> 00:21:06,240
d's

00:21:04,159 --> 00:21:07,919
we have multiple connections and

00:21:06,240 --> 00:21:09,840
requests going at once we're talking the

00:21:07,919 --> 00:21:10,880
control plane there's lots of concurrent

00:21:09,840 --> 00:21:13,440
access

00:21:10,880 --> 00:21:14,320
and in go this can be quite dangerous by

00:21:13,440 --> 00:21:17,360
default

00:21:14,320 --> 00:21:19,520
so here i've written just

00:21:17,360 --> 00:21:21,360
this actually from the the go by example

00:21:19,520 --> 00:21:23,440
website

00:21:21,360 --> 00:21:25,039
um where they demonstrate how to use

00:21:23,440 --> 00:21:26,080
mutexes and here i've just left the

00:21:25,039 --> 00:21:28,000
mutex out

00:21:26,080 --> 00:21:29,919
and go will happily compile and it'll

00:21:28,000 --> 00:21:31,039
even run so if i run this thing for a

00:21:29,919 --> 00:21:34,159
second

00:21:31,039 --> 00:21:36,320
go works just fine which is great right

00:21:34,159 --> 00:21:38,240
unless i run it for longer so i increase

00:21:36,320 --> 00:21:41,039
the runtime here to 10 seconds

00:21:38,240 --> 00:21:42,799
and all of a sudden i hit an error so

00:21:41,039 --> 00:21:46,240
this is completely non-deterministic

00:21:42,799 --> 00:21:48,240
right i can write tests that pass

00:21:46,240 --> 00:21:51,919
and then when i ship it to prod this

00:21:48,240 --> 00:21:53,840
thing can fail in an unexpected way

00:21:51,919 --> 00:21:56,840
this is virtually impossible to do in

00:21:53,840 --> 00:22:00,640
rest so here's the same code

00:21:56,840 --> 00:22:00,640
effectively written in rust

00:22:00,880 --> 00:22:05,039
and when i try to compile this i'll

00:22:03,120 --> 00:22:08,159
actually get an error that says

00:22:05,039 --> 00:22:10,640
hey this map you built you can't use it

00:22:08,159 --> 00:22:12,240
multiple places at once somebody has to

00:22:10,640 --> 00:22:13,520
own this thing and so this idea of a

00:22:12,240 --> 00:22:15,360
borrower checker

00:22:13,520 --> 00:22:18,640
is really an ownership model for who

00:22:15,360 --> 00:22:21,120
owns memory who is responsible for this

00:22:18,640 --> 00:22:22,799
or what code is responsible for this

00:22:21,120 --> 00:22:23,280
means that i can't even compile this

00:22:22,799 --> 00:22:26,240
code

00:22:23,280 --> 00:22:27,840
in rest because i it's unsafe the axis

00:22:26,240 --> 00:22:29,919
patterns aren't safe

00:22:27,840 --> 00:22:30,960
and so to fix this i actually have to go

00:22:29,919 --> 00:22:33,919
and put a mutex

00:22:30,960 --> 00:22:35,520
in this is the same fix effectively that

00:22:33,919 --> 00:22:38,799
should exist in the go code

00:22:35,520 --> 00:22:39,679
but the compiler enforces in rest when i

00:22:38,799 --> 00:22:43,280
add the mutex

00:22:39,679 --> 00:22:45,520
everything works pop as you'd expect

00:22:43,280 --> 00:22:46,880
which is great the rust has made my

00:22:45,520 --> 00:22:51,039
program more safe

00:22:46,880 --> 00:22:51,039
without even writing tests

00:22:52,320 --> 00:22:55,840
my last example here is that the rest is

00:22:55,039 --> 00:22:59,760
this idea

00:22:55,840 --> 00:23:01,520
called uh raii resource acquisition

00:22:59,760 --> 00:23:03,440
is initialization and this deals with

00:23:01,520 --> 00:23:06,000
lifetimes and when

00:23:03,440 --> 00:23:07,440
um kind of tying back to that borrowing

00:23:06,000 --> 00:23:09,919
and ownership model

00:23:07,440 --> 00:23:11,840
and once i drop something it no longer

00:23:09,919 --> 00:23:14,640
exists

00:23:11,840 --> 00:23:16,400
and so here in the example on the left

00:23:14,640 --> 00:23:19,120
we have go code

00:23:16,400 --> 00:23:19,600
and that sends two messages on the

00:23:19,120 --> 00:23:22,240
channel

00:23:19,600 --> 00:23:23,120
and then drops the sender and then i

00:23:22,240 --> 00:23:25,679
have another

00:23:23,120 --> 00:23:26,640
task that continually reads from that

00:23:25,679 --> 00:23:29,760
channel

00:23:26,640 --> 00:23:30,960
and if i run this it runs until that

00:23:29,760 --> 00:23:34,159
error happens

00:23:30,960 --> 00:23:35,120
and we hit a deadlock and go exits which

00:23:34,159 --> 00:23:38,320
is great i mean go

00:23:35,120 --> 00:23:40,000
should fail in this case because that's

00:23:38,320 --> 00:23:41,440
the best it can do but we can do better

00:23:40,000 --> 00:23:44,000
in rust

00:23:41,440 --> 00:23:45,600
and rust i have this type system again

00:23:44,000 --> 00:23:46,000
and what the type system tells lets me

00:23:45,600 --> 00:23:48,720
do

00:23:46,000 --> 00:23:52,240
is i get an optional value back and so

00:23:48,720 --> 00:23:55,039
there's no more runtime failure here

00:23:52,240 --> 00:23:55,440
i can't even write the code to not work

00:23:55,039 --> 00:23:57,440
here

00:23:55,440 --> 00:23:59,200
i have to handle these conditions and

00:23:57,440 --> 00:24:02,400
when i do that

00:23:59,200 --> 00:24:05,279
i actually uh we see that we

00:24:02,400 --> 00:24:06,240
get a some value back every time we do a

00:24:05,279 --> 00:24:09,520
read

00:24:06,240 --> 00:24:12,960
so this is an example of the type of

00:24:09,520 --> 00:24:14,640
safety net that we get from rust and why

00:24:12,960 --> 00:24:16,000
you know we haven't even gotten to any

00:24:14,640 --> 00:24:19,200
of the details around

00:24:16,000 --> 00:24:21,840
memory access or you know russ

00:24:19,200 --> 00:24:23,120
kind of provable safety but these are

00:24:21,840 --> 00:24:25,520
all sorts of ways that we

00:24:23,120 --> 00:24:26,480
take failures that could happen at

00:24:25,520 --> 00:24:27,760
runtime

00:24:26,480 --> 00:24:29,279
after i've shipped my software to

00:24:27,760 --> 00:24:29,840
production when i hit a weird corner

00:24:29,279 --> 00:24:32,720
case

00:24:29,840 --> 00:24:33,360
where things can crash and break the

00:24:32,720 --> 00:24:36,320
whole up

00:24:33,360 --> 00:24:37,039
you know the rest of the system russ we

00:24:36,320 --> 00:24:39,840
want to push

00:24:37,039 --> 00:24:41,039
all ruts russ lets us take all of those

00:24:39,840 --> 00:24:42,559
types of failures

00:24:41,039 --> 00:24:44,840
and bring them back in the development

00:24:42,559 --> 00:24:46,559
cycle so they have to be dealt with

00:24:44,840 --> 00:24:48,159
explicitly

00:24:46,559 --> 00:24:49,679
and finally let me take you through a

00:24:48,159 --> 00:24:53,200
quick tour of what

00:24:49,679 --> 00:24:55,520
of tokyo's async ecosystem the tokyo

00:24:53,200 --> 00:24:57,760
is a rust library that's kind of similar

00:24:55,520 --> 00:25:01,039
to neti if you're familiar with the jbm

00:24:57,760 --> 00:25:03,520
it gives us asynchronous i o

00:25:01,039 --> 00:25:05,279
and so when i when i start a program i

00:25:03,520 --> 00:25:08,559
stood up to tokyo runtime

00:25:05,279 --> 00:25:10,640
and this lets us run io concurrently

00:25:08,559 --> 00:25:11,679
without having to have a thread per

00:25:10,640 --> 00:25:14,000
connection

00:25:11,679 --> 00:25:15,679
or you know it gives us something you

00:25:14,000 --> 00:25:16,720
can basically think of similar to goes

00:25:15,679 --> 00:25:18,400
runtime where

00:25:16,720 --> 00:25:21,279
go has these green threads that let you

00:25:18,400 --> 00:25:23,360
run things concurrently and just block

00:25:21,279 --> 00:25:24,720
uh rust in tokyo give you kind of a

00:25:23,360 --> 00:25:26,720
similar set of primitives

00:25:24,720 --> 00:25:28,400
and tokyo has an ecosystem around it

00:25:26,720 --> 00:25:31,760
that really lets us

00:25:28,400 --> 00:25:33,679
build up uh new technique build up

00:25:31,760 --> 00:25:36,559
systems on these good primitives that

00:25:33,679 --> 00:25:36,559
are trustworthy

00:25:37,600 --> 00:25:41,679
the first one which we've invested

00:25:39,279 --> 00:25:44,400
heavily in linkedin a lot of the towers

00:25:41,679 --> 00:25:46,400
primitives come out of linkerity is this

00:25:44,400 --> 00:25:48,720
system called tower which is really

00:25:46,400 --> 00:25:50,320
similar to finagle's services and so

00:25:48,720 --> 00:25:52,159
it's a service abstraction where there's

00:25:50,320 --> 00:25:54,720
a request and a response

00:25:52,159 --> 00:25:56,880
and a set of you know layers or

00:25:54,720 --> 00:25:59,440
middlewares that'll let us

00:25:56,880 --> 00:26:01,760
layer stack these things together so

00:25:59,440 --> 00:26:04,240
they can be used and i can write

00:26:01,760 --> 00:26:05,279
loosely coupled components and then bind

00:26:04,240 --> 00:26:08,400
them together

00:26:05,279 --> 00:26:11,760
so here's an example from the linker d

00:26:08,400 --> 00:26:14,000
proxy this is an http client

00:26:11,760 --> 00:26:15,200
and so what this is for every endpoint

00:26:14,000 --> 00:26:16,960
we're talking to

00:26:15,200 --> 00:26:18,880
we build one of these services and this

00:26:16,960 --> 00:26:19,760
has an http client it has a reconnect

00:26:18,880 --> 00:26:21,919
layer

00:26:19,760 --> 00:26:23,120
it lets us do linkers tap feature and

00:26:21,919 --> 00:26:24,799
adds metrics

00:26:23,120 --> 00:26:26,480
and all of these compo all of these

00:26:24,799 --> 00:26:28,640
features are are

00:26:26,480 --> 00:26:29,919
you know orthogonal they have no

00:26:28,640 --> 00:26:34,000
dependencies on each other

00:26:29,919 --> 00:26:35,679
really um and so i can write all of

00:26:34,000 --> 00:26:36,960
these separate modules that are easily

00:26:35,679 --> 00:26:41,679
tested or easily

00:26:36,960 --> 00:26:44,880
shared and reused without having to

00:26:41,679 --> 00:26:48,240
couple them together this is a really

00:26:44,880 --> 00:26:49,919
great building block i also

00:26:48,240 --> 00:26:52,400
should emphasize that a lot of the

00:26:49,919 --> 00:26:55,600
primitives we've developed for lingerie

00:26:52,400 --> 00:26:59,120
are freely available in the tower uh

00:26:55,600 --> 00:27:00,480
library and framework um that so you can

00:26:59,120 --> 00:27:01,600
use for instance linkedin's load

00:27:00,480 --> 00:27:04,720
balancer

00:27:01,600 --> 00:27:05,520
without having to uh pull and link you

00:27:04,720 --> 00:27:08,159
that's that's a

00:27:05,520 --> 00:27:09,200
you know the tower balance project or

00:27:08,159 --> 00:27:12,400
crate

00:27:09,200 --> 00:27:13,760
is um something we've contributed back

00:27:12,400 --> 00:27:15,760
upstream

00:27:13,760 --> 00:27:17,279
so this is a again a set of reusable

00:27:15,760 --> 00:27:21,840
components that you can use to build

00:27:17,279 --> 00:27:21,840
new systems

00:27:23,679 --> 00:27:28,000
another library that we've been heavily

00:27:25,279 --> 00:27:32,080
involved with is something called tonic

00:27:28,000 --> 00:27:35,760
the tonic is a grpc binding for rust

00:27:32,080 --> 00:27:38,080
again cup really bound up with tower

00:27:35,760 --> 00:27:40,480
and tokyo's async runtime async

00:27:38,080 --> 00:27:43,440
networking

00:27:40,480 --> 00:27:45,360
tonic lets me write little grpc services

00:27:43,440 --> 00:27:48,640
so here on the right this is a load

00:27:45,360 --> 00:27:48,640
testing service that i wrote

00:27:48,960 --> 00:27:53,360
and we just have to implement you know

00:27:51,600 --> 00:27:56,240
we take a

00:27:53,360 --> 00:27:57,600
a grpc protobuf and we write the

00:27:56,240 --> 00:27:59,840
function

00:27:57,600 --> 00:28:01,279
that generated by that api and now we

00:27:59,840 --> 00:28:02,799
have a network server

00:28:01,279 --> 00:28:05,039
and so this makes it really easy to

00:28:02,799 --> 00:28:08,480
build microservices or little

00:28:05,039 --> 00:28:11,679
pieces of services in rust again with

00:28:08,480 --> 00:28:11,679
tokyo's async runtime

00:28:12,480 --> 00:28:17,520
finally i i want to call out

00:28:15,520 --> 00:28:18,960
another library which is newer in this

00:28:17,520 --> 00:28:22,080
ecosystem called

00:28:18,960 --> 00:28:25,440
kubar-s and kubr-s

00:28:22,080 --> 00:28:28,960
is basically client go for

00:28:25,440 --> 00:28:32,320
rust but it's uh so what it gives us

00:28:28,960 --> 00:28:33,039
is kubernetes api bindings and

00:28:32,320 --> 00:28:37,360
primitives

00:28:33,039 --> 00:28:40,720
that use the tokyo primitives

00:28:37,360 --> 00:28:44,559
that use that can be merged easily with

00:28:40,720 --> 00:28:46,640
tonic drpc services or tower services

00:28:44,559 --> 00:28:48,799
and so here is an example from a

00:28:46,640 --> 00:28:52,000
prototype i'm building

00:28:48,799 --> 00:28:53,120
which uh watches all pods in the cluster

00:28:52,000 --> 00:28:56,720
and it indexes

00:28:53,120 --> 00:28:58,320
which ports are available on those pods

00:28:56,720 --> 00:29:00,159
so this is something i'm really excited

00:28:58,320 --> 00:29:01,039
about because this means we may actually

00:29:00,159 --> 00:29:04,320
start

00:29:01,039 --> 00:29:05,760
being able to replace or as we add new

00:29:04,320 --> 00:29:07,679
controllers in linguity

00:29:05,760 --> 00:29:09,039
we can start doing them in rust where

00:29:07,679 --> 00:29:12,240
several years ago

00:29:09,039 --> 00:29:14,720
this was totally not possible now we

00:29:12,240 --> 00:29:16,960
have a rich ecosystem of projects

00:29:14,720 --> 00:29:17,919
around rust and around tokyo

00:29:16,960 --> 00:29:21,120
specifically

00:29:17,919 --> 00:29:23,039
that we can use to stamp out

00:29:21,120 --> 00:29:25,440
new infrastructure code that is going to

00:29:23,039 --> 00:29:27,520
be much safer that we're going to get

00:29:25,440 --> 00:29:28,799
more we'll be more productive writing

00:29:27,520 --> 00:29:32,640
and generally

00:29:28,799 --> 00:29:32,640
have a much easier time about it

00:29:33,520 --> 00:29:40,159
so in summary cloud computing creates

00:29:36,640 --> 00:29:41,679
new ubiquitous abstractions we no longer

00:29:40,159 --> 00:29:43,360
have to deal with managing hosts or

00:29:41,679 --> 00:29:46,399
acquiring hardware in nearly the same

00:29:43,360 --> 00:29:49,919
way that we did a decade ago

00:29:46,399 --> 00:29:53,200
now we have kubernetes apis and

00:29:49,919 --> 00:29:54,240
we have lots of glue beneath the

00:29:53,200 --> 00:29:56,640
application

00:29:54,240 --> 00:29:58,880
and we need that to work well we've all

00:29:56,640 --> 00:30:00,640
become system programmers anyone who

00:29:58,880 --> 00:30:01,360
would have been in operations a decade

00:30:00,640 --> 00:30:03,919
ago

00:30:01,360 --> 00:30:04,799
is basically a systems programmer now

00:30:03,919 --> 00:30:08,240
but

00:30:04,799 --> 00:30:10,960
scaling that out having to have you know

00:30:08,240 --> 00:30:11,520
an industry of people writing c would

00:30:10,960 --> 00:30:13,200
not

00:30:11,520 --> 00:30:15,200
be great it hasn't been great we have

00:30:13,200 --> 00:30:16,320
security vulnerabilities we have safety

00:30:15,200 --> 00:30:18,320
issues and

00:30:16,320 --> 00:30:20,720
we actually have you know c has a pretty

00:30:18,320 --> 00:30:23,039
steep learning and development curve

00:30:20,720 --> 00:30:24,640
and rust makes this way more accessible

00:30:23,039 --> 00:30:25,279
and one of the things i'm most excited

00:30:24,640 --> 00:30:27,919
about

00:30:25,279 --> 00:30:30,320
in the rust ecosystem is the number of

00:30:27,919 --> 00:30:32,799
young engineers getting involved here

00:30:30,320 --> 00:30:34,559
people in school or just out of school

00:30:32,799 --> 00:30:36,640
are really gravitating towards rust

00:30:34,559 --> 00:30:38,159
and i think that the industry is going

00:30:36,640 --> 00:30:41,600
to be transformed by this

00:30:38,159 --> 00:30:43,200
we're going to have a much richer more

00:30:41,600 --> 00:30:46,960
reliable

00:30:43,200 --> 00:30:49,200
systems ecosystem that's built on rust

00:30:46,960 --> 00:30:50,960
finally this wasn't possible a few years

00:30:49,200 --> 00:30:52,559
ago there's been a tremendous amount of

00:30:50,960 --> 00:30:54,880
investment

00:30:52,559 --> 00:30:55,760
our team has invested heavily in rust

00:30:54,880 --> 00:30:59,200
and in these

00:30:55,760 --> 00:31:02,720
ecosystem libraries folks at amazon

00:30:59,200 --> 00:31:05,120
and microsoft google

00:31:02,720 --> 00:31:06,880
you name it uh have have been investing

00:31:05,120 --> 00:31:09,919
in rust and i think that this

00:31:06,880 --> 00:31:11,760
really paints to a future that is going

00:31:09,919 --> 00:31:13,440
to be much safer

00:31:11,760 --> 00:31:17,200
more efficient better for the

00:31:13,440 --> 00:31:17,200
environment and more reliable

00:31:17,600 --> 00:31:21,760
and so finally thanks for coming i hope

00:31:20,159 --> 00:31:23,120
this talk was useful

00:31:21,760 --> 00:31:28,000
i hope you enjoy the rest of the talks

00:31:23,120 --> 00:31:28,000

YouTube URL: https://www.youtube.com/watch?v=BWL4889RKhU


