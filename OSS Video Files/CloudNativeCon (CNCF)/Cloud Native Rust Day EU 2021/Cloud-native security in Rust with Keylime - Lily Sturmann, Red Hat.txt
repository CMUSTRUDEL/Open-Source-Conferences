Title: Cloud-native security in Rust with Keylime - Lily Sturmann, Red Hat
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Cloud-native security in Rust with Keylime - Lily Sturmann, Red Hat

Keylime is a CNCF hosted, open source project that provides a highly scalable remote boot attestation and runtime integrity measurement solution. In early 2021, the Keylime team is wrapping up porting a key component of Keylime, the remote node cryptographically proving its security, from Python to Rust. This session presents an overview of Keylime with a focus on Rust as natural fit for this cloud-native security project.
Captions: 
	00:00:00,080 --> 00:00:04,399
hello and welcome to cloud native rust

00:00:02,159 --> 00:00:04,399
day

00:00:05,839 --> 00:00:09,920
my name is lily sturman i'm a software

00:00:08,160 --> 00:00:12,559
engineer at red hat

00:00:09,920 --> 00:00:13,040
and today i'll tell you a bit about key

00:00:12,559 --> 00:00:16,800
lime

00:00:13,040 --> 00:00:17,760
a cncf sandbox project and specifically

00:00:16,800 --> 00:00:19,920
about

00:00:17,760 --> 00:00:22,400
cloud native security and rust with key

00:00:19,920 --> 00:00:26,400
lime and about our ongoing experiences

00:00:22,400 --> 00:00:26,400
using rust as part of that project

00:00:27,920 --> 00:00:31,439
so first i want to summarize a little

00:00:30,240 --> 00:00:34,800
context about

00:00:31,439 --> 00:00:37,120
the problem that key lime is solving

00:00:34,800 --> 00:00:38,000
so many of you may be familiar with

00:00:37,120 --> 00:00:40,320
computers

00:00:38,000 --> 00:00:42,719
and by extension you may be familiar

00:00:40,320 --> 00:00:44,399
with the modern tech stack

00:00:42,719 --> 00:00:46,800
this is the modern tech stack as

00:00:44,399 --> 00:00:48,640
depicted by the talented randall monroe

00:00:46,800 --> 00:00:51,680
of xkcd

00:00:48,640 --> 00:00:55,760
and you might notice that it has

00:00:51,680 --> 00:00:59,280
a little problem and the problem is that

00:00:55,760 --> 00:01:00,160
uh this is a complex stack it has a lot

00:00:59,280 --> 00:01:02,000
of layers

00:01:00,160 --> 00:01:04,159
and that means that there is a large

00:01:02,000 --> 00:01:07,200
attack surface

00:01:04,159 --> 00:01:09,520
so it's hard to know that

00:01:07,200 --> 00:01:11,280
every single layer in a stack on a

00:01:09,520 --> 00:01:12,000
machine that you're working with is

00:01:11,280 --> 00:01:15,360
going to be

00:01:12,000 --> 00:01:17,360
secure and furthermore

00:01:15,360 --> 00:01:18,799
due to the nature of the stack hierarchy

00:01:17,360 --> 00:01:21,920
lower layers generally have

00:01:18,799 --> 00:01:25,360
access to higher layers of the stack

00:01:21,920 --> 00:01:28,240
so uh what this means is that if

00:01:25,360 --> 00:01:29,680
a lower stack layer is compromised the

00:01:28,240 --> 00:01:33,119
entire stack

00:01:29,680 --> 00:01:33,600
is compromised so you can try to write

00:01:33,119 --> 00:01:35,280
or

00:01:33,600 --> 00:01:37,520
to run a completely watertight

00:01:35,280 --> 00:01:39,520
application with all the security

00:01:37,520 --> 00:01:42,240
features that you want on your system

00:01:39,520 --> 00:01:43,200
but if there is a compromise lower down

00:01:42,240 --> 00:01:46,560
in the bootloader

00:01:43,200 --> 00:01:48,079
firmware host os or hypervisor if you're

00:01:46,560 --> 00:01:50,000
running a vm

00:01:48,079 --> 00:01:51,759
you will still be dealing with security

00:01:50,000 --> 00:01:54,560
problems

00:01:51,759 --> 00:01:55,920
so now if you imagine that you have many

00:01:54,560 --> 00:01:58,799
machines with a similar

00:01:55,920 --> 00:01:59,680
stack uh even remote machines in the

00:01:58,799 --> 00:02:03,280
cloud

00:01:59,680 --> 00:02:04,560
this problem compounds so

00:02:03,280 --> 00:02:06,560
especially when you're running in the

00:02:04,560 --> 00:02:08,479
cloud or on a remote machine

00:02:06,560 --> 00:02:10,399
you often have even less control over

00:02:08,479 --> 00:02:12,319
these various stack layers because

00:02:10,399 --> 00:02:13,840
you may not be in charge of all of them

00:02:12,319 --> 00:02:14,959
you may not have control over all of

00:02:13,840 --> 00:02:17,840
them

00:02:14,959 --> 00:02:20,080
so if you are running a remote machine

00:02:17,840 --> 00:02:23,040
it would be great to know

00:02:20,080 --> 00:02:24,000
if you should trust these layers both at

00:02:23,040 --> 00:02:27,200
boot time

00:02:24,000 --> 00:02:28,640
so you want to know that you're booting

00:02:27,200 --> 00:02:31,280
the machine that you expect

00:02:28,640 --> 00:02:32,560
in the state that you expect as well as

00:02:31,280 --> 00:02:35,680
during runtime

00:02:32,560 --> 00:02:36,560
you want to know that the code that

00:02:35,680 --> 00:02:39,360
you're running

00:02:36,560 --> 00:02:41,200
is uh running as expected in the same

00:02:39,360 --> 00:02:42,879
environment that you expect to run it in

00:02:41,200 --> 00:02:45,040
and that no bad actor has

00:02:42,879 --> 00:02:47,440
executed some malicious script on this

00:02:45,040 --> 00:02:47,440
machine

00:02:48,959 --> 00:02:52,319
so this is where key lime comes in uh

00:02:51,680 --> 00:02:55,280
key lime

00:02:52,319 --> 00:02:58,080
is a project that was started at mit

00:02:55,280 --> 00:03:00,080
lincoln labs in 2016

00:02:58,080 --> 00:03:01,120
and over time the project and its

00:03:00,080 --> 00:03:04,159
community grew

00:03:01,120 --> 00:03:06,640
and red hat got involved as well

00:03:04,159 --> 00:03:09,200
by 2020 last year the keyline project

00:03:06,640 --> 00:03:10,400
had been accepted as a cncf sandbox

00:03:09,200 --> 00:03:13,280
project

00:03:10,400 --> 00:03:15,680
and the code base began its life in

00:03:13,280 --> 00:03:18,480
python

00:03:15,680 --> 00:03:20,560
so what you see here is a simple

00:03:18,480 --> 00:03:23,920
depiction of the key lime setup

00:03:20,560 --> 00:03:27,120
on the left you see the remote machine

00:03:23,920 --> 00:03:30,000
which is also called the node or agent

00:03:27,120 --> 00:03:32,239
and this is the machine that's going to

00:03:30,000 --> 00:03:33,360
prove its trust to the key lime system

00:03:32,239 --> 00:03:36,959
so you can

00:03:33,360 --> 00:03:38,799
imagine it running this huge

00:03:36,959 --> 00:03:41,599
tech stack layer that you saw in the

00:03:38,799 --> 00:03:41,599
previous slide

00:03:42,480 --> 00:03:48,879
and before this machine is allowed to

00:03:46,560 --> 00:03:50,159
run any tasks or be included for example

00:03:48,879 --> 00:03:52,080
in a cluster

00:03:50,159 --> 00:03:53,760
it's going to have to prove to the

00:03:52,080 --> 00:03:56,319
system the key lime system via

00:03:53,760 --> 00:03:59,680
attestation that

00:03:56,319 --> 00:04:02,080
it is running in an expected state

00:03:59,680 --> 00:04:03,360
and you should know that there can be

00:04:02,080 --> 00:04:05,519
multiple ones of these

00:04:03,360 --> 00:04:06,640
agent machines but uh we're only showing

00:04:05,519 --> 00:04:08,799
one here on the screen just for

00:04:06,640 --> 00:04:11,360
simplicity

00:04:08,799 --> 00:04:12,159
so until this attestation process

00:04:11,360 --> 00:04:15,680
happens

00:04:12,159 --> 00:04:17,040
um and until it's checked uh by these

00:04:15,680 --> 00:04:18,000
components you see on the right hand

00:04:17,040 --> 00:04:20,000
side

00:04:18,000 --> 00:04:22,160
the agent is not trusted with sensitive

00:04:20,000 --> 00:04:24,560
data or payloads

00:04:22,160 --> 00:04:25,440
there's also a revocation framework in

00:04:24,560 --> 00:04:27,919
place

00:04:25,440 --> 00:04:28,960
to run a set of predefined actions if

00:04:27,919 --> 00:04:32,479
this agent node

00:04:28,960 --> 00:04:34,240
fails at a station even during run time

00:04:32,479 --> 00:04:35,919
for example maybe it was in a good state

00:04:34,240 --> 00:04:38,080
before but something happened some

00:04:35,919 --> 00:04:41,440
malicious script was executed

00:04:38,080 --> 00:04:45,840
and it's no longer in a known good state

00:04:41,440 --> 00:04:49,120
um and

00:04:45,840 --> 00:04:50,720
the agent machine will need a tpm

00:04:49,120 --> 00:04:52,160
which serves as a hardware route of

00:04:50,720 --> 00:04:55,199
trust

00:04:52,160 --> 00:04:57,440
the machines on the right hand side

00:04:55,199 --> 00:04:59,040
don't need a tpm these are components

00:04:57,440 --> 00:05:01,919
responsible for

00:04:59,040 --> 00:05:03,600
uh verifying the state of the machine on

00:05:01,919 --> 00:05:05,440
the left

00:05:03,600 --> 00:05:07,360
uh here they're called the verifier and

00:05:05,440 --> 00:05:10,080
the registrar

00:05:07,360 --> 00:05:10,960
and these components could be uh running

00:05:10,080 --> 00:05:13,360
on a machine

00:05:10,960 --> 00:05:15,600
on premises for example so they're

00:05:13,360 --> 00:05:18,880
communicating with the agent over on

00:05:15,600 --> 00:05:22,160
on an untrusted network

00:05:18,880 --> 00:05:23,360
uh and this is completely fine so at a

00:05:22,160 --> 00:05:26,400
high level what key

00:05:23,360 --> 00:05:27,520
offers is a way to measure the state of

00:05:26,400 --> 00:05:30,400
a remote machine

00:05:27,520 --> 00:05:31,360
during boot as well as at run time using

00:05:30,400 --> 00:05:34,000
something called

00:05:31,360 --> 00:05:35,919
integrity measurement architecture it

00:05:34,000 --> 00:05:38,240
allows for encrypted payloads to be

00:05:35,919 --> 00:05:40,080
delivered to that remote machine after

00:05:38,240 --> 00:05:43,120
the machine has attested its state

00:05:40,080 --> 00:05:44,800
through use of the tpm and it offers a

00:05:43,120 --> 00:05:46,639
revocation framework

00:05:44,800 --> 00:05:48,800
so in the case of that malicious script

00:05:46,639 --> 00:05:51,280
i mentioned before

00:05:48,800 --> 00:05:52,080
that node could be for example removed

00:05:51,280 --> 00:05:54,960
from the cluster

00:05:52,080 --> 00:05:57,199
automatically now there's a lot more to

00:05:54,960 --> 00:05:59,840
know about keylime and how it works

00:05:57,199 --> 00:06:00,800
and if you're curious i encourage you to

00:05:59,840 --> 00:06:03,759
check out

00:06:00,800 --> 00:06:03,759
keylime.dev

00:06:04,400 --> 00:06:08,000
but i just wanted to give an overview of

00:06:06,240 --> 00:06:10,319
this architecture so that you have some

00:06:08,000 --> 00:06:11,919
context for which portion we chose to

00:06:10,319 --> 00:06:15,280
port to rust

00:06:11,919 --> 00:06:19,840
and spoiler alert it is the

00:06:15,280 --> 00:06:23,199
the agent component so that remote

00:06:19,840 --> 00:06:25,039
and the reason that this component was

00:06:23,199 --> 00:06:25,600
chosen is basically because it's a

00:06:25,039 --> 00:06:27,840
smaller

00:06:25,600 --> 00:06:29,840
self-contained component um you see

00:06:27,840 --> 00:06:32,880
there are multiple components

00:06:29,840 --> 00:06:34,880
over on the right and uh

00:06:32,880 --> 00:06:36,880
we're open to potentially porting more

00:06:34,880 --> 00:06:37,360
but we just chose to start with the

00:06:36,880 --> 00:06:40,960
agent

00:06:37,360 --> 00:06:40,960
um for the first part

00:06:41,759 --> 00:06:45,840
so keylime is actually already available

00:06:44,720 --> 00:06:49,039
as an rpm

00:06:45,840 --> 00:06:51,440
in developer preview in fedora

00:06:49,039 --> 00:06:53,039
which um if you don't know fedora is a

00:06:51,440 --> 00:06:55,039
linux distribution developed by the

00:06:53,039 --> 00:06:58,560
fedora project

00:06:55,039 --> 00:06:59,199
and at red hat we have a philosophy of

00:06:58,560 --> 00:07:02,319
upstream

00:06:59,199 --> 00:07:02,880
first so we want to contribute directly

00:07:02,319 --> 00:07:05,120
to

00:07:02,880 --> 00:07:07,599
open source upstream code bases and

00:07:05,120 --> 00:07:09,599
build community around those code bases

00:07:07,599 --> 00:07:11,680
and fedora is one example of working

00:07:09,599 --> 00:07:13,599
with an open source community in this

00:07:11,680 --> 00:07:16,800
way

00:07:13,599 --> 00:07:17,759
so if you're looking for a key lime rpm

00:07:16,800 --> 00:07:19,840
for fedora

00:07:17,759 --> 00:07:21,280
it's already available at this link that

00:07:19,840 --> 00:07:23,360
you see on the slide

00:07:21,280 --> 00:07:26,400
and this is going to be using the

00:07:23,360 --> 00:07:30,000
original python version of keyline

00:07:26,400 --> 00:07:32,240
um so that's great but what about other

00:07:30,000 --> 00:07:33,440
use cases packaging for other

00:07:32,240 --> 00:07:35,680
distributions

00:07:33,440 --> 00:07:39,199
and was python really the best choice

00:07:35,680 --> 00:07:42,000
for a security oriented system like this

00:07:39,199 --> 00:07:44,000
these questions um were asked and they

00:07:42,000 --> 00:07:47,280
eventually converged around a decision

00:07:44,000 --> 00:07:49,680
to begin porting at least a portion of

00:07:47,280 --> 00:07:51,440
the the python keyline code base to a

00:07:49,680 --> 00:07:53,599
different language

00:07:51,440 --> 00:07:55,440
and as this is part of rust day you may

00:07:53,599 --> 00:07:57,199
be able to guess which language was

00:07:55,440 --> 00:07:59,599
chosen

00:07:57,199 --> 00:08:02,160
um but just as an example if you're

00:07:59,599 --> 00:08:05,759
curious about some of the considerations

00:08:02,160 --> 00:08:09,919
um that led to this decision

00:08:05,759 --> 00:08:12,240
there is the example of fedora core os

00:08:09,919 --> 00:08:14,960
for those not familiar this is another

00:08:12,240 --> 00:08:16,639
linux distribution which is

00:08:14,960 --> 00:08:19,440
uh it's known as an automatically

00:08:16,639 --> 00:08:21,440
updating minimal operating system for

00:08:19,440 --> 00:08:25,039
running containerized workloads

00:08:21,440 --> 00:08:26,800
securely and at scale so this is often

00:08:25,039 --> 00:08:29,840
used as a container host

00:08:26,800 --> 00:08:32,080
and it's known as an immutable operating

00:08:29,840 --> 00:08:34,880
system

00:08:32,080 --> 00:08:36,560
at a very high level it's meant to be a

00:08:34,880 --> 00:08:39,360
read-only operating system

00:08:36,560 --> 00:08:40,159
in the sense that all installed programs

00:08:39,360 --> 00:08:43,360
are defined

00:08:40,159 --> 00:08:46,480
by a single commit hash um

00:08:43,360 --> 00:08:48,640
and this commit hash basically um

00:08:46,480 --> 00:08:49,680
describes everything that is installed

00:08:48,640 --> 00:08:52,000
on the system

00:08:49,680 --> 00:08:54,080
so the system can be atomically upgraded

00:08:52,000 --> 00:08:57,519
or rolled back to a particular hash

00:08:54,080 --> 00:09:01,680
and this can make it a lot easier to

00:08:57,519 --> 00:09:01,680
manage a large number of these machines

00:09:01,760 --> 00:09:05,920
and as you can imagine you're not going

00:09:03,760 --> 00:09:10,160
to want to be

00:09:05,920 --> 00:09:12,320
installing a different programs um

00:09:10,160 --> 00:09:14,240
that uh that the system doesn't have

00:09:12,320 --> 00:09:17,200
installed already you want to

00:09:14,240 --> 00:09:18,480
really anchor it in a particular commit

00:09:17,200 --> 00:09:20,640
hash so that you know the state of the

00:09:18,480 --> 00:09:24,320
system

00:09:20,640 --> 00:09:26,160
so uh for this fedora core os use case

00:09:24,320 --> 00:09:28,000
if you want to package a program for

00:09:26,160 --> 00:09:29,120
this type of distribution

00:09:28,000 --> 00:09:30,800
you're going to want to know all the

00:09:29,120 --> 00:09:32,320
dependencies ahead of time you're going

00:09:30,800 --> 00:09:34,000
to want the program to be very

00:09:32,320 --> 00:09:35,600
self-contained

00:09:34,000 --> 00:09:37,360
because we're not going to want to be

00:09:35,600 --> 00:09:40,080
updating the os to install new

00:09:37,360 --> 00:09:42,800
dependencies when the program is running

00:09:40,080 --> 00:09:45,839
and um fedora core os also tries to be

00:09:42,800 --> 00:09:47,920
very minimal in its dependency tree

00:09:45,839 --> 00:09:50,399
uh so a python program would actually

00:09:47,920 --> 00:09:53,920
add a lot of complication to that tree

00:09:50,399 --> 00:09:56,640
so python was not a good choice here

00:09:53,920 --> 00:09:58,399
and we didn't want to pull in a vast

00:09:56,640 --> 00:10:00,160
number of dependencies that a python

00:09:58,399 --> 00:10:01,760
program would require for something like

00:10:00,160 --> 00:10:03,519
this

00:10:01,760 --> 00:10:05,360
so this is some of the thinking that led

00:10:03,519 --> 00:10:06,959
to the decision to port

00:10:05,360 --> 00:10:08,720
some portion of key lime over to a

00:10:06,959 --> 00:10:10,880
different language that

00:10:08,720 --> 00:10:13,440
is more compatible with a distro like

00:10:10,880 --> 00:10:13,440
core os

00:10:14,959 --> 00:10:18,000
now uh for the big reveal the language

00:10:17,200 --> 00:10:21,040
that was chosen

00:10:18,000 --> 00:10:24,079
was rust and

00:10:21,040 --> 00:10:25,760
in addition to being a compiled language

00:10:24,079 --> 00:10:26,399
that we can create a self-contained

00:10:25,760 --> 00:10:30,560
binary

00:10:26,399 --> 00:10:33,519
it had multiple other advantages as well

00:10:30,560 --> 00:10:34,959
and some of you rust fans might already

00:10:33,519 --> 00:10:38,880
know some of these things about

00:10:34,959 --> 00:10:40,800
rust um it has better performance than

00:10:38,880 --> 00:10:43,600
some other languages because it doesn't

00:10:40,800 --> 00:10:46,640
have garbage collection for example

00:10:43,600 --> 00:10:47,680
and also for us especially as a security

00:10:46,640 --> 00:10:50,000
project

00:10:47,680 --> 00:10:51,279
we had a lot of security considerations

00:10:50,000 --> 00:10:54,399
so

00:10:51,279 --> 00:10:56,880
the ownership enforcement that rust has

00:10:54,399 --> 00:10:58,480
is very useful in terms of memory and

00:10:56,880 --> 00:11:00,800
thread safety

00:10:58,480 --> 00:11:01,519
and the rigorous type checking from the

00:11:00,800 --> 00:11:04,160
compiler

00:11:01,519 --> 00:11:05,120
avoids unexpected behavior at runtime

00:11:04,160 --> 00:11:07,360
which is

00:11:05,120 --> 00:11:09,600
very important nobody wants unexpected

00:11:07,360 --> 00:11:12,079
behavior at runtime

00:11:09,600 --> 00:11:14,240
and then um we also get to have some

00:11:12,079 --> 00:11:15,360
less concern about side channel attacks

00:11:14,240 --> 00:11:16,800
which is interesting

00:11:15,360 --> 00:11:19,200
there are some papers about this

00:11:16,800 --> 00:11:22,480
actually that i didn't link here

00:11:19,200 --> 00:11:24,240
um but the lack of garbage collection

00:11:22,480 --> 00:11:25,680
leads to more predictable performance

00:11:24,240 --> 00:11:27,360
which could actually help with some

00:11:25,680 --> 00:11:30,640
timing attacks

00:11:27,360 --> 00:11:32,959
and um additionally there's helpful uh

00:11:30,640 --> 00:11:35,040
rust ecosystem around security for

00:11:32,959 --> 00:11:38,560
example there's even a crate

00:11:35,040 --> 00:11:40,399
called timing shield that is uh

00:11:38,560 --> 00:11:42,160
able to help you guard against some of

00:11:40,399 --> 00:11:43,839
these side channel attacks now we

00:11:42,160 --> 00:11:44,560
haven't used this particular crate in

00:11:43,839 --> 00:11:47,360
our project

00:11:44,560 --> 00:11:49,600
but i did find it and i just thought it

00:11:47,360 --> 00:11:53,360
was interesting

00:11:49,600 --> 00:11:56,240
so additionally rust also gives us

00:11:53,360 --> 00:11:59,440
some helpful compilation targets it has

00:11:56,240 --> 00:12:01,120
an arm target for example

00:11:59,440 --> 00:12:03,600
for internet of things that could be

00:12:01,120 --> 00:12:06,480
very useful down the line

00:12:03,600 --> 00:12:08,079
and it's also got very good foreign

00:12:06,480 --> 00:12:10,480
function interface

00:12:08,079 --> 00:12:12,800
so some of you may be familiar with bind

00:12:10,480 --> 00:12:14,560
gen which automatically generates

00:12:12,800 --> 00:12:16,240
uh rust foreign function interface

00:12:14,560 --> 00:12:18,959
bindings to c

00:12:16,240 --> 00:12:20,720
um that's been really useful for systems

00:12:18,959 --> 00:12:23,040
programming

00:12:20,720 --> 00:12:24,560
so um these are just some of the

00:12:23,040 --> 00:12:27,279
highlights of uh

00:12:24,560 --> 00:12:28,160
why rust seemed like a good fit for our

00:12:27,279 --> 00:12:30,880
project

00:12:28,160 --> 00:12:33,120
and um it's been panning out pretty well

00:12:30,880 --> 00:12:36,399
so far

00:12:33,120 --> 00:12:38,000
and there's actually um

00:12:36,399 --> 00:12:39,440
something else that i wanted to

00:12:38,000 --> 00:12:41,040
highlight which

00:12:39,440 --> 00:12:43,120
i think could be very exciting for other

00:12:41,040 --> 00:12:46,480
security projects

00:12:43,120 --> 00:12:49,279
um so the tpm

00:12:46,480 --> 00:12:51,680
that i mentioned is critical not just to

00:12:49,279 --> 00:12:54,079
our project but

00:12:51,680 --> 00:12:55,839
i imagine is widely used in other

00:12:54,079 --> 00:12:58,639
security projects which like to have a

00:12:55,839 --> 00:13:01,040
hardware route of trust

00:12:58,639 --> 00:13:02,240
so it's reasonable to think that rust as

00:13:01,040 --> 00:13:04,560
a language choice

00:13:02,240 --> 00:13:06,240
for such a project would be accepted or

00:13:04,560 --> 00:13:10,320
rejected based on

00:13:06,240 --> 00:13:10,320
how easy it is to work with tpms

00:13:10,880 --> 00:13:14,880
now as mentioned a moment ago rust

00:13:12,800 --> 00:13:17,680
already has pretty good ffi

00:13:14,880 --> 00:13:18,000
to see generally which helps as uh tpms

00:13:17,680 --> 00:13:21,279
will

00:13:18,000 --> 00:13:24,000
have a c interface often um

00:13:21,279 --> 00:13:25,200
so it's possible to use uh rust already

00:13:24,000 --> 00:13:29,040
to talk to a c

00:13:25,200 --> 00:13:30,000
tpm but this library this new library

00:13:29,040 --> 00:13:35,120
here the

00:13:30,000 --> 00:13:37,279
tss2 enhanced system api rust wrapper

00:13:35,120 --> 00:13:40,880
just makes it a lot easier because it

00:13:37,279 --> 00:13:43,920
has those bindings already

00:13:40,880 --> 00:13:46,240
it's actually basically a wrapper that

00:13:43,920 --> 00:13:49,839
binds to

00:13:46,240 --> 00:13:51,279
the tpm2 software that some people may

00:13:49,839 --> 00:13:54,880
already be familiar with

00:13:51,279 --> 00:13:58,560
um it's a pre-existing library

00:13:54,880 --> 00:14:01,199
uh a c library for communicating with

00:13:58,560 --> 00:14:01,199
the tpm

00:14:01,600 --> 00:14:07,360
so uh this is a new library

00:14:04,800 --> 00:14:09,199
um it's helped us a lot it's been

00:14:07,360 --> 00:14:12,160
undergoing active development

00:14:09,199 --> 00:14:14,079
the past few months so we actually had

00:14:12,160 --> 00:14:18,480
some functionality in our project

00:14:14,079 --> 00:14:21,440
uh where uh we used some of the

00:14:18,480 --> 00:14:23,440
interfaces from this uh this crate as it

00:14:21,440 --> 00:14:26,880
became available

00:14:23,440 --> 00:14:28,560
um which meant pinning our dependency to

00:14:26,880 --> 00:14:32,480
this library and cargo.tomol

00:14:28,560 --> 00:14:35,279
actually to the git repo the tss

00:14:32,480 --> 00:14:36,639
enhanced system api rust wrap or git

00:14:35,279 --> 00:14:39,920
repo instead of the

00:14:36,639 --> 00:14:42,240
officially released version which is

00:14:39,920 --> 00:14:45,680
also a cool rust feature that

00:14:42,240 --> 00:14:49,519
you can actually pin your dependency

00:14:45,680 --> 00:14:52,880
to a very new code in a git repo

00:14:49,519 --> 00:14:56,639
that was useful to us here as well

00:14:52,880 --> 00:14:58,160
so uh by using this library we

00:14:56,639 --> 00:14:59,680
avoided having to call out to see

00:14:58,160 --> 00:15:01,040
ourselves we saved ourselves a little

00:14:59,680 --> 00:15:03,040
bit of time

00:15:01,040 --> 00:15:05,120
um and we also saved ourselves from

00:15:03,040 --> 00:15:07,839
having to

00:15:05,120 --> 00:15:09,760
issue shell commands to tpm which i

00:15:07,839 --> 00:15:13,120
believe the python version of

00:15:09,760 --> 00:15:15,199
keylime code was doing so we have more

00:15:13,120 --> 00:15:18,079
direct communication with the tpm this

00:15:15,199 --> 00:15:18,079
way which is great

00:15:21,680 --> 00:15:25,360
and what about our other experiences

00:15:24,000 --> 00:15:28,560
with porting to rust

00:15:25,360 --> 00:15:30,800
well overall it's had everything that we

00:15:28,560 --> 00:15:34,240
need in terms of cloud native security

00:15:30,800 --> 00:15:35,680
um we've been able to have server client

00:15:34,240 --> 00:15:38,399
interactions which the

00:15:35,680 --> 00:15:40,240
agent node needs in order to communicate

00:15:38,399 --> 00:15:43,519
with the verifier and the registrar

00:15:40,240 --> 00:15:44,959
over this untrusted network um

00:15:43,519 --> 00:15:46,639
there are a lot of great crates out

00:15:44,959 --> 00:15:49,360
there for this type of communication

00:15:46,639 --> 00:15:51,040
already uh i've just highlighted a few

00:15:49,360 --> 00:15:53,920
here that we've used

00:15:51,040 --> 00:15:54,800
like request as a client there's actix

00:15:53,920 --> 00:15:57,839
web

00:15:54,800 --> 00:16:00,399
for the server there's zmq

00:15:57,839 --> 00:16:02,560
and we've been able to have uh this type

00:16:00,399 --> 00:16:05,440
of communication asynchronously between

00:16:02,560 --> 00:16:08,959
the components when we need it

00:16:05,440 --> 00:16:09,920
so also on top of rust safe and speedy

00:16:08,959 --> 00:16:13,279
memory management

00:16:09,920 --> 00:16:16,240
rust has the helpful mutex primitive

00:16:13,279 --> 00:16:18,639
for a shared memory where we need to

00:16:16,240 --> 00:16:21,440
restrict access to one thread at a time

00:16:18,639 --> 00:16:23,600
like we have something called a tpm

00:16:21,440 --> 00:16:26,240
contacts that we only want

00:16:23,600 --> 00:16:27,199
one thread to be able to access at once

00:16:26,240 --> 00:16:30,240
so

00:16:27,199 --> 00:16:32,000
this has been very easy to use even with

00:16:30,240 --> 00:16:34,240
one of the other crates the actix web

00:16:32,000 --> 00:16:36,000
crate

00:16:34,240 --> 00:16:38,639
and of course in a security project

00:16:36,000 --> 00:16:41,920
we're going to need to use cryptography

00:16:38,639 --> 00:16:43,680
so uh there are helpful crypto libraries

00:16:41,920 --> 00:16:46,720
available for us as well

00:16:43,680 --> 00:16:48,800
and we've been using the openssl crate

00:16:46,720 --> 00:16:51,839
when we need to handle things like rsa

00:16:48,800 --> 00:16:51,839
key pairs in the code

00:16:52,720 --> 00:16:55,920
so as for cons there haven't been too

00:16:55,279 --> 00:16:57,680
many

00:16:55,920 --> 00:16:59,920
and some of these may come up in other

00:16:57,680 --> 00:17:02,880
languages as well but

00:16:59,920 --> 00:17:04,559
one of the things that we've thought

00:17:02,880 --> 00:17:06,559
about as a con is that there's still a

00:17:04,559 --> 00:17:07,839
lot of active development going on in a

00:17:06,559 --> 00:17:10,559
lot of rust crates

00:17:07,839 --> 00:17:12,000
and some of the libraries that we've

00:17:10,559 --> 00:17:13,919
used have had

00:17:12,000 --> 00:17:15,679
changing apis or maybe outdated

00:17:13,919 --> 00:17:17,199
documentation just because of the rapid

00:17:15,679 --> 00:17:19,520
pace of development

00:17:17,199 --> 00:17:21,120
so we've just had to um check on that

00:17:19,520 --> 00:17:23,600
and adapt to it and maybe do some

00:17:21,120 --> 00:17:27,039
revision if we hit any bumps

00:17:23,600 --> 00:17:29,520
but this hasn't been too bad um and

00:17:27,039 --> 00:17:31,600
secondly there is a higher barrier to

00:17:29,520 --> 00:17:33,120
entry for getting participation in a

00:17:31,600 --> 00:17:36,240
rust project

00:17:33,120 --> 00:17:38,000
because the rust

00:17:36,240 --> 00:17:39,360
rust basically still isn't a language

00:17:38,000 --> 00:17:42,480
that a lot of people know

00:17:39,360 --> 00:17:43,919
and so there can be um kind of a barrier

00:17:42,480 --> 00:17:45,520
or a bit of a learning curve even if

00:17:43,919 --> 00:17:48,080
someone is interested as they try to

00:17:45,520 --> 00:17:49,679
learn rust really fast

00:17:48,080 --> 00:17:51,760
but hopefully the rest community will

00:17:49,679 --> 00:17:54,160
keep growing and hopefully the

00:17:51,760 --> 00:17:58,000
rust ecosystem will keep growing and

00:17:54,160 --> 00:17:58,000
eventually maybe this won't be a concern

00:17:59,600 --> 00:18:03,520
so the current status um specifically of

00:18:02,559 --> 00:18:06,400
the rust port

00:18:03,520 --> 00:18:07,760
of key lime is uh i'd say it's about

00:18:06,400 --> 00:18:09,919
eighty percent done

00:18:07,760 --> 00:18:12,400
um a lot of the functionality from the

00:18:09,919 --> 00:18:15,360
python agent is already in place

00:18:12,400 --> 00:18:16,640
so the agent needs to be registered and

00:18:15,360 --> 00:18:20,080
activated as part

00:18:16,640 --> 00:18:21,440
of the key lime system and code is

00:18:20,080 --> 00:18:22,160
already in place to go through those

00:18:21,440 --> 00:18:24,480
steps

00:18:22,160 --> 00:18:27,120
and we also have the revocation

00:18:24,480 --> 00:18:28,720
framework in place so that's if

00:18:27,120 --> 00:18:30,480
that's the case where a malicious script

00:18:28,720 --> 00:18:32,320
is executed on the node we

00:18:30,480 --> 00:18:34,000
want to run some actions to make sure

00:18:32,320 --> 00:18:37,760
that we don't uh

00:18:34,000 --> 00:18:39,360
keep trusting that machine so

00:18:37,760 --> 00:18:40,880
uh we're still working on the

00:18:39,360 --> 00:18:43,679
attestation that's for

00:18:40,880 --> 00:18:45,520
boot and for runtime and of course we're

00:18:43,679 --> 00:18:47,360
going to want to do some

00:18:45,520 --> 00:18:49,280
extensive testing before we're able to

00:18:47,360 --> 00:18:52,000
package this

00:18:49,280 --> 00:18:53,840
but we're getting there and it's been an

00:18:52,000 --> 00:18:54,160
exciting and rewarding project that we

00:18:53,840 --> 00:18:57,840
hope

00:18:54,160 --> 00:18:57,840
will be useful to people

00:18:58,799 --> 00:19:02,640
so if you're curious if you want to find

00:19:01,200 --> 00:19:05,039
out more get in touch we

00:19:02,640 --> 00:19:07,480
really encourage you to do so um you can

00:19:05,039 --> 00:19:10,160
visit any of our resources

00:19:07,480 --> 00:19:10,720
keylime.dev here is the shortest one if

00:19:10,160 --> 00:19:12,400
you

00:19:10,720 --> 00:19:15,200
only want to type in one link that'll

00:19:12,400 --> 00:19:18,559
get you to a lot of other information

00:19:15,200 --> 00:19:21,840
we also have the cncf page as we're a

00:19:18,559 --> 00:19:25,600
cncf sandbox project so you can visit us

00:19:21,840 --> 00:19:26,960
on the cncf site and if you're curious

00:19:25,600 --> 00:19:27,840
about the code or interested in

00:19:26,960 --> 00:19:30,799
contributing

00:19:27,840 --> 00:19:32,559
we've also got github repos for both the

00:19:30,799 --> 00:19:34,000
python and the rust version of the code

00:19:32,559 --> 00:19:36,640
base

00:19:34,000 --> 00:19:38,000
we've also got a slack channel so if you

00:19:36,640 --> 00:19:40,400
have any thoughts or questions

00:19:38,000 --> 00:19:42,720
we encourage you to join that um i

00:19:40,400 --> 00:19:44,880
believe there's also a bi-monthly

00:19:42,720 --> 00:19:46,640
text-based meeting on that same channel

00:19:44,880 --> 00:19:48,480
which is kind of cool so

00:19:46,640 --> 00:19:50,720
uh you don't have to turn on your video

00:19:48,480 --> 00:19:51,039
or or any of that kind of stuff um it's

00:19:50,720 --> 00:19:54,400
a

00:19:51,039 --> 00:19:56,799
purely text-based meeting

00:19:54,400 --> 00:19:58,320
and i also thought i would plug the tss

00:19:56,799 --> 00:20:00,240
es api again

00:19:58,320 --> 00:20:01,600
this is the library for working with the

00:20:00,240 --> 00:20:03,039
tpm

00:20:01,600 --> 00:20:04,799
because this is so useful and worth

00:20:03,039 --> 00:20:06,880
checking out and

00:20:04,799 --> 00:20:08,320
they uh i think they're also a cncf

00:20:06,880 --> 00:20:09,600
project because they also have their own

00:20:08,320 --> 00:20:13,919
slack channel

00:20:09,600 --> 00:20:16,720
um on the same cncf slack

00:20:13,919 --> 00:20:17,679
so thanks very much for listening if you

00:20:16,720 --> 00:20:19,919
have any

00:20:17,679 --> 00:20:22,640
thoughts or questions please let me know

00:20:19,919 --> 00:20:27,200
reach out on slack

00:20:22,640 --> 00:20:27,200

YouTube URL: https://www.youtube.com/watch?v=RBiSQzZuH7k


