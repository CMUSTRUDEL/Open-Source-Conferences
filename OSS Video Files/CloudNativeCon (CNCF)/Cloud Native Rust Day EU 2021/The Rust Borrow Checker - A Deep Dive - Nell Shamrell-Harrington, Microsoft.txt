Title: The Rust Borrow Checker - A Deep Dive - Nell Shamrell-Harrington, Microsoft
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

The Rust Borrow Checker - A Deep Dive - Nell Shamrell-Harrington, Microsoft

The Rust compiler's borrow checker is critical for ensuring safe Rust code. Even more critical, however, is how the borrow checker provides useful, automated guidance on how to write safe code when the check fails. Early in your Rust journey it may feel like you are fighting the borrow checker. Come to this talk to learn how you can transition from fighting the borrow checker to using its guidance to write safer and more powerful code at any experience level. Walk away not only understanding the what and the how of the borrow checker - but why it works the way it does - and why it is so critical to both the technical functionality and philosophy of Rust.
Captions: 
	00:00:00,080 --> 00:00:04,240
well hello everyone around the world

00:00:02,480 --> 00:00:05,680
thank you so much for having me here

00:00:04,240 --> 00:00:07,359
today

00:00:05,680 --> 00:00:09,120
when i work with someone who is just

00:00:07,359 --> 00:00:11,040
learning rust

00:00:09,120 --> 00:00:12,400
they sometimes question whether the rust

00:00:11,040 --> 00:00:16,160
borrow checker is

00:00:12,400 --> 00:00:16,720
their friend or their foe if you take a

00:00:16,160 --> 00:00:19,119
look

00:00:16,720 --> 00:00:22,080
at the rus subreddit it's common to see

00:00:19,119 --> 00:00:23,519
posts with headlines like this

00:00:22,080 --> 00:00:25,680
newbie your question regarding the

00:00:23,519 --> 00:00:28,960
borrow checker

00:00:25,680 --> 00:00:31,840
help fighting the borrow checker

00:00:28,960 --> 00:00:34,480
and does it ever get easier fighting

00:00:31,840 --> 00:00:36,960
with the borrow checker

00:00:34,480 --> 00:00:39,200
however as you watch people get more

00:00:36,960 --> 00:00:41,120
experience and rust

00:00:39,200 --> 00:00:42,640
they tend to come around to the borrow

00:00:41,120 --> 00:00:45,360
checker and realize

00:00:42,640 --> 00:00:46,480
what it protects them from doing so in

00:00:45,360 --> 00:00:49,520
answer to the question

00:00:46,480 --> 00:00:52,160
is the borrow checker a friend or a foe

00:00:49,520 --> 00:00:54,800
i say the borrow checker will become

00:00:52,160 --> 00:00:56,719
your friend through experience

00:00:54,800 --> 00:00:59,520
and along with gaining experience with

00:00:56,719 --> 00:01:00,559
it it's also very helpful to understand

00:00:59,520 --> 00:01:03,440
how it works

00:01:00,559 --> 00:01:05,439
and why it does the things it does we're

00:01:03,440 --> 00:01:06,640
going to dive deep into that but before

00:01:05,439 --> 00:01:09,360
we do

00:01:06,640 --> 00:01:11,119
let's briefly cover who i am i'm nell

00:01:09,360 --> 00:01:13,920
shamrell harrington i'm a principal

00:01:11,119 --> 00:01:15,119
software engineer at microsoft i'm also

00:01:13,920 --> 00:01:17,439
a board director

00:01:15,119 --> 00:01:19,119
of the rust foundation i'm the lead

00:01:17,439 --> 00:01:20,960
editor of this week in rust if you're

00:01:19,119 --> 00:01:22,000
not subscribed i hope you subscribe

00:01:20,960 --> 00:01:24,080
right after this

00:01:22,000 --> 00:01:26,080
to keep up with all the wonderful things

00:01:24,080 --> 00:01:28,000
the rust community is doing

00:01:26,080 --> 00:01:29,840
you can also tweet at me at neil

00:01:28,000 --> 00:01:33,040
shamrell if you wish to get in touch

00:01:29,840 --> 00:01:33,040
with me or just say hi

00:01:34,400 --> 00:01:37,840
and to set expectations we will first do

00:01:36,960 --> 00:01:40,159
a bit of

00:01:37,840 --> 00:01:41,600
background on the rust compiler in order

00:01:40,159 --> 00:01:44,640
to put the borrow checker in

00:01:41,600 --> 00:01:47,520
context then we will do a deep dive

00:01:44,640 --> 00:01:49,040
on the borrow checker and let's go ahead

00:01:47,520 --> 00:01:51,600
and start with an overview of the rust

00:01:49,040 --> 00:01:51,600
compiler

00:01:51,680 --> 00:01:56,719
let's take a look at a code example this

00:01:54,799 --> 00:01:58,560
rust function

00:01:56,719 --> 00:01:59,759
declares a vector composed of the

00:01:58,560 --> 00:02:02,880
integers 1

00:01:59,759 --> 00:02:05,520
2 3 4 and 5.

00:02:02,880 --> 00:02:07,840
after it declares this vector it then

00:02:05,520 --> 00:02:08,959
uses a for loop to iterate through each

00:02:07,840 --> 00:02:12,400
integer in the vector

00:02:08,959 --> 00:02:14,160
and print it out on a new line

00:02:12,400 --> 00:02:16,239
so let's go ahead and run this code

00:02:14,160 --> 00:02:18,319
using cargo

00:02:16,239 --> 00:02:22,080
and as expected we see the numbers 1

00:02:18,319 --> 00:02:25,040
through 5 printed out on the screen

00:02:22,080 --> 00:02:27,360
seems pretty simple cargo builds and

00:02:25,040 --> 00:02:29,120
runs the piece of code for us

00:02:27,360 --> 00:02:30,640
but there is a lot that happens

00:02:29,120 --> 00:02:32,879
underneath the surface

00:02:30,640 --> 00:02:35,040
in the compiler when cargo is building

00:02:32,879 --> 00:02:37,200
it

00:02:35,040 --> 00:02:39,200
there are five general stages to

00:02:37,200 --> 00:02:41,200
compiling a piece of code

00:02:39,200 --> 00:02:42,480
it starts with a lexical analysis of the

00:02:41,200 --> 00:02:45,680
code

00:02:42,480 --> 00:02:46,800
then parsing of the code semantic

00:02:45,680 --> 00:02:48,319
analysis of the code

00:02:46,800 --> 00:02:50,720
this is where the borrow checker comes

00:02:48,319 --> 00:02:54,319
in in the rust compiler

00:02:50,720 --> 00:02:56,640
optimization of the code and finally

00:02:54,319 --> 00:02:58,959
code generation where the compiler

00:02:56,640 --> 00:03:00,080
creates the executable binary of our

00:02:58,959 --> 00:03:02,000
code

00:03:00,080 --> 00:03:04,000
when we look at the stages laid out in a

00:03:02,000 --> 00:03:05,599
list like this it seems like they will

00:03:04,000 --> 00:03:08,720
run linearly

00:03:05,599 --> 00:03:10,879
and in some compilers they do

00:03:08,720 --> 00:03:12,480
however if you've delved it all into the

00:03:10,879 --> 00:03:15,680
rest compiler internals

00:03:12,480 --> 00:03:17,280
you might be thinking wait a minute

00:03:15,680 --> 00:03:18,800
isn't the rust compiler at least

00:03:17,280 --> 00:03:21,840
partially query based

00:03:18,800 --> 00:03:24,319
rather than linear based

00:03:21,840 --> 00:03:26,239
and the answer to this question is yes

00:03:24,319 --> 00:03:27,680
but that is out of the scope of this

00:03:26,239 --> 00:03:29,920
particular talk

00:03:27,680 --> 00:03:31,680
for the sake of clarity i'll speak to

00:03:29,920 --> 00:03:33,840
the internals of the compiler as if they

00:03:31,680 --> 00:03:36,799
were functioning linearly

00:03:33,840 --> 00:03:38,640
however if you want to delve more into

00:03:36,799 --> 00:03:39,760
how the rust compiler is query based and

00:03:38,640 --> 00:03:41,519
what that means

00:03:39,760 --> 00:03:43,840
check out the guide to rust c

00:03:41,519 --> 00:03:46,000
development for more information

00:03:43,840 --> 00:03:47,680
this guide has been a big help to me as

00:03:46,000 --> 00:03:50,319
i've learned how to hack on the rust

00:03:47,680 --> 00:03:50,319
compiler

00:03:51,440 --> 00:03:55,760
going back to the stages of compilation

00:03:53,840 --> 00:04:00,080
let's start with the first one here

00:03:55,760 --> 00:04:01,760
lexical analysis during lexical analysis

00:04:00,080 --> 00:04:03,280
a program within the compiler called

00:04:01,760 --> 00:04:05,599
alexa

00:04:03,280 --> 00:04:06,319
takes the raw rust source code called a

00:04:05,599 --> 00:04:09,439
lexeme

00:04:06,319 --> 00:04:11,360
and analyzes it then splits the code

00:04:09,439 --> 00:04:14,799
into tokens to make it easier for the

00:04:11,360 --> 00:04:16,560
compiler to parse

00:04:14,799 --> 00:04:20,239
and that brings us the next stage of

00:04:16,560 --> 00:04:21,840
compilation called parsing

00:04:20,239 --> 00:04:24,400
in this stage a program within the

00:04:21,840 --> 00:04:26,960
compiler called a parser

00:04:24,400 --> 00:04:28,880
analyzes the tokens generated by the

00:04:26,960 --> 00:04:31,040
lecter

00:04:28,880 --> 00:04:33,759
and translates them into an abstract

00:04:31,040 --> 00:04:35,759
syntax tree or ast

00:04:33,759 --> 00:04:37,759
having the tokens in this data structure

00:04:35,759 --> 00:04:38,560
makes it much quicker and easier for the

00:04:37,759 --> 00:04:42,160
compiler

00:04:38,560 --> 00:04:44,320
to do the rest of its work

00:04:42,160 --> 00:04:46,000
at this stage before it moves on to the

00:04:44,320 --> 00:04:49,199
next stage of compilation

00:04:46,000 --> 00:04:53,040
the rust compiler takes that abstract

00:04:49,199 --> 00:04:56,639
syntax tree generated by the parser

00:04:53,040 --> 00:04:58,639
and first expands any macros included in

00:04:56,639 --> 00:05:01,360
the code

00:04:58,639 --> 00:05:03,840
if we look back at our code example and

00:05:01,360 --> 00:05:06,720
let's zoom in on this line

00:05:03,840 --> 00:05:08,479
print line is a macro which means this

00:05:06,720 --> 00:05:11,280
line would be expanded

00:05:08,479 --> 00:05:12,400
to this this is what the full print line

00:05:11,280 --> 00:05:14,800
macro looks like

00:05:12,400 --> 00:05:17,120
and how it will be represented in the

00:05:14,800 --> 00:05:19,199
act

00:05:17,120 --> 00:05:21,120
this is part of me this is what the full

00:05:19,199 --> 00:05:25,840
print line macro looks like and how it

00:05:21,120 --> 00:05:25,840
will be represented in the ast

00:05:26,320 --> 00:05:30,320
it also de-sugars some of the syntactic

00:05:28,800 --> 00:05:31,520
sugar that makes riding rust so

00:05:30,320 --> 00:05:34,880
delightful

00:05:31,520 --> 00:05:37,600
for example in rust the for loop is a

00:05:34,880 --> 00:05:39,759
piece of syntactic sugar for an iterator

00:05:37,600 --> 00:05:41,039
if we were to de-sugar this section of

00:05:39,759 --> 00:05:42,800
code

00:05:41,039 --> 00:05:44,720
it would consist of both a match

00:05:42,800 --> 00:05:46,320
statement and a loop

00:05:44,720 --> 00:05:48,800
the functionality of this code is

00:05:46,320 --> 00:05:50,240
identical but de-sugaring it makes it

00:05:48,800 --> 00:05:54,000
easier for the compiler to

00:05:50,240 --> 00:05:54,000
understand it and optimize it

00:05:54,160 --> 00:05:58,639
at this time the compiler also resolves

00:05:56,560 --> 00:06:00,319
any imports in the code

00:05:58,639 --> 00:06:02,160
so if you are bringing in an external

00:06:00,319 --> 00:06:03,120
crate or using internal crates or

00:06:02,160 --> 00:06:07,840
modules

00:06:03,120 --> 00:06:07,840
those will be resolved here as well

00:06:08,080 --> 00:06:11,360
after these steps the compiler takes

00:06:10,080 --> 00:06:14,800
that ast

00:06:11,360 --> 00:06:15,759
that abstract syntax tree and converts

00:06:14,800 --> 00:06:18,160
that ast

00:06:15,759 --> 00:06:19,360
into higher level intermediate

00:06:18,160 --> 00:06:23,120
representation

00:06:19,360 --> 00:06:24,880
or h-i-r let's pause here and take a

00:06:23,120 --> 00:06:27,520
closer look

00:06:24,880 --> 00:06:30,000
at that h-i-r it helps to understand the

00:06:27,520 --> 00:06:32,560
data structures that make it up

00:06:30,000 --> 00:06:34,319
the first data structure is a node this

00:06:32,560 --> 00:06:37,600
corresponds to a specific

00:06:34,319 --> 00:06:38,880
piece of code this is identified by an

00:06:37,600 --> 00:06:42,960
hr

00:06:38,880 --> 00:06:45,440
this is identified by an h-i-r-i-d

00:06:42,960 --> 00:06:47,039
and that node belongs to a definition a

00:06:45,440 --> 00:06:48,240
definition is an item in the crate we

00:06:47,039 --> 00:06:50,479
are compiling

00:06:48,240 --> 00:06:51,599
these are primarily top level items

00:06:50,479 --> 00:06:55,520
within the crate

00:06:51,599 --> 00:06:58,000
this is identified by a deaf id

00:06:55,520 --> 00:07:00,560
and a definition is owned by a crate

00:06:58,000 --> 00:07:03,039
this is the crate we are compiling with

00:07:00,560 --> 00:07:04,800
with rust it stores the contents of the

00:07:03,039 --> 00:07:05,440
crate we are compiling and creates a

00:07:04,800 --> 00:07:07,520
number of

00:07:05,440 --> 00:07:09,199
maps and other things that help organize

00:07:07,520 --> 00:07:10,800
the content for easier

00:07:09,199 --> 00:07:13,440
access throughout the compilation

00:07:10,800 --> 00:07:16,160
process this crate is identified with a

00:07:13,440 --> 00:07:18,160
great number

00:07:16,160 --> 00:07:19,360
this is the original rust source code we

00:07:18,160 --> 00:07:22,639
are compiling and

00:07:19,360 --> 00:07:24,800
let's take a focus on this section here

00:07:22,639 --> 00:07:26,479
the for loop that iterates through the

00:07:24,800 --> 00:07:30,000
numbers vector

00:07:26,479 --> 00:07:33,120
remember this for loop d sugars into

00:07:30,000 --> 00:07:35,360
a match statement and a loop if we look

00:07:33,120 --> 00:07:36,880
at the node in the hir that represents

00:07:35,360 --> 00:07:39,360
this match statement

00:07:36,880 --> 00:07:41,440
we would see something similar to this

00:07:39,360 --> 00:07:44,560
it's a little hard to read for humans so

00:07:41,440 --> 00:07:47,199
let's go ahead and break it down

00:07:44,560 --> 00:07:49,199
this arm structure represents a single

00:07:47,199 --> 00:07:49,680
arm of the match statement that our for

00:07:49,199 --> 00:07:54,639
loop d

00:07:49,680 --> 00:07:55,919
sugars into and first we have the hir id

00:07:54,639 --> 00:08:00,000
for this piece of code

00:07:55,919 --> 00:08:02,400
this identifies a node within the hir

00:08:00,000 --> 00:08:03,759
and that node is owned by a definition

00:08:02,400 --> 00:08:06,560
the definition is some

00:08:03,759 --> 00:08:08,800
top level item in the crate and that

00:08:06,560 --> 00:08:12,080
definition data structure

00:08:08,800 --> 00:08:14,560
is owned by a crate data structure

00:08:12,080 --> 00:08:15,440
so our for loop is a node within a

00:08:14,560 --> 00:08:18,080
definition

00:08:15,440 --> 00:08:18,800
within our crate that's how we can

00:08:18,080 --> 00:08:20,720
identify

00:08:18,800 --> 00:08:22,240
where this node corresponds to our

00:08:20,720 --> 00:08:25,360
original code

00:08:22,240 --> 00:08:29,759
what this also helps us do

00:08:25,360 --> 00:08:32,320
is we use something called a span

00:08:29,759 --> 00:08:34,159
this span stores the file path line

00:08:32,320 --> 00:08:35,839
numbers and column numbers of the

00:08:34,159 --> 00:08:37,039
original source code

00:08:35,839 --> 00:08:39,440
this will be very important in the

00:08:37,039 --> 00:08:40,719
future as we optimize and de-sugar the

00:08:39,440 --> 00:08:42,560
rust code

00:08:40,719 --> 00:08:44,640
if we encounter a problem with the code

00:08:42,560 --> 00:08:46,399
after it is de-sugared and optimized

00:08:44,640 --> 00:08:48,880
we still want to be able to show the

00:08:46,399 --> 00:08:50,640
user where in their original source code

00:08:48,880 --> 00:08:52,560
that the error was generated

00:08:50,640 --> 00:08:54,000
if we were to show them the d-sugar code

00:08:52,560 --> 00:08:57,839
which is different from the code they

00:08:54,000 --> 00:08:57,839
wrote it wouldn't mean much to them

00:08:58,080 --> 00:09:04,880
the compiler then takes the hir

00:09:01,519 --> 00:09:06,399
and lowers it into the mid-level

00:09:04,880 --> 00:09:10,560
intermediate representation

00:09:06,399 --> 00:09:13,360
also known as the mir

00:09:10,560 --> 00:09:14,560
the mir is constructed as a control

00:09:13,360 --> 00:09:17,200
graph

00:09:14,560 --> 00:09:19,040
the units within this graph are called

00:09:17,200 --> 00:09:22,080
basic blocks which are identified with

00:09:19,040 --> 00:09:25,440
values like bb0 and bb1

00:09:22,080 --> 00:09:27,279
within these blocks each has a sequence

00:09:25,440 --> 00:09:29,920
of statements that execute in an

00:09:27,279 --> 00:09:31,360
order the very last statement is known

00:09:29,920 --> 00:09:33,519
as a terminator

00:09:31,360 --> 00:09:35,680
this controls when and how the program

00:09:33,519 --> 00:09:37,600
proceeds to another basic block

00:09:35,680 --> 00:09:39,519
this is a pretty simple example there's

00:09:37,600 --> 00:09:41,440
only one direction the basic blocks can

00:09:39,519 --> 00:09:46,080
go

00:09:41,440 --> 00:09:46,080
but if our code had an if else statement

00:09:46,160 --> 00:09:50,480
then the terminator a bb0 would have the

00:09:48,560 --> 00:09:53,680
option to either proceed to bb1

00:09:50,480 --> 00:09:55,440
or to bb2 in this case there is more

00:09:53,680 --> 00:10:00,000
than one path that the program can take

00:09:55,440 --> 00:10:00,000
when it encounters the terminator in bb0

00:10:00,240 --> 00:10:04,160
and there are definitely more data

00:10:01,839 --> 00:10:05,760
structures involved in the mir if you're

00:10:04,160 --> 00:10:07,680
curious about them

00:10:05,760 --> 00:10:09,839
definitely check out that guide to rusty

00:10:07,680 --> 00:10:11,839
development again it's a great resource

00:10:09,839 --> 00:10:14,800
for learning how the rust compiler works

00:10:11,839 --> 00:10:14,800
underneath the surface

00:10:15,120 --> 00:10:18,959
let's go back to our d sugar code and

00:10:18,000 --> 00:10:21,279
let's

00:10:18,959 --> 00:10:24,240
focus on this match statement which is

00:10:21,279 --> 00:10:26,320
assigned to a variable called result

00:10:24,240 --> 00:10:27,279
if we looked at the mir for this piece

00:10:26,320 --> 00:10:29,519
of code

00:10:27,279 --> 00:10:31,279
it would look similar to this i've

00:10:29,519 --> 00:10:33,680
simplified it for the sake of appearing

00:10:31,279 --> 00:10:35,360
on a slide

00:10:33,680 --> 00:10:39,279
up here on the top left we have our

00:10:35,360 --> 00:10:42,160
basic block identified here as bb2

00:10:39,279 --> 00:10:44,959
and then we have what is called a local

00:10:42,160 --> 00:10:45,600
a local in the mir represents a place in

00:10:44,959 --> 00:10:48,000
memory

00:10:45,600 --> 00:10:49,839
or more specifically a place on the

00:10:48,000 --> 00:10:52,000
stack frame

00:10:49,839 --> 00:10:55,839
in this case underscore 5 corresponds to

00:10:52,000 --> 00:10:58,160
the value of the variable result

00:10:55,839 --> 00:10:59,040
and like in the nodes in the hir we have

00:10:58,160 --> 00:11:00,560
a span

00:10:59,040 --> 00:11:02,399
the piece of the original rust source

00:11:00,560 --> 00:11:03,920
code that each node in the mir

00:11:02,399 --> 00:11:05,519
corresponds to

00:11:03,920 --> 00:11:07,200
again if we encounter an error when

00:11:05,519 --> 00:11:09,680
we're operating with the mir

00:11:07,200 --> 00:11:12,839
we can still easily refer to what lines

00:11:09,680 --> 00:11:14,240
in the original source code cause the

00:11:12,839 --> 00:11:16,480
error

00:11:14,240 --> 00:11:19,120
and that brings us to this third stage

00:11:16,480 --> 00:11:22,240
and this is big in the rust compiler

00:11:19,120 --> 00:11:23,760
semantic analysis

00:11:22,240 --> 00:11:25,360
this is where the compiler tries to

00:11:23,760 --> 00:11:26,240
figure out what the programmer is trying

00:11:25,360 --> 00:11:28,640
to do

00:11:26,240 --> 00:11:30,880
in a way the compiler can understand it

00:11:28,640 --> 00:11:33,920
and then translate it into machine

00:11:30,880 --> 00:11:36,480
code and at this point

00:11:33,920 --> 00:11:38,160
after it's lowered the hir into the mir

00:11:36,480 --> 00:11:40,720
the compiler will run several checks

00:11:38,160 --> 00:11:42,640
including the borrow checker

00:11:40,720 --> 00:11:44,800
and we'll come back and dive deep into

00:11:42,640 --> 00:11:47,839
the borrow checker in just a few minutes

00:11:44,800 --> 00:11:48,240
but for now let's focus on these last

00:11:47,839 --> 00:11:51,360
two

00:11:48,240 --> 00:11:55,519
stages of compilation optimization

00:11:51,360 --> 00:11:57,360
and code generation these stages

00:11:55,519 --> 00:11:59,680
are where the code is transformed into

00:11:57,360 --> 00:12:02,160
an executable binary

00:11:59,680 --> 00:12:04,240
and the rust compiler we use llvm to do

00:12:02,160 --> 00:12:06,880
this for us

00:12:04,240 --> 00:12:09,200
llvm is a commonly used collection of

00:12:06,880 --> 00:12:11,040
modular and reusable compiler and

00:12:09,200 --> 00:12:12,800
toolchain technologies

00:12:11,040 --> 00:12:14,800
the rest compiler uses it to further

00:12:12,800 --> 00:12:18,320
optimize the code and generate the

00:12:14,800 --> 00:12:18,320
machine code to run it

00:12:18,480 --> 00:12:24,720
before it uses llvm the rust compiler

00:12:22,079 --> 00:12:25,920
takes the mir we created earlier and

00:12:24,720 --> 00:12:28,079
lowers it

00:12:25,920 --> 00:12:29,120
into the llvm intermediate

00:12:28,079 --> 00:12:32,639
representation

00:12:29,120 --> 00:12:35,120
or llvmir

00:12:32,639 --> 00:12:37,120
and the llvm ir honestly is pretty

00:12:35,120 --> 00:12:39,839
unreadable to humans but it looks

00:12:37,120 --> 00:12:39,839
something like this

00:12:40,000 --> 00:12:46,160
as you can see it's organized into basic

00:12:42,560 --> 00:12:46,160
blocks like the mir

00:12:46,959 --> 00:12:54,639
we then use llvm and pass it the llvmir

00:12:51,680 --> 00:12:56,240
and then it runs more optimizations on

00:12:54,639 --> 00:12:59,839
it and emits machine

00:12:56,240 --> 00:13:01,920
code it then links the machine code

00:12:59,839 --> 00:13:04,399
files together to produce the final

00:13:01,920 --> 00:13:07,519
binary

00:13:04,399 --> 00:13:10,959
and that's why when we call cargo run

00:13:07,519 --> 00:13:12,959
we see all those numbers printed out

00:13:10,959 --> 00:13:15,120
so yay that gives you a bit of an idea

00:13:12,959 --> 00:13:16,160
of how the compiler works to take your

00:13:15,120 --> 00:13:17,839
rust source code

00:13:16,160 --> 00:13:19,519
and make it into something a computer

00:13:17,839 --> 00:13:22,800
can execute

00:13:19,519 --> 00:13:24,639
and at this point i do want to go back

00:13:22,800 --> 00:13:26,240
and take a deeper look at that borrow

00:13:24,639 --> 00:13:29,680
checker because this is really where the

00:13:26,240 --> 00:13:29,680
magic of rust happens

00:13:30,399 --> 00:13:34,320
and in order to do that let's use a

00:13:32,079 --> 00:13:36,079
different piece of code

00:13:34,320 --> 00:13:37,200
if you have some experience with rust

00:13:36,079 --> 00:13:38,720
and you're looking at this code and

00:13:37,200 --> 00:13:41,360
thinking it will error out

00:13:38,720 --> 00:13:43,199
you are right we'll see how and why that

00:13:41,360 --> 00:13:44,959
happens in just a moment

00:13:43,199 --> 00:13:46,320
first let's go through this code line by

00:13:44,959 --> 00:13:48,240
line

00:13:46,320 --> 00:13:50,639
we declare the variable x and give it

00:13:48,240 --> 00:13:52,560
the type string

00:13:50,639 --> 00:13:56,800
and then we set the value of x in the

00:13:52,560 --> 00:13:59,279
string to high cloud native rest day

00:13:56,800 --> 00:14:00,839
then we say that the variable y's value

00:13:59,279 --> 00:14:03,760
is equal to the value of

00:14:00,839 --> 00:14:05,680
x and then we attempt to print both

00:14:03,760 --> 00:14:07,920
variables

00:14:05,680 --> 00:14:10,000
if we tried to build this code with

00:14:07,920 --> 00:14:12,720
cargo build

00:14:10,000 --> 00:14:15,440
we would get an error and this error is

00:14:12,720 --> 00:14:17,199
a result of the borrow checker

00:14:15,440 --> 00:14:20,000
let's go through how the borrow checker

00:14:17,199 --> 00:14:22,160
identified this error

00:14:20,000 --> 00:14:24,240
the borrow checker does several things

00:14:22,160 --> 00:14:25,440
including tracking initializations and

00:14:24,240 --> 00:14:27,920
moves

00:14:25,440 --> 00:14:29,519
how this plays out in our code is when

00:14:27,920 --> 00:14:31,519
we start with this first line where we

00:14:29,519 --> 00:14:33,279
declare the variable x with the type of

00:14:31,519 --> 00:14:35,760
string

00:14:33,279 --> 00:14:36,480
x is not actually initialized at this

00:14:35,760 --> 00:14:38,800
point

00:14:36,480 --> 00:14:41,680
it won't be considered initialized until

00:14:38,800 --> 00:14:43,600
it is assigned a value

00:14:41,680 --> 00:14:44,880
if we look at the mir for this line of

00:14:43,600 --> 00:14:47,680
code we see that

00:14:44,880 --> 00:14:49,920
x is represented by the local underscore

00:14:47,680 --> 00:14:52,399
00:14:49,920 --> 00:14:55,360
and local underscore 1 is assigned the

00:14:52,399 --> 00:14:55,360
type of string

00:14:56,639 --> 00:15:00,320
now let's look at this line of code

00:14:58,399 --> 00:15:03,680
where we create and assign the high

00:15:00,320 --> 00:15:06,639
cloud native rust a string

00:15:03,680 --> 00:15:10,240
now that x has a value it is considered

00:15:06,639 --> 00:15:10,240
initialized at this point

00:15:10,800 --> 00:15:13,920
if we look at the mir we create a new

00:15:13,120 --> 00:15:16,399
place in memory

00:15:13,920 --> 00:15:19,279
local underscore 2 where we store the

00:15:16,399 --> 00:15:22,240
high cloud native rest day string

00:15:19,279 --> 00:15:23,279
then we move the value stored at

00:15:22,240 --> 00:15:26,800
underscore 2

00:15:23,279 --> 00:15:29,600
to underscore 1. remember underscore one

00:15:26,800 --> 00:15:31,680
corresponds to the x variable

00:15:29,600 --> 00:15:33,600
so we have created the string in memory

00:15:31,680 --> 00:15:36,959
and moved it to be the value of

00:15:33,600 --> 00:15:38,720
x now let's look at this line

00:15:36,959 --> 00:15:42,720
where we attempt to create the variable

00:15:38,720 --> 00:15:44,880
y and assign it to the value of x

00:15:42,720 --> 00:15:46,320
this line is where the value of x is

00:15:44,880 --> 00:15:48,240
moved to y

00:15:46,320 --> 00:15:49,600
if we look at the mir created for this

00:15:48,240 --> 00:15:52,000
line of code

00:15:49,600 --> 00:15:54,079
we'll see that y is assigned to the

00:15:52,000 --> 00:15:56,720
local underscore 3.

00:15:54,079 --> 00:15:58,959
remember a local represents a place in

00:15:56,720 --> 00:16:01,680
memory

00:15:58,959 --> 00:16:04,160
and underscore 3 is given the type

00:16:01,680 --> 00:16:04,160
string

00:16:04,720 --> 00:16:08,480
and then the value at underscore 1

00:16:06,720 --> 00:16:10,560
remember that represents x

00:16:08,480 --> 00:16:13,839
is moved to the value of underscore

00:16:10,560 --> 00:16:23,839
three which represents y

00:16:13,839 --> 00:16:23,839
this means when we get to here

00:16:24,160 --> 00:16:27,759
this means when we get to here when we

00:16:25,839 --> 00:16:30,800
try to print x

00:16:27,759 --> 00:16:32,639
x is not initialized at this line so we

00:16:30,800 --> 00:16:34,480
cannot print it

00:16:32,639 --> 00:16:37,839
and that's what generates this

00:16:34,480 --> 00:16:37,839
particular error

00:16:38,160 --> 00:16:42,880
we're attempting to use a value of a

00:16:40,160 --> 00:16:45,040
variable after it has been moved

00:16:42,880 --> 00:16:47,279
and the rust compiler says you cannot do

00:16:45,040 --> 00:16:47,279
that

00:16:47,519 --> 00:16:51,279
something i'd like to specifically call

00:16:49,279 --> 00:16:53,120
out is how the compiler shows

00:16:51,279 --> 00:16:54,800
where the error was generated from in

00:16:53,120 --> 00:16:57,279
the original source code

00:16:54,800 --> 00:16:58,720
through a span even though we had

00:16:57,279 --> 00:17:01,040
lowered this code to mir

00:16:58,720 --> 00:17:03,199
or mid-level representation we still

00:17:01,040 --> 00:17:05,120
tracked what items in the mir

00:17:03,199 --> 00:17:07,039
correspond to what places in the

00:17:05,120 --> 00:17:09,520
original rus code

00:17:07,039 --> 00:17:11,760
this is very helpful to the end user

00:17:09,520 --> 00:17:14,720
what is also helpful

00:17:11,760 --> 00:17:16,559
is this remember the rust compiler not

00:17:14,720 --> 00:17:17,760
only tells you what the error is and

00:17:16,559 --> 00:17:20,079
where it is

00:17:17,760 --> 00:17:22,000
it gives you a command to get even more

00:17:20,079 --> 00:17:24,079
information about the error so that you

00:17:22,000 --> 00:17:26,480
can fix it

00:17:24,079 --> 00:17:28,079
if we run this command we see not only

00:17:26,480 --> 00:17:30,400
an explanation of the error

00:17:28,079 --> 00:17:32,240
but also a piece of example code that

00:17:30,400 --> 00:17:35,280
would generate it

00:17:32,240 --> 00:17:37,360
then the message gives you even more

00:17:35,280 --> 00:17:39,200
information about how to fix it

00:17:37,360 --> 00:17:40,480
this suggests using a reference to

00:17:39,200 --> 00:17:42,640
borrow a value

00:17:40,480 --> 00:17:44,720
rather than attempting to move the value

00:17:42,640 --> 00:17:46,880
which is what we saw done in the mir

00:17:44,720 --> 00:17:50,320
representation of our code

00:17:46,880 --> 00:17:53,200
so let's do this and change this line

00:17:50,320 --> 00:17:54,880
so that y is assigned to a reference to

00:17:53,200 --> 00:17:59,520
the value of x

00:17:54,880 --> 00:18:01,440
rather than moving the value of x into y

00:17:59,520 --> 00:18:03,440
after we've made this change if we run

00:18:01,440 --> 00:18:05,360
our code again using cargo run

00:18:03,440 --> 00:18:06,480
the compiler will build the code and

00:18:05,360 --> 00:18:08,720
execute it

00:18:06,480 --> 00:18:11,360
and we see the message hi cloud native

00:18:08,720 --> 00:18:13,440
rest day printed out twice

00:18:11,360 --> 00:18:15,280
rather than finding the borrow checker

00:18:13,440 --> 00:18:18,000
we used it to make our code

00:18:15,280 --> 00:18:18,000
even better

00:18:19,200 --> 00:18:24,080
along with tracking initializations and

00:18:21,120 --> 00:18:26,720
moves the borrow checker also deals with

00:18:24,080 --> 00:18:29,200
lifetime inference and let's go over

00:18:26,720 --> 00:18:31,440
what this means

00:18:29,200 --> 00:18:33,200
rust uses the word lifetime in two

00:18:31,440 --> 00:18:35,440
distinct ways

00:18:33,200 --> 00:18:36,559
the first is to refer to the lifetime of

00:18:35,440 --> 00:18:38,720
a value

00:18:36,559 --> 00:18:40,080
that's the span of time before the value

00:18:38,720 --> 00:18:42,080
gets freed

00:18:40,080 --> 00:18:43,679
another word for referring to the

00:18:42,080 --> 00:18:45,039
lifetime of a value is referring to the

00:18:43,679 --> 00:18:48,160
variable scope

00:18:45,039 --> 00:18:49,919
let's see how this plays out in our code

00:18:48,160 --> 00:18:51,600
and let's start with this first line

00:18:49,919 --> 00:18:54,799
where we assign the value of

00:18:51,600 --> 00:18:59,520
x as this string at this point

00:18:54,799 --> 00:19:02,000
x is live its lifetime begins here

00:18:59,520 --> 00:19:02,559
when we get to here and move the value

00:19:02,000 --> 00:19:08,080
of x

00:19:02,559 --> 00:19:10,000
into y this is the end of x's lifetime

00:19:08,080 --> 00:19:11,600
when we get down here and try to use x

00:19:10,000 --> 00:19:13,520
again x is dead

00:19:11,600 --> 00:19:15,520
its lifetime is no longer an effect

00:19:13,520 --> 00:19:19,200
which is why this program as it's

00:19:15,520 --> 00:19:19,200
written now will error out

00:19:19,919 --> 00:19:24,400
the other way rust uses the term

00:19:21,760 --> 00:19:26,640
lifetime is to refer to the lifetime of

00:19:24,400 --> 00:19:28,640
a reference to a value

00:19:26,640 --> 00:19:31,520
this is the span of code in which the

00:19:28,640 --> 00:19:33,600
reference can be used

00:19:31,520 --> 00:19:35,360
let's take a look at our corrected code

00:19:33,600 --> 00:19:38,880
where we assign the value of y

00:19:35,360 --> 00:19:40,960
to be a reference to the value of x

00:19:38,880 --> 00:19:42,480
if we look at the mir for this line of

00:19:40,960 --> 00:19:44,720
code

00:19:42,480 --> 00:19:46,559
we remember that the local underscore 1

00:19:44,720 --> 00:19:49,919
refers to x

00:19:46,559 --> 00:19:52,400
and the local underscore 3 refers to y

00:19:49,919 --> 00:19:54,720
and we see that underscore three that

00:19:52,400 --> 00:19:58,400
underscore three local is assigned

00:19:54,720 --> 00:20:00,720
a reference to the value of underscore

00:19:58,400 --> 00:20:00,720
one

00:20:02,320 --> 00:20:06,559
looking back at our code let's alter

00:20:04,240 --> 00:20:08,559
this slightly

00:20:06,559 --> 00:20:09,600
and try to drop the value of the

00:20:08,559 --> 00:20:12,000
variable x

00:20:09,600 --> 00:20:13,679
before we try to print out the value of

00:20:12,000 --> 00:20:16,559
y

00:20:13,679 --> 00:20:19,200
after we make this change and try to

00:20:16,559 --> 00:20:22,720
build this code using cargo build

00:20:19,200 --> 00:20:23,760
we get an error we can't drop x because

00:20:22,720 --> 00:20:26,799
it is borrowed

00:20:23,760 --> 00:20:28,720
and that borrow is used later

00:20:26,799 --> 00:20:29,919
the borrow checker tells us that x

00:20:28,720 --> 00:20:33,039
because it is

00:20:29,919 --> 00:20:33,760
referenced by y needs to stay alive for

00:20:33,039 --> 00:20:36,960
at least

00:20:33,760 --> 00:20:39,280
as long as y needs to stay alive

00:20:36,960 --> 00:20:41,200
x's lifetime must be greater than or

00:20:39,280 --> 00:20:43,440
equal to y's

00:20:41,200 --> 00:20:45,440
looking at this line in the code or

00:20:43,440 --> 00:20:49,039
looking at these lifetimes in the code

00:20:45,440 --> 00:20:50,640
again this is x's lifetime

00:20:49,039 --> 00:20:54,240
and this is what needs to be the

00:20:50,640 --> 00:20:57,280
lifetime of y which is a reference to x

00:20:54,240 --> 00:20:57,840
notice that even though they overlap x's

00:20:57,280 --> 00:21:00,840
lifetime

00:20:57,840 --> 00:21:02,960
ends before y's lifetime is supposed to

00:21:00,840 --> 00:21:05,520
end

00:21:02,960 --> 00:21:07,440
y can no longer reference the value of x

00:21:05,520 --> 00:21:09,760
after this line

00:21:07,440 --> 00:21:11,039
and at this point y along with x would

00:21:09,760 --> 00:21:13,039
be dead

00:21:11,039 --> 00:21:14,240
in order for this code to compile the

00:21:13,039 --> 00:21:17,280
lifetime of y

00:21:14,240 --> 00:21:20,400
x must last at least as long as the

00:21:17,280 --> 00:21:20,400
lifetime of y

00:21:21,200 --> 00:21:25,600
the overarching way the scope and the

00:21:23,919 --> 00:21:26,159
lifetime of a reference relate to each

00:21:25,600 --> 00:21:27,679
other

00:21:26,159 --> 00:21:30,080
is that if you make a reference to a

00:21:27,679 --> 00:21:34,559
value the lifetime of that reference

00:21:30,080 --> 00:21:34,559
cannot outlive the scope of the value

00:21:35,360 --> 00:21:38,720
as i move toward concluding this

00:21:36,640 --> 00:21:40,480
presentation i want to make sure that

00:21:38,720 --> 00:21:43,200
you know there is so much more to the

00:21:40,480 --> 00:21:45,919
rust compiler and the borrow checker

00:21:43,200 --> 00:21:47,760
again please if you want to know more

00:21:45,919 --> 00:21:51,360
check out the guide to rusty development

00:21:47,760 --> 00:21:51,360
it's a fantastic resource

00:21:51,760 --> 00:21:55,600
going back to this question from the

00:21:53,039 --> 00:21:59,360
beginning is the borrow checker a friend

00:21:55,600 --> 00:22:02,960
or a foe i say it's a friend

00:21:59,360 --> 00:22:03,760
though a very strict one but the best

00:22:02,960 --> 00:22:06,080
thing about this

00:22:03,760 --> 00:22:08,159
friend is it will not only tell you when

00:22:06,080 --> 00:22:11,120
something is wrong

00:22:08,159 --> 00:22:12,000
it will also tell you how to fix it and

00:22:11,120 --> 00:22:13,520
i find that to be one

00:22:12,000 --> 00:22:15,520
of the best qualities i can find in a

00:22:13,520 --> 00:22:19,840
friend as well as one of the best

00:22:15,520 --> 00:22:19,840
qualities i can find in a compiler

00:22:20,080 --> 00:22:24,320

YouTube URL: https://www.youtube.com/watch?v=HG1fppexRMA


