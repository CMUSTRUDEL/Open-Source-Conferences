Title: Keyhouse: Production-ready Key Management Service in Rust - Maxwell Bruce & Sergey Shekyan
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Keyhouse: Production-ready Key Management Service in Rust - Maxwell Bruce & Sergey Shekyan, ByteDance

In this talk, Max and Sergey from ByteDance security team will share their experience of building a production-ready key management system using Rust. It uses Spire to establish mutual trust with the customers and other components, which adds up to the already unique combination of being the only OSS production-ready KMS written in Rust. The system is nearly self-contained, with the exception of the storage system, which is ETCD at the moment. Compared to go its predecessor which is written in Go, keyhouse uses much less memory and CPU cores to secure a large amount of user data. Keyhouse will be open sourced on Github very soon.

Acknowledgment:
We thank Yu Ding as a 3rd author. He will not be a presenter but he contributed significantly to keyhouse.

Yu Ding is a security researcher and engineer. His research interest is security issues around Intel SGX and building security-critical systems. He is a zealot of security oriented software development and dedicated to build a memory safe world.
Captions: 
	00:00:00,000 --> 00:00:03,679
hi everyone um we will be talking

00:00:02,000 --> 00:00:06,319
talking about key house a key management

00:00:03,679 --> 00:00:09,200
system that's ready for production

00:00:06,319 --> 00:00:09,200
and um

00:00:09,840 --> 00:00:14,480
we work for a company called by dance it

00:00:12,400 --> 00:00:16,240
was founded 90 roughly nine years ago we

00:00:14,480 --> 00:00:20,720
have a lot of products

00:00:16,240 --> 00:00:20,720
most famous one is tick tock

00:00:21,039 --> 00:00:27,599
and a couple of words about ourselves

00:00:24,080 --> 00:00:29,199
so building

00:00:27,599 --> 00:00:31,119
leads trusted computing can secure

00:00:29,199 --> 00:00:33,520
coding initiatives at by dance

00:00:31,119 --> 00:00:35,280
and his big supporter of rust he is

00:00:33,520 --> 00:00:37,120
maintaining apache t clave

00:00:35,280 --> 00:00:38,719
which is an open source uh universal

00:00:37,120 --> 00:00:40,320
secure computing platform

00:00:38,719 --> 00:00:43,040
and before that he worked at baidu on

00:00:40,320 --> 00:00:46,239
similar problems

00:00:43,040 --> 00:00:46,800
max who is with us today is a very quick

00:00:46,239 --> 00:00:51,120
learner

00:00:46,800 --> 00:00:53,120
and he is the primary developer on

00:00:51,120 --> 00:00:54,160
key house so without him this project

00:00:53,120 --> 00:00:55,760
wouldn't exist

00:00:54,160 --> 00:00:58,000
he brings his rust skills and like in

00:00:55,760 --> 00:00:59,840
general computer science skills and

00:00:58,000 --> 00:01:02,000
security skills to the table

00:00:59,840 --> 00:01:04,000
and previously max worked on some

00:01:02,000 --> 00:01:07,360
anti-automation problems

00:01:04,000 --> 00:01:08,799
and me sergey i work on primarily work

00:01:07,360 --> 00:01:12,320
on like web security problems

00:01:08,799 --> 00:01:15,680
and which includes anti-automation and

00:01:12,320 --> 00:01:19,280
some browser security apis and so on

00:01:15,680 --> 00:01:22,000
so none of us had a prior key management

00:01:19,280 --> 00:01:23,600
system uh development experience so

00:01:22,000 --> 00:01:27,360
that's kind of

00:01:23,600 --> 00:01:27,360
more interesting

00:01:28,479 --> 00:01:34,400
so what is key house

00:01:31,600 --> 00:01:37,360
it's an open source project well soon to

00:01:34,400 --> 00:01:40,960
be open source project

00:01:37,360 --> 00:01:42,799
completely written in rust and um

00:01:40,960 --> 00:01:44,880
at by then security and privacy are top

00:01:42,799 --> 00:01:47,759
concerns and

00:01:44,880 --> 00:01:48,159
uh just a few words how we started doing

00:01:47,759 --> 00:01:50,079
this

00:01:48,159 --> 00:01:52,799
is that there was an existing key

00:01:50,079 --> 00:01:55,600
management system that we were

00:01:52,799 --> 00:01:56,240
integrating started integrating with zti

00:01:55,600 --> 00:01:59,119
with the

00:01:56,240 --> 00:02:01,119
with our new authentication uh mechanism

00:01:59,119 --> 00:02:04,560
in our in our company cloud

00:02:01,119 --> 00:02:09,440
and while looking at the code

00:02:04,560 --> 00:02:12,400
several refactoring initiatives came to

00:02:09,440 --> 00:02:15,280
our attention and at some point critical

00:02:12,400 --> 00:02:17,380
mass of changes was so big that

00:02:15,280 --> 00:02:19,120
was so massive that um

00:02:17,380 --> 00:02:20,959
[Music]

00:02:19,120 --> 00:02:23,440
we decided to rewrite everything from

00:02:20,959 --> 00:02:26,560
scratch and

00:02:23,440 --> 00:02:29,440
while there was no massive

00:02:26,560 --> 00:02:30,560
trust projects in the company we were

00:02:29,440 --> 00:02:33,120
allowed to

00:02:30,560 --> 00:02:33,599
management allowed us to experiment with

00:02:33,120 --> 00:02:36,480
rust

00:02:33,599 --> 00:02:38,800
for a bit and maybe rewrite some some

00:02:36,480 --> 00:02:40,879
small components in rust and see

00:02:38,800 --> 00:02:42,160
if uh performance benefits or any other

00:02:40,879 --> 00:02:45,599
benefits overweight

00:02:42,160 --> 00:02:48,959
uh steep learning curve and like we can

00:02:45,599 --> 00:02:51,840
we can benefit from it and

00:02:48,959 --> 00:02:53,840
yeah it was it went so good that um

00:02:51,840 --> 00:02:56,400
within a couple of weeks

00:02:53,840 --> 00:02:57,680
we wrote a minimum minimum viable

00:02:56,400 --> 00:02:59,840
product and

00:02:57,680 --> 00:03:01,840
we were amazed with the performance and

00:02:59,840 --> 00:03:02,800
scalability and like memory safety

00:03:01,840 --> 00:03:05,920
guarantees

00:03:02,800 --> 00:03:06,480
that we were allowed basically or we

00:03:05,920 --> 00:03:08,720
were

00:03:06,480 --> 00:03:10,000
we got a support to implement everything

00:03:08,720 --> 00:03:15,040
from scratch

00:03:10,000 --> 00:03:15,040
100 in rust and

00:03:16,840 --> 00:03:21,280
um

00:03:18,480 --> 00:03:21,760
yeah so our our rust deployment uh you

00:03:21,280 --> 00:03:23,440
know

00:03:21,760 --> 00:03:24,959
this project has has since matured at

00:03:23,440 --> 00:03:26,000
bike dance and we're deployed in

00:03:24,959 --> 00:03:29,360
production

00:03:26,000 --> 00:03:30,640
um all across the world now um so

00:03:29,360 --> 00:03:32,480
you know we can say this project has

00:03:30,640 --> 00:03:34,159
internally been a success and

00:03:32,480 --> 00:03:35,440
part of our open source initiative is

00:03:34,159 --> 00:03:37,360
turning this into a success for

00:03:35,440 --> 00:03:40,720
everybody else

00:03:37,360 --> 00:03:43,840
um yeah so thanks sergey for telling us

00:03:40,720 --> 00:03:45,680
uh stuff about why rust um so i'm

00:03:43,840 --> 00:03:48,000
max i'll be going into some of the

00:03:45,680 --> 00:03:49,760
design considerations in key house

00:03:48,000 --> 00:03:51,519
um so starting off here with our core

00:03:49,760 --> 00:03:53,040
components um

00:03:51,519 --> 00:03:54,879
everything in keyhouse is designed

00:03:53,040 --> 00:03:57,040
around kind of like a monolith

00:03:54,879 --> 00:03:58,720
uh kind of end product in that you know

00:03:57,040 --> 00:04:01,120
you ship like just one service

00:03:58,720 --> 00:04:03,280
out that provides key house and then you

00:04:01,120 --> 00:04:03,920
you'd balance that out amongst many pods

00:04:03,280 --> 00:04:05,439
or

00:04:03,920 --> 00:04:07,760
or whatever it would be horizontally

00:04:05,439 --> 00:04:09,840
scaled but just one

00:04:07,760 --> 00:04:12,000
category of service uh the reason being

00:04:09,840 --> 00:04:15,120
is just minimizing chances of failure

00:04:12,000 --> 00:04:16,720
minimizing um any kind of like potential

00:04:15,120 --> 00:04:19,040
dependency problems

00:04:16,720 --> 00:04:21,040
and uh just overall trying to maintain

00:04:19,040 --> 00:04:23,520
as much simplicity as possible

00:04:21,040 --> 00:04:24,400
because as it turns out key management

00:04:23,520 --> 00:04:26,320
systems tend to

00:04:24,400 --> 00:04:28,080
be dependent on by a lot of critical

00:04:26,320 --> 00:04:30,720
services we really really

00:04:28,080 --> 00:04:31,360
need that top reliability and that top

00:04:30,720 --> 00:04:34,000
um

00:04:31,360 --> 00:04:35,280
top like just reliability and redundancy

00:04:34,000 --> 00:04:35,840
so we just don't have any room for

00:04:35,280 --> 00:04:38,560
failure

00:04:35,840 --> 00:04:39,840
so a lot of our design considerations go

00:04:38,560 --> 00:04:42,240
with that in mind

00:04:39,840 --> 00:04:44,000
um and with that in mind as a monolith

00:04:42,240 --> 00:04:44,880
we have uh kind of like two halves to

00:04:44,000 --> 00:04:46,639
our program

00:04:44,880 --> 00:04:48,560
uh so we have our data plane which is

00:04:46,639 --> 00:04:50,720
what our sdks talk to

00:04:48,560 --> 00:04:52,160
um and then we also have our control

00:04:50,720 --> 00:04:54,160
plane which is what like you

00:04:52,160 --> 00:04:55,280
uh or an operator administrator would

00:04:54,160 --> 00:04:57,040
talk to to

00:04:55,280 --> 00:04:59,199
you know create new keys and and do

00:04:57,040 --> 00:05:02,400
other administration operations

00:04:59,199 --> 00:05:04,880
um uh and in general you could say

00:05:02,400 --> 00:05:05,759
are the each component of keyhouse

00:05:04,880 --> 00:05:08,320
design to be

00:05:05,759 --> 00:05:08,880
very easily hot swappable at the build

00:05:08,320 --> 00:05:12,479
phase

00:05:08,880 --> 00:05:14,800
and um we did this kind of with a

00:05:12,479 --> 00:05:16,080
uh a service as a library approach where

00:05:14,800 --> 00:05:18,240
you would import key house

00:05:16,080 --> 00:05:19,759
almost as a library and then fill in

00:05:18,240 --> 00:05:20,880
whatever implementations you need to

00:05:19,759 --> 00:05:21,759
integrate with your own corporate

00:05:20,880 --> 00:05:24,160
infrastructure

00:05:21,759 --> 00:05:25,919
the idea being okay you know as bike

00:05:24,160 --> 00:05:27,280
dance if this was somebody else's open

00:05:25,919 --> 00:05:28,880
source project and we have all the

00:05:27,280 --> 00:05:29,919
specific infrastructure requirements we

00:05:28,880 --> 00:05:31,919
need to fulfill

00:05:29,919 --> 00:05:34,080
how can we get this open source project

00:05:31,919 --> 00:05:35,440
to mesh with our own internal systems

00:05:34,080 --> 00:05:36,880
um and so we tried to make it an

00:05:35,440 --> 00:05:38,479
approach so that we could both answer

00:05:36,880 --> 00:05:40,320
that question for us but also answer

00:05:38,479 --> 00:05:42,800
that question for everybody else

00:05:40,320 --> 00:05:44,080
um and so that's why we landed this kind

00:05:42,800 --> 00:05:46,240
of hot swappable

00:05:44,080 --> 00:05:48,479
uh system so for example like control

00:05:46,240 --> 00:05:51,199
plane authorization can be defined

00:05:48,479 --> 00:05:52,560
um by any system like some kind of sso

00:05:51,199 --> 00:05:54,800
internal to a company

00:05:52,560 --> 00:05:57,039
uh just standard jbt tokens directly

00:05:54,800 --> 00:06:00,400
through spire spiffy

00:05:57,039 --> 00:06:03,840
uh zero test infrastructure um you know

00:06:00,400 --> 00:06:04,240
anything works uh and on a similar note

00:06:03,840 --> 00:06:07,840
uh

00:06:04,240 --> 00:06:09,520
like exact crypto algorithm support um

00:06:07,840 --> 00:06:11,360
and even like the back end itself like

00:06:09,520 --> 00:06:12,960
we were probably we will primarily be

00:06:11,360 --> 00:06:14,960
talking about ncd here but

00:06:12,960 --> 00:06:16,240
uh you could swap out back ends of other

00:06:14,960 --> 00:06:18,400
needs of rows

00:06:16,240 --> 00:06:20,319
um and this extends to a lot of other

00:06:18,400 --> 00:06:23,440
components of keyhouse as well

00:06:20,319 --> 00:06:24,880
uh speaking of fcd uh etcds are is if

00:06:23,440 --> 00:06:26,319
you're not familiar with it a back-end

00:06:24,880 --> 00:06:27,600
data store and we'll be talking more

00:06:26,319 --> 00:06:30,479
about that shortly

00:06:27,600 --> 00:06:31,199
um but it's ultimately like the the root

00:06:30,479 --> 00:06:35,199
source of all

00:06:31,199 --> 00:06:37,120
uh like back-end storage for t-house

00:06:35,199 --> 00:06:39,440
cd itself doesn't have support for

00:06:37,120 --> 00:06:43,039
spiffy spire zti which is what we use

00:06:39,440 --> 00:06:46,160
for identity and attestation

00:06:43,039 --> 00:06:48,000
and ultimately authorization we wrote

00:06:46,160 --> 00:06:51,440
another project called spire proxy

00:06:48,000 --> 00:06:52,560
that allows us to uh con ls is to

00:06:51,440 --> 00:06:56,000
provide the kind of like a

00:06:52,560 --> 00:06:59,199
a wrapper over at cd in order to

00:06:56,000 --> 00:06:59,680
um uh provide like that that spiffy

00:06:59,199 --> 00:07:01,039
spire

00:06:59,680 --> 00:07:02,720
attestation authorization we'll be

00:07:01,039 --> 00:07:03,919
talking more about spiffy later on in

00:07:02,720 --> 00:07:06,400
the presentation

00:07:03,919 --> 00:07:08,240
um also generally speaking kms uh key

00:07:06,400 --> 00:07:10,400
house we'll also be talking to

00:07:08,240 --> 00:07:11,440
uh nhsm hardware security modules a

00:07:10,400 --> 00:07:13,120
hardware to trust

00:07:11,440 --> 00:07:15,520
we'll also be talking about that more

00:07:13,120 --> 00:07:16,319
later on um so let's talk more about

00:07:15,520 --> 00:07:18,160
etcd

00:07:16,319 --> 00:07:20,160
so etcd as i said before it's our

00:07:18,160 --> 00:07:20,960
primary authoritative uh backend data

00:07:20,160 --> 00:07:23,199
source

00:07:20,960 --> 00:07:24,000
um every keyhouse instance talks that cd

00:07:23,199 --> 00:07:25,440
all the time

00:07:24,000 --> 00:07:26,639
of course we do have failure like

00:07:25,440 --> 00:07:28,000
prevention we have like kind of

00:07:26,639 --> 00:07:29,759
failovers in place and stuff

00:07:28,000 --> 00:07:31,199
uh that's all ultimately up to how you

00:07:29,759 --> 00:07:33,520
want to deploy things

00:07:31,199 --> 00:07:35,919
um we use spiffy ids as a form of

00:07:33,520 --> 00:07:38,560
identity uh between ncd and keyhouse

00:07:35,919 --> 00:07:40,080
uh so we're not relying on like username

00:07:38,560 --> 00:07:41,599
password schemes or anything like that

00:07:40,080 --> 00:07:43,360
um and you can set that up with other

00:07:41,599 --> 00:07:45,039
backend stores as well but

00:07:43,360 --> 00:07:47,599
uh like i said before we'll be focusing

00:07:45,039 --> 00:07:50,560
on ncd um

00:07:47,599 --> 00:07:52,400
and uh in general uh ncd if you're not

00:07:50,560 --> 00:07:54,160
already familiar with it it is a

00:07:52,400 --> 00:07:56,160
it's a very simple key value store with

00:07:54,160 --> 00:07:58,160
its primary selling points being

00:07:56,160 --> 00:07:59,440
high consistency guarantees very

00:07:58,160 --> 00:08:01,039
persistent very reliable

00:07:59,440 --> 00:08:03,120
uh load distribution but it is

00:08:01,039 --> 00:08:06,800
distributed like generally speaking

00:08:03,120 --> 00:08:09,280
you plug like five to seven nodes um

00:08:06,800 --> 00:08:11,440
so uh it's relatively scalable uh for

00:08:09,280 --> 00:08:13,360
what we need and it also

00:08:11,440 --> 00:08:15,360
um you know it's also relatively easy to

00:08:13,360 --> 00:08:17,840
create replicas of both with fcd

00:08:15,360 --> 00:08:20,479
and as we'll be talking about right now

00:08:17,840 --> 00:08:22,080
uh with re-replicas and with caching

00:08:20,479 --> 00:08:23,759
so uh i guess in the last slide i talked

00:08:22,080 --> 00:08:25,599
about a little bit here um we

00:08:23,759 --> 00:08:27,759
do also create read replicas of fcd in

00:08:25,599 --> 00:08:30,000
order to deploy

00:08:27,759 --> 00:08:30,960
with the same cluster data set across

00:08:30,000 --> 00:08:34,080
multiple

00:08:30,960 --> 00:08:35,039
regions around the world um and uh you

00:08:34,080 --> 00:08:36,320
know part of that is

00:08:35,039 --> 00:08:39,279
we have this really interesting kind of

00:08:36,320 --> 00:08:40,959
cache infrastructure in key house where

00:08:39,279 --> 00:08:42,560
each keyhouse instance right so each

00:08:40,959 --> 00:08:44,560
like pod running keyhouse

00:08:42,560 --> 00:08:47,200
effectively becomes a replica of that cd

00:08:44,560 --> 00:08:50,320
in and of itself a read replica that is

00:08:47,200 --> 00:08:51,680
um and you know in uh you know we kind

00:08:50,320 --> 00:08:53,120
of like more theoretical terms this ends

00:08:51,680 --> 00:08:54,640
up being a kind of like a right through

00:08:53,120 --> 00:08:56,720
evictionless cache

00:08:54,640 --> 00:08:58,399
and that due to the the generally low

00:08:56,720 --> 00:09:00,080
size of the entire data set like i think

00:08:58,399 --> 00:09:01,519
our entire production network

00:09:00,080 --> 00:09:03,920
uh you know it doesn't grow above a

00:09:01,519 --> 00:09:05,440
couple megabytes uh for every you know

00:09:03,920 --> 00:09:07,120
encryption key there is because crypt

00:09:05,440 --> 00:09:08,480
keys just aren't that big

00:09:07,120 --> 00:09:10,000
so what we end up doing is we actually

00:09:08,480 --> 00:09:12,000
just cache everything all the time in

00:09:10,000 --> 00:09:15,040
every keyhouse instance which provides

00:09:12,000 --> 00:09:17,120
amazing like failure uh you know like

00:09:15,040 --> 00:09:19,360
you know just handling failures really

00:09:17,120 --> 00:09:20,959
well uh etsy goes down

00:09:19,360 --> 00:09:22,480
key house just keeps trucking like it's

00:09:20,959 --> 00:09:24,320
no big deal um

00:09:22,480 --> 00:09:25,760
of course we deny any rights during that

00:09:24,320 --> 00:09:26,959
time but uh

00:09:25,760 --> 00:09:28,800
and that's why we're right through is to

00:09:26,959 --> 00:09:31,920
deny rights when uh

00:09:28,800 --> 00:09:33,519
that cd can't confirm anything uh and

00:09:31,920 --> 00:09:34,880
in general key house actually relies a

00:09:33,519 --> 00:09:36,000
lot on the kind of consistency

00:09:34,880 --> 00:09:38,080
guarantees that std

00:09:36,000 --> 00:09:39,200
provides in order to synchronize its

00:09:38,080 --> 00:09:42,080
operations

00:09:39,200 --> 00:09:44,320
um and so that's a it's a very useful uh

00:09:42,080 --> 00:09:47,760
you know future provided by fcd

00:09:44,320 --> 00:09:49,440
um and uh yeah this has given us great

00:09:47,760 --> 00:09:50,640
performance gains across the board and

00:09:49,440 --> 00:09:51,839
ultimately if you think about it it

00:09:50,640 --> 00:09:53,360
makes it such that any

00:09:51,839 --> 00:09:54,959
given request that key house has to

00:09:53,360 --> 00:09:55,760
handle does not have any direct network

00:09:54,959 --> 00:09:57,920
dependencies

00:09:55,760 --> 00:09:59,360
which is both at least other than the

00:09:57,920 --> 00:10:02,399
request itself of course

00:09:59,360 --> 00:10:05,519
um and so this results in uh

00:10:02,399 --> 00:10:06,959
just like a really reliable um like

00:10:05,519 --> 00:10:09,040
request serving uh

00:10:06,959 --> 00:10:10,000
latency and in general just high

00:10:09,040 --> 00:10:13,360
reliability of

00:10:10,000 --> 00:10:14,959
serving requests um we talked a little

00:10:13,360 --> 00:10:16,560
bit about it before but

00:10:14,959 --> 00:10:17,760
you know what is spiffy if you're not

00:10:16,560 --> 00:10:19,839
already familiar with it it's a

00:10:17,760 --> 00:10:21,600
attestation and identity framework

00:10:19,839 --> 00:10:23,760
uh it's an open standard open source

00:10:21,600 --> 00:10:27,120
implementations and standard

00:10:23,760 --> 00:10:29,120
um we mostly center around spire at uh

00:10:27,120 --> 00:10:32,640
key house and bike dance um our own

00:10:29,120 --> 00:10:34,800
internal deployment is using spire

00:10:32,640 --> 00:10:36,480
and if you're not already familiar with

00:10:34,800 --> 00:10:38,720
it

00:10:36,480 --> 00:10:40,000
ultimately what the usage of spiffy

00:10:38,720 --> 00:10:42,240
inspire provides

00:10:40,000 --> 00:10:43,279
is some kind of spiffy verifiable

00:10:42,240 --> 00:10:45,839
identity document

00:10:43,279 --> 00:10:47,440
or spin generally in the form of an x

00:10:45,839 --> 00:10:50,560
509 certificate

00:10:47,440 --> 00:10:50,959
uh signed by spire through some form or

00:10:50,560 --> 00:10:54,000
uh

00:10:50,959 --> 00:10:56,240
an es256 jwt uh

00:10:54,000 --> 00:10:58,320
token containing a spiffy id whereas

00:10:56,240 --> 00:10:59,360
spiffy id is just a uri of a specific

00:10:58,320 --> 00:11:01,680
form

00:10:59,360 --> 00:11:02,959
in keyhouse we place a a generalized

00:11:01,680 --> 00:11:05,120
form of this and that

00:11:02,959 --> 00:11:06,720
you have like spiffy uh and then you

00:11:05,120 --> 00:11:08,160
have like a trust domain

00:11:06,720 --> 00:11:10,320
uh and then you have a series of key

00:11:08,160 --> 00:11:10,959
value pairs uh which denotes some

00:11:10,320 --> 00:11:12,399
property

00:11:10,959 --> 00:11:14,560
the intention being that you can use

00:11:12,399 --> 00:11:16,880
wild cards to uh

00:11:14,560 --> 00:11:18,640
be able to more generically refer to

00:11:16,880 --> 00:11:22,399
parts of a spiffy id

00:11:18,640 --> 00:11:23,920
um so yeah how does key house

00:11:22,399 --> 00:11:26,640
specifically use spiffy

00:11:23,920 --> 00:11:28,240
uh so in general everything in keyhouse

00:11:26,640 --> 00:11:31,440
is protected with mutual

00:11:28,240 --> 00:11:31,760
tls and uh you know we're using spiffy

00:11:31,440 --> 00:11:34,000
to

00:11:31,760 --> 00:11:35,040
communicate identity through this use of

00:11:34,000 --> 00:11:37,760
mtls

00:11:35,040 --> 00:11:40,240
so like sdks will confirm the identity

00:11:37,760 --> 00:11:42,079
of the keyhouse server it's talking to

00:11:40,240 --> 00:11:44,320
the server will confirm the identities

00:11:42,079 --> 00:11:46,880
of sdks if applicable

00:11:44,320 --> 00:11:48,079
um and you know on top of that the key

00:11:46,880 --> 00:11:50,639
house will also use

00:11:48,079 --> 00:11:51,200
these identities to authorize resources

00:11:50,639 --> 00:11:53,279
in

00:11:51,200 --> 00:11:54,399
uh you know we'll talk more about the

00:11:53,279 --> 00:11:56,320
specific groups as being authorized

00:11:54,399 --> 00:11:59,360
later but the customer key is

00:11:56,320 --> 00:12:00,639
uh that uh a given request that the data

00:11:59,360 --> 00:12:02,720
plane is accessing

00:12:00,639 --> 00:12:04,720
uh gets authorized to these spiffy idea

00:12:02,720 --> 00:12:06,160
identities as well so those uris we

00:12:04,720 --> 00:12:08,880
looked at before

00:12:06,160 --> 00:12:09,200
um and all of our integrations of this

00:12:08,880 --> 00:12:12,160
uh

00:12:09,200 --> 00:12:13,839
due to the general low uh integration of

00:12:12,160 --> 00:12:15,760
spire and spiffy in

00:12:13,839 --> 00:12:17,600
rus so far in open sourcing we actually

00:12:15,760 --> 00:12:19,839
wrote our own implementation

00:12:17,600 --> 00:12:21,440
called spire workload rs that will also

00:12:19,839 --> 00:12:22,880
be getting open source at the same time

00:12:21,440 --> 00:12:25,839
as key house when that gets open sourced

00:12:22,880 --> 00:12:25,839
in the coming months

00:12:27,760 --> 00:12:30,880
so uh let's talk more about our key

00:12:29,920 --> 00:12:34,079
hierarchy

00:12:30,880 --> 00:12:35,440
so in general like k key house it really

00:12:34,079 --> 00:12:38,000
revolves around a lot about

00:12:35,440 --> 00:12:40,160
envelope encryption and we also put a

00:12:38,000 --> 00:12:41,120
lot of uh you know effort into hardware

00:12:40,160 --> 00:12:43,440
route of trust

00:12:41,120 --> 00:12:44,320
so our master key generally speaking is

00:12:43,440 --> 00:12:47,680
stored at our

00:12:44,320 --> 00:12:49,600
at our in our you know our hsm and it is

00:12:47,680 --> 00:12:51,440
you know really hardened down it's in

00:12:49,600 --> 00:12:54,480
you know a lockdown cluster

00:12:51,440 --> 00:12:56,160
um of like hsn modules with any

00:12:54,480 --> 00:12:58,240
implementation defined like backup

00:12:56,160 --> 00:12:59,519
system and access control outside the

00:12:58,240 --> 00:13:03,040
keyhouse's hands

00:12:59,519 --> 00:13:04,320
um and uh you know to avoid

00:13:03,040 --> 00:13:06,399
generally speaking one would expect that

00:13:04,320 --> 00:13:08,000
to have a very like uh

00:13:06,399 --> 00:13:09,040
low throughput for encryption like

00:13:08,000 --> 00:13:10,560
you're not going to send a bunch of

00:13:09,040 --> 00:13:12,639
stuff into your hsm

00:13:10,560 --> 00:13:15,120
uh so we use an intermediate key that is

00:13:12,639 --> 00:13:18,160
directly encrypted by the hsm

00:13:15,120 --> 00:13:20,240
um and this gets stored in fcd uh at

00:13:18,160 --> 00:13:21,920
rest encrypted um

00:13:20,240 --> 00:13:24,160
and this is used to encrypt all other

00:13:21,920 --> 00:13:25,279
data in ncd generally speaking so like

00:13:24,160 --> 00:13:27,519
customer keys

00:13:25,279 --> 00:13:28,720
uh as our number one example we'll talk

00:13:27,519 --> 00:13:29,920
more about those later but those are

00:13:28,720 --> 00:13:31,440
really like our meat and buns

00:13:29,920 --> 00:13:33,839
uh and that's what a lot of like access

00:13:31,440 --> 00:13:34,959
control and users kind of interact with

00:13:33,839 --> 00:13:38,320
data keys are

00:13:34,959 --> 00:13:40,320
uh what we use an sdk level to

00:13:38,320 --> 00:13:42,000
uh it's kind of like the end use key uh

00:13:40,320 --> 00:13:44,320
you can think about it that way

00:13:42,000 --> 00:13:45,760
so we made a master key um these are

00:13:44,320 --> 00:13:48,560
generally manually rotated

00:13:45,760 --> 00:13:49,519
uh by any like you know presumably have

00:13:48,560 --> 00:13:52,800
some kind of like

00:13:49,519 --> 00:13:54,480
uh operation in place uh to to create a

00:13:52,800 --> 00:13:56,959
new master key internally

00:13:54,480 --> 00:13:57,680
um and then uh you would just have

00:13:56,959 --> 00:14:00,880
keyhouse

00:13:57,680 --> 00:14:03,279
uh updated to uh

00:14:00,880 --> 00:14:04,399
start you know uh migrating all of the

00:14:03,279 --> 00:14:06,480
existing encrypted

00:14:04,399 --> 00:14:07,519
customer keys and intermediate keys

00:14:06,480 --> 00:14:10,399
around uh

00:14:07,519 --> 00:14:11,440
this new master key so our intermediate

00:14:10,399 --> 00:14:12,880
keypad

00:14:11,440 --> 00:14:14,839
uh the only time you would need to

00:14:12,880 --> 00:14:17,120
access hsm or any other

00:14:14,839 --> 00:14:17,920
like hardware route of trust

00:14:17,120 --> 00:14:20,639
implementing

00:14:17,920 --> 00:14:21,199
storage uh will be at the startup when

00:14:20,639 --> 00:14:24,560
you need to

00:14:21,199 --> 00:14:26,880
decrypt uh intermediate key that's

00:14:24,560 --> 00:14:27,839
in at rest or when you rotate

00:14:26,880 --> 00:14:30,079
intermediate key

00:14:27,839 --> 00:14:31,839
yeah so uh this ends up being that in

00:14:30,079 --> 00:14:33,760
our current defaults where we rotate

00:14:31,839 --> 00:14:36,079
intermediate keys every 24 hours

00:14:33,760 --> 00:14:37,279
and assuming you don't restart keyhouse

00:14:36,079 --> 00:14:40,560
uh very often that

00:14:37,279 --> 00:14:43,839
results in one encrypt in uh uh

00:14:40,560 --> 00:14:46,240
like and decrypt operations one per pod

00:14:43,839 --> 00:14:47,519
and then one encrypt operation to create

00:14:46,240 --> 00:14:48,880
a new intermediate key

00:14:47,519 --> 00:14:50,720
uh and then each pod would have to

00:14:48,880 --> 00:14:52,800
decrypt the intermediate key on boot

00:14:50,720 --> 00:14:55,199
uh that's kind of like the general uh

00:14:52,800 --> 00:14:58,320
load on the hsm that's expected

00:14:55,199 --> 00:14:59,680
um yeah so our intermediate keys uh

00:14:58,320 --> 00:15:00,079
we've heard a little bit about these but

00:14:59,680 --> 00:15:03,120
uh

00:15:00,079 --> 00:15:06,240
these are uh as i said

00:15:03,120 --> 00:15:08,320
uh are rotated once per day um

00:15:06,240 --> 00:15:10,839
and are encrypted at rest by the the

00:15:08,320 --> 00:15:13,519
master key in the hsm

00:15:10,839 --> 00:15:15,760
um there can be more than one floating

00:15:13,519 --> 00:15:17,920
around uh due to the way that keyhouse

00:15:15,760 --> 00:15:18,880
uh migrates customer keys when we rotate

00:15:17,920 --> 00:15:20,320
intermediate keys

00:15:18,880 --> 00:15:22,079
intermediate keys actually get stored

00:15:20,320 --> 00:15:22,639
alongside or they get copied alongside

00:15:22,079 --> 00:15:25,199
customer

00:15:22,639 --> 00:15:26,800
keys encrypted at rest uh this way that

00:15:25,199 --> 00:15:27,440
in the when we rotate an intermediate

00:15:26,800 --> 00:15:30,000
key

00:15:27,440 --> 00:15:32,079
um you know we can do it reliably uh

00:15:30,000 --> 00:15:33,600
with each pod taking an arbitrary chunk

00:15:32,079 --> 00:15:35,040
of those customer keys and

00:15:33,600 --> 00:15:36,639
uh re-encrypting them with new

00:15:35,040 --> 00:15:39,120
intermediate keys um

00:15:36,639 --> 00:15:40,959
in a highly reliable way um taking

00:15:39,120 --> 00:15:42,480
advantage of fcd's consistency to

00:15:40,959 --> 00:15:44,240
coordinate

00:15:42,480 --> 00:15:45,839
uh so our customer keys these are you

00:15:44,240 --> 00:15:48,320
know are real meat and bones

00:15:45,839 --> 00:15:48,959
um these are what access control lists

00:15:48,320 --> 00:15:50,959
live on

00:15:48,959 --> 00:15:52,560
these also have an assigned purpose like

00:15:50,959 --> 00:15:54,399
okay these are for encrypting secrets

00:15:52,560 --> 00:15:57,920
these are for encrypting data

00:15:54,399 --> 00:15:59,839
um and uh they never leave the keyhouse

00:15:57,920 --> 00:16:01,120
uh it's kind of like the the lowest

00:15:59,839 --> 00:16:04,399
layer key

00:16:01,120 --> 00:16:07,120
uh that is in key house server itself

00:16:04,399 --> 00:16:08,000
um generally speaking what happens with

00:16:07,120 --> 00:16:10,079
these keyholes

00:16:08,000 --> 00:16:11,519
these customer keys is an administrator

00:16:10,079 --> 00:16:12,639
goes through creates one sets an access

00:16:11,519 --> 00:16:14,399
control list

00:16:12,639 --> 00:16:16,000
and then we get to the data key so what

00:16:14,399 --> 00:16:17,759
happens is if you think about it from

00:16:16,000 --> 00:16:20,560
the sdk perspective

00:16:17,759 --> 00:16:22,720
sdk wants to encrypt some data uh sdk

00:16:20,560 --> 00:16:24,959
requests a data key from keyhouse

00:16:22,720 --> 00:16:26,480
keyhouse uses an uh a one a one time

00:16:24,959 --> 00:16:27,199
password scheme kind of like two factor

00:16:26,480 --> 00:16:29,680
authentication

00:16:27,199 --> 00:16:31,120
to uh generate a data key for a given

00:16:29,680 --> 00:16:33,199
day to uh

00:16:31,120 --> 00:16:34,320
make caching uh a much more reasonable

00:16:33,199 --> 00:16:35,279
thing to do

00:16:34,320 --> 00:16:36,800
because we want to keep the number of

00:16:35,279 --> 00:16:38,160
data keys floating around for a given

00:16:36,800 --> 00:16:40,399
time period low

00:16:38,160 --> 00:16:42,000
um generally speaking we do one data key

00:16:40,399 --> 00:16:45,199
per day per customer key

00:16:42,000 --> 00:16:45,839
um and so what uh keyhouse will do is

00:16:45,199 --> 00:16:48,639
it'll return

00:16:45,839 --> 00:16:50,160
the encrypted uh data key an envelope

00:16:48,639 --> 00:16:52,160
encrypted by the customer key and the

00:16:50,160 --> 00:16:54,320
unencrypted data key to the sdk

00:16:52,160 --> 00:16:55,519
which will then encrypt the original

00:16:54,320 --> 00:16:57,680
payload and

00:16:55,519 --> 00:16:59,440
store alongside the encrypted data key

00:16:57,680 --> 00:17:02,079
alongside it along with

00:16:59,440 --> 00:17:04,720
metadata that tags it along to its

00:17:02,079 --> 00:17:08,400
owning customer key

00:17:04,720 --> 00:17:10,240
um and uh

00:17:08,400 --> 00:17:12,079
yeah it's you know ends up being this

00:17:10,240 --> 00:17:13,839
really clean implementation where

00:17:12,079 --> 00:17:16,079
uh the data never gets sent to keyhole

00:17:13,839 --> 00:17:18,959
so it minimizes your bandwidth usage

00:17:16,079 --> 00:17:20,480
um but we also uh avoid sending the

00:17:18,959 --> 00:17:22,559
customer key to

00:17:20,480 --> 00:17:24,559
the client and also minimizing the

00:17:22,559 --> 00:17:25,600
number of requests upstream to keyhouse

00:17:24,559 --> 00:17:27,280
this also provides us a lot of

00:17:25,600 --> 00:17:28,640
redundancy so in the event that the

00:17:27,280 --> 00:17:30,559
keyhole server is down

00:17:28,640 --> 00:17:32,000
uh if the sdk can't fetch another data

00:17:30,559 --> 00:17:33,440
key i mean it's not

00:17:32,000 --> 00:17:35,200
great but you know you can have some

00:17:33,440 --> 00:17:37,200
leeway where like say we try to fetch a

00:17:35,200 --> 00:17:37,760
new data key every six hours but if it

00:17:37,200 --> 00:17:39,360
fails

00:17:37,760 --> 00:17:41,840
well we can wait another six hours it

00:17:39,360 --> 00:17:44,000
only rotates every 24 hours anyways

00:17:41,840 --> 00:17:45,840
um and you know of course you want to

00:17:44,000 --> 00:17:48,320
put strict limits on that to avoid

00:17:45,840 --> 00:17:49,760
any kind of problems but it allows for a

00:17:48,320 --> 00:17:52,400
lot of extra fault tolerance

00:17:49,760 --> 00:17:55,120
um and just improving that that uh you

00:17:52,400 --> 00:17:56,559
know reliability guarantee

00:17:55,120 --> 00:17:59,120
um so we talked a little bit about this

00:17:56,559 --> 00:18:00,720
before but secrets so not everything can

00:17:59,120 --> 00:18:02,320
really fit into the neat box that is

00:18:00,720 --> 00:18:04,480
like a customer key data key

00:18:02,320 --> 00:18:05,600
setup um so say you have some persistent

00:18:04,480 --> 00:18:06,640
key you need to use for some other

00:18:05,600 --> 00:18:09,039
purpose like a

00:18:06,640 --> 00:18:11,280
you know an hmac key an immutable

00:18:09,039 --> 00:18:14,000
private key for some pki stuff

00:18:11,280 --> 00:18:14,960
um some credentials for some sensitive

00:18:14,000 --> 00:18:17,360
service

00:18:14,960 --> 00:18:18,720
um you know you can store these in a

00:18:17,360 --> 00:18:21,840
keyhouse secret

00:18:18,720 --> 00:18:24,160
um and they get stored in that cd um uh

00:18:21,840 --> 00:18:25,440
buy a data key that doesn't leave uh key

00:18:24,160 --> 00:18:27,840
house

00:18:25,440 --> 00:18:29,919
in a given customer key that's the that

00:18:27,840 --> 00:18:30,880
is mutually exclusively assigned to only

00:18:29,919 --> 00:18:34,000
be able to

00:18:30,880 --> 00:18:34,960
encrypt secrets and not other data will

00:18:34,000 --> 00:18:37,280
uh

00:18:34,960 --> 00:18:38,000
uh be able to have any number of these

00:18:37,280 --> 00:18:41,520
uh

00:18:38,000 --> 00:18:43,039
associated with it um so key rings so

00:18:41,520 --> 00:18:45,440
key rings this is not a

00:18:43,039 --> 00:18:46,960
type of key is rather a category or a

00:18:45,440 --> 00:18:49,039
grouping of customer keys

00:18:46,960 --> 00:18:50,320
mostly used for operator and admin or

00:18:49,039 --> 00:18:53,919
slash administrator

00:18:50,320 --> 00:18:56,320
uh ease of use and convenience um

00:18:53,919 --> 00:18:57,520
you can use these to to kind of group

00:18:56,320 --> 00:18:59,039
together customer keys and like say

00:18:57,520 --> 00:19:01,360
share to another operator

00:18:59,039 --> 00:19:03,039
um and it's mostly all therefore is it's

00:19:01,360 --> 00:19:04,640
just a form of organization because

00:19:03,039 --> 00:19:06,240
i mean if you have one customer key per

00:19:04,640 --> 00:19:07,919
use case as you should

00:19:06,240 --> 00:19:09,200
it's falling good security principles

00:19:07,919 --> 00:19:09,760
then you can end up with quite a few of

00:19:09,200 --> 00:19:12,080
them

00:19:09,760 --> 00:19:13,360
and then you know you know it's nice to

00:19:12,080 --> 00:19:14,880
grip them together into some like

00:19:13,360 --> 00:19:19,360
coherent groupings say like

00:19:14,880 --> 00:19:19,360
x team or x service or whatever

00:19:19,440 --> 00:19:22,880
so uh you know we talked a little about

00:19:21,360 --> 00:19:24,559
operators and how we're using

00:19:22,880 --> 00:19:26,240
access controllers to the customer level

00:19:24,559 --> 00:19:26,720
this is kind of like a full diagram of

00:19:26,240 --> 00:19:29,919
what

00:19:26,720 --> 00:19:31,679
authorization looks like uh in keyhouse

00:19:29,919 --> 00:19:32,960
so you have some administrator you know

00:19:31,679 --> 00:19:36,160
they have access through

00:19:32,960 --> 00:19:38,640
some implementation defined uh mechanism

00:19:36,160 --> 00:19:40,160
you know say like sso or whatever uh

00:19:38,640 --> 00:19:40,880
they have ownership of some set of

00:19:40,160 --> 00:19:43,200
keyrings

00:19:40,880 --> 00:19:44,720
or access to some sort of keyrings um

00:19:43,200 --> 00:19:46,480
and then each keyring had

00:19:44,720 --> 00:19:48,320
uniquely owned some number of customer

00:19:46,480 --> 00:19:49,760
keys under it like i said before it's a

00:19:48,320 --> 00:19:51,200
grouping

00:19:49,760 --> 00:19:52,880
then each customer key has its own

00:19:51,200 --> 00:19:54,960
unique access control lists

00:19:52,880 --> 00:19:56,400
which define how it works at the data

00:19:54,960 --> 00:19:58,480
plane level

00:19:56,400 --> 00:20:00,240
and so the operators can then go into

00:19:58,480 --> 00:20:00,559
customer keys they have indirect control

00:20:00,240 --> 00:20:04,400
of

00:20:00,559 --> 00:20:06,159
and set up a

00:20:04,400 --> 00:20:07,679
access control to whatever spiffy

00:20:06,159 --> 00:20:09,200
authenticated entities like service

00:20:07,679 --> 00:20:10,080
person whatever your spiffy ids

00:20:09,200 --> 00:20:12,799
represent

00:20:10,080 --> 00:20:14,880
uh and can set it up to uh so they have

00:20:12,799 --> 00:20:16,960
whatever specific access is necessary

00:20:14,880 --> 00:20:20,000
reading secrets writing secrets uh

00:20:16,960 --> 00:20:22,799
encrypting data etc

00:20:20,000 --> 00:20:23,120
so uh next steps uh currently he house

00:20:22,799 --> 00:20:25,520
is

00:20:23,120 --> 00:20:26,559
not open source however we're working to

00:20:25,520 --> 00:20:27,840
open source it now

00:20:26,559 --> 00:20:29,840
we've been working with some security

00:20:27,840 --> 00:20:31,280
vendors to uh you know make sure

00:20:29,840 --> 00:20:32,960
everything's tip-top shape

00:20:31,280 --> 00:20:34,640
uh and we're also working to open-source

00:20:32,960 --> 00:20:36,799
our spire workload project

00:20:34,640 --> 00:20:38,640
uh inspire proxy as well which is mostly

00:20:36,799 --> 00:20:41,919
just an offshoot of spyware club

00:20:38,640 --> 00:20:44,480
um and uh yeah those we expect those to

00:20:41,919 --> 00:20:46,320
be open source in the next few months

00:20:44,480 --> 00:20:48,720
we also want to increase the number of

00:20:46,320 --> 00:20:51,039
integration for generic or open source

00:20:48,720 --> 00:20:52,240
implementations of uh various components

00:20:51,039 --> 00:20:54,320
of keyhouse say like

00:20:52,240 --> 00:20:55,280
different open source metric servers uh

00:20:54,320 --> 00:20:58,080
like log

00:20:55,280 --> 00:21:01,280
different ways to to gobble up logs um

00:20:58,080 --> 00:21:03,039
control plane authorization schemes

00:21:01,280 --> 00:21:05,440
perhaps team different background stores

00:21:03,039 --> 00:21:08,400
so just maximizing our

00:21:05,440 --> 00:21:09,520
uh kind of like ready to go on a lot of

00:21:08,400 --> 00:21:12,559
different open source

00:21:09,520 --> 00:21:15,360
more open source uh stacks

00:21:12,559 --> 00:21:16,559
um and also we want to add support for

00:21:15,360 --> 00:21:18,480
asymmetric keys

00:21:16,559 --> 00:21:19,600
right now keyhouse is really really

00:21:18,480 --> 00:21:21,679
tailored for

00:21:19,600 --> 00:21:23,440
what we need internally and we've really

00:21:21,679 --> 00:21:25,919
designed it around what our internal

00:21:23,440 --> 00:21:27,280
uh customers at bikecans like need for

00:21:25,919 --> 00:21:28,799
their different projects

00:21:27,280 --> 00:21:30,400
uh and one of those things just hasn't

00:21:28,799 --> 00:21:34,720
been uh you know

00:21:30,400 --> 00:21:37,440
asymmetric key is stored in uh keyhouse

00:21:34,720 --> 00:21:39,039
store asymmetric key as a secret yeah

00:21:37,440 --> 00:21:40,880
you can sort as a secret but like say

00:21:39,039 --> 00:21:41,520
automatic rotation or setting up pki

00:21:40,880 --> 00:21:43,280
infrastructures

00:21:41,520 --> 00:21:45,200
is not something currently innately

00:21:43,280 --> 00:21:46,080
supported by keyhouse as some special

00:21:45,200 --> 00:21:48,720
feature like

00:21:46,080 --> 00:21:50,080
we have for customer keys uh it fits in

00:21:48,720 --> 00:21:51,200
pretty well but we just haven't

00:21:50,080 --> 00:21:53,360
implemented that

00:21:51,200 --> 00:21:54,799
um it's not something we want to add in

00:21:53,360 --> 00:21:56,080
but yeah in general a lot of our design

00:21:54,799 --> 00:21:57,840
decisions have been

00:21:56,080 --> 00:21:59,440
primarily motivated by what we need to

00:21:57,840 --> 00:22:00,400
get this rolling inside

00:21:59,440 --> 00:22:01,760
uh i think we mentioned a little bit

00:22:00,400 --> 00:22:03,520
before but key house is deployed in

00:22:01,760 --> 00:22:05,120
production now bike dance and is now

00:22:03,520 --> 00:22:06,960
you know serving all the people on tech

00:22:05,120 --> 00:22:09,200
talk

00:22:06,960 --> 00:22:10,559
yeah we can't really give out any

00:22:09,200 --> 00:22:14,400
concrete numbers but

00:22:10,559 --> 00:22:18,640
uh several pods of key house are serving

00:22:14,400 --> 00:22:18,640
tens of thousands of services yeah

00:22:19,039 --> 00:22:22,080
uh yeah that's all we have here uh

00:22:21,039 --> 00:22:24,840
thanks everyone

00:22:22,080 --> 00:22:26,159
uh and i think now we have some time for

00:22:24,840 --> 00:22:30,640
questions

00:22:26,159 --> 00:22:30,640

YouTube URL: https://www.youtube.com/watch?v=O_diNCN5e4w


