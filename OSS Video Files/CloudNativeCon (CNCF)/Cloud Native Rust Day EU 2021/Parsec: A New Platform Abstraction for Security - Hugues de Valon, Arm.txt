Title: Parsec: A New Platform Abstraction for Security - Hugues de Valon, Arm
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Parsec: A New Platform Abstraction for Security - Hugues de Valon, Arm

Parsec is the Platform Abstraction for Security, an open-source initiative that aims to create simple, standardised, ergonomic software interfaces for interacting with hardware-backed security features on any platform in any programming language. Parsec enables key management and cryptographic services to be consumed on rich, multi-tenant platforms to protect Cloud Native deployments in a way that is agnostic with respect to the underlying hardware. This talk will give an overview of the Parsec project as well as its involvement in the Rust community making it easier to interface with HSMs, TPMs and PSA Crypto!
Captions: 
	00:00:00,000 --> 00:00:03,919
hi everyone and thanks for joining in

00:00:01,599 --> 00:00:04,720
today i'm xdevelo i'm a software

00:00:03,919 --> 00:00:07,520
engineer at

00:00:04,720 --> 00:00:09,519
arm and i will be presenting parsec the

00:00:07,520 --> 00:00:11,679
platform assertion for security

00:00:09,519 --> 00:00:13,120
and also its involvements in the larger

00:00:11,679 --> 00:00:17,520
errors community

00:00:13,120 --> 00:00:20,880
so let's get started let's see

00:00:17,520 --> 00:00:20,880
why why pasek

00:00:21,520 --> 00:00:26,640
to the the edge in between the cloud and

00:00:24,400 --> 00:00:29,679
the iot endpoint is becoming a

00:00:26,640 --> 00:00:31,840
richer compute capable world

00:00:29,679 --> 00:00:33,920
at the edge you you would want to to

00:00:31,840 --> 00:00:38,160
execute richer workloads for example for

00:00:33,920 --> 00:00:38,160
machine learning or sensor data analysis

00:00:38,640 --> 00:00:44,079
similarly than in the cloud gh is a

00:00:42,160 --> 00:00:45,360
multi-tenant environment where multiple

00:00:44,079 --> 00:00:50,239
applications

00:00:45,360 --> 00:00:51,920
could be accessing the same device

00:00:50,239 --> 00:00:54,000
and similarly then in the cloud you

00:00:51,920 --> 00:00:55,520
would want in the edge to have access to

00:00:54,000 --> 00:00:57,039
the various cloud native development

00:00:55,520 --> 00:00:59,760
tools

00:00:57,039 --> 00:01:01,359
but very differently from the cloud um

00:00:59,760 --> 00:01:02,640
the threat landscape is totally

00:01:01,359 --> 00:01:05,199
different

00:01:02,640 --> 00:01:06,799
you would have new new threats in the

00:01:05,199 --> 00:01:10,320
edge than than in the cloud

00:01:06,799 --> 00:01:13,360
and the the platforms

00:01:10,320 --> 00:01:16,400
are also very diverse

00:01:13,360 --> 00:01:18,560
and specifically um

00:01:16,400 --> 00:01:19,439
the the root of trust that they have so

00:01:18,560 --> 00:01:21,439
the the

00:01:19,439 --> 00:01:22,880
the hardware-backed security modules

00:01:21,439 --> 00:01:24,560
present on those platforms

00:01:22,880 --> 00:01:26,159
can be very diverse you could have

00:01:24,560 --> 00:01:27,280
trusted platform modules hardware

00:01:26,159 --> 00:01:30,240
security modules

00:01:27,280 --> 00:01:30,240
and secure elements

00:01:30,720 --> 00:01:38,400
so there is a conflict there

00:01:34,479 --> 00:01:40,880
between on one side having applications

00:01:38,400 --> 00:01:41,920
that are highly secure um that store

00:01:40,880 --> 00:01:44,799
their keys in

00:01:41,920 --> 00:01:46,079
real hardware uh in those uh root of

00:01:44,799 --> 00:01:48,479
trust modules

00:01:46,079 --> 00:01:49,759
and that's also easily deployed and on

00:01:48,479 --> 00:01:52,880
the other side

00:01:49,759 --> 00:01:54,399
this uh this this big landscape of

00:01:52,880 --> 00:01:58,079
different platforms and different

00:01:54,399 --> 00:01:58,719
uh device and different hardware backed

00:01:58,079 --> 00:02:02,399
security

00:01:58,719 --> 00:02:05,119
devices so so parsec is made to

00:02:02,399 --> 00:02:05,840
to to to solve that problems parsec

00:02:05,119 --> 00:02:09,280
provides a

00:02:05,840 --> 00:02:10,560
uniform compatibility layer across the

00:02:09,280 --> 00:02:13,599
diverse wall of

00:02:10,560 --> 00:02:16,319
edge parsec makes

00:02:13,599 --> 00:02:17,520
the connection in between cloud native

00:02:16,319 --> 00:02:19,120
applications

00:02:17,520 --> 00:02:21,360
that are written in any programming

00:02:19,120 --> 00:02:24,560
language and

00:02:21,360 --> 00:02:27,040
between the the device that

00:02:24,560 --> 00:02:28,400
can be any platform on any architecture

00:02:27,040 --> 00:02:30,959
and

00:02:28,400 --> 00:02:31,760
working with any any any hardware so

00:02:30,959 --> 00:02:33,200
they could be

00:02:31,760 --> 00:02:35,760
trusted but for modules hardware

00:02:33,200 --> 00:02:38,800
security modules a trusted execution

00:02:35,760 --> 00:02:40,800
environment services and and and other

00:02:38,800 --> 00:02:42,800
hardware-based security modules

00:02:40,800 --> 00:02:44,959
so parsec is making these connections so

00:02:42,800 --> 00:02:47,360
that cloud native

00:02:44,959 --> 00:02:48,640
development is possible at the edge

00:02:47,360 --> 00:02:51,760
secure cognitive

00:02:48,640 --> 00:02:51,760
development this possibility

00:02:52,560 --> 00:02:59,280
so let's see on a on a conceptual view

00:02:55,599 --> 00:03:02,159
parsec api is rooted in

00:02:59,280 --> 00:03:03,680
platform security architecture psa and

00:03:02,159 --> 00:03:06,720
specifically

00:03:03,680 --> 00:03:10,080
parsec uses the psa cryptography api

00:03:06,720 --> 00:03:12,720
which is providing key storage and

00:03:10,080 --> 00:03:14,319
a lot of different cryptography

00:03:12,720 --> 00:03:16,959
operations like

00:03:14,319 --> 00:03:17,599
for example asymmetric signing symmetric

00:03:16,959 --> 00:03:22,000
signing

00:03:17,599 --> 00:03:23,560
and and many more persec is a service

00:03:22,000 --> 00:03:25,280
a service that is available to

00:03:23,560 --> 00:03:28,080
[Music]

00:03:25,280 --> 00:03:31,519
clients in a rich choice so it's a it's

00:03:28,080 --> 00:03:31,519
a it's a user space demon

00:03:31,680 --> 00:03:38,159
which is not accessed through

00:03:35,120 --> 00:03:40,080
one specific language um parsec is as as

00:03:38,159 --> 00:03:40,640
develop its own wire protocol which is

00:03:40,080 --> 00:03:44,159
language

00:03:40,640 --> 00:03:47,760
agnostic and on top of which

00:03:44,159 --> 00:03:49,360
client libraries can be can be developed

00:03:47,760 --> 00:03:51,519
so client libraries in a lot of

00:03:49,360 --> 00:03:53,840
different programming language

00:03:51,519 --> 00:03:55,599
that can that know how to communicate

00:03:53,840 --> 00:03:58,159
with the ipc protocol

00:03:55,599 --> 00:03:58,840
in a convenient way for for developers

00:03:58,159 --> 00:04:02,159
so that's

00:03:58,840 --> 00:04:02,799
accessing in a you know in a rich

00:04:02,159 --> 00:04:05,200
workload

00:04:02,799 --> 00:04:07,519
um the hardware hardware-backed security

00:04:05,200 --> 00:04:09,680
modules is easy

00:04:07,519 --> 00:04:12,720
so let's see in more detail what is the

00:04:09,680 --> 00:04:15,599
the service architecture there

00:04:12,720 --> 00:04:16,479
so the parsec services architect is is

00:04:15,599 --> 00:04:20,000
made around the

00:04:16,479 --> 00:04:21,280
front end and backhand architecture

00:04:20,000 --> 00:04:23,199
so on the front end you have the

00:04:21,280 --> 00:04:25,360
listener which is the component

00:04:23,199 --> 00:04:27,840
responsible for taking in

00:04:25,360 --> 00:04:30,320
the requests of all the the clients on

00:04:27,840 --> 00:04:30,320
your system

00:04:30,800 --> 00:04:34,160
so the listener is

00:04:34,800 --> 00:04:41,919
knows the the y protocol and the

00:04:38,560 --> 00:04:43,440
and pass the request deeper in the

00:04:41,919 --> 00:04:45,840
service

00:04:43,440 --> 00:04:47,199
so that access control is performed in

00:04:45,840 --> 00:04:50,080
between the

00:04:47,199 --> 00:04:51,120
different tenants and the requests are

00:04:50,080 --> 00:04:53,759
passed

00:04:51,120 --> 00:04:55,840
on the specific providers that needs to

00:04:53,759 --> 00:04:58,160
to respond to the request

00:04:55,840 --> 00:05:01,039
and the provider is the backend of the

00:04:58,160 --> 00:05:03,520
service it is the

00:05:01,039 --> 00:05:05,199
the part where that knows that has the

00:05:03,520 --> 00:05:08,560
the hardware specific knowledge

00:05:05,199 --> 00:05:11,360
on how to communicate with the the root

00:05:08,560 --> 00:05:13,440
of trust

00:05:11,360 --> 00:05:14,560
and on the left on the other side of the

00:05:13,440 --> 00:05:16,639
ipc

00:05:14,560 --> 00:05:18,240
um there is the the cloud native

00:05:16,639 --> 00:05:22,400
application

00:05:18,240 --> 00:05:25,360
which is using the parsec client library

00:05:22,400 --> 00:05:26,240
to to be a totally platform agnostic and

00:05:25,360 --> 00:05:29,680
and

00:05:26,240 --> 00:05:31,199
and that will work on on on any platform

00:05:29,680 --> 00:05:34,080
so

00:05:31,199 --> 00:05:35,120
anywhere that this application is

00:05:34,080 --> 00:05:36,880
deployed

00:05:35,120 --> 00:05:39,039
anywhere that there is a perfect service

00:05:36,880 --> 00:05:40,960
it will work and will not need to be

00:05:39,039 --> 00:05:43,759
reconfigured

00:05:40,960 --> 00:05:46,000
as as it was previously if this

00:05:43,759 --> 00:05:48,479
application wanted to use a

00:05:46,000 --> 00:05:49,680
tpm or hsm it would have to change its

00:05:48,479 --> 00:05:53,039
api calls

00:05:49,680 --> 00:05:56,880
but with per sec it doesn't have to

00:05:53,039 --> 00:05:56,880
and i've talked about client libraries

00:05:56,960 --> 00:06:03,440
there are client libraries ergonomics

00:06:00,639 --> 00:06:04,560
depending on what is the the the use

00:06:03,440 --> 00:06:07,039
case so

00:06:04,560 --> 00:06:07,600
there is different layers the first

00:06:07,039 --> 00:06:09,520
layer

00:06:07,600 --> 00:06:11,360
the client library core is for

00:06:09,520 --> 00:06:13,680
sophisticated use case with granular

00:06:11,360 --> 00:06:16,080
control and that's the layer where

00:06:13,680 --> 00:06:16,720
all operations with all parameters are

00:06:16,080 --> 00:06:18,160
available

00:06:16,720 --> 00:06:20,160
so that's the most complicated layer

00:06:18,160 --> 00:06:21,840
because one developer

00:06:20,160 --> 00:06:24,240
will have to to set the specific

00:06:21,840 --> 00:06:26,960
parameters for for each call

00:06:24,240 --> 00:06:28,000
but there is a higher level for specific

00:06:26,960 --> 00:06:31,120
use case

00:06:28,000 --> 00:06:34,080
um which where

00:06:31,120 --> 00:06:36,400
where the client library make makes the

00:06:34,080 --> 00:06:39,199
the the choices for you with a small

00:06:36,400 --> 00:06:41,360
defaulting or capability profiling

00:06:39,199 --> 00:06:43,120
where parameters are already set

00:06:41,360 --> 00:06:45,840
basically

00:06:43,120 --> 00:06:46,880
and i'll show in an example uh layer uh

00:06:45,840 --> 00:06:49,680
letter

00:06:46,880 --> 00:06:53,360
what's the the client library call looks

00:06:49,680 --> 00:06:53,360
like for the for the followers clients

00:06:53,680 --> 00:06:56,960
well multi-tenancy is an imp is a

00:06:56,319 --> 00:07:00,080
obviously

00:06:56,960 --> 00:07:01,840
important part part of this so

00:07:00,080 --> 00:07:04,160
cloud native workload delivery at the

00:07:01,840 --> 00:07:06,319
edge is expected to be multitenant

00:07:04,160 --> 00:07:08,800
multiple applications will share access

00:07:06,319 --> 00:07:10,800
to the secure hardware on the platform

00:07:08,800 --> 00:07:12,240
each application needs a unique and

00:07:10,800 --> 00:07:13,919
personal identity

00:07:12,240 --> 00:07:16,800
which is assigned by a component that

00:07:13,919 --> 00:07:19,919
parser can trust

00:07:16,800 --> 00:07:21,199
the parsec service tweets each api call

00:07:19,919 --> 00:07:23,520
according to the identity of the

00:07:21,199 --> 00:07:25,840
application that made a call

00:07:23,520 --> 00:07:29,440
partitions key stores and brokers access

00:07:25,840 --> 00:07:29,440
to hardware based on the identity

00:07:29,599 --> 00:07:33,199
the source of the identity depends on

00:07:31,440 --> 00:07:35,360
the deployment it might be a container

00:07:33,199 --> 00:07:37,280
runtime manager for example

00:07:35,360 --> 00:07:39,680
a deployed system requires an identity

00:07:37,280 --> 00:07:41,840
provider a separate component that

00:07:39,680 --> 00:07:43,520
assigns identities to applications

00:07:41,840 --> 00:07:45,360
which has a trust relationship with the

00:07:43,520 --> 00:07:47,199
parsec service

00:07:45,360 --> 00:07:49,520
let's let's see let's see how how it

00:07:47,199 --> 00:07:51,440
works in practice

00:07:49,520 --> 00:07:52,639
so in your typical system you would have

00:07:51,440 --> 00:07:55,840
the parsec service

00:07:52,639 --> 00:07:59,280
sitting on top of the hardware back

00:07:55,840 --> 00:08:02,479
security modules and applications making

00:07:59,280 --> 00:08:02,479
calls to the parsec service

00:08:04,000 --> 00:08:07,039
separately from the parsec service there

00:08:05,440 --> 00:08:09,759
is the ident separator

00:08:07,039 --> 00:08:11,120
which rules is to give to each

00:08:09,759 --> 00:08:13,199
application on your system their

00:08:11,120 --> 00:08:16,720
specific identity

00:08:13,199 --> 00:08:19,680
this identity is given

00:08:16,720 --> 00:08:20,000
on their request to the perfect service

00:08:19,680 --> 00:08:21,759
so

00:08:20,000 --> 00:08:23,520
whenever an application wants to make a

00:08:21,759 --> 00:08:24,160
call to the parsec service for example

00:08:23,520 --> 00:08:28,000
to

00:08:24,160 --> 00:08:30,879
to generate a key pair or to

00:08:28,000 --> 00:08:31,520
use a key to encrypt some data the

00:08:30,879 --> 00:08:33,360
application

00:08:31,520 --> 00:08:36,000
has to give its identity to the parsec

00:08:33,360 --> 00:08:38,719
service and the parsec service

00:08:36,000 --> 00:08:40,320
with that identity will perform a

00:08:38,719 --> 00:08:42,320
keystore partitioning

00:08:40,320 --> 00:08:45,599
so that one application cannot access

00:08:42,320 --> 00:08:45,599
the key of another one

00:08:46,560 --> 00:08:53,120
but of course parsec needs to trust

00:08:49,839 --> 00:08:56,080
that identity and needs to

00:08:53,120 --> 00:08:58,240
verifies it so that the authenticity of

00:08:56,080 --> 00:08:58,880
of each of those identity identities is

00:08:58,240 --> 00:08:59,920
respected

00:08:58,880 --> 00:09:02,160
so there needs to be a trust

00:08:59,920 --> 00:09:05,040
relationship in between parsec and the

00:09:02,160 --> 00:09:07,920
identity provider

00:09:05,040 --> 00:09:09,040
for example when one identity provider

00:09:07,920 --> 00:09:12,480
that we currently

00:09:09,040 --> 00:09:15,839
have in pasek is um using

00:09:12,480 --> 00:09:19,200
unix user id

00:09:15,839 --> 00:09:20,880
so in that in that uh with that identity

00:09:19,200 --> 00:09:23,920
provider the applications

00:09:20,880 --> 00:09:27,440
when making calls to parsec give

00:09:23,920 --> 00:09:27,760
their their uid to parsec and to verify

00:09:27,440 --> 00:09:31,440
it

00:09:27,760 --> 00:09:32,360
parsec uses a feature on unix domain

00:09:31,440 --> 00:09:35,360
socket called

00:09:32,360 --> 00:09:38,640
peer credentials

00:09:35,360 --> 00:09:39,200
to make sure that the uid given in the

00:09:38,640 --> 00:09:41,760
request

00:09:39,200 --> 00:09:43,040
match the actual uid of the process

00:09:41,760 --> 00:09:45,440
which is on the other end

00:09:43,040 --> 00:09:47,600
of the unix domain circuit and if they

00:09:45,440 --> 00:09:49,760
match parsec is sure that

00:09:47,600 --> 00:09:50,959
the application is is indeed the one

00:09:49,760 --> 00:09:53,760
that

00:09:50,959 --> 00:09:57,360
it says it is and can use that uid as

00:09:53,760 --> 00:10:01,120
identity to partition the keystore

00:09:57,360 --> 00:10:04,720
another identity that we use in parsec

00:10:01,120 --> 00:10:08,320
is the is the spf id

00:10:04,720 --> 00:10:09,519
and uh using a spire as a spf

00:10:08,320 --> 00:10:12,560
implementation for example

00:10:09,519 --> 00:10:14,160
the the application fetch their their

00:10:12,560 --> 00:10:16,800
their spf id

00:10:14,160 --> 00:10:17,360
and what they actually fetch is the is

00:10:16,800 --> 00:10:20,959
the jot

00:10:17,360 --> 00:10:23,519
svid token um using the

00:10:20,959 --> 00:10:25,120
the spiffy workload api they give this

00:10:23,519 --> 00:10:28,079
token to parsec

00:10:25,120 --> 00:10:28,959
and parsec uses the workload api as well

00:10:28,079 --> 00:10:32,399
to verify it

00:10:28,959 --> 00:10:34,399
and make sure that that

00:10:32,399 --> 00:10:35,519
that that this token is valid and uses

00:10:34,399 --> 00:10:37,279
the specie id

00:10:35,519 --> 00:10:39,760
as the pass as the the application

00:10:37,279 --> 00:10:41,040
identity to partition the crystal

00:10:39,760 --> 00:10:43,600
so this is two examples of

00:10:41,040 --> 00:10:45,279
authenticators um one coming from

00:10:43,600 --> 00:10:48,160
uid from the operating system and the

00:10:45,279 --> 00:10:50,480
other one coming from spiffy

00:10:48,160 --> 00:10:52,160
but many more are possible and more

00:10:50,480 --> 00:10:55,519
generally in parsec

00:10:52,160 --> 00:10:56,000
there is a um a plugable architecture

00:10:55,519 --> 00:10:57,680
where

00:10:56,000 --> 00:10:58,360
all the different parts can be can be

00:10:57,680 --> 00:11:00,720
changed so

00:10:58,360 --> 00:11:02,560
[Music]

00:11:00,720 --> 00:11:05,360
other identity providers are perfectly

00:11:02,560 --> 00:11:07,519
possible depending on

00:11:05,360 --> 00:11:09,920
depending on the on the deployment of

00:11:07,519 --> 00:11:09,920
parsec

00:11:12,480 --> 00:11:16,880
so ultimately uh to use parsec you need

00:11:16,000 --> 00:11:18,720
the client library

00:11:16,880 --> 00:11:20,880
written in the in the language that you

00:11:18,720 --> 00:11:23,040
want

00:11:20,880 --> 00:11:23,920
and what we have currently um we have

00:11:23,040 --> 00:11:27,519
support for

00:11:23,920 --> 00:11:30,079
a rest client library we have support

00:11:27,519 --> 00:11:33,120
for a go client library

00:11:30,079 --> 00:11:35,360
a c client library which is a which is

00:11:33,120 --> 00:11:38,160
made possible through embed crypto

00:11:35,360 --> 00:11:40,560
and we also have a cli tool to access

00:11:38,160 --> 00:11:40,560
basic

00:11:40,720 --> 00:11:46,800
so each of those are our ways for for

00:11:44,079 --> 00:11:48,959
your your your workloads to to access

00:11:46,800 --> 00:11:52,240
the perfect service

00:11:48,959 --> 00:11:52,880
and let's see let's see how uh an actual

00:11:52,240 --> 00:11:54,639
example of

00:11:52,880 --> 00:11:57,120
of the of the resclient library looks

00:11:54,639 --> 00:12:00,320
like so as i told before

00:11:57,120 --> 00:12:02,399
this is the this is the the

00:12:00,320 --> 00:12:04,160
the core library level so so the layer

00:12:02,399 --> 00:12:07,920
where

00:12:04,160 --> 00:12:09,680
all the parameters are to be defined by

00:12:07,920 --> 00:12:13,040
the column so not the easiest layer

00:12:09,680 --> 00:12:15,440
but still as you can see all this code

00:12:13,040 --> 00:12:19,839
which is like around 25 lines

00:12:15,440 --> 00:12:23,120
is enough to uh to instantiate a

00:12:19,839 --> 00:12:23,600
pass a client generate a keypair sign a

00:12:23,120 --> 00:12:25,360
hash

00:12:23,600 --> 00:12:28,240
and export a public key so it's not

00:12:25,360 --> 00:12:32,480
actually it's not it's not that much

00:12:28,240 --> 00:12:35,760
um so if you if you focus on the four

00:12:32,480 --> 00:12:38,880
last lines we

00:12:35,760 --> 00:12:39,920
we actually do perform the actual calls

00:12:38,880 --> 00:12:43,600
where we

00:12:39,920 --> 00:12:45,920
create basic basic clients which is the

00:12:43,600 --> 00:12:47,040
the name of the rest client we generate

00:12:45,920 --> 00:12:51,040
a key pair

00:12:47,040 --> 00:12:53,680
uh and that is using the psc crypto as

00:12:51,040 --> 00:12:55,680
as as an api as i told before so when

00:12:53,680 --> 00:12:58,399
generating a keypair you have to give

00:12:55,680 --> 00:12:59,279
key attributes and in that case we say

00:12:58,399 --> 00:13:02,399
that

00:12:59,279 --> 00:13:04,320
the key that we are going to generate is

00:13:02,399 --> 00:13:06,639
a ecc keeper

00:13:04,320 --> 00:13:08,480
we give it it's curve family and the

00:13:06,639 --> 00:13:10,880
specific curve that it's going to use

00:13:08,480 --> 00:13:12,959
and also we give a policy uh where we

00:13:10,880 --> 00:13:15,519
say that um

00:13:12,959 --> 00:13:16,720
with this key you you will only be

00:13:15,519 --> 00:13:18,720
allowed to

00:13:16,720 --> 00:13:20,800
to sign ash and nothing else so you

00:13:18,720 --> 00:13:23,839
can't export it for example

00:13:20,800 --> 00:13:25,920
and you can only use an

00:13:23,839 --> 00:13:27,839
algorithm that we that we specify and in

00:13:25,920 --> 00:13:31,120
this case is ecgsa with

00:13:27,839 --> 00:13:34,320
shadow56 and

00:13:31,120 --> 00:13:36,880
then on on the on the other line we

00:13:34,320 --> 00:13:38,480
we assign a small text to it and this

00:13:36,880 --> 00:13:41,360
specific algorithm and then we export

00:13:38,480 --> 00:13:41,360
the the public key

00:13:41,440 --> 00:13:45,360
so if two two other things to notice in

00:13:44,000 --> 00:13:47,600
that snippet of code

00:13:45,360 --> 00:13:49,600
is that the key names are referenced

00:13:47,600 --> 00:13:51,519
using utf-8 strings

00:13:49,600 --> 00:13:52,880
so as you can see you can put emojis in

00:13:51,519 --> 00:13:57,600
it which is

00:13:52,880 --> 00:14:01,279
it can be nice and also

00:13:57,600 --> 00:14:04,480
to to actually instantiate a

00:14:01,279 --> 00:14:07,760
client so there is just one one new

00:14:04,480 --> 00:14:10,000
uh method here but what happens in the

00:14:07,760 --> 00:14:12,480
in the background is actually a very

00:14:10,000 --> 00:14:14,240
much more complicated than that is that

00:14:12,480 --> 00:14:16,079
when creating these clients

00:14:14,240 --> 00:14:18,800
this client will actually use the

00:14:16,079 --> 00:14:21,600
default parsec provider and the default

00:14:18,800 --> 00:14:23,760
persec authenticator on the system

00:14:21,600 --> 00:14:25,199
and when i mean default is that it's the

00:14:23,760 --> 00:14:28,320
default that has been set

00:14:25,199 --> 00:14:31,839
by uh by the parsec administrator

00:14:28,320 --> 00:14:31,839
when setting up per second the system

00:14:32,000 --> 00:14:38,160
so this code these few lines of code

00:14:36,160 --> 00:14:40,079
anywhere they are they are deployed they

00:14:38,160 --> 00:14:43,040
will work

00:14:40,079 --> 00:14:44,000
and they will work on the default

00:14:43,040 --> 00:14:45,920
provider and

00:14:44,000 --> 00:14:47,760
the default authenticator that parsec is

00:14:45,920 --> 00:14:50,720
working with so if

00:14:47,760 --> 00:14:52,000
parsec is deployed with a tpm those this

00:14:50,720 --> 00:14:53,920
will work with a tpm

00:14:52,000 --> 00:14:55,440
and if parsec is working with hsm this

00:14:53,920 --> 00:14:56,399
will work with an hsn but this code does

00:14:55,440 --> 00:14:58,079
not have to change

00:14:56,399 --> 00:15:00,160
and that's the big value proposition of

00:14:58,079 --> 00:15:03,920
barcelona that's the the cloud native

00:15:00,160 --> 00:15:04,639
way so i've shown the the rest client

00:15:03,920 --> 00:15:07,519
let's see

00:15:04,639 --> 00:15:08,800
the exact same um same code so the the

00:15:07,519 --> 00:15:10,720
exact same

00:15:08,800 --> 00:15:14,160
same operations but using the parsec

00:15:10,720 --> 00:15:16,959
tool which is the cli client

00:15:14,160 --> 00:15:18,560
and in the exact same way here we have a

00:15:16,959 --> 00:15:22,000
we have commands to

00:15:18,560 --> 00:15:25,040
to create an ecc key

00:15:22,000 --> 00:15:27,519
we have another command to sign and then

00:15:25,040 --> 00:15:29,600
we export the public key here

00:15:27,519 --> 00:15:30,720
and in the exact same way this is using

00:15:29,600 --> 00:15:32,639
the default

00:15:30,720 --> 00:15:34,720
provider and the default authenticator

00:15:32,639 --> 00:15:37,839
on the system

00:15:34,720 --> 00:15:39,040
of course it's if if parsec is is

00:15:37,839 --> 00:15:42,720
deployed

00:15:39,040 --> 00:15:45,839
on a system where there is both a tpm

00:15:42,720 --> 00:15:45,839
an hsm and

00:15:46,000 --> 00:15:49,839
a trusted service it's possible to

00:15:48,240 --> 00:15:53,199
choose like uh

00:15:49,839 --> 00:15:54,480
in the in the code the specific one that

00:15:53,199 --> 00:15:56,399
you want

00:15:54,480 --> 00:15:58,160
but by default and using the simple

00:15:56,399 --> 00:16:00,480
commands it will use the

00:15:58,160 --> 00:16:04,079
the default one which is often the only

00:16:00,480 --> 00:16:04,079
one that that barcode is deployed with

00:16:04,880 --> 00:16:09,920
so yeah that was it for the for the

00:16:07,759 --> 00:16:13,120
passive part of the presentation uh uh

00:16:09,920 --> 00:16:14,639
uh i also wanted to to present what's

00:16:13,120 --> 00:16:16,399
our involvement in the in the larger

00:16:14,639 --> 00:16:18,560
risk community so what what do we do for

00:16:16,399 --> 00:16:21,519
the rest community

00:16:18,560 --> 00:16:22,720
so as i as i told before parsec is a

00:16:21,519 --> 00:16:25,680
heavily relies

00:16:22,720 --> 00:16:26,880
on the different route of trust so on

00:16:25,680 --> 00:16:30,720
the different hardware back

00:16:26,880 --> 00:16:34,000
security modules and that we

00:16:30,720 --> 00:16:38,079
that we use and instead of

00:16:34,000 --> 00:16:41,680
developing the code uh inside the

00:16:38,079 --> 00:16:45,360
inside the the the code source

00:16:41,680 --> 00:16:47,759
we decided to to publish uh

00:16:45,360 --> 00:16:50,000
independent crates for for each of them

00:16:47,759 --> 00:16:53,680
so for example for the tpm

00:16:50,000 --> 00:16:57,680
we have a tss yes api crate

00:16:53,680 --> 00:16:59,839
which is which is a wrapper around the

00:16:57,680 --> 00:17:01,040
enhanced system api to communicate with

00:16:59,839 --> 00:17:03,279
gpms

00:17:01,040 --> 00:17:07,120
for hsm we have the crypto key crate

00:17:03,279 --> 00:17:09,520
which is wrapped around the pkcs11 api

00:17:07,120 --> 00:17:10,559
and for the trusted service provider we

00:17:09,520 --> 00:17:12,319
have the um

00:17:10,559 --> 00:17:14,079
and that's used in parsec as well we

00:17:12,319 --> 00:17:18,480
have the psa cryptocrate

00:17:14,079 --> 00:17:21,280
a wrap around the ps4 cryptoc api

00:17:18,480 --> 00:17:23,360
and all of those crates are rebuilt in a

00:17:21,280 --> 00:17:26,319
similar way because they are

00:17:23,360 --> 00:17:27,760
as as in they're all safe abstraction

00:17:26,319 --> 00:17:30,799
oversee apis

00:17:27,760 --> 00:17:32,559
so they are really using uh rust ejumps

00:17:30,799 --> 00:17:35,520
and rusty geometric codes

00:17:32,559 --> 00:17:36,960
to make sure that that what is exported

00:17:35,520 --> 00:17:40,240
in rust is always safe

00:17:36,960 --> 00:17:43,760
memory safe and straight safe so that

00:17:40,240 --> 00:17:45,039
they are actually really nice to use and

00:17:43,760 --> 00:17:46,960
[Music]

00:17:45,039 --> 00:17:49,200
even for someone that has no no interest

00:17:46,960 --> 00:17:52,320
at all in person just wants to use a

00:17:49,200 --> 00:17:55,760
tpm hsn uh interest those are

00:17:52,320 --> 00:17:56,960
uh really nice to do so and yeah many

00:17:55,760 --> 00:17:59,039
people are using them uh

00:17:56,960 --> 00:18:00,960
yeah totally independently for fanbase

00:17:59,039 --> 00:18:01,280
so so that's that's that's really great

00:18:00,960 --> 00:18:03,360
to

00:18:01,280 --> 00:18:05,120
to see to see engagement from the

00:18:03,360 --> 00:18:07,360
community just for for those specific

00:18:05,120 --> 00:18:11,440
parts

00:18:07,360 --> 00:18:14,160
so other than the crate that we that we

00:18:11,440 --> 00:18:15,200
that we ship we also contributed to to

00:18:14,160 --> 00:18:17,520
other

00:18:15,200 --> 00:18:18,240
rust projects so for bioengine for

00:18:17,520 --> 00:18:21,440
example we

00:18:18,240 --> 00:18:24,400
we added a support for

00:18:21,440 --> 00:18:25,120
dynamic loading in biogen itself so

00:18:24,400 --> 00:18:28,000
using the

00:18:25,120 --> 00:18:28,799
lib loading crate so that binding is

00:18:28,000 --> 00:18:32,320
capable of

00:18:28,799 --> 00:18:35,360
generating a structure uh

00:18:32,320 --> 00:18:35,360
which creates a

00:18:35,440 --> 00:18:39,039
lib loading context so that's for

00:18:37,840 --> 00:18:40,559
example you can see

00:18:39,039 --> 00:18:42,480
here and that's what we use in the

00:18:40,559 --> 00:18:45,520
crypto key

00:18:42,480 --> 00:18:47,120
syscrate is that it generates this

00:18:45,520 --> 00:18:48,640
pkcs11 structure

00:18:47,120 --> 00:18:50,400
in this specific case because it's been

00:18:48,640 --> 00:18:54,000
given the pkcs11 ca

00:18:50,400 --> 00:18:55,679
api header file and so that at runtime

00:18:54,000 --> 00:18:58,000
we just have to give him the the path of

00:18:55,679 --> 00:18:59,919
the dynamic library and it will

00:18:58,000 --> 00:19:02,080
automatically create the leap loading

00:18:59,919 --> 00:19:05,520
structure so that's really useful

00:19:02,080 --> 00:19:08,080
for for rest abstraction of the

00:19:05,520 --> 00:19:08,880
other api and libraries that are meant

00:19:08,080 --> 00:19:12,160
to be

00:19:08,880 --> 00:19:12,160
to be loaded at some time

00:19:12,799 --> 00:19:17,200
we added the peer credential support for

00:19:15,200 --> 00:19:19,440
unix domain sockets

00:19:17,200 --> 00:19:20,320
um and that's currently available in

00:19:19,440 --> 00:19:23,520
nightly rest

00:19:20,320 --> 00:19:24,000
with the the pr cred method that that

00:19:23,520 --> 00:19:27,280
that

00:19:24,000 --> 00:19:30,559
is to be executed on the unix stream and

00:19:27,280 --> 00:19:33,520
that method actually returns the uid

00:19:30,559 --> 00:19:35,840
and the the group id of the process that

00:19:33,520 --> 00:19:38,080
is on the other side of the

00:19:35,840 --> 00:19:39,600
of the of the socket and that's mainly

00:19:38,080 --> 00:19:41,840
uh what we use

00:19:39,600 --> 00:19:43,440
in the in the bar second indicator to

00:19:41,840 --> 00:19:46,720
make sure to to check

00:19:43,440 --> 00:19:49,760
that the uid match the client that is

00:19:46,720 --> 00:19:51,919
that is calling basic and also we added

00:19:49,760 --> 00:19:54,960
a basic uh

00:19:51,919 --> 00:19:55,679
svid uh token api support in in russ

00:19:54,960 --> 00:19:57,520
bifi

00:19:55,679 --> 00:20:00,160
and that's what we're using our specific

00:19:57,520 --> 00:20:00,160
authenticator

00:20:01,039 --> 00:20:07,120
so yeah so that's it for

00:20:04,400 --> 00:20:08,159
for for for this presentation uh thanks

00:20:07,120 --> 00:20:11,280
a lot for

00:20:08,159 --> 00:20:12,880
for listening to it um you can check the

00:20:11,280 --> 00:20:14,880
code of pasek and the code of the

00:20:12,880 --> 00:20:17,919
different crates that i presented in

00:20:14,880 --> 00:20:20,080
in the prolac second github organization

00:20:17,919 --> 00:20:22,000
if you're interested in pasek make sure

00:20:20,080 --> 00:20:23,919
to check out our book

00:20:22,000 --> 00:20:25,120
it actually contains a quick a quick

00:20:23,919 --> 00:20:28,799
start guide

00:20:25,120 --> 00:20:31,039
um if you're running a linux and x86

00:20:28,799 --> 00:20:31,840
to to to really uh get you started

00:20:31,039 --> 00:20:35,120
quickly

00:20:31,840 --> 00:20:37,280
um and uh try trying the

00:20:35,120 --> 00:20:39,440
the actual trying the the cli parsec

00:20:37,280 --> 00:20:41,760
tool uh quickly

00:20:39,440 --> 00:20:43,039
we are on the cncf slack workspace on

00:20:41,760 --> 00:20:44,080
the pacific channel if you have any

00:20:43,039 --> 00:20:47,039
questions at all

00:20:44,080 --> 00:20:48,559
uh really feel free to to chat with us

00:20:47,039 --> 00:20:49,039
and we have a weekly community call as

00:20:48,559 --> 00:20:51,840
well

00:20:49,039 --> 00:20:52,640
uh on tuesdays uh where where you can

00:20:51,840 --> 00:20:56,000
where you can

00:20:52,640 --> 00:20:56,880
also join and chat with uh with us so if

00:20:56,000 --> 00:20:58,799
you have any questions

00:20:56,880 --> 00:21:00,640
i'll i'll be really happy to to to

00:20:58,799 --> 00:21:03,080
answer and yeah otherwise

00:21:00,640 --> 00:21:06,080
thanks a lot for listening to me today

00:21:03,080 --> 00:21:06,080

YouTube URL: https://www.youtube.com/watch?v=49cXCDLALYY


