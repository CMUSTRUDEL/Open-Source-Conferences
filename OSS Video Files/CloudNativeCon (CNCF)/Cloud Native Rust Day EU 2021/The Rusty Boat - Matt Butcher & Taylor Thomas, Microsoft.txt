Title: The Rusty Boat - Matt Butcher & Taylor Thomas, Microsoft
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

The Rusty Boat - Matt Butcher & Taylor Thomas, Microsoft

One year ago, our team released Krustlet, a Kubernetes Kubelet implementation for running WASM modules written in Rust. Since then, we've spent plenty of time out on the frontier, implementing full Kubernetes functionality, all in Rust. In this session, we'll cover why we chose Rust and what the benefits and rough edges are. Using code from Krustlet as a practical backdrop, we'll show you how we wrote the core components of Kubelet from scratch and by leveraging various community crates (including gRPC, controllers, volume mounting, and more!) to highlight how you can also use Rust for your next Cloud Native project.
Captions: 
	00:00:00,080 --> 00:00:04,720
hi everyone welcome to the rusty boat my

00:00:02,720 --> 00:00:06,720
name is taylor thomas and i'll let matt

00:00:04,720 --> 00:00:09,280
uh butcher introduce himself

00:00:06,720 --> 00:00:11,440
yeah i'm matt butcher um i lead an open

00:00:09,280 --> 00:00:13,360
source team at microsoft

00:00:11,440 --> 00:00:15,200
i've been working on all kinds of cloud

00:00:13,360 --> 00:00:17,520
technologies over the last

00:00:15,200 --> 00:00:18,480
long time uh including helm uh

00:00:17,520 --> 00:00:21,760
kubernetes

00:00:18,480 --> 00:00:22,800
uh brigade uh various paths platforms

00:00:21,760 --> 00:00:25,599
and even going back

00:00:22,800 --> 00:00:27,760
into openstack uh you can find me all

00:00:25,599 --> 00:00:30,160
over the social media as always at

00:00:27,760 --> 00:00:31,119
technosofas so there you go and this is

00:00:30,160 --> 00:00:32,640
taylor

00:00:31,119 --> 00:00:34,000
yeah and like he said i'm kind of a

00:00:32,640 --> 00:00:35,440
little bit less consistent with the

00:00:34,000 --> 00:00:37,200
social media so there's all my social

00:00:35,440 --> 00:00:37,600
media handles and that's just because

00:00:37,200 --> 00:00:41,120
you know

00:00:37,600 --> 00:00:42,480
common name and common last name so it's

00:00:41,120 --> 00:00:45,120
kind of hard sometimes

00:00:42,480 --> 00:00:46,399
um so first off i'm one of the crescent

00:00:45,120 --> 00:00:47,680
core maintainers we'll talk about that

00:00:46,399 --> 00:00:50,800
project a lot today

00:00:47,680 --> 00:00:51,600
um and one a an emeritus uh helm core

00:00:50,800 --> 00:00:54,000
maintainer

00:00:51,600 --> 00:00:55,680
um i've also been doing uh containers in

00:00:54,000 --> 00:00:57,520
kubernetes for a long time it makes me

00:00:55,680 --> 00:00:58,320
quite old in container years as we like

00:00:57,520 --> 00:01:00,160
to joke

00:00:58,320 --> 00:01:02,079
i've been just doing it for for a while

00:01:00,160 --> 00:01:04,799
not as long as matt has but

00:01:02,079 --> 00:01:06,799
for a while and then um i am a uh

00:01:04,799 --> 00:01:07,280
restation what we call rust developers

00:01:06,799 --> 00:01:09,360
right

00:01:07,280 --> 00:01:10,799
by way of go which makes sense given my

00:01:09,360 --> 00:01:12,960
background and so

00:01:10,799 --> 00:01:14,320
um we're going to go ahead and and kind

00:01:12,960 --> 00:01:16,320
of kick off and talk about different

00:01:14,320 --> 00:01:19,520
things we've learned from rust and

00:01:16,320 --> 00:01:20,320
in cloud computing so this all kind of

00:01:19,520 --> 00:01:22,960
started with an

00:01:20,320 --> 00:01:24,000
aha moment uh or maybe a couple of aha

00:01:22,960 --> 00:01:26,400
moments

00:01:24,000 --> 00:01:27,759
i was doing a one-on-one with uh with

00:01:26,400 --> 00:01:30,640
one of the people on our team

00:01:27,759 --> 00:01:31,200
uh brian and we were kind of wandering

00:01:30,640 --> 00:01:35,040
around

00:01:31,200 --> 00:01:35,520
boulder this was summertime 2019. we had

00:01:35,040 --> 00:01:37,119
a

00:01:35,520 --> 00:01:39,040
couple cups of iced coffee and we were

00:01:37,119 --> 00:01:40,720
just kind of walking around talking

00:01:39,040 --> 00:01:42,560
it was a couple of days before we all

00:01:40,720 --> 00:01:45,920
got together for an on-site

00:01:42,560 --> 00:01:47,520
and uh as happens you know the

00:01:45,920 --> 00:01:49,119
topic a led to topic b and all of a

00:01:47,520 --> 00:01:51,280
sudden we were talking about hey

00:01:49,119 --> 00:01:52,560
remember when assembly.js was going to

00:01:51,280 --> 00:01:54,240
be the next big thing

00:01:52,560 --> 00:01:56,240
and we both sort of vowed to go off and

00:01:54,240 --> 00:01:57,759
look at this well unbeknownst to us

00:01:56,240 --> 00:01:59,920
other people on the team had

00:01:57,759 --> 00:02:01,600
accidentally stumbled on the webassembly

00:01:59,920 --> 00:02:04,240
world at the same time

00:02:01,600 --> 00:02:05,040
uh and when we got together about a week

00:02:04,240 --> 00:02:06,960
later

00:02:05,040 --> 00:02:08,959
we had this kind of brainstorming

00:02:06,960 --> 00:02:10,479
session and we all sort of blurted out

00:02:08,959 --> 00:02:12,319
at the same time wouldn't it be fun to

00:02:10,479 --> 00:02:14,640
work on webassembly and who's doing what

00:02:12,319 --> 00:02:15,920
with webassembly and here's some ideas

00:02:14,640 --> 00:02:17,680
and if you take a look at the

00:02:15,920 --> 00:02:19,360
webassembly ecosystem

00:02:17,680 --> 00:02:21,200
these days they're really kind of two

00:02:19,360 --> 00:02:23,280
prongs of the cutting edge there's the m

00:02:21,200 --> 00:02:25,280
script in javascript implementation

00:02:23,280 --> 00:02:27,360
and then there's a whole bunch of work

00:02:25,280 --> 00:02:30,080
uh much of which started out of mozilla

00:02:27,360 --> 00:02:32,480
that's really oriented more around rust

00:02:30,080 --> 00:02:34,160
and so we kind of came to rust we'd all

00:02:32,480 --> 00:02:36,239
dabbled with it here and there but

00:02:34,160 --> 00:02:38,160
really our first production endeavors

00:02:36,239 --> 00:02:40,959
with rust all had to do with

00:02:38,160 --> 00:02:42,239
web assembly and kubernetes uh and and

00:02:40,959 --> 00:02:44,400
that's kind of what got us

00:02:42,239 --> 00:02:45,599
originally started on it but we feel

00:02:44,400 --> 00:02:49,040
really good about that

00:02:45,599 --> 00:02:51,440
selection and uh and here's why yeah so

00:02:49,040 --> 00:02:54,319
the really these are kind of the over

00:02:51,440 --> 00:02:55,599
overarching reasons why we picked rust

00:02:54,319 --> 00:02:57,440
and and then we'll go a little bit

00:02:55,599 --> 00:02:59,120
deeper into each into all the things we

00:02:57,440 --> 00:03:01,840
discussed here so first off

00:02:59,120 --> 00:03:03,440
we have safety if you're here at a rest

00:03:01,840 --> 00:03:05,599
conference you probably know that but

00:03:03,440 --> 00:03:07,360
just to mention it like safety is a huge

00:03:05,599 --> 00:03:08,959
thing with rest and that was

00:03:07,360 --> 00:03:10,480
an excellent benefit that we picked up

00:03:08,959 --> 00:03:11,280
basically for free for using the

00:03:10,480 --> 00:03:13,440
language

00:03:11,280 --> 00:03:14,640
um the developer experience in rest is

00:03:13,440 --> 00:03:17,840
quite amazing which we'll

00:03:14,640 --> 00:03:18,720
also dive into and like matt mentioned

00:03:17,840 --> 00:03:21,200
we have

00:03:18,720 --> 00:03:22,879
wasm support in it wasm support in rust

00:03:21,200 --> 00:03:23,440
is probably one of the best of all the

00:03:22,879 --> 00:03:25,840
languages

00:03:23,440 --> 00:03:27,360
at least for the um side wasm that's

00:03:25,840 --> 00:03:30,000
meant for the server side

00:03:27,360 --> 00:03:31,840
and then there's an extensibility thing

00:03:30,000 --> 00:03:33,040
with with rest apis that's just really

00:03:31,840 --> 00:03:34,640
elegant and beautiful

00:03:33,040 --> 00:03:37,280
that has been very helpful as we've

00:03:34,640 --> 00:03:38,879
extended external apis and also consumed

00:03:37,280 --> 00:03:39,760
other internal apis which we'll talk

00:03:38,879 --> 00:03:42,799
about here

00:03:39,760 --> 00:03:44,879
yeah so oh yeah something that

00:03:42,799 --> 00:03:46,000
really kind of transformed the way we

00:03:44,879 --> 00:03:48,080
did a lot of development

00:03:46,000 --> 00:03:51,200
especially having come from go where the

00:03:48,080 --> 00:03:53,760
extensibility isn't quite at the same

00:03:51,200 --> 00:03:55,519
language level as it is in rust and that

00:03:53,760 --> 00:03:57,040
has been sort of a big and compelling

00:03:55,519 --> 00:03:59,840
reason why we've switched a lot of our

00:03:57,040 --> 00:04:01,760
development there

00:03:59,840 --> 00:04:03,280
rust is usually considered a systems

00:04:01,760 --> 00:04:05,599
development language but

00:04:03,280 --> 00:04:06,720
we've been using it almost exclusively

00:04:05,599 --> 00:04:08,480
on our team for

00:04:06,720 --> 00:04:10,319
cloud development and have found it to

00:04:08,480 --> 00:04:12,000
be very much a good fit cloud

00:04:10,319 --> 00:04:13,920
development of course is a type of

00:04:12,000 --> 00:04:15,360
system development but often with a lot

00:04:13,920 --> 00:04:17,440
more emphasis on

00:04:15,360 --> 00:04:18,479
http and networking and things like that

00:04:17,440 --> 00:04:20,160
that uh

00:04:18,479 --> 00:04:22,000
our colleagues originally were saying

00:04:20,160 --> 00:04:24,080
but why did you choose rust for that

00:04:22,000 --> 00:04:25,680
wouldn't you just use language x or

00:04:24,080 --> 00:04:27,680
language y how come you didn't just stay

00:04:25,680 --> 00:04:28,960
with go

00:04:27,680 --> 00:04:30,560
yeah and so we really just wanted to

00:04:28,960 --> 00:04:31,280
talk about that's what the first part of

00:04:30,560 --> 00:04:32,479
this

00:04:31,280 --> 00:04:34,080
this talk is going to be about we're

00:04:32,479 --> 00:04:34,960
going to kind of go over well how does

00:04:34,080 --> 00:04:36,240
rust look

00:04:34,960 --> 00:04:38,479
in cloud native development and then

00:04:36,240 --> 00:04:40,560
we're going to go into a very specific

00:04:38,479 --> 00:04:42,000
example of how we reverse engineered

00:04:40,560 --> 00:04:43,919
kubelet and a bunch of kubernetes

00:04:42,000 --> 00:04:45,199
things and show the different components

00:04:43,919 --> 00:04:46,479
of rust that we used

00:04:45,199 --> 00:04:49,040
so we're going to talk about this in

00:04:46,479 --> 00:04:50,720
good bad and ugly and so let's go ahead

00:04:49,040 --> 00:04:51,680
and break into the good stuff so one of

00:04:50,720 --> 00:04:55,520
the good things we love

00:04:51,680 --> 00:04:57,440
is traits traits are pretty much amazing

00:04:55,520 --> 00:04:58,800
there's not really a better way to say

00:04:57,440 --> 00:05:01,120
that they are

00:04:58,800 --> 00:05:02,479
flexible they're expressive we've loved

00:05:01,120 --> 00:05:04,240
the conversion reference

00:05:02,479 --> 00:05:06,240
uh traits like the ones displayed here

00:05:04,240 --> 00:05:08,960
so this is like from try from

00:05:06,240 --> 00:05:10,240
from string d ref all those different

00:05:08,960 --> 00:05:13,199
traits because

00:05:10,240 --> 00:05:14,800
it allows just such flexible things

00:05:13,199 --> 00:05:16,240
compared to other interface types we

00:05:14,800 --> 00:05:18,320
consider traits to be better than pretty

00:05:16,240 --> 00:05:20,560
much most other interface style types

00:05:18,320 --> 00:05:21,759
because the type itself doesn't even

00:05:20,560 --> 00:05:23,919
have to implement

00:05:21,759 --> 00:05:24,960
the an interface to be used as another

00:05:23,919 --> 00:05:26,720
type

00:05:24,960 --> 00:05:28,320
dref is really nice for picking up

00:05:26,720 --> 00:05:29,199
methods from underneath it's it's just

00:05:28,320 --> 00:05:30,880
pretty awesome

00:05:29,199 --> 00:05:32,479
this is an example from our bundle

00:05:30,880 --> 00:05:34,400
project which we won't talk about here

00:05:32,479 --> 00:05:36,080
but it just allows us to pass in pretty

00:05:34,400 --> 00:05:37,520
much any type that can be parsed as a

00:05:36,080 --> 00:05:40,000
string and then a few others

00:05:37,520 --> 00:05:41,280
and convert it into our internal id type

00:05:40,000 --> 00:05:42,720
which is really

00:05:41,280 --> 00:05:44,639
really powerful compared to other

00:05:42,720 --> 00:05:46,400
languages we've used yeah and we really

00:05:44,639 --> 00:05:48,080
found that we were misusing traits

00:05:46,400 --> 00:05:49,039
originally that we were thinking of

00:05:48,080 --> 00:05:52,479
traits more like

00:05:49,039 --> 00:05:53,919
go interfaces or java interfaces and

00:05:52,479 --> 00:05:55,680
taylor put this one up here because i

00:05:53,919 --> 00:05:57,120
think this was representative of sort of

00:05:55,680 --> 00:05:59,280
his aha moment

00:05:57,120 --> 00:06:00,800
that traits were far more powerful if

00:05:59,280 --> 00:06:02,319
you thought about them from the rust

00:06:00,800 --> 00:06:03,759
perspective instead of some of these

00:06:02,319 --> 00:06:05,199
others

00:06:03,759 --> 00:06:07,280
and another feature that we've really

00:06:05,199 --> 00:06:08,800
liked that that took us

00:06:07,280 --> 00:06:11,520
you know more than a few moments to

00:06:08,800 --> 00:06:13,039
realize how powerful it was was uh enums

00:06:11,520 --> 00:06:15,680
and here we've got an example from

00:06:13,039 --> 00:06:17,199
error handling and enums yeah now this

00:06:15,680 --> 00:06:17,520
error handling i always have people ask

00:06:17,199 --> 00:06:19,600
well

00:06:17,520 --> 00:06:21,360
why don't you use just this error crate

00:06:19,600 --> 00:06:21,840
this is actually using this error crate

00:06:21,360 --> 00:06:23,840
i just

00:06:21,840 --> 00:06:25,280
it's already fat and big so i didn't

00:06:23,840 --> 00:06:27,520
want to include any more

00:06:25,280 --> 00:06:29,199
but using some of the other crates and

00:06:27,520 --> 00:06:31,039
just leveraging these enums

00:06:29,199 --> 00:06:32,400
allow for really really expressive

00:06:31,039 --> 00:06:34,000
errors and so

00:06:32,400 --> 00:06:36,000
they're not just like single values but

00:06:34,000 --> 00:06:37,520
they can carry associated data so

00:06:36,000 --> 00:06:39,600
each variant can have different data

00:06:37,520 --> 00:06:41,520
structures like a discriminated union

00:06:39,600 --> 00:06:42,800
and then you can work with these using

00:06:41,520 --> 00:06:44,400
pattern matching so this pattern

00:06:42,800 --> 00:06:46,240
matching is

00:06:44,400 --> 00:06:48,000
converting some types over for us in our

00:06:46,240 --> 00:06:49,680
real code and so we're able

00:06:48,000 --> 00:06:51,520
to make sure that we handle every single

00:06:49,680 --> 00:06:53,919
kind and get the data out

00:06:51,520 --> 00:06:55,280
all in one beautiful statement i mean

00:06:53,919 --> 00:06:56,319
you can read this coming from any

00:06:55,280 --> 00:06:58,800
language

00:06:56,319 --> 00:07:00,080
um that you and you'll go like oh i see

00:06:58,800 --> 00:07:01,360
what this is doing like

00:07:00,080 --> 00:07:03,039
you might go what's this unwrapper

00:07:01,360 --> 00:07:04,639
default or what's this like some of it

00:07:03,039 --> 00:07:06,560
might be weird but like the basic

00:07:04,639 --> 00:07:09,120
structure of what it's doing

00:07:06,560 --> 00:07:10,479
is really really um elegant and powerful

00:07:09,120 --> 00:07:12,319
and we see this

00:07:10,479 --> 00:07:14,560
um all over the place we've just kind of

00:07:12,319 --> 00:07:16,080
like matt said had this aha moment like

00:07:14,560 --> 00:07:19,199
wow like you can use these

00:07:16,080 --> 00:07:21,120
for some amazing uh cases in particular

00:07:19,199 --> 00:07:24,160
errors

00:07:21,120 --> 00:07:26,639
now macros uh let's just say we

00:07:24,160 --> 00:07:28,240
we absolutely love macros now they

00:07:26,639 --> 00:07:29,199
writing them can be a little finicky but

00:07:28,240 --> 00:07:30,880
we're not going to worry about that

00:07:29,199 --> 00:07:32,560
right now just be aware

00:07:30,880 --> 00:07:34,800
that that happens we've learned that

00:07:32,560 --> 00:07:38,479
quite a bit but

00:07:34,800 --> 00:07:39,919
macros are great for cloud development

00:07:38,479 --> 00:07:41,680
because there's so many times we're

00:07:39,919 --> 00:07:43,280
consuming external apis so

00:07:41,680 --> 00:07:44,800
seeing that this is a kubernetes

00:07:43,280 --> 00:07:46,800
adjacent event right now you probably

00:07:44,800 --> 00:07:48,000
know what a crd is if not it's a custom

00:07:46,800 --> 00:07:51,120
resource definition

00:07:48,000 --> 00:07:53,039
a hook into the kubernetes api in go

00:07:51,120 --> 00:07:54,319
even with all these other libraries that

00:07:53,039 --> 00:07:56,879
people have generated

00:07:54,319 --> 00:07:58,000
you still have to auto generate code and

00:07:56,879 --> 00:08:00,160
commit code

00:07:58,000 --> 00:08:01,199
and have all these different things to

00:08:00,160 --> 00:08:03,919
make it work

00:08:01,199 --> 00:08:05,280
here literally i have the data i care

00:08:03,919 --> 00:08:07,440
about specified

00:08:05,280 --> 00:08:09,919
and then i can derive custom resource

00:08:07,440 --> 00:08:11,680
and pass it basically some configuration

00:08:09,919 --> 00:08:13,919
and i automatically when the thing's

00:08:11,680 --> 00:08:16,000
built that code expands

00:08:13,919 --> 00:08:17,520
out to all the code needed implement i

00:08:16,000 --> 00:08:19,840
don't have to commit anything

00:08:17,520 --> 00:08:20,800
it builds it correctly every time you

00:08:19,840 --> 00:08:22,479
can also see this

00:08:20,800 --> 00:08:24,639
inheriting no i'm not inheriting that's

00:08:22,479 --> 00:08:26,720
the wrong word in rest but taking and

00:08:24,639 --> 00:08:28,720
deriving a json schema so we're

00:08:26,720 --> 00:08:29,440
attaching a whole json schema to this

00:08:28,720 --> 00:08:32,560
object

00:08:29,440 --> 00:08:35,360
basically for free so this we as a matt

00:08:32,560 --> 00:08:37,760
and i were talking over this code sample

00:08:35,360 --> 00:08:39,200
we realized that this block of code in

00:08:37,760 --> 00:08:40,320
go where you would generally write

00:08:39,200 --> 00:08:43,200
something like this

00:08:40,320 --> 00:08:43,760
is probably at least 200 lines if not

00:08:43,200 --> 00:08:45,920
more

00:08:43,760 --> 00:08:47,760
and a lot of it is just committed or

00:08:45,920 --> 00:08:51,440
auto updated code and this is

00:08:47,760 --> 00:08:53,920
10. that is so powerful we're deriving

00:08:51,440 --> 00:08:56,240
serialization deserialization and macros

00:08:53,920 --> 00:08:57,680
all do that for you for free

00:08:56,240 --> 00:08:59,200
yeah and all the things that are being

00:08:57,680 --> 00:09:00,880
hidden from you here are things that we

00:08:59,200 --> 00:09:02,320
don't really as developers care all that

00:09:00,880 --> 00:09:04,320
much about it's what would normally be

00:09:02,320 --> 00:09:06,000
boilerplate code

00:09:04,320 --> 00:09:07,600
another thing we really have enjoyed

00:09:06,000 --> 00:09:09,680
when it comes to reducing the number of

00:09:07,600 --> 00:09:11,360
lines of code that you have to write

00:09:09,680 --> 00:09:13,200
is the way you can do error handling in

00:09:11,360 --> 00:09:15,680
the way you do iterators

00:09:13,200 --> 00:09:17,600
in rust uh again this this particular

00:09:15,680 --> 00:09:19,760
example probably would be

00:09:17,600 --> 00:09:20,800
uh two three four hundred lines of go

00:09:19,760 --> 00:09:23,760
code with lots of

00:09:20,800 --> 00:09:25,200
with the the uh cyclomatic complexity of

00:09:23,760 --> 00:09:26,800
it would have been fairly deep because

00:09:25,200 --> 00:09:29,279
you'd have a lot of nested ifs

00:09:26,800 --> 00:09:31,519
and a lot of nested loops and it's just

00:09:29,279 --> 00:09:33,839
so elegant to look at code like this and

00:09:31,519 --> 00:09:36,000
see everything sort of laid out laid out

00:09:33,839 --> 00:09:37,519
linearly and again we find the

00:09:36,000 --> 00:09:39,600
readability of this to be

00:09:37,519 --> 00:09:41,600
very high i remember taylor i don't

00:09:39,600 --> 00:09:45,279
think you liked this style at first

00:09:41,600 --> 00:09:46,720
uh has that changed i i still it's

00:09:45,279 --> 00:09:48,240
sometimes can be a little bit hard to

00:09:46,720 --> 00:09:49,440
read especially with these kinds of

00:09:48,240 --> 00:09:51,519
examples but

00:09:49,440 --> 00:09:53,120
i have come around to really liking how

00:09:51,519 --> 00:09:54,560
some like just some of the magic that

00:09:53,120 --> 00:09:57,120
happens here because

00:09:54,560 --> 00:09:58,000
this example in particular is doing a

00:09:57,120 --> 00:10:01,040
whole

00:09:58,000 --> 00:10:04,560
fanout fan in asynchronous

00:10:01,040 --> 00:10:07,519
compute task in 20 lines of code

00:10:04,560 --> 00:10:08,480
uh so that is that is really cool to see

00:10:07,519 --> 00:10:11,760
that happen

00:10:08,480 --> 00:10:13,680
um and so i know that it can be a little

00:10:11,760 --> 00:10:15,360
hard to read coming in but like once you

00:10:13,680 --> 00:10:18,399
see how it's working it starts becoming

00:10:15,360 --> 00:10:21,279
a lot clearer

00:10:18,399 --> 00:10:21,680
now dependency management okay this is

00:10:21,279 --> 00:10:23,839
where

00:10:21,680 --> 00:10:24,880
we are this is a very high on our impre

00:10:23,839 --> 00:10:27,440
on our very uh

00:10:24,880 --> 00:10:29,360
impressive uh list of rust features and

00:10:27,440 --> 00:10:32,480
we're gonna have to make a confession

00:10:29,360 --> 00:10:35,519
we pretty much love cargo like

00:10:32,480 --> 00:10:37,440
love it uh it is flexible it tells you

00:10:35,519 --> 00:10:38,560
exactly what's wrong when a version

00:10:37,440 --> 00:10:40,800
can't resolve

00:10:38,560 --> 00:10:42,079
and it really it's another thing that

00:10:40,800 --> 00:10:43,600
where we feel like it's completely

00:10:42,079 --> 00:10:44,560
changed how we look at dependency

00:10:43,600 --> 00:10:46,320
management

00:10:44,560 --> 00:10:48,079
and this just shows some examples here

00:10:46,320 --> 00:10:48,959
but you can patch in dependencies from

00:10:48,079 --> 00:10:51,519
other places

00:10:48,959 --> 00:10:53,279
and these four show four different ways

00:10:51,519 --> 00:10:54,640
you can do stuff so in the top example

00:10:53,279 --> 00:10:56,800
we're pulling in

00:10:54,640 --> 00:10:58,880
only a very small portion of basically

00:10:56,800 --> 00:11:01,040
what's a big auto-generated open api

00:10:58,880 --> 00:11:02,399
spec and we're just pulling in exactly

00:11:01,040 --> 00:11:04,480
what we need we're not pulling in

00:11:02,399 --> 00:11:06,560
this massive code base and compiling it

00:11:04,480 --> 00:11:09,279
all in with uh the struct

00:11:06,560 --> 00:11:10,880
with struct opt we expose and cresla an

00:11:09,279 --> 00:11:12,240
optional command line flag which is

00:11:10,880 --> 00:11:14,560
what's shown below

00:11:12,240 --> 00:11:16,240
if a user specifies it it downloads all

00:11:14,560 --> 00:11:17,760
the command line management stuff and

00:11:16,240 --> 00:11:18,160
all these other structs arranging the

00:11:17,760 --> 00:11:19,760
ops

00:11:18,160 --> 00:11:22,000
but if you're not and you don't want to

00:11:19,760 --> 00:11:23,600
use a command line tool for it

00:11:22,000 --> 00:11:25,360
you don't have to include it the

00:11:23,600 --> 00:11:27,760
dependency doesn't get pulled down

00:11:25,360 --> 00:11:29,519
the structs don't get compiled in which

00:11:27,760 --> 00:11:30,560
is amazing and then you can also do

00:11:29,519 --> 00:11:32,160
stuff like the bottom where you're

00:11:30,560 --> 00:11:33,519
pointing to a local path

00:11:32,160 --> 00:11:35,680
so when you're local it's going to use a

00:11:33,519 --> 00:11:36,480
local path but when you push it up into

00:11:35,680 --> 00:11:39,600
crates

00:11:36,480 --> 00:11:41,200
it uses the proper version so i mean

00:11:39,600 --> 00:11:43,360
these are just two examples but we

00:11:41,200 --> 00:11:45,920
love cargo and this is coming from

00:11:43,360 --> 00:11:47,120
people we have both worked on multiple

00:11:45,920 --> 00:11:49,600
dependency management

00:11:47,120 --> 00:11:50,720
and and package management systems like

00:11:49,600 --> 00:11:52,880
helm and cnab and

00:11:50,720 --> 00:11:55,200
and glide and things like that and we

00:11:52,880 --> 00:11:56,880
just we look at cargo and we're like ah

00:11:55,200 --> 00:11:58,240
well this is just better than all of

00:11:56,880 --> 00:11:59,680
those things that we wrote

00:11:58,240 --> 00:12:01,360
but i think the last thing we really

00:11:59,680 --> 00:12:02,720
wanted to highlight in the good one is

00:12:01,360 --> 00:12:05,440
the community we found

00:12:02,720 --> 00:12:06,959
the rest community to be very open very

00:12:05,440 --> 00:12:09,600
easy to work with uh

00:12:06,959 --> 00:12:12,320
kind of exuberant about collaboration

00:12:09,600 --> 00:12:14,320
and improving the ecosystem in sort of a

00:12:12,320 --> 00:12:16,000
deliberate rational and also

00:12:14,320 --> 00:12:18,240
good-hearted way

00:12:16,000 --> 00:12:19,360
uh and while we don't anything else you

00:12:18,240 --> 00:12:22,560
want to add to that before we go

00:12:19,360 --> 00:12:24,639
no not not really that that covers it uh

00:12:22,560 --> 00:12:26,560
we do want to be honest and talk about

00:12:24,639 --> 00:12:27,760
the bad and the ugly so we'll dive into

00:12:26,560 --> 00:12:29,519
this section which

00:12:27,760 --> 00:12:31,279
admittedly is shorter and some of these

00:12:29,519 --> 00:12:33,279
things might surprise you others of them

00:12:31,279 --> 00:12:35,200
i doubt they will

00:12:33,279 --> 00:12:36,959
yeah so let's start off with dachshund

00:12:35,200 --> 00:12:38,000
clarity this is an interesting one that

00:12:36,959 --> 00:12:39,839
people go like oh

00:12:38,000 --> 00:12:41,600
i didn't really think about that so a

00:12:39,839 --> 00:12:42,800
pattern that we've seen in lots of great

00:12:41,600 --> 00:12:44,240
documentation

00:12:42,800 --> 00:12:45,760
um that's something to really be aware

00:12:44,240 --> 00:12:47,360
of as you consume things especially if

00:12:45,760 --> 00:12:48,639
you're new to rust and especially rust

00:12:47,360 --> 00:12:50,560
with cloud nano development

00:12:48,639 --> 00:12:52,800
is that the docks are sometimes very

00:12:50,560 --> 00:12:54,000
unclear about what is happening in the

00:12:52,800 --> 00:12:55,360
actual code they describe the

00:12:54,000 --> 00:12:56,800
functionality well but then you have to

00:12:55,360 --> 00:12:58,959
go digging through the code to find out

00:12:56,800 --> 00:13:00,800
whether it is a zero cost abstraction

00:12:58,959 --> 00:13:02,560
or if there's side effects so like is

00:13:00,800 --> 00:13:03,920
something flushing a file

00:13:02,560 --> 00:13:05,279
oftentimes it doesn't tell you and i

00:13:03,920 --> 00:13:06,560
have to go down on the code and figure

00:13:05,279 --> 00:13:08,240
out what's going on but you also get

00:13:06,560 --> 00:13:09,920
what's displayed here

00:13:08,240 --> 00:13:11,360
so this is something from the tonic

00:13:09,920 --> 00:13:12,320
crate which i'll talk a little about a

00:13:11,360 --> 00:13:14,800
little bit later

00:13:12,320 --> 00:13:16,560
and as a new developer when you come in

00:13:14,800 --> 00:13:17,279
and you see this code you just go what

00:13:16,560 --> 00:13:19,519
is going

00:13:17,279 --> 00:13:20,959
on here and you like click through well

00:13:19,519 --> 00:13:23,120
what's this make connection

00:13:20,959 --> 00:13:24,880
and it's like linking to another trait

00:13:23,120 --> 00:13:26,240
in another crate which links to two more

00:13:24,880 --> 00:13:28,079
traits and another crate

00:13:26,240 --> 00:13:29,760
and you're like whoa like what am i

00:13:28,079 --> 00:13:31,440
supposed to implement here turns out all

00:13:29,760 --> 00:13:33,360
we needed was the little code snippet

00:13:31,440 --> 00:13:36,240
below which is quite simple

00:13:33,360 --> 00:13:37,760
but um what had happened is there was an

00:13:36,240 --> 00:13:40,800
example in the examples

00:13:37,760 --> 00:13:42,480
directory of the of the actual repo

00:13:40,800 --> 00:13:43,920
but the first thought wasn't to go look

00:13:42,480 --> 00:13:45,760
there now granted this is before they

00:13:43,920 --> 00:13:47,279
change they've updated these docs and it

00:13:45,760 --> 00:13:48,399
points to that new example and it's

00:13:47,279 --> 00:13:51,040
great but

00:13:48,399 --> 00:13:52,639
this is something we saw quite a bit of

00:13:51,040 --> 00:13:54,639
as we started things so just remember to

00:13:52,639 --> 00:13:56,240
keep your docs clear as you write stuff

00:13:54,639 --> 00:13:57,680
and be aware that you might have to dig

00:13:56,240 --> 00:13:58,560
a little bit to understand what this is

00:13:57,680 --> 00:14:01,760
asking

00:13:58,560 --> 00:14:03,199
um you to implement yeah and we'll go a

00:14:01,760 --> 00:14:04,160
little bit faster through the remainder

00:14:03,199 --> 00:14:05,760
of the bad and

00:14:04,160 --> 00:14:07,199
ugly section so we can get to some of

00:14:05,760 --> 00:14:09,279
the more exciting stuff

00:14:07,199 --> 00:14:11,199
um but one of the things we did run into

00:14:09,279 --> 00:14:13,279
is that a lot of times

00:14:11,199 --> 00:14:15,360
uh when you're in a new ecosystem you

00:14:13,279 --> 00:14:17,040
have to write more code yourself

00:14:15,360 --> 00:14:18,800
there are many crates out there already

00:14:17,040 --> 00:14:19,920
but sometimes we just don't find the

00:14:18,800 --> 00:14:21,839
things we need and we have to

00:14:19,920 --> 00:14:24,320
re-implement them either to glue

00:14:21,839 --> 00:14:25,839
different crates together or to to

00:14:24,320 --> 00:14:27,839
provide an implementation that simply

00:14:25,839 --> 00:14:31,120
doesn't exist

00:14:27,839 --> 00:14:32,160
yeah for example here grpc on windows uh

00:14:31,120 --> 00:14:34,000
not jrpci

00:14:32,160 --> 00:14:36,000
sockets on windows so we're just gonna

00:14:34,000 --> 00:14:38,240
skip over that unholy code

00:14:36,000 --> 00:14:39,519
and talk about the learning curve uh the

00:14:38,240 --> 00:14:41,120
learning curve is something that people

00:14:39,519 --> 00:14:42,480
often mention but what we want to point

00:14:41,120 --> 00:14:44,639
out is actually the learning curve

00:14:42,480 --> 00:14:45,920
it is logarithmic it just has a very

00:14:44,639 --> 00:14:47,360
steep initial curve

00:14:45,920 --> 00:14:49,040
and it flattens out but there's one

00:14:47,360 --> 00:14:49,360
other little bump we ran into and that

00:14:49,040 --> 00:14:51,600
is

00:14:49,360 --> 00:14:53,120
how to design proper apis so that first

00:14:51,600 --> 00:14:54,639
example with traits was you with using

00:14:53,120 --> 00:14:56,320
try into

00:14:54,639 --> 00:14:58,160
that was when i finally got it but it

00:14:56,320 --> 00:14:58,399
took a lot of looking at other crates

00:14:58,160 --> 00:15:00,240
and

00:14:58,399 --> 00:15:03,040
understanding what was going on about

00:15:00,240 --> 00:15:05,279
what makes a good and flexible rest api

00:15:03,040 --> 00:15:07,040
when you design them users love them but

00:15:05,279 --> 00:15:08,320
sometimes getting there is a bit of a

00:15:07,040 --> 00:15:10,560
hiccup

00:15:08,320 --> 00:15:13,680
so with that let's go into the ugly

00:15:10,560 --> 00:15:14,399
which is just one thing it's async now

00:15:13,680 --> 00:15:16,000
to be clear

00:15:14,399 --> 00:15:17,360
i don't want this is not bashing on

00:15:16,000 --> 00:15:18,880
anything i have worked with these people

00:15:17,360 --> 00:15:20,560
i've talked to these people

00:15:18,880 --> 00:15:22,399
um they've started a working group this

00:15:20,560 --> 00:15:24,079
is not that i'm just pointing out

00:15:22,399 --> 00:15:26,240
what you're going to run into in the

00:15:24,079 --> 00:15:26,639
cloud native space and the first off is

00:15:26,240 --> 00:15:28,480
this

00:15:26,639 --> 00:15:29,920
competing and incompatible runtime so

00:15:28,480 --> 00:15:33,040
you have multiple runtimes

00:15:29,920 --> 00:15:34,079
tokyo async standard small and it's

00:15:33,040 --> 00:15:36,800
possible to

00:15:34,079 --> 00:15:38,880
um use interchangeable ones but a lot of

00:15:36,800 --> 00:15:40,880
times once you buy into a stack

00:15:38,880 --> 00:15:42,399
you're kind of stuck there and you have

00:15:40,880 --> 00:15:44,240
a little bit of lock-in it's not perfect

00:15:42,399 --> 00:15:45,759
and it depends on what you're doing

00:15:44,240 --> 00:15:48,240
um sometimes there's shim layers that

00:15:45,759 --> 00:15:51,120
you can add in but just keep that aware

00:15:48,240 --> 00:15:52,560
um here we have our ugly code uh i hope

00:15:51,120 --> 00:15:53,839
these code examples show exactly what

00:15:52,560 --> 00:15:54,320
we're talking about but there's so many

00:15:53,839 --> 00:15:56,639
chained

00:15:54,320 --> 00:15:58,800
calls and that one on the left was one

00:15:56,639 --> 00:16:00,000
that we called move clone move clone

00:15:58,800 --> 00:16:01,759
move clone with clone

00:16:00,000 --> 00:16:03,519
because i mean we know exactly where the

00:16:01,759 --> 00:16:05,199
date is going but to make rest happy we

00:16:03,519 --> 00:16:06,959
had to move something then clone it

00:16:05,199 --> 00:16:08,880
then move it again then clone it then

00:16:06,959 --> 00:16:10,000
move it again to make it so that it was

00:16:08,880 --> 00:16:13,199
all in the right place

00:16:10,000 --> 00:16:15,920
and again all this in context of async

00:16:13,199 --> 00:16:17,120
right yes all this is async related to

00:16:15,920 --> 00:16:19,680
async this is not

00:16:17,120 --> 00:16:21,040
outside of async this doesn't happen but

00:16:19,680 --> 00:16:22,720
something to be aware of and then that

00:16:21,040 --> 00:16:25,120
also adds some craft and bloat where

00:16:22,720 --> 00:16:27,199
you're re-implementing async

00:16:25,120 --> 00:16:28,959
methods for a type that's already async

00:16:27,199 --> 00:16:30,800
i would be rich if i had money for every

00:16:28,959 --> 00:16:32,560
single time i had to re-implement async

00:16:30,800 --> 00:16:33,440
read or write for a type that's async

00:16:32,560 --> 00:16:36,320
underneath the hood

00:16:33,440 --> 00:16:37,920
but it's constantly getting better so

00:16:36,320 --> 00:16:40,000
for this last part of our presentation

00:16:37,920 --> 00:16:42,320
we wanted to switch and focus on

00:16:40,000 --> 00:16:44,639
uh sort of what happened when we decided

00:16:42,320 --> 00:16:46,560
we wanted to build this project crestlet

00:16:44,639 --> 00:16:47,920
it was going to be a kubernetes kubelet

00:16:46,560 --> 00:16:50,560
written in rust

00:16:47,920 --> 00:16:52,240
uh and kind of walk you through uh the

00:16:50,560 --> 00:16:54,079
initial stages and then some of the

00:16:52,240 --> 00:16:54,480
things that caused us to have to really

00:16:54,079 --> 00:16:57,519
dive

00:16:54,480 --> 00:16:59,920
deeply into the the under the

00:16:57,519 --> 00:17:01,839
underbelly of kubernetes and how rust

00:16:59,920 --> 00:17:03,519
really has ended up making this

00:17:01,839 --> 00:17:05,360
a sort of i don't know if i'd call it a

00:17:03,519 --> 00:17:06,559
pleasurable experience but definitely

00:17:05,360 --> 00:17:08,880
one that was

00:17:06,559 --> 00:17:10,640
manageable by a little small team like

00:17:08,880 --> 00:17:12,319
ours that didn't require

00:17:10,640 --> 00:17:14,400
hundreds of engineers to be able to sort

00:17:12,319 --> 00:17:16,000
it out when we first wrote crestlet we

00:17:14,400 --> 00:17:18,799
wrote a proof of concept

00:17:16,000 --> 00:17:20,640
and the proof of concept was maybe a few

00:17:18,799 --> 00:17:22,720
hundred lines of code that was all it

00:17:20,640 --> 00:17:24,959
took us to be able to take a very basic

00:17:22,720 --> 00:17:27,439
pod definition from kubernetes

00:17:24,959 --> 00:17:29,039
start up a web assembly runtime and

00:17:27,439 --> 00:17:30,720
report back to kubernetes yeah we're

00:17:29,039 --> 00:17:31,360
running this thing here's the output of

00:17:30,720 --> 00:17:33,600
it

00:17:31,360 --> 00:17:35,600
uh and and so the proof of concept went

00:17:33,600 --> 00:17:36,880
well and was deceptively simple because

00:17:35,600 --> 00:17:38,400
we went oh yeah

00:17:36,880 --> 00:17:40,000
from here we got it we're going to move

00:17:38,400 --> 00:17:41,760
on to a minimum viable product we're

00:17:40,000 --> 00:17:44,240
going to get this thing to a 1.0 that

00:17:41,760 --> 00:17:47,280
people can actually use in production

00:17:44,240 --> 00:17:47,840
and then it wasn't easy yeah it really

00:17:47,280 --> 00:17:50,000
wasn't

00:17:47,840 --> 00:17:51,440
um so this is just kind of a list i

00:17:50,000 --> 00:17:52,160
don't think it's even a complete list

00:17:51,440 --> 00:17:54,080
but it's close

00:17:52,160 --> 00:17:55,520
of all like the worst things we ran into

00:17:54,080 --> 00:17:57,520
to try to figure out

00:17:55,520 --> 00:17:58,720
um we had to figure out the grpc plug-in

00:17:57,520 --> 00:17:59,919
system

00:17:58,720 --> 00:18:02,240
we had to figure out how to make state

00:17:59,919 --> 00:18:04,160
machines and controllers work in rust

00:18:02,240 --> 00:18:05,679
um there's also the idea of how how does

00:18:04,160 --> 00:18:07,200
bootstrapping work underneath the hood

00:18:05,679 --> 00:18:08,240
like what's the proper way to do it and

00:18:07,200 --> 00:18:10,080
exchange it and

00:18:08,240 --> 00:18:12,080
do it properly there's things about how

00:18:10,080 --> 00:18:14,720
do we handle oci image pulling

00:18:12,080 --> 00:18:16,160
um what's the what's the api that is

00:18:14,720 --> 00:18:17,760
expected of kubelet

00:18:16,160 --> 00:18:19,600
um for kubernetes and then like the

00:18:17,760 --> 00:18:21,120
various kubernetes subsystems volume

00:18:19,600 --> 00:18:22,240
mounting networking what are we supposed

00:18:21,120 --> 00:18:25,039
to do like all this

00:18:22,240 --> 00:18:25,919
became very very hard so let's dive into

00:18:25,039 --> 00:18:28,720
that a bit

00:18:25,919 --> 00:18:30,000
uh first off oci image poles this is

00:18:28,720 --> 00:18:31,600
just something where

00:18:30,000 --> 00:18:33,039
um like we mentioned there's some gaps

00:18:31,600 --> 00:18:35,280
in the system sometimes

00:18:33,039 --> 00:18:36,640
and so you just out here on the frontier

00:18:35,280 --> 00:18:39,039
have to do it yourself so

00:18:36,640 --> 00:18:39,679
we re-impartially re-implemented the oci

00:18:39,039 --> 00:18:42,960
spec

00:18:39,679 --> 00:18:44,000
to be able to pull modules because we

00:18:42,960 --> 00:18:46,559
assume that even for

00:18:44,000 --> 00:18:48,240
our wasm modules that we're using here

00:18:46,559 --> 00:18:50,400
we assume they'd be stored in an oci

00:18:48,240 --> 00:18:54,559
registry just like a container would

00:18:50,400 --> 00:18:56,080
yep now the api contract

00:18:54,559 --> 00:18:57,520
this was interesting because there's no

00:18:56,080 --> 00:18:59,600
documentation here which makes sense

00:18:57,520 --> 00:19:02,000
it's not really like a public api many

00:18:59,600 --> 00:19:03,440
people consume but it turns out there's

00:19:02,000 --> 00:19:04,559
two parts here so

00:19:03,440 --> 00:19:06,400
if you're interested in the underlying

00:19:04,559 --> 00:19:08,160
internals this is a great slide to go

00:19:06,400 --> 00:19:09,760
reference later but

00:19:08,160 --> 00:19:11,760
there's these three end points that we

00:19:09,760 --> 00:19:14,480
see um and then

00:19:11,760 --> 00:19:16,400
uh there's also the duties of the kublet

00:19:14,480 --> 00:19:18,480
itself which is watching for new pods

00:19:16,400 --> 00:19:19,840
handle the entire pod life cycle

00:19:18,480 --> 00:19:21,360
and resource management and then

00:19:19,840 --> 00:19:23,280
updating the node status and heartbeat

00:19:21,360 --> 00:19:25,919
so let's go into some code things

00:19:23,280 --> 00:19:27,440
that are right here that matt already

00:19:25,919 --> 00:19:29,679
clear here it's not necessarily

00:19:27,440 --> 00:19:31,679
documented what the duties are

00:19:29,679 --> 00:19:33,919
given the api endpoints so a lot of this

00:19:31,679 --> 00:19:35,600
is going okay given this information

00:19:33,919 --> 00:19:37,280
what are we gonna do and that's really

00:19:35,600 --> 00:19:38,559
where a lot of this code sort of came

00:19:37,280 --> 00:19:40,240
from

00:19:38,559 --> 00:19:42,000
yeah and we can see actually some of the

00:19:40,240 --> 00:19:44,720
power of rest here so

00:19:42,000 --> 00:19:45,760
right in this example we see first off

00:19:44,720 --> 00:19:47,760
why generics

00:19:45,760 --> 00:19:48,880
especially rust generic trade system are

00:19:47,760 --> 00:19:51,200
so useful

00:19:48,880 --> 00:19:53,440
we are allowing this to do a client

00:19:51,200 --> 00:19:55,200
that's a using the wonderful tube crate

00:19:53,440 --> 00:19:57,120
which is the basically the official rest

00:19:55,200 --> 00:19:59,679
client for go for for go wow

00:19:57,120 --> 00:20:00,640
the official rest client for kubernetes

00:19:59,679 --> 00:20:04,559
just like you have the

00:20:00,640 --> 00:20:07,039
client go um and in here you can see it

00:20:04,559 --> 00:20:08,480
it doesn't matter what type this is this

00:20:07,039 --> 00:20:10,240
actually underlying type doesn't matter

00:20:08,480 --> 00:20:11,440
if it's a pod or a custom resource or

00:20:10,240 --> 00:20:12,880
whatever as long as it implements a

00:20:11,440 --> 00:20:16,400
kubernetes definition

00:20:12,880 --> 00:20:18,480
this this code will work but it also

00:20:16,400 --> 00:20:20,000
um has the matching and unwrapping that

00:20:18,480 --> 00:20:21,360
we love that we talked about as well and

00:20:20,000 --> 00:20:23,760
you'll see if inside we're going to now

00:20:21,360 --> 00:20:26,000
dive into the handle event

00:20:23,760 --> 00:20:26,880
thing where it actually is is easy there

00:20:26,000 --> 00:20:29,679
as well

00:20:26,880 --> 00:20:30,960
um what we did have to do here and

00:20:29,679 --> 00:20:32,320
something to be aware of especially with

00:20:30,960 --> 00:20:32,880
kubernetes and probably a lot of other

00:20:32,320 --> 00:20:34,880
systems

00:20:32,880 --> 00:20:36,320
is we had to plumb the events through

00:20:34,880 --> 00:20:37,440
into our own system so getting the

00:20:36,320 --> 00:20:38,880
events and starting

00:20:37,440 --> 00:20:40,720
essentially a reflector if you're

00:20:38,880 --> 00:20:42,320
familiar with kubernetes

00:20:40,720 --> 00:20:43,679
was really easy like it was just that

00:20:42,320 --> 00:20:45,280
little snippet of code but then we had

00:20:43,679 --> 00:20:47,440
to do the plumbing to kind of

00:20:45,280 --> 00:20:49,200
handle those events properly but russ

00:20:47,440 --> 00:20:50,799
still makes that easy because an event

00:20:49,200 --> 00:20:52,080
is expressed as an enum which we

00:20:50,799 --> 00:20:52,880
mentioned before and so this shows how

00:20:52,080 --> 00:20:56,480
we handle

00:20:52,880 --> 00:21:00,080
resyncs shutdowns and event dispatching

00:20:56,480 --> 00:21:02,640
all in a fairly concise function

00:21:00,080 --> 00:21:04,240
lastly we have our patch status stuff so

00:21:02,640 --> 00:21:06,960
patching so this is how we patch

00:21:04,240 --> 00:21:08,000
um i guess there's we also have to talk

00:21:06,960 --> 00:21:09,760
about node but for the

00:21:08,000 --> 00:21:11,600
for the actual managing the life cycle

00:21:09,760 --> 00:21:13,840
of things you have to patch

00:21:11,600 --> 00:21:14,960
the status of the pod now we're

00:21:13,840 --> 00:21:17,039
leveraging the awesome

00:21:14,960 --> 00:21:19,760
cube crate again that allows us to do

00:21:17,039 --> 00:21:21,440
this patch status operation

00:21:19,760 --> 00:21:23,120
with pretty much an easy thing we're

00:21:21,440 --> 00:21:25,600
just able to get out an api

00:21:23,120 --> 00:21:27,679
um client and then we're able to talk to

00:21:25,600 --> 00:21:29,679
it and then unwrap that error

00:21:27,679 --> 00:21:31,600
but one thing to know is that patching

00:21:29,679 --> 00:21:32,400
utilities for pods are non-existent and

00:21:31,600 --> 00:21:34,000
we

00:21:32,400 --> 00:21:36,080
had to write our own which that json

00:21:34,000 --> 00:21:39,760
patch method is what's in our next

00:21:36,080 --> 00:21:41,200
slide is that we have we had to manually

00:21:39,760 --> 00:21:44,080
assemble

00:21:41,200 --> 00:21:44,640
the patch now this is easier for custom

00:21:44,080 --> 00:21:45,919
types

00:21:44,640 --> 00:21:47,600
but we had to put the whole thing

00:21:45,919 --> 00:21:48,240
together so something to be aware of is

00:21:47,600 --> 00:21:50,159
that

00:21:48,240 --> 00:21:52,400
uh you don't have those json patching

00:21:50,159 --> 00:21:54,559
methods that come kind of built in with

00:21:52,400 --> 00:21:56,159
some of the extended kubernetes

00:21:54,559 --> 00:21:57,039
libraries and go so just be aware of

00:21:56,159 --> 00:21:58,320
that when you're doing anything

00:21:57,039 --> 00:21:59,679
kubernetes or really anything in the

00:21:58,320 --> 00:22:00,640
cloud is that you might have to do some

00:21:59,679 --> 00:22:03,039
plumbing work

00:22:00,640 --> 00:22:04,000
just like here and to finish up we're

00:22:03,039 --> 00:22:05,600
going to leave what each of the

00:22:04,000 --> 00:22:06,640
functions do inside of here but in case

00:22:05,600 --> 00:22:08,640
you're curious

00:22:06,640 --> 00:22:10,240
what happens with a node is that you

00:22:08,640 --> 00:22:11,760
update the lease and you have to update

00:22:10,240 --> 00:22:12,480
the status there's two things that you

00:22:11,760 --> 00:22:15,120
do

00:22:12,480 --> 00:22:16,720
to keep it uh keep it registered with

00:22:15,120 --> 00:22:17,440
the kubernetes cluster and all this we

00:22:16,720 --> 00:22:18,960
kind of had to go

00:22:17,440 --> 00:22:20,720
figure out okay well how long does it

00:22:18,960 --> 00:22:22,559
expect like when is it expected to be

00:22:20,720 --> 00:22:24,720
updated what's the documentation for

00:22:22,559 --> 00:22:27,360
this object all those things

00:22:24,720 --> 00:22:28,000
another cool use of macros there too uh

00:22:27,360 --> 00:22:32,480
yes where we

00:22:28,000 --> 00:22:32,960
wrote our own so we have the grpc plugin

00:22:32,480 --> 00:22:36,240
system

00:22:32,960 --> 00:22:37,520
uh this here there be monsters i cannot

00:22:36,240 --> 00:22:40,640
stress this enough

00:22:37,520 --> 00:22:43,360
so turns out to be able to um enable

00:22:40,640 --> 00:22:44,080
um oc sorry not ocd that meant to be csi

00:22:43,360 --> 00:22:47,360
support

00:22:44,080 --> 00:22:48,799
they're uh we needed to have some sort

00:22:47,360 --> 00:22:50,720
of plug-in system

00:22:48,799 --> 00:22:52,240
available which matches the one that

00:22:50,720 --> 00:22:53,840
kubernetes expects

00:22:52,240 --> 00:22:55,679
so the plug-in manager there's actually

00:22:53,840 --> 00:22:57,200
two of them if you go look at the code

00:22:55,679 --> 00:22:59,440
underneath the hood

00:22:57,200 --> 00:23:01,039
but one is only for device plugins and

00:22:59,440 --> 00:23:02,400
one handles other ones

00:23:01,039 --> 00:23:04,960
so we implemented one of them that

00:23:02,400 --> 00:23:06,880
handles uh the csi interface

00:23:04,960 --> 00:23:08,559
um there's no way to figure out how this

00:23:06,880 --> 00:23:10,640
works except by reading code

00:23:08,559 --> 00:23:12,240
but what the cool part of all this was

00:23:10,640 --> 00:23:14,240
and you'll see some of it is rust

00:23:12,240 --> 00:23:16,080
shrunk the amount of code needed from

00:23:14,240 --> 00:23:18,080
several thousand i mean this is a gnarly

00:23:16,080 --> 00:23:19,919
thing with interfaces and indirection

00:23:18,080 --> 00:23:21,520
everywhere in the original kubernetes

00:23:19,919 --> 00:23:25,200
thing it's about 800

00:23:21,520 --> 00:23:26,640
with tests 300 without them so

00:23:25,200 --> 00:23:28,559
uh yeah and just so you know

00:23:26,640 --> 00:23:30,080
cross-platform support for sockets is a

00:23:28,559 --> 00:23:31,840
nightmare which will only cover briefly

00:23:30,080 --> 00:23:34,400
but just one dimension

00:23:31,840 --> 00:23:36,000
so this is big i know but if you if you

00:23:34,400 --> 00:23:38,240
see here this is the run this is how

00:23:36,000 --> 00:23:39,120
we start things inside of the plug-in

00:23:38,240 --> 00:23:41,200
manager

00:23:39,120 --> 00:23:42,880
and it watches a configured plug-in

00:23:41,200 --> 00:23:44,159
directory for new sockets to appear and

00:23:42,880 --> 00:23:46,880
when it discovers them

00:23:44,159 --> 00:23:48,320
it tries to register them but we can see

00:23:46,880 --> 00:23:50,159
here some good examples of using

00:23:48,320 --> 00:23:51,120
iterators to run multiple futures at the

00:23:50,159 --> 00:23:53,360
same time again

00:23:51,120 --> 00:23:54,640
and how to consume a stream so we're

00:23:53,360 --> 00:23:56,320
able to just take these

00:23:54,640 --> 00:23:58,400
turn them into an async object that just

00:23:56,320 --> 00:24:00,000
returns something every time it detects

00:23:58,400 --> 00:24:01,600
it

00:24:00,000 --> 00:24:04,000
so there's nothing super crazy here with

00:24:01,600 --> 00:24:05,600
rust but instead of having to

00:24:04,000 --> 00:24:06,960
do all this other channel management

00:24:05,600 --> 00:24:08,559
stuff that you saw on the go one it's

00:24:06,960 --> 00:24:10,320
really concise we shrunk it down to a

00:24:08,559 --> 00:24:13,200
single thing that runs it all

00:24:10,320 --> 00:24:14,799
and then we have this handle create um

00:24:13,200 --> 00:24:16,559
thing that actually does the creation

00:24:14,799 --> 00:24:17,520
when it sees under the creation of a new

00:24:16,559 --> 00:24:20,320
plugin

00:24:17,520 --> 00:24:21,919
and these are the actual steps that are

00:24:20,320 --> 00:24:23,039
performed in case you're curious i tried

00:24:21,919 --> 00:24:24,799
to include some stuff in here that

00:24:23,039 --> 00:24:26,400
people could go back and look at

00:24:24,799 --> 00:24:27,679
when i say as we looked and we created

00:24:26,400 --> 00:24:29,520
these these samples and this is the

00:24:27,679 --> 00:24:31,039
exact process that goes on underneath

00:24:29,520 --> 00:24:32,799
the hood in case you're curious

00:24:31,039 --> 00:24:35,520
but more interestingly in the next slide

00:24:32,799 --> 00:24:38,000
is we have what actually goes on

00:24:35,520 --> 00:24:39,120
um underneath with watching the file

00:24:38,000 --> 00:24:40,799
system so

00:24:39,120 --> 00:24:42,320
this is where things get really exciting

00:24:40,799 --> 00:24:43,760
so this is a demonstration of the

00:24:42,320 --> 00:24:47,200
awesomeness of

00:24:43,760 --> 00:24:49,120
conditional compilation which i mean

00:24:47,200 --> 00:24:51,039
isn't we've we've run into several times

00:24:49,120 --> 00:24:54,559
i think at this point right matt

00:24:51,039 --> 00:24:56,480
yep you know all over the place and

00:24:54,559 --> 00:24:58,400
uh this shows off another useful crate

00:24:56,480 --> 00:24:59,600
called notify and we've also wanted to

00:24:58,400 --> 00:25:00,480
kind of show the crates that we're

00:24:59,600 --> 00:25:01,919
consuming here

00:25:00,480 --> 00:25:03,120
and notify is the thing that tells you

00:25:01,919 --> 00:25:04,799
when something changes on the file

00:25:03,120 --> 00:25:05,760
system it uses the proper underlying

00:25:04,799 --> 00:25:08,400
utilities

00:25:05,760 --> 00:25:10,480
to do it but it's not async by default

00:25:08,400 --> 00:25:12,640
so we had to do some wrapping and

00:25:10,480 --> 00:25:14,080
adaptation into a stream interface that

00:25:12,640 --> 00:25:15,360
receives a result out

00:25:14,080 --> 00:25:17,840
which is what we're doing here but you

00:25:15,360 --> 00:25:20,559
can see that we actually had to do

00:25:17,840 --> 00:25:21,520
a hacky work around for mac os uh it

00:25:20,559 --> 00:25:24,720
turns out that

00:25:21,520 --> 00:25:26,720
the underlying libraries in mac do not

00:25:24,720 --> 00:25:28,000
detect when a socket is created only

00:25:26,720 --> 00:25:29,520
when it's modified

00:25:28,000 --> 00:25:31,760
which i opened a bug for in case you're

00:25:29,520 --> 00:25:33,440
ever curious about that but

00:25:31,760 --> 00:25:34,799
we had to basically write our own hacky

00:25:33,440 --> 00:25:36,159
version for mac

00:25:34,799 --> 00:25:38,159
but now instead of having to include

00:25:36,159 --> 00:25:40,400
that everywhere we have

00:25:38,159 --> 00:25:41,679
specific versions that are called

00:25:40,400 --> 00:25:44,240
depending on

00:25:41,679 --> 00:25:46,159
the um operating system so if it's a mac

00:25:44,240 --> 00:25:48,320
os target it uses the hack

00:25:46,159 --> 00:25:49,840
otherwise it uses the great notify crate

00:25:48,320 --> 00:25:52,559
that gives us all this with

00:25:49,840 --> 00:25:54,960
the proper way and not hacky all right

00:25:52,559 --> 00:25:58,000
now we're up to my very favorite slide

00:25:54,960 --> 00:25:59,520
because this replaces tens of thousands

00:25:58,000 --> 00:26:03,279
of lines of code that's

00:25:59,520 --> 00:26:04,799
auto generated yes we love the build rs

00:26:03,279 --> 00:26:06,320
so one of the things this is first

00:26:04,799 --> 00:26:08,960
i mentioned this earlier about the tonic

00:26:06,320 --> 00:26:11,760
crate so tonic is a grpc library

00:26:08,960 --> 00:26:12,960
for rust if you haven't used it like we

00:26:11,760 --> 00:26:15,360
use grpc

00:26:12,960 --> 00:26:16,720
libraries and interfaces all the time in

00:26:15,360 --> 00:26:18,240
the cloud native space not just in

00:26:16,720 --> 00:26:19,840
kubernetes but everywhere

00:26:18,240 --> 00:26:21,600
and so this is something you'll likely

00:26:19,840 --> 00:26:24,480
run into no matter what you're writing

00:26:21,600 --> 00:26:25,600
for the cloud and it's awesome this is

00:26:24,480 --> 00:26:28,559
10 lines

00:26:25,600 --> 00:26:29,360
and it takes the protobuf definition and

00:26:28,559 --> 00:26:30,880
builds you can

00:26:29,360 --> 00:26:32,880
you can tweak how you want to build it

00:26:30,880 --> 00:26:34,480
builds everything

00:26:32,880 --> 00:26:36,799
and you don't even have to commit the

00:26:34,480 --> 00:26:38,559
code there's no auto generated client

00:26:36,799 --> 00:26:41,440
it is generating code underneath the

00:26:38,559 --> 00:26:44,080
hood but because of the use of macros

00:26:41,440 --> 00:26:44,640
um plus the build file you're able to

00:26:44,080 --> 00:26:46,400
just

00:26:44,640 --> 00:26:47,919
have it be built at runtime and have it

00:26:46,400 --> 00:26:50,080
included which is

00:26:47,919 --> 00:26:51,520
awesome i mean we just get soup this is

00:26:50,080 --> 00:26:54,080
where we nerd out about it

00:26:51,520 --> 00:26:55,279
in in contrast the typical go repository

00:26:54,080 --> 00:26:58,159
that does the same thing

00:26:55,279 --> 00:26:59,760
includes dozens if not hundreds of files

00:26:58,159 --> 00:27:01,840
that you have to remember to manually

00:26:59,760 --> 00:27:03,440
auto generate and keep in sync with your

00:27:01,840 --> 00:27:05,200
protobuf definitions

00:27:03,440 --> 00:27:06,880
and it's all incumbent on the developer

00:27:05,200 --> 00:27:08,880
to do the auto generation

00:27:06,880 --> 00:27:10,320
and then all that code gets checked in

00:27:08,880 --> 00:27:11,919
and then every time somebody goes

00:27:10,320 --> 00:27:13,600
through their your source code repo they

00:27:11,919 --> 00:27:16,159
have to read through all of that

00:27:13,600 --> 00:27:17,360
uh we just love the fact that this hides

00:27:16,159 --> 00:27:18,960
all of this stuff from the

00:27:17,360 --> 00:27:21,440
from the developer and we don't have to

00:27:18,960 --> 00:27:23,279
see those ugly auto-generated files

00:27:21,440 --> 00:27:25,919
and can just use the raw protobuf

00:27:23,279 --> 00:27:25,919
definitions

00:27:26,559 --> 00:27:29,919
now last off this will be pretty quick

00:27:28,720 --> 00:27:31,840
because there's actually going to be a

00:27:29,919 --> 00:27:33,840
talk on all of this by one of our fellow

00:27:31,840 --> 00:27:35,120
co-maintainers of crestlet

00:27:33,840 --> 00:27:36,880
at the same conference he's going to

00:27:35,120 --> 00:27:38,559
talk more about it but we had to

00:27:36,880 --> 00:27:40,559
discover how to do controllers and state

00:27:38,559 --> 00:27:42,000
machines inside of rust now kubernetes

00:27:40,559 --> 00:27:43,440
is best represented by a state machine

00:27:42,000 --> 00:27:44,720
but actually under the hood it doesn't

00:27:43,440 --> 00:27:46,720
really do

00:27:44,720 --> 00:27:48,159
a very traditional state machine if

00:27:46,720 --> 00:27:50,080
we're being honest based on all the

00:27:48,159 --> 00:27:51,440
all the code i was i was reading for it

00:27:50,080 --> 00:27:52,559
is still a state machine but kind of a

00:27:51,440 --> 00:27:54,480
little bit different

00:27:52,559 --> 00:27:56,240
and we were taking something that had a

00:27:54,480 --> 00:27:57,840
very established pattern and go and

00:27:56,240 --> 00:27:59,520
doing an entirely different

00:27:57,840 --> 00:28:00,960
language and was difficult because we

00:27:59,520 --> 00:28:02,720
had to combine this kubernetes way with

00:28:00,960 --> 00:28:06,240
the rust way and

00:28:02,720 --> 00:28:07,760
um he'll talk our our

00:28:06,240 --> 00:28:09,919
fellow maintainer kevin will talk about

00:28:07,760 --> 00:28:11,039
that more but when we combine all this

00:28:09,919 --> 00:28:13,600
we created something called

00:28:11,039 --> 00:28:14,559
crater which is an operator crate for

00:28:13,600 --> 00:28:16,000
kubernetes

00:28:14,559 --> 00:28:17,200
and this took a whole bunch this took

00:28:16,000 --> 00:28:18,720
several false starts in different

00:28:17,200 --> 00:28:19,840
versions and it took about three months

00:28:18,720 --> 00:28:21,440
of us just like

00:28:19,840 --> 00:28:23,360
building on other people's work and

00:28:21,440 --> 00:28:26,080
trying things again and again

00:28:23,360 --> 00:28:28,640
and it the the ending api is actually

00:28:26,080 --> 00:28:30,320
quite flexible which i'll show right now

00:28:28,640 --> 00:28:31,760
we have this one is the most simple

00:28:30,320 --> 00:28:33,679
thing where it basically does nothing

00:28:31,760 --> 00:28:35,039
but you have to implement two methods

00:28:33,679 --> 00:28:36,480
if you wanted to use the same kind of

00:28:35,039 --> 00:28:38,000
state machine pattern in something not

00:28:36,480 --> 00:28:39,120
kubernetes you can just take away the

00:28:38,000 --> 00:28:40,880
status one

00:28:39,120 --> 00:28:42,320
and you just have this next method that

00:28:40,880 --> 00:28:45,200
does work

00:28:42,320 --> 00:28:46,880
and so that's the simplest example now

00:28:45,200 --> 00:28:49,039
the next one is actually a more complex

00:28:46,880 --> 00:28:52,080
example

00:28:49,039 --> 00:28:54,720
as you can see a lot longer but it

00:28:52,080 --> 00:28:55,919
shows how to um how it's what happens

00:28:54,720 --> 00:28:59,520
when a pod is running

00:28:55,919 --> 00:29:00,720
inside a presslet and there are

00:28:59,520 --> 00:29:02,399
multiple things that happen but you're

00:29:00,720 --> 00:29:04,000
able to pass state around and just go

00:29:02,399 --> 00:29:07,520
next and you'll see at the very top

00:29:04,000 --> 00:29:08,960
there's a um there's this derived

00:29:07,520 --> 00:29:11,120
transition to so we wrote a derived

00:29:08,960 --> 00:29:13,919
macro that allows you to

00:29:11,120 --> 00:29:15,760
put on a transition automatically to a

00:29:13,919 --> 00:29:16,720
struct and make sure that it is compile

00:29:15,760 --> 00:29:18,240
time checked

00:29:16,720 --> 00:29:19,760
if you don't have the proper things in

00:29:18,240 --> 00:29:21,200
place it'll tell you that your state

00:29:19,760 --> 00:29:22,960
machine is invalid

00:29:21,200 --> 00:29:24,799
which is incredibly powerful because

00:29:22,960 --> 00:29:25,200
then you're not accidentally checking

00:29:24,799 --> 00:29:26,559
like

00:29:25,200 --> 00:29:28,320
checking in something that you think

00:29:26,559 --> 00:29:28,720
works but there's a missing edge in your

00:29:28,320 --> 00:29:31,279
graph

00:29:28,720 --> 00:29:34,960
essentially so that's pretty much the

00:29:31,279 --> 00:29:36,880
stuff we learned from from kubernetes

00:29:34,960 --> 00:29:38,880
yeah and this has been a very

00:29:36,880 --> 00:29:40,000
pleasurable journey for us as we've done

00:29:38,880 --> 00:29:43,200
this and we've learned a lot

00:29:40,000 --> 00:29:44,080
about rust uh a lot about kubernetes uh

00:29:43,200 --> 00:29:45,679
of course

00:29:44,080 --> 00:29:47,200
we're really invested in the web

00:29:45,679 --> 00:29:48,480
assembly space so if you're around for

00:29:47,200 --> 00:29:50,559
web assembly day

00:29:48,480 --> 00:29:51,600
uh take a look at some of the stuff uh

00:29:50,559 --> 00:29:53,520
there as well

00:29:51,600 --> 00:29:56,240
but we wanted to end up with a couple

00:29:53,520 --> 00:29:58,799
with a slide with a couple of resources

00:29:56,240 --> 00:29:59,279
of course uh kevin's talk on crater is

00:29:58,799 --> 00:30:02,399
also

00:29:59,279 --> 00:30:04,159
in rust today today so uh we encourage

00:30:02,399 --> 00:30:05,600
you to watch that one

00:30:04,159 --> 00:30:07,440
and then here are several links that

00:30:05,600 --> 00:30:08,960
will give you some um

00:30:07,440 --> 00:30:10,880
reading material if you'd like to catch

00:30:08,960 --> 00:30:12,720
up on how we did the state machine

00:30:10,880 --> 00:30:14,559
uh that the good the bad the ugly

00:30:12,720 --> 00:30:16,320
section we went through there uh a

00:30:14,559 --> 00:30:17,679
written version of that or

00:30:16,320 --> 00:30:19,840
is that the slides i don't remember if

00:30:17,679 --> 00:30:22,880
that's written version that's okay

00:30:19,840 --> 00:30:25,360
and then um then of course uh the async

00:30:22,880 --> 00:30:26,880
code that was our only entry in the ugly

00:30:25,360 --> 00:30:28,799
there's a lot of work going on there and

00:30:26,880 --> 00:30:31,120
we're really excited about the work

00:30:28,799 --> 00:30:33,039
and looking forward to the future of

00:30:31,120 --> 00:30:33,760
rust because we know that it's just a

00:30:33,039 --> 00:30:35,440
matter of

00:30:33,760 --> 00:30:36,799
time before everything sort of falls

00:30:35,440 --> 00:30:38,480
into place and gets it right

00:30:36,799 --> 00:30:40,960
but there's a place you can go and take

00:30:38,480 --> 00:30:41,279
a look at uh at what everyone is working

00:30:40,960 --> 00:30:43,440
on

00:30:41,279 --> 00:30:44,640
uh on the cutting edge of that anything

00:30:43,440 --> 00:30:46,320
else to add

00:30:44,640 --> 00:30:47,520
no i think that's it thank you everyone

00:30:46,320 --> 00:30:48,880
for listening to this hopefully it was

00:30:47,520 --> 00:30:50,480
helpful gave you some good starting

00:30:48,880 --> 00:30:52,960
points feel free to reach out to

00:30:50,480 --> 00:30:53,520
me or matt anytime we love talking about

00:30:52,960 --> 00:30:56,799
this

00:30:53,520 --> 00:31:01,440
and we can pass on any knowledge

00:30:56,799 --> 00:31:01,440

YouTube URL: https://www.youtube.com/watch?v=owXzGdaVgsU


