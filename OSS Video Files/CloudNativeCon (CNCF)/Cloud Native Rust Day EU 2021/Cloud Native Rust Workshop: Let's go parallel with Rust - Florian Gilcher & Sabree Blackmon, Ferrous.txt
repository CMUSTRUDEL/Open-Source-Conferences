Title: Cloud Native Rust Workshop: Let's go parallel with Rust - Florian Gilcher & Sabree Blackmon, Ferrous
Publication date: 2021-05-13
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Cloud Native Rust Workshop: Let's go parallel with Rust - Florian Gilcher & Sabree Blackmon, Ferrous Systems GmbH

In this session, we are going to build a small Rust server together. We’ll start with a simple server that accepts and delivers data through a simple TCP protocol.

Then, we will start using threads to parallelise the process. After that, we will rewrite the same project in an async fashion.

This way, you will get a basic feel for Rust and its concurrency features.
To follow the session, I recommend that have Rust installed through https://rustup.rs (rustup may also be available in your distributions package manager) and have rust-analyzer set up.
Captions: 
	00:00:01,920 --> 00:00:05,279
welcome everyone

00:00:03,199 --> 00:00:06,799
uh this is the first time for me giving

00:00:05,279 --> 00:00:08,559
such a workshop in

00:00:06,799 --> 00:00:10,639
front of an online audience although i

00:00:08,559 --> 00:00:12,480
give like online conference audience so

00:00:10,639 --> 00:00:16,560
thank you all for being here

00:00:12,480 --> 00:00:19,760
um and i apologize if some of the

00:00:16,560 --> 00:00:22,160
uh management of my setup will take a

00:00:19,760 --> 00:00:26,720
second for me to get used to

00:00:22,160 --> 00:00:30,800
um first of all i would like to

00:00:26,720 --> 00:00:35,200
share some introductory slides with you

00:00:30,800 --> 00:00:35,200
and get started with that

00:00:42,840 --> 00:00:48,160
and

00:00:44,480 --> 00:00:48,160
so i'm going to share this

00:00:48,399 --> 00:00:55,039
screen here and

00:00:51,920 --> 00:00:56,800
i'm going to get started so um

00:00:55,039 --> 00:00:59,199
thank you all for being here and

00:00:56,800 --> 00:01:00,800
listening to this workshop

00:00:59,199 --> 00:01:02,879
i'm actually quite happy to give this

00:01:00,800 --> 00:01:06,000
workshop again because

00:01:02,879 --> 00:01:09,760
i have started with such a format

00:01:06,000 --> 00:01:14,720
to start training uh rust so

00:01:09,760 --> 00:01:14,720
an introduction in two hours and

00:01:16,000 --> 00:01:22,479
before i'm even getting started um

00:01:19,360 --> 00:01:24,320
introducing myself if you don't have

00:01:22,479 --> 00:01:25,280
rust installed i would highly recommend

00:01:24,320 --> 00:01:28,159
you to install

00:01:25,280 --> 00:01:30,320
rust through rust stop this means you

00:01:28,159 --> 00:01:32,880
can either go to rustling.org

00:01:30,320 --> 00:01:34,640
learn get started and the reason why i

00:01:32,880 --> 00:01:38,799
put this slide up front is

00:01:34,640 --> 00:01:42,720
if you are using oh

00:01:38,799 --> 00:01:42,720
for some people audio seems to be muted

00:01:42,880 --> 00:01:49,759
okay um so

00:01:46,880 --> 00:01:50,240
um the reason why i'm putting this slide

00:01:49,759 --> 00:01:52,399
up front

00:01:50,240 --> 00:01:54,320
is if you are on windows this requires

00:01:52,399 --> 00:01:58,640
visual studio to be installed

00:01:54,320 --> 00:02:01,520
which is a which is a sizable download

00:01:58,640 --> 00:02:02,799
if you can't get rust installed you can

00:02:01,520 --> 00:02:05,759
always use the

00:02:02,799 --> 00:02:07,520
playground and the play.rustlang.org to

00:02:05,759 --> 00:02:08,640
follow along and at least get things to

00:02:07,520 --> 00:02:11,200
compile

00:02:08,640 --> 00:02:11,760
and i'll explain what rust stop is in

00:02:11,200 --> 00:02:14,560
detail

00:02:11,760 --> 00:02:15,760
in a bit but just for the sake of making

00:02:14,560 --> 00:02:17,120
sure that you can get the

00:02:15,760 --> 00:02:19,120
get your download started and your

00:02:17,120 --> 00:02:22,800
installation started i

00:02:19,120 --> 00:02:26,720
wanted to put this as a first slide

00:02:22,800 --> 00:02:28,319
so who am i i'm from geisha i'm uh

00:02:26,720 --> 00:02:29,760
one of the founders of ferris systems in

00:02:28,319 --> 00:02:32,800
critical section

00:02:29,760 --> 00:02:35,280
i am part of the rust project um

00:02:32,800 --> 00:02:37,040
since around 2015 as a member of the

00:02:35,280 --> 00:02:39,440
community and the core team

00:02:37,040 --> 00:02:40,640
i'm also currently sitting at the board

00:02:39,440 --> 00:02:42,879
of the rust foundation

00:02:40,640 --> 00:02:44,160
and have been a part of the foundation

00:02:42,879 --> 00:02:45,920
setup group

00:02:44,160 --> 00:02:49,200
and personally i've been in a

00:02:45,920 --> 00:02:53,120
restoration since 2013

00:02:49,200 --> 00:02:55,120
roughly and i've created a number of

00:02:53,120 --> 00:02:58,319
projects in the meantime

00:02:55,120 --> 00:03:00,480
such as the the berlin user group and

00:02:58,319 --> 00:03:02,080
also for example the european conference

00:03:00,480 --> 00:03:06,080
russ test

00:03:02,080 --> 00:03:06,800
and i'm been training ross since 2015

00:03:06,080 --> 00:03:08,480
now

00:03:06,800 --> 00:03:09,840
and recently had a look back on how many

00:03:08,480 --> 00:03:14,159
people i trained and that's like

00:03:09,840 --> 00:03:17,440
over 600 um like conservative number

00:03:14,159 --> 00:03:20,400
people all our teaching material is

00:03:17,440 --> 00:03:21,440
open source though i am not going to use

00:03:20,400 --> 00:03:24,640
most of it

00:03:21,440 --> 00:03:25,360
in the part of this course um i don't

00:03:24,640 --> 00:03:27,440
think that

00:03:25,360 --> 00:03:28,799
copyright on teaching material is a good

00:03:27,440 --> 00:03:31,920
forcing function

00:03:28,799 --> 00:03:33,599
and the other thing that we do as far

00:03:31,920 --> 00:03:35,360
systems which i would like to highlight

00:03:33,599 --> 00:03:38,799
is we try to

00:03:35,360 --> 00:03:42,080
work as much as possible in open source

00:03:38,799 --> 00:03:44,080
also using new funding models so for

00:03:42,080 --> 00:03:45,440
example we propose tools to the

00:03:44,080 --> 00:03:48,720
ecosystem that we think

00:03:45,440 --> 00:03:51,920
is useful that we think are useful and

00:03:48,720 --> 00:03:54,959
then for them um

00:03:51,920 --> 00:03:57,040
also the idea behind that is that

00:03:54,959 --> 00:03:59,840
making sure that whenever building a new

00:03:57,040 --> 00:04:01,040
tool that sustainability as a checkbox

00:03:59,840 --> 00:04:03,840
that you fix

00:04:01,040 --> 00:04:04,799
that you check off first is incredibly

00:04:03,840 --> 00:04:07,040
important

00:04:04,799 --> 00:04:08,319
because who wants to adopt a tool that

00:04:07,040 --> 00:04:11,280
goes

00:04:08,319 --> 00:04:12,720
out of maintenance in two years so this

00:04:11,280 --> 00:04:13,920
is actually

00:04:12,720 --> 00:04:15,760
i believe this should be one of the

00:04:13,920 --> 00:04:18,479
first check boxes to fix

00:04:15,760 --> 00:04:20,079
um you see this logo up there called um

00:04:18,479 --> 00:04:21,600
ferrocene you may have seen the talk by

00:04:20,079 --> 00:04:23,919
sabri earlier

00:04:21,600 --> 00:04:25,040
um we are also currently engaged in

00:04:23,919 --> 00:04:28,479
bringing

00:04:25,040 --> 00:04:32,080
rust to particularly safety critical

00:04:28,479 --> 00:04:34,240
sectors that is the job of a subsidiary

00:04:32,080 --> 00:04:37,759
called critical section

00:04:34,240 --> 00:04:40,240
and that is a

00:04:37,759 --> 00:04:41,280
project that we want to succeed in in

00:04:40,240 --> 00:04:44,400
the next few years

00:04:41,280 --> 00:04:48,240
2020 to 2023 is the date when

00:04:44,400 --> 00:04:48,240
we want to see rust on course

00:04:48,800 --> 00:04:52,160
about this workshop and how it's going

00:04:50,479 --> 00:04:55,199
to work

00:04:52,160 --> 00:04:57,840
because i only have two hours

00:04:55,199 --> 00:04:59,840
the way i'm going to do this is in a

00:04:57,840 --> 00:05:02,000
code along style

00:04:59,840 --> 00:05:04,080
if you want to you can just watch me

00:05:02,000 --> 00:05:06,320
doing things and talking about it

00:05:04,080 --> 00:05:07,919
but also i highly encourage you to have

00:05:06,320 --> 00:05:10,240
a text buffer open and just

00:05:07,919 --> 00:05:12,880
code along also like if you've got a

00:05:10,240 --> 00:05:15,680
minute and some bandwidth you can try to

00:05:12,880 --> 00:05:18,560
like take chances and start developing

00:05:15,680 --> 00:05:22,400
in a certain direction or not

00:05:18,560 --> 00:05:25,199
and just try things out and please ask

00:05:22,400 --> 00:05:27,199
questions in chat doing that i've made

00:05:25,199 --> 00:05:28,639
sure that the example is small enough

00:05:27,199 --> 00:05:32,000
that i have ample time

00:05:28,639 --> 00:05:34,560
to actually go and talk about

00:05:32,000 --> 00:05:36,320
these kind of things i'll also be

00:05:34,560 --> 00:05:38,800
relying on a little of

00:05:36,320 --> 00:05:40,560
the experience of the previous speakers

00:05:38,800 --> 00:05:43,840
that they have shared particularly

00:05:40,560 --> 00:05:45,600
nell's talk about borrowing and working

00:05:43,840 --> 00:05:48,080
with the borrower checker

00:05:45,600 --> 00:05:50,000
which i will show practical applications

00:05:48,080 --> 00:05:52,800
of

00:05:50,000 --> 00:05:53,759
and the example is betraying really

00:05:52,800 --> 00:05:56,639
simple

00:05:53,759 --> 00:05:58,560
um what we want to build in the next two

00:05:56,639 --> 00:06:00,479
hours is just a small server that

00:05:58,560 --> 00:06:04,880
accepts tcp connections

00:06:00,479 --> 00:06:06,960
not even http connections um

00:06:04,880 --> 00:06:08,160
then read one line from the incoming

00:06:06,960 --> 00:06:10,880
stream either

00:06:08,160 --> 00:06:13,360
until the first new line or until the

00:06:10,880 --> 00:06:15,280
input stream closes

00:06:13,360 --> 00:06:17,520
for the sake of the exercise it's okay

00:06:15,280 --> 00:06:20,800
to just trim trading spaces

00:06:17,520 --> 00:06:23,680
of the incoming messages

00:06:20,800 --> 00:06:25,120
and then if the input is an empty string

00:06:23,680 --> 00:06:26,800
we're going to store the string

00:06:25,120 --> 00:06:28,080
internally somewhere so that we have

00:06:26,800 --> 00:06:29,759
some amount of state

00:06:28,080 --> 00:06:32,000
and if it is an empty string we'll

00:06:29,759 --> 00:06:34,720
interpret it as give me one of those

00:06:32,000 --> 00:06:36,880
messages that someone previously sent

00:06:34,720 --> 00:06:39,120
and then we want to start improving on

00:06:36,880 --> 00:06:41,600
that by adding for example threading

00:06:39,120 --> 00:06:43,759
or experiencing rest concurrency safety

00:06:41,600 --> 00:06:47,360
we'll see how far we get

00:06:43,759 --> 00:06:49,280
and that is

00:06:47,360 --> 00:06:50,400
the reason why i use this example is

00:06:49,280 --> 00:06:53,360
because it shows

00:06:50,400 --> 00:06:55,919
every small issue that we're going to

00:06:53,360 --> 00:06:59,280
deal with at precisely one location

00:06:55,919 --> 00:07:00,880
it is simple but it allows us to always

00:06:59,280 --> 00:07:02,000
come back and you can keep that and

00:07:00,880 --> 00:07:03,840
rebuild it and rebuild

00:07:02,000 --> 00:07:06,160
it and rebuild it trying out new things

00:07:03,840 --> 00:07:07,840
that you learned because

00:07:06,160 --> 00:07:09,599
once you once you got used to the

00:07:07,840 --> 00:07:13,440
example it's um

00:07:09,599 --> 00:07:17,520
it's easy to rebuild and

00:07:13,440 --> 00:07:20,000
yeah that's uh that's about it

00:07:17,520 --> 00:07:20,880
and along the way we will actually learn

00:07:20,000 --> 00:07:24,080
how

00:07:20,880 --> 00:07:27,199
rust's ownership model does

00:07:24,080 --> 00:07:29,680
not only um manage memory

00:07:27,199 --> 00:07:31,680
but also for example other resources

00:07:29,680 --> 00:07:33,680
like network connections

00:07:31,680 --> 00:07:35,919
we're going to learn mutable and

00:07:33,680 --> 00:07:39,919
immutable references and how they work

00:07:35,919 --> 00:07:42,319
and how i can for example work with them

00:07:39,919 --> 00:07:44,639
in a dynamic setting where need to

00:07:42,319 --> 00:07:48,000
assume multiple connections to be

00:07:44,639 --> 00:07:52,479
currently being handled

00:07:48,000 --> 00:07:56,840
and also some basic concurrency safety

00:07:52,479 --> 00:07:59,840
few mutexes and smart pointers

00:07:56,840 --> 00:07:59,840
so

00:08:00,160 --> 00:08:03,919
thank you um before i start i want to

00:08:02,960 --> 00:08:07,360
give the chance for

00:08:03,919 --> 00:08:08,639
a first round of quick questions just

00:08:07,360 --> 00:08:11,520
quick fire questions

00:08:08,639 --> 00:08:13,840
not long ones someone feels need for

00:08:11,520 --> 00:08:13,840
clarity

00:08:16,639 --> 00:08:18,879
okay

00:08:20,080 --> 00:08:22,560
thank you

00:08:27,599 --> 00:08:30,639
spontaneous slides

00:08:31,039 --> 00:08:37,760
i am going to try to

00:08:34,399 --> 00:08:42,640
remove myself

00:08:37,760 --> 00:08:42,640
from the stage if that's possible

00:08:45,120 --> 00:08:48,080
doesn't seem like

00:08:51,200 --> 00:08:57,120
then it'll have to do here

00:08:54,399 --> 00:08:58,399
um because i would actually like to work

00:08:57,120 --> 00:09:01,680
with my

00:08:58,399 --> 00:09:05,040
full screen here i hope

00:09:01,680 --> 00:09:06,560
i'm going to increase for that reason

00:09:05,040 --> 00:09:09,279
the font size here a little

00:09:06,560 --> 00:09:10,240
even if that ends up being painfully

00:09:09,279 --> 00:09:14,000
large

00:09:10,240 --> 00:09:23,839
and give myself a little bit more space

00:09:14,000 --> 00:09:23,839
to the right

00:09:26,720 --> 00:09:31,600
let's do it that way i'll work full

00:09:29,279 --> 00:09:33,920
screen with the text editor

00:09:31,600 --> 00:09:33,920
and

00:09:34,800 --> 00:09:38,000
then i need to take care with my with

00:09:36,480 --> 00:09:40,480
the rest of my window management

00:09:38,000 --> 00:09:43,040
the white window that you're seeing here

00:09:40,480 --> 00:09:47,200
is one that i'm going to use

00:09:43,040 --> 00:09:51,040
for explanatory drawings

00:09:47,200 --> 00:09:54,080
so that we can visualize a little bit of

00:09:51,040 --> 00:09:54,080
around what's happening

00:09:55,360 --> 00:10:02,399
and first of all i'm going to close

00:09:58,560 --> 00:10:02,399
this part here

00:10:02,959 --> 00:10:07,839
um there's one question

00:10:08,240 --> 00:10:15,519
i can turn off the camera says

00:10:11,680 --> 00:10:20,160
three but this uh keeps my

00:10:15,519 --> 00:10:23,760
window on at least at my side yep

00:10:20,160 --> 00:10:25,600
okay um

00:10:23,760 --> 00:10:27,040
there's a question is there a ripple for

00:10:25,600 --> 00:10:33,040
this to follow along

00:10:27,040 --> 00:10:35,120
um yes you can

00:10:33,040 --> 00:10:38,160
there might be some slight divergences

00:10:35,120 --> 00:10:38,160
but you can go for

00:10:40,800 --> 00:10:43,040
here

00:10:44,000 --> 00:10:49,680
this is actually um it's been

00:10:47,680 --> 00:10:50,880
i'm using this as an example since a

00:10:49,680 --> 00:10:54,399
couple of years

00:10:50,880 --> 00:11:01,839
and um there you can see it even

00:10:54,399 --> 00:11:01,839
like collected in steps

00:11:03,360 --> 00:11:09,760
um i will also share um

00:11:06,399 --> 00:11:13,279
share code afterwards there's um

00:11:09,760 --> 00:11:15,839
one question here um about what's the

00:11:13,279 --> 00:11:20,240
best text editor for rust

00:11:15,839 --> 00:11:23,519
them or i personally use vs code for

00:11:20,240 --> 00:11:26,640
a number of reasons um

00:11:23,519 --> 00:11:27,440
but you can basically use any that

00:11:26,640 --> 00:11:32,000
supports

00:11:27,440 --> 00:11:32,000
a plugin from rust analyzer

00:11:33,600 --> 00:11:38,720
i'll share a link in chat

00:11:39,760 --> 00:11:43,839
sorry for me clicking

00:11:45,120 --> 00:11:50,320
and it has set up instructions for your

00:11:47,200 --> 00:11:50,320
favorite text editor

00:11:51,360 --> 00:11:58,800
and if you feel

00:11:54,480 --> 00:12:02,160
and if you if you are already using

00:11:58,800 --> 00:12:04,560
intellij or intellij c line

00:12:02,160 --> 00:12:08,399
especially i can recommend you sticking

00:12:04,560 --> 00:12:08,399
with that and installing the rust plugin

00:12:09,120 --> 00:12:12,240
it's also questions in the qa section

00:12:10,980 --> 00:12:14,240
[Music]

00:12:12,240 --> 00:12:16,320
um as beginner you will be able to

00:12:14,240 --> 00:12:20,320
follow along this workshop

00:12:16,320 --> 00:12:20,320
yeah definitely um

00:12:20,399 --> 00:12:25,120
if will we use the standard clip and we

00:12:22,320 --> 00:12:28,560
will look at minifying the result

00:12:25,120 --> 00:12:30,399
no but i'm happy to take

00:12:28,560 --> 00:12:32,880
to take that later feel free to send me

00:12:30,399 --> 00:12:36,160
a message check and

00:12:32,880 --> 00:12:36,160
we'll have a look at that as well

00:12:37,120 --> 00:12:43,440
okay if you have

00:12:40,639 --> 00:12:44,480
rust installed and particularly rust up

00:12:43,440 --> 00:12:46,720
i promise you to talk

00:12:44,480 --> 00:12:47,760
a tiny bit about rust up and why it is

00:12:46,720 --> 00:12:50,000
there

00:12:47,760 --> 00:12:50,959
um i won't go too much into details but

00:12:50,000 --> 00:12:54,480
rust stop is

00:12:50,959 --> 00:12:56,639
rus toolchain manager and

00:12:54,480 --> 00:12:58,320
what it does it installs rust compiler

00:12:56,639 --> 00:13:00,320
versions for you allows you to switch

00:12:58,320 --> 00:13:03,600
between them similar to something like

00:13:00,320 --> 00:13:05,680
rvm or the node version manager

00:13:03,600 --> 00:13:08,000
but it also does more and i think that's

00:13:05,680 --> 00:13:09,760
the important part around this and where

00:13:08,000 --> 00:13:12,880
it becomes the tool chain manager

00:13:09,760 --> 00:13:16,480
so i can first of all i can go and say

00:13:12,880 --> 00:13:19,839
well stop default and can switch for

00:13:16,480 --> 00:13:23,600
example between the nightly rust

00:13:19,839 --> 00:13:26,000
if i want to or between the stable

00:13:23,600 --> 00:13:27,920
which i'm going to use for this course

00:13:26,000 --> 00:13:29,360
but another thing that it for example

00:13:27,920 --> 00:13:32,880
allows is

00:13:29,360 --> 00:13:36,880
that rust by default all the tooling

00:13:32,880 --> 00:13:39,199
as cross compilation aware and

00:13:36,880 --> 00:13:39,920
rust the rust project ships a number of

00:13:39,199 --> 00:13:43,440
pre-built

00:13:39,920 --> 00:13:44,240
targets and for example rostop also

00:13:43,440 --> 00:13:47,680
manages

00:13:44,240 --> 00:13:50,639
these so i do quite a bit of

00:13:47,680 --> 00:13:52,480
embedded development on these kinds of

00:13:50,639 --> 00:13:55,040
ports but that's not

00:13:52,480 --> 00:13:57,279
the point of this course so i have a

00:13:55,040 --> 00:14:01,440
number of the targets installed to

00:13:57,279 --> 00:14:05,760
insta to compile software for this board

00:14:01,440 --> 00:14:08,160
and here is my native target i'm on a

00:14:05,760 --> 00:14:09,680
windows pc and i use the microsoft

00:14:08,160 --> 00:14:13,120
visual code

00:14:09,680 --> 00:14:15,440
back-end there's also one for mean gw

00:14:13,120 --> 00:14:17,760
if you want to use that so if you want

00:14:15,440 --> 00:14:21,199
to use a neutral chain on windows

00:14:17,760 --> 00:14:22,320
and you prefer that um you see there's

00:14:21,199 --> 00:14:25,920
other ones

00:14:22,320 --> 00:14:29,519
like for example android even like

00:14:25,920 --> 00:14:32,639
um google's new operating system

00:14:29,519 --> 00:14:35,839
fuchsia the experimental one and

00:14:32,639 --> 00:14:37,839
for example ios so rostop

00:14:35,839 --> 00:14:39,360
manages your whole development

00:14:37,839 --> 00:14:41,519
environment and that's why i recommend

00:14:39,360 --> 00:14:45,120
using it

00:14:41,519 --> 00:14:46,079
there's a some people don't like rust up

00:14:45,120 --> 00:14:48,000
because

00:14:46,079 --> 00:14:50,160
you need to install it through a shell

00:14:48,000 --> 00:14:52,399
script this is only the case

00:14:50,160 --> 00:14:54,079
if your operating system or your linux

00:14:52,399 --> 00:14:56,959
distribution does not yet ship

00:14:54,079 --> 00:14:58,880
rust up in its package manager which is

00:14:56,959 --> 00:15:03,120
if it's available in a package manager

00:14:58,880 --> 00:15:05,680
the way i recommend that in

00:15:03,120 --> 00:15:05,680
difference

00:15:06,320 --> 00:15:08,880
there we go

00:15:09,519 --> 00:15:14,079
in difference to for example the

00:15:12,800 --> 00:15:18,240
compiler that comes

00:15:14,079 --> 00:15:20,399
with uh with your linux distribution um

00:15:18,240 --> 00:15:22,480
this one is your development this one we

00:15:20,399 --> 00:15:26,320
consider your development compiler

00:15:22,480 --> 00:15:29,839
your linux distribution now often

00:15:26,320 --> 00:15:31,600
has a rust c version as well this is in

00:15:29,839 --> 00:15:32,399
general the one that is used to compile

00:15:31,600 --> 00:15:34,560
other

00:15:32,399 --> 00:15:36,720
packages just for the difference on what

00:15:34,560 --> 00:15:39,040
rustop does and why there's still one

00:15:36,720 --> 00:15:40,399
in package managing and this one i would

00:15:39,040 --> 00:15:42,160
recommend to use if you are actually

00:15:40,399 --> 00:15:45,279
interested in

00:15:42,160 --> 00:15:47,920
testing your software on a specific

00:15:45,279 --> 00:15:51,360
linux distribution

00:15:47,920 --> 00:15:55,920
and one thing

00:15:51,360 --> 00:15:57,680
that is um

00:15:55,920 --> 00:15:59,360
just to quickly address the question by

00:15:57,680 --> 00:16:01,839
olga what would you recommend as a

00:15:59,360 --> 00:16:04,880
container base for windows based build

00:16:01,839 --> 00:16:07,120
um i usually don't build in

00:16:04,880 --> 00:16:08,000
containers when i'm working on when i'm

00:16:07,120 --> 00:16:10,399
working on windows

00:16:08,000 --> 00:16:11,120
i use the native target because i'm very

00:16:10,399 --> 00:16:14,399
interested in

00:16:11,120 --> 00:16:17,519
cross-platform development that's a

00:16:14,399 --> 00:16:18,880
personal habit though i'm a little bit

00:16:17,519 --> 00:16:19,360
out of the cloud space in the recent

00:16:18,880 --> 00:16:22,240
years

00:16:19,360 --> 00:16:22,800
so i can i can actually admit that um

00:16:22,240 --> 00:16:24,959
the rust

00:16:22,800 --> 00:16:28,720
project itself ships docker images

00:16:24,959 --> 00:16:28,720
though with the compiler in it

00:16:30,959 --> 00:16:36,079
and yeah

00:16:34,720 --> 00:16:38,320
and this is where i would like to get

00:16:36,079 --> 00:16:42,240
started so if you have

00:16:38,320 --> 00:16:45,120
a directory somewhere in which you're

00:16:42,240 --> 00:16:47,120
you're going to take this workshop on i

00:16:45,120 --> 00:16:52,399
would like you to navigate there

00:16:47,120 --> 00:16:52,399
and there put in cargo new

00:16:55,360 --> 00:16:59,199
tcp mailbox

00:17:00,000 --> 00:17:06,400
and you hit enter there

00:17:03,759 --> 00:17:08,079
cargo will create us a new binary

00:17:06,400 --> 00:17:09,439
application so this is something we can

00:17:08,079 --> 00:17:12,559
run

00:17:09,439 --> 00:17:18,880
called tcp mailbox

00:17:12,559 --> 00:17:24,079
i'm going to navigate down and

00:17:18,880 --> 00:17:24,079
finally open my editor there

00:17:26,240 --> 00:17:28,799
and give you

00:17:29,440 --> 00:17:33,840
some seconds to follow

00:17:39,280 --> 00:17:43,039
so the first thing i would recommend you

00:17:41,200 --> 00:17:47,200
to do in

00:17:43,039 --> 00:17:50,480
this directory is

00:17:47,200 --> 00:17:50,480
put in cargo run

00:17:52,880 --> 00:17:56,400
and it should build this and print hello

00:17:54,559 --> 00:17:58,559
world and if that worked

00:17:56,400 --> 00:18:00,559
your tool chain is working and should

00:17:58,559 --> 00:18:03,840
continue working through

00:18:00,559 --> 00:18:07,120
the whole workshop

00:18:03,840 --> 00:18:10,480
and if anyone has any issues there

00:18:07,120 --> 00:18:15,440
please let me know in chat and maybe

00:18:10,480 --> 00:18:18,160
someone has also seen this issue and

00:18:15,440 --> 00:18:18,160
may help there

00:18:19,200 --> 00:18:22,799
um also if you do see issues in this

00:18:21,919 --> 00:18:25,840
process

00:18:22,799 --> 00:18:29,679
we're interested in the box

00:18:25,840 --> 00:18:31,760
in the bug report

00:18:29,679 --> 00:18:33,600
because this should work in all cases

00:18:31,760 --> 00:18:35,360
and if it doesn't

00:18:33,600 --> 00:18:36,960
the last project considers this a bug

00:18:35,360 --> 00:18:43,840
and would like be

00:18:36,960 --> 00:18:43,840
to know what you ran into

00:18:44,400 --> 00:18:50,559
let's have a quick look on what's

00:18:48,320 --> 00:18:52,400
in this directory before we go into the

00:18:50,559 --> 00:18:53,600
main rs file and we're not going to

00:18:52,400 --> 00:18:56,559
leave it

00:18:53,600 --> 00:18:58,320
for most of this course see how far we

00:18:56,559 --> 00:19:01,440
go

00:18:58,320 --> 00:19:04,559
so what this creates is

00:19:01,440 --> 00:19:07,200
um a new cargo project

00:19:04,559 --> 00:19:08,960
cargo is rust's build tool build

00:19:07,200 --> 00:19:10,400
management and dependency management

00:19:08,960 --> 00:19:12,960
tool and

00:19:10,400 --> 00:19:14,240
it has a manifest file called cargo

00:19:12,960 --> 00:19:17,280
tunnel

00:19:14,240 --> 00:19:20,080
tommel tom's obvious minimal

00:19:17,280 --> 00:19:21,840
language a kind of an any file language

00:19:20,080 --> 00:19:24,960
i think most people know tamil now

00:19:21,840 --> 00:19:29,120
nowadays and what it takes

00:19:24,960 --> 00:19:32,960
is a top level key called package

00:19:29,120 --> 00:19:36,080
gives the package some metadata the name

00:19:32,960 --> 00:19:38,640
version this key selects

00:19:36,080 --> 00:19:40,400
the language profile the ros compiler

00:19:38,640 --> 00:19:44,160
understands two language profiles the

00:19:40,400 --> 00:19:46,480
2018 and the 2015 profile

00:19:44,160 --> 00:19:47,200
you can completely ignore the 2015

00:19:46,480 --> 00:19:51,200
profile

00:19:47,200 --> 00:19:51,600
nowadays no one uses it anymore except

00:19:51,200 --> 00:19:54,640
in

00:19:51,600 --> 00:19:57,760
very niche cases where

00:19:54,640 --> 00:19:58,559
code hasn't been ported over yet so this

00:19:57,760 --> 00:20:00,880
is something

00:19:58,559 --> 00:20:02,880
what i would say learn or need if you're

00:20:00,880 --> 00:20:04,840
learning rust learning rust 2018 and

00:20:02,880 --> 00:20:07,280
don't bother

00:20:04,840 --> 00:20:10,640
unless you probably never run into the

00:20:07,280 --> 00:20:14,960
case where 2015 becomes relevant for you

00:20:10,640 --> 00:20:17,520
and below we have a dependency section

00:20:14,960 --> 00:20:18,080
and in this dependency section we can

00:20:17,520 --> 00:20:21,440
express

00:20:18,080 --> 00:20:25,200
dependencies similar to

00:20:21,440 --> 00:20:30,000
rubygems npm any other

00:20:25,200 --> 00:20:31,919
package manager but we're not going

00:20:30,000 --> 00:20:33,039
to express one now we would like to

00:20:31,919 --> 00:20:36,880
start

00:20:33,039 --> 00:20:39,280
coding and for that reason we're going

00:20:36,880 --> 00:20:44,320
to go into the main rs file

00:20:39,280 --> 00:20:44,320
and we're going to

00:20:46,840 --> 00:20:51,840
fold

00:20:49,679 --> 00:20:53,280
the left side here so that it doesn't

00:20:51,840 --> 00:20:55,679
take up

00:20:53,280 --> 00:20:55,679
space

00:20:56,880 --> 00:21:00,880
and yeah so this is where i would like

00:20:59,679 --> 00:21:04,799
to get started

00:21:00,880 --> 00:21:08,720
so the first thing

00:21:04,799 --> 00:21:12,240
that we need to solve is

00:21:08,720 --> 00:21:17,840
we want to set up a tcp server

00:21:12,240 --> 00:21:17,840
that starts listening for connections

00:21:24,480 --> 00:21:33,440
and for every new connection

00:21:30,720 --> 00:21:33,440
does something

00:21:42,159 --> 00:21:48,880
so that's our first initial goal

00:21:47,039 --> 00:21:50,559
first thing we're going to do is write a

00:21:48,880 --> 00:21:52,480
small

00:21:50,559 --> 00:21:54,240
accepting loop that just on every new

00:21:52,480 --> 00:21:59,840
connection prints

00:21:54,240 --> 00:21:59,840
hi new connection

00:22:02,400 --> 00:22:08,799
for that um i will

00:22:06,400 --> 00:22:11,520
i can highly recommend after this course

00:22:08,799 --> 00:22:14,000
or actually follow down a little

00:22:11,520 --> 00:22:14,640
the types that i'm going to use here and

00:22:14,000 --> 00:22:16,320
have a look

00:22:14,640 --> 00:22:18,640
at their documentation in the standard

00:22:16,320 --> 00:22:20,400
lab i'm not going to do that

00:22:18,640 --> 00:22:22,799
for the sake of time but our standard

00:22:20,400 --> 00:22:26,799
clip is completely documented

00:22:22,799 --> 00:22:28,640
and again if you read something in the

00:22:26,799 --> 00:22:29,600
documentation and it doesn't immediately

00:22:28,640 --> 00:22:31,120
click or

00:22:29,600 --> 00:22:33,039
you have a hard time understanding it

00:22:31,120 --> 00:22:36,320
would also be very interested

00:22:33,039 --> 00:22:36,320
in a bug report um

00:22:41,360 --> 00:22:43,679
um

00:22:47,440 --> 00:22:51,840
so the first thing we need to do is in

00:22:50,559 --> 00:22:54,000
some way

00:22:51,840 --> 00:22:56,640
get our start listening for network

00:22:54,000 --> 00:23:00,000
connections

00:22:56,640 --> 00:23:03,120
and the way we do this

00:23:00,000 --> 00:23:09,760
is we use a type called

00:23:03,120 --> 00:23:11,440
tcp listener not pcl listener

00:23:09,760 --> 00:23:13,120
you can see rust analyzer will

00:23:11,440 --> 00:23:15,440
immediately tell me

00:23:13,120 --> 00:23:18,400
standard do you mean standard net tcp

00:23:15,440 --> 00:23:18,400
listener that's the one

00:23:20,640 --> 00:23:24,320
and if i click that one it will

00:23:22,400 --> 00:23:26,159
automatically import it in rus

00:23:24,320 --> 00:23:28,640
you need to declare every type that you

00:23:26,159 --> 00:23:30,640
use in an unqualified way

00:23:28,640 --> 00:23:32,559
so if i just want to use the name tcp

00:23:30,640 --> 00:23:37,840
listener i have to import

00:23:32,559 --> 00:23:37,840
use standard net tcp listener

00:23:39,520 --> 00:23:43,360
and the function

00:23:43,679 --> 00:23:48,240
that i need to bind to a socket is what

00:23:46,559 --> 00:23:51,840
the bind or to an address is

00:23:48,240 --> 00:23:51,840
the bind function

00:23:53,520 --> 00:24:02,400
for eseg

00:23:57,360 --> 00:24:05,279
i will use a tcp for e4 address

00:24:02,400 --> 00:24:06,000
but you can also enter any other kind

00:24:05,279 --> 00:24:10,400
understands

00:24:06,000 --> 00:24:14,720
ipv6 whatever um

00:24:10,400 --> 00:24:18,080
can do so and

00:24:14,720 --> 00:24:21,120
we need to bind

00:24:18,080 --> 00:24:21,120
results to a variable

00:24:26,159 --> 00:24:33,840
now let's have a look at the result

00:24:29,919 --> 00:24:33,840
type like what we get back

00:24:38,080 --> 00:24:44,320
if you have a look here

00:24:41,360 --> 00:24:45,440
listener is now results tcp listener

00:24:44,320 --> 00:24:48,240
error

00:24:45,440 --> 00:24:49,360
and that's the first time in russ that

00:24:48,240 --> 00:24:51,120
we get actually in

00:24:49,360 --> 00:24:53,679
touch with the result type on the very

00:24:51,120 --> 00:24:56,640
first line rust has a special

00:24:53,679 --> 00:24:57,840
or this is actually not special is just

00:24:56,640 --> 00:24:59,840
a

00:24:57,840 --> 00:25:02,480
type that is provided by the core

00:24:59,840 --> 00:25:05,679
library says

00:25:02,480 --> 00:25:09,520
that extract over things that work

00:25:05,679 --> 00:25:12,000
or may not so here it says

00:25:09,520 --> 00:25:13,520
this gives back a result of tcp listener

00:25:12,000 --> 00:25:16,559
and error

00:25:13,520 --> 00:25:18,320
the error in this case being the error

00:25:16,559 --> 00:25:21,440
that for example we were not able

00:25:18,320 --> 00:25:24,320
to bind to a socket

00:25:21,440 --> 00:25:25,600
in this case i'm going to use a strategy

00:25:24,320 --> 00:25:29,679
for

00:25:25,600 --> 00:25:33,120
result handling is called unwrapping

00:25:29,679 --> 00:25:34,240
what unwrapping says is either this

00:25:33,120 --> 00:25:38,080
works

00:25:34,240 --> 00:25:40,720
or immediately crash for beginners

00:25:38,080 --> 00:25:42,240
um that sometimes feels like this is a

00:25:40,720 --> 00:25:44,640
this is a way out like

00:25:42,240 --> 00:25:46,559
i i ignored the structured error

00:25:44,640 --> 00:25:49,679
handling that russ does

00:25:46,559 --> 00:25:52,960
um i do not fully subscribe to that

00:25:49,679 --> 00:25:54,720
um calling unwrap is

00:25:52,960 --> 00:25:56,960
basically a statement that if this

00:25:54,720 --> 00:25:59,679
doesn't work

00:25:56,960 --> 00:26:00,240
um then the program should immediately

00:25:59,679 --> 00:26:02,960
quit

00:26:00,240 --> 00:26:05,600
and shut down in a structured way so it

00:26:02,960 --> 00:26:10,559
is perfectly fine to do that

00:26:05,600 --> 00:26:13,039
also for the sake of

00:26:10,559 --> 00:26:14,320
this session i will actually handle all

00:26:13,039 --> 00:26:18,000
result types

00:26:14,320 --> 00:26:19,840
using unwrap why

00:26:18,000 --> 00:26:21,200
this is actually for even for

00:26:19,840 --> 00:26:23,600
experienced

00:26:21,200 --> 00:26:26,559
rust developers an easy first pass i

00:26:23,600 --> 00:26:29,760
just assume everything works all right

00:26:26,559 --> 00:26:31,840
and then i can later go look at

00:26:29,760 --> 00:26:33,360
all of those and wrap calls and turn

00:26:31,840 --> 00:26:35,200
them into structured error handling

00:26:33,360 --> 00:26:37,440
because then i know all the errors that

00:26:35,200 --> 00:26:40,559
could happen in the program that i have

00:26:37,440 --> 00:26:41,279
and that is a good moment to collect

00:26:40,559 --> 00:26:43,120
them all

00:26:41,279 --> 00:26:44,559
and put a more structured error handling

00:26:43,120 --> 00:26:47,279
on top of that

00:26:44,559 --> 00:26:49,679
so that is something if we have enough

00:26:47,279 --> 00:26:53,360
time that i'm actually going to do

00:26:49,679 --> 00:26:56,480
um so i don't want to omit that part but

00:26:53,360 --> 00:26:56,480
let's see how far we get

00:27:00,240 --> 00:27:04,640
so i get a small warning that i'm not

00:27:03,200 --> 00:27:08,480
using

00:27:04,640 --> 00:27:10,720
using this uh uh this variable

00:27:08,480 --> 00:27:12,000
don't let warnings confuse you too much

00:27:10,720 --> 00:27:14,159
the rust compiler

00:27:12,000 --> 00:27:15,279
takes care that all varnic warnings are

00:27:14,159 --> 00:27:17,679
relevant

00:27:15,279 --> 00:27:19,520
once you're done so currently hey you're

00:27:17,679 --> 00:27:20,080
not using this i can ignore this warning

00:27:19,520 --> 00:27:23,279
i will

00:27:20,080 --> 00:27:24,480
use that variable in a second but once

00:27:23,279 --> 00:27:26,480
your program is done

00:27:24,480 --> 00:27:28,159
it is actually good practice to see that

00:27:26,480 --> 00:27:30,640
it's warning free because

00:27:28,159 --> 00:27:32,799
again all all warnings should ultimately

00:27:30,640 --> 00:27:32,799
be

00:27:32,840 --> 00:27:35,840
relevant

00:27:37,279 --> 00:27:39,600
um

00:27:41,360 --> 00:27:49,440
so just on these two quick questions

00:27:45,840 --> 00:27:52,559
um donald is asking jesse

00:27:49,440 --> 00:27:55,039
is the ability to have a function called

00:27:52,559 --> 00:27:55,039
expect

00:27:55,679 --> 00:27:59,440
and then you can say

00:28:00,960 --> 00:28:05,760
give a custom error message that is

00:28:03,679 --> 00:28:07,440
working similar to unwrap

00:28:05,760 --> 00:28:08,880
that is a choice you can make if you

00:28:07,440 --> 00:28:12,799
want to

00:28:08,880 --> 00:28:16,559
um i'm

00:28:12,799 --> 00:28:18,799
usually because i am not using this

00:28:16,559 --> 00:28:20,640
like i want to remove this at some point

00:28:18,799 --> 00:28:22,960
i'm just using unwrap right away and

00:28:20,640 --> 00:28:26,240
then i'm filling that later

00:28:22,960 --> 00:28:29,520
um on jack's question why

00:28:26,240 --> 00:28:31,679
unwrap with this question mark

00:28:29,520 --> 00:28:32,720
this is possible this is actually

00:28:31,679 --> 00:28:35,360
something that i will

00:28:32,720 --> 00:28:37,120
would do once we go to more structured

00:28:35,360 --> 00:28:39,840
error handling but currently

00:28:37,120 --> 00:28:40,960
i want everything to just explode at the

00:28:39,840 --> 00:28:43,840
place where it happens

00:28:40,960 --> 00:28:44,640
so during doing development i actually

00:28:43,840 --> 00:28:47,679
like

00:28:44,640 --> 00:28:49,039
um if um errors have like if errors stop

00:28:47,679 --> 00:28:49,919
the program at the place where they

00:28:49,039 --> 00:28:53,679
happen

00:28:49,919 --> 00:28:55,600
um for uh coding initial coding and

00:28:53,679 --> 00:28:57,440
debugging i find that more helpful so

00:28:55,600 --> 00:28:59,760
they have different uh different

00:28:57,440 --> 00:29:04,640
behavior question mark is

00:28:59,760 --> 00:29:04,640
is a different way of error handling and

00:29:04,799 --> 00:29:09,520
the question of victor will russia throw

00:29:07,840 --> 00:29:10,559
warnings for easier search of on-wrap

00:29:09,520 --> 00:29:13,600
usage

00:29:10,559 --> 00:29:16,399
rust has a code linter called clippy

00:29:13,600 --> 00:29:21,840
that actually has a lint that says

00:29:16,399 --> 00:29:21,840
i like one on unwrap so you can use that

00:29:24,840 --> 00:29:30,399
okay

00:29:27,440 --> 00:29:30,399
thanks for the questions

00:29:31,760 --> 00:29:35,200
let's continue so we said that we want

00:29:34,320 --> 00:29:38,720
to uh

00:29:35,200 --> 00:29:41,679
we want to accept all the incoming

00:29:38,720 --> 00:29:47,760
connections and the way this works

00:29:41,679 --> 00:29:47,760
is we actually start looping

00:29:52,640 --> 00:29:55,679
and listener has a method called

00:29:54,559 --> 00:29:58,799
incoming

00:29:55,679 --> 00:29:59,520
and what incoming does takes the

00:29:58,799 --> 00:30:02,799
listener

00:29:59,520 --> 00:30:06,000
and turns it into an iterator

00:30:02,799 --> 00:30:06,399
and this iterator can be used to iterate

00:30:06,000 --> 00:30:09,120
over

00:30:06,399 --> 00:30:11,039
all incoming connections so i can use a

00:30:09,120 --> 00:30:13,760
for loop here

00:30:11,039 --> 00:30:15,279
and the reason why i'm saying connection

00:30:13,760 --> 00:30:19,279
attempt

00:30:15,279 --> 00:30:21,840
is the um

00:30:19,279 --> 00:30:22,720
this only represents the attempt to

00:30:21,840 --> 00:30:26,080
connect

00:30:22,720 --> 00:30:27,279
so later if we were to write a fully

00:30:26,080 --> 00:30:31,600
fledged service

00:30:27,279 --> 00:30:31,600
this allows us for example to react to

00:30:32,320 --> 00:30:36,320
to the condition that the kernel started

00:30:33,919 --> 00:30:37,039
rejecting connections for whatever

00:30:36,320 --> 00:30:40,640
reason

00:30:37,039 --> 00:30:42,720
i will see still see their rejected

00:30:40,640 --> 00:30:44,080
connections here

00:30:42,720 --> 00:30:45,840
and this is the one place where i would

00:30:44,080 --> 00:30:47,039
actually like to look at how that what

00:30:45,840 --> 00:30:50,320
that looks like

00:30:47,039 --> 00:30:53,679
if we look here connection attempt is

00:30:50,320 --> 00:30:56,000
again a result of a tcp stream

00:30:53,679 --> 00:30:57,039
this is now the connection has worked

00:30:56,000 --> 00:31:01,840
and

00:30:57,039 --> 00:31:05,200
an error and i would like to

00:31:01,840 --> 00:31:06,080
here to handle this case so that you see

00:31:05,200 --> 00:31:08,720
how

00:31:06,080 --> 00:31:10,799
rust enables us to handle this case in a

00:31:08,720 --> 00:31:14,159
structured fashion

00:31:10,799 --> 00:31:17,919
and the way you do that is you use a

00:31:14,159 --> 00:31:18,960
match statement rust's match statements

00:31:17,919 --> 00:31:22,240
allow us to

00:31:18,960 --> 00:31:24,399
look at these types called um yeah these

00:31:22,240 --> 00:31:25,519
results types and also all other types

00:31:24,399 --> 00:31:28,000
that we're going to introduce

00:31:25,519 --> 00:31:30,399
are very similar form i'll introduce one

00:31:28,000 --> 00:31:30,399
later

00:31:30,840 --> 00:31:33,840
and

00:31:34,640 --> 00:31:38,320
say match connection attempt

00:31:38,399 --> 00:31:43,039
and if i have a look here this one is an

00:31:41,519 --> 00:31:47,440
error currently

00:31:43,039 --> 00:31:50,000
the arrow being missing matcharm

00:31:47,440 --> 00:31:50,480
so what it tells me is there's multiple

00:31:50,000 --> 00:31:52,080
options

00:31:50,480 --> 00:31:54,320
that there's multiple alternatives that

00:31:52,080 --> 00:31:55,679
you need to cover which that type could

00:31:54,320 --> 00:31:58,000
represent

00:31:55,679 --> 00:31:59,679
and i can easily get them inserted by my

00:31:58,000 --> 00:32:03,360
ide by clicking

00:31:59,679 --> 00:32:07,039
here left and say fill my charms

00:32:03,360 --> 00:32:10,799
and now i have those two conditions

00:32:07,039 --> 00:32:14,080
and results is a type that says

00:32:10,799 --> 00:32:16,799
either everything went okay

00:32:14,080 --> 00:32:20,080
then you get the loft value or there was

00:32:16,799 --> 00:32:23,679
an error then you get the right value

00:32:20,080 --> 00:32:29,039
let's start with the error first i can

00:32:23,679 --> 00:32:32,799
bind this error to a variable called e

00:32:29,039 --> 00:32:34,559
and then use e println

00:32:32,799 --> 00:32:36,320
so similar to the printer ln that we've

00:32:34,559 --> 00:32:37,760
seen just at the beginning with the

00:32:36,320 --> 00:32:40,960
hello world

00:32:37,760 --> 00:32:43,840
we can use eprintellen to

00:32:40,960 --> 00:32:43,840
print

00:32:44,480 --> 00:32:48,320
arrow connecting oh and e-printer line

00:32:47,039 --> 00:32:51,519
prints to standard error

00:32:48,320 --> 00:32:51,519
instead of standard out

00:32:52,240 --> 00:33:00,399
and using the interpolation syntax here

00:32:57,360 --> 00:33:01,840
i can print e

00:33:00,399 --> 00:33:05,120
there's a question in the chat was that

00:33:01,840 --> 00:33:07,760
does the bang mean an e-printer lm

00:33:05,120 --> 00:33:08,559
iprinterland and printerland are macros

00:33:07,760 --> 00:33:12,080
in rust and

00:33:08,559 --> 00:33:16,720
macros always need to be called with a

00:33:12,080 --> 00:33:16,720
bang on them that's it

00:33:18,000 --> 00:33:23,519
so you can you can get the rust compiler

00:33:21,679 --> 00:33:24,000
to actually expand this macro for you

00:33:23,519 --> 00:33:26,080
and see what

00:33:24,000 --> 00:33:27,679
it does in the back what it does it gets

00:33:26,080 --> 00:33:29,360
the standard error handle

00:33:27,679 --> 00:33:31,279
locks on it then writes to it and

00:33:29,360 --> 00:33:34,159
releases the lock

00:33:31,279 --> 00:33:35,120
for synchronization reasons you could

00:33:34,159 --> 00:33:40,320
start writing

00:33:35,120 --> 00:33:44,480
raw um and yes you can add custom macros

00:33:40,320 --> 00:33:48,080
like in c though macros and rust are not

00:33:44,480 --> 00:33:50,480
um textual replacement there's a

00:33:48,080 --> 00:33:53,840
there's a structured macro language

00:33:50,480 --> 00:33:53,840
behind that

00:33:56,559 --> 00:34:02,320
and in the case of ok

00:34:00,480 --> 00:34:05,039
now we get our stream so this is our

00:34:02,320 --> 00:34:06,960
connecting stream

00:34:05,039 --> 00:34:09,040
and this is where i want to exit this

00:34:06,960 --> 00:34:11,520
function here

00:34:09,040 --> 00:34:13,040
the main function and call a function

00:34:11,520 --> 00:34:15,839
called

00:34:13,040 --> 00:34:16,800
handle client now we have a connected

00:34:15,839 --> 00:34:21,839
client

00:34:16,800 --> 00:34:21,839
and pass that stream in

00:34:24,800 --> 00:34:32,159
and the function is not here

00:34:29,040 --> 00:34:34,000
but we can again use our ide

00:34:32,159 --> 00:34:37,200
or write it by hand to generate the

00:34:34,000 --> 00:34:37,200
handle client function here

00:34:41,280 --> 00:34:43,839
there we go

00:34:44,480 --> 00:34:48,159
now we have this handle client function

00:34:46,480 --> 00:34:51,599
and can do

00:34:48,159 --> 00:34:52,800
whatever we want here first of all one

00:34:51,599 --> 00:34:56,639
thing that i would like to do

00:34:52,800 --> 00:35:00,079
is remove the standard net here

00:34:56,639 --> 00:35:02,240
and import

00:35:00,079 --> 00:35:03,680
the tcp stream directly so that i don't

00:35:02,240 --> 00:35:07,359
need to fully qualify it

00:35:03,680 --> 00:35:10,240
because i'm going to use it again

00:35:07,359 --> 00:35:10,240
for other functions

00:35:14,079 --> 00:35:20,640
rust has this nice to do macro that

00:35:18,320 --> 00:35:21,680
allows you to have parts of your code

00:35:20,640 --> 00:35:23,440
unwritten

00:35:21,680 --> 00:35:25,119
and if you hit to do your code will just

00:35:23,440 --> 00:35:27,680
crash and say there's a there's an open

00:35:25,119 --> 00:35:27,680
to do here

00:35:28,320 --> 00:35:35,200
so it's a piece of convenience here

00:35:32,079 --> 00:35:36,720
and there's an important thing here rust

00:35:35,200 --> 00:35:40,000
has

00:35:36,720 --> 00:35:44,160
famously this ownership system and

00:35:40,000 --> 00:35:47,040
if you just pass in a bear type

00:35:44,160 --> 00:35:49,040
into a function we say it takes

00:35:47,040 --> 00:35:53,200
ownership so this function now

00:35:49,040 --> 00:35:53,200
takes ownership of the connection

00:35:53,440 --> 00:36:00,800
and what we can now do is

00:35:56,800 --> 00:36:00,800
example we can print here

00:36:01,040 --> 00:36:06,240
client connected

00:36:08,720 --> 00:36:13,839
and then go and actually start running

00:36:11,200 --> 00:36:13,839
the program

00:36:17,680 --> 00:36:20,480
so let's run it

00:36:25,200 --> 00:36:31,680
and let's connect i'm just

00:36:28,480 --> 00:36:31,680
going to use telnet here

00:36:32,320 --> 00:36:34,640
sorry

00:36:38,720 --> 00:36:41,839
now i got myself

00:36:47,599 --> 00:36:50,000
sorry

00:36:52,000 --> 00:36:58,160
cool for quit um

00:36:55,440 --> 00:36:58,160
sorry for that

00:37:02,640 --> 00:37:06,560
and let's connect to 7878

00:37:07,680 --> 00:37:10,320
and it will

00:37:13,200 --> 00:37:15,440
sorry

00:37:19,280 --> 00:37:27,760
and we'll have a connected client here

00:37:22,800 --> 00:37:27,760
also immediately quit

00:37:30,079 --> 00:37:35,200
and the reason for this being is

00:37:32,079 --> 00:37:37,520
precisely rust's ownership model

00:37:35,200 --> 00:37:38,560
i have not explicitly said goodbye to

00:37:37,520 --> 00:37:41,280
the client

00:37:38,560 --> 00:37:43,359
but um this handle client function has

00:37:41,280 --> 00:37:46,800
taken ownership of this

00:37:43,359 --> 00:37:50,240
currently currently active tcp stream

00:37:46,800 --> 00:37:52,800
for that client and one thing that rust

00:37:50,240 --> 00:37:53,920
does implicitly but i can also annotate

00:37:52,800 --> 00:37:57,119
that

00:37:53,920 --> 00:38:00,640
explicitly is once an

00:37:57,119 --> 00:38:03,200
own value falls out of scope

00:38:00,640 --> 00:38:04,000
it will deregister its interest in the

00:38:03,200 --> 00:38:05,920
resource

00:38:04,000 --> 00:38:08,000
being managed which in this case is the

00:38:05,920 --> 00:38:08,880
connection so the moment the handle

00:38:08,000 --> 00:38:12,240
client function

00:38:08,880 --> 00:38:14,720
ends after printing to standard out

00:38:12,240 --> 00:38:16,000
it will throw the stream away and in the

00:38:14,720 --> 00:38:20,640
process of it

00:38:16,000 --> 00:38:20,640
closing in so

00:38:23,200 --> 00:38:26,800
yeah that cut also works

00:38:29,440 --> 00:38:37,200
yeah so

00:38:33,680 --> 00:38:38,640
um this allows

00:38:37,200 --> 00:38:40,400
that makes sure that we cannot

00:38:38,640 --> 00:38:44,480
accidentally forget

00:38:40,400 --> 00:38:47,599
to close this tcp stream

00:38:44,480 --> 00:38:50,240
and we'll make sure that we

00:38:47,599 --> 00:38:51,200
that we disconnect the client properly

00:38:50,240 --> 00:38:54,320
the moment

00:38:51,200 --> 00:38:54,320
we let the stream drop

00:38:55,680 --> 00:38:58,960
i will remove that again this is just a

00:38:58,079 --> 00:39:00,960
that was just an

00:38:58,960 --> 00:39:02,880
illustration so this is our first

00:39:00,960 --> 00:39:06,720
experience with ownership

00:39:02,880 --> 00:39:08,640
like direct we make this connection

00:39:06,720 --> 00:39:11,839
attempt

00:39:08,640 --> 00:39:15,280
we see if it worked if it worked

00:39:11,839 --> 00:39:16,640
we'll take the connected tcp stream out

00:39:15,280 --> 00:39:19,040
and we call a function called handle

00:39:16,640 --> 00:39:21,040
client and at this moment we pass on

00:39:19,040 --> 00:39:23,119
the ownership of the stream and say okay

00:39:21,040 --> 00:39:24,960
now you are completely responsible for

00:39:23,119 --> 00:39:29,839
managing that

00:39:24,960 --> 00:39:29,839
um and

00:39:30,480 --> 00:39:36,960
this has an um expression

00:39:33,920 --> 00:39:38,000
in the um actually in software

00:39:36,960 --> 00:39:43,440
architecture

00:39:38,000 --> 00:39:46,640
in that we have our

00:39:43,440 --> 00:39:48,400
bare network system here on the left

00:39:46,640 --> 00:39:51,599
sorry

00:39:48,400 --> 00:39:53,040
so a connection handler or

00:39:51,599 --> 00:39:54,640
a system that handles our network

00:39:53,040 --> 00:39:56,000
connections and we have a handler for

00:39:54,640 --> 00:39:59,440
those connections on the other side

00:39:56,000 --> 00:39:59,440
and if we pass ownership

00:40:00,320 --> 00:40:06,800
that means we express

00:40:04,400 --> 00:40:07,680
a low coupling between those two

00:40:06,800 --> 00:40:10,240
components

00:40:07,680 --> 00:40:11,760
the net component is now not responsible

00:40:10,240 --> 00:40:14,880
for handling the stream anymore

00:40:11,760 --> 00:40:16,960
at all the handler is now

00:40:14,880 --> 00:40:18,720
responsible for doing that and that

00:40:16,960 --> 00:40:20,960
ownership transfer is

00:40:18,720 --> 00:40:22,880
complete in the sense of the one

00:40:20,960 --> 00:40:23,520
component is not allowed to use it

00:40:22,880 --> 00:40:25,520
anymore

00:40:23,520 --> 00:40:26,960
i can actually try that out if i were to

00:40:25,520 --> 00:40:30,800
try

00:40:26,960 --> 00:40:30,800
doing something with stream over here

00:40:31,359 --> 00:40:33,920
for example

00:40:34,880 --> 00:40:39,839
try to debug print it just even that

00:40:42,160 --> 00:40:49,520
i'm not allowed to you will see an error

00:40:45,599 --> 00:40:52,400
that says value borrowed here after move

00:40:49,520 --> 00:40:54,480
and it will call me out here you have

00:40:52,400 --> 00:40:56,720
given up this value

00:40:54,480 --> 00:40:57,839
and this is the way rust structures

00:40:56,720 --> 00:41:01,040
programs

00:40:57,839 --> 00:41:03,280
values flowing through the program and

00:41:01,040 --> 00:41:07,839
components giving up ownership and

00:41:03,280 --> 00:41:07,839
giving it to another component

00:41:12,640 --> 00:41:18,560
i agree fullscreen would help here i did

00:41:14,960 --> 00:41:18,560
not anticipate i'm very sorry

00:41:18,839 --> 00:41:24,720
um let me increase

00:41:22,480 --> 00:41:27,520
font size a little more i hope that that

00:41:24,720 --> 00:41:27,520
makes things better

00:41:28,480 --> 00:41:32,319
okay so now that we've got this tcp

00:41:30,880 --> 00:41:35,680
stream

00:41:32,319 --> 00:41:36,400
i want to start doing what we actually

00:41:35,680 --> 00:41:40,960
wanted to do

00:41:36,400 --> 00:41:40,960
so first of all let's read

00:41:42,400 --> 00:41:49,839
let's read a line from this tcp stream

00:41:50,240 --> 00:41:52,560
and

00:41:53,520 --> 00:41:57,280
i'm going to talk about this in a second

00:41:58,480 --> 00:42:02,160
and we're going to generate a readline

00:42:00,839 --> 00:42:04,960
function

00:42:02,160 --> 00:42:05,760
and what we're going to have back from

00:42:04,960 --> 00:42:09,440
this function

00:42:05,760 --> 00:42:11,680
is a string so this is the line that we

00:42:09,440 --> 00:42:11,680
read

00:42:15,200 --> 00:42:23,040
and um this is a place

00:42:19,119 --> 00:42:26,079
where i um

00:42:23,040 --> 00:42:28,079
need to yeah get a little bit like

00:42:26,079 --> 00:42:29,599
pull a little bit out of my ap api

00:42:28,079 --> 00:42:32,880
knowledge

00:42:29,599 --> 00:42:35,200
reading a line from an input stream

00:42:32,880 --> 00:42:35,920
is not available on raw input streams

00:42:35,200 --> 00:42:39,520
directly

00:42:35,920 --> 00:42:42,880
i actually need to use buffered reading

00:42:39,520 --> 00:42:45,839
if you're used to java or

00:42:42,880 --> 00:42:45,839
other languages you may

00:42:46,400 --> 00:42:49,839
may know the feeling you we need to wrap

00:42:48,800 --> 00:42:52,960
the stream

00:42:49,839 --> 00:42:54,240
in an inner reader that allows us to

00:42:52,960 --> 00:42:59,839
buffer

00:42:54,240 --> 00:42:59,839
this kind of data so

00:43:01,040 --> 00:43:04,720
we want a buffered reader and that is

00:43:03,200 --> 00:43:09,200
available

00:43:04,720 --> 00:43:09,200
under the name buff reader

00:43:11,040 --> 00:43:16,960
and i can create this again with a new

00:43:12,720 --> 00:43:16,960
function passing in this stream

00:43:23,040 --> 00:43:26,880
now what does this ampersand mean this

00:43:25,839 --> 00:43:29,920
ampersand means

00:43:26,880 --> 00:43:31,839
i am borrowing here i'm giving up i'm

00:43:29,920 --> 00:43:33,599
giving i'm just giving a reference

00:43:31,839 --> 00:43:35,440
of the tcp stream to the sweet line

00:43:33,599 --> 00:43:37,839
function why do i want to

00:43:35,440 --> 00:43:39,280
use this i want to reuse the stream

00:43:37,839 --> 00:43:41,359
later i

00:43:39,280 --> 00:43:43,359
maybe want to write to the client again

00:43:41,359 --> 00:43:44,960
and do other things with the stream so i

00:43:43,359 --> 00:43:47,680
do not want to throw it away

00:43:44,960 --> 00:43:48,960
so i do not want to pass on the handling

00:43:47,680 --> 00:43:51,839
of this resource

00:43:48,960 --> 00:43:52,720
so i give readline the ability to use

00:43:51,839 --> 00:43:55,040
that resource

00:43:52,720 --> 00:43:56,079
through reference but i do not want to

00:43:55,040 --> 00:43:59,119
give it away

00:43:56,079 --> 00:44:01,520
so every time you see a type that has

00:43:59,119 --> 00:44:03,280
a kind of sigil ampersand or something

00:44:01,520 --> 00:44:06,720
like that and rust that means

00:44:03,280 --> 00:44:09,839
this is where the referencing system

00:44:06,720 --> 00:44:09,839
takes place

00:44:14,720 --> 00:44:19,119
there's a question here does the stream

00:44:16,160 --> 00:44:19,119
pass the buffer reader

00:44:19,359 --> 00:44:22,800
reference i am choosing to pass the

00:44:22,000 --> 00:44:24,960
buffer here

00:44:22,800 --> 00:44:26,319
a reference it would actually take both

00:44:24,960 --> 00:44:29,200
um both ways

00:44:26,319 --> 00:44:30,000
but that's getting a little bit into um

00:44:29,200 --> 00:44:33,680
the woods here

00:44:30,000 --> 00:44:37,839
so i am choosing to to pass in a

00:44:33,680 --> 00:44:37,839
uh a reference here

00:44:38,880 --> 00:44:48,319
now buffered reader now has a function

00:44:43,920 --> 00:44:52,720
that is called readline

00:44:48,319 --> 00:44:54,960
that correctly reads uh

00:44:52,720 --> 00:44:54,960
sorry

00:44:57,680 --> 00:45:03,040
that correctly reads a line

00:45:00,800 --> 00:45:04,560
with all kinds of new line careers

00:45:03,040 --> 00:45:07,200
return new line whatever

00:45:04,560 --> 00:45:07,200
doesn't matter

00:45:07,599 --> 00:45:14,480
now you see this takes a um

00:45:11,200 --> 00:45:16,800
this takes a buff

00:45:14,480 --> 00:45:18,400
argument and this is the actual buffer

00:45:16,800 --> 00:45:21,359
that we need to

00:45:18,400 --> 00:45:22,000
that we want to write to and as its read

00:45:21,359 --> 00:45:23,680
line

00:45:22,000 --> 00:45:27,839
it reads into a string buffer you can

00:45:23,680 --> 00:45:27,839
see here ampersand mut string

00:45:28,560 --> 00:45:34,720
and this is where we meet mutability and

00:45:32,400 --> 00:45:34,720
rust

00:45:40,319 --> 00:45:43,680
we need to create this buffer

00:45:44,079 --> 00:45:47,839
we call it buff

00:45:48,160 --> 00:45:53,920
let me buff is string qualcomm new

00:45:51,520 --> 00:45:56,240
i get this new buffer and how do i pass

00:45:53,920 --> 00:45:56,240
it in

00:45:57,119 --> 00:46:02,960
and this is a second kind of

00:46:00,560 --> 00:46:04,240
reference that rust has rust has a

00:46:02,960 --> 00:46:07,520
difference between

00:46:04,240 --> 00:46:09,599
mutable references and immutable ones

00:46:07,520 --> 00:46:11,680
and both are not allowed to be active at

00:46:09,599 --> 00:46:12,480
the same time you need to either mutable

00:46:11,680 --> 00:46:14,960
reference or

00:46:12,480 --> 00:46:16,640
immunity reference you can also if you

00:46:14,960 --> 00:46:18,560
have experience with concurrency safety

00:46:16,640 --> 00:46:21,680
you can already see where this is going

00:46:18,560 --> 00:46:24,000
rust does not allow you to have

00:46:21,680 --> 00:46:26,640
to look at data and to mute it at the

00:46:24,000 --> 00:46:26,640
same time

00:46:26,880 --> 00:46:32,000
and now that we have read this line

00:46:34,079 --> 00:46:36,800
we return it

00:46:40,160 --> 00:46:44,720
and the other thing that i need to do i

00:46:42,880 --> 00:46:45,680
also need to mark the buffered reader as

00:46:44,720 --> 00:46:48,160
mutable

00:46:45,680 --> 00:46:48,160
because

00:46:49,599 --> 00:46:52,640
this buffered reader

00:46:55,440 --> 00:46:59,040
has a state inside

00:46:59,599 --> 00:47:04,960
the buffer so reading

00:47:08,839 --> 00:47:13,440
sorry

00:47:10,400 --> 00:47:16,400
so reading will write to that buffer

00:47:13,440 --> 00:47:16,400
and we'll mutate it

00:47:17,839 --> 00:47:22,960
if that one fails currently we unwrap

00:47:21,200 --> 00:47:25,839
we don't handle this this returns a

00:47:22,960 --> 00:47:25,839
result

00:47:27,359 --> 00:47:32,319
um the question whether like the answer

00:47:30,880 --> 00:47:35,359
that kevin gave

00:47:32,319 --> 00:47:37,839
i mean to uh

00:47:35,359 --> 00:47:38,559
to ask whether why we need to call this

00:47:37,839 --> 00:47:40,960
a second time

00:47:38,559 --> 00:47:42,640
this is different this is the variable

00:47:40,960 --> 00:47:43,920
is mutable and we're allowed to mutate

00:47:42,640 --> 00:47:46,880
it and

00:47:43,920 --> 00:47:49,119
as kevin says this is correct this is

00:47:46,880 --> 00:47:51,920
now we take immutable reference to it

00:47:49,119 --> 00:47:53,119
so for this to be allowed it needs to be

00:47:51,920 --> 00:47:55,520
immutable

00:47:53,119 --> 00:47:58,880
but we need to reset we need to state

00:47:55,520 --> 00:47:58,880
that we're taking this reference

00:48:00,079 --> 00:48:04,720
this is sometimes seen the question

00:48:03,119 --> 00:48:07,520
whether this can be inferred

00:48:04,720 --> 00:48:09,599
is a is a good one it was actually

00:48:07,520 --> 00:48:10,319
investigated whether we want this to be

00:48:09,599 --> 00:48:13,599
inferred

00:48:10,319 --> 00:48:16,319
and the decision was actually not

00:48:13,599 --> 00:48:17,359
so we want especially at the place where

00:48:16,319 --> 00:48:20,480
we go from

00:48:17,359 --> 00:48:23,440
value to reference we want to be

00:48:20,480 --> 00:48:24,559
visible this is a discussion that has

00:48:23,440 --> 00:48:26,800
been had

00:48:24,559 --> 00:48:27,680
maybe in the future this question this

00:48:26,800 --> 00:48:30,000
is this

00:48:27,680 --> 00:48:31,520
discussion will be had again rust is a

00:48:30,000 --> 00:48:35,280
verbose language

00:48:31,520 --> 00:48:38,319
i can definitely say as much and

00:48:35,280 --> 00:48:38,319
has no problem with that

00:48:39,599 --> 00:48:46,160
okay now this is reading exactly

00:48:42,880 --> 00:48:49,839
one line from the input

00:48:46,160 --> 00:48:49,839
in a function

00:48:53,760 --> 00:48:57,040
the next thing that we would like to do

00:48:55,200 --> 00:49:00,960
is apply our

00:48:57,040 --> 00:49:04,319
very simple parsing rules so

00:49:00,960 --> 00:49:06,559
what we get back here we get the line

00:49:04,319 --> 00:49:06,559
back

00:49:07,440 --> 00:49:11,440
and what we want next is

00:49:11,520 --> 00:49:14,079
figure out

00:49:15,680 --> 00:49:34,079
what the actual request is that we have

00:49:31,680 --> 00:49:35,920
um ariane has the problem i'm getting

00:49:34,079 --> 00:49:38,480
there unknown method named redline

00:49:35,920 --> 00:49:39,440
found for buff reader tcpa um reference

00:49:38,480 --> 00:49:41,839
tcp stream

00:49:39,440 --> 00:49:42,880
in current scope yes that means you need

00:49:41,839 --> 00:49:46,319
to import

00:49:42,880 --> 00:49:48,800
a trait i'm sorry that i've been jumping

00:49:46,319 --> 00:49:48,800
over there

00:49:50,720 --> 00:49:53,760
because the ide did it automatically and

00:49:53,359 --> 00:49:56,480
i

00:49:53,760 --> 00:49:57,119
missed stating that you need use

00:49:56,480 --> 00:50:00,000
standard

00:49:57,119 --> 00:50:01,839
o above read there as well which is the

00:50:00,000 --> 00:50:04,000
buffered reading interface

00:50:01,839 --> 00:50:06,480
so buffered reader is a concrete

00:50:04,000 --> 00:50:08,559
implementation of buffered reading

00:50:06,480 --> 00:50:13,839
but buffered reading is a general

00:50:08,559 --> 00:50:13,839
interface that's available

00:50:15,200 --> 00:50:19,599
if you compile that one if you would

00:50:17,280 --> 00:50:21,520
compile it on the command line

00:50:19,599 --> 00:50:23,599
then the compiler would actually give

00:50:21,520 --> 00:50:25,680
you a list of traits that it knows that

00:50:23,599 --> 00:50:28,319
implement this function

00:50:25,680 --> 00:50:30,640
the reason why you need to import it is

00:50:28,319 --> 00:50:33,440
for forward

00:50:30,640 --> 00:50:34,880
for forward compatibility so if we were

00:50:33,440 --> 00:50:37,200
to add for example a

00:50:34,880 --> 00:50:38,400
another function of a same name in a

00:50:37,200 --> 00:50:40,559
different interface

00:50:38,400 --> 00:50:42,319
importing it explicitly makes it even in

00:50:40,559 --> 00:50:44,880
the future now

00:50:42,319 --> 00:50:46,480
knowing which one you mean that is a

00:50:44,880 --> 00:50:48,559
strategy that rust applies

00:50:46,480 --> 00:50:49,680
a lot to make sure that the code you

00:50:48,559 --> 00:50:53,119
write

00:50:49,680 --> 00:50:54,800
um is actually compiling even in the

00:50:53,119 --> 00:50:57,839
face of interface changes in

00:50:54,800 --> 00:50:59,440
years out unless someone deliberately

00:50:57,839 --> 00:51:00,800
breaks existing interface that obviously

00:50:59,440 --> 00:51:01,920
it doesn't work so if you read line

00:51:00,800 --> 00:51:04,559
would change

00:51:01,920 --> 00:51:05,599
its its type signature its function

00:51:04,559 --> 00:51:09,839
signature then

00:51:05,599 --> 00:51:09,839
that would break

00:51:10,000 --> 00:51:14,240
okay so

00:51:18,800 --> 00:51:23,839
let's apply our request parsing

00:51:27,119 --> 00:51:31,119
again this is a very simple example for

00:51:30,000 --> 00:51:34,240
the sake

00:51:31,119 --> 00:51:37,040
of the tutorial um calling this

00:51:34,240 --> 00:51:40,960
request parsing is probably stretching

00:51:37,040 --> 00:51:40,960
it but the role of it is the same

00:51:43,599 --> 00:51:50,800
and here i want to return a

00:51:46,640 --> 00:51:54,000
structure type and

00:51:50,800 --> 00:51:56,720
you've i talked about these uh

00:51:54,000 --> 00:51:58,319
types that rust has that express

00:51:56,720 --> 00:52:01,040
alternatives and would actually like to

00:51:58,319 --> 00:52:05,119
define one myself

00:52:01,040 --> 00:52:08,240
so what i would like to

00:52:05,119 --> 00:52:11,119
um to build is a

00:52:08,240 --> 00:52:13,440
type that says either you wanted to

00:52:11,119 --> 00:52:17,440
write something to our storage

00:52:13,440 --> 00:52:21,520
or you want to get something out

00:52:17,440 --> 00:52:24,880
and i will define this type

00:52:21,520 --> 00:52:27,920
as a so-called enum enumeration

00:52:24,880 --> 00:52:30,559
call it request and now

00:52:27,920 --> 00:52:31,359
what this gets is so-called variance and

00:52:30,559 --> 00:52:35,920
we have two

00:52:31,359 --> 00:52:35,920
variants publish and retrieve

00:52:36,559 --> 00:52:44,240
so i have publish

00:52:40,559 --> 00:52:46,800
and retrieve but the nice thing here is

00:52:44,240 --> 00:52:48,559
that russ allows us

00:52:46,800 --> 00:52:50,880
some of these variants to actually carry

00:52:48,559 --> 00:52:50,880
data

00:52:51,599 --> 00:52:54,720
so i can say there's two kinds of

00:52:53,599 --> 00:52:58,079
requests

00:52:54,720 --> 00:53:02,720
publish with a payload and retrieve

00:52:58,079 --> 00:53:07,599
which doesn't carry one as i'm here

00:53:02,720 --> 00:53:11,040
i want to show a quick thing here

00:53:07,599 --> 00:53:11,040
which is so called derives

00:53:12,079 --> 00:53:16,880
rust has a debug interface

00:53:15,280 --> 00:53:18,800
and multiple other interesting

00:53:16,880 --> 00:53:20,720
interfaces which can be

00:53:18,800 --> 00:53:22,480
automatically inserted by the compiler

00:53:20,720 --> 00:53:25,839
by you requesting them

00:53:22,480 --> 00:53:28,559
so i can say derive debug and two others

00:53:25,839 --> 00:53:32,000
that i would like to have is eq

00:53:28,559 --> 00:53:34,960
and partial eq this one being

00:53:32,000 --> 00:53:35,839
you can use the debug interpolation

00:53:34,960 --> 00:53:39,200
syntax

00:53:35,839 --> 00:53:40,079
which is hold on question mark with that

00:53:39,200 --> 00:53:44,480
type

00:53:40,079 --> 00:53:44,480
so you can have structured output

00:53:45,359 --> 00:53:48,880
and these two are equality is actually

00:53:48,160 --> 00:53:51,920
defined

00:53:48,880 --> 00:53:55,119
so request equals request

00:53:51,920 --> 00:53:57,359
can be automatically

00:53:55,119 --> 00:53:58,880
be applied you can build custom

00:53:57,359 --> 00:54:00,720
implementations of these so if you

00:53:58,880 --> 00:54:02,319
wanted to you can omit the compiler

00:54:00,720 --> 00:54:05,839
doing that and just

00:54:02,319 --> 00:54:07,680
write your own but for convenience here

00:54:05,839 --> 00:54:09,920
um and because they're so common there's

00:54:07,680 --> 00:54:10,400
this derived interface that allows you

00:54:09,920 --> 00:54:12,559
to

00:54:10,400 --> 00:54:14,480
have the compiler auto-generate that and

00:54:12,559 --> 00:54:16,400
the rule is very simple

00:54:14,480 --> 00:54:18,160
if any of these here internally have

00:54:16,400 --> 00:54:20,800
data

00:54:18,160 --> 00:54:22,800
here for example string then it expects

00:54:20,800 --> 00:54:23,200
that that string also implements debug

00:54:22,800 --> 00:54:25,040
eq

00:54:23,200 --> 00:54:27,200
and partial eq and then again the

00:54:25,040 --> 00:54:28,400
compiler can reason about the structure

00:54:27,200 --> 00:54:31,760
of the request

00:54:28,400 --> 00:54:34,800
type and say okay there's a trivial

00:54:31,760 --> 00:54:38,640
equality and debug implementation here

00:54:34,800 --> 00:54:41,760
the partial eq here is a little bit odd

00:54:38,640 --> 00:54:43,920
um you need that for floats but eq

00:54:41,760 --> 00:54:44,880
cannot be derived without a partial eq

00:54:43,920 --> 00:54:47,520
being present

00:54:44,880 --> 00:54:48,720
so i need both and i think for the first

00:54:47,520 --> 00:54:51,280
couple of years

00:54:48,720 --> 00:54:52,720
of rust development the knowledge that

00:54:51,280 --> 00:54:54,480
that eq cannot

00:54:52,720 --> 00:54:56,480
be derived from that partial eq is

00:54:54,480 --> 00:54:59,760
probably

00:54:56,480 --> 00:55:04,160
uh the one to follow

00:54:59,760 --> 00:55:04,160
like i follow this just blindingly

00:55:04,880 --> 00:55:10,079
okay so now we want to part this request

00:55:07,200 --> 00:55:14,240
and as i said if it's empty

00:55:10,079 --> 00:55:14,240
then i uh

00:55:14,559 --> 00:55:19,200
then i consider this a retrieve request

00:55:17,520 --> 00:55:20,559
if it's not empty i consider this

00:55:19,200 --> 00:55:23,760
publish

00:55:20,559 --> 00:55:26,720
the result of this is

00:55:23,760 --> 00:55:26,720
this request type

00:55:27,280 --> 00:55:30,319
so how do i do this

00:55:30,480 --> 00:55:36,640
first of all i take the line and trim it

00:55:39,680 --> 00:55:43,680
and i use the trim end function

00:55:45,280 --> 00:55:51,440
this is simple this is just

00:55:48,319 --> 00:55:54,559
take all um

00:55:51,440 --> 00:55:56,960
um take all white space new lines

00:55:54,559 --> 00:55:57,760
carriage returns and spaces by the end

00:55:56,960 --> 00:55:59,760
and just

00:55:57,760 --> 00:56:01,599
remove them similar to a trim function

00:55:59,760 --> 00:56:04,799
in ruby pyson

00:56:01,599 --> 00:56:06,640
whatever rust in general has a

00:56:04,799 --> 00:56:08,000
pretty rich standard library interface

00:56:06,640 --> 00:56:10,160
that comes with all of these kind of

00:56:08,000 --> 00:56:14,000
functions

00:56:10,160 --> 00:56:19,440
and now i can go

00:56:14,000 --> 00:56:19,440
and say if trimmed

00:56:20,400 --> 00:56:25,200
equals empty string

00:56:26,880 --> 00:56:33,119
then yeah i want to do one thing

00:56:31,200 --> 00:56:34,319
and else it has not been an empty string

00:56:33,119 --> 00:56:36,480
then it's well

00:56:34,319 --> 00:56:38,960
publish and the other one is the

00:56:36,480 --> 00:56:41,040
retrieve command

00:56:38,960 --> 00:56:43,040
now i need to construct these things and

00:56:41,040 --> 00:56:48,160
the way you construct these enums

00:56:43,040 --> 00:56:48,160
is you name the enum

00:56:48,640 --> 00:56:53,359
and then the variant so this was

00:56:51,200 --> 00:56:58,319
retrieved

00:56:53,359 --> 00:57:01,200
and otherwise

00:56:58,319 --> 00:57:01,200
we use publish

00:57:04,400 --> 00:57:13,839
and now we want to publish

00:57:08,240 --> 00:57:13,839
the trim data

00:57:16,319 --> 00:57:19,520
and run into a problem

00:57:24,839 --> 00:57:30,400
that this here is not a string

00:57:31,359 --> 00:57:36,960
and that's due to

00:57:34,480 --> 00:57:38,640
rust's nature as a systems programming

00:57:36,960 --> 00:57:41,520
language

00:57:38,640 --> 00:57:43,920
because to avoid copying if we have a

00:57:41,520 --> 00:57:43,920
stream

00:57:44,240 --> 00:57:46,880
in memory

00:57:48,880 --> 00:57:55,839
in a second

00:58:00,160 --> 00:58:09,839
it's the classic problem with computers

00:58:03,680 --> 00:58:09,839
they fail the moment you need them

00:58:10,880 --> 00:58:19,359
there we go so

00:58:14,079 --> 00:58:19,359
if we have data in memory

00:58:20,839 --> 00:58:25,680
string

00:58:22,480 --> 00:58:25,680
and we have a new line

00:58:27,760 --> 00:58:31,200
what will be returned

00:58:32,559 --> 00:58:40,000
is reference to a substring abc

00:58:37,680 --> 00:58:40,000
and

00:58:41,440 --> 00:58:44,799
due to the rules that i've laid out

00:58:43,839 --> 00:58:48,319
around ownership

00:58:44,799 --> 00:58:51,440
in rust we take ownership of the string

00:58:48,319 --> 00:58:56,559
buffer here

00:58:51,440 --> 00:58:56,559
that means and this rule is strict

00:58:58,880 --> 00:59:02,839
i'm very sorry for those help things

00:59:01,440 --> 00:59:06,319
popping up

00:59:02,839 --> 00:59:06,319
everywhere see you

00:59:06,880 --> 00:59:10,880
so now that we that we took ownership

00:59:10,319 --> 00:59:12,880
that means

00:59:10,880 --> 00:59:16,240
parts request will actually deallocate

00:59:12,880 --> 00:59:19,760
the string at the end

00:59:16,240 --> 00:59:24,880
of the function and this rule is strict

00:59:19,760 --> 00:59:24,880
so but i've been uh but i'm handing out

00:59:25,440 --> 00:59:32,240
a reference here to the substring

00:59:29,200 --> 00:59:33,760
and i cannot do this because

00:59:32,240 --> 00:59:36,960
i would hand out a reference to

00:59:33,760 --> 00:59:40,319
something that isn't in memory anymore

00:59:36,960 --> 00:59:40,319
our quick fix for this is

00:59:43,119 --> 00:59:50,079
create a new string from that

00:59:47,200 --> 00:59:50,079
and remove this

00:59:54,240 --> 00:59:57,280
one thing to note here

00:59:57,599 --> 01:00:05,200
rust is an expression based language

01:00:01,599 --> 01:00:08,240
similar to for example ruby so

01:00:05,200 --> 01:00:11,760
we can we do don't need to say return

01:00:08,240 --> 01:00:12,160
request retrieve we can in the one arm

01:00:11,760 --> 01:00:14,559
here

01:00:12,160 --> 01:00:15,599
return request retrieve in the other arm

01:00:14,559 --> 01:00:18,640
of the if statement

01:00:15,599 --> 01:00:21,760
request publish and

01:00:18,640 --> 01:00:23,440
that means the if statement always

01:00:21,760 --> 01:00:25,200
returns a request type and we can just

01:00:23,440 --> 01:00:28,559
let that flow out

01:00:25,200 --> 01:00:30,960
into out of the function and we return a

01:00:28,559 --> 01:00:30,960
request

01:00:31,839 --> 01:00:38,559
there's a question by boban which

01:00:36,319 --> 01:00:41,119
whether to use string from trim to own

01:00:38,559 --> 01:00:43,920
or trimmed to string

01:00:41,119 --> 01:00:45,599
there's a fourth form that also exists

01:00:43,920 --> 01:00:48,960
which one to use in which case

01:00:45,599 --> 01:00:51,680
i generally recommend thank you

01:00:48,960 --> 01:00:52,079
i generally recommend um to use a string

01:00:51,680 --> 01:00:53,760
from

01:00:52,079 --> 01:00:55,280
i like that the most but they're

01:00:53,760 --> 01:00:57,200
actually all the same

01:00:55,280 --> 01:00:58,480
they used to be a difference with

01:00:57,200 --> 01:01:03,119
tostring was actually

01:00:58,480 --> 01:01:06,240
faster due to um in inadequate compiler

01:01:03,119 --> 01:01:06,640
optimizations that is gone since rust

01:01:06,240 --> 01:01:10,079
won

01:01:06,640 --> 01:01:13,200
six so use whatever

01:01:10,079 --> 01:01:15,599
feels best in the current situation in

01:01:13,200 --> 01:01:15,599
this case

01:01:17,680 --> 01:01:21,040
yeah now we have this request

01:01:21,760 --> 01:01:28,960
and now what we can do

01:01:25,280 --> 01:01:32,160
is we can again let those types help us

01:01:28,960 --> 01:01:32,160
in our program flow

01:01:33,280 --> 01:01:39,760
and because we now have this enum type

01:01:37,599 --> 01:01:41,040
and i've seen where this is going enums

01:01:39,760 --> 01:01:43,839
get matched upon

01:01:41,040 --> 01:01:45,920
match is like you use match far more

01:01:43,839 --> 01:01:46,720
often in rust than if and else this is

01:01:45,920 --> 01:01:50,240
the

01:01:46,720 --> 01:01:53,200
standard way of of doing any kind of

01:01:50,240 --> 01:01:54,079
branching or decision making so now we

01:01:53,200 --> 01:01:56,799
can match

01:01:54,079 --> 01:01:56,799
the request

01:01:58,079 --> 01:02:03,280
here and

01:02:04,839 --> 01:02:09,599
again

01:02:06,160 --> 01:02:13,119
now i have uh

01:02:09,599 --> 01:02:14,720
roster as a fill in the the arms here

01:02:13,119 --> 01:02:16,480
now we can match on this request and now

01:02:14,720 --> 01:02:21,839
we can figure out okay was it published

01:02:16,480 --> 01:02:21,839
or was it retrieve and what do we do

01:02:27,520 --> 01:02:32,079
and this is we published a message and

01:02:29,359 --> 01:02:34,640
here we retrieve a message

01:02:32,079 --> 01:02:37,680
and for the sake of debugging the first

01:02:34,640 --> 01:02:37,680
thing that i would like to do

01:02:46,839 --> 01:02:52,319
is

01:02:49,760 --> 01:02:52,319
let's use

01:02:54,160 --> 01:02:58,720
um wrong way around publishing

01:02:59,359 --> 01:03:04,000
there we go so we can use this data type

01:03:02,559 --> 01:03:07,680
that we've used that expressed

01:03:04,000 --> 01:03:10,960
these two alternatives here to uh

01:03:07,680 --> 01:03:13,760
to guide ourselves through um

01:03:10,960 --> 01:03:15,359
our reaction to those requests it's

01:03:13,760 --> 01:03:18,559
essentially if you look

01:03:15,359 --> 01:03:20,319
this is a little bit of a router here um

01:03:18,559 --> 01:03:21,920
i would not use this like i would not

01:03:20,319 --> 01:03:25,359
use match as a router

01:03:21,920 --> 01:03:27,920
for any kinds of systems um there's more

01:03:25,359 --> 01:03:27,920
uh this

01:03:29,599 --> 01:03:32,640
actually systems for that but this is

01:03:31,280 --> 01:03:34,640
how you go through all those

01:03:32,640 --> 01:03:38,799
alternatives

01:03:34,640 --> 01:03:38,799
and i would like to run this

01:03:39,760 --> 01:03:46,160
and it works so if i go now

01:03:44,079 --> 01:03:48,720
and say tell that you'll see another bad

01:03:46,160 --> 01:03:48,720
thing about

01:03:49,440 --> 01:03:53,599
windows telnet in a second which is that

01:03:52,799 --> 01:03:58,559
it doesn't

01:03:53,599 --> 01:04:02,319
present the input that i'm writing

01:03:58,559 --> 01:04:02,319
and you can see here publishing message

01:04:02,559 --> 01:04:08,960
and if i just hit enter once

01:04:06,079 --> 01:04:10,000
it will say retrieving message so sorry

01:04:08,960 --> 01:04:13,280
for not

01:04:10,000 --> 01:04:15,920
being able to present that

01:04:13,280 --> 01:04:15,920
visually

01:04:19,760 --> 01:04:28,880
so now we have two of these things

01:04:26,000 --> 01:04:29,680
now the only and you might have noticed

01:04:28,880 --> 01:04:33,359
i've

01:04:29,680 --> 01:04:36,240
not been doing uh i've

01:04:33,359 --> 01:04:36,960
been using the type system to let me

01:04:36,240 --> 01:04:40,319
flow

01:04:36,960 --> 01:04:42,799
through um

01:04:40,319 --> 01:04:44,720
the things that i wanted to do and i've

01:04:42,799 --> 01:04:47,680
only added

01:04:44,720 --> 01:04:48,799
this one data type where i introduced my

01:04:47,680 --> 01:04:50,640
own alternative

01:04:48,799 --> 01:04:52,799
my own semantics here there's a probable

01:04:50,640 --> 01:04:54,880
request and there's a retrieve request

01:04:52,799 --> 01:04:57,760
the rest i've been flowing through the

01:04:54,880 --> 01:04:57,760
type system here

01:04:58,240 --> 01:05:04,400
and now now that i'm faced with this

01:05:01,680 --> 01:05:07,359
decision now i have a problem

01:05:04,400 --> 01:05:08,000
i actually want to store store data and

01:05:07,359 --> 01:05:12,319
i have no

01:05:08,000 --> 01:05:12,319
storage and

01:05:12,799 --> 01:05:19,280
um i

01:05:16,160 --> 01:05:23,440
uh on a new question um it

01:05:19,280 --> 01:05:25,119
it does actually take my um

01:05:23,440 --> 01:05:26,480
it does actually take my input it just

01:05:25,119 --> 01:05:30,640
doesn't echo it

01:05:26,480 --> 01:05:34,640
so that's the annoying part here

01:05:30,640 --> 01:05:38,000
so i would actually just go and

01:05:34,640 --> 01:05:41,359
pop this shell here off

01:05:38,000 --> 01:05:45,440
so that you see the actual reaction okay

01:05:41,359 --> 01:05:47,920
so again coming back to this now i need

01:05:45,440 --> 01:05:47,920
storage

01:05:48,839 --> 01:05:55,200
and the

01:05:52,240 --> 01:05:56,559
this is again something that i just pull

01:05:55,200 --> 01:06:01,039
out of my knowledge there's

01:05:56,559 --> 01:06:05,839
the rust standard library has a

01:06:01,039 --> 01:06:05,839
nice type called

01:06:09,599 --> 01:06:13,599
vector q it's a double ended queue based

01:06:13,200 --> 01:06:15,920
on

01:06:13,599 --> 01:06:16,799
backed by a vector the nice thing around

01:06:15,920 --> 01:06:19,039
that is

01:06:16,799 --> 01:06:19,920
it allows me to push something in the

01:06:19,039 --> 01:06:22,960
back

01:06:19,920 --> 01:06:24,319
and pop it out from the front in

01:06:22,960 --> 01:06:26,000
difference to a normal

01:06:24,319 --> 01:06:27,520
vector type that rust has that only

01:06:26,000 --> 01:06:30,000
allows me to push in the back

01:06:27,520 --> 01:06:31,039
and pop the last element and i wanted to

01:06:30,000 --> 01:06:33,119
have this kind of

01:06:31,039 --> 01:06:34,720
first in first out behavior so pushing

01:06:33,119 --> 01:06:37,680
back taking from the front is the

01:06:34,720 --> 01:06:37,680
semantics that i want

01:06:43,760 --> 01:06:50,400
and how do we

01:06:47,119 --> 01:06:52,400
do a handlers this piece of storage

01:06:50,400 --> 01:06:54,240
the problem is i cannot create it in

01:06:52,400 --> 01:06:57,359
handle client

01:06:54,240 --> 01:07:01,760
why if we go back

01:06:57,359 --> 01:07:04,160
to this picture here

01:07:01,760 --> 01:07:04,799
if i were to create the storage in here

01:07:04,160 --> 01:07:08,319
so

01:07:04,799 --> 01:07:10,480
the networking layer calls for

01:07:08,319 --> 01:07:11,680
my main there your calls into the

01:07:10,480 --> 01:07:14,480
handler

01:07:11,680 --> 01:07:14,960
and if i were to create like the queue

01:07:14,480 --> 01:07:17,119
here

01:07:14,960 --> 01:07:18,720
i would doing every request actually

01:07:17,119 --> 01:07:20,880
destroy it again so i need to

01:07:18,720 --> 01:07:22,720
make sure that it actually outlives

01:07:20,880 --> 01:07:24,720
handle client

01:07:22,720 --> 01:07:27,039
and lives longer than the call to handle

01:07:24,720 --> 01:07:30,319
client so in some way

01:07:27,039 --> 01:07:34,400
it needs to be passed in here

01:07:30,319 --> 01:07:37,520
and as we've learned

01:07:34,400 --> 01:07:40,960
we can take storage

01:07:37,520 --> 01:07:42,240
in a way that is mutable but reference

01:07:40,960 --> 01:07:46,079
so it's owned

01:07:42,240 --> 01:07:48,079
by the by anyone who's outside of handle

01:07:46,079 --> 01:07:52,880
client

01:07:48,079 --> 01:07:56,559
and uh um

01:07:52,880 --> 01:07:58,319
yeah so it's handled by anyone who's uh

01:07:56,559 --> 01:07:59,680
who is outside of the handle client

01:07:58,319 --> 01:08:02,160
function

01:07:59,680 --> 01:08:03,280
but is willing to give me mutable access

01:08:02,160 --> 01:08:06,160
to it

01:08:03,280 --> 01:08:08,839
the way we do this is ampersand we take

01:08:06,160 --> 01:08:13,200
a mutable reference to a back to q

01:08:08,839 --> 01:08:14,720
string this one being one that stores

01:08:13,200 --> 01:08:16,560
strings which is our current message

01:08:14,720 --> 01:08:18,159
type we can just later

01:08:16,560 --> 01:08:20,719
actually introduce a proper structured

01:08:18,159 --> 01:08:25,839
message type if we want to

01:08:20,719 --> 01:08:25,839
the uh way would be the same

01:08:28,319 --> 01:08:32,400
um there's a question olga is there not

01:08:30,400 --> 01:08:34,960
a lot of go channels and rust

01:08:32,400 --> 01:08:35,440
not as a language feature it's actually

01:08:34,960 --> 01:08:38,319
rust

01:08:35,440 --> 01:08:40,159
did have in language channels at some

01:08:38,319 --> 01:08:43,839
point as a research prototype

01:08:40,159 --> 01:08:46,880
um there are channels um in

01:08:43,839 --> 01:08:49,839
um that can be found in standard lib

01:08:46,880 --> 01:08:50,880
yeah and um as supreme mentions there's

01:08:49,839 --> 01:08:52,880
uh

01:08:50,880 --> 01:08:55,199
for example the cross beam crate allows

01:08:52,880 --> 01:08:56,880
that the nice thing about channels is

01:08:55,199 --> 01:08:57,600
that they also work by this ownership

01:08:56,880 --> 01:08:59,839
principle

01:08:57,600 --> 01:09:00,960
you push something into you send

01:08:59,839 --> 01:09:03,359
something through a channel

01:09:00,960 --> 01:09:04,000
it takes it away from the sender and it

01:09:03,359 --> 01:09:05,679
takes

01:09:04,000 --> 01:09:07,120
and and gives the ownership to the other

01:09:05,679 --> 01:09:09,040
side so there's

01:09:07,120 --> 01:09:10,319
um there's no chance to accidentally

01:09:09,040 --> 01:09:12,880
refer um

01:09:10,319 --> 01:09:14,799
for example to send away data from the

01:09:12,880 --> 01:09:17,279
thing that has just sent

01:09:14,799 --> 01:09:17,279
the data

01:09:18,839 --> 01:09:24,799
um

01:09:21,759 --> 01:09:26,880
okay um so i need

01:09:24,799 --> 01:09:29,040
to create my data structure here so i

01:09:26,880 --> 01:09:35,520
take lot storage

01:09:29,040 --> 01:09:37,600
equals back to cue

01:09:35,520 --> 01:09:37,600
u

01:09:41,600 --> 01:09:46,799
this will yield an error

01:09:44,799 --> 01:09:48,640
because it doesn't know which style

01:09:46,799 --> 01:09:51,120
which type the vector q is but that will

01:09:48,640 --> 01:09:54,560
immediately go away

01:09:51,120 --> 01:09:57,440
if i actually pass the search over here

01:09:54,560 --> 01:09:57,440
to handle client

01:09:58,320 --> 01:10:06,000
needs to be mutable

01:10:02,800 --> 01:10:06,320
so i can actually give it away and now

01:10:06,000 --> 01:10:08,960
on

01:10:06,320 --> 01:10:09,440
every loop doing every connection i give

01:10:08,960 --> 01:10:12,480
you

01:10:09,440 --> 01:10:13,199
the story the storage over uh to handle

01:10:12,480 --> 01:10:15,199
client

01:10:13,199 --> 01:10:16,719
can write something or read from it and

01:10:15,199 --> 01:10:18,159
then on the next loop it will be passed

01:10:16,719 --> 01:10:21,840
to the next client handler

01:10:18,159 --> 01:10:24,400
on the next loop iteration and

01:10:21,840 --> 01:10:26,800
over here that's simple what do i do in

01:10:24,400 --> 01:10:26,800
publish

01:10:28,960 --> 01:10:31,679
dot push back

01:10:40,800 --> 01:10:45,120
it stores that but now what do you do in

01:10:44,400 --> 01:10:48,480
retrieve

01:10:45,120 --> 01:10:48,480
and this is again a nice thing

01:10:52,880 --> 01:10:59,840
um now i try to to

01:10:56,640 --> 01:10:59,840
get a message out

01:11:00,080 --> 01:11:02,239
but

01:11:04,239 --> 01:11:12,640
what if the queue is empty

01:11:07,280 --> 01:11:15,360
so i may get a message or not

01:11:12,640 --> 01:11:15,360
so let's try

01:11:19,440 --> 01:11:23,600
the corresponding method is pop front

01:11:24,239 --> 01:11:28,719
gives me the it gives me this data and

01:11:26,880 --> 01:11:32,000
now let's have a look at what this

01:11:28,719 --> 01:11:35,040
variable is and it is

01:11:32,000 --> 01:11:38,400
option string

01:11:35,040 --> 01:11:41,600
and that says well it might be there

01:11:38,400 --> 01:11:42,480
or not and again this is an enum like

01:11:41,600 --> 01:11:45,040
the results

01:11:42,480 --> 01:11:46,480
or the one that i introduced tells me

01:11:45,040 --> 01:11:48,800
these are the two child

01:11:46,480 --> 01:11:50,960
the two things that may happen either

01:11:48,800 --> 01:11:54,800
there was nothing in

01:11:50,960 --> 01:11:58,159
the storage or um

01:11:54,800 --> 01:12:01,440
you um well or you can

01:11:58,159 --> 01:12:01,440
write it to the client if you want to

01:12:02,800 --> 01:12:05,520
so let's match

01:12:06,840 --> 01:12:09,840
again

01:12:16,640 --> 01:12:20,719
so if there was a message

01:12:21,120 --> 01:12:28,640
we need to write to the client

01:12:25,199 --> 01:12:33,520
and if there was no message

01:12:28,640 --> 01:12:33,520
let's write new message

01:12:35,520 --> 01:12:39,600
and here's where i need to stream again

01:12:38,480 --> 01:12:43,199
now i can say

01:12:39,600 --> 01:12:43,199
stream dot write all

01:12:44,080 --> 01:12:50,880
message the stream takes bytes

01:12:48,159 --> 01:12:53,600
so a string is not bytes but it can be

01:12:50,880 --> 01:12:56,640
seen as such

01:12:53,600 --> 01:12:57,520
and i use the azvice methods to turn it

01:12:56,640 --> 01:12:59,040
into one

01:12:57,520 --> 01:13:01,440
there's quite a bit to a wrap here in

01:12:59,040 --> 01:13:03,199
this line

01:13:01,440 --> 01:13:05,120
first of all rust takes a very

01:13:03,199 --> 01:13:08,080
structured way on its linger

01:13:05,120 --> 01:13:09,360
so if i can interpret something as

01:13:08,080 --> 01:13:11,280
something else

01:13:09,360 --> 01:13:13,280
the functions that do that are always

01:13:11,280 --> 01:13:17,360
called as underscore

01:13:13,280 --> 01:13:20,159
so this is no copy or whatever

01:13:17,360 --> 01:13:20,640
involved this is strings can be seen as

01:13:20,159 --> 01:13:22,159
bytes

01:13:20,640 --> 01:13:24,320
not the other way around bytes are not

01:13:22,159 --> 01:13:27,440
always youtube eight strings

01:13:24,320 --> 01:13:30,800
messages bytes and you can uh

01:13:27,440 --> 01:13:34,400
you basically just turn it into

01:13:30,800 --> 01:13:37,520
the different type and then there's the

01:13:34,400 --> 01:13:37,520
write-all function here

01:13:37,679 --> 01:13:47,840
which you actually need to import a

01:13:41,920 --> 01:13:47,840
trade for the right trade

01:13:49,520 --> 01:13:53,120
which writes all of these out

01:13:54,239 --> 01:13:58,880
to the client slight warning here

01:13:57,280 --> 01:14:00,560
rust does not protect you from

01:13:58,880 --> 01:14:04,080
functional mistakes there's

01:14:00,560 --> 01:14:04,719
also a write method the write method

01:14:04,080 --> 01:14:07,520
will write

01:14:04,719 --> 01:14:10,080
as many bytes as it currently can until

01:14:07,520 --> 01:14:13,520
it would block

01:14:10,080 --> 01:14:14,000
the write all will write all the bytes

01:14:13,520 --> 01:14:17,199
on the right

01:14:14,000 --> 01:14:19,280
side and wait this to be done this is a

01:14:17,199 --> 01:14:20,560
frequent mistake here people using write

01:14:19,280 --> 01:14:22,480
and then later if they write

01:14:20,560 --> 01:14:25,679
more data actually losing data to the

01:14:22,480 --> 01:14:29,679
right because they forget writing

01:14:25,679 --> 01:14:32,320
the data

01:14:29,679 --> 01:14:33,840
yeah there's a problem here which is the

01:14:32,320 --> 01:14:35,199
stream needs to be immutable so that i

01:14:33,840 --> 01:14:40,080
can actually write to it

01:14:35,199 --> 01:14:41,840
there we go happy to oblige

01:14:40,080 --> 01:14:43,679
there might be arrows happening here

01:14:41,840 --> 01:14:46,000
which the compiler will call me out on

01:14:43,679 --> 01:14:47,760
it says there's a result being returned

01:14:46,000 --> 01:14:49,360
here but you're not using it

01:14:47,760 --> 01:14:51,840
you're not checking whether it actually

01:14:49,360 --> 01:14:54,080
works and that actually being a warning

01:14:51,840 --> 01:14:55,920
and the compiler being annoying about

01:14:54,080 --> 01:14:58,800
hey you haven't checked whether that

01:14:55,920 --> 01:14:58,800
actually succeeded

01:14:59,120 --> 01:15:02,800
is a good thing even though i'm choosing

01:15:01,360 --> 01:15:05,199
again here to just say

01:15:02,800 --> 01:15:06,800
unwrap then then let it crash if that

01:15:05,199 --> 01:15:08,080
happens then let it crash but at least

01:15:06,800 --> 01:15:10,080
i'm seeing if the

01:15:08,080 --> 01:15:12,000
like i will see it very visibly by my

01:15:10,080 --> 01:15:12,719
program crashing if that condition was

01:15:12,000 --> 01:15:15,280
met

01:15:12,719 --> 01:15:16,560
because now i am checking it but my

01:15:15,280 --> 01:15:19,040
check is basically

01:15:16,560 --> 01:15:20,000
if the condition actually happens then

01:15:19,040 --> 01:15:23,760
um

01:15:20,000 --> 01:15:27,440
then yeah fail hard

01:15:23,760 --> 01:15:27,440
and what i do with there's nothing

01:15:28,480 --> 01:15:33,280
i will send a small message

01:15:33,360 --> 01:15:39,840
to the user

01:15:42,800 --> 01:15:49,360
um and i'll say no message

01:15:46,800 --> 01:15:49,360
available

01:15:50,480 --> 01:15:57,440
there we go same thing

01:15:54,880 --> 01:15:57,440
may fail

01:16:00,800 --> 01:16:07,840
there we go

01:16:09,540 --> 01:16:14,330
[Laughter]

01:16:16,960 --> 01:16:21,840
and now i build and run this

01:16:32,960 --> 01:16:35,840
and

01:16:37,120 --> 01:16:41,120
after i challenge it again yeah i said i

01:16:39,679 --> 01:16:45,280
i won't show you a window that

01:16:41,120 --> 01:16:49,040
prints nothing so just tell you

01:16:45,280 --> 01:16:52,159
verbally what i do

01:16:49,040 --> 01:16:52,159
so if i send a message

01:16:54,320 --> 01:16:59,920
it will be stored i actually removed the

01:16:57,199 --> 01:17:03,920
logging statement so

01:16:59,920 --> 01:17:08,320
sorry for that and

01:17:03,920 --> 01:17:08,320
if i connect again but now i type

01:17:08,400 --> 01:17:12,880
nothing then it will retrieve that

01:17:11,440 --> 01:17:15,760
message

01:17:12,880 --> 01:17:19,280
and if i go again and type nothing it

01:17:15,760 --> 01:17:19,280
will write me no message available

01:17:20,640 --> 01:17:24,400
and again i've been using the type

01:17:22,719 --> 01:17:27,199
system here to guide me

01:17:24,400 --> 01:17:27,840
by saying oh okay so the two things that

01:17:27,199 --> 01:17:31,280
could happen

01:17:27,840 --> 01:17:31,840
if i pop from a collection is data could

01:17:31,280 --> 01:17:35,440
be there

01:17:31,840 --> 01:17:38,719
for data could not be there and

01:17:35,440 --> 01:17:41,679
then react on that

01:17:38,719 --> 01:17:43,600
and let myself be guided by this by this

01:17:41,679 --> 01:17:44,480
type level flow where the type system

01:17:43,600 --> 01:17:46,640
can express

01:17:44,480 --> 01:17:47,920
this kind of branching behavior these

01:17:46,640 --> 01:17:49,280
are the two things that you need to

01:17:47,920 --> 01:17:51,199
cover

01:17:49,280 --> 01:17:53,040
data has been there or not in other

01:17:51,199 --> 01:17:55,760
languages that would often be

01:17:53,040 --> 01:17:56,320
um abstracted to an outpoint or a null

01:17:55,760 --> 01:17:58,960
value

01:17:56,320 --> 01:18:01,280
rust doesn't have nil or now it uses

01:17:58,960 --> 01:18:03,199
these kind of option types here

01:18:01,280 --> 01:18:04,960
and through compiler optimizations that

01:18:03,199 --> 01:18:05,520
doesn't actually cost me anything so

01:18:04,960 --> 01:18:10,480
this is

01:18:05,520 --> 01:18:10,480
as costly as a null pointer check here

01:18:10,960 --> 01:18:13,840
in the back

01:18:16,320 --> 01:18:21,840
um for albert um

01:18:19,440 --> 01:18:23,280
the the stream making the stream mutable

01:18:21,840 --> 01:18:27,679
is um

01:18:23,280 --> 01:18:30,719
just annotating is it as immutable here

01:18:27,679 --> 01:18:32,320
and for writer the trait that needs to

01:18:30,719 --> 01:18:35,520
be

01:18:32,320 --> 01:18:41,840
imported is the right trait also from

01:18:35,520 --> 01:18:41,840
the io module

01:18:44,320 --> 01:18:46,640
okay

01:18:50,320 --> 01:18:57,360
so we're done here

01:18:55,120 --> 01:18:57,360
um

01:19:00,560 --> 01:19:04,320
on the question on adrian's question why

01:19:02,560 --> 01:19:07,120
don't we need to specify the stream as

01:19:04,320 --> 01:19:09,440
immutable when we pass it in

01:19:07,120 --> 01:19:10,960
precisely because we have not used it in

01:19:09,440 --> 01:19:14,800
immutable fashion

01:19:10,960 --> 01:19:16,640
um at all before

01:19:14,800 --> 01:19:17,920
so this happens because this is the

01:19:16,640 --> 01:19:20,800
first time we're writing

01:19:17,920 --> 01:19:22,800
um we're writing to it and yes this is

01:19:20,800 --> 01:19:26,640
because of ownership

01:19:22,800 --> 01:19:29,760
in rus there's a the ownership principle

01:19:26,640 --> 01:19:32,960
basically says there's only one owner

01:19:29,760 --> 01:19:34,320
in the in the whole world essentially of

01:19:32,960 --> 01:19:36,880
any piece of data

01:19:34,320 --> 01:19:38,320
so and this owner can actually decide

01:19:36,880 --> 01:19:39,120
for example to make immutable data

01:19:38,320 --> 01:19:41,199
immutable or

01:19:39,120 --> 01:19:42,960
immutable data immutable so at this

01:19:41,199 --> 01:19:43,199
place this is really just a choice and

01:19:42,960 --> 01:19:46,400
an

01:19:43,199 --> 01:19:48,560
and an annotation which is well

01:19:46,400 --> 01:19:50,000
the well the compiler diagnostic tells

01:19:48,560 --> 01:19:52,080
you well

01:19:50,000 --> 01:19:53,360
it's not mutable but you can add mood

01:19:52,080 --> 01:19:55,360
here and then it is

01:19:53,360 --> 01:19:57,040
but this is own this is a privilege that

01:19:55,360 --> 01:20:00,000
only owners have

01:19:57,040 --> 01:20:01,199
um i can not make an immutable reference

01:20:00,000 --> 01:20:05,840
for example mutable

01:20:01,199 --> 01:20:05,840
or things like that

01:20:07,280 --> 01:20:09,600
okay

01:20:10,480 --> 01:20:12,800
so

01:20:14,320 --> 01:20:21,199
now coming back

01:20:19,120 --> 01:20:22,880
to this initial image this is basically

01:20:21,199 --> 01:20:23,600
what we built so we have this connection

01:20:22,880 --> 01:20:26,960
loop

01:20:23,600 --> 01:20:26,960
and we have this handle client

01:20:27,360 --> 01:20:29,679
um

01:20:30,400 --> 01:20:36,480
question from adrian um is it similar to

01:20:34,239 --> 01:20:39,840
const correctness

01:20:36,480 --> 01:20:40,239
um yeah a lot of similarities exist

01:20:39,840 --> 01:20:43,600
there

01:20:40,239 --> 01:20:45,679
i generally recommend not to apply too

01:20:43,600 --> 01:20:47,600
many c-class plus principles to rust

01:20:45,679 --> 01:20:50,800
directly

01:20:47,600 --> 01:20:50,800
i give my case for it

01:20:52,239 --> 01:20:59,920
rust is much more

01:20:55,760 --> 01:21:03,120
if if c is here and c plus plus is here

01:20:59,920 --> 01:21:06,400
rust actually lands kind of over here

01:21:03,120 --> 01:21:08,239
and adds c plus generics in in a way

01:21:06,400 --> 01:21:09,679
um rust is a data structures and

01:21:08,239 --> 01:21:12,800
functions language

01:21:09,679 --> 01:21:16,000
much like c and doesn't have

01:21:12,800 --> 01:21:19,520
a lot of concepts that c plus ads um

01:21:16,000 --> 01:21:22,800
adds on top um but yeah if it

01:21:19,520 --> 01:21:25,440
if it helps you like as a first um

01:21:22,800 --> 01:21:29,040
as a first approach um yeah these things

01:21:25,440 --> 01:21:31,600
can be seen

01:21:29,040 --> 01:21:33,920
um how do you get the documentation

01:21:31,600 --> 01:21:36,320
interface

01:21:33,920 --> 01:21:36,320
um

01:21:37,760 --> 01:21:41,600
that's a good question that maybe a rust

01:21:39,760 --> 01:21:44,639
analyzer bug

01:21:41,600 --> 01:21:44,639
chris so

01:21:44,960 --> 01:21:48,560
i'm not sure if i can quickly help with

01:21:46,400 --> 01:21:48,560
that

01:21:49,280 --> 01:21:51,600
sorry

01:21:53,520 --> 01:21:57,040
and sometimes if you have both the rust

01:21:55,440 --> 01:21:59,920
plug-in and the rust analyzer

01:21:57,040 --> 01:22:02,560
plug-in installed de-installing the rush

01:21:59,920 --> 01:22:02,560
plug-in may help

01:22:06,560 --> 01:22:14,480
oh there's one thing that may help

01:22:10,560 --> 01:22:17,040
if you have vs code running for days

01:22:14,480 --> 01:22:18,639
like i sometimes do if there's a vs code

01:22:17,040 --> 01:22:20,320
update in between

01:22:18,639 --> 01:22:22,000
the language server for for a rust

01:22:20,320 --> 01:22:23,760
analyzer will not install cleanly

01:22:22,000 --> 01:22:26,080
because that case cannot be properly

01:22:23,760 --> 01:22:26,880
handled so sometimes like just quitting

01:22:26,080 --> 01:22:31,600
this code and

01:22:26,880 --> 01:22:31,600
starting it up again um may help

01:22:32,880 --> 01:22:38,239
okay um there's something where i would

01:22:36,000 --> 01:22:39,440
like to spend the the last uh half an

01:22:38,239 --> 01:22:42,560
hour on

01:22:39,440 --> 01:22:45,600
and it's probably the

01:22:42,560 --> 01:22:47,360
most interesting part here is the

01:22:45,600 --> 01:22:52,080
problem that we now

01:22:47,360 --> 01:22:55,120
well not a problem but something that we

01:22:52,080 --> 01:22:58,400
sometimes that we observe here is

01:22:55,120 --> 01:23:02,560
we have this connection loop

01:22:58,400 --> 01:23:04,480
but um so as part of the connection loop

01:23:02,560 --> 01:23:07,840
we're calling into handle client

01:23:04,480 --> 01:23:07,840
and we're coming back here

01:23:08,639 --> 01:23:12,719
and this is completely synchronous so

01:23:10,480 --> 01:23:16,480
we're handling one

01:23:12,719 --> 01:23:18,400
client at a time the kernel buffers that

01:23:16,480 --> 01:23:19,120
for us so we're not losing any clients

01:23:18,400 --> 01:23:21,760
but we're

01:23:19,120 --> 01:23:22,320
going one by one and for that reason

01:23:21,760 --> 01:23:24,239
well we

01:23:22,320 --> 01:23:27,600
basically have no parallels more

01:23:24,239 --> 01:23:29,760
concurrency problems because

01:23:27,600 --> 01:23:32,400
there is none so one thing that i would

01:23:29,760 --> 01:23:35,199
like to do for the last half an hour

01:23:32,400 --> 01:23:36,560
is actually take this and put it on a

01:23:35,199 --> 01:23:38,800
thread

01:23:36,560 --> 01:23:39,920
and the principles that i'm going to

01:23:38,800 --> 01:23:43,520
show here

01:23:39,920 --> 01:23:47,520
will be just as applicable to

01:23:43,520 --> 01:23:49,280
um async systems in in rust as well

01:23:47,520 --> 01:23:51,280
so for example things like tokyo or

01:23:49,280 --> 01:23:54,639
async stood or

01:23:51,280 --> 01:23:57,120
all those um so

01:23:54,639 --> 01:23:57,840
the the safety mechanisms that rust

01:23:57,120 --> 01:24:00,639
supplies are

01:23:57,840 --> 01:24:02,320
exactly the same um especially because

01:24:00,639 --> 01:24:04,159
all of those run times are

01:24:02,320 --> 01:24:06,159
always multi-threaded runtime so the

01:24:04,159 --> 01:24:09,679
problem of multi-threading

01:24:06,159 --> 01:24:11,679
is always the dominant one here

01:24:09,679 --> 01:24:13,760
i just find it easier to explain that

01:24:11,679 --> 01:24:15,440
using threads because they're

01:24:13,760 --> 01:24:18,639
a little bit of a simpler primitive that

01:24:15,440 --> 01:24:21,120
does not mean need

01:24:18,639 --> 01:24:23,520
understanding of the whole user space

01:24:21,120 --> 01:24:26,239
runtime that also comes with

01:24:23,520 --> 01:24:27,440
with these kind of things but you can

01:24:26,239 --> 01:24:30,159
definitely

01:24:27,440 --> 01:24:32,880
take this example take async still or

01:24:30,159 --> 01:24:35,920
tokyo and turn it into an async one

01:24:32,880 --> 01:24:36,480
um using uh the types provided by those

01:24:35,920 --> 01:24:39,679
two

01:24:36,480 --> 01:24:43,440
and turn it into an async one in yeah

01:24:39,679 --> 01:24:46,400
a matter of minutes so

01:24:43,440 --> 01:24:46,400
um yeah

01:24:48,239 --> 01:24:56,239
and now

01:24:51,679 --> 01:24:56,239
i want to be just very naive here

01:24:56,719 --> 01:25:01,600
and just wrap a thread around handle

01:24:59,280 --> 01:25:01,600
client

01:25:03,280 --> 01:25:13,840
and this is where where rust shines

01:25:07,840 --> 01:25:13,840
so rust has a spawn function

01:25:15,280 --> 01:25:27,840
bear with me for a second for the syntax

01:25:28,880 --> 01:25:35,520
that's the spawn function and

01:25:32,880 --> 01:25:37,440
the syntax here is simply this is an

01:25:35,520 --> 01:25:39,440
anonymous function that is the

01:25:37,440 --> 01:25:41,120
that is the actual function that will be

01:25:39,440 --> 01:25:42,639
executed on the thread

01:25:41,120 --> 01:25:45,360
and once you're crossing the boundary to

01:25:42,639 --> 01:25:47,040
this function move ownership so it

01:25:45,360 --> 01:25:48,719
takes ownership of everything from the

01:25:47,040 --> 01:25:52,239
outside

01:25:48,719 --> 01:25:53,760
this is the if you this is copied from

01:25:52,239 --> 01:25:56,960
the standard thread spawn

01:25:53,760 --> 01:25:59,440
interface the interesting here is

01:25:56,960 --> 01:26:01,920
that's a mistake and the compiler will

01:25:59,440 --> 01:26:01,920
catch that

01:26:02,320 --> 01:26:04,560
and

01:26:06,960 --> 01:26:13,199
what it will use um yes tokyo's outside

01:26:10,960 --> 01:26:17,040
of scope for this workshop

01:26:13,199 --> 01:26:18,639
but yes you as as written tokyo spawn

01:26:17,040 --> 01:26:21,840
and and all of these things will just

01:26:18,639 --> 01:26:23,199
work um

01:26:21,840 --> 01:26:24,960
and they have similar semantics

01:26:23,199 --> 01:26:28,320
particularly around the moving

01:26:24,960 --> 01:26:30,400
so for the sake of this workshop it's

01:26:28,320 --> 01:26:33,920
completely fine if you replace thread

01:26:30,400 --> 01:26:35,360
by task and it will work it will behave

01:26:33,920 --> 01:26:38,159
just the same and the principles

01:26:35,360 --> 01:26:43,040
especially around moving ownership

01:26:38,159 --> 01:26:43,040
are are the same

01:26:48,639 --> 01:26:52,960
okay so um

01:26:55,840 --> 01:27:03,360
the thing that it catches me doing here

01:26:59,520 --> 01:27:06,719
is okay i'm trying to move

01:27:03,360 --> 01:27:08,880
ownership of the data here

01:27:06,719 --> 01:27:11,440
into the thread because of this move

01:27:08,880 --> 01:27:11,440
annotation

01:27:12,159 --> 01:27:20,080
and i'm going to show that on

01:27:17,040 --> 01:27:21,360
the console rather

01:27:20,080 --> 01:27:23,360
because it gives me a little bit more

01:27:21,360 --> 01:27:25,280
space

01:27:23,360 --> 01:27:27,199
so it says you're moving this log into

01:27:25,280 --> 01:27:29,440
the closure

01:27:27,199 --> 01:27:29,440
and

01:27:30,480 --> 01:27:35,440
it knows that i'm looping here so if i

01:27:33,280 --> 01:27:37,840
were to give this data away to the first

01:27:35,440 --> 01:27:37,840
thread

01:27:38,000 --> 01:27:43,840
it will say okay so

01:27:41,199 --> 01:27:45,199
now if i iterate again like what a what

01:27:43,840 --> 01:27:49,120
do i have to give away

01:27:45,199 --> 01:27:49,120
the second iteration the data is gone

01:27:49,280 --> 01:27:53,679
so what to do what to do

01:27:54,000 --> 01:28:01,840
i could try to reference it

01:28:09,199 --> 01:28:15,840
and move the reference in

01:28:18,159 --> 01:28:23,679
this will also not work

01:28:21,360 --> 01:28:26,560
because that will say hey we're trying

01:28:23,679 --> 01:28:26,560
to reference this

01:28:27,520 --> 01:28:35,280
immutably more than once at a time

01:28:30,960 --> 01:28:36,719
because i am not sure

01:28:35,280 --> 01:28:39,440
how long this threat is going to live

01:28:36,719 --> 01:28:41,920
the threat that takes ownership

01:28:39,440 --> 01:28:43,760
i'm i will not allow you to pass

01:28:41,920 --> 01:28:44,960
immutable reference into a thread which

01:28:43,760 --> 01:28:46,719
has

01:28:44,960 --> 01:28:48,000
like because these things might start

01:28:46,719 --> 01:28:50,800
working

01:28:48,000 --> 01:28:51,920
in parallel or concurrently independent

01:28:50,800 --> 01:28:54,800
of your runtime system the whole

01:28:51,920 --> 01:28:54,800
concurrency and

01:28:55,199 --> 01:28:58,400
and parallels and checking and rust is

01:28:57,120 --> 01:29:01,520
completely independent

01:28:58,400 --> 01:29:04,639
it doesn't know if you're running on a

01:29:01,520 --> 01:29:06,400
uh on a threading on

01:29:04,639 --> 01:29:07,920
on a thread runtime which is essentially

01:29:06,400 --> 01:29:09,199
your kernel is or if you're running on

01:29:07,920 --> 01:29:11,280
something like tokyo

01:29:09,199 --> 01:29:14,239
russ doesn't know about this at all just

01:29:11,280 --> 01:29:18,239
knows oh so thread spawn

01:29:14,239 --> 01:29:21,120
and we'll run thread spawn

01:29:18,239 --> 01:29:22,400
i need to be aware that this is a

01:29:21,120 --> 01:29:25,199
component

01:29:22,400 --> 01:29:26,639
that has dynamic runtime behavior over

01:29:25,199 --> 01:29:28,320
each other so you have two threads

01:29:26,639 --> 01:29:29,760
running in parallel and so you don't

01:29:28,320 --> 01:29:32,400
know how long this reference will be

01:29:29,760 --> 01:29:32,400
used and when

01:29:32,719 --> 01:29:41,360
and rust gives us two tools around this

01:29:38,320 --> 01:29:43,600
and so we have two problems essentially

01:29:41,360 --> 01:29:45,280
we have multiple threads or tasks or

01:29:43,600 --> 01:29:49,120
whatever

01:29:45,280 --> 01:29:49,120
i'll just call this g1

01:29:50,239 --> 01:29:58,000
q2 t3 we have these three

01:29:54,960 --> 01:30:00,639
and all of them want to have a share of

01:29:58,000 --> 01:30:00,639
the storage

01:30:03,280 --> 01:30:09,600
they need some access here

01:30:06,560 --> 01:30:09,600
but who should own it

01:30:10,960 --> 01:30:16,880
so i have a problem i have the single

01:30:14,400 --> 01:30:18,400
ownership principle that rust has but i

01:30:16,880 --> 01:30:20,239
need now need

01:30:18,400 --> 01:30:23,600
i have now have multiple parties that

01:30:20,239 --> 01:30:23,600
have interest in this resource

01:30:24,080 --> 01:30:27,600
and the way we deal with that in rust is

01:30:26,719 --> 01:30:32,400
a type called

01:30:27,600 --> 01:30:35,679
the arc come to what that is in a second

01:30:32,400 --> 01:30:38,400
let me write it out and

01:30:35,679 --> 01:30:39,280
you need to import it from the standard

01:30:38,400 --> 01:30:43,520
sync

01:30:39,280 --> 01:30:43,520
module standard sync arc

01:30:45,120 --> 01:30:52,320
and what arc allows me to do

01:30:49,199 --> 01:30:52,320
it allows me

01:30:52,480 --> 01:30:59,120
to have let me make this just bigger

01:30:55,679 --> 01:31:04,239
some drink that in front anyways um

01:30:59,120 --> 01:31:04,239
the arc is the atomic ref counter

01:31:04,320 --> 01:31:07,920
and the atomic stands for the counting

01:31:07,120 --> 01:31:10,960
is done in an

01:31:07,920 --> 01:31:13,360
atomic manner so um

01:31:10,960 --> 01:31:14,960
that um i have no compare and

01:31:13,360 --> 01:31:17,360
concurrency problems on

01:31:14,960 --> 01:31:19,760
count on the down count and it's a

01:31:17,360 --> 01:31:22,560
reference counter in the sense that

01:31:19,760 --> 01:31:22,560
if i have

01:31:24,800 --> 01:31:31,520
three of those what it will do it will

01:31:28,880 --> 01:31:33,760
produce references to the storage can

01:31:31,520 --> 01:31:37,440
allows me to reference the storage

01:31:33,760 --> 01:31:37,440
but if i have three of them out

01:31:38,239 --> 01:31:41,920
i will have a counter internally that

01:31:40,000 --> 01:31:44,560
says okay plus three

01:31:41,920 --> 01:31:46,320
so base three references currently out

01:31:44,560 --> 01:31:50,880
and once

01:31:46,320 --> 01:31:54,480
those threads drop usage of this arc

01:31:50,880 --> 01:31:56,880
we will have references going down

01:31:54,480 --> 01:31:58,159
and this will make sure that once this

01:31:56,880 --> 01:31:59,760
counter reaches zero

01:31:58,159 --> 01:32:02,239
then it will actually de-allocate the

01:31:59,760 --> 01:32:02,239
storage

01:32:02,320 --> 01:32:13,520
and the way we use that is

01:32:07,040 --> 01:32:16,719
before we start threading here

01:32:13,520 --> 01:32:20,960
i usually call that threat handle

01:32:16,719 --> 01:32:20,960
i take the original storage arc

01:32:21,920 --> 01:32:27,840
and call the arc clone function on the

01:32:25,199 --> 01:32:27,840
original

01:32:33,840 --> 01:32:36,239
and

01:32:37,679 --> 01:32:42,080
now i can use the thread handle over

01:32:39,920 --> 01:32:42,080
here

01:32:53,600 --> 01:32:58,800
so now i have my second handle here

01:32:59,360 --> 01:33:09,840
so what i have is i have my main thread

01:33:11,360 --> 01:33:16,400
so i have my main thread and it will

01:33:14,080 --> 01:33:16,400
start

01:33:18,400 --> 01:33:23,520
it will hold one reference here which is

01:33:21,600 --> 01:33:26,480
the storage reference and every time it

01:33:23,520 --> 01:33:26,480
spawns another one

01:33:26,880 --> 01:33:30,000
before it does so it will create a

01:33:29,120 --> 01:33:34,560
second one

01:33:30,000 --> 01:33:34,560
and gives the thread access to that

01:33:34,880 --> 01:33:42,000
so this

01:33:38,639 --> 01:33:43,679
handlebase management allows me to count

01:33:42,000 --> 01:33:45,360
how long i actually need to keep the

01:33:43,679 --> 01:33:48,000
storage around which

01:33:45,360 --> 01:33:50,480
because this handle will be dropped

01:33:48,000 --> 01:33:52,080
after the connection loop

01:33:50,480 --> 01:33:55,840
is basically forever as long as the

01:33:52,080 --> 01:33:58,800
server runs so i always have one

01:33:55,840 --> 01:33:58,800
one available here

01:34:02,840 --> 01:34:05,840
okay

01:34:11,440 --> 01:34:15,440
yeah we have a little bit of error

01:34:12,800 --> 01:34:19,760
message alien accidentally but now we

01:34:15,440 --> 01:34:21,840
have another problem

01:34:19,760 --> 01:34:23,199
i've always been talking about this

01:34:21,840 --> 01:34:25,600
problem that

01:34:23,199 --> 01:34:26,800
there's it just does not allow you to

01:34:25,600 --> 01:34:30,639
have multiple

01:34:26,800 --> 01:34:32,880
mutable references out at the same time

01:34:30,639 --> 01:34:35,679
and for that reason if i have this kind

01:34:32,880 --> 01:34:35,679
of setup here

01:34:38,560 --> 01:34:46,239
these ones are not allowed to produce me

01:34:42,960 --> 01:34:47,440
mutable references because if you're

01:34:46,239 --> 01:34:49,840
thinking about it

01:34:47,440 --> 01:34:50,639
we have these multiple parallel threats

01:34:49,840 --> 01:34:53,520
happening

01:34:50,639 --> 01:34:53,520
at the same time

01:34:53,679 --> 01:34:57,840
or tasks assigned to threats

01:34:59,119 --> 01:35:01,840
and

01:35:04,719 --> 01:35:11,600
that means that means we don't know

01:35:08,080 --> 01:35:14,880
if they would not for example take out

01:35:11,600 --> 01:35:17,679
try to mutate the shared data

01:35:14,880 --> 01:35:19,199
at similar times so if i draw a line

01:35:17,679 --> 01:35:20,480
here

01:35:19,199 --> 01:35:23,199
there could be moments where these

01:35:20,480 --> 01:35:25,119
actions overlap

01:35:23,199 --> 01:35:26,800
and this is how rust guarantees

01:35:25,119 --> 01:35:29,040
concurrency safety

01:35:26,800 --> 01:35:31,280
actually through the definition that

01:35:29,040 --> 01:35:34,159
mutable references are required

01:35:31,280 --> 01:35:36,320
to write to memory and that mutable

01:35:34,159 --> 01:35:39,600
references need to be unique

01:35:36,320 --> 01:35:41,920
oh sorry

01:35:39,600 --> 01:35:44,159
thank you thank you for the pointer and

01:35:41,920 --> 01:35:47,440
chat that you couldn't see the drawing

01:35:44,159 --> 01:35:49,520
so if we have these threads

01:35:47,440 --> 01:35:51,280
um taking out immutable references at

01:35:49,520 --> 01:35:52,480
the same time there could be a moment

01:35:51,280 --> 01:35:54,719
where multiple meteor

01:35:52,480 --> 01:35:56,960
mutable references are yet available at

01:35:54,719 --> 01:36:00,080
the same time

01:35:56,960 --> 01:36:02,880
um arcs

01:36:00,080 --> 01:36:03,520
have no similarity to go context weight

01:36:02,880 --> 01:36:06,880
groups

01:36:03,520 --> 01:36:08,840
um steep as my understanding for for go

01:36:06,880 --> 01:36:12,639
context and weight goes

01:36:08,840 --> 01:36:16,320
um arcs um parks essentially just use

01:36:12,639 --> 01:36:20,000
the processor feature of um

01:36:16,320 --> 01:36:23,520
of atomic additions and um

01:36:20,000 --> 01:36:28,880
there there's a quick question right

01:36:23,520 --> 01:36:28,880
on why i use arc clone here

01:36:29,199 --> 01:36:35,360
purely out of habit there's a debate

01:36:32,239 --> 01:36:38,800
which one is better you can also use

01:36:35,360 --> 01:36:41,280
just as an illustration you can also use

01:36:38,800 --> 01:36:41,280
storage

01:36:49,199 --> 01:36:54,080
at this moment i think it makes it more

01:36:51,280 --> 01:36:55,119
visible that i'm cloning this arc handle

01:36:54,080 --> 01:36:57,760
like that my

01:36:55,119 --> 01:36:58,719
basically my lease on a ref counted

01:36:57,760 --> 01:37:01,760
value

01:36:58,719 --> 01:37:04,560
while the clone interface is the general

01:37:01,760 --> 01:37:06,000
cloning interface that rust has which

01:37:04,560 --> 01:37:08,320
also allows you to feed this

01:37:06,000 --> 01:37:09,920
in for example in things that um that

01:37:08,320 --> 01:37:12,800
want to express multiple

01:37:09,920 --> 01:37:13,600
uh ownership that you feed this into

01:37:12,800 --> 01:37:15,920
things that that

01:37:13,600 --> 01:37:16,639
might want to clone and and that would

01:37:15,920 --> 01:37:20,880
cost you

01:37:16,639 --> 01:37:23,760
um that would cost you um

01:37:20,880 --> 01:37:24,800
for example a lot of memory if you were

01:37:23,760 --> 01:37:28,560
actually doing this so

01:37:24,800 --> 01:37:28,560
this allows you to do cheap cloning

01:37:28,800 --> 01:37:35,440
okay uh so let's get to this mutable

01:37:31,840 --> 01:37:39,840
thing here so what i essentially

01:37:35,440 --> 01:37:39,840
need is something

01:37:42,480 --> 01:37:44,800
that

01:37:46,840 --> 01:37:49,840
um

01:37:50,400 --> 01:37:54,560
that makes sure that if you have

01:37:52,719 --> 01:37:57,679
multiple threads

01:37:54,560 --> 01:38:00,080
and they want mutable or

01:37:57,679 --> 01:38:03,840
even immutable if they want to read um

01:38:00,080 --> 01:38:03,840
synchronized access to the value

01:38:05,520 --> 01:38:09,679
here we need some type that moderates

01:38:07,920 --> 01:38:13,360
that

01:38:09,679 --> 01:38:16,560
and the classic type to use here

01:38:13,360 --> 01:38:31,840
is a mutex and

01:38:16,560 --> 01:38:31,840
i would like to use one here

01:38:37,520 --> 01:38:43,040
the mutex is in the standard sync module

01:38:41,119 --> 01:38:47,600
as well

01:38:43,040 --> 01:38:51,760
and it works just the same here you use

01:38:47,600 --> 01:38:56,239
it you construct it around this vector q

01:38:51,760 --> 01:38:56,239
and what we've now done let me

01:38:57,440 --> 01:39:01,040
put the drawing on the screen first

01:39:01,280 --> 01:39:04,239
take this down a little

01:39:06,239 --> 01:39:09,679
and just for those that were asking

01:39:07,840 --> 01:39:11,920
around tokyo tokyo

01:39:09,679 --> 01:39:13,280
uses arc from the standard clip but for

01:39:11,920 --> 01:39:17,280
example provides its own

01:39:13,280 --> 01:39:18,560
async mutex and that's the

01:39:17,280 --> 01:39:20,320
there's two things you would need to

01:39:18,560 --> 01:39:21,760
replace to run this on tokyo which is

01:39:20,320 --> 01:39:24,159
replacing thread spawn

01:39:21,760 --> 01:39:26,400
by tokyo spawn and by replacing the

01:39:24,159 --> 01:39:27,840
mutex implementation or an async mutex

01:39:26,400 --> 01:39:30,239
implementation that interacts with the

01:39:27,840 --> 01:39:30,239
runtime

01:39:31,760 --> 01:39:37,679
and but the ex

01:39:35,440 --> 01:39:38,560
the exact same principle and the exact

01:39:37,679 --> 01:39:41,520
same api

01:39:38,560 --> 01:39:43,119
applies with one minor difference that

01:39:41,520 --> 01:39:44,480
is seen as an api mistake in the

01:39:43,119 --> 01:39:48,320
standard clip

01:39:44,480 --> 01:39:48,560
but you can really go like import tokyo

01:39:48,320 --> 01:39:51,920
and

01:39:48,560 --> 01:39:56,560
and run through this whole program and

01:39:51,920 --> 01:39:59,440
change it to to an async fashion

01:39:56,560 --> 01:40:00,320
so now we have this mutex wrapping

01:39:59,440 --> 01:40:02,320
around the storage

01:40:00,320 --> 01:40:04,880
and the arc now gives me access to the

01:40:02,320 --> 01:40:04,880
mutex

01:40:06,880 --> 01:40:12,480
this an interesting thing that now

01:40:09,600 --> 01:40:15,040
happens in the api

01:40:12,480 --> 01:40:18,480
we need to take a mutex here because we

01:40:15,040 --> 01:40:18,480
want to interact with the mutex

01:40:21,760 --> 01:40:25,040
standard circle also provides you with

01:40:23,360 --> 01:40:26,320
other kinds of primitives if you have

01:40:25,040 --> 01:40:31,040
different kinds of

01:40:26,320 --> 01:40:34,159
read and write behavior like um

01:40:31,040 --> 01:40:36,080
you can for example an rw lock

01:40:34,159 --> 01:40:39,199
or things like that are better for you

01:40:36,080 --> 01:40:39,199
you can also find that there

01:40:41,119 --> 01:40:44,560
but for the sake of it i'll be using the

01:40:43,520 --> 01:40:47,360
mutex

01:40:44,560 --> 01:40:50,080
so now i have mutex vectorq string and i

01:40:47,360 --> 01:40:51,360
come back to this piece of signature in

01:40:50,080 --> 01:40:54,239
a second but now

01:40:51,360 --> 01:40:54,800
first of all i want to use it so i

01:40:54,239 --> 01:40:57,040
cannot

01:40:54,800 --> 01:40:58,080
call pushback on the storage here

01:40:57,040 --> 01:41:01,199
because it's not

01:40:58,080 --> 01:41:01,600
a vectorq anymore the way we end up

01:41:01,199 --> 01:41:05,840
doing

01:41:01,600 --> 01:41:05,840
handling this is

01:41:06,719 --> 01:41:11,679
we want to lock so we can request one

01:41:16,159 --> 01:41:19,360
and this is the one location maybe i can

01:41:18,239 --> 01:41:21,520
go into details

01:41:19,360 --> 01:41:23,280
later on why that is but this is what

01:41:21,520 --> 01:41:25,040
i've been hinting at with

01:41:23,280 --> 01:41:28,000
generally seen as an api mistake in the

01:41:25,040 --> 01:41:29,920
standard lib locking returns a result

01:41:28,000 --> 01:41:32,400
and that's result is almost not

01:41:29,920 --> 01:41:34,719
handleable in the case where

01:41:32,400 --> 01:41:35,440
it actually fails so this is the point

01:41:34,719 --> 01:41:39,040
where we

01:41:35,440 --> 01:41:42,239
i'll call just unwrap and just be

01:41:39,040 --> 01:41:45,600
okay with that um so

01:41:42,239 --> 01:41:48,000
um this is really like if if this result

01:41:45,600 --> 01:41:50,080
fails your program is so broken that you

01:41:48,000 --> 01:41:51,600
probably cannot recover and then

01:41:50,080 --> 01:41:53,840
panicking and quitting is the right

01:41:51,600 --> 01:41:57,199
thing to do

01:41:53,840 --> 01:42:00,880
and what this returns is a so-called

01:41:57,199 --> 01:42:02,400
guard i call this guard this is a value

01:42:00,880 --> 01:42:03,679
that represents i'm currently holding

01:42:02,400 --> 01:42:06,480
lock and i can use the

01:42:03,679 --> 01:42:07,920
card to actually write to the data

01:42:06,480 --> 01:42:09,280
because this represents i'm holding a

01:42:07,920 --> 01:42:11,520
lock

01:42:09,280 --> 01:42:12,480
and it knows i'm holding a lock to a

01:42:11,520 --> 01:42:14,400
vector queue

01:42:12,480 --> 01:42:16,000
and will expose the function pushback i

01:42:14,400 --> 01:42:17,280
cannot go into the exact mechanics on

01:42:16,000 --> 01:42:20,800
how this works

01:42:17,280 --> 01:42:22,719
um here but because i would like to talk

01:42:20,800 --> 01:42:25,280
a little bit about how that guard works

01:42:22,719 --> 01:42:26,560
um in a second but just before we're

01:42:25,280 --> 01:42:29,920
doing that

01:42:26,560 --> 01:42:33,679
i would also like to again

01:42:29,920 --> 01:42:33,679
do that here so if we retrieve

01:42:39,760 --> 01:42:43,920
um yeah this is exactly what i wanted to

01:42:42,080 --> 01:42:45,920
talk about before

01:42:43,920 --> 01:42:47,440
when i talk about the guard uh thanks

01:42:45,920 --> 01:42:50,239
for the question so

01:42:47,440 --> 01:42:51,760
when is that lock released we need to

01:42:50,239 --> 01:42:52,880
mutate it because we want to mute it

01:42:51,760 --> 01:42:54,800
through it

01:42:52,880 --> 01:42:56,400
and this card represents okay you're

01:42:54,800 --> 01:43:02,159
currently holding the lock

01:42:56,400 --> 01:43:02,159
now you are allowed

01:43:02,239 --> 01:43:05,360
so here is the guard

01:43:06,800 --> 01:43:09,840
and because the mutex internally

01:43:08,560 --> 01:43:12,159
guarantees

01:43:09,840 --> 01:43:15,840
that this card can only exist once

01:43:12,159 --> 01:43:19,360
that's the definition of a mutex

01:43:15,840 --> 01:43:21,040
this one will finally produce you a

01:43:19,360 --> 01:43:22,960
mutable reference

01:43:21,040 --> 01:43:25,760
to which you can write that only exists

01:43:22,960 --> 01:43:27,600
once this is the thing that a mutex

01:43:25,760 --> 01:43:28,800
provides so this is like the the

01:43:27,600 --> 01:43:33,119
cleverness

01:43:28,800 --> 01:43:33,119
that rust has there

01:43:33,920 --> 01:43:38,400
so there's the question when is the

01:43:35,520 --> 01:43:38,400
guard released

01:43:40,000 --> 01:43:44,639
the guard is released by the end of the

01:43:42,239 --> 01:43:44,639
scope

01:43:50,840 --> 01:43:53,840
here

01:43:56,080 --> 01:43:59,760
yep so when it's dropped

01:44:00,639 --> 01:44:08,560
um that means it's a slight warning here

01:44:05,440 --> 01:44:11,040
um i've been using i've been binding the

01:44:08,560 --> 01:44:12,719
guard explicitly here

01:44:11,040 --> 01:44:14,960
here that means the guard will be

01:44:12,719 --> 01:44:15,679
released up after actually writing to

01:44:14,960 --> 01:44:17,440
the client

01:44:15,679 --> 01:44:18,719
so i'm actually holding it for a little

01:44:17,440 --> 01:44:21,040
too long

01:44:18,719 --> 01:44:22,800
which is why general practice is

01:44:21,040 --> 01:44:25,920
actually to

01:44:22,800 --> 01:44:25,920
do that all in line

01:44:32,400 --> 01:44:36,320
that means the guard will only be held

01:44:35,280 --> 01:44:39,840
for actually this

01:44:36,320 --> 01:44:41,440
this line of code so if you don't bind

01:44:39,840 --> 01:44:42,880
things to a variable they will be

01:44:41,440 --> 01:44:45,040
like they will be temporary and

01:44:42,880 --> 01:44:46,480
immediately dropped and that makes sure

01:44:45,040 --> 01:44:48,320
that that this year works

01:44:46,480 --> 01:44:50,320
so this is actually a good practice when

01:44:48,320 --> 01:44:53,920
working with mutexes

01:44:50,320 --> 01:44:56,560
yeah so what we see here

01:44:53,920 --> 01:44:57,440
is we have the mutex and then we have

01:44:56,560 --> 01:45:00,719
this way to

01:44:57,440 --> 01:45:02,800
come back to mutability by working

01:45:00,719 --> 01:45:03,920
through the lock interface

01:45:02,800 --> 01:45:05,440
there's often the question whether

01:45:03,920 --> 01:45:07,040
that's an escape patch in the language

01:45:05,440 --> 01:45:08,480
it actually isn't because

01:45:07,040 --> 01:45:10,159
i said i wanted to come back to this

01:45:08,480 --> 01:45:15,119
type signature

01:45:10,159 --> 01:45:15,119
and make sure that you understand it

01:45:15,280 --> 01:45:19,840
this says here you get a reference to

01:45:18,880 --> 01:45:22,960
mutex

01:45:19,840 --> 01:45:26,480
you are not owning it

01:45:22,960 --> 01:45:30,159
the mutex wraps a vector cue

01:45:26,480 --> 01:45:33,520
inside and the mutex

01:45:30,159 --> 01:45:38,400
actually owns it

01:45:33,520 --> 01:45:38,400
so you have this kind of picture here

01:45:39,040 --> 01:45:45,840
mutex and really the storage on the

01:45:42,840 --> 01:45:45,840
inside

01:45:46,320 --> 01:45:51,920
and the immutable reference here says

01:45:50,320 --> 01:45:54,719
you are not allowed to manipulate the

01:45:51,920 --> 01:45:56,320
mutex you're also not the owner of the

01:45:54,719 --> 01:45:57,440
mutex so you're also not allowed to

01:45:56,320 --> 01:45:59,280
destroy it or

01:45:57,440 --> 01:46:02,719
anything else you can only work through

01:45:59,280 --> 01:46:02,719
it through an interface

01:46:03,280 --> 01:46:07,679
you are also not to access what's on the

01:46:05,360 --> 01:46:12,480
inside the only way to actually get

01:46:07,679 --> 01:46:27,840
to the inside is this locking function

01:46:12,480 --> 01:46:27,840
and this does three things

01:46:39,600 --> 01:46:42,719
so um

01:46:43,280 --> 01:46:49,040
here the mutex exists before i'm

01:46:46,239 --> 01:46:52,159
actually calling here

01:46:49,040 --> 01:46:52,159
the moment i'm locking

01:46:52,840 --> 01:46:57,760
here the card starts existing

01:46:58,880 --> 01:47:01,199
sorry

01:47:04,480 --> 01:47:09,840
and the card exists until here

01:47:11,920 --> 01:47:16,960
but in between there's a third thing

01:47:14,880 --> 01:47:19,280
happening

01:47:16,960 --> 01:47:21,040
which happens when i call pushback is at

01:47:19,280 --> 01:47:22,480
some point there will be a mutable

01:47:21,040 --> 01:47:24,639
reference

01:47:22,480 --> 01:47:24,639
to

01:47:25,760 --> 01:47:30,400
this vector qb available

01:47:30,800 --> 01:47:37,600
and this one is enforced

01:47:35,199 --> 01:47:38,880
and this is what you generally know as

01:47:37,600 --> 01:47:41,280
borrow checking if you

01:47:38,880 --> 01:47:42,639
like hear about it at the hear hear

01:47:41,280 --> 01:47:46,639
about that at some point

01:47:42,639 --> 01:47:49,520
is enforced to never

01:47:46,639 --> 01:47:50,719
live longer than the guard that would be

01:47:49,520 --> 01:47:53,600
a violation

01:47:50,719 --> 01:47:54,719
so rust does three levels of safety

01:47:53,600 --> 01:47:57,119
checking here

01:47:54,719 --> 01:47:57,840
first of all to make sure that you don't

01:47:57,119 --> 01:48:00,960
start like

01:47:57,840 --> 01:48:02,719
manipulating the mutex structure raw

01:48:00,960 --> 01:48:05,440
and that it's properly initialized and

01:48:02,719 --> 01:48:08,320
this is a properly initialized mutex

01:48:05,440 --> 01:48:10,159
that before you are even allowed to have

01:48:08,320 --> 01:48:12,639
a reference to the inside

01:48:10,159 --> 01:48:14,159
you have made sure that there's a lock

01:48:12,639 --> 01:48:17,360
but the third thing is

01:48:14,159 --> 01:48:20,320
that it will also make sure

01:48:17,360 --> 01:48:21,840
through this kind of layer checking it

01:48:20,320 --> 01:48:24,239
will also make sure that

01:48:21,840 --> 01:48:24,960
even after you release the lock you are

01:48:24,239 --> 01:48:27,040
asked you

01:48:24,960 --> 01:48:29,280
before releasing the lock it's better to

01:48:27,040 --> 01:48:32,080
save that way before releasing the lock

01:48:29,280 --> 01:48:33,920
you also gave up any attempt to

01:48:32,080 --> 01:48:35,840
manipulate the data

01:48:33,920 --> 01:48:37,520
so if i were trying to manipulate the

01:48:35,840 --> 01:48:40,159
data after

01:48:37,520 --> 01:48:41,280
dropping the guard we can't use this

01:48:40,159 --> 01:48:44,560
case

01:48:41,280 --> 01:48:47,600
if we wanted to we could just force

01:48:44,560 --> 01:48:50,880
that's this is not

01:48:47,600 --> 01:48:53,280
uh this is not very

01:48:50,880 --> 01:48:56,080
meaningful code this is we lock we guard

01:48:53,280 --> 01:48:58,159
and then we try to write to it

01:48:56,080 --> 01:48:59,679
we so we lock we get the guard then we

01:48:58,159 --> 01:48:59,920
throw it away and then we try to write

01:48:59,679 --> 01:49:05,440
to

01:48:59,920 --> 01:49:08,560
it this not something one would write

01:49:05,440 --> 01:49:13,119
but if you were to run this um

01:49:08,560 --> 01:49:17,040
it would say ah wait a second

01:49:13,119 --> 01:49:20,000
this is a the wrong error message

01:49:17,040 --> 01:49:22,560
this is the one i wanted if you were to

01:49:20,000 --> 01:49:22,560
look at this

01:49:27,199 --> 01:49:31,040
then it would say hey uh you are trying

01:49:29,440 --> 01:49:33,679
to write to this card although you have

01:49:31,040 --> 01:49:33,679
thrown it away

01:49:34,960 --> 01:49:41,520
and rust

01:49:38,320 --> 01:49:42,320
is not extremely magical around this in

01:49:41,520 --> 01:49:45,599
the sense

01:49:42,320 --> 01:49:48,719
that well what it does is

01:49:45,599 --> 01:49:48,719
draw these regions

01:49:49,440 --> 01:49:53,199
i'm sorry they should

01:49:53,840 --> 01:49:59,040
what it does is draw these regions and

01:49:55,520 --> 01:50:02,880
make sure they follow a hierarchy

01:49:59,040 --> 01:50:04,239
and that's a that's what's generally

01:50:02,880 --> 01:50:07,840
known as borrow checking

01:50:04,239 --> 01:50:11,199
making sure that what i have that my

01:50:07,840 --> 01:50:14,800
loan on the vectiq does not outlive

01:50:11,199 --> 01:50:14,800
the time that is actually valid

01:50:15,760 --> 01:50:18,080
okay

01:50:21,760 --> 01:50:27,199
are there any questions around that

01:50:34,639 --> 01:50:40,080
ah should maybe

01:50:37,679 --> 01:50:40,080
run it

01:50:44,800 --> 01:50:50,560
um on your next question are data race

01:50:47,679 --> 01:50:52,400
conditions possible no

01:50:50,560 --> 01:50:54,880
that's that's exactly the thing that

01:50:52,400 --> 01:50:59,119
rust bands data races are not possible

01:50:54,880 --> 01:51:07,840
log races are just to be clear

01:50:59,119 --> 01:51:07,840
um so but data races are not

01:51:08,320 --> 01:51:14,400
um because data races like

01:51:12,080 --> 01:51:16,480
rust is a mem it basically follows from

01:51:14,400 --> 01:51:17,040
rust as a memory saved language and data

01:51:16,480 --> 01:51:21,840
races

01:51:17,040 --> 01:51:21,840
are a kind of memory unsafety

01:51:26,080 --> 01:51:33,520
and yeah that lock on wrap

01:51:29,520 --> 01:51:34,080
pop front will will immediately release

01:51:33,520 --> 01:51:37,520
the lock

01:51:34,080 --> 01:51:39,760
in that line because it's temporary

01:51:37,520 --> 01:51:41,599
um the mathematical proof for this is

01:51:39,760 --> 01:51:43,920
called rust belt

01:51:41,599 --> 01:51:46,840
um so if you look at the university of

01:51:43,920 --> 01:51:49,840
subrican rust bulk project

01:51:46,840 --> 01:51:49,840
um

01:51:50,400 --> 01:51:53,119
that is um

01:51:55,840 --> 01:52:04,480
you'll find it there

01:52:03,040 --> 01:52:06,480
clear yes you can deadlock in live

01:52:04,480 --> 01:52:09,760
locking rust you

01:52:06,480 --> 01:52:09,760
can um

01:52:09,920 --> 01:52:14,239
there are ways on how you can force a

01:52:12,400 --> 01:52:17,280
resource acquisition order

01:52:14,239 --> 01:52:18,800
if you structure your types right

01:52:17,280 --> 01:52:20,639
but that is something you need to work

01:52:18,800 --> 01:52:22,560
for that doesn't come naturally out of

01:52:20,639 --> 01:52:24,800
the language

01:52:22,560 --> 01:52:27,280
you can use the type system a little bit

01:52:24,800 --> 01:52:27,280
was that

01:52:28,080 --> 01:52:32,239
the questions on cc plus plus new and

01:52:30,560 --> 01:52:35,199
delete in any way

01:52:32,239 --> 01:52:35,840
um no there's nothing similar to new and

01:52:35,199 --> 01:52:39,599
delete

01:52:35,840 --> 01:52:42,400
um in in the way that uh

01:52:39,599 --> 01:52:42,960
that you would be used to in c plus um

01:52:42,400 --> 01:52:45,040
we

01:52:42,960 --> 01:52:47,920
like rust doesn't even have things like

01:52:45,040 --> 01:52:51,920
special constructors there's some

01:52:47,920 --> 01:52:56,000
there's ways to create um to create data

01:52:51,920 --> 01:52:56,000
but the

01:52:56,239 --> 01:52:59,199
the destruction of data always goes

01:52:57,840 --> 01:53:00,239
through this drop interface you can

01:52:59,199 --> 01:53:03,199
write destructors

01:53:00,239 --> 01:53:04,639
um that's the thing that i haven't shown

01:53:03,199 --> 01:53:05,840
like all of these things work through

01:53:04,639 --> 01:53:08,080
destructors

01:53:05,840 --> 01:53:08,080
um

01:53:11,040 --> 01:53:14,880
okay um

01:53:15,920 --> 01:53:19,840
and i will quickly

01:53:20,480 --> 01:53:24,960
share this code already as a playground

01:53:23,119 --> 01:53:30,320
here

01:53:24,960 --> 01:53:30,320
um rust has the rust playground

01:53:30,880 --> 01:53:34,480
i will show that on screen for a second

01:53:36,480 --> 01:53:39,599
so that's our online playground which

01:53:38,400 --> 01:53:43,520
you probably know

01:53:39,599 --> 01:53:48,560
and it has this nice share button

01:53:43,520 --> 01:53:48,560
and i will copy the link here to this

01:53:51,040 --> 01:53:58,239
um that's the code that we've written

01:53:54,800 --> 01:54:00,400
and you can start playing around with

01:53:58,239 --> 01:54:00,400
that

01:54:02,560 --> 01:54:06,719
on thomas question the art no longer

01:54:04,400 --> 01:54:10,080
leads mood is that because of interior

01:54:06,719 --> 01:54:12,560
theory mutability and yes

01:54:10,080 --> 01:54:14,000
we are you've seen this warning here

01:54:12,560 --> 01:54:15,280
mood storage it does not need to be

01:54:14,000 --> 01:54:17,440
mutable anymore

01:54:15,280 --> 01:54:19,199
rust has this idea of interior

01:54:17,440 --> 01:54:23,360
immutability

01:54:19,199 --> 01:54:25,119
um just quickly which is precisely this

01:54:23,360 --> 01:54:29,760
year where

01:54:25,119 --> 01:54:32,480
i have immutable access to this and

01:54:29,760 --> 01:54:33,840
but in some way i can produce mutable

01:54:32,480 --> 01:54:36,800
access here

01:54:33,840 --> 01:54:38,639
and i said like i cannot like if i have

01:54:36,800 --> 01:54:40,080
an immutable reference i cannot get

01:54:38,639 --> 01:54:43,280
immutable reference

01:54:40,080 --> 01:54:46,639
and this is in general true in practice

01:54:43,280 --> 01:54:48,480
that would make mutexes not very useful

01:54:46,639 --> 01:54:50,080
types because that would mean i would

01:54:48,480 --> 01:54:52,560
have to need mutable access

01:54:50,080 --> 01:54:53,199
to the mutex already to then produce

01:54:52,560 --> 01:54:54,960
immutable

01:54:53,199 --> 01:54:57,280
and mutable access to its inner parts so

01:54:54,960 --> 01:55:01,679
there's this concept of immutability

01:54:57,280 --> 01:55:02,080
in that types in and by themselves can

01:55:01,679 --> 01:55:06,320
say

01:55:02,080 --> 01:55:08,880
i will manage um immutability by myself

01:55:06,320 --> 01:55:10,719
but and and particularly at runtime

01:55:08,880 --> 01:55:14,480
because that's what a mutex does it

01:55:10,719 --> 01:55:15,520
is a mutex it's a moderator of mutation

01:55:14,480 --> 01:55:17,679
essentially

01:55:15,520 --> 01:55:19,679
um but what that means is that it still

01:55:17,679 --> 01:55:22,320
needs to uphold this guarantee

01:55:19,679 --> 01:55:22,880
that mutable references in rust if there

01:55:22,320 --> 01:55:25,360
is one

01:55:22,880 --> 01:55:27,440
out there's exactly one out there's also

01:55:25,360 --> 01:55:28,800
no immutable references there's exactly

01:55:27,440 --> 01:55:31,599
one mutable reference

01:55:28,800 --> 01:55:32,639
to the vector q available at that moment

01:55:31,599 --> 01:55:35,840
in the program

01:55:32,639 --> 01:55:36,560
and nothing else and that's um that's

01:55:35,840 --> 01:55:40,320
important

01:55:36,560 --> 01:55:43,599
to uh to make sure that this is uh

01:55:40,320 --> 01:55:46,880
uh that this is true um at all times

01:55:43,599 --> 01:55:50,560
and mutex's um

01:55:46,880 --> 01:55:55,280
especially many concurrency primitives

01:55:50,560 --> 01:55:57,360
do you use this kind of feature

01:55:55,280 --> 01:55:59,360
um yeah and the compiler knows about

01:55:57,360 --> 01:56:00,000
this it knows okay these are types that

01:55:59,360 --> 01:56:01,840
manage

01:56:00,000 --> 01:56:05,040
this kind of mutability checking on the

01:56:01,840 --> 01:56:07,119
inside by themselves

01:56:05,040 --> 01:56:08,800
but the language will still exist so if

01:56:07,119 --> 01:56:13,280
i have a function

01:56:08,800 --> 01:56:17,280
here that says

01:56:13,280 --> 01:56:18,960
um now they're all gone

01:56:17,280 --> 01:56:21,199
oh if i have a function here that says i

01:56:18,960 --> 01:56:23,119
take immutable reference

01:56:21,199 --> 01:56:24,320
it still needs to make sure that in all

01:56:23,119 --> 01:56:27,679
cases

01:56:24,320 --> 01:56:29,119
um while bufferedreader readline works

01:56:27,679 --> 01:56:31,040
on this specific buffer

01:56:29,119 --> 01:56:32,960
it knows this is the only execution of

01:56:31,040 --> 01:56:33,840
this function on this specific piece of

01:56:32,960 --> 01:56:36,159
data

01:56:33,840 --> 01:56:37,360
and again coming back to what i said

01:56:36,159 --> 01:56:40,159
before

01:56:37,360 --> 01:56:42,639
this is this is the crucial part of the

01:56:40,159 --> 01:56:45,119
concurrency and safety checking of rust

01:56:42,639 --> 01:56:46,560
and if you take this piece of code i can

01:56:45,119 --> 01:56:48,400
highly recommend doing that as an

01:56:46,560 --> 01:56:49,199
exercise if you take this piece of code

01:56:48,400 --> 01:56:51,360
and then

01:56:49,199 --> 01:56:53,840
have a look at the tokyo api you will

01:56:51,360 --> 01:56:57,840
see tokyo also has tcp stream

01:56:53,840 --> 01:56:57,840
it has buffered reader it has

01:56:58,080 --> 01:57:02,880
it has tcp listener under the exact same

01:57:00,719 --> 01:57:06,480
interface it has mutex

01:57:02,880 --> 01:57:08,480
under the same interface it has a task

01:57:06,480 --> 01:57:10,639
spawn module instead of a threat spawn

01:57:08,480 --> 01:57:12,960
module and this is the most important

01:57:10,639 --> 01:57:16,000
difference behind this but the

01:57:12,960 --> 01:57:19,199
the safety checking works

01:57:16,000 --> 01:57:21,199
very much the same and the construction

01:57:19,199 --> 01:57:24,080
of this program works very much the same

01:57:21,199 --> 01:57:24,960
which is an interesting experience to

01:57:24,080 --> 01:57:28,400
see where

01:57:24,960 --> 01:57:30,000
um rust takes the the common ground

01:57:28,400 --> 01:57:31,440
between all of these kind of things and

01:57:30,000 --> 01:57:34,080
makes it safe

01:57:31,440 --> 01:57:34,719
and so you can use and this is also why

01:57:34,080 --> 01:57:38,080
i picked

01:57:34,719 --> 01:57:39,040
going down that route um for uh for this

01:57:38,080 --> 01:57:40,480
exercise

01:57:39,040 --> 01:57:42,159
because it gives you an access on how

01:57:40,480 --> 01:57:44,000
the mechanics work

01:57:42,159 --> 01:57:45,679
and then you can apply these mechanics

01:57:44,000 --> 01:57:48,880
to just tokyo

01:57:45,679 --> 01:57:52,400
or whatever um right away

01:57:48,880 --> 01:57:54,480
um so um the

01:57:52,400 --> 01:57:56,480
tokyo task spawn interface if you look

01:57:54,480 --> 01:57:58,560
at it is very very similar to the threat

01:57:56,480 --> 01:58:00,480
spawn interface

01:57:58,560 --> 01:58:01,760
going back to that point of common

01:58:00,480 --> 01:58:07,360
ground

01:58:01,760 --> 01:58:10,350
so yeah

01:58:07,360 --> 01:58:13,440
are there any other

01:58:10,350 --> 01:58:16,639
[Music]

01:58:13,440 --> 01:58:20,320
uh our collections themselves let's say

01:58:16,639 --> 01:58:20,719
no so um standard lip collections and

01:58:20,320 --> 01:58:24,080
rust

01:58:20,719 --> 01:58:25,679
are not by themselves thread safe and

01:58:24,080 --> 01:58:27,280
you would need to use these kind of

01:58:25,679 --> 01:58:28,080
things but rust knows that they're not

01:58:27,280 --> 01:58:30,560
thread safe

01:58:28,080 --> 01:58:32,080
so they are safe to use um and this is

01:58:30,560 --> 01:58:33,440
exactly what it

01:58:32,080 --> 01:58:35,199
what it has figured out when i was

01:58:33,440 --> 01:58:37,599
trying to pass um

01:58:35,199 --> 01:58:39,040
if if it were thread safe it would not

01:58:37,599 --> 01:58:41,119
have complained

01:58:39,040 --> 01:58:42,639
the moment where i'm passing it over

01:58:41,119 --> 01:58:45,920
through an arc and would try

01:58:42,639 --> 01:58:49,280
uh and would try to mutate it

01:58:45,920 --> 01:58:51,440
in a way

01:58:49,280 --> 01:58:52,719
there are though implementations of

01:58:51,440 --> 01:58:56,239
threatsafe

01:58:52,719 --> 01:58:56,239
collections out there as crates

01:59:00,880 --> 01:59:08,719
happy too last round of questions

01:59:04,960 --> 01:59:12,080
um that's always good when

01:59:08,719 --> 01:59:16,400
someone says eye opening um i have an

01:59:12,080 --> 01:59:18,560
async implementation um of this sorry

01:59:16,400 --> 01:59:21,119
online that is a little bit more

01:59:18,560 --> 01:59:21,119
elaborate

01:59:22,780 --> 01:59:27,360
[Music]

01:59:24,960 --> 01:59:27,360
i will

01:59:28,080 --> 01:59:45,840
i'll have so much time to actually find

01:59:30,400 --> 01:59:45,840
that link

01:59:50,560 --> 01:59:56,159
that is takes a little bit of a more

01:59:54,400 --> 01:59:57,920
complex protocol that

01:59:56,159 --> 01:59:59,520
looks a lot like the redis protocol so

01:59:57,920 --> 02:00:00,480
it also has a library as a protocol

01:59:59,520 --> 02:00:04,080
browser

02:00:00,480 --> 02:00:05,920
um it's written using async stud but

02:00:04,080 --> 02:00:07,679
given that the interface of async state

02:00:05,920 --> 02:00:09,360
and tokyo have moves very closely to

02:00:07,679 --> 02:00:10,000
each other you can basically just go and

02:00:09,360 --> 02:00:13,280
remove

02:00:10,000 --> 02:00:16,400
async stud replace it by tokund um

02:00:13,280 --> 02:00:16,400
and use it as tokyo

02:00:16,560 --> 02:00:22,639
and greetings to germany

02:00:19,599 --> 02:00:26,000
um yeah i i hope i give you

02:00:22,639 --> 02:00:28,880
um a little bit of uh an of an overview

02:00:26,000 --> 02:00:29,599
of the basics of what make rust teasing

02:00:28,880 --> 02:00:31,599
um

02:00:29,599 --> 02:00:32,639
and the last thing that i would like to

02:00:31,599 --> 02:00:35,520
give you

02:00:32,639 --> 02:00:36,400
um on your learning exercise is

02:00:35,520 --> 02:00:38,480
ownership

02:00:36,400 --> 02:00:40,560
is the important principle in rust if

02:00:38,480 --> 02:00:42,000
you if you are struggling with the

02:00:40,560 --> 02:00:44,719
borrower checker a little

02:00:42,000 --> 02:00:45,040
reference less use more clones use arcs

02:00:44,719 --> 02:00:48,000
like

02:00:45,040 --> 02:00:49,040
use things that they use own types um

02:00:48,000 --> 02:00:51,840
that makes uh

02:00:49,040 --> 02:00:53,760
rust a lot easier and there's an easy

02:00:51,840 --> 02:00:54,400
refactoring for if you figure out i'm

02:00:53,760 --> 02:00:56,320
copying

02:00:54,400 --> 02:00:57,840
data too much and all of these kind of

02:00:56,320 --> 02:01:00,880
things and then actually

02:00:57,840 --> 02:01:02,400
start referencing more is a good way to

02:01:00,880 --> 02:01:05,840
learn the language so ownership

02:01:02,400 --> 02:01:05,840
is a thing that you should focus on

02:01:06,840 --> 02:01:13,440
first

02:01:09,199 --> 02:01:15,599
okay um

02:01:13,440 --> 02:01:17,840
oh and um because it's so quick to

02:01:15,599 --> 02:01:20,800
answer um

02:01:17,840 --> 02:01:20,800
frank um

02:01:20,880 --> 02:01:24,480
yeah that was that was the thing that i

02:01:22,480 --> 02:01:26,560
had uh hinted at

02:01:24,480 --> 02:01:27,920
there's a type in rust that is instead

02:01:26,560 --> 02:01:31,360
of mudex

02:01:27,920 --> 02:01:34,960
it's called um

02:01:31,360 --> 02:01:37,280
rw lock which works the same as mutex it

02:01:34,960 --> 02:01:40,400
wraps the data but it has two functions

02:01:37,280 --> 02:01:43,280
one read and one right where

02:01:40,400 --> 02:01:45,840
you request the kind of locking that you

02:01:43,280 --> 02:01:45,840
that you need

02:01:49,520 --> 02:01:56,159
okay um thank you all for

02:01:52,719 --> 02:01:59,520
attending the session seen more than 100

02:01:56,159 --> 02:02:02,560
listeners and number has dropped so

02:01:59,520 --> 02:02:04,320
thank you and um see you soon if you

02:02:02,560 --> 02:02:07,040
have any further questions i'll be

02:02:04,320 --> 02:02:10,400
in slack please feel free to ping me um

02:02:07,040 --> 02:02:12,800
i may need some time to answer

02:02:10,400 --> 02:02:15,840
and uh but i'll i'll be going through

02:02:12,800 --> 02:02:15,840
all the questions you sent me

02:02:16,880 --> 02:02:19,840

YouTube URL: https://www.youtube.com/watch?v=e_Y0QzhlGn0


