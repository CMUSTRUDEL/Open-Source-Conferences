Title: Leveraging State Machines to Build Operators in Rust - Kevin Flansburg, Moose Consulting
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Leveraging State Machines to Build Operators in Rust - Kevin Flansburg, Moose Consulting

This talk will introduce and demonstrate Krator, a crate for building state-machine-based Operators in Rust. Last fall, the Krustlet team developed a state machine API for describing the Pod lifecycle for their Rust implementation of Kubelet. Based on interest from the community, this API was split out into a new crate (Krator) to allow it to be used to implement arbitrary Operators. First, the talk will walk through the process of developing a simple Operator with Krator, including a live demo. Next, it will explore the API in more detail, including design decisions that were made and how it meshes well with many Kubernetes design philosophies. Finally, it will outline some new and interesting Operator functionality that has been introduced, beyond what was needed to support Krustlet.
Captions: 
	00:00:00,000 --> 00:00:03,520
hello i'm kevin and this talk is going

00:00:02,159 --> 00:00:04,880
to be about building kubernetes

00:00:03,520 --> 00:00:06,480
operators in rust

00:00:04,880 --> 00:00:08,080
and in particular it's going to be about

00:00:06,480 --> 00:00:09,840
a crate that i've been working on

00:00:08,080 --> 00:00:13,280
which allows you to define the object

00:00:09,840 --> 00:00:15,440
life cycles using state machines

00:00:13,280 --> 00:00:17,279
first a little bit about myself i've

00:00:15,440 --> 00:00:18,800
been a rest developer for four years

00:00:17,279 --> 00:00:20,880
i've been working with kubernetes for

00:00:18,800 --> 00:00:22,000
one year i'm a maintainer on the

00:00:20,880 --> 00:00:23,199
crestlip project

00:00:22,000 --> 00:00:25,199
which we'll talk about a little bit

00:00:23,199 --> 00:00:27,439
later and i'm the lead developer on the

00:00:25,199 --> 00:00:28,560
crater crate which is the focus of this

00:00:27,439 --> 00:00:30,000
talk

00:00:28,560 --> 00:00:31,840
in this talk we're going to discuss

00:00:30,000 --> 00:00:32,800
crater's unique api for developing

00:00:31,840 --> 00:00:35,440
operators

00:00:32,800 --> 00:00:36,800
i'm going to demo an operator that was

00:00:35,440 --> 00:00:38,160
built using crater

00:00:36,800 --> 00:00:41,760
and then i'm going to discuss the

00:00:38,160 --> 00:00:43,120
upcoming features on craters roadmap

00:00:41,760 --> 00:00:45,440
first a little bit of background on

00:00:43,120 --> 00:00:46,719
crestlet crestlet stands for kubernetes

00:00:45,440 --> 00:00:48,239
rust cubelet

00:00:46,719 --> 00:00:50,640
and the goal of the project is to

00:00:48,239 --> 00:00:53,280
re-implement cubelet using rust

00:00:50,640 --> 00:00:54,719
and the focus of the project is to allow

00:00:53,280 --> 00:00:55,440
for the development of cubelets which

00:00:54,719 --> 00:00:57,199
support

00:00:55,440 --> 00:00:59,039
alternative and experimental types of

00:00:57,199 --> 00:01:01,920
workloads so the project

00:00:59,039 --> 00:01:02,879
includes two cubelets one using the

00:01:01,920 --> 00:01:06,320
wazey runtime

00:01:02,879 --> 00:01:08,000
and one using the wask runtime and this

00:01:06,320 --> 00:01:11,680
allows you to deploy

00:01:08,000 --> 00:01:13,439
wasm applications using a kubernetes

00:01:11,680 --> 00:01:15,360
cubelet

00:01:13,439 --> 00:01:17,040
so how did i get involved with

00:01:15,360 --> 00:01:20,479
developing operators

00:01:17,040 --> 00:01:23,040
well last fall we wanted to improve

00:01:20,479 --> 00:01:25,280
the api that was used to define the

00:01:23,040 --> 00:01:28,640
lifecycle of pods within the

00:01:25,280 --> 00:01:29,600
crestlet based cubelets and a cubelet is

00:01:28,640 --> 00:01:33,119
essentially a

00:01:29,600 --> 00:01:35,920
controller for managing pods

00:01:33,119 --> 00:01:37,200
and so we developed this state machine

00:01:35,920 --> 00:01:41,040
api

00:01:37,200 --> 00:01:43,759
and i presented it both in a blog post

00:01:41,040 --> 00:01:45,680
and at kubecon north america last fall

00:01:43,759 --> 00:01:47,920
and we got excellent feedback from the

00:01:45,680 --> 00:01:50,079
community and there was a huge desire

00:01:47,920 --> 00:01:52,240
to split out the state machine api to

00:01:50,079 --> 00:01:53,680
support arbitrary controllers and

00:01:52,240 --> 00:01:56,719
operators

00:01:53,680 --> 00:01:58,000
so that's how crater was started i split

00:01:56,719 --> 00:02:01,040
that out

00:01:58,000 --> 00:02:02,479
in december and january and then crater

00:02:01,040 --> 00:02:05,200
was officially launched

00:02:02,479 --> 00:02:07,360
in a blog post on february 1st and

00:02:05,200 --> 00:02:10,319
crater stands for kubernetes rust

00:02:07,360 --> 00:02:11,520
state machine operator next a little bit

00:02:10,319 --> 00:02:13,200
of prior art

00:02:11,520 --> 00:02:14,959
there's lots of frameworks out there for

00:02:13,200 --> 00:02:16,879
developing operators

00:02:14,959 --> 00:02:18,800
the biggest one is the operator sdk

00:02:16,879 --> 00:02:20,720
which is a cncf project

00:02:18,800 --> 00:02:22,319
it allows developing operators in go

00:02:20,720 --> 00:02:25,920
ansible and helm

00:02:22,319 --> 00:02:28,800
the go variant of this operator sdk

00:02:25,920 --> 00:02:29,760
uses goes controller runtime as well as

00:02:28,800 --> 00:02:31,680
cube builder

00:02:29,760 --> 00:02:33,760
and it pulls in the kubernetes types

00:02:31,680 --> 00:02:35,440
from the main kubernetes source code

00:02:33,760 --> 00:02:38,879
and it offers a lot of plumbing and

00:02:35,440 --> 00:02:42,080
templating around deploying operators

00:02:38,879 --> 00:02:44,400
the the helm variant has a

00:02:42,080 --> 00:02:45,920
limited subset of functionality but it

00:02:44,400 --> 00:02:48,560
allows you to get deploying

00:02:45,920 --> 00:02:50,400
oper your operator very quickly by

00:02:48,560 --> 00:02:53,040
simply supplying a helm chart

00:02:50,400 --> 00:02:53,840
and then the custom resource definition

00:02:53,040 --> 00:02:55,840
spec

00:02:53,840 --> 00:02:57,519
contains helm chart values which are

00:02:55,840 --> 00:02:59,200
populated and then applied

00:02:57,519 --> 00:03:01,680
and then the operator ensures that the

00:02:59,200 --> 00:03:03,840
helm chart stays consistent with cluster

00:03:01,680 --> 00:03:07,360
state

00:03:03,840 --> 00:03:10,720
other languages such as python and and

00:03:07,360 --> 00:03:13,040
ruby etc uh all have uh

00:03:10,720 --> 00:03:14,239
controller frameworks which tend to sit

00:03:13,040 --> 00:03:16,239
on top of the

00:03:14,239 --> 00:03:17,519
main kubernetes client library for that

00:03:16,239 --> 00:03:19,440
language

00:03:17,519 --> 00:03:21,040
these offer limited functionality for

00:03:19,440 --> 00:03:24,159
controllers

00:03:21,040 --> 00:03:26,080
and rust includes this as well the cube

00:03:24,159 --> 00:03:27,280
and cube runtime crates are both very

00:03:26,080 --> 00:03:30,080
excellent

00:03:27,280 --> 00:03:31,360
both crater and crestlet rely on them

00:03:30,080 --> 00:03:33,840
under the hood

00:03:31,360 --> 00:03:34,720
but cube runtime provides a controller

00:03:33,840 --> 00:03:38,640
api

00:03:34,720 --> 00:03:41,040
for rust some background on the basic

00:03:38,640 --> 00:03:43,200
frameworks that i mentioned above

00:03:41,040 --> 00:03:45,680
they typically just watch for for

00:03:43,200 --> 00:03:48,720
resources of a specific type

00:03:45,680 --> 00:03:50,640
you you have to sort of explicitly

00:03:48,720 --> 00:03:53,360
define that watching logic

00:03:50,640 --> 00:03:54,640
and then you have methods that you

00:03:53,360 --> 00:03:56,959
populate for create

00:03:54,640 --> 00:03:58,720
update and delete events for for your

00:03:56,959 --> 00:04:01,360
managed resource

00:03:58,720 --> 00:04:03,519
and these methods can be end up being

00:04:01,360 --> 00:04:06,720
quite large and monolithic

00:04:03,519 --> 00:04:08,720
and it doesn't provide a great structure

00:04:06,720 --> 00:04:13,040
for you to define your operator's logic

00:04:08,720 --> 00:04:15,599
in so more sophisticated frameworks like

00:04:13,040 --> 00:04:18,239
the go operator sdk

00:04:15,599 --> 00:04:19,040
do a lot of code generation for you they

00:04:18,239 --> 00:04:20,880
wrap

00:04:19,040 --> 00:04:23,759
the logic of your controller with a lot

00:04:20,880 --> 00:04:26,880
of boilerplate that is required to

00:04:23,759 --> 00:04:28,960
build good and reliable controllers

00:04:26,880 --> 00:04:31,280
and they offer a very sophisticated api

00:04:28,960 --> 00:04:33,360
for that and they have extended features

00:04:31,280 --> 00:04:35,360
such as the ability to easily add

00:04:33,360 --> 00:04:37,199
validating or mutating admissions web

00:04:35,360 --> 00:04:39,840
hooks

00:04:37,199 --> 00:04:41,600
and other extended features which we'll

00:04:39,840 --> 00:04:43,600
discuss later

00:04:41,600 --> 00:04:45,600
so some common features in all of these

00:04:43,600 --> 00:04:47,680
frameworks is that there tends to be

00:04:45,600 --> 00:04:49,199
kind of a single method that you're

00:04:47,680 --> 00:04:52,000
intended to implement

00:04:49,199 --> 00:04:53,840
in which you determine the difference

00:04:52,000 --> 00:04:56,240
between the desired state of the

00:04:53,840 --> 00:04:59,120
application that's defined in the crd

00:04:56,240 --> 00:05:01,120
and the existing state of the cluster or

00:04:59,120 --> 00:05:02,400
or whatever resources your operator is

00:05:01,120 --> 00:05:04,000
managing

00:05:02,400 --> 00:05:06,080
and these functions tend to be very

00:05:04,000 --> 00:05:08,479
complex and

00:05:06,080 --> 00:05:11,280
you're kind of left your own devices to

00:05:08,479 --> 00:05:14,320
split up that logic into a reasonable

00:05:11,280 --> 00:05:16,639
and maintainable piece of code

00:05:14,320 --> 00:05:17,440
so the state machine api was an attempt

00:05:16,639 --> 00:05:20,000
to

00:05:17,440 --> 00:05:20,720
increase the reliability of of

00:05:20,000 --> 00:05:23,759
implementing

00:05:20,720 --> 00:05:24,720
this kind of application logic and break

00:05:23,759 --> 00:05:27,840
up

00:05:24,720 --> 00:05:28,880
these monolithic functions so the

00:05:27,840 --> 00:05:32,400
general approach

00:05:28,880 --> 00:05:33,520
is that for each sort of area of concern

00:05:32,400 --> 00:05:35,440
that you might have in your

00:05:33,520 --> 00:05:36,080
application's logic so an example would

00:05:35,440 --> 00:05:38,880
be

00:05:36,080 --> 00:05:40,560
pulling images for pods or mounting

00:05:38,880 --> 00:05:41,280
volumes these would be separate areas of

00:05:40,560 --> 00:05:44,160
concern

00:05:41,280 --> 00:05:45,759
you would define a node in your state

00:05:44,160 --> 00:05:47,680
machine graph

00:05:45,759 --> 00:05:48,800
and you can define an arbitrary state

00:05:47,680 --> 00:05:52,080
machine graph

00:05:48,800 --> 00:05:53,600
for your application these nodes are

00:05:52,080 --> 00:05:56,400
intended to be

00:05:53,600 --> 00:05:57,919
infallible and if they do encounter an

00:05:56,400 --> 00:06:00,000
error they should transition to an

00:05:57,919 --> 00:06:01,039
explicit error node in the state machine

00:06:00,000 --> 00:06:04,000
graph

00:06:01,039 --> 00:06:06,720
which allows better error handling and

00:06:04,000 --> 00:06:10,720
and retrying and things like that

00:06:06,720 --> 00:06:13,039
um and then uh the state handlers i use

00:06:10,720 --> 00:06:15,199
uh the term i use as handlers and that's

00:06:13,039 --> 00:06:16,000
the actual body of code that's executed

00:06:15,199 --> 00:06:19,280
within

00:06:16,000 --> 00:06:22,080
each node in the state machine graph

00:06:19,280 --> 00:06:23,120
so this offers some some really great

00:06:22,080 --> 00:06:26,240
benefits

00:06:23,120 --> 00:06:29,280
um the first is that the

00:06:26,240 --> 00:06:32,400
rust compiler can enforce a lot of uh

00:06:29,280 --> 00:06:35,360
nice safety guarantees on the

00:06:32,400 --> 00:06:37,840
behavior of your operator so you can

00:06:35,360 --> 00:06:41,199
ensure that

00:06:37,840 --> 00:06:43,759
the state of your object only ever

00:06:41,199 --> 00:06:47,680
transitions between states that you've

00:06:43,759 --> 00:06:51,039
considered and it only transitions to

00:06:47,680 --> 00:06:51,840
well-defined states and by using

00:06:51,039 --> 00:06:55,199
infallible

00:06:51,840 --> 00:06:58,319
state handlers we're able to sort of

00:06:55,199 --> 00:07:01,840
avoid just completely dropping

00:06:58,319 --> 00:07:04,639
the management of objects and

00:07:01,840 --> 00:07:05,840
better encode the retry logic that you

00:07:04,639 --> 00:07:08,639
may want to use with your

00:07:05,840 --> 00:07:10,400
your application and then some other

00:07:08,639 --> 00:07:12,400
things that you get out of the box

00:07:10,400 --> 00:07:15,039
uh crater is able to automatically

00:07:12,400 --> 00:07:16,000
update the kubernetes api to reflect the

00:07:15,039 --> 00:07:19,440
state that you're currently

00:07:16,000 --> 00:07:21,199
in it provides the latest version of the

00:07:19,440 --> 00:07:22,960
object at all times to your state

00:07:21,199 --> 00:07:24,800
handler

00:07:22,960 --> 00:07:26,479
and finally in crestlet we're able to

00:07:24,800 --> 00:07:28,240
supply a number of

00:07:26,479 --> 00:07:29,520
common states that you may wish to

00:07:28,240 --> 00:07:30,000
implement if you're implementing a

00:07:29,520 --> 00:07:33,440
cubelet

00:07:30,000 --> 00:07:35,360
specifically so digging a little bit

00:07:33,440 --> 00:07:37,280
deeper into the crater api

00:07:35,360 --> 00:07:38,639
there's really four major traits that

00:07:37,280 --> 00:07:41,039
you need to be aware of

00:07:38,639 --> 00:07:42,240
the operator trait you're intended to

00:07:41,039 --> 00:07:44,639
implement a

00:07:42,240 --> 00:07:45,520
type which implements operator and this

00:07:44,639 --> 00:07:48,720
is uh

00:07:45,520 --> 00:07:50,560
created as a singleton and this has some

00:07:48,720 --> 00:07:53,039
associated types on it

00:07:50,560 --> 00:07:54,560
namely manifest initial state and

00:07:53,039 --> 00:07:56,639
deleted state

00:07:54,560 --> 00:07:58,080
and we'll we'll discuss the roles of

00:07:56,639 --> 00:08:01,520
these types a little bit later

00:07:58,080 --> 00:08:03,599
in the demo next is the state trait

00:08:01,520 --> 00:08:05,199
this is to be implemented for each state

00:08:03,599 --> 00:08:07,520
in your state machine graph so you'll

00:08:05,199 --> 00:08:10,240
implement this a number of times

00:08:07,520 --> 00:08:11,759
and this has methods for defining the

00:08:10,240 --> 00:08:13,199
status that should be reported to the

00:08:11,759 --> 00:08:15,039
kubernetes api

00:08:13,199 --> 00:08:17,199
when entering this state and then of

00:08:15,039 --> 00:08:18,080
course the state handler is the the next

00:08:17,199 --> 00:08:20,800
function

00:08:18,080 --> 00:08:22,319
which returns a indication of which

00:08:20,800 --> 00:08:25,039
state should be transitioned to or

00:08:22,319 --> 00:08:26,720
whether the state machine should exit

00:08:25,039 --> 00:08:29,440
the remaining two traits are used to

00:08:26,720 --> 00:08:32,320
define types that will be

00:08:29,440 --> 00:08:33,760
provided to your your state machine uh

00:08:32,320 --> 00:08:36,719
your state handler

00:08:33,760 --> 00:08:38,719
so there's object status that defines

00:08:36,719 --> 00:08:40,560
the schema of the status that's reported

00:08:38,719 --> 00:08:42,880
to the kubernetes api

00:08:40,560 --> 00:08:45,519
and then there's object state which

00:08:42,880 --> 00:08:48,160
defines the state that is

00:08:45,519 --> 00:08:49,200
kept the data that's kept associated

00:08:48,160 --> 00:08:52,080
with a single

00:08:49,200 --> 00:08:52,720
state machine or a single object and

00:08:52,080 --> 00:08:54,640
then there's

00:08:52,720 --> 00:08:56,000
an associated type shared state which

00:08:54,640 --> 00:08:56,480
represents the data that is shared

00:08:56,000 --> 00:08:58,880
across

00:08:56,480 --> 00:09:00,880
all state machines or all objects that

00:08:58,880 --> 00:09:03,200
your operator is managing

00:09:00,880 --> 00:09:04,640
and next i'd like to walk through a sort

00:09:03,200 --> 00:09:06,320
of canonical demo

00:09:04,640 --> 00:09:07,680
uh that i developed for the original

00:09:06,320 --> 00:09:10,399
crater blog post

00:09:07,680 --> 00:09:12,399
and utilizes a lot of the features of

00:09:10,399 --> 00:09:13,920
craters api

00:09:12,399 --> 00:09:16,640
so if you'd like to try this demo at

00:09:13,920 --> 00:09:19,279
home it is all of the code is

00:09:16,640 --> 00:09:20,240
located in the examples directory within

00:09:19,279 --> 00:09:23,680
the crater

00:09:20,240 --> 00:09:25,120
sub crate within the main crustlet

00:09:23,680 --> 00:09:28,080
repository

00:09:25,120 --> 00:09:30,000
so if i go into this examples directory

00:09:28,080 --> 00:09:31,600
you can see moose.rs that's the

00:09:30,000 --> 00:09:33,760
implementation of the operator

00:09:31,600 --> 00:09:34,640
and then assets has a number of useful

00:09:33,760 --> 00:09:36,480
scripts and

00:09:34,640 --> 00:09:39,519
manifests for playing around with the

00:09:36,480 --> 00:09:43,200
operator so just quickly going through

00:09:39,519 --> 00:09:46,080
the code for moose.rs i use

00:09:43,200 --> 00:09:48,560
cube the cubecrates custom resource

00:09:46,080 --> 00:09:52,160
derived macro to specify

00:09:48,560 --> 00:09:53,600
the type for my custom resource

00:09:52,160 --> 00:09:56,560
and this is great because i just have to

00:09:53,600 --> 00:09:59,680
specify the contents of the spec field

00:09:56,560 --> 00:10:01,360
and it derives the rest of the type

00:09:59,680 --> 00:10:03,200
but one thing that i'd like to call out

00:10:01,360 --> 00:10:04,240
is that crater requires that the status

00:10:03,200 --> 00:10:06,320
field is used

00:10:04,240 --> 00:10:07,920
that's optional on custom resources but

00:10:06,320 --> 00:10:11,279
it's required by crater

00:10:07,920 --> 00:10:14,079
so i name a status type that i've

00:10:11,279 --> 00:10:14,079
defined below

00:10:14,320 --> 00:10:17,680
this status type gets the first trait

00:10:16,399 --> 00:10:20,560
implementation

00:10:17,680 --> 00:10:22,240
from crater there's a method for

00:10:20,560 --> 00:10:22,880
creating a failed status in the event

00:10:22,240 --> 00:10:25,279
that crater

00:10:22,880 --> 00:10:27,680
has an issue within its own run time and

00:10:25,279 --> 00:10:30,079
needs to report that the object failed

00:10:27,680 --> 00:10:31,680
to kubernetes and then there's also a

00:10:30,079 --> 00:10:33,600
method where you should

00:10:31,680 --> 00:10:35,839
take any information that's captured in

00:10:33,600 --> 00:10:39,440
your status and produce a json patch

00:10:35,839 --> 00:10:42,560
that will be sent to the kubernetes api

00:10:39,440 --> 00:10:44,720
next there's moose state now this is the

00:10:42,560 --> 00:10:47,120
data that is shared

00:10:44,720 --> 00:10:49,279
amongst state handlers for a specific

00:10:47,120 --> 00:10:49,839
object state machine so it is not shared

00:10:49,279 --> 00:10:53,040
between

00:10:49,839 --> 00:10:55,680
objects of a given resource type there's

00:10:53,040 --> 00:10:58,320
a trait implementation for this object

00:10:55,680 --> 00:10:59,680
which specifies the custom resource type

00:10:58,320 --> 00:11:01,760
that we defined above

00:10:59,680 --> 00:11:03,440
the status type for that resource and

00:11:01,760 --> 00:11:04,160
then there is a type for sharing state

00:11:03,440 --> 00:11:07,200
between

00:11:04,160 --> 00:11:09,360
objects which is defined below and then

00:11:07,200 --> 00:11:11,600
finally there's an async drop handler if

00:11:09,360 --> 00:11:14,800
you run need to run asynchronous code

00:11:11,600 --> 00:11:15,839
when the object is deregistered looking

00:11:14,800 --> 00:11:18,160
at the first state

00:11:15,839 --> 00:11:18,880
implementation this is the registration

00:11:18,160 --> 00:11:22,480
state

00:11:18,880 --> 00:11:24,160
where where a moose is first created

00:11:22,480 --> 00:11:26,399
you have to implement the state trait

00:11:24,160 --> 00:11:28,160
for each of your states and

00:11:26,399 --> 00:11:29,920
here there's a method called status

00:11:28,160 --> 00:11:31,519
which simply produces the status type

00:11:29,920 --> 00:11:32,560
that we defined above for that given

00:11:31,519 --> 00:11:34,640
state

00:11:32,560 --> 00:11:36,560
this is called when the state is entered

00:11:34,640 --> 00:11:41,680
and should report the status

00:11:36,560 --> 00:11:44,640
to the api kubernetes api for this state

00:11:41,680 --> 00:11:46,320
the other method here is the next method

00:11:44,640 --> 00:11:47,839
i also refer to this as the state

00:11:46,320 --> 00:11:50,639
handler and this is the body of code

00:11:47,839 --> 00:11:53,839
that's executed for a given state

00:11:50,639 --> 00:11:55,279
it has access to an arc rw lock to any

00:11:53,839 --> 00:11:57,360
shared state

00:11:55,279 --> 00:11:58,959
it has access to the state for this

00:11:57,360 --> 00:12:00,720
specific object which it has

00:11:58,959 --> 00:12:02,320
a mutable reference to because that is

00:12:00,720 --> 00:12:04,480
owned by this object

00:12:02,320 --> 00:12:06,320
and then it has access to this manifest

00:12:04,480 --> 00:12:08,079
type and this manifest type

00:12:06,320 --> 00:12:09,360
implements streams so you can watch for

00:12:08,079 --> 00:12:12,079
changes to

00:12:09,360 --> 00:12:13,680
the the object and it also has a method

00:12:12,079 --> 00:12:15,680
called latest which supplies

00:12:13,680 --> 00:12:17,360
the latest copy of the object

00:12:15,680 --> 00:12:19,680
immediately

00:12:17,360 --> 00:12:20,560
so you can see here i run some code to

00:12:19,680 --> 00:12:23,120
to

00:12:20,560 --> 00:12:24,560
create register this object in the

00:12:23,120 --> 00:12:27,440
shared state

00:12:24,560 --> 00:12:28,320
and then i call transition next and tell

00:12:27,440 --> 00:12:31,360
crater which

00:12:28,320 --> 00:12:33,360
state i'd like to transition to

00:12:31,360 --> 00:12:35,200
now in order to transition to a state i

00:12:33,360 --> 00:12:36,320
have to implement transition to and

00:12:35,200 --> 00:12:38,880
explicitly

00:12:36,320 --> 00:12:40,160
tag that transition as as valid with the

00:12:38,880 --> 00:12:43,200
compiler

00:12:40,160 --> 00:12:44,560
and this is to improve the

00:12:43,200 --> 00:12:46,639
the rigor of the state machine

00:12:44,560 --> 00:12:50,079
implementation and ensure that

00:12:46,639 --> 00:12:51,760
invalid state transitions are not taken

00:12:50,079 --> 00:12:53,600
i'm not going to go into too much detail

00:12:51,760 --> 00:12:55,440
on all of these states but i just like

00:12:53,600 --> 00:12:55,839
to call out that there's a derived macro

00:12:55,440 --> 00:12:59,839
for

00:12:55,839 --> 00:13:01,680
for defining valid transitions um

00:12:59,839 --> 00:13:03,920
and then i'll just uh comment on the

00:13:01,680 --> 00:13:06,320
behavior of the state machine so

00:13:03,920 --> 00:13:08,880
the next state is roaming around the

00:13:06,320 --> 00:13:10,639
moose will do that until it gets hungry

00:13:08,880 --> 00:13:12,639
and with some probability it'll make a

00:13:10,639 --> 00:13:16,079
friend and update that shared state

00:13:12,639 --> 00:13:17,760
map when it gets hungry it transitions

00:13:16,079 --> 00:13:20,079
to the eating state

00:13:17,760 --> 00:13:22,079
this simply waits for some duration and

00:13:20,079 --> 00:13:23,680
then replenishes the moose's food

00:13:22,079 --> 00:13:26,560
and then transitions to the sleeping

00:13:23,680 --> 00:13:28,560
state uh from the sleeping state

00:13:26,560 --> 00:13:30,399
we simply wait 20 seconds and then

00:13:28,560 --> 00:13:33,200
transition back to roaming

00:13:30,399 --> 00:13:35,279
and then the final state is a deleted or

00:13:33,200 --> 00:13:38,399
or deregistration state

00:13:35,279 --> 00:13:41,199
this is a state that on

00:13:38,399 --> 00:13:42,160
an operator like a cubelet uh you may

00:13:41,199 --> 00:13:45,360
transition to

00:13:42,160 --> 00:13:47,120
within the handlers of other

00:13:45,360 --> 00:13:49,040
other states in your state machine graph

00:13:47,120 --> 00:13:50,800
so a pod may be running and then

00:13:49,040 --> 00:13:52,639
it exits and it's successful and you

00:13:50,800 --> 00:13:56,079
transition to the completed state

00:13:52,639 --> 00:13:58,399
and that exits the state machine or

00:13:56,079 --> 00:14:00,160
in the case of this operator i never

00:13:58,399 --> 00:14:02,720
explicitly transition to it and the

00:14:00,160 --> 00:14:05,040
state machine simply runs forever

00:14:02,720 --> 00:14:06,320
however when an object is deleted with

00:14:05,040 --> 00:14:08,399
the kubernetes api

00:14:06,320 --> 00:14:09,360
crater needs to transition to a state

00:14:08,399 --> 00:14:13,040
that allows the

00:14:09,360 --> 00:14:15,680
object to clean up and then exit and so

00:14:13,040 --> 00:14:17,680
this state needs to exist for crater to

00:14:15,680 --> 00:14:19,680
transition to it will interrupt the

00:14:17,680 --> 00:14:22,000
execution of the state machine

00:14:19,680 --> 00:14:23,600
transition to this state and then

00:14:22,000 --> 00:14:25,839
execute from this state

00:14:23,600 --> 00:14:27,760
until the state machine exits and you

00:14:25,839 --> 00:14:29,839
can see that this state calls transition

00:14:27,760 --> 00:14:32,480
complete which

00:14:29,839 --> 00:14:34,079
completes and and terminates the the

00:14:32,480 --> 00:14:35,920
execution of the state machine

00:14:34,079 --> 00:14:37,760
and then it returns a result which

00:14:35,920 --> 00:14:40,720
indicates whether the state machine

00:14:37,760 --> 00:14:41,920
exited gracefully or not for our shared

00:14:40,720 --> 00:14:44,959
state i have a simple

00:14:41,920 --> 00:14:48,160
hash map of relationships between mooses

00:14:44,959 --> 00:14:52,320
and then i implement moose tracker this

00:14:48,160 --> 00:14:55,040
is the type that will implement

00:14:52,320 --> 00:14:57,440
our operator trait and these are created

00:14:55,040 --> 00:14:59,920
essentially as singletons

00:14:57,440 --> 00:15:02,000
so scrolling down this is the

00:14:59,920 --> 00:15:04,880
implementation of the operator trait

00:15:02,000 --> 00:15:05,839
i again reference the status and

00:15:04,880 --> 00:15:08,480
resource

00:15:05,839 --> 00:15:10,480
type definitions from above i indicate

00:15:08,480 --> 00:15:12,000
that the tag state is the first state

00:15:10,480 --> 00:15:14,480
that should be entered when an object

00:15:12,000 --> 00:15:16,240
state machine is created i indicate that

00:15:14,480 --> 00:15:17,839
the release state is that that state

00:15:16,240 --> 00:15:19,279
that should be transitioned to when an

00:15:17,839 --> 00:15:22,399
object is deleted

00:15:19,279 --> 00:15:22,880
and finally i reference the state type

00:15:22,399 --> 00:15:26,160
that is

00:15:22,880 --> 00:15:27,600
is specific to each object

00:15:26,160 --> 00:15:29,839
there's a couple of methods that need to

00:15:27,600 --> 00:15:32,880
be implemented so the first is to

00:15:29,839 --> 00:15:34,240
create that initial state type for a

00:15:32,880 --> 00:15:36,639
given object

00:15:34,240 --> 00:15:37,920
when the state machine is starting and

00:15:36,639 --> 00:15:40,720
this can reference

00:15:37,920 --> 00:15:42,720
the manifest of that object or any

00:15:40,720 --> 00:15:45,120
shared state on the operator

00:15:42,720 --> 00:15:45,759
next is a crater needs to be able to

00:15:45,120 --> 00:15:49,040
fetch

00:15:45,759 --> 00:15:50,800
a arc rw lock reference to the shared

00:15:49,040 --> 00:15:52,000
state so that it can supply it to the

00:15:50,800 --> 00:15:53,920
state handlers

00:15:52,000 --> 00:15:56,160
and so there's a method that you need to

00:15:53,920 --> 00:15:58,240
implement here to simply uh

00:15:56,160 --> 00:15:59,440
you know create an uh a clone of that

00:15:58,240 --> 00:16:02,079
that arc and

00:15:59,440 --> 00:16:03,519
return it to crater and then finally

00:16:02,079 --> 00:16:04,800
i've been working on some extended

00:16:03,519 --> 00:16:07,519
functionality to support

00:16:04,800 --> 00:16:08,560
uh admissions uh validating and mutating

00:16:07,519 --> 00:16:12,000
web hooks

00:16:08,560 --> 00:16:13,120
and here it's hidden behind a compiler

00:16:12,000 --> 00:16:16,079
feature flag

00:16:13,120 --> 00:16:18,399
but essentially you get a copy of the

00:16:16,079 --> 00:16:21,600
object that's that's trying to be

00:16:18,399 --> 00:16:23,199
changed or deleted or created and of

00:16:21,600 --> 00:16:24,480
course you can reference any shared

00:16:23,199 --> 00:16:26,560
state on the operator

00:16:24,480 --> 00:16:28,160
uh if you need to validate within sort

00:16:26,560 --> 00:16:30,399
of the context of all of the objects

00:16:28,160 --> 00:16:32,959
that the operator is managing

00:16:30,399 --> 00:16:34,720
and then here i'm simply validating that

00:16:32,959 --> 00:16:37,759
the moose's name starts with the letter

00:16:34,720 --> 00:16:41,199
m and then i can allow

00:16:37,759 --> 00:16:43,040
the object or the the change to to occur

00:16:41,199 --> 00:16:46,399
and then i can optionally mutate the

00:16:43,040 --> 00:16:49,440
object here i'm i'm leaving it unmutated

00:16:46,399 --> 00:16:51,440
or i can deny the object and

00:16:49,440 --> 00:16:53,279
return kind of a standard kubernetes

00:16:51,440 --> 00:16:55,360
status which indicates why this has been

00:16:53,279 --> 00:16:58,399
denied and that will be returned

00:16:55,360 --> 00:17:02,160
by the kubernetes kubernetes api

00:16:58,399 --> 00:17:02,959
to the client so scrolling down a little

00:17:02,160 --> 00:17:05,919
bit

00:17:02,959 --> 00:17:07,520
this final piece of code is our main

00:17:05,919 --> 00:17:09,760
function and it's all you need to do to

00:17:07,520 --> 00:17:12,640
actually start an operator with crater

00:17:09,760 --> 00:17:13,839
so i create a cube config which i simply

00:17:12,640 --> 00:17:16,400
infer

00:17:13,839 --> 00:17:16,880
i create my operator singleton and then

00:17:16,400 --> 00:17:20,000
i call

00:17:16,880 --> 00:17:20,799
operator runtime new and uh pass it that

00:17:20,000 --> 00:17:23,919
cubeconfig

00:17:20,799 --> 00:17:25,839
and that operator singleton and then i

00:17:23,919 --> 00:17:28,559
can optionally supply list parameters to

00:17:25,839 --> 00:17:30,679
filter uh the objects that i'm managing

00:17:28,559 --> 00:17:32,480
and then finally i call

00:17:30,679 --> 00:17:33,840
runtimestart.weight and that'll block

00:17:32,480 --> 00:17:36,960
forever

00:17:33,840 --> 00:17:38,799
and it will spawn asynchronous tasks

00:17:36,960 --> 00:17:41,200
for the execution of the state machines

00:17:38,799 --> 00:17:44,799
for each object that's created

00:17:41,200 --> 00:17:44,799
so if i exit out of this

00:17:44,840 --> 00:17:52,080
and uh i come up and

00:17:48,799 --> 00:17:55,200
re-run my operator

00:17:52,080 --> 00:17:55,840
you can see that i am setting uh the

00:17:55,200 --> 00:17:58,799
moose

00:17:55,840 --> 00:18:00,559
module as well as all of crater to debug

00:17:58,799 --> 00:18:02,720
for the purposes of this demo and i'm

00:18:00,559 --> 00:18:03,440
i'm also activating the admissions web

00:18:02,720 --> 00:18:06,160
hook

00:18:03,440 --> 00:18:06,640
so that i can show you that so if i run

00:18:06,160 --> 00:18:10,880
this

00:18:06,640 --> 00:18:15,600
it'll i'm in the wrong directory

00:18:10,880 --> 00:18:18,160
there we go it'll print out the crd

00:18:15,600 --> 00:18:18,960
here um but it doesn't actually apply it

00:18:18,160 --> 00:18:20,960
um

00:18:18,960 --> 00:18:23,520
the crd is located in the assets

00:18:20,960 --> 00:18:25,760
directory uh within the examples folder

00:18:23,520 --> 00:18:28,559
so you can apply this yourself if you

00:18:25,760 --> 00:18:30,160
want to play around

00:18:28,559 --> 00:18:32,160
but you can see here that there was

00:18:30,160 --> 00:18:33,919
already a moose registered with the api

00:18:32,160 --> 00:18:36,640
so we got a resync event

00:18:33,919 --> 00:18:36,960
uh when we started watching for mooses

00:18:36,640 --> 00:18:39,280
we

00:18:36,960 --> 00:18:41,039
created an event handler here that's

00:18:39,280 --> 00:18:45,120
creating a state machine for this

00:18:41,039 --> 00:18:49,760
this moose let me scroll up

00:18:45,120 --> 00:18:49,760
and there's a number of

00:18:50,240 --> 00:18:55,200
pieces of logging here and i'll talk

00:18:52,080 --> 00:18:57,600
about that a little bit later

00:18:55,200 --> 00:18:58,400
but initially the moose enters the tag

00:18:57,600 --> 00:19:00,960
state

00:18:58,400 --> 00:19:02,000
uh and there is a status update that's

00:19:00,960 --> 00:19:04,400
patched

00:19:02,000 --> 00:19:06,000
uh excuse me there's a status update

00:19:04,400 --> 00:19:07,520
that's patched to kubernetes when it

00:19:06,000 --> 00:19:10,480
enters this state

00:19:07,520 --> 00:19:12,080
uh and then next it transitions to the

00:19:10,480 --> 00:19:13,120
roaming state and there's a status

00:19:12,080 --> 00:19:15,600
update for that

00:19:13,120 --> 00:19:17,600
and then the moose will continue to move

00:19:15,600 --> 00:19:20,640
through its states

00:19:17,600 --> 00:19:22,000
as the operator progresses so here in

00:19:20,640 --> 00:19:25,919
canines

00:19:22,000 --> 00:19:28,880
you can see i can list mooses

00:19:25,919 --> 00:19:30,480
and i have set certain fields on the

00:19:28,880 --> 00:19:34,080
status to be printed out

00:19:30,480 --> 00:19:35,600
when you use cube cuddle and so we can

00:19:34,080 --> 00:19:37,120
see the moose transitioning through the

00:19:35,600 --> 00:19:40,240
states

00:19:37,120 --> 00:19:43,280
for the purposes of this demo i can

00:19:40,240 --> 00:19:48,080
generate a large number

00:19:43,280 --> 00:19:51,520
of mooses so here i generate 25

00:19:48,080 --> 00:19:52,160
new mooses and the amount of time that

00:19:51,520 --> 00:19:54,080
the moose

00:19:52,160 --> 00:19:55,840
spends in the roaming state is

00:19:54,080 --> 00:19:57,280
determined by its body weight that that

00:19:55,840 --> 00:19:57,919
determines how long it takes to get

00:19:57,280 --> 00:19:59,280
hungry and

00:19:57,919 --> 00:20:01,039
and the body weight is sampled from a

00:19:59,280 --> 00:20:03,600
normal distribution so

00:20:01,039 --> 00:20:05,200
uh the mooses should go through the

00:20:03,600 --> 00:20:06,480
state machine at different rates which

00:20:05,200 --> 00:20:08,960
which makes it a little bit more

00:20:06,480 --> 00:20:08,960
interesting

00:20:09,039 --> 00:20:13,440
and then finally i can demonstrate the

00:20:10,960 --> 00:20:16,400
uh the web hook capability so

00:20:13,440 --> 00:20:18,240
i have a moose here named george which

00:20:16,400 --> 00:20:21,520
is an invalid name

00:20:18,240 --> 00:20:24,960
according to my rule and so i can

00:20:21,520 --> 00:20:28,080
apply this manifest

00:20:24,960 --> 00:20:29,520
and you can see uh in the log that the

00:20:28,080 --> 00:20:32,000
request was denied

00:20:29,520 --> 00:20:32,799
that went by quickly but you can also

00:20:32,000 --> 00:20:36,400
see that the

00:20:32,799 --> 00:20:40,000
response returned to the client is

00:20:36,400 --> 00:20:43,360
that this is a invalid moose name

00:20:40,000 --> 00:20:46,480
so hopefully this has been a

00:20:43,360 --> 00:20:48,799
a nice overview of the api and

00:20:46,480 --> 00:20:50,080
the functionality that you can implement

00:20:48,799 --> 00:20:53,280
fairly concisely

00:20:50,080 --> 00:20:53,280
using the crater api

00:20:54,159 --> 00:20:57,280
next i'd like to talk a little bit about

00:20:55,760 --> 00:20:59,280
some new functionality i've been working

00:20:57,280 --> 00:21:00,880
on with crestlit and crater

00:20:59,280 --> 00:21:02,480
the first is that both crates have

00:21:00,880 --> 00:21:05,200
transitioned to using tracing

00:21:02,480 --> 00:21:07,280
for all logging events that we emit and

00:21:05,200 --> 00:21:09,280
this offers full compatibility with the

00:21:07,280 --> 00:21:11,360
original log crate that we were using so

00:21:09,280 --> 00:21:14,480
it shouldn't require any changes

00:21:11,360 --> 00:21:15,919
for consumers of our crate

00:21:14,480 --> 00:21:17,919
additionally i've been working on some

00:21:15,919 --> 00:21:20,960
extended functionality for crater

00:21:17,919 --> 00:21:22,400
so wherever log

00:21:20,960 --> 00:21:25,360
events were emitted where we were

00:21:22,400 --> 00:21:27,679
populating strings with the value of

00:21:25,360 --> 00:21:29,679
variables those have been pulled out

00:21:27,679 --> 00:21:32,880
into structured fields

00:21:29,679 --> 00:21:35,039
which should allow you to dissect the

00:21:32,880 --> 00:21:38,640
log output of crater using a

00:21:35,039 --> 00:21:42,080
tool like jq for json parsing

00:21:38,640 --> 00:21:44,640
and then i've added several key spans to

00:21:42,080 --> 00:21:45,360
the tracing instrumentation in crater

00:21:44,640 --> 00:21:47,280
namely

00:21:45,360 --> 00:21:48,400
whenever an admission web hook request

00:21:47,280 --> 00:21:51,760
is processed

00:21:48,400 --> 00:21:52,799
whenever a single state node is executed

00:21:51,760 --> 00:21:54,559
for an object

00:21:52,799 --> 00:21:56,559
and then whenever an update is received

00:21:54,559 --> 00:21:59,120
from the kubernetes api

00:21:56,559 --> 00:22:01,200
and is processed and if you'd like to

00:21:59,120 --> 00:22:04,400
read a little bit more about

00:22:01,200 --> 00:22:08,480
tracing luca palmieri has an excellent

00:22:04,400 --> 00:22:10,720
blog post slash book on deploying rust

00:22:08,480 --> 00:22:12,480
in cloud native environments and and has

00:22:10,720 --> 00:22:14,559
an entire section on tracing that's

00:22:12,480 --> 00:22:16,559
that's really excellent

00:22:14,559 --> 00:22:18,559
uh finally i'd like to talk about uh

00:22:16,559 --> 00:22:21,600
craters road map a little bit

00:22:18,559 --> 00:22:24,559
so uh on in the near term i'd like to

00:22:21,600 --> 00:22:25,440
expand the ability to easily subscribe

00:22:24,559 --> 00:22:27,360
to

00:22:25,440 --> 00:22:29,360
watching different types of kubernetes

00:22:27,360 --> 00:22:30,880
resources and i have an rfc out on

00:22:29,360 --> 00:22:33,520
github for the api

00:22:30,880 --> 00:22:35,280
proposal there in addition to that i'd

00:22:33,520 --> 00:22:37,840
like to think a little bit about

00:22:35,280 --> 00:22:39,360
how the state machine api can be

00:22:37,840 --> 00:22:42,240
improved to

00:22:39,360 --> 00:22:43,520
sort of identify where cluster state may

00:22:42,240 --> 00:22:46,159
be deviating from

00:22:43,520 --> 00:22:48,320
desired state and how to trigger

00:22:46,159 --> 00:22:50,320
reconciliation within the context of a

00:22:48,320 --> 00:22:52,400
state machine

00:22:50,320 --> 00:22:54,400
finally i'd like to expand the

00:22:52,400 --> 00:22:56,640
templating and

00:22:54,400 --> 00:22:57,840
sort of boilerplate generation

00:22:56,640 --> 00:23:00,000
surrounding

00:22:57,840 --> 00:23:02,400
creating and deploying operators this is

00:23:00,000 --> 00:23:04,400
something that's offered by the go sdk

00:23:02,400 --> 00:23:06,880
and i think there's a lot of room for

00:23:04,400 --> 00:23:08,400
improvement here with crater

00:23:06,880 --> 00:23:11,200
and then i'd like to look at the

00:23:08,400 --> 00:23:14,559
operator sdk's capabilities roadmap

00:23:11,200 --> 00:23:16,480
for ways that i can offer very

00:23:14,559 --> 00:23:18,720
simple apis to implement some of the

00:23:16,480 --> 00:23:20,640
more advanced features such as

00:23:18,720 --> 00:23:22,000
auto scaling and abnormal state

00:23:20,640 --> 00:23:23,840
detection so

00:23:22,000 --> 00:23:25,280
thank you for coming to my talk i hope

00:23:23,840 --> 00:23:27,039
this has been very interesting and i

00:23:25,280 --> 00:23:28,799
hope you'll check out crater

00:23:27,039 --> 00:23:31,039
if you'd like to get in contact with me

00:23:28,799 --> 00:23:34,480
or the crustlet project you can find

00:23:31,039 --> 00:23:35,440
us on twitter github we both have

00:23:34,480 --> 00:23:36,880
websites

00:23:35,440 --> 00:23:39,360
and then finally for the crestlet

00:23:36,880 --> 00:23:41,279
project there's a hashtag crestlet slack

00:23:39,360 --> 00:23:44,400
channel in the kubernetes

00:23:41,279 --> 00:23:45,679
slack so that's probably the easiest way

00:23:44,400 --> 00:23:48,799
to reach out to us

00:23:45,679 --> 00:23:48,799

YouTube URL: https://www.youtube.com/watch?v=2YSdRpCnG-U


