Title: Building Cloud-native applications with Rust - the good, the bad and the ugly - Luca Palmieri
Publication date: 2021-05-03
Playlist: Cloud Native Rust Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Building Cloud-native applications with Rust - the good, the bad and the ugly - Luca Palmieri, TrueLayer

Rust has built a reputation as an excellent systems programming language. Yet more than a few companies have chosen to bet on Rust for a completely different type of software: Cloud-native applications. What does Rust have to offer compared to other established languages (e.g. Java, C#, Python, Golang) when it comes to APIs and message consumers? The talk will walk you through TrueLayer's experience. We will cover what convinced us that Rust was a viable option for our latest product (spoiler - not just performance!), the issues and annoyances we experienced along the way as well as what we believe to be some of its intrinsic limitations for the backend development usecase.
Captions: 
	00:00:00,080 --> 00:00:03,439
hello everybody super excited to be here

00:00:02,879 --> 00:00:06,879
with you

00:00:03,439 --> 00:00:08,320
at cloud native rust days for those of

00:00:06,879 --> 00:00:09,040
you who haven't had the pleasure to meet

00:00:08,320 --> 00:00:11,360
yet

00:00:09,040 --> 00:00:13,120
my name is luca palmieri and i work as a

00:00:11,360 --> 00:00:15,360
lead engineer for toulair

00:00:13,120 --> 00:00:16,480
a financial technology company based in

00:00:15,360 --> 00:00:17,760
london

00:00:16,480 --> 00:00:19,600
i've been contributing to the russ

00:00:17,760 --> 00:00:20,480
community for the past three and a half

00:00:19,600 --> 00:00:22,160
years

00:00:20,480 --> 00:00:24,240
you might have seen some of the work i

00:00:22,160 --> 00:00:25,039
did to get people interested into the

00:00:24,240 --> 00:00:27,760
language

00:00:25,039 --> 00:00:29,279
workshops code dodges with the last

00:00:27,760 --> 00:00:30,480
london user group

00:00:29,279 --> 00:00:32,640
or you might have used some of the

00:00:30,480 --> 00:00:35,760
packages i maintain cargo chef

00:00:32,640 --> 00:00:38,399
for faster docker builds or wiremock to

00:00:35,760 --> 00:00:40,559
test some of your rest api clients

00:00:38,399 --> 00:00:42,079
for the past 12 months or so i've mostly

00:00:40,559 --> 00:00:43,680
been focused on driving zero to

00:00:42,079 --> 00:00:46,719
production in rust

00:00:43,680 --> 00:00:48,960
zero the production rust is a book that

00:00:46,719 --> 00:00:49,760
guides a developer which is new to the

00:00:48,960 --> 00:00:52,559
ecosystem

00:00:49,760 --> 00:00:53,680
or new to the domain in understanding

00:00:52,559 --> 00:00:56,719
what is available

00:00:53,680 --> 00:00:58,079
and how to make use of it efficiently to

00:00:56,719 --> 00:01:00,719
actually build cloud native

00:00:58,079 --> 00:01:02,000
applications and some of the topics that

00:01:00,719 --> 00:01:04,080
are touched in the book

00:01:02,000 --> 00:01:06,479
will also form some of the material for

00:01:04,080 --> 00:01:09,520
this talk

00:01:06,479 --> 00:01:10,880
coming to the matter at end what drives

00:01:09,520 --> 00:01:12,320
most of the conversation we're going to

00:01:10,880 --> 00:01:14,080
be having today

00:01:12,320 --> 00:01:16,799
is the work we've been doing at true

00:01:14,080 --> 00:01:19,119
layer for the past year

00:01:16,799 --> 00:01:20,080
to later build a new product line called

00:01:19,119 --> 00:01:22,080
pay direct

00:01:20,080 --> 00:01:23,439
the details of it don't matter

00:01:22,080 --> 00:01:25,759
necessarily too much

00:01:23,439 --> 00:01:27,600
you can think of pay direct as an api

00:01:25,759 --> 00:01:30,159
which allows a merchant

00:01:27,600 --> 00:01:31,280
to manage what looks like a bank account

00:01:30,159 --> 00:01:33,439
so their funds

00:01:31,280 --> 00:01:35,520
held by two layer they can receive

00:01:33,439 --> 00:01:37,680
payments from the rest in the ecosystem

00:01:35,520 --> 00:01:40,079
and they can initiate payments uh

00:01:37,680 --> 00:01:43,040
towards other accounts on the network

00:01:40,079 --> 00:01:43,840
all of it done by apis there's one

00:01:43,040 --> 00:01:46,799
question

00:01:43,840 --> 00:01:48,159
that keeps being asked over and over

00:01:46,799 --> 00:01:51,840
again

00:01:48,159 --> 00:01:53,920
why why have you chosen bust

00:01:51,840 --> 00:01:56,240
and one side of the question we might

00:01:53,920 --> 00:01:58,640
frame as a question of novelty

00:01:56,240 --> 00:01:59,360
rust no matter how ozone we believe it

00:01:58,640 --> 00:02:01,840
is

00:01:59,360 --> 00:02:02,719
it's still a young programming language

00:02:01,840 --> 00:02:05,759
1.0

00:02:02,719 --> 00:02:08,560
came out shortly five years ago

00:02:05,759 --> 00:02:09,520
more or less compared to the age of

00:02:08,560 --> 00:02:13,280
maturity

00:02:09,520 --> 00:02:16,959
of ecosystems like the jvm like

00:02:13,280 --> 00:02:19,840
the clr like python and typescript

00:02:16,959 --> 00:02:21,520
is still fairly young so that there's an

00:02:19,840 --> 00:02:23,200
inherent element of risk

00:02:21,520 --> 00:02:24,800
and we're gonna touch on some of those

00:02:23,200 --> 00:02:27,920
later on

00:02:24,800 --> 00:02:30,000
but the other part the other like intent

00:02:27,920 --> 00:02:31,040
behind the question is actually

00:02:30,000 --> 00:02:34,080
confusion

00:02:31,040 --> 00:02:36,160
between what people think trust is and

00:02:34,080 --> 00:02:39,200
what we're using russ for

00:02:36,160 --> 00:02:41,280
and that's because rust has

00:02:39,200 --> 00:02:42,319
made a lot of his early victories and a

00:02:41,280 --> 00:02:44,480
lot of his

00:02:42,319 --> 00:02:45,440
most striking successes in a different

00:02:44,480 --> 00:02:47,680
domain

00:02:45,440 --> 00:02:49,519
not in cloud native applications but in

00:02:47,680 --> 00:02:51,360
system programming

00:02:49,519 --> 00:02:54,239
and this is a little scrapbook that i

00:02:51,360 --> 00:02:57,519
put together in like five to ten minutes

00:02:54,239 --> 00:02:58,560
of just high profile projects that not

00:02:57,519 --> 00:03:00,560
so long ago

00:02:58,560 --> 00:03:01,760
i've been on the headlines for using

00:03:00,560 --> 00:03:03,200
rust

00:03:01,760 --> 00:03:04,800
all of these things are massive

00:03:03,200 --> 00:03:06,560
accomplishment especially

00:03:04,800 --> 00:03:08,560
if we go back to what we were discussing

00:03:06,560 --> 00:03:11,120
a few moments ago considering

00:03:08,560 --> 00:03:12,720
our younger languages but all of these

00:03:11,120 --> 00:03:15,519
massive accomplishments

00:03:12,720 --> 00:03:17,200
fall within the domain of system

00:03:15,519 --> 00:03:19,519
programming

00:03:17,200 --> 00:03:21,599
and as people like to remember me you

00:03:19,519 --> 00:03:24,159
are not doing system programming

00:03:21,599 --> 00:03:25,440
so a lot of the things that matter in

00:03:24,159 --> 00:03:28,799
system programming

00:03:25,440 --> 00:03:31,280
uh memory safety um squeezing out

00:03:28,799 --> 00:03:33,040
milliseconds by being very careful

00:03:31,280 --> 00:03:34,720
when you're locating memory adding

00:03:33,040 --> 00:03:36,400
binaries which are very small because

00:03:34,720 --> 00:03:37,599
you're deploying them on constrained

00:03:36,400 --> 00:03:39,599
devices

00:03:37,599 --> 00:03:42,400
don't necessarily matter in the

00:03:39,599 --> 00:03:46,480
cloud-native ecosystem

00:03:42,400 --> 00:03:49,519
we often are constrained not by how fast

00:03:46,480 --> 00:03:52,480
our programs are but on how fast

00:03:49,519 --> 00:03:54,080
we can develop them how many mistakes we

00:03:52,480 --> 00:03:56,640
make along the way

00:03:54,080 --> 00:03:57,920
how fast can we fix those and how fast

00:03:56,640 --> 00:04:01,360
most importantly

00:03:57,920 --> 00:04:04,879
can we evolve that software over time

00:04:01,360 --> 00:04:06,319
speed of iteration is almost always the

00:04:04,879 --> 00:04:08,480
biggest constraint

00:04:06,319 --> 00:04:11,519
in big cloud native deployments

00:04:08,480 --> 00:04:14,959
especially microservice architectures

00:04:11,519 --> 00:04:16,079
so why are we using a language which was

00:04:14,959 --> 00:04:18,079
engineered

00:04:16,079 --> 00:04:21,040
to solve problems which are not the

00:04:18,079 --> 00:04:22,960
problems of the cloud native ecosystem

00:04:21,040 --> 00:04:24,240
you don't have to draw a wall between

00:04:22,960 --> 00:04:25,919
different domains

00:04:24,240 --> 00:04:27,280
things which are good for system

00:04:25,919 --> 00:04:28,960
programmer can be

00:04:27,280 --> 00:04:31,360
equally interesting and equally

00:04:28,960 --> 00:04:32,240
beneficial to people working in back-end

00:04:31,360 --> 00:04:34,479
development

00:04:32,240 --> 00:04:36,479
the same applies to front-end and other

00:04:34,479 --> 00:04:38,720
domains like game development

00:04:36,479 --> 00:04:41,280
which are usually seen as very siloed

00:04:38,720 --> 00:04:44,000
and not communicating with one another

00:04:41,280 --> 00:04:44,880
actually by fraying outside of what is

00:04:44,000 --> 00:04:46,880
familiar

00:04:44,880 --> 00:04:48,000
we can find out that some of the

00:04:46,880 --> 00:04:50,000
problems they have

00:04:48,000 --> 00:04:52,400
are some of the problems we have if you

00:04:50,000 --> 00:04:55,199
look a little bit under the surface

00:04:52,400 --> 00:04:56,800
and the solutions can be reused and can

00:04:55,199 --> 00:04:59,040
be the foundation

00:04:56,800 --> 00:05:01,360
to build something much more interesting

00:04:59,040 --> 00:05:02,800
for what we want to solve

00:05:01,360 --> 00:05:05,120
and that's pretty much going to be the

00:05:02,800 --> 00:05:07,360
theme of this whole talk

00:05:05,120 --> 00:05:08,639
like you have seen the title we're going

00:05:07,360 --> 00:05:10,880
to talk about the good

00:05:08,639 --> 00:05:12,639
the bad and the ugly of using grass for

00:05:10,880 --> 00:05:15,039
the club native development

00:05:12,639 --> 00:05:16,880
and this is of course based on our own

00:05:15,039 --> 00:05:18,560
very specific experience

00:05:16,880 --> 00:05:20,240
and i'm sure that different people

00:05:18,560 --> 00:05:22,240
coming from different backgrounds

00:05:20,240 --> 00:05:23,520
trying to solve different problems might

00:05:22,240 --> 00:05:25,919
have a different take

00:05:23,520 --> 00:05:26,639
but i think it's important to start to

00:05:25,919 --> 00:05:28,880
break

00:05:26,639 --> 00:05:31,120
to an extent the strong association that

00:05:28,880 --> 00:05:33,120
rust has with system programming

00:05:31,120 --> 00:05:34,880
so let's start from well it's good once

00:05:33,120 --> 00:05:36,800
again people remember beginning at the

00:05:34,880 --> 00:05:39,360
end so put the bed in the middle

00:05:36,800 --> 00:05:41,520
well the best aspects of rust when it

00:05:39,360 --> 00:05:44,960
comes to cloud native development

00:05:41,520 --> 00:05:47,759
well the number one for me and like

00:05:44,960 --> 00:05:49,120
cued 80 percent or why i love to use the

00:05:47,759 --> 00:05:52,320
language today

00:05:49,120 --> 00:05:53,440
is that i'm able to compose smaller bits

00:05:52,320 --> 00:05:56,639
of functionality

00:05:53,440 --> 00:06:00,160
into larger program without adding

00:05:56,639 --> 00:06:01,520
surprises found at runtime so let's look

00:06:00,160 --> 00:06:03,280
at an example

00:06:01,520 --> 00:06:06,000
let's look at this function verify

00:06:03,280 --> 00:06:06,720
signature text.json web token as

00:06:06,000 --> 00:06:09,440
argument

00:06:06,720 --> 00:06:11,600
and it returns us the claims uh inside

00:06:09,440 --> 00:06:13,280
the json web token

00:06:11,600 --> 00:06:14,960
now if this was within a different

00:06:13,280 --> 00:06:16,560
programming language depending on what

00:06:14,960 --> 00:06:19,039
that language was

00:06:16,560 --> 00:06:20,319
this might look slightly different in a

00:06:19,039 --> 00:06:23,120
dynamic language

00:06:20,319 --> 00:06:23,520
uh you wouldn't have the types so you

00:06:23,120 --> 00:06:26,240
would

00:06:23,520 --> 00:06:26,880
infer that anything that behaves like a

00:06:26,240 --> 00:06:29,919
token

00:06:26,880 --> 00:06:32,000
in some not very well defined way is

00:06:29,919 --> 00:06:33,360
going to be a valid input

00:06:32,000 --> 00:06:35,680
and then you would have to write a bunch

00:06:33,360 --> 00:06:37,600
of tests to make sure that anything

00:06:35,680 --> 00:06:39,600
which is not a valid input

00:06:37,600 --> 00:06:41,680
fails in a predictable manner for

00:06:39,600 --> 00:06:43,919
example raising an exception

00:06:41,680 --> 00:06:45,680
and that is his own problems right is

00:06:43,919 --> 00:06:46,639
somebody's coming back to the code base

00:06:45,680 --> 00:06:47,759
tomorrow

00:06:46,639 --> 00:06:49,520
they don't know about all those

00:06:47,759 --> 00:06:50,080
assumptions because they're not in the

00:06:49,520 --> 00:06:52,319
run

00:06:50,080 --> 00:06:54,080
they have not loaded all the implicit

00:06:52,319 --> 00:06:56,800
knowledge required by the code base

00:06:54,080 --> 00:06:58,560
and they might make mistakes and if

00:06:56,800 --> 00:06:59,840
those are not tested for

00:06:58,560 --> 00:07:02,400
then those mistakes might arrive in

00:06:59,840 --> 00:07:03,680
production we don't like that

00:07:02,400 --> 00:07:05,599
if you move to something which is

00:07:03,680 --> 00:07:09,280
statically typed uh

00:07:05,599 --> 00:07:09,840
like c sharp or java then what you might

00:07:09,280 --> 00:07:12,240
have

00:07:09,840 --> 00:07:13,840
is something similar so a function which

00:07:12,240 --> 00:07:16,800
is marked as a synchronous

00:07:13,840 --> 00:07:19,120
so it does some input output it might be

00:07:16,800 --> 00:07:21,039
over the network it might be over disk

00:07:19,120 --> 00:07:22,639
it takes as input a token and you would

00:07:21,039 --> 00:07:24,960
definitely have a gwt type

00:07:22,639 --> 00:07:26,319
which has some constraints encoded

00:07:24,960 --> 00:07:29,520
inside the type

00:07:26,319 --> 00:07:30,400
and it would return some claims but that

00:07:29,520 --> 00:07:33,520
function

00:07:30,400 --> 00:07:34,000
might mutate the gwt token and passing

00:07:33,520 --> 00:07:37,280
to it

00:07:34,000 --> 00:07:39,039
as an input and also it might fail but

00:07:37,280 --> 00:07:41,440
the signature doesn't tell me that it

00:07:39,039 --> 00:07:42,479
might fail that's because they're using

00:07:41,440 --> 00:07:44,879
exceptions

00:07:42,479 --> 00:07:46,319
uh to signal that some things might not

00:07:44,879 --> 00:07:48,720
complete successfully

00:07:46,319 --> 00:07:50,879
but i don't see in the signature what

00:07:48,720 --> 00:07:53,680
exception that function can raise

00:07:50,879 --> 00:07:54,879
which means that i either need to go and

00:07:53,680 --> 00:07:58,000
look at the source code

00:07:54,879 --> 00:07:59,599
and inspect every line to understand if

00:07:58,000 --> 00:08:01,599
it might throw an exception

00:07:59,599 --> 00:08:02,720
or i need to be very defensive so need

00:08:01,599 --> 00:08:04,479
to add

00:08:02,720 --> 00:08:07,120
try catch statements which are very

00:08:04,479 --> 00:08:09,840
broad to make sure that they actually

00:08:07,120 --> 00:08:11,599
fulfill all the different corner cases

00:08:09,840 --> 00:08:13,840
now let's go back to rust

00:08:11,599 --> 00:08:15,840
once again i have a scene keyword on the

00:08:13,840 --> 00:08:16,800
left that tells me this function might

00:08:15,840 --> 00:08:20,240
do io

00:08:16,800 --> 00:08:21,759
that's great the token not only the gwt

00:08:20,240 --> 00:08:24,080
which tells me something about the

00:08:21,759 --> 00:08:26,479
structure of the input i also know

00:08:24,080 --> 00:08:28,240
that i'm passing in a reference to

00:08:26,479 --> 00:08:29,199
touchywt and that's an immutable

00:08:28,240 --> 00:08:31,199
reference

00:08:29,199 --> 00:08:32,560
that means that i know that my verify

00:08:31,199 --> 00:08:36,479
signature function

00:08:32,560 --> 00:08:38,719
relaxes the gwt but it won't mutate it

00:08:36,479 --> 00:08:40,080
and that already simplifies massively

00:08:38,719 --> 00:08:41,279
debugging for example

00:08:40,080 --> 00:08:43,760
if you're trying to understand where

00:08:41,279 --> 00:08:46,240
things go wrong knowing that

00:08:43,760 --> 00:08:47,920
your data is not changing unless it's

00:08:46,240 --> 00:08:50,320
very explicitly demarked

00:08:47,920 --> 00:08:52,000
as being mutable makes it much much

00:08:50,320 --> 00:08:54,640
faster you can rule out

00:08:52,000 --> 00:08:56,560
massive parts of the call tree without

00:08:54,640 --> 00:09:00,000
even looking at those

00:08:56,560 --> 00:09:02,160
and equally important at the end i know

00:09:00,000 --> 00:09:04,560
immediately that this function can fail

00:09:02,160 --> 00:09:06,480
because this function returns a result

00:09:04,560 --> 00:09:09,760
now result is a way to encode

00:09:06,480 --> 00:09:10,320
inside the type system that if things go

00:09:09,760 --> 00:09:13,360
well

00:09:10,320 --> 00:09:15,440
i'll get a claims but if things go wrong

00:09:13,360 --> 00:09:16,640
i'll get an error that error the

00:09:15,440 --> 00:09:19,040
verification error

00:09:16,640 --> 00:09:21,120
i can go and look at the definition and

00:09:19,040 --> 00:09:23,839
i can see all the different cases

00:09:21,120 --> 00:09:25,519
most likely is going to be an enum and i

00:09:23,839 --> 00:09:28,720
can decide what to do

00:09:25,519 --> 00:09:31,279
in each of those cases this allows me

00:09:28,720 --> 00:09:31,920
to reason about what matters to my

00:09:31,279 --> 00:09:34,080
software

00:09:31,920 --> 00:09:36,000
when calling your software without

00:09:34,080 --> 00:09:37,839
actually having to go inside

00:09:36,000 --> 00:09:39,440
and do technical due diligence of your

00:09:37,839 --> 00:09:43,360
implementation

00:09:39,440 --> 00:09:46,080
and that's the basis for powerful reuse

00:09:43,360 --> 00:09:48,080
being able to actually isolate and

00:09:46,080 --> 00:09:50,480
encapsulate complexity

00:09:48,080 --> 00:09:52,720
by exposing just what matters to the

00:09:50,480 --> 00:09:54,720
person using the abstraction

00:09:52,720 --> 00:09:56,959
empowers us to build towers which are

00:09:54,720 --> 00:09:59,440
much higher and much more robust

00:09:56,959 --> 00:10:00,720
than what we can do if we stack things

00:09:59,440 --> 00:10:04,399
on top of each other

00:10:00,720 --> 00:10:06,320
without controlling all these effects

00:10:04,399 --> 00:10:07,920
let's get to the second pattern which is

00:10:06,320 --> 00:10:09,839
actually very important but writing

00:10:07,920 --> 00:10:12,320
cloud native dress code

00:10:09,839 --> 00:10:13,839
being able to write state machines sid

00:10:12,320 --> 00:10:16,160
machines are everywhere

00:10:13,839 --> 00:10:19,200
in your programs you have resources that

00:10:16,160 --> 00:10:22,480
most likely have a life cycle of sort

00:10:19,200 --> 00:10:23,760
a user a user might sign up they might

00:10:22,480 --> 00:10:25,360
confirm their email

00:10:23,760 --> 00:10:27,680
and then they might suspend their

00:10:25,360 --> 00:10:30,000
account or close their account

00:10:27,680 --> 00:10:31,680
a payment gets authorized then it gets

00:10:30,000 --> 00:10:34,000
booked then it gets submitted then it

00:10:31,680 --> 00:10:36,000
gets settled or it fails

00:10:34,000 --> 00:10:37,200
they have a finite number of states

00:10:36,000 --> 00:10:39,279
which are valid

00:10:37,200 --> 00:10:40,320
and they are very clear business rules

00:10:39,279 --> 00:10:43,360
on how to go from

00:10:40,320 --> 00:10:44,880
state a to state b and it's also clear

00:10:43,360 --> 00:10:47,680
that you can go from state a

00:10:44,880 --> 00:10:48,640
to state c this is extremely difficult

00:10:47,680 --> 00:10:50,800
to encode

00:10:48,640 --> 00:10:52,480
if you're using class hierarchies like

00:10:50,800 --> 00:10:54,079
you can have an infinite number of

00:10:52,480 --> 00:10:56,640
subclasses

00:10:54,079 --> 00:10:57,440
instead if you're using rust you can

00:10:56,640 --> 00:11:00,240
encode

00:10:57,440 --> 00:11:01,600
these finite state machines using

00:11:00,240 --> 00:11:04,000
algebraic types

00:11:01,600 --> 00:11:05,040
so using genomes in and switch are able

00:11:04,000 --> 00:11:06,880
to have values

00:11:05,040 --> 00:11:09,040
so each of the variants can contain a

00:11:06,880 --> 00:11:11,440
payload is not just

00:11:09,040 --> 00:11:12,320
a fancy way of having an integer zero

00:11:11,440 --> 00:11:14,800
one two

00:11:12,320 --> 00:11:15,680
zero bending one active to suspended

00:11:14,800 --> 00:11:18,079
each of those

00:11:15,680 --> 00:11:20,720
is actually struct which has fields can

00:11:18,079 --> 00:11:23,839
be constructed and used

00:11:20,720 --> 00:11:25,040
and they're finite so you know if you

00:11:23,839 --> 00:11:27,839
actually used

00:11:25,040 --> 00:11:29,920
and verified all the possible parts

00:11:27,839 --> 00:11:32,480
every time you're using a user

00:11:29,920 --> 00:11:33,360
let's make an example and this is

00:11:32,480 --> 00:11:35,600
classic

00:11:33,360 --> 00:11:36,399
when you start modeling a domain you

00:11:35,600 --> 00:11:38,880
don't know

00:11:36,399 --> 00:11:40,480
exactly all the different corner cases

00:11:38,880 --> 00:11:41,279
so if you're starting to write your

00:11:40,480 --> 00:11:43,839
platform

00:11:41,279 --> 00:11:44,720
you might say well a user is either

00:11:43,839 --> 00:11:47,360
pending

00:11:44,720 --> 00:11:49,360
or active and that's because the world

00:11:47,360 --> 00:11:51,120
is simple right you don't have users yet

00:11:49,360 --> 00:11:53,279
like your biggest focus at that point in

00:11:51,120 --> 00:11:55,920
time is getting more users

00:11:53,279 --> 00:11:57,920
so you focus on the user creation part

00:11:55,920 --> 00:11:59,440
of the user life cycle

00:11:57,920 --> 00:12:01,120
so you go to production with pending an

00:11:59,440 --> 00:12:02,320
active and all the different parts of

00:12:01,120 --> 00:12:04,560
your code basis know

00:12:02,320 --> 00:12:05,920
what to do if a user is spending and if

00:12:04,560 --> 00:12:08,160
a user is active

00:12:05,920 --> 00:12:09,519
at a certain point in time you realize

00:12:08,160 --> 00:12:10,240
the user might want to freeze their

00:12:09,519 --> 00:12:12,240
accounts

00:12:10,240 --> 00:12:13,680
you have become successful now i have a

00:12:12,240 --> 00:12:15,519
sizable user base

00:12:13,680 --> 00:12:17,839
now this new part of the lifecycle

00:12:15,519 --> 00:12:19,680
enters your domain model

00:12:17,839 --> 00:12:21,519
and you need to make sure that

00:12:19,680 --> 00:12:22,800
everywhere in your code base when you're

00:12:21,519 --> 00:12:24,639
rendering a user

00:12:22,800 --> 00:12:26,880
you also are taking the appropriate

00:12:24,639 --> 00:12:28,399
action if the user is suspended

00:12:26,880 --> 00:12:30,560
for example they shouldn't be able to

00:12:28,399 --> 00:12:33,760
look in and rust

00:12:30,560 --> 00:12:36,240
helps you massively here because in ems

00:12:33,760 --> 00:12:37,200
being finite so they're not open-ended

00:12:36,240 --> 00:12:40,240
class hierarchy

00:12:37,200 --> 00:12:41,279
that a finite number of states allows

00:12:40,240 --> 00:12:44,240
the compiler

00:12:41,279 --> 00:12:46,000
to actually do exhaustive matching so

00:12:44,240 --> 00:12:48,320
every time you want to use a user

00:12:46,000 --> 00:12:49,519
you need to match on that user and you

00:12:48,320 --> 00:12:52,160
need to have a match

00:12:49,519 --> 00:12:54,480
arm for every possible variant the

00:12:52,160 --> 00:12:56,560
moment you introduce a new variant

00:12:54,480 --> 00:12:58,560
the compiler will scream at you with all

00:12:56,560 --> 00:13:00,320
the different places in the code base

00:12:58,560 --> 00:13:02,320
which require you to handle the new

00:13:00,320 --> 00:13:03,040
variant and then you know that until it

00:13:02,320 --> 00:13:05,360
compiles

00:13:03,040 --> 00:13:06,320
you actually can move forward and that

00:13:05,360 --> 00:13:09,519
is just amazing

00:13:06,320 --> 00:13:10,800
because you're using technology to scale

00:13:09,519 --> 00:13:12,720
up your mental model

00:13:10,800 --> 00:13:15,120
in a complex code base written by

00:13:12,720 --> 00:13:15,920
somebody else involved by somebody else

00:13:15,120 --> 00:13:18,639
afterwards

00:13:15,920 --> 00:13:19,279
which you landed on 15 days ago you

00:13:18,639 --> 00:13:21,120
don't know

00:13:19,279 --> 00:13:23,279
all the cool parts you don't know all

00:13:21,120 --> 00:13:25,200
the places where the user is used

00:13:23,279 --> 00:13:26,720
but technology is there to help you

00:13:25,200 --> 00:13:28,639
scale your understanding

00:13:26,720 --> 00:13:30,160
is there to help you fall into the beat

00:13:28,639 --> 00:13:32,079
of success

00:13:30,160 --> 00:13:33,440
third good part of grass for cloud

00:13:32,079 --> 00:13:36,079
native development

00:13:33,440 --> 00:13:37,680
predictable performance and i want to

00:13:36,079 --> 00:13:40,079
stress the word predictable

00:13:37,680 --> 00:13:41,440
so i'm not here to talk about the fact

00:13:40,079 --> 00:13:42,800
that rust is fast

00:13:41,440 --> 00:13:45,279
for most of the application doesn't

00:13:42,800 --> 00:13:47,040
matter as we said before

00:13:45,279 --> 00:13:48,639
the biggest constraint when doing

00:13:47,040 --> 00:13:51,360
enterprise software

00:13:48,639 --> 00:13:51,920
is how fast can you iterate and in most

00:13:51,360 --> 00:13:53,920
cases

00:13:51,920 --> 00:13:55,920
if your application takes 70

00:13:53,920 --> 00:13:58,800
milliseconds instead of 100

00:13:55,920 --> 00:14:00,720
instead of 150 doesn't actually make a

00:13:58,800 --> 00:14:02,720
massive difference to the user

00:14:00,720 --> 00:14:04,160
in certain places it does like there are

00:14:02,720 --> 00:14:05,680
bottlenecks in the system where you want

00:14:04,160 --> 00:14:07,920
to be as fast as possible

00:14:05,680 --> 00:14:09,360
but there are also plenty of parts where

00:14:07,920 --> 00:14:11,519
speed doesn't matter

00:14:09,360 --> 00:14:13,279
what matters though is being able to

00:14:11,519 --> 00:14:15,040
reason about the system as a whole

00:14:13,279 --> 00:14:16,800
and being able to reason about the way

00:14:15,040 --> 00:14:18,480
it's going to behave in a consistent

00:14:16,800 --> 00:14:21,120
fashion

00:14:18,480 --> 00:14:22,399
so what matters is when looking at your

00:14:21,120 --> 00:14:24,959
latency lines

00:14:22,399 --> 00:14:25,440
is seeing something flat so i want to

00:14:24,959 --> 00:14:27,360
know

00:14:25,440 --> 00:14:29,360
that fetching the settings for the

00:14:27,360 --> 00:14:32,399
client is going to take on average

00:14:29,360 --> 00:14:33,760
50 milliseconds and it's much easier

00:14:32,399 --> 00:14:35,600
to reason about the behavior of the

00:14:33,760 --> 00:14:36,880
system if it always takes 50

00:14:35,600 --> 00:14:39,279
milliseconds

00:14:36,880 --> 00:14:40,480
if from time to time it takes 50 but

00:14:39,279 --> 00:14:43,040
sometimes it takes

00:14:40,480 --> 00:14:44,240
300 then the situation is much more

00:14:43,040 --> 00:14:46,399
complicated

00:14:44,240 --> 00:14:48,079
and that happens a lot if you're using

00:14:46,399 --> 00:14:49,600
garbage collective languages

00:14:48,079 --> 00:14:51,199
but it's much easier to reason about

00:14:49,600 --> 00:14:53,519
your system if everything you need to

00:14:51,199 --> 00:14:56,000
look at is the code you have written

00:14:53,519 --> 00:14:57,360
and rust being able to free memory in a

00:14:56,000 --> 00:14:58,959
deterministic fashion

00:14:57,360 --> 00:15:01,120
thanks to the border checker and

00:14:58,959 --> 00:15:02,800
lifetime tracking actually give you that

00:15:01,120 --> 00:15:06,480
super flat line

00:15:02,800 --> 00:15:08,240
now not everything is roses and rainbows

00:15:06,480 --> 00:15:10,480
certain things are not working at the

00:15:08,240 --> 00:15:12,959
moment when it comes to using rust

00:15:10,480 --> 00:15:14,800
for cloud native ecosystem and actually

00:15:12,959 --> 00:15:16,480
my list is not particularly long

00:15:14,800 --> 00:15:20,240
there's one items but i think it's

00:15:16,480 --> 00:15:24,320
massive compilation times

00:15:20,240 --> 00:15:27,360
past compile times are long

00:15:24,320 --> 00:15:30,880
we have applications a true layer which

00:15:27,360 --> 00:15:34,399
are reasonably complex and take

00:15:30,880 --> 00:15:37,040
up to 15 16 minutes to compile

00:15:34,399 --> 00:15:40,160
in release mode so when we're building

00:15:37,040 --> 00:15:43,040
docker images to release in production

00:15:40,160 --> 00:15:43,920
on our local machines incremental

00:15:43,040 --> 00:15:48,079
compilation

00:15:43,920 --> 00:15:50,560
caching the experience is fairly smooth

00:15:48,079 --> 00:15:51,759
but we are experiencing a lengthening of

00:15:50,560 --> 00:15:53,759
the feedback loop

00:15:51,759 --> 00:15:55,120
which is actually very very important in

00:15:53,759 --> 00:15:59,040
a company which is

00:15:55,120 --> 00:16:02,240
write code commit merge to master deploy

00:15:59,040 --> 00:16:05,360
observe the merge buster

00:16:02,240 --> 00:16:08,480
deploy step is too long

00:16:05,360 --> 00:16:10,800
i can't wait 15 minutes to go from

00:16:08,480 --> 00:16:12,160
code is in my trunk to code is running

00:16:10,800 --> 00:16:14,399
in production

00:16:12,160 --> 00:16:15,600
continuous deployment is the temp of

00:16:14,399 --> 00:16:17,040
your organization

00:16:15,600 --> 00:16:19,519
if you have an organization that can

00:16:17,040 --> 00:16:20,880
only deploy once every 15 minutes

00:16:19,519 --> 00:16:22,639
that means that you can make four

00:16:20,880 --> 00:16:25,519
experiments per hour

00:16:22,639 --> 00:16:27,440
and you can make with like awesome usage

00:16:25,519 --> 00:16:29,920
of your time which doesn't happen

00:16:27,440 --> 00:16:31,600
uh 32 experiments per day in reality

00:16:29,920 --> 00:16:34,320
probably there's something like 20

00:16:31,600 --> 00:16:36,560
because i put something in ci then i do

00:16:34,320 --> 00:16:38,399
something else i forget waste a bunch of

00:16:36,560 --> 00:16:39,600
minutes then i go back and so on and so

00:16:38,399 --> 00:16:42,720
forth

00:16:39,600 --> 00:16:44,240
if i can deploy every two minutes i can

00:16:42,720 --> 00:16:45,839
make the same number of experiments

00:16:44,240 --> 00:16:47,759
within a single hour

00:16:45,839 --> 00:16:49,600
and within a day i can iterate on so

00:16:47,759 --> 00:16:51,360
many different configurations that

00:16:49,600 --> 00:16:52,240
actually i can convert to what i need

00:16:51,360 --> 00:16:55,120
much faster

00:16:52,240 --> 00:16:56,800
this is probably the most threatening

00:16:55,120 --> 00:16:57,360
aspect of the rust programming language

00:16:56,800 --> 00:16:59,120
today

00:16:57,360 --> 00:17:02,079
when it comes to adoption within the

00:16:59,120 --> 00:17:04,400
cloud native ecosystem

00:17:02,079 --> 00:17:05,439
now that's not to say that all the rest

00:17:04,400 --> 00:17:07,839
is amazing

00:17:05,439 --> 00:17:08,880
but the rest they classify as ugly ugly

00:17:07,839 --> 00:17:12,400
means that

00:17:08,880 --> 00:17:14,640
the situation as of today is not optimal

00:17:12,400 --> 00:17:16,160
but there is a clear part to get those

00:17:14,640 --> 00:17:17,760
things in blocked and to make them

00:17:16,160 --> 00:17:20,319
better

00:17:17,760 --> 00:17:21,520
first one is ecosystem maturity and we

00:17:20,319 --> 00:17:22,000
touched on this point at the very

00:17:21,520 --> 00:17:24,559
beginning

00:17:22,000 --> 00:17:26,720
rust is a young language and rust in the

00:17:24,559 --> 00:17:28,880
cloud native ecosystem specifically

00:17:26,720 --> 00:17:29,840
is even younger because rust really

00:17:28,880 --> 00:17:31,679
became viable

00:17:29,840 --> 00:17:33,280
to do backhand development from the

00:17:31,679 --> 00:17:36,320
moment they got a sync await

00:17:33,280 --> 00:17:39,200
and it got a sync await in november 2019

00:17:36,320 --> 00:17:40,799
and let's factor in four or five months

00:17:39,200 --> 00:17:42,080
for the ecosystem kind of to shift to

00:17:40,799 --> 00:17:45,039
use the sync weight

00:17:42,080 --> 00:17:46,799
we're talking like uh mid-2020 and

00:17:45,039 --> 00:17:47,679
there's a lot of exploration that still

00:17:46,799 --> 00:17:49,440
needs to happen

00:17:47,679 --> 00:17:51,440
in the ecosystem to understand what

00:17:49,440 --> 00:17:52,160
ergonomic means what are the best

00:17:51,440 --> 00:17:54,559
practices

00:17:52,160 --> 00:17:55,440
of using that feature of the language

00:17:54,559 --> 00:17:57,440
therefore

00:17:55,440 --> 00:17:58,480
the ecosystem is moving like there's a

00:17:57,440 --> 00:18:01,039
bit of churn

00:17:58,480 --> 00:18:02,480
uh libraries are still evolving and that

00:18:01,039 --> 00:18:03,760
might create a little bit of additional

00:18:02,480 --> 00:18:06,480
work

00:18:03,760 --> 00:18:09,039
the other side of it is that a lot of

00:18:06,480 --> 00:18:11,679
libraries do not exist as of today

00:18:09,039 --> 00:18:12,880
i'm talking about libraries to interact

00:18:11,679 --> 00:18:14,880
with big vendors

00:18:12,880 --> 00:18:17,200
you want to use aws that is risotto

00:18:14,880 --> 00:18:19,120
great you want to use gcp

00:18:17,200 --> 00:18:20,720
uh well you might have to write a bunch

00:18:19,120 --> 00:18:21,679
of stuff on your own you want to use

00:18:20,720 --> 00:18:24,960
volt

00:18:21,679 --> 00:18:27,280
same story so you cannot consider as you

00:18:24,960 --> 00:18:28,160
might do for example in python or in

00:18:27,280 --> 00:18:30,480
node

00:18:28,160 --> 00:18:32,400
the open source ecosystem as a vendor

00:18:30,480 --> 00:18:34,720
you are shopping from

00:18:32,400 --> 00:18:36,320
once you use a package in rust which is

00:18:34,720 --> 00:18:38,240
open source you need to take into

00:18:36,320 --> 00:18:41,200
account that you might have to devote

00:18:38,240 --> 00:18:43,039
a percentage of your development time to

00:18:41,200 --> 00:18:43,840
actually go and contribute to that

00:18:43,039 --> 00:18:45,280
library

00:18:43,840 --> 00:18:47,520
it may be that the documentation is

00:18:45,280 --> 00:18:50,160
missing a bit it might be that there is

00:18:47,520 --> 00:18:53,039
uh an unusual code path that you are

00:18:50,160 --> 00:18:55,360
exercising which is not as well tested

00:18:53,039 --> 00:18:57,679
factor that in like go inside in the

00:18:55,360 --> 00:18:59,440
ecosystem with your eyes wide open

00:18:57,679 --> 00:19:01,520
it happened to us as well like over a

00:18:59,440 --> 00:19:02,720
year we contributed i think almost 10

00:19:01,520 --> 00:19:04,720
different patches

00:19:02,720 --> 00:19:06,320
to fairly well known projects so we're

00:19:04,720 --> 00:19:07,280
not talking projects with one or two

00:19:06,320 --> 00:19:09,919
stars

00:19:07,280 --> 00:19:12,720
so be ready for doing your part in

00:19:09,919 --> 00:19:15,200
pushing the ecosystem forward

00:19:12,720 --> 00:19:17,120
the second one and i know this is like

00:19:15,200 --> 00:19:19,840
once again top of the agenda

00:19:17,120 --> 00:19:20,240
for many different people rus does not

00:19:19,840 --> 00:19:22,480
ship

00:19:20,240 --> 00:19:24,000
on a sync executor inside the standard

00:19:22,480 --> 00:19:27,120
library rust shapes the

00:19:24,000 --> 00:19:28,960
future trait so shapes the interface on

00:19:27,120 --> 00:19:32,080
what doing an asynchronous task

00:19:28,960 --> 00:19:32,880
looks like but it pushes the actual

00:19:32,080 --> 00:19:34,880
logic to

00:19:32,880 --> 00:19:36,160
orchestrate those asynchronous tasks

00:19:34,880 --> 00:19:38,960
into libraries

00:19:36,160 --> 00:19:40,400
at the moment we have tokyo on one side

00:19:38,960 --> 00:19:42,160
the oldest executor

00:19:40,400 --> 00:19:44,240
then we have a institute now we're

00:19:42,160 --> 00:19:45,679
bastian and a bunch of others with

00:19:44,240 --> 00:19:47,919
specialized use cases

00:19:45,679 --> 00:19:50,000
and it's not easy to interoperate we

00:19:47,919 --> 00:19:53,120
don't want libraries to have to choose

00:19:50,000 --> 00:19:54,880
in which which side they're playing

00:19:53,120 --> 00:19:56,880
i want to be able to buy the library

00:19:54,880 --> 00:19:58,640
that works with most executors

00:19:56,880 --> 00:20:00,400
and that requires us standardizing on

00:19:58,640 --> 00:20:01,200
certain traits and requires us making

00:20:00,400 --> 00:20:03,679
sure that that

00:20:01,200 --> 00:20:05,919
experience works and i know this is one

00:20:03,679 --> 00:20:06,480
of the focus of the async vision effort

00:20:05,919 --> 00:20:08,480
that is

00:20:06,480 --> 00:20:10,000
getting started in the past couple of

00:20:08,480 --> 00:20:11,039
months and i'm sure we're gonna see

00:20:10,000 --> 00:20:13,760
improvements

00:20:11,039 --> 00:20:15,520
but as of today i think that i recommend

00:20:13,760 --> 00:20:17,679
to beginners which i don't like

00:20:15,520 --> 00:20:18,640
is pick an executor and stick to it

00:20:17,679 --> 00:20:20,080
because that's gonna make your

00:20:18,640 --> 00:20:22,080
experience simpler

00:20:20,080 --> 00:20:25,280
i would like to see a future where these

00:20:22,080 --> 00:20:25,280
advances not necessary

00:20:25,760 --> 00:20:29,760
third intermediate learning resources

00:20:28,320 --> 00:20:31,919
rust is amazing

00:20:29,760 --> 00:20:32,960
when it comes to getting beginners into

00:20:31,919 --> 00:20:35,280
the language

00:20:32,960 --> 00:20:36,720
you have the last book you have

00:20:35,280 --> 00:20:39,200
programming with trust

00:20:36,720 --> 00:20:41,039
you have trust in action you have

00:20:39,200 --> 00:20:43,360
awesome video series on youtube

00:20:41,039 --> 00:20:45,600
of different kinds and levels but when

00:20:43,360 --> 00:20:47,600
you want to do cloud native development

00:20:45,600 --> 00:20:48,640
there's a lot more that is not in those

00:20:47,600 --> 00:20:50,400
resources

00:20:48,640 --> 00:20:52,480
as seeing kuwait for example is often

00:20:50,400 --> 00:20:55,280
not contemplated

00:20:52,480 --> 00:20:57,120
what libraries to use now discussed how

00:20:55,280 --> 00:21:00,480
to stitch them together

00:20:57,120 --> 00:21:02,240
not really discussed part of this is why

00:21:00,480 --> 00:21:05,520
i brought zero to production bust

00:21:02,240 --> 00:21:06,640
is like i don't plan to have this as an

00:21:05,520 --> 00:21:09,600
official resource

00:21:06,640 --> 00:21:10,080
this is as the title says an opinionated

00:21:09,600 --> 00:21:12,320
way

00:21:10,080 --> 00:21:13,600
of getting something that works or

00:21:12,320 --> 00:21:15,600
putting a bunch of tools

00:21:13,600 --> 00:21:17,039
inside the box and getting you something

00:21:15,600 --> 00:21:19,600
that you can use we trust

00:21:17,039 --> 00:21:20,720
to make this kind of programs but i'd

00:21:19,600 --> 00:21:22,799
like to see more

00:21:20,720 --> 00:21:23,919
like i like to see more resources with

00:21:22,799 --> 00:21:26,400
different angles

00:21:23,919 --> 00:21:27,360
uh videos books that take a different

00:21:26,400 --> 00:21:28,880
approach

00:21:27,360 --> 00:21:30,559
people need to have the possibility to

00:21:28,880 --> 00:21:32,480
choose how to approach the ecosystem

00:21:30,559 --> 00:21:34,720
because everybody learns differently

00:21:32,480 --> 00:21:36,880
and there's a void a massive void here

00:21:34,720 --> 00:21:38,960
that needs to be filled in

00:21:36,880 --> 00:21:41,120
and that was the last item in the list

00:21:38,960 --> 00:21:43,039
of ugly things that they're seeing rust

00:21:41,120 --> 00:21:45,440
for cloud native today

00:21:43,039 --> 00:21:47,679
thanks a lot for tuning in i hope this

00:21:45,440 --> 00:21:49,200
was a useful presentation and

00:21:47,679 --> 00:21:51,840
shared an experience that you can learn

00:21:49,200 --> 00:21:55,200
from if you have any questions i'm happy

00:21:51,840 --> 00:21:55,200

YouTube URL: https://www.youtube.com/watch?v=p4zjgU4RSYM


