Title: Deep Dive: Runtime Security With Falco in Userspace - Loris Degioanni, Sysdig
Publication date: 2020-09-11
Playlist: Cloud Native + Open Source Virtual Summit China 2020
Description: 
	Don’t miss out! Join us at our upcoming events: EnvoyCon Virtual on October 15 and KubeCon + CloudNativeCon North America 2020 Virtual from November 17-20. Learn more at https://kubecon.io The conferences feature presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects. 

Deep Dive: Runtime Security With Falco in Userspace - Loris Degioanni, Sysdig 

In this talk Loris will discuss the tradeoffs for using different backend drivers to access systemcall information for cloud native security with Falco. We learn about eBPF, kernel modules, and ptrace(2). Loris will discuss other approaches considered and the performance impact with other solutions such as LD_PRELOAD. Loris shares deep knowledge and expertise in the matter and draws on years of contributing to wireshark, and creating sysdig and falco. 

https://sched.co/cpBB
Captions: 
	00:00:01,280 --> 00:00:07,279
good evening and welcome to

00:00:04,160 --> 00:00:11,200
uh the falco deep dive uh

00:00:07,279 --> 00:00:14,160
safe session uh for kubecon

00:00:11,200 --> 00:00:15,440
uh tonight we're going to talk about uh

00:00:14,160 --> 00:00:18,800
runtime security

00:00:15,440 --> 00:00:21,600
with falco in user space so uh

00:00:18,800 --> 00:00:22,480
how to use falco in those environments

00:00:21,600 --> 00:00:25,519
where

00:00:22,480 --> 00:00:27,920
no access is allowed to

00:00:25,519 --> 00:00:28,560
the kernel of the operating system which

00:00:27,920 --> 00:00:31,119
is where

00:00:28,560 --> 00:00:34,000
tools like falco typically get their

00:00:31,119 --> 00:00:34,000
information from

00:00:34,399 --> 00:00:39,840
the talk is going to cover

00:00:38,000 --> 00:00:42,399
a little bit of falco the high level to

00:00:39,840 --> 00:00:44,800
give a tiny bit of context

00:00:42,399 --> 00:00:46,000
then deep dive into the falco collection

00:00:44,800 --> 00:00:50,000
architecture

00:00:46,000 --> 00:00:53,199
uh give an overview of uh

00:00:50,000 --> 00:00:55,760
the options that we have to collect data

00:00:53,199 --> 00:00:59,680
for falcon user space when kernel

00:00:55,760 --> 00:01:03,440
access is not available talk about

00:00:59,680 --> 00:01:05,280
a tool called pd which puts these

00:01:03,440 --> 00:01:07,840
theories in practice and then leaves

00:01:05,280 --> 00:01:10,080
some space for for questions

00:01:07,840 --> 00:01:11,360
first of all me my name is loris de

00:01:10,080 --> 00:01:14,960
jouani

00:01:11,360 --> 00:01:16,000
i am the founder and cto of a company

00:01:14,960 --> 00:01:19,520
called csd

00:01:16,000 --> 00:01:20,560
which provides tools for security and

00:01:19,520 --> 00:01:22,880
visibility

00:01:20,560 --> 00:01:24,159
for cloud native environments based on

00:01:22,880 --> 00:01:27,600
kubernetes

00:01:24,159 --> 00:01:31,040
i am also one of the original creators

00:01:27,600 --> 00:01:32,960
of falco in 2016.

00:01:31,040 --> 00:01:34,079
i'm still an active contributor to the

00:01:32,960 --> 00:01:37,439
tool

00:01:34,079 --> 00:01:40,400
and before falco i spent a lot of time

00:01:37,439 --> 00:01:42,079
in open source and networking in

00:01:40,400 --> 00:01:44,320
particular i was uh

00:01:42,079 --> 00:01:46,399
one of the original contributors to to

00:01:44,320 --> 00:01:50,240
wildshark

00:01:46,399 --> 00:01:53,520
the open source packet network analyzer

00:01:50,240 --> 00:01:56,560
you find me on twitter at laurie station

00:01:53,520 --> 00:01:57,200
all right let's talk a little bit about

00:01:56,560 --> 00:02:00,560
uh

00:01:57,200 --> 00:02:05,600
about falco falco is

00:02:00,560 --> 00:02:08,800
a runtime security engine

00:02:05,600 --> 00:02:09,119
for containers and for kubernetes you

00:02:08,800 --> 00:02:13,120
use

00:02:09,119 --> 00:02:15,680
falco to create rules

00:02:13,120 --> 00:02:17,040
that will notify you when you're

00:02:15,680 --> 00:02:20,319
triggered

00:02:17,040 --> 00:02:22,640
about unwanted activity

00:02:20,319 --> 00:02:24,560
in your containerized environment uh for

00:02:22,640 --> 00:02:26,879
example when somebody is uh

00:02:24,560 --> 00:02:27,599
touching a sensitive file exfiltrating

00:02:26,879 --> 00:02:29,440
data

00:02:27,599 --> 00:02:30,879
establishing connections that are

00:02:29,440 --> 00:02:34,000
unwanted uh

00:02:30,879 --> 00:02:37,680
executing commands uh that are strange

00:02:34,000 --> 00:02:39,280
and stuff like that falco

00:02:37,680 --> 00:02:41,280
leverages the kernel of the operating

00:02:39,280 --> 00:02:44,400
system to collect information

00:02:41,280 --> 00:02:49,200
and in particular uh is based

00:02:44,400 --> 00:02:53,200
on some technologies for collecting data

00:02:49,200 --> 00:02:56,400
one of them is called ebpf and

00:02:53,200 --> 00:02:58,720
stands for enhanced berkeley filter

00:02:56,400 --> 00:02:59,680
and we'll talk a little bit about it

00:02:58,720 --> 00:03:01,440
later but

00:02:59,680 --> 00:03:03,360
allows falco to essentially collect

00:03:01,440 --> 00:03:04,400
system calls from the from the operating

00:03:03,360 --> 00:03:06,640
system

00:03:04,400 --> 00:03:07,680
very importantly falco is designed to be

00:03:06,640 --> 00:03:10,800
modular

00:03:07,680 --> 00:03:13,920
and consumable so falco is a component

00:03:10,800 --> 00:03:14,560
that we designed to be very tightly

00:03:13,920 --> 00:03:17,280
embedded

00:03:14,560 --> 00:03:19,120
in the cloud native ecosystem and in the

00:03:17,280 --> 00:03:22,159
cloud native stack of tools

00:03:19,120 --> 00:03:25,360
and is designed to interact

00:03:22,159 --> 00:03:27,200
and interface with these tools to be

00:03:25,360 --> 00:03:29,920
part essentially of

00:03:27,200 --> 00:03:29,920
the pipeline

00:03:30,560 --> 00:03:34,799
falco uses the kernel of the operating

00:03:33,599 --> 00:03:37,680
system in particular

00:03:34,799 --> 00:03:38,080
linux typically as the source of truth

00:03:37,680 --> 00:03:41,360
uh

00:03:38,080 --> 00:03:41,840
and takes this information and enriches

00:03:41,360 --> 00:03:43,840
it

00:03:41,840 --> 00:03:47,599
with metadata coming from the

00:03:43,840 --> 00:03:50,799
orchestrator from kubernetes for example

00:03:47,599 --> 00:03:53,120
service labels

00:03:50,799 --> 00:03:56,080
annotations all this kind of stuff is

00:03:53,120 --> 00:03:59,280
consumed by falco to make it possible to

00:03:56,080 --> 00:04:00,080
offer a view that is not only container

00:03:59,280 --> 00:04:03,280
centric

00:04:00,080 --> 00:04:04,640
but it's also service and user and

00:04:03,280 --> 00:04:07,760
application centric

00:04:04,640 --> 00:04:11,360
which is very important when

00:04:07,760 --> 00:04:13,599
doing runtime alerting

00:04:11,360 --> 00:04:14,959
and runtime protection of your

00:04:13,599 --> 00:04:17,440
infrastructures because

00:04:14,959 --> 00:04:20,079
you're typically much more interested in

00:04:17,440 --> 00:04:22,160
what service

00:04:20,079 --> 00:04:24,560
is showing an anomalous behavior rather

00:04:22,160 --> 00:04:27,280
than just getting a container id or

00:04:24,560 --> 00:04:31,759
something like that

00:04:27,280 --> 00:04:35,040
falco is a cncf project

00:04:31,759 --> 00:04:36,960
uh very important for us uh we started

00:04:35,040 --> 00:04:40,800
falco in 2016

00:04:36,960 --> 00:04:43,520
we got accepted by cncf

00:04:40,800 --> 00:04:45,280
as assembled sandbox project in at the

00:04:43,520 --> 00:04:47,840
end of 2018

00:04:45,280 --> 00:04:49,919
and uh around six months ago in december

00:04:47,840 --> 00:04:52,960
of 2018 we were promoted to

00:04:49,919 --> 00:04:56,320
incubation uh it's a big focus

00:04:52,960 --> 00:04:59,600
of us to make sure that falco

00:04:56,320 --> 00:05:02,720
is a a project that

00:04:59,600 --> 00:05:04,160
is a broad audience but in a way that is

00:05:02,720 --> 00:05:06,720
completely

00:05:04,160 --> 00:05:08,240
open it's community community oriented

00:05:06,720 --> 00:05:11,280
and it's by driven in

00:05:08,240 --> 00:05:15,440
is driven by the guidelines

00:05:11,280 --> 00:05:15,440
at the core of of cncf

00:05:16,320 --> 00:05:20,639
let's go a little bit into architecture

00:05:18,960 --> 00:05:22,639
at the high level

00:05:20,639 --> 00:05:25,280
the firework architecture is relatively

00:05:22,639 --> 00:05:28,320
simple there are inputs

00:05:25,280 --> 00:05:31,199
there are rules there's an engine

00:05:28,320 --> 00:05:31,919
and there are outputs so inputs of

00:05:31,199 --> 00:05:35,520
course

00:05:31,919 --> 00:05:37,440
can be uh as i was mentioning

00:05:35,520 --> 00:05:38,800
kernel events in the form of system

00:05:37,440 --> 00:05:42,560
calls

00:05:38,800 --> 00:05:45,600
but also container metadata

00:05:42,560 --> 00:05:49,280
kubernetes events

00:05:45,600 --> 00:05:52,320
kubernetes metadata information

00:05:49,280 --> 00:05:55,520
and so on rules

00:05:52,320 --> 00:05:57,919
um allow you to specify

00:05:55,520 --> 00:05:58,560
essentially conditions on these inputs

00:05:57,919 --> 00:06:01,840
and

00:05:58,560 --> 00:06:03,600
are evaluated uh at the edge uh

00:06:01,840 --> 00:06:05,600
by farco engines that are running on

00:06:03,600 --> 00:06:08,800
every machine

00:06:05,600 --> 00:06:10,479
and they provide outputs that can be

00:06:08,800 --> 00:06:12,160
you know can go to syslog can go to

00:06:10,479 --> 00:06:15,600
standard output can go

00:06:12,160 --> 00:06:17,280
to grpc or web books can go for example

00:06:15,600 --> 00:06:18,400
there's an integration for prometheus so

00:06:17,280 --> 00:06:20,720
there's a bunch of

00:06:18,400 --> 00:06:22,160
ways essentially to consume falco

00:06:20,720 --> 00:06:25,360
outputs most of the people

00:06:22,160 --> 00:06:26,160
tend to send the outputs uh coming from

00:06:25,360 --> 00:06:28,639
falco

00:06:26,160 --> 00:06:30,800
uh to through seeds log or through some

00:06:28,639 --> 00:06:32,479
other mechanism to a sim

00:06:30,800 --> 00:06:34,800
tool that then can collect all of this

00:06:32,479 --> 00:06:36,560
kind of of stuff in a centralized place

00:06:34,800 --> 00:06:38,240
and falco of course puts a lot of

00:06:36,560 --> 00:06:40,000
richness in these events

00:06:38,240 --> 00:06:41,520
uh and a lot of context and then from

00:06:40,000 --> 00:06:43,120
the same tool you can essentially create

00:06:41,520 --> 00:06:46,960
dashboards or investigate

00:06:43,120 --> 00:06:50,400
or alert or do whatever you want

00:06:46,960 --> 00:06:52,720
some rule examples uh

00:06:50,400 --> 00:06:54,000
as you can see falco is designed with

00:06:52,720 --> 00:06:58,479
the syntax

00:06:54,000 --> 00:07:02,960
that uh uh as a the goal of being

00:06:58,479 --> 00:07:04,160
as lean and as simple as possible so

00:07:02,960 --> 00:07:07,199
maybe compare

00:07:04,160 --> 00:07:10,319
compared to other security kubernetes uh

00:07:07,199 --> 00:07:13,680
tools like for example oppa

00:07:10,319 --> 00:07:17,199
um falco is a

00:07:13,680 --> 00:07:21,199
slight a less expressive

00:07:17,199 --> 00:07:23,039
syntax but also a very simple syntax

00:07:21,199 --> 00:07:25,520
that allows you to

00:07:23,039 --> 00:07:27,039
create uh sophisticated stuff with one

00:07:25,520 --> 00:07:30,319
liners that are

00:07:27,039 --> 00:07:32,880
pretty easy to grasp and

00:07:30,319 --> 00:07:33,680
pretty easy to to manage and create new

00:07:32,880 --> 00:07:35,360
ones

00:07:33,680 --> 00:07:36,800
for example a shell is running a

00:07:35,360 --> 00:07:38,560
container as you can see

00:07:36,800 --> 00:07:40,240
is a condition that says container id

00:07:38,560 --> 00:07:41,919
different than host so we are

00:07:40,240 --> 00:07:44,000
actually inside the container and

00:07:41,919 --> 00:07:47,199
there's a process called bash

00:07:44,000 --> 00:07:48,639
overwrite system binaries uh

00:07:47,199 --> 00:07:51,680
we are you know we have a write

00:07:48,639 --> 00:07:55,039
operation in one of these directories

00:07:51,680 --> 00:07:57,120
uh container namespace change so this

00:07:55,039 --> 00:08:00,240
rule for example is trying to

00:07:57,120 --> 00:08:03,919
detect a container trying to escape

00:08:00,240 --> 00:08:06,240
uh its its name space is its gel and

00:08:03,919 --> 00:08:07,120
as you can see in this one we look at

00:08:06,240 --> 00:08:10,240
the certainness

00:08:07,120 --> 00:08:12,319
system call and and so on you know uh

00:08:10,240 --> 00:08:13,919
rules can be can become you know more

00:08:12,319 --> 00:08:17,520
and more sophisticated

00:08:13,919 --> 00:08:20,639
but at the basic they uh trying to be

00:08:17,520 --> 00:08:22,319
simple expressive and powerful at the

00:08:20,639 --> 00:08:25,440
same time

00:08:22,319 --> 00:08:26,000
um okay now that we've seen what kind of

00:08:25,440 --> 00:08:28,400
rules we can

00:08:26,000 --> 00:08:30,319
express and how it works let's look at

00:08:28,400 --> 00:08:31,280
how falco collects the data because the

00:08:30,319 --> 00:08:34,399
whole

00:08:31,280 --> 00:08:37,760
value and richness of a tool like falco

00:08:34,399 --> 00:08:42,880
and the ability to run at runtime uh

00:08:37,760 --> 00:08:44,640
and inform you of of granular changes

00:08:42,880 --> 00:08:46,959
and actions in your infrastructure

00:08:44,640 --> 00:08:47,920
depend on the ability to collect the

00:08:46,959 --> 00:08:50,399
best data

00:08:47,920 --> 00:08:51,680
in particular falco is uses the kernel

00:08:50,399 --> 00:08:54,080
of the operating system

00:08:51,680 --> 00:08:55,839
to collect system calls so here in this

00:08:54,080 --> 00:08:57,519
diagram we have a simplified diagram

00:08:55,839 --> 00:08:59,440
of a of a machine in this slide we have

00:08:57,519 --> 00:09:01,120
a simplified diagram of a machine

00:08:59,440 --> 00:09:02,800
with the kernel of the operating system

00:09:01,120 --> 00:09:04,399
and we have three containers

00:09:02,800 --> 00:09:06,880
running on the on this machine with

00:09:04,399 --> 00:09:09,920
three different container run times

00:09:06,880 --> 00:09:12,959
you deploy falco by running

00:09:09,920 --> 00:09:15,040
another container on the machine only

00:09:12,959 --> 00:09:16,560
one new container you typically do this

00:09:15,040 --> 00:09:18,640
through a demon set for example in

00:09:16,560 --> 00:09:21,600
kubernetes by telling kubernetes

00:09:18,640 --> 00:09:22,160
on a on each of my hosts i want a falco

00:09:21,600 --> 00:09:24,000
container

00:09:22,160 --> 00:09:25,920
only one if it goes down bring it back

00:09:24,000 --> 00:09:28,640
again you click enter

00:09:25,920 --> 00:09:29,920
uh cube cattle and essentially pushed

00:09:28,640 --> 00:09:32,399
falco

00:09:29,920 --> 00:09:33,680
everywhere when falco starts on the

00:09:32,399 --> 00:09:37,200
machine

00:09:33,680 --> 00:09:39,519
it detects the version of

00:09:37,200 --> 00:09:40,560
the operating system and it deploys

00:09:39,519 --> 00:09:42,959
instrumentation

00:09:40,560 --> 00:09:44,480
at the edge between the containers and

00:09:42,959 --> 00:09:49,360
the operating system

00:09:44,480 --> 00:09:51,760
itself this is important because falco

00:09:49,360 --> 00:09:53,760
is not based the the the traditional

00:09:51,760 --> 00:09:56,000
instrumentation for falco is not based

00:09:53,760 --> 00:09:57,440
on cycles it's not based on installing

00:09:56,000 --> 00:09:59,440
something inside the container

00:09:57,440 --> 00:10:00,800
but they can achieve this visibility by

00:09:59,440 --> 00:10:02,880
just running

00:10:00,800 --> 00:10:05,120
one separate container and by

00:10:02,880 --> 00:10:09,920
instrumenting the kernel

00:10:05,120 --> 00:10:14,240
and this is a very key in terms of uh

00:10:09,920 --> 00:10:17,200
easy easiness to deploy and scalability

00:10:14,240 --> 00:10:18,560
once this is deployed in the corner of

00:10:17,200 --> 00:10:21,600
the operating system

00:10:18,560 --> 00:10:24,000
uh typically under the form of

00:10:21,600 --> 00:10:25,440
any bpf module falco is able to collect

00:10:24,000 --> 00:10:27,519
every single system call

00:10:25,440 --> 00:10:29,760
so let's first talk a little bit about

00:10:27,519 --> 00:10:30,240
ebpf as i was saying before bpf stands

00:10:29,760 --> 00:10:33,200
for

00:10:30,240 --> 00:10:34,959
enhanced packet filter and it's

00:10:33,200 --> 00:10:36,800
essentially a virtual machine that runs

00:10:34,959 --> 00:10:39,839
in the kernel of the operating system

00:10:36,800 --> 00:10:41,760
and allows you to inject scripts

00:10:39,839 --> 00:10:42,959
in the operating system to do a bunch of

00:10:41,760 --> 00:10:46,959
different things

00:10:42,959 --> 00:10:50,160
falco uses it to collect uh system calls

00:10:46,959 --> 00:10:51,920
uh and uh ebpf makes it possible to do

00:10:50,160 --> 00:10:53,600
that in a way that is uh

00:10:51,920 --> 00:10:55,279
at the same time extreme efficient

00:10:53,600 --> 00:10:58,800
because this code is uh

00:10:55,279 --> 00:11:00,880
just in time compiled uh and uh

00:10:58,800 --> 00:11:02,480
heavily optimized but at the same time

00:11:00,880 --> 00:11:06,240
safe safe because

00:11:02,480 --> 00:11:09,519
ebpf is validated uh for

00:11:06,240 --> 00:11:10,399
uh stability reasons essentially bpf can

00:11:09,519 --> 00:11:12,240
only do

00:11:10,399 --> 00:11:14,399
a minimal set of things inside the

00:11:12,240 --> 00:11:15,760
kernel and what it does is validate it

00:11:14,399 --> 00:11:16,640
before the program is just in time

00:11:15,760 --> 00:11:18,560
compiled

00:11:16,640 --> 00:11:20,000
so that you don't crash you're

00:11:18,560 --> 00:11:21,600
guaranteed not to crash the kernel

00:11:20,000 --> 00:11:23,040
unless there are bugs in the kernel

00:11:21,600 --> 00:11:26,720
uh when you're when you're running an

00:11:23,040 --> 00:11:28,240
ebpf script and at the same time

00:11:26,720 --> 00:11:29,440
save from the security point of view

00:11:28,240 --> 00:11:30,240
because the scripts are sort of

00:11:29,440 --> 00:11:31,760
sandboxed

00:11:30,240 --> 00:11:33,680
inside the kernel so it's a beautiful

00:11:31,760 --> 00:11:35,600
way to essentially extend

00:11:33,680 --> 00:11:38,079
and include functionality in the kernel

00:11:35,600 --> 00:11:38,880
that uh allows a tool like falco to

00:11:38,079 --> 00:11:42,079
operate

00:11:38,880 --> 00:11:43,360
at that point the eppf scripts uh allow

00:11:42,079 --> 00:11:45,200
falco to

00:11:43,360 --> 00:11:48,320
capture system calls as i was saying

00:11:45,200 --> 00:11:51,839
system calls are

00:11:48,320 --> 00:11:54,240
anything you know reading or writing uh

00:11:51,839 --> 00:11:55,760
to disk opening files establishing

00:11:54,240 --> 00:11:57,120
network connections or receiving network

00:11:55,760 --> 00:11:59,920
connections and servers

00:11:57,120 --> 00:12:00,560
interface communication uh executing

00:11:59,920 --> 00:12:03,680
commands

00:12:00,560 --> 00:12:06,000
this is all system calls so on a really

00:12:03,680 --> 00:12:07,839
super granular way falco is able to

00:12:06,000 --> 00:12:10,959
collect all of this information

00:12:07,839 --> 00:12:13,360
and uh give you

00:12:10,959 --> 00:12:14,399
essentially notifications if something

00:12:13,360 --> 00:12:16,720
goes wrong

00:12:14,399 --> 00:12:18,880
kernel-based instrumentation is very

00:12:16,720 --> 00:12:20,480
powerful and the reason why we chose it

00:12:18,880 --> 00:12:22,079
is the original way to

00:12:20,480 --> 00:12:24,480
instrument falco is because it's

00:12:22,079 --> 00:12:26,720
accurate it's in the kernel so you

00:12:24,480 --> 00:12:28,079
you don't really bypass it and and it

00:12:26,720 --> 00:12:30,560
really collects everything

00:12:28,079 --> 00:12:31,600
it's extremely efficient so it slows

00:12:30,560 --> 00:12:33,519
down minimally

00:12:31,600 --> 00:12:34,639
the target containers and the target

00:12:33,519 --> 00:12:36,320
applications

00:12:34,639 --> 00:12:38,480
at the same time it's scalable because

00:12:36,320 --> 00:12:39,839
you only need to deploy one thing

00:12:38,480 --> 00:12:41,360
and then you can have one container

00:12:39,839 --> 00:12:43,120
running on the machine or a thousand

00:12:41,360 --> 00:12:45,120
containers running on the machine

00:12:43,120 --> 00:12:46,880
this orientation point is always one you

00:12:45,120 --> 00:12:48,320
know while when you have side cars

00:12:46,880 --> 00:12:50,560
essentially the overhead of the

00:12:48,320 --> 00:12:51,760
instrumentation tends to be linear with

00:12:50,560 --> 00:12:52,880
the number of containers that you're

00:12:51,760 --> 00:12:55,279
running

00:12:52,880 --> 00:12:56,480
the problem with the kernel-based

00:12:55,279 --> 00:12:58,639
instrumentation is

00:12:56,480 --> 00:13:00,639
there are some places where kernel

00:12:58,639 --> 00:13:02,880
instrumentation is not available anymore

00:13:00,639 --> 00:13:04,959
i mentioned in fargate for example so

00:13:02,880 --> 00:13:07,040
falcon needs access to the kernel

00:13:04,959 --> 00:13:10,000
the collection system that i described

00:13:07,040 --> 00:13:12,000
uh requires a kernel access

00:13:10,000 --> 00:13:13,600
but there are places like for example

00:13:12,000 --> 00:13:16,480
fargate in aws

00:13:13,600 --> 00:13:18,160
or microsoft hyper-v containers where

00:13:16,480 --> 00:13:19,920
this access is not available anymore

00:13:18,160 --> 00:13:21,760
because

00:13:19,920 --> 00:13:24,160
essentially the same machine could host

00:13:21,760 --> 00:13:27,839
multiple containers from multiple users

00:13:24,160 --> 00:13:29,839
so uh it's not safe to give

00:13:27,839 --> 00:13:31,040
some one of these users access to the

00:13:29,839 --> 00:13:32,560
kernel uh

00:13:31,040 --> 00:13:34,079
this could create issues for the other

00:13:32,560 --> 00:13:35,600
users that are that are in a

00:13:34,079 --> 00:13:36,800
multi-tenant environment sharing the

00:13:35,600 --> 00:13:40,000
same machine

00:13:36,800 --> 00:13:41,199
so how can we address this we need to

00:13:40,000 --> 00:13:43,279
find a solution

00:13:41,199 --> 00:13:44,320
that uh collects the data with the same

00:13:43,279 --> 00:13:47,680
granularity

00:13:44,320 --> 00:13:49,040
but it does not access the corner of the

00:13:47,680 --> 00:13:50,480
operating system

00:13:49,040 --> 00:13:52,160
there are a couple of ways one that

00:13:50,480 --> 00:13:53,440
typically comes to mind when

00:13:52,160 --> 00:13:56,480
doing this kind of stuff is the

00:13:53,440 --> 00:13:59,760
so-called ld preload ld preload means

00:13:56,480 --> 00:14:01,360
uh being able to tell the

00:13:59,760 --> 00:14:03,600
operating system through an environment

00:14:01,360 --> 00:14:04,720
variable to get system libraries from a

00:14:03,600 --> 00:14:06,480
different place

00:14:04,720 --> 00:14:08,639
so instead of getting them from inside

00:14:06,480 --> 00:14:09,519
the container it's possible essentially

00:14:08,639 --> 00:14:13,120
to map

00:14:09,519 --> 00:14:15,440
an external volume and then replace

00:14:13,120 --> 00:14:16,800
some system libraries for example the c

00:14:15,440 --> 00:14:20,000
the c library

00:14:16,800 --> 00:14:22,480
of of the container c libraries uh the c

00:14:20,000 --> 00:14:24,079
library is uh the gate between uh

00:14:22,480 --> 00:14:25,760
any application and the corner of the

00:14:24,079 --> 00:14:27,920
operating system so

00:14:25,760 --> 00:14:29,360
when you issue a system called typically

00:14:27,920 --> 00:14:32,320
you go to libc

00:14:29,360 --> 00:14:33,760
so if we replace lipsy in one of your

00:14:32,320 --> 00:14:35,839
containers then we're able to

00:14:33,760 --> 00:14:36,880
install some instrumentation that can

00:14:35,839 --> 00:14:39,760
send the data

00:14:36,880 --> 00:14:41,600
to falco the preload is the advantage of

00:14:39,760 --> 00:14:44,639
being

00:14:41,600 --> 00:14:47,839
efficient pretty easy to implement

00:14:44,639 --> 00:14:49,680
but as the huge disadvantage that it

00:14:47,839 --> 00:14:51,279
requires essentially replacement of

00:14:49,680 --> 00:14:52,560
dynamic libraries in an application

00:14:51,279 --> 00:14:55,519
which myself is

00:14:52,560 --> 00:14:56,480
a little bit dirty but even more

00:14:55,519 --> 00:14:59,760
importantly

00:14:56,480 --> 00:15:01,519
it's limited because it doesn't support

00:14:59,760 --> 00:15:02,880
the whole classes of applications that

00:15:01,519 --> 00:15:04,639
just don't use

00:15:02,880 --> 00:15:06,639
lip c and and they don't link dynamic

00:15:04,639 --> 00:15:09,279
libraries see

00:15:06,639 --> 00:15:10,720
statically linked programs have this

00:15:09,279 --> 00:15:13,760
feature they they don't

00:15:10,720 --> 00:15:15,920
they use dynamic libraries and go

00:15:13,760 --> 00:15:17,440
is another example go has been designed

00:15:15,920 --> 00:15:19,519
to generate

00:15:17,440 --> 00:15:21,519
at least on linux completely statically

00:15:19,519 --> 00:15:24,560
aesthetic binaries

00:15:21,519 --> 00:15:27,360
and doesn't really use lip c so

00:15:24,560 --> 00:15:28,079
ellipse an led preload approach would

00:15:27,360 --> 00:15:30,480
not support

00:15:28,079 --> 00:15:32,720
gopro programs which is a pretty massive

00:15:30,480 --> 00:15:35,759
limitation in cloud native

00:15:32,720 --> 00:15:38,880
uh so another approach is

00:15:35,759 --> 00:15:42,000
using ptrace ptrace is a functionality

00:15:38,880 --> 00:15:44,639
in the linux kernel that allows

00:15:42,000 --> 00:15:45,839
deploying essentially something inside

00:15:44,639 --> 00:15:47,920
the container that can

00:15:45,839 --> 00:15:48,959
essentially detect every single system

00:15:47,920 --> 00:15:52,240
call

00:15:48,959 --> 00:15:55,199
by going and getting access

00:15:52,240 --> 00:15:56,000
to the monitored application uh ptrace

00:15:55,199 --> 00:15:58,800
is what's you

00:15:56,000 --> 00:16:00,079
it's what's at the base of tools like a

00:15:58,800 --> 00:16:03,279
gdb

00:16:00,079 --> 00:16:04,240
or or s-trays so just by looking at what

00:16:03,279 --> 00:16:06,560
gdp can do

00:16:04,240 --> 00:16:07,600
you can get a hint of what p trace can

00:16:06,560 --> 00:16:09,199
do it can freeze

00:16:07,600 --> 00:16:11,360
a target process it can install

00:16:09,199 --> 00:16:12,399
breakpoints it can inspect the memory of

00:16:11,360 --> 00:16:15,040
the target process

00:16:12,399 --> 00:16:15,519
you can also see every single system

00:16:15,040 --> 00:16:18,000
call

00:16:15,519 --> 00:16:19,279
and the arguments of the system call so

00:16:18,000 --> 00:16:22,800
by

00:16:19,279 --> 00:16:24,399
leveraging uh ptrace uh it's possible to

00:16:22,800 --> 00:16:27,759
essentially create

00:16:24,399 --> 00:16:29,839
a a tool uh which i call pde

00:16:27,759 --> 00:16:32,720
call it pd gear that can collect the

00:16:29,839 --> 00:16:35,120
system calls and send them to funk

00:16:32,720 --> 00:16:36,880
benefits of phrase are it's accurate

00:16:35,120 --> 00:16:39,279
because you still go through the kernel

00:16:36,880 --> 00:16:40,560
so uh i used to say the kernel never

00:16:39,279 --> 00:16:42,800
lies because uh

00:16:40,560 --> 00:16:44,560
uh there's there's uh it's hard to

00:16:42,800 --> 00:16:47,600
bypass something that is collected

00:16:44,560 --> 00:16:49,600
at the kernel level uh at the same time

00:16:47,600 --> 00:16:50,720
it raises a couple of limitations one is

00:16:49,600 --> 00:16:52,880
performance

00:16:50,720 --> 00:16:53,759
and the other one is that historically

00:16:52,880 --> 00:16:56,480
disabled

00:16:53,759 --> 00:16:57,600
on some of these platforms for example

00:16:56,480 --> 00:17:00,800
you cannot use

00:16:57,600 --> 00:17:03,839
ptrace in in fargate this is

00:17:00,800 --> 00:17:04,480
something that is changed because very

00:17:03,839 --> 00:17:07,039
recently

00:17:04,480 --> 00:17:08,799
a few weeks ago amazon has announced the

00:17:07,039 --> 00:17:11,600
fargate engine 1.4

00:17:08,799 --> 00:17:13,039
and it's amazon has added this capsule

00:17:11,600 --> 00:17:15,760
trace by working with

00:17:13,039 --> 00:17:16,959
uh people like like the falco

00:17:15,760 --> 00:17:19,120
maintainers

00:17:16,959 --> 00:17:20,640
so that there could be a path

00:17:19,120 --> 00:17:22,480
essentially to have a system called

00:17:20,640 --> 00:17:25,760
collection at user level

00:17:22,480 --> 00:17:29,039
on a platform like for example fargate

00:17:25,760 --> 00:17:30,720
which is a pretty uh

00:17:29,039 --> 00:17:32,880
new and pretty mind-blowing if you think

00:17:30,720 --> 00:17:36,799
about that let's take a look

00:17:32,880 --> 00:17:40,000
so i'm switching to my aws console

00:17:36,799 --> 00:17:40,960
and as you can see here i have a couple

00:17:40,000 --> 00:17:44,400
of tasks

00:17:40,960 --> 00:17:44,960
and i'm i have one that is called falco

00:17:44,400 --> 00:17:47,760
trace

00:17:44,960 --> 00:17:49,280
ssh so let's go inside it and let's

00:17:47,760 --> 00:17:52,320
gather the public

00:17:49,280 --> 00:17:54,320
ip this is essentially a container that

00:17:52,320 --> 00:17:57,440
is running

00:17:54,320 --> 00:18:02,240
ubuntu and let me

00:17:57,440 --> 00:18:04,559
ssh into it

00:18:02,240 --> 00:18:04,559
it's

00:18:05,600 --> 00:18:08,559
in now

00:18:10,400 --> 00:18:12,799
wrong

00:18:13,600 --> 00:18:18,000
password and now we're inside the

00:18:15,679 --> 00:18:21,280
container

00:18:18,000 --> 00:18:23,760
this container has been instrumented

00:18:21,280 --> 00:18:24,799
with the technique that they just

00:18:23,760 --> 00:18:27,120
described

00:18:24,799 --> 00:18:29,120
so we have pdig running inside this

00:18:27,120 --> 00:18:30,160
container using ptrace to collect

00:18:29,120 --> 00:18:33,120
information

00:18:30,160 --> 00:18:34,160
so i can do some simulated malicious

00:18:33,120 --> 00:18:38,320
activity here

00:18:34,160 --> 00:18:43,039
like i can change a system binary

00:18:38,320 --> 00:18:46,400
slash being then

00:18:43,039 --> 00:18:49,919
slash cat and now

00:18:46,400 --> 00:18:52,559
i'm going into my console actually let

00:18:49,919 --> 00:18:52,559
me refresh

00:18:53,039 --> 00:18:56,559
and as you can see sure enough i've been

00:18:55,440 --> 00:18:59,120
notified

00:18:56,559 --> 00:19:01,280
that the system binary has been changed

00:18:59,120 --> 00:19:04,559
inside this container so we get

00:19:01,280 --> 00:19:05,600
essentially granular run time system

00:19:04,559 --> 00:19:08,960
call level

00:19:05,600 --> 00:19:12,720
visibility uh through falco

00:19:08,960 --> 00:19:16,080
uh on fargate thanks

00:19:12,720 --> 00:19:16,080
to ptrace-based

00:19:16,640 --> 00:19:21,360
instrumentation based on pd

00:19:22,240 --> 00:19:26,400
one more thing that i want to talk about

00:19:24,960 --> 00:19:28,960
is uh

00:19:26,400 --> 00:19:29,600
performance so as i was saying uh the

00:19:28,960 --> 00:19:32,960
issue

00:19:29,600 --> 00:19:36,880
with ptrace is that it tends to be

00:19:32,960 --> 00:19:38,320
relatively uh slow because every time

00:19:36,880 --> 00:19:39,760
there's a system called every time the

00:19:38,320 --> 00:19:41,120
application talks to the kernel of the

00:19:39,760 --> 00:19:44,240
operating system

00:19:41,120 --> 00:19:46,960
the system call needs to go up

00:19:44,240 --> 00:19:48,640
and go back to user space and go and be

00:19:46,960 --> 00:19:49,840
delivered essentially to a separate

00:19:48,640 --> 00:19:53,360
process running

00:19:49,840 --> 00:19:56,320
inside the the machine this process

00:19:53,360 --> 00:19:58,320
uh by the way needs to be essentially uh

00:19:56,320 --> 00:20:01,120
loaded in the container in my demo

00:19:58,320 --> 00:20:01,440
uh i loaded it it is as the entry point

00:20:01,120 --> 00:20:03,919
of

00:20:01,440 --> 00:20:05,520
of the container so that then everything

00:20:03,919 --> 00:20:07,039
inside the container would be captured

00:20:05,520 --> 00:20:09,039
essentially

00:20:07,039 --> 00:20:10,880
and by do and doing that creates a

00:20:09,039 --> 00:20:12,480
little bit of an overhead

00:20:10,880 --> 00:20:14,400
there are things that can be done to

00:20:12,480 --> 00:20:16,880
accelerate this because otherwise

00:20:14,400 --> 00:20:17,520
without optimizations p trades would

00:20:16,880 --> 00:20:21,200
just be

00:20:17,520 --> 00:20:23,360
as a technique too slow to

00:20:21,200 --> 00:20:24,480
work effectively in production on your

00:20:23,360 --> 00:20:26,159
containers so

00:20:24,480 --> 00:20:28,080
we do multiple things to make this

00:20:26,159 --> 00:20:33,039
faster one example

00:20:28,080 --> 00:20:34,880
is the use of a second bpf when

00:20:33,039 --> 00:20:36,720
ptrace has been enabled for example on

00:20:34,880 --> 00:20:40,240
fargate in the environment where i give

00:20:36,720 --> 00:20:42,720
the demo um another thing that was

00:20:40,240 --> 00:20:44,240
enabled by by amazon was a second vpf

00:20:42,720 --> 00:20:47,039
which allows essentially to

00:20:44,240 --> 00:20:48,240
inject little simple bpf scripts that

00:20:47,039 --> 00:20:50,159
can selectively

00:20:48,240 --> 00:20:51,600
capture only specific system calls for

00:20:50,159 --> 00:20:53,840
example falco

00:20:51,600 --> 00:20:55,440
needs to know when a file is open or

00:20:53,840 --> 00:20:57,120
when a connection is established

00:20:55,440 --> 00:20:58,960
but falco doesn't currently look at the

00:20:57,120 --> 00:21:01,919
payloads for performance reasons

00:20:58,960 --> 00:21:02,720
so through second we can selectively

00:21:01,919 --> 00:21:05,840
capture

00:21:02,720 --> 00:21:07,520
and do this path this trajectory only

00:21:05,840 --> 00:21:09,520
for some system calls and not

00:21:07,520 --> 00:21:10,720
other system calls and the results is

00:21:09,520 --> 00:21:13,120
that we can

00:21:10,720 --> 00:21:14,960
greatly essentially minimize the number

00:21:13,120 --> 00:21:17,360
of system calls that are captured

00:21:14,960 --> 00:21:18,559
by pdig and delivered to falco and by

00:21:17,360 --> 00:21:22,559
doing that

00:21:18,559 --> 00:21:25,280
we can be much more efficient

00:21:22,559 --> 00:21:27,200
in in the capture there are also other

00:21:25,280 --> 00:21:30,320
optimizations that we're doing

00:21:27,200 --> 00:21:33,600
but uh those go a little bit uh

00:21:30,320 --> 00:21:36,880
deeper and might be the subject

00:21:33,600 --> 00:21:40,480
of a future kubecon talk

00:21:36,880 --> 00:21:43,600
for the moment um i'm just

00:21:40,480 --> 00:21:44,559
giving you a few links if you want to

00:21:43,600 --> 00:21:46,480
play with this

00:21:44,559 --> 00:21:47,840
in particular everything about falco is

00:21:46,480 --> 00:21:50,400
on falco.org

00:21:47,840 --> 00:21:50,960
and anything that i showed on this demo

00:21:50,400 --> 00:21:53,600
is

00:21:50,960 --> 00:21:55,039
already available for the community

00:21:53,600 --> 00:21:58,159
under the falco

00:21:55,039 --> 00:22:00,720
organization and can be essentially

00:21:58,159 --> 00:22:01,600
uh downloaded from github uh this is

00:22:00,720 --> 00:22:04,000
where you

00:22:01,600 --> 00:22:06,320
download and and install falco from

00:22:04,000 --> 00:22:09,360
github and this is where you find pdig

00:22:06,320 --> 00:22:11,840
on github so um

00:22:09,360 --> 00:22:13,360
please you know go ahead have fun with

00:22:11,840 --> 00:22:16,640
this

00:22:13,360 --> 00:22:19,280
and of course reach out to the community

00:22:16,640 --> 00:22:20,080
if you need any help with this but let

00:22:19,280 --> 00:22:23,679
me

00:22:20,080 --> 00:22:26,799
maybe stop here and uh

00:22:23,679 --> 00:22:29,120
let me open this up

00:22:26,799 --> 00:22:31,679
for questions and thank you very much

00:22:29,120 --> 00:22:31,679
for the moment

00:22:35,520 --> 00:22:39,360
okay really saying really thanks for the

00:22:37,760 --> 00:22:41,919
great talk from loris

00:22:39,360 --> 00:22:42,880
and here is the q a session loris you

00:22:41,919 --> 00:22:46,159
can take a look at

00:22:42,880 --> 00:22:48,480
the q and a tab in zoom and

00:22:46,159 --> 00:22:51,520
answer any questions you want to ask you

00:22:48,480 --> 00:22:51,520
want to answer thank you

00:22:52,240 --> 00:22:58,720
i believe there are no questions

00:22:55,840 --> 00:23:00,240
for the moment right uh yes yes just

00:22:58,720 --> 00:23:03,360
wait a second yes

00:23:00,240 --> 00:23:06,480
oh here we go yes are there

00:23:03,360 --> 00:23:08,400
any good tools which work with falco

00:23:06,480 --> 00:23:11,280
for visualizations and easy

00:23:08,400 --> 00:23:11,280
configuration

00:23:11,919 --> 00:23:19,039
so the yes there are one of the

00:23:15,600 --> 00:23:21,919
goals of falco

00:23:19,039 --> 00:23:23,120
as a project of course is integrating as

00:23:21,919 --> 00:23:27,200
best as possible

00:23:23,120 --> 00:23:31,360
into um the rest of the of the ecosystem

00:23:27,200 --> 00:23:33,600
and of course into pipelines uh

00:23:31,360 --> 00:23:35,280
to collect these events transport them

00:23:33,600 --> 00:23:38,640
and so on so

00:23:35,280 --> 00:23:41,919
if you go either to the

00:23:38,640 --> 00:23:42,240
falco website or to the falco blog which

00:23:41,919 --> 00:23:45,279
you

00:23:42,240 --> 00:23:48,840
find from the website as well

00:23:45,279 --> 00:23:51,840
you will find um

00:23:48,840 --> 00:23:54,559
several uh reference

00:23:51,840 --> 00:23:55,840
architectures to for example uh

00:23:54,559 --> 00:23:59,840
integrate falco with

00:23:55,840 --> 00:24:03,520
elastic for for message collection or

00:23:59,840 --> 00:24:06,880
with the event

00:24:03,520 --> 00:24:10,320
pipelines on aws or lambda

00:24:06,880 --> 00:24:12,400
or or stuff like that so um yes

00:24:10,320 --> 00:24:14,640
uh there are many another one for

00:24:12,400 --> 00:24:17,440
example that the detect mention is

00:24:14,640 --> 00:24:19,440
prometheus we have exporters for falco

00:24:17,440 --> 00:24:21,600
that can convert far colors into

00:24:19,440 --> 00:24:24,080
prometheus so then you can you know

00:24:21,600 --> 00:24:24,960
sorry farco metrics uh they're going to

00:24:24,080 --> 00:24:28,000
prometheus

00:24:24,960 --> 00:24:29,440
and then uh you can use any graphene or

00:24:28,000 --> 00:24:32,559
any any other tool

00:24:29,440 --> 00:24:34,480
to visualize essentially the reports

00:24:32,559 --> 00:24:36,960
and the statistics about what you

00:24:34,480 --> 00:24:37,520
receive so again go to the website go to

00:24:36,960 --> 00:24:41,120
the blog

00:24:37,520 --> 00:24:41,120
and you will find a bunch of information

00:24:43,679 --> 00:24:48,000
what is your opinion on having a

00:24:46,240 --> 00:24:49,039
kubernetes distribution that is secure

00:24:48,000 --> 00:24:51,039
by default

00:24:49,039 --> 00:24:52,799
with opinionated configurations and

00:24:51,039 --> 00:24:55,840
tools integrated

00:24:52,799 --> 00:24:59,039
um you

00:24:55,840 --> 00:24:59,520
are really talking to somebody here that

00:24:59,039 --> 00:25:02,400
uh

00:24:59,520 --> 00:25:03,760
as the strong conviction uh it's the

00:25:02,400 --> 00:25:06,880
falco community

00:25:03,760 --> 00:25:10,799
uh does a bunch of work just with

00:25:06,880 --> 00:25:15,520
uh distributions um

00:25:10,799 --> 00:25:19,120
uh in order to have yes this kind of

00:25:15,520 --> 00:25:21,279
functionality embedded into

00:25:19,120 --> 00:25:22,960
just kubernetes when you when when you

00:25:21,279 --> 00:25:26,559
get it

00:25:22,960 --> 00:25:30,159
for sure kubernetes itself

00:25:26,559 --> 00:25:33,039
is making a lot of progress in terms

00:25:30,159 --> 00:25:33,039
in terms of just

00:25:33,279 --> 00:25:37,440
getting you know better included from

00:25:35,760 --> 00:25:42,000
the security point of view

00:25:37,440 --> 00:25:42,320
but there's definitely space i see you

00:25:42,000 --> 00:25:44,320
know

00:25:42,320 --> 00:25:45,520
especially the runtime security that

00:25:44,320 --> 00:25:48,480
falco does

00:25:45,520 --> 00:25:50,559
uh to be uh it would be a great benefit

00:25:48,480 --> 00:25:52,960
if it's just integrated by default

00:25:50,559 --> 00:25:53,760
into the destroy and then maybe uh also

00:25:52,960 --> 00:25:55,200
integrated

00:25:53,760 --> 00:25:56,720
into mechanisms like admission

00:25:55,200 --> 00:25:57,440
controllers and so on to create a

00:25:56,720 --> 00:26:00,240
positive

00:25:57,440 --> 00:26:01,520
feedback loop to protect and self-feel

00:26:00,240 --> 00:26:06,080
essentially your

00:26:01,520 --> 00:26:08,000
um your your infrastructure

00:26:06,080 --> 00:26:09,120
one thing that for example i can mention

00:26:08,000 --> 00:26:12,720
that we have announced

00:26:09,120 --> 00:26:16,080
recently is the integration uh with file

00:26:12,720 --> 00:26:20,480
between falco and openshift uh through

00:26:16,080 --> 00:26:22,799
the reddit acm 2.0 so

00:26:20,480 --> 00:26:24,000
red hat now is an operator that makes it

00:26:22,799 --> 00:26:25,840
possible to

00:26:24,000 --> 00:26:27,760
essentially win the thing with a single

00:26:25,840 --> 00:26:29,600
click to just have falco deployed in

00:26:27,760 --> 00:26:30,400
your cluster and configured essentially

00:26:29,600 --> 00:26:32,159
by the flow

00:26:30,400 --> 00:26:33,679
by default when you bring your your

00:26:32,159 --> 00:26:35,279
cluster up this is

00:26:33,679 --> 00:26:37,360
hopefully just the beginning and we're

00:26:35,279 --> 00:26:39,120
seeing you know definitely

00:26:37,360 --> 00:26:41,039
a lot of potential into just embedding

00:26:39,120 --> 00:26:42,480
falco by default and having a curated

00:26:41,039 --> 00:26:44,880
default set of rules that you have for

00:26:42,480 --> 00:26:47,120
runtime protection

00:26:44,880 --> 00:26:48,720
yeah i think uh velco right now is the

00:26:47,120 --> 00:26:52,159
incubation project right

00:26:48,720 --> 00:26:54,720
so when it goes to the graduated uh

00:26:52,159 --> 00:26:56,000
project in cncf it might be a can

00:26:54,720 --> 00:26:58,720
included in the

00:26:56,000 --> 00:26:59,520
kubernetes distribution right absolutely

00:26:58,720 --> 00:27:02,880
absolutely

00:26:59,520 --> 00:27:05,440
uh it's it's

00:27:02,880 --> 00:27:06,000
very much so and very much a goal of

00:27:05,440 --> 00:27:08,880
ours

00:27:06,000 --> 00:27:12,000
for sure to go into graduation uh one of

00:27:08,880 --> 00:27:14,480
the criteria that the toc looks is uh

00:27:12,000 --> 00:27:16,000
tight integration uh with the with the

00:27:14,480 --> 00:27:17,840
rest of the cncf ecosystem and

00:27:16,000 --> 00:27:20,320
kubernetes here is definitely the tool

00:27:17,840 --> 00:27:23,840
that falco wants to integrate with

00:27:20,320 --> 00:27:26,559
yeah okay uh

00:27:23,840 --> 00:27:27,600
thanks for the great talk from loris

00:27:26,559 --> 00:27:31,840
thank you

00:27:27,600 --> 00:27:35,840
and our next talk will start at

00:27:31,840 --> 00:27:36,640
9 30 so we will play the warm-up video

00:27:35,840 --> 00:27:39,919
right now

00:27:36,640 --> 00:27:40,640
welcome be patient and we'll come back

00:27:39,919 --> 00:27:44,080
later

00:27:40,640 --> 00:27:44,080

YouTube URL: https://www.youtube.com/watch?v=JmikZKslBtc


