Title: Keynote: WASI - A new kind of system interface & what it means for cloud native - Lin Clark, Fastly
Publication date: 2021-05-04
Playlist: Cloud Native Wasm Day EU 2021
Description: 
	Don’t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Keynote: WASI - A new kind of system interface and what it means for cloud native - Lin Clark, Senior Principal Engineer, Fastly

The system interfaces we use today were designed in the 70s and 80s to power the systems that were prevalent at that time. But increasingly what a "system" even is, is much more open-ended. They include distributed applications spanning the cloud and edge networks, tiny IoT devices scattered throughout our homes, or platforms that embed sandboxes to run untrusted code. 

With the WebAssembly System Interface, we’re building a new kind of system interface to better support these kinds of systems. And with this shift, new opportunities are opening up.

In this talk, I’ll explain what all of this means for Cloud Native and some of the opportunities that could be unlocked.
Captions: 
	00:00:00,760 --> 00:00:04,319
[Music]

00:00:03,919 --> 00:00:08,000
hi

00:00:04,319 --> 00:00:09,679
i'm lynne clark and i make code cartoons

00:00:08,000 --> 00:00:11,759
i also work at fastly which is doing a

00:00:09,679 --> 00:00:15,120
ton of cool things with webassembly

00:00:11,759 --> 00:00:16,400
to make better edge compute possible

00:00:15,120 --> 00:00:17,920
and i also am a co-founder of the

00:00:16,400 --> 00:00:19,760
bytecode alliance which is building a

00:00:17,920 --> 00:00:23,039
vision of a future webassembly ecosystem

00:00:19,760 --> 00:00:24,960
that extends beyond the browser

00:00:23,039 --> 00:00:26,640
before i start i want to say thank you

00:00:24,960 --> 00:00:28,320
to the organizers for inviting me to

00:00:26,640 --> 00:00:29,920
speak here today

00:00:28,320 --> 00:00:32,399
i was really excited when i was asked to

00:00:29,920 --> 00:00:34,000
give this talk in the webassembly world

00:00:32,399 --> 00:00:35,440
we've been looking at many of the same

00:00:34,000 --> 00:00:36,880
problems that all of you in the cloud

00:00:35,440 --> 00:00:37,920
native community have been looking at

00:00:36,880 --> 00:00:39,200
too

00:00:37,920 --> 00:00:41,520
for example one problem we've been

00:00:39,200 --> 00:00:42,000
thinking through is how do you deal with

00:00:41,520 --> 00:00:43,920
code

00:00:42,000 --> 00:00:45,920
that depends on the concept of a file

00:00:43,920 --> 00:00:48,160
system in places where you don't

00:00:45,920 --> 00:00:50,239
actually have a file system available

00:00:48,160 --> 00:00:51,840
or another problem how do you create a

00:00:50,239 --> 00:00:53,760
clear separation between the business

00:00:51,840 --> 00:00:55,199
logic of an app and the orchestration of

00:00:53,760 --> 00:00:56,719
that app

00:00:55,199 --> 00:00:58,079
so we have a lot of goals in common but

00:00:56,719 --> 00:00:58,960
our communities have been coming at

00:00:58,079 --> 00:01:00,719
these problems

00:00:58,960 --> 00:01:03,760
from different perspectives and bringing

00:01:00,719 --> 00:01:04,799
different contexts to the conversation

00:01:03,760 --> 00:01:06,320
so i think that there are lots of

00:01:04,799 --> 00:01:07,760
conversations that we can have between

00:01:06,320 --> 00:01:08,799
our communities combining these

00:01:07,760 --> 00:01:10,400
perspectives

00:01:08,799 --> 00:01:12,560
and seeing what opportunities they open

00:01:10,400 --> 00:01:15,040
up for each other

00:01:12,560 --> 00:01:17,439
before i dive in more deeply into how

00:01:15,040 --> 00:01:19,040
we've been thinking about these things

00:01:17,439 --> 00:01:21,759
i want to explain what made us start

00:01:19,040 --> 00:01:24,799
thinking about them in the first place

00:01:21,759 --> 00:01:26,400
so why was webassembly created

00:01:24,799 --> 00:01:28,159
the browsers wanted developers to be

00:01:26,400 --> 00:01:29,520
able to compile code bases that were

00:01:28,159 --> 00:01:32,079
written in languages like c

00:01:29,520 --> 00:01:34,079
plus and rust to a single file and then

00:01:32,079 --> 00:01:36,000
have that code run at near native speeds

00:01:34,079 --> 00:01:37,600
in the browser

00:01:36,000 --> 00:01:40,000
and they wanted it to run in a very

00:01:37,600 --> 00:01:41,280
secure way in a well isolated sandbox

00:01:40,000 --> 00:01:43,119
because you need that when you're

00:01:41,280 --> 00:01:46,000
running code that you just downloaded

00:01:43,119 --> 00:01:47,759
from the internet that you don't trust

00:01:46,000 --> 00:01:50,079
to get that near native speed the

00:01:47,759 --> 00:01:52,159
bytecode for this webassembly binary

00:01:50,079 --> 00:01:54,640
needed to be as close as possible to the

00:01:52,159 --> 00:01:57,840
native instruction set architecture or

00:01:54,640 --> 00:01:59,520
isas like x86 or arm64

00:01:57,840 --> 00:02:01,840
but without specializing to any

00:01:59,520 --> 00:02:03,680
particular isa

00:02:01,840 --> 00:02:07,840
so this meant creating a really low

00:02:03,680 --> 00:02:09,840
level abstraction over the various isas

00:02:07,840 --> 00:02:11,599
made it easy to run the same binary

00:02:09,840 --> 00:02:14,319
across a bunch of different machines

00:02:11,599 --> 00:02:16,080
with different machine architectures

00:02:14,319 --> 00:02:17,440
and this got developers really excited

00:02:16,080 --> 00:02:20,840
even those that were working

00:02:17,440 --> 00:02:22,319
outside completely outside of the

00:02:20,840 --> 00:02:24,160
browser

00:02:22,319 --> 00:02:26,319
but as these developers started bringing

00:02:24,160 --> 00:02:27,760
web assembly to the server and to other

00:02:26,319 --> 00:02:30,560
places they left some of the key

00:02:27,760 --> 00:02:32,640
properties of webassembly behind

00:02:30,560 --> 00:02:34,000
they were giving these web assemblies of

00:02:32,640 --> 00:02:36,160
webassembly binaries full

00:02:34,000 --> 00:02:37,760
access to the operating system system

00:02:36,160 --> 00:02:39,519
call library

00:02:37,760 --> 00:02:41,440
that compromised security and it also

00:02:39,519 --> 00:02:43,280
compromised the portability since now

00:02:41,440 --> 00:02:45,360
the binary was tied to a particular

00:02:43,280 --> 00:02:47,519
operating system

00:02:45,360 --> 00:02:50,879
so with this we realized we didn't just

00:02:47,519 --> 00:02:53,680
need an abstract isa we also needed an

00:02:50,879 --> 00:02:55,599
abstract operating system one that made

00:02:53,680 --> 00:02:57,040
it possible to run the same binary

00:02:55,599 --> 00:02:58,159
across a bunch of different operating

00:02:57,040 --> 00:02:59,040
systems while preserving the

00:02:58,159 --> 00:03:02,560
effectiveness

00:02:59,040 --> 00:03:03,680
of the webassembly sandbox so we started

00:03:02,560 --> 00:03:06,640
work on wazi

00:03:03,680 --> 00:03:08,640
the webassembly system interface the

00:03:06,640 --> 00:03:11,599
goal of wazzy is to create a very

00:03:08,640 --> 00:03:13,360
modular set of system interfaces

00:03:11,599 --> 00:03:15,120
these include all of the low-level kinds

00:03:13,360 --> 00:03:17,280
of interfaces that you'd expect from

00:03:15,120 --> 00:03:18,879
a system interface layer but it also

00:03:17,280 --> 00:03:20,560
includes some higher level ones like

00:03:18,879 --> 00:03:22,080
neural networks and crypto

00:03:20,560 --> 00:03:25,360
and we expect many more of these higher

00:03:22,080 --> 00:03:26,959
level apis to be added over time

00:03:25,360 --> 00:03:29,200
these interfaces need to follow

00:03:26,959 --> 00:03:30,959
capability-based security principles to

00:03:29,200 --> 00:03:32,400
ensure that we maintain the integrity of

00:03:30,959 --> 00:03:34,400
the sandbox

00:03:32,400 --> 00:03:36,319
and for the most part these interfaces

00:03:34,400 --> 00:03:39,120
also need to be portable across

00:03:36,319 --> 00:03:40,159
the major operating systems although we

00:03:39,120 --> 00:03:41,920
are okay with

00:03:40,159 --> 00:03:44,000
system specific interface modules for

00:03:41,920 --> 00:03:48,319
certainly narrowly scoped

00:03:44,000 --> 00:03:50,159
use cases it was when we started trying

00:03:48,319 --> 00:03:51,599
to make this portability work that we

00:03:50,159 --> 00:03:53,920
started getting to some of the problems

00:03:51,599 --> 00:03:55,360
that i mentioned before

00:03:53,920 --> 00:03:56,799
these step problems started coming to

00:03:55,360 --> 00:03:58,879
light when we were thinking about a

00:03:56,799 --> 00:04:02,400
pretty core concept in many operating

00:03:58,879 --> 00:04:04,560
systems the file system

00:04:02,400 --> 00:04:05,680
a lot of code today depends on the file

00:04:04,560 --> 00:04:07,519
system

00:04:05,680 --> 00:04:09,360
and the code uses the file system for

00:04:07,519 --> 00:04:11,519
many different tasks

00:04:09,360 --> 00:04:12,879
so it's where you persist data it's

00:04:11,519 --> 00:04:14,080
where you share data between two

00:04:12,879 --> 00:04:15,439
programs that are running in different

00:04:14,080 --> 00:04:16,720
processes

00:04:15,439 --> 00:04:18,720
it's where you put the code for

00:04:16,720 --> 00:04:19,280
executables it's where configuration

00:04:18,720 --> 00:04:22,720
lives

00:04:19,280 --> 00:04:24,560
as where assets get stored files are

00:04:22,720 --> 00:04:27,600
like these swiss army knives that are

00:04:24,560 --> 00:04:29,040
used for all of these different tasks

00:04:27,600 --> 00:04:31,520
but as we were thinking about all the

00:04:29,040 --> 00:04:33,840
places where we wanted to run wazzy

00:04:31,520 --> 00:04:37,600
we started wondering whether or not this

00:04:33,840 --> 00:04:37,600
was the right abstraction to use

00:04:37,680 --> 00:04:41,360
the file achieved its central position

00:04:39,759 --> 00:04:42,000
in system interfaces during a very

00:04:41,360 --> 00:04:44,720
different time

00:04:42,000 --> 00:04:46,560
in software development there were a few

00:04:44,720 --> 00:04:47,120
operating systems that really entrenched

00:04:46,560 --> 00:04:49,120
the file

00:04:47,120 --> 00:04:50,720
in this privileged position and these

00:04:49,120 --> 00:04:53,520
operating systems were first being

00:04:50,720 --> 00:04:55,040
developed in the 1970s and 80s

00:04:53,520 --> 00:04:56,479
this is when you had the rise of the

00:04:55,040 --> 00:04:57,840
mini computer and after that the

00:04:56,479 --> 00:04:59,759
personal computer

00:04:57,840 --> 00:05:03,919
mostly to help with office work which of

00:04:59,759 --> 00:05:06,000
course was organized in real paper files

00:05:03,919 --> 00:05:07,919
for these kinds of systems having a file

00:05:06,000 --> 00:05:11,520
system and having direct access to that

00:05:07,919 --> 00:05:12,880
file system made a whole lot of sense

00:05:11,520 --> 00:05:15,199
if you look at the systems that we're

00:05:12,880 --> 00:05:16,400
building now though things look a bit

00:05:15,199 --> 00:05:18,080
different

00:05:16,400 --> 00:05:19,600
we're still building applications for

00:05:18,080 --> 00:05:21,360
the personal computer

00:05:19,600 --> 00:05:22,960
but with things like browsers we started

00:05:21,360 --> 00:05:24,400
running applications inside of other

00:05:22,960 --> 00:05:25,840
applications

00:05:24,400 --> 00:05:27,840
places where you probably don't want the

00:05:25,840 --> 00:05:29,759
inner application to have direct access

00:05:27,840 --> 00:05:31,120
to the file system

00:05:29,759 --> 00:05:32,479
and then as we started moving

00:05:31,120 --> 00:05:34,400
applications to the cloud and edge

00:05:32,479 --> 00:05:35,680
networks and as iot devices started

00:05:34,400 --> 00:05:37,440
proliferating

00:05:35,680 --> 00:05:39,600
we suddenly had an entirely different

00:05:37,440 --> 00:05:41,360
landscape where direct access to a real

00:05:39,600 --> 00:05:43,280
file system was the exception not the

00:05:41,360 --> 00:05:46,080
norm

00:05:43,280 --> 00:05:48,720
and on top of all of that as we've moved

00:05:46,080 --> 00:05:50,080
towards having more modular ecosystems

00:05:48,720 --> 00:05:52,160
of open source code that you plug

00:05:50,080 --> 00:05:53,840
together like npm or pi pi

00:05:52,160 --> 00:05:55,440
these file systems are presenting

00:05:53,840 --> 00:05:56,880
maintainability and security problems

00:05:55,440 --> 00:05:58,080
because the way that these file systems

00:05:56,880 --> 00:06:00,560
are used

00:05:58,080 --> 00:06:01,120
is basically like having one big giant

00:06:00,560 --> 00:06:04,639
pile

00:06:01,120 --> 00:06:04,639
of global shared mutable state

00:06:04,800 --> 00:06:08,720
given all of this files don't really

00:06:07,199 --> 00:06:11,039
feel like the right kind of universal

00:06:08,720 --> 00:06:12,720
abstraction anymore

00:06:11,039 --> 00:06:14,639
if we're going to try and break out of

00:06:12,720 --> 00:06:16,479
this file-centric paradigm

00:06:14,639 --> 00:06:18,639
we need to think about what a file

00:06:16,479 --> 00:06:22,000
actually is and what it does

00:06:18,639 --> 00:06:23,759
so what exactly is a file well a file

00:06:22,000 --> 00:06:25,600
consists of two things

00:06:23,759 --> 00:06:28,639
some bytes that encode content and you

00:06:25,600 --> 00:06:31,600
can think of this as an array or stream

00:06:28,639 --> 00:06:34,960
this is the data and other bytes that

00:06:31,600 --> 00:06:36,639
contain metadata about that data

00:06:34,960 --> 00:06:38,960
so this includes things like the name of

00:06:36,639 --> 00:06:41,039
the file timestamps permissions

00:06:38,960 --> 00:06:43,600
and what underlying device the file is

00:06:41,039 --> 00:06:43,600
stored on

00:06:43,759 --> 00:06:48,080
it's the second part here where we start

00:06:45,919 --> 00:06:49,599
to have problems

00:06:48,080 --> 00:06:51,199
when you're working with this metadata

00:06:49,599 --> 00:06:52,560
that's when you need to know about the

00:06:51,199 --> 00:06:54,720
conventions of the host system that

00:06:52,560 --> 00:06:56,400
you're running on

00:06:54,720 --> 00:06:58,080
but when you think about what most

00:06:56,400 --> 00:06:59,599
programs are actually doing what they

00:06:58,080 --> 00:07:01,759
actually care about

00:06:59,599 --> 00:07:03,280
most of them only care about the data

00:07:01,759 --> 00:07:04,880
they just want to get that array or

00:07:03,280 --> 00:07:05,680
stream of bytes and start working on

00:07:04,880 --> 00:07:07,520
that

00:07:05,680 --> 00:07:09,840
they don't care about where the data

00:07:07,520 --> 00:07:11,039
lives

00:07:09,840 --> 00:07:12,960
now there are of course some

00:07:11,039 --> 00:07:14,960
applications that do need to know

00:07:12,960 --> 00:07:16,560
the details of this metadata as well so

00:07:14,960 --> 00:07:17,280
for example if you're building a backup

00:07:16,560 --> 00:07:19,039
application

00:07:17,280 --> 00:07:22,000
you of course do need to know the file

00:07:19,039 --> 00:07:23,759
names of those files

00:07:22,000 --> 00:07:25,360
but most of the time the metadata is

00:07:23,759 --> 00:07:27,440
unnecessary for what a program is trying

00:07:25,360 --> 00:07:29,280
to do

00:07:27,440 --> 00:07:31,199
my colleague and the architect of much

00:07:29,280 --> 00:07:32,080
of wazzy dan gilman has called this

00:07:31,199 --> 00:07:33,919
distinction

00:07:32,080 --> 00:07:35,280
the difference between compute and meta

00:07:33,919 --> 00:07:36,720
compute

00:07:35,280 --> 00:07:38,960
and he had the thought that what if we

00:07:36,720 --> 00:07:40,720
were to push as much of the meta compute

00:07:38,960 --> 00:07:42,080
out to the edges of the system as

00:07:40,720 --> 00:07:44,080
possible

00:07:42,080 --> 00:07:47,360
either up to an orchestrating module or

00:07:44,080 --> 00:07:49,680
even better out to the host itself

00:07:47,360 --> 00:07:52,319
to see exactly what this means let's

00:07:49,680 --> 00:07:53,840
walk through an example

00:07:52,319 --> 00:07:55,599
let's say that you're writing a utility

00:07:53,840 --> 00:07:57,120
that shrinks an image down to a

00:07:55,599 --> 00:07:58,879
particular size

00:07:57,120 --> 00:08:00,720
and you want to run this utility from a

00:07:58,879 --> 00:08:02,240
command line

00:08:00,720 --> 00:08:05,039
how would this work in the file system

00:08:02,240 --> 00:08:06,560
centric paradigm

00:08:05,039 --> 00:08:08,879
we have the host system that's the

00:08:06,560 --> 00:08:10,720
outside the gray

00:08:08,879 --> 00:08:13,840
and the wasm module is running inside of

00:08:10,720 --> 00:08:16,560
the host inside of this white box

00:08:13,840 --> 00:08:19,599
so the wasm module would be passed in an

00:08:16,560 --> 00:08:20,960
array of arguments that are all strings

00:08:19,599 --> 00:08:23,440
and would take the string that's at a

00:08:20,960 --> 00:08:24,879
particular index and use that as a file

00:08:23,440 --> 00:08:26,800
name

00:08:24,879 --> 00:08:29,039
and then that wasm module would use that

00:08:26,800 --> 00:08:30,720
string with the open syscall

00:08:29,039 --> 00:08:32,320
to get a handle to the file the

00:08:30,720 --> 00:08:34,399
operating system would hand it back a

00:08:32,320 --> 00:08:35,919
handle

00:08:34,399 --> 00:08:39,599
and then the wasm module would read the

00:08:35,919 --> 00:08:42,320
bytes from that file using the handle

00:08:39,599 --> 00:08:43,760
with this we're requiring the module to

00:08:42,320 --> 00:08:45,760
think about the file system we're

00:08:43,760 --> 00:08:48,880
requiring it to think about the concept

00:08:45,760 --> 00:08:50,560
the context that it's running in but

00:08:48,880 --> 00:08:52,160
this module wouldn't really need to know

00:08:50,560 --> 00:08:53,680
about these details all it really needs

00:08:52,160 --> 00:08:56,880
is the stream of bytes to come in so

00:08:53,680 --> 00:08:58,640
that it can operate on that stream

00:08:56,880 --> 00:09:00,399
so now let's try moving this meta

00:08:58,640 --> 00:09:02,880
compute out of the module and over to

00:09:00,399 --> 00:09:02,880
the host

00:09:03,040 --> 00:09:06,480
now by convention a program's main

00:09:05,279 --> 00:09:09,200
function takes in

00:09:06,480 --> 00:09:10,000
a very generic set of parameters so for

00:09:09,200 --> 00:09:13,040
example in c

00:09:10,000 --> 00:09:14,560
it takes the r count and then a pointer

00:09:13,040 --> 00:09:16,320
to the array of strings that are the

00:09:14,560 --> 00:09:17,600
args

00:09:16,320 --> 00:09:19,680
but let's say that we introduced a

00:09:17,600 --> 00:09:22,560
convention and tooling support for more

00:09:19,680 --> 00:09:23,760
application specific parameters

00:09:22,560 --> 00:09:25,440
for example let's say that the main

00:09:23,760 --> 00:09:26,560
function for this application accepts a

00:09:25,440 --> 00:09:28,240
stream

00:09:26,560 --> 00:09:31,360
and returns a result that contains

00:09:28,240 --> 00:09:33,519
either a stream or an error

00:09:31,360 --> 00:09:34,880
when you run this on the command line

00:09:33,519 --> 00:09:36,000
the host will be able to look at that

00:09:34,880 --> 00:09:37,360
string

00:09:36,000 --> 00:09:39,680
and also see that the type that was

00:09:37,360 --> 00:09:41,040
asked for by the program is a stream

00:09:39,680 --> 00:09:42,800
and the host would know that it can

00:09:41,040 --> 00:09:45,920
convert a file

00:09:42,800 --> 00:09:46,720
to a stream so instead of just passing

00:09:45,920 --> 00:09:48,720
in a string

00:09:46,720 --> 00:09:50,720
the host would instead open the file

00:09:48,720 --> 00:09:52,959
itself and get the handle

00:09:50,720 --> 00:09:55,680
which the host would then use to pass in

00:09:52,959 --> 00:09:56,880
the stream of bytes to the wasm module

00:09:55,680 --> 00:09:59,600
and with this we've moved all of that

00:09:56,880 --> 00:10:02,560
metacompute over to the host

00:09:59,600 --> 00:10:04,240
so this module's no longer has any

00:10:02,560 --> 00:10:07,760
concept baked into it

00:10:04,240 --> 00:10:09,760
of whether or not there's a file system

00:10:07,760 --> 00:10:11,440
this makes the code more portable and

00:10:09,760 --> 00:10:12,320
this architecture also makes things more

00:10:11,440 --> 00:10:14,399
secure

00:10:12,320 --> 00:10:16,240
because this way we didn't actually need

00:10:14,399 --> 00:10:19,600
to give the open syst call

00:10:16,240 --> 00:10:21,920
to the wasm module either and so

00:10:19,600 --> 00:10:22,640
if this wasm module were to get

00:10:21,920 --> 00:10:24,959
exploited

00:10:22,640 --> 00:10:26,320
or were subject to a supply chain attack

00:10:24,959 --> 00:10:28,560
it wouldn't have access

00:10:26,320 --> 00:10:30,880
to open files willy-nilly on your

00:10:28,560 --> 00:10:30,880
machine

00:10:31,600 --> 00:10:34,959
of course none of this matters if

00:10:33,279 --> 00:10:37,760
developers don't use it

00:10:34,959 --> 00:10:39,040
we need to have a gradual adoption path

00:10:37,760 --> 00:10:40,399
we need a way for everyone in the

00:10:39,040 --> 00:10:42,160
community to transition to this new

00:10:40,399 --> 00:10:44,839
paradigm at their own pace so that the

00:10:42,160 --> 00:10:46,079
whole community doesn't need to move in

00:10:44,839 --> 00:10:47,839
lockstep

00:10:46,079 --> 00:10:49,760
we have three different options for how

00:10:47,839 --> 00:10:51,360
to compile a module to use wazi and

00:10:49,760 --> 00:10:53,839
these three options represent that

00:10:51,360 --> 00:10:55,360
gradual adoption path

00:10:53,839 --> 00:10:57,760
so let's say that you already have some

00:10:55,360 --> 00:10:59,760
legacy code that you want to compile

00:10:57,760 --> 00:11:01,760
and this code makes extensive use of the

00:10:59,760 --> 00:11:03,680
not so good parts of traditional file

00:11:01,760 --> 00:11:07,279
system apis the ones that bake in

00:11:03,680 --> 00:11:09,279
expectations about the host environment

00:11:07,279 --> 00:11:10,720
in that case you would signal to the

00:11:09,279 --> 00:11:12,800
compiler

00:11:10,720 --> 00:11:14,399
that you want to use the legacy file

00:11:12,800 --> 00:11:16,079
system interface

00:11:14,399 --> 00:11:18,959
now this might be through a flag or

00:11:16,079 --> 00:11:20,560
through a target triple

00:11:18,959 --> 00:11:22,160
this would link your code against a

00:11:20,560 --> 00:11:24,160
version of libc or whatever your

00:11:22,160 --> 00:11:26,320
language's standard library is that's

00:11:24,160 --> 00:11:26,880
implemented in terms of the wazzy file

00:11:26,320 --> 00:11:29,680
system

00:11:26,880 --> 00:11:30,640
interface and this is in many ways the

00:11:29,680 --> 00:11:33,120
same api

00:11:30,640 --> 00:11:33,680
as the file system api exposed by posix

00:11:33,120 --> 00:11:37,440
in in

00:11:33,680 --> 00:11:37,920
other system interfaces so your code can

00:11:37,440 --> 00:11:39,839
act

00:11:37,920 --> 00:11:42,000
like it has direct access to a file

00:11:39,839 --> 00:11:43,920
system which it might in some cases

00:11:42,000 --> 00:11:46,560
or the host might provide a virtualized

00:11:43,920 --> 00:11:46,560
file system

00:11:46,640 --> 00:11:51,279
either way this looks pretty much like

00:11:48,640 --> 00:11:53,440
the run-of-the-mill file system apis

00:11:51,279 --> 00:11:54,880
so your code would not have to actually

00:11:53,440 --> 00:11:58,160
make any changes you wouldn't have to

00:11:54,880 --> 00:12:00,639
make any changes to your code rather

00:11:58,160 --> 00:12:02,399
now this code would not work on hosts

00:12:00,639 --> 00:12:04,320
that didn't either provide direct access

00:12:02,399 --> 00:12:06,320
to the file system or that virtualized

00:12:04,320 --> 00:12:08,880
file system that i mentioned before so

00:12:06,320 --> 00:12:10,720
it wouldn't provide the full portability

00:12:08,880 --> 00:12:14,320
but it would be an easy on-ramp to

00:12:10,720 --> 00:12:16,240
moving code to use webassembly

00:12:14,320 --> 00:12:18,160
but what if you want the portability and

00:12:16,240 --> 00:12:19,200
you also want the isolation

00:12:18,160 --> 00:12:20,800
between different modules that

00:12:19,200 --> 00:12:23,360
webassembly can give you where you

00:12:20,800 --> 00:12:26,639
aren't sharing that global file system

00:12:23,360 --> 00:12:29,279
between modules for that case we're

00:12:26,639 --> 00:12:30,639
providing a compatibility layer

00:12:29,279 --> 00:12:32,480
the developer would still write their

00:12:30,639 --> 00:12:34,079
code using the language's normal file

00:12:32,480 --> 00:12:35,200
apis but in this case what we're

00:12:34,079 --> 00:12:36,639
currently thinking

00:12:35,200 --> 00:12:38,560
is that the host wouldn't be providing

00:12:36,639 --> 00:12:40,399
the file system itself

00:12:38,560 --> 00:12:42,320
instead the module would be virtualizing

00:12:40,399 --> 00:12:44,320
its own file system

00:12:42,320 --> 00:12:47,839
and these quote-unquote files would be

00:12:44,320 --> 00:12:49,519
in the linear memory of the wasm module

00:12:47,839 --> 00:12:50,959
this means that we don't have the global

00:12:49,519 --> 00:12:53,760
shared mutable state problem that the

00:12:50,959 --> 00:12:55,519
file system introduces

00:12:53,760 --> 00:12:57,519
even though these look like files in the

00:12:55,519 --> 00:12:59,440
source code under the hood they would

00:12:57,519 --> 00:13:00,639
use a different set of types was the i o

00:12:59,440 --> 00:13:01,920
types

00:13:00,639 --> 00:13:04,160
and this would give them that full

00:13:01,920 --> 00:13:05,680
portability

00:13:04,160 --> 00:13:07,279
however this virtualization would

00:13:05,680 --> 00:13:10,800
introduce some inefficiencies including

00:13:07,279 --> 00:13:12,240
larger file sizes for the wasm module

00:13:10,800 --> 00:13:14,399
so in the case where you want full

00:13:12,240 --> 00:13:16,480
portability and you want that efficiency

00:13:14,399 --> 00:13:18,560
all at the same time you would use a

00:13:16,480 --> 00:13:22,399
different api in your source code

00:13:18,560 --> 00:13:23,600
you would use the wazzy i o api directly

00:13:22,399 --> 00:13:26,000
so that means that you would change your

00:13:23,600 --> 00:13:27,920
code instead of passing file handles

00:13:26,000 --> 00:13:30,399
around you'd be passing i o types like

00:13:27,920 --> 00:13:32,320
streams and arrays of bytes around

00:13:30,399 --> 00:13:34,000
and with this the developer no longer

00:13:32,320 --> 00:13:36,399
even thinks in terms of files it's all

00:13:34,000 --> 00:13:38,079
just these i o types the developer

00:13:36,399 --> 00:13:38,639
doesn't think i have a file with this

00:13:38,079 --> 00:13:40,880
name

00:13:38,639 --> 00:13:42,639
in this directory i'll open the file and

00:13:40,880 --> 00:13:46,480
read the bytes from the file

00:13:42,639 --> 00:13:48,160
they just think i have a stream of bytes

00:13:46,480 --> 00:13:50,000
so this means that the code really can

00:13:48,160 --> 00:13:51,920
run anywhere it doesn't matter what the

00:13:50,000 --> 00:13:54,720
host system all systems can represent

00:13:51,920 --> 00:13:56,480
these basic primitive types

00:13:54,720 --> 00:13:58,399
and we've completely gotten rid of the

00:13:56,480 --> 00:13:59,120
potential for the global shared mutable

00:13:58,399 --> 00:14:00,720
state

00:13:59,120 --> 00:14:04,880
while also eliminating the overhead of

00:14:00,720 --> 00:14:04,880
the per module virtualized file system

00:14:04,959 --> 00:14:08,639
this path also potentially opens up

00:14:06,880 --> 00:14:10,000
opportunities for further optimizations

00:14:08,639 --> 00:14:13,760
because the engine now has

00:14:10,000 --> 00:14:13,760
more detailed type information

00:14:14,800 --> 00:14:18,000
now when talking about these three

00:14:16,560 --> 00:14:19,040
options there's something i want to be

00:14:18,000 --> 00:14:20,880
clear about

00:14:19,040 --> 00:14:22,480
you don't need to make the same choice

00:14:20,880 --> 00:14:23,839
for all of the different modules in your

00:14:22,480 --> 00:14:26,079
app

00:14:23,839 --> 00:14:27,600
part of this gradual adoption path is

00:14:26,079 --> 00:14:31,120
having the ability to convert certain

00:14:27,600 --> 00:14:32,560
modules before others

00:14:31,120 --> 00:14:34,240
with both the second and the third

00:14:32,560 --> 00:14:36,720
option that i just talked about

00:14:34,240 --> 00:14:39,199
you're using the wazi io types either

00:14:36,720 --> 00:14:40,880
explicitly or implicitly

00:14:39,199 --> 00:14:42,320
and in both cases you're not expecting

00:14:40,880 --> 00:14:44,880
to share the file system between these

00:14:42,320 --> 00:14:46,240
two modules so this means that you can

00:14:44,880 --> 00:14:47,920
use these two modules together and they

00:14:46,240 --> 00:14:50,000
can simply pass values back and forth

00:14:47,920 --> 00:14:51,760
between each other

00:14:50,000 --> 00:14:53,519
now it's not quite as trivial to plug

00:14:51,760 --> 00:14:55,040
these modules up to ones that use waxy

00:14:53,519 --> 00:14:57,760
file system

00:14:55,040 --> 00:14:59,519
but it's still pretty easy if you want a

00:14:57,760 --> 00:15:01,040
module that's using wazi file system to

00:14:59,519 --> 00:15:02,320
call something from a module that uses

00:15:01,040 --> 00:15:03,680
waziio

00:15:02,320 --> 00:15:05,839
then you just need to have some code in

00:15:03,680 --> 00:15:06,560
between to extract the stream or array

00:15:05,839 --> 00:15:08,320
of bytes

00:15:06,560 --> 00:15:12,240
from the file's content and pass that

00:15:08,320 --> 00:15:13,839
into the wazzy io module

00:15:12,240 --> 00:15:15,920
there are some kinds of modules that

00:15:13,839 --> 00:15:17,839
will always require full wazzy file

00:15:15,920 --> 00:15:20,160
system that can't use only the portable

00:15:17,839 --> 00:15:22,079
parts of the file system

00:15:20,160 --> 00:15:24,000
but we expect this to represent a very

00:15:22,079 --> 00:15:25,440
small fraction of the modules that

00:15:24,000 --> 00:15:27,040
developers are creating and we're hoping

00:15:25,440 --> 00:15:28,079
to see the rest of the ecosystem

00:15:27,040 --> 00:15:31,600
gradually migrate

00:15:28,079 --> 00:15:31,600
to only using waziio

00:15:32,000 --> 00:15:35,120
so this is the kind of thinking that

00:15:33,759 --> 00:15:37,120
we're applying as we're building out

00:15:35,120 --> 00:15:39,199
this new ecosystem

00:15:37,120 --> 00:15:41,680
how can we move these details out to the

00:15:39,199 --> 00:15:43,279
edges so that orchestrating code or the

00:15:41,680 --> 00:15:46,639
host can take charge of them and

00:15:43,279 --> 00:15:46,639
potentially optimize them

00:15:47,120 --> 00:15:50,959
and it's one of these potential host

00:15:48,639 --> 00:15:52,959
optimizations that i want to end with

00:15:50,959 --> 00:15:55,199
just to get everybody's minds start to

00:15:52,959 --> 00:15:56,720
start turning on what this paradigm

00:15:55,199 --> 00:15:58,720
could potentially open up for cloud

00:15:56,720 --> 00:16:00,399
native

00:15:58,720 --> 00:16:01,600
and this is just one opportunity that we

00:16:00,399 --> 00:16:03,040
see but i'm sure that there are more

00:16:01,600 --> 00:16:03,920
that others who are more familiar with

00:16:03,040 --> 00:16:05,360
cloud native

00:16:03,920 --> 00:16:08,959
will also be able to see and we're

00:16:05,360 --> 00:16:10,399
excited to explore those more

00:16:08,959 --> 00:16:11,920
now this opportunity has to do with

00:16:10,399 --> 00:16:14,000
requests between containers and how to

00:16:11,920 --> 00:16:15,600
make those faster

00:16:14,000 --> 00:16:17,040
so let's walk through what happens when

00:16:15,600 --> 00:16:17,680
you make a request so i want to be clear

00:16:17,040 --> 00:16:19,199
here

00:16:17,680 --> 00:16:20,560
this is just based on conversations i've

00:16:19,199 --> 00:16:21,279
had i haven't actually set this up

00:16:20,560 --> 00:16:22,800
myself

00:16:21,279 --> 00:16:24,000
and step through it so there's a chance

00:16:22,800 --> 00:16:24,399
i've gotten some of the details wrong

00:16:24,000 --> 00:16:25,600
here

00:16:24,399 --> 00:16:28,639
but i think that this is at least

00:16:25,600 --> 00:16:29,920
directionally correct

00:16:28,639 --> 00:16:31,680
so let's say that you want to make a

00:16:29,920 --> 00:16:35,440
request to another service

00:16:31,680 --> 00:16:36,959
in another plot what does it look like

00:16:35,440 --> 00:16:39,680
the data that you're sending over gets

00:16:36,959 --> 00:16:41,600
serialized using a format like protobufs

00:16:39,680 --> 00:16:43,279
and this is saved into memory in user

00:16:41,600 --> 00:16:45,600
space

00:16:43,279 --> 00:16:46,880
and then the system makes a syscall the

00:16:45,600 --> 00:16:49,120
memory is copied over

00:16:46,880 --> 00:16:51,040
into kernel space memory so that's two

00:16:49,120 --> 00:16:52,399
copies already

00:16:51,040 --> 00:16:53,839
and now let's say that you're using a

00:16:52,399 --> 00:16:55,040
sidecar for something like a service

00:16:53,839 --> 00:16:56,959
mesh

00:16:55,040 --> 00:16:58,720
so that sidecar is another container in

00:16:56,959 --> 00:17:00,480
the same pod

00:16:58,720 --> 00:17:02,720
the data gets sent over to this

00:17:00,480 --> 00:17:04,240
container as an incoming packet

00:17:02,720 --> 00:17:06,559
the data gets copied again into kernel

00:17:04,240 --> 00:17:08,799
space memory by network drivers

00:17:06,559 --> 00:17:09,919
the data is then copied into user space

00:17:08,799 --> 00:17:12,880
of the sidecar

00:17:09,919 --> 00:17:15,600
proxy and then the system deserializes

00:17:12,880 --> 00:17:17,919
the data into objects that it can use

00:17:15,600 --> 00:17:20,000
and only then does the service mesh

00:17:17,919 --> 00:17:21,280
policy actually run on this data we

00:17:20,000 --> 00:17:22,400
haven't even gotten the data out of the

00:17:21,280 --> 00:17:23,839
pod yet

00:17:22,400 --> 00:17:25,760
we still have to go through steps one

00:17:23,839 --> 00:17:27,439
through four again to get the data out

00:17:25,760 --> 00:17:28,640
to the network

00:17:27,439 --> 00:17:32,320
and then when it gets to the other side

00:17:28,640 --> 00:17:34,799
this whole process happens in reverse

00:17:32,320 --> 00:17:36,480
now two-thirds of the steps here were

00:17:34,799 --> 00:17:39,919
actually to make a request

00:17:36,480 --> 00:17:40,640
on the same machine they were to pipe

00:17:39,919 --> 00:17:43,280
the data

00:17:40,640 --> 00:17:45,120
into that sidecar and you'll see that

00:17:43,280 --> 00:17:46,880
the documentation about the sidecar

00:17:45,120 --> 00:17:49,039
sidecar pattern calls this out as a

00:17:46,880 --> 00:17:50,080
trade-off these docs suggest that you

00:17:49,039 --> 00:17:51,679
ask yourself

00:17:50,080 --> 00:17:53,120
whether the isolation is really worth

00:17:51,679 --> 00:17:55,200
the additional overhead

00:17:53,120 --> 00:17:58,799
that your the sidecar is going to

00:17:55,200 --> 00:18:00,799
introduce in your use case

00:17:58,799 --> 00:18:02,320
but this overhead isn't inherent to the

00:18:00,799 --> 00:18:04,720
problem we can actually eliminate this

00:18:02,320 --> 00:18:06,640
as a trade-off

00:18:04,720 --> 00:18:08,880
since we can do fine-grained sandboxing

00:18:06,640 --> 00:18:10,240
and wasm we can actually make this

00:18:08,880 --> 00:18:10,960
relationship between the container and

00:18:10,240 --> 00:18:12,640
the sidecar

00:18:10,960 --> 00:18:14,080
much more efficient even running them in

00:18:12,640 --> 00:18:15,520
the same process

00:18:14,080 --> 00:18:17,760
but we still get all the isolation

00:18:15,520 --> 00:18:19,200
between the two and possibly more

00:18:17,760 --> 00:18:21,520
depending on how they were using a file

00:18:19,200 --> 00:18:24,080
system or volume

00:18:21,520 --> 00:18:26,000
and because of this we don't need the

00:18:24,080 --> 00:18:28,240
socket to be our interface between the

00:18:26,000 --> 00:18:30,080
isolated units of code

00:18:28,240 --> 00:18:32,240
instead our interface is just typed

00:18:30,080 --> 00:18:33,840
function calls

00:18:32,240 --> 00:18:36,080
to communicate between these two we

00:18:33,840 --> 00:18:38,160
simply do a synchronous function call on

00:18:36,080 --> 00:18:39,919
a single thread stack

00:18:38,160 --> 00:18:41,520
we do direct register copies and

00:18:39,919 --> 00:18:43,200
potentially direct memory copies if

00:18:41,520 --> 00:18:44,960
they're needed

00:18:43,200 --> 00:18:47,039
there's no intermediate serialization

00:18:44,960 --> 00:18:49,039
and dc realization step here

00:18:47,039 --> 00:18:52,080
no heavyweight calls to the kernel or

00:18:49,039 --> 00:18:53,919
inter-process communication

00:18:52,080 --> 00:18:56,080
this actually puts us in the nanosecond

00:18:53,919 --> 00:18:57,600
range for calls between these two and

00:18:56,080 --> 00:18:59,120
this would be much faster than the call

00:18:57,600 --> 00:19:01,600
we just looked at from container to

00:18:59,120 --> 00:19:01,600
sidecar

00:19:01,760 --> 00:19:05,919
however sometimes you actually do need

00:19:04,080 --> 00:19:07,120
things to be on different machines

00:19:05,919 --> 00:19:08,799
across the network and it would be

00:19:07,120 --> 00:19:10,799
inconvenient to have different apis for

00:19:08,799 --> 00:19:12,320
representing that and to have to change

00:19:10,799 --> 00:19:13,360
which api you're using in your source

00:19:12,320 --> 00:19:14,799
code based on

00:19:13,360 --> 00:19:16,640
whether or not the other container is on

00:19:14,799 --> 00:19:19,120
the same machine or not

00:19:16,640 --> 00:19:21,039
but we don't have to do that in this

00:19:19,120 --> 00:19:22,320
paradigm we've moved all of the decision

00:19:21,039 --> 00:19:24,960
making related to where the code is

00:19:22,320 --> 00:19:26,799
running out to the edges

00:19:24,960 --> 00:19:28,000
so the module that you'd write would

00:19:26,799 --> 00:19:29,760
import the callee

00:19:28,000 --> 00:19:32,240
specifying a function signature that's

00:19:29,760 --> 00:19:34,720
appropriate for cross network calls

00:19:32,240 --> 00:19:35,679
so for example allowing for various

00:19:34,720 --> 00:19:37,280
network failure

00:19:35,679 --> 00:19:39,840
failure modes and supporting

00:19:37,280 --> 00:19:39,840
non-blocking

00:19:40,160 --> 00:19:43,919
now in the case where the kali is on a

00:19:42,880 --> 00:19:45,919
different machine

00:19:43,919 --> 00:19:46,960
the host would take care of serializing

00:19:45,919 --> 00:19:50,000
the data

00:19:46,960 --> 00:19:51,919
and streaming it over the socket but if

00:19:50,000 --> 00:19:53,520
a service mesh is being used the host

00:19:51,919 --> 00:19:55,039
would instead supply a proxy module

00:19:53,520 --> 00:19:56,799
that's on the same machine

00:19:55,039 --> 00:19:59,840
using the much cheaper calling

00:19:56,799 --> 00:20:02,000
convention described before

00:19:59,840 --> 00:20:04,000
now the important thing is that it's the

00:20:02,000 --> 00:20:05,280
host that handles this distinction not

00:20:04,000 --> 00:20:06,880
your code

00:20:05,280 --> 00:20:08,400
and so in this way you can get the

00:20:06,880 --> 00:20:09,760
optimal performance

00:20:08,400 --> 00:20:11,440
when you're talking to a container on

00:20:09,760 --> 00:20:12,720
the same machine while not sacrificing

00:20:11,440 --> 00:20:16,080
the ability to communicate with a

00:20:12,720 --> 00:20:16,080
container that's across the network

00:20:16,320 --> 00:20:19,919
we don't have all of these pieces in

00:20:18,320 --> 00:20:22,000
place right now but once we do have

00:20:19,919 --> 00:20:23,600
these foundational primitives in place

00:20:22,000 --> 00:20:25,280
we think that someone could build this

00:20:23,600 --> 00:20:27,440
kind of efficiency into the

00:20:25,280 --> 00:20:31,120
existing cloud native ecosystem and

00:20:27,440 --> 00:20:31,120
we're excited to explore this further

00:20:32,240 --> 00:20:35,600
we'll be writing about all of this more

00:20:33,919 --> 00:20:37,120
over the coming months as we push these

00:20:35,600 --> 00:20:38,480
standards forward

00:20:37,120 --> 00:20:40,000
and we'd be very interested in hearing

00:20:38,480 --> 00:20:41,039
from people in the cloud native

00:20:40,000 --> 00:20:42,880
ecosystem

00:20:41,039 --> 00:20:46,799
about your use cases and about what you

00:20:42,880 --> 00:20:46,799
see this kind of architecture opening up

00:20:47,360 --> 00:20:50,760
thank you again to the organizers for

00:20:49,120 --> 00:20:53,760
inviting me and thank you all for

00:20:50,760 --> 00:20:53,760

YouTube URL: https://www.youtube.com/watch?v=k3HDivg3xyc


