Title: Developing & Debugging WebAssembly Filters for Envoy - Shane O'Donnell & Yuval Kohavi, Solo.io
Publication date: 2021-05-04
Playlist: Cloud Native Wasm Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Developing & Debugging WebAssembly Filters for Envoy - Shane O'Donnell & Yuval Kohavi, Solo.io

WebAssembly filters allow users the power to extend and customize Istio to their liking. But how do organizations actually develop them? Tooling exists for traditional software development, but established methods and tooling are difficult to come by in the emerging WebAssembly ecosystem. In this talk we will attempt to answer the following, based on our experience working Istio + WebAssembly in customer environments for over one year: How do we write WebAssembly filters? How do we test WebAssembly filters? How do we debug WebAssembly filters? How do we ship WebAssembly filters? We will explore existing tooling and solutions for working with WebAssembly in the service mesh, and provide insight into the development processes being implemented by early adopters of WebAssembly.
Captions: 
	00:00:01,280 --> 00:00:04,560
hi everybody welcome to our talk about

00:00:03,120 --> 00:00:07,680
developing and debugging

00:00:04,560 --> 00:00:10,240
web assembly filters i'm yuval kujavi

00:00:07,680 --> 00:00:11,519
chief architect at solo io

00:00:10,240 --> 00:00:14,639
and i'm shane o'donnell a software

00:00:11,519 --> 00:00:14,639
engineer at solo.io

00:00:15,120 --> 00:00:18,800
let's talk a little bit about the agenda

00:00:16,640 --> 00:00:19,439
for today we'll start with isro and

00:00:18,800 --> 00:00:21,840
envoy

00:00:19,439 --> 00:00:23,920
we'll do a little bit of an overview

00:00:21,840 --> 00:00:24,400
then we'll talk about how to build and

00:00:23,920 --> 00:00:26,960
deploy

00:00:24,400 --> 00:00:27,920
webassembly filters onto your service

00:00:26,960 --> 00:00:29,519
mesh

00:00:27,920 --> 00:00:31,119
and then we'll talk about how we

00:00:29,519 --> 00:00:34,000
troubleshoot and debug these web

00:00:31,119 --> 00:00:36,719
assembly filters

00:00:34,000 --> 00:00:38,559
let's talk a little bit about uh it's

00:00:36,719 --> 00:00:42,559
your adoption

00:00:38,559 --> 00:00:44,719
that we see in the industry

00:00:42,559 --> 00:00:46,719
so we like to divide it to this fourth

00:00:44,719 --> 00:00:48,480
step the first step we see is kind of a

00:00:46,719 --> 00:00:51,360
crawl step where

00:00:48,480 --> 00:00:53,120
people need support for abstract mitsuo

00:00:51,360 --> 00:00:54,640
they're just testing it out they need

00:00:53,120 --> 00:00:56,960
long-term support

00:00:54,640 --> 00:00:57,680
they're beginning to learn what service

00:00:56,960 --> 00:01:01,199
mesh

00:00:57,680 --> 00:01:03,520
means technically and operationally

00:01:01,199 --> 00:01:05,199
then the next step is people add on more

00:01:03,520 --> 00:01:06,560
features we call it the walk phase

00:01:05,199 --> 00:01:08,640
they're doing

00:01:06,560 --> 00:01:10,479
maybe a developer portal maybe an

00:01:08,640 --> 00:01:14,479
ingress api gateway

00:01:10,479 --> 00:01:17,200
start to use empty lists for zero trust

00:01:14,479 --> 00:01:18,960
security start to use the observability

00:01:17,200 --> 00:01:21,439
features

00:01:18,960 --> 00:01:22,080
once they get more confidence they

00:01:21,439 --> 00:01:24,240
usually

00:01:22,080 --> 00:01:25,439
go to the stage we call the run stage

00:01:24,240 --> 00:01:26,720
which

00:01:25,439 --> 00:01:29,040
involves more delegating

00:01:26,720 --> 00:01:31,360
responsibilities to different teams

00:01:29,040 --> 00:01:32,720
with the various objects that allow

00:01:31,360 --> 00:01:35,520
delegation

00:01:32,720 --> 00:01:37,360
a web assembly filters to enrich the

00:01:35,520 --> 00:01:41,360
data plane

00:01:37,360 --> 00:01:42,880
uh once the once organizations feel

00:01:41,360 --> 00:01:44,000
comfortable in this step the next step

00:01:42,880 --> 00:01:46,640
is really

00:01:44,000 --> 00:01:47,280
taking full advantage of the service

00:01:46,640 --> 00:01:49,920
mesh

00:01:47,280 --> 00:01:51,759
you know multi-cluster meshes federated

00:01:49,920 --> 00:01:53,119
services that can fail over to each

00:01:51,759 --> 00:01:55,759
other

00:01:53,119 --> 00:01:57,200
etc with that i'll hand it off to shane

00:01:55,759 --> 00:01:59,280
to give us

00:01:57,200 --> 00:02:01,360
some of the background on the ico and

00:01:59,280 --> 00:02:03,840
android filters

00:02:01,360 --> 00:02:04,960
so let's do a quick overview of istio's

00:02:03,840 --> 00:02:07,360
architecture

00:02:04,960 --> 00:02:08,879
istio deploys a sidecar proxy to each

00:02:07,360 --> 00:02:09,520
microservice running in your service

00:02:08,879 --> 00:02:11,280
mesh

00:02:09,520 --> 00:02:12,640
these sidecars are each instances of

00:02:11,280 --> 00:02:14,560
envoy proxy

00:02:12,640 --> 00:02:15,920
which we collectively refer to as the

00:02:14,560 --> 00:02:17,520
data plane

00:02:15,920 --> 00:02:18,959
this data plane of envoy proxies is

00:02:17,520 --> 00:02:21,040
controlled by what we call

00:02:18,959 --> 00:02:22,239
the control plane in istio's case this

00:02:21,040 --> 00:02:23,599
is this cod

00:02:22,239 --> 00:02:25,599
and istiod will communicate these

00:02:23,599 --> 00:02:27,680
configuration updates from the control

00:02:25,599 --> 00:02:28,959
plane into the data plane

00:02:27,680 --> 00:02:30,400
once our customers start looking at

00:02:28,959 --> 00:02:32,400
istio one of the first questions they

00:02:30,400 --> 00:02:34,319
ask us is how do we extend it

00:02:32,400 --> 00:02:36,720
we want to build something like dlp data

00:02:34,319 --> 00:02:37,440
loss prevention or waff web application

00:02:36,720 --> 00:02:40,000
firewall

00:02:37,440 --> 00:02:41,040
or any other any other number of

00:02:40,000 --> 00:02:42,400
transformations and

00:02:41,040 --> 00:02:43,920
custom business logic that you're not

00:02:42,400 --> 00:02:45,120
going to get with envoy filters right

00:02:43,920 --> 00:02:47,440
out of the box

00:02:45,120 --> 00:02:48,879
now luckily envoy's incredibly powerful

00:02:47,440 --> 00:02:51,680
and it provides us with a really

00:02:48,879 --> 00:02:53,120
really powerful extension layer inside

00:02:51,680 --> 00:02:54,879
of its filter chain

00:02:53,120 --> 00:02:56,239
so the filter chain out of the box will

00:02:54,879 --> 00:02:57,760
give us some really helpful filters like

00:02:56,239 --> 00:03:00,080
external off and rate limiting

00:02:57,760 --> 00:03:02,480
but it also gives us the ability to

00:03:00,080 --> 00:03:04,400
build our own custom native envoy filter

00:03:02,480 --> 00:03:06,080
now this does have some drawbacks first

00:03:04,400 --> 00:03:08,000
of all you have to write the filter in c

00:03:06,080 --> 00:03:10,400
plus plus and second of all you have to

00:03:08,000 --> 00:03:12,400
actually compile the filter into envoy

00:03:10,400 --> 00:03:13,840
which means you need to be familiar with

00:03:12,400 --> 00:03:14,879
the bazel build system which is

00:03:13,840 --> 00:03:16,239
non-trivial

00:03:14,879 --> 00:03:18,239
and you have to be familiar with

00:03:16,239 --> 00:03:19,519
compiling the entire envoy tool chain

00:03:18,239 --> 00:03:20,159
which takes a lot of time and a lot of

00:03:19,519 --> 00:03:23,440
power

00:03:20,159 --> 00:03:24,799
and it's not that easy to do luckily

00:03:23,440 --> 00:03:26,080
this is where webassembly comes to the

00:03:24,799 --> 00:03:28,640
rescue

00:03:26,080 --> 00:03:30,319
so what is webassembly webassembly is a

00:03:28,640 --> 00:03:32,480
binary format that was originally

00:03:30,319 --> 00:03:34,239
meant to run on the web it was meant to

00:03:32,480 --> 00:03:36,879
run non-javascript languages

00:03:34,239 --> 00:03:38,400
inside of a browser context because it

00:03:36,879 --> 00:03:39,200
was designed to run inside of a browser

00:03:38,400 --> 00:03:40,959
context

00:03:39,200 --> 00:03:42,239
it's built with simplicity security and

00:03:40,959 --> 00:03:44,000
performance in mind

00:03:42,239 --> 00:03:46,080
but these attributes are also incredibly

00:03:44,000 --> 00:03:47,599
desirable when running in other contexts

00:03:46,080 --> 00:03:49,440
the context we're especially interested

00:03:47,599 --> 00:03:50,159
in here is running inside of the envoy

00:03:49,440 --> 00:03:51,680
data plane

00:03:50,159 --> 00:03:54,400
or more specifically inside of the

00:03:51,680 --> 00:03:56,640
filter chain so what does that look like

00:03:54,400 --> 00:03:58,560
rather than having a native custom envoy

00:03:56,640 --> 00:04:00,480
filter now we're running

00:03:58,560 --> 00:04:02,879
envoy's built-in wasn't filter and

00:04:00,480 --> 00:04:04,400
passing it are wasn't filter as code

00:04:02,879 --> 00:04:05,760
this means that it has all of the

00:04:04,400 --> 00:04:06,720
advantages of the other envoy

00:04:05,760 --> 00:04:08,480
configuration

00:04:06,720 --> 00:04:09,680
such that if you want to add or remove a

00:04:08,480 --> 00:04:10,640
wasn't filter or update its

00:04:09,680 --> 00:04:12,239
configuration

00:04:10,640 --> 00:04:13,680
you don't need to restart the proxy

00:04:12,239 --> 00:04:16,639
there's zero downtime

00:04:13,680 --> 00:04:20,160
it's also secure and reliable wasm's

00:04:16,639 --> 00:04:22,240
going to run inside of an isolated vm

00:04:20,160 --> 00:04:23,520
in addition to that not just you you can

00:04:22,240 --> 00:04:25,199
run not only c plus

00:04:23,520 --> 00:04:28,080
filters but any other language that's

00:04:25,199 --> 00:04:29,680
implemented the wasm api runtime

00:04:28,080 --> 00:04:31,759
right now these languages include tiny

00:04:29,680 --> 00:04:35,360
go c plus plus

00:04:31,759 --> 00:04:36,560
assembly script and rust it's got near

00:04:35,360 --> 00:04:37,759
native performance

00:04:36,560 --> 00:04:39,600
which means you can run this on your

00:04:37,759 --> 00:04:41,840
data path and handle real requests

00:04:39,600 --> 00:04:43,360
at production scale and it's sustainable

00:04:41,840 --> 00:04:44,000
because you're just maintaining wasn't

00:04:43,360 --> 00:04:45,600
filters

00:04:44,000 --> 00:04:47,120
you don't need to rebuild all of envoy

00:04:45,600 --> 00:04:50,400
and worry about what happens when envoy

00:04:47,120 --> 00:04:50,400
pushes new security patches

00:04:50,880 --> 00:04:57,440
so i'm going to pass it back to yuval to

00:04:52,320 --> 00:04:59,120
talk a little bit about user experience

00:04:57,440 --> 00:05:01,280
let's talk a little bit about the user

00:04:59,120 --> 00:05:01,680
experience and we like to start with

00:05:01,280 --> 00:05:03,520
this

00:05:01,680 --> 00:05:04,720
tweet from salman height just to

00:05:03,520 --> 00:05:07,759
demonstrate the power

00:05:04,720 --> 00:05:08,880
of web assembly here summon the creator

00:05:07,759 --> 00:05:10,880
of docker

00:05:08,880 --> 00:05:12,880
mentions that if wasserman was he

00:05:10,880 --> 00:05:15,600
existed in 2008

00:05:12,880 --> 00:05:17,840
he wouldn't have needed to create docker

00:05:15,600 --> 00:05:20,720
this can demonstrate the power

00:05:17,840 --> 00:05:24,320
of webassembly and that it can unlock

00:05:20,720 --> 00:05:28,160
many use cases in the data plane

00:05:24,320 --> 00:05:28,800
we like to separate the technology from

00:05:28,160 --> 00:05:31,840
the

00:05:28,800 --> 00:05:34,000
the user experience right with docker

00:05:31,840 --> 00:05:37,120
the technology wasn't new

00:05:34,000 --> 00:05:39,680
linux containers were already there

00:05:37,120 --> 00:05:42,160
docker made it really easy to build and

00:05:39,680 --> 00:05:44,000
distribute those containers

00:05:42,160 --> 00:05:45,919
uh same goes with webassembly

00:05:44,000 --> 00:05:48,880
webassembly exists today

00:05:45,919 --> 00:05:50,080
in envoy but to use it today there's a

00:05:48,880 --> 00:05:52,320
lot of stuff you need to do

00:05:50,080 --> 00:05:53,440
on your own and with the glue mesh web

00:05:52,320 --> 00:05:56,639
assembly hub

00:05:53,440 --> 00:05:58,319
we aim to simplify that

00:05:56,639 --> 00:05:59,919
so let's talk a little bit about the

00:05:58,319 --> 00:06:02,160
life cycle from

00:05:59,919 --> 00:06:04,080
the developer writing the code until the

00:06:02,160 --> 00:06:05,120
filler ends up in your android data

00:06:04,080 --> 00:06:08,960
plane

00:06:05,120 --> 00:06:10,080
serving requests so the first step is to

00:06:08,960 --> 00:06:13,520
build a filter

00:06:10,080 --> 00:06:15,600
now envoy web assembly filters need to

00:06:13,520 --> 00:06:17,680
adhere to the envoy api

00:06:15,600 --> 00:06:18,639
application binary interface that's the

00:06:17,680 --> 00:06:21,520
interface between

00:06:18,639 --> 00:06:22,800
envoy and the filter that's how anwar

00:06:21,520 --> 00:06:26,240
knows how to interact

00:06:22,800 --> 00:06:28,880
with the filter we have pre-packaged

00:06:26,240 --> 00:06:29,520
filters in several languages and we

00:06:28,880 --> 00:06:32,880
allow you

00:06:29,520 --> 00:06:35,360
to quickly and easily get started

00:06:32,880 --> 00:06:36,000
with mesh ctl blue mesh command line

00:06:35,360 --> 00:06:38,080
tool

00:06:36,000 --> 00:06:39,039
we've added the wasm sub command that

00:06:38,080 --> 00:06:42,880
allows you to

00:06:39,039 --> 00:06:46,160
easily initialize a filter with this

00:06:42,880 --> 00:06:49,280
mesh cdl wasn't in it creates

00:06:46,160 --> 00:06:50,639
a base filter so you can start writing

00:06:49,280 --> 00:06:53,280
code

00:06:50,639 --> 00:06:55,120
in addition in order to build each

00:06:53,280 --> 00:06:57,840
language has its own

00:06:55,120 --> 00:07:00,319
built-ins used to build a filter so we

00:06:57,840 --> 00:07:04,000
provide the messenger wasn't built

00:07:00,319 --> 00:07:07,599
in order to build a filter from code

00:07:04,000 --> 00:07:10,319
to web assembly and package it as an oci

00:07:07,599 --> 00:07:13,599
image and i get to why we use an oci

00:07:10,319 --> 00:07:13,599
image in just a second

00:07:13,840 --> 00:07:19,199
so the power of oci images is that it

00:07:17,440 --> 00:07:22,800
can be pushed and pulled

00:07:19,199 --> 00:07:24,560
to a registry much like docker images

00:07:22,800 --> 00:07:27,039
we provide webassembly hub as a

00:07:24,560 --> 00:07:29,280
community resource where you can sign up

00:07:27,039 --> 00:07:30,960
for free and push and pull your images

00:07:29,280 --> 00:07:32,720
too

00:07:30,960 --> 00:07:35,360
so the next step in the workflow would

00:07:32,720 --> 00:07:38,080
be to push this image to a registry

00:07:35,360 --> 00:07:40,319
in this example to webassembly hub to

00:07:38,080 --> 00:07:43,440
make it available later

00:07:40,319 --> 00:07:45,199
to be pulled into the cluster much like

00:07:43,440 --> 00:07:47,680
you're doing today with your docker

00:07:45,199 --> 00:07:47,680
images

00:07:48,879 --> 00:07:53,759
in order to facilitate that we created

00:07:50,960 --> 00:07:57,120
the wasan artifact image specification

00:07:53,759 --> 00:07:58,400
which specifies how to package a wasan

00:07:57,120 --> 00:08:01,599
binary into an

00:07:58,400 --> 00:08:02,080
oci image so that glue mesh and other

00:08:01,599 --> 00:08:05,360
tools

00:08:02,080 --> 00:08:07,759
know how to retrieve it and send it to

00:08:05,360 --> 00:08:07,759
android

00:08:08,479 --> 00:08:15,280
the way glue mesh sends

00:08:12,000 --> 00:08:17,360
the extension to envoy is using

00:08:15,280 --> 00:08:20,479
what's called an envoy an extension

00:08:17,360 --> 00:08:23,680
config discovery service

00:08:20,479 --> 00:08:24,560
this allows us to configure onward to

00:08:23,680 --> 00:08:27,039
grab

00:08:24,560 --> 00:08:28,080
additional extensions like web assembly

00:08:27,039 --> 00:08:31,199
filters

00:08:28,080 --> 00:08:34,000
from a separate control plane

00:08:31,199 --> 00:08:35,919
separating the life cycle of regular

00:08:34,000 --> 00:08:39,279
mesh configuration

00:08:35,919 --> 00:08:42,159
and your webassembly filter

00:08:39,279 --> 00:08:43,599
in this example we use we use mesh ctl

00:08:42,159 --> 00:08:46,640
wasam deploy

00:08:43,599 --> 00:08:49,760
to create a filter deployment crd that

00:08:46,640 --> 00:08:52,640
glue mesh will then uh use

00:08:49,760 --> 00:08:53,760
to create an android filter ico cd to

00:08:52,640 --> 00:08:57,040
inject

00:08:53,760 --> 00:08:58,320
this ecds extension onto onboard anway

00:08:57,040 --> 00:09:01,600
subsequently

00:08:58,320 --> 00:09:04,640
will contact bluemesh and get the

00:09:01,600 --> 00:09:07,040
wasan binary and will load it and

00:09:04,640 --> 00:09:08,560
activate it on the request path this

00:09:07,040 --> 00:09:11,760
request injects

00:09:08,560 --> 00:09:15,120
the filter that we just built and pushed

00:09:11,760 --> 00:09:16,480
into the app rating workload in a

00:09:15,120 --> 00:09:19,680
cluster called

00:09:16,480 --> 00:09:22,720
management cluster

00:09:19,680 --> 00:09:23,839
the last step as far as development goes

00:09:22,720 --> 00:09:26,000
is we may want to do

00:09:23,839 --> 00:09:27,440
source level debugging and that's not

00:09:26,000 --> 00:09:29,360
something that we currently have but

00:09:27,440 --> 00:09:31,440
it's something we're working on

00:09:29,360 --> 00:09:33,519
and it is to provide a message yell

00:09:31,440 --> 00:09:36,640
debug command that will allow you

00:09:33,519 --> 00:09:40,000
to source level debug your filter

00:09:36,640 --> 00:09:43,040
as you are developing it

00:09:40,000 --> 00:09:46,480
and with that let's see a quick demo

00:09:43,040 --> 00:09:51,440
that shows all the commands we took

00:09:46,480 --> 00:09:53,519
up until now used in practice

00:09:51,440 --> 00:09:55,920
all right let's see a quick demo for the

00:09:53,519 --> 00:09:57,040
wasam developer experience with glue

00:09:55,920 --> 00:09:59,760
mesh

00:09:57,040 --> 00:10:02,079
so first of all on the left side of the

00:09:59,760 --> 00:10:04,480
screen you can see the glue mesh console

00:10:02,079 --> 00:10:06,560
it gives you a nice overview of your

00:10:04,480 --> 00:10:07,040
deployment status if we drill down to

00:10:06,560 --> 00:10:08,800
the

00:10:07,040 --> 00:10:11,279
meshes tab you can see that we have two

00:10:08,800 --> 00:10:12,880
cluster management cluster in the remote

00:10:11,279 --> 00:10:15,440
cluster and they're connected with a

00:10:12,880 --> 00:10:17,760
single virtual mesh

00:10:15,440 --> 00:10:19,440
and you can see the various traffic

00:10:17,760 --> 00:10:21,040
target workloads

00:10:19,440 --> 00:10:23,040
and possibly kind of a high level

00:10:21,040 --> 00:10:25,440
overview of what's going on you can also

00:10:23,040 --> 00:10:29,040
drill down to the policy tab to see

00:10:25,440 --> 00:10:33,279
specific policies now we have

00:10:29,040 --> 00:10:35,519
added a wasm plugin into the mesh ctl

00:10:33,279 --> 00:10:38,160
command line mesh ctl is the command

00:10:35,519 --> 00:10:40,959
line that comes along with glue mesh

00:10:38,160 --> 00:10:41,600
we've added what the capabilities of

00:10:40,959 --> 00:10:45,279
wasmi

00:10:41,600 --> 00:10:48,000
to mesh ctl using the wasam plugin

00:10:45,279 --> 00:10:49,760
and let's see how the developer workflow

00:10:48,000 --> 00:10:53,360
for deploying a wasm

00:10:49,760 --> 00:10:54,160
extension to the mesh works so the first

00:10:53,360 --> 00:10:57,200
thing we'll do

00:10:54,160 --> 00:10:59,839
we'll start with mesh ctl wasm in it

00:10:57,200 --> 00:11:01,760
we'll give it the name of the filter we

00:10:59,839 --> 00:11:04,160
want to create and the language in this

00:11:01,760 --> 00:11:07,680
case rust

00:11:04,160 --> 00:11:09,680
this extracts a template for an easy

00:11:07,680 --> 00:11:11,440
getting started experience so let's

00:11:09,680 --> 00:11:13,360
open up the code and see what we're

00:11:11,440 --> 00:11:15,040
working with

00:11:13,360 --> 00:11:16,640
as you can see in this example we

00:11:15,040 --> 00:11:19,040
implement the http

00:11:16,640 --> 00:11:20,399
response header so this method will be

00:11:19,040 --> 00:11:23,760
called every time

00:11:20,399 --> 00:11:24,800
an http requested made the response is

00:11:23,760 --> 00:11:27,519
returned

00:11:24,800 --> 00:11:28,399
and as the response headers are returned

00:11:27,519 --> 00:11:30,880
this

00:11:28,399 --> 00:11:32,880
function here will be called and in this

00:11:30,880 --> 00:11:35,200
case what we can see we have a few lines

00:11:32,880 --> 00:11:38,959
just to make it a bit more interesting

00:11:35,200 --> 00:11:41,360
and it sets a response header hello

00:11:38,959 --> 00:11:42,160
and with the default value world plus

00:11:41,360 --> 00:11:45,519
this number

00:11:42,160 --> 00:11:48,079
which comes out to be one all right so

00:11:45,519 --> 00:11:50,639
now that we have the code we want to

00:11:48,079 --> 00:11:52,240
the next step would be to build this

00:11:50,639 --> 00:11:54,320
filter into a wasa

00:11:52,240 --> 00:11:55,360
binary we have a command for that as

00:11:54,320 --> 00:11:58,320
well so

00:11:55,360 --> 00:11:58,720
messy dl build we tell it the language

00:11:58,320 --> 00:12:00,480
so

00:11:58,720 --> 00:12:02,160
it can select the right tool chain to

00:12:00,480 --> 00:12:05,519
build with

00:12:02,160 --> 00:12:08,959
we tell it how to tag the resulting

00:12:05,519 --> 00:12:11,839
wasn't filter and in our case this

00:12:08,959 --> 00:12:12,800
wasn't filler will be packaged as an oci

00:12:11,839 --> 00:12:16,079
image

00:12:12,800 --> 00:12:18,079
that will be sent or pushed uh in the

00:12:16,079 --> 00:12:18,800
next step to webassembly hub so we give

00:12:18,079 --> 00:12:21,040
it

00:12:18,800 --> 00:12:22,680
an image name that contains webassembly

00:12:21,040 --> 00:12:24,160
hub and my username in webassembly

00:12:22,680 --> 00:12:27,120
webassemblyhub

00:12:24,160 --> 00:12:28,880
now this is very similar to how docker

00:12:27,120 --> 00:12:31,760
images work

00:12:28,880 --> 00:12:34,800
and lastly we give it the folder that

00:12:31,760 --> 00:12:37,040
contains the filter

00:12:34,800 --> 00:12:39,120
so building pulls in a container with

00:12:37,040 --> 00:12:42,399
build tools in this case it has

00:12:39,120 --> 00:12:45,760
a bazel and it's running and building

00:12:42,399 --> 00:12:48,880
the filter it's happening live so

00:12:45,760 --> 00:12:50,480
it'll take a minute i'll

00:12:48,880 --> 00:12:52,800
in the meantime i'll mention that after

00:12:50,480 --> 00:12:55,600
the filter is built

00:12:52,800 --> 00:12:56,320
the resulting wasam file will get

00:12:55,600 --> 00:12:59,360
packaged

00:12:56,320 --> 00:13:02,399
in an oci image

00:12:59,360 --> 00:13:04,800
that will be stored on your local

00:13:02,399 --> 00:13:06,000
machine and then in the next step what

00:13:04,800 --> 00:13:09,680
we'll do is actually

00:13:06,000 --> 00:13:13,760
push it to webassembly hub

00:13:09,680 --> 00:13:15,839
all right everything built successfully

00:13:13,760 --> 00:13:17,920
image was tagged everything looking good

00:13:15,839 --> 00:13:20,800
so let's move on to the next step

00:13:17,920 --> 00:13:22,720
mesh cdl push and what this does it's

00:13:20,800 --> 00:13:25,760
very similar to how docker push works

00:13:22,720 --> 00:13:28,399
it'll push this image from the local

00:13:25,760 --> 00:13:29,279
cache into webassembly hub io so it's

00:13:28,399 --> 00:13:32,639
available

00:13:29,279 --> 00:13:32,639
wherever it's needed next

00:13:32,880 --> 00:13:38,880
all right so far so good the image is

00:13:35,040 --> 00:13:41,519
pushed so let's move on to the next step

00:13:38,880 --> 00:13:42,160
and the next step is to deploy the image

00:13:41,519 --> 00:13:44,800
right so

00:13:42,160 --> 00:13:46,240
so far we have the limit the image in

00:13:44,800 --> 00:13:47,680
our local machine we have it in

00:13:46,240 --> 00:13:50,480
webassembly hub

00:13:47,680 --> 00:13:51,920
we need to get it to the service mesh

00:13:50,480 --> 00:13:54,160
right and in this case we'll use the

00:13:51,920 --> 00:13:55,279
message dl wasn't deploy command so you

00:13:54,160 --> 00:13:59,360
can see here

00:13:55,279 --> 00:14:03,440
messaging wasn't deployed to ico

00:13:59,360 --> 00:14:06,880
to our current management cluster

00:14:03,440 --> 00:14:09,040
the deployment that

00:14:06,880 --> 00:14:10,720
we want to create that's the filter

00:14:09,040 --> 00:14:11,760
deployment it's going to be the ed

00:14:10,720 --> 00:14:14,240
header

00:14:11,760 --> 00:14:16,720
this is the name of the crd that will be

00:14:14,240 --> 00:14:20,240
created to express

00:14:16,720 --> 00:14:21,920
the extension right so everything is

00:14:20,240 --> 00:14:24,079
managed with crds

00:14:21,920 --> 00:14:27,040
and the result of this command will be a

00:14:24,079 --> 00:14:30,639
crd that glue mesh will process

00:14:27,040 --> 00:14:34,079
and inject the filter

00:14:30,639 --> 00:14:35,360
the wasam extension into the workload so

00:14:34,079 --> 00:14:37,680
this is the name

00:14:35,360 --> 00:14:39,040
of the filter deployment crd that is

00:14:37,680 --> 00:14:40,959
about to be created

00:14:39,040 --> 00:14:42,800
we give it obviously the namespace and

00:14:40,959 --> 00:14:46,320
the image this is the image we

00:14:42,800 --> 00:14:49,279
just pushed to webassembly hub

00:14:46,320 --> 00:14:50,240
we give it the cluster because remember

00:14:49,279 --> 00:14:52,880
glue mesh can

00:14:50,240 --> 00:14:55,199
deploy this into multiple clusters so

00:14:52,880 --> 00:14:58,079
this is the cluster where we wanted

00:14:55,199 --> 00:15:00,079
the the filter to apply to and we give

00:14:58,079 --> 00:15:02,240
it the label of the workload

00:15:00,079 --> 00:15:03,279
that we want the filter to apply to so

00:15:02,240 --> 00:15:06,320
in this case

00:15:03,279 --> 00:15:08,320
to the ratings app in the cluster that

00:15:06,320 --> 00:15:12,000
is management cluster

00:15:08,320 --> 00:15:14,320
all right and let's deploy that

00:15:12,000 --> 00:15:16,079
so far so good and now that it's

00:15:14,320 --> 00:15:18,399
deployed you can see that if we'll go to

00:15:16,079 --> 00:15:20,560
the wasm tab in glue mesh

00:15:18,399 --> 00:15:22,480
you can see that there was some filter

00:15:20,560 --> 00:15:24,800
here as well

00:15:22,480 --> 00:15:26,240
so with with the ui we'd really try to

00:15:24,800 --> 00:15:30,399
give you a full

00:15:26,240 --> 00:15:34,800
360 view of what's happening in your

00:15:30,399 --> 00:15:36,240
service mesh all right next step

00:15:34,800 --> 00:15:38,079
we're going to test that it's actually

00:15:36,240 --> 00:15:40,800
working here

00:15:38,079 --> 00:15:42,639
is the step where i cross my fingers so

00:15:40,800 --> 00:15:45,199
what we're doing here is

00:15:42,639 --> 00:15:46,000
essentially x again to the product page

00:15:45,199 --> 00:15:47,839
pod

00:15:46,000 --> 00:15:49,680
and from the product page pod we're

00:15:47,839 --> 00:15:53,680
going to curl the ratings

00:15:49,680 --> 00:15:56,800
pod right in if everything works well

00:15:53,680 --> 00:15:58,959
we will see exactly the hello world one

00:15:56,800 --> 00:16:00,720
header now you'll notice that the header

00:15:58,959 --> 00:16:03,040
is lowercase here because

00:16:00,720 --> 00:16:04,639
with envoy all headers are normalized

00:16:03,040 --> 00:16:07,360
and are lowercase

00:16:04,639 --> 00:16:08,720
and the value is exactly world and one

00:16:07,360 --> 00:16:12,639
which is exactly what

00:16:08,720 --> 00:16:15,680
we expect it to be so so far

00:16:12,639 --> 00:16:17,519
everything is looking good so this is

00:16:15,680 --> 00:16:18,160
kind of the basic demo of what we have

00:16:17,519 --> 00:16:22,720
today

00:16:18,160 --> 00:16:26,639
for a full developer workflow starting

00:16:22,720 --> 00:16:28,800
from deploying a

00:16:26,639 --> 00:16:30,959
source code template that we can start

00:16:28,800 --> 00:16:33,440
working with making it easy

00:16:30,959 --> 00:16:34,160
building it into a wason filter with the

00:16:33,440 --> 00:16:37,680
correct

00:16:34,160 --> 00:16:40,959
build tools pushing it

00:16:37,680 --> 00:16:41,680
to a binary registry right an oci

00:16:40,959 --> 00:16:45,040
registry

00:16:41,680 --> 00:16:45,920
where the filter can be hosted and then

00:16:45,040 --> 00:16:48,000
pulling that

00:16:45,920 --> 00:16:49,360
to the cluster injecting it to our

00:16:48,000 --> 00:16:50,880
workload

00:16:49,360 --> 00:16:53,519
and these are all things that we have

00:16:50,880 --> 00:16:55,600
today and that you can experiment with

00:16:53,519 --> 00:16:57,040
now i would like to give a brief look

00:16:55,600 --> 00:16:58,720
into the future and this is not

00:16:57,040 --> 00:16:59,120
something we have just yet this is more

00:16:58,720 --> 00:17:00,880
of an

00:16:59,120 --> 00:17:02,839
illustration of our plans ahead and

00:17:00,880 --> 00:17:04,000
that's debugging and one of the

00:17:02,839 --> 00:17:06,959
challenges

00:17:04,000 --> 00:17:09,120
with web assembly is source level

00:17:06,959 --> 00:17:10,640
debugging it's not something that's easy

00:17:09,120 --> 00:17:14,319
to do today especially not in

00:17:10,640 --> 00:17:16,799
envoy so for this demo we prepared on

00:17:14,319 --> 00:17:18,720
an example on how we think this is going

00:17:16,799 --> 00:17:20,160
to look like

00:17:18,720 --> 00:17:22,480
and the way it's going to work we're

00:17:20,160 --> 00:17:23,839
going to add an stl debug wasn't which

00:17:22,480 --> 00:17:27,280
will actually

00:17:23,839 --> 00:17:31,120
attach lodb to the envoy

00:17:27,280 --> 00:17:34,400
and using a special runtime

00:17:31,120 --> 00:17:35,520
can also source level debug the wasan

00:17:34,400 --> 00:17:38,400
filter itself

00:17:35,520 --> 00:17:39,840
so if we'll go here to my history of

00:17:38,400 --> 00:17:46,640
commands we can break

00:17:39,840 --> 00:17:48,400
on http response headers

00:17:46,640 --> 00:17:50,559
all right this is obviously unresolved

00:17:48,400 --> 00:17:54,400
because the filter is not loaded yet

00:17:50,559 --> 00:17:55,360
we hit run we let android loader now

00:17:54,400 --> 00:17:57,919
because this

00:17:55,360 --> 00:17:59,919
a wasam runtime needs to generate the

00:17:57,919 --> 00:18:02,080
debug symbol we'll take it a minute to

00:17:59,919 --> 00:18:02,080
run

00:18:04,720 --> 00:18:09,039
you can see it's still loading the

00:18:06,480 --> 00:18:12,799
listeners

00:18:09,039 --> 00:18:12,799
let's clear this screen oh here we go

00:18:12,840 --> 00:18:17,840
nevermind

00:18:14,480 --> 00:18:20,320
all right so

00:18:17,840 --> 00:18:22,799
and you can see that two locations were

00:18:20,320 --> 00:18:24,480
added to breakpoint one

00:18:22,799 --> 00:18:26,640
so now in order to trigger the

00:18:24,480 --> 00:18:28,160
breakpoint i obviously need some sort of

00:18:26,640 --> 00:18:30,880
a response so let me just

00:18:28,160 --> 00:18:32,080
curl localhost so i can get a request

00:18:30,880 --> 00:18:34,400
and a response

00:18:32,080 --> 00:18:36,400
and this is this this demo is for an

00:18:34,400 --> 00:18:37,520
envoy i'm i'm running locally as we

00:18:36,400 --> 00:18:40,880
mentioned it's not yet

00:18:37,520 --> 00:18:44,480
ready so let me

00:18:40,880 --> 00:18:47,520
kill that curl all right now we can see

00:18:44,480 --> 00:18:49,440
uh first breakpoint is just happened to

00:18:47,520 --> 00:18:51,919
be a function with the same name that we

00:18:49,440 --> 00:18:55,120
don't care about so let's continue

00:18:51,919 --> 00:18:57,360
we can see that we break exactly in this

00:18:55,120 --> 00:18:59,840
function with this code and we can step

00:18:57,360 --> 00:18:59,840
through it

00:19:00,480 --> 00:19:04,240
as we would any other program

00:19:06,080 --> 00:19:09,520
and obviously resume execution and that

00:19:08,240 --> 00:19:11,520
will allow us

00:19:09,520 --> 00:19:14,080
to use the tools that we're familiar

00:19:11,520 --> 00:19:17,440
with to also debug

00:19:14,080 --> 00:19:17,440
web assembly filters

00:19:17,600 --> 00:19:25,840
and that's all for the demo

00:19:26,240 --> 00:19:30,160
and with that i'll pass it on to shane

00:19:35,600 --> 00:19:39,840
let's go back here

00:19:40,799 --> 00:19:45,039
thanks you all so attaching a debugger

00:19:43,280 --> 00:19:46,640
is incredibly powerful and it's one of

00:19:45,039 --> 00:19:48,480
the most requested features that our

00:19:46,640 --> 00:19:49,840
users who are using wasm filters are

00:19:48,480 --> 00:19:51,280
asking for and we're really happy to be

00:19:49,840 --> 00:19:53,039
working on that

00:19:51,280 --> 00:19:54,880
but most of the time when you're working

00:19:53,039 --> 00:19:56,160
in an environment it's not a single mesh

00:19:54,880 --> 00:19:57,760
single cluster single service

00:19:56,160 --> 00:19:59,039
environment that's just easy to attach a

00:19:57,760 --> 00:20:00,480
single debugger to

00:19:59,039 --> 00:20:02,400
it usually looks something a little bit

00:20:00,480 --> 00:20:03,440
more like this you know you've got

00:20:02,400 --> 00:20:04,960
multiple clusters

00:20:03,440 --> 00:20:06,159
maybe you've got some load balancers and

00:20:04,960 --> 00:20:07,919
databases and all kinds of different

00:20:06,159 --> 00:20:09,919
infrastructure going on in there

00:20:07,919 --> 00:20:10,960
so let's look at a few tools that we

00:20:09,919 --> 00:20:12,960
have to help you

00:20:10,960 --> 00:20:14,720
debug and troubleshoot in production

00:20:12,960 --> 00:20:17,120
that are a little bit more suited to use

00:20:14,720 --> 00:20:17,120
at scale

00:20:19,440 --> 00:20:22,559
and with that this is a good time to

00:20:21,440 --> 00:20:24,080
start with a demo

00:20:22,559 --> 00:20:25,919
so this is what our demo environment

00:20:24,080 --> 00:20:28,000
looks like we've got two clusters

00:20:25,919 --> 00:20:29,360
they both have an istio mesh installed

00:20:28,000 --> 00:20:31,679
on them and

00:20:29,360 --> 00:20:32,480
each of them has about half of the istio

00:20:31,679 --> 00:20:34,080
book info

00:20:32,480 --> 00:20:35,120
example installed so the cluster on the

00:20:34,080 --> 00:20:36,400
left that which we're calling the

00:20:35,120 --> 00:20:38,720
management cluster

00:20:36,400 --> 00:20:41,120
has reviews v1 and v2 the cluster on the

00:20:38,720 --> 00:20:44,240
right has reviews v3 for example

00:20:41,120 --> 00:20:47,520
both clusters are managed by

00:20:44,240 --> 00:20:49,520
glue mesh in what we call a virtual mesh

00:20:47,520 --> 00:20:51,039
so it acts as one logical mesh which

00:20:49,520 --> 00:20:53,440
just makes it a little easier to

00:20:51,039 --> 00:20:54,880
to manage so let's jump right into the

00:20:53,440 --> 00:20:56,640
terminal here just to kind of see what

00:20:54,880 --> 00:20:58,080
this looks like i'm running canines here

00:20:56,640 --> 00:21:00,000
and you can see on the left we've got

00:20:58,080 --> 00:21:02,159
our management cluster and on the right

00:21:00,000 --> 00:21:03,600
we've got our remote cluster

00:21:02,159 --> 00:21:05,200
note that we've got some things running

00:21:03,600 --> 00:21:06,400
just in one cluster like product page

00:21:05,200 --> 00:21:09,120
and some things running on the second

00:21:06,400 --> 00:21:10,880
cluster like the details

00:21:09,120 --> 00:21:12,320
one thing i'd like to call attention to

00:21:10,880 --> 00:21:14,480
before we jump into our code editor is

00:21:12,320 --> 00:21:18,480
that we've got a wasm deployment here

00:21:14,480 --> 00:21:20,000
for our ratings um

00:21:18,480 --> 00:21:21,679
service where we're exposing some

00:21:20,000 --> 00:21:22,880
metrics i'm just taking a quick look at

00:21:21,679 --> 00:21:24,799
what this looks like

00:21:22,880 --> 00:21:26,640
you can see that we've defined our

00:21:24,799 --> 00:21:27,840
webassembly filter i've actually built

00:21:26,640 --> 00:21:29,360
and deployed and uploaded this to

00:21:27,840 --> 00:21:30,000
webassembly hub ahead of time just so we

00:21:29,360 --> 00:21:31,840
can save a little

00:21:30,000 --> 00:21:33,520
bit of time on the demo and you've

00:21:31,840 --> 00:21:35,280
already seen how all that works in our

00:21:33,520 --> 00:21:36,240
previous demo

00:21:35,280 --> 00:21:37,919
and then you can see here we've got a

00:21:36,240 --> 00:21:39,440
workload selector we can specify which

00:21:37,919 --> 00:21:41,520
clusters this is going to and then we've

00:21:39,440 --> 00:21:42,880
got a selector by app name

00:21:41,520 --> 00:21:44,559
so you can see this is going to all of

00:21:42,880 --> 00:21:45,760
the ratings apps in the book info name

00:21:44,559 --> 00:21:48,240
spaces across both

00:21:45,760 --> 00:21:48,240
clusters

00:21:50,960 --> 00:21:56,080
okay so jumping into the actual code

00:21:54,080 --> 00:21:59,440
here a bit now

00:21:56,080 --> 00:22:00,720
we can see that well i guess first let's

00:21:59,440 --> 00:22:03,039
start what does this

00:22:00,720 --> 00:22:04,559
filter do so this is a webassembly

00:22:03,039 --> 00:22:06,320
filter written in rust

00:22:04,559 --> 00:22:07,760
and it's it's pretty basic uh we're kind

00:22:06,320 --> 00:22:09,840
of using this as an example to show the

00:22:07,760 --> 00:22:13,200
different ways you can debug things but

00:22:09,840 --> 00:22:15,120
essentially it will par it will

00:22:13,200 --> 00:22:16,480
accumulate the body it'll buffer it as

00:22:15,120 --> 00:22:18,159
we're receiving the stream and then once

00:22:16,480 --> 00:22:19,120
we've got it all it'll parse it out into

00:22:18,159 --> 00:22:20,960
json

00:22:19,120 --> 00:22:22,799
uh if you're familiar with the istio

00:22:20,960 --> 00:22:24,159
book info app where because we have this

00:22:22,799 --> 00:22:26,400
on the rating service we're going to

00:22:24,159 --> 00:22:28,400
aggregate all of the ratings and

00:22:26,400 --> 00:22:30,559
determine what the average review out of

00:22:28,400 --> 00:22:32,080
five stars is

00:22:30,559 --> 00:22:33,919
so we're going to be discussing three

00:22:32,080 --> 00:22:35,200
different ways we can kind of debug here

00:22:33,919 --> 00:22:36,480
some of them are suitable for production

00:22:35,200 --> 00:22:37,679
some of them are more suitable for a

00:22:36,480 --> 00:22:39,600
development environment

00:22:37,679 --> 00:22:41,120
first let's talk about debug logs and

00:22:39,600 --> 00:22:42,400
this is one of those things that's a

00:22:41,120 --> 00:22:43,840
little bit more appropriate to use in a

00:22:42,400 --> 00:22:44,559
development environment maybe your local

00:22:43,840 --> 00:22:46,400
environment

00:22:44,559 --> 00:22:48,159
it's a very heavy tool and it has a

00:22:46,400 --> 00:22:48,960
performance impact but it can be really

00:22:48,159 --> 00:22:50,080
useful for

00:22:48,960 --> 00:22:51,360
especially the early stages of

00:22:50,080 --> 00:22:52,880
development development where you're

00:22:51,360 --> 00:22:54,080
trying to figure out exactly

00:22:52,880 --> 00:22:55,600
where something's going wrong and

00:22:54,080 --> 00:22:57,039
pinpoint exactly where a bug is running

00:22:55,600 --> 00:22:59,919
in a really advanced

00:22:57,039 --> 00:23:02,960
multi-cluster deployment so how this

00:22:59,919 --> 00:23:05,679
works is we just use the envoy abi

00:23:02,960 --> 00:23:07,360
which exposes a function called log and

00:23:05,679 --> 00:23:10,640
we're just passing at the

00:23:07,360 --> 00:23:11,200
log level of debug in this particular

00:23:10,640 --> 00:23:13,600
example

00:23:11,200 --> 00:23:15,760
we log once the request is received and

00:23:13,600 --> 00:23:16,559
we log the body once we have it and then

00:23:15,760 --> 00:23:20,640
finally

00:23:16,559 --> 00:23:24,480
we log the average reviews so we should

00:23:20,640 --> 00:23:24,480
see all of these in the debug logs

00:23:27,039 --> 00:23:32,080
so what does this actually look like

00:23:30,000 --> 00:23:34,400
let's jump back to our terminal here

00:23:32,080 --> 00:23:36,240
um okay so we can we can clear out the

00:23:34,400 --> 00:23:37,840
remote cluster get a little bit more

00:23:36,240 --> 00:23:38,960
space because we're kind of focusing on

00:23:37,840 --> 00:23:41,200
the cluster that has

00:23:38,960 --> 00:23:42,320
the glue mesh management plane installed

00:23:41,200 --> 00:23:44,720
on it just be aware that this is a

00:23:42,320 --> 00:23:46,960
multi-cluster environment

00:23:44,720 --> 00:23:48,720
so the first thing to enable logs on any

00:23:46,960 --> 00:23:50,640
envoy is that we need to

00:23:48,720 --> 00:23:52,240
crank up the log level in order to do

00:23:50,640 --> 00:23:54,559
that we will be

00:23:52,240 --> 00:23:56,240
interfacing with the admin api so to do

00:23:54,559 --> 00:24:00,240
that we have to expose

00:23:56,240 --> 00:24:02,159
port 15000 on the rating service

00:24:00,240 --> 00:24:05,840
and with that port exposed we're going

00:24:02,159 --> 00:24:05,840
to crank up the log levels

00:24:07,279 --> 00:24:10,559
and just to kind of show you how that

00:24:09,120 --> 00:24:11,760
works if you're not familiar with the

00:24:10,559 --> 00:24:14,320
envoy logging

00:24:11,760 --> 00:24:15,840
api we're just doing a simple post to

00:24:14,320 --> 00:24:17,600
slash logging and we're

00:24:15,840 --> 00:24:19,279
specifically cranking up the component

00:24:17,600 --> 00:24:21,679
wasn't to debug level

00:24:19,279 --> 00:24:22,960
so you can see here everything else all

00:24:21,679 --> 00:24:24,320
of the other components are still left

00:24:22,960 --> 00:24:27,919
at warning and then here at the bottom

00:24:24,320 --> 00:24:27,919
you can see wasm is up to debug

00:24:29,440 --> 00:24:32,720
now that wasm is at the debug level we

00:24:31,279 --> 00:24:36,400
can make a few requests

00:24:32,720 --> 00:24:38,880
so how this is going to work is we're

00:24:36,400 --> 00:24:40,400
going to exec execute a curl request

00:24:38,880 --> 00:24:43,039
from the product page

00:24:40,400 --> 00:24:44,480
going into the ratings page or the

00:24:43,039 --> 00:24:47,279
rating service i should say

00:24:44,480 --> 00:24:48,559
so this rating service is going to be

00:24:47,279 --> 00:24:50,159
the one that has our filter installed or

00:24:48,559 --> 00:24:53,360
it already has our filter installed

00:24:50,159 --> 00:24:54,080
once we do a few curls here you can see

00:24:53,360 --> 00:24:55,760
we get the

00:24:54,080 --> 00:24:57,360
the request back and then if we actually

00:24:55,760 --> 00:25:00,480
look at the logs here we should

00:24:57,360 --> 00:25:02,320
see our debug logs

00:25:00,480 --> 00:25:04,559
and because there are debug logs we can

00:25:02,320 --> 00:25:04,559
just

00:25:05,039 --> 00:25:09,520
get the logs directly with cube ctl i'm

00:25:07,919 --> 00:25:10,640
getting them specifically from the istio

00:25:09,520 --> 00:25:12,480
proxy pod

00:25:10,640 --> 00:25:13,679
and then i'm just going to grip wasm log

00:25:12,480 --> 00:25:14,799
because that's what all of our wasn't

00:25:13,679 --> 00:25:18,159
logs

00:25:14,799 --> 00:25:20,080
are prepended with the debug logs are

00:25:18,159 --> 00:25:23,120
obviously going to be very very verbose

00:25:20,080 --> 00:25:24,559
so we want to make sure that we are only

00:25:23,120 --> 00:25:26,960
looking at the wasn't ones for this

00:25:24,559 --> 00:25:26,960
example

00:25:27,120 --> 00:25:32,880
so here we can see our wasn't logs let's

00:25:30,240 --> 00:25:35,279
give a little bit more space here you

00:25:32,880 --> 00:25:35,919
can see on http response body which is

00:25:35,279 --> 00:25:38,559
what we

00:25:35,919 --> 00:25:40,000
saw previously in our code and then you

00:25:38,559 --> 00:25:42,000
can see the body gets printed out here

00:25:40,000 --> 00:25:43,039
this is the body of the response and

00:25:42,000 --> 00:25:44,640
finally you can see the

00:25:43,039 --> 00:25:46,559
review which we've calculated as part of

00:25:44,640 --> 00:25:47,440
our filter just jumping back to our

00:25:46,559 --> 00:25:50,640
filter real quick

00:25:47,440 --> 00:25:52,720
kind of tighten that together you can

00:25:50,640 --> 00:25:54,159
see on http response body which we just

00:25:52,720 --> 00:25:55,919
saw in our logs you can see the word

00:25:54,159 --> 00:25:56,400
bodies printed out the actual body

00:25:55,919 --> 00:25:58,720
itself

00:25:56,400 --> 00:26:01,440
and then finally down here you can see

00:25:58,720 --> 00:26:01,440
the log level

00:26:01,520 --> 00:26:05,039
so that's the first way in order in

00:26:03,600 --> 00:26:06,240
order for us to debug things in a

00:26:05,039 --> 00:26:08,799
complex environment

00:26:06,240 --> 00:26:10,320
again like i said debugging is

00:26:08,799 --> 00:26:10,559
definitely something that you want to do

00:26:10,320 --> 00:26:13,600
in

00:26:10,559 --> 00:26:16,320
a a local or dev environment it's not

00:26:13,600 --> 00:26:18,080
really well suited to use in production

00:26:16,320 --> 00:26:20,080
there is a performance impact so

00:26:18,080 --> 00:26:21,919
if you want to do more logging at the

00:26:20,080 --> 00:26:23,360
production level at high scale without

00:26:21,919 --> 00:26:25,200
impacting your performance

00:26:23,360 --> 00:26:26,640
how we do that is something called

00:26:25,200 --> 00:26:28,480
access logging

00:26:26,640 --> 00:26:30,320
so for access logging how it works in

00:26:28,480 --> 00:26:30,880
envoy is that it's a little interesting

00:26:30,320 --> 00:26:33,520
so we

00:26:30,880 --> 00:26:36,000
we set a property in our case we're

00:26:33,520 --> 00:26:37,840
calling it average reviews

00:26:36,000 --> 00:26:39,200
and the average reviews property is a

00:26:37,840 --> 00:26:42,240
filter state object

00:26:39,200 --> 00:26:44,320
that we're setting uh for envoy by

00:26:42,240 --> 00:26:47,440
itself it doesn't really do much but

00:26:44,320 --> 00:26:50,240
in in glue mesh we've created a crd

00:26:47,440 --> 00:26:52,080
called access log record which lets you

00:26:50,240 --> 00:26:53,279
configure at a fine grain level which

00:26:52,080 --> 00:26:54,880
workloads and

00:26:53,279 --> 00:26:56,720
in some cases even which headers to

00:26:54,880 --> 00:26:58,320
match so that you're only getting the

00:26:56,720 --> 00:26:59,600
logs that you really care about at any

00:26:58,320 --> 00:27:03,600
given time

00:26:59,600 --> 00:27:05,840
and we've exposed a api in our

00:27:03,600 --> 00:27:07,760
glue mesh enterprise networking pod

00:27:05,840 --> 00:27:10,480
which can expose exactly which logs you

00:27:07,760 --> 00:27:13,520
need to look at at any given time

00:27:10,480 --> 00:27:15,360
so what does this access log yaml look

00:27:13,520 --> 00:27:17,120
like how do we configure exactly what

00:27:15,360 --> 00:27:19,039
gets logged and what we want to look at

00:27:17,120 --> 00:27:20,640
so what we're going to do is take a

00:27:19,039 --> 00:27:22,720
quick look back in our terminal

00:27:20,640 --> 00:27:24,080
we're going to look at this access log

00:27:22,720 --> 00:27:25,919
record and this is the customer

00:27:24,080 --> 00:27:27,600
resource i was talking about earlier you

00:27:25,919 --> 00:27:29,360
can see here we're only applying it

00:27:27,600 --> 00:27:31,279
to requests on the path slash rating

00:27:29,360 --> 00:27:32,559
slash one we are applying it to both

00:27:31,279 --> 00:27:33,360
clusters and you know you could scale

00:27:32,559 --> 00:27:35,279
this up to

00:27:33,360 --> 00:27:38,080
however many clusters you have in inside

00:27:35,279 --> 00:27:40,159
of your infrastructure

00:27:38,080 --> 00:27:41,919
and what we need to do for this to to

00:27:40,159 --> 00:27:46,000
work is we need to

00:27:41,919 --> 00:27:47,679
expose the uh enterprise networking pods

00:27:46,000 --> 00:27:49,760
port 8080. so i'm just going to do that

00:27:47,679 --> 00:27:51,200
here

00:27:49,760 --> 00:27:53,919
that's because our enterprise networking

00:27:51,200 --> 00:27:54,880
pod exposes a glue mesh api for

00:27:53,919 --> 00:27:57,120
monitoring

00:27:54,880 --> 00:27:58,559
this for observability purposes we're

00:27:57,120 --> 00:28:00,000
then going to

00:27:58,559 --> 00:28:01,919
call that api which is the slash

00:28:00,000 --> 00:28:02,720
observability logs and we're going to

00:28:01,919 --> 00:28:04,960
watch it so

00:28:02,720 --> 00:28:06,399
this is a live stream that we're going

00:28:04,960 --> 00:28:07,919
to keep open

00:28:06,399 --> 00:28:10,399
and then finally we're just going to

00:28:07,919 --> 00:28:12,320
make a few more requests

00:28:10,399 --> 00:28:13,679
again same request we made earlier where

00:28:12,320 --> 00:28:17,440
it's from the product page

00:28:13,679 --> 00:28:20,880
to the ratings service

00:28:17,440 --> 00:28:20,880
so make a few requests here

00:28:21,120 --> 00:28:25,120
and then if we full screen this because

00:28:23,520 --> 00:28:26,399
we're running a little low on space

00:28:25,120 --> 00:28:28,240
you can see we're getting response code

00:28:26,399 --> 00:28:30,240
200 and we should have

00:28:28,240 --> 00:28:33,200
filter state objects in here so let's

00:28:30,240 --> 00:28:33,200
take a quick peek

00:28:35,279 --> 00:28:38,859
um

00:28:35,670 --> 00:28:38,859
[Music]

00:28:39,760 --> 00:28:42,480
maybe i shouldn't have said so many

00:28:41,200 --> 00:28:43,360
requests but here we go filter state

00:28:42,480 --> 00:28:47,039
objects

00:28:43,360 --> 00:28:49,440
so one thing to note is it is of bytes

00:28:47,039 --> 00:28:50,080
value here and that's because our wasm

00:28:49,440 --> 00:28:51,440
filter

00:28:50,080 --> 00:28:52,640
didn't actually know the data type when

00:28:51,440 --> 00:28:53,200
it was saving it we just saved it as

00:28:52,640 --> 00:28:54,480
bytes

00:28:53,200 --> 00:28:57,039
but it's worth noting you can see here

00:28:54,480 --> 00:28:59,120
that it's nc41 is the value

00:28:57,039 --> 00:29:01,480
and that's just the byte value so if i

00:28:59,120 --> 00:29:06,720
get out of this and then i do

00:29:01,480 --> 00:29:09,279
nc41 and just pipe it to base64 decode

00:29:06,720 --> 00:29:11,440
and echo that result back out again you

00:29:09,279 --> 00:29:13,120
can see that's 4.5 which is the 4.5

00:29:11,440 --> 00:29:14,080
stars average review that we calculated

00:29:13,120 --> 00:29:15,600
in our service

00:29:14,080 --> 00:29:17,760
so this is something that we've piped

00:29:15,600 --> 00:29:20,080
through from our filter that

00:29:17,760 --> 00:29:21,919
gets executed on the request path but

00:29:20,080 --> 00:29:24,640
it's handled by this access lock

00:29:21,919 --> 00:29:26,000
access logging architecture which is you

00:29:24,640 --> 00:29:28,399
know architected so that it can be

00:29:26,000 --> 00:29:29,440
run on the data path in production at

00:29:28,399 --> 00:29:30,880
scale without

00:29:29,440 --> 00:29:32,000
crippling your performance so this is

00:29:30,880 --> 00:29:33,520
this is really handy and this is

00:29:32,000 --> 00:29:36,880
something you can leave on in a real

00:29:33,520 --> 00:29:36,880
production environment which is great

00:29:38,080 --> 00:29:41,520
so lastly the last thing we're going to

00:29:39,600 --> 00:29:43,840
talk about is metrics

00:29:41,520 --> 00:29:46,320
so i'm going to jump back to the code

00:29:43,840 --> 00:29:48,880
for a sec

00:29:46,320 --> 00:29:50,480
and we already talked about our logging

00:29:48,880 --> 00:29:53,840
and we already talked about

00:29:50,480 --> 00:29:54,559
our access logging but the other thing

00:29:53,840 --> 00:29:56,159
that we've

00:29:54,559 --> 00:29:57,760
done in this filter is we've defined

00:29:56,159 --> 00:29:59,520
some custom metrics you can see up here

00:29:57,760 --> 00:30:03,279
in line 17 and 18.

00:29:59,520 --> 00:30:05,200
so we've got a metric for when the

00:30:03,279 --> 00:30:07,919
json that we're parsing in the filter is

00:30:05,200 --> 00:30:09,360
parsed okay which we're calling okay and

00:30:07,919 --> 00:30:10,480
then we've got one for when the pricing

00:30:09,360 --> 00:30:12,559
fails

00:30:10,480 --> 00:30:13,760
and they're defined up here at the top

00:30:12,559 --> 00:30:15,679
and then you can see down here where

00:30:13,760 --> 00:30:17,919
we're executing them

00:30:15,679 --> 00:30:19,279
if it's a success we're doing record

00:30:17,919 --> 00:30:21,440
metric metric okay

00:30:19,279 --> 00:30:22,799
and then right here at the bottom when

00:30:21,440 --> 00:30:24,640
it's a failure we're going to record a

00:30:22,799 --> 00:30:26,080
failure

00:30:24,640 --> 00:30:27,919
and the great thing about these metrics

00:30:26,080 --> 00:30:28,799
is that they're exposed as your standard

00:30:27,919 --> 00:30:31,120
envoy metrics

00:30:28,799 --> 00:30:31,919
so if we jump back to our terminal here

00:30:31,120 --> 00:30:34,840
let's just

00:30:31,919 --> 00:30:37,840
exit some of these guys and get more

00:30:34,840 --> 00:30:37,840
space

00:30:38,559 --> 00:30:42,080
we don't need that port forward anymore

00:30:42,880 --> 00:30:46,240
okay so we should be able to curl

00:30:44,159 --> 00:30:47,840
localhost 15000

00:30:46,240 --> 00:30:49,440
stats and then we're just going to grab

00:30:47,840 --> 00:30:52,000
for debug

00:30:49,440 --> 00:30:53,200
filter which is part of our stats so you

00:30:52,000 --> 00:30:54,480
can see here we've got two error

00:30:53,200 --> 00:30:55,760
requests recorded and 10

00:30:54,480 --> 00:30:57,600
okay requests and these are the two

00:30:55,760 --> 00:31:00,720
metrics that we define in our filter

00:30:57,600 --> 00:31:04,720
if for example i make a good request

00:31:00,720 --> 00:31:06,240
to ratings v1

00:31:04,720 --> 00:31:08,399
and then i look at these stats again you

00:31:06,240 --> 00:31:11,519
can see it's gone from 10 to 11.

00:31:08,399 --> 00:31:13,440
similarly if i make a request to a bad

00:31:11,519 --> 00:31:16,880
url that's not the accepted ratings

00:31:13,440 --> 00:31:19,039
one and then we look at the stats again

00:31:16,880 --> 00:31:20,640
you can see it's gone from two to three

00:31:19,039 --> 00:31:22,080
and the great thing about these metrics

00:31:20,640 --> 00:31:23,840
is that they're first-class citizens in

00:31:22,080 --> 00:31:24,320
unvoiced stats so you can export these

00:31:23,840 --> 00:31:26,720
to

00:31:24,320 --> 00:31:28,320
prometheus you can get them in a grafana

00:31:26,720 --> 00:31:29,760
dashboard where you can set up alerting

00:31:28,320 --> 00:31:30,320
on them depending on how important they

00:31:29,760 --> 00:31:31,679
are

00:31:30,320 --> 00:31:32,799
you know this is just a really powerful

00:31:31,679 --> 00:31:34,159
tool especially for something in

00:31:32,799 --> 00:31:35,919
production that you want to just keep an

00:31:34,159 --> 00:31:38,080
eye on and set alerting to this is this

00:31:35,919 --> 00:31:40,080
is great

00:31:38,080 --> 00:31:42,960
so in summary we've looked at how you

00:31:40,080 --> 00:31:44,480
can attach a debugger to do dev level

00:31:42,960 --> 00:31:46,320
debugging we've looked at how you can

00:31:44,480 --> 00:31:48,080
look at debugger logs

00:31:46,320 --> 00:31:49,919
inside of your filters we've also looked

00:31:48,080 --> 00:31:51,760
at more production appropriate use cases

00:31:49,919 --> 00:31:52,799
like access logging and metrics which

00:31:51,760 --> 00:31:55,440
you can use

00:31:52,799 --> 00:31:57,200
in your clusters at scale we've looked

00:31:55,440 --> 00:31:58,880
at the entire life cycle of a wasm

00:31:57,200 --> 00:31:59,120
filter of how you can go about building

00:31:58,880 --> 00:32:01,279
it

00:31:59,120 --> 00:32:02,480
how you can publish it to a registry how

00:32:01,279 --> 00:32:04,080
you can discover

00:32:02,480 --> 00:32:05,679
filters that other people have written

00:32:04,080 --> 00:32:07,039
and published up to the registry

00:32:05,679 --> 00:32:09,120
and how you can deploy it across your

00:32:07,039 --> 00:32:10,320
cluster we've highlighted the ease of

00:32:09,120 --> 00:32:11,760
use of all of this throughout the

00:32:10,320 --> 00:32:13,039
ecosystem as well as the various

00:32:11,760 --> 00:32:14,720
languages you can use to write these

00:32:13,039 --> 00:32:16,159
filters in

00:32:14,720 --> 00:32:17,519
and we've shown you that we've given you

00:32:16,159 --> 00:32:21,200
the tools of how to do this in a

00:32:17,519 --> 00:32:21,200
multi-cluster multi-mesh environment

00:32:21,919 --> 00:32:25,120
thanks very much for listening to our

00:32:23,440 --> 00:32:28,840
talk if you want to learn more please

00:32:25,120 --> 00:32:31,840
check out solo.i o or webassemblyhub.io

00:32:28,840 --> 00:32:31,840

YouTube URL: https://www.youtube.com/watch?v=Ax5J_5fGFJk


