Title: Lightning Talk: Migrating from JS to WASM in production and living to tell the ta... Corentin Godeau
Publication date: 2021-05-04
Playlist: Cloud Native Wasm Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Lightning Talk: Migrating from JS to WASM in production and living to tell the tale - Corentin Godeau, Lumen 

Here at Lumen, we develop software to help video streaming platforms scale to millions of viewers and provide top-notch quality to audiences. As video streaming soared last year, we embarked on a journey to improve the performance of one of our core offerings - a client-side CDN load balancer. In this talk, we explain how we migrated our legacy JavaScript codebase into C++ targeting WASM for the web. We discuss how we overcame the differences in paradigm between JS and WASM. We explore the constraints WASM presented when ensuring compatibility with native and how that shaped our code architecture. We also look at the tooling we used to debug the code that went into production and share some practical insights into memory management and the battle scars that you can avoid if you plan to take on this kind of project yourself.
Captions: 
	00:00:01,120 --> 00:00:05,600
hi everyone my name is coron tangodo i'm

00:00:03,679 --> 00:00:06,240
a compatibility software engineer at

00:00:05,600 --> 00:00:08,480
human

00:00:06,240 --> 00:00:10,080
and i will be presenting how we migrated

00:00:08,480 --> 00:00:11,679
from javascript to wasm

00:00:10,080 --> 00:00:13,200
and successfully deployed it in

00:00:11,679 --> 00:00:15,360
production

00:00:13,200 --> 00:00:17,279
first let me set the context in this

00:00:15,360 --> 00:00:19,199
talk i will talk about the differences

00:00:17,279 --> 00:00:20,640
that exist between running wasm and

00:00:19,199 --> 00:00:22,240
running javascript

00:00:20,640 --> 00:00:24,400
the differences that exist between

00:00:22,240 --> 00:00:25,680
compiling to wasm and compiling two

00:00:24,400 --> 00:00:27,599
native platforms

00:00:25,680 --> 00:00:30,800
and i will be giving some advice for

00:00:27,599 --> 00:00:33,280
your project based on our experience

00:00:30,800 --> 00:00:34,160
however i won't mention wasm outside of

00:00:33,280 --> 00:00:36,000
the browser

00:00:34,160 --> 00:00:38,160
and i want you to keep in mind that what

00:00:36,000 --> 00:00:38,960
i will be presenting is not a magical

00:00:38,160 --> 00:00:41,040
recipe

00:00:38,960 --> 00:00:43,200
it works in our case and is simply a

00:00:41,040 --> 00:00:45,680
feedback from our experience

00:00:43,200 --> 00:00:48,000
but first let me do a bit of history le

00:00:45,680 --> 00:00:50,079
mans formerly known as centurylink

00:00:48,000 --> 00:00:51,280
is a technology company providing

00:00:50,079 --> 00:00:54,320
infrastructures

00:00:51,280 --> 00:00:56,239
and platforms for companies one of our

00:00:54,320 --> 00:00:58,719
projects cdn mesh delivery

00:00:56,239 --> 00:00:59,680
leverages peer-to-peer technology to

00:00:58,719 --> 00:01:02,160
improve qos

00:00:59,680 --> 00:01:05,040
and reduce cdn bandwidth in the video

00:01:02,160 --> 00:01:07,680
delivery pipelines of our clients

00:01:05,040 --> 00:01:08,320
originally this product was web-based

00:01:07,680 --> 00:01:10,720
and thus

00:01:08,320 --> 00:01:12,080
written in javascript it has later been

00:01:10,720 --> 00:01:15,200
integrated in an ios

00:01:12,080 --> 00:01:16,720
and android sdk without being rewritten

00:01:15,200 --> 00:01:19,280
back then this decision was

00:01:16,720 --> 00:01:21,520
understandable but it was not a viable

00:01:19,280 --> 00:01:24,479
long-term solution this is why we

00:01:21,520 --> 00:01:26,640
decided to rewrite it from scratch

00:01:24,479 --> 00:01:29,119
talking about motivations here are

00:01:26,640 --> 00:01:31,439
additional key points that convey stats

00:01:29,119 --> 00:01:33,600
to migrate from javascript to c plus

00:01:31,439 --> 00:01:35,840
plus and target wasn't

00:01:33,600 --> 00:01:38,320
first we wanted to have a single code

00:01:35,840 --> 00:01:41,360
base targeting the majority of platforms

00:01:38,320 --> 00:01:43,040
including web then we wanted to be able

00:01:41,360 --> 00:01:44,000
to fully exploit the hardware

00:01:43,040 --> 00:01:46,960
capabilities

00:01:44,000 --> 00:01:49,280
of native platforms and finally some of

00:01:46,960 --> 00:01:51,840
our algorithms were pretty complex

00:01:49,280 --> 00:01:52,479
and compute intensive for the rest of

00:01:51,840 --> 00:01:54,240
this tool

00:01:52,479 --> 00:01:56,560
i want you to keep in mind the following

00:01:54,240 --> 00:01:58,799
assumptions our anterior code base

00:01:56,560 --> 00:02:00,880
is written in c plus plus and we chose

00:01:58,799 --> 00:02:02,560
the em script and toolchain to target

00:02:00,880 --> 00:02:04,960
wasm

00:02:02,560 --> 00:02:06,640
we don't target only wasm but also

00:02:04,960 --> 00:02:09,759
native platforms such as

00:02:06,640 --> 00:02:10,640
android and ios now that i did the

00:02:09,759 --> 00:02:13,200
introduction

00:02:10,640 --> 00:02:15,040
let's dive more on the technical side

00:02:13,200 --> 00:02:16,239
javascript and wasm have pretty

00:02:15,040 --> 00:02:18,239
different paradigms

00:02:16,239 --> 00:02:20,080
and here are the key differences between

00:02:18,239 --> 00:02:22,319
them on one side

00:02:20,080 --> 00:02:23,120
javascript is an interpreted high-level

00:02:22,319 --> 00:02:25,280
language

00:02:23,120 --> 00:02:27,040
strongly asynchronous and internally

00:02:25,280 --> 00:02:29,520
based on an event loop

00:02:27,040 --> 00:02:30,879
it's very popular and deeply integrated

00:02:29,520 --> 00:02:33,360
in modern browsers

00:02:30,879 --> 00:02:35,519
on the other side bosum is presented as

00:02:33,360 --> 00:02:36,239
the web equivalent of native assembly

00:02:35,519 --> 00:02:38,720
language

00:02:36,239 --> 00:02:40,879
thus it's very different from javascript

00:02:38,720 --> 00:02:43,280
it's a very low level language targeting

00:02:40,879 --> 00:02:44,720
a stack-based virtual machine

00:02:43,280 --> 00:02:46,959
it's designed to be called from

00:02:44,720 --> 00:02:48,560
javascript in synchronous manner

00:02:46,959 --> 00:02:50,879
these main differences have strong

00:02:48,560 --> 00:02:52,959
implications on how we should approach a

00:02:50,879 --> 00:02:54,640
code based design

00:02:52,959 --> 00:02:56,560
concerning the differences between

00:02:54,640 --> 00:02:57,840
compiling to wasm and compiling to

00:02:56,560 --> 00:03:00,239
native platforms

00:02:57,840 --> 00:03:01,120
here are the key differences due to the

00:03:00,239 --> 00:03:04,000
way that

00:03:01,120 --> 00:03:06,000
most javascript engines work a mismodel

00:03:04,000 --> 00:03:08,720
threaded and non-preemptive

00:03:06,000 --> 00:03:10,480
all caused wasn't function or blocking

00:03:08,720 --> 00:03:13,440
and must return before letting

00:03:10,480 --> 00:03:14,480
any other javascript code to execute on

00:03:13,440 --> 00:03:16,480
the contrary

00:03:14,480 --> 00:03:18,640
native platforms can be mondo or

00:03:16,480 --> 00:03:19,519
multi-threaded and are almost always

00:03:18,640 --> 00:03:21,760
preemptive

00:03:19,519 --> 00:03:23,519
meaning that threads of execution can

00:03:21,760 --> 00:03:25,920
stop in the middle of a function

00:03:23,519 --> 00:03:27,519
and continue execution later letting

00:03:25,920 --> 00:03:30,560
time for other processes

00:03:27,519 --> 00:03:32,080
to run as you can imagine this will also

00:03:30,560 --> 00:03:33,760
have strong implications

00:03:32,080 --> 00:03:35,200
on how you should approach your code

00:03:33,760 --> 00:03:36,959
based design

00:03:35,200 --> 00:03:38,720
in case you are wondering there are

00:03:36,959 --> 00:03:41,280
plans to make wasn't

00:03:38,720 --> 00:03:42,560
multi-threaded but we do not recommend

00:03:41,280 --> 00:03:44,560
using it now

00:03:42,560 --> 00:03:46,879
it relies on web workers and shared

00:03:44,560 --> 00:03:49,440
array buffers that have been disabled

00:03:46,879 --> 00:03:51,239
in most modern browsers due to the

00:03:49,440 --> 00:03:52,879
resonance spectrum and meltdown

00:03:51,239 --> 00:03:54,959
vulnerabilities

00:03:52,879 --> 00:03:55,920
also there are libraries such as the

00:03:54,959 --> 00:03:58,400
syncify

00:03:55,920 --> 00:03:59,840
integrated within em scriptin that lets

00:03:58,400 --> 00:04:02,480
you introduce um

00:03:59,840 --> 00:04:04,239
astroproduce calls to javascript inside

00:04:02,480 --> 00:04:06,560
wasn't function

00:04:04,239 --> 00:04:07,599
but be careful as it makes the output

00:04:06,560 --> 00:04:09,760
binary bigger

00:04:07,599 --> 00:04:10,959
twice as big in our case and also

00:04:09,760 --> 00:04:14,159
introduces a small

00:04:10,959 --> 00:04:15,760
overhead in terms of performance

00:04:14,159 --> 00:04:17,680
now that you have a clear understanding

00:04:15,760 --> 00:04:18,400
of the differences between our target

00:04:17,680 --> 00:04:20,239
platforms

00:04:18,400 --> 00:04:22,079
i will be giving some advice that

00:04:20,239 --> 00:04:23,440
successfully helped us deploying wasn't

00:04:22,079 --> 00:04:24,560
mean production

00:04:23,440 --> 00:04:26,960
let's start with the project

00:04:24,560 --> 00:04:28,240
architecture advanced in the case you

00:04:26,960 --> 00:04:30,560
have a modular design

00:04:28,240 --> 00:04:31,919
you want to have an agnostic interface

00:04:30,560 --> 00:04:35,120
and platform specific

00:04:31,919 --> 00:04:35,759
implementations that way uh you will you

00:04:35,120 --> 00:04:37,280
won't have

00:04:35,759 --> 00:04:38,880
to be aware of the platform you're

00:04:37,280 --> 00:04:41,919
running on when working

00:04:38,880 --> 00:04:42,800
on the core part of your project one way

00:04:41,919 --> 00:04:44,639
to achieve this

00:04:42,800 --> 00:04:47,199
is to leverage the power of your build

00:04:44,639 --> 00:04:48,720
system to automatically dispatch to the

00:04:47,199 --> 00:04:50,240
correct implementation

00:04:48,720 --> 00:04:52,960
depending on the platform you are

00:04:50,240 --> 00:04:53,919
compiling to here is an example from our

00:04:52,960 --> 00:04:55,440
code base

00:04:53,919 --> 00:04:58,000
this is the module that handles

00:04:55,440 --> 00:05:01,039
everything related to http cores

00:04:58,000 --> 00:05:03,039
as you can see our agnostic interface is

00:05:01,039 --> 00:05:04,080
uh has exposed headers in the include

00:05:03,039 --> 00:05:06,160
directory

00:05:04,080 --> 00:05:08,479
we have the common code in the command

00:05:06,160 --> 00:05:10,400
directory and you have one directory for

00:05:08,479 --> 00:05:11,120
the native platform such as android and

00:05:10,400 --> 00:05:13,680
ios

00:05:11,120 --> 00:05:15,199
and one directory for the web platform

00:05:13,680 --> 00:05:17,520
when compiling to wasm

00:05:15,199 --> 00:05:18,560
our build system automatically selects

00:05:17,520 --> 00:05:22,240
the web folder

00:05:18,560 --> 00:05:23,280
to build sources now under code based

00:05:22,240 --> 00:05:26,400
general design

00:05:23,280 --> 00:05:28,479
we suggest to to design your common apis

00:05:26,400 --> 00:05:30,240
with an asynchronous mindset

00:05:28,479 --> 00:05:32,320
this may seem strange since wasn't

00:05:30,240 --> 00:05:33,759
called a synchronous but disability

00:05:32,320 --> 00:05:35,039
resides in the fact that most

00:05:33,759 --> 00:05:35,600
interaction you will have with the

00:05:35,039 --> 00:05:37,759
browser

00:05:35,600 --> 00:05:38,639
and the javascript apis will be a

00:05:37,759 --> 00:05:40,639
synchronous

00:05:38,639 --> 00:05:42,479
you will be called back later with the

00:05:40,639 --> 00:05:44,320
result of what you asked for

00:05:42,479 --> 00:05:45,759
but first you need to return from the

00:05:44,320 --> 00:05:48,160
wasm function

00:05:45,759 --> 00:05:50,320
designing your apis around callbacks is

00:05:48,160 --> 00:05:52,400
a good way of achieving this goal

00:05:50,320 --> 00:05:54,880
please note that even if on native these

00:05:52,400 --> 00:05:56,960
apis behave in a synchronous manner

00:05:54,880 --> 00:05:58,319
it's not really an issue in practice and

00:05:56,960 --> 00:06:01,199
you want to add that to the more

00:05:58,319 --> 00:06:03,280
constrained platform

00:06:01,199 --> 00:06:05,120
still on the code based design aspect

00:06:03,280 --> 00:06:07,120
we'd suggest you to take inspiration

00:06:05,120 --> 00:06:08,960
from the actor model to design the main

00:06:07,120 --> 00:06:11,039
modules of your project

00:06:08,960 --> 00:06:12,560
in a nutshell the actor model is a way

00:06:11,039 --> 00:06:14,880
of designing your code base

00:06:12,560 --> 00:06:15,600
around the idea that each module has its

00:06:14,880 --> 00:06:17,600
own state

00:06:15,600 --> 00:06:19,120
and communicates with other modules

00:06:17,600 --> 00:06:20,880
using messages

00:06:19,120 --> 00:06:22,960
what made it really suited for our

00:06:20,880 --> 00:06:25,840
constraints is that it can easily

00:06:22,960 --> 00:06:26,800
be adapted to fully exploit the hardware

00:06:25,840 --> 00:06:28,800
capabilities

00:06:26,800 --> 00:06:30,000
of the various platforms we plan to

00:06:28,800 --> 00:06:32,319
target

00:06:30,000 --> 00:06:34,479
in our case we designed a task-based

00:06:32,319 --> 00:06:37,840
system that runs on schedulers

00:06:34,479 --> 00:06:40,240
each module has its own schedulers

00:06:37,840 --> 00:06:41,280
and schedules small tasks to get its

00:06:40,240 --> 00:06:43,440
work done

00:06:41,280 --> 00:06:45,280
on wasm if you look at the context you

00:06:43,440 --> 00:06:48,319
already have a scheduler for free

00:06:45,280 --> 00:06:49,759
the one from your browser each scheduler

00:06:48,319 --> 00:06:52,000
of each module

00:06:49,759 --> 00:06:52,880
will be multiplexed on the browser

00:06:52,000 --> 00:06:57,120
scheduler

00:06:52,880 --> 00:06:59,360
and will run on the main event loop

00:06:57,120 --> 00:07:01,360
the need for small tasks ensures that

00:06:59,360 --> 00:07:03,199
each module will have its time share

00:07:01,360 --> 00:07:04,639
and that we are not blocking the ui

00:07:03,199 --> 00:07:07,039
thread for too long

00:07:04,639 --> 00:07:08,479
on native each scheduler will be able to

00:07:07,039 --> 00:07:10,160
run on its own thread

00:07:08,479 --> 00:07:12,400
thus exploiting the full hardware

00:07:10,160 --> 00:07:14,560
capabilities of the platform

00:07:12,400 --> 00:07:16,319
furthermore the actual model approach

00:07:14,560 --> 00:07:18,720
will limit common issues

00:07:16,319 --> 00:07:19,840
encountered in multi-threaded programs

00:07:18,720 --> 00:07:23,039
such as data race

00:07:19,840 --> 00:07:24,080
and shared states now let's talk about

00:07:23,039 --> 00:07:26,479
debugging

00:07:24,080 --> 00:07:28,080
if you have the possibility to do so we

00:07:26,479 --> 00:07:30,639
strongly suggest you to do your

00:07:28,080 --> 00:07:32,160
debugging on native platforms

00:07:30,639 --> 00:07:33,840
even though the beginning was them on

00:07:32,160 --> 00:07:35,520
chrome is possible if you build your

00:07:33,840 --> 00:07:38,560
project with debug flags

00:07:35,520 --> 00:07:41,199
the support is still young not verbal

00:07:38,560 --> 00:07:42,479
and rely on an extension to work

00:07:41,199 --> 00:07:44,800
properly

00:07:42,479 --> 00:07:46,479
furthermore a lot of coconucy issues

00:07:44,800 --> 00:07:48,319
that your codebase could contain

00:07:46,479 --> 00:07:50,080
can't happen in wazoo due to the

00:07:48,319 --> 00:07:51,759
mono-threaded context

00:07:50,080 --> 00:07:53,919
if you are interested in knowing how to

00:07:51,759 --> 00:07:57,360
debug on chrome i put a link to an

00:07:53,919 --> 00:07:59,759
interesting article on this slide

00:07:57,360 --> 00:08:01,759
finally here is a small list of useful

00:07:59,759 --> 00:08:04,240
flags to use when compiling

00:08:01,759 --> 00:08:05,919
using gmc which is the em script and c

00:08:04,240 --> 00:08:08,400
and c plus plus compiler

00:08:05,919 --> 00:08:10,479
dash aussie to optimize for code size

00:08:08,400 --> 00:08:12,560
wasn't binary have the bad reputation

00:08:10,479 --> 00:08:15,199
of being bigger than their javascript

00:08:12,560 --> 00:08:16,960
equivalent and that's true in practice

00:08:15,199 --> 00:08:19,199
there's just profiling this will keep

00:08:16,960 --> 00:08:21,360
the function names in the output binary

00:08:19,199 --> 00:08:22,639
and let you do profiling on chrome using

00:08:21,360 --> 00:08:25,039
the dev tools

00:08:22,639 --> 00:08:26,479
dash dash memory profiler this will add

00:08:25,039 --> 00:08:28,400
an overlay to the page

00:08:26,479 --> 00:08:29,759
giving very interesting information on

00:08:28,400 --> 00:08:32,320
memory fragmentation

00:08:29,759 --> 00:08:33,519
biggest allocation set and most frequent

00:08:32,320 --> 00:08:36,000
allocation sites

00:08:33,519 --> 00:08:37,839
if memory footprint is a concern for you

00:08:36,000 --> 00:08:40,880
this will be very helpful

00:08:37,839 --> 00:08:42,640
and finally dash closure 1 this will

00:08:40,880 --> 00:08:44,880
enable the closure compiler

00:08:42,640 --> 00:08:48,160
to optimize the javascript blue code

00:08:44,880 --> 00:08:50,399
generated by em scripter

00:08:48,160 --> 00:08:52,000
in conclusion i present a few key points

00:08:50,399 --> 00:08:53,279
that help us successfully deploy the

00:08:52,000 --> 00:08:55,600
wasm in production

00:08:53,279 --> 00:08:58,080
but this list is far from exhaustive i

00:08:55,600 --> 00:09:00,640
simply kept the more important ones

00:08:58,080 --> 00:09:01,600
please keep in mind that wasm is still a

00:09:00,640 --> 00:09:03,760
very young target

00:09:01,600 --> 00:09:05,519
and thus moves really fast the

00:09:03,760 --> 00:09:06,480
unscripted documentation is not

00:09:05,519 --> 00:09:08,800
finalized

00:09:06,480 --> 00:09:10,720
and you will often have no other other

00:09:08,800 --> 00:09:12,720
choice than finding the correct solution

00:09:10,720 --> 00:09:15,360
by trial and errors

00:09:12,720 --> 00:09:17,440
also em scriptures offer a long list of

00:09:15,360 --> 00:09:18,480
flags and settings to help you during

00:09:17,440 --> 00:09:20,240
your development

00:09:18,480 --> 00:09:22,160
and i put the link to the corresponding

00:09:20,240 --> 00:09:24,399
documentation on this slide

00:09:22,160 --> 00:09:26,399
and finally we created a repository

00:09:24,399 --> 00:09:28,480
containing all the border parade code

00:09:26,399 --> 00:09:30,160
needed to start a multi-platform project

00:09:28,480 --> 00:09:31,839
targeting wasm

00:09:30,160 --> 00:09:33,360
if you have any questions on everything

00:09:31,839 --> 00:09:35,360
i just presented

00:09:33,360 --> 00:09:36,640
don't hesitate to contact me on my email

00:09:35,360 --> 00:09:38,640
address on twitter

00:09:36,640 --> 00:09:40,800
or directly on the repository i just

00:09:38,640 --> 00:09:42,480
linked before

00:09:40,800 --> 00:09:46,560
thank you for your attention and have a

00:09:42,480 --> 00:09:46,560

YouTube URL: https://www.youtube.com/watch?v=-BeHLr7HncY


