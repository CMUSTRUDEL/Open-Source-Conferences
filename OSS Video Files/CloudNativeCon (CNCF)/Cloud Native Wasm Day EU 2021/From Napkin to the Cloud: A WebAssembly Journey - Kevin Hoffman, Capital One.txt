Title: From Napkin to the Cloud: A WebAssembly Journey - Kevin Hoffman, Capital One
Publication date: 2021-05-04
Playlist: Cloud Native Wasm Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

From Napkin to the Cloud: A WebAssembly Journey - Kevin Hoffman, Capital One

WebAssembly is not only changing the way we build and deploy software, but it can improve every aspect of the developer experience from napkin sketch to deployment. In this session, Kevin takes you on a trip from application concept (the "napkin") all the way to production in the cloud (and beyond!). He will illustrate the process of building a full-featured, cloud-native application composed of polyglot actors (Rust and Go!) using the open source project wasmCloud. You'll learn how this journey changes for the better in so many ways simply by embracing the power and--even the limitations--of WebAssembly. You'll see how what you build in isolation on your workstation can grow in scale, performance, and resiliency, all without ever having to re-architect components, consume hard-to-use remote services, or recompile a complex chain of dependencies. Ship your napkin to production!
Captions: 
	00:00:01,680 --> 00:00:06,799
all right well thank you for

00:00:04,000 --> 00:00:09,839
attending from napkin to the cloud a

00:00:06,799 --> 00:00:09,839
webassembly journey

00:00:13,519 --> 00:00:19,199
now first i want to take a quick detour

00:00:16,960 --> 00:00:20,480
and explain a little bit of who i am and

00:00:19,199 --> 00:00:23,279
why i'm doing this

00:00:20,480 --> 00:00:24,240
i created the open source project

00:00:23,279 --> 00:00:26,240
wasmcloud

00:00:24,240 --> 00:00:30,400
and i'm also the author of programming

00:00:26,240 --> 00:00:33,440
webassembly and rust

00:00:30,400 --> 00:00:36,480
so what i want to talk about today is

00:00:33,440 --> 00:00:40,079
a journey from

00:00:36,480 --> 00:00:42,000
design to production and

00:00:40,079 --> 00:00:43,280
i want to comment on how that's

00:00:42,000 --> 00:00:45,440
different

00:00:43,280 --> 00:00:46,640
when using webassembly as the underlying

00:00:45,440 --> 00:00:48,800
technology

00:00:46,640 --> 00:00:49,680
to do that first i want to start off

00:00:48,800 --> 00:00:51,840
with a real quick

00:00:49,680 --> 00:00:54,960
two-minute tour of what webassembly is

00:00:51,840 --> 00:00:56,879
and what asmcloud is

00:00:54,960 --> 00:00:59,039
and i'll talk about the application that

00:00:56,879 --> 00:01:00,960
we're going to build and that i have

00:00:59,039 --> 00:01:04,320
built for this demo

00:01:00,960 --> 00:01:05,600
what the conceptual design is and

00:01:04,320 --> 00:01:07,920
then we'll talk about the actual

00:01:05,600 --> 00:01:08,479
building and in this case i'll show some

00:01:07,920 --> 00:01:11,360
code

00:01:08,479 --> 00:01:12,479
and i'll compare and contrast the

00:01:11,360 --> 00:01:14,320
difference between

00:01:12,479 --> 00:01:15,759
what i designed and what we ended up

00:01:14,320 --> 00:01:18,880
building

00:01:15,759 --> 00:01:19,680
and the point there is to see if if

00:01:18,880 --> 00:01:22,880
there is a

00:01:19,680 --> 00:01:23,840
noticeable gap between the two and then

00:01:22,880 --> 00:01:25,439
i'll

00:01:23,840 --> 00:01:28,640
take you through a demo of the

00:01:25,439 --> 00:01:28,640
application that we built

00:01:29,040 --> 00:01:34,479
and then finally there is a q a period

00:01:31,680 --> 00:01:34,479
at the end of the session

00:01:34,720 --> 00:01:40,159
so quick tour of webassembly in the

00:01:38,840 --> 00:01:41,439
cloud

00:01:40,159 --> 00:01:43,360
there's a couple things that we

00:01:41,439 --> 00:01:45,200
typically want in our cloud native

00:01:43,360 --> 00:01:45,920
workloads whether we've been using

00:01:45,200 --> 00:01:48,560
docker

00:01:45,920 --> 00:01:49,680
or we've been just straight up running

00:01:48,560 --> 00:01:50,880
processes

00:01:49,680 --> 00:01:52,880
there are a number of things that are

00:01:50,880 --> 00:01:56,880
fairly common needs that we have

00:01:52,880 --> 00:02:00,640
such as security predictability speed

00:01:56,880 --> 00:02:05,360
and size and by size i mean

00:02:00,640 --> 00:02:05,360
lack of size we want small workloads

00:02:06,840 --> 00:02:11,680
and coincidentally what we get from

00:02:09,440 --> 00:02:12,000
webassembly is a number of those things

00:02:11,680 --> 00:02:14,959
so

00:02:12,000 --> 00:02:16,160
webassembly is secure it's predictable

00:02:14,959 --> 00:02:18,319
it's fast

00:02:16,160 --> 00:02:20,239
webassembly modules are small and i'll

00:02:18,319 --> 00:02:21,680
show during the demo just how small that

00:02:20,239 --> 00:02:24,800
can be

00:02:21,680 --> 00:02:27,840
it's portable webassembly can

00:02:24,800 --> 00:02:29,599
free us from dependency hell and

00:02:27,840 --> 00:02:32,239
it has what i like to refer to as

00:02:29,599 --> 00:02:34,160
beneficial limitations which means

00:02:32,239 --> 00:02:36,080
there are things that you can't do in

00:02:34,160 --> 00:02:38,480
webassembly that you can do freely

00:02:36,080 --> 00:02:41,280
in other environments and i think that's

00:02:38,480 --> 00:02:41,280
actually a good thing

00:02:42,000 --> 00:02:46,319
so if we get all these things from

00:02:44,080 --> 00:02:48,480
webassembly and there is this great

00:02:46,319 --> 00:02:48,720
overlap between what webassembly gives

00:02:48,480 --> 00:02:51,200
us

00:02:48,720 --> 00:02:53,280
and what we want in our cloud native

00:02:51,200 --> 00:02:54,959
workloads then

00:02:53,280 --> 00:02:56,319
maybe we should explore using

00:02:54,959 --> 00:02:59,519
webassembly for

00:02:56,319 --> 00:02:59,519
cloud native workloads

00:02:59,920 --> 00:03:03,200
so web assembly is a stack based virtual

00:03:02,159 --> 00:03:05,200
machine

00:03:03,200 --> 00:03:07,360
and without going into too much details

00:03:05,200 --> 00:03:09,760
that just refers to

00:03:07,360 --> 00:03:11,440
how that virtual machine processes its

00:03:09,760 --> 00:03:13,680
instructions

00:03:11,440 --> 00:03:15,599
the important point though is that it is

00:03:13,680 --> 00:03:18,720
a virtual machine

00:03:15,599 --> 00:03:22,239
it's a binary file format that has

00:03:18,720 --> 00:03:25,599
a text representation as well

00:03:22,239 --> 00:03:28,319
webassembly is cpu agnostic

00:03:25,599 --> 00:03:29,680
it's operating system agnostic the

00:03:28,319 --> 00:03:32,959
modules are

00:03:29,680 --> 00:03:35,040
fast small efficient and

00:03:32,959 --> 00:03:36,640
this is probably the the key point here

00:03:35,040 --> 00:03:38,319
which is that they're entirely dependent

00:03:36,640 --> 00:03:41,280
on the host runtime

00:03:38,319 --> 00:03:42,080
so in the case of a web browser the host

00:03:41,280 --> 00:03:45,599
runtime

00:03:42,080 --> 00:03:46,000
is some kind of javascript engine so in

00:03:45,599 --> 00:03:49,280
chrome

00:03:46,000 --> 00:03:51,680
it might be v8 and so on but in the

00:03:49,280 --> 00:03:55,760
browser your host runtime

00:03:51,680 --> 00:03:57,360
is done through javascript

00:03:55,760 --> 00:03:58,799
when you're outside the browser there

00:03:57,360 --> 00:04:00,000
are a number of different web assembly

00:03:58,799 --> 00:04:03,280
host runtimes available

00:04:00,000 --> 00:04:04,879
to us we have wasmtime

00:04:03,280 --> 00:04:07,519
from the vitacone alliance we have

00:04:04,879 --> 00:04:10,319
wasmer wasm 3 which is a

00:04:07,519 --> 00:04:11,920
popular sea based library that also has

00:04:10,319 --> 00:04:13,599
rust bindings

00:04:11,920 --> 00:04:15,599
and then we have a higher level

00:04:13,599 --> 00:04:16,880
libraries that build on top of engines

00:04:15,599 --> 00:04:20,160
like that

00:04:16,880 --> 00:04:23,120
specifically wasn't cloud and

00:04:20,160 --> 00:04:24,479
this may be a controversial bullet point

00:04:23,120 --> 00:04:26,880
here but i firmly believe

00:04:24,479 --> 00:04:29,840
that web assembly is the future of

00:04:26,880 --> 00:04:29,840
distributed computing

00:04:30,800 --> 00:04:34,639
so wisem cloud ryzen cloud is an open

00:04:33,520 --> 00:04:37,680
source project

00:04:34,639 --> 00:04:40,240
that i started probably a little over a

00:04:37,680 --> 00:04:43,280
year and a half ago

00:04:40,240 --> 00:04:45,759
based on these assumptions here which is

00:04:43,280 --> 00:04:46,639
if we want all of these things from our

00:04:45,759 --> 00:04:48,880
cloud native

00:04:46,639 --> 00:04:50,479
workloads and webassembly can give them

00:04:48,880 --> 00:04:52,400
to us then

00:04:50,479 --> 00:04:53,919
maybe there's an open source project

00:04:52,400 --> 00:04:56,080
that can create the

00:04:53,919 --> 00:04:58,160
tooling and host runtimes to bridging

00:04:56,080 --> 00:05:01,840
that gap and to give us what we need

00:04:58,160 --> 00:05:04,720
so wisely cloud is an actor runtime

00:05:01,840 --> 00:05:06,160
and for those that are familiar with it

00:05:04,720 --> 00:05:08,240
that just means that it

00:05:06,160 --> 00:05:10,080
it treats webassembly workloads as

00:05:08,240 --> 00:05:12,400
though they're actors as part of the

00:05:10,080 --> 00:05:16,400
actor pattern

00:05:12,400 --> 00:05:17,759
wasmcloud is it makes it so that your

00:05:16,400 --> 00:05:20,960
portable business logic

00:05:17,759 --> 00:05:21,520
runs anywhere so that could be at the

00:05:20,960 --> 00:05:24,560
edge

00:05:21,520 --> 00:05:28,240
in the cloud on iot devices and

00:05:24,560 --> 00:05:29,120
also in the browser asm cloud is secure

00:05:28,240 --> 00:05:31,520
by default

00:05:29,120 --> 00:05:33,360
and in the demo i'll show a little bit

00:05:31,520 --> 00:05:36,080
of how that security works

00:05:33,360 --> 00:05:37,360
it eliminates boilerplate we want to

00:05:36,080 --> 00:05:40,960
strip off

00:05:37,360 --> 00:05:42,960
all of the code that we write

00:05:40,960 --> 00:05:44,720
day in and day out in service of

00:05:42,960 --> 00:05:46,400
boilerplate that really has nothing to

00:05:44,720 --> 00:05:50,160
do with our business logic

00:05:46,400 --> 00:05:52,479
and our true functional requirements

00:05:50,160 --> 00:05:54,320
wisemcloud supports a rapid feedback

00:05:52,479 --> 00:05:56,400
loop we have a rebel in one of our

00:05:54,320 --> 00:05:59,440
command line tools

00:05:56,400 --> 00:06:00,319
uh wasmcloud also provides a

00:05:59,440 --> 00:06:02,560
self-healing

00:06:00,319 --> 00:06:05,199
self-forming mesh called the lattice

00:06:02,560 --> 00:06:08,400
that connects

00:06:05,199 --> 00:06:11,280
your host runtimes in

00:06:08,400 --> 00:06:13,759
clouds iot devices edges and more it

00:06:11,280 --> 00:06:15,840
provides a single flat topology network

00:06:13,759 --> 00:06:20,560
that you can use to

00:06:15,840 --> 00:06:22,240
manage and observe your active workloads

00:06:20,560 --> 00:06:24,240
so let's take a look at the combination

00:06:22,240 --> 00:06:27,360
of webassembly and

00:06:24,240 --> 00:06:28,400
wasm cloud and we saw earlier that

00:06:27,360 --> 00:06:31,600
webassembly

00:06:28,400 --> 00:06:33,440
provides security uh most of the

00:06:31,600 --> 00:06:36,160
security from webassembly

00:06:33,440 --> 00:06:37,520
at the core comes from just the fact

00:06:36,160 --> 00:06:40,960
that it contains no

00:06:37,520 --> 00:06:43,120
bytecode operations for interacting

00:06:40,960 --> 00:06:44,720
with the operating system it can't do

00:06:43,120 --> 00:06:46,080
things that the host runtime doesn't

00:06:44,720 --> 00:06:48,639
allow it to do

00:06:46,080 --> 00:06:49,599
it's portable all the instructions in

00:06:48,639 --> 00:06:53,199
webassembly

00:06:49,599 --> 00:06:53,759
are cpu and os agnostic webassembly is

00:06:53,199 --> 00:06:56,960
fast

00:06:53,759 --> 00:07:00,000
it has a small size and then

00:06:56,960 --> 00:07:03,039
wisemancloud builds on top of this

00:07:00,000 --> 00:07:05,840
by giving us access to loosely coupled

00:07:03,039 --> 00:07:06,400
capabilities and those capabilities

00:07:05,840 --> 00:07:09,759
might be

00:07:06,400 --> 00:07:10,960
web servers database clients message

00:07:09,759 --> 00:07:14,639
brokers

00:07:10,960 --> 00:07:16,479
those types of things blob stores

00:07:14,639 --> 00:07:18,000
seamless distributed compute that runs

00:07:16,479 --> 00:07:19,520
anywhere is

00:07:18,000 --> 00:07:21,919
a feature that we add through wisem

00:07:19,520 --> 00:07:24,000
cloud you can horizontally scale

00:07:21,919 --> 00:07:25,360
your actors and your capability

00:07:24,000 --> 00:07:26,720
providers

00:07:25,360 --> 00:07:28,960
again i mentioned the actor model

00:07:26,720 --> 00:07:31,919
earlier and we also do

00:07:28,960 --> 00:07:33,280
contract driven design so when you build

00:07:31,919 --> 00:07:35,680
a wisdom cloud actor

00:07:33,280 --> 00:07:37,599
you're writing against an abstract

00:07:35,680 --> 00:07:39,280
contract

00:07:37,599 --> 00:07:41,440
so you might be writing against the key

00:07:39,280 --> 00:07:45,840
value contract or abstraction

00:07:41,440 --> 00:07:45,840
or the web server abstraction or

00:07:46,080 --> 00:07:50,080
some database client abstraction and not

00:07:48,400 --> 00:07:52,319
the actual database itself

00:07:50,080 --> 00:07:54,560
which means all of those things can

00:07:52,319 --> 00:07:55,680
change at runtime without you having to

00:07:54,560 --> 00:07:59,120
rebuild or

00:07:55,680 --> 00:08:01,520
redeploy your code

00:07:59,120 --> 00:08:02,560
so let's take a look at the sample

00:08:01,520 --> 00:08:07,759
application that we

00:08:02,560 --> 00:08:12,080
that we built and the idea here was to

00:08:07,759 --> 00:08:14,160
to track the and document the journey of

00:08:12,080 --> 00:08:15,120
that starts with having an idea and

00:08:14,160 --> 00:08:17,160
finishes with

00:08:15,120 --> 00:08:18,400
that idea running in production and

00:08:17,160 --> 00:08:21,599
[Music]

00:08:18,400 --> 00:08:23,199
to take note on how that changes or how

00:08:21,599 --> 00:08:26,319
that experience might change

00:08:23,199 --> 00:08:27,120
using small composable webassembly

00:08:26,319 --> 00:08:30,639
modules

00:08:27,120 --> 00:08:33,360
rather than our traditional uh throw a

00:08:30,639 --> 00:08:37,120
microservice into a docker image

00:08:33,360 --> 00:08:39,200
approach so the application that we're

00:08:37,120 --> 00:08:41,039
building is called wisem cloud chat

00:08:39,200 --> 00:08:43,039
and it's a multi-channel real-time

00:08:41,039 --> 00:08:45,760
messaging application so

00:08:43,039 --> 00:08:46,959
instead of a simple hello world app this

00:08:45,760 --> 00:08:50,240
chat application

00:08:46,959 --> 00:08:52,880
has a full backend it records all of the

00:08:50,240 --> 00:08:55,040
messages that go through it

00:08:52,880 --> 00:08:56,240
and it has multiple inbound and outbound

00:08:55,040 --> 00:08:59,519
channels including

00:08:56,240 --> 00:09:03,680
message broker and uh for

00:08:59,519 --> 00:09:03,680
our demo we're going to use telnet

00:09:04,959 --> 00:09:08,959
so this is essentially the napkin sketch

00:09:07,680 --> 00:09:10,560
or the blueprint for

00:09:08,959 --> 00:09:12,320
what we wanted to build for the sample

00:09:10,560 --> 00:09:15,120
application and

00:09:12,320 --> 00:09:16,240
so you can see that we have some users

00:09:15,120 --> 00:09:18,560
coming into the

00:09:16,240 --> 00:09:20,080
back end through the telnet channel and

00:09:18,560 --> 00:09:20,959
someone coming in through the broker

00:09:20,080 --> 00:09:23,680
channel

00:09:20,959 --> 00:09:25,360
and in the back in the the true back end

00:09:23,680 --> 00:09:28,959
we have

00:09:25,360 --> 00:09:32,000
functionality lumped together

00:09:28,959 --> 00:09:34,240
in categories called presence

00:09:32,000 --> 00:09:36,480
which is who's online and how long have

00:09:34,240 --> 00:09:40,480
they been on line for

00:09:36,480 --> 00:09:40,480
messages which is essentially the

00:09:40,560 --> 00:09:46,720
message processing and storage rooms

00:09:43,920 --> 00:09:48,560
so that's the chat rooms think of those

00:09:46,720 --> 00:09:52,800
as channels in slack

00:09:48,560 --> 00:09:52,800
and uh authentication and authorization

00:09:53,200 --> 00:09:56,959
and again this is a completely abstract

00:09:55,519 --> 00:09:59,760
concept here this is

00:09:56,959 --> 00:10:00,720
to represent the idea that we had before

00:09:59,760 --> 00:10:05,040
we started

00:10:00,720 --> 00:10:08,560
started to implement it

00:10:05,040 --> 00:10:11,279
and probably uh

00:10:08,560 --> 00:10:12,560
i sort of knew what to expect before i

00:10:11,279 --> 00:10:14,399
went down this road of

00:10:12,560 --> 00:10:17,120
trying to build out this application

00:10:14,399 --> 00:10:22,560
which was that i i've

00:10:17,120 --> 00:10:25,040
in the past my my plans

00:10:22,560 --> 00:10:27,279
immediately go or i'm bad as soon as i

00:10:25,040 --> 00:10:29,680
try and turn them into an implementation

00:10:27,279 --> 00:10:31,519
and whether that's because of tooling or

00:10:29,680 --> 00:10:32,640
technology or something else there is

00:10:31,519 --> 00:10:36,000
always a very

00:10:32,640 --> 00:10:41,120
large gap between my original idea

00:10:36,000 --> 00:10:41,120
and what i'm forced to build in the end

00:10:41,360 --> 00:10:47,839
so let's take a look at the journey of

00:10:44,800 --> 00:10:49,360
how we generally go about converting our

00:10:47,839 --> 00:10:50,640
ideas into something that runs in

00:10:49,360 --> 00:10:53,120
production

00:10:50,640 --> 00:10:55,360
so we start off with this amazing idea

00:10:53,120 --> 00:10:56,959
and we're inspired and that inspiration

00:10:55,360 --> 00:11:00,560
gives us just enough energy

00:10:56,959 --> 00:11:03,440
to get over and around that next curve

00:11:00,560 --> 00:11:04,880
and so we have this idea that we then

00:11:03,440 --> 00:11:08,160
convert into a design

00:11:04,880 --> 00:11:10,480
and the design is that abstract design

00:11:08,160 --> 00:11:11,839
that has very little to do with the

00:11:10,480 --> 00:11:13,600
actual implementation

00:11:11,839 --> 00:11:16,160
and it's just a rough sketch of what it

00:11:13,600 --> 00:11:18,320
is we're trying to build

00:11:16,160 --> 00:11:20,800
we then do some early experimentation on

00:11:18,320 --> 00:11:22,720
this idea

00:11:20,800 --> 00:11:24,720
and then that early experimentation

00:11:22,720 --> 00:11:26,640
invariably results in us having to throw

00:11:24,720 --> 00:11:30,079
away everything that we've done

00:11:26,640 --> 00:11:32,800
including some of our original uh ideas

00:11:30,079 --> 00:11:34,720
and redo what we were building and

00:11:32,800 --> 00:11:37,440
that's maybe because we we learned some

00:11:34,720 --> 00:11:40,560
valuable lessons or we got some

00:11:37,440 --> 00:11:42,720
technical things incorrect but this

00:11:40,560 --> 00:11:43,920
iteration of experimentation and

00:11:42,720 --> 00:11:47,839
redesign is

00:11:43,920 --> 00:11:50,880
pretty common including another

00:11:47,839 --> 00:11:52,639
round of refactoring and redesign

00:11:50,880 --> 00:11:54,000
and during that process we might

00:11:52,639 --> 00:11:54,639
actually get something out into

00:11:54,000 --> 00:11:57,760
production

00:11:54,639 --> 00:12:01,120
and deployed but it's

00:11:57,760 --> 00:12:02,399
certainly in many cases nothing like

00:12:01,120 --> 00:12:04,240
what we wanted to

00:12:02,399 --> 00:12:10,240
to build back when we had our amazing

00:12:04,240 --> 00:12:12,480
idea and this of course leads to despair

00:12:10,240 --> 00:12:13,440
and so what i'm hoping is that through

00:12:12,480 --> 00:12:16,639
the combination

00:12:13,440 --> 00:12:18,399
of webassembly and other cloud tooling

00:12:16,639 --> 00:12:19,839
we might be able to change this journey

00:12:18,399 --> 00:12:21,839
for the better

00:12:19,839 --> 00:12:23,200
so we start off again with our amazing

00:12:21,839 --> 00:12:26,000
idea

00:12:23,200 --> 00:12:27,440
and then we get to an initial design our

00:12:26,000 --> 00:12:31,360
napkin drawing which

00:12:27,440 --> 00:12:33,839
i drew on a slide earlier and then again

00:12:31,360 --> 00:12:36,000
we go to early experimentation and i

00:12:33,839 --> 00:12:39,120
think this is where the paths diverge

00:12:36,000 --> 00:12:41,200
the results of the early experimentation

00:12:39,120 --> 00:12:43,200
is going to be different this time and

00:12:41,200 --> 00:12:45,839
that's where we're able to

00:12:43,200 --> 00:12:46,639
quickly and easily deploy and test our

00:12:45,839 --> 00:12:49,440
experiments

00:12:46,639 --> 00:12:51,040
in different environments including

00:12:49,440 --> 00:12:53,200
production and production simulated

00:12:51,040 --> 00:12:56,160
environments

00:12:53,200 --> 00:12:58,480
and then the iterative process after

00:12:56,160 --> 00:13:01,200
these successfully deployed experiments

00:12:58,480 --> 00:13:02,480
is now instead of complete refactors and

00:13:01,200 --> 00:13:04,560
redesigns

00:13:02,480 --> 00:13:06,800
we're just able to tweak things change

00:13:04,560 --> 00:13:09,760
the knobs on our scaling and deployments

00:13:06,800 --> 00:13:11,760
and the shape of our final production

00:13:09,760 --> 00:13:16,160
environment to deal with

00:13:11,760 --> 00:13:18,880
scale and expected volume and load

00:13:16,160 --> 00:13:21,519
and we haven't had to throw away any of

00:13:18,880 --> 00:13:25,760
our initial conceptions this way

00:13:21,519 --> 00:13:25,760
and this hopefully leads to joy

00:13:27,360 --> 00:13:33,120
so back on the original journey path

00:13:30,720 --> 00:13:36,000
of microservices when we build our

00:13:33,120 --> 00:13:38,480
services with hard service boundaries

00:13:36,000 --> 00:13:40,240
uh i think work if you've built any

00:13:38,480 --> 00:13:41,120
microservices this pattern should look

00:13:40,240 --> 00:13:44,079
pretty familiar

00:13:41,120 --> 00:13:44,959
each one of these represents one of the

00:13:44,079 --> 00:13:46,800
potential

00:13:44,959 --> 00:13:48,959
units of deployment that we might want

00:13:46,800 --> 00:13:52,320
to build and if we're building this

00:13:48,959 --> 00:13:54,560
as regular microservices a small

00:13:52,320 --> 00:13:57,839
fraction of each one of these services

00:13:54,560 --> 00:14:00,160
on the screen is our business logic

00:13:57,839 --> 00:14:02,160
but then we now have all of these

00:14:00,160 --> 00:14:04,399
embedded dependencies

00:14:02,160 --> 00:14:06,240
each one of these has an rpc client in

00:14:04,399 --> 00:14:08,320
it some of them have

00:14:06,240 --> 00:14:09,760
message broker clients there's a telnet

00:14:08,320 --> 00:14:11,920
server and one of them

00:14:09,760 --> 00:14:13,519
there are database clients and in others

00:14:11,920 --> 00:14:16,480
there's caches

00:14:13,519 --> 00:14:18,240
all of these non-functional requirements

00:14:16,480 --> 00:14:20,639
and

00:14:18,240 --> 00:14:23,199
as alluded to earlier the problem with

00:14:20,639 --> 00:14:25,279
these is that these are now

00:14:23,199 --> 00:14:26,720
dependencies that we own and they are

00:14:25,279 --> 00:14:29,600
tightly coupled

00:14:26,720 --> 00:14:31,360
dependencies and even if we've managed

00:14:29,600 --> 00:14:33,680
to compile these we're still in a form

00:14:31,360 --> 00:14:36,959
of dependency hell because

00:14:33,680 --> 00:14:38,079
if we want to change how we get our

00:14:36,959 --> 00:14:41,279
telnet services

00:14:38,079 --> 00:14:43,360
from one approach to another

00:14:41,279 --> 00:14:44,560
we have to refactor and rebuild and

00:14:43,360 --> 00:14:46,560
redeploy

00:14:44,560 --> 00:14:48,079
if we want to change one of our database

00:14:46,560 --> 00:14:50,480
clients from

00:14:48,079 --> 00:14:52,480
redis to cassandra we have to refactor

00:14:50,480 --> 00:14:56,240
and rebuild and redeploy

00:14:52,480 --> 00:14:59,839
and that entire cycle happens

00:14:56,240 --> 00:15:01,839
a lot more often than we expect and

00:14:59,839 --> 00:15:03,519
so these hard service boundaries are

00:15:01,839 --> 00:15:06,399
very much like

00:15:03,519 --> 00:15:08,560
uh containment walls and not in a good

00:15:06,399 --> 00:15:12,160
way

00:15:08,560 --> 00:15:16,000
and so hopefully we can do better and so

00:15:12,160 --> 00:15:17,120
with webassembly and using wisem cloud

00:15:16,000 --> 00:15:20,480
actors

00:15:17,120 --> 00:15:21,680
and a bunch of beneficial open source

00:15:20,480 --> 00:15:24,240
runtimes

00:15:21,680 --> 00:15:25,279
we can get flexible service boundaries

00:15:24,240 --> 00:15:27,199
so

00:15:25,279 --> 00:15:29,360
one deployment option here would be to

00:15:27,199 --> 00:15:30,880
have a single runtime process that has

00:15:29,360 --> 00:15:34,399
all of our actors in it

00:15:30,880 --> 00:15:37,199
so we can choose on our laptop

00:15:34,399 --> 00:15:37,839
during early development to have a

00:15:37,199 --> 00:15:39,519
monolith

00:15:37,839 --> 00:15:41,199
because it's the most convenient and

00:15:39,519 --> 00:15:42,240
it's the easiest to work with for that

00:15:41,199 --> 00:15:46,959
time

00:15:42,240 --> 00:15:48,560
and then as we experiment and we start

00:15:46,959 --> 00:15:50,240
needing different shapes to handle

00:15:48,560 --> 00:15:51,360
different loads we can split that we

00:15:50,240 --> 00:15:54,560
could split it into

00:15:51,360 --> 00:15:55,600
two runtime hosts and now we have our

00:15:54,560 --> 00:15:57,440
actors

00:15:55,600 --> 00:15:59,120
spread in different ways across the

00:15:57,440 --> 00:16:01,600
different hosts and we can pick and

00:15:59,120 --> 00:16:04,800
choose which ones go where

00:16:01,600 --> 00:16:08,160
we're not locked into any binding

00:16:04,800 --> 00:16:10,240
between an actor and a host at compile

00:16:08,160 --> 00:16:12,639
time

00:16:10,240 --> 00:16:13,759
and finally we could also choose the the

00:16:12,639 --> 00:16:16,880
super micro

00:16:13,759 --> 00:16:18,160
micro service where one of our hosts is

00:16:16,880 --> 00:16:20,320
hosting one actor

00:16:18,160 --> 00:16:21,440
and we could choose that for a number of

00:16:20,320 --> 00:16:24,240
reasons

00:16:21,440 --> 00:16:24,800
but the important point is that this

00:16:24,240 --> 00:16:28,240
choice

00:16:24,800 --> 00:16:29,519
is now at least in the world of web

00:16:28,240 --> 00:16:32,880
assembly

00:16:29,519 --> 00:16:34,639
a runtime an operational choice and not

00:16:32,880 --> 00:16:37,040
a

00:16:34,639 --> 00:16:38,160
an architectural design choice that is

00:16:37,040 --> 00:16:41,360
baked into

00:16:38,160 --> 00:16:44,880
the overall implementation of the system

00:16:41,360 --> 00:16:44,880
so let's take a look at how we built it

00:16:46,800 --> 00:16:50,079
and i'm going to go through some rust

00:16:48,399 --> 00:16:52,720
fairly quickly but

00:16:50,079 --> 00:16:54,320
the main thing that i want to show that

00:16:52,720 --> 00:16:55,360
i want you to keep in mind as i go

00:16:54,320 --> 00:16:57,519
through this code

00:16:55,360 --> 00:16:59,519
is not what the code looks like but

00:16:57,519 --> 00:17:01,839
what's missing from the code

00:16:59,519 --> 00:17:02,639
and so in this one the first thing that

00:17:01,839 --> 00:17:05,039
an actor does

00:17:02,639 --> 00:17:05,919
is it righteous areas the message

00:17:05,039 --> 00:17:09,039
handlers

00:17:05,919 --> 00:17:11,120
actors are reactive and

00:17:09,039 --> 00:17:13,679
they they receive messages and they emit

00:17:11,120 --> 00:17:16,640
a reply to those messages

00:17:13,679 --> 00:17:18,079
and so in this case uh one of these

00:17:16,640 --> 00:17:20,720
actors is

00:17:18,079 --> 00:17:23,280
simply registering a handler to process

00:17:20,720 --> 00:17:23,280
messages

00:17:24,319 --> 00:17:27,360
and again let's take a look at the code

00:17:26,640 --> 00:17:29,679
more with an

00:17:27,360 --> 00:17:31,120
eye towards what's missing in this

00:17:29,679 --> 00:17:34,559
snippet we can see

00:17:31,120 --> 00:17:37,120
that it's publishing a message to

00:17:34,559 --> 00:17:37,679
the backend and this this code is

00:17:37,120 --> 00:17:40,400
actually

00:17:37,679 --> 00:17:41,520
from the message broker channel which

00:17:40,400 --> 00:17:44,880
acts as a

00:17:41,520 --> 00:17:45,360
proxy between the outside message broker

00:17:44,880 --> 00:17:47,760
and the

00:17:45,360 --> 00:17:48,640
the back end inside our chat system

00:17:47,760 --> 00:17:52,559
which is

00:17:48,640 --> 00:17:55,760
far more complicated than a hello world

00:17:52,559 --> 00:17:59,280
sample but what's missing

00:17:55,760 --> 00:18:01,200
is actual communication with a tightly

00:17:59,280 --> 00:18:03,520
coupled broker

00:18:01,200 --> 00:18:04,480
that publish function just takes the

00:18:03,520 --> 00:18:09,360
topic

00:18:04,480 --> 00:18:12,240
a reply topic and the payload to publish

00:18:09,360 --> 00:18:13,120
the choice of which broker is doing the

00:18:12,240 --> 00:18:15,520
publishing

00:18:13,120 --> 00:18:17,360
how that broker does the publishing and

00:18:15,520 --> 00:18:19,919
what configuration we use

00:18:17,360 --> 00:18:21,280
in order to enable that publisher that

00:18:19,919 --> 00:18:24,240
broker to publish

00:18:21,280 --> 00:18:25,679
that's all done at runtime we could

00:18:24,240 --> 00:18:28,720
completely swap out

00:18:25,679 --> 00:18:31,679
rabbitmq for kafka for gnats without

00:18:28,720 --> 00:18:33,919
having to recompile this actor

00:18:31,679 --> 00:18:36,400
or even redeploy we could swap those at

00:18:33,919 --> 00:18:36,400
runtime

00:18:37,760 --> 00:18:44,559
similar scenario here with data services

00:18:41,440 --> 00:18:48,720
so in this one we

00:18:44,559 --> 00:18:51,360
are adding a room to the chat back end

00:18:48,720 --> 00:18:52,799
and in order to do that we need to

00:18:51,360 --> 00:18:54,559
communicate with a database

00:18:52,799 --> 00:18:56,240
and in this case we're communicating

00:18:54,559 --> 00:18:59,679
with a key value store

00:18:56,240 --> 00:19:02,720
but the again what's missing from here

00:18:59,679 --> 00:19:05,600
is that the key value store

00:19:02,720 --> 00:19:08,160
isn't actually defined here we're

00:19:05,600 --> 00:19:11,039
referring to the key value abstraction

00:19:08,160 --> 00:19:11,760
but we're not talking explicitly to

00:19:11,039 --> 00:19:15,679
redis

00:19:11,760 --> 00:19:17,760
or to cassandra or memcached or etcd

00:19:15,679 --> 00:19:20,000
we're simply saying set this key to this

00:19:17,760 --> 00:19:25,039
value and add this value

00:19:20,000 --> 00:19:29,679
to a a set with this key

00:19:25,039 --> 00:19:32,640
and again the binding of the provider

00:19:29,679 --> 00:19:32,640
is done at runtime

00:19:33,120 --> 00:19:36,400
all right so now i'm going to take

00:19:34,559 --> 00:19:39,200
through a quick demo

00:19:36,400 --> 00:19:40,320
of the chat application that we built

00:19:39,200 --> 00:19:42,880
and i'll show

00:19:40,320 --> 00:19:43,919
all of this code in action and more

00:19:42,880 --> 00:19:47,600
importantly

00:19:43,919 --> 00:19:51,120
i'll show this the incredibly small

00:19:47,600 --> 00:19:54,000
size of the of our unit of distribution

00:19:51,120 --> 00:19:55,120
and our unit of compute and how flexible

00:19:54,000 --> 00:19:58,080
it is

00:19:55,120 --> 00:20:01,360
and the options that we have without

00:19:58,080 --> 00:20:03,360
needing to recompile anything

00:20:01,360 --> 00:20:05,360
and again before i get into the demo i

00:20:03,360 --> 00:20:06,400
just want to have this slide up here

00:20:05,360 --> 00:20:08,559
real quick

00:20:06,400 --> 00:20:09,760
as a brief reminder of the architecture

00:20:08,559 --> 00:20:12,799
that we're building

00:20:09,760 --> 00:20:13,919
everything with a gear and in one case a

00:20:12,799 --> 00:20:18,080
padlock

00:20:13,919 --> 00:20:20,880
is an actor written in wasmcloud

00:20:18,080 --> 00:20:23,360
for the system and i'll go through that

00:20:20,880 --> 00:20:23,360
in a second

00:20:25,600 --> 00:20:28,880
all right so let's get started with the

00:20:26,880 --> 00:20:30,720
demo i've got

00:20:28,880 --> 00:20:32,480
a couple of terminal windows open here

00:20:30,720 --> 00:20:35,440
because uh in general

00:20:32,480 --> 00:20:37,280
my demos are i'm pretty devoid of

00:20:35,440 --> 00:20:38,320
graphics i'm going to be going through

00:20:37,280 --> 00:20:41,520
some console stuff

00:20:38,320 --> 00:20:45,039
and we'll be using the telnet channel

00:20:41,520 --> 00:20:46,159
on the chat example so the first thing i

00:20:45,039 --> 00:20:49,200
want to go through

00:20:46,159 --> 00:20:50,640
is looking at some of the actors uh you

00:20:49,200 --> 00:20:51,360
saw some of the source code for the

00:20:50,640 --> 00:20:54,720
actors

00:20:51,360 --> 00:20:58,000
in the slide deck that i

00:20:54,720 --> 00:20:58,720
went through earlier and i just want to

00:20:58,000 --> 00:21:00,640
show you

00:20:58,720 --> 00:21:02,400
uh what that what that sort of looks

00:21:00,640 --> 00:21:05,760
like in the shell here

00:21:02,400 --> 00:21:08,960
so what i want to look at

00:21:05,760 --> 00:21:09,300
is first how small these things are

00:21:08,960 --> 00:21:12,349
so

00:21:09,300 --> 00:21:12,349
[Music]

00:21:12,480 --> 00:21:19,360
if i take a look at the

00:21:16,320 --> 00:21:22,000
signed uh version of

00:21:19,360 --> 00:21:23,919
our actor which is just a wasm file

00:21:22,000 --> 00:21:27,520
you'll see that it's actually

00:21:23,919 --> 00:21:30,320
only 702k and when you think about

00:21:27,520 --> 00:21:31,360
the unit of deployment for most

00:21:30,320 --> 00:21:33,200
microservices

00:21:31,360 --> 00:21:34,400
even if we're using a language that's

00:21:33,200 --> 00:21:37,200
known for

00:21:34,400 --> 00:21:39,280
fairly small self-contained binaries

00:21:37,200 --> 00:21:41,280
nothing produces binaries as small as

00:21:39,280 --> 00:21:44,080
700k

00:21:41,280 --> 00:21:45,360
and we're able to embed them with a

00:21:44,080 --> 00:21:48,080
cryptographic signature

00:21:45,360 --> 00:21:49,919
that tells the runtime what these

00:21:48,080 --> 00:21:53,760
modules are allowed to do

00:21:49,919 --> 00:21:57,200
so if i inspect the claims

00:21:53,760 --> 00:22:00,000
on this module you'll see

00:21:57,200 --> 00:22:01,200
that uh what i've got here is the name

00:22:00,000 --> 00:22:04,640
of the actor which is called

00:22:01,200 --> 00:22:06,400
a telnet channel and the actor has an

00:22:04,640 --> 00:22:08,480
account a module

00:22:06,400 --> 00:22:09,600
expires can be used and so on and if

00:22:08,480 --> 00:22:11,679
you're

00:22:09,600 --> 00:22:14,080
paying close attention and you've seen

00:22:11,679 --> 00:22:15,440
jason webb token before you'll recognize

00:22:14,080 --> 00:22:18,000
that these are

00:22:15,440 --> 00:22:19,200
similar fields where we have an issuer a

00:22:18,000 --> 00:22:20,880
subject

00:22:19,200 --> 00:22:22,400
and then some other fields for how that

00:22:20,880 --> 00:22:25,840
certificate or how that

00:22:22,400 --> 00:22:27,039
token can be used but more importantly

00:22:25,840 --> 00:22:30,240
this telnet channel

00:22:27,039 --> 00:22:34,000
is capable of using the key value store

00:22:30,240 --> 00:22:36,880
messaging broker logging extras for

00:22:34,000 --> 00:22:38,840
random number generation and the telnet

00:22:36,880 --> 00:22:42,080
capability

00:22:38,840 --> 00:22:43,840
and uh it's it's worth pointing out

00:22:42,080 --> 00:22:45,520
that nowhere in that list of

00:22:43,840 --> 00:22:48,720
capabilities is there

00:22:45,520 --> 00:22:50,400
a specific mention of

00:22:48,720 --> 00:22:52,559
a vendor project so we don't mention

00:22:50,400 --> 00:22:56,080
redis we say that you can use the

00:22:52,559 --> 00:22:57,600
a key value store and so on so that was

00:22:56,080 --> 00:23:01,679
that's the telnet channel

00:22:57,600 --> 00:23:05,120
and we also have in the

00:23:01,679 --> 00:23:08,240
actor list we have authorization

00:23:05,120 --> 00:23:09,200
a broker channel so anything that is

00:23:08,240 --> 00:23:13,039
using

00:23:09,200 --> 00:23:15,039
let's say gnats can use gnats as a

00:23:13,039 --> 00:23:17,840
gateway into the chat system

00:23:15,039 --> 00:23:19,840
we have the messages actor a presence

00:23:17,840 --> 00:23:22,720
actor for determining who's online

00:23:19,840 --> 00:23:24,960
rooms and then again the telnet channel

00:23:22,720 --> 00:23:24,960
so

00:23:27,039 --> 00:23:30,799
what i'd like to do next is start up a

00:23:29,039 --> 00:23:33,760
wisdom cloud host

00:23:30,799 --> 00:23:34,400
and i want to start all of the important

00:23:33,760 --> 00:23:36,640
actors

00:23:34,400 --> 00:23:37,760
i want to start all of the capability

00:23:36,640 --> 00:23:39,679
providers

00:23:37,760 --> 00:23:41,360
and then i want to configure those and

00:23:39,679 --> 00:23:44,559
we do that through

00:23:41,360 --> 00:23:45,840
a manifest file and first looking at

00:23:44,559 --> 00:23:48,480
this manifest file

00:23:45,840 --> 00:23:50,480
may seem a little bit overwhelming i'm

00:23:48,480 --> 00:23:54,559
only using yaml here

00:23:50,480 --> 00:23:58,000
for an example you can also use json

00:23:54,559 --> 00:24:00,080
there's no no requirement there so

00:23:58,000 --> 00:24:01,360
the first thing we have on lines five

00:24:00,080 --> 00:24:03,600
through seven

00:24:01,360 --> 00:24:04,480
is a list of actors that we want to

00:24:03,600 --> 00:24:07,840
start up in the

00:24:04,480 --> 00:24:10,960
asm cloud host and then on lines 9

00:24:07,840 --> 00:24:13,760
11 13 15

00:24:10,960 --> 00:24:15,200
and 17 you'll see we're actually using a

00:24:13,760 --> 00:24:16,240
thing called an image ref for a

00:24:15,200 --> 00:24:17,840
capability

00:24:16,240 --> 00:24:20,400
and what that means is we're actually

00:24:17,840 --> 00:24:23,679
able to load a capability provider

00:24:20,400 --> 00:24:25,760
from an oci uh

00:24:23,679 --> 00:24:27,440
registry that means that we can store

00:24:25,760 --> 00:24:29,279
them the same way

00:24:27,440 --> 00:24:30,720
you store document niches and we can

00:24:29,279 --> 00:24:33,440
retrieve them the same way you

00:24:30,720 --> 00:24:34,799
you retrieve docker images and so we

00:24:33,440 --> 00:24:36,880
have a number of our

00:24:34,799 --> 00:24:39,039
first party capability providers sitting

00:24:36,880 --> 00:24:42,880
in our wasm cloud

00:24:39,039 --> 00:24:45,600
oci registry in azure and then

00:24:42,880 --> 00:24:47,600
starting on line 18 we have links and

00:24:45,600 --> 00:24:50,640
link definitions

00:24:47,600 --> 00:24:53,279
uh essentially consists of the actor

00:24:50,640 --> 00:24:53,840
the provider that we're linking to and

00:24:53,279 --> 00:24:57,120
then

00:24:53,840 --> 00:24:59,360
the name of the link and then a

00:24:57,120 --> 00:25:01,520
set of parameters so we think

00:24:59,360 --> 00:25:03,120
environment variables

00:25:01,520 --> 00:25:07,039
and so if you see here we've got the

00:25:03,120 --> 00:25:10,400
broker channel actor is being linked to

00:25:07,039 --> 00:25:14,080
the front-end version of

00:25:10,400 --> 00:25:14,960
the broker the wasmcloud messaging and

00:25:14,080 --> 00:25:16,799
so

00:25:14,960 --> 00:25:18,640
by using these two different link names

00:25:16,799 --> 00:25:20,640
we can actually have

00:25:18,640 --> 00:25:22,320
two different instances of the same

00:25:20,640 --> 00:25:23,760
capability provider

00:25:22,320 --> 00:25:25,919
but with different configuration

00:25:23,760 --> 00:25:29,520
parameters and so in this case

00:25:25,919 --> 00:25:32,320
we have a mats broker configured

00:25:29,520 --> 00:25:33,760
with a front end connection string and

00:25:32,320 --> 00:25:36,480
one configured with the back end

00:25:33,760 --> 00:25:38,080
connection string

00:25:36,480 --> 00:25:40,320
so as we go through here you'll see

00:25:38,080 --> 00:25:43,520
there's telnet we configure the telnet

00:25:40,320 --> 00:25:44,159
actor by allowing it by configuring it

00:25:43,520 --> 00:25:46,880
with

00:25:44,159 --> 00:25:47,919
logging extras access to the telnet

00:25:46,880 --> 00:25:51,200
provider

00:25:47,919 --> 00:25:52,799
and access to a key value store and

00:25:51,200 --> 00:25:54,960
[Music]

00:25:52,799 --> 00:25:56,000
you'll see that that key value store is

00:25:54,960 --> 00:25:59,919
configured to

00:25:56,000 --> 00:26:04,159
communicate with redis so if i start

00:25:59,919 --> 00:26:07,600
wasmcloud with this manifest file

00:26:04,159 --> 00:26:10,080
you'll see a whole bunch of

00:26:07,600 --> 00:26:11,039
log spam that should look fairly

00:26:10,080 --> 00:26:13,279
familiar to

00:26:11,039 --> 00:26:14,559
anybody who has spent time looking at

00:26:13,279 --> 00:26:17,200
microservices

00:26:14,559 --> 00:26:19,200
standard outlooks in kubernetes or any

00:26:17,200 --> 00:26:22,240
other cloud environment

00:26:19,200 --> 00:26:24,000
most of this is informational not really

00:26:22,240 --> 00:26:27,600
worth going into too much detail

00:26:24,000 --> 00:26:30,320
but you can see how we have a

00:26:27,600 --> 00:26:31,919
discrete log of all of the actors all of

00:26:30,320 --> 00:26:33,919
the providers that are running

00:26:31,919 --> 00:26:35,360
if an actor stops and starts we'll see

00:26:33,919 --> 00:26:37,600
that here

00:26:35,360 --> 00:26:40,640
if one if a capability provider stops

00:26:37,600 --> 00:26:43,760
and starts we'll see that there as well

00:26:40,640 --> 00:26:45,760
so the first thing we now have is we

00:26:43,760 --> 00:26:46,880
we know that we have a telnet provider

00:26:45,760 --> 00:26:49,279
running

00:26:46,880 --> 00:26:52,159
and because we configured it we know

00:26:49,279 --> 00:26:56,559
it's running on port 8500

00:26:52,159 --> 00:26:59,520
and we got a fancy ascii art

00:26:56,559 --> 00:27:00,240
welcome message so we'll log in here i

00:26:59,520 --> 00:27:02,000
shall

00:27:00,240 --> 00:27:04,400
those are the list of the commands that

00:27:02,000 --> 00:27:06,799
we support and i mentioned earlier

00:27:04,400 --> 00:27:09,520
the back-end system deals with things

00:27:06,799 --> 00:27:12,320
like storing and retrieving messages

00:27:09,520 --> 00:27:14,159
as a stream uh creating and deleting

00:27:12,320 --> 00:27:16,159
rooms joining rooms

00:27:14,159 --> 00:27:17,440
and all of that sort of thing and then

00:27:16,159 --> 00:27:19,039
the channels

00:27:17,440 --> 00:27:20,880
are responsible for the actual

00:27:19,039 --> 00:27:23,600
communication so right now i'm using the

00:27:20,880 --> 00:27:23,600
telnet channel

00:27:26,000 --> 00:27:33,039
and i typed a message there and since

00:27:30,159 --> 00:27:34,399
there was no one listening if there's no

00:27:33,039 --> 00:27:37,679
one listening to

00:27:34,399 --> 00:27:41,360
a real-time chat message in the forest

00:27:37,679 --> 00:27:44,559
uh did it actually happen and

00:27:41,360 --> 00:27:45,840
if we go into our redis cli we'll see

00:27:44,559 --> 00:27:48,240
that in it indeed

00:27:45,840 --> 00:27:49,520
did still happen so i'll take a look at

00:27:48,240 --> 00:27:52,720
the stream

00:27:49,520 --> 00:27:54,320
for the general room

00:27:52,720 --> 00:27:55,600
and don't worry if the rate of syntax

00:27:54,320 --> 00:27:56,720
isn't familiar it's not all that

00:27:55,600 --> 00:27:58,399
important right now

00:27:56,720 --> 00:28:00,399
but you can see what's what's what

00:27:58,399 --> 00:28:02,720
happened here is

00:28:00,399 --> 00:28:03,840
i have a stream of messages that has

00:28:02,720 --> 00:28:05,760
been going

00:28:03,840 --> 00:28:08,960
through the different rooms in my in my

00:28:05,760 --> 00:28:11,279
chat back end and this most recent one

00:28:08,960 --> 00:28:12,240
we have a each message has a unique id

00:28:11,279 --> 00:28:15,279
the text was

00:28:12,240 --> 00:28:16,480
hello from kubecon we can see the origin

00:28:15,279 --> 00:28:19,440
user is

00:28:16,480 --> 00:28:20,720
a wasn't cloud chat url there's a

00:28:19,440 --> 00:28:22,480
timestamp on it

00:28:20,720 --> 00:28:24,000
and the origin channel is the telnet

00:28:22,480 --> 00:28:26,320
broker

00:28:24,000 --> 00:28:27,919
now assuming that we have other channels

00:28:26,320 --> 00:28:31,919
running we might have

00:28:27,919 --> 00:28:35,200
as an origin channel you might see the

00:28:31,919 --> 00:28:38,000
the nats broker or you might see an irc

00:28:35,200 --> 00:28:39,120
broker or even a slack broker or a slack

00:28:38,000 --> 00:28:41,120
channel

00:28:39,120 --> 00:28:42,320
depending on the integrations that we

00:28:41,120 --> 00:28:45,200
support

00:28:42,320 --> 00:28:46,559
it's designed to support any number of

00:28:45,200 --> 00:28:49,520
integrations written

00:28:46,559 --> 00:28:49,919
using wisem cloud actors so but in any

00:28:49,520 --> 00:28:52,960
case

00:28:49,919 --> 00:28:56,480
the the moral of this story isn't

00:28:52,960 --> 00:28:59,360
that i've been able to build a

00:28:56,480 --> 00:28:59,840
chat application the moral of the story

00:28:59,360 --> 00:29:01,360
is

00:28:59,840 --> 00:29:03,840
that we've been able to build the chat

00:29:01,360 --> 00:29:07,840
application by composing

00:29:03,840 --> 00:29:11,279
tiny units of compute and distribution

00:29:07,840 --> 00:29:12,640
that literally consume no more than one

00:29:11,279 --> 00:29:15,279
meg each

00:29:12,640 --> 00:29:15,679
that are cryptographically signed that

00:29:15,279 --> 00:29:18,799
have

00:29:15,679 --> 00:29:20,880
a verifiable secure prominence that can

00:29:18,799 --> 00:29:22,720
be deployed anywhere and can connect to

00:29:20,880 --> 00:29:23,600
capabilities that are also deployed

00:29:22,720 --> 00:29:26,720
anywhere

00:29:23,600 --> 00:29:28,799
i can choose to run this entire thing

00:29:26,720 --> 00:29:30,320
as a monolith which is what i'm doing in

00:29:28,799 --> 00:29:32,080
this one terminal window

00:29:30,320 --> 00:29:34,080
or i could choose to run it as any

00:29:32,080 --> 00:29:35,120
number of processes as i want i could

00:29:34,080 --> 00:29:38,240
run

00:29:35,120 --> 00:29:40,080
30 copies of one actor and 12 copies

00:29:38,240 --> 00:29:41,679
of the capability provider that it

00:29:40,080 --> 00:29:44,480
speaks to and

00:29:41,679 --> 00:29:45,600
the wasn't quad runtime takes care of

00:29:44,480 --> 00:29:48,880
distributing

00:29:45,600 --> 00:29:53,440
the function columns between those and

00:29:48,880 --> 00:29:56,320
makes it all seamless for you so

00:29:53,440 --> 00:29:57,679
the the end result of the experiment

00:29:56,320 --> 00:29:58,640
that we did to build this chat

00:29:57,679 --> 00:30:03,120
application

00:29:58,640 --> 00:30:05,039
was that thinking about

00:30:03,120 --> 00:30:06,840
the the problem that we were trying to

00:30:05,039 --> 00:30:10,960
solve

00:30:06,840 --> 00:30:12,159
was uh almost directly in line with how

00:30:10,960 --> 00:30:15,600
we solved it

00:30:12,159 --> 00:30:17,679
when we went with building actors

00:30:15,600 --> 00:30:19,679
and connecting them to capabilities

00:30:17,679 --> 00:30:21,279
versus

00:30:19,679 --> 00:30:23,120
other avenues that might have been

00:30:21,279 --> 00:30:25,679
higher friction had we decided to go

00:30:23,120 --> 00:30:27,840
with the traditional microservices route

00:30:25,679 --> 00:30:28,720
so if i could ask one thing it would

00:30:27,840 --> 00:30:31,840
just be to

00:30:28,720 --> 00:30:32,720
take a look at the tutorials and kick

00:30:31,840 --> 00:30:36,159
the tires

00:30:32,720 --> 00:30:38,640
and see if

00:30:36,159 --> 00:30:40,399
you know your next microservice project

00:30:38,640 --> 00:30:41,440
might be something that you might want

00:30:40,399 --> 00:30:44,640
to

00:30:41,440 --> 00:30:50,720
make as your first

00:30:44,640 --> 00:30:50,720

YouTube URL: https://www.youtube.com/watch?v=N9tj9ukFNig


