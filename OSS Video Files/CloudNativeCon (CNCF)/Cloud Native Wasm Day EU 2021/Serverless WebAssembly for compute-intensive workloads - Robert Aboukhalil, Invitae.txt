Title: Serverless WebAssembly for compute-intensive workloads - Robert Aboukhalil, Invitae
Publication date: 2021-05-04
Playlist: Cloud Native Wasm Day EU 2021
Description: 
	Donâ€™t miss out! Join us at our upcoming event: KubeCon + CloudNativeCon North America 2021 in Los Angeles, CA from October 12-15. Learn more at https://kubecon.io The conference features presentations from developers and end users of Kubernetes, Prometheus, Envoy, and all of the other CNCF-hosted projects.

Serverless WebAssembly for compute-intensive workloads - Robert Aboukhalil, Invitae

Serverless functions are a cost-effective way to build scalable APIs, but they can be impractical for certain applications due to cold starts and lack of support for your language of interest. However, now that several platforms offer FaaS solutions powered by WebAssembly (e.g. Cloudflare, Fastly), they can now provide near-0 function initialization times, and support for languages that compile to WebAssembly. This talk explores how to use serverless WebAssembly to build APIs for compute-intensive workloads. As a concrete example, Robert will showcase a serverless function that performs bioinformatics analysis; this is done by compiling an existing library from C to WebAssembly, and deploying it as a serverless function.
Captions: 
	00:00:01,760 --> 00:00:04,080
hey everyone thanks so much for being

00:00:03,360 --> 00:00:06,240
here

00:00:04,080 --> 00:00:07,120
i'm really excited to share with you a

00:00:06,240 --> 00:00:09,679
few thoughts

00:00:07,120 --> 00:00:11,519
on serverless web assembly and how that

00:00:09,679 --> 00:00:14,880
could be a really powerful tool

00:00:11,519 --> 00:00:16,640
for compute intensive workloads

00:00:14,880 --> 00:00:18,640
now before we get into that just a bit

00:00:16,640 --> 00:00:21,279
about me my background

00:00:18,640 --> 00:00:23,039
is a mix of computer science and

00:00:21,279 --> 00:00:25,039
bioinformatics

00:00:23,039 --> 00:00:27,119
i'm currently a software engineer at

00:00:25,039 --> 00:00:28,560
nvitae which is a genetic testing

00:00:27,119 --> 00:00:31,359
company

00:00:28,560 --> 00:00:31,840
and i'm the author of the book level up

00:00:31,359 --> 00:00:34,640
with

00:00:31,840 --> 00:00:34,640
webassembly

00:00:35,120 --> 00:00:39,520
right so before we dive into the

00:00:38,000 --> 00:00:42,879
serverless webassembly

00:00:39,520 --> 00:00:46,559
parts i did want to review

00:00:42,879 --> 00:00:46,960
why webassembly can be a powerful tool

00:00:46,559 --> 00:00:50,079
for

00:00:46,960 --> 00:00:51,680
analyzing data in the browser

00:00:50,079 --> 00:00:53,840
so whether you're talking about a

00:00:51,680 --> 00:00:56,879
desktop application

00:00:53,840 --> 00:00:59,039
image processing machine learning or

00:00:56,879 --> 00:01:02,160
bioinformatics

00:00:59,039 --> 00:01:06,000
these four are really good examples

00:01:02,160 --> 00:01:08,479
of tools that leverage existing code

00:01:06,000 --> 00:01:09,600
written in languages like c sql plus and

00:01:08,479 --> 00:01:12,880
rust

00:01:09,600 --> 00:01:15,040
and are able to bring those tools into

00:01:12,880 --> 00:01:17,439
the browser

00:01:15,040 --> 00:01:18,159
and the reason why this is powerful

00:01:17,439 --> 00:01:20,080
first of all

00:01:18,159 --> 00:01:21,920
is because you are able to reuse

00:01:20,080 --> 00:01:22,960
existing code so you don't have to

00:01:21,920 --> 00:01:27,200
rewrite

00:01:22,960 --> 00:01:29,840
these complex algorithms into javascript

00:01:27,200 --> 00:01:30,880
it's also nice because in some cases you

00:01:29,840 --> 00:01:32,880
can get

00:01:30,880 --> 00:01:33,920
some performance improvements for

00:01:32,880 --> 00:01:35,360
example

00:01:33,920 --> 00:01:38,240
in the tool ribbon that i showed in the

00:01:35,360 --> 00:01:41,200
previous slide we saw a 3x

00:01:38,240 --> 00:01:42,799
speed up by replacing slow javascript

00:01:41,200 --> 00:01:44,799
computations

00:01:42,799 --> 00:01:48,159
with an off-the-shelf tool that we

00:01:44,799 --> 00:01:48,159
compile to webassembly

00:01:49,600 --> 00:01:53,360
using webassembly the browser is also

00:01:51,520 --> 00:01:56,719
useful because you can

00:01:53,360 --> 00:01:59,280
leverage the user's compute power

00:01:56,719 --> 00:01:59,840
which means that as a tool builder this

00:01:59,280 --> 00:02:03,600
is

00:01:59,840 --> 00:02:05,119
much cheaper to host because all the

00:02:03,600 --> 00:02:09,840
costly compute

00:02:05,119 --> 00:02:12,480
is distributed to the users

00:02:09,840 --> 00:02:14,560
it's also useful if the data is local

00:02:12,480 --> 00:02:16,640
and you're analyzing that data

00:02:14,560 --> 00:02:18,000
and it doesn't have to go in the cloud

00:02:16,640 --> 00:02:19,840
in that case it makes

00:02:18,000 --> 00:02:21,520
a lot of sense to use webassembly in the

00:02:19,840 --> 00:02:24,879
browser

00:02:21,520 --> 00:02:28,239
but you know what if these assumptions

00:02:24,879 --> 00:02:29,680
don't pan out what if you can't leverage

00:02:28,239 --> 00:02:32,800
the user's compute power

00:02:29,680 --> 00:02:34,800
what if the data is not local and so if

00:02:32,800 --> 00:02:37,200
that data for example is in the cloud

00:02:34,800 --> 00:02:39,840
and it's pretty large you don't want to

00:02:37,200 --> 00:02:42,160
start download loading large data files

00:02:39,840 --> 00:02:45,599
to your user's browser just so you can

00:02:42,160 --> 00:02:48,160
run the webassembly there

00:02:45,599 --> 00:02:48,959
so a few alternatives that one is you

00:02:48,160 --> 00:02:52,239
know just

00:02:48,959 --> 00:02:54,480
run it in the cloud spin up some vms

00:02:52,239 --> 00:02:55,519
download the data locally run the

00:02:54,480 --> 00:02:57,519
analysis

00:02:55,519 --> 00:02:58,959
save the results and then shut down the

00:02:57,519 --> 00:03:01,519
vm

00:02:58,959 --> 00:03:03,680
you can even use more specialized things

00:03:01,519 --> 00:03:05,920
like aws batch where you can essentially

00:03:03,680 --> 00:03:08,800
develop a whole pipeline

00:03:05,920 --> 00:03:09,599
of tools and then each step can have its

00:03:08,800 --> 00:03:13,920
own

00:03:09,599 --> 00:03:13,920
set of cpu and ram needs

00:03:14,319 --> 00:03:19,280
an alternative to that would be

00:03:17,599 --> 00:03:21,920
serverless functions

00:03:19,280 --> 00:03:24,159
you know analysis in the cloud is is

00:03:21,920 --> 00:03:26,879
very nice but it's also

00:03:24,159 --> 00:03:28,080
can be pretty costly and adds up pretty

00:03:26,879 --> 00:03:30,840
quickly and so

00:03:28,080 --> 00:03:33,200
serverless functions can be an

00:03:30,840 --> 00:03:34,480
alternative for example lambda or google

00:03:33,200 --> 00:03:37,920
cloud functions

00:03:34,480 --> 00:03:41,120
where you can essentially

00:03:37,920 --> 00:03:42,640
have scaling done for you so you don't

00:03:41,120 --> 00:03:45,680
have to worry about that

00:03:42,640 --> 00:03:48,159
and the pricing is kind of on a per use

00:03:45,680 --> 00:03:52,080
basis

00:03:48,159 --> 00:03:53,840
but in this talk i do want to focus on

00:03:52,080 --> 00:03:55,920
one particular flavor of serverless

00:03:53,840 --> 00:03:59,040
functions namely those that are

00:03:55,920 --> 00:04:03,120
specifically webassembly focused

00:03:59,040 --> 00:04:03,120
for example cloudflare and fastly

00:04:03,280 --> 00:04:06,480
you know the benefits of those are

00:04:05,280 --> 00:04:08,239
basically the same

00:04:06,480 --> 00:04:10,080
as the serverless functions but on top

00:04:08,239 --> 00:04:12,720
of that

00:04:10,080 --> 00:04:14,879
because webassembly is so light compared

00:04:12,720 --> 00:04:18,479
to something like a container

00:04:14,879 --> 00:04:21,519
it is easier for serverless providers

00:04:18,479 --> 00:04:24,880
to make that function have very

00:04:21,519 --> 00:04:27,600
little cold starts or none whatsoever

00:04:24,880 --> 00:04:29,280
and so that can be really important if

00:04:27,600 --> 00:04:30,479
your functions are short-lived in the

00:04:29,280 --> 00:04:31,840
first place

00:04:30,479 --> 00:04:33,840
you don't want to have to wait for

00:04:31,840 --> 00:04:37,280
hundreds of milliseconds before

00:04:33,840 --> 00:04:40,240
your function even initializes

00:04:37,280 --> 00:04:42,639
it's also neat because you can now use

00:04:40,240 --> 00:04:45,840
webassembly both in the browser

00:04:42,639 --> 00:04:47,919
and in a serverless function

00:04:45,840 --> 00:04:49,600
and you know obviously you can do that

00:04:47,919 --> 00:04:53,120
today with javascript

00:04:49,600 --> 00:04:55,120
but with this you don't need your tools

00:04:53,120 --> 00:04:57,440
to be already written in javascript you

00:04:55,120 --> 00:04:58,560
could take things within other languages

00:04:57,440 --> 00:05:01,120
and that's really the beauty of

00:04:58,560 --> 00:05:05,840
webassembly is that you can then

00:05:01,120 --> 00:05:05,840
run these tools wherever you see fit

00:05:07,039 --> 00:05:10,720
so let's let's take a look at a concrete

00:05:09,199 --> 00:05:14,400
example of this

00:05:10,720 --> 00:05:15,600
so the application here is to build an

00:05:14,400 --> 00:05:18,240
api

00:05:15,600 --> 00:05:20,479
that simulates data from a dna

00:05:18,240 --> 00:05:22,160
sequencing experiment

00:05:20,479 --> 00:05:24,240
and so what that's going to look like is

00:05:22,160 --> 00:05:25,919
you call the api

00:05:24,240 --> 00:05:28,320
it does some analysis and then it

00:05:25,919 --> 00:05:30,800
outputs some simulated

00:05:28,320 --> 00:05:31,759
dna sequences and so what that looks

00:05:30,800 --> 00:05:34,960
like is just

00:05:31,759 --> 00:05:36,800
strings of a's c's t's and g's that

00:05:34,960 --> 00:05:39,440
represent

00:05:36,800 --> 00:05:40,080
the genetic code essentially and so what

00:05:39,440 --> 00:05:43,919
we want to do

00:05:40,080 --> 00:05:47,680
is have these simulations that

00:05:43,919 --> 00:05:48,560
simulate errors during the experiment

00:05:47,680 --> 00:05:50,840
but also

00:05:48,560 --> 00:05:52,800
you know genetic variations between

00:05:50,840 --> 00:05:54,800
individuals

00:05:52,800 --> 00:05:56,000
and so to do that simulation we're going

00:05:54,800 --> 00:05:59,520
to use

00:05:56,000 --> 00:06:02,160
cloudflare workers and i'll talk

00:05:59,520 --> 00:06:03,600
later on why that is but basically the

00:06:02,160 --> 00:06:06,880
very powerful

00:06:03,600 --> 00:06:09,680
local starts runs at the edge

00:06:06,880 --> 00:06:11,759
but to do the actual simulation itself

00:06:09,680 --> 00:06:14,400
we're going to rely on a tool called wg

00:06:11,759 --> 00:06:16,240
sim now this is a tool that's commonly

00:06:14,400 --> 00:06:19,759
used in bioinformatics

00:06:16,240 --> 00:06:21,520
to simulate dna sequences as it happens

00:06:19,759 --> 00:06:23,759
it's written in c

00:06:21,520 --> 00:06:24,560
and so we can compile it to webassembly

00:06:23,759 --> 00:06:28,160
and run it

00:06:24,560 --> 00:06:28,160
as part of that api call

00:06:28,479 --> 00:06:35,840
now one thing to note is that wg sim

00:06:32,479 --> 00:06:38,400
can't run on its own it needs in

00:06:35,840 --> 00:06:40,000
some initial data to start with and so

00:06:38,400 --> 00:06:44,720
it needs

00:06:40,000 --> 00:06:47,919
a reference sequence so that it can

00:06:44,720 --> 00:06:49,840
on top of that make small changes

00:06:47,919 --> 00:06:51,759
randomly

00:06:49,840 --> 00:06:53,199
and so that reference genome we're going

00:06:51,759 --> 00:06:56,560
to store on s3

00:06:53,199 --> 00:06:59,520
and fetch a subset of it on

00:06:56,560 --> 00:06:59,520
each api call

00:07:00,000 --> 00:07:04,319
one thing to keep in mind though is that

00:07:02,319 --> 00:07:07,599
cloudflare workers are limited

00:07:04,319 --> 00:07:10,720
to 128 megabytes of ram

00:07:07,599 --> 00:07:12,880
for now um and

00:07:10,720 --> 00:07:14,400
to get around that limitation what we

00:07:12,880 --> 00:07:17,440
have to do

00:07:14,400 --> 00:07:19,120
is not keep in memory all the data and

00:07:17,440 --> 00:07:21,759
then send it what we have to do is

00:07:19,120 --> 00:07:24,800
essentially stream the data in

00:07:21,759 --> 00:07:27,599
from s3 run the simulation

00:07:24,800 --> 00:07:29,120
and stream the data out as we have it to

00:07:27,599 --> 00:07:32,160
the user

00:07:29,120 --> 00:07:33,120
so this would let us for example output

00:07:32,160 --> 00:07:37,440
a lot more

00:07:33,120 --> 00:07:37,440
than 128 megabytes of data

00:07:38,960 --> 00:07:43,680
what's neat about this architecture also

00:07:41,360 --> 00:07:46,000
is that i can run the same thing

00:07:43,680 --> 00:07:46,879
in the browser or as a serverless

00:07:46,000 --> 00:07:49,280
function

00:07:46,879 --> 00:07:50,400
in this case it makes sense for the

00:07:49,280 --> 00:07:51,680
serverless function

00:07:50,400 --> 00:07:55,360
but there are cases where you can

00:07:51,680 --> 00:07:57,360
imagine you want to run things

00:07:55,360 --> 00:07:59,039
both in the browser and the those

00:07:57,360 --> 00:08:01,280
functions depending

00:07:59,039 --> 00:08:04,400
on where the data comes from is it local

00:08:01,280 --> 00:08:04,400
or is it already in the cloud

00:08:05,919 --> 00:08:09,120
so as a demonstration i've deployed this

00:08:08,800 --> 00:08:12,800
to

00:08:09,120 --> 00:08:13,919
wg sim.sandbox.bio this is the api

00:08:12,800 --> 00:08:15,440
endpoint

00:08:13,919 --> 00:08:17,680
you can tell it how many sequences you

00:08:15,440 --> 00:08:18,639
want which chromosome you're interested

00:08:17,680 --> 00:08:20,560
in

00:08:18,639 --> 00:08:22,879
and the error rate that you want to

00:08:20,560 --> 00:08:24,400
simulate so if you go to that endpoint

00:08:22,879 --> 00:08:27,919
you will see

00:08:24,400 --> 00:08:29,199
this big mess of a result uh this is

00:08:27,919 --> 00:08:32,399
actually

00:08:29,199 --> 00:08:34,240
a file format in bioinformatics called

00:08:32,399 --> 00:08:36,959
fastq

00:08:34,240 --> 00:08:38,560
it's not the prettiest but you can

00:08:36,959 --> 00:08:41,039
ignore most of this

00:08:38,560 --> 00:08:42,719
and focus on the actual dna sequences

00:08:41,039 --> 00:08:45,200
and so this is what

00:08:42,719 --> 00:08:46,959
we want to simulate and so if we were to

00:08:45,200 --> 00:08:50,160
refresh we can get

00:08:46,959 --> 00:08:53,760
different simulated dna sequences from

00:08:50,160 --> 00:08:57,279
random regions in chromosome 1.

00:08:53,760 --> 00:08:58,959
so this works it's fast it's scalable

00:08:57,279 --> 00:09:02,080
it's cost effective

00:08:58,959 --> 00:09:04,720
um and so you may be wondering well

00:09:02,080 --> 00:09:06,000
why why did i use cloudflare workers for

00:09:04,720 --> 00:09:08,399
this so i wanted to

00:09:06,000 --> 00:09:09,760
talk a bit more about that and just as a

00:09:08,399 --> 00:09:12,800
side note i'm not

00:09:09,760 --> 00:09:15,360
affiliated with cloudflare i'm this is

00:09:12,800 --> 00:09:18,800
just my personal opinion

00:09:15,360 --> 00:09:20,240
so one reason is you know like any other

00:09:18,800 --> 00:09:22,560
serverless provider they give you

00:09:20,240 --> 00:09:24,399
the scalability of the paper use but

00:09:22,560 --> 00:09:27,920
they also

00:09:24,399 --> 00:09:30,720
give you first class webassembly support

00:09:27,920 --> 00:09:31,600
and in part because of that they are

00:09:30,720 --> 00:09:34,160
able

00:09:31,600 --> 00:09:36,720
to reduce their cold start so that

00:09:34,160 --> 00:09:38,399
they're non-existent

00:09:36,720 --> 00:09:41,120
you know again because webassembly is so

00:09:38,399 --> 00:09:44,880
light compared to containers

00:09:41,120 --> 00:09:47,839
um and so so actually

00:09:44,880 --> 00:09:49,279
workers used to have a five millisecond

00:09:47,839 --> 00:09:52,720
coil start and then

00:09:49,279 --> 00:09:54,959
they recently modified it so that

00:09:52,720 --> 00:09:55,920
when you make an api call during the

00:09:54,959 --> 00:09:58,480
https

00:09:55,920 --> 00:09:59,680
handshake they actually warm up your

00:09:58,480 --> 00:10:02,079
function then

00:09:59,680 --> 00:10:02,800
and so by the time the handshake is done

00:10:02,079 --> 00:10:06,880
it

00:10:02,800 --> 00:10:06,880
starts executing it's very cool

00:10:07,519 --> 00:10:11,360
the other thing that's neat is that this

00:10:09,040 --> 00:10:15,440
is powered by v8

00:10:11,360 --> 00:10:18,079
and so v8 is the chrome browser's

00:10:15,440 --> 00:10:20,320
engine that executes javascript and

00:10:18,079 --> 00:10:22,720
webassembly

00:10:20,320 --> 00:10:23,600
and you know the reason why i mentioned

00:10:22,720 --> 00:10:26,399
this

00:10:23,600 --> 00:10:27,920
as an advantage and not just as a random

00:10:26,399 --> 00:10:30,000
trivia fact

00:10:27,920 --> 00:10:31,680
is because this means when you're

00:10:30,000 --> 00:10:33,519
running webassembly binaries on

00:10:31,680 --> 00:10:36,079
cloudflare workers

00:10:33,519 --> 00:10:38,640
you're still running them in browsers it

00:10:36,079 --> 00:10:42,320
just so happens that that browser

00:10:38,640 --> 00:10:44,839
is hosted in the cloud and so

00:10:42,320 --> 00:10:46,640
what that means is you know like i said

00:10:44,839 --> 00:10:48,000
earlier

00:10:46,640 --> 00:10:50,320
we can be in a point where we can use

00:10:48,000 --> 00:10:51,200
webassembly in the front and end of the

00:10:50,320 --> 00:10:53,120
back end

00:10:51,200 --> 00:10:56,160
well this takes it a step further where

00:10:53,120 --> 00:10:59,760
we use the exact same

00:10:56,160 --> 00:11:03,120
wasm binaries in our browser

00:10:59,760 --> 00:11:06,000
and in cloudflare's browser and which is

00:11:03,120 --> 00:11:09,680
really powerful if you're building tools

00:11:06,000 --> 00:11:09,680
that need to run in both places

00:11:10,959 --> 00:11:14,160
the other thing that's really good is

00:11:12,720 --> 00:11:18,720
the debugging

00:11:14,160 --> 00:11:21,440
experience and just to demonstrate it

00:11:18,720 --> 00:11:22,560
this is what it looks like when i'm

00:11:21,440 --> 00:11:25,279
looking at

00:11:22,560 --> 00:11:26,959
my wg sim script so this is the

00:11:25,279 --> 00:11:28,800
javascript code part

00:11:26,959 --> 00:11:30,480
and so what i can do is come over here

00:11:28,800 --> 00:11:33,200
and click send

00:11:30,480 --> 00:11:34,160
this will execute the code on cloudflare

00:11:33,200 --> 00:11:37,760
servers

00:11:34,160 --> 00:11:41,040
and return the result right here

00:11:37,760 --> 00:11:42,880
so far so good no no this is really

00:11:41,040 --> 00:11:45,040
earth shattering but

00:11:42,880 --> 00:11:47,760
what's really neat is this part over

00:11:45,040 --> 00:11:50,160
here which is the developer tools

00:11:47,760 --> 00:11:52,079
this is not the developer tools in my

00:11:50,160 --> 00:11:55,040
browser

00:11:52,079 --> 00:11:56,399
in a way it's a developer tools and in

00:11:55,040 --> 00:11:59,360
the browser that

00:11:56,399 --> 00:12:00,079
executes your code and you can actually

00:11:59,360 --> 00:12:02,720
look

00:12:00,079 --> 00:12:04,880
behind the scenes what's happening so if

00:12:02,720 --> 00:12:06,959
you remember i mentioned that

00:12:04,880 --> 00:12:09,200
our algorithm needs to reach out to s3

00:12:06,959 --> 00:12:10,079
first to download some reference data

00:12:09,200 --> 00:12:11,519
and so

00:12:10,079 --> 00:12:13,360
you can actually see that by going to

00:12:11,519 --> 00:12:16,000
the network tab

00:12:13,360 --> 00:12:16,480
and you can see that it actually click

00:12:16,000 --> 00:12:20,079
on it

00:12:16,480 --> 00:12:23,120
it reaches out to amazon aws

00:12:20,079 --> 00:12:24,959
and fetches some data and we can preview

00:12:23,120 --> 00:12:27,040
it this is

00:12:24,959 --> 00:12:28,720
the sequence that is being used as a

00:12:27,040 --> 00:12:30,160
starting point

00:12:28,720 --> 00:12:32,560
by the algorithm and then it does

00:12:30,160 --> 00:12:34,720
mutations on top of that and so

00:12:32,560 --> 00:12:36,240
what's what's beautiful is that this is

00:12:34,720 --> 00:12:41,600
not running

00:12:36,240 --> 00:12:45,120
on my browser but it lets us get a view

00:12:41,600 --> 00:12:47,120
into the execution platform

00:12:45,120 --> 00:12:48,560
another neat application is the

00:12:47,120 --> 00:12:50,880
javascript profiler

00:12:48,560 --> 00:12:52,399
this lets you see which parts of your

00:12:50,880 --> 00:12:55,279
code are taking

00:12:52,399 --> 00:12:56,480
the most time another thing i wanted to

00:12:55,279 --> 00:13:00,160
demonstrate is

00:12:56,480 --> 00:13:03,120
if you modify this script

00:13:00,160 --> 00:13:04,560
you can actually rerun it without

00:13:03,120 --> 00:13:06,560
deploying the changes

00:13:04,560 --> 00:13:09,760
so for example if we went over here and

00:13:06,560 --> 00:13:12,240
added a console.log statement

00:13:09,760 --> 00:13:14,720
you could then come here and click send

00:13:12,240 --> 00:13:17,760
you see this refreshed

00:13:14,720 --> 00:13:19,839
this it says the script was modified

00:13:17,760 --> 00:13:20,959
and so we can see the console.log

00:13:19,839 --> 00:13:24,079
statement you know

00:13:20,959 --> 00:13:26,000
and again this this console log did not

00:13:24,079 --> 00:13:28,720
execute on my browser

00:13:26,000 --> 00:13:32,160
um executed on cloudflare servers but

00:13:28,720 --> 00:13:35,279
we're able to to see the output of that

00:13:32,160 --> 00:13:38,480
which makes it a lot easier to debug

00:13:35,279 --> 00:13:38,480
these kinds of applications

00:13:40,720 --> 00:13:43,920
the other thing that's useful is a key

00:13:42,160 --> 00:13:46,560
value store so if you want to

00:13:43,920 --> 00:13:48,000
store key value pairs that's kale this

00:13:46,560 --> 00:13:51,120
is really good for that

00:13:48,000 --> 00:13:53,680
especially for read heavy applications

00:13:51,120 --> 00:13:55,839
so one thing i've used this for recently

00:13:53,680 --> 00:13:58,959
is for storing permalinks

00:13:55,839 --> 00:13:59,440
so there's this app where you give it

00:13:58,959 --> 00:14:02,800
your

00:13:59,440 --> 00:14:05,519
your local data it analyzes it

00:14:02,800 --> 00:14:07,120
stores the results into a key value

00:14:05,519 --> 00:14:07,920
store and gives you a permalink that you

00:14:07,120 --> 00:14:10,079
can share

00:14:07,920 --> 00:14:11,839
with others so they could see the

00:14:10,079 --> 00:14:14,399
results without

00:14:11,839 --> 00:14:14,880
having your input data and so this is a

00:14:14,399 --> 00:14:18,320
great

00:14:14,880 --> 00:14:18,320
place to store that kind of thing

00:14:19,360 --> 00:14:24,160
other useful tools are cron jobs

00:14:22,399 --> 00:14:26,160
so you can run your javascript and web

00:14:24,160 --> 00:14:28,720
assembly on demand

00:14:26,160 --> 00:14:30,959
via an api call but you can also have

00:14:28,720 --> 00:14:34,399
them run at schedules

00:14:30,959 --> 00:14:36,240
so for example i have a script that runs

00:14:34,399 --> 00:14:39,199
every half an hour

00:14:36,240 --> 00:14:41,199
looks at some recent logs calculates

00:14:39,199 --> 00:14:43,360
summary statistics

00:14:41,199 --> 00:14:45,199
and stores the results in the key value

00:14:43,360 --> 00:14:46,240
store so that way when i go to the

00:14:45,199 --> 00:14:49,279
statistics page

00:14:46,240 --> 00:14:50,800
it just pulls the cached results

00:14:49,279 --> 00:14:54,399
from the key value store and doesn't

00:14:50,800 --> 00:14:54,399
have to recompute them every time

00:14:55,920 --> 00:14:59,120
in terms of the limitations so as i

00:14:58,639 --> 00:15:02,639
mentioned

00:14:59,120 --> 00:15:04,880
128 megabytes of ram

00:15:02,639 --> 00:15:06,160
and in terms of cpu we're talking about

00:15:04,880 --> 00:15:10,000
30 seconds

00:15:06,160 --> 00:15:11,519
for workers unbound

00:15:10,000 --> 00:15:13,839
you know as i mentioned you know

00:15:11,519 --> 00:15:16,560
asterisk this is the current limits

00:15:13,839 --> 00:15:17,360
it's possible that these limits get

00:15:16,560 --> 00:15:20,079
increased

00:15:17,360 --> 00:15:20,079
over time

00:15:21,120 --> 00:15:25,199
and yeah that is all i had to share

00:15:24,240 --> 00:15:27,680
today

00:15:25,199 --> 00:15:28,959
if you enjoyed this presentation and

00:15:27,680 --> 00:15:30,000
you're just getting started with

00:15:28,959 --> 00:15:32,720
webassembly

00:15:30,000 --> 00:15:34,320
you can check out my book level up with

00:15:32,720 --> 00:15:36,480
webassembly

00:15:34,320 --> 00:15:38,399
and i do also have a whole bunch of free

00:15:36,480 --> 00:15:40,639
articles and videos that you can check

00:15:38,399 --> 00:15:43,000
out as well

00:15:40,639 --> 00:15:46,000
with that thank you very much for your

00:15:43,000 --> 00:15:46,000

YouTube URL: https://www.youtube.com/watch?v=IuQxONAaRjA


