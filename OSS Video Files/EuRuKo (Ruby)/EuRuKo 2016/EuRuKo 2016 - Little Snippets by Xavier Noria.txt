Title: EuRuKo 2016 - Little Snippets by Xavier Noria
Publication date: 2016-10-11
Playlist: EuRuKo 2016
Description: 
	
Captions: 
	00:00:03,930 --> 00:00:12,000
so our next speaker Shavian oriya from

00:00:08,830 --> 00:00:16,900
barcelona he's in independent

00:00:12,000 --> 00:00:21,700
ruby-on-rails consultant and also a core

00:00:16,900 --> 00:00:25,360
team member so for ruby on rails so

00:00:21,700 --> 00:00:26,950
young well his contributions whenever

00:00:25,360 --> 00:00:30,190
you go to contributors thought

00:00:26,950 --> 00:00:33,489
ruby-on-rails calm or you reference a

00:00:30,190 --> 00:00:38,320
constant without requiring it that's

00:00:33,489 --> 00:00:41,340
thanks to him so enjoy your talk and see

00:00:38,320 --> 00:00:41,340
you in a minute fine

00:00:46,860 --> 00:00:57,460
okay sounds good yeah say okay all right

00:00:52,360 --> 00:01:03,370
so so as many of you I've been farming

00:00:57,460 --> 00:01:07,360
for some years and have read a good deal

00:01:03,370 --> 00:01:09,940
of source code you know especially I

00:01:07,360 --> 00:01:13,930
don't know in the last 10 12 years view

00:01:09,940 --> 00:01:18,640
to my involvement in open source and and

00:01:13,930 --> 00:01:21,330
my consultant work and with about the

00:01:18,640 --> 00:01:26,470
years to develop like intuitions about

00:01:21,330 --> 00:01:29,380
good code some of those intuitions or

00:01:26,470 --> 00:01:33,310
some of those personal preferences about

00:01:29,380 --> 00:01:37,899
what makes good coat of high-level like

00:01:33,310 --> 00:01:42,580
I don't know like object-oriented design

00:01:37,899 --> 00:01:46,080
like how to organize code usability of

00:01:42,580 --> 00:01:50,890
api's know that kind of things but

00:01:46,080 --> 00:01:53,829
sometimes you develop also intuitions

00:01:50,890 --> 00:01:55,780
for those tiny details in the source

00:01:53,829 --> 00:01:59,280
code you know not only the big feature

00:01:55,780 --> 00:02:03,450
but also little things that matter and

00:01:59,280 --> 00:02:03,450
this talk is about those little things

00:02:03,899 --> 00:02:12,370
so we are going to go through a series

00:02:07,450 --> 00:02:17,850
of a real real code that has like one

00:02:12,370 --> 00:02:21,549
line maybe just a bunch of lines and and

00:02:17,850 --> 00:02:24,730
reflect about it because isn't it is not

00:02:21,549 --> 00:02:26,500
only a talk about best practices

00:02:24,730 --> 00:02:30,519
something like that it is in some sense

00:02:26,500 --> 00:02:33,070
but also it is a talk in which i invite

00:02:30,519 --> 00:02:36,280
you to introspect a little bit and

00:02:33,070 --> 00:02:39,010
reflect and verbalize our thought

00:02:36,280 --> 00:02:41,440
process why why do we believe that

00:02:39,010 --> 00:02:45,010
something can be refactor or something

00:02:41,440 --> 00:02:49,269
you know that tiny thing it's important

00:02:45,010 --> 00:02:54,040
so later okay and there's going to be

00:02:49,269 --> 00:02:57,190
opinions in this talk so I would like to

00:02:54,040 --> 00:02:59,290
to say something about about these kind

00:02:57,190 --> 00:03:05,290
of things about opinions and discussions

00:02:59,290 --> 00:03:07,780
and the thing is that often in

00:03:05,290 --> 00:03:12,010
discussions either online or personally

00:03:07,780 --> 00:03:14,489
we phrase things in a way that is more

00:03:12,010 --> 00:03:18,040
or less like these are my reasonings and

00:03:14,489 --> 00:03:20,819
you were the thing as if your preference

00:03:18,040 --> 00:03:25,150
or you know the option you you want to

00:03:20,819 --> 00:03:28,299
you prefer follows from that you know

00:03:25,150 --> 00:03:30,159
it's a consequence of that like it was

00:03:28,299 --> 00:03:34,150
the natural consequence the absolute

00:03:30,159 --> 00:03:36,280
consequences and and life is not an

00:03:34,150 --> 00:03:37,959
axiomatic system you know so there's no

00:03:36,280 --> 00:03:42,489
first order logic here to apply

00:03:37,959 --> 00:03:45,609
generally so most of the time what you

00:03:42,489 --> 00:03:47,139
are doing really is you have it goes the

00:03:45,609 --> 00:03:49,870
other way around you have some

00:03:47,139 --> 00:03:52,569
preference and you and then you have

00:03:49,870 --> 00:03:57,750
some reasons that for you work and the

00:03:52,569 --> 00:04:02,200
preference you know is your choice but

00:03:57,750 --> 00:04:03,970
but those but that reasoning is part of

00:04:02,200 --> 00:04:06,909
your background is part of your trade

00:04:03,970 --> 00:04:10,690
offs is part of how your brain works so

00:04:06,909 --> 00:04:13,359
when you when two people discuss the

00:04:10,690 --> 00:04:15,129
intersection of reasonings and the

00:04:13,359 --> 00:04:19,599
trade-offs and you know that kind of

00:04:15,129 --> 00:04:23,320
thing is very fuzzy okay so let's let's

00:04:19,599 --> 00:04:27,190
do an example with code okay we have

00:04:23,320 --> 00:04:30,550
here a hash and now we are going to to

00:04:27,190 --> 00:04:32,650
see a little bit different this hash the

00:04:30,550 --> 00:04:36,490
difference is in that comma you see that

00:04:32,650 --> 00:04:43,510
common okay do you feel the tension with

00:04:36,490 --> 00:04:45,310
that comma so for some people the the

00:04:43,510 --> 00:04:49,479
one at the bottom is the preferred one

00:04:45,310 --> 00:04:52,120
and some arguments are like it's easier

00:04:49,479 --> 00:04:55,750
to add something I statics because i

00:04:52,120 --> 00:04:57,490
have a comma everywhere and the if i add

00:04:55,750 --> 00:04:59,139
something the patch is going to be

00:04:57,490 --> 00:05:01,870
cleaner because it's only the line i am

00:04:59,139 --> 00:05:05,229
talking but other people don't care

00:05:01,870 --> 00:05:07,389
about that so this is you you value a

00:05:05,229 --> 00:05:10,570
cost-benefit here that other people do

00:05:07,389 --> 00:05:13,120
not perceive the same way so for other

00:05:10,570 --> 00:05:15,940
people are what they see

00:05:13,120 --> 00:05:17,740
here is a missing element so the brain

00:05:15,940 --> 00:05:20,460
parsing here says doesn't missing

00:05:17,740 --> 00:05:22,630
element here okay so different pains

00:05:20,460 --> 00:05:24,669
which is the right answer to this

00:05:22,630 --> 00:05:30,430
there's no right answer it all depends

00:05:24,669 --> 00:05:35,260
on everyone and so wording things that

00:05:30,430 --> 00:05:37,780
acknowledge this I believe it's it's a

00:05:35,260 --> 00:05:39,340
good thing to do in discussions like

00:05:37,780 --> 00:05:40,780
always our knowledge that there's

00:05:39,340 --> 00:05:44,580
something subjective that's something

00:05:40,780 --> 00:05:47,860
personal in the way you are reasoning so

00:05:44,580 --> 00:05:49,660
introducing in my opinion in my view you

00:05:47,860 --> 00:05:52,270
know that kind of things kind of relax

00:05:49,660 --> 00:05:56,380
and takes you know something of the

00:05:52,270 --> 00:05:59,770
absolute tone out of the discussion so

00:05:56,380 --> 00:06:02,440
saying that the entire talk is going to

00:05:59,770 --> 00:06:05,289
be in my view okay so we have like a

00:06:02,440 --> 00:06:08,440
global thing that says this is all in my

00:06:05,289 --> 00:06:11,110
view all right now if in some is light I

00:06:08,440 --> 00:06:14,740
don't see I don't say it's implicit okay

00:06:11,110 --> 00:06:18,789
in my view I'm going to to say a number

00:06:14,740 --> 00:06:20,860
of things also I'm going to speculate so

00:06:18,789 --> 00:06:24,010
I'm going to put myself you know I'm

00:06:20,860 --> 00:06:26,770
going to toggle this this this this flag

00:06:24,010 --> 00:06:30,190
and allow myself to speculate and

00:06:26,770 --> 00:06:33,510
sometimes and and explain why I believe

00:06:30,190 --> 00:06:37,599
some some things are the way they are

00:06:33,510 --> 00:06:41,590
all right so we're going to start

00:06:37,599 --> 00:06:44,639
talking about conciseness conciseness is

00:06:41,590 --> 00:06:46,660
using three words are not including

00:06:44,639 --> 00:06:49,270
extra or in the necessary information

00:06:46,660 --> 00:06:53,530
this is our definition I took four from

00:06:49,270 --> 00:06:55,449
some dictionary and it mostly applies to

00:06:53,530 --> 00:06:58,349
natural language okay but we also know

00:06:55,449 --> 00:07:01,750
that it applies to programming languages

00:06:58,349 --> 00:07:04,780
let's take this example so in this

00:07:01,750 --> 00:07:08,020
example we have a collection which is

00:07:04,780 --> 00:07:14,169
remote and then we sort it and take the

00:07:08,020 --> 00:07:16,690
last element okay so there's a more

00:07:14,169 --> 00:07:20,050
concise way to say this which is to take

00:07:16,690 --> 00:07:23,050
the max element okay and the first

00:07:20,050 --> 00:07:25,419
version makes you think more and it does

00:07:23,050 --> 00:07:26,920
more stuff because you are you have to

00:07:25,419 --> 00:07:28,690
sort the entire collection and

00:07:26,920 --> 00:07:32,050
and you take the last and then when you

00:07:28,690 --> 00:07:34,870
read this code you have to you have to

00:07:32,050 --> 00:07:36,580
infer that you are going for the max

00:07:34,870 --> 00:07:39,040
element you have to infer it it's not

00:07:36,580 --> 00:07:41,680
clear okay so you have to say okay you

00:07:39,040 --> 00:07:44,470
have to connect the dots I'm sorting

00:07:41,680 --> 00:07:47,610
then I therefore I'm going for the max

00:07:44,470 --> 00:07:51,660
if you if you put the max here it's

00:07:47,610 --> 00:07:54,700
instantly clear all right so conciseness

00:07:51,660 --> 00:07:59,050
translates in programming to a number of

00:07:54,700 --> 00:08:03,070
things generally so generally it means

00:07:59,050 --> 00:08:05,260
that you choose the most specific API

00:08:03,070 --> 00:08:09,070
call that that you have like in the

00:08:05,260 --> 00:08:14,170
previous case often it involves less

00:08:09,070 --> 00:08:17,550
code Oh often the code is more clear you

00:08:14,170 --> 00:08:22,060
apply Occam's razor Occam's razor in

00:08:17,550 --> 00:08:24,850
several angles because first you ask

00:08:22,060 --> 00:08:29,560
specifically about what you need when

00:08:24,850 --> 00:08:32,650
you write concise code and you are able

00:08:29,560 --> 00:08:36,520
to express yourself with precision and

00:08:32,650 --> 00:08:38,710
also the reader of your code has this

00:08:36,520 --> 00:08:41,010
this benefit because it's more clear

00:08:38,710 --> 00:08:44,770
more direct for the reader of the code

00:08:41,010 --> 00:08:47,530
which is the intention and as a

00:08:44,770 --> 00:08:49,870
consequence often and I am saying often

00:08:47,530 --> 00:08:53,020
in every it I item because this is not

00:08:49,870 --> 00:08:55,000
like always the case but often you get

00:08:53,020 --> 00:08:57,580
better performance because if you ask

00:08:55,000 --> 00:09:00,790
specifically what all you need to a

00:08:57,580 --> 00:09:02,320
library or an interpreter generally the

00:09:00,790 --> 00:09:04,930
code that is going to implement that

00:09:02,320 --> 00:09:06,430
takes advantage that it only has to

00:09:04,930 --> 00:09:10,290
solve that particular problem so

00:09:06,430 --> 00:09:10,290
generally you get better performance

00:09:11,250 --> 00:09:16,540
this one's for instance are taking the

00:09:14,350 --> 00:09:18,880
keys of a hash and then asked for

00:09:16,540 --> 00:09:24,100
include here we have an IEP I for that

00:09:18,880 --> 00:09:28,270
right this one is opening a file to damp

00:09:24,100 --> 00:09:32,250
an entire text into the file and this

00:09:28,270 --> 00:09:36,100
case this was the idiom in in 18 and

00:09:32,250 --> 00:09:40,740
still you see this this code oh there

00:09:36,100 --> 00:09:40,740
but we have no an API for doing this

00:09:43,650 --> 00:09:49,830
when I do reviews of raids applications

00:09:46,780 --> 00:09:52,330
are to my surprise this kind of code

00:09:49,830 --> 00:09:57,130
appears free with with some frequency

00:09:52,330 --> 00:10:00,430
and I believe and that's a speculation

00:09:57,130 --> 00:10:03,190
mode I believe people writing this kind

00:10:00,430 --> 00:10:05,770
of code are not thinking about using an

00:10:03,190 --> 00:10:09,040
over m and the API instructions that the

00:10:05,770 --> 00:10:12,370
other RM provides they are so this

00:10:09,040 --> 00:10:16,810
translates very directly to a select ok

00:10:12,370 --> 00:10:21,460
so so I believe you are thinking here in

00:10:16,810 --> 00:10:25,330
SQL and you know doing with Ruby the

00:10:21,460 --> 00:10:28,240
Select but the point of the army of your

00:10:25,330 --> 00:10:30,370
RM is to use the abstraction so it's

00:10:28,240 --> 00:10:33,220
much more pleasant to say user the past

00:10:30,370 --> 00:10:35,170
you are right you are working at the

00:10:33,220 --> 00:10:37,030
model level you know you your

00:10:35,170 --> 00:10:44,050
abstraction is closer to the problem

00:10:37,030 --> 00:10:46,840
domain and and an oem has not be so an

00:10:44,050 --> 00:10:49,900
Orion is not a black box you have to

00:10:46,840 --> 00:10:55,180
know exactly what the doc what did our M

00:10:49,900 --> 00:10:57,550
works so for me n orem is at least for

00:10:55,180 --> 00:11:00,780
doing queries is just an SQL generator

00:10:57,550 --> 00:11:04,090
so you have like a high level interface

00:11:00,780 --> 00:11:06,700
to generate SQL and you have to control

00:11:04,090 --> 00:11:08,650
what it's generating everything so you

00:11:06,700 --> 00:11:10,630
get the benefit of the generation and

00:11:08,650 --> 00:11:14,080
you have to know what is what is doing

00:11:10,630 --> 00:11:16,210
but you have but you have to work at the

00:11:14,080 --> 00:11:20,650
at this level of abstraction the model

00:11:16,210 --> 00:11:25,720
at the model level this I see often so

00:11:20,650 --> 00:11:29,770
in this case name is Anna string and for

00:11:25,720 --> 00:11:35,470
some reason you see the string

00:11:29,770 --> 00:11:40,050
interpolated in a string literal that no

00:11:35,470 --> 00:11:45,250
need to do that yes Perez name okay I

00:11:40,050 --> 00:11:49,180
wonder here if if people writing this

00:11:45,250 --> 00:11:53,670
kind of of code is thinking visually

00:11:49,180 --> 00:11:57,670
like you are you often right

00:11:53,670 --> 00:11:59,830
literals with with boots right so maybe

00:11:57,670 --> 00:12:01,480
then you have the inertia to write the

00:11:59,830 --> 00:12:04,780
literal because you are used to it and

00:12:01,480 --> 00:12:06,730
do not think that you don't you do not

00:12:04,780 --> 00:12:09,340
need it you know but visually you are

00:12:06,730 --> 00:12:13,210
used to see the codes next to place and

00:12:09,340 --> 00:12:18,270
maybe that you know that makes you do

00:12:13,210 --> 00:12:22,180
not realize that you gonna need it and

00:12:18,270 --> 00:12:25,480
this is this is a particularly frequent

00:12:22,180 --> 00:12:27,790
case of this thing which is you have

00:12:25,480 --> 00:12:30,520
meth innate that it's already a string

00:12:27,790 --> 00:12:35,530
and then you interpolate it to build the

00:12:30,520 --> 00:12:39,100
simple thing I see this often and maybe

00:12:35,530 --> 00:12:41,530
the reason here is that for instance for

00:12:39,100 --> 00:12:44,770
many years we have had to include

00:12:41,530 --> 00:12:48,370
modules dynamically using sin so when

00:12:44,770 --> 00:12:49,870
you write the literal you normally use a

00:12:48,370 --> 00:12:51,640
symbol you know is that that small

00:12:49,870 --> 00:12:54,790
that's more or less conventional you use

00:12:51,640 --> 00:12:56,340
a symbol so sin include something for

00:12:54,790 --> 00:13:02,380
active rep or whatever you know and

00:12:56,340 --> 00:13:04,570
maybe that's again inertia so so you use

00:13:02,380 --> 00:13:06,640
it visually to see the symbol and when

00:13:04,570 --> 00:13:10,810
you are dynamically building something

00:13:06,640 --> 00:13:12,910
you go for the symbol but other people

00:13:10,810 --> 00:13:16,240
write this to see but there's no need to

00:13:12,910 --> 00:13:25,680
do a sim because the string just works

00:13:16,240 --> 00:13:29,830
ok this is another one here we are

00:13:25,680 --> 00:13:32,260
testing for a substring you see so we

00:13:29,830 --> 00:13:38,080
are testing if the constant Ruby

00:13:32,260 --> 00:13:40,810
platform has java within this code looks

00:13:38,080 --> 00:13:45,070
like very lightweight but is doing a

00:13:40,810 --> 00:13:47,290
bunch of things so it this is a regular

00:13:45,070 --> 00:13:50,220
expression so there's there's an engine

00:13:47,290 --> 00:13:54,360
going on that is going to do the match

00:13:50,220 --> 00:13:56,830
that sounds or you'll be complicated

00:13:54,360 --> 00:13:58,600
also it's going to have a side effect

00:13:56,830 --> 00:14:02,290
like setting you know this these

00:13:58,600 --> 00:14:05,270
variables so which was the match which

00:14:02,290 --> 00:14:08,360
was the prefix of the match that what

00:14:05,270 --> 00:14:11,090
after that captures if there are

00:14:08,360 --> 00:14:15,800
captures and the bunch of side effects

00:14:11,090 --> 00:14:18,380
of running this code in 24 we are going

00:14:15,800 --> 00:14:20,720
to have a predicate which is more

00:14:18,380 --> 00:14:24,340
concise if you do not need anything of

00:14:20,720 --> 00:14:27,470
any of those side effects you can ask

00:14:24,340 --> 00:14:29,810
with the predicate to see you i only

00:14:27,470 --> 00:14:32,930
care if it matches and that it's going

00:14:29,810 --> 00:14:36,410
to return a boolean since the side

00:14:32,930 --> 00:14:38,180
effects do not need to be compute this

00:14:36,410 --> 00:14:42,410
is one of the cases where performance is

00:14:38,180 --> 00:14:45,140
much better because the gene enjoying

00:14:42,410 --> 00:14:49,160
sorry does not need to do all of that

00:14:45,140 --> 00:14:51,200
work and and the performance is like to

00:14:49,160 --> 00:14:56,240
fault or maybe a little bit more you

00:14:51,200 --> 00:14:59,270
know but also we have include in the in

00:14:56,240 --> 00:15:02,780
the in a string you can I suggest so we

00:14:59,270 --> 00:15:05,270
are looking for a substring the we have

00:15:02,780 --> 00:15:09,950
an API for doing that no need to go to a

00:15:05,270 --> 00:15:12,290
regular expression so normally i tend to

00:15:09,950 --> 00:15:16,520
i tend to use the last one include

00:15:12,290 --> 00:15:22,430
because it's kind of more it's more

00:15:16,520 --> 00:15:26,240
concise but i have also to say that the

00:15:22,430 --> 00:15:28,700
first one even even although with all

00:15:26,240 --> 00:15:35,390
the warnings that I've said somehow

00:15:28,700 --> 00:15:39,410
maybe reads better so in many cases I

00:15:35,390 --> 00:15:41,090
think there's no so the rel is there are

00:15:39,410 --> 00:15:44,350
a little bit of tension you know you

00:15:41,090 --> 00:15:46,790
maybe see the tension and maybe

00:15:44,350 --> 00:15:48,620
personally say ok I will go with this

00:15:46,790 --> 00:15:53,360
one but this is not like black and white

00:15:48,620 --> 00:15:55,780
so even even if if the first one is like

00:15:53,360 --> 00:15:58,030
not concise in a in this way

00:15:55,780 --> 00:16:05,150
superficially you don't see it and

00:15:58,030 --> 00:16:08,960
indeed if you are if you read this kind

00:16:05,150 --> 00:16:14,450
of pattern matching to look for

00:16:08,960 --> 00:16:17,210
substrings then when when you read this

00:16:14,450 --> 00:16:19,220
code and you are used to it you do not

00:16:17,210 --> 00:16:21,290
read it like I

00:16:19,220 --> 00:16:24,230
doing a battle matching and you know and

00:16:21,290 --> 00:16:28,910
all the stuff that is going on you you

00:16:24,230 --> 00:16:30,649
read it like a unit okay and that's for

00:16:28,910 --> 00:16:33,500
instance to say another example in other

00:16:30,649 --> 00:16:35,209
languages other languages for look if

00:16:33,500 --> 00:16:37,939
you want to look for a substring there's

00:16:35,209 --> 00:16:41,209
no api and they have to do this so you

00:16:37,939 --> 00:16:45,620
compute if there's a position within the

00:16:41,209 --> 00:16:47,870
string where the argument you know is

00:16:45,620 --> 00:16:50,120
contained and that gives you an integer

00:16:47,870 --> 00:16:53,930
and then you have to check whether it's

00:16:50,120 --> 00:16:57,379
in this case different from minus one so

00:16:53,930 --> 00:17:01,399
conceptually ah then I've said I've set

00:16:57,379 --> 00:17:04,189
a number of things okay but if you a

00:17:01,399 --> 00:17:07,010
programmer in a language that has this

00:17:04,189 --> 00:17:10,600
as a way to look for expressions indeed

00:17:07,010 --> 00:17:13,280
I believe you do not parse this

00:17:10,600 --> 00:17:16,250
following this reasoning so your brain

00:17:13,280 --> 00:17:19,220
is used to this construction and what's

00:17:16,250 --> 00:17:21,650
when it sees it automatically you know

00:17:19,220 --> 00:17:28,730
gets the unit and says okay i'm looking

00:17:21,650 --> 00:17:35,750
for a substrate redundant self you also

00:17:28,730 --> 00:17:36,650
see them often in in source code so most

00:17:35,750 --> 00:17:39,260
of the time there are some exceptions

00:17:36,650 --> 00:17:43,220
but most of the time you do not need our

00:17:39,260 --> 00:17:44,960
self in rubic so this is the the same

00:17:43,220 --> 00:17:49,000
code without the self and this is

00:17:44,960 --> 00:17:54,919
conventionally what we generally prefer

00:17:49,000 --> 00:17:59,480
and particularly with new you see this

00:17:54,919 --> 00:18:02,059
more often than with other metals news

00:17:59,480 --> 00:18:06,559
is nothing a special it's just a method

00:18:02,059 --> 00:18:09,679
so in this this code could be uh well it

00:18:06,559 --> 00:18:15,100
is the code for some kind of singleton

00:18:09,679 --> 00:18:20,809
thing right so no need to put self

00:18:15,100 --> 00:18:22,580
before new and I wonder if if if you

00:18:20,809 --> 00:18:26,390
come from other languages where new is a

00:18:22,580 --> 00:18:30,950
keyword maybe you have like you know

00:18:26,390 --> 00:18:32,360
some mismatch here writing or seeing new

00:18:30,950 --> 00:18:34,420
this naked you know

00:18:32,360 --> 00:18:38,240
maybe you have a little mismatch and

00:18:34,420 --> 00:18:42,650
prefer to qualify it I don't know but

00:18:38,240 --> 00:18:49,640
it's not necessary and this is the most

00:18:42,650 --> 00:18:53,480
the most the redundant self that I by

00:18:49,640 --> 00:18:55,400
far see more frequently which is

00:18:53,480 --> 00:19:03,049
inactive record for some reason I don't

00:18:55,400 --> 00:19:07,160
know I very often see ID qualify by self

00:19:03,049 --> 00:19:10,669
I don't know why but you do not need it

00:19:07,160 --> 00:19:13,610
I dick just a dick like the name this

00:19:10,669 --> 00:19:17,360
name we do not qualify name why do we

00:19:13,610 --> 00:19:19,100
Calif qualify ID I don't know I wonder

00:19:17,360 --> 00:19:21,380
if the reason is that idea is so short

00:19:19,100 --> 00:19:23,809
that you want you want it to you know to

00:19:21,380 --> 00:19:26,870
be more obvious I don't know you know

00:19:23,809 --> 00:19:29,720
the reason but i have to say i have to

00:19:26,870 --> 00:19:36,169
tell you that it's this self ID is very

00:19:29,720 --> 00:19:38,620
common so this is redundancy and i would

00:19:36,169 --> 00:19:42,350
like to reflect a little bit about

00:19:38,620 --> 00:19:48,679
whether it's perceived in a universal

00:19:42,350 --> 00:19:51,799
way so in the Ruby community we as a

00:19:48,679 --> 00:19:53,840
convention we do not write itself so it

00:19:51,799 --> 00:19:57,410
is expected that our call does not have

00:19:53,840 --> 00:20:00,679
cells we perceive it as a redundancy but

00:19:57,410 --> 00:20:07,419
in python is the other way around so in

00:20:00,679 --> 00:20:07,419
python you have to write selves and

00:20:07,450 --> 00:20:11,809
python people do not talk about

00:20:10,010 --> 00:20:15,890
redundancy by thought people talk about

00:20:11,809 --> 00:20:19,970
explicitly you see so two angles are the

00:20:15,890 --> 00:20:24,590
same thing we see redundancy where

00:20:19,970 --> 00:20:32,030
others see implicitly and they prefer to

00:20:24,590 --> 00:20:34,700
be explicit and i always like to to be

00:20:32,030 --> 00:20:37,190
aware of these things because it allows

00:20:34,700 --> 00:20:40,580
you to take some some distance you know

00:20:37,190 --> 00:20:43,520
from these things so some distance so

00:20:40,580 --> 00:20:45,750
you play by the rules if you are if you

00:20:43,520 --> 00:20:48,580
are writing Ruby you're going to write

00:20:45,750 --> 00:20:51,850
idiomatic Ruby you are not going to

00:20:48,580 --> 00:20:55,120
write redundant self but there's a very

00:20:51,850 --> 00:20:56,650
huge social aspect of this i believe

00:20:55,120 --> 00:20:58,630
it's just that the community has

00:20:56,650 --> 00:21:01,290
converged to this kind of conventions

00:20:58,630 --> 00:21:05,530
this is not it's not like absolute thing

00:21:01,290 --> 00:21:08,110
there's a mix of expectations and that

00:21:05,530 --> 00:21:10,059
you want your code to to look similar to

00:21:08,110 --> 00:21:12,940
the code that you get out there you know

00:21:10,059 --> 00:21:16,679
it's all the cultural thing about it but

00:21:12,940 --> 00:21:19,330
it's not an absolute aspect of of it so

00:21:16,679 --> 00:21:23,559
yeah that's nice nice to have into

00:21:19,330 --> 00:21:29,980
account all right now we are going to

00:21:23,559 --> 00:21:32,590
talk about with the ability to show you

00:21:29,980 --> 00:21:35,530
Charlie enjoyable and easy to read so

00:21:32,590 --> 00:21:38,080
easy to read very big enjoyable

00:21:35,530 --> 00:21:41,040
important so it's not just that you have

00:21:38,080 --> 00:21:45,490
to enjoy it reading a readable code okay

00:21:41,040 --> 00:21:48,880
that's the idea let's see this again all

00:21:45,490 --> 00:21:52,120
the others are snippets are real okay so

00:21:48,880 --> 00:21:57,840
let's see this returning the unless not

00:21:52,120 --> 00:22:00,549
name blank first thing if we can

00:21:57,840 --> 00:22:03,520
sometimes we cannot but if we can is

00:22:00,549 --> 00:22:06,460
better to avoid negations why because

00:22:03,520 --> 00:22:09,100
our brain is not a logic machine so our

00:22:06,460 --> 00:22:10,990
brain for some reasons has difficulties

00:22:09,100 --> 00:22:13,120
generally speaking with negations you

00:22:10,990 --> 00:22:16,990
have to work a little bit more you know

00:22:13,120 --> 00:22:19,179
to figure out the meaning of this in

00:22:16,990 --> 00:22:22,660
this particular case we just can say

00:22:19,179 --> 00:22:26,080
name present ok that's it easier you

00:22:22,660 --> 00:22:30,669
have to work less ok that's the way the

00:22:26,080 --> 00:22:34,530
brain works but still for some people

00:22:30,669 --> 00:22:38,140
may include unless has like a negation

00:22:34,530 --> 00:22:41,169
within it I know that some people have

00:22:38,140 --> 00:22:44,280
no issue with unless like they instantly

00:22:41,169 --> 00:22:46,929
understand the unless but for me unless

00:22:44,280 --> 00:22:51,340
it's still a little bit more of work

00:22:46,929 --> 00:22:54,100
because I am seeing what does not have

00:22:51,340 --> 00:22:56,320
to happen you know what what I'm reading

00:22:54,100 --> 00:22:58,830
is what does not have to happen to in

00:22:56,320 --> 00:23:02,659
order to run the the thing

00:22:58,830 --> 00:23:06,480
in the left so the way I work at least

00:23:02,659 --> 00:23:09,360
it's still not there so this is the one

00:23:06,480 --> 00:23:11,130
that I prefer so it's like everything is

00:23:09,360 --> 00:23:12,870
affirmative you know everything what you

00:23:11,130 --> 00:23:15,210
see is what you know everything is

00:23:12,870 --> 00:23:19,640
there's no second level of anything you

00:23:15,210 --> 00:23:25,740
know so every code in positive is

00:23:19,640 --> 00:23:33,330
generally easier to read backslashes in

00:23:25,740 --> 00:23:37,380
literals not nice not nice so yeah so

00:23:33,330 --> 00:23:38,970
this thing you are you are counting

00:23:37,380 --> 00:23:42,590
their backs lies then okay I'm do this

00:23:38,970 --> 00:23:46,970
thing in my brain then no so in Ruby

00:23:42,590 --> 00:23:49,649
fortunately we have several ways to

00:23:46,970 --> 00:23:54,090
write this kind of literals like in

00:23:49,649 --> 00:23:57,870
regular expressions in the strings you

00:23:54,090 --> 00:24:00,179
can do this and so the the best practice

00:23:57,870 --> 00:24:03,059
here could be tried to buy backslashes

00:24:00,179 --> 00:24:08,370
as much as possible in your in the

00:24:03,059 --> 00:24:11,580
literals all right and if if this feels

00:24:08,370 --> 00:24:14,549
a little bit heavier or you can use

00:24:11,580 --> 00:24:16,769
actually some contraction and some other

00:24:14,549 --> 00:24:18,990
characters to delimit as long as the as

00:24:16,769 --> 00:24:20,940
the as the punctuation does is not

00:24:18,990 --> 00:24:24,360
present in the literal you can do it and

00:24:20,940 --> 00:24:26,100
it feels this one feels like even more

00:24:24,360 --> 00:24:29,549
lighter you know but in any case

00:24:26,100 --> 00:24:37,590
backslashes tried we try to avoid them

00:24:29,549 --> 00:24:41,549
oh this one has from 44 I don't know

00:24:37,590 --> 00:24:47,070
every time I see this I have to ok so

00:24:41,549 --> 00:24:50,789
the thing is so the situation here is

00:24:47,070 --> 00:24:52,620
that you have a file say config are you

00:24:50,789 --> 00:24:56,159
or something like that and you want to

00:24:52,620 --> 00:24:59,460
load another file in this case boat RV

00:24:56,159 --> 00:25:03,059
that belongs to the same directory so if

00:24:59,460 --> 00:25:06,380
you are used to to you know to a file

00:25:03,059 --> 00:25:09,510
system here occasion that kind of thing

00:25:06,380 --> 00:25:11,730
for the natural thing so you are in the

00:25:09,510 --> 00:25:13,710
set of the same level for sexually

00:25:11,730 --> 00:25:17,220
and doing this contortion is like

00:25:13,710 --> 00:25:21,270
unnatural and you think so we have this

00:25:17,220 --> 00:25:23,070
this sailed upon Stan file which is the

00:25:21,270 --> 00:25:26,760
the point of reference of expand bath

00:25:23,070 --> 00:25:29,480
and then you have to do dot dot and the

00:25:26,760 --> 00:25:32,910
dot for me the dot is about directories

00:25:29,480 --> 00:25:35,370
it's difficult for me to so I have to

00:25:32,910 --> 00:25:37,350
think okay I'm in a file so the dot dot

00:25:35,370 --> 00:25:42,090
is the directory of the fire I have to

00:25:37,350 --> 00:25:44,970
thing all and yeah so we have had to to

00:25:42,090 --> 00:25:48,750
to write this for a number of years but

00:25:44,970 --> 00:25:50,850
in 20 we got there which is the that the

00:25:48,750 --> 00:25:54,030
current directory the directory of the

00:25:50,850 --> 00:25:56,130
coulomb file okay so this is more

00:25:54,030 --> 00:26:01,440
natural in my in my view this is more

00:25:56,130 --> 00:26:06,000
natural and these remarks applied to

00:26:01,440 --> 00:26:08,070
expand path in isolation but in the cut

00:26:06,000 --> 00:26:10,020
in the particular case of require we

00:26:08,070 --> 00:26:11,850
still have even something easier which

00:26:10,020 --> 00:26:17,130
is just require relative boot and done

00:26:11,850 --> 00:26:19,050
right you know the saying always called

00:26:17,130 --> 00:26:21,590
as if the guy who ends up maintaining

00:26:19,050 --> 00:26:27,120
your code will be a violent psychopath

00:26:21,590 --> 00:26:28,710
who knows where you live there's another

00:26:27,120 --> 00:26:32,690
saying like this that is the maintainer

00:26:28,710 --> 00:26:35,520
of this code could be your future self

00:26:32,690 --> 00:26:39,470
yeah there's a nice things nice things

00:26:35,520 --> 00:26:43,830
but for my taste they are too

00:26:39,470 --> 00:26:46,800
self-centered like like let's write a

00:26:43,830 --> 00:26:48,870
little code because otherwise but things

00:26:46,800 --> 00:26:51,450
can happen although you know could be

00:26:48,870 --> 00:26:53,970
myself not understanding or whatever

00:26:51,450 --> 00:26:56,310
what I would like to reward that this

00:26:53,970 --> 00:26:59,430
kind of sayings and say just constantly

00:26:56,310 --> 00:27:01,110
think of the riddles of your code not

00:26:59,430 --> 00:27:06,030
because of you because you'll be gone

00:27:01,110 --> 00:27:09,540
but because of them so right readable

00:27:06,030 --> 00:27:14,000
code and document the wise in your code

00:27:09,540 --> 00:27:17,400
if you have ever done maintenance of a

00:27:14,000 --> 00:27:20,640
previous code base for sure if you've

00:27:17,400 --> 00:27:22,800
seen pieces of code and nobody knows why

00:27:20,640 --> 00:27:23,760
they are there the logic is not clear

00:27:22,800 --> 00:27:26,160
can

00:27:23,760 --> 00:27:29,400
who can we remove the sheet nobody knows

00:27:26,160 --> 00:27:33,750
so will you keep it it for years that

00:27:29,400 --> 00:27:35,400
kind of thing documental wise not

00:27:33,750 --> 00:27:40,860
because of you because you'll be gone

00:27:35,400 --> 00:27:42,570
but because of them because of the

00:27:40,860 --> 00:27:46,910
greatest of the qualities a parameter

00:27:42,570 --> 00:27:52,590
can have in my view which is empathy and

00:27:46,910 --> 00:27:58,980
empathy there are a number of ways to to

00:27:52,590 --> 00:28:01,470
be empathic you that that that you can

00:27:58,980 --> 00:28:03,390
show that when related with other team

00:28:01,470 --> 00:28:06,090
members you can show that when review a

00:28:03,390 --> 00:28:07,890
pull request you can show that a

00:28:06,090 --> 00:28:11,760
practice that in a number of things but

00:28:07,890 --> 00:28:15,780
for me the ultimate expression of

00:28:11,760 --> 00:28:22,650
empathy in a in a programmer is in the

00:28:15,780 --> 00:28:25,590
way they program okay so let's go back

00:28:22,650 --> 00:28:28,770
to snippets and now we are talking about

00:28:25,590 --> 00:28:30,630
ordering all those things naturally

00:28:28,770 --> 00:28:34,170
sometimes in your code you're writing

00:28:30,630 --> 00:28:37,530
things that have like a natural orders

00:28:34,170 --> 00:28:40,260
from some sort okay so for instance you

00:28:37,530 --> 00:28:42,870
are you are reading class top to bottom

00:28:40,260 --> 00:28:46,380
which is the normal thing to do and you

00:28:42,870 --> 00:28:48,300
find last name okay so there's a there's

00:28:46,380 --> 00:28:53,340
an alert in your brain last name it was

00:28:48,300 --> 00:28:55,190
the first name okay you see it at the

00:28:53,340 --> 00:28:57,590
bottom oh ok ok is there you get a

00:28:55,190 --> 00:29:00,360
little disconcert you know for a moment

00:28:57,590 --> 00:29:02,340
but if you if you just do it naturally

00:29:00,360 --> 00:29:06,960
like first name first and last name

00:29:02,340 --> 00:29:10,580
there then it flows right this is the

00:29:06,960 --> 00:29:14,100
declaration of some time stamps ok

00:29:10,580 --> 00:29:19,320
deleted created updated that again real

00:29:14,100 --> 00:29:22,770
examples so you see deleted and your

00:29:19,320 --> 00:29:25,400
mind has just has to check the Thrilla

00:29:22,770 --> 00:29:28,890
mother we have we do I have everything

00:29:25,400 --> 00:29:30,690
because if you're right created that you

00:29:28,890 --> 00:29:32,250
first create things then maybe you

00:29:30,690 --> 00:29:35,340
update things maybe then you delete

00:29:32,250 --> 00:29:37,560
that's the natural thing ok so the

00:29:35,340 --> 00:29:41,600
second one in my opinion

00:29:37,560 --> 00:29:41,600
better you know you have to think less

00:29:43,130 --> 00:29:47,940
another typical one you have some

00:29:45,600 --> 00:29:50,730
arguments in a in a method definition

00:29:47,940 --> 00:29:55,170
and then for some reason you assign

00:29:50,730 --> 00:29:58,020
things in different order this could be

00:29:55,170 --> 00:29:59,940
maybe we had first two arguments and

00:29:58,020 --> 00:30:02,910
then someone adds a third argument and

00:29:59,940 --> 00:30:06,290
then goes up to the first line and just

00:30:02,910 --> 00:30:09,150
add it there you know the assignment but

00:30:06,290 --> 00:30:11,760
your mind is like checking things you

00:30:09,150 --> 00:30:12,960
know okay and this is this is that one

00:30:11,760 --> 00:30:16,710
you know you are crossing things you

00:30:12,960 --> 00:30:19,260
know much easier to follow the order

00:30:16,710 --> 00:30:21,750
okay so protocol protocol Costco's and

00:30:19,260 --> 00:30:29,880
your brain parses this more much more

00:30:21,750 --> 00:30:32,780
easily but as I said very very readily

00:30:29,880 --> 00:30:35,580
this is going to be black and white and

00:30:32,780 --> 00:30:39,060
sometimes the decision is not clear or

00:30:35,580 --> 00:30:41,930
have different cons and pros and you

00:30:39,060 --> 00:30:45,030
finally have to choose something but

00:30:41,930 --> 00:30:49,410
sometimes is not like one hundred

00:30:45,030 --> 00:30:52,080
percent like very very clear for

00:30:49,410 --> 00:30:54,990
instance we are here constructing an

00:30:52,080 --> 00:30:58,350
object passing a couple of attributes to

00:30:54,990 --> 00:31:01,890
it name an email and in this example we

00:30:58,350 --> 00:31:06,770
assume that there's an RX thing that has

00:31:01,890 --> 00:31:09,930
a hash with some values okay so we see

00:31:06,770 --> 00:31:12,150
repetition here right and and you have

00:31:09,930 --> 00:31:15,210
to check things so you have to check

00:31:12,150 --> 00:31:19,920
that name goes with name there are no

00:31:15,210 --> 00:31:25,560
typos that email goes with email ARC's

00:31:19,920 --> 00:31:28,260
is written twice in inactive support we

00:31:25,560 --> 00:31:30,390
have a slice okay so this is more

00:31:28,260 --> 00:31:33,690
concise this life is more concise

00:31:30,390 --> 00:31:37,470
because there are you are this is

00:31:33,690 --> 00:31:39,690
actually saying i want this Subhash okay

00:31:37,470 --> 00:31:42,450
so it's like if someone doesn't does not

00:31:39,690 --> 00:31:45,750
know this method is going to take name

00:31:42,450 --> 00:31:48,600
and email and you get a harsh a sub

00:31:45,750 --> 00:31:51,210
crash with with just these two piece

00:31:48,600 --> 00:31:53,909
well actually the both examples

00:31:51,210 --> 00:31:56,850
equivalent because a slice if the if the

00:31:53,909 --> 00:31:58,429
key is not present it it is it is not

00:31:56,850 --> 00:32:01,679
present in the Hajj that it returns

00:31:58,429 --> 00:32:03,809
whereas this this new method is going in

00:32:01,679 --> 00:32:05,820
the in the in the one at the top is

00:32:03,809 --> 00:32:08,580
going always to receive wolf case but

00:32:05,820 --> 00:32:12,990
let's let's imagine that that that

00:32:08,580 --> 00:32:16,440
doesn't matter okay but yeah more

00:32:12,990 --> 00:32:19,500
concise and I would probably choose the

00:32:16,440 --> 00:32:23,059
second one probably but I have to admit

00:32:19,500 --> 00:32:29,460
that maybe the first one is more clear

00:32:23,059 --> 00:32:33,149
hmm I don't know more questions than

00:32:29,460 --> 00:32:36,899
answers in this talk and this one you

00:32:33,149 --> 00:32:40,230
call super get something that you modify

00:32:36,899 --> 00:32:43,200
it's a it's a harsh and then you return

00:32:40,230 --> 00:32:46,860
the harsh well we have a specific idiom

00:32:43,200 --> 00:32:49,620
nowadays to do this which is tab so you

00:32:46,860 --> 00:32:52,409
tap and then you modify and the result

00:32:49,620 --> 00:32:55,289
of this is this is supposed to be

00:32:52,409 --> 00:32:57,960
immutable thing of course in the block

00:32:55,289 --> 00:33:00,029
you you can do everything maybe you do

00:32:57,960 --> 00:33:05,210
not mutated but normally that's that the

00:33:00,029 --> 00:33:08,010
use case okay and I do prefer tab

00:33:05,210 --> 00:33:10,470
because tab is saying to the reader of

00:33:08,010 --> 00:33:12,419
the code I'm going to pick this and I'm

00:33:10,470 --> 00:33:14,909
going to return before you read anything

00:33:12,419 --> 00:33:16,710
else so you are you upset about what's

00:33:14,909 --> 00:33:19,830
going to happen where as in the previous

00:33:16,710 --> 00:33:22,529
one you have to infer so i have this

00:33:19,830 --> 00:33:23,730
value and then and now and this value is

00:33:22,529 --> 00:33:27,740
the one that i'm going to return from

00:33:23,730 --> 00:33:31,919
the method or the expression or whatever

00:33:27,740 --> 00:33:34,500
so yeah so there's more going on you

00:33:31,919 --> 00:33:36,870
have to think more in the first case in

00:33:34,500 --> 00:33:38,520
my view and the second one is more

00:33:36,870 --> 00:33:41,190
concise and the second one is the one

00:33:38,520 --> 00:33:44,460
that i normally prefer because it

00:33:41,190 --> 00:33:46,789
communicates better nevertheless i know

00:33:44,460 --> 00:33:50,340
many people that prefer the first option

00:33:46,789 --> 00:33:52,740
because there's less things you know

00:33:50,340 --> 00:33:55,590
there's less abstraction let us less API

00:33:52,740 --> 00:33:58,559
less less let's stuff going on because

00:33:55,590 --> 00:34:04,100
they they they perceive simpler code in

00:33:58,559 --> 00:34:04,100
the first version no no right answer

00:34:04,159 --> 00:34:12,050
all right now we are going to talk about

00:34:07,860 --> 00:34:15,179
precision being precise in your code

00:34:12,050 --> 00:34:18,179
this is an experiment editing rails I

00:34:15,179 --> 00:34:21,990
wrote an outpost plane so if you had a

00:34:18,179 --> 00:34:24,300
fresco land query was running for too

00:34:21,990 --> 00:34:26,599
long in development mode you could have

00:34:24,300 --> 00:34:29,329
an explain in the in the lock

00:34:26,599 --> 00:34:32,399
automatically but I did an experiment

00:34:29,329 --> 00:34:34,200
which was to say to put the units in the

00:34:32,399 --> 00:34:36,510
name of of the of the config variable

00:34:34,200 --> 00:34:42,300
okay so it was out of spreading 13

00:34:36,510 --> 00:34:43,889
seconds it's longer but when you are

00:34:42,300 --> 00:34:45,270
going to when you go to the

00:34:43,889 --> 00:34:47,849
configuration you want to tweak this

00:34:45,270 --> 00:34:50,010
thing it's absolutely clear what you

00:34:47,849 --> 00:34:52,560
have to work which is the unit which is

00:34:50,010 --> 00:34:55,139
often not the case in many many of these

00:34:52,560 --> 00:34:57,270
kind of things you have to check the

00:34:55,139 --> 00:34:59,069
documentation you know and if you are

00:34:57,270 --> 00:35:00,869
reading the implementation and you see

00:34:59,069 --> 00:35:03,630
out the Spring Festival in seconds

00:35:00,869 --> 00:35:08,640
compared to time new I don't know

00:35:03,630 --> 00:35:11,040
whatever you know you do not need to

00:35:08,640 --> 00:35:12,750
have in mind or go to check which was a

00:35:11,040 --> 00:35:18,630
unit of this thing because i am not

00:35:12,750 --> 00:35:20,460
familiar with the code it's obvious in

00:35:18,630 --> 00:35:23,160
every code review i do of rails

00:35:20,460 --> 00:35:25,050
application there's a grep that i run in

00:35:23,160 --> 00:35:29,900
the project checking for has many

00:35:25,050 --> 00:35:33,390
without dependent so this has many

00:35:29,900 --> 00:35:37,560
normally means you are going to have

00:35:33,390 --> 00:35:40,020
orphan records and in every project I

00:35:37,560 --> 00:35:45,150
have revealed I believe I have found

00:35:40,020 --> 00:35:47,670
some of this so you know when you delete

00:35:45,150 --> 00:35:51,180
something to to have the database

00:35:47,670 --> 00:35:55,680
consistent you have to delete normally

00:35:51,180 --> 00:35:59,730
delete children so and grandchildren you

00:35:55,680 --> 00:36:02,010
know all the descendants sometimes you

00:35:59,730 --> 00:36:04,619
have other options to do but you

00:36:02,010 --> 00:36:06,569
normally have to take a decision so a

00:36:04,619 --> 00:36:09,480
blank has many comments like this

00:36:06,569 --> 00:36:11,250
normally it's a bit it's it's telling

00:36:09,480 --> 00:36:13,020
you that something is missing here you

00:36:11,250 --> 00:36:16,410
have to take a split decision about what

00:36:13,020 --> 00:36:20,030
to do with children and

00:36:16,410 --> 00:36:22,590
oh yeah okay I want you add here that

00:36:20,030 --> 00:36:27,560
you can you can have you can have as

00:36:22,590 --> 00:36:31,920
many without this thing if you configure

00:36:27,560 --> 00:36:34,320
foreign keys that delete when you when

00:36:31,920 --> 00:36:37,500
you delete records and that's the the

00:36:34,320 --> 00:36:40,880
option I normally I normally use because

00:36:37,500 --> 00:36:44,400
in my experience before destroy

00:36:40,880 --> 00:36:46,410
callbacks and not you do not you do not

00:36:44,400 --> 00:36:50,700
happy for destroy callbacks that orphan

00:36:46,410 --> 00:36:53,370
and many times the easiest thing to do

00:36:50,700 --> 00:36:55,380
is just to put the foreign key cascade

00:36:53,370 --> 00:36:57,390
and then you know when you delete

00:36:55,380 --> 00:36:59,010
something the database takes care of all

00:36:57,390 --> 00:37:00,810
the descendants you know you have to do

00:36:59,010 --> 00:37:03,570
nothing and then if you have the

00:37:00,810 --> 00:37:06,720
exception which is to have a before

00:37:03,570 --> 00:37:09,260
destroyed then you have to do all the

00:37:06,720 --> 00:37:14,700
things you know but a blank one normally

00:37:09,260 --> 00:37:20,760
bad sign logger taking a standard output

00:37:14,700 --> 00:37:22,680
from the constant conventionally in Ruby

00:37:20,760 --> 00:37:25,500
programs the standard output it's in

00:37:22,680 --> 00:37:27,480
this global variable ok so the constant

00:37:25,500 --> 00:37:31,710
has like the original stream in the

00:37:27,480 --> 00:37:34,230
process but the body of all problems can

00:37:31,710 --> 00:37:37,920
change the variable and that's what when

00:37:34,230 --> 00:37:41,100
you when you use print put s and this

00:37:37,920 --> 00:37:44,850
kind of i/o they go to the global

00:37:41,100 --> 00:37:47,760
variable so if you change it you know if

00:37:44,850 --> 00:37:49,710
everything is going to respect that so

00:37:47,760 --> 00:37:51,660
it's a you know it's playing by the

00:37:49,710 --> 00:37:54,480
rules to use the global variable instead

00:37:51,660 --> 00:37:56,670
of the constant also in test Suites if

00:37:54,480 --> 00:37:58,800
you use the global variable since the

00:37:56,670 --> 00:38:00,360
API uses the global variable you can

00:37:58,800 --> 00:38:02,520
capture standard output just by

00:38:00,360 --> 00:38:04,620
assigning a string I or something you

00:38:02,520 --> 00:38:06,600
know to this thing temporarily and then

00:38:04,620 --> 00:38:08,670
reset it you cannot do that with a

00:38:06,600 --> 00:38:10,620
constant so if you just use you are

00:38:08,670 --> 00:38:12,780
using the constant in a library or

00:38:10,620 --> 00:38:17,460
something then the third parties are not

00:38:12,780 --> 00:38:21,900
able to mock that ok and now let's talk

00:38:17,460 --> 00:38:23,970
about regular expressions another saying

00:38:21,900 --> 00:38:26,250
some people when confronted with the

00:38:23,970 --> 00:38:28,440
problem thing I know I use a regular

00:38:26,250 --> 00:38:29,430
expression and now they have two

00:38:28,440 --> 00:38:32,510
problems

00:38:29,430 --> 00:38:37,559
and I have to say this is and

00:38:32,510 --> 00:38:39,359
it's in my opinion so regular

00:38:37,559 --> 00:38:40,980
specialness are super powerful and I

00:38:39,359 --> 00:38:42,540
believe it should be in the toolbox of

00:38:40,980 --> 00:38:46,020
every programmer it's they are super

00:38:42,540 --> 00:38:47,250
powerful and and you know used in you

00:38:46,020 --> 00:38:50,490
know in the in the in the place that

00:38:47,250 --> 00:38:52,559
they make sense like any other tool if

00:38:50,490 --> 00:38:54,960
you do not know regular expressions you

00:38:52,559 --> 00:38:57,390
are lacking a lot of power that they

00:38:54,960 --> 00:39:01,890
bring and I am going to talk about

00:38:57,390 --> 00:39:06,510
anchors this these are correct in this

00:39:01,890 --> 00:39:08,099
dollar and yes so let's suppose this is

00:39:06,510 --> 00:39:11,609
our regular expression to check for user

00:39:08,099 --> 00:39:15,329
names and you have to you have to know

00:39:11,609 --> 00:39:17,160
that the the anchor anchors at the

00:39:15,329 --> 00:39:19,230
beginning of lines or beginners of a

00:39:17,160 --> 00:39:21,359
string beginning of lines or beginning

00:39:19,230 --> 00:39:23,970
of a string so it's not the beginning of

00:39:21,359 --> 00:39:26,099
the string it also matches on beginning

00:39:23,970 --> 00:39:29,220
of lights so you can have this this

00:39:26,099 --> 00:39:32,700
matches okay you have a hack than a new

00:39:29,220 --> 00:39:34,559
line and I valid user name since since

00:39:32,700 --> 00:39:38,640
the regular expression is checking

00:39:34,559 --> 00:39:43,589
anchoring to just any line is going to

00:39:38,640 --> 00:39:48,089
pass and the hack is in so talking about

00:39:43,589 --> 00:39:50,910
precision use the anchor a what you mean

00:39:48,089 --> 00:39:52,950
a a is beginning of a string that's

00:39:50,910 --> 00:39:56,609
specifically beginning of a string so

00:39:52,950 --> 00:39:59,670
use a when you mean a sometimes you may

00:39:56,609 --> 00:40:01,740
you may think I'm doing just this little

00:39:59,670 --> 00:40:04,319
thing I will relax and just use the

00:40:01,740 --> 00:40:06,990
current okay like like going through a

00:40:04,319 --> 00:40:09,170
file system like this if the file name

00:40:06,990 --> 00:40:12,510
starts with something well let's relax

00:40:09,170 --> 00:40:16,230
but then the question is can a file name

00:40:12,510 --> 00:40:18,359
have new lines if this is just a quick

00:40:16,230 --> 00:40:20,640
script you know you are doing a quick

00:40:18,359 --> 00:40:23,579
and if the thing maybe it's enough if

00:40:20,640 --> 00:40:25,349
you are working in a genetic library or

00:40:23,579 --> 00:40:28,859
something like that maybe you have to be

00:40:25,349 --> 00:40:31,650
more careful can a file name have new

00:40:28,859 --> 00:40:34,950
lines so if in this moment you are

00:40:31,650 --> 00:40:37,079
wondering that that's the point so no

00:40:34,950 --> 00:40:40,339
need to wonder about that and the answer

00:40:37,079 --> 00:40:42,780
is yes you can have new lines but why

00:40:40,339 --> 00:40:43,260
can have me I don't know well let's use

00:40:42,780 --> 00:40:47,880
the gardener

00:40:43,260 --> 00:40:52,680
or just use a when you mean a similar

00:40:47,880 --> 00:40:55,500
with dollar dollar means end of line or

00:40:52,680 --> 00:40:58,710
end of a string and that we have capital

00:40:55,500 --> 00:41:01,110
Z and lowercase set capital said means

00:40:58,710 --> 00:41:04,680
end of a string with an optional new

00:41:01,110 --> 00:41:07,800
line and lower case and that means end

00:41:04,680 --> 00:41:11,840
of a string so capital a goes with

00:41:07,800 --> 00:41:14,820
lowercase that ok that's the pair and

00:41:11,840 --> 00:41:16,800
yeah so with using dollar we have the

00:41:14,820 --> 00:41:19,980
same kind of things I'm not going to put

00:41:16,800 --> 00:41:25,590
more examples about this but I want to

00:41:19,980 --> 00:41:29,760
talk about the origin of this means use

00:41:25,590 --> 00:41:32,390
of the often misuse of the carrot of the

00:41:29,760 --> 00:41:35,610
of these anchors and the thing is that

00:41:32,390 --> 00:41:39,020
the anchor normally means a start of a

00:41:35,610 --> 00:41:41,370
string for instance the carrot means

00:41:39,020 --> 00:41:45,720
start of a string in many in many places

00:41:41,370 --> 00:41:47,760
and the dollar normally means end of a

00:41:45,720 --> 00:41:51,120
string except for an optional new line

00:41:47,760 --> 00:41:54,630
so if you do any of these things and

00:41:51,120 --> 00:41:57,300
maybe more that's the meaning of the of

00:41:54,630 --> 00:42:00,150
these anchors unless you pass a flag if

00:41:57,300 --> 00:42:04,290
you pass a flag then you get the

00:42:00,150 --> 00:42:08,040
multi-line thing but by default by

00:42:04,290 --> 00:42:12,510
default they mean capital A and capital

00:42:08,040 --> 00:42:15,180
Z so the thing is that we are exposed to

00:42:12,510 --> 00:42:17,820
a lot of regular expressions out there

00:42:15,180 --> 00:42:19,650
in Stack Overflow if you if you've done

00:42:17,820 --> 00:42:22,980
any of these other languages you know

00:42:19,650 --> 00:42:25,470
you were exposed to a lot of regular

00:42:22,980 --> 00:42:28,290
expressions that use the anchors with

00:42:25,470 --> 00:42:32,880
the meaning of the capital letters okay

00:42:28,290 --> 00:42:35,760
and I believe that's possibly the reason

00:42:32,880 --> 00:42:38,130
why so many people even in rails even in

00:42:35,760 --> 00:42:40,740
documentation we have had this issue

00:42:38,130 --> 00:42:48,030
sometimes okay so it's very it's very

00:42:40,740 --> 00:42:52,740
common to see it but again again we have

00:42:48,030 --> 00:42:55,580
a problem here because probably under

00:42:52,740 --> 00:42:59,820
square the dollar is more readable than

00:42:55,580 --> 00:43:02,280
backslide zetas probably for to me it

00:42:59,820 --> 00:43:05,840
feels lighter somehow you know this

00:43:02,280 --> 00:43:13,130
backslash backslash bad I don't know so

00:43:05,840 --> 00:43:17,130
no absolute right or wrong answer and

00:43:13,130 --> 00:43:20,670
finally I want to talk just briefly

00:43:17,130 --> 00:43:22,200
about code style so style guidelines and

00:43:20,670 --> 00:43:25,440
that kind of thing so in this talk we

00:43:22,200 --> 00:43:28,880
have not talked about code style we had

00:43:25,440 --> 00:43:31,410
the first example with that common but

00:43:28,880 --> 00:43:33,600
for me code style does not belong to

00:43:31,410 --> 00:43:35,820
these kind of things so in general I

00:43:33,600 --> 00:43:38,850
don't care about your particular you

00:43:35,820 --> 00:43:41,370
know whether you put when in denton or

00:43:38,850 --> 00:43:43,850
with case or that kind of thing I think

00:43:41,370 --> 00:43:45,810
that's really really really unimportant

00:43:43,850 --> 00:43:48,420
the only thing that they believe

00:43:45,810 --> 00:43:51,030
important it's important about style is

00:43:48,420 --> 00:43:55,500
that in every project on in every

00:43:51,030 --> 00:43:57,090
company this consistency so so that when

00:43:55,500 --> 00:44:00,660
you open any of the files of that

00:43:57,090 --> 00:44:02,640
project of that company what you see is

00:44:00,660 --> 00:44:04,620
is always the same kind of thing you

00:44:02,640 --> 00:44:07,620
know because just because the

00:44:04,620 --> 00:44:09,660
consistency makes the maist going

00:44:07,620 --> 00:44:14,610
through the files easier because your

00:44:09,660 --> 00:44:17,990
brain is used to parse a certain style

00:44:14,610 --> 00:44:20,040
so for instance if if you ever seen

00:44:17,990 --> 00:44:22,040
method declarations in the in the

00:44:20,040 --> 00:44:25,500
Seattle area style without parentheses

00:44:22,040 --> 00:44:27,570
the first time you see that it feels

00:44:25,500 --> 00:44:30,080
strange ok if it's strange because your

00:44:27,570 --> 00:44:33,300
brain is not used to it not because

00:44:30,080 --> 00:44:35,880
intrinsically is battle right is right

00:44:33,300 --> 00:44:38,160
around because just because you normally

00:44:35,880 --> 00:44:40,770
parse parentheses and the lack of

00:44:38,160 --> 00:44:43,650
panties it makes you wait for a moment

00:44:40,770 --> 00:44:46,290
ok ok I need to go you know collected by

00:44:43,650 --> 00:44:48,980
character to parse this thing but if you

00:44:46,290 --> 00:44:52,020
are doing Seattle will be for one month

00:44:48,980 --> 00:44:53,810
it's going to be like this because then

00:44:52,020 --> 00:44:57,240
you your brain is used to it so

00:44:53,810 --> 00:44:58,650
consistency in the in the in the in the

00:44:57,240 --> 00:45:00,870
code base is the only thing that I think

00:44:58,650 --> 00:45:03,630
it matters and the specific rules for me

00:45:00,870 --> 00:45:05,850
particularly as time passes I don't have

00:45:03,630 --> 00:45:08,070
any you know I can work with any rules i

00:45:05,850 --> 00:45:09,780
don't care i only care about consistency

00:45:08,070 --> 00:45:13,820
and i have to

00:45:09,780 --> 00:45:17,220
to do a hot tip here for Robocop because

00:45:13,820 --> 00:45:19,590
as years pass I see more and more

00:45:17,220 --> 00:45:22,110
projects using Robocop in the in their

00:45:19,590 --> 00:45:26,160
code bases and evilly this is this is

00:45:22,110 --> 00:45:28,620
really good and this these are wouldn't

00:45:26,160 --> 00:45:30,300
be possible without without the work

00:45:28,620 --> 00:45:32,940
that I think is going to be difficult

00:45:30,300 --> 00:45:35,130
because we booked up I believe is the

00:45:32,940 --> 00:45:37,050
perfect project to go by shedding

00:45:35,130 --> 00:45:39,240
everything I don't know seems like a

00:45:37,050 --> 00:45:43,640
difficult project so hat tip to the

00:45:39,240 --> 00:45:43,640
Robocop people and thanks very much

00:45:52,940 --> 00:45:58,640
so thanks travian for your awesome folk

00:46:04,610 --> 00:46:06,670

YouTube URL: https://www.youtube.com/watch?v=mC9TyVeER_8


