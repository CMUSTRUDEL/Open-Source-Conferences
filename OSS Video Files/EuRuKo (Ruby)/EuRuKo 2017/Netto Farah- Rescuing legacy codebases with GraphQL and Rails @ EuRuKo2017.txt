Title: Netto Farah- Rescuing legacy codebases with GraphQL and Rails @ EuRuKo2017
Publication date: 2017-12-21
Playlist: EuRuKo 2017
Description: 
	
Captions: 
	00:00:08,059 --> 00:00:16,560
hi everyone thank you so much for being

00:00:13,860 --> 00:00:18,840
here for attending my talk there are

00:00:16,560 --> 00:00:22,439
multiple reasons why I'm excited to give

00:00:18,840 --> 00:00:25,320
this talk today the number one is it's

00:00:22,439 --> 00:00:27,200
just very humbling to participate in

00:00:25,320 --> 00:00:30,360
this conference with such a diverse

00:00:27,200 --> 00:00:32,880
panel with speakers such a talented

00:00:30,360 --> 00:00:35,219
panel too I would like to ask everybody

00:00:32,880 --> 00:00:36,570
to give a round of applause to all the

00:00:35,219 --> 00:00:42,470
speakers and the organization for

00:00:36,570 --> 00:00:45,780
putting together something so great yeah

00:00:42,470 --> 00:00:48,960
the second reason why I'm excited to

00:00:45,780 --> 00:00:51,780
give this talk is because I get to tell

00:00:48,960 --> 00:00:54,030
a story it's not an overnight failure

00:00:51,780 --> 00:00:56,430
story I've got many of those too but

00:00:54,030 --> 00:01:00,149
this is actually a nine month long

00:00:56,430 --> 00:01:02,460
success story for my team and the seek

00:01:00,149 --> 00:01:04,890
the second the third reason why I love

00:01:02,460 --> 00:01:07,619
to share this talk it's because it's a

00:01:04,890 --> 00:01:09,450
technology I'm very excited about it's

00:01:07,619 --> 00:01:12,149
something I got involved a couple years

00:01:09,450 --> 00:01:14,039
ago and I've been enjoying working with

00:01:12,149 --> 00:01:16,229
a graphic you all I've enjoyed working

00:01:14,039 --> 00:01:17,909
with Ruby on Rails for multiple years

00:01:16,229 --> 00:01:21,210
and are things that I'm excited to talk

00:01:17,909 --> 00:01:25,490
about if you don't know me my name is

00:01:21,210 --> 00:01:28,859
Neto I currently live in big country I

00:01:25,490 --> 00:01:31,859
thought I flew in from from San

00:01:28,859 --> 00:01:35,369
Francisco I I'm an engineering manager

00:01:31,859 --> 00:01:38,399
manager at segments but this is not a

00:01:35,369 --> 00:01:40,799
story about segments and also I'm

00:01:38,399 --> 00:01:43,310
originally from Brazil and I've been

00:01:40,799 --> 00:01:46,619
hearing so much Portuguese here so

00:01:43,310 --> 00:01:48,380
Brazilians please say hi there's a bunch

00:01:46,619 --> 00:01:53,090
of Brazilians here

00:01:48,380 --> 00:01:56,690
not that many nah they're shy okay this

00:01:53,090 --> 00:01:58,190
is a story about when I worked at IFTTT

00:01:56,690 --> 00:02:01,700
and for the ones that are not familiar

00:01:58,190 --> 00:02:04,670
it stands for if this then that and I'll

00:02:01,700 --> 00:02:06,680
tell you the story about how me and my

00:02:04,670 --> 00:02:08,539
team helped build the next generation of

00:02:06,680 --> 00:02:11,120
their current the current generation of

00:02:08,539 --> 00:02:12,290
their project if you're not familiar

00:02:11,120 --> 00:02:14,270
with what they do

00:02:12,290 --> 00:02:16,160
it's exactly what it stands for if

00:02:14,270 --> 00:02:18,770
there's then that so you can connect

00:02:16,160 --> 00:02:21,739
different services online and make they

00:02:18,770 --> 00:02:23,569
work for you on an if there's then their

00:02:21,739 --> 00:02:26,590
fashions an example that I could use

00:02:23,569 --> 00:02:28,280
here is if I take a photo on Instagram

00:02:26,590 --> 00:02:31,130
with the hashtag

00:02:28,280 --> 00:02:33,140
Iroko I wanted to get tweeted

00:02:31,130 --> 00:02:35,390
automatically for me so I can do all

00:02:33,140 --> 00:02:38,000
these sorts of things I can back up all

00:02:35,390 --> 00:02:41,380
my photos to my Dropbox folder I can

00:02:38,000 --> 00:02:43,400
automate searches on Craigslist or

00:02:41,380 --> 00:02:45,290
anything anything that you can think

00:02:43,400 --> 00:02:48,560
that you can use to different online

00:02:45,290 --> 00:02:51,500
services for a little bit of context

00:02:48,560 --> 00:02:54,110
here so it is an app that is loved by

00:02:51,500 --> 00:02:56,329
millions of users there's a lot of

00:02:54,110 --> 00:02:58,280
people using it and because it makes

00:02:56,329 --> 00:03:00,440
these connections between different

00:02:58,280 --> 00:03:03,380
services online we're talking about

00:03:00,440 --> 00:03:05,450
billions of API calls every day just to

00:03:03,380 --> 00:03:08,630
make those checking connections posting

00:03:05,450 --> 00:03:14,410
things things like that it has an

00:03:08,630 --> 00:03:16,700
website an iOS app and an Android app a

00:03:14,410 --> 00:03:19,209
little bit about the text the text SEC

00:03:16,700 --> 00:03:23,900
at the time when we started this project

00:03:19,209 --> 00:03:26,060
it was a season rails 3 mono s app it

00:03:23,900 --> 00:03:29,480
had multiple versions up for their API

00:03:26,060 --> 00:03:33,109
is API v1 v2 v3 internal API developer

00:03:29,480 --> 00:03:35,209
API and as its normal with a lot of

00:03:33,109 --> 00:03:36,590
seasoned rails apps and I bet a lot of

00:03:35,209 --> 00:03:39,530
people who have an experience with that

00:03:36,590 --> 00:03:42,320
here too is that over time it gets

00:03:39,530 --> 00:03:45,859
really challenging to deploy to iterate

00:03:42,320 --> 00:03:48,049
to run tests and I remember even booting

00:03:45,859 --> 00:03:51,180
our app with sometimes take like 40

00:03:48,049 --> 00:03:53,459
seconds just for rails server

00:03:51,180 --> 00:03:56,519
and to make things even more interesting

00:03:53,459 --> 00:04:00,900
and fun I was the only web developer

00:03:56,519 --> 00:04:03,090
working on it at the time so we get

00:04:00,900 --> 00:04:04,860
these news there's a a challenge here

00:04:03,090 --> 00:04:07,650
we're gonna build an entirely new

00:04:04,860 --> 00:04:09,840
product and that's very very common if

00:04:07,650 --> 00:04:11,280
you're working at a startup you're still

00:04:09,840 --> 00:04:12,720
trying to figure out product market fit

00:04:11,280 --> 00:04:14,370
you're still trying to figure out how

00:04:12,720 --> 00:04:16,190
you're gonna make money you're trying to

00:04:14,370 --> 00:04:18,209
build the product that people love and

00:04:16,190 --> 00:04:19,799
oftentimes you're gonna have to change a

00:04:18,209 --> 00:04:22,410
lot of things and that's kind of what

00:04:19,799 --> 00:04:26,190
happened to us but there was a caveat

00:04:22,410 --> 00:04:30,120
there was a nine-month deadline that for

00:04:26,190 --> 00:04:31,830
us to rebuild everything so we knew we

00:04:30,120 --> 00:04:34,410
needed to make some changes there was no

00:04:31,830 --> 00:04:36,720
way that that's going to be sustainable

00:04:34,410 --> 00:04:38,669
it's an app that we can barely boot in

00:04:36,720 --> 00:04:40,800
development and we're gonna have to make

00:04:38,669 --> 00:04:42,150
these drastic changes we're gonna add a

00:04:40,800 --> 00:04:43,530
bunch of new features we're gonna

00:04:42,150 --> 00:04:45,510
deprecated a bunch of other features

00:04:43,530 --> 00:04:47,539
we're gonna change some other ones we're

00:04:45,510 --> 00:04:50,160
gonna build a radically different UI

00:04:47,539 --> 00:04:54,389
there's no way that I can do that on my

00:04:50,160 --> 00:04:57,530
own so there's this and then there's an

00:04:54,389 --> 00:05:00,240
entire discussion about how you rescue a

00:04:57,530 --> 00:05:02,310
legacy rails codebase or any other

00:05:00,240 --> 00:05:03,810
codebase and the first thing that comes

00:05:02,310 --> 00:05:05,130
to mind is like oh yeah I'm just gonna

00:05:03,810 --> 00:05:07,190
split it in micro services and

00:05:05,130 --> 00:05:09,570
everything is gonna work fine but

00:05:07,190 --> 00:05:12,270
there's an entire discussion about this

00:05:09,570 --> 00:05:15,000
or just the majestic monolith and the

00:05:12,270 --> 00:05:17,400
micro services it's not my talk but it's

00:05:15,000 --> 00:05:18,900
the first thing that comes to mind and I

00:05:17,400 --> 00:05:21,599
don't think it's a binary decision I

00:05:18,900 --> 00:05:24,510
think there's pros and cons to each one

00:05:21,599 --> 00:05:25,919
of them and it's really a choice that

00:05:24,510 --> 00:05:28,740
you make and you're gonna have to deal

00:05:25,919 --> 00:05:31,949
with those consequences but one thing to

00:05:28,740 --> 00:05:34,860
keep in mind here is we have a very

00:05:31,949 --> 00:05:37,590
small team it's me working on back-end

00:05:34,860 --> 00:05:40,020
and web front-end to Android engineers

00:05:37,590 --> 00:05:42,599
to iOS engineers that's it we need to

00:05:40,020 --> 00:05:44,900
build an entirely new brother very

00:05:42,599 --> 00:05:47,010
limited resources very tight deadlines

00:05:44,900 --> 00:05:48,780
well the more we thought about it we

00:05:47,010 --> 00:05:50,430
realized that there might be a

00:05:48,780 --> 00:05:52,530
compromise that we can make the

00:05:50,430 --> 00:05:54,690
something that's kind of in between we

00:05:52,530 --> 00:05:57,090
can create a this hybrid approach that's

00:05:54,690 --> 00:05:59,969
a very rich API and then we'll build

00:05:57,090 --> 00:06:03,029
some some more specific clients instead

00:05:59,969 --> 00:06:03,970
of just going full-on all the way micro

00:06:03,029 --> 00:06:05,260
services

00:06:03,970 --> 00:06:07,030
we might actually be able to take an

00:06:05,260 --> 00:06:10,540
incremental approach and that's where

00:06:07,030 --> 00:06:12,820
we're gonna get with this talk but then

00:06:10,540 --> 00:06:15,160
the moment you make that decision okay

00:06:12,820 --> 00:06:17,380
we're gonna we're going the kind of the

00:06:15,160 --> 00:06:19,300
distributed route we're not gonna keep

00:06:17,380 --> 00:06:21,550
everything contained in one place

00:06:19,300 --> 00:06:23,650
separate things a little bit how do you

00:06:21,550 --> 00:06:25,840
make these different apps communicate

00:06:23,650 --> 00:06:29,140
now so the first thing that comes to

00:06:25,840 --> 00:06:31,420
mind is through the database and if you

00:06:29,140 --> 00:06:33,520
do that that's the first thing that

00:06:31,420 --> 00:06:35,950
you're gonna get from anybody who talked

00:06:33,520 --> 00:06:38,350
to you well let's dive into that a

00:06:35,950 --> 00:06:41,500
little bit let's let's talk about why

00:06:38,350 --> 00:06:44,080
database driven integration are so so so

00:06:41,500 --> 00:06:47,260
tempting one of the reasons it's

00:06:44,080 --> 00:06:49,420
tempting is that you get a really really

00:06:47,260 --> 00:06:51,880
nice granularity when you're querying

00:06:49,420 --> 00:06:53,800
your data because you're co-located with

00:06:51,880 --> 00:06:56,260
your database it's very easy to load

00:06:53,800 --> 00:06:58,300
everything that you need and exactly

00:06:56,260 --> 00:07:00,490
what you need with one round trip and

00:06:58,300 --> 00:07:02,440
most importantly especially when you're

00:07:00,490 --> 00:07:05,350
talking in the context of distributed

00:07:02,440 --> 00:07:07,330
systems is that you have asset

00:07:05,350 --> 00:07:09,910
guarantees that your sequel database

00:07:07,330 --> 00:07:12,040
gives you so now you don't have to worry

00:07:09,910 --> 00:07:14,230
about transactions you don't have to

00:07:12,040 --> 00:07:15,640
worry about row backs and all of those

00:07:14,230 --> 00:07:18,550
things because they're all implemented

00:07:15,640 --> 00:07:21,340
in the database for you but why are they

00:07:18,550 --> 00:07:24,220
challenging why why it might not be a

00:07:21,340 --> 00:07:25,720
very good idea and one of the reasons is

00:07:24,220 --> 00:07:28,030
that you end up having to repeat your

00:07:25,720 --> 00:07:30,550
abstractions everywhere so if your

00:07:28,030 --> 00:07:32,440
database is your integration point you

00:07:30,550 --> 00:07:34,600
want every system that connects to that

00:07:32,440 --> 00:07:36,520
database has to re-implement those

00:07:34,600 --> 00:07:38,919
abstractions that you have in your

00:07:36,520 --> 00:07:41,110
entire system row backs are gonna be

00:07:38,919 --> 00:07:43,810
almost impossible because you're dealing

00:07:41,110 --> 00:07:46,900
with the structure of the data and the

00:07:43,810 --> 00:07:48,790
same thing if you make a deploy you make

00:07:46,900 --> 00:07:50,770
a change to your database schema and now

00:07:48,790 --> 00:07:52,960
you have five different services that

00:07:50,770 --> 00:07:54,460
talk directly to that database how do

00:07:52,960 --> 00:07:58,270
you even coordinate all of those

00:07:54,460 --> 00:08:00,190
releases at once so the natural the the

00:07:58,270 --> 00:08:04,480
other option and the option that most

00:08:00,190 --> 00:08:05,890
people go with it's api's but api's are

00:08:04,480 --> 00:08:07,870
not easy either

00:08:05,890 --> 00:08:09,430
they're also challenging and there's a

00:08:07,870 --> 00:08:11,740
lot of challenges with the traditional

00:08:09,430 --> 00:08:14,050
API is do but one thing that I really

00:08:11,740 --> 00:08:16,300
love about the Ruby on Rails community

00:08:14,050 --> 00:08:16,720
especially is that it's very easy to

00:08:16,300 --> 00:08:19,870
create

00:08:16,720 --> 00:08:22,630
api's rails makes that super easy for us

00:08:19,870 --> 00:08:25,120
or Sinatra or any other tool it's very

00:08:22,630 --> 00:08:27,970
easy to just fire up a new endpoint and

00:08:25,120 --> 00:08:30,130
start writing code so our communities

00:08:27,970 --> 00:08:31,900
used to this and I bet a lot of people

00:08:30,130 --> 00:08:34,000
are gonna relate with this challenges

00:08:31,900 --> 00:08:36,400
that I've then we're gonna bring up the

00:08:34,000 --> 00:08:39,669
first one of them is just the number of

00:08:36,400 --> 00:08:41,500
use cases so there's this this challenge

00:08:39,669 --> 00:08:43,510
now when you start to build an API is

00:08:41,500 --> 00:08:46,660
that it has to cater to most pool use

00:08:43,510 --> 00:08:48,580
cases you might have a use case that's

00:08:46,660 --> 00:08:52,990
an internal system you might have

00:08:48,580 --> 00:08:55,390
another one that is a you are you why in

00:08:52,990 --> 00:08:57,580
many other scenarios like those there's

00:08:55,390 --> 00:09:00,700
one example that I read of this blog

00:08:57,580 --> 00:09:02,740
post once but from SoundCloud that there

00:09:00,700 --> 00:09:05,440
were going the microservices route and

00:09:02,740 --> 00:09:07,870
they were redoing their UI and just

00:09:05,440 --> 00:09:11,770
surrendered their their track page with

00:09:07,870 --> 00:09:13,720
comments they would have to make 38 Ajax

00:09:11,770 --> 00:09:16,330
calls just to talk to all the micro

00:09:13,720 --> 00:09:19,270
services that they have to so you start

00:09:16,330 --> 00:09:22,450
to you have this there's this challenge

00:09:19,270 --> 00:09:25,180
now that you have to do I make my API is

00:09:22,450 --> 00:09:27,220
very rich and cater to every possible

00:09:25,180 --> 00:09:29,950
scenario at the expense of possibly

00:09:27,220 --> 00:09:32,490
making it more complex and slow or do I

00:09:29,950 --> 00:09:34,660
make my endpoints with just one

00:09:32,490 --> 00:09:36,220
responsibility and leave it up to my

00:09:34,660 --> 00:09:39,580
clients to coordinate with all those

00:09:36,220 --> 00:09:42,010
endpoints and then there's the different

00:09:39,580 --> 00:09:45,880
access patterns you might have an iOS

00:09:42,010 --> 00:09:48,670
app that needs some data you might have

00:09:45,880 --> 00:09:50,560
your website that needs just different

00:09:48,670 --> 00:09:52,420
data in a different format in a

00:09:50,560 --> 00:09:53,860
different transport and that just gets

00:09:52,420 --> 00:09:56,440
really complicated

00:09:53,860 --> 00:09:58,839
another problem is ambiguity when you're

00:09:56,440 --> 00:10:01,390
when you're building an API and the way

00:09:58,839 --> 00:10:04,150
to solve ambiguity is with documentation

00:10:01,390 --> 00:10:06,640
and conventions or conventions but

00:10:04,150 --> 00:10:10,290
conventions have a little challenge too

00:10:06,640 --> 00:10:12,850
so this is the universal sign for okay

00:10:10,290 --> 00:10:14,500
everywhere I gave this talk I would

00:10:12,850 --> 00:10:16,230
bring up this thing and everyone's like

00:10:14,500 --> 00:10:18,700
yeah it's okay that's what he means

00:10:16,230 --> 00:10:20,740
except where I was raised

00:10:18,700 --> 00:10:22,990
this could mean something very offensive

00:10:20,740 --> 00:10:24,930
if you're curious about it you can come

00:10:22,990 --> 00:10:28,930
ask me later

00:10:24,930 --> 00:10:31,269
let's talk about graph QL that was had

00:10:28,930 --> 00:10:35,199
just come out as an open source solution

00:10:31,269 --> 00:10:36,819
by Facebook and there was a lot of hype

00:10:35,199 --> 00:10:39,430
around it a lot of people were talking

00:10:36,819 --> 00:10:40,990
about it decided to take a look to see

00:10:39,430 --> 00:10:43,300
if there was something that we could

00:10:40,990 --> 00:10:45,220
leverage for this is what we're we're

00:10:43,300 --> 00:10:46,720
trying to solve and one way to

00:10:45,220 --> 00:10:48,639
understand graph duo is that it's a

00:10:46,720 --> 00:10:51,220
language specification to the fine and

00:10:48,639 --> 00:10:54,189
query api's and we're gonna get more

00:10:51,220 --> 00:10:56,259
into that now the first thing to keep in

00:10:54,189 --> 00:10:58,779
mind about graph QL is that it comes

00:10:56,259 --> 00:11:00,819
with three main characteristics the

00:10:58,779 --> 00:11:03,279
first one is that you can describe your

00:11:00,819 --> 00:11:05,499
data with types and I'll show you an

00:11:03,279 --> 00:11:09,069
example of that here's a type I'm

00:11:05,499 --> 00:11:11,199
creating a type that almost every Ruby

00:11:09,069 --> 00:11:13,749
developer is gonna be familiar with and

00:11:11,199 --> 00:11:17,199
I'm calling it a ruby gem and the type

00:11:13,749 --> 00:11:19,110
ruby gem comes with three feuds a name

00:11:17,199 --> 00:11:21,730
feud that happens to be a string a

00:11:19,110 --> 00:11:23,800
downloads' feud that's an integer that's

00:11:21,730 --> 00:11:26,199
the number of downloads and aversions

00:11:23,800 --> 00:11:28,959
field that is an array of the version

00:11:26,199 --> 00:11:31,329
type so I can make certain guarantees

00:11:28,959 --> 00:11:33,189
about the shape of my data here when I'm

00:11:31,329 --> 00:11:35,379
using graph key well there's a strong

00:11:33,189 --> 00:11:39,459
contract now that's enforced by a type

00:11:35,379 --> 00:11:41,319
when I'm using my my API the second

00:11:39,459 --> 00:11:44,410
characteristic is there you can load

00:11:41,319 --> 00:11:46,569
just what you need only what your client

00:11:44,410 --> 00:11:49,449
needs to load and here's an example this

00:11:46,569 --> 00:11:52,089
is how a graph QL query looks like so

00:11:49,449 --> 00:11:56,649
I'm defining a query and it's for the

00:11:52,089 --> 00:11:57,990
ruby gem feud with the name rail and i

00:11:56,649 --> 00:12:02,949
really want to know how many downloads

00:11:57,990 --> 00:12:05,559
the ruby gem rails hat so you can see

00:12:02,949 --> 00:12:08,259
that it's it's very product centric it's

00:12:05,559 --> 00:12:11,829
I'll let the clients dictate what they

00:12:08,259 --> 00:12:13,389
want out of my API and third

00:12:11,829 --> 00:12:15,670
characteristic is that you get

00:12:13,389 --> 00:12:19,120
predictable results out of it when you

00:12:15,670 --> 00:12:22,929
combine type contracts with the query

00:12:19,120 --> 00:12:25,089
language that let you import only the

00:12:22,929 --> 00:12:28,089
data that you need you get predictable

00:12:25,089 --> 00:12:30,910
results so here's the result for the API

00:12:28,089 --> 00:12:31,990
call I got my ruby gem it's name is

00:12:30,910 --> 00:12:34,180
Rails

00:12:31,990 --> 00:12:37,029
and it has too many downloads there's a

00:12:34,180 --> 00:12:39,250
guarantee that this the format of that

00:12:37,029 --> 00:12:41,500
data is not gonna change there's a

00:12:39,250 --> 00:12:43,120
guarantee that feuds are not going to be

00:12:41,500 --> 00:12:44,410
taken away and there's a guarantee that

00:12:43,120 --> 00:12:47,649
extra fields are not going to be

00:12:44,410 --> 00:12:51,160
included graphical focuses on the

00:12:47,649 --> 00:12:53,080
clients that's the the takeaway from the

00:12:51,160 --> 00:12:56,730
entire talk is that when you're writing

00:12:53,080 --> 00:13:00,670
graph QL you're thinking of the client

00:12:56,730 --> 00:13:04,000
graph QL and Ruby are an awesome combo

00:13:00,670 --> 00:13:06,720
and I'm gonna show you why I'm gonna

00:13:04,000 --> 00:13:06,720
show you some code

00:13:12,490 --> 00:13:19,960
okay we can start here so graph goooo

00:13:17,260 --> 00:13:22,540
this is not necessarily graph go up this

00:13:19,960 --> 00:13:25,080
is just a graph QL API and what I did

00:13:22,540 --> 00:13:28,050
here to make to create a nice example

00:13:25,080 --> 00:13:31,660
was that I forked the rubygems.org

00:13:28,050 --> 00:13:35,200
codebase on github and I implemented a

00:13:31,660 --> 00:13:40,320
new API for them and here's how it looks

00:13:35,200 --> 00:13:40,320
like let's start over

00:13:41,540 --> 00:13:46,459
and this tool that we're using here is a

00:13:43,639 --> 00:13:48,320
tool called graphical it's just a user

00:13:46,459 --> 00:13:51,230
interface for exploring graphical you

00:13:48,320 --> 00:13:53,930
eyes what's going on here is that

00:13:51,230 --> 00:13:57,800
remember that I mentioned this thing

00:13:53,930 --> 00:13:59,420
called types so if now that I have types

00:13:57,800 --> 00:14:02,000
I actually have documentation that's

00:13:59,420 --> 00:14:04,009
generated by my types so what I'm gonna

00:14:02,000 --> 00:14:06,410
do here is I'm gonna explore this type

00:14:04,009 --> 00:14:08,600
ruby gem that we just talked about and

00:14:06,410 --> 00:14:10,399
I'll see it has a description it's a

00:14:08,600 --> 00:14:12,980
package of Ruby code with specific

00:14:10,399 --> 00:14:15,649
functionality and it has feud's it has a

00:14:12,980 --> 00:14:17,660
downloads field it has a name whew

00:14:15,649 --> 00:14:19,940
that's a string and aversions view

00:14:17,660 --> 00:14:21,829
that's the type version so I'm gonna

00:14:19,940 --> 00:14:26,089
start writing a query here and I'm gonna

00:14:21,829 --> 00:14:29,480
start exploring my API I'm gonna type

00:14:26,089 --> 00:14:32,240
Ruby jams and there's a ruby gems field

00:14:29,480 --> 00:14:33,620
and it says it returns a ruby gem and it

00:14:32,240 --> 00:14:35,630
actually loads a collection of all

00:14:33,620 --> 00:14:38,209
available ruby gems I'm interested in

00:14:35,630 --> 00:14:40,880
that let's see what's up and I'm gonna

00:14:38,209 --> 00:14:46,040
just go bracket here and I'm gonna type

00:14:40,880 --> 00:14:49,370
name and boom I just ran a query now

00:14:46,040 --> 00:14:50,990
that gets the name of all the ruby gems

00:14:49,370 --> 00:14:53,630
that I have in my local database here

00:14:50,990 --> 00:14:56,449
and you can see it on the right I'm just

00:14:53,630 --> 00:14:58,220
gonna close this that I get action cave

00:14:56,449 --> 00:15:02,060
election may alert bah blah blah blah

00:14:58,220 --> 00:15:03,920
blah a lot of lot of ruby gems and let's

00:15:02,060 --> 00:15:08,420
let's keep exploring let's see what else

00:15:03,920 --> 00:15:09,829
can we do here downloads the number of

00:15:08,420 --> 00:15:11,020
downloads for this ruby gem let's see

00:15:09,829 --> 00:15:13,090
what's up

00:15:11,020 --> 00:15:14,740
the same idea I get zero here because

00:15:13,090 --> 00:15:16,890
this is my local database but in

00:15:14,740 --> 00:15:19,990
production you would get actual numbers

00:15:16,890 --> 00:15:21,940
and I can keep going there's a there's a

00:15:19,990 --> 00:15:23,860
third field they're called versions and

00:15:21,940 --> 00:15:26,140
as all versions ever published for this

00:15:23,860 --> 00:15:28,780
rubygem let's see what's what's this

00:15:26,140 --> 00:15:31,390
thing and it gives me the author's the

00:15:28,780 --> 00:15:34,390
dependencies the number let's see all

00:15:31,390 --> 00:15:36,940
the version numbers Oh

00:15:34,390 --> 00:15:39,130
for action cable F I have five zero

00:15:36,940 --> 00:15:40,780
three four action alerts I actually have

00:15:39,130 --> 00:15:43,210
two versions for action they learn in my

00:15:40,780 --> 00:15:45,310
database four zero three four two seven

00:15:43,210 --> 00:15:50,560
one that's really cool let's see code

00:15:45,310 --> 00:15:52,710
now let's see how do we do this so

00:15:50,560 --> 00:15:55,930
here's an example that I put together

00:15:52,710 --> 00:15:57,940
and remember that type definition that I

00:15:55,930 --> 00:16:00,180
just shared a minute ago this is the

00:15:57,940 --> 00:16:02,440
exact same thing and this is why I think

00:16:00,180 --> 00:16:04,600
Ruby and graphic you all are just such a

00:16:02,440 --> 00:16:06,600
great match because the language is just

00:16:04,600 --> 00:16:07,900
so extensible when it's so easy to build

00:16:06,600 --> 00:16:10,120
DSL

00:16:07,900 --> 00:16:11,560
they you actually get a really nice DSL

00:16:10,120 --> 00:16:14,350
like this I haven't seen anything

00:16:11,560 --> 00:16:17,020
remotely like this try another graph do

00:16:14,350 --> 00:16:17,890
all implementations so let's look at how

00:16:17,020 --> 00:16:20,410
this thing works

00:16:17,890 --> 00:16:22,480
so I'm defining an object type it makes

00:16:20,410 --> 00:16:25,570
sense of rubygems of the object and I'm

00:16:22,480 --> 00:16:27,520
giving it a name the name for it is ruby

00:16:25,570 --> 00:16:29,620
gem that description we just saw a

00:16:27,520 --> 00:16:33,040
minute ago and I'm just going to define

00:16:29,620 --> 00:16:36,460
a few a few called name and it's up the

00:16:33,040 --> 00:16:39,160
type string a few name downloads of the

00:16:36,460 --> 00:16:43,300
type int and that's the exact same thing

00:16:39,160 --> 00:16:45,310
that we saw just there the the bank here

00:16:43,300 --> 00:16:48,160
read before a type string just means

00:16:45,310 --> 00:16:51,250
that it's a required field it means that

00:16:48,160 --> 00:16:53,490
it's never know my clients can be sure

00:16:51,250 --> 00:16:56,800
that a ruby gem will always have a name

00:16:53,490 --> 00:16:59,050
if I keep scrolling down here this is

00:16:56,800 --> 00:17:00,700
how we actually implement that query so

00:16:59,050 --> 00:17:02,920
I just listed all the Ruby gems in my

00:17:00,700 --> 00:17:05,500
database and that's just plain old

00:17:02,920 --> 00:17:07,690
active record I'll just do a ruby gem

00:17:05,500 --> 00:17:10,630
doll call and that would just return on

00:17:07,690 --> 00:17:12,700
my Ruby gems and graph you all take care

00:17:10,630 --> 00:17:14,140
of transforming those Ruby gems into the

00:17:12,700 --> 00:17:16,390
ruby gem type

00:17:14,140 --> 00:17:17,860
and everything else here is just a

00:17:16,390 --> 00:17:19,360
little bit of boilerplate to make sure

00:17:17,860 --> 00:17:21,280
that we're we're doing the right thing

00:17:19,360 --> 00:17:22,929
so basically I'm doing the same thing

00:17:21,280 --> 00:17:25,720
defining a feud rubygems

00:17:22,929 --> 00:17:29,140
that returns a repeat an array of

00:17:25,720 --> 00:17:31,030
rubygem types and I have to give the

00:17:29,140 --> 00:17:32,559
field a way for it to resolve itself and

00:17:31,030 --> 00:17:38,559
it is to just download all the revisions

00:17:32,559 --> 00:17:42,660
so we go back here magic all those

00:17:38,559 --> 00:17:46,900
things are here now let's look at a more

00:17:42,660 --> 00:17:49,660
a little more advanced example the same

00:17:46,900 --> 00:17:52,030
way that I that's cool but that doesn't

00:17:49,660 --> 00:17:55,570
it's not any better than just doing rest

00:17:52,030 --> 00:17:57,640
with importing nested views right

00:17:55,570 --> 00:18:00,130
because I'm just hitting that end point

00:17:57,640 --> 00:18:02,350
when no parameters or anything so here's

00:18:00,130 --> 00:18:04,210
another another example it's defining

00:18:02,350 --> 00:18:06,520
another few that's a little more complex

00:18:04,210 --> 00:18:08,500
I'm calling this food a ruby gem by name

00:18:06,520 --> 00:18:11,500
and basically what I'm doing

00:18:08,500 --> 00:18:13,450
is that it returns a ruby gem type and

00:18:11,500 --> 00:18:15,309
it takes in an argument the arguments a

00:18:13,450 --> 00:18:19,900
name and it's up the type string and

00:18:15,309 --> 00:18:22,120
it's required and say mode active record

00:18:19,900 --> 00:18:24,570
magic down here I get that argument by

00:18:22,120 --> 00:18:30,040
name and I do a ruby gem fine by name

00:18:24,570 --> 00:18:32,880
let's go back to the demo I'm just gonna

00:18:30,040 --> 00:18:32,880
comment this out

00:18:34,529 --> 00:18:40,080
and I'm gonna start typing same idea I

00:18:38,339 --> 00:18:42,719
get my ruby gem by name it has that

00:18:40,080 --> 00:18:45,509
description that I just gave it ruby gem

00:18:42,719 --> 00:18:46,709
by name and I'm actually just gonna hit

00:18:45,509 --> 00:18:50,009
enter let's see what happens

00:18:46,709 --> 00:18:52,109
oops something's up here and I got an

00:18:50,009 --> 00:18:53,849
error message a few ruby gem by name is

00:18:52,109 --> 00:18:55,830
missing the require my argument name

00:18:53,849 --> 00:18:57,659
that's really cool because yeah there's

00:18:55,830 --> 00:19:00,779
a there's a type there's a compilation

00:18:57,659 --> 00:19:03,719
happening for this feud that I just

00:19:00,779 --> 00:19:05,959
defined and I get a really nice little

00:19:03,719 --> 00:19:09,869
error message here okay let's keep going

00:19:05,959 --> 00:19:10,229
let's give it a name let's look for many

00:19:09,869 --> 00:19:14,700
tests

00:19:10,229 --> 00:19:16,889
Oh write their name many tests and I I

00:19:14,700 --> 00:19:20,009
could be building a page now that just

00:19:16,889 --> 00:19:21,599
shows some Ruby a specific ruby gem and

00:19:20,009 --> 00:19:23,849
the number downloads that ruby gem has

00:19:21,599 --> 00:19:27,059
and I can keep going out just gonna get

00:19:23,849 --> 00:19:29,159
the versions again and the versions I'm

00:19:27,059 --> 00:19:31,440
gonna get who are the authors who's the

00:19:29,159 --> 00:19:33,929
author for many tests I don't know Ryan

00:19:31,440 --> 00:19:36,179
Davis for the two versions that way that

00:19:33,929 --> 00:19:43,009
we have let's see what version numbers

00:19:36,179 --> 00:19:43,009
are those 5 10 3 5 10 1 is really cool

00:19:43,759 --> 00:19:49,499
so another example here it's just more

00:19:46,769 --> 00:19:51,719
types I can go and I could enrich my

00:19:49,499 --> 00:19:55,559
Ruby Jam types and just add more fuse as

00:19:51,719 --> 00:19:57,989
I need I could add created it at I could

00:19:55,559 --> 00:19:59,279
add another few that's versions it's

00:19:57,989 --> 00:20:01,109
that field that we're just looking at

00:19:59,279 --> 00:20:03,749
and the way to load versions is just to

00:20:01,109 --> 00:20:06,809
do ruby jammed all versions really cool

00:20:03,749 --> 00:20:08,549
i had one like i might get the latest

00:20:06,809 --> 00:20:11,219
version oh my god the number of

00:20:08,549 --> 00:20:13,499
downloads and i can find even more types

00:20:11,219 --> 00:20:15,539
I can just keep defining my types I'm

00:20:13,499 --> 00:20:17,369
gonna find the version type here now and

00:20:15,539 --> 00:20:19,589
aversions the specific version of a ruby

00:20:17,369 --> 00:20:21,919
gem his authors it has a description

00:20:19,589 --> 00:20:24,389
number summary

00:20:21,919 --> 00:20:27,089
blah blah blah same thing more

00:20:24,389 --> 00:20:28,409
dependencies of the pendency type is it

00:20:27,089 --> 00:20:31,200
dependency for a specific version of a

00:20:28,409 --> 00:20:34,880
ruby gem has requirements has scope has

00:20:31,200 --> 00:20:40,980
a name so I want some forth

00:20:34,880 --> 00:20:41,660
so it's really cool so here's what

00:20:40,980 --> 00:20:46,950
happened

00:20:41,660 --> 00:20:49,290
we built a graph cool API on top of

00:20:46,950 --> 00:20:51,000
hormonal s so going back to the

00:20:49,290 --> 00:20:53,430
beginning of the talk we're talking

00:20:51,000 --> 00:20:55,500
about why it's challenging and tempting

00:20:53,430 --> 00:20:57,240
to do a database driven integration and

00:20:55,500 --> 00:20:59,640
why it's challenging and tempting to

00:20:57,240 --> 00:21:01,890
through an API based integration and it

00:20:59,640 --> 00:21:04,380
turns out that we were able to find a

00:21:01,890 --> 00:21:05,880
solution that combines the things

00:21:04,380 --> 00:21:08,730
they're attempting for both of those

00:21:05,880 --> 00:21:11,670
because now I can get the granularity

00:21:08,730 --> 00:21:14,150
that I want for my data and I can also

00:21:11,670 --> 00:21:16,890
deal with a lot of those challenges of

00:21:14,150 --> 00:21:18,780
also serving different clients with

00:21:16,890 --> 00:21:20,760
exactly the data that they need and

00:21:18,780 --> 00:21:23,580
maintainability and documentation that

00:21:20,760 --> 00:21:25,980
just comes built-in with the technology

00:21:23,580 --> 00:21:27,660
because you're using types and because

00:21:25,980 --> 00:21:29,700
you're encouraged to define the

00:21:27,660 --> 00:21:33,180
description for those types that are

00:21:29,700 --> 00:21:35,490
co-located with the implementation so

00:21:33,180 --> 00:21:39,180
basically what we did at the end was to

00:21:35,490 --> 00:21:40,950
use graph QL as an integration layer for

00:21:39,180 --> 00:21:43,530
those services that we wanted to expect

00:21:40,950 --> 00:21:47,160
to expose so instead of breaking the

00:21:43,530 --> 00:21:49,110
entire model list and different micro

00:21:47,160 --> 00:21:52,110
services we actually just started to

00:21:49,110 --> 00:21:54,750
build new things outside of the monorail

00:21:52,110 --> 00:21:57,990
and connect them through graph QL and

00:21:54,750 --> 00:22:00,420
the exact same thing with our UI's so

00:21:57,990 --> 00:22:03,300
here's how if current architecture looks

00:22:00,420 --> 00:22:05,100
like except though we're writing

00:22:03,300 --> 00:22:08,060
software we make mistakes and that's

00:22:05,100 --> 00:22:12,180
kind of how it looks so you can see

00:22:08,060 --> 00:22:15,810
clients there on the left and then the

00:22:12,180 --> 00:22:17,100
internet super reliable an API gate wait

00:22:15,810 --> 00:22:20,040
you don't have to worry about that right

00:22:17,100 --> 00:22:22,580
now and then services and services go up

00:22:20,040 --> 00:22:25,470
and down they get slow they break it's

00:22:22,580 --> 00:22:28,230
just the way things are but you can see

00:22:25,470 --> 00:22:30,750
the different services now can actually

00:22:28,230 --> 00:22:32,730
go to the monorail in the graph QL API

00:22:30,750 --> 00:22:34,560
and treat them as the source of truth

00:22:32,730 --> 00:22:37,740
they don't have to talk to the database

00:22:34,560 --> 00:22:41,010
they don't have to create a million

00:22:37,740 --> 00:22:42,690
different api's in the monorail to cater

00:22:41,010 --> 00:22:45,070
to all of these different clients and

00:22:42,690 --> 00:22:47,049
different usages of the data

00:22:45,070 --> 00:22:51,070
and we can actually have the UI is just

00:22:47,049 --> 00:22:53,590
talk to grass cool when they had to so

00:22:51,070 --> 00:22:56,019
that actually worked out really well for

00:22:53,590 --> 00:22:58,840
us we still have all those guarantees

00:22:56,019 --> 00:23:01,419
the monorail still exists is so amazing

00:22:58,840 --> 00:23:03,250
but they rarely have to touch it these

00:23:01,419 --> 00:23:07,059
days because a lot of the data models

00:23:03,250 --> 00:23:10,240
already exposed in graph Google but of

00:23:07,059 --> 00:23:11,889
course not everything is pretty not

00:23:10,240 --> 00:23:13,750
everything's perfect

00:23:11,889 --> 00:23:15,940
there's also challenges with running

00:23:13,750 --> 00:23:19,240
graph Google and rails in production and

00:23:15,940 --> 00:23:21,580
the first one is our good old friends

00:23:19,240 --> 00:23:23,409
and +1 queries and don't worry if you're

00:23:21,580 --> 00:23:27,399
not familiar with n +1 queries we'll get

00:23:23,409 --> 00:23:30,039
there but what I find funny about M plus

00:23:27,399 --> 00:23:32,620
1 queries is that every single rails

00:23:30,039 --> 00:23:35,409
code base that I worked on in my career

00:23:32,620 --> 00:23:37,120
it always had challenges with those they

00:23:35,409 --> 00:23:40,029
always had challenges with waiting +1

00:23:37,120 --> 00:23:42,580
queries and the reason is that it's too

00:23:40,029 --> 00:23:45,009
easy to just load data dynamically it's

00:23:42,580 --> 00:23:49,779
too convenient and sometimes we just

00:23:45,009 --> 00:23:53,500
overlook those things and the reason why

00:23:49,779 --> 00:23:55,750
n +1 queries are just so obvious and

00:23:53,500 --> 00:23:58,289
they would come up so easily we're graph

00:23:55,750 --> 00:24:01,029
go well is that because we're actually

00:23:58,289 --> 00:24:03,159
requesting dynamic data we don't know

00:24:01,029 --> 00:24:06,850
there's no way for our graph QL server

00:24:03,159 --> 00:24:08,710
to know up front exactly what data that

00:24:06,850 --> 00:24:10,240
the client is gonna need because they

00:24:08,710 --> 00:24:11,919
could have just asked for anything and

00:24:10,240 --> 00:24:15,940
we're basically just gonna translate

00:24:11,919 --> 00:24:17,889
that to the database calls and here's an

00:24:15,940 --> 00:24:20,590
example of a schema that we can look

00:24:17,889 --> 00:24:22,570
side-by-side so I put together this

00:24:20,590 --> 00:24:25,419
simple schema for a restaurant and it

00:24:22,570 --> 00:24:27,009
has a recipe type on and you're on the

00:24:25,419 --> 00:24:29,289
left side is just the graphical type

00:24:27,009 --> 00:24:32,919
definition pretty easy to follow and

00:24:29,289 --> 00:24:35,500
then active record on the right so the

00:24:32,919 --> 00:24:38,919
one we're used to and then a recipe mats

00:24:35,500 --> 00:24:40,299
has many ingredients the same thing in a

00:24:38,919 --> 00:24:42,309
graphical type and the active record

00:24:40,299 --> 00:24:44,710
type same thing with the ingredient

00:24:42,309 --> 00:24:46,899
ingredient belongs to a vendor a vendor

00:24:44,710 --> 00:24:49,480
has many ingredients a restaurant

00:24:46,899 --> 00:24:52,030
launched one owner and it has one rating

00:24:49,480 --> 00:24:54,880
and same thing to the left

00:24:52,030 --> 00:24:58,090
and we want to but let's say we want to

00:24:54,880 --> 00:25:00,610
write a report I owned this restaurant I

00:24:58,090 --> 00:25:02,230
want to see where my ingredients are

00:25:00,610 --> 00:25:04,600
coming from and we're selling those

00:25:02,230 --> 00:25:05,680
ingredients to me and I'll look at it

00:25:04,600 --> 00:25:08,080
like the recipes

00:25:05,680 --> 00:25:09,430
I'll grab their title I'll check all the

00:25:08,080 --> 00:25:12,250
ingredients for each one of those

00:25:09,430 --> 00:25:13,780
recipes all the vendors and their name I

00:25:12,250 --> 00:25:16,780
guess that kind of makes sense if I want

00:25:13,780 --> 00:25:19,390
to build that rapport here's how it

00:25:16,780 --> 00:25:22,120
looks like in our console or in

00:25:19,390 --> 00:25:26,470
production here's how you get to those

00:25:22,120 --> 00:25:28,780
five or eight minutes API calls so

00:25:26,470 --> 00:25:30,100
loading all the recipes and then loading

00:25:28,780 --> 00:25:33,310
out ingredients loading all the vendors

00:25:30,100 --> 00:25:34,660
if we zoom in a little bit here's how it

00:25:33,310 --> 00:25:37,090
looks like you select the ingredients

00:25:34,660 --> 00:25:38,590
and you join them by recipe ID and any

00:25:37,090 --> 00:25:41,950
selector vendors for each one of those

00:25:38,590 --> 00:25:43,420
and if you have a thousand recipes all

00:25:41,950 --> 00:25:44,710
of them they're being sourced by

00:25:43,420 --> 00:25:49,000
different vendors this thing is just

00:25:44,710 --> 00:25:51,250
gonna explode this is a complicated

00:25:49,000 --> 00:25:53,770
problem in itself it's really hard it's

00:25:51,250 --> 00:25:54,910
super dynamic I didn't have an answer

00:25:53,770 --> 00:25:56,800
for it right away

00:25:54,910 --> 00:25:58,990
and I'd invested a significant amount of

00:25:56,800 --> 00:26:02,860
time building out a little bit more of

00:25:58,990 --> 00:26:06,700
graph to wall and this problem and I

00:26:02,860 --> 00:26:08,950
thought about it for a long time and I

00:26:06,700 --> 00:26:11,230
knew I knew in my heart that we could

00:26:08,950 --> 00:26:13,810
not go live in production for millions

00:26:11,230 --> 00:26:16,060
of users expecting tens of thousands of

00:26:13,810 --> 00:26:17,530
requests for a minute with inefficient

00:26:16,060 --> 00:26:20,290
database queries there was no way we

00:26:17,530 --> 00:26:22,420
could do it but remember the nine-month

00:26:20,290 --> 00:26:24,550
deadline and the other front end that I

00:26:22,420 --> 00:26:31,630
also had to build and do these other

00:26:24,550 --> 00:26:33,550
api's so Yolo but not really

00:26:31,630 --> 00:26:36,070
we actually found solution eventually

00:26:33,550 --> 00:26:39,890
let's take a look let's take a second

00:26:36,070 --> 00:26:41,809
look at the data model here it is again

00:26:39,890 --> 00:26:43,370
and one day I'm thinking about these

00:26:41,809 --> 00:26:45,710
things and we're trying to figure out

00:26:43,370 --> 00:26:48,860
how to do it and it's funny that like we

00:26:45,710 --> 00:26:50,779
we have our best ideas when like you

00:26:48,860 --> 00:26:52,549
just go to bed and it's like oh I just

00:26:50,779 --> 00:26:54,220
can't sleep because I just had an idea

00:26:52,549 --> 00:26:57,049
I have to go back to my computer and

00:26:54,220 --> 00:26:59,210
that's exactly what happened and I

00:26:57,049 --> 00:27:02,120
started to think about these data models

00:26:59,210 --> 00:27:04,640
and if you look closely you notice that

00:27:02,120 --> 00:27:08,230
it's they're actually super similar they

00:27:04,640 --> 00:27:12,049
almost map one-to-one keep that in mind

00:27:08,230 --> 00:27:14,870
and then I remember this nice little

00:27:12,049 --> 00:27:18,080
trick the active record gives you this

00:27:14,870 --> 00:27:21,830
tool to include the dependencies for the

00:27:18,080 --> 00:27:24,549
data they want to load so if I were to

00:27:21,830 --> 00:27:27,679
build that report myself as a regular

00:27:24,549 --> 00:27:29,600
rails MVC this is what I would have done

00:27:27,679 --> 00:27:31,399
I would have load all the rest loaded

00:27:29,600 --> 00:27:33,529
all the recipes included in ingredients

00:27:31,399 --> 00:27:36,260
and preloaded the vendors with the

00:27:33,529 --> 00:27:39,139
ingredients let's take a look again at

00:27:36,260 --> 00:27:42,409
that graph cool query if you look at the

00:27:39,139 --> 00:27:44,899
left here my types if I look at the

00:27:42,409 --> 00:27:47,179
right those are my includes the things

00:27:44,899 --> 00:27:47,809
that I'm trying to do so that was when

00:27:47,179 --> 00:27:50,929
it clicked

00:27:47,809 --> 00:27:53,990
I could actually translate the graph QL

00:27:50,929 --> 00:27:55,789
query into the active record format

00:27:53,990 --> 00:27:59,419
because I actually have all that

00:27:55,789 --> 00:28:00,799
information there and I could I could

00:27:59,419 --> 00:28:02,929
write some code that translate those

00:28:00,799 --> 00:28:04,940
things and just hope for the best and

00:28:02,929 --> 00:28:06,529
hope that that it works and what's

00:28:04,940 --> 00:28:10,340
really cool about this here is because

00:28:06,529 --> 00:28:12,919
there is a language specification the

00:28:10,340 --> 00:28:15,919
graph Google is a query language there

00:28:12,919 --> 00:28:18,289
is an abstract syntax tree backing up

00:28:15,919 --> 00:28:21,139
every query that comes in so the graph

00:28:18,289 --> 00:28:23,960
Google rubygem has a feature that lets

00:28:21,139 --> 00:28:26,720
you tap into and introspect the query

00:28:23,960 --> 00:28:29,450
and get metadata information about it so

00:28:26,720 --> 00:28:32,179
if the query comes in I can actually get

00:28:29,450 --> 00:28:34,050
all that information and I can translate

00:28:32,179 --> 00:28:36,540
it and

00:28:34,050 --> 00:28:39,960
the the active record format for

00:28:36,540 --> 00:28:41,790
includes and I warn you the code does

00:28:39,960 --> 00:28:45,840
not look pretty it's a lot of meta

00:28:41,790 --> 00:28:47,970
programming there but I can get this the

00:28:45,840 --> 00:28:50,400
moment that we feed that data that we

00:28:47,970 --> 00:28:52,080
got from the query interactive record we

00:28:50,400 --> 00:28:54,840
solved the n plus 1 queries because

00:28:52,080 --> 00:28:58,230
we're just hinting active record of all

00:28:54,840 --> 00:29:00,990
the types that he needs and I put this

00:28:58,230 --> 00:29:03,300
together in this Ruby Jam that I

00:29:00,990 --> 00:29:04,980
published called graph QL query resolver

00:29:03,300 --> 00:29:07,880
if you're curious just go check it out

00:29:04,980 --> 00:29:11,540
you'll look at my horrible code there

00:29:07,880 --> 00:29:14,580
and what did I what did that mean for

00:29:11,540 --> 00:29:18,630
IFTTT I so remember that they would flip

00:29:14,580 --> 00:29:21,210
the switch we killed all and +1 queries

00:29:18,630 --> 00:29:24,870
that we have in our own API s and we saw

00:29:21,210 --> 00:29:27,510
a 60% drop in database operations right

00:29:24,870 --> 00:29:29,160
off the bat this was amazing by just

00:29:27,510 --> 00:29:31,530
using all this information that I was

00:29:29,160 --> 00:29:33,390
available to us all this time we could

00:29:31,530 --> 00:29:37,860
just save that which saved a lot of

00:29:33,390 --> 00:29:40,800
money our services become a lot faster

00:29:37,860 --> 00:29:43,440
and we managed to completely removed all

00:29:40,800 --> 00:29:45,510
the memcache dependencies that we had in

00:29:43,440 --> 00:29:48,900
our rails app that's beautiful

00:29:45,510 --> 00:29:51,600
and because it is it also unlocked a

00:29:48,900 --> 00:29:53,370
second feature as when it comes to

00:29:51,600 --> 00:29:54,780
database optimization and I like to call

00:29:53,370 --> 00:29:58,190
a selectively choosing our database

00:29:54,780 --> 00:30:01,650
environment and what that means is that

00:29:58,190 --> 00:30:03,960
because again we have access to the

00:30:01,650 --> 00:30:06,690
graph QL query coming in and we know

00:30:03,960 --> 00:30:09,090
exactly which fields it touches we know

00:30:06,690 --> 00:30:12,240
whether or not a query is read-only or

00:30:09,090 --> 00:30:14,580
if it has mutations or write operations

00:30:12,240 --> 00:30:16,140
in them so you can write a little bit of

00:30:14,580 --> 00:30:18,210
code and this is kind of how it looks

00:30:16,140 --> 00:30:22,860
like and if you're familiar if you build

00:30:18,210 --> 00:30:24,930
more slightly with a rails app that has

00:30:22,860 --> 00:30:27,840
slightly more traffic you might have to

00:30:24,930 --> 00:30:30,300
have used a replica database or used

00:30:27,840 --> 00:30:31,980
active record established connection or

00:30:30,300 --> 00:30:34,710
any of those options to have more than

00:30:31,980 --> 00:30:38,520
one database in your app we actually had

00:30:34,710 --> 00:30:41,100
that too so you see the green the both

00:30:38,520 --> 00:30:44,040
green thing and the if statement is that

00:30:41,100 --> 00:30:45,030
if my query includes a mutation I'm just

00:30:44,040 --> 00:30:46,920
going to run it in the main

00:30:45,030 --> 00:30:48,780
database that takes rights and if it

00:30:46,920 --> 00:30:50,580
does not I'll just use a replica

00:30:48,780 --> 00:30:54,000
database and guess what this is a

00:30:50,580 --> 00:30:55,890
consumer facing product that has a ton

00:30:54,000 --> 00:30:58,260
of page views of people just browsing

00:30:55,890 --> 00:31:01,830
things so it's actually closer like 90%

00:30:58,260 --> 00:31:04,020
reads and 10% writes and what does that

00:31:01,830 --> 00:31:06,060
mean is it means that we completely

00:31:04,020 --> 00:31:07,950
eliminated contention locks from our

00:31:06,060 --> 00:31:09,780
database and if you're not familiar with

00:31:07,950 --> 00:31:12,810
contention locks this is a problem that

00:31:09,780 --> 00:31:15,240
happens when you have a lot of when your

00:31:12,810 --> 00:31:16,890
database has competing queries try to

00:31:15,240 --> 00:31:18,930
write and read to the same rows in the

00:31:16,890 --> 00:31:20,700
database and that's super common when

00:31:18,930 --> 00:31:22,970
you have things like updating a counter

00:31:20,700 --> 00:31:25,530
of how many people liked or added

00:31:22,970 --> 00:31:27,660
something on your site and you're also

00:31:25,530 --> 00:31:30,090
trying to read those throws rows all the

00:31:27,660 --> 00:31:32,100
time that's actually gone now because

00:31:30,090 --> 00:31:34,290
we're just routing the data that because

00:31:32,100 --> 00:31:35,670
we have that information in the queries

00:31:34,290 --> 00:31:38,160
that are coming in but can actually

00:31:35,670 --> 00:31:42,480
route the the query or mutation to the

00:31:38,160 --> 00:31:45,450
correct database another big challenge

00:31:42,480 --> 00:31:47,580
if you're if you watched and paid

00:31:45,450 --> 00:31:49,200
attention to the talks today to Anna

00:31:47,580 --> 00:31:52,050
stock today she talked about monitoring

00:31:49,200 --> 00:31:54,660
and error tracking and other things and

00:31:52,050 --> 00:31:57,300
a lot of rails apps are going to use a

00:31:54,660 --> 00:32:00,060
monitoring system or error collection

00:31:57,300 --> 00:32:02,640
app too but they have one thing in

00:32:00,060 --> 00:32:05,670
common that's super common with web apps

00:32:02,640 --> 00:32:08,700
is that every tool for almost every tool

00:32:05,670 --> 00:32:11,760
for web apps are optimized on a per

00:32:08,700 --> 00:32:13,320
endpoint basis on a per action and

00:32:11,760 --> 00:32:15,720
controller basis and that's how you

00:32:13,320 --> 00:32:17,880
break down different endpoints and

00:32:15,720 --> 00:32:19,860
different functionality in your app so

00:32:17,880 --> 00:32:22,410
we're after well you remember the demo

00:32:19,860 --> 00:32:24,390
that there's only one API endpoint so

00:32:22,410 --> 00:32:25,050
the moment you plug something in like

00:32:24,390 --> 00:32:28,260
New Relic

00:32:25,050 --> 00:32:32,040
you get this you get a pretty big lump

00:32:28,260 --> 00:32:34,710
of purple coals in there those are all

00:32:32,040 --> 00:32:37,980
duh that's the graph gooooal endpoint so

00:32:34,710 --> 00:32:39,930
okay it's beautiful 90% of all the axis

00:32:37,980 --> 00:32:43,020
is going to graph cool but I don't know

00:32:39,930 --> 00:32:45,930
exactly what they're trying to query so

00:32:43,020 --> 00:32:48,600
not super useful and the same thing

00:32:45,930 --> 00:32:49,380
happens to error so our error tracking

00:32:48,600 --> 00:32:52,050
tool in ohralik

00:32:49,380 --> 00:32:54,060
had the same problem oh I had 45 errors

00:32:52,050 --> 00:32:56,900
and graphic you all controller was no

00:32:54,060 --> 00:32:58,460
method error but

00:32:56,900 --> 00:33:00,500
what could be going on here I have a

00:32:58,460 --> 00:33:02,960
hundred different types in my graph QL

00:33:00,500 --> 00:33:06,350
schema I don't know I don't know what's

00:33:02,960 --> 00:33:08,360
going on and like undefined method empty

00:33:06,350 --> 00:33:12,500
for no class yeah I don't know what that

00:33:08,360 --> 00:33:14,240
is okay we go back to you know we have

00:33:12,500 --> 00:33:15,980
that all that information again it's all

00:33:14,240 --> 00:33:17,570
available it's all in the query it's all

00:33:15,980 --> 00:33:20,090
in the language you can tap into it you

00:33:17,570 --> 00:33:22,250
can read the ast okay let's get the

00:33:20,090 --> 00:33:24,200
query name so if you looked at you

00:33:22,250 --> 00:33:25,970
remember and the demo that I was doing

00:33:24,200 --> 00:33:28,220
rubygem by name

00:33:25,970 --> 00:33:30,470
that's the query name I can set it oh

00:33:28,220 --> 00:33:32,570
hey New Relic that's the name of the

00:33:30,470 --> 00:33:34,310
endpoint I'm trying to you can't figure

00:33:32,570 --> 00:33:36,680
it out but I'll give you a hint that's

00:33:34,310 --> 00:33:38,780
what it is and then you remember we're

00:33:36,680 --> 00:33:41,750
we're defining lambdas to resolve issue

00:33:38,780 --> 00:33:43,970
on of those feeds I wrote some code more

00:33:41,750 --> 00:33:46,820
matter programming that wraps all of

00:33:43,970 --> 00:33:48,950
those lambdas and just tells New Relic

00:33:46,820 --> 00:33:51,560
which lambda I'm trying to sell as I egg

00:33:48,950 --> 00:33:53,900
in a relic just report that under

00:33:51,560 --> 00:33:56,510
graphic you all whew the type name for

00:33:53,900 --> 00:33:58,730
this lambda and the feud name I called

00:33:56,510 --> 00:34:01,670
the old resolver things are good and

00:33:58,730 --> 00:34:04,030
boom here it is I got all my

00:34:01,670 --> 00:34:07,340
transactions again I can see graph QL

00:34:04,030 --> 00:34:10,669
the channels query recipe recommendation

00:34:07,340 --> 00:34:13,399
to query statements action feud blah

00:34:10,669 --> 00:34:16,220
blah blah they're all in there my chart

00:34:13,399 --> 00:34:18,230
is back no more big it's still pretty

00:34:16,220 --> 00:34:19,790
big the purple part but it's actually

00:34:18,230 --> 00:34:21,500
one graph Google query that's the most

00:34:19,790 --> 00:34:23,179
common graph Google query and you see

00:34:21,500 --> 00:34:24,940
all the other top graph QL queries

00:34:23,179 --> 00:34:28,419
throwing up there

00:34:24,940 --> 00:34:31,460
same thing for errors you'll get now

00:34:28,419 --> 00:34:33,470
different graphic you all endpoints and

00:34:31,460 --> 00:34:36,230
the errors in exactly where they happen

00:34:33,470 --> 00:34:38,810
and I can actually know now we're on the

00:34:36,230 --> 00:34:40,970
find method empty for no classes it's in

00:34:38,810 --> 00:34:42,770
the recipe type for my graph queue all

00:34:40,970 --> 00:34:45,520
endpoint that's really neat

00:34:42,770 --> 00:34:47,990
if you're curious if you want to see the

00:34:45,520 --> 00:34:50,690
implementation it's really just a few

00:34:47,990 --> 00:34:55,480
lines a ruby code it's in that this just

00:34:50,690 --> 00:34:55,480
that I put together gql - RB - in our

00:34:55,890 --> 00:35:00,720
where to go next if you're if you're

00:34:59,010 --> 00:35:02,870
excited about Graff cool if you think

00:35:00,720 --> 00:35:04,950
it's something that you could try out I

00:35:02,870 --> 00:35:07,110
recommend checking out the graph Google

00:35:04,950 --> 00:35:09,000
org website there's a lot of other

00:35:07,110 --> 00:35:11,820
features that I didn't mention here for

00:35:09,000 --> 00:35:12,870
the sake of time there is the graph QL

00:35:11,820 --> 00:35:15,390
slack Channel

00:35:12,870 --> 00:35:17,460
there's the Ruby channel and that slack

00:35:15,390 --> 00:35:20,070
group I hang out there

00:35:17,460 --> 00:35:23,730
Robert the author for the graph goooo

00:35:20,070 --> 00:35:25,860
Ruby Jim hangs out there too people are

00:35:23,730 --> 00:35:28,770
super friendly a lot of github people

00:35:25,860 --> 00:35:31,410
from the github graph Google API also

00:35:28,770 --> 00:35:35,550
hang out there and you know check out

00:35:31,410 --> 00:35:38,880
the ruby gem if you do want to work with

00:35:35,550 --> 00:35:41,130
Graff cool my team is hiring segment

00:35:38,880 --> 00:35:44,460
comm slash jobs or come talk to me I

00:35:41,130 --> 00:35:47,520
have a lot of gifts if somebody wants a

00:35:44,460 --> 00:35:51,560
t-shirt or a fidget spinner or pair of

00:35:47,520 --> 00:35:55,860
socks come talk to me after the talk and

00:35:51,560 --> 00:35:58,830
feel free to tweet at me to email me and

00:35:55,860 --> 00:36:00,940
to grab me for questions and thanks a

00:35:58,830 --> 00:36:04,139
lot thanks for being here

00:36:00,940 --> 00:36:04,139
[Applause]

00:36:10,090 --> 00:36:12,150

YouTube URL: https://www.youtube.com/watch?v=Lk3Xx7k1aOk


