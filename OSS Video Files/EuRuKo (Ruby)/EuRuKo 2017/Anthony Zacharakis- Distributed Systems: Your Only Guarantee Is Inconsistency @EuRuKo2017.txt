Title: Anthony Zacharakis- Distributed Systems: Your Only Guarantee Is Inconsistency @EuRuKo2017
Publication date: 2017-12-20
Playlist: EuRuKo 2017
Description: 
	Slides: https://speakerdeck.com/azach/distributed-systems-your-only-guarantee-is-inconsistency
Captions: 
	00:00:14,930 --> 00:00:20,550
hi everybody thanks for coming I know

00:00:18,060 --> 00:00:22,199
it's getting late in the day so it kind

00:00:20,550 --> 00:00:23,400
of gets hard to concentrate but if you

00:00:22,199 --> 00:00:27,780
make it through this you get the coffee

00:00:23,400 --> 00:00:29,670
break so look forward to that I'm

00:00:27,780 --> 00:00:32,309
Anthony I'm here to talk to you about

00:00:29,670 --> 00:00:35,370
distributed systems and specifically the

00:00:32,309 --> 00:00:37,469
cut the inconsistencies the inherent in

00:00:35,370 --> 00:00:39,570
consistencies you get in your data when

00:00:37,469 --> 00:00:41,910
you move to one of these systems and

00:00:39,570 --> 00:00:44,550
with all the buzz around micro services

00:00:41,910 --> 00:00:47,180
and service-oriented architectures today

00:00:44,550 --> 00:00:50,720
this is becoming more and more important

00:00:47,180 --> 00:00:53,579
so I work at digitalocean which is a

00:00:50,720 --> 00:00:55,500
cloud provider of networking storage

00:00:53,579 --> 00:00:58,890
servers all kinds of good things like

00:00:55,500 --> 00:01:00,360
that if you're an email marketing

00:00:58,890 --> 00:01:02,040
company with Black Friday around the

00:01:00,360 --> 00:01:04,860
corner and you need something between a

00:01:02,040 --> 00:01:07,500
hotfix in a long term code solution this

00:01:04,860 --> 00:01:10,770
could be really interesting for you so

00:01:07,500 --> 00:01:13,319
we do infrastructure as a service so

00:01:10,770 --> 00:01:15,380
keep us in mind for that but more

00:01:13,319 --> 00:01:18,990
importantly I work on the billing team

00:01:15,380 --> 00:01:22,880
and I work on everything that's related

00:01:18,990 --> 00:01:25,409
to making payments and invoicing and

00:01:22,880 --> 00:01:27,209
anything related to billing and that's

00:01:25,409 --> 00:01:31,590
kind of what I want to talk to you a

00:01:27,209 --> 00:01:33,779
little bit about today is one of them

00:01:31,590 --> 00:01:36,810
the most important processes in our

00:01:33,779 --> 00:01:41,179
billing system is our month closed

00:01:36,810 --> 00:01:43,439
processing where we tally up all the

00:01:41,179 --> 00:01:46,380
services that our customers have used

00:01:43,439 --> 00:01:49,870
and build them for it and then take any

00:01:46,380 --> 00:01:54,050
appropriate actions that we need to

00:01:49,870 --> 00:01:55,850
afterwards and although of my talk is

00:01:54,050 --> 00:01:57,290
kind of focused on that building example

00:01:55,850 --> 00:01:58,790
because it's something everyone can

00:01:57,290 --> 00:02:00,590
relate to we probably all have

00:01:58,790 --> 00:02:04,940
subscription services and things that we

00:02:00,590 --> 00:02:06,890
use and pay for it's not the concepts

00:02:04,940 --> 00:02:10,009
your kind of transcend that it could

00:02:06,890 --> 00:02:13,130
apply to anything where you have some

00:02:10,009 --> 00:02:14,600
kind of pipeline that you perform one

00:02:13,130 --> 00:02:15,860
step after another after another and

00:02:14,600 --> 00:02:17,000
you're looking to figure out ways to

00:02:15,860 --> 00:02:21,650
scale that up and make it more

00:02:17,000 --> 00:02:25,700
distributed so this is kind of what our

00:02:21,650 --> 00:02:28,250
end of month pipeline looks like we have

00:02:25,700 --> 00:02:29,930
a list of actions that we kind of do for

00:02:28,250 --> 00:02:32,360
each user which is like generate the

00:02:29,930 --> 00:02:35,570
users invoice charge them email them

00:02:32,360 --> 00:02:38,120
place an account holds on people who

00:02:35,570 --> 00:02:41,810
don't pay and then maybe generate

00:02:38,120 --> 00:02:44,450
reports for our internal users and then

00:02:41,810 --> 00:02:45,709
do a bunch of other actions so there's a

00:02:44,450 --> 00:02:47,170
lot of stuff going on here there's a lot

00:02:45,709 --> 00:02:49,100
of stuff that we do it's kind of like

00:02:47,170 --> 00:02:52,190
well-suited for this kind of pipeline

00:02:49,100 --> 00:02:54,170
architecture and this is kind of where

00:02:52,190 --> 00:02:56,180
we where we are or where we were when I

00:02:54,170 --> 00:02:57,530
first started where you kind of have the

00:02:56,180 --> 00:03:00,440
first step in the second step and the

00:02:57,530 --> 00:03:02,709
third step but as we scale up that

00:03:00,440 --> 00:03:06,110
becomes really hard to sustain because

00:03:02,709 --> 00:03:08,360
there's so many actions here there's a

00:03:06,110 --> 00:03:09,860
lot of things that we're doing and they

00:03:08,360 --> 00:03:11,570
don't necessarily need to be performed

00:03:09,860 --> 00:03:13,820
in these orders there's some like loose

00:03:11,570 --> 00:03:17,750
dependencies here but we kind of want to

00:03:13,820 --> 00:03:19,310
turn into a more parallel system so this

00:03:17,750 --> 00:03:21,170
is kind of a slimmed down version of

00:03:19,310 --> 00:03:22,549
what our actual month clothes class

00:03:21,170 --> 00:03:24,709
looks like so we have the service class

00:03:22,549 --> 00:03:27,019
called month close and then we can

00:03:24,709 --> 00:03:29,329
perform these actions for all these

00:03:27,019 --> 00:03:30,890
users and you can see we have all day

00:03:29,329 --> 00:03:34,040
actions here but there's kind of a

00:03:30,890 --> 00:03:36,739
number of different problems with doing

00:03:34,040 --> 00:03:39,049
it all in one class a lot of these

00:03:36,739 --> 00:03:40,730
actions are expensive like generating

00:03:39,049 --> 00:03:43,549
the invoice and kind of figuring out

00:03:40,730 --> 00:03:46,820
what everyone what a user has used is

00:03:43,549 --> 00:03:49,370
pretty expensive to do some of these

00:03:46,820 --> 00:03:50,780
actions have external dependencies like

00:03:49,370 --> 00:03:51,890
if we're going to charge you or we're

00:03:50,780 --> 00:03:54,270
gonna email you we're going to use a

00:03:51,890 --> 00:03:55,940
third party service and

00:03:54,270 --> 00:03:59,610
some of our actually kind of complicated

00:03:55,940 --> 00:04:03,240
so maybe like we have some complicated

00:03:59,610 --> 00:04:05,730
logic here that just makes it harder to

00:04:03,240 --> 00:04:08,160
kind of maintain this class so doing

00:04:05,730 --> 00:04:11,670
everything in one big bucket is not

00:04:08,160 --> 00:04:13,710
ideal and we also kinda have problems

00:04:11,670 --> 00:04:16,410
with like idempotency what if this fails

00:04:13,710 --> 00:04:18,780
halfway through again maybe one of our

00:04:16,410 --> 00:04:22,190
third party services it down and it

00:04:18,780 --> 00:04:25,800
fails what happens when we rerun the job

00:04:22,190 --> 00:04:27,480
what we recharge the user will reduce

00:04:25,800 --> 00:04:29,580
well we have some kind of unintended

00:04:27,480 --> 00:04:31,350
side effect from that it's hard to say

00:04:29,580 --> 00:04:34,710
because again it's long complicated

00:04:31,350 --> 00:04:36,630
messy makes it hard to refactor because

00:04:34,710 --> 00:04:38,810
you don't want to touch anything there's

00:04:36,630 --> 00:04:42,510
like a lot of implicit assumptions there

00:04:38,810 --> 00:04:46,950
so enter background workers this is

00:04:42,510 --> 00:04:48,750
something that's very handy here and I

00:04:46,950 --> 00:04:50,880
kind of wanna extol the virtues of

00:04:48,750 --> 00:04:54,690
background workers they have a lot of

00:04:50,880 --> 00:04:57,060
benefits for this kind of work you can

00:04:54,690 --> 00:04:59,760
persist the jobs in sequel or in Redis

00:04:57,060 --> 00:05:01,920
so as soon as you and queue a job into a

00:04:59,760 --> 00:05:04,710
worker you know it's stored there and

00:05:01,920 --> 00:05:07,650
it's gonna run at some point you have

00:05:04,710 --> 00:05:09,960
prioritized job queue so you can give

00:05:07,650 --> 00:05:14,550
each worker a different priority so it

00:05:09,960 --> 00:05:16,680
some might run faster or sooner and if

00:05:14,550 --> 00:05:18,000
you have the low priority job like some

00:05:16,680 --> 00:05:21,420
kind of report worker or something you

00:05:18,000 --> 00:05:24,960
don't care when it gets run then you can

00:05:21,420 --> 00:05:27,180
set a lower priority you can do media

00:05:24,960 --> 00:05:30,660
recurring or delayed scheduling so you

00:05:27,180 --> 00:05:32,730
can kind of set something to run now as

00:05:30,660 --> 00:05:34,830
soon as it's a it's possible to process

00:05:32,730 --> 00:05:37,350
or maybe later maybe you want to get it

00:05:34,830 --> 00:05:38,850
around to in a few hours so maybe you

00:05:37,350 --> 00:05:42,570
want to send this email tomorrow or

00:05:38,850 --> 00:05:44,520
something like that the big benefit for

00:05:42,570 --> 00:05:46,320
us is there that there's an automatic

00:05:44,520 --> 00:05:49,260
retry see and you can configure this

00:05:46,320 --> 00:05:51,600
obviously but it kind of gives you that

00:05:49,260 --> 00:05:54,270
free automatic retrying effect where

00:05:51,600 --> 00:05:55,710
maybe your worker fails halfway through

00:05:54,270 --> 00:05:58,020
because of a network issue

00:05:55,710 --> 00:06:00,570
it'll just rerun again at some point and

00:05:58,020 --> 00:06:01,770
once that network issue clears up like

00:06:00,570 --> 00:06:02,790
you don't have to think about it you

00:06:01,770 --> 00:06:05,479
don't have to go in and do anything

00:06:02,790 --> 00:06:07,069
it'll just automatically retry for you

00:06:05,479 --> 00:06:09,979
and then there's also nice features with

00:06:07,069 --> 00:06:13,699
like batching where maybe you might want

00:06:09,979 --> 00:06:15,620
to run a group of workers and when all

00:06:13,699 --> 00:06:17,960
of those complete either successfully or

00:06:15,620 --> 00:06:21,349
with errors you can run some callback so

00:06:17,960 --> 00:06:24,259
there's a lot of great things about

00:06:21,349 --> 00:06:27,080
background workers and we make heavy use

00:06:24,259 --> 00:06:29,539
of it at digitalocean so this is what

00:06:27,080 --> 00:06:31,789
our sidekick dashboard actually looks

00:06:29,539 --> 00:06:34,879
like and you can see we have almost 6

00:06:31,789 --> 00:06:37,029
billion workers that we process and this

00:06:34,879 --> 00:06:40,219
kind of compasses maybe like a year of

00:06:37,029 --> 00:06:44,779
data and it's probably over that a bit

00:06:40,219 --> 00:06:46,400
at this point so we use it a lot and we

00:06:44,779 --> 00:06:51,770
kind of wanted to use it even more to

00:06:46,400 --> 00:06:53,240
scale up so so we use sidekick like I

00:06:51,770 --> 00:06:54,949
mentioned but there are other background

00:06:53,240 --> 00:06:57,830
workers out there delayed job which

00:06:54,949 --> 00:07:00,409
works pretty well with active record and

00:06:57,830 --> 00:07:01,729
uses sequel and rescue so if this is

00:07:00,409 --> 00:07:03,800
something that's interesting to you I

00:07:01,729 --> 00:07:07,009
suggest checking out one of these

00:07:03,800 --> 00:07:08,360
options there's a lot of great ones in

00:07:07,009 --> 00:07:11,569
the Ruby community and we're very lucky

00:07:08,360 --> 00:07:13,479
to have them so I kind of want to run

00:07:11,569 --> 00:07:15,860
through an example of what this actually

00:07:13,479 --> 00:07:17,389
looks like in practice to use a

00:07:15,860 --> 00:07:19,279
background worker if you're not familiar

00:07:17,389 --> 00:07:22,099
with it so on the Left we might have our

00:07:19,279 --> 00:07:24,499
expensive jobs that's kind of expensive

00:07:22,099 --> 00:07:26,060
to run and we normally we might

00:07:24,499 --> 00:07:29,419
initialize in and run this expensive

00:07:26,060 --> 00:07:31,129
method to kind of put into a background

00:07:29,419 --> 00:07:34,249
where girls you really need to do is add

00:07:31,129 --> 00:07:35,839
an another class and this is an example

00:07:34,249 --> 00:07:39,279
for sidekick but you kind of add this

00:07:35,839 --> 00:07:42,860
expensive job worker class and include

00:07:39,279 --> 00:07:44,330
the sidekick worker set some of the

00:07:42,860 --> 00:07:46,250
options here

00:07:44,330 --> 00:07:48,830
here we put it in a high priority queue

00:07:46,250 --> 00:07:50,210
and to find a perform method that does

00:07:48,830 --> 00:07:52,009
something and in this case we're just

00:07:50,210 --> 00:07:55,849
kind of passing through the arguments to

00:07:52,009 --> 00:07:58,219
our expensive job class so this lets us

00:07:55,849 --> 00:08:01,669
easily just now run an expensive job

00:07:58,219 --> 00:08:03,530
worker in the background like this you

00:08:01,669 --> 00:08:06,590
just kind of set it to run and it'll run

00:08:03,530 --> 00:08:10,580
whenever there's available ability in

00:08:06,590 --> 00:08:13,639
the queue this is an example doing it in

00:08:10,580 --> 00:08:15,800
ten minutes so just as easy to kind of

00:08:13,639 --> 00:08:18,889
do that and you can even do some more

00:08:15,800 --> 00:08:21,110
complicated things like run it in the

00:08:18,889 --> 00:08:24,110
background every day so there's this

00:08:21,110 --> 00:08:26,509
cool gem called the whenever gem which

00:08:24,110 --> 00:08:32,209
is really nice because you can kind of

00:08:26,509 --> 00:08:34,969
use this DSL that lets you define some

00:08:32,209 --> 00:08:36,860
kind of like cron job and you can run

00:08:34,969 --> 00:08:39,469
that every day or every hour or whatever

00:08:36,860 --> 00:08:43,099
it is and this is actually how our month

00:08:39,469 --> 00:08:47,060
clothes worker runs we have a cron

00:08:43,099 --> 00:08:48,829
defined that is set to run that month

00:08:47,060 --> 00:08:50,779
close worker every month for all the

00:08:48,829 --> 00:08:52,970
users and this is kind of nice because

00:08:50,779 --> 00:08:56,300
you keep all that logic in one place in

00:08:52,970 --> 00:08:59,209
your repo instead of having it maybe in

00:08:56,300 --> 00:09:01,690
defined in a cron file that's defined in

00:08:59,209 --> 00:09:03,649
like maybe a chef or a puppet

00:09:01,690 --> 00:09:08,209
repository so you keep all that logic

00:09:03,649 --> 00:09:10,070
together so let's just kind of apply

00:09:08,209 --> 00:09:12,589
that to our example so we can do better

00:09:10,070 --> 00:09:15,709
and take this and then transform it so

00:09:12,589 --> 00:09:18,560
on the left is what we kind of come up

00:09:15,709 --> 00:09:20,720
with now so when we generate our invoice

00:09:18,560 --> 00:09:23,269
for our user and we have an amount and

00:09:20,720 --> 00:09:25,160
we say this is the amount they owes we

00:09:23,269 --> 00:09:28,430
instead of running the payment and

00:09:25,160 --> 00:09:29,959
running the email workers in line right

00:09:28,430 --> 00:09:31,310
there we kind of run them in the

00:09:29,959 --> 00:09:33,740
background and we pass through that

00:09:31,310 --> 00:09:37,510
amount and on the right that's kind of

00:09:33,740 --> 00:09:40,880
what our workers look like we have the

00:09:37,510 --> 00:09:43,610
jobs running there and that and the good

00:09:40,880 --> 00:09:45,560
thing about this is that we kind of help

00:09:43,610 --> 00:09:48,820
solve our idempotency issue from before

00:09:45,560 --> 00:09:51,920
because now if our payment worker fails

00:09:48,820 --> 00:09:54,319
because our payment provider is down

00:09:51,920 --> 00:09:55,680
this was just automatically you tried we

00:09:54,319 --> 00:09:57,000
don't have to worry about it

00:09:55,680 --> 00:09:59,190
we trying other things that are

00:09:57,000 --> 00:10:02,160
unrelated to that failure so that's kind

00:09:59,190 --> 00:10:05,160
of a nice benefit of doing this the

00:10:02,160 --> 00:10:11,130
other benefit is that we can scale

00:10:05,160 --> 00:10:12,990
things up separately so are different

00:10:11,130 --> 00:10:14,850
third-party providers for example might

00:10:12,990 --> 00:10:17,700
have different throttling requirements

00:10:14,850 --> 00:10:19,860
different SLA is different things that

00:10:17,700 --> 00:10:21,570
we need to do so we can actually set

00:10:19,860 --> 00:10:23,970
throttling limits on all these different

00:10:21,570 --> 00:10:26,430
workers that are different and that's

00:10:23,970 --> 00:10:28,649
really nice because we can scale up as

00:10:26,430 --> 00:10:31,380
we need to for the specific parts of our

00:10:28,649 --> 00:10:34,050
system that are bottlenecks so this is

00:10:31,380 --> 00:10:36,750
awesome right and it and it turned out

00:10:34,050 --> 00:10:37,800
to be pretty good because before when we

00:10:36,750 --> 00:10:39,240
were running everything kind of in the

00:10:37,800 --> 00:10:42,060
synchronous class it took about 30

00:10:39,240 --> 00:10:43,800
minutes per user on average and it took

00:10:42,060 --> 00:10:45,690
us up to two days to finish our whole

00:10:43,800 --> 00:10:48,029
month closed process for all users so

00:10:45,690 --> 00:10:49,350
that's really not good if you're like

00:10:48,029 --> 00:10:52,110
the finance team and you have to wait

00:10:49,350 --> 00:10:54,080
two days from the first of the month to

00:10:52,110 --> 00:10:56,820
the end of the month to find out exactly

00:10:54,080 --> 00:10:58,950
what happened with all the money that

00:10:56,820 --> 00:11:01,080
you're looking to collect so after about

00:10:58,950 --> 00:11:02,430
the first day we'd get like somebody

00:11:01,080 --> 00:11:04,830
knocking on the door at the slack

00:11:02,430 --> 00:11:06,029
channel being like hey you know did we

00:11:04,830 --> 00:11:08,670
collect the money yet and we were like

00:11:06,029 --> 00:11:12,029
no not yet just give us a minute or a

00:11:08,670 --> 00:11:13,620
couple days so afterwards took less than

00:11:12,029 --> 00:11:16,560
10 minutes per user to finish on average

00:11:13,620 --> 00:11:18,690
because we could scale up a lot easily a

00:11:16,560 --> 00:11:22,970
lot easier horizontally instead of

00:11:18,690 --> 00:11:25,170
vertically and it actually ran overnight

00:11:22,970 --> 00:11:29,060
it took less than 8 hours for the whole

00:11:25,170 --> 00:11:31,670
month closed process to complete

00:11:29,060 --> 00:11:32,780
which was really nice because we just go

00:11:31,670 --> 00:11:36,640
to bed and wake up and everything was

00:11:32,780 --> 00:11:39,020
done so all's well that ends well but

00:11:36,640 --> 00:11:40,970
whoops this actually kind of introduced

00:11:39,020 --> 00:11:44,150
a lot of bugs in our system that we

00:11:40,970 --> 00:11:46,460
didn't anticipate and I will show you

00:11:44,150 --> 00:11:50,270
one of these bugs from our help desk

00:11:46,460 --> 00:11:52,040
right here so this user wrote in to us

00:11:50,270 --> 00:11:54,500
and says hey you know my account has two

00:11:52,040 --> 00:11:56,750
payments for this month can you check

00:11:54,500 --> 00:11:58,430
again and refund this because I came in

00:11:56,750 --> 00:12:01,310
and paid when I got a notification that

00:11:58,430 --> 00:12:03,470
I had an invoice and then later you kind

00:12:01,310 --> 00:12:06,620
of made a second payment on my account

00:12:03,470 --> 00:12:08,150
like that like why did this happen so

00:12:06,620 --> 00:12:09,290
that's what we asked ourselves like why

00:12:08,150 --> 00:12:13,940
did this happen

00:12:09,290 --> 00:12:15,650
and the answer is kind of obvious once

00:12:13,940 --> 00:12:17,120
you kind of think about it but the

00:12:15,650 --> 00:12:19,700
average time between the steps changed

00:12:17,120 --> 00:12:23,900
so previously once a payment was made

00:12:19,700 --> 00:12:25,520
then we'd send the email or and handle

00:12:23,900 --> 00:12:29,870
the failed charge as appropriately and

00:12:25,520 --> 00:12:31,310
we had a guarantee between each step how

00:12:29,870 --> 00:12:33,020
long it would take it would just take as

00:12:31,310 --> 00:12:35,810
long as it took for the instruction to

00:12:33,020 --> 00:12:37,610
move to the next method afterwards we

00:12:35,810 --> 00:12:41,390
have no guarantee whatsoever because

00:12:37,610 --> 00:12:42,800
it's in this long queue that may be

00:12:41,390 --> 00:12:45,220
affected by other things you might have

00:12:42,800 --> 00:12:47,450
other jobs in the queue you might have

00:12:45,220 --> 00:12:49,940
really you might have that throttling

00:12:47,450 --> 00:12:51,830
going on so you can't guarantee when

00:12:49,940 --> 00:12:54,650
something will happen so now you have

00:12:51,830 --> 00:12:58,550
this big delay that you didn't account

00:12:54,650 --> 00:13:02,210
for before and that's kind of introduced

00:12:58,550 --> 00:13:04,910
some issues here so this kind of brings

00:13:02,210 --> 00:13:07,550
up an important point in that the our

00:13:04,910 --> 00:13:11,120
mental model of what our classes are

00:13:07,550 --> 00:13:13,970
doing that's an ideal world it kind of

00:13:11,120 --> 00:13:17,270
we maybe wrote some nice little stories

00:13:13,970 --> 00:13:19,350
from a from a

00:13:17,270 --> 00:13:21,959
flowchart or something that had like

00:13:19,350 --> 00:13:23,730
really nice branching trees and it said

00:13:21,959 --> 00:13:25,800
like if this happens then this will

00:13:23,730 --> 00:13:27,390
happen and if this happens and something

00:13:25,800 --> 00:13:30,000
else will happen and looked all tidy and

00:13:27,390 --> 00:13:32,700
we wrote the stories but it doesn't

00:13:30,000 --> 00:13:35,820
actually represent how reality works how

00:13:32,700 --> 00:13:37,890
our actual workflows work so like our

00:13:35,820 --> 00:13:39,450
deal workflows kind of looked like hey

00:13:37,890 --> 00:13:42,000
the invoice is generated and then we

00:13:39,450 --> 00:13:45,649
make a payment attempt or the payment

00:13:42,000 --> 00:13:48,390
fails and then the user is suspended or

00:13:45,649 --> 00:13:49,980
the payment succeeds and then the user

00:13:48,390 --> 00:13:52,620
either emails the receipt so there's

00:13:49,980 --> 00:13:54,660
like these and Den's that come between

00:13:52,620 --> 00:13:56,750
each step and nothing else kind of

00:13:54,660 --> 00:14:00,660
intrudes upon that that's just

00:13:56,750 --> 00:14:02,910
everything in our ideal world but

00:14:00,660 --> 00:14:07,140
reality actually likes butts and I'll

00:14:02,910 --> 00:14:10,470
pause for your laughter here things

00:14:07,140 --> 00:14:13,020
happen in between each step here that we

00:14:10,470 --> 00:14:16,200
can't necessarily anticipate so we might

00:14:13,020 --> 00:14:18,360
generate the invoice but somebody on our

00:14:16,200 --> 00:14:21,180
support team applies a credit before the

00:14:18,360 --> 00:14:23,279
payment can be made or the payment is

00:14:21,180 --> 00:14:25,380
attempted but the user goes in and

00:14:23,279 --> 00:14:27,870
removes their credit card before we

00:14:25,380 --> 00:14:29,279
realize we can't charge them or the

00:14:27,870 --> 00:14:31,350
payment is attempted but the user be

00:14:29,279 --> 00:14:32,910
paid manually and this is what happened

00:14:31,350 --> 00:14:36,870
here the user came in and paid mainly

00:14:32,910 --> 00:14:39,930
before our payment worker could run so

00:14:36,870 --> 00:14:41,760
this brings us to our first learning

00:14:39,930 --> 00:14:44,490
here which is when you kind of pass

00:14:41,760 --> 00:14:46,649
information you're working under an

00:14:44,490 --> 00:14:49,610
assumption that represents the state of

00:14:46,649 --> 00:14:51,720
the world at that time so when we

00:14:49,610 --> 00:14:54,000
generated the invoice and we said this

00:14:51,720 --> 00:14:56,190
is the amount that you owe us and sent

00:14:54,000 --> 00:14:59,579
that to the payment worker that amount

00:14:56,190 --> 00:15:02,120
was an amount that represented the state

00:14:59,579 --> 00:15:05,190
of the world at the time that that

00:15:02,120 --> 00:15:06,630
worker was in queued it didn't

00:15:05,190 --> 00:15:11,370
necessarily represent the state of the

00:15:06,630 --> 00:15:13,710
world of when the payment worker ran so

00:15:11,370 --> 00:15:17,650
that was a completely different

00:15:13,710 --> 00:15:19,420
representation so this also brings us to

00:15:17,650 --> 00:15:21,220
the second learning which is changing

00:15:19,420 --> 00:15:23,920
methods from synchronous asynchronous is

00:15:21,220 --> 00:15:25,300
an implicit change in behavior even

00:15:23,920 --> 00:15:29,290
though we didn't really change anything

00:15:25,300 --> 00:15:31,210
about the processing of the order of our

00:15:29,290 --> 00:15:33,250
processing or what it was doing like

00:15:31,210 --> 00:15:35,530
everything still ran in the same order

00:15:33,250 --> 00:15:38,020
as it did before we did the same exact

00:15:35,530 --> 00:15:40,270
steps as we did before but because the

00:15:38,020 --> 00:15:42,670
timing was different and because we lost

00:15:40,270 --> 00:15:43,900
some of those guarantees about what the

00:15:42,670 --> 00:15:47,200
state of the world looked like there was

00:15:43,900 --> 00:15:49,150
a change in behavior so that's kind of

00:15:47,200 --> 00:15:51,400
really important to address so what can

00:15:49,150 --> 00:15:54,850
we do we want to do something to fix

00:15:51,400 --> 00:15:57,940
that so one of the first things that we

00:15:54,850 --> 00:15:59,200
thought about was well in this case we

00:15:57,940 --> 00:16:02,500
need our payments to run immediately

00:15:59,200 --> 00:16:04,570
after the invoice is generated so we'll

00:16:02,500 --> 00:16:07,180
use that queueing priority queue feature

00:16:04,570 --> 00:16:10,210
in sidekick and set it as the highest

00:16:07,180 --> 00:16:12,280
priority so as soon as the invoice is

00:16:10,210 --> 00:16:14,290
generated we enqueue our payment worker

00:16:12,280 --> 00:16:17,140
it'll run really quickly in that well

00:16:14,290 --> 00:16:21,010
shorten that time from 5 or 10 minutes

00:16:17,140 --> 00:16:22,930
to something really small and this turns

00:16:21,010 --> 00:16:25,120
out to be a bad idea because this is not

00:16:22,930 --> 00:16:27,820
what you want if you do this you're kind

00:16:25,120 --> 00:16:29,530
of engaging in this priority arms race

00:16:27,820 --> 00:16:33,370
and you end up with a like a queue

00:16:29,530 --> 00:16:36,240
priority that looks like this and this

00:16:33,370 --> 00:16:38,890
not something that you want to be doing

00:16:36,240 --> 00:16:40,390
because you'll never really ever solve

00:16:38,890 --> 00:16:41,950
the issue like you're just kind of

00:16:40,390 --> 00:16:43,270
kicking the can down the road and

00:16:41,950 --> 00:16:48,310
there's always gonna be something that's

00:16:43,270 --> 00:16:51,490
more important what you want to actually

00:16:48,310 --> 00:16:54,640
do is assume that the world changes like

00:16:51,490 --> 00:16:57,160
that's an okay assumption to make the

00:16:54,640 --> 00:17:01,480
world will change that is reality so we

00:16:57,160 --> 00:17:04,959
want to account for that so this is kind

00:17:01,480 --> 00:17:08,800
of how we wanna maybe handle this

00:17:04,959 --> 00:17:10,660
payment worker is when we run it we say

00:17:08,800 --> 00:17:12,880
what is this users current balance and

00:17:10,660 --> 00:17:14,980
if the current balance doesn't match the

00:17:12,880 --> 00:17:16,510
amount we were told to charge we need to

00:17:14,980 --> 00:17:18,970
perform some action

00:17:16,510 --> 00:17:21,100
maybe we still charge the user maybe we

00:17:18,970 --> 00:17:23,530
throw an error maybe we do nothing but

00:17:21,100 --> 00:17:25,660
this is this is a condition we need to

00:17:23,530 --> 00:17:28,419
start accepting as something that's a

00:17:25,660 --> 00:17:31,120
valid case and you might look at this

00:17:28,419 --> 00:17:32,770
and think it's kind of dirty because

00:17:31,120 --> 00:17:34,210
that's what I thought too like I was

00:17:32,770 --> 00:17:36,730
like wow why should we have to do this

00:17:34,210 --> 00:17:38,799
it's like impure like this should just

00:17:36,730 --> 00:17:40,809
charge the user the amount that we said

00:17:38,799 --> 00:17:42,730
and if for if we can't do that then

00:17:40,809 --> 00:17:45,780
there's some maybe something wrong with

00:17:42,730 --> 00:17:52,090
our with our program or a program design

00:17:45,780 --> 00:17:53,830
but I kind of want you to start to think

00:17:52,090 --> 00:17:57,580
that maybe this isn't such a bad thing

00:17:53,830 --> 00:17:59,590
to do because the reality of the world

00:17:57,580 --> 00:18:00,970
does change and that is something that

00:17:59,590 --> 00:18:04,780
we need to consider so it's not

00:18:00,970 --> 00:18:07,870
inherently a bad thing to to kind of

00:18:04,780 --> 00:18:11,380
take make these checks and try to see

00:18:07,870 --> 00:18:13,090
how your how your program can account

00:18:11,380 --> 00:18:16,480
for that how you're like services can

00:18:13,090 --> 00:18:18,070
account for that so if you do this you

00:18:16,480 --> 00:18:21,190
actually there's actually like a nice

00:18:18,070 --> 00:18:24,130
little bonus I think this speaks for

00:18:21,190 --> 00:18:27,370
itself I see some confused faces in the

00:18:24,130 --> 00:18:30,100
audience so I will explain but if you've

00:18:27,370 --> 00:18:32,799
ever seen Terminator 2 this is the t1000

00:18:30,100 --> 00:18:35,020
robot and he had a really cool feature

00:18:32,799 --> 00:18:37,890
even though he was the bad guy and that

00:18:35,020 --> 00:18:39,820
when he was shot or some kind of

00:18:37,890 --> 00:18:44,679
encountered some kind of physical damage

00:18:39,820 --> 00:18:48,910
he would heal himself and that's kind of

00:18:44,679 --> 00:18:51,700
what our program our program will do if

00:18:48,910 --> 00:18:54,309
we start to design it taking into

00:18:51,700 --> 00:18:56,260
account these changes we'll end up

00:18:54,309 --> 00:18:57,970
building a self-healing system that's

00:18:56,260 --> 00:19:00,190
resilient to changes in the environment

00:18:57,970 --> 00:19:02,490
because we're assuming the environment

00:19:00,190 --> 00:19:06,220
changes and this is kind of really nice

00:19:02,490 --> 00:19:07,690
behavior to have in your prope in your

00:19:06,220 --> 00:19:09,429
architecture because then you don't have

00:19:07,690 --> 00:19:12,760
those alerts coming in you don't have

00:19:09,429 --> 00:19:14,570
all these errors being thrown because

00:19:12,760 --> 00:19:18,719
your

00:19:14,570 --> 00:19:23,789
your surfaces are prone or are resilient

00:19:18,719 --> 00:19:26,070
to failure so another thing you can do

00:19:23,789 --> 00:19:27,539
is freeze your world in time so we were

00:19:26,070 --> 00:19:33,599
talking about how the state of the world

00:19:27,539 --> 00:19:35,429
changes and it previously we had a the

00:19:33,599 --> 00:19:37,529
world looking a certain way at one time

00:19:35,429 --> 00:19:38,749
and then later it didn't look like that

00:19:37,529 --> 00:19:41,580
anymore

00:19:38,749 --> 00:19:43,200
so one way you can account for this is

00:19:41,580 --> 00:19:45,809
doing something like this so this is

00:19:43,200 --> 00:19:47,759
kind of what our emails started to look

00:19:45,809 --> 00:19:53,549
like not not quite so ugly but this is

00:19:47,759 --> 00:19:55,589
the plain text example but when we send

00:19:53,549 --> 00:19:58,109
an email to the user we kind of we can

00:19:55,589 --> 00:20:01,279
kind of say hey this is your invoice and

00:19:58,109 --> 00:20:04,169
your balance is $10.00 as of this time

00:20:01,279 --> 00:20:07,139
so we kind of froze the world in time

00:20:04,169 --> 00:20:09,629
for the user by letting them know that

00:20:07,139 --> 00:20:12,029
their balance was this amount at this

00:20:09,629 --> 00:20:13,950
time so maybe they won't get an email

00:20:12,029 --> 00:20:17,549
and be confused like hey you know I went

00:20:13,950 --> 00:20:21,089
paid off my balance but then I got an

00:20:17,549 --> 00:20:23,639
email that said my balance is $10.00 so

00:20:21,089 --> 00:20:27,119
yeah I mean this can apply in many other

00:20:23,639 --> 00:20:30,869
ways where you maybe you do some caching

00:20:27,119 --> 00:20:33,059
or maybe you display on your website

00:20:30,869 --> 00:20:35,789
like a kind of a last updated counter or

00:20:33,059 --> 00:20:38,219
something like that base you're freezing

00:20:35,789 --> 00:20:40,019
the world in time for the user and kind

00:20:38,219 --> 00:20:41,279
of letting letting the world know you're

00:20:40,019 --> 00:20:43,469
making you're working under an

00:20:41,279 --> 00:20:46,289
assumption of what things look like at a

00:20:43,469 --> 00:20:48,570
certain time and this kind of reduces

00:20:46,289 --> 00:20:50,700
confusion and kind of lets you embrace

00:20:48,570 --> 00:20:54,749
this this idea that the world changes

00:20:50,700 --> 00:20:56,549
and of course be a good citizen so we're

00:20:54,749 --> 00:21:00,269
in Budapest so you want to localize all

00:20:56,549 --> 00:21:04,950
your oil your all your text so we

00:21:00,269 --> 00:21:07,950
account for that here too so I mean the

00:21:04,950 --> 00:21:10,589
just the gist of all this is a you want

00:21:07,950 --> 00:21:12,330
to embrace the inconsistency of your

00:21:10,589 --> 00:21:16,919
workers don't

00:21:12,330 --> 00:21:19,169
try to fight the the the this move from

00:21:16,919 --> 00:21:20,940
a synchronous process to an asynchronous

00:21:19,169 --> 00:21:23,339
process cuz you're you're never gonna

00:21:20,940 --> 00:21:25,889
win if you find yourself kind of doing

00:21:23,339 --> 00:21:28,440
things to pull you back to something

00:21:25,889 --> 00:21:30,779
that's a more synchronous dependable

00:21:28,440 --> 00:21:34,349
guarantee take a step back and think of

00:21:30,779 --> 00:21:35,909
whether you actually need that if it's

00:21:34,349 --> 00:21:37,679
something that you need then you

00:21:35,909 --> 00:21:39,989
probably need to move back to something

00:21:37,679 --> 00:21:42,599
that gives you those guarantees but I

00:21:39,989 --> 00:21:44,339
think more often than not you'll find

00:21:42,599 --> 00:21:46,679
it's probably not something that you

00:21:44,339 --> 00:21:49,320
actually really need and that you're

00:21:46,679 --> 00:21:50,759
just not embracing the inconsistencies

00:21:49,320 --> 00:21:55,259
that come with like moving to this

00:21:50,759 --> 00:21:57,179
distributed system and by doing that you

00:21:55,259 --> 00:21:59,309
get a lot of benefits out of it your

00:21:57,179 --> 00:22:01,639
your services will be like much more

00:21:59,309 --> 00:22:05,609
resilient to failure you're kind of

00:22:01,639 --> 00:22:10,259
building it this this architecture

00:22:05,609 --> 00:22:12,200
that's more able to withstand the

00:22:10,259 --> 00:22:16,229
changes in any environment that it's in

00:22:12,200 --> 00:22:18,829
so just remember to embrace the

00:22:16,229 --> 00:22:22,049
inconsistency because that's kind of the

00:22:18,829 --> 00:22:26,089
driving force behind a distributed

00:22:22,049 --> 00:22:26,089
system Thanks

00:22:38,300 --> 00:22:40,360

YouTube URL: https://www.youtube.com/watch?v=JvBq27cbv_0


