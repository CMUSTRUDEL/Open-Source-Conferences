Title: Lightning Talks Day2 @ EuRuKo2017
Publication date: 2017-12-21
Playlist: EuRuKo 2017
Description: 
	
Captions: 
	00:00:09,600 --> 00:00:14,469
hi everyone so I'm gonna tell you

00:00:12,190 --> 00:00:16,059
something I'm gonna talk about something

00:00:14,469 --> 00:00:18,700
that I'm personally very passionate

00:00:16,059 --> 00:00:20,650
about and that's doing OCR and computer

00:00:18,700 --> 00:00:23,170
vision with Ruby

00:00:20,650 --> 00:00:26,340
so last time you saw me on stage I guess

00:00:23,170 --> 00:00:29,380
you might have inferred that this is me

00:00:26,340 --> 00:00:32,110
and I'm telling you this because my talk

00:00:29,380 --> 00:00:34,300
you'll you'll understand in a couple of

00:00:32,110 --> 00:00:36,100
seconds but just because I didn't get to

00:00:34,300 --> 00:00:43,059
introduce myself earlier my name is

00:00:36,100 --> 00:00:45,190
Vinod so yeah so it begins

00:00:43,059 --> 00:00:48,629
for the sake of the to make the talk a

00:00:45,190 --> 00:00:52,690
little simpler I'm going to kind of be

00:00:48,629 --> 00:00:55,239
talking as Fiona my dog and for the sake

00:00:52,690 --> 00:00:59,949
of the talk her favorite toy moppy is

00:00:55,239 --> 00:01:02,559
Ruby so who of you is familiar with OCR

00:00:59,949 --> 00:01:05,199
you know are you very good at it or kind

00:01:02,559 --> 00:01:08,860
of weird about it okay

00:01:05,199 --> 00:01:10,420
good to see so just to make it a little

00:01:08,860 --> 00:01:11,170
clearer for those of you who aren't so

00:01:10,420 --> 00:01:14,460
familiar with it

00:01:11,170 --> 00:01:15,810
OCR is optical character recognition and

00:01:14,460 --> 00:01:19,350
[Music]

00:01:15,810 --> 00:01:22,240
computer vision is giving the Machine

00:01:19,350 --> 00:01:25,090
understanding of what you've picked up

00:01:22,240 --> 00:01:27,729
with OCR or of the analog world so

00:01:25,090 --> 00:01:30,159
computer vision is not OCR but OCR can

00:01:27,729 --> 00:01:33,100
be used for computer vision so why would

00:01:30,159 --> 00:01:35,500
we do this because digital is nice we

00:01:33,100 --> 00:01:37,750
like digital it's eco friendly and it's

00:01:35,500 --> 00:01:40,299
actually immensely accessible so for

00:01:37,750 --> 00:01:42,610
example you could scan a music sheet and

00:01:40,299 --> 00:01:46,180
have sonic play it out or something like

00:01:42,610 --> 00:01:51,180
this so fun and cool so OCR with Ruby

00:01:46,180 --> 00:01:51,180
now before you give me that look

00:01:51,380 --> 00:01:56,100
ruby is nice and we all like ruby that's

00:01:53,820 --> 00:01:59,009
why we're here right and if you remember

00:01:56,100 --> 00:02:01,079
from the first day you know just just

00:01:59,009 --> 00:02:02,820
gonna put that there big there is there

00:02:01,079 --> 00:02:07,830
was a very important guy saying that

00:02:02,820 --> 00:02:11,700
earlier so to get started with OCR you

00:02:07,830 --> 00:02:13,800
need an OCR engine or a program and like

00:02:11,700 --> 00:02:16,170
the one I use is tesseract which is an

00:02:13,800 --> 00:02:20,090
open source one and you would run

00:02:16,170 --> 00:02:24,000
something like this on the shell you

00:02:20,090 --> 00:02:26,760
call tesseract give it the file path put

00:02:24,000 --> 00:02:28,739
in the languages what what output you

00:02:26,760 --> 00:02:31,470
want and you give it the configuration

00:02:28,739 --> 00:02:36,870
so tesseract would pick up something

00:02:31,470 --> 00:02:38,880
like this and that doesn't look

00:02:36,870 --> 00:02:42,299
impressive but it would give you just a

00:02:38,880 --> 00:02:45,480
bunch of data and what you can do is use

00:02:42,299 --> 00:02:48,209
this in your Ruby code base save it to a

00:02:45,480 --> 00:02:51,150
variable translate it into HTML and then

00:02:48,209 --> 00:02:54,930
you can parse it and make it know

00:02:51,150 --> 00:02:57,690
something like this it's a date now I

00:02:54,930 --> 00:03:02,250
know you're already wondering okay but

00:02:57,690 --> 00:03:06,299
why again we come back to computer

00:03:02,250 --> 00:03:09,090
vision so with OCR we can pick up all of

00:03:06,299 --> 00:03:11,430
the world or understand what an images

00:03:09,090 --> 00:03:14,459
in the analog world and then we can

00:03:11,430 --> 00:03:16,650
actually parse it and give it meaning so

00:03:14,459 --> 00:03:17,000
I know you were thinking like why would

00:03:16,650 --> 00:03:19,290
I do

00:03:17,000 --> 00:03:23,609
OCR with Ruby I get asked this question

00:03:19,290 --> 00:03:25,410
all the time why Ruby isn't Ruby Snow I

00:03:23,609 --> 00:03:28,100
could have a picture of that other talk

00:03:25,410 --> 00:03:30,900
that had you know matt said ruby is slow

00:03:28,100 --> 00:03:32,850
but the point is we get to use a tool

00:03:30,900 --> 00:03:35,700
that we really love for the logic

00:03:32,850 --> 00:03:38,850
actually Ruby isn't doing I'm gonna skip

00:03:35,700 --> 00:03:40,889
a couple slides ahead it's not Ruby

00:03:38,850 --> 00:03:43,530
right it's actually the OCR engine

00:03:40,889 --> 00:03:46,739
picking everything up but we give the

00:03:43,530 --> 00:03:49,620
world meaning with Ruby so you can still

00:03:46,739 --> 00:03:53,160
work with the tools that you love Ruby

00:03:49,620 --> 00:03:55,170
and do something you know that sounds

00:03:53,160 --> 00:03:57,900
very complicated and is really hard like

00:03:55,170 --> 00:04:00,060
Ruby so what you would do you run the

00:03:57,900 --> 00:04:01,920
OCR engine you pick up all those words

00:04:00,060 --> 00:04:03,629
and then you give them meaning with Ruby

00:04:01,920 --> 00:04:06,180
I can't stop saying that because it's

00:04:03,629 --> 00:04:08,670
just logic you just tell it you know

00:04:06,180 --> 00:04:10,980
there's a word that's at the top of the

00:04:08,670 --> 00:04:13,019
page it's two numbers another two

00:04:10,980 --> 00:04:15,930
numbers and then four numbers it's

00:04:13,019 --> 00:04:19,229
probably a date your digitalizing the

00:04:15,930 --> 00:04:23,250
world so I hope that I've managed to

00:04:19,229 --> 00:04:26,580
inspire some of you excite you and leave

00:04:23,250 --> 00:04:31,169
you only slightly skeptical about doing

00:04:26,580 --> 00:04:32,700
OCR with Ruby thank you so much to all

00:04:31,169 --> 00:04:35,099
of you for being here I'd wanted to just

00:04:32,700 --> 00:04:36,750
say that because it's really awesome to

00:04:35,099 --> 00:04:38,880
be with a community I get so many

00:04:36,750 --> 00:04:40,740
skeptical looks for doing OCR with Ruby

00:04:38,880 --> 00:04:43,140
you cannot imagine everyone's just like

00:04:40,740 --> 00:04:44,789
why Ruby it's so great to be in this

00:04:43,140 --> 00:04:48,630
room full of people who can probably

00:04:44,789 --> 00:04:51,240
understand why Ruby and in case you were

00:04:48,630 --> 00:04:53,560
wondering this is the dog from the

00:04:51,240 --> 00:04:55,039
Vienna pitch so if you haven't voted

00:04:53,560 --> 00:04:58,890
[Music]

00:04:55,039 --> 00:05:00,450
just on stage thank you so much

00:04:58,890 --> 00:05:03,479
my name is Peter with over now if you're

00:05:00,450 --> 00:05:05,039
interested in OCR or you know doing this

00:05:03,479 --> 00:05:09,680
kind of stuff with Ruby come talk to me

00:05:05,039 --> 00:05:09,680
that's my Twitter right there thank you

00:05:10,250 --> 00:05:15,030
all right hi guys I'm Jake I work with

00:05:13,530 --> 00:05:16,919
chalk my goal for about the past year

00:05:15,030 --> 00:05:19,349
I've been working pretty heavily on

00:05:16,919 --> 00:05:20,960
performance at chart ruggle and part of

00:05:19,349 --> 00:05:23,460
it has been reducing memory usage and

00:05:20,960 --> 00:05:25,710
I've gone pretty much all the way from

00:05:23,460 --> 00:05:27,780
starting to now patching Ruby scale

00:05:25,710 --> 00:05:29,490
which collector I don't really have time

00:05:27,780 --> 00:05:30,990
to talk too much about that today but

00:05:29,490 --> 00:05:32,700
I'm gonna run through some stuff that's

00:05:30,990 --> 00:05:33,930
pretty easy and will help really see

00:05:32,700 --> 00:05:36,449
memory usage

00:05:33,930 --> 00:05:38,669
so first one is to upgrade to Ruby 2.4

00:05:36,449 --> 00:05:41,340
pretty much just uses 10% less memory

00:05:38,669 --> 00:05:44,160
and a big part of it as releasing the

00:05:41,340 --> 00:05:45,509
heat growth factor which is how fast

00:05:44,160 --> 00:05:48,960
Ruby increases the amount of memory

00:05:45,509 --> 00:05:50,130
users when it runs out of memory you can

00:05:48,960 --> 00:05:53,370
either set that as an environment

00:05:50,130 --> 00:05:56,039
variable I just upgrade to 2.4 next

00:05:53,370 --> 00:05:59,720
quick fix STS J malloc which is an

00:05:56,039 --> 00:06:02,789
alternative implementation of malloc

00:05:59,720 --> 00:06:05,130
it's by Jeremy Evans from Facebook yeah

00:06:02,789 --> 00:06:06,630
you can either use LD preload to load it

00:06:05,130 --> 00:06:09,330
or you can actually use it as a compile

00:06:06,630 --> 00:06:11,760
option since Ruby 2 point 2 there's

00:06:09,330 --> 00:06:14,070
pretty much no downside to this it's

00:06:11,760 --> 00:06:15,660
just faster and uses less memory if

00:06:14,070 --> 00:06:18,570
you're using sidekick it's like

00:06:15,660 --> 00:06:20,550
massively faster and sorry uses

00:06:18,570 --> 00:06:21,810
massively less memory because it's

00:06:20,550 --> 00:06:25,320
thread base but it's not that much

00:06:21,810 --> 00:06:27,449
faster maybe 10 percent right so if

00:06:25,320 --> 00:06:28,770
you're using a forking web server Ruby

00:06:27,449 --> 00:06:31,590
is not actually copyright for

00:06:28,770 --> 00:06:34,199
copy-on-write friendly at all the ruby

00:06:31,590 --> 00:06:37,020
2.0 bitmap garbage collector is a little

00:06:34,199 --> 00:06:39,720
bit friendlier it's not horrific but

00:06:37,020 --> 00:06:40,770
ruby is still pretty terrible so one of

00:06:39,720 --> 00:06:42,960
the first things that you should do is

00:06:40,770 --> 00:06:45,060
to say both transparent huge pages this

00:06:42,960 --> 00:06:47,370
is a linux kernel optimization that is

00:06:45,060 --> 00:06:49,889
better for basically everything apart

00:06:47,370 --> 00:06:52,860
from Ruby for really it's an absolute

00:06:49,889 --> 00:06:54,210
disaster if you disable it if you don't

00:06:52,860 --> 00:06:57,210
disable it you basically won't get any

00:06:54,210 --> 00:07:02,190
copyright sharing at all the other thing

00:06:57,210 --> 00:07:05,990
to do is to either use as Cochise

00:07:02,190 --> 00:07:09,240
Asada's Nakayoshi fork gem or to

00:07:05,990 --> 00:07:14,880
literally just per GC start in your

00:07:09,240 --> 00:07:16,949
annual before for cook basically - ruby

00:07:14,880 --> 00:07:20,639
2.0 is bitmap garbage collector remove

00:07:16,949 --> 00:07:22,889
the GC bit from the object itself before

00:07:20,639 --> 00:07:25,139
that running garbage collection cause

00:07:22,889 --> 00:07:26,699
the right to every object in a Ruby heap

00:07:25,139 --> 00:07:28,020
and that destroyed forking if you're

00:07:26,699 --> 00:07:29,570
using unicorn or something it just

00:07:28,020 --> 00:07:33,870
absolutely destroys to copy and write

00:07:29,570 --> 00:07:35,070
efficiency so Ruby 2.1 added a bit back

00:07:33,870 --> 00:07:37,050
on

00:07:35,070 --> 00:07:38,760
and if you have new objects before you

00:07:37,050 --> 00:07:40,680
fork as soon as the first garbage

00:07:38,760 --> 00:07:42,270
collection runs after you fork every one

00:07:40,680 --> 00:07:45,230
of those objects will now count towards

00:07:42,270 --> 00:07:48,330
all of your child processes memory usage

00:07:45,230 --> 00:07:50,190
okay um what about the future can we

00:07:48,330 --> 00:07:52,580
make things better and actually there's

00:07:50,190 --> 00:07:55,890
some pretty low hanging fruit in Ruby

00:07:52,580 --> 00:07:58,140
tenderlove Aaron Patterson I've been

00:07:55,890 --> 00:07:59,700
talking to him about this have to admit

00:07:58,140 --> 00:08:03,240
when he first wanted to talk to me about

00:07:59,700 --> 00:08:04,410
it I had a bit of a fanboy moment but

00:08:03,240 --> 00:08:06,360
yeah he's working on a compacting

00:08:04,410 --> 00:08:08,190
garbage collection which will actually

00:08:06,360 --> 00:08:09,840
squish objects back together and remove

00:08:08,190 --> 00:08:12,210
all the free space between them

00:08:09,840 --> 00:08:14,730
I've lighting me a Makarov MGI T will

00:08:12,210 --> 00:08:16,170
remove unnecessary allocations so it

00:08:14,730 --> 00:08:19,470
will just have less garbage to collect

00:08:16,170 --> 00:08:21,990
and finally I watched Hiroshi shibata's

00:08:19,470 --> 00:08:24,960
talk on starting developing Ruby itself

00:08:21,990 --> 00:08:26,400
last year at Euro 2016 in Sofia it was

00:08:24,960 --> 00:08:28,050
fantastic

00:08:26,400 --> 00:08:29,580
I've no started working on patching the

00:08:28,050 --> 00:08:32,880
garbage collection to use multiple heaps

00:08:29,580 --> 00:08:36,090
like Erlang users for beam and that will

00:08:32,880 --> 00:08:39,120
become more important as Ruby gets

00:08:36,090 --> 00:08:40,860
guilds in Ruby 3 and we have actual like

00:08:39,120 --> 00:08:42,000
concurrent operations and the garbage

00:08:40,860 --> 00:08:44,760
collection will be under much more

00:08:42,000 --> 00:08:46,890
pressure again so sorry that was way too

00:08:44,760 --> 00:08:49,770
much to fit into five minutes I'm at

00:08:46,890 --> 00:08:52,770
about four minutes now thank you very

00:08:49,770 --> 00:08:54,150
much for listening hopefully you guys

00:08:52,770 --> 00:08:55,740
got some useful information there's

00:08:54,150 --> 00:09:00,140
nothing in here that you can't google go

00:08:55,740 --> 00:09:00,140
forth learn it it's pretty interesting

00:09:02,780 --> 00:09:09,230
okay

00:09:04,880 --> 00:09:12,910
so I'm content about going to talk about

00:09:09,230 --> 00:09:16,130
the right SAP and a ruby up to 20 dates

00:09:12,910 --> 00:09:20,089
so just a small introduction about

00:09:16,130 --> 00:09:22,190
European rail so 15 years ago about the

00:09:20,089 --> 00:09:23,690
situation was like that you have one

00:09:22,190 --> 00:09:25,730
country one carrier

00:09:23,690 --> 00:09:28,610
so for example I send stuff in France

00:09:25,730 --> 00:09:32,180
and the Dutchman Germany trying to meet

00:09:28,610 --> 00:09:36,079
in Italy you had basically few yielded

00:09:32,180 --> 00:09:39,050
fares so you had a full price and some

00:09:36,079 --> 00:09:41,990
constrained concession fares on top of

00:09:39,050 --> 00:09:44,240
that and the cross-border ticketing was

00:09:41,990 --> 00:09:48,139
a bit shitty basically you had access

00:09:44,240 --> 00:09:51,649
only to the full fare and the fat father

00:09:48,139 --> 00:09:54,949
you go from your own country became more

00:09:51,649 --> 00:09:59,050
and more complex and that was the

00:09:54,949 --> 00:10:02,240
situation and now you have more

00:09:59,050 --> 00:10:04,370
competitors in a single country for

00:10:02,240 --> 00:10:06,589
example in Italy you have ETA dough and

00:10:04,370 --> 00:10:09,350
train italia which are competitors and

00:10:06,589 --> 00:10:10,850
don't talk to each other so if you want

00:10:09,350 --> 00:10:13,819
a little etiquette you gotta have to go

00:10:10,850 --> 00:10:15,290
through the for their own web website

00:10:13,819 --> 00:10:17,240
and if you want to have a traitor

00:10:15,290 --> 00:10:20,870
etiquette you have to go to a train to

00:10:17,240 --> 00:10:22,850
the ticket and you can't exchange or do

00:10:20,870 --> 00:10:25,310
anything at train telesales moves if you

00:10:22,850 --> 00:10:28,639
have an etiquette you have more yield it

00:10:25,310 --> 00:10:31,699
fares and cross-border ticketing is even

00:10:28,639 --> 00:10:34,610
worse so operators don't have an

00:10:31,699 --> 00:10:38,329
incentive to publish their yield it

00:10:34,610 --> 00:10:40,370
fares for the other para ters and they

00:10:38,329 --> 00:10:42,880
have even fewer incentives who for cares

00:10:40,370 --> 00:10:45,949
to improve the situation just because

00:10:42,880 --> 00:10:50,480
they prefer to sell their own trains

00:10:45,949 --> 00:10:54,560
than the competitors want so here comes

00:10:50,480 --> 00:10:57,500
train line so basically there is simple

00:10:54,560 --> 00:11:00,500
pitches rail tickets made easy so we

00:10:57,500 --> 00:11:02,509
serve more than 20 countries we have 17

00:11:00,500 --> 00:11:05,930
rate vendors in production that means we

00:11:02,509 --> 00:11:07,610
have access to their own fare service we

00:11:05,930 --> 00:11:10,939
have offices in London and it brought

00:11:07,610 --> 00:11:13,670
passenger more than 150 developers we

00:11:10,939 --> 00:11:17,180
are about 5 million pound

00:11:13,670 --> 00:11:19,639
daily turnover and we are ruby shop in

00:11:17,180 --> 00:11:22,610
Paris and c-sharp shop in London and

00:11:19,639 --> 00:11:23,750
we're hiring both in person London so

00:11:22,610 --> 00:11:26,540
apply if you want

00:11:23,750 --> 00:11:30,980
so the Ruby architecture we serve

00:11:26,540 --> 00:11:33,740
basically the mainland Europe trains so

00:11:30,980 --> 00:11:34,579
we have a basic architecture with

00:11:33,740 --> 00:11:39,230
front-ends

00:11:34,579 --> 00:11:42,350
who talked to a rails app through a REST

00:11:39,230 --> 00:11:45,319
API which itself that delegates all

00:11:42,350 --> 00:11:48,079
right ticketing and rail operations to a

00:11:45,319 --> 00:11:51,980
rate integrator built on top of event

00:11:48,079 --> 00:11:57,889
machine for the rabbitmq which allows

00:11:51,980 --> 00:12:00,709
for simple replication and horizontal

00:11:57,889 --> 00:12:03,680
scaling so the Reds app is basically

00:12:00,709 --> 00:12:05,420
just an API built with grey Pascal

00:12:03,680 --> 00:12:08,120
screen from the database nothing very

00:12:05,420 --> 00:12:12,339
fancy it is with user preferences

00:12:08,120 --> 00:12:15,500
passengers tickets PDAs and all the like

00:12:12,339 --> 00:12:19,850
it handles ecommerce operations payment

00:12:15,500 --> 00:12:21,380
invoicing emails this kind of stuff it

00:12:19,850 --> 00:12:24,199
handles a back office so you have a

00:12:21,380 --> 00:12:27,199
traditional rights views and it allows

00:12:24,199 --> 00:12:29,569
us to see and customer support to deal

00:12:27,199 --> 00:12:31,939
with the clients tickets through the

00:12:29,569 --> 00:12:34,610
back-office and all right operations are

00:12:31,939 --> 00:12:36,740
deferred to right integrator so the

00:12:34,610 --> 00:12:39,380
right temperature combined rate offers

00:12:36,740 --> 00:12:43,269
it's a purely app built with event

00:12:39,380 --> 00:12:47,930
machine it uses cooperative multitasking

00:12:43,269 --> 00:12:49,519
so for example it's nice because it

00:12:47,930 --> 00:12:51,769
allows us to have more than 12

00:12:49,519 --> 00:12:56,000
developers and 17 different vendors

00:12:51,769 --> 00:12:59,149
integrations without everybody anybody

00:12:56,000 --> 00:13:01,550
is stepping onto each other it's

00:12:59,149 --> 00:13:04,040
relatively easy for newbies to enter

00:13:01,550 --> 00:13:05,990
into the code base you can don't

00:13:04,040 --> 00:13:09,470
understand the whole mechanism and still

00:13:05,990 --> 00:13:11,990
be able to do some features we have very

00:13:09,470 --> 00:13:15,529
very few repairs or have rebates or

00:13:11,990 --> 00:13:18,079
conflicts and if you want to integrate a

00:13:15,529 --> 00:13:22,399
new operator basically you have just one

00:13:18,079 --> 00:13:24,270
to implement a vendor-neutral stateless

00:13:22,399 --> 00:13:27,210
api so we

00:13:24,270 --> 00:13:30,660
defined a set of standard verbs across

00:13:27,210 --> 00:13:32,910
integration like search searched tickets

00:13:30,660 --> 00:13:35,690
booked a ticket a me the ticket pay the

00:13:32,910 --> 00:13:37,430
ticket and that's it and that's it

00:13:35,690 --> 00:13:42,830
thanks for your attention

00:13:37,430 --> 00:13:48,760
[Applause]

00:13:42,830 --> 00:13:52,730
hi so impressing some lot of people

00:13:48,760 --> 00:13:54,830
today are talked about ruby middlewares

00:13:52,730 --> 00:13:58,850
and how we are using them in a

00:13:54,830 --> 00:14:06,860
production app a train line yeah we

00:13:58,850 --> 00:14:08,899
hacked a bit the concept so oh yeah

00:14:06,860 --> 00:14:12,380
basically a train line we sell train

00:14:08,899 --> 00:14:15,040
ticket across Europe and UK so for you

00:14:12,380 --> 00:14:18,230
from your point of view just search for

00:14:15,040 --> 00:14:20,990
travel or trip from Paris to Munich for

00:14:18,230 --> 00:14:23,930
example and we do to search for a couple

00:14:20,990 --> 00:14:27,950
seconds and we show the results combined

00:14:23,930 --> 00:14:32,690
in multiple careers so how does it work

00:14:27,950 --> 00:14:35,149
and under the hood and how do we handle

00:14:32,690 --> 00:14:38,120
the multiple carriers combination stuff

00:14:35,149 --> 00:14:42,529
so basically we have front-end Sorkin's

00:14:38,120 --> 00:14:45,680
to a giant rails IP api doing basically

00:14:42,529 --> 00:14:49,820
anything which is not connections with

00:14:45,680 --> 00:14:53,899
careers api's so let's zoom zoom in this

00:14:49,820 --> 00:14:55,880
block connection stuff it's simply a

00:14:53,899 --> 00:15:00,829
bunch of middlewares

00:14:55,880 --> 00:15:03,680
so requests are processed by generated

00:15:00,829 --> 00:15:07,360
apps on the fly and those apps are

00:15:03,680 --> 00:15:14,689
simply stacks of specialized middlewares

00:15:07,360 --> 00:15:19,759
a requests comes in and it's

00:15:14,689 --> 00:15:25,379
it calls an action which is specified

00:15:19,759 --> 00:15:30,839
with a giant environment hash and then

00:15:25,379 --> 00:15:33,959
this action is generate an app which is

00:15:30,839 --> 00:15:36,389
a stack of meteor where's this base

00:15:33,959 --> 00:15:39,569
builder that app should remind you of

00:15:36,389 --> 00:15:42,509
something it's heavily inspired by rock

00:15:39,569 --> 00:15:48,959
itself it's not rock but basically a

00:15:42,509 --> 00:15:52,680
fork of rock the action got yeah

00:15:48,959 --> 00:15:57,230
so each meter where calls it's the meter

00:15:52,680 --> 00:16:00,089
where underneath it with a town method

00:15:57,230 --> 00:16:03,540
passing the environment hash until the

00:16:00,089 --> 00:16:07,620
bottom then it bounced back and calls up

00:16:03,540 --> 00:16:12,930
for the whole matter where stack then

00:16:07,620 --> 00:16:17,759
it's respond to the request with the end

00:16:12,930 --> 00:16:20,850
of callback stuff let's see so here is

00:16:17,759 --> 00:16:23,730
an example of the action what we call

00:16:20,850 --> 00:16:24,709
action so it's simply book emit cancel

00:16:23,730 --> 00:16:27,179
search

00:16:24,709 --> 00:16:30,509
let's take search for example the

00:16:27,179 --> 00:16:33,600
actions search it's an app stack in

00:16:30,509 --> 00:16:35,939
middlewares so we have of course we

00:16:33,600 --> 00:16:39,179
removed tons of meteors here like our

00:16:35,939 --> 00:16:43,920
secret sauce so here are thus like

00:16:39,179 --> 00:16:48,240
simple stuff we are doing stuff with

00:16:43,920 --> 00:16:52,639
cache which stations avoiding you

00:16:48,240 --> 00:16:56,429
useless searches etc and the latest call

00:16:52,639 --> 00:17:00,329
what we named parallel actually it's

00:16:56,429 --> 00:17:03,240
what we'll call the courier search

00:17:00,329 --> 00:17:06,419
method like it's in C F dot search - a

00:17:03,240 --> 00:17:09,360
bandit search based on the your first

00:17:06,419 --> 00:17:11,610
request we detect what the courier we

00:17:09,360 --> 00:17:16,470
should call we don't call all the word

00:17:11,610 --> 00:17:19,580
each time and just do the calls and SNCF

00:17:16,470 --> 00:17:23,030
search method it's also

00:17:19,580 --> 00:17:26,920
an app stuck in some middlewares very

00:17:23,030 --> 00:17:30,830
specialized dude SNCF courier doing

00:17:26,920 --> 00:17:34,460
stuff with station extracting whatever

00:17:30,830 --> 00:17:38,120
and engine we doing the actual HTTP

00:17:34,460 --> 00:17:41,780
request to the outside world and the

00:17:38,120 --> 00:17:47,660
problem is that when we arrive to the

00:17:41,780 --> 00:17:50,150
bottom of the stack there we will

00:17:47,660 --> 00:17:52,310
dispatch multiple parallel requests to

00:17:50,150 --> 00:17:54,850
multiple carriers and the Careers

00:17:52,310 --> 00:17:57,680
basically all of them have shichi api's

00:17:54,850 --> 00:18:01,750
responding sometimes with after a few

00:17:57,680 --> 00:18:04,850
seconds so we have to do some

00:18:01,750 --> 00:18:07,250
parallelism here and we are using event

00:18:04,850 --> 00:18:09,440
machine to be able to coordinate between

00:18:07,250 --> 00:18:12,400
those parallel requests so everything

00:18:09,440 --> 00:18:16,160
want to is synchronous simple stuff

00:18:12,400 --> 00:18:19,400
after the middle will tree it start to

00:18:16,160 --> 00:18:22,670
be a synchronous then it sinks back all

00:18:19,400 --> 00:18:24,140
the results and go up until the top

00:18:22,670 --> 00:18:35,030
meter were to respond

00:18:24,140 --> 00:18:36,590
so yeah it's event machine hi my name is

00:18:35,030 --> 00:18:39,290
Anna I'm going to tell you about

00:18:36,590 --> 00:18:43,260
something iPhone find really cool that's

00:18:39,290 --> 00:18:47,279
property testing so

00:18:43,260 --> 00:18:49,679
I guess or I hope that most of you are

00:18:47,279 --> 00:18:54,029
using unit tests so what's the problem

00:18:49,679 --> 00:18:57,840
with unit test so how can you know how

00:18:54,029 --> 00:19:01,049
many tests are enough to cover properly

00:18:57,840 --> 00:19:03,120
your code how can you be sure that you

00:19:01,049 --> 00:19:08,399
have covered all your possible cases

00:19:03,120 --> 00:19:10,350
including eight cases so yeah cool a

00:19:08,399 --> 00:19:12,990
purse programmer break your code without

00:19:10,350 --> 00:19:16,980
your telling it's notice units without

00:19:12,990 --> 00:19:19,769
failing so let's see with some cold

00:19:16,980 --> 00:19:22,649
so let's write a fancy on in Ruby which

00:19:19,769 --> 00:19:26,190
add two numbers together that's easy

00:19:22,649 --> 00:19:28,889
a plus B we are done and now let's write

00:19:26,190 --> 00:19:33,779
some tests I'm using a respek so I'm

00:19:28,889 --> 00:19:38,070
using I'm writing two test cases one

00:19:33,779 --> 00:19:40,830
plus two will be 3 and 2 plus 0 to reach

00:19:38,070 --> 00:19:43,500
home so I'm even covering some edge

00:19:40,830 --> 00:19:46,380
cases because the zero is always tricky

00:19:43,500 --> 00:19:49,200
so everything is passing will be fine

00:19:46,380 --> 00:19:51,990
right now come the personal programmer

00:19:49,200 --> 00:19:54,870
and at an absolute value in the first

00:19:51,990 --> 00:19:57,210
parameter I forgot to add negative cases

00:19:54,870 --> 00:20:00,630
because how many test cases will I need

00:19:57,210 --> 00:20:05,370
so my test still fails but the code is

00:20:00,630 --> 00:20:09,389
now wrong so then how can property

00:20:05,370 --> 00:20:11,789
tested property tests help in and what

00:20:09,389 --> 00:20:14,539
are they exactly so a property is a

00:20:11,789 --> 00:20:18,210
high-level specification of behavior and

00:20:14,539 --> 00:20:20,159
a property test in confusing generate

00:20:18,210 --> 00:20:21,320
random example which must verify the

00:20:20,159 --> 00:20:24,960
property

00:20:21,320 --> 00:20:28,889
so let's now write the same test with

00:20:24,960 --> 00:20:30,960
using property tests I'm using a game I

00:20:28,889 --> 00:20:32,639
will speak about later but I think you

00:20:30,960 --> 00:20:34,860
will understand the code is not that

00:20:32,639 --> 00:20:37,710
difficult so in this case instead of

00:20:34,860 --> 00:20:39,870
trying concrete examples and using the

00:20:37,710 --> 00:20:41,670
addition property so they

00:20:39,870 --> 00:20:44,340
commutative associative identities

00:20:41,670 --> 00:20:45,630
element and distributive properties so

00:20:44,340 --> 00:20:48,180
for example here you have the

00:20:45,630 --> 00:20:52,380
communicative property I'm generating

00:20:48,180 --> 00:20:56,730
two random integers and then a plus V

00:20:52,380 --> 00:20:59,309
should be the same as B plus a and here

00:20:56,730 --> 00:21:01,770
you also have the associative one and on

00:20:59,309 --> 00:21:03,900
internal details but I knew exactly team

00:21:01,770 --> 00:21:07,320
for any of the tests for any of the

00:21:03,900 --> 00:21:09,960
properties 100 random tests so 100

00:21:07,320 --> 00:21:12,809
different input data tests with

00:21:09,960 --> 00:21:16,590
different input data's and everything is

00:21:12,809 --> 00:21:19,920
succession like all the 100 tests sixth

00:21:16,590 --> 00:21:22,500
is the test success now the purpose

00:21:19,920 --> 00:21:25,020
programmer arcturion and in this case it

00:21:22,500 --> 00:21:31,620
fails that we want because it is not

00:21:25,020 --> 00:21:34,170
tested with negative cases and so to sum

00:21:31,620 --> 00:21:36,630
up property Testaments venues unit test

00:21:34,170 --> 00:21:38,429
unit tests run always the same example

00:21:36,630 --> 00:21:41,700
and check the return value with a

00:21:38,429 --> 00:21:44,880
concrete value so you can end it looking

00:21:41,700 --> 00:21:46,860
like this crying guy and property tests

00:21:44,880 --> 00:21:49,500
describe the behavior and take it for

00:21:46,860 --> 00:21:53,880
several run on examples so that doesn't

00:21:49,500 --> 00:21:55,679
mean that we can remove unit tests we

00:21:53,880 --> 00:21:57,660
also need them because there are some

00:21:55,679 --> 00:21:59,970
things that cannot be easily test with

00:21:57,660 --> 00:22:03,179
property tests and also sometimes write

00:21:59,970 --> 00:22:05,160
it the property is not that easy so in

00:22:03,179 --> 00:22:06,840
Ruby we have this great gem I really

00:22:05,160 --> 00:22:09,510
encourage you to take a look because

00:22:06,840 --> 00:22:12,480
it's a great project and you can

00:22:09,510 --> 00:22:14,850
generate random data and also too you

00:22:12,480 --> 00:22:16,770
can write write you can write property

00:22:14,850 --> 00:22:18,420
based testing for test unit mini test

00:22:16,770 --> 00:22:23,400
and I respect that was the one I was

00:22:18,420 --> 00:22:28,230
using and yeah example to see you can

00:22:23,400 --> 00:22:30,330
test more complex things so for example

00:22:28,230 --> 00:22:32,400
I want to know if a project has a valid

00:22:30,330 --> 00:22:36,030
name and then in the method I have that

00:22:32,400 --> 00:22:38,160
a valid name is not valid if it has to

00:22:36,030 --> 00:22:41,160
colon so I'm testing a regular

00:22:38,160 --> 00:22:43,170
expression so I find property tests

00:22:41,160 --> 00:22:44,820
really great for testing

00:22:43,170 --> 00:22:47,930
rulers presidents because it's difficult

00:22:44,820 --> 00:22:52,740
to test a regular expressing with some

00:22:47,930 --> 00:22:55,530
example 1 to 100 so what unit test we

00:22:52,740 --> 00:22:58,590
will test one test case like one name

00:22:55,530 --> 00:23:01,050
that is not valid while with property

00:22:58,590 --> 00:23:03,420
test we will generate random strings

00:23:01,050 --> 00:23:08,130
that have two : I only might need to

00:23:03,420 --> 00:23:10,080
travel hundreds lens strings and then we

00:23:08,130 --> 00:23:12,270
will regenerate something like this so

00:23:10,080 --> 00:23:17,010
one case for unit test

00:23:12,270 --> 00:23:18,930
100 for property test and it is being

00:23:17,010 --> 00:23:21,780
used in real project so I'm using in the

00:23:18,930 --> 00:23:24,840
project I'm working in that is obvious

00:23:21,780 --> 00:23:29,100
and as open-source you can take a look

00:23:24,840 --> 00:23:32,490
at how we are using it and it's a system

00:23:29,100 --> 00:23:34,650
to will packages from sources from

00:23:32,490 --> 00:23:36,240
different distribution architectures so

00:23:34,650 --> 00:23:39,060
you can take a look at you are

00:23:36,240 --> 00:23:39,930
interested and that was everything thank

00:23:39,060 --> 00:23:44,759
you

00:23:39,930 --> 00:23:44,759
[Applause]

00:23:49,620 --> 00:23:51,680

YouTube URL: https://www.youtube.com/watch?v=0bDRKUqIu24


