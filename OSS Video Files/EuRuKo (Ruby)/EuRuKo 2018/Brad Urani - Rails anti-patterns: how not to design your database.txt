Title: Brad Urani - Rails anti-patterns: how not to design your database
Publication date: 2018-08-22
Playlist: EuRuKo 2018
Description: 
	Up Next: Coraline Ada Ehmke - The broken promise of Open Source https://www.youtube.com/watch?v=5ByUPh_uPqQ

######################
### \o/ EuRuKo 2018 \o/ ###
######################

###   Day 1  ###

Yukihiro Matsumoto - Keynote https://www.youtube.com/watch?v=cs0s5lZAUwc
Chris Salzberg - Metaprogramming for generalists https://www.youtube.com/watch?v=1fIlcnrJHxs
Joannah Nanjekye - Ruby in containers https://www.youtube.com/watch?v=qPNkOPvjecs
Damir Zekić - Tool belt of a seasoned bug hunter 
https://www.youtube.com/watch?v=ObB0dzX_rBs
Igor Morozov - Ducks and monads: wonders of Ruby types https://www.youtube.com/watch?v=v-H9nK8hqfE
Brad Urani - Rails anti-patterns: how not to design your database https://www.youtube.com/watch?v=zo3iRBPzscU
Coraline Ada Ehmke - The broken promise of Open Source https://www.youtube.com/watch?v=5ByUPh_uPqQ
Louisa Barrett - Ruby not red: color theory for the rest of us https://www.youtube.com/watch?v=OgO1EIFDgPU

###  Day 2  ###

Nadia Odunayo - The case of the missing method — a Ruby mystery story https://www.youtube.com/watch?v=OlOA0aGxud0
Pitch the next EuRuKo's location https://www.youtube.com/watch?v=YXe9OoQW8lc
Ana María Martínez Gómez - Let’s refactor some Ruby code https://www.youtube.com/watch?v=jUc8InwoA-E
Pan Thomakos - Debugging adventures in Rack-land https://www.youtube.com/watch?v=5o4krwjJbOI
Lightning talks https://www.youtube.com/watch?v=zSeaNPjwnnA
Kerstin Puschke - Scaling a monolith isn't scaling microservices https://www.youtube.com/watch?v=tA8gGd_Rl7E
Amr Abdelwahab - An empathy exercise: contextualising the question of privilege https://www.youtube.com/watch?v=6CqmGYvFwAQ
Wrap up & announcing the next EuRuKo's location https://www.youtube.com/watch?v=wMggsShGTzk
Captions: 
	00:01:20,960 --> 00:01:25,660
we are going to oh this is way louder

00:01:25,720 --> 00:01:31,460
but it worked so you know whatever works

00:01:29,060 --> 00:01:33,760
I need you to be super super quiet

00:01:31,460 --> 00:01:38,660
because I have an announcement to make

00:01:33,760 --> 00:01:42,710
hi my name is Andrew and I've been doing

00:01:38,660 --> 00:01:44,240
a great job as capturing this conference

00:01:42,710 --> 00:01:47,240
in written word

00:01:44,240 --> 00:01:50,080
I am absolutely awesome please give me a

00:01:47,240 --> 00:01:50,080
round of applause

00:01:51,500 --> 00:02:03,040
[Music]

00:01:52,590 --> 00:02:06,530
[Applause]

00:02:03,040 --> 00:02:08,960
nice all right we have two stalks coming

00:02:06,530 --> 00:02:11,540
up then there's a break and then we have

00:02:08,960 --> 00:02:14,090
one more talk coming up and then there's

00:02:11,540 --> 00:02:17,750
going to be the closing notes by Ramona

00:02:14,090 --> 00:02:19,550
and Pilar again and then then there's

00:02:17,750 --> 00:02:22,790
the after party of course it 8:00

00:02:19,550 --> 00:02:26,120
tonight so our next speaker is bread

00:02:22,790 --> 00:02:30,530
I've heard that he is quite the karaoke

00:02:26,120 --> 00:02:33,410
singer and a barbecue enthusiast and a

00:02:30,530 --> 00:02:35,660
coder who would expect that and he has

00:02:33,410 --> 00:02:38,480
about 15 years of experience with

00:02:35,660 --> 00:02:42,140
Seacole under his belt so you know if

00:02:38,480 --> 00:02:44,360
you're about to embark on your next the

00:02:42,140 --> 00:02:46,640
designing your next database challenge

00:02:44,360 --> 00:02:49,100
he is probably the best to help you with

00:02:46,640 --> 00:02:52,380
that so

00:02:49,100 --> 00:02:52,380
[Applause]

00:03:01,569 --> 00:03:07,489
hi how you doing

00:03:03,530 --> 00:03:10,340
guten tag did I say that right I'm very

00:03:07,489 --> 00:03:12,860
happy to be here in Vienna this is my

00:03:10,340 --> 00:03:14,690
second time I was here in 2003 I could

00:03:12,860 --> 00:03:16,580
not be more thrilled I flew out here

00:03:14,690 --> 00:03:18,290
from Los Angeles last night just to

00:03:16,580 --> 00:03:19,610
speak to you all and this has just been

00:03:18,290 --> 00:03:21,440
a lovely time thank you all to our

00:03:19,610 --> 00:03:22,489
organizers and all the people who set up

00:03:21,440 --> 00:03:25,340
this conference and invited me up here

00:03:22,489 --> 00:03:27,350
my name is Brad irani I am a staff

00:03:25,340 --> 00:03:30,050
engineer at procore in Santa Barbara

00:03:27,350 --> 00:03:33,080
California and this is a talk about

00:03:30,050 --> 00:03:34,760
database patterns rails anti patterns or

00:03:33,080 --> 00:03:36,200
a relational anti patterns I changed the

00:03:34,760 --> 00:03:38,180
title depending on who my audience is

00:03:36,200 --> 00:03:41,650
but it's the same talk rails anti

00:03:38,180 --> 00:03:45,799
patterns how not to design your database

00:03:41,650 --> 00:03:48,470
so warning tough decisions ahead I'm

00:03:45,799 --> 00:03:50,360
gonna give you some patterns you can use

00:03:48,470 --> 00:03:53,420
in your database but realize at the end

00:03:50,360 --> 00:03:55,280
of this that I cannot give you hard and

00:03:53,420 --> 00:03:57,440
fast rules over exactly what to use

00:03:55,280 --> 00:03:59,000
where I'm going to hopefully give you

00:03:57,440 --> 00:04:00,709
tools that will you can add to your tool

00:03:59,000 --> 00:04:02,720
belt new things to try but ultimately

00:04:00,709 --> 00:04:04,730
and the end of the day making decisions

00:04:02,720 --> 00:04:07,519
about design patterns is difficult and

00:04:04,730 --> 00:04:10,850
it's very specific to your use case so

00:04:07,519 --> 00:04:13,190
at the end of this realize that there's

00:04:10,850 --> 00:04:15,350
still choices to be made I work for pro

00:04:13,190 --> 00:04:17,720
core pro core makes offer the

00:04:15,350 --> 00:04:19,519
construction industry we make software

00:04:17,720 --> 00:04:21,919
for people who build skyscrapers giant

00:04:19,519 --> 00:04:24,770
buildings like this this is an example

00:04:21,919 --> 00:04:26,150
of one of our iPad apps it's a boot

00:04:24,770 --> 00:04:28,550
print management app for construction

00:04:26,150 --> 00:04:30,550
plans here's a gentleman out in the

00:04:28,550 --> 00:04:32,390
field using it and it is a man

00:04:30,550 --> 00:04:34,130
construction has a similar problem to

00:04:32,390 --> 00:04:36,800
software and that most of the people are

00:04:34,130 --> 00:04:39,080
males but we do have some programs in

00:04:36,800 --> 00:04:40,100
place for increasing gender diversity in

00:04:39,080 --> 00:04:41,600
the construction industry and we

00:04:40,100 --> 00:04:42,950
actually modeled them after a lot of the

00:04:41,600 --> 00:04:44,780
rails programs for this things like

00:04:42,950 --> 00:04:46,400
rails girls and things like that we're

00:04:44,780 --> 00:04:47,870
pretty proud of those we're also big

00:04:46,400 --> 00:04:49,520
supporters of the Ruby community we

00:04:47,870 --> 00:04:52,060
sponsored railsconf we were the diamond

00:04:49,520 --> 00:04:56,230
sponsors of rail comp the last two years

00:04:52,060 --> 00:04:58,000
and we thank you I appreciate that

00:04:56,230 --> 00:05:03,770
[Applause]

00:04:58,000 --> 00:05:07,189
we are very we do Postgres database a

00:05:03,770 --> 00:05:08,569
sequel at a very very large scale 60

00:05:07,189 --> 00:05:11,449
million rows scanned a second on our

00:05:08,569 --> 00:05:13,430
primary database instance is that's

00:05:11,449 --> 00:05:17,110
pretty big even I gave this talk at

00:05:13,430 --> 00:05:19,340
Postgres Kampf in New Jersey City and

00:05:17,110 --> 00:05:21,259
even the Postgres people were somewhat

00:05:19,340 --> 00:05:22,879
impressed at that fifty thousand

00:05:21,259 --> 00:05:24,319
transactions seconds probably even a

00:05:22,879 --> 00:05:25,939
more impressive number that's reads and

00:05:24,319 --> 00:05:28,159
writes there's an implicit transaction

00:05:25,939 --> 00:05:29,870
and every Postgres read with a fourteen

00:05:28,159 --> 00:05:32,719
terabyte database and what that means is

00:05:29,870 --> 00:05:33,710
that we have to do sequel very very well

00:05:32,719 --> 00:05:35,990
which means we have to design our

00:05:33,710 --> 00:05:37,490
database very very well because mistakes

00:05:35,990 --> 00:05:38,750
in the area of database design can

00:05:37,490 --> 00:05:41,300
really cost us when you're running at

00:05:38,750 --> 00:05:42,650
this scale this for instance actually

00:05:41,300 --> 00:05:43,969
this is our old instance we have a

00:05:42,650 --> 00:05:47,270
bigger one now that probably cost as

00:05:43,969 --> 00:05:49,159
much as a new Ferrari but um we cannot

00:05:47,270 --> 00:05:50,689
abuse this database and everything we do

00:05:49,159 --> 00:05:52,460
is very database heavy so this is an

00:05:50,689 --> 00:05:54,560
example from pro core it's a

00:05:52,460 --> 00:05:57,319
construction budget and when you load a

00:05:54,560 --> 00:05:59,090
page like this it's gonna run possibly

00:05:57,319 --> 00:06:00,620
twenty to thirty sequel queries just to

00:05:59,090 --> 00:06:03,500
render this page and though that is very

00:06:00,620 --> 00:06:06,740
highly tuned very intentional sequel

00:06:03,500 --> 00:06:09,710
queries and to get that fast to get this

00:06:06,740 --> 00:06:10,759
page look quickly that requires tuning

00:06:09,710 --> 00:06:12,440
this carefully choosing the right

00:06:10,759 --> 00:06:15,500
patterns making sure that the

00:06:12,440 --> 00:06:17,659
performance is spot-on but also their

00:06:15,500 --> 00:06:20,419
development developer happiness issues

00:06:17,659 --> 00:06:22,430
with this we have a very large team of

00:06:20,419 --> 00:06:24,860
rails developers dozens of rails

00:06:22,430 --> 00:06:26,300
developers and one of the largest rails

00:06:24,860 --> 00:06:27,919
Ruby on Rails apps in the world it is

00:06:26,300 --> 00:06:29,779
over a million lines of Ruby close to

00:06:27,919 --> 00:06:31,039
two million lines of Ruby right now and

00:06:29,779 --> 00:06:32,689
what that means is not only is this a

00:06:31,039 --> 00:06:34,219
sequel problem it's a Ruby on Rails

00:06:32,689 --> 00:06:35,750
problem which means the database

00:06:34,219 --> 00:06:37,400
patterns that we use have to work with

00:06:35,750 --> 00:06:40,189
our tooling in our case our tooling is

00:06:37,400 --> 00:06:41,120
Ruby on Rails and active record so not

00:06:40,189 --> 00:06:42,199
only do we have to pick the right

00:06:41,120 --> 00:06:43,610
patterns that work really well with

00:06:42,199 --> 00:06:45,560
sequel queries that are performant and

00:06:43,610 --> 00:06:47,060
fast it has to be very easy for our

00:06:45,560 --> 00:06:48,589
developers all of our web developers to

00:06:47,060 --> 00:06:51,379
use them it has to fit naturally into

00:06:48,589 --> 00:06:53,120
their toolset you know work with their

00:06:51,379 --> 00:06:57,080
core competencies which is active record

00:06:53,120 --> 00:07:00,620
and rails I don't know what that is so

00:06:57,080 --> 00:07:01,729
let's talk about anti-patterns this talk

00:07:00,620 --> 00:07:04,159
today I'm going to talk to you about two

00:07:01,729 --> 00:07:06,770
major anti patterns the anti patterns

00:07:04,159 --> 00:07:08,270
are naive trees and polymorphic

00:07:06,770 --> 00:07:10,720
relationships but first a little

00:07:08,270 --> 00:07:14,920
disclaimer there are no actual

00:07:10,720 --> 00:07:16,570
anti-patterns an anti-pattern is only an

00:07:14,920 --> 00:07:18,340
anti-pattern if you use it in the place

00:07:16,570 --> 00:07:19,450
where it's not the best choice if you

00:07:18,340 --> 00:07:21,490
use it in the place where it's the wrong

00:07:19,450 --> 00:07:23,140
choice every pattern has does have a

00:07:21,490 --> 00:07:24,400
case where is the best pattern so even

00:07:23,140 --> 00:07:25,990
my anti patterns that I'm going to talk

00:07:24,400 --> 00:07:28,780
to you about today can be the best

00:07:25,990 --> 00:07:31,360
choice if it fits your use case well but

00:07:28,780 --> 00:07:32,770
trees trees are pretty tough to work

00:07:31,360 --> 00:07:33,880
with in databases in a lot of cases so

00:07:32,770 --> 00:07:36,130
what's a tree let me give you an example

00:07:33,880 --> 00:07:38,020
if you have to represent a file system

00:07:36,130 --> 00:07:40,030
like maybe you've got some document

00:07:38,020 --> 00:07:41,380
management solution then you met have a

00:07:40,030 --> 00:07:46,110
tree in your database so here's an

00:07:41,380 --> 00:07:50,200
example of a file system hierarchy right

00:07:46,110 --> 00:07:51,040
an org chart is a tree so if you have

00:07:50,200 --> 00:07:53,500
something like this if you're

00:07:51,040 --> 00:07:55,990
representing any kind of structure like

00:07:53,500 --> 00:07:57,760
this it's a tree a comment thread like

00:07:55,990 --> 00:07:59,500
something on Hacker News is a tree and

00:07:57,760 --> 00:08:00,580
you get all this idiot stuff it's the

00:07:59,500 --> 00:08:02,380
same time every time on Hacker News

00:08:00,580 --> 00:08:03,970
someone mentions rails and they're all

00:08:02,380 --> 00:08:05,310
these JavaScript fanboys someone says

00:08:03,970 --> 00:08:06,550
something about self-driving cars

00:08:05,310 --> 00:08:10,120
blockchains

00:08:06,550 --> 00:08:12,160
and all the typical stories occasionally

00:08:10,120 --> 00:08:14,980
you do get some sense if you filter

00:08:12,160 --> 00:08:18,070
through out the noise but regardless a

00:08:14,980 --> 00:08:21,010
comment thread is a tree and our anti

00:08:18,070 --> 00:08:24,550
pattern here is naive trees so the

00:08:21,010 --> 00:08:26,740
simplest way to represent a tree in a

00:08:24,550 --> 00:08:29,080
databases with something like this I've

00:08:26,740 --> 00:08:32,919
got a primary key ID I've got a foreign

00:08:29,080 --> 00:08:34,390
key manager ID in this case the if

00:08:32,919 --> 00:08:37,150
you're say you're an employee at a

00:08:34,390 --> 00:08:40,300
company you have a manager ID which is

00:08:37,150 --> 00:08:41,560
your supervisory manager and very simply

00:08:40,300 --> 00:08:44,140
with two columns we have a tree right

00:08:41,560 --> 00:08:46,480
here this is very efficient it uses very

00:08:44,140 --> 00:08:48,400
little space it's the easiest way to

00:08:46,480 --> 00:08:52,180
represent a tree but it is the hardest

00:08:48,400 --> 00:08:53,290
to query so let's take an example of

00:08:52,180 --> 00:08:54,370
something you might want to do if you

00:08:53,290 --> 00:08:55,839
have this structure you might want to

00:08:54,370 --> 00:08:57,520
get what we have you might want to get

00:08:55,839 --> 00:08:59,110
descendants so here we have Paulie

00:08:57,520 --> 00:09:03,670
walnuts this is from The Sopranos TV

00:08:59,110 --> 00:09:05,050
show and he has many descendants getting

00:09:03,670 --> 00:09:07,960
this out of that naive tree requires

00:09:05,050 --> 00:09:09,850
some pretty hairy sequel so how do we

00:09:07,960 --> 00:09:12,190
get this well we could start at the top

00:09:09,850 --> 00:09:14,830
right and we could we could start to

00:09:12,190 --> 00:09:16,540
join so if you've got um one person you

00:09:14,830 --> 00:09:18,940
can do a join and get all of their

00:09:16,540 --> 00:09:20,890
direct children then you can do another

00:09:18,940 --> 00:09:23,110
join to get their grandchildren and

00:09:20,890 --> 00:09:24,220
another join to get that those people's

00:09:23,110 --> 00:09:25,900
children right look

00:09:24,220 --> 00:09:27,430
probably very quickly becomes when you

00:09:25,900 --> 00:09:28,840
start off this off you don't know how

00:09:27,430 --> 00:09:30,220
many joins you have to do it this case

00:09:28,840 --> 00:09:31,480
you have to do a join for every level of

00:09:30,220 --> 00:09:32,770
the tree but when you start this query

00:09:31,480 --> 00:09:34,840
you don't know how deep you need to go

00:09:32,770 --> 00:09:36,040
so this starts to break down and turns

00:09:34,840 --> 00:09:37,180
out not to work very well when you're

00:09:36,040 --> 00:09:40,030
trying to get descendants out of your

00:09:37,180 --> 00:09:42,430
database well what else we could do oh

00:09:40,030 --> 00:09:44,800
I've got an idea we could start at the

00:09:42,430 --> 00:09:46,210
top and we could get the person at the

00:09:44,800 --> 00:09:48,280
top and we could get their children with

00:09:46,210 --> 00:09:49,330
another query and get their children

00:09:48,280 --> 00:09:51,130
with another query and get their

00:09:49,330 --> 00:09:52,510
children with another query this also

00:09:51,130 --> 00:09:54,340
starts to break down this is a pattern

00:09:52,510 --> 00:09:57,040
called N+ 1 query is and it's typically

00:09:54,340 --> 00:09:59,050
a bad thing to do this is not very fast

00:09:57,040 --> 00:10:00,520
with deep trees you end up doing way too

00:09:59,050 --> 00:10:02,140
many queries and you bog down your

00:10:00,520 --> 00:10:04,270
database and hog database connections so

00:10:02,140 --> 00:10:05,770
I don't recommend this alright so how

00:10:04,270 --> 00:10:08,980
else can we get descendants out of our

00:10:05,770 --> 00:10:10,330
database oh I know we could use

00:10:08,980 --> 00:10:12,130
recursion I tried to find like the

00:10:10,330 --> 00:10:14,830
scariest tree I could find it's like the

00:10:12,130 --> 00:10:17,050
monster tree we could use recursion to

00:10:14,830 --> 00:10:18,040
try to find this recursive sequel as

00:10:17,050 --> 00:10:21,640
anyone here tried to write recursive

00:10:18,040 --> 00:10:23,920
sequel it kind of sucks right it's not

00:10:21,640 --> 00:10:25,960
very readable it is not supported well

00:10:23,920 --> 00:10:28,000
in our OMS particularly active record

00:10:25,960 --> 00:10:30,130
and things like that it's very hard to

00:10:28,000 --> 00:10:31,390
performance-tuned and if you have a lot

00:10:30,130 --> 00:10:32,890
of developers that have to deal with

00:10:31,390 --> 00:10:34,780
database tables that you have that our

00:10:32,890 --> 00:10:36,490
trees asking everyone in your

00:10:34,780 --> 00:10:38,320
organization to all right recursive

00:10:36,490 --> 00:10:40,480
sequel when they interface with this

00:10:38,320 --> 00:10:41,980
particular table is pretty much too much

00:10:40,480 --> 00:10:45,310
to ask what we need is something simple

00:10:41,980 --> 00:10:48,040
or a better way to do this a that gives

00:10:45,310 --> 00:10:49,750
people fewer foot guns right so um

00:10:48,040 --> 00:10:52,450
here's an example of some recursive

00:10:49,750 --> 00:10:54,010
sequel true fact recursive sequel is not

00:10:52,450 --> 00:10:57,760
actually recursive it's actually

00:10:54,010 --> 00:11:00,520
iterative unions but regardless it's not

00:10:57,760 --> 00:11:01,960
the best way to run this app another

00:11:00,520 --> 00:11:02,980
typical problem we were on when we have

00:11:01,960 --> 00:11:05,110
trees as we try to get people's

00:11:02,980 --> 00:11:06,580
ancestors so if we start at the bottom

00:11:05,110 --> 00:11:08,590
when we have Alfie and we want to try to

00:11:06,580 --> 00:11:10,590
find his manager and his manager and his

00:11:08,590 --> 00:11:14,400
manager and go up to the top this also

00:11:10,590 --> 00:11:17,170
we also get the same problem here so

00:11:14,400 --> 00:11:20,380
also realize that we have issues here

00:11:17,170 --> 00:11:22,270
with the end result so say at the end of

00:11:20,380 --> 00:11:23,650
the day I want to put the results of

00:11:22,270 --> 00:11:25,840
these queries on a web page right the

00:11:23,650 --> 00:11:29,470
web page might look like this nested

00:11:25,840 --> 00:11:31,030
bulleted lists this is not how the data

00:11:29,470 --> 00:11:32,500
is shaped when it comes back from sequel

00:11:31,030 --> 00:11:34,540
and it comes back from sequel it's is in

00:11:32,500 --> 00:11:35,740
a table so oftentimes with for writing

00:11:34,540 --> 00:11:37,060
recursive sequel and things like that

00:11:35,740 --> 00:11:38,259
not only do we have to write recursive

00:11:37,060 --> 00:11:39,459
sequel we have

00:11:38,259 --> 00:11:40,899
to write some recursion that takes the

00:11:39,459 --> 00:11:43,089
results and renders them into the tree

00:11:40,899 --> 00:11:45,309
so that we can display it not ideal

00:11:43,089 --> 00:11:47,049
right that's a waste of time

00:11:45,309 --> 00:11:47,919
and we haven't even mentioned everything

00:11:47,049 --> 00:11:49,569
that can go wrong here what about

00:11:47,919 --> 00:11:50,979
deleting in a tree if you have a tree

00:11:49,569 --> 00:11:52,929
and you take a node out of the middle

00:11:50,979 --> 00:11:54,519
you have to repair into everything which

00:11:52,929 --> 00:11:55,660
gets very complex try writing those

00:11:54,519 --> 00:11:58,419
queries does anyone ever tried to

00:11:55,660 --> 00:11:58,839
paginate a tree that gets pretty tricky

00:11:58,419 --> 00:12:01,239
right

00:11:58,839 --> 00:12:02,799
counting updating insert it quickly

00:12:01,239 --> 00:12:03,910
breaks down and gets very very complex

00:12:02,799 --> 00:12:06,489
when you try to deal with these things

00:12:03,910 --> 00:12:08,289
if you don't find better patterns here's

00:12:06,489 --> 00:12:10,209
an example of a giant recursive query

00:12:08,289 --> 00:12:12,699
this is a tree copy that I wrote it

00:12:10,209 --> 00:12:14,739
features among other things cycle

00:12:12,699 --> 00:12:17,319
detection so if you have a and a has a

00:12:14,739 --> 00:12:19,539
parent B and B has a parent C and C has

00:12:17,319 --> 00:12:21,189
a parent a you can infinitely loop your

00:12:19,539 --> 00:12:23,229
sequel which is not good so sometimes

00:12:21,189 --> 00:12:24,339
you're forced to put cycle detection in

00:12:23,229 --> 00:12:27,939
your queries if you deal with things

00:12:24,339 --> 00:12:29,589
like that okay but like I said anti

00:12:27,939 --> 00:12:31,089
patterns are not always anti patterns

00:12:29,589 --> 00:12:32,859
even anti patterns sometimes have the

00:12:31,089 --> 00:12:35,459
case have a good use case so if what

00:12:32,859 --> 00:12:38,470
you're doing is relatively simple right

00:12:35,459 --> 00:12:39,759
this might work for you you know if your

00:12:38,470 --> 00:12:43,149
tree if you're not doing a whole lot

00:12:39,759 --> 00:12:44,980
with it it could be good it does have

00:12:43,149 --> 00:12:46,419
referential integrity meaning you can

00:12:44,980 --> 00:12:48,160
put foreign key constraints between

00:12:46,419 --> 00:12:50,259
children and parents and enforce

00:12:48,160 --> 00:12:52,509
integrity that way it is very efficient

00:12:50,259 --> 00:12:54,549
on disk space you know if you don't need

00:12:52,509 --> 00:12:56,139
descendents if you don't need ancestors

00:12:54,549 --> 00:12:57,759
or maybe you can write some recursive

00:12:56,139 --> 00:12:59,079
sequel but then cache the results you

00:12:57,759 --> 00:13:00,549
might be able to get away with this it

00:12:59,079 --> 00:13:02,079
might work for you but if you're doing

00:13:00,549 --> 00:13:04,929
anything more complex there's probably a

00:13:02,079 --> 00:13:07,509
better way so number one alternatives to

00:13:04,929 --> 00:13:09,850
naive tree is the closure tree so a

00:13:07,509 --> 00:13:11,859
closure tree works like this in our

00:13:09,850 --> 00:13:14,410
organization here or we have this is our

00:13:11,859 --> 00:13:15,999
file system example what we do is we

00:13:14,410 --> 00:13:18,489
create a table that has a reference from

00:13:15,999 --> 00:13:20,019
every parent to all of its descendants

00:13:18,489 --> 00:13:23,169
its children its grandchildren its

00:13:20,019 --> 00:13:24,639
great-grandchildren and itself every

00:13:23,169 --> 00:13:26,919
node also have a reference to itself so

00:13:24,639 --> 00:13:30,129
it looks like this we start with this

00:13:26,919 --> 00:13:34,239
which is just we have a primary key ID

00:13:30,129 --> 00:13:35,889
we have a parent ID and in this case a

00:13:34,239 --> 00:13:38,139
name but we've seen this before right we

00:13:35,889 --> 00:13:40,539
recognize this this is naive tree isn't

00:13:38,139 --> 00:13:42,399
it so in addition to this what we add on

00:13:40,539 --> 00:13:44,559
is a table that looks like this and so

00:13:42,399 --> 00:13:48,299
here in this table on the side what we

00:13:44,559 --> 00:13:49,989
have is a primary key and a row

00:13:48,299 --> 00:13:50,960
representing every one of its

00:13:49,989 --> 00:13:51,800
descendants it's

00:13:50,960 --> 00:13:55,220
children grandchildren

00:13:51,800 --> 00:13:57,590
great-grandchildren so ancestor ID one

00:13:55,220 --> 00:13:59,900
and my example is Tony Soprano and we

00:13:57,590 --> 00:14:01,700
see not only his direct reports right

00:13:59,900 --> 00:14:03,770
but also their direct reports their

00:14:01,700 --> 00:14:05,600
direct reports their direct reports so

00:14:03,770 --> 00:14:08,780
there's a row in this table for every

00:14:05,600 --> 00:14:10,460
relationship in our tree which is why I

00:14:08,780 --> 00:14:12,710
mentioned conceptually this is what it

00:14:10,460 --> 00:14:15,440
looks like not only do we have from the

00:14:12,710 --> 00:14:16,790
top file right we've got a row for from

00:14:15,440 --> 00:14:18,740
the root two photos from the root to

00:14:16,790 --> 00:14:20,930
France 2017 from the root to railsconf

00:14:18,740 --> 00:14:23,660
and each one also has a reference to

00:14:20,930 --> 00:14:24,890
itself which is important so then it

00:14:23,660 --> 00:14:27,110
becomes very simple if we want to do

00:14:24,890 --> 00:14:28,790
something like descendants we can do

00:14:27,110 --> 00:14:31,070
that entire thing with a single join and

00:14:28,790 --> 00:14:33,560
a single where this now is a very

00:14:31,070 --> 00:14:37,310
efficient fast query very fast

00:14:33,560 --> 00:14:38,990
especially if we have in if you put the

00:14:37,310 --> 00:14:41,660
indexes in the right place in this case

00:14:38,990 --> 00:14:43,790
ancestor ID what you have to weave

00:14:41,660 --> 00:14:45,020
drastically simplified the sequel we

00:14:43,790 --> 00:14:47,450
don't have to worry too much about query

00:14:45,020 --> 00:14:48,860
tuning it's a lot easier for our

00:14:47,450 --> 00:14:51,800
developers to handle especially on

00:14:48,860 --> 00:14:53,210
larger teams so and we get very good

00:14:51,800 --> 00:14:54,560
performance out of these a single select

00:14:53,210 --> 00:14:56,810
for ancestors a single select for

00:14:54,560 --> 00:14:59,030
descendents siblings and various other

00:14:56,810 --> 00:15:00,590
things I haven't talked about all come

00:14:59,030 --> 00:15:02,600
very quickly and there's a ruby gem for

00:15:00,590 --> 00:15:04,580
this too wouldn't you know it it's

00:15:02,600 --> 00:15:06,140
called closure tree we use this in

00:15:04,580 --> 00:15:07,640
production it's really wonderful it

00:15:06,140 --> 00:15:08,900
implements this pattern for you it's got

00:15:07,640 --> 00:15:11,450
a lot of features like it helps you

00:15:08,900 --> 00:15:14,300
write the migrations it comes along it's

00:15:11,450 --> 00:15:16,370
you add it to your active active record

00:15:14,300 --> 00:15:18,230
models like this and it gives you all

00:15:16,370 --> 00:15:19,700
these wonderful methods that generate

00:15:18,230 --> 00:15:21,680
all the sequel for you and save you from

00:15:19,700 --> 00:15:22,880
having to write a lot of these things it

00:15:21,680 --> 00:15:24,140
gives you some really kind of neat

00:15:22,880 --> 00:15:26,060
advanced ones like this where you can

00:15:24,140 --> 00:15:29,690
create like whole legs of your tree in

00:15:26,060 --> 00:15:31,910
one single query mutations are also

00:15:29,690 --> 00:15:33,110
pretty quick to inserts reap Aron ting

00:15:31,910 --> 00:15:34,310
is the tough one that's when you delete

00:15:33,110 --> 00:15:35,570
a node in the middle of the tree and you

00:15:34,310 --> 00:15:36,440
have to update the parent IDs of

00:15:35,570 --> 00:15:38,180
everything else

00:15:36,440 --> 00:15:41,720
it's transactional it does the right

00:15:38,180 --> 00:15:43,610
things for you there and it's fast it's

00:15:41,720 --> 00:15:44,840
it's referential integrity is something

00:15:43,610 --> 00:15:45,860
I'm gonna talk a lot about today it

00:15:44,840 --> 00:15:47,920
allows you to put for and keep

00:15:45,860 --> 00:15:49,910
constraints on your references

00:15:47,920 --> 00:15:51,620
deterministic ordering supports all your

00:15:49,910 --> 00:15:54,650
databases includes migration tooling

00:15:51,620 --> 00:15:56,570
it's pretty nice I'm not going to get

00:15:54,650 --> 00:15:58,390
into PG bouncer but there's another

00:15:56,570 --> 00:16:00,860
alternative

00:15:58,390 --> 00:16:03,740
there's also materialized path and this

00:16:00,860 --> 00:16:04,460
is another way to represent trees that

00:16:03,740 --> 00:16:05,810
this

00:16:04,460 --> 00:16:08,570
similar job is closer to you but is

00:16:05,810 --> 00:16:10,670
slightly different so consider our file

00:16:08,570 --> 00:16:13,160
system example again we have a primary

00:16:10,670 --> 00:16:16,100
key ID and then we've got this path

00:16:13,160 --> 00:16:18,710
column so here's the fun part

00:16:16,100 --> 00:16:21,710
path is a string a text or a VAR char

00:16:18,710 --> 00:16:24,820
and as you can see it has a slash

00:16:21,710 --> 00:16:28,790
delimited sort of format here

00:16:24,820 --> 00:16:31,430
referencing every single every so every

00:16:28,790 --> 00:16:33,410
single entity's entire hierarchy in this

00:16:31,430 --> 00:16:35,090
tree now that seems a little weird right

00:16:33,410 --> 00:16:37,340
like we're seriously representing our

00:16:35,090 --> 00:16:38,960
hierarchy is a string sounds a little

00:16:37,340 --> 00:16:40,070
bit odd doesn't it the first time I saw

00:16:38,960 --> 00:16:41,420
this looks like are you kidding me that

00:16:40,070 --> 00:16:43,430
does not sound right there's got to be a

00:16:41,420 --> 00:16:45,770
better way to design this turns out it

00:16:43,430 --> 00:16:47,990
works actually really well believe it or

00:16:45,770 --> 00:16:49,520
not Microsoft sequel server uses this

00:16:47,990 --> 00:16:51,980
under hood under the hood for its tree

00:16:49,520 --> 00:16:54,050
data type all the Sun descendants

00:16:51,980 --> 00:16:57,440
becomes quite easy we've got one little

00:16:54,050 --> 00:16:59,300
query with a single where clause and now

00:16:57,440 --> 00:17:01,700
we've gotten descendants very very very

00:16:59,300 --> 00:17:04,010
fast now we all know that when you do

00:17:01,700 --> 00:17:05,900
database performance the way you make

00:17:04,010 --> 00:17:08,900
you fast is with the index right so pop

00:17:05,900 --> 00:17:12,110
quiz if I have an index on path can it

00:17:08,900 --> 00:17:14,600
use it for a query like this the answer

00:17:12,110 --> 00:17:17,570
is yes only if the wild-card is at the

00:17:14,600 --> 00:17:18,560
end you cannot put the wild-card at the

00:17:17,570 --> 00:17:20,780
beginning or in the middle but if the

00:17:18,560 --> 00:17:22,250
wild-card matches at the end it will use

00:17:20,780 --> 00:17:23,510
the index to do this lookup and that's

00:17:22,250 --> 00:17:26,000
the reason this is possible that's what

00:17:23,510 --> 00:17:27,020
makes this fast there's also a gem for

00:17:26,000 --> 00:17:29,180
this wouldn't you know it it's called

00:17:27,020 --> 00:17:30,650
ancestry it seems it's very well

00:17:29,180 --> 00:17:33,020
maintained I think they're looking for a

00:17:30,650 --> 00:17:34,820
new maintainer but last time I checked

00:17:33,020 --> 00:17:36,980
it was very up-to-date and it gives you

00:17:34,820 --> 00:17:39,230
a lot of the same things you know parent

00:17:36,980 --> 00:17:40,490
methods ancestors descendants migration

00:17:39,230 --> 00:17:42,050
tooling all those kind of things it's

00:17:40,490 --> 00:17:44,810
got some limits because it's a varchar'

00:17:42,050 --> 00:17:47,360
255 you can only go 23 levels deep

00:17:44,810 --> 00:17:49,040
that could be an issue for you there is

00:17:47,360 --> 00:17:50,750
a pretty big limitation in this approach

00:17:49,040 --> 00:17:52,010
which is no referential integrity that

00:17:50,750 --> 00:17:53,900
means because we're representing the

00:17:52,010 --> 00:17:55,640
parents as a string you cannot put a

00:17:53,900 --> 00:17:58,190
foreign key constraint on that column so

00:17:55,640 --> 00:17:59,900
there's a potential for data mistakes

00:17:58,190 --> 00:18:03,260
right due to programmer air race

00:17:59,900 --> 00:18:06,320
conditions things like that but this is

00:18:03,260 --> 00:18:07,970
fast so a little performance comparison

00:18:06,320 --> 00:18:09,980
this is from a blog post by Reynard

00:18:07,970 --> 00:18:12,260
Hillman a little blog post shows that

00:18:09,980 --> 00:18:14,270
ancestry is typically three times faster

00:18:12,260 --> 00:18:16,550
than closure tree for most of the kind

00:18:14,270 --> 00:18:19,830
of things you would want to do in this

00:18:16,550 --> 00:18:23,040
but in certain cases culture tree is

00:18:19,830 --> 00:18:24,630
orders of magnitude faster so which one

00:18:23,040 --> 00:18:26,460
is faster depends kind of on what you're

00:18:24,630 --> 00:18:28,380
doing you know

00:18:26,460 --> 00:18:30,090
are you paginating are you deleting are

00:18:28,380 --> 00:18:31,770
you counting if you're really concerned

00:18:30,090 --> 00:18:33,300
about performance if your database load

00:18:31,770 --> 00:18:35,490
is highly dependent on querying trees

00:18:33,300 --> 00:18:37,590
then you have to tailor the performance

00:18:35,490 --> 00:18:38,970
characteristics to your workload insert

00:18:37,590 --> 00:18:40,560
heavy workloads are going to be very

00:18:38,970 --> 00:18:42,240
different from write from read heavy

00:18:40,560 --> 00:18:43,860
workloads and things like that so if it

00:18:42,240 --> 00:18:45,330
matters if performance is the top thing

00:18:43,860 --> 00:18:46,800
and I'm not saying it should be if

00:18:45,330 --> 00:18:48,270
performance is top of your mind you do

00:18:46,800 --> 00:18:49,670
have to choose these based on the

00:18:48,270 --> 00:18:52,080
specific workload that you're using

00:18:49,670 --> 00:18:55,080
usually you focus on reads typically

00:18:52,080 --> 00:18:56,730
data is written once and read hundreds

00:18:55,080 --> 00:18:58,110
or even thousands of times more than it

00:18:56,730 --> 00:19:01,080
is written so usually you care a lot

00:18:58,110 --> 00:19:02,190
more about the reads than the writes but

00:19:01,080 --> 00:19:04,590
your workload may vary

00:19:02,190 --> 00:19:08,250
beware of naive benchmarks it's always

00:19:04,590 --> 00:19:09,810
specific to your use case okay so that

00:19:08,250 --> 00:19:18,420
covers trees how much time do I have

00:19:09,810 --> 00:19:22,310
where am i sorry okay so that brings us

00:19:18,420 --> 00:19:24,330
on to anti-pattern number two

00:19:22,310 --> 00:19:26,990
polymorphic relationships who knows what

00:19:24,330 --> 00:19:30,060
this is have you ever heard of this ah

00:19:26,990 --> 00:19:32,940
you are all rails developers I say this

00:19:30,060 --> 00:19:34,890
because I wrote sequel back to Web Apps

00:19:32,940 --> 00:19:36,540
for ten years and I had never heard of

00:19:34,890 --> 00:19:38,760
this problem of this pattern until the

00:19:36,540 --> 00:19:40,140
first time I ever used Ruby on Rails and

00:19:38,760 --> 00:19:41,970
the first time I looked at I was like

00:19:40,140 --> 00:19:44,070
what the beep is that like what are

00:19:41,970 --> 00:19:46,170
people doing oh my god you've got a

00:19:44,070 --> 00:19:48,530
foreign key referencing many tables this

00:19:46,170 --> 00:19:52,020
is wrong dead wrong dead wrong

00:19:48,530 --> 00:19:53,430
turns out I was wrong it is actually

00:19:52,020 --> 00:19:56,130
really useful but only for a few

00:19:53,430 --> 00:19:58,170
specific use cases and I call it an

00:19:56,130 --> 00:20:00,180
anti-pattern because a lot of the time I

00:19:58,170 --> 00:20:01,920
see it employed are used it's for the

00:20:00,180 --> 00:20:03,270
wrong reasons it's it's a lot of times

00:20:01,920 --> 00:20:05,550
employed for the use cases which is not

00:20:03,270 --> 00:20:07,350
best for but to be fair I'm gonna talk

00:20:05,550 --> 00:20:10,890
about where it does fit well where it is

00:20:07,350 --> 00:20:12,300
good also so for those of you who aren't

00:20:10,890 --> 00:20:13,890
familiar with this this is what it looks

00:20:12,300 --> 00:20:16,200
like this is actually the example that

00:20:13,890 --> 00:20:18,600
we ran into in a production case which

00:20:16,200 --> 00:20:20,160
is um here we've got three tables

00:20:18,600 --> 00:20:22,170
purchase orders sales orders and

00:20:20,160 --> 00:20:24,720
receipts they all have something in

00:20:22,170 --> 00:20:25,890
common in our sort of business design

00:20:24,720 --> 00:20:27,570
here they all have this thing called a

00:20:25,890 --> 00:20:28,370
line item which represents one of those

00:20:27,570 --> 00:20:31,490
lines

00:20:28,370 --> 00:20:33,200
on the page you know and so in this

00:20:31,490 --> 00:20:34,730
particular case we rolled up line-item

00:20:33,200 --> 00:20:36,110
into a single table we have a

00:20:34,730 --> 00:20:38,900
polymorphic relationship that means

00:20:36,110 --> 00:20:41,000
we've got that column holder ID that is

00:20:38,900 --> 00:20:42,980
a foreign key to any one of the IDS in

00:20:41,000 --> 00:20:44,870
one of the parents over there and we've

00:20:42,980 --> 00:20:46,610
got a holder type a holder type is a

00:20:44,870 --> 00:20:48,680
string which would be either purchase

00:20:46,610 --> 00:20:51,140
order sales orders or receipts and in

00:20:48,680 --> 00:20:52,700
that way the holder ID foreign key is a

00:20:51,140 --> 00:20:54,710
foreign key to any one of those other

00:20:52,700 --> 00:20:58,070
three tables and we know which one based

00:20:54,710 --> 00:20:59,570
on the string and holder type okay it

00:20:58,070 --> 00:21:01,580
looks like this when you actually look

00:20:59,570 --> 00:21:04,520
at the data you can see that holder ID

00:21:01,580 --> 00:21:05,960
there is the foreign key but we only

00:21:04,520 --> 00:21:09,140
know which table that belongs to because

00:21:05,960 --> 00:21:10,490
of the holder type over there problems

00:21:09,140 --> 00:21:12,280
with this okay well let's talk about the

00:21:10,490 --> 00:21:14,510
good sides it's built into rails

00:21:12,280 --> 00:21:16,190
honestly just the fact that it's built

00:21:14,510 --> 00:21:18,230
into rails means it may be the best

00:21:16,190 --> 00:21:19,970
choice for you it's easy you don't have

00:21:18,230 --> 00:21:21,559
to think too much you can just use it

00:21:19,970 --> 00:21:23,570
and no one will fault you if you just

00:21:21,559 --> 00:21:25,030
use this based on its ease that this

00:21:23,570 --> 00:21:27,170
because it's easy and built into rails

00:21:25,030 --> 00:21:29,210
that's perfectly acceptable if that's

00:21:27,170 --> 00:21:31,460
what's most important to you and it's

00:21:29,210 --> 00:21:33,650
also easy to add more parents if I have

00:21:31,460 --> 00:21:34,880
something like in this case line item

00:21:33,650 --> 00:21:37,160
and I was going to add a bunch of new

00:21:34,880 --> 00:21:38,600
parent types it's very easy to add those

00:21:37,160 --> 00:21:40,460
you add the new table but you don't have

00:21:38,600 --> 00:21:42,440
to actually change the line items table

00:21:40,460 --> 00:21:44,090
you just write new values to it the line

00:21:42,440 --> 00:21:46,160
items table stays the same no matter how

00:21:44,090 --> 00:21:47,780
many parents you add which if that's

00:21:46,160 --> 00:21:49,220
what's important to you could be very

00:21:47,780 --> 00:21:51,830
useful for you

00:21:49,220 --> 00:21:53,240
disadvantages is once again no foreign

00:21:51,830 --> 00:21:54,559
keys and this becomes really really

00:21:53,240 --> 00:21:56,960
important when you deal with people's

00:21:54,559 --> 00:21:59,630
data if you are holding financial data

00:21:56,960 --> 00:22:01,429
or medical data or things where you

00:21:59,630 --> 00:22:02,690
absolutely cannot get it wrong and you

00:22:01,429 --> 00:22:04,190
have the responsibility to your

00:22:02,690 --> 00:22:06,020
customers and the people who to whom

00:22:04,190 --> 00:22:09,590
this data belongs to get it absolutely

00:22:06,020 --> 00:22:13,130
right then not having foreign keys opens

00:22:09,590 --> 00:22:15,260
you up for a lot of problems so right

00:22:13,130 --> 00:22:16,580
there is a very good reason not to use

00:22:15,260 --> 00:22:18,320
that if that is what's critical to your

00:22:16,580 --> 00:22:20,330
app and your customers we lose our

00:22:18,320 --> 00:22:22,640
cascading delete when you do this I

00:22:20,330 --> 00:22:24,770
don't it gets ugly if you have to switch

00:22:22,640 --> 00:22:27,620
to Ross sequel like doing joins off two

00:22:24,770 --> 00:22:29,630
different columns gets kind of ugly it's

00:22:27,620 --> 00:22:31,550
not very space efficient if you've got

00:22:29,630 --> 00:22:34,190
that extra string type holder right on

00:22:31,550 --> 00:22:35,570
every row wastes a lot of space that's

00:22:34,190 --> 00:22:36,890
probably not a big deal in most cases

00:22:35,570 --> 00:22:39,160
but it could be depending on what you're

00:22:36,890 --> 00:22:41,450
doing so this comes with disadvantages

00:22:39,160 --> 00:22:42,290
so what are some of the alternatives

00:22:41,450 --> 00:22:44,600
well you could just keep it

00:22:42,290 --> 00:22:45,890
separate tables right in this case

00:22:44,600 --> 00:22:47,480
probably the best choice would have just

00:22:45,890 --> 00:22:48,980
been to have separate purchase order

00:22:47,480 --> 00:22:50,060
line item sales order items and receipt

00:22:48,980 --> 00:22:51,770
lines and it would have solved all these

00:22:50,060 --> 00:22:53,750
problems we should have just done this

00:22:51,770 --> 00:22:55,010
from the very beginning the air here was

00:22:53,750 --> 00:22:56,840
that we had the temptation to make it

00:22:55,010 --> 00:22:58,160
dry we saw uh all these parents have

00:22:56,840 --> 00:22:59,750
these line item things let's make it

00:22:58,160 --> 00:23:01,430
into one table and dry it up and that

00:22:59,750 --> 00:23:03,050
turned out to be an error but this only

00:23:01,430 --> 00:23:05,090
works because there's never a time where

00:23:03,050 --> 00:23:07,100
I need to show data from the three child

00:23:05,090 --> 00:23:08,480
tables all on the same page these are

00:23:07,100 --> 00:23:11,390
separate pages we never need to combine

00:23:08,480 --> 00:23:12,920
all that stuff in a lot of cases you do

00:23:11,390 --> 00:23:15,650
so this one works in a limited amount of

00:23:12,920 --> 00:23:17,030
cases but not all cases let's look at

00:23:15,650 --> 00:23:21,580
another example so the lesson there is

00:23:17,030 --> 00:23:23,890
it's okay not to be dry okay so uh

00:23:21,580 --> 00:23:25,940
another alternative here right is

00:23:23,890 --> 00:23:28,220
exclusive arcs this is another way to

00:23:25,940 --> 00:23:29,390
represent the same data and I'm going to

00:23:28,220 --> 00:23:30,800
use a slightly different example here

00:23:29,390 --> 00:23:32,840
this is sort of like the social media

00:23:30,800 --> 00:23:34,190
like the Facebook example so say you've

00:23:32,840 --> 00:23:35,540
got a say you're running a social media

00:23:34,190 --> 00:23:37,610
site you've got photos and people can

00:23:35,540 --> 00:23:38,930
comment on a photo you've got posts and

00:23:37,610 --> 00:23:40,310
people can comment on a post you've got

00:23:38,930 --> 00:23:42,950
invitations that people can comment on

00:23:40,310 --> 00:23:44,660
invitations so an exclusive Arc's which

00:23:42,950 --> 00:23:46,700
you notice we have photo ID post id and

00:23:44,660 --> 00:23:48,490
invitation ID so we have three foreign

00:23:46,700 --> 00:23:51,050
keys because we have three parent tables

00:23:48,490 --> 00:23:53,150
okay it looks like this when we look at

00:23:51,050 --> 00:23:54,560
the table you have three foreign keys

00:23:53,150 --> 00:23:58,180
and in each case you have one that's

00:23:54,560 --> 00:23:58,180
filled in and two that are known so

00:23:58,350 --> 00:24:01,640
[Music]

00:23:59,800 --> 00:24:03,320
advantages here right you can have your

00:24:01,640 --> 00:24:04,730
foreign key constraints now you can use

00:24:03,320 --> 00:24:07,720
the databases powers that it gives you

00:24:04,730 --> 00:24:10,490
to make sure that this data is correct

00:24:07,720 --> 00:24:12,080
mistakes right there are possible

00:24:10,490 --> 00:24:13,640
mistakes that is you can have a bug in

00:24:12,080 --> 00:24:16,220
your code that fills in two foreign keys

00:24:13,640 --> 00:24:17,720
but more than two foreign keys in one

00:24:16,220 --> 00:24:19,850
row one or more foreign keys in the same

00:24:17,720 --> 00:24:22,580
row you can put constraints on most

00:24:19,850 --> 00:24:23,720
databases that protect you from that one

00:24:22,580 --> 00:24:26,000
of the downsides to this is you might

00:24:23,720 --> 00:24:27,830
have many indexes so for instance to

00:24:26,000 --> 00:24:29,570
make this fast you have to put a foreign

00:24:27,830 --> 00:24:31,640
key on all of your in or you have to put

00:24:29,570 --> 00:24:33,680
an index on all of your foreign keys too

00:24:31,640 --> 00:24:35,060
many indexes will slow down your queries

00:24:33,680 --> 00:24:37,550
they speed up reads but they slow down

00:24:35,060 --> 00:24:39,140
inserts and updates so if you have a lot

00:24:37,550 --> 00:24:40,370
of different parent types you have a lot

00:24:39,140 --> 00:24:42,680
of indexes and that could become a

00:24:40,370 --> 00:24:44,510
performance bottleneck alright so

00:24:42,680 --> 00:24:46,280
another alternative is this pattern

00:24:44,510 --> 00:24:48,380
called base parent table and it looks

00:24:46,280 --> 00:24:49,610
like this so first of all on our parent

00:24:48,380 --> 00:24:51,920
table what you see is you've got a

00:24:49,610 --> 00:24:54,170
comment to Bowl ID on this side so we've

00:24:51,920 --> 00:24:54,810
moved to the foreign keys over to the

00:24:54,170 --> 00:24:57,030
right side

00:24:54,810 --> 00:24:59,940
and then we have a table in the middle

00:24:57,030 --> 00:25:01,500
called commentable the idea of which the

00:24:59,940 --> 00:25:03,810
primary key of which references the keys

00:25:01,500 --> 00:25:05,820
on that side and then we've got comments

00:25:03,810 --> 00:25:07,350
over here now look closely at this

00:25:05,820 --> 00:25:09,270
you'll see that we have a messages on

00:25:07,350 --> 00:25:11,370
comment about in a message on comments

00:25:09,270 --> 00:25:12,990
the message on commentable z' is the

00:25:11,370 --> 00:25:15,480
message that goes along with the photo

00:25:12,990 --> 00:25:16,860
post or invitation what we've done here

00:25:15,480 --> 00:25:18,960
is realized that all three of these

00:25:16,860 --> 00:25:20,730
things on the right side here all need

00:25:18,960 --> 00:25:22,830
messages so we can move it to the table

00:25:20,730 --> 00:25:24,600
in the center the actual comment also

00:25:22,830 --> 00:25:25,980
has a message which is what lives over

00:25:24,600 --> 00:25:27,750
there so what we've done is sort of like

00:25:25,980 --> 00:25:29,910
the database equivalent of inheritances

00:25:27,750 --> 00:25:32,820
we extracted the common fields and put

00:25:29,910 --> 00:25:35,100
them on the comment about a Bolivia for

00:25:32,820 --> 00:25:36,240
instance in certain pages you might only

00:25:35,100 --> 00:25:37,710
need to render the things from

00:25:36,240 --> 00:25:39,570
commentable you might not even need to

00:25:37,710 --> 00:25:41,150
query the data that's on this side maybe

00:25:39,570 --> 00:25:43,950
depending on what you're doing

00:25:41,150 --> 00:25:45,630
advantages to this so by the way that is

00:25:43,950 --> 00:25:47,580
one-to-one so for each comment a bowl we

00:25:45,630 --> 00:25:49,260
have one photo or for each photo we have

00:25:47,580 --> 00:25:50,550
one comment above and it's one-to-many

00:25:49,260 --> 00:25:53,190
over here because they can all have many

00:25:50,550 --> 00:25:55,550
comments advantages it is dry in this

00:25:53,190 --> 00:25:57,600
case that's a good kind of dry

00:25:55,550 --> 00:25:59,340
disadvantages we now have two joins now

00:25:57,600 --> 00:26:03,660
databases are designed to do joins they

00:25:59,340 --> 00:26:04,860
are very very fast it joins so probably

00:26:03,660 --> 00:26:06,390
if you've got the right indexes that

00:26:04,860 --> 00:26:08,550
might not be a bottleneck but it might

00:26:06,390 --> 00:26:09,930
you have to be careful one of the

00:26:08,550 --> 00:26:12,030
drawbacks we do find to this as well

00:26:09,930 --> 00:26:13,530
it's very easy to go from this way from

00:26:12,030 --> 00:26:15,690
the right to the left it is very hard to

00:26:13,530 --> 00:26:17,010
go the opposite way left to right so

00:26:15,690 --> 00:26:19,080
depending on which way you're joining

00:26:17,010 --> 00:26:20,760
that might be a limitation airs are

00:26:19,080 --> 00:26:24,330
still possible does anyone see it how

00:26:20,760 --> 00:26:26,100
you can mess this up well you could have

00:26:24,330 --> 00:26:27,150
the same comments below ID appear in

00:26:26,100 --> 00:26:28,770
more than one of these tables on the

00:26:27,150 --> 00:26:31,080
right but that'd be a pretty strange bug

00:26:28,770 --> 00:26:33,500
it's not likely so this is in most ways

00:26:31,080 --> 00:26:38,070
safer

00:26:33,500 --> 00:26:39,120
so just to recap here if you have right

00:26:38,070 --> 00:26:40,800
because now we have to like actually

00:26:39,120 --> 00:26:42,270
make choices we have these decisions to

00:26:40,800 --> 00:26:44,970
make we have a few more patterns in our

00:26:42,270 --> 00:26:49,620
tool belt if you have dozens of possible

00:26:44,970 --> 00:26:51,750
parent types so this is a case that we

00:26:49,620 --> 00:26:54,630
have at Pro course so we have a change

00:26:51,750 --> 00:26:56,700
tracking table so what that means is

00:26:54,630 --> 00:26:58,290
that we have dozens of tables and every

00:26:56,700 --> 00:27:01,110
time one of those has changed we want to

00:26:58,290 --> 00:27:03,390
make an entry in the change table that

00:27:01,110 --> 00:27:05,160
means dozens of possibly paired dozens

00:27:03,390 --> 00:27:08,110
of possible parent types actually in our

00:27:05,160 --> 00:27:10,030
case it's hundreds and growing every day

00:27:08,110 --> 00:27:12,570
how do we make that relationship what is

00:27:10,030 --> 00:27:14,530
the best choice in this case any guesses

00:27:12,570 --> 00:27:15,940
polymorphic relationships that is where

00:27:14,530 --> 00:27:18,730
this really really shines when you have

00:27:15,940 --> 00:27:21,760
a large and growing number of parents of

00:27:18,730 --> 00:27:24,040
parent types it's simple and mostly safe

00:27:21,760 --> 00:27:25,780
it's built into Rails oh sorry

00:27:24,040 --> 00:27:27,220
what if that doesn't work for us what if

00:27:25,780 --> 00:27:28,720
we want our pilot what if we want our

00:27:27,220 --> 00:27:30,880
referential integrity we want our

00:27:28,720 --> 00:27:33,130
foreign key constraints and we have

00:27:30,880 --> 00:27:34,450
relatively few parents exclusive arcs

00:27:33,130 --> 00:27:35,679
really well that's the one where you

00:27:34,450 --> 00:27:38,740
have a foreign key for each of the

00:27:35,679 --> 00:27:40,570
different parent types if you've got a

00:27:38,740 --> 00:27:42,040
lot of shared fields if you've got a lot

00:27:40,570 --> 00:27:45,610
of functionality we want to encapsulate

00:27:42,040 --> 00:27:47,919
that's common to our parent tables and

00:27:45,610 --> 00:27:49,600
then we want good foreign key

00:27:47,919 --> 00:27:50,799
constraints base parent table works

00:27:49,600 --> 00:27:51,840
really well that's like the common

00:27:50,799 --> 00:27:54,640
tabula

00:27:51,840 --> 00:27:56,230
as always these things your mileage may

00:27:54,640 --> 00:27:57,970
vary there are a lot of trade-offs here

00:27:56,230 --> 00:27:59,980
between performance and simplicity in

00:27:57,970 --> 00:28:01,900
some cases performing its performances

00:27:59,980 --> 00:28:03,460
everything in some case developer

00:28:01,900 --> 00:28:06,130
ergonomics and the developer experience

00:28:03,460 --> 00:28:08,230
is a lot more important there's a case

00:28:06,130 --> 00:28:09,730
of correctness in this case like having

00:28:08,230 --> 00:28:11,320
your referential integrity being able to

00:28:09,730 --> 00:28:12,880
force your business rules with database

00:28:11,320 --> 00:28:15,700
indexes unique constraints foreign key

00:28:12,880 --> 00:28:17,260
constraints you know comes at the cost

00:28:15,700 --> 00:28:18,970
of convenience which is things like

00:28:17,260 --> 00:28:20,320
polymorphic relationships that are built

00:28:18,970 --> 00:28:22,299
right into your rails framework which

00:28:20,320 --> 00:28:24,340
make it really really easy to reuse you

00:28:22,299 --> 00:28:25,540
have choices at the end of the day and

00:28:24,340 --> 00:28:27,910
you can only pick the choice that fits

00:28:25,540 --> 00:28:31,390
your use case the best so make good

00:28:27,910 --> 00:28:32,830
choices realize that the pattern it's

00:28:31,390 --> 00:28:34,480
most obvious to you might not be your

00:28:32,830 --> 00:28:35,770
best one whether its trees or these

00:28:34,480 --> 00:28:37,030
other types of relationships that there

00:28:35,770 --> 00:28:38,880
are more than one good way to do things

00:28:37,030 --> 00:28:40,900
and it depends on what you're doing

00:28:38,880 --> 00:28:43,630
congratulations you avoided recursive

00:28:40,900 --> 00:28:45,880
sequel there are a few books that I

00:28:43,630 --> 00:28:47,830
recommend for these things trees and

00:28:45,880 --> 00:28:49,750
hierarchies in sequel for Smarties this

00:28:47,830 --> 00:28:51,370
is a riveting page-turner it will keep

00:28:49,750 --> 00:28:52,660
you up all night long I'm just kidding

00:28:51,370 --> 00:28:55,419
it's like really dry and hard to get

00:28:52,660 --> 00:28:57,100
through this other one no disrespect to

00:28:55,419 --> 00:28:59,650
the author but it is really good and

00:28:57,100 --> 00:29:00,910
complete this one is more readable this

00:28:59,650 --> 00:29:03,880
one you can actually read cover to cover

00:29:00,910 --> 00:29:06,220
I enjoyed it and it details these types

00:29:03,880 --> 00:29:08,410
of anti-patterns and more bill Carwin is

00:29:06,220 --> 00:29:10,120
very excellent I'm Brad you ronnie

00:29:08,410 --> 00:29:11,890
follow me on twitter i'm a total addict

00:29:10,120 --> 00:29:13,450
reach out to me at linkedin I read I

00:29:11,890 --> 00:29:16,179
work in Santa Barbara at procorp

00:29:13,450 --> 00:29:18,790
beautiful Southern California full of

00:29:16,179 --> 00:29:21,490
home to perfect weather and wild fires

00:29:18,790 --> 00:29:23,230
at the moment oh my god pray for us

00:29:21,490 --> 00:29:24,909
this is the view from the office we are

00:29:23,230 --> 00:29:26,889
hiring all kinds of rolls Ruby

00:29:24,909 --> 00:29:28,419
android/ios security DevOps machine

00:29:26,889 --> 00:29:29,590
learning all of it so come move to

00:29:28,419 --> 00:29:33,880
California work with me

00:29:29,590 --> 00:29:38,760
we've got seals sunshine and sharks

00:29:33,880 --> 00:29:41,500
[Applause]

00:29:38,760 --> 00:29:50,029
[Music]

00:29:41,500 --> 00:29:50,029
[Applause]

00:29:50,690 --> 00:29:53,960
super scary

00:30:01,370 --> 00:30:05,110
slow motion walking

00:30:06,810 --> 00:30:13,110
Oh another another round of you know

00:30:10,890 --> 00:30:14,940
applause for Andrew because I was so

00:30:13,110 --> 00:30:22,760
quick it was difficult to follow along

00:30:14,940 --> 00:30:22,760
also even more to write it all down you

00:30:22,880 --> 00:30:28,140
know I love when I get a question where

00:30:25,200 --> 00:30:30,780
is the laptop that really you know comes

00:30:28,140 --> 00:30:33,210
my nurse I think we well-bred walks away

00:30:30,780 --> 00:30:36,870
with a laptop I'm not sure if that's the

00:30:33,210 --> 00:30:46,020
laptop that sure we have a case of a

00:30:36,870 --> 00:30:47,820
missing laptop that was exciting sort of

00:30:46,020 --> 00:30:51,360
Sherlock he all right

00:30:47,820 --> 00:30:53,580
are after after this talk we have a

00:30:51,360 --> 00:30:57,000
small break and then I want you all back

00:30:53,580 --> 00:30:59,520
at half-past four yes for the for the

00:30:57,000 --> 00:31:00,810
last talk of today and after that

00:30:59,520 --> 00:31:02,780
there's a tiny break and then there's

00:31:00,810 --> 00:31:07,010
the closing notes as I have already said

00:31:02,780 --> 00:31:11,780
the next speaker is Coraline a she is a

00:31:07,010 --> 00:31:11,780

YouTube URL: https://www.youtube.com/watch?v=zo3iRBPzscU


