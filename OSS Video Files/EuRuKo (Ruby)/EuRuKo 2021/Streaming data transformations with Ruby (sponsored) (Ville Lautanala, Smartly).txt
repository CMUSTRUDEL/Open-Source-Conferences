Title: Streaming data transformations with Ruby (sponsored) (Ville Lautanala, Smartly)
Publication date: 2021-06-03
Playlist: Euruko 2021 - Day 2
Description: 
	Sponsored lightning talk from Smartly
Captions: 
	00:00:00,160 --> 00:00:07,440
but first we are going to listen about

00:00:04,160 --> 00:00:11,200
streaming data transformations

00:00:07,440 --> 00:00:14,559
with ruby and we have a finnish guy here

00:00:11,200 --> 00:00:14,920
ville lautanala it's your turn and see

00:00:14,559 --> 00:00:17,920
you

00:00:14,920 --> 00:00:17,920
145.

00:00:21,039 --> 00:00:25,920
hi i'm bill o'tan

00:00:24,160 --> 00:00:28,320
or if you happen to run into me on the

00:00:25,920 --> 00:00:30,960
internet i usually go by the handle loud

00:00:28,320 --> 00:00:34,079
the topic for this liking talk is

00:00:30,960 --> 00:00:35,600
streaming data transformations with ruby

00:00:34,079 --> 00:00:38,239
to give an example what i'm talking

00:00:35,600 --> 00:00:38,719
about i might want to download a web

00:00:38,239 --> 00:00:40,399
page

00:00:38,719 --> 00:00:41,920
decompress it and count the number of

00:00:40,399 --> 00:00:44,079
characters on the page

00:00:41,920 --> 00:00:46,239
on terminal this is rather simple to do

00:00:44,079 --> 00:00:47,200
using crl to fetch the page piping the

00:00:46,239 --> 00:00:50,320
output to gzip

00:00:47,200 --> 00:00:51,760
and then finding that to word count to

00:00:50,320 --> 00:00:54,440
get the number of characters

00:00:51,760 --> 00:00:57,199
and on the example page we have roughly

00:00:54,440 --> 00:00:59,039
132 000

00:00:57,199 --> 00:01:00,239
and as you can see we get more of these

00:00:59,039 --> 00:01:03,280
steps if needed and

00:01:00,239 --> 00:01:05,439
things kind of uh get together and the

00:01:03,280 --> 00:01:07,280
best part of this is that

00:01:05,439 --> 00:01:09,840
this is streaming so even if the page

00:01:07,280 --> 00:01:12,080
would be terabytes in size

00:01:09,840 --> 00:01:13,680
it would work maybe take a bit longer

00:01:12,080 --> 00:01:16,080
time but wouldn't consume all my

00:01:13,680 --> 00:01:17,759
available memory

00:01:16,080 --> 00:01:20,159
so how hard can it be to implement

00:01:17,759 --> 00:01:22,479
something like this in ruby

00:01:20,159 --> 00:01:23,360
well not too hard but at least my first

00:01:22,479 --> 00:01:26,000
trial

00:01:23,360 --> 00:01:27,759
kind of ended up in a bit of a mess it

00:01:26,000 --> 00:01:31,119
does work

00:01:27,759 --> 00:01:34,079
but it's a bit of a like spaghetti

00:01:31,119 --> 00:01:35,040
where things are coupled together and

00:01:34,079 --> 00:01:38,479
mainly because

00:01:35,040 --> 00:01:39,600
there is this gzip decoder that needs to

00:01:38,479 --> 00:01:41,920
be

00:01:39,600 --> 00:01:43,600
then finalized to free up the resources

00:01:41,920 --> 00:01:46,640
so that that

00:01:43,600 --> 00:01:47,920
kind of made it harder to decompose the

00:01:46,640 --> 00:01:50,960
functionality into

00:01:47,920 --> 00:01:54,399
smaller pieces it's not a problem

00:01:50,960 --> 00:01:56,479
that much with the simple uh pro

00:01:54,399 --> 00:02:00,159
pipeline that i have but what if i would

00:01:56,479 --> 00:02:00,159
have more steps in the um

00:02:00,640 --> 00:02:05,360
streaming pipeline then it wouldn't be

00:02:03,439 --> 00:02:07,200
acceptable anymore and i would need to

00:02:05,360 --> 00:02:08,879
figure out way to recompose it so back

00:02:07,200 --> 00:02:12,239
to the drawing board

00:02:08,879 --> 00:02:14,239
how could this be improved well

00:02:12,239 --> 00:02:15,760
taking inspiration from the terminal

00:02:14,239 --> 00:02:18,000
script

00:02:15,760 --> 00:02:18,959
i thought of having this idea of a

00:02:18,000 --> 00:02:22,080
pipeline

00:02:18,959 --> 00:02:24,000
with steps where each step is a lambda

00:02:22,080 --> 00:02:26,000
function that returns an enumerable

00:02:24,000 --> 00:02:28,000
and then just compose those things

00:02:26,000 --> 00:02:31,840
together

00:02:28,000 --> 00:02:33,840
for good measure the page url

00:02:31,840 --> 00:02:35,440
or the input for the first pipeline

00:02:33,840 --> 00:02:39,280
could be given as the

00:02:35,440 --> 00:02:42,400
function call so so that

00:02:39,280 --> 00:02:47,519
when the pipeline is initialized

00:02:42,400 --> 00:02:47,519
i can change the page url if i need

00:02:48,400 --> 00:02:51,680
and this is all in the typewriter gem

00:02:50,319 --> 00:02:54,959
that i implemented

00:02:51,680 --> 00:02:57,519
the http fetch is not that interesting

00:02:54,959 --> 00:02:59,040
pretty much same as before uh for the

00:02:57,519 --> 00:03:00,640
decompression part because i really

00:02:59,040 --> 00:03:04,560
wanted to use the

00:03:00,640 --> 00:03:08,319
gc breeder i needed to implement this

00:03:04,560 --> 00:03:10,879
i o wrapper for enumerators so that

00:03:08,319 --> 00:03:12,640
i could pass in the enumerator for the

00:03:10,879 --> 00:03:16,080
gz reader as an

00:03:12,640 --> 00:03:19,360
argument and the length is

00:03:16,080 --> 00:03:21,280
pretty uninteresting rubicon

00:03:19,360 --> 00:03:22,560
so my original goal for this talk was

00:03:21,280 --> 00:03:25,120
that maybe

00:03:22,560 --> 00:03:26,959
not much is in the audience and i hope

00:03:25,120 --> 00:03:29,280
listening to this talk

00:03:26,959 --> 00:03:30,840
i could pitch the idea that we could

00:03:29,280 --> 00:03:33,760
have something like this in

00:03:30,840 --> 00:03:34,560
ruby but to not make a fool out of

00:03:33,760 --> 00:03:36,159
myself i

00:03:34,560 --> 00:03:38,720
thought it would be good idea to check

00:03:36,159 --> 00:03:40,319
that is there something like this

00:03:38,720 --> 00:03:42,319
in the latest ruby versions because i

00:03:40,319 --> 00:03:43,680
have not been writing that much ruby in

00:03:42,319 --> 00:03:45,519
the past two years

00:03:43,680 --> 00:03:46,720
and turns out that at least for the

00:03:45,519 --> 00:03:49,760
pipeline part

00:03:46,720 --> 00:03:52,560
there is so since ruby 2.7

00:03:49,760 --> 00:03:53,120
you could have written it out using the

00:03:52,560 --> 00:03:55,760
function

00:03:53,120 --> 00:03:57,280
composition operator and get pretty much

00:03:55,760 --> 00:04:00,480
the same code

00:03:57,280 --> 00:04:05,120
as before the

00:04:00,480 --> 00:04:08,560
uh enumerator io part

00:04:05,120 --> 00:04:10,879
is still valid so maybe to make my

00:04:08,560 --> 00:04:12,959
gem really redundant could we please

00:04:10,879 --> 00:04:18,079
have an enumerator ir object

00:04:12,959 --> 00:04:20,720
in ruby just like we have a string i o

00:04:18,079 --> 00:04:22,320
maybe something we could consider for

00:04:20,720 --> 00:04:25,280
future ruby versions because otherwise i

00:04:22,320 --> 00:04:27,440
think this is a pretty neat way of

00:04:25,280 --> 00:04:29,199
composing streaming data pipelines

00:04:27,440 --> 00:04:31,919
together

00:04:29,199 --> 00:04:32,880
and i can also show that it actually

00:04:31,919 --> 00:04:36,160
works so

00:04:32,880 --> 00:04:38,400
if i run the command

00:04:36,160 --> 00:04:40,400
or script i get the exact same outputs

00:04:38,400 --> 00:04:43,280
as before

00:04:40,400 --> 00:04:47,919
and thank you for your attention and

00:04:43,280 --> 00:04:47,919

YouTube URL: https://www.youtube.com/watch?v=lEedrF7ZNZU


