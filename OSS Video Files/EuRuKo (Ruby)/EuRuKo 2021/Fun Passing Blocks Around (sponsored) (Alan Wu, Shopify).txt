Title: Fun Passing Blocks Around (sponsored) (Alan Wu, Shopify)
Publication date: 2021-06-03
Playlist: Euruko 2021 - Day 1
Description: 
	A sponsored lightning talk from Shopify
Captions: 
	00:00:00,399 --> 00:00:07,600
our next talk is from our sponsor

00:00:03,880 --> 00:00:11,759
shopify and it's titled

00:00:07,600 --> 00:00:15,759
fun passing blocks around please welcome

00:00:11,759 --> 00:00:18,320
alan wu from shopify

00:00:15,759 --> 00:00:20,560
hi my name is alan i am a member of the

00:00:18,320 --> 00:00:23,119
ruby core team and i work on improving

00:00:20,560 --> 00:00:25,039
the ruby runtime at shopify

00:00:23,119 --> 00:00:26,880
i want to share some fun facts about the

00:00:25,039 --> 00:00:29,519
implementation details for passing

00:00:26,880 --> 00:00:33,040
blocks around in c ruby today

00:00:29,519 --> 00:00:36,160
let's get started so in ruby

00:00:33,040 --> 00:00:38,079
all methods implicitly take blocks and

00:00:36,160 --> 00:00:38,719
methods can invoke the block they

00:00:38,079 --> 00:00:41,600
receive

00:00:38,719 --> 00:00:44,879
with the yield keyword this is the most

00:00:41,600 --> 00:00:47,760
basic way to work with blocks works well

00:00:44,879 --> 00:00:49,200
but has some limitations for example the

00:00:47,760 --> 00:00:51,680
method can't pass

00:00:49,200 --> 00:00:52,320
the block it receives to another method

00:00:51,680 --> 00:00:54,800
it also

00:00:52,320 --> 00:00:56,160
can't save the block into a variable for

00:00:54,800 --> 00:00:58,559
later

00:00:56,160 --> 00:01:01,199
for more flexibility we can give a name

00:00:58,559 --> 00:01:03,840
to the block argument in our method

00:01:01,199 --> 00:01:04,879
yield still works but it's also possible

00:01:03,840 --> 00:01:07,520
to call the block

00:01:04,879 --> 00:01:08,240
using the block argument the block

00:01:07,520 --> 00:01:11,360
argument

00:01:08,240 --> 00:01:14,799
is a proc object instance or nil

00:01:11,360 --> 00:01:17,200
in case the method receives no block

00:01:14,799 --> 00:01:19,439
now let's say you want to change the

00:01:17,200 --> 00:01:19,920
method to check whether a block was

00:01:19,439 --> 00:01:23,119
given

00:01:19,920 --> 00:01:26,080
like this if you want to be efficient

00:01:23,119 --> 00:01:28,880
with cpu time this is where things start

00:01:26,080 --> 00:01:31,280
to get interesting

00:01:28,880 --> 00:01:32,000
let's call our method a couple million

00:01:31,280 --> 00:01:34,240
times

00:01:32,000 --> 00:01:35,439
to see if we can measure how long our

00:01:34,240 --> 00:01:38,799
script takes to run

00:01:35,439 --> 00:01:41,360
before and after adding the if check

00:01:38,799 --> 00:01:44,479
on my computer the version with the if

00:01:41,360 --> 00:01:46,720
takes about three times longer to run

00:01:44,479 --> 00:01:48,159
of course the if check itself takes some

00:01:46,720 --> 00:01:49,759
time to execute

00:01:48,159 --> 00:01:51,600
but it shouldn't make the script take

00:01:49,759 --> 00:01:55,360
three times longer

00:01:51,600 --> 00:01:58,159
so what's going on to spoil the surprise

00:01:55,360 --> 00:01:58,799
the version with the if check allocates

00:01:58,159 --> 00:02:02,320
a proc

00:01:58,799 --> 00:02:02,799
object every time it runs so this is my

00:02:02,320 --> 00:02:05,920
first

00:02:02,799 --> 00:02:06,479
fun fact some forms of block parameter

00:02:05,920 --> 00:02:10,080
usage

00:02:06,479 --> 00:02:11,360
don't allocate objects the version

00:02:10,080 --> 00:02:13,120
without the if check

00:02:11,360 --> 00:02:15,680
is benefiting from a special

00:02:13,120 --> 00:02:17,599
optimization in the runtime

00:02:15,680 --> 00:02:19,280
i will try to explain how the

00:02:17,599 --> 00:02:21,840
optimization works

00:02:19,280 --> 00:02:24,239
but first i want to go into why the

00:02:21,840 --> 00:02:26,000
optimization cannot be performed in all

00:02:24,239 --> 00:02:28,400
situations

00:02:26,000 --> 00:02:30,640
normally local variables are reserved

00:02:28,400 --> 00:02:32,480
out of a single chunk of memory

00:02:30,640 --> 00:02:34,560
it's done this way because the

00:02:32,480 --> 00:02:35,840
reservation itself can be done very

00:02:34,560 --> 00:02:38,480
efficiently

00:02:35,840 --> 00:02:38,879
reserving and releasing space pretty

00:02:38,480 --> 00:02:41,120
much

00:02:38,879 --> 00:02:43,360
involves adding and subtracting to and

00:02:41,120 --> 00:02:46,800
from a single number

00:02:43,360 --> 00:02:48,800
we reserve space when entering a method

00:02:46,800 --> 00:02:50,319
and release space when returning from

00:02:48,800 --> 00:02:52,640
the method

00:02:50,319 --> 00:02:54,400
this strategy runs into trouble when

00:02:52,640 --> 00:02:57,360
local variables need to stay

00:02:54,400 --> 00:02:58,319
accessible after the method returns

00:02:57,360 --> 00:03:01,360
let's look at an

00:02:58,319 --> 00:03:03,280
example here we save the proc

00:03:01,360 --> 00:03:04,879
object for block into an instance

00:03:03,280 --> 00:03:07,760
variable for later

00:03:04,879 --> 00:03:08,959
we then return and call into method 3

00:03:07,760 --> 00:03:12,319
which reuses

00:03:08,959 --> 00:03:14,159
the space method 1 used when we call

00:03:12,319 --> 00:03:16,080
into the block that was saved

00:03:14,159 --> 00:03:19,280
it would be wrong for the block to set

00:03:16,080 --> 00:03:22,159
the x that's define them three

00:03:19,280 --> 00:03:22,879
so where is the local variable x defined

00:03:22,159 --> 00:03:25,040
in one

00:03:22,879 --> 00:03:26,799
if not in the chunk of memory for local

00:03:25,040 --> 00:03:29,120
variables

00:03:26,799 --> 00:03:31,760
c ruby deals with this problem by

00:03:29,120 --> 00:03:34,640
dynamically allocating heap space

00:03:31,760 --> 00:03:35,280
and moving locals there when creating

00:03:34,640 --> 00:03:38,319
the proc

00:03:35,280 --> 00:03:40,799
object for the block

00:03:38,319 --> 00:03:43,360
in this example the proc object is

00:03:40,799 --> 00:03:46,239
allocated at the highlighted line

00:03:43,360 --> 00:03:48,400
when 2 returns to 1 one refers to

00:03:46,239 --> 00:03:52,159
freshly allocated heap space

00:03:48,400 --> 00:03:54,239
for the local variable x this evacuation

00:03:52,159 --> 00:03:56,959
of local variables to the heap

00:03:54,239 --> 00:03:58,400
also happens when the ruby program calls

00:03:56,959 --> 00:04:01,280
the binding method

00:03:58,400 --> 00:04:02,640
but i digress i've put more details

00:04:01,280 --> 00:04:06,239
about this operation

00:04:02,640 --> 00:04:09,439
on the screen in case you are interested

00:04:06,239 --> 00:04:11,120
that was the second fun fact i wanted to

00:04:09,439 --> 00:04:14,239
share today

00:04:11,120 --> 00:04:18,400
local variables move when a proc

00:04:14,239 --> 00:04:20,880
object is created for a block

00:04:18,400 --> 00:04:23,199
okay so let's talk about the special

00:04:20,880 --> 00:04:23,680
optimization that avoids allocating the

00:04:23,199 --> 00:04:26,160
proc

00:04:23,680 --> 00:04:27,520
object and hence avoids evacuating

00:04:26,160 --> 00:04:29,680
locals

00:04:27,520 --> 00:04:31,759
we have seen that it's problematic to

00:04:29,680 --> 00:04:32,800
refer to the chunk of memory for local

00:04:31,759 --> 00:04:34,639
variables

00:04:32,800 --> 00:04:36,000
once the method housing the block

00:04:34,639 --> 00:04:38,720
returns

00:04:36,000 --> 00:04:40,400
but it is fine to do it while the method

00:04:38,720 --> 00:04:43,120
is still running

00:04:40,400 --> 00:04:44,320
so if we can guarantee that the method

00:04:43,120 --> 00:04:46,720
housing the block is

00:04:44,320 --> 00:04:47,360
running we can call into the block

00:04:46,720 --> 00:04:50,400
without

00:04:47,360 --> 00:04:52,560
evacuating the locals the runtime looks

00:04:50,400 --> 00:04:54,320
for this condition by strictly limiting

00:04:52,560 --> 00:04:57,120
the optimization to two

00:04:54,320 --> 00:04:59,120
operations on the block parameter

00:04:57,120 --> 00:04:59,919
passing the block parameter to another

00:04:59,120 --> 00:05:02,639
method

00:04:59,919 --> 00:05:03,440
and calling the block parameter

00:05:02,639 --> 00:05:06,479
performing

00:05:03,440 --> 00:05:07,440
any other operations with the block

00:05:06,479 --> 00:05:10,800
parameter

00:05:07,440 --> 00:05:13,199
defeats the optimization while the

00:05:10,800 --> 00:05:15,520
method receiving the block is running

00:05:13,199 --> 00:05:17,440
we also know that the method passing the

00:05:15,520 --> 00:05:19,840
block is running

00:05:17,440 --> 00:05:21,199
after all the method receiving the block

00:05:19,840 --> 00:05:24,080
must have received it

00:05:21,199 --> 00:05:26,240
from somebody c ruby is very

00:05:24,080 --> 00:05:29,120
conservative when looking for these two

00:05:26,240 --> 00:05:31,280
operations for example assigning the

00:05:29,120 --> 00:05:34,880
block parameter to a local variable

00:05:31,280 --> 00:05:37,440
defeats the optimization and as we saw

00:05:34,880 --> 00:05:38,160
using the block parameter in an if

00:05:37,440 --> 00:05:41,280
condition

00:05:38,160 --> 00:05:43,759
also defeats the optimization

00:05:41,280 --> 00:05:45,039
c ruby's ruby virtual machine uses a

00:05:43,759 --> 00:05:47,520
special instruction

00:05:45,039 --> 00:05:49,039
get block param proxy to implement this

00:05:47,520 --> 00:05:52,000
optimization

00:05:49,039 --> 00:05:53,360
you can search for it in compile.c to

00:05:52,000 --> 00:05:56,479
see how it targets

00:05:53,360 --> 00:05:59,759
this optimization the instruction

00:05:56,479 --> 00:06:03,600
pushes a one-of-a-kind special object

00:05:59,759 --> 00:06:06,560
that stands in for the proc object

00:06:03,600 --> 00:06:07,520
the special proxy object has a special

00:06:06,560 --> 00:06:10,080
call method

00:06:07,520 --> 00:06:10,800
that behaves similarly to the yield

00:06:10,080 --> 00:06:14,240
keyword

00:06:10,800 --> 00:06:15,840
when called i've been talking a lot

00:06:14,240 --> 00:06:18,560
about this optimization

00:06:15,840 --> 00:06:19,039
and i would be remiss to not give credit

00:06:18,560 --> 00:06:23,440
to

00:06:19,039 --> 00:06:24,080
its author this optimization was written

00:06:23,440 --> 00:06:27,919
by

00:06:24,080 --> 00:06:32,560
koichi sasada-san or ko1

00:06:27,919 --> 00:06:35,120
on github so that was my third fun fact

00:06:32,560 --> 00:06:36,560
see ruby implements this allocation

00:06:35,120 --> 00:06:39,759
avoidance scheme

00:06:36,560 --> 00:06:42,479
with a special proxy object

00:06:39,759 --> 00:06:43,440
all right i have one last thing to talk

00:06:42,479 --> 00:06:45,680
about

00:06:43,440 --> 00:06:46,720
you might be curious as to whether this

00:06:45,680 --> 00:06:50,560
optimization

00:06:46,720 --> 00:06:53,360
is fully semantics preserving if it is

00:06:50,560 --> 00:06:54,560
then all possible ruby programs should

00:06:53,360 --> 00:06:57,120
behave the same

00:06:54,560 --> 00:06:58,960
before and after the introduction of the

00:06:57,120 --> 00:07:00,720
optimization

00:06:58,960 --> 00:07:03,120
this is important for keeping

00:07:00,720 --> 00:07:04,960
compatibility with the existing ruby

00:07:03,120 --> 00:07:07,440
programs

00:07:04,960 --> 00:07:09,520
turns out the optimization did bring

00:07:07,440 --> 00:07:11,599
about a behavior change

00:07:09,520 --> 00:07:12,720
particularly to deal with the lambda

00:07:11,599 --> 00:07:15,520
method

00:07:12,720 --> 00:07:17,199
to quickly summarize the issue it turned

00:07:15,520 --> 00:07:19,520
out that the lambda method

00:07:17,199 --> 00:07:21,759
needs the special ability to tell the

00:07:19,520 --> 00:07:23,919
difference between a literal block

00:07:21,759 --> 00:07:25,440
and when passed in with the n percent

00:07:23,919 --> 00:07:27,759
syntax

00:07:25,440 --> 00:07:30,319
there is no straightforward way in ruby

00:07:27,759 --> 00:07:31,280
code to know whether block is a little

00:07:30,319 --> 00:07:33,599
block

00:07:31,280 --> 00:07:34,639
so i think it's easy to see how this

00:07:33,599 --> 00:07:37,199
very specific

00:07:34,639 --> 00:07:39,840
corner case was missed while introducing

00:07:37,199 --> 00:07:43,039
this optimization

00:07:39,840 --> 00:07:45,840
the lambda issue was fixed in the 2.7

00:07:43,039 --> 00:07:48,400
release so this optimization is fully

00:07:45,840 --> 00:07:51,440
semantics preserving now right

00:07:48,400 --> 00:07:53,680
answer is a definite maybe there's an

00:07:51,440 --> 00:07:54,800
even more obscure and less important

00:07:53,680 --> 00:07:58,000
situation

00:07:54,800 --> 00:08:00,400
where the optimization poses a problem

00:07:58,000 --> 00:08:02,479
it's so obscure and unimportant that i'm

00:08:00,400 --> 00:08:04,720
going to leave it here as a riddle for

00:08:02,479 --> 00:08:07,759
those interested to solve

00:08:04,720 --> 00:08:08,720
that's my fourth and final fun fact the

00:08:07,759 --> 00:08:11,280
lambda method

00:08:08,720 --> 00:08:12,720
has the special ability to tell whether

00:08:11,280 --> 00:08:16,319
the block passed to it

00:08:12,720 --> 00:08:18,720
is a little block or not all right

00:08:16,319 --> 00:08:19,520
that's all i have thank you for your

00:08:18,720 --> 00:08:23,440
attention

00:08:19,520 --> 00:08:23,440
and i hope you have a nice day

00:08:24,560 --> 00:08:31,599
thank you alan we sure do have a

00:08:27,680 --> 00:08:34,719
nice day today thank you for the

00:08:31,599 --> 00:08:39,599
three and plus one extra fun

00:08:34,719 --> 00:08:39,599

YouTube URL: https://www.youtube.com/watch?v=MOfqH8euU58


