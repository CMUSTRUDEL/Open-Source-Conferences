Title: Improving Build Speed & Bundle Size with Angular Ivy | Joel Parks | #ngconf
Publication date: 2021-02-16
Playlist: Webinars
Description: 
	Join GrapeCity & ng-conf for this webinar on all the benefits that come with using the Ivy compiler. Walk away knowing how to get smaller bundle sizes, faster build times, and several other features such as consuming View Engine libraries that the Ivy compiler brings to the table.

Get tickets to ng-conf today at ng-conf.org!
Slides from presentation: https://bit.ly/WijmoSlides

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:02,490 --> 00:00:06,550
[Music]

00:00:03,870 --> 00:00:13,040
[Applause]

00:00:06,550 --> 00:00:13,759
[Music]

00:00:13,040 --> 00:00:16,480
all right so

00:00:13,759 --> 00:00:17,119
today i'm going to be going over angular

00:00:16,480 --> 00:00:19,840
iv

00:00:17,119 --> 00:00:20,960
what it is it's goals new features that

00:00:19,840 --> 00:00:22,720
it brings to the table

00:00:20,960 --> 00:00:24,320
and how you can make the switch to ivy

00:00:22,720 --> 00:00:26,160
and take advantage of all these

00:00:24,320 --> 00:00:29,599
remarkable new things that the

00:00:26,160 --> 00:00:29,599
iv compiler has to offer

00:00:29,760 --> 00:00:33,040
so just a little bit of background

00:00:31,039 --> 00:00:35,760
information my name is joel parks

00:00:33,040 --> 00:00:37,360
i work for grape city on the widge mode

00:00:35,760 --> 00:00:39,280
component library team

00:00:37,360 --> 00:00:40,640
um which mode like i said is a component

00:00:39,280 --> 00:00:42,879
library focused on

00:00:40,640 --> 00:00:45,520
data visualization and user input

00:00:42,879 --> 00:00:47,280
controls which are available to be used

00:00:45,520 --> 00:00:51,680
in all of the major frameworks so

00:00:47,280 --> 00:00:51,680
pure javascript view angular react

00:00:51,760 --> 00:00:57,840
um so now

00:00:55,199 --> 00:00:59,039
iv is angular's newest compiler by the

00:00:57,840 --> 00:01:01,280
angular team

00:00:59,039 --> 00:01:03,280
it was initially released with angular 8

00:01:01,280 --> 00:01:05,040
but was made the default compiler for

00:01:03,280 --> 00:01:07,360
new angular applications with the

00:01:05,040 --> 00:01:09,840
angular 9 release

00:01:07,360 --> 00:01:11,200
iv is replacing the view engine compiler

00:01:09,840 --> 00:01:12,240
which had been angular's default

00:01:11,200 --> 00:01:15,280
compiler since

00:01:12,240 --> 00:01:17,520
its release back in angular 4. however

00:01:15,280 --> 00:01:19,600
the angular team has made it possible to

00:01:17,520 --> 00:01:21,680
still use the view engine in angular 9.

00:01:19,600 --> 00:01:24,000
you'll just have to opt into using it

00:01:21,680 --> 00:01:26,240
over the iv compiler

00:01:24,000 --> 00:01:28,159
do note that anything after angular 9

00:01:26,240 --> 00:01:30,240
you won't be able to opt back into the

00:01:28,159 --> 00:01:32,479
view engine

00:01:30,240 --> 00:01:35,439
now ivy's a large step for angular it's

00:01:32,479 --> 00:01:37,520
a complete redesign of how the framework

00:01:35,439 --> 00:01:38,960
functions internally without changing

00:01:37,520 --> 00:01:41,280
the way that we as developers have to

00:01:38,960 --> 00:01:43,680
write our angular applications

00:01:41,280 --> 00:01:45,040
the redesign of angular with ivy serves

00:01:43,680 --> 00:01:47,520
two primary purposes

00:01:45,040 --> 00:01:49,680
and that's to reach better build times

00:01:47,520 --> 00:01:51,759
through more incremental compilation

00:01:49,680 --> 00:01:55,280
and to reach better bundle sizes through

00:01:51,759 --> 00:01:57,119
improved tree shaking compatibility

00:01:55,280 --> 00:01:58,479
the most important part of all of this

00:01:57,119 --> 00:02:00,159
is that as developers

00:01:58,479 --> 00:02:01,920
we won't have to change the way that we

00:02:00,159 --> 00:02:03,840
write our applications

00:02:01,920 --> 00:02:05,759
ibms will be compatible with existing

00:02:03,840 --> 00:02:07,360
applications and using it will be as

00:02:05,759 --> 00:02:09,360
easy as flicking a switch for most

00:02:07,360 --> 00:02:10,879
projects

00:02:09,360 --> 00:02:12,720
now a big part of the push for this

00:02:10,879 --> 00:02:14,319
reduction of bundle sizes

00:02:12,720 --> 00:02:16,560
though it improves loading performances

00:02:14,319 --> 00:02:18,480
across the board is help improve

00:02:16,560 --> 00:02:20,879
the user experience of users who are

00:02:18,480 --> 00:02:22,640
accessing the applications that we build

00:02:20,879 --> 00:02:24,640
through mobile devices such as

00:02:22,640 --> 00:02:26,879
smartphones or tablets

00:02:24,640 --> 00:02:29,680
as time has gone on mobile device usage

00:02:26,879 --> 00:02:32,080
in to access the internet has increased

00:02:29,680 --> 00:02:33,840
with it accounting for 53 percent of all

00:02:32,080 --> 00:02:36,560
internet traffic within the us

00:02:33,840 --> 00:02:38,480
in 2019 and that number is only expected

00:02:36,560 --> 00:02:40,480
to keep climbing

00:02:38,480 --> 00:02:42,239
mobile devices unfortunately often

00:02:40,480 --> 00:02:43,120
suffer from bad or slow internet

00:02:42,239 --> 00:02:44,640
connections

00:02:43,120 --> 00:02:46,959
making it harder for us to deliver the

00:02:44,640 --> 00:02:48,480
applications as fast as possible

00:02:46,959 --> 00:02:51,120
we have solutions that can help us with

00:02:48,480 --> 00:02:53,840
this such as using cdns to serve files

00:02:51,120 --> 00:02:55,840
or progressive web apps to cache assets

00:02:53,840 --> 00:02:57,760
the best opportunity we as developers

00:02:55,840 --> 00:03:00,800
have is to reduce the bundle sizes that

00:02:57,760 --> 00:03:03,040
our applications produce

00:03:00,800 --> 00:03:05,200
now along with these two main features

00:03:03,040 --> 00:03:05,840
ivies also introduced a host of other

00:03:05,200 --> 00:03:08,000
improvements

00:03:05,840 --> 00:03:09,440
along with the to mention above such as

00:03:08,000 --> 00:03:12,400
improved build errors

00:03:09,440 --> 00:03:14,159
faster testing better debugging improved

00:03:12,400 --> 00:03:17,280
css and style bindings

00:03:14,159 --> 00:03:18,800
and improved internationalization

00:03:17,280 --> 00:03:20,000
we're taking a look at each of these

00:03:18,800 --> 00:03:21,360
features in a little more depth

00:03:20,000 --> 00:03:23,200
throughout the presentation

00:03:21,360 --> 00:03:25,120
we'll also take some time to go over any

00:03:23,200 --> 00:03:26,080
potential changes that developers may

00:03:25,120 --> 00:03:28,239
need to make

00:03:26,080 --> 00:03:30,879
as well as building libraries compatible

00:03:28,239 --> 00:03:32,799
with both view engine and iv compilers

00:03:30,879 --> 00:03:35,920
and consuming those live libraries with

00:03:32,799 --> 00:03:35,920
your iv applications

00:03:37,280 --> 00:03:40,560
first improvement that we're going to

00:03:38,400 --> 00:03:42,159
take a look at is how iv helps us shrink

00:03:40,560 --> 00:03:44,159
our bundle sizes

00:03:42,159 --> 00:03:46,319
just as a quick refresher bundling in

00:03:44,159 --> 00:03:47,920
javascript is an optimization technique

00:03:46,319 --> 00:03:49,040
that allows us to merge multiple

00:03:47,920 --> 00:03:51,440
javascript files

00:03:49,040 --> 00:03:53,439
together into fewer files meaning that

00:03:51,440 --> 00:03:55,360
we can render our pages more quickly for

00:03:53,439 --> 00:03:58,000
our users

00:03:55,360 --> 00:03:59,920
now what is tree shaking tree shaking is

00:03:58,000 --> 00:04:02,480
a term commonly used in the drop script

00:03:59,920 --> 00:04:04,720
context for dead code elimination

00:04:02,480 --> 00:04:06,640
the idea is that all execution flows of

00:04:04,720 --> 00:04:07,760
a program can be represented as a tree

00:04:06,640 --> 00:04:09,760
of function calls

00:04:07,760 --> 00:04:14,080
so functions are never that are never

00:04:09,760 --> 00:04:15,840
called can be eliminated

00:04:14,080 --> 00:04:17,600
other thing that should be noted is that

00:04:15,840 --> 00:04:18,639
if you are using common js to bundle

00:04:17,600 --> 00:04:20,479
your applications

00:04:18,639 --> 00:04:22,800
angular will now throw a warning when

00:04:20,479 --> 00:04:24,160
building your application using ivy

00:04:22,800 --> 00:04:26,160
the reason for this warning is that

00:04:24,160 --> 00:04:28,240
using common gs modules can result in

00:04:26,160 --> 00:04:30,880
larger bundle sizes when performing

00:04:28,240 --> 00:04:32,320
production build this is because common

00:04:30,880 --> 00:04:34,960
js was designed to be

00:04:32,320 --> 00:04:35,520
used on server-side applications and it

00:04:34,960 --> 00:04:37,600
was not

00:04:35,520 --> 00:04:39,040
properly optimized to run on client-side

00:04:37,600 --> 00:04:40,960
applications

00:04:39,040 --> 00:04:42,880
if you're still using common js it's

00:04:40,960 --> 00:04:45,759
recommended that you switch to using es

00:04:42,880 --> 00:04:47,520
modules to bundle your applications

00:04:45,759 --> 00:04:48,880
to give you an example of what i mean

00:04:47,520 --> 00:04:50,960
when importing functions

00:04:48,880 --> 00:04:53,040
functionality from another module common

00:04:50,960 --> 00:04:55,199
js allows you to pass a variable

00:04:53,040 --> 00:04:56,960
into the path while es modules requires

00:04:55,199 --> 00:04:59,120
it to be a string literal

00:04:56,960 --> 00:05:00,080
if you take a look at this screenshot of

00:04:59,120 --> 00:05:03,520
code here

00:05:00,080 --> 00:05:05,680
the first line is an import function for

00:05:03,520 --> 00:05:08,639
com.js modules and the second is an

00:05:05,680 --> 00:05:10,080
import statement for es modules

00:05:08,639 --> 00:05:11,600
in the first one in the require

00:05:10,080 --> 00:05:12,000
statement you can see that we're passing

00:05:11,600 --> 00:05:14,240
along

00:05:12,000 --> 00:05:15,680
a path variable into the file path

00:05:14,240 --> 00:05:17,520
whereas in the uh

00:05:15,680 --> 00:05:18,720
in the second one it's just the the

00:05:17,520 --> 00:05:21,039
entire path the

00:05:18,720 --> 00:05:24,639
the location uh we're not passing in any

00:05:21,039 --> 00:05:27,120
variables there

00:05:24,639 --> 00:05:29,440
common.js can take this dynamic approach

00:05:27,120 --> 00:05:31,600
because of how dependencies are loaded

00:05:29,440 --> 00:05:32,960
when commonjs needs to load modules it's

00:05:31,600 --> 00:05:35,440
done at runtime

00:05:32,960 --> 00:05:36,240
the modules are loaded instantiated and

00:05:35,440 --> 00:05:39,039
evaluated

00:05:36,240 --> 00:05:39,680
all at once this is what allows you to

00:05:39,039 --> 00:05:42,720
do things

00:05:39,680 --> 00:05:43,840
like past variables and file paths since

00:05:42,720 --> 00:05:45,600
this is done at runtime

00:05:43,840 --> 00:05:48,000
it makes it harder for applications to

00:05:45,600 --> 00:05:50,160
perform tree shaking

00:05:48,000 --> 00:05:51,039
es modules however do not have the same

00:05:50,160 --> 00:05:52,880
problem

00:05:51,039 --> 00:05:55,199
because yes modules are more static

00:05:52,880 --> 00:05:57,600
they're more statically analyzable

00:05:55,199 --> 00:05:59,520
the loading instantiating and evaluation

00:05:57,600 --> 00:06:00,639
that takes place is broken up into three

00:05:59,520 --> 00:06:02,160
distinct phases

00:06:00,639 --> 00:06:04,000
that can be done separately instead of

00:06:02,160 --> 00:06:06,960
being required to perform them together

00:06:04,000 --> 00:06:10,880
like with common this allows us the

00:06:06,960 --> 00:06:10,880
ability for more efficient tree shaking

00:06:11,759 --> 00:06:15,759
now how does iv allow tree shaking while

00:06:14,319 --> 00:06:18,560
the view engine does not

00:06:15,759 --> 00:06:19,360
while making use of es modules it has to

00:06:18,560 --> 00:06:20,880
do with how iv

00:06:19,360 --> 00:06:23,520
updates the dom versus how the view

00:06:20,880 --> 00:06:23,520
engine does

00:06:25,840 --> 00:06:29,600
when the view engine first processes the

00:06:27,520 --> 00:06:32,080
application code it makes a note of all

00:06:29,600 --> 00:06:34,560
associations between the html properties

00:06:32,080 --> 00:06:36,240
and the typescript properties then it

00:06:34,560 --> 00:06:38,560
goes about creating bindings

00:06:36,240 --> 00:06:41,120
or a set of instructions for each html

00:06:38,560 --> 00:06:42,639
typescript property association

00:06:41,120 --> 00:06:45,120
since these bindings are component

00:06:42,639 --> 00:06:47,520
specific it is easier to optimize them

00:06:45,120 --> 00:06:49,280
than some generic instructions

00:06:47,520 --> 00:06:51,199
the resulting template data is then

00:06:49,280 --> 00:06:54,000
taken by the angular interpreter

00:06:51,199 --> 00:06:55,919
and transformed into the dom so in the

00:06:54,000 --> 00:06:59,520
slide you can see that there's a little

00:06:55,919 --> 00:07:00,560
diagram of the render pipeline for the

00:06:59,520 --> 00:07:03,039
view engine

00:07:00,560 --> 00:07:03,759
so it'll take our template html that we

00:07:03,039 --> 00:07:06,479
write

00:07:03,759 --> 00:07:07,120
convert that over into a set of template

00:07:06,479 --> 00:07:08,720
data

00:07:07,120 --> 00:07:10,479
which then gets handed off to the

00:07:08,720 --> 00:07:13,840
angular interpreter which then converts

00:07:10,479 --> 00:07:13,840
it over to be used by the dom

00:07:15,280 --> 00:07:18,560
whenever the bindings are created

00:07:16,720 --> 00:07:19,840
angular only deals with the bindings for

00:07:18,560 --> 00:07:21,919
change detection

00:07:19,840 --> 00:07:24,080
when angular is notified of a change all

00:07:21,919 --> 00:07:27,039
bindings are re-evaluated

00:07:24,080 --> 00:07:29,280
this process is called dirty checking

00:07:27,039 --> 00:07:30,720
after all bindings are re-evaluated

00:07:29,280 --> 00:07:33,919
the binding for which property is

00:07:30,720 --> 00:07:36,319
changed is then marked and updated

00:07:33,919 --> 00:07:37,759
finally the template data is interpreted

00:07:36,319 --> 00:07:40,560
and transformed into the dom with the

00:07:37,759 --> 00:07:40,560
latest bindings

00:07:41,120 --> 00:07:45,039
with ivy instead of generating template

00:07:43,199 --> 00:07:47,520
data and passing it to an interpreter

00:07:45,039 --> 00:07:49,440
that decides on which operations to run

00:07:47,520 --> 00:07:51,440
a set of template instructions is now

00:07:49,440 --> 00:07:52,960
generated directly

00:07:51,440 --> 00:07:54,960
the template instructions are where the

00:07:52,960 --> 00:07:57,120
logic that instantiates components

00:07:54,960 --> 00:07:58,000
creates dom nodes and runs change

00:07:57,120 --> 00:08:01,199
detection now

00:07:58,000 --> 00:08:02,879
lives if you take a look at this iv

00:08:01,199 --> 00:08:03,919
pipeline render image you can see that

00:08:02,879 --> 00:08:05,840
we've taken out

00:08:03,919 --> 00:08:07,360
the two sections the template data

00:08:05,840 --> 00:08:08,960
section in the angular interpreter

00:08:07,360 --> 00:08:10,560
section and those have been combined

00:08:08,960 --> 00:08:11,280
into a single template instruction

00:08:10,560 --> 00:08:13,360
section

00:08:11,280 --> 00:08:15,759
which uses the template html to create

00:08:13,360 --> 00:08:15,759
the dom

00:08:17,440 --> 00:08:21,039
the final thing to look at in regards to

00:08:19,199 --> 00:08:23,039
bundling is how much of a decrease in

00:08:21,039 --> 00:08:24,960
bundle size we see

00:08:23,039 --> 00:08:26,800
the angular team says that for small and

00:08:24,960 --> 00:08:29,039
large applications we should be seeing a

00:08:26,800 --> 00:08:30,240
decrease in bundle size of roughly 20 to

00:08:29,039 --> 00:08:32,399
30 percent

00:08:30,240 --> 00:08:34,159
and we should expect to see a slightly

00:08:32,399 --> 00:08:35,599
lower number for medium-sized

00:08:34,159 --> 00:08:37,279
applications

00:08:35,599 --> 00:08:39,360
we've done some internal testing and you

00:08:37,279 --> 00:08:43,039
can see our numbers here in the two

00:08:39,360 --> 00:08:44,880
images on this slide

00:08:43,039 --> 00:08:47,680
now these tests show the bundle sizes

00:08:44,880 --> 00:08:50,160
you using the view engine versus the iv

00:08:47,680 --> 00:08:51,920
compiler the first column shows the

00:08:50,160 --> 00:08:52,720
widget controls that we have included in

00:08:51,920 --> 00:08:54,080
each project

00:08:52,720 --> 00:08:56,000
so you can see in each one we've

00:08:54,080 --> 00:08:59,200
included a different number of controls

00:08:56,000 --> 00:09:00,959
different control combinations etc

00:08:59,200 --> 00:09:03,040
the second column is our bundle size

00:09:00,959 --> 00:09:05,519
output in kilobytes

00:09:03,040 --> 00:09:06,959
using the iv compiler and the third is

00:09:05,519 --> 00:09:07,600
the bundle size output from the view

00:09:06,959 --> 00:09:09,440
engine

00:09:07,600 --> 00:09:10,959
with the last column showing the bundle

00:09:09,440 --> 00:09:14,160
size percentage decrease

00:09:10,959 --> 00:09:16,080
between the two angular compilers

00:09:14,160 --> 00:09:18,800
you can see that from our tests we're

00:09:16,080 --> 00:09:21,040
seeing over 30 percent decrease in cases

00:09:18,800 --> 00:09:22,080
of some of the smaller applications as

00:09:21,040 --> 00:09:25,519
we get into medium-sized

00:09:22,080 --> 00:09:27,040
application it hovers around 25

00:09:25,519 --> 00:09:29,440
when everything's then done we're seeing

00:09:27,040 --> 00:09:30,080
about a 30 decrease in overall bundle

00:09:29,440 --> 00:09:31,839
size

00:09:30,080 --> 00:09:33,440
which is in line with the numbers the

00:09:31,839 --> 00:09:37,839
angular team we're saying we should

00:09:33,440 --> 00:09:37,839
expect to see

00:09:39,040 --> 00:09:42,560
the second large change that we'll take

00:09:40,800 --> 00:09:44,160
a look at is the improvements that the

00:09:42,560 --> 00:09:46,000
angular team has made in both

00:09:44,160 --> 00:09:47,760
application build times as well as

00:09:46,000 --> 00:09:49,440
improved build errors with the release

00:09:47,760 --> 00:09:51,200
of ivy

00:09:49,440 --> 00:09:53,200
when building your application each

00:09:51,200 --> 00:09:54,240
build would force angular to recompile

00:09:53,200 --> 00:09:56,240
everything

00:09:54,240 --> 00:09:57,680
inside of your module and would do so to

00:09:56,240 --> 00:09:59,200
check and see what had been changed in

00:09:57,680 --> 00:10:01,120
your code

00:09:59,200 --> 00:10:02,720
it did this because the generated code

00:10:01,120 --> 00:10:06,320
of a component could be using the

00:10:02,720 --> 00:10:08,160
internal details of another component

00:10:06,320 --> 00:10:10,000
now each component references the

00:10:08,160 --> 00:10:13,120
directives and components it uses

00:10:10,000 --> 00:10:15,120
only by their public apis so if you

00:10:13,120 --> 00:10:16,320
modify an internal detail of a component

00:10:15,120 --> 00:10:18,079
or a directive

00:10:16,320 --> 00:10:20,000
your application will know which other

00:10:18,079 --> 00:10:22,480
components the code

00:10:20,000 --> 00:10:25,519
uses the code that has been modified and

00:10:22,480 --> 00:10:27,519
only recompile those components

00:10:25,519 --> 00:10:29,279
this can lead to massive benefits in

00:10:27,519 --> 00:10:30,959
build times for applications with a

00:10:29,279 --> 00:10:33,600
large number of components

00:10:30,959 --> 00:10:35,279
and directives now instead of being

00:10:33,600 --> 00:10:36,399
required to recompile the entire

00:10:35,279 --> 00:10:38,399
application

00:10:36,399 --> 00:10:41,760
you're only recompiling those components

00:10:38,399 --> 00:10:41,760
that need to be recompiled

00:10:42,160 --> 00:10:45,680
we're going to take a look at a small

00:10:43,920 --> 00:10:47,680
example here to see what the changes

00:10:45,680 --> 00:10:48,880
look like in the compilers

00:10:47,680 --> 00:10:50,480
so in this sample we're going to be

00:10:48,880 --> 00:10:51,440
going over our mock component car

00:10:50,480 --> 00:10:53,279
component

00:10:51,440 --> 00:10:55,839
that takes an input value called car

00:10:53,279 --> 00:10:57,519
when the input is created

00:10:55,839 --> 00:10:59,200
when the car component gets used inside

00:10:57,519 --> 00:11:01,040
of another component template

00:10:59,200 --> 00:11:04,640
the code looks something like this if

00:11:01,040 --> 00:11:07,519
you take a look at the app.ts screenshot

00:11:04,640 --> 00:11:08,240
and then the appcomponent.html is how we

00:11:07,519 --> 00:11:11,920
are calling

00:11:08,240 --> 00:11:13,360
our our car component

00:11:11,920 --> 00:11:15,600
on the right side of screen you can see

00:11:13,360 --> 00:11:17,120
that the code that both the view engine

00:11:15,600 --> 00:11:19,360
and the iv compilers

00:11:17,120 --> 00:11:21,360
generated as a result of the input that

00:11:19,360 --> 00:11:24,720
our component requires

00:11:21,360 --> 00:11:27,440
for ivy you can see the code here

00:11:24,720 --> 00:11:29,760
now the iv code is only referencing the

00:11:27,440 --> 00:11:31,200
car component's public name

00:11:29,760 --> 00:11:32,880
contrast this to the code that is

00:11:31,200 --> 00:11:34,720
generated by the view engine compiler

00:11:32,880 --> 00:11:37,200
which you can see

00:11:34,720 --> 00:11:39,040
here the view engine generated code is

00:11:37,200 --> 00:11:40,399
only referencing the private field of

00:11:39,040 --> 00:11:41,600
car component

00:11:40,399 --> 00:11:45,440
the difference that we're seeing here is

00:11:41,600 --> 00:11:48,720
because of ivy's principle of locality

00:11:45,440 --> 00:11:50,800
the principle of locality

00:11:48,720 --> 00:11:51,920
in iv means that in order to compile a

00:11:50,800 --> 00:11:54,720
component in

00:11:51,920 --> 00:11:56,240
ivy angular only needs information about

00:11:54,720 --> 00:11:57,839
the component itself

00:11:56,240 --> 00:12:00,160
except for the name and package name of

00:11:57,839 --> 00:12:02,639
its declarable dependencies

00:12:00,160 --> 00:12:04,560
most notably ivy doesn't need metadata

00:12:02,639 --> 00:12:06,800
of any declarable dependencies to

00:12:04,560 --> 00:12:08,800
compile a component

00:12:06,800 --> 00:12:10,800
now this may just be a small sample but

00:12:08,800 --> 00:12:12,320
this applies for large applications as

00:12:10,800 --> 00:12:14,000
well as small

00:12:12,320 --> 00:12:15,839
all in all the angular team expects

00:12:14,000 --> 00:12:18,160
build times to improve roughly 40

00:12:15,839 --> 00:12:19,279
percent

00:12:18,160 --> 00:12:21,040
now the cool thing about these

00:12:19,279 --> 00:12:21,680
improvements the angular team has made

00:12:21,040 --> 00:12:24,320
to ivy

00:12:21,680 --> 00:12:24,959
is that angular's aot or ahead of time

00:12:24,320 --> 00:12:27,600
builds

00:12:24,959 --> 00:12:29,279
are noticeably faster this means that

00:12:27,600 --> 00:12:31,519
the angular team has been able to make

00:12:29,279 --> 00:12:32,560
aot builds the default build in ib

00:12:31,519 --> 00:12:34,399
applications

00:12:32,560 --> 00:12:36,639
both in developer mode as well as in

00:12:34,399 --> 00:12:38,160
production mode

00:12:36,639 --> 00:12:39,839
because of that i'd like to touch

00:12:38,160 --> 00:12:41,440
quickly on aot builds

00:12:39,839 --> 00:12:43,200
because the changes that allow for these

00:12:41,440 --> 00:12:45,360
kinds of builds in development mode

00:12:43,200 --> 00:12:47,120
and not just production mode have made

00:12:45,360 --> 00:12:48,560
other improvements to our applications

00:12:47,120 --> 00:12:49,839
that will be touched on later in the

00:12:48,560 --> 00:12:51,200
presentation

00:12:49,839 --> 00:12:53,519
so i feel it's important to have at

00:12:51,200 --> 00:12:56,720
least a simple understanding of what aot

00:12:53,519 --> 00:12:58,959
builds are now iot

00:12:56,720 --> 00:13:01,360
or ahead of time compilation converts

00:12:58,959 --> 00:13:03,200
your code from angular to html and

00:13:01,360 --> 00:13:04,959
angular html and typescript into

00:13:03,200 --> 00:13:06,480
efficient javascript code

00:13:04,959 --> 00:13:09,600
during the build phase before the

00:13:06,480 --> 00:13:11,360
browser downloads and runs your code

00:13:09,600 --> 00:13:13,279
compiling your application during the

00:13:11,360 --> 00:13:16,000
build process will provide faster

00:13:13,279 --> 00:13:17,519
rendering in the browser

00:13:16,000 --> 00:13:20,480
and some reasons that you want to use

00:13:17,519 --> 00:13:22,480
aot include faster rendering

00:13:20,480 --> 00:13:24,880
with aot the browser downloads a

00:13:22,480 --> 00:13:26,959
pre-compiled version of the application

00:13:24,880 --> 00:13:29,040
the browser loads executable code so it

00:13:26,959 --> 00:13:32,240
can render the application immediately

00:13:29,040 --> 00:13:34,720
without waiting to compile the app first

00:13:32,240 --> 00:13:37,200
there are fewer asynchronous requests

00:13:34,720 --> 00:13:37,839
the compiler inlines external html

00:13:37,200 --> 00:13:40,240
templates

00:13:37,839 --> 00:13:41,920
and css style sheets with within the

00:13:40,240 --> 00:13:44,000
application javascript

00:13:41,920 --> 00:13:46,240
eliminating separate ajax requests for

00:13:44,000 --> 00:13:49,199
those source files

00:13:46,240 --> 00:13:51,040
smaller angular framework download sizes

00:13:49,199 --> 00:13:52,560
there's no need to download the angular

00:13:51,040 --> 00:13:53,519
interpreter if the app is already

00:13:52,560 --> 00:13:55,279
compiled

00:13:53,519 --> 00:13:56,880
the compilers the interpreter is roughly

00:13:55,279 --> 00:13:58,880
half the size of angular itself

00:13:56,880 --> 00:14:01,680
so emitting it dramatically reduces the

00:13:58,880 --> 00:14:05,199
application payload

00:14:01,680 --> 00:14:08,560
detect template errors earlier the aot

00:14:05,199 --> 00:14:09,360
compiler detect the aot builds detect

00:14:08,560 --> 00:14:11,040
and report

00:14:09,360 --> 00:14:13,760
template binding errors during the build

00:14:11,040 --> 00:14:16,959
step before users can see them

00:14:13,760 --> 00:14:19,199
and finally better security aot compiles

00:14:16,959 --> 00:14:20,320
the html templates and components into

00:14:19,199 --> 00:14:22,720
javascript files

00:14:20,320 --> 00:14:24,560
long before they're served to the client

00:14:22,720 --> 00:14:26,399
with no templates to read and no risky

00:14:24,560 --> 00:14:27,519
client-side html or javascript

00:14:26,399 --> 00:14:28,959
evaluations

00:14:27,519 --> 00:14:31,839
there are fewer opportunities for

00:14:28,959 --> 00:14:31,839
injection attacks

00:14:33,839 --> 00:14:37,839
so along with these better build times

00:14:36,320 --> 00:14:41,279
ib has also introduced

00:14:37,839 --> 00:14:44,560
better build errors that will show

00:14:41,279 --> 00:14:46,000
when you're building your application

00:14:44,560 --> 00:14:48,399
so as you can see here we've got two

00:14:46,000 --> 00:14:48,959
different build errors both of these one

00:14:48,399 --> 00:14:51,680
in iv

00:14:48,959 --> 00:14:53,600
one in the view engine are for when you

00:14:51,680 --> 00:14:55,199
are calling a component

00:14:53,600 --> 00:14:58,000
that hasn't been imported into your

00:14:55,199 --> 00:15:01,040
module so you can see the first one here

00:14:58,000 --> 00:15:04,639
it just says that the app new component

00:15:01,040 --> 00:15:05,519
is not known uh and then it's saying

00:15:04,639 --> 00:15:08,160
that if it is

00:15:05,519 --> 00:15:09,360
add it to the add it to your module if

00:15:08,160 --> 00:15:11,680
you look at the second one

00:15:09,360 --> 00:15:12,639
it's showing the exact line of code that

00:15:11,680 --> 00:15:14,320
it's on

00:15:12,639 --> 00:15:16,079
and the exact file that you're seeing

00:15:14,320 --> 00:15:18,560
this in

00:15:16,079 --> 00:15:20,720
so it clears up a some of the

00:15:18,560 --> 00:15:22,160
readability here

00:15:20,720 --> 00:15:23,920
the bullet points of the error message

00:15:22,160 --> 00:15:25,279
are the same they let the developer know

00:15:23,920 --> 00:15:27,360
that the element that the user

00:15:25,279 --> 00:15:28,800
is trying to load may be a component but

00:15:27,360 --> 00:15:31,759
it's not been included as a part of the

00:15:28,800 --> 00:15:31,759
module that's being built

00:15:34,639 --> 00:15:38,320
so now we're going to take a look at

00:15:36,079 --> 00:15:40,720
some of the changes that ivy has made to

00:15:38,320 --> 00:15:43,600
allow us to test our applications faster

00:15:40,720 --> 00:15:43,600
and more efficiently

00:15:44,800 --> 00:15:48,880
with the release of iv angular now

00:15:46,560 --> 00:15:49,440
enables us to use alt compilation in all

00:15:48,880 --> 00:15:51,839
phases

00:15:49,440 --> 00:15:53,279
including the testing phase this allows

00:15:51,839 --> 00:15:54,800
us to catch errors more quickly

00:15:53,279 --> 00:15:56,000
since we have fewer differences between

00:15:54,800 --> 00:15:58,000
the testing environment and the

00:15:56,000 --> 00:15:59,600
production environment

00:15:58,000 --> 00:16:01,759
along with this the angular team has

00:15:59,600 --> 00:16:03,519
also taken the opportunity to revamp

00:16:01,759 --> 00:16:06,240
angular's implementation of

00:16:03,519 --> 00:16:09,120
the test bed class and iv to help

00:16:06,240 --> 00:16:12,160
improve some of its efficiency

00:16:09,120 --> 00:16:14,240
in ivy testbed doesn't recon

00:16:12,160 --> 00:16:16,160
excuse me previously testbed would

00:16:14,240 --> 00:16:17,519
recompile all components between the

00:16:16,160 --> 00:16:20,399
running of each test

00:16:17,519 --> 00:16:21,920
or between each it statement regardless

00:16:20,399 --> 00:16:23,279
of whether there were any changes to be

00:16:21,920 --> 00:16:27,120
made to components

00:16:23,279 --> 00:16:29,279
for example through overrides in ivy

00:16:27,120 --> 00:16:31,040
testbed doesn't recompile components

00:16:29,279 --> 00:16:32,880
between tests unless a component has

00:16:31,040 --> 00:16:35,759
been manually overwritten

00:16:32,880 --> 00:16:39,360
which allows it to avoid recompilation

00:16:35,759 --> 00:16:41,600
between a majority of developers tests

00:16:39,360 --> 00:16:43,279
with this change the iv team has seen

00:16:41,600 --> 00:16:43,920
the framework's core acceptance test

00:16:43,279 --> 00:16:46,959
speeds

00:16:43,920 --> 00:16:48,000
improve roughly 40 percent they stated

00:16:46,959 --> 00:16:50,000
that they expect

00:16:48,000 --> 00:16:52,079
users to see their own application test

00:16:50,000 --> 00:16:55,600
speeds to be around 40 to 50

00:16:52,079 --> 00:16:55,600
faster than they previously were

00:16:57,519 --> 00:17:02,160
the angular cdk also introduces a

00:17:00,320 --> 00:17:03,600
testing subclass with version 9 which

00:17:02,160 --> 00:17:05,600
can be used to implement something

00:17:03,600 --> 00:17:07,039
called a component harness for test

00:17:05,600 --> 00:17:08,640
cases

00:17:07,039 --> 00:17:11,199
a component harnesses hide

00:17:08,640 --> 00:17:13,439
implementation details of a component

00:17:11,199 --> 00:17:15,839
and exposes api which can be used to

00:17:13,439 --> 00:17:19,039
retrieve important dom attributes

00:17:15,839 --> 00:17:20,000
such as aria attributes interact with

00:17:19,039 --> 00:17:22,079
the component

00:17:20,000 --> 00:17:23,520
as users would without querying a

00:17:22,079 --> 00:17:25,760
component's dom

00:17:23,520 --> 00:17:27,360
and get harnesses of related components

00:17:25,760 --> 00:17:29,200
such as child components or

00:17:27,360 --> 00:17:31,840
dialogues with menu triggers by the

00:17:29,200 --> 00:17:33,760
current component

00:17:31,840 --> 00:17:36,720
harnesses can be used in unit tests

00:17:33,760 --> 00:17:39,440
integration tests and end-to-end tests

00:17:36,720 --> 00:17:41,440
the angular cdk comes with two harness

00:17:39,440 --> 00:17:43,280
environments out of the box

00:17:41,440 --> 00:17:45,360
the first one is the test bed harness

00:17:43,280 --> 00:17:47,840
environment which can be used for unit

00:17:45,360 --> 00:17:49,919
tests and integration tests

00:17:47,840 --> 00:17:51,919
the second is the protractor harness

00:17:49,919 --> 00:17:55,039
environment which is used for end-to-end

00:17:51,919 --> 00:17:56,880
tests driven by protractor

00:17:55,039 --> 00:17:58,480
the test bed harness environment is

00:17:56,880 --> 00:17:59,760
first and foremost meant to be used with

00:17:58,480 --> 00:18:02,720
jasmine and karma

00:17:59,760 --> 00:18:03,919
the de facto angular unit testing stacks

00:18:02,720 --> 00:18:07,440
which should work with other test

00:18:03,919 --> 00:18:07,440
runners and test frameworks as well

00:18:10,240 --> 00:18:13,679
now we have a lot of tools at our

00:18:11,840 --> 00:18:15,919
disposal to debug web

00:18:13,679 --> 00:18:17,520
applications i'm using simple logging

00:18:15,919 --> 00:18:19,039
statements in our code

00:18:17,520 --> 00:18:20,799
browser development tools and web

00:18:19,039 --> 00:18:22,720
extensions there are plenty of ways for

00:18:20,799 --> 00:18:24,240
us to tackle the issues of debugging our

00:18:22,720 --> 00:18:26,559
application

00:18:24,240 --> 00:18:29,200
but the angular team has given us a new

00:18:26,559 --> 00:18:32,320
tool with the release of ivy

00:18:29,200 --> 00:18:34,480
a global variable called ng

00:18:32,320 --> 00:18:37,120
this new variable allows us to access

00:18:34,480 --> 00:18:38,559
corresponding angular components

00:18:37,120 --> 00:18:40,480
we can not only see the component

00:18:38,559 --> 00:18:41,280
properties and functions we can also

00:18:40,480 --> 00:18:42,880
modify them

00:18:41,280 --> 00:18:45,200
in our browser's console and trigger

00:18:42,880 --> 00:18:47,120
change detection

00:18:45,200 --> 00:18:49,600
to use the ng object you'll need to have

00:18:47,120 --> 00:18:52,480
your application running in dev mode

00:18:49,600 --> 00:18:52,799
with the ng object you can ask angular

00:18:52,480 --> 00:18:55,039
for

00:18:52,799 --> 00:18:56,640
instances of your components directives

00:18:55,039 --> 00:19:00,400
and more

00:18:56,640 --> 00:19:02,080
manually call methods and update states

00:19:00,400 --> 00:19:03,760
trigger change detection with apply

00:19:02,080 --> 00:19:06,080
changes when you want to see the results

00:19:03,760 --> 00:19:09,120
of your change detection

00:19:06,080 --> 00:19:10,799
by doing this you can avoid inserting

00:19:09,120 --> 00:19:11,200
unnecessary logging statements in your

00:19:10,799 --> 00:19:13,039
code

00:19:11,200 --> 00:19:14,880
because you can see the component state

00:19:13,039 --> 00:19:17,600
directly in your browser without any

00:19:14,880 --> 00:19:17,600
further tools

00:19:18,720 --> 00:19:21,600
one of the errors that a lot of

00:19:20,000 --> 00:19:22,000
developers ran into that they hated to

00:19:21,600 --> 00:19:23,679
see

00:19:22,000 --> 00:19:25,360
during their angular development was the

00:19:23,679 --> 00:19:26,720
expression changed after it has been

00:19:25,360 --> 00:19:28,559
checked error

00:19:26,720 --> 00:19:30,160
the output was pretty messy which made

00:19:28,559 --> 00:19:31,039
it hard to debug the issue and find the

00:19:30,160 --> 00:19:32,000
root cause of it

00:19:31,039 --> 00:19:34,000
and as you can see here on the

00:19:32,000 --> 00:19:35,360
screenshot this is one of the errors

00:19:34,000 --> 00:19:38,240
from the view engine

00:19:35,360 --> 00:19:40,720
of uh the expression changed after had

00:19:38,240 --> 00:19:40,720
been checked

00:19:42,240 --> 00:19:46,320
now ivy's updated the error messages a

00:19:44,240 --> 00:19:47,600
little bit um it looks pretty similar

00:19:46,320 --> 00:19:49,919
but they've added some

00:19:47,600 --> 00:19:51,600
uh some stuff to it here so for example

00:19:49,919 --> 00:19:54,240
if you take a look

00:19:51,600 --> 00:19:56,640
at the app component template in the

00:19:54,240 --> 00:19:58,320
stack trace here

00:19:56,640 --> 00:20:00,720
which was not in the previous stack

00:19:58,320 --> 00:20:02,799
trace you can click directly on that

00:20:00,720 --> 00:20:05,200
and it will take you from the stack

00:20:02,799 --> 00:20:06,000
trace right to the specific line in the

00:20:05,200 --> 00:20:09,280
generated code

00:20:06,000 --> 00:20:11,280
where the error is being thrown if you'd

00:20:09,280 --> 00:20:12,880
like you can also step into any of these

00:20:11,280 --> 00:20:14,320
framework instructions to walk through

00:20:12,880 --> 00:20:20,000
how the framework creates

00:20:14,320 --> 00:20:22,240
and updates your components

00:20:20,000 --> 00:20:24,000
the iv compiler and runtime provides

00:20:22,240 --> 00:20:25,760
improvements for handling styles

00:20:24,000 --> 00:20:28,320
as well as the ability to use style

00:20:25,760 --> 00:20:30,720
variables inside of the html template

00:20:28,320 --> 00:20:30,720
itself

00:20:30,960 --> 00:20:34,480
in previous versions of angular

00:20:32,840 --> 00:20:36,559
whichever

00:20:34,480 --> 00:20:38,880
whichever style binding was evaluated

00:20:36,559 --> 00:20:40,240
last on the html element

00:20:38,880 --> 00:20:42,000
would be the one that would be of the

00:20:40,240 --> 00:20:44,640
applied style

00:20:42,000 --> 00:20:45,120
for example take a look at the uh html

00:20:44,640 --> 00:20:48,559
here

00:20:45,120 --> 00:20:52,240
so you can see that we're setting

00:20:48,559 --> 00:20:55,280
three different styles uh the the red

00:20:52,240 --> 00:20:57,840
color to our element

00:20:55,280 --> 00:21:00,000
we're using the style attribute we're

00:20:57,840 --> 00:21:04,080
using the style.color attribute

00:21:00,000 --> 00:21:05,600
and then in the final one we are using

00:21:04,080 --> 00:21:09,440
the style where we are passing in

00:21:05,600 --> 00:21:12,640
another variable to the color property

00:21:09,440 --> 00:21:13,360
if my color and other color were both

00:21:12,640 --> 00:21:15,679
undefined

00:21:13,360 --> 00:21:16,720
in this case then the static red would

00:21:15,679 --> 00:21:18,559
get ignored

00:21:16,720 --> 00:21:20,400
because it was overwritten by the styles

00:21:18,559 --> 00:21:24,640
that came later in the

00:21:20,400 --> 00:21:26,880
in the element with the iv compiler

00:21:24,640 --> 00:21:29,039
you can use a clear and concise order of

00:21:26,880 --> 00:21:31,679
precedence to determine which style will

00:21:29,039 --> 00:21:34,080
take effect when your code is compiled

00:21:31,679 --> 00:21:36,559
with ivy the most specific style will

00:21:34,080 --> 00:21:39,760
always have the highest precedence

00:21:36,559 --> 00:21:42,559
for example binding the color of the

00:21:39,760 --> 00:21:44,559
element through the style.color property

00:21:42,559 --> 00:21:47,200
will override a conflicting binding to

00:21:44,559 --> 00:21:49,360
the style property

00:21:47,200 --> 00:21:51,520
another nice little change that was

00:21:49,360 --> 00:21:54,320
included is the ability to now use

00:21:51,520 --> 00:21:56,799
css variables inside of your html

00:21:54,320 --> 00:21:58,400
templates

00:21:56,799 --> 00:22:00,240
you can see from this code snippet that

00:21:58,400 --> 00:22:03,039
we're setting our css variable

00:22:00,240 --> 00:22:04,080
inside of the div and then using that

00:22:03,039 --> 00:22:12,640
variable inside

00:22:04,080 --> 00:22:15,600
of the the paragraph element down below

00:22:12,640 --> 00:22:16,640
like how typescript catches type errors

00:22:15,600 --> 00:22:18,480
in your code

00:22:16,640 --> 00:22:19,679
angular checks the expressions and

00:22:18,480 --> 00:22:22,000
bindings within your

00:22:19,679 --> 00:22:24,480
application templates and can report any

00:22:22,000 --> 00:22:26,880
type errors that it finds

00:22:24,480 --> 00:22:28,960
the move from the view engine to ivy the

00:22:26,880 --> 00:22:31,600
angular team has made some improvements

00:22:28,960 --> 00:22:33,760
to allow for easier error detection with

00:22:31,600 --> 00:22:35,840
the full template type check setting

00:22:33,760 --> 00:22:38,559
as well as adding a new setting the

00:22:35,840 --> 00:22:40,880
strict template setting

00:22:38,559 --> 00:22:42,400
now before we get into any new changes

00:22:40,880 --> 00:22:44,480
for type checking in iv

00:22:42,400 --> 00:22:47,600
we'll do a quick review of uh template

00:22:44,480 --> 00:22:49,840
type checking in angular 8.

00:22:47,600 --> 00:22:52,880
so the the following component here will

00:22:49,840 --> 00:22:54,559
display a list of countries for us

00:22:52,880 --> 00:22:57,000
as you can see here in the first

00:22:54,559 --> 00:23:00,080
screenshot it's our uh

00:22:57,000 --> 00:23:02,240
component.typescript file we have a

00:23:00,080 --> 00:23:05,679
list of countries here we also have a

00:23:02,240 --> 00:23:07,919
title that is currently commented out

00:23:05,679 --> 00:23:08,880
inside of our html you can see that we

00:23:07,919 --> 00:23:12,080
are trying to

00:23:08,880 --> 00:23:13,440
call the title and we also are using the

00:23:12,080 --> 00:23:15,600
incorrect variable name for the

00:23:13,440 --> 00:23:16,000
country.code properties you can see the

00:23:15,600 --> 00:23:19,600
c

00:23:16,000 --> 00:23:23,200
is capitalized instead of lowercase

00:23:19,600 --> 00:23:26,240
now we're also setting a

00:23:23,200 --> 00:23:27,120
we are also setting the uh full template

00:23:26,240 --> 00:23:29,480
type check

00:23:27,120 --> 00:23:32,799
which uh you can do inside of the

00:23:29,480 --> 00:23:32,799
tsconfig.json file

00:23:32,960 --> 00:23:36,480
now once this is done we'll do run an ng

00:23:35,919 --> 00:23:38,799
build

00:23:36,480 --> 00:23:40,960
and everything will compile successfully

00:23:38,799 --> 00:23:44,000
and we'll even get some output here

00:23:40,960 --> 00:23:46,320
but there will be some issues so

00:23:44,000 --> 00:23:48,159
as you can see here this list is the

00:23:46,320 --> 00:23:50,080
output of our application

00:23:48,159 --> 00:23:52,080
as you can see that it's missing both

00:23:50,080 --> 00:23:53,760
the uh the country codes

00:23:52,080 --> 00:23:56,480
as well as the title that we wanted to

00:23:53,760 --> 00:24:00,320
include above it

00:23:56,480 --> 00:24:01,919
now will uh we run into an issue when

00:24:00,320 --> 00:24:04,240
trying to build this application

00:24:01,919 --> 00:24:06,480
while using aot or ahead of time

00:24:04,240 --> 00:24:09,279
compilation by running the ng build

00:24:06,480 --> 00:24:09,760
prod command we run this command you'll

00:24:09,279 --> 00:24:12,080
see

00:24:09,760 --> 00:24:14,640
the following error which you can see on

00:24:12,080 --> 00:24:14,640
the screen here

00:24:15,919 --> 00:24:20,000
when both aot and the full template type

00:24:18,960 --> 00:24:22,880
check properties

00:24:20,000 --> 00:24:24,559
are set to when with aot enabled and

00:24:22,880 --> 00:24:25,840
with full template type check property

00:24:24,559 --> 00:24:27,200
set to true

00:24:25,840 --> 00:24:29,039
angular can detect when we make

00:24:27,200 --> 00:24:31,679
references to a model that's missing

00:24:29,039 --> 00:24:33,200
from our component

00:24:31,679 --> 00:24:34,880
now when the full template type check

00:24:33,200 --> 00:24:37,360
property is set to true

00:24:34,880 --> 00:24:38,640
and we're using aot compilation angular

00:24:37,360 --> 00:24:41,679
is a lot more aggressive

00:24:38,640 --> 00:24:44,320
in its type checking within templates

00:24:41,679 --> 00:24:45,200
embedded views such as those within ng4

00:24:44,320 --> 00:24:47,600
and ngif

00:24:45,200 --> 00:24:49,919
are checked pipes are checked to make

00:24:47,600 --> 00:24:51,919
sure they have the correct return type

00:24:49,919 --> 00:24:53,600
and local references to directives and

00:24:51,919 --> 00:24:54,799
pipes are checked to make sure they have

00:24:53,600 --> 00:24:56,640
the correct type

00:24:54,799 --> 00:25:00,240
except for any generic parameters they

00:24:56,640 --> 00:25:02,320
may have

00:25:00,240 --> 00:25:03,919
now we'll take a a look at how id

00:25:02,320 --> 00:25:04,880
handles type checking when building a

00:25:03,919 --> 00:25:06,960
project

00:25:04,880 --> 00:25:09,360
while using iv we'll navigate back to

00:25:06,960 --> 00:25:11,360
the tsconfig.json file and make sure

00:25:09,360 --> 00:25:12,320
that full template type check is set to

00:25:11,360 --> 00:25:14,480
true

00:25:12,320 --> 00:25:17,120
now when we run the application using

00:25:14,480 --> 00:25:18,559
just ng build not ng build prod

00:25:17,120 --> 00:25:20,320
we'll see a similar error to the one

00:25:18,559 --> 00:25:21,600
that we had seen previously with the

00:25:20,320 --> 00:25:22,960
production build

00:25:21,600 --> 00:25:24,880
as you can see here it's saying the

00:25:22,960 --> 00:25:26,080
property title does not exist on type

00:25:24,880 --> 00:25:27,679
app component

00:25:26,080 --> 00:25:29,279
it's also giving us a little bit more

00:25:27,679 --> 00:25:31,360
information it's telling us

00:25:29,279 --> 00:25:35,039
what file that error is occurring in

00:25:31,360 --> 00:25:38,240
which is the app.component.html file

00:25:35,039 --> 00:25:39,760
and it's also telling us that the title

00:25:38,240 --> 00:25:42,159
is what's causing the error there's no

00:25:39,760 --> 00:25:44,640
title property inside of the

00:25:42,159 --> 00:25:47,279
typescript uh it does not exist on type

00:25:44,640 --> 00:25:47,279
app component

00:25:47,440 --> 00:25:51,679
number if you remember iv uses aot by

00:25:50,720 --> 00:25:53,120
default

00:25:51,679 --> 00:25:54,880
so we're going to be seeing these errors

00:25:53,120 --> 00:25:56,080
without having to specify a production

00:25:54,880 --> 00:25:58,000
build

00:25:56,080 --> 00:26:00,000
because of the change in aot being

00:25:58,000 --> 00:26:01,440
utilized in all forms of the build

00:26:00,000 --> 00:26:03,440
developers will now be able to catch

00:26:01,440 --> 00:26:07,039
these template type checking errors

00:26:03,440 --> 00:26:10,159
sooner rather than later if you go back

00:26:07,039 --> 00:26:13,200
into your app.component.ts file

00:26:10,159 --> 00:26:16,000
we'll uh we'll fix that that misspelled

00:26:13,200 --> 00:26:18,480
code and we'll also add back our title

00:26:16,000 --> 00:26:20,159
and we'll uncomment that out and uh if

00:26:18,480 --> 00:26:22,000
we rerun it

00:26:20,159 --> 00:26:23,600
we'll see the following output in

00:26:22,000 --> 00:26:26,640
angular 9.

00:26:23,600 --> 00:26:29,120
or with angular ib sorry you can see

00:26:26,640 --> 00:26:30,000
the title countries angular iv and then

00:26:29,120 --> 00:26:34,240
it includes both

00:26:30,000 --> 00:26:34,240
the codes as well as the country names

00:26:35,679 --> 00:26:39,919
now we'll take a quick look at the new

00:26:38,000 --> 00:26:41,760
setting added to allow for more type

00:26:39,919 --> 00:26:44,240
checking in ivy which is

00:26:41,760 --> 00:26:47,039
strict mode with the strength strict

00:26:44,240 --> 00:26:49,919
template setting

00:26:47,039 --> 00:26:52,159
strict mode is a superset of full mode

00:26:49,919 --> 00:26:53,360
and can be used by setting the strict

00:26:52,159 --> 00:26:56,559
template setting to

00:26:53,360 --> 00:26:58,880
true now in strict mode iv

00:26:56,559 --> 00:26:59,840
adds checks that go beyond those in full

00:26:58,880 --> 00:27:02,799
mode which is

00:26:59,840 --> 00:27:04,400
set with the full template mode

00:27:02,799 --> 00:27:06,880
including

00:27:04,400 --> 00:27:10,559
verifying that components and directive

00:27:06,880 --> 00:27:12,960
bindings are assignable to their inputs

00:27:10,559 --> 00:27:15,760
uh obeying typescripts strict null

00:27:12,960 --> 00:27:17,679
checks flags when validating the above

00:27:15,760 --> 00:27:20,640
infers the correct type of components

00:27:17,679 --> 00:27:22,880
and directives including generics

00:27:20,640 --> 00:27:23,919
infers template context types where

00:27:22,880 --> 00:27:25,840
configured

00:27:23,919 --> 00:27:28,960
for example allowing correct type

00:27:25,840 --> 00:27:31,200
checking for ng4 loops

00:27:28,960 --> 00:27:32,720
infers the correct type of event in

00:27:31,200 --> 00:27:36,159
components and directives

00:27:32,720 --> 00:27:38,000
dom and animation event binding bindings

00:27:36,159 --> 00:27:39,760
and infers the correct type of local

00:27:38,000 --> 00:27:43,039
references to dom elements

00:27:39,760 --> 00:27:43,039
based on the tag's name

00:27:43,679 --> 00:27:47,919
now to enable strict mode first you'll

00:27:45,600 --> 00:27:49,120
need to go back to the tsconfig.json

00:27:47,919 --> 00:27:50,720
file

00:27:49,120 --> 00:27:52,559
where we had the full template type

00:27:50,720 --> 00:27:55,600
checking you want to replace

00:27:52,559 --> 00:27:58,240
that with the strip template setting

00:27:55,600 --> 00:27:58,960
and set that to true and that will

00:27:58,240 --> 00:28:01,120
enable

00:27:58,960 --> 00:28:04,480
the that will enable strict mode when

00:28:01,120 --> 00:28:04,480
you're building your applications

00:28:07,360 --> 00:28:11,679
the iv compiler also makes improvements

00:28:10,080 --> 00:28:14,840
on internationalization

00:28:11,679 --> 00:28:17,360
and localizing your applications

00:28:14,840 --> 00:28:19,279
internationalization is the process of

00:28:17,360 --> 00:28:22,240
designing and preparing your app

00:28:19,279 --> 00:28:24,000
to be usable in different languages

00:28:22,240 --> 00:28:26,159
localization is the process of

00:28:24,000 --> 00:28:27,600
translating your internationalized app

00:28:26,159 --> 00:28:31,360
into specific languages

00:28:27,600 --> 00:28:33,039
for particular locales

00:28:31,360 --> 00:28:34,559
to mark items that you want to add

00:28:33,039 --> 00:28:36,799
localizable messages to

00:28:34,559 --> 00:28:38,640
you'll need to include the i18n

00:28:36,799 --> 00:28:39,919
attribute on these elements like you can

00:28:38,640 --> 00:28:43,120
see here in this

00:28:39,919 --> 00:28:45,440
little hello world snippet

00:28:43,120 --> 00:28:47,600
the angular compiler will replace this

00:28:45,440 --> 00:28:48,559
text when compiling the template with

00:28:47,600 --> 00:28:50,720
different text

00:28:48,559 --> 00:28:53,120
if a set of translations was provided in

00:28:50,720 --> 00:28:56,000
the compiler configuration

00:28:53,120 --> 00:28:57,919
these i18n tags are very powerful they

00:28:56,000 --> 00:28:58,480
can be used in attributes as well as

00:28:57,919 --> 00:29:00,720
content

00:28:58,480 --> 00:29:02,880
and they can be included in complex

00:29:00,720 --> 00:29:04,720
nested icu expressions

00:29:02,880 --> 00:29:06,399
as well as have metadata attached to

00:29:04,720 --> 00:29:08,159
them

00:29:06,399 --> 00:29:09,840
however there were a few issues that

00:29:08,159 --> 00:29:11,520
arose with the localization

00:29:09,840 --> 00:29:13,520
in internationalization in the view

00:29:11,520 --> 00:29:15,360
engine the most significant

00:29:13,520 --> 00:29:17,440
concern was that translation had to

00:29:15,360 --> 00:29:18,960
happen during template compilation

00:29:17,440 --> 00:29:20,480
which occurs right at the start of the

00:29:18,960 --> 00:29:22,480
build pipeline

00:29:20,480 --> 00:29:24,240
the result of this is that the full

00:29:22,480 --> 00:29:27,279
build compilation

00:29:24,240 --> 00:29:28,960
bundling minification etc had to happen

00:29:27,279 --> 00:29:31,120
for each locale that you wanted to

00:29:28,960 --> 00:29:33,120
support in your application

00:29:31,120 --> 00:29:34,320
so if a single build took say for

00:29:33,120 --> 00:29:38,080
example three minutes

00:29:34,320 --> 00:29:39,600
and the total build time was uh

00:29:38,080 --> 00:29:41,120
or you wanted to support say a dozen

00:29:39,600 --> 00:29:44,640
languages that would be over

00:29:41,120 --> 00:29:46,559
30 minutes to do all of those builds

00:29:44,640 --> 00:29:49,440
moreover it was not possible to mark

00:29:46,559 --> 00:29:52,399
text in application code for translation

00:29:49,440 --> 00:29:54,640
only text in component templates this

00:29:52,399 --> 00:29:56,000
resulted in some weird workarounds where

00:29:54,640 --> 00:29:58,399
developers would create

00:29:56,000 --> 00:29:59,679
uh artificial components that existed

00:29:58,399 --> 00:30:01,520
solely to

00:29:59,679 --> 00:30:03,600
hold text that would later be used to be

00:30:01,520 --> 00:30:06,240
translated

00:30:03,600 --> 00:30:06,640
and then finally it was not possible to

00:30:06,240 --> 00:30:08,640
load

00:30:06,640 --> 00:30:10,320
translations at runtime which meant that

00:30:08,640 --> 00:30:11,200
it wasn't possible for applications to

00:30:10,320 --> 00:30:13,200
be provided

00:30:11,200 --> 00:30:16,399
to an end user who might want to provide

00:30:13,200 --> 00:30:16,399
translations of their own

00:30:16,480 --> 00:30:19,600
the iv compiler has been redesigned to

00:30:18,960 --> 00:30:22,320
generate

00:30:19,600 --> 00:30:24,640
a localized tagged string rather than

00:30:22,320 --> 00:30:26,399
doing the translations itself

00:30:24,640 --> 00:30:28,240
this means that after the angular

00:30:26,399 --> 00:30:30,240
compiler has completed its work

00:30:28,240 --> 00:30:31,679
all the template text that's been marked

00:30:30,240 --> 00:30:33,679
with the i18n

00:30:31,679 --> 00:30:35,360
attributes have been converted to

00:30:33,679 --> 00:30:37,200
localized tagged strings

00:30:35,360 --> 00:30:40,320
which then can be processed just like

00:30:37,200 --> 00:30:40,320
any other tag string

00:30:43,440 --> 00:30:47,279
now if you're using angular 9 or a later

00:30:46,159 --> 00:30:50,080
version of angular

00:30:47,279 --> 00:30:51,200
your project will have an iv enabled by

00:30:50,080 --> 00:30:53,679
default

00:30:51,200 --> 00:30:54,720
if you're currently working in angular 8

00:30:53,679 --> 00:30:56,960
you're currently

00:30:54,720 --> 00:30:58,320
using the view engine which is enabled

00:30:56,960 --> 00:31:01,600
by default unless

00:30:58,320 --> 00:31:03,200
you've decided to enable the ib compiler

00:31:01,600 --> 00:31:05,200
though it is recommended that you

00:31:03,200 --> 00:31:06,320
upgrade to a newer version of angular if

00:31:05,200 --> 00:31:08,720
you intend to use

00:31:06,320 --> 00:31:10,720
ib this will let you get the most

00:31:08,720 --> 00:31:12,159
up-to-date features and fixes that the

00:31:10,720 --> 00:31:14,720
angular team has released for the

00:31:12,159 --> 00:31:17,120
compiler

00:31:14,720 --> 00:31:18,960
if you're upgrading an already existing

00:31:17,120 --> 00:31:20,960
application to use ivy

00:31:18,960 --> 00:31:22,799
the angular team has done their best to

00:31:20,960 --> 00:31:24,640
make it so the developers will have to

00:31:22,799 --> 00:31:26,240
do the minimal amount of work

00:31:24,640 --> 00:31:28,559
to get their application running with

00:31:26,240 --> 00:31:30,799
ivy but there still may be

00:31:28,559 --> 00:31:32,559
a few changes that developers will have

00:31:30,799 --> 00:31:34,960
to make

00:31:32,559 --> 00:31:36,559
now if you're seeing errors while using

00:31:34,960 --> 00:31:38,799
iv in angular 8

00:31:36,559 --> 00:31:40,480
the first thing that you want to do is

00:31:38,799 --> 00:31:43,120
turn off iv

00:31:40,480 --> 00:31:43,840
this can be done in the tsconfig.json

00:31:43,120 --> 00:31:46,159
file

00:31:43,840 --> 00:31:48,320
underneath the angular compiler option

00:31:46,159 --> 00:31:51,440
setting as you can see here

00:31:48,320 --> 00:31:53,039
this is how you would enable iv in an

00:31:51,440 --> 00:31:55,200
angular 8 application

00:31:53,039 --> 00:31:56,559
if you want to disable iv you'll just

00:31:55,200 --> 00:31:59,200
set enable iv to

00:31:56,559 --> 00:32:00,000
false now like i said if you're seeing

00:31:59,200 --> 00:32:01,840
errors while you're

00:32:00,000 --> 00:32:03,840
using iv the first thing you want to do

00:32:01,840 --> 00:32:07,279
is turn id off

00:32:03,840 --> 00:32:10,720
uh then you want to try running it again

00:32:07,279 --> 00:32:13,039
if you are still seeing errors

00:32:10,720 --> 00:32:14,080
then you know that this isn't iv related

00:32:13,039 --> 00:32:15,600
if your application

00:32:14,080 --> 00:32:17,039
runs perfectly fine then you'll know

00:32:15,600 --> 00:32:17,440
that you're probably running into some

00:32:17,039 --> 00:32:20,640
iv

00:32:17,440 --> 00:32:23,760
related issues now some of these

00:32:20,640 --> 00:32:27,919
uh more common issues that you may see

00:32:23,760 --> 00:32:30,000
include uh the following so by default

00:32:27,919 --> 00:32:31,600
at content children queries will only

00:32:30,000 --> 00:32:34,720
search direct child nodes

00:32:31,600 --> 00:32:35,360
in the dom hierarchy previously they

00:32:34,720 --> 00:32:37,760
would search

00:32:35,360 --> 00:32:39,120
any nesting level in the dom as long as

00:32:37,760 --> 00:32:42,960
another directive wasn't

00:32:39,120 --> 00:32:45,120
matched above it classes that use

00:32:42,960 --> 00:32:47,120
angular di must have an angular

00:32:45,120 --> 00:32:50,559
decorator like at directive

00:32:47,120 --> 00:32:52,320
or at injectable previously undecorated

00:32:50,559 --> 00:32:55,919
classes were allowed in aot

00:32:52,320 --> 00:32:57,840
mode only if only if injection flags

00:32:55,919 --> 00:33:00,640
were used

00:32:57,840 --> 00:33:00,960
um unbound inputs for directives are now

00:33:00,640 --> 00:33:03,519
set

00:33:00,960 --> 00:33:05,519
upon creation of the view before change

00:33:03,519 --> 00:33:08,640
detection runs

00:33:05,519 --> 00:33:10,559
and uh static attributes set directly in

00:33:08,640 --> 00:33:12,559
the html of a template

00:33:10,559 --> 00:33:14,880
will override any conflicting host

00:33:12,559 --> 00:33:17,440
attributes set by directives or

00:33:14,880 --> 00:33:20,399
components

00:33:17,440 --> 00:33:22,480
now there's also a handful of less

00:33:20,399 --> 00:33:24,320
common changes as you can see here the

00:33:22,480 --> 00:33:27,120
developers may need to make

00:33:24,320 --> 00:33:27,679
um these ones are a lot rarer than the

00:33:27,120 --> 00:33:29,360
the

00:33:27,679 --> 00:33:32,320
initial four that i had outlined so we

00:33:29,360 --> 00:33:35,120
won't go over these uh in detail but um

00:33:32,320 --> 00:33:36,320
i will make the uh the slideshow

00:33:35,120 --> 00:33:38,720
available afterwards

00:33:36,320 --> 00:33:40,000
after the webinar is complete so that if

00:33:38,720 --> 00:33:42,720
you would like to take a look at all of

00:33:40,000 --> 00:33:42,720
these you can

00:33:44,159 --> 00:33:48,960
uh now we'll go over building and

00:33:45,760 --> 00:33:51,039
consuming libraries with ivy

00:33:48,960 --> 00:33:52,559
so with the change from the view engine

00:33:51,039 --> 00:33:55,039
compiler to the iv

00:33:52,559 --> 00:33:57,519
compiler developers may wonder if they

00:33:55,039 --> 00:34:00,159
need to continue

00:33:57,519 --> 00:34:02,880
if they will continue to be able to use

00:34:00,159 --> 00:34:04,960
libraries built in the view engine

00:34:02,880 --> 00:34:07,600
thankfully the angular team has created

00:34:04,960 --> 00:34:11,200
the iv compatibility compiler

00:34:07,600 --> 00:34:12,480
or ngcc to allow us to use libraries

00:34:11,200 --> 00:34:15,599
built in the view engine

00:34:12,480 --> 00:34:17,760
with the iv compiler

00:34:15,599 --> 00:34:20,000
now the compatibility compiler parses

00:34:17,760 --> 00:34:20,879
the pre-compiled javascript code that

00:34:20,000 --> 00:34:24,000
gets produced

00:34:20,879 --> 00:34:24,560
by the view engine compiler it then goes

00:34:24,000 --> 00:34:26,879
through

00:34:24,560 --> 00:34:27,760
and updates this code as though it had

00:34:26,879 --> 00:34:31,520
been compiled

00:34:27,760 --> 00:34:33,280
by the iv compiler so if you're using

00:34:31,520 --> 00:34:34,320
libraries built within the view engine

00:34:33,280 --> 00:34:36,560
but you're using

00:34:34,320 --> 00:34:38,800
iv you will need to use the

00:34:36,560 --> 00:34:41,240
compatibility compiler

00:34:38,800 --> 00:34:42,879
to do so inside of your projects

00:34:41,240 --> 00:34:45,359
package.json file

00:34:42,879 --> 00:34:46,000
you'll want to add a post install npm

00:34:45,359 --> 00:34:48,079
script

00:34:46,000 --> 00:34:49,679
so as you can see here the post install

00:34:48,079 --> 00:34:51,839
and gcc

00:34:49,679 --> 00:34:53,119
this script will run on every

00:34:51,839 --> 00:34:55,440
installation of

00:34:53,119 --> 00:34:56,240
node modules including those performed

00:34:55,440 --> 00:35:00,079
by ng

00:34:56,240 --> 00:35:02,240
update as well as ng and

00:35:00,079 --> 00:35:03,839
now the compatibility compiler works by

00:35:02,240 --> 00:35:06,880
scanning the

00:35:03,839 --> 00:35:09,119
node modules folder folder for packages

00:35:06,880 --> 00:35:14,240
that are in angular package format or

00:35:09,119 --> 00:35:16,240
apf by checking the metadata.json files

00:35:14,240 --> 00:35:18,800
the compatibility compiler will then

00:35:16,240 --> 00:35:21,200
produce iv compatible versions for each

00:35:18,800 --> 00:35:24,079
of these packages

00:35:21,200 --> 00:35:24,320
so if you are a library author or you

00:35:24,079 --> 00:35:26,320
are

00:35:24,320 --> 00:35:27,440
supporting any angular libraries that

00:35:26,320 --> 00:35:29,520
people are using

00:35:27,440 --> 00:35:31,359
the angular team still recommends

00:35:29,520 --> 00:35:32,560
building your libraries with the view

00:35:31,359 --> 00:35:36,000
engine compiler

00:35:32,560 --> 00:35:37,839
over the ib compiler the reason for this

00:35:36,000 --> 00:35:39,359
is that iv generated code isn't

00:35:37,839 --> 00:35:40,160
backwards compatible with the view

00:35:39,359 --> 00:35:41,760
engine

00:35:40,160 --> 00:35:43,200
so apps that are using the view engine

00:35:41,760 --> 00:35:45,200
won't be able to make use of them

00:35:43,200 --> 00:35:47,200
so if you really say an update that's

00:35:45,200 --> 00:35:49,440
built only in ivy

00:35:47,200 --> 00:35:50,880
if you have any any users who are on

00:35:49,440 --> 00:35:52,480
build engine

00:35:50,880 --> 00:35:54,960
they won't be able to make use of that

00:35:52,480 --> 00:35:57,680
newest build

00:35:54,960 --> 00:35:58,079
furthermore the iv instructions are not

00:35:57,680 --> 00:35:59,920
yet

00:35:58,079 --> 00:36:01,839
the internal iv instructions are not yet

00:35:59,920 --> 00:36:03,680
stable which can potentially break

00:36:01,839 --> 00:36:05,040
applications that are using different

00:36:03,680 --> 00:36:08,000
versions of angular

00:36:05,040 --> 00:36:09,760
than the one used to build the library

00:36:08,000 --> 00:36:13,119
so this means that uh if

00:36:09,760 --> 00:36:14,560
say you've built a uh your your library

00:36:13,119 --> 00:36:16,960
on a different version of iv

00:36:14,560 --> 00:36:19,760
than than what your users are using that

00:36:16,960 --> 00:36:21,839
may cause issues with your library

00:36:19,760 --> 00:36:22,800
so what the iv team recommends is to

00:36:21,839 --> 00:36:25,040
just let the

00:36:22,800 --> 00:36:27,040
angular cli use the compatibility

00:36:25,040 --> 00:36:29,760
compiler to convert your view engine

00:36:27,040 --> 00:36:31,280
generated code into iv compatible code

00:36:29,760 --> 00:36:34,160
currently there's no need to

00:36:31,280 --> 00:36:36,800
rewrite your your libraries inside of

00:36:34,160 --> 00:36:36,800
angular ib

00:36:37,760 --> 00:36:41,599
and that is comes to the end of the uh

00:36:40,560 --> 00:36:43,920
the webinar

00:36:41,599 --> 00:36:44,640
um the that covers all of the major

00:36:43,920 --> 00:36:46,640
changes

00:36:44,640 --> 00:36:48,400
that the angular team has been able to

00:36:46,640 --> 00:36:49,200
make with uh switching over from the

00:36:48,400 --> 00:36:52,560
view engine

00:36:49,200 --> 00:36:54,240
compiler to the iv compiler i know that

00:36:52,560 --> 00:36:56,720
we've kind of covered a lot

00:36:54,240 --> 00:36:57,839
in this presentation so i'd just like to

00:36:56,720 --> 00:37:00,320
do a quick rehash

00:36:57,839 --> 00:37:02,640
of the uh the two biggest changes and

00:37:00,320 --> 00:37:03,920
reasons for switching over to the ib

00:37:02,640 --> 00:37:06,079
compiler

00:37:03,920 --> 00:37:07,440
uh the first one being uh improved

00:37:06,079 --> 00:37:09,359
bundling

00:37:07,440 --> 00:37:12,000
ivy's changed how it handles rendering

00:37:09,359 --> 00:37:14,560
versus how the view engine handles it

00:37:12,000 --> 00:37:17,040
um the view engine created uh template

00:37:14,560 --> 00:37:17,520
data from template html which it then

00:37:17,040 --> 00:37:20,320
used

00:37:17,520 --> 00:37:22,160
the um the uh into the angular

00:37:20,320 --> 00:37:23,839
interpreter to translate that over to

00:37:22,160 --> 00:37:25,760
the dom

00:37:23,839 --> 00:37:27,359
ivy has gotten rid of the interpreter

00:37:25,760 --> 00:37:29,680
and that template data and now we just

00:37:27,359 --> 00:37:32,880
use template instructions to convert our

00:37:29,680 --> 00:37:34,960
template html over into our dom

00:37:32,880 --> 00:37:36,480
and the second is the improved build

00:37:34,960 --> 00:37:38,720
times

00:37:36,480 --> 00:37:40,560
now that the angular team is making use

00:37:38,720 --> 00:37:43,760
of the principle of locality when

00:37:40,560 --> 00:37:43,760
building applications

00:37:43,920 --> 00:37:48,240
we are seeing improved build times the

00:37:46,880 --> 00:37:49,920
principle of locality

00:37:48,240 --> 00:37:51,599
means that in order to compile a

00:37:49,920 --> 00:37:53,599
component in ivy

00:37:51,599 --> 00:37:56,000
angular only needs information about

00:37:53,599 --> 00:37:57,920
that component itself

00:37:56,000 --> 00:37:59,599
that component itself except for the

00:37:57,920 --> 00:38:02,480
name and package name of its

00:37:59,599 --> 00:38:04,400
declarable dependencies ivy doesn't need

00:38:02,480 --> 00:38:06,240
any of the metadata of those declarable

00:38:04,400 --> 00:38:08,400
dependencies to compile a component

00:38:06,240 --> 00:38:10,400
which has made aot compilation much

00:38:08,400 --> 00:38:13,040
faster and the default

00:38:10,400 --> 00:38:15,520
compilation method for both dev and

00:38:13,040 --> 00:38:17,280
production mode

00:38:15,520 --> 00:38:19,040
so we've seen there are some small

00:38:17,280 --> 00:38:20,720
changes that developers will need to

00:38:19,040 --> 00:38:22,400
make

00:38:20,720 --> 00:38:24,800
in that process of upgrading from the

00:38:22,400 --> 00:38:27,200
view engine compiler to ivy

00:38:24,800 --> 00:38:29,280
but outside of any potential changes the

00:38:27,200 --> 00:38:31,119
change done to ivy is done in a way that

00:38:29,280 --> 00:38:32,079
we as developers won't need to change

00:38:31,119 --> 00:38:34,320
the base way

00:38:32,079 --> 00:38:36,320
that we write our applications which

00:38:34,320 --> 00:38:37,839
gives us all the benefits of the changes

00:38:36,320 --> 00:38:40,320
that the angular team has made on the

00:38:37,839 --> 00:38:40,320
back end

00:38:40,880 --> 00:38:45,440
right that's it for the my presentation

00:38:44,079 --> 00:38:56,880
here

00:38:45,440 --> 00:38:56,880

YouTube URL: https://www.youtube.com/watch?v=HRv7gKm9Q-8


