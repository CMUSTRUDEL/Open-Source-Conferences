Title: Functional Reactive JavaScript- Let's stop the Conversational Remorse! - Anas Raza Firdousi
Publication date: 2016-05-04
Playlist: ng-conf 2016
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:04,100 --> 00:00:09,840
thank you so much Joe so the moment I

00:00:07,740 --> 00:00:12,360
came to know that I'm talking after Shai

00:00:09,840 --> 00:00:15,030
Resnick I thought let's not talk about

00:00:12,360 --> 00:00:17,910
angular right because angular doesn't

00:00:15,030 --> 00:00:19,789
make more sense after his shock so let's

00:00:17,910 --> 00:00:23,250
talk about functional reactive

00:00:19,789 --> 00:00:25,590
JavaScript okay this is a heads up this

00:00:23,250 --> 00:00:28,260
is a twenty Albert talk cut down to

00:00:25,590 --> 00:00:29,609
twenty minutes and it all started one

00:00:28,260 --> 00:00:31,410
day at work when I was talking to a

00:00:29,609 --> 00:00:33,750
friend of mine and he came up with this

00:00:31,410 --> 00:00:35,309
simple little question what the heck is

00:00:33,750 --> 00:00:36,329
this buzzword functional reactive

00:00:35,309 --> 00:00:39,870
programming

00:00:36,329 --> 00:00:42,930
I felt blank because I couldn't give him

00:00:39,870 --> 00:00:44,850
a good answer have you ever been in a

00:00:42,930 --> 00:00:47,520
situation where you have to explain

00:00:44,850 --> 00:00:51,480
functional reactive programming to a

00:00:47,520 --> 00:00:53,309
mere civilian I don't know what you told

00:00:51,480 --> 00:00:55,379
them but this is what I told them so

00:00:53,309 --> 00:00:59,160
it's a way to get your talks accepted at

00:00:55,379 --> 00:01:00,930
conferences that's I'm here and it's the

00:00:59,160 --> 00:01:02,899
most recent major hours trip developers

00:01:00,930 --> 00:01:04,170
have invented to impress their peers

00:01:02,899 --> 00:01:06,090
hello

00:01:04,170 --> 00:01:07,530
as he said my name is an asteroid Ozzie

00:01:06,090 --> 00:01:09,570
and I'm originally from a country in

00:01:07,530 --> 00:01:11,880
this background called Pakistan I'm a

00:01:09,570 --> 00:01:14,040
senior software architect at PayPal I

00:01:11,880 --> 00:01:16,080
also run the ng Pakistan community and

00:01:14,040 --> 00:01:18,060
we are glad they're having a ng-conf

00:01:16,080 --> 00:01:21,090
extended there so hello to everybody

00:01:18,060 --> 00:01:23,610
there and I've been doing JavaScript for

00:01:21,090 --> 00:01:25,530
about 12 years now and doing some

00:01:23,610 --> 00:01:28,020
angular production apps these days for a

00:01:25,530 --> 00:01:29,610
few months but that's not important here

00:01:28,020 --> 00:01:31,740
what's important is functional

00:01:29,610 --> 00:01:33,270
programming let's cut this wiki

00:01:31,740 --> 00:01:36,600
definition down to a few points you can

00:01:33,270 --> 00:01:39,960
remember so program like you're doing

00:01:36,600 --> 00:01:42,150
maths a wide mutating things they're out

00:01:39,960 --> 00:01:42,750
of your scope and you gotta be

00:01:42,150 --> 00:01:44,460
decorative

00:01:42,750 --> 00:01:47,220
that is to say you've got to write more

00:01:44,460 --> 00:01:48,869
expressive code so in the functional

00:01:47,220 --> 00:01:51,180
part I've got five things that I would

00:01:48,869 --> 00:01:53,549
like to talk to you about today starting

00:01:51,180 --> 00:01:55,439
with separation but just before that

00:01:53,549 --> 00:01:58,110
here's the ng-conf blog we'll be

00:01:55,439 --> 00:02:00,719
creating today so we have a list of post

00:01:58,110 --> 00:02:03,119
each with a teaser text we have been

00:02:00,719 --> 00:02:06,090
able to use a logged in any resemblance

00:02:03,119 --> 00:02:08,580
to our Jeff cross is accidental and we

00:02:06,090 --> 00:02:10,770
have the admin report button which

00:02:08,580 --> 00:02:13,050
actually tells how the report how the

00:02:10,770 --> 00:02:13,380
blog is doing so when I click on this

00:02:13,050 --> 00:02:16,410
egg

00:02:13,380 --> 00:02:18,240
secur report button this function gets

00:02:16,410 --> 00:02:20,940
executed so this assumption accepts a

00:02:18,240 --> 00:02:23,430
URL as an input and then executes the

00:02:20,940 --> 00:02:25,500
report I want you to focus only on this

00:02:23,430 --> 00:02:27,600
part of the function you'd like to

00:02:25,500 --> 00:02:29,990
separate functions from things it is

00:02:27,600 --> 00:02:32,220
acting upon like random ghost inputs

00:02:29,990 --> 00:02:34,560
because if I look at the signature of

00:02:32,220 --> 00:02:38,670
the function I don't see that it depends

00:02:34,560 --> 00:02:41,310
on window dot location or date how do

00:02:38,670 --> 00:02:43,560
you test this function and pour them to

00:02:41,310 --> 00:02:44,880
an environment other than a browser so

00:02:43,560 --> 00:02:47,460
you always have to walk through the

00:02:44,880 --> 00:02:49,860
ghost inputs so what you do is you set

00:02:47,460 --> 00:02:51,180
the inputs outside the function and

00:02:49,860 --> 00:02:53,610
depending upon the environment you're

00:02:51,180 --> 00:02:55,620
running in and then pass them along to

00:02:53,610 --> 00:02:58,260
your functions now your function

00:02:55,620 --> 00:03:00,870
signature explicitly explains what it

00:02:58,260 --> 00:03:02,730
knew what it needs to do what it does so

00:03:00,870 --> 00:03:05,790
that's the first type of separation we

00:03:02,730 --> 00:03:07,200
separate functions from environments now

00:03:05,790 --> 00:03:09,320
remember the teaser text said we had

00:03:07,200 --> 00:03:11,610
these Caesar texts can help us

00:03:09,320 --> 00:03:13,170
understand the second type of separation

00:03:11,610 --> 00:03:15,480
that is between mutations and

00:03:13,170 --> 00:03:18,300
calculations so how do we generate these

00:03:15,480 --> 00:03:20,400
teasers here's a teaser function now

00:03:18,300 --> 00:03:23,150
let's try to separate mutations from

00:03:20,400 --> 00:03:26,220
calculations or at least try to isolate

00:03:23,150 --> 00:03:27,120
mutations because those are the trickier

00:03:26,220 --> 00:03:29,100
parts to reason about

00:03:27,120 --> 00:03:31,950
because the order in which you do things

00:03:29,100 --> 00:03:33,930
matter so here I'm grabbing all the

00:03:31,950 --> 00:03:35,790
paragraphs within the block class and

00:03:33,930 --> 00:03:38,700
passing them to the teaser function one

00:03:35,790 --> 00:03:40,740
by one by using the map function so the

00:03:38,700 --> 00:03:44,700
idea is to first do all types of

00:03:40,740 --> 00:03:46,260
calculations and calculations which are

00:03:44,700 --> 00:03:49,350
pure because you're not changing

00:03:46,260 --> 00:03:51,750
anything and then you do mutations like

00:03:49,350 --> 00:03:54,330
they're using this set tag functions to

00:03:51,750 --> 00:03:55,950
do the mutations the problem here is our

00:03:54,330 --> 00:04:00,480
teaser function is doing both

00:03:55,950 --> 00:04:02,370
calculations as well as mutations I want

00:04:00,480 --> 00:04:05,100
you to think of creating independent

00:04:02,370 --> 00:04:06,740
calculation pipelines again read it from

00:04:05,100 --> 00:04:10,950
right to the left

00:04:06,740 --> 00:04:13,080
so now Harry you call the get text

00:04:10,950 --> 00:04:15,390
function which is ignorant of the input

00:04:13,080 --> 00:04:16,530
and then it uses the text down to 60

00:04:15,390 --> 00:04:18,450
characters which is a very naive

00:04:16,530 --> 00:04:21,930
implementation of how you generate

00:04:18,450 --> 00:04:23,490
teasers and then you set the textual

00:04:21,930 --> 00:04:25,280
environment so you're ignorant of your

00:04:23,490 --> 00:04:28,250
input environment and you're a girl

00:04:25,280 --> 00:04:30,860
of your output environment now let's

00:04:28,250 --> 00:04:33,230
take our pipeline to our previous

00:04:30,860 --> 00:04:36,320
algorithm so the only thing our teaser

00:04:33,230 --> 00:04:38,750
function do is slice this text given to

00:04:36,320 --> 00:04:41,390
it by set text function so we actually

00:04:38,750 --> 00:04:43,400
isolated mutation to the set text

00:04:41,390 --> 00:04:45,830
function and took it out of the teaser

00:04:43,400 --> 00:04:48,320
function this is just a taste of

00:04:45,830 --> 00:04:51,620
separating mutations from calculations

00:04:48,320 --> 00:04:53,480
and you'll be will be diving deep into

00:04:51,620 --> 00:04:56,480
more kinds of separation along the way

00:04:53,480 --> 00:04:59,510
and so let's jump right into pure

00:04:56,480 --> 00:05:01,370
functions we all have been writing three

00:04:59,510 --> 00:05:03,890
kinds of functions so the first are

00:05:01,370 --> 00:05:07,100
mapping functions so you pass in X it

00:05:03,890 --> 00:05:08,900
converts it to Y and and just returns

00:05:07,100 --> 00:05:10,610
result and then there are other types of

00:05:08,900 --> 00:05:13,340
functions like procedure functions and

00:05:10,610 --> 00:05:15,290
i/o functions in which you have it steps

00:05:13,340 --> 00:05:17,650
like do this and then do this and then

00:05:15,290 --> 00:05:20,090
you produce a lot of side effects

00:05:17,650 --> 00:05:22,310
so we'll be concentrating only on

00:05:20,090 --> 00:05:26,360
mapping functions while talking about

00:05:22,310 --> 00:05:28,310
purity just to keep it kind of messy a

00:05:26,360 --> 00:05:32,120
function is a single valued collection

00:05:28,310 --> 00:05:34,940
of pairs so if you pass in one to this

00:05:32,120 --> 00:05:36,740
function it would reduce e and no matter

00:05:34,940 --> 00:05:38,180
how many times you pass one to this

00:05:36,740 --> 00:05:41,540
function it's always going to produce

00:05:38,180 --> 00:05:43,700
three and passing two to this function

00:05:41,540 --> 00:05:45,740
produces five now passing two for

00:05:43,700 --> 00:05:48,320
example can never produce eight that's

00:05:45,740 --> 00:05:50,900
just not possible so what you can pass

00:05:48,320 --> 00:05:53,000
to a function is its domain and what you

00:05:50,900 --> 00:05:54,590
get out of a function is its range for

00:05:53,000 --> 00:05:56,360
example a squaring function you can

00:05:54,590 --> 00:05:58,820
never get a negative value out of a

00:05:56,360 --> 00:06:01,490
squaring function that's just not in the

00:05:58,820 --> 00:06:04,270
range of the squaring function so what

00:06:01,490 --> 00:06:06,790
makes a function pair let's look at the

00:06:04,270 --> 00:06:09,320
well let's look at this real quick so

00:06:06,790 --> 00:06:12,590
given the same inputs is always going to

00:06:09,320 --> 00:06:14,419
return the same output it has no side

00:06:12,590 --> 00:06:16,700
effects which actually means that it

00:06:14,419 --> 00:06:18,320
avoids mutating shared state or even

00:06:16,700 --> 00:06:20,720
working with shared state all together

00:06:18,320 --> 00:06:23,540
and it solely depends on the arguments

00:06:20,720 --> 00:06:26,450
passed to it that is to say it never

00:06:23,540 --> 00:06:28,729
lies an external estate nicely the pure

00:06:26,450 --> 00:06:30,919
impure game so here's a squaring

00:06:28,729 --> 00:06:33,590
function which totally depends on okay

00:06:30,919 --> 00:06:35,450
the arrows are a bit off okay so it

00:06:33,590 --> 00:06:37,700
totally depends on the input password so

00:06:35,450 --> 00:06:38,540
this is a pure function and then we have

00:06:37,700 --> 00:06:40,310
our

00:06:38,540 --> 00:06:41,900
slice function which actually gives you

00:06:40,310 --> 00:06:43,700
a subset of an array but it never

00:06:41,900 --> 00:06:45,860
mutates the actuary so that's a pure

00:06:43,700 --> 00:06:47,990
function there but then we have a splice

00:06:45,860 --> 00:06:50,540
which actually mutates the actuary and

00:06:47,990 --> 00:06:52,310
gives you a subset that's an impure

00:06:50,540 --> 00:06:54,170
function and then we have pop which is

00:06:52,310 --> 00:06:57,440
again impure because it mutates the

00:06:54,170 --> 00:06:59,300
actuary now maybe we can write impure

00:06:57,440 --> 00:07:02,930
functions in a pure way so this is like

00:06:59,300 --> 00:07:04,610
maybe a pure version of pop and there

00:07:02,930 --> 00:07:06,290
can be other ways in which you can pop

00:07:04,610 --> 00:07:09,350
an element without mutating the actual

00:07:06,290 --> 00:07:10,700
element so now we want to add some sort

00:07:09,350 --> 00:07:13,430
functionality where I can sort by

00:07:10,700 --> 00:07:16,610
leaders famous and shortest pose now the

00:07:13,430 --> 00:07:19,610
whole UI is the whole UI layer is most

00:07:16,610 --> 00:07:22,310
predictable when it is define as a pure

00:07:19,610 --> 00:07:24,200
function of the application state now

00:07:22,310 --> 00:07:26,120
what is an application state it's a

00:07:24,200 --> 00:07:28,760
collection of objects and a simplified

00:07:26,120 --> 00:07:30,440
version of it may look like this where

00:07:28,760 --> 00:07:34,160
you have a sort flag and then an array

00:07:30,440 --> 00:07:35,840
of objects each presenting opposed now

00:07:34,160 --> 00:07:38,630
here is the on state change pure

00:07:35,840 --> 00:07:41,450
function if that's doing two things to

00:07:38,630 --> 00:07:43,460
it so a the current application state

00:07:41,450 --> 00:07:45,650
and then the action we are trying to do

00:07:43,460 --> 00:07:48,170
there is sort here since this function

00:07:45,650 --> 00:07:51,680
is pure it does not mutate the current

00:07:48,170 --> 00:07:54,680
state rather creates new state few folks

00:07:51,680 --> 00:07:56,720
call these functions as reducers so

00:07:54,680 --> 00:07:59,090
essentially what you're doing over time

00:07:56,720 --> 00:08:02,210
is you're actually creating a history of

00:07:59,090 --> 00:08:04,070
application States which brings us to

00:08:02,210 --> 00:08:06,440
time-traveling impurity

00:08:04,070 --> 00:08:08,450
this history objects brings us to

00:08:06,440 --> 00:08:10,880
time-traveling so suppose you go from a

00:08:08,450 --> 00:08:14,570
state 1 to 2 to 3 to 4 and then you can

00:08:10,880 --> 00:08:16,400
always come jump from a state 4 to 2 or

00:08:14,570 --> 00:08:19,070
3 to 1 if you have preserved all the

00:08:16,400 --> 00:08:20,870
states so so you're you're not actually

00:08:19,070 --> 00:08:22,760
regenerating these states but actually

00:08:20,870 --> 00:08:25,670
jumping back to a state which is already

00:08:22,760 --> 00:08:28,760
there now I'll leave this slide with

00:08:25,670 --> 00:08:32,630
discussion I have this a crazy idea and

00:08:28,760 --> 00:08:35,570
talk to Patrick about this how about if

00:08:32,630 --> 00:08:37,490
we can create more than once because in

00:08:35,570 --> 00:08:40,520
England Universal what you do is you

00:08:37,490 --> 00:08:42,560
actually create like render your initial

00:08:40,520 --> 00:08:45,470
state on the server how about creating

00:08:42,560 --> 00:08:47,450
more than one initial stages which you

00:08:45,470 --> 00:08:49,970
can implement through a service worker

00:08:47,450 --> 00:08:51,500
and then time travel into the future

00:08:49,970 --> 00:08:52,190
when I say time-traveling in the future

00:08:51,500 --> 00:08:54,260
what I'm

00:08:52,190 --> 00:08:57,110
saying is I won't be generating the

00:08:54,260 --> 00:08:59,120
state on the fly because I already have

00:08:57,110 --> 00:09:01,460
this state being generated and then I'll

00:08:59,120 --> 00:09:03,770
just jump back jump from state 1 to

00:09:01,460 --> 00:09:06,710
state 3 or any money anywhere in the

00:09:03,770 --> 00:09:10,130
future that's just a crazy idea

00:09:06,710 --> 00:09:12,260
so purity its reliable because it's

00:09:10,130 --> 00:09:14,120
predictable it's testable because it

00:09:12,260 --> 00:09:16,370
does not have host inputs as we as we

00:09:14,120 --> 00:09:18,940
discussed it's portable because it's

00:09:16,370 --> 00:09:20,720
independent of the application state

00:09:18,940 --> 00:09:21,350
it's independent of the environment

00:09:20,720 --> 00:09:24,260
sorry

00:09:21,350 --> 00:09:26,600
it's port it's memorize Abul because it

00:09:24,260 --> 00:09:29,210
it can help us create history and

00:09:26,600 --> 00:09:30,710
memorize them and then it's federalized

00:09:29,210 --> 00:09:33,470
able because that's a tongue twister

00:09:30,710 --> 00:09:35,660
para la la la it's parallelizable

00:09:33,470 --> 00:09:38,570
because it does not affect sure to see

00:09:35,660 --> 00:09:40,550
so things can go in parallel now let's

00:09:38,570 --> 00:09:42,830
talk about function allowance real quick

00:09:40,550 --> 00:09:45,020
so generally we think of functions as

00:09:42,830 --> 00:09:46,970
verbs but in the light of functional

00:09:45,020 --> 00:09:50,390
programming function can be thought of

00:09:46,970 --> 00:09:53,390
as nouns so ultimately functions are

00:09:50,390 --> 00:09:55,970
defined by rules but if we step back and

00:09:53,390 --> 00:09:57,830
not think of functions as rules defined

00:09:55,970 --> 00:09:59,870
inside of them and all the things the

00:09:57,830 --> 00:10:01,400
function do but think of function

00:09:59,870 --> 00:10:03,650
there's something that passes things

00:10:01,400 --> 00:10:06,710
through and converts it from one thing

00:10:03,650 --> 00:10:09,890
to another for example here we have an

00:10:06,710 --> 00:10:12,110
array of colorful circles we pass them

00:10:09,890 --> 00:10:14,510
to a map function which maps them to a

00:10:12,110 --> 00:10:16,040
triangle then we pass it to a take

00:10:14,510 --> 00:10:17,960
function and take the first three

00:10:16,040 --> 00:10:20,090
elements then we can cat two more

00:10:17,960 --> 00:10:23,930
elements and then we pass it to a filter

00:10:20,090 --> 00:10:26,270
function to filter only the red ones did

00:10:23,930 --> 00:10:29,990
you get the feel functions are just

00:10:26,270 --> 00:10:32,960
passing values true now let's jump right

00:10:29,990 --> 00:10:34,880
into currying and composition so we said

00:10:32,960 --> 00:10:37,160
in mathematics function take one input

00:10:34,880 --> 00:10:39,230
and produces one output but that's a

00:10:37,160 --> 00:10:40,970
pain like I have functions and you all

00:10:39,230 --> 00:10:43,100
have written functions which take more

00:10:40,970 --> 00:10:45,260
than one input so we converted this

00:10:43,100 --> 00:10:48,589
mathematical phenomena of one input one

00:10:45,260 --> 00:10:51,110
output to one input at a time produces

00:10:48,589 --> 00:10:54,700
one output like you want to be lazy and

00:10:51,110 --> 00:10:57,290
we give inputs to functions one by one

00:10:54,700 --> 00:10:59,270
let's look at a simple function that

00:10:57,290 --> 00:11:01,640
adds two numbers we all have created

00:10:59,270 --> 00:11:04,300
error functions out of this function by

00:11:01,640 --> 00:11:07,750
being lazy and passing only Oh

00:11:04,300 --> 00:11:09,810
but at a time and when you do that you

00:11:07,750 --> 00:11:11,830
get another function as a result and

00:11:09,810 --> 00:11:13,660
JavaScript somehow remembers the

00:11:11,830 --> 00:11:15,160
environment that is in this case the

00:11:13,660 --> 00:11:16,870
value of x that was passed to the

00:11:15,160 --> 00:11:19,540
original function I'm not going to use

00:11:16,870 --> 00:11:22,780
the word closure because that's another

00:11:19,540 --> 00:11:25,000
topic and then you call the adder with

00:11:22,780 --> 00:11:28,060
value to get the value plus 10 every

00:11:25,000 --> 00:11:29,650
time what if I want to pass in like a

00:11:28,060 --> 00:11:31,990
bunch of board if I want to add like

00:11:29,650 --> 00:11:33,340
four numbers now that's a very bad

00:11:31,990 --> 00:11:36,370
implementation and there are a lot of

00:11:33,340 --> 00:11:39,460
unwanted closures there so what you do

00:11:36,370 --> 00:11:42,190
is you use a curling function so welcome

00:11:39,460 --> 00:11:44,170
to occurring so this is the function to

00:11:42,190 --> 00:11:46,090
help us carry our functions now then and

00:11:44,170 --> 00:11:47,740
now I don't expect you to get hold of

00:11:46,090 --> 00:11:50,550
this function if you haven't seen it

00:11:47,740 --> 00:11:54,760
before so it's returning a function

00:11:50,550 --> 00:11:56,410
which says I'm a new function if I were

00:11:54,760 --> 00:11:59,650
given fewer arguments then the original

00:11:56,410 --> 00:12:01,330
function wanted I just I just remember

00:11:59,650 --> 00:12:04,270
what was passed to me and little wait

00:12:01,330 --> 00:12:06,010
for the actual arguments but if somebody

00:12:04,270 --> 00:12:08,620
passes in all the arguments which the

00:12:06,010 --> 00:12:10,210
original function wanted then just pass

00:12:08,620 --> 00:12:12,580
it along to the original original

00:12:10,210 --> 00:12:14,440
function in general you don't have to

00:12:12,580 --> 00:12:16,600
implement this because it's implemented

00:12:14,440 --> 00:12:18,520
by hundred different libraries in

00:12:16,600 --> 00:12:19,930
thousand different ways so you don't

00:12:18,520 --> 00:12:22,120
have to do that so all what you do is

00:12:19,930 --> 00:12:25,180
use that currying function and make your

00:12:22,120 --> 00:12:27,520
function implementations flatter and

00:12:25,180 --> 00:12:31,690
then you got a B and then you can be

00:12:27,520 --> 00:12:33,190
lazy about passing arguments so that was

00:12:31,690 --> 00:12:36,790
carrying in less than two minutes by the

00:12:33,190 --> 00:12:38,110
way now let's talk about composition so

00:12:36,790 --> 00:12:39,910
most of us have done these basic

00:12:38,110 --> 00:12:41,680
composition like creating a net function

00:12:39,910 --> 00:12:43,660
and then compose the specific functions

00:12:41,680 --> 00:12:45,760
like a second function out of an init

00:12:43,660 --> 00:12:49,120
function now let's go back to our

00:12:45,760 --> 00:12:51,850
interface do you remember the greetings

00:12:49,120 --> 00:12:54,100
and user name we display how do we do

00:12:51,850 --> 00:12:58,660
that so here's the basic function we

00:12:54,100 --> 00:13:01,270
started from but we wanted to append mr.

00:12:58,660 --> 00:13:04,060
or mrs. based on gender so we change our

00:13:01,270 --> 00:13:06,310
function a little and make it look like

00:13:04,060 --> 00:13:07,870
this but then we wanted to add more

00:13:06,310 --> 00:13:09,730
stuff to this function and make it not

00:13:07,870 --> 00:13:11,890
just keep on adding stuff to over

00:13:09,730 --> 00:13:14,080
function so we create separate

00:13:11,890 --> 00:13:17,200
composable functions for each part of

00:13:14,080 --> 00:13:20,620
our breedings and how do we compose a

00:13:17,200 --> 00:13:23,410
message for Jeff so we pass Jeff to

00:13:20,620 --> 00:13:25,900
beard and then we pass the result to

00:13:23,410 --> 00:13:28,240
male and then we pass the result to

00:13:25,900 --> 00:13:33,010
casual readings which actually generates

00:13:28,240 --> 00:13:37,720
sub Jeff now let's talk about functors

00:13:33,010 --> 00:13:38,890
and monads okay and this is the time in

00:13:37,720 --> 00:13:40,720
functional programming when people

00:13:38,890 --> 00:13:43,810
started unfriending you because these

00:13:40,720 --> 00:13:45,760
are like some religious topics so I'll

00:13:43,810 --> 00:13:48,400
try to like you know blast all the

00:13:45,760 --> 00:13:50,590
slides right in there so foundry is an

00:13:48,400 --> 00:13:53,950
object that you can map over but you're

00:13:50,590 --> 00:13:56,800
not we are so hardwired to think of map

00:13:53,950 --> 00:14:00,220
as something which can help us i trait

00:13:56,800 --> 00:14:02,050
over an array which is not true you

00:14:00,220 --> 00:14:06,520
should be able to map over any type of

00:14:02,050 --> 00:14:08,020
object so here is a box object or a

00:14:06,520 --> 00:14:10,270
function whatever you want to call it it

00:14:08,020 --> 00:14:12,790
has a property value and then you cart

00:14:10,270 --> 00:14:14,680
off and then you create a box functor

00:14:12,790 --> 00:14:19,720
which actually returns a new instance of

00:14:14,680 --> 00:14:21,580
the box type now whenever I call the Box

00:14:19,720 --> 00:14:24,520
FUNKER and giving it a value it's just

00:14:21,580 --> 00:14:27,700
going to give me something like this but

00:14:24,520 --> 00:14:29,680
what if I want to pass box FUNKER and

00:14:27,700 --> 00:14:31,990
pass it ng-conf and then pass the whole

00:14:29,680 --> 00:14:33,880
thing to some function which is to

00:14:31,990 --> 00:14:36,760
lowercase or to uppercase and on and

00:14:33,880 --> 00:14:40,150
that kind of a function you cannot use

00:14:36,760 --> 00:14:41,530
our box functor on top of these

00:14:40,150 --> 00:14:44,350
functions because it's just going to

00:14:41,530 --> 00:14:46,540
return an object as we just saw so what

00:14:44,350 --> 00:14:50,170
we can do is we can add a math function

00:14:46,540 --> 00:14:53,650
in our box type which actually whatever

00:14:50,170 --> 00:14:55,510
function you pass through this of map

00:14:53,650 --> 00:14:58,030
implementation it's gonna just run this

00:14:55,510 --> 00:15:00,790
function on the value property so now we

00:14:58,030 --> 00:15:04,960
can just do it like this and call our

00:15:00,790 --> 00:15:06,970
map function I'm just gonna go okay so

00:15:04,960 --> 00:15:09,730
here is another slide on this so we can

00:15:06,970 --> 00:15:12,550
map over a map so you have a box anchor

00:15:09,730 --> 00:15:15,070
you pass in an array and then you call

00:15:12,550 --> 00:15:16,330
the reverse function and then you call

00:15:15,070 --> 00:15:17,710
the last function and then you get the

00:15:16,330 --> 00:15:20,230
result and similar is another example

00:15:17,710 --> 00:15:23,680
we'll skip over this real quick and

00:15:20,230 --> 00:15:26,170
let's look at this some some real well

00:15:23,680 --> 00:15:26,840
example so we grab the query selector

00:15:26,170 --> 00:15:29,390
and put it

00:15:26,840 --> 00:15:32,390
in get Dom elements so what we're trying

00:15:29,390 --> 00:15:35,450
to do is we are trying to get value of

00:15:32,390 --> 00:15:38,420
all the classes with all the blog

00:15:35,450 --> 00:15:41,180
readings classes in our HTML now there's

00:15:38,420 --> 00:15:44,210
a problem what if you don't find the

00:15:41,180 --> 00:15:46,520
blog reading class on your HTML your get

00:15:44,210 --> 00:15:48,830
Dom element is gonna return a null and

00:15:46,520 --> 00:15:50,090
then you're calling get value on top of

00:15:48,830 --> 00:15:53,650
that so when you do that

00:15:50,090 --> 00:15:57,620
you're gonna mess up so what you do is

00:15:53,650 --> 00:16:01,730
you create a maybe functor and that's

00:15:57,620 --> 00:16:03,350
just an idea to avoid nulls and stuff in

00:16:01,730 --> 00:16:05,870
your code so that you don't have to

00:16:03,350 --> 00:16:07,640
worry that if it is if something returns

00:16:05,870 --> 00:16:09,440
null what's gonna happen and will I be

00:16:07,640 --> 00:16:12,740
able to call another function on top of

00:16:09,440 --> 00:16:14,180
that so you call maybe functors and I'm

00:16:12,740 --> 00:16:17,300
not gonna go into how implement maybe

00:16:14,180 --> 00:16:19,730
functors because of lack of time then we

00:16:17,300 --> 00:16:22,160
have mone yards and monads in other

00:16:19,730 --> 00:16:24,110
religious debates so anything that

00:16:22,160 --> 00:16:27,170
implements concat and empty is a

00:16:24,110 --> 00:16:30,230
moonyard and anything that implements m

00:16:27,170 --> 00:16:33,140
join and chain is monads you can just

00:16:30,230 --> 00:16:34,760
look at just one example so M join is

00:16:33,140 --> 00:16:37,550
two custom types

00:16:34,760 --> 00:16:40,160
what flatten is to erase and I hope you

00:16:37,550 --> 00:16:43,250
all have used sladden so if you have you

00:16:40,160 --> 00:16:45,800
slide in to flatten maybe like a couple

00:16:43,250 --> 00:16:48,290
of bunch of arrays and then we flatten

00:16:45,800 --> 00:16:50,720
it down to a single array right but we

00:16:48,290 --> 00:16:53,180
can use that on any type other than

00:16:50,720 --> 00:16:56,720
areas as well so what I'm doing here is

00:16:53,180 --> 00:16:59,690
I'm calling I'm getting the type ID and

00:16:56,720 --> 00:17:01,700
I'm again using the maybe functor trying

00:16:59,690 --> 00:17:03,590
to compose these two together to get the

00:17:01,700 --> 00:17:05,780
type ID similar I get the author ID

00:17:03,590 --> 00:17:08,090
right so what I'm trying to do here is

00:17:05,780 --> 00:17:10,670
I'm trying to get all posts from an

00:17:08,090 --> 00:17:12,440
author of a particular type well then

00:17:10,670 --> 00:17:15,620
the problems going to happen is author

00:17:12,440 --> 00:17:17,840
ID is gonna return maybe maybe and then

00:17:15,620 --> 00:17:20,630
type ID again is gonna return maybe and

00:17:17,840 --> 00:17:23,660
then we compose to you get a maybe maybe

00:17:20,630 --> 00:17:25,520
and the result how do you solve this

00:17:23,660 --> 00:17:27,830
problem now I have to flatten it down

00:17:25,520 --> 00:17:30,830
right as I said it's it's exactly the

00:17:27,830 --> 00:17:34,910
same as flatten but for custom types so

00:17:30,830 --> 00:17:37,070
what I do is I use this M joint thing

00:17:34,910 --> 00:17:39,940
which actually flattens this stuff down

00:17:37,070 --> 00:17:41,799
and then you can go ahead

00:17:39,940 --> 00:17:43,809
with your results and then do chaining

00:17:41,799 --> 00:17:45,759
on top of this so if anybody wants to

00:17:43,809 --> 00:17:47,980
talk about monads further I'm here I'll

00:17:45,759 --> 00:17:50,320
be talking about this after the doc now

00:17:47,980 --> 00:17:52,629
let's talk about reactive framing the a

00:17:50,320 --> 00:17:54,759
couple of awesome frameworks like baking

00:17:52,629 --> 00:17:56,980
GIS and art exists and psychology is and

00:17:54,759 --> 00:17:59,110
then there are platforms like angular

00:17:56,980 --> 00:18:01,809
which can help you go as much reactive

00:17:59,110 --> 00:18:03,159
as you want so why is everyone so

00:18:01,809 --> 00:18:05,590
interested about reactive programming

00:18:03,159 --> 00:18:09,250
what on earth is reactive programming

00:18:05,590 --> 00:18:11,379
anyways it's programming with async data

00:18:09,250 --> 00:18:14,350
streams it's a programming paradigm

00:18:11,379 --> 00:18:16,629
oriented around data flows making the

00:18:14,350 --> 00:18:19,899
propagation of chain is smooth and

00:18:16,629 --> 00:18:22,120
easier to reason about so I think

00:18:19,899 --> 00:18:23,529
reactive programming is easier than most

00:18:22,120 --> 00:18:25,480
of the programming style if you do

00:18:23,529 --> 00:18:28,539
everyday but there's only one barrier

00:18:25,480 --> 00:18:30,250
that is thinking in terms of reactive

00:18:28,539 --> 00:18:33,519
programming since you don't have time to

00:18:30,250 --> 00:18:37,570
code and I'm not super awesome at live

00:18:33,519 --> 00:18:39,070
coding we will dive deep in to see how

00:18:37,570 --> 00:18:40,570
we think in terms of reactive

00:18:39,070 --> 00:18:42,370
programming so I want to talk about

00:18:40,570 --> 00:18:44,860
three things here to help us think in

00:18:42,370 --> 00:18:46,809
terms of Rp reactive programming is

00:18:44,860 --> 00:18:49,360
based heavily on two design patterns the

00:18:46,809 --> 00:18:51,850
observer and the iterator value now

00:18:49,360 --> 00:18:54,639
before we go into this observables are

00:18:51,850 --> 00:18:56,529
like scrums everybody have their own

00:18:54,639 --> 00:19:00,100
definition of it and everybody thinks

00:18:56,529 --> 00:19:02,470
that everybody else is wrong so so in

00:19:00,100 --> 00:19:04,659
the observer pattern you have two

00:19:02,470 --> 00:19:07,029
constructs an observable and an observer

00:19:04,659 --> 00:19:10,269
to start with an observer makes a

00:19:07,029 --> 00:19:11,799
request to the observable that hey send

00:19:10,269 --> 00:19:14,409
me some data whenever you have something

00:19:11,799 --> 00:19:15,940
now the observable maintains a list or

00:19:14,409 --> 00:19:17,320
somehow keeps track of all the

00:19:15,940 --> 00:19:20,139
observables and then there can be

00:19:17,320 --> 00:19:22,419
multiple observables so an observable

00:19:20,139 --> 00:19:25,200
can emit values to its subscribers and

00:19:22,419 --> 00:19:28,139
it can be observed or subscribed to and

00:19:25,200 --> 00:19:31,779
subsequently unsubscribe from over time

00:19:28,139 --> 00:19:34,210
then we have an observer which can

00:19:31,779 --> 00:19:36,639
listen to an observable and receive data

00:19:34,210 --> 00:19:39,490
from observable and then generally apply

00:19:36,639 --> 00:19:42,730
some data manipulation pipelines on the

00:19:39,490 --> 00:19:44,590
receive response now let's talk about

00:19:42,730 --> 00:19:47,919
this heated religious debate of push

00:19:44,590 --> 00:19:50,500
versus pull architecture so poll nature

00:19:47,919 --> 00:19:51,190
is common we as consumers of data

00:19:50,500 --> 00:19:53,050
X

00:19:51,190 --> 00:19:55,360
we asked for a value from the data

00:19:53,050 --> 00:19:57,070
producer at some point in time like

00:19:55,360 --> 00:19:59,790
reading an array that's pulling

00:19:57,070 --> 00:20:02,980
requesting value from the data source

00:19:59,790 --> 00:20:05,620
pull is not continuous you pull the

00:20:02,980 --> 00:20:07,390
value once and then whenever you want to

00:20:05,620 --> 00:20:08,830
do it you have to do it again it's like

00:20:07,390 --> 00:20:13,480
you don't have a connection between a

00:20:08,830 --> 00:20:15,340
data source and a data consumer so it's

00:20:13,480 --> 00:20:17,470
kind of sounds like the consumer is in

00:20:15,340 --> 00:20:20,170
charge of the data here in contrast to

00:20:17,470 --> 00:20:22,870
this in a push architecture the observer

00:20:20,170 --> 00:20:24,340
defines an interface and when you are

00:20:22,870 --> 00:20:26,170
subscribing to an observable you're

00:20:24,340 --> 00:20:28,360
actually telling the observable look if

00:20:26,170 --> 00:20:30,760
you have some good data do this if you

00:20:28,360 --> 00:20:32,920
have some bad data do that so the

00:20:30,760 --> 00:20:35,470
observer define these interfaces are

00:20:32,920 --> 00:20:36,100
callbacks and inform the observable

00:20:35,470 --> 00:20:37,690
about it

00:20:36,100 --> 00:20:40,900
that's what happens when you actually

00:20:37,690 --> 00:20:43,000
subscribe to observable whenever we have

00:20:40,900 --> 00:20:45,610
an update the observable actually pushes

00:20:43,000 --> 00:20:47,920
the data to all its observers and and

00:20:45,610 --> 00:20:50,260
that would happen and that happens

00:20:47,920 --> 00:20:53,440
continuously over time now push is

00:20:50,260 --> 00:20:55,510
different push is continuous the values

00:20:53,440 --> 00:20:57,280
are push until the consumer asks the

00:20:55,510 --> 00:20:58,780
data producer to remove its subscription

00:20:57,280 --> 00:21:01,240
and now the subscription is another

00:20:58,780 --> 00:21:02,950
story like how we actually unsubscribe

00:21:01,240 --> 00:21:06,430
from an observable and I'm not going to

00:21:02,950 --> 00:21:09,280
be talking about this right now so in a

00:21:06,430 --> 00:21:11,410
push architecture the data producer is

00:21:09,280 --> 00:21:13,990
more in charge of the data than the data

00:21:11,410 --> 00:21:15,700
consumer now a few days back I was

00:21:13,990 --> 00:21:19,930
skyping a friend of mine and he asked me

00:21:15,700 --> 00:21:23,320
since everything is a stream what is not

00:21:19,930 --> 00:21:24,580
a stream I said look since everything in

00:21:23,320 --> 00:21:29,350
the stream let me make it more difficult

00:21:24,580 --> 00:21:31,420
for you nothing is not a stream so our

00:21:29,350 --> 00:21:32,740
timer like set interval in JavaScript

00:21:31,420 --> 00:21:34,510
that can happen over time and

00:21:32,740 --> 00:21:38,140
continuously generate some data can be

00:21:34,510 --> 00:21:41,080
observed mouse clicks drags drops hovers

00:21:38,140 --> 00:21:43,030
and keystrokes as user inputs can happen

00:21:41,080 --> 00:21:46,570
over time and that's an observable there

00:21:43,030 --> 00:21:48,190
and then any async calls to networks

00:21:46,570 --> 00:21:50,080
which bring one piece of data or

00:21:48,190 --> 00:21:52,840
multiple pieces of information over time

00:21:50,080 --> 00:21:54,700
that's an observable they're shared

00:21:52,840 --> 00:21:56,710
services across your components doing

00:21:54,700 --> 00:21:59,020
some IO operations or maintaining your

00:21:56,710 --> 00:22:01,540
states that can be turned into an

00:21:59,020 --> 00:22:03,049
observable form inputs like a textbox

00:22:01,540 --> 00:22:05,389
change or a check

00:22:03,049 --> 00:22:07,999
or drop-down selection that can be

00:22:05,389 --> 00:22:10,190
treated as observables as well and the

00:22:07,999 --> 00:22:13,669
new ways of user inputs like speech and

00:22:10,190 --> 00:22:15,440
gesture and whatnot all of that can be

00:22:13,669 --> 00:22:16,970
observed over time and then we have

00:22:15,440 --> 00:22:17,629
classical data structures which we'll

00:22:16,970 --> 00:22:19,940
skip over

00:22:17,629 --> 00:22:23,659
and then anything that's a dot dot dot

00:22:19,940 --> 00:22:26,690
for anything so now I treat a matter

00:22:23,659 --> 00:22:29,090
real quick it has three pieces to it and

00:22:26,690 --> 00:22:31,519
a lot of folks overlook the first piece

00:22:29,090 --> 00:22:33,860
which talks about traversal of different

00:22:31,519 --> 00:22:37,279
data types of collections so what it

00:22:33,860 --> 00:22:40,669
says is I don't care if you're if you

00:22:37,279 --> 00:22:42,769
are producing data by moving the mouse

00:22:40,669 --> 00:22:44,989
over a screen or you're downloading a

00:22:42,769 --> 00:22:47,389
file if it's data its data its

00:22:44,989 --> 00:22:50,480
collection I call it polymorphic

00:22:47,389 --> 00:22:52,999
traversal because it feeds all types of

00:22:50,480 --> 00:22:55,609
collections the same way now it's read a

00:22:52,999 --> 00:22:57,859
pattern like observer pattern gives data

00:22:55,609 --> 00:23:00,080
to the consumer one item at a time and

00:22:57,859 --> 00:23:01,629
while it's reading over a list it only

00:23:00,080 --> 00:23:03,919
cares about two things

00:23:01,629 --> 00:23:06,679
that's the collection have more data

00:23:03,919 --> 00:23:08,749
that you're interested in if it has more

00:23:06,679 --> 00:23:11,509
data how can we get to the next data

00:23:08,749 --> 00:23:14,629
pointer so data producer progressively

00:23:11,509 --> 00:23:17,809
sends data to the consumer one item at a

00:23:14,629 --> 00:23:20,389
time and with it sends an indicator if

00:23:17,809 --> 00:23:23,119
the stream has completed or not now I

00:23:20,389 --> 00:23:25,940
would like you to focus on this done

00:23:23,119 --> 00:23:28,220
true because that's the magic that was

00:23:25,940 --> 00:23:30,259
the missing piece in how Gang of Four

00:23:28,220 --> 00:23:33,440
described this pattern like twenty years

00:23:30,259 --> 00:23:35,749
back and we finally realize it because

00:23:33,440 --> 00:23:38,389
previously a lot of subscriptions were

00:23:35,749 --> 00:23:41,090
always alive and were never disposed

00:23:38,389 --> 00:23:42,950
because he never had this indicator from

00:23:41,090 --> 00:23:47,570
the data producer that hey boy no more

00:23:42,950 --> 00:23:50,119
data and es6 has a lot of support for

00:23:47,570 --> 00:23:51,679
iterators I blog about it quite a lot so

00:23:50,119 --> 00:23:55,159
you can go and check my blog I'll share

00:23:51,679 --> 00:23:57,230
the links in the end now to finish off

00:23:55,159 --> 00:23:59,629
this I want to talk about the streams

00:23:57,230 --> 00:24:01,399
and reactions over time together because

00:23:59,629 --> 00:24:03,859
all of what you do is wait for streams

00:24:01,399 --> 00:24:05,960
and react when something happens now

00:24:03,859 --> 00:24:07,879
this is the main ng can't talk interface

00:24:05,960 --> 00:24:09,950
and only the best talks will make you

00:24:07,879 --> 00:24:11,809
this interface looks like the talk

00:24:09,950 --> 00:24:14,690
started coming so serious talk from Shai

00:24:11,809 --> 00:24:16,890
Resnick keep waiting for that Eric's

00:24:14,690 --> 00:24:18,690
from Ben Lesh in ng beard

00:24:16,890 --> 00:24:21,780
is my favorite talk from Jeff cross ng1

00:24:18,690 --> 00:24:24,420
is alive so you have couple of talks so

00:24:21,780 --> 00:24:27,000
do you see that gray area where you have

00:24:24,420 --> 00:24:29,040
to drop your talks so all what you need

00:24:27,000 --> 00:24:31,950
to do is to click on your favorite talk

00:24:29,040 --> 00:24:34,140
and drag it to that area the number of

00:24:31,950 --> 00:24:36,450
talks selected counter is incremented as

00:24:34,140 --> 00:24:37,830
soon as you do that and the progress bar

00:24:36,450 --> 00:24:42,990
shows up and you click on the download

00:24:37,830 --> 00:24:45,660
button so to start with we have a number

00:24:42,990 --> 00:24:48,320
of talks appearing over time we click on

00:24:45,660 --> 00:24:52,290
any of the talk and start dragging it

00:24:48,320 --> 00:24:54,750
then drop the talk to be downloaded the

00:24:52,290 --> 00:24:57,480
the drop triggers the counter and that

00:24:54,750 --> 00:25:00,240
gets incremented and as we click on the

00:24:57,480 --> 00:25:03,390
download button progress bar for each

00:25:00,240 --> 00:25:05,670
file being downloaded shows up let's

00:25:03,390 --> 00:25:08,930
bring this down to a single scale in

00:25:05,670 --> 00:25:10,350
time does it look like a scatter plot

00:25:08,930 --> 00:25:12,810
now

00:25:10,350 --> 00:25:16,140
let's merge them down over the scale of

00:25:12,810 --> 00:25:18,660
time you see that's what the user is

00:25:16,140 --> 00:25:21,570
doing on the page that's the reactive

00:25:18,660 --> 00:25:23,070
mindset you got to have and then you

00:25:21,570 --> 00:25:24,630
have several different ways to merge

00:25:23,070 --> 00:25:26,550
these extremes depending upon the

00:25:24,630 --> 00:25:28,470
reactive framework that you're using I'm

00:25:26,550 --> 00:25:30,270
not going to be talking about that so

00:25:28,470 --> 00:25:34,680
let's close our discussion with a bigger

00:25:30,270 --> 00:25:37,020
picture a bigger picture so that's all

00:25:34,680 --> 00:25:38,880
what it is you have a sync event streams

00:25:37,020 --> 00:25:41,100
and you're able to create it streams out

00:25:38,880 --> 00:25:43,470
of anything then you literally feed

00:25:41,100 --> 00:25:46,410
these streams to powerful set of rules

00:25:43,470 --> 00:25:49,860
utilities functions mappers filters and

00:25:46,410 --> 00:25:52,410
much more from this function world to

00:25:49,860 --> 00:25:54,750
create what I call reactive user

00:25:52,410 --> 00:25:56,600
interfaces and I wish somebody didn't

00:25:54,750 --> 00:26:00,170
call their interface react

00:25:56,600 --> 00:26:04,190
that's not reactive

00:26:00,170 --> 00:26:06,200
now in angular2 we have a lot of things

00:26:04,190 --> 00:26:09,740
that we can observe and be reactive

00:26:06,200 --> 00:26:14,120
about I promise that's my last slide you

00:26:09,740 --> 00:26:15,890
can you can listen to routes you can

00:26:14,120 --> 00:26:19,370
listen to HTTP calls which is heavily

00:26:15,890 --> 00:26:21,140
based on our X Y s and then font fields

00:26:19,370 --> 00:26:23,090
are based off of even imagers and

00:26:21,140 --> 00:26:25,460
observable rappers so you can observe

00:26:23,090 --> 00:26:27,620
them to then interactive user interfaces

00:26:25,460 --> 00:26:29,300
can easily be observed and then you can

00:26:27,620 --> 00:26:31,160
treat observable type variables in your

00:26:29,300 --> 00:26:34,730
services and elsewhere to be observed

00:26:31,160 --> 00:26:36,710
and react upon and then we are observing

00:26:34,730 --> 00:26:39,470
the promising github issue four zero six

00:26:36,710 --> 00:26:41,570
four zero six two and Robert will hate

00:26:39,470 --> 00:26:43,760
me for this which in the case that we'll

00:26:41,570 --> 00:26:47,270
be providing a way to delegate arbitrary

00:26:43,760 --> 00:26:50,000
Dom events to a subject observable so

00:26:47,270 --> 00:26:52,160
that it could be easily subscribed to be

00:26:50,000 --> 00:26:53,630
handled we actively so it's like more

00:26:52,160 --> 00:26:56,240
observables are coming to England too

00:26:53,630 --> 00:26:58,010
and that's why I said we can be as

00:26:56,240 --> 00:26:59,660
reactive as you want while using angular

00:26:58,010 --> 00:27:02,450
so in conclusion

00:26:59,660 --> 00:27:05,420
FRP is a programming paradigm for

00:27:02,450 --> 00:27:09,140
reactive programming using the building

00:27:05,420 --> 00:27:10,490
blocks of functional programming the

00:27:09,140 --> 00:27:12,500
resources I'll share

00:27:10,490 --> 00:27:15,260
so start catching all these things out

00:27:12,500 --> 00:27:19,130
there but there's a lot of stuff to

00:27:15,260 --> 00:27:20,720
learn so learn and work towards it over

00:27:19,130 --> 00:27:23,860
time take it easy

00:27:20,720 --> 00:27:23,860

YouTube URL: https://www.youtube.com/watch?v=mmWCuSxSXeY


