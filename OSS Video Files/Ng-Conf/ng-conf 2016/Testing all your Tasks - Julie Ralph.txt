Title: Testing all your Tasks - Julie Ralph
Publication date: 2016-05-04
Playlist: ng-conf 2016
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:08,760
I I think I use a compass to draw

00:00:06,299 --> 00:00:11,690
circles protectors are for measuring

00:00:08,760 --> 00:00:14,099
angles because they measure angular I

00:00:11,690 --> 00:00:17,640
hope you all got that like a couple

00:00:14,099 --> 00:00:21,330
years ago all right I just blew some

00:00:17,640 --> 00:00:23,910
lines so let's give a talk so my name is

00:00:21,330 --> 00:00:25,949
Julie I'm a software engineer in tools

00:00:23,910 --> 00:00:27,570
and infrastructure at Google I work out

00:00:25,949 --> 00:00:29,189
of the Seattle office and for the past

00:00:27,570 --> 00:00:32,969
couple years I've been working with the

00:00:29,189 --> 00:00:34,680
angular team on testing Frank mostly

00:00:32,969 --> 00:00:36,390
protractor but I've also been working a

00:00:34,680 --> 00:00:38,910
lot recently with unit testing

00:00:36,390 --> 00:00:40,829
frameworks for it and give it to so I'm

00:00:38,910 --> 00:00:43,020
gonna talk about testing your tasks or

00:00:40,829 --> 00:00:45,629
as I like to call it the return of the

00:00:43,020 --> 00:00:47,730
zones so if you were here two years ago

00:00:45,629 --> 00:00:50,160
or watch the live stream or the

00:00:47,730 --> 00:00:52,079
recordings you may have heard Brian Ford

00:00:50,160 --> 00:00:54,829
give a talk about this library this

00:00:52,079 --> 00:00:58,530
mysterious library called zone J s and

00:00:54,829 --> 00:01:00,149
zone J s as he mentioned is for managing

00:00:58,530 --> 00:01:02,940
asynchronous tasks it's a way of

00:01:00,149 --> 00:01:06,720
controlling execution contexts for

00:01:02,940 --> 00:01:09,000
JavaScript so why am I here talking

00:01:06,720 --> 00:01:10,080
about zones again and here's a link to

00:01:09,000 --> 00:01:12,390
the original talk they'll be in the

00:01:10,080 --> 00:01:13,530
slide deck if you haven't seen that just

00:01:12,390 --> 00:01:14,970
great

00:01:13,530 --> 00:01:17,100
they've been a couple changes in the

00:01:14,970 --> 00:01:18,150
past two years first zones is not

00:01:17,100 --> 00:01:21,270
theoretical anymore

00:01:18,150 --> 00:01:23,430
it's actually in use in angular 2 for

00:01:21,270 --> 00:01:25,439
really important behavior which I'll

00:01:23,430 --> 00:01:27,420
talk about secondly we've undergone a

00:01:25,439 --> 00:01:29,460
major refactoring for zones which

00:01:27,420 --> 00:01:32,130
introduces a new API and a couple of new

00:01:29,460 --> 00:01:33,659
concepts and finally I find a

00:01:32,130 --> 00:01:35,189
synchronous behavior in JavaScript

00:01:33,659 --> 00:01:36,570
confusing which I think a lot of people

00:01:35,189 --> 00:01:38,970
can relate with and I think that these

00:01:36,570 --> 00:01:42,270
concepts are often worth revisiting even

00:01:38,970 --> 00:01:45,060
if you've heard about them before so

00:01:42,270 --> 00:01:46,700
zones track and control asynchronous

00:01:45,060 --> 00:01:49,860
activity throughout your application

00:01:46,700 --> 00:01:52,500
what does that actually mean first let's

00:01:49,860 --> 00:01:54,810
take a little reminder of what's going

00:01:52,500 --> 00:01:57,719
on in JavaScript when we use

00:01:54,810 --> 00:02:00,210
asynchronous activity so your program

00:01:57,719 --> 00:02:01,829
has a call stack which is synchronously

00:02:00,210 --> 00:02:03,509
running all of your functions popping

00:02:01,829 --> 00:02:05,880
them in and off of the call stack and

00:02:03,509 --> 00:02:08,160
when that's all done processing you've

00:02:05,880 --> 00:02:10,770
probably asked for something like an xhr

00:02:08,160 --> 00:02:14,490
and the event loop

00:02:10,770 --> 00:02:17,370
is a management that will call back into

00:02:14,490 --> 00:02:19,170
your code when that callback queue is

00:02:17,370 --> 00:02:21,060
done so after your set timeout has

00:02:19,170 --> 00:02:23,190
finished it'll pop onto the callback

00:02:21,060 --> 00:02:25,110
queue the event loop will take the first

00:02:23,190 --> 00:02:26,550
thing in that queue run any of your

00:02:25,110 --> 00:02:29,010
actual code that needs to be run and

00:02:26,550 --> 00:02:31,770
then get the next thing off the queue or

00:02:29,010 --> 00:02:33,780
wait for something to be scheduled and

00:02:31,770 --> 00:02:36,450
there's one more piece here that I've

00:02:33,780 --> 00:02:39,000
drawn in which is the micro task queue

00:02:36,450 --> 00:02:41,370
and this is a browser spec and micro

00:02:39,000 --> 00:02:43,680
tasks will run after your call stack

00:02:41,370 --> 00:02:46,530
completes but before a turn of the event

00:02:43,680 --> 00:02:48,810
loop the most often the most common time

00:02:46,530 --> 00:02:51,810
that you'll see these is in promise

00:02:48,810 --> 00:02:53,580
callbacks those should always be queued

00:02:51,810 --> 00:02:55,230
into the micro task queue so that if

00:02:53,580 --> 00:02:56,760
your promise is already resolved it'll

00:02:55,230 --> 00:02:58,710
still run asynchronously so your

00:02:56,760 --> 00:03:00,660
behavior is consistent but it'll run

00:02:58,710 --> 00:03:04,320
immediately and save up time for the

00:03:00,660 --> 00:03:05,820
browser processing in modern web

00:03:04,320 --> 00:03:07,350
applications there's a lot of different

00:03:05,820 --> 00:03:11,270
things that can make our apps

00:03:07,350 --> 00:03:16,080
asynchronous from promises to sockets

00:03:11,270 --> 00:03:17,640
event listeners on the Dom timeouts xhr

00:03:16,080 --> 00:03:20,070
is if we're using node we'll have things

00:03:17,640 --> 00:03:22,709
like file system requests and so while

00:03:20,070 --> 00:03:24,840
you might be able to handle you know if

00:03:22,709 --> 00:03:27,959
you have one one function you can use a

00:03:24,840 --> 00:03:30,120
callback to use the same context for

00:03:27,959 --> 00:03:32,100
your code and the handler but for

00:03:30,120 --> 00:03:34,410
everything that can go on this becomes

00:03:32,100 --> 00:03:37,140
difficult this is where zones come in

00:03:34,410 --> 00:03:40,200
zones are kind of a big monkey patch

00:03:37,140 --> 00:03:42,930
over all of this possible asynchronous

00:03:40,200 --> 00:03:45,030
stuff and they give you a simple API so

00:03:42,930 --> 00:03:47,640
that you can hook in to various points

00:03:45,030 --> 00:03:49,850
of this event loop and modify what's

00:03:47,640 --> 00:03:52,200
happening or track what's happening

00:03:49,850 --> 00:03:55,440
let's look at how we would actually use

00:03:52,200 --> 00:03:56,940
zones as I mentioned zones is a library

00:03:55,440 --> 00:03:59,250
it's a standalone library that does not

00:03:56,940 --> 00:04:01,950
depend on angular it's available on

00:03:59,250 --> 00:04:03,900
github or NPM and so we could install it

00:04:01,950 --> 00:04:07,110
and just include it in our code with a

00:04:03,900 --> 00:04:09,330
script tech and then in our in our

00:04:07,110 --> 00:04:11,730
actual application will have this zone

00:04:09,330 --> 00:04:13,890
global added to the window and we create

00:04:11,730 --> 00:04:15,330
a new zone with the fork function and

00:04:13,890 --> 00:04:18,000
this is a really simple one let's make

00:04:15,330 --> 00:04:19,440
one here that just has a name then to

00:04:18,000 --> 00:04:22,169
actually use the zone we need to run

00:04:19,440 --> 00:04:24,600
something inside of it so let's add an

00:04:22,169 --> 00:04:26,790
event listener for a click handler onto

00:04:24,600 --> 00:04:28,830
a button inside of our zone then

00:04:26,790 --> 00:04:31,560
elsewhere in our application we would

00:04:28,830 --> 00:04:33,990
defend this design that click Handler

00:04:31,560 --> 00:04:37,229
and let's just log the current name with

00:04:33,990 --> 00:04:39,750
the zone and if the click came from that

00:04:37,229 --> 00:04:43,020
handler across asynchronous execution

00:04:39,750 --> 00:04:44,850
will have the same zone name stored so

00:04:43,020 --> 00:04:46,710
that's what we mean by zone tracking

00:04:44,850 --> 00:04:50,820
asynchronous activity across an

00:04:46,710 --> 00:04:53,280
execution context so as I mentioned you

00:04:50,820 --> 00:04:56,250
create new zones by forking them zones

00:04:53,280 --> 00:04:58,260
form a hierarchy so every tone that you

00:04:56,250 --> 00:04:59,970
fork will be a child of its parents and

00:04:58,260 --> 00:05:02,100
it'll have a chance to add hooks and

00:04:59,970 --> 00:05:04,350
modify behavior and also be able to

00:05:02,100 --> 00:05:06,150
delegate to its parent zone we could

00:05:04,350 --> 00:05:08,100
create multiple zones inside of our

00:05:06,150 --> 00:05:10,410
application and we might want to do this

00:05:08,100 --> 00:05:12,600
if say we have an application and we

00:05:10,410 --> 00:05:15,060
want to run some special error handling

00:05:12,600 --> 00:05:17,000
we want to log something whenever an

00:05:15,060 --> 00:05:20,760
error occurs zones can let us do that

00:05:17,000 --> 00:05:23,310
but we also have this help pop-up box

00:05:20,760 --> 00:05:24,570
that we're importing from some other

00:05:23,310 --> 00:05:26,460
team and we don't really want to worry

00:05:24,570 --> 00:05:29,280
about their errors we just want their

00:05:26,460 --> 00:05:31,020
code to run and not bother with ours so

00:05:29,280 --> 00:05:33,390
we can use a zone fork for our

00:05:31,020 --> 00:05:35,190
application and start that up with our

00:05:33,390 --> 00:05:38,220
special error handling and use a

00:05:35,190 --> 00:05:41,100
different zone to run the pop-up box and

00:05:38,220 --> 00:05:43,160
those two won't interfere and in code

00:05:41,100 --> 00:05:46,410
this would look something like this

00:05:43,160 --> 00:05:48,720
Wilfork a zone with the name for our

00:05:46,410 --> 00:05:50,610
application and an error handler

00:05:48,720 --> 00:05:52,080
that'll do some special custom logging

00:05:50,610 --> 00:05:53,970
that we don't want to do for any parts

00:05:52,080 --> 00:05:56,430
of the application any of the other

00:05:53,970 --> 00:05:58,860
parts of our application and then we'll

00:05:56,430 --> 00:06:02,130
run that help pop up in its own zone

00:05:58,860 --> 00:06:03,240
that's unrelated cool so this is how we

00:06:02,130 --> 00:06:04,680
reuse zones

00:06:03,240 --> 00:06:07,830
let's talk a little bit about what they

00:06:04,680 --> 00:06:10,590
can actually do we've been passing these

00:06:07,830 --> 00:06:13,020
names into our zone Forks there's a lot

00:06:10,590 --> 00:06:15,120
more that we can add here this is called

00:06:13,020 --> 00:06:17,850
a specification for the zone or a zone

00:06:15,120 --> 00:06:19,440
spec and the zone spec API is more

00:06:17,850 --> 00:06:21,360
complicated than this but it looks a

00:06:19,440 --> 00:06:23,280
little bit like this where every zone

00:06:21,360 --> 00:06:25,440
has a name we can also store arbitrary

00:06:23,280 --> 00:06:27,390
properties on to our zone which will be

00:06:25,440 --> 00:06:30,000
tracked across asynchronous execution

00:06:27,390 --> 00:06:33,020
and we have a whole bunch of handlers

00:06:30,000 --> 00:06:35,370
for events like forking handling errors

00:06:33,020 --> 00:06:38,370
scheduling and canceling tasks and

00:06:35,370 --> 00:06:40,229
managing task queues well I just talked

00:06:38,370 --> 00:06:42,000
about tasks a whole bunch it might be a

00:06:40,229 --> 00:06:45,090
good idea to go back and define what we

00:06:42,000 --> 00:06:47,570
actually mean by a task so we go back to

00:06:45,090 --> 00:06:50,159
this familiar diagram of our event loop

00:06:47,570 --> 00:06:53,250
whenever our call stack does something

00:06:50,159 --> 00:06:57,300
like set a timeout or send off an xhr

00:06:53,250 --> 00:06:59,310
it's adding a potential thing to what I

00:06:57,300 --> 00:07:01,710
like to professionally call the pending

00:06:59,310 --> 00:07:03,240
tasks puddle which could be added to the

00:07:01,710 --> 00:07:05,580
callback queue at some point in the

00:07:03,240 --> 00:07:08,789
future so we can think of the pending

00:07:05,580 --> 00:07:10,830
tasks puddle as holding all of our xhrs

00:07:08,789 --> 00:07:12,719
and timeouts that at some point will be

00:07:10,830 --> 00:07:14,300
added to that callback queue which is

00:07:12,719 --> 00:07:18,870
also sometimes called a task queue

00:07:14,300 --> 00:07:20,700
handled by our code so in addition to

00:07:18,870 --> 00:07:23,370
thinking of asynchronous activity as

00:07:20,700 --> 00:07:26,400
this event loop we can think of it as a

00:07:23,370 --> 00:07:28,409
set of queues first there's the micro

00:07:26,400 --> 00:07:30,690
task queue which we talked about then

00:07:28,409 --> 00:07:32,760
there's a queue of macro tasks and I use

00:07:30,690 --> 00:07:34,500
quotes for queue here because this isn't

00:07:32,760 --> 00:07:36,690
actually a first in first out queue it's

00:07:34,500 --> 00:07:39,000
more of a set but it's easier to just

00:07:36,690 --> 00:07:42,390
use one word so this will be any event

00:07:39,000 --> 00:07:44,640
that is scheduled and has a finite time

00:07:42,390 --> 00:07:46,529
when it will end or it could be a

00:07:44,640 --> 00:07:49,380
periodic event like I said interphase

00:07:46,529 --> 00:07:50,700
and then there's a vent task queue which

00:07:49,380 --> 00:07:52,890
we don't know exactly when they're gonna

00:07:50,700 --> 00:07:55,469
fire but whenever the user clicks or

00:07:52,890 --> 00:07:59,039
Scrolls or presses a key event tasks

00:07:55,469 --> 00:08:01,140
will be fired and zones let's us hook in

00:07:59,039 --> 00:08:03,479
to things like when tasks are scheduled

00:08:01,140 --> 00:08:06,089
when tasks complete and when these

00:08:03,479 --> 00:08:08,010
queues drain and when the queues drain

00:08:06,089 --> 00:08:09,630
is especially important because that

00:08:08,010 --> 00:08:11,279
gives us really useful hooks into

00:08:09,630 --> 00:08:13,110
knowing when we should be doing certain

00:08:11,279 --> 00:08:15,599
things with our application which we'll

00:08:13,110 --> 00:08:17,099
talk about in a minute first I want to

00:08:15,599 --> 00:08:18,570
link to a couple of more zones examples

00:08:17,099 --> 00:08:20,219
because I think the best way to get a

00:08:18,570 --> 00:08:22,050
sense of how these actually work is to

00:08:20,219 --> 00:08:23,729
play around with them yourself so the

00:08:22,050 --> 00:08:26,640
zone repo has a bunch of good examples

00:08:23,729 --> 00:08:28,289
and I have a couple of examples that are

00:08:26,640 --> 00:08:30,510
similar to what I've put in this talk in

00:08:28,289 --> 00:08:32,659
my ng cone for 2016

00:08:30,510 --> 00:08:35,399
repository as well

00:08:32,659 --> 00:08:36,330
okay so we're all here at ng-conf and I

00:08:35,399 --> 00:08:38,550
promise the bank though he was using

00:08:36,330 --> 00:08:40,860
zones let's talk about how angular 2

00:08:38,550 --> 00:08:42,570
contributes to zones and this gets back

00:08:40,860 --> 00:08:45,000
to a question that Brad alluded to at

00:08:42,570 --> 00:08:47,070
the very very beginning of the day which

00:08:45,000 --> 00:08:48,510
is what happened to digest and apply we

00:08:47,070 --> 00:08:51,529
don't have to call them anymore which is

00:08:48,510 --> 00:08:55,560
great how does that actually work so

00:08:51,529 --> 00:08:57,779
angular 2 change detection is run from

00:08:55,560 --> 00:08:59,370
your applications root component down

00:08:57,779 --> 00:09:01,500
through all of its children component

00:08:59,370 --> 00:09:05,160
updating properties in a single

00:09:01,500 --> 00:09:06,990
one-directional pass so that's great how

00:09:05,160 --> 00:09:09,930
do we know when we need to run change

00:09:06,990 --> 00:09:13,410
detection the answer as you may have

00:09:09,930 --> 00:09:15,779
guessed is zones angular creates an NG

00:09:13,410 --> 00:09:18,660
zone or angular zone which every

00:09:15,779 --> 00:09:22,380
application is every angular application

00:09:18,660 --> 00:09:25,860
is run win side its own NG zone and this

00:09:22,380 --> 00:09:28,230
exports a micro test empty event and we

00:09:25,860 --> 00:09:30,269
can listen on that and that's a cue to

00:09:28,230 --> 00:09:32,010
your angular application that we might

00:09:30,269 --> 00:09:33,720
have to do change detection at this

00:09:32,010 --> 00:09:35,490
point because that means that all of our

00:09:33,720 --> 00:09:37,320
processing is finished some sort of

00:09:35,490 --> 00:09:39,180
asynchronous vents might have changed

00:09:37,320 --> 00:09:41,399
things and we should go look and see if

00:09:39,180 --> 00:09:43,350
we need to update our bindings so we

00:09:41,399 --> 00:09:45,270
don't have to a call apply and digest

00:09:43,350 --> 00:09:46,560
because angular knows about everything

00:09:45,270 --> 00:09:48,570
asynchronous that might have happened

00:09:46,560 --> 00:09:51,680
because zones knows about everything I

00:09:48,570 --> 00:09:51,680
synchronous that might have happened

00:09:52,520 --> 00:09:57,600
angular has its own that it runs your

00:09:55,079 --> 00:09:59,220
application in and this is an injectable

00:09:57,600 --> 00:10:02,850
service so you can get a hold of this

00:09:59,220 --> 00:10:04,890
inside your app and it has a similar API

00:10:02,850 --> 00:10:06,810
to the zone spec it's it's not quite the

00:10:04,890 --> 00:10:08,010
same but it lets you hook into things

00:10:06,810 --> 00:10:10,110
like when the micro test queue is empty

00:10:08,010 --> 00:10:11,760
which we use for change detection you

00:10:10,110 --> 00:10:13,980
can look at errors and then there's

00:10:11,760 --> 00:10:17,430
these two important functions run and

00:10:13,980 --> 00:10:20,459
run outside angular lets you enter and

00:10:17,430 --> 00:10:23,699
exit the angular zone in your code well

00:10:20,459 --> 00:10:27,209
why would you want to do that let's say

00:10:23,699 --> 00:10:29,610
that you have a progress meter in your

00:10:27,209 --> 00:10:31,649
application so we'll have a template

00:10:29,610 --> 00:10:33,690
that will just have a binding for the

00:10:31,649 --> 00:10:35,880
progress I'll have a button and when we

00:10:33,690 --> 00:10:38,100
click the button we'll kick off this

00:10:35,880 --> 00:10:41,100
increase progress function and all that

00:10:38,100 --> 00:10:43,500
this does is set a timeout every 10

00:10:41,100 --> 00:10:45,900
until we get to a hundred and then call

00:10:43,500 --> 00:10:48,090
a callback we can look at what this

00:10:45,900 --> 00:10:49,620
actually looks like I'm really sad I had

00:10:48,090 --> 00:10:51,600
to go after the material team because

00:10:49,620 --> 00:10:54,420
I'm not good with CSS my buttons are

00:10:51,600 --> 00:10:58,590
flat so that's good all right so we can

00:10:54,420 --> 00:11:00,630
see here angular is updating on every

00:10:58,590 --> 00:11:02,310
after every set timeout every 10

00:11:00,630 --> 00:11:03,900
microseconds progress is going from 1 to

00:11:02,310 --> 00:11:07,290
100 and we're also logging it to the

00:11:03,900 --> 00:11:09,510
console so this is this is normally what

00:11:07,290 --> 00:11:12,090
you want but maybe you don't want to run

00:11:09,510 --> 00:11:13,950
change detection after every of those 10

00:11:12,090 --> 00:11:15,180
microseconds steps you want to you want

00:11:13,950 --> 00:11:17,010
to do something else you still want the

00:11:15,180 --> 00:11:18,480
console log but you don't want angular

00:11:17,010 --> 00:11:20,430
to update because that's expensive

00:11:18,480 --> 00:11:23,010
and that's gonna interfere with our 60

00:11:20,430 --> 00:11:25,610
frames per second scrolling so instead

00:11:23,010 --> 00:11:28,230
we can run outside of the angular zone

00:11:25,610 --> 00:11:31,890
and we'll still get the progress updates

00:11:28,230 --> 00:11:33,360
in our console but our screen won't

00:11:31,890 --> 00:11:35,220
refresh and you I won't run change

00:11:33,360 --> 00:11:37,590
detection except for the very beginning

00:11:35,220 --> 00:11:40,920
and the very end let's see what that

00:11:37,590 --> 00:11:43,410
would look like in code so instead of

00:11:40,920 --> 00:11:45,720
the go function that click Handler just

00:11:43,410 --> 00:11:48,210
running the increased progress we'll run

00:11:45,720 --> 00:11:50,670
that outside of the angular zone by

00:11:48,210 --> 00:11:52,800
injecting ng zone and using its methods

00:11:50,670 --> 00:11:54,390
Edmund once were all done we've got

00:11:52,800 --> 00:11:57,120
progress to a hundred percent we'll go

00:11:54,390 --> 00:12:00,870
back into the angular zone and log bit

00:11:57,120 --> 00:12:02,880
we're done so I'm up here I usually talk

00:12:00,870 --> 00:12:04,560
about testing let's talk about testing a

00:12:02,880 --> 00:12:07,320
little bit we can use zones to really

00:12:04,560 --> 00:12:09,000
improve our testing experience and we

00:12:07,320 --> 00:12:10,380
use zones for both end-to-end and unit

00:12:09,000 --> 00:12:12,120
testing I want to talk about end-to-end

00:12:10,380 --> 00:12:16,260
first because it's actually a simpler

00:12:12,120 --> 00:12:18,290
situation for the user that you'll often

00:12:16,260 --> 00:12:20,730
have an end-to-end tests is that

00:12:18,290 --> 00:12:22,590
applications take a while to load and

00:12:20,730 --> 00:12:25,200
have asynchronous events and loading

00:12:22,590 --> 00:12:28,110
bars and progress bars and and spinners

00:12:25,200 --> 00:12:30,180
and you can get race conditions if you

00:12:28,110 --> 00:12:32,010
don't properly wait for those in your

00:12:30,180 --> 00:12:34,400
automated scripts that are interacting

00:12:32,010 --> 00:12:37,740
with your page like a user would

00:12:34,400 --> 00:12:39,570
protractor worked with angular 1 to

00:12:37,740 --> 00:12:41,670
create helpers that would automatically

00:12:39,570 --> 00:12:43,440
do this waiting for you but we can do

00:12:41,670 --> 00:12:45,180
even better in angular 2 because we can

00:12:43,440 --> 00:12:47,330
use zones so our waiting logic can be

00:12:45,180 --> 00:12:49,220
much smarter

00:12:47,330 --> 00:12:51,019
so if you're writing a protractor test

00:12:49,220 --> 00:12:52,640
before you do anything that tries to

00:12:51,019 --> 00:12:54,649
interact with the page or get data back

00:12:52,640 --> 00:12:57,320
from the page we use angular's

00:12:54,649 --> 00:13:00,560
testability API and ask it is the page

00:12:57,320 --> 00:13:02,510
stable let me know when it is behind the

00:13:00,560 --> 00:13:04,700
scenes this is roughly implemented as

00:13:02,510 --> 00:13:06,950
asking the angular zone when it's stable

00:13:04,700 --> 00:13:09,440
and then if it has no pending macro

00:13:06,950 --> 00:13:11,720
tasks so unstable roughly means your

00:13:09,440 --> 00:13:13,880
micro task queue is empty and then if we

00:13:11,720 --> 00:13:15,589
have no pending macro tasks we're good

00:13:13,880 --> 00:13:20,269
and we can run our callbacks and

00:13:15,589 --> 00:13:22,070
continue with our test script this also

00:13:20,269 --> 00:13:24,350
allows us the flexibility to fix a

00:13:22,070 --> 00:13:26,930
problem that we've had with protractor

00:13:24,350 --> 00:13:29,329
and angular one for a while which is

00:13:26,930 --> 00:13:32,839
applications often have some sort of

00:13:29,329 --> 00:13:34,910
always persistent timeout for example on

00:13:32,839 --> 00:13:36,980
the ng-conf homepage there's this nice

00:13:34,910 --> 00:13:38,930
little carousel that's showing some

00:13:36,980 --> 00:13:41,209
information and it's changing every two

00:13:38,930 --> 00:13:43,430
seconds and a natural later inclement

00:13:41,209 --> 00:13:45,320
this might be with a set interval which

00:13:43,430 --> 00:13:47,660
ticks every two seconds and shows us the

00:13:45,320 --> 00:13:49,970
next carousel image but if you try to

00:13:47,660 --> 00:13:51,589
run a protractor tense against this your

00:13:49,970 --> 00:13:54,079
application is never going to be stable

00:13:51,589 --> 00:13:56,480
because you always have some pending

00:13:54,079 --> 00:14:00,020
tasks but you can fix this as a

00:13:56,480 --> 00:14:01,850
developer by running that sent interval

00:14:00,020 --> 00:14:04,279
outside of the angular zone and then

00:14:01,850 --> 00:14:07,550
re-entering the angular zone to update

00:14:04,279 --> 00:14:09,170
the carousel image and I have a very

00:14:07,550 --> 00:14:12,850
small demo of this as well

00:14:09,170 --> 00:14:15,079
so let's actually refresh the page I

00:14:12,850 --> 00:14:21,920
don't know why this is down so we're not

00:14:15,079 --> 00:14:24,200
gonna look at that maybe at the end so

00:14:21,920 --> 00:14:26,930
so for unit tests you're also going to

00:14:24,200 --> 00:14:28,640
need to manage asynchronous execution at

00:14:26,930 --> 00:14:31,310
some point because a synchronous API is

00:14:28,640 --> 00:14:34,610
and promises are prevalent in everything

00:14:31,310 --> 00:14:36,079
that we're doing there's a couple of

00:14:34,610 --> 00:14:37,970
techniques that are out there to deal

00:14:36,079 --> 00:14:39,920
with this if you've worked with jasmine

00:14:37,970 --> 00:14:42,770
or mocha you've probably seen these two

00:14:39,920 --> 00:14:46,160
the first is to use a done callback so

00:14:42,770 --> 00:14:47,420
you would pass done as a parameter into

00:14:46,160 --> 00:14:49,640
your test function and then you would

00:14:47,420 --> 00:14:51,170
have to call it at some point so this is

00:14:49,640 --> 00:14:53,000
a couple of problems first you have to

00:14:51,170 --> 00:14:55,850
remember to call it and second you have

00:14:53,000 --> 00:14:58,970
to remember to handle failures nicely so

00:14:55,850 --> 00:14:59,699
we're toasting our toasts if anything

00:14:58,970 --> 00:15:01,799
errors

00:14:59,699 --> 00:15:03,959
what will happen here is will just get a

00:15:01,799 --> 00:15:06,179
timeout right now instead of actually

00:15:03,959 --> 00:15:07,649
sending the error message on and that's

00:15:06,179 --> 00:15:10,619
not really great behavior it's hard to

00:15:07,649 --> 00:15:12,569
debug another potential solution for

00:15:10,619 --> 00:15:14,459
dealing with this is then to return a

00:15:12,569 --> 00:15:16,220
promise from your test and have your

00:15:14,459 --> 00:15:18,869
test wait for that promise to resolve

00:15:16,220 --> 00:15:20,850
but this can also be problematic because

00:15:18,869 --> 00:15:23,339
it's very easy to forget in our return

00:15:20,850 --> 00:15:25,199
statements on promises so in this

00:15:23,339 --> 00:15:27,179
example here we would never get to that

00:15:25,199 --> 00:15:29,369
in our expectation because our outer

00:15:27,179 --> 00:15:31,319
promise would resolve and our test

00:15:29,369 --> 00:15:35,369
wouldn't actually be testing that you're

00:15:31,319 --> 00:15:38,129
toasted bread is delicious so in angular

00:15:35,369 --> 00:15:40,679
we can help out by using zones we've

00:15:38,129 --> 00:15:43,079
written to helpers that are available in

00:15:40,679 --> 00:15:45,299
the angular testing library called async

00:15:43,079 --> 00:15:47,399
and fake async which will help you deal

00:15:45,299 --> 00:15:49,619
with and give it with asynchronous

00:15:47,399 --> 00:15:52,470
activity in your zone unsurprisingly and

00:15:49,619 --> 00:15:54,419
you use these by importing them and then

00:15:52,470 --> 00:15:56,939
using them within your Jasmin style

00:15:54,419 --> 00:15:59,970
tests so you would wrap your entire test

00:15:56,939 --> 00:16:03,059
function as shown here inside of that

00:15:59,970 --> 00:16:04,709
async wrapper behind the scenes these

00:16:03,059 --> 00:16:06,209
are using zone specs that we've written

00:16:04,709 --> 00:16:08,819
that are included in the zone jeaious

00:16:06,209 --> 00:16:10,980
library which track when things are

00:16:08,819 --> 00:16:12,839
added when tasks are scheduled and when

00:16:10,980 --> 00:16:15,539
tasks are emptied out of those task

00:16:12,839 --> 00:16:18,509
queues and you could go in and use these

00:16:15,539 --> 00:16:21,720
yourself if you wanted to and then your

00:16:18,509 --> 00:16:25,109
each individual test case is run inside

00:16:21,720 --> 00:16:26,850
one of those test zones when all of the

00:16:25,109 --> 00:16:28,829
queues are completed it takes care of

00:16:26,850 --> 00:16:30,600
ending the tests for you and cleans up

00:16:28,829 --> 00:16:33,480
the zone so your next test runs in a

00:16:30,600 --> 00:16:36,749
fresh clean zone how would you actually

00:16:33,480 --> 00:16:39,419
use this for our example let's say that

00:16:36,749 --> 00:16:42,089
we have a simple widget that displays

00:16:39,419 --> 00:16:43,829
the weather for various zip codes this

00:16:42,089 --> 00:16:46,379
is going to use a service called our

00:16:43,829 --> 00:16:47,850
weather service which we will give a zip

00:16:46,379 --> 00:16:49,439
code and it'll go do some really

00:16:47,850 --> 00:16:50,579
expensive processing on the back and

00:16:49,439 --> 00:16:54,119
that's going to take a really long time

00:16:50,579 --> 00:16:56,189
and then give us back a number so in our

00:16:54,119 --> 00:16:58,350
test we'll wrap the whole thing in async

00:16:56,189 --> 00:17:00,029
we'll also use angular's injection

00:16:58,350 --> 00:17:02,609
helper because Weather Service is an

00:17:00,029 --> 00:17:04,889
injected service to grab an instance of

00:17:02,609 --> 00:17:06,630
that service and then inside our tests

00:17:04,889 --> 00:17:08,339
we can use asynchronous commands to our

00:17:06,630 --> 00:17:10,289
hearts content and rest assured that

00:17:08,339 --> 00:17:12,589
they will all complete and these

00:17:10,289 --> 00:17:15,150
expectations will actually run

00:17:12,589 --> 00:17:18,120
and we can do this with components as

00:17:15,150 --> 00:17:20,430
well so here we're also using the

00:17:18,120 --> 00:17:22,110
asynchronous rapper and we're using the

00:17:20,430 --> 00:17:24,420
test component builder which is also

00:17:22,110 --> 00:17:26,940
exported from the library to get a

00:17:24,420 --> 00:17:29,400
component fixture we'll have a weather

00:17:26,940 --> 00:17:30,810
widget will run a round of change

00:17:29,400 --> 00:17:32,760
detection the beginning just to make

00:17:30,810 --> 00:17:35,550
sure that everything is stable using the

00:17:32,760 --> 00:17:38,190
fixtures detect changes method and then

00:17:35,550 --> 00:17:40,320
we can add something out of value to the

00:17:38,190 --> 00:17:43,290
zip code input and simulate a click

00:17:40,320 --> 00:17:45,540
event on the go button okay so our

00:17:43,290 --> 00:17:47,460
widgets going it's gonna presumably show

00:17:45,540 --> 00:17:50,040
the temperature in a little while after

00:17:47,460 --> 00:17:52,710
that weather service finishes but we

00:17:50,040 --> 00:17:54,690
have a problem here the test knows to

00:17:52,710 --> 00:17:57,390
wait until the application is updated

00:17:54,690 --> 00:17:59,010
but we in the code actually also need to

00:17:57,390 --> 00:18:02,220
get a hook to that so that we can run

00:17:59,010 --> 00:18:03,960
expectations so something that we can do

00:18:02,220 --> 00:18:06,300
which is a cheap trick that we can do

00:18:03,960 --> 00:18:09,480
here is we can just set a timeout and

00:18:06,300 --> 00:18:10,530
say after two hundred milliseconds we'll

00:18:09,480 --> 00:18:13,170
run another round of change detection

00:18:10,530 --> 00:18:15,840
and then run our expectations this is

00:18:13,170 --> 00:18:17,970
not a great solution because we're

00:18:15,840 --> 00:18:20,100
introducing an artificial long timeout

00:18:17,970 --> 00:18:21,780
and we might have leakiness if our

00:18:20,100 --> 00:18:23,340
weather service takes longer than 200

00:18:21,780 --> 00:18:25,290
milliseconds this unit test will flake

00:18:23,340 --> 00:18:25,860
occasionally so we can do better than

00:18:25,290 --> 00:18:29,130
this

00:18:25,860 --> 00:18:31,110
the fixture API now includes a when

00:18:29,130 --> 00:18:32,550
stable function which is similar to the

00:18:31,110 --> 00:18:34,890
one that we talked about for end-to-end

00:18:32,550 --> 00:18:36,630
testing that'll let us hook into when

00:18:34,890 --> 00:18:39,240
our macro tests in micro tests are empty

00:18:36,630 --> 00:18:41,250
so instead of having a hack with a set

00:18:39,240 --> 00:18:43,260
timeout we can just ask the mixture when

00:18:41,250 --> 00:18:45,720
it's stable and then run our final

00:18:43,260 --> 00:18:48,150
expectations and we've done one other

00:18:45,720 --> 00:18:50,190
thing in this test at the top we've

00:18:48,150 --> 00:18:52,230
asked the fixture to automatically run

00:18:50,190 --> 00:18:54,540
change detection whenever it thinks that

00:18:52,230 --> 00:18:56,910
we need to this is usually a good idea

00:18:54,540 --> 00:18:59,130
to call immediately in your component

00:18:56,910 --> 00:19:02,910
tests unless you need precise control of

00:18:59,130 --> 00:19:04,410
change detection for some reason all

00:19:02,910 --> 00:19:07,380
right the last thing that I want to talk

00:19:04,410 --> 00:19:09,420
about is the fake async helper this is

00:19:07,380 --> 00:19:11,880
useful for when you need precise control

00:19:09,420 --> 00:19:14,430
of timing to really check that something

00:19:11,880 --> 00:19:16,740
works in your component so let's say

00:19:14,430 --> 00:19:18,480
that we have a component which plays

00:19:16,740 --> 00:19:21,770
rock-paper-scissors with you it's going

00:19:18,480 --> 00:19:25,580
to count down from 3 to 1 and

00:19:21,770 --> 00:19:26,900
throw rock paper or scissors and so we

00:19:25,580 --> 00:19:28,760
don't want to just test the beginning

00:19:26,900 --> 00:19:30,350
state in the very end state we want to

00:19:28,760 --> 00:19:34,400
ensure that it's actually running that

00:19:30,350 --> 00:19:36,140
countdown and changing every second we

00:19:34,400 --> 00:19:38,090
can do this with the fake async wrapper

00:19:36,140 --> 00:19:39,770
so instead of wrapping our entire test

00:19:38,090 --> 00:19:42,590
in a sink we're wrapping in fake async

00:19:39,770 --> 00:19:45,080
we'll set up our fixture as before and

00:19:42,590 --> 00:19:48,170
we'll set up a click event on our Start

00:19:45,080 --> 00:19:50,210
button and now since we're using fake

00:19:48,170 --> 00:19:52,190
async we get access to this helper

00:19:50,210 --> 00:19:54,140
method called tick which simulates

00:19:52,190 --> 00:19:56,570
moving time forward by the amount that

00:19:54,140 --> 00:19:59,059
you place in there so we'll move time

00:19:56,570 --> 00:20:00,920
forward by one second run change

00:19:59,059 --> 00:20:03,679
detection again and assert that our

00:20:00,920 --> 00:20:04,970
component has updated as expected and we

00:20:03,679 --> 00:20:07,429
can do that through to the end of the

00:20:04,970 --> 00:20:09,020
test I think I think will warn you if at

00:20:07,429 --> 00:20:11,620
the end of your test you still have

00:20:09,020 --> 00:20:15,050
anything pending but it knows about

00:20:11,620 --> 00:20:17,420
behind the scenes this uses zones to

00:20:15,050 --> 00:20:20,330
actually intercept and not forward on

00:20:17,420 --> 00:20:22,250
requests to schedule tasks so fake async

00:20:20,330 --> 00:20:24,740
is keeping track of its own queues of

00:20:22,250 --> 00:20:26,840
events and firing them manually and

00:20:24,740 --> 00:20:27,910
truly synchronously when you call the

00:20:26,840 --> 00:20:31,190
tick correction

00:20:27,910 --> 00:20:33,380
all right for some further reading and

00:20:31,190 --> 00:20:36,290
to see all of the examples that I put up

00:20:33,380 --> 00:20:38,990
here live I have a github repository for

00:20:36,290 --> 00:20:42,890
ng-conf 2016 zones there's also several

00:20:38,990 --> 00:20:44,690
good podcasts and blogs about micro

00:20:42,890 --> 00:20:49,270
tasks and zones but would be really

00:20:44,690 --> 00:20:49,270

YouTube URL: https://www.youtube.com/watch?v=DltUEDy7ItY


