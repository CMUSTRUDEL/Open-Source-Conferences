Title: Super TypeScript II Turbo â€“ FP Remix - Sean May
Publication date: 2017-04-30
Playlist: ng-conf 2017 Advanced Talks
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,030 --> 00:00:06,899
hey guys Jeff Foxworthy was right I

00:00:03,060 --> 00:00:10,980
might be Sean Nye and this might be a

00:00:06,899 --> 00:00:13,469
functional programming talk I'm sorry

00:00:10,980 --> 00:00:15,450
I hope lunch was great just before we

00:00:13,469 --> 00:00:17,880
get started I want to say a huge thank

00:00:15,450 --> 00:00:19,470
you to my friend and colleague Fatima

00:00:17,880 --> 00:00:24,480
who's an awesome designer who put that

00:00:19,470 --> 00:00:29,039
together now just show of hands or a

00:00:24,480 --> 00:00:32,149
show of wus who here came from java and

00:00:29,039 --> 00:00:36,210
then spring and who loves that ecosystem

00:00:32,149 --> 00:00:40,640
awesome okay who loves a c-sharp and

00:00:36,210 --> 00:00:44,460
dotnet and that world awesome

00:00:40,640 --> 00:00:47,930
who here is a gigantic functional

00:00:44,460 --> 00:00:53,399
programming nerd who loves javascript

00:00:47,930 --> 00:00:55,770
yeah okay so my goal is to not let that

00:00:53,399 --> 00:00:58,079
happen my goal is by the end of the talk

00:00:55,770 --> 00:00:59,879
to have everybody have some common

00:00:58,079 --> 00:01:02,340
ground in terms of typescript and

00:00:59,879 --> 00:01:04,339
functional programming right so this is

00:01:02,340 --> 00:01:10,260
going to get really nerdy I apologize

00:01:04,339 --> 00:01:13,130
but it will feel better in a bit so once

00:01:10,260 --> 00:01:16,590
again like Jeff Foxworthy said that's me

00:01:13,130 --> 00:01:19,110
I'm on Twitter at John Jay May and I am

00:01:16,590 --> 00:01:20,850
nor guard on Stack Overflow I apologize

00:01:19,110 --> 00:01:26,280
if you have yelled at me in the past

00:01:20,850 --> 00:01:30,000
this this is the reason that I got into

00:01:26,280 --> 00:01:32,130
functional programming I have seen too

00:01:30,000 --> 00:01:34,049
many code bases look like this in too

00:01:32,130 --> 00:01:39,840
many languages how many people are with

00:01:34,049 --> 00:01:42,420
me awesome so I found myself in

00:01:39,840 --> 00:01:46,049
positions where I was asked to fix code

00:01:42,420 --> 00:01:48,479
bases that I had you know no hand in but

00:01:46,049 --> 00:01:53,549
even just making the tiniest little

00:01:48,479 --> 00:01:57,030
change sort of felt like I was up

00:01:53,549 --> 00:02:00,659
against that and when I'm looking at my

00:01:57,030 --> 00:02:03,329
IDE and that is staring back at me I do

00:02:00,659 --> 00:02:08,330
not feel empowered to work with that

00:02:03,329 --> 00:02:12,270
code base all right so that brings me to

00:02:08,330 --> 00:02:15,780
thinking that really I need

00:02:12,270 --> 00:02:17,910
some strategy for working with code for

00:02:15,780 --> 00:02:19,890
writing systems I need something that's

00:02:17,910 --> 00:02:22,980
lightweight adaptable simple and

00:02:19,890 --> 00:02:28,070
dependable and it turns out that this

00:02:22,980 --> 00:02:34,470
talk is actually about chun-li right

00:02:28,070 --> 00:02:36,750
quick agile tactical technical right so

00:02:34,470 --> 00:02:39,030
because of that and because of the

00:02:36,750 --> 00:02:41,430
Street Fighter tie-in we're going to

00:02:39,030 --> 00:02:42,810
talk about a strategy guide right a

00:02:41,430 --> 00:02:45,360
strategy guide to functional programming

00:02:42,810 --> 00:02:46,740
in typescript we're going to start with

00:02:45,360 --> 00:02:48,270
the basics then we're going to move on

00:02:46,740 --> 00:02:51,660
to the combos and then we're going to

00:02:48,270 --> 00:02:55,700
see some special moves hopefully all

00:02:51,660 --> 00:02:55,700
right so let's start with the basics

00:02:57,260 --> 00:03:03,330
pure functions right I have a function

00:03:01,470 --> 00:03:05,670
that does nothing but take two numbers

00:03:03,330 --> 00:03:07,440
and return a number right that the

00:03:05,670 --> 00:03:09,900
concept of pure functions is that they

00:03:07,440 --> 00:03:12,120
don't modify anything outside of them

00:03:09,900 --> 00:03:14,520
you can run that a million times and you

00:03:12,120 --> 00:03:18,480
will always get the same answer right if

00:03:14,520 --> 00:03:20,850
I make that a little more complex you

00:03:18,480 --> 00:03:22,620
can see that it's a little more

00:03:20,850 --> 00:03:24,630
convoluted I've got all of this type

00:03:22,620 --> 00:03:27,210
information in there but all I'm doing

00:03:24,630 --> 00:03:30,300
is making some new vector2 calculate

00:03:27,210 --> 00:03:33,540
distance and then I am making and

00:03:30,300 --> 00:03:36,360
returning a new position based on that

00:03:33,540 --> 00:03:38,670
data rather than just modifying the old

00:03:36,360 --> 00:03:40,950
position that I had and the reasoning

00:03:38,670 --> 00:03:42,690
for that is actually pretty simple have

00:03:40,950 --> 00:03:45,780
you ever worked in a code base where the

00:03:42,690 --> 00:03:50,480
one on top doesn't work and the one on

00:03:45,780 --> 00:03:54,750
the bottom does is anybody not seen that

00:03:50,480 --> 00:03:57,920
all right so the answer is obvious right

00:03:54,750 --> 00:04:03,000
you just move C up and everything works

00:03:57,920 --> 00:04:05,610
come on right so why pure functions no

00:04:03,000 --> 00:04:07,950
races no surprises that is extra true

00:04:05,610 --> 00:04:09,930
for threading right it's easy to debug

00:04:07,950 --> 00:04:11,700
and you get this magical thing called

00:04:09,930 --> 00:04:14,720
referential transparency that will show

00:04:11,700 --> 00:04:18,810
up later don't worry about that for now

00:04:14,720 --> 00:04:20,100
right so next on our list of basics we

00:04:18,810 --> 00:04:21,570
have higher-order functions and

00:04:20,100 --> 00:04:24,670
higher-order functions come in two

00:04:21,570 --> 00:04:26,440
flavors the first flavor is a function

00:04:24,670 --> 00:04:29,560
returns a function and the second flavor

00:04:26,440 --> 00:04:31,900
is a function that accepts a function

00:04:29,560 --> 00:04:33,670
right in JavaScript we do that all the

00:04:31,900 --> 00:04:37,120
time in callbacks again we'll see that

00:04:33,670 --> 00:04:39,820
in a bit so the first kind a function

00:04:37,120 --> 00:04:41,890
that returns a function remember X right

00:04:39,820 --> 00:04:45,730
I pass in a number I get a function back

00:04:41,890 --> 00:04:49,420
that function that returns returns the X

00:04:45,730 --> 00:04:51,940
all right so I'm saving out X 6 X 10 X

00:04:49,420 --> 00:04:57,610
23 for the nerdy in the room those are

00:04:51,940 --> 00:04:59,230
web and X members so I can call each one

00:04:57,610 --> 00:05:06,190
of those functions and it will return

00:04:59,230 --> 00:05:09,880
the remembered number right now if the

00:05:06,190 --> 00:05:13,390
arrow functions are a little odd to you

00:05:09,880 --> 00:05:17,230
we can do this in the es5 way right so

00:05:13,390 --> 00:05:18,940
the es5 way the necessary typing which

00:05:17,230 --> 00:05:21,820
is enough typing for typescript to know

00:05:18,940 --> 00:05:23,260
what's going on we have remember X which

00:05:21,820 --> 00:05:27,040
takes a number and returns a function

00:05:23,260 --> 00:05:29,950
which returns the X all right the extra

00:05:27,040 --> 00:05:31,990
typing the very explicit typing right we

00:05:29,950 --> 00:05:34,330
have a function remember X which takes a

00:05:31,990 --> 00:05:37,840
number which returns a type function

00:05:34,330 --> 00:05:39,940
number which returns a function of type

00:05:37,840 --> 00:05:41,470
number which returns number but that

00:05:39,940 --> 00:05:42,970
that might be a little overkill but if

00:05:41,470 --> 00:05:47,530
you think that's overkill be explicit

00:05:42,970 --> 00:05:51,580
typing for the es6 version is this right

00:05:47,530 --> 00:05:53,830
so being explicit is not always a great

00:05:51,580 --> 00:05:56,730
thing right this is way more information

00:05:53,830 --> 00:05:59,710
than typescript needs to do its job in

00:05:56,730 --> 00:06:04,210
fact the information that typescript

00:05:59,710 --> 00:06:05,620
needs to do its job is that right that's

00:06:04,210 --> 00:06:07,660
going to do all of your type checking

00:06:05,620 --> 00:06:09,280
for you if you have intellisense it's

00:06:07,660 --> 00:06:13,030
going to tell you what the type is of

00:06:09,280 --> 00:06:14,710
the returned function or the number it

00:06:13,030 --> 00:06:19,300
is smart enough to do that so that we

00:06:14,710 --> 00:06:23,140
don't have to care all right so again

00:06:19,300 --> 00:06:25,180
moving a little forward we see clamp we

00:06:23,140 --> 00:06:27,850
have a min and a max which returns a

00:06:25,180 --> 00:06:29,830
function X this lets me make multiple

00:06:27,850 --> 00:06:32,470
clamps and clamp to multiple values

00:06:29,830 --> 00:06:34,450
right I can clamp X and I can clamp Y

00:06:32,470 --> 00:06:36,370
and those are just reusable functions

00:06:34,450 --> 00:06:38,500
now I can I can use them all over my

00:06:36,370 --> 00:06:42,160
system right so I can make a

00:06:38,500 --> 00:06:46,240
new point based on clamp X&Y based on my

00:06:42,160 --> 00:06:49,660
current position this gets into the

00:06:46,240 --> 00:06:53,920
second form and starts blending the two

00:06:49,660 --> 00:06:55,420
I'm passing in a test now so once I pass

00:06:53,920 --> 00:06:58,750
in a test I get back a function that

00:06:55,420 --> 00:07:00,790
expects an A and B and I test that one

00:06:58,750 --> 00:07:02,920
way I test it the other way and I'm

00:07:00,790 --> 00:07:04,960
going to return 1 negative 1 or 0 based

00:07:02,920 --> 00:07:08,560
on how things go right you've seen that

00:07:04,960 --> 00:07:11,140
in sorts all over the place but what's

00:07:08,560 --> 00:07:14,290
really handy here is I can make these

00:07:11,140 --> 00:07:16,960
ascending and descending sorts save them

00:07:14,290 --> 00:07:21,640
in my system and reuse them all over the

00:07:16,960 --> 00:07:24,580
place that is the benefit of this type

00:07:21,640 --> 00:07:26,320
of higher-order function so I know what

00:07:24,580 --> 00:07:29,740
you're thinking that looks like a whole

00:07:26,320 --> 00:07:31,630
lot of any doesn't it and you're right

00:07:29,740 --> 00:07:35,590
that might lead to a whole lot of any's

00:07:31,630 --> 00:07:37,210
I have you covered right we're not going

00:07:35,590 --> 00:07:38,950
to spend a whole lot of time here but if

00:07:37,210 --> 00:07:43,390
you look I've got types for a comparator

00:07:38,950 --> 00:07:45,550
comparison and compare and really one is

00:07:43,390 --> 00:07:47,500
a typed function using generics the

00:07:45,550 --> 00:07:51,370
other is a type function using generics

00:07:47,500 --> 00:07:54,840
and again I have the third one which is

00:07:51,370 --> 00:07:57,130
another generic function which returns a

00:07:54,840 --> 00:07:59,669
comparison after you handed a comparator

00:07:57,130 --> 00:08:03,010
and that will remember all of the types

00:07:59,669 --> 00:08:04,870
right so the code below again those

00:08:03,010 --> 00:08:07,150
types shouldn't be there with the code

00:08:04,870 --> 00:08:13,030
but the code below can look that clean

00:08:07,150 --> 00:08:16,030
and be type safe why it is reusable it's

00:08:13,030 --> 00:08:18,760
configurable I'm separating what I'm

00:08:16,030 --> 00:08:24,370
doing from how I'm doing it and I can

00:08:18,760 --> 00:08:27,100
combine these map and filter our other

00:08:24,370 --> 00:08:30,340
very very basics through primitives

00:08:27,100 --> 00:08:32,890
right so to uppercase on a string just

00:08:30,340 --> 00:08:35,080
call string to uppercase right so I can

00:08:32,890 --> 00:08:37,930
map over that array and call to

00:08:35,080 --> 00:08:39,880
uppercase on it and I get ABC back again

00:08:37,930 --> 00:08:41,469
I can do the same thing with filter and

00:08:39,880 --> 00:08:43,270
pass it a predicate rather than a

00:08:41,469 --> 00:08:48,670
transform and it's going to return me

00:08:43,270 --> 00:08:53,070
the right thing and you replayed that

00:08:48,670 --> 00:08:56,270
slide that's okay go me okay

00:08:53,070 --> 00:08:58,500
again that this doesn't have to be just

00:08:56,270 --> 00:09:02,160
functions in and of itself I have a

00:08:58,500 --> 00:09:04,590
point here with a static from method and

00:09:02,160 --> 00:09:07,650
that's going to take some coordinate and

00:09:04,590 --> 00:09:11,760
it's going to return a point right so I

00:09:07,650 --> 00:09:13,860
can use map and just passing point from

00:09:11,760 --> 00:09:16,920
and get a list of points out of a list

00:09:13,860 --> 00:09:18,660
of coordinates I don't actually have to

00:09:16,920 --> 00:09:21,930
run that function and new all of those

00:09:18,660 --> 00:09:23,790
things that from which is called an

00:09:21,930 --> 00:09:24,960
isomorphism again really nerdy don't

00:09:23,790 --> 00:09:27,630
worry about that

00:09:24,960 --> 00:09:29,850
we'll take care of that for you pick up

00:09:27,630 --> 00:09:33,630
items right I can map items and I can

00:09:29,850 --> 00:09:36,480
filter where each item is in range based

00:09:33,630 --> 00:09:37,950
on where it is and where I am right and

00:09:36,480 --> 00:09:40,620
all of the picked up items from that

00:09:37,950 --> 00:09:45,150
tick are going to be based on that

00:09:40,620 --> 00:09:48,180
filter predicate passing why again I'm

00:09:45,150 --> 00:09:49,830
separating the logic from the flow I get

00:09:48,180 --> 00:09:51,570
to define these tiny little functions

00:09:49,830 --> 00:09:54,300
which do one job and do that really

00:09:51,570 --> 00:09:56,160
really well and then just control how

00:09:54,300 --> 00:09:58,470
that flows through my system it's a very

00:09:56,160 --> 00:10:00,810
simple pattern to pick up and the

00:09:58,470 --> 00:10:02,190
paradigm of map and filter apply to way

00:10:00,810 --> 00:10:05,100
more than a raise we'll get there and

00:10:02,190 --> 00:10:09,300
they're very easy to chain speaking of

00:10:05,100 --> 00:10:11,760
chaining that leads us to combos and so

00:10:09,300 --> 00:10:15,330
you want to combine functions as a

00:10:11,760 --> 00:10:19,500
pipeline for data we have this updated

00:10:15,330 --> 00:10:21,090
player which is going to take some

00:10:19,500 --> 00:10:23,220
player and it's going to run it through

00:10:21,090 --> 00:10:24,510
update player position then it's going

00:10:23,220 --> 00:10:26,790
to run it through update player

00:10:24,510 --> 00:10:30,810
animation and at the end of that I have

00:10:26,790 --> 00:10:32,520
this new updated player again we might

00:10:30,810 --> 00:10:35,190
do that for threading purposes we might

00:10:32,520 --> 00:10:37,230
do it for concurrency purposes we might

00:10:35,190 --> 00:10:39,960
just do it for memory safety and and

00:10:37,230 --> 00:10:43,470
module management and doesn't really

00:10:39,960 --> 00:10:46,230
matter so I have this updated player or

00:10:43,470 --> 00:10:48,720
I could just run that updated player

00:10:46,230 --> 00:10:50,820
through update player animation passing

00:10:48,720 --> 00:10:54,120
in repositioned player that I already

00:10:50,820 --> 00:10:56,250
got from somewhere else right or that

00:10:54,120 --> 00:10:59,040
function could do double duty and I pass

00:10:56,250 --> 00:11:00,630
in player this is actually the magic of

00:10:59,040 --> 00:11:03,030
referential transparency that I was

00:11:00,630 --> 00:11:05,100
talking about before and referential

00:11:03,030 --> 00:11:07,250
transparency basically means that it

00:11:05,100 --> 00:11:10,440
doesn't matter which one of these I use

00:11:07,250 --> 00:11:15,030
because the return value of a function

00:11:10,440 --> 00:11:16,800
is the same as having a value that is

00:11:15,030 --> 00:11:19,080
equal to the transformation of that

00:11:16,800 --> 00:11:22,200
function I can replace a function call

00:11:19,080 --> 00:11:27,060
with a value that is represented by its

00:11:22,200 --> 00:11:31,200
return all right so compose lets me

00:11:27,060 --> 00:11:34,020
simplify this I can take two functions G

00:11:31,200 --> 00:11:37,680
and F and return a function that expects

00:11:34,020 --> 00:11:42,870
X and as soon as I run that over X

00:11:37,680 --> 00:11:45,630
whatever X is I will run F over X and

00:11:42,870 --> 00:11:48,030
then i will run g over the return of f

00:11:45,630 --> 00:11:50,190
of X again that's the referential

00:11:48,030 --> 00:11:52,980
transparency talking it wouldn't matter

00:11:50,190 --> 00:11:59,310
whether it was f of X or it was just

00:11:52,980 --> 00:12:01,530
some F F X transformed value right so I

00:11:59,310 --> 00:12:03,720
can add one in double and you can see I

00:12:01,530 --> 00:12:07,560
have this compose function where I am

00:12:03,720 --> 00:12:11,010
passing two functions x returns X plus 1

00:12:07,560 --> 00:12:15,150
and X returns x times 2 and the written

00:12:11,010 --> 00:12:16,860
upside down because math if you look at

00:12:15,150 --> 00:12:18,960
the body of the compose function you'll

00:12:16,860 --> 00:12:21,270
actually see why it turns out

00:12:18,960 --> 00:12:25,080
upside-down once you start adding new

00:12:21,270 --> 00:12:30,660
lines so an add one on double on three

00:12:25,080 --> 00:12:32,280
is going to be eight and again to combat

00:12:30,660 --> 00:12:36,750
the people who are like what about be

00:12:32,280 --> 00:12:39,120
any type I have a transform type that

00:12:36,750 --> 00:12:41,280
takes some function with the generic a

00:12:39,120 --> 00:12:44,220
and returns a generic B write and

00:12:41,280 --> 00:12:48,660
compose just takes three generic

00:12:44,220 --> 00:12:50,970
arguments ABC and it takes the first

00:12:48,660 --> 00:12:52,770
transform from A to B it takes the

00:12:50,970 --> 00:12:54,660
second transform from B to C and it

00:12:52,770 --> 00:12:57,120
returns a new function that is a

00:12:54,660 --> 00:12:58,350
transform from A to C right so it's

00:12:57,120 --> 00:13:02,040
hiding what's going on under the covers

00:12:58,350 --> 00:13:04,020
it's saying give me the functions I will

00:13:02,040 --> 00:13:06,300
return a function that takes your input

00:13:04,020 --> 00:13:08,760
value and returns your output value and

00:13:06,300 --> 00:13:13,080
again typescript is going to hold onto

00:13:08,760 --> 00:13:16,170
all of that so the compose of this

00:13:13,080 --> 00:13:17,990
particular type again totally typesafe

00:13:16,170 --> 00:13:19,430
despite the fact that you can't

00:13:17,990 --> 00:13:21,350
should we see any of the types defined

00:13:19,430 --> 00:13:24,050
in their type script we'll figure those

00:13:21,350 --> 00:13:26,810
out the one type that I'm adding is

00:13:24,050 --> 00:13:30,140
actually the type of the input value for

00:13:26,810 --> 00:13:32,690
the first function x equals number as

00:13:30,140 --> 00:13:34,160
long as I pass that in type script is

00:13:32,690 --> 00:13:35,779
smart enough to be able to follow the

00:13:34,160 --> 00:13:38,890
chain all the way back up and figure out

00:13:35,779 --> 00:13:38,890
what you're getting at the tail end

00:13:39,339 --> 00:13:45,260
right so again in a slightly larger

00:13:43,100 --> 00:13:47,270
example player update is just a

00:13:45,260 --> 00:13:49,490
transform from player to some new player

00:13:47,270 --> 00:13:51,830
right and I have update position update

00:13:49,490 --> 00:13:55,459
animation update health and update all

00:13:51,830 --> 00:13:58,070
is going to be a compose of update

00:13:55,459 --> 00:14:00,580
health and also the composition of

00:13:58,070 --> 00:14:03,620
update animation an update position

00:14:00,580 --> 00:14:08,570
right so I can compose composed

00:14:03,620 --> 00:14:10,100
functions and this is where functional

00:14:08,570 --> 00:14:12,529
programming sort of gets a little

00:14:10,100 --> 00:14:14,720
magical but as long as you remember that

00:14:12,529 --> 00:14:17,149
I'm returning new values on not doing

00:14:14,720 --> 00:14:20,750
anything magical with private state it's

00:14:17,149 --> 00:14:23,120
just input and output then I can compose

00:14:20,750 --> 00:14:25,760
these all day long and typescript will

00:14:23,120 --> 00:14:31,640
be totally happy with it and so will

00:14:25,760 --> 00:14:33,110
your codebase hopefully so again a

00:14:31,640 --> 00:14:36,200
different type of chaining a different

00:14:33,110 --> 00:14:40,399
type of combo is chaining map and filter

00:14:36,200 --> 00:14:43,399
calls in a pipeline right so injured

00:14:40,399 --> 00:14:46,100
enemies if I want to deal damage all I

00:14:43,399 --> 00:14:48,800
need to do is filter for all of the

00:14:46,100 --> 00:14:53,329
enemies that are in range of some attack

00:14:48,800 --> 00:14:56,270
range some attack radius and map deal

00:14:53,329 --> 00:14:58,610
damage over them with that damage value

00:14:56,270 --> 00:15:00,709
right and what comes back is a list of

00:14:58,610 --> 00:15:03,680
enemies that have taken damage this

00:15:00,709 --> 00:15:06,829
round and it will only be those enemies

00:15:03,680 --> 00:15:08,630
right so again updated players I can map

00:15:06,829 --> 00:15:10,160
over a list of all players and pass in

00:15:08,630 --> 00:15:14,230
that update all function that we just

00:15:10,160 --> 00:15:16,480
rode now really important to note

00:15:14,230 --> 00:15:18,709
mapping is not about loops at all

00:15:16,480 --> 00:15:22,820
mapping is actually about going from

00:15:18,709 --> 00:15:25,750
Taipei to type B and this is key right

00:15:22,820 --> 00:15:28,820
so if I've got that transform again and

00:15:25,750 --> 00:15:30,840
I have some map to point which takes a

00:15:28,820 --> 00:15:33,270
coordinate and returns a point

00:15:30,840 --> 00:15:35,580
and I'm just calling point from which we

00:15:33,270 --> 00:15:37,560
saw earlier I can call that on a new

00:15:35,580 --> 00:15:40,500
coordinate and get a new point that's a

00:15:37,560 --> 00:15:42,840
map right I can take an array of

00:15:40,500 --> 00:15:45,600
coordinates and map map to point over

00:15:42,840 --> 00:15:49,410
them and I get an array of points I can

00:15:45,600 --> 00:15:51,570
take a promise and then it over map to

00:15:49,410 --> 00:15:56,370
point and get a promise of a point back

00:15:51,570 --> 00:15:58,560
I can take some stream observable stream

00:15:56,370 --> 00:16:02,339
and map map to point over it and get an

00:15:58,560 --> 00:16:04,890
observable of points back right

00:16:02,339 --> 00:16:09,240
typescript again will remember all of

00:16:04,890 --> 00:16:10,370
those types and keep you safe well that

00:16:09,240 --> 00:16:14,250
was interesting

00:16:10,370 --> 00:16:16,230
now the why it becomes really easy to

00:16:14,250 --> 00:16:18,360
reason about with practice you can build

00:16:16,230 --> 00:16:21,690
pretty big systems with this technique

00:16:18,360 --> 00:16:24,330
right dataflow is predictable if you

00:16:21,690 --> 00:16:26,730
have separated your functions and your

00:16:24,330 --> 00:16:29,490
transformations from how your composing

00:16:26,730 --> 00:16:31,500
systems then your system just has to

00:16:29,490 --> 00:16:36,000
worry about what is my input and what is

00:16:31,500 --> 00:16:39,360
my output Uncle Bob would actually be a

00:16:36,000 --> 00:16:41,130
very big fan of that it's easy to add or

00:16:39,360 --> 00:16:42,660
change links in the chain so if somebody

00:16:41,130 --> 00:16:44,910
comes along and says you also need to

00:16:42,660 --> 00:16:47,520
filter for this case you add a filter in

00:16:44,910 --> 00:16:50,280
the middle of that pipeline and you're

00:16:47,520 --> 00:16:52,290
done right and you can logic about where

00:16:50,280 --> 00:16:55,170
that filter fits it's easy to compose

00:16:52,290 --> 00:16:57,750
functions in a chain and if each link is

00:16:55,170 --> 00:17:01,230
pure pure function then the whole chain

00:16:57,750 --> 00:17:03,630
is pure and that's great news because

00:17:01,230 --> 00:17:06,329
then you can use that whole chain as the

00:17:03,630 --> 00:17:08,310
input to some other composition and it's

00:17:06,329 --> 00:17:09,990
testable right you can test the logic of

00:17:08,310 --> 00:17:15,480
an individual function and you can test

00:17:09,990 --> 00:17:19,579
the chain as a whole okay so the last

00:17:15,480 --> 00:17:22,920
piece special moves

00:17:19,579 --> 00:17:26,310
we have read-only we have pick and we

00:17:22,920 --> 00:17:32,190
have record and we'll spend a little

00:17:26,310 --> 00:17:37,770
time on each so read-only is actually a

00:17:32,190 --> 00:17:40,620
really really handy and type it's it's

00:17:37,770 --> 00:17:44,070
basically an interface which will take

00:17:40,620 --> 00:17:44,700
in whatever generic you pass it and it

00:17:44,070 --> 00:17:48,270
will

00:17:44,700 --> 00:17:52,470
then tell the compiler to expect that

00:17:48,270 --> 00:17:56,970
all of the members of that type are

00:17:52,470 --> 00:18:00,300
read-only right so if you wanted to make

00:17:56,970 --> 00:18:02,520
read-only immutable classes in

00:18:00,300 --> 00:18:04,740
typescript you usually have to declare a

00:18:02,520 --> 00:18:07,740
member read-only like a read-only

00:18:04,740 --> 00:18:11,330
private or a read-only public now you

00:18:07,740 --> 00:18:12,510
can just say it's a read-only account

00:18:11,330 --> 00:18:15,390
right

00:18:12,510 --> 00:18:18,620
so if I get account by ID and it returns

00:18:15,390 --> 00:18:23,040
me a read-only account if I try to

00:18:18,620 --> 00:18:25,650
manage that if I try to change the value

00:18:23,040 --> 00:18:29,490
it's going to throw an error at that

00:18:25,650 --> 00:18:32,300
compile time in my editor if I have some

00:18:29,490 --> 00:18:35,970
tamper-proof function which takes a

00:18:32,300 --> 00:18:38,640
read-only and returns a read-only then I

00:18:35,970 --> 00:18:41,160
can handle transactions with wallets

00:18:38,640 --> 00:18:42,810
with the expectation that my code is not

00:18:41,160 --> 00:18:50,970
allowed to mutate the state of any

00:18:42,810 --> 00:18:54,060
wallet that is a pretty big deal right

00:18:50,970 --> 00:18:56,190
caveat implementer it doesn't save you

00:18:54,060 --> 00:19:00,690
from mutating private state in method

00:18:56,190 --> 00:19:08,100
calls so do this with structs and not

00:19:00,690 --> 00:19:11,130
with java esque classes alright so here

00:19:08,100 --> 00:19:12,570
we have a pick and this is a little

00:19:11,130 --> 00:19:13,980
harder to see because it requires a

00:19:12,570 --> 00:19:18,980
little bit of setup but the point of

00:19:13,980 --> 00:19:22,770
pick is to pick a subset of an object

00:19:18,980 --> 00:19:25,740
with the types intact so if you were

00:19:22,770 --> 00:19:28,350
just copying key value pairs on to some

00:19:25,740 --> 00:19:29,880
new object to get a subset typescript is

00:19:28,350 --> 00:19:34,050
usually going to say that object is

00:19:29,880 --> 00:19:35,640
Danny right I have no way of

00:19:34,050 --> 00:19:38,490
guaranteeing that those types aren't

00:19:35,640 --> 00:19:41,010
going to change but here I'm saying I've

00:19:38,490 --> 00:19:44,370
got some band member and I'm going to

00:19:41,010 --> 00:19:46,380
pick the keys of person out of them so

00:19:44,370 --> 00:19:48,960
as long as all of the keys of person are

00:19:46,380 --> 00:19:51,450
within band member typescript is going

00:19:48,960 --> 00:19:56,340
to remember the types off band member

00:19:51,450 --> 00:19:57,590
if those two types diverge typescript is

00:19:56,340 --> 00:20:02,690
going to complain

00:19:57,590 --> 00:20:04,400
if you have a key in person that is not

00:20:02,690 --> 00:20:15,140
in band member typescript is going to

00:20:04,400 --> 00:20:18,800
complain hey that's funny just before

00:20:15,140 --> 00:20:25,130
that that's where that missing slide

00:20:18,800 --> 00:20:28,520
went okay so with record the point is

00:20:25,130 --> 00:20:31,670
you can specify types of keys

00:20:28,520 --> 00:20:35,960
dynamically you can build a record to

00:20:31,670 --> 00:20:38,870
say my fields are going to be a or B or

00:20:35,960 --> 00:20:41,330
C or D and all of them are going to be

00:20:38,870 --> 00:20:47,390
of type number or type string or type

00:20:41,330 --> 00:20:48,760
person so with that in mind thank you

00:20:47,390 --> 00:20:52,859
very much

00:20:48,760 --> 00:20:52,859
[Applause]

00:20:58,200 --> 00:21:00,260

YouTube URL: https://www.youtube.com/watch?v=9oVKjZrgXmU


