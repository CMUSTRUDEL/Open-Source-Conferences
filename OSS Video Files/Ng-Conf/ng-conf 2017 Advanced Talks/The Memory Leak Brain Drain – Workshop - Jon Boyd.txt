Title: The Memory Leak Brain Drain â€“ Workshop - Jon Boyd
Publication date: 2017-04-30
Playlist: ng-conf 2017 Advanced Talks
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,260 --> 00:00:03,649
so I'm going to start out by saying I

00:00:02,600 --> 00:00:06,410
thought there's going to be like 20

00:00:03,649 --> 00:00:11,709
people here so thanks for making me

00:00:06,410 --> 00:00:15,259
nervous again yeah some John from Canada

00:00:11,709 --> 00:00:17,720
that's my whole bio actually my whole

00:00:15,259 --> 00:00:19,520
bio normally is just famous ng comp

00:00:17,720 --> 00:00:23,060
speaker now there's a bunch of us here

00:00:19,520 --> 00:00:25,600
so I can't say that anymore I'm a lead

00:00:23,060 --> 00:00:28,190
developer mostly I do front-end UI stuff

00:00:25,600 --> 00:00:31,490
and get tossed all the memory leak

00:00:28,190 --> 00:00:32,840
problems when they come up go this link

00:00:31,490 --> 00:00:35,030
if you want to look at the slides

00:00:32,840 --> 00:00:40,370
there's a ton of notes that go into more

00:00:35,030 --> 00:00:41,350
detail so just going to get right into

00:00:40,370 --> 00:00:47,540
it

00:00:41,350 --> 00:00:48,829
wait yeah so large-scale memory leaks I

00:00:47,540 --> 00:00:51,739
don't know if anybody else here has ever

00:00:48,829 --> 00:00:55,070
had to deal with a gigantic memory leak

00:00:51,739 --> 00:00:57,860
but I have and people I worked along

00:00:55,070 --> 00:00:59,570
side with had to also and we spent you

00:00:57,860 --> 00:01:03,500
know multiple weeks trying to track down

00:00:59,570 --> 00:01:06,170
a memory leak 6 plus man weeks and you

00:01:03,500 --> 00:01:07,490
know there's the really tricky to solve

00:01:06,170 --> 00:01:09,289
when you're working in a giant

00:01:07,490 --> 00:01:10,039
application and pretty much everybody in

00:01:09,289 --> 00:01:11,869
the project

00:01:10,039 --> 00:01:14,389
I went from never having to think about

00:01:11,869 --> 00:01:19,549
a memory leak to being super well-versed

00:01:14,389 --> 00:01:21,229
and hunting them down and by the end of

00:01:19,549 --> 00:01:23,020
it we're all super mentally drained and

00:01:21,229 --> 00:01:25,700
need to drain to drink about that big -

00:01:23,020 --> 00:01:26,929
so Polly I hope some of the insights I

00:01:25,700 --> 00:01:28,490
give you in the walkthrough will let you

00:01:26,929 --> 00:01:28,969
hit the ground running and not need to

00:01:28,490 --> 00:01:31,959
drink

00:01:28,969 --> 00:01:38,959
margarita quite that size the aftermath

00:01:31,959 --> 00:01:41,810
wasn't super pretty ok so uh my goal

00:01:38,959 --> 00:01:43,549
with this talk is mostly I'm going to

00:01:41,810 --> 00:01:44,719
run through memory how it works in the

00:01:43,549 --> 00:01:48,229
browser I'm going to give you a

00:01:44,719 --> 00:01:51,170
breakdown of all the tools that you're

00:01:48,229 --> 00:01:52,729
going to need to use I'm going to let

00:01:51,170 --> 00:01:54,490
you understand how memory leaks happen

00:01:52,729 --> 00:01:56,840
despite the memory being managed for you

00:01:54,490 --> 00:01:58,789
and why you need to care about memory

00:01:56,840 --> 00:02:02,329
leaks even if they're super tiny in your

00:01:58,789 --> 00:02:05,359
application so there's really three

00:02:02,329 --> 00:02:07,650
types of memory issues not just memory

00:02:05,359 --> 00:02:09,869
leaks your memory bloat

00:02:07,650 --> 00:02:11,730
and that's going to be when your app

00:02:09,869 --> 00:02:14,040
uses way too much memory right off the

00:02:11,730 --> 00:02:16,020
bat you have garbage collections if

00:02:14,040 --> 00:02:17,730
they're happening way too often you'll

00:02:16,020 --> 00:02:21,360
get janked in your app it'll be choppy

00:02:17,730 --> 00:02:23,610
animations will yeah they'll be visibly

00:02:21,360 --> 00:02:25,830
choppy and then you have memory leaks of

00:02:23,610 --> 00:02:28,560
course which is going to be the core of

00:02:25,830 --> 00:02:30,360
this Tech Talk no wait I have more

00:02:28,560 --> 00:02:31,950
slides but I miss them okay it's

00:02:30,360 --> 00:02:34,200
frequent garbage collection and memory

00:02:31,950 --> 00:02:37,800
leaks so what is the memory leak problem

00:02:34,200 --> 00:02:39,510
at high level it's pretty simple really

00:02:37,800 --> 00:02:41,400
all it is is your applications are

00:02:39,510 --> 00:02:42,660
always going to be asking the OS for a

00:02:41,400 --> 00:02:45,000
certain amount of memory to store data

00:02:42,660 --> 00:02:46,620
in the next queue tasks with it uses

00:02:45,000 --> 00:02:49,560
that for a time and what's no longer

00:02:46,620 --> 00:02:52,380
needed it should be released back to the

00:02:49,560 --> 00:02:53,790
OS so the memory leak happens when that

00:02:52,380 --> 00:02:57,630
process where it should release it

00:02:53,790 --> 00:02:59,940
doesn't work properly and that's when

00:02:57,630 --> 00:03:03,870
garbage collection fails you and it's

00:02:59,940 --> 00:03:07,980
always your fault or some other library

00:03:03,870 --> 00:03:09,390
that you're including it's likely

00:03:07,980 --> 00:03:10,620
because there's still reference to an

00:03:09,390 --> 00:03:12,420
object that you didn't know was there

00:03:10,620 --> 00:03:13,830
right so if there's multiple references

00:03:12,420 --> 00:03:17,040
to an object say you reference in a

00:03:13,830 --> 00:03:18,870
component and somewhere else so you have

00:03:17,040 --> 00:03:20,220
reference a that's something you wrote

00:03:18,870 --> 00:03:22,820
reference be somewhere else in the

00:03:20,220 --> 00:03:25,110
application you're not even aware of it

00:03:22,820 --> 00:03:28,380
you go okay I'm going to clean up

00:03:25,110 --> 00:03:30,330
reference a so its component you get rid

00:03:28,380 --> 00:03:31,530
of it you expect the garbage collector

00:03:30,330 --> 00:03:34,050
to come through and clean up the memory

00:03:31,530 --> 00:03:38,630
for you but it can't run until whatever

00:03:34,050 --> 00:03:41,070
that other object was gets unreferenced

00:03:38,630 --> 00:03:42,540
here's a simple example in angular it's

00:03:41,070 --> 00:03:46,200
pretty contrived but you'd have a

00:03:42,540 --> 00:03:47,430
component and it's storing some part of

00:03:46,200 --> 00:03:50,250
that component so in this case the

00:03:47,430 --> 00:03:51,930
element reference in a service so when

00:03:50,250 --> 00:03:53,370
that components remove from the Dom if

00:03:51,930 --> 00:03:54,900
you navigate away and it's deleted from

00:03:53,370 --> 00:03:57,420
your Dom and you no longer see it in

00:03:54,900 --> 00:03:59,130
your element list you might think the

00:03:57,420 --> 00:04:01,830
memory should be freed but because it's

00:03:59,130 --> 00:04:03,209
referenced in a service somewhere it's

00:04:01,830 --> 00:04:04,860
going to stick around a memory and in

00:04:03,209 --> 00:04:07,430
the tools you'll see that you'll see dom

00:04:04,860 --> 00:04:12,769
nodes still stick around even though

00:04:07,430 --> 00:04:12,769
it's not in your actual Dom tree anymore

00:04:13,190 --> 00:04:17,609
so it doesn't matter if these leaks are

00:04:15,660 --> 00:04:21,680
really small really big if you're

00:04:17,609 --> 00:04:21,680
leaking next to no memory or a ton

00:04:21,860 --> 00:04:26,970
because you have to imagine the users

00:04:25,020 --> 00:04:28,800
use case versus what your development

00:04:26,970 --> 00:04:30,919
machine is and when I'm working on

00:04:28,800 --> 00:04:33,930
projects web packs running a dev server

00:04:30,919 --> 00:04:36,479
it's refreshing every I don't know 30

00:04:33,930 --> 00:04:37,710
seconds maybe maybe even more if there's

00:04:36,479 --> 00:04:40,289
a tiny memory leak you're never going to

00:04:37,710 --> 00:04:42,479
notice it in that scenario but you're

00:04:40,289 --> 00:04:46,159
real users they sit there with their

00:04:42,479 --> 00:04:46,159
machines running for months straight and

00:04:46,669 --> 00:04:50,970
the severity of the leak is going to

00:04:48,810 --> 00:04:52,379
matter because if you think about the

00:04:50,970 --> 00:04:55,259
specs you have on your dev machine you

00:04:52,379 --> 00:04:56,970
have 16 32 gigs of ram your real users

00:04:55,259 --> 00:04:59,759
may only have two gigs so even really

00:04:56,970 --> 00:05:00,360
tiny memory leaks can you know crash

00:04:59,759 --> 00:05:06,780
their browser

00:05:00,360 --> 00:05:08,789
crash their computer possibly and then

00:05:06,780 --> 00:05:11,729
like I said the normal usage timely app

00:05:08,789 --> 00:05:12,840
also comes into place so if you're

00:05:11,729 --> 00:05:15,599
absolutely used for five minutes

00:05:12,840 --> 00:05:16,889
normally maybe it doesn't matter if

00:05:15,599 --> 00:05:18,569
there's a super tiny memory leak you

00:05:16,889 --> 00:05:20,069
should still probably try to fix it but

00:05:18,569 --> 00:05:21,319
if your apps normal usage time is

00:05:20,069 --> 00:05:23,789
someone sitting there for 810 hours

00:05:21,319 --> 00:05:26,159
maybe the normal usage is to leave it

00:05:23,789 --> 00:05:28,710
running for multiple days then it can be

00:05:26,159 --> 00:05:30,990
a lot more important and you always have

00:05:28,710 --> 00:05:33,930
your edge case users your people that

00:05:30,990 --> 00:05:39,659
leave it on for 30 days straight someone

00:05:33,930 --> 00:05:41,099
using IE 10 IE 9 anybody with a super

00:05:39,659 --> 00:05:46,740
low-end machine maybe only have one gig

00:05:41,099 --> 00:05:48,930
of ram and so why do you care I mean

00:05:46,740 --> 00:05:50,580
it's just a bit is that all memory leaks

00:05:48,930 --> 00:05:54,870
and my other size are going to cause

00:05:50,580 --> 00:05:56,810
performance issues for someone and in

00:05:54,870 --> 00:05:58,919
the worst case crash the browser and

00:05:56,810 --> 00:06:03,569
they're probably paying for your salary

00:05:58,919 --> 00:06:06,199
oh wait that's my note that's not

00:06:03,569 --> 00:06:06,199
supposed to be in there

00:06:12,760 --> 00:06:15,960
okay so yesterday in my talk I said

00:06:14,440 --> 00:06:18,250
there's two types of memory leaks

00:06:15,960 --> 00:06:19,540
contrived examples in real ones so this

00:06:18,250 --> 00:06:21,160
is contrived it's not really that

00:06:19,540 --> 00:06:22,810
helpful but we're going to do it anyways

00:06:21,160 --> 00:06:24,190
because you really can't show a real

00:06:22,810 --> 00:06:27,190
memory leak unless you have a massive

00:06:24,190 --> 00:06:29,530
application and it's pretty hard to do

00:06:27,190 --> 00:06:30,640
that for a talk like this so we're going

00:06:29,530 --> 00:06:33,940
to run through some of the tools that

00:06:30,640 --> 00:06:35,590
you can use in Chrome try and give you a

00:06:33,940 --> 00:06:37,480
pretty quick rundown but hopefully

00:06:35,590 --> 00:06:40,600
everything you need to know to target a

00:06:37,480 --> 00:06:42,010
memory leak so the first thing if you

00:06:40,600 --> 00:06:44,140
think you have a memory leak or you

00:06:42,010 --> 00:06:48,820
suspect it iwase will come in and use

00:06:44,140 --> 00:06:52,030
the time line tool so at the top you

00:06:48,820 --> 00:06:55,270
have a few things in here just big

00:06:52,030 --> 00:06:56,740
enough you see it roughly okay so you

00:06:55,270 --> 00:06:58,750
have a record button that will start a

00:06:56,740 --> 00:07:00,310
time line you have a few options up here

00:06:58,750 --> 00:07:02,020
so you can take screenshots there's a

00:07:00,310 --> 00:07:03,040
memory option you're of course going to

00:07:02,020 --> 00:07:05,050
want that on if you're looking for

00:07:03,040 --> 00:07:08,020
memory leaks then you have a few capture

00:07:05,050 --> 00:07:09,370
settings in here and then you can

00:07:08,020 --> 00:07:11,440
throttle your computer so you can

00:07:09,370 --> 00:07:13,660
pretend like you're a user on a slower

00:07:11,440 --> 00:07:15,550
computer which can be pretty helpful not

00:07:13,660 --> 00:07:19,000
specifically for memory leaks also for

00:07:15,550 --> 00:07:24,400
other performance so let's refresh this

00:07:19,000 --> 00:07:26,850
quickly okay so you come in give it a

00:07:24,400 --> 00:07:28,960
second and you want to run a time line

00:07:26,850 --> 00:07:30,790
how you should generally do it as you

00:07:28,960 --> 00:07:32,260
start recording a timeline and then this

00:07:30,790 --> 00:07:34,420
garbage collection button here will run

00:07:32,260 --> 00:07:35,800
a major garbage collection clean up

00:07:34,420 --> 00:07:38,530
anything that's not needed in the memory

00:07:35,800 --> 00:07:40,540
so you run out at the start toggle

00:07:38,530 --> 00:07:41,860
whatever event you have in your app that

00:07:40,540 --> 00:07:44,470
you think might be causing a memory

00:07:41,860 --> 00:07:47,110
issue so I mean there's one thing you

00:07:44,470 --> 00:07:50,350
can do in this app let's say that's a

00:07:47,110 --> 00:07:52,420
likely culprit run the major garbage

00:07:50,350 --> 00:07:57,130
collection again at the end and then

00:07:52,420 --> 00:07:59,680
stop it so there's a few things in here

00:07:57,130 --> 00:08:01,600
at the top it gives you a couple

00:07:59,680 --> 00:08:05,200
different timelines so at the top you

00:08:01,600 --> 00:08:07,630
get animation performance CPU usage and

00:08:05,200 --> 00:08:11,260
then your memory we're not going to be

00:08:07,630 --> 00:08:12,850
super concerned with those what we're

00:08:11,260 --> 00:08:14,470
mainly going to be focused on is the

00:08:12,850 --> 00:08:18,490
memory here so you get this graph of

00:08:14,470 --> 00:08:20,290
memory and it shows you a few different

00:08:18,490 --> 00:08:23,050
things so the blue line is showing you

00:08:20,290 --> 00:08:25,450
the JavaScript heap the green line

00:08:23,050 --> 00:08:26,380
chicken-cannon see over here is the dom

00:08:25,450 --> 00:08:28,330
nodes

00:08:26,380 --> 00:08:32,320
and then the orange line is the event

00:08:28,330 --> 00:08:33,940
listeners at the bottom so this is

00:08:32,320 --> 00:08:36,340
exactly the graph you're not looking for

00:08:33,940 --> 00:08:38,560
if you see it climbing up like that sort

00:08:36,340 --> 00:08:40,390
of stair casing up that likely means you

00:08:38,560 --> 00:08:42,360
have a memory leak or something is being

00:08:40,390 --> 00:08:44,950
added to your memory and not cleared up

00:08:42,360 --> 00:08:55,000
I'll jump back to the slides quickly to

00:08:44,950 --> 00:08:57,460
show you well I mean so the top is an

00:08:55,000 --> 00:08:59,650
example of a memory leak and the bottom

00:08:57,460 --> 00:09:02,230
is the graph you're looking for so if

00:08:59,650 --> 00:09:05,560
you look at the start and the end of

00:09:02,230 --> 00:09:06,880
both of these graphs in general you're

00:09:05,560 --> 00:09:08,500
going to want to see whatever level of

00:09:06,880 --> 00:09:10,690
memory you started at that should be

00:09:08,500 --> 00:09:13,480
roughly where you end at the end of the

00:09:10,690 --> 00:09:15,670
graph and this will be influenced by

00:09:13,480 --> 00:09:17,200
things outside of your app if you're not

00:09:15,670 --> 00:09:18,430
running an incognito mode and you have

00:09:17,200 --> 00:09:19,930
plugins running in there you might have

00:09:18,430 --> 00:09:22,150
extensions that are adding a little bit

00:09:19,930 --> 00:09:24,850
of memory to your page like an ad

00:09:22,150 --> 00:09:26,890
blocker or I don't know if you have like

00:09:24,850 --> 00:09:28,420
an enhancement suite for a specific site

00:09:26,890 --> 00:09:29,950
or something like that so it's a good

00:09:28,420 --> 00:09:33,130
idea to always do these tests in

00:09:29,950 --> 00:09:36,940
incognito just to default disable your

00:09:33,130 --> 00:09:39,310
extensions so I'm going to run through

00:09:36,940 --> 00:09:40,660
garbage collection at a fairly deep

00:09:39,310 --> 00:09:44,760
level just so you know how it works in a

00:09:40,660 --> 00:09:47,500
browser and really the point of this I

00:09:44,760 --> 00:09:49,300
just want you to understand what garbage

00:09:47,500 --> 00:09:52,240
collection is and how it's working and

00:09:49,300 --> 00:09:54,130
why it exists so there's a bunch of

00:09:52,240 --> 00:09:57,790
different types of memory management at

00:09:54,130 --> 00:09:59,970
a super low level with assembly you're

00:09:57,790 --> 00:10:02,770
managing the memory on the heap itself

00:09:59,970 --> 00:10:05,680
and it gives you a ton of control and as

00:10:02,770 --> 00:10:07,570
you go up the control is kind of taken

00:10:05,680 --> 00:10:10,270
away from you but it's simplified in how

00:10:07,570 --> 00:10:12,130
you use the memory in JavaScript is a

00:10:10,270 --> 00:10:14,650
garbage collection our garbage collected

00:10:12,130 --> 00:10:16,090
language so everything you write in the

00:10:14,650 --> 00:10:19,780
browser is going to be garbage collected

00:10:16,090 --> 00:10:21,610
by default so if you go through the

00:10:19,780 --> 00:10:24,100
different types like manual memory

00:10:21,610 --> 00:10:27,880
management in languages like assembly C

00:10:24,100 --> 00:10:29,320
C++ you can control each bit of memory

00:10:27,880 --> 00:10:31,600
in your application that's super

00:10:29,320 --> 00:10:33,580
powerful because you don't have to worry

00:10:31,600 --> 00:10:35,710
about the performance implications of a

00:10:33,580 --> 00:10:38,980
garbage collector but it's also way

00:10:35,710 --> 00:10:40,410
easier to mess up it's much easier for

00:10:38,980 --> 00:10:42,520
you to

00:10:40,410 --> 00:10:44,230
accidentally reuse memory that was still

00:10:42,520 --> 00:10:47,050
in use somewhere else or forget to

00:10:44,230 --> 00:10:48,970
deallocate some memory and you need to

00:10:47,050 --> 00:10:51,940
manually track each bit you don't have

00:10:48,970 --> 00:10:54,550
something handling that for you and then

00:10:51,940 --> 00:10:56,260
if you go one step up you look at

00:10:54,550 --> 00:10:58,180
something like objective-c that just

00:10:56,260 --> 00:11:00,550
keeps a reference count so it keeps a

00:10:58,180 --> 00:11:02,529
reference to each resource in your

00:11:00,550 --> 00:11:03,850
application and it's a counter that goes

00:11:02,529 --> 00:11:05,980
up and down and when it hits zero it

00:11:03,850 --> 00:11:07,150
just knows to collect itself so you kind

00:11:05,980 --> 00:11:09,550
of get some of the power of a garbage

00:11:07,150 --> 00:11:11,440
collector man you are managing a memory

00:11:09,550 --> 00:11:13,330
for you but you don't have to worry

00:11:11,440 --> 00:11:15,130
about a performance implications it just

00:11:13,330 --> 00:11:17,670
tosses it away it doesn't have to run a

00:11:15,130 --> 00:11:19,720
cycle and decide do I keep it or not

00:11:17,670 --> 00:11:21,700
then you have garbage collection so

00:11:19,720 --> 00:11:25,450
that's automatic tracking each resort or

00:11:21,700 --> 00:11:26,950
each reference to a resource and then it

00:11:25,450 --> 00:11:28,870
runs what's called the garbage

00:11:26,950 --> 00:11:31,600
collection and in a minute we'll go

00:11:28,870 --> 00:11:32,710
through kind of visualization of what

00:11:31,600 --> 00:11:36,010
that does and how it works in the

00:11:32,710 --> 00:11:37,810
browser but it takes time to do that and

00:11:36,010 --> 00:11:39,310
since the browser's only single-threaded

00:11:37,810 --> 00:11:40,930
anything that's taking time away from

00:11:39,310 --> 00:11:43,890
your application is going to cause it to

00:11:40,930 --> 00:11:43,890
pause while it's running

00:11:44,190 --> 00:11:50,320
so each browser has its own engine and

00:11:47,589 --> 00:11:52,180
each engine implements everything a

00:11:50,320 --> 00:11:55,600
little bit differently there's you know

00:11:52,180 --> 00:11:57,490
specs now but and they try and adhere to

00:11:55,600 --> 00:11:59,950
them but each other garbage collectors

00:11:57,490 --> 00:12:02,050
are conceptually the same but

00:11:59,950 --> 00:12:04,510
implemented differently and what that's

00:12:02,050 --> 00:12:09,820
going to mean is you might run into an

00:12:04,510 --> 00:12:11,170
issue a memory leak with likely it'll

00:12:09,820 --> 00:12:13,330
affect all the browsers but you might

00:12:11,170 --> 00:12:15,790
see it have a much worse effect in a

00:12:13,330 --> 00:12:17,470
certain browser you might notice I'm

00:12:15,790 --> 00:12:19,270
using the chrome dev tools because I

00:12:17,470 --> 00:12:20,980
like them the most and I'm looking at

00:12:19,270 --> 00:12:23,020
the memory and I'm not seeing much maybe

00:12:20,980 --> 00:12:25,120
I'm seeing a tiny memory leak not a ton

00:12:23,020 --> 00:12:26,380
and I don't really test any other

00:12:25,120 --> 00:12:29,140
browsers but I'm getting reports for my

00:12:26,380 --> 00:12:30,850
users that something seems funky a naive

00:12:29,140 --> 00:12:32,980
app slowing down after a bunch of time

00:12:30,850 --> 00:12:34,930
so you open it up Nighy with their tools

00:12:32,980 --> 00:12:36,820
and you see the memory leaks actually

00:12:34,930 --> 00:12:38,350
huge over there and that's likely going

00:12:36,820 --> 00:12:42,459
to be because the garbage collectors are

00:12:38,350 --> 00:12:44,260
implemented differently yeah so if we

00:12:42,459 --> 00:12:49,279
visualize what garbage collection looks

00:12:44,260 --> 00:12:51,350
like you have a user using your app

00:12:49,279 --> 00:12:52,610
and there's in the garbage collector

00:12:51,350 --> 00:12:54,350
there's basically two chunks of memory

00:12:52,610 --> 00:12:57,139
you have a young generation or young

00:12:54,350 --> 00:12:59,720
space and an old generation or old space

00:12:57,139 --> 00:13:01,910
where the memories stored and as they go

00:12:59,720 --> 00:13:04,310
through and use it memories allocated so

00:13:01,910 --> 00:13:06,230
the dark green blocks are allocated and

00:13:04,310 --> 00:13:08,029
still referenced memory when they clear

00:13:06,230 --> 00:13:10,040
out that's on referenced so they come

00:13:08,029 --> 00:13:13,069
through and some memories allocated and

00:13:10,040 --> 00:13:14,389
then unreferenced so that memories no

00:13:13,069 --> 00:13:16,610
longer using your application that would

00:13:14,389 --> 00:13:18,379
be like a component got cleared up and

00:13:16,610 --> 00:13:20,809
there is a an array or something and

00:13:18,379 --> 00:13:22,660
it's no longer used but at this point in

00:13:20,809 --> 00:13:25,309
time your apps still using that memory

00:13:22,660 --> 00:13:27,040
if not until a minor garbage collection

00:13:25,309 --> 00:13:30,980
comes and it runs what's called a mark

00:13:27,040 --> 00:13:32,660
mark and sweep algorithm that it clears

00:13:30,980 --> 00:13:36,879
out the unreferenced memory and it will

00:13:32,660 --> 00:13:40,249
mark anything that needs to be retained

00:13:36,879 --> 00:13:42,050
so that memory is still required by your

00:13:40,249 --> 00:13:44,899
app that's some component or service

00:13:42,050 --> 00:13:47,740
that that's still there being used and

00:13:44,899 --> 00:13:49,790
the user continues to use the

00:13:47,740 --> 00:13:53,029
application some more memories once

00:13:49,790 --> 00:13:54,709
again allocated D allocated and then a

00:13:53,029 --> 00:13:57,110
second minor garbage collection happens

00:13:54,709 --> 00:13:59,360
and that memory shifted over from the

00:13:57,110 --> 00:14:03,459
Maya or the young generation to the old

00:13:59,360 --> 00:14:05,420
generation so it's important because

00:14:03,459 --> 00:14:08,809
anything that sticks around in the minor

00:14:05,420 --> 00:14:11,990
generation or the minor generation minor

00:14:08,809 --> 00:14:14,120
garbage collection cycle is very quick

00:14:11,990 --> 00:14:15,410
if you're just sweeping memory out of

00:14:14,120 --> 00:14:17,389
there it's going to take one millisecond

00:14:15,410 --> 00:14:19,759
a worst-case scenario if it has to mark

00:14:17,389 --> 00:14:21,740
everything in there might take up to 25

00:14:19,759 --> 00:14:24,139
milliseconds or so which isn't a huge

00:14:21,740 --> 00:14:26,180
performance hit but anything in the

00:14:24,139 --> 00:14:27,680
major in the old generation when a major

00:14:26,180 --> 00:14:30,230
garbage collection happens that's like a

00:14:27,680 --> 00:14:32,240
minimum of 30 milliseconds and an

00:14:30,230 --> 00:14:38,120
unbounded upper limit on how long that

00:14:32,240 --> 00:14:39,350
garbage collection to take so you have

00:14:38,120 --> 00:14:40,790
your minor garbage collections and

00:14:39,350 --> 00:14:42,679
they're always dealing with a small

00:14:40,790 --> 00:14:45,499
amount of memory one tape megabytes

00:14:42,679 --> 00:14:48,939
memory that's frequently allocated and D

00:14:45,499 --> 00:14:51,350
allocated not used for a long time

00:14:48,939 --> 00:14:52,999
these are preferable you'll see these

00:14:51,350 --> 00:14:54,350
happening in your application a lot more

00:14:52,999 --> 00:14:55,579
if you look at the tools and you look at

00:14:54,350 --> 00:14:57,949
what's going on with the garbage

00:14:55,579 --> 00:15:02,160
collector there's tons and tons of minor

00:14:57,949 --> 00:15:04,960
garbage collections running anytime

00:15:02,160 --> 00:15:07,270
anytime they need to so the garbage

00:15:04,960 --> 00:15:09,850
collector is pretty smart or it's been

00:15:07,270 --> 00:15:12,700
getting smart in the past few years it

00:15:09,850 --> 00:15:15,070
schedules idle time or tries to schedule

00:15:12,700 --> 00:15:16,570
itself in idle time so it doesn't cause

00:15:15,070 --> 00:15:17,920
a performance issues so if you can keep

00:15:16,570 --> 00:15:20,350
it to minor garbage collections and

00:15:17,920 --> 00:15:23,950
quick garbage collections it'll try and

00:15:20,350 --> 00:15:26,110
fit itself into your program and really

00:15:23,950 --> 00:15:27,610
you know precise tiny chunks so it

00:15:26,110 --> 00:15:30,070
doesn't cause an issue so you hopefully

00:15:27,610 --> 00:15:31,630
don't see any performance impact but

00:15:30,070 --> 00:15:33,070
with that said major garbage collections

00:15:31,630 --> 00:15:37,510
are always going to take too long for

00:15:33,070 --> 00:15:39,340
that to really be feasible so they can

00:15:37,510 --> 00:15:42,040
deal with the rest of your JavaScript

00:15:39,340 --> 00:15:43,630
heap and if you look at an angular app

00:15:42,040 --> 00:15:45,310
even a very simple one you're looking at

00:15:43,630 --> 00:15:49,090
probably 50 to 60 megabytes of memory

00:15:45,310 --> 00:15:52,420
and they take way longer right so they

00:15:49,090 --> 00:15:54,880
are handling that mark-and-sweep on a

00:15:52,420 --> 00:15:57,160
larger chunk of memory and they're also

00:15:54,880 --> 00:15:59,350
compressing any memory in there that has

00:15:57,160 --> 00:16:05,230
been retained for a while to stop

00:15:59,350 --> 00:16:07,750
fragmentation so why is memory leaking

00:16:05,230 --> 00:16:09,160
with garbage collection right the

00:16:07,750 --> 00:16:12,010
garbage collector is smart and when it's

00:16:09,160 --> 00:16:14,920
running but it's kind of dumb in what

00:16:12,010 --> 00:16:16,240
it's doing it's not let's not say it's

00:16:14,920 --> 00:16:17,890
bad it can't know it doesn't know your

00:16:16,240 --> 00:16:19,120
intention right so you're writing that

00:16:17,890 --> 00:16:22,240
code and you think there's no more

00:16:19,120 --> 00:16:23,380
references to an object but the garbage

00:16:22,240 --> 00:16:25,450
collector is aware of everything right

00:16:23,380 --> 00:16:27,670
so it is aware that a reference still

00:16:25,450 --> 00:16:29,770
exists somewhere and even if that

00:16:27,670 --> 00:16:31,450
reference is never used it still exists

00:16:29,770 --> 00:16:36,160
and it can't clean that memory up for

00:16:31,450 --> 00:16:37,600
you and the last thing I want to really

00:16:36,160 --> 00:16:39,610
drive home is since it is single

00:16:37,600 --> 00:16:40,180
threaded the performance is super

00:16:39,610 --> 00:16:41,650
important

00:16:40,180 --> 00:16:43,090
there improving the garbage collector

00:16:41,650 --> 00:16:46,570
constantly so the performance

00:16:43,090 --> 00:16:48,760
implications are less and less but if

00:16:46,570 --> 00:16:50,770
you're at all concerned with smooth

00:16:48,760 --> 00:16:54,010
animations or smooth transitions between

00:16:50,770 --> 00:16:55,240
pages watching what your memory is doing

00:16:54,010 --> 00:16:57,400
and how often garbage collector is

00:16:55,240 --> 00:17:03,760
running isn't important to make sure

00:16:57,400 --> 00:17:05,500
those are as smooth as possible so you

00:17:03,760 --> 00:17:07,000
get tickets from your users and they're

00:17:05,500 --> 00:17:08,530
you know they're never that clear they

00:17:07,000 --> 00:17:10,420
don't really know what's going on what

00:17:08,530 --> 00:17:12,400
types of things would they report to you

00:17:10,420 --> 00:17:14,330
that are going to make you think maybe I

00:17:12,400 --> 00:17:16,190
should look for memory leak

00:17:14,330 --> 00:17:17,990
the performance is degrading over time

00:17:16,190 --> 00:17:18,650
that's the most likely sign there's a

00:17:17,990 --> 00:17:21,110
memory leak

00:17:18,650 --> 00:17:23,410
you know if they start using it and your

00:17:21,110 --> 00:17:27,260
apps great four hours down the line

00:17:23,410 --> 00:17:29,810
people submit a ticket that's likely the

00:17:27,260 --> 00:17:32,900
issue a memory leak if your app crashes

00:17:29,810 --> 00:17:34,910
after extended use it could be memory

00:17:32,900 --> 00:17:36,320
leak it's not certainly that there's

00:17:34,910 --> 00:17:38,330
other performance things that could be

00:17:36,320 --> 00:17:39,710
causing that but it's a good reason to

00:17:38,330 --> 00:17:41,090
look and if the performance is

00:17:39,710 --> 00:17:43,130
constantly slowed again that's either

00:17:41,090 --> 00:17:46,460
memory leak or memory bloat either way

00:17:43,130 --> 00:17:48,380
it's a memory problem but with that said

00:17:46,460 --> 00:17:50,390
the only real sign they have a memory

00:17:48,380 --> 00:17:52,340
leak sorry the only real sign you have a

00:17:50,390 --> 00:17:53,630
memory leak is that memory is going up

00:17:52,340 --> 00:17:55,910
and you can look at the tools and see

00:17:53,630 --> 00:17:57,470
that right so those are things your

00:17:55,910 --> 00:17:58,760
users might report to you and then you

00:17:57,470 --> 00:18:03,470
know to dive in the tools in at least

00:17:58,760 --> 00:18:05,840
check because even if your users are

00:18:03,470 --> 00:18:07,520
reporting that and you know to look in

00:18:05,840 --> 00:18:09,500
the tools to see is the memory going up

00:18:07,520 --> 00:18:11,810
that's lonely sign sometimes it's not

00:18:09,500 --> 00:18:15,320
that easy if you can imagine you have a

00:18:11,810 --> 00:18:18,050
gigantic application and you have maybe

00:18:15,320 --> 00:18:20,210
a certain section of your app that it's

00:18:18,050 --> 00:18:23,690
really tiny doesn't do a lot you know it

00:18:20,210 --> 00:18:25,040
works properly so you're not going in

00:18:23,690 --> 00:18:26,360
there often and users are reporting

00:18:25,040 --> 00:18:28,480
memory leak and you're going through

00:18:26,360 --> 00:18:30,890
your whole application trying to find

00:18:28,480 --> 00:18:33,080
trying to toggle all the events seeing

00:18:30,890 --> 00:18:36,200
if anything is causing a memory leak in

00:18:33,080 --> 00:18:37,730
the tools but you've never visited you

00:18:36,200 --> 00:18:39,650
forgot to visit that one page because

00:18:37,730 --> 00:18:41,660
it's such a small unused portion of your

00:18:39,650 --> 00:18:43,160
app what sort of tool like Redux can

00:18:41,660 --> 00:18:44,720
come into play and really help you you

00:18:43,160 --> 00:18:46,610
can have a global state and the history

00:18:44,720 --> 00:18:48,710
of all their states so you can replay

00:18:46,610 --> 00:18:51,680
exactly what your user would what's

00:18:48,710 --> 00:18:53,600
doing that led to the memory leak like

00:18:51,680 --> 00:18:55,790
you might be able to even send their

00:18:53,600 --> 00:18:57,980
their entire history back to your server

00:18:55,790 --> 00:18:58,910
when they report a ticket and that can

00:18:57,980 --> 00:19:01,610
just run you through and you'll know

00:18:58,910 --> 00:19:03,440
everybody that reports an observational

00:19:01,610 --> 00:19:08,420
sign of a memory leak is going to that

00:19:03,440 --> 00:19:12,020
exact page so what's causing the leak in

00:19:08,420 --> 00:19:15,260
your app not blaming you for the memory

00:19:12,020 --> 00:19:17,300
leak okay I'm it's almost certainly your

00:19:15,260 --> 00:19:19,640
fault or someone else's on your team so

00:19:17,300 --> 00:19:23,080
I just blame the new guy that's what I

00:19:19,640 --> 00:19:23,080
always do or the last person that quit

00:19:23,190 --> 00:19:28,240
my point is that you won't have to dive

00:19:25,870 --> 00:19:32,830
into angular itself or put the blame on

00:19:28,240 --> 00:19:34,360
the browser it's almost certainly going

00:19:32,830 --> 00:19:36,340
to be something you did and that's

00:19:34,360 --> 00:19:38,440
that's awesome that means we can fix it

00:19:36,340 --> 00:19:41,170
and it shouldn't be that hard hopefully

00:19:38,440 --> 00:19:43,590
but sometimes it is so what are the most

00:19:41,170 --> 00:19:46,420
likely culprits of a memory leak

00:19:43,590 --> 00:19:48,970
detached Dom trees this is what that

00:19:46,420 --> 00:19:55,120
first example was showing but if you

00:19:48,970 --> 00:19:56,740
think about it your entire Dom tree can

00:19:55,120 --> 00:19:58,330
be divided into sub trees so if you

00:19:56,740 --> 00:20:00,010
imagine each of these different colors

00:19:58,330 --> 00:20:04,200
as a different component then you have a

00:20:00,010 --> 00:20:08,830
root at the top if you take away the

00:20:04,200 --> 00:20:10,750
reference to one of the components you

00:20:08,830 --> 00:20:12,280
would think that clears itself up but

00:20:10,750 --> 00:20:13,720
again if you had a reference in the

00:20:12,280 --> 00:20:16,300
service like we showed and I showed in

00:20:13,720 --> 00:20:18,490
my example it will actually retain the

00:20:16,300 --> 00:20:20,020
detached Dom tree so when we were

00:20:18,490 --> 00:20:22,720
looking at the tools earlier you could

00:20:20,020 --> 00:20:25,870
see the Dom nodes growing up or going up

00:20:22,720 --> 00:20:27,580
sorry and if you looked at the actual

00:20:25,870 --> 00:20:30,100
application obviously nothing was being

00:20:27,580 --> 00:20:31,900
added to the DOM and that's because the

00:20:30,100 --> 00:20:35,020
Dom tree every time was getting detached

00:20:31,900 --> 00:20:36,960
from the application the second thing is

00:20:35,020 --> 00:20:39,429
long-lived observables

00:20:36,960 --> 00:20:43,630
so some observables have a lifespan

00:20:39,429 --> 00:20:46,059
something like an HTTP request will

00:20:43,630 --> 00:20:48,100
always have a completed event and it

00:20:46,059 --> 00:20:51,630
will kill itself it'll unsubscribe when

00:20:48,100 --> 00:20:53,980
that happens but if you're constantly

00:20:51,630 --> 00:20:56,260
taking requests from a certain API like

00:20:53,980 --> 00:20:57,970
if say you're pulling a stock market API

00:20:56,260 --> 00:21:00,850
and it sends something back to you every

00:20:57,970 --> 00:21:02,920
5 seconds in a component even if you

00:21:00,850 --> 00:21:04,990
remove that component that observer that

00:21:02,920 --> 00:21:06,790
observables still in subscription is

00:21:04,990 --> 00:21:08,800
still going to exist in memory and will

00:21:06,790 --> 00:21:11,620
be retained and that's why you always

00:21:08,800 --> 00:21:14,200
you know just to be safe always

00:21:11,620 --> 00:21:16,570
unsubscribed from observables even you

00:21:14,200 --> 00:21:21,850
know might not be necessary but it's a

00:21:16,570 --> 00:21:24,190
good safety procedure and then there's

00:21:21,850 --> 00:21:25,420
the console API and you should have it

00:21:24,190 --> 00:21:26,679
turned off in production there's really

00:21:25,420 --> 00:21:29,470
no reason to leave it on in your

00:21:26,679 --> 00:21:30,910
production app but if you come in in

00:21:29,470 --> 00:21:32,320
your your in your development

00:21:30,910 --> 00:21:34,870
environment and you're trying to track

00:21:32,320 --> 00:21:36,610
down a memory leak it's pretty easy to

00:21:34,870 --> 00:21:37,040
forget to turn off the console API or

00:21:36,610 --> 00:21:38,810
not even

00:21:37,040 --> 00:21:41,660
think about it and go through the tools

00:21:38,810 --> 00:21:43,490
and see the memories constantly going up

00:21:41,660 --> 00:21:45,110
as I navigate maybe you're logging

00:21:43,490 --> 00:21:48,470
events on navigation normally in

00:21:45,110 --> 00:21:50,360
development and each of those objects

00:21:48,470 --> 00:21:51,740
that gets logged to your console would

00:21:50,360 --> 00:21:53,510
get stays around in memory until the

00:21:51,740 --> 00:21:54,830
console is cleared and look you know the

00:21:53,510 --> 00:21:56,990
console is not really cleared until you

00:21:54,830 --> 00:22:00,800
refresh the page by default so it'll

00:21:56,990 --> 00:22:03,200
look exactly like a memory leak and then

00:22:00,800 --> 00:22:05,120
you'll likely have components if you

00:22:03,200 --> 00:22:07,430
haven't planned them out well better can

00:22:05,120 --> 00:22:11,990
be they'll behave like a leak so any

00:22:07,430 --> 00:22:16,670
component that is a just a list for

00:22:11,990 --> 00:22:18,500
example a list with no bounds so you

00:22:16,670 --> 00:22:19,910
maybe you're pulling some API and it

00:22:18,500 --> 00:22:21,680
adds something to list every five

00:22:19,910 --> 00:22:23,510
seconds if that list has no bounds and

00:22:21,680 --> 00:22:25,160
it can grow to an unbounded height in

00:22:23,510 --> 00:22:26,240
the tools it'll look exactly like a

00:22:25,160 --> 00:22:27,860
memory leak you'll see the memory

00:22:26,240 --> 00:22:29,990
constantly going up and ever going down

00:22:27,860 --> 00:22:31,460
you'll see the Dom nodes constantly

00:22:29,990 --> 00:22:34,970
going up as things are added to the list

00:22:31,460 --> 00:22:37,070
if it displays in your Dom it's not

00:22:34,970 --> 00:22:38,630
technically a memory leak but you should

00:22:37,070 --> 00:22:40,010
treat it like one you should fix it

00:22:38,630 --> 00:22:46,430
because it will behave like a memory

00:22:40,010 --> 00:22:48,350
leak and then your first I mean a lot of

00:22:46,430 --> 00:22:50,060
people's first idea to check the

00:22:48,350 --> 00:22:52,160
memories to look at the task manager or

00:22:50,060 --> 00:22:53,750
the activity manager and they might see

00:22:52,160 --> 00:22:57,380
that the applications memory is just

00:22:53,750 --> 00:22:58,970
climbing like crazy is I actually memory

00:22:57,380 --> 00:23:01,220
leak probably not

00:22:58,970 --> 00:23:02,900
euro Cesare super smart at this point in

00:23:01,220 --> 00:23:05,480
time they don't ask for that memory back

00:23:02,900 --> 00:23:07,160
until they need it so if your your

00:23:05,480 --> 00:23:09,260
applications idle and it did previously

00:23:07,160 --> 00:23:11,510
say need a gig of memory and right now

00:23:09,260 --> 00:23:12,620
it only needs 100 Meg's but your OS

00:23:11,510 --> 00:23:14,960
doesn't need the memory for anything

00:23:12,620 --> 00:23:19,160
else it'll stay at a gig of memory until

00:23:14,960 --> 00:23:24,680
that memory is required elsewhere back

00:23:19,160 --> 00:23:26,570
to the dev tools okay so we have a few

00:23:24,680 --> 00:23:30,080
more tools the timeline is a it's really

00:23:26,570 --> 00:23:31,490
vague picture it doesn't like maybe you

00:23:30,080 --> 00:23:33,980
can tell you have a memory leak it's not

00:23:31,490 --> 00:23:35,840
guaranteed based on that graph it's

00:23:33,980 --> 00:23:37,280
likely but it doesn't tell you what's

00:23:35,840 --> 00:23:44,570
leaking it doesn't tell you when that

00:23:37,280 --> 00:23:46,910
leak happened so in the tools if you go

00:23:44,570 --> 00:23:48,890
into profiles it's pretty similar to the

00:23:46,910 --> 00:23:50,480
timeline you have two different things

00:23:48,890 --> 00:23:52,070
you're going to want to look at keep

00:23:50,480 --> 00:23:53,570
snapshots will be a snapshot of all

00:23:52,070 --> 00:23:56,059
memory used by your application when you

00:23:53,570 --> 00:23:58,250
take the snapshot and the allocation

00:23:56,059 --> 00:24:00,860
timeline is going to show you memory as

00:23:58,250 --> 00:24:03,890
it's being allocated and D allocated in

00:24:00,860 --> 00:24:07,250
your app so if we run refresh let's

00:24:03,890 --> 00:24:10,730
quickly again we run an allocation

00:24:07,250 --> 00:24:12,500
timeline you can see some memory a

00:24:10,730 --> 00:24:15,110
really tiny amount is constant being

00:24:12,500 --> 00:24:17,660
allocated and D allocated that's because

00:24:15,110 --> 00:24:28,250
of the counter counting up likely if I

00:24:17,660 --> 00:24:30,350
toggle it on and off a few times you can

00:24:28,250 --> 00:24:32,150
see these blue bars stick around so the

00:24:30,350 --> 00:24:34,669
blue is memory that is still retained

00:24:32,150 --> 00:24:37,610
the gray is memory that's been cleared

00:24:34,669 --> 00:24:40,940
up so I toggle with the counter three

00:24:37,610 --> 00:24:43,429
times and it looks like there was three

00:24:40,940 --> 00:24:45,820
memory leaks really so you can click on

00:24:43,429 --> 00:24:48,169
each one in the allocation timeline and

00:24:45,820 --> 00:24:52,429
specifically see what memory is still

00:24:48,169 --> 00:24:54,470
retained at that point in time when you

00:24:52,429 --> 00:24:56,780
click on them you get a few different

00:24:54,470 --> 00:25:01,130
columns here so the Constructors each

00:24:56,780 --> 00:25:03,380
different type of object I suppose that

00:25:01,130 --> 00:25:05,030
still exists here you have your shallow

00:25:03,380 --> 00:25:07,880
size which is the amount of memory

00:25:05,030 --> 00:25:09,260
retained by that specific item and then

00:25:07,880 --> 00:25:11,240
the retain size is the amount of memory

00:25:09,260 --> 00:25:13,340
it references so if you look at these

00:25:11,240 --> 00:25:14,600
memory leaks there each around 600

00:25:13,340 --> 00:25:17,419
kilobytes roughly if we're going to

00:25:14,600 --> 00:25:20,540
guess if we look at the retain size of

00:25:17,419 --> 00:25:26,090
something like a counter component it

00:25:20,540 --> 00:25:29,360
has a retained size of 640 kilobytes you

00:25:26,090 --> 00:25:32,660
can come in expand it and it will give

00:25:29,360 --> 00:25:35,870
you some insights into what's happening

00:25:32,660 --> 00:25:37,429
in here so this is where it gets really

00:25:35,870 --> 00:25:39,860
complicated when it's not a contrived

00:25:37,429 --> 00:25:41,720
example like for me I can come in here

00:25:39,860 --> 00:25:43,400
and see there's a counter component or

00:25:41,720 --> 00:25:45,679
component and there's not much else

00:25:43,400 --> 00:25:47,480
happening in the app so it's really easy

00:25:45,679 --> 00:25:49,610
for me to see it when you have a giant

00:25:47,480 --> 00:25:51,679
application with 300 screens and a

00:25:49,610 --> 00:25:53,059
hundred different components and you're

00:25:51,679 --> 00:25:55,400
importing a bunch of different libraries

00:25:53,059 --> 00:25:57,140
it's way more complex the steps are

00:25:55,400 --> 00:25:59,690
still the same to try and figure out

00:25:57,140 --> 00:26:00,980
what is leaking but there's just a ton

00:25:59,690 --> 00:26:02,250
more information you're going to have to

00:26:00,980 --> 00:26:08,669
look through

00:26:02,250 --> 00:26:10,440
and it can take a very long time so if

00:26:08,669 --> 00:26:12,240
we look like if we look through what

00:26:10,440 --> 00:26:14,220
exists in this list we have counter

00:26:12,240 --> 00:26:17,429
component itself is really small but it

00:26:14,220 --> 00:26:22,049
retains 600 kilobytes we have some

00:26:17,429 --> 00:26:24,210
objects 10,000 of them that themselves

00:26:22,049 --> 00:26:26,100
are 560 kilobytes and then we have an

00:26:24,210 --> 00:26:27,929
array that's 80 so that's basically all

00:26:26,100 --> 00:26:29,700
the memory and you can expand each of

00:26:27,929 --> 00:26:31,440
these things and click on the objects

00:26:29,700 --> 00:26:34,200
that exist in here or hover over them

00:26:31,440 --> 00:26:36,960
even and it will tell you what is that

00:26:34,200 --> 00:26:39,360
object so this is a native element which

00:26:36,960 --> 00:26:43,049
will be an element reference for an app

00:26:39,360 --> 00:26:46,110
counter go over another random one in

00:26:43,049 --> 00:26:49,049
here you'll see the same thing kind of

00:26:46,110 --> 00:26:53,400
looks like there's 10,000 maybe of the

00:26:49,049 --> 00:26:55,500
same thing leaking if you want more

00:26:53,400 --> 00:26:57,240
insights into into what's happening here

00:26:55,500 --> 00:27:01,200
you can also use the heap snapshots so

00:26:57,240 --> 00:27:03,630
we kind of ate it with that that the

00:27:01,200 --> 00:27:05,130
event causing it's toggling the counter

00:27:03,630 --> 00:27:07,830
I mean it's lonely event so it's pretty

00:27:05,130 --> 00:27:13,530
easy to isolate so if we come in and we

00:27:07,830 --> 00:27:16,230
take a heap snapshot before then we

00:27:13,530 --> 00:27:19,230
toggle it one time and take another

00:27:16,230 --> 00:27:22,320
snapshot after you can look at a few

00:27:19,230 --> 00:27:23,940
different things so the snapshot by

00:27:22,320 --> 00:27:25,409
default showing you all of the memory

00:27:23,940 --> 00:27:29,309
used in your application at that point

00:27:25,409 --> 00:27:31,799
of time and you might need to look at

00:27:29,309 --> 00:27:33,390
this but it's a lot to go through even

00:27:31,799 --> 00:27:35,159
in this tiny app there's not much going

00:27:33,390 --> 00:27:36,570
on and there's a ton of information in

00:27:35,159 --> 00:27:38,309
here for you to to look through and

00:27:36,570 --> 00:27:41,400
trying to figure out what's sticking

00:27:38,309 --> 00:27:42,690
around but a really nice thing you can

00:27:41,400 --> 00:27:48,210
do is you can have multiple snapshots

00:27:42,690 --> 00:27:50,010
and you can compare between them sorry

00:27:48,210 --> 00:27:51,720
compare between the snapshots and that's

00:27:50,010 --> 00:27:55,110
just going to show you the new memory

00:27:51,720 --> 00:27:58,890
that was allocated after snapshot one

00:27:55,110 --> 00:28:00,480
was taken and again this is very similar

00:27:58,890 --> 00:28:04,320
to what we saw on the allocation

00:28:00,480 --> 00:28:06,090
timeline and now that you know since the

00:28:04,320 --> 00:28:07,350
examples so easy the allocation timeline

00:28:06,090 --> 00:28:09,990
was probably all you needed to solve

00:28:07,350 --> 00:28:12,870
this but in more complex interactions in

00:28:09,990 --> 00:28:14,850
your app keep snapshots can be very

00:28:12,870 --> 00:28:20,310
powerful

00:28:14,850 --> 00:28:24,000
so we kind of got a few insights in here

00:28:20,310 --> 00:28:27,360
counter components likely the culprit

00:28:24,000 --> 00:28:30,400
there's a huge list of objects leaking

00:28:27,360 --> 00:28:39,070
let's see if we can solve solve what's

00:28:30,400 --> 00:28:41,200
going on it's a big enough so it's

00:28:39,070 --> 00:28:43,420
coming to the counter component and we

00:28:41,200 --> 00:28:45,760
look at what's happening where for some

00:28:43,420 --> 00:28:47,290
reason allocating array of 10,000 items

00:28:45,760 --> 00:28:54,640
that seems pretty contrived to me I

00:28:47,290 --> 00:28:56,230
don't know I do that but I'm allocating

00:28:54,640 --> 00:28:59,110
it and I'm not doing anything with this

00:28:56,230 --> 00:29:01,900
array again what else is happening I'm

00:28:59,110 --> 00:29:04,830
starting a subscription and I'm not

00:29:01,900 --> 00:29:07,180
unsubscribing from it anywhere in here

00:29:04,830 --> 00:29:09,460
but even with that said why is this

00:29:07,180 --> 00:29:10,870
array leaking when it's not in the

00:29:09,460 --> 00:29:12,850
subscription right people always tell

00:29:10,870 --> 00:29:14,560
you anything any memory used in the

00:29:12,850 --> 00:29:16,600
subscription is going to leak outside in

00:29:14,560 --> 00:29:20,020
the subscription I just just have this

00:29:16,600 --> 00:29:24,400
dot count and this dot count is just a

00:29:20,020 --> 00:29:26,470
number so your initial idea might just

00:29:24,400 --> 00:29:28,990
be that only that number should be

00:29:26,470 --> 00:29:31,540
leaking but because of how the compiler

00:29:28,990 --> 00:29:34,750
works in typescript when you reference

00:29:31,540 --> 00:29:37,270
this in here this it doesn't matter what

00:29:34,750 --> 00:29:39,550
comes after that if this is referenced

00:29:37,270 --> 00:29:41,710
in your subscription the entire class is

00:29:39,550 --> 00:29:44,560
going to leak in the memory so anything

00:29:41,710 --> 00:29:46,210
you did in there is going to leak so if

00:29:44,560 --> 00:29:49,260
we're going to fix this I guess we

00:29:46,210 --> 00:29:49,260
should store that subscription

00:29:57,110 --> 00:30:09,600
and then on undestroyed will unsubscribe

00:30:00,270 --> 00:30:13,070
from it and let's go back to the tools

00:30:09,600 --> 00:30:15,660
and see see if that fixed our problem

00:30:13,070 --> 00:30:17,610
I'll run a time line because it's the

00:30:15,660 --> 00:30:20,120
easiest way to see if the leaks still

00:30:17,610 --> 00:30:27,000
happening so come in here toggle it off

00:30:20,120 --> 00:30:29,130
back on off and back on off and back on

00:30:27,000 --> 00:30:40,110
well I'd solved the memory leak and it

00:30:29,130 --> 00:30:42,030
wasn't supposed to interesting wait no I

00:30:40,110 --> 00:30:45,380
got a restart webpack give me one sec

00:30:42,030 --> 00:30:45,380
this happened earlier

00:30:48,769 --> 00:30:51,769
well-prepared

00:31:08,880 --> 00:31:12,740
at least web packs getting quicker

00:31:24,059 --> 00:31:27,370
all right well I'm just going to show

00:31:26,140 --> 00:31:30,330
you what you should have had to do

00:31:27,370 --> 00:31:32,230
because that shouldn't be fixing this

00:31:30,330 --> 00:31:34,539
okay so if we come in the counter

00:31:32,230 --> 00:31:36,820
component what else are we doing in here

00:31:34,539 --> 00:31:39,160
the app service is initializing polling

00:31:36,820 --> 00:31:41,200
so that counter counting up is isn't

00:31:39,160 --> 00:31:43,870
observable in this app service so if we

00:31:41,200 --> 00:31:46,929
jump in there we can look at the

00:31:43,870 --> 00:31:48,490
initialized polling function again this

00:31:46,929 --> 00:31:50,830
is pretty contrived but the first time

00:31:48,490 --> 00:31:52,770
you call it it's starting an interval

00:31:50,830 --> 00:31:54,730
that's pulling out a number so

00:31:52,770 --> 00:31:58,000
observable that interval just means

00:31:54,730 --> 00:32:01,240
every 500 milliseconds it's going to

00:31:58,000 --> 00:32:03,820
increment a counter basically and then

00:32:01,240 --> 00:32:07,929
it's sending that information out to my

00:32:03,820 --> 00:32:10,150
polling subject so these subscriptions

00:32:07,929 --> 00:32:13,150
in here are being created and they're

00:32:10,150 --> 00:32:15,100
never being cleared there's a bunch of

00:32:13,150 --> 00:32:18,070
different ways you could handle this but

00:32:15,100 --> 00:32:28,600
like the other component and I swear

00:32:18,070 --> 00:32:29,770
normally you do have to do this so

00:32:28,600 --> 00:32:32,530
you'll have to store them and then

00:32:29,770 --> 00:32:35,500
unsubscribe but services don't have a

00:32:32,530 --> 00:32:41,470
non destroy event like components do so

00:32:35,500 --> 00:32:44,169
you have to figure out sorry you have to

00:32:41,470 --> 00:32:46,659
figure out what time do you want these

00:32:44,169 --> 00:32:48,929
subscriptions to stop so what we'll do

00:32:46,659 --> 00:32:51,429
is we'll just create another function

00:32:48,929 --> 00:32:57,419
that we call from the component when it

00:32:51,429 --> 00:32:59,620
gets destroyed that says stop polling

00:32:57,419 --> 00:33:02,760
and all it's going to do is it's going

00:32:59,620 --> 00:33:02,760
to go through each subscription

00:33:06,370 --> 00:33:15,590
and I'll unsubscribe from and then

00:33:13,640 --> 00:33:19,580
because of how polling works we need to

00:33:15,590 --> 00:33:20,900
reset the initial subscription to true

00:33:19,580 --> 00:33:26,539
so it does the right thing the first

00:33:20,900 --> 00:33:28,460
time through and now the memory leak

00:33:26,539 --> 00:33:30,400
what would actually be fixed once we

00:33:28,460 --> 00:33:34,190
call that in the component so we come in

00:33:30,400 --> 00:33:35,929
sorry oil into the counter component we

00:33:34,190 --> 00:33:40,460
unsubscribe from the one subscription

00:33:35,929 --> 00:33:41,059
here when we call app service stop stop

00:33:40,460 --> 00:33:42,770
pulling

00:33:41,059 --> 00:33:44,150
we unsubscribe from the other two

00:33:42,770 --> 00:33:48,200
subscriptions or however many were

00:33:44,150 --> 00:33:50,179
created in the service and the memory

00:33:48,200 --> 00:33:51,530
leak is actually solved now so now I can

00:33:50,179 --> 00:33:53,000
go to the tools and show you guys it

00:33:51,530 --> 00:34:00,620
doesn't leak anymore because you haven't

00:33:53,000 --> 00:34:05,929
seen that yet well I can show you

00:34:00,620 --> 00:34:09,220
actually broke it oh you need to

00:34:05,929 --> 00:34:09,220
initialize your raise

00:34:23,840 --> 00:34:27,620
it would've been really good if this had

00:34:25,490 --> 00:34:35,770
a memory leak now though I think I would

00:34:27,620 --> 00:34:35,770
have been fine so a couple more slides

00:34:41,440 --> 00:34:46,490
so like I said because of the different

00:34:44,870 --> 00:34:48,050
engines you might have to use a

00:34:46,490 --> 00:34:49,670
different browser to try and figure out

00:34:48,050 --> 00:34:50,900
what the memory leak is I personally

00:34:49,670 --> 00:34:53,810
like Chrome the most I think it's the

00:34:50,900 --> 00:34:55,430
best tool it has the allocation timeline

00:34:53,810 --> 00:34:58,970
the other browsers don't have that so

00:34:55,430 --> 00:35:00,560
it's a pretty big advantage but with

00:34:58,970 --> 00:35:02,450
that said there will be times you have

00:35:00,560 --> 00:35:05,480
to use the other browsers and the other

00:35:02,450 --> 00:35:10,670
tools especially if a memory leak is

00:35:05,480 --> 00:35:12,710
only present in one browser yeah

00:35:10,670 --> 00:35:14,420
so in conclusion they're easy to spot

00:35:12,710 --> 00:35:16,130
they're hard to fix

00:35:14,420 --> 00:35:21,980
sometimes they fix themselves and you're

00:35:16,130 --> 00:35:23,570
not sure why it's not as easy as that's

00:35:21,980 --> 00:35:27,020
made it look and it was even easier than

00:35:23,570 --> 00:35:30,170
I expected so that's really true now it

00:35:27,020 --> 00:35:32,210
has a massive performance impact like

00:35:30,170 --> 00:35:33,950
all it doesn't matter how small it is

00:35:32,210 --> 00:35:35,210
someone out there is going to complain

00:35:33,950 --> 00:35:40,100
to you about a memory leak if you have

00:35:35,210 --> 00:35:42,050
one all the browser's are different so

00:35:40,100 --> 00:35:43,520
make sure you test on all of them make

00:35:42,050 --> 00:35:45,380
sure maybe you have your unit test run

00:35:43,520 --> 00:35:47,360
in all of them or at least you manually

00:35:45,380 --> 00:35:49,790
check each one and the dev tools are

00:35:47,360 --> 00:35:53,090
awesome they're super powerful it's

00:35:49,790 --> 00:35:55,370
likely all you'll ever need to solve a

00:35:53,090 --> 00:35:56,810
memory leak yeah there's the link again

00:35:55,370 --> 00:35:58,060
if you guys want to take a look but

00:35:56,810 --> 00:36:03,070
thanks

00:35:58,060 --> 00:36:03,070

YouTube URL: https://www.youtube.com/watch?v=nS53gCp2swc


