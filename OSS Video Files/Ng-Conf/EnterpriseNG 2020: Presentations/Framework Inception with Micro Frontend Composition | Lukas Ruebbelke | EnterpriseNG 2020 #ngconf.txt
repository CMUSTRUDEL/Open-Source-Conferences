Title: Framework Inception with Micro Frontend Composition | Lukas Ruebbelke | EnterpriseNG 2020 #ngconf
Publication date: 2021-05-17
Playlist: EnterpriseNG 2020: Presentations
Description: 
	Micro frontends solve complex developer problems, but more importantly, they accelerate innovation by giving organizations an incredible advantage through composition at the architecture layer. The future is a world where framework supremacy is a discussion relegated to the sidelines, and achieving business outcomes through composition will become the focus. In this talk, we will see what this looks like in a practical demo and how you can start to apply these ideas to your development efforts.

Learn the best ways to build reliable web applications, write quality code, choose scalable architectures, and create effective automated tests at the Reliable Web Summit this August 26-27, 2021. Powered by the team at ng-conf.

Get your ticket ðŸ‘‰ https://reliablewebsummit.com/

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:00,120 --> 00:00:16,800
[Music]

00:00:03,840 --> 00:00:19,520
let us

00:00:16,800 --> 00:00:20,800
my name is lucas rubicky and welcome to

00:00:19,520 --> 00:00:23,680
framework inception

00:00:20,800 --> 00:00:24,720
let's get enterprisey every app starts

00:00:23,680 --> 00:00:26,640
as an idea from the

00:00:24,720 --> 00:00:27,840
from that point of inception there is no

00:00:26,640 --> 00:00:29,359
turning back

00:00:27,840 --> 00:00:31,439
as we add features and functional

00:00:29,359 --> 00:00:34,160
enhancements the application

00:00:31,439 --> 00:00:35,280
will grow in complexity and continue to

00:00:34,160 --> 00:00:36,880
increase in complexity

00:00:35,280 --> 00:00:38,719
until we arrive at the enterprise stage

00:00:36,880 --> 00:00:40,719
where it gets really interesting

00:00:38,719 --> 00:00:42,399
applications at this level are usually

00:00:40,719 --> 00:00:44,239
segmented by lines of business

00:00:42,399 --> 00:00:46,640
with their own unique set of kpis that

00:00:44,239 --> 00:00:49,280
must be met and yet the same

00:00:46,640 --> 00:00:51,360
basic need for self-reservation as

00:00:49,280 --> 00:00:54,640
stakeholders awkwardly try to coordinate

00:00:51,360 --> 00:00:56,879
this release at scale my experience is

00:00:54,640 --> 00:00:58,640
that this doesn't usually go very well

00:00:56,879 --> 00:00:59,280
with the same stakeholders standing

00:00:58,640 --> 00:01:00,960
around

00:00:59,280 --> 00:01:03,120
watching the release progress wondering

00:01:00,960 --> 00:01:05,840
why this deployment isn't going

00:01:03,120 --> 00:01:07,760
better a very viable solution to what i

00:01:05,840 --> 00:01:09,520
feel is a game changer is module

00:01:07,760 --> 00:01:10,880
federation i'm not going to address this

00:01:09,520 --> 00:01:12,799
at the molecular level

00:01:10,880 --> 00:01:14,960
as manfred has already done an amazing

00:01:12,799 --> 00:01:17,280
job i defer to his genius

00:01:14,960 --> 00:01:18,479
but for review we have a large amount of

00:01:17,280 --> 00:01:20,880
functional complexity

00:01:18,479 --> 00:01:22,080
that we can extract into host itself

00:01:20,880 --> 00:01:23,920
contain modules that

00:01:22,080 --> 00:01:25,920
can be independently developed and then

00:01:23,920 --> 00:01:26,240
consumed back into the main application

00:01:25,920 --> 00:01:29,200
or

00:01:26,240 --> 00:01:30,079
any consumer my goal is not to rehash

00:01:29,200 --> 00:01:32,320
these points

00:01:30,079 --> 00:01:33,600
but rather to introduce you to a few new

00:01:32,320 --> 00:01:35,680
ideas to consider

00:01:33,600 --> 00:01:37,840
that will maximize your investments as

00:01:35,680 --> 00:01:40,240
you start to adopt federated modules

00:01:37,840 --> 00:01:41,280
into your enterprise applications a lot

00:01:40,240 --> 00:01:42,960
of parameters

00:01:41,280 --> 00:01:45,280
for distributed functionality already

00:01:42,960 --> 00:01:46,079
exist in the microservices world and so

00:01:45,280 --> 00:01:48,399
we can start

00:01:46,079 --> 00:01:49,840
there how do we know what modules are

00:01:48,399 --> 00:01:51,840
even available to us

00:01:49,840 --> 00:01:53,520
well imagine we have a dashboard i.e the

00:01:51,840 --> 00:01:55,200
consumer and a number of producers in

00:01:53,520 --> 00:01:57,759
the form of federated modules

00:01:55,200 --> 00:01:58,560
how do we signal that these modules are

00:01:57,759 --> 00:02:00,399
available

00:01:58,560 --> 00:02:02,240
well i've created a central registry

00:02:00,399 --> 00:02:04,799
named ledger

00:02:02,240 --> 00:02:06,960
that allows us to register modules and

00:02:04,799 --> 00:02:09,039
then the consumer can query the ledger

00:02:06,960 --> 00:02:10,800
for available modules which can be

00:02:09,039 --> 00:02:13,440
surfaced to the consumer

00:02:10,800 --> 00:02:15,520
and ultimately consumed and we can

00:02:13,440 --> 00:02:18,800
continue to register new modules

00:02:15,520 --> 00:02:20,400
for consumption and repeat this process

00:02:18,800 --> 00:02:23,200
until ai takes over the world

00:02:20,400 --> 00:02:25,280
and we become consumable modules ourself

00:02:23,200 --> 00:02:27,360
but more on that in a future

00:02:25,280 --> 00:02:28,959
breakout session perfect segue though

00:02:27,360 --> 00:02:31,120
into health check

00:02:28,959 --> 00:02:32,080
not only do we need to know what modules

00:02:31,120 --> 00:02:35,360
are available

00:02:32,080 --> 00:02:37,040
but which modules are healthy so let's

00:02:35,360 --> 00:02:39,519
imagine a black swan event

00:02:37,040 --> 00:02:40,239
where all our modules are inexplicably

00:02:39,519 --> 00:02:42,720
healthy

00:02:40,239 --> 00:02:44,959
well the universe notices this and

00:02:42,720 --> 00:02:47,599
there's trouble in paradise a module

00:02:44,959 --> 00:02:48,720
goes offline because the ledger is

00:02:47,599 --> 00:02:51,280
monitoring all

00:02:48,720 --> 00:02:51,920
hosted modules we detect this almost

00:02:51,280 --> 00:02:53,840
immediately

00:02:51,920 --> 00:02:55,200
which then marks the offline module is

00:02:53,840 --> 00:02:57,040
unhealthy and

00:02:55,200 --> 00:02:58,800
using websockets we can signal to our

00:02:57,040 --> 00:03:00,800
consumer that a module is unhealthy

00:02:58,800 --> 00:03:02,560
and that we can take that offline

00:03:00,800 --> 00:03:04,560
another use case is the ability to

00:03:02,560 --> 00:03:06,080
dynamically service modules based on the

00:03:04,560 --> 00:03:08,239
identity of the consumer

00:03:06,080 --> 00:03:10,080
for instance we have a premium consumer

00:03:08,239 --> 00:03:10,640
who's purchased our highest enterprise

00:03:10,080 --> 00:03:12,159
plan

00:03:10,640 --> 00:03:13,840
they get all the modules but a

00:03:12,159 --> 00:03:15,920
restricted user may

00:03:13,840 --> 00:03:17,040
only be served a subset of modules based

00:03:15,920 --> 00:03:18,879
on their login

00:03:17,040 --> 00:03:20,640
along those lines split testing is

00:03:18,879 --> 00:03:22,080
another great application of this

00:03:20,640 --> 00:03:25,200
we have two variations of the same

00:03:22,080 --> 00:03:26,400
module that we want to split test across

00:03:25,200 --> 00:03:27,920
two or more consumers

00:03:26,400 --> 00:03:29,599
well we can serve one module to one

00:03:27,920 --> 00:03:32,319
subset and another module to

00:03:29,599 --> 00:03:33,440
another subset or vice versa and now my

00:03:32,319 --> 00:03:35,760
favorite example

00:03:33,440 --> 00:03:36,959
module inception federated modules

00:03:35,760 --> 00:03:39,040
inside of federated

00:03:36,959 --> 00:03:40,319
modules my friend was telling me an

00:03:39,040 --> 00:03:41,040
issue that he had with jira the other

00:03:40,319 --> 00:03:44,560
day

00:03:41,040 --> 00:03:45,280
that he noticed a start work in vs code

00:03:44,560 --> 00:03:48,159
line item

00:03:45,280 --> 00:03:49,440
without opting in to this feature i have

00:03:48,159 --> 00:03:51,040
nothing against your and certainly

00:03:49,440 --> 00:03:53,040
nothing against vs code

00:03:51,040 --> 00:03:55,200
but this was a cloud infrastructure

00:03:53,040 --> 00:03:58,159
project and as a result this was hard

00:03:55,200 --> 00:03:58,640
a hard-coded and unwanted feature this

00:03:58,159 --> 00:04:00,159
could have

00:03:58,640 --> 00:04:01,920
easily been solved by allowing for the

00:04:00,159 --> 00:04:03,920
ability to dynamically compose

00:04:01,920 --> 00:04:06,000
features based on federated module

00:04:03,920 --> 00:04:06,560
consumption i imagine it would look like

00:04:06,000 --> 00:04:08,879
this

00:04:06,560 --> 00:04:10,239
you have a dynamic module outlet you can

00:04:08,879 --> 00:04:11,760
make available in the ledger

00:04:10,239 --> 00:04:13,680
which would allow you to assemble

00:04:11,760 --> 00:04:16,720
features however you please

00:04:13,680 --> 00:04:18,239
and then rearrange them at will now let

00:04:16,720 --> 00:04:19,280
me get you off of this cliffhanger and

00:04:18,239 --> 00:04:22,320
show you what

00:04:19,280 --> 00:04:25,040
this looks like now what we have here

00:04:22,320 --> 00:04:27,199
on the left hand side is the ledger and

00:04:25,040 --> 00:04:29,680
i have a secondary module queued up

00:04:27,199 --> 00:04:30,479
as well as a third module that we'll see

00:04:29,680 --> 00:04:32,639
in just a moment

00:04:30,479 --> 00:04:33,520
and you can see these modules are

00:04:32,639 --> 00:04:36,639
standalone

00:04:33,520 --> 00:04:39,199
and hosted and so if i go back to

00:04:36,639 --> 00:04:41,120
this first tab and i save you can see

00:04:39,199 --> 00:04:42,160
that this is now immediately available

00:04:41,120 --> 00:04:44,000
to the dashboard

00:04:42,160 --> 00:04:46,000
i'm going to make this available to the

00:04:44,000 --> 00:04:49,040
application and you can see it

00:04:46,000 --> 00:04:49,919
now if i go back to this tab here i'm

00:04:49,040 --> 00:04:52,400
going to shut down

00:04:49,919 --> 00:04:52,960
the secondary server you can see now it

00:04:52,400 --> 00:04:54,479
fails

00:04:52,960 --> 00:04:56,000
the health check and so what i'm going

00:04:54,479 --> 00:04:58,479
to do is i'm just going to spin this

00:04:56,000 --> 00:05:00,000
back up and you'll notice that at some

00:04:58,479 --> 00:05:02,720
point this is going to

00:05:00,000 --> 00:05:03,600
turn green in the meantime i'm going to

00:05:02,720 --> 00:05:05,600
go ahead

00:05:03,600 --> 00:05:07,120
and i'm going to create this third

00:05:05,600 --> 00:05:10,639
module that has a module

00:05:07,120 --> 00:05:12,720
inside of a module so you can see that

00:05:10,639 --> 00:05:15,680
the secondary module just went healthy

00:05:12,720 --> 00:05:17,199
and i'm going to add in this third

00:05:15,680 --> 00:05:20,080
module this partner module

00:05:17,199 --> 00:05:22,320
that when i make this available it has

00:05:20,080 --> 00:05:22,800
this outside federated module and inside

00:05:22,320 --> 00:05:25,039
of that

00:05:22,800 --> 00:05:26,800
it has this primary federator module

00:05:25,039 --> 00:05:29,600
which is the same module

00:05:26,800 --> 00:05:30,560
up here and so that is the example if

00:05:29,600 --> 00:05:32,880
you want to check

00:05:30,560 --> 00:05:35,039
out the source code for this you can

00:05:32,880 --> 00:05:37,199
check it out at this url here

00:05:35,039 --> 00:05:38,800
and please ping me on twitter at

00:05:37,199 --> 00:05:40,160
simpleton and above all

00:05:38,800 --> 00:05:43,120
thank you for your time i hope you

00:05:40,160 --> 00:05:43,120

YouTube URL: https://www.youtube.com/watch?v=6c8HiVpMWvs


