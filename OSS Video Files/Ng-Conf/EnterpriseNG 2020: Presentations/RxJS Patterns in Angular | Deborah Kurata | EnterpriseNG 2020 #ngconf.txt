Title: RxJS Patterns in Angular | Deborah Kurata | EnterpriseNG 2020Â #ngconf
Publication date: 2021-06-07
Playlist: EnterpriseNG 2020: Presentations
Description: 
	Following common RxJS patterns can save you time, and improve the quality and simplify the maintenance of your Angular code. This session walks through several common coding scenarios and useful RxJS patterns to implement those scenarios.

Learn the best ways to build reliable web applications, write quality code, choose scalable architectures, and create effective automated tests at the Reliable Web Summit this August 26-27, 2021. Powered by the team at ng-conf.
Get your ticket ðŸ‘‰ https://reliablewebsummit.com/

ng-conf is a multi-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1000's of developers from across the globe join together to attend talks and workshops by the Angular team and other community experts.

Follow us on twitter https://twitter.com/ngconfâ€‹ 
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:00,120 --> 00:00:17,279
[Music]

00:00:03,840 --> 00:00:19,920
let us

00:00:17,279 --> 00:00:20,960
as angular developers we often work with

00:00:19,920 --> 00:00:24,160
rxjs

00:00:20,960 --> 00:00:25,840
and observables over time we see common

00:00:24,160 --> 00:00:27,920
patterns emerging

00:00:25,840 --> 00:00:29,119
in this session we'll look at a few of

00:00:27,920 --> 00:00:31,119
these patterns

00:00:29,119 --> 00:00:33,680
and along the way i'll share some tips

00:00:31,119 --> 00:00:36,320
for working with rxjs

00:00:33,680 --> 00:00:38,879
my name is deborah karata i'm a software

00:00:36,320 --> 00:00:41,120
developer and pluralsight author

00:00:38,879 --> 00:00:43,040
let's start off with a general tip for

00:00:41,120 --> 00:00:46,640
how to think about rxjs

00:00:43,040 --> 00:00:46,640
and observable pipelines

00:00:46,960 --> 00:00:55,520
consider what do you have

00:00:50,239 --> 00:00:58,239
what do you want and when do you want it

00:00:55,520 --> 00:00:58,879
here's our sample application we want to

00:00:58,239 --> 00:01:02,160
display

00:00:58,879 --> 00:01:05,920
a list of products here on the left

00:01:02,160 --> 00:01:07,439
so what do we have well starting off we

00:01:05,920 --> 00:01:09,680
don't have anything

00:01:07,439 --> 00:01:10,560
what do we want we want that list of

00:01:09,680 --> 00:01:12,479
products

00:01:10,560 --> 00:01:14,320
when do we want it we want it when the

00:01:12,479 --> 00:01:15,840
page is loaded

00:01:14,320 --> 00:01:18,960
here's our classic pattern for

00:01:15,840 --> 00:01:21,119
retrieving data here's our service code

00:01:18,960 --> 00:01:23,920
we have a get products method that

00:01:21,119 --> 00:01:26,479
issues an http get request

00:01:23,920 --> 00:01:27,439
it returns an observable of product

00:01:26,479 --> 00:01:29,840
array

00:01:27,439 --> 00:01:30,960
what's our next step then that comes to

00:01:29,840 --> 00:01:33,360
our next tip

00:01:30,960 --> 00:01:34,640
we need to ensure each observable is

00:01:33,360 --> 00:01:37,360
subscribed

00:01:34,640 --> 00:01:39,280
and ensure each subscription is

00:01:37,360 --> 00:01:42,799
unsubscribed

00:01:39,280 --> 00:01:45,040
so our classic pattern in our component

00:01:42,799 --> 00:01:46,079
we wanted to retrieve the data when the

00:01:45,040 --> 00:01:48,560
page is loaded

00:01:46,079 --> 00:01:49,840
so in the ng on init is where we do our

00:01:48,560 --> 00:01:52,159
subscribe

00:01:49,840 --> 00:01:54,159
we store that subscription so that when

00:01:52,159 --> 00:01:57,280
the page is unloaded in our ng

00:01:54,159 --> 00:01:59,119
on destroy we can unsubscribe

00:01:57,280 --> 00:02:01,680
but what if we thought about this

00:01:59,119 --> 00:02:02,479
differently what if instead of using a

00:02:01,680 --> 00:02:05,520
procedure

00:02:02,479 --> 00:02:06,640
our get products we instead declared a

00:02:05,520 --> 00:02:08,720
variable

00:02:06,640 --> 00:02:10,160
so here we've got products dollar in our

00:02:08,720 --> 00:02:13,599
service instead

00:02:10,160 --> 00:02:16,560
but it's set to the exact same uh http

00:02:13,599 --> 00:02:18,959
get request that we had in our method

00:02:16,560 --> 00:02:21,120
the products dollar that dollar sign is

00:02:18,959 --> 00:02:22,080
indicating that what we have here is an

00:02:21,120 --> 00:02:24,800
observable

00:02:22,080 --> 00:02:26,000
and not the actual data itself so it's

00:02:24,800 --> 00:02:29,040
an observable

00:02:26,000 --> 00:02:32,400
of product array not the product array

00:02:29,040 --> 00:02:34,239
so in our component instead of our ng on

00:02:32,400 --> 00:02:36,160
init and our ng on destroy

00:02:34,239 --> 00:02:37,519
and all of the extra code for managing

00:02:36,160 --> 00:02:40,000
our subscription

00:02:37,519 --> 00:02:41,519
we could just have this so we define

00:02:40,000 --> 00:02:43,920
another local variable

00:02:41,519 --> 00:02:44,560
products dollar and just assign it to

00:02:43,920 --> 00:02:47,760
our product

00:02:44,560 --> 00:02:49,680
service uh products dollar and

00:02:47,760 --> 00:02:51,120
you could add some exception handling

00:02:49,680 --> 00:02:54,879
there

00:02:51,120 --> 00:02:57,360
but what about our prior tip how are we

00:02:54,879 --> 00:02:58,640
subscribing and unsubscribing then if we

00:02:57,360 --> 00:03:00,080
aren't

00:02:58,640 --> 00:03:02,239
technically subscribing and

00:03:00,080 --> 00:03:04,000
unsubscribing how do we deal with that

00:03:02,239 --> 00:03:05,920
well that brings up our next tip which

00:03:04,000 --> 00:03:08,800
is to use the async pipe

00:03:05,920 --> 00:03:09,280
the async pipe automatically subscribes

00:03:08,800 --> 00:03:12,159
and

00:03:09,280 --> 00:03:14,800
automatically unsubscribes for us so in

00:03:12,159 --> 00:03:16,640
our template we have some code like this

00:03:14,800 --> 00:03:18,640
so we have our products dollar that

00:03:16,640 --> 00:03:22,159
we're binding to from our component

00:03:18,640 --> 00:03:23,680
we use the async pipe to uh subscribe

00:03:22,159 --> 00:03:26,959
and unsubscribe to that

00:03:23,680 --> 00:03:29,200
for us the as products clause defines

00:03:26,959 --> 00:03:32,239
the variable that the value is emitted

00:03:29,200 --> 00:03:35,040
into and we can then use that value

00:03:32,239 --> 00:03:36,640
throughout our template so here's our

00:03:35,040 --> 00:03:39,280
first declarative pattern

00:03:36,640 --> 00:03:40,720
our declarative data access pattern

00:03:39,280 --> 00:03:42,799
starting at the bottom

00:03:40,720 --> 00:03:43,840
we have our products dollar and our

00:03:42,799 --> 00:03:45,760
service

00:03:43,840 --> 00:03:47,200
in the middle we have our products

00:03:45,760 --> 00:03:48,959
dollar and our component

00:03:47,200 --> 00:03:51,519
and then in our template we're using our

00:03:48,959 --> 00:03:54,799
async pipe

00:03:51,519 --> 00:03:56,879
i tend to do my marble diagrams

00:03:54,799 --> 00:03:58,000
more simplistically to sort of make a

00:03:56,879 --> 00:04:01,040
point a little bit more

00:03:58,000 --> 00:04:04,319
artistically so here is

00:04:01,040 --> 00:04:04,959
the data stream it is then returning and

00:04:04,319 --> 00:04:07,920
emitting

00:04:04,959 --> 00:04:08,720
that set of data our array of products

00:04:07,920 --> 00:04:10,959
that

00:04:08,720 --> 00:04:14,239
vertical line is identifying that it's

00:04:10,959 --> 00:04:16,320
done whenever we issue an http request

00:04:14,239 --> 00:04:18,079
it is one and done it returns the

00:04:16,320 --> 00:04:21,359
response and then it's

00:04:18,079 --> 00:04:22,400
finished all right so let's look at

00:04:21,359 --> 00:04:25,440
another one

00:04:22,400 --> 00:04:28,560
we frequently end up having to pass data

00:04:25,440 --> 00:04:30,720
so here in this example we have way too

00:04:28,560 --> 00:04:32,960
many products to show the user

00:04:30,720 --> 00:04:34,960
so we want them to pick some criteria

00:04:32,960 --> 00:04:36,479
maybe we want to do paging maybe we want

00:04:34,960 --> 00:04:38,560
them to pick a category

00:04:36,479 --> 00:04:40,320
in this example we're having them pick a

00:04:38,560 --> 00:04:42,880
category so that we're only showing

00:04:40,320 --> 00:04:44,639
products from a particular category

00:04:42,880 --> 00:04:46,240
but this code as we have it written

00:04:44,639 --> 00:04:48,240
isn't going to work because

00:04:46,240 --> 00:04:50,479
where is that category id going to come

00:04:48,240 --> 00:04:52,880
from so what do we do

00:04:50,479 --> 00:04:53,840
we start with our questions what do we

00:04:52,880 --> 00:04:57,360
have

00:04:53,840 --> 00:04:59,840
what do we want and when do we want it

00:04:57,360 --> 00:05:01,680
so what do we have well the user is

00:04:59,840 --> 00:05:03,440
going to pick a category so we have the

00:05:01,680 --> 00:05:05,600
category that they picked

00:05:03,440 --> 00:05:07,440
what do we want we want the set of

00:05:05,600 --> 00:05:09,600
products for that category

00:05:07,440 --> 00:05:11,360
and when do we want it every time the

00:05:09,600 --> 00:05:14,160
user picks a different category we want

00:05:11,360 --> 00:05:17,039
to go out and get those products

00:05:14,160 --> 00:05:18,560
so we have an action of the user picking

00:05:17,039 --> 00:05:22,479
that category

00:05:18,560 --> 00:05:25,120
how do we work with an action in rxjs

00:05:22,479 --> 00:05:26,000
well to respond to an action use a

00:05:25,120 --> 00:05:30,240
subject

00:05:26,000 --> 00:05:33,360
or behavior subject that's our next tip

00:05:30,240 --> 00:05:35,919
so a subject the common pattern for

00:05:33,360 --> 00:05:36,880
doing a subject or behavior subject is

00:05:35,919 --> 00:05:40,720
this

00:05:36,880 --> 00:05:41,360
when we issue an http request the http

00:05:40,720 --> 00:05:44,000
service

00:05:41,360 --> 00:05:44,639
automatically creates an observable for

00:05:44,000 --> 00:05:47,520
us

00:05:44,639 --> 00:05:48,960
and it automatically emits the response

00:05:47,520 --> 00:05:52,000
from that request

00:05:48,960 --> 00:05:54,320
into that observable

00:05:52,000 --> 00:05:56,000
when we're dealing with our own actions

00:05:54,320 --> 00:05:59,199
we need to define our own

00:05:56,000 --> 00:06:02,080
observables and we do that using subject

00:05:59,199 --> 00:06:04,080
and behavior subject so that first line

00:06:02,080 --> 00:06:07,120
is defining a private variable

00:06:04,080 --> 00:06:09,600
for our new subject and the generic

00:06:07,120 --> 00:06:11,600
argument there is defining the type of

00:06:09,600 --> 00:06:14,479
item that's going to be emitted

00:06:11,600 --> 00:06:16,240
into that stream notice that we have the

00:06:14,479 --> 00:06:18,240
private keyword on there

00:06:16,240 --> 00:06:20,319
we do that because we don't want any

00:06:18,240 --> 00:06:21,840
other part of the application any other

00:06:20,319 --> 00:06:25,120
component or service

00:06:21,840 --> 00:06:29,120
to be able to emit values or

00:06:25,120 --> 00:06:32,319
potentially complete are observable

00:06:29,120 --> 00:06:35,520
but we still want to have the ability to

00:06:32,319 --> 00:06:37,039
access the read only or observable part

00:06:35,520 --> 00:06:39,199
and that's the purpose of the second

00:06:37,039 --> 00:06:41,199
line so here we're dividing an

00:06:39,199 --> 00:06:41,840
observable notice the dollar at the end

00:06:41,199 --> 00:06:43,600
there

00:06:41,840 --> 00:06:44,880
and we're setting it equal to our

00:06:43,600 --> 00:06:48,000
subjects

00:06:44,880 --> 00:06:49,759
observable using as observable so what's

00:06:48,000 --> 00:06:51,360
the difference between a subject and a

00:06:49,759 --> 00:06:53,199
behavior subject

00:06:51,360 --> 00:06:55,520
well with a subject when you first

00:06:53,199 --> 00:06:57,199
subscribe you don't get any initial

00:06:55,520 --> 00:06:59,599
value

00:06:57,199 --> 00:07:02,560
you won't get a value until another

00:06:59,599 --> 00:07:05,360
value is emitted into the stream

00:07:02,560 --> 00:07:07,280
for a behavior subject if a value has

00:07:05,360 --> 00:07:09,039
already been emitted into the stream you

00:07:07,280 --> 00:07:11,280
will get the last one

00:07:09,039 --> 00:07:12,479
if no values yet been emitted you get

00:07:11,280 --> 00:07:14,319
the default value

00:07:12,479 --> 00:07:17,360
which is what you specify in the

00:07:14,319 --> 00:07:20,400
constructor of the behavior subject

00:07:17,360 --> 00:07:22,880
okay so once we have

00:07:20,400 --> 00:07:23,599
our action stream how do we get a value

00:07:22,880 --> 00:07:27,199
into it

00:07:23,599 --> 00:07:30,599
well we emit it we emit a value

00:07:27,199 --> 00:07:32,000
using next so we use

00:07:30,599 --> 00:07:34,080
this.categorysubject.next

00:07:32,000 --> 00:07:35,840
and define whatever we want to be

00:07:34,080 --> 00:07:39,360
emitted into that stream in this

00:07:35,840 --> 00:07:39,360
case a category id

00:07:40,800 --> 00:07:45,520
so here's our pattern our retrieve on

00:07:43,360 --> 00:07:47,599
action pattern what we have

00:07:45,520 --> 00:07:48,560
we have a subject that is going to be

00:07:47,599 --> 00:07:53,440
notified

00:07:48,560 --> 00:07:53,440
every time the user picks a category

00:07:54,639 --> 00:07:58,000
what do we want we want our products

00:07:56,879 --> 00:08:01,440
dollar and that's what we're

00:07:58,000 --> 00:08:03,199
going to bind to our products dollar

00:08:01,440 --> 00:08:05,520
what is that code going to look like

00:08:03,199 --> 00:08:07,199
there as it's written here there are two

00:08:05,520 --> 00:08:09,039
issues with this code

00:08:07,199 --> 00:08:11,280
first of all we have this inner

00:08:09,039 --> 00:08:12,960
observable and we're not subscribing to

00:08:11,280 --> 00:08:13,759
it remember that tip we have to

00:08:12,960 --> 00:08:16,560
subscribe

00:08:13,759 --> 00:08:16,879
and we should unsubscribe and second of

00:08:16,560 --> 00:08:18,639
all

00:08:16,879 --> 00:08:20,319
maybe we don't quite know what kind of

00:08:18,639 --> 00:08:23,360
map to use here

00:08:20,319 --> 00:08:26,080
so how do we solve these two problems

00:08:23,360 --> 00:08:27,520
that brings us to our next tip leverage

00:08:26,080 --> 00:08:30,080
your ide

00:08:27,520 --> 00:08:30,800
what do i mean by that well without even

00:08:30,080 --> 00:08:33,680
running

00:08:30,800 --> 00:08:36,080
you can hover over your values in your

00:08:33,680 --> 00:08:36,719
ide so here we're hovering over products

00:08:36,080 --> 00:08:39,599
dollar

00:08:36,719 --> 00:08:41,279
and you can see what their types are so

00:08:39,599 --> 00:08:43,440
if we just used a map

00:08:41,279 --> 00:08:44,959
instead of a different kind of operator

00:08:43,440 --> 00:08:48,399
here we would see

00:08:44,959 --> 00:08:51,760
that it would return us an observable

00:08:48,399 --> 00:08:54,160
of observable of product array

00:08:51,760 --> 00:08:56,399
and that's not what we want we need to

00:08:54,160 --> 00:08:57,839
flatten that we just want the observable

00:08:56,399 --> 00:09:00,720
of product array

00:08:57,839 --> 00:09:02,080
to be um emitted from our products

00:09:00,720 --> 00:09:05,040
dollar

00:09:02,080 --> 00:09:05,600
observable stream so how do we deal with

00:09:05,040 --> 00:09:08,560
that

00:09:05,600 --> 00:09:08,959
well you guessed it we have another tip

00:09:08,560 --> 00:09:12,800
um

00:09:08,959 --> 00:09:15,680
to subscribe to an inner observable and

00:09:12,800 --> 00:09:17,279
flatten the result use a higher order

00:09:15,680 --> 00:09:19,519
mapping operator

00:09:17,279 --> 00:09:21,519
these are sometimes called flattening

00:09:19,519 --> 00:09:24,399
operators

00:09:21,519 --> 00:09:26,560
what is a higher order mapping operator

00:09:24,399 --> 00:09:28,560
well a higher order mapping operator is

00:09:26,560 --> 00:09:31,519
an operator that will automatically

00:09:28,560 --> 00:09:34,080
subscribe to your inner observable

00:09:31,519 --> 00:09:35,519
it also flattens the resulting

00:09:34,080 --> 00:09:38,000
observable

00:09:35,519 --> 00:09:39,120
so it will instead return observable of

00:09:38,000 --> 00:09:41,760
your type

00:09:39,120 --> 00:09:42,959
not observable of observable of your

00:09:41,760 --> 00:09:46,000
type

00:09:42,959 --> 00:09:47,920
it also automatically unsubscribes from

00:09:46,000 --> 00:09:49,920
that inner observable

00:09:47,920 --> 00:09:51,200
cool all right we're going to look at

00:09:49,920 --> 00:09:52,959
three of

00:09:51,200 --> 00:09:55,920
the common higher order mapping

00:09:52,959 --> 00:09:58,320
operators first there's switch map

00:09:55,920 --> 00:10:01,200
switch map stops the current operation

00:09:58,320 --> 00:10:04,160
and performs the new operation

00:10:01,200 --> 00:10:04,880
concat map performs each operation one

00:10:04,160 --> 00:10:08,720
at a time

00:10:04,880 --> 00:10:11,920
in order and merge map performs each

00:10:08,720 --> 00:10:15,120
operation concurrently

00:10:11,920 --> 00:10:17,600
okay so going back to our retrieve on

00:10:15,120 --> 00:10:20,160
action pattern we have our action

00:10:17,600 --> 00:10:21,600
and this is what our pattern is going to

00:10:20,160 --> 00:10:24,640
look like here

00:10:21,600 --> 00:10:27,440
so we have our category selected action

00:10:24,640 --> 00:10:28,480
when it emits we're going to use the

00:10:27,440 --> 00:10:31,519
switch map

00:10:28,480 --> 00:10:32,560
to take the category id emitted from the

00:10:31,519 --> 00:10:35,760
action stream

00:10:32,560 --> 00:10:39,040
and issue our http get we can now then

00:10:35,760 --> 00:10:41,519
use our category id in the url

00:10:39,040 --> 00:10:43,040
why switch map and not one of the others

00:10:41,519 --> 00:10:45,360
well switch map

00:10:43,040 --> 00:10:46,959
is good to use anytime that the user

00:10:45,360 --> 00:10:48,959
could be changing their mind

00:10:46,959 --> 00:10:50,720
so i'm gonna pick category one oh no i

00:10:48,959 --> 00:10:52,640
wanted category seven

00:10:50,720 --> 00:10:53,839
what the switch map will do is even

00:10:52,640 --> 00:10:56,160
though it might start

00:10:53,839 --> 00:10:58,800
getting the data for category one as

00:10:56,160 --> 00:11:01,040
soon as it sees the next item emitted

00:10:58,800 --> 00:11:03,440
hey i really wanted category seven it

00:11:01,040 --> 00:11:05,920
will stop that first one cancel it

00:11:03,440 --> 00:11:06,640
and go ahead and execute then the

00:11:05,920 --> 00:11:09,920
retrieve

00:11:06,640 --> 00:11:13,360
for category seven

00:11:09,920 --> 00:11:15,360
okay if we then hovered over

00:11:13,360 --> 00:11:17,120
products dollar we'd see that it did

00:11:15,360 --> 00:11:19,279
correctly

00:11:17,120 --> 00:11:20,160
flatten our observable so we now have an

00:11:19,279 --> 00:11:23,279
observable

00:11:20,160 --> 00:11:23,279
of product array

00:11:23,519 --> 00:11:28,399
so using our ide we can frequently check

00:11:26,160 --> 00:11:29,440
our types which can be very helpful to

00:11:28,399 --> 00:11:32,079
ensure

00:11:29,440 --> 00:11:33,040
especially as our pipelines get more

00:11:32,079 --> 00:11:35,519
complex

00:11:33,040 --> 00:11:37,839
that each one is returning what we

00:11:35,519 --> 00:11:39,680
expect it to be returning

00:11:37,839 --> 00:11:40,880
all right here's my fabulous marble

00:11:39,680 --> 00:11:43,519
diagram for this

00:11:40,880 --> 00:11:46,320
the user picks category with 42 the

00:11:43,519 --> 00:11:48,560
result stream has the products for 42

00:11:46,320 --> 00:11:50,000
if they later pick 15 they get the new

00:11:48,560 --> 00:11:51,279
products for that

00:11:50,000 --> 00:11:54,240
and you'll notice that there are no

00:11:51,279 --> 00:11:56,480
vertical bars on there it will keep

00:11:54,240 --> 00:11:57,360
emitting values as long as that page is

00:11:56,480 --> 00:12:01,200
displayed

00:11:57,360 --> 00:12:03,760
it won't terminate the stream until

00:12:01,200 --> 00:12:05,600
the user leaves the page because of our

00:12:03,760 --> 00:12:08,160
async pipe

00:12:05,600 --> 00:12:09,519
the next pattern is the shape on action

00:12:08,160 --> 00:12:12,639
pattern

00:12:09,519 --> 00:12:14,160
so let's again ask our questions what do

00:12:12,639 --> 00:12:16,000
we have well in this case

00:12:14,160 --> 00:12:18,639
now we have our list of products on the

00:12:16,000 --> 00:12:20,720
left what do we want we want to display

00:12:18,639 --> 00:12:21,920
the detail for the one product that the

00:12:20,720 --> 00:12:23,760
user picked

00:12:21,920 --> 00:12:25,040
when do we want it anytime the user

00:12:23,760 --> 00:12:27,040
picks one on the left

00:12:25,040 --> 00:12:28,399
we want to display that product on the

00:12:27,040 --> 00:12:31,600
right

00:12:28,399 --> 00:12:33,519
okay so how do we do it

00:12:31,600 --> 00:12:35,200
so here is our products we already

00:12:33,519 --> 00:12:36,000
talked about this this is the code that

00:12:35,200 --> 00:12:39,440
we just

00:12:36,000 --> 00:12:42,000
finished talking about and we want

00:12:39,440 --> 00:12:43,600
to change the shape of this based on an

00:12:42,000 --> 00:12:44,959
action all right so we already know the

00:12:43,600 --> 00:12:46,800
pattern for an action

00:12:44,959 --> 00:12:48,079
is to define a subject or behavior

00:12:46,800 --> 00:12:49,920
subject here

00:12:48,079 --> 00:12:52,240
now if the user hasn't picked a product

00:12:49,920 --> 00:12:54,399
yet we don't want to display anything so

00:12:52,240 --> 00:12:56,160
we don't need any kind of default value

00:12:54,399 --> 00:12:57,920
so that means we'll use a subject and

00:12:56,160 --> 00:13:01,040
not a behavior subject

00:12:57,920 --> 00:13:03,600
so here is our product selected action

00:13:01,040 --> 00:13:05,120
so now we have two streams we've got our

00:13:03,600 --> 00:13:09,040
products and we've got

00:13:05,120 --> 00:13:11,519
our selected product how are we going to

00:13:09,040 --> 00:13:13,920
work with the two of them together

00:13:11,519 --> 00:13:15,519
that brings us to our next step to work

00:13:13,920 --> 00:13:19,279
with multiple streams

00:13:15,519 --> 00:13:22,240
use a combination operator

00:13:19,279 --> 00:13:23,200
combination operators combine multiple

00:13:22,240 --> 00:13:25,680
streams just as

00:13:23,200 --> 00:13:27,600
as the name sounds we're going to talk

00:13:25,680 --> 00:13:30,320
about three of the most common one

00:13:27,600 --> 00:13:30,720
combine latest emits a combined value

00:13:30,320 --> 00:13:33,519
when

00:13:30,720 --> 00:13:34,000
any of the observables emit and it won't

00:13:33,519 --> 00:13:36,240
emit

00:13:34,000 --> 00:13:37,519
until all observables have admitted at

00:13:36,240 --> 00:13:39,120
least once

00:13:37,519 --> 00:13:40,880
so the nice thing is there if you're

00:13:39,120 --> 00:13:43,120
doing multiple retrieves

00:13:40,880 --> 00:13:45,199
it will not continue and try to work

00:13:43,120 --> 00:13:46,560
with all that data until it's actually

00:13:45,199 --> 00:13:48,079
received all of it

00:13:46,560 --> 00:13:50,399
so that's great when you have to hit

00:13:48,079 --> 00:13:51,199
multiple endpoints to retrieve the data

00:13:50,399 --> 00:13:55,360
you need for an

00:13:51,199 --> 00:13:58,079
operation merge emits one value when any

00:13:55,360 --> 00:14:00,399
of the observables that are merged emits

00:13:58,079 --> 00:14:02,160
merge is best used when you're merging

00:14:00,399 --> 00:14:03,920
things of like types

00:14:02,160 --> 00:14:06,000
for typing purposes you really don't

00:14:03,920 --> 00:14:07,920
want to emit into the same stream

00:14:06,000 --> 00:14:09,120
a customer and then an order and then

00:14:07,920 --> 00:14:11,040
odd things

00:14:09,120 --> 00:14:12,959
what you would instead use it for is if

00:14:11,040 --> 00:14:13,600
you need to get customers from one end

00:14:12,959 --> 00:14:15,440
point

00:14:13,600 --> 00:14:17,120
and potential customers from another

00:14:15,440 --> 00:14:18,079
endpoint and you want to merge them into

00:14:17,120 --> 00:14:20,720
one list

00:14:18,079 --> 00:14:21,839
you could use merge and then there's

00:14:20,720 --> 00:14:23,680
fork join

00:14:21,839 --> 00:14:25,519
the important thing to note about fork

00:14:23,680 --> 00:14:28,639
join is it only

00:14:25,519 --> 00:14:31,519
finishes it only starts its pipeline

00:14:28,639 --> 00:14:32,800
when all observables complete so you

00:14:31,519 --> 00:14:35,279
don't want to fork join

00:14:32,800 --> 00:14:35,920
action observables because they're set

00:14:35,279 --> 00:14:38,639
up to not

00:14:35,920 --> 00:14:40,480
complete until you're leaving um so when

00:14:38,639 --> 00:14:42,560
the all observables that you're joining

00:14:40,480 --> 00:14:45,040
complete you emit the last value from

00:14:42,560 --> 00:14:47,920
each observable into an array

00:14:45,040 --> 00:14:48,880
all right so we've got our products

00:14:47,920 --> 00:14:51,120
we've got our

00:14:48,880 --> 00:14:52,000
action and we're going to combine them

00:14:51,120 --> 00:14:54,240
with combine

00:14:52,000 --> 00:14:55,600
latest so there's our products our

00:14:54,240 --> 00:14:57,600
product selection

00:14:55,600 --> 00:15:01,440
and then we can use the find to find the

00:14:57,600 --> 00:15:01,440
one particular one that we want

00:15:01,600 --> 00:15:05,760
here is the marble diagram for that so

00:15:04,399 --> 00:15:07,760
our data stream

00:15:05,760 --> 00:15:08,800
user says i want product one we're going

00:15:07,760 --> 00:15:12,560
to get saw

00:15:08,800 --> 00:15:13,680
the later later go if the user later

00:15:12,560 --> 00:15:17,199
picks

00:15:13,680 --> 00:15:19,600
product 3 they'll get the x

00:15:17,199 --> 00:15:20,720
all right so let's dive right into our

00:15:19,600 --> 00:15:23,920
last pattern

00:15:20,720 --> 00:15:25,440
retrieve related data pattern

00:15:23,920 --> 00:15:27,279
so let's talk through again our

00:15:25,440 --> 00:15:30,160
questions what do we have

00:15:27,279 --> 00:15:31,040
well we have a product what do we want

00:15:30,160 --> 00:15:34,079
we want that

00:15:31,040 --> 00:15:35,920
products supplier when do we want it

00:15:34,079 --> 00:15:37,360
anytime the product changes we want to

00:15:35,920 --> 00:15:39,279
get the supplier

00:15:37,360 --> 00:15:41,759
now here we have two kind of sub

00:15:39,279 --> 00:15:42,160
patterns one case when there's a one to

00:15:41,759 --> 00:15:44,160
one

00:15:42,160 --> 00:15:46,000
relationship meaning every product has

00:15:44,160 --> 00:15:47,759
one and only one supplier

00:15:46,000 --> 00:15:49,600
and one when there are multiple when

00:15:47,759 --> 00:15:52,560
each product could have

00:15:49,600 --> 00:15:54,079
one or more suppliers so let's look at

00:15:52,560 --> 00:15:56,000
the first one first

00:15:54,079 --> 00:15:57,839
so this is our retrieve related data

00:15:56,000 --> 00:15:59,279
pattern when there is a one-to-one

00:15:57,839 --> 00:16:01,279
relationship

00:15:59,279 --> 00:16:03,279
so we have our selected product we've

00:16:01,279 --> 00:16:05,759
seen that one before

00:16:03,279 --> 00:16:06,880
and what we're going to do is pipe that

00:16:05,759 --> 00:16:09,440
one through

00:16:06,880 --> 00:16:11,360
another pipeline and here we're going to

00:16:09,440 --> 00:16:12,000
use switch map again because the user

00:16:11,360 --> 00:16:13,920
could say

00:16:12,000 --> 00:16:16,480
oh i want product one now i want product

00:16:13,920 --> 00:16:18,639
seven and it'll switch to the right one

00:16:16,480 --> 00:16:19,600
and then we're issuing an http get

00:16:18,639 --> 00:16:21,519
request

00:16:19,600 --> 00:16:22,800
and since we're using a higher order

00:16:21,519 --> 00:16:25,360
mapping operator

00:16:22,800 --> 00:16:27,120
it will automatically subscribe to that

00:16:25,360 --> 00:16:29,279
inner observable for us and

00:16:27,120 --> 00:16:31,040
unsubscribe from it and flatten the

00:16:29,279 --> 00:16:32,880
result

00:16:31,040 --> 00:16:35,759
but what about the case of having

00:16:32,880 --> 00:16:36,160
multiple so here in this example you can

00:16:35,759 --> 00:16:38,240
see

00:16:36,160 --> 00:16:39,920
that i'm returning multiple suppliers

00:16:38,240 --> 00:16:43,519
for a particular product

00:16:39,920 --> 00:16:45,360
how do we do that well this is not the

00:16:43,519 --> 00:16:46,880
best implementation but i wanted to show

00:16:45,360 --> 00:16:48,639
this one first because it's a little bit

00:16:46,880 --> 00:16:51,759
easier to talk through

00:16:48,639 --> 00:16:53,839
so here i have my selected product i'm

00:16:51,759 --> 00:16:56,079
switch mapping again on the product

00:16:53,839 --> 00:16:58,800
but this time now i'm taking the array

00:16:56,079 --> 00:17:01,759
of ids that are stored with that product

00:16:58,800 --> 00:17:02,720
i'm using from to define that as an

00:17:01,759 --> 00:17:04,559
observable

00:17:02,720 --> 00:17:06,079
so i can pipe it through some more

00:17:04,559 --> 00:17:08,640
operators

00:17:06,079 --> 00:17:10,160
i'm using merge map here then to take

00:17:08,640 --> 00:17:13,360
each of those ids

00:17:10,160 --> 00:17:13,679
and retrieve the data why merge map and

00:17:13,360 --> 00:17:16,000
not

00:17:13,679 --> 00:17:18,480
switch map well let's talk through an

00:17:16,000 --> 00:17:20,319
example if i had three supplier ids

00:17:18,480 --> 00:17:22,720
let's say for simplicity one two and

00:17:20,319 --> 00:17:23,360
three if i used a switch map what it

00:17:22,720 --> 00:17:25,600
would do

00:17:23,360 --> 00:17:27,280
is go to get one and then see the second

00:17:25,600 --> 00:17:28,240
one and go oh no let's not get the one

00:17:27,280 --> 00:17:31,200
let's get two

00:17:28,240 --> 00:17:31,760
and then c3 and then say oh no not two

00:17:31,200 --> 00:17:34,480
three

00:17:31,760 --> 00:17:36,320
and you'd only end up with the last one

00:17:34,480 --> 00:17:38,480
if you used concat map

00:17:36,320 --> 00:17:40,080
it would get one wait for one to get

00:17:38,480 --> 00:17:42,640
back get two

00:17:40,080 --> 00:17:44,080
wait for two to get back get three wait

00:17:42,640 --> 00:17:46,400
for three to get back

00:17:44,080 --> 00:17:47,440
using merge map it says okay i need one

00:17:46,400 --> 00:17:50,000
two three

00:17:47,440 --> 00:17:51,120
and then it starts collecting them one

00:17:50,000 --> 00:17:53,600
two three

00:17:51,120 --> 00:17:55,039
now the last one last line here is two

00:17:53,600 --> 00:17:57,440
array

00:17:55,039 --> 00:17:59,280
without two array what this will do and

00:17:57,440 --> 00:18:01,039
if we hovered over product suppliers

00:17:59,280 --> 00:18:04,240
dollar we'd see what it would do

00:18:01,039 --> 00:18:06,320
which is return an observable of

00:18:04,240 --> 00:18:07,840
supplier singular it's going to give us

00:18:06,320 --> 00:18:09,840
one at a time

00:18:07,840 --> 00:18:11,679
but we don't want one at a time we want

00:18:09,840 --> 00:18:12,480
the set of them so that we can bind to

00:18:11,679 --> 00:18:14,320
that set

00:18:12,480 --> 00:18:16,240
so that's why we're using two arrays so

00:18:14,320 --> 00:18:17,520
that it stops and waits for them to get

00:18:16,240 --> 00:18:20,000
collected

00:18:17,520 --> 00:18:21,039
a better implementation of this is this

00:18:20,000 --> 00:18:22,480
here

00:18:21,039 --> 00:18:24,480
so again we're starting with the

00:18:22,480 --> 00:18:26,160
selected products again we're switch

00:18:24,480 --> 00:18:27,039
mapping as the user could change the

00:18:26,160 --> 00:18:29,520
product

00:18:27,039 --> 00:18:30,559
but now we're going to use fork join and

00:18:29,520 --> 00:18:33,039
what fork join

00:18:30,559 --> 00:18:35,440
will do is we're going to take each of

00:18:33,039 --> 00:18:36,640
the ids using the map so we're using the

00:18:35,440 --> 00:18:38,799
array map

00:18:36,640 --> 00:18:41,360
taking each of the supplier ids and

00:18:38,799 --> 00:18:43,520
issuing all those get requests

00:18:41,360 --> 00:18:45,760
and fork join will automatically

00:18:43,520 --> 00:18:48,559
subscribe to each one of them

00:18:45,760 --> 00:18:51,120
and wait for all of them to finish and

00:18:48,559 --> 00:18:52,640
then return the result as an array

00:18:51,120 --> 00:18:54,559
again if we hovered over product

00:18:52,640 --> 00:18:57,679
suppliers dollar we'd see that we were

00:18:54,559 --> 00:19:00,240
returning the right thing

00:18:57,679 --> 00:19:01,440
all right so on a picture when the user

00:19:00,240 --> 00:19:04,320
picks a product

00:19:01,440 --> 00:19:05,360
it's going to get the associated

00:19:04,320 --> 00:19:07,440
suppliers

00:19:05,360 --> 00:19:10,720
the fork join will wait till it gets all

00:19:07,440 --> 00:19:13,120
of them and then return the value

00:19:10,720 --> 00:19:14,480
all right so we looked at quite a few

00:19:13,120 --> 00:19:16,799
patterns here in this

00:19:14,480 --> 00:19:17,840
session i hope that they were useful for

00:19:16,799 --> 00:19:19,520
you

00:19:17,840 --> 00:19:24,960
and here are some links for more

00:19:19,520 --> 00:19:24,960

YouTube URL: https://www.youtube.com/watch?v=uv_sblwIJag


