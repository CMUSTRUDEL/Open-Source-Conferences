Title: A short trip into Reactive Forms Validation | Armela Gjoka | Lightning Talks 2021Â #ngconf
Publication date: 2021-05-31
Playlist: ng-conf 2021 Lightning Talks
Description: 
	Most applications require some user input and since we can not guarantee that the user enters valid input, we have to set in place some rules before sending  data to the backend. 

She has been working for some time with forms, both template-driven and reactive, and one of the challenges is to decide whether validation should be handled in the frontend or the backend. She believes that a mix of both is the right combination.

Frontend should handle these types of validations: 
Required or optional.
Format: minLength, maxLength, pattern match.
Other validations that are easily understandable to any UI user, such as: password and confirm password should have the same value.
On the other hand, any  validation that is specific to the business logic should be handled in the backend. 
She discussed  Reactive Forms since they are more scalable and a large form will probably have many rules. There are three main categories of validators that we can apply to a form control. 
Built-in Validators
Custom Validators
Async Validators
She applied these validators in a form control and showed how they are implemented and their behaviour.

Learn the best ways to build reliable web applications, write quality code, choose scalable architectures, and create effective automated tests at the Reliable Web Summit this August 26-27, 2021. Powered by the team at ng-conf.

Get your ticket ðŸ‘‰ https://reliablewebsummit.com/

ng-conf is a multi-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1000's of developers from across the globe join together to attend talks and workshops by the Angular team and other community experts.

Follow us on twitter https://twitter.com/ngconfâ€‹ 
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:04,820 --> 00:00:07,869
[Music]

00:00:08,639 --> 00:00:12,160
sure

00:00:09,360 --> 00:00:14,559
so my name is armela and i live here in

00:00:12,160 --> 00:00:15,440
tirana albania it's a small country in

00:00:14,559 --> 00:00:17,920
europe

00:00:15,440 --> 00:00:20,000
i've been working as a software engineer

00:00:17,920 --> 00:00:22,480
for more than seven years

00:00:20,000 --> 00:00:23,119
but the last four years have been only

00:00:22,480 --> 00:00:26,400
working with

00:00:23,119 --> 00:00:28,240
angular excellent sorry

00:00:26,400 --> 00:00:32,559
hey well your slides are beautiful

00:00:28,240 --> 00:00:36,640
they're showing yes i'm so proud

00:00:32,559 --> 00:00:38,800
so i've been working recently a lot

00:00:36,640 --> 00:00:41,040
with forms both reactive and template

00:00:38,800 --> 00:00:43,520
driven it's a large subject but we're

00:00:41,040 --> 00:00:47,680
going to cover a few topics today

00:00:43,520 --> 00:00:50,160
regarding form validation first of all

00:00:47,680 --> 00:00:52,640
why we need form validation because most

00:00:50,160 --> 00:00:54,719
applications require some user inputs

00:00:52,640 --> 00:00:56,160
and we cannot always guarantee that the

00:00:54,719 --> 00:00:58,160
input is valid

00:00:56,160 --> 00:01:00,320
for this reason we set in place some

00:00:58,160 --> 00:01:00,960
rules before sending data to the back

00:01:00,320 --> 00:01:03,199
end

00:01:00,960 --> 00:01:04,720
this will improve the user experience

00:01:03,199 --> 00:01:07,680
because errors will be shown

00:01:04,720 --> 00:01:09,439
instantly and then another advantage is

00:01:07,680 --> 00:01:11,040
that it will reduce the load on the

00:01:09,439 --> 00:01:13,840
server

00:01:11,040 --> 00:01:15,439
so when we talk about validation we can

00:01:13,840 --> 00:01:18,240
think of a scale there

00:01:15,439 --> 00:01:20,159
are some validations managing from that

00:01:18,240 --> 00:01:21,200
and some other validations managed in

00:01:20,159 --> 00:01:24,640
the back end

00:01:21,200 --> 00:01:26,560
and the combination is always optimal

00:01:24,640 --> 00:01:27,920
so let's have a look on a little bit

00:01:26,560 --> 00:01:30,479
more details

00:01:27,920 --> 00:01:31,119
on what type of validation handles the

00:01:30,479 --> 00:01:34,400
front end

00:01:31,119 --> 00:01:37,280
and the back end so uh from my

00:01:34,400 --> 00:01:40,400
experience front end will be managing

00:01:37,280 --> 00:01:41,920
required or optional fields format

00:01:40,400 --> 00:01:45,200
validations such as

00:01:41,920 --> 00:01:47,600
length or a pattern match and some other

00:01:45,200 --> 00:01:48,159
validations that make sense to the user

00:01:47,600 --> 00:01:50,240
such as

00:01:48,159 --> 00:01:51,840
password and confirmed password should

00:01:50,240 --> 00:01:54,000
have the same value

00:01:51,840 --> 00:01:57,040
on the other hand the back end will be

00:01:54,000 --> 00:01:59,040
managing the business logic validations

00:01:57,040 --> 00:02:01,840
and all the other validations that

00:01:59,040 --> 00:02:04,799
require some data to be

00:02:01,840 --> 00:02:05,439
determined if a value is valid or not

00:02:04,799 --> 00:02:07,840
such as

00:02:05,439 --> 00:02:09,200
is a name unique we need some data from

00:02:07,840 --> 00:02:11,840
the backend

00:02:09,200 --> 00:02:12,640
by managing validations this way we make

00:02:11,840 --> 00:02:15,920
sure that

00:02:12,640 --> 00:02:15,920
the scale is balanced

00:02:16,160 --> 00:02:21,680
so next we have a quick look on how

00:02:19,200 --> 00:02:23,120
validations work in template driven and

00:02:21,680 --> 00:02:24,959
reactive forms

00:02:23,120 --> 00:02:26,400
each of them manage validations

00:02:24,959 --> 00:02:28,640
differently

00:02:26,400 --> 00:02:30,560
template-driven since it's the template

00:02:28,640 --> 00:02:32,160
that carries the heavy weight

00:02:30,560 --> 00:02:34,080
is managing validations through

00:02:32,160 --> 00:02:36,319
directives in the template

00:02:34,080 --> 00:02:37,599
while in the reactive forms it's managed

00:02:36,319 --> 00:02:40,480
through functions

00:02:37,599 --> 00:02:42,480
each of them have their use cases when

00:02:40,480 --> 00:02:46,080
they are optimal

00:02:42,480 --> 00:02:48,879
but usually for medium to large complex

00:02:46,080 --> 00:02:51,440
forms we go for reactive forms

00:02:48,879 --> 00:02:53,040
and the reason is because first of all

00:02:51,440 --> 00:02:56,239
the writing functions it

00:02:53,040 --> 00:02:57,040
is easier than writing directives and if

00:02:56,239 --> 00:02:59,519
we manage

00:02:57,040 --> 00:03:01,680
a large and complex form only with

00:02:59,519 --> 00:03:04,000
directives in the template

00:03:01,680 --> 00:03:05,680
eventually it becomes hard to maintain

00:03:04,000 --> 00:03:08,879
so that's why we chose the

00:03:05,680 --> 00:03:08,879
reactive approach

00:03:09,040 --> 00:03:12,400
so if we were to categorize the

00:03:11,360 --> 00:03:15,360
validators

00:03:12,400 --> 00:03:17,280
we would go for three categories we have

00:03:15,360 --> 00:03:19,680
building validators that come

00:03:17,280 --> 00:03:21,440
out of the box and then we have

00:03:19,680 --> 00:03:24,239
synchronous validators

00:03:21,440 --> 00:03:24,720
which is basically a validator function

00:03:24,239 --> 00:03:27,680
and

00:03:24,720 --> 00:03:29,760
async validators which is amazing by a

00:03:27,680 --> 00:03:31,040
data function and the difference between

00:03:29,760 --> 00:03:33,120
the two last

00:03:31,040 --> 00:03:34,080
is that the first one will just bring

00:03:33,120 --> 00:03:36,239
the validation

00:03:34,080 --> 00:03:38,400
error and the second one is going to be

00:03:36,239 --> 00:03:40,480
either an observable or promise of

00:03:38,400 --> 00:03:43,760
validation errors

00:03:40,480 --> 00:03:45,760
and after we've discussed the validators

00:03:43,760 --> 00:03:48,879
let's consider

00:03:45,760 --> 00:03:50,239
case where we have a field username and

00:03:48,879 --> 00:03:53,280
for this field to be

00:03:50,239 --> 00:03:55,680
valid it should have a value a

00:03:53,280 --> 00:03:56,319
min length of 3 and it should only

00:03:55,680 --> 00:03:59,360
contain

00:03:56,319 --> 00:04:01,680
numbers and letters i've also added

00:03:59,360 --> 00:04:03,120
another validation condition that the

00:04:01,680 --> 00:04:05,599
first and the last letter

00:04:03,120 --> 00:04:06,560
should be the same and it also should be

00:04:05,599 --> 00:04:09,360
unique

00:04:06,560 --> 00:04:11,439
and as we discussed before the three

00:04:09,360 --> 00:04:12,640
main categories this is how we would

00:04:11,439 --> 00:04:15,360
organize

00:04:12,640 --> 00:04:16,479
this validations for the username form

00:04:15,360 --> 00:04:18,239
control

00:04:16,479 --> 00:04:19,840
we're going to take advantage of the

00:04:18,239 --> 00:04:22,240
built-in validator

00:04:19,840 --> 00:04:24,960
and for this case we will just need to

00:04:22,240 --> 00:04:28,080
write two custom functions

00:04:24,960 --> 00:04:28,720
for the first and the last letter to be

00:04:28,080 --> 00:04:32,240
the same

00:04:28,720 --> 00:04:35,600
and the value to be unique

00:04:32,240 --> 00:04:38,639
so here we have uh defines

00:04:35,600 --> 00:04:41,520
the synchronous and the sync validator

00:04:38,639 --> 00:04:43,440
so the synthetic synchronous validator

00:04:41,520 --> 00:04:44,720
is just considering the value of the

00:04:43,440 --> 00:04:47,199
form control

00:04:44,720 --> 00:04:49,280
and returning null if it's valid or a

00:04:47,199 --> 00:04:52,479
validation error

00:04:49,280 --> 00:04:53,120
on the other hand the async validator is

00:04:52,479 --> 00:04:55,840
using

00:04:53,120 --> 00:04:58,000
the user service for this example is

00:04:55,840 --> 00:05:00,800
sending the request to the back end

00:04:58,000 --> 00:05:03,199
and then after considering the response

00:05:00,800 --> 00:05:05,199
it will determine if this username is

00:05:03,199 --> 00:05:08,479
available or not

00:05:05,199 --> 00:05:10,400
and after we have declared implemented

00:05:08,479 --> 00:05:12,240
these validator functions

00:05:10,400 --> 00:05:14,080
it's time to organize them inside the

00:05:12,240 --> 00:05:16,560
form control

00:05:14,080 --> 00:05:18,880
so let's suppose we have a form and the

00:05:16,560 --> 00:05:21,840
username is our form control

00:05:18,880 --> 00:05:23,440
so the first parameter will be the value

00:05:21,840 --> 00:05:26,400
now for this case

00:05:23,440 --> 00:05:27,440
and then we will have to erase where we

00:05:26,400 --> 00:05:30,800
will list

00:05:27,440 --> 00:05:31,680
all our validators in the first array we

00:05:30,800 --> 00:05:34,160
will list

00:05:31,680 --> 00:05:36,320
all the synchronous validators including

00:05:34,160 --> 00:05:38,720
the built-in validators

00:05:36,320 --> 00:05:41,199
and in the second secondary we go with

00:05:38,720 --> 00:05:43,280
the list of all the async validators

00:05:41,199 --> 00:05:44,960
and for this case we have only the

00:05:43,280 --> 00:05:47,919
unique validator

00:05:44,960 --> 00:05:49,919
so it's quite easy and manageable even

00:05:47,919 --> 00:05:51,759
if these forms grow larger

00:05:49,919 --> 00:05:54,639
and we have to manage more complex

00:05:51,759 --> 00:05:54,639
validations

00:05:54,880 --> 00:05:58,000
and with this i want to thank you for

00:05:57,039 --> 00:06:00,319
your attention

00:05:58,000 --> 00:06:01,039
if you have something you can just write

00:06:00,319 --> 00:06:03,919
me

00:06:01,039 --> 00:06:05,440
i have a blog and just drop me a message

00:06:03,919 --> 00:06:18,000
either on twitter

00:06:05,440 --> 00:06:18,000

YouTube URL: https://www.youtube.com/watch?v=4iRd47hKo7Y


