Title: Stronger Type-Checking in Templates with Ivy | Alex Rickabaugh | ng-conf: Hardwired
Publication date: 2020-07-21
Playlist: ng-conf 2020: Hardwired
Description: 
	Get your free ticket to EnterpriseNG conference Keynote: https://ng-conf.org

One of the new features in Angular Ivy is strictTemplates, a compiler flag that turns on much stronger validation and type-checking of component templates. Discover how to use this new flag with Angular Framework team member Alex Rickabaugh. Learn how the new type-checking works, how best to migrate a large project onto stricter type-checking, and take a peek under the hood at how this feature works.

Watch all the ng-conf: Hardwired presentations/videos at https://videos.ng-conf.org

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

ng-conf: Hardwired is brought to you by:
- https://thinkster.io/ The best Angular and JavaScript tutorials on the web
- https://herodevs.com/ Engineering and consulting by web development experts
- https://xlts.dev/  Extended support for AngularJS

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:00,190 --> 00:00:02,970
[Music]

00:00:01,010 --> 00:00:03,980
[Applause]

00:00:02,970 --> 00:00:05,920
[Music]

00:00:03,980 --> 00:00:16,640
[Applause]

00:00:05,920 --> 00:00:16,640
[Music]

00:00:17,039 --> 00:00:20,800
all right hello everyone hello ngconf

00:00:19,039 --> 00:00:22,800
uh welcome to stronger type checking and

00:00:20,800 --> 00:00:24,640
templates with ivy

00:00:22,800 --> 00:00:25,840
for those of you who don't know me um

00:00:24,640 --> 00:00:26,720
although you should because aaron just

00:00:25,840 --> 00:00:29,039
introduced me

00:00:26,720 --> 00:00:31,599
my name is alex rickebaum i'm one of the

00:00:29,039 --> 00:00:33,280
engineers on the angular framework team

00:00:31,599 --> 00:00:34,960
i've been on the angular project for

00:00:33,280 --> 00:00:38,000
over five years now

00:00:34,960 --> 00:00:39,440
i joined before kind of the 2.0 alpha

00:00:38,000 --> 00:00:41,040
releases

00:00:39,440 --> 00:00:42,719
and for the past couple years i've been

00:00:41,040 --> 00:00:44,320
working on the angular compiler

00:00:42,719 --> 00:00:46,000
and helping to get it ready for angular

00:00:44,320 --> 00:00:48,079
ivy

00:00:46,000 --> 00:00:50,160
and today i'm excited to tell you about

00:00:48,079 --> 00:00:52,160
my favorite new feature of the compiler

00:00:50,160 --> 00:00:53,440
that we've been working on and it's my

00:00:52,160 --> 00:00:55,520
favorite feature because

00:00:53,440 --> 00:00:56,640
we've been getting issues for literally

00:00:55,520 --> 00:00:58,800
years

00:00:56,640 --> 00:01:01,120
from users asking for stronger and

00:00:58,800 --> 00:01:02,719
stricter type checking in templates

00:01:01,120 --> 00:01:04,400
and we've always kind of had to explain

00:01:02,719 --> 00:01:04,720
that architecturally this just really

00:01:04,400 --> 00:01:06,640
was

00:01:04,720 --> 00:01:08,400
too hard to do with the way the previous

00:01:06,640 --> 00:01:10,400
compiler worked

00:01:08,400 --> 00:01:12,479
so it was a real joy as part of building

00:01:10,400 --> 00:01:13,439
the new compiler to develop a new type

00:01:12,479 --> 00:01:16,240
checking mode

00:01:13,439 --> 00:01:17,840
that we call strict templates so you

00:01:16,240 --> 00:01:19,759
probably already know that the angular

00:01:17,840 --> 00:01:21,280
compiler performs type checking of your

00:01:19,759 --> 00:01:23,040
application templates

00:01:21,280 --> 00:01:24,560
and maybe you're already using the full

00:01:23,040 --> 00:01:26,240
template type check flag

00:01:24,560 --> 00:01:27,840
which enables the strictest possible

00:01:26,240 --> 00:01:31,840
checking that we had in angular's

00:01:27,840 --> 00:01:33,920
version 8 and below

00:01:31,840 --> 00:01:35,840
so strict templates turns on an even

00:01:33,920 --> 00:01:37,520
stricter mode of checking with ivy

00:01:35,840 --> 00:01:40,240
and you can think of it as being similar

00:01:37,520 --> 00:01:42,000
to typescript's own strict flag

00:01:40,240 --> 00:01:43,439
if you're not using this flag i highly

00:01:42,000 --> 00:01:46,159
suggest that you do

00:01:43,439 --> 00:01:47,600
if you turn on strict true in typescript

00:01:46,159 --> 00:01:50,960
typescript will give you the strictest

00:01:47,600 --> 00:01:52,560
possible type checking that it can do

00:01:50,960 --> 00:01:54,399
and it definitely will help you catch

00:01:52,560 --> 00:01:56,960
more bugs at build time

00:01:54,399 --> 00:01:58,719
instead of runtime so strict templates

00:01:56,960 --> 00:02:01,280
is basically our strict true

00:01:58,719 --> 00:02:03,119
for templates when you turn it on the

00:02:01,280 --> 00:02:04,479
angular compiler will infer much more

00:02:03,119 --> 00:02:06,399
accurate type information

00:02:04,479 --> 00:02:08,319
inside your templates and that leads to

00:02:06,399 --> 00:02:10,959
more accurate error messages and more

00:02:08,319 --> 00:02:13,120
bugs caught at build time

00:02:10,959 --> 00:02:14,400
so yesterday you probably saw brian love

00:02:13,120 --> 00:02:16,480
brian loves talk

00:02:14,400 --> 00:02:17,440
on why type checking strictness is so

00:02:16,480 --> 00:02:18,879
important

00:02:17,440 --> 00:02:20,560
it's really effective to be able to

00:02:18,879 --> 00:02:21,280
catch errors early in the development

00:02:20,560 --> 00:02:23,440
process

00:02:21,280 --> 00:02:25,599
when it's easy to fix them as opposed to

00:02:23,440 --> 00:02:28,160
catching them in qa or even worse

00:02:25,599 --> 00:02:29,760
having ui glitches or runtime crashes in

00:02:28,160 --> 00:02:31,440
production

00:02:29,760 --> 00:02:33,519
but another thing that i've noticed in

00:02:31,440 --> 00:02:35,280
the applications that i write myself

00:02:33,519 --> 00:02:37,280
is that if i'm using the type checker to

00:02:35,280 --> 00:02:38,400
catch kind of the basic more obvious

00:02:37,280 --> 00:02:40,720
types of errors

00:02:38,400 --> 00:02:42,800
i tend to focus my test suite on

00:02:40,720 --> 00:02:43,200
catching actual logic bugs and kind of

00:02:42,800 --> 00:02:46,160
more

00:02:43,200 --> 00:02:47,519
subtle edge case things so not only does

00:02:46,160 --> 00:02:48,640
catching air's earlier improve

00:02:47,519 --> 00:02:50,400
reliability

00:02:48,640 --> 00:02:52,480
it also leads to a much more effective

00:02:50,400 --> 00:02:55,120
test suite that kind of catches a

00:02:52,480 --> 00:02:56,640
complementary set of problems

00:02:55,120 --> 00:02:58,400
and so i'm going to walk us through a

00:02:56,640 --> 00:03:00,319
number of examples showing what the new

00:02:58,400 --> 00:03:02,080
strict templates mode can do

00:03:00,319 --> 00:03:04,480
and to make things easier i base them

00:03:02,080 --> 00:03:06,400
all on this common user interface

00:03:04,480 --> 00:03:07,920
so a user is an object that has a name

00:03:06,400 --> 00:03:09,760
property that name has

00:03:07,920 --> 00:03:11,120
first name and last name fields both of

00:03:09,760 --> 00:03:12,720
which are strings

00:03:11,120 --> 00:03:14,560
and because they're using one interface

00:03:12,720 --> 00:03:14,959
throughout you can focus on the examples

00:03:14,560 --> 00:03:16,840
and not

00:03:14,959 --> 00:03:18,480
trying to figure out the different types

00:03:16,840 --> 00:03:19,920
involved

00:03:18,480 --> 00:03:22,800
another thing that i'm going to do is

00:03:19,920 --> 00:03:25,120
highlight all kinds of expressions

00:03:22,800 --> 00:03:26,879
within the examples that i show you and

00:03:25,120 --> 00:03:28,239
this will show what is or isn't checked

00:03:26,879 --> 00:03:30,560
by the compiler

00:03:28,239 --> 00:03:32,239
so anything highlighted in green is an

00:03:30,560 --> 00:03:33,760
expression for which we have what i

00:03:32,239 --> 00:03:35,040
would consider to be perfect type

00:03:33,760 --> 00:03:36,560
information

00:03:35,040 --> 00:03:38,879
we know the most about it and we can

00:03:36,560 --> 00:03:41,760
check it more or less completely

00:03:38,879 --> 00:03:42,560
anything highlighted in orange or amber

00:03:41,760 --> 00:03:44,640
means that

00:03:42,560 --> 00:03:46,080
while we are still checking it parts of

00:03:44,640 --> 00:03:48,400
that expression we have incomplete

00:03:46,080 --> 00:03:50,080
information about maybe our compiler is

00:03:48,400 --> 00:03:51,920
inferring in any somewhere

00:03:50,080 --> 00:03:53,360
and anys tend to be poisonous and kind

00:03:51,920 --> 00:03:54,159
of pollute the expressions that they're

00:03:53,360 --> 00:03:56,480
involved in

00:03:54,159 --> 00:03:58,319
and turn them into enemies themselves

00:03:56,480 --> 00:04:01,120
and of course anything in red

00:03:58,319 --> 00:04:02,239
is something we're not checking at all

00:04:01,120 --> 00:04:03,840
so first up

00:04:02,239 --> 00:04:05,280
uh let's talk about how the new type

00:04:03,840 --> 00:04:06,319
checking mode differs from the previous

00:04:05,280 --> 00:04:08,000
two

00:04:06,319 --> 00:04:10,000
then we'll talk about how to go about

00:04:08,000 --> 00:04:13,040
turning it on in your applications

00:04:10,000 --> 00:04:14,799
without kind of getting overwhelmed by a

00:04:13,040 --> 00:04:16,239
stream of template errors

00:04:14,799 --> 00:04:19,280
and finally we'll talk about how this

00:04:16,239 --> 00:04:19,280
feature works under the hood

00:04:19,519 --> 00:04:23,199
so to start off i think it's useful to

00:04:21,040 --> 00:04:25,440
talk about the two modes of type

00:04:23,199 --> 00:04:27,840
checking available in angular 8

00:04:25,440 --> 00:04:29,280
and how they're different so the first

00:04:27,840 --> 00:04:31,199
is the basic mode of checking

00:04:29,280 --> 00:04:32,960
that every application gets even if it

00:04:31,199 --> 00:04:34,400
doesn't set any flags

00:04:32,960 --> 00:04:36,720
and then there's the full template type

00:04:34,400 --> 00:04:38,160
check mode which enables stricter

00:04:36,720 --> 00:04:40,880
checking that's been the default for

00:04:38,160 --> 00:04:42,560
some time in the cli

00:04:40,880 --> 00:04:44,080
so here's a pretty basic template that's

00:04:42,560 --> 00:04:45,120
going to show us nicely the main

00:04:44,080 --> 00:04:46,800
difference

00:04:45,120 --> 00:04:49,280
we're going to display a user's first

00:04:46,800 --> 00:04:51,280
name user.name.first

00:04:49,280 --> 00:04:55,040
and if the ngf is true we'll also show

00:04:51,280 --> 00:04:58,080
their last name user.name.last

00:04:55,040 --> 00:05:00,080
and even in basic mode with no flag set

00:04:58,080 --> 00:05:01,759
angular version 8 will still check a few

00:05:00,080 --> 00:05:03,080
things about this template

00:05:01,759 --> 00:05:05,680
it's going to verify that

00:05:03,080 --> 00:05:07,520
user.name.first is a valid expression

00:05:05,680 --> 00:05:08,960
and that includes checking that user is

00:05:07,520 --> 00:05:09,600
actually a valid property of the

00:05:08,960 --> 00:05:12,240
component

00:05:09,600 --> 00:05:14,560
that we're writing it'll also check that

00:05:12,240 --> 00:05:16,639
show last name is a valid property

00:05:14,560 --> 00:05:18,720
and that ng if exists and is something

00:05:16,639 --> 00:05:21,199
that we can bind to

00:05:18,720 --> 00:05:22,400
but it's going to miss a few things it's

00:05:21,199 --> 00:05:24,560
not going to check

00:05:22,400 --> 00:05:26,240
that the type of show last name is

00:05:24,560 --> 00:05:27,440
actually assignable to the input of

00:05:26,240 --> 00:05:29,360
ng-if

00:05:27,440 --> 00:05:30,720
um thankfully it will be because ngf

00:05:29,360 --> 00:05:31,840
checks truthiness so it'll accept

00:05:30,720 --> 00:05:33,840
anything

00:05:31,840 --> 00:05:35,360
and it's going to ignore the contents of

00:05:33,840 --> 00:05:37,520
any embedded views

00:05:35,360 --> 00:05:39,840
that's any ng templates any structural

00:05:37,520 --> 00:05:41,199
directives like ngef or ng4

00:05:39,840 --> 00:05:43,479
anything inside of those won't be

00:05:41,199 --> 00:05:46,479
checked at all so it won't check the

00:05:43,479 --> 00:05:47,960
user.name.last expression

00:05:46,479 --> 00:05:49,919
and so if we accidentally write

00:05:47,960 --> 00:05:51,440
user.lastname instead

00:05:49,919 --> 00:05:53,600
the template typechecker is not going to

00:05:51,440 --> 00:05:55,120
catch this it's going to be a ui glitch

00:05:53,600 --> 00:05:57,919
at runtime right we'll probably show a

00:05:55,120 --> 00:05:57,919
blank last name

00:05:58,720 --> 00:06:03,280
in full template type check mode things

00:06:00,720 --> 00:06:05,039
get a little bit better

00:06:03,280 --> 00:06:07,120
angular is now going to correctly check

00:06:05,039 --> 00:06:08,160
the embedded views the contents inside

00:06:07,120 --> 00:06:09,560
the ng-if

00:06:08,160 --> 00:06:11,919
so it's going to validate that

00:06:09,560 --> 00:06:13,280
user.name.last is ok

00:06:11,919 --> 00:06:15,199
but it's still not going to check that

00:06:13,280 --> 00:06:16,639
show last name is actually assignable to

00:06:15,199 --> 00:06:18,639
ngif

00:06:16,639 --> 00:06:20,000
and that's because the full in full

00:06:18,639 --> 00:06:21,600
template type check

00:06:20,000 --> 00:06:23,759
actually means it checks the entire

00:06:21,600 --> 00:06:25,919
template both the top level template

00:06:23,759 --> 00:06:26,960
and any embedded views like ngifs or

00:06:25,919 --> 00:06:28,479
ng4s

00:06:26,960 --> 00:06:30,800
that's the main difference between these

00:06:28,479 --> 00:06:30,800
modes

00:06:31,039 --> 00:06:35,600
so now let's talk about iv instrict

00:06:32,800 --> 00:06:36,880
templates and run through a few examples

00:06:35,600 --> 00:06:38,000
i'm going to show you four of them where

00:06:36,880 --> 00:06:39,600
our type checking has improved

00:06:38,000 --> 00:06:41,680
significantly

00:06:39,600 --> 00:06:43,840
so first i want to talk about type

00:06:41,680 --> 00:06:45,919
checking of ng for loops

00:06:43,840 --> 00:06:47,680
also that check of binding assignability

00:06:45,919 --> 00:06:49,199
so making sure the inputs of directives

00:06:47,680 --> 00:06:50,479
or components are actually compatible

00:06:49,199 --> 00:06:51,599
with the expressions that you bind to

00:06:50,479 --> 00:06:53,360
them

00:06:51,599 --> 00:06:54,880
inference of the dollar event type for

00:06:53,360 --> 00:06:56,880
output bindings

00:06:54,880 --> 00:06:58,319
and last but not least some fixes to

00:06:56,880 --> 00:07:00,639
strange behavior around the type

00:06:58,319 --> 00:07:02,400
checking of safe navigation

00:07:00,639 --> 00:07:04,000
and since full template type check is

00:07:02,400 --> 00:07:05,199
actually the default in the cli

00:07:04,000 --> 00:07:07,199
that will be the basis for our

00:07:05,199 --> 00:07:08,800
comparison the best type checking

00:07:07,199 --> 00:07:11,759
angular could do in version 8

00:07:08,800 --> 00:07:13,599
versus the best we can do in ivy let's

00:07:11,759 --> 00:07:15,440
dive in

00:07:13,599 --> 00:07:17,440
so the first example i want to show you

00:07:15,440 --> 00:07:18,960
is an ng4 loop that iterates over an

00:07:17,440 --> 00:07:21,360
array of users

00:07:18,960 --> 00:07:23,199
the ability to check ng4 has been one of

00:07:21,360 --> 00:07:25,360
those most requested features and we can

00:07:23,199 --> 00:07:28,319
finally do it with id

00:07:25,360 --> 00:07:30,160
so what would happen in version 8 well

00:07:28,319 --> 00:07:31,919
even in full template type check mode

00:07:30,160 --> 00:07:33,759
the compiler couldn't understand very

00:07:31,919 --> 00:07:35,520
much about an ng4

00:07:33,759 --> 00:07:37,360
again it'll validate that the directive

00:07:35,520 --> 00:07:39,039
exists that we can bind to it

00:07:37,360 --> 00:07:40,639
and that the array we're passing in is a

00:07:39,039 --> 00:07:42,479
valid expression

00:07:40,639 --> 00:07:45,039
but it's not actually going to check for

00:07:42,479 --> 00:07:46,160
example that our user's expression is

00:07:45,039 --> 00:07:49,280
actually an iterable

00:07:46,160 --> 00:07:51,759
and therefore assignable to an ng4 and

00:07:49,280 --> 00:07:53,280
with inside the ng4 body

00:07:51,759 --> 00:07:55,599
the compiler actually has no way of

00:07:53,280 --> 00:07:58,080
knowing what type the loop variable is

00:07:55,599 --> 00:08:01,000
so it treats it as any and that means

00:07:58,080 --> 00:08:03,680
that our expressions user.name.first

00:08:01,000 --> 00:08:05,680
user.name.last are actually all kind of

00:08:03,680 --> 00:08:07,199
fall apart and turn into enemies

00:08:05,680 --> 00:08:10,720
and so if there were typos in there they

00:08:07,199 --> 00:08:12,319
would not be caught by the type checker

00:08:10,720 --> 00:08:15,199
here's kind of a similar form of that

00:08:12,319 --> 00:08:16,400
error the compiler is able to verify

00:08:15,199 --> 00:08:18,160
that getlastname

00:08:16,400 --> 00:08:20,319
as a function is something that exists

00:08:18,160 --> 00:08:21,919
on our component and that we can call it

00:08:20,319 --> 00:08:23,360
but because the loop variable is

00:08:21,919 --> 00:08:25,039
inferred as any

00:08:23,360 --> 00:08:26,639
the compiler can't provide any safety

00:08:25,039 --> 00:08:28,800
around using it as an argument for get

00:08:26,639 --> 00:08:30,400
last name

00:08:28,800 --> 00:08:32,159
so under strict templates this picture

00:08:30,400 --> 00:08:33,599
gets a lot greener

00:08:32,159 --> 00:08:35,440
thanks to our new template type

00:08:33,599 --> 00:08:37,200
inference the compiler will actually be

00:08:35,440 --> 00:08:38,000
able to tell what type the loop variable

00:08:37,200 --> 00:08:39,839
is

00:08:38,000 --> 00:08:41,680
so we can correctly type and check all

00:08:39,839 --> 00:08:43,360
of the expressions involving it

00:08:41,680 --> 00:08:46,399
this is the first time as i mentioned in

00:08:43,360 --> 00:08:46,399
angular that we can do this

00:08:47,040 --> 00:08:50,720
so one of the main differences between

00:08:48,959 --> 00:08:53,040
the previous type checking in ng

00:08:50,720 --> 00:08:55,120
and strict templates is the check for

00:08:53,040 --> 00:08:56,880
assignability of inputs

00:08:55,120 --> 00:08:59,200
so in this template we're invoking a

00:08:56,880 --> 00:09:00,720
component called user component

00:08:59,200 --> 00:09:02,399
and we're passing in an expression

00:09:00,720 --> 00:09:04,240
myuser

00:09:02,399 --> 00:09:06,720
so previously the type checker would

00:09:04,240 --> 00:09:09,440
verify that the expression was correct

00:09:06,720 --> 00:09:10,640
and that the input user exists but it

00:09:09,440 --> 00:09:11,360
wouldn't actually check that the

00:09:10,640 --> 00:09:14,480
expression

00:09:11,360 --> 00:09:15,440
was compatible with the input and so if

00:09:14,480 --> 00:09:17,600
you did something like

00:09:15,440 --> 00:09:19,760
pass in a string instead of the

00:09:17,600 --> 00:09:21,040
interface type that it expects

00:09:19,760 --> 00:09:22,720
this would not be caught by the type

00:09:21,040 --> 00:09:24,959
checker and this would probably crash at

00:09:22,720 --> 00:09:26,720
runtime

00:09:24,959 --> 00:09:28,080
so one case where this can lead to some

00:09:26,720 --> 00:09:30,640
really subtle bugs

00:09:28,080 --> 00:09:32,720
or crashes is when you use the async

00:09:30,640 --> 00:09:34,839
pipe to wait on an observable

00:09:32,720 --> 00:09:37,680
for example if you're fetching data from

00:09:34,839 --> 00:09:39,120
hdp and until that observable actually

00:09:37,680 --> 00:09:41,040
emits data

00:09:39,120 --> 00:09:43,279
an expression involving the async pipe

00:09:41,040 --> 00:09:45,040
will actually become null

00:09:43,279 --> 00:09:47,200
and that means that if you bind an input

00:09:45,040 --> 00:09:48,320
to it that input is actually going to

00:09:47,200 --> 00:09:51,440
get set to null

00:09:48,320 --> 00:09:52,959
until the observable emits some data but

00:09:51,440 --> 00:09:54,080
because that wasn't being type checked

00:09:52,959 --> 00:09:56,880
this could lead to

00:09:54,080 --> 00:10:00,240
ui crashes or glitches if the input

00:09:56,880 --> 00:10:01,760
wasn't actually expecting a null value

00:10:00,240 --> 00:10:03,680
so with strict templates we can actually

00:10:01,760 --> 00:10:05,519
tell you about this at build time

00:10:03,680 --> 00:10:08,320
the compiler knows the async pipe is

00:10:05,519 --> 00:10:09,839
going to produce either a user or null

00:10:08,320 --> 00:10:11,440
and it can check that both of those

00:10:09,839 --> 00:10:13,600
values would be compatible

00:10:11,440 --> 00:10:15,120
with the user input of our component and

00:10:13,600 --> 00:10:18,959
if they're not it can let you know with

00:10:15,120 --> 00:10:21,040
an error message similar thing happens

00:10:18,959 --> 00:10:22,399
for output bindings in the dollar event

00:10:21,040 --> 00:10:23,920
value

00:10:22,399 --> 00:10:25,440
dollar event has previously been

00:10:23,920 --> 00:10:27,200
inferred as any

00:10:25,440 --> 00:10:29,120
the compiler will verify that the event

00:10:27,200 --> 00:10:30,880
that we're binding to exists

00:10:29,120 --> 00:10:32,399
but it won't be able to tell if what

00:10:30,880 --> 00:10:33,120
we're doing with dollar event actually

00:10:32,399 --> 00:10:35,440
makes sense

00:10:33,120 --> 00:10:37,279
given the output type of the event

00:10:35,440 --> 00:10:38,800
binding

00:10:37,279 --> 00:10:40,640
so with strict templates we can figure

00:10:38,800 --> 00:10:42,399
this out the compiler will correctly

00:10:40,640 --> 00:10:44,079
infer the type of dollar event

00:10:42,399 --> 00:10:47,839
and can check every part of the binding

00:10:44,079 --> 00:10:49,760
as a result

00:10:47,839 --> 00:10:52,720
and the last example i want to show you

00:10:49,760 --> 00:10:52,720
is safe navigation

00:10:52,959 --> 00:10:57,279
so in this case let's assume we have a

00:10:54,800 --> 00:10:59,120
component here that has a user input

00:10:57,279 --> 00:11:00,720
that may or may not be set so it might

00:10:59,120 --> 00:11:02,000
be undefined

00:11:00,720 --> 00:11:04,079
and we'll declare a function in that

00:11:02,000 --> 00:11:05,440
component called format name

00:11:04,079 --> 00:11:07,360
and format name is going to take the

00:11:05,440 --> 00:11:08,480
name in as a string and presumably

00:11:07,360 --> 00:11:10,320
format it for display

00:11:08,480 --> 00:11:12,480
i'm just calling string.trim as an

00:11:10,320 --> 00:11:15,360
example

00:11:12,480 --> 00:11:15,839
so naively we may attempt to print out

00:11:15,360 --> 00:11:18,399
the name

00:11:15,839 --> 00:11:19,040
in our template using format name

00:11:18,399 --> 00:11:21,200
however

00:11:19,040 --> 00:11:23,040
even in version 8 the compiler will

00:11:21,200 --> 00:11:24,800
correctly complain about this

00:11:23,040 --> 00:11:26,399
it says the user property can be

00:11:24,800 --> 00:11:29,360
undefined and therefore you can't just

00:11:26,399 --> 00:11:31,040
access the name property of it

00:11:29,360 --> 00:11:32,640
and that's correct right but we can work

00:11:31,040 --> 00:11:35,440
around that angular has

00:11:32,640 --> 00:11:36,880
safe property navigation let's use it

00:11:35,440 --> 00:11:39,920
that will allow us to do

00:11:36,880 --> 00:11:42,640
user question dot name and not crash if

00:11:39,920 --> 00:11:44,160
user is undefined

00:11:42,640 --> 00:11:45,680
unfortunately there's still problems

00:11:44,160 --> 00:11:47,920
with this because

00:11:45,680 --> 00:11:49,920
even though it won't crash if user is

00:11:47,920 --> 00:11:50,560
undefined the result of the overall

00:11:49,920 --> 00:11:52,800
expression

00:11:50,560 --> 00:11:54,160
if user is undefined is actually

00:11:52,800 --> 00:11:56,959
undefined still

00:11:54,160 --> 00:11:59,040
it still has a value right and that's

00:11:56,959 --> 00:12:00,720
not valid to call format name with

00:11:59,040 --> 00:12:02,240
but the type checker here hasn't helped

00:12:00,720 --> 00:12:04,560
us it doesn't know this

00:12:02,240 --> 00:12:06,560
because it turns out some safe

00:12:04,560 --> 00:12:08,800
navigation operations in angular

00:12:06,560 --> 00:12:10,480
were inferred as any this is actually a

00:12:08,800 --> 00:12:11,360
bug in the old compiler it wasn't trying

00:12:10,480 --> 00:12:12,880
to do that

00:12:11,360 --> 00:12:14,800
but it worked out in certain cases that

00:12:12,880 --> 00:12:16,480
this happened

00:12:14,800 --> 00:12:18,560
so under strict templates as you might

00:12:16,480 --> 00:12:19,360
guess we fix this we actually catch this

00:12:18,560 --> 00:12:21,279
error

00:12:19,360 --> 00:12:23,279
now the compiler knows the overall

00:12:21,279 --> 00:12:25,200
expression is capable of being null

00:12:23,279 --> 00:12:28,079
and can tell us that's not legal to call

00:12:25,200 --> 00:12:28,079
format name with

00:12:29,120 --> 00:12:32,079
so the takeaway from all of these

00:12:30,399 --> 00:12:32,800
examples is that strict templates gives

00:12:32,079 --> 00:12:34,320
you

00:12:32,800 --> 00:12:36,560
much better type inference within your

00:12:34,320 --> 00:12:38,959
templates and that translates to fewer

00:12:36,560 --> 00:12:40,480
runtime crashes or ui glitches

00:12:38,959 --> 00:12:42,320
when the assumptions that you're making

00:12:40,480 --> 00:12:44,079
about the data you're working with

00:12:42,320 --> 00:12:46,720
aren't quite correct or don't line up

00:12:44,079 --> 00:12:49,360
with what the type system says

00:12:46,720 --> 00:12:50,720
how do you get there from here though if

00:12:49,360 --> 00:12:51,920
you have an application i think someone

00:12:50,720 --> 00:12:53,040
asked this question on the stream

00:12:51,920 --> 00:12:54,399
yesterday

00:12:53,040 --> 00:12:56,800
if you have an application that has like

00:12:54,399 --> 00:12:58,959
hundreds of components it's not trivial

00:12:56,800 --> 00:13:00,480
just to turn on a new type checking flag

00:12:58,959 --> 00:13:02,560
and subject all of your templates to

00:13:00,480 --> 00:13:03,680
much more rigorous validation

00:13:02,560 --> 00:13:05,200
there's probably going to be some

00:13:03,680 --> 00:13:06,639
failures and it's annoying to have to

00:13:05,200 --> 00:13:08,240
fix all of them before you can turn the

00:13:06,639 --> 00:13:10,320
flag on

00:13:08,240 --> 00:13:12,959
unfortunately we've designed strict

00:13:10,320 --> 00:13:15,440
templates for incremental adoption

00:13:12,959 --> 00:13:17,360
so you can do that in four steps and

00:13:15,440 --> 00:13:18,240
step one is the easiest you turn on the

00:13:17,360 --> 00:13:20,160
flag

00:13:18,240 --> 00:13:22,240
and drink from the fire hose of failures

00:13:20,160 --> 00:13:24,240
right then you look at each of the

00:13:22,240 --> 00:13:25,120
failures and try to figure out why is it

00:13:24,240 --> 00:13:27,040
failing

00:13:25,120 --> 00:13:28,800
is it failing because we're now checking

00:13:27,040 --> 00:13:30,079
that an expression is assignable to an

00:13:28,800 --> 00:13:31,680
input and it's not

00:13:30,079 --> 00:13:34,000
is it failing because you're relying on

00:13:31,680 --> 00:13:35,440
safe navigation inferring in any

00:13:34,000 --> 00:13:37,360
and once you have that list of root

00:13:35,440 --> 00:13:39,920
causes which is much shorter

00:13:37,360 --> 00:13:41,839
hopefully than the list of errors you

00:13:39,920 --> 00:13:44,880
can selectively disable

00:13:41,839 --> 00:13:46,160
specific checks to hide them until you

00:13:44,880 --> 00:13:47,600
get them all fixed

00:13:46,160 --> 00:13:49,760
and that means that you can turn on this

00:13:47,600 --> 00:13:50,399
feature incrementally one check at a

00:13:49,760 --> 00:13:51,600
time

00:13:50,399 --> 00:13:53,199
by disabling everything that's

00:13:51,600 --> 00:13:56,079
problematic until you've had time to go

00:13:53,199 --> 00:13:57,680
through and clean up your code

00:13:56,079 --> 00:13:59,360
so there are a few reasons that you

00:13:57,680 --> 00:14:00,959
might have to do this uh the most

00:13:59,360 --> 00:14:02,959
obvious one is if they're actual you

00:14:00,959 --> 00:14:04,720
know type bugs in your templates

00:14:02,959 --> 00:14:06,160
but another thing that often comes up is

00:14:04,720 --> 00:14:07,440
if you're using libraries

00:14:06,160 --> 00:14:09,360
that weren't actually designed to be

00:14:07,440 --> 00:14:12,079
strict templates compatible

00:14:09,360 --> 00:14:13,279
um one case is if they weren't compiled

00:14:12,079 --> 00:14:15,040
with typescript specific

00:14:13,279 --> 00:14:17,680
you know strictest settings they might

00:14:15,040 --> 00:14:18,959
not specify null or undefined as valid

00:14:17,680 --> 00:14:20,240
values for an input

00:14:18,959 --> 00:14:23,279
even if they're perfectly happy to

00:14:20,240 --> 00:14:23,279
accept that at runtime

00:14:24,320 --> 00:14:28,320
so if the check that expressions are

00:14:26,399 --> 00:14:29,440
actually assignable to the inputs

00:14:28,320 --> 00:14:31,440
that you're binding them to is

00:14:29,440 --> 00:14:33,199
problematic you can turn that off by

00:14:31,440 --> 00:14:34,480
setting the strict input types flag to

00:14:33,199 --> 00:14:36,320
false

00:14:34,480 --> 00:14:38,240
as again as i said you might do this if

00:14:36,320 --> 00:14:39,519
libraries that you're using are don't

00:14:38,240 --> 00:14:40,240
have quite correct types for their

00:14:39,519 --> 00:14:41,600
inputs

00:14:40,240 --> 00:14:44,160
or if you've been kind of loose about

00:14:41,600 --> 00:14:46,240
that in your own components

00:14:44,160 --> 00:14:47,920
a special case of that is handling

00:14:46,240 --> 00:14:49,279
expressions which are potentially null

00:14:47,920 --> 00:14:50,959
or undefined

00:14:49,279 --> 00:14:52,639
and that's because if a library is not

00:14:50,959 --> 00:14:53,440
compiled with typescript strict null

00:14:52,639 --> 00:14:56,000
checks

00:14:53,440 --> 00:14:56,639
the dts files that it produces actually

00:14:56,000 --> 00:14:59,199
don't include

00:14:56,639 --> 00:15:01,279
null or undefined as possible values and

00:14:59,199 --> 00:15:02,000
so by turning off strict null input

00:15:01,279 --> 00:15:04,399
types

00:15:02,000 --> 00:15:06,720
you can bypass that particular issue and

00:15:04,399 --> 00:15:10,639
still have the input assignability check

00:15:06,720 --> 00:15:12,160
working overall another problem

00:15:10,639 --> 00:15:14,000
tends to come up with attribute style

00:15:12,160 --> 00:15:15,920
bindings as opposed to the square

00:15:14,000 --> 00:15:18,720
bracket property bindings

00:15:15,920 --> 00:15:19,600
attribute bindings are always strings

00:15:18,720 --> 00:15:21,279
and that can cause

00:15:19,600 --> 00:15:22,880
issues if you're trying to bind them to

00:15:21,279 --> 00:15:24,959
inputs that might be expecting for

00:15:22,880 --> 00:15:27,279
example a boolean value like a disabled

00:15:24,959 --> 00:15:29,279
input and you can set strict attribute

00:15:27,279 --> 00:15:31,040
types to false to work around that

00:15:29,279 --> 00:15:33,839
until you have time to kind of you know

00:15:31,040 --> 00:15:35,440
implement the changes in templates

00:15:33,839 --> 00:15:37,120
if you happen to be relying on the

00:15:35,440 --> 00:15:39,519
previous inference of any types

00:15:37,120 --> 00:15:41,440
for safe property navigation you can

00:15:39,519 --> 00:15:44,240
restore that behavior by setting strict

00:15:41,440 --> 00:15:45,920
safe navigation types

00:15:44,240 --> 00:15:47,759
and the same goes for inference of the

00:15:45,920 --> 00:15:50,800
dollar event type for outputs

00:15:47,759 --> 00:15:53,120
and strict output event types

00:15:50,800 --> 00:15:55,279
in the case of dom events we have

00:15:53,120 --> 00:15:56,800
another flag strict dom event types that

00:15:55,279 --> 00:15:58,240
affects the inference of dollar event

00:15:56,800 --> 00:15:59,839
for those

00:15:58,240 --> 00:16:01,600
one case we've seen where people need to

00:15:59,839 --> 00:16:04,399
turn this off is if they're making

00:16:01,600 --> 00:16:06,240
extensive use of dollarevent.target

00:16:04,399 --> 00:16:07,600
you might assume as i did when i first

00:16:06,240 --> 00:16:09,839
saw this example

00:16:07,600 --> 00:16:11,240
that's if we're subscribing to a change

00:16:09,839 --> 00:16:13,759
event of an input

00:16:11,240 --> 00:16:14,720
dollarevent.target will be an html input

00:16:13,759 --> 00:16:17,160
element

00:16:14,720 --> 00:16:19,279
but dom events can bubble and so

00:16:17,160 --> 00:16:20,480
dollarevent.target might not actually be

00:16:19,279 --> 00:16:22,880
the element

00:16:20,480 --> 00:16:24,160
that you subscribe to uh it's in the

00:16:22,880 --> 00:16:25,839
type system is actually much more

00:16:24,160 --> 00:16:28,000
generic and that can break patterns like

00:16:25,839 --> 00:16:28,000
this

00:16:28,160 --> 00:16:31,839
there are a few other flags that i

00:16:29,839 --> 00:16:33,519
haven't specifically mentioned

00:16:31,839 --> 00:16:35,920
um they tend to come up a little more

00:16:33,519 --> 00:16:38,079
rarely in application code

00:16:35,920 --> 00:16:39,600
you can read the full list along with

00:16:38,079 --> 00:16:40,880
some descriptions of you know why you

00:16:39,600 --> 00:16:42,399
might want to turn them off

00:16:40,880 --> 00:16:45,040
on the template type checking guide on

00:16:42,399 --> 00:16:45,040
angular i o

00:16:45,440 --> 00:16:49,120
so now that we've talked about strict

00:16:47,040 --> 00:16:50,800
templates and how to use it

00:16:49,120 --> 00:16:52,399
i want to give you a small peek into how

00:16:50,800 --> 00:16:53,600
it works internally how this feature was

00:16:52,399 --> 00:16:55,040
built

00:16:53,600 --> 00:16:58,240
more because i feel like it's really

00:16:55,040 --> 00:17:00,800
cool so let's go back to the ng4 example

00:16:58,240 --> 00:17:00,800
from earlier

00:17:01,759 --> 00:17:04,880
i'm only going to talk about it

00:17:03,120 --> 00:17:06,240
superficially and not go

00:17:04,880 --> 00:17:07,760
into great detail about the type

00:17:06,240 --> 00:17:09,520
operations that are happening i'm

00:17:07,760 --> 00:17:10,959
working on a blog post that's going to

00:17:09,520 --> 00:17:12,720
have a lot more kind of a technical

00:17:10,959 --> 00:17:14,959
approach to it

00:17:12,720 --> 00:17:16,720
so here's our example template we're

00:17:14,959 --> 00:17:18,000
iterating over a list of users and we're

00:17:16,720 --> 00:17:21,120
printing out the first name

00:17:18,000 --> 00:17:21,679
of each one and right away we run into a

00:17:21,120 --> 00:17:23,919
problem

00:17:21,679 --> 00:17:25,439
because typescript doesn't actually

00:17:23,919 --> 00:17:27,919
understand html

00:17:25,439 --> 00:17:29,440
or angular templates so if we wanted to

00:17:27,919 --> 00:17:31,200
check these expressions

00:17:29,440 --> 00:17:32,720
we actually have to convert them into

00:17:31,200 --> 00:17:34,640
typescript code

00:17:32,720 --> 00:17:35,760
this is code that you as a user will

00:17:34,640 --> 00:17:37,360
never see

00:17:35,760 --> 00:17:39,200
this is code that does not get

00:17:37,360 --> 00:17:40,400
translated into javascript it does not

00:17:39,200 --> 00:17:43,440
run in the browser

00:17:40,400 --> 00:17:45,520
it does not run anywhere actually we

00:17:43,440 --> 00:17:47,200
feed it to typescript and allow

00:17:45,520 --> 00:17:49,200
typescript to check it for us and give

00:17:47,200 --> 00:17:50,880
us back any error messages

00:17:49,200 --> 00:17:52,640
then we take those errors and show them

00:17:50,880 --> 00:17:54,720
to you in the context of your original

00:17:52,640 --> 00:17:57,919
template

00:17:54,720 --> 00:17:59,520
so that simple ng4 produces this

00:17:57,919 --> 00:18:01,200
complicated looking piece of typescript

00:17:59,520 --> 00:18:03,360
code

00:18:01,200 --> 00:18:05,120
and it is complicated in places but what

00:18:03,360 --> 00:18:07,280
it's doing overall

00:18:05,120 --> 00:18:10,240
is fairly straightforward to understand

00:18:07,280 --> 00:18:11,840
so let me walk you through it

00:18:10,240 --> 00:18:13,600
the first thing it's doing is declaring

00:18:11,840 --> 00:18:16,160
a function called a type constructor

00:18:13,600 --> 00:18:18,559
for the ng4 directive and that's because

00:18:16,160 --> 00:18:20,320
the ng4 directive is generic

00:18:18,559 --> 00:18:22,240
its type actually depends on the types

00:18:20,320 --> 00:18:23,679
of the inputs that you pass in

00:18:22,240 --> 00:18:26,160
and so what this type constructor

00:18:23,679 --> 00:18:28,240
function does is given a particular set

00:18:26,160 --> 00:18:29,919
of input bindings for ng4

00:18:28,240 --> 00:18:32,320
figure out what type the directive is

00:18:29,919 --> 00:18:32,320
going to be

00:18:32,640 --> 00:18:35,679
the next thing this code is going to do

00:18:34,080 --> 00:18:36,799
is declare a function called a type

00:18:35,679 --> 00:18:38,799
check block

00:18:36,799 --> 00:18:40,480
and this represents the entire template

00:18:38,799 --> 00:18:42,320
in typescript code

00:18:40,480 --> 00:18:44,320
so it has one argument which is a

00:18:42,320 --> 00:18:46,000
context variable that represents the

00:18:44,320 --> 00:18:47,840
application type

00:18:46,000 --> 00:18:50,880
and the first thing this block does is

00:18:47,840 --> 00:18:53,360
call the type constructor for ng4

00:18:50,880 --> 00:18:55,120
you can see it's passing in the binding

00:18:53,360 --> 00:18:57,039
expression that we wrote for ng4 which

00:18:55,120 --> 00:18:58,400
is context.users

00:18:57,039 --> 00:19:01,039
typescript will let us know if that's

00:18:58,400 --> 00:19:02,080
not valid here and then we get back this

00:19:01,039 --> 00:19:04,080
value t1

00:19:02,080 --> 00:19:06,000
which actually has the correct type for

00:19:04,080 --> 00:19:06,799
the ng4 directive in this particular

00:19:06,000 --> 00:19:10,720
instance

00:19:06,799 --> 00:19:14,320
it'll be an ng4 of user objects

00:19:10,720 --> 00:19:16,000
next we ask the ng4 structural directive

00:19:14,320 --> 00:19:18,000
what type it's going to use for its

00:19:16,000 --> 00:19:20,320
template context at runtime

00:19:18,000 --> 00:19:22,000
ng4 is free to create embedded views of

00:19:20,320 --> 00:19:23,840
any type that it wants

00:19:22,000 --> 00:19:25,200
so we have to ask it hey what are you

00:19:23,840 --> 00:19:27,600
planning on doing

00:19:25,200 --> 00:19:29,200
and it will tell us this t2 variable

00:19:27,600 --> 00:19:29,520
should actually be narrowed to a type

00:19:29,200 --> 00:19:32,080
called

00:19:29,520 --> 00:19:34,240
ng4 context that's generic over user

00:19:32,080 --> 00:19:36,640
objects

00:19:34,240 --> 00:19:38,559
and inside this if block we can now

00:19:36,640 --> 00:19:40,320
extract dollar implicit

00:19:38,559 --> 00:19:41,840
which is the internal name in angular

00:19:40,320 --> 00:19:43,919
for the let user

00:19:41,840 --> 00:19:45,919
variable it's actually short for let

00:19:43,919 --> 00:19:47,280
user equals dollar implicit

00:19:45,919 --> 00:19:49,360
and that's going to be the actual loop

00:19:47,280 --> 00:19:52,400
variable of type user

00:19:49,360 --> 00:19:54,400
and that's called t3 here then all that

00:19:52,400 --> 00:19:57,120
we have to do is reflect the actual

00:19:54,400 --> 00:19:58,640
expression t3.name.first

00:19:57,120 --> 00:20:01,200
and let typescript tell us if there are

00:19:58,640 --> 00:20:03,919
any problems with that

00:20:01,200 --> 00:20:05,440
also you might notice in the in the

00:20:03,919 --> 00:20:07,200
example here there are comments

00:20:05,440 --> 00:20:08,799
with pairs of numbers kind of littered

00:20:07,200 --> 00:20:11,200
throughout the expression

00:20:08,799 --> 00:20:12,880
these are our source maps so if we get

00:20:11,200 --> 00:20:14,480
an error back from typescript we can

00:20:12,880 --> 00:20:14,799
look at where typescript says the error

00:20:14,480 --> 00:20:16,960
is

00:20:14,799 --> 00:20:18,080
inside this code find the nearest

00:20:16,960 --> 00:20:19,760
comment

00:20:18,080 --> 00:20:21,360
and then use that to map the error back

00:20:19,760 --> 00:20:22,400
to the original template so that when we

00:20:21,360 --> 00:20:24,080
show it to you

00:20:22,400 --> 00:20:25,679
we can show it to you in the context of

00:20:24,080 --> 00:20:27,120
the binding expression that you wrote

00:20:25,679 --> 00:20:29,360
and not the code that we generated to

00:20:27,120 --> 00:20:31,440
check it

00:20:29,360 --> 00:20:33,360
so in summary you should use strict

00:20:31,440 --> 00:20:34,480
templates you should turn on strict mode

00:20:33,360 --> 00:20:36,799
and typescript as well

00:20:34,480 --> 00:20:38,559
if at all possible and don't be afraid

00:20:36,799 --> 00:20:39,440
to disable specific checks while you're

00:20:38,559 --> 00:20:41,280
migrating

00:20:39,440 --> 00:20:43,520
it's much better to be partially strict

00:20:41,280 --> 00:20:44,400
for a while as you fix up errors in your

00:20:43,520 --> 00:20:47,039
templates

00:20:44,400 --> 00:20:47,679
than it is to never engage the flag

00:20:47,039 --> 00:20:50,000
because

00:20:47,679 --> 00:20:52,240
you just don't have time to go and fix

00:20:50,000 --> 00:20:54,559
all the errors in one sitting

00:20:52,240 --> 00:20:55,760
ivy has a verified very powerful

00:20:54,559 --> 00:20:57,760
template type inference

00:20:55,760 --> 00:20:59,679
and type checking engine and we have a

00:20:57,760 --> 00:21:00,960
lot more ideas about new checks and new

00:20:59,679 --> 00:21:02,559
things we can add

00:21:00,960 --> 00:21:04,400
for example i don't think host bindings

00:21:02,559 --> 00:21:06,240
are checked at the moment

00:21:04,400 --> 00:21:08,400
and with our strictness flag model we

00:21:06,240 --> 00:21:09,919
can actually turn these on incrementally

00:21:08,400 --> 00:21:12,000
over time and roll them out to you

00:21:09,919 --> 00:21:13,520
without major inconvenience if you've

00:21:12,000 --> 00:21:15,600
already enabled the flag

00:21:13,520 --> 00:21:17,200
because if a new check is too breaky we

00:21:15,600 --> 00:21:18,559
can actually release it as an opt-in

00:21:17,200 --> 00:21:20,240
mode

00:21:18,559 --> 00:21:30,250
so that's all i have for you today thank

00:21:20,240 --> 00:21:30,430
you very much

00:21:30,250 --> 00:21:32,470
[Music]

00:21:30,430 --> 00:21:35,840
[Applause]

00:21:32,470 --> 00:21:37,919
[Music]

00:21:35,840 --> 00:21:37,919

YouTube URL: https://www.youtube.com/watch?v=7yge1cHFExI


