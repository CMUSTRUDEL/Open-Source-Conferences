Title: Into the Unknown | Craig Spence | ng-conf: Hardwired #ngconfHardwired #ngconf2020
Publication date: 2020-10-06
Playlist: ng-conf 2020: Hardwired
Description: 
	Get your free ticket to EnterpriseNG conference Keynote: https://ng-conf.org

Sven the reindeer and Olaf the snowman have a big problem! They’re creating a new TypeScript library, and they want to give developers who use their library the best possible experience. They know that TypeScript has incredible powers (they’re almost magical! 💫), but they don’t know exactly how to use them to their full potential.

They have so many questions! What is unknown? How is it different from any? How do you use infer? What are conditional types? Unions and Intersections?! It’s almost too much…

Thankfully Elsa, beloved Queen of Arendelle is a TypeScript master, and along with her sister Anna, they love to teach others all about type magic.

Come along with Elsa, Anna, Olaf and Sven, and learn all about advanced TypeScript typing by going INTO THE UNKNOWN 🎶❄️🎵

Watch all the ng-conf: Hardwired presentations/videos at https://videos.ng-conf.org

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

ng-conf: Hardwired is brought to you by:
- https://thinkster.io/ The best Angular and JavaScript tutorials on the web
- https://herodevs.com/ Engineering and consulting by web development experts
- https://xlts.dev/  Extended support for AngularJS

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:00,180 --> 00:00:02,970
[Music]

00:00:02,400 --> 00:00:23,119
[Applause]

00:00:02,970 --> 00:00:23,920
[Music]

00:00:23,119 --> 00:00:26,000
hey everyone

00:00:23,920 --> 00:00:27,599
so i'm craig i'm currently in new

00:00:26,000 --> 00:00:28,240
zealand but i'm usually based in

00:00:27,599 --> 00:00:31,279
stockholm

00:00:28,240 --> 00:00:32,719
i'm in here at spotify um you can find

00:00:31,279 --> 00:00:35,360
me on the internet you find all my stuff

00:00:32,719 --> 00:00:35,360
everywhere you want

00:00:35,760 --> 00:00:40,000
but today i'm going to tell you all a

00:00:38,320 --> 00:00:42,559
story

00:00:40,000 --> 00:00:44,879
and it goes a little bit like this

00:00:42,559 --> 00:00:48,559
chapter one

00:00:44,879 --> 00:00:48,559
a very helpful reindeer

00:00:49,039 --> 00:00:53,680
it was nearing the end of winter in the

00:00:50,960 --> 00:00:56,840
kingdom of arendelle

00:00:53,680 --> 00:00:58,239
sven the reindeer was feeling very very

00:00:56,840 --> 00:00:59,680
productive

00:00:58,239 --> 00:01:03,199
he had been helping his best friend

00:00:59,680 --> 00:01:04,640
christoph the royal ice master

00:01:03,199 --> 00:01:06,720
christoph and sven had been friends

00:01:04,640 --> 00:01:08,479
since they were very little

00:01:06,720 --> 00:01:12,400
and it was their job to make sure that

00:01:08,479 --> 00:01:14,159
arendelle always had enough ice

00:01:12,400 --> 00:01:14,660
sven was always looking for ways to work

00:01:14,159 --> 00:01:16,159
smarter

00:01:14,660 --> 00:01:18,080
[Music]

00:01:16,159 --> 00:01:20,640
and he could always count on help from

00:01:18,080 --> 00:01:24,880
olaf the snowman

00:01:20,640 --> 00:01:28,479
less work means more time for adventures

00:01:24,880 --> 00:01:34,079
and sven and olaf love adventures

00:01:28,479 --> 00:01:34,079
chapter 2 sven's most magical idea

00:01:34,400 --> 00:01:38,799
sven and olaf had two other special

00:01:36,320 --> 00:01:43,520
friends in the kingdom

00:01:38,799 --> 00:01:46,159
princess anna and queen elsa

00:01:43,520 --> 00:01:47,280
anna is the brave tenacious princess of

00:01:46,159 --> 00:01:51,439
arendelle

00:01:47,280 --> 00:01:51,439
and queen elsa is a big sister

00:01:51,520 --> 00:01:56,159
queen elsa had amazing powers

00:01:54,560 --> 00:01:58,079
she could sense the water molecules

00:01:56,159 --> 00:02:01,520
around her

00:01:58,079 --> 00:02:05,520
transform those water molecules into ice

00:02:01,520 --> 00:02:05,520
and control that ice however she liked

00:02:05,759 --> 00:02:11,039
sven would never forget the day that

00:02:07,439 --> 00:02:11,039
elsa explained her magic

00:02:11,280 --> 00:02:16,239
i'm going to let you in on my little

00:02:12,800 --> 00:02:16,239
secret elsa began

00:02:16,640 --> 00:02:19,840
you may have heard that any sufficiently

00:02:18,879 --> 00:02:22,720
advanced technology

00:02:19,840 --> 00:02:23,599
is indistinguishable from magic but

00:02:22,720 --> 00:02:26,640
actually it's

00:02:23,599 --> 00:02:26,640
the other way around

00:02:27,040 --> 00:02:30,160
any sufficiently incredible magic is

00:02:29,599 --> 00:02:34,400
actually

00:02:30,160 --> 00:02:36,239
technology and the technology that makes

00:02:34,400 --> 00:02:39,760
my snow magic work

00:02:36,239 --> 00:02:39,760
is called typescript

00:02:40,879 --> 00:02:44,239
speed already knew typescript from his

00:02:42,560 --> 00:02:44,879
work running the website for the local

00:02:44,239 --> 00:02:47,920
sauna

00:02:44,879 --> 00:02:50,080
and he couldn't wait to learn more

00:02:47,920 --> 00:02:51,680
sven and olaf wanted to use elsa's ice

00:02:50,080 --> 00:02:54,560
magic to make kristoff's life

00:02:51,680 --> 00:02:55,120
a bit easier and they'd figured out the

00:02:54,560 --> 00:02:58,319
perfect

00:02:55,120 --> 00:03:00,640
plan they were so excited to share it

00:02:58,319 --> 00:03:04,560
with anna and elsa

00:03:00,640 --> 00:03:07,280
snort sven snorted

00:03:04,560 --> 00:03:08,959
anna was thrilled that's a great idea

00:03:07,280 --> 00:03:11,280
sven

00:03:08,959 --> 00:03:13,200
you can take elsa's typescript ice magic

00:03:11,280 --> 00:03:15,840
and create a library that anyone

00:03:13,200 --> 00:03:17,760
can use this is going to save so much

00:03:15,840 --> 00:03:20,800
time

00:03:17,760 --> 00:03:23,519
also couldn't wait to help let's do this

00:03:20,800 --> 00:03:25,920
she said anna and i will help you learn

00:03:23,519 --> 00:03:28,879
about typescript

00:03:25,920 --> 00:03:31,360
chapter three you can't freeze

00:03:28,879 --> 00:03:31,360
everything

00:03:31,599 --> 00:03:35,120
sven and olaf got straight to work on

00:03:33,280 --> 00:03:37,920
their new library

00:03:35,120 --> 00:03:38,239
they designed their ideal api it had

00:03:37,920 --> 00:03:41,519
just

00:03:38,239 --> 00:03:44,879
two functions freeze and thor

00:03:41,519 --> 00:03:46,560
you could take a thing freeze it

00:03:44,879 --> 00:03:49,360
and then thought to get it back in the

00:03:46,560 --> 00:03:50,480
original state

00:03:49,360 --> 00:03:53,439
they started building out the

00:03:50,480 --> 00:03:54,799
functionality the freeze function would

00:03:53,439 --> 00:03:58,000
be a nice wrapper around

00:03:54,799 --> 00:04:01,840
elsa's ice magic which elsa would help

00:03:58,000 --> 00:04:01,840
write down later

00:04:02,480 --> 00:04:05,840
this is great we're amazing olaf

00:04:04,720 --> 00:04:09,599
exclaimed

00:04:05,840 --> 00:04:09,599
arno and elsa what do you think

00:04:09,760 --> 00:04:14,720
this is really good great work sinana

00:04:13,040 --> 00:04:16,320
but do you want to make it even better

00:04:14,720 --> 00:04:20,479
ask elsa

00:04:16,320 --> 00:04:20,479
let's talk about developer experience

00:04:20,639 --> 00:04:23,919
what would happen if a user imported

00:04:22,960 --> 00:04:29,280
some magic

00:04:23,919 --> 00:04:30,880
fire and then tried to freeze it

00:04:29,280 --> 00:04:32,639
you and i know that you can't freeze

00:04:30,880 --> 00:04:35,520
magic fire but our users

00:04:32,639 --> 00:04:36,880
may not know that if they were to try to

00:04:35,520 --> 00:04:39,199
freeze magic fire

00:04:36,880 --> 00:04:41,280
there would be serious consequences but

00:04:39,199 --> 00:04:43,440
our library allows it

00:04:41,280 --> 00:04:47,199
it's our job as library authors to save

00:04:43,440 --> 00:04:47,199
our users from these kinds of tracks

00:04:47,440 --> 00:04:51,440
right now we're using the any type

00:04:51,600 --> 00:04:57,840
but that's okay it's not super easy to

00:04:53,840 --> 00:04:57,840
see how best to type this code

00:04:57,919 --> 00:05:01,919
we want to be able to freeze almost any

00:05:00,560 --> 00:05:03,680
input

00:05:01,919 --> 00:05:04,960
but right now the code says that you can

00:05:03,680 --> 00:05:08,479
freeze absolutely

00:05:04,960 --> 00:05:12,800
anything grunt

00:05:08,479 --> 00:05:15,600
spin grunted that's right spin

00:05:12,800 --> 00:05:17,039
ana replied we need to find some way to

00:05:15,600 --> 00:05:17,600
limit the kind of objects that can be

00:05:17,039 --> 00:05:19,199
frozen

00:05:17,600 --> 00:05:22,639
so that then we can freeze something

00:05:19,199 --> 00:05:24,880
that is unreasonable

00:05:22,639 --> 00:05:25,919
one thing we could do is catch the

00:05:24,880 --> 00:05:29,280
problem at run time

00:05:25,919 --> 00:05:31,199
elsa suggested we could check

00:05:29,280 --> 00:05:35,199
for the presence of the unfeasible

00:05:31,199 --> 00:05:35,199
property and then throw an error

00:05:35,280 --> 00:05:40,560
but we can do a bit better than that

00:05:38,880 --> 00:05:42,639
it would be better for the library user

00:05:40,560 --> 00:05:43,840
to know about the issue before they run

00:05:42,639 --> 00:05:45,759
the code

00:05:43,840 --> 00:05:49,360
and that's where typescript can help

00:05:45,759 --> 00:05:49,360
anna why don't you explain

00:05:49,520 --> 00:05:53,199
touchscript has lots of different types

00:05:51,600 --> 00:05:54,560
began

00:05:53,199 --> 00:05:56,240
there are all primitive types like

00:05:54,560 --> 00:05:57,680
boolean and string

00:05:56,240 --> 00:05:59,600
there's all the built-in types like

00:05:57,680 --> 00:06:01,039
array and date and then there's all the

00:05:59,600 --> 00:06:04,960
custom user-defined

00:06:01,039 --> 00:06:06,560
tags these types all form the typescript

00:06:04,960 --> 00:06:08,240
type system

00:06:06,560 --> 00:06:11,039
one way to think about this is like

00:06:08,240 --> 00:06:13,840
event diagram

00:06:11,039 --> 00:06:16,400
you have all of these different types

00:06:13,840 --> 00:06:18,240
which each do their own thing

00:06:16,400 --> 00:06:20,000
but they're all contained within a

00:06:18,240 --> 00:06:24,000
default type which is called

00:06:20,000 --> 00:06:24,720
any the any type is what is called the

00:06:24,000 --> 00:06:27,840
top type

00:06:24,720 --> 00:06:30,960
of a type system it is a super type

00:06:27,840 --> 00:06:34,960
of all other types it's a type for which

00:06:30,960 --> 00:06:36,800
all values are valid

00:06:34,960 --> 00:06:38,240
using the any type tells typescript that

00:06:36,800 --> 00:06:39,440
any value can be assigned to the

00:06:38,240 --> 00:06:41,199
variable

00:06:39,440 --> 00:06:42,880
so when typescript sees in any it

00:06:41,199 --> 00:06:45,440
basically stops type checking from that

00:06:42,880 --> 00:06:45,440
point on

00:06:45,680 --> 00:06:51,199
the any type makes the code very

00:06:47,440 --> 00:06:54,319
flexible but it can be a bit dangerous

00:06:51,199 --> 00:06:55,520
here if to freeze input is undefined a

00:06:54,319 --> 00:06:59,280
code will break

00:06:55,520 --> 00:06:59,280
but the compiler doesn't complain

00:07:01,680 --> 00:07:04,880
so we want our library to be flexible

00:07:03,680 --> 00:07:09,120
but without the danger

00:07:04,880 --> 00:07:09,120
that's our life is that even possible

00:07:09,759 --> 00:07:13,840
yes we play it typescript gives us

00:07:12,160 --> 00:07:16,960
another tool for us

00:07:13,840 --> 00:07:20,560
we can use the unknown type

00:07:16,960 --> 00:07:20,560
let's look at the venn diagram again

00:07:20,720 --> 00:07:24,160
we have the same venn diagram before

00:07:22,639 --> 00:07:25,199
with all the specific types in the

00:07:24,160 --> 00:07:27,440
middle

00:07:25,199 --> 00:07:29,440
and any as the super type of all these

00:07:27,440 --> 00:07:31,360
types

00:07:29,440 --> 00:07:34,880
but we can add another new friend in the

00:07:31,360 --> 00:07:37,599
middle called unknown

00:07:34,880 --> 00:07:38,880
the unknown type is also a top type of

00:07:37,599 --> 00:07:40,800
the type system

00:07:38,880 --> 00:07:44,080
it's also a super type of all other

00:07:40,800 --> 00:07:47,919
types and all values are also valid

00:07:44,080 --> 00:07:47,919
but it behaves a little bit differently

00:07:48,080 --> 00:07:52,000
if we replace the any with unknown

00:07:50,560 --> 00:07:54,800
[Music]

00:07:52,000 --> 00:07:56,479
we now get a compile-type error we can't

00:07:54,800 --> 00:08:00,560
use the unfeasible property

00:07:56,479 --> 00:08:00,560
because two frees might not exist

00:08:02,479 --> 00:08:05,599
but now we need to fix a compile time

00:08:04,319 --> 00:08:08,319
error so we need a way

00:08:05,599 --> 00:08:10,160
for the compiler to decipher the unknown

00:08:08,319 --> 00:08:12,080
value

00:08:10,160 --> 00:08:14,400
one we can we can do this is to use a

00:08:12,080 --> 00:08:16,000
type guide

00:08:14,400 --> 00:08:17,759
a type guide is a special kind of

00:08:16,000 --> 00:08:20,319
function that gives typescript hints

00:08:17,759 --> 00:08:22,319
about how to narrow a type

00:08:20,319 --> 00:08:23,840
in other words it tells typescript how

00:08:22,319 --> 00:08:28,879
to go from a broad type

00:08:23,840 --> 00:08:31,360
like any or unknown to a specific type

00:08:28,879 --> 00:08:33,519
the type guard is a runtime check that

00:08:31,360 --> 00:08:36,240
maps to a type

00:08:33,519 --> 00:08:37,039
it takes an input of unknown and checks

00:08:36,240 --> 00:08:41,839
that the input

00:08:37,039 --> 00:08:41,839
is a type by looking up a property on it

00:08:42,080 --> 00:08:47,839
we use a special is keyword to define

00:08:44,159 --> 00:08:50,000
what that type is when it's finished

00:08:47,839 --> 00:08:52,800
our type is defined as an object with a

00:08:50,000 --> 00:08:54,880
property of unreasonable set to true

00:08:52,800 --> 00:08:56,640
so after we've called the type guard

00:08:54,880 --> 00:08:57,360
touchscript knows that within the if

00:08:56,640 --> 00:09:01,920
statement

00:08:57,360 --> 00:09:01,920
our object is definitely not unfreezable

00:09:02,720 --> 00:09:06,640
right now the implementation is a little

00:09:04,320 --> 00:09:07,040
bit weird we're talking about something

00:09:06,640 --> 00:09:09,680
being

00:09:07,040 --> 00:09:11,519
not unfreezable and we're doing all of

00:09:09,680 --> 00:09:14,720
our work inside of the if statement with

00:09:11,519 --> 00:09:14,720
a weird throw outside

00:09:14,800 --> 00:09:18,720
it would be way better if we could talk

00:09:16,320 --> 00:09:21,120
about something being freezable

00:09:18,720 --> 00:09:22,959
typescript is another handy type to help

00:09:21,120 --> 00:09:25,040
let's go back to our venn diagram once

00:09:22,959 --> 00:09:27,760
again

00:09:25,040 --> 00:09:28,880
inside we have our two top types any and

00:09:27,760 --> 00:09:32,160
unknown

00:09:28,880 --> 00:09:34,720
all values are valid for these types but

00:09:32,160 --> 00:09:36,399
outside of any and unknown we have

00:09:34,720 --> 00:09:39,920
another type which is called

00:09:36,399 --> 00:09:41,279
never the never type is the bottom type

00:09:39,920 --> 00:09:45,760
of the type system

00:09:41,279 --> 00:09:45,760
it is a type which has no valid values

00:09:46,080 --> 00:09:50,560
we can use the never type to describe

00:09:47,680 --> 00:09:53,360
what a freezable object is

00:09:50,560 --> 00:09:55,680
an object with a value for the with a

00:09:53,360 --> 00:09:56,399
value assigned to the unfeasible

00:09:55,680 --> 00:10:00,320
property

00:09:56,399 --> 00:10:00,320
can never be assigned to freezable

00:10:03,279 --> 00:10:06,720
this means that we can invert our type

00:10:04,959 --> 00:10:10,079
guard we can rewrite it

00:10:06,720 --> 00:10:12,000
in terms of being freezable instead of

00:10:10,079 --> 00:10:13,760
as unfeasible in checking for the

00:10:12,000 --> 00:10:16,240
presence of unfreezable

00:10:13,760 --> 00:10:16,800
we write it at this freezable and check

00:10:16,240 --> 00:10:19,760
that there's

00:10:16,800 --> 00:10:22,079
not an unpredictable property this means

00:10:19,760 --> 00:10:23,360
that we have no more double negative

00:10:22,079 --> 00:10:25,600
but we've still got the weird control

00:10:23,360 --> 00:10:25,600
flow

00:10:25,760 --> 00:10:29,920
a way that we can get around this is use

00:10:28,560 --> 00:10:32,560
never again

00:10:29,920 --> 00:10:34,880
another way to use never is for a return

00:10:32,560 --> 00:10:37,120
type of a function that never returns

00:10:34,880 --> 00:10:38,320
for example a function that throws an

00:10:37,120 --> 00:10:40,560
error will never

00:10:38,320 --> 00:10:42,800
return a value which we could use like

00:10:40,560 --> 00:10:42,800
this

00:10:44,079 --> 00:10:48,000
to get even better we have the idea of

00:10:45,839 --> 00:10:51,680
an assertion guard which combines

00:10:48,000 --> 00:10:52,240
type guards and never if a function

00:10:51,680 --> 00:10:55,600
doesn't

00:10:52,240 --> 00:10:57,440
throw the return type is freezable

00:10:55,600 --> 00:10:58,800
and here we are saying that we assert

00:10:57,440 --> 00:11:01,120
that a thing is freezable

00:10:58,800 --> 00:11:01,920
so if it does throw it returns never but

00:11:01,120 --> 00:11:04,880
if it doesn't

00:11:01,920 --> 00:11:06,640
we know that we're feasible any code

00:11:04,880 --> 00:11:07,279
that executes after the function call

00:11:06,640 --> 00:11:10,000
therefore

00:11:07,279 --> 00:11:12,839
must be running on a feasible type which

00:11:10,000 --> 00:11:15,440
means we can have much more sensible

00:11:12,839 --> 00:11:17,680
control

00:11:15,440 --> 00:11:19,120
that's looking great see elsa but we can

00:11:17,680 --> 00:11:21,680
still go further

00:11:19,120 --> 00:11:25,760
our input is still type is unknown so

00:11:21,680 --> 00:11:25,760
we're still depending on a runtime error

00:11:27,279 --> 00:11:31,680
but now that we've got our freezable

00:11:29,040 --> 00:11:34,160
type we can restrict our input to only

00:11:31,680 --> 00:11:35,120
accept things that are freezable now we

00:11:34,160 --> 00:11:38,959
have a runtime

00:11:35,120 --> 00:11:38,959
and compile time safety checks

00:11:39,200 --> 00:11:47,040
chapter four to be frozen

00:11:43,360 --> 00:11:47,040
sven and olaf were delighted

00:11:47,120 --> 00:11:50,240
what's next we asked

00:11:50,399 --> 00:11:55,519
next we need to talk about what is

00:11:52,480 --> 00:11:57,200
involved with freezing something

00:11:55,519 --> 00:11:59,600
i use a very obscure dialect of

00:11:57,200 --> 00:12:03,040
typescript for my ice magic setup

00:11:59,600 --> 00:12:03,040
it looks something like this

00:12:03,120 --> 00:12:07,200
you're just gonna have to trust me that

00:12:04,720 --> 00:12:07,200
it works

00:12:08,560 --> 00:12:12,079
we can simplify it down a bit to

00:12:09,920 --> 00:12:13,839
understand what's going on

00:12:12,079 --> 00:12:15,680
the function tries to run the magic on

00:12:13,839 --> 00:12:19,360
the object and then it sets

00:12:15,680 --> 00:12:19,360
the frozen property of that object

00:12:19,600 --> 00:12:25,200
but now we have some messy types again

00:12:21,760 --> 00:12:27,519
and we need to fix them

00:12:25,200 --> 00:12:29,680
we already have a freezable type but we

00:12:27,519 --> 00:12:34,399
need to somehow replace the unknowns and

00:12:29,680 --> 00:12:36,639
any we need to have the frozen type

00:12:34,399 --> 00:12:37,519
the most basic version of this might

00:12:36,639 --> 00:12:39,920
look something

00:12:37,519 --> 00:12:40,880
like this basic frozen type where the

00:12:39,920 --> 00:12:43,920
property frozen

00:12:40,880 --> 00:12:46,959
is set to true but it doesn't really

00:12:43,920 --> 00:12:48,800
express what we mean

00:12:46,959 --> 00:12:50,959
we want to combine the type of our

00:12:48,800 --> 00:12:53,040
freezable thing and augment it with the

00:12:50,959 --> 00:12:54,480
basic frozen type

00:12:53,040 --> 00:12:56,079
so we need a type that describes

00:12:54,480 --> 00:13:00,160
something that is freezable

00:12:56,079 --> 00:13:00,160
but also has the frozen property

00:13:01,040 --> 00:13:05,279
we can use typescript to express this by

00:13:03,279 --> 00:13:06,959
using generic types and intersection

00:13:05,279 --> 00:13:09,040
types

00:13:06,959 --> 00:13:10,399
here we say that if an object is a

00:13:09,040 --> 00:13:13,600
frozen of some type

00:13:10,399 --> 00:13:15,279
t it has all the properties from t and

00:13:13,600 --> 00:13:16,000
all the properties from this extra

00:13:15,279 --> 00:13:19,519
object

00:13:16,000 --> 00:13:22,800
in our case the frozen true

00:13:19,519 --> 00:13:24,800
let's type in data it can be useful to

00:13:22,800 --> 00:13:26,880
think about complex types in equivalent

00:13:24,800 --> 00:13:28,560
javascript syntax

00:13:26,880 --> 00:13:31,760
you can think of the type as like a

00:13:28,560 --> 00:13:33,519
function adding a generic type parameter

00:13:31,760 --> 00:13:35,839
is like adding a parameter to that

00:13:33,519 --> 00:13:38,000
function

00:13:35,839 --> 00:13:40,320
an intersection type is kind of like a

00:13:38,000 --> 00:13:42,000
type version of an object spread

00:13:40,320 --> 00:13:44,880
where you get all the properties from

00:13:42,000 --> 00:13:44,880
both types

00:13:47,040 --> 00:13:50,720
using this we can almost correctly

00:13:49,040 --> 00:13:52,800
express our function

00:13:50,720 --> 00:13:55,279
we can replace all of our annie's and

00:13:52,800 --> 00:13:57,600
unknowns with frozen of t

00:13:55,279 --> 00:14:02,000
but there's still one thing missing do

00:13:57,600 --> 00:14:03,519
you see what it is

00:14:02,000 --> 00:14:06,720
doesn't say anywhere that the input has

00:14:03,519 --> 00:14:09,360
to be freezable to open it off

00:14:06,720 --> 00:14:11,440
exactly for that we need to express one

00:14:09,360 --> 00:14:14,079
more type relationship

00:14:11,440 --> 00:14:14,800
we have our feasible type and we want to

00:14:14,079 --> 00:14:18,160
describe

00:14:14,800 --> 00:14:20,000
all types that contain freezable

00:14:18,160 --> 00:14:21,360
just like any with a supertype of

00:14:20,000 --> 00:14:23,680
boolean and string

00:14:21,360 --> 00:14:26,079
and array we want a supertype of

00:14:23,680 --> 00:14:30,639
freezable

00:14:26,079 --> 00:14:32,639
for that we can use the extends keyword

00:14:30,639 --> 00:14:33,839
if we go back to our function analogy

00:14:32,639 --> 00:14:37,040
using extensions

00:14:33,839 --> 00:14:39,440
is a bit like specifying a type

00:14:37,040 --> 00:14:41,279
for the type of parameter anything that

00:14:39,440 --> 00:14:43,519
enters that type parameter must be of

00:14:41,279 --> 00:14:45,279
that type

00:14:43,519 --> 00:14:47,760
we can even set a default for the type

00:14:45,279 --> 00:14:49,680
parameter

00:14:47,760 --> 00:14:51,680
in this case we set it to freezable by

00:14:49,680 --> 00:14:53,839
default

00:14:51,680 --> 00:14:57,279
so now we just need to have everything

00:14:53,839 --> 00:14:59,519
that we need to use the freeze function

00:14:57,279 --> 00:15:00,480
so putting it all together we have a

00:14:59,519 --> 00:15:02,240
freezable type

00:15:00,480 --> 00:15:04,720
which is an object with the unfreezable

00:15:02,240 --> 00:15:06,160
property that's never assignable to

00:15:04,720 --> 00:15:08,560
freezable

00:15:06,160 --> 00:15:09,360
a frozen type so a frozen object is the

00:15:08,560 --> 00:15:11,839
intersection

00:15:09,360 --> 00:15:15,040
of a freezable object and an object with

00:15:11,839 --> 00:15:18,079
the frozen property set to true

00:15:15,040 --> 00:15:21,360
uh the absurd freezable

00:15:18,079 --> 00:15:22,959
function which is a

00:15:21,360 --> 00:15:25,199
assertion guard that takes an object

00:15:22,959 --> 00:15:25,680
input and throws an error if the object

00:15:25,199 --> 00:15:30,000
is not

00:15:25,680 --> 00:15:31,360
freezable and we have a freeze function

00:15:30,000 --> 00:15:33,440
the function which is a function that

00:15:31,360 --> 00:15:34,399
takes a feasible input asserts that it

00:15:33,440 --> 00:15:36,560
is freezable

00:15:34,399 --> 00:15:40,000
freezes the object and then returns a

00:15:36,560 --> 00:15:42,720
frozen type

00:15:40,000 --> 00:15:44,800
olaf was very excited the library's

00:15:42,720 --> 00:15:46,720
finished he asked

00:15:44,800 --> 00:15:48,480
come on sven let's go show kristoff

00:15:46,720 --> 00:15:50,399
right away

00:15:48,480 --> 00:15:52,639
and before anna and elsa could even try

00:15:50,399 --> 00:15:53,040
to stop them sven and olaf were out the

00:15:52,639 --> 00:15:56,800
door

00:15:53,040 --> 00:16:00,399
and on their way chapter five

00:15:56,800 --> 00:16:00,399
too fast too frozen

00:16:00,880 --> 00:16:06,320
i will often spin rushed to show

00:16:03,519 --> 00:16:08,320
kristoff their library

00:16:06,320 --> 00:16:10,240
hi christoph we made you a library to

00:16:08,320 --> 00:16:13,600
help make your job easier

00:16:10,240 --> 00:16:15,120
snort snorted slim

00:16:13,600 --> 00:16:17,839
you can use it to freeze anything you

00:16:15,120 --> 00:16:19,920
like just like elsa

00:16:17,839 --> 00:16:23,839
and it will even stop you from freezing

00:16:19,920 --> 00:16:23,839
anything that can't be frozen

00:16:24,000 --> 00:16:28,800
kristoff was blown away by this you made

00:16:26,560 --> 00:16:30,880
this for me

00:16:28,800 --> 00:16:32,720
let's try it on me right now suggested

00:16:30,880 --> 00:16:34,880
over

00:16:32,720 --> 00:16:36,160
kristoff is quite the rockstar developer

00:16:34,880 --> 00:16:38,800
so he wrote a little script

00:16:36,160 --> 00:16:39,279
very quickly but just as he ran the

00:16:38,800 --> 00:16:42,959
script

00:16:39,279 --> 00:16:46,000
anna and elsa burst in wait

00:16:42,959 --> 00:16:48,839
stop exclaimed elsa we still need to

00:16:46,000 --> 00:16:51,519
write the thor function

00:16:48,839 --> 00:16:54,560
sedan but it was too late

00:16:51,519 --> 00:16:57,759
the library worked

00:16:54,560 --> 00:16:57,759
olaf was frozen

00:16:58,160 --> 00:17:03,360
chapter six do you want to thaw a

00:17:00,959 --> 00:17:06,400
snowman

00:17:03,360 --> 00:17:07,199
kristoff was devastated oh no what have

00:17:06,400 --> 00:17:10,720
i done

00:17:07,199 --> 00:17:13,199
i've frozen olaf we need to move fast

00:17:10,720 --> 00:17:15,280
said elsa or olaf could be frozen

00:17:13,199 --> 00:17:17,600
forever

00:17:15,280 --> 00:17:18,640
let's start with the javascript we have

00:17:17,600 --> 00:17:20,400
a thor function

00:17:18,640 --> 00:17:22,559
which will delete the frozen property of

00:17:20,400 --> 00:17:23,199
an object and we will use the assert

00:17:22,559 --> 00:17:26,799
frozen

00:17:23,199 --> 00:17:26,799
function to validate the output

00:17:27,600 --> 00:17:31,360
can't we just add any everywhere and fix

00:17:29,520 --> 00:17:33,280
it ask kristoff

00:17:31,360 --> 00:17:36,000
it's too risky replied anna we don't

00:17:33,280 --> 00:17:37,840
want something going wrong

00:17:36,000 --> 00:17:39,840
sven why don't you add types to the

00:17:37,840 --> 00:17:43,520
assertion guard first

00:17:39,840 --> 00:17:45,679
yo gulp spin

00:17:43,520 --> 00:17:47,360
first spin out of the unknown type to

00:17:45,679 --> 00:17:49,840
the input

00:17:47,360 --> 00:17:51,200
then he cast the input to frozen to do

00:17:49,840 --> 00:17:52,960
the check

00:17:51,200 --> 00:17:54,880
and finally he added the assertion

00:17:52,960 --> 00:17:57,760
statement for the return type to

00:17:54,880 --> 00:18:01,600
validate that something is frozen

00:17:57,760 --> 00:18:04,960
that's perfect sedan clip clock

00:18:01,600 --> 00:18:06,160
synthetic now we need to add types to

00:18:04,960 --> 00:18:09,520
the thor function

00:18:06,160 --> 00:18:09,520
kristoff i'll need your help

00:18:10,240 --> 00:18:14,080
so we can start by adding a generic type

00:18:12,320 --> 00:18:16,559
for the input that has to extend

00:18:14,080 --> 00:18:16,559
frozen

00:18:17,280 --> 00:18:22,240
but i have no idea how to do the return

00:18:19,120 --> 00:18:22,240
type please help

00:18:23,120 --> 00:18:27,200
we need to use typescript to extract the

00:18:25,360 --> 00:18:28,880
type of the original object from the

00:18:27,200 --> 00:18:31,280
frozen type

00:18:28,880 --> 00:18:34,320
this is the perfect time to use

00:18:31,280 --> 00:18:36,559
conditional types

00:18:34,320 --> 00:18:39,120
conditional types let us change type

00:18:36,559 --> 00:18:41,919
based on the state of other types

00:18:39,120 --> 00:18:43,520
we have a condition a type for if the

00:18:41,919 --> 00:18:47,360
condition passes

00:18:43,520 --> 00:18:47,360
and a type for if the condition fails

00:18:47,840 --> 00:18:52,720
a conditional type is kind of like a

00:18:49,520 --> 00:18:54,640
type function with an if segment

00:18:52,720 --> 00:18:57,840
different types are returned based on

00:18:54,640 --> 00:18:57,840
the state of the condition

00:18:58,480 --> 00:19:02,080
conditional types also have an extra

00:19:00,240 --> 00:19:06,000
special power which is called

00:19:02,080 --> 00:19:07,600
type inference type inference gives us a

00:19:06,000 --> 00:19:10,799
mechanism to extract

00:19:07,600 --> 00:19:12,640
types from other types imagine that we

00:19:10,799 --> 00:19:15,679
want to extract the type of the return

00:19:12,640 --> 00:19:17,679
value of a function

00:19:15,679 --> 00:19:19,679
we can write a conditional type called

00:19:17,679 --> 00:19:21,440
return type which takes in a type

00:19:19,679 --> 00:19:24,080
parameter t

00:19:21,440 --> 00:19:25,200
we check if t is a function with some

00:19:24,080 --> 00:19:27,520
number of parameters

00:19:25,200 --> 00:19:28,559
and then return type and return to type

00:19:27,520 --> 00:19:33,600
r

00:19:28,559 --> 00:19:36,799
then we infer r using the infer keyword

00:19:33,600 --> 00:19:40,000
if the condition passes t is a function

00:19:36,799 --> 00:19:40,480
and so we return r otherwise t isn't a

00:19:40,000 --> 00:19:43,840
function

00:19:40,480 --> 00:19:45,600
so we return never if we pass at the

00:19:43,840 --> 00:19:48,160
type of a function we get back the

00:19:45,600 --> 00:19:49,520
return type

00:19:48,160 --> 00:19:51,840
we can do the same thing to figure out

00:19:49,520 --> 00:19:53,840
the parameters of a function the types

00:19:51,840 --> 00:19:55,600
of the parameters and function

00:19:53,840 --> 00:19:57,120
we check if t is a function with a

00:19:55,600 --> 00:19:59,280
number of parameters p

00:19:57,120 --> 00:20:00,799
and then we infer p using the infer

00:19:59,280 --> 00:20:04,159
keyword

00:20:00,799 --> 00:20:07,280
if the condition passes t is a function

00:20:04,159 --> 00:20:07,840
so we return p otherwise t isn't a

00:20:07,280 --> 00:20:11,440
function

00:20:07,840 --> 00:20:12,799
so we return never again if we pass it

00:20:11,440 --> 00:20:14,720
the type of a function

00:20:12,799 --> 00:20:17,840
we get back a list of the types of the

00:20:14,720 --> 00:20:17,840
parameters to that function

00:20:18,320 --> 00:20:24,000
we can use type invertments to extract

00:20:20,400 --> 00:20:26,720
the type of the generic frozen object

00:20:24,000 --> 00:20:27,760
we check if t extends frozen with some

00:20:26,720 --> 00:20:32,000
generic type

00:20:27,760 --> 00:20:35,280
r and we infer r using the infer keyword

00:20:32,000 --> 00:20:38,080
if the condition passes we use r

00:20:35,280 --> 00:20:40,080
otherwise t isn't frozen so we return

00:20:38,080 --> 00:20:42,480
never

00:20:40,080 --> 00:20:43,679
if we pass it a frozen object we get

00:20:42,480 --> 00:20:48,080
back the type

00:20:43,679 --> 00:20:50,799
the original object

00:20:48,080 --> 00:20:53,039
okay said crystal i've got this i'll

00:20:50,799 --> 00:20:56,320
update the four function

00:20:53,039 --> 00:20:58,080
add the third conditional type use

00:20:56,320 --> 00:21:03,840
thought as the return type

00:20:58,080 --> 00:21:03,840
and cast the result

00:21:04,159 --> 00:21:10,080
that looks perfect to me let's say if i

00:21:06,640 --> 00:21:10,080
laugh before it's too late

00:21:10,799 --> 00:21:14,559
chapter seven that was weird

00:21:15,039 --> 00:21:20,960
kristoff sven anna and elsa worked

00:21:17,679 --> 00:21:22,799
together to quickly write a new script

00:21:20,960 --> 00:21:24,559
thanks to the library's excellent types

00:21:22,799 --> 00:21:28,000
they were confident that the code

00:21:24,559 --> 00:21:30,799
was good so they ran the script

00:21:28,000 --> 00:21:33,520
and just like that olaf was back to his

00:21:30,799 --> 00:21:33,520
normal self

00:21:33,840 --> 00:21:38,480
hi everyone my name's overlove that was

00:21:36,720 --> 00:21:41,760
weird

00:21:38,480 --> 00:21:44,799
what happened oh olaf

00:21:41,760 --> 00:21:46,320
we're so glad you're okay so much has

00:21:44,799 --> 00:21:50,799
happened

00:21:46,320 --> 00:21:50,799
kristoff i think you'd better explain

00:21:50,880 --> 00:21:55,360
okay i think we've got it are you ready

00:21:53,679 --> 00:21:59,840
sven

00:21:55,360 --> 00:21:59,840
sniff synthetic

00:22:01,760 --> 00:22:08,720
[Music]

00:22:05,360 --> 00:22:12,559
unknown is better than any

00:22:08,720 --> 00:22:15,360
sven don't you think that's true

00:22:12,559 --> 00:22:16,480
yes unknowns to flex i know it's your

00:22:15,360 --> 00:22:18,480
new bestie

00:22:16,480 --> 00:22:21,280
and never is pretty cool too

00:22:18,480 --> 00:22:24,400
[Music]

00:22:21,280 --> 00:22:28,559
generics are also quite useful

00:22:24,400 --> 00:22:31,520
for describing unknown types

00:22:28,559 --> 00:22:32,799
and don't forget unions traditional

00:22:31,520 --> 00:22:36,640
entrances

00:22:32,799 --> 00:22:40,080
your users will have a great time

00:22:36,640 --> 00:22:43,200
that's right the good

00:22:40,080 --> 00:22:45,520
types are worth the

00:22:43,200 --> 00:22:45,520
high

00:22:47,200 --> 00:22:52,720
and just like that everything was back

00:22:50,159 --> 00:22:52,720
to normal

00:22:53,120 --> 00:22:59,840
the end thanks everyone

00:22:57,280 --> 00:23:00,480
i hope you enjoyed that um found me on

00:22:59,840 --> 00:23:02,159
the internet

00:23:00,480 --> 00:23:04,000
again tweet me any questions you've got

00:23:02,159 --> 00:23:09,180
and all my slides are online

00:23:04,000 --> 00:23:09,630
thanks so much

00:23:09,180 --> 00:23:10,360
[Music]

00:23:09,630 --> 00:23:13,830
[Applause]

00:23:10,360 --> 00:23:15,870
[Music]

00:23:13,830 --> 00:23:19,360
[Applause]

00:23:15,870 --> 00:23:21,440
[Music]

00:23:19,360 --> 00:23:21,440

YouTube URL: https://www.youtube.com/watch?v=W2-Djx-brxo


