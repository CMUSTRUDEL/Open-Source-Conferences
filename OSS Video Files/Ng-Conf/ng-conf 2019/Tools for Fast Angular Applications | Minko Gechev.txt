Title: Tools for Fast Angular Applications | Minko Gechev
Publication date: 2019-05-02
Playlist: ng-conf 2019
Description: 
	Angular grew significantly in the past few years from both a tooling and developer experience standpoint. This talk will explore many of the features and newer improvements in the pipeline that allow anyone to build and deploy performant apps with very little overhead.

Through real demos and examples, we’ll cover Ivy, bundle budgeting, differential serving, automatic code-splitting, and more! In the second part of the talk, we’ll focus on how to efficiently prefetch and preload different modules and components.

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:07,920 --> 00:00:11,170
[Music]

00:00:11,719 --> 00:00:16,590
all right hello everyone my name is Mika

00:00:15,089 --> 00:00:18,869
ketchup I'm an engineer in the angular

00:00:16,590 --> 00:00:21,510
team at Google today I'm going to be

00:00:18,869 --> 00:00:23,220
talking about a couple of tools that we

00:00:21,510 --> 00:00:25,380
have been working on over the past few

00:00:23,220 --> 00:00:28,980
months which aim to help you build

00:00:25,380 --> 00:00:31,080
faster and your applications so let us

00:00:28,980 --> 00:00:32,880
start with your gender we're going to

00:00:31,080 --> 00:00:34,050
discuss what is network performance I

00:00:32,880 --> 00:00:35,610
believe most of you are already familiar

00:00:34,050 --> 00:00:37,700
with this but we're also going to

00:00:35,610 --> 00:00:39,899
introduce a couple of tips and tricks

00:00:37,700 --> 00:00:41,910
which you can directly take from this

00:00:39,899 --> 00:00:43,290
presentation and introduce in your

00:00:41,910 --> 00:00:46,140
applications in order to make them

00:00:43,290 --> 00:00:48,450
faster after that we're going to discuss

00:00:46,140 --> 00:00:50,850
how we can efficiently deploy and your

00:00:48,450 --> 00:00:55,430
applications to production just by using

00:00:50,850 --> 00:00:57,750
the angular CLI so network performance

00:00:55,430 --> 00:01:00,000
network performance is a time required

00:00:57,750 --> 00:01:03,059
for your application to get downloaded

00:01:00,000 --> 00:01:04,739
in the browser pretty much so we can

00:01:03,059 --> 00:01:07,680
optimize the network performance of our

00:01:04,739 --> 00:01:09,590
app just by reducing the number of bytes

00:01:07,680 --> 00:01:11,880
that were transferring over the wire and

00:01:09,590 --> 00:01:14,909
reducing the number of network requests

00:01:11,880 --> 00:01:17,490
that we're also sending a couple of

00:01:14,909 --> 00:01:19,799
tools that we have been working on they

00:01:17,490 --> 00:01:21,689
aim to help you ship fewer bytes of

00:01:19,799 --> 00:01:23,700
JavaScript because it turns out that

00:01:21,689 --> 00:01:25,920
javascript is more expensive than some

00:01:23,700 --> 00:01:28,380
other assets for example I'd use money

00:01:25,920 --> 00:01:31,079
in his survey the state of JavaScript he

00:01:28,380 --> 00:01:33,630
shown that shipping 170 kilobytes of

00:01:31,079 --> 00:01:36,119
JavaScript is much more expensive than

00:01:33,630 --> 00:01:39,329
shipping 170 kilobytes of a jpg image

00:01:36,119 --> 00:01:42,180
about 20 times more expensive because of

00:01:39,329 --> 00:01:44,850
the overhead of parsing and right after

00:01:42,180 --> 00:01:48,930
that executing this JavaScript code and

00:01:44,850 --> 00:01:50,970
compiling it so native so a couple of

00:01:48,930 --> 00:01:53,220
practices are of course minification and

00:01:50,970 --> 00:01:54,390
that code elimination this is something

00:01:53,220 --> 00:01:57,180
that we have been building in the

00:01:54,390 --> 00:02:00,030
angular CLI and introduced units it's

00:01:57,180 --> 00:02:02,700
for its early days so we are already

00:02:00,030 --> 00:02:04,680
doing unification we are eliminating all

00:02:02,700 --> 00:02:07,320
that codes after ahead of time

00:02:04,680 --> 00:02:10,379
compilation and we are making sure your

00:02:07,320 --> 00:02:12,540
apps execute as fast as possible but

00:02:10,379 --> 00:02:13,630
something new that we have been working

00:02:12,540 --> 00:02:16,540
on together with MAO

00:02:13,630 --> 00:02:18,070
from the community to interview and

00:02:16,540 --> 00:02:20,400
which we are going to introduce as part

00:02:18,070 --> 00:02:22,480
of version eight is differential loading

00:02:20,400 --> 00:02:24,220
so this is a feature that I'm

00:02:22,480 --> 00:02:26,800
particularly excited about especially

00:02:24,220 --> 00:02:30,340
because of its performance benefits and

00:02:26,800 --> 00:02:32,320
our users who are on modern browsers

00:02:30,340 --> 00:02:35,470
that are no longer need have to pay the

00:02:32,320 --> 00:02:38,350
penalty for shipping just getting

00:02:35,470 --> 00:02:39,880
polyfills for older browsers so here is

00:02:38,350 --> 00:02:43,150
how differential loading is going to

00:02:39,880 --> 00:02:45,160
work we're currently building to type

00:02:43,150 --> 00:02:47,770
two times your application once for

00:02:45,160 --> 00:02:50,350
older browsers and once for newer

00:02:47,770 --> 00:02:53,050
browsers we're going to build es five

00:02:50,350 --> 00:02:57,360
bundles for your users who are on legacy

00:02:53,050 --> 00:03:00,580
browsers and years 2015 bundles for

00:02:57,360 --> 00:03:04,060
users who are on leading-edge browsers

00:03:00,580 --> 00:03:06,010
so there are a couple of benefits of

00:03:04,060 --> 00:03:08,950
this first of all we need to shift your

00:03:06,010 --> 00:03:11,770
polyfills right and on top of that will

00:03:08,950 --> 00:03:14,050
not have to down level the modern syntax

00:03:11,770 --> 00:03:16,510
which is not only going to make your

00:03:14,050 --> 00:03:19,090
bundles more but it is also going to

00:03:16,510 --> 00:03:20,830
make them faster to execute because well

00:03:19,090 --> 00:03:23,320
the JavaScript engine can take advantage

00:03:20,830 --> 00:03:24,580
of the more expressive and more powerful

00:03:23,320 --> 00:03:28,540
syntax which has been introduced

00:03:24,580 --> 00:03:30,640
recently we noticed some performance

00:03:28,540 --> 00:03:34,720
improvements in a couple of applications

00:03:30,640 --> 00:03:36,880
and we buy very early measurements we

00:03:34,720 --> 00:03:40,840
can see that we're hitting about 65

00:03:36,880 --> 00:03:42,670
kilobytes less polyfills and from two to

00:03:40,840 --> 00:03:44,620
ten percents more bundles or even more

00:03:42,670 --> 00:03:46,540
this depends completely on how modern

00:03:44,620 --> 00:03:50,700
syntax how modern and expressive syntax

00:03:46,540 --> 00:03:53,050
you're already using in your application

00:03:50,700 --> 00:03:55,510
here is how differential warning works

00:03:53,050 --> 00:03:57,040
so first the browser sense of course

00:03:55,510 --> 00:03:59,560
requests to the server the server

00:03:57,040 --> 00:04:02,320
delivers the HTML where there are two

00:03:59,560 --> 00:04:05,200
script tags one for modern browsers and

00:04:02,320 --> 00:04:06,730
one for legacy browsers from there the

00:04:05,200 --> 00:04:08,770
browser depending on its supported

00:04:06,730 --> 00:04:10,930
capabilities it chooses one of these

00:04:08,770 --> 00:04:13,300
script tags it downloads the Associated

00:04:10,930 --> 00:04:16,180
JavaScript and right after that executes

00:04:13,300 --> 00:04:19,060
it that's it here is how the index.html

00:04:16,180 --> 00:04:20,950
file looks like here are the two script

00:04:19,060 --> 00:04:24,220
tags one of them is with type module

00:04:20,950 --> 00:04:27,250
which is associated with the Year 2015

00:04:24,220 --> 00:04:30,550
bundle and we have a script tag

00:04:27,250 --> 00:04:33,370
with attributes no module this is just a

00:04:30,550 --> 00:04:36,850
hint for newer browsers to not download

00:04:33,370 --> 00:04:41,860
this bundle if they already have es m

00:04:36,850 --> 00:04:43,390
equal to 2015 module support so why did

00:04:41,860 --> 00:04:45,640
we choose differential load link instead

00:04:43,390 --> 00:04:48,610
of doing some magic on the server well

00:04:45,640 --> 00:04:50,920
first of all it simplifies deployment a

00:04:48,610 --> 00:04:54,100
lot the browser makes the decision which

00:04:50,920 --> 00:04:56,230
which bundle to download and we don't

00:04:54,100 --> 00:04:57,970
have to cover our server with any

00:04:56,230 --> 00:05:00,370
complicated logic which is related to

00:04:57,970 --> 00:05:02,290
parsing the user agent and deciding what

00:05:00,370 --> 00:05:04,810
JavaScript is supported by the users

00:05:02,290 --> 00:05:07,020
browser at all and on top of that there

00:05:04,810 --> 00:05:08,950
is a proposal which aims to make

00:05:07,020 --> 00:05:11,620
differential loading a first-class

00:05:08,950 --> 00:05:13,960
citizen in modern browsers so this is

00:05:11,620 --> 00:05:15,730
two very early stage it may even not

00:05:13,960 --> 00:05:17,440
ever get standardized but it's pretty

00:05:15,730 --> 00:05:19,510
exciting to see that people are working

00:05:17,440 --> 00:05:21,730
in this direction so currently

00:05:19,510 --> 00:05:23,260
differential warding we're restricted to

00:05:21,730 --> 00:05:27,850
in shipping two different versions of

00:05:23,260 --> 00:05:29,710
JavaScript yes five and year 2015 with

00:05:27,850 --> 00:05:32,440
this new standard will be able to ship

00:05:29,710 --> 00:05:34,750
multiple JavaScript versions so that the

00:05:32,440 --> 00:05:40,180
browser can download the most recent one

00:05:34,750 --> 00:05:41,950
depending on the support syntax it has a

00:05:40,180 --> 00:05:44,500
summation forget to introduce this as

00:05:41,950 --> 00:05:45,850
part of angular CLI version 8 you can

00:05:44,500 --> 00:05:49,660
already experiment with this feature

00:05:45,850 --> 00:05:51,400
with our our C 2 which is on NPM so yeah

00:05:49,660 --> 00:05:53,440
please give it a try and so let us know

00:05:51,400 --> 00:05:57,880
how much we shrink we shrunk your

00:05:53,440 --> 00:06:00,340
bundles how you can control differential

00:05:57,880 --> 00:06:02,200
loading so we have 2 properties in the

00:06:00,340 --> 00:06:03,790
angular CLI which allow you to set the

00:06:02,200 --> 00:06:05,470
minimum supported version that you would

00:06:03,790 --> 00:06:08,470
want us to ship to provide for you and

00:06:05,470 --> 00:06:11,910
the maximum one you can set the targets

00:06:08,470 --> 00:06:14,140
in his config dot JSON to years 2015 and

00:06:11,910 --> 00:06:16,750
you need to set the minimum browser

00:06:14,140 --> 00:06:19,270
support minimum supported browsers in

00:06:16,750 --> 00:06:22,150
your browser browser list in order to

00:06:19,270 --> 00:06:23,350
make sure that you're shipping yes 5 so

00:06:22,150 --> 00:06:24,970
that your application is not only

00:06:23,350 --> 00:06:30,370
compatible with all the other browsers

00:06:24,970 --> 00:06:32,320
but also C SEO friendly all right so now

00:06:30,370 --> 00:06:35,500
let us go to even more exciting part

00:06:32,320 --> 00:06:39,210
which is called splitting cost rating in

00:06:35,500 --> 00:06:41,580
general one technique which is a sub

00:06:39,210 --> 00:06:45,539
of larger set of practices called lazy

00:06:41,580 --> 00:06:47,460
loading with lazy loading we just ship

00:06:45,539 --> 00:06:49,620
the minimum amount of assets which are

00:06:47,460 --> 00:06:51,630
required for the user a given points you

00:06:49,620 --> 00:06:54,180
might have seen this on medium where you

00:06:51,630 --> 00:06:55,770
see pretty much all the images which are

00:06:54,180 --> 00:06:58,470
currently visible in the viewport and

00:06:55,770 --> 00:07:00,360
once you start scrolling more and more

00:06:58,470 --> 00:07:01,590
visible more and more images get visible

00:07:00,360 --> 00:07:05,069
get downloaded from the server and

00:07:01,590 --> 00:07:08,430
visualized in the browser so to the two

00:07:05,069 --> 00:07:10,919
specific practices for lazy loading

00:07:08,430 --> 00:07:13,889
JavaScript our component level and route

00:07:10,919 --> 00:07:15,180
level code splitting with component

00:07:13,889 --> 00:07:16,970
level code splitting let's say that we

00:07:15,180 --> 00:07:20,370
have a very heavy ecommerce platform

00:07:16,970 --> 00:07:22,259
which has even heavier widgets chat

00:07:20,370 --> 00:07:23,490
widget there like chat support widget

00:07:22,259 --> 00:07:26,400
which is something like slack in the

00:07:23,490 --> 00:07:28,380
browser and we know that's only about 2%

00:07:26,400 --> 00:07:31,050
of user engage with this user only about

00:07:28,380 --> 00:07:32,759
2% of users are actually using it so

00:07:31,050 --> 00:07:34,080
does this mean that we'll have to

00:07:32,759 --> 00:07:36,840
introduce this part of our initial

00:07:34,080 --> 00:07:38,729
bundle so that everyone is paying for

00:07:36,840 --> 00:07:41,370
the price of this widget even though

00:07:38,729 --> 00:07:42,840
they are not using it at all no we can

00:07:41,370 --> 00:07:44,610
just lazy load it we can put a

00:07:42,840 --> 00:07:46,530
placeholder there and once the user

00:07:44,610 --> 00:07:48,900
starts interacting with this widget we

00:07:46,530 --> 00:07:50,580
can send a request over the network we

00:07:48,900 --> 00:07:52,860
can download the corresponding Java

00:07:50,580 --> 00:07:56,370
scripts and bootstrap the chat widget

00:07:52,860 --> 00:07:57,810
completely so this has been a little bit

00:07:56,370 --> 00:07:59,870
hard to achieve with the Angels view

00:07:57,810 --> 00:08:01,919
engine but there are a couple of modules

00:07:59,870 --> 00:08:04,530
community modules which are going to let

00:08:01,919 --> 00:08:06,840
you do that for example we have ng a

00:08:04,530 --> 00:08:08,610
explodable which on about 2 points 2

00:08:06,840 --> 00:08:16,320
kilobytes of JavaScript will allow you

00:08:08,610 --> 00:08:18,449
to do that we also have lazy AF from era

00:08:16,320 --> 00:08:21,870
Frost who developed this widget this

00:08:18,449 --> 00:08:23,159
module and it's providing the same the

00:08:21,870 --> 00:08:24,930
same functionality so it's pretty much

00:08:23,159 --> 00:08:27,440
depending on your own preferences which

00:08:24,930 --> 00:08:31,530
one you're going to use both of them are

00:08:27,440 --> 00:08:34,140
well developed rod level code splitting

00:08:31,530 --> 00:08:35,909
so this is something that I hope pretty

00:08:34,140 --> 00:08:37,500
much everyone is already doing it right

00:08:35,909 --> 00:08:38,610
how many of you are using crowds that

00:08:37,500 --> 00:08:42,479
will cause bleeding with the angular

00:08:38,610 --> 00:08:43,770
router right I hope I hope I will

00:08:42,479 --> 00:08:45,329
encourage you to use it even further

00:08:43,770 --> 00:08:46,470
around right now because this is

00:08:45,329 --> 00:08:49,150
probably the most efficient way to

00:08:46,470 --> 00:08:51,779
shrink your bundles

00:08:49,150 --> 00:08:54,310
with trout cooked with route level

00:08:51,779 --> 00:08:56,680
course splitting we can have our let's

00:08:54,310 --> 00:09:00,160
say in this case our article feed page

00:08:56,680 --> 00:09:02,230
our article this page so once the user

00:09:00,160 --> 00:09:03,760
opens the articles list they're only

00:09:02,230 --> 00:09:06,610
going to go they're only going to

00:09:03,760 --> 00:09:07,810
download the articles list module so the

00:09:06,610 --> 00:09:11,350
JavaScript associated with this

00:09:07,810 --> 00:09:13,150
particular page and once they navigates

00:09:11,350 --> 00:09:16,620
to settings let's say they're going to

00:09:13,150 --> 00:09:19,300
download the settings module that's it

00:09:16,620 --> 00:09:21,400
pretty simple and we can already use

00:09:19,300 --> 00:09:23,740
this in angular by using the loads

00:09:21,400 --> 00:09:26,830
children syntax the load children

00:09:23,740 --> 00:09:30,460
property in the route declaration in

00:09:26,830 --> 00:09:31,600
version 8 we want to enable more and we

00:09:30,460 --> 00:09:34,540
want to take advantage of modern

00:09:31,600 --> 00:09:37,839
standards so we want we enabled dynamic

00:09:34,540 --> 00:09:40,300
imports which can let you do pretty much

00:09:37,839 --> 00:09:45,630
the same thing but by using the years

00:09:40,300 --> 00:09:47,890
2015 module syntax dynamic import syntax

00:09:45,630 --> 00:09:50,290
but there is one problem with lazy

00:09:47,890 --> 00:09:52,029
loading it introduces some latency

00:09:50,290 --> 00:09:53,920
between navigations because the browser

00:09:52,029 --> 00:09:55,900
needs to go that go to the network

00:09:53,920 --> 00:09:58,930
downloads the associated with the page

00:09:55,900 --> 00:10:00,459
JavaScript and bootstrap it on slow

00:09:58,930 --> 00:10:02,200
networks this could be quite annoying

00:10:00,459 --> 00:10:03,910
and that's why we are actually building

00:10:02,200 --> 00:10:05,380
single page applications because we want

00:10:03,910 --> 00:10:07,390
to provide a very responsive user

00:10:05,380 --> 00:10:09,279
interface and by introducing this

00:10:07,390 --> 00:10:12,760
latency well we're not going in the

00:10:09,279 --> 00:10:16,410
right direction so here I have throw

00:10:12,760 --> 00:10:18,790
todo Network and introduced 3,000

00:10:16,410 --> 00:10:21,640
milliseconds latency so that when the

00:10:18,790 --> 00:10:23,980
user clicks on the settings page they'll

00:10:21,640 --> 00:10:26,500
have to wait for three seconds until

00:10:23,980 --> 00:10:28,120
anything gets visible so as you can see

00:10:26,500 --> 00:10:29,980
that's not ideal experience and

00:10:28,120 --> 00:10:31,150
depending on the users connection this

00:10:29,980 --> 00:10:34,959
could be the experience could be even

00:10:31,150 --> 00:10:37,839
worst that's why we have techniques such

00:10:34,959 --> 00:10:39,400
as prefetching with prefetching in the

00:10:37,839 --> 00:10:41,020
background we can download the jealous

00:10:39,400 --> 00:10:43,860
people associated with pages that we

00:10:41,020 --> 00:10:46,330
suppose that the user may need next and

00:10:43,860 --> 00:10:48,310
just after I provide them from the

00:10:46,330 --> 00:10:49,870
browser's cache once the user actually

00:10:48,310 --> 00:10:53,290
used them went once they navigate to

00:10:49,870 --> 00:10:55,029
these pages so there are different

00:10:53,290 --> 00:10:56,950
strategies for achieving prefetching or

00:10:55,029 --> 00:11:00,640
pre-loading for example in angular we

00:10:56,950 --> 00:11:02,290
have the preload o strategy which is

00:11:00,640 --> 00:11:02,769
going to preload all the different

00:11:02,290 --> 00:11:04,509
modules

00:11:02,769 --> 00:11:07,360
your application but of course if you

00:11:04,509 --> 00:11:09,279
have hundreds or even tens of module

00:11:07,360 --> 00:11:11,290
this might be not the most efficient way

00:11:09,279 --> 00:11:13,269
because you're going to drain the users

00:11:11,290 --> 00:11:16,059
data and on top of that you may even

00:11:13,269 --> 00:11:19,540
block the main UI thread so that's why

00:11:16,059 --> 00:11:21,819
we usually try to be precise in what

00:11:19,540 --> 00:11:23,649
we're prefetching we want to prefetch

00:11:21,819 --> 00:11:26,920
only what is supposed to be used next

00:11:23,649 --> 00:11:28,329
and I've noticed that as developer I

00:11:26,920 --> 00:11:30,040
usually try to guess what the user is

00:11:28,329 --> 00:11:32,139
going to use and do next

00:11:30,040 --> 00:11:34,179
similar to this wages I'm trying to put

00:11:32,139 --> 00:11:36,040
myself into the users shoes and trying

00:11:34,179 --> 00:11:38,170
to guess where the user may supposed to

00:11:36,040 --> 00:11:41,350
go but they usually don't do that

00:11:38,170 --> 00:11:44,079
exactly I think so there are a couple of

00:11:41,350 --> 00:11:47,290
more efficient prefetching heuristics

00:11:44,079 --> 00:11:48,759
that we can use instead for example we

00:11:47,290 --> 00:11:51,040
can prefetch only the visible links on

00:11:48,759 --> 00:11:53,079
the page because if the user is going to

00:11:51,040 --> 00:11:55,149
navigate somewhere it's very likely that

00:11:53,079 --> 00:11:57,910
so that they click on a visible link

00:11:55,149 --> 00:11:59,679
right we can use predictive prefetching

00:11:57,910 --> 00:12:01,809
this is something that I'm particularly

00:11:59,679 --> 00:12:04,379
excited about and I'm going to discuss

00:12:01,809 --> 00:12:07,029
in a little bit or we can prefetch a

00:12:04,379 --> 00:12:11,189
link like the JavaScript associated with

00:12:07,029 --> 00:12:13,569
a specific router link on mouse-over

00:12:11,189 --> 00:12:17,619
let's start with fetching the visible

00:12:13,569 --> 00:12:19,509
links first so let's suppose that we

00:12:17,619 --> 00:12:23,139
have this blank page which has a bunch

00:12:19,509 --> 00:12:25,119
of links we have a modern API called

00:12:23,139 --> 00:12:26,980
intersection observers which is going to

00:12:25,119 --> 00:12:29,290
allow you to observe on the elements and

00:12:26,980 --> 00:12:31,480
once this element becomes visible to a

00:12:29,290 --> 00:12:33,970
certain percentage we're going to get an

00:12:31,480 --> 00:12:35,379
event so we can perform an action so

00:12:33,970 --> 00:12:37,779
here for example we are scrolling down

00:12:35,379 --> 00:12:39,369
this page team gets visible so we're

00:12:37,779 --> 00:12:41,350
downloading The Associated JavaScript

00:12:39,369 --> 00:12:45,279
contact and the ball gets this ball as

00:12:41,350 --> 00:12:46,749
well so we do the same this is a valid

00:12:45,279 --> 00:12:48,339
pre loading strategy that you can use

00:12:46,749 --> 00:12:50,879
with the angular router to the ages by

00:12:48,339 --> 00:12:53,350
installing the NZXT quick link module

00:12:50,879 --> 00:12:55,689
right after that you need to introduce

00:12:53,350 --> 00:12:58,389
it as part of your routing configuration

00:12:55,689 --> 00:13:00,309
in your pre loading strategy and finally

00:12:58,389 --> 00:13:02,769
you need to import the quick link module

00:13:00,309 --> 00:13:05,230
from injects quick link introduced in

00:13:02,769 --> 00:13:08,139
your imports and exports in your shared

00:13:05,230 --> 00:13:09,429
module so I'll definitely encourage you

00:13:08,139 --> 00:13:11,589
to take a look at this module but

00:13:09,429 --> 00:13:12,999
sometimes it can be a little bit too

00:13:11,589 --> 00:13:15,189
aggressive in terms of prefetching as

00:13:12,999 --> 00:13:16,640
well imagine we have

00:13:15,189 --> 00:13:19,030
Wikipedia like page where

00:13:16,640 --> 00:13:21,980
from one page particular we can go to

00:13:19,030 --> 00:13:24,290
$100 so does this mean that we're going

00:13:21,980 --> 00:13:26,810
to download a hundreds JavaScript

00:13:24,290 --> 00:13:30,230
bundles this might be quite inefficient

00:13:26,810 --> 00:13:33,410
also well we may even never prefetch the

00:13:30,230 --> 00:13:35,390
actual JavaScript that the user is going

00:13:33,410 --> 00:13:38,090
to need because well the browser can

00:13:35,390 --> 00:13:40,040
just fetch maybe five or six can process

00:13:38,090 --> 00:13:43,250
five or six single origin requests per

00:13:40,040 --> 00:13:45,590
time at given point instead we can use

00:13:43,250 --> 00:13:47,840
predictive prefetching so this is

00:13:45,590 --> 00:13:50,750
related to a project that was announced

00:13:47,840 --> 00:13:52,010
on Google i/o last year by from the

00:13:50,750 --> 00:13:54,400
chrome team so we have been working with

00:13:52,010 --> 00:13:57,800
them quite actively in order to provide

00:13:54,400 --> 00:14:00,380
predictive like predictive even machine

00:13:57,800 --> 00:14:01,780
learning driven user experience which to

00:14:00,380 --> 00:14:04,520
code gasps yes

00:14:01,780 --> 00:14:06,920
basically we can consume your data from

00:14:04,520 --> 00:14:09,710
Google Analytics we can download your

00:14:06,920 --> 00:14:11,090
Google Analytics report after rats

00:14:09,710 --> 00:14:12,890
because we're getting individual pages

00:14:11,090 --> 00:14:14,870
and how the user navigates between them

00:14:12,890 --> 00:14:17,710
we need to map them to actual JavaScript

00:14:14,870 --> 00:14:21,500
bundles corresponding to your routing

00:14:17,710 --> 00:14:24,170
declaration from there we can build a

00:14:21,500 --> 00:14:26,210
Markov chain or a recurrent neural

00:14:24,170 --> 00:14:28,340
network depending on how fancy we want

00:14:26,210 --> 00:14:29,990
to be just this is just a predictive

00:14:28,340 --> 00:14:32,210
model that we can use at runtime in

00:14:29,990 --> 00:14:33,620
order to guess where user may go next so

00:14:32,210 --> 00:14:37,010
that we can prefetch the Associated

00:14:33,620 --> 00:14:38,900
JavaScript right after rats gives us

00:14:37,010 --> 00:14:41,390
bundles a tiny piece of JavaScript in

00:14:38,900 --> 00:14:43,280
your main bundle and once the users

00:14:41,390 --> 00:14:45,650
start navigating across the application

00:14:43,280 --> 00:14:48,020
we are predicting where they may go next

00:14:45,650 --> 00:14:52,730
so we go to the network prefetch this

00:14:48,020 --> 00:14:54,860
and push it into the browser's cache we

00:14:52,730 --> 00:14:57,110
can think of it in the following way we

00:14:54,860 --> 00:15:00,260
have this Wikipedia like application we

00:14:57,110 --> 00:15:01,910
have tens of links on it and based on

00:15:00,260 --> 00:15:04,580
our Google Analytics data we can rank

00:15:01,910 --> 00:15:07,400
each individual link so we can give it a

00:15:04,580 --> 00:15:10,010
cost and depending on how how high its

00:15:07,400 --> 00:15:12,860
cost we can preload only the ones which

00:15:10,010 --> 00:15:14,750
are very likely to be visited next so

00:15:12,860 --> 00:15:17,480
this is - in an early preview although

00:15:14,750 --> 00:15:20,570
we can also already give the triangular

00:15:17,480 --> 00:15:25,040
it's available on github but github.com

00:15:20,570 --> 00:15:26,630
large gets yes so yeah this means this

00:15:25,040 --> 00:15:30,130
could be some very cool things like

00:15:26,630 --> 00:15:31,900
differential loading lazy loading we're

00:15:30,130 --> 00:15:33,400
using predictive prefetching we're using

00:15:31,900 --> 00:15:35,050
some statistical models in order to

00:15:33,400 --> 00:15:38,530
predict where the user may go next based

00:15:35,050 --> 00:15:43,060
on some heuristics but in the same time

00:15:38,530 --> 00:15:45,220
if we just have a broken import we can

00:15:43,060 --> 00:15:47,530
rack half of node modules as part of our

00:15:45,220 --> 00:15:50,440
initial bundle and we can completely

00:15:47,530 --> 00:15:52,510
destroy the user experience so that is

00:15:50,440 --> 00:15:55,060
why we have performance budgets in the

00:15:52,510 --> 00:15:58,480
angular CLI the performance budgets are

00:15:55,060 --> 00:16:00,490
going to let you set constraints and set

00:15:58,480 --> 00:16:03,370
the minimum the maximum bundle size for

00:16:00,490 --> 00:16:06,310
your application so this way if your

00:16:03,370 --> 00:16:08,800
bundle size exceeds the limits that you

00:16:06,310 --> 00:16:10,480
have set your build is just going to

00:16:08,800 --> 00:16:12,610
fail and this is not going to let you

00:16:10,480 --> 00:16:14,560
proceed this is a great opportunity to

00:16:12,610 --> 00:16:17,230
introduce performance budgets as part of

00:16:14,560 --> 00:16:19,360
your CI so that you can track each

00:16:17,230 --> 00:16:21,760
individual PR and what is the cost of

00:16:19,360 --> 00:16:23,650
your PRS on top of your bundle size

00:16:21,760 --> 00:16:26,680
I'll definitely encourage you to take a

00:16:23,650 --> 00:16:29,320
look at performance budgets and we have

00:16:26,680 --> 00:16:33,180
documentation on the angular io in the

00:16:29,320 --> 00:16:35,590
build section for the CLI alright so

00:16:33,180 --> 00:16:37,090
there is one more thing that we have

00:16:35,590 --> 00:16:39,130
been working on in order to make sure

00:16:37,090 --> 00:16:42,700
that you're shipping very fast web

00:16:39,130 --> 00:16:45,190
applications we notice that there are

00:16:42,700 --> 00:16:46,810
some very low-hanging fruits that people

00:16:45,190 --> 00:16:49,900
are usually not taking taking advantage

00:16:46,810 --> 00:16:51,970
of for example more than 27% of angular

00:16:49,900 --> 00:16:54,280
applications are not using content

00:16:51,970 --> 00:16:57,390
compression for their static assets for

00:16:54,280 --> 00:16:59,980
example for SVG images or JavaScript and

00:16:57,390 --> 00:17:01,660
even higher is the percentage of angular

00:16:59,980 --> 00:17:04,900
applications which are not using CD ends

00:17:01,660 --> 00:17:07,930
and CDN is an extremely convenient way

00:17:04,900 --> 00:17:10,510
to provide your static assets from the

00:17:07,930 --> 00:17:13,030
most geographically close location to

00:17:10,510 --> 00:17:14,790
your users for example in the u.s. here

00:17:13,030 --> 00:17:17,079
if you're building application for our

00:17:14,790 --> 00:17:20,319
users in Europe we can just directly

00:17:17,079 --> 00:17:22,360
push them to the CDN edge there and our

00:17:20,319 --> 00:17:24,040
users latency is going to be much lower

00:17:22,360 --> 00:17:27,010
compared to downloading these assets

00:17:24,040 --> 00:17:29,320
from the US in order to encourage people

00:17:27,010 --> 00:17:31,480
to use these practices even further

00:17:29,320 --> 00:17:33,490
we're working very closely with cloud

00:17:31,480 --> 00:17:34,870
providers in order to provide automated

00:17:33,490 --> 00:17:38,340
deployment from the angular CLI

00:17:34,870 --> 00:17:41,290
for example this is a demo of using

00:17:38,340 --> 00:17:43,350
angular CLI with firebase with angular

00:17:41,290 --> 00:17:46,380
fire which is going to allow you to have

00:17:43,350 --> 00:17:49,289
automated deployments here we're first

00:17:46,380 --> 00:17:52,440
adding the angularfire module to angular

00:17:49,289 --> 00:17:54,750
CLI version 8 GRC this is going to

00:17:52,440 --> 00:17:56,340
download the angular fire module this is

00:17:54,750 --> 00:17:58,049
going to do some modifications in your

00:17:56,340 --> 00:18:00,030
configuration files these need to

00:17:58,049 --> 00:18:02,130
download a few other dependencies such

00:18:00,030 --> 00:18:04,799
as far these tools let's say and right

00:18:02,130 --> 00:18:06,090
after that it is going to show prompt so

00:18:04,799 --> 00:18:08,010
you can pick your firebase hosting

00:18:06,090 --> 00:18:11,520
project where you would want your

00:18:08,010 --> 00:18:14,850
application to be deployed to once you

00:18:11,520 --> 00:18:18,179
run ng run the name of your application

00:18:14,850 --> 00:18:19,559
call and deploy we're going to run the

00:18:18,179 --> 00:18:21,830
production build of your application

00:18:19,559 --> 00:18:24,270
here we're going to do all the magic of

00:18:21,830 --> 00:18:26,309
ahead of time computation we're going to

00:18:24,270 --> 00:18:29,159
do tree shaking we're going to get rid

00:18:26,309 --> 00:18:33,570
of that codes and specify your codes in

00:18:29,159 --> 00:18:34,799
a most efficient way we can once we're

00:18:33,570 --> 00:18:37,230
done with this we're going to delegate

00:18:34,799 --> 00:18:40,590
the execution to firebase so firebase is

00:18:37,230 --> 00:18:42,320
going to take your static assets and

00:18:40,590 --> 00:18:44,270
directly deploy them to firebase hosting

00:18:42,320 --> 00:18:46,620
finally we're going to provide the URL

00:18:44,270 --> 00:18:49,890
where you can preview your application

00:18:46,620 --> 00:18:51,600
directly as I mentioned we're working

00:18:49,890 --> 00:18:53,610
very closely with Google Cloud for

00:18:51,600 --> 00:18:56,340
firebase hosting we're working very

00:18:53,610 --> 00:19:00,809
closely with Asia since recently we're

00:18:56,340 --> 00:19:02,580
talking to a bio s notify and sites so

00:19:00,809 --> 00:19:04,799
we're going to provide you a way to

00:19:02,580 --> 00:19:06,929
deploy your applications to any platform

00:19:04,799 --> 00:19:09,870
convenient for you and on top of that

00:19:06,929 --> 00:19:11,820
based on the anchors Bueller's api you

00:19:09,870 --> 00:19:14,130
can implement deployments to your

00:19:11,820 --> 00:19:16,200
favorite cloud platform if there aren't

00:19:14,130 --> 00:19:20,429
already existing builders for this

00:19:16,200 --> 00:19:23,549
purpose so just a quick recap today we

00:19:20,429 --> 00:19:24,990
saw how we can reuse the bundles of your

00:19:23,549 --> 00:19:29,520
applications by using differential

00:19:24,990 --> 00:19:31,440
loading excuse me after we have to

00:19:29,520 --> 00:19:33,720
discuss how we can use lazy loading per

00:19:31,440 --> 00:19:36,240
component or routing level and how we

00:19:33,720 --> 00:19:38,280
can use be loading or prefetching by

00:19:36,240 --> 00:19:40,409
based on quick link or predictive

00:19:38,280 --> 00:19:41,789
prefetching with gauges and finally we

00:19:40,409 --> 00:19:43,559
saw how we can import deploy your

00:19:41,789 --> 00:19:45,090
applications automatically from the CLI

00:19:43,559 --> 00:19:47,190
and make sure that you're following best

00:19:45,090 --> 00:19:51,270
practices so that your users are going

00:19:47,190 --> 00:19:52,860
to get the best possible experience that

00:19:51,270 --> 00:19:53,840
was it and thank you very much for your

00:19:52,860 --> 00:19:58,840
attention

00:19:53,840 --> 00:19:58,840
[Applause]

00:20:02,780 --> 00:20:09,390
[Music]

00:20:14,970 --> 00:20:17,030

YouTube URL: https://www.youtube.com/watch?v=5VlBaaXO6ok


