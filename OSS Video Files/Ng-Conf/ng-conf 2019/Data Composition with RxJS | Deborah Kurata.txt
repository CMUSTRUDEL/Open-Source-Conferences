Title: Data Composition with RxJS | Deborah Kurata
Publication date: 2019-05-02
Playlist: ng-conf 2019
Description: 
	RxJS is one of those technologies we use every day, but there is always a bit more to learn. In this session, we focus on making our code more reactive by:
– Collecting data from a backend server using a declarative approach
– Composing data streams to handle foreign key and aggregate relationships
– Caching the streams in a service so they can be readily reused
– All without a subscription!
Join me as we get to know more about data composition with RxJS.

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:00,000 --> 00:00:03,120
[Music]

00:00:06,920 --> 00:00:10,170
[Music]

00:00:10,910 --> 00:00:18,539
good afternoon we're gonna talk about

00:00:14,790 --> 00:00:23,060
data composition with rxjs or in other

00:00:18,539 --> 00:00:23,060
words we're gonna cross some streams

00:00:24,289 --> 00:00:30,779
what our goal is for this session is to

00:00:28,170 --> 00:00:34,710
talk about a declarative approach to

00:00:30,779 --> 00:00:40,500
collecting combining and caching with

00:00:34,710 --> 00:00:47,090
rxjs streams with no subscriptions what

00:00:40,500 --> 00:00:47,090
is no subscribing mean no unsubscribing

00:00:47,510 --> 00:00:52,320
so here's our little sample application

00:00:50,219 --> 00:00:54,899
that we're going to use we've got on the

00:00:52,320 --> 00:00:56,670
left thing to pick something from and on

00:00:54,899 --> 00:00:59,250
the right the detail for whatever thing

00:00:56,670 --> 00:01:01,800
you picked you've probably used similar

00:00:59,250 --> 00:01:04,439
UIs in your application and we're going

00:01:01,800 --> 00:01:08,790
to go through how to make this app in a

00:01:04,439 --> 00:01:11,070
more reactive way so before we can get

00:01:08,790 --> 00:01:13,650
data on that page we need to collect

00:01:11,070 --> 00:01:16,200
that data so we might have seen the

00:01:13,650 --> 00:01:18,960
standard pattern that we learned way

00:01:16,200 --> 00:01:24,240
back when we started that in our service

00:01:18,960 --> 00:01:27,299
we and went too far okay in our service

00:01:24,240 --> 00:01:31,320
we have a method that gets products and

00:01:27,299 --> 00:01:34,439
that method just simply returns our HTTP

00:01:31,320 --> 00:01:37,829
GET in our component in the ng on in it

00:01:34,439 --> 00:01:40,920
we call this method we map it to some

00:01:37,829 --> 00:01:43,020
type of array or something and then we

00:01:40,920 --> 00:01:44,490
bind to that and that's the common

00:01:43,020 --> 00:01:46,860
pattern that we all learned at the

00:01:44,490 --> 00:01:48,810
beginning but there is another pattern

00:01:46,860 --> 00:01:51,479
that we can use which is much more

00:01:48,810 --> 00:01:54,439
declarative and the idea of this pattern

00:01:51,479 --> 00:01:56,939
is that we can simply use that

00:01:54,439 --> 00:01:59,640
observable stream and keep it as a

00:01:56,939 --> 00:02:01,680
stream throughout our application so

00:01:59,640 --> 00:02:04,680
here we're defining products dollar kind

00:02:01,680 --> 00:02:06,570
of the informal convention is to stick a

00:02:04,680 --> 00:02:09,030
dollar on the end if it means that it

00:02:06,570 --> 00:02:11,849
represents an observable and all we're

00:02:09,030 --> 00:02:13,780
doing is assigning it to what to our

00:02:11,849 --> 00:02:17,860
observable that's returned from an H

00:02:13,780 --> 00:02:21,370
ttp gun by doing this then we don't need

00:02:17,860 --> 00:02:23,980
the ng on a knit lifecycle hook we

00:02:21,370 --> 00:02:25,810
simply set a local property here in our

00:02:23,980 --> 00:02:28,569
component we call that products dollar

00:02:25,810 --> 00:02:32,620
as well and we set it equal to the value

00:02:28,569 --> 00:02:36,550
that's in our service okay good so far

00:02:32,620 --> 00:02:39,760
all right in our template then our

00:02:36,550 --> 00:02:41,319
template now has to bind to a I think

00:02:39,760 --> 00:02:44,319
I'm hitting that a little bit and that's

00:02:41,319 --> 00:02:50,739
making a little noise in our template

00:02:44,319 --> 00:02:56,280
then sorry one more time in our template

00:02:50,739 --> 00:02:59,319
then we bind to our observable by

00:02:56,280 --> 00:03:01,450
specifying the async pipe what is the

00:02:59,319 --> 00:03:04,080
async pipe doing for us well first of

00:03:01,450 --> 00:03:06,959
all it's automatically subscribing and

00:03:04,080 --> 00:03:10,019
best of all it's automatically

00:03:06,959 --> 00:03:12,750
unsubscribing so we don't need those

00:03:10,019 --> 00:03:14,440
gazillions of different options for

00:03:12,750 --> 00:03:16,090
unsubscribing we don't have to

00:03:14,440 --> 00:03:18,760
unsubscribe because we're never going to

00:03:16,090 --> 00:03:21,010
subscribe the other thing that the async

00:03:18,760 --> 00:03:24,489
pipe does then of course is it kicks off

00:03:21,010 --> 00:03:26,290
our request because it's subscribed so

00:03:24,489 --> 00:03:29,019
it kicks off a request it goes and gets

00:03:26,290 --> 00:03:32,260
our data it brings it back and it

00:03:29,019 --> 00:03:34,000
populates the variable so as products

00:03:32,260 --> 00:03:36,489
it's going to populate that products

00:03:34,000 --> 00:03:39,400
with that set of products and then we

00:03:36,489 --> 00:03:43,090
can use it in our template now the other

00:03:39,400 --> 00:03:46,180
really cool thing about binding directly

00:03:43,090 --> 00:03:48,810
to our observable is that we can then

00:03:46,180 --> 00:03:51,700
use the on push change detection

00:03:48,810 --> 00:03:54,730
strategy so we don't need to use the

00:03:51,700 --> 00:03:57,220
default change change detection what

00:03:54,730 --> 00:03:59,890
this means is we can minimize our change

00:03:57,220 --> 00:04:02,950
detection cycles which could have a big

00:03:59,890 --> 00:04:07,959
impact if your of view is doing lots of

00:04:02,950 --> 00:04:10,720
different things now on push then we'll

00:04:07,959 --> 00:04:14,650
only check for changes if an input

00:04:10,720 --> 00:04:17,799
variable has changed if a event is

00:04:14,650 --> 00:04:19,900
emitted using event emitter or the one

00:04:17,799 --> 00:04:23,080
that's important in this scenario if we

00:04:19,900 --> 00:04:25,720
have a bound observable that emits a

00:04:23,080 --> 00:04:27,639
value we have now bound to our

00:04:25,720 --> 00:04:30,849
observable so we can use

00:04:27,639 --> 00:04:33,250
pushed change detection strategy and it

00:04:30,849 --> 00:04:35,919
will check for changes and redisplay

00:04:33,250 --> 00:04:38,740
itself every time something is emitted

00:04:35,919 --> 00:04:41,849
from the stream ok that's an important

00:04:38,740 --> 00:04:43,810
point as we go forward here so why

00:04:41,849 --> 00:04:46,300
that's always an important question

00:04:43,810 --> 00:04:49,060
right why why would we want to do this

00:04:46,300 --> 00:04:51,400
well for one thing we can compose our

00:04:49,060 --> 00:04:53,590
streams we can merge all of the bits

00:04:51,400 --> 00:04:56,469
together that we need for a particular

00:04:53,590 --> 00:04:58,629
view we can leverage rxjs

00:04:56,469 --> 00:05:01,469
operator so that we can do things like

00:04:58,629 --> 00:05:04,629
filtering we can do things like

00:05:01,469 --> 00:05:07,689
accumulating we can improve change

00:05:04,629 --> 00:05:10,900
detection as we just saw and we can also

00:05:07,689 --> 00:05:13,960
more easily react to user actions which

00:05:10,900 --> 00:05:16,719
we'll see here in just a moment all

00:05:13,960 --> 00:05:19,539
right so that's collecting now we're

00:05:16,719 --> 00:05:24,699
into composing how do we compose our

00:05:19,539 --> 00:05:27,580
streams well and it turns out that when

00:05:24,699 --> 00:05:31,479
we get products back from our server it

00:05:27,580 --> 00:05:34,000
has a category number a category ID that

00:05:31,479 --> 00:05:36,069
comes with the product so if we look at

00:05:34,000 --> 00:05:38,139
the product data it has a category ID

00:05:36,069 --> 00:05:40,180
and we could just display that to the

00:05:38,139 --> 00:05:44,529
user and hope they know what a category

00:05:40,180 --> 00:05:46,870
3 means or a category 47 or whatever but

00:05:44,529 --> 00:05:50,229
it would be much nicer if we also

00:05:46,870 --> 00:05:53,229
retrieved a lookup table and brought

00:05:50,229 --> 00:05:56,379
that down so we collected the product

00:05:53,229 --> 00:05:58,900
category data and brought that down so

00:05:56,379 --> 00:06:01,270
we could instead display the category is

00:05:58,900 --> 00:06:04,060
toolbox which would be much more user

00:06:01,270 --> 00:06:06,909
friendly so how do we go about doing

00:06:04,060 --> 00:06:09,039
that well the code to actually get that

00:06:06,909 --> 00:06:11,229
is going to be the same that we just

00:06:09,039 --> 00:06:13,500
looked at for our product we have our

00:06:11,229 --> 00:06:16,089
product categories we are getting

00:06:13,500 --> 00:06:19,779
setting it equal to our the result of

00:06:16,089 --> 00:06:22,479
our HTTP GET easy enough all right

00:06:19,779 --> 00:06:25,419
then we are going to use combined latest

00:06:22,479 --> 00:06:27,789
and we're going to combine those two

00:06:25,419 --> 00:06:30,009
streams so we're going to combine our

00:06:27,789 --> 00:06:33,279
product stream which has our products

00:06:30,009 --> 00:06:36,550
with our product category stream so that

00:06:33,279 --> 00:06:39,460
the code underneath this has both sets

00:06:36,550 --> 00:06:43,700
of data to work with

00:06:39,460 --> 00:06:47,150
okay so combine latest combines multiple

00:06:43,700 --> 00:06:50,030
streams into a new stream it uses the

00:06:47,150 --> 00:06:53,810
last emitted value from each stream and

00:06:50,030 --> 00:06:56,000
it won't emit anything until all of the

00:06:53,810 --> 00:06:59,030
streams listed and combined latest have

00:06:56,000 --> 00:07:01,070
emitted at least once so the other nice

00:06:59,030 --> 00:07:04,190
thing about this is it's going to sort

00:07:01,070 --> 00:07:05,690
of wait for us so if you ever had code

00:07:04,190 --> 00:07:08,150
that you were written in that you want

00:07:05,690 --> 00:07:10,070
to get some product data and then you

00:07:08,150 --> 00:07:12,140
sort of want and you want to get the

00:07:10,070 --> 00:07:13,700
category data and you want it to wait to

00:07:12,140 --> 00:07:16,310
get both of those before it does

00:07:13,700 --> 00:07:21,290
something combined latest will do that

00:07:16,310 --> 00:07:25,310
for you it then emits an array that

00:07:21,290 --> 00:07:27,170
looks like this look they're pointing

00:07:25,310 --> 00:07:32,330
over here can you see that right there

00:07:27,170 --> 00:07:34,790
so it emits an array the first element

00:07:32,330 --> 00:07:38,240
of that array is the result of that

00:07:34,790 --> 00:07:40,340
first stream that you pass in so with

00:07:38,240 --> 00:07:43,580
this products it's going to be an array

00:07:40,340 --> 00:07:45,830
of products the second element of that

00:07:43,580 --> 00:07:48,410
array is the result of the second

00:07:45,830 --> 00:07:51,830
argument that you pass in to the combine

00:07:48,410 --> 00:07:54,860
latest if you add a third one it would

00:07:51,830 --> 00:07:57,890
be providing that as well and so the

00:07:54,860 --> 00:08:00,500
combined latest emits this array to the

00:07:57,890 --> 00:08:03,680
rest of our code here so we can

00:08:00,500 --> 00:08:05,870
establish a pipeline that uses both of

00:08:03,680 --> 00:08:08,330
these things so that we can do the

00:08:05,870 --> 00:08:11,000
mapping between them what does that look

00:08:08,330 --> 00:08:12,729
like well here's my map the first thing

00:08:11,000 --> 00:08:15,890
I'm doing is I'm using a raid

00:08:12,729 --> 00:08:18,890
destructuring in my map so that I can

00:08:15,890 --> 00:08:21,560
assign a name to each of the elements of

00:08:18,890 --> 00:08:23,419
the array so the thing in that first

00:08:21,560 --> 00:08:25,790
element of the array which happens to be

00:08:23,419 --> 00:08:27,860
my array of products I'm assigning to be

00:08:25,790 --> 00:08:30,110
products and then categories for the

00:08:27,860 --> 00:08:35,030
second element to make it easier to work

00:08:30,110 --> 00:08:37,729
with then I have whatever other code

00:08:35,030 --> 00:08:40,099
that I need to do my mapping in my case

00:08:37,729 --> 00:08:42,530
I'm using the arrays map method because

00:08:40,099 --> 00:08:43,700
now my products is an array so I'm using

00:08:42,530 --> 00:08:46,700
the array map

00:08:43,700 --> 00:08:49,310
I'm taking my existing product that I

00:08:46,700 --> 00:08:50,180
got from the server that has my category

00:08:49,310 --> 00:08:53,450
idea

00:08:50,180 --> 00:08:55,610
it and I am using the spread operator to

00:08:53,450 --> 00:08:59,060
copy it over so now I have a copy of it

00:08:55,610 --> 00:09:01,760
and I'm adding then a category property

00:08:59,060 --> 00:09:04,420
and doing the mapping you with the find

00:09:01,760 --> 00:09:07,970
to find the name for that ID

00:09:04,420 --> 00:09:10,339
lastly I'm telling it hey I really want

00:09:07,970 --> 00:09:12,470
this to be a product so what comes out

00:09:10,339 --> 00:09:15,500
of here what's emitted out of here is

00:09:12,470 --> 00:09:18,620
going to be a product array just like

00:09:15,500 --> 00:09:21,230
products dollar would which is exactly

00:09:18,620 --> 00:09:24,980
what my UI wants only now it has this

00:09:21,230 --> 00:09:27,320
extra property called category in the

00:09:24,980 --> 00:09:29,120
component then I just change it instead

00:09:27,320 --> 00:09:31,580
of saying this dot product service dot

00:09:29,120 --> 00:09:34,250
products it's this dot product service

00:09:31,580 --> 00:09:36,410
dot products with category and that's

00:09:34,250 --> 00:09:38,810
then I don't have to change my UI

00:09:36,410 --> 00:09:44,360
because it's already binding to products

00:09:38,810 --> 00:09:47,529
dollar ok alrighty so we end up with our

00:09:44,360 --> 00:09:50,600
category of toolbox so much nicer now

00:09:47,529 --> 00:09:53,060
when we build user interfaces they're

00:09:50,600 --> 00:09:55,100
interactive right otherwise it's not an

00:09:53,060 --> 00:09:57,980
application if it's just a static page

00:09:55,100 --> 00:10:00,350
so we also need to be able to react to

00:09:57,980 --> 00:10:02,540
user changes for example when the user

00:10:00,350 --> 00:10:04,970
clicks on hammer we want to display the

00:10:02,540 --> 00:10:06,890
detail for hammer when the user clicks

00:10:04,970 --> 00:10:10,550
on saw we want to display the details

00:10:06,890 --> 00:10:16,520
for saw so how do we deal with that

00:10:10,550 --> 00:10:19,580
selection we want to be able to combine

00:10:16,520 --> 00:10:23,980
our streams such that they can react to

00:10:19,580 --> 00:10:26,860
user actions how do we do that

00:10:23,980 --> 00:10:29,959
there are three steps that we can follow

00:10:26,860 --> 00:10:31,490
to make our code react to changes when

00:10:29,959 --> 00:10:34,100
we're following this declarative

00:10:31,490 --> 00:10:36,290
approach first of all we create a new

00:10:34,100 --> 00:10:38,329
stream that I call an action stream

00:10:36,290 --> 00:10:40,040
thanks to someone on Twitter I was

00:10:38,329 --> 00:10:42,890
trying to find a good name for it and an

00:10:40,040 --> 00:10:45,200
action stream seemed perfect we need to

00:10:42,890 --> 00:10:48,290
combine our action stream with our data

00:10:45,200 --> 00:10:50,690
stream and then every time that action

00:10:48,290 --> 00:10:53,270
occurs we need to emit something into

00:10:50,690 --> 00:10:55,160
that action stream ok so those are our

00:10:53,270 --> 00:10:58,970
three steps let's walk through how to do

00:10:55,160 --> 00:11:02,360
those first of all we create our action

00:10:58,970 --> 00:11:03,950
stream so we do that using a subject or

00:11:02,360 --> 00:11:07,880
behavior subject or some

00:11:03,950 --> 00:11:10,010
things similar what is a subject what's

00:11:07,880 --> 00:11:13,190
a behavior subject well a subject is

00:11:10,010 --> 00:11:15,260
just a special type of observable and a

00:11:13,190 --> 00:11:17,780
behavior subject is a special type of

00:11:15,260 --> 00:11:20,660
subject the only difference between

00:11:17,780 --> 00:11:23,660
subject and behavior subject is behavior

00:11:20,660 --> 00:11:26,060
subject takes in a default value so when

00:11:23,660 --> 00:11:28,640
you call the constructor new behavior

00:11:26,060 --> 00:11:33,140
subject you have to pass something in as

00:11:28,640 --> 00:11:36,230
a default initial value the other

00:11:33,140 --> 00:11:38,470
primary difference oh wait okay I'm

00:11:36,230 --> 00:11:41,900
gonna stop my talk then right now and

00:11:38,470 --> 00:11:43,880
can you back over there can you call me

00:11:41,900 --> 00:11:47,000
I'm gonna give the rest of my talk just

00:11:43,880 --> 00:11:48,940
to you and if someone over here if you

00:11:47,000 --> 00:11:54,110
could call me I'm gonna give my talk

00:11:48,940 --> 00:11:57,580
just to you that would be unicast right

00:11:54,110 --> 00:12:01,460
that's how our observables work our UI

00:11:57,580 --> 00:12:05,540
subscribes to that observable and at

00:12:01,460 --> 00:12:08,950
that point it fires all emits all of its

00:12:05,540 --> 00:12:11,240
stuff directly to that one subscriber

00:12:08,950 --> 00:12:13,490
the difference between a subject

00:12:11,240 --> 00:12:16,400
behavior subject and a normal type of

00:12:13,490 --> 00:12:18,260
observable is it's multicast it's what

00:12:16,400 --> 00:12:20,570
allows me to talk to all of you all at

00:12:18,260 --> 00:12:23,720
the same time otherwise it wouldn't be

00:12:20,570 --> 00:12:26,000
very efficient all right the other big

00:12:23,720 --> 00:12:28,550
difference between a subject behavior

00:12:26,000 --> 00:12:32,450
subject and an observable is that a

00:12:28,550 --> 00:12:36,700
subject can be both an observable and an

00:12:32,450 --> 00:12:39,170
observer what does that mean well

00:12:36,700 --> 00:12:42,380
subject can behave like an observable

00:12:39,170 --> 00:12:45,620
stream it can emit values but it also

00:12:42,380 --> 00:12:49,460
can behave like an observer an observer

00:12:45,620 --> 00:12:51,440
is that piece of code that we pass in to

00:12:49,460 --> 00:12:53,600
our streams on a subscribe when we do it

00:12:51,440 --> 00:12:58,310
the old-fashioned way on a subscribe we

00:12:53,600 --> 00:13:01,550
pass it in a object that basically says

00:12:58,310 --> 00:13:03,980
I'm going to watch the stream and this

00:13:01,550 --> 00:13:05,480
is what I want to do on next this is

00:13:03,980 --> 00:13:09,490
what I want to do if an error occurs

00:13:05,480 --> 00:13:14,960
this is what I want to do if when the

00:13:09,490 --> 00:13:17,450
stream completes so a subject behavior

00:13:14,960 --> 00:13:19,280
subject acts both as an observer

00:13:17,450 --> 00:13:22,160
and has these next air and complete

00:13:19,280 --> 00:13:25,400
methods okay so the second step now that

00:13:22,160 --> 00:13:28,490
we've got our I let's go back a second

00:13:25,400 --> 00:13:30,410
there now that we have our action stream

00:13:28,490 --> 00:13:32,980
created there it is product selected

00:13:30,410 --> 00:13:36,200
action and notice that it's a number

00:13:32,980 --> 00:13:38,480
okay so we want to be every time a

00:13:36,200 --> 00:13:41,560
product is selected we want the product

00:13:38,480 --> 00:13:46,190
ID that number emitted into the stream

00:13:41,560 --> 00:13:50,360
okay well I'm pointing my thing at that

00:13:46,190 --> 00:13:52,310
like that's an idiot all right so anyway

00:13:50,360 --> 00:13:54,320
alright so now I'm combining my streams

00:13:52,310 --> 00:13:56,390
this time though I'm combining my action

00:13:54,320 --> 00:13:58,550
stream which is my number it's my

00:13:56,390 --> 00:14:01,490
product idea of the one the user picked

00:13:58,550 --> 00:14:04,310
with my products with category because I

00:14:01,490 --> 00:14:08,060
want my detail to also have that

00:14:04,310 --> 00:14:09,800
category string available I'm again

00:14:08,060 --> 00:14:11,570
using a map I'm using a ray

00:14:09,800 --> 00:14:14,030
destructuring again for the two

00:14:11,570 --> 00:14:16,130
different streams and then I'm using a

00:14:14,030 --> 00:14:19,520
fine to find the product that they

00:14:16,130 --> 00:14:22,400
requested and then this thing emits a

00:14:19,520 --> 00:14:24,560
new product and what happens to the UI

00:14:22,400 --> 00:14:28,760
when we emit something in the stream

00:14:24,560 --> 00:14:32,300
it's going to update the UI by the on

00:14:28,760 --> 00:14:34,310
push change detection okay so how do we

00:14:32,300 --> 00:14:36,470
kick this whole thing off well our third

00:14:34,310 --> 00:14:38,900
step our first step again was to create

00:14:36,470 --> 00:14:41,360
our action stream second step was to

00:14:38,900 --> 00:14:44,510
merge the streams third step is to make

00:14:41,360 --> 00:14:47,600
sure we're emitting these actions so our

00:14:44,510 --> 00:14:50,390
when the user clicks that click is tied

00:14:47,600 --> 00:14:52,790
is bound to a non selected method and

00:14:50,390 --> 00:14:55,280
our component which is calling a method

00:14:52,790 --> 00:14:58,090
in our service and that method in our

00:14:55,280 --> 00:15:01,600
service executes the next method which

00:14:58,090 --> 00:15:06,350
throws out emits that next product ID

00:15:01,600 --> 00:15:09,770
and that causes it to re execute our

00:15:06,350 --> 00:15:13,130
pipeline so I have it kind of Anna

00:15:09,770 --> 00:15:15,320
marble diagram ish way my first line

00:15:13,130 --> 00:15:18,020
there is representing our first stream

00:15:15,320 --> 00:15:21,670
which is our array of products the

00:15:18,020 --> 00:15:24,320
second stream is representing the

00:15:21,670 --> 00:15:26,810
actions so my first action the user

00:15:24,320 --> 00:15:31,010
clicked on the fund the product with an

00:15:26,810 --> 00:15:33,170
ID of one recall that I said that was

00:15:31,010 --> 00:15:36,530
buying latest it won't aim it until both

00:15:33,170 --> 00:15:40,670
streams have emitted so now I've got in

00:15:36,530 --> 00:15:43,280
my code a saw a rake and acts in array

00:15:40,670 --> 00:15:46,450
and then the one then when the user

00:15:43,280 --> 00:15:49,760
clicks on something else I get another

00:15:46,450 --> 00:15:52,790
ID in the action stream which causes the

00:15:49,760 --> 00:15:58,790
combine latest to re-emit and then I can

00:15:52,790 --> 00:16:03,650
process that data ok caching when I

00:15:58,790 --> 00:16:05,570
first get the data for the page I have

00:16:03,650 --> 00:16:07,130
it displayed here you can't really see

00:16:05,570 --> 00:16:10,370
it display but the idea is that I'm

00:16:07,130 --> 00:16:16,930
getting all that data when I when my

00:16:10,370 --> 00:16:19,340
user interface this async pipe actually

00:16:16,930 --> 00:16:21,950
subscribes and then I get that data down

00:16:19,340 --> 00:16:24,590
if the user then moves somewhere else

00:16:21,950 --> 00:16:26,960
like to the home page and comes back

00:16:24,590 --> 00:16:28,700
it's gonna do it all again so I've got

00:16:26,960 --> 00:16:30,860
two of these where it went out and got

00:16:28,700 --> 00:16:33,860
all that data again wouldn't it be

00:16:30,860 --> 00:16:38,570
better if we cashed it and yes we can

00:16:33,860 --> 00:16:39,980
cache the array so this is kind of a way

00:16:38,570 --> 00:16:43,580
that we might have learned to have done

00:16:39,980 --> 00:16:45,410
it we just cache it into our service and

00:16:43,580 --> 00:16:47,380
then we can share it but the problem

00:16:45,410 --> 00:16:50,150
with this is we've just lost our streams

00:16:47,380 --> 00:16:52,520
so what we instead want to do is use

00:16:50,150 --> 00:16:54,890
something like share replay and what

00:16:52,520 --> 00:16:56,860
share replay does is it shares the

00:16:54,890 --> 00:17:00,140
observable with all of the subscribers

00:16:56,860 --> 00:17:04,250
so the next time that the user comes to

00:17:00,140 --> 00:17:07,970
the page it just reads the values that

00:17:04,250 --> 00:17:10,550
it already has ok the last thing that I

00:17:07,970 --> 00:17:16,100
want to cover then is observable all of

00:17:10,550 --> 00:17:17,959
the things our page our page on the

00:17:16,100 --> 00:17:19,240
right there our detail page has more

00:17:17,959 --> 00:17:22,370
than just product and category

00:17:19,240 --> 00:17:24,890
information on it it also has a list of

00:17:22,370 --> 00:17:28,640
suppliers and it has a header at the top

00:17:24,890 --> 00:17:32,570
that is also adjusting for each product

00:17:28,640 --> 00:17:35,270
that's displayed so lets observable

00:17:32,570 --> 00:17:37,580
those things as well so here we can do

00:17:35,270 --> 00:17:40,700
in our component we can make our page

00:17:37,580 --> 00:17:43,950
title adjust automatically every time

00:17:40,700 --> 00:17:46,980
the user picks a new product by used

00:17:43,950 --> 00:17:49,560
the product dollar observable and piping

00:17:46,980 --> 00:17:54,480
it transforming it with the map from a

00:17:49,560 --> 00:17:56,760
product stream into a string and then

00:17:54,480 --> 00:17:58,620
for our product suppliers we can do

00:17:56,760 --> 00:18:01,590
something similar to be did with the

00:17:58,620 --> 00:18:05,040
categories and the products and we can

00:18:01,590 --> 00:18:10,050
define that as a stream then we can

00:18:05,040 --> 00:18:12,480
merge all the streams using this code so

00:18:10,050 --> 00:18:14,280
we're going to use combined latest and

00:18:12,480 --> 00:18:17,310
we're going to merge all of the streams

00:18:14,280 --> 00:18:19,590
required for our UI so we've got the

00:18:17,310 --> 00:18:23,070
product detail the products suppliers

00:18:19,590 --> 00:18:25,590
and the page title and notice the

00:18:23,070 --> 00:18:31,860
variable I'm using there VM dollar is

00:18:25,590 --> 00:18:34,110
that feel retro angular one ish so what

00:18:31,860 --> 00:18:35,940
we're doing then is we are taking all of

00:18:34,110 --> 00:18:38,070
that and piping it through first a

00:18:35,940 --> 00:18:40,410
filter and we're piping it through this

00:18:38,070 --> 00:18:43,140
filter because when the page first comes

00:18:40,410 --> 00:18:45,630
up the user has not selected anything

00:18:43,140 --> 00:18:49,020
there is no product and we are filtering

00:18:45,630 --> 00:18:51,870
out and jumping out of the code if there

00:18:49,020 --> 00:18:54,420
is no product to process if there is a

00:18:51,870 --> 00:18:57,210
product then we do this map we're again

00:18:54,420 --> 00:18:59,160
using a ray destructuring what we're

00:18:57,210 --> 00:19:01,680
doing in this case is we're converting

00:18:59,160 --> 00:19:04,340
an array with three elements to an

00:19:01,680 --> 00:19:07,170
object literal with three properties

00:19:04,340 --> 00:19:10,440
because that makes it easier for our

00:19:07,170 --> 00:19:12,990
template to work with the values then

00:19:10,440 --> 00:19:15,990
because we've taken every stream that

00:19:12,990 --> 00:19:20,060
our view needs and put it into one our

00:19:15,990 --> 00:19:22,440
template only needs one async pipe and

00:19:20,060 --> 00:19:24,990
every time the user picks something

00:19:22,440 --> 00:19:27,630
different in our list component our

00:19:24,990 --> 00:19:30,390
detail component will adjust accordingly

00:19:27,630 --> 00:19:32,880
and here we access each one of the

00:19:30,390 --> 00:19:39,240
properties page title product and

00:19:32,880 --> 00:19:40,920
product suppliers so what do we think is

00:19:39,240 --> 00:19:43,320
this something that we might want to try

00:19:40,920 --> 00:19:44,670
is it something we're already doing is

00:19:43,320 --> 00:19:47,990
anybody doing this technique now

00:19:44,670 --> 00:19:49,950
something like this Oh quite a few yay

00:19:47,990 --> 00:19:51,480
for those of you who didn't raise your

00:19:49,950 --> 00:19:55,560
hand this is something you might want to

00:19:51,480 --> 00:19:57,389
look at okay just a few cons to know

00:19:55,560 --> 00:20:00,509
about picking the right opera

00:19:57,389 --> 00:20:03,359
is not always easy and sometimes it is

00:20:00,509 --> 00:20:05,729
difficult to debug observables but look

00:20:03,359 --> 00:20:07,499
at all of the pros we've got lots of

00:20:05,729 --> 00:20:11,070
good things that we can be doing with

00:20:07,499 --> 00:20:14,309
that composable streams sharing

00:20:11,070 --> 00:20:16,649
observables relatively easily and I

00:20:14,309 --> 00:20:17,459
won't mention the second to the last one

00:20:16,649 --> 00:20:25,769
here out loud

00:20:17,459 --> 00:20:28,139
and uh sorry uh Brandon um so with that

00:20:25,769 --> 00:20:31,499
I want to give you links to the slides

00:20:28,139 --> 00:20:35,419
to the code and my Twitter thank you all

00:20:31,499 --> 00:20:35,419
very much thank you

00:20:41,280 --> 00:20:47,900
[Music]

00:20:53,470 --> 00:20:55,530

YouTube URL: https://www.youtube.com/watch?v=Z76QlSpYcck


