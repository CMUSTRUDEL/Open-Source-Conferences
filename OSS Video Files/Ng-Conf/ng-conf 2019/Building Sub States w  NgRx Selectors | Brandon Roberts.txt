Title: Building Sub States w  NgRx Selectors | Brandon Roberts
Publication date: 2019-05-07
Playlist: ng-conf 2019
Description: 
	NgRx provides Angular developers a framework for managing your application state in a reactive way. Actions provide an expressive way to manage state and trigger state changes, along with immutability enforced by reducers as pure functions. One of the real advantages of NgRx comes in the form of selectors. Selectors provide simple but powerful ways to efficiently get, derive, and compose view models for your application. This talk takes a deeper look at NgRx selectors, with examples and advanced features such as memoization and custom selectors.

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:07,920 --> 00:00:11,170
[Music]

00:00:12,019 --> 00:00:18,570
okay so this is a building substates

00:00:15,000 --> 00:00:20,520
with angelic selectors my name is

00:00:18,570 --> 00:00:22,560
Brandon Roberts you can find me on

00:00:20,520 --> 00:00:24,660
twitter at brandon t roberts i tweet out

00:00:22,560 --> 00:00:26,250
for any gifts i talk about sports and I

00:00:24,660 --> 00:00:29,060
block people sometimes you know cuz

00:00:26,250 --> 00:00:32,279
that's just how it works

00:00:29,060 --> 00:00:35,370
I'm a developer and technical writer on

00:00:32,279 --> 00:00:38,640
the angular team and also a maintainer

00:00:35,370 --> 00:00:41,730
on the njx project so if you're not

00:00:38,640 --> 00:00:44,309
familiar with what in Jurek's is index

00:00:41,730 --> 00:00:46,200
was founded by Rob Wormald with the

00:00:44,309 --> 00:00:48,570
purpose of providing open source

00:00:46,200 --> 00:00:49,850
libraries for angular with reactivity in

00:00:48,570 --> 00:00:52,469
mind

00:00:49,850 --> 00:00:54,510
its primary libraries handle state

00:00:52,469 --> 00:00:56,699
management of course and side effects

00:00:54,510 --> 00:00:59,539
with additional libraries for handling

00:00:56,699 --> 00:01:03,539
collections router integration and

00:00:59,539 --> 00:01:05,880
schematics it's a community driven

00:01:03,539 --> 00:01:07,770
project so if you want to get involved

00:01:05,880 --> 00:01:12,180
we always welcome contributions with

00:01:07,770 --> 00:01:19,350
those be issues or Docs or code or tests

00:01:12,180 --> 00:01:21,360
or anything like that so so let's get in

00:01:19,350 --> 00:01:23,640
what we want to talk about today the

00:01:21,360 --> 00:01:25,530
selectors and when they examine the use

00:01:23,640 --> 00:01:28,829
and the flexibility of selectors provide

00:01:25,530 --> 00:01:30,659
with you for I for you in in grx so we

00:01:28,829 --> 00:01:31,820
talked about kind of like what they are

00:01:30,659 --> 00:01:38,070
the why and the how

00:01:31,820 --> 00:01:39,930
with selectors so you've probably seen

00:01:38,070 --> 00:01:41,880
this before but I'm contractually

00:01:39,930 --> 00:01:44,490
obligated to show you this this site

00:01:41,880 --> 00:01:47,159
this very active cycle every time to

00:01:44,490 --> 00:01:49,829
talk about ng rx because you know it's a

00:01:47,159 --> 00:01:52,799
cycle of state changes and reducers and

00:01:49,829 --> 00:01:54,540
selectors and selectors represent the

00:01:52,799 --> 00:01:57,119
the purple line on the right side of the

00:01:54,540 --> 00:02:01,770
screen here so selectors are what binds

00:01:57,119 --> 00:02:03,930
your global state to your components so

00:02:01,770 --> 00:02:06,329
index is using a lot of plates a lot of

00:02:03,930 --> 00:02:08,160
places and that's pretty cool you know

00:02:06,329 --> 00:02:11,030
if I say so myself but you know if ax

00:02:08,160 --> 00:02:13,390
people how they're using directs and

00:02:11,030 --> 00:02:15,730
specifically about selectors and

00:02:13,390 --> 00:02:19,030
kind of made me take a step back the one

00:02:15,730 --> 00:02:21,100
quote that stuck out to me was I don't

00:02:19,030 --> 00:02:25,959
know how they work I just used them and

00:02:21,100 --> 00:02:31,090
so it made me pause so I took a step

00:02:25,959 --> 00:02:34,320
back and I was like what okay so I guess

00:02:31,090 --> 00:02:34,320
we've got some more work to do there

00:02:34,410 --> 00:02:39,640
so slate as I mentioned selectors are

00:02:37,330 --> 00:02:42,130
responsible for combining and composing

00:02:39,640 --> 00:02:45,670
data for your components whether they be

00:02:42,130 --> 00:02:49,989
simple or complex just depends on the

00:02:45,670 --> 00:02:52,300
view model you need to create but at a

00:02:49,989 --> 00:02:54,459
simple simple explanation is they're

00:02:52,300 --> 00:02:57,610
just functions with a little caveat of

00:02:54,459 --> 00:02:59,980
mostly they get passed in global state

00:02:57,610 --> 00:03:02,190
and return a smaller or composed piece

00:02:59,980 --> 00:03:04,810
of state based on what your needs are

00:03:02,190 --> 00:03:07,239
it's the additional functionality that

00:03:04,810 --> 00:03:10,510
is provided within grx that makes them

00:03:07,239 --> 00:03:13,530
shine so let's walk through a simple

00:03:10,510 --> 00:03:16,420
selector and then we'll go more in-depth

00:03:13,530 --> 00:03:17,709
so here's just a selector function that

00:03:16,420 --> 00:03:20,380
as I mentioned before is a receiving

00:03:17,709 --> 00:03:24,010
global state and returning the list

00:03:20,380 --> 00:03:25,959
movies movie state I'm referring to

00:03:24,010 --> 00:03:27,910
state here in the argument as the entire

00:03:25,959 --> 00:03:31,720
state object to just illustrate how

00:03:27,910 --> 00:03:33,519
we're picking off properties so it's

00:03:31,720 --> 00:03:37,060
pretty straightforward colonists

00:03:33,519 --> 00:03:38,620
function does what you'd expect you pass

00:03:37,060 --> 00:03:41,590
in a state and you get a movie state out

00:03:38,620 --> 00:03:43,780
if you compare this to reducers are

00:03:41,590 --> 00:03:48,220
they're pure in that for any given input

00:03:43,780 --> 00:03:50,290
the output is always the same so let's

00:03:48,220 --> 00:03:51,790
take it a step further and say you have

00:03:50,290 --> 00:03:54,340
a movie state that has a collection of

00:03:51,790 --> 00:03:56,980
entities so what do you do do you you

00:03:54,340 --> 00:03:59,829
don't provide a selector function that

00:03:56,980 --> 00:04:01,690
map's each property in the object state

00:03:59,829 --> 00:04:04,269
you can use a selector function to pick

00:04:01,690 --> 00:04:07,900
off entities from the result that you

00:04:04,269 --> 00:04:09,730
already had from the movie state so what

00:04:07,900 --> 00:04:12,880
we're doing is combining these functions

00:04:09,730 --> 00:04:14,530
together to produce movie entities we

00:04:12,880 --> 00:04:17,950
call the movie state function first and

00:04:14,530 --> 00:04:19,750
pass its result to the Select movies so

00:04:17,950 --> 00:04:22,270
you what you end up with is a value from

00:04:19,750 --> 00:04:24,400
the state object so you start with

00:04:22,270 --> 00:04:25,610
global state and we end over the

00:04:24,400 --> 00:04:28,460
entities

00:04:25,610 --> 00:04:32,449
so selective functions are predictable

00:04:28,460 --> 00:04:34,340
and consistent so just to drive that

00:04:32,449 --> 00:04:36,860
home selectors are at their simplest

00:04:34,340 --> 00:04:44,229
level just retrieving properties from

00:04:36,860 --> 00:04:47,270
your state you can also use selectors to

00:04:44,229 --> 00:04:48,860
combine them together and this is where

00:04:47,270 --> 00:04:51,650
the create selector function comes in

00:04:48,860 --> 00:04:53,330
and there are a few there are a couple

00:04:51,650 --> 00:04:57,099
key things that enhance the selectors

00:04:53,330 --> 00:04:59,300
and they deal directly with performance

00:04:57,099 --> 00:05:02,240
so the first one is that when you create

00:04:59,300 --> 00:05:04,219
a selector the selector is tracking its

00:05:02,240 --> 00:05:07,250
are its input arguments each time is

00:05:04,219 --> 00:05:09,889
called so while why would you want to do

00:05:07,250 --> 00:05:11,780
that because computations are expensive

00:05:09,889 --> 00:05:14,629
especially if you're dealing with large

00:05:11,780 --> 00:05:17,000
data sets so you don't want to recompute

00:05:14,629 --> 00:05:21,500
these derivate state derivations on our

00:05:17,000 --> 00:05:24,469
state changes so each time a state

00:05:21,500 --> 00:05:26,509
change happens is tracking the inputs

00:05:24,469 --> 00:05:31,069
for a selector to see if they've changed

00:05:26,509 --> 00:05:33,680
or not so to just illustrate this as a

00:05:31,069 --> 00:05:38,150
timeline we can go through say that

00:05:33,680 --> 00:05:40,879
state change no inputs change it goes to

00:05:38,150 --> 00:05:44,990
our selector and just returns the

00:05:40,879 --> 00:05:47,229
previous value if there conversely if

00:05:44,990 --> 00:05:50,029
there are if the inputs do change it

00:05:47,229 --> 00:05:53,650
goes to the selector again but this time

00:05:50,029 --> 00:05:58,400
it computes a new value and returns that

00:05:53,650 --> 00:06:02,750
there's another added benefit as the

00:05:58,400 --> 00:06:04,699
selectors are memorized so again we

00:06:02,750 --> 00:06:07,190
talked about I don't know how they work

00:06:04,699 --> 00:06:09,979
so you know what is what does that

00:06:07,190 --> 00:06:13,310
actually mean how does that help me with

00:06:09,979 --> 00:06:15,860
performance and just to give you a

00:06:13,310 --> 00:06:18,020
little hint I hope you like state

00:06:15,860 --> 00:06:20,900
management so I put some well state

00:06:18,020 --> 00:06:23,389
management in your state management memo

00:06:20,900 --> 00:06:25,729
I selectors maintain the state of the

00:06:23,389 --> 00:06:28,190
last value so even if your inputs change

00:06:25,729 --> 00:06:32,000
and it produces the same result the

00:06:28,190 --> 00:06:35,089
current value is returned so going back

00:06:32,000 --> 00:06:37,639
to selecting multiple sets of data such

00:06:35,089 --> 00:06:40,009
as users books and the current users

00:06:37,639 --> 00:06:41,659
these values could change but since

00:06:40,009 --> 00:06:43,819
we're working with shared data the

00:06:41,659 --> 00:06:46,669
selector could produce the same result

00:06:43,819 --> 00:06:48,469
when compared so we're returning the

00:06:46,669 --> 00:06:53,389
same reference and no changes would need

00:06:48,469 --> 00:06:56,270
to be triggered so looking at another

00:06:53,389 --> 00:06:57,669
example of book views this allows you to

00:06:56,270 --> 00:06:59,620
scope down views that are

00:06:57,669 --> 00:07:02,180
computationally expensive

00:06:59,620 --> 00:07:04,759
here I'm using a dictionary of authors

00:07:02,180 --> 00:07:07,460
and an array of books to map those two

00:07:04,759 --> 00:07:10,009
together as opposed to filtering through

00:07:07,460 --> 00:07:12,529
an author in each author in an array I

00:07:10,009 --> 00:07:17,409
can just directly pick off the author

00:07:12,529 --> 00:07:20,680
from the entities so the second point is

00:07:17,409 --> 00:07:27,919
selectors track inputs and leverage

00:07:20,680 --> 00:07:29,810
memorization for performance so in the

00:07:27,919 --> 00:07:31,849
previous demo we talked about picking

00:07:29,810 --> 00:07:35,029
off properties to get the movie state

00:07:31,849 --> 00:07:37,310
and movie entities so that was a pretty

00:07:35,029 --> 00:07:40,449
straightforward example but selectors

00:07:37,310 --> 00:07:44,810
can't be inputs to other selectors so

00:07:40,449 --> 00:07:46,190
here I have two examples here one is

00:07:44,810 --> 00:07:47,270
just a selector function that I

00:07:46,190 --> 00:07:49,310
mentioned before that's getting a

00:07:47,270 --> 00:07:53,389
property ID that's returning an active

00:07:49,310 --> 00:07:55,940
moving ID and then without any another

00:07:53,389 --> 00:07:58,729
project the index entity gives you some

00:07:55,940 --> 00:08:00,800
selectors out of the box so I'm using

00:07:58,729 --> 00:08:02,839
the active movie ID and the selectors to

00:08:00,800 --> 00:08:07,699
select the entities that I want to

00:08:02,839 --> 00:08:10,509
create or create a new view out of so

00:08:07,699 --> 00:08:15,020
combining these selectors together is

00:08:10,509 --> 00:08:19,039
not much issue at all a new selector is

00:08:15,020 --> 00:08:21,550
a new selector is a combination of those

00:08:19,039 --> 00:08:24,979
two selectors to select the active movie

00:08:21,550 --> 00:08:27,729
but this is only done at the local level

00:08:24,979 --> 00:08:31,430
of the movie stage as I mentioned before

00:08:27,729 --> 00:08:37,010
we're operating on global stage because

00:08:31,430 --> 00:08:39,769
we receive global state every time so

00:08:37,010 --> 00:08:43,130
once again selectors allow you to

00:08:39,769 --> 00:08:48,910
compose queries of data from that shared

00:08:43,130 --> 00:08:51,160
data that you have in in grx so here

00:08:48,910 --> 00:08:53,230
lifting up the local selectors and I'm

00:08:51,160 --> 00:09:01,030
composing them to expose them to the

00:08:53,230 --> 00:09:02,560
global shared state this selector if we

00:09:01,030 --> 00:09:04,240
look at another example because we're

00:09:02,560 --> 00:09:06,700
talking about share a lot of shared data

00:09:04,240 --> 00:09:10,450
a lot of complex models every want to

00:09:06,700 --> 00:09:14,500
combine together this electric lines the

00:09:10,450 --> 00:09:18,220
current user their books and favorites

00:09:14,500 --> 00:09:21,550
into one view this all this is done

00:09:18,220 --> 00:09:23,890
efficiently with tracked inputs and is

00:09:21,550 --> 00:09:28,750
reusable to build up even more complex

00:09:23,890 --> 00:09:30,700
views selectors are building blocks as I

00:09:28,750 --> 00:09:33,700
mentioned before if I needed to use this

00:09:30,700 --> 00:09:35,410
selector and then as an input for

00:09:33,700 --> 00:09:39,180
another piece of data that I need for

00:09:35,410 --> 00:09:39,180
our UI and I could do that

00:09:40,230 --> 00:09:49,900
so selectors are easily composable to

00:09:45,280 --> 00:09:52,300
build complex models and Live View is so

00:09:49,900 --> 00:09:54,820
that when you're using these selectors

00:09:52,300 --> 00:09:56,860
in that fashion you can they're not just

00:09:54,820 --> 00:09:58,390
single users and you can build them up

00:09:56,860 --> 00:10:05,920
in a way that makes them more powerful

00:09:58,390 --> 00:10:08,020
according to what your needs are in an

00:10:05,920 --> 00:10:10,960
image before we're building these sub

00:10:08,020 --> 00:10:13,660
States out of these selectors but what

00:10:10,960 --> 00:10:15,970
if you say that you need you need a

00:10:13,660 --> 00:10:21,760
little bit more you need a little bit

00:10:15,970 --> 00:10:25,300
more power selectors are customizable so

00:10:21,760 --> 00:10:28,390
underneath each create selector is a

00:10:25,300 --> 00:10:30,160
create selector factory that comes with

00:10:28,390 --> 00:10:33,370
a default memorization strategy that I

00:10:30,160 --> 00:10:36,070
mentioned before which tracks the

00:10:33,370 --> 00:10:39,220
quality of the result that you generated

00:10:36,070 --> 00:10:41,680
when the inputs change so out of the box

00:10:39,220 --> 00:10:45,430
that is what you get with the create

00:10:41,680 --> 00:10:49,660
selector function and to just illustrate

00:10:45,430 --> 00:10:52,990
that selectors use inequality assertion

00:10:49,660 --> 00:10:56,590
for checking values and this supports

00:10:52,990 --> 00:10:58,540
most use cases but collections include

00:10:56,590 --> 00:11:01,000
large sets of data that data changes

00:10:58,540 --> 00:11:02,000
over time and selectors may only be

00:11:01,000 --> 00:11:04,280
interested in a small

00:11:02,000 --> 00:11:08,540
all subsets of that data that dated at

00:11:04,280 --> 00:11:10,370
me relatively fixed so let's look at

00:11:08,540 --> 00:11:14,000
these two arrays here which we've been

00:11:10,370 --> 00:11:16,760
the result of an array of a collection

00:11:14,000 --> 00:11:18,410
that was updated as a state change but

00:11:16,760 --> 00:11:21,860
it was recomputed and produced a new

00:11:18,410 --> 00:11:24,080
value but as you can see the arrays are

00:11:21,860 --> 00:11:29,380
still the same so we can be more

00:11:24,080 --> 00:11:31,670
efficient with a custom selector so

00:11:29,380 --> 00:11:34,280
custom selectors like I mentioned before

00:11:31,670 --> 00:11:38,300
allow you to override the custom or the

00:11:34,280 --> 00:11:41,060
default strategy for memorization so if

00:11:38,300 --> 00:11:43,280
we wanted so to check whether this

00:11:41,060 --> 00:11:45,950
strategy would go through this array and

00:11:43,280 --> 00:11:47,330
compute the same result again you would

00:11:45,950 --> 00:11:49,760
check that whether it's an instance of

00:11:47,330 --> 00:11:52,310
an array and check that every property

00:11:49,760 --> 00:11:57,770
in one array still matches everyone in a

00:11:52,310 --> 00:12:00,200
second so using that in our defining an

00:11:57,770 --> 00:12:02,120
array memorizer function you can compose

00:12:00,200 --> 00:12:04,280
the default min wiser with the custom

00:12:02,120 --> 00:12:07,010
check for the resulting array still

00:12:04,280 --> 00:12:12,440
taking advantage of memoization but

00:12:07,010 --> 00:12:14,870
using your own custom logic so you still

00:12:12,440 --> 00:12:18,470
use the create selector factory custom

00:12:14,870 --> 00:12:23,540
memorizer but now you have your own

00:12:18,470 --> 00:12:26,589
create array selector that's fully

00:12:23,540 --> 00:12:26,589
customizable to your needs

00:12:27,190 --> 00:12:33,380
so selectors allow you to query your

00:12:31,310 --> 00:12:35,810
store for data whether that be small

00:12:33,380 --> 00:12:39,380
sets of data or large sets of data that

00:12:35,810 --> 00:12:42,140
you need to combine together they

00:12:39,380 --> 00:12:45,200
recompute when their inputs change that

00:12:42,140 --> 00:12:48,320
way states your application is that you

00:12:45,200 --> 00:12:50,980
know constantly flowing state change but

00:12:48,320 --> 00:12:53,660
you don't need to recompute every time

00:12:50,980 --> 00:12:55,760
we fully liberalize memorization for

00:12:53,660 --> 00:12:59,200
performance so they were only needed to

00:12:55,760 --> 00:13:02,990
trigger changes when it's needed

00:12:59,200 --> 00:13:05,900
selectors are fully composable you can

00:13:02,990 --> 00:13:08,089
build up these complex models or these

00:13:05,900 --> 00:13:12,200
sub States as we call them in your

00:13:08,089 --> 00:13:15,310
injects app and selectors are extensible

00:13:12,200 --> 00:13:17,380
I showed you an example of

00:13:15,310 --> 00:13:19,300
more advanced example of creating a

00:13:17,380 --> 00:13:21,310
custom minimization strategy for an

00:13:19,300 --> 00:13:23,770
array but you can customize those

00:13:21,310 --> 00:13:29,230
according to whichever your requirements

00:13:23,770 --> 00:13:31,870
are so just to cap it off whether you

00:13:29,230 --> 00:13:35,740
want to slice off a small piece of state

00:13:31,870 --> 00:13:37,420
for your application or you want to

00:13:35,740 --> 00:13:40,390
build some complex model that you're

00:13:37,420 --> 00:13:42,279
spreading around everywhere selectors

00:13:40,390 --> 00:13:47,400
are fully capable of handling either one

00:13:42,279 --> 00:13:51,400
of those scenarios so let's talk about

00:13:47,400 --> 00:13:54,490
one last thing and if you're if you've

00:13:51,400 --> 00:13:56,470
been injured before or even if you

00:13:54,490 --> 00:13:58,360
haven't you should this should be

00:13:56,470 --> 00:14:01,420
exciting or should be exciting for you

00:13:58,360 --> 00:14:03,580
cuz I know it has been for us and that's

00:14:01,420 --> 00:14:07,779
the upcoming version of injure X version

00:14:03,580 --> 00:14:12,310
8 so let's talk about where injure X is

00:14:07,779 --> 00:14:14,890
today today index is still about

00:14:12,310 --> 00:14:17,140
explicitness and type safety and we do

00:14:14,890 --> 00:14:20,950
this using action classes in enums

00:14:17,140 --> 00:14:24,970
and this works works to satisfy the

00:14:20,950 --> 00:14:26,830
explicitness but you know people say

00:14:24,970 --> 00:14:29,920
this is a lot of that seems to be kind

00:14:26,830 --> 00:14:31,810
of heavy to what what we want to do and

00:14:29,920 --> 00:14:34,690
because open source collaboration is

00:14:31,810 --> 00:14:39,370
awesome we came up with a less verbose

00:14:34,690 --> 00:14:42,010
way to create actions so now we ever

00:14:39,370 --> 00:14:43,960
introduced action creators in engineer X

00:14:42,010 --> 00:14:46,810
you know these action creators are in

00:14:43,960 --> 00:14:49,810
version 7 and we simplified them even

00:14:46,810 --> 00:14:51,880
more for the upcoming version 8 we still

00:14:49,810 --> 00:14:56,200
retain the same type safety and

00:14:51,880 --> 00:14:57,880
explicitness with less code so instead

00:14:56,200 --> 00:15:01,270
of creating new instances for action

00:14:57,880 --> 00:15:03,790
classes we can use the action creators

00:15:01,270 --> 00:15:05,290
when we're dispatching actions and still

00:15:03,790 --> 00:15:10,780
have that type safety for your action

00:15:05,290 --> 00:15:12,370
metadata now here's another one because

00:15:10,780 --> 00:15:14,620
we've talked about this one before many

00:15:12,370 --> 00:15:16,360
times because you if you were here last

00:15:14,620 --> 00:15:20,709
year you maybe hurt me scream

00:15:16,360 --> 00:15:22,180
boilerplate in the talk last year but

00:15:20,709 --> 00:15:23,860
along with action creators we took a

00:15:22,180 --> 00:15:26,260
look at some different economics for

00:15:23,860 --> 00:15:28,160
reducers today you can use a reducer

00:15:26,260 --> 00:15:30,529
function with a switch statement

00:15:28,160 --> 00:15:32,600
action union and this is still a

00:15:30,529 --> 00:15:37,089
completely valid way to do a reducer and

00:15:32,600 --> 00:15:39,949
be explicit about it but thanks to

00:15:37,089 --> 00:15:42,860
Nicolas Jamison and his TS action

00:15:39,949 --> 00:15:44,750
library and Alex of Cusco for building

00:15:42,860 --> 00:15:46,639
out this feature we now have a helper

00:15:44,750 --> 00:15:49,550
function to generate a reducer that

00:15:46,639 --> 00:15:51,769
operates in the same way you can

00:15:49,550 --> 00:15:53,990
generate multiple actions no you more

00:15:51,769 --> 00:15:56,029
union types are required and you still

00:15:53,990 --> 00:15:59,500
have all the same guarantees that you

00:15:56,029 --> 00:15:59,500
have currently today within Gerak's

00:16:01,480 --> 00:16:06,649
another features coming is in directs

00:16:04,009 --> 00:16:10,189
data in jerks data was developed by John

00:16:06,649 --> 00:16:12,920
Papa and warbell in version 8 it will be

00:16:10,189 --> 00:16:16,540
an official in Jurek's package with

00:16:12,920 --> 00:16:20,060
minimal setup managing empty collections

00:16:16,540 --> 00:16:24,939
batteries included in GX but it still

00:16:20,060 --> 00:16:28,160
interacts under the hood and for a new

00:16:24,939 --> 00:16:30,410
one to also say that we have some new

00:16:28,160 --> 00:16:32,689
people coming onto the team now you may

00:16:30,410 --> 00:16:35,209
have seen them on Twitter before or if

00:16:32,689 --> 00:16:37,189
you follow the danger X repo we have

00:16:35,209 --> 00:16:39,110
Alex at Cusco who's a software engineer

00:16:37,189 --> 00:16:41,600
at Google working on firebase and is a

00:16:39,110 --> 00:16:43,519
maintainer for njx inside Google and has

00:16:41,600 --> 00:16:45,740
written many high-quality articles about

00:16:43,519 --> 00:16:48,350
injure X and other many of the features

00:16:45,740 --> 00:16:51,019
that I mentioned there's also West

00:16:48,350 --> 00:16:52,939
Grimes who is a software engineer in the

00:16:51,019 --> 00:16:55,370
insurance industry specializing in

00:16:52,939 --> 00:16:57,170
enterprise web apps so in his spare time

00:16:55,370 --> 00:16:59,329
he enjoys mentoring new developers

00:16:57,170 --> 00:17:02,209
tracking weather and contributing

00:16:59,329 --> 00:17:04,280
open-source projects like enger' X so if

00:17:02,209 --> 00:17:05,480
you want to follow the follow west on

00:17:04,280 --> 00:17:08,270
twitter you'll find pictures of food

00:17:05,480 --> 00:17:09,530
sunsets and tea bits about angular and

00:17:08,270 --> 00:17:14,240
those those sound like pretty good

00:17:09,530 --> 00:17:17,240
things to me lastly we mentioned before

00:17:14,240 --> 00:17:18,770
the inner X is about community so

00:17:17,240 --> 00:17:20,569
there's a lot of work that goes into

00:17:18,770 --> 00:17:21,829
each release and we that would not be

00:17:20,569 --> 00:17:24,439
possible without the community of

00:17:21,829 --> 00:17:26,240
contributors so I've listed some of the

00:17:24,439 --> 00:17:28,429
names of the contributors here and this

00:17:26,240 --> 00:17:30,049
is not an exhaustive list but this is

00:17:28,429 --> 00:17:32,120
these people come from a lot of diverse

00:17:30,049 --> 00:17:33,049
backgrounds but all have contributed in

00:17:32,120 --> 00:17:36,080
a meaningful way

00:17:33,049 --> 00:17:37,520
whether it be Doc's code or testing so

00:17:36,080 --> 00:17:40,100
if you want to get involved with our

00:17:37,520 --> 00:17:41,520
great community of contributors and

00:17:40,100 --> 00:17:46,410
continue this open

00:17:41,520 --> 00:17:48,330
project we welcome you thank you for

00:17:46,410 --> 00:17:50,340
having me if you want to read more about

00:17:48,330 --> 00:17:52,740
the docs on index you can go to ngrick

00:17:50,340 --> 00:17:54,150
Co and then once again you can follow me

00:17:52,740 --> 00:17:55,340
on twitter if you want to have some fun

00:17:54,150 --> 00:17:55,560
thank you

00:17:55,340 --> 00:18:01,380
[Music]

00:17:55,560 --> 00:18:01,380
[Applause]

00:18:05,160 --> 00:18:11,769
[Music]

00:18:17,380 --> 00:18:19,440

YouTube URL: https://www.youtube.com/watch?v=RXuSDiLmcN0


