Title: Thinking Reactively: Most Difficult | Mike Pearson
Publication date: 2019-05-05
Playlist: ng-conf 2019
Description: 
	Reading and writing reactive code is a mysterious art that evades mastery for all but the most dedicated of disciples. Why is it so mind-bendingly difficult? Is it worth mastering? Most of all, how can we make it better?

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:07,920 --> 00:00:11,170
[Music]

00:00:11,780 --> 00:00:19,619
so a few months ago ng-conf did a survey

00:00:15,929 --> 00:00:21,270
and the number one thing that angular

00:00:19,619 --> 00:00:24,119
developers said that both they and other

00:00:21,270 --> 00:00:27,810
developers are struggling with was rxjs

00:00:24,119 --> 00:00:29,580
and when I was first learning rxjs I

00:00:27,810 --> 00:00:31,230
thought that the most difficult thing

00:00:29,580 --> 00:00:32,790
was going to be learning the operators

00:00:31,230 --> 00:00:34,829
because there are just so many of them

00:00:32,790 --> 00:00:37,170
but once I was familiar with some of

00:00:34,829 --> 00:00:40,800
them I realized that I was still having

00:00:37,170 --> 00:00:42,300
a lot of trouble with rxjs and and with

00:00:40,800 --> 00:00:43,940
talking with my co-workers and trying to

00:00:42,300 --> 00:00:47,250
figure out what why it was so difficult

00:00:43,940 --> 00:00:50,219
we came to the conclusion that that it's

00:00:47,250 --> 00:00:51,480
more about thinking reactively and using

00:00:50,219 --> 00:00:53,670
those operators to build reactive

00:00:51,480 --> 00:00:54,870
applications that's so difficult because

00:00:53,670 --> 00:01:01,170
it's just different from what we're used

00:00:54,870 --> 00:01:03,719
to and about a month ago or a year ago

00:01:01,170 --> 00:01:06,390
sorry I was working on a tournament app

00:01:03,719 --> 00:01:08,100
where users could follow different teams

00:01:06,390 --> 00:01:09,780
and get notified whenever there was a

00:01:08,100 --> 00:01:12,950
win or a loss for the team they're

00:01:09,780 --> 00:01:15,509
following and there was a problem where

00:01:12,950 --> 00:01:18,840
the users were getting notifications

00:01:15,509 --> 00:01:20,250
when they were supposed to with with the

00:01:18,840 --> 00:01:21,780
teams are already following but then

00:01:20,250 --> 00:01:24,450
when they went to a team's page and

00:01:21,780 --> 00:01:26,330
click the follow button they didn't

00:01:24,450 --> 00:01:29,850
start getting notifications for that

00:01:26,330 --> 00:01:32,369
team until they refreshed the app so I

00:01:29,850 --> 00:01:35,189
figured all right I think I know what's

00:01:32,369 --> 00:01:35,670
going on I think there's an ng on in it

00:01:35,189 --> 00:01:40,079
somewhere

00:01:35,670 --> 00:01:42,630
and in that ng on in it the app is

00:01:40,079 --> 00:01:44,310
taking the users teams they're already

00:01:42,630 --> 00:01:45,960
following and then going through them

00:01:44,310 --> 00:01:48,299
and subscribing to the notifications so

00:01:45,960 --> 00:01:53,939
they can show them to the user and I

00:01:48,299 --> 00:01:56,960
thought it would be and but then in the

00:01:53,939 --> 00:02:01,140
event handler for the follow team button

00:01:56,960 --> 00:02:02,189
there there was a missing line of code

00:02:01,140 --> 00:02:05,250
there so I thought what it would look

00:02:02,189 --> 00:02:07,409
like is something like this so you would

00:02:05,250 --> 00:02:10,140
add that new team to the teams that the

00:02:07,409 --> 00:02:12,030
users following and then it would update

00:02:10,140 --> 00:02:13,620
some visual indicator in the page that

00:02:12,030 --> 00:02:16,230
they're now following that team

00:02:13,620 --> 00:02:17,879
and then that would be it and I thought

00:02:16,230 --> 00:02:20,370
that I could just come in and add this

00:02:17,879 --> 00:02:23,970
line of code and then it would just work

00:02:20,370 --> 00:02:27,390
perfectly so just subscribe to the new

00:02:23,970 --> 00:02:30,000
notifications for that team and but my

00:02:27,390 --> 00:02:32,640
plan didn't work out and you'll never

00:02:30,000 --> 00:02:35,489
guess why it's because that function

00:02:32,640 --> 00:02:38,220
didn't exist or it didn't exist in

00:02:35,489 --> 00:02:41,700
anything close to the form that I was

00:02:38,220 --> 00:02:47,130
expecting it to so I saw this instead I

00:02:41,700 --> 00:02:49,230
was like okay click through to the

00:02:47,130 --> 00:02:52,769
definition for that observable and it

00:02:49,230 --> 00:02:55,349
was just a regular subject so I'm like

00:02:52,769 --> 00:03:00,290
okay I searched the project and found

00:02:55,349 --> 00:03:00,290
about 82 references to this subject and

00:03:00,319 --> 00:03:04,650
after a couple months I finally found

00:03:03,329 --> 00:03:11,760
the right place in the code to change

00:03:04,650 --> 00:03:14,090
and then it worked so to step back for a

00:03:11,760 --> 00:03:16,620
second and think about that process I

00:03:14,090 --> 00:03:18,389
don't think that's actually an uncommon

00:03:16,620 --> 00:03:21,200
process for a lot of people debugging

00:03:18,389 --> 00:03:23,910
rxjs applications I've heard a lot from

00:03:21,200 --> 00:03:25,410
from other developers and and I've had

00:03:23,910 --> 00:03:28,010
this experience to where you feel like

00:03:25,410 --> 00:03:32,040
you have to chase the observables around

00:03:28,010 --> 00:03:33,420
um you know following the streams around

00:03:32,040 --> 00:03:36,900
until you find the right place to change

00:03:33,420 --> 00:03:38,400
stuff so is it just rxjs is that is that

00:03:36,900 --> 00:03:42,510
the problem is it just difficult to

00:03:38,400 --> 00:03:43,950
debug rxjs applications and usually

00:03:42,510 --> 00:03:47,489
that's kind of my go-to approach you

00:03:43,950 --> 00:03:49,680
know blame the code like a skinner here

00:03:47,489 --> 00:03:54,030
am i lacking experience no see

00:03:49,680 --> 00:03:55,739
observables that are wrong but actually

00:03:54,030 --> 00:03:59,069
that wasn't the problem the problem was

00:03:55,739 --> 00:04:02,669
my experience my experience was mostly

00:03:59,069 --> 00:04:06,510
with imperative architecture and so I

00:04:02,669 --> 00:04:07,950
was thinking of it as an imperative app

00:04:06,510 --> 00:04:09,870
when it was actually structured like a

00:04:07,950 --> 00:04:11,900
reactive app I think that's the key to

00:04:09,870 --> 00:04:14,970
making it easier for us to understand

00:04:11,900 --> 00:04:17,430
rxjs apps apps that are built completely

00:04:14,970 --> 00:04:18,349
with the reactive architecture so to

00:04:17,430 --> 00:04:21,450
look at the difference between

00:04:18,349 --> 00:04:24,390
imperative and reactive I think is the

00:04:21,450 --> 00:04:26,320
key so this is what we're mostly used to

00:04:24,390 --> 00:04:28,870
the function is

00:04:26,320 --> 00:04:31,060
the the unit that that determines how

00:04:28,870 --> 00:04:33,760
things behave you have event handlers

00:04:31,060 --> 00:04:36,400
callbacks that are making things go to

00:04:33,760 --> 00:04:38,530
the server making things show up in the

00:04:36,400 --> 00:04:40,840
DOM and just making things in general

00:04:38,530 --> 00:04:43,690
happen in your app so when you have a

00:04:40,840 --> 00:04:45,310
bug you go to an event handler or a

00:04:43,690 --> 00:04:47,500
callback and you expect to see the

00:04:45,310 --> 00:04:52,410
problem there expect to see something

00:04:47,500 --> 00:04:54,940
missing there but with reactive apps

00:04:52,410 --> 00:04:58,930
it's structured kind of like this you

00:04:54,940 --> 00:05:01,540
have sources and syncs in a purely

00:04:58,930 --> 00:05:03,700
reactive app and in the sources those

00:05:01,540 --> 00:05:06,610
are things like Dom events like when the

00:05:03,700 --> 00:05:08,050
user types of clicks and then you have

00:05:06,610 --> 00:05:11,830
like server events when data arrives

00:05:08,050 --> 00:05:15,250
from the server or timers just any time

00:05:11,830 --> 00:05:18,160
data enters your app that is a source

00:05:15,250 --> 00:05:19,930
and then the sync is where data ends up

00:05:18,160 --> 00:05:22,210
after goes through your app so that

00:05:19,930 --> 00:05:25,450
would be like the Dom where it's shown

00:05:22,210 --> 00:05:30,670
to the user or the server where it's

00:05:25,450 --> 00:05:32,560
saved and so these are pretty different

00:05:30,670 --> 00:05:36,460
architectures if I flip back between

00:05:32,560 --> 00:05:39,400
these two so what was happening it was I

00:05:36,460 --> 00:05:46,140
was looking here for an event handler to

00:05:39,400 --> 00:05:49,270
to to have that bug that I could fix but

00:05:46,140 --> 00:05:51,430
what I needed to do was actually start

00:05:49,270 --> 00:05:54,280
from the template and find an async pipe

00:05:51,430 --> 00:05:55,480
for a similar behavior and trace it up

00:05:54,280 --> 00:05:58,180
there and if I had done that I would

00:05:55,480 --> 00:06:03,250
have found the problem in about 1/10 the

00:05:58,180 --> 00:06:06,640
time so our habits are making it more

00:06:03,250 --> 00:06:10,510
difficult for us to work with rxjs apps

00:06:06,640 --> 00:06:15,130
and it's even more difficult when we're

00:06:10,510 --> 00:06:19,300
trying to write rxjs apps so I've got

00:06:15,130 --> 00:06:23,620
this example that I made in stack blitz

00:06:19,300 --> 00:06:29,460
I hired a PhD graphic designer to help

00:06:23,620 --> 00:06:29,460
me design this Thanks

00:06:30,040 --> 00:06:34,940
yeah so there's a certain pattern that I

00:06:33,260 --> 00:06:38,780
see that shows up in a lot of different

00:06:34,940 --> 00:06:41,090
apps and my favorite example of this

00:06:38,780 --> 00:06:43,430
pattern is a simple type ahead or

00:06:41,090 --> 00:06:48,410
autocomplete or like a list that you're

00:06:43,430 --> 00:06:51,350
filtering based on user input and every

00:06:48,410 --> 00:06:54,530
time the first few times most developers

00:06:51,350 --> 00:06:57,110
come across this pattern they make a

00:06:54,530 --> 00:07:02,000
mistake and they don't utilize the power

00:06:57,110 --> 00:07:04,820
that rxjs gives you so what the what the

00:07:02,000 --> 00:07:07,430
type ahead is is basically you give it

00:07:04,820 --> 00:07:09,560
input and then it filters the list

00:07:07,430 --> 00:07:11,450
well that wasn't exciting it filters the

00:07:09,560 --> 00:07:15,919
list down to the string that you've

00:07:11,450 --> 00:07:17,780
typed and and then yeah so it handles

00:07:15,919 --> 00:07:20,330
user input fetches the data and then

00:07:17,780 --> 00:07:24,850
shows it so how would you just naturally

00:07:20,330 --> 00:07:27,919
go about coding this this behavior well

00:07:24,850 --> 00:07:29,330
the most natural method to every

00:07:27,919 --> 00:07:30,800
developer I've known is just coded

00:07:29,330 --> 00:07:33,320
directly the function takes care of it

00:07:30,800 --> 00:07:36,500
the function is in charge the event

00:07:33,320 --> 00:07:39,260
handler to this to this input is right

00:07:36,500 --> 00:07:43,340
here so you receive the search term then

00:07:39,260 --> 00:07:46,610
you go fetch the data and then you show

00:07:43,340 --> 00:07:49,550
the data by assigning the the class

00:07:46,610 --> 00:07:53,720
property to that value and then change

00:07:49,550 --> 00:07:58,030
detection takes care of the rest so how

00:07:53,720 --> 00:08:05,690
does this work it works pretty well but

00:07:58,030 --> 00:08:07,340
every once in a while there it goes you

00:08:05,690 --> 00:08:08,840
get a mismatch between what the user has

00:08:07,340 --> 00:08:10,580
typed and the results that are showing

00:08:08,840 --> 00:08:13,640
you can alleviate this a little bit with

00:08:10,580 --> 00:08:16,460
debouncing but that's adding some

00:08:13,640 --> 00:08:21,020
permanent delay time on the requests

00:08:16,460 --> 00:08:22,910
that that maybe isn't perfect and it's

00:08:21,020 --> 00:08:25,190
it's also a little bit inefficient

00:08:22,910 --> 00:08:26,780
because once these requests are sent out

00:08:25,190 --> 00:08:29,900
they're just out there and they're not

00:08:26,780 --> 00:08:31,520
being cancelled so what happened here

00:08:29,900 --> 00:08:35,089
was the second last request came back

00:08:31,520 --> 00:08:37,430
after the last request so it gets shown

00:08:35,089 --> 00:08:41,390
instead of the last one and that's where

00:08:37,430 --> 00:08:43,750
this problem comes from so how would

00:08:41,390 --> 00:08:49,310
this look if we were doing this

00:08:43,750 --> 00:08:52,190
more reactively well we would think

00:08:49,310 --> 00:08:55,370
about the sources and sinks and then the

00:08:52,190 --> 00:08:58,040
pipes that connect them and I really

00:08:55,370 --> 00:09:01,269
really liked Debora krottas talked on on

00:08:58,040 --> 00:09:03,980
Wednesday about this about you know

00:09:01,269 --> 00:09:06,320
creating these observable chains that

00:09:03,980 --> 00:09:08,300
are composed that that allow you to not

00:09:06,320 --> 00:09:09,649
even need to manually subscribe so

00:09:08,300 --> 00:09:12,740
that's kind of the approach I'm taking

00:09:09,649 --> 00:09:14,930
here so I think about the source first

00:09:12,740 --> 00:09:18,680
it's going to be a subject it could be a

00:09:14,930 --> 00:09:21,620
behavior subject whatever but with this

00:09:18,680 --> 00:09:23,630
subject there's an event handler here

00:09:21,620 --> 00:09:27,950
and we're just going to pump those

00:09:23,630 --> 00:09:32,200
values into that subject and that's the

00:09:27,950 --> 00:09:34,190
source okay and then the sink

00:09:32,200 --> 00:09:37,370
I'm just gonna say it's gonna be the

00:09:34,190 --> 00:09:41,720
async pipe and it's gonna loop through

00:09:37,370 --> 00:09:43,519
the data and show it here and so where

00:09:41,720 --> 00:09:47,089
does this observable come from this is

00:09:43,519 --> 00:09:48,620
the hard part it's it's the part where

00:09:47,089 --> 00:09:50,269
you have to think reactively because you

00:09:48,620 --> 00:09:53,240
have to do you have to connect the

00:09:50,269 --> 00:09:55,430
source to the sink and in this example

00:09:53,240 --> 00:09:57,769
it's pretty simple though you just chain

00:09:55,430 --> 00:10:01,880
off of that search term and switch map

00:09:57,769 --> 00:10:05,390
it into the filtered results and the

00:10:01,880 --> 00:10:12,740
result here is it's it's never gonna be

00:10:05,390 --> 00:10:17,180
out of order I guess just trust me all

00:10:12,740 --> 00:10:19,190
right I think that's enough with that so

00:10:17,180 --> 00:10:21,709
what are the differences between these

00:10:19,190 --> 00:10:25,670
two approaches that we can extend to

00:10:21,709 --> 00:10:31,279
other examples and give ourselves a way

00:10:25,670 --> 00:10:34,880
to avoid the imperative habits that we

00:10:31,279 --> 00:10:36,230
have with our code well there are some

00:10:34,880 --> 00:10:38,149
differences here but I want to call

00:10:36,230 --> 00:10:39,620
attention to the manual subscription

00:10:38,149 --> 00:10:41,600
here

00:10:39,620 --> 00:10:43,430
the imperative example is calling dot

00:10:41,600 --> 00:10:46,070
subscribe on that observable chain and

00:10:43,430 --> 00:10:48,500
in looking over a bunch of different

00:10:46,070 --> 00:10:50,779
examples of rxjs code that was still

00:10:48,500 --> 00:10:52,040
kind of in an imperative style this was

00:10:50,779 --> 00:10:54,890
the common thing between all of them

00:10:52,040 --> 00:10:57,050
they were they were coding with rxjs

00:10:54,890 --> 00:11:01,310
but they weren't getting the full van

00:10:57,050 --> 00:11:04,120
and they were subscribing and either the

00:11:01,310 --> 00:11:06,530
component class or the service so

00:11:04,120 --> 00:11:09,590
theoretically you shouldn't ever have to

00:11:06,530 --> 00:11:11,990
manually subscribe though I like the

00:11:09,590 --> 00:11:14,840
approach of letting the asic pipe handle

00:11:11,990 --> 00:11:17,630
at all because nothing really happens in

00:11:14,840 --> 00:11:20,870
your app unless a consumer is interested

00:11:17,630 --> 00:11:22,400
in it like the user and nothing is

00:11:20,870 --> 00:11:24,740
really being calculated unless it's

00:11:22,400 --> 00:11:26,360
going to be displayed right eventually

00:11:24,740 --> 00:11:28,550
the user is going to see it so it's

00:11:26,360 --> 00:11:31,220
going to end up in the template and so

00:11:28,550 --> 00:11:33,380
if you're if you're just connecting from

00:11:31,220 --> 00:11:35,110
the sources to the sinks and you've got

00:11:33,380 --> 00:11:36,970
observable chains that are just

00:11:35,110 --> 00:11:40,370
composing each other all the way down

00:11:36,970 --> 00:11:42,020
then that that subscription that the

00:11:40,370 --> 00:11:44,390
async pipe is automatically doing for

00:11:42,020 --> 00:11:47,020
you should just propagate all the way up

00:11:44,390 --> 00:11:50,630
through your code and you can have

00:11:47,020 --> 00:11:53,510
reactive streams and never need to

00:11:50,630 --> 00:11:56,830
subscribe manually I'm not saying that

00:11:53,510 --> 00:11:59,750
you should never ever subscribe manually

00:11:56,830 --> 00:12:02,000
I'm just saying that you should be aware

00:11:59,750 --> 00:12:04,870
that when you do you are breaking that

00:12:02,000 --> 00:12:07,880
observable chain and from this point on

00:12:04,870 --> 00:12:09,410
you are moving over to an imperative

00:12:07,880 --> 00:12:13,060
code and you might not get the

00:12:09,410 --> 00:12:13,060
guarantees that reactive code gives you

00:12:15,430 --> 00:12:25,180
so I think the one thing I could say is

00:12:21,700 --> 00:12:27,140
just of course it's easier to code

00:12:25,180 --> 00:12:29,570
imperative lis because that's what we're

00:12:27,140 --> 00:12:30,620
used to but I think we can actually get

00:12:29,570 --> 00:12:35,510
better and more comfortable with

00:12:30,620 --> 00:12:37,280
thinking reactively and and so I would

00:12:35,510 --> 00:12:39,410
say don't as soon as you get

00:12:37,280 --> 00:12:40,910
uncomfortable don't bail yourself out

00:12:39,410 --> 00:12:41,810
with this subscribe and then do things

00:12:40,910 --> 00:12:43,460
imperative lis

00:12:41,810 --> 00:12:44,750
I'd say push yourself a little further

00:12:43,460 --> 00:12:46,040
and try to think of the reactive

00:12:44,750 --> 00:12:51,290
solution and that's how you're gonna get

00:12:46,040 --> 00:12:53,420
better at it alright so the last part of

00:12:51,290 --> 00:12:58,310
my talk is just going to be a lot of

00:12:53,420 --> 00:13:03,020
opinions that I've developed I I I'm

00:12:58,310 --> 00:13:05,120
afraid that that we might not get the

00:13:03,020 --> 00:13:08,030
benefits as a community of reactive

00:13:05,120 --> 00:13:10,430
architecture fully unless we we really

00:13:08,030 --> 00:13:12,380
do put in like a

00:13:10,430 --> 00:13:15,050
an intentional effort at training

00:13:12,380 --> 00:13:16,670
ourselves and our team members to learn

00:13:15,050 --> 00:13:20,390
how to use observables in a reactive

00:13:16,670 --> 00:13:21,980
manner and I am afraid that there's like

00:13:20,390 --> 00:13:23,300
the pendulum that's really in favor of

00:13:21,980 --> 00:13:25,610
arts just right now it's can swing the

00:13:23,300 --> 00:13:27,500
other way and after a while if we don't

00:13:25,610 --> 00:13:29,300
see a ton of benefits from it we might

00:13:27,500 --> 00:13:32,480
push it into the corners of our apps and

00:13:29,300 --> 00:13:34,460
kind of minimize its its influence in

00:13:32,480 --> 00:13:37,490
our code but I don't want that to happen

00:13:34,460 --> 00:13:41,839
because I really really love rxjs I

00:13:37,490 --> 00:13:43,400
think it's amazing you remember that

00:13:41,839 --> 00:13:47,900
tournament app I was talking about at

00:13:43,400 --> 00:13:50,900
the beginning that bug wasn't real

00:13:47,900 --> 00:13:53,120
because that bug wouldn't have been able

00:13:50,900 --> 00:13:55,010
to exist in an app that was actually

00:13:53,120 --> 00:13:57,050
structured reactively because the

00:13:55,010 --> 00:14:00,440
notifications would be shown using an

00:13:57,050 --> 00:14:02,900
async pipe right and those notifications

00:14:00,440 --> 00:14:04,190
are be coming from the observable of

00:14:02,900 --> 00:14:07,760
notifications which would be chaining

00:14:04,190 --> 00:14:09,589
off of the team's observable and so you

00:14:07,760 --> 00:14:11,690
wouldn't be able to follow a new team

00:14:09,589 --> 00:14:13,550
and add it to your team's without that

00:14:11,690 --> 00:14:15,020
vely propagating all the way through so

00:14:13,550 --> 00:14:21,140
it would've been impossible for that bug

00:14:15,020 --> 00:14:23,240
to show up I think that bugs may seem

00:14:21,140 --> 00:14:27,070
sometimes like an inevitability in our

00:14:23,240 --> 00:14:32,120
code because there are always bugs but

00:14:27,070 --> 00:14:33,680
if you're intentional about analyzing

00:14:32,120 --> 00:14:36,020
the bugs and where they come from you

00:14:33,680 --> 00:14:38,810
can actually trace where they come from

00:14:36,020 --> 00:14:40,790
and eliminate entire categories of bugs

00:14:38,810 --> 00:14:45,680
I think reactive architecture eliminates

00:14:40,790 --> 00:14:47,420
inconsistent state and because you can't

00:14:45,680 --> 00:14:48,410
really develop a new feature unless it's

00:14:47,420 --> 00:14:50,630
already getting the values from

00:14:48,410 --> 00:14:52,730
observables which will be getting the

00:14:50,630 --> 00:14:55,250
values they need exactly when they need

00:14:52,730 --> 00:15:00,200
it so I think it's a better separation

00:14:55,250 --> 00:15:01,700
of concerns fundamentally because each

00:15:00,200 --> 00:15:03,740
each part of the app is its own

00:15:01,700 --> 00:15:06,220
authority on what it is what it means

00:15:03,740 --> 00:15:08,270
and what it needs and what it reacts to

00:15:06,220 --> 00:15:10,610
whereas with imperative code you have

00:15:08,270 --> 00:15:13,700
functions that are determining other

00:15:10,610 --> 00:15:16,700
parts of the app how they're going to

00:15:13,700 --> 00:15:18,920
behave and at different times and it's

00:15:16,700 --> 00:15:22,259
very easy to forget a step you have to

00:15:18,920 --> 00:15:24,720
be very active

00:15:22,259 --> 00:15:28,669
and making the behavior looking for

00:15:24,720 --> 00:15:30,989
happen I think a good analogy between

00:15:28,669 --> 00:15:32,790
reactive and imperative architectures is

00:15:30,989 --> 00:15:35,249
with plumbing because plumbing is done

00:15:32,790 --> 00:15:37,410
reactively but if it were done

00:15:35,249 --> 00:15:39,689
imperative ly if you needed hot water

00:15:37,410 --> 00:15:42,600
there might be like a hose on the wall

00:15:39,689 --> 00:15:44,220
that you you grab and you you spray

00:15:42,600 --> 00:15:45,959
water into the water heater you turn on

00:15:44,220 --> 00:15:47,509
the faucet for our hot water and then

00:15:45,959 --> 00:15:50,899
you send a text to the utility company

00:15:47,509 --> 00:15:53,999
so it's not really surprising that that

00:15:50,899 --> 00:15:55,410
maybe if that was how all plumbing was

00:15:53,999 --> 00:15:59,910
done that maybe a lot of people would be

00:15:55,410 --> 00:16:01,949
forgetting a lot of those steps so a lot

00:15:59,910 --> 00:16:04,079
of my opinions are just based on my own

00:16:01,949 --> 00:16:09,929
experience just being a web developer

00:16:04,079 --> 00:16:11,789
for the past few years and I think based

00:16:09,929 --> 00:16:16,529
on my experience that reactive

00:16:11,789 --> 00:16:18,389
architecture is is scalable for the

00:16:16,529 --> 00:16:21,689
modern web whereas imperative isn't and

00:16:18,389 --> 00:16:23,069
that might sound like a strong strong

00:16:21,689 --> 00:16:25,109
statement like we would have noticed

00:16:23,069 --> 00:16:28,350
before now if imperative was impossible

00:16:25,109 --> 00:16:31,549
but we have to haven't been doing purely

00:16:28,350 --> 00:16:34,919
imperative code in a long time

00:16:31,549 --> 00:16:38,399
when angularjs was introduced many years

00:16:34,919 --> 00:16:40,289
ago it was mostly imperative but it

00:16:38,399 --> 00:16:42,539
actually had introduced a slice of

00:16:40,289 --> 00:16:44,939
reactivity to our apps and it was

00:16:42,539 --> 00:16:47,789
exactly that slice of reactivity that

00:16:44,939 --> 00:16:49,649
developers loved change detection was

00:16:47,789 --> 00:16:54,119
reactive it could have been called Dom

00:16:49,649 --> 00:16:55,980
reaction maybe and for a while we didn't

00:16:54,119 --> 00:16:57,749
we did struggle with imperative habits

00:16:55,980 --> 00:17:00,509
there were a lot of questions people

00:16:57,749 --> 00:17:02,819
saying how do I mainly relate the Dom

00:17:00,509 --> 00:17:04,850
directly in this circumstance or or this

00:17:02,819 --> 00:17:07,799
circumstance and if you remember

00:17:04,850 --> 00:17:11,010
eventually enough people told us about

00:17:07,799 --> 00:17:13,110
the angular way where you let the

00:17:11,010 --> 00:17:14,929
variable you assign the variable and

00:17:13,110 --> 00:17:19,760
then you let the Dom react on its own

00:17:14,929 --> 00:17:22,620
and I think Redux /ng Rx is kind of

00:17:19,760 --> 00:17:25,639
continuing that trend as well except it

00:17:22,620 --> 00:17:30,629
introduces the layer of reactivity to

00:17:25,639 --> 00:17:32,100
the application state where reducers

00:17:30,629 --> 00:17:34,289
react to the events that are happening

00:17:32,100 --> 00:17:35,610
in your app I think we are still

00:17:34,289 --> 00:17:35,910
struggling a little bit with imperative

00:17:35,610 --> 00:17:38,610
hab

00:17:35,910 --> 00:17:40,020
with Redux as well where we create

00:17:38,610 --> 00:17:46,530
actions that are nothing more than

00:17:40,020 --> 00:17:49,190
setters of state but yeah and a really

00:17:46,530 --> 00:17:51,540
good talk about this as Mike Ryan's talk

00:17:49,190 --> 00:17:53,550
about good action hygiene I think he

00:17:51,540 --> 00:17:58,140
gave last year that it covers this

00:17:53,550 --> 00:18:01,440
concept so but I think we will we will

00:17:58,140 --> 00:18:05,460
learn the reactive patterns with redux

00:18:01,440 --> 00:18:07,590
as well I think and rxjs to me is is

00:18:05,460 --> 00:18:09,930
just kind of continuing this trend but

00:18:07,590 --> 00:18:14,700
it allows us to introduce reactivity to

00:18:09,930 --> 00:18:17,390
every layer of our app and I think it's

00:18:14,700 --> 00:18:19,830
powerful to have one abstraction for a

00:18:17,390 --> 00:18:23,220
synchronicity that that you can learn

00:18:19,830 --> 00:18:28,620
and and then you're good you can just

00:18:23,220 --> 00:18:30,990
always use it and we are struggling with

00:18:28,620 --> 00:18:33,420
it there are a lot of imperative habits

00:18:30,990 --> 00:18:35,490
it I mean it's a lot to adjust to it

00:18:33,420 --> 00:18:37,860
once with rxjs if you're going to use it

00:18:35,490 --> 00:18:40,170
everywhere which I don't recommend doing

00:18:37,860 --> 00:18:44,310
at first but I think we will learn the

00:18:40,170 --> 00:18:46,320
reactive habits and as a result we will

00:18:44,310 --> 00:18:50,550
eliminate will just see an entire

00:18:46,320 --> 00:18:52,550
category of bugs go away and so I think

00:18:50,550 --> 00:18:56,550
it'll be worth the struggle definitely

00:18:52,550 --> 00:18:59,130
to summarize the points that I wanted to

00:18:56,550 --> 00:19:00,810
get across in this talk I think the

00:18:59,130 --> 00:19:03,330
reason we're struggling right now so

00:19:00,810 --> 00:19:04,460
much with rxjs is because of our habits

00:19:03,330 --> 00:19:07,490
that we've just developed with

00:19:04,460 --> 00:19:10,320
experienced programming imperative Lee

00:19:07,490 --> 00:19:14,370
but we can master thinking rack

00:19:10,320 --> 00:19:16,170
reactively if we stick with it and don't

00:19:14,370 --> 00:19:18,480
bail ourselves out with a manual

00:19:16,170 --> 00:19:23,510
subscription as soon as we get a little

00:19:18,480 --> 00:19:26,220
bit fuzzy on what to do next and lastly

00:19:23,510 --> 00:19:28,200
it's gonna be worth the struggle the

00:19:26,220 --> 00:19:31,110
thing that's exciting to me I love

00:19:28,200 --> 00:19:34,700
seeing bugs go away but the thing that I

00:19:31,110 --> 00:19:37,560
love most is not having to worry about

00:19:34,700 --> 00:19:39,840
what parts of the app I have to update

00:19:37,560 --> 00:19:41,760
or worrying about all the bugs that

00:19:39,840 --> 00:19:43,530
might come up when I'm creating a new

00:19:41,760 --> 00:19:46,500
feature I can just chain off of an

00:19:43,530 --> 00:19:48,870
existing observable and not even worry

00:19:46,500 --> 00:19:49,710
about when that observable is going to

00:19:48,870 --> 00:19:52,380
get the values I can do

00:19:49,710 --> 00:19:56,190
trust that it will so it allows us to

00:19:52,380 --> 00:19:58,110
develop apps faster and get more

00:19:56,190 --> 00:20:01,380
exciting features to our users so that's

00:19:58,110 --> 00:20:03,330
what I'm excited about I'm really really

00:20:01,380 --> 00:20:07,710
grateful I was able to give this talk

00:20:03,330 --> 00:20:09,760
this is my first talk ever and I yeah

00:20:07,710 --> 00:20:15,940
thank you all for listening

00:20:09,760 --> 00:20:15,940
[Applause]

00:20:19,800 --> 00:20:26,410
[Music]

00:20:31,990 --> 00:20:34,050

YouTube URL: https://www.youtube.com/watch?v=-4cwkHNguXE


