Title: Using Monorepos for Scalable Apps | Dylan Johnson & James Henry & Mike Haas
Publication date: 2019-05-07
Playlist: ng-conf 2019
Description: 
	This interactive workshop will explore an architecture for building a large Angular app across federated development teams.

We’ll cover some low-level specifics of the architecture, like an Elements-based approach to angular.js migration, and building a shared component library on top of the Angular CDK. From there, we’ll explore developer experience and delivery ergonomics items like source control in a monorepo, Continuous Integration strategies, and code generation and modification via Schematics.

Interactive examples will be provided, but laptops aren’t required to consume the workshop content.

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:07,920 --> 00:00:11,170
[Music]

00:00:11,540 --> 00:00:16,740
I'm thrilled to be back this year at the

00:00:14,969 --> 00:00:18,420
world's best technical conference with

00:00:16,740 --> 00:00:20,820
the world's best technical community

00:00:18,420 --> 00:00:23,310
this year with my pals James and Mike

00:00:20,820 --> 00:00:27,060
with what I think is the longest talk

00:00:23,310 --> 00:00:28,349
title in ng-conf history I had to take

00:00:27,060 --> 00:00:31,590
the opportunity to work as many

00:00:28,349 --> 00:00:32,550
buzzwords as possible into the title but

00:00:31,590 --> 00:00:34,020
really we're here to share some

00:00:32,550 --> 00:00:36,750
interesting things we've learned about

00:00:34,020 --> 00:00:39,030
angular and team productivity while

00:00:36,750 --> 00:00:41,250
working on my migrating a big angularjs

00:00:39,030 --> 00:00:43,860
app to angular or as we're calling it

00:00:41,250 --> 00:00:45,120
turning an aircraft carrier the slides

00:00:43,860 --> 00:00:46,829
we're gonna go through draw from a

00:00:45,120 --> 00:00:52,110
sample project you can pull from Mike's

00:00:46,829 --> 00:00:54,449
github my costs 763 slash ng 2019

00:00:52,110 --> 00:00:56,430
turning an aircraft carrier you don't

00:00:54,449 --> 00:00:58,140
need the sample project to get value

00:00:56,430 --> 00:00:59,730
from the the presentation but if you'd

00:00:58,140 --> 00:01:01,710
like to pull it down tinker with it a

00:00:59,730 --> 00:01:03,979
little bit asks ask us some questions

00:01:01,710 --> 00:01:07,260
afterwards we'd be happy to answer I

00:01:03,979 --> 00:01:09,119
usually talk very slowly but since I

00:01:07,260 --> 00:01:11,400
made the very smart decision to try to

00:01:09,119 --> 00:01:13,979
jam three multi hour topics into a

00:01:11,400 --> 00:01:15,600
single hour presentation I'm gonna talk

00:01:13,979 --> 00:01:17,820
fast I'm gonna skip some points I would

00:01:15,600 --> 00:01:19,560
have liked to make we'll do our best to

00:01:17,820 --> 00:01:21,180
leave some time for Q&A but if you'd

00:01:19,560 --> 00:01:23,400
like to learn more please come find us

00:01:21,180 --> 00:01:25,740
afterwards we'd love to chat answer

00:01:23,400 --> 00:01:27,290
questions and share more info so with

00:01:25,740 --> 00:01:30,570
that let's jump right in

00:01:27,290 --> 00:01:33,479
so a quick intro on me I'm a platform

00:01:30,570 --> 00:01:35,490
engineering lead at Capital One my teams

00:01:33,479 --> 00:01:37,189
are focused on UI architecture and

00:01:35,490 --> 00:01:39,570
continuous integration and delivery

00:01:37,189 --> 00:01:41,040
please do come see the Capital One booth

00:01:39,570 --> 00:01:42,630
to meet some of the team and learn more

00:01:41,040 --> 00:01:44,640
about the stuff we build the angular

00:01:42,630 --> 00:01:47,130
apps we work on I've been building

00:01:44,640 --> 00:01:49,229
angularjs and angular things for about

00:01:47,130 --> 00:01:51,180
six years with a significant amount of

00:01:49,229 --> 00:01:53,850
that time dedicated to migrating various

00:01:51,180 --> 00:01:55,979
apps from angularjs to angular tried a

00:01:53,850 --> 00:01:59,549
bunch of strategies I framed some stuff

00:01:55,979 --> 00:02:00,960
in upgrade module downgrade module so

00:01:59,549 --> 00:02:03,030
we're here today to talk about a new

00:02:00,960 --> 00:02:05,340
strategy that we're using and I'll let

00:02:03,030 --> 00:02:08,729
James and Mike introduce themselves more

00:02:05,340 --> 00:02:10,709
properly in a bit to set the stage let's

00:02:08,729 --> 00:02:11,520
provide some background on the app that

00:02:10,709 --> 00:02:13,260
we work on

00:02:11,520 --> 00:02:13,680
it's a servicing application they're

00:02:13,260 --> 00:02:16,469
about

00:02:13,680 --> 00:02:18,480
50 million or so registered users those

00:02:16,469 --> 00:02:21,659
customers can pay their bills view their

00:02:18,480 --> 00:02:23,219
transactions report fraud etc and there

00:02:21,659 --> 00:02:24,840
are multiple account types that show up

00:02:23,219 --> 00:02:26,939
in the application so credit cards

00:02:24,840 --> 00:02:29,670
checking accounts auto loan savings

00:02:26,939 --> 00:02:32,040
accounts etc a lot of developers and

00:02:29,670 --> 00:02:34,439
teams contribute to this app this is

00:02:32,040 --> 00:02:36,719
where the aircraft carrier analogy comes

00:02:34,439 --> 00:02:38,549
in we can think of the app itself like

00:02:36,719 --> 00:02:40,379
the aircraft carrier and the independent

00:02:38,549 --> 00:02:43,139
teams flying their own aircrafts to

00:02:40,379 --> 00:02:45,120
deliver value to customers so a scalable

00:02:43,139 --> 00:02:47,040
federated operating model model is

00:02:45,120 --> 00:02:48,540
critical for us teams need to operate

00:02:47,040 --> 00:02:50,489
independently without breaking each

00:02:48,540 --> 00:02:52,439
other's stuff while delivering what

00:02:50,489 --> 00:02:55,319
feels like a cohesive seamless user

00:02:52,439 --> 00:02:57,209
experience in a single page app at the

00:02:55,319 --> 00:02:59,669
outset of this journey the entire app

00:02:57,209 --> 00:03:02,189
was running angularjs 1.3 and a

00:02:59,669 --> 00:03:03,870
significant portion of it still is we

00:03:02,189 --> 00:03:05,760
installed the component polyfill a while

00:03:03,870 --> 00:03:08,159
back which allows folks to think in a

00:03:05,760 --> 00:03:10,579
more angular mindset but we really want

00:03:08,159 --> 00:03:12,329
to get to angular and retire angularjs

00:03:10,579 --> 00:03:13,980
something interesting about this

00:03:12,329 --> 00:03:16,349
application lazy loading has been

00:03:13,980 --> 00:03:18,659
required since day one even even as an

00:03:16,349 --> 00:03:20,669
angularjs app because there was too much

00:03:18,659 --> 00:03:22,560
to ship to the user all at once so we've

00:03:20,669 --> 00:03:25,680
wired up lazy loading with UI router

00:03:22,560 --> 00:03:27,359
extras future states OC lazy load and

00:03:25,680 --> 00:03:29,819
that's using require.js behind the

00:03:27,359 --> 00:03:31,590
scenes find us afterwards if you're

00:03:29,819 --> 00:03:33,540
interested in talking about single page

00:03:31,590 --> 00:03:35,549
apps versus multi page apps but for

00:03:33,540 --> 00:03:38,310
today let's assume we're talking about a

00:03:35,549 --> 00:03:40,139
single page application we tried upgrade

00:03:38,310 --> 00:03:43,560
module on this project starting in early

00:03:40,139 --> 00:03:46,259
2017 and then last year after ng-conf

00:03:43,560 --> 00:03:48,259
when downgrade module was introduced we

00:03:46,259 --> 00:03:50,699
tried that as well with limited success

00:03:48,259 --> 00:03:52,620
and when we started this migration we

00:03:50,699 --> 00:03:55,079
had nine source code repositories for

00:03:52,620 --> 00:03:56,849
this application when James talks we'll

00:03:55,079 --> 00:03:58,409
hear about what that means and some

00:03:56,849 --> 00:04:00,209
alternative approaches that we've been

00:03:58,409 --> 00:04:02,759
adopting in terms of source code

00:04:00,209 --> 00:04:04,409
management so with that background how

00:04:02,759 --> 00:04:06,299
do we take this critical application

00:04:04,409 --> 00:04:08,009
from a starting point and turn the

00:04:06,299 --> 00:04:12,419
aircraft carrier towards a modern

00:04:08,009 --> 00:04:13,799
scalable angular app for the first part

00:04:12,419 --> 00:04:16,500
of the story I'll talk about our

00:04:13,799 --> 00:04:18,060
elements base migration strategy real

00:04:16,500 --> 00:04:19,859
quick I do want to say that we're not

00:04:18,060 --> 00:04:21,900
asserting that upgrade module downgrade

00:04:19,859 --> 00:04:24,570
module iframes or whatever you do our

00:04:21,900 --> 00:04:26,520
bad things this isn't supposed to be a

00:04:24,570 --> 00:04:27,450
controversial talk just an informational

00:04:26,520 --> 00:04:28,680
one we're

00:04:27,450 --> 00:04:31,080
just sharing a story about something

00:04:28,680 --> 00:04:33,270
that works for us so with that let's

00:04:31,080 --> 00:04:36,690
dive into using elements for angular

00:04:33,270 --> 00:04:38,580
migration with all of the available

00:04:36,690 --> 00:04:41,790
options for migration how do we choose a

00:04:38,580 --> 00:04:44,580
strategy we tried to narrow down to some

00:04:41,790 --> 00:04:46,170
key factors for comparison developer

00:04:44,580 --> 00:04:48,000
understanding was critical for us to

00:04:46,170 --> 00:04:49,890
echo Igor's point from the keynote

00:04:48,000 --> 00:04:52,290
yesterday we want developers to love

00:04:49,890 --> 00:04:54,450
building this app so how do we support

00:04:52,290 --> 00:04:56,340
people writing angular or angularjs code

00:04:54,450 --> 00:04:59,190
when it makes sense with the minimum

00:04:56,340 --> 00:05:00,660
cognitive overhead secondly we want to

00:04:59,190 --> 00:05:02,400
introduce angular with the lowest

00:05:00,660 --> 00:05:03,570
possible effort and without breaking

00:05:02,400 --> 00:05:05,670
things

00:05:03,570 --> 00:05:07,290
if you've read victor savkin x' blogs or

00:05:05,670 --> 00:05:09,020
a book on upgrade strategies we

00:05:07,290 --> 00:05:11,700
considered vertical and horizontal

00:05:09,020 --> 00:05:13,410
ultimately deciding to upgrade from the

00:05:11,700 --> 00:05:17,040
leaf nodes and then move up to the root

00:05:13,410 --> 00:05:19,710
component to keep things safe next

00:05:17,040 --> 00:05:21,660
before angularjs or angular can do their

00:05:19,710 --> 00:05:23,580
magic they need to be bootstraps and

00:05:21,660 --> 00:05:25,590
before they can be bootstraps they need

00:05:23,580 --> 00:05:27,000
to be loaded some of the questions we

00:05:25,590 --> 00:05:28,860
wanted to answer here include what's

00:05:27,000 --> 00:05:30,870
bootstrapping what what needs to be

00:05:28,860 --> 00:05:33,420
loaded first how do we limit framework

00:05:30,870 --> 00:05:34,950
mixing in our source code and since we

00:05:33,420 --> 00:05:36,630
were already doing lazy loading and

00:05:34,950 --> 00:05:39,510
angularjs there were a lot of

00:05:36,630 --> 00:05:41,460
implications here rendering and change

00:05:39,510 --> 00:05:43,020
detection obviously important how do we

00:05:41,460 --> 00:05:45,900
get angular components in angularjs

00:05:43,020 --> 00:05:48,120
templates and or vice versa and once you

00:05:45,900 --> 00:05:50,220
get both frameworks components on the

00:05:48,120 --> 00:05:52,020
screen how do they update each other and

00:05:50,220 --> 00:05:55,530
are there any performance considerations

00:05:52,020 --> 00:05:56,990
to keep in mind then there's dependency

00:05:55,530 --> 00:05:59,160
injection one of the key features that

00:05:56,990 --> 00:06:03,540
angularjs introduced to front-end

00:05:59,160 --> 00:06:06,060
development deciding how or if or when

00:06:03,540 --> 00:06:07,590
to share injectables is important how do

00:06:06,060 --> 00:06:09,270
we keep the coupling light and again

00:06:07,590 --> 00:06:11,370
limit how much our code needs to know

00:06:09,270 --> 00:06:13,770
about mixing frameworks and then finally

00:06:11,370 --> 00:06:15,840
routing can we have both UI router and

00:06:13,770 --> 00:06:18,120
the angular router running together and

00:06:15,840 --> 00:06:20,220
if so how do we determine which one of

00:06:18,120 --> 00:06:22,680
those things handles a given navigation

00:06:20,220 --> 00:06:23,910
event when we look at upgrade module and

00:06:22,680 --> 00:06:25,260
downgrade module I'm going to skip

00:06:23,910 --> 00:06:27,150
routing because we found that the

00:06:25,260 --> 00:06:29,070
answers to our questions were mostly the

00:06:27,150 --> 00:06:30,360
same between frameworks but we will

00:06:29,070 --> 00:06:33,840
share it later because we think the

00:06:30,360 --> 00:06:36,270
approach is pretty cool so upgrade

00:06:33,840 --> 00:06:37,860
module first path available to us let's

00:06:36,270 --> 00:06:40,400
look at how it stacks up with our key

00:06:37,860 --> 00:06:40,400
criteria

00:06:40,919 --> 00:06:45,130
let's start by looking through the lens

00:06:42,970 --> 00:06:48,400
of our most important factor developer

00:06:45,130 --> 00:06:51,250
understanding taking a look at the

00:06:48,400 --> 00:06:53,650
upgrade module docks there's a lot to

00:06:51,250 --> 00:06:55,990
wrap your head around if we look at

00:06:53,650 --> 00:06:58,180
point seven point two we can see that

00:06:55,990 --> 00:07:01,210
attributes in angularjs templates use

00:06:58,180 --> 00:07:04,330
kabab case while attributes in angularjs

00:07:01,210 --> 00:07:06,039
templates must use camel case that

00:07:04,330 --> 00:07:07,840
doesn't make sense

00:07:06,039 --> 00:07:09,310
this is an unfair joke and I apologize

00:07:07,840 --> 00:07:11,470
to the amazing folks that give us such

00:07:09,310 --> 00:07:13,449
wonderful and thorough documentation I

00:07:11,470 --> 00:07:15,490
probably should have just opened a PR to

00:07:13,449 --> 00:07:17,110
correct this minor typo but it served

00:07:15,490 --> 00:07:19,449
the purpose of this presentation so I

00:07:17,110 --> 00:07:22,120
did not do that but apologize to the

00:07:19,449 --> 00:07:23,590
docs team there's a ton of smart folks

00:07:22,120 --> 00:07:25,690
building apps in the angular community

00:07:23,590 --> 00:07:28,360
but for me keeping nine points in my

00:07:25,690 --> 00:07:31,000
head at any given time as well as my

00:07:28,360 --> 00:07:32,470
application logic was a challenge so if

00:07:31,000 --> 00:07:34,659
you're like me when working with upgrade

00:07:32,470 --> 00:07:35,830
module and your app doesn't do what what

00:07:34,659 --> 00:07:40,870
you expect you might find yourself

00:07:35,830 --> 00:07:45,039
asking I'm gonna leave that there for a

00:07:40,870 --> 00:07:46,479
minute cuz because I like it alright

00:07:45,039 --> 00:07:49,180
what about our next key factor

00:07:46,479 --> 00:07:50,979
bootstrapping so this is an example

00:07:49,180 --> 00:07:52,960
stolen from the docs we could see that

00:07:50,979 --> 00:07:55,930
angular is responsible for bootstrapping

00:07:52,960 --> 00:07:58,449
angularjs with upgrade module this

00:07:55,930 --> 00:08:00,490
dictates our loading sequence introduces

00:07:58,449 --> 00:08:02,770
some coupling and framework mixing and

00:08:00,490 --> 00:08:05,080
means that introducing angular is a

00:08:02,770 --> 00:08:08,469
global change impacting the entire

00:08:05,080 --> 00:08:10,690
application increasing the impact also

00:08:08,469 --> 00:08:12,580
this one-liner may not seem like a big

00:08:10,690 --> 00:08:14,409
deal from a reasoning perspective but

00:08:12,580 --> 00:08:16,570
when your angularjs app is already

00:08:14,409 --> 00:08:18,550
supporting lazy loading figuring out how

00:08:16,570 --> 00:08:21,250
to lazily load and instantiate angularjs

00:08:18,550 --> 00:08:24,400
modules and components etc can be a

00:08:21,250 --> 00:08:26,889
pretty confusing thing what about

00:08:24,400 --> 00:08:28,740
rendering and change detection well the

00:08:26,889 --> 00:08:31,719
good news is with upgrade module

00:08:28,740 --> 00:08:33,490
angularjs runs in the angular zone so

00:08:31,719 --> 00:08:35,979
change detection just magically works

00:08:33,490 --> 00:08:38,950
there is a trade-off here though any

00:08:35,979 --> 00:08:40,839
change runs both the angularjs digest

00:08:38,950 --> 00:08:42,729
cycle and angular change detection

00:08:40,839 --> 00:08:44,589
creating a potential performance

00:08:42,729 --> 00:08:47,529
bottleneck but maybe that's a trade-off

00:08:44,589 --> 00:08:49,959
that we can accept with rendering it's a

00:08:47,529 --> 00:08:51,820
little bit more complicated to make one

00:08:49,959 --> 00:08:53,950
frameworks components available in

00:08:51,820 --> 00:08:55,780
another's templates we use utility

00:08:53,950 --> 00:08:58,960
engines like downgrade component here

00:08:55,780 --> 00:09:00,760
and map inputs and outputs so this was a

00:08:58,960 --> 00:09:03,040
little bit more mixed framework code

00:09:00,760 --> 00:09:08,140
than we really wanted and contributed to

00:09:03,040 --> 00:09:10,240
cognitive overhead so in terms of di we

00:09:08,140 --> 00:09:12,730
made a conscious choice to only allow di

00:09:10,240 --> 00:09:14,650
Interop with angularjs services being

00:09:12,730 --> 00:09:16,960
made available and angular we will get

00:09:14,650 --> 00:09:18,580
to that choice later but any interest of

00:09:16,960 --> 00:09:20,890
time we're only going to look at that

00:09:18,580 --> 00:09:23,230
case with upgrade module when evaluating

00:09:20,890 --> 00:09:25,270
di just know that sharing angular

00:09:23,230 --> 00:09:27,370
injectibles back to angularjs requires

00:09:25,270 --> 00:09:29,020
we're calling a utility function and

00:09:27,370 --> 00:09:32,050
again adding some mixed framework code

00:09:29,020 --> 00:09:34,360
to your source code upgrade module makes

00:09:32,050 --> 00:09:36,550
the angularjs injector available so we

00:09:34,360 --> 00:09:38,670
can simply provide a factory that grabs

00:09:36,550 --> 00:09:41,050
injectables from the angularjs injector

00:09:38,670 --> 00:09:43,600
this is a perfectly reasonable well

00:09:41,050 --> 00:09:46,480
isolated thing to do with the minor

00:09:43,600 --> 00:09:48,670
downside that our NG module is now aware

00:09:46,480 --> 00:09:51,220
of angularjs things when we look at

00:09:48,670 --> 00:09:53,200
elements you'll see how we use the same

00:09:51,220 --> 00:09:55,450
principle of runtime availability of the

00:09:53,200 --> 00:09:56,980
angularjs injector but in a slightly

00:09:55,450 --> 00:09:59,050
different way that doesn't require our

00:09:56,980 --> 00:10:01,510
NG module to know about upgraded

00:09:59,050 --> 00:10:03,900
injectables again limiting the framework

00:10:01,510 --> 00:10:03,900
mixing

00:10:11,019 --> 00:10:15,410
all right and then last year we saw the

00:10:13,250 --> 00:10:17,180
angular team introduced downgrade module

00:10:15,410 --> 00:10:20,300
which was a tool for kind of flipping

00:10:17,180 --> 00:10:22,010
the control back to angularjs so maybe

00:10:20,300 --> 00:10:23,930
this was the solution to our challenges

00:10:22,010 --> 00:10:25,970
I don't have time to do a deep dive on

00:10:23,930 --> 00:10:29,420
each key factor but let's take a quick

00:10:25,970 --> 00:10:31,550
high-level look on the plus side with

00:10:29,420 --> 00:10:33,769
downgrade module we can lazily load in

00:10:31,550 --> 00:10:35,570
bootstrap angular which allows that leaf

00:10:33,769 --> 00:10:37,519
node up approach that we would like to

00:10:35,570 --> 00:10:39,769
take and limits the impact of

00:10:37,519 --> 00:10:41,810
introducing angular it does however

00:10:39,769 --> 00:10:44,209
require that we declare the downgraded

00:10:41,810 --> 00:10:46,940
module as a dependency of our angularjs

00:10:44,209 --> 00:10:49,579
module so we have again framework mixing

00:10:46,940 --> 00:10:52,070
in our source code change detection and

00:10:49,579 --> 00:10:53,810
D I get a neutral emoji downgrade

00:10:52,070 --> 00:10:56,089
mitigates the performance concern of

00:10:53,810 --> 00:10:58,820
change detection because angularjs is

00:10:56,089 --> 00:11:01,399
not running in the angular zone but we

00:10:58,820 --> 00:11:03,290
need to explicitly initiate cross

00:11:01,399 --> 00:11:05,149
framework change detection which

00:11:03,290 --> 00:11:07,579
increases the cognitive load and again

00:11:05,149 --> 00:11:11,120
mixes framework synchronization into our

00:11:07,579 --> 00:11:13,069
code in terms of D I downgrade modules

00:11:11,120 --> 00:11:16,279
benefit of lazily loading angular things

00:11:13,069 --> 00:11:18,410
comes with the trade-off each downgraded

00:11:16,279 --> 00:11:20,750
module is treated as a root meaning that

00:11:18,410 --> 00:11:24,319
if we downgrade multiple modules we need

00:11:20,750 --> 00:11:26,569
to explicitly pass the root injector to

00:11:24,319 --> 00:11:28,819
our module factories create functions in

00:11:26,569 --> 00:11:30,649
fairness we do have to do the same thing

00:11:28,819 --> 00:11:32,540
with our elements approach which is why

00:11:30,649 --> 00:11:35,089
this is a neutral rating with either

00:11:32,540 --> 00:11:37,639
downgrade or elements you can and should

00:11:35,089 --> 00:11:39,589
take that boilerplate concern off of

00:11:37,639 --> 00:11:42,440
developers plates with the schematics

00:11:39,589 --> 00:11:44,870
magic and James we'll talk about that in

00:11:42,440 --> 00:11:46,519
a minute on the negative side when we

00:11:44,870 --> 00:11:49,519
were starting this effort an app could

00:11:46,519 --> 00:11:50,959
only have one downgraded module this was

00:11:49,519 --> 00:11:52,940
kind of the hard stop for us

00:11:50,959 --> 00:11:55,100
when considering downgrade module given

00:11:52,940 --> 00:11:57,110
our contribution model and I think

00:11:55,100 --> 00:11:59,810
support for multiple downgraded modules

00:11:57,110 --> 00:12:01,970
landed in October November of last year

00:11:59,810 --> 00:12:04,490
but we were already well on our way with

00:12:01,970 --> 00:12:06,110
elements in terms of rendering we still

00:12:04,490 --> 00:12:07,870
would have needed to use upgrade and

00:12:06,110 --> 00:12:10,940
downgrade component utility functions

00:12:07,870 --> 00:12:13,459
and use those wrappers which increases

00:12:10,940 --> 00:12:15,490
the cognitive overhead and again mixes

00:12:13,459 --> 00:12:17,839
framework concerns into our source code

00:12:15,490 --> 00:12:19,850
lastly our most important factor of

00:12:17,839 --> 00:12:21,649
developer understanding is not helped

00:12:19,850 --> 00:12:22,390
much here because the frameworks are

00:12:21,649 --> 00:12:26,260
still interact

00:12:22,390 --> 00:12:28,960
quite a bit but then Along Came the

00:12:26,260 --> 00:12:30,760
elements package this probably is not

00:12:28,960 --> 00:12:32,260
the use case that you've heard about in

00:12:30,760 --> 00:12:33,970
the context developments more likely

00:12:32,260 --> 00:12:36,430
you've heard about dynamic content or

00:12:33,970 --> 00:12:38,290
putting angular stuff in an app owned by

00:12:36,430 --> 00:12:40,030
a different framework but if elements

00:12:38,290 --> 00:12:42,010
means that you can put angular things in

00:12:40,030 --> 00:12:45,640
an app owned by another framework why

00:12:42,010 --> 00:12:47,770
not an angularjs app so I asked Rob

00:12:45,640 --> 00:12:49,420
Wormald this question last year and he

00:12:47,770 --> 00:12:51,190
said yeah you could probably do that

00:12:49,420 --> 00:12:52,750
that's not really what the tool is for

00:12:51,190 --> 00:12:56,580
but go ahead give it a shot

00:12:52,750 --> 00:12:58,900
so let's look how it fit our goals

00:12:56,580 --> 00:13:00,700
before diving into migration with

00:12:58,900 --> 00:13:02,410
elements just a quick overview of

00:13:00,700 --> 00:13:04,000
elements on their own hopefully some of

00:13:02,410 --> 00:13:05,530
you saw a man Fritz talk yesterday

00:13:04,000 --> 00:13:05,800
explained elements much better than I

00:13:05,530 --> 00:13:07,620
could

00:13:05,800 --> 00:13:10,600
I think he's got another workshop today

00:13:07,620 --> 00:13:12,010
advise checking that out we're limited

00:13:10,600 --> 00:13:13,810
on time we want to focus on the upgrade

00:13:12,010 --> 00:13:15,510
strategy so I'm gonna do my best to

00:13:13,810 --> 00:13:18,010
describe elements in two minutes

00:13:15,510 --> 00:13:20,080
what are elements in short they are

00:13:18,010 --> 00:13:22,750
angular components packaged as native

00:13:20,080 --> 00:13:25,060
custom elements we can think of elements

00:13:22,750 --> 00:13:27,100
kind of like miniature angular apps the

00:13:25,060 --> 00:13:29,440
host app and consuming developers don't

00:13:27,100 --> 00:13:32,230
need to know about angular they can just

00:13:29,440 --> 00:13:33,880
put a Dom tag like regular old custom

00:13:32,230 --> 00:13:36,250
elements into their template and expect

00:13:33,880 --> 00:13:39,370
it to work so how does this work

00:13:36,250 --> 00:13:41,860
elements bridges angular things - native

00:13:39,370 --> 00:13:44,620
API so angular semantics and constructs

00:13:41,860 --> 00:13:47,410
like input and output are mapped to

00:13:44,620 --> 00:13:49,540
native browser api's that any app can

00:13:47,410 --> 00:13:52,300
understand and consume to further

00:13:49,540 --> 00:13:54,580
illustrate that elements are separate

00:13:52,300 --> 00:13:56,500
and apart from angular we can look at

00:13:54,580 --> 00:13:58,360
the Global's that are exposed in all

00:13:56,500 --> 00:14:00,640
modern browsers and can be polyfilled

00:13:58,360 --> 00:14:03,160
and others where we have this custom

00:14:00,640 --> 00:14:05,110
elements define function that accepts a

00:14:03,160 --> 00:14:07,060
tag name and a class that usually

00:14:05,110 --> 00:14:09,820
extends an HTML element class like a

00:14:07,060 --> 00:14:12,250
paragraph it's almost a lot like

00:14:09,820 --> 00:14:13,900
creating angularjs directives back in

00:14:12,250 --> 00:14:16,420
the good old days you call a function

00:14:13,900 --> 00:14:18,610
you pass a tag in a configuration object

00:14:16,420 --> 00:14:21,000
and then you can start using your very

00:14:18,610 --> 00:14:23,500
own HTML elements in your application

00:14:21,000 --> 00:14:25,300
the angular magic happens here by

00:14:23,500 --> 00:14:27,900
importing and invoking the custom

00:14:25,300 --> 00:14:30,100
elements excuse me the elements package

00:14:27,900 --> 00:14:32,320
create custom element function and

00:14:30,100 --> 00:14:34,000
passing that return value to the custom

00:14:32,320 --> 00:14:36,500
elements define the function as the

00:14:34,000 --> 00:14:38,420
second argument again form or embed

00:14:36,500 --> 00:14:40,310
info please check out the guide and

00:14:38,420 --> 00:14:44,090
hopefully you got to see Manfred stock

00:14:40,310 --> 00:14:46,070
yesterday alright so how does this

00:14:44,090 --> 00:14:48,800
actually help with our key migration

00:14:46,070 --> 00:14:50,870
considerations migration with elements

00:14:48,800 --> 00:14:53,690
really shines in the area of developer

00:14:50,870 --> 00:14:55,460
understanding and the mental model since

00:14:53,690 --> 00:14:56,930
elements are plain browser native

00:14:55,460 --> 00:14:58,910
components and they bootstrap and

00:14:56,930 --> 00:15:00,170
destroy themselves we don't need to

00:14:58,910 --> 00:15:01,910
think about which framework is

00:15:00,170 --> 00:15:04,310
bootstrapping the other one how to

00:15:01,910 --> 00:15:05,870
upgrade and downgrade components and how

00:15:04,310 --> 00:15:07,940
and when to invoke change detection

00:15:05,870 --> 00:15:10,520
routines to sync across the frameworks

00:15:07,940 --> 00:15:12,740
we simply build an element put that

00:15:10,520 --> 00:15:14,450
elements tag in our template and make

00:15:12,740 --> 00:15:16,640
sure the element bundle gets loaded at

00:15:14,450 --> 00:15:20,090
runtime and that's it

00:15:16,640 --> 00:15:24,160
and this makes Ron a little bit happier

00:15:20,090 --> 00:15:24,160
because it's simple to understand

00:15:24,340 --> 00:15:29,180
alright so in terms of loading how do we

00:15:26,780 --> 00:15:32,060
actually get elements bundles into our

00:15:29,180 --> 00:15:34,310
application well you simply use some

00:15:32,060 --> 00:15:36,140
imperative API to load the correct UMD

00:15:34,310 --> 00:15:38,420
bundle in our case we already had OC

00:15:36,140 --> 00:15:40,580
lazy load and require Jas wired up so

00:15:38,420 --> 00:15:43,070
that's what we use most often we do this

00:15:40,580 --> 00:15:44,990
in resolve blocks in our UI router state

00:15:43,070 --> 00:15:47,240
definition so we have an angularjs route

00:15:44,990 --> 00:15:49,280
we put a resolve statement in there and

00:15:47,240 --> 00:15:51,950
then we use OC lazy load to go grab the

00:15:49,280 --> 00:15:53,270
bundle that we want to use in Rob's talk

00:15:51,950 --> 00:15:55,010
yesterday you saw that there are maybe

00:15:53,270 --> 00:15:57,110
more elegant ways to do this with

00:15:55,010 --> 00:15:58,490
dynamic imports but at the end of the

00:15:57,110 --> 00:16:01,220
day you need something that's gonna say

00:15:58,490 --> 00:16:02,750
go ahead and load this bundle let's take

00:16:01,220 --> 00:16:07,400
a look at what is actually in that

00:16:02,750 --> 00:16:08,960
bundle in terms of ng module and

00:16:07,400 --> 00:16:10,970
components and all that good stuff from

00:16:08,960 --> 00:16:13,910
angular nothing changes from a plain old

00:16:10,970 --> 00:16:16,010
angular app the bootstrapping process

00:16:13,910 --> 00:16:18,680
for our elements module has no knowledge

00:16:16,010 --> 00:16:21,920
of angularjs which is a key point for us

00:16:18,680 --> 00:16:23,870
in the main TS for any given module we

00:16:21,920 --> 00:16:26,480
hook in to the on at bootstrapped life

00:16:23,870 --> 00:16:28,250
cycle event ensuring the shared shared

00:16:26,480 --> 00:16:30,530
injector is available more on that in a

00:16:28,250 --> 00:16:32,810
minute from there we create a module ref

00:16:30,530 --> 00:16:35,240
by invoking the create method and passed

00:16:32,810 --> 00:16:36,950
the shared injector then we invoke the

00:16:35,240 --> 00:16:38,870
only method of our team's elements

00:16:36,950 --> 00:16:41,150
module create and define elements

00:16:38,870 --> 00:16:43,610
passing that injector and we can look at

00:16:41,150 --> 00:16:45,230
that method in more detail it loops

00:16:43,610 --> 00:16:47,450
through the angular components that we

00:16:45,230 --> 00:16:50,010
want to expose as elements defines the

00:16:47,450 --> 00:16:51,720
custom element with the shared injector

00:16:50,010 --> 00:16:54,000
and the strategy factory to wire up

00:16:51,720 --> 00:16:55,550
automatic change detection and we'll

00:16:54,000 --> 00:16:57,870
look at that in more detail in a second

00:16:55,550 --> 00:17:00,840
then we invoke the custom elements that

00:16:57,870 --> 00:17:03,300
define function and create custom

00:17:00,840 --> 00:17:05,820
element to make the the tag available to

00:17:03,300 --> 00:17:07,680
the dom and hook up angular and in terms

00:17:05,820 --> 00:17:10,459
of loading again we can lazily load this

00:17:07,680 --> 00:17:10,459
whenever we want

00:17:11,660 --> 00:17:15,930
what about rendering once we've

00:17:14,339 --> 00:17:18,089
registered our custom element we can

00:17:15,930 --> 00:17:20,250
simply drop it into our angularjs

00:17:18,089 --> 00:17:21,540
template there's no utility functions

00:17:20,250 --> 00:17:23,370
that we need to call to make angular

00:17:21,540 --> 00:17:25,949
understand angularjs things or vice

00:17:23,370 --> 00:17:27,720
versa we simply make sure that the

00:17:25,949 --> 00:17:29,970
element bundle is loaded and we can use

00:17:27,720 --> 00:17:34,290
the tag in our template which is a fair

00:17:29,970 --> 00:17:36,150
amount simpler for change detection we

00:17:34,290 --> 00:17:40,500
do need to do a little bit of extra work

00:17:36,150 --> 00:17:42,210
in angularjs 17.3 some helpers were

00:17:40,500 --> 00:17:43,740
introduced for binding properties and

00:17:42,210 --> 00:17:46,410
events to custom elements from

00:17:43,740 --> 00:17:48,360
surrounding angularjs code but as I

00:17:46,410 --> 00:17:51,060
mentioned we're on 1.3 we're not

00:17:48,360 --> 00:17:53,220
investing in any angularjs upgrade so we

00:17:51,060 --> 00:17:55,290
use the ng custom element library that

00:17:53,220 --> 00:17:58,020
our pal james wrote which gives us the

00:17:55,290 --> 00:18:01,140
same functionality and is available on

00:17:58,020 --> 00:18:03,390
NPM additionally when we create our

00:18:01,140 --> 00:18:05,520
custom element we're passing a strategy

00:18:03,390 --> 00:18:08,340
implementation which wire's our element

00:18:05,520 --> 00:18:10,200
up to the root angular apps zone this

00:18:08,340 --> 00:18:11,910
achieves the same automatic change

00:18:10,200 --> 00:18:14,250
detection effect that you get with

00:18:11,910 --> 00:18:16,350
upgrade module but it also provides the

00:18:14,250 --> 00:18:19,050
downgrade module perf benefit of running

00:18:16,350 --> 00:18:21,210
angular change detection for one

00:18:19,050 --> 00:18:22,680
framework without necessarily triggering

00:18:21,210 --> 00:18:23,970
the other so they're isolated from one

00:18:22,680 --> 00:18:28,410
another the same way they are with

00:18:23,970 --> 00:18:31,260
downgrade module what about di so there

00:18:28,410 --> 00:18:33,750
are three cases here sharing injectables

00:18:31,260 --> 00:18:36,000
between elements modules exposing

00:18:33,750 --> 00:18:38,790
angularjs services to angular things and

00:18:36,000 --> 00:18:40,350
vice-versa we chose not to bridge

00:18:38,790 --> 00:18:42,030
angular things back to angler j/s

00:18:40,350 --> 00:18:44,100
because we want to encourage retirement

00:18:42,030 --> 00:18:47,100
at the angularjs code and it makes our

00:18:44,100 --> 00:18:49,260
head hurt in the case of sharing between

00:18:47,100 --> 00:18:50,970
angular modules we follow a very similar

00:18:49,260 --> 00:18:53,850
strategy to the one now supported by

00:18:50,970 --> 00:18:56,760
downgrade module we bootstrap an angular

00:18:53,850 --> 00:18:58,590
app that creates a root di container we

00:18:56,760 --> 00:19:00,990
expose that root injector on a global

00:18:58,590 --> 00:19:03,120
variable then when we bootstrap our

00:19:00,990 --> 00:19:05,400
elements modules we pass that shared and

00:19:03,120 --> 00:19:07,559
to the module factories create function

00:19:05,400 --> 00:19:09,570
and that sets up the same relationship

00:19:07,559 --> 00:19:11,400
that you might expect in any regular old

00:19:09,570 --> 00:19:14,370
angular app where you have hierarchical

00:19:11,400 --> 00:19:16,350
injectors what about sharing angularjs

00:19:14,370 --> 00:19:19,140
things with angular things for example

00:19:16,350 --> 00:19:21,900
if I have an angularjs service that

00:19:19,140 --> 00:19:23,460
contains my internationalized content do

00:19:21,900 --> 00:19:26,010
I need to rewrite that before I can

00:19:23,460 --> 00:19:28,980
create any angular components that rely

00:19:26,010 --> 00:19:31,140
on translations for this case we created

00:19:28,980 --> 00:19:33,030
a created and angular framework bridge

00:19:31,140 --> 00:19:35,040
service that leverages a very similar

00:19:33,030 --> 00:19:37,260
strategy to the upgrade package and the

00:19:35,040 --> 00:19:39,360
runtime availability of the angularjs

00:19:37,260 --> 00:19:41,570
injector let's look at that in detail

00:19:39,360 --> 00:19:44,670
real quick

00:19:41,570 --> 00:19:47,040
so our framework bridge service has a

00:19:44,670 --> 00:19:49,260
method called get angularjs resource and

00:19:47,040 --> 00:19:51,630
that just grabs injectable instances at

00:19:49,260 --> 00:19:53,970
runtime so we can bind them to props of

00:19:51,630 --> 00:19:56,550
other angular injectibles or properties

00:19:53,970 --> 00:19:58,440
of our components our ng module here

00:19:56,550 --> 00:20:01,320
again has no knowledge of angularjs

00:19:58,440 --> 00:20:03,570
which is a key point for us you might be

00:20:01,320 --> 00:20:05,400
asking isn't this like the framework

00:20:03,570 --> 00:20:06,900
mixing thing that you want to avoid but

00:20:05,400 --> 00:20:08,550
the key difference here is that the

00:20:06,900 --> 00:20:11,190
framework bridge is an angular service

00:20:08,550 --> 00:20:13,650
the fact that it talks to angularjs is

00:20:11,190 --> 00:20:15,390
just an implementation detail and the

00:20:13,650 --> 00:20:17,190
framework bridge could be doing anything

00:20:15,390 --> 00:20:19,280
behind the scenes the code leveraging

00:20:17,190 --> 00:20:21,870
the bridge doesn't need to know about it

00:20:19,280 --> 00:20:24,270
so we offer a couple patterns here we

00:20:21,870 --> 00:20:26,580
can expose the angularjs injectibles

00:20:24,270 --> 00:20:28,530
directly on our components or we can

00:20:26,580 --> 00:20:30,870
wrap them in angular injectibles that

00:20:28,530 --> 00:20:34,500
act as facades and each of these has its

00:20:30,870 --> 00:20:36,450
benefits and trade-offs in a picture

00:20:34,500 --> 00:20:38,670
exposing directly might look like this

00:20:36,450 --> 00:20:40,530
we use the framework bridge to grab an

00:20:38,670 --> 00:20:44,670
angularjs injectable and bind it to a

00:20:40,530 --> 00:20:46,679
property of our component in the

00:20:44,670 --> 00:20:49,320
wrapping strategy we create angular

00:20:46,679 --> 00:20:51,360
equivalents of our angularjs injectables

00:20:49,320 --> 00:20:53,190
but those injectables are simply facades

00:20:51,360 --> 00:20:55,860
they delegate directly to the angularjs

00:20:53,190 --> 00:20:58,290
injectibles this is nice because it

00:20:55,860 --> 00:21:00,179
means our components are unaware of the

00:20:58,290 --> 00:21:01,830
bridging so when we're ready and we have

00:21:00,179 --> 00:21:03,600
the appropriate angular services

00:21:01,830 --> 00:21:05,490
migrated we can remove the bridging

00:21:03,600 --> 00:21:09,150
without any impact on our individual

00:21:05,490 --> 00:21:10,410
component code mentioned earlier that I

00:21:09,150 --> 00:21:12,030
was skipping routing an upgrade and

00:21:10,410 --> 00:21:14,400
downgrade module because it was similar

00:21:12,030 --> 00:21:16,530
in all approaches we were not in a

00:21:14,400 --> 00:21:18,090
position to migrate all routes and

00:21:16,530 --> 00:21:20,610
one fell swoop we needed to move

00:21:18,090 --> 00:21:23,790
incremental e and run both ui-router and

00:21:20,610 --> 00:21:25,710
the angular router in a single app so

00:21:23,790 --> 00:21:28,230
how do we make it work first we put

00:21:25,710 --> 00:21:30,780
sibling elements on the page one is UI

00:21:28,230 --> 00:21:32,490
routers root UI view the other is

00:21:30,780 --> 00:21:35,070
treated as the angular routers root

00:21:32,490 --> 00:21:37,230
outlet from there we configure both UI

00:21:35,070 --> 00:21:39,720
router and the angular router with empty

00:21:37,230 --> 00:21:41,040
kind of catch-all routes when the

00:21:39,720 --> 00:21:43,500
angular router sees a route it doesn't

00:21:41,040 --> 00:21:45,300
recognize it renders simply an empty

00:21:43,500 --> 00:21:47,160
component and its outlet and the same

00:21:45,300 --> 00:21:49,440
goes for UI router so in all cases

00:21:47,160 --> 00:21:51,810
there's precisely one router handling a

00:21:49,440 --> 00:21:54,560
navigation event a big caveat here I

00:21:51,810 --> 00:21:57,300
have not seen the dollar location

00:21:54,560 --> 00:21:59,640
exposing that's going on in angular

00:21:57,300 --> 00:22:02,250
version 8 that might be way better and

00:21:59,640 --> 00:22:06,060
smarter than what we are doing but this

00:22:02,250 --> 00:22:08,000
approach works for us for now so in

00:22:06,060 --> 00:22:10,230
summary why would you choose to do this

00:22:08,000 --> 00:22:13,770
we found that it's simpler to reason

00:22:10,230 --> 00:22:15,720
about developers can understand what's

00:22:13,770 --> 00:22:17,700
going on focus on making things and

00:22:15,720 --> 00:22:19,260
delivering value rather than trying to

00:22:17,700 --> 00:22:21,720
freak to figure out which framework is

00:22:19,260 --> 00:22:24,090
doing what at any given time a lot of

00:22:21,720 --> 00:22:26,550
the simplicity comes from the good old

00:22:24,090 --> 00:22:28,560
principle of separating concerns so

00:22:26,550 --> 00:22:30,780
elements allows us to bootstrap and load

00:22:28,560 --> 00:22:32,940
angular and angularjs items whenever we

00:22:30,780 --> 00:22:35,400
want without one framework knowing about

00:22:32,940 --> 00:22:37,350
the other there's no wrapping components

00:22:35,400 --> 00:22:39,270
and the other frameworks conventions no

00:22:37,350 --> 00:22:41,760
wrappers to map upgrade component

00:22:39,270 --> 00:22:44,100
angularjs to outputs and angular outputs

00:22:41,760 --> 00:22:45,510
know creating angularjs directives for

00:22:44,100 --> 00:22:47,520
angular components via a downgrade

00:22:45,510 --> 00:22:50,610
component we simply slap a tag in the

00:22:47,520 --> 00:22:52,460
page and everything works we don't need

00:22:50,610 --> 00:22:55,080
to explicitly invoked change detection

00:22:52,460 --> 00:22:57,300
in either framework because we've got

00:22:55,080 --> 00:22:58,440
that Factory a strategy Factory that we

00:22:57,300 --> 00:23:01,530
implemented that makes that happen

00:22:58,440 --> 00:23:03,900
automatically and we don't we can inject

00:23:01,530 --> 00:23:06,480
angularjs dependencies into our angular

00:23:03,900 --> 00:23:09,270
code in a fully transparent way without

00:23:06,480 --> 00:23:12,030
impacting the existing angularjs code or

00:23:09,270 --> 00:23:13,820
our ng modules because of this

00:23:12,030 --> 00:23:16,230
separation we were able to make

00:23:13,820 --> 00:23:18,030
low-impact light touch changes to

00:23:16,230 --> 00:23:21,930
introduce angular if you want to learn

00:23:18,030 --> 00:23:23,820
more check out TJ Siemens medium post

00:23:21,930 --> 00:23:25,560
how Capital One is using angular

00:23:23,820 --> 00:23:28,650
elements to upgrade from angularjs to

00:23:25,560 --> 00:23:30,070
angular now making these changes in a

00:23:28,650 --> 00:23:31,960
situation where you have source code

00:23:30,070 --> 00:23:34,420
nine different repositories presents a

00:23:31,960 --> 00:23:37,120
whole new set of challenges which are

00:23:34,420 --> 00:23:38,260
agnostic to any framework so to talk

00:23:37,120 --> 00:23:39,730
about the strategies that we're

00:23:38,260 --> 00:23:41,860
employing to make that a little bit more

00:23:39,730 --> 00:23:50,100
convenient I'm gonna hand it over to

00:23:41,860 --> 00:23:52,540
James thanks Dylan

00:23:50,100 --> 00:23:54,460
cuz I'm a massive idiot I just drank all

00:23:52,540 --> 00:23:56,410
my drink while I was sat there so I'm

00:23:54,460 --> 00:23:58,000
suffering from conference throat a

00:23:56,410 --> 00:24:00,010
little bit so my voice may crack at

00:23:58,000 --> 00:24:02,770
various points I'll do my best to battle

00:24:00,010 --> 00:24:03,700
on this is Dylan's laptop so hopefully

00:24:02,770 --> 00:24:07,540
yeah cool

00:24:03,700 --> 00:24:09,160
so as Dylan mentioned when we first

00:24:07,540 --> 00:24:10,750
started this project it wasn't just a

00:24:09,160 --> 00:24:12,250
case of figuring out how do we make

00:24:10,750 --> 00:24:14,470
angular and angular Jess work how do we

00:24:12,250 --> 00:24:15,760
upgrade was also the case of dealing

00:24:14,470 --> 00:24:18,010
with the fact that we're building one

00:24:15,760 --> 00:24:20,230
application as you heard we have 50

00:24:18,010 --> 00:24:22,420
million users there's 300 developers

00:24:20,230 --> 00:24:24,300
working on this that implies a lot of

00:24:22,420 --> 00:24:26,710
hierarchy and a lot of cultural things

00:24:24,300 --> 00:24:28,090
just to go into making one application

00:24:26,710 --> 00:24:29,770
so it's not as simple as figuring out

00:24:28,090 --> 00:24:31,960
the technical details we have to figure

00:24:29,770 --> 00:24:34,450
out how we can work together to make

00:24:31,960 --> 00:24:37,330
this happen and the real out the reality

00:24:34,450 --> 00:24:38,830
is of those 300 developers not everybody

00:24:37,330 --> 00:24:41,110
is going to have the same in-depth

00:24:38,830 --> 00:24:43,360
understanding of all of the migration

00:24:41,110 --> 00:24:45,760
process so we need to be able to

00:24:43,360 --> 00:24:47,710
facilitate developers being effective

00:24:45,760 --> 00:24:50,080
and efficient not reinventing the wheel

00:24:47,710 --> 00:24:51,760
working together and not being exposed

00:24:50,080 --> 00:24:54,040
to necessarily every single

00:24:51,760 --> 00:24:56,410
implementation detail within disparate

00:24:54,040 --> 00:24:59,200
repos spread across the organization so

00:24:56,410 --> 00:25:01,420
I'm going to focus my section on code

00:24:59,200 --> 00:25:03,580
storage and code structure and how those

00:25:01,420 --> 00:25:05,800
actually impacts collaboration within an

00:25:03,580 --> 00:25:08,080
organization so it's highly related to

00:25:05,800 --> 00:25:10,240
again like the way we're phrasing

00:25:08,080 --> 00:25:12,610
framing this is this is our experience

00:25:10,240 --> 00:25:13,720
of doing this together so my name is

00:25:12,610 --> 00:25:18,130
James Tony I work for a company called

00:25:13,720 --> 00:25:19,720
Narwhal the unicorn of the sea and I

00:25:18,130 --> 00:25:21,130
have a passion for open source tooling

00:25:19,720 --> 00:25:23,440
I'm heavily involved in typescript so

00:25:21,130 --> 00:25:25,270
I'm a Microsoft MVP on the subject so

00:25:23,440 --> 00:25:26,770
I've worked with yes lint babble and

00:25:25,270 --> 00:25:29,980
prettier to support typescript in those

00:25:26,770 --> 00:25:32,140
projects now what we trying to help

00:25:29,980 --> 00:25:35,110
folks develop like Google Google is a

00:25:32,140 --> 00:25:36,580
little bit of an it's an example of the

00:25:35,110 --> 00:25:38,470
kind of things we approach things like

00:25:36,580 --> 00:25:40,630
Google is an extreme example of some of

00:25:38,470 --> 00:25:42,670
the best practices we try and promote so

00:25:40,630 --> 00:25:43,010
I've been working now with the Capital

00:25:42,670 --> 00:25:44,840
One for

00:25:43,010 --> 00:25:47,330
for about 11 months and it's been a

00:25:44,840 --> 00:25:48,710
really cool experience you can catch me

00:25:47,330 --> 00:25:50,960
online Jameson read our blog types of

00:25:48,710 --> 00:25:53,870
courses comm I occasionally do stuff

00:25:50,960 --> 00:25:56,990
online so let's talk about what

00:25:53,870 --> 00:25:58,790
enterprise team wants they want to not

00:25:56,990 --> 00:26:00,350
reinvent the wheel over and over and

00:25:58,790 --> 00:26:02,540
over again because that massively

00:26:00,350 --> 00:26:04,760
impacts both developer productivity and

00:26:02,540 --> 00:26:06,440
also a sense of well-being I feel like

00:26:04,760 --> 00:26:07,940
if you're looking at something which is

00:26:06,440 --> 00:26:10,580
almost identical to the thing you need

00:26:07,940 --> 00:26:11,960
and for reasons you can't control you

00:26:10,580 --> 00:26:13,310
have to re-implement that thing from

00:26:11,960 --> 00:26:15,110
scratch because certain things are

00:26:13,310 --> 00:26:16,580
slightly different that can that can be

00:26:15,110 --> 00:26:17,840
quite frustrating experience you want to

00:26:16,580 --> 00:26:20,210
build features which it can impact

00:26:17,840 --> 00:26:21,560
customer experience so we want to not

00:26:20,210 --> 00:26:24,290
reinvent the wheel we also want to be

00:26:21,560 --> 00:26:25,940
able to share things you want to develop

00:26:24,290 --> 00:26:27,590
things which are consistent across the

00:26:25,940 --> 00:26:30,920
organization so we want to be on brand

00:26:27,590 --> 00:26:32,660
as you might say and yet we still want

00:26:30,920 --> 00:26:35,300
to preserve that team autonomy we still

00:26:32,660 --> 00:26:37,870
want to be able to feel like we're we're

00:26:35,300 --> 00:26:40,220
an important cog in an overall machine

00:26:37,870 --> 00:26:41,600
not they're not easy challenges and I

00:26:40,220 --> 00:26:43,910
want to talk about how code structure

00:26:41,600 --> 00:26:47,600
and code storage can affect those goals

00:26:43,910 --> 00:26:48,950
that organizations might have so in

00:26:47,600 --> 00:26:50,120
order to illustrate this point I'd like

00:26:48,950 --> 00:26:52,850
to talk about the extremes of the

00:26:50,120 --> 00:26:55,790
spectrum so in terms of code storage how

00:26:52,850 --> 00:26:57,140
you locate your codes the extreme ends

00:26:55,790 --> 00:26:59,240
of the spectrum would be extreme mono

00:26:57,140 --> 00:27:01,610
repo and extreme poly repo in other

00:26:59,240 --> 00:27:04,460
words keeping every single line of code

00:27:01,610 --> 00:27:06,440
you have in one repository having atomic

00:27:04,460 --> 00:27:08,030
commits single versions of dependencies

00:27:06,440 --> 00:27:09,650
and this might be something where you

00:27:08,030 --> 00:27:12,620
think of Google for example they very

00:27:09,650 --> 00:27:15,200
famously have effectively one huge

00:27:12,620 --> 00:27:16,400
repository for all of their code and on

00:27:15,200 --> 00:27:18,590
the other end of the spectrum you have

00:27:16,400 --> 00:27:20,930
everything is split into different

00:27:18,590 --> 00:27:23,270
repositories so every single repository

00:27:20,930 --> 00:27:25,100
needs its own builds and publishing and

00:27:23,270 --> 00:27:26,930
CI concerns it needs to work out how

00:27:25,100 --> 00:27:28,280
it's going to version things and then

00:27:26,930 --> 00:27:30,130
only later down the road you have to

00:27:28,280 --> 00:27:33,350
figure out how you can wire things up

00:27:30,130 --> 00:27:36,140
when it comes to code structure we can

00:27:33,350 --> 00:27:38,180
think about monolithic apps and more

00:27:36,140 --> 00:27:40,520
modular apps as being the two sides of

00:27:38,180 --> 00:27:43,370
that spectrum notice this is a different

00:27:40,520 --> 00:27:45,560
spectrum to code storage so a monolith

00:27:43,370 --> 00:27:46,940
that would be that our code is not is

00:27:45,560 --> 00:27:49,760
written it in a very context dependent

00:27:46,940 --> 00:27:51,320
way it's not easy to separate concerns

00:27:49,760 --> 00:27:51,920
it's not easy to draw boundaries between

00:27:51,320 --> 00:27:54,110
things

00:27:51,920 --> 00:27:56,419
it's not easy therefore to reuse things

00:27:54,110 --> 00:27:59,159
in other similar contexts

00:27:56,419 --> 00:28:00,629
modular however might be considered that

00:27:59,159 --> 00:28:02,279
you've drawn clear separations of

00:28:00,629 --> 00:28:04,109
concerns around things you've got clear

00:28:02,279 --> 00:28:06,720
module boundaries you have explicit

00:28:04,109 --> 00:28:08,759
api's between things in your application

00:28:06,720 --> 00:28:12,419
you have clearly exposed public and

00:28:08,759 --> 00:28:14,909
private implementation details I've got

00:28:12,419 --> 00:28:16,409
a little illustration of maybe what this

00:28:14,909 --> 00:28:19,409
might look like when you implement an

00:28:16,409 --> 00:28:20,669
application on the Left we have an

00:28:19,409 --> 00:28:23,519
example of something that's more

00:28:20,669 --> 00:28:25,109
monolithic so if we look at the the dark

00:28:23,519 --> 00:28:27,179
circles there those are meant to be the

00:28:25,109 --> 00:28:28,679
coat the types of code you write which

00:28:27,179 --> 00:28:31,049
are actually specific to this

00:28:28,679 --> 00:28:32,519
application every single application no

00:28:31,049 --> 00:28:35,460
matter how it's structured has some

00:28:32,519 --> 00:28:37,259
logic or some some kind of components

00:28:35,460 --> 00:28:38,429
things like that which are specific to

00:28:37,259 --> 00:28:40,139
that application in that application

00:28:38,429 --> 00:28:42,629
alone that's only natural

00:28:40,139 --> 00:28:43,889
however we do have certain things which

00:28:42,629 --> 00:28:47,460
are represented by the colored boxes

00:28:43,889 --> 00:28:49,200
here that are arguably generic there

00:28:47,460 --> 00:28:51,359
could be for example presentational

00:28:49,200 --> 00:28:53,129
components or dumb components which just

00:28:51,359 --> 00:28:55,559
take inputs render things they produce

00:28:53,129 --> 00:28:57,659
outputs but they don't need to know what

00:28:55,559 --> 00:28:59,369
context they're being used in and you

00:28:57,659 --> 00:29:00,929
can have common data access libraries

00:28:59,369 --> 00:29:02,519
you might have multiple applications in

00:29:00,929 --> 00:29:04,649
your organization which access the same

00:29:02,519 --> 00:29:05,909
set of API is for example it's a real

00:29:04,649 --> 00:29:07,649
shame if you have to keep implementing

00:29:05,909 --> 00:29:09,479
wrappers around those API is over and

00:29:07,649 --> 00:29:11,609
over again but if you write your app in

00:29:09,479 --> 00:29:13,379
a monolithic way you can end up losing

00:29:11,609 --> 00:29:15,149
any ability to extract some of that

00:29:13,379 --> 00:29:18,330
logic and reuse it in other applications

00:29:15,149 --> 00:29:21,359
on the right hand side a more modular

00:29:18,330 --> 00:29:24,269
approach separates those concerns into

00:29:21,359 --> 00:29:26,039
the the kind of responsibility that they

00:29:24,269 --> 00:29:27,899
have so data access libraries get

00:29:26,039 --> 00:29:29,489
grouped together components that are

00:29:27,899 --> 00:29:31,499
shared get grouped together and then

00:29:29,489 --> 00:29:36,570
business logic for a specific app is

00:29:31,499 --> 00:29:38,519
also categorized as such I want to just

00:29:36,570 --> 00:29:41,039
stress so it's super clear for everybody

00:29:38,519 --> 00:29:43,049
that a monolith and a mono repo are not

00:29:41,039 --> 00:29:44,279
the same thing as I've explained I've

00:29:43,049 --> 00:29:47,639
highlighted it through two different

00:29:44,279 --> 00:29:49,679
spectrums the monolith is related to how

00:29:47,639 --> 00:29:52,649
code is structured the mono repo is

00:29:49,679 --> 00:29:55,379
related to how code is stored you can

00:29:52,649 --> 00:29:56,940
produce any effect from any storage

00:29:55,379 --> 00:29:58,979
effectively so you can produce a

00:29:56,940 --> 00:30:01,229
monolith from a Pali repo approach and

00:29:58,979 --> 00:30:03,840
vice-versa it's possible for all things

00:30:01,229 --> 00:30:05,309
so it's not to say that things are

00:30:03,840 --> 00:30:06,840
entirely unrelated because I'm

00:30:05,309 --> 00:30:08,460
specifically talking about a section

00:30:06,840 --> 00:30:09,200
that is about code structure and storage

00:30:08,460 --> 00:30:10,940
and how they

00:30:09,200 --> 00:30:12,019
it's a collaboration but I want you to

00:30:10,940 --> 00:30:14,090
bear in mind that just because they both

00:30:12,019 --> 00:30:15,500
start with mono does not mean they're

00:30:14,090 --> 00:30:18,470
the same thing and it's important to

00:30:15,500 --> 00:30:20,210
bear in mind so just as a quick visual

00:30:18,470 --> 00:30:21,820
analysis of what we might think of as

00:30:20,210 --> 00:30:24,230
examples of these things I'm describing

00:30:21,820 --> 00:30:26,600
we might think of Google as the extreme

00:30:24,230 --> 00:30:31,010
mono repo so we have mono repo we have

00:30:26,600 --> 00:30:33,049
our codes storage on the on the y axis

00:30:31,010 --> 00:30:36,620
here and we have how we structure our

00:30:33,049 --> 00:30:39,230
code on the X so Google extreme mono

00:30:36,620 --> 00:30:41,029
repo but very modular they have

00:30:39,230 --> 00:30:43,429
fantastic engineers they have unlimited

00:30:41,029 --> 00:30:45,260
resources effectively so they can

00:30:43,429 --> 00:30:49,580
approach their code in a very scalable

00:30:45,260 --> 00:30:52,490
modular way if we look at maybe the open

00:30:49,580 --> 00:30:55,730
source on github equivalent this is

00:30:52,490 --> 00:30:57,260
indeed pretty modular because everyone's

00:30:55,730 --> 00:31:00,169
separating out their code based on it

00:30:57,260 --> 00:31:01,970
doing one or a couple of things but it's

00:31:00,169 --> 00:31:03,110
a it's a very heavily split approach

00:31:01,970 --> 00:31:05,210
everything's in different repositories

00:31:03,110 --> 00:31:07,220
so it's up to you to then stitch things

00:31:05,210 --> 00:31:09,320
together it becomes a bit harder to

00:31:07,220 --> 00:31:12,740
share things in an intelligent way in a

00:31:09,320 --> 00:31:14,090
precise way and in our experience what

00:31:12,740 --> 00:31:16,610
we see is that a lot of enterprises end

00:31:14,090 --> 00:31:18,970
up roughly here so they end up with

00:31:16,610 --> 00:31:21,200
quite a monolithic app it just

00:31:18,970 --> 00:31:23,090
organically ends up that way because

00:31:21,200 --> 00:31:24,350
there are all kinds of constraints

00:31:23,090 --> 00:31:27,279
there's all kinds of feature delivery

00:31:24,350 --> 00:31:29,750
deadlines that kind of stuff but we're

00:31:27,279 --> 00:31:31,340
we're also on the Pali repo side of

00:31:29,750 --> 00:31:33,440
things it naturally ends up the teams

00:31:31,340 --> 00:31:35,090
want to control their own destiny so it

00:31:33,440 --> 00:31:37,600
might be an obvious thing to do to

00:31:35,090 --> 00:31:40,309
create a separate repository for that

00:31:37,600 --> 00:31:43,100
our thesis however is that monolithic

00:31:40,309 --> 00:31:44,269
Pali repos in other words that position

00:31:43,100 --> 00:31:46,669
on the graph for a lot of enterprises

00:31:44,269 --> 00:31:48,590
find themselves is actually the enemy of

00:31:46,669 --> 00:31:51,649
collaboration and I'll expand on that

00:31:48,590 --> 00:31:54,649
now so with monolithic public poly-r

00:31:51,649 --> 00:31:57,289
opposed we do have that autonomy but we

00:31:54,649 --> 00:31:58,789
do lose the ability to meet some of

00:31:57,289 --> 00:32:00,590
those goals we describe that enterprises

00:31:58,789 --> 00:32:02,269
once sunny becomes very difficult to

00:32:00,590 --> 00:32:05,690
ensure consistency across the enterprise

00:32:02,269 --> 00:32:07,419
and for tooling and other concerns it

00:32:05,690 --> 00:32:10,130
can be incredibly difficult to ensure

00:32:07,419 --> 00:32:12,220
versioning publishing CI all of that

00:32:10,130 --> 00:32:14,389
kind of stuff it all has to be repeated

00:32:12,220 --> 00:32:16,370
I'm going to illustrate this with a very

00:32:14,389 --> 00:32:18,769
basic example Mike is going to talk more

00:32:16,370 --> 00:32:20,210
in depth about components and those kind

00:32:18,769 --> 00:32:21,620
of shared use cases mine's just an

00:32:20,210 --> 00:32:22,559
illustrative example let's imagine we

00:32:21,620 --> 00:32:25,440
have a button

00:32:22,559 --> 00:32:27,840
Nawal has invented a design spec and we

00:32:25,440 --> 00:32:29,429
defined this beautiful button and it

00:32:27,840 --> 00:32:31,649
defines a padding and some fonts and

00:32:29,429 --> 00:32:32,850
whatever and that's what we've

00:32:31,649 --> 00:32:35,149
instruments are implemented but then

00:32:32,850 --> 00:32:37,620
it's up to engineers to implement it so

00:32:35,149 --> 00:32:40,289
this might be the reality of what what

00:32:37,620 --> 00:32:42,480
ends up in users hands so we have

00:32:40,289 --> 00:32:44,370
multiple applications the teams that

00:32:42,480 --> 00:32:47,370
have implemented it are in different

00:32:44,370 --> 00:32:48,539
repositories and they there's a number

00:32:47,370 --> 00:32:50,009
of reasons why we could end up with this

00:32:48,539 --> 00:32:51,539
like you can tell these are the same

00:32:50,009 --> 00:32:53,070
button they have the same

00:32:51,539 --> 00:32:55,139
characteristics but clearly they're

00:32:53,070 --> 00:32:57,059
different and naturally as users our

00:32:55,139 --> 00:32:58,679
eyes are tuned to picking up even the

00:32:57,059 --> 00:33:00,960
slightest differences and it's super

00:32:58,679 --> 00:33:03,029
annoying so how did we get here

00:33:00,960 --> 00:33:04,740
maybe the spec was ambiguous maybe the

00:33:03,029 --> 00:33:06,029
authors of the spectrum do a good job of

00:33:04,740 --> 00:33:09,090
defining all of the things in

00:33:06,029 --> 00:33:10,590
crystal-clear detail it could be that

00:33:09,090 --> 00:33:12,720
there were just time constraints and

00:33:10,590 --> 00:33:14,220
details were skipped or one team wasn't

00:33:12,720 --> 00:33:16,320
as detailed as another when it came to

00:33:14,220 --> 00:33:18,809
implementation time there's all kinds of

00:33:16,320 --> 00:33:20,340
reasons why this might come about and

00:33:18,809 --> 00:33:23,309
it's it's not it's not really anybody's

00:33:20,340 --> 00:33:25,499
fault but my point is that it's easier

00:33:23,309 --> 00:33:29,519
to do the wrong thing when you're spread

00:33:25,499 --> 00:33:30,690
across these poly repos so that's just

00:33:29,519 --> 00:33:32,100
the summary of what I've been saying and

00:33:30,690 --> 00:33:33,869
the other concern naturally of course

00:33:32,100 --> 00:33:36,269
then we have this button which is

00:33:33,869 --> 00:33:37,679
fulfilling the exact same use case but

00:33:36,269 --> 00:33:39,210
because we've chosen a poly Reaper

00:33:37,679 --> 00:33:41,820
approach we have two independently

00:33:39,210 --> 00:33:44,129
define a CI process a testing process a

00:33:41,820 --> 00:33:45,570
build process a versioning process all

00:33:44,129 --> 00:33:48,240
of these different things to then bring

00:33:45,570 --> 00:33:50,730
down into the application so this could

00:33:48,240 --> 00:33:52,259
be done inconsistently it wastes a

00:33:50,730 --> 00:33:54,119
massive amount of time because not only

00:33:52,259 --> 00:33:55,679
have we implemented a thing twice we've

00:33:54,119 --> 00:33:57,059
now have two different release processes

00:33:55,679 --> 00:33:58,830
for the same thing effectively the same

00:33:57,059 --> 00:34:03,720
thing it's not a shared implementation

00:33:58,830 --> 00:34:05,850
yet so again I would just like to

00:34:03,720 --> 00:34:08,220
reiterate that with poly repos it's

00:34:05,850 --> 00:34:09,720
easier to do the wrong thing ultimately

00:34:08,220 --> 00:34:11,849
everything we do as software engineers

00:34:09,720 --> 00:34:13,649
we're dealing with levels of abstraction

00:34:11,849 --> 00:34:15,629
the most efficient way we can work with

00:34:13,649 --> 00:34:17,700
computers is to write binary we could

00:34:15,629 --> 00:34:19,770
write zeros and ones and we could tell

00:34:17,700 --> 00:34:22,050
our computers exactly what we mean but

00:34:19,770 --> 00:34:23,280
we we've invented all kinds of levels of

00:34:22,050 --> 00:34:25,079
abstraction to make it easier on

00:34:23,280 --> 00:34:26,520
ourselves to do efficient things because

00:34:25,079 --> 00:34:29,069
if we were directly writing machine code

00:34:26,520 --> 00:34:30,510
we would blow up our CPUs probably we're

00:34:29,069 --> 00:34:33,119
terrible like humans are not good at

00:34:30,510 --> 00:34:34,349
that kind of instruction set so the

00:34:33,119 --> 00:34:36,300
reason we deal with these things is to

00:34:34,349 --> 00:34:38,340
make things easier for ourselves to not

00:34:36,300 --> 00:34:40,110
do the bad things and with Polly repos

00:34:38,340 --> 00:34:43,380
it's just fundamentally easier to make

00:34:40,110 --> 00:34:47,100
these mistakes so what if the team had a

00:34:43,380 --> 00:34:48,510
mono repo well suddenly our applications

00:34:47,100 --> 00:34:51,000
that we have the home page in the admin

00:34:48,510 --> 00:34:53,429
app they're right next to each other so

00:34:51,000 --> 00:34:55,140
let's say homepage app already invent

00:34:53,429 --> 00:34:58,200
already implemented the button it

00:34:55,140 --> 00:35:00,030
suddenly becomes obviously wrong for the

00:34:58,200 --> 00:35:01,620
admin app team to re-implement that

00:35:00,030 --> 00:35:03,810
button because it's right there

00:35:01,620 --> 00:35:05,250
it would be so obviously wrong to do it

00:35:03,810 --> 00:35:06,870
not only that they not have to

00:35:05,250 --> 00:35:08,910
re-implement the functionality of the

00:35:06,870 --> 00:35:10,800
button they're in the same repo so they

00:35:08,910 --> 00:35:13,380
don't have to invent a new HCI process

00:35:10,800 --> 00:35:15,240
build process test process because the

00:35:13,380 --> 00:35:16,770
applications are then also co-located

00:35:15,240 --> 00:35:19,200
with the button it's not like a shared

00:35:16,770 --> 00:35:21,150
component repo that publishes artifacts

00:35:19,200 --> 00:35:23,430
they get consumed into the app you can

00:35:21,150 --> 00:35:25,560
also do far better integration testing

00:35:23,430 --> 00:35:27,330
unit tests are fantastic and they make

00:35:25,560 --> 00:35:28,980
us feel warm and fuzzy inside we can see

00:35:27,330 --> 00:35:31,050
coverage numbers and they go up and we

00:35:28,980 --> 00:35:32,760
can reach 100 but then we plug it in and

00:35:31,050 --> 00:35:34,680
then it breaks because we don't have

00:35:32,760 --> 00:35:36,810
good integration testing sunny with a

00:35:34,680 --> 00:35:38,760
mono repo it's trivial to do good

00:35:36,810 --> 00:35:41,160
integration testing all of your commits

00:35:38,760 --> 00:35:44,310
can test across all of your applications

00:35:41,160 --> 00:35:46,170
so fundamentally it's easier to do the

00:35:44,310 --> 00:35:47,790
right thing you might be asking what

00:35:46,170 --> 00:35:49,770
happens if I want to make change the

00:35:47,790 --> 00:35:51,570
button now I've lost all control over

00:35:49,770 --> 00:35:53,040
the button and I previously as the admin

00:35:51,570 --> 00:35:55,710
team I could write my own button and I

00:35:53,040 --> 00:35:57,120
could change things that's true but as

00:35:55,710 --> 00:35:59,610
we've said it enterprises we want

00:35:57,120 --> 00:36:01,260
consistency so if you want to make a

00:35:59,610 --> 00:36:02,820
change to the button that might be a

00:36:01,260 --> 00:36:04,830
good thing but it's a good thing that

00:36:02,820 --> 00:36:06,630
you have to have a discussion with your

00:36:04,830 --> 00:36:08,190
colleagues and work out what the best

00:36:06,630 --> 00:36:12,450
solution is for everybody I would say

00:36:08,190 --> 00:36:13,860
that this is a good tension to have so

00:36:12,450 --> 00:36:15,180
those are the problems hopefully now you

00:36:13,860 --> 00:36:16,770
understand how we're positioning

00:36:15,180 --> 00:36:18,480
structure storage its effect on

00:36:16,770 --> 00:36:21,000
collaboration and particularly on

00:36:18,480 --> 00:36:22,680
enterprise teams how do we solve these

00:36:21,000 --> 00:36:24,930
problems well now all produces an

00:36:22,680 --> 00:36:26,460
open-source toolkit called NX so you can

00:36:24,930 --> 00:36:28,020
go to NX dev we've got a brand new

00:36:26,460 --> 00:36:29,190
documentation if you've got lots of rich

00:36:28,020 --> 00:36:30,810
guides and stuff like that for

00:36:29,190 --> 00:36:32,490
understanding a lot of the things I've

00:36:30,810 --> 00:36:33,840
described and then how to implement

00:36:32,490 --> 00:36:35,970
these things and solve some of these

00:36:33,840 --> 00:36:37,110
problems with NX so this is completely

00:36:35,970 --> 00:36:39,180
open-source you can see how it's

00:36:37,110 --> 00:36:43,770
implemented you can contribute please do

00:36:39,180 --> 00:36:46,230
and if we have an NX mono repo it's kind

00:36:43,770 --> 00:36:48,360
of roughly here is how I position it so

00:36:46,230 --> 00:36:49,420
we're not full mono repo in the sense

00:36:48,360 --> 00:36:50,920
that we're not

00:36:49,420 --> 00:36:54,400
not the tool for you to power your

00:36:50,920 --> 00:36:55,960
entire 10000 person organization with

00:36:54,400 --> 00:36:57,970
every single back and front end app at

00:36:55,960 --> 00:36:59,859
this point you've been hearing a lot

00:36:57,970 --> 00:37:01,900
probably at this conference about Basel

00:36:59,859 --> 00:37:04,089
and its its power because it's the open

00:37:01,900 --> 00:37:05,530
source variant of Blaise the tool that

00:37:04,089 --> 00:37:08,470
they use inside of Google to power their

00:37:05,530 --> 00:37:11,559
giant mono repo and X is not quite that

00:37:08,470 --> 00:37:13,089
n X is positioning itself to do 90% of

00:37:11,559 --> 00:37:15,609
the work that Basel would be able to do

00:37:13,089 --> 00:37:17,410
but in a different way so with Basel you

00:37:15,609 --> 00:37:19,569
annotate your workspace with build files

00:37:17,410 --> 00:37:21,400
so you say this is a part of my

00:37:19,569 --> 00:37:23,230
application I only want to rebuild this

00:37:21,400 --> 00:37:25,660
part when I make a change you do that

00:37:23,230 --> 00:37:27,430
explicitly so it's far more powerful but

00:37:25,660 --> 00:37:29,589
with NX we were able to infer the

00:37:27,430 --> 00:37:31,329
relationships in your mono repo through

00:37:29,589 --> 00:37:33,010
imports and exports statements through

00:37:31,329 --> 00:37:34,900
your source code because it's typescript

00:37:33,010 --> 00:37:36,790
we can statically follow those import

00:37:34,900 --> 00:37:38,680
and export paths to build up what's

00:37:36,790 --> 00:37:40,540
called a dependency graph and this is a

00:37:38,680 --> 00:37:42,819
key requirement of scaling a mono repo

00:37:40,540 --> 00:37:45,400
the advantages of collocation and stuff

00:37:42,819 --> 00:37:47,500
like that will fall down if on every

00:37:45,400 --> 00:37:49,890
single change you rebuild the entire

00:37:47,500 --> 00:37:52,780
universe because that will be very slow

00:37:49,890 --> 00:37:55,210
so we need tools like an X to be able to

00:37:52,780 --> 00:37:57,280
provide that kind of power on top it's

00:37:55,210 --> 00:37:59,829
fundamentally powered by the angular CLI

00:37:57,280 --> 00:38:01,119
so it's not a brand new concept to you

00:37:59,829 --> 00:38:03,549
it's not something that you need to

00:38:01,119 --> 00:38:05,140
learn specifically NX is powered by all

00:38:03,549 --> 00:38:07,150
of the same structures that the angular

00:38:05,140 --> 00:38:09,970
CLI is and we call it directly behind

00:38:07,150 --> 00:38:12,160
the scenes so mono repo and modularity

00:38:09,970 --> 00:38:13,809
is what we striving for because we've

00:38:12,160 --> 00:38:17,619
decided those are the optimal things as

00:38:13,809 --> 00:38:19,089
I've discussed so in a standard angular

00:38:17,619 --> 00:38:21,430
CLI setup you'll have a single source

00:38:19,089 --> 00:38:24,040
directory the Angus Eli does now support

00:38:21,430 --> 00:38:26,190
multiple projects but by default it's

00:38:24,040 --> 00:38:29,170
you will have one project out of the box

00:38:26,190 --> 00:38:31,210
with NX it's always been focused on a

00:38:29,170 --> 00:38:32,980
mono repo approach even if you only have

00:38:31,210 --> 00:38:34,390
a single application however the

00:38:32,980 --> 00:38:36,579
approach and the breakdown of having

00:38:34,390 --> 00:38:38,410
apps and libs is a really powerful

00:38:36,579 --> 00:38:40,329
approach so what's the difference

00:38:38,410 --> 00:38:41,859
between apps and libs well if you

00:38:40,329 --> 00:38:43,780
remember my diagram with the circles and

00:38:41,859 --> 00:38:45,819
the squares we do have different types

00:38:43,780 --> 00:38:48,309
of code not all code is exactly the same

00:38:45,819 --> 00:38:50,440
so with our applications with our apps

00:38:48,309 --> 00:38:52,150
this is the wiring up point of a

00:38:50,440 --> 00:38:55,450
specific thing we want to deploy to

00:38:52,150 --> 00:38:56,920
users that's all it is all the rest of

00:38:55,450 --> 00:38:58,930
our code goes in libs

00:38:56,920 --> 00:39:00,309
and we categorize it based on what type

00:38:58,930 --> 00:39:01,180
of code it is so for example here it

00:39:00,309 --> 00:39:03,109
might be common UI

00:39:01,180 --> 00:39:05,109
it might be data access layer

00:39:03,109 --> 00:39:07,309
things or it might be

00:39:05,109 --> 00:39:08,690
application-specific business logic like

00:39:07,309 --> 00:39:10,339
I mentioned here we have a library

00:39:08,690 --> 00:39:12,140
called narwhal die o because it's code

00:39:10,339 --> 00:39:15,109
that's specific to narwhal the iOS

00:39:12,140 --> 00:39:16,579
implementation so that's how you can

00:39:15,109 --> 00:39:19,670
think about the separation from libs if

00:39:16,579 --> 00:39:21,200
you're NX users already a best practice

00:39:19,670 --> 00:39:23,059
with an X is to make sure as much of

00:39:21,200 --> 00:39:25,130
your code is in libs as possible because

00:39:23,059 --> 00:39:27,019
that gives you the ability to be modular

00:39:25,130 --> 00:39:29,180
that allows you to draw those explicit

00:39:27,019 --> 00:39:31,309
boundaries and have public API is for

00:39:29,180 --> 00:39:33,380
your code which the rest of your mana

00:39:31,309 --> 00:39:35,239
reaper has to respect because NX

00:39:33,380 --> 00:39:39,349
provides tooling to ensure that you

00:39:35,239 --> 00:39:41,089
stick to those public api s-- so having

00:39:39,349 --> 00:39:43,279
those things next to each other and

00:39:41,089 --> 00:39:45,109
having those enforced best practices

00:39:43,279 --> 00:39:48,099
around sharing means that you have

00:39:45,109 --> 00:39:52,460
first-class reusability and

00:39:48,099 --> 00:39:54,230
consistency across your codebase as I

00:39:52,460 --> 00:39:56,539
mentioned the only way to scale a mana

00:39:54,230 --> 00:39:58,190
repo is if you have a tool which is

00:39:56,539 --> 00:40:00,739
capable of understanding your dependency

00:39:58,190 --> 00:40:03,559
graph so here I have an example a very

00:40:00,739 --> 00:40:05,809
simple example we have an admin app and

00:40:03,559 --> 00:40:08,569
a client app so both of these things

00:40:05,809 --> 00:40:09,920
have end-to-end tests so those actually

00:40:08,569 --> 00:40:12,019
in our dependency graph there's actually

00:40:09,920 --> 00:40:13,730
sit above our application because they

00:40:12,019 --> 00:40:15,799
depend on our application if our

00:40:13,730 --> 00:40:18,170
application changes our end-to-end tests

00:40:15,799 --> 00:40:19,700
need to run but the other things that

00:40:18,170 --> 00:40:21,890
make up the applications sit below them

00:40:19,700 --> 00:40:23,420
so here our admin app is made up of an

00:40:21,890 --> 00:40:26,059
admin feature that was implemented

00:40:23,420 --> 00:40:28,339
called permissions and also some more

00:40:26,059 --> 00:40:31,430
generic stuff like a data access library

00:40:28,339 --> 00:40:34,099
both our applications share a library

00:40:31,430 --> 00:40:35,509
around components so they have some dumb

00:40:34,099 --> 00:40:37,640
components which are consistent across

00:40:35,509 --> 00:40:39,650
our organization so we just share them

00:40:37,640 --> 00:40:40,880
and as you can see here the ones that

00:40:39,650 --> 00:40:42,349
are highlighted in red this is actually

00:40:40,880 --> 00:40:44,539
a visualization that NX will generate

00:40:42,349 --> 00:40:46,039
for you you just need to say generate my

00:40:44,539 --> 00:40:47,599
effective dependency graph and it will

00:40:46,039 --> 00:40:50,119
it will literally create this diagram

00:40:47,599 --> 00:40:52,069
for you it will highlight in red what's

00:40:50,119 --> 00:40:54,109
affected by your particular commit for

00:40:52,069 --> 00:40:56,599
example if I make a commit which changes

00:40:54,109 --> 00:40:58,819
the admin feature I have affected the

00:40:56,599 --> 00:41:00,980
admin feature itself and the admin app

00:40:58,819 --> 00:41:03,259
and the admin app end-to-end tests those

00:41:00,980 --> 00:41:05,420
are the things I need to rerun if I've

00:41:03,259 --> 00:41:07,549
made a change to the admin feature but

00:41:05,420 --> 00:41:09,049
nothing else I haven't touched anything

00:41:07,549 --> 00:41:10,730
to do with share components or the

00:41:09,049 --> 00:41:12,920
client app whatsoever

00:41:10,730 --> 00:41:15,079
so I don't rebuild that I don't retest

00:41:12,920 --> 00:41:16,579
that and there's no integration points

00:41:15,079 --> 00:41:18,709
there for me to worry about

00:41:16,579 --> 00:41:21,170
this is the only way to scale a mana

00:41:18,709 --> 00:41:23,420
repo if you seek arguments against mana

00:41:21,170 --> 00:41:25,579
repost they will usually be the results

00:41:23,420 --> 00:41:28,429
of the fact that tooling falls down in

00:41:25,579 --> 00:41:30,439
this area you end up with hugely spiking

00:41:28,429 --> 00:41:31,999
build times and stuff like that you need

00:41:30,439 --> 00:41:36,319
something which can enforce dependency

00:41:31,999 --> 00:41:37,309
graph analysis just to example just to

00:41:36,319 --> 00:41:39,140
show you an example of the kind of

00:41:37,309 --> 00:41:42,259
commands you run off the off of this

00:41:39,140 --> 00:41:43,459
information we provide some NPM scripts

00:41:42,259 --> 00:41:44,900
out-of-the-box for you to invoke but

00:41:43,459 --> 00:41:47,029
ultimately this is just invoking NX

00:41:44,900 --> 00:41:49,459
affecteds behind the scenes and we have

00:41:47,029 --> 00:41:50,779
some options of how you determine what

00:41:49,459 --> 00:41:53,779
range you're looking at so you can use

00:41:50,779 --> 00:41:54,890
commit chars or you can use untracked if

00:41:53,779 --> 00:41:56,630
you've just got some work in progress

00:41:54,890 --> 00:41:58,429
you haven't committed yet you can just

00:41:56,630 --> 00:42:01,189
see between these two points in time

00:41:58,429 --> 00:42:03,170
what's affected and only we rerun the

00:42:01,189 --> 00:42:06,759
test only rebuilds only rerun the

00:42:03,170 --> 00:42:06,759
interim test for that for that period

00:42:06,880 --> 00:42:13,549
cool so very briefly because there are

00:42:10,279 --> 00:42:15,920
many talks on this topic specifically I

00:42:13,549 --> 00:42:17,779
just wants to talk about some of the key

00:42:15,920 --> 00:42:19,939
aspects of the angular CLI that we

00:42:17,779 --> 00:42:22,069
actually leverage for NX powered mana

00:42:19,939 --> 00:42:24,109
repos and specifically a capital one

00:42:22,069 --> 00:42:26,839
we're using a quite a few of these as

00:42:24,109 --> 00:42:31,939
well as power elements use case so I'm

00:42:26,839 --> 00:42:36,410
just gonna switch over to MI there we go

00:42:31,939 --> 00:42:38,630
I think I'm gonna need to bump this so

00:42:36,410 --> 00:42:40,429
this is the sample repo that Dylan

00:42:38,630 --> 00:42:41,989
mentioned before so just very quickly

00:42:40,429 --> 00:42:47,900
going to use it to highlight some

00:42:41,989 --> 00:42:49,429
examples so come in here angular JSON is

00:42:47,900 --> 00:42:51,140
an incredibly powerful piece of

00:42:49,429 --> 00:42:53,029
configuration it's actually the

00:42:51,140 --> 00:42:55,670
architect stuff which came in in version

00:42:53,029 --> 00:42:57,319
6 is hugely hugely powerful and very

00:42:55,670 --> 00:42:58,880
generic it's actually even though we use

00:42:57,319 --> 00:43:03,679
it for angular it could be used for any

00:42:58,880 --> 00:43:04,849
real use case we have our projects which

00:43:03,679 --> 00:43:06,499
is our top-level object here which

00:43:04,849 --> 00:43:07,660
defines all of the different pieces of

00:43:06,499 --> 00:43:10,369
our mana repo

00:43:07,660 --> 00:43:11,809
each one of those projects has an

00:43:10,369 --> 00:43:13,039
architect as is very difficult for me to

00:43:11,809 --> 00:43:15,499
lean around here and do this at the same

00:43:13,039 --> 00:43:17,509
time everyone has an architect's

00:43:15,499 --> 00:43:19,759
property so this is what this architects

00:43:17,509 --> 00:43:21,979
concept is where we define references to

00:43:19,759 --> 00:43:25,039
our builders and a builder is just a way

00:43:21,979 --> 00:43:27,049
of running a command or kicking off a

00:43:25,039 --> 00:43:29,089
compilation process running linting

00:43:27,049 --> 00:43:31,330
testing those kind of things it's a very

00:43:29,089 --> 00:43:34,880
generic cons

00:43:31,330 --> 00:43:38,210
each architect type or target as it's

00:43:34,880 --> 00:43:44,240
called is given a name so build we have

00:43:38,210 --> 00:43:47,300
if I scroll down serve extracts I 18 n

00:43:44,240 --> 00:43:51,320
lint these are the things which power

00:43:47,300 --> 00:43:52,730
you running ng lint ng build ng serve it

00:43:51,320 --> 00:43:56,450
actually translates into architect

00:43:52,730 --> 00:43:58,460
targets as you can see with lint here it

00:43:56,450 --> 00:44:00,710
has a builder extract IAC then has a

00:43:58,460 --> 00:44:02,200
builder so once you've understood

00:44:00,710 --> 00:44:04,490
architects and how that this together

00:44:02,200 --> 00:44:05,900
you they need to understand builders so

00:44:04,490 --> 00:44:07,520
builders out-of-the-box

00:44:05,900 --> 00:44:08,870
angular ships with all the all the

00:44:07,520 --> 00:44:11,630
builders you might need for a standard

00:44:08,870 --> 00:44:12,980
angular set up but it doesn't you're not

00:44:11,630 --> 00:44:15,500
limited by that you can write your own

00:44:12,980 --> 00:44:17,060
builders and just swap in the reference

00:44:15,500 --> 00:44:18,590
here so right by default they come from

00:44:17,060 --> 00:44:20,300
angular defecate in your node modules

00:44:18,590 --> 00:44:24,100
but you can write your own builders and

00:44:20,300 --> 00:44:24,100
just reference them via a relative path

00:44:25,900 --> 00:44:31,370
by default NX provides a tools directory

00:44:28,700 --> 00:44:32,750
and in here we have builders so in our

00:44:31,370 --> 00:44:34,550
particular case because we have some

00:44:32,750 --> 00:44:36,500
interesting concerns with how we wire

00:44:34,550 --> 00:44:39,290
things together for elements and we have

00:44:36,500 --> 00:44:41,240
that independent team methodology that I

00:44:39,290 --> 00:44:43,010
described before we want to be able to

00:44:41,240 --> 00:44:44,690
do something subtly different to the

00:44:43,010 --> 00:44:46,790
angular CLI builds things we need to

00:44:44,690 --> 00:44:50,240
build UMD bundles of all of our elements

00:44:46,790 --> 00:44:51,980
and share them at runtime so we make a

00:44:50,240 --> 00:44:53,660
tweak to the Builder so we provide our

00:44:51,980 --> 00:44:55,220
own builder you don't need to worry too

00:44:53,660 --> 00:44:57,620
much about these implementation details

00:44:55,220 --> 00:44:58,210
but for example right now it's this

00:44:57,620 --> 00:45:03,050
simple

00:44:58,210 --> 00:45:05,090
so unfortunately huge caveat in version

00:45:03,050 --> 00:45:06,860
8 the builders API is changing so don't

00:45:05,090 --> 00:45:09,560
look too hard at the implementation

00:45:06,860 --> 00:45:11,150
details here but the concept here is

00:45:09,560 --> 00:45:12,950
that we use the underlying angular

00:45:11,150 --> 00:45:15,650
browser builder so the one that would be

00:45:12,950 --> 00:45:18,440
in that config by default we slightly

00:45:15,650 --> 00:45:20,240
extend it override some of its behavior

00:45:18,440 --> 00:45:21,800
in this case how the web pack configures

00:45:20,240 --> 00:45:24,020
being written we slightly tweak the web

00:45:21,800 --> 00:45:26,540
pack config and then we're done it's a

00:45:24,020 --> 00:45:28,010
it's a class which behind-the-scenes has

00:45:26,540 --> 00:45:29,660
a run method which returns an observable

00:45:28,010 --> 00:45:32,690
this is changing to be just a function

00:45:29,660 --> 00:45:34,460
in version 8 but right now this is how

00:45:32,690 --> 00:45:37,010
we do this in our real application at

00:45:34,460 --> 00:45:38,660
Capital One we extend the base one so

00:45:37,010 --> 00:45:39,770
that we know we're not reinventing all

00:45:38,660 --> 00:45:41,630
the hard work that's been done by the

00:45:39,770 --> 00:45:43,550
angular team and we just tweak the web

00:45:41,630 --> 00:45:46,070
pack config for our own usage

00:45:43,550 --> 00:45:48,530
so that's architect and builders covered

00:45:46,070 --> 00:45:50,480
schematics are a fantastic tool we're

00:45:48,530 --> 00:45:52,340
actually running alongside a schematics

00:45:50,480 --> 00:45:53,420
workshop right now I believe and there's

00:45:52,340 --> 00:45:55,250
several other talks of this conference

00:45:53,420 --> 00:45:57,410
about schematics so I'd encourage you to

00:45:55,250 --> 00:46:00,050
check those out essentially it's a way

00:45:57,410 --> 00:46:01,700
of making sure that the best practices

00:46:00,050 --> 00:46:04,880
you decide for your mono repo as they

00:46:01,700 --> 00:46:05,900
evolve are stuck to by engineers so by

00:46:04,880 --> 00:46:07,640
default you're used to the ones of

00:46:05,900 --> 00:46:09,110
energy generate components and stuff

00:46:07,640 --> 00:46:10,700
like that it's all powered by schematics

00:46:09,110 --> 00:46:12,740
so you're generating things on your file

00:46:10,700 --> 00:46:14,200
system in a specific way you might

00:46:12,740 --> 00:46:17,360
decide for example that you have

00:46:14,200 --> 00:46:20,360
particular conventions for your own

00:46:17,360 --> 00:46:23,960
schematics right now we don't have an

00:46:20,360 --> 00:46:25,970
example in this repo but with NX

00:46:23,960 --> 00:46:27,440
that's all I've been describing we have

00:46:25,970 --> 00:46:28,910
many schematics that we provide out of

00:46:27,440 --> 00:46:38,570
the box just like the angular team does

00:46:28,910 --> 00:46:46,850
so I come down here it looks quite

00:46:38,570 --> 00:46:49,130
intense there we go so it exports a

00:46:46,850 --> 00:46:50,540
default function there's some concepts

00:46:49,130 --> 00:46:52,130
here that you can look into like tree

00:46:50,540 --> 00:46:53,660
for example as a key concept it's like a

00:46:52,130 --> 00:46:55,880
virtual representation of your file

00:46:53,660 --> 00:46:57,980
system so you can apply changes and

00:46:55,880 --> 00:46:59,600
things to your file system virtually

00:46:57,980 --> 00:47:01,760
first before they get committed to disk

00:46:59,600 --> 00:47:03,560
so you can write really nice unit tests

00:47:01,760 --> 00:47:05,720
and stuff like that around your file

00:47:03,560 --> 00:47:08,390
system behavior but essentially you're

00:47:05,720 --> 00:47:10,490
returning a chain of instructions so for

00:47:08,390 --> 00:47:12,350
example the key thing I wanted to

00:47:10,490 --> 00:47:14,690
highlight here before I finish is the

00:47:12,350 --> 00:47:17,780
fact that when we do a narwhal library a

00:47:14,690 --> 00:47:19,850
Lib all we're doing is invoking the

00:47:17,780 --> 00:47:21,380
standard angular one we're invoking

00:47:19,850 --> 00:47:22,970
what's called an external schematic so

00:47:21,380 --> 00:47:25,940
we're voting somebody else's schematic

00:47:22,970 --> 00:47:27,680
with a particular set of options so the

00:47:25,940 --> 00:47:29,210
same way as if you've gone ng generate

00:47:27,680 --> 00:47:31,370
library this is what we're doing

00:47:29,210 --> 00:47:33,050
programmatically here and then we make

00:47:31,370 --> 00:47:36,380
some tweaks to it so we move some files

00:47:33,050 --> 00:47:39,260
around we update some files we choose to

00:47:36,380 --> 00:47:40,490
provide gest out-of-the-box we like just

00:47:39,260 --> 00:47:41,990
a lot so we provide it as the default

00:47:40,490 --> 00:47:44,060
but you can choose what test runner you

00:47:41,990 --> 00:47:45,650
want to run so schematics are hugely

00:47:44,060 --> 00:47:48,050
powerful if you decide at your

00:47:45,650 --> 00:47:50,660
organization I like to do this this way

00:47:48,050 --> 00:47:53,270
you can write a schematic use it locally

00:47:50,660 --> 00:47:56,000
using NX and enforce that best practice

00:47:53,270 --> 00:47:57,230
in your mana repo and like I said our

00:47:56,000 --> 00:47:58,820
300 developers

00:47:57,230 --> 00:48:00,200
only a handful need to care about the

00:47:58,820 --> 00:48:02,599
implementation details of this because

00:48:00,200 --> 00:48:04,640
they can just run ng generates my org

00:48:02,599 --> 00:48:07,490
components and it will generate

00:48:04,640 --> 00:48:11,170
component with the styles you specify so

00:48:07,490 --> 00:48:11,170
with that I will pass it over to Mike

00:48:22,450 --> 00:48:28,500
Wow this is a pretty good turnout so

00:48:25,450 --> 00:48:28,500
thanks everyone for coming out

00:48:45,180 --> 00:48:48,349
I don't have my

00:48:50,950 --> 00:48:54,210
sorry just one second

00:48:59,190 --> 00:49:02,430
thanks James

00:49:04,119 --> 00:49:08,950
escape

00:49:06,560 --> 00:49:12,120
present

00:49:08,950 --> 00:49:14,870
we have to cover at the bottom

00:49:12,120 --> 00:49:14,870
presenter

00:49:16,070 --> 00:49:18,910
have that

00:49:19,820 --> 00:49:22,720
man control that

00:49:36,950 --> 00:49:39,700
click this

00:49:42,170 --> 00:49:46,940
all right a quick bit about me I'm Mike

00:49:45,140 --> 00:49:49,970
Hassan a team leader at Capital One

00:49:46,940 --> 00:49:50,480
I love typescript type systems in

00:49:49,970 --> 00:49:53,240
general

00:49:50,480 --> 00:49:54,710
I love angular even though I work at in

00:49:53,240 --> 00:49:57,289
addition angle I work on other front-end

00:49:54,710 --> 00:49:58,970
frameworks at Capital One and I love

00:49:57,289 --> 00:50:05,240
mono repo all the things that James is

00:49:58,970 --> 00:50:07,220
just talking about so a Capital One we

00:50:05,240 --> 00:50:09,380
want to I guess I shared with you our

00:50:07,220 --> 00:50:12,859
journey toward building a Capital One

00:50:09,380 --> 00:50:15,650
branded UI component library on top of

00:50:12,859 --> 00:50:18,769
the component dev kit library also known

00:50:15,650 --> 00:50:20,450
as a CD K to encourage a great inner

00:50:18,769 --> 00:50:22,940
source contribution and collaboration

00:50:20,450 --> 00:50:26,200
model we've set it up as a project just

00:50:22,940 --> 00:50:28,430
like any other NX or CLI based project

00:50:26,200 --> 00:50:31,519
since this project is such a heavily

00:50:28,430 --> 00:50:33,769
shared project with many dependents it

00:50:31,519 --> 00:50:36,799
was extra important for us to optimize

00:50:33,769 --> 00:50:39,559
our test trees in NX affected just as

00:50:36,799 --> 00:50:41,269
James described before additionally has

00:50:39,559 --> 00:50:44,180
a quick explanation for those who do not

00:50:41,269 --> 00:50:45,799
know like what the CD K is it is a

00:50:44,180 --> 00:50:47,359
library from the angular team that

00:50:45,799 --> 00:50:49,250
provides foundational building blocks

00:50:47,359 --> 00:50:52,490
for building out consumer writing UI

00:50:49,250 --> 00:50:54,890
component libraries there are no visual

00:50:52,490 --> 00:50:56,180
design assumptions within the CD k it

00:50:54,890 --> 00:50:58,700
essentially pulls out the things that

00:50:56,180 --> 00:51:00,650
are common between all UI component

00:50:58,700 --> 00:51:02,390
libraries so that we don't have to

00:51:00,650 --> 00:51:04,849
re-implement the same logic across all

00:51:02,390 --> 00:51:07,190
these different libraries in fact the

00:51:04,849 --> 00:51:12,319
angular material library utilizes the

00:51:07,190 --> 00:51:14,390
cdk under the hood like like most

00:51:12,319 --> 00:51:16,549
websites when we started building out

00:51:14,390 --> 00:51:18,079
the capital own platform we immediately

00:51:16,549 --> 00:51:19,549
had immediately had this need for

00:51:18,079 --> 00:51:21,559
components so that we had a consistent

00:51:19,549 --> 00:51:23,210
look and feel along with all the other

00:51:21,559 --> 00:51:28,039
great reasons to use a UI component

00:51:23,210 --> 00:51:31,190
library so we started with bootstrap

00:51:28,039 --> 00:51:32,900
components via the UI bootstrap library

00:51:31,190 --> 00:51:35,420
like I'm sure many of you have used in

00:51:32,900 --> 00:51:37,160
the past as a matter of fact when I was

00:51:35,420 --> 00:51:38,509
creating these slides I was kind of

00:51:37,160 --> 00:51:40,730
reminiscing and feeling a little

00:51:38,509 --> 00:51:42,200
sentimental because it was like the

00:51:40,730 --> 00:51:46,759
first library as using when I was

00:51:42,200 --> 00:51:48,650
learning angularjs as noted in this

00:51:46,759 --> 00:51:50,720
slide these components that we started

00:51:48,650 --> 00:51:52,039
out with our angularjs components so

00:51:50,720 --> 00:51:53,460
we're at a point in history of our

00:51:52,039 --> 00:51:55,710
journey

00:51:53,460 --> 00:51:59,339
where our platform was just kind of 100%

00:51:55,710 --> 00:52:01,530
angularjs bootstrap is really cool and

00:51:59,339 --> 00:52:03,450
something I've utilized heavily on past

00:52:01,530 --> 00:52:05,940
projects but we are a company with an

00:52:03,450 --> 00:52:08,490
established brand and we wanted to

00:52:05,940 --> 00:52:10,050
reflect that with our components we

00:52:08,490 --> 00:52:11,910
started out by overriding bootstrap

00:52:10,050 --> 00:52:15,390
styles but that became hard to maintain

00:52:11,910 --> 00:52:17,040
and resulted in visual design defects it

00:52:15,390 --> 00:52:19,079
also didn't give us the full flexibility

00:52:17,040 --> 00:52:21,420
that we wanted that we'd get with our

00:52:19,079 --> 00:52:23,130
own implementation so we set out to

00:52:21,420 --> 00:52:26,040
create our own shared UI component

00:52:23,130 --> 00:52:27,900
library if anyone here has an account

00:52:26,040 --> 00:52:30,000
with us like you've probably seen a

00:52:27,900 --> 00:52:31,680
dialog that looks a lot like this before

00:52:30,000 --> 00:52:34,980
because this is a real reusable

00:52:31,680 --> 00:52:37,440
component that we created for our shared

00:52:34,980 --> 00:52:38,579
component library a few years back it

00:52:37,440 --> 00:52:40,200
worked well for us but we were

00:52:38,579 --> 00:52:42,839
responsible for writing and maintaining

00:52:40,200 --> 00:52:45,240
the code to manually inject our dialog

00:52:42,839 --> 00:52:48,329
into the Dom creating the backdrop

00:52:45,240 --> 00:52:50,430
overlay that is behind it and preventing

00:52:48,329 --> 00:52:53,940
focus from leaving the dialog to enable

00:52:50,430 --> 00:52:55,619
like a good accessibility experience all

00:52:53,940 --> 00:52:57,690
of this code was coupled to the dialog

00:52:55,619 --> 00:52:58,740
itself the consequence being that we

00:52:57,690 --> 00:53:00,299
couldn't reuse these generic

00:52:58,740 --> 00:53:02,490
functionalities with all their

00:53:00,299 --> 00:53:05,640
components that we were building such as

00:53:02,490 --> 00:53:08,250
our tooltip component over time our set

00:53:05,640 --> 00:53:10,049
of custom reusable components grew and

00:53:08,250 --> 00:53:13,220
matured to a point where we could build

00:53:10,049 --> 00:53:15,839
most features utilizing these components

00:53:13,220 --> 00:53:18,059
now relating to our journey from

00:53:15,839 --> 00:53:20,369
angularjs to angular we of course need

00:53:18,059 --> 00:53:22,230
to upgrade our shared components however

00:53:20,369 --> 00:53:23,599
we wanted we wanted to take our

00:53:22,230 --> 00:53:25,650
learnings from the first time around

00:53:23,599 --> 00:53:27,990
since we became aware of angular

00:53:25,650 --> 00:53:29,609
material we want to look at that project

00:53:27,990 --> 00:53:33,990
to the lens of the Capital One branded

00:53:29,609 --> 00:53:35,369
components so quality what we saw was

00:53:33,990 --> 00:53:36,599
that angular material components were

00:53:35,369 --> 00:53:38,369
high quality from at least two

00:53:36,599 --> 00:53:40,020
perspectives they are high quality

00:53:38,369 --> 00:53:41,970
because they provide a great end-user

00:53:40,020 --> 00:53:44,010
experience but they also provide a great

00:53:41,970 --> 00:53:45,720
developer experience they contain

00:53:44,010 --> 00:53:48,900
excellent documentation with an easily

00:53:45,720 --> 00:53:50,250
accessible documentation website the

00:53:48,900 --> 00:53:51,510
components are highly declarative

00:53:50,250 --> 00:53:53,430
leading is something that's very

00:53:51,510 --> 00:53:55,290
understandable for engineers the

00:53:53,430 --> 00:53:58,079
programmatic api's are also intuitive

00:53:55,290 --> 00:54:00,690
and understandable those are all great

00:53:58,079 --> 00:54:02,760
qualitative observations but something

00:54:00,690 --> 00:54:04,380
else really caught our eye when digging

00:54:02,760 --> 00:54:06,210
through the material source code we

00:54:04,380 --> 00:54:08,010
found some very awesome engine

00:54:06,210 --> 00:54:11,880
ARC abstractions I'll give you some

00:54:08,010 --> 00:54:13,619
examples when I showed the capital 1

00:54:11,880 --> 00:54:14,970
dialog earlier I mentioned that we

00:54:13,619 --> 00:54:17,910
needed to write code that would prevent

00:54:14,970 --> 00:54:19,619
the focus from leaving the dialog this

00:54:17,910 --> 00:54:20,910
is for accessibility purposes it's very

00:54:19,619 --> 00:54:22,830
important

00:54:20,910 --> 00:54:24,030
doing so involves a fair bit of code and

00:54:22,830 --> 00:54:26,670
it's not something that a typical

00:54:24,030 --> 00:54:28,859
engineer would be able to do without

00:54:26,670 --> 00:54:31,050
investing research time into the Dom API

00:54:28,859 --> 00:54:33,150
is to see what's possible

00:54:31,050 --> 00:54:34,980
we found a useful little thing in the

00:54:33,150 --> 00:54:37,320
angular material code base called focus

00:54:34,980 --> 00:54:39,390
trap this directive allows us to easily

00:54:37,320 --> 00:54:42,480
trap focus with any Dom container

00:54:39,390 --> 00:54:44,040
element I'm talking almost no effort

00:54:42,480 --> 00:54:49,980
it's just slap a directive right on

00:54:44,040 --> 00:54:51,480
there another very useful but internal

00:54:49,980 --> 00:54:53,369
abstraction we found was portal outlet

00:54:51,480 --> 00:54:54,660
I'm gonna go a little bit faster we're

00:54:53,369 --> 00:54:57,180
running out of time but this allows you

00:54:54,660 --> 00:54:59,119
to kind of define a slot in your Dom

00:54:57,180 --> 00:55:01,740
anywhere and then insert

00:54:59,119 --> 00:55:03,210
programmatically another component into

00:55:01,740 --> 00:55:04,710
that slot it's a little bit different

00:55:03,210 --> 00:55:06,270
than like transclusion or content

00:55:04,710 --> 00:55:09,080
projection because those are declarative

00:55:06,270 --> 00:55:12,810
this is a programmatic and more dynamic

00:55:09,080 --> 00:55:14,580
capability so back to our angular

00:55:12,810 --> 00:55:16,200
migration journey we needed to start

00:55:14,580 --> 00:55:18,030
implementing our shared components and

00:55:16,200 --> 00:55:21,119
we want to use these abstractions but we

00:55:18,030 --> 00:55:22,890
couldn't and that made us sad since we

00:55:21,119 --> 00:55:24,359
want our own branded components using

00:55:22,890 --> 00:55:26,099
angular materials out of the question

00:55:24,359 --> 00:55:28,320
however the abstractions I've previously

00:55:26,099 --> 00:55:30,240
talked about are not inherently coupled

00:55:28,320 --> 00:55:31,920
to the Midd the material spec itself

00:55:30,240 --> 00:55:33,780
additionally they weren't coupled to the

00:55:31,920 --> 00:55:36,330
rest of the material components at a

00:55:33,780 --> 00:55:37,740
code level since api's were decoupled

00:55:36,330 --> 00:55:39,060
the thing that was preventing us from

00:55:37,740 --> 00:55:41,070
using them is that they were internal

00:55:39,060 --> 00:55:45,869
private api's of the angular material

00:55:41,070 --> 00:55:47,940
library the angular folks saw that

00:55:45,869 --> 00:55:51,240
others wanted these abstractions so they

00:55:47,940 --> 00:55:53,099
released released the cdk it includes

00:55:51,240 --> 00:55:55,530
these abstractions as supported official

00:55:53,099 --> 00:55:59,030
public api's upon which others can build

00:55:55,530 --> 00:55:59,030
their own branded shared components

00:55:59,300 --> 00:56:03,119
since they released this cdk we've been

00:56:01,890 --> 00:56:04,680
empowered to build several of our

00:56:03,119 --> 00:56:06,270
components more quickly and with more

00:56:04,680 --> 00:56:08,220
confidence than had it not been

00:56:06,270 --> 00:56:09,210
available additionally since the

00:56:08,220 --> 00:56:10,680
material components are such high

00:56:09,210 --> 00:56:12,690
quality we've taken a lot of inspiration

00:56:10,680 --> 00:56:14,160
from those implementations that are

00:56:12,690 --> 00:56:15,470
above and beyond what's in the CD K

00:56:14,160 --> 00:56:17,329
itself

00:56:15,470 --> 00:56:18,950
I think it's awesome that you know

00:56:17,329 --> 00:56:20,150
they're working let's see DK and I can't

00:56:18,950 --> 00:56:22,099
wait to see where it goes these are all

00:56:20,150 --> 00:56:27,530
the different components that they have

00:56:22,099 --> 00:56:29,869
today as James was describing we use NX

00:56:27,530 --> 00:56:31,819
so we can get the benefits like of a

00:56:29,869 --> 00:56:33,440
mono repo so you may be asking yourself

00:56:31,819 --> 00:56:36,410
why I just spent time talking about the

00:56:33,440 --> 00:56:38,000
CD K well that's because it's like a

00:56:36,410 --> 00:56:40,339
perfect example for what we can do with

00:56:38,000 --> 00:56:42,790
NX tuning I'll try to show you with a

00:56:40,339 --> 00:56:45,740
real use case that we have a capital one

00:56:42,790 --> 00:56:48,140
when once you have a your repo and your

00:56:45,740 --> 00:56:50,599
angular project an X enabled you end up

00:56:48,140 --> 00:56:52,460
with two Co lies generally you'll

00:56:50,599 --> 00:56:55,040
abstract that behind and NPM run

00:56:52,460 --> 00:56:56,119
commands but I'm gonna go right for for

00:56:55,040 --> 00:56:58,760
what the commands are so you can see

00:56:56,119 --> 00:57:00,200
what's happening you will use the ng CLI

00:56:58,760 --> 00:57:03,290
just as you normally would to serve your

00:57:00,200 --> 00:57:05,839
app or to generate code artifacts like

00:57:03,290 --> 00:57:07,579
components and services however if you

00:57:05,839 --> 00:57:10,040
want all of the intelligent affected

00:57:07,579 --> 00:57:11,810
build tests and lint functionality as

00:57:10,040 --> 00:57:15,819
well as the ability to run in repo

00:57:11,810 --> 00:57:19,730
custom schematics you'll use the NX CLI

00:57:15,819 --> 00:57:24,290
so here's a quick example of how we

00:57:19,730 --> 00:57:26,450
actually use it from the command so so

00:57:24,290 --> 00:57:28,760
ng generate library components so I want

00:57:26,450 --> 00:57:30,800
to generate a library for components to

00:57:28,760 --> 00:57:35,630
store reusable components in and we get

00:57:30,800 --> 00:57:37,880
a little project like this ng generate

00:57:35,630 --> 00:57:39,609
library card payments this is like a

00:57:37,880 --> 00:57:42,950
feature component that we want to build

00:57:39,609 --> 00:57:45,020
that will depend on the components now

00:57:42,950 --> 00:57:47,359
this is where we were talking about

00:57:45,020 --> 00:57:50,119
before we have integration doing

00:57:47,359 --> 00:57:52,160
integration points using custom elements

00:57:50,119 --> 00:57:53,599
in order to upgrade our app so we

00:57:52,160 --> 00:57:56,000
created a custom schematic that

00:57:53,599 --> 00:57:58,130
generates a project and then we'll also

00:57:56,000 --> 00:58:00,410
wire up a component that's already a

00:57:58,130 --> 00:58:03,380
custom element so saves our developers

00:58:00,410 --> 00:58:09,520
the like cognitive overhead of

00:58:03,380 --> 00:58:13,190
understanding that so if I make a change

00:58:09,520 --> 00:58:16,130
and I want to like run the build it will

00:58:13,190 --> 00:58:18,319
only run if it will only run on the the

00:58:16,130 --> 00:58:20,420
projects that I've changed in this case

00:58:18,319 --> 00:58:23,119
it's affected and then you specify a

00:58:20,420 --> 00:58:26,270
target which is the project or which is

00:58:23,119 --> 00:58:28,310
the architect and then you specify bass

00:58:26,270 --> 00:58:30,880
master generally in order to run just

00:58:28,310 --> 00:58:30,880
your changes

00:58:31,300 --> 00:58:35,660
now let's say I made a change to the

00:58:33,350 --> 00:58:39,080
shared components library that's cool

00:58:35,660 --> 00:58:42,380
but now I need to run the build on that

00:58:39,080 --> 00:58:43,670
as well so the effective tooling just

00:58:42,380 --> 00:58:45,890
kind of takes care of this for you

00:58:43,670 --> 00:58:48,440
and additionally what if there are other

00:58:45,890 --> 00:58:49,790
features that are already out there it

00:58:48,440 --> 00:58:50,870
will automatically take care of that too

00:58:49,790 --> 00:58:57,170
because it's just traversing the

00:58:50,870 --> 00:58:58,790
typescript imports and then here I just

00:58:57,170 --> 00:59:00,380
want to show so obviously that's

00:58:58,790 --> 00:59:02,060
building that's cool but we also want to

00:59:00,380 --> 00:59:04,820
run the affected tests so here I've

00:59:02,060 --> 00:59:07,400
changed the target to test and it's kind

00:59:04,820 --> 00:59:08,690
of the same exact thing so I'm gonna

00:59:07,400 --> 00:59:14,930
we're running out of time so I'm gonna

00:59:08,690 --> 00:59:16,700
turn it over to Dylan thanks all right

00:59:14,930 --> 00:59:18,260
thanks everybody for coming hopefully

00:59:16,700 --> 00:59:19,280
there was some useful information for

00:59:18,260 --> 00:59:21,950
you here if you want to hear about

00:59:19,280 --> 00:59:23,510
elements migration strategies why we are

00:59:21,950 --> 00:59:25,850
making 300 people work in the same

00:59:23,510 --> 00:59:27,680
source code repository together or how

00:59:25,850 --> 00:59:29,390
the cdk is helping us accelerate our

00:59:27,680 --> 00:59:31,550
angular migration please come find us

00:59:29,390 --> 00:59:33,530
and check out the repo we'd love to

00:59:31,550 --> 00:59:39,319
share some info thank you

00:59:33,530 --> 00:59:39,319
[Applause]

00:59:43,360 --> 00:59:49,969
[Music]

00:59:55,550 --> 00:59:57,610

YouTube URL: https://www.youtube.com/watch?v=WFzph5uTdmw


