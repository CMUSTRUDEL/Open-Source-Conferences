Title: Use decorator to beat ngOnChanges – Decoupling ngOnChanges | Kern Zhao
Publication date: 2019-05-07
Playlist: ng-conf 2019
Description: 
	By using a TypeScript property decorator directly on a property of a component, it’s much easier/cleaner/more-readable to subscribe to property change than the traditional painful ngOnChanges. Details on:
https://medium.com/p/19f3a5e051ef/edit

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:07,920 --> 00:00:11,170
[Music]

00:00:12,049 --> 00:00:16,139
my name is Kern

00:00:13,799 --> 00:00:17,250
today I'm very excited to stand here at

00:00:16,139 --> 00:00:21,930
the stage of ng-conf

00:00:17,250 --> 00:00:25,769
and telling you guys what you I have

00:00:21,930 --> 00:00:27,480
discovered recently about decorator just

00:00:25,769 --> 00:00:30,840
a little bit about myself my name is

00:00:27,480 --> 00:00:33,570
curl or Sooyoung and I work as an

00:00:30,840 --> 00:00:36,780
independent contractor I help my clients

00:00:33,570 --> 00:00:38,489
architecting digital solutions and bring

00:00:36,780 --> 00:00:41,160
them best practice of web development

00:00:38,489 --> 00:00:44,460
I'm also a writer of anger in depth

00:00:41,160 --> 00:00:47,250
which is a great publication I have

00:00:44,460 --> 00:00:51,539
thing I've learned a lot from there and

00:00:47,250 --> 00:00:53,969
I encourage you guys to check it out my

00:00:51,539 --> 00:00:58,050
topic today is about how to use

00:00:53,969 --> 00:01:00,180
decorator to decouple ng on changes let

00:00:58,050 --> 00:01:03,390
me explain more about it

00:01:00,180 --> 00:01:06,200
suppose we have a name card component

00:01:03,390 --> 00:01:09,689
with two input properties name and age

00:01:06,200 --> 00:01:11,820
okay my question is how to listen to the

00:01:09,689 --> 00:01:15,299
change of input properties for example

00:01:11,820 --> 00:01:18,090
if I want to I Iona console.log name

00:01:15,299 --> 00:01:20,490
change whenever names change right if I

00:01:18,090 --> 00:01:23,790
want to constantly age changed every

00:01:20,490 --> 00:01:26,220
time age gets changed okay you might

00:01:23,790 --> 00:01:29,549
have your answer right so the word that

00:01:26,220 --> 00:01:33,390
pub overhead is ng own changes yes and

00:01:29,549 --> 00:01:36,000
your own changes works so basically if

00:01:33,390 --> 00:01:37,860
any one of the input property gets

00:01:36,000 --> 00:01:40,740
changed and your own changes lifecycle

00:01:37,860 --> 00:01:42,899
hooks will be triggered and then we can

00:01:40,740 --> 00:01:46,320
use if statement to determine which

00:01:42,899 --> 00:01:48,570
input properties change right however

00:01:46,320 --> 00:01:52,020
I'm not a big fan of ng on changes to be

00:01:48,570 --> 00:01:54,869
honest the reasons because first we need

00:01:52,020 --> 00:01:58,380
to handle all input properties changes

00:01:54,869 --> 00:02:01,549
inside one joint block which is an

00:01:58,380 --> 00:02:01,549
engineer changes

00:02:02,049 --> 00:02:08,560
and the way we need to and we need to

00:02:05,560 --> 00:02:11,890
use F statement that boil a to two

00:02:08,560 --> 00:02:15,040
separate Navarre and the second thing is

00:02:11,890 --> 00:02:17,530
about poor typing some of you might

00:02:15,040 --> 00:02:19,959
already know that NGO engine just takes

00:02:17,530 --> 00:02:22,510
in one parameter which it has typed

00:02:19,959 --> 00:02:24,480
simple changes let's take a look at what

00:02:22,510 --> 00:02:27,880
what's the simple change

00:02:24,480 --> 00:02:32,920
so here the simple changes is a object

00:02:27,880 --> 00:02:35,830
defined by angular and it's it's keys

00:02:32,920 --> 00:02:38,860
are are any strengths which is

00:02:35,830 --> 00:02:42,880
problematic why because if we have a

00:02:38,860 --> 00:02:45,010
typo here say if changes thought typo

00:02:42,880 --> 00:02:47,260
name then typescript won't really

00:02:45,010 --> 00:02:50,290
recognize it times we won't complain

00:02:47,260 --> 00:02:53,860
about it right so this will fail

00:02:50,290 --> 00:02:59,230
silently another thing about the typing

00:02:53,860 --> 00:03:02,769
is that for a simple change so by the

00:02:59,230 --> 00:03:04,780
way the angular use class instead of

00:03:02,769 --> 00:03:07,720
intervals but here I are using this to

00:03:04,780 --> 00:03:12,459
just you to be to to make it easier to

00:03:07,720 --> 00:03:13,900
understand now so the simple change has

00:03:12,459 --> 00:03:16,720
a previous value and the current value

00:03:13,900 --> 00:03:18,640
they are all time to any but it would be

00:03:16,720 --> 00:03:21,100
better if they can type to a specific

00:03:18,640 --> 00:03:23,680
type for example it would be better if

00:03:21,100 --> 00:03:26,560
they can type to string if I use it for

00:03:23,680 --> 00:03:33,250
name right and type to number if I use

00:03:26,560 --> 00:03:36,519
it for 4-h I've seen a lot of people

00:03:33,250 --> 00:03:41,609
using this kind of solution by combining

00:03:36,519 --> 00:03:44,709
setter with input right and it works so

00:03:41,609 --> 00:03:47,739
basically this put one input property

00:03:44,709 --> 00:03:50,730
you need to have three pieces the first

00:03:47,739 --> 00:03:53,650
at the top is a private variable and

00:03:50,730 --> 00:03:57,430
this variable is to store the current

00:03:53,650 --> 00:03:58,630
value right of the input property and at

00:03:57,430 --> 00:04:01,540
the bottom we have a getter function

00:03:58,630 --> 00:04:05,319
which is which is simply returning the

00:04:01,540 --> 00:04:07,660
private variable and finally we have a

00:04:05,319 --> 00:04:09,489
getter function sorry is setter function

00:04:07,660 --> 00:04:12,609
which sits together with the input

00:04:09,489 --> 00:04:15,610
property input decorator and whenever

00:04:12,609 --> 00:04:17,410
the the input prop

00:04:15,610 --> 00:04:20,890
is to be changed the setup function will

00:04:17,410 --> 00:04:23,260
take over the task and and doing two

00:04:20,890 --> 00:04:25,540
things the first is to store the new

00:04:23,260 --> 00:04:28,660
value to the private variable and the

00:04:25,540 --> 00:04:31,690
second is to execute some your

00:04:28,660 --> 00:04:35,590
customizer code like name is change

00:04:31,690 --> 00:04:38,220
right however okay the good thing about

00:04:35,590 --> 00:04:42,820
it is that it decouples angel on changes

00:04:38,220 --> 00:04:44,950
however there is several cons I don't

00:04:42,820 --> 00:04:48,850
really like it so first it's about too

00:04:44,950 --> 00:04:51,640
many pieces we can see that for just the

00:04:48,850 --> 00:04:54,520
two input properties we need to have six

00:04:51,640 --> 00:04:56,710
pieces and they can be rearranged in any

00:04:54,520 --> 00:05:00,669
order right which makes the code hard to

00:04:56,710 --> 00:05:02,200
maintain hard to read and for the getter

00:05:00,669 --> 00:05:04,600
function and the private variable

00:05:02,200 --> 00:05:09,010
declaration is just a coil thing right

00:05:04,600 --> 00:05:10,630
and finally private variable not really

00:05:09,010 --> 00:05:15,910
private but private variable I mean

00:05:10,630 --> 00:05:18,669
these two underscored variable why they

00:05:15,910 --> 00:05:22,150
they are truly private to the outside

00:05:18,669 --> 00:05:25,419
world however they're not private within

00:05:22,150 --> 00:05:28,060
this component right so bye-bye private

00:05:25,419 --> 00:05:30,430
within this company I mean I mean hey

00:05:28,060 --> 00:05:32,650
don't touch me directly if you want to

00:05:30,430 --> 00:05:34,570
read me just use the getter function if

00:05:32,650 --> 00:05:36,790
you want to write me just use the setup

00:05:34,570 --> 00:05:40,510
function right but this rule is not

00:05:36,790 --> 00:05:42,550
enforced and people would easily make a

00:05:40,510 --> 00:05:45,310
mistake by accessing the private

00:05:42,550 --> 00:05:48,070
variable directly for example if we need

00:05:45,310 --> 00:05:50,700
to write a grou method which simply

00:05:48,070 --> 00:05:53,320
increment the age by one then apparently

00:05:50,700 --> 00:05:55,090
the first way is wrong because the first

00:05:53,320 --> 00:05:59,500
way we're now trigger a set of function

00:05:55,090 --> 00:06:02,620
right but but this so the reason that

00:05:59,500 --> 00:06:04,360
the not allowing you to access the

00:06:02,620 --> 00:06:09,280
private variable the rule is not

00:06:04,360 --> 00:06:13,450
enforced let's think about how to solve

00:06:09,280 --> 00:06:17,110
this problem nicely so we want to listen

00:06:13,450 --> 00:06:19,540
to the change of say name property it

00:06:17,110 --> 00:06:22,510
would be amazing if we can if we could

00:06:19,540 --> 00:06:25,539
have a a callback function which can

00:06:22,510 --> 00:06:28,120
just put aside just beside the name

00:06:25,539 --> 00:06:29,080
property right and every time hopefully

00:06:28,120 --> 00:06:31,419
we can make a work

00:06:29,080 --> 00:06:33,310
in a way that every time a name is

00:06:31,419 --> 00:06:38,470
changed then the callback function is

00:06:33,310 --> 00:06:41,020
triggered same for H right it has a lot

00:06:38,470 --> 00:06:44,949
of good stuff first we also decompose

00:06:41,020 --> 00:06:47,319
enjoin changes right and the second no

00:06:44,949 --> 00:06:49,750
need to change existing code if we want

00:06:47,319 --> 00:06:52,150
this feature we just need to add this

00:06:49,750 --> 00:06:56,050
block of code if we don't want it we

00:06:52,150 --> 00:06:58,060
just remove it right and finally it's

00:06:56,050 --> 00:07:01,690
easy to read and use it's apparently

00:06:58,060 --> 00:07:05,229
right okay so I just introduced my

00:07:01,690 --> 00:07:08,259
blueprint of what I what I want this to

00:07:05,229 --> 00:07:11,909
be working like right now let's try to

00:07:08,259 --> 00:07:15,210
implement the on unchanged decorator

00:07:11,909 --> 00:07:18,490
okay but before we do it

00:07:15,210 --> 00:07:22,479
do no JavaScript getter and setter well

00:07:18,490 --> 00:07:24,520
enough okay let's let's pause the main

00:07:22,479 --> 00:07:26,680
thread a little bit and let me introduce

00:07:24,520 --> 00:07:30,039
you get a little deeper knowledge into

00:07:26,680 --> 00:07:32,680
getter and setter this is a typescript

00:07:30,039 --> 00:07:36,669
class person with a getter and setter

00:07:32,680 --> 00:07:40,599
for the prompt eh okay when I compile

00:07:36,669 --> 00:07:44,289
this into es5 we can see how getter and

00:07:40,599 --> 00:07:47,380
setter is implemented under the hood so

00:07:44,289 --> 00:07:50,979
the object of define property is caught

00:07:47,380 --> 00:07:54,009
with three parameters the first is the

00:07:50,979 --> 00:07:57,629
prototype of a person the second is the

00:07:54,009 --> 00:08:01,060
prop prop the key the third one is a

00:07:57,629 --> 00:08:03,310
configuration object it has a key get

00:08:01,060 --> 00:08:06,580
the value is the getter function and

00:08:03,310 --> 00:08:10,090
another key set the value is the setter

00:08:06,580 --> 00:08:11,919
function okay so with this knowledge in

00:08:10,090 --> 00:08:16,360
mind we can rewrite the class in this

00:08:11,919 --> 00:08:19,300
way in time squared we can instead of

00:08:16,360 --> 00:08:22,900
declaring getter and setter within this

00:08:19,300 --> 00:08:25,270
class we can modify a existing class by

00:08:22,900 --> 00:08:28,539
calling object the define property with

00:08:25,270 --> 00:08:30,460
the same three parameters okay so the

00:08:28,539 --> 00:08:32,919
key takeaway of this slide is that we

00:08:30,460 --> 00:08:36,699
can use object or define property to

00:08:32,919 --> 00:08:40,000
modify an existing class and add and

00:08:36,699 --> 00:08:41,670
configure setter and it's indicator for

00:08:40,000 --> 00:08:45,410
a particular

00:08:41,670 --> 00:08:48,000
key property the first parameter is

00:08:45,410 --> 00:08:50,970
prototype of the class the second one is

00:08:48,000 --> 00:08:52,830
the property key the third one is a

00:08:50,970 --> 00:08:55,260
configuration object containing getter

00:08:52,830 --> 00:08:57,360
and setter information okay that's

00:08:55,260 --> 00:08:58,830
enough knowledge forgetting etc let's

00:08:57,360 --> 00:09:03,210
get back to me if we were to implement

00:08:58,830 --> 00:09:06,540
the unchanged decorator this this our

00:09:03,210 --> 00:09:08,550
first on the left-hand side is our first

00:09:06,540 --> 00:09:10,110
implementation of content decorator on

00:09:08,550 --> 00:09:13,380
the right-hand side I'm just keeping in

00:09:10,110 --> 00:09:17,060
my blueprint as a reference okay I'm

00:09:13,380 --> 00:09:17,060
gonna give you 10 seconds to read it

00:09:23,600 --> 00:09:30,690
okay so a decorator is essentially a

00:09:27,450 --> 00:09:32,760
function or a function factory in this

00:09:30,690 --> 00:09:36,270
case it's a function factory it returns

00:09:32,760 --> 00:09:40,800
a new function with two input parameters

00:09:36,270 --> 00:09:45,660
right target and key if we put the

00:09:40,800 --> 00:09:49,640
unchanged decorator besides a property

00:09:45,660 --> 00:09:52,650
then typescript would automatically

00:09:49,640 --> 00:09:56,460
passing the prototype of the class to

00:09:52,650 --> 00:10:01,470
the target and the property key name or

00:09:56,460 --> 00:10:03,210
age to the key so in effect the object

00:10:01,470 --> 00:10:06,150
the define property will be triggered

00:10:03,210 --> 00:10:09,240
during compile time with three

00:10:06,150 --> 00:10:13,380
parameters again first prototype of name

00:10:09,240 --> 00:10:17,750
con component second property key name

00:10:13,380 --> 00:10:19,770
or age right the third parameter is a

00:10:17,750 --> 00:10:23,760
configuration object or setter and

00:10:19,770 --> 00:10:27,240
getter so basically this is to modify

00:10:23,760 --> 00:10:29,340
the existing name car component during

00:10:27,240 --> 00:10:33,450
compound time and a together and the

00:10:29,340 --> 00:10:35,670
setter for for name and age right let's

00:10:33,450 --> 00:10:39,030
let's take a look at what's inside to

00:10:35,670 --> 00:10:41,700
get insider' for the camera function it

00:10:39,030 --> 00:10:45,270
simply returns something what's the

00:10:41,700 --> 00:10:48,720
keyword this here the keyword this means

00:10:45,270 --> 00:10:52,680
a instance a instance of name car

00:10:48,720 --> 00:10:55,320
component and the cash value key is a

00:10:52,680 --> 00:10:59,610
randomly generated number to used as a

00:10:55,320 --> 00:11:02,070
key so here we basically have a binding

00:10:59,610 --> 00:11:04,470
a key value pair to the component

00:11:02,070 --> 00:11:07,620
instance the value is to store the

00:11:04,470 --> 00:11:09,750
current value right for the center

00:11:07,620 --> 00:11:13,380
function it does two things the first is

00:11:09,750 --> 00:11:15,960
to store the new value and the second is

00:11:13,380 --> 00:11:17,690
to trigger a callback function and the

00:11:15,960 --> 00:11:23,610
callback function is of course a

00:11:17,690 --> 00:11:28,530
parameter phone change decorator this

00:11:23,610 --> 00:11:31,110
works this absolutely works just a side

00:11:28,530 --> 00:11:33,420
note about the master random here we

00:11:31,110 --> 00:11:35,430
need to generate a randomly a random key

00:11:33,420 --> 00:11:38,640
right I would recommend a better way to

00:11:35,430 --> 00:11:42,480
use symbol so symbol was introduced in

00:11:38,640 --> 00:11:44,400
es6 and the biggest of features about

00:11:42,480 --> 00:11:46,860
symbols is that first symbol is

00:11:44,400 --> 00:11:50,520
absolutely unique no two symbols are

00:11:46,860 --> 00:11:54,060
equal and secondly symbol can be used as

00:11:50,520 --> 00:11:56,580
a object key so here we have we created

00:11:54,060 --> 00:12:01,740
two symbols one for key sorry one for

00:11:56,580 --> 00:12:04,170
name one for age right okay this works

00:12:01,740 --> 00:12:08,130
this totally works this works very well

00:12:04,170 --> 00:12:09,960
then it improve it further first I don't

00:12:08,130 --> 00:12:13,200
want to trigger the callback function if

00:12:09,960 --> 00:12:16,650
the input sorry if the owed value and

00:12:13,200 --> 00:12:19,020
the new value are equal right so I just

00:12:16,650 --> 00:12:20,670
need to add an if statement by comparing

00:12:19,020 --> 00:12:23,570
the new value in the Oh value if they

00:12:20,670 --> 00:12:26,640
are the same just to do nothing

00:12:23,570 --> 00:12:30,690
my second improvement is better typing

00:12:26,640 --> 00:12:32,490
the current probably is that we type

00:12:30,690 --> 00:12:34,440
script doesn't know doesn't really know

00:12:32,490 --> 00:12:37,710
what's the type of the new value here

00:12:34,440 --> 00:12:41,700
right so to solve this we can add a

00:12:37,710 --> 00:12:43,770
generic type T to the phone change

00:12:41,700 --> 00:12:45,930
decorator and we can type the callback

00:12:43,770 --> 00:12:51,270
function to have a function type which

00:12:45,930 --> 00:12:54,660
takes in one parameter of type T right

00:12:51,270 --> 00:12:57,600
so in this case I just need to modify

00:12:54,660 --> 00:13:00,690
the our blueprint a little bit by

00:12:57,600 --> 00:13:04,140
passing a type to the on change

00:13:00,690 --> 00:13:08,490
decorator so type script can

00:13:04,140 --> 00:13:11,070
knows that the new value here is a

00:13:08,490 --> 00:13:17,100
strain for the name and the new value

00:13:11,070 --> 00:13:19,740
down here for the age is number the

00:13:17,100 --> 00:13:22,440
third improvement is simple change

00:13:19,740 --> 00:13:25,709
we know that ngoen changes not only

00:13:22,440 --> 00:13:28,769
provides us with new value right it also

00:13:25,709 --> 00:13:31,890
provides us with previous value and and

00:13:28,769 --> 00:13:34,860
some additional information and that was

00:13:31,890 --> 00:13:38,070
defined in in in a simple change that I

00:13:34,860 --> 00:13:40,260
show you just now so here I want my

00:13:38,070 --> 00:13:42,420
callback function to have to have the

00:13:40,260 --> 00:13:44,670
same amount of the information right so

00:13:42,420 --> 00:13:46,860
my callback function should not only

00:13:44,670 --> 00:13:50,820
have the new value but also have a

00:13:46,860 --> 00:13:53,339
optional change simple change object so

00:13:50,820 --> 00:13:57,750
I can do more stuff in my callback

00:13:53,339 --> 00:14:00,420
function so to achieve this okay so here

00:13:57,750 --> 00:14:04,380
I modify my my simple change a little

00:14:00,420 --> 00:14:05,790
bit by adding a a generic type T so the

00:14:04,380 --> 00:14:07,649
previous value and current value can be

00:14:05,790 --> 00:14:12,390
tapped to T instead of any defined by

00:14:07,649 --> 00:14:15,120
anger okay so to illustrate my point

00:14:12,390 --> 00:14:16,860
better here let's just to focus on the

00:14:15,120 --> 00:14:20,270
previous value and in the current value

00:14:16,860 --> 00:14:24,720
let's just ignore the the other tears

00:14:20,270 --> 00:14:27,920
okay so what we need to do in on change

00:14:24,720 --> 00:14:30,089
rectory is three things the first in the

00:14:27,920 --> 00:14:34,910
in the typing of the callback function

00:14:30,089 --> 00:14:38,120
we just need to add a second parameter

00:14:34,910 --> 00:14:41,339
which has type simple change of T and

00:14:38,120 --> 00:14:44,279
just before we call the call the

00:14:41,339 --> 00:14:46,949
callback function we need to create a

00:14:44,279 --> 00:14:48,779
simple change object with previous value

00:14:46,949 --> 00:14:51,360
in the current Val it's easy it's very

00:14:48,779 --> 00:14:53,610
easy to get right and finally when we

00:14:51,360 --> 00:14:56,250
trigger our callback function we not

00:14:53,610 --> 00:14:59,390
only pass the new value we also pass a

00:14:56,250 --> 00:14:59,390
simple change object

00:15:00,610 --> 00:15:05,920
so it is trigger to mention that if you

00:15:03,309 --> 00:15:08,110
want to implement the full interface of

00:15:05,920 --> 00:15:09,910
simple change the code will look a

00:15:08,110 --> 00:15:12,489
little bit more complicated but there's

00:15:09,910 --> 00:15:16,509
no additional knowledge around it

00:15:12,489 --> 00:15:18,939
it's just mmm we just use this exact

00:15:16,509 --> 00:15:23,799
same technique so I'm gonna skip this

00:15:18,939 --> 00:15:26,139
part what we can achieve is is huge

00:15:23,799 --> 00:15:29,559
right so whenever we want to achieve

00:15:26,139 --> 00:15:31,449
want to listen to the name the change of

00:15:29,559 --> 00:15:35,529
the name property we just need to add an

00:15:31,449 --> 00:15:38,860
unchanged decorator with the input out

00:15:35,529 --> 00:15:42,220
on top of the property then we give a

00:15:38,860 --> 00:15:43,749
callback function right so the so that

00:15:42,220 --> 00:15:45,339
whenever the name is changed the

00:15:43,749 --> 00:15:46,929
callback function will be trigger and

00:15:45,339 --> 00:15:50,199
the callback function will have access

00:15:46,929 --> 00:15:55,139
to the new value and some additional

00:15:50,199 --> 00:15:58,809
information defining simple change right

00:15:55,139 --> 00:16:01,660
okay just some additional notes about

00:15:58,809 --> 00:16:05,049
this decorator this decorator can also

00:16:01,660 --> 00:16:07,419
be used with non input properties it

00:16:05,049 --> 00:16:09,279
doesn't ask we we don't have to use

00:16:07,419 --> 00:16:12,600
together with input properties you can

00:16:09,279 --> 00:16:16,839
use it together with any regular

00:16:12,600 --> 00:16:22,869
properties inside the class but in Gion

00:16:16,839 --> 00:16:24,939
changes can't we win right and it also

00:16:22,869 --> 00:16:27,189
works very well with dynamic component

00:16:24,939 --> 00:16:30,699
because dynamic component doesn't really

00:16:27,189 --> 00:16:35,169
have input property or even enjoin

00:16:30,699 --> 00:16:38,230
changes like seconds finally

00:16:35,169 --> 00:16:40,179
typescript is the only dependency we

00:16:38,230 --> 00:16:42,610
don't have to use it it's not an angular

00:16:40,179 --> 00:16:44,980
thing we don't have to using angular we

00:16:42,610 --> 00:16:49,600
can't use it anywhere as long as we as

00:16:44,980 --> 00:16:53,529
long as we use typescript and I've

00:16:49,600 --> 00:16:59,489
published this as a NPM package called

00:16:53,529 --> 00:16:59,489
property watch decorator name is law

00:16:59,690 --> 00:17:05,030
and this is my the end of my talk and if

00:17:03,260 --> 00:17:07,970
you have any questions feedback please

00:17:05,030 --> 00:17:08,910
feel free to reach out thank you for

00:17:07,970 --> 00:17:12,979
listening

00:17:08,910 --> 00:17:12,979
[Applause]

00:17:19,319 --> 00:17:26,049
[Music]

00:17:31,870 --> 00:17:33,930

YouTube URL: https://www.youtube.com/watch?v=rVDMmlCRvkg


