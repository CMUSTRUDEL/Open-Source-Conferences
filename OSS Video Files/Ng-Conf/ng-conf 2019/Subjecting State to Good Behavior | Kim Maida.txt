Title: Subjecting State to Good Behavior | Kim Maida
Publication date: 2019-05-03
Playlist: ng-conf 2019
Description: 
	Apps of all sizes need to manage state, but not all apps need a state machine like NgRx. What if we can’t afford the code cost? What if we don’t want to decouple our business layer? The quick answer might be “inputs! outputs! subjects!” But there’s more to Angular state management than just getters and setters or a global stream. Let’s set up readable, uncomplicated state management using behavior subjects, observables, and immutability — all OnPush ready. In this talk, we’ll explore a couple of approaches for reactive state management in Angular.

ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:07,920 --> 00:00:11,170
[Music]

00:00:11,960 --> 00:00:17,010
so today I am going to talk to you about

00:00:14,670 --> 00:00:19,320
reactive state management with behavior

00:00:17,010 --> 00:00:21,180
subjects so Lucas it a great type

00:00:19,320 --> 00:00:23,369
introducing me but a little bit about

00:00:21,180 --> 00:00:26,279
myself I run a couple of Deverell teams

00:00:23,369 --> 00:00:28,890
at an identity and authorization company

00:00:26,279 --> 00:00:30,060
I also manage to convince some people at

00:00:28,890 --> 00:00:34,200
Google that I know something about

00:00:30,060 --> 00:00:36,870
angular so state management and angular

00:00:34,200 --> 00:00:38,760
when we tackle this topic we've got a

00:00:36,870 --> 00:00:40,829
lot of third-party options for state

00:00:38,760 --> 00:00:42,719
management libraries and in fact it's

00:00:40,829 --> 00:00:44,309
starting to sort of feel like this these

00:00:42,719 --> 00:00:45,840
days I feel like there's a state

00:00:44,309 --> 00:00:48,090
management library sort of popping up

00:00:45,840 --> 00:00:50,010
all the time but I want to stick it step

00:00:48,090 --> 00:00:52,320
back I think about why is this happening

00:00:50,010 --> 00:00:54,000
what's the reason for that and it's

00:00:52,320 --> 00:00:55,980
really this right not every application

00:00:54,000 --> 00:00:58,170
has the same needs not every team goes

00:00:55,980 --> 00:01:00,090
through the same development cycle I

00:00:58,170 --> 00:01:02,160
want to tell you a little bit about an

00:01:00,090 --> 00:01:04,769
application that I built once in angular

00:01:02,160 --> 00:01:07,409
and this was an application for a

00:01:04,769 --> 00:01:10,439
preschool registration call center so

00:01:07,409 --> 00:01:12,600
employees of the preschool would answer

00:01:10,439 --> 00:01:14,520
phones for families calling in to get

00:01:12,600 --> 00:01:16,170
their kids signed up for preschool so

00:01:14,520 --> 00:01:18,000
they only ever had to look at one

00:01:16,170 --> 00:01:19,470
family's data at a time so essentially

00:01:18,000 --> 00:01:22,830
they only had to manage one piece of

00:01:19,470 --> 00:01:24,180
state at a time but moreover on top of

00:01:22,830 --> 00:01:26,009
that there was also the development

00:01:24,180 --> 00:01:27,180
lifecycle that I had to consider so

00:01:26,009 --> 00:01:29,220
after I was done with the main

00:01:27,180 --> 00:01:30,720
architecture of the application I'm

00:01:29,220 --> 00:01:32,750
gonna pass it off to another front-end

00:01:30,720 --> 00:01:36,150
developer who worked at my company and

00:01:32,750 --> 00:01:37,710
this gentleman was sort of familiar with

00:01:36,150 --> 00:01:39,600
JavaScript but he didn't have any

00:01:37,710 --> 00:01:41,220
experience with angular he didn't have

00:01:39,600 --> 00:01:42,990
any experience with sort of things like

00:01:41,220 --> 00:01:46,530
Redux pattern or anything like that and

00:01:42,990 --> 00:01:49,140
then after he was done with his sort of

00:01:46,530 --> 00:01:50,790
tour of duty on the application we're

00:01:49,140 --> 00:01:53,040
gonna pass it off to the client who's

00:01:50,790 --> 00:01:55,049
development team was composed entirely

00:01:53,040 --> 00:01:56,549
of back-end developers so they didn't

00:01:55,049 --> 00:01:59,759
regularly work with JavaScript they had

00:01:56,549 --> 00:02:01,560
no angular experience definitely no

00:01:59,759 --> 00:02:03,659
experience with state management third

00:02:01,560 --> 00:02:05,670
party state management libraries so in

00:02:03,659 --> 00:02:09,360
this case it really didn't make sense to

00:02:05,670 --> 00:02:11,640
use one the nice thing is angular comes

00:02:09,360 --> 00:02:13,190
with rxjs so we can manage state

00:02:11,640 --> 00:02:15,140
reactively and because

00:02:13,190 --> 00:02:16,610
people who are learning angular need to

00:02:15,140 --> 00:02:19,040
sort of learn how to manage streams

00:02:16,610 --> 00:02:20,900
anyway just in the course of their sort

00:02:19,040 --> 00:02:23,150
of angular learning journey it made

00:02:20,900 --> 00:02:24,890
sense that we would do this and it

00:02:23,150 --> 00:02:28,820
wouldn't be any extra cognitive burden

00:02:24,890 --> 00:02:30,700
for them to follow along with this so

00:02:28,820 --> 00:02:34,580
Kula we can do this with rxjs

00:02:30,700 --> 00:02:36,350
and one strategy that we can use in

00:02:34,580 --> 00:02:38,810
order to leverage our class before this

00:02:36,350 --> 00:02:42,590
is subjects so a little bit about

00:02:38,810 --> 00:02:44,210
subjects subjects are observables but

00:02:42,590 --> 00:02:46,610
they have state so they keep a list of

00:02:44,210 --> 00:02:48,260
observers in addition they implement the

00:02:46,610 --> 00:02:49,970
observer interface which gives them

00:02:48,260 --> 00:02:52,220
access to the next error incomplete

00:02:49,970 --> 00:02:55,430
methods and then some subjects can also

00:02:52,220 --> 00:02:57,170
multicast and this means that the same

00:02:55,430 --> 00:03:00,260
observable execution is shared among

00:02:57,170 --> 00:03:03,530
multiple subscribers now the thing that

00:03:00,260 --> 00:03:05,570
happens when you give developers sort of

00:03:03,530 --> 00:03:06,800
free and unfettered access to something

00:03:05,570 --> 00:03:09,500
like the next method in their

00:03:06,800 --> 00:03:11,030
applications is you can kind of induce

00:03:09,500 --> 00:03:13,520
what eyes a call sort of a reactive

00:03:11,030 --> 00:03:15,230
power trip where people people get

00:03:13,520 --> 00:03:17,060
tempted to just use the next method

00:03:15,230 --> 00:03:19,580
anywhere and everywhere in their

00:03:17,060 --> 00:03:21,709
application and so when it comes to

00:03:19,580 --> 00:03:23,630
managing state reactively with arcs yes

00:03:21,709 --> 00:03:25,850
we really need some kind of a strategy

00:03:23,630 --> 00:03:28,570
here we don't want to do this sort of

00:03:25,850 --> 00:03:31,489
next all the things all over the place

00:03:28,570 --> 00:03:34,580
so one of the strategies that's become

00:03:31,489 --> 00:03:36,739
sort of more well known in the angular

00:03:34,580 --> 00:03:39,800
landscape recently is this concept of

00:03:36,739 --> 00:03:41,150
service with a subject and so we might

00:03:39,800 --> 00:03:43,700
start out doing this but we create a

00:03:41,150 --> 00:03:45,230
service we would create a store subject

00:03:43,700 --> 00:03:47,600
and this would be a private behavior

00:03:45,230 --> 00:03:50,660
subject and behavior subjects require an

00:03:47,600 --> 00:03:52,910
initial state so we give it an initial

00:03:50,660 --> 00:03:55,820
value when we instantiate the behavior

00:03:52,910 --> 00:03:58,100
subject now they also store the current

00:03:55,820 --> 00:03:59,959
value and then they will notify

00:03:58,100 --> 00:04:01,880
subscribers of the currently stored

00:03:59,959 --> 00:04:03,650
value on subscription so if we get a

00:04:01,880 --> 00:04:05,810
subscriber and we haven't admitted any

00:04:03,650 --> 00:04:07,760
values yet then they're going to get the

00:04:05,810 --> 00:04:09,230
initial value if we've emitted a few

00:04:07,760 --> 00:04:11,330
values already then they're gonna get

00:04:09,230 --> 00:04:14,260
whatever was emitted last so really this

00:04:11,330 --> 00:04:17,810
sets it up for a really good model for

00:04:14,260 --> 00:04:21,049
sort of global store throughout the

00:04:17,810 --> 00:04:23,090
application not because we set up our

00:04:21,049 --> 00:04:25,039
behavior subject is private we need to

00:04:23,090 --> 00:04:25,720
create a public observable version of it

00:04:25,039 --> 00:04:27,130
so that

00:04:25,720 --> 00:04:29,950
can actually subscribe to it in our

00:04:27,130 --> 00:04:31,930
application so we can create a store

00:04:29,950 --> 00:04:34,240
observable and then we can just use as

00:04:31,930 --> 00:04:37,900
observable method on our store subject

00:04:34,240 --> 00:04:40,360
in order to create that and what this

00:04:37,900 --> 00:04:42,700
does is it hides the identity of the

00:04:40,360 --> 00:04:46,330
source sequence so that we can't just

00:04:42,700 --> 00:04:47,590
call store dollar sign dot next and get

00:04:46,330 --> 00:04:50,890
that sort of reactive power to

00:04:47,590 --> 00:04:52,990
phenomenon happening now if you need to

00:04:50,890 --> 00:04:54,370
do any transformations on the values

00:04:52,990 --> 00:04:57,130
that you're sending into your subjects

00:04:54,370 --> 00:04:59,530
and before they're emitted then we can

00:04:57,130 --> 00:05:01,900
use pipe and then arcs yes operators and

00:04:59,530 --> 00:05:03,760
if you do this you don't need to use as

00:05:01,900 --> 00:05:07,240
observable because this also hides the

00:05:03,760 --> 00:05:09,190
identity of the source sequence now what

00:05:07,240 --> 00:05:11,890
we've done here is we're preventing

00:05:09,190 --> 00:05:15,130
leaky abstractions right so what we can

00:05:11,890 --> 00:05:17,830
do is set up sort of a logical and

00:05:15,130 --> 00:05:20,020
comprehensive strategy for how we expect

00:05:17,830 --> 00:05:23,590
our application to interact with our

00:05:20,020 --> 00:05:26,169
store and I built an application to

00:05:23,590 --> 00:05:28,000
demonstrate this a little bit this app

00:05:26,169 --> 00:05:31,419
uses the Astronomy Picture of the Day

00:05:28,000 --> 00:05:32,980
API from NASA and it just goes and gets

00:05:31,419 --> 00:05:35,169
you know sort of whatever picture NASA

00:05:32,980 --> 00:05:36,669
thinks is great for the day and if you

00:05:35,169 --> 00:05:38,410
look in the upper left hand corner you

00:05:36,669 --> 00:05:40,900
can see there's a little button with a

00:05:38,410 --> 00:05:42,550
star in it and all this really does is I

00:05:40,900 --> 00:05:44,110
can click that button and it'll sort of

00:05:42,550 --> 00:05:46,210
increment a little counter I'm sorry

00:05:44,110 --> 00:05:47,830
it's kind of hard to see but I can also

00:05:46,210 --> 00:05:49,180
hold the mouse button down on it and it

00:05:47,830 --> 00:05:50,950
will continually increment until I'm

00:05:49,180 --> 00:05:53,110
Mouse off it this is just implemented

00:05:50,950 --> 00:05:55,479
with rxjs if you're really if you're

00:05:53,110 --> 00:05:57,280
familiar with how clapping works on like

00:05:55,479 --> 00:06:01,090
the medium blog it's basically the same

00:05:57,280 --> 00:06:03,610
thing this is pretty simple as far as

00:06:01,090 --> 00:06:05,050
sort of state requirements go but what

00:06:03,610 --> 00:06:07,900
I'm gonna do is I'm gonna create a state

00:06:05,050 --> 00:06:09,310
service and in that service I'm gonna

00:06:07,900 --> 00:06:12,700
have something that looks like this now

00:06:09,310 --> 00:06:15,490
I am creating my public a pod store

00:06:12,700 --> 00:06:18,130
observable based on my private a pod

00:06:15,490 --> 00:06:20,110
subject and then I'm gonna use the scan

00:06:18,130 --> 00:06:22,600
operator and this gives me access to a

00:06:20,110 --> 00:06:24,280
couple of interesting things so first of

00:06:22,600 --> 00:06:27,280
all we have access to the accumulated

00:06:24,280 --> 00:06:30,190
value here and this is essentially the

00:06:27,280 --> 00:06:33,250
current state so it's whatever was in

00:06:30,190 --> 00:06:36,340
the the subject previously before we

00:06:33,250 --> 00:06:38,470
sent the next value in now I expect this

00:06:36,340 --> 00:06:39,240
to be in the shape of this a pod

00:06:38,470 --> 00:06:42,419
interface

00:06:39,240 --> 00:06:44,520
want some data from the API and then it

00:06:42,419 --> 00:06:47,759
may or may not have stars at any given

00:06:44,520 --> 00:06:50,789
time and I also have access to the new

00:06:47,759 --> 00:06:52,020
value which is it can be either the

00:06:50,789 --> 00:06:53,729
shape of a pot for example if I'm

00:06:52,020 --> 00:06:56,460
grabbing data directly from the API or

00:06:53,729 --> 00:06:59,009
it can be this update interface which is

00:06:56,460 --> 00:07:02,599
just an object with a Stars property and

00:06:59,009 --> 00:07:05,669
then some number of stars as I add stars

00:07:02,599 --> 00:07:07,560
now with access to both the accumulated

00:07:05,669 --> 00:07:12,030
value and the new value that I'm sending

00:07:07,560 --> 00:07:15,449
in I can return a new object as my next

00:07:12,030 --> 00:07:17,909
value in my store and this is the the

00:07:15,449 --> 00:07:19,530
previous state with updates from the new

00:07:17,909 --> 00:07:20,669
value that got sent in so it's gonna

00:07:19,530 --> 00:07:22,830
look something like this we're gonna

00:07:20,669 --> 00:07:24,740
have the API data and then we may or may

00:07:22,830 --> 00:07:27,659
not have stars

00:07:24,740 --> 00:07:29,789
lastly we have the an initial value

00:07:27,659 --> 00:07:32,039
that's gets passed in and the reason

00:07:29,789 --> 00:07:34,680
that we are doing this is because if we

00:07:32,039 --> 00:07:36,330
don't do this then the first value that

00:07:34,680 --> 00:07:38,430
gets sent into the subject just

00:07:36,330 --> 00:07:40,020
automatically becomes the first state

00:07:38,430 --> 00:07:45,570
and it doesn't actually pass through

00:07:40,020 --> 00:07:47,699
this function in scan so the next thing

00:07:45,570 --> 00:07:49,469
that we want to do is we need a way for

00:07:47,699 --> 00:07:52,469
our application to publicly interact

00:07:49,469 --> 00:07:55,139
with the store so we can have this set

00:07:52,469 --> 00:07:57,630
store method and we expect this to

00:07:55,139 --> 00:07:59,880
either be the shape of the a pod

00:07:57,630 --> 00:08:01,380
interface or the update interface and

00:07:59,880 --> 00:08:03,509
then we can just run next on our a pod

00:08:01,380 --> 00:08:05,430
subject which was private but this is

00:08:03,509 --> 00:08:09,449
sort of the public way to be able to do

00:08:05,430 --> 00:08:11,849
this that's actually it for my state

00:08:09,449 --> 00:08:13,650
service now my data service is the only

00:08:11,849 --> 00:08:16,289
thing in the application that interacts

00:08:13,650 --> 00:08:18,659
with the state service and it's gonna do

00:08:16,289 --> 00:08:20,550
some things that's going to have an an

00:08:18,659 --> 00:08:22,050
it method that goes out it's going to

00:08:20,550 --> 00:08:25,409
return an observable it's gonna make the

00:08:22,050 --> 00:08:27,000
API call to the NASA API and then once

00:08:25,409 --> 00:08:28,919
it's got that data I'm just gonna run a

00:08:27,000 --> 00:08:33,390
side effect to take the data and set it

00:08:28,919 --> 00:08:36,870
in the store now the other thing that I

00:08:33,390 --> 00:08:40,079
can do here is I have made a sort of

00:08:36,870 --> 00:08:41,969
decision to use business logic to not

00:08:40,079 --> 00:08:43,890
separate out my business logic so I'm

00:08:41,969 --> 00:08:45,660
going to set an expectation in my

00:08:43,890 --> 00:08:47,650
application that when I interact with

00:08:45,660 --> 00:08:49,810
the store

00:08:47,650 --> 00:08:51,610
and run this particular method I'm

00:08:49,810 --> 00:08:53,020
adding stars because that's how I make

00:08:51,610 --> 00:08:55,960
updates to the state

00:08:53,020 --> 00:08:58,690
so my add stars method can explicitly

00:08:55,960 --> 00:09:00,760
expect a stars object that's in the

00:08:58,690 --> 00:09:02,560
shape of that update interface and then

00:09:00,760 --> 00:09:04,570
it's going to run that set store method

00:09:02,560 --> 00:09:09,370
in order to update the Stars and send

00:09:04,570 --> 00:09:10,540
them into my scann function now the rest

00:09:09,370 --> 00:09:12,460
of the application is actually all

00:09:10,540 --> 00:09:14,140
composed in the app component because

00:09:12,460 --> 00:09:16,450
it's a pretty simple app you thought it

00:09:14,140 --> 00:09:19,600
was quite straightforward on

00:09:16,450 --> 00:09:21,310
initialization I'm going to subscribe to

00:09:19,600 --> 00:09:23,440
my init method to go get the data from

00:09:21,310 --> 00:09:25,270
the API once I've got that data then I'm

00:09:23,440 --> 00:09:27,190
just gonna run a local method called

00:09:25,270 --> 00:09:29,350
setup stars and this is sort of where

00:09:27,190 --> 00:09:32,110
all of the functionality for the rxjs

00:09:29,350 --> 00:09:34,210
with clicking the button and holding the

00:09:32,110 --> 00:09:35,860
mouse down that's where this all happens

00:09:34,210 --> 00:09:38,740
it looks like this don't worry too much

00:09:35,860 --> 00:09:41,950
about that but I have this function

00:09:38,740 --> 00:09:44,470
called add star that actually goes and

00:09:41,950 --> 00:09:49,089
calls my add stars method from my data

00:09:44,470 --> 00:09:50,860
service and passes in that new value and

00:09:49,089 --> 00:09:52,000
that's it that's all the state

00:09:50,860 --> 00:09:54,339
management that this particular

00:09:52,000 --> 00:09:56,350
application requires and the nice thing

00:09:54,339 --> 00:09:58,120
about this is it's pretty readable so

00:09:56,350 --> 00:09:59,920
people who are coming into angular

00:09:58,120 --> 00:10:02,110
they're learning how streams work how to

00:09:59,920 --> 00:10:03,339
interact with rxjs they can read this

00:10:02,110 --> 00:10:06,660
and figure out what's happening pretty

00:10:03,339 --> 00:10:09,459
easily but it may have been an

00:10:06,660 --> 00:10:10,450
oversimplified example right so what if

00:10:09,459 --> 00:10:12,910
we want to do something a little more

00:10:10,450 --> 00:10:15,160
complex what about something like

00:10:12,910 --> 00:10:17,100
optimistic updates for example so

00:10:15,160 --> 00:10:19,930
optimistic updates are when we

00:10:17,100 --> 00:10:23,140
optimistically update our local state or

00:10:19,930 --> 00:10:24,880
our NR UI and then we make our API call

00:10:23,140 --> 00:10:27,100
silently unless we do this with the

00:10:24,880 --> 00:10:29,290
assumption that the API call is going to

00:10:27,100 --> 00:10:32,080
succeed if it doesn't then we have to

00:10:29,290 --> 00:10:34,420
handle that sort of separately but

00:10:32,080 --> 00:10:36,160
optimistic updates are something that we

00:10:34,420 --> 00:10:38,680
might do if we want our apps to look

00:10:36,160 --> 00:10:41,740
really fast and if our API is very

00:10:38,680 --> 00:10:43,510
reliable like we would never do this for

00:10:41,740 --> 00:10:46,120
high stakes operations you don't want to

00:10:43,510 --> 00:10:47,860
do it if you are changing users password

00:10:46,120 --> 00:10:50,980
or financial transactions or anything

00:10:47,860 --> 00:10:53,980
like that but if you do have sort of a

00:10:50,980 --> 00:10:55,540
low stakes API and it's very reliable

00:10:53,980 --> 00:10:57,220
then it's a great way to make your

00:10:55,540 --> 00:10:59,800
applications look extremely fast for

00:10:57,220 --> 00:11:02,970
example if you use Trello you probably

00:10:59,800 --> 00:11:05,170
see this charlie uses optimistic updates

00:11:02,970 --> 00:11:06,820
so in order to demonstrate this I built

00:11:05,170 --> 00:11:09,279
another application and this one uses

00:11:06,820 --> 00:11:11,740
the near-earth objects API from NASA and

00:11:09,279 --> 00:11:14,470
what its gonna do it goes and it calls

00:11:11,740 --> 00:11:16,149
that API and then it displays all of the

00:11:14,470 --> 00:11:19,029
asteroids that are close to Earth for

00:11:16,149 --> 00:11:20,380
any given time period and I have a

00:11:19,029 --> 00:11:22,269
couple of different views of this I've

00:11:20,380 --> 00:11:24,250
got it filtered down to like bigger

00:11:22,269 --> 00:11:26,320
faster ones and then ones that are

00:11:24,250 --> 00:11:28,360
smaller if I go back to the home page

00:11:26,320 --> 00:11:30,910
then what I'm actually gonna do here is

00:11:28,360 --> 00:11:33,579
my app gives me the ability to change to

00:11:30,910 --> 00:11:35,800
add a nickname to these so I'm gonna go

00:11:33,579 --> 00:11:38,110
ahead and open the console and then this

00:11:35,800 --> 00:11:40,420
one here is actually flagged by NASA's

00:11:38,110 --> 00:11:43,810
potentially hazardous so I'm going to

00:11:40,420 --> 00:11:46,899
call this one Armageddon I'm going to

00:11:43,810 --> 00:11:49,480
save and you see my UI updated and now a

00:11:46,899 --> 00:11:51,519
couple of seconds later I get the update

00:11:49,480 --> 00:11:54,519
from the API it's just a success message

00:11:51,519 --> 00:11:57,730
as it says that worked now if I go ahead

00:11:54,519 --> 00:11:59,709
and clear this out and then I go over to

00:11:57,730 --> 00:12:02,019
my other filtered views you can see that

00:11:59,709 --> 00:12:04,959
that change is persisted so my local

00:12:02,019 --> 00:12:05,980
store has been updated with that now I'm

00:12:04,959 --> 00:12:09,070
gonna to do another one

00:12:05,980 --> 00:12:10,329
so this one is really really small it's

00:12:09,070 --> 00:12:10,810
like it's super tiny so I'm gonna call

00:12:10,329 --> 00:12:15,370
it tiny

00:12:10,810 --> 00:12:17,200
I'm gonna hit save my UI updated but

00:12:15,370 --> 00:12:18,940
then I got an error from the API so as

00:12:17,200 --> 00:12:19,360
you can see the UI sort of rolled that

00:12:18,940 --> 00:12:21,459
back

00:12:19,360 --> 00:12:24,370
I don't tidy still in the field but it's

00:12:21,459 --> 00:12:25,750
not in the store anymore and I also have

00:12:24,370 --> 00:12:28,329
this error toast that popped up in the

00:12:25,750 --> 00:12:30,100
corner if I go back to my home view that

00:12:28,329 --> 00:12:32,230
lists everything you can see that that

00:12:30,100 --> 00:12:37,360
same item which is right here no longer

00:12:32,230 --> 00:12:40,149
has that nickname so we can implement

00:12:37,360 --> 00:12:42,430
this with rxjs in a fairly

00:12:40,149 --> 00:12:44,050
straightforward way so what I'm gonna do

00:12:42,430 --> 00:12:46,120
this time though is I'm gonna create a

00:12:44,050 --> 00:12:48,550
state class and the reason I'm doing it

00:12:46,120 --> 00:12:51,040
this way is because I want to keep my

00:12:48,550 --> 00:12:52,390
state management logic organized but I

00:12:51,040 --> 00:12:54,610
don't necessarily want it to be

00:12:52,390 --> 00:12:56,079
perceived as being an injectable service

00:12:54,610 --> 00:12:57,459
on its own I don't really want other

00:12:56,079 --> 00:12:59,829
developers who pick up that my

00:12:57,459 --> 00:13:01,810
application to think that all the state

00:12:59,829 --> 00:13:03,760
service is a service I'm just gonna

00:13:01,810 --> 00:13:08,770
stick it in wherever I need to touch the

00:13:03,760 --> 00:13:11,079
state so my state class looks pretty

00:13:08,770 --> 00:13:12,769
familiar too the first example that I

00:13:11,079 --> 00:13:16,009
showed for the

00:13:12,769 --> 00:13:18,199
the day I have a private store subject

00:13:16,009 --> 00:13:19,790
and this is behavior selfish Scot

00:13:18,199 --> 00:13:22,220
initial state and then I have a public

00:13:19,790 --> 00:13:23,989
Neos or observable and this time I'm not

00:13:22,220 --> 00:13:27,619
doing any transformations with operators

00:13:23,989 --> 00:13:28,999
so I'm just gonna say as observable now

00:13:27,619 --> 00:13:30,920
the other thing I need though is a way

00:13:28,999 --> 00:13:33,949
to track errors because you would never

00:13:30,920 --> 00:13:35,269
push an error into your store so the way

00:13:33,949 --> 00:13:37,790
I'm gonna do this is I'm gonna create a

00:13:35,269 --> 00:13:40,910
new subject and this one is a subject

00:13:37,790 --> 00:13:42,230
not a behavior subject because I in my

00:13:40,910 --> 00:13:44,540
particular application I made a choice

00:13:42,230 --> 00:13:46,459
to clear errors on navigation so I

00:13:44,540 --> 00:13:48,259
actually don't need multi casting or

00:13:46,459 --> 00:13:50,449
replay functionality so I can just use a

00:13:48,259 --> 00:13:52,579
normal subject now I'm gonna create a

00:13:50,449 --> 00:13:55,670
public errors observable again I'm gonna

00:13:52,579 --> 00:13:57,980
use the as observable method and then in

00:13:55,670 --> 00:13:59,809
order to sort of have that optimistic

00:13:57,980 --> 00:14:01,850
updates functionality I need to have a

00:13:59,809 --> 00:14:03,410
way to essentially omit the previous

00:14:01,850 --> 00:14:06,350
state in case something goes wrong with

00:14:03,410 --> 00:14:08,299
the API so I'm going to just use a local

00:14:06,350 --> 00:14:10,009
Member it's called prove state I'm gonna

00:14:08,299 --> 00:14:11,749
get the value of the neo store subject

00:14:10,009 --> 00:14:14,980
whenever this method is run I'm gonna

00:14:11,749 --> 00:14:14,980
run it at appropriate times

00:14:15,339 --> 00:14:19,759
now I also need a way to dismiss the

00:14:17,569 --> 00:14:22,069
errors because I because I would never

00:14:19,759 --> 00:14:25,309
put errors in my store then I need some

00:14:22,069 --> 00:14:26,809
way to be able to tell the error subject

00:14:25,309 --> 00:14:28,639
if it shouldn't be showing an error

00:14:26,809 --> 00:14:30,860
anymore and so I'm just gonna omit null

00:14:28,639 --> 00:14:34,910
from a or subject whenever I need to do

00:14:30,860 --> 00:14:37,129
that now my son neo store method is a

00:14:34,910 --> 00:14:40,129
public method and this is going to

00:14:37,129 --> 00:14:41,869
expect a neo list the first thing I'm

00:14:40,129 --> 00:14:43,910
gonna do before I make any changes to

00:14:41,869 --> 00:14:45,139
this is set the previous state because I

00:14:43,910 --> 00:14:47,240
want to make sure that I have that

00:14:45,139 --> 00:14:50,509
stored and I know what it is before I

00:14:47,240 --> 00:14:52,549
make an ulceration next I'm going to

00:14:50,509 --> 00:14:54,410
omit the Neo list from my Neos store

00:14:52,549 --> 00:14:56,509
subject and then finally I'm gonna clear

00:14:54,410 --> 00:14:57,709
any errors in case there something went

00:14:56,509 --> 00:15:01,939
wrong with an interaction with the API

00:14:57,709 --> 00:15:04,100
previously now my update neo method is

00:15:01,939 --> 00:15:06,619
how I'm going to update those nicknames

00:15:04,100 --> 00:15:07,809
I expect a near-earth object just one

00:15:06,619 --> 00:15:09,079
this time the one that I'm updating

00:15:07,809 --> 00:15:10,579
again

00:15:09,079 --> 00:15:11,989
the first thing I need to do is make

00:15:10,579 --> 00:15:15,439
sure I know what that previous state was

00:15:11,989 --> 00:15:17,689
and this time I'm going to create a new

00:15:15,439 --> 00:15:19,549
state by mapping the previous state I'm

00:15:17,689 --> 00:15:21,230
gonna go through and I'm going to find

00:15:19,549 --> 00:15:23,060
the particular object that I'm modifying

00:15:21,230 --> 00:15:24,950
in the previous state

00:15:23,060 --> 00:15:26,930
and in its place I'm going to return a

00:15:24,950 --> 00:15:29,690
new object if that is the current object

00:15:26,930 --> 00:15:32,000
but has updates from the new object and

00:15:29,690 --> 00:15:35,720
by doing it this way too I'm ensuring

00:15:32,000 --> 00:15:37,640
that I have immutability so I can use on

00:15:35,720 --> 00:15:39,520
push with components that you that are

00:15:37,640 --> 00:15:41,480
sort of interacting with the store and

00:15:39,520 --> 00:15:42,800
that's just going to work out of the box

00:15:41,480 --> 00:15:46,490
because I'm because of the way I'm doing

00:15:42,800 --> 00:15:48,110
it once I've got my new state and it's

00:15:46,490 --> 00:15:50,540
already that I'm going to emit it for my

00:15:48,110 --> 00:15:53,600
new store subject and finally once again

00:15:50,540 --> 00:15:54,950
I'm going to dismiss any errors not

00:15:53,600 --> 00:15:57,380
speaking of errors I need a way to

00:15:54,950 --> 00:16:00,050
handle those so I have my state error

00:15:57,380 --> 00:16:02,150
message or I've my state error method it

00:16:00,050 --> 00:16:04,760
expects a string that is my error

00:16:02,150 --> 00:16:09,590
message I'm going to omit that string

00:16:04,760 --> 00:16:11,180
and then I need to and then I need to

00:16:09,590 --> 00:16:13,310
make sure that I'm at the previous state

00:16:11,180 --> 00:16:17,990
from my neos store subject to rollback

00:16:13,310 --> 00:16:21,920
my overly optimistic updates so I think

00:16:17,990 --> 00:16:24,410
my batteries died ominous so my data

00:16:21,920 --> 00:16:25,910
service in this case is actually going

00:16:24,410 --> 00:16:27,320
to extend my state class because it's

00:16:25,910 --> 00:16:28,580
the only thing that uses it but like I

00:16:27,320 --> 00:16:33,140
said I wanted to keep all that logic

00:16:28,580 --> 00:16:34,820
organized and together data service is

00:16:33,140 --> 00:16:36,650
going to do a lot of similar things to

00:16:34,820 --> 00:16:38,270
the first example it's going to fetch

00:16:36,650 --> 00:16:40,970
the data from the API it's going to set

00:16:38,270 --> 00:16:44,270
the store and then it's going to have an

00:16:40,970 --> 00:16:45,920
update method that updates the store so

00:16:44,270 --> 00:16:47,210
we've got our local update running and

00:16:45,920 --> 00:16:50,090
then after it does that's going to send

00:16:47,210 --> 00:16:52,310
that data to the API now if this is

00:16:50,090 --> 00:16:54,110
successful then I don't actually need to

00:16:52,310 --> 00:16:56,200
do anything else everything worked out

00:16:54,110 --> 00:16:59,120
I've already updated my store locally if

00:16:56,200 --> 00:17:01,220
there's some kind of error though then I

00:16:59,120 --> 00:17:04,520
can subscribe to my error observable and

00:17:01,220 --> 00:17:06,680
do things like show a toast in the UI

00:17:04,520 --> 00:17:08,570
and then I'm going to emit the previous

00:17:06,680 --> 00:17:13,430
state so that gives me my my sort of

00:17:08,570 --> 00:17:15,290
roll back effect and that's all there is

00:17:13,430 --> 00:17:18,080
to that like it's a pretty simple

00:17:15,290 --> 00:17:20,690
example of doing something that's that's

00:17:18,080 --> 00:17:23,450
slightly more complicated with state

00:17:20,690 --> 00:17:25,970
management it's a very desirable feature

00:17:23,450 --> 00:17:27,950
but if you sort of look at some of the

00:17:25,970 --> 00:17:29,240
code that comes along with doing

00:17:27,950 --> 00:17:30,980
optimistic updates in some of these

00:17:29,240 --> 00:17:34,100
third-party libraries it can be very

00:17:30,980 --> 00:17:35,080
daunting but in this case we have sort

00:17:34,100 --> 00:17:37,480
of done it in a way

00:17:35,080 --> 00:17:42,100
it's still pretty much as readable as

00:17:37,480 --> 00:17:45,039
the first example now it's helpful to

00:17:42,100 --> 00:17:47,470
know how to manage state with rxjs no

00:17:45,039 --> 00:17:50,649
matter what you're gonna do because rxjs

00:17:47,470 --> 00:17:52,899
is so integral to angular and angular

00:17:50,649 --> 00:17:54,519
ecosystem now for example if you do

00:17:52,899 --> 00:17:57,669
choose to use the state management

00:17:54,519 --> 00:18:00,700
library like an TRX it uses rxjs under

00:17:57,669 --> 00:18:02,980
the hood so for example this is just the

00:18:00,700 --> 00:18:05,590
very very beginning of the state class

00:18:02,980 --> 00:18:07,240
of ng rx platform and you just scan

00:18:05,590 --> 00:18:09,250
through this really quickly like you can

00:18:07,240 --> 00:18:11,529
see several things that probably looks

00:18:09,250 --> 00:18:13,330
pretty familiar now even just from sort

00:18:11,529 --> 00:18:17,110
of the 18 minutes that I've been talking

00:18:13,330 --> 00:18:19,090
about this so only good things sort of

00:18:17,110 --> 00:18:21,429
come of knowing how to manage state

00:18:19,090 --> 00:18:23,889
reactively and strategically whether

00:18:21,429 --> 00:18:25,630
you're going to do it sort of any of the

00:18:23,889 --> 00:18:26,919
ways that I described or if you're going

00:18:25,630 --> 00:18:28,779
to end up using a state management

00:18:26,919 --> 00:18:30,309
library at the end it helps to

00:18:28,779 --> 00:18:32,730
understand how those libraries function

00:18:30,309 --> 00:18:34,690
under the hood

00:18:32,730 --> 00:18:36,909
now the other important thing is that

00:18:34,690 --> 00:18:38,500
this is your strategy so you can do

00:18:36,909 --> 00:18:40,360
whatever works best for your application

00:18:38,500 --> 00:18:42,760
for your architecture for your team

00:18:40,360 --> 00:18:44,919
structure if you want to do couple-y or

00:18:42,760 --> 00:18:48,100
business object please do if you don't

00:18:44,919 --> 00:18:49,990
don't if you want to abstract it out so

00:18:48,100 --> 00:18:51,820
you have more layers of abstraction then

00:18:49,990 --> 00:18:54,549
you can do that too there's a lot of

00:18:51,820 --> 00:18:56,320
different approaches to this and you're

00:18:54,549 --> 00:18:58,510
actually going to hear several talks

00:18:56,320 --> 00:18:59,590
tomorrow about this again I'm really

00:18:58,510 --> 00:19:01,809
looking forward to hearing those myself

00:18:59,590 --> 00:19:03,760
I have not had any sort of preview to

00:19:01,809 --> 00:19:04,990
what they are but I actually fully

00:19:03,760 --> 00:19:07,450
expect them to be slightly different

00:19:04,990 --> 00:19:09,010
than the talk I just gave you so the

00:19:07,450 --> 00:19:11,049
nice thing is there's a lot of different

00:19:09,010 --> 00:19:14,880
ways to do this and you can tailor it to

00:19:11,049 --> 00:19:18,850
how you need your application to perform

00:19:14,880 --> 00:19:20,649
so these slides and the github links to

00:19:18,850 --> 00:19:22,779
the repos for both of the applications

00:19:20,649 --> 00:19:25,240
that I showed are available at this

00:19:22,779 --> 00:19:26,620
bitly link and I really appreciate you

00:19:25,240 --> 00:19:28,640
giving me 20 minutes of your time today

00:19:26,620 --> 00:19:33,049
so thank you very much

00:19:28,640 --> 00:19:33,049
[Applause]

00:19:36,650 --> 00:19:43,269
[Music]

00:19:48,880 --> 00:19:50,940

YouTube URL: https://www.youtube.com/watch?v=XuRpn8KXw6g


