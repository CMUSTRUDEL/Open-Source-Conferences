Title: Building Platforms with Angular   Jen Bourey
Publication date: 2015-03-06
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:04,900


00:00:04,900 --> 00:00:05,890
JEN BOUREY: Thank you.

00:00:05,890 --> 00:00:07,889
I'm going to be talking about building platforms

00:00:07,889 --> 00:00:09,490
with Angular.

00:00:09,490 --> 00:00:11,580
Just to introduce myself, I'm Jen Bourey.

00:00:11,580 --> 00:00:14,570
I'm currently the Tech Lead on Google Cloud Platform's Client

00:00:14,570 --> 00:00:16,110
Infrastructure team.

00:00:16,110 --> 00:00:18,610
And before I joined Google, I had a bunch

00:00:18,610 --> 00:00:20,980
of experience working on open source portal platforms,

00:00:20,980 --> 00:00:23,070
many of which I did front-end engineering for.

00:00:23,070 --> 00:00:26,020


00:00:26,020 --> 00:00:28,490
Today, I'd like to talk about some of the challenges

00:00:28,490 --> 00:00:32,900
we face when creating a large app with Angular.

00:00:32,900 --> 00:00:35,730
Some of those include managing code size,

00:00:35,730 --> 00:00:38,670
sharing code, and avoiding conflicts.

00:00:38,670 --> 00:00:41,445
Also, making changes while ensuring code quality.

00:00:41,445 --> 00:00:44,570


00:00:44,570 --> 00:00:47,070
So just to give you a little bit of context

00:00:47,070 --> 00:00:49,180
about our application.

00:00:49,180 --> 00:00:51,740
I work on the Google Cloud Platform,

00:00:51,740 --> 00:00:56,830
which is a unified web console for cloud development.

00:00:56,830 --> 00:00:59,640
And that includes things like logging and monitoring.

00:00:59,640 --> 00:01:01,380
It also includes resource management.

00:01:01,380 --> 00:01:05,110
So for example, if you wanted to spin up or shut down a VM,

00:01:05,110 --> 00:01:08,140
or work with a database.

00:01:08,140 --> 00:01:10,390
And it also includes a number of interactive features,

00:01:10,390 --> 00:01:11,723
like code editing and debugging.

00:01:11,723 --> 00:01:14,227


00:01:14,227 --> 00:01:16,310
We use a number of different JavaScript libraries,

00:01:16,310 --> 00:01:18,230
including Angular, of course.

00:01:18,230 --> 00:01:20,450
We also use something called Google Closure, which

00:01:20,450 --> 00:01:22,260
is an open source tool that gives us

00:01:22,260 --> 00:01:25,970
things like type checking, and dependency management,

00:01:25,970 --> 00:01:27,810
and compilation.

00:01:27,810 --> 00:01:31,720
We also use a number of internal Google UI component libraries.

00:01:31,720 --> 00:01:33,464
This probably won't be true forever.

00:01:33,464 --> 00:01:35,130
We're really looking forward to adopting

00:01:35,130 --> 00:01:38,290
some of the new Angular Material components.

00:01:38,290 --> 00:01:41,490
And we also have a number of feature specific

00:01:41,490 --> 00:01:43,620
external libraries, like d3 and CodeMirror.

00:01:43,620 --> 00:01:47,070


00:01:47,070 --> 00:01:49,650
Our project is one of the biggest

00:01:49,650 --> 00:01:51,500
Angular-based applications at Google.

00:01:51,500 --> 00:01:53,590
It currently includes somewhere on the order

00:01:53,590 --> 00:01:57,650
of 200,000 lines of JavaScript and template code,

00:01:57,650 --> 00:02:00,980
and that does not include comments and white space.

00:02:00,980 --> 00:02:04,440
All compiled, that adds up to over 25 megabytes

00:02:04,440 --> 00:02:09,240
of JavaScript and template code before it's compressed.

00:02:09,240 --> 00:02:12,430
Google is a big global company, so we are also

00:02:12,430 --> 00:02:15,460
working with dozens of teams across multiple offices

00:02:15,460 --> 00:02:17,360
and multiple time zones.

00:02:17,360 --> 00:02:18,900
That's certainly common at Google,

00:02:18,900 --> 00:02:21,191
but it does add to some of our coordination challenges.

00:02:21,191 --> 00:02:25,140


00:02:25,140 --> 00:02:28,160
So contributions to our project include a number of core teams

00:02:28,160 --> 00:02:29,790
which are responsible for doing things

00:02:29,790 --> 00:02:32,000
like maintaining infrastructure, and building

00:02:32,000 --> 00:02:35,470
shared libraries and UI widgets, and also includes

00:02:35,470 --> 00:02:38,330
a number of contributing teams they typically do domain

00:02:38,330 --> 00:02:40,570
specific feature development.

00:02:40,570 --> 00:02:42,940
My team is one of the infrastructure teams.

00:02:42,940 --> 00:02:46,280
So I view our users both as the end users who will eventually

00:02:46,280 --> 00:02:48,254
interact with our web page, but also

00:02:48,254 --> 00:02:49,670
the developers who are going to be

00:02:49,670 --> 00:02:51,490
developing for our application.

00:02:51,490 --> 00:02:53,220
So we're really focused on trying

00:02:53,220 --> 00:02:56,570
to build a platform that will be a pleasant place for people

00:02:56,570 --> 00:02:58,119
to do development and on building

00:02:58,119 --> 00:02:59,160
libraries and frameworks.

00:02:59,160 --> 00:03:04,010


00:03:04,010 --> 00:03:06,140
One of the big challenges that we've encountered

00:03:06,140 --> 00:03:07,830
is managing code size.

00:03:07,830 --> 00:03:12,390
So having a single page app with over 25 megabytes of code,

00:03:12,390 --> 00:03:14,890
obviously, that's really too much for a user

00:03:14,890 --> 00:03:17,220
to download in a single request.

00:03:17,220 --> 00:03:19,150
Our users would really not be happy with us

00:03:19,150 --> 00:03:21,149
if we pushed all of that to them, even if it was

00:03:21,149 --> 00:03:22,580
[INAUDIBLE].

00:03:22,580 --> 00:03:25,280
That certainly affects download time for the initial page load.

00:03:25,280 --> 00:03:28,520
But even if it were cached, parsing that much JavaScript

00:03:28,520 --> 00:03:30,920
would really not be realistic.

00:03:30,920 --> 00:03:33,390
Also, not all of that code is used for a single view.

00:03:33,390 --> 00:03:36,730
We might have a user visit the App Engine page, at which point

00:03:36,730 --> 00:03:39,570
they don't need to see all the code for, say, Compute Engine

00:03:39,570 --> 00:03:40,300
and Logging.

00:03:40,300 --> 00:03:41,820
And some of our users may only be

00:03:41,820 --> 00:03:43,830
using a couple of Google Cloud features,

00:03:43,830 --> 00:03:45,650
so they might never need some of that code.

00:03:45,650 --> 00:03:49,209


00:03:49,209 --> 00:03:51,250
The way we've handled this within our application

00:03:51,250 --> 00:03:53,410
is to use lazy loading.

00:03:53,410 --> 00:03:55,610
So we first divide code into modules.

00:03:55,610 --> 00:03:57,640
That's done using a Google-specific packaging

00:03:57,640 --> 00:03:58,870
system.

00:03:58,870 --> 00:04:02,090
That system works with our dependency management system

00:04:02,090 --> 00:04:03,960
and even allows us to ship different code

00:04:03,960 --> 00:04:04,970
to different users.

00:04:04,970 --> 00:04:07,680
We might ship some things only to internal users first just

00:04:07,680 --> 00:04:09,150
to try them out.

00:04:09,150 --> 00:04:11,052
But you could use any packaging system

00:04:11,052 --> 00:04:12,510
that you wanted to accomplish this.

00:04:12,510 --> 00:04:14,680


00:04:14,680 --> 00:04:18,140
Next, what we do is register a placeholder route

00:04:18,140 --> 00:04:19,516
for each lazy loaded path.

00:04:19,516 --> 00:04:21,140
And I'll give you some examples of what

00:04:21,140 --> 00:04:24,220
these look like in a minute.

00:04:24,220 --> 00:04:27,250
We also have a new injector that's registered.

00:04:27,250 --> 00:04:28,840
And what that does is it forwards

00:04:28,840 --> 00:04:31,109
white-listed, lazy loaded changes

00:04:31,109 --> 00:04:32,150
to the original injector.

00:04:32,150 --> 00:04:34,450
So we have a white list of providers

00:04:34,450 --> 00:04:38,150
that we think it's safe to allow later configuration for.

00:04:38,150 --> 00:04:42,170
And, of course, the route provider is one of those.

00:04:42,170 --> 00:04:44,260
When the lazy loaded module is loaded,

00:04:44,260 --> 00:04:46,660
it registers its real routes, after which

00:04:46,660 --> 00:04:49,060
we delete the placeholder ones and call route.reload.

00:04:49,060 --> 00:04:52,760


00:04:52,760 --> 00:04:54,936
So if we can imagine that we have a sample lunch

00:04:54,936 --> 00:04:56,560
application-- yes, I wrote these slides

00:04:56,560 --> 00:05:01,680
when I was hungry-- we might have a taco subpath and a pizza

00:05:01,680 --> 00:05:04,170
subpath, both of which are separate lazy loaded modules.

00:05:04,170 --> 00:05:06,530
So we could view those as separate features.

00:05:06,530 --> 00:05:11,080
So when we start, these are just registered with wild card paths

00:05:11,080 --> 00:05:12,330
that just point to the module.

00:05:12,330 --> 00:05:14,540
We don't actually know what any of the sub URLs are.

00:05:14,540 --> 00:05:16,373
We don't know what any of the templates are.

00:05:16,373 --> 00:05:17,140
We don't care.

00:05:17,140 --> 00:05:19,390
And then we publish all of those routes as a constant.

00:05:19,390 --> 00:05:22,500


00:05:22,500 --> 00:05:25,480
An insider lazy loaded module, the route provider

00:05:25,480 --> 00:05:28,410
sets up all the routes just like it normally would.

00:05:28,410 --> 00:05:30,340
The key piece is that this module is not

00:05:30,340 --> 00:05:32,630
in the dependency list of the main app.

00:05:32,630 --> 00:05:34,120
So when the main app loads up, it

00:05:34,120 --> 00:05:36,270
doesn't know anything about this module.

00:05:36,270 --> 00:05:38,200
And there's nothing that's going to break because those pieces

00:05:38,200 --> 00:05:38,741
aren't there.

00:05:38,741 --> 00:05:42,740


00:05:42,740 --> 00:05:46,050
We have two pieces of setup code in our core application

00:05:46,050 --> 00:05:47,940
that get all this wired together.

00:05:47,940 --> 00:05:52,640
So in a run block for each module ID to path mapping,

00:05:52,640 --> 00:05:57,910
we go through and register this loadJS and reload method

00:05:57,910 --> 00:05:59,690
on the route provider.

00:05:59,690 --> 00:06:01,710
So what this does is it basically says,

00:06:01,710 --> 00:06:03,800
OK, we're going to load up the JavaScript code,

00:06:03,800 --> 00:06:07,764
and then, once it's ready, we're going to call reload on it.

00:06:07,764 --> 00:06:10,430
And then, we also make sure that our cleanup code is registered.

00:06:10,430 --> 00:06:14,510
So this is just taking a look at the route resolve,

00:06:14,510 --> 00:06:16,430
looking to see if that method is still there.

00:06:16,430 --> 00:06:18,263
If it's not there, we must have already done

00:06:18,263 --> 00:06:19,780
all the lazy loading.

00:06:19,780 --> 00:06:21,159
Just ignore it and move on.

00:06:21,159 --> 00:06:22,700
If it's still there, do some cleanup.

00:06:22,700 --> 00:06:25,890


00:06:25,890 --> 00:06:28,440
So if I were a user accessing the main lunch

00:06:28,440 --> 00:06:31,960
page for the first time, this is not a lazy loaded route.

00:06:31,960 --> 00:06:33,290
This just works as normal.

00:06:33,290 --> 00:06:35,310
I visit the URL.

00:06:35,310 --> 00:06:37,170
I get some initial code downloaded.

00:06:37,170 --> 00:06:38,270
This includes Angular.

00:06:38,270 --> 00:06:41,340
It includes our base application code.

00:06:41,340 --> 00:06:43,960
And that sets up all the route mappings for me.

00:06:43,960 --> 00:06:47,320
So we have the regular lunch thing

00:06:47,320 --> 00:06:48,840
that's already registered.

00:06:48,840 --> 00:06:52,830
And then, we maybe have our custom lazy loaded mappings.

00:06:52,830 --> 00:06:55,540


00:06:55,540 --> 00:06:59,424
Now, once I go ahead and move to the lunch pizza URL,

00:06:59,424 --> 00:07:01,090
we're going to have to start downloading

00:07:01,090 --> 00:07:03,810
that lazy loaded code.

00:07:03,810 --> 00:07:06,610
So the new JavaScript module is loaded.

00:07:06,610 --> 00:07:08,660
And then, at that point, as it loads,

00:07:08,660 --> 00:07:13,240
it replaces those wild card mappings with the real ones.

00:07:13,240 --> 00:07:15,990
And at this point, route.reload is called.

00:07:15,990 --> 00:07:18,700
Angular sees that new mapping and will show me

00:07:18,700 --> 00:07:21,230
the content that I am supposed to be seeing on that page.

00:07:21,230 --> 00:07:24,744


00:07:24,744 --> 00:07:26,660
Another thing that I think is really important

00:07:26,660 --> 00:07:28,180
when working with large applications

00:07:28,180 --> 00:07:30,620
is having a plan for sharing code.

00:07:30,620 --> 00:07:32,990
And there are a lot of good reasons to do that.

00:07:32,990 --> 00:07:34,740
First of all, this keeps code size down.

00:07:34,740 --> 00:07:37,740
So you're not going to have as much code to begin with.

00:07:37,740 --> 00:07:39,410
It also promotes product consistency.

00:07:39,410 --> 00:07:41,339
So when I move across the application,

00:07:41,339 --> 00:07:42,880
I want it to feel like something that

00:07:42,880 --> 00:07:45,660
was developed by single entity interactions,

00:07:45,660 --> 00:07:49,210
or similar things work the same on every page.

00:07:49,210 --> 00:07:51,200
It also gives us an abstraction layer that

00:07:51,200 --> 00:07:53,040
helps us iterate in the future.

00:07:53,040 --> 00:07:54,880
So if we want to make some sort of change,

00:07:54,880 --> 00:07:56,630
we can do it across the entire application

00:07:56,630 --> 00:07:58,820
in a coordinated way.

00:07:58,820 --> 00:08:01,120
It increases feature developer velocity.

00:08:01,120 --> 00:08:02,592
So if I'm a contributing developer,

00:08:02,592 --> 00:08:04,800
I don't have to start from scratch for every feature.

00:08:04,800 --> 00:08:07,430
I can use a number of services and directives

00:08:07,430 --> 00:08:11,500
that our team has already been provided.

00:08:11,500 --> 00:08:12,890
It also improves quality.

00:08:12,890 --> 00:08:14,810
As you have more and more features

00:08:14,810 --> 00:08:16,920
using all of these different services,

00:08:16,920 --> 00:08:18,280
you get a lot more testing.

00:08:18,280 --> 00:08:20,010
And if you fix a bug, you can fix it

00:08:20,010 --> 00:08:21,727
across the entire product.

00:08:21,727 --> 00:08:24,060
And I think code sharing is a place where Angular really

00:08:24,060 --> 00:08:25,910
shines.

00:08:25,910 --> 00:08:27,760
Angular directives are great match

00:08:27,760 --> 00:08:29,480
for building UI components.

00:08:29,480 --> 00:08:31,180
So, in our application, we have things

00:08:31,180 --> 00:08:33,690
like icons and dialogues.

00:08:33,690 --> 00:08:37,770
We also provide directives for form components, tabs,

00:08:37,770 --> 00:08:41,260
table sorting, and a number of other UI widgets.

00:08:41,260 --> 00:08:43,710
We even have some non-visual directives.

00:08:43,710 --> 00:08:46,660
So, for example, you could do something like track visits

00:08:46,660 --> 00:08:48,700
to outgoing links using a directive.

00:08:48,700 --> 00:08:52,580


00:08:52,580 --> 00:08:55,780
Services are also a great place for sharing business logic.

00:08:55,780 --> 00:09:00,620
We have services for things like URL management, caching, Google

00:09:00,620 --> 00:09:02,675
Analytics tracking, and error handling.

00:09:02,675 --> 00:09:08,152


00:09:08,152 --> 00:09:10,610
One thing we've occasionally found challenging with Angular

00:09:10,610 --> 00:09:14,100
is avoiding conflicts as we're building all of this code.

00:09:14,100 --> 00:09:17,080
As I mentioned, we have a number of different distributed teams,

00:09:17,080 --> 00:09:18,750
and it's really important to make sure

00:09:18,750 --> 00:09:22,800
that we don't accidentally reuse the same names or namespaces.

00:09:22,800 --> 00:09:25,770
Angular has a lot of world-writable global state.

00:09:25,770 --> 00:09:28,466
So particularly, things like the root scope, any feature

00:09:28,466 --> 00:09:30,090
can write to and that would potentially

00:09:30,090 --> 00:09:31,940
affect other features.

00:09:31,940 --> 00:09:34,392
The module service, directive registrations,

00:09:34,392 --> 00:09:36,100
are all things that could be accidentally

00:09:36,100 --> 00:09:38,930
overwritten by another feature as well.

00:09:38,930 --> 00:09:42,490
So we have a number of different things that help combat this.

00:09:42,490 --> 00:09:44,700
One of the tools that we use is visibility.

00:09:44,700 --> 00:09:48,010
So our build system actually allows for package level

00:09:48,010 --> 00:09:49,180
visibility.

00:09:49,180 --> 00:09:51,860
And we use this to ensure that features

00:09:51,860 --> 00:09:53,460
can't use each other's code.

00:09:53,460 --> 00:09:55,510
They can only use code that has specifically been

00:09:55,510 --> 00:09:57,380
added to our common directory.

00:09:57,380 --> 00:10:00,834
So in this example, the SQL and logging features

00:10:00,834 --> 00:10:02,250
couldn't use code from each other.

00:10:02,250 --> 00:10:04,370
They could only use common.

00:10:04,370 --> 00:10:07,230
And this is enforced at the compiler level.

00:10:07,230 --> 00:10:11,100
This helps ensure that code that is written by a feature that

00:10:11,100 --> 00:10:12,610
might not be actually be intended

00:10:12,610 --> 00:10:16,430
to be used as an API doesn't accidentally get used that way.

00:10:16,430 --> 00:10:19,230
And it also helps us promote code into common.

00:10:19,230 --> 00:10:21,487
So if the logging package decided

00:10:21,487 --> 00:10:23,070
they wanted to use something from SQL,

00:10:23,070 --> 00:10:25,110
maybe they could help get it into common.

00:10:25,110 --> 00:10:26,860
And then, we would know that it was there,

00:10:26,860 --> 00:10:28,943
and other features could start using that as well.

00:10:28,943 --> 00:10:32,570


00:10:32,570 --> 00:10:35,430
We also support visibility at a little more fine grained level.

00:10:35,430 --> 00:10:37,660
This is something that's provided by Google Closure

00:10:37,660 --> 00:10:39,860
and is also enforced by the compiler.

00:10:39,860 --> 00:10:44,720
But we can mark particular methods and properties

00:10:44,720 --> 00:10:46,520
as either public or private.

00:10:46,520 --> 00:10:49,000
And this is really great for building common APIs,

00:10:49,000 --> 00:10:53,950
because we can ensure that a particular property is not

00:10:53,950 --> 00:10:56,130
writable by the end user of that API.

00:10:56,130 --> 00:11:00,060


00:11:00,060 --> 00:11:02,070
I'm sure many of you have seen recommendations

00:11:02,070 --> 00:11:04,920
to pick a unique name space for your project

00:11:04,920 --> 00:11:07,400
when you're building directives and services.

00:11:07,400 --> 00:11:10,000
And that helps prevent conflicts with Angular,

00:11:10,000 --> 00:11:12,740
or with some other library that you might be using.

00:11:12,740 --> 00:11:17,670
We've extended that concept and asked every single feature team

00:11:17,670 --> 00:11:21,314
within our product to pick a globally unique namespace.

00:11:21,314 --> 00:11:22,730
That's really great for debugging,

00:11:22,730 --> 00:11:24,354
because you can just look at some code,

00:11:24,354 --> 00:11:26,900
and just from the namespace, be able to tell exactly

00:11:26,900 --> 00:11:28,209
where that code is coming from.

00:11:28,209 --> 00:11:30,000
And then, we also have a separate namespace

00:11:30,000 --> 00:11:30,670
for common code.

00:11:30,670 --> 00:11:32,510
So it's really easy to identify what

00:11:32,510 --> 00:11:33,720
code is coming from common.

00:11:33,720 --> 00:11:38,150


00:11:38,150 --> 00:11:41,360
I mentioned that root scope is world writable.

00:11:41,360 --> 00:11:43,520
We typically discourage people from doing that,

00:11:43,520 --> 00:11:45,510
just to prevent confusion.

00:11:45,510 --> 00:11:48,000
Many of our directives also use isolate scope.

00:11:48,000 --> 00:11:51,900
And this is because if we have some sort of scope property

00:11:51,900 --> 00:11:54,691
that's public, there's some chance that it might eventually

00:11:54,691 --> 00:11:56,940
conflict with something that's used by a feature teams

00:11:56,940 --> 00:11:57,440
controller.

00:11:57,440 --> 00:12:03,480


00:12:03,480 --> 00:12:07,000
As we get user feedback and do user research,

00:12:07,000 --> 00:12:09,330
we really want to be able to make iterative updates

00:12:09,330 --> 00:12:10,730
in our product, and we want to be

00:12:10,730 --> 00:12:13,540
able to make those in a coordinated fashion sometimes.

00:12:13,540 --> 00:12:15,300
So sometimes, we have a global change

00:12:15,300 --> 00:12:17,180
that we feel like would be jarring if we made

00:12:17,180 --> 00:12:18,690
it only one page at a time.

00:12:18,690 --> 00:12:21,590
We really want our application to be consistent.

00:12:21,590 --> 00:12:24,000
So here's an example of a global change

00:12:24,000 --> 00:12:25,430
that we actually made last year.

00:12:25,430 --> 00:12:29,220
Our form fields used to be-- our labels for our form fields used

00:12:29,220 --> 00:12:32,100
to be next to the input box, and we moved them

00:12:32,100 --> 00:12:33,230
above the input box.

00:12:33,230 --> 00:12:35,520
So it went from this to something

00:12:35,520 --> 00:12:38,100
that looks more like this.

00:12:38,100 --> 00:12:40,600
The way that we typically make these global changes

00:12:40,600 --> 00:12:43,060
is to use a flag system.

00:12:43,060 --> 00:12:45,770
So our backend publishes a Boolean value

00:12:45,770 --> 00:12:49,180
indicating whether or not some new feature is enabled.

00:12:49,180 --> 00:12:51,880
And then, we have a flag service that

00:12:51,880 --> 00:12:55,200
can inject that into things like directives and controllers.

00:12:55,200 --> 00:12:57,650
So in this example, for that sort of form

00:12:57,650 --> 00:13:00,630
change-- if we had a form directive, which we do--

00:13:00,630 --> 00:13:03,440
we can potentially pick a different template based on

00:13:03,440 --> 00:13:04,940
whether that flag is enabled or not.

00:13:04,940 --> 00:13:07,065
And then, even within the linker compile functions,

00:13:07,065 --> 00:13:10,200
we can also make behavioral decisions based on that value.

00:13:10,200 --> 00:13:13,020


00:13:13,020 --> 00:13:14,840
This is another example of a global change

00:13:14,840 --> 00:13:15,960
that we made at one point.

00:13:15,960 --> 00:13:19,160
We decided to change our URL format

00:13:19,160 --> 00:13:21,160
to be something that was a little more friendly.

00:13:21,160 --> 00:13:23,780
And because we had a global URL service

00:13:23,780 --> 00:13:27,050
that we used to build all URLs, we

00:13:27,050 --> 00:13:30,619
were able to make this change at one single change

00:13:30,619 --> 00:13:31,410
across the product.

00:13:31,410 --> 00:13:35,850


00:13:35,850 --> 00:13:37,970
In some situations, it might make more sense

00:13:37,970 --> 00:13:41,640
to make changes on a page by page basis.

00:13:41,640 --> 00:13:44,450
When we have these sort of changes, typically what we do

00:13:44,450 --> 00:13:46,280
is we take the original directive

00:13:46,280 --> 00:13:49,540
and register a second copy of it with the beta suffix,

00:13:49,540 --> 00:13:51,950
and then move pages over one at a time.

00:13:51,950 --> 00:13:53,590
So we could clone that directive,

00:13:53,590 --> 00:13:56,490
or just re-register it with a different parameter,

00:13:56,490 --> 00:13:59,140
and then change each page individually,

00:13:59,140 --> 00:14:01,620
make sure each page looks great before we ship it.

00:14:01,620 --> 00:14:04,060
And then, once everything is migrated over,

00:14:04,060 --> 00:14:06,477
we can rename that new directive back to the old name

00:14:06,477 --> 00:14:08,310
and delete the old code and do some cleanup.

00:14:08,310 --> 00:14:15,310


00:14:15,310 --> 00:14:17,790
Upgrading Angular is also another global change

00:14:17,790 --> 00:14:19,650
that you might need to make at some point.

00:14:19,650 --> 00:14:22,580
We recently migrated Angular 1.3,

00:14:22,580 --> 00:14:25,430
and we're really looking forward to adopting 1.4.

00:14:25,430 --> 00:14:28,180
We relied very heavily on unit and integration tests

00:14:28,180 --> 00:14:28,680
to do that.

00:14:28,680 --> 00:14:31,630
So we ran through entire tests, fixed anything that

00:14:31,630 --> 00:14:35,230
didn't look right, and then did some additional manual testing.

00:14:35,230 --> 00:14:38,740
We're working with the Angular team on 2.0 migration strategy.

00:14:38,740 --> 00:14:41,190
I believe there's a talk this afternoon on that.

00:14:41,190 --> 00:14:43,800
So we're really looking forward to that change, as well.

00:14:43,800 --> 00:14:46,720


00:14:46,720 --> 00:14:48,220
I wanted to mention that we actually

00:14:48,220 --> 00:14:50,280
didn't start out on Angular.

00:14:50,280 --> 00:14:53,430
And we actually adopted Angular after our project was already

00:14:53,430 --> 00:14:54,440
in production.

00:14:54,440 --> 00:14:58,370
So you can still switch, even if you're not using it yet.

00:14:58,370 --> 00:15:01,070
We adopted a page by page migration

00:15:01,070 --> 00:15:02,759
and kind of worked from the outside in.

00:15:02,759 --> 00:15:05,300
And we did this because we're really attracted by the smaller

00:15:05,300 --> 00:15:08,220
code size and felt like we could achieve a higher developer

00:15:08,220 --> 00:15:08,720
velocity.

00:15:08,720 --> 00:15:12,210


00:15:12,210 --> 00:15:16,160
So as a first step, we applied the ng app to the entire page,

00:15:16,160 --> 00:15:19,100
and added some navigation directives into the page,

00:15:19,100 --> 00:15:22,950
and then made the main content view port be this ng view.

00:15:22,950 --> 00:15:25,710
And we migrated pages on a page by page basis.

00:15:25,710 --> 00:15:28,510
Anything that wasn't actively mapped in the route config

00:15:28,510 --> 00:15:30,440
just fell through to our custom code

00:15:30,440 --> 00:15:35,760
that continued to handle the URL mappings just as it used to.

00:15:35,760 --> 00:15:39,720
Even within those Angular pages that we had-- even within pages

00:15:39,720 --> 00:15:41,720
that we had migrated to Angular, we kind of also

00:15:41,720 --> 00:15:43,530
worked from the outside in.

00:15:43,530 --> 00:15:46,074
So it's possible to wrap some of your existing code

00:15:46,074 --> 00:15:48,490
so that you don't actually have to migrate everything over

00:15:48,490 --> 00:15:49,490
at once.

00:15:49,490 --> 00:15:53,650
So you can use directives to wrap some of your existing UI

00:15:53,650 --> 00:15:55,080
widgets.

00:15:55,080 --> 00:15:57,840
You can also use services to encapsulate existing business

00:15:57,840 --> 00:15:58,510
object.

00:15:58,510 --> 00:16:00,780
And that tends to work particularly well if you add

00:16:00,780 --> 00:16:03,494
in things like promise support.

00:16:03,494 --> 00:16:04,910
If you want to, you can eventually

00:16:04,910 --> 00:16:07,000
convert this code over.

00:16:07,000 --> 00:16:09,900
But you can actually run for a very long time with code that's

00:16:09,900 --> 00:16:11,440
just wrapped in a sensible way.

00:16:11,440 --> 00:16:15,080


00:16:15,080 --> 00:16:16,740
As we make global changes like this,

00:16:16,740 --> 00:16:19,492
it's really important to ensure that we don't accidentally

00:16:19,492 --> 00:16:21,450
break anything and that we continue to maintain

00:16:21,450 --> 00:16:23,270
our product quality.

00:16:23,270 --> 00:16:25,914
All code is reviewed at Google, actively,

00:16:25,914 --> 00:16:27,580
by somebody else before it's checked in.

00:16:27,580 --> 00:16:31,580
But it's still much better to prefer automated checks

00:16:31,580 --> 00:16:34,450
whenever we can.

00:16:34,450 --> 00:16:36,920
So some of the different kind of checks that we have are,

00:16:36,920 --> 00:16:38,290
first, JS compilations.

00:16:38,290 --> 00:16:41,930
So that helps catch things like compiler errors and typos.

00:16:41,930 --> 00:16:44,750
It makes sure that arguments actually match.

00:16:44,750 --> 00:16:46,322
We currently use Closure for this,

00:16:46,322 --> 00:16:48,530
but you could certainly use something like TypeScript

00:16:48,530 --> 00:16:51,380
instead.

00:16:51,380 --> 00:16:52,970
We also have a number of checks that

00:16:52,970 --> 00:16:55,500
are run before code is submitted,

00:16:55,500 --> 00:16:57,430
and these are great for enforcing

00:16:57,430 --> 00:16:59,150
project best practices.

00:16:59,150 --> 00:17:01,210
So they might include things like enforcing

00:17:01,210 --> 00:17:04,400
usage of custom filters that we prefer,

00:17:04,400 --> 00:17:07,250
preventing people from accessing the root scope.

00:17:07,250 --> 00:17:09,332
It can also help make sure that things

00:17:09,332 --> 00:17:11,540
like debugging statements aren't accidentally checked

00:17:11,540 --> 00:17:12,450
into the code base.

00:17:12,450 --> 00:17:14,180
And we can enforce our Lint roles.

00:17:14,180 --> 00:17:17,220


00:17:17,220 --> 00:17:20,470
We also use automated testing to verify our changes.

00:17:20,470 --> 00:17:22,980
For unit tests, we use Jasmine and Karma and those are

00:17:22,980 --> 00:17:24,609
actually run before submission.

00:17:24,609 --> 00:17:26,480
So if there's a test that's broken,

00:17:26,480 --> 00:17:28,850
the code can't be checked in.

00:17:28,850 --> 00:17:31,580
We also have a number of Protractor-based integration

00:17:31,580 --> 00:17:33,290
tests, and we run those after check-in.

00:17:33,290 --> 00:17:35,623
So once code is checked in, those run in the background.

00:17:35,623 --> 00:17:38,820
And then, if something breaks, it's flagged.

00:17:38,820 --> 00:17:41,900
We found it really helpful to have shared helpers for some

00:17:41,900 --> 00:17:44,110
of our common UI components.

00:17:44,110 --> 00:17:46,440
This is particularly on the Protractor side.

00:17:46,440 --> 00:17:50,100
If you have some widget that has a really complex DOM structure,

00:17:50,100 --> 00:17:52,870
it's helpful to publish those selectors and maybe some helper

00:17:52,870 --> 00:17:54,950
methods so that your feature developers can write

00:17:54,950 --> 00:17:57,020
integration tests more quickly.

00:17:57,020 --> 00:17:58,940
That also gives you nice abstraction layer.

00:17:58,940 --> 00:18:00,690
So if you change that widget, you

00:18:00,690 --> 00:18:02,900
can also change the test helper.

00:18:02,900 --> 00:18:06,180


00:18:06,180 --> 00:18:09,050
We've occasionally run into more subtle failures

00:18:09,050 --> 00:18:11,930
that it's kind of difficult to catch

00:18:11,930 --> 00:18:14,820
with some of those automated integration test strategies.

00:18:14,820 --> 00:18:16,740
So the thing that we find most troublesome

00:18:16,740 --> 00:18:18,800
is sometimes missing directives.

00:18:18,800 --> 00:18:21,750
So, in this example, we have an attribute-based directive that

00:18:21,750 --> 00:18:23,757
applies a custom CSS class.

00:18:23,757 --> 00:18:25,340
And over on the left hand side, that's

00:18:25,340 --> 00:18:27,670
what the directive is supposed to look like.

00:18:27,670 --> 00:18:30,550
If the directive just isn't applied-- maybe somebody forgot

00:18:30,550 --> 00:18:32,940
to include it in the dependency mapping--

00:18:32,940 --> 00:18:36,480
you just get that same element without the CSS class.

00:18:36,480 --> 00:18:38,780
So if the Protractor test was looking for just an input

00:18:38,780 --> 00:18:42,470
element, the test would still pass.

00:18:42,470 --> 00:18:45,780
Similarly, this is a element-based template

00:18:45,780 --> 00:18:49,890
directive that adds a little icon and some wrapper classes.

00:18:49,890 --> 00:18:52,140
And HTML allows arbitrary elements.

00:18:52,140 --> 00:18:54,130
So if this directive wasn't mapped,

00:18:54,130 --> 00:18:55,720
there's no error on the page.

00:18:55,720 --> 00:18:58,470
The tag is just included in the HTML as is,

00:18:58,470 --> 00:18:59,850
and it winds up just being taxed.

00:18:59,850 --> 00:19:02,780


00:19:02,780 --> 00:19:05,360
So the way that we're currently exploring

00:19:05,360 --> 00:19:07,660
is to use screenshot comparison.

00:19:07,660 --> 00:19:09,740
So, in this view, I have a test page

00:19:09,740 --> 00:19:12,570
that uses a couple different flavors of this little message

00:19:12,570 --> 00:19:13,300
widget.

00:19:13,300 --> 00:19:16,160
And on the top is what that page is supposed to look like.

00:19:16,160 --> 00:19:19,200
And then, if I remove the dependency mapping,

00:19:19,200 --> 00:19:22,140
you get that text on the bottom.

00:19:22,140 --> 00:19:24,490
And then, our screenshot comparison tool

00:19:24,490 --> 00:19:26,760
can actually show me a visual dif

00:19:26,760 --> 00:19:30,142
of where all the pixels don't match between those two views.

00:19:30,142 --> 00:19:32,350
We're using an internal framework for this right now,

00:19:32,350 --> 00:19:34,760
but there are some publicly available ones, as well.

00:19:34,760 --> 00:19:37,680


00:19:37,680 --> 00:19:40,820
So my recommendations for working with large Angular

00:19:40,820 --> 00:19:44,270
applications would first be to create shared abstraction

00:19:44,270 --> 00:19:44,800
layers.

00:19:44,800 --> 00:19:46,341
Those are really important for things

00:19:46,341 --> 00:19:49,270
like consistency, and developer velocity,

00:19:49,270 --> 00:19:51,750
and the ability to iterate.

00:19:51,750 --> 00:19:53,450
Watch your JavaScript download size,

00:19:53,450 --> 00:19:55,920
and maybe adopt some sort of lazy loading strategy

00:19:55,920 --> 00:19:57,240
if you need to.

00:19:57,240 --> 00:19:59,550
And then, finally, to ensure thorough test coverage.

00:19:59,550 --> 00:20:01,500
If you want it to work, you should test it.

00:20:01,500 --> 00:20:02,866
Thank you.

00:20:02,866 --> 00:20:06,730
[APPLAUSE]

00:20:06,730 --> 00:20:10,720


00:20:10,720 --> 00:20:12,110
MODERATOR: Thanks, Jen.


YouTube URL: https://www.youtube.com/watch?v=cVTN8msr5DE


