Title: Angular + React = Speed Dave Smith
Publication date: 2015-03-08
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:00,500


00:00:00,500 --> 00:00:02,940
[APPLAUSE]

00:00:02,940 --> 00:00:04,410


00:00:04,410 --> 00:00:05,770
DAVE SMITH: Hey, everybody.

00:00:05,770 --> 00:00:07,192
How we doing?

00:00:07,192 --> 00:00:08,074
[CHEERS]

00:00:08,074 --> 00:00:08,956
Good?

00:00:08,956 --> 00:00:11,824
Well, today I wanted to talk-- oh, I really

00:00:11,824 --> 00:00:12,990
should have turned this off.

00:00:12,990 --> 00:00:13,489
Hold on.

00:00:13,489 --> 00:00:15,030
Oh, I've got to take this.

00:00:15,030 --> 00:00:16,470
Sorry, hold on.

00:00:16,470 --> 00:00:19,130
Hey, Grandma.

00:00:19,130 --> 00:00:19,820
Yeah, yeah.

00:00:19,820 --> 00:00:21,770
Thanks for calling back.

00:00:21,770 --> 00:00:22,460
Yeah.

00:00:22,460 --> 00:00:24,341
So I just wanted to call and tell you,

00:00:24,341 --> 00:00:25,840
remember how last year I called you,

00:00:25,840 --> 00:00:27,410
and I was all happy because I didn't

00:00:27,410 --> 00:00:29,187
have to use jQuery anymore?

00:00:29,187 --> 00:00:30,560
[LAUGHTER]

00:00:30,560 --> 00:00:31,350
Yeah?

00:00:31,350 --> 00:00:34,250
Because this Angular thing has been so awesome?

00:00:34,250 --> 00:00:36,940
Well, now I get to use React in my Angular.

00:00:36,940 --> 00:00:38,960
I thought maybe you'd like to know about that.

00:00:38,960 --> 00:00:39,520
OK.

00:00:39,520 --> 00:00:40,020
Yeah.

00:00:40,020 --> 00:00:42,075
I-- yeah.

00:00:42,075 --> 00:00:43,470
(WHISPERING) I love you too.

00:00:43,470 --> 00:00:45,330
[LAUGHTER AND APPLAUSE]

00:00:45,330 --> 00:00:47,190


00:00:47,190 --> 00:00:49,380
So I usually like to start off with a joke.

00:00:49,380 --> 00:00:50,229
Today, I'll do two.

00:00:50,229 --> 00:00:52,020
I was going to tell a really hilarious one,

00:00:52,020 --> 00:00:56,796
but I didn't really know how you would react.

00:00:56,796 --> 00:00:58,170
Before we talk about performance,

00:00:58,170 --> 00:01:02,020
it's important for us talk about what is our job as engineers.

00:01:02,020 --> 00:01:05,770
Engineering, I believe, is when that

00:01:05,770 --> 00:01:09,140
which is theoretically possible through science

00:01:09,140 --> 00:01:14,254
reaches a compromise with that which is economically feasible.

00:01:14,254 --> 00:01:16,170
And this is where we find ourselves constantly

00:01:16,170 --> 00:01:18,700
tugging between the trade-offs of what's possible

00:01:18,700 --> 00:01:22,590
and what we can afford to do.

00:01:22,590 --> 00:01:24,890
Performance is really hard.

00:01:24,890 --> 00:01:26,900
It's a hard problem.

00:01:26,900 --> 00:01:31,389
In fact, this was a quote that I recently

00:01:31,389 --> 00:01:33,180
found-- I don't think you're measuring what

00:01:33,180 --> 00:01:34,440
you think you're measuring.

00:01:34,440 --> 00:01:39,980
This is actually Misko to me about this talk.

00:01:39,980 --> 00:01:40,480
Twice.

00:01:40,480 --> 00:01:43,670


00:01:43,670 --> 00:01:48,050
Here's a question I get a lot-- is React faster than Angular?

00:01:48,050 --> 00:01:49,620
Well, the answer is very simple--

00:01:49,620 --> 00:01:50,920
that's a stupid question.

00:01:50,920 --> 00:01:52,720
[LAUGHTER]

00:01:52,720 --> 00:01:53,620


00:01:53,620 --> 00:01:56,810
I'm not going to compare apples and oranges today.

00:01:56,810 --> 00:02:01,060
Instead, I am going to build a whole new kind of super powered

00:02:01,060 --> 00:02:01,760
Frankenfruit.

00:02:01,760 --> 00:02:03,560
[LAUGHTER]

00:02:03,560 --> 00:02:04,910


00:02:04,910 --> 00:02:07,980
But first, I feel like I owe you an introduction to React.

00:02:07,980 --> 00:02:09,570
Here it is in 30 seconds.

00:02:09,570 --> 00:02:14,070
React is a web view framework in JavaScript

00:02:14,070 --> 00:02:16,770
that's designed to take your application state

00:02:16,770 --> 00:02:19,720
and allow you to write code that takes that status input

00:02:19,720 --> 00:02:23,180
and returns Virtual DOM, which is really just a set of plain

00:02:23,180 --> 00:02:26,190
old JavaScript objects, which is then passed into React's

00:02:26,190 --> 00:02:29,560
Reconciling and Rendering Engine,

00:02:29,560 --> 00:02:33,245
and then generates from that a set of optimized DOM operations

00:02:33,245 --> 00:02:35,930
that need to be performed on browsers to make it real.

00:02:35,930 --> 00:02:37,560
A little more detail.

00:02:37,560 --> 00:02:39,170
The performance premise of React is

00:02:39,170 --> 00:02:41,680
that the DOM is dangerously unperformant for engineers

00:02:41,680 --> 00:02:42,850
to work with directly.

00:02:42,850 --> 00:02:44,530
So instead, they give you a virtual DOM

00:02:44,530 --> 00:02:47,030
to work on, which is an intermediate representation

00:02:47,030 --> 00:02:47,830
of DOM.

00:02:47,830 --> 00:02:50,990
When your application state changes,

00:02:50,990 --> 00:02:53,310
you return new virtual DOM, React

00:02:53,310 --> 00:02:55,385
diffs it against the existing virtual DOM

00:02:55,385 --> 00:02:57,010
and generates performance-optimized DOM

00:02:57,010 --> 00:02:59,760
operations that will then go to the browser.

00:02:59,760 --> 00:03:01,990
It can do things like batching reads and writes,

00:03:01,990 --> 00:03:04,080
which results in fewer reflows, and it can even

00:03:04,080 --> 00:03:06,470
do cool things like generate big blocks of inner HTML

00:03:06,470 --> 00:03:08,200
for maximum speed.

00:03:08,200 --> 00:03:10,800
Here's some links I'd like you to check out later about React.

00:03:10,800 --> 00:03:12,860
So now you know a little bit about React--

00:03:12,860 --> 00:03:14,260
[LAUGHTER]

00:03:14,260 --> 00:03:16,010
There's an obvious conclusion.

00:03:16,010 --> 00:03:17,180
React everything!

00:03:17,180 --> 00:03:18,370
Right?

00:03:18,370 --> 00:03:21,107
Well, the unicorn grumpy cat says that's really not

00:03:21,107 --> 00:03:21,690
that possible.

00:03:21,690 --> 00:03:24,312
So we're going to just React some of the things today.

00:03:24,312 --> 00:03:26,520
But first, I want to tell you a story with two parts.

00:03:26,520 --> 00:03:29,870
The first part is tragedy, and the second part is glory.

00:03:29,870 --> 00:03:31,630
We'll start with the tragedy.

00:03:31,630 --> 00:03:34,030
This is a piece of UI that we developed at my company

00:03:34,030 --> 00:03:35,250
at Higher View.

00:03:35,250 --> 00:03:35,920
It's a table.

00:03:35,920 --> 00:03:37,130
It's written with Angular.

00:03:37,130 --> 00:03:38,497
It's NG repeated.

00:03:38,497 --> 00:03:40,830
Our product managers came to us, as product managers are

00:03:40,830 --> 00:03:42,580
wont to do, and they said, please

00:03:42,580 --> 00:03:44,030
add a new column to this table.

00:03:44,030 --> 00:03:46,020
It's that one.

00:03:46,020 --> 00:03:47,310
And I thought, oh boy.

00:03:47,310 --> 00:03:48,909
We already have an NG repeat table,

00:03:48,909 --> 00:03:50,700
and now you want us to do an NG repeat list

00:03:50,700 --> 00:03:52,585
inside of our NG repeat table.

00:03:52,585 --> 00:03:54,460
So I did a little bit of advanced performance

00:03:54,460 --> 00:03:56,490
mathematics, and I came up with the following.

00:03:56,490 --> 00:04:00,960
If I have a slow NG repeat table and I add to it a nested NG

00:04:00,960 --> 00:04:04,950
repeat, what I get is precisely a really slow NG repeat table.

00:04:04,950 --> 00:04:06,700
[LAUGHTER]

00:04:06,700 --> 00:04:09,564
So I thought, React to the rescue.

00:04:09,564 --> 00:04:10,480
Here's a "wat" moment.

00:04:10,480 --> 00:04:12,938
Did you guys know React stole their logo from the Simpsons?

00:04:12,938 --> 00:04:14,279
There it is.

00:04:14,279 --> 00:04:15,570
This is the attempt we thought.

00:04:15,570 --> 00:04:17,420
Let's write a directive that internally

00:04:17,420 --> 00:04:19,290
uses React to render that list of stuff

00:04:19,290 --> 00:04:20,950
so that it can be optimally fast.

00:04:20,950 --> 00:04:24,270
We'll call that directive right inside of our NG repeat markup.

00:04:24,270 --> 00:04:27,056
Here's what happened.

00:04:27,056 --> 00:04:29,501
[LAUGHTER AND APPLAUSE]

00:04:29,501 --> 00:04:35,870


00:04:35,870 --> 00:04:37,860
It's not very good.

00:04:37,860 --> 00:04:38,990
Here's why it failed.

00:04:38,990 --> 00:04:41,297
React had no ability to batch its DOM operation,

00:04:41,297 --> 00:04:43,380
so it couldn't do the one thing that it's good at.

00:04:43,380 --> 00:04:45,839
And the reason was, it did not control the outer DOM.

00:04:45,839 --> 00:04:48,380
And what I mean by that is that Angular controlled the tables

00:04:48,380 --> 00:04:50,463
and rows, and then React just had to render inside

00:04:50,463 --> 00:04:51,896
of each one of those rows.

00:04:51,896 --> 00:04:53,270
So it ended up generating options

00:04:53,270 --> 00:04:55,820
like this-- append child react, append child react,

00:04:55,820 --> 00:04:59,575
append child react instead of just inner HTML.

00:04:59,575 --> 00:05:01,700
Also, I should point out, NG repeat, as we learned,

00:05:01,700 --> 00:05:02,700
is not inherently slow.

00:05:02,700 --> 00:05:05,116
And we ended up implementing this feature with a nested NG

00:05:05,116 --> 00:05:06,810
repeat, and it was fine.

00:05:06,810 --> 00:05:09,960
Then we go forward to a year into the future.

00:05:09,960 --> 00:05:11,790
Just a few months ago-- I'm going

00:05:11,790 --> 00:05:14,640
to tell you the glory part-- product management came

00:05:14,640 --> 00:05:16,690
to us again and said, please build the following.

00:05:16,690 --> 00:05:18,970
It's a schedule search algorithm.

00:05:18,970 --> 00:05:21,450
It allows users to bring up a calendar,

00:05:21,450 --> 00:05:23,010
click a Search button, and then we'll

00:05:23,010 --> 00:05:25,093
start searching in their calendar for availability

00:05:25,093 --> 00:05:26,100
to do interviewing.

00:05:26,100 --> 00:05:27,770
Well, this sounded really cool.

00:05:27,770 --> 00:05:29,850
But again, I started thinking about performance.

00:05:29,850 --> 00:05:31,780
And I was concerned, because we had done apps

00:05:31,780 --> 00:05:33,730
like this before where you have a lot of things happening

00:05:33,730 --> 00:05:35,438
a lot at a time, which means you're going

00:05:35,438 --> 00:05:36,670
to have a lot of digesting.

00:05:36,670 --> 00:05:38,960
What would happen is you'd click Search Week, all of the cells

00:05:38,960 --> 00:05:40,460
would go into spinner mode, and then

00:05:40,460 --> 00:05:43,130
results would start coming back from the server quickly.

00:05:43,130 --> 00:05:45,505
And before we knew it, you'd have a performance challenge

00:05:45,505 --> 00:05:46,510
on your hand.

00:05:46,510 --> 00:05:49,630
We decided, we already game overed once with React--

00:05:49,630 --> 00:05:51,820
should we insert coins to continue, or just

00:05:51,820 --> 00:05:53,180
keep our game over?

00:05:53,180 --> 00:05:55,480
We decided to insert coins.

00:05:55,480 --> 00:05:58,860
And this time when we did Angular plus React,

00:05:58,860 --> 00:06:01,970
we got a prophetic narwhal.

00:06:01,970 --> 00:06:04,072
I'd like to show you what that looks like.

00:06:04,072 --> 00:06:05,030
Here we have some code.

00:06:05,030 --> 00:06:06,910
This is my app.

00:06:06,910 --> 00:06:08,350
Instead of showing the actual app,

00:06:08,350 --> 00:06:09,974
I've reproduced it in a minimal fashion

00:06:09,974 --> 00:06:11,580
so you can just see the relevant bits.

00:06:11,580 --> 00:06:13,470
Here we have index.html.

00:06:13,470 --> 00:06:16,360
This body consists of just two directives.

00:06:16,360 --> 00:06:18,780
One is called My Calendar, and the other

00:06:18,780 --> 00:06:21,680
is called My Calendar React.

00:06:21,680 --> 00:06:24,870
I'd like to show you what this looks like.

00:06:24,870 --> 00:06:27,287
My Calendar and My Calendar React right there,

00:06:27,287 --> 00:06:28,870
right now, they're just a Load button.

00:06:28,870 --> 00:06:30,244
When I click this Load button, it

00:06:30,244 --> 00:06:32,980
will actually fill in the DOM to represent the calendar.

00:06:32,980 --> 00:06:36,900
But before I do that, I want to turn on the profiler.

00:06:36,900 --> 00:06:42,820
So I'm just going to hit Start, Load, Stop, just like that.

00:06:42,820 --> 00:06:45,290
So now you can see visually what the calendar looks like.

00:06:45,290 --> 00:06:51,780
It's 24 hours tall and 31 days wide for a total of 744 cells.

00:06:51,780 --> 00:06:53,367
And here is the profile.

00:06:53,367 --> 00:06:55,200
If you haven't used Chrome's profiling tool,

00:06:55,200 --> 00:06:56,699
I'll tell you a little bit about it.

00:06:56,699 --> 00:06:58,760
The horizontal axis is time.

00:06:58,760 --> 00:07:00,640
Left is older.

00:07:00,640 --> 00:07:01,750
Right is newer.

00:07:01,750 --> 00:07:03,860
The vertical axis actually represents

00:07:03,860 --> 00:07:07,230
the depth of your deepest function call stack.

00:07:07,230 --> 00:07:10,000
For the purposes of this talk, all we really

00:07:10,000 --> 00:07:11,510
care about is horizontal width.

00:07:11,510 --> 00:07:13,160
The depth isn't really that important.

00:07:13,160 --> 00:07:14,570
I'm going to zoom in here.

00:07:14,570 --> 00:07:19,030
You can see the Event Handler that happened here.

00:07:19,030 --> 00:07:21,220
And what we can see if we hover here

00:07:21,220 --> 00:07:23,390
is down below where it says aggregated total time is

00:07:23,390 --> 00:07:25,090
about 544 milliseconds.

00:07:25,090 --> 00:07:26,270
That's across all of these.

00:07:26,270 --> 00:07:29,660


00:07:29,660 --> 00:07:32,300
Now we're going to do the same thing in our React directive.

00:07:32,300 --> 00:07:33,550
Just click the Load button.

00:07:33,550 --> 00:07:37,285
I'm going to start the profiler, click Load, Stop.

00:07:37,285 --> 00:07:40,295


00:07:40,295 --> 00:07:41,920
Here you can see it did the same thing.

00:07:41,920 --> 00:07:43,940
Actually, this one was 87 milliseconds.

00:07:43,940 --> 00:07:45,080
And those numbers are a little weird.

00:07:45,080 --> 00:07:46,140
When I've run this before, it hasn't

00:07:46,140 --> 00:07:47,930
been that slow on the Angular One side,

00:07:47,930 --> 00:07:48,930
so I'm going to do this again just

00:07:48,930 --> 00:07:50,790
to make sure we get good representation.

00:07:50,790 --> 00:07:54,500
So Start, Load, Stop.

00:07:54,500 --> 00:07:55,650
OK.

00:07:55,650 --> 00:07:58,780
Yeah, that's more like it-- somewhere between 300 and 500

00:07:58,780 --> 00:08:00,190
milliseconds.

00:08:00,190 --> 00:08:02,680
So you can see why that happened is because React

00:08:02,680 --> 00:08:04,990
was able to generate all of that DOM

00:08:04,990 --> 00:08:07,580
by doing a single inner HTML call.

00:08:07,580 --> 00:08:10,650
When you give a browser an inner HTML piece of HTML,

00:08:10,650 --> 00:08:15,130
it really is the fastest it can run is about that.

00:08:15,130 --> 00:08:15,920
That's one thing.

00:08:15,920 --> 00:08:17,503
Now, the next thing I want to show you

00:08:17,503 --> 00:08:19,740
is, what happens when I click this Search button?

00:08:19,740 --> 00:08:21,767
So what I've got here is a whole bunch of cells.

00:08:21,767 --> 00:08:23,350
Each cell is independently searchable.

00:08:23,350 --> 00:08:25,590
So I can click on it, and it simulates a trip

00:08:25,590 --> 00:08:28,400
to the server that can take up to-- let's

00:08:28,400 --> 00:08:31,500
see-- I think I said 10 seconds, but let me just double check.

00:08:31,500 --> 00:08:32,000
Nope.

00:08:32,000 --> 00:08:34,150
Actually, that's half a second.

00:08:34,150 --> 00:08:36,409
We'll do it again here.

00:08:36,409 --> 00:08:38,720
So each cell can take up to 10 seconds to do a search.

00:08:38,720 --> 00:08:41,219
You can see that 4 o'clock hour came back with four results,

00:08:41,219 --> 00:08:43,159
and then it just randomly generates a response

00:08:43,159 --> 00:08:44,480
with a number in it.

00:08:44,480 --> 00:08:46,430
And I can have a bunch in flight at once,

00:08:46,430 --> 00:08:48,055
and within the next 10 seconds, they'll

00:08:48,055 --> 00:08:50,960
all return with results randomly generated.

00:08:50,960 --> 00:08:54,210
Between 0 and 10 seconds, just like that.

00:08:54,210 --> 00:08:55,960
Now, I am using dollar timeout to do this.

00:08:55,960 --> 00:08:58,418
So what that means is that every time a search result comes

00:08:58,418 --> 00:09:00,130
back, my root scope gets digested, which

00:09:00,130 --> 00:09:02,255
means Angular has to dirty check every single scope

00:09:02,255 --> 00:09:03,060
in my application.

00:09:03,060 --> 00:09:07,130
And since I have 744 cells inside of a nested NG repeat,

00:09:07,130 --> 00:09:09,595
I have 744 scopes at least.

00:09:09,595 --> 00:09:10,970
So that's a lot of dirty checking

00:09:10,970 --> 00:09:12,710
that it has to do in Angular One.

00:09:12,710 --> 00:09:15,285
So let me just click this button and start the profiler.

00:09:15,285 --> 00:09:19,370


00:09:19,370 --> 00:09:21,120
So you can see, between 0 and 10 seconds,

00:09:21,120 --> 00:09:22,995
each cell is slowly trickling in its results.

00:09:22,995 --> 00:09:27,840


00:09:27,840 --> 00:09:29,510
That's enough for now.

00:09:29,510 --> 00:09:31,710
Let me expand the profiler.

00:09:31,710 --> 00:09:33,650
So what you see here is a thick--

00:09:33,650 --> 00:09:35,210
what I like to call sequoia redwood

00:09:35,210 --> 00:09:38,050
forest with very thick trees.

00:09:38,050 --> 00:09:41,000
There are little gaps between the thick Sequoia trees.

00:09:41,000 --> 00:09:42,500
And those little gaps are times when

00:09:42,500 --> 00:09:44,270
the browser is responsive to user input

00:09:44,270 --> 00:09:45,670
and the event loop isn't busy.

00:09:45,670 --> 00:09:49,220
But the times where you see the colorful areas, the trees, that

00:09:49,220 --> 00:09:51,040
is time when your JavaScript code

00:09:51,040 --> 00:09:52,612
is blocking the event loop.

00:09:52,612 --> 00:09:54,070
And if you go and zoom way in here,

00:09:54,070 --> 00:09:57,210
you won't be surprised at what you find-- 744 scope

00:09:57,210 --> 00:09:59,770
digests inside of each one.

00:09:59,770 --> 00:10:02,220
Now, this is my fault, because I wrote my app this way

00:10:02,220 --> 00:10:03,230
to do dollar timeout.

00:10:03,230 --> 00:10:04,670
Dollar timeout is not very performant,

00:10:04,670 --> 00:10:06,836
because it assumes that anything could have changed,

00:10:06,836 --> 00:10:09,330
so it needs to redigest your whole app.

00:10:09,330 --> 00:10:12,050
But let's go look at the Reactor version.

00:10:12,050 --> 00:10:15,070
So I'm going to load it, start the profiler,

00:10:15,070 --> 00:10:15,990
hit the Search button.

00:10:15,990 --> 00:10:20,520


00:10:20,520 --> 00:10:22,640
That's probably enough.

00:10:22,640 --> 00:10:24,527
And let's zoom in on that.

00:10:24,527 --> 00:10:26,360
So you can see here, it's a different story.

00:10:26,360 --> 00:10:28,600
Instead of a forest of thick sequoia redwood trees,

00:10:28,600 --> 00:10:31,930
we have a forest of toothpicks, which is what you want to see.

00:10:31,930 --> 00:10:34,130
This space between each toothpick

00:10:34,130 --> 00:10:37,080
is time when the browser can be fully responsive to user input.

00:10:37,080 --> 00:10:40,350
So just to compare a little more carefully here,

00:10:40,350 --> 00:10:45,480
let's just pick about a one-second time chunk there.

00:10:45,480 --> 00:10:48,760
So this is from second five to second six on the Angular one.

00:10:48,760 --> 00:10:52,220
And then I'll do the same thing in React.

00:10:52,220 --> 00:10:54,600
Here's a one-second time chunk.

00:10:54,600 --> 00:10:56,520
You can see quite a big difference

00:10:56,520 --> 00:11:00,110
in the amount of space between each chunk.

00:11:00,110 --> 00:11:00,610
All right.

00:11:00,610 --> 00:11:01,940
So that's how that looks.

00:11:01,940 --> 00:11:04,440
By the way, I could have done some more optimization to make

00:11:04,440 --> 00:11:07,870
the Angular One app look more like this, but I didn't.

00:11:07,870 --> 00:11:11,410
Because by default, we're going to be using dollar timeout,

00:11:11,410 --> 00:11:13,910
and this is the kind of thing you're going to have to debug.

00:11:13,910 --> 00:11:15,993
But let me just show you what the code looks like.

00:11:15,993 --> 00:11:18,520
So here's my app file.

00:11:18,520 --> 00:11:21,314
The Angular One code, you should be really familiar with.

00:11:21,314 --> 00:11:22,480
This is common pattern here.

00:11:22,480 --> 00:11:24,366
We have our My Calendar directive.

00:11:24,366 --> 00:11:25,740
Inside the My Calendar directive,

00:11:25,740 --> 00:11:28,330
I have a nested NG repeat, and then

00:11:28,330 --> 00:11:30,810
inside that nested NG repeat, I have a My Calendar cell

00:11:30,810 --> 00:11:33,980
directive, which is declared a little bit down here.

00:11:33,980 --> 00:11:36,260
And each My Calendar cell has just a couple of NGS

00:11:36,260 --> 00:11:38,280
ifs inside of it to decide what state to show

00:11:38,280 --> 00:11:40,340
and what should go in there, just like that.

00:11:40,340 --> 00:11:42,167
Pretty straightforward.

00:11:42,167 --> 00:11:44,250
Now, if I scroll down below the calendar cell one,

00:11:44,250 --> 00:11:47,640
I'll show you the directive that has React inside of it.

00:11:47,640 --> 00:11:49,160
So My Calendar React was the name

00:11:49,160 --> 00:11:51,570
of directive, which you'll remember from the HTML.

00:11:51,570 --> 00:11:55,220
And here's its link function, which just does one thing.

00:11:55,220 --> 00:11:59,539
It says react dot render, and then this weird thing.

00:11:59,539 --> 00:12:00,830
Does anybody know what that is?

00:12:00,830 --> 00:12:02,730
Has anyone seen that before?

00:12:02,730 --> 00:12:04,030
This is called JSX.

00:12:04,030 --> 00:12:06,370
And it is not JavaScript.

00:12:06,370 --> 00:12:09,250
It is a way to easily represent HTML right

00:12:09,250 --> 00:12:10,720
inside of your JavaScript.

00:12:10,720 --> 00:12:12,889
And this thing is actually a React component,

00:12:12,889 --> 00:12:15,180
which I'll scroll down and show you what it looks like.

00:12:15,180 --> 00:12:16,680
So here I have a calendar component.

00:12:16,680 --> 00:12:19,060


00:12:19,060 --> 00:12:21,980
You declare a React component by saying react.createclass.

00:12:21,980 --> 00:12:24,490
Every React component should have a render function.

00:12:24,490 --> 00:12:26,599
And the render function returns a bunch of HTML.

00:12:26,599 --> 00:12:28,390
Now, it looks pretty templatey, but notice,

00:12:28,390 --> 00:12:30,120
we're still in our JavaScript file.

00:12:30,120 --> 00:12:33,110
This HTML is actually not returning DOM.

00:12:33,110 --> 00:12:35,630
This HTML-- or this stuff that looks like HTML--

00:12:35,630 --> 00:12:38,150
is actually returning virtual DOM.

00:12:38,150 --> 00:12:42,170
And this gets compiled by React's JSX compiler

00:12:42,170 --> 00:12:44,260
into a different kind of JavaScript that actually

00:12:44,260 --> 00:12:45,910
will execute in the browser.

00:12:45,910 --> 00:12:47,790
So you can see here, this is my calendar.

00:12:47,790 --> 00:12:51,860
My calendar is just like my angular calendar.

00:12:51,860 --> 00:12:56,310
Instead of using NG repeat, we actually use array dot map.

00:12:56,310 --> 00:12:59,360
So here I've got an array dot map over the hours and an array

00:12:59,360 --> 00:13:00,760
dot map over the days.

00:13:00,760 --> 00:13:03,960
And inside here, I've got a cell component that I've written.

00:13:03,960 --> 00:13:06,280
And the cell component is another react class

00:13:06,280 --> 00:13:07,940
with its own render function that

00:13:07,940 --> 00:13:10,110
has a couple of if statements and returns different

00:13:10,110 --> 00:13:13,190
HTML depending on the state of the cell.

00:13:13,190 --> 00:13:14,830
Just like that.

00:13:14,830 --> 00:13:15,390
All right.

00:13:15,390 --> 00:13:18,440
So that's actually how easy it is

00:13:18,440 --> 00:13:22,512
to integrate a React component into in Angular directive.

00:13:22,512 --> 00:13:24,970
Let me show you what happens when we speed things up a bit.

00:13:24,970 --> 00:13:27,540
So right now, we saw with a 10-second random timeout

00:13:27,540 --> 00:13:29,550
on each cell what it looks like.

00:13:29,550 --> 00:13:31,400
If I make that closer to half a second,

00:13:31,400 --> 00:13:33,500
you can really start to feel what things look

00:13:33,500 --> 00:13:36,130
like from a user's perspective.

00:13:36,130 --> 00:13:39,649
So let's load up the Angular One, hit Search.

00:13:39,649 --> 00:13:41,690
Now, remember, I made it a half-a-second timeout,

00:13:41,690 --> 00:13:44,830
so all of these should be done in half a second.

00:13:44,830 --> 00:13:46,122
You can see it's cooking along.

00:13:46,122 --> 00:13:48,663
Actually, I think this is not-- I think I made them in cache.

00:13:48,663 --> 00:13:49,544
Let me try again.

00:13:49,544 --> 00:13:52,480


00:13:52,480 --> 00:13:53,480
That doesn't look right.

00:13:53,480 --> 00:13:57,480


00:13:57,480 --> 00:13:58,480
Let's go to the New Tab.

00:13:58,480 --> 00:14:02,104


00:14:02,104 --> 00:14:03,010
Huh.

00:14:03,010 --> 00:14:03,910
Maybe that's right.

00:14:03,910 --> 00:14:07,340
It seems awfully slow.

00:14:07,340 --> 00:14:08,430
Let me restart.

00:14:08,430 --> 00:14:12,800


00:14:12,800 --> 00:14:15,575
Wait for it.

00:14:15,575 --> 00:14:16,075
OK.

00:14:16,075 --> 00:14:19,615


00:14:19,615 --> 00:14:20,550
Huh.

00:14:20,550 --> 00:14:22,883
That seems really slow to me, but we'll just go with it.

00:14:22,883 --> 00:14:24,866
Let me show you the React One.

00:14:24,866 --> 00:14:25,490
Just like that.

00:14:25,490 --> 00:14:28,290


00:14:28,290 --> 00:14:30,942
Let me do that again, in case you didn't see it.

00:14:30,942 --> 00:14:32,415
[LAUGHTER]

00:14:32,415 --> 00:14:33,400


00:14:33,400 --> 00:14:35,230
You had to be watching.

00:14:35,230 --> 00:14:38,090
So the difference there is not digesting the whole world.

00:14:38,090 --> 00:14:40,442
Because in the React app, it was easily-- by default,

00:14:40,442 --> 00:14:41,900
the design is to only really digest

00:14:41,900 --> 00:14:44,450
the things you need to, although it doesn't have a digest.

00:14:44,450 --> 00:14:46,270
And in fact, the root scope digest

00:14:46,270 --> 00:14:48,620
didn't run at all inside the React directive.

00:14:48,620 --> 00:14:49,960
So there you you.

00:14:49,960 --> 00:14:52,321
So that's kind of the difference.

00:14:52,321 --> 00:14:52,820
All right.

00:14:52,820 --> 00:14:55,732
So let's go back to slides here.

00:14:55,732 --> 00:14:57,190
There are drawbacks to using React.

00:14:57,190 --> 00:15:00,040
First of all, you will add 500 kilobytes of code to your app.

00:15:00,040 --> 00:15:01,830
It is not a tiny library.

00:15:01,830 --> 00:15:03,790
Secondly, you must have a JSX build step.

00:15:03,790 --> 00:15:06,529
You can write Reactive without JSX, but I don't recommend it.

00:15:06,529 --> 00:15:08,570
Thirdly, you now have two frameworks in your app.

00:15:08,570 --> 00:15:10,650
Now, this is a problem because you have people to train,

00:15:10,650 --> 00:15:12,816
you have developers who won't know one or the other,

00:15:12,816 --> 00:15:14,430
and now they might have to know both.

00:15:14,430 --> 00:15:16,130
So it can be a problem.

00:15:16,130 --> 00:15:17,940
Lastly, you might very well have to change

00:15:17,940 --> 00:15:18,960
your internationalization.

00:15:18,960 --> 00:15:19,460
We did.

00:15:19,460 --> 00:15:21,210
We support 14 languages, and we had

00:15:21,210 --> 00:15:23,230
to use a very different internationalization

00:15:23,230 --> 00:15:25,860
pattern with React than we did with Angular.

00:15:25,860 --> 00:15:27,370
React, however, does shine.

00:15:27,370 --> 00:15:29,390
In the initial download, it does really well,

00:15:29,390 --> 00:15:31,140
because it can batch all of the operations

00:15:31,140 --> 00:15:32,960
to generate it really quickly.

00:15:32,960 --> 00:15:35,490
And this is mostly thanks to things like inner HTML.

00:15:35,490 --> 00:15:37,184
Also, after small state changes, React

00:15:37,184 --> 00:15:39,475
is really good about only touching the parts of the DOM

00:15:39,475 --> 00:15:40,390
that actually changed.

00:15:40,390 --> 00:15:41,890
And it's even really good when there

00:15:41,890 --> 00:15:45,160
is big changes in the DOM, because it can bulk do those,

00:15:45,160 --> 00:15:46,450
too.

00:15:46,450 --> 00:15:49,355
React is kind of weak after there are no state changes.

00:15:49,355 --> 00:15:51,410
If you tell React to re-render your whole app,

00:15:51,410 --> 00:15:53,350
it will generate all of the new virtual DOM.

00:15:53,350 --> 00:15:55,680
And in my experience, it takes about twice as long

00:15:55,680 --> 00:15:58,480
to generate all the virtual DOM for an app of significant size

00:15:58,480 --> 00:16:02,502
than it does to run through the digest dirty check once.

00:16:02,502 --> 00:16:04,460
For an app I was testing with, for example, you

00:16:04,460 --> 00:16:07,576
can get 13 milliseconds verses about 27 milliseconds in React,

00:16:07,576 --> 00:16:09,200
which you might think is insignificant,

00:16:09,200 --> 00:16:12,525
except 27 is greater than the 60 SPS boundary, which

00:16:12,525 --> 00:16:13,690
is 16 milliseconds.

00:16:13,690 --> 00:16:15,799
And so it does make a difference.

00:16:15,799 --> 00:16:17,340
One of the strategies I use is to not

00:16:17,340 --> 00:16:19,270
tell the whole app to re-render, but rather,

00:16:19,270 --> 00:16:20,811
find the components that have changed

00:16:20,811 --> 00:16:22,212
and tell those to re-render.

00:16:22,212 --> 00:16:24,670
So that's pretty much all I wanted to show you about React,

00:16:24,670 --> 00:16:30,180
but I do have one more thing that I wanted to show you.

00:16:30,180 --> 00:16:34,447
I did actually build the app in Angular 2.

00:16:34,447 --> 00:16:36,280
Thanks a lot to the Angular team for helping

00:16:36,280 --> 00:16:37,720
me get this working.

00:16:37,720 --> 00:16:40,860
And I just wanted to show you what that looks like.

00:16:40,860 --> 00:16:43,084
So first of all, I'm going to hit the Load button.

00:16:43,084 --> 00:16:44,250
That's actually really fast.

00:16:44,250 --> 00:16:45,586
Hope you can see that.

00:16:45,586 --> 00:16:47,210
Now I'm going to hit the Search button.

00:16:47,210 --> 00:16:52,750
So you will want to be watching for this, because remember,

00:16:52,750 --> 00:16:54,875
here's how it looked like with React.

00:16:54,875 --> 00:16:56,500
Just pay attention to how long it took.

00:16:56,500 --> 00:16:57,083
This is React.

00:16:57,083 --> 00:17:00,280


00:17:00,280 --> 00:17:02,532
And here is Angular 2.

00:17:02,532 --> 00:17:05,012
[CHEERS AND APPLAUSE]

00:17:05,012 --> 00:17:17,908


00:17:17,908 --> 00:17:18,910
[LAUGHTER]

00:17:18,910 --> 00:17:23,010
Angular 2 is really, really fast.

00:17:23,010 --> 00:17:24,950
You have to do your own engineering.

00:17:24,950 --> 00:17:27,560
You need to measure, observe, and decide for your team.

00:17:27,560 --> 00:17:28,430
Thanks very much.

00:17:28,430 --> 00:17:30,900
[APPLAUSE]

00:17:30,900 --> 00:17:37,816


00:17:37,816 --> 00:17:40,100
DAVE SMITH (VOICEOVER): Hey, everybody.

00:17:40,100 --> 00:17:42,980
You may have noticed a mistake that I made in my talk

00:17:42,980 --> 00:17:45,940
when I was comparing the performance of Angular

00:17:45,940 --> 00:17:49,130
2 and the React example.

00:17:49,130 --> 00:17:52,460
The problem was that in my Angular 2 example,

00:17:52,460 --> 00:17:54,760
the random millis function was written

00:17:54,760 --> 00:17:58,770
to return 0 while the react function at the time

00:17:58,770 --> 00:18:04,540
was written to return a random number between 0 and 500.

00:18:04,540 --> 00:18:06,120
So it's really not a fair comparison

00:18:06,120 --> 00:18:10,540
to show the run times of the two frameworks when one of them

00:18:10,540 --> 00:18:12,884
is set up to return more slowly.

00:18:12,884 --> 00:18:14,050
I'm really sorry about that.

00:18:14,050 --> 00:18:16,080
It was completely accidental.

00:18:16,080 --> 00:18:17,900
Now I want to make it right and show you

00:18:17,900 --> 00:18:20,910
what it looks like when both frameworks are set up to return

00:18:20,910 --> 00:18:23,550
a zero millisecond timeout.

00:18:23,550 --> 00:18:28,209
So here is the React example.

00:18:28,209 --> 00:18:30,000
And I'm not even going to run the profiler.

00:18:30,000 --> 00:18:32,560
I'm just going to let you see it visually.

00:18:32,560 --> 00:18:36,000
So I'm going to click the Search All Month button.

00:18:36,000 --> 00:18:36,920
OK.

00:18:36,920 --> 00:18:38,820
And here is the Angular 2 example.

00:18:38,820 --> 00:18:41,740


00:18:41,740 --> 00:18:45,130
To my eye, the Angular 2 example does look a little bit faster

00:18:45,130 --> 00:18:48,670
for this particular example.

00:18:48,670 --> 00:18:52,140
But it's worth mentioning that the Angular team actually

00:18:52,140 --> 00:18:53,930
helped me optimize this.

00:18:53,930 --> 00:18:57,470
And the React team hasn't had a chance to look at this at all.

00:18:57,470 --> 00:18:59,381
I wouldn't make any kind of conclusion

00:18:59,381 --> 00:19:01,630
about the relative performance of these two frameworks

00:19:01,630 --> 00:19:03,050
from this example.

00:19:03,050 --> 00:19:07,450
But I at least wanted to show that I did make a mistake,

00:19:07,450 --> 00:19:10,340
and I did make the performance difference look more

00:19:10,340 --> 00:19:12,130
significant than it really was.

00:19:12,130 --> 00:19:13,280
So I apologize for that.

00:19:13,280 --> 00:19:15,850
And thanks for being patient with me as I

00:19:15,850 --> 00:19:16,810
work on performance.

00:19:16,810 --> 00:19:19,940
Like I said in my talk, performance is hard.

00:19:19,940 --> 00:19:22,840
And what I didn't say in my talk is that I'm a gigantic idiot,

00:19:22,840 --> 00:19:24,215
and you probably shouldn't listen

00:19:24,215 --> 00:19:25,583
to anything I say anyway.


YouTube URL: https://www.youtube.com/watch?v=XQM0K6YG18s


