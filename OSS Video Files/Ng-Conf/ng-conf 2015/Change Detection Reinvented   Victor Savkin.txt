Title: Change Detection Reinvented   Victor Savkin
Publication date: 2015-03-06
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:00,470


00:00:00,470 --> 00:00:00,970
All right.

00:00:00,970 --> 00:00:03,381
So I'm Victor, and I'm a member of the Angular core team.

00:00:03,381 --> 00:00:05,880
And today, I want to tell you about the new change detection

00:00:05,880 --> 00:00:08,010
system we built for Angular 2.

00:00:08,010 --> 00:00:09,870
So this is a somewhat technical talk.

00:00:09,870 --> 00:00:12,910
So if you find something a bit hard to understand,

00:00:12,910 --> 00:00:13,550
don't worry.

00:00:13,550 --> 00:00:16,190
I will provide links to the articles and presentation that

00:00:16,190 --> 00:00:18,412
will cover the same material.

00:00:18,412 --> 00:00:20,370
And you can, of course, grab me after the talk,

00:00:20,370 --> 00:00:23,160
and I will answer all your questions.

00:00:23,160 --> 00:00:23,900
OK.

00:00:23,900 --> 00:00:25,520
Let's get started.

00:00:25,520 --> 00:00:28,960
First, let's define what change detection is.

00:00:28,960 --> 00:00:30,910
And to do that, let's look at this app.

00:00:30,910 --> 00:00:32,659
It's a very simple app.

00:00:32,659 --> 00:00:35,490
It has a list of technical talks you can filter,

00:00:35,490 --> 00:00:38,090
watch, and rate.

00:00:38,090 --> 00:00:39,730
Any Angular 2 application will always

00:00:39,730 --> 00:00:41,330
have a tree of components.

00:00:41,330 --> 00:00:44,560
Let's say our application has this tree.

00:00:44,560 --> 00:00:47,740
Let's look at the components in this tree.

00:00:47,740 --> 00:00:51,520
We have the Filters component that has a speaker

00:00:51,520 --> 00:00:54,570
input and the Filter button.

00:00:54,570 --> 00:00:57,035
We have the Talks component-- "Talks" plural.

00:00:57,035 --> 00:00:59,920
And it's the list you see at the bottom.

00:00:59,920 --> 00:01:03,660
And we also have a talk, which is an item in that list.

00:01:03,660 --> 00:01:05,349
In addition to our component tree,

00:01:05,349 --> 00:01:08,050
our application will have a model.

00:01:08,050 --> 00:01:10,660
Let's say our model looks like this.

00:01:10,660 --> 00:01:13,240
So it's a plain old JavaScript object.

00:01:13,240 --> 00:01:15,120
Nothing fancy.

00:01:15,120 --> 00:01:18,090
Now, imagine an event that changes the model.

00:01:18,090 --> 00:01:20,180
Let's say I watched the talk.

00:01:20,180 --> 00:01:23,040
I really liked it, and I like this talk a lot.

00:01:23,040 --> 00:01:31,809
And I decided to give it 9.9.

00:01:31,809 --> 00:01:32,770
Awesome.

00:01:32,770 --> 00:01:35,810
So what we have right now is the updated model.

00:01:35,810 --> 00:01:38,930
What happens next is, at the end of the [INAUDIBLE],

00:01:38,930 --> 00:01:41,520
change detection will walk the component tree.

00:01:41,520 --> 00:01:45,700
And for every component, it will check the model it depends on.

00:01:45,700 --> 00:01:48,840
And if that model change, it will update the component.

00:01:48,840 --> 00:01:53,050
So in our example, this component will be updated.

00:01:53,050 --> 00:01:54,860
After that, it will update the DOM

00:01:54,860 --> 00:01:57,460
to match the state of the component tree.

00:01:57,460 --> 00:01:59,780
In our example, this bot will get disabled,

00:01:59,780 --> 00:02:03,060
because you cannot read the same talk twice.

00:02:03,060 --> 00:02:04,490
All right?

00:02:04,490 --> 00:02:06,120
More abstractly, in Angular 2, we

00:02:06,120 --> 00:02:09,000
separated application state update, or application model

00:02:09,000 --> 00:02:12,220
update, and the view state propagation.

00:02:12,220 --> 00:02:15,570
So the first part, application state update,

00:02:15,570 --> 00:02:21,190
is done by your code, your custom code, due to some event.

00:02:21,190 --> 00:02:22,160
All right?

00:02:22,160 --> 00:02:25,740
And the second part is done via change detection.

00:02:25,740 --> 00:02:29,360
So change detection doesn't update your model anymore.

00:02:29,360 --> 00:02:32,452
Instead, it just syncs up your model with the component tree,

00:02:32,452 --> 00:02:34,970
or syncs up your component tree with the model,

00:02:34,970 --> 00:02:38,950
and your DOM with the component tree.

00:02:38,950 --> 00:02:40,710
So how is it different from Angular 1?

00:02:40,710 --> 00:02:42,660
Because Angular 1 right now, currently,

00:02:42,660 --> 00:02:45,000
has a very similar mechanism.

00:02:45,000 --> 00:02:49,540
In Angular 1, these arrows point in both directions.

00:02:49,540 --> 00:02:52,950
So you can have DOM update in a directive via change detection.

00:02:52,950 --> 00:02:54,890
And a directive can affect a model,

00:02:54,890 --> 00:02:57,250
again via change detection.

00:02:57,250 --> 00:03:00,300
Moreover, a directive can affect another directive.

00:03:00,300 --> 00:03:04,380
And a model can affect another model.

00:03:04,380 --> 00:03:07,610
Or more formally, in Angular 1, our change detection graph

00:03:07,610 --> 00:03:08,930
has cycles.

00:03:08,930 --> 00:03:11,510
And in Angular 2, it's a tree.

00:03:11,510 --> 00:03:12,700
And trees are fantastic.

00:03:12,700 --> 00:03:14,540
I really like trees, because we all

00:03:14,540 --> 00:03:16,150
know how to reason about them.

00:03:16,150 --> 00:03:18,140
We understand trees very well.

00:03:18,140 --> 00:03:21,040
And they also provide nice guarantees.

00:03:21,040 --> 00:03:22,810
And in my view, it has a profound impact

00:03:22,810 --> 00:03:24,530
on the dev experience.

00:03:24,530 --> 00:03:28,560
And I want to give you one example to demonstrate that.

00:03:28,560 --> 00:03:31,150
So this is Angular 1.

00:03:31,150 --> 00:03:37,730
Because of the cycles, it's hard to know what gets updated when.

00:03:37,730 --> 00:03:40,940
In this example, we have two directives-- parent and child.

00:03:40,940 --> 00:03:45,117
And each directive has two bindings.

00:03:45,117 --> 00:03:46,950
Do you know which one will be updated first?

00:03:46,950 --> 00:03:48,470
Like parent or child?

00:03:48,470 --> 00:03:53,582
Actually, because of the cycles, the updates can be interleaved.

00:03:53,582 --> 00:03:55,790
Like do you know how many times a particular property

00:03:55,790 --> 00:03:57,650
is checked and updated?

00:03:57,650 --> 00:04:02,860
It can be zero, one, or many-- again, because of the cycles.

00:04:02,860 --> 00:04:06,230
In Angular 2, we have a tree, and we cannot have cycles.

00:04:06,230 --> 00:04:09,300
We can answer these questions much better.

00:04:09,300 --> 00:04:14,090
We know exactly what gets checked and how many times.

00:04:14,090 --> 00:04:17,810
And what is more important, the order of the checks

00:04:17,810 --> 00:04:20,779
is determined by the template only.

00:04:20,779 --> 00:04:22,780
So in this example, parent will always

00:04:22,780 --> 00:04:24,870
be checked before child, regardless

00:04:24,870 --> 00:04:28,330
of what parent and child are.

00:04:28,330 --> 00:04:31,120
In addition, the new system is designed in the way

00:04:31,120 --> 00:04:34,150
that it gets table after a single pass.

00:04:34,150 --> 00:04:36,720
So the number of digest iterations is fixed.

00:04:36,720 --> 00:04:37,680
It's one.

00:04:37,680 --> 00:04:39,310
You cannot change it.

00:04:39,310 --> 00:04:43,510
So the [AUDIO OUT] iterations is no longer present.

00:04:43,510 --> 00:04:46,170
So it's gone.

00:04:46,170 --> 00:04:47,328
All right, listen.

00:04:47,328 --> 00:04:49,200
[APPLAUSE]

00:04:49,200 --> 00:04:51,080


00:04:51,080 --> 00:04:52,620
Yeah, I think it's awesome.

00:04:52,620 --> 00:04:53,170
All right.

00:04:53,170 --> 00:04:55,580
So what we've learned so far-- we've

00:04:55,580 --> 00:04:58,510
learned that, in the new system, the change detection

00:04:58,510 --> 00:05:00,500
graph is a tree.

00:05:00,500 --> 00:05:02,780
And it makes the system a lot more predictable.

00:05:02,780 --> 00:05:04,840
We can reason about it better.

00:05:04,840 --> 00:05:09,630
And finally, the number of digest iterations is one.

00:05:09,630 --> 00:05:12,550
And this is what I like most about the new system,

00:05:12,550 --> 00:05:16,880
is that you can reason about it statically and locally.

00:05:16,880 --> 00:05:18,880
And what I mean by that is you can

00:05:18,880 --> 00:05:21,830
look at a template-- at a single template, at one file.

00:05:21,830 --> 00:05:24,490
And you will know how changes propagate

00:05:24,490 --> 00:05:26,820
without knowing anything else about your application.

00:05:26,820 --> 00:05:29,431


00:05:29,431 --> 00:05:31,180
But, of course, the main question for many

00:05:31,180 --> 00:05:32,950
is how fast is it?

00:05:32,950 --> 00:05:35,220
Because we want it to be very fast.

00:05:35,220 --> 00:05:39,920
To answer this question, let's look at this formula.

00:05:39,920 --> 00:05:42,980
It defines how long it takes to go through the change detection

00:05:42,980 --> 00:05:44,310
graph.

00:05:44,310 --> 00:05:46,480
N here is the number of bindings,

00:05:46,480 --> 00:05:49,150
total number of bindings for the system,

00:05:49,150 --> 00:05:54,160
and C is the average time it takes to check a binding.

00:05:54,160 --> 00:05:56,320
There are two ways to make the system faster--

00:05:56,320 --> 00:05:58,340
we can decrease C, or we can deal

00:05:58,340 --> 00:06:04,010
with N. Let's start with C. To understand

00:06:04,010 --> 00:06:07,250
how we made this constant, the average time it takes

00:06:07,250 --> 00:06:09,980
to check a binding smaller, let's

00:06:09,980 --> 00:06:12,222
dissect the following binding.

00:06:12,222 --> 00:06:14,730
It's a very simple binding.

00:06:14,730 --> 00:06:17,470
A reasonable way to have read this binding

00:06:17,470 --> 00:06:21,690
is to get a getter function for every property read.

00:06:21,690 --> 00:06:22,300
All right?

00:06:22,300 --> 00:06:24,130
And then use a getter function to get

00:06:24,130 --> 00:06:26,740
the value of the property.

00:06:26,740 --> 00:06:28,536
Of course, we don't have talk and rating

00:06:28,536 --> 00:06:29,660
hardcoded in our code base.

00:06:29,660 --> 00:06:32,800
So we have a generic function that does stuff like that.

00:06:32,800 --> 00:06:36,150
So first, it takes a getter function for property read.

00:06:36,150 --> 00:06:40,810
Then, it has an old value of the property stored somewhere.

00:06:40,810 --> 00:06:42,380
Then it computes the new value.

00:06:42,380 --> 00:06:43,500
It checks if the same.

00:06:43,500 --> 00:06:48,350
And if it's not, it will invoke the reaction function.

00:06:48,350 --> 00:06:50,230
This is a very high level view of the system.

00:06:50,230 --> 00:06:52,750
So it's not how Angular 1 works exactly,

00:06:52,750 --> 00:06:56,210
but it sort of gives you an idea.

00:06:56,210 --> 00:06:58,430
I think the solution is great.

00:06:58,430 --> 00:07:00,270
I mean, it's easy to understand.

00:07:00,270 --> 00:07:02,060
It is elegant.

00:07:02,060 --> 00:07:03,915
But it has one problem.

00:07:03,915 --> 00:07:06,287
And the problem is that virtual machines do not

00:07:06,287 --> 00:07:08,320
like this kind of code.

00:07:08,320 --> 00:07:10,900
They cannot give the times of the objects here.

00:07:10,900 --> 00:07:13,820
And as a result, they cannot use the optimization that made

00:07:13,820 --> 00:07:16,170
JavaScript fast.

00:07:16,170 --> 00:07:18,340
The highlighted codes here are polymorphic,

00:07:18,340 --> 00:07:22,020
and such codes are very expensive.

00:07:22,020 --> 00:07:25,420
So what do virtual machines like instead?

00:07:25,420 --> 00:07:27,900
They like the code that looks like this.

00:07:27,900 --> 00:07:30,300
Here, we don't have generic getter functions

00:07:30,300 --> 00:07:32,710
that we invoke to evaluate our expression.

00:07:32,710 --> 00:07:37,890
Instead, we just access the value of the field directly.

00:07:37,890 --> 00:07:41,130
And given that old value is not the same as a new value,

00:07:41,130 --> 00:07:42,590
we are going to invoke-- we are not

00:07:42,590 --> 00:07:44,756
going to invoke a generic reaction function anymore.

00:07:44,756 --> 00:07:48,960
We are going to update the component, again, directly.

00:07:48,960 --> 00:07:52,060
All the variables here will always have the same shape.

00:07:52,060 --> 00:07:53,780
Like all the objects will always have

00:07:53,780 --> 00:07:56,440
the same shape, the same type.

00:07:56,440 --> 00:07:59,500
Virtual machines will be able to deduce those types.

00:07:59,500 --> 00:08:03,170
And as a result, all the calls here are very fast.

00:08:03,170 --> 00:08:05,580
They're monomorphic.

00:08:05,580 --> 00:08:07,350
So what do you do in Angular 2?

00:08:07,350 --> 00:08:09,540
How do you make it fast?

00:08:09,540 --> 00:08:13,677
So when compiling the template of component,

00:08:13,677 --> 00:08:15,385
we take all the bindings of the template,

00:08:15,385 --> 00:08:18,810
and we generate a clause that looks like this,

00:08:18,810 --> 00:08:21,520
one clause per component.

00:08:21,520 --> 00:08:23,262
So basically, we generate the clause

00:08:23,262 --> 00:08:24,720
that you would write by hand if you

00:08:24,720 --> 00:08:26,600
wanted to do change detection.

00:08:26,600 --> 00:08:29,277
And VMs love that.

00:08:29,277 --> 00:08:30,860
What's important here is that we do it

00:08:30,860 --> 00:08:32,961
behind the scenes at runtime.

00:08:32,961 --> 00:08:35,169
So there is nothing you need to do to make it happen.

00:08:35,169 --> 00:08:37,960
It just happens automatically.

00:08:37,960 --> 00:08:39,349
And it decreases the average time

00:08:39,349 --> 00:08:43,590
of checking the binding significantly.

00:08:43,590 --> 00:08:47,910
Depending on the use case, it makes change detection 3x

00:08:47,910 --> 00:08:49,871
to 10x faster.

00:08:49,871 --> 00:08:50,870
And you get it for free.

00:08:50,870 --> 00:08:52,320
You don't need to change anything

00:08:52,320 --> 00:08:53,990
about your application.

00:08:53,990 --> 00:08:57,350
I think it's a very good result.

00:08:57,350 --> 00:09:00,220
I think the performance of Angular 1

00:09:00,220 --> 00:09:03,050
is actually good enough for the majority of apps.

00:09:03,050 --> 00:09:09,310
And as you can see, Angular 2 is quite a bit faster, 10x faster.

00:09:09,310 --> 00:09:12,290
But some applications may require

00:09:12,290 --> 00:09:14,800
even better performance, if you're on a mobile,

00:09:14,800 --> 00:09:16,220
for example.

00:09:16,220 --> 00:09:20,860
Let's see how we enable that in Angular 2.

00:09:20,860 --> 00:09:23,470
To understand that, let's look at this formula again.

00:09:23,470 --> 00:09:25,850
So what we've learned right now is that the constant

00:09:25,850 --> 00:09:27,910
is much smaller.

00:09:27,910 --> 00:09:29,130
But what about N?

00:09:29,130 --> 00:09:33,550
So can we be smarter about what we check?

00:09:33,550 --> 00:09:35,750
The answer is we can.

00:09:35,750 --> 00:09:39,661
And to see how, let's look at this example.

00:09:39,661 --> 00:09:40,160
OK.

00:09:40,160 --> 00:09:43,550
What we have here is two components--

00:09:43,550 --> 00:09:47,680
talks component that contains a list of talk components.

00:09:47,680 --> 00:09:52,260
So it's basically a list and an item in that list.

00:09:52,260 --> 00:09:55,040
And what you see on this slide is the template

00:09:55,040 --> 00:09:57,440
of the two components.

00:09:57,440 --> 00:10:01,260
So let's say our change detection system checks

00:10:01,260 --> 00:10:04,190
the model for one of the components,

00:10:04,190 --> 00:10:06,550
and it happened to be the same instance.

00:10:06,550 --> 00:10:09,720
So it's the same talk model instance.

00:10:09,720 --> 00:10:14,390
Can we just keep checking the template of that component?

00:10:14,390 --> 00:10:15,970
Well, of course we can't.

00:10:15,970 --> 00:10:17,540
The object is mutable.

00:10:17,540 --> 00:10:22,340
So even though the instance is the same, the title can change.

00:10:22,340 --> 00:10:24,730
So we cannot skip it.

00:10:24,730 --> 00:10:27,100
So Angular has to be conservative and check

00:10:27,100 --> 00:10:30,530
everything, because mutable-- plain old JavaScript objects,

00:10:30,530 --> 00:10:33,650
like JSON like objects, they don't provide us

00:10:33,650 --> 00:10:37,790
enough guarantees in regards to how they change.

00:10:37,790 --> 00:10:41,040
And as a result, we have to go through every single component

00:10:41,040 --> 00:10:45,480
in the system, every single time, and check their bindings.

00:10:45,480 --> 00:10:48,040
All right?

00:10:48,040 --> 00:10:49,890
But although the JavaScript language itself

00:10:49,890 --> 00:10:52,710
doesn't give us guarantees, you as a developer,

00:10:52,710 --> 00:10:55,550
you may know that certain objects in your application,

00:10:55,550 --> 00:10:56,880
they do not change.

00:10:56,880 --> 00:10:59,290
Or you know when they change.

00:10:59,290 --> 00:11:01,740
And now, you'll be able to give this information

00:11:01,740 --> 00:11:07,960
to the framework, and it will be smarter about what it checks.

00:11:07,960 --> 00:11:10,595
For example, let's take a look at immutable objects.

00:11:10,595 --> 00:11:13,760


00:11:13,760 --> 00:11:17,680
So what we have here is exactly the same two components.

00:11:17,680 --> 00:11:20,740
So the two templates here are identical.

00:11:20,740 --> 00:11:24,380
The only difference here is that the model, the talk model,

00:11:24,380 --> 00:11:26,900
is immutable.

00:11:26,900 --> 00:11:29,890
This gives us the following guarantee.

00:11:29,890 --> 00:11:33,060
That if the two instances are the same-- so

00:11:33,060 --> 00:11:37,010
if it is the same instance-- the title couldn't change.

00:11:37,010 --> 00:11:39,800
So it's true it's the same value.

00:11:39,800 --> 00:11:42,320
And therefore, if the talk component

00:11:42,320 --> 00:11:44,710
doesn't have any hidden state, it

00:11:44,710 --> 00:11:47,995
can change if, and only if, the instance is replaced.

00:11:47,995 --> 00:11:49,730
And therefore, if the object is not

00:11:49,730 --> 00:11:51,490
replaced, if it's the same instance,

00:11:51,490 --> 00:11:54,980
we can skip that component subtree altogether.

00:11:54,980 --> 00:11:59,190
So previously, in Angular 1, we cannot take advantage of this.

00:11:59,190 --> 00:12:02,560
And now, in Angular 2, we can.

00:12:02,560 --> 00:12:04,730
And since only a small fraction of your screen

00:12:04,730 --> 00:12:08,860
tend to change at once, it can result

00:12:08,860 --> 00:12:11,600
in huge performance benefits.

00:12:11,600 --> 00:12:16,030
For example, you won't have to check every single component

00:12:16,030 --> 00:12:19,250
in your graph, which can be thousands of components.

00:12:19,250 --> 00:12:21,940
If you use immutable objects, you

00:12:21,940 --> 00:12:24,250
check only the path that changed.

00:12:24,250 --> 00:12:27,610


00:12:27,610 --> 00:12:29,130
And you can do it declaratively.

00:12:29,130 --> 00:12:31,790
When you define a component, you can say that you depend only

00:12:31,790 --> 00:12:33,990
on immutable objects.

00:12:33,990 --> 00:12:37,010
We're still playing with API, trying to find the best one,

00:12:37,010 --> 00:12:38,770
the one that makes most sense.

00:12:38,770 --> 00:12:41,671
But the capability is already there.

00:12:41,671 --> 00:12:42,170
All right.

00:12:42,170 --> 00:12:44,110
What does it do to our time?

00:12:44,110 --> 00:12:46,820
How does it affect our time?

00:12:46,820 --> 00:12:51,610
That's what we had when we used only mutable objects.

00:12:51,610 --> 00:12:55,930
And N here is the total number of bindings as a system.

00:12:55,930 --> 00:13:01,100
If you use immutable objects, what you get is this formula.

00:13:01,100 --> 00:13:04,960
And M here is the number of changed bindings.

00:13:04,960 --> 00:13:11,870
And M will almost always be much smaller than N.

00:13:11,870 --> 00:13:14,560
But immutable objects are not the only ones

00:13:14,560 --> 00:13:18,170
that give us certain guarantees about how they change.

00:13:18,170 --> 00:13:20,240
Observable objects do it, too.

00:13:20,240 --> 00:13:23,800
They use some sort of push mechanism to tell you

00:13:23,800 --> 00:13:26,270
there's a new value that arrived.

00:13:26,270 --> 00:13:28,140
And here, I use the word observable

00:13:28,140 --> 00:13:29,099
in the broader sense.

00:13:29,099 --> 00:13:30,640
So it can be anything that can modify

00:13:30,640 --> 00:13:31,960
your [INAUDIBLE] changes.

00:13:31,960 --> 00:13:33,440
It can be Rx.

00:13:33,440 --> 00:13:35,450
It can be Backbone Models.

00:13:35,450 --> 00:13:39,600
It can be Knockout Models, or Object.observe.

00:13:39,600 --> 00:13:42,040
Let's see how it works.

00:13:42,040 --> 00:13:45,630
So what we have here is exactly the same tree of components.

00:13:45,630 --> 00:13:47,990
But this time, let's imagine that all our models

00:13:47,990 --> 00:13:51,630
in our application are observable.

00:13:51,630 --> 00:13:54,560
Observable objects are different from immutables in one

00:13:54,560 --> 00:13:56,290
very important way.

00:13:56,290 --> 00:13:59,150
When you use immutable objects, your change

00:13:59,150 --> 00:14:01,170
always comes from the root.

00:14:01,170 --> 00:14:02,910
So it has to come from the root.

00:14:02,910 --> 00:14:05,020
And that way, applications using immutable data

00:14:05,020 --> 00:14:06,550
tend to have global state.

00:14:06,550 --> 00:14:10,160
There's a push through the whole component every single time.

00:14:10,160 --> 00:14:13,120
That's not the case when you use observables.

00:14:13,120 --> 00:14:16,540
With observables, a change can come from anywhere.

00:14:16,540 --> 00:14:19,140
For example, the model of this component,

00:14:19,140 --> 00:14:21,150
the observable model of this component,

00:14:21,150 --> 00:14:24,190
can fire an event-- basically, notify

00:14:24,190 --> 00:14:26,440
this component about changes.

00:14:26,440 --> 00:14:29,550
The parent of this component doesn't see any changes.

00:14:29,550 --> 00:14:32,120
How do we handle it?

00:14:32,120 --> 00:14:35,950
What we do in Angular 2 when we encounter this situation,

00:14:35,950 --> 00:14:38,060
we are going to mark-- the whole path

00:14:38,060 --> 00:14:40,190
to the root has to be checked.

00:14:40,190 --> 00:14:43,590
So when change detection kicks in, it will walk this path,

00:14:43,590 --> 00:14:46,880
and will check all components along the way.

00:14:46,880 --> 00:14:51,380
And after it does it, the system gets stable again.

00:14:51,380 --> 00:14:52,480
So observables are great.

00:14:52,480 --> 00:14:53,930
They're very useful.

00:14:53,930 --> 00:14:56,900
But you may have one problem with observables,

00:14:56,900 --> 00:15:00,120
and the problem is called cascading updates.

00:15:00,120 --> 00:15:03,340
And what I mean by cascading updates is the following.

00:15:03,340 --> 00:15:06,840
Imagine an app that uses a lot of observable models.

00:15:06,840 --> 00:15:09,690
Now imagine one modifies an event.

00:15:09,690 --> 00:15:11,680
Let's say another model catches this event

00:15:11,680 --> 00:15:15,050
within the same [INAUDIBLE] and fires its own event.

00:15:15,050 --> 00:15:15,990
And it goes and goes.

00:15:15,990 --> 00:15:18,350
You have many models firing events.

00:15:18,350 --> 00:15:23,450
And along the way, views get updated or created.

00:15:23,450 --> 00:15:26,140
Such systems are very hard to reason about,

00:15:26,140 --> 00:15:28,910
because your application state propagation and view state

00:15:28,910 --> 00:15:32,250
propagation, they won't separate it.

00:15:32,250 --> 00:15:35,630
And so much depends on the runtime order of events,

00:15:35,630 --> 00:15:38,930
which you cannot see in your template, obviously.

00:15:38,930 --> 00:15:42,750
And also, such system tend to be not very performant.

00:15:42,750 --> 00:15:46,970
Because you have to re-render the same thing multiple times.

00:15:46,970 --> 00:15:48,778
So how do we deal with it in Angular 2?

00:15:48,778 --> 00:15:52,010


00:15:52,010 --> 00:15:54,140
Let's look at the situation.

00:15:54,140 --> 00:15:57,770
So let's say the model of this component fired an event,

00:15:57,770 --> 00:16:00,860
and we mark this spot has to be checked.

00:16:00,860 --> 00:16:03,330
Let's say some other component, like this guy,

00:16:03,330 --> 00:16:06,320
its model triggers an event.

00:16:06,320 --> 00:16:08,470
Maybe it's a result of the first event.

00:16:08,470 --> 00:16:11,810
And we mark this path has to be checked.

00:16:11,810 --> 00:16:15,860
Only now, only at this point, change detection will kick in

00:16:15,860 --> 00:16:18,440
and will go through the component graph.

00:16:18,440 --> 00:16:20,630
Only now the views are updated.

00:16:20,630 --> 00:16:24,675
Until this point, we were updating our application model,

00:16:24,675 --> 00:16:25,300
not view state.

00:16:25,300 --> 00:16:28,090


00:16:28,090 --> 00:16:29,880
What's also very important here is

00:16:29,880 --> 00:16:32,250
that, in order to have the guarantees I talked

00:16:32,250 --> 00:16:34,550
about a few minutes ago, where you can reason

00:16:34,550 --> 00:16:37,460
about your template statically, this guy

00:16:37,460 --> 00:16:41,850
has to be checked first and this guy second.

00:16:41,850 --> 00:16:44,400
And that's what happens when you use Angular 2.

00:16:44,400 --> 00:16:47,500


00:16:47,500 --> 00:16:49,980
So I won't say that Angular 2 completely eliminates

00:16:49,980 --> 00:16:51,880
the issue of cascading updates.

00:16:51,880 --> 00:16:54,020
Your application state propagation

00:16:54,020 --> 00:16:56,780
can still be as crazy as you want it to be.

00:16:56,780 --> 00:16:59,410
But view state propagation, which Angular is responsible

00:16:59,410 --> 00:17:04,780
for, we hope is as predictable as possible.

00:17:04,780 --> 00:17:08,819
So I talked a lot about immutables and observables,

00:17:08,819 --> 00:17:10,390
but I want to clarify that we are not

00:17:10,390 --> 00:17:14,400
forcing a particular type of model on you.

00:17:14,400 --> 00:17:18,740
Angular remains open to different types of models.

00:17:18,740 --> 00:17:22,319
The only thing we are trying to do is the following.

00:17:22,319 --> 00:17:25,040
If you happen to have an immutable model, because you

00:17:25,040 --> 00:17:27,260
like functional programming, for example,

00:17:27,260 --> 00:17:29,870
Angular can be much faster.

00:17:29,870 --> 00:17:32,080
If you happen to have an observable model because you

00:17:32,080 --> 00:17:35,980
like Rx, Angular again can be much faster.

00:17:35,980 --> 00:17:37,800
And the best part here is that you

00:17:37,800 --> 00:17:42,040
can combine different types of models in one application.

00:17:42,040 --> 00:17:45,180
For example, you can use immutable data for your facts

00:17:45,180 --> 00:17:48,845
and collection of facts, and observables for the data

00:17:48,845 --> 00:17:51,227
that comes from the backend.

00:17:51,227 --> 00:17:53,060
And they don't have to be layered like this.

00:17:53,060 --> 00:17:54,696
You can mix and match them.

00:17:54,696 --> 00:17:57,070
And Angular will take advantage of them performance-wise.

00:17:57,070 --> 00:17:59,600


00:17:59,600 --> 00:18:00,100
All right.

00:18:00,100 --> 00:18:02,890
So what we've learned so far is that we decreased

00:18:02,890 --> 00:18:04,970
the average time of checking a binding,

00:18:04,970 --> 00:18:09,110
or the performance of change detection got 10x better.

00:18:09,110 --> 00:18:12,010
We also give you more control over change detection.

00:18:12,010 --> 00:18:15,520
So you can actually tell it what you want to be checked

00:18:15,520 --> 00:18:17,269
and when.

00:18:17,269 --> 00:18:18,810
And we use the same mechanism that we

00:18:18,810 --> 00:18:22,775
give to you to take advantage of immutables and observables.

00:18:22,775 --> 00:18:27,200


00:18:27,200 --> 00:18:29,890
If you want to learn more, I recommend you check out

00:18:29,890 --> 00:18:31,890
the following resources.

00:18:31,890 --> 00:18:34,210
I wrote a few blog posts about change detection,

00:18:34,210 --> 00:18:36,010
immutable objects, observable objects,

00:18:36,010 --> 00:18:39,210
and functional programming in Angular.

00:18:39,210 --> 00:18:41,320
[INAUDIBLE] has an excellent blog

00:18:41,320 --> 00:18:45,720
about VMs, where he talks about polymorphism and monomorphism.

00:18:45,720 --> 00:18:47,100
I think you need to check it out.

00:18:47,100 --> 00:18:48,340
It's awesome.

00:18:48,340 --> 00:18:51,740
And finally, Jafar from Netflix gave an excellent talk

00:18:51,740 --> 00:18:53,060
about using RxJS.

00:18:53,060 --> 00:18:54,920
You should check it out.

00:18:54,920 --> 00:18:56,840
Thank you.


YouTube URL: https://www.youtube.com/watch?v=jvKGQSFQf10


