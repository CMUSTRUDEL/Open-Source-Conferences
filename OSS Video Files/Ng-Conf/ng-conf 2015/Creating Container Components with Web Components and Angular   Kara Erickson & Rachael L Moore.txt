Title: Creating Container Components with Web Components and Angular   Kara Erickson & Rachael L Moore
Publication date: 2015-03-05
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:03,416
[APPLAUSE]

00:00:03,416 --> 00:00:06,350


00:00:06,350 --> 00:00:09,670
RACHAEL L. MOORE: Rachel, who does not have her microphone.

00:00:09,670 --> 00:00:11,270
Hi, I'm Rachael.

00:00:11,270 --> 00:00:12,820
I'm the UI engineer at OpenTable.

00:00:12,820 --> 00:00:13,700
And this is Kara.

00:00:13,700 --> 00:00:16,230
She's a software engineer at OpenTable.

00:00:16,230 --> 00:00:18,210
We've spent the last several months

00:00:18,210 --> 00:00:22,580
with Web Components, Polymer, and most especially, Angular,

00:00:22,580 --> 00:00:24,400
building a library of user interface

00:00:24,400 --> 00:00:29,060
components for OpenTable's product guest center.

00:00:29,060 --> 00:00:32,870
Over the next 20 minutes, with mixed excitement and nostalgia,

00:00:32,870 --> 00:00:35,630
we'll take a little journey through combining user contact

00:00:35,630 --> 00:00:39,700
with pre-defined template of a container component, how

00:00:39,700 --> 00:00:43,580
Web Components standards add native functionality,

00:00:43,580 --> 00:00:48,150
techniques for pre-Web Component application using Angular 1.3,

00:00:48,150 --> 00:00:52,900
and the way that we'll work with Web Components in Angular 2.0.

00:00:52,900 --> 00:00:55,540
Since time immemorial, we web developers

00:00:55,540 --> 00:00:57,670
have employed templates and includes in order

00:00:57,670 --> 00:01:00,560
to reuse site-wide layouts, like this one

00:01:00,560 --> 00:01:05,170
here, on different pages without having to rewrite them.

00:01:05,170 --> 00:01:09,070
Long, long ago, we used server-side includes.

00:01:09,070 --> 00:01:12,950
Later, we used JavaScript template systems.

00:01:12,950 --> 00:01:15,810
But the more modern approach to the sort of code we use

00:01:15,810 --> 00:01:19,860
is to create a UI component, often linked to a custom tag,

00:01:19,860 --> 00:01:22,020
which ideally bootstraps all of the markup,

00:01:22,020 --> 00:01:24,680
scripts, and styles required, and which

00:01:24,680 --> 00:01:27,130
also acts as a declarative API.

00:01:27,130 --> 00:01:30,020
This is what we did for the OT site content container

00:01:30,020 --> 00:01:31,890
component.

00:01:31,890 --> 00:01:32,740
Why?

00:01:32,740 --> 00:01:36,530
Well, this is inspired by how native HTML elements work.

00:01:36,530 --> 00:01:38,710
For example, a native range input

00:01:38,710 --> 00:01:40,620
brings everything it needs for its appearance

00:01:40,620 --> 00:01:42,610
and functionality along with it.

00:01:42,610 --> 00:01:45,520
It also exposes a way to control relevant options,

00:01:45,520 --> 00:01:48,670
like min and max values.

00:01:48,670 --> 00:01:50,950
But a component like OT site is a layout

00:01:50,950 --> 00:01:53,620
scaffold with multiple content containers.

00:01:53,620 --> 00:01:56,140
So we needed more than attribute values.

00:01:56,140 --> 00:01:58,100
As component users, we need to insert

00:01:58,100 --> 00:02:01,980
our content-- big, old blocks of dynamic HTML--

00:02:01,980 --> 00:02:04,800
into the scaffold that OT site provides.

00:02:04,800 --> 00:02:07,550
This was a challenge that we faced with OT site.

00:02:07,550 --> 00:02:10,169
And, of course, there are a bunch of ways you can do this.

00:02:10,169 --> 00:02:14,580
But it turns out they have a lot in common, such as,

00:02:14,580 --> 00:02:17,560
first, let's put our component developer hats on

00:02:17,560 --> 00:02:20,590
and write the HTML that will be built into our OT site

00:02:20,590 --> 00:02:22,260
container.

00:02:22,260 --> 00:02:25,420
In this case, that's the head, the menu,

00:02:25,420 --> 00:02:27,733
and body, the containers in which we

00:02:27,733 --> 00:02:31,450
want to insert content, plus some static stuff that should

00:02:31,450 --> 00:02:36,920
be on every page, such as OpenTable's awesome new logo

00:02:36,920 --> 00:02:39,086
and the footer with copyright.

00:02:39,086 --> 00:02:39,940
AUDIENCE: Woo!

00:02:39,940 --> 00:02:43,880
RACHAEL L. MOORE: Then we have to mark, in some yet

00:02:43,880 --> 00:02:46,450
to be determined implementation-specific way,

00:02:46,450 --> 00:02:49,540
all those pre-designated insertion points.

00:02:49,540 --> 00:02:52,000
Now we're going to take off our component developer hats,

00:02:52,000 --> 00:02:55,060
and we're going to put on our component user hats.

00:02:55,060 --> 00:02:59,520
We have to add content to OT's site by nesting it inside.

00:02:59,520 --> 00:03:01,560
And since there are multiple insertion points,

00:03:01,560 --> 00:03:03,184
we're also going to have to label where

00:03:03,184 --> 00:03:05,400
the content should end up.

00:03:05,400 --> 00:03:08,020
Next, those two things are going to come together,

00:03:08,020 --> 00:03:10,750
and there'll be some tactic that each specific implementation

00:03:10,750 --> 00:03:12,810
will use to match up each insertion

00:03:12,810 --> 00:03:18,410
point to the left with its relevant content on the right.

00:03:18,410 --> 00:03:20,750
Finally, after matching everything,

00:03:20,750 --> 00:03:22,350
we're going to get a result.

00:03:22,350 --> 00:03:26,940
The combination of component template and user content

00:03:26,940 --> 00:03:27,850
will get rendered.

00:03:27,850 --> 00:03:31,040


00:03:31,040 --> 00:03:34,010
Web Components standards aim to provide this insertion point

00:03:34,010 --> 00:03:36,580
functionality natively.

00:03:36,580 --> 00:03:39,560
This hearkens back again to how native elements work.

00:03:39,560 --> 00:03:42,030
When we use the range input on a page, the markup we write

00:03:42,030 --> 00:03:43,910
is merely what we see on the screen.

00:03:43,910 --> 00:03:46,640
And we get rich functionality in return.

00:03:46,640 --> 00:03:48,530
This is what we're used to seeing.

00:03:48,530 --> 00:03:51,630
How it actually works, though, builds both on the DOM

00:03:51,630 --> 00:03:53,820
that we already had and already knew

00:03:53,820 --> 00:03:56,770
and a DOM that we didn't know we had.

00:03:56,770 --> 00:03:59,800
When we turn on Show user agent shadow DOM in Chrome Developer

00:03:59,800 --> 00:04:02,900
Tools, we can see a secret DOM.

00:04:02,900 --> 00:04:05,760
The plain old everyday element and the plain old everyday DOM

00:04:05,760 --> 00:04:09,220
tree actually has a hidden Shadow tree.

00:04:09,220 --> 00:04:11,440
So from now on, to keep things straight,

00:04:11,440 --> 00:04:13,680
let's call the DOM that we knew the light DOM.

00:04:13,680 --> 00:04:16,240


00:04:16,240 --> 00:04:18,690
And what exactly is this shadow tree?

00:04:18,690 --> 00:04:21,040
Well, it's a bit like a document fragment.

00:04:21,040 --> 00:04:23,650
However, unlike a typical document fragment,

00:04:23,650 --> 00:04:27,220
the shadow tree is a complete and totally encapsulated DOM.

00:04:27,220 --> 00:04:30,160
And it actually remains separate throughout its life

00:04:30,160 --> 00:04:33,620
in many practical ways, including encapsulating script

00:04:33,620 --> 00:04:36,380
and scoping styles.

00:04:36,380 --> 00:04:38,240
With the Web Component Standards support,

00:04:38,240 --> 00:04:40,540
we're able to create our own shadow trees.

00:04:40,540 --> 00:04:43,890
In order to do that, we actually still start in the light DOM

00:04:43,890 --> 00:04:47,950
with an element to play host to our new shadow tree.

00:04:47,950 --> 00:04:50,500
To illustrate, we'll use the span in the light DOM

00:04:50,500 --> 00:04:54,080
with the ID myspan.

00:04:54,080 --> 00:04:56,090
In order to make myspan a shadow host,

00:04:56,090 --> 00:04:59,520
we have to create a shadow root on the span.

00:04:59,520 --> 00:05:01,460
The shadow DOM specification defines

00:05:01,460 --> 00:05:05,750
a createShadowRoot method, which does exactly that.

00:05:05,750 --> 00:05:10,200
So we'll just grab our span and employ the method.

00:05:10,200 --> 00:05:13,340
That's really all that it takes to give myspan a shadow root.

00:05:13,340 --> 00:05:15,500
And the result is something like this.

00:05:15,500 --> 00:05:17,890
From this point on, any light DOM descendants

00:05:17,890 --> 00:05:21,790
of our gracious shadow host won't render.

00:05:21,790 --> 00:05:25,620
So that sentence that's wrapped in myspan is missing now.

00:05:25,620 --> 00:05:28,610
You may be wondering how that could possibly be useful.

00:05:28,610 --> 00:05:31,180
Well, now that we have one, we can add elements

00:05:31,180 --> 00:05:31,990
to the shadow DOM.

00:05:31,990 --> 00:05:34,800
And those will render.

00:05:34,800 --> 00:05:37,300
That means that we can implement our OT site container,

00:05:37,300 --> 00:05:39,160
just as we outlined earlier, starting

00:05:39,160 --> 00:05:42,299
by appending its template to our shadow root.

00:05:42,299 --> 00:05:44,590
We could dress this up with more Web Component goodies,

00:05:44,590 --> 00:05:47,040
but for now, we'll stick with the bare essentials,

00:05:47,040 --> 00:05:51,370
and we'll set the template on the shadow root's inner HTML.

00:05:51,370 --> 00:05:55,260
So by the way, see those back ticks?

00:05:55,260 --> 00:05:58,520
That's an ECMAScript 6 feature, template strings.

00:05:58,520 --> 00:06:00,730
When we use those, we don't have to escape quotes

00:06:00,730 --> 00:06:02,370
in our OT site template.

00:06:02,370 --> 00:06:03,610
And we can use line breaks.

00:06:03,610 --> 00:06:05,790
It's just a lot less noisy on our slides.

00:06:05,790 --> 00:06:08,580
And it's very convenient for inlined HTML.

00:06:08,580 --> 00:06:12,200
So now that we've added the OT site template to our shadow

00:06:12,200 --> 00:06:18,160
DOM, if we also add styles the same way,

00:06:18,160 --> 00:06:20,810
this is the composite DOM we've actually created.

00:06:20,810 --> 00:06:24,160
OT site is in the light DOM, and it hosts a shadow root

00:06:24,160 --> 00:06:27,140
that contains that template.

00:06:27,140 --> 00:06:30,710
As a result, this is what we get when we use the OT site tag.

00:06:30,710 --> 00:06:34,270
We get six tags, a logo, and styles

00:06:34,270 --> 00:06:37,590
for the price of one tag.

00:06:37,590 --> 00:06:40,520
But we still need to be able to add our content.

00:06:40,520 --> 00:06:44,100
So let's deal with these placeholders.

00:06:44,100 --> 00:06:46,540
When we're implementing with the shadow DOM,

00:06:46,540 --> 00:06:48,350
we can use the content tag.

00:06:48,350 --> 00:06:51,630
A content element creates a content insertion point,

00:06:51,630 --> 00:06:54,800
a place where elements from our light DOM can appear.

00:06:54,800 --> 00:06:56,270
Content insertion points are how we

00:06:56,270 --> 00:06:58,580
can fill the containers in our template

00:06:58,580 --> 00:07:00,570
with dynamic, user-defined HTML.

00:07:00,570 --> 00:07:03,230


00:07:03,230 --> 00:07:05,710
But we have multiple insertion points.

00:07:05,710 --> 00:07:07,440
And somebody thought of that.

00:07:07,440 --> 00:07:09,896
The content tag has a Select attribute.

00:07:09,896 --> 00:07:11,270
The value of the Select attribute

00:07:11,270 --> 00:07:13,460
is a CSS selector used to specify

00:07:13,460 --> 00:07:17,630
which parts of the light DOM can appear at each insertion point.

00:07:17,630 --> 00:07:20,620
Here, we've defined some attribute selectors.

00:07:20,620 --> 00:07:23,065
In the header, for example, this will

00:07:23,065 --> 00:07:25,570
match any light DOM children of OT site

00:07:25,570 --> 00:07:28,760
that have the head attribute name.

00:07:28,760 --> 00:07:31,850
So now we'll be component users again.

00:07:31,850 --> 00:07:34,480
We need to add the attributes we defined in the component

00:07:34,480 --> 00:07:37,030
to our content as well, in order to label

00:07:37,030 --> 00:07:39,990
the appropriate destination for each div.

00:07:39,990 --> 00:07:43,230
We just add, for example, the attribute name head

00:07:43,230 --> 00:07:47,990
on the div that should display in the header of OT site.

00:07:47,990 --> 00:07:50,400
Next is the matching step.

00:07:50,400 --> 00:07:52,220
But since this functionality is native,

00:07:52,220 --> 00:07:54,040
we don't have to deal with this ourselves.

00:07:54,040 --> 00:07:56,170
As long as we didn't make any typos,

00:07:56,170 --> 00:07:59,420
the insertion points defined in the component on the left will

00:07:59,420 --> 00:08:02,130
be merged with the appropriately labelled user content

00:08:02,130 --> 00:08:05,210
on the right.

00:08:05,210 --> 00:08:08,520
Which brings us to the result and to a very important thing

00:08:08,520 --> 00:08:11,220
to keep in mind when using the shadow DOM.

00:08:11,220 --> 00:08:14,310
Things only render as if the light DOM and the shadow DOM

00:08:14,310 --> 00:08:15,470
are combined.

00:08:15,470 --> 00:08:17,200
What is actually occurring is something

00:08:17,200 --> 00:08:20,660
that people are calling content projection.

00:08:20,660 --> 00:08:23,240
The user's light DOM content is projected,

00:08:23,240 --> 00:08:25,080
like a movie onto the big screen,

00:08:25,080 --> 00:08:28,500
onto the insertion point, which makes it render in some ways

00:08:28,500 --> 00:08:30,170
as if it were there.

00:08:30,170 --> 00:08:31,410
But it isn't.

00:08:31,410 --> 00:08:34,789
For most purposes, like script execution context, events,

00:08:34,789 --> 00:08:38,020
and styles, the user stuff is still in the light DOM,

00:08:38,020 --> 00:08:40,049
and the components stuff is still

00:08:40,049 --> 00:08:42,460
totally isolated in the shadow DOM--

00:08:42,460 --> 00:08:44,940
almost as if they're each processed separately

00:08:44,940 --> 00:08:47,530
before ever rendering together.

00:08:47,530 --> 00:08:50,550
So say we had a style in the light DOM that

00:08:50,550 --> 00:08:52,050
made the text red.

00:08:52,050 --> 00:08:54,260
What happens?

00:08:54,260 --> 00:08:55,639
We get red text.

00:08:55,639 --> 00:08:57,597
Regardless of the rules in the shadow DOM style

00:08:57,597 --> 00:09:00,940
sheet, how specific the selectors are--

00:09:00,940 --> 00:09:03,160
because the text does not move.

00:09:03,160 --> 00:09:04,730
The text is still in the light DOM.

00:09:04,730 --> 00:09:07,670
And it can still get styles from the light DOM style sheet.

00:09:07,670 --> 00:09:09,852
It doesn't inherit from the shadow DOM style sheet

00:09:09,852 --> 00:09:11,810
quite the way that it would if we were actually

00:09:11,810 --> 00:09:14,160
appending a document fragment.

00:09:14,160 --> 00:09:16,480
But, by the same token, the red rule

00:09:16,480 --> 00:09:21,440
doesn't affect our text in the shadow DOM like the copyright.

00:09:21,440 --> 00:09:25,520
Removing the red, however, shows how content projection gives us

00:09:25,520 --> 00:09:28,670
exactly what we were looking for, but with the extra added

00:09:28,670 --> 00:09:32,030
benefits of shadow DOM's encapsulation and style

00:09:32,030 --> 00:09:33,390
scoping.

00:09:33,390 --> 00:09:36,330
And that covers the process of implementing the OT site

00:09:36,330 --> 00:09:40,080
container using Web Components and native functionality.

00:09:40,080 --> 00:09:43,572
Now I'll hand over to Kara, who will talk about Angular.

00:09:43,572 --> 00:09:47,044
[APPLAUSE]

00:09:47,044 --> 00:09:50,020


00:09:50,020 --> 00:09:51,840
KARA ERICKSON: Hi, everyone.

00:09:51,840 --> 00:09:54,190
So now that we've built the OT site Web Component,

00:09:54,190 --> 00:09:56,070
I'll show you how to achieve the same effect

00:09:56,070 --> 00:09:58,250
with a normal Angular 1.3 directive.

00:09:58,250 --> 00:10:00,220
So to understand how that works, we're

00:10:00,220 --> 00:10:03,150
going to build it together from scratch.

00:10:03,150 --> 00:10:06,190
So I started us out with a basic directive definition.

00:10:06,190 --> 00:10:08,780
At this point, it only has a name, OT site.

00:10:08,780 --> 00:10:12,769
So let's get started by adding a template.

00:10:12,769 --> 00:10:15,310
We'll use a similar template as we did for our Web Component,

00:10:15,310 --> 00:10:20,800
with our three empty sections and our static logo and footer.

00:10:20,800 --> 00:10:23,006
The template alone will get us this empty container.

00:10:23,006 --> 00:10:24,380
But the challenging part is still

00:10:24,380 --> 00:10:26,490
ahead-- finding a way for component users

00:10:26,490 --> 00:10:28,040
to pass in their content.

00:10:28,040 --> 00:10:30,320
So how can we do that?

00:10:30,320 --> 00:10:34,910
In Angular 1.3, we can use the strategy called transclusion.

00:10:34,910 --> 00:10:37,180
Transclusion in Angular allows component users

00:10:37,180 --> 00:10:39,810
to pass an HTML template into a directive

00:10:39,810 --> 00:10:42,234
by inserting it between the directive's tags.

00:10:42,234 --> 00:10:43,900
That user template will then be appended

00:10:43,900 --> 00:10:46,824
to some part of the directive's internal template.

00:10:46,824 --> 00:10:48,990
You'll notice that the markup for the component user

00:10:48,990 --> 00:10:51,820
is similar to the markup that we used for Web Components.

00:10:51,820 --> 00:10:53,320
The distinguishing part for Angular,

00:10:53,320 --> 00:10:55,150
given Angular's concept of scope,

00:10:55,150 --> 00:10:57,510
is that the user's template maintains a connection

00:10:57,510 --> 00:10:59,670
to the original scope from which it came.

00:10:59,670 --> 00:11:03,849
So any Angular bindings the user adds will work as expected.

00:11:03,849 --> 00:11:06,140
So how do we wire up this transclusion on the directive

00:11:06,140 --> 00:11:07,282
side?

00:11:07,282 --> 00:11:08,740
Well, the first thing we have to do

00:11:08,740 --> 00:11:10,198
is indicate to Angular that we will

00:11:10,198 --> 00:11:14,900
be transcluding by setting the transclude property to true.

00:11:14,900 --> 00:11:17,320
This is necessary because during the compilation phase,

00:11:17,320 --> 00:11:18,960
the default behavior for Angular is

00:11:18,960 --> 00:11:22,330
to replace anything between the directives tags

00:11:22,330 --> 00:11:24,710
with the directives' internal template, which

00:11:24,710 --> 00:11:25,970
normally would make sense.

00:11:25,970 --> 00:11:27,460
But in this case, it would actually

00:11:27,460 --> 00:11:30,390
overwrite our user's content.

00:11:30,390 --> 00:11:34,090
However, when you set transclude to true, the process changes.

00:11:34,090 --> 00:11:36,480
When Angular begins to compile the OT site directive,

00:11:36,480 --> 00:11:38,880
it won't add the directive template right away.

00:11:38,880 --> 00:11:42,214
Instead, it will first save a clone of the user's content.

00:11:42,214 --> 00:11:43,755
Only then will it empty the directive

00:11:43,755 --> 00:11:46,440
and add the directive's template.

00:11:46,440 --> 00:11:49,750
So we still have access to the clone.

00:11:49,750 --> 00:11:51,240
So we've set transclude to true.

00:11:51,240 --> 00:11:53,190
How do we actually set the insertion points

00:11:53,190 --> 00:11:54,580
for our content?

00:11:54,580 --> 00:11:56,360
Well, if we were creating a Web Component,

00:11:56,360 --> 00:11:59,660
this is simply where we'd add content tags.

00:11:59,660 --> 00:12:02,110
Angular 1.3's rough equivalent to a content tag

00:12:02,110 --> 00:12:05,450
is a core Angular directive called ng-transclude.

00:12:05,450 --> 00:12:09,710
But ng-transclude won't get us quite there.

00:12:09,710 --> 00:12:11,970
It's really intended for basic transclusion,

00:12:11,970 --> 00:12:16,220
so it doesn't have a concept of Select the way

00:12:16,220 --> 00:12:18,110
that Web Component tags do.

00:12:18,110 --> 00:12:20,650
Consequently, it will always attach the entire block

00:12:20,650 --> 00:12:23,040
of user content to its element, which would leave us

00:12:23,040 --> 00:12:24,680
with something like this.

00:12:24,680 --> 00:12:27,020
So given that we need the ability to treat

00:12:27,020 --> 00:12:29,230
different parts of the clone in different ways,

00:12:29,230 --> 00:12:30,910
we'll have to wire up our own custom

00:12:30,910 --> 00:12:33,350
transclusion functionality.

00:12:33,350 --> 00:12:37,340
So instead of ng-transclude, let's set

00:12:37,340 --> 00:12:39,170
our own version of the Select attribute--

00:12:39,170 --> 00:12:42,380
a transclude ID that will serve as the label for each section,

00:12:42,380 --> 00:12:45,740
abbreviated here as TID, for space.

00:12:45,740 --> 00:12:47,400
And then from the component user's end,

00:12:47,400 --> 00:12:49,580
we just need to add the corresponding labels.

00:12:49,580 --> 00:12:51,990
How about a transclude-to attribute abbreviated to t-to?

00:12:51,990 --> 00:12:54,540


00:12:54,540 --> 00:12:56,190
So now that we have our labels, we

00:12:56,190 --> 00:12:58,170
have everything that we need to start matching.

00:12:58,170 --> 00:13:00,170
So let's visualize the process and start writing

00:13:00,170 --> 00:13:03,214
the code together line by line.

00:13:03,214 --> 00:13:04,630
So to do this matching, we'll want

00:13:04,630 --> 00:13:06,240
to go through every element in the clone,

00:13:06,240 --> 00:13:08,531
because we know that the user wants every element to be

00:13:08,531 --> 00:13:10,470
attached somewhere to the DOM.

00:13:10,470 --> 00:13:12,572
So for each element, first we need

00:13:12,572 --> 00:13:14,030
to grab the value of that element's

00:13:14,030 --> 00:13:15,480
transclude-to attribute.

00:13:15,480 --> 00:13:19,080
That will give us the ID of our target element.

00:13:19,080 --> 00:13:21,580
Then we need to find the element in the directive's template

00:13:21,580 --> 00:13:25,780
whose TID property matches that ID.

00:13:25,780 --> 00:13:28,977
Lastly, we need to append the clone element to its target.

00:13:28,977 --> 00:13:29,560
And that's it.

00:13:29,560 --> 00:13:31,412
It's pretty straightforward.

00:13:31,412 --> 00:13:33,120
So if we look at the consolidated version

00:13:33,120 --> 00:13:37,790
of the code that we just wrote, line by line, here it is.

00:13:37,790 --> 00:13:39,970
So aside from some error-checking and validation,

00:13:39,970 --> 00:13:43,490
this is all the processing that we have to do.

00:13:43,490 --> 00:13:46,230
So we've been assuming access to a clone variable that

00:13:46,230 --> 00:13:47,750
represents the user's content.

00:13:47,750 --> 00:13:49,740
So how do we even get that?

00:13:49,740 --> 00:13:52,400
Well, the answer is something called the transclude function.

00:13:52,400 --> 00:13:54,750
The transclude function is a special linking function

00:13:54,750 --> 00:13:58,210
that becomes available as soon as you set transclude to true.

00:13:58,210 --> 00:14:01,060
It takes a callback function that has access to that clone,

00:14:01,060 --> 00:14:03,190
and you can do any DOM manipulation or processing

00:14:03,190 --> 00:14:04,231
you need in that context.

00:14:04,231 --> 00:14:06,860


00:14:06,860 --> 00:14:08,460
So the transclude function actually

00:14:08,460 --> 00:14:10,710
services in three different locations in the directive

00:14:10,710 --> 00:14:12,840
definition-- the compile function, the controller,

00:14:12,840 --> 00:14:14,330
and the link function.

00:14:14,330 --> 00:14:16,842
So which one do you use?

00:14:16,842 --> 00:14:18,550
Well, the first thing to know is that not

00:14:18,550 --> 00:14:20,449
all transclude functions are the same.

00:14:20,449 --> 00:14:22,740
The transclude function that's passed to you in compile

00:14:22,740 --> 00:14:24,739
is actually different than the one passed to you

00:14:24,739 --> 00:14:26,110
in the controller and link.

00:14:26,110 --> 00:14:28,390
Unlike the latter two, the correct transclusion scope

00:14:28,390 --> 00:14:31,240
isn't auto-generated for you or linked for you.

00:14:31,240 --> 00:14:34,752
So at best, you can only get it to work with broken bindings.

00:14:34,752 --> 00:14:36,710
For this reason, the compile function's version

00:14:36,710 --> 00:14:38,960
of transclude is actually deprecated,

00:14:38,960 --> 00:14:40,460
which leaves us with the latter two.

00:14:40,460 --> 00:14:44,050
How do we choose, and what's the difference?

00:14:44,050 --> 00:14:45,820
Mostly, it's execution order.

00:14:45,820 --> 00:14:48,210
So the controller of the parent directive

00:14:48,210 --> 00:14:51,170
will be instantiated before its child directives are linked.

00:14:51,170 --> 00:14:53,200
This is why controllers are ideal for directive

00:14:53,200 --> 00:14:54,260
communication.

00:14:54,260 --> 00:14:56,950
The parent can define any shared methods or scope properties

00:14:56,950 --> 00:15:00,010
before the child directives will ever need to use them.

00:15:00,010 --> 00:15:02,520
But this order isn't great for DOM manipulation.

00:15:02,520 --> 00:15:05,530
If you try to manipulate the DOM before the child directives are

00:15:05,530 --> 00:15:07,157
linked, the compiler's linking function

00:15:07,157 --> 00:15:08,990
might have some trouble finding the children

00:15:08,990 --> 00:15:10,510
to link them properly.

00:15:10,510 --> 00:15:13,260
So generally speaking, the best practice for DOM manipulation

00:15:13,260 --> 00:15:14,870
is to use the link function, also

00:15:14,870 --> 00:15:17,520
known as the post-link function, because the parent directive's

00:15:17,520 --> 00:15:20,105
post-link function will run after the child directives have

00:15:20,105 --> 00:15:22,960
already been found and linked.

00:15:22,960 --> 00:15:25,210
So we really want to use the link function's version

00:15:25,210 --> 00:15:27,880
of transclude here.

00:15:27,880 --> 00:15:30,330
So if we go ahead and add a link function

00:15:30,330 --> 00:15:31,920
and paste in all the custom processing

00:15:31,920 --> 00:15:35,590
that we already wrote, oops, that

00:15:35,590 --> 00:15:36,970
gets us most of the way there.

00:15:36,970 --> 00:15:40,550
So the last thing we have to do to make this a viable component

00:15:40,550 --> 00:15:44,140
is to set the appropriate scope.

00:15:44,140 --> 00:15:45,994
The obvious choice for a reusable component

00:15:45,994 --> 00:15:48,410
is to use an isolate scope to keep it completely insulated

00:15:48,410 --> 00:15:49,690
from its environment.

00:15:49,690 --> 00:15:51,770
But how will this affect the user's template?

00:15:51,770 --> 00:15:53,610
How can you have a transcluding directive

00:15:53,610 --> 00:15:56,671
that also has isolate scope?

00:15:56,671 --> 00:15:58,880
If we take a look at the scope diagram here,

00:15:58,880 --> 00:16:00,990
we can see how this kind of works together.

00:16:00,990 --> 00:16:04,290
So on the left here, we have the DOM hierarchy

00:16:04,290 --> 00:16:06,830
that we've created, color-coded by scope.

00:16:06,830 --> 00:16:08,220
And then on the right over there,

00:16:08,220 --> 00:16:11,670
we have the matching scopes organized by encapsulation.

00:16:11,670 --> 00:16:13,570
So we can already see that there are actually

00:16:13,570 --> 00:16:16,480
two scopes associated with our OT site directive.

00:16:16,480 --> 00:16:18,450
We have the directive template scope,

00:16:18,450 --> 00:16:21,110
represented by the orange OT site tags,

00:16:21,110 --> 00:16:24,600
and the scope for the user's content represented by the grey

00:16:24,600 --> 00:16:25,740
divs.

00:16:25,740 --> 00:16:28,840
So the directive's template is actually

00:16:28,840 --> 00:16:31,480
completely isolated from all of the other scopes,

00:16:31,480 --> 00:16:33,895
as you can see with the box isolated on the bottom.

00:16:33,895 --> 00:16:35,770
And that's great because that's what we want.

00:16:35,770 --> 00:16:37,820
We want it to have no leaks.

00:16:37,820 --> 00:16:40,410
But the user's content is actually

00:16:40,410 --> 00:16:42,472
a child of its outer scope, the controller,

00:16:42,472 --> 00:16:43,930
so that it can inherit any bindings

00:16:43,930 --> 00:16:46,450
that it might want to use in its template directly

00:16:46,450 --> 00:16:47,740
from the controller.

00:16:47,740 --> 00:16:51,290
So this would absolutely work, which leads us

00:16:51,290 --> 00:16:54,700
to the final version of our code, which

00:16:54,700 --> 00:16:59,080
will get us the same output that we got with Web Components.

00:16:59,080 --> 00:17:01,130
So how about Angular 2.0?

00:17:01,130 --> 00:17:04,010
Does it make the process we just outlined any easier?

00:17:04,010 --> 00:17:06,690
The short answer is yes, absolutely.

00:17:06,690 --> 00:17:09,480
Angular 2.0 has the concept of component directives, which are

00:17:09,480 --> 00:17:11,329
built on top of Web Components.

00:17:11,329 --> 00:17:13,339
And so component directives combine the best

00:17:13,339 --> 00:17:16,349
of both worlds-- Web Component standards and the advantages

00:17:16,349 --> 00:17:18,990
of Angular-- bindings, dependency injection, and so

00:17:18,990 --> 00:17:21,280
on.

00:17:21,280 --> 00:17:23,829
There are a few differences between Angular 1.3 directives

00:17:23,829 --> 00:17:26,520
and Angular 2 component directives.

00:17:26,520 --> 00:17:31,540
First, in Angular 1.3, component authors had to use transclusion

00:17:31,540 --> 00:17:34,420
to insert custom content.

00:17:34,420 --> 00:17:36,350
In Angular 2, the concept of transclusion

00:17:36,350 --> 00:17:37,790
is no longer necessary.

00:17:37,790 --> 00:17:40,460
Because component directives are built on top of Web Components,

00:17:40,460 --> 00:17:43,110
we can simply use the built-in Web Component functionality,

00:17:43,110 --> 00:17:45,269
even with multiple insertion points.

00:17:45,269 --> 00:17:47,060
What this means for our Directives template

00:17:47,060 --> 00:17:48,650
is that we can replace our custom

00:17:48,650 --> 00:17:52,967
TID attributes with the more powerful content

00:17:52,967 --> 00:17:54,800
tags that are modified by Select attributes.

00:17:54,800 --> 00:17:57,990


00:17:57,990 --> 00:18:00,330
So Web Components will be doing most of the work for us

00:18:00,330 --> 00:18:01,150
natively.

00:18:01,150 --> 00:18:04,440
So all that extra processing, like the transclude function

00:18:04,440 --> 00:18:08,925
and the transclude flag, aren't necessary to define.

00:18:08,925 --> 00:18:11,320
In Angular 1.3, another conceptual hurdle

00:18:11,320 --> 00:18:13,226
is understanding scope.

00:18:13,226 --> 00:18:14,600
As we saw in this diagram, we had

00:18:14,600 --> 00:18:16,933
to think about transcluding scopes versus isolate scope,

00:18:16,933 --> 00:18:20,470
and how they interact, and-- ah, complicated.

00:18:20,470 --> 00:18:22,434
But Angular 2 provides some sensible defaults,

00:18:22,434 --> 00:18:24,600
depending on what type of directive you're creating,

00:18:24,600 --> 00:18:26,969
which reduces much of that uncertainty.

00:18:26,969 --> 00:18:28,760
So if you're writing a component directive,

00:18:28,760 --> 00:18:31,090
it will have a completely isolated execution context

00:18:31,090 --> 00:18:32,186
by default.

00:18:32,186 --> 00:18:33,560
You don't have to set it yourself

00:18:33,560 --> 00:18:34,940
or even understand the full scope

00:18:34,940 --> 00:18:36,590
hierarchy if you don't want to.

00:18:36,590 --> 00:18:38,730
Additionally, if you elect to use content tags

00:18:38,730 --> 00:18:40,640
to allow user-provided templates,

00:18:40,640 --> 00:18:42,620
your bindings will still work.

00:18:42,620 --> 00:18:46,080
So at this point, if we remove all the unnecessary code,

00:18:46,080 --> 00:18:49,020
you can see that the only configuration we really need

00:18:49,020 --> 00:18:53,160
is the name and the temple itself, which is pretty cool.

00:18:53,160 --> 00:18:55,930
So the only thing left to do to convert this to a true Angular

00:18:55,930 --> 00:18:59,020
2 directive is to update the registration syntax.

00:18:59,020 --> 00:19:01,650
So in Angular 1.3, to register a directive,

00:19:01,650 --> 00:19:05,130
we had a somewhat cumbersome directive definition object.

00:19:05,130 --> 00:19:07,540
We have to call a directive function, to which we

00:19:07,540 --> 00:19:10,580
pass a factory function that returns an object that

00:19:10,580 --> 00:19:12,560
contains everything we ever want to associate

00:19:12,560 --> 00:19:14,570
with this directive.

00:19:14,570 --> 00:19:16,060
Instead of this one large config,

00:19:16,060 --> 00:19:17,930
Angular 2 provides a simpler interface

00:19:17,930 --> 00:19:20,330
for component authors, splitting the definition out

00:19:20,330 --> 00:19:22,510
into two logical parts-- the component class

00:19:22,510 --> 00:19:25,607
and its metadata annotations.

00:19:25,607 --> 00:19:27,190
The first half of creating a directive

00:19:27,190 --> 00:19:28,821
is defining the component class.

00:19:28,821 --> 00:19:30,570
It controls the component's business logic

00:19:30,570 --> 00:19:33,890
and can expose a public API for other components.

00:19:33,890 --> 00:19:36,004
Here we have to find it using ES6 class syntax,

00:19:36,004 --> 00:19:37,420
but you can achieve the same thing

00:19:37,420 --> 00:19:40,727
with ES5 using a normal constructor function.

00:19:40,727 --> 00:19:42,560
So normally, there would be methods in here,

00:19:42,560 --> 00:19:45,830
but as our OT site directive is an inert scaffold,

00:19:45,830 --> 00:19:47,800
we actually don't need any methods.

00:19:47,800 --> 00:19:51,250
What we do need is to record those two pieces of metadata,

00:19:51,250 --> 00:19:53,480
which brings us to the second half of our definition,

00:19:53,480 --> 00:19:55,580
annotations.

00:19:55,580 --> 00:19:57,180
Since we're using ES6, which doesn't

00:19:57,180 --> 00:19:59,040
have a native concept of annotations,

00:19:59,040 --> 00:20:00,910
we simply set a static property on the class

00:20:00,910 --> 00:20:04,750
called annotations, and Angular will pick it up.

00:20:04,750 --> 00:20:06,750
By annotating our OT site class, we

00:20:06,750 --> 00:20:09,730
can succinctly indicate the class's intent-- in this case,

00:20:09,730 --> 00:20:12,424
that we're building a component directive.

00:20:12,424 --> 00:20:14,840
And further, we can indicate that this component directive

00:20:14,840 --> 00:20:17,234
is identified by the OT site tag.

00:20:17,234 --> 00:20:18,900
You'll notice that we're no longer using

00:20:18,900 --> 00:20:20,140
a normalized directive name.

00:20:20,140 --> 00:20:23,940
And we can simply use a CSS selector.

00:20:23,940 --> 00:20:25,580
Lastly, we can associate our component

00:20:25,580 --> 00:20:27,510
with a certain template.

00:20:27,510 --> 00:20:29,930
So at this point, our code is actually fully functional,

00:20:29,930 --> 00:20:31,240
and the component will work.

00:20:31,240 --> 00:20:33,200
But we can make the code even cleaner.

00:20:33,200 --> 00:20:34,860
If we were to convert this to AtScript

00:20:34,860 --> 00:20:39,520
or, I guess, TypeScript now, we get even more syntactic sugar.

00:20:39,520 --> 00:20:41,770
We don't have to manually set the annotations property

00:20:41,770 --> 00:20:43,810
anymore because that's native.

00:20:43,810 --> 00:20:47,382
And we can simply annotate using the At shorthand.

00:20:47,382 --> 00:20:48,840
Lastly, we can move the metadata up

00:20:48,840 --> 00:20:50,300
to the top of the definition, so you

00:20:50,300 --> 00:20:52,508
don't have to scroll through all your class code just

00:20:52,508 --> 00:20:55,010
to see the selector and the associated template.

00:20:55,010 --> 00:20:55,757
And that's it.

00:20:55,757 --> 00:20:57,340
That's all you need to do in Angular 2

00:20:57,340 --> 00:20:59,360
to implement the container.

00:20:59,360 --> 00:21:00,840
So you get the same output.

00:21:00,840 --> 00:21:02,490
So that's it.

00:21:02,490 --> 00:21:03,390
Thank you.

00:21:03,390 --> 00:21:06,740
[APPLAUSE]


YouTube URL: https://www.youtube.com/watch?v=AbunztfV5vU


