Title: Binding to the Cloud with Falcor   Jafar Husain
Publication date: 2015-03-06
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:00,100


00:00:00,100 --> 00:00:01,110
Can you hear me?

00:00:01,110 --> 00:00:04,080


00:00:04,080 --> 00:00:07,420
Wow, exciting prizes.

00:00:07,420 --> 00:00:10,774
So I want to thank the Angular folks for having me here

00:00:10,774 --> 00:00:11,620
to talk to you.

00:00:11,620 --> 00:00:14,390
I'm going to talk to you today about a library called Falcore.

00:00:14,390 --> 00:00:17,060
Now every user out there wants to believe

00:00:17,060 --> 00:00:20,370
that all the data out there in the cloud is on their device.

00:00:20,370 --> 00:00:22,120
I mean, if you think about it, that's kind

00:00:22,120 --> 00:00:24,800
of what our job as web developers is to do.

00:00:24,800 --> 00:00:26,250
It's like 80% of our job.

00:00:26,250 --> 00:00:27,850
Is kind of like a conjuring trick.

00:00:27,850 --> 00:00:28,760
They request data.

00:00:28,760 --> 00:00:30,200
We go and get it from the network.

00:00:30,200 --> 00:00:34,070
We make it feel to them like it's sitting right there.

00:00:34,070 --> 00:00:35,905
But what if you could code that way?

00:00:35,905 --> 00:00:38,030
What if you could code as if all the data out there

00:00:38,030 --> 00:00:40,350
on the network was sitting right there on the device

00:00:40,350 --> 00:00:42,930
and you didn't have to worry about the network at all.

00:00:42,930 --> 00:00:44,020
My name is Jafar Husain.

00:00:44,020 --> 00:00:46,690
I'm Netflix's Cross-Team tech UI lead.

00:00:46,690 --> 00:00:47,900
I'm an architect of Falcore.

00:00:47,900 --> 00:00:49,880
And I want you guys to ask yourself a question.

00:00:49,880 --> 00:00:52,171
I want us to do a little soul searching together today.

00:00:52,171 --> 00:00:56,742
And that is does MVC really separate concerns?

00:00:56,742 --> 00:00:58,950
Now I look out, and I see a lot of Angular developers

00:00:58,950 --> 00:00:59,450
out there.

00:00:59,450 --> 00:01:02,980
And there's a lot MVC users, no doubt.

00:01:02,980 --> 00:01:04,400
Let's take a look at an ideal look

00:01:04,400 --> 00:01:05,740
at how MVC is supposed to work.

00:01:05,740 --> 00:01:06,820
I've got a controller.

00:01:06,820 --> 00:01:08,330
And it's responsible for marshaling

00:01:08,330 --> 00:01:12,280
the model from the cloud and handing it to the view.

00:01:12,280 --> 00:01:14,380
And the view can act like sort of like a black box

00:01:14,380 --> 00:01:17,382
and then take that model and output HTML5.

00:01:17,382 --> 00:01:18,090
That's the ideal.

00:01:18,090 --> 00:01:20,602
That's sort of a uni-directional flow.

00:01:20,602 --> 00:01:23,090
It doesn't really work out like that, though.

00:01:23,090 --> 00:01:23,650
Let's see.

00:01:23,650 --> 00:01:24,774
Let's actually test it out.

00:01:24,774 --> 00:01:26,860
Let's see how we would work this into Netflix.

00:01:26,860 --> 00:01:31,445
Now how many Netflix customers we got out there, people?

00:01:31,445 --> 00:01:31,945
Yes!

00:01:31,945 --> 00:01:33,570
I saw one guy in the back who didn't put his hands up.

00:01:33,570 --> 00:01:35,900
So I'm just going to explain to you how Netflix works.

00:01:35,900 --> 00:01:39,320
We are a video service, and we personalize recommendations

00:01:39,320 --> 00:01:39,880
to you.

00:01:39,880 --> 00:01:42,550
And so you can go ahead a select a title, like "House of Cards,"

00:01:42,550 --> 00:01:43,390
for example.

00:01:43,390 --> 00:01:44,890
And then you can choose to watch it,

00:01:44,890 --> 00:01:47,750
or you can pivot to related titles and check them out.

00:01:47,750 --> 00:01:51,020
So if you were to visualize Netflix's domain model,

00:01:51,020 --> 00:01:55,200
it's like a big graph out there, a big graph in the cloud with

00:01:55,200 --> 00:01:57,990
a bunch of titles that're all related to each other through

00:01:57,990 --> 00:02:00,530
that graph. "House of Cards " could be related to "Breaking

00:02:00,530 --> 00:02:02,440
Bad," which is related to Jim Jeffries,

00:02:02,440 --> 00:02:05,350
which is related back to "House of cards," et cetera.

00:02:05,350 --> 00:02:08,300
So now, let's try and see what it would

00:02:08,300 --> 00:02:09,750
look like to use an MVC style.

00:02:09,750 --> 00:02:11,900
That same MVC style we talked about earlier

00:02:11,900 --> 00:02:13,700
to do, say, a movie detail page.

00:02:13,700 --> 00:02:15,470
So let's say we select "House of Cards."

00:02:15,470 --> 00:02:18,670
And we create a show detail controller and a show detail

00:02:18,670 --> 00:02:19,207
view.

00:02:19,207 --> 00:02:20,790
And that show detail control and makes

00:02:20,790 --> 00:02:25,140
a request for detail information about "House of Cards."

00:02:25,140 --> 00:02:28,520
And now we grab that node in the graph, the "House of Cards"

00:02:28,520 --> 00:02:31,800
node, and we've got a problem all of the sudden.

00:02:31,800 --> 00:02:37,000
How much of the "House of Cards" should the controller request?

00:02:37,000 --> 00:02:39,790
Should it get the name, maybe the description,

00:02:39,790 --> 00:02:42,540
the list of episodes, the list of seasons?

00:02:42,540 --> 00:02:44,319
How does it know?

00:02:44,319 --> 00:02:46,360
In fact, there's really no way for the controller

00:02:46,360 --> 00:02:49,880
to know exactly how much of this graph it should grab.

00:02:49,880 --> 00:02:51,520
The fact is, the controller wants

00:02:51,520 --> 00:02:53,080
to grab as little as possible.

00:02:53,080 --> 00:02:55,510
It's more efficient if it grabs just the data it needs

00:02:55,510 --> 00:02:57,384
and sends it over the wire.

00:02:57,384 --> 00:02:58,800
The only way to know, though, what

00:02:58,800 --> 00:03:01,740
the minimum amount of data we can grab from the cloud

00:03:01,740 --> 00:03:03,550
is what the view uses.

00:03:03,550 --> 00:03:05,230
So if we take a look at this template,

00:03:05,230 --> 00:03:07,310
and the controller knows what the view is going to use,

00:03:07,310 --> 00:03:08,476
well, it's pretty obviously.

00:03:08,476 --> 00:03:10,360
We can just grab these four fields,

00:03:10,360 --> 00:03:12,870
and the service can execute a SQL query,

00:03:12,870 --> 00:03:16,330
grab just those four fields, and send down the minimum amount

00:03:16,330 --> 00:03:17,974
of data to the view.

00:03:17,974 --> 00:03:18,640
Now, this works.

00:03:18,640 --> 00:03:20,310
And it's really efficient.

00:03:20,310 --> 00:03:22,732
But it's not what I'd call decoupled.

00:03:22,732 --> 00:03:25,190
Just to prove that this really isn't very decoupled at all,

00:03:25,190 --> 00:03:27,735
and there's no real separation between the controller

00:03:27,735 --> 00:03:29,980
and the view here, let's imagine a PM

00:03:29,980 --> 00:03:32,140
comes by my desk, which happens every now and then.

00:03:32,140 --> 00:03:33,660
And they are like, you know what? "House of Cards"

00:03:33,660 --> 00:03:34,769
has got such a great cast.

00:03:34,769 --> 00:03:36,060
We really want to highlight it.

00:03:36,060 --> 00:03:38,400
So let's add a new field in the view

00:03:38,400 --> 00:03:41,490
talking about the cast of "House of Cards."

00:03:41,490 --> 00:03:44,020
What do I have to change to make that happen?

00:03:44,020 --> 00:03:46,680
Well, obviously, I have to add it to the view.

00:03:46,680 --> 00:03:48,846
But, realistically, it's not just a matter

00:03:48,846 --> 00:03:50,790
of changing the view and walking away.

00:03:50,790 --> 00:03:53,760
I need to go to the service that actually marshals this data.

00:03:53,760 --> 00:03:57,730
And I need to request an extra field.

00:03:57,730 --> 00:04:01,204
What has this view controller separation bought me?

00:04:01,204 --> 00:04:05,430
It's two boxes where I put code, but are they really decoupled?

00:04:05,430 --> 00:04:07,180
So let's say I select this data.

00:04:07,180 --> 00:04:08,200
We render it.

00:04:08,200 --> 00:04:09,560
We've got that field down there.

00:04:09,560 --> 00:04:10,690
That's great.

00:04:10,690 --> 00:04:13,490
But I suggest to you that the view is actually

00:04:13,490 --> 00:04:15,910
coupled to the controller because the view depends

00:04:15,910 --> 00:04:17,810
on the controller to respond, to retrieve

00:04:17,810 --> 00:04:21,544
all the information that that view is going to display.

00:04:21,544 --> 00:04:22,960
How do we decouple these things?

00:04:22,960 --> 00:04:24,090
How do we do better?

00:04:24,090 --> 00:04:26,140
I mean, do I just not get it, guys?

00:04:26,140 --> 00:04:27,355
Am I doing it all wrong?

00:04:27,355 --> 00:04:28,730
Well, I find, typically, when you

00:04:28,730 --> 00:04:30,896
ask a lot of developers, maybe five developers, what

00:04:30,896 --> 00:04:34,170
MVC is, you'll often get four or five different answers.

00:04:34,170 --> 00:04:36,300
But as far as I can see, this is a real problem.

00:04:36,300 --> 00:04:39,440
And it's a problem that exists in a lot of Angular apps.

00:04:39,440 --> 00:04:41,555
So why don't we turn it a little differently?

00:04:41,555 --> 00:04:43,659
I can think of a solution to this.

00:04:43,659 --> 00:04:45,700
I'm not necessarily proposing you try it at home.

00:04:45,700 --> 00:04:47,600
But that is that we go and download--

00:04:47,600 --> 00:04:50,310
we just create a JSON resource for like all the data

00:04:50,310 --> 00:04:51,330
about a Netflix member.

00:04:51,330 --> 00:04:54,020
That's all the Netflix titles, and their ratings,

00:04:54,020 --> 00:04:56,340
and we just download all the data right at the start.

00:04:56,340 --> 00:04:58,565
Now we've got all the data locally.

00:04:58,565 --> 00:05:00,350
And now it's a much easier problem.

00:05:00,350 --> 00:05:02,500
The controller decides what the root node

00:05:02,500 --> 00:05:05,350
is that it wants to hand to the gallery view for in this case.

00:05:05,350 --> 00:05:07,472
And the gallery view just traverses and grabs

00:05:07,472 --> 00:05:08,930
as much of the data as it wants to.

00:05:08,930 --> 00:05:10,840
And it's just a JSON object in memory.

00:05:10,840 --> 00:05:12,750
No problem.

00:05:12,750 --> 00:05:15,710
Now I look at a movie detail page, exactly the same thing.

00:05:15,710 --> 00:05:17,770
Controller chooses what the root node is.

00:05:17,770 --> 00:05:19,750
View expands and traverses as much

00:05:19,750 --> 00:05:22,656
of the graph as it needs to display its information.

00:05:22,656 --> 00:05:24,990
And we get a detail page.

00:05:24,990 --> 00:05:27,590
Related titles, same thing.

00:05:27,590 --> 00:05:29,904
Everything is really easy when you don't have a cloud.

00:05:29,904 --> 00:05:32,070
Everything's really easy when the data is in memory,

00:05:32,070 --> 00:05:35,646
and it's easy to separate our concerns.

00:05:35,646 --> 00:05:37,020
Well, I don't think that's really

00:05:37,020 --> 00:05:38,228
going to work for most of us.

00:05:38,228 --> 00:05:40,730
Even if we could fit all that data on our device,

00:05:40,730 --> 00:05:43,250
we probably don't want to sit around and wait for 20 minutes

00:05:43,250 --> 00:05:45,680
while we download it all over a 3G connection.

00:05:45,680 --> 00:05:49,010
So that's where Falcore comes in.

00:05:49,010 --> 00:05:51,130
Falcore is an asynchronous model.

00:05:51,130 --> 00:05:54,090
It's a library to help you build an asynchronous model

00:05:54,090 --> 00:05:55,890
for your MVC?

00:05:55,890 --> 00:05:57,220
So what does that look like?

00:05:57,220 --> 00:06:00,870
Well, it allows you to pretend that we did download

00:06:00,870 --> 00:06:02,440
all the data from the cloud.

00:06:02,440 --> 00:06:04,320
So we've still got our one HTTP resource,

00:06:04,320 --> 00:06:07,120
which has all the JSON data for this Netflix member.

00:06:07,120 --> 00:06:09,260
And instead of download it, we're

00:06:09,260 --> 00:06:10,660
going to have to virtualize it.

00:06:10,660 --> 00:06:12,830
We're going to create an asynchronous model which

00:06:12,830 --> 00:06:14,270
doesn't really have the data.

00:06:14,270 --> 00:06:16,550
But it's going to take any requests for information,

00:06:16,550 --> 00:06:18,622
and it's going to forward along to the service.

00:06:18,622 --> 00:06:21,080
It's almost as if we took the service layer, and the model,

00:06:21,080 --> 00:06:23,360
and we fused them together.

00:06:23,360 --> 00:06:26,870
So a view requests some data.

00:06:26,870 --> 00:06:28,870
We actually use the query string to request

00:06:28,870 --> 00:06:30,750
just a fragment of that JSON.

00:06:30,750 --> 00:06:31,880
And we send it down.

00:06:31,880 --> 00:06:32,881
Now the view is driving.

00:06:32,881 --> 00:06:34,921
As long as the view is comfortable with receiving

00:06:34,921 --> 00:06:36,310
the data asynchronously, the view

00:06:36,310 --> 00:06:39,140
can describe exactly how much of the graph it wants to traverse.

00:06:39,140 --> 00:06:40,937
And then the model can go and get it.

00:06:40,937 --> 00:06:42,020
So we do a different page.

00:06:42,020 --> 00:06:43,490
The view starts driving again.

00:06:43,490 --> 00:06:45,430
It says, hey look, I want this data.

00:06:45,430 --> 00:06:47,170
We send it down.

00:06:47,170 --> 00:06:48,580
And we go to related titles.

00:06:48,580 --> 00:06:51,220
Again, it's the view deciding how much of the graph

00:06:51,220 --> 00:06:53,490
gets traversed.

00:06:53,490 --> 00:06:55,780
And, interestingly enough, we cache.

00:06:55,780 --> 00:06:57,382
That's an index finger, by the way.

00:06:57,382 --> 00:07:02,180
If we hit Back, you hit the cache part of the model.

00:07:02,180 --> 00:07:04,410
We're transparently caching this model for you.

00:07:04,410 --> 00:07:05,472
It's still asynchronous.

00:07:05,472 --> 00:07:06,680
But we take it out of memory.

00:07:06,680 --> 00:07:08,450
And we push it to you immediately.

00:07:08,450 --> 00:07:10,530
And so we go back.

00:07:10,530 --> 00:07:12,276
And that's completely transparent.

00:07:12,276 --> 00:07:13,650
We're caching it, just like a web

00:07:13,650 --> 00:07:15,650
browser would cache resources that it previously

00:07:15,650 --> 00:07:17,950
had gathered.

00:07:17,950 --> 00:07:19,860
How do we access it?

00:07:19,860 --> 00:07:20,480
The data.

00:07:20,480 --> 00:07:21,900
The data is the API.

00:07:21,900 --> 00:07:24,944
This is a big JSON document, a proxy for a big JSON

00:07:24,944 --> 00:07:25,860
document in the cloud.

00:07:25,860 --> 00:07:27,930
How would I load, say, the address

00:07:27,930 --> 00:07:29,710
from a person object in JSON?

00:07:29,710 --> 00:07:31,010
Well, I would just use a path.

00:07:31,010 --> 00:07:34,060
In a Falcor JSON model, I can refer to a JSON object

00:07:34,060 --> 00:07:35,440
out there in the cloud.

00:07:35,440 --> 00:07:38,900
And I can use the exact same API to retrieve the results.

00:07:38,900 --> 00:07:42,850
The only difference is that what comes out is a promise.

00:07:42,850 --> 00:07:45,340
So this allows us to do a pattern which

00:07:45,340 --> 00:07:48,840
I call asynchronous MVC.

00:07:48,840 --> 00:07:50,540
What do I mean by asynchronous MVC?

00:07:50,540 --> 00:07:52,620
Well, an asynchronous model, what we're doing

00:07:52,620 --> 00:07:55,550
is we're actually taking the last piece of MVC that

00:07:55,550 --> 00:07:58,110
wasn't async, and we're making it async.

00:07:58,110 --> 00:07:59,920
And we're seeing how that can actually

00:07:59,920 --> 00:08:01,750
give us the promise of MVC, give us

00:08:01,750 --> 00:08:04,940
the decoupling that we've always kind of been promised from MVC.

00:08:04,940 --> 00:08:06,080
So let's see again.

00:08:06,080 --> 00:08:07,990
Let's take a look at how that idyllic MVC

00:08:07,990 --> 00:08:09,920
is supposed to work.

00:08:09,920 --> 00:08:12,420
Kind of how most of the folks out there are doing it.

00:08:12,420 --> 00:08:15,590
And we know that introduces an implicit coupling because we're

00:08:15,590 --> 00:08:18,250
counting on the controller to retrieve enough of the graph

00:08:18,250 --> 00:08:21,310
so that when the view tries to display it, it's there.

00:08:21,310 --> 00:08:23,370
Well, here's what async MVC looks like.

00:08:23,370 --> 00:08:25,230
We create an asynchronous model.

00:08:25,230 --> 00:08:27,760
And the controller chooses the root node

00:08:27,760 --> 00:08:30,900
of that asynchronous model and describes that to the view

00:08:30,900 --> 00:08:33,409
by creating a new little asynchronous model that's

00:08:33,409 --> 00:08:35,549
just a little object in memory that's holding

00:08:35,549 --> 00:08:37,544
on to that path in the model.

00:08:37,544 --> 00:08:38,960
The view requests data from there.

00:08:38,960 --> 00:08:41,084
It might make several requests, through a template,

00:08:41,084 --> 00:08:42,860
for example, a bunch of different fields.

00:08:42,860 --> 00:08:45,590
But because it's asynchronous, we can take all those requests.

00:08:45,590 --> 00:08:49,810
And we can schedule them in one request to the server.

00:08:49,810 --> 00:08:51,420
And the requested data comes back.

00:08:51,420 --> 00:08:53,229
Notice, now, it's not the controller

00:08:53,229 --> 00:08:55,270
making the decision about how much data out there

00:08:55,270 --> 00:08:56,660
in the cloud we download.

00:08:56,660 --> 00:08:58,530
It's actually the view driving it.

00:08:58,530 --> 00:09:01,580
And so we've totally decoupled the controller and the view.

00:09:01,580 --> 00:09:03,610
The controller's job is to choose the root node

00:09:03,610 --> 00:09:04,190
in the graph.

00:09:04,190 --> 00:09:06,440
And the view's job is to traverse as much as it likes.

00:09:06,440 --> 00:09:09,412
Maybe today the "House of Cards" shows the list of episodes.

00:09:09,412 --> 00:09:11,620
And tomorrow it shows the first three related titles.

00:09:11,620 --> 00:09:15,820
It can go as deep through the graph as it wants to.

00:09:15,820 --> 00:09:18,190
So what does it look like to create this route?

00:09:18,190 --> 00:09:19,370
What does it look like when the controller

00:09:19,370 --> 00:09:21,828
picks this little root object out and hands it to the view.

00:09:21,828 --> 00:09:24,510
Well, this is what it would look like in traditional MVC.

00:09:24,510 --> 00:09:27,800
I might call this service, get genreless title by index.

00:09:27,800 --> 00:09:29,930
And that will give me, it'll have

00:09:29,930 --> 00:09:32,170
to choose some amount of that title to download.

00:09:32,170 --> 00:09:34,970
And I'm going to make this a property of my controller.

00:09:34,970 --> 00:09:37,480
And then the view can take a look at it.

00:09:37,480 --> 00:09:40,080
Asynchronous MVC, though, essentially, we're

00:09:40,080 --> 00:09:41,039
using this bind method.

00:09:41,039 --> 00:09:42,746
Don't confuse this with template binding.

00:09:42,746 --> 00:09:44,290
But we're using this bind method,

00:09:44,290 --> 00:09:47,220
and we're creating this little other asynchronous model.

00:09:47,220 --> 00:09:48,870
It's just a little object in memory

00:09:48,870 --> 00:09:53,320
that's referring to that path, genre list 2-1.

00:09:53,320 --> 00:09:55,630
Now title in this is still an asynchronous model.

00:09:55,630 --> 00:09:57,630
So we're creating this little asynchronous model

00:09:57,630 --> 00:10:01,090
that points to the right node.

00:10:01,090 --> 00:10:03,840
So in Angular 2, one of the things that's most exciting to

00:10:03,840 --> 00:10:06,420
me is that they are now going to allow you

00:10:06,420 --> 00:10:10,080
to bind to asynchronous data sources declaratively directly

00:10:10,080 --> 00:10:11,350
in your template.

00:10:11,350 --> 00:10:13,780
It's basically because the template syntax, and this

00:10:13,780 --> 00:10:16,290
goes to show you, is so flexible that you're

00:10:16,290 --> 00:10:19,240
able to go from this, which is binding to a synchronous JSON

00:10:19,240 --> 00:10:21,635
object in memory do binding to something

00:10:21,635 --> 00:10:22,760
that returns back promises.

00:10:22,760 --> 00:10:24,735
We need that little bit of extra stuff here.

00:10:24,735 --> 00:10:26,360
And what I'm doing here is I'm actually

00:10:26,360 --> 00:10:28,140
extending how templates work.

00:10:28,140 --> 00:10:30,415
And Victor's done some work to prove this out.

00:10:30,415 --> 00:10:31,790
And we can actually bind directly

00:10:31,790 --> 00:10:33,632
to things like promises or observables.

00:10:33,632 --> 00:10:35,340
By the way, who has heard of observables?

00:10:35,340 --> 00:10:36,820
Hands up.

00:10:36,820 --> 00:10:38,250
Quite a few people, OK.

00:10:38,250 --> 00:10:41,240
In fact, this framework will output observables as well as

00:10:41,240 --> 00:10:41,740
promises.

00:10:41,740 --> 00:10:44,160
And so you can bind either in the template.

00:10:44,160 --> 00:10:47,010
So now let's go back to the problem we had.

00:10:47,010 --> 00:10:49,777
I want to display a field.

00:10:49,777 --> 00:10:51,360
What does it take to make that happen?

00:10:51,360 --> 00:10:53,390
Well, our show detail controller, we're

00:10:53,390 --> 00:10:55,200
going to use our virtual model.

00:10:55,200 --> 00:10:57,610
It's going to say, hey, this is the root node.

00:10:57,610 --> 00:11:01,050
It's going to create this little virtual model proxy here.

00:11:01,050 --> 00:11:04,900
And show detail view is going to request the data.

00:11:04,900 --> 00:11:06,550
But it's going to use the template.

00:11:06,550 --> 00:11:08,758
And the template is just going to list all the fields

00:11:08,758 --> 00:11:11,370
that it wants, declaratively.

00:11:11,370 --> 00:11:13,540
That's going to cause a bunch of different requests

00:11:13,540 --> 00:11:15,124
to go to this async model.

00:11:15,124 --> 00:11:17,290
But the async model is going to schedule all of them

00:11:17,290 --> 00:11:18,590
to happen on the next turn.

00:11:18,590 --> 00:11:21,040
And it's going to batch them all up.

00:11:21,040 --> 00:11:24,360
And so we get a request to the member JSON for all

00:11:24,360 --> 00:11:25,940
of the data that's necessary.

00:11:25,940 --> 00:11:28,240
Now, I want you to look at the path that goes in here.

00:11:28,240 --> 00:11:30,055
What's actually happened, when we bind,

00:11:30,055 --> 00:11:31,960
when we saw that bind expression earlier,

00:11:31,960 --> 00:11:35,740
we will automatically optimize into IDs for you.

00:11:35,740 --> 00:11:37,487
We have a graph format for JSON--

00:11:37,487 --> 00:11:39,820
because the challenge about taking all your domain model

00:11:39,820 --> 00:11:42,174
and putting it into JSON, JSON is not for graphs.

00:11:42,174 --> 00:11:43,590
And everybody's got a domain model

00:11:43,590 --> 00:11:45,050
that's a graph, everybody.

00:11:45,050 --> 00:11:47,720
And so we don't want to blow it out and create duplicates.

00:11:47,720 --> 00:11:49,720
But we do have to express as a JSON object.

00:11:49,720 --> 00:11:51,950
And so, I don't have time to talk about it today,

00:11:51,950 --> 00:11:54,830
but we have a coding format for expressing your domain model

00:11:54,830 --> 00:11:57,780
as a graph inside that JSON that allows Falcore

00:11:57,780 --> 00:11:59,650
to learn about IDs for you.

00:11:59,650 --> 00:12:01,650
One of the most painful things when

00:12:01,650 --> 00:12:05,070
you start working with remote data instead of local data,

00:12:05,070 --> 00:12:06,515
you need to think about IDs.

00:12:06,515 --> 00:12:07,890
I mean, imagine we did that thing

00:12:07,890 --> 00:12:10,690
where we downloaded all the JSON onto the device right to start.

00:12:10,690 --> 00:12:13,191
Would you ever think about ideas ever again?

00:12:13,191 --> 00:12:13,690
No.

00:12:13,690 --> 00:12:16,450
It's cheap to just traverse pointer references.

00:12:16,450 --> 00:12:18,320
But when you start working with remote data,

00:12:18,320 --> 00:12:20,620
you need to use IDs whenever you go back to the server,

00:12:20,620 --> 00:12:22,110
if you have an ID, because it means

00:12:22,110 --> 00:12:24,280
we can be much, much more efficient back end

00:12:24,280 --> 00:12:25,240
queries for things.

00:12:25,240 --> 00:12:27,500
And so Falcore makes this process transparent.

00:12:27,500 --> 00:12:29,180
Really, that's part of how it delivers

00:12:29,180 --> 00:12:32,300
on the promise of making remote data feel like it's local,

00:12:32,300 --> 00:12:35,080
by automatically doing ID translations for you.

00:12:35,080 --> 00:12:37,500
And so it's requesting all of the fields in the template

00:12:37,500 --> 00:12:41,610
in one query and by ID.

00:12:41,610 --> 00:12:43,690
So we return the requested data.

00:12:43,690 --> 00:12:46,210
We output the HTML with the views in control.

00:12:46,210 --> 00:12:48,710
And it's driving how much of the graph it wants to traverse.

00:12:48,710 --> 00:12:53,490
And finally, we get "House of Cards" with that extra field.

00:12:53,490 --> 00:12:59,180
So Falcore is really based on three dimensional freedom.

00:12:59,180 --> 00:13:03,120
It's the what, when, where of data.

00:13:03,120 --> 00:13:05,380
So what that is our job.

00:13:05,380 --> 00:13:07,770
What is the actual data that we want to display the user.

00:13:07,770 --> 00:13:10,540
We want to be able to describe what data is that we want.

00:13:10,540 --> 00:13:12,550
And so I can create a Falcore model

00:13:12,550 --> 00:13:14,670
that refers to a JSON file out there in the cloud.

00:13:14,670 --> 00:13:17,420
And then I can pull out a path.

00:13:17,420 --> 00:13:20,052
What comes out as a promise-- so if I run this,

00:13:20,052 --> 00:13:22,510
you'll notice on the right hand side, we selected TV shows.

00:13:22,510 --> 00:13:24,301
That's actually coming from the JSON object

00:13:24,301 --> 00:13:26,630
out there in the cloud, just visually representing it.

00:13:26,630 --> 00:13:28,214
But we can also grab a lot of data

00:13:28,214 --> 00:13:29,880
using the syntax that looks a little bit

00:13:29,880 --> 00:13:30,560
like [INAUDIBLE] script.

00:13:30,560 --> 00:13:32,330
But basically what we're doing there

00:13:32,330 --> 00:13:33,954
is grabbing a bunch of different paths.

00:13:33,954 --> 00:13:36,240
But we're doing it in a nice coarse grain interface

00:13:36,240 --> 00:13:37,750
which makes it very efficient.

00:13:37,750 --> 00:13:40,100
So if I run this, we get back the fragment

00:13:40,100 --> 00:13:43,280
of the JSON document out there in the cloud.

00:13:43,280 --> 00:13:45,750
So you don't need to pick arbitrary services anymore

00:13:45,750 --> 00:13:48,680
to carve out these arbitrary pieces of the cloud.

00:13:48,680 --> 00:13:51,350
You can just, on the client, request exactly what you want

00:13:51,350 --> 00:13:52,280
and no more.

00:13:52,280 --> 00:13:54,860
And you don't have to create all these different services

00:13:54,860 --> 00:13:55,360
either.

00:13:55,360 --> 00:13:56,610
And that's one of the real problem

00:13:56,610 --> 00:13:58,234
that we had at Netflix three years ago.

00:13:58,234 --> 00:14:00,230
We had this proliferation of services.

00:14:00,230 --> 00:14:03,050
And all of them returned some subset of that data

00:14:03,050 --> 00:14:05,350
out there in the cloud, our conceptual domain model.

00:14:05,350 --> 00:14:06,390
And the problem was, because they all

00:14:06,390 --> 00:14:08,789
returned some subset, some of them were overlapping.

00:14:08,789 --> 00:14:10,580
And that made it really difficult to cache.

00:14:10,580 --> 00:14:12,121
How many folks out there are actually

00:14:12,121 --> 00:14:14,225
caching, in memory, their own objects.

00:14:14,225 --> 00:14:16,600
They've got to keep a in memory cache for the single page

00:14:16,600 --> 00:14:18,430
web application?

00:14:18,430 --> 00:14:20,490
Quite a few folks.

00:14:20,490 --> 00:14:22,780
Easy?

00:14:22,780 --> 00:14:23,801
[LAUGH] Good.

00:14:23,801 --> 00:14:24,550
Somebody said yes.

00:14:24,550 --> 00:14:25,091
That's great.

00:14:25,091 --> 00:14:26,070
I'm glad.

00:14:26,070 --> 00:14:28,330
It wasn't so easy for us.

00:14:28,330 --> 00:14:29,340
Definitely not.

00:14:29,340 --> 00:14:31,100
Caching validation-- anybody ever

00:14:31,100 --> 00:14:33,641
heard that saying, there's only two hard problems in computer

00:14:33,641 --> 00:14:36,230
science, naming things and caching validation?

00:14:36,230 --> 00:14:38,110
Yeah.

00:14:38,110 --> 00:14:41,030
This essentially keeps your cache coherent for you

00:14:41,030 --> 00:14:44,110
because you ask for individual fields.

00:14:44,110 --> 00:14:46,752
You're not going to go in and ask for an entire title object.

00:14:46,752 --> 00:14:48,960
You're going to be very specific, just like you would

00:14:48,960 --> 00:14:50,680
be about an in memory JSON object

00:14:50,680 --> 00:14:52,980
and ask for the specific fields that you want.

00:14:52,980 --> 00:14:55,560
And so you never have any overlapping messages

00:14:55,560 --> 00:14:56,380
from the server.

00:14:56,380 --> 00:14:58,350
It's all goes down to these individual fields.

00:14:58,350 --> 00:15:00,932
And we keep a cache that's totally consistent for you.

00:15:00,932 --> 00:15:02,890
So you don't even have to think about catching.

00:15:02,890 --> 00:15:05,480
It just happens like when you use a web browser.

00:15:05,480 --> 00:15:08,860
So we have total flexibility about what data we request.

00:15:08,860 --> 00:15:11,110
We can make a single request and grab the entire graph

00:15:11,110 --> 00:15:12,570
if that's what we want.

00:15:12,570 --> 00:15:15,520
We also have flexibility about when the data can arrive.

00:15:15,520 --> 00:15:19,200
So I can also use this new-- this particular,

00:15:19,200 --> 00:15:21,380
I can request this as path values.

00:15:21,380 --> 00:15:23,330
And now we're going to return an observable.

00:15:23,330 --> 00:15:25,800
And we're actually going to have the data stream back to us

00:15:25,800 --> 00:15:27,370
as quickly as it becomes available.

00:15:27,370 --> 00:15:28,920
Maybe it's coming over a WebSocket.

00:15:28,920 --> 00:15:30,132
Maybe some of it's already in cache,

00:15:30,132 --> 00:15:31,760
and it'll be pushed to us immediately.

00:15:31,760 --> 00:15:33,580
But eventually we can just have that data

00:15:33,580 --> 00:15:35,290
streamed to us over time.

00:15:35,290 --> 00:15:38,770
And so we have all this flexibility along the win axis.

00:15:38,770 --> 00:15:41,100
Finally, and this is the most important thing,

00:15:41,100 --> 00:15:42,390
where is the data?

00:15:42,390 --> 00:15:44,602
You get to code the same way regardless

00:15:44,602 --> 00:15:46,810
of whether that data is in cache, in a fast in memory

00:15:46,810 --> 00:15:49,054
cache, or it's out there on the cloud.

00:15:49,054 --> 00:15:49,970
So how does this look?

00:15:49,970 --> 00:15:53,460
Well, I've got a JSON object, regular old JSON.

00:15:53,460 --> 00:15:55,040
Nothing to see here.

00:15:55,040 --> 00:15:57,530
I can take that JSON data, and I can load it

00:15:57,530 --> 00:16:00,612
into a local Falcore cache, into a model for a Falcore cache.

00:16:00,612 --> 00:16:02,070
So I've taken the same JSON object.

00:16:02,070 --> 00:16:02,930
I put it in there.

00:16:02,930 --> 00:16:04,430
And when I request it, this time I'm

00:16:04,430 --> 00:16:06,080
going to use an asynchronous API.

00:16:06,080 --> 00:16:09,160
And when I do that, I can load the exact same data.

00:16:09,160 --> 00:16:11,700
But now that I'm actually interacting with my data

00:16:11,700 --> 00:16:14,290
throughout a Falcore model, and not directly through JSON,

00:16:14,290 --> 00:16:16,570
I have the flexibility to take that data

00:16:16,570 --> 00:16:23,430
and move it out into the cloud-- on a node server, for example.

00:16:23,430 --> 00:16:25,140
So let's say, for the sake of argument,

00:16:25,140 --> 00:16:26,723
just temporarily here, you're actually

00:16:26,723 --> 00:16:31,200
OK with storing all your data in memory on the node server.

00:16:31,200 --> 00:16:32,200
Just for the time being.

00:16:32,200 --> 00:16:33,241
Probably not a good idea.

00:16:33,241 --> 00:16:33,980
Don't try this.

00:16:33,980 --> 00:16:36,410
But this is effectively what it looks like.

00:16:36,410 --> 00:16:37,670
I would make a request.

00:16:37,670 --> 00:16:40,730
The HTTP source basically just sends this.

00:16:40,730 --> 00:16:43,880
It sends a path as part of the query string off to the server.

00:16:43,880 --> 00:16:47,575
And we run the exact same query on the model on the server.

00:16:47,575 --> 00:16:48,450
And we take the data.

00:16:48,450 --> 00:16:50,080
And then we send it back.

00:16:50,080 --> 00:16:53,600
Now, it actually gets added to the client Falcore model's

00:16:53,600 --> 00:16:54,650
local cache.

00:16:54,650 --> 00:16:56,325
Now, as I've said earlier, you probably

00:16:56,325 --> 00:16:57,700
don't want to store all your data

00:16:57,700 --> 00:16:59,036
in memory on the node server.

00:16:59,036 --> 00:17:01,410
I think those things go down pretty frequently, actually.

00:17:01,410 --> 00:17:03,860
So you should probably try and see

00:17:03,860 --> 00:17:05,339
if you can store it in data stores.

00:17:05,339 --> 00:17:06,650
That's where we like to keep our data, right?

00:17:06,650 --> 00:17:07,260
In databases.

00:17:07,260 --> 00:17:10,250
Sometimes not one or two or three, but, in Netflix's case,

00:17:10,250 --> 00:17:12,630
we've got like 80 services and a huge number

00:17:12,630 --> 00:17:13,730
of different databases.

00:17:13,730 --> 00:17:15,240
How do I take all that complexity

00:17:15,240 --> 00:17:18,260
and abstract it into something as simple as a JSON object?

00:17:18,260 --> 00:17:24,079
Well, it works exactly the same as your router in Angular--

00:17:24,079 --> 00:17:27,740
or a dynamic web server router in express MVC, for example.

00:17:27,740 --> 00:17:31,050
You build routes through the JSON document.

00:17:31,050 --> 00:17:32,110
And you match them.

00:17:32,110 --> 00:17:35,430
And, on demand, you go off to data stores

00:17:35,430 --> 00:17:37,634
and return that fragment of JSON.

00:17:37,634 --> 00:17:39,300
So what did we accomplish by doing this?

00:17:39,300 --> 00:17:41,990
It's almost like building a little web server into one HTTP

00:17:41,990 --> 00:17:42,491
resource?

00:17:42,491 --> 00:17:43,990
Why would we do that when we already

00:17:43,990 --> 00:17:45,229
have a dynamic web server?

00:17:45,229 --> 00:17:46,770
Well, it's to give us the flexibility

00:17:46,770 --> 00:17:48,850
to make a single request and retrieve

00:17:48,850 --> 00:17:50,660
a large amount of information.

00:17:50,660 --> 00:17:52,240
One of the problems about HTTP is

00:17:52,240 --> 00:17:53,840
that modern browsers can't necessarily

00:17:53,840 --> 00:17:55,900
make unlimited HTTP requests.

00:17:55,900 --> 00:17:58,087
It's really expensive to make HTTP requests.

00:17:58,087 --> 00:18:00,170
And sometimes, if you're downloading little things

00:18:00,170 --> 00:18:01,944
like JSON objects, the actual cost,

00:18:01,944 --> 00:18:03,360
like the size of the HTTP headers,

00:18:03,360 --> 00:18:05,510
could be larger than the data that you get.

00:18:05,510 --> 00:18:08,460
And that's because something's changed in the last 10 years.

00:18:08,460 --> 00:18:09,930
The web is no longer become a place

00:18:09,930 --> 00:18:11,930
where you just go to get there things like Yahoo

00:18:11,930 --> 00:18:13,110
and newsgroups.

00:18:13,110 --> 00:18:15,260
It's become a place where we go to do things.

00:18:15,260 --> 00:18:16,510
We have web applications.

00:18:16,510 --> 00:18:19,390
And the difference between web applications and web pages

00:18:19,390 --> 00:18:21,610
is web pages have large resources,

00:18:21,610 --> 00:18:23,370
like images and documents.

00:18:23,370 --> 00:18:25,370
And web applications deal in large numbers

00:18:25,370 --> 00:18:28,000
of small resources, like JSON objects.

00:18:28,000 --> 00:18:30,184
And creating a single separate HTTP request, which

00:18:30,184 --> 00:18:32,100
was designed for these coarse grained objects,

00:18:32,100 --> 00:18:34,880
for every single little JSON object is just not practical.

00:18:34,880 --> 00:18:38,330
And so by putting all of the graph in one HTTP resource,

00:18:38,330 --> 00:18:40,570
we get around this restriction.

00:18:40,570 --> 00:18:42,400
So I can take another part of my document

00:18:42,400 --> 00:18:45,062
and retrieve it from a totally different data store there.

00:18:45,062 --> 00:18:47,020
So it's working just like a dynamic web server,

00:18:47,020 --> 00:18:50,290
where we've realized HTML on demand based on a path pattern.

00:18:50,290 --> 00:18:52,780
Here, based on a pattern through the JSON document,

00:18:52,780 --> 00:18:56,500
we've realized a fragmentation of JSON on demand.

00:18:56,500 --> 00:19:00,850
So today, in Netflix, everything uses Falcore.

00:19:00,850 --> 00:19:03,360
All of our apps essentially think of the cloud

00:19:03,360 --> 00:19:06,410
as a big JSON object in memory.

00:19:06,410 --> 00:19:08,020
And we're really excited about what

00:19:08,020 --> 00:19:10,339
Angular is doing to provide better integration

00:19:10,339 --> 00:19:12,380
inside of templates for asynchronous programming.

00:19:12,380 --> 00:19:15,130
This is something we'd like to see across all MVC firmware.

00:19:15,130 --> 00:19:17,220
And we're starting to slowly see that happen.

00:19:17,220 --> 00:19:18,678
I think what it's going to allow us

00:19:18,678 --> 00:19:21,820
to do is really declaratively write a lot of the code

00:19:21,820 --> 00:19:24,184
that we write manually today and basically bind

00:19:24,184 --> 00:19:25,600
your templates directly to a cloud

00:19:25,600 --> 00:19:27,940
and not worry about so much of that marshalling data

00:19:27,940 --> 00:19:29,640
and then handing it to a template

00:19:29,640 --> 00:19:32,270
because the reality is, you end up either over fetching

00:19:32,270 --> 00:19:33,320
or under fetching.

00:19:33,320 --> 00:19:36,080
And why not just have the view drive exactly the data

00:19:36,080 --> 00:19:38,266
that you display?

00:19:38,266 --> 00:19:39,640
So we're open sourcing this soon.

00:19:39,640 --> 00:19:40,680
We were hoping to get ready for ng-comp.

00:19:40,680 --> 00:19:42,100
But we didn't quite get there.

00:19:42,100 --> 00:19:44,350
But we want it to be available in the next few months,

00:19:44,350 --> 00:19:45,100
certainly.

00:19:45,100 --> 00:19:46,790
And we're looking for help integrating with Angular 2.

00:19:46,790 --> 00:19:48,440
There's some really exciting things

00:19:48,440 --> 00:19:51,442
we could do by template integration

00:19:51,442 --> 00:19:53,650
with this-- not just by allowing you to bind directly

00:19:53,650 --> 00:19:55,370
to the model in the template, but also

00:19:55,370 --> 00:19:57,320
by allowing you to parse through the template

00:19:57,320 --> 00:20:00,520
and look ahead, and actually do predictive data loading.

00:20:00,520 --> 00:20:03,710
So if you want to check it out, Falcorjs is the Twitter handle.

00:20:03,710 --> 00:20:06,130
And that's my handle as well, if you

00:20:06,130 --> 00:20:08,730
want to follow me and learn more about Falcore.

00:20:08,730 --> 00:20:10,820
And thanks very much.


YouTube URL: https://www.youtube.com/watch?v=WiO1f6h15c8


