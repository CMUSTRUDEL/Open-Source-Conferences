Title: ng-conf 2015 Keynote 2 - Misko Hevery and Rado Kirov
Publication date: 2015-03-06
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:00,499


00:00:00,499 --> 00:00:02,340
[APPLAUSE]

00:00:02,340 --> 00:00:06,235


00:00:06,235 --> 00:00:07,610
MISKO HEVERY: Good morning, guys.

00:00:07,610 --> 00:00:09,966
How you guys doing?

00:00:09,966 --> 00:00:11,460
[CHEERING]

00:00:11,460 --> 00:00:12,960


00:00:12,960 --> 00:00:15,592
Where is [INAUDIBLE]?

00:00:15,592 --> 00:00:16,945
Where is he?

00:00:16,945 --> 00:00:17,808
Raise your hand.

00:00:17,808 --> 00:00:18,764
Right here?

00:00:18,764 --> 00:00:20,200
No?

00:00:20,200 --> 00:00:22,430
That was the awesomest T-shirt I ever got.

00:00:22,430 --> 00:00:25,770
Let me tell you.

00:00:25,770 --> 00:00:27,920
But first, let me just say thanks for that

00:00:27,920 --> 00:00:29,795
the people who have organized the conference.

00:00:29,795 --> 00:00:32,270
Like, I can't believe what an honor it is to be here.

00:00:32,270 --> 00:00:34,652
And also, I wanted to say thank you for, you know,

00:00:34,652 --> 00:00:36,120
there's some amazing set of people

00:00:36,120 --> 00:00:38,830
I get to work with every day, especially my boss.

00:00:38,830 --> 00:00:41,390
And all the other folks on the Angular team.

00:00:41,390 --> 00:00:43,946
And so give it up for them.

00:00:43,946 --> 00:00:45,425
[APPLAUSE]

00:00:45,425 --> 00:00:48,390


00:00:48,390 --> 00:00:50,850
So I wanted to talk to you today about Angular 2, right?

00:00:50,850 --> 00:00:52,796
I'm sure you guys all want to know, don't you?

00:00:52,796 --> 00:00:53,212
AUDIENCE: Yeah!

00:00:53,212 --> 00:00:53,628
MISKO HEVERY: All right.

00:00:53,628 --> 00:00:54,044
All right.

00:00:54,044 --> 00:00:54,544
All right.

00:00:54,544 --> 00:00:58,355
And so first of all, the project is, as Igor pointed out,

00:00:58,355 --> 00:00:59,230
it's out in the open.

00:00:59,230 --> 00:01:00,380
You're welcome to check it out.

00:01:00,380 --> 00:01:02,080
You're welcome to see what's going on.

00:01:02,080 --> 00:01:05,040
We got some forks happening, stars are happening.

00:01:05,040 --> 00:01:06,700
Commits are coming in.

00:01:06,700 --> 00:01:08,870
But an important point is, it's really in the open.

00:01:08,870 --> 00:01:10,730
And so you will get to have a chance

00:01:10,730 --> 00:01:13,930
to influence it, committed it, look at the issues.

00:01:13,930 --> 00:01:15,540
You can help us out with them.

00:01:15,540 --> 00:01:17,439
Send a pull request, and so on.

00:01:17,439 --> 00:01:18,730
So I'm really excited about it.

00:01:18,730 --> 00:01:20,820
Actually, I've been so excited about Angular 2,

00:01:20,820 --> 00:01:22,900
everybody who will listen, I tell them how excited I am.

00:01:22,900 --> 00:01:24,970
So I'm going to tell all of you now how excited I

00:01:24,970 --> 00:01:26,880
am about Angular 2.

00:01:26,880 --> 00:01:28,690
So one of the things that always comes up

00:01:28,690 --> 00:01:33,910
is, I think there is people who are like really are slightly

00:01:33,910 --> 00:01:35,150
afraid of the new syntax.

00:01:35,150 --> 00:01:36,780
Why are we changing it?

00:01:36,780 --> 00:01:38,510
And I want to convey to you today

00:01:38,510 --> 00:01:40,550
that there are some really important reasons why

00:01:40,550 --> 00:01:41,633
we're doing these changes.

00:01:41,633 --> 00:01:44,100
And these reasons are really going

00:01:44,100 --> 00:01:47,606
to enable us to build the next awesome framework.

00:01:47,606 --> 00:01:49,480
And so what I want to talk to you today about

00:01:49,480 --> 00:01:50,540
is this the syntax.

00:01:50,540 --> 00:01:52,080
And specifically, not the syntax,

00:01:52,080 --> 00:01:54,770
because that's very much in the land of the opinion,

00:01:54,770 --> 00:01:56,660
but really the semantics and the reasons

00:01:56,660 --> 00:02:00,680
behind it, which are concrete reasons that we have.

00:02:00,680 --> 00:02:02,720
Now as I said, syntax is something

00:02:02,720 --> 00:02:04,150
that is in line to an opinion.

00:02:04,150 --> 00:02:06,066
You know, syntax is just a bunch of characters

00:02:06,066 --> 00:02:07,120
you put on a page.

00:02:07,120 --> 00:02:08,590
You might like some characters.

00:02:08,590 --> 00:02:10,389
I might like some other characters.

00:02:10,389 --> 00:02:11,930
That's really not the important part.

00:02:11,930 --> 00:02:15,230
The important part is really the semantics behind it.

00:02:15,230 --> 00:02:17,234
And so when I'm going to present this to you,

00:02:17,234 --> 00:02:18,900
there's going to be a part of you that's

00:02:18,900 --> 00:02:19,999
the familiar side of it.

00:02:19,999 --> 00:02:22,540
And you're going to be like, oh, I know the Angular 1 syntax.

00:02:22,540 --> 00:02:23,340
And it's so simple.

00:02:23,340 --> 00:02:26,990
It's familiar to me because I worked with it so long.

00:02:26,990 --> 00:02:29,990
And the human brain has this natural tendency

00:02:29,990 --> 00:02:32,340
to confuse things that are familiar to us

00:02:32,340 --> 00:02:34,270
as things that are actually simple.

00:02:34,270 --> 00:02:36,789
But if you try and explain the syntax to somebody

00:02:36,789 --> 00:02:38,330
who's never been done Angular, you'll

00:02:38,330 --> 00:02:40,288
actually discover there's actually quite a menu

00:02:40,288 --> 00:02:43,260
set of rules that exist in Angular 1 syntax.

00:02:43,260 --> 00:02:46,750
And so, we believe that Angular 2 syntax is fundamentally

00:02:46,750 --> 00:02:49,080
simpler, in the sense that it has fewer rules

00:02:49,080 --> 00:02:51,385
to remember, to memorize, to understand.

00:02:51,385 --> 00:02:53,760
And as a result, it's going to be a lot more predictable,

00:02:53,760 --> 00:02:56,640
which is going to have a huge impact on performance for us.

00:02:56,640 --> 00:02:59,410
And also, it's going to be more toolable.

00:02:59,410 --> 00:03:03,770
And tooling is always a nice thing to have.

00:03:03,770 --> 00:03:05,540
So the first thing we want to talk about

00:03:05,540 --> 00:03:09,727
is the most familiar side of the syntax,

00:03:09,727 --> 00:03:10,810
which is the data binding.

00:03:10,810 --> 00:03:13,740
Which is, how do I get the data from my model

00:03:13,740 --> 00:03:15,540
and project it to the UI?

00:03:15,540 --> 00:03:18,160
This is what most people think about when

00:03:18,160 --> 00:03:19,450
they think about data binding.

00:03:19,450 --> 00:03:21,200
So let me show you something in Angular 1.

00:03:21,200 --> 00:03:24,160
In Angular 1, when you declare a component, it turns out,

00:03:24,160 --> 00:03:26,550
you could write three different kinds of components.

00:03:26,550 --> 00:03:28,520
You could say, title is a literal.

00:03:28,520 --> 00:03:30,310
It could be an expression.

00:03:30,310 --> 00:03:33,610
Or it could be an interpolation, if the component has managed

00:03:33,610 --> 00:03:35,820
to set up proper listeners.

00:03:35,820 --> 00:03:38,637
And I think this is an interesting thing.

00:03:38,637 --> 00:03:40,970
This is not exactly obvious when you first look at this,

00:03:40,970 --> 00:03:43,720
but the choice, which one of these three things

00:03:43,720 --> 00:03:46,510
should happen, that choice lies with the author

00:03:46,510 --> 00:03:48,030
of the component.

00:03:48,030 --> 00:03:50,960
Not with the author of the template where

00:03:50,960 --> 00:03:52,410
these things get instantiated.

00:03:52,410 --> 00:03:54,630
And it turns out that that's backwards.

00:03:54,630 --> 00:03:56,772
It's really be the author of the template,

00:03:56,772 --> 00:03:58,230
where this is going to be used, who

00:03:58,230 --> 00:04:00,770
should have the choice which one to write.

00:04:00,770 --> 00:04:03,910
Not the author of the component itself.

00:04:03,910 --> 00:04:06,960
And this is something that took me quite a long time

00:04:06,960 --> 00:04:07,810
to actually realize.

00:04:07,810 --> 00:04:09,710
But once you realize this, you go like, oh, yeah.

00:04:09,710 --> 00:04:10,550
This is backwards.

00:04:10,550 --> 00:04:12,930
This has always not been the other way around.

00:04:12,930 --> 00:04:15,550
And so not only that, there's three different ways,

00:04:15,550 --> 00:04:17,579
there's theses special characters in Angular 1.x

00:04:17,579 --> 00:04:19,579
and the bindings syntax that you have to define.

00:04:19,579 --> 00:04:22,755
You know, which one of these are you choosing?

00:04:22,755 --> 00:04:24,255
So we're going to simplify all this,

00:04:24,255 --> 00:04:25,838
and we're going to really say, there's

00:04:25,838 --> 00:04:27,590
only two different kinds of bindings.

00:04:27,590 --> 00:04:29,807
There's either a literal.

00:04:29,807 --> 00:04:30,890
Or there is an expression.

00:04:30,890 --> 00:04:32,360
And we're going to put that in the bracket.

00:04:32,360 --> 00:04:34,350
And I'm going to explain the bracket in a second,

00:04:34,350 --> 00:04:35,210
so let's not worry about it.

00:04:35,210 --> 00:04:37,090
The key takeaway here is, there's only

00:04:37,090 --> 00:04:41,170
two kinds of all bindings we're going to have.

00:04:41,170 --> 00:04:44,560
And as far as the component author is concerned,

00:04:44,560 --> 00:04:46,670
they actually don't care which one it is.

00:04:46,670 --> 00:04:48,897
All they're interested in is that a title

00:04:48,897 --> 00:04:49,980
will be delivered to them.

00:04:49,980 --> 00:04:53,200
And whether that title is in-lined, as a literal,

00:04:53,200 --> 00:04:55,130
or whether title is an expression,

00:04:55,130 --> 00:04:58,710
that is a concern of the template author, not the author

00:04:58,710 --> 00:05:00,070
of the component.

00:05:00,070 --> 00:05:03,150
Now I'm sure you're wondering, is this even a valid HTML?

00:05:03,150 --> 00:05:05,630
And why are you putting this weird stuff

00:05:05,630 --> 00:05:07,760
on the left-hand side, versus the right-hand side?

00:05:07,760 --> 00:05:09,093
And what about my interpolation?

00:05:09,093 --> 00:05:10,870
So let's talk about all of these things.

00:05:10,870 --> 00:05:12,470
First all, whoa!

00:05:12,470 --> 00:05:14,860
It is a valid HTML.

00:05:14,860 --> 00:05:16,542
Turns out, any character over there

00:05:16,542 --> 00:05:18,500
is valid, provided a few exceptional characters

00:05:18,500 --> 00:05:20,970
like equal sign or a bracket sign.

00:05:20,970 --> 00:05:23,170
Now I know you might be thinking, well,

00:05:23,170 --> 00:05:25,060
it's still kind of an alphanumeric.

00:05:25,060 --> 00:05:26,994
So for those of you guys who really

00:05:26,994 --> 00:05:28,410
insist on alphanumeric characters,

00:05:28,410 --> 00:05:31,090
there is going to be an alternative syntax that

00:05:31,090 --> 00:05:32,520
will be purely alphanumeric.

00:05:32,520 --> 00:05:36,020
So it will pass the HTML validators.

00:05:36,020 --> 00:05:36,520
OK.

00:05:36,520 --> 00:05:38,780
Now why we escaping the left-hand side, not

00:05:38,780 --> 00:05:39,972
the right-hand side?

00:05:39,972 --> 00:05:41,430
So look at something like an image.

00:05:41,430 --> 00:05:44,540
This is a problem we have in Angular 1.

00:05:44,540 --> 00:05:47,250
When you look at the source attribute, it refers to a URL,

00:05:47,250 --> 00:05:47,750
right?

00:05:47,750 --> 00:05:51,130
The user.png is not some object that has a user property

00:05:51,130 --> 00:05:52,690
and then has a property png.

00:05:52,690 --> 00:05:55,915
It's actually a URL file name called user.png.

00:05:55,915 --> 00:05:57,920
Now when an image first gets instantiated,

00:05:57,920 --> 00:05:58,910
the browsers are eager.

00:05:58,910 --> 00:06:00,743
And so they wake up and go fetch that image.

00:06:00,743 --> 00:06:02,990
So if you put a double curly inside of there,

00:06:02,990 --> 00:06:04,857
we all know what's going to happen, right?

00:06:04,857 --> 00:06:06,440
The browser is actually going to fetch

00:06:06,440 --> 00:06:09,215
a URL that contains double curly, username, double

00:06:09,215 --> 00:06:10,470
curly.png.

00:06:10,470 --> 00:06:12,660
And the server will return a 404.

00:06:12,660 --> 00:06:14,489
And you're going to get a dreaded error.

00:06:14,489 --> 00:06:16,030
Now we had this problem in Angular 1.

00:06:16,030 --> 00:06:17,830
And the way we solved it is we gave you

00:06:17,830 --> 00:06:20,490
an ng source directive.

00:06:20,490 --> 00:06:23,430
Now we could do that with the built-in attributes,

00:06:23,430 --> 00:06:25,940
because we know there's a limited number of them.

00:06:25,940 --> 00:06:28,880
And as a result, we can figure out

00:06:28,880 --> 00:06:30,390
which ones needed to be escaping.

00:06:30,390 --> 00:06:32,872
And we gave you an alternate way of escaping them.

00:06:32,872 --> 00:06:34,330
But look what's happening in there.

00:06:34,330 --> 00:06:36,420
What we're doing, actually, the only way

00:06:36,420 --> 00:06:38,360
to solve this particular problem is

00:06:38,360 --> 00:06:41,620
to do something with the key of the attribute, right?

00:06:41,620 --> 00:06:43,849
No amount of escaping on the right-hand side

00:06:43,849 --> 00:06:45,140
is going to solve this problem.

00:06:45,140 --> 00:06:47,560
The way we solved this problem is that we prefixed

00:06:47,560 --> 00:06:49,880
the source with ng source.

00:06:49,880 --> 00:06:54,390
And so the interesting kind of an insight into this

00:06:54,390 --> 00:06:55,874
is that, when a component wakes up,

00:06:55,874 --> 00:06:58,040
whether it's a real component inside of the browser,

00:06:58,040 --> 00:07:00,490
or it's a Web Component, when it wakes up,

00:07:00,490 --> 00:07:03,090
it will go and read its attributes in HTML.

00:07:03,090 --> 00:07:05,050
Because HTML is really just a serialization

00:07:05,050 --> 00:07:06,174
of its internal state.

00:07:06,174 --> 00:07:07,590
And it will read these attributes.

00:07:07,590 --> 00:07:11,190
And it does not know what the double curlies mean.

00:07:11,190 --> 00:07:13,160
And the only way we can prevent it

00:07:13,160 --> 00:07:15,660
from reading those attributes is to rename the attributes.

00:07:15,660 --> 00:07:18,190
And so now, the escape mechanism really becomes,

00:07:18,190 --> 00:07:19,510
like, how do we rename them?

00:07:19,510 --> 00:07:21,320
Now this is not the only instance of it.

00:07:21,320 --> 00:07:23,569
There's another instance of it, which is, for example,

00:07:23,569 --> 00:07:24,140
disabled.

00:07:24,140 --> 00:07:27,030
Disabled is, again, special because it is Boolean.

00:07:27,030 --> 00:07:29,740
And it's not what you put in the disabled that matters,

00:07:29,740 --> 00:07:32,260
it is whether the disabled attribute is present

00:07:32,260 --> 00:07:34,040
or not inside of the DOM

00:07:34,040 --> 00:07:35,980
And again, to solve this, is that we

00:07:35,980 --> 00:07:37,890
have a special directive called ng-disabled.

00:07:37,890 --> 00:07:40,990
Now what ng-disabled does is it actually

00:07:40,990 --> 00:07:43,720
writes to the property of the element

00:07:43,720 --> 00:07:46,247
rather than to the attribute.

00:07:46,247 --> 00:07:47,330
And now we have a problem.

00:07:47,330 --> 00:07:51,000
As I said, when you have an internal set of HTML elements,

00:07:51,000 --> 00:07:52,200
you know which one you have.

00:07:52,200 --> 00:07:53,040
You can enumerate them.

00:07:53,040 --> 00:07:54,039
And you can escape them.

00:07:54,039 --> 00:07:55,690
But in the world of Web Components,

00:07:55,690 --> 00:07:58,712
you don't know what the Web Components will choose to do.

00:07:58,712 --> 00:08:00,170
And therefore, you don't know ahead

00:08:00,170 --> 00:08:05,600
of time which attributes will have theses Boolean properties,

00:08:05,600 --> 00:08:06,750
and which do not.

00:08:06,750 --> 00:08:09,830
And so it turns out that a proper way to handle this

00:08:09,830 --> 00:08:15,300
is to always write to properties, not to attributes.

00:08:15,300 --> 00:08:18,160
So the syntax is basically this.

00:08:18,160 --> 00:08:21,040
You have some component, let's say it's a pane,

00:08:21,040 --> 00:08:22,810
and it might have a title, and select it,

00:08:22,810 --> 00:08:24,880
and there might be a double curly inside of it.

00:08:24,880 --> 00:08:28,870
The trouble becomes, how do I escape the title

00:08:28,870 --> 00:08:30,690
and the selected attribute?

00:08:30,690 --> 00:08:33,929
And as I said, this really falls in the land of opinion.

00:08:33,929 --> 00:08:35,799
The semantics, the reasoning that I just

00:08:35,799 --> 00:08:39,830
explained why we have to do this, that's kind of fixed.

00:08:39,830 --> 00:08:43,090
But the characters you happen to choose,

00:08:43,090 --> 00:08:45,010
that's very much in the land of opinion.

00:08:45,010 --> 00:08:48,240
And there's a famous Issue for that, Issue 133 on the GitHub,

00:08:48,240 --> 00:08:49,970
where there are some 600 comments people

00:08:49,970 --> 00:08:51,920
have about what particular set of characters

00:08:51,920 --> 00:08:52,846
they choose to have.

00:08:52,846 --> 00:08:54,220
Now what I find interesting about

00:08:54,220 --> 00:08:57,210
that Issue is that everybody has an opinion about characters.

00:08:57,210 --> 00:08:59,500
Very few people actually had an opinion

00:08:59,500 --> 00:09:00,729
about the semantics of it.

00:09:00,729 --> 00:09:03,020
And what we're really discussing here is the semantics.

00:09:03,020 --> 00:09:04,850
The reasons, why are we doing this?

00:09:04,850 --> 00:09:06,590
This is the important part.

00:09:06,590 --> 00:09:08,900
The actual characters, those can be

00:09:08,900 --> 00:09:12,510
changed by a simple regex and a search and replace.

00:09:12,510 --> 00:09:14,690
The semantics are a lot more complicated to change

00:09:14,690 --> 00:09:15,035
in your code.

00:09:15,035 --> 00:09:17,451
That requires a human to kind of understand and figure out

00:09:17,451 --> 00:09:19,350
what's going on.

00:09:19,350 --> 00:09:23,350
So Web Components are an important part of Angular 2.

00:09:23,350 --> 00:09:27,115
We really would like to be able to just have them and use them

00:09:27,115 --> 00:09:27,740
out of the box.

00:09:27,740 --> 00:09:30,073
And that's something that I'm going to talk about later,

00:09:30,073 --> 00:09:32,194
is not really possible in Angular 1.x.

00:09:32,194 --> 00:09:33,610
And the thing about Web Components

00:09:33,610 --> 00:09:36,790
is that, they really should act like the browser's existing

00:09:36,790 --> 00:09:37,440
elements.

00:09:37,440 --> 00:09:39,064
You know, when you get a Web Component,

00:09:39,064 --> 00:09:41,730
you shouldn't be able to really tell, or behave differently,

00:09:41,730 --> 00:09:45,170
or treat the fundamental element any different way

00:09:45,170 --> 00:09:46,080
than the native one.

00:09:46,080 --> 00:09:48,510
It should just be natural to the syntax.

00:09:48,510 --> 00:09:50,410
And what this syntax actually allows

00:09:50,410 --> 00:09:53,310
is that we can treat the two of them in a similar way.

00:09:53,310 --> 00:09:55,730
Now the other thing to remember about components,

00:09:55,730 --> 00:09:58,730
Web Components, or really just elements in general,

00:09:58,730 --> 00:10:01,860
is that they have properties, events and methods.

00:10:01,860 --> 00:10:06,230
That is the API surface of the DOM elements that we have.

00:10:06,230 --> 00:10:08,480
And these are the API surfaces that the Web Components

00:10:08,480 --> 00:10:10,340
will have, as well.

00:10:10,340 --> 00:10:11,800
And the last interesting thing is,

00:10:11,800 --> 00:10:15,260
that the HTML is a serialized version of the DOM, all right?

00:10:15,260 --> 00:10:16,760
It is how we serialize DOM.

00:10:16,760 --> 00:10:21,200
But what we care about is the actual DOM and the DOM's APIs,

00:10:21,200 --> 00:10:23,460
not the HTML serialization.

00:10:23,460 --> 00:10:26,510
And so if you look at an example of input by value,

00:10:26,510 --> 00:10:28,020
the initial value is placed inside

00:10:28,020 --> 00:10:31,430
of the HTML, inside of these the value property of the input.

00:10:31,430 --> 00:10:34,830
But if you want to read what the current state of the value is,

00:10:34,830 --> 00:10:37,750
you don't need the attribute, right?

00:10:37,750 --> 00:10:40,000
You read the property, because it's the property that

00:10:40,000 --> 00:10:41,750
has the good stuff.

00:10:41,750 --> 00:10:43,567
Now HTML is a little tricky.

00:10:43,567 --> 00:10:45,400
And this is a little confusing, because HTML

00:10:45,400 --> 00:10:48,170
syncs the attributes and the properties.

00:10:48,170 --> 00:10:49,904
And they keep them constantly in sync.

00:10:49,904 --> 00:10:50,570
Not all of them.

00:10:50,570 --> 00:10:54,130
There's a whole bunch of properties that only

00:10:54,130 --> 00:10:56,610
exist inside of the DOM API.

00:10:56,610 --> 00:10:59,770
So for example, cursor position, selected index,

00:10:59,770 --> 00:11:01,880
scrolling position, all of these things

00:11:01,880 --> 00:11:04,520
are properties that you can only read in DOM.

00:11:04,520 --> 00:11:07,320
But many things are synced to be attributes, which makes

00:11:07,320 --> 00:11:08,650
this thing really confusing.

00:11:08,650 --> 00:11:11,590
And this is the reason why, originally, Angular 1,

00:11:11,590 --> 00:11:14,090
thought like, well, there is no difference between attribute

00:11:14,090 --> 00:11:14,740
and properties.

00:11:14,740 --> 00:11:16,800
And we just randomly chose to have attributes.

00:11:16,800 --> 00:11:20,120
But it turns out that properties are really the way to go.

00:11:20,120 --> 00:11:22,546
Now properties solve two interesting things.

00:11:22,546 --> 00:11:24,170
First of all, when you have properties,

00:11:24,170 --> 00:11:25,770
you get to pass models.

00:11:25,770 --> 00:11:28,920
Attributes only understand strengths.

00:11:28,920 --> 00:11:31,950
But with properties, you can pass in complicated models

00:11:31,950 --> 00:11:33,260
down to your objects.

00:11:33,260 --> 00:11:35,260
And it solves the problem of Boolean attributes,

00:11:35,260 --> 00:11:37,610
as I pointed out earlier.

00:11:37,610 --> 00:11:40,880
So the big takeaway here is that we're changing two things.

00:11:40,880 --> 00:11:43,390
First of all, we're escaping the left-hand side

00:11:43,390 --> 00:11:45,260
of the expression.

00:11:45,260 --> 00:11:49,110
And the second part is that we are binding to properties, not

00:11:49,110 --> 00:11:52,570
to attributes of the element.

00:11:52,570 --> 00:11:55,130
Now you were saying, well, what about the double curly?

00:11:55,130 --> 00:11:57,400
So this is known as interpolation.

00:11:57,400 --> 00:11:58,310
It is so useful.

00:11:58,310 --> 00:11:59,340
It's everywhere.

00:11:59,340 --> 00:12:00,600
Can I please, please have it?

00:12:00,600 --> 00:12:03,067
And the answer is, yes, you can have it.

00:12:03,067 --> 00:12:04,650
But the way you have to think about it

00:12:04,650 --> 00:12:08,380
is that it's just a shorthand for the bottom line.

00:12:08,380 --> 00:12:11,260
When you say title equals double curly expression,

00:12:11,260 --> 00:12:13,770
that's just a shorthand of saying bind the title

00:12:13,770 --> 00:12:15,570
property to the expression.

00:12:15,570 --> 00:12:17,930
But remember, interpolation always has to be a string.

00:12:17,930 --> 00:12:20,870
So we have to convert it into a string and write it this way.

00:12:20,870 --> 00:12:23,110
Now Angular 2 is going to do this for you.

00:12:23,110 --> 00:12:25,130
But notice, I'm not introducing a new concept.

00:12:25,130 --> 00:12:26,290
It's an existing concept.

00:12:26,290 --> 00:12:28,230
I'm just giving you a mental transformation

00:12:28,230 --> 00:12:31,140
that's happening between the double curly

00:12:31,140 --> 00:12:33,340
and the actual binding system.

00:12:33,340 --> 00:12:35,880
At the end of the date, there is but one binding system

00:12:35,880 --> 00:12:38,260
in Angular 2.

00:12:38,260 --> 00:12:40,494
Now there's an interesting set of things that happen.

00:12:40,494 --> 00:12:41,910
For example, in Angular 1, there's

00:12:41,910 --> 00:12:43,600
been this thing called ng-bind, which

00:12:43,600 --> 00:12:46,560
allows you to write the text of an element.

00:12:46,560 --> 00:12:48,480
Notice how in Angular 2, we don't actually

00:12:48,480 --> 00:12:49,540
need this directive.

00:12:49,540 --> 00:12:52,810
It's just a binding to the text of the element.

00:12:52,810 --> 00:12:56,190
Now I don't know about you, but whenever I design something

00:12:56,190 --> 00:12:59,010
and in the process I come up with a new system which

00:12:59,010 --> 00:13:02,020
allows me to get rid of a whole bunch of previous concepts,

00:13:02,020 --> 00:13:03,790
I'm super excited.

00:13:03,790 --> 00:13:06,310
So when I saw this particle property emerge, I was like,

00:13:06,310 --> 00:13:07,410
yes, this is awesome!

00:13:07,410 --> 00:13:08,479
This is amazing.

00:13:08,479 --> 00:13:10,020
I don't need to have ng-bind element.

00:13:10,020 --> 00:13:12,240
It's not that we're not giving you the power.

00:13:12,240 --> 00:13:14,880
It's that it's fundamentally not needed, because you can

00:13:14,880 --> 00:13:16,300
express this syntax directly.

00:13:16,300 --> 00:13:18,008
Now there's a whole bunch of other things

00:13:18,008 --> 00:13:18,970
that this happens with.

00:13:18,970 --> 00:13:21,590
Ng-bind HTML is just inner-html.

00:13:21,590 --> 00:13:23,810
And my favorite is this one.

00:13:23,810 --> 00:13:26,470
Did you know that every DOM element

00:13:26,470 --> 00:13:28,520
has a property called hidden?

00:13:28,520 --> 00:13:31,750
And if you set it to True the element hides?

00:13:31,750 --> 00:13:34,670
Well, why do we have ng-hidden then, or ng-hide?

00:13:34,670 --> 00:13:37,390
It's just a hidden binding, right?

00:13:37,390 --> 00:13:42,500
And it turns out, there's about 16 different directives

00:13:42,500 --> 00:13:45,530
that we have in Angular 1 to deal specifically

00:13:45,530 --> 00:13:46,330
with these cases.

00:13:46,330 --> 00:13:48,560
So all of these directives fundamentally

00:13:48,560 --> 00:13:50,350
just disappear in Angular 2.

00:13:50,350 --> 00:13:52,864


00:13:52,864 --> 00:13:54,280
Now let's talk about the next one.

00:13:54,280 --> 00:13:58,140
So binding was a way of getting the data from the model

00:13:58,140 --> 00:13:59,917
to the UI for the rendering.

00:13:59,917 --> 00:14:01,500
There's also the second problem, which

00:14:01,500 --> 00:14:04,750
is, how do we get data from the UI back to the model,

00:14:04,750 --> 00:14:07,550
or back to the controllers?

00:14:07,550 --> 00:14:11,250
Now in Angular 1, there is this interesting example you can do.

00:14:11,250 --> 00:14:13,585
So I made up a component called Component.

00:14:13,585 --> 00:14:16,210
And it has a select equals, and there's an expression in there.

00:14:16,210 --> 00:14:18,034
It turns out there's three different ways

00:14:18,034 --> 00:14:19,700
you can interpret this particular thing.

00:14:19,700 --> 00:14:24,150
And this is what makes, in my opinion, the Angular 1

00:14:24,150 --> 00:14:26,390
a little more complicated to tool,

00:14:26,390 --> 00:14:29,100
is because the tools have a really hard time telling which

00:14:29,100 --> 00:14:30,830
of the three cases this is.

00:14:30,830 --> 00:14:32,920
So case number one, it could be that

00:14:32,920 --> 00:14:35,110
what the author of the component, not

00:14:35,110 --> 00:14:38,920
the author of the HTML, but the author of the component, what

00:14:38,920 --> 00:14:42,740
they meant is that there's some property called Select.

00:14:42,740 --> 00:14:46,010
And that property is bound to the user.name current

00:14:46,010 --> 00:14:46,650
expression.

00:14:46,650 --> 00:14:49,774
So as the user.name current expression changes,

00:14:49,774 --> 00:14:51,940
the select property inside of the component changes.

00:14:51,940 --> 00:14:53,089
So that's use case one.

00:14:53,089 --> 00:14:54,880
The use case two is, they could have set up

00:14:54,880 --> 00:14:56,370
a bidirectional data binding.

00:14:56,370 --> 00:14:58,330
In which case, what I just said holds.

00:14:58,330 --> 00:15:00,420
So the user.name gets executed all the time

00:15:00,420 --> 00:15:01,920
as part of the digest cycle.

00:15:01,920 --> 00:15:05,520
But in addition to it, sometimes, the component

00:15:05,520 --> 00:15:08,770
gets to write to its property, in which case, we will actually

00:15:08,770 --> 00:15:11,250
assign to this particular expression.

00:15:11,250 --> 00:15:15,070
So this actually could have a side effect, sometimes.

00:15:15,070 --> 00:15:16,780
And then there's a third mode, where

00:15:16,780 --> 00:15:19,700
the way to think about Select is not that it's a property,

00:15:19,700 --> 00:15:20,870
but rather it's an event.

00:15:20,870 --> 00:15:24,680
That a component, upon user action, like selection,

00:15:24,680 --> 00:15:26,750
the component says, I have been selected.

00:15:26,750 --> 00:15:29,780
And so it will execute this particular expression.

00:15:29,780 --> 00:15:32,350
And this is the crux of the problem.

00:15:32,350 --> 00:15:36,500
It's like you, as a person who's writing this particular

00:15:36,500 --> 00:15:40,390
template, or the person who's reading an existing template,

00:15:40,390 --> 00:15:44,290
you cannot tell which of the three of these modes is going

00:15:44,290 --> 00:15:45,150
to happen in there.

00:15:45,150 --> 00:15:46,365
And it's not just you.

00:15:46,365 --> 00:15:48,960
It's also the tools cannot tell.

00:15:48,960 --> 00:15:50,400
And this makes tooling difficult,

00:15:50,400 --> 00:15:53,300
and it makes it also difficult to read and understand

00:15:53,300 --> 00:15:55,624
and reason about what's going on.

00:15:55,624 --> 00:15:58,290
So we're going to split that up, and we're going to say, no, no.

00:15:58,290 --> 00:16:01,320
Bindings, DOS, is what we have seen earlier,

00:16:01,320 --> 00:16:04,370
we will use the bracket syntax to say this is an expression.

00:16:04,370 --> 00:16:07,177
That is, we will dirty watch this expression all the time.

00:16:07,177 --> 00:16:08,760
And when the expression changes, we'll

00:16:08,760 --> 00:16:10,430
update the Select property.

00:16:10,430 --> 00:16:11,910
If you want the other kind, which

00:16:11,910 --> 00:16:14,420
is that when a component changes,

00:16:14,420 --> 00:16:19,150
when a component has becomes selected and it fires an event,

00:16:19,150 --> 00:16:20,600
we have the second syntax.

00:16:20,600 --> 00:16:23,780
And in this particular case, what you put in there,

00:16:23,780 --> 00:16:26,030
is we're going to call it a statement.

00:16:26,030 --> 00:16:27,930
Now they look identical, but they actually

00:16:27,930 --> 00:16:29,440
have different behavior.

00:16:29,440 --> 00:16:31,222
So let's have a look.

00:16:31,222 --> 00:16:33,180
First of all, I'm showing you the two syntaxes.

00:16:33,180 --> 00:16:36,070


00:16:36,070 --> 00:16:37,710
Whatever.

00:16:37,710 --> 00:16:39,530
You can see that I'm showing you also

00:16:39,530 --> 00:16:43,270
the pure alphanumeric version of it, up there, as well.

00:16:43,270 --> 00:16:45,550
But here's the thing.

00:16:45,550 --> 00:16:47,650
When does the expression get executed?

00:16:47,650 --> 00:16:49,750
So the expressions get executed all the time

00:16:49,750 --> 00:16:51,362
as part of the change detection.

00:16:51,362 --> 00:16:53,070
Whereas, the statements only get executed

00:16:53,070 --> 00:16:57,030
as part of a user action, part of an event.

00:16:57,030 --> 00:16:58,797
Side effects wise, the expressions

00:16:58,797 --> 00:17:00,630
should have no side effects, because they're

00:17:00,630 --> 00:17:01,480
executed all the time.

00:17:01,480 --> 00:17:02,938
And you don't know when they really

00:17:02,938 --> 00:17:04,150
should not have side effects.

00:17:04,150 --> 00:17:07,640
On the other hand, a statement is all about a side effect.

00:17:07,640 --> 00:17:09,930
If you have a statement that has no side effect,

00:17:09,930 --> 00:17:11,903
that statement could essentially be removed

00:17:11,903 --> 00:17:13,319
and it doesn't do anything, right?

00:17:13,319 --> 00:17:15,319
So a statement is all about having side effects.

00:17:15,319 --> 00:17:16,902
Now there's interesting things that we

00:17:16,902 --> 00:17:18,990
can do about these distinctions, which is,

00:17:18,990 --> 00:17:20,650
for example, null suppression.

00:17:20,650 --> 00:17:23,740
Null suppression is wonderful inside of double curlies,

00:17:23,740 --> 00:17:25,885
but it's actually counterproductive

00:17:25,885 --> 00:17:26,760
inside of statements.

00:17:26,760 --> 00:17:29,540
Because you register a listener, you start clicking on it

00:17:29,540 --> 00:17:31,650
and nothing is happening, you don't know why.

00:17:31,650 --> 00:17:33,330
And it's because we're null suppressing.

00:17:33,330 --> 00:17:34,850
So we can actually tell them apart.

00:17:34,850 --> 00:17:36,440
And finally, when you have statements,

00:17:36,440 --> 00:17:37,400
you can use a semicolon.

00:17:37,400 --> 00:17:39,170
But you cannot use a semicolon with expressions.

00:17:39,170 --> 00:17:40,711
So the expression has to be something

00:17:40,711 --> 00:17:42,800
that evaluates to a value.

00:17:42,800 --> 00:17:44,770
And by separating these things out,

00:17:44,770 --> 00:17:49,270
again, it's easier reason about these things.

00:17:49,270 --> 00:17:50,980
Now this set of directives actually gets

00:17:50,980 --> 00:17:52,290
to get rid of more directives.

00:17:52,290 --> 00:17:54,350
So things like blur, change, checked,

00:17:54,350 --> 00:17:57,686
all of these events systems that we have and that we have added,

00:17:57,686 --> 00:18:00,060
all of these things are actually unneeded because they're

00:18:00,060 --> 00:18:01,860
covered directly by the syntax.

00:18:01,860 --> 00:18:04,090
So another-- I think there's about 20 directives that

00:18:04,090 --> 00:18:04,840
can be removed.

00:18:04,840 --> 00:18:09,281


00:18:09,281 --> 00:18:10,780
Now let's talk about one last thing.

00:18:10,780 --> 00:18:14,890
Remember how I said the elements have properties, events,

00:18:14,890 --> 00:18:17,074
and methods?

00:18:17,074 --> 00:18:18,990
Well, we already covered the first two, right?

00:18:18,990 --> 00:18:20,500
The properties and events.

00:18:20,500 --> 00:18:22,520
So how do we cover the methods?

00:18:22,520 --> 00:18:24,870
So it turns out, we already have an expression system

00:18:24,870 --> 00:18:25,911
that it can call methods.

00:18:25,911 --> 00:18:28,140
And we do this all the time inside of our expressions

00:18:28,140 --> 00:18:29,230
and statements.

00:18:29,230 --> 00:18:31,600
The trouble is, we can't get a hold of it.

00:18:31,600 --> 00:18:33,617
So let's look at this example in Angular 1.

00:18:33,617 --> 00:18:35,700
Suppose you have a button and when you click on it

00:18:35,700 --> 00:18:38,700
you want to put something else in focus.

00:18:38,700 --> 00:18:40,450
There's already a method called focus that

00:18:40,450 --> 00:18:42,060
does exactly what you want.

00:18:42,060 --> 00:18:44,865
The trouble is, there's no way for you to get a hold of it.

00:18:44,865 --> 00:18:46,740
And it's not just, you can't get a hold of it

00:18:46,740 --> 00:18:47,652
inside of a template.

00:18:47,652 --> 00:18:49,360
There's really no way to get a hold of it

00:18:49,360 --> 00:18:52,410
inside of the controller either.

00:18:52,410 --> 00:18:55,000
There's no good way of actually injecting this thing so

00:18:55,000 --> 00:18:56,350
that you can get a hold of it.

00:18:56,350 --> 00:18:58,280
And as a result, you probably have

00:18:58,280 --> 00:19:01,090
to do it by writing a custom directive, which

00:19:01,090 --> 00:19:02,374
then gets a hold of the input.

00:19:02,374 --> 00:19:04,040
And then we have some expression changes

00:19:04,040 --> 00:19:08,122
that will focus the input, or something along those lines.

00:19:08,122 --> 00:19:10,080
So the way this is solved is that we introduced

00:19:10,080 --> 00:19:12,110
this concept of a reference.

00:19:12,110 --> 00:19:14,630
So inside of the input, we can now say.

00:19:14,630 --> 00:19:16,630
I am referring to this other input,

00:19:16,630 --> 00:19:18,200
and, therefore, I can focus it.

00:19:18,200 --> 00:19:19,390
I can call methods on it.

00:19:19,390 --> 00:19:20,852
I can call its API.

00:19:20,852 --> 00:19:22,310
And now we have covered everything.

00:19:22,310 --> 00:19:23,435
We have covered properties.

00:19:23,435 --> 00:19:24,450
We have covered events.

00:19:24,450 --> 00:19:26,450
And we have covered methods.

00:19:26,450 --> 00:19:29,480
But an interesting thing happens when you explicitly

00:19:29,480 --> 00:19:31,610
declare variables.

00:19:31,610 --> 00:19:34,990
Can you spot all the errors in here?

00:19:34,990 --> 00:19:35,990
There's six of them.

00:19:35,990 --> 00:19:38,080
I'm going to highlight them for you.

00:19:38,080 --> 00:19:40,630
Different things will be called either

00:19:40,630 --> 00:19:43,420
because there's no suppression, and so nothing will happen.

00:19:43,420 --> 00:19:46,430
Or there's a typo, and nothing will happen.

00:19:46,430 --> 00:19:47,140
And so on.

00:19:47,140 --> 00:19:51,610
But inside of Angular 2, because we get to declare ahead of time

00:19:51,610 --> 00:19:55,880
the references, we can actually catch a particular thing.

00:19:55,880 --> 00:19:57,915
We can look at the div and say, hey,

00:19:57,915 --> 00:19:59,930
there is no property called tytle,

00:19:59,930 --> 00:20:01,964
spelled with a y on a div.

00:20:01,964 --> 00:20:03,130
You probably made a mistake.

00:20:03,130 --> 00:20:05,530
And we can give you this error immediately.

00:20:05,530 --> 00:20:08,610
We can look at the usor, mistyped again,

00:20:08,610 --> 00:20:11,120
and we can look at the controller.

00:20:11,120 --> 00:20:14,540
And we can say, hey, there is no property called usor

00:20:14,540 --> 00:20:15,270
on a controller.

00:20:15,270 --> 00:20:16,978
And we can give you an error immediately,

00:20:16,978 --> 00:20:18,570
and so on and so forth.

00:20:18,570 --> 00:20:21,400
So with these changes, we can actually

00:20:21,400 --> 00:20:24,230
give you useful error messages, rather than having

00:20:24,230 --> 00:20:25,301
the application not work.

00:20:25,301 --> 00:20:26,800
And I'm sure, then, most of you guys

00:20:26,800 --> 00:20:28,925
are going to be excited about this particular part.

00:20:28,925 --> 00:20:31,430
[APPLAUSE]

00:20:31,430 --> 00:20:35,430


00:20:35,430 --> 00:20:38,220
So let me reiterate this again.

00:20:38,220 --> 00:20:41,150
The DOM elements have three properties.

00:20:41,150 --> 00:20:43,170
There's three things, three APis, right?

00:20:43,170 --> 00:20:45,349
There's properties, events, and methods.

00:20:45,349 --> 00:20:46,890
And on the JavaScript side, I'm going

00:20:46,890 --> 00:20:49,490
to show you, what would you do in something like jQuery?

00:20:49,490 --> 00:20:51,400
You would simply write to the property

00:20:51,400 --> 00:20:52,451
using the square bracket.

00:20:52,451 --> 00:20:54,200
Now you can see where the square is coming

00:20:54,200 --> 00:20:56,040
from inside of our syntax.

00:20:56,040 --> 00:20:57,910
You can set up, add event listeners, which

00:20:57,910 --> 00:21:00,320
is a function call, hence the parentheses

00:21:00,320 --> 00:21:01,850
on the syntax over here.

00:21:01,850 --> 00:21:04,280
Or you could just refer to it as a variable.

00:21:04,280 --> 00:21:06,650
And this seems kind of like a no-op.

00:21:06,650 --> 00:21:09,400
But the key over here is, by being able to refer to it,

00:21:09,400 --> 00:21:10,910
I can call methods.

00:21:10,910 --> 00:21:13,450
And so we have these three ways covered inside

00:21:13,450 --> 00:21:15,020
of the Angular 1 syntax.

00:21:15,020 --> 00:21:16,700
This is much easier to understand.

00:21:16,700 --> 00:21:20,810
There's fewer rules and fewer exceptions.

00:21:20,810 --> 00:21:23,380
And a nice thing is, the Web Components really

00:21:23,380 --> 00:21:24,080
start to happen.

00:21:24,080 --> 00:21:26,500
So suppose you want to do a web component in Angular 1.x.

00:21:26,500 --> 00:21:28,280
You might write something like this.

00:21:28,280 --> 00:21:29,900
But this actually isn't going to work.

00:21:29,900 --> 00:21:32,760
First of all, the ID equals V, well, that's

00:21:32,760 --> 00:21:35,220
going to put it on a window, not actually on your scope.

00:21:35,220 --> 00:21:36,928
So you won't be able to get a hold of it.

00:21:36,928 --> 00:21:40,280
So you won't be able to say something like, v.play.

00:21:40,280 --> 00:21:41,980
The next thing is, if you want to bind

00:21:41,980 --> 00:21:46,510
do a attribute called video ID, this may or may not work,

00:21:46,510 --> 00:21:49,650
depending on whether the Web Component author has decided

00:21:49,650 --> 00:21:52,310
to set up a DOM listener event.

00:21:52,310 --> 00:21:55,250
Now it is possible that set up a DOM listener [INAUDIBLE],

00:21:55,250 --> 00:21:56,990
and this is actually going to work.

00:21:56,990 --> 00:21:59,160
But I have this feeling that in the future, in the world where

00:21:59,160 --> 00:22:01,070
Web Components are going to be happening all the time,

00:22:01,070 --> 00:22:02,694
this is going to actually be considered

00:22:02,694 --> 00:22:05,090
an [INAUDIBLE] pattern, because setting up DOM listeners

00:22:05,090 --> 00:22:06,740
is actually kind of expensive.

00:22:06,740 --> 00:22:11,870
And so I believe most authors will choose against this.

00:22:11,870 --> 00:22:13,730
It's expensive in terms of setting them up.

00:22:13,730 --> 00:22:16,100
And it's also expensive in terms of firing them.

00:22:16,100 --> 00:22:17,990
So even if this would work, I'm not

00:22:17,990 --> 00:22:19,570
sure this is the best way to do it.

00:22:19,570 --> 00:22:22,620
And finally, let's say you want to pass an object that is

00:22:22,620 --> 00:22:24,610
something other than a string.

00:22:24,610 --> 00:22:28,690
In here, in this example, the head attribute

00:22:28,690 --> 00:22:30,370
is going to be written as a string.

00:22:30,370 --> 00:22:34,040
And so the information of the object actually gets destroyed.

00:22:34,040 --> 00:22:36,762
And so there's no way to actually pass

00:22:36,762 --> 00:22:38,970
things other than strings into this particular thing.

00:22:38,970 --> 00:22:41,190
And finally, there's no such thing as ng stayed.

00:22:41,190 --> 00:22:43,550
We don't know what events the Web Component

00:22:43,550 --> 00:22:45,149
is going to fire in the future.

00:22:45,149 --> 00:22:47,690
And as a result, we cannot give you all of the directives are

00:22:47,690 --> 00:22:48,700
ahead of time.

00:22:48,700 --> 00:22:51,360
There could be endless number of these events, custom events

00:22:51,360 --> 00:22:52,790
the component might fire.

00:22:52,790 --> 00:22:55,837
And so, while you would want to write this in Angular 1.x,

00:22:55,837 --> 00:22:56,920
this is not going to work.

00:22:56,920 --> 00:22:57,856
But look at Angular 2.

00:22:57,856 --> 00:23:00,230
This is what, essentially, you would like to write inside

00:23:00,230 --> 00:23:01,140
of the code, right?

00:23:01,140 --> 00:23:02,080
You get a hold of it.

00:23:02,080 --> 00:23:03,200
You assign the properties to it.

00:23:03,200 --> 00:23:04,116
You set up a listener.

00:23:04,116 --> 00:23:05,440
You call a method on it, right?

00:23:05,440 --> 00:23:06,440
It's that simple.

00:23:06,440 --> 00:23:09,900
We can express the same exact thing in the Angular 2 syntax.

00:23:09,900 --> 00:23:11,540
We can use the click with parentheses

00:23:11,540 --> 00:23:12,570
to say this is an event.

00:23:12,570 --> 00:23:15,260
If you click on it, please call v. Where is v coming from?

00:23:15,260 --> 00:23:18,110
Well, there's a hash wheel that says it's right over here.

00:23:18,110 --> 00:23:20,800
The videoid is bound to a property.

00:23:20,800 --> 00:23:21,940
But so is a state.

00:23:21,940 --> 00:23:25,270
And as a result, state can have things other than strings.

00:23:25,270 --> 00:23:26,540
You can have real objects.

00:23:26,540 --> 00:23:29,380
And finally, we can bind to any custom event

00:23:29,380 --> 00:23:31,370
that you can possibly imagine.

00:23:31,370 --> 00:23:33,840
We can call methods on it.

00:23:33,840 --> 00:23:36,040
Now, there's one thing we have not talked about,

00:23:36,040 --> 00:23:36,998
and that's Microsyntax.

00:23:36,998 --> 00:23:39,532
And this thing, this was a tough nut to crack.

00:23:39,532 --> 00:23:40,990
We spent many, many months thinking

00:23:40,990 --> 00:23:43,140
about this particular thing.

00:23:43,140 --> 00:23:44,030
Here's the problem.

00:23:44,030 --> 00:23:45,790
If you have something like ng-repeat,

00:23:45,790 --> 00:23:47,280
there's item in items.

00:23:47,280 --> 00:23:50,740
Well it turns out, item in items is

00:23:50,740 --> 00:23:54,660
neither a literal nor an expression, nor a keyword.

00:23:54,660 --> 00:23:56,350
Like, what is this thing?

00:23:56,350 --> 00:23:58,017
I can't put it inside of a double curly.

00:23:58,017 --> 00:23:59,058
That's not going to work.

00:23:59,058 --> 00:24:00,480
That's going to blow up, right?

00:24:00,480 --> 00:24:01,740
So what is this?

00:24:01,740 --> 00:24:03,410
Well, it turns out, what ng-repeat

00:24:03,410 --> 00:24:06,080
does is it runs it through a regex and it cuts things out.

00:24:06,080 --> 00:24:07,610
So in a key word.

00:24:07,610 --> 00:24:09,810
Item is going to be a new variable that's

00:24:09,810 --> 00:24:10,790
going to be declared.

00:24:10,790 --> 00:24:12,490
And items is an expression.

00:24:12,490 --> 00:24:16,430
Can we express this in a simpler way

00:24:16,430 --> 00:24:18,520
that doesn't require this complicated parsing

00:24:18,520 --> 00:24:19,420
and understanding?

00:24:19,420 --> 00:24:22,560
And you really having to read the ng-repeat documentation

00:24:22,560 --> 00:24:26,410
before you can even understand what part of these microsyntax

00:24:26,410 --> 00:24:27,870
we have?

00:24:27,870 --> 00:24:29,010
Well, it turns out we have.

00:24:29,010 --> 00:24:31,790
So first of all, Web Component defines

00:24:31,790 --> 00:24:33,819
something called a template.

00:24:33,819 --> 00:24:36,360
Now I don't want to go too much into the details of template,

00:24:36,360 --> 00:24:39,250
but it turns out, there's other reasons why this is a good idea

00:24:39,250 --> 00:24:41,060
to have a template tag in here.

00:24:41,060 --> 00:24:44,230
But let's just focus on a microsyntax.

00:24:44,230 --> 00:24:46,850
We are thinking about renaming ng-repeat to foreach.

00:24:46,850 --> 00:24:49,210
So let's just go with this for a second.

00:24:49,210 --> 00:24:51,220
So let's say it says, foreach.

00:24:51,220 --> 00:24:52,560
Notice it says hash item.

00:24:52,560 --> 00:24:53,310
I can refer to it.

00:24:53,310 --> 00:24:54,309
We know what that means.

00:24:54,309 --> 00:24:55,360
That's a variable, right?

00:24:55,360 --> 00:24:58,180
Because this was already covered in the previous syntax.

00:24:58,180 --> 00:25:01,190
And we know that "in" is going to be a property that's

00:25:01,190 --> 00:25:02,910
bound on an expression.

00:25:02,910 --> 00:25:05,300
So we know that items is an expression.

00:25:05,300 --> 00:25:07,510
Now this is perfectly toolable.

00:25:07,510 --> 00:25:09,524
The tools can look at this, can read this,

00:25:09,524 --> 00:25:11,190
everybody can understand this, everybody

00:25:11,190 --> 00:25:12,720
knows what's happening.

00:25:12,720 --> 00:25:15,130
The only problem is, it is quite wordy.

00:25:15,130 --> 00:25:17,170
Can we do something about the wordiness?

00:25:17,170 --> 00:25:19,720
Well, it turns out we can.

00:25:19,720 --> 00:25:23,000
What we can do is, we can say fundamentally,

00:25:23,000 --> 00:25:25,540
this is the only kind of templating system that Angular

00:25:25,540 --> 00:25:26,685
is going to understand.

00:25:26,685 --> 00:25:28,810
But we're going to give you a shorthand syntax that

00:25:28,810 --> 00:25:30,639
directly translates into this.

00:25:30,639 --> 00:25:31,930
Now what is a shorthand syntax?

00:25:31,930 --> 00:25:34,370
A shorthand syntax is to simply say,

00:25:34,370 --> 00:25:36,630
any element can have a template.

00:25:36,630 --> 00:25:38,670
And you can place key value pairs

00:25:38,670 --> 00:25:41,186
of these bindings that were on the element down to here.

00:25:41,186 --> 00:25:43,310
And as you can see, they're separated by semicolons

00:25:43,310 --> 00:25:44,712
and they have equal signs.

00:25:44,712 --> 00:25:46,170
And so there's a direct translation

00:25:46,170 --> 00:25:49,830
from this syntax to the previous one, which is fully

00:25:49,830 --> 00:25:52,290
toolable, fully understandable.

00:25:52,290 --> 00:25:54,810
Nothing is complicated in there.

00:25:54,810 --> 00:25:56,220
But could we do even better?

00:25:56,220 --> 00:25:58,490
Well, one thing we can do is, it turns out

00:25:58,490 --> 00:26:01,800
that tools and humans can still understand this if we drop

00:26:01,800 --> 00:26:03,670
the semicolons and equal signs.

00:26:03,670 --> 00:26:05,830
And so now just says foreach item in items,

00:26:05,830 --> 00:26:08,020
and we still know what is going on.

00:26:08,020 --> 00:26:09,160
But we can do even better.

00:26:09,160 --> 00:26:10,600
Which is, we can take the foreach

00:26:10,600 --> 00:26:12,310
and move it to the other side and just

00:26:12,310 --> 00:26:14,850
leave a star behind to let us know, this is a template.

00:26:14,850 --> 00:26:17,110
This requires this set of transformations

00:26:17,110 --> 00:26:19,780
to happen before we can reason about it.

00:26:19,780 --> 00:26:21,530
And so this is the shorthand syntax.

00:26:21,530 --> 00:26:23,960
And notice, nothing here is special.

00:26:23,960 --> 00:26:25,914
It's not like the ng-repeat has to do

00:26:25,914 --> 00:26:28,080
a complicated set of parsings or anything like that.

00:26:28,080 --> 00:26:30,413
Or if you wanted to write your own custom directive that

00:26:30,413 --> 00:26:34,260
does these things, you can just set up a key value

00:26:34,260 --> 00:26:36,900
pair with variables that you're exporting,

00:26:36,900 --> 00:26:39,170
and you know what's happening.

00:26:39,170 --> 00:26:41,270
So in this particular case, it becomes very clear

00:26:41,270 --> 00:26:44,240
that the item is actually referring to the item

00:26:44,240 --> 00:26:46,330
that the foreach is exporting.

00:26:46,330 --> 00:26:48,290
And it actually helps with tooling.

00:26:48,290 --> 00:26:50,129
It actually helps with speed.

00:26:50,129 --> 00:26:51,670
We can do all kinds of optimizations,

00:26:51,670 --> 00:26:53,100
if you know these things.

00:26:53,100 --> 00:26:56,810
And it's part of the reason why Angular 2 is faster.

00:26:56,810 --> 00:26:59,580
So really, the goal here is to have a simpler syntax

00:26:59,580 --> 00:27:01,070
so it's easier to understand.

00:27:01,070 --> 00:27:02,450
It's predictable, so it's faster.

00:27:02,450 --> 00:27:04,949
And it's toolable, so you can have more amazing tool wonders

00:27:04,949 --> 00:27:07,802
building more amazing ways of having

00:27:07,802 --> 00:27:09,010
easier to build applications.

00:27:09,010 --> 00:27:11,760
So at this point, I'm going to welcome Rado Kirov.

00:27:11,760 --> 00:27:13,370
He's one of our core team members.

00:27:13,370 --> 00:27:14,953
And we're going to show you, actually,

00:27:14,953 --> 00:27:16,910
a working application.

00:27:16,910 --> 00:27:18,234
So--

00:27:18,234 --> 00:27:20,082
[APPLAUSE]

00:27:20,082 --> 00:27:22,860


00:27:22,860 --> 00:27:24,810
RADO KIROV: Thank you, Misko.

00:27:24,810 --> 00:27:26,790
So we've been working really hard on Angular 2

00:27:26,790 --> 00:27:27,850
for the last few months.

00:27:27,850 --> 00:27:29,600
And I'm very excited to be here, and to be

00:27:29,600 --> 00:27:33,570
able to actually show you a demo Angular 2 running in a browser.

00:27:33,570 --> 00:27:36,500
So let's take a look at it.

00:27:36,500 --> 00:27:39,710
So what we have here is a sample application that

00:27:39,710 --> 00:27:43,030
takes a YouTube search term, searches for all the videos

00:27:43,030 --> 00:27:45,272
that contain that search term.

00:27:45,272 --> 00:27:49,880
You can see them all rendered in nice material design cards.

00:27:49,880 --> 00:27:53,680
For each video, we see a thumbnail, some stats,

00:27:53,680 --> 00:27:55,750
a description of the video.

00:27:55,750 --> 00:27:58,680
If I click on the thumbnail, I get an actual player.

00:27:58,680 --> 00:28:00,630
I can play the video.

00:28:00,630 --> 00:28:02,190
I can pause it.

00:28:02,190 --> 00:28:04,530
And finally, if I like it, or I dislike it,

00:28:04,530 --> 00:28:06,440
I can click the little thumb icons.

00:28:06,440 --> 00:28:08,800
Obviously, I really like this one.

00:28:08,800 --> 00:28:10,900
So what we're going to do next is

00:28:10,900 --> 00:28:12,740
we're going to go through how we built

00:28:12,740 --> 00:28:16,520
this application in Angular 2.

00:28:16,520 --> 00:28:19,094
And walk you through the steps of building it.

00:28:19,094 --> 00:28:20,510
MISKO HEVERY: So every application

00:28:20,510 --> 00:28:22,730
starts with index.html.

00:28:22,730 --> 00:28:24,780
And this is our index.html.

00:28:24,780 --> 00:28:26,840
Now Angular 2 is still in the early versions.

00:28:26,840 --> 00:28:32,160
And so we haven't simplified the scripts tags and CSS tags

00:28:32,160 --> 00:28:33,250
that you have to include.

00:28:33,250 --> 00:28:34,840
Rest assured, we're going to work on that.

00:28:34,840 --> 00:28:36,423
So if you look at, check out the demo,

00:28:36,423 --> 00:28:38,710
please just kind of glance over that particular part.

00:28:38,710 --> 00:28:41,760
But once you set up all of the imports and all the scripts,

00:28:41,760 --> 00:28:44,230
the question becomes, how do I bootstrap this thing?

00:28:44,230 --> 00:28:46,600
Now in here, we have a tag call App.

00:28:46,600 --> 00:28:48,570
Now in Angular 1.x, ng-app.

00:28:48,570 --> 00:28:49,790
Here, we just have an app.

00:28:49,790 --> 00:28:51,860
And it has some content inside of it.

00:28:51,860 --> 00:28:53,410
App is in no way special.

00:28:53,410 --> 00:28:54,870
Not like ng-app in Angular.

00:28:54,870 --> 00:28:56,410
We could have called it a div.

00:28:56,410 --> 00:28:57,910
It doesn't matter what is over here.

00:28:57,910 --> 00:28:59,670
We just chose app, and it's a component.

00:28:59,670 --> 00:29:03,110
Now in Angular 2, we kind of simplified

00:29:03,110 --> 00:29:04,360
the concept of an application.

00:29:04,360 --> 00:29:05,570
We have a concept of an application,

00:29:05,570 --> 00:29:08,060
but there's no concrete thing we call an application,

00:29:08,060 --> 00:29:09,330
like an Angular 1.x.

00:29:09,330 --> 00:29:11,514
Instead, what we have is a top level component.

00:29:11,514 --> 00:29:13,430
And Rado is going to show you what a top level

00:29:13,430 --> 00:29:14,710
component looks like.

00:29:14,710 --> 00:29:17,760
RADO KIROV: So let's take a look at the application component.

00:29:17,760 --> 00:29:18,620
So here it is.

00:29:18,620 --> 00:29:22,591
Application is just ES6 class.

00:29:22,591 --> 00:29:23,590
MISKO HEVERY: I'm sorry.

00:29:23,590 --> 00:29:26,424
Let me just point out, we're showing you

00:29:26,424 --> 00:29:29,090
the demo in type script, because we're excited about this stuff.

00:29:29,090 --> 00:29:32,510
You can write this stuff in ES5, if you choose.

00:29:32,510 --> 00:29:34,750
We're not forcing you, in any way,

00:29:34,750 --> 00:29:38,820
to use any kind of translation or compilation or extra step.

00:29:38,820 --> 00:29:42,340
This could be done in purely good old JavaScript five.

00:29:42,340 --> 00:29:43,644
But you get other benefits.

00:29:43,644 --> 00:29:44,560
RADO KIROV: All right.

00:29:44,560 --> 00:29:47,460
So back to the application components.

00:29:47,460 --> 00:29:48,860
It is an ES6 glass.

00:29:48,860 --> 00:29:50,972
And it has two annotations.

00:29:50,972 --> 00:29:52,430
We heard yesterday that annotations

00:29:52,430 --> 00:29:54,290
are coming to type scripts.

00:29:54,290 --> 00:29:56,650
So the way you think about those two annotations,

00:29:56,650 --> 00:30:00,160
they're just syntactic sugar to attach some metadata

00:30:00,160 --> 00:30:02,860
to this application class.

00:30:02,860 --> 00:30:04,740
So the first one is the component annotation.

00:30:04,740 --> 00:30:07,530
That's what does Angular, this application class

00:30:07,530 --> 00:30:09,980
is actually a Angular component.

00:30:09,980 --> 00:30:11,430
It contains a selector.

00:30:11,430 --> 00:30:13,140
The selector is just a CSS selector.

00:30:13,140 --> 00:30:15,610
Tells you where, in the HTML, the components

00:30:15,610 --> 00:30:17,250
will get triggered.

00:30:17,250 --> 00:30:20,250
Then we have a configuration for dependency injection

00:30:20,250 --> 00:30:22,090
through component service.

00:30:22,090 --> 00:30:25,790
So we all love dependency injection in Angular 1.

00:30:25,790 --> 00:30:29,230
It's here to stay in Angular 2.

00:30:29,230 --> 00:30:31,150
Dependency injection is what will

00:30:31,150 --> 00:30:34,700
construct the actual application instance.

00:30:34,700 --> 00:30:36,810
So this is just a configuration for it.

00:30:36,810 --> 00:30:38,550
Next, we have the template annotation,

00:30:38,550 --> 00:30:40,630
where we've specified a visual representation

00:30:40,630 --> 00:30:41,970
of the component.

00:30:41,970 --> 00:30:46,384
We have some HTML that would be put in place for the component.

00:30:46,384 --> 00:30:48,050
And then we have the directives that are

00:30:48,050 --> 00:30:50,610
active within that template.

00:30:50,610 --> 00:30:53,500
If you're wondering why our components and templates

00:30:53,500 --> 00:30:56,140
annotations split, that is because we

00:30:56,140 --> 00:30:59,820
might want to have many to one mapping between components

00:30:59,820 --> 00:31:01,280
and templates.

00:31:01,280 --> 00:31:03,380
One component might be backed by two or three

00:31:03,380 --> 00:31:05,766
different templates, depending on whether we

00:31:05,766 --> 00:31:08,470
want to serve the application for mobile, or desktop,

00:31:08,470 --> 00:31:10,740
or you want to do an AB test.

00:31:10,740 --> 00:31:13,960
So let's bootstrap the application.

00:31:13,960 --> 00:31:17,130
So I'm going to come here in the main methods and type

00:31:17,130 --> 00:31:17,750
bootstrap.

00:31:17,750 --> 00:31:19,192
That we know from Angular 1.

00:31:19,192 --> 00:31:20,650
And the difference for Angular 2 is

00:31:20,650 --> 00:31:23,475
we're just going to pass this top level component.

00:31:23,475 --> 00:31:25,850
MISKO HEVERY: So notice how in Angular 1 you have to pass

00:31:25,850 --> 00:31:28,641
and all kinds of module definition information

00:31:28,641 --> 00:31:30,890
to get your application going and set up the injector.

00:31:30,890 --> 00:31:32,490
Turns out, all of that information

00:31:32,490 --> 00:31:34,572
is encapsulated into the component.

00:31:34,572 --> 00:31:36,655
And there's nothing extra special that can happen.

00:31:36,655 --> 00:31:38,950
We just have chosen this particular component

00:31:38,950 --> 00:31:40,690
to be our top level component.

00:31:40,690 --> 00:31:42,920
Now the other thing to point out is that, it

00:31:42,920 --> 00:31:44,380
said, loading, please wait.

00:31:44,380 --> 00:31:45,650
Notice that it's still there.

00:31:45,650 --> 00:31:50,720
We just added a shadow root to the application.

00:31:50,720 --> 00:31:54,316
And the content tag is a replacement of transclusion.

00:31:54,316 --> 00:31:58,050


00:31:58,050 --> 00:32:01,430
And so we're retiring the concept of transclusion

00:32:01,430 --> 00:32:04,580
in favor of Web Components in the shadow DOM standard.

00:32:04,580 --> 00:32:06,258
AUDIENCE: Whew!

00:32:06,258 --> 00:32:08,940
[APPLAUSE]

00:32:08,940 --> 00:32:11,862
I really want to know what next year's [INAUDIBLE] talk is

00:32:11,862 --> 00:32:13,778
going to be about, now that he cannot make fun

00:32:13,778 --> 00:32:17,454
of transclusion.

00:32:17,454 --> 00:32:18,370
RADO KIROV: All right.

00:32:18,370 --> 00:32:19,725
So let's continue building this application.

00:32:19,725 --> 00:32:21,100
MISKO HEVERY: I'm sure he's going

00:32:21,100 --> 00:32:22,869
to find something, though.

00:32:22,869 --> 00:32:25,160
RADO KIROV: So we go back to the application component,

00:32:25,160 --> 00:32:28,770
and the template you have so far is not very feature full.

00:32:28,770 --> 00:32:33,030
Let's replace it with an actual good looking template.

00:32:33,030 --> 00:32:34,520
So what I'm doing right now is, I'm

00:32:34,520 --> 00:32:37,180
switching to this application HTML template

00:32:37,180 --> 00:32:39,280
that I have already written.

00:32:39,280 --> 00:32:40,840
And before I switch to the template,

00:32:40,840 --> 00:32:42,830
I want to just point out, what do we have

00:32:42,830 --> 00:32:44,710
in the application components?

00:32:44,710 --> 00:32:46,550
We have a fetch method.

00:32:46,550 --> 00:32:51,220
This is what triggers the API code to actually get the set

00:32:51,220 --> 00:32:52,990
the videos I'm looking for.

00:32:52,990 --> 00:32:56,240
And I'm storing them in the videos member variable

00:32:56,240 --> 00:32:57,870
for the application component.

00:32:57,870 --> 00:33:00,140
So now let's switch to a template.

00:33:00,140 --> 00:33:02,800
So in the templates, we see exactly where

00:33:02,800 --> 00:33:04,110
we use the fetch methods.

00:33:04,110 --> 00:33:08,590
We event bind it to the button using the parent syntax

00:33:08,590 --> 00:33:11,210
that Misko described the reasoning behind.

00:33:11,210 --> 00:33:14,340
And once I get my set of videos, I'm

00:33:14,340 --> 00:33:18,360
using, again, the foreach syntax that we saw a little bit

00:33:18,360 --> 00:33:20,012
earlier to iterate over them.

00:33:20,012 --> 00:33:21,970
And for each one of them, I'm displaying so far

00:33:21,970 --> 00:33:24,060
just the title.

00:33:24,060 --> 00:33:27,980
One thing to point out, as you look at this template,

00:33:27,980 --> 00:33:29,610
if you look at all the expressions

00:33:29,610 --> 00:33:32,890
you see, and you think, where are those symbols coming from?

00:33:32,890 --> 00:33:35,430
Where is fetch videos?

00:33:35,430 --> 00:33:39,490
They're all coming straight from the instance of the application

00:33:39,490 --> 00:33:40,510
components.

00:33:40,510 --> 00:33:42,920
There was no other concept or some hashmap

00:33:42,920 --> 00:33:43,930
where they come from.

00:33:43,930 --> 00:33:45,730
They're directly coming from there.

00:33:45,730 --> 00:33:47,480
And there's one extra thing, which

00:33:47,480 --> 00:33:49,530
is, as we're iterating we need to have

00:33:49,530 --> 00:33:52,670
a reference for the current video that we're seeing.

00:33:52,670 --> 00:33:56,050
And I can immediately spot it in the template

00:33:56,050 --> 00:33:58,375
by looking for this pound.

00:33:58,375 --> 00:34:00,000
MISKO HEVERY: So you might be wondering

00:34:00,000 --> 00:34:02,450
what happened to the scope.

00:34:02,450 --> 00:34:05,020
So the scope is kind there, kind of not there.

00:34:05,020 --> 00:34:06,920
Because the execution context for all

00:34:06,920 --> 00:34:10,250
the expressions is just the controller's instance.

00:34:10,250 --> 00:34:12,090
Now in Angular 1.x, we were basically

00:34:12,090 --> 00:34:13,790
recommending that you'd use controller

00:34:13,790 --> 00:34:17,830
as syntax, to make sure that every single expression has

00:34:17,830 --> 00:34:21,370
a dot inside of it, so that the property, the particular read

00:34:21,370 --> 00:34:23,631
versus the local write problem that sometimes occurs

00:34:23,631 --> 00:34:25,880
with the ng model, so that that particular problem can

00:34:25,880 --> 00:34:26,380
be solved.

00:34:26,380 --> 00:34:28,671
It turns out, we solved this problem in a different way

00:34:28,671 --> 00:34:29,500
in Angular 2.

00:34:29,500 --> 00:34:31,920
So we no longer use prototypes for reading and writing.

00:34:31,920 --> 00:34:34,090
And it actually has performance implications,

00:34:34,090 --> 00:34:36,989
which are in the positive way.

00:34:36,989 --> 00:34:40,040
But the scope, as a concept, has really kind of disappeared.

00:34:40,040 --> 00:34:42,870
Instead what we have is, we just purely bind directly

00:34:42,870 --> 00:34:44,030
to the controller instance.

00:34:44,030 --> 00:34:46,100
That means you no longer have to inject scope.

00:34:46,100 --> 00:34:48,141
Or you no longer have to expose yourself and have

00:34:48,141 --> 00:34:50,790
this extra variable that is really, probably,

00:34:50,790 --> 00:34:53,280
everybody always just called it a CTRL.

00:34:53,280 --> 00:34:55,756
So that's simplified, as well.

00:34:55,756 --> 00:34:56,380
RADO KIROV: OK.

00:34:56,380 --> 00:34:59,032
So, so far, we've seen how to create one component.

00:34:59,032 --> 00:35:00,740
The next thing you'll probably want to do

00:35:00,740 --> 00:35:04,160
is create a child component that lives within our parent

00:35:04,160 --> 00:35:05,830
component.

00:35:05,830 --> 00:35:08,030
So let's do that.

00:35:08,030 --> 00:35:09,660
So in my application component, I

00:35:09,660 --> 00:35:12,220
want to include another component, which makes

00:35:12,220 --> 00:35:15,830
the video card look better.

00:35:15,830 --> 00:35:18,440
That is what I call the Search Result component.

00:35:18,440 --> 00:35:20,070
First thing I do is, I activate it

00:35:20,070 --> 00:35:23,430
in my template by adding it to the directors list.

00:35:23,430 --> 00:35:27,500
Next thing is, I come to the template.

00:35:27,500 --> 00:35:30,270
And I start using it.

00:35:30,270 --> 00:35:36,800
It is the actual HTML tag that triggers

00:35:36,800 --> 00:35:38,272
it is called Search Results.

00:35:38,272 --> 00:35:39,855
That just instantiates the components.

00:35:39,855 --> 00:35:41,650
I also want to pass some data to it,

00:35:41,650 --> 00:35:43,489
because have the components without data

00:35:43,489 --> 00:35:44,280
is not very useful.

00:35:44,280 --> 00:35:47,610


00:35:47,610 --> 00:35:50,320
So I pass the video data into it.

00:35:50,320 --> 00:35:54,390
Again, to reiterate what Misko said earlier,

00:35:54,390 --> 00:35:57,440
if you take a look at video right here,

00:35:57,440 --> 00:36:00,210
and if you're wondering, is this a literal or an expression?

00:36:00,210 --> 00:36:02,440
It is immediately clear that this is an expression,

00:36:02,440 --> 00:36:05,850
because of the square brackets we see right in front of it.

00:36:05,850 --> 00:36:07,840
So we know this video is an expression.

00:36:07,840 --> 00:36:10,820
And this expression comes from the variable defined right

00:36:10,820 --> 00:36:11,474
above it.

00:36:11,474 --> 00:36:13,140
MISKO HEVERY: Now you might be wondering

00:36:13,140 --> 00:36:16,340
why Rado had to explicitly import the particular component

00:36:16,340 --> 00:36:17,130
before using it.

00:36:17,130 --> 00:36:19,420
So in Angular 1.x there was a global registry

00:36:19,420 --> 00:36:22,560
of all of the directives that you could use.

00:36:22,560 --> 00:36:25,550
In Angular 2, we're making that register per component.

00:36:25,550 --> 00:36:28,260
And what that allows us to do it to do proper encapsulation.

00:36:28,260 --> 00:36:30,710
You no longer have to worry that if somebody

00:36:30,710 --> 00:36:33,550
imports a directive that has a selector, for example,

00:36:33,550 --> 00:36:34,170
required.

00:36:34,170 --> 00:36:36,130
And you also happen to import a directive that

00:36:36,130 --> 00:36:37,546
has a selector code required, then

00:36:37,546 --> 00:36:39,530
the two selectors will collide.

00:36:39,530 --> 00:36:41,370
The way we tried to solve it in Angular 1.x

00:36:41,370 --> 00:36:43,960
is we made everything prefixed.

00:36:43,960 --> 00:36:46,980
Which is kind of a workaround, rather than a solution.

00:36:46,980 --> 00:36:49,540
This is an actual solution, which imports

00:36:49,540 --> 00:36:51,470
every single thing explicitly.

00:36:51,470 --> 00:36:53,660
And as a result, what you're seeing now is

00:36:53,660 --> 00:36:57,547
there's a lot fewer prefixes of attributes inside of the HTML.

00:36:57,547 --> 00:36:59,130
We think that's actually a good thing.

00:36:59,130 --> 00:37:02,755
But nothing, obviously, stops you from having the prefixes.

00:37:02,755 --> 00:37:05,130
The other thing is, you'll be able to group these things.

00:37:05,130 --> 00:37:07,320
So you wouldn't have to enumerate

00:37:07,320 --> 00:37:08,990
every single directive that you want.

00:37:08,990 --> 00:37:12,280
You can say, typically I use these set of directives

00:37:12,280 --> 00:37:13,230
within my components.

00:37:13,230 --> 00:37:15,040
And now you can just import a single item,

00:37:15,040 --> 00:37:17,784
instead of enumerating every single one of them.

00:37:17,784 --> 00:37:18,700
RADO KIROV: All right.

00:37:18,700 --> 00:37:21,490
So next thing you might want to do

00:37:21,490 --> 00:37:26,040
is, we've seen how we pass data down to your child components.

00:37:26,040 --> 00:37:30,280
You might want to have a way to communicate from the child

00:37:30,280 --> 00:37:33,000
components up to the parent components.

00:37:33,000 --> 00:37:36,090
So data binding only works down to children.

00:37:36,090 --> 00:37:39,080
To communicate back up to do the reverse mechanism,

00:37:39,080 --> 00:37:40,910
we use events.

00:37:40,910 --> 00:37:43,530
So one place I need this in my application

00:37:43,530 --> 00:37:46,410
is when, remember when I click on the thumbs,

00:37:46,410 --> 00:37:48,440
I need to go back up to the parent component

00:37:48,440 --> 00:37:50,660
and update the actual accounts.

00:37:50,660 --> 00:37:52,650
So let's see how to achieve this.

00:37:52,650 --> 00:37:54,430
So I open the thumbs component.

00:37:54,430 --> 00:37:58,820
We see it is an event meter for a change event.

00:37:58,820 --> 00:38:01,850
So now I can come back in the parent component,

00:38:01,850 --> 00:38:05,630
find to where I am using the thumbs component

00:38:05,630 --> 00:38:11,757
and add a change listener that is bound to change event coming

00:38:11,757 --> 00:38:12,840
from the thumbs component.

00:38:12,840 --> 00:38:15,040
And on that change, I am executing

00:38:15,040 --> 00:38:18,230
this statement, which is saying, go

00:38:18,230 --> 00:38:21,870
to the method called thumbs change and reflect

00:38:21,870 --> 00:38:24,425
the changes back.

00:38:24,425 --> 00:38:25,800
MISKO HEVERY: So what's happening

00:38:25,800 --> 00:38:29,200
is that all of the data that is being projected to the UI

00:38:29,200 --> 00:38:31,895
really has one set of bindings, which is the square brackets.

00:38:31,895 --> 00:38:33,770
And all the data that comes back to the model

00:38:33,770 --> 00:38:36,186
has a different kind of binding, which is the parentheses.

00:38:36,186 --> 00:38:38,580
Sometimes I refer to them as the forward and reverse data

00:38:38,580 --> 00:38:39,440
binding.

00:38:39,440 --> 00:38:42,370
And by having this clear separation,

00:38:42,370 --> 00:38:44,800
it turns out that the data going forward,

00:38:44,800 --> 00:38:47,040
which is the ones inside of square brackets,

00:38:47,040 --> 00:38:48,940
becomes uni-directional and becomes

00:38:48,940 --> 00:38:51,170
what we call a directive acyclic graph, which

00:38:51,170 --> 00:38:52,940
means that there are no cycles.

00:38:52,940 --> 00:38:55,480
It is not possible for you to get in the situation

00:38:55,480 --> 00:38:57,724
where one binding will affect another one.

00:38:57,724 --> 00:38:59,640
And because you can't get into this situation,

00:38:59,640 --> 00:39:01,848
we don't have to run the digest cycle more than once.

00:39:01,848 --> 00:39:03,780
So the digest cycle is no longer a cycle.

00:39:03,780 --> 00:39:05,080
It's just a digest phase.

00:39:05,080 --> 00:39:08,240
It becomes exactly once through the digest cycle,

00:39:08,240 --> 00:39:11,780
which has an important, again, more important implications

00:39:11,780 --> 00:39:13,791
for performance.

00:39:13,791 --> 00:39:16,290
The other thing that this does, it make the performance more

00:39:16,290 --> 00:39:19,900
predictable, because you know it's happening exactly once.

00:39:19,900 --> 00:39:21,940
And you don't have to worry about setting

00:39:21,940 --> 00:39:23,015
this thing called a TTL.

00:39:23,015 --> 00:39:24,810
I'm not sure if many people are familiar with it.

00:39:24,810 --> 00:39:27,351
But there's this Time To Live for the scope [INAUDIBLE] cycle

00:39:27,351 --> 00:39:30,010
inside a [INAUDIBLE] and 1.x, which also goes away.

00:39:30,010 --> 00:39:32,410
So this separation makes it easier to read.

00:39:32,410 --> 00:39:35,320
So you can follow whether the data is going to the UI,

00:39:35,320 --> 00:39:37,710
or is having side effects, and it also

00:39:37,710 --> 00:39:41,790
has performance implications, which makes it go faster.

00:39:41,790 --> 00:39:44,265
[APPLAUSE]

00:39:44,265 --> 00:39:47,460


00:39:47,460 --> 00:39:49,260
Glad you like it.

00:39:49,260 --> 00:39:51,190
RADO KIROV: Faster is always better.

00:39:51,190 --> 00:39:54,890
So what we have so far is, we have our data.

00:39:54,890 --> 00:39:55,710
We're showing it.

00:39:55,710 --> 00:39:57,251
We don't have an actual video player.

00:39:57,251 --> 00:39:59,640
If I click on a thumbnail, there's this disappears.

00:39:59,640 --> 00:40:05,250
So I want to add a video player.

00:40:05,250 --> 00:40:06,350
It's a common problem.

00:40:06,350 --> 00:40:09,350
I don't want to reinvent the wheel.

00:40:09,350 --> 00:40:11,100
I want to reuse a component.

00:40:11,100 --> 00:40:12,140
Well, this is Angular 2.

00:40:12,140 --> 00:40:14,260
We don't have that many components written yet.

00:40:14,260 --> 00:40:15,967
We're still in alpha.

00:40:15,967 --> 00:40:17,550
What I happen to notice, though, there

00:40:17,550 --> 00:40:21,090
is a very convenient Web Component

00:40:21,090 --> 00:40:22,840
that is built with the Polymer Library

00:40:22,840 --> 00:40:24,780
it's called Google-YouTube.

00:40:24,780 --> 00:40:25,990
I have its API right here.

00:40:25,990 --> 00:40:29,360
I take a look, it has some properties I can bind to.

00:40:29,360 --> 00:40:31,010
It has some events I can listen to.

00:40:31,010 --> 00:40:32,950
And some methods that I can call.

00:40:32,950 --> 00:40:34,240
That should sound familiar.

00:40:34,240 --> 00:40:37,050
We heard those three fundamental types of APIs

00:40:37,050 --> 00:40:40,680
that Angular components have and Web Components have.

00:40:40,680 --> 00:40:43,720
So I'm going to go right ahead and use it.

00:40:43,720 --> 00:40:50,800
So right here, I am just going to say, Google-YouTube.

00:40:50,800 --> 00:40:52,730
I add it as a HTML tag.

00:40:52,730 --> 00:40:54,970
And that's pretty much all I have to do.

00:40:54,970 --> 00:40:56,827


00:40:56,827 --> 00:40:58,660
MISKO HEVERY: Now what's interesting to know

00:40:58,660 --> 00:41:01,882
is that Angular didn't treat Polymer in any special way.

00:41:01,882 --> 00:41:04,090
We know it's not because we're friends with-- I mean,

00:41:04,090 --> 00:41:05,200
we are friends with Polymer folks.

00:41:05,200 --> 00:41:06,949
But it's not because of that as the reason

00:41:06,949 --> 00:41:08,860
why it works with Polymer.

00:41:08,860 --> 00:41:12,300
It works with Polymer, because we followed the fundamental Web

00:41:12,300 --> 00:41:14,950
Components practices in there.

00:41:14,950 --> 00:41:18,070
And so not just Polymer becomes available, but also Bricks,

00:41:18,070 --> 00:41:20,090
X-Tags, or any other future library that

00:41:20,090 --> 00:41:21,530
chooses to use Web Components.

00:41:21,530 --> 00:41:23,238
So this is kind of the promise of it all.

00:41:23,238 --> 00:41:24,599
And this is very exciting.

00:41:24,599 --> 00:41:26,140
The other thing I wanted to point out

00:41:26,140 --> 00:41:28,056
is that Angular doesn't even know that there's

00:41:28,056 --> 00:41:29,380
a Web Component underneath it.

00:41:29,380 --> 00:41:32,010
All the Angular knows is it has to instantiate

00:41:32,010 --> 00:41:34,360
a particular element at a particular location.

00:41:34,360 --> 00:41:35,344
That's all we know.

00:41:35,344 --> 00:41:36,760
The other thing we know is we have

00:41:36,760 --> 00:41:39,410
to write to certain properties and set up certain listeners.

00:41:39,410 --> 00:41:42,880
And we don't have actually differentiate

00:41:42,880 --> 00:41:46,529
whether that particular element is a native browser element

00:41:46,529 --> 00:41:47,570
or it is a Web Component.

00:41:47,570 --> 00:41:49,470
This is kind of the beauty of it all,

00:41:49,470 --> 00:41:53,070
is that it's completely uniform.

00:41:53,070 --> 00:41:54,970
RADO KIROV: Let's take a look, again,

00:41:54,970 --> 00:41:59,430
at how I actually integrated the YouTube component.

00:41:59,430 --> 00:42:01,680
The YouTube component needed the video ID.

00:42:01,680 --> 00:42:05,840
I passed it using the data binding with square brackets.

00:42:05,840 --> 00:42:10,180
And it was emitting the states change events.

00:42:10,180 --> 00:42:12,930
And I listen to it using the parents.

00:42:12,930 --> 00:42:16,800
If you had a deja vu, this is exactly the same APIs

00:42:16,800 --> 00:42:19,160
and methods that we used for Angular components

00:42:19,160 --> 00:42:21,360
a few seconds earlier.

00:42:21,360 --> 00:42:23,090
I think this is very exciting.

00:42:23,090 --> 00:42:26,005
One API for all components.

00:42:26,005 --> 00:42:29,930
[APPLAUSE]

00:42:29,930 --> 00:42:32,010
Finally, the last new thing I used

00:42:32,010 --> 00:42:35,860
is, I have this reference, this variable binding, here,

00:42:35,860 --> 00:42:40,470
to the player variable, just so I can use it in my button

00:42:40,470 --> 00:42:41,840
right below.

00:42:41,840 --> 00:42:44,880
So right below, on click, I'm binding the player

00:42:44,880 --> 00:42:49,675
pause and play methods out the Google-YouTube components.

00:42:49,675 --> 00:42:51,300
MISKO HEVERY: So you might be wondering

00:42:51,300 --> 00:42:54,284
why we put the play directly inside the HTML.

00:42:54,284 --> 00:42:56,200
And why doesn't it go through a component now?

00:42:56,200 --> 00:42:58,320
We're certainly going to enable you so that you

00:42:58,320 --> 00:43:00,030
can go through a component.

00:43:00,030 --> 00:43:02,490
But in this particular case, I think this is a feature.

00:43:02,490 --> 00:43:04,890
Because imagine you have different templates,

00:43:04,890 --> 00:43:07,430
one for a desktop, one for a mobile device.

00:43:07,430 --> 00:43:10,070
It's very likely that the mechanism by which you

00:43:10,070 --> 00:43:11,512
play a video on a desktop is going

00:43:11,512 --> 00:43:13,470
to be different than the mechanism by which you

00:43:13,470 --> 00:43:14,720
play a video on a mobile.

00:43:14,720 --> 00:43:17,390
You might not even have buttons for mobile, and so on.

00:43:17,390 --> 00:43:19,570
And so as a result, not only are you

00:43:19,570 --> 00:43:22,195
going to have different HTML for the mobile device,

00:43:22,195 --> 00:43:24,320
you're actually going to have different components,

00:43:24,320 --> 00:43:26,070
or different Web Components in there.

00:43:26,070 --> 00:43:28,070
And those Web Components will have

00:43:28,070 --> 00:43:31,780
different methods for starting and pausing the video.

00:43:31,780 --> 00:43:35,640
So by being able to express all of this information

00:43:35,640 --> 00:43:37,950
in the template, we're actually allowing

00:43:37,950 --> 00:43:40,030
you to make sure you have a single controller,

00:43:40,030 --> 00:43:41,990
but have multiple ways of representing

00:43:41,990 --> 00:43:44,014
that information to the user.

00:43:44,014 --> 00:43:44,930
RADO KIROV: All right.

00:43:44,930 --> 00:43:48,010
Lastly, we heard yesterday by the talk

00:43:48,010 --> 00:43:51,720
from the Open Table folks how Shadow DOM really

00:43:51,720 --> 00:43:54,820
can enhance the reusability of your components.

00:43:54,820 --> 00:43:58,590
Since Angular 2 is using Shadow DOM right out of the box,

00:43:58,590 --> 00:44:02,240
we are reaping those benefits right here in this little app.

00:44:02,240 --> 00:44:06,910
So if you remember, I had this panel, this description

00:44:06,910 --> 00:44:11,180
and stats panels that I could switch between with the click

00:44:11,180 --> 00:44:12,720
of a button.

00:44:12,720 --> 00:44:14,410
Let's see how I implemented that.

00:44:14,410 --> 00:44:17,030
I see there is a component called Either Panel.

00:44:17,030 --> 00:44:20,070
And within it there are two divs, one with class left

00:44:20,070 --> 00:44:22,550
and one with class right.

00:44:22,550 --> 00:44:25,450
Now if I open the Either Panel component itself,

00:44:25,450 --> 00:44:27,780
I said two content stacks that are directly

00:44:27,780 --> 00:44:30,710
projecting the left piece and the right piece.

00:44:30,710 --> 00:44:32,210
And they're doing all the decoration

00:44:32,210 --> 00:44:36,410
and all the transitioning between the two panels.

00:44:36,410 --> 00:44:37,880
The great benefit that you see here

00:44:37,880 --> 00:44:40,660
is, either panel is completely detached

00:44:40,660 --> 00:44:43,590
from the logic of the application itself.

00:44:43,590 --> 00:44:46,160
It has nothing to do with videos or YouTube.

00:44:46,160 --> 00:44:51,180
And it could have been written by UI library,

00:44:51,180 --> 00:44:55,342
or some other team within your organization.

00:44:55,342 --> 00:44:56,800
MISKO HEVERY: So the nice thing is,

00:44:56,800 --> 00:44:59,660
we can retire our transclusion friends.

00:44:59,660 --> 00:45:02,569
Replace it with Web Component of Shadow DOM.

00:45:02,569 --> 00:45:04,110
And it turns out, Shadow DOM actually

00:45:04,110 --> 00:45:06,220
has a lot more features than transclude ever did.

00:45:06,220 --> 00:45:08,620
Like, this example of having multiple content,

00:45:08,620 --> 00:45:10,470
being able to select a portion of it.

00:45:10,470 --> 00:45:13,430
Actually, you can even bind to the select attribute

00:45:13,430 --> 00:45:15,890
of the content and change what exactly you're binding

00:45:15,890 --> 00:45:17,880
and projecting in the future.

00:45:17,880 --> 00:45:19,860
The other thing is, we actually get

00:45:19,860 --> 00:45:22,550
to benefit by having somebody else write

00:45:22,550 --> 00:45:24,840
all the documentation about Shadow DOM and content

00:45:24,840 --> 00:45:27,740
and how it works, so we don't have to explain it.

00:45:27,740 --> 00:45:29,180
We don't have to make up terms.

00:45:29,180 --> 00:45:32,372
I'm super excited about this whole Shadow DOM thing.

00:45:32,372 --> 00:45:34,507
It is really, really nice.

00:45:34,507 --> 00:45:35,938
AUDIENCE: Whew!

00:45:35,938 --> 00:45:37,846
[APPLAUSE]

00:45:37,846 --> 00:45:39,754


00:45:39,754 --> 00:45:42,779
Now you might be thinking, well, but Shadow DOM

00:45:42,779 --> 00:45:44,070
is not available on my browser.

00:45:44,070 --> 00:45:45,800
So what do we do about that?

00:45:45,800 --> 00:45:47,200
So it turns out, what we're going

00:45:47,200 --> 00:45:49,800
to do is we're going to emulate the Shadow DOM on all

00:45:49,800 --> 00:45:50,880
the browsers in Angular.

00:45:50,880 --> 00:45:52,660
So as a developer, you're going to pretend

00:45:52,660 --> 00:45:53,805
that there is a Shadow DOM.

00:45:53,805 --> 00:45:55,430
When you talk to your coworkers, you're

00:45:55,430 --> 00:45:59,340
going to use words like light DOM and projection and Shadow

00:45:59,340 --> 00:46:00,786
Dom.

00:46:00,786 --> 00:46:02,160
Everything that you will be doing

00:46:02,160 --> 00:46:04,160
will be as if Shadow DOM existed.

00:46:04,160 --> 00:46:08,012
But all of this will be emulated by Angular for you

00:46:08,012 --> 00:46:08,845
on all the browsers.

00:46:08,845 --> 00:46:11,525


00:46:11,525 --> 00:46:13,890
[APPLAUSE]

00:46:13,890 --> 00:46:16,000


00:46:16,000 --> 00:46:17,750
RADO KIROV: So that's the end of our demo.

00:46:17,750 --> 00:46:20,320


00:46:20,320 --> 00:46:22,070
I hope you're just as excited as I

00:46:22,070 --> 00:46:25,820
am about achieving that same productivity you know and love

00:46:25,820 --> 00:46:29,820
from 1.x, while really reducing the mental overheads,

00:46:29,820 --> 00:46:32,970
the overload that you had to do to learn the framework

00:46:32,970 --> 00:46:37,070
and to really understand how the framework works.

00:46:37,070 --> 00:46:38,951
MISKO HEVERY: So [INAUDIBLE] said, we

00:46:38,951 --> 00:46:40,200
are really excited about this.

00:46:40,200 --> 00:46:41,635
I am so excited, I'll tell anybody

00:46:41,635 --> 00:46:44,300
who will want to talk to me about all the amazing things

00:46:44,300 --> 00:46:45,760
that's happening in Angular 2.

00:46:45,760 --> 00:46:48,390
And I'm super excited to see what kind of amazing things

00:46:48,390 --> 00:46:51,510
you guys are going to build using Angular 2 in the future.

00:46:51,510 --> 00:46:52,260
Thank you.

00:46:52,260 --> 00:46:55,610
[APPLAUSE]


YouTube URL: https://www.youtube.com/watch?v=-dMBcqwvYA0


