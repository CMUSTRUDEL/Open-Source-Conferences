Title: Fast from the Start   Jeff Cross
Publication date: 2015-03-05
Playlist: ng-conf 2015
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:00,410


00:00:00,410 --> 00:00:01,285
SPEAKER: [INAUDIBLE].

00:00:01,285 --> 00:00:04,390


00:00:04,390 --> 00:00:04,890
All right.

00:00:04,890 --> 00:00:06,772
I'm going to kick off Jeff's talk here.

00:00:06,772 --> 00:00:07,980
And hopefully, he's here by--

00:00:07,980 --> 00:00:08,646
[VIDEO PLAYBACK]

00:00:08,646 --> 00:00:11,340
-Making Angular 2 Fast from the Start.

00:00:11,340 --> 00:00:15,130
Thanks for the time today.

00:00:15,130 --> 00:00:18,230
I hope to answer your questions later.

00:00:18,230 --> 00:00:19,810
-What'd you think?

00:00:19,810 --> 00:00:21,770
-I liked it.

00:00:21,770 --> 00:00:23,260
I didn't feel it.

00:00:23,260 --> 00:00:24,190
-OK.

00:00:24,190 --> 00:00:25,910
Did you see the graphs?

00:00:25,910 --> 00:00:27,710
Yeah, they were nice graphs.

00:00:27,710 --> 00:00:31,370
But I really want people to feel this being fast.

00:00:31,370 --> 00:00:32,830
And I really didn't get it.

00:00:32,830 --> 00:00:34,260
-You want them to feel the fast.

00:00:34,260 --> 00:00:36,110
-Yeah, like don't half-step this thing.

00:00:36,110 --> 00:00:36,820
-I get it.

00:00:36,820 --> 00:00:37,100
-OK.

00:00:37,100 --> 00:00:37,940
-I know exactly what you mean.

00:00:37,940 --> 00:00:38,200
-All right.

00:00:38,200 --> 00:00:39,000
I trust you, Jeff.

00:00:39,000 --> 00:00:40,330
-Oh, they're going to feel it tomorrow.

00:00:40,330 --> 00:00:40,750
-OK.

00:00:40,750 --> 00:00:41,490
-They're going to see it.

00:00:41,490 --> 00:00:42,260
-Make us proud.

00:00:42,260 --> 00:00:42,800
-All right.

00:00:42,800 --> 00:00:43,260
-Make us proud.

00:00:43,260 --> 00:00:43,843
-Thanks, Brad.

00:00:43,843 --> 00:00:46,794


00:00:46,794 --> 00:00:49,289
[ROCK MUSIC ALARM]

00:00:49,289 --> 00:01:00,267


00:01:00,267 --> 00:01:02,762
[ROCK MUSIC]

00:01:02,762 --> 00:01:16,733


00:01:16,733 --> 00:01:17,233
-Daddy.

00:01:17,233 --> 00:01:20,226


00:01:20,226 --> 00:01:20,726
Daddy.

00:01:20,726 --> 00:01:23,720


00:01:23,720 --> 00:01:29,708
[ROCK MUSIC]

00:01:29,708 --> 00:02:58,031


00:02:58,031 --> 00:02:59,528
[END PLAYBACK]

00:02:59,528 --> 00:03:00,526
[CHEERS AND APPLAUSE]

00:03:00,526 --> 00:03:04,019


00:03:04,019 --> 00:03:09,800
JEFF CROSS: [SIGHS] Thank you.

00:03:09,800 --> 00:03:11,330
Let me get this going here.

00:03:11,330 --> 00:03:12,330
AUDIENCE: I can feel it.

00:03:12,330 --> 00:03:13,060
JEFF CROSS: Yeah, thank you.

00:03:13,060 --> 00:03:13,515
AUDIENCE: Woo!

00:03:13,515 --> 00:03:13,970
Feel it.

00:03:13,970 --> 00:03:14,470
JEFF CROSS: Can you feel it?

00:03:14,470 --> 00:03:15,210
AUDIENCE: Fast.

00:03:15,210 --> 00:03:15,840
JEFF CROSS: You felt it.

00:03:15,840 --> 00:03:16,327
AUDIENCE: I felt it.

00:03:16,327 --> 00:03:17,788
AUDIENCE: You're not even sweaty.

00:03:17,788 --> 00:03:18,621
JEFF CROSS: [LAUGHS]

00:03:18,621 --> 00:03:19,736
[LAUGHTER]

00:03:19,736 --> 00:03:22,658


00:03:22,658 --> 00:03:25,150
Now let's see if I can get my notes here.

00:03:25,150 --> 00:03:28,270


00:03:28,270 --> 00:03:30,090
Don't look at my notes.

00:03:30,090 --> 00:03:32,050
[LAUGHTER]

00:03:32,050 --> 00:03:34,010


00:03:34,010 --> 00:03:34,770
Hello.

00:03:34,770 --> 00:03:35,820
I made it just in time.

00:03:35,820 --> 00:03:38,910


00:03:38,910 --> 00:03:41,010
First, thanks for the help with the video.

00:03:41,010 --> 00:03:44,290
Alex Eagle on our team was a big help there.

00:03:44,290 --> 00:03:46,720
Also, I think it's pretty cool that my manager

00:03:46,720 --> 00:03:48,400
would costar in my video and also do

00:03:48,400 --> 00:03:51,480
some camera work for me.

00:03:51,480 --> 00:03:53,807
So I'm Jeff from the Angular Team at Google.

00:03:53,807 --> 00:03:55,890
I'm here to talk about web application performance

00:03:55,890 --> 00:03:57,636
and specifically how to measure it.

00:03:57,636 --> 00:03:59,260
And I'm talking about a tool we've been

00:03:59,260 --> 00:04:01,864
working on called Benchpress.

00:04:01,864 --> 00:04:03,530
And you probably think, oh, that's Jeff.

00:04:03,530 --> 00:04:05,459
He's the funniest guy on the Angular Team.

00:04:05,459 --> 00:04:06,750
This talk is going to be funny.

00:04:06,750 --> 00:04:10,160
But actually, performance is serious.

00:04:10,160 --> 00:04:12,920
[LAUGHTER]

00:04:12,920 --> 00:04:14,140
In fact, it's dead serious.

00:04:14,140 --> 00:04:15,940
[LAUGHTER]

00:04:15,940 --> 00:04:17,115


00:04:17,115 --> 00:04:18,490
So if you want jokes, you'll have

00:04:18,490 --> 00:04:22,970
to wait for this guy's talk tomorrow-- my towel boy.

00:04:22,970 --> 00:04:24,960
But let's get back on track.

00:04:24,960 --> 00:04:28,670
So speed, responsiveness, and smoothness

00:04:28,670 --> 00:04:31,170
are big parts of what make a good user experience when

00:04:31,170 --> 00:04:33,040
using an application.

00:04:33,040 --> 00:04:36,120
So as a framework, Angular-- it's pretty important

00:04:36,120 --> 00:04:37,850
that the framework is as fast as possible

00:04:37,850 --> 00:04:41,000
and that it's helping developers make apps as fast as possible,

00:04:41,000 --> 00:04:42,060
too.

00:04:42,060 --> 00:04:44,790
So we're using Benchpress to make Angular 2 measurably fast

00:04:44,790 --> 00:04:49,860
from the start, as the title suggests.

00:04:49,860 --> 00:04:52,609
And when I say fast from the start, I mean two things.

00:04:52,609 --> 00:04:54,150
One is that we're approaching it with

00:04:54,150 --> 00:04:55,339
a performance-first design.

00:04:55,339 --> 00:04:56,880
So at the beginning of the framework,

00:04:56,880 --> 00:04:59,200
performance is one of the biggest goals.

00:04:59,200 --> 00:05:01,481
And also, applications are fast by default.

00:05:01,481 --> 00:05:02,980
You shouldn't have to think too much

00:05:02,980 --> 00:05:04,690
about how your application's architected

00:05:04,690 --> 00:05:07,580
to optimize it for performance.

00:05:07,580 --> 00:05:09,380
So before I dive into Benchpress,

00:05:09,380 --> 00:05:13,310
I want to show some background performance of Angular 1.

00:05:13,310 --> 00:05:16,030
So Angular, as demonstrated by everyone here,

00:05:16,030 --> 00:05:17,280
is a pretty popular framework.

00:05:17,280 --> 00:05:20,440
It's grown a lot over the past few years.

00:05:20,440 --> 00:05:22,130
And people like it for a lot of reasons.

00:05:22,130 --> 00:05:23,870
It's got good testability.

00:05:23,870 --> 00:05:25,490
It separates concerns well.

00:05:25,490 --> 00:05:27,690
It provides data binding.

00:05:27,690 --> 00:05:29,360
But as more and more people used it,

00:05:29,360 --> 00:05:31,120
some common-use cases started to emerge

00:05:31,120 --> 00:05:33,700
where performance was an issue.

00:05:33,700 --> 00:05:35,770
And developers would need to understand Angular

00:05:35,770 --> 00:05:37,860
pretty well to know how to avoid these issues.

00:05:37,860 --> 00:05:40,430
They'd have to know how to minimize digests,

00:05:40,430 --> 00:05:43,560
how to minimize the number of watchers in a view.

00:05:43,560 --> 00:05:45,934
And a lot of these issues could be improved by changes

00:05:45,934 --> 00:05:46,850
to application design.

00:05:46,850 --> 00:05:49,266
But there are a lot of layers to this performance problem.

00:05:49,266 --> 00:05:51,870
And this is a simplified view of those layers

00:05:51,870 --> 00:05:54,130
as it pertains to Angular.

00:05:54,130 --> 00:05:56,960
And so you see that between your application and the DOM

00:05:56,960 --> 00:05:59,790
and all the JavaScript engines happening underneath

00:05:59,790 --> 00:06:00,440
is Angular.

00:06:00,440 --> 00:06:03,530
And so Angular is an abstraction between your application

00:06:03,530 --> 00:06:04,590
and the DOM.

00:06:04,590 --> 00:06:06,090
And so being an abstraction, Angular

00:06:06,090 --> 00:06:09,540
has a responsibility to be as lightweight as possible,

00:06:09,540 --> 00:06:11,890
to create as little overhead as possible,

00:06:11,890 --> 00:06:15,310
and also to give you control over its performance

00:06:15,310 --> 00:06:17,130
characteristics.

00:06:17,130 --> 00:06:19,510
So as we started Angular 1.3, we started

00:06:19,510 --> 00:06:21,660
profiling some Angular applications at Google

00:06:21,660 --> 00:06:23,130
and outside of Google.

00:06:23,130 --> 00:06:25,960
And this gave us some good ideas where we could spend our time

00:06:25,960 --> 00:06:26,920
to optimize Angular.

00:06:26,920 --> 00:06:28,964
We saw the parts that were slow, and we

00:06:28,964 --> 00:06:30,380
saw how applications were using it

00:06:30,380 --> 00:06:33,000
and how we could work around that.

00:06:33,000 --> 00:06:36,150
But we wanted a simpler approach to performance management

00:06:36,150 --> 00:06:38,400
that would give us the same kind of instant validation

00:06:38,400 --> 00:06:40,040
that we get with unit tests.

00:06:40,040 --> 00:06:41,940
So Chrome Profiler's good for analyzing.

00:06:41,940 --> 00:06:44,570
But we wanted something that would help us measure.

00:06:44,570 --> 00:06:47,880
So we like to use this process of measure,

00:06:47,880 --> 00:06:49,722
analyze, improve on the team.

00:06:49,722 --> 00:06:50,930
It's not an original concept.

00:06:50,930 --> 00:06:52,900
This is just how we express it.

00:06:52,900 --> 00:06:56,600
We like to first understand the problem in some measurable way,

00:06:56,600 --> 00:06:58,480
analyze to figure out what the problem is,

00:06:58,480 --> 00:07:03,120
and then improve-- fix what we think was the problem--

00:07:03,120 --> 00:07:05,520
and then measure to see if we were correct.

00:07:05,520 --> 00:07:08,219
But we lacked the tools for the measure part.

00:07:08,219 --> 00:07:10,510
And there are tools that provide JavaScript performance

00:07:10,510 --> 00:07:12,750
measurement, like Benchmark.js, which

00:07:12,750 --> 00:07:16,660
is what is used on jsPerf.com, which many of you have used.

00:07:16,660 --> 00:07:18,680
And these are great for micro benchmarks.

00:07:18,680 --> 00:07:21,542
But we wanted to focus on macro benchmarks.

00:07:21,542 --> 00:07:23,000
Or to put it another way, we wanted

00:07:23,000 --> 00:07:26,060
benchmarks that represented higher-level use cases

00:07:26,060 --> 00:07:28,600
and show aggregate performance of many moving

00:07:28,600 --> 00:07:30,595
parts in an application.

00:07:30,595 --> 00:07:32,470
We wanted this because micro benchmarks still

00:07:32,470 --> 00:07:34,386
assume that the small part you're benchmarking

00:07:34,386 --> 00:07:36,940
is the right part to be looking at.

00:07:36,940 --> 00:07:39,021
And macro benchmarks help verify if there's

00:07:39,021 --> 00:07:41,270
actual user-perceivable improvement to your underlying

00:07:41,270 --> 00:07:43,020
code.

00:07:43,020 --> 00:07:45,840
And the last part about micro benchmarks

00:07:45,840 --> 00:07:48,559
is even if you make this one piece of code 10 times faster,

00:07:48,559 --> 00:07:51,100
you don't know if it has some side effect that could actually

00:07:51,100 --> 00:07:55,420
create a 50% worse user experience.

00:07:55,420 --> 00:07:57,570
So we decided to build a tool called Benchpress.

00:07:57,570 --> 00:07:58,470
AUDIENCE: Woo!

00:07:58,470 --> 00:07:59,620
JEFF CROSS: Yeah.

00:07:59,620 --> 00:08:02,250
And so what Benchpress would do-- it

00:08:02,250 --> 00:08:05,530
would allow us to write macro benchmarks as isolated fully

00:08:05,530 --> 00:08:07,740
functioning applications.

00:08:07,740 --> 00:08:10,150
This would give us close to real-world use cases

00:08:10,150 --> 00:08:11,795
that we could verify.

00:08:11,795 --> 00:08:13,670
The performance improvement will be something

00:08:13,670 --> 00:08:15,710
that users will actually feel.

00:08:15,710 --> 00:08:18,630
Each benchmark would provide different ways

00:08:18,630 --> 00:08:23,159
to test varying operations in conditions--

00:08:23,159 --> 00:08:25,700
so test different things that a [INAUDIBLE] application would

00:08:25,700 --> 00:08:27,450
do and test it under different conditions,

00:08:27,450 --> 00:08:31,820
like different ways of binding or watching changes.

00:08:31,820 --> 00:08:35,780
So for each operation, we wanted to collect the execution time,

00:08:35,780 --> 00:08:39,120
as well as the allocated memory, the garbage size,

00:08:39,120 --> 00:08:41,450
and how much time it took to garbage-collect

00:08:41,450 --> 00:08:44,560
after the operation.

00:08:44,560 --> 00:08:46,910
And we should be able to get some hint as

00:08:46,910 --> 00:08:49,710
to how reliable and admissible the data we

00:08:49,710 --> 00:08:50,860
collect from the runner is.

00:08:50,860 --> 00:08:53,954
So if we can confidently say, OK, we've run this;

00:08:53,954 --> 00:08:55,370
the data looks stable, we're going

00:08:55,370 --> 00:08:59,090
to say that for this commit, this is the result.

00:08:59,090 --> 00:09:01,520
And we can compare it to before and have some level

00:09:01,520 --> 00:09:03,760
of confidence with that.

00:09:03,760 --> 00:09:05,980
And so as we started writing Benchpress,

00:09:05,980 --> 00:09:08,860
we started writing benchmarks for Angular 1.3

00:09:08,860 --> 00:09:10,520
as we were building it.

00:09:10,520 --> 00:09:12,950
For example, we built a benchmark called large table,

00:09:12,950 --> 00:09:14,520
which is what you see here.

00:09:14,520 --> 00:09:16,770
And this is one of two benchmarks, the other one being

00:09:16,770 --> 00:09:19,470
deep tree, which Igor touched on earlier, which give us

00:09:19,470 --> 00:09:22,010
a pretty good overall picture of Angular application

00:09:22,010 --> 00:09:22,760
performance.

00:09:22,760 --> 00:09:26,380
So large table gives us a good idea of quickly stamping out

00:09:26,380 --> 00:09:28,100
elements, whereas deep tree gives us

00:09:28,100 --> 00:09:32,020
a good idea of the time to create components.

00:09:32,020 --> 00:09:33,560
So what this does is this benchmark

00:09:33,560 --> 00:09:36,460
creates a table with many rows and columns and bindings

00:09:36,460 --> 00:09:38,090
in each cell.

00:09:38,090 --> 00:09:40,220
And we test it with varying binding strategies,

00:09:40,220 --> 00:09:42,710
as you can see by the radio buttons here.

00:09:42,710 --> 00:09:46,842
And then we can see how fast the table is created and destroyed

00:09:46,842 --> 00:09:48,550
using these different binding strategies.

00:09:48,550 --> 00:09:52,700


00:09:52,700 --> 00:09:57,250
So here's a video I'm hoping to play.

00:09:57,250 --> 00:10:01,830
This is just a video of the first version of Benchpress

00:10:01,830 --> 00:10:04,680
running the Table benchmark.

00:10:04,680 --> 00:10:06,600
I'll explain a little bit about this one.

00:10:06,600 --> 00:10:08,970
And this is using ngBind in this video.

00:10:08,970 --> 00:10:10,530
So each light-gray row represents

00:10:10,530 --> 00:10:11,730
a step of the benchmark.

00:10:11,730 --> 00:10:13,600
And in this case, there are three steps.

00:10:13,600 --> 00:10:16,860
And the most interesting step we want to measure is Create.

00:10:16,860 --> 00:10:19,460
So there's a Create step that actually creates the table,

00:10:19,460 --> 00:10:23,040
adds data to the scope, and then renders the table.

00:10:23,040 --> 00:10:26,860
And then there's Destroy, which is tearing that down.

00:10:26,860 --> 00:10:30,970
So what we're seeing-- the measurements in the columns--

00:10:30,970 --> 00:10:34,320
we see the test time, which is Script Execution Time, GC Time,

00:10:34,320 --> 00:10:35,820
which is how long it took to garbage

00:10:35,820 --> 00:10:39,437
collect after the script ran, and Garbage, which

00:10:39,437 --> 00:10:42,020
is how much garbage was actually generated, and Retain Memory,

00:10:42,020 --> 00:10:44,690
so how much memory was used in the [INAUDIBLE]

00:10:44,690 --> 00:10:47,254
after this operation-- before and after.

00:10:47,254 --> 00:10:49,420
So naturally, Destroy has a negative retainment rate

00:10:49,420 --> 00:10:52,444
because it's destroying data.

00:10:52,444 --> 00:10:53,360
So speed is one thing.

00:10:53,360 --> 00:10:55,620
That's probably the most user-perceivable metric

00:10:55,620 --> 00:10:56,640
to watch.

00:10:56,640 --> 00:10:59,030
But memory is one of the more impactful things

00:10:59,030 --> 00:11:00,120
on actual performance.

00:11:00,120 --> 00:11:02,700
The memory pressure your application generates

00:11:02,700 --> 00:11:06,552
is a big factor in overall speed.

00:11:06,552 --> 00:11:08,010
And at the top of these columns, we

00:11:08,010 --> 00:11:09,634
see some statistical information that's

00:11:09,634 --> 00:11:11,630
hard to see here in the screenshot.

00:11:11,630 --> 00:11:14,630
But this tells us the mean of the number of samples

00:11:14,630 --> 00:11:17,890
we want to look at-- which is 20 by default-- and then

00:11:17,890 --> 00:11:18,970
the standard deviation.

00:11:18,970 --> 00:11:20,920
So you can use that to determine about how

00:11:20,920 --> 00:11:23,600
immiscible the tests should be.

00:11:23,600 --> 00:11:25,460
So when Angular 1.3 was released,

00:11:25,460 --> 00:11:28,220
this benchmark showed that we had a 4.4 times

00:11:28,220 --> 00:11:31,130
improvement in DOM manipulation time.

00:11:31,130 --> 00:11:35,910
73% less garbage was created, and Digest was 3 and 1/2 times

00:11:35,910 --> 00:11:37,795
faster and 87% less garbage.

00:11:37,795 --> 00:11:40,720


00:11:40,720 --> 00:11:43,980
So Benchpress was immensely helpful in helping us measure

00:11:43,980 --> 00:11:46,800
the performance of Angular 1.3.

00:11:46,800 --> 00:11:48,170
But it had some limitations.

00:11:48,170 --> 00:11:50,600
One was that it was completely web based.

00:11:50,600 --> 00:11:53,000
This made it difficult to automate.

00:11:53,000 --> 00:11:56,260
And it was designed primarily to be run manually

00:11:56,260 --> 00:11:58,090
by developers as they were working

00:11:58,090 --> 00:11:59,360
on improving the framework.

00:11:59,360 --> 00:12:02,390
And because of that, it was subject to different results

00:12:02,390 --> 00:12:04,150
depending on the environment that it

00:12:04,150 --> 00:12:05,570
was being run in-- so the machine

00:12:05,570 --> 00:12:08,830
that it was being run on, what programs they would have open,

00:12:08,830 --> 00:12:11,260
what they were doing while the benchmark was running.

00:12:11,260 --> 00:12:13,710
You really have to be disciplined and smart to be

00:12:13,710 --> 00:12:17,760
able to even keep your results stable on the same machine

00:12:17,760 --> 00:12:22,260
from run to run, let alone different environments.

00:12:22,260 --> 00:12:25,700
And so it was difficult to automate.

00:12:25,700 --> 00:12:28,007
The data was sandboxed to the browser.

00:12:28,007 --> 00:12:29,840
So we saw the reporting data in the browser,

00:12:29,840 --> 00:12:31,700
and that's where it lived and died.

00:12:31,700 --> 00:12:33,540
When the browser would go away, the data's

00:12:33,540 --> 00:12:36,350
gone unless you copy it and paste it into a spreadsheet.

00:12:36,350 --> 00:12:38,240
So that doesn't make it very actionable

00:12:38,240 --> 00:12:40,880
unless you're really disciplined about that

00:12:40,880 --> 00:12:45,277
in comparing the data between versions of your framework.

00:12:45,277 --> 00:12:46,860
And there was limited browser support.

00:12:46,860 --> 00:12:49,900
Really, Chrome Canary was the only browser

00:12:49,900 --> 00:12:51,670
that we could give the flags to that we

00:12:51,670 --> 00:12:54,520
needed to get that memory data.

00:12:54,520 --> 00:12:56,170
Other browsers, you just can't get that

00:12:56,170 --> 00:12:58,360
from inside the browser.

00:12:58,360 --> 00:13:00,470
And also, the manual garbage collection

00:13:00,470 --> 00:13:02,950
that we do to calculate how much garbage was generated

00:13:02,950 --> 00:13:05,530
and how much garbage collection time took-- we

00:13:05,530 --> 00:13:07,880
couldn't do that in very many browsers.

00:13:07,880 --> 00:13:10,630
So we released 1.3 and started spending more time

00:13:10,630 --> 00:13:12,280
building Angular 2.

00:13:12,280 --> 00:13:15,230
And since mobile performance is a big focus of Angular 2,

00:13:15,230 --> 00:13:19,710
we needed to be able to measure performance in mobile browsers.

00:13:19,710 --> 00:13:24,544
So Tobias did some research and designed a new Benchpress.

00:13:24,544 --> 00:13:27,210
And this was based on collecting performance data from WebDriver

00:13:27,210 --> 00:13:30,180
and ways that could work with more browsers, particularly

00:13:30,180 --> 00:13:31,210
mobile browsers.

00:13:31,210 --> 00:13:33,290
And if you're not familiar with WebDriver,

00:13:33,290 --> 00:13:35,280
it's the protocol used by Protractor

00:13:35,280 --> 00:13:38,800
and another end-to-end testing tools.

00:13:38,800 --> 00:13:42,532
So as we started writing Angular 2,

00:13:42,532 --> 00:13:44,490
we were writing Benchpress and at the same time

00:13:44,490 --> 00:13:49,920
writing benchmarks for Angular 2 that test the core itself

00:13:49,920 --> 00:13:52,740
but also will test the previous versions of the framework

00:13:52,740 --> 00:13:55,470
to see how performance has improved from Angular

00:13:55,470 --> 00:13:58,130
1.3, JavaScript, Dart.

00:13:58,130 --> 00:14:00,360
And also, we write external benchmarks

00:14:00,360 --> 00:14:02,500
to test against other frameworks to see

00:14:02,500 --> 00:14:04,330
similar implementations-- how well we

00:14:04,330 --> 00:14:07,060
compare with other frameworks.

00:14:07,060 --> 00:14:10,237
So we have the large table benchmark, deep tree,

00:14:10,237 --> 00:14:12,320
and there's a new benchmark for infinite scrolling

00:14:12,320 --> 00:14:15,750
that measures how performance holds up

00:14:15,750 --> 00:14:18,790
as you're scrolling through an infinite scrolling list.

00:14:18,790 --> 00:14:20,790
And we have some more module-specific benchmarks

00:14:20,790 --> 00:14:23,000
that are more like micro benchmarks for the compiler,

00:14:23,000 --> 00:14:27,500
dependency injection, element injector, and change detection.

00:14:27,500 --> 00:14:29,540
So something different in the Angular 2 setup

00:14:29,540 --> 00:14:31,340
is that we have a suite of Jasmine tests

00:14:31,340 --> 00:14:34,154
that run the benchmarks instead of running it in the browser.

00:14:34,154 --> 00:14:36,570
And we use tests to describe the conditions under which we

00:14:36,570 --> 00:14:37,882
wanted to run the benchmark.

00:14:37,882 --> 00:14:39,340
And we run these benchmarks locally

00:14:39,340 --> 00:14:41,798
when adding and changing Angular to verify that performance

00:14:41,798 --> 00:14:45,250
is remaining stable or improving with each commit.

00:14:45,250 --> 00:14:47,910
And we're using a library called PerfUtil here.

00:14:47,910 --> 00:14:50,790
But really, all that's happening here

00:14:50,790 --> 00:14:56,440
is we are telling Benchpress, we're

00:14:56,440 --> 00:14:58,890
telling it to click these two buttons-- measure what

00:14:58,890 --> 00:15:01,186
happens as those are clicked.

00:15:01,186 --> 00:15:03,060
And then we're passing a value of [INAUDIBLE]

00:15:03,060 --> 00:15:05,400
to tell the tree how deep it should go-- how many levels

00:15:05,400 --> 00:15:07,450
deep it should render.

00:15:07,450 --> 00:15:12,510
And now we have the Benchpress logs.

00:15:12,510 --> 00:15:14,850
This is an example of the new Benchpress.

00:15:14,850 --> 00:15:18,340
It just logs the data as it tests

00:15:18,340 --> 00:15:21,060
the different variables of the benchmark to the console.

00:15:21,060 --> 00:15:23,150
And we can see the results after each sample

00:15:23,150 --> 00:15:26,750
after it's done being collected.

00:15:26,750 --> 00:15:28,407
And in addition to running local,

00:15:28,407 --> 00:15:30,990
we have a CI setup that runs all benchmarks on mobile hardware

00:15:30,990 --> 00:15:33,210
for each commit to Angular-Angular.

00:15:33,210 --> 00:15:36,700
And we started with a simple setup of a Nexus tablet

00:15:36,700 --> 00:15:38,820
plugged into a Mac Mini that you see here.

00:15:38,820 --> 00:15:40,157
This is in our office.

00:15:40,157 --> 00:15:42,240
But we're getting a little bit more sophisticated.

00:15:42,240 --> 00:15:44,990
We're setting up our benchmarks in a calibrated environment

00:15:44,990 --> 00:15:46,760
to produce more stable results.

00:15:46,760 --> 00:15:49,810
And we use dedicated hardware, performance-tuned operating

00:15:49,810 --> 00:15:53,534
system, and remove as many external factors as possible

00:15:53,534 --> 00:15:54,950
that could affect the sample so we

00:15:54,950 --> 00:15:56,590
can have some more confidence.

00:15:56,590 --> 00:15:58,340
And you can see here that the view we use,

00:15:58,340 --> 00:16:01,990
that it provides more ways of drilling down into data.

00:16:01,990 --> 00:16:02,490
OK.

00:16:02,490 --> 00:16:03,960
Yawn-- so what's in it for me?

00:16:03,960 --> 00:16:06,820
I've got a minute left because of that long video.

00:16:06,820 --> 00:16:08,236
So what is in it for you?

00:16:08,236 --> 00:16:09,860
You'll get a faster framework, for one.

00:16:09,860 --> 00:16:12,519
I think that's a pretty big win for everybody.

00:16:12,519 --> 00:16:14,560
But you can actually use it in your own projects.

00:16:14,560 --> 00:16:17,520
And I've made a simple GitHub project

00:16:17,520 --> 00:16:18,960
that I'll link to at the end here

00:16:18,960 --> 00:16:22,270
that you could clone and see that implements the deep tree

00:16:22,270 --> 00:16:25,090
baseline benchmark from the Angular to repository.

00:16:25,090 --> 00:16:29,192
And this benchmark is a baseline that doesn't actually

00:16:29,192 --> 00:16:31,400
have a dependency on any framework and just shows you

00:16:31,400 --> 00:16:33,260
how to use Benchpress.

00:16:33,260 --> 00:16:36,460
I'll walk through how it's set up in the time I have left.

00:16:36,460 --> 00:16:38,800
It's really just an application in the Public folder,

00:16:38,800 --> 00:16:43,270
a Protractor config, and a spec.

00:16:43,270 --> 00:16:45,690
And this is what the benchmark looks like.

00:16:45,690 --> 00:16:47,684
It just recursively renders tree nodes.

00:16:47,684 --> 00:16:49,100
It has a form where you can change

00:16:49,100 --> 00:16:51,811
the depth of the tree and the buttons

00:16:51,811 --> 00:16:52,810
you click to measure it.

00:16:52,810 --> 00:16:54,100
And you could actually run this in your browser

00:16:54,100 --> 00:16:55,933
and profile it, too, and see the same things

00:16:55,933 --> 00:16:56,960
that Benchpress sees.

00:16:56,960 --> 00:16:58,310
And here's the spec.

00:16:58,310 --> 00:17:00,320
I won't go into how we set up the runner.

00:17:00,320 --> 00:17:02,910
But it's well commented in the project.

00:17:02,910 --> 00:17:05,140
And we see, we're just navigating with Protractor

00:17:05,140 --> 00:17:08,750
to open the page and then clicking the buttons manually

00:17:08,750 --> 00:17:10,430
with the Protractor selector.

00:17:10,430 --> 00:17:12,810
And then here's the code for the spec.

00:17:12,810 --> 00:17:15,510
And also, this is pretty well documented in the repository.

00:17:15,510 --> 00:17:17,540
So I won't go into it now.

00:17:17,540 --> 00:17:20,599
And here's the Protractor config, which sets up a server.

00:17:20,599 --> 00:17:22,940
It creates a new browser for each spec you're running.

00:17:22,940 --> 00:17:27,619
And here's some best practices that are also in the slide.

00:17:27,619 --> 00:17:30,670
I'll keep talking till they kick me off stage.

00:17:30,670 --> 00:17:34,030
So some best practices-- wait until a component's functional

00:17:34,030 --> 00:17:35,427
before you try to test it.

00:17:35,427 --> 00:17:37,510
It's hard to test something that doesn't work yet.

00:17:37,510 --> 00:17:39,885
About the same time as you would write an end-to-end test

00:17:39,885 --> 00:17:41,390
is a good time to write a benchmark.

00:17:41,390 --> 00:17:45,320
Run benchmarks consecutively in the same environment

00:17:45,320 --> 00:17:48,010
if you want stable results or confident results.

00:17:48,010 --> 00:17:50,760
Focus on the hottest components of your app first.

00:17:50,760 --> 00:17:51,510
Start simple.

00:17:51,510 --> 00:17:53,280
We're just logging on a CI server to start

00:17:53,280 --> 00:17:54,662
and comparing those over time.

00:17:54,662 --> 00:17:56,620
Calibrate your environment as much as possible.

00:17:56,620 --> 00:17:58,370
Step away as you're running the benchmark.

00:17:58,370 --> 00:18:00,350
Close as many programs as possible.

00:18:00,350 --> 00:18:02,900
And maybe run it a few times in cold-started browsers

00:18:02,900 --> 00:18:04,844
to make sure that you're getting real results.

00:18:04,844 --> 00:18:07,010
And use things like Google Analytics and other tools

00:18:07,010 --> 00:18:11,130
to get more real-world statistics.

00:18:11,130 --> 00:18:14,080
So you can see the source in angular/angular on GitHub.

00:18:14,080 --> 00:18:15,080
It's also on Benchpress.

00:18:15,080 --> 00:18:17,170
And thanks to Mario Casciaro for giving us

00:18:17,170 --> 00:18:20,151
that package name on npm.

00:18:20,151 --> 00:18:22,400
Leonardo's going to talk about ngTasty tomorrow, which

00:18:22,400 --> 00:18:23,590
uses this.

00:18:23,590 --> 00:18:24,876
Try it.

00:18:24,876 --> 00:18:26,500
See the links at the end of the slides?

00:18:26,500 --> 00:18:28,041
These will be shared right after here

00:18:28,041 --> 00:18:30,610
to someplace that Aaron Frost knows about.

00:18:30,610 --> 00:18:31,360
I hope you try it.

00:18:31,360 --> 00:18:32,360
And let me know what you think.

00:18:32,360 --> 00:18:34,790
I'd be happy to help you set up a benchmark for your app

00:18:34,790 --> 00:18:36,373
if you catch me during the conference.

00:18:36,373 --> 00:18:37,300
So thank you.

00:18:37,300 --> 00:18:41,550
[APPLAUSE]


YouTube URL: https://www.youtube.com/watch?v=x1PJn5qMUT4


