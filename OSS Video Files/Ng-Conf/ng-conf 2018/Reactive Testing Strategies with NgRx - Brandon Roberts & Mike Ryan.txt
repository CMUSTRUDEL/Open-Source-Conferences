Title: Reactive Testing Strategies with NgRx - Brandon Roberts & Mike Ryan
Publication date: 2018-11-16
Playlist: ng-conf 2018
Description: 
	ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:05,700
all right good morning everybody how's

00:00:02,070 --> 00:00:09,030
everyone doing so far all right not bad

00:00:05,700 --> 00:00:11,130
for the morning so we're excited to kick

00:00:09,030 --> 00:00:12,570
off the in grx tract with a topic that's

00:00:11,130 --> 00:00:14,490
really important to us and that's

00:00:12,570 --> 00:00:17,390
reactive testing strategies within G X

00:00:14,490 --> 00:00:20,570
and it's really important because

00:00:17,390 --> 00:00:23,279
quality is at the heart of Anjar x

00:00:20,570 --> 00:00:25,980
quality is a core value where we work at

00:00:23,279 --> 00:00:27,689
synapse if the software we write fails

00:00:25,980 --> 00:00:30,689
then people's lives could be in danger

00:00:27,689 --> 00:00:33,030
so as a result we've tried really hard

00:00:30,689 --> 00:00:35,989
to embed quality into every decision

00:00:33,030 --> 00:00:38,790
we've made when designing in grx and

00:00:35,989 --> 00:00:41,930
this testing story is a big reason why

00:00:38,790 --> 00:00:46,230
injure X requires you to be so explicit

00:00:41,930 --> 00:00:49,260
this this explicitness is in how you

00:00:46,230 --> 00:00:51,350
write actions and how you model state

00:00:49,260 --> 00:00:53,789
changes and in fixing your applications

00:00:51,350 --> 00:00:56,969
we'll talk about more about these

00:00:53,789 --> 00:00:58,500
explicitness later today also but you'll

00:00:56,969 --> 00:01:00,480
see hopefully during this talk to this

00:00:58,500 --> 00:01:02,399
explicitness actually makes testing

00:01:00,480 --> 00:01:04,970
pretty straightforward in comparison to

00:01:02,399 --> 00:01:07,290
a non indirect angular application and

00:01:04,970 --> 00:01:09,810
simplifying testing is really important

00:01:07,290 --> 00:01:12,840
because developers only write tests when

00:01:09,810 --> 00:01:16,290
it is easy to do so and the reason for

00:01:12,840 --> 00:01:18,320
this is because if tests are slow to run

00:01:16,290 --> 00:01:21,479
and they require a lot of setup

00:01:18,320 --> 00:01:23,580
developers tend to not want to be really

00:01:21,479 --> 00:01:25,259
want to do that as much yeah we both

00:01:23,580 --> 00:01:27,299
work as tech leads at the company where

00:01:25,259 --> 00:01:29,520
we work out and we've kind of realized

00:01:27,299 --> 00:01:33,210
that developers like the idea of tests

00:01:29,520 --> 00:01:36,060
more than writing tests themselves so if

00:01:33,210 --> 00:01:38,369
testing applications is exhausting then

00:01:36,060 --> 00:01:41,549
we want we want to make that process

00:01:38,369 --> 00:01:43,380
easier and more pleasant so it is our

00:01:41,549 --> 00:01:45,659
goal to make testing reactive angular

00:01:43,380 --> 00:01:48,119
applications within grx both pleasant

00:01:45,659 --> 00:01:49,860
and fast and to do that we're going to

00:01:48,119 --> 00:01:51,810
cover a couple of testing tools they're

00:01:49,860 --> 00:01:53,100
going to kind of help us get there I'm

00:01:51,810 --> 00:01:55,500
going to set those up in an example

00:01:53,100 --> 00:01:58,170
project so the first tool we want to

00:01:55,500 --> 00:02:00,840
talk about this morning is just ingest

00:01:58,170 --> 00:02:02,930
is a delightful JavaScript chess runner

00:02:00,840 --> 00:02:05,340
that lets you run your tests in parallel

00:02:02,930 --> 00:02:07,710
gives you the ability to do snapshot

00:02:05,340 --> 00:02:09,660
tests which we'll cover and also let you

00:02:07,710 --> 00:02:12,870
run your tests an emulated browser

00:02:09,660 --> 00:02:13,920
environment so at a high level what does

00:02:12,870 --> 00:02:15,300
just give you

00:02:13,920 --> 00:02:17,640
well it's easy to set up and configure

00:02:15,300 --> 00:02:19,980
and that's important because you already

00:02:17,640 --> 00:02:21,660
have a test tool with the angular CLI so

00:02:19,980 --> 00:02:23,069
if we want to bring in a new tool it's

00:02:21,660 --> 00:02:27,150
got to be pretty frictionless to get

00:02:23,069 --> 00:02:29,640
that setup and it's being easy to set up

00:02:27,150 --> 00:02:31,830
configured there's a package called just

00:02:29,640 --> 00:02:34,290
preset angular that integrates with the

00:02:31,830 --> 00:02:36,300
CLI that makes that even easier it's

00:02:34,290 --> 00:02:38,490
also lightning fast in comparison to

00:02:36,300 --> 00:02:40,080
karma just runs your tests in an

00:02:38,490 --> 00:02:40,830
emulated browser instead of an actual

00:02:40,080 --> 00:02:42,870
browser

00:02:40,830 --> 00:02:45,180
this means it's both easier to debug a

00:02:42,870 --> 00:02:46,770
test that's running ingest and you're

00:02:45,180 --> 00:02:50,190
not waiting for a browser to spin up on

00:02:46,770 --> 00:02:52,680
your a big advantage is snapshot testing

00:02:50,190 --> 00:02:56,100
which can be used to automate the

00:02:52,680 --> 00:02:59,220
creation of assertions will use snapshot

00:02:56,100 --> 00:03:01,380
testing to do reducers selectors and

00:02:59,220 --> 00:03:02,730
components during this talk and this

00:03:01,380 --> 00:03:05,190
snapshot testing something we want to

00:03:02,730 --> 00:03:06,810
highlight like Brandon said snapshot

00:03:05,190 --> 00:03:09,570
testing lets you automate the creation

00:03:06,810 --> 00:03:11,730
of assertions we found that when we're

00:03:09,570 --> 00:03:14,070
writing tests for angular components

00:03:11,730 --> 00:03:15,959
especially one of the most painful parts

00:03:14,070 --> 00:03:18,930
of running these tests is setting up

00:03:15,959 --> 00:03:22,489
these really complex assertions and

00:03:18,930 --> 00:03:25,049
since you can automate this it lets you

00:03:22,489 --> 00:03:26,549
capture that these snapshots to your

00:03:25,049 --> 00:03:28,650
file system so that you can compare

00:03:26,549 --> 00:03:30,390
these changes later on so take a quick

00:03:28,650 --> 00:03:33,329
look at kind of how this might help you

00:03:30,390 --> 00:03:35,070
write a test so here is the kind of

00:03:33,329 --> 00:03:37,260
expect statement you might write in a

00:03:35,070 --> 00:03:39,630
reducer function and I'm having to

00:03:37,260 --> 00:03:41,850
assert that my state matches a certain

00:03:39,630 --> 00:03:43,860
shape and in this test I have to write

00:03:41,850 --> 00:03:45,959
out the entire state object by hand and

00:03:43,860 --> 00:03:48,209
the truth is I never write this out by

00:03:45,959 --> 00:03:50,070
hand instead I make this test fail

00:03:48,209 --> 00:03:52,680
copy the output and then paste this back

00:03:50,070 --> 00:03:56,040
into my test I've done that before too

00:03:52,680 --> 00:03:58,079
so it's a maddening process and what to

00:03:56,040 --> 00:04:00,180
match snapshot does ingest as it lets

00:03:58,079 --> 00:04:01,799
you automate this instead of copying and

00:04:00,180 --> 00:04:03,540
pasting from the terminal when the test

00:04:01,799 --> 00:04:05,730
fails it's just gonna capture the output

00:04:03,540 --> 00:04:07,620
one time for you write it to the disk

00:04:05,730 --> 00:04:09,480
and then every time that test runs again

00:04:07,620 --> 00:04:12,989
it's going to compare it to that good

00:04:09,480 --> 00:04:15,690
snapshot so here we can replace this to

00:04:12,989 --> 00:04:16,919
equal assertion with to match snapshot

00:04:15,690 --> 00:04:18,060
and it's going to be that easy

00:04:16,919 --> 00:04:21,090
we're going to use this all throughout

00:04:18,060 --> 00:04:24,330
the day today so does this look like

00:04:21,090 --> 00:04:26,580
when it gets written out to the file so

00:04:24,330 --> 00:04:27,660
behind the scenes just like I said just

00:04:26,580 --> 00:04:30,900
creates a snaps

00:04:27,660 --> 00:04:32,820
file that accompanies r-spec and this

00:04:30,900 --> 00:04:36,120
file gets checked in the source control

00:04:32,820 --> 00:04:39,420
as you can see here the title of the

00:04:36,120 --> 00:04:41,520
test that we write is captured in the

00:04:39,420 --> 00:04:43,320
actual file itself to let you be able to

00:04:41,520 --> 00:04:46,440
look at point at a particular snapshot

00:04:43,320 --> 00:04:48,780
now each time this test runs is going to

00:04:46,440 --> 00:04:50,130
verify that the input to my test matches

00:04:48,780 --> 00:04:53,430
the output that I've checked into source

00:04:50,130 --> 00:04:54,450
control there's a couple of downsides to

00:04:53,430 --> 00:04:56,940
this that we should highlight and that

00:04:54,450 --> 00:04:58,710
is really that we needed we can trust

00:04:56,940 --> 00:05:01,410
this tool to work correctly but we need

00:04:58,710 --> 00:05:03,300
to verify the snapshots it's so easy to

00:05:01,410 --> 00:05:04,590
generate a snapshot to your file system

00:05:03,300 --> 00:05:06,780
and say all right that's great I'm not

00:05:04,590 --> 00:05:08,220
gonna open up that snapshot file and it

00:05:06,780 --> 00:05:09,480
turns out you didn't actually capture

00:05:08,220 --> 00:05:11,520
the thing you want to turn your snapshot

00:05:09,480 --> 00:05:14,840
test so we need be able to trust but

00:05:11,520 --> 00:05:18,600
verify snapshots so now that we've

00:05:14,840 --> 00:05:20,310
talked about how you you can use gifs in

00:05:18,600 --> 00:05:24,950
your project let's take a look at how

00:05:20,310 --> 00:05:27,210
you would do that in angular CLI project

00:05:24,950 --> 00:05:29,640
so I'm gonna let Brandon get this set up

00:05:27,210 --> 00:05:31,170
and the thing I wanted to make you or

00:05:29,640 --> 00:05:33,840
take away about setting up just is that

00:05:31,170 --> 00:05:36,060
it's pretty painless like Brandon said

00:05:33,840 --> 00:05:38,550
there's a package called just preset

00:05:36,060 --> 00:05:40,590
angular and what that does is it gives

00:05:38,550 --> 00:05:42,720
you really good defaults for running

00:05:40,590 --> 00:05:44,610
just inside of an angular CLI project

00:05:42,720 --> 00:05:47,430
alright so all you need to do is install

00:05:44,610 --> 00:05:49,320
that with NPM to your project right so

00:05:47,430 --> 00:05:51,630
as you can see here we have just set up

00:05:49,320 --> 00:05:53,220
already and just preset angular as we

00:05:51,630 --> 00:05:56,970
mentioned that gives you these tools out

00:05:53,220 --> 00:05:58,560
of the box and just preset angular comes

00:05:56,970 --> 00:06:01,080
with a default configuration that you

00:05:58,560 --> 00:06:04,230
can also extend so here we're just using

00:06:01,080 --> 00:06:06,540
a preset and we're setting a just a

00:06:04,230 --> 00:06:08,730
setup file for a little bit of if you

00:06:06,540 --> 00:06:10,230
have to override any additional things

00:06:08,730 --> 00:06:12,690
during your test like if you have

00:06:10,230 --> 00:06:14,640
conditions for material but that's

00:06:12,690 --> 00:06:16,320
pretty much all you need to start to get

00:06:14,640 --> 00:06:17,880
up and running with gist and this

00:06:16,320 --> 00:06:19,890
configuration lives in your package all

00:06:17,880 --> 00:06:23,160
JSON file and that's about as big as the

00:06:19,890 --> 00:06:24,810
configuration for just really gets so

00:06:23,160 --> 00:06:29,340
now we can see that we have all our

00:06:24,810 --> 00:06:31,260
tests running here it gives you a nice

00:06:29,340 --> 00:06:33,060
output of which tests have run and what

00:06:31,260 --> 00:06:36,650
the result is and you can get an idea of

00:06:33,060 --> 00:06:36,650
how fast these tests take to run

00:06:38,430 --> 00:06:43,590
so now that we've covered gist the next

00:06:41,260 --> 00:06:46,030
tool we'll talk about is Jasmine marbles

00:06:43,590 --> 00:06:47,650
so this is a node package that's going

00:06:46,030 --> 00:06:49,450
to integrate with the rxjs test

00:06:47,650 --> 00:06:51,850
scheduler and that's gonna allow you to

00:06:49,450 --> 00:06:53,170
write Jasmine tests they allow you to

00:06:51,850 --> 00:06:55,300
assert against the behavior of

00:06:53,170 --> 00:06:58,540
observables and it gives you a couple of

00:06:55,300 --> 00:07:01,330
important features Jasmine marbles lets

00:06:58,540 --> 00:07:04,270
you visually test observables by writing

00:07:01,330 --> 00:07:05,590
diagrams that describe that behavior and

00:07:04,270 --> 00:07:07,780
these diagrams are really important

00:07:05,590 --> 00:07:10,390
they're gonna allow us to express time

00:07:07,780 --> 00:07:13,660
and sequencing really elegantly and this

00:07:10,390 --> 00:07:15,730
is essential to test complex effects it

00:07:13,660 --> 00:07:17,920
also extends the corset of jasmine

00:07:15,730 --> 00:07:19,150
mattress to let you make assertions

00:07:17,920 --> 00:07:21,910
against the behavior of these

00:07:19,150 --> 00:07:23,680
observables and so this is gonna be kind

00:07:21,910 --> 00:07:25,540
of the mind-melting part there's a full

00:07:23,680 --> 00:07:27,760
talk about this in this session today

00:07:25,540 --> 00:07:29,470
about jasmine marbles and there's kind

00:07:27,760 --> 00:07:31,270
of an important question I have do we

00:07:29,470 --> 00:07:34,450
have to write marble tests for every

00:07:31,270 --> 00:07:37,840
single effect yes okay actually you

00:07:34,450 --> 00:07:39,160
don't know this is not a silver bullet

00:07:37,840 --> 00:07:40,990
testing tool and we're gonna kind of

00:07:39,160 --> 00:07:42,490
cover it lightly but this is for your

00:07:40,990 --> 00:07:43,690
really complex effects and we'll show

00:07:42,490 --> 00:07:48,400
you some examples of that later in the

00:07:43,690 --> 00:07:51,130
talk okay so what is this library look

00:07:48,400 --> 00:07:54,250
like and what is a marble diagram here's

00:07:51,130 --> 00:07:58,060
kind of a simple test that we can write

00:07:54,250 --> 00:07:59,890
using Jasmine marbles so here we are

00:07:58,060 --> 00:08:01,840
importing two utility functions from

00:07:59,890 --> 00:08:04,060
jasmine marbles the cold function which

00:08:01,840 --> 00:08:09,190
lets you create a code observable and

00:08:04,060 --> 00:08:11,140
the test scheduler function and so what

00:08:09,190 --> 00:08:13,000
we're doing is we're describing this

00:08:11,140 --> 00:08:14,770
cold observable using a marble diagram

00:08:13,000 --> 00:08:17,590
and providing that marble diagram with

00:08:14,770 --> 00:08:19,840
some context then we can subscribe this

00:08:17,590 --> 00:08:22,330
observable like any other observable but

00:08:19,840 --> 00:08:24,700
it's using virtual time so we then have

00:08:22,330 --> 00:08:26,890
to get what's called a test scheduler we

00:08:24,700 --> 00:08:29,230
flush it to caused virtual time to kind

00:08:26,890 --> 00:08:33,820
of run instantaneously so let's walk

00:08:29,230 --> 00:08:36,370
through this a little bit more so the

00:08:33,820 --> 00:08:37,990
each string each piece in the string of

00:08:36,370 --> 00:08:40,390
a mile diagram represents a certain

00:08:37,990 --> 00:08:43,000
things so in this case if we look at

00:08:40,390 --> 00:08:45,610
what's inside the cold function we have

00:08:43,000 --> 00:08:48,130
in a marble diagram that weights 30

00:08:45,610 --> 00:08:51,460
frames or 30 milliseconds of time

00:08:48,130 --> 00:08:52,030
it emits a value hello weights 20 more

00:08:51,460 --> 00:08:54,820
frames

00:08:52,030 --> 00:08:58,210
omits world 20 more and then the

00:08:54,820 --> 00:08:59,440
observable completes okay but I think we

00:08:58,210 --> 00:09:01,090
should probably show them a few more

00:08:59,440 --> 00:09:04,120
examples of this marble syntax before we

00:09:01,090 --> 00:09:05,620
get to some tests so again with that

00:09:04,120 --> 00:09:08,170
diagram that brand was just showing you

00:09:05,620 --> 00:09:11,050
every dash represents ten milliseconds

00:09:08,170 --> 00:09:12,550
of time each character represents an

00:09:11,050 --> 00:09:14,710
item that that observable is going to

00:09:12,550 --> 00:09:16,510
admit and then the bar at the end

00:09:14,710 --> 00:09:19,360
signifies that this observable is going

00:09:16,510 --> 00:09:21,370
to complete so this diagram describes an

00:09:19,360 --> 00:09:23,320
unobservable that's going to emit a and

00:09:21,370 --> 00:09:25,030
B at different points in time and then

00:09:23,320 --> 00:09:28,480
we'll eventually complete at some time

00:09:25,030 --> 00:09:31,390
in the future taking a look at another

00:09:28,480 --> 00:09:34,150
example we're gonna wait six frames it

00:09:31,390 --> 00:09:35,860
made a value from D another couple of

00:09:34,150 --> 00:09:38,500
frames and then we're going to use the

00:09:35,860 --> 00:09:40,690
pound sign to emit and error as opposed

00:09:38,500 --> 00:09:42,850
to a completion so the marble diagrams

00:09:40,690 --> 00:09:46,690
lets you both a model observables that

00:09:42,850 --> 00:09:48,250
complete or air out it can also actually

00:09:46,690 --> 00:09:50,410
model some kind of interesting

00:09:48,250 --> 00:09:52,120
observables that come out of the box for

00:09:50,410 --> 00:09:54,310
instance here's one that just kind of

00:09:52,120 --> 00:09:56,440
keeps on waiting over a duration of time

00:09:54,310 --> 00:09:58,990
it never emits a value it never

00:09:56,440 --> 00:10:01,330
completes it never errors out we've ever

00:09:58,990 --> 00:10:05,980
used observable never this would be the

00:10:01,330 --> 00:10:08,620
equivalent diagram for that marble

00:10:05,980 --> 00:10:10,390
diagrams also lets you group emission of

00:10:08,620 --> 00:10:11,890
values together so here we're

00:10:10,390 --> 00:10:14,950
immediately we're waiting three frames

00:10:11,890 --> 00:10:16,960
we're going to emit or group the values

00:10:14,950 --> 00:10:19,390
for a and B together using parentheses

00:10:16,960 --> 00:10:23,290
waiting a couple more frames and then

00:10:19,390 --> 00:10:25,780
completing so if you've ever written an

00:10:23,290 --> 00:10:28,390
effect where your service aired out and

00:10:25,780 --> 00:10:29,890
you didn't actually want to dispatch an

00:10:28,390 --> 00:10:31,870
action maybe because we don't do good

00:10:29,890 --> 00:10:33,910
air handling this observable should be

00:10:31,870 --> 00:10:35,980
very familiar to you this is the empty

00:10:33,910 --> 00:10:38,200
observable so it doesn't emit anything

00:10:35,980 --> 00:10:42,610
it doesn't wait any amount of time it is

00:10:38,200 --> 00:10:45,490
complete right away so let's go back to

00:10:42,610 --> 00:10:49,420
this code sample what is this actually

00:10:45,490 --> 00:10:52,480
doing Brandon so actually this marble

00:10:49,420 --> 00:10:54,700
diagram is using the schedule as we've

00:10:52,480 --> 00:10:57,340
mentioned before using the scheduler to

00:10:54,700 --> 00:11:00,400
simulate time and after this sequence

00:10:57,340 --> 00:11:02,470
happened we call flush to start that

00:11:00,400 --> 00:11:04,150
sequence and run the in this case we

00:11:02,470 --> 00:11:06,010
subscribe to the observable and start

00:11:04,150 --> 00:11:08,830
that test and this happens

00:11:06,010 --> 00:11:11,020
using a scheduler and so we kind of need

00:11:08,830 --> 00:11:12,640
to talk about our ex schedulers and I

00:11:11,020 --> 00:11:14,920
apologize we're trying to go into the

00:11:12,640 --> 00:11:17,290
weeds of how our ex works with these but

00:11:14,920 --> 00:11:20,560
basically a scheduler is a primitive

00:11:17,290 --> 00:11:22,840
inside of rxjs that simply schedules

00:11:20,560 --> 00:11:26,020
tasks to perform at a certain time in

00:11:22,840 --> 00:11:28,450
your application any observable or

00:11:26,020 --> 00:11:31,540
operator that deals with this uses a

00:11:28,450 --> 00:11:33,040
scheduler to wait some amount of time so

00:11:31,540 --> 00:11:35,380
what we can do is we can leverage

00:11:33,040 --> 00:11:37,720
schedulers in our ex to change the

00:11:35,380 --> 00:11:39,820
behavior of observables and operators to

00:11:37,720 --> 00:11:44,050
work in virtual time rather than in real

00:11:39,820 --> 00:11:46,720
time so if you've ever used the interval

00:11:44,050 --> 00:11:48,730
observable in rxjs it is an observable

00:11:46,720 --> 00:11:50,830
where you can give it a fixed number of

00:11:48,730 --> 00:11:53,700
milliseconds and every time that many

00:11:50,830 --> 00:11:55,840
milliseconds passes it emits an item

00:11:53,700 --> 00:11:59,230
behind the scenes this is using a

00:11:55,840 --> 00:12:01,660
scheduler and that scheduler is called

00:11:59,230 --> 00:12:03,970
the async scheduler it uses set timeout

00:12:01,660 --> 00:12:06,220
behind the background to create a

00:12:03,970 --> 00:12:08,770
observable that emits every 17

00:12:06,220 --> 00:12:10,720
milliseconds what we can do is we can

00:12:08,770 --> 00:12:13,000
actually tell this interval observable

00:12:10,720 --> 00:12:16,360
don't use the async scheduler by default

00:12:13,000 --> 00:12:18,040
instead use a different scheduler for

00:12:16,360 --> 00:12:20,350
instance if we want this one to run in

00:12:18,040 --> 00:12:22,570
an animation frame instead of a set

00:12:20,350 --> 00:12:23,950
timeout we could replace the async

00:12:22,570 --> 00:12:26,500
scheduler with the animation frame

00:12:23,950 --> 00:12:28,480
scheduler I want to talk about how this

00:12:26,500 --> 00:12:30,550
integrates further but there's a an

00:12:28,480 --> 00:12:32,350
interesting nugget in this slide and if

00:12:30,550 --> 00:12:36,040
you find out what that is come see us

00:12:32,350 --> 00:12:37,810
after the talks over so marble testing

00:12:36,040 --> 00:12:39,910
uses virtual time we've said it a couple

00:12:37,810 --> 00:12:41,800
of times and so if we take that previous

00:12:39,910 --> 00:12:44,230
code example we can actually make this

00:12:41,800 --> 00:12:46,540
interval observable operate in virtual

00:12:44,230 --> 00:12:50,470
time by using the test scheduler instead

00:12:46,540 --> 00:12:52,780
of the async scheduler so with jasmine

00:12:50,470 --> 00:12:54,970
marbles let's see how we how we would

00:12:52,780 --> 00:12:58,030
get that running and this set up is even

00:12:54,970 --> 00:13:00,700
less involved in what is with gest

00:12:58,030 --> 00:13:04,000
because since Jasmine marbles is

00:13:00,700 --> 00:13:06,310
integrated with integrated with your

00:13:04,000 --> 00:13:08,860
test Runner all we have to do is install

00:13:06,310 --> 00:13:10,450
the package and we can use that use the

00:13:08,860 --> 00:13:12,400
package out of the box when you start to

00:13:10,450 --> 00:13:14,110
write your tests when you install jazz

00:13:12,400 --> 00:13:16,480
and marbles it's going to add a custom

00:13:14,110 --> 00:13:18,880
matcher to the expectations that are

00:13:16,480 --> 00:13:19,870
built into Jasmine and it's going to

00:13:18,880 --> 00:13:21,550
cause your tests

00:13:19,870 --> 00:13:23,470
go ahead and flush that test scheduler

00:13:21,550 --> 00:13:24,520
after every test is run so that you

00:13:23,470 --> 00:13:29,770
don't actually really have to interact

00:13:24,520 --> 00:13:31,870
that test scheduler too much so next

00:13:29,770 --> 00:13:34,270
we're going to talk about a library that

00:13:31,870 --> 00:13:37,150
we have used for a while but we

00:13:34,270 --> 00:13:40,060
previously open sourced and that's the

00:13:37,150 --> 00:13:42,520
angular testing library so the angular

00:13:40,060 --> 00:13:43,510
testing library is the last we're going

00:13:42,520 --> 00:13:45,300
to talk about before we start getting

00:13:43,510 --> 00:13:47,350
into tests and it gives you three things

00:13:45,300 --> 00:13:49,810
it allows you to create component

00:13:47,350 --> 00:13:52,240
fixtures very quickly if you've ever had

00:13:49,810 --> 00:13:54,130
to set up a test using the testbed it

00:13:52,240 --> 00:13:55,630
can be kind of verbose to get your test

00:13:54,130 --> 00:13:58,950
set up correctly to make assertions

00:13:55,630 --> 00:14:01,750
about components it also lets you

00:13:58,950 --> 00:14:04,240
magically mock out dependencies and I

00:14:01,750 --> 00:14:06,790
say magic because there's some magic

00:14:04,240 --> 00:14:08,560
going underneath but as with anything

00:14:06,790 --> 00:14:10,180
else if you want to take a look at the

00:14:08,560 --> 00:14:12,040
source code you can see what it's doing

00:14:10,180 --> 00:14:13,600
underneath it also is going to let us

00:14:12,040 --> 00:14:15,310
use that snapshot testing tool that we

00:14:13,600 --> 00:14:17,860
showed earlier against angular

00:14:15,310 --> 00:14:21,070
components so what is it going to do

00:14:17,860 --> 00:14:23,680
behind the scenes so we want to keep our

00:14:21,070 --> 00:14:26,830
tests lightweight and if you're familiar

00:14:23,680 --> 00:14:28,570
with the testbed if you're just using it

00:14:26,830 --> 00:14:30,610
out of the box without these helper

00:14:28,570 --> 00:14:32,050
functions there's a couple of things you

00:14:30,610 --> 00:14:35,290
would do when you want to keep your

00:14:32,050 --> 00:14:37,990
tests lightweight and fast the first is

00:14:35,290 --> 00:14:40,839
just disabling animations so we bring in

00:14:37,990 --> 00:14:43,150
a no op animations module for that the

00:14:40,839 --> 00:14:44,680
biggest one that helps with keep your

00:14:43,150 --> 00:14:47,140
components lightweight especially when

00:14:44,680 --> 00:14:50,380
you're using snapshots is using an

00:14:47,140 --> 00:14:53,110
auteur schema this allows you to keep

00:14:50,380 --> 00:14:55,330
your component templates you to use

00:14:53,110 --> 00:14:57,010
shallow rendering which only renders

00:14:55,330 --> 00:14:59,260
those components that you explicitly

00:14:57,010 --> 00:15:01,480
rated register in your test or import

00:14:59,260 --> 00:15:02,830
with any other modules and so we were

00:15:01,480 --> 00:15:05,170
doing this in every single component

00:15:02,830 --> 00:15:07,990
because as the developers of index we

00:15:05,170 --> 00:15:10,750
kind of love boilerplate but talk about

00:15:07,990 --> 00:15:12,250
boilerplate with that being said we

00:15:10,750 --> 00:15:13,779
wanted to create a library that kind of

00:15:12,250 --> 00:15:16,150
did this all for you and give you the

00:15:13,779 --> 00:15:18,100
right behavior so with angular testing

00:15:16,150 --> 00:15:19,870
library instead we give you a function

00:15:18,100 --> 00:15:22,690
that kind of abstracts us away for you

00:15:19,870 --> 00:15:24,339
called crate component fixture and

00:15:22,690 --> 00:15:27,370
create component fixture as we say it

00:15:24,339 --> 00:15:29,140
wraps up these is utility function so

00:15:27,370 --> 00:15:32,260
that we can you can use shallow running

00:15:29,140 --> 00:15:33,100
out of the box or disable it if you want

00:15:32,260 --> 00:15:35,530
to do a full more

00:15:33,100 --> 00:15:37,540
a full-blown integration test it also

00:15:35,530 --> 00:15:39,550
allows you to provide all the same test

00:15:37,540 --> 00:15:41,800
module metadata that you're used to with

00:15:39,550 --> 00:15:44,290
the testbed so you can specify imports

00:15:41,800 --> 00:15:46,750
declarations and providers as your test

00:15:44,290 --> 00:15:49,770
needs them and what it returns to you is

00:15:46,750 --> 00:15:52,750
an instance of a component test fixture

00:15:49,770 --> 00:15:54,760
this component text fish test fixture

00:15:52,750 --> 00:15:56,500
gives you like I said a few helper

00:15:54,760 --> 00:15:58,840
methods to let you compile your

00:15:56,500 --> 00:16:01,270
component let your in change the texture

00:15:58,840 --> 00:16:03,730
get dependencies from the injector or

00:16:01,270 --> 00:16:06,490
even access the underlying component for

00:16:03,730 --> 00:16:08,950
more advanced query because when you're

00:16:06,490 --> 00:16:11,290
doing component unit tests you these are

00:16:08,950 --> 00:16:14,110
going to be small but if you have if you

00:16:11,290 --> 00:16:16,060
use this fixture with larger components

00:16:14,110 --> 00:16:18,430
then you can use the advanced querying

00:16:16,060 --> 00:16:20,200
to get down to individual elements and

00:16:18,430 --> 00:16:21,790
so just like with jasmine marbles

00:16:20,200 --> 00:16:23,680
setting this one up is extremely easy

00:16:21,790 --> 00:16:26,620
all you have to do is install from NPM

00:16:23,680 --> 00:16:28,210
and it'll just work so those three

00:16:26,620 --> 00:16:29,590
testing tools out of the way let's get

00:16:28,210 --> 00:16:32,050
to what we're all kind of here for and

00:16:29,590 --> 00:16:34,600
that is testing in grx and we're gonna

00:16:32,050 --> 00:16:37,360
use these three tools to write fast

00:16:34,600 --> 00:16:40,960
performant tests for in an in grx

00:16:37,360 --> 00:16:42,640
application so let's look at some of our

00:16:40,960 --> 00:16:45,910
test targets within Jurek's

00:16:42,640 --> 00:16:47,770
and if you're familiar with this these

00:16:45,910 --> 00:16:49,150
are the building blocks that we use when

00:16:47,770 --> 00:16:51,940
we they were going to write these tests

00:16:49,150 --> 00:16:53,620
for so first we're going to talk a

00:16:51,940 --> 00:16:55,630
little bit about presentation and smart

00:16:53,620 --> 00:16:57,220
components smart components are the

00:16:55,630 --> 00:16:59,440
components that are actually store where

00:16:57,220 --> 00:17:01,840
they connect to the store select data

00:16:59,440 --> 00:17:03,400
out of them and dispatch actions we're

00:17:01,840 --> 00:17:05,380
also gonna show presentation components

00:17:03,400 --> 00:17:07,090
they're reusable there and they're more

00:17:05,380 --> 00:17:08,740
concerned with like layout and styling

00:17:07,090 --> 00:17:10,510
and they're mostly built with inputs and

00:17:08,740 --> 00:17:13,590
outputs or with your active forms

00:17:10,510 --> 00:17:17,020
library we're also going to talk about

00:17:13,590 --> 00:17:18,490
side effects and these are side effects

00:17:17,020 --> 00:17:20,860
are powerful because they reduce the

00:17:18,490 --> 00:17:23,050
responsibility of components to only

00:17:20,860 --> 00:17:24,760
dispatching actions and selecting state

00:17:23,050 --> 00:17:26,080
they're gonna be the hardest test to

00:17:24,760 --> 00:17:28,150
write but we're gonna leverage that

00:17:26,080 --> 00:17:30,040
marble testing library to hopefully make

00:17:28,150 --> 00:17:32,320
that a little bit easier we're also

00:17:30,040 --> 00:17:34,420
going to test selectors which let you

00:17:32,320 --> 00:17:37,120
select and compose pieces of state using

00:17:34,420 --> 00:17:38,590
functions so that being said Brandon

00:17:37,120 --> 00:17:39,640
once you show them the application that

00:17:38,590 --> 00:17:43,270
we're gonna actually be writing some

00:17:39,640 --> 00:17:46,030
tests for today so if you've used the

00:17:43,270 --> 00:17:46,780
example app in the ng rx repo this is

00:17:46,030 --> 00:17:49,390
going to seem

00:17:46,780 --> 00:17:52,570
very familiar it will allow you to login

00:17:49,390 --> 00:17:54,220
to a book collection and once you are

00:17:52,570 --> 00:17:56,620
authenticated it is going to show you

00:17:54,220 --> 00:17:58,690
your book collection and we always kind

00:17:56,620 --> 00:18:00,820
of like this example out because it has

00:17:58,690 --> 00:18:02,470
a lot of things in it that at normal

00:18:00,820 --> 00:18:04,330
index application is going to have its

00:18:02,470 --> 00:18:06,280
going to have derive state complex

00:18:04,330 --> 00:18:10,410
reducers and effects that communicate

00:18:06,280 --> 00:18:10,410
with the backend so let's get testing

00:18:17,100 --> 00:18:21,210
so first we're going to talk about

00:18:18,750 --> 00:18:23,519
testing reducers and a good thing about

00:18:21,210 --> 00:18:25,769
reducers is that they're pure functions

00:18:23,519 --> 00:18:28,710
so out of the box they are just easy to

00:18:25,769 --> 00:18:30,929
test so what do you mean by this well

00:18:28,710 --> 00:18:32,429
let's take a look at a reducer function

00:18:30,929 --> 00:18:33,779
and talk about the things that we're

00:18:32,429 --> 00:18:35,909
gonna actually want to test about it

00:18:33,779 --> 00:18:38,639
there are two conditional branches in

00:18:35,909 --> 00:18:39,929
this function every case statement in a

00:18:38,639 --> 00:18:41,460
switch is going to count as a

00:18:39,929 --> 00:18:44,539
conditional branch that we're gonna want

00:18:41,460 --> 00:18:46,289
to try and capture with a unit test

00:18:44,539 --> 00:18:49,200
we're also going to want to make sure

00:18:46,289 --> 00:18:51,570
that we are going to be returning state

00:18:49,200 --> 00:18:53,389
unmodified if we pass in an action type

00:18:51,570 --> 00:18:55,470
that is unrecognized by this reducer

00:18:53,389 --> 00:18:57,929
there are a couple of interesting

00:18:55,470 --> 00:19:00,299
qualities about this function it is

00:18:57,929 --> 00:19:02,779
completely immutable and you know that

00:19:00,299 --> 00:19:04,950
since that is a pattern that we

00:19:02,779 --> 00:19:06,840
implement during within Jurek's

00:19:04,950 --> 00:19:09,240
you don't have to worry about modifying

00:19:06,840 --> 00:19:10,529
any of its arguments it's a pure

00:19:09,240 --> 00:19:12,600
function and you're gonna see how this

00:19:10,529 --> 00:19:14,879
is gonna really reduce the scope of the

00:19:12,600 --> 00:19:16,230
test that we have to write for it so

00:19:14,879 --> 00:19:19,049
let's take a look let's talk a little

00:19:16,230 --> 00:19:20,639
bit about functional purity we're going

00:19:19,049 --> 00:19:22,230
about writing these unit tests because

00:19:20,639 --> 00:19:26,399
this is gonna come up a lot in an Ender

00:19:22,230 --> 00:19:28,950
X application so a function is pure if

00:19:26,399 --> 00:19:30,870
it always produces the same output from

00:19:28,950 --> 00:19:32,370
the given input and has no observable

00:19:30,870 --> 00:19:35,730
side-effects I copied that from

00:19:32,370 --> 00:19:38,360
Wikipedia what does it actually mean

00:19:35,730 --> 00:19:40,950
what is a side-effect side-effects is

00:19:38,360 --> 00:19:42,960
something that did a side-effect if it

00:19:40,950 --> 00:19:44,059
might modify a global variable or a

00:19:42,960 --> 00:19:46,470
static variable

00:19:44,059 --> 00:19:49,230
rivo bow variable and modify one of its

00:19:46,470 --> 00:19:51,990
arguments take throws an exception or

00:19:49,230 --> 00:19:54,750
produces side effecting side-effect code

00:19:51,990 --> 00:19:56,820
and so a reducer function tends to not

00:19:54,750 --> 00:19:58,740
have any of these qualities instead a

00:19:56,820 --> 00:20:00,720
good reducer function will always

00:19:58,740 --> 00:20:03,000
produce the same output for a given

00:20:00,720 --> 00:20:05,220
state and an action it doesn't rely on

00:20:03,000 --> 00:20:07,379
dependency injection it's not going to

00:20:05,220 --> 00:20:09,389
require global State for it to operate

00:20:07,379 --> 00:20:10,740
in one way or another and it doesn't

00:20:09,389 --> 00:20:12,629
really have any side effects in those

00:20:10,740 --> 00:20:15,750
we've isolated those to the side effects

00:20:12,629 --> 00:20:17,639
using ng or ex effects so let's take a

00:20:15,750 --> 00:20:21,210
look at some examples to grap our head

00:20:17,639 --> 00:20:24,659
around functional purity so this first

00:20:21,210 --> 00:20:27,210
function is pure it takes in an input

00:20:24,659 --> 00:20:28,710
returns a new string with the name

00:20:27,210 --> 00:20:32,250
prefixed from

00:20:28,710 --> 00:20:33,929
but here's an impure function and this

00:20:32,250 --> 00:20:36,510
one's impure because it's taking an

00:20:33,929 --> 00:20:38,309
array and it's modifying that array it

00:20:36,510 --> 00:20:39,899
by pushing an item into it this is an

00:20:38,309 --> 00:20:43,559
impure function because it's modifying

00:20:39,899 --> 00:20:45,240
one of its arguments we have another

00:20:43,559 --> 00:20:46,770
function here and this this looks

00:20:45,240 --> 00:20:47,250
familiar where you're bootstrapping it

00:20:46,770 --> 00:20:49,320
out

00:20:47,250 --> 00:20:51,120
this one's impure it reads from the

00:20:49,320 --> 00:20:53,220
global state which is window in this

00:20:51,120 --> 00:20:58,559
case and Karl side-effect producing code

00:20:53,220 --> 00:21:00,480
which is mousse trapping your app here's

00:20:58,559 --> 00:21:03,929
another impure function this one's using

00:21:00,480 --> 00:21:05,820
fetch to start an HTTP request promises

00:21:03,929 --> 00:21:07,409
are really eager so this is causing side

00:21:05,820 --> 00:21:09,620
effects producing code to start up

00:21:07,409 --> 00:21:12,120
immediately when I call this function

00:21:09,620 --> 00:21:14,490
here's the tricky one any guesses that

00:21:12,120 --> 00:21:19,289
this is a pure or impure function doing

00:21:14,490 --> 00:21:20,630
these curveballs no guesses pure yeah

00:21:19,289 --> 00:21:22,980
it's pure and it's kind of a tricky one

00:21:20,630 --> 00:21:24,600
observables are lazy nothing happens

00:21:22,980 --> 00:21:26,640
until you subscribe to them we're not

00:21:24,600 --> 00:21:28,380
modifying any arguments we're not

00:21:26,640 --> 00:21:30,659
causing any Network requests to start up

00:21:28,380 --> 00:21:33,179
immediately instead for any given input

00:21:30,659 --> 00:21:35,190
we're always returning the same HTTP

00:21:33,179 --> 00:21:40,679
observable and nothing happens until I

00:21:35,190 --> 00:21:43,140
get subscribe to so by encapsulating

00:21:40,679 --> 00:21:45,390
this logic and pure functions we

00:21:43,140 --> 00:21:47,669
dramatically reduce the scope of these

00:21:45,390 --> 00:21:49,470
tips that we have to write we don't need

00:21:47,669 --> 00:21:50,760
to mock out any side-effect producing

00:21:49,470 --> 00:21:52,740
code that means we're not gonna have to

00:21:50,760 --> 00:21:54,990
set up any spies well not have to work

00:21:52,740 --> 00:21:57,270
with the testbed to configure dependency

00:21:54,990 --> 00:21:58,409
injection and that's really gonna save

00:21:57,270 --> 00:22:01,049
us a lot of time when writing these

00:21:58,409 --> 00:22:03,570
tests all we have to do is supply the

00:22:01,049 --> 00:22:06,450
function with legal input defined by the

00:22:03,570 --> 00:22:09,120
type type signature and then we can

00:22:06,450 --> 00:22:10,860
assert the output in our tests all right

00:22:09,120 --> 00:22:15,779
let's write and some example tests then

00:22:10,860 --> 00:22:17,100
for testing a reducer function so as

00:22:15,779 --> 00:22:18,779
you'll kind of see Brandon's a much

00:22:17,100 --> 00:22:21,630
better typist than I am so I'm gonna let

00:22:18,779 --> 00:22:23,190
him write the tests of this morning and

00:22:21,630 --> 00:22:26,610
the reducer function that we want to

00:22:23,190 --> 00:22:27,330
test really has two things that we want

00:22:26,610 --> 00:22:29,490
to say about it

00:22:27,330 --> 00:22:32,640
we want to verify that if we give it an

00:22:29,490 --> 00:22:34,640
undefined state with an action it always

00:22:32,640 --> 00:22:36,630
returns the initial state back out to us

00:22:34,640 --> 00:22:39,270
the second thing that we want to verify

00:22:36,630 --> 00:22:41,260
is that it'll load books on success so

00:22:39,270 --> 00:22:44,500
let's take a look at that first test

00:22:41,260 --> 00:22:46,720
so for this first test the code that I'm

00:22:44,500 --> 00:22:50,260
showing here is using the reducer from

00:22:46,720 --> 00:22:52,179
our the books reducer and we're passing

00:22:50,260 --> 00:22:54,760
an initial state and we're passing a

00:22:52,179 --> 00:22:56,710
type that the reducer is unaware of and

00:22:54,760 --> 00:22:59,470
in this case we're just using the type

00:22:56,710 --> 00:23:01,179
as in it we have to cast it as any

00:22:59,470 --> 00:23:02,860
because when we go right these reducer

00:23:01,179 --> 00:23:04,840
functions we give them really narrow

00:23:02,860 --> 00:23:06,549
type signatures but really this is an

00:23:04,840 --> 00:23:08,890
important test because it verifies that

00:23:06,549 --> 00:23:13,000
our reducer can handle actions that it

00:23:08,890 --> 00:23:17,080
wasn't actually aware of so saving this

00:23:13,000 --> 00:23:20,830
test and if we look at our test bed we

00:23:17,080 --> 00:23:24,309
can verify that that test ran and that

00:23:20,830 --> 00:23:27,220
state passed through that reducer and we

00:23:24,309 --> 00:23:28,630
returned exactly as it was passed in so

00:23:27,220 --> 00:23:30,340
this is kind of a straightforward test

00:23:28,630 --> 00:23:32,320
because we already have the initial

00:23:30,340 --> 00:23:34,540
state being exported from this reducer

00:23:32,320 --> 00:23:36,520
but if we want to make an assertion

00:23:34,540 --> 00:23:38,650
about an actual state transition that

00:23:36,520 --> 00:23:42,940
maybe adds books to the state it gets a

00:23:38,650 --> 00:23:44,470
little bit more complicated so the first

00:23:42,940 --> 00:23:46,179
thing we want to do is we want to set up

00:23:44,470 --> 00:23:48,669
some actions that we're going to pass in

00:23:46,179 --> 00:23:50,470
to this reducer function and one of the

00:23:48,669 --> 00:23:52,809
nice things about it being a reducer

00:23:50,470 --> 00:23:55,780
function is it as a legal input to array

00:23:52,809 --> 00:23:58,240
dot reduce so we can do is we can create

00:23:55,780 --> 00:24:00,309
an array of these two actions first init

00:23:58,240 --> 00:24:02,740
and then load then we can call dot

00:24:00,309 --> 00:24:04,210
reduce on that array we can pass in our

00:24:02,740 --> 00:24:06,220
reducer function along with the initial

00:24:04,210 --> 00:24:08,799
state and it's actually give us the

00:24:06,220 --> 00:24:13,000
final output as the reducer transition

00:24:08,799 --> 00:24:14,380
between those actions finally we can

00:24:13,000 --> 00:24:16,150
make an assertion that this state

00:24:14,380 --> 00:24:17,740
matches snapshot and you'll notice that

00:24:16,150 --> 00:24:20,049
for a second there it was underlined

00:24:17,740 --> 00:24:22,660
yellow that's because we're using vs

00:24:20,049 --> 00:24:24,490
code plugin called snapshot tools that

00:24:22,660 --> 00:24:26,620
allows us to inspect snapshots from our

00:24:24,490 --> 00:24:28,929
editor so now that we've saved this

00:24:26,620 --> 00:24:32,320
snapshot I can actually just hover over

00:24:28,929 --> 00:24:34,540
the two men snapshot and see what is in

00:24:32,320 --> 00:24:36,460
that snapshot file we didn't have to

00:24:34,540 --> 00:24:38,020
write this assertion ourselves instead

00:24:36,460 --> 00:24:40,090
this was saved to the disk and we can

00:24:38,020 --> 00:24:43,360
capture this and commit it to our

00:24:40,090 --> 00:24:45,070
repository and as we mentioned before we

00:24:43,360 --> 00:24:48,250
didn't have to copy that entire block

00:24:45,070 --> 00:24:50,890
which is nice and so this is a much

00:24:48,250 --> 00:24:53,169
easier way to write tests for reducer

00:24:50,890 --> 00:24:54,790
functions it's very straightforward pass

00:24:53,169 --> 00:24:56,950
in some state and some number

00:24:54,790 --> 00:24:59,140
of actions and then just snapshot the

00:24:56,950 --> 00:25:03,100
output it gives you a quick way to test

00:24:59,140 --> 00:25:05,500
reduce your functions so now that we've

00:25:03,100 --> 00:25:07,120
written tasks for reducers let's like

00:25:05,500 --> 00:25:09,640
take a look at testing selector

00:25:07,120 --> 00:25:11,170
functions and one of the nice quality of

00:25:09,640 --> 00:25:12,790
selector functions is that just like

00:25:11,170 --> 00:25:14,500
reducers these are going to be pure

00:25:12,790 --> 00:25:16,630
functions that means we can again

00:25:14,500 --> 00:25:19,990
leverage snapshot testing to verify they

00:25:16,630 --> 00:25:22,000
work correctly we can also use snapshot

00:25:19,990 --> 00:25:24,550
testing to verify the output of the

00:25:22,000 --> 00:25:26,050
selector as opposed to writing brittle

00:25:24,550 --> 00:25:28,420
object comparisons like we mentioned

00:25:26,050 --> 00:25:30,610
before we'll also take a look at how we

00:25:28,420 --> 00:25:32,620
can write tests for really complex

00:25:30,610 --> 00:25:35,620
selectors that require a lot of state

00:25:32,620 --> 00:25:37,450
setup and to do that we kind of needed

00:25:35,620 --> 00:25:39,340
to find that there are two types of

00:25:37,450 --> 00:25:41,950
selectors and an Ender X application

00:25:39,340 --> 00:25:44,050
they are getters which simply retrieve

00:25:41,950 --> 00:25:45,910
values from the state and then there are

00:25:44,050 --> 00:25:47,950
derive and these are the complex ones

00:25:45,910 --> 00:25:50,500
that take the outputs from multiple

00:25:47,950 --> 00:25:54,610
selectors and derive some new state from

00:25:50,500 --> 00:25:56,710
it so if we look at a couple of examples

00:25:54,610 --> 00:25:59,040
here gaiter functions are

00:25:56,710 --> 00:26:01,570
straightforward to test and these are

00:25:59,040 --> 00:26:04,210
functions that you'll use in your local

00:26:01,570 --> 00:26:06,220
reducer file that you compose later

00:26:04,210 --> 00:26:08,290
together so all we'll have to do for

00:26:06,220 --> 00:26:10,030
these is what to pass in some legal

00:26:08,290 --> 00:26:11,950
state to them and then make sure they

00:26:10,030 --> 00:26:13,750
got the right property out of that state

00:26:11,950 --> 00:26:15,520
we can just use a simple reference

00:26:13,750 --> 00:26:19,000
equality assertion for these tests we

00:26:15,520 --> 00:26:20,590
don't even need snapshot testing the

00:26:19,000 --> 00:26:23,440
robbers are on the other hand are a

00:26:20,590 --> 00:26:25,480
little more complex to test we could set

00:26:23,440 --> 00:26:27,340
up an entire mock state to pass in this

00:26:25,480 --> 00:26:29,590
test but that requires more setup than

00:26:27,340 --> 00:26:32,200
we want to do one of the nice things

00:26:29,590 --> 00:26:34,360
about the create selector function in

00:26:32,200 --> 00:26:36,220
index is it actually lets you just test

00:26:34,360 --> 00:26:37,690
the piece of this that is doing

00:26:36,220 --> 00:26:39,760
something interesting and that is the

00:26:37,690 --> 00:26:42,190
projection function so we'll see how we

00:26:39,760 --> 00:26:44,290
can isolate the projector function from

00:26:42,190 --> 00:26:49,480
these selectors and test those

00:26:44,290 --> 00:26:52,860
independently so it's jumped in to

00:26:49,480 --> 00:26:52,860
testing some of these lectures now

00:26:54,600 --> 00:26:59,289
so in the same reducer there are a

00:26:57,100 --> 00:27:00,400
couple for a couple of selectors and can

00:26:59,289 --> 00:27:08,710
we take a look at what those selectors

00:27:00,400 --> 00:27:10,990
look like oh these are actually in

00:27:08,710 --> 00:27:12,250
generating with the in or with the index

00:27:10,990 --> 00:27:14,950
entity helper and so what are those

00:27:12,250 --> 00:27:17,620
produce well that produces two get er

00:27:14,950 --> 00:27:20,080
selectors get IDs and get entities these

00:27:17,620 --> 00:27:22,360
just get values out of the state it also

00:27:20,080 --> 00:27:23,470
has one driver select all which is

00:27:22,360 --> 00:27:25,990
actually gonna do something interesting

00:27:23,470 --> 00:27:27,730
in terms of bringing those two pieces of

00:27:25,990 --> 00:27:30,070
safe together to produce the full list

00:27:27,730 --> 00:27:31,030
of books so let's test that one since

00:27:30,070 --> 00:27:33,299
that one's gonna be the harder one to

00:27:31,030 --> 00:27:33,299
test

00:27:41,330 --> 00:27:46,889
so the first thing we need to do is we

00:27:44,099 --> 00:27:48,779
need to pass in some legal state into

00:27:46,889 --> 00:27:50,669
this function and we can do that by

00:27:48,779 --> 00:27:53,029
going up here first and copying the

00:27:50,669 --> 00:27:59,669
state set up from our previous test

00:27:53,029 --> 00:28:01,529
looking use we can also pass in the

00:27:59,669 --> 00:28:03,450
initial state object being given to us

00:28:01,529 --> 00:28:07,409
from the reducer function to make sure

00:28:03,450 --> 00:28:10,080
that this test runs correctly so here we

00:28:07,409 --> 00:28:12,539
as we as I mentioned for we can run this

00:28:10,080 --> 00:28:14,909
function and we can assert against this

00:28:12,539 --> 00:28:17,879
the helper function from this selector

00:28:14,909 --> 00:28:20,009
to get all the books in the first one we

00:28:17,879 --> 00:28:21,509
took a snapshot of what the entire

00:28:20,009 --> 00:28:23,940
collection would look like but here we

00:28:21,509 --> 00:28:26,179
just assert against the length of the

00:28:23,940 --> 00:28:28,289
array that's produced by the selector

00:28:26,179 --> 00:28:29,759
because our initial state isn't how many

00:28:28,289 --> 00:28:31,409
books in it this test is going to fail

00:28:29,759 --> 00:28:33,749
because the length of that will be 0

00:28:31,409 --> 00:28:36,659
instead of 2 we can verify that it fails

00:28:33,749 --> 00:28:39,690
correctly in jest so next let's take a

00:28:36,659 --> 00:28:41,429
look at an integration test that this

00:28:39,690 --> 00:28:42,059
will be a local selector so let's take a

00:28:41,429 --> 00:28:45,119
look at it

00:28:42,059 --> 00:28:49,889
integration test higher up that would be

00:28:45,119 --> 00:28:51,359
used by components so this is we've

00:28:49,889 --> 00:28:53,129
taken that selector and we kind of

00:28:51,359 --> 00:28:54,869
composed it with our global state and

00:28:53,129 --> 00:28:56,309
these are where the selectors get really

00:28:54,869 --> 00:28:59,009
complicated because it requires a

00:28:56,309 --> 00:29:03,119
tremendous amount of setup so if you

00:28:59,009 --> 00:29:05,340
look at this one it looks similar to the

00:29:03,119 --> 00:29:08,249
previous reduce local reducer test I

00:29:05,340 --> 00:29:10,499
just wrote but this will be an

00:29:08,249 --> 00:29:12,599
integration test because the local

00:29:10,499 --> 00:29:14,879
reducer is just operating on that

00:29:12,599 --> 00:29:17,249
particular piece of state this would be

00:29:14,879 --> 00:29:19,229
operating at a higher level to where if

00:29:17,249 --> 00:29:21,210
you're composing different pieces of

00:29:19,229 --> 00:29:24,389
state this is how you would write this

00:29:21,210 --> 00:29:26,279
function and before this is you can see

00:29:24,389 --> 00:29:28,470
how the integration is because selectors

00:29:26,279 --> 00:29:32,220
ending jerks are memorized and so we can

00:29:28,470 --> 00:29:36,570
still pass this state in for this test

00:29:32,220 --> 00:29:38,340
in assert against that but we can do as

00:29:36,570 --> 00:29:40,799
we mentioned before there's an easier

00:29:38,340 --> 00:29:44,970
way to do this and that's using the

00:29:40,799 --> 00:29:47,489
projector function so I've done another

00:29:44,970 --> 00:29:48,509
test here side by side which is going to

00:29:47,489 --> 00:29:53,129
show you how to use the projector

00:29:48,509 --> 00:29:54,870
function to write a test so here every

00:29:53,129 --> 00:29:56,700
selector actually exposes that part

00:29:54,870 --> 00:29:58,620
to function as a static property on the

00:29:56,700 --> 00:30:00,960
selector itself called dot projector and

00:29:58,620 --> 00:30:02,430
that gives us access to just that inner

00:30:00,960 --> 00:30:06,690
function that we really want to write

00:30:02,430 --> 00:30:08,730
test for now we don't have to pass in if

00:30:06,690 --> 00:30:10,740
you want to override just individual

00:30:08,730 --> 00:30:12,330
properties in that selector function

00:30:10,740 --> 00:30:14,340
it's going to be returned that's where

00:30:12,330 --> 00:30:16,770
the projector function really comes in

00:30:14,340 --> 00:30:18,600
handy this keeps us are these keeps our

00:30:16,770 --> 00:30:20,309
selected tests a lot smaller and easier

00:30:18,600 --> 00:30:22,140
to write than if we have to set up the

00:30:20,309 --> 00:30:28,830
full integration with all the reducers

00:30:22,140 --> 00:30:30,630
in our application so now that we've

00:30:28,830 --> 00:30:33,990
talked about how you write tests for

00:30:30,630 --> 00:30:36,059
selectors let's look at writing tests

00:30:33,990 --> 00:30:37,830
for side effects and these are the

00:30:36,059 --> 00:30:39,360
complicated ones again I want to remind

00:30:37,830 --> 00:30:41,490
you that there will be a full talk later

00:30:39,360 --> 00:30:43,140
today about testing observables this is

00:30:41,490 --> 00:30:46,230
kind of get you an introduction into

00:30:43,140 --> 00:30:49,740
what this process might look like side

00:30:46,230 --> 00:30:52,500
effects provide action or into impact

00:30:49,740 --> 00:30:55,170
taking actions and return relevant

00:30:52,500 --> 00:30:57,059
actions based with relevant data based

00:30:55,170 --> 00:30:59,990
on the store back to the based on that

00:30:57,059 --> 00:31:02,580
result so let's take a look at an effect

00:30:59,990 --> 00:31:04,500
well for a common effect that listens

00:31:02,580 --> 00:31:06,420
for actions it's going to initiate some

00:31:04,500 --> 00:31:08,309
side effect and then it's going to map

00:31:06,420 --> 00:31:11,070
the result of that side effect to new

00:31:08,309 --> 00:31:13,140
actions so the first thing we're going

00:31:11,070 --> 00:31:15,840
to want to verify is that for some given

00:31:13,140 --> 00:31:19,500
input action it's actually going to

00:31:15,840 --> 00:31:22,170
break into performing a side effect we

00:31:19,500 --> 00:31:25,380
want first we want to verify that the

00:31:22,170 --> 00:31:27,960
set of actions actually initiated this

00:31:25,380 --> 00:31:29,490
effect and then when assert against to

00:31:27,960 --> 00:31:32,190
enter observable to make sure that it

00:31:29,490 --> 00:31:33,630
behaves correctly and so we can do that

00:31:32,190 --> 00:31:35,970
by looking at the inner part of this

00:31:33,630 --> 00:31:37,770
exhaust map we want to verify that it's

00:31:35,970 --> 00:31:39,900
going to interact with the service call

00:31:37,770 --> 00:31:41,700
correctly when the action is dispatched

00:31:39,900 --> 00:31:45,570
so it's really kind of two things that

00:31:41,700 --> 00:31:47,580
we want to assert about this effect so

00:31:45,570 --> 00:31:50,250
let's look at the strategies when we're

00:31:47,580 --> 00:31:53,040
writing tests for effects we want to use

00:31:50,250 --> 00:31:55,380
Jasmine marbles to verify the behavior

00:31:53,040 --> 00:31:57,630
of inputs and like you said use the

00:31:55,380 --> 00:32:00,660
smaller or a simpler variable to test

00:31:57,630 --> 00:32:04,700
the inner observable let's jump into

00:32:00,660 --> 00:32:04,700
writing some small effects tests

00:32:06,440 --> 00:32:11,670
so in this example application when the

00:32:09,360 --> 00:32:13,620
application loads up it has to reach out

00:32:11,670 --> 00:32:15,270
to the google book service to give us

00:32:13,620 --> 00:32:19,970
all the books that exist in our

00:32:15,270 --> 00:32:23,100
collection and so this effect uses

00:32:19,970 --> 00:32:24,930
anithing operator to map from the action

00:32:23,100 --> 00:32:27,420
into an observable that we're gonna map

00:32:24,930 --> 00:32:28,920
into more actions I just show you a

00:32:27,420 --> 00:32:31,080
quick snippet of what he just mentioned

00:32:28,920 --> 00:32:33,270
here and talking about how the request

00:32:31,080 --> 00:32:34,650
is made and how we're handling mapping

00:32:33,270 --> 00:32:39,210
and handling errors before we write the

00:32:34,650 --> 00:32:41,630
test so brain has already scaffolded out

00:32:39,210 --> 00:32:44,490
some of this test and you can see that

00:32:41,630 --> 00:32:46,830
we're gonna go ahead and use parts of

00:32:44,490 --> 00:32:49,050
the angular testing library that Brent

00:32:46,830 --> 00:32:52,230
and I have written to mount to mock out

00:32:49,050 --> 00:32:54,690
that Google book service here as you see

00:32:52,230 --> 00:32:56,550
we're using Jasmine marbles we use an X

00:32:54,690 --> 00:32:58,470
we're using a few functions Jasmine

00:32:56,550 --> 00:33:01,050
marbles we're using the provide mock

00:32:58,470 --> 00:33:03,450
actions functions that comes with

00:33:01,050 --> 00:33:05,430
indirect effects and we're using the

00:33:03,450 --> 00:33:07,890
angular testing library that provides

00:33:05,430 --> 00:33:09,840
the magical mock function and an

00:33:07,890 --> 00:33:11,880
interface that you can use when you're

00:33:09,840 --> 00:33:13,890
mocking out these services so how did

00:33:11,880 --> 00:33:16,020
this mock function work well first we're

00:33:13,890 --> 00:33:18,090
gonna declare a variable using the mock

00:33:16,020 --> 00:33:19,890
type what this is gonna do is this is

00:33:18,090 --> 00:33:21,360
going to take a service and it's

00:33:19,890 --> 00:33:23,340
actually gonna look at all the functions

00:33:21,360 --> 00:33:25,830
on this service and give you a type back

00:33:23,340 --> 00:33:28,860
that has that service mocked out so it

00:33:25,830 --> 00:33:31,290
replace all those functions with Jasmine

00:33:28,860 --> 00:33:34,170
spies and if you're familiar with doing

00:33:31,290 --> 00:33:36,540
this manually this is the equivalent of

00:33:34,170 --> 00:33:38,720
using a provide object in providing it

00:33:36,540 --> 00:33:41,070
with a use class or a use value and

00:33:38,720 --> 00:33:43,560
mocking out each one of those service

00:33:41,070 --> 00:33:45,120
calls that exist in a given those

00:33:43,560 --> 00:33:47,760
methods that exist in a given service

00:33:45,120 --> 00:33:49,800
and so to set up this magical mock you

00:33:47,760 --> 00:33:52,140
can see on line 35 we're using provide

00:33:49,800 --> 00:33:54,600
magical mock and where's passing in the

00:33:52,140 --> 00:33:56,370
class itself this is gonna set up a

00:33:54,600 --> 00:34:00,780
provider for us that is going to produce

00:33:56,370 --> 00:34:02,880
that mock for us we're also mocking out

00:34:00,780 --> 00:34:04,590
the action stream that you would

00:34:02,880 --> 00:34:08,460
normally use in an effect so that we can

00:34:04,590 --> 00:34:10,470
pass in our own actions during the test

00:34:08,460 --> 00:34:12,000
and provide mock actions as something

00:34:10,470 --> 00:34:16,500
that's provided directly in indirect

00:34:12,000 --> 00:34:19,320
effects as testing library so first this

00:34:16,500 --> 00:34:23,370
look at what a test for this effect

00:34:19,320 --> 00:34:25,560
would look like here we're setting up

00:34:23,370 --> 00:34:27,450
these actions that I mentioned in the

00:34:25,560 --> 00:34:29,520
effect where you're passing in the load

00:34:27,450 --> 00:34:33,389
action and we want to assert against

00:34:29,520 --> 00:34:34,860
what the result is for that the next

00:34:33,389 --> 00:34:37,110
part is we're empty to actually describe

00:34:34,860 --> 00:34:40,590
how the observables work in this effect

00:34:37,110 --> 00:34:42,030
so first for the actions observable we

00:34:40,590 --> 00:34:43,379
don't really need to do anything with a

00:34:42,030 --> 00:34:45,540
marble diagram we can just use

00:34:43,379 --> 00:34:48,770
observable dot of and create an

00:34:45,540 --> 00:34:51,389
observable of just that input action

00:34:48,770 --> 00:34:53,760
next we're going to set up the response

00:34:51,389 --> 00:34:56,760
that we're expecting to return from this

00:34:53,760 --> 00:34:58,620
observable and using the expected

00:34:56,760 --> 00:35:00,390
variable that stores what we want to

00:34:58,620 --> 00:35:02,730
start against when we get to that part

00:35:00,390 --> 00:35:04,710
for these marble diagrams whenever we

00:35:02,730 --> 00:35:06,780
use a character we can supply a second

00:35:04,710 --> 00:35:10,410
object to it that gives that character

00:35:06,780 --> 00:35:12,780
context so on line 49 in line 50 we're

00:35:10,410 --> 00:35:14,850
saying whenever you see an A in my

00:35:12,780 --> 00:35:17,190
marble diagram this is actually all the

00:35:14,850 --> 00:35:19,830
books when you see a B in these marble

00:35:17,190 --> 00:35:21,480
diagrams this is the HTTP response or

00:35:19,830 --> 00:35:23,810
the action that we're outputting this

00:35:21,480 --> 00:35:27,060
gives context to these mock observables

00:35:23,810 --> 00:35:29,460
so the last line in this excuse me last

00:35:27,060 --> 00:35:33,150
line in this test is we're just passing

00:35:29,460 --> 00:35:37,260
in the effect low collection and we're

00:35:33,150 --> 00:35:39,210
using the Jasmine metric jasmine marbles

00:35:37,260 --> 00:35:41,250
function to be observable and we're

00:35:39,210 --> 00:35:44,370
passing in the diagram that we expect

00:35:41,250 --> 00:35:46,320
that observable to output and so this

00:35:44,370 --> 00:35:48,630
lets us make assertions about the

00:35:46,320 --> 00:35:52,520
behavior of the observable using mock

00:35:48,630 --> 00:35:52,520
observables created with jasmine marbles

00:35:56,270 --> 00:36:00,960
like a good live demo we wrote some

00:35:59,160 --> 00:36:02,700
tests previously that are failing that's

00:36:00,960 --> 00:36:07,020
fine but the effects test that we just

00:36:02,700 --> 00:36:10,380
wrote is passing okay so now that we've

00:36:07,020 --> 00:36:11,340
written in effect a test for the books

00:36:10,380 --> 00:36:15,210
page effect

00:36:11,340 --> 00:36:17,370
let's test write a test that shows you

00:36:15,210 --> 00:36:19,290
an effect that doesn't dispatch any new

00:36:17,370 --> 00:36:21,150
actions such as using the router to

00:36:19,290 --> 00:36:22,830
navigate and these are the kinds of

00:36:21,150 --> 00:36:24,180
effects where you've put in the effect

00:36:22,830 --> 00:36:26,460
decorator that this effect doesn't

00:36:24,180 --> 00:36:28,170
actually dispatch anything instead they

00:36:26,460 --> 00:36:30,130
just kind of do some side effect in

00:36:28,170 --> 00:36:32,910
isolation and don't bridge

00:36:30,130 --> 00:36:36,039
turn any actions back out to the system

00:36:32,910 --> 00:36:39,970
so this one is a little more involved

00:36:36,039 --> 00:36:43,749
right because in the office service or

00:36:39,970 --> 00:36:45,009
author fix class we have a lot more

00:36:43,749 --> 00:36:48,519
dependents we have a lot more

00:36:45,009 --> 00:36:51,249
dependencies here at the bottom we have

00:36:48,519 --> 00:36:53,109
actions we have our service we have the

00:36:51,249 --> 00:36:54,609
router in the dialog and I talked about

00:36:53,109 --> 00:36:56,589
this during the authentication talk

00:36:54,609 --> 00:36:58,150
yesterday and this would be really

00:36:56,589 --> 00:36:59,950
painful if we have to set up mock

00:36:58,150 --> 00:37:01,839
objects for every single service that

00:36:59,950 --> 00:37:04,029
this effect requires but thankfully

00:37:01,839 --> 00:37:05,650
using the angular testing library we can

00:37:04,029 --> 00:37:08,859
set up magical mocks for most of those

00:37:05,650 --> 00:37:10,660
services so we set up those tests like

00:37:08,859 --> 00:37:13,499
we did before we mark out the actions

00:37:10,660 --> 00:37:16,749
and then we get an incidence of those

00:37:13,499 --> 00:37:21,759
services during the test so now we can

00:37:16,749 --> 00:37:23,529
talk about a simpler test of verifying

00:37:21,759 --> 00:37:27,069
that the router is called after

00:37:23,529 --> 00:37:28,450
navigation after the user logs in so

00:37:27,069 --> 00:37:30,279
first we're going to create a mock user

00:37:28,450 --> 00:37:31,479
and then we're gonna create the action

00:37:30,279 --> 00:37:34,839
that's going to be the input to this

00:37:31,479 --> 00:37:36,400
effect we're gonna set up the action

00:37:34,839 --> 00:37:38,200
stream again we don't need to use

00:37:36,400 --> 00:37:39,339
Jasmine marbles for this piece because

00:37:38,200 --> 00:37:40,839
there's nothing interesting about the

00:37:39,339 --> 00:37:43,059
behavior we want to assert we can just

00:37:40,839 --> 00:37:46,420
use observable of again to wrap that

00:37:43,059 --> 00:37:48,670
action and an observable so lastly we

00:37:46,420 --> 00:37:51,400
can assert that the router navigate

00:37:48,670 --> 00:37:53,769
function was called only net when the

00:37:51,400 --> 00:37:56,069
login success action came in and it was

00:37:53,769 --> 00:37:58,749
called with the Euro specific URL books

00:37:56,069 --> 00:38:01,089
and we can see what we were doing here

00:37:58,749 --> 00:38:03,569
and how we can assert against that in

00:38:01,089 --> 00:38:05,589
our test

00:38:03,569 --> 00:38:07,869
so the general strategies for writing

00:38:05,589 --> 00:38:09,789
effects tests are is if you have a

00:38:07,869 --> 00:38:11,920
complex effect that has a lot of

00:38:09,789 --> 00:38:13,509
behavior reach for Jasmine marbles to

00:38:11,920 --> 00:38:16,029
describe those behaviors using marble

00:38:13,509 --> 00:38:18,339
diagrams if you have simpler tests that

00:38:16,029 --> 00:38:20,289
are really just input actions behavior

00:38:18,339 --> 00:38:22,390
then output actions don't reach for

00:38:20,289 --> 00:38:28,089
Jasmine marbles use simple or observable

00:38:22,390 --> 00:38:32,160
constructs to write those tests so next

00:38:28,089 --> 00:38:36,369
let's talk about unit testing components

00:38:32,160 --> 00:38:38,650
so ideally we want to keep the component

00:38:36,369 --> 00:38:40,509
tests just as small lightweight and fast

00:38:38,650 --> 00:38:42,369
as the effects reducers and selector

00:38:40,509 --> 00:38:43,840
tests we've written this is actually

00:38:42,369 --> 00:38:46,120
going to mean that we're got to change

00:38:43,840 --> 00:38:47,200
the way we test components and one of

00:38:46,120 --> 00:38:49,300
the things that really slows down a

00:38:47,200 --> 00:38:51,220
component test is actually running the

00:38:49,300 --> 00:38:52,600
just-in-time compiler on all the modules

00:38:51,220 --> 00:38:54,370
that you're going to import into your

00:38:52,600 --> 00:38:56,680
tests so we don't want to try and reduce

00:38:54,370 --> 00:39:00,430
as few dependencies as possible in these

00:38:56,680 --> 00:39:03,880
component tests and to do that we can

00:39:00,430 --> 00:39:06,670
leverage snapshot tests so if we look at

00:39:03,880 --> 00:39:09,010
this small presentation component from a

00:39:06,670 --> 00:39:11,470
testing perspective we only need to

00:39:09,010 --> 00:39:14,320
assert that for a given book it renders

00:39:11,470 --> 00:39:14,920
the same output and that might sound

00:39:14,320 --> 00:39:17,320
familiar

00:39:14,920 --> 00:39:19,150
for a given book this template is always

00:39:17,320 --> 00:39:20,740
going to produce the same results we

00:39:19,150 --> 00:39:23,980
could really say that this is kind of a

00:39:20,740 --> 00:39:27,250
form of component purity so the same

00:39:23,980 --> 00:39:29,290
rules apply for a given set of inputs a

00:39:27,250 --> 00:39:31,090
component will also always render the

00:39:29,290 --> 00:39:32,950
same outlet and what are the ways that

00:39:31,090 --> 00:39:35,560
we can verify that a component always

00:39:32,950 --> 00:39:37,720
renders consistently well we can make

00:39:35,560 --> 00:39:39,220
sure it has no side effects and that

00:39:37,720 --> 00:39:41,590
means making sure that the component

00:39:39,220 --> 00:39:43,690
again it's not modifying or reading from

00:39:41,590 --> 00:39:45,850
a global variable it's not going to

00:39:43,690 --> 00:39:47,830
change any of its inputs it is a bad

00:39:45,850 --> 00:39:50,080
component if it is modifying the inputs

00:39:47,830 --> 00:39:51,430
that it is passed it shouldn't throw an

00:39:50,080 --> 00:39:53,650
error as a result of rendering the

00:39:51,430 --> 00:39:55,570
component and lastly it should not

00:39:53,650 --> 00:39:56,650
render any other components that are

00:39:55,570 --> 00:40:01,120
actually going to have side effects

00:39:56,650 --> 00:40:03,160
within them so if we like take a look at

00:40:01,120 --> 00:40:05,800
this at what a component snapshot test

00:40:03,160 --> 00:40:10,410
would look like let's say we started out

00:40:05,800 --> 00:40:13,750
with me a menu and items elements here

00:40:10,410 --> 00:40:15,490
we would write if we changed the

00:40:13,750 --> 00:40:17,620
contents of that component and

00:40:15,490 --> 00:40:22,170
snapshotted it to include more things

00:40:17,620 --> 00:40:25,150
like burgers and tacos then or pizza

00:40:22,170 --> 00:40:30,580
their very food focus on our team at

00:40:25,150 --> 00:40:32,290
work you could look at what that

00:40:30,580 --> 00:40:34,240
component snapshot would look like and

00:40:32,290 --> 00:40:36,520
we can snapshot many other areas with

00:40:34,240 --> 00:40:38,440
sauce components such as API requests

00:40:36,520 --> 00:40:41,080
and we state that we talked about before

00:40:38,440 --> 00:40:43,030
so let's quickly take a look at writing

00:40:41,080 --> 00:40:46,830
a snapshot test for a component using

00:40:43,030 --> 00:40:46,830
gest and the angular testing library

00:40:48,249 --> 00:40:53,749
so we've got a book preview component

00:40:51,309 --> 00:40:55,279
that we are going to or a rather a book

00:40:53,749 --> 00:40:57,499
authors component that we're gonna write

00:40:55,279 --> 00:41:02,329
a test for and this just prints out all

00:40:57,499 --> 00:41:03,709
the authors for a given book so the

00:41:02,329 --> 00:41:05,029
first thing we need to do is we need to

00:41:03,709 --> 00:41:06,410
create one of these component fixtures

00:41:05,029 --> 00:41:07,819
and what's kind of nice about the

00:41:06,410 --> 00:41:09,920
component fixture is you don't have to

00:41:07,819 --> 00:41:11,630
do it and a before each block you can

00:41:09,920 --> 00:41:16,400
declare the component fixture kind of at

00:41:11,630 --> 00:41:18,199
the top of your test then and it before

00:41:16,400 --> 00:41:20,209
each statement we need to go ahead and

00:41:18,199 --> 00:41:21,920
give the angular compiler time to

00:41:20,209 --> 00:41:24,289
compile all the components and pipes

00:41:21,920 --> 00:41:27,349
that we've declared in this test also

00:41:24,289 --> 00:41:30,410
you can see here that we're passing in a

00:41:27,349 --> 00:41:33,259
book property into this object and the

00:41:30,410 --> 00:41:37,459
book property exists on the book authors

00:41:33,259 --> 00:41:38,660
component on the book authors component

00:41:37,459 --> 00:41:41,479
that we're going to write the snapshot

00:41:38,660 --> 00:41:44,929
test for and that way we can override

00:41:41,479 --> 00:41:47,779
that component before we compile it and

00:41:44,929 --> 00:41:49,640
provide that initial data so we have

00:41:47,779 --> 00:41:52,069
compiled the fixture and now we can

00:41:49,640 --> 00:41:53,390
write a simple test we can just say we

00:41:52,069 --> 00:41:55,219
should make sure that this fixture has

00:41:53,390 --> 00:41:58,279
actually compiled successful Hollow

00:41:55,219 --> 00:41:59,929
snapshots and so again it's yellow he's

00:41:58,279 --> 00:42:01,819
going to run the test and behind the

00:41:59,929 --> 00:42:04,609
background jest is going to write a

00:42:01,819 --> 00:42:06,619
snapshot file for us now we can take a

00:42:04,609 --> 00:42:10,579
look at that snapshot file and see what

00:42:06,619 --> 00:42:13,789
it's rendered so far so now we can see

00:42:10,579 --> 00:42:15,199
that for this one it shows the contents

00:42:13,789 --> 00:42:21,949
of the template and who it was written

00:42:15,199 --> 00:42:24,439
by so in the next test this one's going

00:42:21,949 --> 00:42:26,209
to be a little more involved when we

00:42:24,439 --> 00:42:28,789
walk through that we're generating a

00:42:26,209 --> 00:42:30,859
mock book just as we did before we're

00:42:28,789 --> 00:42:32,539
just modifying the properties of that

00:42:30,859 --> 00:42:35,779
book to include me and like of course

00:42:32,539 --> 00:42:37,219
because this is our talk and then we're

00:42:35,779 --> 00:42:39,019
going to modify the instance of the

00:42:37,219 --> 00:42:40,299
component we're gonna set this book to

00:42:39,019 --> 00:42:42,349
the mock book that we've generated

00:42:40,299 --> 00:42:44,689
finally we're going to tell the fixture

00:42:42,349 --> 00:42:46,939
to run change detection and then we get

00:42:44,689 --> 00:42:49,459
a new snapshot that has captured that

00:42:46,939 --> 00:42:51,319
author information and so this makes it

00:42:49,459 --> 00:42:53,299
much easier to write tests that are

00:42:51,319 --> 00:42:55,369
built this way if you've put component

00:42:53,299 --> 00:42:56,809
purity and bake that into your process

00:42:55,369 --> 00:42:58,849
for writing components you can leverage

00:42:56,809 --> 00:43:02,890
snapshot testing and the angular testing

00:42:58,849 --> 00:43:02,890
library to write tests for them really

00:43:03,619 --> 00:43:07,829
so the last thing we want to show is

00:43:05,670 --> 00:43:09,480
containers we won't show a Tet hour we

00:43:07,829 --> 00:43:10,380
won't show any tests for this one we

00:43:09,480 --> 00:43:13,799
just want to kind of give you an

00:43:10,380 --> 00:43:15,809
overview of the strategies for them now

00:43:13,799 --> 00:43:17,819
a container test or really just though

00:43:15,809 --> 00:43:18,960
aware components and we'll see how this

00:43:17,819 --> 00:43:20,819
is important in a moment

00:43:18,960 --> 00:43:22,140
so all we really need to make sure is

00:43:20,819 --> 00:43:23,819
that they work correctly with the store

00:43:22,140 --> 00:43:25,769
we all see to make sure that they

00:43:23,819 --> 00:43:28,890
dispatch the right actions when handling

00:43:25,769 --> 00:43:31,200
an event so if we take a look at a

00:43:28,890 --> 00:43:33,420
common container component we can see

00:43:31,200 --> 00:43:35,130
that it is going to dispatch some

00:43:33,420 --> 00:43:40,950
actions and it's also going to select

00:43:35,130 --> 00:43:43,650
state out of the store but select and

00:43:40,950 --> 00:43:46,019
dispatch is really just a special

00:43:43,650 --> 00:43:47,640
version of input and output component

00:43:46,019 --> 00:43:49,289
inputs allow parents control how the

00:43:47,640 --> 00:43:51,210
component renders same with selecting

00:43:49,289 --> 00:43:53,549
State and component outputs allow

00:43:51,210 --> 00:43:57,720
parents to listen for events similar to

00:43:53,549 --> 00:43:59,819
dispatching so for this component the

00:43:57,720 --> 00:44:02,609
Select statement is really just a store

00:43:59,819 --> 00:44:04,559
connected input and when it dispatches

00:44:02,609 --> 00:44:07,950
an action it's really just a store

00:44:04,559 --> 00:44:10,680
connected output and as we mentioned

00:44:07,950 --> 00:44:12,150
before testing containers really isn't

00:44:10,680 --> 00:44:14,849
that different from unit testing

00:44:12,150 --> 00:44:16,710
components for a given input that

00:44:14,849 --> 00:44:18,809
component will produce the same output

00:44:16,710 --> 00:44:20,490
in your tests so if you want to see an

00:44:18,809 --> 00:44:22,019
example of a container test today just

00:44:20,490 --> 00:44:24,900
come find Brandon I will be happy to

00:44:22,019 --> 00:44:26,700
walk you through that process so let's

00:44:24,900 --> 00:44:28,259
go ahead and recap some of the things

00:44:26,700 --> 00:44:32,160
that we've learned today about testing a

00:44:28,259 --> 00:44:34,109
reactive application with ng rx testing

00:44:32,160 --> 00:44:37,200
indirect is designed to make testing

00:44:34,109 --> 00:44:39,170
easier and that's because of quality the

00:44:37,200 --> 00:44:41,640
quality that we want to produce

00:44:39,170 --> 00:44:43,619
we also learned how to use some testing

00:44:41,640 --> 00:44:45,359
tools like just jazz or marbles and

00:44:43,619 --> 00:44:46,980
angular testing library to make writing

00:44:45,359 --> 00:44:49,890
tests really fast and to keep them

00:44:46,980 --> 00:44:51,900
running fast we also showed you a few

00:44:49,890 --> 00:44:55,410
strategies for writing unit tests for

00:44:51,900 --> 00:44:56,400
reducers effects and components so

00:44:55,410 --> 00:44:58,230
hopefully this will help you be more

00:44:56,400 --> 00:45:03,200
productive when testing your index

00:44:58,230 --> 00:45:03,200
applications thank you

00:45:07,520 --> 00:45:09,580

YouTube URL: https://www.youtube.com/watch?v=MTZprd9tI6c


