Title: Reducing the Boilerplate with NgRx  - Brandon Roberts & Mike Ryan
Publication date: 2018-11-16
Playlist: ng-conf 2018
Description: 
	ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:03,060
I hope everyone enjoyed all the fun fair

00:00:01,920 --> 00:00:05,640
food for the day

00:00:03,060 --> 00:00:07,859
and we're gonna talk about something

00:00:05,640 --> 00:00:12,420
that gets asked to us all the time and

00:00:07,859 --> 00:00:14,460
that is boiler plate it has been yelled

00:00:12,420 --> 00:00:16,770
across the lands about the biggest

00:00:14,460 --> 00:00:18,690
problem within grx it's the boiler plate

00:00:16,770 --> 00:00:19,980
I have talked to people o people have

00:00:18,690 --> 00:00:22,050
talked to me on Twitter and I have

00:00:19,980 --> 00:00:24,720
blocked them from mentioning boiler

00:00:22,050 --> 00:00:27,150
plate so watch it you say boy plate

00:00:24,720 --> 00:00:28,980
you're getting blocked so here's what

00:00:27,150 --> 00:00:31,500
we're gonna do we're gonna tell you what

00:00:28,980 --> 00:00:33,360
boiler plate actually is then we're

00:00:31,500 --> 00:00:34,890
gonna tell you some steps to reduce the

00:00:33,360 --> 00:00:36,270
real boiler plate in your application

00:00:34,890 --> 00:00:39,059
and I'm gonna show a little bit of the

00:00:36,270 --> 00:00:41,809
future of in directs at the end so

00:00:39,059 --> 00:00:45,030
you've seen this slide today already and

00:00:41,809 --> 00:00:47,370
I want to go over it again clarity over

00:00:45,030 --> 00:00:50,879
brevity this is the driving force for in

00:00:47,370 --> 00:00:52,800
directs spend time upfront by being very

00:00:50,879 --> 00:00:54,510
explicit about how state changes in your

00:00:52,800 --> 00:00:57,239
application and how side effects start

00:00:54,510 --> 00:00:58,199
if you do this our assertion is that

00:00:57,239 --> 00:01:04,019
this will help you write more

00:00:58,199 --> 00:01:06,390
maintainable programs also Gerak's is an

00:01:04,019 --> 00:01:08,549
architecture interrex is all about

00:01:06,390 --> 00:01:11,100
giving you tools to write explicit

00:01:08,549 --> 00:01:12,900
applications that are easy to trace we

00:01:11,100 --> 00:01:15,659
want to avoid abstractions that

00:01:12,900 --> 00:01:17,939
introduce implicitness so Brandon does

00:01:15,659 --> 00:01:19,770
this mean if I use ng rx my application

00:01:17,939 --> 00:01:25,259
become easier to reason about and I will

00:01:19,770 --> 00:01:27,540
win of course no not really introducing

00:01:25,259 --> 00:01:30,740
injury X into app does not automatically

00:01:27,540 --> 00:01:35,759
make it easier to reason about in quotes

00:01:30,740 --> 00:01:37,799
note that we want developers to reduce

00:01:35,759 --> 00:01:40,770
the boilerplate without writing

00:01:37,799 --> 00:01:42,119
abstractions that are going to remove as

00:01:40,770 --> 00:01:44,729
some of the benefits that index gives

00:01:42,119 --> 00:01:47,009
you so where does this boilerplate come

00:01:44,729 --> 00:01:48,570
from why is this explicitness important

00:01:47,009 --> 00:01:51,600
well to do that we kind of have to take

00:01:48,570 --> 00:01:52,770
a 10,000 foot view at this ng rx thing

00:01:51,600 --> 00:01:54,509
one more time and I'm sure you've seen

00:01:52,770 --> 00:01:55,640
this diagram a couple of times but it's

00:01:54,509 --> 00:01:59,130
worth mentioning again

00:01:55,640 --> 00:02:02,009
so of course Thor follows the Redux

00:01:59,130 --> 00:02:04,320
pattern components normalized UI events

00:02:02,009 --> 00:02:06,270
into actions that represent a logical

00:02:04,320 --> 00:02:07,979
change of states when an action is

00:02:06,270 --> 00:02:10,530
dispatched a special reducer function

00:02:07,979 --> 00:02:12,390
gets set aside how state transitions as

00:02:10,530 --> 00:02:15,850
a result of that action

00:02:12,390 --> 00:02:18,910
State is also the deliver two components

00:02:15,850 --> 00:02:21,160
do an observable observable and

00:02:18,910 --> 00:02:22,960
operators and this allows you to write

00:02:21,160 --> 00:02:25,900
state changes in a way that is immutable

00:02:22,960 --> 00:02:28,240
and pushes data to your UI with an

00:02:25,900 --> 00:02:30,390
observable what benefits is this you'll

00:02:28,240 --> 00:02:33,760
deal well the first is serializability

00:02:30,390 --> 00:02:36,160
and that allows you to inspect download

00:02:33,760 --> 00:02:39,160
upload and dispatch all these actions

00:02:36,160 --> 00:02:41,350
that come that in time travel and with

00:02:39,160 --> 00:02:43,030
its integrated with the dev tools it

00:02:41,350 --> 00:02:45,600
allows you to transmit actions over a

00:02:43,030 --> 00:02:49,120
WebSocket connection or to a web worker

00:02:45,600 --> 00:02:51,130
you can also save your state to local

00:02:49,120 --> 00:02:52,270
storage or any external browser storage

00:02:51,130 --> 00:02:54,190
whether you're doing this on a mobile

00:02:52,270 --> 00:02:56,770
device or where they doing server-side

00:02:54,190 --> 00:02:58,930
rendering it also gives you a mute

00:02:56,770 --> 00:03:00,940
ability this lets you turn on on push

00:02:58,930 --> 00:03:02,620
change detection in a large majority of

00:03:00,940 --> 00:03:04,510
your application giving you a tremendous

00:03:02,620 --> 00:03:06,640
performance boost so that change

00:03:04,510 --> 00:03:09,310
detection only really happens when your

00:03:06,640 --> 00:03:12,550
state's updated so you can get a

00:03:09,310 --> 00:03:14,350
guarantee that the responsibility of

00:03:12,550 --> 00:03:17,440
where those state changes happen is in

00:03:14,350 --> 00:03:20,920
your reducers it's also all about type

00:03:17,440 --> 00:03:22,209
safety we write so much of ng rx the way

00:03:20,920 --> 00:03:23,980
we've written it so that your

00:03:22,209 --> 00:03:26,830
applications that you write will be as

00:03:23,980 --> 00:03:29,530
type safe as possible actions are

00:03:26,830 --> 00:03:31,650
written this way so that you can share

00:03:29,530 --> 00:03:33,370
these action type constraints and

00:03:31,650 --> 00:03:36,070
interfaces across your application

00:03:33,370 --> 00:03:37,840
without breaking lazy loading we write

00:03:36,070 --> 00:03:40,269
reducers the way they are written so the

00:03:37,840 --> 00:03:41,769
typescript compiler can infer the shape

00:03:40,269 --> 00:03:44,560
of actions that into your case

00:03:41,769 --> 00:03:47,739
statements selector functions which are

00:03:44,560 --> 00:03:50,440
pure select pieces of state and allow

00:03:47,739 --> 00:03:52,840
that type safety to flow from your state

00:03:50,440 --> 00:03:54,610
to your components it's also gonna let

00:03:52,840 --> 00:03:56,140
you leverage type inference where

00:03:54,610 --> 00:03:57,790
possible this means we're trying to do

00:03:56,140 --> 00:03:59,709
as much as possible so the typescript

00:03:57,790 --> 00:04:01,480
compiler can understand your program

00:03:59,709 --> 00:04:03,489
whether you haven't right to have type

00:04:01,480 --> 00:04:04,930
annotations everywhere because we want

00:04:03,489 --> 00:04:08,019
you to be able to verify the correctness

00:04:04,930 --> 00:04:10,060
of your program another benefit is that

00:04:08,019 --> 00:04:12,220
it's gonna make testing less painful and

00:04:10,060 --> 00:04:14,620
if you watched our talked earlier about

00:04:12,220 --> 00:04:17,590
testing within grx you'll notice we use

00:04:14,620 --> 00:04:19,450
a lot of functions selectors action

00:04:17,590 --> 00:04:21,430
factories and reducers are all pure

00:04:19,450 --> 00:04:23,229
functions this allows you to avoid

00:04:21,430 --> 00:04:25,630
dependency injection in a majority of an

00:04:23,229 --> 00:04:26,170
indirect application we push developers

00:04:25,630 --> 00:04:27,370
to keep

00:04:26,170 --> 00:04:30,190
side effects where they belong and

00:04:27,370 --> 00:04:31,660
isolated in grx effects so that testing

00:04:30,190 --> 00:04:34,660
the rest of your application is

00:04:31,660 --> 00:04:36,730
straightforward and yet despite all

00:04:34,660 --> 00:04:47,430
these great guarantees and benefits that

00:04:36,730 --> 00:04:49,990
we give you you still say to us okay so

00:04:47,430 --> 00:04:53,290
what are our goals for reducing the

00:04:49,990 --> 00:04:55,600
boilerplate then well we don't want to

00:04:53,290 --> 00:04:56,890
ruin what makes in grx also we don't

00:04:55,600 --> 00:04:59,470
want to make your application less

00:04:56,890 --> 00:05:01,390
serializable less typesafe we don't want

00:04:59,470 --> 00:05:03,820
to make it harder to test these are the

00:05:01,390 --> 00:05:07,720
cornerstones of ng Rx and so we don't

00:05:03,820 --> 00:05:10,300
want to ruin what makes ng x awesome we

00:05:07,720 --> 00:05:13,120
don't want to introduce magic and as we

00:05:10,300 --> 00:05:15,130
mentioned before this is implicitness it

00:05:13,120 --> 00:05:17,080
makes it makes it harder to debug or

00:05:15,130 --> 00:05:18,730
application in the long run because you

00:05:17,080 --> 00:05:22,840
don't just ship and leave it alone

00:05:18,730 --> 00:05:25,090
forever and most importantly we want to

00:05:22,840 --> 00:05:26,950
give you the developers the flexibility

00:05:25,090 --> 00:05:28,660
to build on top of n directs to suit

00:05:26,950 --> 00:05:30,880
your needs if you want to introduce

00:05:28,660 --> 00:05:32,620
conventions into your application that

00:05:30,880 --> 00:05:34,420
might hide some of this complexity for

00:05:32,620 --> 00:05:38,020
you you have really good building blocks

00:05:34,420 --> 00:05:40,450
to do so and so before we get into this

00:05:38,020 --> 00:05:42,280
boilerplate problem I love pulling out

00:05:40,450 --> 00:05:44,050
this quote because it just hits the nail

00:05:42,280 --> 00:05:46,810
on them what I have to block you know

00:05:44,050 --> 00:05:48,820
okay Redux is not great for making

00:05:46,810 --> 00:05:51,190
simple things quickly it's great for

00:05:48,820 --> 00:05:52,900
making really hard things simple there

00:05:51,190 --> 00:05:54,640
is a cost in Jurek's you're not gonna be

00:05:52,900 --> 00:05:56,860
able to move as fast with it but it's

00:05:54,640 --> 00:06:00,610
gonna make your really hard problems so

00:05:56,860 --> 00:06:02,380
much easier to solve within grx all

00:06:00,610 --> 00:06:04,900
right let's do it

00:06:02,380 --> 00:06:07,390
let's solve the boilerplate problem but

00:06:04,900 --> 00:06:10,690
first what is boilerplate

00:06:07,390 --> 00:06:12,160
well when you build a feature there are

00:06:10,690 --> 00:06:13,720
a few things that you're going to need

00:06:12,160 --> 00:06:16,060
at a minimum you're going to need

00:06:13,720 --> 00:06:18,250
actions to describe events reducers to

00:06:16,060 --> 00:06:20,920
manage state changes and selectors to

00:06:18,250 --> 00:06:23,430
retrieve pieces of state but boilerplate

00:06:20,920 --> 00:06:26,380
has a very important definition

00:06:23,430 --> 00:06:28,450
boilerplate is any code that you have to

00:06:26,380 --> 00:06:31,930
repeat throughout your code base with

00:06:28,450 --> 00:06:35,290
little to no alteration and so I'm

00:06:31,930 --> 00:06:37,810
really sorry to report oh that actions

00:06:35,290 --> 00:06:37,820
and reducers are not boilerplate

00:06:37,810 --> 00:06:39,430
[Music]

00:06:37,820 --> 00:06:44,000
[Applause]

00:06:39,430 --> 00:06:45,590
they get it in the back that guy so why

00:06:44,000 --> 00:06:46,670
is this Brennan why are these not

00:06:45,590 --> 00:06:51,050
boilerplate

00:06:46,670 --> 00:06:53,060
so actions describe unique events that

00:06:51,050 --> 00:06:54,380
happen throughout your application this

00:06:53,060 --> 00:06:56,630
means this is not code that you're

00:06:54,380 --> 00:06:58,970
repeating with no alteration these are

00:06:56,630 --> 00:07:02,750
all unique pieces of code there's just a

00:06:58,970 --> 00:07:04,730
lot of them reducers are where the

00:07:02,750 --> 00:07:07,010
business block business logic happens

00:07:04,730 --> 00:07:09,440
for your state updates and handle those

00:07:07,010 --> 00:07:12,020
unique actions that I just mentioned and

00:07:09,440 --> 00:07:13,490
so these building blocks we get it they

00:07:12,020 --> 00:07:15,290
take a lot of time to write and there's

00:07:13,490 --> 00:07:17,630
a lot of them but this isn't boilerplate

00:07:15,290 --> 00:07:19,700
that's just explicitness and it's that

00:07:17,630 --> 00:07:21,290
explicitness that enables a mutability

00:07:19,700 --> 00:07:23,000
type safety serialize ability and

00:07:21,290 --> 00:07:25,910
testability we're gonna keep saying

00:07:23,000 --> 00:07:27,290
those words throughout this talk so then

00:07:25,910 --> 00:07:30,580
what is the boilerplate that we could

00:07:27,290 --> 00:07:33,320
actually reduce actual boilerplate yes

00:07:30,580 --> 00:07:36,100
actual boilerplate is things like

00:07:33,320 --> 00:07:39,050
connecting their reducers to the store

00:07:36,100 --> 00:07:40,880
also registering the fix whether you're

00:07:39,050 --> 00:07:42,950
doing this at the root or you're doing

00:07:40,880 --> 00:07:44,780
it registering the effects lazily you're

00:07:42,950 --> 00:07:47,840
still doing the same thing over and over

00:07:44,780 --> 00:07:50,450
with just very minimal changes right so

00:07:47,840 --> 00:07:53,000
that's as real boilerplate it's also

00:07:50,450 --> 00:07:55,010
handling common state shapes handling

00:07:53,000 --> 00:07:57,560
collections of entities for example is

00:07:55,010 --> 00:08:00,530
got some very common patterns throughout

00:07:57,560 --> 00:08:02,780
it so what are some strategies for

00:08:00,530 --> 00:08:05,480
reducing all of this boilerplate that is

00:08:02,780 --> 00:08:08,660
in an energy arts application yeah we're

00:08:05,480 --> 00:08:10,460
gonna cover these strategies and we're

00:08:08,660 --> 00:08:12,800
going to cover making the right

00:08:10,460 --> 00:08:15,470
decisions about what goes in the store

00:08:12,800 --> 00:08:17,270
and what doesn't we're also going to

00:08:15,470 --> 00:08:18,140
talk about indirect schematics what

00:08:17,270 --> 00:08:20,060
you're going to hear about throughout

00:08:18,140 --> 00:08:21,770
the day and that allows you to automate

00:08:20,060 --> 00:08:23,720
some of those common boilerplate tasks

00:08:21,770 --> 00:08:25,700
that help you generate some of the

00:08:23,720 --> 00:08:29,060
required infrastructure for braiding an

00:08:25,700 --> 00:08:30,440
Ender X application with using common

00:08:29,060 --> 00:08:33,020
state shapes we're going to talk about

00:08:30,440 --> 00:08:35,240
using inter arch entity to manage

00:08:33,020 --> 00:08:37,610
collections and one thing are really

00:08:35,240 --> 00:08:39,170
excited about is to talk about the

00:08:37,610 --> 00:08:42,590
future and what's going to happen in

00:08:39,170 --> 00:08:44,930
future versions of engineering's so

00:08:42,590 --> 00:08:47,390
first the easiest way to reduce the

00:08:44,930 --> 00:08:49,850
boilerplate is to write less code and

00:08:47,390 --> 00:08:52,400
you can write less code by putting fewer

00:08:49,850 --> 00:08:54,290
things in the store so let's talk about

00:08:52,400 --> 00:08:58,820
things that belong in your store and

00:08:54,290 --> 00:09:01,100
what doesn't to do this we have a simple

00:08:58,820 --> 00:09:02,870
mnemonic called sherry you can follow

00:09:01,100 --> 00:09:06,740
the sherry principle to determine what

00:09:02,870 --> 00:09:10,010
state does belong in your store so if we

00:09:06,740 --> 00:09:14,300
go through the first first one in the

00:09:10,010 --> 00:09:16,190
sherry principle it is shared State so

00:09:14,300 --> 00:09:18,470
shared state is accessed by any

00:09:16,190 --> 00:09:20,150
components or services this means that

00:09:18,470 --> 00:09:23,540
it's state that is not just consumed by

00:09:20,150 --> 00:09:25,640
one consumer if you saw my

00:09:23,540 --> 00:09:28,279
authentication talk yesterday I hinted

00:09:25,640 --> 00:09:31,130
at this that authentication is a great

00:09:28,279 --> 00:09:34,220
example of shared state because the

00:09:31,130 --> 00:09:36,290
share that state is you need to share

00:09:34,220 --> 00:09:38,870
throughout your application and it gets

00:09:36,290 --> 00:09:41,000
changed from different places and many

00:09:38,870 --> 00:09:43,310
pages and services need to access it

00:09:41,000 --> 00:09:45,740
the second principle of sherry is state

00:09:43,310 --> 00:09:47,360
that is hydrated this is state that

00:09:45,740 --> 00:09:48,980
needs to be persisted and hydrated

00:09:47,360 --> 00:09:50,660
either in local storage or sessom

00:09:48,980 --> 00:09:52,640
storage as in you need it to be

00:09:50,660 --> 00:09:56,150
available to your application the next

00:09:52,640 --> 00:09:57,500
time it boots up user preferences is a

00:09:56,150 --> 00:10:00,200
good example of this

00:09:57,500 --> 00:10:03,980
they need to be persisted and hydrated

00:10:00,200 --> 00:10:05,570
across page reloads and navigation that

00:10:03,980 --> 00:10:08,120
way when you're not starts back up user

00:10:05,570 --> 00:10:11,630
preferences can be restored or hydrated

00:10:08,120 --> 00:10:13,400
from your session storage strategy the

00:10:11,630 --> 00:10:15,500
third principle of sherry is state that

00:10:13,400 --> 00:10:18,620
needs to be available when re-entering

00:10:15,500 --> 00:10:20,870
routes so this state of course when

00:10:18,620 --> 00:10:23,450
you're navigating around you don't want

00:10:20,870 --> 00:10:26,270
to have to go and reach back or to hit

00:10:23,450 --> 00:10:28,730
external API as to reload that data and

00:10:26,270 --> 00:10:31,040
so that data is always there available

00:10:28,730 --> 00:10:32,570
ready to consume for instance if the

00:10:31,040 --> 00:10:33,860
user starts going through a workflow on

00:10:32,570 --> 00:10:35,990
a page like a wizard

00:10:33,860 --> 00:10:38,029
then leaves the page it might be useful

00:10:35,990 --> 00:10:39,470
to keep that state in the store so that

00:10:38,029 --> 00:10:42,640
when they come back to that page it's

00:10:39,470 --> 00:10:42,640
still available to those components

00:10:43,390 --> 00:10:48,890
their state that needs to be retrieved

00:10:45,680 --> 00:10:52,130
with a side effect and this is where you

00:10:48,890 --> 00:10:55,100
interact do external API to get that

00:10:52,130 --> 00:10:56,870
data and this is data that keeps those

00:10:55,100 --> 00:10:59,209
interactions separate from your

00:10:56,870 --> 00:11:01,880
components and that state that you have

00:10:59,209 --> 00:11:03,770
there for example if the user can

00:11:01,880 --> 00:11:05,329
initiate a search on a collection and

00:11:03,770 --> 00:11:07,670
that search needs to happen with a

00:11:05,329 --> 00:11:09,319
rest api request then it makes sense to

00:11:07,670 --> 00:11:10,999
build the search feature with the in GX

00:11:09,319 --> 00:11:13,220
architecture because it's gonna enable

00:11:10,999 --> 00:11:14,839
you to isolate that side effect and

00:11:13,220 --> 00:11:18,069
leverage the store to keep your

00:11:14,839 --> 00:11:21,049
components and your components pure

00:11:18,069 --> 00:11:24,290
finally state that is impacted by others

00:11:21,049 --> 00:11:26,809
actions or sources put state in the

00:11:24,290 --> 00:11:31,040
store that has changed from other

00:11:26,809 --> 00:11:32,929
components or services so as you're

00:11:31,040 --> 00:11:35,170
building an index application always

00:11:32,929 --> 00:11:37,100
think of Shari state that is shared

00:11:35,170 --> 00:11:39,709
hydrated that needs to be made available

00:11:37,100 --> 00:11:41,629
or is retrieved from a side effect and

00:11:39,709 --> 00:11:44,749
lastly a state that is impacted from

00:11:41,629 --> 00:11:48,319
other sources so what doesn't belong in

00:11:44,749 --> 00:11:50,299
the store then forms that's right I know

00:11:48,319 --> 00:11:51,920
the talk we're following up gave you

00:11:50,299 --> 00:11:53,720
another perspective and it's kind of a

00:11:51,920 --> 00:11:56,329
controversial thing some developers want

00:11:53,720 --> 00:11:57,799
to do it others don't but we kind of

00:11:56,329 --> 00:12:00,529
feel that you shouldn't keep form state

00:11:57,799 --> 00:12:02,899
because it's also non serializable and

00:12:00,529 --> 00:12:07,100
any state that's non serializable pryzen

00:12:02,899 --> 00:12:09,919
belong in the store so forms don't

00:12:07,100 --> 00:12:13,220
belong in a store why is that because

00:12:09,919 --> 00:12:15,499
forms are full of stateful information

00:12:13,220 --> 00:12:18,110
that's usually self contained in the

00:12:15,499 --> 00:12:20,179
local context the angular form controls

00:12:18,110 --> 00:12:21,649
aren't serializable or immutable they're

00:12:20,179 --> 00:12:23,269
going to change themselves and you

00:12:21,649 --> 00:12:26,029
aren't going to track that with actions

00:12:23,269 --> 00:12:28,699
and in a way the reactive forms module

00:12:26,029 --> 00:12:30,949
is kind of its own state management

00:12:28,699 --> 00:12:33,709
library in itself made specifically for

00:12:30,949 --> 00:12:35,749
forms it handles all of the common form

00:12:33,709 --> 00:12:38,569
state for any control like touched and

00:12:35,749 --> 00:12:40,249
value and validity it also connects side

00:12:38,569 --> 00:12:42,589
effects of changes and controls with

00:12:40,249 --> 00:12:43,910
async validators it gives you events to

00:12:42,589 --> 00:12:47,959
hook into that are relevant to the

00:12:43,910 --> 00:12:50,239
content of building forms these are

00:12:47,959 --> 00:12:53,059
strategies for connecting state to the

00:12:50,239 --> 00:12:55,519
store their strategies for connecting

00:12:53,059 --> 00:12:57,470
state to the store two forms that are

00:12:55,519 --> 00:13:01,489
more compelling than doing this within

00:12:57,470 --> 00:13:03,439
your ex we also want to keep unsee

00:13:01,489 --> 00:13:05,329
realisable state out of the store this

00:13:03,439 --> 00:13:07,160
is any state that has cycles in it or

00:13:05,329 --> 00:13:09,079
has an instance of complex data

00:13:07,160 --> 00:13:11,600
structures those don't belong in the

00:13:09,079 --> 00:13:13,100
store we can't serialize those and so we

00:13:11,600 --> 00:13:16,160
can't leverage serialize ability in our

00:13:13,100 --> 00:13:17,930
application and since serializability is

00:13:16,160 --> 00:13:20,360
a big cornerstone

00:13:17,930 --> 00:13:23,690
how you build an indirect SAP we don't

00:13:20,360 --> 00:13:25,520
want to include we want to make I want

00:13:23,690 --> 00:13:27,080
you to follow these rules so that it

00:13:25,520 --> 00:13:29,270
helps you with debugging and state

00:13:27,080 --> 00:13:31,279
hydration this means we can't use some

00:13:29,270 --> 00:13:33,710
utility data structures like maps or

00:13:31,279 --> 00:13:35,060
sets they're not serializable and so we

00:13:33,710 --> 00:13:38,690
shouldn't use them on our reducer

00:13:35,060 --> 00:13:41,930
functions one quick one quick note

00:13:38,690 --> 00:13:43,820
because we've seen this a lot the router

00:13:41,930 --> 00:13:46,700
state is a good example of this because

00:13:43,820 --> 00:13:49,220
the router state is complex it has

00:13:46,700 --> 00:13:50,990
cycles and these are things that you

00:13:49,220 --> 00:13:53,690
don't necessarily need that full picture

00:13:50,990 --> 00:13:55,760
of so something like that would be a

00:13:53,690 --> 00:13:57,440
good example of things that you wouldn't

00:13:55,760 --> 00:14:00,070
keep in a store or that you would pare

00:13:57,440 --> 00:14:02,779
down if you needed to access that data

00:14:00,070 --> 00:14:05,029
lastly keep any state that is solely

00:14:02,779 --> 00:14:07,010
owned by a component out of the store

00:14:05,029 --> 00:14:08,720
you do not need to put all of your

00:14:07,010 --> 00:14:11,589
application state in the store only

00:14:08,720 --> 00:14:14,720
state that follows the cheri principle

00:14:11,589 --> 00:14:17,540
it's okay to have component with this

00:14:14,720 --> 00:14:21,290
local state that gets cleaned up because

00:14:17,540 --> 00:14:23,570
as we've seen people that using jerks

00:14:21,290 --> 00:14:25,490
want to tend to put everything there and

00:14:23,570 --> 00:14:27,380
by following these principles you'll be

00:14:25,490 --> 00:14:30,320
able to make better decisions about what

00:14:27,380 --> 00:14:32,540
goes in there the second strategy

00:14:30,320 --> 00:14:33,890
producing the boilerplate is schematics

00:14:32,540 --> 00:14:38,810
and I'm gonna let Brandon walk us

00:14:33,890 --> 00:14:41,150
through this one so schematics is a

00:14:38,810 --> 00:14:43,400
scaffolding library for any direction of

00:14:41,150 --> 00:14:46,040
course if you're unfamiliar with it it

00:14:43,400 --> 00:14:47,870
provides automation for these repetitive

00:14:46,040 --> 00:14:51,290
tasks like we mentioned that aren't

00:14:47,870 --> 00:14:52,880
unique in addition to generating a lot

00:14:51,290 --> 00:14:55,400
of the things that you do use with the

00:14:52,880 --> 00:14:57,920
injects including actions reducers and

00:14:55,400 --> 00:15:02,810
effects when you're building out your

00:14:57,920 --> 00:15:04,970
app indirect schematics works with the

00:15:02,810 --> 00:15:07,490
CLI so there's already that integration

00:15:04,970 --> 00:15:09,890
there when you want to handle what is

00:15:07,490 --> 00:15:13,279
actual boilerplate as we talked about

00:15:09,890 --> 00:15:15,620
earlier and this is done with this

00:15:13,279 --> 00:15:19,040
integration that uses code and templates

00:15:15,620 --> 00:15:21,079
to generate files and if you talk if you

00:15:19,040 --> 00:15:22,970
saw this talked earlier about angel

00:15:21,079 --> 00:15:25,790
schematics then you may be a little

00:15:22,970 --> 00:15:27,740
familiar with how that works Brandon can

00:15:25,790 --> 00:15:29,329
I use inject schematics with the default

00:15:27,740 --> 00:15:31,010
schematics that are you that are

00:15:29,329 --> 00:15:34,100
available in angular CLI

00:15:31,010 --> 00:15:37,220
yes you can you can sit your in Jurek

00:15:34,100 --> 00:15:40,730
schematics to be the default so that you

00:15:37,220 --> 00:15:43,100
don't have to specify specific specific

00:15:40,730 --> 00:15:46,460
collections when general when using the

00:15:43,100 --> 00:15:48,080
CLI which are out and this was covered a

00:15:46,460 --> 00:15:50,720
little bit in the previous talk about

00:15:48,080 --> 00:15:55,940
NGO schematics but it is one thing that

00:15:50,720 --> 00:15:57,850
needs to be mentioned so the things that

00:15:55,940 --> 00:16:00,050
if you're starting to integrate

00:15:57,850 --> 00:16:02,780
indirects into your project

00:16:00,050 --> 00:16:05,570
we provide helpers with that to generate

00:16:02,780 --> 00:16:06,950
a new store or if you're already using

00:16:05,570 --> 00:16:08,540
in Jurek's

00:16:06,950 --> 00:16:11,350
as I mentioned there are these core

00:16:08,540 --> 00:16:14,060
principles that you need to generate and

00:16:11,350 --> 00:16:15,530
this helps you get along quickly with

00:16:14,060 --> 00:16:18,680
what you need to do and not have to

00:16:15,530 --> 00:16:20,600
focus on those things and as we

00:16:18,680 --> 00:16:24,020
mentioned those things are actions to

00:16:20,600 --> 00:16:27,740
describe events reducers to handle those

00:16:24,020 --> 00:16:33,590
state changes and effects for handling

00:16:27,740 --> 00:16:35,840
side effects so if you're already using

00:16:33,590 --> 00:16:38,440
that then there are a few things you can

00:16:35,840 --> 00:16:42,050
take advantage of that we'll also cover

00:16:38,440 --> 00:16:44,960
in a little bit the first one being

00:16:42,050 --> 00:16:48,800
entity this is where you generate a

00:16:44,960 --> 00:16:52,460
collection to handle common shapes that

00:16:48,800 --> 00:16:54,650
we talked about the biggest one is a

00:16:52,460 --> 00:16:58,550
feature and that is where you can

00:16:54,650 --> 00:17:01,400
generate an action or reducer and an

00:16:58,550 --> 00:17:03,920
effect and being integrated with the CLI

00:17:01,400 --> 00:17:06,500
you can wire these up to your modules

00:17:03,920 --> 00:17:09,140
and not have to worry about how all the

00:17:06,500 --> 00:17:14,890
machinery works and let you get going in

00:17:09,140 --> 00:17:17,630
that case there's also a container

00:17:14,890 --> 00:17:20,660
blueprint and as we've mentioned

00:17:17,630 --> 00:17:23,780
throughout the talks today container is

00:17:20,660 --> 00:17:25,510
basically just a pre-wired component

00:17:23,780 --> 00:17:27,560
that has store already injected to it

00:17:25,510 --> 00:17:28,760
this because these are where your some

00:17:27,560 --> 00:17:33,250
more components are going to be as

00:17:28,760 --> 00:17:33,250
opposed to your presentation components

00:17:33,550 --> 00:17:40,850
so with that being said how does this

00:17:37,430 --> 00:17:43,250
help you with the boilerplate we

00:17:40,850 --> 00:17:44,660
register feature States those are things

00:17:43,250 --> 00:17:46,880
that are going to be the same

00:17:44,660 --> 00:17:50,120
and are not unique whether you're doing

00:17:46,880 --> 00:17:53,270
them it's up front or when you're adding

00:17:50,120 --> 00:17:57,530
new functionality we help you are

00:17:53,270 --> 00:18:02,540
effects which like said handle side

00:17:57,530 --> 00:18:05,600
effects and we have integration with ng

00:18:02,540 --> 00:18:08,060
modules schematics helps you handle this

00:18:05,600 --> 00:18:09,890
area that is boilerplate so you can help

00:18:08,060 --> 00:18:21,020
build your app more efficiently all

00:18:09,890 --> 00:18:22,070
right show me how it works done so I

00:18:21,020 --> 00:18:23,480
have a question for you Brandon why

00:18:22,070 --> 00:18:25,370
you're getting this set up is this gonna

00:18:23,480 --> 00:18:27,080
follow the best practices or is it more

00:18:25,370 --> 00:18:30,200
like the example app in time helps you

00:18:27,080 --> 00:18:32,210
learn this is going the schematics

00:18:30,200 --> 00:18:33,800
follow well it does a little bit of both

00:18:32,210 --> 00:18:36,620
schematics follow the best practices

00:18:33,800 --> 00:18:38,000
that we implement that you should use as

00:18:36,620 --> 00:18:40,040
far as the structure that you should

00:18:38,000 --> 00:18:42,700
have and also it gives you those

00:18:40,040 --> 00:18:49,460
conveniences of how you go about

00:18:42,700 --> 00:18:52,010
generating that information so here I've

00:18:49,460 --> 00:18:54,500
Li now created a project called index

00:18:52,010 --> 00:18:55,030
boilerplate of course because y'all love

00:18:54,500 --> 00:18:58,820
it

00:18:55,030 --> 00:19:01,100
and here I'm just going to show a few

00:18:58,820 --> 00:19:01,520
things I'm going to show starting from

00:19:01,100 --> 00:19:04,000
scratch

00:19:01,520 --> 00:19:09,680
how quickly I could get up.get

00:19:04,000 --> 00:19:13,010
integrated within Durex in my app so if

00:19:09,680 --> 00:19:15,710
I use the ng generate function and

00:19:13,010 --> 00:19:17,570
generate a store and give it a thing

00:19:15,710 --> 00:19:19,940
give it a name and tell it where it's

00:19:17,570 --> 00:19:22,340
going to be registered you can see that

00:19:19,940 --> 00:19:25,070
it's created set up my initial reducers

00:19:22,340 --> 00:19:30,100
for me and also register that within the

00:19:25,070 --> 00:19:32,870
app module so these are things that I

00:19:30,100 --> 00:19:35,360
want got started with with indirection I

00:19:32,870 --> 00:19:37,640
didn't have to worry about I said on my

00:19:35,360 --> 00:19:43,810
reducers integrates with the dev tools

00:19:37,640 --> 00:19:46,880
and register those imports automatically

00:19:43,810 --> 00:19:49,220
if we take a quick look inside the

00:19:46,880 --> 00:19:51,740
reducer function or reduce a file sorry

00:19:49,220 --> 00:19:54,470
we have our interface that defines our

00:19:51,740 --> 00:19:59,890
state's our action reducers and meta

00:19:54,470 --> 00:19:59,890
reducers that operate on the store also

00:20:00,100 --> 00:20:06,620
so that's a one example of using

00:20:04,149 --> 00:20:10,490
schematics to get started quickly within

00:20:06,620 --> 00:20:14,539
your ex next I'll generate a feature

00:20:10,490 --> 00:20:16,159
that helps you to move along if your

00:20:14,539 --> 00:20:19,100
ability if you're already using injects

00:20:16,159 --> 00:20:26,240
and generate an action reducer and

00:20:19,100 --> 00:20:28,940
effect so I use the ng generate feature

00:20:26,240 --> 00:20:30,590
and I'm going to call this one users and

00:20:28,940 --> 00:20:32,899
we'll talk a little bit further about

00:20:30,590 --> 00:20:36,110
how entity plays into this picture

00:20:32,899 --> 00:20:38,659
so I'm generating the files that I need

00:20:36,110 --> 00:20:42,860
actions reducer in effects and already

00:20:38,659 --> 00:20:45,039
wired it up to my reducers file so if we

00:20:42,860 --> 00:20:49,129
look in here I have a users property and

00:20:45,039 --> 00:20:52,009
it's already wired up to my reducer and

00:20:49,129 --> 00:20:55,639
if I look in the users folder I have

00:20:52,009 --> 00:20:58,970
actions and we have we've already set up

00:20:55,639 --> 00:21:02,149
the best practices that we have to give

00:20:58,970 --> 00:21:04,700
to you about how you use in your ex and

00:21:02,149 --> 00:21:06,710
how you define actions hey Brandon that

00:21:04,700 --> 00:21:12,320
action type doesn't follow good action

00:21:06,710 --> 00:21:14,179
hi Jean can you change that that's a

00:21:12,320 --> 00:21:17,419
good catch Mike and you're gonna fix

00:21:14,179 --> 00:21:19,879
that right yes but it's just to give you

00:21:17,419 --> 00:21:22,370
an example of how you can get going

00:21:19,879 --> 00:21:24,529
quickly and how you can make these

00:21:22,370 --> 00:21:27,639
actions more specific so that you can

00:21:24,529 --> 00:21:29,840
follow good action hi Jean

00:21:27,639 --> 00:21:31,220
the important part is that it just

00:21:29,840 --> 00:21:33,169
cathodes this out and connects it for

00:21:31,220 --> 00:21:35,179
you you're still responsible for writing

00:21:33,169 --> 00:21:37,909
the injects application and following or

00:21:35,179 --> 00:21:39,500
building out the rest of the logic if we

00:21:37,909 --> 00:21:42,230
look at a fix we can see that I've

00:21:39,500 --> 00:21:45,289
already predefined the user actions to

00:21:42,230 --> 00:21:49,009
help you get going with loading new data

00:21:45,289 --> 00:21:52,220
or building out a new feature lastly we

00:21:49,009 --> 00:21:53,779
have the reducer that's generated that

00:21:52,220 --> 00:21:57,250
has the switch statement that people

00:21:53,779 --> 00:21:57,250
love especially me

00:21:57,740 --> 00:22:02,960
to get going quickly and use and be able

00:22:01,549 --> 00:22:05,330
to build out that those state

00:22:02,960 --> 00:22:07,399
transitions and Mike is gonna cover is

00:22:05,330 --> 00:22:09,379
going to take a good deep dive into

00:22:07,399 --> 00:22:12,070
reducer functions when he talks about

00:22:09,379 --> 00:22:12,070
entity

00:22:14,010 --> 00:22:19,090
so indirect schematics puts you on the

00:22:16,750 --> 00:22:21,640
right path for generating out and

00:22:19,090 --> 00:22:23,200
connecting these reducers from there you

00:22:21,640 --> 00:22:25,090
write out the part of the application

00:22:23,200 --> 00:22:26,440
that's most interesting the part that's

00:22:25,090 --> 00:22:28,390
unique about the application you're

00:22:26,440 --> 00:22:30,040
building and that's the actions and the

00:22:28,390 --> 00:22:31,930
way state changes and the effects that

00:22:30,040 --> 00:22:34,270
start this tool really helps you

00:22:31,930 --> 00:22:38,890
scaffold out the real boilerplate that

00:22:34,270 --> 00:22:42,550
exists in an index application block me

00:22:38,890 --> 00:22:44,770
bro next Mike is going to talk about an

00:22:42,550 --> 00:22:47,650
Jurek's entity which also helps you

00:22:44,770 --> 00:22:51,010
handle those kind of state shapes we

00:22:47,650 --> 00:22:53,470
mentioned earlier so the index entity it

00:22:51,010 --> 00:22:54,610
gives you a couple of things it's a set

00:22:53,470 --> 00:22:57,040
of helpers to help you manage

00:22:54,610 --> 00:22:59,740
collections and it does this by

00:22:57,040 --> 00:23:02,200
providing you a set of typesafe

00:22:59,740 --> 00:23:04,600
functions for handling common operations

00:23:02,200 --> 00:23:08,650
like creating reading updating or

00:23:04,600 --> 00:23:11,170
deleting items out of out of a set it is

00:23:08,650 --> 00:23:12,970
built as an extendable typesafe adapter

00:23:11,170 --> 00:23:17,410
that you can use build more powerful

00:23:12,970 --> 00:23:19,180
domain-specific adapters with and this

00:23:17,410 --> 00:23:21,460
typesafe adapter is a really good

00:23:19,180 --> 00:23:23,560
building block it helps you build your

00:23:21,460 --> 00:23:27,550
own adapters that meet your requirements

00:23:23,560 --> 00:23:29,230
so what does this adapter do well like I

00:23:27,550 --> 00:23:31,690
said it's kind of built on this idea

00:23:29,230 --> 00:23:33,480
that applications tend to want to manage

00:23:31,690 --> 00:23:35,740
collections in their application and

00:23:33,480 --> 00:23:37,420
with a collection there's really a

00:23:35,740 --> 00:23:40,450
number of things that I as a UI

00:23:37,420 --> 00:23:42,250
developer want to do with them I want to

00:23:40,450 --> 00:23:44,320
know how many items are in a collection

00:23:42,250 --> 00:23:46,390
for instance I might want to show the

00:23:44,320 --> 00:23:49,810
length of the collection or the size of

00:23:46,390 --> 00:23:51,400
it somewhere in my UI I also might want

00:23:49,810 --> 00:23:53,140
to get one item out of that collection

00:23:51,400 --> 00:23:54,760
maybe I'm building a details page where

00:23:53,140 --> 00:23:57,820
I can view one item at a time and I

00:23:54,760 --> 00:24:00,010
needed to be fast I also want to build

00:23:57,820 --> 00:24:03,730
lists I want to show every item in my

00:24:00,010 --> 00:24:04,720
collection using like an NG for and I

00:24:03,730 --> 00:24:07,930
want to be able to manage this

00:24:04,720 --> 00:24:10,720
collection in a reducer function but as

00:24:07,930 --> 00:24:12,910
we said this is difficult because some

00:24:10,720 --> 00:24:15,310
of the really nice JavaScript data types

00:24:12,910 --> 00:24:17,110
that exist in the language we can't use

00:24:15,310 --> 00:24:20,770
in a reducer function like maps or sets

00:24:17,110 --> 00:24:22,630
because they're not serializable and so

00:24:20,770 --> 00:24:24,550
to do this we need to be able to update

00:24:22,630 --> 00:24:25,060
the collection as fast as possible

00:24:24,550 --> 00:24:27,670
whilst

00:24:25,060 --> 00:24:30,550
preserving our three use cases am I am I

00:24:27,670 --> 00:24:33,550
am I still following the practices by

00:24:30,550 --> 00:24:36,250
using this absolutely index entity puts

00:24:33,550 --> 00:24:39,520
you on the right Rails for building fast

00:24:36,250 --> 00:24:41,260
reactive applications and this is going

00:24:39,520 --> 00:24:42,970
to help you query items out of that

00:24:41,260 --> 00:24:44,410
collection it's gonna help you query all

00:24:42,970 --> 00:24:49,240
of them it's gonna help you get the

00:24:44,410 --> 00:24:50,380
total size of it and so what is going to

00:24:49,240 --> 00:24:51,820
do is we're going to take all the

00:24:50,380 --> 00:24:53,380
actions that come through our index

00:24:51,820 --> 00:24:55,240
application we're going to pass it to

00:24:53,380 --> 00:24:57,730
the reducer and this reducer is going to

00:24:55,240 --> 00:25:00,220
use in your X entity to update state and

00:24:57,730 --> 00:25:01,840
what does this date look like well we

00:25:00,220 --> 00:25:03,460
can't use maps or sets that we need to

00:25:01,840 --> 00:25:05,590
pick a data structure that's going to be

00:25:03,460 --> 00:25:08,920
serializable but also really fast and

00:25:05,590 --> 00:25:12,100
that's called at the entity state the

00:25:08,920 --> 00:25:14,020
IDS property allows us to main this or

00:25:12,100 --> 00:25:16,720
maintain the sort order of the

00:25:14,020 --> 00:25:18,850
collection remember that objects do not

00:25:16,720 --> 00:25:21,220
necessarily preserve sort order for

00:25:18,850 --> 00:25:22,420
their keys so if you want to sort your

00:25:21,220 --> 00:25:25,090
collection or if you want to maintain

00:25:22,420 --> 00:25:27,280
the sort order from your REST API that's

00:25:25,090 --> 00:25:30,190
what the IDS property lets you do like

00:25:27,280 --> 00:25:32,470
how is it fast is it really fast it's

00:25:30,190 --> 00:25:34,660
very fast and the fast or the speed

00:25:32,470 --> 00:25:36,190
comes from the entities property this

00:25:34,660 --> 00:25:38,260
allows you to reference a single item

00:25:36,190 --> 00:25:39,970
extremely quickly we don't have to

00:25:38,260 --> 00:25:41,830
search through an array for an item we

00:25:39,970 --> 00:25:44,740
can just quickly look it up using a hash

00:25:41,830 --> 00:25:46,750
table by us ID this is helpful when we

00:25:44,740 --> 00:25:48,850
need to update a single item test for an

00:25:46,750 --> 00:25:53,620
existence of an item or display one item

00:25:48,850 --> 00:25:55,510
and do it reasonably quickly but this

00:25:53,620 --> 00:25:56,950
data structure is really hard to work

00:25:55,510 --> 00:26:00,940
with if you're gonna do it by hand oh

00:25:56,950 --> 00:26:02,710
this looks like it kind of is the

00:26:00,940 --> 00:26:05,110
boilerplate because this state shape

00:26:02,710 --> 00:26:07,480
appears in so many places in your index

00:26:05,110 --> 00:26:09,850
application and so we want to reduce the

00:26:07,480 --> 00:26:11,980
boilerplate of managing it this is where

00:26:09,850 --> 00:26:13,090
index entity comes into play it gives

00:26:11,980 --> 00:26:15,700
you the ability to create what we call

00:26:13,090 --> 00:26:18,520
entity adapters and these adapters know

00:26:15,700 --> 00:26:20,530
just enough about your entity state to

00:26:18,520 --> 00:26:25,000
give you helper functions from from

00:26:20,530 --> 00:26:27,280
managing it to create an adapter by

00:26:25,000 --> 00:26:29,620
default it's looking for the ID property

00:26:27,280 --> 00:26:31,180
on an entity and it's assumed that you

00:26:29,620 --> 00:26:34,360
want to maintain the sort order from

00:26:31,180 --> 00:26:36,880
your REST API but it lets you over lock

00:26:34,360 --> 00:26:38,530
override certain aspects of it for

00:26:36,880 --> 00:26:40,570
instance if you have a different key

00:26:38,530 --> 00:26:44,260
you're using to determine which one's or

00:26:40,570 --> 00:26:46,510
determine the ID of it it also allows

00:26:44,260 --> 00:26:47,890
you to supply your own sort compared so

00:26:46,510 --> 00:26:50,050
if you don't want to maintain the same

00:26:47,890 --> 00:26:52,060
sort order that your API gave you and

00:26:50,050 --> 00:26:54,520
you maybe want to sort all your items by

00:26:52,060 --> 00:26:57,040
save their name property you can provide

00:26:54,520 --> 00:26:58,090
a sort compare function well it what

00:26:57,040 --> 00:27:00,940
about performance

00:26:58,090 --> 00:27:03,280
I love performance right we don't want

00:27:00,940 --> 00:27:05,560
to resort the entire collection every

00:27:03,280 --> 00:27:09,190
time we change the state shape that

00:27:05,560 --> 00:27:11,140
would be incredibly slow to do so

00:27:09,190 --> 00:27:13,750
indirect entity is really smart about

00:27:11,140 --> 00:27:15,520
using this sort compare function it uses

00:27:13,750 --> 00:27:17,530
it when making insertions so that we can

00:27:15,520 --> 00:27:20,920
insert your item into the right place in

00:27:17,530 --> 00:27:22,360
the into the collection that means we're

00:27:20,920 --> 00:27:24,580
not resore ting your entire collection

00:27:22,360 --> 00:27:27,730
every time it changes we're only doing

00:27:24,580 --> 00:27:31,750
it when we absolutely have to this keeps

00:27:27,730 --> 00:27:33,490
your application running very fast the

00:27:31,750 --> 00:27:34,840
adapter also comes with a number of

00:27:33,490 --> 00:27:37,120
functions that help you set up your

00:27:34,840 --> 00:27:39,220
reducer for instance we can use the

00:27:37,120 --> 00:27:43,180
adapter to initialize the state of the

00:27:39,220 --> 00:27:44,680
reducer when it comes to updating the

00:27:43,180 --> 00:27:47,110
state it comes with a number of a

00:27:44,680 --> 00:27:49,510
functions from for managing those it

00:27:47,110 --> 00:27:51,760
handles all the common use cases like

00:27:49,510 --> 00:27:53,710
inserting into the collection updating

00:27:51,760 --> 00:27:57,880
items in the collection or moving items

00:27:53,710 --> 00:28:00,160
and lastly up serving it can also

00:27:57,880 --> 00:28:01,900
generate your selectors for you so you

00:28:00,160 --> 00:28:04,090
don't have to write these selectors that

00:28:01,900 --> 00:28:05,590
go and grab these properties we know

00:28:04,090 --> 00:28:07,150
what the state shape is and we can drink

00:28:05,590 --> 00:28:09,790
them for you you need to your reducer

00:28:07,150 --> 00:28:11,680
and they support all those use cases we

00:28:09,790 --> 00:28:13,720
laid out at the beginning using these

00:28:11,680 --> 00:28:15,370
selectors you can query for one using

00:28:13,720 --> 00:28:17,350
select entities you can get the entire

00:28:15,370 --> 00:28:19,270
list that we've restored for you with

00:28:17,350 --> 00:28:23,410
select all and you can get the size of

00:28:19,270 --> 00:28:25,720
the collection like we see some code yes

00:28:23,410 --> 00:28:27,580
I'll show you how to use indirect sense

00:28:25,720 --> 00:28:29,860
tea and I'm gonna give you a warning I

00:28:27,580 --> 00:28:32,550
do not have the magical ability that

00:28:29,860 --> 00:28:34,930
like Brandon does to just generate code

00:28:32,550 --> 00:28:36,640
three letters and you saw all that code

00:28:34,930 --> 00:28:38,380
generated you can't do that I can't do

00:28:36,640 --> 00:28:42,970
that you have to watch me do this I need

00:28:38,380 --> 00:28:45,550
you to get good it's fine this is what

00:28:42,970 --> 00:28:47,380
it's like working with him don't be

00:28:45,550 --> 00:28:51,220
salting my speaking of being salt him to

00:28:47,380 --> 00:28:54,560
go and update this action type right now

00:28:51,220 --> 00:28:56,780
CEUs actually hide this is good action

00:28:54,560 --> 00:28:58,610
hydrating and let's say we're doing a

00:28:56,780 --> 00:29:00,980
get all action we should put this in the

00:28:58,610 --> 00:29:04,760
app in to generate function itself great

00:29:00,980 --> 00:29:08,450
hmm so in the constructor I'm gonna let

00:29:04,760 --> 00:29:11,540
you specify that you can pass in this

00:29:08,450 --> 00:29:14,600
action a list of users and what I want

00:29:11,540 --> 00:29:18,110
to do is I want to be able to store this

00:29:14,600 --> 00:29:20,000
in a reducer function so if I go back

00:29:18,110 --> 00:29:22,030
and look at this reducer function it

00:29:20,000 --> 00:29:24,530
doesn't really have anything in it and

00:29:22,030 --> 00:29:26,900
or inject semantics has scaffolded out

00:29:24,530 --> 00:29:28,610
the state in the initial state as long

00:29:26,900 --> 00:29:30,170
along with the reducer what we want to

00:29:28,610 --> 00:29:33,050
actually implement this using indirect

00:29:30,170 --> 00:29:37,790
sanity so the first thing when I import

00:29:33,050 --> 00:29:42,980
is create entity adapter from ng or X

00:29:37,790 --> 00:29:45,140
entity and this created Apter is how we

00:29:42,980 --> 00:29:46,730
are going to tell injects entity what

00:29:45,140 --> 00:29:49,490
our state shape or what our entities

00:29:46,730 --> 00:29:52,490
look like so I'm going to create an

00:29:49,490 --> 00:29:56,960
adapter and I'm going to do it using the

00:29:52,490 --> 00:29:58,430
user model whew that nice type safety so

00:29:56,960 --> 00:30:00,770
the first thing I have to do is I have

00:29:58,430 --> 00:30:04,040
to select or tell indirect entity how to

00:30:00,770 --> 00:30:05,840
select the ID out of this model so do

00:30:04,040 --> 00:30:07,810
that I'm going to take a given user and

00:30:05,840 --> 00:30:10,880
say you can get it using the ID

00:30:07,810 --> 00:30:13,190
I'm also want to specify that I want

00:30:10,880 --> 00:30:15,830
these users to be supported or to be

00:30:13,190 --> 00:30:19,490
sorted by their name so for user a and

00:30:15,830 --> 00:30:22,250
user B you can compare them using their

00:30:19,490 --> 00:30:23,780
name I'm going to use the locale compare

00:30:22,250 --> 00:30:28,910
function on strings to great this

00:30:23,780 --> 00:30:31,220
quickly Oh fancy mmm-hmm for the state

00:30:28,910 --> 00:30:32,510
interface I don't actually have to type

00:30:31,220 --> 00:30:34,490
this out anymore I can go ahead and

00:30:32,510 --> 00:30:36,770
delete this and I can instead export a

00:30:34,490 --> 00:30:40,520
type called state and say that this is

00:30:36,770 --> 00:30:44,170
just entity state imported from injure X

00:30:40,520 --> 00:30:46,580
entity and it maintains my user models

00:30:44,170 --> 00:30:48,350
type repelling my initial States not

00:30:46,580 --> 00:30:51,340
fully implemented and he's right I'm

00:30:48,350 --> 00:30:55,820
gonna use the adapter to quickly

00:30:51,340 --> 00:30:58,100
generate the initial State now for my

00:30:55,820 --> 00:31:00,980
reducer function all I have to do is add

00:30:58,100 --> 00:31:02,870
all these users to my state and to do

00:31:00,980 --> 00:31:03,440
that I'm gonna first delete this line of

00:31:02,870 --> 00:31:08,389
code

00:31:03,440 --> 00:31:11,059
I'm the return adapter at all and I can

00:31:08,389 --> 00:31:13,850
get into my action and grab that users

00:31:11,059 --> 00:31:15,590
property last thing I'm to pass in is my

00:31:13,850 --> 00:31:18,019
state and that's all there was to it to

00:31:15,590 --> 00:31:19,490
maintaining this collection oh that

00:31:18,019 --> 00:31:21,529
looks like a lot less code than that

00:31:19,490 --> 00:31:24,259
water plate you talked about earlier I'm

00:31:21,529 --> 00:31:28,730
blocking you I'll block you you don't

00:31:24,259 --> 00:31:31,490
block me last thing I need to do is I

00:31:28,730 --> 00:31:33,230
need to get those selectors and injects

00:31:31,490 --> 00:31:34,519
entity is going to generate fast memo I

00:31:33,230 --> 00:31:37,070
selectors that work with this collection

00:31:34,519 --> 00:31:41,419
for me so I'm going to say give me the

00:31:37,070 --> 00:31:43,879
selected IDs select entities select all

00:31:41,419 --> 00:31:47,000
and select total and that a lot of type

00:31:43,879 --> 00:31:49,309
in but is only it was so much fewer

00:31:47,000 --> 00:31:50,960
lines of code to actually maintain a

00:31:49,309 --> 00:31:53,000
collection of users than the previous

00:31:50,960 --> 00:31:55,159
example and this gets you moving so much

00:31:53,000 --> 00:31:57,049
faster because I found that in an index

00:31:55,159 --> 00:31:59,840
application you write a lot of these

00:31:57,049 --> 00:32:08,049
types of reducers and that's totally

00:31:59,840 --> 00:32:08,049
okay all right so let's jump back to it

00:32:08,409 --> 00:32:14,509
so now that we've covered using

00:32:11,179 --> 00:32:16,070
schematics to reduce boilerplate and we

00:32:14,509 --> 00:32:19,519
talked about entity to manage

00:32:16,070 --> 00:32:22,190
collections let's talk about what's

00:32:19,519 --> 00:32:23,750
happening in the future avenger x so the

00:32:22,190 --> 00:32:25,820
biggest change it's gonna really help

00:32:23,750 --> 00:32:28,309
you when writing less boilerplate is

00:32:25,820 --> 00:32:30,049
typescript 2.8 I've been told that

00:32:28,309 --> 00:32:33,049
angular is gonna get support for it with

00:32:30,049 --> 00:32:35,720
angular 6.1 and what typescript 2.8

00:32:33,049 --> 00:32:37,940
provides is it provides much better type

00:32:35,720 --> 00:32:39,889
utilities for us to infer the structure

00:32:37,940 --> 00:32:42,379
of your application so if you've ever

00:32:39,889 --> 00:32:44,059
had to string up a large union of action

00:32:42,379 --> 00:32:46,279
classes before that kind of thing is

00:32:44,059 --> 00:32:49,100
going to go away when types of 2.8 lands

00:32:46,279 --> 00:32:51,259
in the angular ecosystem and I don't

00:32:49,100 --> 00:32:54,320
know about you but I love to see a lie

00:32:51,259 --> 00:32:56,240
and I love schematics so in the future

00:32:54,320 --> 00:32:57,409
versions of integer X you'll be able

00:32:56,240 --> 00:33:00,289
we're going to provide further

00:32:57,409 --> 00:33:03,169
integration with the CLI by using taking

00:33:00,289 --> 00:33:04,970
advantage of ng add to add projects and

00:33:03,169 --> 00:33:07,610
automatically wire things up further and

00:33:04,970 --> 00:33:10,279
also ng update if you're migrating from

00:33:07,610 --> 00:33:12,200
one version to vendor X to the next if

00:33:10,279 --> 00:33:13,789
you saw the keynote yesterday Brad green

00:33:12,200 --> 00:33:16,430
announced that injure X data is becoming

00:33:13,789 --> 00:33:18,440
an official part of the Ender X family

00:33:16,430 --> 00:33:20,180
and index data is a library by John

00:33:18,440 --> 00:33:21,800
Papua and warbell who will also be

00:33:20,180 --> 00:33:26,930
joining us and helping try to build

00:33:21,800 --> 00:33:29,960
conventions around in jar X so let's

00:33:26,930 --> 00:33:33,370
recap we talked about explicitness that

00:33:29,960 --> 00:33:36,440
gives you type safety serialization and

00:33:33,370 --> 00:33:38,570
easier testing story we defined

00:33:36,440 --> 00:33:40,490
boilerplate will play actions and

00:33:38,570 --> 00:33:42,700
reducers are not boilerplate but

00:33:40,490 --> 00:33:45,920
connecting all these things up really is

00:33:42,700 --> 00:33:48,410
and that is because of the concepts that

00:33:45,920 --> 00:33:50,930
that we mentioned earlier by using these

00:33:48,410 --> 00:33:52,760
these actions and types the list you

00:33:50,930 --> 00:33:55,100
float that types at the flow throughout

00:33:52,760 --> 00:33:56,600
your app we also talked about how this

00:33:55,100 --> 00:33:57,920
kind of state management gives you

00:33:56,600 --> 00:33:59,900
things that you should really appreciate

00:33:57,920 --> 00:34:02,540
about in your ex like immutability and

00:33:59,900 --> 00:34:04,340
serializability we also covered the

00:34:02,540 --> 00:34:06,590
things that hopefully it will give you a

00:34:04,340 --> 00:34:08,570
good direction of what belongs in the

00:34:06,590 --> 00:34:11,980
store and what doesn't so that you can

00:34:08,570 --> 00:34:15,140
write less code and still be productive

00:34:11,980 --> 00:34:17,149
so with that we're gonna go ahead and

00:34:15,140 --> 00:34:18,830
hand it over to Ward Bell who's going to

00:34:17,149 --> 00:34:21,659
come up and give you a quick brief look

00:34:18,830 --> 00:34:29,869
into injects data thank you

00:34:21,659 --> 00:34:29,869
[Applause]

00:34:39,610 --> 00:34:51,160
I got mine all righty

00:34:46,060 --> 00:34:53,260
Hey look at that all right so 100%

00:34:51,160 --> 00:34:57,640
marketing slides all the time that's

00:34:53,260 --> 00:34:58,840
what we want that's what we get so we're

00:34:57,640 --> 00:35:02,740
going to introduce you today you know

00:34:58,840 --> 00:35:06,190
reactive style and NGO rx I'm Ward Bell

00:35:02,740 --> 00:35:08,950
that's that's John Papa and together we

00:35:06,190 --> 00:35:10,480
took this project on now as you've

00:35:08,950 --> 00:35:12,460
learned well through the sherry

00:35:10,480 --> 00:35:14,230
principle interacts is really for shared

00:35:12,460 --> 00:35:15,970
state and there's various kinds of

00:35:14,230 --> 00:35:17,590
shared state there's entity state you

00:35:15,970 --> 00:35:19,000
know those heroes and villains and the

00:35:17,590 --> 00:35:21,460
customers and orders and products that

00:35:19,000 --> 00:35:24,190
you're used to saving and then there's

00:35:21,460 --> 00:35:26,140
transient state which is the user info

00:35:24,190 --> 00:35:28,240
the preferences and and these are all

00:35:26,140 --> 00:35:31,030
the kinds of things that you would use

00:35:28,240 --> 00:35:32,530
enter your X data to manage and then

00:35:31,030 --> 00:35:34,720
there's this local component state which

00:35:32,530 --> 00:35:37,900
you do not put in NV or X so we're in

00:35:34,720 --> 00:35:39,880
total alignment about that all right but

00:35:37,900 --> 00:35:41,740
as you begin to build this stuff out

00:35:39,880 --> 00:35:43,570
it's it seems pretty easy to do the

00:35:41,740 --> 00:35:46,150
transient state but when you start

00:35:43,570 --> 00:35:48,820
working with an tt state which is where

00:35:46,150 --> 00:35:50,590
I really want to focus you find that

00:35:48,820 --> 00:35:52,030
you've got of these artifacts that keep

00:35:50,590 --> 00:35:55,090
coming up it that people have been

00:35:52,030 --> 00:35:56,350
talking about so if we did one for you

00:35:55,090 --> 00:35:58,090
know here's a project for just two

00:35:56,350 --> 00:35:59,650
heroes and villains in one of our

00:35:58,090 --> 00:36:03,670
examples and you've got a lot of files

00:35:59,650 --> 00:36:06,040
there and you had to write them and you

00:36:03,670 --> 00:36:07,630
have to do it again not all yeah every

00:36:06,040 --> 00:36:09,940
one of them but a lot of them for each

00:36:07,630 --> 00:36:11,680
new entity type you add and if you've

00:36:09,940 --> 00:36:13,660
only got two it's not so bad and if

00:36:11,680 --> 00:36:14,950
you've got 50 it starts to look bad and

00:36:13,660 --> 00:36:18,480
if you have an enterprise application

00:36:14,950 --> 00:36:20,770
with 300 entities it's looking real bad

00:36:18,480 --> 00:36:24,070
at least it was looking real bad for me

00:36:20,770 --> 00:36:26,560
so we said like what can we do about it

00:36:24,070 --> 00:36:30,760
notice by the way yes I totally agree

00:36:26,560 --> 00:36:37,210
with the definition of boilerplate being

00:36:30,760 --> 00:36:38,140
this which is like you know boilerplate

00:36:37,210 --> 00:36:40,480
should really be the stuff that you

00:36:38,140 --> 00:36:42,370
don't really touch it's but when you're

00:36:40,480 --> 00:36:44,200
when it all looks the same and you can't

00:36:42,370 --> 00:36:48,850
really tell what's different you know

00:36:44,200 --> 00:36:50,920
then I call that boilerplate so this I'm

00:36:48,850 --> 00:36:52,779
gonna get it I'm going to get it

00:36:50,920 --> 00:36:55,480
that's my good friend red is gonna kill

00:36:52,779 --> 00:36:56,829
me so anyway Andrey arks date is for

00:36:55,480 --> 00:36:58,240
entity state it's not a replacement for

00:36:56,829 --> 00:36:59,769
all the kind of state that you're gonna

00:36:58,240 --> 00:37:01,660
manage it's not a replacement for

00:36:59,769 --> 00:37:05,950
anything as you'll see it's just a way

00:37:01,660 --> 00:37:08,740
to and it's a goal and let me just show

00:37:05,950 --> 00:37:10,119
you what you've seen all the other stuff

00:37:08,740 --> 00:37:12,819
no need to show you what it's like the

00:37:10,119 --> 00:37:14,799
ngrick State experience like here I got

00:37:12,819 --> 00:37:17,260
an energy model with two things that's

00:37:14,799 --> 00:37:19,210
soom it's really simple I'm just gonna

00:37:17,260 --> 00:37:21,519
define metadata for hero as you can see

00:37:19,210 --> 00:37:24,130
how hard that is and villain you can see

00:37:21,519 --> 00:37:26,470
how hard that is and if I had another

00:37:24,130 --> 00:37:30,130
one guess what I do yeah

00:37:26,470 --> 00:37:32,920
all right and now I gotta configure the

00:37:30,130 --> 00:37:37,569
ng rx data module and yeah that's what I

00:37:32,920 --> 00:37:39,220
do I'm done it's hard I got it I got

00:37:37,569 --> 00:37:40,869
I'll put it I'll call it entity store

00:37:39,220 --> 00:37:42,309
module so I have something separate from

00:37:40,869 --> 00:37:45,250
the other kinds of ngrick state of

00:37:42,309 --> 00:37:47,559
things I'm doing and now into my app

00:37:45,250 --> 00:37:49,809
store module where I'm registering all

00:37:47,559 --> 00:37:54,250
my store stuff and doing all my other ng

00:37:49,809 --> 00:37:56,680
rx stuff I I do that so now iris all my

00:37:54,250 --> 00:37:59,019
entities that are ever going to be that

00:37:56,680 --> 00:38:04,390
are ever going to be whether it's two

00:37:59,019 --> 00:38:07,569
for 50 100 300 and now for each one I

00:38:04,390 --> 00:38:10,210
like to make a convenience service

00:38:07,569 --> 00:38:12,099
method to manage the interaction with

00:38:10,210 --> 00:38:14,650
the thing that entry X data provides

00:38:12,099 --> 00:38:16,750
called an entity service Factory because

00:38:14,650 --> 00:38:18,640
there's implicitly an entity service for

00:38:16,750 --> 00:38:20,650
each entity type you'll see how that

00:38:18,640 --> 00:38:22,480
works and it's all for the case that

00:38:20,650 --> 00:38:24,940
you'll customize this so I I happen to

00:38:22,480 --> 00:38:27,579
like a convenience method and then I can

00:38:24,940 --> 00:38:31,150
inject that into my component that needs

00:38:27,579 --> 00:38:33,400
access to heroes and I just say hey

00:38:31,150 --> 00:38:36,130
Sara's service give me my selectors and

00:38:33,400 --> 00:38:39,009
there they are so I've got a heroes or a

00:38:36,130 --> 00:38:41,019
selector that's priming the they you

00:38:39,009 --> 00:38:44,079
know showing up on the list and I got my

00:38:41,019 --> 00:38:46,299
loadings for my spinner and then when I

00:38:44,079 --> 00:38:50,069
want to do any of my crowd operations I

00:38:46,299 --> 00:38:52,210
go like that and you're done

00:38:50,069 --> 00:38:53,890
currently I can't count because that

00:38:52,210 --> 00:38:56,740
said too but there were five steps

00:38:53,890 --> 00:38:58,839
they're friends and you are done all

00:38:56,740 --> 00:39:01,779
right done is in quotes because you've

00:38:58,839 --> 00:39:03,010
really just begun but you are up and

00:39:01,779 --> 00:39:05,770
running

00:39:03,010 --> 00:39:11,140
talking to your back-end even you notice

00:39:05,770 --> 00:39:13,510
I didn't even build a rest surface so

00:39:11,140 --> 00:39:14,770
what did we see there are no India the

00:39:13,510 --> 00:39:16,780
thing on the right there is that

00:39:14,770 --> 00:39:19,210
original list the thing on the left is

00:39:16,780 --> 00:39:21,040
what the store looks like the store

00:39:19,210 --> 00:39:22,720
folder looks like when I've it's an eye

00:39:21,040 --> 00:39:24,369
chart and supposed to be don't try and

00:39:22,720 --> 00:39:26,710
read it too closely the key is that the

00:39:24,369 --> 00:39:27,850
thing on the left is not growth no

00:39:26,710 --> 00:39:30,070
matter how many entities you put in

00:39:27,850 --> 00:39:31,750
there doesn't have to grow so there are

00:39:30,070 --> 00:39:33,190
no actions or action creators to write

00:39:31,750 --> 00:39:34,690
there no reducers to write there are no

00:39:33,190 --> 00:39:36,340
selectors to write there are no effects

00:39:34,690 --> 00:39:38,920
to write there's no code generation

00:39:36,340 --> 00:39:40,869
involved some people ask me should we

00:39:38,920 --> 00:39:42,640
can I help you write a schematics for

00:39:40,869 --> 00:39:44,859
NGR data if you have to write a

00:39:42,640 --> 00:39:47,560
schematics for a New York's data then we

00:39:44,859 --> 00:39:49,060
failed all right because the idea it

00:39:47,560 --> 00:39:51,400
this is not an argument against

00:39:49,060 --> 00:39:54,760
schematics it says it's an argument

00:39:51,400 --> 00:39:58,540
about what the intention of engineer X

00:39:54,760 --> 00:39:59,619
data is which is to say you know a lot

00:39:58,540 --> 00:40:01,000
of these things are similar there's a

00:39:59,619 --> 00:40:03,430
lot of the same patterns so if you can

00:40:01,000 --> 00:40:06,040
follow the same patterns will create

00:40:03,430 --> 00:40:08,800
these things these artifacts for you on

00:40:06,040 --> 00:40:11,859
the fly you won't have to write them

00:40:08,800 --> 00:40:13,330
they're there all right by the way

00:40:11,859 --> 00:40:16,330
there's a built in HTTP crud service

00:40:13,330 --> 00:40:18,609
there there it's still an grx this is

00:40:16,330 --> 00:40:20,560
not an alternative to ng rx this is

00:40:18,609 --> 00:40:22,180
saying if you follow conventions we can

00:40:20,560 --> 00:40:26,380
do a lot of the things that you would do

00:40:22,180 --> 00:40:28,540
by hand ourselves for you on the fly all

00:40:26,380 --> 00:40:31,750
right so just to make the point

00:40:28,540 --> 00:40:33,100
ng Rx is built on ng rx store that's the

00:40:31,750 --> 00:40:34,660
foundation you get your stores your

00:40:33,100 --> 00:40:35,200
actions reducers your selectors they're

00:40:34,660 --> 00:40:38,350
all there

00:40:35,200 --> 00:40:40,570
it uses effects to handle the HTTP stuff

00:40:38,350 --> 00:40:41,770
as this sort of act as a message bus so

00:40:40,570 --> 00:40:44,320
when you say you want to go get

00:40:41,770 --> 00:40:46,210
something or save things or update its

00:40:44,320 --> 00:40:49,960
talk it's using the effects to cure that

00:40:46,210 --> 00:40:51,880
action produce a call comes back takes

00:40:49,960 --> 00:40:53,380
the data turns that into actions they

00:40:51,880 --> 00:40:56,800
flow through the store it's all there

00:40:53,380 --> 00:40:57,940
we're using effects and REE arcs entity

00:40:56,800 --> 00:41:00,070
what you learned about today is a

00:40:57,940 --> 00:41:02,200
fantastic representation of an entity

00:41:00,070 --> 00:41:03,820
collection we loved it we wrote our own

00:41:02,200 --> 00:41:06,490
we saw into your X identity we said no

00:41:03,820 --> 00:41:08,830
no no no these guys got it now so put it

00:41:06,490 --> 00:41:10,690
in there so we're riding on all these

00:41:08,830 --> 00:41:13,840
things all we're doing is adding

00:41:10,690 --> 00:41:16,090
something another layer optional that if

00:41:13,840 --> 00:41:16,869
you have conventions for entity

00:41:16,090 --> 00:41:18,670
collections

00:41:16,869 --> 00:41:21,849
you can use it and then you just go 1 2

00:41:18,670 --> 00:41:23,200
3 4 5 and by the way you know you can

00:41:21,849 --> 00:41:24,279
tell right so one of the things with

00:41:23,200 --> 00:41:24,849
conventions you've got to see what's

00:41:24,279 --> 00:41:28,089
going on

00:41:24,849 --> 00:41:30,039
so the redux tour is there if I I don't

00:41:28,089 --> 00:41:31,210
know if I still got this zoomy thing but

00:41:30,039 --> 00:41:33,069
if you look in there you can see I've

00:41:31,210 --> 00:41:34,990
got generating little methods and a

00:41:33,069 --> 00:41:37,329
little store entries and stuff like that

00:41:34,990 --> 00:41:39,130
I'm sorry actions and I'm generating the

00:41:37,329 --> 00:41:41,049
action titles for you each action is

00:41:39,130 --> 00:41:43,749
independent each has its own type just

00:41:41,049 --> 00:41:47,799
like it's supposed to so you can find

00:41:43,749 --> 00:41:49,569
what you're doing and we know that we

00:41:47,799 --> 00:41:51,339
can't get it right like you know my

00:41:49,569 --> 00:41:53,410
conventions are not your conventions and

00:41:51,339 --> 00:41:55,390
you might have some entity you know most

00:41:53,410 --> 00:41:57,579
of them 80% flow down the convention

00:41:55,390 --> 00:41:59,349
path but something doesn't so maybe you

00:41:57,579 --> 00:42:02,829
know you don't call the primary key of

00:41:59,349 --> 00:42:05,740
your entity ID you call it key or foo

00:42:02,829 --> 00:42:07,619
well you could change that that's by the

00:42:05,740 --> 00:42:11,140
way something that comes to you through

00:42:07,619 --> 00:42:12,490
injury or X entity say you have you

00:42:11,140 --> 00:42:14,170
don't like the way we did our arrest

00:42:12,490 --> 00:42:16,150
service you have your own custom data

00:42:14,170 --> 00:42:18,099
access service you can change it at the

00:42:16,150 --> 00:42:19,839
individual collection item like the

00:42:18,099 --> 00:42:22,329
collection for heroes you can do it at

00:42:19,839 --> 00:42:25,210
the overall you just change the one that

00:42:22,329 --> 00:42:26,529
we're using change it custom actions

00:42:25,210 --> 00:42:28,690
you've got extra things you want to do

00:42:26,529 --> 00:42:31,180
adam edgar and you can add your own

00:42:28,690 --> 00:42:33,160
reducers there's meta reducers you've

00:42:31,180 --> 00:42:34,599
got custom reducers you want to

00:42:33,160 --> 00:42:36,220
completely change the way the reducers

00:42:34,599 --> 00:42:38,529
work for a particular entity you can

00:42:36,220 --> 00:42:40,480
change it on an entity level or you can

00:42:38,529 --> 00:42:41,859
change the default one or you can say I

00:42:40,480 --> 00:42:43,960
like your default one but I don't like

00:42:41,859 --> 00:42:45,849
the way you did the add to cash so that

00:42:43,960 --> 00:42:49,329
problem just change that one and then

00:42:45,849 --> 00:42:51,249
all the others get it custom effects you

00:42:49,329 --> 00:42:53,289
don't like effects at all don't use them

00:42:51,249 --> 00:42:55,920
yank it out you do like effects what you

00:42:53,289 --> 00:42:58,150
want to add your own add your own you

00:42:55,920 --> 00:43:00,489
think a particular entity type is just

00:42:58,150 --> 00:43:02,349
like a bad 4/5 for this thing all right

00:43:00,489 --> 00:43:04,680
you got out you want to roll it yourself

00:43:02,349 --> 00:43:07,749
right from any of the other things that

00:43:04,680 --> 00:43:08,980
Brandon and Mike showed you no problem

00:43:07,749 --> 00:43:10,749
you don't know you don't have to throw

00:43:08,980 --> 00:43:13,779
every entity into this thing just pull

00:43:10,749 --> 00:43:15,190
it out all right this thing is not meant

00:43:13,779 --> 00:43:18,249
to be handcuffs this is meant to

00:43:15,190 --> 00:43:20,200
liberate you to get going see how far it

00:43:18,249 --> 00:43:23,890
takes you customize where you need to

00:43:20,200 --> 00:43:25,470
and step back and use standard entry Rx

00:43:23,890 --> 00:43:28,930
when you need to

00:43:25,470 --> 00:43:33,080
it's just ng rx

00:43:28,930 --> 00:43:37,160
so we're really pleased that the team at

00:43:33,080 --> 00:43:41,300
ng Rx thought they welcomed us into

00:43:37,160 --> 00:43:43,210
their family so it's now a full house we

00:43:41,300 --> 00:43:45,850
don't know who else is coming in there

00:43:43,210 --> 00:43:49,520
now and like I say like who's the boss

00:43:45,850 --> 00:43:52,470
who's the boss you're the boss

00:43:49,520 --> 00:43:57,119
it's your auntie rx thank you very much

00:43:52,470 --> 00:43:59,180
[Applause]

00:43:57,119 --> 00:43:59,180

YouTube URL: https://www.youtube.com/watch?v=t3jx0EC-Y3c


