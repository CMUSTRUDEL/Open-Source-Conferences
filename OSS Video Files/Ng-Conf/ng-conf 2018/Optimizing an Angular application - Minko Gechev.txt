Title: Optimizing an Angular application - Minko Gechev
Publication date: 2018-11-16
Playlist: ng-conf 2018
Description: 
	ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:05,650 --> 00:00:10,330
so here are a couple of words about me

00:00:07,860 --> 00:00:12,070
I'm working on rhyme which is the

00:00:10,330 --> 00:00:15,270
platform that you can actually today use

00:00:12,070 --> 00:00:17,950
in order to follow along the workshop

00:00:15,270 --> 00:00:19,540
this is a platform which allows you to

00:00:17,950 --> 00:00:21,130
build more scalable and consistent

00:00:19,540 --> 00:00:23,169
workshops and corporate trainings by

00:00:21,130 --> 00:00:25,000
using virtualization in the browser and

00:00:23,169 --> 00:00:25,720
I'm also quite active in the open source

00:00:25,000 --> 00:00:27,309
community

00:00:25,720 --> 00:00:29,770
so I'm former member of the angular

00:00:27,309 --> 00:00:32,169
mobile team I also together with jump

00:00:29,770 --> 00:00:33,820
app webinar and warbell works on the

00:00:32,169 --> 00:00:37,059
angular style guide which is known in

00:00:33,820 --> 00:00:39,489
your IO I'm working on angular seed

00:00:37,059 --> 00:00:41,079
colorized Collider is the two for static

00:00:39,489 --> 00:00:44,230
analysis which you might be already

00:00:41,079 --> 00:00:45,850
using in angular CLI and a couple of

00:00:44,230 --> 00:00:49,660
other projects which are related to the

00:00:45,850 --> 00:00:51,760
angular compiler mostly so the workshop

00:00:49,660 --> 00:00:54,899
today I wanted to focus specifically on

00:00:51,760 --> 00:00:57,909
runtime performance previously I was

00:00:54,899 --> 00:01:00,370
building a lot of content related to

00:00:57,909 --> 00:01:01,899
making our bundles more but as we saw

00:01:00,370 --> 00:01:03,069
yesterday on the keynote the angular

00:01:01,899 --> 00:01:05,920
team is working in the exact same

00:01:03,069 --> 00:01:07,960
direction so we have Ivy and Ivy can

00:01:05,920 --> 00:01:10,920
allow us to build a hello world which is

00:01:07,960 --> 00:01:14,470
only 2.7 K and we have amazing to link

00:01:10,920 --> 00:01:16,440
underneath in the anchor CLI which

00:01:14,470 --> 00:01:18,700
allows us to tree shake our application

00:01:16,440 --> 00:01:20,530
apply different dead code elimination

00:01:18,700 --> 00:01:22,530
techniques and so on and so forth

00:01:20,530 --> 00:01:25,330
however regarding runtime performance

00:01:22,530 --> 00:01:29,350
everything is in our own hands so we

00:01:25,330 --> 00:01:30,520
need to take care of this so there are a

00:01:29,350 --> 00:01:33,600
couple of techniques that we're going to

00:01:30,520 --> 00:01:36,490
take a look at I try to make them

00:01:33,600 --> 00:01:39,940
angular specific but also to allow you

00:01:36,490 --> 00:01:41,170
to see where they're inspired from so

00:01:39,940 --> 00:01:42,880
most of them are inspired from

00:01:41,170 --> 00:01:45,120
functional programming and you can apply

00:01:42,880 --> 00:01:49,000
them not only in angular but in other

00:01:45,120 --> 00:01:50,530
technologies as well if you want to

00:01:49,000 --> 00:01:51,520
follow along with me you can join on

00:01:50,530 --> 00:01:56,440
this URL right here

00:01:51,520 --> 00:01:57,970
rhymes comm / go / ng perf if you're

00:01:56,440 --> 00:02:00,400
watching the live stream you should be

00:01:57,970 --> 00:02:02,440
able to join on this year as well after

00:02:00,400 --> 00:02:04,630
registration you should get a virtual

00:02:02,440 --> 00:02:07,300
machine which has the exact same setup

00:02:04,630 --> 00:02:10,000
as like everyone else it has the project

00:02:07,300 --> 00:02:11,260
prints told it has node modules

00:02:10,000 --> 00:02:14,140
pre-installed so you don't have to waste

00:02:11,260 --> 00:02:16,659
time in this it has vyas codes and a few

00:02:14,140 --> 00:02:19,000
other a few other tools which I thought

00:02:16,659 --> 00:02:21,620
it might be appropriate

00:02:19,000 --> 00:02:24,230
after you register your going to see

00:02:21,620 --> 00:02:25,880
screen similar to this one here so your

00:02:24,230 --> 00:02:30,260
virtual machine is going to be on the

00:02:25,880 --> 00:02:32,210
left you can control it and you can

00:02:30,260 --> 00:02:34,040
follow along with me there and from the

00:02:32,210 --> 00:02:36,110
right usually there is a video of me

00:02:34,040 --> 00:02:38,600
showing something or of the guide

00:02:36,110 --> 00:02:41,450
showing something either a video or just

00:02:38,600 --> 00:02:43,700
their virtual machine performing but

00:02:41,450 --> 00:02:46,490
however in this case you're going to see

00:02:43,700 --> 00:02:48,530
my screen here on the big on the wall so

00:02:46,490 --> 00:02:51,440
you can just collapse the right the

00:02:48,530 --> 00:02:52,610
right side if you're following the live

00:02:51,440 --> 00:02:54,440
stream you can watch the video on

00:02:52,610 --> 00:02:58,640
YouTube and follow along we need in your

00:02:54,440 --> 00:03:00,410
virtual machine right so we're going to

00:02:58,640 --> 00:03:04,220
take a very simplified business

00:03:00,410 --> 00:03:06,020
application today and we're going to

00:03:04,220 --> 00:03:08,000
discover all the performance issues that

00:03:06,020 --> 00:03:10,460
it has and we're going to go step by

00:03:08,000 --> 00:03:12,620
step into optimizing it and making it

00:03:10,460 --> 00:03:19,040
faster let's take a look at the business

00:03:12,620 --> 00:03:21,740
app so you can open if you're following

00:03:19,040 --> 00:03:24,260
along you can go to projects optimizing

00:03:21,740 --> 00:03:27,680
connect your app and so you can run and

00:03:24,260 --> 00:03:32,780
you serve there this is an angular CLI

00:03:27,680 --> 00:03:34,730
application so until this loads we can

00:03:32,780 --> 00:03:37,880
just briefly take a look at the code

00:03:34,730 --> 00:03:39,860
base so as in any angular application

00:03:37,880 --> 00:03:42,530
and your co application we have a main

00:03:39,860 --> 00:03:46,910
file in the main file we are booster

00:03:42,530 --> 00:03:48,440
wrapping the app with the app module in

00:03:46,910 --> 00:03:52,040
the app module we have the bootstrap

00:03:48,440 --> 00:03:54,860
component app component which internally

00:03:52,040 --> 00:03:56,720
has a templates and in this template

00:03:54,860 --> 00:04:00,980
we're creating two instances of the app

00:03:56,720 --> 00:04:02,630
of the employee list component also

00:04:00,980 --> 00:04:03,410
we're holding some state inside of the

00:04:02,630 --> 00:04:06,530
app component

00:04:03,410 --> 00:04:10,280
we're holding two areas of items of type

00:04:06,530 --> 00:04:13,280
employee data that's pretty much what's

00:04:10,280 --> 00:04:14,510
interesting about this component we can

00:04:13,280 --> 00:04:17,030
take a look at the employee list

00:04:14,510 --> 00:04:19,700
component right after after that but

00:04:17,030 --> 00:04:20,810
before going into the employers

00:04:19,700 --> 00:04:23,330
component let's take a look at the

00:04:20,810 --> 00:04:27,919
application so that's it we just have

00:04:23,330 --> 00:04:30,140
two lists of items we have a list for a

00:04:27,919 --> 00:04:32,540
sales department and at least for the

00:04:30,140 --> 00:04:35,300
R&D department in our organization

00:04:32,540 --> 00:04:38,660
and for each individual list item we

00:04:35,300 --> 00:04:40,210
have a name and a numeric value this

00:04:38,660 --> 00:04:43,790
numeric value goes through some heavy

00:04:40,210 --> 00:04:45,710
computation so it can go through

00:04:43,790 --> 00:04:46,940
whatever business specific competition

00:04:45,710 --> 00:04:50,120
you have in your application like

00:04:46,940 --> 00:04:52,280
standard deviation or whatever is make

00:04:50,120 --> 00:04:55,610
sense for you and also we can add new

00:04:52,280 --> 00:04:58,970
employees for instance here is Jason we

00:04:55,610 --> 00:05:03,680
can remove employees and so on and so

00:04:58,970 --> 00:05:06,190
forth so statically the application

00:05:03,680 --> 00:05:09,230
structure looks as follow we have our

00:05:06,190 --> 00:05:11,300
app here and it is built with two

00:05:09,230 --> 00:05:15,080
components with the app component and

00:05:11,300 --> 00:05:16,220
with the employee list component the app

00:05:15,080 --> 00:05:19,550
component wraps the entire application

00:05:16,220 --> 00:05:23,060
and it can it also hold some additional

00:05:19,550 --> 00:05:24,500
piece logic the employee list component

00:05:23,060 --> 00:05:26,810
wraps the individual Department in our

00:05:24,500 --> 00:05:29,590
our organization so it can wrap the

00:05:26,810 --> 00:05:33,380
sales department or the R&D department

00:05:29,590 --> 00:05:35,120
and the interesting thing which we

00:05:33,380 --> 00:05:38,000
already mentioned was that our app

00:05:35,120 --> 00:05:40,280
component holds the state so it is the

00:05:38,000 --> 00:05:41,900
container component and the employee

00:05:40,280 --> 00:05:44,510
this component just visualize it and

00:05:41,900 --> 00:05:47,420
just does some aggregation regarding the

00:05:44,510 --> 00:05:49,730
numeric value for the employee data so

00:05:47,420 --> 00:05:52,490
that's it and yeah I used a very

00:05:49,730 --> 00:05:54,470
simplified calculation I just mocked a

00:05:52,490 --> 00:05:56,270
business calculation in order to make

00:05:54,470 --> 00:05:58,700
sure that we are all familiar with the

00:05:56,270 --> 00:06:00,200
computation and in the same time it is

00:05:58,700 --> 00:06:02,660
implemented in a very inefficient manner

00:06:00,200 --> 00:06:03,740
so we can stress even further on the

00:06:02,660 --> 00:06:06,260
optimizations that we're going to

00:06:03,740 --> 00:06:09,320
perform so Fibonacci is actually not too

00:06:06,260 --> 00:06:11,060
far from real-world because it has very

00:06:09,320 --> 00:06:12,650
important characteristics that most

00:06:11,060 --> 00:06:15,200
calculations that we want to apply in

00:06:12,650 --> 00:06:18,080
our apps have we're going to stop on

00:06:15,200 --> 00:06:20,990
this in a little bit later so yeah that

00:06:18,080 --> 00:06:24,170
was the app it looks quite simple but

00:06:20,990 --> 00:06:27,320
let's add a little bit more data so we

00:06:24,170 --> 00:06:30,760
can just switch to the branch on push

00:06:27,320 --> 00:06:30,760
and optimized

00:06:32,450 --> 00:06:37,640
after the browser reloads we're going to

00:06:35,840 --> 00:06:41,240
see that we have few more items in fact

00:06:37,640 --> 00:06:44,350
we have 140 items so no that many and if

00:06:41,240 --> 00:06:50,590
we try to add a new employee

00:06:44,350 --> 00:06:50,590
yeah I'm typing right now still typing

00:06:52,420 --> 00:06:59,360
I'll stop alright yeah that was it so

00:06:55,640 --> 00:07:01,100
it's pretty slow and this is with a

00:06:59,360 --> 00:07:06,320
hundred and forty items there are not

00:07:01,100 --> 00:07:08,120
thousands yeah it is very slow obviously

00:07:06,320 --> 00:07:10,150
and it is interesting to see why it is

00:07:08,120 --> 00:07:13,790
that slow so we can use chrome dev tools

00:07:10,150 --> 00:07:19,940
we can just open the performance tab

00:07:13,790 --> 00:07:22,370
here I'll do and just start the

00:07:19,940 --> 00:07:23,540
recording let me let me rephrase because

00:07:22,370 --> 00:07:28,190
it's going to take less time than

00:07:23,540 --> 00:07:30,590
pressing backspace so once we start

00:07:28,190 --> 00:07:32,540
recording I will type several characters

00:07:30,590 --> 00:07:34,700
chrome dev tools here is going to make a

00:07:32,540 --> 00:07:37,130
recording of which functions are invoked

00:07:34,700 --> 00:07:39,410
how often do they do they get invoked

00:07:37,130 --> 00:07:41,690
and how long does it take them to their

00:07:39,410 --> 00:07:44,510
execution to complete after we press

00:07:41,690 --> 00:07:46,430
stop google chrome is going to just

00:07:44,510 --> 00:07:49,130
aggregate this data and show us what's

00:07:46,430 --> 00:07:52,640
going on so we can see that we spent a

00:07:49,130 --> 00:07:54,050
lot of time in scripting when we take a

00:07:52,640 --> 00:07:55,100
look at the bottom up top we're

00:07:54,050 --> 00:07:56,660
obviously going to see that our

00:07:55,100 --> 00:08:01,520
Fibonacci implementation gets involved

00:07:56,660 --> 00:08:03,140
far too often so let's see what is

00:08:01,520 --> 00:08:06,830
actually going on and why it gets

00:08:03,140 --> 00:08:09,140
involved that offand each time when the

00:08:06,830 --> 00:08:10,760
user presses a key on the keyboard we're

00:08:09,140 --> 00:08:13,220
going to invoke them multiple times to

00:08:10,760 --> 00:08:15,380
change detection for first the app

00:08:13,220 --> 00:08:18,410
component which is the root component in

00:08:15,380 --> 00:08:20,060
our app right after that we're going to

00:08:18,410 --> 00:08:21,530
perform the first traversal so we're

00:08:20,060 --> 00:08:23,840
going to go to the employee list

00:08:21,530 --> 00:08:25,670
component for the sales department we're

00:08:23,840 --> 00:08:27,860
going to compute the numeric value for

00:08:25,670 --> 00:08:30,410
the first employee for the second

00:08:27,860 --> 00:08:32,570
employee and so on and so forth for all

00:08:30,410 --> 00:08:34,010
the employees in the lists we're going

00:08:32,570 --> 00:08:36,200
to do the exact same thing for the other

00:08:34,010 --> 00:08:38,270
department so we're just typing

00:08:36,200 --> 00:08:40,340
something into the textbox but the

00:08:38,270 --> 00:08:42,470
change detection gets invoked for each

00:08:40,340 --> 00:08:44,320
individual component although there are

00:08:42,470 --> 00:08:47,089
obviously no changes

00:08:44,320 --> 00:08:49,070
so what we would want to do is to invoke

00:08:47,089 --> 00:08:51,230
the change detection for each individual

00:08:49,070 --> 00:08:53,000
employee in the list only when we get a

00:08:51,230 --> 00:08:54,710
new list right it makes sense because

00:08:53,000 --> 00:08:56,510
otherwise we have already computed this

00:08:54,710 --> 00:08:59,180
data so we don't want to recompute it

00:08:56,510 --> 00:09:00,589
but if we get a new list of employees we

00:08:59,180 --> 00:09:02,980
would want to go through each individual

00:09:00,589 --> 00:09:05,720
employee and recompute this data again

00:09:02,980 --> 00:09:08,180
so we can use on push yeah that's a very

00:09:05,720 --> 00:09:10,850
popular optimization practice that we

00:09:08,180 --> 00:09:12,529
can apply in our applications and the

00:09:10,850 --> 00:09:14,630
on-post change detection strategy is

00:09:12,529 --> 00:09:16,670
going to help us in a way that it is

00:09:14,630 --> 00:09:19,550
going to trigger the change detection in

00:09:16,670 --> 00:09:23,450
component when this component receives a

00:09:19,550 --> 00:09:25,190
new input so when the component receives

00:09:23,450 --> 00:09:27,680
a new input for instance our Employee

00:09:25,190 --> 00:09:30,380
List component receives a new reference

00:09:27,680 --> 00:09:31,760
to an array of employee data objects

00:09:30,380 --> 00:09:34,820
we're going to trigger to change the

00:09:31,760 --> 00:09:36,110
tection there this means that passing a

00:09:34,820 --> 00:09:38,540
new reference is going to trigger the

00:09:36,110 --> 00:09:40,279
change detection so angular internal is

00:09:38,540 --> 00:09:42,950
performing is comparing the data

00:09:40,279 --> 00:09:44,810
structure of the current inputs and the

00:09:42,950 --> 00:09:48,050
previous inputs by using a reference

00:09:44,810 --> 00:09:51,680
check which is very fast it has constant

00:09:48,050 --> 00:09:54,110
complexity but it may require us to

00:09:51,680 --> 00:09:55,550
create a new reference of the RA right

00:09:54,110 --> 00:09:58,040
so this might not be extremely

00:09:55,550 --> 00:10:00,920
convenient for us this means that we may

00:09:58,040 --> 00:10:03,140
need to copy the entire RA in order to

00:10:00,920 --> 00:10:06,260
make sure that angular knows that we

00:10:03,140 --> 00:10:08,360
have added a new employee so this is not

00:10:06,260 --> 00:10:11,209
very convenient because it first is very

00:10:08,360 --> 00:10:14,029
slow we need to iterate over the initial

00:10:11,209 --> 00:10:16,100
list in order to copy all the items from

00:10:14,029 --> 00:10:17,930
it into the new one and right after that

00:10:16,100 --> 00:10:19,370
we're going to allocate a lot of

00:10:17,930 --> 00:10:23,540
additional memory which we really don't

00:10:19,370 --> 00:10:25,010
have to so we can use immutable J's for

00:10:23,540 --> 00:10:27,800
the purpose how many of you have

00:10:25,010 --> 00:10:30,380
actually used immutable J's alright a

00:10:27,800 --> 00:10:32,510
couple of you oh this is a technology by

00:10:30,380 --> 00:10:34,520
Facebook which implements a lot of

00:10:32,510 --> 00:10:37,089
immutable data structures in a smarter

00:10:34,520 --> 00:10:39,290
way so internally they are using

00:10:37,089 --> 00:10:42,800
persistent data structures with partial

00:10:39,290 --> 00:10:45,560
persistence and this has two important

00:10:42,800 --> 00:10:47,779
characteristics first we're going to get

00:10:45,560 --> 00:10:50,649
a new reference every time when we

00:10:47,779 --> 00:10:53,630
intend to apply a mutation on top of

00:10:50,649 --> 00:10:55,910
given instance of a data structure so we

00:10:53,630 --> 00:10:57,740
are adding a new list to our

00:10:55,910 --> 00:10:57,980
immutable list and we're going to get a

00:10:57,740 --> 00:10:59,810
new

00:10:57,980 --> 00:11:03,110
lists so the initial list is going to be

00:10:59,810 --> 00:11:05,630
unchanged and also we need to copy the

00:11:03,110 --> 00:11:06,950
entire data structure we don't need to

00:11:05,630 --> 00:11:08,720
copy the entire data structure because

00:11:06,950 --> 00:11:11,050
internally immutable J's is reusing

00:11:08,720 --> 00:11:13,850
everything it can from the original list

00:11:11,050 --> 00:11:15,530
right so let's do some refactoring and

00:11:13,850 --> 00:11:18,920
right after that I'm going to show show

00:11:15,530 --> 00:11:22,960
the benchpress results so first what we

00:11:18,920 --> 00:11:22,960
need to do is import the immutable list

00:11:25,210 --> 00:11:40,160
from immutable and we need to change our

00:11:33,430 --> 00:11:42,110
employed data to use immutable lists we

00:11:40,160 --> 00:11:45,080
can we can see that we're getting an

00:11:42,110 --> 00:11:46,880
error here that's because a list and

00:11:45,080 --> 00:11:52,010
sales and tyranny here needs to be

00:11:46,880 --> 00:11:54,380
converted to immutable lists also the

00:11:52,010 --> 00:11:56,720
ads and the remove method needs to

00:11:54,380 --> 00:12:01,460
accept immutable lists now so we can

00:11:56,720 --> 00:12:03,440
just change this and that's it so there

00:12:01,460 --> 00:12:05,330
is something important to notice here I

00:12:03,440 --> 00:12:07,160
mentioned that when we mutate an

00:12:05,330 --> 00:12:09,950
immutable list we're going to get a new

00:12:07,160 --> 00:12:10,970
list and here we are not going to we are

00:12:09,950 --> 00:12:13,010
not doing anything with the new

00:12:10,970 --> 00:12:20,060
reference so we can just return it for

00:12:13,010 --> 00:12:22,340
now all right and we need to assign it

00:12:20,060 --> 00:12:25,100
to the already existing reference for

00:12:22,340 --> 00:12:29,390
the corresponding list so here we need

00:12:25,100 --> 00:12:33,670
to assign it to the sales list sales

00:12:29,390 --> 00:12:33,670
list again and here are in the list

00:12:37,520 --> 00:12:42,990
all right so now there is also one more

00:12:41,160 --> 00:12:45,149
change that we need to do so when we go

00:12:42,990 --> 00:12:47,670
to the employee list component we need

00:12:45,149 --> 00:12:51,500
to change its input data to be of the

00:12:47,670 --> 00:12:51,500
appropriate type in multiple lists

00:12:59,420 --> 00:13:03,170
and since we're using the length

00:13:01,430 --> 00:13:05,750
property of the RA we need to change its

00:13:03,170 --> 00:13:09,230
to size because that's what Dima - list

00:13:05,750 --> 00:13:10,760
uses alright and the final thing is just

00:13:09,230 --> 00:13:12,800
to change the change detection strategy

00:13:10,760 --> 00:13:19,850
of this component so we're using change

00:13:12,800 --> 00:13:24,590
detection change detection strategy dot

00:13:19,850 --> 00:13:28,490
on push cool let's see whether

00:13:24,590 --> 00:13:32,660
everything works everything seems fine

00:13:28,490 --> 00:13:40,730
now now yeah well we should have a very

00:13:32,660 --> 00:13:44,300
fast tap right I'm typing yeah it's not

00:13:40,730 --> 00:13:46,760
too fast isn't it so it was not even

00:13:44,300 --> 00:13:48,950
able to accept my first character I

00:13:46,760 --> 00:13:53,450
guess and when we remove items it is too

00:13:48,950 --> 00:13:55,070
very slow so on push I guess it is not

00:13:53,450 --> 00:13:57,170
it is not the only optimization that we

00:13:55,070 --> 00:13:58,760
need to apply right I didn't think

00:13:57,170 --> 00:14:01,100
initially that I have I have any

00:13:58,760 --> 00:14:02,930
performance improvement so I did some

00:14:01,100 --> 00:14:06,680
performance benchmarks with tank your

00:14:02,930 --> 00:14:10,070
benchpress and here is what I found it

00:14:06,680 --> 00:14:13,310
is at least twice faster but it is still

00:14:10,070 --> 00:14:14,990
very slow so we need to put a little bit

00:14:13,310 --> 00:14:17,780
more effort into this and see what is

00:14:14,990 --> 00:14:19,550
actually going on in order to do this

00:14:17,780 --> 00:14:22,100
let's just inspect it so let's go back

00:14:19,550 --> 00:14:28,850
to our list component and that one log

00:14:22,100 --> 00:14:30,410
statement so I'm just adding the log

00:14:28,850 --> 00:14:32,000
statement into the calculate method

00:14:30,410 --> 00:14:35,000
which is invoke for each individual

00:14:32,000 --> 00:14:36,500
employ in the list and just logging

00:14:35,000 --> 00:14:39,470
calculating and the name of the

00:14:36,500 --> 00:14:42,350
department so when I start typing

00:14:39,470 --> 00:14:43,580
something we can see that the sales

00:14:42,350 --> 00:14:45,470
department has been crazy

00:14:43,580 --> 00:14:46,880
we are recomputing the numeric values

00:14:45,470 --> 00:14:51,260
for each individual employee in the list

00:14:46,880 --> 00:14:52,730
when we are typing and the understanding

00:14:51,260 --> 00:14:54,020
of the Pampas change detection is that

00:14:52,730 --> 00:14:55,700
we're going to trigger the change

00:14:54,020 --> 00:14:58,820
detection when our component gets new

00:14:55,700 --> 00:15:00,680
inputs right this seems that is not

00:14:58,820 --> 00:15:03,440
exactly the case because we are not

00:15:00,680 --> 00:15:06,970
creating new lists of items so we are

00:15:03,440 --> 00:15:06,970
not changing any references

00:15:07,590 --> 00:15:10,620
well I was very interested for this

00:15:09,390 --> 00:15:12,960
going on so I took a look at the

00:15:10,620 --> 00:15:15,390
integration test of your core and I

00:15:12,960 --> 00:15:16,950
found out that anger is also going to

00:15:15,390 --> 00:15:18,360
invoke the change detection of a

00:15:16,950 --> 00:15:21,360
component with on push change detection

00:15:18,360 --> 00:15:23,880
strategy when an event instead of this

00:15:21,360 --> 00:15:26,550
component gets triggered so this wasn't

00:15:23,880 --> 00:15:29,130
something too obvious and I had to do

00:15:26,550 --> 00:15:30,420
some refactoring in order to fix it so

00:15:29,130 --> 00:15:32,880
here is a refactoring that we're going

00:15:30,420 --> 00:15:34,710
to do now we're going to decompose our

00:15:32,880 --> 00:15:38,880
employees components to the name input

00:15:34,710 --> 00:15:40,760
component and to the list component so

00:15:38,880 --> 00:15:42,690
our name input component is going to

00:15:40,760 --> 00:15:44,130
encapsulate all the events which are

00:15:42,690 --> 00:15:45,740
happening while we're typing something

00:15:44,130 --> 00:15:48,450
like the name of the new employee and

00:15:45,740 --> 00:15:50,460
the list component is going to use on

00:15:48,450 --> 00:15:52,680
push change detection strategy it is

00:15:50,460 --> 00:15:55,470
going to render the individual items and

00:15:52,680 --> 00:15:56,850
compute their numeric values so this way

00:15:55,470 --> 00:15:58,650
we're going to encapsulate all the

00:15:56,850 --> 00:16:01,110
events they're going to be insulated in

00:15:58,650 --> 00:16:02,460
the name input component because the

00:16:01,110 --> 00:16:04,260
name input component is sibling

00:16:02,460 --> 00:16:06,960
component of the list component so that

00:16:04,260 --> 00:16:09,200
the list component is going to be just

00:16:06,960 --> 00:16:12,720
not going to needs to recompute anything

00:16:09,200 --> 00:16:14,010
so let's do this and that's what we're

00:16:12,720 --> 00:16:15,030
going to explore what is actually going

00:16:14,010 --> 00:16:20,430
on in terms of change detection

00:16:15,030 --> 00:16:22,080
indication so first if you're following

00:16:20,430 --> 00:16:28,950
along in your virtual machine you can go

00:16:22,080 --> 00:16:30,630
to SRC app employee lists and here we

00:16:28,950 --> 00:16:34,110
want to use angular CLI to generates a

00:16:30,630 --> 00:16:39,120
new component so ng GC angular generate

00:16:34,110 --> 00:16:41,100
component name input keep in mind that

00:16:39,120 --> 00:16:44,580
we're adding a declaration of this

00:16:41,100 --> 00:16:45,960
component in the employee list module so

00:16:44,580 --> 00:16:49,050
we want to do the exact same thing for

00:16:45,960 --> 00:16:52,110
the list component so we have our two

00:16:49,050 --> 00:16:57,930
new components and we need to move some

00:16:52,110 --> 00:17:00,150
logic to them so our our list components

00:16:57,930 --> 00:17:02,370
needs to handle key key down events so

00:17:00,150 --> 00:17:04,860
our name component excuse me name input

00:17:02,370 --> 00:17:09,270
component so we can just move this logic

00:17:04,860 --> 00:17:11,100
to to this component we can remove only

00:17:09,270 --> 00:17:13,380
in its lifecycle cool because we don't

00:17:11,100 --> 00:17:15,240
need it and here cold weather complains

00:17:13,380 --> 00:17:16,589
that we're not following the convention

00:17:15,240 --> 00:17:19,679
in our application so we need to change

00:17:16,589 --> 00:17:20,310
the prefix of this component selector

00:17:19,679 --> 00:17:23,700
with

00:17:20,310 --> 00:17:27,830
d and we're also missing the ad output

00:17:23,700 --> 00:17:27,830
so we need to copy this output as well

00:17:34,040 --> 00:17:38,000
you need to import the event emitter and

00:17:35,960 --> 00:17:40,370
make sure that you import the correct

00:17:38,000 --> 00:17:42,340
event emitter from angular core because

00:17:40,370 --> 00:17:44,690
the first suggestion is from protractor

00:17:42,340 --> 00:17:48,080
alright so it seems that very good with

00:17:44,690 --> 00:17:51,830
the name input component let's go to and

00:17:48,080 --> 00:17:54,560
employ this component now and copy the

00:17:51,830 --> 00:18:00,380
template just move it to the name input

00:17:54,560 --> 00:18:01,670
components template right and we need to

00:18:00,380 --> 00:18:03,920
do the exact same thing for the list

00:18:01,670 --> 00:18:09,430
component so we're copying the material

00:18:03,920 --> 00:18:12,430
design list to list this component I

00:18:09,430 --> 00:18:14,900
mean we need to copy some logic as well

00:18:12,430 --> 00:18:19,010
so we need to copy the calculate method

00:18:14,900 --> 00:18:21,160
and we need to copy the remove output as

00:18:19,010 --> 00:18:21,160
well

00:18:40,870 --> 00:18:50,460
and finally Fibonacci and we no longer

00:18:47,080 --> 00:18:50,460
need the calculate method

00:18:54,559 --> 00:18:59,609
and now we need to add these components

00:18:57,629 --> 00:19:04,200
in the employee list components template

00:18:59,609 --> 00:19:08,820
so here we need to add the name input

00:19:04,200 --> 00:19:10,889
component which throws one output at and

00:19:08,820 --> 00:19:18,919
we need to trigger we need to handle it

00:19:10,889 --> 00:19:18,919
just by omitting the value that it rolls

00:19:22,070 --> 00:19:28,859
we need to do the same with the list

00:19:23,999 --> 00:19:39,570
component however here the output is

00:19:28,859 --> 00:19:42,960
removed and we have the data input so

00:19:39,570 --> 00:19:46,879
let's see whether this works all right

00:19:42,960 --> 00:19:46,879
the SD list is missing here

00:19:54,390 --> 00:19:57,590
always right here

00:20:02,150 --> 00:20:09,020
oh yeah you know I didn't edit the

00:20:05,140 --> 00:20:18,170
inputs of the list component so it is

00:20:09,020 --> 00:20:19,250
right here as well all right so the

00:20:18,170 --> 00:20:20,840
layout will be a little bit broken

00:20:19,250 --> 00:20:23,270
because we didn't move styles we're

00:20:20,840 --> 00:20:26,360
going to do this as well now let's move

00:20:23,270 --> 00:20:34,460
the styles from the material design form

00:20:26,360 --> 00:20:38,120
to the name input component and the rest

00:20:34,460 --> 00:20:43,730
of the styles we can move to the list

00:20:38,120 --> 00:20:45,770
component and this should look a little

00:20:43,730 --> 00:20:46,910
bit better after we refresh and there is

00:20:45,770 --> 00:20:48,740
one final optimizations that

00:20:46,910 --> 00:20:50,630
optimisation that we need to perform

00:20:48,740 --> 00:20:52,130
we haven't actually changed the change

00:20:50,630 --> 00:21:01,930
detection of the list components to use

00:20:52,130 --> 00:21:05,990
on push all right we can save this and

00:21:01,930 --> 00:21:08,710
now we can start typing yeah it's so

00:21:05,990 --> 00:21:08,710
much faster right

00:21:10,210 --> 00:21:13,369
[Applause]

00:21:14,090 --> 00:21:18,910
so in fact that's how much faster it is

00:21:20,230 --> 00:21:25,040
and here is what is going on every time

00:21:23,450 --> 00:21:26,660
when we start typing something we're

00:21:25,040 --> 00:21:29,060
triggering the change detection strategy

00:21:26,660 --> 00:21:30,790
in the app component after that we are

00:21:29,060 --> 00:21:33,260
going to employ this component and

00:21:30,790 --> 00:21:35,120
everything stops here this happens

00:21:33,260 --> 00:21:37,220
because the name input component is

00:21:35,120 --> 00:21:38,240
inside of the employee list component so

00:21:37,220 --> 00:21:40,600
we are triggering the change detection

00:21:38,240 --> 00:21:42,560
in the employers component as well

00:21:40,600 --> 00:21:44,070
eventually if we remove the own push

00:21:42,560 --> 00:21:45,490
change detection strategy from the

00:21:44,070 --> 00:21:47,750
[Music]

00:21:45,490 --> 00:21:50,060
employee this component we may invoke

00:21:47,750 --> 00:21:51,350
the change detection also in the

00:21:50,060 --> 00:21:53,590
employer list component for the R&D

00:21:51,350 --> 00:21:56,300
department but this will happen only

00:21:53,590 --> 00:21:58,700
when if we want to do that I mean we

00:21:56,300 --> 00:22:00,050
don't have to but also the computations

00:21:58,700 --> 00:22:01,820
happening in the employers components

00:22:00,050 --> 00:22:03,290
are very lights so if we invoke the

00:22:01,820 --> 00:22:06,380
change detection there it's not going to

00:22:03,290 --> 00:22:10,940
be a big deal yeah so we saw how fast it

00:22:06,380 --> 00:22:17,330
is but let's see how how quickly we are

00:22:10,940 --> 00:22:20,240
adding new items so my machine is quite

00:22:17,330 --> 00:22:22,670
fast actually but let's set the log

00:22:20,240 --> 00:22:24,980
statements to see what is going on there

00:22:22,670 --> 00:22:27,710
is still some delay with which is about

00:22:24,980 --> 00:22:32,600
100 milliseconds eventually so we can

00:22:27,710 --> 00:22:36,400
add log statements we just says

00:22:32,600 --> 00:22:36,400
calculating and that's it

00:22:38,220 --> 00:22:42,299
so we're adding now when we are typing

00:22:40,799 --> 00:22:43,950
nothing happens because of the

00:22:42,299 --> 00:22:46,620
optimization that we just did but when

00:22:43,950 --> 00:22:48,990
we press ENTER now we are calculating a

00:22:46,620 --> 00:22:51,899
lot of values in fact there are exactly

00:22:48,990 --> 00:22:53,669
71 we are calculating and the value for

00:22:51,899 --> 00:22:55,230
the new employee and all the remaining

00:22:53,669 --> 00:22:57,120
all the other employees from the list

00:22:55,230 --> 00:22:58,950
although we have already calculated

00:22:57,120 --> 00:23:01,500
their value so it doesn't really make

00:22:58,950 --> 00:23:03,840
sense to recompute them right but that's

00:23:01,500 --> 00:23:06,539
how the anchor change detection works if

00:23:03,840 --> 00:23:11,309
you're just going to take a look at so

00:23:06,539 --> 00:23:14,399
first let's go to the diagram we're

00:23:11,309 --> 00:23:15,929
going to add a new element we're going

00:23:14,399 --> 00:23:18,659
to throw we're going to trigger a change

00:23:15,929 --> 00:23:19,529
detection in the app component the

00:23:18,659 --> 00:23:21,230
change detection is going to be

00:23:19,529 --> 00:23:24,000
triggered in the employee list component

00:23:21,230 --> 00:23:25,950
after that in the list component because

00:23:24,000 --> 00:23:27,960
we have gotten a new reference right we

00:23:25,950 --> 00:23:30,090
have added a new element so we have

00:23:27,960 --> 00:23:31,950
created a new immutable list which we

00:23:30,090 --> 00:23:34,529
are passing as an inputs to the list

00:23:31,950 --> 00:23:36,389
component so the list components change

00:23:34,529 --> 00:23:38,330
station gets triggered because it has

00:23:36,389 --> 00:23:41,789
received a new reference for its list

00:23:38,330 --> 00:23:43,559
first its input and this is going to

00:23:41,789 --> 00:23:45,870
recompute the numeric values for each

00:23:43,559 --> 00:23:50,399
individual employee in the list because

00:23:45,870 --> 00:23:53,700
we're going to just recollect calls in

00:23:50,399 --> 00:23:57,240
the ng four in the template so this is

00:23:53,700 --> 00:23:59,429
not too practical we're wrecking

00:23:57,240 --> 00:24:01,169
everything every time when we add a new

00:23:59,429 --> 00:24:03,169
item and this is definitely not

00:24:01,169 --> 00:24:05,039
something that we would want to do

00:24:03,169 --> 00:24:06,690
instead we can take a look at the

00:24:05,039 --> 00:24:09,090
characteristics of the Fibonacci

00:24:06,690 --> 00:24:11,039
implementation I mentioned that it has

00:24:09,090 --> 00:24:12,690
very important properties which are

00:24:11,039 --> 00:24:16,559
common for most business calculations

00:24:12,690 --> 00:24:19,110
that we are performing right so first it

00:24:16,559 --> 00:24:21,240
does not perform any side effects this

00:24:19,110 --> 00:24:24,000
means that inside of the function we are

00:24:21,240 --> 00:24:25,470
not sending Network requests and we're

00:24:24,000 --> 00:24:27,629
not touching local storage

00:24:25,470 --> 00:24:30,779
we are not logging anything into the

00:24:27,629 --> 00:24:32,700
console and it returns the exact same

00:24:30,779 --> 00:24:35,220
result when applies to the same set of

00:24:32,700 --> 00:24:36,960
arguments so it even doesn't hold

00:24:35,220 --> 00:24:39,539
internal states which is completely

00:24:36,960 --> 00:24:43,889
stateless and it just receives an input

00:24:39,539 --> 00:24:45,480
and returns an output that's it so

00:24:43,889 --> 00:24:48,629
functions like this are called pure

00:24:45,480 --> 00:24:50,580
functions and in angular we have a

00:24:48,629 --> 00:24:52,549
concept which is inspired from for pure

00:24:50,580 --> 00:24:55,500
functions these are the pure pie

00:24:52,549 --> 00:24:57,480
pipes I guess you're mostly familiar

00:24:55,500 --> 00:25:00,029
with them they're used for just data

00:24:57,480 --> 00:25:02,909
processing they can be either pure or

00:25:00,029 --> 00:25:05,070
impure and the pure pipes are kind of

00:25:02,909 --> 00:25:06,360
the alternative of functions they're

00:25:05,070 --> 00:25:08,010
kind of inspired from them

00:25:06,360 --> 00:25:09,870
so there are stateless and then you

00:25:08,010 --> 00:25:11,610
realize that the pure functions are

00:25:09,870 --> 00:25:13,620
always always going to return the exact

00:25:11,610 --> 00:25:17,010
same output when you walk through the

00:25:13,620 --> 00:25:19,740
same input an example for a pure pipe is

00:25:17,010 --> 00:25:22,080
the date pipe let's say an impure pipe

00:25:19,740 --> 00:25:24,210
is the sink pipe which some holds some

00:25:22,080 --> 00:25:25,860
state internally so it can hold a

00:25:24,210 --> 00:25:30,559
reference to the pro to a promise or an

00:25:25,860 --> 00:25:33,059
observable so it is not a pure pipe and

00:25:30,559 --> 00:25:35,639
angular can perform an optimization with

00:25:33,059 --> 00:25:38,120
pure pipes it can it is going to invoke

00:25:35,639 --> 00:25:42,120
a pure pipe only when it detects changes

00:25:38,120 --> 00:25:44,399
inside of the pipes inputs input values

00:25:42,120 --> 00:25:46,169
so again only a reference check is going

00:25:44,399 --> 00:25:48,899
to be performed angular is not going to

00:25:46,169 --> 00:25:51,149
do like shell it's not going to compare

00:25:48,899 --> 00:25:53,970
the values with a shallow like search or

00:25:51,149 --> 00:25:57,750
you know it's in depth it is just going

00:25:53,970 --> 00:26:00,240
to be a reference check so we can take

00:25:57,750 --> 00:26:04,169
advantage of these pure pipes we can

00:26:00,240 --> 00:26:09,659
just open angular CLI again and generate

00:26:04,169 --> 00:26:13,500
a new pipe ng g P this time and go it

00:26:09,659 --> 00:26:15,269
with the creative min calculate so when

00:26:13,500 --> 00:26:16,679
we create the calculated pipe this is

00:26:15,269 --> 00:26:22,470
going to add a new declaration in the

00:26:16,679 --> 00:26:26,990
Employee List module we can just go to

00:26:22,470 --> 00:26:30,210
them to the list component now we can

00:26:26,990 --> 00:26:32,850
copy just cut that the Fibonacci

00:26:30,210 --> 00:26:35,820
implementation now you can see if and

00:26:32,850 --> 00:26:38,399
move it to the pipe implementation right

00:26:35,820 --> 00:26:41,720
here just for completeness we can just

00:26:38,399 --> 00:26:45,210
set the pure flag to true by default

00:26:41,720 --> 00:26:47,250
pipes which really clear our pure so the

00:26:45,210 --> 00:26:48,960
default value of the flag is true but

00:26:47,250 --> 00:26:53,880
this is just more explicit and maybe

00:26:48,960 --> 00:26:56,130
more obvious and now we can invoke the

00:26:53,880 --> 00:26:57,870
Fibonacci implementation and the final

00:26:56,130 --> 00:27:00,629
thing is to go to the list components

00:26:57,870 --> 00:27:05,629
template remove the calculate invocation

00:27:00,629 --> 00:27:05,629
and replace it with the calculate pipe

00:27:08,610 --> 00:27:14,020
all right well now adding items will be

00:27:11,290 --> 00:27:16,630
faster maybe not noticeably faster but

00:27:14,020 --> 00:27:19,420
we can add one log statement just to see

00:27:16,630 --> 00:27:29,160
what is going on there so here we can

00:27:19,420 --> 00:27:29,160
lock lock calculating with the value

00:27:32,700 --> 00:27:37,990
we're adding can employ and we're

00:27:34,900 --> 00:27:39,820
calculating Fibonacci of 26 so we're not

00:27:37,990 --> 00:27:43,510
rekt computing already existing values

00:27:39,820 --> 00:27:45,340
this is because angular treats such

00:27:43,510 --> 00:27:47,860
expressions which are containing only

00:27:45,340 --> 00:27:49,930
pure pipes as referential it transparent

00:27:47,860 --> 00:27:52,090
this is a concept from functional

00:27:49,930 --> 00:27:54,430
programming which means that if given

00:27:52,090 --> 00:27:57,100
expression performs insignificant side

00:27:54,430 --> 00:27:59,980
effect or no side effect at all if we

00:27:57,100 --> 00:28:02,440
replace the expression with the value

00:27:59,980 --> 00:28:03,730
that it produces the semantics or the

00:28:02,440 --> 00:28:06,520
meaning of the program will not change

00:28:03,730 --> 00:28:09,000
so what angular does is that when it

00:28:06,520 --> 00:28:11,680
finds that we have invoked previously

00:28:09,000 --> 00:28:14,140
punitive 27 it is just not going to

00:28:11,680 --> 00:28:16,420
invoke the expression again because we

00:28:14,140 --> 00:28:18,910
haven't changed the input of 27 we're

00:28:16,420 --> 00:28:20,650
just going to reuse the result and the

00:28:18,910 --> 00:28:23,050
change and the semantics or the meaning

00:28:20,650 --> 00:28:25,980
of our program will not change so this

00:28:23,050 --> 00:28:29,890
is why we can use pure pipes right so

00:28:25,980 --> 00:28:31,930
it's faster now for sure let me take a

00:28:29,890 --> 00:28:35,380
look at the results from the benchpress

00:28:31,930 --> 00:28:36,970
benchmarks yeah so we're a couple of

00:28:35,380 --> 00:28:38,530
times like a couple of hundreds of times

00:28:36,970 --> 00:28:40,870
faster again just by using pure pipes

00:28:38,530 --> 00:28:43,030
and that was a very simple optimization

00:28:40,870 --> 00:28:48,310
right everybody can do this just move

00:28:43,030 --> 00:28:51,550
your pure calculations to pure pipes but

00:28:48,310 --> 00:28:55,030
if we take a look at our data we can see

00:28:51,550 --> 00:28:58,060
that we have basically values from small

00:28:55,030 --> 00:29:02,170
range so here we have Fibonacci of

00:28:58,060 --> 00:29:06,550
twenty seven several times we have even

00:29:02,170 --> 00:29:09,490
H of 28 and Fibonacci of 29 and angular

00:29:06,550 --> 00:29:11,320
is going to invoke it is going to

00:29:09,490 --> 00:29:14,050
evaluate all the all these pipe

00:29:11,320 --> 00:29:16,900
expressions so if it sees that we have

00:29:14,050 --> 00:29:18,010
several employees with numeric value of

00:29:16,900 --> 00:29:19,690
27 it is

00:29:18,010 --> 00:29:21,250
going to reuse the value which it has

00:29:19,690 --> 00:29:24,370
already computed it is going to

00:29:21,250 --> 00:29:26,380
recompute it every time but on the next

00:29:24,370 --> 00:29:28,420
tick of the change detection angular is

00:29:26,380 --> 00:29:30,880
not going to recompute these values

00:29:28,420 --> 00:29:33,820
because there are in the past two

00:29:30,880 --> 00:29:36,250
referential transparent expression so

00:29:33,820 --> 00:29:38,770
with this small sample with these values

00:29:36,250 --> 00:29:40,030
from a small sample we can do some

00:29:38,770 --> 00:29:41,890
caching in order to speed up our

00:29:40,030 --> 00:29:44,620
application even even further let me

00:29:41,890 --> 00:29:45,760
show you what I mean here so here is

00:29:44,620 --> 00:29:48,340
what happens during the initial

00:29:45,760 --> 00:29:49,990
rendering of the app you can see that we

00:29:48,340 --> 00:29:52,930
have multiple invocations of calc

00:29:49,990 --> 00:29:58,600
multiple locks of calculating with 20 of

00:29:52,930 --> 00:30:00,790
25 29 here and 28 and 27 so we are

00:29:58,600 --> 00:30:01,330
recommitting the same value all over

00:30:00,790 --> 00:30:03,430
again

00:30:01,330 --> 00:30:05,920
although we know that the result of

00:30:03,430 --> 00:30:09,340
invoking calculate of 29 is going to be

00:30:05,920 --> 00:30:11,670
always the same so if we have some

00:30:09,340 --> 00:30:13,870
global cache in terms of memoization

00:30:11,670 --> 00:30:15,610
which is only possible for pure

00:30:13,870 --> 00:30:19,600
functions we can speed up our

00:30:15,610 --> 00:30:21,310
application even further and in this

00:30:19,600 --> 00:30:22,720
case here is actually what the

00:30:21,310 --> 00:30:26,080
difference between memorization and tor

00:30:22,720 --> 00:30:28,390
pipes is going to be so with two pipes

00:30:26,080 --> 00:30:31,710
as I mentioned when anger sees calculate

00:30:28,390 --> 00:30:34,570
of 27 it is going to compute this value

00:30:31,710 --> 00:30:37,240
when it sees this this expression again

00:30:34,570 --> 00:30:40,290
calculates 27 it is going to compute the

00:30:37,240 --> 00:30:44,080
value again and same for each next time

00:30:40,290 --> 00:30:46,240
however with memoization if we have

00:30:44,080 --> 00:30:48,100
calculate of 27 we're going to compute

00:30:46,240 --> 00:30:52,690
the value but we're also going to

00:30:48,100 --> 00:30:55,570
associate it with another with the

00:30:52,690 --> 00:30:57,520
arguments of the function in a cache so

00:30:55,570 --> 00:31:00,520
we're going to associate the result of

00:30:57,520 --> 00:31:03,610
the computation with the input which is

00:31:00,520 --> 00:31:05,620
27 so in this cache 27 is going to be

00:31:03,610 --> 00:31:08,920
the key and the value is going to be the

00:31:05,620 --> 00:31:12,580
result of the computation the next time

00:31:08,920 --> 00:31:14,770
when with the same thing happens when we

00:31:12,580 --> 00:31:16,240
have calculate of 27 we're first going

00:31:14,770 --> 00:31:19,000
to take a look at the cache we're going

00:31:16,240 --> 00:31:21,850
to try to find whether we have 27 there

00:31:19,000 --> 00:31:24,640
if we do have 27 we're going to reuse

00:31:21,850 --> 00:31:29,440
the result from the cache and the same

00:31:24,640 --> 00:31:31,149
for the third calculation so before we

00:31:29,440 --> 00:31:35,830
go to server updates

00:31:31,149 --> 00:31:38,649
this very simple optimization so again

00:31:35,830 --> 00:31:44,619
here is how often the same calculation

00:31:38,649 --> 00:31:46,239
happens we have 29 several times and the

00:31:44,619 --> 00:31:47,919
memorization we can imply with a very

00:31:46,239 --> 00:31:56,289
simple decorator so we can just import

00:31:47,919 --> 00:31:59,409
memo from memo decorator and we can

00:31:56,289 --> 00:32:03,339
apply this memo decorator to our pure

00:31:59,409 --> 00:32:05,559
pipes transfer method and that's it we

00:32:03,339 --> 00:32:08,469
have cooked we have calculated 27 only

00:32:05,559 --> 00:32:11,190
once 28 only ones and the value from 29

00:32:08,469 --> 00:32:11,190
only ones as well

00:32:12,100 --> 00:32:18,159
[Applause]

00:32:14,590 --> 00:32:21,730
oh yeah so we don't have we haven't

00:32:18,159 --> 00:32:23,590
calculates 24 and 25 but yeah we're just

00:32:21,730 --> 00:32:25,659
not doing any redundant calculations now

00:32:23,590 --> 00:32:27,700
and this was only a matter of this

00:32:25,659 --> 00:32:28,960
simple decorator which you actually have

00:32:27,700 --> 00:32:32,350
already pre-installed on your virtual

00:32:28,960 --> 00:32:34,270
machines so memo memo decorator is the

00:32:32,350 --> 00:32:39,820
NPM package on NPM which we you can

00:32:34,270 --> 00:32:41,620
reuse and now the final part of the of

00:32:39,820 --> 00:32:45,400
this presentation of the session is to

00:32:41,620 --> 00:32:52,419
handle real-time updates so for the

00:32:45,400 --> 00:32:56,020
purpose you can you can first let's

00:32:52,419 --> 00:33:00,760
reset all the changes because we already

00:32:56,020 --> 00:33:06,159
have these seeds and switch to the

00:33:00,760 --> 00:33:09,029
server updates branch oh I have to

00:33:06,159 --> 00:33:09,029
remove the files here

00:33:14,100 --> 00:33:16,820
all right

00:33:19,680 --> 00:33:23,490
so in this branch here there is some

00:33:22,320 --> 00:33:25,200
additional piece of logic that we're

00:33:23,490 --> 00:33:27,210
going to take a look at in a second you

00:33:25,200 --> 00:33:31,580
can also go to the server directory and

00:33:27,210 --> 00:33:34,110
here by using TS notes run index dot yes

00:33:31,580 --> 00:33:35,880
all the required modules for the server

00:33:34,110 --> 00:33:38,310
on your virtual machines are already

00:33:35,880 --> 00:33:42,590
pre-installed so you should just run TS

00:33:38,310 --> 00:33:46,950
notes index dot yes

00:33:42,590 --> 00:33:48,990
and after we refresh we're going to see

00:33:46,950 --> 00:33:50,480
that we have very frequent live

00:33:48,990 --> 00:33:54,030
real-time updates from the server right

00:33:50,480 --> 00:33:55,560
so this has like several issues the most

00:33:54,030 --> 00:34:00,450
obvious one is that this is not very

00:33:55,560 --> 00:34:02,730
digestible from the user right just some

00:34:00,450 --> 00:34:05,340
things some stuff is free flickering on

00:34:02,730 --> 00:34:07,370
the screen and the second one we're

00:34:05,340 --> 00:34:10,040
going to take a look at that in a second

00:34:07,370 --> 00:34:13,040
after we do a very brief performance

00:34:10,040 --> 00:34:13,040
profiling

00:34:19,589 --> 00:34:25,169
so after a performance profiling loads

00:34:22,769 --> 00:34:27,179
we are going to see that we're actually

00:34:25,169 --> 00:34:28,979
spending a lot of time in some useless

00:34:27,179 --> 00:34:32,219
calculations which are not necessary for

00:34:28,979 --> 00:34:34,619
hemming updates in such Ryota real time

00:34:32,219 --> 00:34:37,109
manner so we were spending about

00:34:34,619 --> 00:34:39,329
one-fourth of the time in scripting one

00:34:37,109 --> 00:34:43,019
fourth in rendering and one fourth in

00:34:39,329 --> 00:34:45,299
painting like very roughly and this is

00:34:43,019 --> 00:34:47,599
definitely not a good idea so what we

00:34:45,299 --> 00:34:50,959
can do instead is to apply these

00:34:47,599 --> 00:34:54,539
real-time updates which are coming from

00:34:50,959 --> 00:34:56,639
this socket right here constantly what

00:34:54,539 --> 00:35:00,569
we can do instead is just to apply them

00:34:56,639 --> 00:35:02,459
on chunks so we can buffer updates for

00:35:00,569 --> 00:35:04,439
let's say one or two seconds and right

00:35:02,459 --> 00:35:06,420
after that apply all these different

00:35:04,439 --> 00:35:10,640
buffers commands which are coming from

00:35:06,420 --> 00:35:12,839
the server at once and there is usually

00:35:10,640 --> 00:35:14,910
often there is the needs to run code

00:35:12,839 --> 00:35:16,739
outside of the anger zone this time we

00:35:14,910 --> 00:35:18,779
don't really have to do that so we are

00:35:16,739 --> 00:35:19,859
not going to do anything too fancy we're

00:35:18,779 --> 00:35:22,140
just going to use some observable

00:35:19,859 --> 00:35:23,509
operators but before that let's take a

00:35:22,140 --> 00:35:25,949
look at the app module

00:35:23,509 --> 00:35:28,709
so in the app module we have one more

00:35:25,949 --> 00:35:34,289
provider now we have the employee

00:35:28,709 --> 00:35:36,660
service and the employee service it is

00:35:34,289 --> 00:35:38,789
creating a new observable from the

00:35:36,660 --> 00:35:40,920
WebSocket so we're creating a new

00:35:38,789 --> 00:35:44,729
WebSocket clients we're connecting it to

00:35:40,920 --> 00:35:46,910
a local host port 5 5 5 5 and we're

00:35:44,729 --> 00:35:50,269
after that exposing the observable

00:35:46,910 --> 00:35:55,559
through this get through this gather

00:35:50,269 --> 00:35:58,380
after that we're injecting this employee

00:35:55,559 --> 00:36:02,699
service into our app components and

00:35:58,380 --> 00:36:05,549
we're handling the updates real time in

00:36:02,699 --> 00:36:07,829
the NGO unit method so what we do just

00:36:05,549 --> 00:36:11,609
to subscribe to the command observable

00:36:07,829 --> 00:36:16,759
and handle the commands one by one what

00:36:11,609 --> 00:36:20,910
we can do instead is just to just pipe

00:36:16,759 --> 00:36:23,400
our commands observable and invoke the

00:36:20,910 --> 00:36:27,150
buffer operator here and so the buffer

00:36:23,400 --> 00:36:31,009
operator we can pass observable dots

00:36:27,150 --> 00:36:34,519
interval of let's say 200 milliseconds

00:36:31,009 --> 00:36:34,519
2,000 milliseconds

00:36:35,930 --> 00:36:39,480
after we save this we're going to see

00:36:38,040 --> 00:36:41,790
that we're getting a compile-time error

00:36:39,480 --> 00:36:43,650
here this is due the fact that all the

00:36:41,790 --> 00:36:47,160
different commands are already buffered

00:36:43,650 --> 00:36:50,430
so what is going to happen is that so

00:36:47,160 --> 00:36:52,530
the commands the commands observable is

00:36:50,430 --> 00:36:54,630
going to push different commands coming

00:36:52,530 --> 00:36:56,820
from the server which are for removing

00:36:54,630 --> 00:37:00,780
or adding an item to each one of the

00:36:56,820 --> 00:37:02,490
departments and these updates are going

00:37:00,780 --> 00:37:05,310
to be handled real-time however when we

00:37:02,490 --> 00:37:07,350
added the buffer operator or we're just

00:37:05,310 --> 00:37:09,390
going to start buffering them until the

00:37:07,350 --> 00:37:12,720
internal observable right here which is

00:37:09,390 --> 00:37:16,680
the interval observable triggers a value

00:37:12,720 --> 00:37:18,740
so each 200 2000 milliseconds here we're

00:37:16,680 --> 00:37:21,150
just going to trigger a new value and

00:37:18,740 --> 00:37:22,830
all the buffer cam commands to these

00:37:21,150 --> 00:37:25,020
points are going to be pushed to the

00:37:22,830 --> 00:37:28,320
callback which which we have passed to

00:37:25,020 --> 00:37:31,860
the SUBSCRIBE methods and that's it so

00:37:28,320 --> 00:37:35,460
there are an area of commands now so

00:37:31,860 --> 00:37:38,330
let's call them commands and let's just

00:37:35,460 --> 00:37:38,330
iterate over them

00:37:47,690 --> 00:37:51,980
so here it is so we are applying you

00:37:49,609 --> 00:37:54,140
updates every two seconds now it is

00:37:51,980 --> 00:37:55,160
maybe still not the best user experience

00:37:54,140 --> 00:38:00,440
possible

00:37:55,160 --> 00:38:02,240
but we are not at least like spamming

00:38:00,440 --> 00:38:04,430
the user with updates every 10

00:38:02,240 --> 00:38:06,410
milliseconds and on top of that when we

00:38:04,430 --> 00:38:07,640
run performance benchmarks we are

00:38:06,410 --> 00:38:09,440
definitely going to see that we have

00:38:07,640 --> 00:38:11,900
performance improvements because at

00:38:09,440 --> 00:38:13,760
least we're performing much less

00:38:11,900 --> 00:38:17,150
frequent updates right so we're going to

00:38:13,760 --> 00:38:18,440
spend much less time in rendering so

00:38:17,150 --> 00:38:20,950
yeah of course much less time in

00:38:18,440 --> 00:38:23,240
rendering in scripting can't in painting

00:38:20,950 --> 00:38:25,849
my point with this example was to show

00:38:23,240 --> 00:38:28,280
that it's not necessary to do super

00:38:25,849 --> 00:38:30,500
fancy updates running cold outside of

00:38:28,280 --> 00:38:32,930
the anger zone and something to

00:38:30,500 --> 00:38:35,030
angular-specific all the time there are

00:38:32,930 --> 00:38:37,400
some concepts such as buffering and

00:38:35,030 --> 00:38:40,930
caching which we can which we can apply

00:38:37,400 --> 00:38:43,520
in all different technologies and we can

00:38:40,930 --> 00:38:45,530
we don't have to do like reinvent the

00:38:43,520 --> 00:38:50,569
wheel this way so with the real-time

00:38:45,530 --> 00:38:52,010
updates we we got such performance

00:38:50,569 --> 00:38:55,220
improvement and also slight UX

00:38:52,010 --> 00:38:58,069
improvement so that was everything that

00:38:55,220 --> 00:38:59,750
I had today and I'm actually happy to

00:38:58,069 --> 00:39:04,180
announce that that was kind of the

00:38:59,750 --> 00:39:04,180
official release of rime as well so

00:39:09,600 --> 00:39:14,020
yeah so each one of you who was able to

00:39:11,890 --> 00:39:16,020
follow follow along and get a virtual

00:39:14,020 --> 00:39:18,310
machine is going to get I created for

00:39:16,020 --> 00:39:20,170
creating courses in ranked if they want

00:39:18,310 --> 00:39:23,920
here we really have to hear your

00:39:20,170 --> 00:39:26,110
feedback about your experience here are

00:39:23,920 --> 00:39:28,869
some links so I wrote a series of blog

00:39:26,110 --> 00:39:30,460
post about this these these topics there

00:39:28,869 --> 00:39:33,430
I'm going a little bit more in depth and

00:39:30,460 --> 00:39:36,670
a little bit more theory so you might be

00:39:33,430 --> 00:39:39,480
interested to take a look at this thank

00:39:36,670 --> 00:39:39,480
you very much for your attention

00:39:39,640 --> 00:39:46,550
[Applause]

00:39:44,490 --> 00:39:46,550

YouTube URL: https://www.youtube.com/watch?v=ybNj-id0kjY


