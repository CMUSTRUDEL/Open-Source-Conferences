Title: 3 NGRX tips when working with tree like shaped data | Ramiro Rivera | EnterpriseNG 2020 #ngconf
Publication date: 2021-02-02
Playlist: EnterpriseNG: Lightning Talks
Description: 
	ng-conf is a three-day Angular conference focused on delivering the highest quality training in the Angular JavaScript framework. 1500+ developers from across the globe converge on Salt Lake City, UT every year to attend talks and workshops by the Angular team and community experts.

Follow us on twitter https://twitter.com/ngconf
Official Website: https://www.ng-conf.org/
Captions: 
	00:00:04,710 --> 00:00:08,809
[Music]

00:00:14,880 --> 00:00:19,600
so

00:00:15,759 --> 00:00:20,400
the topic of my talk uh is ngrx tips for

00:00:19,600 --> 00:00:23,600
working with

00:00:20,400 --> 00:00:26,000
necessary data so first of all

00:00:23,600 --> 00:00:27,359
i'm a software engineer at a company

00:00:26,000 --> 00:00:30,320
called ida sync

00:00:27,359 --> 00:00:31,039
and we really really love all that's

00:00:30,320 --> 00:00:34,320
angular

00:00:31,039 --> 00:00:37,440
typescript and ngrx because how

00:00:34,320 --> 00:00:39,120
fast and performant it allows us to

00:00:37,440 --> 00:00:40,879
develop our apps so our clients are

00:00:39,120 --> 00:00:42,000
happy we are happy so everyone's happy

00:00:40,879 --> 00:00:44,960
you know

00:00:42,000 --> 00:00:47,039
and before getting started with it i

00:00:44,960 --> 00:00:49,600
wanted to give a big shout out to

00:00:47,039 --> 00:00:51,360
my friend alan who couldn't be here but

00:00:49,600 --> 00:00:54,800
he also helped me a lot to

00:00:51,360 --> 00:00:58,640
get this presentation together so

00:00:54,800 --> 00:01:02,480
with that said let's get started

00:00:58,640 --> 00:01:04,400
so what uh what do i mean with nested

00:01:02,480 --> 00:01:06,640
tree structures so

00:01:04,400 --> 00:01:08,720
there are there are mostly data that we

00:01:06,640 --> 00:01:10,159
get for example from a back end or from

00:01:08,720 --> 00:01:12,960
an api

00:01:10,159 --> 00:01:13,760
and it has like a recursive shape so

00:01:12,960 --> 00:01:15,920
each node

00:01:13,760 --> 00:01:17,759
or each element can have as many

00:01:15,920 --> 00:01:20,880
children as it wants and

00:01:17,759 --> 00:01:24,560
each children will then again

00:01:20,880 --> 00:01:25,119
share the same shape so we can think of

00:01:24,560 --> 00:01:27,040
that

00:01:25,119 --> 00:01:29,920
when we have for example a file system

00:01:27,040 --> 00:01:32,320
so we have folders and files we have

00:01:29,920 --> 00:01:33,920
a tree of course like each three node

00:01:32,320 --> 00:01:35,680
can have all its children and its

00:01:33,920 --> 00:01:40,240
children will have its

00:01:35,680 --> 00:01:43,439
its own children so on and so forth

00:01:40,240 --> 00:01:46,560
so when migrating some parts of our

00:01:43,439 --> 00:01:49,119
apps to ngrx we

00:01:46,560 --> 00:01:49,840
discovered that it just wasn't as

00:01:49,119 --> 00:01:53,600
performant

00:01:49,840 --> 00:01:56,479
as we thought if we just dumped the

00:01:53,600 --> 00:01:57,680
like the whole tree inside the store

00:01:56,479 --> 00:02:00,399
because

00:01:57,680 --> 00:02:01,600
any update as little as it was would

00:02:00,399 --> 00:02:04,880
then re-trigger

00:02:01,600 --> 00:02:06,640
our selectors are are stayed all our

00:02:04,880 --> 00:02:10,479
components with re-render and

00:02:06,640 --> 00:02:12,239
at some point we had some very big uh

00:02:10,479 --> 00:02:14,319
hierarchies that we wanted to show to

00:02:12,239 --> 00:02:16,000
the client and then just a small change

00:02:14,319 --> 00:02:17,360
like i know a highlighting or a

00:02:16,000 --> 00:02:20,480
notification

00:02:17,360 --> 00:02:23,920
would make the app feel really slow

00:02:20,480 --> 00:02:26,400
so so one way

00:02:23,920 --> 00:02:26,959
so here we have some example of what i

00:02:26,400 --> 00:02:29,280
mean so

00:02:26,959 --> 00:02:30,800
you have like a json which is deeply

00:02:29,280 --> 00:02:33,280
nested i've only gone

00:02:30,800 --> 00:02:36,160
i've only went to three levels and you

00:02:33,280 --> 00:02:38,480
can see that each node has a children

00:02:36,160 --> 00:02:39,440
so what we do for start what we did for

00:02:38,480 --> 00:02:42,640
starters

00:02:39,440 --> 00:02:45,599
was try to change the nested data

00:02:42,640 --> 00:02:46,000
to a flat structure it's very similar to

00:02:45,599 --> 00:02:49,280
what

00:02:46,000 --> 00:02:50,319
ngrx entity does where it hashes each

00:02:49,280 --> 00:02:53,599
element

00:02:50,319 --> 00:02:56,319
by its id so then we can find it

00:02:53,599 --> 00:02:58,159
faster once we need to get one from the

00:02:56,319 --> 00:03:02,879
store instead of having to

00:02:58,159 --> 00:03:02,879
loop through through all the array items

00:03:03,360 --> 00:03:08,000
so the three data i showed earlier we

00:03:06,400 --> 00:03:10,080
converted it to a three node

00:03:08,000 --> 00:03:11,680
and then we have a three node viewmodel

00:03:10,080 --> 00:03:15,040
which we will work with

00:03:11,680 --> 00:03:17,360
uh with our selectors so here we have

00:03:15,040 --> 00:03:19,519
this state we have a node property which

00:03:17,360 --> 00:03:22,159
holds all the nodes in a flat structure

00:03:19,519 --> 00:03:23,440
we have top level node ids which are

00:03:22,159 --> 00:03:25,680
like the root ids

00:03:23,440 --> 00:03:26,959
because some of our trees have more than

00:03:25,680 --> 00:03:29,280
one id

00:03:26,959 --> 00:03:31,680
more than one root element sorry and

00:03:29,280 --> 00:03:33,599
then we have a property that's children

00:03:31,680 --> 00:03:36,799
by parents so we have

00:03:33,599 --> 00:03:39,040
it's like a hash of each parent and

00:03:36,799 --> 00:03:41,120
its children id so we can find them even

00:03:39,040 --> 00:03:45,280
faster when we need to retrieve

00:03:41,120 --> 00:03:45,280
a node with each direct children

00:03:45,360 --> 00:03:49,840
then we want to optimize this a little

00:03:48,879 --> 00:03:52,159
bit further

00:03:49,840 --> 00:03:54,959
with some inspiration with uh tim's

00:03:52,159 --> 00:03:58,959
article about parameterized selectors

00:03:54,959 --> 00:04:02,080
so we built some selector factories

00:03:58,959 --> 00:04:04,400
uh basically by playing with this no

00:04:02,080 --> 00:04:06,159
all nodes property and this uh children

00:04:04,400 --> 00:04:10,080
by parent

00:04:06,159 --> 00:04:11,920
we can only run this selector

00:04:10,080 --> 00:04:13,120
sorry we can make that this selector

00:04:11,920 --> 00:04:15,120
only meets when

00:04:13,120 --> 00:04:16,720
either the node has changed so for

00:04:15,120 --> 00:04:19,919
example its name change

00:04:16,720 --> 00:04:21,519
uh its total the state change or its

00:04:19,919 --> 00:04:25,280
highlighted state or whatever change

00:04:21,519 --> 00:04:28,400
or when its children change so that way

00:04:25,280 --> 00:04:29,759
we can fire this selector only when any

00:04:28,400 --> 00:04:32,160
of those properties that

00:04:29,759 --> 00:04:33,520
are of interest to one of our components

00:04:32,160 --> 00:04:36,479
change

00:04:33,520 --> 00:04:37,520
and the last optimizations we did was to

00:04:36,479 --> 00:04:40,880
kind of keep

00:04:37,520 --> 00:04:42,400
uh like like a cache of all our

00:04:40,880 --> 00:04:45,440
selectors so

00:04:42,400 --> 00:04:46,880
the first time we need a selector for a

00:04:45,440 --> 00:04:49,040
given node

00:04:46,880 --> 00:04:51,360
we build we build it and we store it in

00:04:49,040 --> 00:04:54,080
a top level nodes property

00:04:51,360 --> 00:04:54,479
in one of our facets and then the next

00:04:54,080 --> 00:04:57,040
time

00:04:54,479 --> 00:04:58,880
a new component when you component

00:04:57,040 --> 00:05:02,400
request it we will just give it back

00:04:58,880 --> 00:05:02,800
the old selector which which will still

00:05:02,400 --> 00:05:05,120
have

00:05:02,800 --> 00:05:07,520
its cache value because all selectors

00:05:05,120 --> 00:05:10,560
get memoized

00:05:07,520 --> 00:05:15,360
so maybe if i show you in a

00:05:10,560 --> 00:05:15,360
small demo it can make a bit more sense

00:05:15,440 --> 00:05:19,520
i know if you can see the browser screen

00:05:22,840 --> 00:05:29,680
um can you sorry

00:05:26,160 --> 00:05:33,039
it says mini demo ah oh yeah then i've

00:05:29,680 --> 00:05:33,039
shared the wrong screen my bad

00:05:34,560 --> 00:05:39,840
and where is scrum i can find chrome

00:05:41,440 --> 00:05:46,320
there is sorry so

00:05:44,479 --> 00:05:48,400
here we have one of those trees i

00:05:46,320 --> 00:05:52,880
mentioned with all the

00:05:48,400 --> 00:05:55,520
nodes that are already loaded so

00:05:52,880 --> 00:05:56,800
if i'm toggling or i'm changing some

00:05:55,520 --> 00:05:58,639
properties

00:05:56,800 --> 00:06:00,319
i can see that this selector is only

00:05:58,639 --> 00:06:02,160
emitting new values

00:06:00,319 --> 00:06:04,000
for the nodes that actually change so

00:06:02,160 --> 00:06:06,160
for example the node one two four

00:06:04,000 --> 00:06:07,039
change from toggle to not toggled

00:06:06,160 --> 00:06:10,560
expanded to not

00:06:07,039 --> 00:06:14,080
expanded sorry but

00:06:10,560 --> 00:06:17,520
not not all the nodes change and even

00:06:14,080 --> 00:06:21,120
if my selectors are being rerun my

00:06:17,520 --> 00:06:23,520
smart and dumb components are not so

00:06:21,120 --> 00:06:25,440
i can actually reuse the selectors so

00:06:23,520 --> 00:06:28,080
the heaviest operation which is

00:06:25,440 --> 00:06:28,639
actually rendering the view i can save

00:06:28,080 --> 00:06:31,759
some

00:06:28,639 --> 00:06:34,080
cycles of rendering and so far

00:06:31,759 --> 00:06:34,880
that has proven to work really well for

00:06:34,080 --> 00:06:36,880
us uh

00:06:34,880 --> 00:06:38,479
our next we have some next steps like

00:06:36,880 --> 00:06:41,520
integrating this with

00:06:38,479 --> 00:06:41,919
angular material but we we just wanted

00:06:41,520 --> 00:06:44,000
to

00:06:41,919 --> 00:06:45,759
to take it slowly i have some time left

00:06:44,000 --> 00:06:48,400
i could show you some

00:06:45,759 --> 00:06:49,039
little snippets of code this is our

00:06:48,400 --> 00:06:51,840
smart

00:06:49,039 --> 00:06:52,800
trainer component we play along we we

00:06:51,840 --> 00:06:55,680
play a lot with that

00:06:52,800 --> 00:06:56,720
uh small and dumb components because it

00:06:55,680 --> 00:06:59,840
really helped us

00:06:56,720 --> 00:07:01,599
uh reason about

00:06:59,840 --> 00:07:03,280
what our components do and how they get

00:07:01,599 --> 00:07:05,360
their data and whatever

00:07:03,280 --> 00:07:06,639
so as i mentioned this component is

00:07:05,360 --> 00:07:08,080
getting a stream

00:07:06,639 --> 00:07:10,319
of all the no of all the node

00:07:08,080 --> 00:07:13,680
information for a particular node

00:07:10,319 --> 00:07:16,720
that it gets by an input variable

00:07:13,680 --> 00:07:17,440
and while it also handles expanding or

00:07:16,720 --> 00:07:21,120
collapsing

00:07:17,440 --> 00:07:24,479
that particular particular node

00:07:21,120 --> 00:07:26,800
and then we also have a

00:07:24,479 --> 00:07:27,680
dump component or a simple component

00:07:26,800 --> 00:07:30,400
which only

00:07:27,680 --> 00:07:30,880
receives this view model as an input and

00:07:30,400 --> 00:07:34,639
it just

00:07:30,880 --> 00:07:36,720
emits its event to signal the store when

00:07:34,639 --> 00:07:40,400
it's been toggled

00:07:36,720 --> 00:07:42,720
and of course each node each simple node

00:07:40,400 --> 00:07:45,759
so to call it

00:07:42,720 --> 00:07:47,759
will render as many smart three notes

00:07:45,759 --> 00:07:49,919
as it has for his children for its

00:07:47,759 --> 00:07:53,039
children so

00:07:49,919 --> 00:07:55,520
this way also allow us to

00:07:53,039 --> 00:07:57,199
to capitalize on angular's unchanged

00:07:55,520 --> 00:07:59,840
detection so

00:07:57,199 --> 00:08:01,120
both components have an on push change

00:07:59,840 --> 00:08:03,520
detection so

00:08:01,120 --> 00:08:05,199
on top of the store only a meeting when

00:08:03,520 --> 00:08:07,840
something really changed

00:08:05,199 --> 00:08:08,879
we have the components render when they

00:08:07,840 --> 00:08:10,560
really change so

00:08:08,879 --> 00:08:13,039
when they're destroyed for example i

00:08:10,560 --> 00:08:16,000
collapse or expanded some node

00:08:13,039 --> 00:08:17,680
or when the name changed or when

00:08:16,000 --> 00:08:19,759
something changed so

00:08:17,680 --> 00:08:21,919
as i mentioned so far this is working

00:08:19,759 --> 00:08:25,120
really nice as a proof of concept

00:08:21,919 --> 00:08:26,000
for us and yeah i just i just wanted to

00:08:25,120 --> 00:08:29,440
share with you guys

00:08:26,000 --> 00:08:31,840
and yeah really i also wanted to give

00:08:29,440 --> 00:08:34,000
thanks to of course the ngrx teams

00:08:31,840 --> 00:08:41,839
the ngrx team sorry for building such an

00:08:34,000 --> 00:08:41,839
amazing tool

00:08:42,560 --> 00:08:44,640

YouTube URL: https://www.youtube.com/watch?v=4YKrBTQykzA


