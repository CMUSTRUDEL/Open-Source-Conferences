Title: The Angular Compiler 4.0 - TOBIAS BOSCH
Publication date: 2017-04-06
Playlist: ng-conf 2017
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:02,389 --> 00:00:09,090
thank ok welcome to my talk about the

00:00:06,750 --> 00:00:13,500
angular compiler and especially what we

00:00:09,090 --> 00:00:16,470
changed in angular 4 in the inside so

00:00:13,500 --> 00:00:18,359
just a heads up this talk is about the

00:00:16,470 --> 00:00:21,060
internals of angular what the compiler

00:00:18,359 --> 00:00:23,430
does so it's not something a regular

00:00:21,060 --> 00:00:25,500
user needs to know but it might be

00:00:23,430 --> 00:00:28,289
interesting for you to know if you want

00:00:25,500 --> 00:00:31,949
to create PRS for angular or if you just

00:00:28,289 --> 00:00:34,350
want to know what's going on so you

00:00:31,949 --> 00:00:38,219
probably heard that you mentioned it in

00:00:34,350 --> 00:00:40,410
angular 4 we did something to make your

00:00:38,219 --> 00:00:42,690
application smaller and there were

00:00:40,410 --> 00:00:45,270
tweets about it okay I upgrade it to

00:00:42,690 --> 00:00:48,210
angular 4 and it reduced my bundle size

00:00:45,270 --> 00:00:52,440
from 2 megabytes of 1.38 megabytes

00:00:48,210 --> 00:00:54,530
that's cool right so so what actually

00:00:52,440 --> 00:00:57,120
happens underneath to understand that

00:00:54,530 --> 00:00:59,520
let's make a quick overview what the

00:00:57,120 --> 00:01:02,280
angular compiler does so the annual

00:00:59,520 --> 00:01:04,739
compiler takes all the metadata you

00:01:02,280 --> 00:01:06,689
write in form of decorators takes all

00:01:04,739 --> 00:01:09,450
your templates takes all your stylesheet

00:01:06,689 --> 00:01:13,049
and it analyzes them you can call this

00:01:09,450 --> 00:01:15,200
parsing then it builds a tree out of it

00:01:13,049 --> 00:01:18,509
it's called abstract syntax tree and

00:01:15,200 --> 00:01:20,790
from that tree it then creates

00:01:18,509 --> 00:01:22,950
typescript code if you use ahead of time

00:01:20,790 --> 00:01:25,310
compilation or JavaScript code if you

00:01:22,950 --> 00:01:29,100
use just-in-time compilation

00:01:25,310 --> 00:01:30,840
once we have that code then we take this

00:01:29,100 --> 00:01:33,060
code and this code actually instantiates

00:01:30,840 --> 00:01:35,369
your application later on like it it

00:01:33,060 --> 00:01:37,560
move puts everything together it's news

00:01:35,369 --> 00:01:40,790
up your components and it instantiates

00:01:37,560 --> 00:01:43,049
the templates so what we did we change

00:01:40,790 --> 00:01:45,810
this architecture did actually not

00:01:43,049 --> 00:01:48,329
change the things that we did change was

00:01:45,810 --> 00:01:50,820
the way we generate code what kind of

00:01:48,329 --> 00:01:54,740
code we generate and then later on how

00:01:50,820 --> 00:01:58,049
this code instantiates your application

00:01:54,740 --> 00:02:00,450
so let's let's make some simple examples

00:01:58,049 --> 00:02:03,840
to understand what's going on so let's

00:02:00,450 --> 00:02:06,509
assume we have a hello component and it

00:02:03,840 --> 00:02:08,849
uses a template like this so there's a

00:02:06,509 --> 00:02:10,470
an element inside a div as an attribute

00:02:08,849 --> 00:02:12,870
and a value

00:02:10,470 --> 00:02:15,390
and then we generate this kind of code

00:02:12,870 --> 00:02:17,700
so if you use add of time compilation

00:02:15,390 --> 00:02:21,660
you know these files that we generate

00:02:17,700 --> 00:02:24,090
they're called ng factory TF that's the

00:02:21,660 --> 00:02:27,660
file that we produce and they now

00:02:24,090 --> 00:02:30,240
contain a function per component they

00:02:27,660 --> 00:02:32,910
use the component name as prefix and a

00:02:30,240 --> 00:02:34,770
suffix in this case view and this

00:02:32,910 --> 00:02:36,930
function returns something it calls

00:02:34,770 --> 00:02:39,390
another function this case view depth

00:02:36,930 --> 00:02:42,200
that's a helper function which produces

00:02:39,390 --> 00:02:45,240
a plain old JavaScript object and that

00:02:42,200 --> 00:02:47,910
helper function or this data that's

00:02:45,240 --> 00:02:51,810
returned has a type and I'm going to put

00:02:47,910 --> 00:02:54,120
that type here on that side so the view

00:02:51,810 --> 00:02:56,450
death itself is just an object that

00:02:54,120 --> 00:02:59,910
contains a property called nodes and

00:02:56,450 --> 00:03:02,610
then inside of the view that we can put

00:02:59,910 --> 00:03:04,770
different nodes inside so one of them is

00:03:02,610 --> 00:03:06,930
an element you there's a helpful

00:03:04,770 --> 00:03:08,160
function element death which is again

00:03:06,930 --> 00:03:11,250
just creates a plain old JavaScript

00:03:08,160 --> 00:03:13,350
object and it has this shape so there's

00:03:11,250 --> 00:03:15,080
an element property inside name property

00:03:13,350 --> 00:03:16,980
on it and attributes on it

00:03:15,080 --> 00:03:19,230
we are using this helper function

00:03:16,980 --> 00:03:21,120
because that's actually shorter than to

00:03:19,230 --> 00:03:21,870
put the object literals there and it

00:03:21,120 --> 00:03:24,780
also minifides

00:03:21,870 --> 00:03:27,030
a lot nicer you can you could run this

00:03:24,780 --> 00:03:29,160
through ugly Phi or something it's just

00:03:27,030 --> 00:03:33,090
shorten these function names to a B and

00:03:29,160 --> 00:03:37,530
C and then it gets really compact okay

00:03:33,090 --> 00:03:39,810
so that element okay another thing you

00:03:37,530 --> 00:03:42,420
need to know about this is that the view

00:03:39,810 --> 00:03:45,390
definition for a component to only

00:03:42,420 --> 00:03:47,970
created once so per component class we

00:03:45,390 --> 00:03:50,610
create one view definition and then when

00:03:47,970 --> 00:03:53,190
we instantiate your component we create

00:03:50,610 --> 00:03:54,510
a so called view data out of it so the

00:03:53,190 --> 00:03:57,870
view data links to the view definition

00:03:54,510 --> 00:03:59,580
and it contains the runtime notes so if

00:03:57,870 --> 00:04:02,370
you have an element def you instantiate

00:03:59,580 --> 00:04:05,700
it you get out an HTML elements and so

00:04:02,370 --> 00:04:07,830
forth so we do this separation to make

00:04:05,700 --> 00:04:10,380
the many instances of your components

00:04:07,830 --> 00:04:11,820
relatively small in memory usage so

00:04:10,380 --> 00:04:13,590
everything we can we move into the

00:04:11,820 --> 00:04:15,810
definition where there's only one

00:04:13,590 --> 00:04:17,970
instance and everything else that needs

00:04:15,810 --> 00:04:20,330
to be created multiple times goes into

00:04:17,970 --> 00:04:20,330
view data

00:04:20,560 --> 00:04:24,910
that's simple let's have a look how do

00:04:22,720 --> 00:04:27,220
we represent a hierarchy of elements

00:04:24,910 --> 00:04:30,820
there various ways of representing trees

00:04:27,220 --> 00:04:32,260
we chose the following so we say view

00:04:30,820 --> 00:04:35,530
definition takes an array of nodes

00:04:32,260 --> 00:04:38,320
it's a depth-first order of nodes and

00:04:35,530 --> 00:04:41,260
the first argument to this element that

00:04:38,320 --> 00:04:43,120
is the number of children so if you

00:04:41,260 --> 00:04:46,210
think about it you've got a tree and if

00:04:43,120 --> 00:04:49,450
each node knows how many children it has

00:04:46,210 --> 00:04:51,790
transitively then you can put all the

00:04:49,450 --> 00:04:53,919
notes in an array and it still defines

00:04:51,790 --> 00:04:56,169
your tree in a unique way so then it's

00:04:53,919 --> 00:04:57,820
clear who's the child of whom and you

00:04:56,169 --> 00:05:00,430
can use that to instantiate your

00:04:57,820 --> 00:05:02,800
application in the right way so we have

00:05:00,430 --> 00:05:05,200
a new property child comes on the note

00:05:02,800 --> 00:05:05,970
def directives are a little more

00:05:05,200 --> 00:05:08,290
interesting

00:05:05,970 --> 00:05:10,150
so for directives you always have two

00:05:08,290 --> 00:05:12,400
things right you have a template in this

00:05:10,150 --> 00:05:15,280
case we've got an input and an attribute

00:05:12,400 --> 00:05:17,350
on it ng model and you have a class a

00:05:15,280 --> 00:05:19,960
class that's annotated with a directive

00:05:17,350 --> 00:05:22,330
as selector on it you might have di

00:05:19,960 --> 00:05:25,320
dependencies and your model in this case

00:05:22,330 --> 00:05:27,790
takes up an NG form as dependency and

00:05:25,320 --> 00:05:29,740
then our generated code looks like this

00:05:27,790 --> 00:05:32,260
there's another helper function called

00:05:29,740 --> 00:05:34,600
directive step let's let's ignore the

00:05:32,260 --> 00:05:36,280
three for now ng model is the

00:05:34,600 --> 00:05:39,010
constructor and ng form are the

00:05:36,280 --> 00:05:41,010
dependencies and this also these sugars

00:05:39,010 --> 00:05:43,390
into a plain old Java Script object

00:05:41,010 --> 00:05:47,440
that's noted here in the node definition

00:05:43,390 --> 00:05:50,650
with another attribute directive so what

00:05:47,440 --> 00:05:53,650
is this three how do we get to 3 1 plus

00:05:50,650 --> 00:05:55,900
2 is 3 right that's simple so it's

00:05:53,650 --> 00:05:57,820
related to lifecycle hooks so if you

00:05:55,900 --> 00:05:59,919
look at the real implementation of ng

00:05:57,820 --> 00:06:01,900
model it's actually more complicated

00:05:59,919 --> 00:06:04,270
it's not just a class with one

00:06:01,900 --> 00:06:06,310
constructor test lifecycle hooks and

00:06:04,270 --> 00:06:08,650
your own changes and your ondestroy

00:06:06,310 --> 00:06:10,870
and many other things but these

00:06:08,650 --> 00:06:12,520
lifecycle hooks we need to know so

00:06:10,870 --> 00:06:14,320
because it's something where angler

00:06:12,520 --> 00:06:18,070
calls you back when the component is

00:06:14,320 --> 00:06:21,910
destroyed or when changes happen and and

00:06:18,070 --> 00:06:24,760
that what we used is 3/4 we use a bitmap

00:06:21,910 --> 00:06:26,620
for we call the node flags which are

00:06:24,760 --> 00:06:29,560
interesting things to know about a node

00:06:26,620 --> 00:06:32,140
and then we just combine them and as the

00:06:29,560 --> 00:06:34,300
first bit we use on changes the second

00:06:32,140 --> 00:06:36,849
list is on destroy and if

00:06:34,300 --> 00:06:38,830
sum them up you get three right it's

00:06:36,849 --> 00:06:44,759
it's just a compact form of representing

00:06:38,830 --> 00:06:48,129
this again our goal this code size and

00:06:44,759 --> 00:06:50,560
the last part are bindings so let's say

00:06:48,129 --> 00:06:53,349
we have an anchor element and we bind to

00:06:50,560 --> 00:06:56,740
the HR property on it and we set some

00:06:53,349 --> 00:06:59,110
values some href on it then we generate

00:06:56,740 --> 00:07:01,930
the following code so element F takes

00:06:59,110 --> 00:07:04,030
another argument which is the names of

00:07:01,930 --> 00:07:06,729
the bound properties this case we bind

00:07:04,030 --> 00:07:11,319
href and our node F also takes a

00:07:06,729 --> 00:07:13,780
structure that stores that name the

00:07:11,319 --> 00:07:16,449
other piece we add is that a view

00:07:13,780 --> 00:07:18,219
definition has an update function this

00:07:16,449 --> 00:07:19,990
update function will be called on each

00:07:18,219 --> 00:07:22,690
change detection cycle of angular and

00:07:19,990 --> 00:07:23,789
you probably know change detection is

00:07:22,690 --> 00:07:26,560
something that happens very often

00:07:23,789 --> 00:07:29,259
whenever there's an event angular change

00:07:26,560 --> 00:07:31,150
detects all of your components so this

00:07:29,259 --> 00:07:33,909
means whatever we do in this closure

00:07:31,150 --> 00:07:35,169
down there should be better fast because

00:07:33,909 --> 00:07:40,479
otherwise it will slow down your home

00:07:35,169 --> 00:07:42,819
application and what we do there we we

00:07:40,479 --> 00:07:45,130
call a check function that we pass to

00:07:42,819 --> 00:07:47,349
the update function back with the values

00:07:45,130 --> 00:07:49,659
of the bindings so the update function

00:07:47,349 --> 00:07:52,120
gets the view data the component and

00:07:49,659 --> 00:07:54,340
this check function and then it calls

00:07:52,120 --> 00:07:57,069
the check function with a view data

00:07:54,340 --> 00:07:59,529
again with a node that contains the

00:07:57,069 --> 00:08:01,810
bindings the index of the node in this

00:07:59,529 --> 00:08:05,409
case there's just one node so indexes is

00:08:01,810 --> 00:08:07,599
0 and the values of the bindings in this

00:08:05,409 --> 00:08:09,819
case we only have one binding so there's

00:08:07,599 --> 00:08:11,289
just one value but essentially we take

00:08:09,819 --> 00:08:14,259
the expressions from your template and

00:08:11,289 --> 00:08:16,750
translate them one to translate them to

00:08:14,259 --> 00:08:18,250
one expression in JavaScript code it

00:08:16,750 --> 00:08:21,190
might get a little more complicated

00:08:18,250 --> 00:08:23,199
you see we added like comp dot before it

00:08:21,190 --> 00:08:25,270
because in JavaScript you need to have a

00:08:23,199 --> 00:08:27,129
context what you evaluate against

00:08:25,270 --> 00:08:29,319
otherwise you would read a global

00:08:27,129 --> 00:08:31,629
variable which you don't want in your

00:08:29,319 --> 00:08:33,339
template right like it's a little

00:08:31,629 --> 00:08:35,169
transform but one expressing your

00:08:33,339 --> 00:08:40,750
template becomes one expression in the

00:08:35,169 --> 00:08:43,400
generated code the last thing we need

00:08:40,750 --> 00:08:45,830
for bindings is

00:08:43,400 --> 00:08:47,960
the old values you probably know

00:08:45,830 --> 00:08:50,900
bindings and angular only fire if

00:08:47,960 --> 00:08:53,630
something changes so you have a binding

00:08:50,900 --> 00:08:55,940
on your directive or on the Dom we only

00:08:53,630 --> 00:08:57,920
said it if the value actually changed so

00:08:55,940 --> 00:09:00,440
we need a place to track the old values

00:08:57,920 --> 00:09:02,690
and we do that in the view data with an

00:09:00,440 --> 00:09:09,260
array of all the bindings of all the

00:09:02,690 --> 00:09:11,960
notes okay so what's the difference

00:09:09,260 --> 00:09:15,830
between angular two code generation and

00:09:11,960 --> 00:09:18,830
angular for code generation angler two

00:09:15,830 --> 00:09:21,680
we know before we know now let's make

00:09:18,830 --> 00:09:23,420
the example a little bigger let's say we

00:09:21,680 --> 00:09:25,760
have an input elements with an energy

00:09:23,420 --> 00:09:27,980
form binding previously we just had a

00:09:25,760 --> 00:09:29,900
property on it at just an attribute now

00:09:27,980 --> 00:09:32,090
we have a real binding on it an NG model

00:09:29,900 --> 00:09:33,980
has the lifecycle hooks as we said we've

00:09:32,090 --> 00:09:37,760
got a dependency and we've got an input

00:09:33,980 --> 00:09:40,520
property and your four looks like this

00:09:37,760 --> 00:09:43,340
the generated code so directive Steph

00:09:40,520 --> 00:09:45,020
also takes a fourth argument with the

00:09:43,340 --> 00:09:47,750
properties that are bound similar to

00:09:45,020 --> 00:09:51,440
element F and we have this one call for

00:09:47,750 --> 00:09:54,230
the check function angular 2 is a little

00:09:51,440 --> 00:09:57,050
bigger and it's a different principle if

00:09:54,230 --> 00:10:00,470
you think about it angular 2 we generate

00:09:57,050 --> 00:10:02,510
a class per template and in the

00:10:00,470 --> 00:10:04,940
constructor this class when we knew it

00:10:02,510 --> 00:10:07,400
up immediately creates all your elements

00:10:04,940 --> 00:10:09,680
all your directives and storage them in

00:10:07,400 --> 00:10:12,200
properties so that's a little different

00:10:09,680 --> 00:10:13,910
in anger for if I call this view

00:10:12,200 --> 00:10:16,250
definition or this function hello view

00:10:13,910 --> 00:10:18,950
it doesn't do anything it just produces

00:10:16,250 --> 00:10:21,860
data right there's nothing that happens

00:10:18,950 --> 00:10:23,690
compared to angular angular 2 when I

00:10:21,860 --> 00:10:27,710
knew this up things already start to

00:10:23,690 --> 00:10:30,500
happen angle to it it's also really nice

00:10:27,710 --> 00:10:33,080
that we don't use any erase there we

00:10:30,500 --> 00:10:34,550
don't use data structures like this is

00:10:33,080 --> 00:10:36,740
this is really good in terms of

00:10:34,550 --> 00:10:39,020
performance like maybe you saw my my

00:10:36,740 --> 00:10:41,570
talk and angular connect in last autumn

00:10:39,020 --> 00:10:43,430
I argued for it this is the way how

00:10:41,570 --> 00:10:46,940
everybody should do it should just use

00:10:43,430 --> 00:10:48,740
properties and no erase whatsoever it

00:10:46,940 --> 00:10:50,690
also has some nice features you can set

00:10:48,740 --> 00:10:53,660
breakpoints everywhere you see what

00:10:50,690 --> 00:10:54,930
happens it's really nice the only

00:10:53,660 --> 00:10:59,009
downside is it's

00:10:54,930 --> 00:11:01,019
right agree and that that's why we made

00:10:59,009 --> 00:11:05,670
this change to to this other

00:11:01,019 --> 00:11:09,509
architecture and in the end it's a

00:11:05,670 --> 00:11:10,829
trade-off but that we have here so if

00:11:09,509 --> 00:11:12,779
you think about performance in a more

00:11:10,829 --> 00:11:15,119
general sense there multiple metrics

00:11:12,779 --> 00:11:17,550
that you try to optimize so you've

00:11:15,119 --> 00:11:20,850
gotten the sighs I've got bootstrap time

00:11:17,550 --> 00:11:22,949
we've got routing time this means you

00:11:20,850 --> 00:11:25,019
have a view any application you destroy

00:11:22,949 --> 00:11:27,029
it you go to a different view and we've

00:11:25,019 --> 00:11:29,869
got update time this means those views

00:11:27,029 --> 00:11:32,189
days you just update all the values and

00:11:29,869 --> 00:11:33,899
usually what happens and what happened

00:11:32,189 --> 00:11:36,929
to us is we focused on one of these

00:11:33,899 --> 00:11:38,999
metrics for example update and we said

00:11:36,929 --> 00:11:41,100
ok let's make updates super fast and we

00:11:38,999 --> 00:11:44,759
ran with it but then other metrics

00:11:41,100 --> 00:11:46,980
suffrage and now we dialed this thing a

00:11:44,759 --> 00:11:50,009
little in a different direction to set a

00:11:46,980 --> 00:11:51,689
clear honor up to my size and if we

00:11:50,009 --> 00:11:54,949
regress in the others a little bit it's

00:11:51,689 --> 00:11:57,899
fine if you can make size a lot smaller

00:11:54,949 --> 00:12:01,230
as always these trade-offs that you want

00:11:57,899 --> 00:12:04,220
to make and how do we know that it's the

00:12:01,230 --> 00:12:08,399
right trade-offs so we have benchmarks

00:12:04,220 --> 00:12:10,079
so that I will show different benchmarks

00:12:08,399 --> 00:12:12,629
of different applications for these

00:12:10,079 --> 00:12:14,629
different aspects so the first is the

00:12:12,629 --> 00:12:17,429
size so that's an example application

00:12:14,629 --> 00:12:19,740
that we use internally you can see how

00:12:17,429 --> 00:12:22,110
the sides like varies over time this

00:12:19,740 --> 00:12:24,929
first bigger bump that was angular for

00:12:22,110 --> 00:12:27,689
release candidate 1 and this later bump

00:12:24,929 --> 00:12:30,420
was release candidate 3 so also before

00:12:27,689 --> 00:12:31,319
final so you see we didn't get it right

00:12:30,420 --> 00:12:32,819
the first time

00:12:31,319 --> 00:12:35,550
like there were increments that we had

00:12:32,819 --> 00:12:39,990
to do this application was improved by

00:12:35,550 --> 00:12:42,389
about 20% minified size it's not a it's

00:12:39,990 --> 00:12:45,029
not a lot but that's also using closure

00:12:42,389 --> 00:12:47,970
compiler if you were already using

00:12:45,029 --> 00:12:50,189
closure compiler externally you would

00:12:47,970 --> 00:12:52,379
see less impact of this change that we

00:12:50,189 --> 00:12:54,179
make because closure compiler is super

00:12:52,379 --> 00:12:56,519
good at optimizing your application like

00:12:54,179 --> 00:12:59,100
a dreams properties and everything but

00:12:56,519 --> 00:13:01,350
everybody externally uses ugly ideas

00:12:59,100 --> 00:13:03,059
probably or something similar which

00:13:01,350 --> 00:13:04,980
cannot rename properties and their this

00:13:03,059 --> 00:13:07,319
impact is a lot bigger for code size and

00:13:04,980 --> 00:13:08,760
this was also our goal to support users

00:13:07,319 --> 00:13:11,029
that don't use closure

00:13:08,760 --> 00:13:14,540
because it's really hard to use actually

00:13:11,029 --> 00:13:16,829
okay so we measured the size was good

00:13:14,540 --> 00:13:19,250
then we measured the bootstrap time for

00:13:16,829 --> 00:13:21,750
this application so bootstrap here is

00:13:19,250 --> 00:13:23,639
excluding Network time and excluding

00:13:21,750 --> 00:13:28,170
JavaScript time JavaScript parsing time

00:13:23,639 --> 00:13:30,209
so v8 parsed everything and then it

00:13:28,170 --> 00:13:32,760
created the first view how long did that

00:13:30,209 --> 00:13:34,709
take and as you can see there was no

00:13:32,760 --> 00:13:36,779
regression for this example app which is

00:13:34,709 --> 00:13:38,760
really cool like it was little

00:13:36,779 --> 00:13:40,230
counterintuitive I would have thought

00:13:38,760 --> 00:13:42,180
because we need to create these view

00:13:40,230 --> 00:13:44,639
definition objects right would take a

00:13:42,180 --> 00:13:46,920
little longer but it didn't what's

00:13:44,639 --> 00:13:49,019
interesting but like the best thing you

00:13:46,920 --> 00:13:51,209
can do to try something to optimize

00:13:49,019 --> 00:13:55,470
performance to benchmark and then you'll

00:13:51,209 --> 00:13:57,329
know so that's bootstrap routing times

00:13:55,470 --> 00:13:59,820
again that's destroying everything

00:13:57,329 --> 00:14:01,649
creating everything again we actually

00:13:59,820 --> 00:14:03,839
had a regression so the blue one is our

00:14:01,649 --> 00:14:07,290
baseline that's without using angular

00:14:03,839 --> 00:14:09,930
green that's an angular application and

00:14:07,290 --> 00:14:12,149
we regret from 40 milliseconds to 50

00:14:09,930 --> 00:14:15,959
milliseconds that's about 20% that's

00:14:12,149 --> 00:14:18,240
huge right but if we look at this

00:14:15,959 --> 00:14:21,089
application that's our so-called three

00:14:18,240 --> 00:14:24,110
benchmark the tree benchmark is the

00:14:21,089 --> 00:14:26,940
binary tree of depth 11 so we've got

00:14:24,110 --> 00:14:28,800
2048 nodes in components in there but

00:14:26,940 --> 00:14:31,980
they are super simple they just use

00:14:28,800 --> 00:14:33,029
itself recursively so there we have the

00:14:31,980 --> 00:14:34,589
regression so then we said let's

00:14:33,029 --> 00:14:37,199
actually look at a more complicated

00:14:34,589 --> 00:14:39,750
venture market the inches switch tree

00:14:37,199 --> 00:14:42,149
that's the same of the binary tree but

00:14:39,750 --> 00:14:44,040
using an entry switch in each component

00:14:42,149 --> 00:14:46,589
in there we actually did not see a

00:14:44,040 --> 00:14:48,959
regression and if we go to our example

00:14:46,589 --> 00:14:50,550
app which uses the real router to

00:14:48,959 --> 00:14:52,970
destroy some of you and create the other

00:14:50,550 --> 00:14:55,410
view we also did not have a regression

00:14:52,970 --> 00:14:57,540
so it's interesting so for very very

00:14:55,410 --> 00:14:59,490
simple components we have a regression

00:14:57,540 --> 00:15:01,920
but for more complex ones we don't and

00:14:59,490 --> 00:15:03,779
so we said okay that's probably okay if

00:15:01,920 --> 00:15:07,260
we get like a a big chunk of code size

00:15:03,779 --> 00:15:10,529
eliminated then that that's okay and for

00:15:07,260 --> 00:15:12,480
update it's the same story here we are

00:15:10,529 --> 00:15:15,899
actually faster than our baseline so

00:15:12,480 --> 00:15:17,699
blue is our baseline and green at the

00:15:15,899 --> 00:15:19,560
end with your application and you see we

00:15:17,699 --> 00:15:20,880
jump from six milliseconds to eight

00:15:19,560 --> 00:15:23,250
milliseconds

00:15:20,880 --> 00:15:25,500
that's also quite a bit this bump in

00:15:23,250 --> 00:15:27,329
between that reflection error in our

00:15:25,500 --> 00:15:30,720
measuring infrastructure so these are

00:15:27,329 --> 00:15:33,209
real numbers right it's not fake and we

00:15:30,720 --> 00:15:34,980
fixed it after we introduced the new

00:15:33,209 --> 00:15:38,339
engine and that's why I bumped up but

00:15:34,980 --> 00:15:39,959
like ignore this it started winter but

00:15:38,339 --> 00:15:42,829
there is the same story if you go to the

00:15:39,959 --> 00:15:45,420
ng-switch tree we also see this bump but

00:15:42,829 --> 00:15:48,959
ignoring that like there's no regression

00:15:45,420 --> 00:15:51,509
in there which is super cool right so to

00:15:48,959 --> 00:15:53,610
summarize we made a big impact on size

00:15:51,509 --> 00:15:56,389
that that you saw on Twitter and

00:15:53,610 --> 00:15:59,550
everywhere bootstrap time stays the same

00:15:56,389 --> 00:16:02,069
routing time stayed the same for

00:15:59,550 --> 00:16:04,259
non-trivial components that's why the

00:16:02,069 --> 00:16:07,380
star is there and update time the same

00:16:04,259 --> 00:16:13,620
for non-trivial components it should

00:16:07,380 --> 00:16:16,170
should be about the same what's next so

00:16:13,620 --> 00:16:18,089
the biggest thing that will change with

00:16:16,170 --> 00:16:20,519
the angular compiler is not the compiler

00:16:18,089 --> 00:16:22,380
itself but that we will make äôt the

00:16:20,519 --> 00:16:25,290
default ahead of time compilation was

00:16:22,380 --> 00:16:27,630
mentioned multiple times but we really

00:16:25,290 --> 00:16:29,310
believe that's the way to go to make

00:16:27,630 --> 00:16:31,079
this actually happen there are several

00:16:29,310 --> 00:16:33,449
things we need to do so

00:16:31,079 --> 00:16:35,610
one thing we need watch mode you

00:16:33,449 --> 00:16:38,040
probably know typescript you can run TS

00:16:35,610 --> 00:16:41,399
see - - watch we want to have the same

00:16:38,040 --> 00:16:43,380
for for our NGC so you can do NGC - -

00:16:41,399 --> 00:16:45,420
watch and integrate it with with our

00:16:43,380 --> 00:16:47,459
angular CLI like it should be immediate

00:16:45,420 --> 00:16:49,829
that you get the feedback so that's

00:16:47,459 --> 00:16:51,600
going to get a fast round-trip the next

00:16:49,829 --> 00:16:52,529
thing we need better error messages I

00:16:51,600 --> 00:16:54,779
agree with ants

00:16:52,529 --> 00:16:56,279
totally agree we should always have like

00:16:54,779 --> 00:16:58,740
source line source column of the thing

00:16:56,279 --> 00:17:02,939
you need to change and then the messages

00:16:58,740 --> 00:17:04,709
themselves should be better then another

00:17:02,939 --> 00:17:07,679
thing we will actually work on is type

00:17:04,709 --> 00:17:09,600
checking in templates so maybe you saw

00:17:07,679 --> 00:17:11,579
if you use ahead of time compilation and

00:17:09,600 --> 00:17:13,260
you misspelled the property then there

00:17:11,579 --> 00:17:16,020
will be a type check error in your ng

00:17:13,260 --> 00:17:18,270
factory file but if you're not an expert

00:17:16,020 --> 00:17:20,360
this doesn't tell you anything because

00:17:18,270 --> 00:17:22,439
like looking at these ng factory files

00:17:20,360 --> 00:17:25,049
you don't know like what angular does

00:17:22,439 --> 00:17:26,730
under the hood so we will change this to

00:17:25,049 --> 00:17:28,830
be a type checker that will report

00:17:26,730 --> 00:17:31,740
errors regarding your template so it

00:17:28,830 --> 00:17:34,110
will say line 2 column 3 in this in this

00:17:31,740 --> 00:17:36,570
HTML you made a mistake in that property

00:17:34,110 --> 00:17:38,610
and it will actually work with if you

00:17:36,570 --> 00:17:40,590
use typescript strict null checks it

00:17:38,610 --> 00:17:42,720
would also work with retinal checks so

00:17:40,590 --> 00:17:45,630
for example you say I have a Content

00:17:42,720 --> 00:17:47,460
child and it's not nullable and then if

00:17:45,630 --> 00:17:49,559
you use it uses your component and does

00:17:47,460 --> 00:17:51,750
not give you a child that matches you

00:17:49,559 --> 00:17:54,299
will get a type check error which is

00:17:51,750 --> 00:17:55,769
like super cool so so Chuck on our team

00:17:54,299 --> 00:18:00,600
he is working on that and it's super

00:17:55,769 --> 00:18:02,130
excited for that two more things so one

00:18:00,600 --> 00:18:04,890
is we want to make the metadata more

00:18:02,130 --> 00:18:06,450
flexible and I think everybody will use

00:18:04,890 --> 00:18:08,970
the äôt experience this you write a

00:18:06,450 --> 00:18:11,039
provider you say use factory you put a

00:18:08,970 --> 00:18:13,230
closure there and then your tea will

00:18:11,039 --> 00:18:15,779
complain because you it only allows

00:18:13,230 --> 00:18:17,090
top-level functions as factories but we

00:18:15,779 --> 00:18:21,149
will change it so you can actually use

00:18:17,090 --> 00:18:22,710
closures there and the last part we will

00:18:21,149 --> 00:18:25,200
actually remove the ng factory files

00:18:22,710 --> 00:18:27,299
altogether so we will change our

00:18:25,200 --> 00:18:30,169
compiled pipeline to inline them into

00:18:27,299 --> 00:18:32,880
your code while we while we compile it

00:18:30,169 --> 00:18:36,120
so and then in the end it like this

00:18:32,880 --> 00:18:38,039
matches the theme eager set this morning

00:18:36,120 --> 00:18:40,019
in the keynote will be a lot simpler to

00:18:38,039 --> 00:18:42,600
use the angular compiler it's less

00:18:40,019 --> 00:18:45,410
concepts you need to know it's just

00:18:42,600 --> 00:18:52,289
simpler to use thank you

00:18:45,410 --> 00:18:52,289

YouTube URL: https://www.youtube.com/watch?v=RXYjPYkFwy4


