Title: Mad science with the Angular Compiler - MINKO GECHEV
Publication date: 2017-04-06
Playlist: ng-conf 2017
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:03,650 --> 00:00:09,150
so hello everyone my name is Minka today

00:00:07,680 --> 00:00:12,509
I'm going to be talking about math

00:00:09,150 --> 00:00:15,599
science with the angular compiler so a

00:00:12,509 --> 00:00:17,789
couple of more words about me I'm quite

00:00:15,599 --> 00:00:18,960
active in the open source community few

00:00:17,789 --> 00:00:21,750
of the project I'm working on our

00:00:18,960 --> 00:00:23,760
angular speed cola Lizer I've been

00:00:21,750 --> 00:00:26,430
contributing to angular core and then

00:00:23,760 --> 00:00:27,779
your mobile toolkit also packs reason to

00:00:26,430 --> 00:00:30,390
publish the second edition of my book

00:00:27,779 --> 00:00:32,009
getting started with angular where I had

00:00:30,390 --> 00:00:34,200
the privilege to get technical review by

00:00:32,009 --> 00:00:35,520
Mitch to hear it so if you're just

00:00:34,200 --> 00:00:39,870
getting started we thank you you might

00:00:35,520 --> 00:00:41,550
be interested to give to try the today's

00:00:39,870 --> 00:00:44,219
talk is going to be about the compiler

00:00:41,550 --> 00:00:46,350
and what we can do with it so we're just

00:00:44,219 --> 00:00:48,360
going to take a look at four projects

00:00:46,350 --> 00:00:51,239
I've been working on over the past a

00:00:48,360 --> 00:00:52,920
couple of months and in order to get

00:00:51,239 --> 00:00:55,110
better context for how they work and

00:00:52,920 --> 00:00:57,960
what is their purpose let's see how what

00:00:55,110 --> 00:01:00,149
the compiler actually does and how it

00:00:57,960 --> 00:01:01,710
works internally in general the compiler

00:01:00,149 --> 00:01:03,660
is going to take our own and your

00:01:01,710 --> 00:01:05,700
application and it is going to transform

00:01:03,660 --> 00:01:08,970
it in a way that it is going to be more

00:01:05,700 --> 00:01:12,990
efficient in terms of bundle size or in

00:01:08,970 --> 00:01:14,549
terms of runtime performance so for

00:01:12,990 --> 00:01:16,950
instance the compiler is going to take

00:01:14,549 --> 00:01:19,259
this scalar component and out of this it

00:01:16,950 --> 00:01:21,689
is going to generate another class this

00:01:19,259 --> 00:01:23,880
plus is going to take care of things

00:01:21,689 --> 00:01:26,759
such as rendering the component in the

00:01:23,880 --> 00:01:29,310
most efficient way and also instantiated

00:01:26,759 --> 00:01:32,159
the components controller and choosing

00:01:29,310 --> 00:01:36,540
kids as a context for the change

00:01:32,159 --> 00:01:38,880
detection mechanism in short the

00:01:36,540 --> 00:01:41,159
compiler just is going to generate more

00:01:38,880 --> 00:01:43,530
efficient views and also more efficient

00:01:41,159 --> 00:01:44,610
provider instantiation so the individual

00:01:43,530 --> 00:01:46,770
providers they're going to be

00:01:44,610 --> 00:01:48,119
instantiated in the most efficient

00:01:46,770 --> 00:01:49,890
manner just by enlightening their

00:01:48,119 --> 00:01:53,880
dependencies instead of their factories

00:01:49,890 --> 00:01:56,460
or constructors in one words this is a

00:01:53,880 --> 00:01:57,810
transformation of our application but is

00:01:56,460 --> 00:01:58,610
that everything that we can do with the

00:01:57,810 --> 00:02:01,530
compiler

00:01:58,610 --> 00:02:02,969
well of course not we can also take the

00:02:01,530 --> 00:02:05,310
intermediate representation of the

00:02:02,969 --> 00:02:08,610
source code of our application that it

00:02:05,310 --> 00:02:10,319
produces and analyze it somehow or we

00:02:08,610 --> 00:02:12,540
can just visualize it in different ways

00:02:10,319 --> 00:02:13,930
we can afford to do much more but today

00:02:12,540 --> 00:02:17,200
we're going to focus on these two

00:02:13,930 --> 00:02:19,299
here but first of all let's answer the

00:02:17,200 --> 00:02:21,670
question how a compiler works in general

00:02:19,299 --> 00:02:22,599
because conceptually all compilers are

00:02:21,670 --> 00:02:24,400
pretty similar

00:02:22,599 --> 00:02:28,420
for instance the angular compiler

00:02:24,400 --> 00:02:30,040
performs similar fueler each has similar

00:02:28,420 --> 00:02:31,959
phases of processing our program

00:02:30,040 --> 00:02:34,450
compared to the typescript compiler and

00:02:31,959 --> 00:02:37,030
so on so a compiler where we can think

00:02:34,450 --> 00:02:39,579
of it as this blue box here it accepts

00:02:37,030 --> 00:02:41,290
some inputs and produces an output the

00:02:39,579 --> 00:02:44,530
inputs in case of the typescript

00:02:41,290 --> 00:02:46,269
compiler is going to be some typescript

00:02:44,530 --> 00:02:48,609
program like basket files and soul

00:02:46,269 --> 00:02:51,639
system just config the output is going

00:02:48,609 --> 00:02:54,250
to be JavaScript and on top of them some

00:02:51,639 --> 00:02:56,290
time declarations eventually if we

00:02:54,250 --> 00:02:58,150
magnify a little bit we will see that

00:02:56,290 --> 00:03:00,250
the compiler has a front end and the

00:02:58,150 --> 00:03:02,049
back end the front end it is usually

00:03:00,250 --> 00:03:04,329
responsible for processing our program

00:03:02,049 --> 00:03:06,340
and performing some transformations over

00:03:04,329 --> 00:03:08,079
intermediate form that we're going to

00:03:06,340 --> 00:03:10,000
take a look at and also the back end

00:03:08,079 --> 00:03:12,970
which takes this representation and

00:03:10,000 --> 00:03:14,260
generate some source code we're mostly

00:03:12,970 --> 00:03:16,120
going to be interested in the front end

00:03:14,260 --> 00:03:18,940
so here are the typical modules that you

00:03:16,120 --> 00:03:21,819
have if you it usually has a module for

00:03:18,940 --> 00:03:23,919
lexical analysis and image or for syntax

00:03:21,819 --> 00:03:25,629
analysis this may sound a little bit

00:03:23,919 --> 00:03:27,849
fancy first but it's actually something

00:03:25,629 --> 00:03:29,409
quite simple so we have our program

00:03:27,849 --> 00:03:32,109
which is nothing more than just a string

00:03:29,409 --> 00:03:34,690
we have the string constant production

00:03:32,109 --> 00:03:37,150
code say x B and so we're going to

00:03:34,690 --> 00:03:40,329
process it by using our function which

00:03:37,150 --> 00:03:42,790
implements the lexical analyzer it is

00:03:40,329 --> 00:03:45,310
going to produce a list or a stream of

00:03:42,790 --> 00:03:48,220
tokens where each token is an object

00:03:45,310 --> 00:03:50,409
with two properties like seam which sub

00:03:48,220 --> 00:03:52,659
strings of the program that this token

00:03:50,409 --> 00:03:55,150
represents and also a type which can be

00:03:52,659 --> 00:03:58,180
either a keyword an identifier operator

00:03:55,150 --> 00:04:00,519
literal or whatever we're going to take

00:03:58,180 --> 00:04:03,220
this output right now and pass it to the

00:04:00,519 --> 00:04:05,949
module for syntax analysis so out of it

00:04:03,220 --> 00:04:08,470
and out of some grammar the syntax

00:04:05,949 --> 00:04:10,540
analyzer is going to just produce a

00:04:08,470 --> 00:04:12,609
three this is just the abstract

00:04:10,540 --> 00:04:15,690
representation of our program which is

00:04:12,609 --> 00:04:19,150
called an AST or an abstract syntax tree

00:04:15,690 --> 00:04:21,400
it turns out that these trees they are

00:04:19,150 --> 00:04:24,340
very convenient for static code analysis

00:04:21,400 --> 00:04:26,229
and the static code analysis is some

00:04:24,340 --> 00:04:27,310
kind of program verification

00:04:26,229 --> 00:04:29,350
so we're basically able

00:04:27,310 --> 00:04:32,190
to prove that our program has some

00:04:29,350 --> 00:04:34,810
properties without running it just by

00:04:32,190 --> 00:04:37,570
taking a look at the source code for

00:04:34,810 --> 00:04:39,130
instance tools like Eastlands or geo

00:04:37,570 --> 00:04:42,250
sins and others they're doing this

00:04:39,130 --> 00:04:45,310
they're just parsing our source code and

00:04:42,250 --> 00:04:48,250
performing simulations up last year I

00:04:45,310 --> 00:04:50,740
present it to talk about collider which

00:04:48,250 --> 00:04:52,780
is a - which does something similar for

00:04:50,740 --> 00:04:55,900
angular and specifically for the style

00:04:52,780 --> 00:04:58,030
guide so it can prove that your program

00:04:55,900 --> 00:05:01,090
your software is somehow compatible yang

00:04:58,030 --> 00:05:02,530
your style guide well since then it

00:05:01,090 --> 00:05:05,100
scoped have grown a little bit

00:05:02,530 --> 00:05:07,570
but we're going to see how exactly

00:05:05,100 --> 00:05:10,090
internal equalizer uses the typescript

00:05:07,570 --> 00:05:11,860
compiler for producing for going through

00:05:10,090 --> 00:05:14,260
lexical analysis and TouchWiz index

00:05:11,860 --> 00:05:17,680
analysis just for producing KSC and it

00:05:14,260 --> 00:05:19,240
uses Uslan for reporting errors so let's

00:05:17,680 --> 00:05:21,880
see how with cold laser we can implement

00:05:19,240 --> 00:05:23,680
this style to the end your style guide

00:05:21,880 --> 00:05:27,580
that we need to use our all our

00:05:23,680 --> 00:05:30,160
components elements so first we're going

00:05:27,580 --> 00:05:32,770
to have our angular component which is

00:05:30,160 --> 00:05:34,240
just a string in the end we're going to

00:05:32,770 --> 00:05:36,940
pass the string to the module for

00:05:34,240 --> 00:05:38,800
lexical analysis of type script the

00:05:36,940 --> 00:05:41,169
function tokenize in this case it is

00:05:38,800 --> 00:05:42,669
going to do the list of tokens after

00:05:41,169 --> 00:05:44,890
that we're going to pass these tokens to

00:05:42,669 --> 00:05:47,650
the parser of size script and this is

00:05:44,890 --> 00:05:49,990
going to produce an ast which looks

00:05:47,650 --> 00:05:53,710
something like this not exactly but yet

00:05:49,990 --> 00:05:56,620
similar shape now in order to prove that

00:05:53,710 --> 00:05:58,510
our program has our power component has

00:05:56,620 --> 00:06:01,120
selector of the appropriate type we just

00:05:58,510 --> 00:06:02,979
needs to traverse this tree and the

00:06:01,120 --> 00:06:05,289
visitor pattern is very convenient for

00:06:02,979 --> 00:06:06,970
this so we can just first visit the

00:06:05,289 --> 00:06:09,039
rules node which is the club's element

00:06:06,970 --> 00:06:10,720
right after that we're going to go

00:06:09,039 --> 00:06:12,610
through all the individual decorators

00:06:10,720 --> 00:06:15,010
and it will turn out that one of these

00:06:12,610 --> 00:06:17,110
decorators is component we're going to

00:06:15,010 --> 00:06:19,389
extract the metadata out of the object

00:06:17,110 --> 00:06:21,700
literal pass to the component decorator

00:06:19,389 --> 00:06:24,520
and we're going to verify that the

00:06:21,700 --> 00:06:27,220
selector of the element here of the

00:06:24,520 --> 00:06:28,870
component is abstract element it is not

00:06:27,220 --> 00:06:31,960
we're just going to report the wording

00:06:28,870 --> 00:06:34,120
here is how this looks visually so we

00:06:31,960 --> 00:06:35,919
are visiting the class the rules nodes

00:06:34,120 --> 00:06:38,080
we're going to the decorator

00:06:35,919 --> 00:06:39,810
after that we're extracting the metadata

00:06:38,080 --> 00:06:41,970
the selector and the temple

00:06:39,810 --> 00:06:46,710
this case and in the end we're just

00:06:41,970 --> 00:06:48,680
going to throw a warning that's it now

00:06:46,710 --> 00:06:51,120
so far we didn't do anything

00:06:48,680 --> 00:06:53,040
specifically for angular well this is

00:06:51,120 --> 00:06:55,350
achievable which feels like you see

00:06:53,040 --> 00:06:57,300
Indians as already mentioned the unique

00:06:55,350 --> 00:06:59,730
thing about angular is that it is used

00:06:57,300 --> 00:07:01,980
with tooling in mind so you can perform

00:06:59,730 --> 00:07:03,120
similar static code analysis on top of

00:07:01,980 --> 00:07:05,580
the templates and the styles as well

00:07:03,120 --> 00:07:07,950
which is something pretty cool in order

00:07:05,580 --> 00:07:10,350
to do this let's see how we can find out

00:07:07,950 --> 00:07:12,450
whether we are using the Styles inside

00:07:10,350 --> 00:07:15,780
of the Styles property in our component

00:07:12,450 --> 00:07:18,270
metadata so in this case here we have

00:07:15,780 --> 00:07:20,550
Deb style for instance greeting span

00:07:18,270 --> 00:07:22,350
this is misspelled it is called span

00:07:20,550 --> 00:07:24,780
instead of spam in the template we have

00:07:22,350 --> 00:07:26,400
an h1 element with the span instead but

00:07:24,780 --> 00:07:28,800
this pair is not going to be applied and

00:07:26,400 --> 00:07:31,260
the typical way of doing this is just by

00:07:28,800 --> 00:07:34,350
well running our program seeing that the

00:07:31,260 --> 00:07:36,419
style has not been applied and trying to

00:07:34,350 --> 00:07:38,880
fix that but once we have a lot of

00:07:36,419 --> 00:07:41,490
styles it is hard to find all the dead

00:07:38,880 --> 00:07:43,830
Styles it is hard to find all the dead

00:07:41,490 --> 00:07:45,450
classes and this can increase the bundle

00:07:43,830 --> 00:07:48,330
size of our application and reduce the

00:07:45,450 --> 00:07:50,850
performance so instead of this we can

00:07:48,330 --> 00:07:52,800
perform static code analysis and find

00:07:50,850 --> 00:07:54,990
out all the dead styles as part of our

00:07:52,800 --> 00:07:57,030
due process or even report them instead

00:07:54,990 --> 00:08:01,890
of our dictator so we're going to build

00:07:57,030 --> 00:08:04,770
the ASP for the templates also we're

00:08:01,890 --> 00:08:06,840
going to use the ASP for the Styles

00:08:04,770 --> 00:08:08,160
we're going to match both SDS again

00:08:06,840 --> 00:08:09,780
against each other and we're going to

00:08:08,160 --> 00:08:12,030
find out that this tau is actually not

00:08:09,780 --> 00:08:14,789
in use here is how this looks in

00:08:12,030 --> 00:08:16,500
practice so this is colonizer and it

00:08:14,789 --> 00:08:19,700
reports all your new styles by using

00:08:16,500 --> 00:08:22,650
this length we can either decide to fix

00:08:19,700 --> 00:08:25,169
typos or just drop all your new styles

00:08:22,650 --> 00:08:27,660
by using the also fixes of kissin and

00:08:25,169 --> 00:08:30,360
that's it this way we can reduce the

00:08:27,660 --> 00:08:33,030
size of our application of course if we

00:08:30,360 --> 00:08:35,900
follow some conventions like not adding

00:08:33,030 --> 00:08:37,950
cells in an equally with the renderer

00:08:35,900 --> 00:08:41,789
now let's talk about something not that

00:08:37,950 --> 00:08:43,740
fun adds up breaking changes although

00:08:41,789 --> 00:08:45,839
the angular team they did amazing job in

00:08:43,740 --> 00:08:47,550
making sure that we almost have no

00:08:45,839 --> 00:08:49,830
braking changes between version 2 and

00:08:47,550 --> 00:08:52,070
version 4 there are skills some

00:08:49,830 --> 00:08:53,670
deprecations we can migrate our

00:08:52,070 --> 00:08:56,280
application from from

00:08:53,670 --> 00:08:58,950
to diversion for just with by updating

00:08:56,280 --> 00:09:00,510
our dependencies but these deprecations

00:08:58,950 --> 00:09:03,300
is something that we need to take care

00:09:00,510 --> 00:09:05,010
of before version 5 for instance the

00:09:03,300 --> 00:09:07,550
template is called ng template we have

00:09:05,010 --> 00:09:10,020
renderer which is renderer 2 and so on

00:09:07,550 --> 00:09:13,050
let's think of the simplest possible

00:09:10,020 --> 00:09:14,880
migration strategy well it can be for

00:09:13,050 --> 00:09:16,790
instance just finding drink and replace

00:09:14,880 --> 00:09:19,580
for all the opening and closing

00:09:16,790 --> 00:09:21,750
templates tags to ng temperate right

00:09:19,580 --> 00:09:24,450
however this is not going to work in the

00:09:21,750 --> 00:09:27,020
general case this component here is

00:09:24,450 --> 00:09:31,200
going to break our migration strategy

00:09:27,020 --> 00:09:32,580
because where we have templates instead

00:09:31,200 --> 00:09:34,470
of our templates we have a template

00:09:32,580 --> 00:09:37,730
element there which we also mention the

00:09:34,470 --> 00:09:40,410
template opening tag here instead of the

00:09:37,730 --> 00:09:42,990
property of our class so we obviously

00:09:40,410 --> 00:09:44,850
want to migrate the template inside of

00:09:42,990 --> 00:09:49,080
our template but you don't want to leave

00:09:44,850 --> 00:09:50,220
the other one on set here is a too low

00:09:49,080 --> 00:09:51,710
in this means that we need to perform

00:09:50,220 --> 00:09:54,390
some kind of a context where

00:09:51,710 --> 00:09:55,830
replacements so which we should perform

00:09:54,390 --> 00:09:57,840
the replacements only region of our

00:09:55,830 --> 00:10:00,240
templates not comments and strings

00:09:57,840 --> 00:10:02,840
elsewhere we can do this by part by

00:10:00,240 --> 00:10:06,720
building this abstract syntax tree and

00:10:02,840 --> 00:10:09,390
let me show you what to I preside over

00:10:06,720 --> 00:10:12,960
the last couple of weeks by using work

00:10:09,390 --> 00:10:16,290
by Alex CEO from the angular core team

00:10:12,960 --> 00:10:20,580
and gives limbs so here is ng migrate

00:10:16,290 --> 00:10:22,440
you can install it this way but since I

00:10:20,580 --> 00:10:29,040
have it already installed I can just run

00:10:22,440 --> 00:10:30,030
it on top of my tactic files but before

00:10:29,040 --> 00:10:33,390
that let's just take a look at the

00:10:30,030 --> 00:10:35,820
project so this project has one

00:10:33,390 --> 00:10:38,370
component goes to the component which

00:10:35,820 --> 00:10:40,320
has similar situation so we have the

00:10:38,370 --> 00:10:42,210
template element within of the template

00:10:40,320 --> 00:10:42,870
metadata we have the template element

00:10:42,210 --> 00:10:44,490
here as well

00:10:42,870 --> 00:10:46,400
we would want in the perfect case to

00:10:44,490 --> 00:10:48,810
replace this one but leave this one set

00:10:46,400 --> 00:10:52,290
let's run this and see what's going to

00:10:48,810 --> 00:10:54,930
happen so the two founds all the

00:10:52,290 --> 00:10:57,180
deprecations for us and suggest to pick

00:10:54,930 --> 00:10:58,590
them out medical for us so to migrate

00:10:57,180 --> 00:11:00,450
our application to the new version of

00:10:58,590 --> 00:11:03,390
angular out naturally for us let's just

00:11:00,450 --> 00:11:06,170
throw the tool for now click yes all

00:11:03,390 --> 00:11:09,500
right so it fixed all the applications

00:11:06,170 --> 00:11:10,970
let's see if it broke our components we

00:11:09,500 --> 00:11:16,329
turns out that it performs only the

00:11:10,970 --> 00:11:16,329
right stamp type of migrations if we run

00:11:16,480 --> 00:11:21,680
we're going to see that it has migrated

00:11:19,100 --> 00:11:23,750
our and our inline and our external

00:11:21,680 --> 00:11:25,430
templates as well so this way we can

00:11:23,750 --> 00:11:27,709
migrate from version to version

00:11:25,430 --> 00:11:29,589
in angular just by running a simple

00:11:27,709 --> 00:11:32,990
script which is much less error-prone

00:11:29,589 --> 00:11:34,370
compared to doing it manually of course

00:11:32,990 --> 00:11:37,670
it's not going to be possible for all

00:11:34,370 --> 00:11:41,800
the migrations but for big part of them

00:11:37,670 --> 00:11:44,630
the process is going to be just seamless

00:11:41,800 --> 00:11:48,620
now let's talk about the source code

00:11:44,630 --> 00:11:51,620
visualization well now let's suppose

00:11:48,620 --> 00:11:52,880
that we're new to some huge projects we

00:11:51,620 --> 00:11:55,070
have a large change your application

00:11:52,880 --> 00:11:58,880
that is being developed by a big team

00:11:55,070 --> 00:12:01,880
and here just hires to start working on

00:11:58,880 --> 00:12:02,839
it in order to get on track as quickly

00:12:01,880 --> 00:12:05,389
as possible

00:12:02,839 --> 00:12:07,160
we need to usually read the entire

00:12:05,389 --> 00:12:09,560
source code I guess but this is going to

00:12:07,160 --> 00:12:10,730
be very high to digest also the

00:12:09,560 --> 00:12:12,320
different modules inside of this

00:12:10,730 --> 00:12:14,600
application they're on different levels

00:12:12,320 --> 00:12:18,500
of abstraction and in order to apply

00:12:14,600 --> 00:12:20,240
some more systematic way of exploring

00:12:18,500 --> 00:12:22,640
the code for instance top-down or

00:12:20,240 --> 00:12:25,160
bottom-up we need to figure out how are

00:12:22,640 --> 00:12:26,630
they located into we need to just sort

00:12:25,160 --> 00:12:29,600
them out by their level of abstraction

00:12:26,630 --> 00:12:31,070
and apply this strategy so that's why

00:12:29,600 --> 00:12:32,870
because those who people are good in

00:12:31,070 --> 00:12:35,060
visual thinking there are a lot of tools

00:12:32,870 --> 00:12:36,680
for reverse engineering attempts for

00:12:35,060 --> 00:12:38,300
instance for Java and c-sharp there are

00:12:36,680 --> 00:12:41,360
water tools which are going to visualize

00:12:38,300 --> 00:12:42,920
our classes boxes and draw arrows

00:12:41,360 --> 00:12:45,230
between them so this way we will see

00:12:42,920 --> 00:12:47,870
their durations I was thinking to do

00:12:45,230 --> 00:12:50,329
something like this with for angular by

00:12:47,870 --> 00:12:52,490
using angular compiler of course and in

00:12:50,329 --> 00:12:55,790
order to provide a little bit higher ATI

00:12:52,490 --> 00:12:59,240
on top I built wrapper codes of acid

00:12:55,790 --> 00:13:01,459
called ng ast with NGS see this full

00:12:59,240 --> 00:13:03,980
library that you can very easily parson

00:13:01,459 --> 00:13:06,139
and your projects get all the directives

00:13:03,980 --> 00:13:08,420
components in their metadata also

00:13:06,139 --> 00:13:11,839
providers their relations pipe and so on

00:13:08,420 --> 00:13:14,060
let me show you how this looks like with

00:13:11,839 --> 00:13:15,410
a tool called ng F in the meantime I'm

00:13:14,060 --> 00:13:17,080
also working with the guys from the

00:13:15,410 --> 00:13:20,110
computer candy

00:13:17,080 --> 00:13:21,820
the teams in order to collaborate on the

00:13:20,110 --> 00:13:25,720
tool but here is a specific

00:13:21,820 --> 00:13:28,180
implementation that uses NGS D this is

00:13:25,720 --> 00:13:32,560
an electron app which allows us to

00:13:28,180 --> 00:13:35,050
select an angular project and so yeah

00:13:32,560 --> 00:13:36,400
for instance this gives config and right

00:13:35,050 --> 00:13:40,080
after that it is just going to

00:13:36,400 --> 00:13:43,900
automatically render the main component

00:13:40,080 --> 00:13:46,030
of the main module of our application

00:13:43,900 --> 00:13:49,660
which we can explore its dependencies or

00:13:46,030 --> 00:13:51,580
we can just get into the app module one

00:13:49,660 --> 00:13:53,380
level deeper so we can see all the

00:13:51,580 --> 00:13:56,080
providers within this module we can just

00:13:53,380 --> 00:13:58,690
click around and so let's just go into

00:13:56,080 --> 00:14:01,450
the user service the user service has

00:13:58,690 --> 00:14:04,000
three dependencies and we can export

00:14:01,450 --> 00:14:05,770
them one by one but maybe the component

00:14:04,000 --> 00:14:07,960
is going to be even more interesting so

00:14:05,770 --> 00:14:11,500
if we go into the component we can see

00:14:07,960 --> 00:14:13,630
the dependencies or we can explore its

00:14:11,500 --> 00:14:16,120
templates where each individual box is

00:14:13,630 --> 00:14:18,640
just another element out of the

00:14:16,120 --> 00:14:20,350
templates since they our footer is a

00:14:18,640 --> 00:14:22,350
component we can double click on it and

00:14:20,350 --> 00:14:25,470
see the dependencies or each template

00:14:22,350 --> 00:14:28,210
here is the template of the footer

00:14:25,470 --> 00:14:30,850
components which have some a elements

00:14:28,210 --> 00:14:32,040
with a router linked in Sullivan if

00:14:30,850 --> 00:14:34,600
we're interested in any particular

00:14:32,040 --> 00:14:37,180
component we can just right click on it

00:14:34,600 --> 00:14:41,230
and open the file where the declaration

00:14:37,180 --> 00:14:44,550
is contained and this way well we can

00:14:41,230 --> 00:14:44,550
just keep exploring our code

00:14:51,450 --> 00:14:55,690
right well this is already useful I've

00:14:53,950 --> 00:14:57,930
been using it for a few projects and I

00:14:55,690 --> 00:15:00,190
saw some interest in the community and

00:14:57,930 --> 00:15:01,780
it's kind of fun because it's visual

00:15:00,190 --> 00:15:05,080
representation of our application right

00:15:01,780 --> 00:15:07,180
but we can go one dimension higher like

00:15:05,080 --> 00:15:09,820
we've been representing our app in the

00:15:07,180 --> 00:15:12,190
two dimensions so far let's try the

00:15:09,820 --> 00:15:14,230
third dimension as well so so far we've

00:15:12,190 --> 00:15:16,060
been always trying to place our source

00:15:14,230 --> 00:15:17,770
code into our own reality let's just

00:15:16,060 --> 00:15:21,100
create a spatial reality for our source

00:15:17,770 --> 00:15:23,970
code instead here is another tool which

00:15:21,100 --> 00:15:29,980
is an NPM module that I project recently

00:15:23,970 --> 00:15:32,880
called ng world so ng worlds is an NPM

00:15:29,980 --> 00:15:38,070
module that accepts an angular project

00:15:32,880 --> 00:15:43,030
for instance and your CRM system here

00:15:38,070 --> 00:15:45,580
and after we run it it is going to

00:15:43,030 --> 00:15:47,980
perform the faces of lexical analysis

00:15:45,580 --> 00:15:50,380
syntax analysis right after that we are

00:15:47,980 --> 00:15:52,180
going to get the ast we are going to

00:15:50,380 --> 00:15:53,410
transform it a little bit and we're

00:15:52,180 --> 00:15:55,620
going to generate some code

00:15:53,410 --> 00:15:58,750
so in general ng world is some kind of

00:15:55,620 --> 00:16:01,540
unconventional compiler I guess here is

00:15:58,750 --> 00:16:05,320
what it generated we have an index dot

00:16:01,540 --> 00:16:15,870
HTML and a few other things let's run it

00:16:05,320 --> 00:16:19,320
in our favorite browser okay

00:16:15,870 --> 00:16:23,300
so we have some sky and it looks like

00:16:19,320 --> 00:16:27,630
virtual reality let's turn around oh

00:16:23,300 --> 00:16:29,370
yeah we have Gardens let's go a little

00:16:27,630 --> 00:16:32,850
bit closer to see what's if they're on

00:16:29,370 --> 00:16:42,150
these labels and so oh this is our about

00:16:32,850 --> 00:16:43,980
components so this is our about module

00:16:42,150 --> 00:16:47,910
actually let's go inside of the garden

00:16:43,980 --> 00:16:50,220
and see what we have we have trees which

00:16:47,910 --> 00:16:52,890
are named our hour after hour components

00:16:50,220 --> 00:16:55,230
and the cool thing is that if we take a

00:16:52,890 --> 00:16:56,910
look at their crowns this is going to be

00:16:55,230 --> 00:17:00,560
the samples of the components just

00:16:56,910 --> 00:17:00,560
rendering the three-dimensional space

00:17:00,890 --> 00:17:12,150
yeah we can jump around and explore this

00:17:09,840 --> 00:17:13,890
world so if you like our code that much

00:17:12,150 --> 00:17:16,070
that we want to live in it we can do

00:17:13,890 --> 00:17:16,070
that

00:17:17,710 --> 00:17:26,850
[Applause]

00:17:24,890 --> 00:17:28,920
so the purpose of the today's

00:17:26,850 --> 00:17:31,350
presentation was to show you these tools

00:17:28,920 --> 00:17:34,290
and to show you what we can achieve with

00:17:31,350 --> 00:17:36,960
the angular compiler by during console

00:17:34,290 --> 00:17:39,030
profit we can develop tools which are

00:17:36,960 --> 00:17:41,250
able to transform our application into

00:17:39,030 --> 00:17:43,650
much more efficient version of itself or

00:17:41,250 --> 00:17:46,440
we can just perform an automated

00:17:43,650 --> 00:17:48,840
migration we can even visualize our

00:17:46,440 --> 00:17:51,030
source code or do something silly not

00:17:48,840 --> 00:17:53,100
that useful but very fun like generating

00:17:51,030 --> 00:17:55,620
a virtual reality ultimate the only

00:17:53,100 --> 00:17:57,840
limitation that we currently have is our

00:17:55,620 --> 00:17:58,790
own imagination thank you very much for

00:17:57,840 --> 00:18:03,339
your interest

00:17:58,790 --> 00:18:03,339

YouTube URL: https://www.youtube.com/watch?v=tBV4IQwPssU


