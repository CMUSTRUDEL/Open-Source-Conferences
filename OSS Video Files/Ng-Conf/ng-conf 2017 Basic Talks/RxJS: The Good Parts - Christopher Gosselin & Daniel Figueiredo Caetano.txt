Title: RxJS: The Good Parts - Christopher Gosselin & Daniel Figueiredo Caetano
Publication date: 2017-04-30
Playlist: ng-conf 2017 Basic Talks
Description: 
	www.ng-conf.org

ng-conf is a two day, single track conference focused on delivering the highest quality training in the Angular JavaScript framework. 500 to 700 Developers from across the country will converge on beautiful Salt Lake City, UT to participate in training sessions by the Google Angular team, and other Angular experts. In addition to the invaluable training, ng-conf will deliver a premier conference experience for attendees, providing opportunities to network with other developers, relax at social events, and engage in some of the unique entertainment opportunities available in Utah.
Captions: 
	00:00:00,000 --> 00:00:03,929
all right just how's everyone doing

00:00:01,829 --> 00:00:06,060
today cool

00:00:03,929 --> 00:00:07,500
so I mean sure to covered our first

00:00:06,060 --> 00:00:09,990
question I mean we're going to ask who

00:00:07,500 --> 00:00:12,900
knows I worked yes and no no it's cool I

00:00:09,990 --> 00:00:15,719
mean beat us to the punch all right so

00:00:12,900 --> 00:00:18,480
I'm Kris Gosselin and we're both to

00:00:15,719 --> 00:00:20,160
wrangle this is I'm Daniel and today

00:00:18,480 --> 00:00:29,880
we're going to be talking about rxjs

00:00:20,160 --> 00:00:31,890
the good fight so what is our chess the

00:00:29,880 --> 00:00:33,780
first time I saw rxjs this is what went

00:00:31,890 --> 00:00:36,510
through my brain I was like okay sorry I

00:00:33,780 --> 00:00:38,280
got math I got filters there seems to be

00:00:36,510 --> 00:00:40,770
some kind of way to do asynchronous

00:00:38,280 --> 00:00:44,460
programming not really sure it looks

00:00:40,770 --> 00:00:47,550
like a promise or an array this is kind

00:00:44,460 --> 00:00:50,250
of what I visualized it like now I kind

00:00:47,550 --> 00:00:52,079
of see it as almost like a funnel so I

00:00:50,250 --> 00:00:54,000
take like a little ball I kind of think

00:00:52,079 --> 00:00:56,850
remember I was like those balls they use

00:00:54,000 --> 00:00:58,050
for what is a bingo yeah bingo and I

00:00:56,850 --> 00:01:00,090
take the ball and I throw it down the

00:00:58,050 --> 00:01:02,789
funnel and as it goes down the funnel

00:01:00,090 --> 00:01:06,270
multiple things are applied to it let's

00:01:02,789 --> 00:01:07,770
say a map a filter reduced and every

00:01:06,270 --> 00:01:09,960
single time I throw a ball down the

00:01:07,770 --> 00:01:12,090
funnel it gets the operators applied to

00:01:09,960 --> 00:01:14,810
it and then at the very very end

00:01:12,090 --> 00:01:16,680
something gets spit out or you know

00:01:14,810 --> 00:01:20,270
every single time a ball goes through

00:01:16,680 --> 00:01:22,920
the funnel depends on the operators

00:01:20,270 --> 00:01:27,810
alright so how does that relate to

00:01:22,920 --> 00:01:29,579
angular at all it's everywhere so if you

00:01:27,810 --> 00:01:31,380
guys have had experience with angular 2

00:01:29,579 --> 00:01:34,439
you know that ATP modules

00:01:31,380 --> 00:01:37,079
routers output forms they all have

00:01:34,439 --> 00:01:39,329
observables mcdhh in so it's really

00:01:37,079 --> 00:01:42,630
important for us to have an idea of what

00:01:39,329 --> 00:01:43,710
are the common operators how can handle

00:01:42,630 --> 00:01:46,200
errors with rxjs

00:01:43,710 --> 00:01:48,030
how we can type the variables so we can

00:01:46,200 --> 00:01:51,090
get some compile time errors which are

00:01:48,030 --> 00:01:54,750
super handsy and we also had an example

00:01:51,090 --> 00:01:58,259
of RHS versus regular arrays we're going

00:01:54,750 --> 00:01:59,070
to get dipped into it later so firstly

00:01:58,259 --> 00:02:02,040
we're going to talk about common

00:01:59,070 --> 00:02:04,409
operators so this part of the talk I

00:02:02,040 --> 00:02:07,710
actually crowdsource for my company so

00:02:04,409 --> 00:02:10,410
we're a team of about 165 give or take

00:02:07,710 --> 00:02:12,780
so I went over to maybe I take 30 or 40

00:02:10,410 --> 00:02:13,830
people and I took a survey you know what

00:02:12,780 --> 00:02:16,050
are your favorite operators

00:02:13,830 --> 00:02:19,500
why the lowest ones didn't make the cut

00:02:16,050 --> 00:02:20,130
and we we're about to show you what came

00:02:19,500 --> 00:02:23,040
to the top

00:02:20,130 --> 00:02:24,510
so creating observables obviously these

00:02:23,040 --> 00:02:27,270
had to make the cut because otherwise we

00:02:24,510 --> 00:02:30,330
wouldn't have observables so observable

00:02:27,270 --> 00:02:33,900
of it takes it as functional pyramidal

00:02:30,330 --> 00:02:36,000
arguments so a comma B comma C so if you

00:02:33,900 --> 00:02:39,470
wanted a pass to an observable say 1 2 3

00:02:36,000 --> 00:02:42,240
would be 1 comma 2 comma 3 pretty simple

00:02:39,470 --> 00:02:44,130
observable from gives you a little bit

00:02:42,240 --> 00:02:46,530
more flexibility you can pass any kind

00:02:44,130 --> 00:02:50,360
of iterable a promise and it will

00:02:46,530 --> 00:02:50,360
convert it into and observable for you

00:02:50,420 --> 00:02:54,390
and then we have array like operators

00:02:52,680 --> 00:02:55,740
which is coming back to the beginning of

00:02:54,390 --> 00:02:58,680
the talk where I said it reminds me of

00:02:55,740 --> 00:03:02,640
an array I'm sure here who knows what a

00:02:58,680 --> 00:03:04,560
filter is okay so it is exactly the same

00:03:02,640 --> 00:03:06,959
thing as the array filter but in this

00:03:04,560 --> 00:03:11,610
case it applies to a single number going

00:03:06,959 --> 00:03:16,680
through at a single time so filter if it

00:03:11,610 --> 00:03:18,390
passes it continues on map because most

00:03:16,680 --> 00:03:21,030
of people no filter I'll assume you guys

00:03:18,390 --> 00:03:23,970
know map it makes you allow to do an

00:03:21,030 --> 00:03:25,430
operation a modification onto the number

00:03:23,970 --> 00:03:29,730
as it's going through the pipeline

00:03:25,430 --> 00:03:30,780
reduce same thing as the array reduce so

00:03:29,730 --> 00:03:33,360
you can actually combine all your

00:03:30,780 --> 00:03:35,730
numbers into a single number or you know

00:03:33,360 --> 00:03:37,970
do whatever you want it basically allows

00:03:35,730 --> 00:03:40,709
you to iterate all over the numbers and

00:03:37,970 --> 00:03:44,070
return in single output and then take

00:03:40,709 --> 00:03:46,560
really really good for HTTP because HTTP

00:03:44,070 --> 00:03:48,540
generally only gives one response so if

00:03:46,560 --> 00:03:50,519
you go take one it'll clean up the

00:03:48,540 --> 00:03:55,560
observable for you and you don't have to

00:03:50,519 --> 00:03:58,440
dispose with it and then useful useful

00:03:55,560 --> 00:04:00,989
for browser events how about the balance

00:03:58,440 --> 00:04:03,150
does anyone know to balance okay low

00:04:00,989 --> 00:04:05,310
lets people awesome so the way I think

00:04:03,150 --> 00:04:06,870
of the balance is I'm mashing my hands

00:04:05,310 --> 00:04:07,620
on a keyboard like this keyboard cat

00:04:06,870 --> 00:04:10,470
let's just go like this

00:04:07,620 --> 00:04:12,450
and then I have to wait X amount of time

00:04:10,470 --> 00:04:14,190
before I stop doing this

00:04:12,450 --> 00:04:16,410
in order for the next event to actually

00:04:14,190 --> 00:04:18,479
fire so if I keep doing this only one or

00:04:16,410 --> 00:04:21,419
Wenzel fire whereas throttle on the

00:04:18,479 --> 00:04:23,970
other hand it's similar but different so

00:04:21,419 --> 00:04:25,890
if I keep doing this it'll actually fire

00:04:23,970 --> 00:04:27,780
every X amount of you know milliseconds

00:04:25,890 --> 00:04:29,370
so if I'm doing that so fire

00:04:27,780 --> 00:04:30,990
and you know let's wait a second fire

00:04:29,370 --> 00:04:35,220
again so don't actually have to stop

00:04:30,990 --> 00:04:37,980
that's throttle and then we have

00:04:35,220 --> 00:04:40,340
combining observables so switch map

00:04:37,980 --> 00:04:43,980
think it used to be called flat map

00:04:40,340 --> 00:04:46,200
pretty sure and switch map allows you to

00:04:43,980 --> 00:04:52,160
return and observable as you're going

00:04:46,200 --> 00:04:57,320
through so kind sizzles yeah okay

00:04:52,160 --> 00:05:00,060
sorry so if I'm making an API request

00:04:57,320 --> 00:05:02,910
because of like a key event and that one

00:05:00,060 --> 00:05:04,320
doesn't finish if I had another key then

00:05:02,910 --> 00:05:06,570
the previous one will actually get

00:05:04,320 --> 00:05:09,060
canceled whereas merge map on the other

00:05:06,570 --> 00:05:11,730
hand every single likes a keystroke if

00:05:09,060 --> 00:05:15,060
it's hooked up to an HTTP request it'll

00:05:11,730 --> 00:05:17,130
fire every single time so the very

00:05:15,060 --> 00:05:18,960
particulars like the very specific

00:05:17,130 --> 00:05:20,370
differences we have to be really careful

00:05:18,960 --> 00:05:23,910
with it otherwise you can end up with

00:05:20,370 --> 00:05:25,710
like a lot of overhead dot zip I use it

00:05:23,910 --> 00:05:27,479
in terms of combining all my HTTP

00:05:25,710 --> 00:05:29,580
requests so if I have like five I'll

00:05:27,479 --> 00:05:30,990
throw them in a zip and then the dobbs

00:05:29,580 --> 00:05:33,960
that will combine all the requests and

00:05:30,990 --> 00:05:38,610
give you all of my runs combined latest

00:05:33,960 --> 00:05:40,530
so let's say if you have five different

00:05:38,610 --> 00:05:42,419
observables all types of a different key

00:05:40,530 --> 00:05:44,370
stroke or something like that whenever

00:05:42,419 --> 00:05:46,050
one of those keystrokes hit gets hit

00:05:44,370 --> 00:05:50,940
it'll give you all the latest data from

00:05:46,050 --> 00:05:53,190
all your observables and then useful

00:05:50,940 --> 00:05:56,100
utils array just like it sounds

00:05:53,190 --> 00:05:57,960
it'll combine all your data from the

00:05:56,100 --> 00:05:59,550
observable into an array so let's say if

00:05:57,960 --> 00:06:03,030
you pass an array into your observable

00:05:59,550 --> 00:06:05,280
one two three and then you do a dot two

00:06:03,030 --> 00:06:08,220
array your subscribe will be an array of

00:06:05,280 --> 00:06:10,440
one two three otherwise it would be one

00:06:08,220 --> 00:06:15,060
and then it'll fire again to fire again

00:06:10,440 --> 00:06:17,669
three and then dot share so dot share is

00:06:15,060 --> 00:06:19,560
a very interesting one because if you

00:06:17,669 --> 00:06:22,229
have an observable hooked up to an HTTP

00:06:19,560 --> 00:06:23,970
request and you only want that to fire

00:06:22,229 --> 00:06:26,070
once it's actually going to fire every

00:06:23,970 --> 00:06:29,510
every single time unless a news dot

00:06:26,070 --> 00:06:31,979
share so that's what let you see use for

00:06:29,510 --> 00:06:33,419
and in case of errors if your observable

00:06:31,979 --> 00:06:37,760
ever fails you can do this dot retry

00:06:33,419 --> 00:06:37,760
it's good for again HTTP requests

00:06:39,100 --> 00:06:46,330
all right so wait what happens it's an

00:06:41,590 --> 00:06:48,970
error happens that's usually my face

00:06:46,330 --> 00:06:51,640
when something happens so the air is

00:06:48,970 --> 00:06:54,370
there go in that specific channel is

00:06:51,640 --> 00:06:56,590
called a narrow channel we're going to

00:06:54,370 --> 00:06:58,660
get deep into this but basically you can

00:06:56,590 --> 00:07:00,340
attach a callback that will be called

00:06:58,660 --> 00:07:02,560
whenever an error happens and you're

00:07:00,340 --> 00:07:04,930
provided the error as an argument of

00:07:02,560 --> 00:07:06,310
your function the earth another project

00:07:04,930 --> 00:07:08,320
thing is that the year is hot the

00:07:06,310 --> 00:07:10,570
sequence so if an error happens the

00:07:08,320 --> 00:07:12,850
observer will stop this is very

00:07:10,570 --> 00:07:15,010
important to know and there are two

00:07:12,850 --> 00:07:17,260
levels of errors there are class levels

00:07:15,010 --> 00:07:18,430
in instance libraries we're doing but

00:07:17,260 --> 00:07:21,040
we're going to talk about class level

00:07:18,430 --> 00:07:23,080
where it's usually there you want to

00:07:21,040 --> 00:07:26,800
deal with multiple durables at the same

00:07:23,080 --> 00:07:29,860
time and one of the use cases swallowing

00:07:26,800 --> 00:07:34,060
errors let's get an example of that so

00:07:29,860 --> 00:07:36,910
this sample what it does is basically to

00:07:34,060 --> 00:07:39,490
try to perform the first request if it

00:07:36,910 --> 00:07:41,650
an error happens it will try the second

00:07:39,490 --> 00:07:44,710
and if an error has it will try to get

00:07:41,650 --> 00:07:46,780
the last one so it doesn't really matter

00:07:44,710 --> 00:07:48,820
what what's the error that it's being

00:07:46,780 --> 00:07:51,400
drawn it's just that it will keep trying

00:07:48,820 --> 00:07:53,770
to something successful or all the

00:07:51,400 --> 00:07:56,710
options are gone so in this case your to

00:07:53,770 --> 00:07:58,240
make sure that your last option is

00:07:56,710 --> 00:08:03,550
something that you make you're sure

00:07:58,240 --> 00:08:06,820
that's not going to fail so we can also

00:08:03,550 --> 00:08:08,260
in our errors and continue with the

00:08:06,820 --> 00:08:10,660
operations let's say you have a bunch of

00:08:08,260 --> 00:08:13,570
things that you want to execute and all

00:08:10,660 --> 00:08:15,880
these things regardless of the output of

00:08:13,570 --> 00:08:18,100
each particular observable we just want

00:08:15,880 --> 00:08:21,670
them to all be executed in theory in

00:08:18,100 --> 00:08:23,230
this case what you can do is you can use

00:08:21,670 --> 00:08:25,450
another operator there a bunch of other

00:08:23,230 --> 00:08:26,710
operators that perform different things

00:08:25,450 --> 00:08:28,360
in are actually a she goes to the

00:08:26,710 --> 00:08:31,000
documentation going to see it there's

00:08:28,360 --> 00:08:33,790
several options these are just examples

00:08:31,000 --> 00:08:35,590
in this case the on error resume max

00:08:33,790 --> 00:08:38,080
callback will try to execute all the

00:08:35,590 --> 00:08:40,630
functions and data will be function one

00:08:38,080 --> 00:08:46,180
function two three as long as all these

00:08:40,630 --> 00:08:47,890
observables are successful and then we

00:08:46,180 --> 00:08:52,329
go to your instance libraries

00:08:47,890 --> 00:08:54,700
this is what we usually expect from an

00:08:52,329 --> 00:08:56,680
error handler so let's say that you want

00:08:54,700 --> 00:08:58,029
to deal with the error method to a

00:08:56,680 --> 00:09:00,160
different payload something that your

00:08:58,029 --> 00:09:02,260
application is used to so what you can

00:09:00,160 --> 00:09:05,500
do is you can use the catch operator

00:09:02,260 --> 00:09:08,200
which basically it's like a try-catch in

00:09:05,500 --> 00:09:10,810
JavaScript you're going to receive the

00:09:08,200 --> 00:09:13,029
error when something happens and your

00:09:10,810 --> 00:09:14,589
callback will be called with the error

00:09:13,029 --> 00:09:16,420
in what your callback should return

00:09:14,589 --> 00:09:18,550
either not or observable and that

00:09:16,420 --> 00:09:24,519
observable is what your subscription is

00:09:18,550 --> 00:09:26,740
going to receive so an example is we're

00:09:24,519 --> 00:09:29,200
doing a Ajax call here to get that

00:09:26,740 --> 00:09:31,740
resource let's say that service is

00:09:29,200 --> 00:09:34,240
unavailable or something's happening

00:09:31,740 --> 00:09:35,890
this callback function will receive the

00:09:34,240 --> 00:09:38,260
error and all I have to do is just

00:09:35,890 --> 00:09:42,459
return an observer out of it it's pretty

00:09:38,260 --> 00:09:45,579
simple and the same way you can use

00:09:42,459 --> 00:09:49,120
catch they also have a fine of the

00:09:45,579 --> 00:09:51,250
operator so I believe you guys know

00:09:49,120 --> 00:09:53,170
about Rex yes but you have sort of three

00:09:51,250 --> 00:09:56,380
callbacks you have what you subscribe

00:09:53,170 --> 00:09:57,480
when an error and when you observe was

00:09:56,380 --> 00:10:00,370
completed

00:09:57,480 --> 00:10:02,560
finally it's only call these observers

00:10:00,370 --> 00:10:05,320
completed the only difference between

00:10:02,560 --> 00:10:07,540
the complete callback and finally its

00:10:05,320 --> 00:10:10,240
because finally will be called

00:10:07,540 --> 00:10:12,490
regardless even if an error happens so

00:10:10,240 --> 00:10:13,990
the classic use case for this is going

00:10:12,490 --> 00:10:17,350
to clean up resources so let's say I

00:10:13,990 --> 00:10:20,500
have a socket open and I'm streaming

00:10:17,350 --> 00:10:22,269
data reading from the database imagine

00:10:20,500 --> 00:10:24,339
that gasps a doe it's an observable that

00:10:22,269 --> 00:10:28,000
keeps emitting values into all the data

00:10:24,339 --> 00:10:30,610
was being rat if an error happens it

00:10:28,000 --> 00:10:32,800
will stop the observable and we'll call

00:10:30,610 --> 00:10:34,870
finally right after so I can close my

00:10:32,800 --> 00:10:39,420
socket and make sure I read all the

00:10:34,870 --> 00:10:43,660
resources after we talked about

00:10:39,420 --> 00:10:45,519
typescript and how can we leverage

00:10:43,660 --> 00:10:48,670
typescript observables so we can get

00:10:45,519 --> 00:10:50,440
compiler x which is which are super

00:10:48,670 --> 00:10:52,660
handy why

00:10:50,440 --> 00:10:53,860
what are advantages of having types it

00:10:52,660 --> 00:10:55,839
helps you get some high o errors as I

00:10:53,860 --> 00:10:58,420
mentioned it forces you to return a null

00:10:55,839 --> 00:11:01,149
object it will fail if you're not

00:10:58,420 --> 00:11:01,730
providing the type you want and also

00:11:01,149 --> 00:11:03,709
what we

00:11:01,730 --> 00:11:05,000
using this any other dabs if you have

00:11:03,709 --> 00:11:06,440
functions that return a specific

00:11:05,000 --> 00:11:08,449
observable and this observable is typed

00:11:06,440 --> 00:11:11,389
it's easy to understand what you're

00:11:08,449 --> 00:11:14,870
going to get out of it so it also saves

00:11:11,389 --> 00:11:18,680
a bit of development time how can we use

00:11:14,870 --> 00:11:21,350
these generic arguments so our excess

00:11:18,680 --> 00:11:24,500
has generic parameters for all the

00:11:21,350 --> 00:11:26,779
operators and for observable itself the

00:11:24,500 --> 00:11:28,100
observable has a generic argument which

00:11:26,779 --> 00:11:31,010
is what you're going to receive when you

00:11:28,100 --> 00:11:34,100
subscribe to that observable and you

00:11:31,010 --> 00:11:35,899
also have generic parameters when you're

00:11:34,100 --> 00:11:37,370
performing some operations let's say

00:11:35,899 --> 00:11:39,889
you're performing a math operation or

00:11:37,370 --> 00:11:41,570
emerg operation you also have to provide

00:11:39,889 --> 00:11:48,560
the generic arguments for results

00:11:41,570 --> 00:11:50,180
operations yep and this is an example so

00:11:48,560 --> 00:11:52,370
let's say that I want to create an

00:11:50,180 --> 00:11:56,870
observable so returns a cat

00:11:52,370 --> 00:12:00,410
and I've tried here to provide an object

00:11:56,870 --> 00:12:02,389
which does not match the interface and

00:12:00,410 --> 00:12:03,740
you indeed get it error this is the

00:12:02,389 --> 00:12:06,199
error you're probably going to see in

00:12:03,740 --> 00:12:08,060
your type script is objects not

00:12:06,199 --> 00:12:13,970
assignable to that type because we're

00:12:08,060 --> 00:12:15,800
not providing the method part okay so

00:12:13,970 --> 00:12:18,019
let's get little bit more complicated in

00:12:15,800 --> 00:12:19,490
this we know that observables that Chris

00:12:18,019 --> 00:12:23,089
mentioned have a bunch operators we can

00:12:19,490 --> 00:12:24,709
merge observables can map combined so

00:12:23,089 --> 00:12:29,269
how that works with the generic

00:12:24,709 --> 00:12:31,610
arguments in the types let's give an

00:12:29,269 --> 00:12:33,470
example so let's say that we want to map

00:12:31,610 --> 00:12:38,899
our observable from the statistic type

00:12:33,470 --> 00:12:41,209
ax to type Y in this case math has two

00:12:38,899 --> 00:12:43,190
generic parameters the first one is the

00:12:41,209 --> 00:12:44,959
observable the type of observer you're

00:12:43,190 --> 00:12:47,779
getting in so let's say we're receiving

00:12:44,959 --> 00:12:50,000
a cat as we've seen previously and the

00:12:47,779 --> 00:12:52,819
type you're going to return after I'm

00:12:50,000 --> 00:12:54,980
basically mapping from the first type to

00:12:52,819 --> 00:12:58,339
the second and the way that I can do

00:12:54,980 --> 00:13:00,860
this is providing these two arguments in

00:12:58,339 --> 00:13:02,480
my operator so let's say that I want to

00:13:00,860 --> 00:13:04,850
get this resource I know that's the type

00:13:02,480 --> 00:13:09,139
I'm going to receive is a cat and now I

00:13:04,850 --> 00:13:10,720
want to do is map it to a dot so math

00:13:09,139 --> 00:13:13,240
will

00:13:10,720 --> 00:13:15,790
type script will fail if what I'm

00:13:13,240 --> 00:13:22,689
returning is not a dog which is also

00:13:15,790 --> 00:13:27,160
pretty cool it had to turn my mic back

00:13:22,689 --> 00:13:29,620
on alright so this one is an actual kind

00:13:27,160 --> 00:13:31,420
of a weird one I was having a talk over

00:13:29,620 --> 00:13:33,100
dinner last night and they're still kind

00:13:31,420 --> 00:13:35,819
of a little particular about how this

00:13:33,100 --> 00:13:38,620
actually works but I'm pretty positive

00:13:35,819 --> 00:13:40,060
I'm gonna go into the why after so

00:13:38,620 --> 00:13:41,949
anyways I want to thank Michael Bennet

00:13:40,060 --> 00:13:44,170
for this part of my talk he came up with

00:13:41,949 --> 00:13:45,670
this idea and at first I didn't believe

00:13:44,170 --> 00:13:49,149
him and then we did some benchmark

00:13:45,670 --> 00:13:53,170
testing and Moby holds it's true so

00:13:49,149 --> 00:13:55,810
performance in our excess uh Jess rx

00:13:53,170 --> 00:14:00,699
yeah array operator servers rxjs

00:13:55,810 --> 00:14:03,160
operators I'll just keep going so this

00:14:00,699 --> 00:14:06,879
is the test we take a million elements

00:14:03,160 --> 00:14:08,649
in an array and we're going to do a few

00:14:06,879 --> 00:14:11,110
operations over them we're going to do

00:14:08,649 --> 00:14:12,009
it in the array with the array operators

00:14:11,110 --> 00:14:14,439
and we're going to do it with

00:14:12,009 --> 00:14:16,600
observables with observable operators so

00:14:14,439 --> 00:14:17,019
as I talked before observables work like

00:14:16,600 --> 00:14:20,050
a funnel

00:14:17,019 --> 00:14:24,910
whereas arrays you it's more iterative

00:14:20,050 --> 00:14:26,230
okay so here's the array setup I take a

00:14:24,910 --> 00:14:28,540
million elements that are randomly

00:14:26,230 --> 00:14:30,490
generated I'm going to find the even

00:14:28,540 --> 00:14:32,559
ones I'm going to multiply by five and

00:14:30,490 --> 00:14:34,809
then I'm going to reduce them and just

00:14:32,559 --> 00:14:37,930
add them together very simple not that

00:14:34,809 --> 00:14:40,569
complicated and I do the exact same

00:14:37,930 --> 00:14:42,309
thing with the array so I use that from

00:14:40,569 --> 00:14:44,769
operator that we were talking about take

00:14:42,309 --> 00:14:47,110
the array turn it into an observable and

00:14:44,769 --> 00:14:51,430
then I'm going to do a filter a map I'm

00:14:47,110 --> 00:14:53,110
going to reduce and subscribe um so

00:14:51,430 --> 00:14:55,000
remember that observables are inherently

00:14:53,110 --> 00:14:56,490
synchronous so that's how does the whole

00:14:55,000 --> 00:14:58,629
scoping thing works

00:14:56,490 --> 00:15:04,720
so that's why it's going to return the

00:14:58,629 --> 00:15:06,550
value and then the results so I would

00:15:04,720 --> 00:15:06,879
think that the array operator would be

00:15:06,550 --> 00:15:09,189
quicker

00:15:06,879 --> 00:15:12,759
I thought rxjs would have a little bit

00:15:09,189 --> 00:15:16,689
more overhead but it's not so the Rays

00:15:12,759 --> 00:15:19,569
actually took 0.14 seconds whereas rxjs

00:15:16,689 --> 00:15:22,480
took 0.8 seconds it's almost like half

00:15:19,569 --> 00:15:24,490
as less so you know scratching my head

00:15:22,480 --> 00:15:29,000
it was like wondering why

00:15:24,490 --> 00:15:31,070
and why does why is this so so it's

00:15:29,000 --> 00:15:35,630
actually because of iterating over the

00:15:31,070 --> 00:15:37,579
whole array so rxjs works like a funnel

00:15:35,630 --> 00:15:39,260
whereas arrays are going to have to map

00:15:37,579 --> 00:15:41,660
through that a million elements three

00:15:39,260 --> 00:15:43,250
times well I mean you know five hundred

00:15:41,660 --> 00:15:45,860
thousand because every even number and

00:15:43,250 --> 00:15:48,740
then five hundred thousand and then five

00:15:45,860 --> 00:15:50,540
hundred thousand US but rxjs on the

00:15:48,740 --> 00:15:52,430
other hand you take that number and you

00:15:50,540 --> 00:15:54,040
throw it down the funnel and it gets all

00:15:52,430 --> 00:15:56,180
three operators applied to it right away

00:15:54,040 --> 00:15:58,399
whereas arrays have to actually go

00:15:56,180 --> 00:16:01,519
through those five hundred thousand

00:15:58,399 --> 00:16:02,649
elements three times so that's actually

00:16:01,519 --> 00:16:05,449
where this comes from

00:16:02,649 --> 00:16:07,760
the Rays actually have overhead whereas

00:16:05,449 --> 00:16:10,990
rxjs doesn't have the same overhead

00:16:07,760 --> 00:16:13,040
iterates over all the numbers once and

00:16:10,990 --> 00:16:14,600
that's actually how you can use our

00:16:13,040 --> 00:16:18,279
excess to make your code more performant

00:16:14,600 --> 00:16:18,279
if you have like really large data sets

00:16:18,519 --> 00:16:22,730
so I just want to say thanks everyone

00:16:20,810 --> 00:16:24,170
for coming out this was a much bigger

00:16:22,730 --> 00:16:28,370
turnout I was expecting a crowd of like

00:16:24,170 --> 00:16:31,339
thirty I was over there I was like oh

00:16:28,370 --> 00:16:34,250
wow this is a lot bigger times ten at

00:16:31,339 --> 00:16:35,089
least maybe so Daniel so anything so

00:16:34,250 --> 00:16:36,130
thank you all

00:16:35,089 --> 00:16:42,279
thanks very much

00:16:36,130 --> 00:16:42,279
[Applause]

00:16:57,170 --> 00:17:05,430
look one handed you have any rxjs

00:16:59,670 --> 00:17:08,310
questions we don't so treat it like an

00:17:05,430 --> 00:17:10,290
ama if you want so so how did the reduce

00:17:08,310 --> 00:17:11,820
thing was at the end of the panel sir

00:17:10,290 --> 00:17:13,980
okay guys we can't hear hold on

00:17:11,820 --> 00:17:18,150
go ahead way to the previous example

00:17:13,980 --> 00:17:21,060
that you showed where air is a radiative

00:17:18,150 --> 00:17:22,860
and observers are acting like funnel so

00:17:21,060 --> 00:17:25,320
at the end of the funnel is where you

00:17:22,860 --> 00:17:28,200
have a reduced how do you reduce that to

00:17:25,320 --> 00:17:30,030
a single element where if each

00:17:28,200 --> 00:17:35,910
individual elements are coming one by

00:17:30,030 --> 00:17:37,260
one I think I get it like how the reduce

00:17:35,910 --> 00:17:40,470
will work because the oddness are coming

00:17:37,260 --> 00:17:42,300
one by one yeah so the reduced will fire

00:17:40,470 --> 00:17:43,890
with a default value start value and

00:17:42,300 --> 00:17:45,330
then after the second iteration it

00:17:43,890 --> 00:17:50,310
starts getting the previous value but

00:17:45,330 --> 00:17:53,580
basically like the D for a yeah okay

00:17:50,310 --> 00:17:56,040
so yes you want to take this so he asked

00:17:53,580 --> 00:17:57,840
how the reduced will work at the very

00:17:56,040 --> 00:17:59,940
end because we're piping a bunch of

00:17:57,840 --> 00:18:03,180
different operators we have the map

00:17:59,940 --> 00:18:04,890
filter and a reduce but we've are

00:18:03,180 --> 00:18:06,600
actually as stages that you get one

00:18:04,890 --> 00:18:08,160
element at a time and the reduced needs

00:18:06,600 --> 00:18:13,070
two elements because it's always the

00:18:08,160 --> 00:18:13,070
previous and the next we share combining

00:18:14,090 --> 00:18:19,200
so how that that works I don't know

00:18:17,310 --> 00:18:22,440
exactly how internally our task will

00:18:19,200 --> 00:18:24,720
handle that but your reducer will

00:18:22,440 --> 00:18:27,510
receive both values the current in the

00:18:24,720 --> 00:18:29,640
previous at the start so you probably

00:18:27,510 --> 00:18:31,200
start with some no previous value and

00:18:29,640 --> 00:18:32,850
the current is the first element you're

00:18:31,200 --> 00:18:35,220
getting in and after the second

00:18:32,850 --> 00:18:37,860
iteration your next value will be the

00:18:35,220 --> 00:18:39,060
previous and you start getting actually

00:18:37,860 --> 00:18:40,530
I think maybe you're talking about

00:18:39,060 --> 00:18:42,240
because how is it going to reduce

00:18:40,530 --> 00:18:43,800
because like every single number is

00:18:42,240 --> 00:18:45,990
going to come through the SUBSCRIBE is

00:18:43,800 --> 00:18:47,640
that what you're saying yeah yeah

00:18:45,990 --> 00:18:50,120
because it takes all the numbers and it

00:18:47,640 --> 00:18:53,250
does it on complete so reduce actually

00:18:50,120 --> 00:18:55,520
won't continue on until all the numbers

00:18:53,250 --> 00:18:57,660
come through it so it's more of like a

00:18:55,520 --> 00:18:59,040
like normally you take a font like a

00:18:57,660 --> 00:19:00,090
number and you put it through the bundle

00:18:59,040 --> 00:19:01,920
and it comes out the other end you'll

00:19:00,090 --> 00:19:04,310
get much multiples but like reduce

00:19:01,920 --> 00:19:05,780
actually combines all them into one

00:19:04,310 --> 00:19:07,520
does that make sense there's a few

00:19:05,780 --> 00:19:09,410
operators like that like two arrays and

00:19:07,520 --> 00:19:11,180
instead of firing on every single number

00:19:09,410 --> 00:19:13,130
it waits until like the previous is all

00:19:11,180 --> 00:19:16,570
complete and then it actually bunches

00:19:13,130 --> 00:19:16,570
them together and does that for you I

00:19:17,680 --> 00:19:29,080
can't hear you but you can you can

00:19:30,400 --> 00:19:35,210
neural map map those two so there's only

00:19:32,870 --> 00:19:37,610
a few special arguments special things

00:19:35,210 --> 00:19:39,770
that will actually do kind of a non

00:19:37,610 --> 00:19:41,780
complete things so they in an array

00:19:39,770 --> 00:19:44,180
returns the entire array like when you

00:19:41,780 --> 00:19:45,950
do like the top filter on an array so

00:19:44,180 --> 00:19:48,140
there's a few operators like that to

00:19:45,950 --> 00:19:51,820
array is one of them reduces one of them

00:19:48,140 --> 00:19:55,310
if you want the non it's not the non

00:19:51,820 --> 00:19:56,900
array like version if you want the non

00:19:55,310 --> 00:19:58,460
array like version of reduced and you

00:19:56,900 --> 00:20:10,160
want to use the scan

00:19:58,460 --> 00:20:12,050
I think it's scan right the array yeah

00:20:10,160 --> 00:20:13,910
it's the exact same thing except for

00:20:12,050 --> 00:20:16,280
we're not going to return an entirely

00:20:13,910 --> 00:20:18,740
new array or because like it's only

00:20:16,280 --> 00:20:20,150
retiring returning a new element so

00:20:18,740 --> 00:20:22,070
archaea it's like more it's like

00:20:20,150 --> 00:20:23,810
operations on one element and then it

00:20:22,070 --> 00:20:26,300
keeps feeding those elements at the very

00:20:23,810 --> 00:20:27,740
end but so it's more like that it'll map

00:20:26,300 --> 00:20:29,840
over it so and like while you make a

00:20:27,740 --> 00:20:32,570
change but it's it'll do one element at

00:20:29,840 --> 00:20:34,190
a time make if we reduce I don't know if

00:20:32,570 --> 00:20:36,200
you have the FIFO argument because the

00:20:34,190 --> 00:20:38,090
regular reduced function prime VM you

00:20:36,200 --> 00:20:39,830
have the last argument you say sorry pal

00:20:38,090 --> 00:20:42,530
you want to give it I'm not sure if I

00:20:39,830 --> 00:20:44,600
dressed as that but it basically works

00:20:42,530 --> 00:20:46,400
exactly the same way you get it no value

00:20:44,600 --> 00:20:50,510
for the first iteration and you get

00:20:46,400 --> 00:20:53,599
those ballots thereafter like then yeah

00:20:50,510 --> 00:20:53,599

YouTube URL: https://www.youtube.com/watch?v=TszoFCFydiM


