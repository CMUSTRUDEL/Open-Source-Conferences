Title: Flock 2016 - Secure Automated Decryption, Nathaniel McCallum
Publication date: 2016-08-21
Playlist: Flock 2016
Description: 
	(This recording was on a laptop with a defective microphone. Unfortunately, it does not seem like the audio is able to be restored. Please refer to the slides and transcription for the talk, if available.)

Keeping secrets is tough. It is hard enough when you have control over the full computing chain. But now we are expected to keep secrets while storing those secrets in cloud and SaaS infrastructures. At least we can trust the network providers, right? Of course, the answer is to encrypt the data. But then how do we know who should have access to the data and when? This talk will look at the new cryptographic techniques implemented by the Tang and Clevis open source projects. Tang forgoes complex (and compromise-prone) key management infrastructures by using simple algorithms to bind data to third party entities. Clevis permits sophisticated unlocking policies that go beyond simply password management to true attributed cryptography. Come see how to integrate Tang and Clevis into your infrastructure or software project!

https://flock2016.sched.org/event/76mr/secure-automated-decryption

This video was recorded at the annual Fedora contributor conference, Flock, in KrakÃ³w, Poland, from August 2-5, 2016. You can learn more about Flock at https://flocktofedora.org.

#FlockToFedora

Transcription: https://meetbot.fedoraproject.org/fedora-flock-openqa/2016-08-03/secure,_automated_decryption.2016-08-03-08.59.log.html
Captions: 
	00:00:04,339 --> 00:00:10,469
iroquois how everybody my name is

00:00:08,280 --> 00:00:12,090
Nathaniel McCollum's principal software

00:00:10,469 --> 00:00:14,330
engineer at Red Hat and we'll be talking

00:00:12,090 --> 00:00:16,680
about secure all matted decryption I

00:00:14,330 --> 00:00:20,189
would ask for you to bear with me a

00:00:16,680 --> 00:00:21,990
little bit my talk and slides are so

00:00:20,189 --> 00:00:23,939
hosted on a hosting provider and

00:00:21,990 --> 00:00:26,939
apparently there are whole days that I

00:00:23,939 --> 00:00:29,359
went down that had like massive

00:00:26,939 --> 00:00:32,250
catastrophic power failures and

00:00:29,359 --> 00:00:34,620
fortunately they actually are piping the

00:00:32,250 --> 00:00:36,750
recovery process life right on the right

00:00:34,620 --> 00:00:39,210
on the rug so you can actually see they

00:00:36,750 --> 00:00:44,700
this is what they're getting the way is

00:00:39,210 --> 00:00:47,160
just more okay obviously my example is a

00:00:44,700 --> 00:00:50,370
little bit facetious but it is real

00:00:47,160 --> 00:00:53,460
right and that is as we start to deploy

00:00:50,370 --> 00:00:55,829
the cushion at scale the question is how

00:00:53,460 --> 00:00:57,899
do we automate this process because we

00:00:55,829 --> 00:01:00,510
can't do it in manual way we've been

00:00:57,899 --> 00:01:03,480
used to doing it in the past but with

00:01:00,510 --> 00:01:06,840
automation also comes news 30 challenges

00:01:03,480 --> 00:01:09,240
so the the top of the title is top of

00:01:06,840 --> 00:01:11,720
course is a secure automated description

00:01:09,240 --> 00:01:13,610
and you are going to be talking about

00:01:11,720 --> 00:01:15,570
various different methods that are used

00:01:13,610 --> 00:01:18,330
so the first question we're going to

00:01:15,570 --> 00:01:21,360
come to is how you automate this and of

00:01:18,330 --> 00:01:23,580
course the answer is yes first we have

00:01:21,360 --> 00:01:25,860
with the secret here this is the data we

00:01:23,580 --> 00:01:27,880
want to protect and usually the way this

00:01:25,860 --> 00:01:29,649
is this is valid is

00:01:27,880 --> 00:01:32,229
first encrypted with an encryption key

00:01:29,649 --> 00:01:34,210
now this is not the key to you directly

00:01:32,229 --> 00:01:35,710
so this is not the password for instance

00:01:34,210 --> 00:01:37,570
that you take this is a

00:01:35,710 --> 00:01:39,460
cryptographically strong he'll it

00:01:37,570 --> 00:01:42,250
protects the data and then that we

00:01:39,460 --> 00:01:44,350
actually do is we encrypt the encryption

00:01:42,250 --> 00:01:46,780
key in another team called the key

00:01:44,350 --> 00:01:49,179
encryption key again this wrapping

00:01:46,780 --> 00:01:51,670
process or sealing process all of these

00:01:49,179 --> 00:01:53,439
terminologies for the same thing are

00:01:51,670 --> 00:01:55,630
basically allow you to change the outer

00:01:53,439 --> 00:01:58,390
key without having to change the inner

00:01:55,630 --> 00:01:59,860
key because if you have Tara beds where

00:01:58,390 --> 00:02:01,929
the day letter you don't want to have to

00:01:59,860 --> 00:02:04,270
change that in Turkey and then reinstall

00:02:01,929 --> 00:02:06,220
your data so in the orpheum of

00:02:04,270 --> 00:02:08,349
vulnerability in the outer key you can

00:02:06,220 --> 00:02:10,269
simply choose the other key really

00:02:08,349 --> 00:02:12,790
crispy in Turkey and your game is

00:02:10,269 --> 00:02:15,340
protected so it took this is where your

00:02:12,790 --> 00:02:17,140
typical password comes in right you have

00:02:15,340 --> 00:02:19,209
that password and that's actually the

00:02:17,140 --> 00:02:22,480
key encryption key usually arises in

00:02:19,209 --> 00:02:24,130
some some sense and this is sort of a

00:02:22,480 --> 00:02:25,239
stainless console model plus we

00:02:24,130 --> 00:02:27,130
distributed out to all these different

00:02:25,239 --> 00:02:29,170
people and now all these people have

00:02:27,130 --> 00:02:31,690
access to the data and that man that

00:02:29,170 --> 00:02:33,900
leaves the company you can't manage that

00:02:31,690 --> 00:02:36,940
right so we have a hair automation

00:02:33,900 --> 00:02:38,890
problem there an even better option

00:02:36,940 --> 00:02:39,610
would be of course to to generate

00:02:38,890 --> 00:02:44,530
something that has

00:02:39,610 --> 00:02:46,330
or entropy for the outer key and then we

00:02:44,530 --> 00:02:48,070
sort of have a standard escrow model and

00:02:46,330 --> 00:02:49,870
this is what you're typically seeing the

00:02:48,070 --> 00:02:52,240
played in a lot of places this is

00:02:49,870 --> 00:02:54,100
actually showing up in standards it's

00:02:52,240 --> 00:02:56,740
showing up in various different tech

00:02:54,100 --> 00:02:58,810
proposals and even there's some

00:02:56,740 --> 00:03:01,090
regulations that are talking about this

00:02:58,810 --> 00:03:03,550
sort of SQL model so we're done right

00:03:01,090 --> 00:03:04,840
we've described automate secure

00:03:03,550 --> 00:03:09,400
automated decryption we can all go home

00:03:04,840 --> 00:03:11,590
right well not great because the problem

00:03:09,400 --> 00:03:15,610
is we actually also have to protect the

00:03:11,590 --> 00:03:17,860
transport layer so we have a TLS or

00:03:15,610 --> 00:03:20,500
Jesus API which we are using to encrypt

00:03:17,860 --> 00:03:23,590
the transfer of the key from the escrow

00:03:20,500 --> 00:03:26,220
back to the server that's or the client

00:03:23,590 --> 00:03:29,380
that's going to perform the decryption

00:03:26,220 --> 00:03:32,020
and of course this is secured by a key

00:03:29,380 --> 00:03:33,910
on each end because you have to have

00:03:32,020 --> 00:03:36,489
authentication now that the key is

00:03:33,910 --> 00:03:38,709
getting stored 80s grow you can't just

00:03:36,489 --> 00:03:40,660
let anybody get that key right so the

00:03:38,709 --> 00:03:42,670
server has to prove who it is or the

00:03:40,660 --> 00:03:45,370
client has to prove who it is in order

00:03:42,670 --> 00:03:46,900
to get the key from the escrow and so

00:03:45,370 --> 00:03:49,239
now you have mutual authentication I'm

00:03:46,900 --> 00:03:53,410
go and settle at least finally we're on

00:03:49,239 --> 00:03:55,480
right No so there's actually more

00:03:53,410 --> 00:03:57,519
process right because in other daily

00:03:55,480 --> 00:04:00,700
keys for authentication we have to have

00:03:57,519 --> 00:04:03,040
a third party authority which is usually

00:04:00,700 --> 00:04:05,790
in the form i love using juices api it's

00:04:03,040 --> 00:04:08,680
like a KDC for instance Active Directory

00:04:05,790 --> 00:04:11,110
earlier using certificates for TLS you

00:04:08,680 --> 00:04:14,739
have a certification authority so now

00:04:11,110 --> 00:04:16,739
about a picture a medal because remember

00:04:14,739 --> 00:04:19,049
we're storing all

00:04:16,739 --> 00:04:23,190
yes though so we still have to back up

00:04:19,049 --> 00:04:25,620
all of this data and key data is kind of

00:04:23,190 --> 00:04:28,680
sensitive so you don't want to just back

00:04:25,620 --> 00:04:30,810
it up in clear text so now you also have

00:04:28,680 --> 00:04:34,080
the heart big problem that we transfer

00:04:30,810 --> 00:04:37,880
all of these keys over there and also

00:04:34,080 --> 00:04:40,830
our TLS is completely useless helpless

00:04:37,880 --> 00:04:44,039
okay so this is sort of the mountain

00:04:40,830 --> 00:04:45,870
that everybody's doing and we recognize

00:04:44,039 --> 00:04:47,430
that there are some security challenges

00:04:45,870 --> 00:04:49,080
with it and we want to see you we're

00:04:47,430 --> 00:04:51,030
going to gradually unfold some different

00:04:49,080 --> 00:04:53,090
methodologies and we're going to see

00:04:51,030 --> 00:04:56,340
what we can do to solve these problems

00:04:53,090 --> 00:04:58,050
so let's quickly you some of our lessons

00:04:56,340 --> 00:04:59,849
we've learned first one is the

00:04:58,050 --> 00:05:02,220
complexity increases the attack surface

00:04:59,849 --> 00:05:04,139
right so every time we added a little

00:05:02,220 --> 00:05:07,110
bit of complexity in that extra models

00:05:04,139 --> 00:05:11,220
we add in another place to fail another

00:05:07,110 --> 00:05:14,159
place to leave keys right this is also

00:05:11,220 --> 00:05:17,580
difficult to deploy and we also learn

00:05:14,159 --> 00:05:19,949
that speed matters if you think in the

00:05:17,580 --> 00:05:21,630
case of the database the exact way they

00:05:19,949 --> 00:05:23,400
were the beginning of this talk if

00:05:21,630 --> 00:05:25,289
you've got a data center full of

00:05:23,400 --> 00:05:28,169
thousands of machines all coming up at

00:05:25,289 --> 00:05:33,210
the same time all morning keys all right

00:05:28,169 --> 00:05:36,180
speed matters so can a symmetric repel

00:05:33,210 --> 00:05:38,430
and the answer is actually yes we

00:05:36,180 --> 00:05:40,030
started a project called play-doh this

00:05:38,430 --> 00:05:43,920
was actually washed

00:05:40,030 --> 00:05:46,450
and essentially what we did was we

00:05:43,920 --> 00:05:49,240
decided that we would take the key in

00:05:46,450 --> 00:05:51,280
community and cook that again using a

00:05:49,240 --> 00:05:53,950
public key encryption and then just

00:05:51,280 --> 00:05:55,780
start locally ok so the crypt of the

00:05:53,950 --> 00:05:57,700
king curtain key is encrypted again with

00:05:55,780 --> 00:06:00,670
you using asymmetrical toe and store the

00:05:57,700 --> 00:06:03,160
locals then during recovery time when we

00:06:00,670 --> 00:06:05,710
want to get the key back we would send

00:06:03,160 --> 00:06:07,540
the encrypted law to the server and we

00:06:05,710 --> 00:06:08,830
would get back the plane to put index

00:06:07,540 --> 00:06:11,680
key now this had some very nice

00:06:08,830 --> 00:06:13,780
advantages in terms of state permissive

00:06:11,680 --> 00:06:15,310
because it was not stateful we could

00:06:13,780 --> 00:06:16,660
actually start with a locally the server

00:06:15,310 --> 00:06:20,050
didn't need to know this to all this

00:06:16,660 --> 00:06:23,560
data but we still didn't have to

00:06:20,050 --> 00:06:25,000
authenticate the connections and and we

00:06:23,560 --> 00:06:27,520
had to protect the channel of course

00:06:25,000 --> 00:06:29,680
because we were transferring key back in

00:06:27,520 --> 00:06:31,600
plain text we had to flick the channel

00:06:29,680 --> 00:06:34,090
we still have a certification authority

00:06:31,600 --> 00:06:35,790
we still have the backups issue and we

00:06:34,090 --> 00:06:38,020
did learn some lessons from this project

00:06:35,790 --> 00:06:39,580
remember the asymmetric crypto mix the

00:06:38,020 --> 00:06:41,320
server state list which is probably the

00:06:39,580 --> 00:06:44,440
most important thing that we can learn

00:06:41,320 --> 00:06:46,630
from this asymmetric crypto also allows

00:06:44,440 --> 00:06:48,820
for offline provisioning which has some

00:06:46,630 --> 00:06:51,460
really interesting use cases say when

00:06:48,820 --> 00:06:53,320
you're trying to speed up deployment you

00:06:51,460 --> 00:06:54,670
want to bring up thousands of servers

00:06:53,320 --> 00:06:56,830
quickly to handle some

00:06:54,670 --> 00:06:59,440
you can actually do the entire

00:06:56,830 --> 00:07:00,910
provisioning offline because you don't

00:06:59,440 --> 00:07:04,180
need to contact the server for anything

00:07:00,910 --> 00:07:07,270
as long as the client knows the service

00:07:04,180 --> 00:07:09,250
public key I lasted I'm that sending the

00:07:07,270 --> 00:07:10,810
keys over the wire is still a risk we

00:07:09,250 --> 00:07:12,760
also learned that x 5mm takes a lot of

00:07:10,810 --> 00:07:14,230
that for me this is in fact the last

00:07:12,760 --> 00:07:17,650
item is the reason why we killed the

00:07:14,230 --> 00:07:19,870
project we designed it influences of

00:07:17,650 --> 00:07:21,490
this fairly simple and it worked but a

00:07:19,870 --> 00:07:23,590
lot of people have a lot of the full

00:07:21,490 --> 00:07:26,140
time deploying it just around management

00:07:23,590 --> 00:07:29,170
of x.509 certificates and so we wanted

00:07:26,140 --> 00:07:31,420
to see if we could argue better so let's

00:07:29,170 --> 00:07:34,960
ask some more questions our first can we

00:07:31,420 --> 00:07:37,480
avoid TLS altogether because TLS is a

00:07:34,960 --> 00:07:39,070
pretty compact stack we start going to

00:07:37,480 --> 00:07:41,350
need to use encryption of course because

00:07:39,070 --> 00:07:44,020
we do need to keep things secret but if

00:07:41,350 --> 00:07:46,210
we can limit all of the options that TLS

00:07:44,020 --> 00:07:48,220
gives us in which we could fail down to

00:07:46,210 --> 00:07:50,620
just a few manageable options we have a

00:07:48,220 --> 00:07:52,480
much smaller attack circus the second

00:07:50,620 --> 00:07:54,820
question is can we hide the key from the

00:07:52,480 --> 00:07:59,200
server so that the server itself never

00:07:54,820 --> 00:08:01,300
sees the key and we can so we're going

00:07:59,200 --> 00:08:03,790
to use a mode that I'll have to call

00:08:01,300 --> 00:08:05,620
wrapping married so if you go back to

00:08:03,790 --> 00:08:08,170
remember that that gonna circle the

00:08:05,620 --> 00:08:09,940
outer one the key encryption key is now

00:08:08,170 --> 00:08:10,430
in the middle of this so what we do is

00:08:09,940 --> 00:08:12,530
with

00:08:10,430 --> 00:08:17,150
another symmetric-key called the rocky

00:08:12,530 --> 00:08:21,230
and then we encrypt that blog using the

00:08:17,150 --> 00:08:23,510
server t then we keep the book the

00:08:21,230 --> 00:08:25,790
resulting encrypted blog and we keep the

00:08:23,510 --> 00:08:27,920
wrap key that notice that because the

00:08:25,790 --> 00:08:30,740
client does not have the service private

00:08:27,920 --> 00:08:33,260
key that cannot decrypt this material so

00:08:30,740 --> 00:08:34,670
once you've encrypted leary volume using

00:08:33,260 --> 00:08:36,500
your key encryption key you throw away

00:08:34,670 --> 00:08:37,880
the key encryption key and then you

00:08:36,500 --> 00:08:41,030
don't have it anymore and you need to

00:08:37,880 --> 00:08:43,520
get it back so then at the current time

00:08:41,030 --> 00:08:46,730
what you do is you generate a second key

00:08:43,520 --> 00:08:49,220
called the ephemeral p and you encrypt

00:08:46,730 --> 00:08:52,340
this again using the server keys we have

00:08:49,220 --> 00:08:54,800
two layers actual has multiple any of

00:08:52,340 --> 00:08:56,990
them the key encryption key in metal rap

00:08:54,800 --> 00:08:59,210
key is encrypted is used to encrypt that

00:08:56,990 --> 00:09:02,180
the server is asymmetric key is used to

00:08:59,210 --> 00:09:04,070
encrypt that then we have the laptop

00:09:02,180 --> 00:09:06,170
plus the affair monkey in another layer

00:09:04,070 --> 00:09:10,240
of encryption and then we can send this

00:09:06,170 --> 00:09:13,040
to the server over the layer without TLS

00:09:10,240 --> 00:09:15,860
now the server is going to get this big

00:09:13,040 --> 00:09:18,680
packet and it has its own servers

00:09:15,860 --> 00:09:22,390
private key so it can use that to

00:09:18,680 --> 00:09:26,270
decrypt both layers and just the

00:09:22,390 --> 00:09:28,010
encrypted kikikiki why would you still

00:09:26,270 --> 00:09:31,100
can't see it can only see the encrypted

00:09:28,010 --> 00:09:33,410
pod right and it has the ephemeral p so

00:09:31,100 --> 00:09:35,930
then it takes the ephemeral key encrypts

00:09:33,410 --> 00:09:39,860
the resulting blob and then sends it

00:09:35,930 --> 00:09:42,680
back to the client the client of course

00:09:39,860 --> 00:09:44,540
has both keys so now the client could

00:09:42,680 --> 00:09:47,090
simply unwrap the ephemeral

00:09:44,540 --> 00:09:49,010
unwrap the rocky and get back the key

00:09:47,090 --> 00:09:50,930
encryption key and perform the person

00:09:49,010 --> 00:09:53,450
and so let me just done now is we've

00:09:50,930 --> 00:09:55,850
accomplished two things first we have

00:09:53,450 --> 00:09:56,990
completely obviated the need for TLS we

00:09:55,850 --> 00:09:59,210
don't need two LS and all the

00:09:56,990 --> 00:10:02,510
descendants over UDP packet if you want

00:09:59,210 --> 00:10:04,670
and and then the second thing is that

00:10:02,510 --> 00:10:06,860
the key server barely saw on a trip to

00:10:04,670 --> 00:10:10,190
blog okay it never actually saw the

00:10:06,860 --> 00:10:12,140
actual key encryption key which is a

00:10:10,190 --> 00:10:14,720
really nice feature because it means

00:10:12,140 --> 00:10:17,600
that somebody can't just sit there and

00:10:14,720 --> 00:10:19,280
collect keys that can cross the ocean

00:10:17,600 --> 00:10:21,980
blobs but then they would also have to

00:10:19,280 --> 00:10:25,900
compromise the client in order to to get

00:10:21,980 --> 00:10:30,260
the rap key so this is a freedom model

00:10:25,900 --> 00:10:31,490
we write this over it's what has a lot

00:10:30,260 --> 00:10:33,110
of nice features the server never sees

00:10:31,490 --> 00:10:35,510
that keep the king caption key we avoid

00:10:33,110 --> 00:10:37,760
x509 we avoid pls it's stateless and

00:10:35,510 --> 00:10:41,000
it's fast so these are all really great

00:10:37,760 --> 00:10:43,460
things one of the things i didn't put on

00:10:41,000 --> 00:10:45,380
here is that this method is actually

00:10:43,460 --> 00:10:47,120
very easy to migrate to post quantum

00:10:45,380 --> 00:10:49,820
crypto right because this is one of the

00:10:47,120 --> 00:10:51,560
major concerns that's coming up it is

00:10:49,820 --> 00:10:54,560
how we move to a post-punk you crypto

00:10:51,560 --> 00:10:56,870
role and this is very straightforward to

00:10:54,560 --> 00:10:58,520
me we just 80s for instance and

00:10:56,870 --> 00:11:00,230
symmetric keys are not part of

00:10:58,520 --> 00:11:02,420
corresponds of crypto we believe these

00:11:00,230 --> 00:11:04,490
to be secure quantum computers don't

00:11:02,420 --> 00:11:07,040
don't hurt me think it's only the public

00:11:04,490 --> 00:11:08,780
keys right so as long as we get some

00:11:07,040 --> 00:11:11,000
kind of public key encryption in no

00:11:08,780 --> 00:11:12,440
swamp and crypto we're fine to use this

00:11:11,000 --> 00:11:16,160
model I know we'll continue to work in

00:11:12,440 --> 00:11:18,020
the future but still we believe we can

00:11:16,160 --> 00:11:21,200
we can accomplish some other features as

00:11:18,020 --> 00:11:24,680
well remember one must the key actually

00:11:21,200 --> 00:11:26,690
go on the water and number two can

00:11:24,680 --> 00:11:27,699
clients be anonymous and the reason

00:11:26,690 --> 00:11:30,609
you're asking is

00:11:27,699 --> 00:11:33,129
the server in the last example never saw

00:11:30,609 --> 00:11:35,579
the key encryption key but it still saw

00:11:33,129 --> 00:11:38,350
a blob an encrypted Robert didn't change

00:11:35,579 --> 00:11:40,959
okay so it can use that encrypted block

00:11:38,350 --> 00:11:42,399
for traction or clients for instance but

00:11:40,959 --> 00:11:45,299
one of the question you wanted that ask

00:11:42,399 --> 00:11:49,480
is can we do secure alternative

00:11:45,299 --> 00:11:50,919
decryption that is more FML in which you

00:11:49,480 --> 00:11:53,290
could you know just be walking around

00:11:50,919 --> 00:11:56,109
and have access to an access point for

00:11:53,290 --> 00:11:58,749
instance is be able to transiently

00:11:56,109 --> 00:12:00,459
decrypt some data without that server

00:11:58,749 --> 00:12:03,009
even though who you are not having any

00:12:00,459 --> 00:12:05,199
idea so we actually can do this as well

00:12:03,009 --> 00:12:09,009
this is standard elven all encryption

00:12:05,199 --> 00:12:12,189
and if anyone dies for fear of math I

00:12:09,009 --> 00:12:14,319
don't blame you steroid ethanol

00:12:12,189 --> 00:12:19,389
encryption there's nothing fancy about

00:12:14,319 --> 00:12:21,939
this but what a Manhattan myself brought

00:12:19,389 --> 00:12:24,069
real yang how we came up with a very

00:12:21,939 --> 00:12:27,040
into this so notice that on the left

00:12:24,069 --> 00:12:29,769
hand side I go back nothing actually

00:12:27,040 --> 00:12:32,319
changes the Padma left hand side we're

00:12:29,769 --> 00:12:36,249
only changing the decryption step here

00:12:32,319 --> 00:12:39,549
in using this algorithm we come up with

00:12:36,249 --> 00:12:42,579
couple interesting properties and the

00:12:39,549 --> 00:12:45,220
first is that the server only ever sees

00:12:42,579 --> 00:12:47,379
random data over time it's random over

00:12:45,220 --> 00:12:49,899
time so the server never gives anything

00:12:47,379 --> 00:12:52,660
statically can identify the point with

00:12:49,899 --> 00:12:55,179
the client is completely anonymous only

00:12:52,660 --> 00:12:58,410
because this is a key exchange not if

00:12:55,179 --> 00:13:01,040
not encryption we are essentially never

00:12:58,410 --> 00:13:04,170
over the web so it's like a dippy help

00:13:01,040 --> 00:13:07,410
okay so this is even who has some better

00:13:04,170 --> 00:13:09,180
security properties and we have a server

00:13:07,410 --> 00:13:10,980
called hang over here on the right and

00:13:09,180 --> 00:13:14,490
essentially we take the key encryption

00:13:10,980 --> 00:13:16,379
key and we just use the key exchange to

00:13:14,490 --> 00:13:18,079
generate a key encryption key which we

00:13:16,379 --> 00:13:22,500
can always been really regenerate

00:13:18,079 --> 00:13:27,300
automatically we still kind of need

00:13:22,500 --> 00:13:29,310
backups here but we can avoid backups by

00:13:27,300 --> 00:13:32,160
using tpn and actually just burning the

00:13:29,310 --> 00:13:34,439
car keys in the chips and in this case

00:13:32,160 --> 00:13:36,689
you burn the service private key into

00:13:34,439 --> 00:13:39,000
the chip the server becomes completely

00:13:36,689 --> 00:13:40,769
stateless there's literally nothing

00:13:39,000 --> 00:13:43,319
stored on the hard drive nothing backed

00:13:40,769 --> 00:13:46,259
up and you can't recover the key so you

00:13:43,319 --> 00:13:49,019
can do this in a very very footprints so

00:13:46,259 --> 00:13:51,569
as we've been even twenty with ideas

00:13:49,019 --> 00:13:53,189
like with Richard beacons right where

00:13:51,569 --> 00:13:54,360
you could have data that's encrypted on

00:13:53,189 --> 00:13:55,920
your phone and when you're in range with

00:13:54,360 --> 00:13:58,259
Bluetooth beacons can decrypt it when

00:13:55,920 --> 00:14:00,060
you walk the way you came so very very

00:13:58,259 --> 00:14:02,189
lightweight very very small very very

00:14:00,060 --> 00:14:04,949
fast so we have a product that

00:14:02,189 --> 00:14:08,430
implements this the product is called

00:14:04,949 --> 00:14:10,380
tang and you can see this organization

00:14:08,430 --> 00:14:13,329
last set you're going to see this pretty

00:14:10,380 --> 00:14:17,350
frequently this is an order

00:14:13,329 --> 00:14:19,269
that several of the crypto guys in red

00:14:17,350 --> 00:14:21,819
hat have created in a has various

00:14:19,269 --> 00:14:22,959
cryptography related projects so even

00:14:21,819 --> 00:14:24,790
with sizes that we're going to talk

00:14:22,959 --> 00:14:27,069
about here just imagine if that's an

00:14:24,790 --> 00:14:31,649
interesting style so this is the server

00:14:27,069 --> 00:14:35,649
side Damon it's simple HTTP and Jose

00:14:31,649 --> 00:14:37,540
Jose is anybody knows Jason Webb

00:14:35,649 --> 00:14:39,869
encryption never heard that Jason Weber

00:14:37,540 --> 00:14:43,029
Christian Jason Webb signing Jose is a

00:14:39,869 --> 00:14:46,029
Jason object signing and encryption ok

00:14:43,029 --> 00:14:47,949
so the the medicine levis is that we're

00:14:46,029 --> 00:14:50,649
using completely standard formats this

00:14:47,949 --> 00:14:53,049
is a standard HTTP request and this is a

00:14:50,649 --> 00:14:55,989
standard Jason encryption object so

00:14:53,049 --> 00:14:59,139
nothing nothing proprietary here no no

00:14:55,989 --> 00:15:02,769
funding structures this is really really

00:14:59,139 --> 00:15:05,949
fast so I was able to benchmark with a

00:15:02,769 --> 00:15:07,540
single TCP connection we can just you

00:15:05,949 --> 00:15:10,299
can just cramming your quests in the

00:15:07,540 --> 00:15:11,439
server on a standard desktop laptop you

00:15:10,299 --> 00:15:13,929
can get about a hundred thousand

00:15:11,439 --> 00:15:16,779
requests a second which is sufficient

00:15:13,929 --> 00:15:20,199
for lo harÃ© hardware it's sufficient for

00:15:16,779 --> 00:15:22,149
you know for large-scale deployments so

00:15:20,199 --> 00:15:25,449
work shouldn't fast were extremely ball

00:15:22,149 --> 00:15:29,049
small have minimal dependencies our only

00:15:25,449 --> 00:15:31,839
server-side dependencies are HTTP parser

00:15:29,049 --> 00:15:33,819
which is just a small HTTP crossing

00:15:31,839 --> 00:15:37,660
library really tiny eggs two files and

00:15:33,819 --> 00:15:39,819
then the library is going to talk about

00:15:37,660 --> 00:15:43,629
at the end of this talk for during the

00:15:39,819 --> 00:15:45,610
josÃ© encryption so let's continue ask

00:15:43,629 --> 00:15:48,489
you some more questions a rhythm of

00:15:45,610 --> 00:15:49,089
things can we buy more data to like we

00:15:48,489 --> 00:15:51,279
learning

00:15:49,089 --> 00:15:53,559
destroy the standard SQL case where

00:15:51,279 --> 00:15:55,240
you've got a client and the server but

00:15:53,559 --> 00:15:57,550
really we kind of develop some new

00:15:55,240 --> 00:15:59,680
technologies here so let's let's think

00:15:57,550 --> 00:16:01,180
more broadly about what other kinds of

00:15:59,680 --> 00:16:04,540
endpoints we could actually bind our

00:16:01,180 --> 00:16:05,920
data to obviously the TPM is one you

00:16:04,540 --> 00:16:08,769
could actually bind data to your local

00:16:05,920 --> 00:16:10,540
TPM you could bind it to a Bluetooth

00:16:08,769 --> 00:16:12,639
beacon which I mentioned you can do

00:16:10,540 --> 00:16:15,309
something like say generate a random key

00:16:12,639 --> 00:16:17,290
and then print a QR code and then when

00:16:15,309 --> 00:16:19,540
you need to access it just hold the key

00:16:17,290 --> 00:16:21,279
operative camera you can do facial

00:16:19,540 --> 00:16:23,290
recognition fingerprint scan mobile

00:16:21,279 --> 00:16:25,569
phones smart phones off IDs all these

00:16:23,290 --> 00:16:28,749
different kinds of implants that you can

00:16:25,569 --> 00:16:30,490
enjoy I need attitude and what are

00:16:28,749 --> 00:16:32,379
things this is this quote is from Josh

00:16:30,490 --> 00:16:34,720
bachelors off from his security talk at

00:16:32,379 --> 00:16:36,009
that comp and I love the script I keep

00:16:34,720 --> 00:16:38,740
coming back to it over and over again

00:16:36,009 --> 00:16:41,499
security is not a binary it's a sliding

00:16:38,740 --> 00:16:43,959
scale of risk management but very often

00:16:41,499 --> 00:16:46,329
in photography we just deal with the

00:16:43,959 --> 00:16:50,379
binary right is it secure or is it not

00:16:46,329 --> 00:16:52,899
in fact allowing us to have multiple

00:16:50,379 --> 00:16:55,559
things which we burn to allows us to

00:16:52,899 --> 00:16:58,720
have a sliding scale of risk management

00:16:55,559 --> 00:17:03,939
so the question is how do we make our

00:16:58,720 --> 00:17:06,399
unlock policy non-binding there's this

00:17:03,939 --> 00:17:08,370
big girl algorithm that's shamir secret

00:17:06,399 --> 00:17:12,939
sharing anybody knows who Cheniere is

00:17:08,370 --> 00:17:14,649
he's the US in RSA okay so he made this

00:17:12,939 --> 00:17:16,299
algorithm culture music to chang and

00:17:14,649 --> 00:17:18,069
it's a fresh running a villain it allows

00:17:16,299 --> 00:17:20,230
you to take a key and you can

00:17:18,069 --> 00:17:21,819
essentially split up into into five

00:17:20,230 --> 00:17:23,679
different parts which I've shown here

00:17:21,819 --> 00:17:26,439
are the number of parts is it could be

00:17:23,679 --> 00:17:27,539
any number depending on your key size

00:17:26,439 --> 00:17:30,989
and

00:17:27,539 --> 00:17:32,549
petrol and basically your petrol

00:17:30,989 --> 00:17:35,279
determines how many of these key

00:17:32,549 --> 00:17:39,840
fragments are required in order to

00:17:35,279 --> 00:17:43,169
regenerate the resulting key you can

00:17:39,840 --> 00:17:45,359
also miss this right so you're the key

00:17:43,169 --> 00:17:46,679
here that's fragmented and then you can

00:17:45,359 --> 00:17:49,889
take that middle q you could fragments

00:17:46,679 --> 00:17:51,869
it again with a second threshold so

00:17:49,889 --> 00:17:56,580
we're going to use this technique to

00:17:51,869 --> 00:17:59,519
design non-binary security guys so

00:17:56,580 --> 00:18:00,779
noticeable laptop right and now i'm not

00:17:59,519 --> 00:18:01,919
talking about your home laptop here

00:18:00,779 --> 00:18:04,889
we're talking about something that's

00:18:01,919 --> 00:18:06,119
corporate deployed and laptop and

00:18:04,889 --> 00:18:07,440
typically you're going to have the user

00:18:06,119 --> 00:18:09,090
decryption password but you're also

00:18:07,440 --> 00:18:11,519
going to want to have an admin password

00:18:09,090 --> 00:18:13,139
so that for whatever reason if the user

00:18:11,519 --> 00:18:15,419
can't get into their system the admins

00:18:13,139 --> 00:18:17,399
can get into it right so during this

00:18:15,419 --> 00:18:19,229
case out of walks you can just use

00:18:17,399 --> 00:18:22,139
multiple slots but if we translate this

00:18:19,229 --> 00:18:24,659
into shears language we can do a

00:18:22,139 --> 00:18:27,179
threshold of line and we've divided up

00:18:24,659 --> 00:18:30,479
in the two fragments and with admin

00:18:27,179 --> 00:18:32,220
password music password and so the user

00:18:30,479 --> 00:18:34,229
password user can type in his or her

00:18:32,220 --> 00:18:36,570
password and because the threshold is

00:18:34,229 --> 00:18:40,409
one right of sufficient down rotten

00:18:36,570 --> 00:18:42,179
system same for the admin when can

00:18:40,409 --> 00:18:44,460
automate this process right because we

00:18:42,179 --> 00:18:47,190
can sit the 10 server we talked about as

00:18:44,460 --> 00:18:49,649
one of our endpoints and we still have a

00:18:47,190 --> 00:18:51,929
parish hold of one so now we when the

00:18:49,649 --> 00:18:54,179
user is in their laptop to work they

00:18:51,929 --> 00:18:57,029
turn it out of work they get on the

00:18:54,179 --> 00:18:59,090
network and then the disk decrypts

00:18:57,029 --> 00:19:00,590
automatically because they're armed

00:18:59,090 --> 00:19:02,600
network they had access to the tank

00:19:00,590 --> 00:19:05,390
server and everything just continues

00:19:02,600 --> 00:19:07,520
automatically but if they're at home or

00:19:05,390 --> 00:19:09,290
coffee shop then they can use the user

00:19:07,520 --> 00:19:13,310
password or the admin cleans the a

00:19:09,290 --> 00:19:16,640
massive network stack love it before you

00:19:13,310 --> 00:19:19,400
sure this this doesn't just magically

00:19:16,640 --> 00:19:22,610
River because I put it on a slide I wish

00:19:19,400 --> 00:19:24,740
it was that music unfortunately but yes

00:19:22,610 --> 00:19:26,690
I merely do have network sac in early

00:19:24,740 --> 00:19:29,750
boot and in fact i'm going to show you

00:19:26,690 --> 00:19:31,430
them like this at the end that goes with

00:19:29,750 --> 00:19:35,810
some complications we don't currently

00:19:31,430 --> 00:19:38,270
have various in the early stack so we're

00:19:35,810 --> 00:19:46,990
doing our second stages and well let's

00:19:38,270 --> 00:19:46,990
see how far basically

00:19:48,000 --> 00:19:56,729
ammonia which would be

00:19:52,489 --> 00:19:57,599
yep yes so we have options here we're

00:19:56,729 --> 00:19:58,799
still trying to bring up the

00:19:57,599 --> 00:20:00,059
infrastructure still trying to bring up

00:19:58,799 --> 00:20:01,829
the protocols once we get these

00:20:00,059 --> 00:20:02,909
protocols up and establish we can really

00:20:01,829 --> 00:20:05,999
start to look at some of these other

00:20:02,909 --> 00:20:08,070
Abbott's so this is the standard sort of

00:20:05,999 --> 00:20:10,259
automated laptop case right let's start

00:20:08,070 --> 00:20:14,609
to get a little bit more esoteric let's

00:20:10,259 --> 00:20:17,059
imagine now that we have a system that's

00:20:14,609 --> 00:20:20,549
really need to be secure right we've got

00:20:17,059 --> 00:20:22,409
nuclear launch codes on it okay now we

00:20:20,549 --> 00:20:24,989
don't want to just have one password

00:20:22,409 --> 00:20:26,909
that we share out of all people but

00:20:24,989 --> 00:20:29,669
instead we want to have three distinct

00:20:26,909 --> 00:20:32,519
passwords for which two of them are

00:20:29,669 --> 00:20:33,839
required but you both gotta turn the key

00:20:32,519 --> 00:20:36,479
you to blow up the world kind of

00:20:33,839 --> 00:20:38,219
scenario so here in this case two

00:20:36,479 --> 00:20:41,429
different users have to enter a password

00:20:38,219 --> 00:20:45,299
in order to in order to be able to get

00:20:41,429 --> 00:20:49,379
in so let's let them out a complex

00:20:45,299 --> 00:20:52,769
theoretical laptop policy so in this

00:20:49,379 --> 00:20:56,009
case we have our first level which has a

00:20:52,769 --> 00:20:58,229
threshold of one and it has a Qi code

00:20:56,009 --> 00:21:00,959
and this is sort of the master recovery

00:20:58,229 --> 00:21:04,489
key right so I tias provisioning this

00:21:00,959 --> 00:21:07,049
laptop and they generate a

00:21:04,489 --> 00:21:08,820
cryptographically strong random key they

00:21:07,049 --> 00:21:11,700
printed in a QR code and they lock in

00:21:08,820 --> 00:21:14,700
the safe and it's already over used for

00:21:11,700 --> 00:21:16,109
disaster recovery so that one has a

00:21:14,700 --> 00:21:18,959
threshold of one because if they show

00:21:16,109 --> 00:21:21,690
the QR code you want a min number no

00:21:18,959 --> 00:21:24,209
matter what the motor up to another

00:21:21,690 --> 00:21:27,120
level of smears here we have a threshold

00:21:24,209 --> 00:21:29,790
of two okay

00:21:27,120 --> 00:21:32,970
in this case were bound to TPM as well

00:21:29,790 --> 00:21:35,340
as well another sub tree and this means

00:21:32,970 --> 00:21:37,500
that both are actually required so in

00:21:35,340 --> 00:21:39,210
this case in the first case of the QR

00:21:37,500 --> 00:21:42,000
code they can take the laptop out of the

00:21:39,210 --> 00:21:44,580
hard drive and use the QR code to get

00:21:42,000 --> 00:21:47,309
back into the disk but in all remaining

00:21:44,580 --> 00:21:49,530
cases the disk has to be in the chassis

00:21:47,309 --> 00:21:51,270
because it's balanced the TPM and

00:21:49,530 --> 00:21:54,150
there's a threshold to so that means TPM

00:21:51,270 --> 00:21:56,940
is required we are we drop down to a

00:21:54,150 --> 00:21:59,970
leather threshold and we have four

00:21:56,940 --> 00:22:02,850
options here password fingerprint time

00:21:59,970 --> 00:22:05,520
and Bluetooth and in these four cases

00:22:02,850 --> 00:22:07,980
two of them are required so you can now

00:22:05,520 --> 00:22:11,640
imagine that we have a sliding scale of

00:22:07,980 --> 00:22:13,920
security so I'm again in at my desk and

00:22:11,640 --> 00:22:15,240
I release who began right with a range

00:22:13,920 --> 00:22:17,730
of my desk i'm on the corporate network

00:22:15,240 --> 00:22:19,860
and that does the time I prefer my two

00:22:17,730 --> 00:22:22,470
requirements completely automatically on

00:22:19,860 --> 00:22:24,660
the other hand that take my laptop and I

00:22:22,470 --> 00:22:26,820
walk into a conference room I still have

00:22:24,660 --> 00:22:28,110
access to the corporate network so you

00:22:26,820 --> 00:22:29,880
need to 10 but i'm not a range of the

00:22:28,110 --> 00:22:32,460
bluetooth beacon now right so in this

00:22:29,880 --> 00:22:35,190
case i just scanned my fingerprint and i

00:22:32,460 --> 00:22:37,020
get in but Lana took my laptop and a

00:22:35,190 --> 00:22:40,290
relative going you need to be even less

00:22:37,020 --> 00:22:42,060
secure environment and when I walk

00:22:40,290 --> 00:22:44,610
willing to abandon our local coffee shop

00:22:42,060 --> 00:22:47,610
and I try to get into my data and in

00:22:44,610 --> 00:22:49,770
this case we need to again so i use my

00:22:47,610 --> 00:22:52,040
last password and my fingerprint so you

00:22:49,770 --> 00:22:55,290
can see now where we use this complex

00:22:52,040 --> 00:22:57,360
structure in order to synthesize

00:22:55,290 --> 00:22:59,220
essentially a real war in a moment but

00:22:57,360 --> 00:23:00,600
because we've identified that near my

00:22:59,220 --> 00:23:02,970
breast that's a really secure

00:23:00,600 --> 00:23:05,190
environment when i walk away from my

00:23:02,970 --> 00:23:06,900
desk it's a little bit less secure that

00:23:05,190 --> 00:23:09,270
we can still have some automation and

00:23:06,900 --> 00:23:11,010
some easy access but when i'm in a

00:23:09,270 --> 00:23:13,260
completely unsecured environment let the

00:23:11,010 --> 00:23:15,960
coffee shop in that case i have to use

00:23:13,260 --> 00:23:18,990
the strongest level of authentication in

00:23:15,960 --> 00:23:20,160
order to get access so just make sense

00:23:18,990 --> 00:23:22,650
to everybody have I explained it well

00:23:20,160 --> 00:23:25,020
yes now just think about your normal

00:23:22,650 --> 00:23:27,720
life this is processes where you work in

00:23:25,020 --> 00:23:29,610
fact I like to call this essentially a

00:23:27,720 --> 00:23:31,100
neural network for infection right

00:23:29,610 --> 00:23:33,840
because that's that's sort of what it is

00:23:31,100 --> 00:23:35,280
the way we sort of look in our own brain

00:23:33,840 --> 00:23:36,720
as we walk into an environment that we

00:23:35,280 --> 00:23:38,970
don't know we don't know what it is what

00:23:36,720 --> 00:23:40,530
we pick we piece together by the clues

00:23:38,970 --> 00:23:43,560
live around us or hear this

00:23:40,530 --> 00:23:46,440
subconsciously that you know that I'm in

00:23:43,560 --> 00:23:48,480
danger or not and we have these feelings

00:23:46,440 --> 00:23:50,370
of comfort or relaxation if we're in a

00:23:48,480 --> 00:23:54,390
safe environment while or a feeling of

00:23:50,370 --> 00:23:56,790
you know of elevated stress in an

00:23:54,390 --> 00:23:58,260
environment which is which is not secure

00:23:56,790 --> 00:23:59,520
and so essentially what we're trying to

00:23:58,260 --> 00:24:02,940
do here is we're trying to synthesize

00:23:59,520 --> 00:24:05,820
the way that humans actually behave in

00:24:02,940 --> 00:24:08,070
order to create a security policy around

00:24:05,820 --> 00:24:11,700
that so we're essentially emulating a

00:24:08,070 --> 00:24:14,220
human behavior and here's the key point

00:24:11,700 --> 00:24:16,080
I would like to leave us with research

00:24:14,220 --> 00:24:18,660
couple more things talk about but we're

00:24:16,080 --> 00:24:19,720
coming in the home stretch let business

00:24:18,660 --> 00:24:22,150
policy rather cook

00:24:19,720 --> 00:24:25,450
policy and not vice versa right so we're

00:24:22,150 --> 00:24:27,490
trying to create a flexible system one

00:24:25,450 --> 00:24:29,380
of which the person who's actually

00:24:27,490 --> 00:24:32,169
deploying this can create the policy

00:24:29,380 --> 00:24:33,940
it's very easy for us to create one or

00:24:32,169 --> 00:24:35,919
two policies that we think are very good

00:24:33,940 --> 00:24:38,289
but that doesn't want the business

00:24:35,919 --> 00:24:40,240
policy to drive the crypto policy it

00:24:38,289 --> 00:24:43,179
means that a crypto engineer has

00:24:40,240 --> 00:24:47,490
designed the crypto policy and they're

00:24:43,179 --> 00:24:49,720
already can be more flexible yet so the

00:24:47,490 --> 00:24:51,070
the product that influenced this is

00:24:49,720 --> 00:24:53,620
which is the client side is called

00:24:51,070 --> 00:24:56,950
previs and it's quiet side protocol key

00:24:53,620 --> 00:25:00,309
management currently we have three

00:24:56,950 --> 00:25:02,320
plugins we have HTTP which supports the

00:25:00,309 --> 00:25:03,460
traditional escrow model is we have a

00:25:02,320 --> 00:25:06,220
lot of people that use this and they're

00:25:03,460 --> 00:25:08,020
going to want to migrate slowly away and

00:25:06,220 --> 00:25:09,760
there are some cases Pratt for

00:25:08,020 --> 00:25:12,010
regulation might require them to use a

00:25:09,760 --> 00:25:14,890
rest and that's girl model so the best

00:25:12,010 --> 00:25:17,289
for this just does an HTTP put against

00:25:14,890 --> 00:25:19,690
the URL and does need to be get to get

00:25:17,289 --> 00:25:21,490
the key back and this that supports

00:25:19,690 --> 00:25:23,200
caesarea by the way which has this API

00:25:21,490 --> 00:25:25,390
which is one of those other projects in

00:25:23,200 --> 00:25:28,750
last set and it's interesting in its own

00:25:25,390 --> 00:25:31,120
right so go see it let us have minimal

00:25:28,750 --> 00:25:33,220
dependencies and then each plug-in can

00:25:31,120 --> 00:25:36,309
add its own dependencies right so we

00:25:33,220 --> 00:25:37,780
want this to be very very flexible we

00:25:36,309 --> 00:25:39,010
had early due to integration which I'm

00:25:37,780 --> 00:25:41,850
going to show you a demo are we have

00:25:39,010 --> 00:25:45,580
norm integration which I'm not sure

00:25:41,850 --> 00:25:48,430
and the both of these are in progress

00:25:45,580 --> 00:25:50,410
that should work but I made some chord

00:25:48,430 --> 00:25:52,000
changes and broke some stuff and so they

00:25:50,410 --> 00:25:55,690
currently don't work but they will work

00:25:52,000 --> 00:26:02,320
again very shortly so let's look at a

00:25:55,690 --> 00:26:05,850
demo and unfortunately this always wants

00:26:02,320 --> 00:26:05,850
to drop me to the lowest resolution

00:26:10,400 --> 00:26:15,830
okay so on the right-hand side we have

00:26:13,940 --> 00:26:17,780
let's assess the server on the left hand

00:26:15,830 --> 00:26:19,760
side we have a client that's in a

00:26:17,780 --> 00:26:21,440
virtual machine you'll notice that we're

00:26:19,760 --> 00:26:22,940
booting up on the left and one's going

00:26:21,440 --> 00:26:25,970
to require our passwords on their way

00:26:22,940 --> 00:26:28,160
we're going to set up a factor this is

00:26:25,970 --> 00:26:29,450
actually some older code so it doesn't

00:26:28,160 --> 00:26:32,120
look exactly like this but you'll get

00:26:29,450 --> 00:26:35,150
the general idea of the workflow so we

00:26:32,120 --> 00:26:36,530
just generates the keys and start the

00:26:35,150 --> 00:26:40,160
server over here and we picked in the

00:26:36,530 --> 00:26:44,840
password over here to boot so here we

00:26:40,160 --> 00:26:46,670
generated cities and now the server side

00:26:44,840 --> 00:26:49,090
is ready we've got this is from scratch

00:26:46,670 --> 00:26:50,840
by the way from young install and then

00:26:49,090 --> 00:26:53,480
what's that we're going install the

00:26:50,840 --> 00:26:56,840
client integration including the early

00:26:53,480 --> 00:27:02,780
boot integration and then we're going to

00:26:56,840 --> 00:27:06,890
bind the data the deluxe petition to the

00:27:02,780 --> 00:27:09,890
tank sir I just got the idea that

00:27:06,890 --> 00:27:11,390
support of the game it shows you he and

00:27:09,890 --> 00:27:14,180
asks you if you want to accept and take

00:27:11,390 --> 00:27:17,240
an existing luxe password and now our

00:27:14,180 --> 00:27:19,010
disk is down on the left on the right

00:27:17,240 --> 00:27:21,230
side I'll show you now that the sir

00:27:19,010 --> 00:27:25,730
running it started automatically with

00:27:21,230 --> 00:27:27,200
Justin beef I think they turn it off to

00:27:25,730 --> 00:27:29,740
show that it will actually turn back on

00:27:27,200 --> 00:27:32,090
reboot so now we reviewed on the left

00:27:29,740 --> 00:27:35,710
you'll notice that be password prompt

00:27:32,090 --> 00:27:35,710
comes up but I don't type anything

00:27:36,730 --> 00:27:43,520
servers started the process is the key

00:27:39,710 --> 00:27:45,620
and Boots automatically so now we're

00:27:43,520 --> 00:27:48,550
breathing and now you'll notice I

00:27:45,620 --> 00:27:52,100
completely stop service and the socket

00:27:48,550 --> 00:27:54,170
reboot it again and now I'll touch

00:27:52,100 --> 00:27:56,240
anything and we're just hanging wait

00:27:54,170 --> 00:27:58,460
there because it can't contact the

00:27:56,240 --> 00:28:03,650
server so in this case you can of course

00:27:58,460 --> 00:28:06,800
fall back to the password when i type in

00:28:03,650 --> 00:28:09,710
the password to get of stuff so that's

00:28:06,800 --> 00:28:12,610
just a really really simple demo of the

00:28:09,710 --> 00:28:12,610
technology we're making

00:28:14,700 --> 00:28:19,030
the stuff have two more things were

00:28:17,530 --> 00:28:20,530
threatened with dependencies that we're

00:28:19,030 --> 00:28:22,660
using because you had to build some

00:28:20,530 --> 00:28:24,870
infrastructure for this project the

00:28:22,660 --> 00:28:28,960
first dependency is our larger one and

00:28:24,870 --> 00:28:30,730
it in turn depends on just open SSL we

00:28:28,960 --> 00:28:32,500
don't implement around put the right

00:28:30,730 --> 00:28:35,530
that's number one will protocol mature

00:28:32,500 --> 00:28:39,490
with death and so we depend on open SSL

00:28:35,530 --> 00:28:42,700
in Jose and we depend on Ozzy lip before

00:28:39,490 --> 00:28:44,980
gene for Jesus encryption part of a

00:28:42,700 --> 00:28:47,380
standard and basically this is just a

00:28:44,980 --> 00:28:49,000
library that provides updates and object

00:28:47,380 --> 00:28:51,010
signing and encryption it's a see

00:28:49,000 --> 00:28:53,080
language library so it's very low level

00:28:51,010 --> 00:28:54,580
of debt no dependencies I would also

00:28:53,080 --> 00:28:55,990
have this really cool command-line

00:28:54,580 --> 00:28:58,570
utility which I'm really proud of and

00:28:55,990 --> 00:29:01,570
this is just simply user-friendly a trip

00:28:58,570 --> 00:29:05,679
down okay so here's an example of using

00:29:01,570 --> 00:29:10,150
the command line utility so we echo this

00:29:05,679 --> 00:29:12,280
message hi pipe it into Jose we're going

00:29:10,150 --> 00:29:15,070
to encrypt we're going to take our input

00:29:12,280 --> 00:29:19,130
on standard ink we're going to use this

00:29:15,070 --> 00:29:22,220
RSA public key we are going to out

00:29:19,130 --> 00:29:23,870
this file that's it we just encrypted

00:29:22,220 --> 00:29:27,980
the message now we're going to keep

00:29:23,870 --> 00:29:30,350
credit here so they end because the

00:29:27,980 --> 00:29:32,420
input is the extinct at the file and

00:29:30,350 --> 00:29:35,390
this time we're using the arts a private

00:29:32,420 --> 00:29:37,550
key in order to because it and we get

00:29:35,390 --> 00:29:39,170
the message back now we have the same

00:29:37,550 --> 00:29:43,850
thing with a different key and in the

00:29:39,170 --> 00:29:47,570
tickets so you can use it as utility you

00:29:43,850 --> 00:29:49,760
can generate keys automatically you can

00:29:47,570 --> 00:29:51,380
perform encryption you can form

00:29:49,760 --> 00:29:53,450
decription you can perform signing and

00:29:51,380 --> 00:29:56,210
gratification all using the standard

00:29:53,450 --> 00:29:57,950
Jason object really simple to use but

00:29:56,210 --> 00:29:59,630
not only is it really simple to use you

00:29:57,950 --> 00:30:01,130
can actually control all of the plan

00:29:59,630 --> 00:30:03,100
list with it if you want so it's both

00:30:01,130 --> 00:30:08,960
simple and powerful where is that

00:30:03,100 --> 00:30:15,230
message tdg just adjacent interjection

00:30:08,960 --> 00:30:18,020
object okay no no it's it's text it's a

00:30:15,230 --> 00:30:20,480
text file that contains Jason and then

00:30:18,020 --> 00:30:22,520
some of the attributes of the JSON

00:30:20,480 --> 00:30:24,920
object or base64 encoded because their

00:30:22,520 --> 00:30:27,950
binary that's basically it's just

00:30:24,920 --> 00:30:31,670
metadata and for the binary stuff its

00:30:27,950 --> 00:30:33,890
base 64 this is all standard I'm not

00:30:31,670 --> 00:30:37,580
inventing this myself right there is a

00:30:33,890 --> 00:30:39,320
set of I think it's seven rfcs that

00:30:37,580 --> 00:30:40,370
implement all of these objects and

00:30:39,320 --> 00:30:41,870
exactly what they're supposed to look

00:30:40,370 --> 00:30:43,730
like how the algorithms are supposed to

00:30:41,870 --> 00:30:45,230
work this is one of the best standards

00:30:43,730 --> 00:30:48,920
to come out of Microsoft in recent years

00:30:45,230 --> 00:30:53,750
it's really fantastic so so anyway if

00:30:48,920 --> 00:30:55,760
you want easy crypto right there another

00:30:53,750 --> 00:30:59,350
dependency as a project called locks

00:30:55,760 --> 00:31:01,390
meta and the problem that we had is

00:30:59,350 --> 00:31:04,299
metadata about the keys where we get

00:31:01,390 --> 00:31:06,520
them things like that but we need that

00:31:04,299 --> 00:31:07,840
stored on the disk before we decrypt the

00:31:06,520 --> 00:31:09,820
disk because we have to be able to

00:31:07,840 --> 00:31:12,309
access it the problem is the vast

00:31:09,820 --> 00:31:15,130
majority of people have already played a

00:31:12,309 --> 00:31:17,710
disk using rocks taking up the entirety

00:31:15,130 --> 00:31:19,990
of the block dish right so we needed to

00:31:17,710 --> 00:31:22,360
have somewhere to put this but idea and

00:31:19,990 --> 00:31:25,929
fortunately for us there is a gap in the

00:31:22,360 --> 00:31:28,450
lux one header basically you have lux

00:31:25,929 --> 00:31:30,910
one metadata then you have the key slots

00:31:28,450 --> 00:31:33,309
then there's a gap and then you have to

00:31:30,910 --> 00:31:35,500
start the encrypted data so i created

00:31:33,309 --> 00:31:37,299
this library called mucks meta and this

00:31:35,500 --> 00:31:40,210
really does is it allows you to put

00:31:37,299 --> 00:31:42,190
stuff in that yet and it's also very

00:31:40,210 --> 00:31:44,020
easy to use it's also a C library with

00:31:42,190 --> 00:31:45,580
the command line utility you can use

00:31:44,020 --> 00:31:47,350
this completely independently of all the

00:31:45,580 --> 00:31:49,659
stuff we talked about just a quick

00:31:47,350 --> 00:31:52,600
example we're gonna add versa Melanie

00:31:49,659 --> 00:31:55,659
round and round message hi you it was

00:31:52,600 --> 00:31:58,630
better to save it on this device flock

00:31:55,659 --> 00:32:01,350
to with this video ad and this year he

00:31:58,630 --> 00:32:04,570
is just randomly generated identifies

00:32:01,350 --> 00:32:08,250
hopefully in a Persian proof way we will

00:32:04,570 --> 00:32:11,679
the contents of what's in LA to now okay

00:32:08,250 --> 00:32:13,659
so then in the second in the second p.m.

00:32:11,679 --> 00:32:15,970
we learned that we back out saying

00:32:13,659 --> 00:32:20,140
goodbye same slop same UI you would get

00:32:15,970 --> 00:32:22,690
the data back however if we if we try it

00:32:20,140 --> 00:32:24,250
the same problem at different ump it

00:32:22,690 --> 00:32:25,990
tells us the slop contains a different

00:32:24,250 --> 00:32:27,970
in New you ivy and it won't give us the

00:32:25,990 --> 00:32:30,309
data back it's just a protected right so

00:32:27,970 --> 00:32:33,070
you can say I'm expecting this kind of

00:32:30,309 --> 00:32:34,960
data in this slot and if everything

00:32:33,070 --> 00:32:39,640
matches you get data back if not in bits

00:32:34,960 --> 00:32:41,320
so very simple for the idiot please and

00:32:39,640 --> 00:32:43,090
so that new UI you be something that

00:32:41,320 --> 00:32:46,299
would be gotten back from an answer or

00:32:43,090 --> 00:32:48,010
no it's just randomly generated for it's

00:32:46,299 --> 00:32:50,320
essentially a type identifier for

00:32:48,010 --> 00:32:55,630
whatever metadata you're storing ok so

00:32:50,320 --> 00:32:58,809
you I as as klemish I'm going to store

00:32:55,630 --> 00:33:02,500
some metadata ok i define my format I

00:32:58,809 --> 00:33:05,740
randomly generate a uuid that indicates

00:33:02,500 --> 00:33:08,710
that the metadata is that format and so

00:33:05,740 --> 00:33:11,500
then I always use that uuid when reading

00:33:08,710 --> 00:33:13,299
and writing the metadata and I'm always

00:33:11,500 --> 00:33:14,980
guaranteed essentially unless there's a

00:33:13,299 --> 00:33:20,740
collision which is extremely unlikely

00:33:14,980 --> 00:33:22,840
given a uuid if this thing off so yeah

00:33:20,740 --> 00:33:24,790
it uniquely identifies the type of data

00:33:22,840 --> 00:33:28,450
so as long as the data in that slot has

00:33:24,790 --> 00:33:32,820
that uuid I know it's my data and not

00:33:28,450 --> 00:33:35,230
somebody else so

00:33:32,820 --> 00:33:36,880
this of course is useful apart from the

00:33:35,230 --> 00:33:38,230
other projects you can store your own

00:33:36,880 --> 00:33:42,160
data there if you want to do a different

00:33:38,230 --> 00:33:46,810
unlocking scheme so this is rationality

00:33:42,160 --> 00:33:49,360
comes from this is a your standard sort

00:33:46,810 --> 00:33:51,400
of binding mechanic people use this

00:33:49,360 --> 00:33:55,690
thats a mechanic is used in ancient

00:33:51,400 --> 00:33:58,000
handcuffs and the u-shaped part is the

00:33:55,690 --> 00:34:00,280
class the thing it binds to is the

00:33:58,000 --> 00:34:03,510
pattern and plug-ins by the way for

00:34:00,280 --> 00:34:05,470
classical pins so that's where that

00:34:03,510 --> 00:34:08,520
that's where the type of terminology

00:34:05,470 --> 00:34:08,520
comes from any classes

00:34:12,970 --> 00:34:24,599
I think I've killed all of you with now

00:34:16,560 --> 00:34:24,599
yes yes

00:34:25,990 --> 00:34:30,049
it should be because all of those

00:34:28,309 --> 00:34:32,690
distributed file systems are built on

00:34:30,049 --> 00:34:35,000
top of a block device and so you would

00:34:32,690 --> 00:34:36,859
just do Lux encryption underneath the

00:34:35,000 --> 00:34:38,929
block device and then distributed a

00:34:36,859 --> 00:34:50,240
system on top of it so that's like

00:34:38,929 --> 00:34:53,569
roster work sprint it depends it depends

00:34:50,240 --> 00:34:55,190
on the profile that you used when you

00:34:53,569 --> 00:35:00,680
create a deluxe header so for instance

00:34:55,190 --> 00:35:04,359
if you use 256-bit keys it's fairly

00:35:00,680 --> 00:35:08,960
large if you use 512 it's fairly small

00:35:04,359 --> 00:35:11,029
but you can also adjust the size of the

00:35:08,960 --> 00:35:13,700
gap I just specifying a parameter when

00:35:11,029 --> 00:35:15,380
you're provisioning the system so if you

00:35:13,700 --> 00:35:17,450
know ahead of time you want to have a

00:35:15,380 --> 00:35:19,549
pretty pumped by pretty complex policy

00:35:17,450 --> 00:35:22,190
you can just shift encrypt the data

00:35:19,549 --> 00:35:25,460
right on your provision so the idea is

00:35:22,190 --> 00:35:27,849
yes we are somewhat constrained for some

00:35:25,460 --> 00:35:31,579
default deployments including well seven

00:35:27,849 --> 00:35:33,880
and probably recent fedoras because

00:35:31,579 --> 00:35:37,130
they're all using five cultic keys now

00:35:33,880 --> 00:35:38,930
but for users who want to plan ahead

00:35:37,130 --> 00:35:41,750
they can you get one today

00:35:38,930 --> 00:35:43,220
they want lock screen 2 is also in

00:35:41,750 --> 00:35:45,890
planning right now and there's some

00:35:43,220 --> 00:35:48,849
preliminary code and they actually plan

00:35:45,890 --> 00:35:51,910
to have a dedicated Jason storage area

00:35:48,849 --> 00:35:54,800
so you notice that our use of Jason

00:35:51,910 --> 00:35:57,650
match is very tightly with their use of

00:35:54,800 --> 00:35:59,260
Jason and that's because should you know

00:35:57,650 --> 00:36:01,550
we see Lux version 2 in the near future

00:35:59,260 --> 00:36:03,530
we can hopefully port to that and then

00:36:01,550 --> 00:36:06,980
just use that area and not use you need

00:36:03,530 --> 00:36:08,839
to use luck smita at all the last minute

00:36:06,980 --> 00:36:13,250
does provide us compatibility with lucky

00:36:08,839 --> 00:36:17,869
one so there's also some other

00:36:13,250 --> 00:36:20,210
interviews uses for this one of the one

00:36:17,869 --> 00:36:22,579
of the ideas I like which is a little

00:36:20,210 --> 00:36:25,430
bit controversial it depends on whether

00:36:22,579 --> 00:36:28,010
you like export encryption or not so X

00:36:25,430 --> 00:36:29,359
for Google's implemented encryption on

00:36:28,010 --> 00:36:31,819
the file system level which means you

00:36:29,359 --> 00:36:35,869
can actually encrypt directories in

00:36:31,819 --> 00:36:38,990
inside of explore and i would love to

00:36:35,869 --> 00:36:40,700
store metadata in an extended attributes

00:36:38,990 --> 00:36:43,880
which again would be a fairly limited

00:36:40,700 --> 00:36:46,280
size but if we can store that in the

00:36:43,880 --> 00:36:48,250
extended attribute then we can

00:36:46,280 --> 00:36:50,839
automatically unlocks a a directory

00:36:48,250 --> 00:36:54,049
interestingly we can unlock it in a

00:36:50,839 --> 00:36:57,140
namespace so and then start a process in

00:36:54,049 --> 00:36:59,710
that namespace so say you have a

00:36:57,140 --> 00:37:01,549
database you can encrypt the directory

00:36:59,710 --> 00:37:03,920
automatically unlock it when the

00:37:01,549 --> 00:37:08,410
database starts and early the database

00:37:03,920 --> 00:37:12,349
process sees the unlocked directory so

00:37:08,410 --> 00:37:13,750
various other ideas like that obviously

00:37:12,349 --> 00:37:15,190
the folders

00:37:13,750 --> 00:37:17,170
what we're targeting first because

00:37:15,190 --> 00:37:20,080
that's what most people are using that

00:37:17,170 --> 00:37:21,880
this is flexible key management so it

00:37:20,080 --> 00:37:25,290
can be employed to a lot of other areas

00:37:21,880 --> 00:37:25,290
that aren't disk encryption as well

00:37:28,080 --> 00:37:36,150
issues specific please yes the actual

00:37:31,660 --> 00:37:36,150
operation instead of quantum that

00:37:36,510 --> 00:37:41,550
correct yes you know you don't have to

00:37:39,270 --> 00:37:44,910
commit your passwords to the

00:37:41,550 --> 00:37:48,890
configuration files and yet you can just

00:37:44,910 --> 00:37:48,890
use this to automatically to cover them

00:37:53,680 --> 00:37:58,420
thank you everybody for coming

00:37:55,549 --> 00:37:58,420

YouTube URL: https://www.youtube.com/watch?v=teYJi-Prn5A


