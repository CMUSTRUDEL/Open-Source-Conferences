Title: Towards faster composes - Lubomír Sedlář - Flock 2019
Publication date: 2019-08-28
Playlist: Flock 2019
Description: 
	In this session I will talk about what is coming in the future for Pungi, the Fedora compose tool. Historically we have had issues with long compose times, and in this talk I want to explore some options for breaking the process into smaller chunks to enable faster iteration and delivery of consumable artifacts.

--
Recordings of talks at Flock are a community effort. Unfortunately not everything works perfectly every time. If you're interested in helping us improve, let us know.
Captions: 
	00:00:02,510 --> 00:00:07,680
so hello everyone my name is Shubham

00:00:05,399 --> 00:00:09,810
here I work for Red Hat mostly on

00:00:07,680 --> 00:00:11,820
maintaining tools for creating composes

00:00:09,810 --> 00:00:15,660
and I want to tell you something about

00:00:11,820 --> 00:00:18,180
how it's done and what problems there

00:00:15,660 --> 00:00:20,100
are that we face with them and how we

00:00:18,180 --> 00:00:22,820
are trying to address those problems and

00:00:20,100 --> 00:00:27,000
where to move from them

00:00:22,820 --> 00:00:30,720
so first let's actually take a step back

00:00:27,000 --> 00:00:35,269
and give a very brief overview of what

00:00:30,720 --> 00:00:38,729
the compose actually so in this case

00:00:35,269 --> 00:00:41,729
composing means taking some content for

00:00:38,729 --> 00:00:44,519
fedora that's RPM packages from the Koji

00:00:41,729 --> 00:00:46,859
build system and create something usable

00:00:44,519 --> 00:00:49,440
from that because if you get a hundred

00:00:46,859 --> 00:00:52,079
thousand rpms it's not fun you can't

00:00:49,440 --> 00:00:54,809
really do anything so we need to create

00:00:52,079 --> 00:00:58,319
ISOs so that you can actually do stuff

00:00:54,809 --> 00:01:01,199
create container images or simply an RPM

00:00:58,319 --> 00:01:05,070
repo with some structure and that you

00:01:01,199 --> 00:01:06,780
can learn consumed with yum or DNF in

00:01:05,070 --> 00:01:09,510
fedora the tool that is used to create

00:01:06,780 --> 00:01:11,670
these composes is called Pangea and I

00:01:09,510 --> 00:01:15,570
happen to be one of the people trying to

00:01:11,670 --> 00:01:18,240
maintain it and to give you some extra

00:01:15,570 --> 00:01:20,580
perspective composes in fedora are

00:01:18,240 --> 00:01:22,680
really almost everywhere it's not just

00:01:20,580 --> 00:01:25,110
the rawhide compose which it's kinda

00:01:22,680 --> 00:01:27,900
hard to notice because it regularly

00:01:25,110 --> 00:01:30,660
spans the devil list with reports there

00:01:27,900 --> 00:01:34,020
are also other composes so behind each

00:01:30,660 --> 00:01:36,180
update bush there is bungy running and

00:01:34,020 --> 00:01:40,230
processing packages and creating the

00:01:36,180 --> 00:01:42,150
repos with updates so what are the

00:01:40,230 --> 00:01:44,820
actual problems that we are facing with

00:01:42,150 --> 00:01:47,580
that and this is specifically for row

00:01:44,820 --> 00:01:50,909
height and new branch to releases well

00:01:47,580 --> 00:01:54,600
they are slow and that's not

00:01:50,909 --> 00:01:56,940
particularly great like historically the

00:01:54,600 --> 00:02:00,150
timings have been different

00:01:56,940 --> 00:02:03,060
like right now row height takes just

00:02:00,150 --> 00:02:05,250
under five hours to finish it used to be

00:02:03,060 --> 00:02:08,310
something like eight or nine hours only

00:02:05,250 --> 00:02:10,739
a few weeks back but there have been

00:02:08,310 --> 00:02:13,710
situations where the composed to fight

00:02:10,739 --> 00:02:17,460
fifteen sixteen hours and that's

00:02:13,710 --> 00:02:19,920
really good there are multiple issues

00:02:17,460 --> 00:02:22,560
caused by that but the main problem is

00:02:19,920 --> 00:02:25,080
that if the compost takes too long you

00:02:22,560 --> 00:02:28,110
can't really iterate on development so

00:02:25,080 --> 00:02:31,320
once a new feather is coming to be

00:02:28,110 --> 00:02:34,590
finished if you need to wait eight hours

00:02:31,320 --> 00:02:36,780
just to be able to test per fix that's

00:02:34,590 --> 00:02:39,510
just not great because that basically

00:02:36,780 --> 00:02:41,040
gives you one fix a day like you come to

00:02:39,510 --> 00:02:43,260
work in the morning and you see okay the

00:02:41,040 --> 00:02:46,410
compost fail yesterday you debug the

00:02:43,260 --> 00:02:49,980
issue you write a patch you build a new

00:02:46,410 --> 00:02:52,140
updated package and then you wait until

00:02:49,980 --> 00:02:56,180
the next day because that that's how

00:02:52,140 --> 00:03:01,020
long it takes to get an updated package

00:02:56,180 --> 00:03:03,150
so let's be honest here the one of the

00:03:01,020 --> 00:03:08,760
big issue is that just slow things are

00:03:03,150 --> 00:03:10,830
not fun in computing it might be nice

00:03:08,760 --> 00:03:15,500
somewhere else but when you're waiting

00:03:10,830 --> 00:03:19,080
for your job to be finished it sucks so

00:03:15,500 --> 00:03:20,070
just so that we have some idea on what's

00:03:19,080 --> 00:03:22,560
taking so long

00:03:20,070 --> 00:03:24,900
let's take an overview of what the

00:03:22,560 --> 00:03:29,100
compose actually consists of like it is

00:03:24,900 --> 00:03:31,920
one big monolithic process but it's

00:03:29,100 --> 00:03:33,780
split into different chunks and smaller

00:03:31,920 --> 00:03:36,030
pieces so this is an overview of

00:03:33,780 --> 00:03:39,300
everything that goes into row height and

00:03:36,030 --> 00:03:41,070
how Pangaea split to create that it goes

00:03:39,300 --> 00:03:42,990
from left to right and when there are

00:03:41,070 --> 00:03:45,750
multiple things on top of each other

00:03:42,990 --> 00:03:47,790
that's where there's some parallelism so

00:03:45,750 --> 00:03:50,330
it starts with a face code in it that

00:03:47,790 --> 00:03:53,340
basically just takes some data and

00:03:50,330 --> 00:03:55,260
prepares the general structure so this

00:03:53,340 --> 00:03:58,140
involves cloning the repository with

00:03:55,260 --> 00:04:00,690
combs files the module defaults files

00:03:58,140 --> 00:04:02,640
are processed here when this is

00:04:00,690 --> 00:04:06,450
generally very fast like under a minute

00:04:02,640 --> 00:04:09,570
and then comes the first bottleneck and

00:04:06,450 --> 00:04:12,120
that's the face code packet set this is

00:04:09,570 --> 00:04:14,520
where we talk to Koji and ask okay give

00:04:12,120 --> 00:04:17,130
me a list of all the latest packages and

00:04:14,520 --> 00:04:19,590
then we go and check headers on every

00:04:17,130 --> 00:04:22,290
single one of those rpms because we need

00:04:19,590 --> 00:04:25,440
to know what is that RPM actually like

00:04:22,290 --> 00:04:27,110
where can we put it the output of this

00:04:25,440 --> 00:04:30,630
face is

00:04:27,110 --> 00:04:32,190
rpm repository with the packages one for

00:04:30,630 --> 00:04:34,860
every single architecture that we are

00:04:32,190 --> 00:04:36,510
composing for and also lists of packages

00:04:34,860 --> 00:04:38,730
like what's actually in the repo we

00:04:36,510 --> 00:04:40,110
don't want to when we want to find some

00:04:38,730 --> 00:04:41,970
package we don't want to open the

00:04:40,110 --> 00:04:45,120
metadata in the repo and search it there

00:04:41,970 --> 00:04:49,680
and for all right this takes something

00:04:45,120 --> 00:04:52,710
like 30 minutes at least in the compost

00:04:49,680 --> 00:05:00,030
that I test check this for which was I

00:04:52,710 --> 00:05:01,560
think Monday composed then multiple

00:05:00,030 --> 00:05:04,440
things start working at the same time

00:05:01,560 --> 00:05:06,120
like on one hand the first line building

00:05:04,440 --> 00:05:08,340
store face that creates the installer

00:05:06,120 --> 00:05:11,280
image the way it works is that Bungie

00:05:08,340 --> 00:05:14,550
kicks off a task in Koji and says ok

00:05:11,280 --> 00:05:18,389
let's run Lorax to generate or all the

00:05:14,550 --> 00:05:21,210
necessary files and then it sits back

00:05:18,389 --> 00:05:24,200
and waits for the task to finish nothing

00:05:21,210 --> 00:05:28,470
very much in punji to optimizing that

00:05:24,200 --> 00:05:30,900
the OS 3 path is very similar it's just

00:05:28,470 --> 00:05:33,960
that it kicks off Lorax with different

00:05:30,900 --> 00:05:37,200
arguments to create and always tree

00:05:33,960 --> 00:05:41,310
installer that bundles the OS tree

00:05:37,200 --> 00:05:43,470
commit in there the middle line here

00:05:41,310 --> 00:05:46,050
gathering and creating repos that's

00:05:43,470 --> 00:05:49,380
where some work actually happens and

00:05:46,050 --> 00:05:50,370
this is where punchy figures out what

00:05:49,380 --> 00:05:54,270
goes where

00:05:50,370 --> 00:05:55,680
so like there's everything which sounds

00:05:54,270 --> 00:05:57,270
like it should be everything but that's

00:05:55,680 --> 00:05:58,919
actually kind of a lie

00:05:57,270 --> 00:06:01,740
because depending on how you look at it

00:05:58,919 --> 00:06:04,289
it's everything plus something extra or

00:06:01,740 --> 00:06:06,720
it's just shy of everything like there's

00:06:04,289 --> 00:06:08,280
all x86 64 packages for example but

00:06:06,720 --> 00:06:11,400
there's also something more to it and

00:06:08,280 --> 00:06:12,900
not all 32-bit packages are there so

00:06:11,400 --> 00:06:14,850
it's not just a matter of taking

00:06:12,900 --> 00:06:18,389
everything when shipping it somewhere

00:06:14,850 --> 00:06:20,940
there's some extra logic and everything

00:06:18,389 --> 00:06:22,229
is not everything that's in the compost

00:06:20,940 --> 00:06:24,780
there are other parts there's

00:06:22,229 --> 00:06:27,419
workstation there server at least for

00:06:24,780 --> 00:06:29,910
now and those are subsets of the

00:06:27,419 --> 00:06:31,669
packages so in this case we know a list

00:06:29,910 --> 00:06:34,710
of packages that we want there to be

00:06:31,669 --> 00:06:37,830
like if it's workstation and we probably

00:06:34,710 --> 00:06:39,270
want some you know stuff but we need to

00:06:37,830 --> 00:06:39,910
check the dependencies and make sure

00:06:39,270 --> 00:06:42,160
that

00:06:39,910 --> 00:06:43,780
or it can actually be installed like we

00:06:42,160 --> 00:06:46,750
don't want to create a report that

00:06:43,780 --> 00:06:48,490
contains bosch but not G lip-sync

00:06:46,750 --> 00:06:56,550
because then like what do you do with

00:06:48,490 --> 00:06:58,780
that and this is actually kind of slow

00:06:56,550 --> 00:07:01,240
like in the compose did I check the

00:06:58,780 --> 00:07:03,370
gather face took altogether about one

00:07:01,240 --> 00:07:04,810
hour and ten minutes to figure to go

00:07:03,370 --> 00:07:07,660
through all of the combinations of

00:07:04,810 --> 00:07:11,290
variant and architecture and figure out

00:07:07,660 --> 00:07:13,330
what packages should be there and once

00:07:11,290 --> 00:07:15,490
we have the list of what would what to

00:07:13,330 --> 00:07:17,680
put in there we also need to make sure

00:07:15,490 --> 00:07:19,570
that the packages are actually in the

00:07:17,680 --> 00:07:21,160
compost structure because it's a bunch

00:07:19,570 --> 00:07:23,650
of files on the file system we need to

00:07:21,160 --> 00:07:27,070
get done there so we create hard links

00:07:23,650 --> 00:07:28,840
to the koji volume and every single

00:07:27,070 --> 00:07:31,480
package is hard linked into the coachee

00:07:28,840 --> 00:07:33,760
volume and to recompose interestingly

00:07:31,480 --> 00:07:35,920
enough this takes also about ten minutes

00:07:33,760 --> 00:07:37,990
so there's like ten minute phase where

00:07:35,920 --> 00:07:42,400
when he sits and does nothing but

00:07:37,990 --> 00:07:47,500
hammered and FS with requests it works

00:07:42,400 --> 00:07:49,060
maybe not great but it works once we

00:07:47,500 --> 00:07:51,700
know what we actually want to put in

00:07:49,060 --> 00:07:53,830
there we can run create repo on every

00:07:51,700 --> 00:07:55,300
single combination of variant and

00:07:53,830 --> 00:07:56,710
architecture and create the repo with

00:07:55,300 --> 00:07:59,170
the packages that we just heard link

00:07:56,710 --> 00:08:01,360
this interestingly enough also takes

00:07:59,170 --> 00:08:04,570
about ten minutes for all of them

00:08:01,360 --> 00:08:05,740
together so again not much to optimize

00:08:04,570 --> 00:08:09,160
you although there are some

00:08:05,740 --> 00:08:11,430
possibilities and once we have all of

00:08:09,160 --> 00:08:13,590
this we can start building the extra

00:08:11,430 --> 00:08:17,920
artifacts that go into the compares

00:08:13,590 --> 00:08:19,170
that's live media container images and

00:08:17,920 --> 00:08:21,610
what-have-you

00:08:19,170 --> 00:08:25,270
the reason why we need to wait with this

00:08:21,610 --> 00:08:27,520
is that in order to create a bootable

00:08:25,270 --> 00:08:30,550
live media we need the installer to

00:08:27,520 --> 00:08:32,710
finish if lorax fails to create a boot

00:08:30,550 --> 00:08:35,289
ISO there's no way we can make bootable

00:08:32,710 --> 00:08:37,740
live media for any spin and a variant

00:08:35,289 --> 00:08:40,060
anything so that's why it has to wait

00:08:37,740 --> 00:08:42,160
again in all of these phases that are

00:08:40,060 --> 00:08:44,560
very similar punchy just kicks of tasks

00:08:42,160 --> 00:08:48,610
and coche and weights and this can take

00:08:44,560 --> 00:08:50,620
from a couple minutes to an hour turns

00:08:48,610 --> 00:08:52,630
out if you optimize the builders

00:08:50,620 --> 00:08:55,120
correctly it can be much shorter

00:08:52,630 --> 00:08:57,699
like when I spoke at the beginning about

00:08:55,120 --> 00:09:00,610
the robot Campos is going through eight

00:08:57,699 --> 00:09:03,430
hours to under five that optimization

00:09:00,610 --> 00:09:05,740
was done by changing the s/390 builders

00:09:03,430 --> 00:09:07,630
and PowerPC builders and making sure

00:09:05,740 --> 00:09:09,910
they are faster and it saved a huge

00:09:07,630 --> 00:09:11,860
amount of time that actually makes me

00:09:09,910 --> 00:09:13,569
feel kind of bad because like no matter

00:09:11,860 --> 00:09:20,079
what I do in punchy like I will never

00:09:13,569 --> 00:09:22,750
see such speed ups so that brings us to

00:09:20,079 --> 00:09:24,550
the end of the compost process and mhx

00:09:22,750 --> 00:09:28,060
unfazed we look at all the generated

00:09:24,550 --> 00:09:29,740
files and create checks and those are

00:09:28,060 --> 00:09:31,300
kind of useful for people who want to

00:09:29,740 --> 00:09:34,690
download it and check that they have the

00:09:31,300 --> 00:09:37,000
correct stuff and it's actually

00:09:34,690 --> 00:09:38,440
separated in a separate place because we

00:09:37,000 --> 00:09:40,420
don't want to duplicate the logic for

00:09:38,440 --> 00:09:43,600
every single task that is doing

00:09:40,420 --> 00:09:45,850
something just computing the checks ants

00:09:43,600 --> 00:09:50,380
on all of the images takes about 10

00:09:45,850 --> 00:09:52,949
minutes which kind of gives you an idea

00:09:50,380 --> 00:09:57,189
of how much stuff Fedora is producing

00:09:52,949 --> 00:09:59,860
and the last part is the test phase and

00:09:57,189 --> 00:10:01,750
that's kinda simple we just run Reaper

00:09:59,860 --> 00:10:04,240
closure on the generated Reapers and

00:10:01,750 --> 00:10:06,670
some quick sanity checks on the images

00:10:04,240 --> 00:10:09,550
that we created like for example if we

00:10:06,670 --> 00:10:11,589
create a bootable image like we actually

00:10:09,550 --> 00:10:13,290
do and check the file that it can be

00:10:11,589 --> 00:10:16,209
booted like it has all the headers

00:10:13,290 --> 00:10:18,880
because there have historically been

00:10:16,209 --> 00:10:21,069
bugs where we created stuff that we

00:10:18,880 --> 00:10:23,230
claimed ok this is a bootable image and

00:10:21,069 --> 00:10:25,180
it turned out you can't actually boot

00:10:23,230 --> 00:10:28,839
from that because we forgot to run some

00:10:25,180 --> 00:10:34,269
commands so that's not going to happen I

00:10:28,839 --> 00:10:37,959
again so what am i working on right now

00:10:34,269 --> 00:10:40,240
to fix and that is in this face I'm

00:10:37,959 --> 00:10:43,240
focusing from the start so I'm now

00:10:40,240 --> 00:10:46,750
working on the package that face the as

00:10:43,240 --> 00:10:49,000
I said at the beginning what it does is

00:10:46,750 --> 00:10:51,730
take all the packages from koji meshed

00:10:49,000 --> 00:10:53,350
it all into one big pile and use that as

00:10:51,730 --> 00:10:55,540
input for the flowing phases

00:10:53,350 --> 00:10:58,149
this builds on an assumption that

00:10:55,540 --> 00:11:00,250
historically has been true that there is

00:10:58,149 --> 00:11:03,130
one coach attack with all the packages

00:11:00,250 --> 00:11:05,589
and we can do this and it works nicely

00:11:03,130 --> 00:11:05,860
but unfortunately in the modern in the

00:11:05,589 --> 00:11:08,829
brain

00:11:05,860 --> 00:11:10,630
this is not true because every single

00:11:08,829 --> 00:11:13,300
module that goes into a compass has a

00:11:10,630 --> 00:11:16,690
different tag in koji with the actual

00:11:13,300 --> 00:11:18,100
packages so essentially what is

00:11:16,690 --> 00:11:20,380
happening in the current implementation

00:11:18,100 --> 00:11:22,450
is that we look at all those different

00:11:20,380 --> 00:11:24,399
Koji tags pull the packages into one big

00:11:22,450 --> 00:11:26,140
pile and then have to do some extra

00:11:24,399 --> 00:11:28,029
bookkeeping to make sure that the

00:11:26,140 --> 00:11:30,910
modular packages don't go where they are

00:11:28,029 --> 00:11:34,420
not supposed to go this is suboptimal

00:11:30,910 --> 00:11:37,779
let's say so the current work that is in

00:11:34,420 --> 00:11:40,720
progress is to split this and make

00:11:37,779 --> 00:11:44,140
punchy aware of multiple tags sorry and

00:11:40,720 --> 00:11:46,690
have different package set for different

00:11:44,140 --> 00:11:48,640
tack in that case we don't need to do

00:11:46,690 --> 00:11:51,310
the bookkeeping we just say ok you don't

00:11:48,640 --> 00:11:59,380
want modules don't use this generated

00:11:51,310 --> 00:12:02,470
rippers this by itself is probably not

00:11:59,380 --> 00:12:05,079
going to speed it up too much but it

00:12:02,470 --> 00:12:10,240
will lay the groundwork so that we can

00:12:05,079 --> 00:12:13,750
actually do something more fun like one

00:12:10,240 --> 00:12:16,750
option is to reuse more stuff from

00:12:13,750 --> 00:12:20,019
previous composes if we have one big

00:12:16,750 --> 00:12:21,670
pile with everything in order to reuse

00:12:20,019 --> 00:12:23,980
something from the previous compose we

00:12:21,670 --> 00:12:25,630
have to make sure that we only use the

00:12:23,980 --> 00:12:28,449
stuff that didn't change and it's

00:12:25,630 --> 00:12:32,640
difficult if we have stuff nicely

00:12:28,449 --> 00:12:36,279
compart not come in nice smaller chunks

00:12:32,640 --> 00:12:38,140
then for example for modules we don't

00:12:36,279 --> 00:12:41,050
really need to rerun that because once

00:12:38,140 --> 00:12:43,959
the module finishes if we are using the

00:12:41,050 --> 00:12:45,760
same module built in the compost we know

00:12:43,959 --> 00:12:48,699
what the packages were we don't need to

00:12:45,760 --> 00:12:51,940
check them again because it's given how

00:12:48,699 --> 00:12:55,060
koji is working now once the module

00:12:51,940 --> 00:12:58,180
finishes it doesn't change so we could

00:12:55,060 --> 00:13:02,470
just reuse the stuff and not look at all

00:12:58,180 --> 00:13:04,600
the details in the rpm's another thing

00:13:02,470 --> 00:13:08,140
that we could possibly do with this

00:13:04,600 --> 00:13:10,000
change is to write a separate service

00:13:08,140 --> 00:13:12,220
that you listen on the message bus when

00:13:10,000 --> 00:13:13,870
it would see a package was built it will

00:13:12,220 --> 00:13:16,149
just update the repo in the list of

00:13:13,870 --> 00:13:18,339
packages so that this would be

00:13:16,149 --> 00:13:19,210
continuously updated and all almost

00:13:18,339 --> 00:13:22,750
up-to-date

00:13:19,210 --> 00:13:24,850
and at that state like basically the

00:13:22,750 --> 00:13:27,490
whole face in punchy is just asking this

00:13:24,850 --> 00:13:29,680
thing tell me where the repo is and what

00:13:27,490 --> 00:13:31,750
was the rest of packages and I will use

00:13:29,680 --> 00:13:37,960
that and I will not and the compost will

00:13:31,750 --> 00:13:41,260
not have to wait for anything also if

00:13:37,960 --> 00:13:43,090
this actually existed we could split

00:13:41,260 --> 00:13:46,150
some other tasks from the compost into

00:13:43,090 --> 00:13:48,280
separate runnable things like for

00:13:46,150 --> 00:13:52,030
example a lot of testing before release

00:13:48,280 --> 00:13:53,860
waits for installer to be created but in

00:13:52,030 --> 00:13:56,110
order to create the installer you need

00:13:53,860 --> 00:13:57,640
to have repo with the packages so if

00:13:56,110 --> 00:14:00,340
that repo was always there always

00:13:57,640 --> 00:14:01,630
up-to-date you just kick off the task to

00:14:00,340 --> 00:14:05,130
generate the installer and you would

00:14:01,630 --> 00:14:07,450
wait 20 minutes it takes to create it

00:14:05,130 --> 00:14:10,120
and it would be a fairly nice

00:14:07,450 --> 00:14:14,260
improvement in terms of waiting for

00:14:10,120 --> 00:14:16,720
testing or patch but there are also

00:14:14,260 --> 00:14:20,350
other things that we could look into

00:14:16,720 --> 00:14:21,790
optimizing and some of them I have

00:14:20,350 --> 00:14:23,770
actually started but I don't have

00:14:21,790 --> 00:14:26,020
specific benchmarks so I will not tell

00:14:23,770 --> 00:14:28,600
you too many details like for example

00:14:26,020 --> 00:14:30,940
one of things we could do is make try

00:14:28,600 --> 00:14:32,830
and make faster create repo like you may

00:14:30,940 --> 00:14:35,860
think like create repo see is already

00:14:32,830 --> 00:14:39,520
faster than the old Python create repo

00:14:35,860 --> 00:14:41,920
but we could make more assumptions like

00:14:39,520 --> 00:14:45,010
for example we know that builds in Koji

00:14:41,920 --> 00:14:47,800
have NVRs and if those do any view into

00:14:45,010 --> 00:14:49,660
NVRs are the same we know the RPM is

00:14:47,800 --> 00:14:53,290
going to be the same if we get it with

00:14:49,660 --> 00:14:55,870
the same signature so we could use this

00:14:53,290 --> 00:14:58,030
logic and not look into every single RPM

00:14:55,870 --> 00:15:00,490
like if we know what the rpms were in

00:14:58,030 --> 00:15:03,190
the old compass if the NVR didn't change

00:15:00,490 --> 00:15:04,570
on them we can just reuse the data so

00:15:03,190 --> 00:15:06,910
there might be some possibility for

00:15:04,570 --> 00:15:10,060
optimization here it would not be a

00:15:06,910 --> 00:15:13,300
general tool because in the wild

00:15:10,060 --> 00:15:15,550
internet you can find rpms that don't

00:15:13,300 --> 00:15:19,450
hold where this assumption doesn't hold

00:15:15,550 --> 00:15:21,310
it probably doesn't always hold even in

00:15:19,450 --> 00:15:24,700
fedora like there might be case of cases

00:15:21,310 --> 00:15:27,850
where this is broken but it's something

00:15:24,700 --> 00:15:31,150
to look into and other things that I

00:15:27,850 --> 00:15:32,980
plan to do is to look at the code paths

00:15:31,150 --> 00:15:36,700
that are historically not really

00:15:32,980 --> 00:15:38,260
that much because for example I found

00:15:36,700 --> 00:15:40,240
out this out actually when I was

00:15:38,260 --> 00:15:41,980
preparing this talk I looked at the

00:15:40,240 --> 00:15:44,410
timing of the compose and it turned out

00:15:41,980 --> 00:15:46,960
that figuring out what goes into the

00:15:44,410 --> 00:15:48,640
modular variant takes longer than

00:15:46,960 --> 00:15:51,370
figuring out what goes into everything

00:15:48,640 --> 00:15:53,650
which is much much bigger and this is

00:15:51,370 --> 00:15:56,170
just because the code it is used to

00:15:53,650 --> 00:15:58,090
create module variant is a different

00:15:56,170 --> 00:16:00,130
code pad it's working slightly

00:15:58,090 --> 00:16:01,480
differently to everything and this was

00:16:00,130 --> 00:16:05,200
not optimized because it wasn't

00:16:01,480 --> 00:16:07,120
historically used that much and like

00:16:05,200 --> 00:16:09,220
this is a place where someone with just

00:16:07,120 --> 00:16:10,900
knowledge of Python could go and check

00:16:09,220 --> 00:16:13,300
all the loops and make sure that they

00:16:10,900 --> 00:16:15,970
are correct there's the stuff is done in

00:16:13,300 --> 00:16:24,010
correct order this could bring us some

00:16:15,970 --> 00:16:26,500
speed up as well so that's basically the

00:16:24,010 --> 00:16:29,800
current status and where I plan to move

00:16:26,500 --> 00:16:34,960
from that to expect some results in the

00:16:29,800 --> 00:16:36,550
next 10 to 15 years if you have any

00:16:34,960 --> 00:16:46,870
questions I would be happy to try and

00:16:36,550 --> 00:16:49,840
answer that yes that's a very good point

00:16:46,870 --> 00:16:52,870
as Mohan pointed out if we know that

00:16:49,840 --> 00:16:54,490
nothing changed in a particular image we

00:16:52,870 --> 00:16:57,250
could completely skip creating it and

00:16:54,490 --> 00:16:59,020
just use the previous image and again

00:16:57,250 --> 00:17:02,250
this is something that could be helped

00:16:59,020 --> 00:17:04,390
if we correctly track all the steps in

00:17:02,250 --> 00:17:06,940
before that particular image and

00:17:04,390 --> 00:17:09,250
recompose right now we can't really say

00:17:06,940 --> 00:17:13,449
what changed because all we have is like

00:17:09,250 --> 00:17:16,540
we can say okay the configuration for

00:17:13,449 --> 00:17:19,060
the compass didn't change but generally

00:17:16,540 --> 00:17:20,699
in row height some package is changed in

00:17:19,060 --> 00:17:24,010
the day to day business

00:17:20,699 --> 00:17:26,860
we have no way of tracking what image is

00:17:24,010 --> 00:17:28,510
in what what package is in what image so

00:17:26,860 --> 00:17:33,550
we can't really make this optimization

00:17:28,510 --> 00:17:35,520
right now but it's something that is

00:17:33,550 --> 00:17:38,520
possible and nice and would be useful

00:17:35,520 --> 00:17:38,520
yeah

00:17:43,269 --> 00:17:50,570
that's a good point it's only a couple

00:17:46,429 --> 00:17:52,610
of minutes generally yes it would

00:17:50,570 --> 00:17:55,370
probably be an improvement because right

00:17:52,610 --> 00:17:58,250
now the test phase is done in Sri Sri

00:17:55,370 --> 00:18:00,889
lists so we are on we check one image

00:17:58,250 --> 00:18:03,169
after each other and we're on create

00:18:00,889 --> 00:18:06,259
repo for one repo for another another

00:18:03,169 --> 00:18:08,419
another the actual creation of the repos

00:18:06,259 --> 00:18:10,399
is using a thread also we are using like

00:18:08,419 --> 00:18:13,490
for create recursive processes at the

00:18:10,399 --> 00:18:14,899
same time working on the images so yeah

00:18:13,490 --> 00:18:18,649
this would also probably be a

00:18:14,899 --> 00:18:21,320
possibility to change that and test this

00:18:18,649 --> 00:18:24,049
as soon as it finishes the other

00:18:21,320 --> 00:18:37,669
possibility is to just not care and turn

00:18:24,049 --> 00:18:41,480
these tests off yes yes so punji is

00:18:37,669 --> 00:18:43,639
consuming a bunch of packages from Koji

00:18:41,480 --> 00:18:45,470
and it's doing that by directly

00:18:43,639 --> 00:18:49,629
accessing the Koji volume so the same

00:18:45,470 --> 00:18:49,629
volume is mounted in Kochi and Pangea

00:19:02,940 --> 00:20:08,590
that's a good question but I don't have

00:19:05,140 --> 00:20:11,770
an answer for to summarize for the

00:20:08,590 --> 00:20:15,070
recording the NFS is not particularly

00:20:11,770 --> 00:20:18,840
great here we try doing something newer

00:20:15,070 --> 00:20:18,840
and cooler but they didn't work

00:20:31,970 --> 00:20:35,119
[Music]

00:21:11,560 --> 00:21:17,090
yeah so this is basically an

00:21:15,050 --> 00:21:19,550
implementation detail of how this works

00:21:17,090 --> 00:21:22,550
essentially responds a threat for each

00:21:19,550 --> 00:21:24,530
of the phases and they go and do their

00:21:22,550 --> 00:21:27,170
own work but the main threat that is

00:21:24,530 --> 00:21:29,090
that is monitoring it's like waiting on

00:21:27,170 --> 00:21:34,040
every single one of those in some order

00:21:29,090 --> 00:21:38,810
so if one finishes sooner it waits until

00:21:34,040 --> 00:21:41,840
it eats it until its turn to wait for it

00:21:38,810 --> 00:21:44,690
so this might be possible to fix in some

00:21:41,840 --> 00:21:46,730
way like for example I would really like

00:21:44,690 --> 00:21:50,840
to replace the threads in this case with

00:21:46,730 --> 00:21:56,480
whiten free async because it's not

00:21:50,840 --> 00:21:58,720
really doing anything just waiting yeah

00:21:56,480 --> 00:21:58,720
it's

00:21:59,159 --> 00:22:03,369
yes that's very much possible like the

00:22:01,690 --> 00:22:05,349
first task you spawn will fail

00:22:03,369 --> 00:22:07,450
immediately but you still have to wait

00:22:05,349 --> 00:22:33,369
for everything else to finish this is

00:22:07,450 --> 00:22:35,619
probably fixable in the code we we

00:22:33,369 --> 00:22:39,249
probably could do this so the request is

00:22:35,619 --> 00:22:41,829
can we make this more visible so for

00:22:39,249 --> 00:22:44,079
starters like whenever the face starts

00:22:41,829 --> 00:22:45,899
or ends we send a message so if you're

00:22:44,079 --> 00:22:48,639
actually interested from that we can

00:22:45,899 --> 00:22:50,619
listen to them and do stuff with them

00:22:48,639 --> 00:22:54,099
but it's also possible to generate some

00:22:50,619 --> 00:22:55,539
summary it goes with a caveat that as I

00:22:54,099 --> 00:22:57,579
said with the images like for example

00:22:55,539 --> 00:22:59,259
the timing on the face is not really

00:22:57,579 --> 00:23:03,009
representative of how long the

00:22:59,259 --> 00:23:06,969
individual tasks took because for some

00:23:03,009 --> 00:23:08,649
if there's like one really long face but

00:23:06,969 --> 00:23:11,739
it happens to be the first one to be

00:23:08,649 --> 00:23:14,940
waiting on then every other one will be

00:23:11,739 --> 00:23:14,940
artificially inflated

00:23:24,400 --> 00:23:29,510
but they're having more visibility into

00:23:27,020 --> 00:23:32,450
what takes how long is something that

00:23:29,510 --> 00:23:35,480
would be nice but it's not just a simple

00:23:32,450 --> 00:23:37,610
diff between timestamps in the log

00:23:35,480 --> 00:23:53,240
because of things like waiting for some

00:23:37,610 --> 00:23:55,960
other stuff yes okay so the question is

00:23:53,240 --> 00:24:00,200
what is what time we want to reach and

00:23:55,960 --> 00:24:03,470
what good will it break bring so we

00:24:00,200 --> 00:24:08,090
don't have a set time like as fast as

00:24:03,470 --> 00:24:10,160
possible sounds good but the main issue

00:24:08,090 --> 00:24:14,179
we have with the long composite right

00:24:10,160 --> 00:24:16,640
now is it takes too long from writing a

00:24:14,179 --> 00:24:19,840
building a fixed package to seeing some

00:24:16,640 --> 00:24:19,840
artifact that you can test it away

00:25:46,600 --> 00:25:59,220
trying to use trying to get resources

00:25:49,240 --> 00:25:59,220
that are just how to do like very small

00:26:55,240 --> 00:27:00,830
another way to look at this problem is

00:26:57,680 --> 00:27:02,800
it would be great if we enable federal

00:27:00,830 --> 00:27:06,050
contributors to run compost on their own

00:27:02,800 --> 00:27:07,430
right now if you don't have access to an

00:27:06,050 --> 00:27:10,000
infrastructure you're out of luck

00:27:07,430 --> 00:27:10,000
basically

00:27:25,610 --> 00:27:30,960
exactly yeah that's why those two it's

00:27:28,860 --> 00:27:35,360
it's not interesting to me to talk about

00:27:30,960 --> 00:27:35,360
like doing doing that

00:28:45,779 --> 00:28:51,249
so Bungie supports that the problem is

00:28:49,239 --> 00:28:54,999
that you probably won't have access to

00:28:51,249 --> 00:28:56,679
the volume with packages so if we solve

00:28:54,999 --> 00:28:59,259
that somehow you would be able to just

00:28:56,679 --> 00:29:02,889
take the config from production and say

00:28:59,259 --> 00:29:06,399
okay instead of 30 compose tech I want

00:29:02,889 --> 00:29:08,049
to also use my F 30 Python tag and it

00:29:06,399 --> 00:29:09,399
will figure punji will figure out like

00:29:08,049 --> 00:29:11,710
what are the latest packages so that

00:29:09,399 --> 00:29:14,289
would work the only problem is the

00:29:11,710 --> 00:29:15,850
infrastructure side but we need to make

00:29:14,289 --> 00:29:17,830
sure that the packages can be consumed

00:29:15,850 --> 00:29:26,289
somehow differently than direct NFS

00:29:17,830 --> 00:29:27,639
access if you convince people from the

00:29:26,289 --> 00:29:30,269
infrastructure to give you permissions

00:29:27,639 --> 00:29:30,269
then you can

00:30:25,850 --> 00:30:28,850
sure

00:30:51,160 --> 00:30:56,650
okay so I think we are out of time so

00:30:53,540 --> 00:30:56,650
thank you very much for coming

00:30:56,700 --> 00:31:01,900

YouTube URL: https://www.youtube.com/watch?v=xIDyllbkNZI


