Title: Flock 2017 - The Future of fedmsg
Publication date: 2017-10-20
Playlist: Flock 2017
Description: 
	Wednesday August 30, 2017 3:30pm - 4:00pm
@Grand I
Talk: The Future of fedmsg?
Presenter: Jeremy Cline

Description:
fedmsg is the library Fedora Infrastructure applications use to communicate,
both within applications and to make announcements to the world at large.
It is powered by ZeroMQ, although it supports other message brokers via its
dependency on Moksha.

In this talk, I'd like to cover some of the pain points we have with fedmsg
in Fedora Infrastructure and talk about potential solutions to the problems
we encounter. This includes refactors, re-working features, and adding entirely
new features.
Captions: 
	00:00:00,000 --> 00:00:04,819
and if not I'll just make it up as I go

00:00:01,290 --> 00:00:08,040
along so we're running a bit late but

00:00:04,819 --> 00:00:11,340
I'm Jeremy I work on Fedora

00:00:08,040 --> 00:00:13,469
infrastructure at Red Hat I'm gonna talk

00:00:11,340 --> 00:00:17,520
a little bit about the potential future

00:00:13,469 --> 00:00:19,830
of fed message so everything I say is

00:00:17,520 --> 00:00:23,100
just things I've thought about and I

00:00:19,830 --> 00:00:28,830
welcome feedback and criticism and all

00:00:23,100 --> 00:00:30,900
that stuff so fed message if you're not

00:00:28,830 --> 00:00:35,780
aware is what we use to send messages

00:00:30,900 --> 00:00:40,200
between applications and it has a lot of

00:00:35,780 --> 00:00:42,680
painful aspects so we're gonna quickly

00:00:40,200 --> 00:00:45,390
cover a lot of those pain points and

00:00:42,680 --> 00:00:47,879
then we're gonna talk about publishing

00:00:45,390 --> 00:00:49,789
messages specifically and how that will

00:00:47,879 --> 00:00:54,420
solve some of these pain points and

00:00:49,789 --> 00:00:57,629
message schemas and if you have a

00:00:54,420 --> 00:01:00,210
question along the way just stop me I

00:00:57,629 --> 00:01:05,480
also have a habit of speaking too fast

00:01:00,210 --> 00:01:05,480
so if I start doing that just yell at me

00:01:06,470 --> 00:01:12,270
all right so the pain points in fed

00:01:09,210 --> 00:01:16,770
message I think the the first one I

00:01:12,270 --> 00:01:20,430
always notice is configuration the

00:01:16,770 --> 00:01:23,420
configuration is very complicated it

00:01:20,430 --> 00:01:27,229
doesn't work out of the box you have to

00:01:23,420 --> 00:01:29,790
adjust several configuration options and

00:01:27,229 --> 00:01:33,780
it will load configuration from all over

00:01:29,790 --> 00:01:36,000
the place so I've got a list here of all

00:01:33,780 --> 00:01:39,030
the places there's probably more places

00:01:36,000 --> 00:01:45,689
that I have not documented here so it

00:01:39,030 --> 00:01:48,899
makes it daunting to initial users the

00:01:45,689 --> 00:01:52,619
other issue is publishing messages is

00:01:48,899 --> 00:01:55,110
actually pretty difficult which is a

00:01:52,619 --> 00:01:58,850
problem for a library for sending and

00:01:55,110 --> 00:02:02,880
receiving messages the main issues are

00:01:58,850 --> 00:02:05,969
each thread each Python thread needs an

00:02:02,880 --> 00:02:11,670
end point and you have to define these

00:02:05,969 --> 00:02:13,050
end points before using fed message and

00:02:11,670 --> 00:02:14,310
you have to distribute this

00:02:13,050 --> 00:02:15,989
configuration to

00:02:14,310 --> 00:02:19,590
anybody who wants to listen to your

00:02:15,989 --> 00:02:21,660
messages these are not dynamically

00:02:19,590 --> 00:02:25,290
generated so you have a fixed number of

00:02:21,660 --> 00:02:27,180
endpoints which means you can't spin up

00:02:25,290 --> 00:02:28,890
threads and and do some i/o and then

00:02:27,180 --> 00:02:32,519
kill the threads and have those

00:02:28,890 --> 00:02:35,510
published messages and it generally

00:02:32,519 --> 00:02:38,489
makes it difficult and confusing to use

00:02:35,510 --> 00:02:42,269
when you start up a thread it binds to a

00:02:38,489 --> 00:02:45,739
socket and because network latency is

00:02:42,269 --> 00:02:48,750
not zero it takes a bit of time before a

00:02:45,739 --> 00:02:51,840
potential consumer will connect to you

00:02:48,750 --> 00:02:54,540
and this often leads to mysterious

00:02:51,840 --> 00:02:57,870
message loss and and this is also very

00:02:54,540 --> 00:03:00,390
confusing one thing people want to do

00:02:57,870 --> 00:03:06,349
with it is published is 0 mq which is

00:03:00,390 --> 00:03:10,410
what Fedora does and also AMQP or

00:03:06,349 --> 00:03:14,400
ActiveMQ or stomp or choose your your

00:03:10,410 --> 00:03:16,709
message technology here and it does do

00:03:14,400 --> 00:03:19,950
that but you can't do both at the same

00:03:16,709 --> 00:03:24,840
time so if you want to have 0 mq and

00:03:19,950 --> 00:03:27,600
AMQP that's not currently possible the

00:03:24,840 --> 00:03:30,980
the final and most common pain point I

00:03:27,600 --> 00:03:35,579
think is that message schemas change

00:03:30,980 --> 00:03:38,940
regularly and this leads to a lot of key

00:03:35,579 --> 00:03:41,430
errors when programs look in in just

00:03:38,940 --> 00:03:44,880
plain Python dictionaries and suddenly

00:03:41,430 --> 00:03:47,040
Keys have changed so having some tools

00:03:44,880 --> 00:03:49,019
to enforce that for developers I think

00:03:47,040 --> 00:03:51,380
will make it much less painful for

00:03:49,019 --> 00:03:51,380
everybody

00:03:52,040 --> 00:03:59,430
subscribing is is there's two different

00:03:56,069 --> 00:04:03,950
ways to subscribe to messages there's a

00:03:59,430 --> 00:04:06,810
simple for loop basically it just

00:04:03,950 --> 00:04:10,910
receives all messages and you can act on

00:04:06,810 --> 00:04:15,359
them one at a time the second way is

00:04:10,910 --> 00:04:19,940
using a library called moksha or moksha

00:04:15,359 --> 00:04:24,240
I'm not really sure moksha ok moksha and

00:04:19,940 --> 00:04:27,390
it you define a class and then you have

00:04:24,240 --> 00:04:28,020
to add an entry point and then you start

00:04:27,390 --> 00:04:30,800
this other Sur

00:04:28,020 --> 00:04:34,590
service and hope everything goes well

00:04:30,800 --> 00:04:38,009
but it has a fairly rigid API it doesn't

00:04:34,590 --> 00:04:40,319
let you define a topic when you start it

00:04:38,009 --> 00:04:42,000
when you start running your consumer and

00:04:40,319 --> 00:04:46,470
this is something a lot of people want

00:04:42,000 --> 00:04:51,330
to do they might want to test in stage

00:04:46,470 --> 00:04:53,580
and in production and not altar and and

00:04:51,330 --> 00:04:57,419
be able to provide the topic the message

00:04:53,580 --> 00:04:58,860
topic that the consumer uses at runtime

00:04:57,419 --> 00:05:04,590
and this is very difficult

00:04:58,860 --> 00:05:07,620
currently often this is they it's you

00:05:04,590 --> 00:05:09,150
can do this but only in initialization

00:05:07,620 --> 00:05:10,770
and you have to do it in a very specific

00:05:09,150 --> 00:05:14,240
order and if you don't you'll get weird

00:05:10,770 --> 00:05:18,659
errors and nobody knows what to do then

00:05:14,240 --> 00:05:22,409
and finally it's a mixture of twisted

00:05:18,659 --> 00:05:26,310
asynchronous code and threads and that

00:05:22,409 --> 00:05:31,530
is risky at best and and often runs into

00:05:26,310 --> 00:05:33,949
trouble the last thing that fed message

00:05:31,530 --> 00:05:38,430
offers is cryptography message

00:05:33,949 --> 00:05:40,979
authentication and authorization and at

00:05:38,430 --> 00:05:43,770
the time this was implemented 0 mq did

00:05:40,979 --> 00:05:48,690
not have any feature to do this but now

00:05:43,770 --> 00:05:50,819
it does so we have a lot of we have two

00:05:48,690 --> 00:05:55,289
different cryptography stacks we use em

00:05:50,819 --> 00:05:57,180
to crypto or cryptography and we prefer

00:05:55,289 --> 00:06:00,440
cryptography but it requires a fairly

00:05:57,180 --> 00:06:02,849
new version and this leads to a lot of a

00:06:00,440 --> 00:06:08,430
lot of problems especially when you

00:06:02,849 --> 00:06:12,900
install from PI pi so I think we can

00:06:08,430 --> 00:06:15,090
simplify that greatly the last thing I

00:06:12,900 --> 00:06:17,810
think it would be really nice is if it

00:06:15,090 --> 00:06:21,650
was easy for developers to write tests

00:06:17,810 --> 00:06:26,639
record messages they publish replay them

00:06:21,650 --> 00:06:28,949
like VCR for most HTTP libraries and

00:06:26,639 --> 00:06:35,550
that makes it a lot easier on developers

00:06:28,949 --> 00:06:39,089
to write reliable consumers so I have

00:06:35,550 --> 00:06:41,680
come up with a potential new publishing

00:06:39,089 --> 00:06:44,289
architecture

00:06:41,680 --> 00:06:48,400
much it's I just have a proof of concept

00:06:44,289 --> 00:06:51,370
and I'm still working on it

00:06:48,400 --> 00:06:57,880
but I definitely welcome any feedback

00:06:51,370 --> 00:07:00,190
any suggestions and hopefully it will

00:06:57,880 --> 00:07:03,610
solve a lot of the problems I just

00:07:00,190 --> 00:07:05,710
covered so the current architecture for

00:07:03,610 --> 00:07:10,020
for fed message publishing and

00:07:05,710 --> 00:07:12,850
subscribing is this sort of complicated

00:07:10,020 --> 00:07:15,639
diagram over here which I realized now

00:07:12,850 --> 00:07:18,460
that the black arrows on the dark

00:07:15,639 --> 00:07:23,349
background aren't great but it's okay

00:07:18,460 --> 00:07:26,669
it is a tangled mess basically every

00:07:23,349 --> 00:07:31,120
subscriber has to connect to every

00:07:26,669 --> 00:07:32,680
publisher which I described earlier so

00:07:31,120 --> 00:07:34,960
you can think of each publisher at the

00:07:32,680 --> 00:07:38,020
top as a Python thread or a Python

00:07:34,960 --> 00:07:43,240
process and each subscriber at the

00:07:38,020 --> 00:07:44,680
bottom as an interested party but when

00:07:43,240 --> 00:07:48,180
you want to add a new publisher you have

00:07:44,680 --> 00:07:51,610
to tell all the subscribers about it and

00:07:48,180 --> 00:07:54,729
each publisher has to have a connection

00:07:51,610 --> 00:08:00,099
from each subscriber and this quickly

00:07:54,729 --> 00:08:05,409
does not scale so for example Bodie has

00:08:00,099 --> 00:08:08,740
60 endpoints and each subscriber has to

00:08:05,409 --> 00:08:11,860
connect to all 60 of these and when you

00:08:08,740 --> 00:08:15,880
have 60 times you say you have 250

00:08:11,860 --> 00:08:19,419
interested parties that's tens of

00:08:15,880 --> 00:08:21,520
thousands of sockets so that's not very

00:08:19,419 --> 00:08:28,289
efficient and it's very difficult to

00:08:21,520 --> 00:08:28,289
track down where messages get lost so

00:08:29,649 --> 00:08:39,250
yeah so it has four servers and each

00:08:34,690 --> 00:08:43,880
each thread needs its own end point so

00:08:39,250 --> 00:08:45,889
each web request handler has its own end

00:08:43,880 --> 00:08:48,079
point the back end has a couple end

00:08:45,889 --> 00:08:51,709
points I don't know if they're all used

00:08:48,079 --> 00:08:53,240
but because it's a static list you have

00:08:51,709 --> 00:08:55,699
to define at least as many as you're

00:08:53,240 --> 00:08:57,920
gonna use and maybe more so you also

00:08:55,699 --> 00:08:59,300
have a lot of subscribers who are just

00:08:57,920 --> 00:09:01,430
sitting there trying to connect so

00:08:59,300 --> 00:09:04,720
things that it'll never be able to

00:09:01,430 --> 00:09:04,720
connect to if you don't use them all

00:09:06,579 --> 00:09:14,660
yeah so your you'll have you know port

00:09:10,880 --> 00:09:20,660
9000 9001 9,000 to 9,000 so on and so

00:09:14,660 --> 00:09:24,740
forth yeah so obviously it would be nice

00:09:20,660 --> 00:09:28,160
if we didn't have to do that so the

00:09:24,740 --> 00:09:32,600
other approach is to create basically a

00:09:28,160 --> 00:09:35,000
broker with 0 mq so at the top you have

00:09:32,600 --> 00:09:38,420
the publishers again and they talked to

00:09:35,000 --> 00:09:42,350
this service which will publish for them

00:09:38,420 --> 00:09:45,889
and the subscribers also talk to this

00:09:42,350 --> 00:09:47,899
service and so the the publishers

00:09:45,889 --> 00:09:49,579
actually submit their messages to the

00:09:47,899 --> 00:09:50,870
you can call this the broker I think

00:09:49,579 --> 00:09:54,350
they're called the published service but

00:09:50,870 --> 00:09:56,779
brokers probably better so they submit

00:09:54,350 --> 00:09:59,569
it to the published service and the

00:09:56,779 --> 00:10:03,350
published service then publishes it and

00:09:59,569 --> 00:10:04,880
in this diagram we're doing 0 and Q but

00:10:03,350 --> 00:10:06,709
the nice thing about this design is that

00:10:04,880 --> 00:10:08,990
the published service can just publish

00:10:06,709 --> 00:10:13,430
it however it wants and it can publish

00:10:08,990 --> 00:10:15,560
it in many ways at the same time and if

00:10:13,430 --> 00:10:17,689
you're familiar with 0 mq which you

00:10:15,560 --> 00:10:20,510
don't have to be for this but it uses

00:10:17,689 --> 00:10:22,160
request and response sockets so that

00:10:20,510 --> 00:10:24,589
happens synchronously and you can be

00:10:22,160 --> 00:10:27,970
sure that messages either did get

00:10:24,589 --> 00:10:31,490
published or did not get published and

00:10:27,970 --> 00:10:36,500
combining this with something like AMQP

00:10:31,490 --> 00:10:38,269
can let you reliably publish messages or

00:10:36,500 --> 00:10:41,180
not publish messages you'll at least

00:10:38,269 --> 00:10:43,850
know because in the current design

00:10:41,180 --> 00:10:46,760
you publish a message and you have no

00:10:43,850 --> 00:10:50,000
idea what happens it may get lost there

00:10:46,760 --> 00:10:52,430
may have been nobody listening so

00:10:50,000 --> 00:10:54,800
there's a lot of uncertainty which is

00:10:52,430 --> 00:10:57,560
fine and there's good reasons to do that

00:10:54,800 --> 00:11:05,510
but many people are using fed message in

00:10:57,560 --> 00:11:07,130
a way that requires more certainty so I

00:11:05,510 --> 00:11:11,150
think I've I've talked a bit about the

00:11:07,130 --> 00:11:12,830
benefits but we have a single point for

00:11:11,150 --> 00:11:16,010
all the subscribers to talk to so you

00:11:12,830 --> 00:11:18,740
don't have to let them know when you

00:11:16,010 --> 00:11:21,380
bring up more publishers so you can you

00:11:18,740 --> 00:11:26,080
can add a new web for an end to bodie

00:11:21,380 --> 00:11:26,080
without having to add more endpoints the

00:11:26,140 --> 00:11:31,520
the race condition of binding to a

00:11:29,270 --> 00:11:34,130
socket and having a subscriber connect

00:11:31,520 --> 00:11:35,390
to it before you publish is no longer a

00:11:34,130 --> 00:11:38,120
problem because they connect to the

00:11:35,390 --> 00:11:40,850
service that should be running well

00:11:38,120 --> 00:11:42,110
before you try to publish anything and

00:11:40,850 --> 00:11:45,890
then it will just continue to run

00:11:42,110 --> 00:11:49,310
whether you restart the publishing the

00:11:45,890 --> 00:11:53,060
like if you restart bori for example in

00:11:49,310 --> 00:11:54,680
its current form all the subscribers

00:11:53,060 --> 00:11:57,440
will have to quickly reconnect before it

00:11:54,680 --> 00:12:00,550
publishes anything whereas with this

00:11:57,440 --> 00:12:00,550
service you don't have to do that

00:12:00,640 --> 00:12:06,140
another nice thing is that this will

00:12:02,930 --> 00:12:07,430
this will work out of the box currently

00:12:06,140 --> 00:12:10,700
one of the things you have to configure

00:12:07,430 --> 00:12:12,290
with fed message is all the endpoints it

00:12:10,700 --> 00:12:14,210
doesn't come with any default ones and

00:12:12,290 --> 00:12:19,570
so if you try to publish a message you

00:12:14,210 --> 00:12:22,970
just won't work and so this will use a

00:12:19,570 --> 00:12:24,860
inter-process communication socket for

00:12:22,970 --> 00:12:27,880
default submissions so you would run

00:12:24,860 --> 00:12:31,940
this server this service on every host

00:12:27,880 --> 00:12:37,960
basically and it'll bind by default to a

00:12:31,940 --> 00:12:40,250
TCP socket you can also use this

00:12:37,960 --> 00:12:44,420
published service to forward to other

00:12:40,250 --> 00:12:45,980
published services if you want to scale

00:12:44,420 --> 00:12:49,970
out a little bit or combine your

00:12:45,980 --> 00:12:53,360
messages you can do both so instead of

00:12:49,970 --> 00:12:54,890
having go back instead of having

00:12:53,360 --> 00:12:56,510
subscribers

00:12:54,890 --> 00:12:58,970
talking to the published service you

00:12:56,510 --> 00:13:01,370
could have more published services so if

00:12:58,970 --> 00:13:03,320
you needed to deal with a whole bunch of

00:13:01,370 --> 00:13:05,000
subscribers you could have many services

00:13:03,320 --> 00:13:11,870
running that all publish the same

00:13:05,000 --> 00:13:14,089
message another cool thing that I

00:13:11,870 --> 00:13:17,660
mentioned is you can publish to 0 and Q

00:13:14,089 --> 00:13:21,260
mu P whatever publisher you want to

00:13:17,660 --> 00:13:24,170
implement all at the same time you can

00:13:21,260 --> 00:13:26,959
publish multiple variations on the 0 in

00:13:24,170 --> 00:13:29,360
Q format so if you want to change the

00:13:26,959 --> 00:13:32,570
wire format that becomes easy you just

00:13:29,360 --> 00:13:33,950
add a new socket let everybody connect

00:13:32,570 --> 00:13:36,500
to the new one and once you're satisfied

00:13:33,950 --> 00:13:40,130
that everybody's updated you just kill

00:13:36,500 --> 00:13:42,320
the old one it gives us the ability to

00:13:40,130 --> 00:13:44,810
have reliable messages if we want that

00:13:42,320 --> 00:13:46,550
and it's it's simpler to debug because

00:13:44,810 --> 00:13:52,190
there's only one place messages are

00:13:46,550 --> 00:13:56,589
getting sent so I'm gonna try a live

00:13:52,190 --> 00:14:00,760
demo which I know is very dangerous so

00:13:56,589 --> 00:14:07,480
it may not work but hopefully it will

00:14:00,760 --> 00:14:12,230
see here I have to drag this somewhere

00:14:07,480 --> 00:14:16,149
aha alright so I've made the font really

00:14:12,230 --> 00:14:21,140
big hopefully everybody can see that I

00:14:16,149 --> 00:14:25,220
can't see it but that's okay so I've

00:14:21,140 --> 00:14:29,690
made a short little demo script so at

00:14:25,220 --> 00:14:31,970
the top I just call C here so I'll and I

00:14:29,690 --> 00:14:35,149
import a multi processing pool so I'm

00:14:31,970 --> 00:14:38,329
just going to call a function in a whole

00:14:35,149 --> 00:14:45,860
bunch of different processes and all it

00:14:38,329 --> 00:14:49,040
does is publish a short message and down

00:14:45,860 --> 00:14:51,949
here I'll just map this into the multi

00:14:49,040 --> 00:14:53,449
process pool so when I run this we'll

00:14:51,949 --> 00:14:58,070
have a whole bunch of people checking in

00:14:53,449 --> 00:15:01,220
basically so this is the the new design

00:14:58,070 --> 00:15:03,140
I have written a really really bad

00:15:01,220 --> 00:15:07,810
implementation of this published service

00:15:03,140 --> 00:15:07,810
so it may crash hopefully not

00:15:08,389 --> 00:15:13,410
so the the other thing I need to do is

00:15:10,949 --> 00:15:18,329
subscribe and actually hear about these

00:15:13,410 --> 00:15:23,389
messages so I think I subscribe to the

00:15:18,329 --> 00:15:23,389
right port but we'll see you in a second

00:15:28,250 --> 00:15:35,220
alright so I'm gonna run this script and

00:15:31,410 --> 00:15:36,990
so you can see at the top it's sent 4

00:15:35,220 --> 00:15:42,660
messages and I can't see if it actually

00:15:36,990 --> 00:15:47,670
received them looks like it did all four

00:15:42,660 --> 00:15:51,540
of them yeah cool alright so the other

00:15:47,670 --> 00:15:55,560
thing this did which I'm gonna have to

00:15:51,540 --> 00:16:05,190
do some more dragging here is publish

00:15:55,560 --> 00:16:08,339
this to RabbitMQ so you can see I've got

00:16:05,190 --> 00:16:13,709
a RabbitMQ broker and here came our four

00:16:08,339 --> 00:16:15,720
messages and they landed in the same

00:16:13,709 --> 00:16:22,470
message queue it got published to the

00:16:15,720 --> 00:16:28,019
leader dot standby cue and we can go

00:16:22,470 --> 00:16:31,769
down here I can see and get get the same

00:16:28,019 --> 00:16:34,380
message that was published to 0 mq so

00:16:31,769 --> 00:16:37,560
this lets you do both and this is nice

00:16:34,380 --> 00:16:42,360
if you have existing AMQP infrastructure

00:16:37,560 --> 00:16:50,339
or ActiveMQ and you also want to use 0

00:16:42,360 --> 00:16:52,740
mq apps that we've written so actually I

00:16:50,339 --> 00:16:59,329
had one more bit to my demo and it's how

00:16:52,740 --> 00:16:59,329
it works currently or in the old way and

00:16:59,680 --> 00:17:02,900
[Music]

00:17:06,670 --> 00:17:12,530
so you'll notice here I have to

00:17:08,990 --> 00:17:14,540
subscribe to four different end points

00:17:12,530 --> 00:17:18,320
this is because I want to send four

00:17:14,540 --> 00:17:21,530
messages in four different processes and

00:17:18,320 --> 00:17:23,630
I've configured this already to to use

00:17:21,530 --> 00:17:26,320
these endpoints so I'm gonna have to

00:17:23,630 --> 00:17:29,270
connect to all of these endpoints and

00:17:26,320 --> 00:17:33,080
then I'm gonna go back and send these

00:17:29,270 --> 00:17:35,840
messages in the old way which uses the

00:17:33,080 --> 00:17:40,400
script looks basically the same it just

00:17:35,840 --> 00:17:42,440
uses the old publish function alright so

00:17:40,400 --> 00:17:46,340
it published four messages or should

00:17:42,440 --> 00:18:01,420
have I don't know how many showed up it

00:17:46,340 --> 00:18:01,420
varies sometimes all four do you arrive

00:18:17,670 --> 00:18:24,030
I think to arrived but there should have

00:18:20,370 --> 00:18:27,120
been four so you'll see that uh messages

00:18:24,030 --> 00:18:29,820
got lost because because of this startup

00:18:27,120 --> 00:18:32,820
time each process spins up binds to one

00:18:29,820 --> 00:18:34,710
of those sockets and then the subscriber

00:18:32,820 --> 00:18:36,990
has to connect quickly before it sends

00:18:34,710 --> 00:18:39,750
the message and you can ever know how

00:18:36,990 --> 00:18:49,170
fast the networks going to be so it

00:18:39,750 --> 00:18:53,309
makes it very very unreliable so I can't

00:18:49,170 --> 00:18:58,160
find my slides again so yeah that's

00:18:53,309 --> 00:18:58,160
that's publishing yeah Mike

00:19:11,080 --> 00:19:15,930
you could set it up that way the nice

00:19:13,360 --> 00:19:18,880
thing about this is it's very flexible

00:19:15,930 --> 00:19:21,520
if you want to have a separate published

00:19:18,880 --> 00:19:24,100
service you can have one or you can have

00:19:21,520 --> 00:19:28,420
half a dozen you can combine them all

00:19:24,100 --> 00:19:32,170
into a single endpoint kind of like hub

00:19:28,420 --> 00:19:34,950
dot Fedora project or today and it's

00:19:32,170 --> 00:19:36,850
kind of how you want to deploy it

00:19:34,950 --> 00:19:39,460
obviously if you combine them all into

00:19:36,850 --> 00:19:42,490
one and everybody talks to that it's if

00:19:39,460 --> 00:19:44,320
one of them if that service goes down

00:19:42,490 --> 00:19:48,220
for example nobody's gonna get any

00:19:44,320 --> 00:20:07,270
messages but you may decide that that's

00:19:48,220 --> 00:20:09,340
worth the simplicity yeah so this is why

00:20:07,270 --> 00:20:13,810
I called this talk the future of fed

00:20:09,340 --> 00:20:16,740
message because I think that this would

00:20:13,810 --> 00:20:18,580
be a great way to get us to use a broker

00:20:16,740 --> 00:20:21,340
which you know everybody's using

00:20:18,580 --> 00:20:26,350
messages in a way where they want it to

00:20:21,340 --> 00:20:30,220
be reliable and so this way you can just

00:20:26,350 --> 00:20:32,860
add AMQP in the back and then migrate

00:20:30,220 --> 00:20:36,040
however fast you want so I definitely

00:20:32,860 --> 00:20:38,760
agree this is more of a migration

00:20:36,040 --> 00:20:42,180
strategy or potential migration strategy

00:20:38,760 --> 00:20:42,180
yeah Adam

00:20:47,160 --> 00:20:54,570
ah I wasn't there at the time I do know

00:20:50,670 --> 00:20:59,190
that RabbitMQ oh yes so the question was

00:20:54,570 --> 00:21:02,570
was fed message not written in the way

00:20:59,190 --> 00:21:05,550
it is because all the brokers fell over

00:21:02,570 --> 00:21:09,360
from the number of messages that's a

00:21:05,550 --> 00:21:35,910
paraphrase I did but yeah the the answer

00:21:09,360 --> 00:21:37,260
is I was not there at the time yeah yeah

00:21:35,910 --> 00:21:40,530
so the question is has anything changed

00:21:37,260 --> 00:21:42,360
since the initial investigation into

00:21:40,530 --> 00:21:47,370
Merkers to make us believe they would be

00:21:42,360 --> 00:21:48,750
a better solution today not that I'm

00:21:47,370 --> 00:21:54,360
aware of I didn't do the initial

00:21:48,750 --> 00:21:59,040
investigation I will say that brokers

00:21:54,360 --> 00:22:04,290
like RabbitMQ are deployed in many large

00:21:59,040 --> 00:22:07,080
production areas and run it massive

00:22:04,290 --> 00:22:15,200
scales far beyond what we do hundreds of

00:22:07,080 --> 00:22:15,200
thousands of messages a second so yeah

00:22:20,240 --> 00:22:35,630
yeah so I mean you know yeah and you

00:22:27,210 --> 00:22:35,630
don't even have to use AMQP yeah

00:22:42,580 --> 00:22:47,730
[Music]

00:23:09,620 --> 00:23:25,350
it's true you know there's so it's true

00:23:22,110 --> 00:23:30,049
so the the comment was I guess basically

00:23:25,350 --> 00:23:33,690
that reliable message buses are

00:23:30,049 --> 00:23:45,029
appealing but rarely work is that a good

00:23:33,690 --> 00:23:47,730
summary I don't know for the it's true I

00:23:45,029 --> 00:23:51,450
think there are plenty of reasons to not

00:23:47,730 --> 00:23:53,059
want a reliable message service and

00:23:51,450 --> 00:23:55,230
there are plenty of things we do in

00:23:53,059 --> 00:23:58,500
fedora infrastructure where we don't

00:23:55,230 --> 00:24:03,539
care whether a message gets lost the

00:23:58,500 --> 00:24:06,210
problem is that many people want to

00:24:03,539 --> 00:24:08,250
guarantee that a message either made it

00:24:06,210 --> 00:24:09,990
or didn't make it and there's no way to

00:24:08,250 --> 00:24:11,580
answer that right now and there are

00:24:09,990 --> 00:24:15,929
plenty of patterns in 0 mq to make this

00:24:11,580 --> 00:24:17,429
possible where you can you know send a

00:24:15,929 --> 00:24:18,960
message and have something on the other

00:24:17,429 --> 00:24:20,220
side that checks back in and if it

00:24:18,960 --> 00:24:23,580
doesn't check back in and you assume you

00:24:20,220 --> 00:24:26,669
lost it but yeah distributed computing

00:24:23,580 --> 00:24:32,309
is really hard and messages get lost no

00:24:26,669 --> 00:24:33,450
matter what you do and yeah I don't

00:24:32,309 --> 00:24:37,770
really have a good answer other than

00:24:33,450 --> 00:24:41,280
it's tough yeah so Adam

00:24:37,770 --> 00:24:44,640
I have looked at Gil message they're

00:24:41,280 --> 00:24:49,230
also very common like in 0m q has rfcs

00:24:44,640 --> 00:24:57,240
and very common patterns and so yeah the

00:24:49,230 --> 00:25:01,020
reliable messaging via Durham Q is yeah

00:24:57,240 --> 00:25:02,640
I mean we could use that it's it's the

00:25:01,020 --> 00:25:06,480
the thing that really spurred this is

00:25:02,640 --> 00:25:09,000
that we had all this C ICD stuff and

00:25:06,480 --> 00:25:11,250
people were running all these tests in

00:25:09,000 --> 00:25:15,390
sent OS infrastructure and we want to

00:25:11,250 --> 00:25:18,420
get the results to the Fedora results DB

00:25:15,390 --> 00:25:20,190
and people wanted to send reliable

00:25:18,420 --> 00:25:22,110
messages and there are plenty of other

00:25:20,190 --> 00:25:25,380
times people have said well I I expect

00:25:22,110 --> 00:25:38,000
this to make it or know that it didn't

00:25:25,380 --> 00:25:38,000
make it and we can't answer that so yeah

00:26:32,190 --> 00:26:35,450
Tim I think first

00:27:04,200 --> 00:27:31,230
I don't really like I don't have off the

00:27:27,840 --> 00:27:32,370
top of my head how many people want want

00:27:31,230 --> 00:27:34,409
it to be reliable I have heard people

00:27:32,370 --> 00:27:35,549
say that it is reliable which is just

00:27:34,409 --> 00:27:37,830
not true

00:27:35,549 --> 00:27:40,529
and when you make those assumptions you

00:27:37,830 --> 00:27:42,440
have problems because you've assumed

00:27:40,529 --> 00:27:57,659
that the message will either get there

00:27:42,440 --> 00:27:59,580
you know you'll be told about it it's

00:27:57,659 --> 00:28:02,490
true and you don't have to use AMQP as a

00:27:59,580 --> 00:28:05,250
back-end you can still use 0nq and the

00:28:02,490 --> 00:28:09,269
messages will either get there or won't

00:28:05,250 --> 00:28:11,190
and that's fine but what you get from

00:28:09,269 --> 00:28:13,320
having this service is that you don't

00:28:11,190 --> 00:28:17,700
have to write down all your endpoints

00:28:13,320 --> 00:28:20,210
and not use like threads or have to

00:28:17,700 --> 00:28:22,590
distribute this massive list or have

00:28:20,210 --> 00:28:25,740
have everybody have to connect to

00:28:22,590 --> 00:28:30,350
hundreds of endpoints so you can still

00:28:25,740 --> 00:28:30,350
use their mq Randy

00:28:58,080 --> 00:29:03,429
yeah so I think it can be fixed in other

00:29:00,940 --> 00:29:05,530
ways um and it's just a matter about

00:29:03,429 --> 00:29:07,090
being honest like is it going to be

00:29:05,530 --> 00:29:09,190
reliable or not and if it's not reliable

00:29:07,090 --> 00:29:13,000
application developers need to deal with

00:29:09,190 --> 00:29:14,980
that and if it is they need to know

00:29:13,000 --> 00:29:18,130
about that and you need to you just need

00:29:14,980 --> 00:29:33,870
to go one way or the other and the

00:29:18,130 --> 00:29:33,870
problem is yeah

00:30:13,930 --> 00:30:21,320
yeah

00:30:15,140 --> 00:30:25,000
so to summarize no we don't need this

00:30:21,320 --> 00:30:28,240
there you can you can build reliable

00:30:25,000 --> 00:30:32,930
messaging techniques on top of 0 and Q

00:30:28,240 --> 00:30:35,060
using unreliable techniques and then you

00:30:32,930 --> 00:30:36,890
do that if you want to know that your

00:30:35,060 --> 00:30:39,140
message got there or didn't and if you

00:30:36,890 --> 00:30:42,530
don't care about that then you know

00:30:39,140 --> 00:30:47,240
that's fine but people have cared about

00:30:42,530 --> 00:30:50,120
that using bad message so this is just a

00:30:47,240 --> 00:30:52,790
happy side-effect of solving a different

00:30:50,120 --> 00:30:57,790
problem which is that you don't need to

00:30:52,790 --> 00:30:57,790
have 60 endpoints for an application

00:31:02,680 --> 00:31:09,500
that's fair that's fair it's just mostly

00:31:06,680 --> 00:31:11,480
this is already a feature in in fed

00:31:09,500 --> 00:31:14,210
message via mantra and I don't want to

00:31:11,480 --> 00:31:16,010
have to support moksha and so I want to

00:31:14,210 --> 00:31:19,310
have feature parity and I know that

00:31:16,010 --> 00:31:24,320
people use this feature to publish to

00:31:19,310 --> 00:31:26,960
AMQP and you to stomp so providing this

00:31:24,320 --> 00:31:33,470
is basically feature parity and we don't

00:31:26,960 --> 00:31:35,140
have to use it but it'll be there so see

00:31:33,470 --> 00:31:39,410
I don't know how much time I have left

00:31:35,140 --> 00:31:40,370
I'm Way over time actually so I don't

00:31:39,410 --> 00:31:43,850
know if there's something after this

00:31:40,370 --> 00:31:47,420
talk we can skip the end of the talk if

00:31:43,850 --> 00:31:50,120
you want or we can keep going okay well

00:31:47,420 --> 00:31:51,850
then I guess we're done but that was the

00:31:50,120 --> 00:31:56,510
the interesting part of the talk anyway

00:31:51,850 --> 00:31:57,110
and I guess just to summarize we got to

00:31:56,510 --> 00:32:02,330
the questions

00:31:57,110 --> 00:32:05,240
oops I went too far so there's there's a

00:32:02,330 --> 00:32:11,000
couple issues on fed message if you have

00:32:05,240 --> 00:32:13,520
opinions please chime in I definitely

00:32:11,000 --> 00:32:15,990
like to hear what people have to say so

00:32:13,520 --> 00:32:21,940
thank you very much

00:32:15,990 --> 00:32:21,940

YouTube URL: https://www.youtube.com/watch?v=SWVuohR5xbY


