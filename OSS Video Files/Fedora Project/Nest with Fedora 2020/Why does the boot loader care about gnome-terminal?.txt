Title: Why does the boot loader care about gnome-terminal?
Publication date: 2020-09-15
Playlist: Nest with Fedora 2020
Description: 
	This session takes a look at why are we adding connections between pieces of software at widely different levels.

Presented at Nest With Fedora 2020.
Captions: 
	00:00:02,159 --> 00:00:05,120
uh i want to talk about some

00:00:03,840 --> 00:00:07,600
some changes that have been happening in

00:00:05,120 --> 00:00:07,600
fedora

00:00:07,839 --> 00:00:12,080
and the slides are

00:00:13,100 --> 00:00:16,720
[Music]

00:00:14,920 --> 00:00:19,119
online

00:00:16,720 --> 00:00:19,119
and

00:00:21,039 --> 00:00:26,650
i'll start with a disclaimer that uh

00:00:24,560 --> 00:00:29,679
are we talking in a way that

00:00:26,650 --> 00:00:33,360
[Music]

00:00:29,679 --> 00:00:36,880
is from the point of view of systemd

00:00:33,360 --> 00:00:41,280
because i work on systemd and

00:00:36,880 --> 00:00:43,600
often i will use gnome as an example

00:00:41,280 --> 00:00:45,039
which is because i use gnome myself and

00:00:43,600 --> 00:00:48,320
i know it

00:00:45,039 --> 00:00:51,360
relatively well but

00:00:48,320 --> 00:00:51,360
the idea is to

00:00:51,760 --> 00:00:56,559
crea to let different desktops and

00:00:54,800 --> 00:01:00,399
different distribution collaborate

00:00:56,559 --> 00:01:05,680
so please treat this as examples

00:01:00,399 --> 00:01:05,680
not as as the only only way to do stuff

00:01:06,400 --> 00:01:14,080
and well

00:01:10,080 --> 00:01:16,320
i want to talk about changes that

00:01:14,080 --> 00:01:17,439
connect different components into

00:01:16,320 --> 00:01:21,119
distribution

00:01:17,439 --> 00:01:24,479
the high level and the low level

00:01:21,119 --> 00:01:26,479
very high level things like

00:01:24,479 --> 00:01:28,240
well the gnome terminal that is in the

00:01:26,479 --> 00:01:30,880
title and

00:01:28,240 --> 00:01:32,400
everything in the in between and then

00:01:30,880 --> 00:01:35,840
very low level things like

00:01:32,400 --> 00:01:40,640
uh the kernel the bootloader

00:01:35,840 --> 00:01:42,880
uh the system manager

00:01:40,640 --> 00:01:42,880
and

00:01:44,560 --> 00:01:48,560
people some people say that different

00:01:46,960 --> 00:01:50,079
things should should be should do

00:01:48,560 --> 00:01:52,840
separate jobs and shouldn't

00:01:50,079 --> 00:01:55,360
care too much about each other and i

00:01:52,840 --> 00:01:56,320
disagree and in this talk i want to to

00:01:55,360 --> 00:02:01,040
show

00:01:56,320 --> 00:02:02,880
uh some examples of the of

00:02:01,040 --> 00:02:04,479
things like this that are happening

00:02:02,880 --> 00:02:07,360
right now and

00:02:04,479 --> 00:02:08,000
explain why they're done like this and

00:02:07,360 --> 00:02:11,520
why i think it's

00:02:08,000 --> 00:02:14,239
a good thing and

00:02:11,520 --> 00:02:15,360
why in the long run i expect that we'll

00:02:14,239 --> 00:02:18,879
have even more

00:02:15,360 --> 00:02:22,720
of of such integrations

00:02:18,879 --> 00:02:24,239
and um

00:02:22,720 --> 00:02:26,640
some of those things are kind of

00:02:24,239 --> 00:02:28,800
complicated

00:02:26,640 --> 00:02:30,720
and the the implementation at the bottom

00:02:28,800 --> 00:02:33,920
is often

00:02:30,720 --> 00:02:35,200
quite complex but

00:02:33,920 --> 00:02:37,680
i think it's easier to start from the

00:02:35,200 --> 00:02:38,480
bottom because the stuff that's at the

00:02:37,680 --> 00:02:41,040
bottom

00:02:38,480 --> 00:02:42,480
of this of stack of components the

00:02:41,040 --> 00:02:46,480
low-level components they

00:02:42,480 --> 00:02:47,920
they usually have a clear goal and

00:02:46,480 --> 00:02:50,160
since i'm not talking about the

00:02:47,920 --> 00:02:53,200
implementation just about the

00:02:50,160 --> 00:02:55,120
um the purpose then it's easier to start

00:02:53,200 --> 00:02:59,360
at the bottom and go up

00:02:55,120 --> 00:03:02,720
so without

00:02:59,360 --> 00:03:04,720
further ado let me start with a

00:03:02,720 --> 00:03:06,080
something that is called boot blessing

00:03:04,720 --> 00:03:09,360
so

00:03:06,080 --> 00:03:13,120
um put blessing is a name that is used

00:03:09,360 --> 00:03:16,239
in systemd some

00:03:13,120 --> 00:03:18,800
others call it a bit different

00:03:16,239 --> 00:03:20,959
but in general the idea is that the uh

00:03:18,800 --> 00:03:24,080
bootloader boots a kernel

00:03:20,959 --> 00:03:25,280
and uh well assuming that the kernel

00:03:24,080 --> 00:03:28,159
loaded from this fine

00:03:25,280 --> 00:03:29,120
and the boot started the bootloader

00:03:28,159 --> 00:03:33,200
cannot

00:03:29,120 --> 00:03:35,920
know if the uh if the kernel

00:03:33,200 --> 00:03:36,480
booted successfully and if the boot was

00:03:35,920 --> 00:03:40,720
actually

00:03:36,480 --> 00:03:40,720
useful for the user so

00:03:41,040 --> 00:03:45,360
we need to create a feedback loop and we

00:03:42,879 --> 00:03:48,640
let the user space

00:03:45,360 --> 00:03:49,760
that is part of the boot decide if the

00:03:48,640 --> 00:03:53,040
boot

00:03:49,760 --> 00:03:54,319
was a good boot and

00:03:53,040 --> 00:03:56,159
feed this information back to the

00:03:54,319 --> 00:03:59,200
bootloader and then

00:03:56,159 --> 00:04:00,720
the bootloader can take some some some

00:03:59,200 --> 00:04:04,720
action based on this

00:04:00,720 --> 00:04:07,840
and we have two implementations um

00:04:04,720 --> 00:04:12,159
since most people use

00:04:07,840 --> 00:04:15,120
grub there is an implementation in grab

00:04:12,159 --> 00:04:18,639
and then

00:04:15,120 --> 00:04:21,680
a competing implementation maybe

00:04:18,639 --> 00:04:22,960
in systemd for the system the bootloader

00:04:21,680 --> 00:04:25,440
as debut

00:04:22,960 --> 00:04:26,639
so so let me let me talk about the uh

00:04:25,440 --> 00:04:29,840
the grub

00:04:26,639 --> 00:04:29,840
implementation first

00:04:30,240 --> 00:04:37,600
it's quite simple it has a a

00:04:34,320 --> 00:04:40,880
counter that

00:04:37,600 --> 00:04:42,479
when we start booting we set we

00:04:40,880 --> 00:04:44,720
bump the counter that says that we tried

00:04:42,479 --> 00:04:46,080
this boot and we don't know yet what the

00:04:44,720 --> 00:04:49,919
result was

00:04:46,080 --> 00:04:53,440
uh but in determinate and then

00:04:49,919 --> 00:04:56,639
uh there's a user service

00:04:53,440 --> 00:04:59,199
so uh

00:04:56,639 --> 00:04:59,840
a service that part that runs as part of

00:04:59,199 --> 00:05:03,440
the

00:04:59,840 --> 00:05:04,240
user session uh that has a very simple

00:05:03,440 --> 00:05:06,800
job

00:05:04,240 --> 00:05:07,919
um it consists of two parts there's a

00:05:06,800 --> 00:05:10,710
timer

00:05:07,919 --> 00:05:12,960
that waits two minutes and um

00:05:10,710 --> 00:05:15,600
[Music]

00:05:12,960 --> 00:05:17,199
after two minutes have passed the the

00:05:15,600 --> 00:05:20,080
timer starts the

00:05:17,199 --> 00:05:20,400
uh the service that does the actual uh

00:05:20,080 --> 00:05:22,240
um

00:05:20,400 --> 00:05:25,039
[Music]

00:05:22,240 --> 00:05:26,400
blessing and this blessing consists of

00:05:25,039 --> 00:05:31,360
telling the

00:05:26,400 --> 00:05:31,360
um of calling a grab binary to set a

00:05:32,320 --> 00:05:38,800
grab variable so

00:05:35,520 --> 00:05:40,240
um i mean this is this is conceptually

00:05:38,800 --> 00:05:43,360
very simple

00:05:40,240 --> 00:05:46,080
uh and it actually works um

00:05:43,360 --> 00:05:46,720
this uh this implementation was approved

00:05:46,080 --> 00:05:50,080
as

00:05:46,720 --> 00:05:52,800
part of uh two changes i think it was

00:05:50,080 --> 00:05:57,600
further a 29

00:05:52,800 --> 00:05:57,600
hidden grub menu change and then

00:05:57,759 --> 00:06:04,840
in fedora 30 or 31 flicker free boot

00:06:01,910 --> 00:06:08,880
[Music]

00:06:04,840 --> 00:06:08,880
and this those

00:06:09,919 --> 00:06:13,360
this uh the effect of all this is it's

00:06:12,400 --> 00:06:16,479
not very big

00:06:13,360 --> 00:06:18,720
because uh grab uh

00:06:16,479 --> 00:06:20,319
just um hides the boot menu by default

00:06:18,720 --> 00:06:24,319
and shows it if

00:06:20,319 --> 00:06:24,319
the last boot wasn't successful

00:06:25,440 --> 00:06:32,000
the competing implementation in systemd

00:06:28,560 --> 00:06:35,840
is more complicated so

00:06:32,000 --> 00:06:35,840
systemd has this um

00:06:40,160 --> 00:06:45,039
systemd is known for being for

00:06:43,199 --> 00:06:48,639
complicating things too much and this is

00:06:45,039 --> 00:06:53,840
uh or at least a lot and this is

00:06:48,639 --> 00:06:53,840
no different in this case it also has a

00:06:55,120 --> 00:07:02,240
a service to to bless the boot as

00:06:59,280 --> 00:07:03,199
successful the difference is that this

00:07:02,240 --> 00:07:07,199
this service

00:07:03,199 --> 00:07:11,759
uh works for

00:07:07,199 --> 00:07:11,759
the sd boot bootloader not for for grab

00:07:12,960 --> 00:07:19,120
and it also essentially sets a variable

00:07:17,840 --> 00:07:22,400
and the implementation is different but

00:07:19,120 --> 00:07:22,400
the effect is very similar

00:07:27,759 --> 00:07:34,319
and um

00:07:31,759 --> 00:07:34,960
but that's pretty much all that is

00:07:34,319 --> 00:07:36,560
similar

00:07:34,960 --> 00:07:40,080
because the the service is actually

00:07:36,560 --> 00:07:40,080
started by uh um

00:07:41,599 --> 00:07:44,800
it's enabled by a generator so here we

00:07:44,080 --> 00:07:49,039
have this

00:07:44,800 --> 00:07:49,039
first point of flexibility that

00:07:49,440 --> 00:07:54,479
the the service is only active

00:07:52,800 --> 00:07:55,919
if as the boot was used to boot the

00:07:54,479 --> 00:07:59,280
machine

00:07:55,919 --> 00:08:03,120
that may be a minor point

00:07:59,280 --> 00:08:06,720
the complexity starts in how this

00:08:03,120 --> 00:08:10,600
service is activated instead of having a

00:08:06,720 --> 00:08:11,759
uh of just saying that the

00:08:10,600 --> 00:08:13,759
[Music]

00:08:11,759 --> 00:08:14,879
service should be part of the

00:08:13,759 --> 00:08:18,160
transaction

00:08:14,879 --> 00:08:20,960
statically uh we have a

00:08:18,160 --> 00:08:23,919
um a level of interaction we have

00:08:20,960 --> 00:08:26,240
something called boot complete target

00:08:23,919 --> 00:08:28,000
and this target works as a

00:08:26,240 --> 00:08:32,000
synchronization point

00:08:28,000 --> 00:08:35,039
uh between services that do the blessing

00:08:32,000 --> 00:08:37,279
so so the our example is the the

00:08:35,039 --> 00:08:38,640
system d blood boot service which runs

00:08:37,279 --> 00:08:41,760
after the target

00:08:38,640 --> 00:08:45,440
if grab was converted to the scheme

00:08:41,760 --> 00:08:45,440
then we would have something like grab

00:08:46,399 --> 00:08:52,839
wood success service after this target

00:08:50,560 --> 00:08:54,480
on the other hand before this target we

00:08:52,839 --> 00:08:59,120
can

00:08:54,480 --> 00:08:59,120
put arbitrary services that do

00:08:59,839 --> 00:09:04,960
checks on the boat and and tell us if

00:09:02,160 --> 00:09:06,480
the boot was successful

00:09:04,960 --> 00:09:09,839
[Music]

00:09:06,480 --> 00:09:11,600
and i mean this this is all nice

00:09:09,839 --> 00:09:12,959
except that systemd actually doesn't

00:09:11,600 --> 00:09:16,320
provide any useful

00:09:12,959 --> 00:09:18,640
service to run before uh

00:09:16,320 --> 00:09:19,519
would complete target and do a useful

00:09:18,640 --> 00:09:23,440
check

00:09:19,519 --> 00:09:24,000
there is a systemd boot check no failure

00:09:23,440 --> 00:09:27,040
service

00:09:24,000 --> 00:09:29,600
that does what it what this name says

00:09:27,040 --> 00:09:30,640
but that's that's not enough to figure

00:09:29,600 --> 00:09:34,839
out if the

00:09:30,640 --> 00:09:37,120
boot was successful um

00:09:34,839 --> 00:09:40,480
so uh

00:09:37,120 --> 00:09:44,080
let me run through two

00:09:40,480 --> 00:09:46,240
failure modes um so the first one would

00:09:44,080 --> 00:09:50,080
be where kernel crashes

00:09:46,240 --> 00:09:52,000
in early boot uh

00:09:50,080 --> 00:09:53,440
and both implementations do the right

00:09:52,000 --> 00:09:55,760
thing here they

00:09:53,440 --> 00:09:55,760
um

00:09:58,000 --> 00:10:04,399
we marked the boot early uh as uh

00:10:01,120 --> 00:10:06,640
as um with some appropriate counter

00:10:04,399 --> 00:10:08,240
and we never get to the phase where we

00:10:06,640 --> 00:10:10,880
uh

00:10:08,240 --> 00:10:11,519
market is successful in case of system d

00:10:10,880 --> 00:10:14,320
because we

00:10:11,519 --> 00:10:15,600
we never complete the transaction

00:10:14,320 --> 00:10:18,720
successfully

00:10:15,600 --> 00:10:20,320
in case of grab because we

00:10:18,720 --> 00:10:21,839
the timer doesn't have enough time to

00:10:20,320 --> 00:10:25,760
run and we never start the

00:10:21,839 --> 00:10:26,880
the service but let's consider a

00:10:25,760 --> 00:10:30,000
different failure mode

00:10:26,880 --> 00:10:32,079
the the user logs in but

00:10:30,000 --> 00:10:33,120
the mouse and the keyboard is broken

00:10:32,079 --> 00:10:36,480
this

00:10:33,120 --> 00:10:39,680
uh this can happen this is nasty

00:10:36,480 --> 00:10:41,600
um or maybe you know maybe maybe the

00:10:39,680 --> 00:10:43,200
screen is garbled or something else that

00:10:41,600 --> 00:10:44,640
causes

00:10:43,200 --> 00:10:46,320
the user not to be able to use the

00:10:44,640 --> 00:10:50,800
machine successfully well

00:10:46,320 --> 00:10:50,800
two minutes pass and the grab

00:10:51,120 --> 00:10:57,040
timer fires and the grab entries marked

00:10:54,480 --> 00:10:57,040
as is good

00:10:57,360 --> 00:11:03,120
the systemd

00:11:00,640 --> 00:11:04,720
service does the same thing it it well

00:11:03,120 --> 00:11:06,160
and it has the same effect it

00:11:04,720 --> 00:11:07,839
everything finishes successfully all

00:11:06,160 --> 00:11:08,959
services are started no errors are

00:11:07,839 --> 00:11:12,160
reported

00:11:08,959 --> 00:11:16,079
uh it's just that the session is not

00:11:12,160 --> 00:11:16,079
useful for the user and

00:11:16,399 --> 00:11:19,600
so so we have this feedback loop where

00:11:18,240 --> 00:11:22,160
we um

00:11:19,600 --> 00:11:23,680
talk to the bootloader from somewhere in

00:11:22,160 --> 00:11:26,839
the middle of the

00:11:23,680 --> 00:11:28,000
stack of things that we start to to have

00:11:26,839 --> 00:11:31,360
a

00:11:28,000 --> 00:11:32,000
graphical user session um but i would

00:11:31,360 --> 00:11:34,959
argue that

00:11:32,000 --> 00:11:36,320
it's actually too low what i would like

00:11:34,959 --> 00:11:39,360
to see is that

00:11:36,320 --> 00:11:42,959
um gnome session itself

00:11:39,360 --> 00:11:45,519
would be smart enough to figure out that

00:11:42,959 --> 00:11:46,320
the user is i don't know not opening any

00:11:45,519 --> 00:11:49,279
windows

00:11:46,320 --> 00:11:51,600
so maybe even though the session started

00:11:49,279 --> 00:11:54,959
um

00:11:51,600 --> 00:11:57,920
it shouldn't be marked as successful so

00:11:54,959 --> 00:11:58,480
uh we want to have feedback from the

00:11:57,920 --> 00:12:01,760
very

00:11:58,480 --> 00:12:06,000
highest levels back to the to the

00:12:01,760 --> 00:12:06,000
very lowest levels um

00:12:08,880 --> 00:12:13,360
i also want to mention that um the

00:12:11,839 --> 00:12:17,200
system the implementation is

00:12:13,360 --> 00:12:20,320
more uh complicated in one more way

00:12:17,200 --> 00:12:24,079
it does boot counting so

00:12:20,320 --> 00:12:27,360
uh we install a new kernel and we put

00:12:24,079 --> 00:12:28,560
a we decide on some number three or five

00:12:27,360 --> 00:12:31,519
something like that

00:12:28,560 --> 00:12:32,480
um when the kernel is newly installed

00:12:31,519 --> 00:12:35,600
and we create the

00:12:32,480 --> 00:12:36,399
boot entering the bootloader for it and

00:12:35,600 --> 00:12:39,920
then

00:12:36,399 --> 00:12:42,720
every time we uh boot this kernel

00:12:39,920 --> 00:12:44,639
we we increase we decrease the counter

00:12:42,720 --> 00:12:48,320
by one

00:12:44,639 --> 00:12:50,000
and once we mark the boot entry as

00:12:48,320 --> 00:12:51,279
successful then we stop decreasing it we

00:12:50,000 --> 00:12:56,079
set another flag

00:12:51,279 --> 00:12:56,079
this allows us to create an automatic

00:12:56,320 --> 00:13:03,680
fallback so that if the the machine

00:12:59,839 --> 00:13:06,240
has a new kernel installed the kernel

00:13:03,680 --> 00:13:07,920
is booted a few times without success we

00:13:06,240 --> 00:13:09,200
stopped putting this kernel we tried to

00:13:07,920 --> 00:13:12,399
put for example

00:13:09,200 --> 00:13:15,760
the previous kernel then

00:13:12,399 --> 00:13:17,200
ideally the machine

00:13:15,760 --> 00:13:19,360
would start successfully with the order

00:13:17,200 --> 00:13:22,399
kernel maybe

00:13:19,360 --> 00:13:24,880
a board would kick in

00:13:22,399 --> 00:13:26,880
figure out that something was uh

00:13:24,880 --> 00:13:30,160
crashing in the

00:13:26,880 --> 00:13:32,079
this newest kernel version upload it to

00:13:30,160 --> 00:13:33,920
fedora servers

00:13:32,079 --> 00:13:37,120
and then fedora developers would be able

00:13:33,920 --> 00:13:40,480
to uh fix this

00:13:37,120 --> 00:13:42,399
and then yet another kernel update

00:13:40,480 --> 00:13:43,600
that was installed would now work

00:13:42,399 --> 00:13:47,440
correctly and

00:13:43,600 --> 00:13:50,639
the user could have this well

00:13:47,440 --> 00:13:55,279
magic experience where

00:13:50,639 --> 00:13:55,279
the bug is handled automatically and

00:13:56,240 --> 00:14:00,320
they don't even need to do anything

00:13:58,000 --> 00:14:03,360
except maybe

00:14:00,320 --> 00:14:06,000
press the rest button a few times but

00:14:03,360 --> 00:14:07,360
for this to work we would need to have

00:14:06,000 --> 00:14:11,040
everything working

00:14:07,360 --> 00:14:13,920
much more rarely what we can do right

00:14:11,040 --> 00:14:16,959
now is that we can

00:14:13,920 --> 00:14:20,320
show the menu if the boot fails but

00:14:16,959 --> 00:14:22,480
doing something as complex as

00:14:20,320 --> 00:14:24,880
automatically falling back to an older

00:14:22,480 --> 00:14:24,880
kernel

00:14:26,000 --> 00:14:33,360
it's we are not there yet but it's

00:14:30,000 --> 00:14:34,560
within i mean we pretty much know how to

00:14:33,360 --> 00:14:38,160
do it it's just a question of

00:14:34,560 --> 00:14:38,160
integrating there are right bits

00:14:39,760 --> 00:14:47,440
the second topic i want to talk about is

00:14:43,519 --> 00:14:49,600
a systemd unit for the

00:14:47,440 --> 00:14:49,600
uh

00:14:51,120 --> 00:14:58,000
for the for the user session so the

00:14:54,320 --> 00:15:01,839
for the um right i mean units started by

00:14:58,000 --> 00:15:04,399
the user manager for any given user

00:15:01,839 --> 00:15:07,120
and not units started by the system

00:15:04,399 --> 00:15:09,040
manager for the system itself

00:15:07,120 --> 00:15:10,839
and what has been somewhat quietly

00:15:09,040 --> 00:15:13,839
happening is that

00:15:10,839 --> 00:15:13,839
um

00:15:16,000 --> 00:15:20,399
gnome has been slowly converting to this

00:15:18,480 --> 00:15:22,160
mode where it

00:15:20,399 --> 00:15:24,079
where everything that gnome starts is

00:15:22,160 --> 00:15:28,000
starting started as separate

00:15:24,079 --> 00:15:28,000
uh user units um

00:15:30,320 --> 00:15:34,000
the the way that this this happens in

00:15:33,680 --> 00:15:36,560
the

00:15:34,000 --> 00:15:38,839
in the low level implementation in in

00:15:36,560 --> 00:15:41,839
gilip

00:15:38,839 --> 00:15:41,839
um

00:15:44,560 --> 00:15:49,680
has always used glib 2 to start uh

00:15:47,680 --> 00:15:50,959
processes and now instead of starting

00:15:49,680 --> 00:15:53,759
the process directly

00:15:50,959 --> 00:15:55,360
it does the deepest call to to the

00:15:53,759 --> 00:15:59,920
system the

00:15:55,360 --> 00:15:59,920
user instance and tells it about

00:16:00,959 --> 00:16:07,759
a job that needs to to run and

00:16:04,959 --> 00:16:08,000
this lets systemd user instance manage

00:16:07,759 --> 00:16:11,199
the

00:16:08,000 --> 00:16:15,680
processes so that's

00:16:11,199 --> 00:16:19,680
by itself it doesn't do much uh it's a

00:16:15,680 --> 00:16:22,079
because the processes are still started

00:16:19,680 --> 00:16:23,519
and they they run pretty much the same

00:16:22,079 --> 00:16:27,279
systemd is not actually

00:16:23,519 --> 00:16:28,560
doing too much monitoring

00:16:27,279 --> 00:16:32,079
on the other hand it's a big change

00:16:28,560 --> 00:16:34,079
because it's a change in philosophy

00:16:32,079 --> 00:16:35,360
the low level bits in gilip need to be

00:16:34,079 --> 00:16:39,360
changed there's

00:16:35,360 --> 00:16:43,199
i put some merge requests

00:16:39,360 --> 00:16:45,600
in the in the slides

00:16:43,199 --> 00:16:47,199
but the important part is that systemd

00:16:45,600 --> 00:16:49,120
has this generic infrastructure to

00:16:47,199 --> 00:16:52,880
manage

00:16:49,120 --> 00:16:55,199
groups of processes using c groups

00:16:52,880 --> 00:16:55,199
and

00:16:55,920 --> 00:16:59,199
in the long run this this will give us a

00:16:58,639 --> 00:17:02,320
lot of

00:16:59,199 --> 00:17:03,920
uh power in how we manage

00:17:02,320 --> 00:17:06,079
services that are part of the user

00:17:03,920 --> 00:17:09,819
session

00:17:06,079 --> 00:17:12,949
i wanted to show an example

00:17:09,819 --> 00:17:12,949
[Music]

00:17:14,720 --> 00:17:22,799
so that's a bit

00:17:18,880 --> 00:17:22,799
unclear but

00:17:29,840 --> 00:17:35,039
on fedora 32

00:17:33,520 --> 00:17:37,440
pretty much everything that is started

00:17:35,039 --> 00:17:37,440
by the

00:17:37,520 --> 00:17:42,960
user session is already in individual

00:17:44,559 --> 00:17:51,120
c groups managed by systemd

00:17:48,400 --> 00:17:51,840
for example my firefox with all its

00:17:51,120 --> 00:17:56,880
processes

00:17:51,840 --> 00:17:56,880
using the cpu is in one control group

00:17:58,840 --> 00:18:03,120
uh

00:18:00,400 --> 00:18:03,840
i also have a a flat pack instance

00:18:03,120 --> 00:18:07,840
running

00:18:03,840 --> 00:18:07,840
telegram and so on

00:18:08,160 --> 00:18:10,400
so

00:18:12,840 --> 00:18:19,600
um why why why do we want

00:18:15,840 --> 00:18:22,640
this to happen so three items

00:18:19,600 --> 00:18:25,120
obviously systemd is very good at

00:18:22,640 --> 00:18:29,039
keeping track of processes this is

00:18:25,120 --> 00:18:32,000
why we have it um

00:18:29,039 --> 00:18:32,640
systemd also allows uh dependencies to

00:18:32,000 --> 00:18:36,240
be

00:18:32,640 --> 00:18:39,520
uh declared between jobs so

00:18:36,240 --> 00:18:42,480
uh finally instead of trying to to

00:18:39,520 --> 00:18:43,760
start different processes as part of the

00:18:42,480 --> 00:18:45,919
graphical session

00:18:43,760 --> 00:18:47,919
and hoping that we got the order right

00:18:45,919 --> 00:18:52,640
we can

00:18:47,919 --> 00:18:56,000
declare real dependencies we can declare

00:18:52,640 --> 00:18:57,679
failure modes we can do more stuff in

00:18:56,000 --> 00:19:01,120
parallel

00:18:57,679 --> 00:19:02,640
uh and right and let's say that we want

00:19:01,120 --> 00:19:05,840
to start the

00:19:02,640 --> 00:19:08,240
music player after pulse audio has

00:19:05,840 --> 00:19:08,240
started

00:19:08,840 --> 00:19:14,320
um

00:19:10,559 --> 00:19:16,799
and by after i mean not just

00:19:14,320 --> 00:19:17,600
that the pulse audio binary has been

00:19:16,799 --> 00:19:21,039
spawned

00:19:17,600 --> 00:19:24,160
but the pulse audio binary has

00:19:21,039 --> 00:19:27,120
reported to the to the manager that

00:19:24,160 --> 00:19:28,799
it is ready to handle requests and this

00:19:27,120 --> 00:19:32,240
is what systemd does and

00:19:28,799 --> 00:19:32,960
so far this was partially duplicated in

00:19:32,240 --> 00:19:36,480
the

00:19:32,960 --> 00:19:39,840
graphical environments but it is better

00:19:36,480 --> 00:19:39,840
to do it in systemd

00:19:40,000 --> 00:19:47,360
it actually makes the

00:19:43,039 --> 00:19:47,360
graphical session a bit simpler

00:19:49,120 --> 00:19:57,360
i also want to mention a

00:19:53,120 --> 00:20:00,320
as an aside the systemd xdg

00:19:57,360 --> 00:20:01,840
so the systemd cross desktop group

00:20:00,320 --> 00:20:06,159
autostart generator

00:20:01,840 --> 00:20:09,600
it's a little generator that converts uh

00:20:06,159 --> 00:20:13,919
desktop files in the autostart directory

00:20:09,600 --> 00:20:21,840
into systemd user unit

00:20:13,919 --> 00:20:21,840
system the user session units and

00:20:22,559 --> 00:20:28,080
it's it's a pretty pretty cool thing

00:20:25,840 --> 00:20:30,159
so so we will have this this mode where

00:20:28,080 --> 00:20:33,760
we will be able to start

00:20:30,159 --> 00:20:35,440
uh things as part of the

00:20:33,760 --> 00:20:37,280
graphical session auto start and

00:20:35,440 --> 00:20:39,840
actually use dependencies for them and

00:20:37,280 --> 00:20:43,280
error handling and stuff

00:20:39,840 --> 00:20:45,440
but the the third reason uh is that

00:20:43,280 --> 00:20:46,840
we can re assign resources to control

00:20:45,440 --> 00:20:50,799
groups

00:20:46,840 --> 00:20:52,320
uh and i want to talk about this because

00:20:50,799 --> 00:20:53,919
this is this has been a really big

00:20:52,320 --> 00:20:57,039
subject in fedora recently

00:20:53,919 --> 00:21:00,840
so a short reminder how the kernel

00:20:57,039 --> 00:21:04,000
uh manages resources for contra groups

00:21:00,840 --> 00:21:07,360
uh in the c-group's

00:21:04,000 --> 00:21:10,559
v2 world we have

00:21:07,360 --> 00:21:13,200
high-level controllers uh

00:21:10,559 --> 00:21:14,840
cpu memory io are the the three

00:21:13,200 --> 00:21:18,240
important ones

00:21:14,840 --> 00:21:18,240
um and

00:21:19,360 --> 00:21:23,760
one of the the changes from before is

00:21:21,280 --> 00:21:26,000
that those controllers

00:21:23,760 --> 00:21:26,000
uh

00:21:27,679 --> 00:21:32,400
try to provide a simplified even if not

00:21:31,039 --> 00:21:35,360
simple

00:21:32,400 --> 00:21:38,400
interface to the user space and and hide

00:21:35,360 --> 00:21:40,960
all the complexity underneath

00:21:38,400 --> 00:21:42,480
so before there were many more

00:21:40,960 --> 00:21:44,080
controllers and there were many more

00:21:42,480 --> 00:21:49,440
knobs now we have

00:21:44,080 --> 00:21:53,280
a much simplified view of this

00:21:49,440 --> 00:21:56,320
there are weights and limits

00:21:53,280 --> 00:21:58,960
so weights

00:21:56,320 --> 00:22:00,159
are for stateless resources like for

00:21:58,960 --> 00:22:02,000
example cpu

00:22:00,159 --> 00:22:04,320
and they they we can specify that we

00:22:02,000 --> 00:22:06,400
want to divide

00:22:04,320 --> 00:22:07,919
the cpu at any given time with some

00:22:06,400 --> 00:22:11,039
weight between different

00:22:07,919 --> 00:22:13,679
uh tasks

00:22:11,039 --> 00:22:15,440
and there are limits which specify how

00:22:13,679 --> 00:22:17,360
much of a given resource can be used

00:22:15,440 --> 00:22:21,440
which is mostly useful for

00:22:17,360 --> 00:22:25,280
uh stuff like memory where we say

00:22:21,440 --> 00:22:26,720
this uh the users did this i don't know

00:22:25,280 --> 00:22:28,400
the graphical session should not use

00:22:26,720 --> 00:22:30,720
more than two gigabytes of memory or

00:22:28,400 --> 00:22:30,720
whatever

00:22:31,120 --> 00:22:35,360
and we have limits which limit from the

00:22:35,039 --> 00:22:38,400
top

00:22:35,360 --> 00:22:40,470
and we have uh protections

00:22:38,400 --> 00:22:43,200
uh which um

00:22:40,470 --> 00:22:45,919
[Music]

00:22:43,200 --> 00:22:47,039
kind of do the opposite if a unit is

00:22:45,919 --> 00:22:51,039
below its

00:22:47,039 --> 00:22:54,000
protection level for a given resource uh

00:22:51,039 --> 00:22:55,520
this resource will be taken away from

00:22:54,000 --> 00:22:57,679
other units

00:22:55,520 --> 00:23:00,000
before it is taken from this protected

00:22:57,679 --> 00:23:00,000
unit

00:23:01,360 --> 00:23:08,880
and the two

00:23:04,799 --> 00:23:08,880
to two obvious examples of this is a

00:23:15,360 --> 00:23:19,280
good example of this of protection is

00:23:17,440 --> 00:23:20,080
this change that was merged for federer

00:23:19,280 --> 00:23:23,840
00:23:20,080 --> 00:23:23,840
which is the um

00:23:24,720 --> 00:23:28,000
micro resource the demand which will set

00:23:27,039 --> 00:23:29,440
the

00:23:28,000 --> 00:23:31,280
protections for the active user session

00:23:29,440 --> 00:23:34,720
i will return to this in a moment

00:23:31,280 --> 00:23:36,799
uh so we have all those

00:23:34,720 --> 00:23:38,480
settings for i mean all this kernel

00:23:36,799 --> 00:23:41,840
magic

00:23:38,480 --> 00:23:45,200
and systemd exposes it for its

00:23:41,840 --> 00:23:47,039
interface so we

00:23:45,200 --> 00:23:49,600
the graphical session can talk to

00:23:47,039 --> 00:23:49,600
systemd

00:23:49,679 --> 00:23:52,880
using d bus and d bus can talk to the

00:23:52,320 --> 00:23:56,480
kernel

00:23:52,880 --> 00:23:58,640
said the appropriate colonel knobs

00:23:56,480 --> 00:23:58,640
and

00:24:01,360 --> 00:24:07,600
i want to emphasize that this is kind of

00:24:04,559 --> 00:24:12,159
similar to this to this previous case

00:24:07,600 --> 00:24:14,880
um the kernel is doing

00:24:12,159 --> 00:24:15,360
the low-level job in this case it's it's

00:24:14,880 --> 00:24:17,039
it's

00:24:15,360 --> 00:24:19,679
very good at managing resource

00:24:17,039 --> 00:24:23,360
allocations but the kernel

00:24:19,679 --> 00:24:25,200
doesn't know it and cannot know uh

00:24:23,360 --> 00:24:28,240
what processes are important to the user

00:24:25,200 --> 00:24:32,080
how to divide the resources

00:24:28,240 --> 00:24:34,720
so so we need to have high level

00:24:32,080 --> 00:24:34,720
components

00:24:36,159 --> 00:24:39,520
that run as part of the user space and

00:24:38,320 --> 00:24:41,440
that that feed

00:24:39,520 --> 00:24:44,480
information back to due to the lower

00:24:41,440 --> 00:24:44,480
layers and

00:24:45,360 --> 00:24:53,600
one example is the eu resource d

00:24:49,200 --> 00:24:54,170
or micro resource d uh it sets the

00:24:53,600 --> 00:24:57,279
um

00:24:54,170 --> 00:25:00,559
[Music]

00:24:57,279 --> 00:25:04,159
protections for memory

00:25:00,559 --> 00:25:07,200
cpu and io

00:25:04,159 --> 00:25:10,159
for the active session so it watches

00:25:07,200 --> 00:25:10,880
which which sessions which section in

00:25:10,159 --> 00:25:14,400
the sense of

00:25:10,880 --> 00:25:17,440
uh the login session is active

00:25:14,400 --> 00:25:18,480
and and reserves i know 250 megabytes of

00:25:17,440 --> 00:25:23,279
memory for the

00:25:18,480 --> 00:25:26,400
for the for the desktop and

00:25:23,279 --> 00:25:29,630
the kernel cannot ever do this because

00:25:26,400 --> 00:25:31,039
it doesn't have a concept of

00:25:29,630 --> 00:25:33,940
[Music]

00:25:31,039 --> 00:25:35,600
that would allow it to tie the um

00:25:33,940 --> 00:25:38,880
[Music]

00:25:35,600 --> 00:25:41,679
display manager and the the gnome shell

00:25:38,880 --> 00:25:42,320
and various parts that form the session

00:25:41,679 --> 00:25:46,559
uh

00:25:42,320 --> 00:25:49,760
that this large group of processes is

00:25:46,559 --> 00:25:53,039
uh together important uh

00:25:49,760 --> 00:25:55,200
and um so

00:25:53,039 --> 00:25:58,080
this information needs to come from from

00:25:55,200 --> 00:26:01,039
different higher layers

00:25:58,080 --> 00:26:01,760
another change that that is actually

00:26:01,039 --> 00:26:04,400
already happening

00:26:01,760 --> 00:26:05,120
there are 32 is the introduction of the

00:26:04,400 --> 00:26:07,520
early

00:26:05,120 --> 00:26:07,520
umd

00:26:08,720 --> 00:26:13,919
and for some for various reasons some

00:26:11,840 --> 00:26:18,320
people are very unhappy with this

00:26:13,919 --> 00:26:20,320
uh because they they think that um

00:26:18,320 --> 00:26:22,880
it should be enough to have the the

00:26:20,320 --> 00:26:27,120
colonel umkiller

00:26:22,880 --> 00:26:30,720
but uh the canal unkiller

00:26:27,120 --> 00:26:34,000
first of all it doesn't know

00:26:30,720 --> 00:26:35,760
um i mean it has some heuristics but it

00:26:34,000 --> 00:26:38,080
cannot ever know

00:26:35,760 --> 00:26:40,180
which job at any given moment is the

00:26:38,080 --> 00:26:41,600
most important for the user

00:26:40,180 --> 00:26:44,480
[Music]

00:26:41,600 --> 00:26:45,679
and when we have sessions where people

00:26:44,480 --> 00:26:47,120
log in

00:26:45,679 --> 00:26:49,520
and then log out and leave some jobs

00:26:47,120 --> 00:26:49,520
behind

00:26:50,000 --> 00:26:53,840
this create this creates this

00:26:53,919 --> 00:26:59,120
dynamic state which which which is too

00:26:56,880 --> 00:27:02,320
complicated for the kernel to manage

00:26:59,120 --> 00:27:05,520
first of all and second uh the

00:27:02,320 --> 00:27:06,880
unkiller in the kernel its job is to to

00:27:05,520 --> 00:27:10,240
protect the kernel and to

00:27:06,880 --> 00:27:13,840
to make sure that uh stuff is happening

00:27:10,240 --> 00:27:16,080
so if we uh try to

00:27:13,840 --> 00:27:18,080
i don't know if if you open too many

00:27:16,080 --> 00:27:21,200
firefox stops and the machine

00:27:18,080 --> 00:27:21,520
uh is swapping heavily from the point of

00:27:21,200 --> 00:27:27,120
view

00:27:21,520 --> 00:27:27,120
of the kernel uh work is being done

00:27:29,360 --> 00:27:32,880
all the time so

00:27:33,520 --> 00:27:37,520
everything everything is fine but of

00:27:34,880 --> 00:27:40,159
course for the user who can see how the

00:27:37,520 --> 00:27:41,440
cursor slowly jumps around on the screen

00:27:40,159 --> 00:27:44,640
this is not

00:27:41,440 --> 00:27:47,600
very useful so we need to have

00:27:44,640 --> 00:27:49,840
some component in in the user space

00:27:47,600 --> 00:27:49,840
which

00:27:50,640 --> 00:27:58,320
helps the kernel do the the job

00:27:54,320 --> 00:27:58,320
and this is this is a common theme right

00:28:00,840 --> 00:28:07,360
and

00:28:02,320 --> 00:28:07,360
uh in all those cases that are

00:28:09,440 --> 00:28:14,559
actually flexible enough to

00:28:12,720 --> 00:28:16,480
to handle the the user cases that we

00:28:14,559 --> 00:28:18,640
want we have

00:28:16,480 --> 00:28:21,200
this interaction of high-level

00:28:18,640 --> 00:28:21,200
components

00:28:21,760 --> 00:28:24,799
with the middle layer

00:28:25,600 --> 00:28:33,520
because the high-level components

00:28:29,600 --> 00:28:36,799
they first of all they shouldn't um

00:28:33,520 --> 00:28:40,559
talk directly to to we don't want

00:28:36,799 --> 00:28:41,600
our gnome cell to to talk to the booth

00:28:40,559 --> 00:28:44,799
holder directly

00:28:41,600 --> 00:28:47,840
we want to have some intermediate helper

00:28:44,799 --> 00:28:52,240
which is usually systemd or

00:28:47,840 --> 00:28:52,240
various helper services

00:28:54,000 --> 00:29:00,240
also the users the top level components

00:28:57,200 --> 00:29:00,240
they don't have permissions

00:29:02,880 --> 00:29:09,520
but and this this those middle middle

00:29:06,960 --> 00:29:11,279
uh this intermediate layer in the middle

00:29:09,520 --> 00:29:14,880
needs to be

00:29:11,279 --> 00:29:20,559
flexible enough to accommodate

00:29:14,880 --> 00:29:20,559
various use cases on the other hand

00:29:23,039 --> 00:29:27,919
the implementation itself needs to be

00:29:26,399 --> 00:29:29,919
done at the low level

00:29:27,919 --> 00:29:31,840
uh for example in the case of the

00:29:29,919 --> 00:29:34,080
bootloader

00:29:31,840 --> 00:29:35,360
and put blessing it's the boot holder

00:29:34,080 --> 00:29:39,600
itself that must

00:29:35,360 --> 00:29:41,760
do the counting because

00:29:39,600 --> 00:29:42,799
the the boot sequence can can be aborted

00:29:41,760 --> 00:29:46,159
at any

00:29:42,799 --> 00:29:48,399
point in time so uh

00:29:46,159 --> 00:29:49,200
we must set the appropriate counters

00:29:48,399 --> 00:29:51,440
before we

00:29:49,200 --> 00:29:52,559
i mean as early as possible and

00:29:51,440 --> 00:29:56,159
similarly for the

00:29:52,559 --> 00:29:58,000
for the resource allocation stuff

00:29:56,159 --> 00:29:59,200
the accounting needs to be done in the

00:29:58,000 --> 00:30:02,799
kernel

00:29:59,200 --> 00:30:06,320
uh so that it works as a

00:30:02,799 --> 00:30:08,080
that is always in place that the machine

00:30:06,320 --> 00:30:10,399
never hangs even if there's a sudden

00:30:08,080 --> 00:30:13,919
spike any any kind of

00:30:10,399 --> 00:30:13,919
user demon can always be

00:30:14,880 --> 00:30:21,840
overwhelmed uh

00:30:18,399 --> 00:30:23,520
and also the kernel is a place where the

00:30:21,840 --> 00:30:26,720
accounting can be done

00:30:23,520 --> 00:30:30,480
efficiently enough and

00:30:26,720 --> 00:30:34,320
the kernel is the place which can react

00:30:30,480 --> 00:30:34,320
quickly enough and

00:30:34,720 --> 00:30:37,919
some people say that this is a violation

00:30:37,120 --> 00:30:41,440
of uh

00:30:37,919 --> 00:30:44,799
unix principles uh

00:30:41,440 --> 00:30:48,399
and in a way it is um so

00:30:44,799 --> 00:30:51,760
and in a way it's not so it is not

00:30:48,399 --> 00:30:53,919
in the sense that we

00:30:51,760 --> 00:30:56,159
do have things that are doing one thing

00:30:53,919 --> 00:30:59,200
and uh well they're doing it well or at

00:30:56,159 --> 00:31:04,399
least better than before

00:30:59,200 --> 00:31:04,399
if we let the systemd user session

00:31:06,240 --> 00:31:10,590
manage jobs and we remove this this

00:31:09,279 --> 00:31:12,080
handling from

00:31:10,590 --> 00:31:14,000
[Music]

00:31:12,080 --> 00:31:15,679
from the graphical environment we

00:31:14,000 --> 00:31:18,960
simplify the graphical environment and

00:31:15,679 --> 00:31:21,600
let well actually split

00:31:18,960 --> 00:31:22,399
split how things are done on the other

00:31:21,600 --> 00:31:24,640
hand

00:31:22,399 --> 00:31:24,640
uh

00:31:25,679 --> 00:31:29,360
the linux environment as a collection of

00:31:28,399 --> 00:31:32,399
little

00:31:29,360 --> 00:31:34,320
processes that that that don't really

00:31:32,399 --> 00:31:37,679
care about each other and only

00:31:34,320 --> 00:31:39,760
do one thing and don't communicate

00:31:37,679 --> 00:31:42,720
uh well this is this is going in exactly

00:31:39,760 --> 00:31:42,720
the opposite direction

00:31:44,840 --> 00:31:51,600
and uh i'm saying that if we want

00:31:49,279 --> 00:31:52,640
if we want to build solutions that are

00:31:51,600 --> 00:31:55,039
uh

00:31:52,640 --> 00:31:58,480
featureful enough we will need to go

00:31:55,039 --> 00:31:58,480
even further in this direction

00:31:58,840 --> 00:32:05,840
and i want to underline the fact that

00:32:02,159 --> 00:32:09,200
in some way um all of this was

00:32:05,840 --> 00:32:11,360
possible before i mean even 15 years ago

00:32:09,200 --> 00:32:12,240
we could write a script that would set

00:32:11,360 --> 00:32:15,200
some

00:32:12,240 --> 00:32:16,480
uh the user would click an icon on the

00:32:15,200 --> 00:32:17,760
desktop and this would launch some

00:32:16,480 --> 00:32:20,960
script and the script would

00:32:17,760 --> 00:32:23,919
do some job but

00:32:20,960 --> 00:32:26,240
those were ad hoc solutions if we want

00:32:23,919 --> 00:32:26,240
to have

00:32:26,559 --> 00:32:32,559
systems that are reliable that are

00:32:29,840 --> 00:32:33,440
flexible and support many many many use

00:32:32,559 --> 00:32:37,200
cases

00:32:33,440 --> 00:32:38,159
we need more and more flexibility and

00:32:37,200 --> 00:32:40,320
more and more

00:32:38,159 --> 00:32:40,320
more

00:32:41,279 --> 00:32:47,840
features in the in this middle

00:32:44,799 --> 00:32:48,960
plumbing layer that provides that

00:32:47,840 --> 00:32:52,320
connects the

00:32:48,960 --> 00:32:55,440
uh the high levels which set the policy

00:32:52,320 --> 00:32:56,000
and the the low level implementations

00:32:55,440 --> 00:32:58,960
that

00:32:56,000 --> 00:32:58,960
do the actual job

00:32:59,670 --> 00:33:02,769
[Music]

00:33:08,840 --> 00:33:14,240
and

00:33:11,279 --> 00:33:15,039
well that's that's what i wanted to say

00:33:14,240 --> 00:33:18,159
about what was

00:33:15,039 --> 00:33:21,200
what has been happening up now uh

00:33:18,159 --> 00:33:25,440
and as the last a

00:33:21,200 --> 00:33:26,720
few uh um

00:33:25,440 --> 00:33:29,200
what will happen in this area in the

00:33:26,720 --> 00:33:31,600
future so

00:33:29,200 --> 00:33:31,600
um

00:33:32,240 --> 00:33:37,200
we when we look at the the way that the

00:33:35,360 --> 00:33:40,480
user session is managed

00:33:37,200 --> 00:33:43,039
is undergoing a similar transformation

00:33:40,480 --> 00:33:44,480
as that which happened for system

00:33:43,039 --> 00:33:45,519
services with the introduction of

00:33:44,480 --> 00:33:48,640
systemd

00:33:45,519 --> 00:33:50,880
so we will have this this uh drawn out

00:33:48,640 --> 00:33:53,919
process where we

00:33:50,880 --> 00:33:55,840
parallelize things where we uh

00:33:53,919 --> 00:33:58,000
figure out what are the dependencies

00:33:55,840 --> 00:34:00,720
between different services that

00:33:58,000 --> 00:34:01,840
run as part of the user session and then

00:34:00,720 --> 00:34:07,840
we figure out

00:34:01,840 --> 00:34:07,840
what resources are needed to

00:34:10,480 --> 00:34:14,240
to to to keep various services running

00:34:12,879 --> 00:34:18,399
and and

00:34:14,240 --> 00:34:21,119
the introduction of early umd and

00:34:18,399 --> 00:34:23,599
micro resource d it's probably just the

00:34:21,119 --> 00:34:23,599
first step

00:34:24,879 --> 00:34:27,119
and

00:34:28,159 --> 00:34:35,119
we will most likely introduce a

00:34:32,000 --> 00:34:38,480
systemd in systemd so

00:34:35,119 --> 00:34:42,079
there will be a demon which will

00:34:38,480 --> 00:34:43,359
whose job will be to kill stuff when

00:34:42,079 --> 00:34:45,839
there is not enough

00:34:43,359 --> 00:34:45,839
memory

00:34:46,800 --> 00:34:52,960
itself will probably uh take

00:34:50,399 --> 00:34:54,159
over part of the job done by micro

00:34:52,960 --> 00:34:57,440
resource d

00:34:54,159 --> 00:34:58,240
uh and possibly set protections i think

00:34:57,440 --> 00:35:00,560
that's that's

00:34:58,240 --> 00:35:01,440
those are the the um i mean login d is

00:35:00,560 --> 00:35:04,640
probably the right

00:35:01,440 --> 00:35:04,640
place to do this kind of thing

00:35:05,280 --> 00:35:12,079
one thing that will be different

00:35:08,480 --> 00:35:12,079
in umd is that undi

00:35:12,240 --> 00:35:18,240
responds to the live information

00:35:16,000 --> 00:35:19,680
from the kernel about pressure on

00:35:18,240 --> 00:35:21,920
resources

00:35:19,680 --> 00:35:21,920
so

00:35:23,680 --> 00:35:26,880
instead of just looking at how much is

00:35:25,440 --> 00:35:30,800
used we can

00:35:26,880 --> 00:35:34,240
look at how much

00:35:30,800 --> 00:35:35,760
the over allocation of resources is

00:35:34,240 --> 00:35:37,119
slowing things down

00:35:35,760 --> 00:35:41,040
uh i don't want to talk about the

00:35:37,119 --> 00:35:41,040
details i just want to say that

00:35:41,520 --> 00:35:47,440
instead of uh having a policy that we

00:35:45,359 --> 00:35:49,599
kill things when the system is

00:35:47,440 --> 00:35:50,800
running out of in out of memory for some

00:35:49,599 --> 00:35:54,640
definition of that

00:35:50,800 --> 00:35:56,640
we we can do things like um

00:35:54,640 --> 00:35:58,320
you know kill a background processing

00:35:56,640 --> 00:36:01,520
task which we know

00:35:58,320 --> 00:36:03,920
for for a policy set by the user uh

00:36:01,520 --> 00:36:05,119
that is unimportant when there is any

00:36:03,920 --> 00:36:08,400
kind of slowdown

00:36:05,119 --> 00:36:10,560
or we would say that tasks like the

00:36:08,400 --> 00:36:13,839
user session the graphical user session

00:36:10,560 --> 00:36:13,839
should be protected at all costs

00:36:13,920 --> 00:36:17,440
but we have in the more fancy solutions

00:36:16,720 --> 00:36:21,520
possible

00:36:17,440 --> 00:36:23,359
we can freeze tasks using the the

00:36:21,520 --> 00:36:24,560
the freezer when there is memory

00:36:23,359 --> 00:36:26,560
pressure

00:36:24,560 --> 00:36:27,599
or maybe freeze tasks when the user logs

00:36:26,560 --> 00:36:32,160
in

00:36:27,599 --> 00:36:32,160
i mean the future is open

00:36:33,119 --> 00:36:35,359
and

00:36:36,240 --> 00:36:40,079
there are really interesting things

00:36:37,680 --> 00:36:43,520
happening um the fact that federer

00:36:40,079 --> 00:36:44,720
33 has so many changes in so many

00:36:43,520 --> 00:36:46,480
different directions

00:36:44,720 --> 00:36:48,160
it's i don't think it's an accident i

00:36:46,480 --> 00:36:50,640
think we are

00:36:48,160 --> 00:36:53,280
at a point in time where we can do

00:36:50,640 --> 00:36:56,800
really interesting things

00:36:53,280 --> 00:37:00,160
and uh the good part is that

00:36:56,800 --> 00:37:02,560
this is done through across desktop uh

00:37:00,160 --> 00:37:03,920
cooperation and cross distro cooperation

00:37:02,560 --> 00:37:07,839
from the beginning

00:37:03,920 --> 00:37:09,119
uh we shouldn't uh

00:37:07,839 --> 00:37:11,839
have the situation where different

00:37:09,119 --> 00:37:15,040
desktops or implement the same bits

00:37:11,839 --> 00:37:15,040
in slightly different ways

00:37:16,000 --> 00:37:18,240
and

00:37:19,850 --> 00:37:23,040
[Music]

00:37:21,440 --> 00:37:25,440
you know i think that this will allow us

00:37:23,040 --> 00:37:30,480
to to build

00:37:25,440 --> 00:37:30,480
a more real and more featureful uh

00:37:31,440 --> 00:37:36,880
graphical workstations and other kinds

00:37:35,359 --> 00:37:39,920
of systems

00:37:36,880 --> 00:37:41,280
and i know that's that's pretty much

00:37:39,920 --> 00:37:44,400
what i had to say

00:37:41,280 --> 00:37:46,160
uh they

00:37:44,400 --> 00:37:47,520
forget anything important i don't know

00:37:46,160 --> 00:37:48,839
probably not i don't know if there are

00:37:47,520 --> 00:37:53,440
any questions then

00:37:48,839 --> 00:37:56,640
uh i wasn't

00:37:53,440 --> 00:37:59,680
watching the the chat too much sorry uh

00:37:56,640 --> 00:38:05,839
so please ask questions in the chat if

00:37:59,680 --> 00:38:05,839
there's a few minutes

00:38:09,920 --> 00:38:13,760
um are there any plans to support other

00:38:12,800 --> 00:38:18,000
bootloaders

00:38:13,760 --> 00:38:21,280
so maybe i didn't make this clear enough

00:38:18,000 --> 00:38:23,920
the um the

00:38:21,280 --> 00:38:24,720
put blessing framework is uh flexible

00:38:23,920 --> 00:38:28,000
enough

00:38:24,720 --> 00:38:30,240
to to support you know i mean

00:38:28,000 --> 00:38:31,920
easily support any kind of bootloader if

00:38:30,240 --> 00:38:33,440
a implementation for this bootloader is

00:38:31,920 --> 00:38:36,640
provided so this part is

00:38:33,440 --> 00:38:38,000
uh this part is easy um on the other

00:38:36,640 --> 00:38:41,119
hand

00:38:38,000 --> 00:38:43,119
systemd itself will not provide uh

00:38:41,119 --> 00:38:45,040
support for other bootloaders there is

00:38:43,119 --> 00:38:48,560
this this

00:38:45,040 --> 00:38:52,720
implementation for sd put uh

00:38:48,560 --> 00:38:55,119
and uh i mean this is already too much

00:38:52,720 --> 00:38:57,280
to for for systemd i guess if we it

00:38:55,119 --> 00:39:01,280
shouldn't be part of cindy actually

00:38:57,280 --> 00:39:03,839
um so

00:39:01,280 --> 00:39:03,839
yes and no

00:39:12,800 --> 00:39:16,320
okay and so if there are no more

00:39:15,359 --> 00:39:19,920
questions

00:39:16,320 --> 00:39:25,200
i will uh i'll finish before mosquitoes

00:39:19,920 --> 00:39:25,200

YouTube URL: https://www.youtube.com/watch?v=NeriFdtTRqE


