Title: Flock 2018 -  Status of the ABI compatibility verifier in Fedora
Publication date: 2018-09-03
Playlist: Flock 2018
Description: 
	Thursday, August 9, 2018 
10:30am - 11:20am 
@Hamburg 3+5

Talk: Status of the ABI compatibility verifier in Fedora
Presenters: Dodji Seketeli, Sinny Kumari

Description: The Fedora package update process promotes ABI compatibility
of many critical path packages which contain C and C++ ELF shared
libraries. This compatibility is enforced by statically analysing
each package update in its binary form. At the moment, the result of
that analysis has an informative value for each package maintainer.

In this talk we present the current status of the Libabigail static
analysis framework used to enforce ABI compatibility in Fedora. Some
of the most recent developments are highlighted and their possible use
to improve the Fedora ABI verification process are considered.

The talk also intends to foster some needed discussions about how we,
as a community, want to use ABI compatibility analysis in the gating
process of Fedora package updates.
Captions: 
	00:00:03,529 --> 00:00:15,570
okay welcome everybody thank you for

00:00:09,240 --> 00:00:20,250
showing up so my name is doji and so

00:00:15,570 --> 00:00:23,939
this is Sydney we well I work in Howard

00:00:20,250 --> 00:00:28,980
for Red Hat in the platform toolchains

00:00:23,939 --> 00:00:34,829
group and I mostly work on static

00:00:28,980 --> 00:00:39,450
analysis framework to perform analysis

00:00:34,829 --> 00:00:45,300
and binaries so that we can analyze a be

00:00:39,450 --> 00:00:47,989
eyes and so on and so forth so and

00:00:45,300 --> 00:00:51,840
cinnamon what are you working on

00:00:47,989 --> 00:00:55,469
hello good morning everyone so I work in

00:00:51,840 --> 00:00:58,199
fedora team before that I was involved

00:00:55,469 --> 00:01:01,530
in lis barbegal directly but now I

00:00:58,199 --> 00:01:04,290
mostly do some federal atomic host and

00:01:01,530 --> 00:01:06,810
further a career stuff and also

00:01:04,290 --> 00:01:12,330
contribute some time to the lab Abigail

00:01:06,810 --> 00:01:15,210
project and hobby - ABI verification in

00:01:12,330 --> 00:01:17,850
fedora so that's what today's talk is

00:01:15,210 --> 00:01:20,520
about and one thing I would like to tell

00:01:17,850 --> 00:01:24,720
you that doji has been my mentor for a

00:01:20,520 --> 00:01:28,770
long time and he helped a lot so yeah ok

00:01:24,720 --> 00:01:34,170
let's start so today we will be talking

00:01:28,770 --> 00:01:36,950
about these stuff so you will see how

00:01:34,170 --> 00:01:40,170
exactly we are doing abi abi

00:01:36,950 --> 00:01:43,619
verification in fedora how exactly the

00:01:40,170 --> 00:01:47,220
design looks like and what all what are

00:01:43,619 --> 00:01:51,810
the internal tools which we use for the

00:01:47,220 --> 00:01:55,290
ABI verification in a BIA verification

00:01:51,810 --> 00:01:57,479
and analysis exactly and then we will

00:01:55,290 --> 00:02:01,649
look into how we are doing in both he

00:01:57,479 --> 00:02:08,050
the gating of gating of the packages

00:02:01,649 --> 00:02:13,480
update during the body update

00:02:08,050 --> 00:02:16,660
then the future directions yeah

00:02:13,480 --> 00:02:19,750
so our API verification design in Fedora

00:02:16,660 --> 00:02:22,960
is based on the task at Ron so how many

00:02:19,750 --> 00:02:26,230
of you know about the Tosca Tron okay

00:02:22,960 --> 00:02:30,430
cool so if you don't know artist Cutrone

00:02:26,230 --> 00:02:34,090
is a framework of which helps you to run

00:02:30,430 --> 00:02:38,310
the automated tests and we use it in

00:02:34,090 --> 00:02:43,930
fedora to run some tests like rpm lint

00:02:38,310 --> 00:02:50,700
this rpm grill depth check and also for

00:02:43,930 --> 00:02:54,400
the ABA checks so what exactly we do so

00:02:50,700 --> 00:02:56,170
whenever you do a package build so how

00:02:54,400 --> 00:02:57,670
many of you have done able package build

00:02:56,170 --> 00:03:02,200
building in fedora

00:02:57,670 --> 00:03:05,140
okay that's good that's really nice yeah

00:03:02,200 --> 00:03:08,320
so whenever you do a package build in

00:03:05,140 --> 00:03:12,070
fedora so not scratch build it's a non

00:03:08,320 --> 00:03:14,350
scratch build so if once it succeeds we

00:03:12,070 --> 00:03:17,350
there is a tasket run task gets

00:03:14,350 --> 00:03:21,310
triggered among them it's a task ABA

00:03:17,350 --> 00:03:25,020
check and what exactly does it takes to

00:03:21,310 --> 00:03:28,300
the package which you just updated and

00:03:25,020 --> 00:03:30,550
then it takes the last table update

00:03:28,300 --> 00:03:33,340
updated package available in the fedora

00:03:30,550 --> 00:03:37,060
and then it will perform the ABI

00:03:33,340 --> 00:03:39,640
comparison between them and during an

00:03:37,060 --> 00:03:42,520
ABI comparison it takes the shared

00:03:39,640 --> 00:03:45,250
libraries which is available inside the

00:03:42,520 --> 00:03:47,800
packages and it will do the comparison

00:03:45,250 --> 00:03:50,620
from the previous version of the package

00:03:47,800 --> 00:03:56,860
library and from the latest one which

00:03:50,620 --> 00:04:00,310
you have just made the build so once our

00:03:56,860 --> 00:04:04,989
ABI checks runs I you will see the

00:04:00,310 --> 00:04:08,440
results like failed past or need

00:04:04,989 --> 00:04:09,820
inspection we'll talk more about what

00:04:08,440 --> 00:04:13,840
exactly exactly

00:04:09,820 --> 00:04:18,370
we categorize dist fail pass or needed

00:04:13,840 --> 00:04:19,470
inspection in the later slides so for

00:04:18,370 --> 00:04:22,290
now

00:04:19,470 --> 00:04:25,980
the package maintenance can get see the

00:04:22,290 --> 00:04:28,950
what see the results of this test how

00:04:25,980 --> 00:04:32,640
exactly it is like past failed or or

00:04:28,950 --> 00:04:36,810
need inspection and the logs of the test

00:04:32,640 --> 00:04:42,080
results of what failed or what's there

00:04:36,810 --> 00:04:45,990
so for that we you really need to go and

00:04:42,080 --> 00:04:50,340
add yourself to this notification and

00:04:45,990 --> 00:04:53,970
you will see get an email for that the

00:04:50,340 --> 00:04:56,910
package test run and you can check how

00:04:53,970 --> 00:05:01,560
to fix it the log contains all the

00:04:56,910 --> 00:05:05,430
details also if not if you are going to

00:05:01,560 --> 00:05:09,180
push that update into body the package

00:05:05,430 --> 00:05:11,940
some set of test runs if you if you

00:05:09,180 --> 00:05:14,550
recently have done in your maybe in late

00:05:11,940 --> 00:05:17,130
before that you will see there is a tab

00:05:14,550 --> 00:05:19,440
inside the update package both the

00:05:17,130 --> 00:05:22,290
updates any package there is a tab

00:05:19,440 --> 00:05:25,320
called automated tests so that's where

00:05:22,290 --> 00:05:30,419
you will see if ABI check test as well

00:05:25,320 --> 00:05:37,250
for instance this link the down body dot

00:05:30,419 --> 00:05:37,250
Fedora project at all / update ok yeah

00:05:38,990 --> 00:05:45,080
yeah so you have this time here with

00:05:41,600 --> 00:05:49,130
which has all the automated tests and

00:05:45,080 --> 00:05:55,430
and somewhere you can find I don't know

00:05:49,130 --> 00:05:58,849
the ABI check tests here so it passed so

00:05:55,430 --> 00:05:59,810
it says that there was no ABI change bla

00:05:58,849 --> 00:06:04,699
bla bla

00:05:59,810 --> 00:06:07,759
yeah so it depends how exactly the test

00:06:04,699 --> 00:06:10,699
ran if it has some ABA changes it will

00:06:07,759 --> 00:06:16,310
show it here otherwise you will see no

00:06:10,699 --> 00:06:20,360
change so that's good now we will talk

00:06:16,310 --> 00:06:23,090
about how exactly the design of the two

00:06:20,360 --> 00:06:26,840
links look like which we use for actual

00:06:23,090 --> 00:06:29,389
ABI analysis in your analysis using the

00:06:26,840 --> 00:06:34,970
Li barbegal and I will hand over to doji

00:06:29,389 --> 00:06:38,830
for that okay thank you Sydney so a few

00:06:34,970 --> 00:06:43,159
years ago when people wanted to know if

00:06:38,830 --> 00:06:47,509
library update contains API changes

00:06:43,159 --> 00:06:50,870
people would would you know use tools

00:06:47,509 --> 00:06:53,060
like and em then I don't know if you

00:06:50,870 --> 00:06:56,979
guys are familiar with that tools to go

00:06:53,060 --> 00:06:59,990
look inside the elf binaries and see

00:06:56,979 --> 00:07:04,310
what symbols health symbols are in there

00:06:59,990 --> 00:07:07,219
and and the kind of changes we could see

00:07:04,310 --> 00:07:07,969
back then were changes like a symbol

00:07:07,219 --> 00:07:10,400
disappeared

00:07:07,969 --> 00:07:11,960
for instance you had one symbol which

00:07:10,400 --> 00:07:14,539
was the symbol corresponding to a

00:07:11,960 --> 00:07:17,930
function name and boom that symbol

00:07:14,539 --> 00:07:21,229
disappeared but then so and that's an

00:07:17,930 --> 00:07:25,009
ABI change if the symbol was obviously

00:07:21,229 --> 00:07:28,150
used by some applications but then we

00:07:25,009 --> 00:07:31,880
wanted to have more precise information

00:07:28,150 --> 00:07:34,789
related to the meaning of those symbols

00:07:31,880 --> 00:07:36,800
right actually programmers don't even

00:07:34,789 --> 00:07:40,360
want to talk about symbols programmers

00:07:36,800 --> 00:07:44,180
talk about things like functions

00:07:40,360 --> 00:07:46,370
variables and their types symbols that's

00:07:44,180 --> 00:07:50,839
too much of you know kind of plumb

00:07:46,370 --> 00:07:52,100
plumber stuff right when you change the

00:07:50,839 --> 00:07:54,410
type

00:07:52,100 --> 00:07:57,410
of a parameter of a function as a

00:07:54,410 --> 00:08:00,710
programmer and if that impacts the ABI

00:07:57,410 --> 00:08:03,080
then you want to have reports in terms

00:08:00,710 --> 00:08:06,080
of what you changed like in terms of

00:08:03,080 --> 00:08:09,530
types structures structured data members

00:08:06,080 --> 00:08:14,870
and so on and so forth so to be able to

00:08:09,530 --> 00:08:17,420
give that kind of information by looking

00:08:14,870 --> 00:08:22,370
at the binaries themselves we came up

00:08:17,420 --> 00:08:25,130
with framework which name is a bi

00:08:22,370 --> 00:08:26,600
generic analysis an instrumentation

00:08:25,130 --> 00:08:32,300
library Abigale

00:08:26,600 --> 00:08:34,610
and so that basically is a library that

00:08:32,300 --> 00:08:37,849
knows how to yeah

00:08:34,610 --> 00:08:40,340
incidentally we were to starting this

00:08:37,849 --> 00:08:47,060
project and Abigail was also the name of

00:08:40,340 --> 00:08:52,610
the wife of the order guy anyway so yeah

00:08:47,060 --> 00:08:54,890
and so it's just stuck no no one came up

00:08:52,610 --> 00:08:58,580
with a better better name so we just

00:08:54,890 --> 00:09:01,730
kept that one so that library which is a

00:08:58,580 --> 00:09:05,030
suppose post library today knows how to

00:09:01,730 --> 00:09:07,400
load an elf binary and of course it's

00:09:05,030 --> 00:09:09,320
debug information because we need the

00:09:07,400 --> 00:09:12,290
debug information to be able to know

00:09:09,320 --> 00:09:14,120
which kind of things we're looking at

00:09:12,290 --> 00:09:15,800
inside the binary debug information will

00:09:14,120 --> 00:09:18,320
tell us that oh from here to here what

00:09:15,800 --> 00:09:20,300
you're looking a variable that variable

00:09:18,320 --> 00:09:21,890
is has a type the type is a structure

00:09:20,300 --> 00:09:25,010
blah blah blah so we need to analyze

00:09:21,890 --> 00:09:26,390
debug info just like any debugger or I

00:09:25,010 --> 00:09:28,640
don't know things like vulgar high and

00:09:26,390 --> 00:09:31,160
or and so on and so forth would do so we

00:09:28,640 --> 00:09:33,740
load that and what do we do with that we

00:09:31,160 --> 00:09:37,100
build an internal representation of the

00:09:33,740 --> 00:09:39,950
exported interface right just just like

00:09:37,100 --> 00:09:41,420
what a compiler would you but the

00:09:39,950 --> 00:09:44,000
compiler will do that from source code

00:09:41,420 --> 00:09:46,010
and we do that from the binary so we

00:09:44,000 --> 00:09:49,160
build an internal representation which

00:09:46,010 --> 00:09:53,690
is a graph basically and some nodes of

00:09:49,160 --> 00:09:55,460
the graphs are pipes and interfaces

00:09:53,690 --> 00:09:57,770
interfaces meaning either public

00:09:55,460 --> 00:09:59,860
functions like exported functions that

00:09:57,770 --> 00:10:03,580
are not static for instance in C or

00:09:59,860 --> 00:10:05,150
global variables you know things that

00:10:03,580 --> 00:10:07,850
applications

00:10:05,150 --> 00:10:09,170
can use you know from the binary so we

00:10:07,850 --> 00:10:12,500
build an internal representation of that

00:10:09,170 --> 00:10:16,430
and then the library also has facilities

00:10:12,500 --> 00:10:20,720
to compare two graphs to internal

00:10:16,430 --> 00:10:23,000
representation and then once we've

00:10:20,720 --> 00:10:26,780
compared that I mean like think about it

00:10:23,000 --> 00:10:30,410
as what the new DIF does write on text

00:10:26,780 --> 00:10:32,840
files but one of the big differences of

00:10:30,410 --> 00:10:36,500
what we do compared to unitive is that

00:10:32,840 --> 00:10:40,130
once we have the result of the

00:10:36,500 --> 00:10:43,060
comparison we just don't spit it out we

00:10:40,130 --> 00:10:46,630
also build an internal representation of

00:10:43,060 --> 00:10:51,020
the changes as well

00:10:46,630 --> 00:10:56,390
you know not every single change needs

00:10:51,020 --> 00:10:57,890
to be like emitted report it as is let

00:10:56,390 --> 00:11:01,010
me give you an example you have for

00:10:57,890 --> 00:11:04,400
instance I don't know two functions the

00:11:01,010 --> 00:11:06,470
first one is name is foo yeah all the

00:11:04,400 --> 00:11:08,870
functions are named foo be someone and

00:11:06,470 --> 00:11:13,720
the other one is ah you know my example

00:11:08,870 --> 00:11:16,670
right bar so and the two functions have

00:11:13,720 --> 00:11:19,250
taken parameter which is I don't know in

00:11:16,670 --> 00:11:21,860
C a pointer to a structure for instance

00:11:19,250 --> 00:11:24,580
I don't know the structures name is s

00:11:21,860 --> 00:11:27,530
and suppose that we run an ABI

00:11:24,580 --> 00:11:29,060
comparison between the two versions so

00:11:27,530 --> 00:11:31,580
this is a super fancy library we have

00:11:29,060 --> 00:11:35,270
right and we come up with a new version

00:11:31,580 --> 00:11:39,380
of it and we modify s the structure s so

00:11:35,270 --> 00:11:41,960
suppose that the report says that okay

00:11:39,380 --> 00:11:45,170
in function foo we have an a change and

00:11:41,960 --> 00:11:47,450
that change is well it's s that changed

00:11:45,170 --> 00:11:51,980
basically and because of that it did

00:11:47,450 --> 00:11:56,840
impact foo right do you want to know by

00:11:51,980 --> 00:12:00,800
default for instance that bar has also

00:11:56,840 --> 00:12:04,190
an ABI change and that change is due to

00:12:00,800 --> 00:12:09,230
s you can say yes but usually most

00:12:04,190 --> 00:12:12,050
developers how we came up with abi abi

00:12:09,230 --> 00:12:14,210
dev result at the beginning told me this

00:12:12,050 --> 00:12:16,910
is noise you told me about the change of

00:12:14,210 --> 00:12:18,080
s on foo I don't want to see the change

00:12:16,910 --> 00:12:20,450
of s on bar

00:12:18,080 --> 00:12:24,200
you know like by default the second one

00:12:20,450 --> 00:12:26,630
is redundant okay so whenever whenever

00:12:24,200 --> 00:12:28,670
we have the internal representation of

00:12:26,630 --> 00:12:31,190
the ABI change what we do is that we

00:12:28,670 --> 00:12:36,400
analyze that as well and then we will

00:12:31,190 --> 00:12:39,530
flag stuff like redundant stuff or or

00:12:36,400 --> 00:12:41,600
you know changes that are not meaningful

00:12:39,530 --> 00:12:44,270
for instance let me give you another

00:12:41,600 --> 00:12:46,550
example if you're analyzing a C++

00:12:44,270 --> 00:12:49,940
library for instance and you change some

00:12:46,550 --> 00:12:51,590
data members moves from being public to

00:12:49,940 --> 00:12:52,040
private I don't know or the other way

00:12:51,590 --> 00:12:54,740
around

00:12:52,040 --> 00:12:57,710
okay this is a change and we see that in

00:12:54,740 --> 00:12:59,390
the debug info and we detect that but is

00:12:57,710 --> 00:13:01,520
that really an API change that is

00:12:59,390 --> 00:13:03,860
meaningful at first sight it doesn't

00:13:01,520 --> 00:13:06,020
really you know break things basically

00:13:03,860 --> 00:13:09,190
some programmers would want to see it

00:13:06,020 --> 00:13:12,530
right so we will put that in another

00:13:09,190 --> 00:13:14,780
category which is a category you know

00:13:12,530 --> 00:13:16,640
which says okay it's a change but not

00:13:14,780 --> 00:13:20,960
very important so we do all these things

00:13:16,640 --> 00:13:22,100
on the graph of ABI changes as well so

00:13:20,960 --> 00:13:24,620
this is where we're different from

00:13:22,100 --> 00:13:29,810
something like nude if you know we also

00:13:24,620 --> 00:13:35,030
work on the changes and at this point we

00:13:29,810 --> 00:13:37,520
give a chance to users to say what they

00:13:35,030 --> 00:13:41,330
want to see as a changes and what they

00:13:37,520 --> 00:13:44,150
don't want to see for instance you can

00:13:41,330 --> 00:13:47,540
have a second function a third function

00:13:44,150 --> 00:13:51,320
named baths I don't know so foo bar and

00:13:47,540 --> 00:13:56,060
the third one is bad always and for a

00:13:51,320 --> 00:14:00,020
reason Baz is exported you know as an

00:13:56,060 --> 00:14:02,240
elf artifact but gramming model in your

00:14:00,020 --> 00:14:05,590
project Baz is private to you it's only

00:14:02,240 --> 00:14:07,400
used it's only meant to be used by other

00:14:05,590 --> 00:14:07,910
libraries that's are part of your

00:14:07,400 --> 00:14:12,850
project

00:14:07,910 --> 00:14:16,379
it is so Baz is public from an elf

00:14:12,850 --> 00:14:21,220
perspective but

00:14:16,379 --> 00:14:24,790
exactly you don't put bears in header

00:14:21,220 --> 00:14:27,369
files for instance so you want to you

00:14:24,790 --> 00:14:29,679
don't want to see changes on that even

00:14:27,369 --> 00:14:31,049
though it's public programmers are weird

00:14:29,679 --> 00:14:34,299
sometimes

00:14:31,049 --> 00:14:36,730
so for that you can write what the

00:14:34,299 --> 00:14:40,360
valgrind are people called a suppression

00:14:36,730 --> 00:14:43,629
file right saying okay this function I

00:14:40,360 --> 00:14:45,910
don't want to see any changes related to

00:14:43,629 --> 00:14:48,299
it we call that suppressions and so

00:14:45,910 --> 00:14:53,139
suppressions will be taken into account

00:14:48,299 --> 00:14:55,899
when we are analyzing the graph of ABI

00:14:53,139 --> 00:15:00,369
changes okay so this will be at that

00:14:55,899 --> 00:15:03,009
point basically and then we have passes

00:15:00,369 --> 00:15:04,509
it's basically a compiler stuff we have

00:15:03,009 --> 00:15:08,679
other passes that we'll walk through

00:15:04,509 --> 00:15:12,549
this graph of changes and we'll report

00:15:08,679 --> 00:15:14,799
those changes okay so do you see the

00:15:12,549 --> 00:15:17,739
pipeline a little bit so this is what we

00:15:14,799 --> 00:15:22,360
do sometimes it can take a lot of space

00:15:17,739 --> 00:15:24,999
and time because if you look at it from

00:15:22,360 --> 00:15:30,730
a tool chain perspective what we do here

00:15:24,999 --> 00:15:33,669
is just like what linkers do okay we

00:15:30,730 --> 00:15:37,720
look at the the the library the dot s so

00:15:33,669 --> 00:15:39,999
file and from the dot iso file we we

00:15:37,720 --> 00:15:43,239
break it apart and we look at every

00:15:39,999 --> 00:15:47,019
single translation unit you you get that

00:15:43,239 --> 00:15:50,230
translation unit that make up this dot

00:15:47,019 --> 00:15:53,410
iso file and from those translation unit

00:15:50,230 --> 00:15:56,199
we build a common model right so just

00:15:53,410 --> 00:15:59,949
like what linkers the linkers do except

00:15:56,199 --> 00:16:02,649
that linkers don't look at types right

00:15:59,949 --> 00:16:05,259
they just look at you like relocations

00:16:02,649 --> 00:16:07,569
symbols and so on and so forth when you

00:16:05,259 --> 00:16:12,549
start looking at types things can become

00:16:07,569 --> 00:16:14,889
really messy you know and super big okay

00:16:12,549 --> 00:16:16,449
so that's the main difference between us

00:16:14,889 --> 00:16:20,120
and linkers but you know their

00:16:16,449 --> 00:16:24,080
similarities so

00:16:20,120 --> 00:16:27,720
based on that library we came up with

00:16:24,080 --> 00:16:33,420
different tools directed by the feedback

00:16:27,720 --> 00:16:35,370
we got from you guys from users so we

00:16:33,420 --> 00:16:40,260
came up with a tool named ABI package

00:16:35,370 --> 00:16:43,560
diff which takes two rpms today someone

00:16:40,260 --> 00:16:45,330
added Debian support so it works on live

00:16:43,560 --> 00:16:50,910
in packages as well anyway

00:16:45,330 --> 00:16:53,130
and for those rpms we will look here you

00:16:50,910 --> 00:16:55,620
know the binaries are only the shared

00:16:53,130 --> 00:16:59,040
libraries it depends it I can look at

00:16:55,620 --> 00:17:01,650
both that are in those rpms and we will

00:16:59,040 --> 00:17:06,780
perform comparisons ABI comparisons on

00:17:01,650 --> 00:17:08,640
them of course for that we also need the

00:17:06,780 --> 00:17:13,560
debug info rpms okay

00:17:08,640 --> 00:17:15,900
and these are these so it looks things

00:17:13,560 --> 00:17:20,610
always look simple when you put them on

00:17:15,900 --> 00:17:23,430
on slides but think about it a bit the

00:17:20,610 --> 00:17:27,300
debug info is usually stripped when we

00:17:23,430 --> 00:17:31,560
use our you know RPM pipeline the debug

00:17:27,300 --> 00:17:34,680
info is stripped out so we that's one

00:17:31,560 --> 00:17:36,690
thing and secondly it is compressed you

00:17:34,680 --> 00:17:40,130
know that right we use a compression

00:17:36,690 --> 00:17:45,030
scheme carried by a tool which name is

00:17:40,130 --> 00:17:47,520
dwz so it's an ad hoc compression scheme

00:17:45,030 --> 00:17:51,630
that we use I say we I mean the tool

00:17:47,520 --> 00:17:55,160
chain people so what the barbegal does

00:17:51,630 --> 00:17:58,830
here is that it also has to decompress

00:17:55,160 --> 00:18:00,810
this debug info so debugging for that

00:17:58,830 --> 00:18:06,450
will take I don't know like one gigabyte

00:18:00,810 --> 00:18:09,330
of space decompressed can take right so

00:18:06,450 --> 00:18:11,670
the compressing that has you know

00:18:09,330 --> 00:18:14,850
bringing challenges because we have to

00:18:11,670 --> 00:18:17,520
you know try to reduce the memory

00:18:14,850 --> 00:18:19,200
consumption you know to not make things

00:18:17,520 --> 00:18:24,170
explodes but there are interesting

00:18:19,200 --> 00:18:29,610
things there so we do that bug info and

00:18:24,170 --> 00:18:32,010
then we also take the devel RPM packages

00:18:29,610 --> 00:18:33,030
into account because remember we were

00:18:32,010 --> 00:18:36,660
saying that

00:18:33,030 --> 00:18:39,090
you can have some exported functions or

00:18:36,660 --> 00:18:42,570
global variables that are not meant to

00:18:39,090 --> 00:18:45,510
be like consumed by applications they

00:18:42,570 --> 00:18:47,300
are meant for internal purposes but how

00:18:45,510 --> 00:18:51,030
do you know that these are internal

00:18:47,300 --> 00:18:55,880
stuff and not public API is what we do

00:18:51,030 --> 00:19:01,410
is that we look at the header files okay

00:18:55,880 --> 00:19:05,610
and we try to be maybe too smart for our

00:19:01,410 --> 00:19:07,890
own sake because one of the main purpose

00:19:05,610 --> 00:19:09,450
of one we what we are doing here is that

00:19:07,890 --> 00:19:11,790
we don't want to look at the source code

00:19:09,450 --> 00:19:15,270
we really don't want to do that we want

00:19:11,790 --> 00:19:19,380
to look only at binary files do you get

00:19:15,270 --> 00:19:22,140
why okay the reason is that I mean there

00:19:19,380 --> 00:19:25,140
there are some profound implications to

00:19:22,140 --> 00:19:28,230
that because today when you look at the

00:19:25,140 --> 00:19:31,590
source code you cannot know what the

00:19:28,230 --> 00:19:35,340
binary form is going to be because in C

00:19:31,590 --> 00:19:38,340
and C++ we are subject to the tyranny of

00:19:35,340 --> 00:19:40,310
the preprocessor which means that there

00:19:38,340 --> 00:19:43,530
are stuff missing from the source code

00:19:40,310 --> 00:19:45,630
you know there is information missing

00:19:43,530 --> 00:19:48,390
meaning for instance the value of the

00:19:45,630 --> 00:19:50,040
define you know of macros you don't have

00:19:48,390 --> 00:19:52,530
that when you look at the source code so

00:19:50,040 --> 00:19:55,650
you have to know the build system stuff

00:19:52,530 --> 00:19:58,400
so when once you start willing to parse

00:19:55,650 --> 00:20:00,690
source code you get into a rabbit hole

00:19:58,400 --> 00:20:02,670
because you need to be able to parse the

00:20:00,690 --> 00:20:04,890
build system and we have Oh two tools we

00:20:02,670 --> 00:20:07,590
have messin we have you know it's super

00:20:04,890 --> 00:20:10,710
messy the world of build systems so we

00:20:07,590 --> 00:20:13,080
just want to look at the binaries right

00:20:10,710 --> 00:20:17,130
and then well then you have the binary

00:20:13,080 --> 00:20:21,510
form okay but then now we want to look

00:20:17,130 --> 00:20:25,140
at header files to know what the public

00:20:21,510 --> 00:20:27,420
interfaces are so what we do is that we

00:20:25,140 --> 00:20:31,620
are going to when we analyze the

00:20:27,420 --> 00:20:34,530
binaries we look at an interface and in

00:20:31,620 --> 00:20:38,220
the debug info there is information in

00:20:34,530 --> 00:20:42,340
there saying where in which file this

00:20:38,220 --> 00:20:44,859
interface has been declared or defined

00:20:42,340 --> 00:20:48,489
I'll repeat that when you have a

00:20:44,859 --> 00:20:53,769
structure that is defined in a header

00:20:48,489 --> 00:20:56,200
file a foot H file that information is

00:20:53,769 --> 00:20:59,169
present in the debug info so you see

00:20:56,200 --> 00:21:03,039
that struct s is defined in food age

00:20:59,169 --> 00:21:06,219
okay and then what we're going to do is

00:21:03,039 --> 00:21:09,070
that we're going to go see if we have

00:21:06,219 --> 00:21:11,979
food at H in the header files in the

00:21:09,070 --> 00:21:15,509
devel or p.m. if we do then food that h

00:21:11,979 --> 00:21:18,519
is part of you know the public interface

00:21:15,509 --> 00:21:20,589
defining header files so we know that s

00:21:18,519 --> 00:21:23,889
is part of the public interface that's

00:21:20,589 --> 00:21:27,519
how we do it you know without having to

00:21:23,889 --> 00:21:30,999
parse the header files so we need the

00:21:27,519 --> 00:21:34,289
devel or PMS so once we have that we

00:21:30,999 --> 00:21:38,469
will Auto generate some suppression

00:21:34,289 --> 00:21:41,559
specifications saying that whatever is

00:21:38,469 --> 00:21:44,919
not in food age we don't want to see its

00:21:41,559 --> 00:21:48,789
report so this is how we integrate all

00:21:44,919 --> 00:21:54,839
this in the pipeline okay to reduce of

00:21:48,789 --> 00:21:58,089
course noise in the final report then

00:21:54,839 --> 00:21:59,799
people were not happy enough they wanted

00:21:58,089 --> 00:22:04,029
to do weird stuff

00:21:59,799 --> 00:22:07,210
programmers again so we came up with a

00:22:04,029 --> 00:22:07,710
tool which name is ABI DW what does it

00:22:07,210 --> 00:22:11,950
do

00:22:07,710 --> 00:22:14,649
it emits a textual representation of the

00:22:11,950 --> 00:22:17,440
ABI of a binary so suppose you have a

00:22:14,649 --> 00:22:19,210
binary you want to know what is that the

00:22:17,440 --> 00:22:22,239
ABI of that binary and you want to save

00:22:19,210 --> 00:22:24,489
that ABI and to get without having to

00:22:22,239 --> 00:22:26,679
save the binary into gate right because

00:22:24,489 --> 00:22:31,139
nobody wants to save binaries into gate

00:22:26,679 --> 00:22:34,779
or something so ABI DW just spits out an

00:22:31,139 --> 00:22:37,330
XML file we file we call that in a

00:22:34,779 --> 00:22:39,070
format that we call ABI XML so you can

00:22:37,330 --> 00:22:43,119
just take that boom and stick that into

00:22:39,070 --> 00:22:45,119
into gate and then afterwards there is

00:22:43,119 --> 00:22:49,330
another tool which name is ABI diff

00:22:45,119 --> 00:22:51,970
which can take an ABI XML file and a

00:22:49,330 --> 00:22:54,550
binary so you will compare the ABI of

00:22:51,970 --> 00:22:56,380
the binary against the ABI of the

00:22:54,550 --> 00:22:58,240
via XML file which is the base a

00:22:56,380 --> 00:23:01,510
baseline ABI for instance for you and

00:22:58,240 --> 00:23:06,430
that is useful for people to build ad

00:23:01,510 --> 00:23:07,840
hoc ABI checking stuff during the you

00:23:06,430 --> 00:23:09,670
know that they can run during the build

00:23:07,840 --> 00:23:13,000
system there's some upstream project

00:23:09,670 --> 00:23:17,560
today that have a make check ABI like

00:23:13,000 --> 00:23:19,120
target that is run regularly and so they

00:23:17,560 --> 00:23:23,710
do this guy they use this kind of stuff

00:23:19,120 --> 00:23:26,590
okay so many people do have you know

00:23:23,710 --> 00:23:29,290
different use cases in mind depending on

00:23:26,590 --> 00:23:31,690
their project and if we don't have the

00:23:29,290 --> 00:23:33,760
tool for that I mean it's okay to come

00:23:31,690 --> 00:23:35,680
to us and say you know what if you guys

00:23:33,760 --> 00:23:38,650
could come up with this kind of tool and

00:23:35,680 --> 00:23:41,230
we will you know try to write it if

00:23:38,650 --> 00:23:44,140
possible and if the Lib Abigail library

00:23:41,230 --> 00:23:45,760
doesn't have the features needed for

00:23:44,140 --> 00:23:47,950
that - well we'll just add it because

00:23:45,760 --> 00:23:52,660
you know we don't know all the use cases

00:23:47,950 --> 00:23:55,950
but you know in advance and there is

00:23:52,660 --> 00:23:59,580
also fed ABI package ative which is

00:23:55,950 --> 00:24:03,850
intended for fedora specifically as

00:23:59,580 --> 00:24:05,890
you've as you can imagine here using ABI

00:24:03,850 --> 00:24:08,380
package diff can be tedious you have to

00:24:05,890 --> 00:24:10,510
get the two rpms you you want to compare

00:24:08,380 --> 00:24:12,640
you have to get the debug info rpms what

00:24:10,510 --> 00:24:16,290
do you have to get the devel or you know

00:24:12,640 --> 00:24:19,690
and at some point you just get fed up

00:24:16,290 --> 00:24:24,220
fed up so we said rather than being fed

00:24:19,690 --> 00:24:29,410
up use fed ABI packaged it and yeah do

00:24:24,220 --> 00:24:31,870
my best for jokes anyway so this one is

00:24:29,410 --> 00:24:34,210
quite cool even though it's written in

00:24:31,870 --> 00:24:34,450
Python nobody's perfect I didn't write

00:24:34,210 --> 00:24:38,650
that

00:24:34,450 --> 00:24:41,830
but anyway apparently writing it in in

00:24:38,650 --> 00:24:45,010
Python was mandatory so that we could

00:24:41,830 --> 00:24:47,290
use the koji interface or something

00:24:45,010 --> 00:24:50,350
there's they're always bad reasons to

00:24:47,290 --> 00:24:53,500
use Python anyway so but it's a cool

00:24:50,350 --> 00:24:55,840
tool seriously I like it I like it a lot

00:24:53,500 --> 00:24:59,440
because you just say fed ABI packaged if

00:24:55,840 --> 00:25:01,420
you give the name of the package like no

00:24:59,440 --> 00:25:05,260
failure baby I packaged it if you say

00:25:01,420 --> 00:25:08,020
from Fedora 27 for instance and the name

00:25:05,260 --> 00:25:10,870
of the package you've just built

00:25:08,020 --> 00:25:14,020
right the RPM you'd like HTTP something

00:25:10,870 --> 00:25:16,870
that rpm and so fed API package if he's

00:25:14,020 --> 00:25:19,210
going to compare the ABI of HTTP package

00:25:16,870 --> 00:25:21,670
you just build against the stable one

00:25:19,210 --> 00:25:23,530
from fedora 28 you don't even know the

00:25:21,670 --> 00:25:26,980
version you don't even know where it is

00:25:23,530 --> 00:25:28,780
just go grabs it even if you can do some

00:25:26,980 --> 00:25:32,680
nice stuff in Python apparently anyway

00:25:28,780 --> 00:25:34,900
and and it works so this is typically

00:25:32,680 --> 00:25:37,270
one of these things that we didn't think

00:25:34,900 --> 00:25:41,320
about in the beginning and federal users

00:25:37,270 --> 00:25:44,440
you know like made us write and we have

00:25:41,320 --> 00:25:47,320
other tools as well but I won't bother

00:25:44,440 --> 00:25:54,520
you guys too much with with those for

00:25:47,320 --> 00:25:58,810
now so of course today tasks API check

00:25:54,520 --> 00:26:01,660
so the API verifier of fedora uses ABI

00:25:58,810 --> 00:26:05,050
package thief as a matter of fact it was

00:26:01,660 --> 00:26:08,560
because of API check that scene II wrote

00:26:05,050 --> 00:26:12,790
ABI package diff to begin with so always

00:26:08,560 --> 00:26:15,250
this you know user use case driven

00:26:12,790 --> 00:26:18,190
approach that we have we don't do

00:26:15,250 --> 00:26:27,100
intelligent design that much you know we

00:26:18,190 --> 00:26:31,210
just we grow like a cancer anyway so so

00:26:27,100 --> 00:26:35,500
well what we do is that you want to talk

00:26:31,210 --> 00:26:38,650
about this one or I yeah okay we just

00:26:35,500 --> 00:26:42,810
compare so the new package we go against

00:26:38,650 --> 00:26:46,720
the old one like as as you guys know and

00:26:42,810 --> 00:26:49,180
because this tasks API check uses sorry

00:26:46,720 --> 00:26:52,600
uses the task or on infrastructure there

00:26:49,180 --> 00:26:56,320
are some lot of nice magic in there to

00:26:52,600 --> 00:26:57,970
get you know the debug info packages the

00:26:56,320 --> 00:27:00,190
devel packages I call that all the

00:26:57,970 --> 00:27:02,800
ancillary packages needed to do to

00:27:00,190 --> 00:27:04,210
perform the the comparison and it's all

00:27:02,800 --> 00:27:06,370
magic boom

00:27:04,210 --> 00:27:09,100
Tesco Tron give infrastructure gives us

00:27:06,370 --> 00:27:11,860
everything and we can perform the

00:27:09,100 --> 00:27:16,270
comparison without task patron knowing

00:27:11,860 --> 00:27:18,610
exactly you know what's happening and so

00:27:16,270 --> 00:27:20,280
yeah it's it's it's kind of you know

00:27:18,610 --> 00:27:22,100
well integrated then I

00:27:20,280 --> 00:27:25,230
the friends just to give you an example

00:27:22,100 --> 00:27:27,420
at the beginning we wanted well I wanted

00:27:25,230 --> 00:27:29,220
I liked multi-threaded stuff I like

00:27:27,420 --> 00:27:31,160
doing stuff in parallel and we were

00:27:29,220 --> 00:27:33,870
talking I think it was with you coming

00:27:31,160 --> 00:27:36,870
coming up with about you know like Tesco

00:27:33,870 --> 00:27:40,500
Tron is it you know like multi-threaded

00:27:36,870 --> 00:27:42,870
blah blah blah and well just because we

00:27:40,500 --> 00:27:45,290
could write a bi packaged if you you

00:27:42,870 --> 00:27:46,590
know underneath we put all the

00:27:45,290 --> 00:27:48,720
multitasking

00:27:46,590 --> 00:27:50,370
you know parallel handling in a bi a

00:27:48,720 --> 00:27:52,770
package ative that's what Tesco Tron

00:27:50,370 --> 00:27:55,080
just calls it and we perform you know

00:27:52,770 --> 00:27:59,070
like if I don't know if your lab your

00:27:55,080 --> 00:28:01,320
rpm has like five libraries and you have

00:27:59,070 --> 00:28:03,810
at least five course right on the

00:28:01,320 --> 00:28:05,220
machine then the five comparisons are

00:28:03,810 --> 00:28:07,620
going to happen in parallel you know

00:28:05,220 --> 00:28:13,260
this kind of stuff so it's pretty pretty

00:28:07,620 --> 00:28:18,930
neat so as you know we get the public

00:28:13,260 --> 00:28:21,530
interfaces from the devel package and we

00:28:18,930 --> 00:28:24,200
provide you know suppression

00:28:21,530 --> 00:28:30,390
automatically based on based on that now

00:28:24,200 --> 00:28:33,150
so as a result of this you have to know

00:28:30,390 --> 00:28:37,680
that I mean a bi comparison is a gray

00:28:33,150 --> 00:28:39,480
area kind of thing we cannot say oh you

00:28:37,680 --> 00:28:42,470
know you can we cannot always say if

00:28:39,480 --> 00:28:45,900
change and maybe I change is good or bad

00:28:42,470 --> 00:28:49,320
basically it depends there are some that

00:28:45,900 --> 00:28:51,180
are you know bad like I don't know a

00:28:49,320 --> 00:28:54,380
function disappearing a public function

00:28:51,180 --> 00:28:58,200
that is in the interface that disappears

00:28:54,380 --> 00:29:01,910
a type I mean like for instance a return

00:28:58,200 --> 00:29:03,180
type of a function that changes

00:29:01,910 --> 00:29:07,260
completely

00:29:03,180 --> 00:29:10,740
we flag that as not good but there are

00:29:07,260 --> 00:29:12,990
other changes that are weird so the

00:29:10,740 --> 00:29:14,730
first kind of change when we know for

00:29:12,990 --> 00:29:17,820
sure that they are not good your test

00:29:14,730 --> 00:29:20,790
failed it failed sorry the status of the

00:29:17,820 --> 00:29:23,450
test is failed but then suppose you have

00:29:20,790 --> 00:29:27,360
a you have a structure I don't know

00:29:23,450 --> 00:29:29,880
which gets changed like you remove a

00:29:27,360 --> 00:29:33,410
data member from it and you add a new

00:29:29,880 --> 00:29:33,410
data member for to it

00:29:34,160 --> 00:29:38,120
and the size of the structure doesn't

00:29:36,170 --> 00:29:41,270
change is that good or bad

00:29:38,120 --> 00:29:43,700
hard to say so we flag it we detect it

00:29:41,270 --> 00:29:47,150
and we say that this kind of change it

00:29:43,700 --> 00:29:52,730
makes it needs inspection so these are

00:29:47,150 --> 00:29:55,370
the kind of gray kind of things and and

00:29:52,730 --> 00:29:57,830
then there is something I wanted to say

00:29:55,370 --> 00:30:00,350
here is that if you keep seeing these

00:29:57,830 --> 00:30:03,080
kind of changes consistently for your

00:30:00,350 --> 00:30:05,900
project you know and in your opinion

00:30:03,080 --> 00:30:10,340
there are better ways to categorize

00:30:05,900 --> 00:30:12,920
these things come to us and even for

00:30:10,340 --> 00:30:16,610
your project we can figure out a way for

00:30:12,920 --> 00:30:19,460
this neat inspection kind of changes to

00:30:16,610 --> 00:30:22,700
become like either failed or passed is

00:30:19,460 --> 00:30:25,220
that clear what I'm saying we yeah

00:30:22,700 --> 00:30:29,240
because yeah we need to evolve that way

00:30:25,220 --> 00:30:34,010
you know based on your feedback so don't

00:30:29,240 --> 00:30:36,800
just say the tool set this ha this okay

00:30:34,010 --> 00:30:40,130
I'm not gonna use any F words here but

00:30:36,800 --> 00:30:41,810
okay this tool ya know yeah if you do a

00:30:40,130 --> 00:30:44,420
raster yeah yeah of course this Fedora

00:30:41,810 --> 00:30:47,090
tool yeah thank you

00:30:44,420 --> 00:30:49,610
no seriously come to us and we'll try to

00:30:47,090 --> 00:30:52,250
figure out something this is how we grow

00:30:49,610 --> 00:30:55,670
and and get better all these static

00:30:52,250 --> 00:31:01,240
analysis tools need to you know grow

00:30:55,670 --> 00:31:05,500
like this with input from from users so

00:31:01,240 --> 00:31:08,690
this brings us to the bode updates

00:31:05,500 --> 00:31:12,500
getting project so as you guys know at

00:31:08,690 --> 00:31:15,020
some point well I mean even well at some

00:31:12,500 --> 00:31:20,990
points people wanted to use more

00:31:15,020 --> 00:31:25,600
automated tests way to gate package

00:31:20,990 --> 00:31:31,010
update through body and well we started

00:31:25,600 --> 00:31:32,960
you know enabling API verification in

00:31:31,010 --> 00:31:39,980
that framework I mean using tasks API

00:31:32,960 --> 00:31:44,510
check as a gating that's right yeah so

00:31:39,980 --> 00:31:44,510
and we have pretty interesting results

00:31:45,440 --> 00:31:52,650
yeah so we already have the test running

00:31:50,070 --> 00:31:58,020
in both the updates we saw in the web

00:31:52,650 --> 00:32:01,050
interface before so this the current

00:31:58,020 --> 00:32:03,390
approach what happens that a package

00:32:01,050 --> 00:32:05,760
manager a package maintainer can go and

00:32:03,390 --> 00:32:08,760
see in the body test results whether a

00:32:05,760 --> 00:32:11,550
be a checkered past or not or he can he

00:32:08,760 --> 00:32:15,120
can go and see in the email notification

00:32:11,550 --> 00:32:18,330
that the test has passed or failed but

00:32:15,120 --> 00:32:22,020
there is no way that we are saying that

00:32:18,330 --> 00:32:25,260
okay go and fix it maybe maintainer can

00:32:22,020 --> 00:32:28,950
go and just ignore it and we might have

00:32:25,260 --> 00:32:30,480
seen a lot of some of at least email

00:32:28,950 --> 00:32:32,640
threats on fedora devil that this

00:32:30,480 --> 00:32:34,110
package has been updated and there was a

00:32:32,640 --> 00:32:37,130
be a change and it has not been

00:32:34,110 --> 00:32:41,940
announced and that leads to a lot of

00:32:37,130 --> 00:32:45,780
package being failed so we tried to do

00:32:41,940 --> 00:32:48,650
in fedora to get the gate

00:32:45,780 --> 00:32:51,800
the body a package updates using the

00:32:48,650 --> 00:32:55,230
using the ABI check as well so in

00:32:51,800 --> 00:32:57,540
January and I think the we in name we

00:32:55,230 --> 00:33:00,600
started the gating the getting the

00:32:57,540 --> 00:33:05,640
package updates with some other tests

00:33:00,600 --> 00:33:10,170
there was a BIA check as well and in

00:33:05,640 --> 00:33:14,220
this of what we do is that whenever a

00:33:10,170 --> 00:33:17,390
package it pushed and the updates is

00:33:14,220 --> 00:33:23,280
available in body if there is a failure

00:33:17,390 --> 00:33:27,480
then it will stop it from being being

00:33:23,280 --> 00:33:30,440
pushed default it needs to be inspected

00:33:27,480 --> 00:33:33,600
by the maintainer he needs to fix it or

00:33:30,440 --> 00:33:37,820
he can go and wave it that was the

00:33:33,600 --> 00:33:43,140
approach but it didn't work out and it

00:33:37,820 --> 00:33:46,530
just failed the reason we'll look at it

00:33:43,140 --> 00:33:50,040
so basically what happened that we got

00:33:46,530 --> 00:33:52,910
very quickly some feedback that the

00:33:50,040 --> 00:33:55,770
tests which are running a bi check is

00:33:52,910 --> 00:33:59,040
getting them is like there is loss of

00:33:55,770 --> 00:34:01,200
false positive results coming up and

00:33:59,040 --> 00:34:06,450
they cannot really push the updates

00:34:01,200 --> 00:34:11,010
available and then the reason was we

00:34:06,450 --> 00:34:14,820
look yeah so what happens that in the

00:34:11,010 --> 00:34:17,460
shared library we we do a be a

00:34:14,820 --> 00:34:21,359
comparison for all the shared library

00:34:17,460 --> 00:34:24,570
available in the package and the the

00:34:21,359 --> 00:34:28,020
issue which we faced was there were a

00:34:24,570 --> 00:34:30,629
lot of libraries which we are considered

00:34:28,020 --> 00:34:31,260
as private libraries as per the

00:34:30,629 --> 00:34:34,220
maintainer

00:34:31,260 --> 00:34:38,010
for example if you go to the LibreOffice

00:34:34,220 --> 00:34:39,720
package or anything there are some

00:34:38,010 --> 00:34:42,179
shared library which is supposed to be

00:34:39,720 --> 00:34:44,550
used for the internal purpose the

00:34:42,179 --> 00:34:46,830
private libraries is like yeah it is

00:34:44,550 --> 00:34:49,290
being used for just inside the project

00:34:46,830 --> 00:34:54,080
and it is not supposed to be used by the

00:34:49,290 --> 00:34:58,080
other other in the other applications so

00:34:54,080 --> 00:35:02,850
these changes were really not supposed

00:34:58,080 --> 00:35:10,950
to be Kate Kate getting the package from

00:35:02,850 --> 00:35:15,570
being pushed to the stable so what we

00:35:10,950 --> 00:35:18,869
did was when we stopped the gating based

00:35:15,570 --> 00:35:22,920
on a bi check as soon as possible and

00:35:18,869 --> 00:35:23,369
then we started looking into how to fix

00:35:22,920 --> 00:35:28,380
that

00:35:23,369 --> 00:35:31,320
so we there is really no way in the AL

00:35:28,380 --> 00:35:34,920
if by near LF binary to say that this is

00:35:31,320 --> 00:35:37,020
a private shared library or a public

00:35:34,920 --> 00:35:40,109
shared library all are like just a share

00:35:37,020 --> 00:35:44,010
library so we came up with an approach

00:35:40,109 --> 00:35:47,600
after some discussion or that if rpm

00:35:44,010 --> 00:35:51,600
package says that we provide these esos

00:35:47,600 --> 00:35:53,520
so we consider only those as the public

00:35:51,600 --> 00:35:55,530
shared library and rest of the library

00:35:53,520 --> 00:35:56,059
would be the privately share library

00:35:55,530 --> 00:35:58,209
which is

00:35:56,059 --> 00:36:02,959
most abuse only inside the application

00:35:58,209 --> 00:36:06,079
and got implemented in into the into the

00:36:02,959 --> 00:36:10,969
lib Abigail itself a bi pkg Tiptronic

00:36:06,079 --> 00:36:14,209
and another was it was a minor stuff

00:36:10,969 --> 00:36:17,119
which I think we may start or we came to

00:36:14,209 --> 00:36:20,989
know about while doing this fixes we

00:36:17,119 --> 00:36:23,449
were so suppose if you have rpm package

00:36:20,989 --> 00:36:25,369
update and they are a lot there are some

00:36:23,449 --> 00:36:28,219
some packs of packages so if you don't

00:36:25,369 --> 00:36:30,619
ship devil or a header packages into

00:36:28,219 --> 00:36:33,079
that which means that we should assume

00:36:30,619 --> 00:36:36,469
you don't really want to use your

00:36:33,079 --> 00:36:39,890
application as a to be consumed by

00:36:36,469 --> 00:36:42,410
another packages so if you're not

00:36:39,890 --> 00:36:46,819
shipping any devil package we are

00:36:42,410 --> 00:36:49,160
considering it as private any any shared

00:36:46,819 --> 00:36:51,709
library shared as a private I would not

00:36:49,160 --> 00:36:54,650
consider it as a being used consumed so

00:36:51,709 --> 00:36:57,229
that we implemented inside the tasks API

00:36:54,650 --> 00:37:01,150
check itself and these are the two

00:36:57,229 --> 00:37:03,769
things we did and leave a bigger 1.4

00:37:01,150 --> 00:37:06,739
which we recently which was recently

00:37:03,769 --> 00:37:10,239
released contain the fixes of the first

00:37:06,739 --> 00:37:13,249
issue and it's now again ready because

00:37:10,239 --> 00:37:17,890
these were the main issue which we saw

00:37:13,249 --> 00:37:22,429
so far so maybe we can enable again the

00:37:17,890 --> 00:37:25,549
gating of the body upon the tasks API

00:37:22,429 --> 00:37:28,729
check so initially it was I think

00:37:25,549 --> 00:37:32,630
enabled for all the packages but maybe

00:37:28,729 --> 00:37:35,299
this time we can start with gating some

00:37:32,630 --> 00:37:38,660
of the packages or obtain bases like

00:37:35,299 --> 00:37:41,269
some maintain us who wants to opt it

00:37:38,660 --> 00:37:43,999
they can they can obtain and see how it

00:37:41,269 --> 00:37:46,029
goes so yeah it's just open to

00:37:43,999 --> 00:37:49,939
suggestions what we should be doing

00:37:46,029 --> 00:37:53,359
there's one more stuff like if you are

00:37:49,939 --> 00:37:57,679
really not satisfied with the current

00:37:53,359 --> 00:38:01,009
current separation which we do like not

00:37:57,679 --> 00:38:04,820
considering the private libraries and if

00:38:01,009 --> 00:38:09,380
you still wants to suppress some of the

00:38:04,820 --> 00:38:11,750
some of the libraries or or any inside

00:38:09,380 --> 00:38:14,780
symbols as a considered to be private

00:38:11,750 --> 00:38:18,110
you can write your own ABI specification

00:38:14,780 --> 00:38:21,530
there is a you can have ship dot a by

00:38:18,110 --> 00:38:23,990
ignore file inside your package and you

00:38:21,530 --> 00:38:26,210
can ship it and leave Abigail and the

00:38:23,990 --> 00:38:30,110
two links or top of it will take care of

00:38:26,210 --> 00:38:34,520
it and it will not show you as any ABI

00:38:30,110 --> 00:38:37,880
changes as a false positive so that's

00:38:34,520 --> 00:38:41,060
all and we look into the future

00:38:37,880 --> 00:38:45,410
direction yeah

00:38:41,060 --> 00:38:48,500
future directions so first of all before

00:38:45,410 --> 00:38:49,940
even getting into the specifics of what

00:38:48,500 --> 00:38:53,200
we want to do in the future and so on

00:38:49,940 --> 00:38:57,560
and so forth I wanted to say again that

00:38:53,200 --> 00:39:00,230
it's it's do not please do not be shy I

00:38:57,560 --> 00:39:02,780
mean come to us there are many things

00:39:00,230 --> 00:39:07,130
that are projects dependent for instance

00:39:02,780 --> 00:39:09,830
so Matthias is here in GT K and the

00:39:07,130 --> 00:39:12,860
object base project in general there is

00:39:09,830 --> 00:39:14,780
something that's been in the back of my

00:39:12,860 --> 00:39:19,250
mind for some time that we need to do

00:39:14,780 --> 00:39:21,760
and we haven't you know done yet which

00:39:19,250 --> 00:39:27,080
is that okay you know by default today

00:39:21,760 --> 00:39:32,450
we only look at interfaces that are

00:39:27,080 --> 00:39:35,660
public you know not static and we we get

00:39:32,450 --> 00:39:39,110
the types that we look at from those

00:39:35,660 --> 00:39:42,530
interfaces these are the route of the

00:39:39,110 --> 00:39:44,990
graph that we built but then in GT K and

00:39:42,530 --> 00:39:47,990
G object stuff you have some static

00:39:44,990 --> 00:39:50,480
functions so they're static they're not

00:39:47,990 --> 00:39:54,170
seen outside the binary for instance the

00:39:50,480 --> 00:39:57,530
class stuff you know that are that we

00:39:54,170 --> 00:40:01,760
should look at because these things

00:39:57,530 --> 00:40:04,130
define some of the types that are used

00:40:01,760 --> 00:40:05,330
in you know in the GTA application and

00:40:04,130 --> 00:40:08,300
so on and so forth but because a

00:40:05,330 --> 00:40:11,000
function that use these types or static

00:40:08,300 --> 00:40:14,510
we don't see those so you someone can

00:40:11,000 --> 00:40:16,520
break these things you know these V

00:40:14,510 --> 00:40:19,140
functions that they end up like V

00:40:16,520 --> 00:40:22,979
functions in in the in the

00:40:19,140 --> 00:40:25,259
structures so so I think we can do

00:40:22,979 --> 00:40:27,269
something like you know detecting that

00:40:25,259 --> 00:40:30,509
we're looking at a do object thing and

00:40:27,269 --> 00:40:33,059
look at those static functions as well

00:40:30,509 --> 00:40:35,640
rather than just ignoring them we can do

00:40:33,059 --> 00:40:38,640
that but it's project specific and we

00:40:35,640 --> 00:40:42,660
have to you know like define how how to

00:40:38,640 --> 00:40:44,819
how to do that so yeah it's it's it's

00:40:42,660 --> 00:40:47,279
it's important that we get to have these

00:40:44,819 --> 00:40:49,890
discussions even even if you know we're

00:40:47,279 --> 00:40:52,380
like bandwidth stripped we can still

00:40:49,890 --> 00:40:54,329
design what we want to do and then when

00:40:52,380 --> 00:40:56,279
I have the bandwidth I'll you know work

00:40:54,329 --> 00:40:59,959
on that so please get you know come to

00:40:56,279 --> 00:41:02,789
us and so so we can do stuff for your

00:40:59,959 --> 00:41:05,549
for your project we even supported ADA

00:41:02,789 --> 00:41:07,650
recently like if we do that we can do

00:41:05,549 --> 00:41:13,130
many stuff right there are some people

00:41:07,650 --> 00:41:15,539
like who want us to support Fortran yeah

00:41:13,130 --> 00:41:21,690
anyway so yeah we can do a lot of stuff

00:41:15,539 --> 00:41:24,690
so first of all I think one of the first

00:41:21,690 --> 00:41:27,059
thing that people or be you know are

00:41:24,690 --> 00:41:29,099
asking for is speed improvement we get

00:41:27,059 --> 00:41:30,989
these like all the time but it's never

00:41:29,099 --> 00:41:36,170
enough like for instance if you want to

00:41:30,989 --> 00:41:40,049
analyze Firefox you know okay so

00:41:36,170 --> 00:41:43,619
basically what I'm what I think I would

00:41:40,049 --> 00:41:48,839
like to look into now is doing things

00:41:43,619 --> 00:41:51,959
more in parallel it looks like well at a

00:41:48,839 --> 00:41:55,369
deeper level so I told you that we're

00:41:51,959 --> 00:42:00,299
building an internal representation okay

00:41:55,369 --> 00:42:03,150
but we're loading two binaries usually

00:42:00,299 --> 00:42:05,789
because we're comparing stuff right

00:42:03,150 --> 00:42:08,329
we're loading two binaries but at some

00:42:05,789 --> 00:42:10,859
point we are building just one graph

00:42:08,329 --> 00:42:13,559
even though we have two binaries because

00:42:10,859 --> 00:42:15,690
there are two graphs but we try to share

00:42:13,559 --> 00:42:18,209
many things so if for instance will

00:42:15,690 --> 00:42:19,769
loading the first binary okay we looked

00:42:18,209 --> 00:42:21,839
at we did load the first binary we're

00:42:19,769 --> 00:42:25,259
loading the second one and we see a type

00:42:21,839 --> 00:42:28,469
which name is int integer we've seen int

00:42:25,259 --> 00:42:29,740
in the first binary - right but this

00:42:28,469 --> 00:42:32,020
time the

00:42:29,740 --> 00:42:35,589
it's are the same what do we do I don't

00:42:32,020 --> 00:42:38,680
bill I won't build another int you know

00:42:35,589 --> 00:42:40,869
that is memory waste so I will reuse the

00:42:38,680 --> 00:42:42,849
first int you know so the even though

00:42:40,869 --> 00:42:46,020
the two graphs are different they reuse

00:42:42,849 --> 00:42:46,020

YouTube URL: https://www.youtube.com/watch?v=xOJAz1IrQPc


