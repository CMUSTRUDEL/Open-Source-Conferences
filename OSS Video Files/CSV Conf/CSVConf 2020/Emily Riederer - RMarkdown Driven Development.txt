Title: Emily Riederer - RMarkdown Driven Development
Publication date: 2020-06-02
Playlist: CSVConf 2020
Description: 
	RMarkdown enables analysts to engage with code interactively, embrace literate programming, and rapidly produce a wide variety of high-quality data products such as documents, emails, dashboards, and websites. However, RMarkdown is less commonly explored and celebrated for the important role it can play in helping R users grow into developers. In this talk, I will provide an overview of RMarkdown Driven Development: a workflow for converting one-off analysis into a well-engineered and well-designed R package with deep empathy for user needs. We will explore how the methodical incorporation of good coding practices such as modularization and testing naturally evolves a single-file RMarkdown into an R project or package. Along the way, we will discuss big-picture questions like “optimal stopping” (why some data products are better left as single files or projects) and concrete details such as the {here} and {testthat} packages which can provide step-change improvements to project sustainability.

--
csv,conf,v5 is a community conference for data makers everywhere, featuring stories about data sharing and data analysis from science, journalism, government, and open source.  Held May 13-14, 2020, Online. https://csvconf.com/
Captions: 
	00:00:00,030 --> 00:00:04,020
all right well thank you very much

00:00:01,829 --> 00:00:07,020
everyone today I am here to talk about

00:00:04,020 --> 00:00:09,179
our markdown driven development so

00:00:07,020 --> 00:00:11,099
essentially I think many of us in the

00:00:09,179 --> 00:00:14,009
open science and open data communities

00:00:11,099 --> 00:00:16,410
already know a lot of value of working

00:00:14,009 --> 00:00:18,359
in a code notebook like our markdown or

00:00:16,410 --> 00:00:19,949
Jupiter and a lot of the values that

00:00:18,359 --> 00:00:22,050
that can bring in terms of literate

00:00:19,949 --> 00:00:25,350
programming where we're combining both

00:00:22,050 --> 00:00:27,840
code and narrative elements of art and

00:00:25,350 --> 00:00:29,900
analysis and creating a wide variety of

00:00:27,840 --> 00:00:32,219
different interesting analytical of

00:00:29,900 --> 00:00:34,920
however the thing I'm particularly

00:00:32,219 --> 00:00:37,710
passionate about about our markdown is

00:00:34,920 --> 00:00:40,280
its ability to be a prototyping engine

00:00:37,710 --> 00:00:42,510
for more sustainable analytical tools I

00:00:40,280 --> 00:00:44,820
contend that any time that you've

00:00:42,510 --> 00:00:47,370
created an analysis in our markdown

00:00:44,820 --> 00:00:49,469
you've actually gone BA on your way to

00:00:47,370 --> 00:00:51,750
creating a really mature analytical

00:00:49,469 --> 00:00:54,449
product that's custom fit for your

00:00:51,750 --> 00:00:56,730
domain specific workflow and what I want

00:00:54,449 --> 00:00:59,640
to talk about today is steps of how to

00:00:56,730 --> 00:01:02,820
turn this latent and implicit tool into

00:00:59,640 --> 00:01:04,799
an explicit one the reason this works is

00:01:02,820 --> 00:01:07,080
by the time you've completed a single

00:01:04,799 --> 00:01:08,970
analysis if you think about it you've

00:01:07,080 --> 00:01:11,400
already done many of the really really

00:01:08,970 --> 00:01:13,650
hard parts of building package for

00:01:11,400 --> 00:01:16,170
example on the design side you've

00:01:13,650 --> 00:01:18,840
understood user requirements crafted a

00:01:16,170 --> 00:01:21,090
same workflow and by virtue of your own

00:01:18,840 --> 00:01:23,610
analysis have a complete and really

00:01:21,090 --> 00:01:25,680
compelling example on the development

00:01:23,610 --> 00:01:27,420
front you've carat created the right

00:01:25,680 --> 00:01:29,250
tools to help you along the way and

00:01:27,420 --> 00:01:31,500
figured out how to make them play nicely

00:01:29,250 --> 00:01:35,460
together and you have working and

00:01:31,500 --> 00:01:38,280
hopefully well tested code so what I

00:01:35,460 --> 00:01:39,869
want to talk about is five main steps to

00:01:38,280 --> 00:01:42,869
what I call our markdown driven

00:01:39,869 --> 00:01:45,450
development for how to take the your

00:01:42,869 --> 00:01:47,520
open data analysis and turn it into a

00:01:45,450 --> 00:01:51,000
product that supports more arrays

00:01:47,520 --> 00:01:53,220
ability and accessible and we'll see as

00:01:51,000 --> 00:01:55,200
I go through this process if this can

00:01:53,220 --> 00:01:57,600
have many different outcomes including a

00:01:55,200 --> 00:02:00,119
single file a project or a package and

00:01:57,600 --> 00:02:03,180
there's no superiority or better or

00:02:00,119 --> 00:02:05,820
worse on this spectrum it simply matters

00:02:03,180 --> 00:02:08,849
how you expect your users to take

00:02:05,820 --> 00:02:09,750
advantage of your work in the future but

00:02:08,849 --> 00:02:12,630
first let's

00:02:09,750 --> 00:02:14,820
start at the beginning the first step to

00:02:12,630 --> 00:02:16,440
refactoring a code notebook is simply to

00:02:14,820 --> 00:02:17,970
remove the elements that you probably

00:02:16,440 --> 00:02:18,870
should have never been there in the

00:02:17,970 --> 00:02:21,450
first place

00:02:18,870 --> 00:02:24,450
this can include things like hard-coded

00:02:21,450 --> 00:02:29,040
variables plaintext passwords local file

00:02:24,450 --> 00:02:31,709
paths and unused pieces of code for

00:02:29,040 --> 00:02:33,959
hard-coded variables one trick I like to

00:02:31,709 --> 00:02:38,100
use in our markdown is converting

00:02:33,959 --> 00:02:39,120
variables into parameters so for example

00:02:38,100 --> 00:02:42,060
if I'm generating a report

00:02:39,120 --> 00:02:44,130
month-over-month I might at some point

00:02:42,060 --> 00:02:46,500
have to filter my data set for specific

00:02:44,130 --> 00:02:48,750
date range but this can be very fragile

00:02:46,500 --> 00:02:50,700
because I might forget to change it or

00:02:48,750 --> 00:02:54,209
change it and consistently throughout my

00:02:50,700 --> 00:02:56,910
document instead I can use parameters to

00:02:54,209 --> 00:02:59,489
turn my whole analysis and my whole our

00:02:56,910 --> 00:03:02,850
markdown script into one mega function

00:02:59,489 --> 00:03:04,500
where I'm highlighting all the variables

00:03:02,850 --> 00:03:07,590
that I might want to change at the

00:03:04,500 --> 00:03:09,540
beginning to promote consistency this is

00:03:07,590 --> 00:03:11,790
also a great way to protect my

00:03:09,540 --> 00:03:14,790
credentials because with parameters I

00:03:11,790 --> 00:03:17,430
can also insert dummy values on its and

00:03:14,790 --> 00:03:20,549
only supplied the real values at runtime

00:03:17,430 --> 00:03:23,760
so I never have to store passwords or

00:03:20,549 --> 00:03:27,540
other API keys or secret material in

00:03:23,760 --> 00:03:29,940
plain text next up we want to remove

00:03:27,540 --> 00:03:31,980
local file paths because this ensures

00:03:29,940 --> 00:03:34,440
that our project will work on no one's

00:03:31,980 --> 00:03:37,110
computer but our own and probably not

00:03:34,440 --> 00:03:40,350
even our own should we ever rearrange or

00:03:37,110 --> 00:03:45,260
reorganize our files one gold standard

00:03:40,350 --> 00:03:47,310
is using a relative file paths reference

00:03:45,260 --> 00:03:50,640
describing the location of your files

00:03:47,310 --> 00:03:52,320
only within the working directory and if

00:03:50,640 --> 00:03:55,350
you use them are in particular you can

00:03:52,320 --> 00:03:57,750
get one step better by using the care

00:03:55,350 --> 00:03:59,700
package which makes file paths that are

00:03:57,750 --> 00:04:02,650
especially resilient across different

00:03:59,700 --> 00:04:04,390
operating systems and platforms

00:04:02,650 --> 00:04:06,489
the final thing we want to remove as

00:04:04,390 --> 00:04:09,189
hard as it can be is sometimes we have

00:04:06,489 --> 00:04:11,230
to kill our darlings no matter how fun

00:04:09,189 --> 00:04:13,090
some of the different rabbit holes we

00:04:11,230 --> 00:04:15,700
may have gone down in our analysis where

00:04:13,090 --> 00:04:17,440
if we have code in our scripts that we

00:04:15,700 --> 00:04:19,359
didn't actually use and doesn't actually

00:04:17,440 --> 00:04:21,549
add to that final analysis you're

00:04:19,359 --> 00:04:25,270
delivering it's probably time to remove

00:04:21,549 --> 00:04:27,970
those and clean things up so once we

00:04:25,270 --> 00:04:30,460
only have what we want in our murk down

00:04:27,970 --> 00:04:33,150
our next step is thinking about where we

00:04:30,460 --> 00:04:35,770
want it to be by rearranging chunks

00:04:33,150 --> 00:04:37,810
narrative and literate programming is

00:04:35,770 --> 00:04:41,020
great at capturing our thought processes

00:04:37,810 --> 00:04:44,169
but thought processes are rarely linear

00:04:41,020 --> 00:04:44,789
and as a result neither is the code that

00:04:44,169 --> 00:04:48,220
we wrote

00:04:44,789 --> 00:04:51,039
so some turistic SIU's to make this

00:04:48,220 --> 00:04:53,560
transition are letting infrastructure

00:04:51,039 --> 00:04:56,229
and heavy lifting computing chunks come

00:04:53,560 --> 00:04:58,840
up to the top of my document and letting

00:04:56,229 --> 00:05:01,090
database data wrangling triplet code

00:04:58,840 --> 00:05:04,120
that makes plots and tables and helps

00:05:01,090 --> 00:05:07,449
communicate sink down to the bottom this

00:05:04,120 --> 00:05:09,970
has multiple benefits first it helps us

00:05:07,449 --> 00:05:12,250
clearly define our dependencies because

00:05:09,970 --> 00:05:15,220
things like reading in data and external

00:05:12,250 --> 00:05:17,919
files and loading in libraries are

00:05:15,220 --> 00:05:19,990
naturally at the top of our scripts this

00:05:17,919 --> 00:05:22,330
code is also since it's doing the most

00:05:19,990 --> 00:05:24,729
of the work the most likely to break and

00:05:22,330 --> 00:05:29,199
it can be nice to front-load our errors

00:05:24,729 --> 00:05:31,090
so if we fail we fail early similarly by

00:05:29,199 --> 00:05:33,190
letting some of the more communication

00:05:31,090 --> 00:05:34,810
pieces sink to the bottom we're more

00:05:33,190 --> 00:05:36,729
likely to notice your pettite of code

00:05:34,810 --> 00:05:39,460
that we're using for processing

00:05:36,729 --> 00:05:42,130
different types of plots and tables and

00:05:39,460 --> 00:05:45,510
analytical views which can help us

00:05:42,130 --> 00:05:48,050
reduce duplication and the next step

00:05:45,510 --> 00:05:50,670
and finally this also helps us to

00:05:48,050 --> 00:05:52,320
consolidate more of the narrative pieces

00:05:50,670 --> 00:05:54,780
of our code so if we're working with

00:05:52,320 --> 00:05:57,510
less technical collaborators it's still

00:05:54,780 --> 00:05:59,490
easy for them to get in and help figure

00:05:57,510 --> 00:06:01,100
out exactly where they need to edit to

00:05:59,490 --> 00:06:04,800
edit your manuscript

00:06:01,100 --> 00:06:07,230
now one exciting thing about doing this

00:06:04,800 --> 00:06:09,060
rearranging is it's also a great way to

00:06:07,230 --> 00:06:13,440
start thinking about adding more of an

00:06:09,060 --> 00:06:15,780
interface aspect to your single file for

00:06:13,440 --> 00:06:18,720
example two tricks you can use with

00:06:15,780 --> 00:06:21,900
within the our Studio IDE are naming

00:06:18,720 --> 00:06:24,210
your code chunks and commenting within a

00:06:21,900 --> 00:06:27,180
code chunk with four little dashes after

00:06:24,210 --> 00:06:28,590
each comment this traits the nice table

00:06:27,180 --> 00:06:30,450
of contents that you can see at the

00:06:28,590 --> 00:06:34,650
bottom of the screen to help users

00:06:30,450 --> 00:06:36,300
easily jump between pieces of your fork

00:06:34,650 --> 00:06:37,560
and find the right places that in the

00:06:36,300 --> 00:06:40,110
script that they need to jump to

00:06:37,560 --> 00:06:42,180
automatically this serves as kind of

00:06:40,110 --> 00:06:44,010
like a great additional incentive for

00:06:42,180 --> 00:06:47,840
the code commenting that we all know

00:06:44,010 --> 00:06:51,630
that we should probably be doing anyway

00:06:47,840 --> 00:06:53,790
so as I mentioned before one benefit of

00:06:51,630 --> 00:06:55,830
that rearranging is we can start to

00:06:53,790 --> 00:06:58,680
better get to know our own code and get

00:06:55,830 --> 00:07:00,720
to find patterns within it and the next

00:06:58,680 --> 00:07:02,790
thing we can do with those patterns is

00:07:00,720 --> 00:07:05,160
reduce a lot of the duplicate code that

00:07:02,790 --> 00:07:08,430
we may have in our code notebook by

00:07:05,160 --> 00:07:10,860
defining functions so on the left hand

00:07:08,430 --> 00:07:13,620
side of this example you might see in

00:07:10,860 --> 00:07:15,210
some exploratory data analysis I might

00:07:13,620 --> 00:07:16,860
have just started making scatter plots

00:07:15,210 --> 00:07:20,010
to understand the relationship between

00:07:16,860 --> 00:07:22,290
different variables however this has a

00:07:20,010 --> 00:07:24,660
couple of problems if I want to say

00:07:22,290 --> 00:07:27,780
change the point size I'd have to go in

00:07:24,660 --> 00:07:30,030
and change multiple pieces of hope also

00:07:27,780 --> 00:07:32,220
it's not very literate and that my

00:07:30,030 --> 00:07:35,040
intent in what I'm doing isn't totally

00:07:32,220 --> 00:07:37,440
clear on the right hand side instead I

00:07:35,040 --> 00:07:40,560
define a single scatter plot function

00:07:37,440 --> 00:07:42,630
and call it three times now I could only

00:07:40,560 --> 00:07:45,030
change my code one place if I needed to

00:07:42,630 --> 00:07:47,700
for my own use it'd be easier for a

00:07:45,030 --> 00:07:49,020
collaborator to borrow that function to

00:07:47,700 --> 00:07:52,290
use for a different purpose if they

00:07:49,020 --> 00:07:54,780
wanted to and even better in vick's

00:07:52,290 --> 00:07:56,670
Florrie data analysis section you can

00:07:54,780 --> 00:07:58,470
really read and infer my intent very

00:07:56,670 --> 00:08:00,250
clearly that I'm trying to make those

00:07:58,470 --> 00:08:03,409
three scattered

00:08:00,250 --> 00:08:05,479
again returning to the concept of how we

00:08:03,409 --> 00:08:08,389
are building more of a user interface

00:08:05,479 --> 00:08:11,180
for our tool we can then think about

00:08:08,389 --> 00:08:13,219
commenting and documenting our functions

00:08:11,180 --> 00:08:15,469
even within the single our markdown

00:08:13,219 --> 00:08:18,110
script in the same way you would for in

00:08:15,469 --> 00:08:20,810
our package so as you can see in this

00:08:18,110 --> 00:08:23,060
example we can use the our oxygen

00:08:20,810 --> 00:08:24,860
package to create a code documenting

00:08:23,060 --> 00:08:27,469
skeleton similar to what you'd use

00:08:24,860 --> 00:08:29,840
inside of a package to define each

00:08:27,469 --> 00:08:32,089
expected input and output of our

00:08:29,840 --> 00:08:34,219
function since this is the type of

00:08:32,089 --> 00:08:36,979
documentation that our users are very

00:08:34,219 --> 00:08:39,079
very used to looking at this can go a

00:08:36,979 --> 00:08:44,360
long way into helping them learn and

00:08:39,079 --> 00:08:46,790
engage with pieces of your code so at

00:08:44,360 --> 00:08:48,769
this point we've gotten to relatively

00:08:46,790 --> 00:08:50,570
clean code and we can start also

00:08:48,769 --> 00:08:52,430
thinking about code style and

00:08:50,570 --> 00:08:55,040
navigability and they're great tools for

00:08:52,430 --> 00:08:58,010
this in our including the linter and

00:08:55,040 --> 00:09:00,589
styler packages which can help you check

00:08:58,010 --> 00:09:04,250
your code against a configurable style

00:09:00,589 --> 00:09:06,440
guide and either call out violations of

00:09:04,250 --> 00:09:09,230
that style guide as you see on the right

00:09:06,440 --> 00:09:11,630
hand side or in the case of the styler

00:09:09,230 --> 00:09:14,910
package actually even go ahead and fix

00:09:11,630 --> 00:09:17,430
those code style issues on your path

00:09:14,910 --> 00:09:19,830
and besides code style there's also

00:09:17,430 --> 00:09:22,140
writing style to think about and for

00:09:19,830 --> 00:09:24,480
that we can use this phone package to

00:09:22,140 --> 00:09:27,300
help catch typos in the narrative pieces

00:09:24,480 --> 00:09:30,210
of our code our report just to keep

00:09:27,300 --> 00:09:33,840
things as absolutely clean and polished

00:09:30,210 --> 00:09:36,120
as possible so at the stage of our

00:09:33,840 --> 00:09:38,250
markdown driven development we're we've

00:09:36,120 --> 00:09:41,750
still only work in one single file and

00:09:38,250 --> 00:09:45,270
we have a very sustainable while

00:09:41,750 --> 00:09:47,130
volunteered file and it's some for some

00:09:45,270 --> 00:09:49,740
use cases this may actually be the

00:09:47,130 --> 00:09:52,290
perfect place to stop if you're in a low

00:09:49,740 --> 00:09:55,170
resource environment without a portable

00:09:52,290 --> 00:09:58,380
without a like formal version control

00:09:55,170 --> 00:10:00,450
system or repository single files can be

00:09:58,380 --> 00:10:02,910
the most easy to share between

00:10:00,450 --> 00:10:04,830
collaborators to understand the

00:10:02,910 --> 00:10:07,460
differences between versions by simply

00:10:04,830 --> 00:10:10,770
running a define in the terminal and

00:10:07,460 --> 00:10:13,290
easy to automate wit order fresh with a

00:10:10,770 --> 00:10:16,560
single single click of a button however

00:10:13,290 --> 00:10:18,900
they can sometimes be lengthy and

00:10:16,560 --> 00:10:22,260
somewhat intimidating for new users to

00:10:18,900 --> 00:10:23,430
inherit and enable some anti-patterns

00:10:22,260 --> 00:10:26,670
because they don't give us all to

00:10:23,430 --> 00:10:28,590
flexibility we need so if we're looking

00:10:26,670 --> 00:10:30,930
for something a little more accessible

00:10:28,590 --> 00:10:33,480
we may want to consider breaking a

00:10:30,930 --> 00:10:37,140
parter file into a more robust

00:10:33,480 --> 00:10:40,260
analytical project so the key here is to

00:10:37,140 --> 00:10:41,910
define a standardized file structure and

00:10:40,260 --> 00:10:44,430
think about how we can break out

00:10:41,910 --> 00:10:47,130
different components of our our markdown

00:10:44,430 --> 00:10:49,710
document into different folders in that

00:10:47,130 --> 00:10:52,020
project for example the functions I

00:10:49,710 --> 00:10:55,110
talked about defining core could go in a

00:10:52,020 --> 00:10:57,720
scripts or function folder the David

00:10:55,110 --> 00:11:00,570
data that we're using for our analysis

00:10:57,720 --> 00:11:03,150
could go in a raw data folder and any

00:11:00,570 --> 00:11:05,130
subsequent data artifacts that are being

00:11:03,150 --> 00:11:07,550
created from some of those computation

00:11:05,130 --> 00:11:10,590
chunks can be saved in an output folder

00:11:07,550 --> 00:11:13,890
the analysis as a whole can live in an

00:11:10,590 --> 00:11:16,290
analysis folder and etcetera with other

00:11:13,890 --> 00:11:19,450
types of documentation or external files

00:11:16,290 --> 00:11:21,370
you might collect along the way just

00:11:19,450 --> 00:11:24,100
a slightly more technical view of this

00:11:21,370 --> 00:11:26,020
we can return to the exploratory data

00:11:24,100 --> 00:11:28,570
analysis example that I talked about

00:11:26,020 --> 00:11:30,850
before so instead of using different

00:11:28,570 --> 00:11:33,220
chunks to define my function and then

00:11:30,850 --> 00:11:35,740
call it I can actually save that

00:11:33,220 --> 00:11:39,130
function definition in a separate our

00:11:35,740 --> 00:11:42,010
script and simply reference that and I

00:11:39,130 --> 00:11:46,750
asked arch will execute that code for me

00:11:42,010 --> 00:11:50,650
by using the source function as shown at

00:11:46,750 --> 00:11:52,660
the top of the right hand side one place

00:11:50,650 --> 00:11:56,230
I particularly like to use this trick

00:11:52,660 --> 00:11:59,920
myself is when working with data instead

00:11:56,230 --> 00:12:02,500
of directly having databases in queries

00:11:59,920 --> 00:12:05,020
or API is being called from my our

00:12:02,500 --> 00:12:07,360
markdown document we can have a script

00:12:05,020 --> 00:12:10,150
that reads data from a database and

00:12:07,360 --> 00:12:12,040
saves it to raw data folder and another

00:12:10,150 --> 00:12:13,990
script that reads in that data and

00:12:12,040 --> 00:12:16,900
doesn't some of those like wrangling

00:12:13,990 --> 00:12:19,240
model fitting and Alice pieces and saves

00:12:16,900 --> 00:12:21,390
those intermediate data artifacts and we

00:12:19,240 --> 00:12:25,440
only read those into the our markdown

00:12:21,390 --> 00:12:28,180
this is very beneficial because I it

00:12:25,440 --> 00:12:30,490
eliminates the direct link and the drug

00:12:28,180 --> 00:12:32,830
dependency between some of those data

00:12:30,490 --> 00:12:33,550
stores that we don't necessarily have

00:12:32,830 --> 00:12:36,760
control over

00:12:33,550 --> 00:12:38,860
and our final our markdown report so for

00:12:36,760 --> 00:12:41,890
example if I find a typo in my our

00:12:38,860 --> 00:12:44,320
markdown I can refresh and rerun that

00:12:41,890 --> 00:12:47,080
document without having to worry about

00:12:44,320 --> 00:12:50,890
if my database or my API is currently

00:12:47,080 --> 00:12:52,360
online and accessible again at the

00:12:50,890 --> 00:12:54,430
project stage there are a lot more

00:12:52,360 --> 00:12:57,070
optimizations that we can put into play

00:12:54,430 --> 00:12:59,620
I've talked about this concept of having

00:12:57,070 --> 00:13:02,350
an interface and defining that standard

00:12:59,620 --> 00:13:04,390
file structure in an organizational

00:13:02,350 --> 00:13:06,730
setting can have really huge benefits

00:13:04,390 --> 00:13:08,800
because different collaborators as they

00:13:06,730 --> 00:13:11,200
move between different projects can

00:13:08,800 --> 00:13:13,690
easily have an intuitive sense of where

00:13:11,200 --> 00:13:16,060
to navigate in a project to find certain

00:13:13,690 --> 00:13:20,850
types of material again like data sets

00:13:16,060 --> 00:13:20,850
or function definitions and there many

00:13:22,430 --> 00:13:27,959
and there are many great art packages to

00:13:25,260 --> 00:13:30,740
help you do this such as use this

00:13:27,959 --> 00:13:33,779
project template and starters and

00:13:30,740 --> 00:13:35,910
similarly for dependency management it's

00:13:33,779 --> 00:13:39,990
a great time to think about adding in

00:13:35,910 --> 00:13:42,480
the RMF package so some benefits that

00:13:39,990 --> 00:13:46,740
we've achieved by taking this extra step

00:13:42,480 --> 00:13:48,570
are making our project a lot more

00:13:46,740 --> 00:13:51,060
flexible and more extensible to

00:13:48,570 --> 00:13:53,730
different use cases and easier to steal

00:13:51,060 --> 00:13:56,370
and borrow small components of like a

00:13:53,730 --> 00:13:59,070
single function for other use however at

00:13:56,370 --> 00:14:01,680
the same time in this approach we've

00:13:59,070 --> 00:14:06,089
still captured a lot of the initial

00:14:01,680 --> 00:14:09,600
context of our analysis but

00:14:06,089 --> 00:14:11,490
and are really still focusing on the one

00:14:09,600 --> 00:14:14,339
specific instance of a problem that we

00:14:11,490 --> 00:14:16,579
were thinking about however this can

00:14:14,339 --> 00:14:19,040
sometimes muddy the line between

00:14:16,579 --> 00:14:21,990
analysis and general purpose code and

00:14:19,040 --> 00:14:25,019
make it hard to fully extend or

00:14:21,990 --> 00:14:27,689
generalize our work and we haven't fully

00:14:25,019 --> 00:14:30,839
take advantage of our all VARs developer

00:14:27,689 --> 00:14:32,999
tools if these are concerns we can think

00:14:30,839 --> 00:14:36,300
about taking the final step of turning

00:14:32,999 --> 00:14:38,819
our project into a package and the magic

00:14:36,300 --> 00:14:42,120
of our packages is it's really as simple

00:14:38,819 --> 00:14:44,459
as saving files in the right place so

00:14:42,120 --> 00:14:45,959
for example our scripts folder those

00:14:44,459 --> 00:14:49,079
functions could move into an arc

00:14:45,959 --> 00:14:51,689
function folder our initial our markdown

00:14:49,079 --> 00:14:53,519
itself can serve multiple purposes both

00:14:51,689 --> 00:14:55,769
as a template embedded in the package

00:14:53,519 --> 00:14:57,990
that helps interactively walk users

00:14:55,769 --> 00:15:00,720
through the code as well as the vignette

00:14:57,990 --> 00:15:02,699
but as at a high level excites users

00:15:00,720 --> 00:15:04,319
about learning your package by giving

00:15:02,699 --> 00:15:07,410
them a really interesting and enticing

00:15:04,319 --> 00:15:10,769
example similarly even the data that we

00:15:07,410 --> 00:15:12,749
used along the way if it's properly

00:15:10,769 --> 00:15:15,959
protected and anonymized could go into

00:15:12,749 --> 00:15:19,110
the package as example data all that's

00:15:15,959 --> 00:15:21,179
missing is documentation which if you're

00:15:19,110 --> 00:15:24,540
call we actually already wrote a few

00:15:21,179 --> 00:15:26,279
steps though and unit tests which we

00:15:24,540 --> 00:15:29,040
probably should have actually talked

00:15:26,279 --> 00:15:31,139
about far earlier in the process if we

00:15:29,040 --> 00:15:33,389
want to actually trust any of our

00:15:31,139 --> 00:15:36,240
analysis even when it's in a single file

00:15:33,389 --> 00:15:38,519
and again there are many great our

00:15:36,240 --> 00:15:41,279
packages to help you do these last few

00:15:38,519 --> 00:15:43,559
steps use this can help make sure you

00:15:41,279 --> 00:15:45,689
get all those project assets into the

00:15:43,559 --> 00:15:48,059
right folders dev tools can help

00:15:45,689 --> 00:15:50,370
automate automatically document the

00:15:48,059 --> 00:15:52,499
documentation in your man folder from

00:15:50,370 --> 00:15:55,679
the our oxygen comments we discussed

00:15:52,499 --> 00:15:59,220
tests that provides a very friendly user

00:15:55,679 --> 00:16:01,290
interface for writing tests and with

00:15:59,220 --> 00:16:03,179
package down you can even go one step

00:16:01,290 --> 00:16:05,699
further and create a very user-friendly

00:16:03,179 --> 00:16:08,370
and navigable website to help other

00:16:05,699 --> 00:16:12,029
people learn how to use your analytical

00:16:08,370 --> 00:16:13,920
product so now we've really completed

00:16:12,029 --> 00:16:16,980
the spectrum of different types of

00:16:13,920 --> 00:16:19,550
outputs packages of course are the sort

00:16:16,980 --> 00:16:21,980
of like formal mechanism for distributed

00:16:19,550 --> 00:16:24,080
code and jewels at scale and it's

00:16:21,980 --> 00:16:27,470
something other coding users are really

00:16:24,080 --> 00:16:30,620
similar nning how to learn so those are

00:16:27,470 --> 00:16:33,140
some great advantages however we've now

00:16:30,620 --> 00:16:35,420
looks abstracted very far away from your

00:16:33,140 --> 00:16:38,420
specific analysis to a very general

00:16:35,420 --> 00:16:41,000
class of problems which sometimes can be

00:16:38,420 --> 00:16:43,459
great but sometimes may actually be a

00:16:41,000 --> 00:16:45,620
bridge too far if you're you think

00:16:43,459 --> 00:16:47,779
future users will be more focused on

00:16:45,620 --> 00:16:50,720
reproducing your work than extending it

00:16:47,779 --> 00:16:53,540
at the end of the day you may have

00:16:50,720 --> 00:16:55,700
different goals but regardless of what

00:16:53,540 --> 00:16:57,829
that is following the steps of our

00:16:55,700 --> 00:16:59,930
markdown driven development can help you

00:16:57,829 --> 00:17:02,930
get a lot closer to making a sustainable

00:16:59,930 --> 00:17:05,839
and empathetic data product both for

00:17:02,930 --> 00:17:08,929
yourself and for anyone who wants to use

00:17:05,839 --> 00:17:09,650
it in the future and benefit from all of

00:17:08,929 --> 00:17:12,260
your labor

00:17:09,650 --> 00:17:14,780
so thank you very much for your time

00:17:12,260 --> 00:17:17,480
today I'm happy to take questions on

00:17:14,780 --> 00:17:19,429
slack and I'd also mentioned I have two

00:17:17,480 --> 00:17:22,160
blog posts up on this topic if you're

00:17:19,429 --> 00:17:24,169
interested in learning more and finally

00:17:22,160 --> 00:17:27,199
thank you so much to the organizers of

00:17:24,169 --> 00:17:28,580
ESP comp this has been a phenomenal

00:17:27,199 --> 00:17:30,830
experience and a great conference

00:17:28,580 --> 00:17:36,050
despite all of the challenges of going

00:17:30,830 --> 00:17:38,380
virtual thank you very much thank you so

00:17:36,050 --> 00:17:38,380

YouTube URL: https://www.youtube.com/watch?v=Z9qk5YnuBQM


