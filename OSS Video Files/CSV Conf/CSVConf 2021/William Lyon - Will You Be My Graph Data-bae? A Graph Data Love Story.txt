Title: William Lyon - Will You Be My Graph Data-bae? A Graph Data Love Story
Publication date: 2021-05-20
Playlist: CSVConf 2021
Description: 
	This talk tells the story of two technologies that were always meant to be together but came from different worlds, yet finally were able to come together and help the world make sense of data through APIs: GraphQL and graph databases. We'll discuss graph databases like Neo4j - what they are, why and how to use them, as well as the tradeoffs of building applications with graph databases. We'll review GraphQL and how to build GraphQL APIs. Then we'll see how GraphQL and Neo4j are even more powerful when used together, each leveraging features of the other (the property graph data model, a strict type system, index-free adjacency, extensibility through schema directives, and the Cypher query language) - resulting in a truly symbiotic and mutually beneficial relationship.
Captions: 
	00:00:03,520 --> 00:00:08,639
great

00:00:04,799 --> 00:00:12,559
hey everyone um my slides are available

00:00:08,639 --> 00:00:16,080
at this link bitly graphql

00:00:12,559 --> 00:00:19,039
csv conf in in this talk

00:00:16,080 --> 00:00:20,720
i really want to talk about two open

00:00:19,039 --> 00:00:22,720
source technologies that

00:00:20,720 --> 00:00:23,760
i think are each on their own really

00:00:22,720 --> 00:00:26,240
interesting but

00:00:23,760 --> 00:00:26,800
when they're used together become sort

00:00:26,240 --> 00:00:29,119
of this

00:00:26,800 --> 00:00:30,320
super power uh combination of

00:00:29,119 --> 00:00:33,600
technologies and that

00:00:30,320 --> 00:00:37,680
is graphql and the

00:00:33,600 --> 00:00:37,680
neo4j graph database

00:00:40,239 --> 00:00:46,640
and so my name is will i work at

00:00:43,360 --> 00:00:48,800
neo4j on the developer relations team on

00:00:46,640 --> 00:00:49,680
a team we call neo4j labs which works on

00:00:48,800 --> 00:00:52,160
building

00:00:49,680 --> 00:00:53,120
extensions and integrations with neo4j

00:00:52,160 --> 00:00:56,960
another tooling

00:00:53,120 --> 00:01:00,160
that's my twitter handle there and

00:00:56,960 --> 00:01:01,600
my personal website i read a newsletter

00:01:00,160 --> 00:01:04,239
and an occasional blog post

00:01:01,600 --> 00:01:04,640
uh if you're interested in digging in to

00:01:04,239 --> 00:01:07,680
more

00:01:04,640 --> 00:01:08,880
there so these two technologies that i

00:01:07,680 --> 00:01:12,080
want to talk about

00:01:08,880 --> 00:01:15,360
one is neo4j which is a

00:01:12,080 --> 00:01:17,600
graph database so similar to other

00:01:15,360 --> 00:01:20,080
database management systems you might be

00:01:17,600 --> 00:01:24,240
familiar with but instead of working

00:01:20,080 --> 00:01:26,880
with a table or document data model

00:01:24,240 --> 00:01:28,080
we're working with graphs so nodes these

00:01:26,880 --> 00:01:30,640
are the entities

00:01:28,080 --> 00:01:32,079
in the data model and relationships

00:01:30,640 --> 00:01:34,079
connect them

00:01:32,079 --> 00:01:35,439
we call this the the property graph data

00:01:34,079 --> 00:01:38,400
model because we can store

00:01:35,439 --> 00:01:40,000
arbitrary key value pair properties on

00:01:38,400 --> 00:01:43,600
nodes and relationships those are the

00:01:40,000 --> 00:01:45,840
attributes in our data with neo4j we use

00:01:43,600 --> 00:01:46,880
a query language called cipher which you

00:01:45,840 --> 00:01:50,159
can think of as

00:01:46,880 --> 00:01:52,000
kind of like sql but for graphs

00:01:50,159 --> 00:01:53,680
which we'll take a look at some examples

00:01:52,000 --> 00:01:56,640
in a minute

00:01:53,680 --> 00:01:57,439
and then there are lots of different use

00:01:56,640 --> 00:02:01,040
cases

00:01:57,439 --> 00:02:04,240
for graph databases and neo4j from the

00:02:01,040 --> 00:02:05,520
transactional building a web or mobile

00:02:04,240 --> 00:02:08,080
application

00:02:05,520 --> 00:02:10,319
to things like graph analytics graph

00:02:08,080 --> 00:02:11,680
algorithms data visualization

00:02:10,319 --> 00:02:13,200
and these sorts of things but

00:02:11,680 --> 00:02:14,400
fundamentally graph databases are

00:02:13,200 --> 00:02:16,959
optimized

00:02:14,400 --> 00:02:18,480
in a different way from other databases

00:02:16,959 --> 00:02:20,720
like relational databases or document

00:02:18,480 --> 00:02:21,280
databases graph databases are optimized

00:02:20,720 --> 00:02:23,840
for

00:02:21,280 --> 00:02:25,680
traversing the graph so going from one

00:02:23,840 --> 00:02:28,080
node traversing to

00:02:25,680 --> 00:02:28,720
all other nodes that i'm connected to

00:02:28,080 --> 00:02:31,440
very

00:02:28,720 --> 00:02:32,959
quickly and efficiently the other

00:02:31,440 --> 00:02:36,800
technology we're going to talk about is

00:02:32,959 --> 00:02:38,720
graphql which is an api

00:02:36,800 --> 00:02:40,160
query language that allows us to

00:02:38,720 --> 00:02:43,360
describe

00:02:40,160 --> 00:02:44,160
the type of data that's available in the

00:02:43,360 --> 00:02:47,680
api

00:02:44,160 --> 00:02:50,319
and then presents this data as a graph

00:02:47,680 --> 00:02:51,840
to the client who can then sort of

00:02:50,319 --> 00:02:53,760
arbitrarily describe

00:02:51,840 --> 00:02:55,840
a traversal through the data graph and

00:02:53,760 --> 00:02:57,280
what fields to come back so it's

00:02:55,840 --> 00:03:01,440
important to point out that

00:02:57,280 --> 00:03:02,400
graphql is data layer agnostic so while

00:03:01,440 --> 00:03:04,400
it's presenting

00:03:02,400 --> 00:03:06,319
a graph data model to the client

00:03:04,400 --> 00:03:09,440
modeling application data as a graph

00:03:06,319 --> 00:03:12,159
on the back end we can fetch data from

00:03:09,440 --> 00:03:12,720
really any system and we can even wrap

00:03:12,159 --> 00:03:16,879
other

00:03:12,720 --> 00:03:20,159
apis and other databases

00:03:16,879 --> 00:03:21,519
so these seem like two somewhat

00:03:20,159 --> 00:03:24,400
complementary technologies

00:03:21,519 --> 00:03:25,120
they're both sort of working with graphs

00:03:24,400 --> 00:03:28,000
but

00:03:25,120 --> 00:03:28,640
in a different way when we combine these

00:03:28,000 --> 00:03:31,040
together

00:03:28,640 --> 00:03:32,560
and when we talk about building graphql

00:03:31,040 --> 00:03:34,640
apis that are backed by

00:03:32,560 --> 00:03:36,319
a graph database we have all these

00:03:34,640 --> 00:03:39,120
benefits that start to emerge so

00:03:36,319 --> 00:03:39,840
type safety is a really important one so

00:03:39,120 --> 00:03:43,280
i can use

00:03:39,840 --> 00:03:45,440
the graphql schema to define the

00:03:43,280 --> 00:03:48,959
database schema and i have sort of one

00:03:45,440 --> 00:03:50,640
unified graph data layer to think about

00:03:48,959 --> 00:03:52,159
and really have sort of graphs all the

00:03:50,640 --> 00:03:54,000
way down through

00:03:52,159 --> 00:03:55,599
through the stack as i'm working with

00:03:54,000 --> 00:03:58,400
data

00:03:55,599 --> 00:03:59,200
we were really interested early on so

00:03:58,400 --> 00:04:01,760
graphql

00:03:59,200 --> 00:04:05,040
was used internally at facebook for a

00:04:01,760 --> 00:04:07,920
while and then open sourced in in 2015

00:04:05,040 --> 00:04:08,640
and we're really interested to see if we

00:04:07,920 --> 00:04:12,080
could build

00:04:08,640 --> 00:04:12,799
some graphql neo4j integrations to make

00:04:12,080 --> 00:04:15,360
it easier

00:04:12,799 --> 00:04:16,400
to build graphql apis using a graph

00:04:15,360 --> 00:04:18,479
database

00:04:16,400 --> 00:04:19,840
and sort of some of the things we

00:04:18,479 --> 00:04:21,919
learned from that

00:04:19,840 --> 00:04:23,520
is what i'll talk about next but really

00:04:21,919 --> 00:04:24,560
quickly i think it would be interesting

00:04:23,520 --> 00:04:28,240
to take a look

00:04:24,560 --> 00:04:32,320
at a neo4j example

00:04:28,240 --> 00:04:35,360
so this is neo4j browser which is like a

00:04:32,320 --> 00:04:38,800
query workbench uh for neo4j

00:04:35,360 --> 00:04:41,680
and i have some data loaded

00:04:38,800 --> 00:04:43,759
so i'm going to run a query here to show

00:04:41,680 --> 00:04:44,960
our data model so we have some data

00:04:43,759 --> 00:04:47,520
about

00:04:44,960 --> 00:04:48,800
businesses that are in categories we

00:04:47,520 --> 00:04:50,720
have users

00:04:48,800 --> 00:04:52,479
that have written reviews of these

00:04:50,720 --> 00:04:56,160
businesses

00:04:52,479 --> 00:04:59,280
and here's a cipher example

00:04:56,160 --> 00:05:03,120
so here i'm saying find a

00:04:59,280 --> 00:05:06,080
user node where the name

00:05:03,120 --> 00:05:08,080
is will so the cipher is all about

00:05:06,080 --> 00:05:08,639
pattern matching so we draw these sort

00:05:08,080 --> 00:05:12,080
of

00:05:08,639 --> 00:05:14,800
ascii art representations of a graph

00:05:12,080 --> 00:05:15,520
pattern the nodes or the parentheses are

00:05:14,800 --> 00:05:18,960
sort of

00:05:15,520 --> 00:05:21,600
defining a node and then we're saying

00:05:18,960 --> 00:05:23,199
match and return to find where this

00:05:21,600 --> 00:05:24,080
pattern exists in the graph and so we

00:05:23,199 --> 00:05:26,240
get back

00:05:24,080 --> 00:05:27,440
this user node with the name will and i

00:05:26,240 --> 00:05:29,440
can sort of

00:05:27,440 --> 00:05:32,080
traverse through the graph to see that

00:05:29,440 --> 00:05:35,039
oh yeah this user wrote a review

00:05:32,080 --> 00:05:36,800
of a business in these categories your

00:05:35,039 --> 00:05:39,360
other reviews and so on

00:05:36,800 --> 00:05:43,440
so i can explore that data visually or i

00:05:39,360 --> 00:05:48,160
can express more complex graph patterns

00:05:43,440 --> 00:05:51,120
in cipher so you can see how i can

00:05:48,160 --> 00:05:52,080
string together these patterns to again

00:05:51,120 --> 00:05:55,680
using this sort of

00:05:52,080 --> 00:05:57,120
ascii art notation i'm saying find a

00:05:55,680 --> 00:05:59,919
user node

00:05:57,120 --> 00:06:01,360
with an outgoing rote relationship to a

00:05:59,919 --> 00:06:04,080
review node

00:06:01,360 --> 00:06:05,199
and then what business is that review

00:06:04,080 --> 00:06:07,600
connected to

00:06:05,199 --> 00:06:08,880
and return that piece of the graph so

00:06:07,600 --> 00:06:12,000
here i have a

00:06:08,880 --> 00:06:15,280
subgraph based on this pattern

00:06:12,000 --> 00:06:16,720
that i've defined that i'm looking for

00:06:15,280 --> 00:06:20,080
and this is really powerful when you

00:06:16,720 --> 00:06:22,479
start looking at

00:06:20,080 --> 00:06:24,720
questions that can be answered through a

00:06:22,479 --> 00:06:27,440
traversal through the graph so here

00:06:24,720 --> 00:06:28,800
this is a business recommendation query

00:06:27,440 --> 00:06:30,880
where i'm saying

00:06:28,800 --> 00:06:32,240
for this user named will find all the

00:06:30,880 --> 00:06:34,000
businesses that he reviewed what

00:06:32,240 --> 00:06:36,080
category are they in

00:06:34,000 --> 00:06:37,440
and then find other businesses in the

00:06:36,080 --> 00:06:39,280
same categories

00:06:37,440 --> 00:06:41,120
that he hasn't already reviewed those

00:06:39,280 --> 00:06:44,240
may be good recommendations

00:06:41,120 --> 00:06:44,720
for him so adding some personalization

00:06:44,240 --> 00:06:48,000
by

00:06:44,720 --> 00:06:50,479
traversing the graph

00:06:48,000 --> 00:06:52,400
so that's a quick look at cipher just to

00:06:50,479 --> 00:06:54,319
to give you an idea of

00:06:52,400 --> 00:06:55,520
what that looks like and and how we work

00:06:54,319 --> 00:06:59,039
with that in

00:06:55,520 --> 00:07:01,919
neo4j here's just kind of a snippet

00:06:59,039 --> 00:07:03,520
using the javascript driver for neo4j so

00:07:01,919 --> 00:07:05,680
if i'm building an application

00:07:03,520 --> 00:07:07,199
and i want to expose some of this data

00:07:05,680 --> 00:07:10,479
i'm kind of hard coding

00:07:07,199 --> 00:07:12,240
a cipher query here and then i have some

00:07:10,479 --> 00:07:14,319
boilerplate code for sending that off to

00:07:12,240 --> 00:07:18,479
the database and then working

00:07:14,319 --> 00:07:21,599
with the results but exposing this data

00:07:18,479 --> 00:07:23,120
uh directly to an application

00:07:21,599 --> 00:07:24,720
or if i want to share some of this data

00:07:23,120 --> 00:07:26,720
i don't want to just sort of

00:07:24,720 --> 00:07:30,000
expose my database i want to build some

00:07:26,720 --> 00:07:31,759
sort of api layer that sits between

00:07:30,000 --> 00:07:33,520
the client whether that's someone

00:07:31,759 --> 00:07:35,199
looking at analyzing the data or

00:07:33,520 --> 00:07:37,280
i'm building an application i want some

00:07:35,199 --> 00:07:39,120
api layer between

00:07:37,280 --> 00:07:40,400
the client and the database and this is

00:07:39,120 --> 00:07:42,880
where graphql

00:07:40,400 --> 00:07:44,720
comes in so we said that graphql is this

00:07:42,880 --> 00:07:47,840
api query language

00:07:44,720 --> 00:07:49,520
that allows us to define the shape of

00:07:47,840 --> 00:07:50,479
the data the schema of the data in the

00:07:49,520 --> 00:07:53,039
api

00:07:50,479 --> 00:07:55,039
and then allows the client to

00:07:53,039 --> 00:07:56,720
arbitrarily express

00:07:55,039 --> 00:07:58,960
traversals to the data graph and what

00:07:56,720 --> 00:08:03,680
data the client wants to come back

00:07:58,960 --> 00:08:07,199
at query time so let's take a look at

00:08:03,680 --> 00:08:10,879
querying with graphql now so this

00:08:07,199 --> 00:08:15,199
is a tool called graphql playgrounds

00:08:10,879 --> 00:08:17,840
and this is a example graphql api that

00:08:15,199 --> 00:08:19,680
that is out there with data on movies

00:08:17,840 --> 00:08:23,039
and

00:08:19,680 --> 00:08:25,919
actors and reviews of movies

00:08:23,039 --> 00:08:26,960
so one thing that is really neat about

00:08:25,919 --> 00:08:29,039
graphql

00:08:26,960 --> 00:08:30,000
and a lot of the tooling that's built

00:08:29,039 --> 00:08:32,560
around it

00:08:30,000 --> 00:08:34,000
that's powered by this feature called

00:08:32,560 --> 00:08:37,200
introspection

00:08:34,000 --> 00:08:39,919
so i can ask a graphql api

00:08:37,200 --> 00:08:40,800
to tell me what data is available in the

00:08:39,919 --> 00:08:44,000
api

00:08:40,800 --> 00:08:45,200
and explore the entry points and sort of

00:08:44,000 --> 00:08:48,240
see what fields

00:08:45,200 --> 00:08:48,880
are available so in graphql the entry

00:08:48,240 --> 00:08:51,760
points for

00:08:48,880 --> 00:08:53,680
the api are they're queries which are

00:08:51,760 --> 00:08:56,240
typically read operations

00:08:53,680 --> 00:08:58,560
or mutations which are typically write

00:08:56,240 --> 00:09:01,760
operations and so i can see

00:08:58,560 --> 00:09:05,200
just by this introspection

00:09:01,760 --> 00:09:09,360
feature all of the entry points

00:09:05,200 --> 00:09:11,760
the types and how that data is connected

00:09:09,360 --> 00:09:12,560
and then i can write queries here so

00:09:11,760 --> 00:09:15,279
here i'm

00:09:12,560 --> 00:09:16,080
searching for movies where the title

00:09:15,279 --> 00:09:18,480
contains

00:09:16,080 --> 00:09:20,959
river runs through it and then i want

00:09:18,480 --> 00:09:24,320
the title plot and all of the actors

00:09:20,959 --> 00:09:28,880
in that movie but i can then

00:09:24,320 --> 00:09:28,880
also express more complex

00:09:29,680 --> 00:09:36,160
queries so also for all these actors

00:09:33,360 --> 00:09:36,800
tell me all of the movies that they've

00:09:36,160 --> 00:09:39,279
acted in

00:09:36,800 --> 00:09:40,160
as well and so i'm traversing the graph

00:09:39,279 --> 00:09:43,839
if i don't

00:09:40,160 --> 00:09:44,880
i don't want the plot field to come back

00:09:43,839 --> 00:09:46,720
maybe that's

00:09:44,880 --> 00:09:48,480
computationally expensive to compute on

00:09:46,720 --> 00:09:50,480
the back end i don't need it

00:09:48,480 --> 00:09:51,839
in my application or analyzing the data

00:09:50,480 --> 00:09:54,640
i can remove that

00:09:51,839 --> 00:09:57,279
and i don't have to send that data back

00:09:54,640 --> 00:09:57,279
to the client

00:09:57,360 --> 00:10:04,240
so that's that's a quick look at

00:10:00,399 --> 00:10:05,519
graphql let's take a look at a example

00:10:04,240 --> 00:10:08,640
application

00:10:05,519 --> 00:10:11,040
uh using graphql so this is

00:10:08,640 --> 00:10:12,079
an example from a podcast application

00:10:11,040 --> 00:10:16,640
that i've been building

00:10:12,079 --> 00:10:18,800
on on a live stream called grandcast.fm

00:10:16,640 --> 00:10:20,480
that just links to the github repo for

00:10:18,800 --> 00:10:21,600
this if you want to see the code you can

00:10:20,480 --> 00:10:23,920
find that there

00:10:21,600 --> 00:10:26,000
and there's basically three views to

00:10:23,920 --> 00:10:27,519
this podcast application

00:10:26,000 --> 00:10:29,120
search where i want to search for

00:10:27,519 --> 00:10:31,120
podcasts by

00:10:29,120 --> 00:10:32,560
title or some keyword something like

00:10:31,120 --> 00:10:35,279
that a feed

00:10:32,560 --> 00:10:35,680
that is personalized for the signed in

00:10:35,279 --> 00:10:37,920
user

00:10:35,680 --> 00:10:39,440
so for all of the podcasts that they

00:10:37,920 --> 00:10:41,040
subscribe to these are the most recent

00:10:39,440 --> 00:10:42,079
episodes they can add those to a

00:10:41,040 --> 00:10:45,279
playlist

00:10:42,079 --> 00:10:48,399
play them whatever and then the episode

00:10:45,279 --> 00:10:50,880
view which is showing me details for

00:10:48,399 --> 00:10:51,680
a particular podcast and i can listen to

00:10:50,880 --> 00:10:54,720
it

00:10:51,680 --> 00:10:56,959
add it to the playlist and so on and

00:10:54,720 --> 00:11:00,560
each one of these views

00:10:56,959 --> 00:11:01,120
the data it comes from a graphql query

00:11:00,560 --> 00:11:05,360
so

00:11:01,120 --> 00:11:08,320
we can co-locate the data fetching logic

00:11:05,360 --> 00:11:10,079
with our view in our application so it's

00:11:08,320 --> 00:11:12,560
sort of component-based

00:11:10,079 --> 00:11:15,120
data fetching logic which is quite nice

00:11:12,560 --> 00:11:16,000
so each one of these views has a graphql

00:11:15,120 --> 00:11:17,600
query

00:11:16,000 --> 00:11:19,279
associated with it each one of these

00:11:17,600 --> 00:11:21,920
hitting a different endpoint

00:11:19,279 --> 00:11:24,720
different entry points rather for

00:11:21,920 --> 00:11:26,160
podcast search i'm passing a search term

00:11:24,720 --> 00:11:28,480
for the episode feed i have different

00:11:26,160 --> 00:11:32,000
ways to order that and then for

00:11:28,480 --> 00:11:33,760
the episode view i have a id of a

00:11:32,000 --> 00:11:37,680
particular episode that i'm

00:11:33,760 --> 00:11:38,240
looking up by id and the data that comes

00:11:37,680 --> 00:11:41,279
back

00:11:38,240 --> 00:11:43,519
comes back to our application in json

00:11:41,279 --> 00:11:44,640
and the shape of that json exactly

00:11:43,519 --> 00:11:48,079
matches the

00:11:44,640 --> 00:11:51,120
graphql query so the fields that i have

00:11:48,079 --> 00:11:53,440
requested show up in that json response

00:11:51,120 --> 00:11:56,399
and i can then use that data to populate

00:11:53,440 --> 00:11:58,320
the view in my application

00:11:56,399 --> 00:11:59,760
now as far as where that data comes from

00:11:58,320 --> 00:12:02,000
in this application

00:11:59,760 --> 00:12:03,519
well for the search endpoint that is

00:12:02,000 --> 00:12:07,040
actually just wrapping

00:12:03,519 --> 00:12:08,480
a rest api uh called the podcast index

00:12:07,040 --> 00:12:10,160
so we're actually just searching another

00:12:08,480 --> 00:12:13,120
api and just

00:12:10,160 --> 00:12:14,320
passing that data through but for the

00:12:13,120 --> 00:12:17,600
feed

00:12:14,320 --> 00:12:19,200
view we're looking up the current user

00:12:17,600 --> 00:12:21,040
in the database looking at all of the

00:12:19,200 --> 00:12:22,399
podcasts they subscribe to

00:12:21,040 --> 00:12:24,320
and then finding the most recent

00:12:22,399 --> 00:12:26,240
episodes this is the

00:12:24,320 --> 00:12:27,680
sort of equivalent cipher query for that

00:12:26,240 --> 00:12:30,480
how we're traversing

00:12:27,680 --> 00:12:32,480
through that graph uh somewhat similar

00:12:30,480 --> 00:12:35,680
for episode we're looking up an episode

00:12:32,480 --> 00:12:38,160
by id and then just uh traversing to

00:12:35,680 --> 00:12:40,639
the podcast node and then returning the

00:12:38,160 --> 00:12:40,639
results

00:12:42,160 --> 00:12:46,079
this is how we might deploy that

00:12:43,600 --> 00:12:48,480
application just pointing out here that

00:12:46,079 --> 00:12:49,120
the graphql layer here we're deploying

00:12:48,480 --> 00:12:51,920
it to

00:12:49,120 --> 00:12:53,600
aws is a lambda function but just

00:12:51,920 --> 00:12:55,680
pointing out that this is something

00:12:53,600 --> 00:12:56,800
that sits between the database and our

00:12:55,680 --> 00:12:59,040
client to help us

00:12:56,800 --> 00:13:00,079
load data in the application or to get

00:12:59,040 --> 00:13:03,839
data to

00:13:00,079 --> 00:13:03,839
someone analyzing the data

00:13:04,079 --> 00:13:07,920
so based on what we've seen so far

00:13:06,320 --> 00:13:11,279
graphql is really

00:13:07,920 --> 00:13:13,440
an api query language and very much not

00:13:11,279 --> 00:13:15,920
a database query language so we have

00:13:13,440 --> 00:13:16,959
limited ability to express things that

00:13:15,920 --> 00:13:19,760
we might would want

00:13:16,959 --> 00:13:20,720
in a database query language like

00:13:19,760 --> 00:13:23,519
projections

00:13:20,720 --> 00:13:23,920
aggregations in a graph query language

00:13:23,519 --> 00:13:27,279
like

00:13:23,920 --> 00:13:30,240
variable length paths this kind of thing

00:13:27,279 --> 00:13:31,440
and we saw that while graphql does

00:13:30,240 --> 00:13:35,440
expose our data as

00:13:31,440 --> 00:13:38,639
a graph we can use any other data layer

00:13:35,440 --> 00:13:41,680
to fetch data for a graphql api even

00:13:38,639 --> 00:13:44,800
other apis

00:13:41,680 --> 00:13:47,600
so some of the advantages of graphql

00:13:44,800 --> 00:13:50,079
well we can send less data over the wire

00:13:47,600 --> 00:13:51,920
because the client is

00:13:50,079 --> 00:13:53,760
specifying exactly the fields that

00:13:51,920 --> 00:13:56,320
they're interested in

00:13:53,760 --> 00:13:57,839
under fetching this means that the

00:13:56,320 --> 00:14:00,240
client can say

00:13:57,839 --> 00:14:01,519
in one request all of the data that it

00:14:00,240 --> 00:14:03,920
wants to

00:14:01,519 --> 00:14:05,279
populate the view or that it has

00:14:03,920 --> 00:14:07,440
specific need for

00:14:05,279 --> 00:14:08,800
so we don't have to make multiple round

00:14:07,440 --> 00:14:11,920
trips

00:14:08,800 --> 00:14:14,800
to the api and then

00:14:11,920 --> 00:14:16,480
we also saw this benefit of component

00:14:14,800 --> 00:14:18,639
based data interactions where

00:14:16,480 --> 00:14:20,079
in our application with the podcast

00:14:18,639 --> 00:14:23,279
example we're able to take

00:14:20,079 --> 00:14:24,320
the graphql queries uh and componentize

00:14:23,279 --> 00:14:27,440
those with

00:14:24,320 --> 00:14:29,120
the the view logic in this case

00:14:27,440 --> 00:14:31,279
there are some challenges associated

00:14:29,120 --> 00:14:33,440
with graphql a lot of the well

00:14:31,279 --> 00:14:35,680
understood practices from

00:14:33,440 --> 00:14:36,480
the rest world don't really apply here

00:14:35,680 --> 00:14:39,199
so things like

00:14:36,480 --> 00:14:39,920
http status codes don't really really

00:14:39,199 --> 00:14:41,839
apply

00:14:39,920 --> 00:14:43,680
error handling is a bit different

00:14:41,839 --> 00:14:44,399
caching can be problematic because our

00:14:43,680 --> 00:14:47,440
queries

00:14:44,399 --> 00:14:49,279
can be different with each request

00:14:47,440 --> 00:14:50,639
and then there's this in plus one query

00:14:49,279 --> 00:14:52,720
problem which

00:14:50,639 --> 00:14:54,000
because you saw that these graphql

00:14:52,720 --> 00:14:57,360
queries are often very

00:14:54,000 --> 00:14:58,240
nested we can often be going back to the

00:14:57,360 --> 00:15:00,160
data source

00:14:58,240 --> 00:15:02,880
multiple times we want to try to avoid

00:15:00,160 --> 00:15:05,040
that these are all things that

00:15:02,880 --> 00:15:07,360
tooling and best practices have emerged

00:15:05,040 --> 00:15:09,199
to address a lot of these but

00:15:07,360 --> 00:15:11,120
good to be aware of these challenges

00:15:09,199 --> 00:15:15,279
when you're looking at implementing

00:15:11,120 --> 00:15:17,279
graphql so how do we typically build

00:15:15,279 --> 00:15:18,720
graphql services well there's basically

00:15:17,279 --> 00:15:21,279
three steps one is

00:15:18,720 --> 00:15:22,800
we start with what are called graphql

00:15:21,279 --> 00:15:24,839
type definitions

00:15:22,800 --> 00:15:26,959
so here's an example where we are

00:15:24,839 --> 00:15:29,519
defining the types

00:15:26,959 --> 00:15:31,440
and the fields and how these types are

00:15:29,519 --> 00:15:34,320
connected it's basically building out

00:15:31,440 --> 00:15:35,680
the graph then we write what are called

00:15:34,320 --> 00:15:37,440
resolver functions

00:15:35,680 --> 00:15:39,680
and these are functions that define how

00:15:37,440 --> 00:15:42,639
we actually fetch the data

00:15:39,680 --> 00:15:44,160
from the database from the the data

00:15:42,639 --> 00:15:47,040
layer whatever it may be

00:15:44,160 --> 00:15:48,320
and we call these for each field in the

00:15:47,040 --> 00:15:50,079
graphql api so

00:15:48,320 --> 00:15:52,079
in this example on the right we're using

00:15:50,079 --> 00:15:54,959
sort of like an orm

00:15:52,079 --> 00:15:55,279
type model to go back to the data layer

00:15:54,959 --> 00:15:57,440
and

00:15:55,279 --> 00:15:59,440
fetch data for each one of these fields

00:15:57,440 --> 00:15:59,920
in our graphql api this is an example

00:15:59,440 --> 00:16:03,040
for

00:15:59,920 --> 00:16:05,519
like a conference website

00:16:03,040 --> 00:16:08,320
so you can see because of these nested

00:16:05,519 --> 00:16:08,880
resolvers where this n plus one query

00:16:08,320 --> 00:16:13,360
problem

00:16:08,880 --> 00:16:16,560
comes from and then we serve our

00:16:13,360 --> 00:16:17,199
type definitions plus resolvers and that

00:16:16,560 --> 00:16:19,440
gives us

00:16:17,199 --> 00:16:21,040
a executable schema that we can then

00:16:19,440 --> 00:16:24,079
serve as an api

00:16:21,040 --> 00:16:25,199
endpoint but there are some some common

00:16:24,079 --> 00:16:27,440
problems that come up with this

00:16:25,199 --> 00:16:28,240
one is we're now sort of duplicating our

00:16:27,440 --> 00:16:31,600
schema

00:16:28,240 --> 00:16:33,040
from the api and the database

00:16:31,600 --> 00:16:35,120
we have to think of this mapping

00:16:33,040 --> 00:16:36,000
translation layer in our resolvers going

00:16:35,120 --> 00:16:38,880
going from graph

00:16:36,000 --> 00:16:39,600
to maybe a different model in the back

00:16:38,880 --> 00:16:41,440
end

00:16:39,600 --> 00:16:43,360
we end up writing a lot of boilerplate

00:16:41,440 --> 00:16:45,759
code in these resolvers

00:16:43,360 --> 00:16:47,759
and we have this in plus one query

00:16:45,759 --> 00:16:50,639
problem that we want to avoid of not

00:16:47,759 --> 00:16:51,759
going back to the database multiple

00:16:50,639 --> 00:16:54,560
times

00:16:51,759 --> 00:16:56,560
and so these were sort of the the input

00:16:54,560 --> 00:17:00,399
when we were looking at building

00:16:56,560 --> 00:17:02,399
the neo4j graphql integrations can we

00:17:00,399 --> 00:17:03,440
build tooling that makes it easier to

00:17:02,399 --> 00:17:07,120
build these

00:17:03,440 --> 00:17:10,319
apis and i'm going to skip to

00:17:07,120 --> 00:17:13,919
a code example here showing how to use

00:17:10,319 --> 00:17:15,600
this library actually which we have

00:17:13,919 --> 00:17:18,959
right here

00:17:15,600 --> 00:17:22,240
so basically what this library is is

00:17:18,959 --> 00:17:25,199
a javascript library that allows you to

00:17:22,240 --> 00:17:26,240
just write graphql type definitions and

00:17:25,199 --> 00:17:30,000
then

00:17:26,240 --> 00:17:33,039
that generates a graphql schema

00:17:30,000 --> 00:17:36,880
with all of the uh sort of filtering

00:17:33,039 --> 00:17:39,440
logic the entry points for the types

00:17:36,880 --> 00:17:40,720
and then at query time that is

00:17:39,440 --> 00:17:43,280
generating

00:17:40,720 --> 00:17:44,080
cipher for you automatically to fetch

00:17:43,280 --> 00:17:47,440
data

00:17:44,080 --> 00:17:49,280
from the api um

00:17:47,440 --> 00:17:50,799
so basically the only code i'm writing

00:17:49,280 --> 00:17:53,280
here are my

00:17:50,799 --> 00:17:55,120
graphql type definitions which maps to

00:17:53,280 --> 00:17:58,000
the business reviews data

00:17:55,120 --> 00:17:59,760
we saw previously and connecting to the

00:17:58,000 --> 00:18:01,840
database i don't have to write

00:17:59,760 --> 00:18:03,360
these resolver functions that specify

00:18:01,840 --> 00:18:07,200
how to actually

00:18:03,360 --> 00:18:10,799
fetch that data from the database

00:18:07,200 --> 00:18:13,440
which is which is a huge advantage

00:18:10,799 --> 00:18:14,160
if you're interested in how the sort of

00:18:13,440 --> 00:18:16,720
database

00:18:14,160 --> 00:18:18,799
integrations work with graphql there's

00:18:16,720 --> 00:18:20,480
an object called the resolveinfo object

00:18:18,799 --> 00:18:21,120
that's passed all these resolvers that

00:18:20,480 --> 00:18:23,360
has

00:18:21,120 --> 00:18:24,559
lots of information about the graphql

00:18:23,360 --> 00:18:27,039
schema and we essentially

00:18:24,559 --> 00:18:29,120
iterate through that to build up the

00:18:27,039 --> 00:18:32,320
database query

00:18:29,120 --> 00:18:32,799
um i'll leave the slides here that have

00:18:32,320 --> 00:18:35,440
some

00:18:32,799 --> 00:18:37,679
resources to learn to learn more there's

00:18:35,440 --> 00:18:40,720
a hackathon that's currently going on

00:18:37,679 --> 00:18:43,039
for building graphql apis as well as an

00:18:40,720 --> 00:18:46,960
online training i've also been working

00:18:43,039 --> 00:18:48,880
on a book talking about

00:18:46,960 --> 00:18:50,320
uh using these technologies together

00:18:48,880 --> 00:18:50,799
that's available in early release this

00:18:50,320 --> 00:18:53,120
is a

00:18:50,799 --> 00:18:54,400
free download for the first few chapters

00:18:53,120 --> 00:18:55,440
and then i mentioned that i've been

00:18:54,400 --> 00:18:58,320
doing a lot on

00:18:55,440 --> 00:18:58,960
the live streams as well but anyway

00:18:58,320 --> 00:19:00,400
here's my

00:18:58,960 --> 00:19:02,160
my twitter handle and my personal

00:19:00,400 --> 00:19:05,600
website if you're interested in digging

00:19:02,160 --> 00:19:05,600

YouTube URL: https://www.youtube.com/watch?v=5_fggWZZY3M


