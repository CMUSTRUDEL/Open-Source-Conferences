Title: Emily Riederer - Building a team of R packages
Publication date: 2021-05-19
Playlist: CSVConf 2021
Description: 
	Many case studies demonstrate the benefits of organizations and research groups developing internal R packages. But how do you move your organization from individual internal packages to a coherent internal ecosystem? This talk applies the jobs-to-be-done framework to consider the different roles that internal tools can play, from unblocking IT challenges to democratizing tribal knowledge. Beyond technical functionality, we will explore design principles and practice that make internal packages good teammates and consider how these deviate from open-source standards. Finally, we will consider how to exploit the unique challenges and opportunities of developing within an organization to make packages that collaborate well – both with other packages and their human teammates.
Captions: 
	00:00:01,520 --> 00:00:06,000
EMILY: All right. Thank you very much. All right. Hi, everyone. Thank you so much for having  

00:00:06,000 --> 00:00:11,920
me. Today, I'm here to talk about how to build  internal R packages to help analyze open data and  

00:00:12,640 --> 00:00:16,960
bring in more aspects of the open‑source  community to internal teamwork. 

00:00:18,080 --> 00:00:24,640
Before we talk about packages, I want you to  think back to the last time you joined a new team.  

00:00:24,640 --> 00:00:28,160
There was probably so much you needed to  learn before you could start contributing.  

00:00:28,720 --> 00:00:33,680
From the frustration of trying to access data  to lost hours, answering the wrong questions  

00:00:33,680 --> 00:00:38,000
until you built up that intuition and the  awkwardness of figuring out team norms,  

00:00:38,800 --> 00:00:45,360
when we join a new organization, we have to go  down this learning curve one time. The official  

00:00:45,360 --> 00:00:50,800
tools we use don't preserve this context, so  every single day is like their first day at work.  

00:00:52,160 --> 00:00:58,080
Unlike open‑source packages, internal packages  can embrace institutional knowledge more like a  

00:00:58,080 --> 00:01:04,240
colleague in two really important ways. First,  they can target a far more domain‑specific  

00:01:10,080 --> 00:01:15,920
problem. Their insight into our organizations  allow them to be more holistic in their  

00:01:15,920 --> 00:01:20,960
solutions by incorporating more steps of the  necessary workflow to answer that problem.  

00:01:20,960 --> 00:01:25,840
Covering areas all the way from pulling  data to communicating with our coworkers.  

00:01:26,720 --> 00:01:30,720
Because of these two factors, internal  packages can add a lot of value  

00:01:31,280 --> 00:01:37,360
by doing things like interfacing with internal  utilities, streamlining our analytic processes,  

00:01:37,360 --> 00:01:43,760
and empowering our data scientists to have  high quality outputs. More than the tasks  

00:01:43,760 --> 00:01:48,960
that a package can do, today I want to focus  on how to design such internal packages. 

00:01:48,960 --> 00:01:58,640
To do this, I like to think about the popular  jobs‑to‑be‑done framework for product development.  

00:01:59,360 --> 00:02:04,400
This asserts we hire a product to do a job  that helps us make progress toward a goal.  

00:02:06,160 --> 00:02:16,080
It's that progress and the ins and outs of what  progress our users want to make that really sets  

00:02:16,080 --> 00:02:22,160
internal packages apart. Additionally, these  jobs can have functional, social, and emotional  

00:02:22,160 --> 00:02:27,440
aspects. For the rest of this discussion,  I'll tweak this framework just slightly.  

00:02:28,080 --> 00:02:33,360
Let's think about building a team of packages  to do jobs that help our organization answer  

00:02:33,360 --> 00:02:39,440
impactful questions with efficient workflows. What sort of teammates should our packages be?  

00:02:40,240 --> 00:02:46,720
Let's meet a few. First, let me introduce you  to the IT guy. Think of a helpful or friendly  

00:02:46,720 --> 00:02:51,520
IT colleague you may know. They're fantastic  at handling the quirks of infrastructure and  

00:02:51,520 --> 00:02:58,880
abstracting the things data analysts don't want to  or aren't particularly educated in thinking about,  

00:02:58,880 --> 00:03:05,040
like maintaining secure servers. In the data  abstraction process, they take on additional  

00:03:05,040 --> 00:03:12,240
responsibilities, like credential management.  Ideally, they help us save time and frustration  

00:03:12,240 --> 00:03:21,600
by navigating organization‑specific roadblocks.  How can we encode these characteristics into  

00:03:21,600 --> 00:03:27,440
an R package? Providing utility functions in a  package can help achieve the same abstraction,  

00:03:28,080 --> 00:03:33,440
and in these we can take an opinionated  stance in crafting helpful error messages. 

00:03:36,400 --> 00:03:41,680
Suppose we wanted to write a function to connect  ourselves to a database. We might first start out  

00:03:41,680 --> 00:03:48,080
with a rather boilerplate piece of code using the  DBI package. We take the username and password,  

00:03:48,080 --> 00:03:56,960
hard code the information, and return a function  object. Suppose there's strict rules for  

00:03:56,960 --> 00:04:05,360
credentials. In an open‑source package, I wouldn't  want to presume to force users' hands in how  

00:04:05,360 --> 00:04:11,200
they're doing credential management. However, in  this case, I can make strong assumptions based on  

00:04:11,200 --> 00:04:18,400
my knowledge of my organization's rules and norms.  This sort of function can incentivize users to do  

00:04:18,400 --> 00:04:23,200
the right thing. Like in this case storing  their credentials and environment variables  

00:04:23,200 --> 00:04:28,960
because that's literally the only way they can  get the function to work. Of course, opinionated  

00:04:28,960 --> 00:04:37,600
design is only helpful if we provide a descriptive  error message. Otherwise, they'll get a cryptic  

00:04:37,600 --> 00:04:48,560
warning that DB pass is missing. We can enhance  this function with a custom and proscriptive error  

00:04:48,560 --> 00:04:53,920
message explaining what went wrong and how to  fix it and where they can get more information. 

00:04:55,600 --> 00:04:59,280
Even better than explaining errors is  preventing them from occurring at all.  

00:05:03,552 --> 00:05:09,280
Non‑alphanumeric characters are required  in passwords, but they're not included  

00:05:09,280 --> 00:05:15,840
when passed to the database. Instead of  asking our users to change their passwords,  

00:05:15,840 --> 00:05:23,600
we can proactively but silently re‑encode that  information. However, strong opinions in this  

00:05:23,600 --> 00:05:28,800
level of independence don't always make the  best teammates. Other times, we might want  

00:05:28,800 --> 00:05:36,800
someone like a junior analyst or trainee. We can  trust them to execute calculations correctly and  

00:05:36,800 --> 00:05:42,480
make reasonable assumptions. At the same time, we  want them to be responsive to feedback and willing  

00:05:42,480 --> 00:05:48,160
to test out multiple solutions, so how could we  incorporate these jobs in an internal package? 

00:05:49,600 --> 00:05:55,200
We can build interactive and yet responsive  functions with default arguments, reserved  

00:05:55,200 --> 00:06:02,800
keywords, and the ellipses. To illustrate, imagine  a visualization function that drafts a gg plot 2  

00:06:02,800 --> 00:06:19,040
code but allows users to input their variables  to draw cohort codes. If we relied on the same  

00:06:19,040 --> 00:06:24,320
opinionated design as the IT guy, we might  consider hard coding some of these variables in  

00:06:24,320 --> 00:06:30,320
our function. Here that isn't a great approach.  We might know what the desired X‑axis will be  

00:06:30,320 --> 00:06:52,720
80% of the time. Hard coding decreases the  efficiency of the package 20% of the time. Then,  

00:06:52,720 --> 00:06:58,800
when we do not provide a unique value, the default  is used. That was the junior analyst's best guess,  

00:06:59,440 --> 00:07:05,600
but users retain complete control to change  it as they see fit. This approach becomes even  

00:07:05,600 --> 00:07:10,960
more powerful if we can identify a small set of  incredibly commonly occurring assumed variable  

00:07:10,960 --> 00:07:16,960
names or other values. Then we can define  and document the set of reserved keywords  

00:07:16,960 --> 00:07:21,920
that span all of our internal packages. If  these are well‑known and well documented,  

00:07:21,920 --> 00:07:27,200
users are getting into the habit of shaping their  data so it plays nicely with the package ecosystem  

00:07:27,200 --> 00:07:34,000
and saves manual typing. This incentivizes a  level of standardization in naming that can have  

00:07:34,000 --> 00:07:39,280
other convenient consequences and making data  abstracts more transparent and more shareable. 

00:07:40,960 --> 00:07:50,320
Finally, one other nice trick is the ellipses or  passing the dots. This allows users to provide any  

00:07:50,320 --> 00:07:55,840
number of additional arbitrary arguments beyond  what was specified by the developer and plug them  

00:07:55,840 --> 00:08:03,760
in at a designated place in the function body.  This way users can extend functions based on needs  

00:08:03,760 --> 00:08:09,200
that the developer never could have anticipated,  like customizing color, size, and line type.  

00:08:11,200 --> 00:08:16,960
So far, we've focused mostly on the first  dimension we talked about of internal packages,  

00:08:16,960 --> 00:08:22,720
making our package teammates target solving  specific internal problems, but there's just  

00:08:22,720 --> 00:08:27,840
as much value in that second dimension. Using  internal packages is a way to ship not just  

00:08:27,840 --> 00:08:34,560
calculations but complete workflows and to share  our understanding of how the broader organization  

00:08:34,560 --> 00:08:40,320
operates. To illustrate this, consider our  intrepid tech lead or principal investigator. 

00:08:41,200 --> 00:08:45,440
We value this type of teammate because  they can draw from a breadth of rich past  

00:08:45,440 --> 00:08:51,120
experience and institutional knowledge to  help us weigh tradeoffs, learn from wisdom,  

00:08:51,120 --> 00:08:56,080
and inspire us to do our best work.  So, that's a pretty tall order for a  

00:08:56,080 --> 00:09:01,600
package. The conscientious use of vignettes  and templates can help us toward this goal.  

00:09:03,360 --> 00:09:08,640
Vignettes and R packages introduce the  basic functionality of the tool example.  

00:09:12,400 --> 00:09:16,160
Alternatively, they may discuss a  statistical method that's implemented,  

00:09:16,160 --> 00:09:22,080
as done in the survival package. The vignettes  of internal R packages can do more diverse and  

00:09:22,080 --> 00:09:33,840
numerous jobs. These vignettes can use them  to coach anyone working on our analysis.  

00:09:34,880 --> 00:09:41,840
Just as a few examples, you can consider having  completely code‑free vignettes that introduce a  

00:09:41,840 --> 00:09:47,920
problem your package solves, explain the workflow  and key questions you should be asking yourself,  

00:09:49,920 --> 00:09:55,680
and get into some of the procedural weeds,  like what you need to do to deploy a feature.  

00:09:59,280 --> 00:10:04,000
After aligning with your workers on that  conceptual framework, you may introduce the  

00:10:04,000 --> 00:10:08,720
package's functionality and explain how  these tools overlap. When your packages  

00:10:08,720 --> 00:10:14,240
contain functions for many different ways to do  a task, you can compare pros and cons and explain  

00:10:14,240 --> 00:10:21,360
different situations where different options would  be more effective. Vignettes can include lessons  

00:10:21,360 --> 00:10:29,040
learned and links to references to past examples  to help colleagues learn about similar projects.  

00:10:30,160 --> 00:10:36,160
In fact, all of that context may be so helpful,  even colleagues who are not direct users of your  

00:10:36,160 --> 00:10:42,400
package may seek out its mentorship. In this  case, you can use the package down package to  

00:10:42,400 --> 00:10:47,920
automatically create a package website to share  these vignettes with anyone who needs to learn  

00:10:47,920 --> 00:10:57,200
about a specific problem space. Your package can  share its wisdom much more broadly. Unlike their  

00:10:57,200 --> 00:11:02,640
human counterparts, package teammates can always  find time on their calendar for another meeting. 

00:11:04,960 --> 00:11:14,080
Now similar to vignettes, embedded templates take  on a more important role. Mark down templates  

00:11:14,080 --> 00:11:20,240
provide a prepopulated file instead of the detail.  This is commonly used to demonstrate proper  

00:11:20,240 --> 00:11:27,840
formatting syntax. For example, the flex dashboard  package shows users how to set up YAML metadata.  

00:11:35,440 --> 00:11:40,960
They understand the problems users are facing  and the progress they hope to achieve. Templates  

00:11:40,960 --> 00:11:46,560
can mentor users and structure their work in two  different ways. Process walk‑throughs can serve  

00:11:46,560 --> 00:11:53,680
as interactive notebooks that coach users through  common analyses. If a type of analysis requires  

00:11:53,680 --> 00:11:59,440
manual data cleaning and curation, a template  notebook could guide users to ask questions  

00:11:59,440 --> 00:12:04,160
of their data and demonstrate common views and  summaries that they really need to interrogate.  

00:12:05,040 --> 00:12:11,920
We can include full analysis outlines, which  include placeholder text, commentary, and code  

00:12:13,280 --> 00:12:20,960
that result in a specific report or outcome. Similar to  

00:12:23,200 --> 00:12:30,800
mark down templates, our packages can also include  project templates. They can provide the structure  

00:12:30,800 --> 00:12:35,760
and set of files for each new project to  give users a helping hand and drive the kind  

00:12:35,760 --> 00:12:40,560
of consistency across projects that any tech  lead would dream of when doing a code review. 

00:12:43,280 --> 00:12:48,320
Speaking of that collaboration piece, it brings  us to the last teammate whose traits we want our  

00:12:48,320 --> 00:12:58,240
packages to flow. The project manager. One of the  differences is understanding the whole workflow  

00:12:58,240 --> 00:13:03,680
and helping coordinate projects across many  different components. When writing open‑source  

00:13:03,680 --> 00:13:10,240
packages, we tend to assume that our  project managers are programmers. On a  

00:13:10,240 --> 00:13:18,880
true cross‑functional team not everyone will be.  We can think about how to augment our studio's IDE  

00:13:18,880 --> 00:13:25,040
so it works well for all colleagues. One  way to do is this is through modularization.  

00:13:29,440 --> 00:13:34,720
In those templates we just discussed, we can  actually make separate templates for components  

00:13:34,720 --> 00:13:40,640
that do and do not require programming. Files  that only need plain text commentary could be in  

00:13:40,640 --> 00:13:50,080
vanilla markdown files. The main markdown file can  incorporate these documents using child documents.  

00:13:51,760 --> 00:13:57,680
This approach is made even easier with advances  in the RStudio IDE through the visual markdown  

00:13:57,680 --> 00:14:01,840
editor, which provides a great graphical  user and we are face to support processing  

00:14:03,440 --> 00:14:08,720
and markdown. We can use the feature of RStudio  add‑ins to extend the interface and install  

00:14:08,720 --> 00:14:21,600
interactive widgets inside our package. Add‑ins  require more investment up front, but they're  

00:14:21,600 --> 00:14:27,600
much easier to maintain than complete web apps and  can help convert our teammates to our users over  

00:14:27,600 --> 00:14:35,600
time. Besides, an excellent project manager is  willing to go the extra mile to support the team. 

00:14:36,960 --> 00:14:41,360
We've talked about what makes an  individual package a good team member.  

00:14:42,000 --> 00:14:47,600
Another major opportunity when building a suite  of tools is we have a unique opportunity to  

00:14:47,600 --> 00:14:53,840
think about how multiple packages on our team can  best work together. We will always want teammates  

00:14:53,840 --> 00:14:58,960
that are clear communicators, have defined  responsibilities, and keep their promises.  

00:15:00,240 --> 00:15:05,760
We can help our packages be good teammates with  naming conventions, clearly defined scopes,  

00:15:06,480 --> 00:15:13,600
and attention to dependencies and testing.  Clear function naming conventions and consistent  

00:15:13,600 --> 00:15:19,360
signatures help packages effectively  communicate with package human collaborators.  

00:15:26,640 --> 00:15:31,200
One approach I really like is that each  function pretext can denote the type of  

00:15:31,200 --> 00:15:42,880
object it will return. Viz functions always  returns a gg plot object. This gives users  

00:15:42,880 --> 00:15:54,320
intuition when working on any one of them. Since we own our whole internal stack,  

00:15:54,320 --> 00:15:58,480
we have more freedom in choosing how to  define functionality between packages.  

00:15:59,440 --> 00:16:04,000
Take, for example, the data science workflow  as described in the R for Data Science book.  

00:16:05,520 --> 00:16:10,240
Open‑source packages have overlapping  functionality, which forces users to  

00:16:10,240 --> 00:16:18,240
compare alternatives and decide which one is best,  which can be timely. But internally, we can use  

00:16:18,240 --> 00:16:24,400
some amount of centralized planning to ensure each  package teammate has a very clearly defined role,  

00:16:24,400 --> 00:16:30,080
whether that is a horizontal utility or to  enable progress on a specific work stream.  

00:16:31,760 --> 00:16:36,800
When assigning these roles and responsibilities  to our team of packages, we can assess what  

00:16:39,280 --> 00:16:44,240
different functionality needs to be shared.  Packages often have direct dependencies  

00:16:44,240 --> 00:16:50,720
where a function in one package calls a function  in another package. This isn't bad, but especially  

00:16:50,720 --> 00:16:55,680
with eternal packages, which might sometimes  have a short shelf life and few developers,  

00:16:56,240 --> 00:17:02,320
this can potentially create a domino effect  of failure. If one package is deprecated or  

00:17:02,320 --> 00:17:07,680
decides to graduate, retire, or take a vacation,  we don't want the rest of our ecosystem to fail. 

00:17:07,680 --> 00:17:12,400
>> You have four minutes. >> Since we control both packages A and B,  

00:17:15,040 --> 00:17:19,200
we can see if we can eliminate explicit  dependencies by promoting a clean handle.  

00:17:19,920 --> 00:17:24,880
We might need a function in A to produce an output  in B that can be consumed instead of calling it  

00:17:24,880 --> 00:17:34,880
directly. Or we can find shared needs and extract  them to some building block C, which might contain  

00:17:36,240 --> 00:17:42,800
visualization primitive functions. This way we can  at least have a clear hierarchy of dependencies  

00:17:42,800 --> 00:17:53,040
and can identify a small number of critical  infrastructures to prevent failure. We can use  

00:17:53,040 --> 00:17:58,160
tests to make sure our packages are reliable  teammates who always do what they promise. 

00:17:58,960 --> 00:18:02,560
Typically, if I write a package  B that depends on a package A,  

00:18:02,560 --> 00:18:13,600
I can only control package Bs tests. This is a  good safeguard, but it means I'll only detect  

00:18:13,600 --> 00:18:21,200
a problem after it's already been introduced.  Instead with internal packages, we prefer A and B  

00:18:21,200 --> 00:18:25,520
be conscientious of the promises they've made  and stay committed to their collaboration.  

00:18:26,560 --> 00:18:32,160
We can formalize this shared vision with  integrated tests. We can add tests to the  

00:18:32,160 --> 00:18:43,840
upstream and downstream packages to make sure  they check in with each other. Now just imagine  

00:18:43,840 --> 00:18:48,640
having that rigorous and ongoing communication  and prioritization with your actual teammates. 

00:18:50,400 --> 00:18:55,440
In summary, we all know the joy of working  with a great team, and I suspect many of  

00:18:55,440 --> 00:18:59,680
the people here today know the pleasure  of cracking open a new open‑source tool.  

00:19:00,480 --> 00:19:05,040
By taking advantage of the unique  opportunities of designing internal packages,  

00:19:05,040 --> 00:19:10,080
we can truly achieve the best of both worlds. We  can ensure the fun of working with good tools with  

00:19:10,080 --> 00:19:16,000
the teammates we care about, and we can elevate  those same tools to be full‑fledged teammates  

00:19:16,000 --> 00:19:19,920

YouTube URL: https://www.youtube.com/watch?v=SbnUFpqLtws


