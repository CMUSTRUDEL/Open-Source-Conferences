Title: Jason Crawford - CSVConf 2017
Publication date: 2017-06-04
Playlist: CSVConf 2017 - Day 2 - Room A
Description: 
	
Captions: 
	00:00:02,100 --> 00:00:05,740
thanks everybody for coming it's great

00:00:04,180 --> 00:00:08,830
to be here this is my first CSV

00:00:05,740 --> 00:00:11,380
conference and it is my first time

00:00:08,830 --> 00:00:13,870
giving this talk and presenting this

00:00:11,380 --> 00:00:16,299
part of our vision I don't do a lot of

00:00:13,870 --> 00:00:18,430
conferences but I thought you all would

00:00:16,299 --> 00:00:20,890
be the perfect audience to hear this

00:00:18,430 --> 00:00:22,090
message so thanks for coming in here and

00:00:20,890 --> 00:00:23,949
sitting and listening to what I have to

00:00:22,090 --> 00:00:27,570
say folks over in the corner we've got a

00:00:23,949 --> 00:00:27,570
few empty seats over here if you like

00:00:28,710 --> 00:00:34,870
we live in a world of data models and

00:00:31,330 --> 00:00:36,850
especially relational data models they

00:00:34,870 --> 00:00:39,670
power the tools that we use to get our

00:00:36,850 --> 00:00:43,500
work done every day and they structure

00:00:39,670 --> 00:00:43,500
the data sets that we want to analyze

00:00:43,620 --> 00:00:48,520
today to create a data model you need

00:00:46,000 --> 00:00:51,190
two things you need text technical

00:00:48,520 --> 00:00:53,020
expertise in data modeling itself and of

00:00:51,190 --> 00:00:56,079
course you need domain knowledge of the

00:00:53,020 --> 00:00:58,809
domain being modeled usually these

00:00:56,079 --> 00:01:00,789
things are not in the same person so the

00:00:58,809 --> 00:01:02,770
solution that we have today is usually

00:01:00,789 --> 00:01:05,229
you take somebody who already has

00:01:02,770 --> 00:01:06,819
technical expertise in data modeling and

00:01:05,229 --> 00:01:08,560
then you have them go out and gather the

00:01:06,819 --> 00:01:11,799
domain knowledge buy it through

00:01:08,560 --> 00:01:13,119
interviews what we usually don't do is

00:01:11,799 --> 00:01:15,369
start with somebody who already knows

00:01:13,119 --> 00:01:18,909
the domain and just teach them how to

00:01:15,369 --> 00:01:20,979
model data if it's always easier to

00:01:18,909 --> 00:01:22,539
start with knowledge of data modeling

00:01:20,979 --> 00:01:24,609
than knowledge of any other domain the

00:01:22,539 --> 00:01:25,959
implication seems to be that data

00:01:24,609 --> 00:01:31,240
modeling is the hardest thing in the

00:01:25,959 --> 00:01:32,590
world to learn and the result is that

00:01:31,240 --> 00:01:35,139
there's a whole ton of domain knowledge

00:01:32,590 --> 00:01:36,399
out there just just waiting to be

00:01:35,139 --> 00:01:38,829
unlocked it's locked up in people's

00:01:36,399 --> 00:01:41,469
heads now there are millions of

00:01:38,829 --> 00:01:43,630
interesting and useful data models that

00:01:41,469 --> 00:01:47,259
could help millions of people in their

00:01:43,630 --> 00:01:52,239
life their work their research if only

00:01:47,259 --> 00:01:54,669
they were able to create them now it

00:01:52,239 --> 00:01:57,159
wasn't supposed to be this way in the

00:01:54,669 --> 00:01:59,559
book go to the authors Steve lore tells

00:01:57,159 --> 00:02:02,139
story of the creation of sequel at IBM

00:01:59,559 --> 00:02:03,609
in the 1970s the creators of sequel

00:02:02,139 --> 00:02:06,009
wanted to create a language that could

00:02:03,609 --> 00:02:07,869
be understood easily by ordinary humans

00:02:06,009 --> 00:02:11,409
and make it possible for them to

00:02:07,869 --> 00:02:13,209
interact with data but ultimately they

00:02:11,409 --> 00:02:16,020
concluded they've been too optimistic

00:02:13,209 --> 00:02:21,650
after some of the early usability study

00:02:16,020 --> 00:02:27,870
aha this is their conclusion in the 70s

00:02:21,650 --> 00:02:30,480
so 40 plus years later how do we bring

00:02:27,870 --> 00:02:32,910
about this vision how do we bring about

00:02:30,480 --> 00:02:36,150
a world where end users are not just

00:02:32,910 --> 00:02:38,190
passive consumers of models created by

00:02:36,150 --> 00:02:40,500
software experts but our active

00:02:38,190 --> 00:02:44,910
participants in the process building

00:02:40,500 --> 00:02:47,580
useful data models for themselves if

00:02:44,910 --> 00:02:49,980
you've ever been frustrated with a tool

00:02:47,580 --> 00:02:51,900
via Trello or github or anything else

00:02:49,980 --> 00:02:53,640
you use maybe to track your work or do

00:02:51,900 --> 00:02:55,980
your research if you've ever been

00:02:53,640 --> 00:02:58,350
frustrated with something that you know

00:02:55,980 --> 00:02:59,730
that doesn't fit your workflow your

00:02:58,350 --> 00:03:01,410
process are exactly what you want to

00:02:59,730 --> 00:03:06,240
track you felt the pain of a mismatched

00:03:01,410 --> 00:03:08,400
data model and you felt the need for for

00:03:06,240 --> 00:03:09,810
this world where you can create exactly

00:03:08,400 --> 00:03:12,360
the model that you want and work with it

00:03:09,810 --> 00:03:14,160
easily well to bring about this world I

00:03:12,360 --> 00:03:16,050
think we need to look at our tools look

00:03:14,160 --> 00:03:19,530
at who they're designed for and what

00:03:16,050 --> 00:03:22,530
they're optimized for the traditional

00:03:19,530 --> 00:03:24,120
sequel database is designed by and for

00:03:22,530 --> 00:03:26,519
developers it's an infrastructure

00:03:24,120 --> 00:03:28,830
component right and it's optimized for

00:03:26,519 --> 00:03:30,540
performance and scaling now this is all

00:03:28,830 --> 00:03:32,370
well and good we need databases like

00:03:30,540 --> 00:03:34,440
this but what would a database look like

00:03:32,370 --> 00:03:36,810
if it were designed for end-users

00:03:34,440 --> 00:03:39,230
and optimized for usability and

00:03:36,810 --> 00:03:41,970
learnability

00:03:39,230 --> 00:03:45,390
well it would look something like this

00:03:41,970 --> 00:03:46,830
so this is filled book it is a database

00:03:45,390 --> 00:03:49,709
that looks and feels like a spreadsheet

00:03:46,830 --> 00:03:52,769
but supports relational data querying

00:03:49,709 --> 00:03:54,360
and it has a REST API so just a quick

00:03:52,769 --> 00:03:56,220
demo to give you the feel of it this is

00:03:54,360 --> 00:03:58,799
a little demo with some public company

00:03:56,220 --> 00:04:01,280
data you can scroll through it select

00:03:58,799 --> 00:04:03,840
and edit text just like in a spreadsheet

00:04:01,280 --> 00:04:07,170
but it's super easier to query so say I

00:04:03,840 --> 00:04:09,150
want to do a filter for companies with a

00:04:07,170 --> 00:04:12,780
market cap of greater than 100 millions

00:04:09,150 --> 00:04:15,959
sort by their earnings and group by

00:04:12,780 --> 00:04:18,600
their country boom so just like that

00:04:15,959 --> 00:04:20,400
I've done a filter sort and group type

00:04:18,600 --> 00:04:25,050
of query and now I can scroll through

00:04:20,400 --> 00:04:26,820
these results and I mentioned also it

00:04:25,050 --> 00:04:29,260
handles relational data so this country

00:04:26,820 --> 00:04:31,840
column here is not just text it

00:04:29,260 --> 00:04:33,880
a link to a country sheet the countries

00:04:31,840 --> 00:04:36,220
have been normalized out into their own

00:04:33,880 --> 00:04:38,740
sheet you see them here and it supports

00:04:36,220 --> 00:04:40,300
formulas that use this relational model

00:04:38,740 --> 00:04:42,070
so like if I want to figure out the

00:04:40,300 --> 00:04:45,270
total market cap of companies I could

00:04:42,070 --> 00:04:47,290
just say sum of companies market cap and

00:04:45,270 --> 00:04:49,990
and I've got that formula that

00:04:47,290 --> 00:04:52,060
calculation there so this is how easy it

00:04:49,990 --> 00:04:57,190
can be to work with data and something

00:04:52,060 --> 00:04:59,230
like field book the thing about the

00:04:57,190 --> 00:05:01,840
sequel model is that because it's

00:04:59,230 --> 00:05:03,340
optimized for the machine rather than

00:05:01,840 --> 00:05:06,820
for the user it puts a good amount of

00:05:03,340 --> 00:05:09,880
cognitive load on the user a simple

00:05:06,820 --> 00:05:11,920
example of this just to tell you what I

00:05:09,880 --> 00:05:14,020
mean by cognitive load is the fact that

00:05:11,920 --> 00:05:15,820
sequel databases are statically typed so

00:05:14,020 --> 00:05:17,230
when you create a you know to even get

00:05:15,820 --> 00:05:18,580
started working with the database you've

00:05:17,230 --> 00:05:19,810
got to do a bunch of up front

00:05:18,580 --> 00:05:22,120
configuration you have to create a

00:05:19,810 --> 00:05:23,170
schema a data model and to do this you

00:05:22,120 --> 00:05:25,120
have to know what tables you're going to

00:05:23,170 --> 00:05:27,490
have what college you're going to have

00:05:25,120 --> 00:05:29,530
what types those columns are which ones

00:05:27,490 --> 00:05:31,600
are nullable or not if you want to add

00:05:29,530 --> 00:05:32,860
another column into a table you got to

00:05:31,600 --> 00:05:33,370
know what type it's going to be and so

00:05:32,860 --> 00:05:36,250
forth

00:05:33,370 --> 00:05:38,770
I'm very helpful for the machine to

00:05:36,250 --> 00:05:41,260
optimize for performance but but adds

00:05:38,770 --> 00:05:43,090
cognitive load on the user so if you're

00:05:41,260 --> 00:05:44,350
optimizing for the user you want to make

00:05:43,090 --> 00:05:46,030
that a lot easier right you want to say

00:05:44,350 --> 00:05:48,460
if you add a column it's just a click of

00:05:46,030 --> 00:05:49,150
a button and you don't have to say what

00:05:48,460 --> 00:05:52,150
type it is

00:05:49,150 --> 00:05:54,700
so in field book like in spreadsheets

00:05:52,150 --> 00:05:56,680
you can enter numbers or you know you

00:05:54,700 --> 00:05:58,420
can enter text as well and they can

00:05:56,680 --> 00:05:59,710
coexist in the same column so it's more

00:05:58,420 --> 00:06:03,190
like dynamically typed rather than

00:05:59,710 --> 00:06:05,110
static okay that's just a simple example

00:06:03,190 --> 00:06:07,720
of what I mean by optimizing for the

00:06:05,110 --> 00:06:09,850
user instead of the human but that's a

00:06:07,720 --> 00:06:12,910
really easy case let's talk about some

00:06:09,850 --> 00:06:15,070
stuff that's trickier how do we handle

00:06:12,910 --> 00:06:17,080
relational modeling this is a really key

00:06:15,070 --> 00:06:18,520
thing that the spreadsheet model doesn't

00:06:17,080 --> 00:06:22,540
do very well but that end-users

00:06:18,520 --> 00:06:26,880
definitely want to do in the sequel

00:06:22,540 --> 00:06:29,650
model this is done through foreign keys

00:06:26,880 --> 00:06:33,220
so particularly in a sequel database

00:06:29,650 --> 00:06:35,500
every every record will have a numeric

00:06:33,220 --> 00:06:38,020
ID that is it's sort of unique global

00:06:35,500 --> 00:06:39,490
reference if you want to say say we want

00:06:38,020 --> 00:06:41,080
to track some people and what cities

00:06:39,490 --> 00:06:42,910
they live in well we would have two

00:06:41,080 --> 00:06:45,520
tables people in cities

00:06:42,910 --> 00:06:47,110
and then you'd add a city ID column to

00:06:45,520 --> 00:06:48,880
the people table this is called a

00:06:47,110 --> 00:06:50,650
foreign key column and this would

00:06:48,880 --> 00:06:52,510
contain the idea city is so London is

00:06:50,650 --> 00:06:54,580
identified by ID two and when we have

00:06:52,510 --> 00:06:56,040
Alice has city ID two that means she

00:06:54,580 --> 00:06:59,380
lives in London okay

00:06:56,040 --> 00:07:01,450
hmm not too hard to understand but

00:06:59,380 --> 00:07:03,310
clearly optimized again for the machine

00:07:01,450 --> 00:07:04,840
not for the user when you glance at this

00:07:03,310 --> 00:07:06,520
cities column you don't want to see a

00:07:04,840 --> 00:07:07,630
bunch of numbers right you really want

00:07:06,520 --> 00:07:10,930
to know what what cities are these

00:07:07,630 --> 00:07:13,870
people in so the simple way that we make

00:07:10,930 --> 00:07:15,550
that we make relational modeling more

00:07:13,870 --> 00:07:17,440
accessible to users is to say we're

00:07:15,550 --> 00:07:18,820
going to base it on names so here I'm

00:07:17,440 --> 00:07:22,390
going to take that cities column and

00:07:18,820 --> 00:07:24,070
Dean or MIT into a into its own or

00:07:22,390 --> 00:07:27,130
starting normalize it into its own sheet

00:07:24,070 --> 00:07:28,780
city of sheet and now when we want to

00:07:27,130 --> 00:07:29,230
add a new city to somebody we can just

00:07:28,780 --> 00:07:30,940
do it

00:07:29,230 --> 00:07:33,220
based on the name I can even start

00:07:30,940 --> 00:07:38,440
typing and now we're creating links

00:07:33,220 --> 00:07:40,030
based on names instead of IDs okay so

00:07:38,440 --> 00:07:41,380
again pretty straightforward but we're

00:07:40,030 --> 00:07:42,730
starting to evolve the model towards

00:07:41,380 --> 00:07:44,760
something that's optimized for the end

00:07:42,730 --> 00:07:47,860
user

00:07:44,760 --> 00:07:49,540
this model of having a column that

00:07:47,860 --> 00:07:52,540
references another table gives us a

00:07:49,540 --> 00:07:54,460
one-to-many relationship right belongs

00:07:52,540 --> 00:07:56,230
to relationship in data modeling terms

00:07:54,460 --> 00:07:59,250
we say that each person belongs to a

00:07:56,230 --> 00:08:00,970
city like Alice belongs to London

00:07:59,250 --> 00:08:02,620
anytime you have a belongs to

00:08:00,970 --> 00:08:04,990
relationship in a data model you've got

00:08:02,620 --> 00:08:06,610
an implicit relationship in the opposite

00:08:04,990 --> 00:08:08,560
direction to call des has many

00:08:06,610 --> 00:08:10,360
relationship a city has many people in

00:08:08,560 --> 00:08:13,630
this case both Alice and Dave are in

00:08:10,360 --> 00:08:15,790
London but in the traditional sequel

00:08:13,630 --> 00:08:18,490
model the has many relationship is

00:08:15,790 --> 00:08:20,950
implicit you can't see it just by

00:08:18,490 --> 00:08:22,660
looking at the city's table you have to

00:08:20,950 --> 00:08:24,310
know that it's sort of implicitly there

00:08:22,660 --> 00:08:26,620
and if you want to see which people are

00:08:24,310 --> 00:08:28,090
in a city you have to do a query and you

00:08:26,620 --> 00:08:29,919
have to know what query to do right it's

00:08:28,090 --> 00:08:32,800
something like this select star from

00:08:29,919 --> 00:08:35,469
people where city ID is - that's how you

00:08:32,800 --> 00:08:36,849
see all the people who are in London to

00:08:35,469 --> 00:08:38,289
know how to do this query you have to

00:08:36,849 --> 00:08:39,969
not only know sequel you have to also

00:08:38,289 --> 00:08:42,820
know the structure of the table you have

00:08:39,969 --> 00:08:44,440
to know that this people table has a

00:08:42,820 --> 00:08:47,080
city ID and again you can't tell that

00:08:44,440 --> 00:08:49,420
just by looking at the city's table so

00:08:47,080 --> 00:08:50,950
one thing that helps end-users we've

00:08:49,420 --> 00:08:54,480
found through our usability testing is

00:08:50,950 --> 00:08:56,310
to just make this explicit so here

00:08:54,480 --> 00:08:59,190
similar example if I go into my cities

00:08:56,310 --> 00:09:02,070
now and I click into London we can

00:08:59,190 --> 00:09:04,709
actually see a form view and because of

00:09:02,070 --> 00:09:06,420
that link back to the people table we

00:09:04,709 --> 00:09:09,079
automatically essentially run that query

00:09:06,420 --> 00:09:14,760
for you and show you the explicit

00:09:09,079 --> 00:09:16,829
reverse relationship ok still pretty

00:09:14,760 --> 00:09:18,600
simple let's take things up a level very

00:09:16,829 --> 00:09:20,670
often people want to do not just one too

00:09:18,600 --> 00:09:22,320
many but actually many to many

00:09:20,670 --> 00:09:23,579
relationships this is another thing that

00:09:22,320 --> 00:09:26,519
came out very clearly in our user

00:09:23,579 --> 00:09:29,790
testing suppose for instance we wanted

00:09:26,519 --> 00:09:31,769
to track not just where where does the

00:09:29,790 --> 00:09:33,420
person live now but say all the cities

00:09:31,769 --> 00:09:35,010
they've ever lived in well then we would

00:09:33,420 --> 00:09:37,170
need a many-to-many relationship between

00:09:35,010 --> 00:09:39,320
people in cities and in a sequel

00:09:37,170 --> 00:09:42,329
database that looks something like this

00:09:39,320 --> 00:09:44,490
you can't do this directly with just two

00:09:42,329 --> 00:09:47,040
tables in sequel because a foreign key

00:09:44,490 --> 00:09:49,199
column only supports one value again

00:09:47,040 --> 00:09:51,120
this is optimizing for performance so

00:09:49,199 --> 00:09:54,000
the database can organize data in a very

00:09:51,120 --> 00:09:56,790
compact way great for the database but

00:09:54,000 --> 00:09:58,829
it's not so great for people because you

00:09:56,790 --> 00:10:00,930
now have to have this third table an

00:09:58,829 --> 00:10:02,910
intermediate table called a join table

00:10:00,930 --> 00:10:04,350
it is highly non-intuitive right if you

00:10:02,910 --> 00:10:05,970
haven't been trained I'm taking a sequel

00:10:04,350 --> 00:10:07,860
class you have been trained in this kind

00:10:05,970 --> 00:10:10,529
of thing it would take you have to be

00:10:07,860 --> 00:10:12,420
pretty smart and like come up with some

00:10:10,529 --> 00:10:14,100
invention to figure out maybe I could do

00:10:12,420 --> 00:10:19,019
this with a third table you know it's

00:10:14,100 --> 00:10:20,730
not and and this third table has no it

00:10:19,019 --> 00:10:22,139
doesn't correspond to anything in the

00:10:20,730 --> 00:10:23,970
users mental model right it's an

00:10:22,139 --> 00:10:25,230
implementation detail it's actually it's

00:10:23,970 --> 00:10:27,870
an implementation detail that kind of

00:10:25,230 --> 00:10:30,839
sticks out like a sore thumb right it

00:10:27,870 --> 00:10:31,920
doesn't correspond to any concept in in

00:10:30,839 --> 00:10:35,399
the mental model it's more about the

00:10:31,920 --> 00:10:37,230
physical model the database and we've

00:10:35,399 --> 00:10:40,440
gotten one more level implicit because

00:10:37,230 --> 00:10:41,970
now notice that this relationship

00:10:40,440 --> 00:10:43,949
between people in cities is now not

00:10:41,970 --> 00:10:46,350
obvious from looking at the people table

00:10:43,949 --> 00:10:47,639
or the city's table it's only you can

00:10:46,350 --> 00:10:50,850
fill declare when you discover that

00:10:47,639 --> 00:10:52,139
there's this intermediate table here so

00:10:50,850 --> 00:10:54,630
again if we want to optimize for the

00:10:52,139 --> 00:10:56,760
user instead of the machine what do we

00:10:54,630 --> 00:10:58,889
do well a simple way to do this is just

00:10:56,760 --> 00:11:01,680
to allow multiple links in the cell this

00:10:58,889 --> 00:11:03,300
is harder to implement and it's harder

00:11:01,680 --> 00:11:04,800
to optimize for performance but it's

00:11:03,300 --> 00:11:07,830
much easier for people to understand

00:11:04,800 --> 00:11:10,050
so in field book we do this we

00:11:07,830 --> 00:11:13,410
allow you to have not just one but

00:11:10,050 --> 00:11:15,750
multiple links in a cell and you can

00:11:13,410 --> 00:11:17,940
assign people to you know to multiple

00:11:15,750 --> 00:11:19,710
cities and now we see both Caroll and

00:11:17,940 --> 00:11:26,280
Alice are in London if we click on that

00:11:19,710 --> 00:11:27,750
we'll see we'll see all them here so in

00:11:26,280 --> 00:11:29,880
user testing this worked pretty well

00:11:27,750 --> 00:11:31,440
except there was one thing that people

00:11:29,880 --> 00:11:34,650
would get confused about when they were

00:11:31,440 --> 00:11:36,570
setting things up should I start from

00:11:34,650 --> 00:11:38,070
the people table and link into cities or

00:11:36,570 --> 00:11:40,010
should I start from the cities table and

00:11:38,070 --> 00:11:42,150
link it to people

00:11:40,010 --> 00:11:44,100
users who hadn't been trained in data

00:11:42,150 --> 00:11:45,270
modelling got confused about this and

00:11:44,100 --> 00:11:46,590
they would often get it wrong they would

00:11:45,270 --> 00:11:48,060
get it backwards when they got it

00:11:46,590 --> 00:11:49,350
backwards they were confused and

00:11:48,060 --> 00:11:51,840
frustrated it wasn't really what they

00:11:49,350 --> 00:11:55,020
wanted so after dozens of these tests

00:11:51,840 --> 00:11:58,470
and seeing a lot of people upset we we

00:11:55,020 --> 00:11:59,760
eventually moved to a model that we call

00:11:58,470 --> 00:12:03,090
bi-directional or symmetric

00:11:59,760 --> 00:12:04,770
relationships um so narrow in field book

00:12:03,090 --> 00:12:06,450
when you whether you start from the

00:12:04,770 --> 00:12:08,370
people table and link to sidious or

00:12:06,450 --> 00:12:10,680
start from cities and link to people you

00:12:08,370 --> 00:12:13,050
end up with the same result so it's

00:12:10,680 --> 00:12:14,520
impossible to get it wrong it's a good

00:12:13,050 --> 00:12:15,840
principle of making things user friendly

00:12:14,520 --> 00:12:18,090
if there's a choice the user doesn't

00:12:15,840 --> 00:12:21,810
have to make eliminate it that way they

00:12:18,090 --> 00:12:23,100
can't make it wrong so so going back to

00:12:21,810 --> 00:12:25,380
the first example when I link to these

00:12:23,100 --> 00:12:28,080
two I link to this city column to the

00:12:25,380 --> 00:12:30,300
city's table and a people column was

00:12:28,080 --> 00:12:32,190
automatically created and these two

00:12:30,300 --> 00:12:33,990
columns are the dual of each other and

00:12:32,190 --> 00:12:36,360
they're automatically kept in sync so if

00:12:33,990 --> 00:12:38,610
I add Alice to New York here and then I

00:12:36,360 --> 00:12:41,550
go back to the people table New York has

00:12:38,610 --> 00:12:43,470
been added to Alice and so both sides of

00:12:41,550 --> 00:12:45,630
the link are kept in sync automatically

00:12:43,470 --> 00:12:47,670
as you edit them essentially what we've

00:12:45,630 --> 00:12:49,260
done is there's an implicit join table

00:12:47,670 --> 00:12:51,360
right that that third table that

00:12:49,260 --> 00:12:55,610
intermediate table it's behind the

00:12:51,360 --> 00:12:55,610
scenes and it's being managed for you

00:12:56,720 --> 00:13:05,240
all right so now we've solved relational

00:12:59,790 --> 00:13:07,320
modelling right there's a catch I

00:13:05,240 --> 00:13:09,540
slipped something by you in the

00:13:07,320 --> 00:13:13,080
beginning I glossed over the hardest

00:13:09,540 --> 00:13:14,700
part of the problem the first thing I

00:13:13,080 --> 00:13:16,200
said was that instead of making links

00:13:14,700 --> 00:13:20,250
based on numeric ideas we're going to

00:13:16,200 --> 00:13:21,220
make them based on names we're done

00:13:20,250 --> 00:13:23,800
Eames come from

00:13:21,220 --> 00:13:25,569
how do you name a record this turns out

00:13:23,800 --> 00:13:27,250
to be like a deep ontological question

00:13:25,569 --> 00:13:29,110
right it's it turns out to actually

00:13:27,250 --> 00:13:31,089
require a lot of domain knowledge to

00:13:29,110 --> 00:13:33,519
choose the right name for something and

00:13:31,089 --> 00:13:35,740
this is not at all something that comes

00:13:33,519 --> 00:13:38,019
naturally to people like understanding

00:13:35,740 --> 00:13:41,139
what this choice is and how to configure

00:13:38,019 --> 00:13:43,569
this correctly it's tough so if there's

00:13:41,139 --> 00:13:47,500
any things is hard this is a classic

00:13:43,569 --> 00:13:50,079
quip a saying that goes around in

00:13:47,500 --> 00:13:51,459
computer circles they've two hard things

00:13:50,079 --> 00:13:53,490
and computer science and naming of

00:13:51,459 --> 00:13:55,689
naming things is one of them very true

00:13:53,490 --> 00:13:58,360
so one of the things that makes it hard

00:13:55,689 --> 00:14:00,459
is that name isn't even always the right

00:13:58,360 --> 00:14:02,529
term so people and organizations have

00:14:00,459 --> 00:14:03,970
names cities and countries maybe but you

00:14:02,529 --> 00:14:06,569
know books and movies it's really a

00:14:03,970 --> 00:14:09,069
title you call it the title not the name

00:14:06,569 --> 00:14:11,019
sometimes there isn't a single column

00:14:09,069 --> 00:14:12,850
that that is the right name or

00:14:11,019 --> 00:14:14,379
identifier or descriptor for something

00:14:12,850 --> 00:14:16,870
so if you're talking about types of cars

00:14:14,379 --> 00:14:18,040
you might have make model and year right

00:14:16,870 --> 00:14:19,990
or there could be a similar thing for

00:14:18,040 --> 00:14:21,310
wine or sometimes you just want

00:14:19,990 --> 00:14:22,750
sometimes you've got people that you

00:14:21,310 --> 00:14:26,290
just want to split out first name and

00:14:22,750 --> 00:14:28,089
last name some things don't have any

00:14:26,290 --> 00:14:29,439
natural attribute that serves to

00:14:28,089 --> 00:14:32,050
identify them and so we make up

00:14:29,439 --> 00:14:33,490
artificial attributes IDs right so if

00:14:32,050 --> 00:14:35,290
you place an order with a retailer

00:14:33,490 --> 00:14:38,610
you'll probably get a numeric order ID

00:14:35,290 --> 00:14:41,259
for that just as a handle to refer to it

00:14:38,610 --> 00:14:43,240
and other things don't even have

00:14:41,259 --> 00:14:44,980
explicit IDs that we think we're talked

00:14:43,240 --> 00:14:46,959
about so if if you had multiple line

00:14:44,980 --> 00:14:49,509
items in that order each one would be

00:14:46,959 --> 00:14:51,339
its own entity in a database but you

00:14:49,509 --> 00:14:53,230
don't talk about a line item ID it's a

00:14:51,339 --> 00:14:55,059
it's a hidden thing that that the end

00:14:53,230 --> 00:14:56,250
user doesn't really even generally need

00:14:55,059 --> 00:14:59,079
to know

00:14:56,250 --> 00:15:00,459
so just communicating the concept to end

00:14:59,079 --> 00:15:02,769
users is difficult getting them to

00:15:00,459 --> 00:15:05,500
select the right thing is difficult we

00:15:02,769 --> 00:15:07,689
went through a lot of failed attempts so

00:15:05,500 --> 00:15:10,449
in an early version of field book you

00:15:07,689 --> 00:15:12,490
could select any column to be the

00:15:10,449 --> 00:15:16,870
quote-unquote name column and we had

00:15:12,490 --> 00:15:18,790
this option in the menu here and so in a

00:15:16,870 --> 00:15:21,129
people table you could go to the age

00:15:18,790 --> 00:15:22,930
column and say use this as the name

00:15:21,129 --> 00:15:24,879
column and people had no idea what that

00:15:22,930 --> 00:15:26,500
meant so they would just pick it to see

00:15:24,879 --> 00:15:28,480
what it did and then it didn't do

00:15:26,500 --> 00:15:29,920
anything that was obvious so then they

00:15:28,480 --> 00:15:31,149
would just leave it that way and then

00:15:29,920 --> 00:15:33,089
they would go to some other sheet and

00:15:31,149 --> 00:15:35,579
people would suddenly be numbers

00:15:33,089 --> 00:15:38,339
you just just give up at that point

00:15:35,579 --> 00:15:39,990
right um we had as we thought maybe it

00:15:38,339 --> 00:15:42,199
would be more obvious if instead of

00:15:39,990 --> 00:15:44,670
choosing a column maybe if you were

00:15:42,199 --> 00:15:48,120
configuring the title on a detailed page

00:15:44,670 --> 00:15:50,490
so maybe on for a task you could choose

00:15:48,120 --> 00:15:52,949
one of the fields to be like the title

00:15:50,490 --> 00:15:56,610
and we tried to make it anyway this is

00:15:52,949 --> 00:15:58,769
all so confusing people don't know do we

00:15:56,610 --> 00:16:01,889
had another version where she started

00:15:58,769 --> 00:16:04,139
off with no name column just IDs and

00:16:01,889 --> 00:16:05,999
then this was a total disaster because

00:16:04,139 --> 00:16:07,410
people would make a link and then they

00:16:05,999 --> 00:16:08,999
would try to start Auto completing to

00:16:07,410 --> 00:16:12,329
fill in the link and they would just get

00:16:08,999 --> 00:16:14,069
a list of ID's like person 1 2 3 4 and

00:16:12,329 --> 00:16:17,999
they would just be what is this I give

00:16:14,069 --> 00:16:20,670
up so we even designed this super

00:16:17,999 --> 00:16:22,170
complicated configuration dialog at one

00:16:20,670 --> 00:16:24,990
point that we had this plan it was going

00:16:22,170 --> 00:16:28,019
to pop up when you made a link and force

00:16:24,990 --> 00:16:30,180
you to configure the name column before

00:16:28,019 --> 00:16:33,240
the link was we came to our senses

00:16:30,180 --> 00:16:35,790
before we implemented this and what

00:16:33,240 --> 00:16:38,040
finally worked more or less is to just

00:16:35,790 --> 00:16:40,620
say hey look the first column is just

00:16:38,040 --> 00:16:42,120
the name always write whatever you put

00:16:40,620 --> 00:16:43,379
in the first column it's like a special

00:16:42,120 --> 00:16:48,149
column and we're just going to use that

00:16:43,379 --> 00:16:51,689
for the record identifier this people

00:16:48,149 --> 00:16:53,670
pretty much get is this one problem

00:16:51,689 --> 00:16:55,620
which is doesn't actually match all

00:16:53,670 --> 00:16:56,399
those scenarios that I talked about

00:16:55,620 --> 00:16:58,620
earlier right

00:16:56,399 --> 00:17:00,839
it works well for names and titles that

00:16:58,620 --> 00:17:02,370
just are in a single field it doesn't

00:17:00,839 --> 00:17:04,380
work really well when you've got like

00:17:02,370 --> 00:17:05,760
multiple columns you want to combine it

00:17:04,380 --> 00:17:07,949
doesn't work well when you want to sort

00:17:05,760 --> 00:17:10,159
of create an artificial ID or something

00:17:07,949 --> 00:17:13,199
or when things don't have names at all

00:17:10,159 --> 00:17:17,880
so the new model that we're moving

00:17:13,199 --> 00:17:19,319
towards and beta testing now is that you

00:17:17,880 --> 00:17:22,439
can actually have multiple name fields

00:17:19,319 --> 00:17:23,939
so let me pop out and demo this so here

00:17:22,439 --> 00:17:25,860
is a version of the thing that we're

00:17:23,939 --> 00:17:28,049
that we're working on so in this example

00:17:25,860 --> 00:17:30,480
you've got people but you have a first

00:17:28,049 --> 00:17:32,070
name and last name and so you've got

00:17:30,480 --> 00:17:34,919
this sort of line that you can drag

00:17:32,070 --> 00:17:37,169
around to say okay which how many

00:17:34,919 --> 00:17:39,390
columns am I going to use basically for

00:17:37,169 --> 00:17:41,070
a name and so in this case it's two of

00:17:39,390 --> 00:17:42,360
them and again this is linked to cities

00:17:41,070 --> 00:17:44,280
when I go to cities table you'll see

00:17:42,360 --> 00:17:46,120
that it's using both the first and last

00:17:44,280 --> 00:17:48,190
name to create the ID

00:17:46,120 --> 00:17:50,950
just have one name so the the line is

00:17:48,190 --> 00:17:52,780
just right here and then say we wanted

00:17:50,950 --> 00:17:54,820
to track people visiting cities on

00:17:52,780 --> 00:17:56,620
different dates and so forth that

00:17:54,820 --> 00:17:58,090
doesn't really need a name I don't know

00:17:56,620 --> 00:18:00,520
you know what would you call this right

00:17:58,090 --> 00:18:01,900
so instead we just drag the line all the

00:18:00,520 --> 00:18:04,240
way over to the left and we have zero

00:18:01,900 --> 00:18:06,040
name columns and if you absolutely need

00:18:04,240 --> 00:18:09,730
to refer to a visit it'll get a numeric

00:18:06,040 --> 00:18:11,680
ID so this is something where we're just

00:18:09,730 --> 00:18:13,360
implementing and beta testing but I'm

00:18:11,680 --> 00:18:15,340
optimistic about this in our early

00:18:13,360 --> 00:18:25,630
dogfooding it feels really like the

00:18:15,340 --> 00:18:28,720
right model so to sum up the traditional

00:18:25,630 --> 00:18:32,170
sequel model gives you statically typed

00:18:28,720 --> 00:18:36,040
columns relationships based on a foreign

00:18:32,170 --> 00:18:37,840
key model that give you therefore one

00:18:36,040 --> 00:18:40,780
too many or belongs to type

00:18:37,840 --> 00:18:42,850
relationships where the inverse

00:18:40,780 --> 00:18:45,640
relationship that has many is implicit

00:18:42,850 --> 00:18:49,210
and the whole thing is based typically

00:18:45,640 --> 00:18:51,340
on numeric IDs taking a more user

00:18:49,210 --> 00:18:54,730
centered approach leads you to a model

00:18:51,340 --> 00:18:58,840
with dynamically typed columns links

00:18:54,730 --> 00:19:02,980
instead of keys or IDs many to many

00:18:58,840 --> 00:19:04,750
relationships by default that explicitly

00:19:02,980 --> 00:19:07,360
bi-directional thing where you can see

00:19:04,750 --> 00:19:08,920
both sides of every relationship and the

00:19:07,360 --> 00:19:11,140
whole thing based on record

00:19:08,920 --> 00:19:17,200
quote/unquote names which themselves are

00:19:11,140 --> 00:19:19,570
based on 0 or more columns taking this

00:19:17,200 --> 00:19:21,970
user centric approach as our compass as

00:19:19,570 --> 00:19:23,559
our as our North Star I believe there

00:19:21,970 --> 00:19:26,050
are many technical tasks we can make

00:19:23,559 --> 00:19:29,020
much more accessible to end-users not

00:19:26,050 --> 00:19:31,990
just data modeling but sophisticated

00:19:29,020 --> 00:19:34,510
imports and exports transformations

00:19:31,990 --> 00:19:38,050
aggregations reports and ultimately even

00:19:34,510 --> 00:19:42,010
coding itself and that's how we bring

00:19:38,050 --> 00:19:44,590
about a world of builders thank you

00:19:42,010 --> 00:19:46,650
[Applause]

00:19:44,590 --> 00:19:46,650

YouTube URL: https://www.youtube.com/watch?v=Plb_9XeIYHE


