Title: Mike Bostock - Keynote - CSVConf 2017
Publication date: 2017-05-27
Playlist: CSVConf 2017 - Day 2 - Chapel
Description: 
	
Captions: 
	00:00:00,100 --> 00:00:17,020
a quiet but warm welcome for Mike

00:00:07,930 --> 00:00:19,300
Bostock everyone all right thank you so

00:00:17,020 --> 00:00:20,920
if you've ever gotten frustrated trying

00:00:19,300 --> 00:00:24,520
to figure out why your code didn't work

00:00:20,920 --> 00:00:27,100
or how someone else's code work maybe it

00:00:24,520 --> 00:00:30,340
was my code and it's so sorry you are

00:00:27,100 --> 00:00:32,289
not alone and this talk is for you

00:00:30,340 --> 00:00:34,690
you know it's max mentioned for the last

00:00:32,289 --> 00:00:37,510
eight years or so I mean how you count

00:00:34,690 --> 00:00:40,179
I've been building tools for visualizing

00:00:37,510 --> 00:00:43,269
information and the most successful

00:00:40,179 --> 00:00:45,729
outcome of this effort has been this d3

00:00:43,269 --> 00:00:48,219
JavaScript library for a visualization I

00:00:45,729 --> 00:00:51,100
mean I've spent far more work than I

00:00:48,219 --> 00:00:53,350
expected on this and when I made that

00:00:51,100 --> 00:00:54,760
initial commit but I mean that in a good

00:00:53,350 --> 00:00:56,519
way I mean it's been really exciting to

00:00:54,760 --> 00:00:58,959
see what people have done with it

00:00:56,519 --> 00:01:01,299
but there's a danger when you spend so

00:00:58,959 --> 00:01:03,579
long designing a single tool and that is

00:01:01,299 --> 00:01:05,560
that you may forget what the tool is for

00:01:03,579 --> 00:01:07,930
right the tool itself becomes the goal

00:01:05,560 --> 00:01:10,630
rather than the value derived from its

00:01:07,930 --> 00:01:12,159
application so the purpose of a tool for

00:01:10,630 --> 00:01:14,890
visualization is to construct

00:01:12,159 --> 00:01:18,240
visualizations but what is the purpose

00:01:14,890 --> 00:01:21,070
of visualization so in ben shneiderman

00:01:18,240 --> 00:01:23,409
the purpose of visualization is insight

00:01:21,070 --> 00:01:25,149
not pictures it's actually an adaptation

00:01:23,409 --> 00:01:27,280
of a Richard Hannon quote which is the

00:01:25,149 --> 00:01:29,289
purpose of computing is insight not

00:01:27,280 --> 00:01:31,899
numbers so the point here is that

00:01:29,289 --> 00:01:35,140
visualization is also a tool it is a

00:01:31,899 --> 00:01:38,770
means to an end a means to insight a way

00:01:35,140 --> 00:01:40,899
to think to study understand to discover

00:01:38,770 --> 00:01:43,390
to communicate something about the world

00:01:40,899 --> 00:01:45,670
so if we only consider the task of

00:01:43,390 --> 00:01:48,549
constructing visualizations of assigning

00:01:45,670 --> 00:01:50,579
visual encodings when we ignore myriad

00:01:48,549 --> 00:01:53,140
other challenges finding relevant data

00:01:50,579 --> 00:01:55,170
cleaning it transforming it into

00:01:53,140 --> 00:01:57,819
efficient structures for analysis

00:01:55,170 --> 00:01:59,530
designing statistical analysis building

00:01:57,819 --> 00:02:02,259
models validating those models and

00:01:59,530 --> 00:02:04,740
ultimately communicating whatever it is

00:02:02,259 --> 00:02:08,080
that we learned in that process and

00:02:04,740 --> 00:02:11,290
these tasks are often performed in code

00:02:08,080 --> 00:02:13,360
and coding is famously difficult

00:02:11,290 --> 00:02:15,909
even the name code suggests

00:02:13,360 --> 00:02:18,250
impenetrability right code originally

00:02:15,909 --> 00:02:21,040
referred to machine code with low level

00:02:18,250 --> 00:02:24,040
digital instructions sent to be executed

00:02:21,040 --> 00:02:25,659
by a processing unit and code has come a

00:02:24,040 --> 00:02:26,640
long way since that you know it's much

00:02:25,659 --> 00:02:30,069
more human-friendly

00:02:26,640 --> 00:02:31,870
but it's got a long way to go I kind of

00:02:30,069 --> 00:02:33,400
love this image I mean to me it's like

00:02:31,870 --> 00:02:35,829
the fantasy of the developer when

00:02:33,400 --> 00:02:37,090
they're writing code but it's also a

00:02:35,829 --> 00:02:38,530
little bit strange because it's like

00:02:37,090 --> 00:02:40,930
it's a robot I mean why is the robot

00:02:38,530 --> 00:02:43,209
typing can it just like plug in and some

00:02:40,930 --> 00:02:45,280
device directly to the computer it's

00:02:43,209 --> 00:02:47,620
like the robot is being forced to use

00:02:45,280 --> 00:02:52,090
the human interface rather than

00:02:47,620 --> 00:02:54,940
vice-versa okay to give a comically

00:02:52,090 --> 00:02:57,220
dense example this is a Bosch command I

00:02:54,940 --> 00:03:00,760
wrote recently to generate a choropleth

00:02:57,220 --> 00:03:02,409
of population density of California the

00:03:00,760 --> 00:03:06,190
rest of the talk will just be this slide

00:03:02,409 --> 00:03:08,920
and I'm going to walk you through all 15

00:03:06,190 --> 00:03:10,599
commands here let me kind of funny I

00:03:08,920 --> 00:03:12,609
mean look at this like what what is it

00:03:10,599 --> 00:03:15,549
doing exactly if you look at it and you

00:03:12,609 --> 00:03:17,169
think it starts with this go2 topo right

00:03:15,549 --> 00:03:19,299
this is converting Gio Jason to tapa

00:03:17,169 --> 00:03:21,849
Jason but that's not really where this

00:03:19,299 --> 00:03:24,489
program starts because that takes like

00:03:21,849 --> 00:03:26,169
this giant thing is input and then that

00:03:24,489 --> 00:03:29,049
command actually takes like these two

00:03:26,169 --> 00:03:31,269
things is input so there are multiple

00:03:29,049 --> 00:03:33,609
levels of nesting here there's like

00:03:31,269 --> 00:03:36,190
these weird sort of punctuation marks

00:03:33,609 --> 00:03:39,549
what do they mean there are these

00:03:36,190 --> 00:03:42,940
abbreviations like - P and - F and of

00:03:39,549 --> 00:03:44,290
course like the back slashes and if you

00:03:42,940 --> 00:03:46,030
notice there's actually two languages

00:03:44,290 --> 00:03:48,310
here like this is not just bash this is

00:03:46,030 --> 00:03:51,970
actually JavaScript expressions that are

00:03:48,310 --> 00:03:54,400
awkwardly embedded within bash but this

00:03:51,970 --> 00:03:55,870
is you know this isn't machine code like

00:03:54,400 --> 00:03:58,209
from the machines perspective this is

00:03:55,870 --> 00:04:01,599
extremely high level programming but

00:03:58,209 --> 00:04:03,040
it's it's hardly natural language so

00:04:01,599 --> 00:04:05,799
Bret Victor gives this concise

00:04:03,040 --> 00:04:09,129
definition of programming programming is

00:04:05,799 --> 00:04:11,290
blindly manipulating symbols and by

00:04:09,129 --> 00:04:13,419
blindly he means that we can't see the

00:04:11,290 --> 00:04:15,699
results of our manipulation right we can

00:04:13,419 --> 00:04:18,549
edit a program we can rerun it we can

00:04:15,699 --> 00:04:20,040
diff the output but programs are complex

00:04:18,549 --> 00:04:22,170
and dynamic and

00:04:20,040 --> 00:04:24,780
so this approach is not really a direct

00:04:22,170 --> 00:04:27,570
or an immediate observation of our edit

00:04:24,780 --> 00:04:29,280
and by symbol t means that we don't sort

00:04:27,570 --> 00:04:31,620
of directly manipulate the output of our

00:04:29,280 --> 00:04:34,230
programs we operate in abstractions and

00:04:31,620 --> 00:04:36,270
these abstractions can be powerful but

00:04:34,230 --> 00:04:38,280
they can also be difficult to grasp

00:04:36,270 --> 00:04:40,050
in other words or in Donald Norman's

00:04:38,280 --> 00:04:43,440
terms these are the Gulf of evaluation

00:04:40,050 --> 00:04:45,660
and the Gulf of execution okay but

00:04:43,440 --> 00:04:48,540
clearly some code is easier to

00:04:45,660 --> 00:04:49,800
understand than others and one of the

00:04:48,540 --> 00:04:52,290
things that I first thing covered in

00:04:49,800 --> 00:04:55,140
human code is spaghetti a spaghetti cook

00:04:52,290 --> 00:04:57,180
code that lacks structure or modularity

00:04:55,140 --> 00:04:58,740
where in order to understand one part of

00:04:57,180 --> 00:04:59,640
a program you have to understand the

00:04:58,740 --> 00:05:02,640
entire program

00:04:59,640 --> 00:05:04,530
it can't be disentangled and this is

00:05:02,640 --> 00:05:06,780
frequently caused by shared mutable

00:05:04,530 --> 00:05:08,520
state right when you have multiple parts

00:05:06,780 --> 00:05:10,530
of a program that are writing to the

00:05:08,520 --> 00:05:12,390
same piece of state it becomes much

00:05:10,530 --> 00:05:14,850
harder to reason about what that state

00:05:12,390 --> 00:05:18,090
value is and indeed how do we even know

00:05:14,850 --> 00:05:20,040
what programs do if we can't track the

00:05:18,090 --> 00:05:22,500
complete runtime state of a program in

00:05:20,040 --> 00:05:24,900
our head then reading code is

00:05:22,500 --> 00:05:27,720
insufficient right so we used logs to

00:05:24,900 --> 00:05:30,210
use debugger see tests but these tools

00:05:27,720 --> 00:05:32,100
are also limited debugger for example

00:05:30,210 --> 00:05:34,770
can only show you the value of a few

00:05:32,100 --> 00:05:36,840
symbols at a single moment in time so we

00:05:34,770 --> 00:05:41,250
can't reserve complex data structures or

00:05:36,840 --> 00:05:42,540
complex patterns of execution and in a

00:05:41,250 --> 00:05:44,790
way like we continue to have great

00:05:42,540 --> 00:05:48,360
difficulty understanding code and it's a

00:05:44,790 --> 00:05:50,280
miracle that anything works at all but

00:05:48,360 --> 00:05:51,870
despite these challenges we're still

00:05:50,280 --> 00:05:53,730
writing code you know for myriad

00:05:51,870 --> 00:05:56,810
applications and more than ever before

00:05:53,730 --> 00:06:00,450
and so why is that like are we masochist

00:05:56,810 --> 00:06:03,360
maybe are we unable to change I mean I

00:06:00,450 --> 00:06:04,350
think in part certainly some of us some

00:06:03,360 --> 00:06:07,830
more than others

00:06:04,350 --> 00:06:10,260
is there no better solution and in

00:06:07,830 --> 00:06:13,620
general and that is the critical

00:06:10,260 --> 00:06:15,630
qualifier no code is often the best tool

00:06:13,620 --> 00:06:18,150
we have because because it is the most

00:06:15,630 --> 00:06:21,360
general tool we have code has almost

00:06:18,150 --> 00:06:23,100
unlimited expressiveness so alternatives

00:06:21,360 --> 00:06:25,590
to code as well as higher level

00:06:23,100 --> 00:06:28,410
programming interfaces and languages can

00:06:25,590 --> 00:06:30,870
do well in specific domains but these

00:06:28,410 --> 00:06:32,790
alternatives must sacrifice generality

00:06:30,870 --> 00:06:33,770
in order to achieve greater efficiency

00:06:32,790 --> 00:06:36,719
within their doing

00:06:33,770 --> 00:06:38,009
if you can't constrain the domain it's

00:06:36,719 --> 00:06:40,020
unlikely that you'll find a viable

00:06:38,009 --> 00:06:42,689
replacement for code there is no

00:06:40,020 --> 00:06:44,849
universal replacement at least not while

00:06:42,689 --> 00:06:47,610
humans primarily think and communicate

00:06:44,849 --> 00:06:49,349
through language and it's hard to

00:06:47,610 --> 00:06:52,099
constrain the domain of science science

00:06:49,349 --> 00:06:54,330
is fundamental it's studying the world

00:06:52,099 --> 00:06:56,189
extracting meaning from empirical

00:06:54,330 --> 00:06:59,039
observations simulating systems

00:06:56,189 --> 00:07:00,869
communicating quantitative results and a

00:06:59,039 --> 00:07:03,990
medium to support discovery must be

00:07:00,869 --> 00:07:06,330
capable of expressing novel thought just

00:07:03,990 --> 00:07:09,479
as we don't use phrasal templates or mad

00:07:06,330 --> 00:07:11,219
libs for composing the written word we

00:07:09,479 --> 00:07:12,869
can't be limited to chart templates for

00:07:11,219 --> 00:07:15,180
constructing visualizations or a

00:07:12,869 --> 00:07:17,449
drop-down of formulas for statistical

00:07:15,180 --> 00:07:20,459
analysis we need more than configuration

00:07:17,449 --> 00:07:24,240
we need the composition of primitives

00:07:20,459 --> 00:07:26,159
into creations of our own design so if

00:07:24,240 --> 00:07:28,409
our goal is to help people gain insight

00:07:26,159 --> 00:07:29,959
from observation we must consider the

00:07:28,409 --> 00:07:32,369
problem of how people code

00:07:29,959 --> 00:07:34,740
Brett Victor I will quote him several

00:07:32,369 --> 00:07:37,319
times in this talk have the following to

00:07:34,740 --> 00:07:40,019
say about math but it applies equally to

00:07:37,319 --> 00:07:42,149
code the power to understand and predict

00:07:40,019 --> 00:07:43,889
the quantities of the world should not

00:07:42,149 --> 00:07:46,789
be restricted to those with a freakish

00:07:43,889 --> 00:07:49,319
knack for manipulating abstract symbols

00:07:46,789 --> 00:07:51,209
the point here is that improving the

00:07:49,319 --> 00:07:52,559
human experience of coding is not just

00:07:51,209 --> 00:07:55,169
about making your work flow more

00:07:52,559 --> 00:07:57,559
convenient or more efficient it empowers

00:07:55,169 --> 00:08:00,659
people to better understand their world

00:07:57,559 --> 00:08:02,789
so if we can't eliminate coding can we

00:08:00,659 --> 00:08:04,829
at least make it easier for humans with

00:08:02,789 --> 00:08:08,879
our sausage fingers and our finite size

00:08:04,829 --> 00:08:11,639
brains to explore this question for the

00:08:08,879 --> 00:08:14,009
last six months or so I've been

00:08:11,639 --> 00:08:16,619
prototyping building this thing I call

00:08:14,009 --> 00:08:19,439
the integrated discovery environment d3

00:08:16,619 --> 00:08:21,749
express and it's for exploratory data

00:08:19,439 --> 00:08:23,550
analysis for understanding systems and

00:08:21,749 --> 00:08:26,009
algorithms for teaching and sharing

00:08:23,550 --> 00:08:28,800
techniques and code and for sharing

00:08:26,009 --> 00:08:30,719
interactive visual explanations I do

00:08:28,800 --> 00:08:32,969
want to make visualization easier and

00:08:30,719 --> 00:08:35,849
discovery easier but first we need to

00:08:32,969 --> 00:08:39,060
make coding easier now I cannot pretend

00:08:35,849 --> 00:08:41,819
to make coding easy the ideas we wish to

00:08:39,060 --> 00:08:45,000
express explain and explore may be

00:08:41,819 --> 00:08:45,810
irreducibly complex but by reducing the

00:08:45,000 --> 00:08:48,060
cognitive

00:08:45,810 --> 00:08:49,999
of coding my hope is to make the

00:08:48,060 --> 00:08:52,910
analysis of quantitative phenomena

00:08:49,999 --> 00:08:56,009
accessible to a wider audience

00:08:52,910 --> 00:08:59,670
now the first principle of d3 Express is

00:08:56,009 --> 00:09:01,829
reactivity rather than issuing commands

00:08:59,670 --> 00:09:03,540
to modify this shared state each piece

00:09:01,829 --> 00:09:05,939
of state in a reactive program defines

00:09:03,540 --> 00:09:08,490
how it is calculated and the runtime

00:09:05,939 --> 00:09:10,740
manages their evaluation it propagates

00:09:08,490 --> 00:09:12,689
derive state it's a lot of sort of

00:09:10,740 --> 00:09:14,339
technical words but if you've written

00:09:12,689 --> 00:09:17,279
spreadsheet formulas you've done

00:09:14,339 --> 00:09:19,620
reactive programming so here is a simple

00:09:17,279 --> 00:09:21,809
notebook in d3 Express to illustrate

00:09:19,620 --> 00:09:23,459
this concept it looks a little bit like

00:09:21,809 --> 00:09:25,470
the browsers developer console

00:09:23,459 --> 00:09:27,360
except here our work is saved

00:09:25,470 --> 00:09:29,600
automatically so that we can revisit in

00:09:27,360 --> 00:09:32,370
the future and share it with others

00:09:29,600 --> 00:09:35,220
right so in imperative programming C

00:09:32,370 --> 00:09:37,319
equals a plus B is a value assignment

00:09:35,220 --> 00:09:39,480
that means it takes the value of a adds

00:09:37,319 --> 00:09:42,420
it to the value of B and copies that

00:09:39,480 --> 00:09:44,220
into the symbol C and so an imperative

00:09:42,420 --> 00:09:46,230
programming if the value of a or B

00:09:44,220 --> 00:09:48,740
changes the value of C doesn't update

00:09:46,230 --> 00:09:52,589
until you recompute that same addition

00:09:48,740 --> 00:09:55,949
but in reactive programming C equals a

00:09:52,589 --> 00:09:57,540
plus B is a variable definition which

00:09:55,949 --> 00:10:00,300
means that as here when I change the

00:09:57,540 --> 00:10:03,449
value of B from 2 to 3 the value of C

00:10:00,300 --> 00:10:06,149
changes to 4 if I change a from 1 to 4

00:10:03,449 --> 00:10:09,139
again the value of C updates for change

00:10:06,149 --> 00:10:11,579
B to B Maps up random again it updates

00:10:09,139 --> 00:10:13,620
so the point here is that as programmers

00:10:11,579 --> 00:10:15,720
we now care only about the current state

00:10:13,620 --> 00:10:17,670
because the runtime manages state

00:10:15,720 --> 00:10:18,870
changes and that's a small thing when

00:10:17,670 --> 00:10:21,059
you're only adding two numbers together

00:10:18,870 --> 00:10:23,759
but when you have larger programs this

00:10:21,059 --> 00:10:25,889
eliminates a substantial burden of

00:10:23,759 --> 00:10:28,050
course discovery environment needs to do

00:10:25,889 --> 00:10:30,209
more than add a few numbers so let's try

00:10:28,050 --> 00:10:32,220
working with data we're going to load d3

00:10:30,209 --> 00:10:34,860
and because this is a CSV conf we're

00:10:32,220 --> 00:10:36,569
going to load a CSV and then we want to

00:10:34,860 --> 00:10:40,379
see what that is so we can click and

00:10:36,569 --> 00:10:43,139
inspect but already there's some cool

00:10:40,379 --> 00:10:45,720
stuff too tapping here so one is that

00:10:43,139 --> 00:10:47,639
requiring d3 loading d3 and likewise

00:10:45,720 --> 00:10:50,309
fetching this data they're asynchronous

00:10:47,639 --> 00:10:51,779
operations now if you don't know what

00:10:50,309 --> 00:10:52,889
that is it kind of doesn't matter that's

00:10:51,779 --> 00:10:56,259
the beautiful thing about this because

00:10:52,889 --> 00:10:58,389
you can treat this reactive code

00:10:56,259 --> 00:11:00,729
as if it were synchronous code meaning

00:10:58,389 --> 00:11:03,100
that anything that depends on d3 in this

00:11:00,729 --> 00:11:05,649
notebook doesn't get evaluated until d3

00:11:03,100 --> 00:11:07,059
is loaded and likewise any expression

00:11:05,649 --> 00:11:09,609
that you write that refers to the data

00:11:07,059 --> 00:11:12,040
won't get via won't be evaluated until

00:11:09,609 --> 00:11:14,079
the data is loaded and this avoids the

00:11:12,040 --> 00:11:15,699
sort of famous challenge of callback

00:11:14,079 --> 00:11:19,239
hell that you get with imperative

00:11:15,699 --> 00:11:21,100
asynchronous code so what does the data

00:11:19,239 --> 00:11:24,549
look like we can click we can inspect

00:11:21,100 --> 00:11:26,169
and just open it up here one of the

00:11:24,549 --> 00:11:28,089
things that you'll notice is that these

00:11:26,169 --> 00:11:29,859
fields they're all strings right so the

00:11:28,089 --> 00:11:33,039
date is a string in the closed field is

00:11:29,859 --> 00:11:35,499
a string this is stock data for like the

00:11:33,039 --> 00:11:39,129
last four five years or so of like Apple

00:11:35,499 --> 00:11:40,149
stock daily closes in order to work with

00:11:39,129 --> 00:11:41,919
this data one of the things that we're

00:11:40,149 --> 00:11:43,809
going to have to do is convert this from

00:11:41,919 --> 00:11:45,100
string type to a more precise type like

00:11:43,809 --> 00:11:47,079
we want to work with numbers we want to

00:11:45,100 --> 00:11:49,779
work updates so what I'm doing right now

00:11:47,079 --> 00:11:51,369
is I'm passing in this row access or

00:11:49,779 --> 00:11:54,220
function to try to specify what those

00:11:51,369 --> 00:11:56,709
types are you notice when I go in here

00:11:54,220 --> 00:11:59,109
indeed close I put the little plus sign

00:11:56,709 --> 00:12:01,059
in front of that that is JavaScript's

00:11:59,109 --> 00:12:03,970
way of converting a string into a number

00:12:01,059 --> 00:12:05,470
it's a unary plus operator and the point

00:12:03,970 --> 00:12:06,850
here is that as I make that change

00:12:05,470 --> 00:12:09,220
you're immediately seeing what the

00:12:06,850 --> 00:12:11,829
result is so we're still doing sort of

00:12:09,220 --> 00:12:13,089
abstract symbol manipulation here but at

00:12:11,829 --> 00:12:14,319
least we're doing that less blindly

00:12:13,089 --> 00:12:16,720
because we're seeing the result

00:12:14,319 --> 00:12:18,459
immediately so we can do the same thing

00:12:16,720 --> 00:12:20,139
with dates except JavaScript doesn't

00:12:18,459 --> 00:12:22,239
sort of have native support for parsing

00:12:20,139 --> 00:12:24,069
this date format so what would happen if

00:12:22,239 --> 00:12:26,410
we just called a hypothetical function

00:12:24,069 --> 00:12:27,669
called parse time well we can call it

00:12:26,410 --> 00:12:29,410
and of course it returns an error

00:12:27,669 --> 00:12:31,989
because that is not defined it's not

00:12:29,410 --> 00:12:33,759
sort of a built in primitive but this

00:12:31,989 --> 00:12:35,529
kind of raises another point which is

00:12:33,759 --> 00:12:37,329
that the errors that you see in these

00:12:35,529 --> 00:12:38,829
notebooks there are no longer global

00:12:37,329 --> 00:12:41,199
errors they don't bring your whole

00:12:38,829 --> 00:12:42,639
program to a halt the other cells that

00:12:41,199 --> 00:12:45,159
you have in your notebook can continue

00:12:42,639 --> 00:12:46,989
to run and these errors are temporary so

00:12:45,159 --> 00:12:49,169
that when I go in and I define parse

00:12:46,989 --> 00:12:51,249
time the error automatically goes away

00:12:49,169 --> 00:12:53,259
so again this is one of the things that

00:12:51,249 --> 00:12:54,339
reactive programming gets you in in

00:12:53,259 --> 00:12:56,259
terms of being more structured

00:12:54,339 --> 00:12:58,119
programming it's a bit like when your

00:12:56,259 --> 00:13:00,220
formulas in your spreadsheet they just

00:12:58,119 --> 00:13:02,949
say invalid value but Excel doesn't

00:13:00,220 --> 00:13:05,559
crash when you mistyped the formula so

00:13:02,949 --> 00:13:06,680
here I've changed I've defined my date

00:13:05,559 --> 00:13:09,230
parser and now I

00:13:06,680 --> 00:13:11,450
have nice green dates in my data set and

00:13:09,230 --> 00:13:14,779
now I can start to ask questions of my

00:13:11,450 --> 00:13:19,490
data so I'll use d3 for that also you do

00:13:14,779 --> 00:13:20,990
to extent the data no D date but this

00:13:19,490 --> 00:13:22,760
raise is not a point which is that I

00:13:20,990 --> 00:13:24,260
actually forgot to give the data set a

00:13:22,760 --> 00:13:26,110
name I give the data a name and then it

00:13:24,260 --> 00:13:28,250
automatically reevaluate that and this

00:13:26,110 --> 00:13:31,100
raises another interesting feature here

00:13:28,250 --> 00:13:33,500
which is that this notebook is now order

00:13:31,100 --> 00:13:35,630
independence because it understands the

00:13:33,500 --> 00:13:37,070
references between these cells you can

00:13:35,630 --> 00:13:39,500
write the code in any order that you

00:13:37,070 --> 00:13:41,510
want so I can refer to data up here in

00:13:39,500 --> 00:13:44,330
this cell but the data isn't defined

00:13:41,510 --> 00:13:45,740
until down here this is useful for sort

00:13:44,330 --> 00:13:48,220
of having a cleaner structure to your

00:13:45,740 --> 00:13:50,120
code it's also useful when you go to

00:13:48,220 --> 00:13:52,010
publish your results you want to

00:13:50,120 --> 00:13:53,810
communicate those with other people you

00:13:52,010 --> 00:13:55,459
have total freedom in terms of how you

00:13:53,810 --> 00:13:56,779
order your code and how you explain it

00:13:55,459 --> 00:13:59,480
you're not required to for example put

00:13:56,779 --> 00:14:02,270
all of your requires or your imports at

00:13:59,480 --> 00:14:03,740
the top of the file you can just let the

00:14:02,270 --> 00:14:09,290
narrative determine how you want to

00:14:03,740 --> 00:14:11,810
order the code so like the developer

00:14:09,290 --> 00:14:14,660
console the output of each cell is

00:14:11,810 --> 00:14:16,339
visible immediately below that cell but

00:14:14,660 --> 00:14:18,560
unlike the developer console we can have

00:14:16,339 --> 00:14:20,630
visual outputs so now I want to take the

00:14:18,560 --> 00:14:22,850
same data and make a little line chart

00:14:20,630 --> 00:14:24,440
out of it so I'm going to define the

00:14:22,850 --> 00:14:27,730
width and height and the margins for

00:14:24,440 --> 00:14:32,209
that is like three different variables

00:14:27,730 --> 00:14:34,190
then go up look at our data the extents

00:14:32,209 --> 00:14:37,010
that we computed and turn those into

00:14:34,190 --> 00:14:39,170
domains of the scale so these scales d3

00:14:37,010 --> 00:14:41,750
concept and its mapping sort of these

00:14:39,170 --> 00:14:44,480
abstract dimensions of data to visual

00:14:41,750 --> 00:14:46,610
encodings here like a position in X&Y

00:14:44,480 --> 00:14:51,770
so I'm just updating those definitions

00:14:46,610 --> 00:14:54,470
and once those are defined we can create

00:14:51,770 --> 00:14:56,570
an SVG element to contain the output of

00:14:54,470 --> 00:14:58,100
our chart and use the curly braces

00:14:56,570 --> 00:15:00,320
because this will be a little bit more

00:14:58,100 --> 00:15:02,180
of an involved definition than the other

00:15:00,320 --> 00:15:04,040
ones which your expressions so now I can

00:15:02,180 --> 00:15:06,770
sort of put more JavaScript code in here

00:15:04,040 --> 00:15:09,050
and I'm using d3 select to do that and

00:15:06,770 --> 00:15:10,459
I've got this like Dom de SVG I mean the

00:15:09,050 --> 00:15:12,470
details aren't really that important but

00:15:10,459 --> 00:15:14,860
this is really just creating a SVG

00:15:12,470 --> 00:15:17,560
element of the given width and height

00:15:14,860 --> 00:15:19,240
returning that and that's sort of the

00:15:17,560 --> 00:15:22,360
basics that we're just working with like

00:15:19,240 --> 00:15:23,710
web standards here in vanilla Dom so the

00:15:22,360 --> 00:15:25,480
first thing I want to do for this chart

00:15:23,710 --> 00:15:27,310
is to make sure that my sort of

00:15:25,480 --> 00:15:29,590
dimensions of data look correct so I

00:15:27,310 --> 00:15:32,200
plug in the axis here and by default

00:15:29,590 --> 00:15:34,630
like an axis in d3 is going to be rooted

00:15:32,200 --> 00:15:36,820
at the origin which is 0 0 in the top

00:15:34,630 --> 00:15:38,200
left corner and so I want to shift that

00:15:36,820 --> 00:15:40,030
down so that it's on the bottom of my

00:15:38,200 --> 00:15:43,780
chart so I go in here and I click the

00:15:40,030 --> 00:15:46,320
transform attribute on my G element and

00:15:43,780 --> 00:15:50,740
I give it the right sort of height minus

00:15:46,320 --> 00:15:52,600
margin bottom and so then that moves

00:15:50,740 --> 00:15:53,290
down a little bit off screen here but

00:15:52,600 --> 00:15:55,630
you get the idea

00:15:53,290 --> 00:15:58,840
likewise I can make the left axis here

00:15:55,630 --> 00:16:02,230
for the y scale and then put that on the

00:15:58,840 --> 00:16:04,150
left side of the chart ok so now we have

00:16:02,230 --> 00:16:06,010
our little axes and now we want to

00:16:04,150 --> 00:16:06,970
actually draw the data we want to see

00:16:06,010 --> 00:16:09,610
the data we're going to need path

00:16:06,970 --> 00:16:11,590
element for that path elements in SVG

00:16:09,610 --> 00:16:13,210
require this D attribute which tends to

00:16:11,590 --> 00:16:15,310
be this complicated thing this is a

00:16:13,210 --> 00:16:17,650
whole like micro language in SVG for

00:16:15,310 --> 00:16:19,390
making these things we would don't want

00:16:17,650 --> 00:16:20,830
to do that by hand so there's a d3 line

00:16:19,390 --> 00:16:23,410
primitive and we're going to pass our

00:16:20,830 --> 00:16:27,550
data to that line function in order to

00:16:23,410 --> 00:16:28,620
construct the geometry for the chart so

00:16:27,550 --> 00:16:31,150
I'll do that now

00:16:28,620 --> 00:16:34,590
that's configurable again so we're going

00:16:31,150 --> 00:16:36,610
to pass in our X scale and the

00:16:34,590 --> 00:16:42,160
corresponding like value from the data

00:16:36,610 --> 00:16:43,570
so x and y here okay so that shows up

00:16:42,160 --> 00:16:46,180
obviously it doesn't look correct

00:16:43,570 --> 00:16:48,700
that's because passed an SVG or filled

00:16:46,180 --> 00:16:50,890
black by default and we want to stroke

00:16:48,700 --> 00:16:53,020
stroke it for a line chart so again

00:16:50,890 --> 00:16:59,230
we'll go in here and we'll set the fill

00:16:53,020 --> 00:17:01,030
style to none and the stroke to blue ok

00:16:59,230 --> 00:17:04,480
so now we have a basic little line chart

00:17:01,030 --> 00:17:06,880
here with a few few different cells ok

00:17:04,480 --> 00:17:09,670
but even though this is a basic line

00:17:06,880 --> 00:17:12,040
chart the program's topology is starting

00:17:09,670 --> 00:17:14,500
to become more complex so this is a

00:17:12,040 --> 00:17:16,150
directed acyclic graph of references

00:17:14,500 --> 00:17:18,490
within this notebook so this is showing

00:17:16,150 --> 00:17:20,710
you the structure of the program and

00:17:18,490 --> 00:17:22,840
this visualization was itself made in d3

00:17:20,710 --> 00:17:25,240
express using grasses there's a command

00:17:22,840 --> 00:17:27,220
you can run to produce this thing

00:17:25,240 --> 00:17:28,600
so you've got the require at the top

00:17:27,220 --> 00:17:31,540
that's how you load the libraries it

00:17:28,600 --> 00:17:33,610
generates d3 and then we use d3 to make

00:17:31,540 --> 00:17:36,010
our time parsing function we also use

00:17:33,610 --> 00:17:38,320
that to parse the data and load the data

00:17:36,010 --> 00:17:40,570
we've got your wit types and margins

00:17:38,320 --> 00:17:42,640
those feed into the x and y scales and

00:17:40,570 --> 00:17:44,590
then basically everything feeds into the

00:17:42,640 --> 00:17:48,760
SVG node which doesn't have a name so

00:17:44,590 --> 00:17:51,400
it's just number 93 at the bottom so a

00:17:48,760 --> 00:17:53,320
few observations of this chart so one

00:17:51,400 --> 00:17:54,940
thing is that is now trivial to make

00:17:53,320 --> 00:17:56,950
this chart responsive right the width

00:17:54,940 --> 00:17:59,320
height and margins are constants of

00:17:56,950 --> 00:18:01,120
these as we've defined them but if we

00:17:59,320 --> 00:18:02,620
change them so that they were the size

00:18:01,120 --> 00:18:04,120
of the screen or the size of the window

00:18:02,620 --> 00:18:06,280
then the chart would update

00:18:04,120 --> 00:18:07,990
automatically and likewise we can

00:18:06,280 --> 00:18:10,420
replace the data definition so rather

00:18:07,990 --> 00:18:12,100
than a static definition maybe we want a

00:18:10,420 --> 00:18:13,540
real-time chart and so that's just a

00:18:12,100 --> 00:18:15,940
question of replacing that definition

00:18:13,540 --> 00:18:18,280
with another definition and everything

00:18:15,940 --> 00:18:19,690
else sort of falls out of it but I want

00:18:18,280 --> 00:18:21,220
to look a little bit more closely at the

00:18:19,690 --> 00:18:24,490
code here so you can get a sense of how

00:18:21,220 --> 00:18:26,110
this reactive programming effects your

00:18:24,490 --> 00:18:30,490
code structure so this is sort of like

00:18:26,110 --> 00:18:32,860
typical d3 code you might see on Blas

00:18:30,490 --> 00:18:34,809
org and the idea is like I'm defining a

00:18:32,860 --> 00:18:37,210
scale here I would define the scale or I

00:18:34,809 --> 00:18:38,710
would declare a scale on page load and

00:18:37,210 --> 00:18:41,230
then I have to wait till the data loaded

00:18:38,710 --> 00:18:43,090
in order to set the domain and so

00:18:41,230 --> 00:18:45,160
there's a scale object here but really

00:18:43,090 --> 00:18:46,960
my definition of that scale kind of gets

00:18:45,160 --> 00:18:48,460
distributed throughout my program where

00:18:46,960 --> 00:18:50,920
I have a whole bunch of unrelated code

00:18:48,460 --> 00:18:52,450
here and this is obviously a very pared

00:18:50,920 --> 00:18:54,040
down example this is not a complete

00:18:52,450 --> 00:18:57,160
chart it wouldn't fit on the slide for

00:18:54,040 --> 00:19:00,040
one thing but you can already get a

00:18:57,160 --> 00:19:02,410
sense of like how the code ends up being

00:19:00,040 --> 00:19:04,780
harder to follow and more distributed

00:19:02,410 --> 00:19:07,210
because of the statefulness of this

00:19:04,780 --> 00:19:09,250
program whereas in reactive programming

00:19:07,210 --> 00:19:10,480
we can localize those definitions

00:19:09,250 --> 00:19:12,460
because it's now the run times

00:19:10,480 --> 00:19:14,860
responsibility to manage the order of

00:19:12,460 --> 00:19:16,690
execution and it knows that X scale

00:19:14,860 --> 00:19:19,360
depends on the data and it knows that it

00:19:16,690 --> 00:19:20,800
depends on d3 in the margins and so we

00:19:19,360 --> 00:19:23,340
can just define it in a way that makes

00:19:20,800 --> 00:19:26,350
more sense and let the runtime handle it

00:19:23,340 --> 00:19:27,580
now the last thing on charts is that you

00:19:26,350 --> 00:19:29,679
don't have to use d3

00:19:27,580 --> 00:19:31,600
in order to make charts and d3 Express I

00:19:29,679 --> 00:19:33,970
mean it is called d3 Express maybe that

00:19:31,600 --> 00:19:36,039
was a mistake but you know you can use

00:19:33,970 --> 00:19:38,440
Vega light you can use 3 jsut

00:19:36,039 --> 00:19:40,509
use whatever it is you want all of these

00:19:38,440 --> 00:19:43,119
things are just JavaScript and Dom so

00:19:40,509 --> 00:19:45,820
this is the same sort of data set and

00:19:43,119 --> 00:19:48,279
put a log scale on the chart but this is

00:19:45,820 --> 00:19:50,169
using Vega light and to me this is also

00:19:48,279 --> 00:19:51,759
a really exciting opportunity because as

00:19:50,169 --> 00:19:53,739
you sort of make it easier for people to

00:19:51,759 --> 00:19:55,629
explore datasets you can also explore

00:19:53,739 --> 00:19:58,359
other of these more domain-specific

00:19:55,629 --> 00:20:00,159
higher level abstractions and still have

00:19:58,359 --> 00:20:03,220
the benefit you get with the reactive

00:20:00,159 --> 00:20:05,619
programming okay so how about canvas

00:20:03,220 --> 00:20:08,529
you've got another notebook here and I

00:20:05,619 --> 00:20:12,070
want to make a globe so I've loaded dcgo

00:20:08,529 --> 00:20:13,929
and Thapa Jason and then the topology of

00:20:12,070 --> 00:20:15,669
like world county bounce or country

00:20:13,929 --> 00:20:17,830
boundaries and I'm going to create a

00:20:15,669 --> 00:20:21,309
canvas element similar like we did with

00:20:17,830 --> 00:20:22,979
the Dom SDG I get the context from that

00:20:21,309 --> 00:20:25,269
and then we're going to draw a bunch of

00:20:22,979 --> 00:20:29,799
canvas commands in order to get the

00:20:25,269 --> 00:20:31,059
world to appear so for that again you

00:20:29,799 --> 00:20:32,769
know you have this path object where

00:20:31,059 --> 00:20:35,289
you're passing in your geometry what is

00:20:32,769 --> 00:20:37,809
that well there's a d3 geo path function

00:20:35,289 --> 00:20:40,269
which takes geo jason and turns it into

00:20:37,809 --> 00:20:42,849
a string of our sequence of canvas draw

00:20:40,269 --> 00:20:44,409
commands that requires projection which

00:20:42,849 --> 00:20:48,369
for here we'll use an orthographic

00:20:44,409 --> 00:20:49,659
projection and so now it just appears so

00:20:48,369 --> 00:20:52,179
I'll take that and like let's say I

00:20:49,659 --> 00:20:54,849
wanted to draw the outline of the earth

00:20:52,179 --> 00:20:56,710
as well so for that I'll need a seer

00:20:54,849 --> 00:20:58,539
object so I break that out to a sort of

00:20:56,710 --> 00:21:00,369
separate definition here plug that back

00:20:58,539 --> 00:21:03,099
in and so now we have a nice little

00:21:00,369 --> 00:21:04,539
globe here but one of the powerful

00:21:03,099 --> 00:21:06,549
features is I hinted that when we were

00:21:04,539 --> 00:21:07,809
looking at the directed graph is that we

00:21:06,549 --> 00:21:09,279
can sort of take one of these

00:21:07,809 --> 00:21:11,679
definitions or one of these variables

00:21:09,279 --> 00:21:13,749
like in this case the projection and we

00:21:11,679 --> 00:21:16,239
can replace a static definition of this

00:21:13,749 --> 00:21:19,029
orthographic projection and put in a

00:21:16,239 --> 00:21:20,440
dynamic definition so something animated

00:21:19,029 --> 00:21:23,859
let's say so here's the Mercator

00:21:20,440 --> 00:21:25,749
projection or equal rectangular but now

00:21:23,859 --> 00:21:28,570
I want to make it so that's a rotating

00:21:25,749 --> 00:21:29,879
orthographic projection okay so the way

00:21:28,570 --> 00:21:33,220
that I'm doing that I'm sort of like

00:21:29,879 --> 00:21:36,879
glossing over some JavaScript details

00:21:33,220 --> 00:21:38,619
here but this is this is a generator so

00:21:36,879 --> 00:21:40,539
I guess a lot of people haven't used

00:21:38,619 --> 00:21:42,129
JavaScript generators but I only like

00:21:40,539 --> 00:21:44,889
honestly discover them a few months ago

00:21:42,129 --> 00:21:45,990
but they are remarkably cool for doing

00:21:44,889 --> 00:21:47,850
this sort of stuff

00:21:45,990 --> 00:21:49,740
see how it works in a second basically

00:21:47,850 --> 00:21:51,330
it's a function that can yield a

00:21:49,740 --> 00:21:53,429
sequence of values so normally a

00:21:51,330 --> 00:21:55,380
function just returns one value but in

00:21:53,429 --> 00:21:57,360
this case like it can yield an infinite

00:21:55,380 --> 00:21:59,190
stream of values so this is going to

00:21:57,360 --> 00:22:01,559
create an orthographic projection and

00:21:59,190 --> 00:22:04,290
then just inside of a wild true loop

00:22:01,559 --> 00:22:06,570
it's going to set the rotation angles

00:22:04,290 --> 00:22:08,670
for that projection and then you get a

00:22:06,570 --> 00:22:15,570
rotating globe here and tilt it a little

00:22:08,670 --> 00:22:20,610
bit northern hemisphere specific so yeah

00:22:15,570 --> 00:22:21,809
so generators they're pretty cool now

00:22:20,610 --> 00:22:23,250
one of the things you may be wondering

00:22:21,809 --> 00:22:27,000
is like how does this work right like

00:22:23,250 --> 00:22:30,420
how how is it that the generator go back

00:22:27,000 --> 00:22:31,950
here why doesn't it just go into like

00:22:30,420 --> 00:22:33,929
why does it hang the page it's a while

00:22:31,950 --> 00:22:35,790
true loop and the answer is that

00:22:33,929 --> 00:22:37,620
generators are a pole system so it's the

00:22:35,790 --> 00:22:41,300
runtime that's pulling new values from

00:22:37,620 --> 00:22:43,320
this generator at sixty times per second

00:22:41,300 --> 00:22:46,520
rather than it's sort of like pushing

00:22:43,320 --> 00:22:51,450
new values whenever they get updated

00:22:46,520 --> 00:22:53,610
like skip ahead a little bit here and

00:22:51,450 --> 00:22:56,490
one of the cool things you can do in

00:22:53,610 --> 00:22:59,990
addition or you may be wondering like

00:22:56,490 --> 00:23:01,950
when you have these generators let's see

00:22:59,990 --> 00:23:03,510
you know what is it doing with the

00:23:01,950 --> 00:23:05,070
canvas and the answer is that it's just

00:23:03,510 --> 00:23:06,630
throwing away the canvas and creating a

00:23:05,070 --> 00:23:09,750
new canvas every time that it needs to

00:23:06,630 --> 00:23:11,540
draw and that actually works just fine

00:23:09,750 --> 00:23:13,770
in this example because it's not very

00:23:11,540 --> 00:23:15,630
expensive it's pretty simple geometry

00:23:13,770 --> 00:23:16,920
that it's displaying but obviously

00:23:15,630 --> 00:23:18,150
that's a lot of overhead and it would

00:23:16,920 --> 00:23:20,760
limit the sort of things that you can do

00:23:18,150 --> 00:23:22,980
so the thing I'm showing you now is that

00:23:20,760 --> 00:23:25,230
you can change that behavior by just

00:23:22,980 --> 00:23:27,150
accessing the previous canvas that you

00:23:25,230 --> 00:23:29,190
used and of course when you do that it

00:23:27,150 --> 00:23:31,020
starts smearing but you can add this

00:23:29,190 --> 00:23:33,240
clear command so that it's clear before

00:23:31,020 --> 00:23:35,010
you redraw and then you're fixing the

00:23:33,240 --> 00:23:37,320
line width as well and so the point here

00:23:35,010 --> 00:23:38,130
is that you can opt in this loop now

00:23:37,320 --> 00:23:42,600
already too late

00:23:38,130 --> 00:23:45,179
hope you got it you get the simplicity

00:23:42,600 --> 00:23:47,010
of the reactive model but if you want to

00:23:45,179 --> 00:23:48,510
like opt into a little more complexity

00:23:47,010 --> 00:23:49,830
you also don't have to pay the

00:23:48,510 --> 00:23:51,870
performance cost for that there's

00:23:49,830 --> 00:23:54,240
negligible overhead compared to what you

00:23:51,870 --> 00:23:56,370
would write in vanilla JavaScript

00:23:54,240 --> 00:23:57,990
okay so just to reiterate to look at the

00:23:56,370 --> 00:24:00,660
code a little bit this is our static

00:23:57,990 --> 00:24:02,880
definition of the projection and this is

00:24:00,660 --> 00:24:05,280
our generator which defines the rotating

00:24:02,880 --> 00:24:07,770
projection and so every time a new value

00:24:05,280 --> 00:24:09,660
is pulled from this generator it sets

00:24:07,770 --> 00:24:12,059
the new rotation angles based on the

00:24:09,660 --> 00:24:15,600
current time and then yield to that

00:24:12,059 --> 00:24:17,220
value okay so generators are good

00:24:15,600 --> 00:24:19,410
prescriptive animations but what about

00:24:17,220 --> 00:24:21,090
interaction well turns out we can use

00:24:19,410 --> 00:24:22,620
generators for those too

00:24:21,090 --> 00:24:24,990
it's just that our generators are now

00:24:22,620 --> 00:24:26,790
asynchronous and they yield value

00:24:24,990 --> 00:24:30,390
whenever there's new input rather than

00:24:26,790 --> 00:24:31,410
just yielding it at a fixed rate so the

00:24:30,390 --> 00:24:32,970
first thing I'm going to need in order

00:24:31,410 --> 00:24:35,070
to make this interactive is I'm going to

00:24:32,970 --> 00:24:36,660
need a little slider and again this is

00:24:35,070 --> 00:24:38,610
just Dom so I'm creating an input

00:24:36,660 --> 00:24:40,890
element type range with these values

00:24:38,610 --> 00:24:42,179
it's not hooked up to anything so of

00:24:40,890 --> 00:24:44,100
course like dragging that back and forth

00:24:42,179 --> 00:24:46,770
doesn't do anything but I'll give that a

00:24:44,100 --> 00:24:49,170
name and then we can define a generator

00:24:46,770 --> 00:24:52,080
that emits the value of that range

00:24:49,170 --> 00:24:54,510
slider so now I can see okay it's going

00:24:52,080 --> 00:24:56,670
from minus 180 to plus 180 as I'm

00:24:54,510 --> 00:24:58,620
dragging it I get that a name call that

00:24:56,670 --> 00:25:02,670
the angle and then we feed that angle

00:24:58,620 --> 00:25:04,590
into our projection rotation so now when

00:25:02,670 --> 00:25:06,300
I drag the slider it's now interactive

00:25:04,590 --> 00:25:09,660
right I can sort of spin the earth

00:25:06,300 --> 00:25:11,280
around now because this is a very sort

00:25:09,660 --> 00:25:13,440
of common case where you're defining a

00:25:11,280 --> 00:25:15,420
user interface and you want that to

00:25:13,440 --> 00:25:17,730
drive something in your code there's a

00:25:15,420 --> 00:25:19,170
view of operator which does exactly the

00:25:17,730 --> 00:25:20,309
things that I just showed you but it

00:25:19,170 --> 00:25:23,400
does it sort of within a single

00:25:20,309 --> 00:25:24,840
definition so there's the input slider

00:25:23,400 --> 00:25:26,220
that you're declaring here that's the

00:25:24,840 --> 00:25:28,830
user interface or the graphical

00:25:26,220 --> 00:25:30,330
interface and then there's the value of

00:25:28,830 --> 00:25:33,000
that which is the programming interface

00:25:30,330 --> 00:25:37,590
so that's the angle that there the code

00:25:33,000 --> 00:25:39,450
sees to drive the projection okay so

00:25:37,590 --> 00:25:41,370
again this is the code so this is sort

00:25:39,450 --> 00:25:43,860
of like a long form where I'm declaring

00:25:41,370 --> 00:25:46,650
my projection and it's rotation takes an

00:25:43,860 --> 00:25:48,960
angle that angle is derived from this

00:25:46,650 --> 00:25:53,240
range input and the range input that

00:25:48,960 --> 00:25:55,590
just goes from minus 180 to plus 180 and

00:25:53,240 --> 00:25:58,920
this is the shorthand form using the

00:25:55,590 --> 00:26:00,720
view of operator okay but we now have

00:25:58,920 --> 00:26:02,190
the ability to generate arbitrary inputs

00:26:00,720 --> 00:26:03,960
right this is not just sort of you're

00:26:02,190 --> 00:26:05,820
limited to sort of a fixed palette of a

00:26:03,960 --> 00:26:07,590
range slider and a drop-down menu in

00:26:05,820 --> 00:26:09,960
this case like I'm making

00:26:07,590 --> 00:26:11,880
this table and it's got like three

00:26:09,960 --> 00:26:15,620
sliders I'm making a color picker for

00:26:11,880 --> 00:26:20,250
the QP looks color space and I want this

00:26:15,620 --> 00:26:22,980
the output of this complex input to be a

00:26:20,250 --> 00:26:24,150
Q helix color instance so that's the

00:26:22,980 --> 00:26:25,590
code that I'm writing here which

00:26:24,150 --> 00:26:28,020
basically takes the values from the

00:26:25,590 --> 00:26:29,909
sliders it updates their corresponding

00:26:28,020 --> 00:26:31,559
output so as you're dragging it you can

00:26:29,909 --> 00:26:32,220
see that the hue angle is changing there

00:26:31,559 --> 00:26:34,260
to the right

00:26:32,220 --> 00:26:36,179
and then below that you can see this

00:26:34,260 --> 00:26:39,120
color object that's kind of the output

00:26:36,179 --> 00:26:41,010
of our interface here and then I'm using

00:26:39,120 --> 00:26:43,950
that to sort of set the background color

00:26:41,010 --> 00:26:46,830
of this dip so the point is like you're

00:26:43,950 --> 00:26:48,360
just doing sort of DOM and HTML here but

00:26:46,830 --> 00:26:49,950
there's a really nice primitive for you

00:26:48,360 --> 00:26:51,750
to sort of hook that into the

00:26:49,950 --> 00:26:55,169
programming system into the reactive

00:26:51,750 --> 00:26:57,210
programming environment okay now for

00:26:55,169 --> 00:26:59,549
visualization this has sort of even more

00:26:57,210 --> 00:27:01,830
interesting applications so this is a

00:26:59,549 --> 00:27:05,880
histogram it's looking at sort of a

00:27:01,830 --> 00:27:08,130
price of 500 or so stocks in January

00:27:05,880 --> 00:27:10,559
2012 relative to their price in January

00:27:08,130 --> 00:27:13,559
2011 so you can see that there's a bell

00:27:10,559 --> 00:27:15,000
curve here and the mode of that is like

00:27:13,559 --> 00:27:16,590
slightly greater than one because of

00:27:15,000 --> 00:27:19,289
course like the average return on stocks

00:27:16,590 --> 00:27:20,789
tends to be positive but there's also a

00:27:19,289 --> 00:27:22,409
long tail where you have like stocks

00:27:20,789 --> 00:27:24,390
that did really well and you had stocks

00:27:22,409 --> 00:27:26,250
that did really poorly now if you wanted

00:27:24,390 --> 00:27:28,140
to know exactly what those stocks were

00:27:26,250 --> 00:27:30,210
in another environment you might have to

00:27:28,140 --> 00:27:32,669
write separate code in order to query

00:27:30,210 --> 00:27:35,190
that and to look at the results but here

00:27:32,669 --> 00:27:37,200
we can augment this visualization with a

00:27:35,190 --> 00:27:38,820
little bit of interaction so that we can

00:27:37,200 --> 00:27:39,500
manipulate it directly and see the

00:27:38,820 --> 00:27:41,760
output

00:27:39,500 --> 00:27:44,190
so that's what I've done here is this

00:27:41,760 --> 00:27:48,120
that d3 brush I'm brushing on it and

00:27:44,190 --> 00:27:51,210
then this chart yields just like a range

00:27:48,120 --> 00:27:53,279
slider would except it yields sort of

00:27:51,210 --> 00:27:54,990
the data points that you've selected so

00:27:53,279 --> 00:27:57,450
just by brushing back and forth here and

00:27:54,990 --> 00:28:00,179
using the default object inspector I can

00:27:57,450 --> 00:28:02,010
see what these stocks are so like that's

00:28:00,179 --> 00:28:04,080
the price line group in some

00:28:02,010 --> 00:28:06,390
pharmaceutical which I assume they like

00:28:04,080 --> 00:28:07,919
I think they went public like at the

00:28:06,390 --> 00:28:09,179
start of this data set but the

00:28:07,919 --> 00:28:12,299
interesting thing for me is like all the

00:28:09,179 --> 00:28:13,590
ones down here on the Left there's

00:28:12,299 --> 00:28:14,560
anybody have any guesses where they are

00:28:13,590 --> 00:28:19,490
from

00:28:14,560 --> 00:28:21,530
2007 so it was shortly before the

00:28:19,490 --> 00:28:23,300
financial crisis and so this is like

00:28:21,530 --> 00:28:25,580
etrade financial and all of the other

00:28:23,300 --> 00:28:27,050
sort of like financial firms that

00:28:25,580 --> 00:28:30,590
basically collapsed and have to get

00:28:27,050 --> 00:28:32,240
bailed out by the government but it's

00:28:30,590 --> 00:28:34,360
cool that you can just sort of see that

00:28:32,240 --> 00:28:39,170
directly from this visualization here

00:28:34,360 --> 00:28:40,760
building it up incrementally okay just

00:28:39,170 --> 00:28:43,010
to show that there's no real magic going

00:28:40,760 --> 00:28:45,200
on under the hood here this is the code

00:28:43,010 --> 00:28:46,670
that I wrote to adapt sort of your

00:28:45,200 --> 00:28:49,900
standard DT brush that you would write

00:28:46,670 --> 00:28:52,850
today to this sort of generator based

00:28:49,900 --> 00:28:54,470
system so whenever there's a brush event

00:28:52,850 --> 00:28:56,180
you can look at the selection and then

00:28:54,470 --> 00:28:59,630
you can use that selection to filter

00:28:56,180 --> 00:29:02,240
your data so picking the stocks that had

00:28:59,630 --> 00:29:04,160
a change value between you know the

00:29:02,240 --> 00:29:05,990
lower bound and the upper bound of your

00:29:04,160 --> 00:29:07,880
selection and then you're just setting

00:29:05,990 --> 00:29:09,980
that as the value and then dispatching

00:29:07,880 --> 00:29:14,480
this input event so that it triggers the

00:29:09,980 --> 00:29:16,190
update now normally in in reactive

00:29:14,480 --> 00:29:18,380
programming and in this environment your

00:29:16,190 --> 00:29:20,540
reactions are instantaneous but

00:29:18,380 --> 00:29:22,070
sometimes it's beneficial for them not

00:29:20,540 --> 00:29:24,140
to be instantaneous you actually want to

00:29:22,070 --> 00:29:26,900
observe the changes from one state to

00:29:24,140 --> 00:29:30,200
another state so similarly like we had

00:29:26,900 --> 00:29:32,540
with the canvas example we can use the

00:29:30,200 --> 00:29:34,460
previous value of the cell in order to

00:29:32,540 --> 00:29:36,590
define sort of your standard d3

00:29:34,460 --> 00:29:38,210
transitions and using the data join so

00:29:36,590 --> 00:29:41,630
here I've got a stagger transition on a

00:29:38,210 --> 00:29:43,460
deep bar chart and I've got a data set

00:29:41,630 --> 00:29:45,710
that I'm going to sort based on this

00:29:43,460 --> 00:29:49,760
like little checkbox here switching

00:29:45,710 --> 00:29:51,950
between this descending frequency this

00:29:49,760 --> 00:29:54,050
is letters in English language and just

00:29:51,950 --> 00:29:55,880
lexicographic order so if I click the

00:29:54,050 --> 00:29:58,670
checkbox here it's just running that

00:29:55,880 --> 00:30:00,350
same code and because it has access to

00:29:58,670 --> 00:30:01,670
the previous chart it's not throwing it

00:30:00,350 --> 00:30:04,640
away and it can just do your sort of

00:30:01,670 --> 00:30:08,170
standard d3 day to join stuff in order

00:30:04,640 --> 00:30:08,170
to make an animation there

00:30:09,620 --> 00:30:14,270
okay so inline visual outputs improve

00:30:12,289 --> 00:30:17,659
our ability to inspect the program's

00:30:14,270 --> 00:30:20,510
current state but there's more that we

00:30:17,659 --> 00:30:22,190
can do with interactive programming to

00:30:20,510 --> 00:30:23,840
understand not just the current state

00:30:22,190 --> 00:30:25,940
but to understand the behavior of a

00:30:23,840 --> 00:30:27,860
program you can do that by poking by

00:30:25,940 --> 00:30:31,100
changing deleting and reordering code

00:30:27,860 --> 00:30:33,559
and seeing what happens and so in this

00:30:31,100 --> 00:30:36,529
notebook I've got sort of your typical

00:30:33,559 --> 00:30:37,880
force directed graph and I've got the

00:30:36,529 --> 00:30:39,919
simulation here which is driving the

00:30:37,880 --> 00:30:41,539
layout and by sort of commenting out the

00:30:39,919 --> 00:30:43,370
different forces I can see what effect

00:30:41,539 --> 00:30:44,990
they're having on the layout so I turned

00:30:43,370 --> 00:30:46,460
out the charge force and everything

00:30:44,990 --> 00:30:48,350
collapsed because the charge force is

00:30:46,460 --> 00:30:49,789
what's causing these nodes to sort of

00:30:48,350 --> 00:30:51,919
pull apart from each other

00:30:49,789 --> 00:30:53,330
likewise if I change the strength of

00:30:51,919 --> 00:30:55,760
that charge then it's sort of all

00:30:53,330 --> 00:30:57,559
collapses on itself and that was because

00:30:55,760 --> 00:30:59,090
normally the charge is negative right so

00:30:57,559 --> 00:31:00,500
that they repel each other if you change

00:30:59,090 --> 00:31:01,909
them to be positive they're all pulling

00:31:00,500 --> 00:31:03,500
each other towards the center and

00:31:01,909 --> 00:31:07,700
there's nothing there's no equilibrium

00:31:03,500 --> 00:31:09,169
it just goes into chaos so I can tinker

00:31:07,700 --> 00:31:12,020
with the forces here I can choose like

00:31:09,169 --> 00:31:15,289
what's the right value I can play with

00:31:12,020 --> 00:31:18,230
the link force and turn that off - it

00:31:15,289 --> 00:31:23,510
sort of explodes or turn off like the

00:31:18,230 --> 00:31:26,200
centering force and then just kind of

00:31:23,510 --> 00:31:26,200
floats away

00:31:27,650 --> 00:31:33,390
yeah so Nate you've probably seen little

00:31:30,930 --> 00:31:34,620
tinker toys like this before where you

00:31:33,390 --> 00:31:36,360
have a forced layout and they're like

00:31:34,620 --> 00:31:37,530
some sliders like that GUI or whatever

00:31:36,360 --> 00:31:39,630
where you're you're playing with the

00:31:37,530 --> 00:31:41,220
parameters but the thing that's kind of

00:31:39,630 --> 00:31:43,830
cool here is that you didn't have to

00:31:41,220 --> 00:31:46,140
build any specific interface to do that

00:31:43,830 --> 00:31:47,760
it just sort of came for free with the

00:31:46,140 --> 00:31:50,790
reactive programming model just by

00:31:47,760 --> 00:31:55,110
tinkering with the code now a more

00:31:50,790 --> 00:31:57,420
explicit approach is to expose the

00:31:55,110 --> 00:31:58,980
internal state of our code as it's

00:31:57,420 --> 00:32:02,790
running so that we can study it with

00:31:58,980 --> 00:32:04,380
visualization generators can help with

00:32:02,790 --> 00:32:05,790
that as well so I'll give an example so

00:32:04,380 --> 00:32:07,830
this is just a very simple function

00:32:05,790 --> 00:32:10,770
which computes of some of an array of

00:32:07,830 --> 00:32:12,720
numbers and what we can do is turn that

00:32:10,770 --> 00:32:15,930
into a generator so that basically means

00:32:12,720 --> 00:32:17,880
we put a star here and then we add this

00:32:15,930 --> 00:32:19,470
yield value and so now the idea is like

00:32:17,880 --> 00:32:22,350
we have an extra channel where we can

00:32:19,470 --> 00:32:23,730
emit information from our code and use

00:32:22,350 --> 00:32:25,500
that in order to construct

00:32:23,730 --> 00:32:27,960
visualizations or animations to

00:32:25,500 --> 00:32:29,130
understand the behavior of the code and

00:32:27,960 --> 00:32:30,900
that's important because it gives a

00:32:29,130 --> 00:32:32,490
cleaner separation between the

00:32:30,900 --> 00:32:35,700
implementation of the algorithm and how

00:32:32,490 --> 00:32:38,220
we study it how we explore it and so

00:32:35,700 --> 00:32:39,870
there are two ways we can call the

00:32:38,220 --> 00:32:41,850
generator like this so one is you just

00:32:39,870 --> 00:32:43,200
call it directly and then you get an

00:32:41,850 --> 00:32:45,240
animation just like we did with the

00:32:43,200 --> 00:32:47,610
rotating projection and the other way is

00:32:45,240 --> 00:32:49,800
use this like little ellipses here in an

00:32:47,610 --> 00:32:51,570
array and then it's actually going to

00:32:49,800 --> 00:32:53,400
pull all of the values at once

00:32:51,570 --> 00:32:56,520
out of that generator and so you get a

00:32:53,400 --> 00:32:58,260
nice like static data set and you can

00:32:56,520 --> 00:33:00,420
then construct a static visualization of

00:32:58,260 --> 00:33:03,900
your programs behavior rather than just

00:33:00,420 --> 00:33:05,040
being limited to animations so obviously

00:33:03,900 --> 00:33:07,050
you like understanding like a running

00:33:05,040 --> 00:33:07,950
sum isn't particularly interesting so

00:33:07,050 --> 00:33:09,330
I'm going to use like a more concrete

00:33:07,950 --> 00:33:11,760
example here we're going to get deep

00:33:09,330 --> 00:33:12,690
into computational geometry probably

00:33:11,760 --> 00:33:15,750
weren't expecting that at this

00:33:12,690 --> 00:33:18,810
conference but here it comes so this is

00:33:15,750 --> 00:33:22,860
a d3 hierarchical circle packing layout

00:33:18,810 --> 00:33:25,020
it's a bit like a tree map except it's

00:33:22,860 --> 00:33:26,520
not quite as space efficient as a tree

00:33:25,020 --> 00:33:28,230
map but you can see sort of the

00:33:26,520 --> 00:33:30,150
structure of the hierarchy a little bit

00:33:28,230 --> 00:33:31,980
better so this sort of technique is

00:33:30,150 --> 00:33:33,720
commonly used to understand sort of like

00:33:31,980 --> 00:33:36,000
where your disk space is gone or how

00:33:33,720 --> 00:33:38,670
you're using a file system so in this

00:33:36,000 --> 00:33:39,900
case like this is flare which is another

00:33:38,670 --> 00:33:42,420
visualization toolkit

00:33:39,900 --> 00:33:44,820
and looking at the sizes of the

00:33:42,420 --> 00:33:48,420
different source code files organized by

00:33:44,820 --> 00:33:52,110
their package hierarchy so one of the

00:33:48,420 --> 00:33:53,700
tasks here is that you have to you have

00:33:52,110 --> 00:33:55,830
all of these circles and you want to

00:33:53,700 --> 00:33:58,890
pack them into a small place the small

00:33:55,830 --> 00:34:02,190
space as possible without overlap like

00:33:58,890 --> 00:34:04,260
huddling penguins Antarctica

00:34:02,190 --> 00:34:06,150
until your our job is to place circles

00:34:04,260 --> 00:34:08,570
one of the time until all of the circles

00:34:06,150 --> 00:34:10,560
have been placed okay since we want

00:34:08,570 --> 00:34:13,080
circles to be packed as tightly as

00:34:10,560 --> 00:34:15,060
possible it's fairly obvious that each

00:34:13,080 --> 00:34:17,639
circle that we place must be tangent to

00:34:15,060 --> 00:34:20,490
at least one and actually two of the

00:34:17,639 --> 00:34:22,080
circles that we've already placed but if

00:34:20,490 --> 00:34:24,030
we just take an existing circle at

00:34:22,080 --> 00:34:25,409
random as the tangent circle then we're

00:34:24,030 --> 00:34:27,300
going to waste a lot of time trying to

00:34:25,409 --> 00:34:28,440
place the new circle in this in the

00:34:27,300 --> 00:34:29,790
middle of the pack or it's going to

00:34:28,440 --> 00:34:31,830
overlap with the circles that we've

00:34:29,790 --> 00:34:33,270
already placed so ideally we only

00:34:31,830 --> 00:34:35,070
consider the circles that are on the

00:34:33,270 --> 00:34:36,570
outside of the pack but the problem is

00:34:35,070 --> 00:34:38,820
how do we efficiently determine which

00:34:36,570 --> 00:34:40,679
circles are on the outside so what these

00:34:38,820 --> 00:34:42,600
are uses and other implementations of

00:34:40,679 --> 00:34:44,909
this layout used called Wang's algorithm

00:34:42,600 --> 00:34:47,190
and it maintains this front chain which

00:34:44,909 --> 00:34:49,919
is shown in red and that represents the

00:34:47,190 --> 00:34:51,629
outermost circles so when it's placing a

00:34:49,919 --> 00:34:53,250
new circle it's going to pick the circle

00:34:51,629 --> 00:34:55,530
on the front chain that is closest to

00:34:53,250 --> 00:34:57,090
the origin to the center and then the

00:34:55,530 --> 00:34:58,680
new circle is placed tangent to that

00:34:57,090 --> 00:35:01,740
circle and its neighbor on the front

00:34:58,680 --> 00:35:03,570
chain so if this placement does not

00:35:01,740 --> 00:35:05,610
overlap with any circle on the front

00:35:03,570 --> 00:35:07,380
chain then the algorithm can just move

00:35:05,610 --> 00:35:09,360
on to the next circle but if it does

00:35:07,380 --> 00:35:11,070
overlap like in this example here this

00:35:09,360 --> 00:35:13,470
black circle is overlapping with these

00:35:11,070 --> 00:35:15,270
other circles on the front chain then

00:35:13,470 --> 00:35:17,220
you have to cut the front chain between

00:35:15,270 --> 00:35:19,620
the tangent circle and the overlapping

00:35:17,220 --> 00:35:22,230
circle and it's sort of like expands the

00:35:19,620 --> 00:35:24,270
front chain out and that way after you

00:35:22,230 --> 00:35:26,130
apply that process a few times the new

00:35:24,270 --> 00:35:30,180
circle that you place won't be tangent

00:35:26,130 --> 00:35:32,810
to any other circle so I find this

00:35:30,180 --> 00:35:35,010
animation a little bit mesmerizing and

00:35:32,810 --> 00:35:36,750
the moment I like is when the large

00:35:35,010 --> 00:35:37,890
circles kind of like get forced out of

00:35:36,750 --> 00:35:39,570
the pack there's it like a very quick

00:35:37,890 --> 00:35:42,030
animation of only a few frames so they

00:35:39,570 --> 00:35:44,640
kind of get squeezed out but more than

00:35:42,030 --> 00:35:46,500
just being kind of cool to look at this

00:35:44,640 --> 00:35:48,660
notebook was extremely useful for me for

00:35:46,500 --> 00:35:50,880
fixing a long-standing bug in d3 s

00:35:48,660 --> 00:35:51,579
implementation where very rarely it

00:35:50,880 --> 00:35:53,619
would cut the ball

00:35:51,579 --> 00:35:56,709
side of the front chain and the circles

00:35:53,619 --> 00:35:58,779
with end of overlapping and actually I

00:35:56,709 --> 00:36:00,690
discovered another bug just last week

00:35:58,779 --> 00:36:04,779
with a different visualization here but

00:36:00,690 --> 00:36:06,819
I've been great so once you pack the

00:36:04,779 --> 00:36:08,769
circles you're not totally done you also

00:36:06,819 --> 00:36:10,239
need to compute the enclosing circle of

00:36:08,769 --> 00:36:12,369
that pack so that you can then repeat

00:36:10,239 --> 00:36:14,109
repeat the process in the rest of the

00:36:12,369 --> 00:36:15,969
hierarchy and the conventional way of

00:36:14,109 --> 00:36:17,920
doing that is to just scan the front

00:36:15,969 --> 00:36:20,319
chain and picking the circle that is the

00:36:17,920 --> 00:36:21,219
farthest from the origin and that tends

00:36:20,319 --> 00:36:23,440
to do a pretty good approximation

00:36:21,219 --> 00:36:27,910
because these packs end up being roughly

00:36:23,440 --> 00:36:29,469
circular but it's not exact and I am a

00:36:27,910 --> 00:36:31,029
year ago or so I discovered there's this

00:36:29,469 --> 00:36:32,650
other algorithm called well tools

00:36:31,029 --> 00:36:35,589
algorithm for computing the smallest

00:36:32,650 --> 00:36:36,819
enclosing circle in linear time and I

00:36:35,589 --> 00:36:39,369
think it's also pretty cool so I'm gonna

00:36:36,819 --> 00:36:41,079
show you how that one works so let's

00:36:39,369 --> 00:36:43,509
assume that we already have the

00:36:41,079 --> 00:36:45,309
enclosing circle for some circles and

00:36:43,509 --> 00:36:47,380
now we again once we do this

00:36:45,309 --> 00:36:50,410
incrementally we want to incorporate a

00:36:47,380 --> 00:36:51,910
new circle into the enclosing circle and

00:36:50,410 --> 00:36:54,609
that sounds a little bit circular that

00:36:51,910 --> 00:36:56,319
we already know the answer but it's like

00:36:54,609 --> 00:36:57,910
a proof by induction all right or any

00:36:56,319 --> 00:37:00,309
sort of like recursive process as you'll

00:36:57,910 --> 00:37:02,709
see but I'm not going to give you like a

00:37:00,309 --> 00:37:04,449
rigorous proof of this it's not enough

00:37:02,709 --> 00:37:06,940
time and also I probably just going to

00:37:04,449 --> 00:37:09,069
do it frankly but I want to give you

00:37:06,940 --> 00:37:11,769
like an intuition so that you can get a

00:37:09,069 --> 00:37:13,420
sense of how this algorithm works so if

00:37:11,769 --> 00:37:14,739
the new circle is inside then we don't

00:37:13,420 --> 00:37:16,329
have to do anything we just move on to

00:37:14,739 --> 00:37:17,829
the next circle but again if the new

00:37:16,329 --> 00:37:19,869
circle is outside of our enclosing

00:37:17,829 --> 00:37:22,029
circle then we're gonna have to compute

00:37:19,869 --> 00:37:23,199
the new enclosing circle but we actually

00:37:22,029 --> 00:37:25,449
already know something about this new

00:37:23,199 --> 00:37:28,239
circle it's the only circle that is

00:37:25,449 --> 00:37:29,890
outside the enclosing circle and thus it

00:37:28,239 --> 00:37:31,900
must be tangent to whatever the new

00:37:29,890 --> 00:37:34,329
enclosing circle is which is in this

00:37:31,900 --> 00:37:36,099
case is this one so we don't really know

00:37:34,329 --> 00:37:37,569
yet what the other tangent circles are

00:37:36,099 --> 00:37:39,400
but we know what one of the tangent

00:37:37,569 --> 00:37:41,769
circles are and that means that we can

00:37:39,400 --> 00:37:43,930
apply this process recursively in order

00:37:41,769 --> 00:37:45,940
to find the other tangent circles okay

00:37:43,930 --> 00:37:47,170
so I'm glossing over a lot of geometry

00:37:45,940 --> 00:37:48,369
here they're also like boundary

00:37:47,170 --> 00:37:50,049
conditions that you have to worry about

00:37:48,369 --> 00:37:52,359
like you need to know what the enclosing

00:37:50,049 --> 00:37:53,829
circle is for one two or three circles

00:37:52,359 --> 00:37:56,259
and that last one is called the problem

00:37:53,829 --> 00:37:59,920
of Apollonius it has a cool math world

00:37:56,259 --> 00:38:01,089
page with lots of pretty diagrams but

00:37:59,920 --> 00:38:02,619
the point is like with a little bit of

00:38:01,089 --> 00:38:03,500
geometry combined with this intuition

00:38:02,619 --> 00:38:05,180
you can get a Sun

00:38:03,500 --> 00:38:06,890
of how this process works and

00:38:05,180 --> 00:38:08,720
understanding that it's a recursive

00:38:06,890 --> 00:38:11,030
process we can now sort of see a more

00:38:08,720 --> 00:38:12,320
complete picture of this algorithm so

00:38:11,030 --> 00:38:14,240
the first one that I showed you is

00:38:12,320 --> 00:38:16,850
really just sort of the top level of the

00:38:14,240 --> 00:38:18,530
algorithm and now these are like up to

00:38:16,850 --> 00:38:20,330
four levels of the algorithm you can't

00:38:18,530 --> 00:38:21,980
ever get more than three tangent circles

00:38:20,330 --> 00:38:25,190
so that's why there can't be more than

00:38:21,980 --> 00:38:27,500
four circles that are drawn up here and

00:38:25,190 --> 00:38:28,940
as you are iterating over your circles

00:38:27,500 --> 00:38:30,680
and you find one of the circles that's

00:38:28,940 --> 00:38:34,340
outside of your enclosing circle I said

00:38:30,680 --> 00:38:35,930
circle like five thousand times it has

00:38:34,340 --> 00:38:37,400
to recurse it knows it has a tangent

00:38:35,930 --> 00:38:39,860
circle it has to move to the right so

00:38:37,400 --> 00:38:42,380
it's like having one level deeper into

00:38:39,860 --> 00:38:49,460
the dream and then popping back up again

00:38:42,380 --> 00:38:51,440
until you finally get your results okay

00:38:49,460 --> 00:38:52,550
so in addition I'll show it again but in

00:38:51,440 --> 00:38:54,860
addition to showing how this algorithm

00:38:52,550 --> 00:38:56,810
works the algorithm gives a sense of how

00:38:54,860 --> 00:38:58,190
much time algorithm spends or the

00:38:56,810 --> 00:39:00,590
animation gives a sense of how much time

00:38:58,190 --> 00:39:02,750
the algorithm spends different levels of

00:39:00,590 --> 00:39:05,330
recursion so you can see that it

00:39:02,750 --> 00:39:07,730
converges very quickly on an approximate

00:39:05,330 --> 00:39:10,190
answer but when it encounters a circle

00:39:07,730 --> 00:39:12,260
that's outside it then has to rescan all

00:39:10,190 --> 00:39:14,120
the circles that looked at previously in

00:39:12,260 --> 00:39:17,060
order to compute a new enclosing circle

00:39:14,120 --> 00:39:18,980
so it ends up being more expensive when

00:39:17,060 --> 00:39:24,230
it finds a new circle that's outside in

00:39:18,980 --> 00:39:26,420
order to validate the new result okay so

00:39:24,230 --> 00:39:29,570
one way to write less code is to reuse

00:39:26,420 --> 00:39:31,760
it and the 450 thousand or so packages

00:39:29,570 --> 00:39:34,310
published to NPM attest to the

00:39:31,760 --> 00:39:35,870
popularity of this approach but

00:39:34,310 --> 00:39:37,790
libraries are an example of active

00:39:35,870 --> 00:39:39,560
reusability right they must be

00:39:37,790 --> 00:39:42,470
intentionally designed to be reusable

00:39:39,560 --> 00:39:44,540
and this is a substantial burden it can

00:39:42,470 --> 00:39:46,430
be hard to design an effective general

00:39:44,540 --> 00:39:47,170
abstraction just ask any open-source

00:39:46,430 --> 00:39:50,090
maintainer

00:39:47,170 --> 00:39:52,460
in contrast implementing one-off code

00:39:50,090 --> 00:39:54,080
like you see in many d3 examples is much

00:39:52,460 --> 00:39:56,480
easier you're only concerned with sort

00:39:54,080 --> 00:39:59,510
of the task at hand not some general

00:39:56,480 --> 00:40:02,210
abstract classic tasks so what I'd like

00:39:59,510 --> 00:40:04,250
to explore with d3 Express is whether we

00:40:02,210 --> 00:40:06,140
can have better passive reusability sort

00:40:04,250 --> 00:40:08,590
of something in between one-off code and

00:40:06,140 --> 00:40:11,030
sort of nicely packaged up usable code

00:40:08,590 --> 00:40:13,100
where by leveraging the structure of

00:40:11,030 --> 00:40:15,860
these reactive documents we can more

00:40:13,100 --> 00:40:16,880
easily repurpose code even if that code

00:40:15,860 --> 00:40:20,150
wasn't

00:40:16,880 --> 00:40:22,160
designed to be reusable so what I mean

00:40:20,150 --> 00:40:24,410
by this is for starters you can treat

00:40:22,160 --> 00:40:27,400
your notebooks like de-facto libraries

00:40:24,410 --> 00:40:30,320
so I don't know if you saw that but in

00:40:27,400 --> 00:40:32,030
this notebook here I've sort of defined

00:40:30,320 --> 00:40:33,920
a color interpolator this is like

00:40:32,030 --> 00:40:37,130
implementing terrain dot colors from our

00:40:33,920 --> 00:40:39,260
using d3 HSB it's just sort of used for

00:40:37,130 --> 00:40:41,720
elevation data or topographic maps

00:40:39,260 --> 00:40:43,190
sometimes so I've defined that in one

00:40:41,720 --> 00:40:44,960
notebook and what I want to do is use

00:40:43,190 --> 00:40:46,760
this color scale in another notebook and

00:40:44,960 --> 00:40:48,740
I haven't published that to NPM but I

00:40:46,760 --> 00:40:50,750
can import that from the other notebook

00:40:48,740 --> 00:40:53,300
by just saying import interpolate

00:40:50,750 --> 00:40:55,850
terrain from the name of that other

00:40:53,300 --> 00:40:58,430
notebook and then I can start to use it

00:40:55,850 --> 00:40:59,870
and so this is nice for a sort of

00:40:58,430 --> 00:41:01,850
reusing code that you wrote from another

00:40:59,870 --> 00:41:03,410
notebook I can also imagine this

00:41:01,850 --> 00:41:05,000
technique being useful if you for

00:41:03,410 --> 00:41:07,280
example you have a lot of different

00:41:05,000 --> 00:41:09,080
notebooks used for exploration and then

00:41:07,280 --> 00:41:10,760
you want to combine those together into

00:41:09,080 --> 00:41:12,290
your final write-up you don't have to

00:41:10,760 --> 00:41:13,700
copy your code from those separate

00:41:12,290 --> 00:41:16,070
notebooks you can just import the

00:41:13,700 --> 00:41:19,310
symbols and then write around it and add

00:41:16,070 --> 00:41:22,700
extra explanation now more interestingly

00:41:19,310 --> 00:41:25,280
you can do rewiring of these definitions

00:41:22,700 --> 00:41:27,170
as part of the import process so I'll

00:41:25,280 --> 00:41:29,210
give you an example so this is a data

00:41:27,170 --> 00:41:33,050
set where I'm streaming data over

00:41:29,210 --> 00:41:35,020
WebSockets and so whenever it gets a new

00:41:33,050 --> 00:41:38,150
event it's going to sort of like add a

00:41:35,020 --> 00:41:40,090
new datum to the array and shift the old

00:41:38,150 --> 00:41:42,260
one off so that it's a moving window

00:41:40,090 --> 00:41:44,150
again like the details of this code

00:41:42,260 --> 00:41:45,800
don't really matter I'm not imagining

00:41:44,150 --> 00:41:47,720
that people would write all of this code

00:41:45,800 --> 00:41:49,130
for all of their real-time data sets you

00:41:47,720 --> 00:41:52,220
probably have like an API or something

00:41:49,130 --> 00:41:53,900
to load these streaming data sets but I

00:41:52,220 --> 00:41:56,090
still want to show you that it's

00:41:53,900 --> 00:41:58,820
relatively straightforward in order to

00:41:56,090 --> 00:42:00,110
construct these using DES generators so

00:41:58,820 --> 00:42:02,030
this is what the data set looks like

00:42:00,110 --> 00:42:03,500
it's just an array of 300 things and you

00:42:02,030 --> 00:42:06,260
can see that it's sort of shifting off

00:42:03,500 --> 00:42:08,800
representing sort of a recent time

00:42:06,260 --> 00:42:08,800
window here

00:42:14,870 --> 00:42:20,310
okay so now you saw from before we had a

00:42:18,120 --> 00:42:22,260
chart that did a line chart from before

00:42:20,310 --> 00:42:23,520
and so this data set I mean it's real

00:42:22,260 --> 00:42:25,350
time but it's basically the same

00:42:23,520 --> 00:42:27,090
structure as our old chart so the

00:42:25,350 --> 00:42:29,370
question is can we use our old chart to

00:42:27,090 --> 00:42:32,070
show this data set in the answer as yes

00:42:29,370 --> 00:42:33,630
as you'll see so this is the chart that

00:42:32,070 --> 00:42:35,070
I've imported from the other notebook

00:42:33,630 --> 00:42:37,410
that's actually a slightly different

00:42:35,070 --> 00:42:39,570
definition using canvas rather than SVG

00:42:37,410 --> 00:42:41,580
and so now all I've done is I added a

00:42:39,570 --> 00:42:43,560
little whiff Clause here to inject our

00:42:41,580 --> 00:42:45,810
data into this chart definition so we're

00:42:43,560 --> 00:42:47,610
just replacing that definition and you

00:42:45,810 --> 00:42:49,710
can see that it's now a real-time chart

00:42:47,610 --> 00:42:52,020
that's sort of ticking as I get new data

00:42:49,710 --> 00:42:54,210
from the server without having to change

00:42:52,020 --> 00:42:56,310
anything else about the chart definition

00:42:54,210 --> 00:42:58,170
but the cool thing is I can actually

00:42:56,310 --> 00:42:59,700
customize that to our definition a

00:42:58,170 --> 00:43:02,010
little bit more if I want to so I'm

00:42:59,700 --> 00:43:03,540
going to load d3 and one of the things

00:43:02,010 --> 00:43:05,880
that I want to do here is I want to fix

00:43:03,540 --> 00:43:08,640
the Y scale so they don't sort of bounce

00:43:05,880 --> 00:43:10,590
up and down as the extent of my data

00:43:08,640 --> 00:43:12,630
changes I just want like a fixed value

00:43:10,590 --> 00:43:15,300
it represents like what the expected

00:43:12,630 --> 00:43:16,950
values are for this data set and that

00:43:15,300 --> 00:43:19,860
way it won't sort of bounce up and down

00:43:16,950 --> 00:43:21,960
distractingly so in order to do that I

00:43:19,860 --> 00:43:23,720
need to import some other symbols I need

00:43:21,960 --> 00:43:26,700
to know what the size of the chart is

00:43:23,720 --> 00:43:29,820
but then after that I can inject my Y

00:43:26,700 --> 00:43:33,000
definition and so now the chart is got

00:43:29,820 --> 00:43:36,330
this fixed range and similarly I can do

00:43:33,000 --> 00:43:38,700
the same thing with the X scale so like

00:43:36,330 --> 00:43:41,520
let's say rather than again deriving the

00:43:38,700 --> 00:43:43,080
domain of the X scale from the data I

00:43:41,520 --> 00:43:45,660
just want to have like fixed moving

00:43:43,080 --> 00:43:47,460
window so that it updates at 60 frames

00:43:45,660 --> 00:43:50,370
per second so I'll do that with the

00:43:47,460 --> 00:43:53,280
generator and here it's like a generator

00:43:50,370 --> 00:43:55,350
that emits the X scale where the domain

00:43:53,280 --> 00:44:02,720
of the X scale is based on the current

00:43:55,350 --> 00:44:05,599
time I'll finish typing on

00:44:02,720 --> 00:44:08,720
and then go up the import statement and

00:44:05,599 --> 00:44:13,300
inject X right so now it's it's smoothly

00:44:08,720 --> 00:44:13,300
sliding rather than ticking every update

00:44:15,160 --> 00:44:19,310
okay so the last concept that I want to

00:44:17,569 --> 00:44:21,770
talk about is that because these

00:44:19,310 --> 00:44:25,849
notebooks run in the browser and not in

00:44:21,770 --> 00:44:27,890
a desktop app or on the cloud it's a web

00:44:25,849 --> 00:44:29,359
first discovery environment like all the

00:44:27,890 --> 00:44:32,089
computation and rendering happens

00:44:29,359 --> 00:44:35,089
locally inside the client so what does

00:44:32,089 --> 00:44:37,339
that mean well a web first environment

00:44:35,089 --> 00:44:39,380
has to embrace web standards including

00:44:37,339 --> 00:44:41,119
vanilla JavaScript and Dom it works with

00:44:39,380 --> 00:44:43,790
today's open source whether that's

00:44:41,119 --> 00:44:46,430
example code you find in a tutorial or

00:44:43,790 --> 00:44:48,380
libraries that are published to NPM and

00:44:46,430 --> 00:44:49,849
it minimizes the specialized knowledge

00:44:48,380 --> 00:44:53,720
that you need in order to be productive

00:44:49,849 --> 00:44:56,450
in that environment there is some new

00:44:53,720 --> 00:44:58,040
syntax in d3 Express for reactivity but

00:44:56,450 --> 00:45:00,740
I've tried to keep it as small and as

00:44:58,040 --> 00:45:03,560
familiar as possible such as by using

00:45:00,740 --> 00:45:05,569
generators so these are the four

00:45:03,560 --> 00:45:08,119
different ways that you can define cells

00:45:05,569 --> 00:45:11,030
or variables and d3 Express and these

00:45:08,119 --> 00:45:12,859
are just expressions block statement the

00:45:11,030 --> 00:45:14,420
funky block statement preceded by an

00:45:12,859 --> 00:45:16,130
asterisk which means that it's a

00:45:14,420 --> 00:45:18,369
generator and then you're sort of

00:45:16,130 --> 00:45:20,750
standard function declaration here and

00:45:18,369 --> 00:45:22,790
the idea is that by having sort of

00:45:20,750 --> 00:45:24,920
minimal syntax is very different from

00:45:22,790 --> 00:45:27,260
let's say using a reactive framework

00:45:24,920 --> 00:45:28,970
where there's a lot of boilerplate sort

00:45:27,260 --> 00:45:30,589
of API that you're wrapping on top of

00:45:28,970 --> 00:45:32,300
your code here I want to make the

00:45:30,589 --> 00:45:33,560
reactiveness feel like a more of a

00:45:32,300 --> 00:45:35,390
language feature or something that's

00:45:33,560 --> 00:45:37,400
intrinsic to the programming environment

00:45:35,390 --> 00:45:39,319
rather than a layer that you add on top

00:45:37,400 --> 00:45:41,030
of that and that's important too if you

00:45:39,319 --> 00:45:43,430
want to take this code and pull it out

00:45:41,030 --> 00:45:44,780
and put it into your react app there's

00:45:43,430 --> 00:45:46,750
not really anything that you have to

00:45:44,780 --> 00:45:48,890
remove in order to plug that in there

00:45:46,750 --> 00:45:50,270
you're just trading one reactive

00:45:48,890 --> 00:45:55,880
environment for another reactive

00:45:50,270 --> 00:45:57,230
environment so another important

00:45:55,880 --> 00:45:58,609
principle is that the web first

00:45:57,230 --> 00:45:59,960
environment lets you run your code

00:45:58,609 --> 00:46:02,240
anywhere right because your code is

00:45:59,960 --> 00:46:04,849
running in the browser there's nothing

00:46:02,240 --> 00:46:06,740
to install which means that it's easier

00:46:04,849 --> 00:46:09,710
for others to repeat and validate your

00:46:06,740 --> 00:46:11,480
analysis like you didn't have to

00:46:09,710 --> 00:46:13,160
reproduce the exact environment or

00:46:11,480 --> 00:46:14,569
install the right set of packages in

00:46:13,160 --> 00:46:15,589
order to run your code if it's running

00:46:14,569 --> 00:46:17,660
in your browser it's going

00:46:15,589 --> 00:46:19,759
run in your reader sprout or browsers as

00:46:17,660 --> 00:46:21,109
well and that means that you can

00:46:19,759 --> 00:46:23,660
transition more easily from your

00:46:21,109 --> 00:46:24,680
exploration to your explanation

00:46:23,660 --> 00:46:26,569
you don't have to start over from

00:46:24,680 --> 00:46:28,430
scratch switching from one tool or one

00:46:26,569 --> 00:46:30,019
environment to another in order to

00:46:28,430 --> 00:46:35,900
communicate whatever it is you've

00:46:30,019 --> 00:46:37,789
learned in your discovery process so to

00:46:35,900 --> 00:46:40,190
keep it comparison to what commonly done

00:46:37,789 --> 00:46:43,640
today you know we might publish a model

00:46:40,190 --> 00:46:46,039
or some data sets up to github and what

00:46:43,640 --> 00:46:48,380
I'm trying to do is to make this process

00:46:46,039 --> 00:46:52,609
a little bit richer I guess like to make

00:46:48,380 --> 00:46:54,890
it so that the ability for our readers

00:46:52,609 --> 00:46:58,009
to reproduce these environments and run

00:46:54,890 --> 00:46:59,960
this code is easier as the bar is

00:46:58,009 --> 00:47:01,489
lowered we don't have to sort of read

00:46:59,960 --> 00:47:03,140
these long instructions in order to

00:47:01,489 --> 00:47:08,749
reproduce these environments we can just

00:47:03,140 --> 00:47:10,279
sort of run them directly and I'll end

00:47:08,749 --> 00:47:11,569
on like another sort of Victor quote

00:47:10,279 --> 00:47:15,979
well I have a little bit more to say

00:47:11,569 --> 00:47:18,140
after this but the point here is making

00:47:15,979 --> 00:47:19,579
your code for analysis more portable can

00:47:18,140 --> 00:47:22,609
have a transformative effect on how we

00:47:19,579 --> 00:47:25,249
communicate so to quote Bret Victor

00:47:22,609 --> 00:47:27,079
again an active reader asks questions

00:47:25,249 --> 00:47:28,940
considers alternatives questions

00:47:27,079 --> 00:47:31,430
assumptions and even questions the

00:47:28,940 --> 00:47:33,229
trustworthiness of the author an active

00:47:31,430 --> 00:47:35,299
reader tries to generalize specific

00:47:33,229 --> 00:47:37,309
examples and devise specific examples

00:47:35,299 --> 00:47:39,349
for generalities an active reader

00:47:37,309 --> 00:47:41,509
doesn't passively sponge up information

00:47:39,349 --> 00:47:43,190
but uses the author's argument as a

00:47:41,509 --> 00:47:45,859
springboard for critical thought and

00:47:43,190 --> 00:47:47,509
deep understanding so the point is if

00:47:45,859 --> 00:47:49,130
the code is running in your readers

00:47:47,509 --> 00:47:51,109
browser they have a much better ability

00:47:49,130 --> 00:47:52,519
to see how that code works to tinker

00:47:51,109 --> 00:47:54,109
with the code change some of the

00:47:52,519 --> 00:47:56,390
assumptions that you make to fork it

00:47:54,109 --> 00:47:59,239
into another environment and start doing

00:47:56,390 --> 00:48:01,219
some new things or even to just explore

00:47:59,239 --> 00:48:04,940
interactively because the code is again

00:48:01,219 --> 00:48:09,259
running inside of their browser okay now

00:48:04,940 --> 00:48:12,049
for the disappointment as much as I want

00:48:09,259 --> 00:48:13,549
to release d3 Express this is quite

00:48:12,049 --> 00:48:14,869
different from sort of library stuff

00:48:13,549 --> 00:48:16,700
there's a lot more work here when you're

00:48:14,869 --> 00:48:19,969
building a platform service for people

00:48:16,700 --> 00:48:21,680
to use in addition to the software and

00:48:19,969 --> 00:48:24,859
so it's not really ready for you to go

00:48:21,680 --> 00:48:27,970
yet and start using it I was trying

00:48:24,859 --> 00:48:30,340
frantically to release part of it

00:48:27,970 --> 00:48:32,109
by the time of the stock but it will

00:48:30,340 --> 00:48:34,119
still be a few more days so if you want

00:48:32,109 --> 00:48:35,770
to try it out you can go to this URL and

00:48:34,119 --> 00:48:38,349
you can sign up for it you can also get

00:48:35,770 --> 00:48:40,420
in touch with me if you want to help me

00:48:38,349 --> 00:48:42,849
build it if you're also looking for a

00:48:40,420 --> 00:48:46,160
job also get in touch with me I would

00:48:42,849 --> 00:48:50,230
love help doing this so thank you

00:48:46,160 --> 00:48:50,960
[Applause]

00:48:50,230 --> 00:48:52,890
[Music]

00:48:50,960 --> 00:48:54,950
[Applause]

00:48:52,890 --> 00:48:54,950

YouTube URL: https://www.youtube.com/watch?v=aT4JvF7sglg


