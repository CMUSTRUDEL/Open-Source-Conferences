Title: Moâ€™Problems, Moâ€™Nads - Kyle Simpson - CityJS Conf 2020
Publication date: 2020-10-03
Playlist: CityJS Conf 2020
Description: 
	Kyle Simpson is Director of Web Futures at Getify Solutions, where he envisions and evangelizes what's next for Open Web technologies, especially JS. He writes, speaks, teaches, and codes OSS.


_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:18,080 --> 00:00:23,680
[Music]

00:00:22,400 --> 00:00:25,439
hello and welcome

00:00:23,680 --> 00:00:27,840
i'm kyle simpson but most of you know me

00:00:25,439 --> 00:00:29,519
as getify i'm director of web futures

00:00:27,840 --> 00:00:31,199
for my own company which means i get to

00:00:29,519 --> 00:00:32,719
spend my time focusing on

00:00:31,199 --> 00:00:34,239
envisioning the future of the web and

00:00:32,719 --> 00:00:35,200
then helping empower other people to

00:00:34,239 --> 00:00:36,960
achieve it

00:00:35,200 --> 00:00:39,200
to that end i've recently partnered with

00:00:36,960 --> 00:00:40,719
kudota who also makes the tab 9 plugin

00:00:39,200 --> 00:00:42,320
for your favorite editors

00:00:40,719 --> 00:00:44,480
and they have this machine learning

00:00:42,320 --> 00:00:45,440
model that helps the tool make semantic

00:00:44,480 --> 00:00:47,440
suggestions

00:00:45,440 --> 00:00:49,039
to help you as a developer do your jobs

00:00:47,440 --> 00:00:51,120
better super excited about this

00:00:49,039 --> 00:00:51,680
symbiosis between developers and smarter

00:00:51,120 --> 00:00:54,719
tools

00:00:51,680 --> 00:00:56,320
so stay tuned for more in that space

00:00:54,719 --> 00:00:57,920
some of you may know some of the books

00:00:56,320 --> 00:00:59,680
that i've written but you may not have

00:00:57,920 --> 00:01:00,800
heard of this book the functional light

00:00:59,680 --> 00:01:02,000
javascript book

00:01:00,800 --> 00:01:04,080
i encourage you to check it out because

00:01:02,000 --> 00:01:05,920
there's an appendix about today's topic

00:01:04,080 --> 00:01:08,000
and yes i know this word monad is kind

00:01:05,920 --> 00:01:09,200
of scary but in these brief few minutes

00:01:08,000 --> 00:01:10,240
that we have together i hope that you'll

00:01:09,200 --> 00:01:12,000
stick with us because i think there's a

00:01:10,240 --> 00:01:13,840
lot to uncover

00:01:12,000 --> 00:01:15,360
some of you heard this quote before and

00:01:13,840 --> 00:01:17,119
you may have wondered like where does

00:01:15,360 --> 00:01:19,200
this come from or you may have heard

00:01:17,119 --> 00:01:21,119
inserted other words besides regular

00:01:19,200 --> 00:01:23,040
expression into this quote

00:01:21,119 --> 00:01:24,799
but i think it's an apt description of

00:01:23,040 --> 00:01:26,159
kind of the fear that we sometimes have

00:01:24,799 --> 00:01:28,799
of are we using

00:01:26,159 --> 00:01:30,479
the right tools in the right way now

00:01:28,799 --> 00:01:30,960
it's entirely fair that some of you may

00:01:30,479 --> 00:01:32,560
feel that

00:01:30,960 --> 00:01:34,799
this is exactly what i'm about to do

00:01:32,560 --> 00:01:36,479
with monads i understand i get it

00:01:34,799 --> 00:01:38,640
but i hope that you'll keep an open mind

00:01:36,479 --> 00:01:40,000
because the truth is that regular

00:01:38,640 --> 00:01:42,960
expressions kind of get a bad

00:01:40,000 --> 00:01:45,119
rap i mean yes regular expressions can

00:01:42,960 --> 00:01:47,360
be abused like for example parsing

00:01:45,119 --> 00:01:49,520
all possible html that you ever may run

00:01:47,360 --> 00:01:50,720
across that's entirely not the right

00:01:49,520 --> 00:01:51,840
kind of thing to do with regular

00:01:50,720 --> 00:01:54,320
expressions

00:01:51,840 --> 00:01:56,240
on the other hand there are tools that

00:01:54,320 --> 00:01:58,640
can do jobs very effectively

00:01:56,240 --> 00:01:59,920
if your job is to do one specific thing

00:01:58,640 --> 00:02:02,079
like parse one

00:01:59,920 --> 00:02:03,920
specific string of html a regular

00:02:02,079 --> 00:02:06,159
expression can absolutely be

00:02:03,920 --> 00:02:08,000
that right tool speaking of that adage

00:02:06,159 --> 00:02:10,000
the right tool for the right job there's

00:02:08,000 --> 00:02:12,239
also using the right tool in the right

00:02:10,000 --> 00:02:14,000
way if i have a hammer in my hand and

00:02:12,239 --> 00:02:15,680
the task is to put a nail in the wall

00:02:14,000 --> 00:02:17,920
and i swing it with my hand everything

00:02:15,680 --> 00:02:19,760
works fine but if i use that same hammer

00:02:17,920 --> 00:02:20,080
and put it in my mouth and try to swing

00:02:19,760 --> 00:02:21,440
it

00:02:20,080 --> 00:02:24,000
we're not going to get the same good

00:02:21,440 --> 00:02:25,280
result so you have to use the right tool

00:02:24,000 --> 00:02:27,200
for the right job

00:02:25,280 --> 00:02:28,879
in the right way and the same is true of

00:02:27,200 --> 00:02:30,879
regular expressions and i argue

00:02:28,879 --> 00:02:33,360
the same is true of monads we have to

00:02:30,879 --> 00:02:35,519
select the right tools for these jobs

00:02:33,360 --> 00:02:36,400
see not all tasks are appropriate for

00:02:35,519 --> 00:02:38,080
all tools so

00:02:36,400 --> 00:02:40,080
if we're talking about that generalized

00:02:38,080 --> 00:02:41,760
task versus a more specialized one

00:02:40,080 --> 00:02:44,239
and i think that's what we'll see out of

00:02:41,760 --> 00:02:45,840
monads in our discussion today

00:02:44,239 --> 00:02:47,280
so how are we going to approach this

00:02:45,840 --> 00:02:49,200
topic of monads

00:02:47,280 --> 00:02:50,319
well we could start with a very formal

00:02:49,200 --> 00:02:52,720
statement of the type

00:02:50,319 --> 00:02:53,599
theory using some type and haskell-ish

00:02:52,720 --> 00:02:54,959
syntax

00:02:53,599 --> 00:02:56,720
and i don't know about you but that

00:02:54,959 --> 00:02:57,599
looks very greek to me so it doesn't

00:02:56,720 --> 00:03:00,000
very much

00:02:57,599 --> 00:03:02,080
speak to me so i think we won't go that

00:03:00,000 --> 00:03:03,680
route now others of you may have taken

00:03:02,080 --> 00:03:05,360
a different approach and read blog posts

00:03:03,680 --> 00:03:07,599
where you've heard monads described as

00:03:05,360 --> 00:03:10,159
burritos or onions or other sorts of

00:03:07,599 --> 00:03:11,920
silly metaphors my own favorite personal

00:03:10,159 --> 00:03:13,840
metaphor is the rubik's cube

00:03:11,920 --> 00:03:15,120
because the rubik's cube basically has

00:03:13,840 --> 00:03:17,280
these different sides

00:03:15,120 --> 00:03:18,480
you don't have to study every single

00:03:17,280 --> 00:03:20,560
side all at once

00:03:18,480 --> 00:03:21,840
you can look at just one side and that's

00:03:20,560 --> 00:03:23,519
what we're doing in our brief time

00:03:21,840 --> 00:03:24,159
together today we're looking at one

00:03:23,519 --> 00:03:27,680
specific

00:03:24,159 --> 00:03:29,519
aspect of monads but to answer that very

00:03:27,680 --> 00:03:31,440
prescient question that is in your mind

00:03:29,519 --> 00:03:34,480
right now that pressing question of

00:03:31,440 --> 00:03:36,480
what is a monad well let me give you an

00:03:34,480 --> 00:03:38,480
example of an answer to that maybe not

00:03:36,480 --> 00:03:40,239
the only an authoritative answer but one

00:03:38,480 --> 00:03:42,159
side of that ruby's cube so we could say

00:03:40,239 --> 00:03:44,400
that it's a set of rules for how one

00:03:42,159 --> 00:03:46,720
collection of values and behaviors

00:03:44,400 --> 00:03:48,959
can interact with another collection of

00:03:46,720 --> 00:03:50,560
values and or behaviors

00:03:48,959 --> 00:03:52,959
so if we squint it at that we could sort

00:03:50,560 --> 00:03:54,239
of call that a data structure

00:03:52,959 --> 00:03:55,920
even though i know that's going to upset

00:03:54,239 --> 00:03:57,680
a bunch of people because technically

00:03:55,920 --> 00:03:58,720
it's supposed to be called an algebraic

00:03:57,680 --> 00:04:00,879
structure

00:03:58,720 --> 00:04:02,239
ultimately i find this question of what

00:04:00,879 --> 00:04:04,560
kind of a distraction

00:04:02,239 --> 00:04:06,319
because it's focused on the identity

00:04:04,560 --> 00:04:07,519
from like a type description is very

00:04:06,319 --> 00:04:09,760
academic

00:04:07,519 --> 00:04:11,439
and and that description doesn't really

00:04:09,760 --> 00:04:12,159
speak to what we want to be talking

00:04:11,439 --> 00:04:14,319
about

00:04:12,159 --> 00:04:15,200
so i think that there's a better way of

00:04:14,319 --> 00:04:17,120
looking at this

00:04:15,200 --> 00:04:18,720
instead of the what question i really

00:04:17,120 --> 00:04:19,440
want us to look at one specific side of

00:04:18,720 --> 00:04:22,479
the cube

00:04:19,440 --> 00:04:23,199
which is more like the why question i

00:04:22,479 --> 00:04:24,960
used some big

00:04:23,199 --> 00:04:26,479
and confusing words just a moment ago

00:04:24,960 --> 00:04:27,759
and i don't know about you but i didn't

00:04:26,479 --> 00:04:29,759
even know there was more than one

00:04:27,759 --> 00:04:32,240
algebra that's a plural noun

00:04:29,759 --> 00:04:34,240
this is like toto i've got a feeling

00:04:32,240 --> 00:04:35,919
we're not in kansas anymore

00:04:34,240 --> 00:04:37,919
but instead of being distracted by that

00:04:35,919 --> 00:04:40,160
what question of its identity

00:04:37,919 --> 00:04:41,840
i think this why question is more useful

00:04:40,160 --> 00:04:42,720
so this talk will focus on building an

00:04:41,840 --> 00:04:44,880
intuition

00:04:42,720 --> 00:04:46,960
about the why question what can we do

00:04:44,880 --> 00:04:49,199
with these things in our code

00:04:46,960 --> 00:04:51,759
and why does that even matter now as

00:04:49,199 --> 00:04:53,440
soon as i dive into a talk on this topic

00:04:51,759 --> 00:04:54,880
out of the woodwork where there will be

00:04:53,440 --> 00:04:58,240
waves of the well

00:04:54,880 --> 00:04:59,759
actually kind of description of oh i

00:04:58,240 --> 00:05:00,080
didn't get this exactly right or didn't

00:04:59,759 --> 00:05:02,080
use

00:05:00,080 --> 00:05:03,840
exactly the precise word we're

00:05:02,080 --> 00:05:05,039
deliberately being informal here

00:05:03,840 --> 00:05:07,440
we're deliberately trying to be

00:05:05,039 --> 00:05:10,160
intuitive rather than academic about it

00:05:07,440 --> 00:05:11,840
and i understand why the communities

00:05:10,160 --> 00:05:13,680
especially functional programming

00:05:11,840 --> 00:05:15,680
maybe more so than others they want to

00:05:13,680 --> 00:05:16,880
protect the things that are so easy to

00:05:15,680 --> 00:05:18,720
misunderstand

00:05:16,880 --> 00:05:20,479
so i get it but it sometimes comes

00:05:18,720 --> 00:05:21,360
across like the functional programming

00:05:20,479 --> 00:05:23,120
police who are saying

00:05:21,360 --> 00:05:25,840
you know there's only one right way to

00:05:23,120 --> 00:05:27,440
do this and i reject that statement

00:05:25,840 --> 00:05:29,039
there's not only one right way we're

00:05:27,440 --> 00:05:31,120
going to look at just one

00:05:29,039 --> 00:05:32,080
of the facets one of the sides of this

00:05:31,120 --> 00:05:33,840
rubik's cube

00:05:32,080 --> 00:05:36,479
and we will shun some of that more

00:05:33,840 --> 00:05:37,120
formal terminology and theory in favor

00:05:36,479 --> 00:05:38,639
of

00:05:37,120 --> 00:05:40,400
what can i do with an encode and why

00:05:38,639 --> 00:05:42,720
would that be useful to me

00:05:40,400 --> 00:05:44,479
so boiling this very complex space of

00:05:42,720 --> 00:05:45,199
category theory and types and all of

00:05:44,479 --> 00:05:48,000
that down

00:05:45,199 --> 00:05:48,960
to just two concepts that maybe we can

00:05:48,000 --> 00:05:50,639
hang on to

00:05:48,960 --> 00:05:52,080
we're going to take all of the ideas of

00:05:50,639 --> 00:05:54,160
interfaces and types and we're just

00:05:52,080 --> 00:05:55,440
going to put it in this one word type

00:05:54,160 --> 00:05:57,759
and then we're going to take all of the

00:05:55,440 --> 00:05:58,960
ideas about what we do in our programs

00:05:57,759 --> 00:06:00,800
the things that we interact with and

00:05:58,960 --> 00:06:02,240
we're just going to call those values

00:06:00,800 --> 00:06:04,880
and so we'll look at a comparison

00:06:02,240 --> 00:06:07,759
between explaining a subject as a type

00:06:04,880 --> 00:06:09,520
or explaining a subject as a value so

00:06:07,759 --> 00:06:10,960
give you an example the number type

00:06:09,520 --> 00:06:13,039
tells us that there are these things

00:06:10,960 --> 00:06:14,560
that we can do mathematic operations on

00:06:13,039 --> 00:06:16,880
and they tell you specifically what we

00:06:14,560 --> 00:06:18,080
can predict after we do those mathematic

00:06:16,880 --> 00:06:20,319
operations

00:06:18,080 --> 00:06:22,240
but if i don't have a specific concrete

00:06:20,319 --> 00:06:24,400
value i can't actually do math

00:06:22,240 --> 00:06:25,360
i need the number 42 so that i can add

00:06:24,400 --> 00:06:28,479
or subtract

00:06:25,360 --> 00:06:29,360
from that value in javascript as in some

00:06:28,479 --> 00:06:31,680
other languages

00:06:29,360 --> 00:06:33,919
quite frankly these lines are quite

00:06:31,680 --> 00:06:35,600
blurred there's not a very strong

00:06:33,919 --> 00:06:36,800
distinction between types and values in

00:06:35,600 --> 00:06:38,880
a language like this

00:06:36,800 --> 00:06:40,240
there is some but not nearly as much as

00:06:38,880 --> 00:06:42,880
in other languages

00:06:40,240 --> 00:06:44,080
and so we kind of mix and match these

00:06:42,880 --> 00:06:45,919
ideas together

00:06:44,080 --> 00:06:47,759
and and if we were to tease them apart i

00:06:45,919 --> 00:06:49,280
would say that types are focusing more

00:06:47,759 --> 00:06:51,360
on that what question

00:06:49,280 --> 00:06:52,479
whereas values and that's what we want

00:06:51,360 --> 00:06:53,039
to focus on because they're going to

00:06:52,479 --> 00:06:56,080
focus

00:06:53,039 --> 00:06:58,880
more on that why question

00:06:56,080 --> 00:06:59,360
so the values are behaviors that we can

00:06:58,880 --> 00:07:01,360
use

00:06:59,360 --> 00:07:02,960
where the types are the behaviors that

00:07:01,360 --> 00:07:05,919
we can expect

00:07:02,960 --> 00:07:06,800
so what does that monad thing mean well

00:07:05,919 --> 00:07:09,039
i want to

00:07:06,800 --> 00:07:10,479
frame it this way i want to talk about

00:07:09,039 --> 00:07:13,199
the monad

00:07:10,479 --> 00:07:15,360
versus a monad v monad being sort of

00:07:13,199 --> 00:07:16,479
this proper noun thing described by type

00:07:15,360 --> 00:07:19,440
and category theory

00:07:16,479 --> 00:07:20,319
and a monad being this thing that can be

00:07:19,440 --> 00:07:23,759
in our code

00:07:20,319 --> 00:07:26,319
so we have the monad versus a monon

00:07:23,759 --> 00:07:28,240
now v monad tells us some very important

00:07:26,319 --> 00:07:29,360
things some formal things like the three

00:07:28,240 --> 00:07:31,199
laws for example

00:07:29,360 --> 00:07:33,120
the left identity the right identity and

00:07:31,199 --> 00:07:35,280
the associative law they tell us things

00:07:33,120 --> 00:07:37,840
about what we can expect out of

00:07:35,280 --> 00:07:38,560
any sort of monadic value that we might

00:07:37,840 --> 00:07:41,759
run across

00:07:38,560 --> 00:07:43,680
in a program but it's the data structure

00:07:41,759 --> 00:07:44,479
itself it's the value itself in our

00:07:43,680 --> 00:07:46,319
program

00:07:44,479 --> 00:07:48,160
that we are going to actually interact

00:07:46,319 --> 00:07:48,800
with so where the law might tell us that

00:07:48,160 --> 00:07:51,520
we can do

00:07:48,800 --> 00:07:53,680
something like a chain operation it's

00:07:51,520 --> 00:07:54,639
the actual value that may have a method

00:07:53,680 --> 00:07:56,800
called chain

00:07:54,639 --> 00:07:58,800
or flat map or bind that we can use in

00:07:56,800 --> 00:08:00,560
our programs and speaking of these

00:07:58,800 --> 00:08:02,160
values and their behaviors we can

00:08:00,560 --> 00:08:03,680
actually mix and match values and

00:08:02,160 --> 00:08:05,360
behaviors together this is one of my

00:08:03,680 --> 00:08:06,160
favorite things because we get more

00:08:05,360 --> 00:08:08,160
powerful

00:08:06,160 --> 00:08:10,400
monads out of doing that we get things

00:08:08,160 --> 00:08:11,039
like the maybe the either and the i o

00:08:10,400 --> 00:08:12,560
and those are

00:08:11,039 --> 00:08:14,800
monads that we'll see here in just a

00:08:12,560 --> 00:08:15,520
little bit so i think we should look at

00:08:14,800 --> 00:08:16,800
some code

00:08:15,520 --> 00:08:18,879
to try to make this a little bit more

00:08:16,800 --> 00:08:20,240
concrete this is an example using a

00:08:18,879 --> 00:08:20,879
library that i wrote which is called

00:08:20,240 --> 00:08:22,080
moneo

00:08:20,879 --> 00:08:24,000
and i'm not trying to sell you on the

00:08:22,080 --> 00:08:26,000
library i'm just using it as a concrete

00:08:24,000 --> 00:08:27,759
way to illustrate in our code

00:08:26,000 --> 00:08:30,160
here with moneo we have this thing

00:08:27,759 --> 00:08:32,080
called just it's just a function

00:08:30,160 --> 00:08:33,279
you see on line one i call it and i pass

00:08:32,080 --> 00:08:35,680
in the value three

00:08:33,279 --> 00:08:36,479
and what i get back is this monad

00:08:35,680 --> 00:08:38,640
wrapper

00:08:36,479 --> 00:08:40,880
this monatic wrapper around the value

00:08:38,640 --> 00:08:42,959
three i can inspect it i can check to

00:08:40,880 --> 00:08:44,640
see if something is of that type

00:08:42,959 --> 00:08:46,080
now as a word of warning you don't

00:08:44,640 --> 00:08:49,120
typically see the

00:08:46,080 --> 00:08:50,959
just as its own standalone monad it's

00:08:49,120 --> 00:08:52,399
usually part of this bigger monad

00:08:50,959 --> 00:08:54,399
that i referred to just a moment ago

00:08:52,399 --> 00:08:56,399
called the maybe that maybe is usually a

00:08:54,399 --> 00:08:58,240
pairing of a just or a nothing

00:08:56,399 --> 00:09:00,240
and so you don't see it usually called

00:08:58,240 --> 00:09:01,839
out but in the mineo library i made it

00:09:00,240 --> 00:09:03,360
its own specific monad it's kind of

00:09:01,839 --> 00:09:05,440
serving the purpose of what we call

00:09:03,360 --> 00:09:07,279
the identity monad meaning it just holds

00:09:05,440 --> 00:09:09,040
a value and then lets that value

00:09:07,279 --> 00:09:10,320
come right back out to be used in other

00:09:09,040 --> 00:09:13,200
operations

00:09:10,320 --> 00:09:13,760
so that's an example of using a monad in

00:09:13,200 --> 00:09:15,519
code

00:09:13,760 --> 00:09:17,120
now there's lots more behavior that we

00:09:15,519 --> 00:09:18,720
want to uncover from that

00:09:17,120 --> 00:09:20,399
but if you can get comfortable with this

00:09:18,720 --> 00:09:22,880
idea that we could take a value like

00:09:20,399 --> 00:09:24,480
3 and wrap it in a magnetic value the

00:09:22,880 --> 00:09:25,519
next most important question you'll

00:09:24,480 --> 00:09:27,200
wonder is

00:09:25,519 --> 00:09:29,040
why would i do that why is that

00:09:27,200 --> 00:09:31,279
important and that's what we'll spend

00:09:29,040 --> 00:09:34,480
the rest of this talk focusing on

00:09:31,279 --> 00:09:36,800
so to illustrate the monad but using

00:09:34,480 --> 00:09:38,080
actual concrete code here's those three

00:09:36,800 --> 00:09:40,399
laws that i just referred to

00:09:38,080 --> 00:09:42,560
actually illustrated in code we see the

00:09:40,399 --> 00:09:44,000
left identity law the right identity law

00:09:42,560 --> 00:09:46,080
and the associativity law

00:09:44,000 --> 00:09:47,360
now i want to call out that while we see

00:09:46,080 --> 00:09:49,839
the actual usage

00:09:47,360 --> 00:09:50,480
of things like the chain method on line

00:09:49,839 --> 00:09:52,880
three

00:09:50,480 --> 00:09:55,200
you see that being used that's just a

00:09:52,880 --> 00:09:57,040
representation of what the types

00:09:55,200 --> 00:09:59,040
and the category theory tells us a

00:09:57,040 --> 00:10:01,279
monadic value needs to be able to do

00:09:59,040 --> 00:10:02,399
it doesn't have to be called chain and

00:10:01,279 --> 00:10:04,800
indeed you often

00:10:02,399 --> 00:10:05,440
see it called bind flat map other things

00:10:04,800 --> 00:10:08,000
like that

00:10:05,440 --> 00:10:09,920
so this code is not proving all of the

00:10:08,000 --> 00:10:12,399
monadic theory all of the laws

00:10:09,920 --> 00:10:14,240
but rather for a specific implementation

00:10:12,399 --> 00:10:16,560
like the one in my library

00:10:14,240 --> 00:10:18,000
and for a specific value like the value

00:10:16,560 --> 00:10:20,079
three and for a specific

00:10:18,000 --> 00:10:22,880
set of functional behaviors here like

00:10:20,079 --> 00:10:25,200
the f and the g functions line 11 and 12

00:10:22,880 --> 00:10:26,079
it's just saying that for that specific

00:10:25,200 --> 00:10:28,399
scenario

00:10:26,079 --> 00:10:30,240
we can see the laws being played out we

00:10:28,399 --> 00:10:31,680
can see that these two sides are equal

00:10:30,240 --> 00:10:33,440
and that's what the laws tell us that we

00:10:31,680 --> 00:10:35,680
should be able to predict

00:10:33,440 --> 00:10:37,440
now code like this is not good enough if

00:10:35,680 --> 00:10:38,560
your goal is to be like a mathematician

00:10:37,440 --> 00:10:40,399
or a theorist

00:10:38,560 --> 00:10:41,600
but it's absolutely good enough to start

00:10:40,399 --> 00:10:44,240
getting our feet wet

00:10:41,600 --> 00:10:44,959
with actual code and all we need to take

00:10:44,240 --> 00:10:47,680
from this

00:10:44,959 --> 00:10:49,040
is that these things if we have a lawful

00:10:47,680 --> 00:10:50,560
implementation of a monad

00:10:49,040 --> 00:10:53,120
they're going to give us predictable

00:10:50,560 --> 00:10:54,640
behaviors we won't necessarily use these

00:10:53,120 --> 00:10:56,560
direct behaviors very often

00:10:54,640 --> 00:10:58,800
but we'll use lots of other things that

00:10:56,560 --> 00:11:01,440
build on these behaviors

00:10:58,800 --> 00:11:03,040
so speaking of these other sorts of

00:11:01,440 --> 00:11:04,160
behaviors that we can mix and i referred

00:11:03,040 --> 00:11:06,959
to that just a moment ago

00:11:04,160 --> 00:11:08,320
i like to call this monads and friends

00:11:06,959 --> 00:11:09,760
right it's like a group of

00:11:08,320 --> 00:11:11,839
kids that have gathered together in the

00:11:09,760 --> 00:11:12,800
sandbox to play together they have lots

00:11:11,839 --> 00:11:14,399
of different

00:11:12,800 --> 00:11:16,399
kinds of identities there's lots of

00:11:14,399 --> 00:11:18,560
different things so we can say these

00:11:16,399 --> 00:11:20,399
other behaviors like semi-group and

00:11:18,560 --> 00:11:22,240
foldable and applicative those have

00:11:20,399 --> 00:11:24,800
these fancy names and they are very

00:11:22,240 --> 00:11:27,279
distinct entities within that bigger

00:11:24,800 --> 00:11:28,800
category theory space but i really like

00:11:27,279 --> 00:11:30,079
to just refer to them as friends of

00:11:28,800 --> 00:11:32,560
monads because in my

00:11:30,079 --> 00:11:33,279
experience i often see them illustrated

00:11:32,560 --> 00:11:35,600
together

00:11:33,279 --> 00:11:36,959
implemented together on values and i

00:11:35,600 --> 00:11:37,920
think that that makes them all more

00:11:36,959 --> 00:11:39,920
powerful when

00:11:37,920 --> 00:11:41,360
they come together so in my perspective

00:11:39,920 --> 00:11:44,079
we'll be illustrating these

00:11:41,360 --> 00:11:46,640
as all together under this one sandbox

00:11:44,079 --> 00:11:48,640
that we'll call monads and friends

00:11:46,640 --> 00:11:50,560
now i wanted to give you a quick example

00:11:48,640 --> 00:11:52,160
of using a monad and i'm going to get

00:11:50,560 --> 00:11:52,639
into more examples in just a moment but

00:11:52,160 --> 00:11:54,160
just

00:11:52,639 --> 00:11:56,000
so that we're not dealing only with this

00:11:54,160 --> 00:11:58,480
abstract idea of that just you remember

00:11:56,000 --> 00:11:59,600
i referred to this maybe monad well here

00:11:58,480 --> 00:12:02,000
i'm using the

00:11:59,600 --> 00:12:03,920
maybe monad and i'm actually invoking

00:12:02,000 --> 00:12:06,000
another behavior that's been mixed in

00:12:03,920 --> 00:12:07,839
this is called the foldable behavior

00:12:06,000 --> 00:12:09,519
because the maybe has these two sides

00:12:07,839 --> 00:12:10,000
it's either holding onto a value or it's

00:12:09,519 --> 00:12:13,200
holding on

00:12:10,000 --> 00:12:15,279
to a nothing and this foldable says

00:12:13,200 --> 00:12:16,399
let's select one of those two based upon

00:12:15,279 --> 00:12:18,000
what's inside it

00:12:16,399 --> 00:12:20,480
let's select one of those two and call

00:12:18,000 --> 00:12:22,320
one of these callbacks so if the nothing

00:12:20,480 --> 00:12:22,959
is what's inside of it like a null or an

00:12:22,320 --> 00:12:24,240
undefined

00:12:22,959 --> 00:12:26,959
then we're going to invoke the callback

00:12:24,240 --> 00:12:28,880
from line five but if a value like a

00:12:26,959 --> 00:12:30,880
string or a cost in this case

00:12:28,880 --> 00:12:32,480
is there then we're going to invoke the

00:12:30,880 --> 00:12:34,240
callback from line six

00:12:32,480 --> 00:12:36,240
that's all that foldable is saying is

00:12:34,240 --> 00:12:36,800
based on the identity of what's inside

00:12:36,240 --> 00:12:38,560
of you

00:12:36,800 --> 00:12:39,920
call one of these two callbacks and give

00:12:38,560 --> 00:12:42,880
us the result back

00:12:39,920 --> 00:12:44,079
so this is an example of using a maybe

00:12:42,880 --> 00:12:44,639
monad encode and we're going to come

00:12:44,079 --> 00:12:47,360
back to that

00:12:44,639 --> 00:12:48,959
in just a moment but i want to motivate

00:12:47,360 --> 00:12:50,959
the rest of our discussion together by

00:12:48,959 --> 00:12:52,399
asking this most important question

00:12:50,959 --> 00:12:54,480
i've already referred to it a couple of

00:12:52,399 --> 00:12:56,000
times why monads

00:12:54,480 --> 00:12:57,600
well the answer to that question is

00:12:56,000 --> 00:12:59,440
simply as i can state it is

00:12:57,600 --> 00:13:01,120
that they're a tool just like anything

00:12:59,440 --> 00:13:03,200
else like regular expressions or any

00:13:01,120 --> 00:13:05,360
other thing we use in code

00:13:03,200 --> 00:13:06,959
you find a problem you find the right

00:13:05,360 --> 00:13:09,120
tool you use the tool

00:13:06,959 --> 00:13:10,320
in the right prescribed way and you

00:13:09,120 --> 00:13:12,480
solve the problem

00:13:10,320 --> 00:13:14,160
now monads just happen to model and

00:13:12,480 --> 00:13:16,320
solve problems differently

00:13:14,160 --> 00:13:17,839
than you're used to but that actually

00:13:16,320 --> 00:13:19,200
opens up a whole world of other

00:13:17,839 --> 00:13:21,360
additional possibilities

00:13:19,200 --> 00:13:22,959
and that's what gets me so excited now

00:13:21,360 --> 00:13:23,920
by the way when i show you these sorts

00:13:22,959 --> 00:13:26,320
of examples

00:13:23,920 --> 00:13:28,079
i want you to be careful about jumping

00:13:26,320 --> 00:13:30,000
to the conclusion oh that's not more

00:13:28,079 --> 00:13:31,839
readable that's more confusing

00:13:30,000 --> 00:13:33,760
of course that's going to be true

00:13:31,839 --> 00:13:35,680
because anything that is

00:13:33,760 --> 00:13:37,760
less familiar to us is automatically

00:13:35,680 --> 00:13:39,040
going to be less readable to us

00:13:37,760 --> 00:13:41,360
so the first time that you see these

00:13:39,040 --> 00:13:43,839
sorts of examples they're less familiar

00:13:41,360 --> 00:13:44,399
and therefore less readable but if you

00:13:43,839 --> 00:13:45,760
push

00:13:44,399 --> 00:13:47,600
your boundaries a little bit if you

00:13:45,760 --> 00:13:50,480
practice with them and you try them

00:13:47,600 --> 00:13:51,720
then the unfamiliar becomes familiar the

00:13:50,480 --> 00:13:54,160
unreadable and under

00:13:51,720 --> 00:13:55,040
understandable becomes readable and

00:13:54,160 --> 00:13:56,720
understandable

00:13:55,040 --> 00:13:58,560
so this will be a journey this is not an

00:13:56,720 --> 00:14:00,880
aha i get it all of a sudden

00:13:58,560 --> 00:14:02,480
in just 20 minutes together in a talk

00:14:00,880 --> 00:14:03,600
but i hope that it wets your appetite

00:14:02,480 --> 00:14:05,199
that you want to dig in more and

00:14:03,600 --> 00:14:06,959
practice with these things

00:14:05,199 --> 00:14:08,639
so what are some things that we struggle

00:14:06,959 --> 00:14:10,639
with in our programs what are some

00:14:08,639 --> 00:14:12,880
questions that we might ask of our

00:14:10,639 --> 00:14:14,639
programs what problems might we face

00:14:12,880 --> 00:14:16,160
and i'll say that these are all problems

00:14:14,639 --> 00:14:16,959
that all of us have faced in all our

00:14:16,160 --> 00:14:19,120
programs

00:14:16,959 --> 00:14:21,279
and we've also already got lots of

00:14:19,120 --> 00:14:23,040
familiar solutions to these problems

00:14:21,279 --> 00:14:25,120
we're just looking at another way of

00:14:23,040 --> 00:14:26,240
solving them that opens up the door to

00:14:25,120 --> 00:14:28,320
potentially

00:14:26,240 --> 00:14:29,360
better usages of these patterns in our

00:14:28,320 --> 00:14:32,560
code

00:14:29,360 --> 00:14:34,240
so we may choose a value or a fallback

00:14:32,560 --> 00:14:36,320
value that's a very common task

00:14:34,240 --> 00:14:38,000
how do i do that we may want to

00:14:36,320 --> 00:14:39,760
gracefully handle an exception

00:14:38,000 --> 00:14:41,199
maybe one that was unexpected or one

00:14:39,760 --> 00:14:42,880
that was expected

00:14:41,199 --> 00:14:45,279
and we also might want to wrangle all of

00:14:42,880 --> 00:14:47,199
the crazy maybe asynchronous i o

00:14:45,279 --> 00:14:49,279
side effects that are happening in our

00:14:47,199 --> 00:14:49,760
programs these are all very common tasks

00:14:49,279 --> 00:14:52,000
but

00:14:49,760 --> 00:14:53,760
there's an infinite list of other ones

00:14:52,000 --> 00:14:55,279
these are only a few that i chose to

00:14:53,760 --> 00:14:57,680
call out in this talk

00:14:55,279 --> 00:14:58,399
so let's start with that first one how

00:14:57,680 --> 00:15:00,880
does

00:14:58,399 --> 00:15:03,519
the maybe allow us to choose a value or

00:15:00,880 --> 00:15:07,279
a fallback this is just one way of using

00:15:03,519 --> 00:15:08,399
our maybe monac so to describe it as i

00:15:07,279 --> 00:15:10,160
said a little bit ago

00:15:08,399 --> 00:15:12,320
we have this thing called a maybe which

00:15:10,160 --> 00:15:14,160
is really just under the covers

00:15:12,320 --> 00:15:16,560
holding something that is either an

00:15:14,160 --> 00:15:19,360
affirmative value like the number 42

00:15:16,560 --> 00:15:21,519
the number three a string or it's

00:15:19,360 --> 00:15:23,680
basically representing a nothing

00:15:21,519 --> 00:15:25,199
meaning like a null or an undefined in a

00:15:23,680 --> 00:15:27,519
language like javascript

00:15:25,199 --> 00:15:28,480
so we use this tool this helper that

00:15:27,519 --> 00:15:31,279
comes along with

00:15:28,480 --> 00:15:32,800
the maybe function and it's called from

00:15:31,279 --> 00:15:34,079
and under the covers the from is

00:15:32,800 --> 00:15:34,560
essentially doing an if statement it's

00:15:34,079 --> 00:15:36,720
saying

00:15:34,560 --> 00:15:38,240
if this thing is null or undefined then

00:15:36,720 --> 00:15:39,360
we're going to represent it as this may

00:15:38,240 --> 00:15:41,519
be nothing

00:15:39,360 --> 00:15:43,839
and if it's a value anything else like

00:15:41,519 --> 00:15:44,480
the number 42 we'll represent it as a

00:15:43,839 --> 00:15:45,519
just

00:15:44,480 --> 00:15:47,440
you remember i said that we don't

00:15:45,519 --> 00:15:48,399
typically see the just or the nothing

00:15:47,440 --> 00:15:50,079
standalone

00:15:48,399 --> 00:15:51,440
they're usually part of this parent

00:15:50,079 --> 00:15:53,120
monad called maybe

00:15:51,440 --> 00:15:54,959
it's just that in manila's case it was

00:15:53,120 --> 00:15:56,800
also convenient to have them

00:15:54,959 --> 00:15:58,959
be able to be used separately if you

00:15:56,800 --> 00:16:00,399
wanted to but we're using maybe here and

00:15:58,959 --> 00:16:02,399
we're saying maybe.from

00:16:00,399 --> 00:16:04,079
and that gives us a maybe just you can

00:16:02,399 --> 00:16:04,959
see that that's how it's inspected there

00:16:04,079 --> 00:16:06,800
in lines two

00:16:04,959 --> 00:16:08,880
and lines three we can inspect it and

00:16:06,800 --> 00:16:11,279
see that it's holding a maybe just

00:16:08,880 --> 00:16:12,720
wrapped around that value 42. the same

00:16:11,279 --> 00:16:14,560
thing when i pass in a

00:16:12,720 --> 00:16:16,399
dot from null like on line 6 we're

00:16:14,560 --> 00:16:18,240
getting a maybe nothing out of that

00:16:16,399 --> 00:16:20,320
now i want to call out that on line 8

00:16:18,240 --> 00:16:22,480
i'm not using the maybe from that's

00:16:20,320 --> 00:16:24,320
the maybe unit constructor and here

00:16:22,480 --> 00:16:26,399
there is no selection logic it's not

00:16:24,320 --> 00:16:26,800
saying null or not null or anything like

00:16:26,399 --> 00:16:28,240
that

00:16:26,800 --> 00:16:30,959
it's just simply taking whatever you

00:16:28,240 --> 00:16:32,800
pass and wrapping it in another monad

00:16:30,959 --> 00:16:34,160
so in this case we would take the empty

00:16:32,800 --> 00:16:36,079
the maybe nothing

00:16:34,160 --> 00:16:38,320
and wrap it in a maybe just and that's

00:16:36,079 --> 00:16:39,920
what you see illustrated on line eight

00:16:38,320 --> 00:16:41,519
maybe is kind of this it's referred to

00:16:39,920 --> 00:16:44,800
as like a sum type because it

00:16:41,519 --> 00:16:46,320
can either be a just or a nothing

00:16:44,800 --> 00:16:48,160
depending on the conditions of how it

00:16:46,320 --> 00:16:50,560
was constructed and that's what the from

00:16:48,160 --> 00:16:52,639
helper is letting us do

00:16:50,560 --> 00:16:54,000
so let's take a more real world-ish kind

00:16:52,639 --> 00:16:55,360
of example this is

00:16:54,000 --> 00:16:57,279
from some actual code that i've been

00:16:55,360 --> 00:16:58,480
working on it's like a media app it

00:16:57,279 --> 00:16:59,360
doesn't really matter what it does but

00:16:58,480 --> 00:17:01,120
here you can see

00:16:59,360 --> 00:17:02,399
that i'm wanting to select out a value

00:17:01,120 --> 00:17:04,959
and do some matching and

00:17:02,399 --> 00:17:06,480
aha i'm using a regular expression see

00:17:04,959 --> 00:17:08,720
because i have this string it's coming

00:17:06,480 --> 00:17:11,199
from a drop down of various mime types

00:17:08,720 --> 00:17:13,039
and i want to match like video audio or

00:17:11,199 --> 00:17:14,720
image from those mime types and if

00:17:13,039 --> 00:17:16,640
that's there i want to match that out

00:17:14,720 --> 00:17:18,000
and if not i want to fall back like i'm

00:17:16,640 --> 00:17:21,120
doing on line three i want to fall

00:17:18,000 --> 00:17:22,559
back to just this quote web value so i'm

00:17:21,120 --> 00:17:24,400
selecting out a value from a regular

00:17:22,559 --> 00:17:24,880
expression and if there's a failed match

00:17:24,400 --> 00:17:26,959
there

00:17:24,880 --> 00:17:28,559
just select the default value now you

00:17:26,959 --> 00:17:29,919
probably recognize code like this you

00:17:28,559 --> 00:17:31,200
may have done it with the ternaries you

00:17:29,919 --> 00:17:32,080
may have done it with if statements but

00:17:31,200 --> 00:17:34,400
it's a very common

00:17:32,080 --> 00:17:35,520
thing to try an operation and substitute

00:17:34,400 --> 00:17:37,679
a default value

00:17:35,520 --> 00:17:38,960
if we don't succeed so that's exactly

00:17:37,679 --> 00:17:40,960
what's happening here

00:17:38,960 --> 00:17:43,200
and this solution quite frankly is

00:17:40,960 --> 00:17:45,280
familiar to all of us and works

00:17:43,200 --> 00:17:46,960
but we would classify this solution as a

00:17:45,280 --> 00:17:48,720
bit more imperative

00:17:46,960 --> 00:17:51,200
and what we're looking for in functional

00:17:48,720 --> 00:17:52,320
programming is to look for ways to solve

00:17:51,200 --> 00:17:54,320
those problems

00:17:52,320 --> 00:17:56,320
in ways that compose better with other

00:17:54,320 --> 00:17:57,760
solutions this is kind of like a metal

00:17:56,320 --> 00:17:58,640
level here because it's not just about

00:17:57,760 --> 00:18:00,480
this problem

00:17:58,640 --> 00:18:02,240
but about other problems i'll solve

00:18:00,480 --> 00:18:03,919
alongside this in the code

00:18:02,240 --> 00:18:05,520
and if i do the solutions in the right

00:18:03,919 --> 00:18:07,280
way they will pair together

00:18:05,520 --> 00:18:08,880
much more effectively than imperative

00:18:07,280 --> 00:18:10,880
code typically does

00:18:08,880 --> 00:18:12,320
so that not equals null check there we

00:18:10,880 --> 00:18:14,559
can actually model

00:18:12,320 --> 00:18:16,080
using the maybe dot from you see that

00:18:14,559 --> 00:18:17,200
they're on line three i'm using this

00:18:16,080 --> 00:18:20,000
maybe.from

00:18:17,200 --> 00:18:20,320
to model that selection logic of did i

00:18:20,000 --> 00:18:23,440
get

00:18:20,320 --> 00:18:24,720
a value out that was an actual match

00:18:23,440 --> 00:18:26,960
from the regular expression

00:18:24,720 --> 00:18:28,960
or was it null and i dropped that into

00:18:26,960 --> 00:18:29,360
this thing called a maybe and then again

00:18:28,960 --> 00:18:32,240
here

00:18:29,360 --> 00:18:32,880
using the foldable nature i select out

00:18:32,240 --> 00:18:34,640
either

00:18:32,880 --> 00:18:37,120
a function that will return me back my

00:18:34,640 --> 00:18:37,520
default value or this identity function

00:18:37,120 --> 00:18:38,960
which

00:18:37,520 --> 00:18:40,960
the identity function just returns

00:18:38,960 --> 00:18:41,440
whatever's in it whatever is passed to

00:18:40,960 --> 00:18:43,679
it so

00:18:41,440 --> 00:18:45,280
we just either select out a default

00:18:43,679 --> 00:18:46,240
value or select out the value that we've

00:18:45,280 --> 00:18:48,799
now selected

00:18:46,240 --> 00:18:50,880
so we're allowing the maybe monad to do

00:18:48,799 --> 00:18:51,600
that selection logic through the from

00:18:50,880 --> 00:18:53,919
utility

00:18:51,600 --> 00:18:54,640
for us and to hold on to that nature of

00:18:53,919 --> 00:18:57,120
is it a just

00:18:54,640 --> 00:18:59,360
value or is it a nothing in isolation

00:18:57,120 --> 00:19:01,600
that doesn't look particularly exciting

00:18:59,360 --> 00:19:02,960
maybe a slightly more complex example

00:19:01,600 --> 00:19:04,000
might help to motivate it a little bit

00:19:02,960 --> 00:19:06,080
more

00:19:04,000 --> 00:19:07,600
here i'm doing some nested ternary logic

00:19:06,080 --> 00:19:08,799
which could be exactly like some if

00:19:07,600 --> 00:19:11,200
statements that you've written

00:19:08,799 --> 00:19:13,120
i'm just saving space on the slides but

00:19:11,200 --> 00:19:14,400
i'm not only doing that not equals null

00:19:13,120 --> 00:19:17,440
check like on line two

00:19:14,400 --> 00:19:18,000
but i'm also doing a an operation on a

00:19:17,440 --> 00:19:21,120
value

00:19:18,000 --> 00:19:22,080
if we found a value here i'm shortening

00:19:21,120 --> 00:19:24,240
a string i'm

00:19:22,080 --> 00:19:25,520
putting a dot ellipsis on the end of a

00:19:24,240 --> 00:19:27,520
string if it's too long

00:19:25,520 --> 00:19:29,840
so it's kind of an operation where i'm

00:19:27,520 --> 00:19:30,240
mapping it to some other value if i need

00:19:29,840 --> 00:19:31,919
to

00:19:30,240 --> 00:19:33,440
just conditionally of course but mapping

00:19:31,919 --> 00:19:35,200
it if i need to so

00:19:33,440 --> 00:19:36,720
we could do this very imperatively the

00:19:35,200 --> 00:19:38,720
way that we're doing we can either

00:19:36,720 --> 00:19:40,640
select the value or a default and if we

00:19:38,720 --> 00:19:42,000
select the value then we can also apply

00:19:40,640 --> 00:19:43,679
some additional logic

00:19:42,000 --> 00:19:45,280
but this is where we get to start

00:19:43,679 --> 00:19:46,640
bringing in more of these functional

00:19:45,280 --> 00:19:49,200
behaviors more of these

00:19:46,640 --> 00:19:50,799
magnetics and friends behaviors so here

00:19:49,200 --> 00:19:51,200
what we're going to do is again use the

00:19:50,799 --> 00:19:52,880
maybe

00:19:51,200 --> 00:19:55,039
we do the maybe from there that you see

00:19:52,880 --> 00:19:57,520
on line two and what we're going to do

00:19:55,039 --> 00:19:59,679
is call the dot map on the result of

00:19:57,520 --> 00:20:01,520
that and the dot map call by the way

00:19:59,679 --> 00:20:03,039
is another nature that we get kind of

00:20:01,520 --> 00:20:05,919
directly from the core

00:20:03,039 --> 00:20:07,120
of of monads because that comes to us

00:20:05,919 --> 00:20:09,600
from the functor

00:20:07,120 --> 00:20:10,400
nature of monads they allow us to map

00:20:09,600 --> 00:20:11,840
over things

00:20:10,400 --> 00:20:13,440
and if that sounds a little bit scary

00:20:11,840 --> 00:20:13,840
you've actually probably seen this a lot

00:20:13,440 --> 00:20:15,039
when

00:20:13,840 --> 00:20:17,120
you've dealt with arrays in your

00:20:15,039 --> 00:20:18,000
programs and you've done a dot map on an

00:20:17,120 --> 00:20:19,760
array call and it

00:20:18,000 --> 00:20:21,919
executes a function against all the

00:20:19,760 --> 00:20:22,799
values in that array and gives you a new

00:20:21,919 --> 00:20:24,960
array back

00:20:22,799 --> 00:20:27,120
that is exactly the same concept here

00:20:24,960 --> 00:20:28,320
there's only one value to be mapped over

00:20:27,120 --> 00:20:30,880
but what we're saying is

00:20:28,320 --> 00:20:32,000
if i have a maybe just i want to invoke

00:20:30,880 --> 00:20:33,840
this map method

00:20:32,000 --> 00:20:35,840
to do something on top of it and that's

00:20:33,840 --> 00:20:37,440
the selection logic to decide

00:20:35,840 --> 00:20:39,600
if i need to truncate the string with an

00:20:37,440 --> 00:20:39,919
ellipsis or not now the cool part about

00:20:39,600 --> 00:20:41,840
this

00:20:39,919 --> 00:20:43,440
map call that's happening on line three

00:20:41,840 --> 00:20:46,480
is that if under the covers that

00:20:43,440 --> 00:20:48,559
maybe.from had produced a nothing value

00:20:46,480 --> 00:20:50,400
then the map call that comes right after

00:20:48,559 --> 00:20:52,080
it is just a do nothing

00:20:50,400 --> 00:20:54,559
it doesn't do anything when there's a

00:20:52,080 --> 00:20:56,080
maybe nothing involved it's only invoked

00:20:54,559 --> 00:20:58,080
to do something useful if there's a

00:20:56,080 --> 00:20:58,480
maybe just so we would skip over line

00:20:58,080 --> 00:21:01,200
three

00:20:58,480 --> 00:21:02,960
in the null case in the nothing case and

00:21:01,200 --> 00:21:04,880
then just go directly to line six and

00:21:02,960 --> 00:21:06,480
again you see the foldable nature there

00:21:04,880 --> 00:21:09,039
that's how we select out either our

00:21:06,480 --> 00:21:09,600
fallback value or the value that has now

00:21:09,039 --> 00:21:12,799
been

00:21:09,600 --> 00:21:15,200
uh terminated with the dot dot ellipsis

00:21:12,799 --> 00:21:17,360
on the end of it

00:21:15,200 --> 00:21:19,120
so here's another example using the

00:21:17,360 --> 00:21:20,880
maybe in a slightly different way

00:21:19,120 --> 00:21:22,480
this is selecting properties and this is

00:21:20,880 --> 00:21:23,600
maybe one of the more common examples

00:21:22,480 --> 00:21:26,080
that you see with maybe

00:21:23,600 --> 00:21:28,440
it's selecting properties on a nested

00:21:26,080 --> 00:21:29,600
object reference like we have

00:21:28,440 --> 00:21:32,000
entry.media.source.url

00:21:29,600 --> 00:21:33,200
and if at any point in that chain a

00:21:32,000 --> 00:21:34,880
property is missing

00:21:33,200 --> 00:21:36,799
if we're just using the dot operator

00:21:34,880 --> 00:21:39,600
then it might fail which is why

00:21:36,799 --> 00:21:41,440
recently some of you know about the

00:21:39,600 --> 00:21:43,280
optional chaining operator that question

00:21:41,440 --> 00:21:44,880
mark dot that you see there on line nine

00:21:43,280 --> 00:21:46,400
this optional chaining operator just

00:21:44,880 --> 00:21:48,320
sort of short circuits out

00:21:46,400 --> 00:21:50,320
and doesn't do anything else if it runs

00:21:48,320 --> 00:21:51,840
across a missing property

00:21:50,320 --> 00:21:53,200
so a lot of people are really excited

00:21:51,840 --> 00:21:54,880
about this feature i think it's a great

00:21:53,200 --> 00:21:56,400
feature to be added to the language

00:21:54,880 --> 00:21:58,080
but i wanted to show you how we can do

00:21:56,400 --> 00:22:00,480
this same kind of thing this

00:21:58,080 --> 00:22:01,840
optional chaining thing using something

00:22:00,480 --> 00:22:02,720
like maybe this is a very common

00:22:01,840 --> 00:22:04,880
illustration

00:22:02,720 --> 00:22:06,640
of that use case same object here we

00:22:04,880 --> 00:22:07,360
have the entry the media the source and

00:22:06,640 --> 00:22:08,799
the url

00:22:07,360 --> 00:22:11,840
but you'll notice that i'm dropping it

00:22:08,799 --> 00:22:12,240
into maybe from and i'm using this uh

00:22:11,840 --> 00:22:14,640
this

00:22:12,240 --> 00:22:16,159
chain method again because maybe it's a

00:22:14,640 --> 00:22:16,960
monad we're going to be able to chain

00:22:16,159 --> 00:22:19,200
from one

00:22:16,960 --> 00:22:21,120
monad to another monad instance and that

00:22:19,200 --> 00:22:23,120
prop function if you'll notice there

00:22:21,120 --> 00:22:24,320
it's giving us back another maybe every

00:22:23,120 --> 00:22:26,080
time so at

00:22:24,320 --> 00:22:27,919
each step we're checking to see if the

00:22:26,080 --> 00:22:29,679
thing that we pulled out was null or

00:22:27,919 --> 00:22:31,919
undefined if it was empty in some way

00:22:29,679 --> 00:22:33,600
and if so we switch to a maybe nothing

00:22:31,919 --> 00:22:35,440
which effectively short circuits the

00:22:33,600 --> 00:22:37,120
rest of those dot chain calls

00:22:35,440 --> 00:22:39,120
you probably recognize something like

00:22:37,120 --> 00:22:39,760
that short circuiting from promises for

00:22:39,120 --> 00:22:41,679
example

00:22:39,760 --> 00:22:43,520
if you have a bunch of vends on it and

00:22:41,679 --> 00:22:44,000
you get an exception or rejection and a

00:22:43,520 --> 00:22:45,679
promise

00:22:44,000 --> 00:22:47,039
it just skips over all of those and then

00:22:45,679 --> 00:22:47,840
goes to the end wherever your catch

00:22:47,039 --> 00:22:49,600
handler is

00:22:47,840 --> 00:22:51,360
it's the same kind of thing here so this

00:22:49,600 --> 00:22:53,360
safe property access

00:22:51,360 --> 00:22:55,120
just kind of short circuits out to a

00:22:53,360 --> 00:22:56,640
maybe nothing if any one of those

00:22:55,120 --> 00:22:58,640
property accesses fails

00:22:56,640 --> 00:23:01,440
that's why on lines 10 through 15 it

00:22:58,640 --> 00:23:03,760
succeeds but on line 17-21

00:23:01,440 --> 00:23:04,960
we've exited out early if you will and

00:23:03,760 --> 00:23:06,400
all the rest of the chain calls are

00:23:04,960 --> 00:23:09,200
effectively ignored

00:23:06,400 --> 00:23:10,799
so yet another example of being able to

00:23:09,200 --> 00:23:12,960
put this selection logic

00:23:10,799 --> 00:23:14,960
into the representation of our value

00:23:12,960 --> 00:23:17,840
using a utility like maybe from

00:23:14,960 --> 00:23:18,799
it puts that selection logic in so that

00:23:17,840 --> 00:23:20,640
we're sure

00:23:18,799 --> 00:23:21,840
that this value is going to behave in a

00:23:20,640 --> 00:23:23,760
very

00:23:21,840 --> 00:23:26,320
predictable way now i want to call out

00:23:23,760 --> 00:23:29,120
this undefined versus this maybe nothing

00:23:26,320 --> 00:23:30,159
the line 13 versus line 22 here because

00:23:29,120 --> 00:23:31,120
what i'm going to say is that even

00:23:30,159 --> 00:23:34,559
though these are both

00:23:31,120 --> 00:23:37,039
empty values in a generic sense

00:23:34,559 --> 00:23:39,440
actually these are not the same because

00:23:37,039 --> 00:23:41,440
they maybe nothing is far more powerful

00:23:39,440 --> 00:23:43,200
than just an undefined value and maybe

00:23:41,440 --> 00:23:44,480
nothing even though it doesn't seem like

00:23:43,200 --> 00:23:46,240
it's doing much

00:23:44,480 --> 00:23:48,720
it's a magnetic value and it gives us

00:23:46,240 --> 00:23:50,080
lots of predictability in terms of how

00:23:48,720 --> 00:23:50,720
it will interact in the rest of our

00:23:50,080 --> 00:23:52,320
program

00:23:50,720 --> 00:23:54,159
where the undefined you have to special

00:23:52,320 --> 00:23:56,159
case with if statements all the time

00:23:54,159 --> 00:23:57,840
and so that's why one of those reasons

00:23:56,159 --> 00:23:59,039
why moving towards this monadic

00:23:57,840 --> 00:24:01,919
representation

00:23:59,039 --> 00:24:02,640
can open up the possibility for us to do

00:24:01,919 --> 00:24:06,480
more things

00:24:02,640 --> 00:24:08,960
and do things better in our programs

00:24:06,480 --> 00:24:09,600
so the second question that we wanted to

00:24:08,960 --> 00:24:11,679
jump

00:24:09,600 --> 00:24:12,960
to is how do i gracefully handle

00:24:11,679 --> 00:24:14,559
exceptions again

00:24:12,960 --> 00:24:16,240
exceptions that either i know are going

00:24:14,559 --> 00:24:17,200
to happen or exceptions that were

00:24:16,240 --> 00:24:18,720
unexpected

00:24:17,200 --> 00:24:20,000
but i still want to gracefully handle

00:24:18,720 --> 00:24:21,360
them we're going to use what's called

00:24:20,000 --> 00:24:23,120
the either monum for that

00:24:21,360 --> 00:24:25,360
and by the way the either monad is very

00:24:23,120 --> 00:24:28,080
similar to the maybe monad

00:24:25,360 --> 00:24:29,600
they're both these sort of sum types and

00:24:28,080 --> 00:24:30,960
in the examples i'm giving here you

00:24:29,600 --> 00:24:32,000
could sort of interchange them you could

00:24:30,960 --> 00:24:34,159
have used the either

00:24:32,000 --> 00:24:35,679
for what i just described maybe doing

00:24:34,159 --> 00:24:37,120
and you could technically do what we're

00:24:35,679 --> 00:24:38,640
doing here with a maybe

00:24:37,120 --> 00:24:40,400
but it's a little bit more convenient

00:24:38,640 --> 00:24:41,600
this way i think so that's how i chose

00:24:40,400 --> 00:24:44,480
to illustrate it

00:24:41,600 --> 00:24:46,159
the either is a pairing a monad that it

00:24:44,480 --> 00:24:49,039
will select either an

00:24:46,159 --> 00:24:50,880
either right or on either left now on

00:24:49,039 --> 00:24:51,679
either left is usually reserved to

00:24:50,880 --> 00:24:53,840
represent like

00:24:51,679 --> 00:24:55,200
the exception or the error message

00:24:53,840 --> 00:24:56,880
whereas the either right

00:24:55,200 --> 00:24:58,880
is designed to represent like an

00:24:56,880 --> 00:25:00,720
affirmative value that still has

00:24:58,880 --> 00:25:02,880
uh operations and behavior that we want

00:25:00,720 --> 00:25:05,360
to do so we could wrap up the

00:25:02,880 --> 00:25:05,919
result of any operation in an either

00:25:05,360 --> 00:25:08,240
left or

00:25:05,919 --> 00:25:09,679
either right and then it that because

00:25:08,240 --> 00:25:11,120
that is monadic then yet

00:25:09,679 --> 00:25:12,720
exactly the same kind of benefits we

00:25:11,120 --> 00:25:14,559
just illustrated with the maybe

00:25:12,720 --> 00:25:15,919
that it will have a predictable behavior

00:25:14,559 --> 00:25:17,520
it'll have short-circuiting

00:25:15,919 --> 00:25:19,279
all of those sorts of things so you

00:25:17,520 --> 00:25:19,679
notice here i can construct either dot

00:25:19,279 --> 00:25:21,760
left

00:25:19,679 --> 00:25:24,159
on line one either dot right on line

00:25:21,760 --> 00:25:25,279
five and by the way the either and the

00:25:24,159 --> 00:25:27,279
maybe since they

00:25:25,279 --> 00:25:30,000
in this implementation they're both

00:25:27,279 --> 00:25:31,679
implementing the foldable interface

00:25:30,000 --> 00:25:33,520
that so-called semi-group here because

00:25:31,679 --> 00:25:34,559
of that we can actually take a maybe

00:25:33,520 --> 00:25:36,720
that's a foldable

00:25:34,559 --> 00:25:39,200
and consume it into an either using this

00:25:36,720 --> 00:25:42,320
from foldable interface

00:25:39,200 --> 00:25:44,000
so you would typically do a an exception

00:25:42,320 --> 00:25:45,440
handling using tri-catch it's the most

00:25:44,000 --> 00:25:45,919
common way that people do this in their

00:25:45,440 --> 00:25:47,360
code

00:25:45,919 --> 00:25:48,960
now the try catch there's nothing wrong

00:25:47,360 --> 00:25:51,440
with it but it does

00:25:48,960 --> 00:25:52,400
get very hairy to compose lots of nested

00:25:51,440 --> 00:25:54,400
tri catches

00:25:52,400 --> 00:25:56,240
as you go throughout all of your

00:25:54,400 --> 00:25:57,600
programs and you have lots of layers

00:25:56,240 --> 00:25:59,279
deep of the call stack

00:25:57,600 --> 00:26:00,799
and things so what we would like to do

00:25:59,279 --> 00:26:02,559
is actually have a slightly better way

00:26:00,799 --> 00:26:03,360
of wrangling these exceptions

00:26:02,559 --> 00:26:05,360
and that's what we're going to

00:26:03,360 --> 00:26:06,159
illustrate with the either now i'm going

00:26:05,360 --> 00:26:07,679
to use this

00:26:06,159 --> 00:26:09,200
helper that i'm going to define called

00:26:07,679 --> 00:26:11,120
safe here and you'll notice that

00:26:09,200 --> 00:26:13,200
basically what safe does is it tries to

00:26:11,120 --> 00:26:15,679
call a function and if that succeeds

00:26:13,200 --> 00:26:17,360
it puts the result in either right and

00:26:15,679 --> 00:26:19,679
if it fails it puts that

00:26:17,360 --> 00:26:21,120
result into an either left so it's very

00:26:19,679 --> 00:26:23,039
similar to the maybe from it's just

00:26:21,120 --> 00:26:24,000
doing that selection logic for us which

00:26:23,039 --> 00:26:27,279
kind of either

00:26:24,000 --> 00:26:29,200
do i need and if we use that safe as a

00:26:27,279 --> 00:26:29,919
wrapper around for example the json

00:26:29,200 --> 00:26:32,720
parse

00:26:29,919 --> 00:26:34,799
line 8 we can call parse json we can

00:26:32,720 --> 00:26:35,279
parse some json and if that fails in any

00:26:34,799 --> 00:26:36,799
way

00:26:35,279 --> 00:26:38,240
we know we're going to get back out and

00:26:36,799 --> 00:26:38,880
either left which is going to short

00:26:38,240 --> 00:26:40,559
circuit

00:26:38,880 --> 00:26:42,159
so the next dot chain call it will just

00:26:40,559 --> 00:26:44,159
be skipped line nine

00:26:42,159 --> 00:26:45,919
but if it succeeds if we're able to

00:26:44,159 --> 00:26:48,080
successfully parse the json

00:26:45,919 --> 00:26:49,840
then we'll get back out and either right

00:26:48,080 --> 00:26:50,400
and then the chain call there on line

00:26:49,840 --> 00:26:52,480
nine

00:26:50,400 --> 00:26:53,840
will invoke the next step in this

00:26:52,480 --> 00:26:55,760
process which in this case

00:26:53,840 --> 00:26:57,039
is our safe wrapper around the save to

00:26:55,760 --> 00:26:59,520
db function

00:26:57,039 --> 00:27:01,360
so we would only call that save to db if

00:26:59,520 --> 00:27:03,279
the parsing of the json worked

00:27:01,360 --> 00:27:05,039
otherwise we would skip over it and

00:27:03,279 --> 00:27:06,960
again you see the foldable here is kind

00:27:05,039 --> 00:27:08,720
of a convenient way of illustrating

00:27:06,960 --> 00:27:10,640
how at the end of all these magnetic

00:27:08,720 --> 00:27:12,159
operations how do i reduce that to

00:27:10,640 --> 00:27:13,760
something that i can actually look at

00:27:12,159 --> 00:27:16,240
like alert an error message

00:27:13,760 --> 00:27:17,120
or grab that value and put it in the dom

00:27:16,240 --> 00:27:18,880
or something like that

00:27:17,120 --> 00:27:20,480
so fold is just one of the various

00:27:18,880 --> 00:27:22,480
convenient ways that we can

00:27:20,480 --> 00:27:24,240
at the end kind of get that value out we

00:27:22,480 --> 00:27:26,559
select either the either

00:27:24,240 --> 00:27:27,679
left case that calls our error function

00:27:26,559 --> 00:27:29,200
with our alert error

00:27:27,679 --> 00:27:32,080
or the either right would have invoked

00:27:29,200 --> 00:27:34,159
in this case the identity function

00:27:32,080 --> 00:27:35,440
so how are we going to manage side

00:27:34,159 --> 00:27:36,880
effects that's our last

00:27:35,440 --> 00:27:38,480
question that we want to ask and this is

00:27:36,880 --> 00:27:40,399
the most complex of all of them

00:27:38,480 --> 00:27:42,399
i'm using what's called the i o monad

00:27:40,399 --> 00:27:44,159
here now the i o monad is a special kind

00:27:42,399 --> 00:27:46,320
of monad that wraps up not just

00:27:44,159 --> 00:27:47,760
number values like the number 42 but

00:27:46,320 --> 00:27:49,600
actually functions

00:27:47,760 --> 00:27:50,799
functions that can produce values like

00:27:49,600 --> 00:27:52,960
the number 42. so

00:27:50,799 --> 00:27:54,799
line one you see an i o wrapping around

00:27:52,960 --> 00:27:57,120
in this case an arrow function

00:27:54,799 --> 00:27:59,200
that returns the number 42. it can wrap

00:27:57,120 --> 00:28:00,720
around any pure function so

00:27:59,200 --> 00:28:02,720
it doesn't have to be ones that return

00:28:00,720 --> 00:28:04,480
constant values like you see here

00:28:02,720 --> 00:28:06,000
but what's special about it is that it

00:28:04,480 --> 00:28:06,640
turns those functions into what we call

00:28:06,000 --> 00:28:08,480
lazy

00:28:06,640 --> 00:28:10,720
meaning that we can compose all of these

00:28:08,480 --> 00:28:11,760
functions together for example we see a

00:28:10,720 --> 00:28:14,159
hello function

00:28:11,760 --> 00:28:16,080
a hello i o monad wrapped around a

00:28:14,159 --> 00:28:17,760
console.log statement for hello

00:28:16,080 --> 00:28:19,919
we see this i o wrapping around the

00:28:17,760 --> 00:28:20,559
console log of world to make that world

00:28:19,919 --> 00:28:23,200
i o

00:28:20,559 --> 00:28:24,159
and then we compose those two on lines

00:28:23,200 --> 00:28:25,679
nine and ten

00:28:24,159 --> 00:28:28,320
but you'll notice that in all of these

00:28:25,679 --> 00:28:29,919
cases like lines two three and ten

00:28:28,320 --> 00:28:32,320
none of that is getting invoked until we

00:28:29,919 --> 00:28:33,919
call dot run so we can compose these

00:28:32,320 --> 00:28:36,080
things we can compose all of these

00:28:33,919 --> 00:28:38,720
complex side effects in our application

00:28:36,080 --> 00:28:39,279
but none of them actually are affected

00:28:38,720 --> 00:28:41,520
none of them

00:28:39,279 --> 00:28:42,640
actually are executed to change the

00:28:41,520 --> 00:28:44,960
state of our app

00:28:42,640 --> 00:28:46,480
until we call the dot run that makes it

00:28:44,960 --> 00:28:47,760
a lot easier to pull these things from

00:28:46,480 --> 00:28:49,279
all different places

00:28:47,760 --> 00:28:51,200
and then have a nice predictable

00:28:49,279 --> 00:28:52,480
ordering so the io monad the more

00:28:51,200 --> 00:28:54,240
complex our apps get

00:28:52,480 --> 00:28:55,520
the more it starts to shine in terms of

00:28:54,240 --> 00:28:57,440
helping us wrangle

00:28:55,520 --> 00:28:58,720
all of these side effects by the way

00:28:57,440 --> 00:28:59,279
lots of side effects that we could

00:28:58,720 --> 00:29:01,120
consider

00:28:59,279 --> 00:29:03,279
things like console log are very simple

00:29:01,120 --> 00:29:04,320
but like saving to the database writing

00:29:03,279 --> 00:29:06,159
to the dom

00:29:04,320 --> 00:29:07,520
even asynchrony all of these are things

00:29:06,159 --> 00:29:10,720
that are side effects that

00:29:07,520 --> 00:29:13,279
something like the iomona can help tame

00:29:10,720 --> 00:29:14,399
so let's take a look at an example uh

00:29:13,279 --> 00:29:16,159
again from that code

00:29:14,399 --> 00:29:18,720
base that i was talking about here i've

00:29:16,159 --> 00:29:20,480
got some an array called entries

00:29:18,720 --> 00:29:22,080
lines one through four i've got an array

00:29:20,480 --> 00:29:23,679
called entries and i have these side

00:29:22,080 --> 00:29:25,520
effecting functions lines

00:29:23,679 --> 00:29:27,679
six and ten the first and the second

00:29:25,520 --> 00:29:28,399
functions are pulling values out one at

00:29:27,679 --> 00:29:30,080
a time

00:29:28,399 --> 00:29:31,520
and that's changing the state of that

00:29:30,080 --> 00:29:32,799
array so these are side effects if you

00:29:31,520 --> 00:29:33,760
will they're changing the state of this

00:29:32,799 --> 00:29:35,039
global variable

00:29:33,760 --> 00:29:37,120
and then i'm doing a console log

00:29:35,039 --> 00:29:37,760
statement on line 17 again another side

00:29:37,120 --> 00:29:39,600
effect

00:29:37,760 --> 00:29:41,760
now all of that side effecting is

00:29:39,600 --> 00:29:43,600
composed in this one function

00:29:41,760 --> 00:29:45,279
playlist but it's done we did so very

00:29:43,600 --> 00:29:47,200
manually and imperatively

00:29:45,279 --> 00:29:48,399
and then we invoke the playlist function

00:29:47,200 --> 00:29:50,640
on line 20.

00:29:48,399 --> 00:29:52,480
so that works but the more complex our

00:29:50,640 --> 00:29:53,440
apps get being able to pull these things

00:29:52,480 --> 00:29:54,880
together into

00:29:53,440 --> 00:29:56,159
bigger and bigger functions and make

00:29:54,880 --> 00:29:56,640
sure that things happen in the right

00:29:56,159 --> 00:29:58,399
order

00:29:56,640 --> 00:30:00,240
especially when asynchrony comes into

00:29:58,399 --> 00:30:01,919
play that gets really difficult

00:30:00,240 --> 00:30:03,600
so here's where the i o monad could

00:30:01,919 --> 00:30:04,799
solve this in a different way

00:30:03,600 --> 00:30:06,559
we're going to have that same global

00:30:04,799 --> 00:30:08,240
array but we're going to wrap every

00:30:06,559 --> 00:30:09,440
function that's doing these side effects

00:30:08,240 --> 00:30:11,520
in an i o monad

00:30:09,440 --> 00:30:13,039
so we have this i o that's right called

00:30:11,520 --> 00:30:14,640
first that's wrapped around the

00:30:13,039 --> 00:30:15,840
modification to pull off the first

00:30:14,640 --> 00:30:17,679
element from the list and then we have

00:30:15,840 --> 00:30:19,360
another one called second to pull off

00:30:17,679 --> 00:30:21,360
another element from the list and then

00:30:19,360 --> 00:30:23,360
you'll notice lines 11 through

00:30:21,360 --> 00:30:25,919
15 14 that we're basically doing the

00:30:23,360 --> 00:30:27,679
composition of all those ios together

00:30:25,919 --> 00:30:30,240
and we're calling this special function

00:30:27,679 --> 00:30:31,840
called concat now that's delegating to

00:30:30,240 --> 00:30:34,240
this other thing

00:30:31,840 --> 00:30:35,200
this compatible behavior i think i said

00:30:34,240 --> 00:30:36,720
a moment ago that

00:30:35,200 --> 00:30:38,480
fold was the summit group it's actually

00:30:36,720 --> 00:30:39,200
concat that's a semi group so sorry for

00:30:38,480 --> 00:30:42,399
that

00:30:39,200 --> 00:30:45,360
concat here is the semi group and that

00:30:42,399 --> 00:30:46,640
is what defers or delegates down to the

00:30:45,360 --> 00:30:48,960
underlying values

00:30:46,640 --> 00:30:50,640
if there's some concatenation to occur

00:30:48,960 --> 00:30:52,799
so concatenation might be something like

00:30:50,640 --> 00:30:55,039
two strings being concatenated together

00:30:52,799 --> 00:30:57,120
or it might be uh two numbers being

00:30:55,039 --> 00:30:59,039
added together any sort of intuitive

00:30:57,120 --> 00:31:01,039
lower level value being concatenated

00:30:59,039 --> 00:31:02,480
together in this case since our ios are

00:31:01,039 --> 00:31:04,159
producing strings we're able to

00:31:02,480 --> 00:31:06,080
concatenate those things together

00:31:04,159 --> 00:31:08,480
just like we were doing before and then

00:31:06,080 --> 00:31:10,640
the final line 14 that chain

00:31:08,480 --> 00:31:11,679
takes the result of those concatenated

00:31:10,640 --> 00:31:12,799
the i o that's holding those

00:31:11,679 --> 00:31:15,600
concatenated values

00:31:12,799 --> 00:31:17,519
and actually logs out that value so

00:31:15,600 --> 00:31:18,480
again what we're doing is able to move

00:31:17,519 --> 00:31:21,360
from a more

00:31:18,480 --> 00:31:23,120
imperative spaghetti-ish kind of mixture

00:31:21,360 --> 00:31:26,159
of all this code into one nice

00:31:23,120 --> 00:31:28,960
clean listing uh very um

00:31:26,159 --> 00:31:29,279
you know very straightforward listing of

00:31:28,960 --> 00:31:30,799
what

00:31:29,279 --> 00:31:32,320
each of the operations are that we want

00:31:30,799 --> 00:31:34,640
to perform

00:31:32,320 --> 00:31:36,480
now i want to talk about some specific

00:31:34,640 --> 00:31:37,519
things with moneo's io as i begin to

00:31:36,480 --> 00:31:39,760
wrap up this talk

00:31:37,519 --> 00:31:41,200
we have what's called this do syntax

00:31:39,760 --> 00:31:42,559
that comes to us from haskell

00:31:41,200 --> 00:31:44,480
and you'll notice that it's represented

00:31:42,559 --> 00:31:45,039
here in javascript we appropriate that

00:31:44,480 --> 00:31:46,640
idea

00:31:45,039 --> 00:31:48,799
we do something here in javascript

00:31:46,640 --> 00:31:49,519
called this generator with the yield

00:31:48,799 --> 00:31:51,279
keyword

00:31:49,519 --> 00:31:53,039
so what we're doing is basically getting

00:31:51,279 --> 00:31:55,600
a kind of compromise

00:31:53,039 --> 00:31:56,720
between the very manatic chainable style

00:31:55,600 --> 00:31:57,440
that's traditional and functional

00:31:56,720 --> 00:31:58,960
programming

00:31:57,440 --> 00:32:00,640
and something that looks a little more

00:31:58,960 --> 00:32:02,320
familiar to you this kind of looks a

00:32:00,640 --> 00:32:03,200
little bit like a single weight style

00:32:02,320 --> 00:32:04,880
programming

00:32:03,200 --> 00:32:06,559
under the covers the yield keyword is

00:32:04,880 --> 00:32:07,679
calling our chain method and chaining

00:32:06,559 --> 00:32:10,240
our ios together

00:32:07,679 --> 00:32:12,320
so it still performs magnetically and

00:32:10,240 --> 00:32:14,399
gives us all the guarantees and

00:32:12,320 --> 00:32:16,720
expected behaviors that we want but the

00:32:14,399 --> 00:32:19,679
it nods to a slightly more familiar

00:32:16,720 --> 00:32:20,320
and accept easy to accept coding style

00:32:19,679 --> 00:32:22,799
and so that's

00:32:20,320 --> 00:32:24,399
one of the advantages of this do syntax

00:32:22,799 --> 00:32:27,279
and that is something that the

00:32:24,399 --> 00:32:28,960
the the implementation in the neo of the

00:32:27,279 --> 00:32:30,640
i o monad supports

00:32:28,960 --> 00:32:32,000
and this is a more complex example i

00:32:30,640 --> 00:32:32,399
don't want you to get too wrapped up in

00:32:32,000 --> 00:32:34,000
the

00:32:32,399 --> 00:32:35,120
usage of these maybes and eithers and

00:32:34,000 --> 00:32:36,880
things but i want you to focus

00:32:35,120 --> 00:32:38,799
specifically on line 63

00:32:36,880 --> 00:32:41,200
because here i'm doing something again

00:32:38,799 --> 00:32:43,440
that looks very much like a async await

00:32:41,200 --> 00:32:45,440
style this weight function is actually

00:32:43,440 --> 00:32:47,679
creating a monad wrapped around

00:32:45,440 --> 00:32:48,720
an asynchronous timer it's kind of

00:32:47,679 --> 00:32:50,720
faking that there's a

00:32:48,720 --> 00:32:52,720
like a delay of a lookup in the database

00:32:50,720 --> 00:32:53,600
and so there's an asynchronous timer

00:32:52,720 --> 00:32:55,519
that's going off

00:32:53,600 --> 00:32:57,440
and that resolves that monad and then

00:32:55,519 --> 00:32:58,720
moves along and the reason i wanted to

00:32:57,440 --> 00:33:01,519
illustrate this is because

00:32:58,720 --> 00:33:03,279
moneo's i o is actually a transparent

00:33:01,519 --> 00:33:05,120
transformer over promises

00:33:03,279 --> 00:33:06,320
which kind of makes it like the task

00:33:05,120 --> 00:33:08,799
monad so

00:33:06,320 --> 00:33:10,000
it lets us do this async await style

00:33:08,799 --> 00:33:12,080
either in the do syntax

00:33:10,000 --> 00:33:14,559
like we see here or in the chaining

00:33:12,080 --> 00:33:16,399
syntax that we saw earlier

00:33:14,559 --> 00:33:18,480
and that's what i'm kind of excited

00:33:16,399 --> 00:33:20,080
about with this io monad this concept

00:33:18,480 --> 00:33:20,799
because you can mix so many other things

00:33:20,080 --> 00:33:22,799
into it

00:33:20,799 --> 00:33:24,799
like the task behaviors and reader and

00:33:22,799 --> 00:33:26,559
all these other monad behaviors into it

00:33:24,799 --> 00:33:28,720
so along with all of the friends in the

00:33:26,559 --> 00:33:30,799
manila library it becomes kind of this

00:33:28,720 --> 00:33:32,480
one size fits all or the one ring to

00:33:30,799 --> 00:33:34,240
rule them all kind of moan at

00:33:32,480 --> 00:33:35,760
and i've started to use this in a lot of

00:33:34,240 --> 00:33:37,120
more places in my program

00:33:35,760 --> 00:33:39,600
and that's what's got me excited and

00:33:37,120 --> 00:33:40,480
wanted to talk to give you this talk

00:33:39,600 --> 00:33:42,799
today

00:33:40,480 --> 00:33:43,760
so as we wrap up let me just give you a

00:33:42,799 --> 00:33:46,320
quick summary

00:33:43,760 --> 00:33:47,519
we talked about this monad type and

00:33:46,320 --> 00:33:49,360
interface idea

00:33:47,519 --> 00:33:51,679
and that tells us that we can make these

00:33:49,360 --> 00:33:53,279
values that have these sort of abstract

00:33:51,679 --> 00:33:55,600
guarantees about what their behavior

00:33:53,279 --> 00:33:57,600
should be but the real focus that we've

00:33:55,600 --> 00:33:58,720
spent in this talk is on what can i do

00:33:57,600 --> 00:34:00,480
in my programs like

00:33:58,720 --> 00:34:02,240
what problems do i face and how can i

00:34:00,480 --> 00:34:04,320
solve those problems

00:34:02,240 --> 00:34:06,159
so i hope that you have gotten that this

00:34:04,320 --> 00:34:06,960
is not an all or nothing thing you don't

00:34:06,159 --> 00:34:09,280
have to be

00:34:06,960 --> 00:34:11,040
all functional you can sprinkle in

00:34:09,280 --> 00:34:12,079
little bits of functional like pure

00:34:11,040 --> 00:34:14,159
functions and

00:34:12,079 --> 00:34:15,919
use a maybe monad and then maybe using

00:34:14,159 --> 00:34:17,679
an either moana at a later time

00:34:15,919 --> 00:34:20,079
you can progressively move through that

00:34:17,679 --> 00:34:22,000
and that's kind of the takeaway from

00:34:20,079 --> 00:34:23,839
my functional light javascript book and

00:34:22,000 --> 00:34:24,560
the associated course from fronted

00:34:23,839 --> 00:34:26,240
masters

00:34:24,560 --> 00:34:27,599
is to just go through this little by

00:34:26,240 --> 00:34:28,320
little instead of feeling like you have

00:34:27,599 --> 00:34:30,240
to rewrite

00:34:28,320 --> 00:34:32,480
the entire program again you want to

00:34:30,240 --> 00:34:33,359
develop some intuition and familiarity

00:34:32,480 --> 00:34:35,359
with these things

00:34:33,359 --> 00:34:37,520
so that they become more readable and my

00:34:35,359 --> 00:34:38,000
caution to you is don't be so scared

00:34:37,520 --> 00:34:40,079
about

00:34:38,000 --> 00:34:41,599
the confusion of it that you run away

00:34:40,079 --> 00:34:42,159
because then you'll never get to that

00:34:41,599 --> 00:34:45,280
point

00:34:42,159 --> 00:34:47,839
where it feels more understandable so

00:34:45,280 --> 00:34:49,919
i hope that maybe i've convinced you to

00:34:47,839 --> 00:34:50,800
try out moan ads and and try to explore

00:34:49,919 --> 00:34:52,480
them a little bit more

00:34:50,800 --> 00:34:54,320
there's lots of great resources on that

00:34:52,480 --> 00:34:57,760
topic oh and by the way you should

00:34:54,320 --> 00:34:59,520
probably also use regular expressions

00:34:57,760 --> 00:35:03,839
thanks very much for coming to my talk

00:34:59,520 --> 00:35:03,839
mo problems monads i'm kyle simpson

00:35:14,839 --> 00:35:20,570
getify

00:35:17,500 --> 00:35:20,570
[Music]

00:35:20,720 --> 00:35:24,800
kyle has arrived the man the myth the

00:35:23,040 --> 00:35:27,920
legend that is

00:35:24,800 --> 00:35:30,160
hello hello hello that was a brilliant

00:35:27,920 --> 00:35:32,240
talk thank you very much for giving it

00:35:30,160 --> 00:35:34,079
thank you and to everybody watching

00:35:32,240 --> 00:35:34,480
along please do pop your questions into

00:35:34,079 --> 00:35:37,680
the q

00:35:34,480 --> 00:35:39,200
a section um i can't see any in there at

00:35:37,680 --> 00:35:41,359
the moment so i'm gonna

00:35:39,200 --> 00:35:43,200
ask you kyle if you could tell us a

00:35:41,359 --> 00:35:44,000
little bit more about your amazing book

00:35:43,200 --> 00:35:47,040
that everybody

00:35:44,000 --> 00:35:50,320
is in with a chance of winning today yes

00:35:47,040 --> 00:35:52,960
um we uh we gave away

00:35:50,320 --> 00:35:53,920
the or are giving away the get started

00:35:52,960 --> 00:35:56,480
book so

00:35:53,920 --> 00:35:58,160
many people probably know about the

00:35:56,480 --> 00:36:00,560
first edition of the you don't know js

00:35:58,160 --> 00:36:03,920
books those were written starting back

00:36:00,560 --> 00:36:06,400
in the end of 2014 and into 2015

00:36:03,920 --> 00:36:08,000
um and there was always a plan to come

00:36:06,400 --> 00:36:09,599
back and update those books

00:36:08,000 --> 00:36:11,280
unfortunately it took a lot longer than

00:36:09,599 --> 00:36:14,320
i expected so

00:36:11,280 --> 00:36:15,359
um the beginning of this year i finally

00:36:14,320 --> 00:36:17,839
picked up that work

00:36:15,359 --> 00:36:18,880
and started putting out the next edition

00:36:17,839 --> 00:36:20,400
of those books

00:36:18,880 --> 00:36:22,079
because it turns out a lot has changed

00:36:20,400 --> 00:36:24,000
about javascript but also a lot has

00:36:22,079 --> 00:36:25,040
changed in terms of what i know about

00:36:24,000 --> 00:36:27,520
the language

00:36:25,040 --> 00:36:29,119
i know more of it than i did before and

00:36:27,520 --> 00:36:31,760
so i wanted to update that

00:36:29,119 --> 00:36:33,440
so as things currently stand two of the

00:36:31,760 --> 00:36:34,480
six books have been rewritten for the

00:36:33,440 --> 00:36:35,839
second edition

00:36:34,480 --> 00:36:37,760
it turned out they were a complete

00:36:35,839 --> 00:36:38,320
rewrite from scratch i totally started

00:36:37,760 --> 00:36:41,839
over with

00:36:38,320 --> 00:36:44,000
empty files and those two are out the

00:36:41,839 --> 00:36:46,400
first one is called get started

00:36:44,000 --> 00:36:47,599
and the second one is the familiar scope

00:36:46,400 --> 00:36:50,560
enclosures book

00:36:47,599 --> 00:36:51,920
so all the attendees we've got the get

00:36:50,560 --> 00:36:54,240
started book

00:36:51,920 --> 00:36:56,160
the first in the second edition books

00:36:54,240 --> 00:36:59,520
the rewrite

00:36:56,160 --> 00:37:01,839
wow you all have been very busy

00:36:59,520 --> 00:37:03,599
that's a lot of writing it is a lot of

00:37:01,839 --> 00:37:05,119
writing for sure

00:37:03,599 --> 00:37:06,400
and so i can't see any questions of

00:37:05,119 --> 00:37:08,160
coming just yet i'm sure people are

00:37:06,400 --> 00:37:10,480
furiously typing as we speak

00:37:08,160 --> 00:37:11,760
but um before i put everybody to sleep

00:37:10,480 --> 00:37:14,560
one of the two i'm not sure what

00:37:11,760 --> 00:37:15,440
it is one or two i'm sure it was the uh

00:37:14,560 --> 00:37:17,680
the former

00:37:15,440 --> 00:37:19,520
and so i'm from cornwall and your

00:37:17,680 --> 00:37:20,800
workshop that you did down here many

00:37:19,520 --> 00:37:23,040
many years ago now

00:37:20,800 --> 00:37:25,440
it's all remember that famous locally

00:37:23,040 --> 00:37:27,599
really yeah we keep on getting

00:37:25,440 --> 00:37:29,280
so i used to work for the organization

00:37:27,599 --> 00:37:31,040
that brought you down

00:37:29,280 --> 00:37:32,720
and we keep on getting asked for you to

00:37:31,040 --> 00:37:33,920
come back so do you fancy a trip it's

00:37:32,720 --> 00:37:36,400
cornwall for holiday

00:37:33,920 --> 00:37:38,240
i would love to come to cornwall it was

00:37:36,400 --> 00:37:39,200
such a beautiful area i've been to

00:37:38,240 --> 00:37:40,720
london like

00:37:39,200 --> 00:37:43,520
a million times right i've been to

00:37:40,720 --> 00:37:45,440
england i actually in college studied at

00:37:43,520 --> 00:37:46,640
oxford for a summer so i was in that

00:37:45,440 --> 00:37:48,880
area for a while

00:37:46,640 --> 00:37:50,079
but i had never actually seen like the

00:37:48,880 --> 00:37:52,800
really pretty parts

00:37:50,079 --> 00:37:54,000
of the uk of england before and that's

00:37:52,800 --> 00:37:56,240
where i got to see

00:37:54,000 --> 00:37:57,599
we came out to cornwall and then after

00:37:56,240 --> 00:37:59,119
that we went up

00:37:57,599 --> 00:38:00,880
kind of a little bit further up the

00:37:59,119 --> 00:38:02,000
coast and stayed at this like hotel that

00:38:00,880 --> 00:38:04,400
overlooked the

00:38:02,000 --> 00:38:06,560
ocean and it's just a beautiful part of

00:38:04,400 --> 00:38:08,640
the of the world of the country so

00:38:06,560 --> 00:38:10,720
yeah uh anytime we get a chance to make

00:38:08,640 --> 00:38:12,800
something like that happen again i

00:38:10,720 --> 00:38:14,320
one of the cool parts of my at least

00:38:12,800 --> 00:38:16,560
former life where i was traveling all

00:38:14,320 --> 00:38:17,839
the time i don't travel much now but

00:38:16,560 --> 00:38:19,920
when i was traveling all the time it's

00:38:17,839 --> 00:38:21,680
getting to see these beautiful areas and

00:38:19,920 --> 00:38:23,599
and cornwall is definitely high up on my

00:38:21,680 --> 00:38:27,920
list it was beautiful

00:38:23,599 --> 00:38:27,920
awesome well i'll pass it on to the team

00:38:28,320 --> 00:38:31,920
and so when we when we look at your your

00:38:30,960 --> 00:38:34,640
talk

00:38:31,920 --> 00:38:35,599
is it safe to say that you do functional

00:38:34,640 --> 00:38:37,760
programming more than

00:38:35,599 --> 00:38:40,400
object orientated programming or is it

00:38:37,760 --> 00:38:42,880
very much a mix for yourself

00:38:40,400 --> 00:38:44,800
i would say it's definitely a mix i

00:38:42,880 --> 00:38:45,280
don't i don't do a lot of what i would

00:38:44,800 --> 00:38:48,160
call

00:38:45,280 --> 00:38:49,200
object oriented programming because

00:38:48,160 --> 00:38:51,920
typically when you

00:38:49,200 --> 00:38:54,160
hear that term you think classes and i'm

00:38:51,920 --> 00:38:55,920
actually not a big fan of writing class

00:38:54,160 --> 00:38:57,839
oriented code

00:38:55,920 --> 00:39:00,400
so i wouldn't do a lot of what you would

00:38:57,839 --> 00:39:01,680
traditionally call say from the java or

00:39:00,400 --> 00:39:03,800
the c-plus plus

00:39:01,680 --> 00:39:05,119
tradition of what we would call

00:39:03,800 --> 00:39:07,920
object-oriented

00:39:05,119 --> 00:39:09,800
but i do work a lot with objects which

00:39:07,920 --> 00:39:11,599
in sort of a more broad sense is

00:39:09,800 --> 00:39:12,960
object-oriented it's just without

00:39:11,599 --> 00:39:15,839
classes

00:39:12,960 --> 00:39:17,920
so i use a lot of uh very basic

00:39:15,839 --> 00:39:20,880
architecture the module pattern and

00:39:17,920 --> 00:39:22,880
objects as name spaces and i even use

00:39:20,880 --> 00:39:24,800
what i call object delegation which is

00:39:22,880 --> 00:39:27,040
leveraging the the prototype chain in

00:39:24,800 --> 00:39:30,240
javascript and things of that nature

00:39:27,040 --> 00:39:33,760
so sort of generally speaking i

00:39:30,240 --> 00:39:37,359
i do object oriented the functional uh

00:39:33,760 --> 00:39:39,440
aspects of my program are a relatively

00:39:37,359 --> 00:39:41,760
recent addition to my programming

00:39:39,440 --> 00:39:43,280
toolbox and by recent i would say

00:39:41,760 --> 00:39:45,760
over the last three to four years i've

00:39:43,280 --> 00:39:46,960
started to try to understand this space

00:39:45,760 --> 00:39:48,560
and that's one thing i'd like to

00:39:46,960 --> 00:39:49,280
emphasize for anybody that's listening

00:39:48,560 --> 00:39:51,040
in is that

00:39:49,280 --> 00:39:53,359
this was not an overnight thing it's not

00:39:51,040 --> 00:39:55,440
like i read some book or i watched the

00:39:53,359 --> 00:39:56,800
conference talk or read a blog and then

00:39:55,440 --> 00:39:58,160
all of a sudden the light bulb went off

00:39:56,800 --> 00:40:01,200
it's been a long

00:39:58,160 --> 00:40:02,160
uh adjustment process and even to this

00:40:01,200 --> 00:40:04,400
day i've been

00:40:02,160 --> 00:40:06,000
actually writing an app where you saw in

00:40:04,400 --> 00:40:07,520
the talks some code snippets from

00:40:06,000 --> 00:40:10,480
a real app that i've been writing for

00:40:07,520 --> 00:40:12,560
myself and i start out writing

00:40:10,480 --> 00:40:13,680
code imperatively because that's still

00:40:12,560 --> 00:40:15,680
my comfort zone

00:40:13,680 --> 00:40:17,920
it's still what i've done for 20 plus

00:40:15,680 --> 00:40:19,920
years and so i start out writing it that

00:40:17,920 --> 00:40:22,000
way and what i have been able to

00:40:19,920 --> 00:40:23,359
accomplish over the last several years

00:40:22,000 --> 00:40:27,119
is be able to look at a

00:40:23,359 --> 00:40:29,119
piece of code and then sort of neo

00:40:27,119 --> 00:40:30,800
in the matrix style be able to see

00:40:29,119 --> 00:40:33,119
beyond that to

00:40:30,800 --> 00:40:34,640
the pattern the pattern behind what i'm

00:40:33,119 --> 00:40:37,440
doing and that's when

00:40:34,640 --> 00:40:39,040
what can emerge is the alternate option

00:40:37,440 --> 00:40:40,880
doing something with functional

00:40:39,040 --> 00:40:43,599
what i know about functional programming

00:40:40,880 --> 00:40:46,480
is that it offers many more guarantees

00:40:43,599 --> 00:40:47,280
it offers better testability you know

00:40:46,480 --> 00:40:49,680
more

00:40:47,280 --> 00:40:50,880
more readability even though people

00:40:49,680 --> 00:40:53,040
listening maybe think oh

00:40:50,880 --> 00:40:55,680
that looked much less readable once you

00:40:53,040 --> 00:40:57,440
actually get used to that style of code

00:40:55,680 --> 00:40:59,760
those things actually jump out more

00:40:57,440 --> 00:41:01,280
quickly at you than you typically would

00:40:59,760 --> 00:41:03,520
with imperative code you don't have to

00:41:01,280 --> 00:41:05,599
do as much mental execution

00:41:03,520 --> 00:41:07,839
so all of these are things that i know

00:41:05,599 --> 00:41:09,839
to expect from functional programming

00:41:07,839 --> 00:41:11,839
it's still difficult for me frankly to

00:41:09,839 --> 00:41:13,920
author a program from scratch

00:41:11,839 --> 00:41:15,920
using those techniques but i've gotten

00:41:13,920 --> 00:41:17,440
better at the case of writing something

00:41:15,920 --> 00:41:18,800
and then as i'm getting along and

00:41:17,440 --> 00:41:19,520
understanding a little bit of what i'm

00:41:18,800 --> 00:41:21,920
doing

00:41:19,520 --> 00:41:24,079
kind of micro refactoring to use these

00:41:21,920 --> 00:41:26,160
principles little bit at a time

00:41:24,079 --> 00:41:28,240
so i would say that i'm i'm in the in

00:41:26,160 --> 00:41:29,839
the most truest sense of the word a

00:41:28,240 --> 00:41:31,760
multi-paradigm programmer

00:41:29,839 --> 00:41:34,000
which means for any given line or any

00:41:31,760 --> 00:41:36,079
given set of lines of code

00:41:34,000 --> 00:41:37,359
i'm going to use whatever pattern is

00:41:36,079 --> 00:41:39,440
most comfortable whatever

00:41:37,359 --> 00:41:41,280
pattern makes most sense and ultimately

00:41:39,440 --> 00:41:43,680
whatever pattern will communicate

00:41:41,280 --> 00:41:45,280
best the ideas that i want to get across

00:41:43,680 --> 00:41:47,200
what's happening for me over the last

00:41:45,280 --> 00:41:49,280
several years is that that's starting to

00:41:47,200 --> 00:41:52,000
be more functional in nature

00:41:49,280 --> 00:41:52,640
but it isn't it isn't even yet the thing

00:41:52,000 --> 00:41:54,800
where that's

00:41:52,640 --> 00:41:57,040
automatic that's it's still a thing that

00:41:54,800 --> 00:41:59,440
i have to work towards

00:41:57,040 --> 00:42:00,560
okay so the questions have started

00:41:59,440 --> 00:42:02,319
rolling in now

00:42:00,560 --> 00:42:04,560
okay we can move on to them so we've got

00:42:02,319 --> 00:42:04,960
one here saying many of the patterns you

00:42:04,560 --> 00:42:08,319
showed

00:42:04,960 --> 00:42:10,800
look familiar is there a benefit

00:42:08,319 --> 00:42:11,920
to being more conscious of when i'm

00:42:10,800 --> 00:42:15,760
using a monad

00:42:11,920 --> 00:42:17,119
like pattern yes i think that's actually

00:42:15,760 --> 00:42:21,119
uh this is a great

00:42:17,119 --> 00:42:24,079
question to start off um our q a with

00:42:21,119 --> 00:42:25,119
that's that's really the core essence of

00:42:24,079 --> 00:42:27,520
this talk

00:42:25,119 --> 00:42:28,800
is for you to begin to realize that all

00:42:27,520 --> 00:42:31,520
of programming

00:42:28,800 --> 00:42:33,680
is recognizing a problem and then trying

00:42:31,520 --> 00:42:35,359
to substitute in a known solution or

00:42:33,680 --> 00:42:38,240
work out a solution

00:42:35,359 --> 00:42:40,160
to that known problem all programmers

00:42:38,240 --> 00:42:42,240
regardless of what paradigm you use

00:42:40,160 --> 00:42:44,000
follow that practice they look at

00:42:42,240 --> 00:42:46,400
something they want to do they try to do

00:42:44,000 --> 00:42:48,319
it they run against it's not doing what

00:42:46,400 --> 00:42:51,359
i want that's the problem

00:42:48,319 --> 00:42:53,599
and then they solve that problem using

00:42:51,359 --> 00:42:55,359
what they have already seen before

00:42:53,599 --> 00:42:56,800
or what they can google or stack

00:42:55,359 --> 00:42:58,800
overflow they use

00:42:56,800 --> 00:43:00,560
those solutions to solve the problem

00:42:58,800 --> 00:43:02,079
that's the general pattern that all

00:43:00,560 --> 00:43:04,720
software development follows

00:43:02,079 --> 00:43:06,400
and so all i'm suggesting here is that

00:43:04,720 --> 00:43:08,960
there's this set of tools

00:43:06,400 --> 00:43:10,400
that solve problems in a different way

00:43:08,960 --> 00:43:12,319
than what we're used to

00:43:10,400 --> 00:43:13,440
and i include myself in that because i

00:43:12,319 --> 00:43:15,680
didn't start

00:43:13,440 --> 00:43:16,640
programming in the functional tradition

00:43:15,680 --> 00:43:18,640
uh but the

00:43:16,640 --> 00:43:20,640
they're all problems that we all face

00:43:18,640 --> 00:43:22,480
and i only called out three there's

00:43:20,640 --> 00:43:24,560
literally an infinite list of problems

00:43:22,480 --> 00:43:26,400
that we face functional programming

00:43:24,560 --> 00:43:27,440
offers what i think is some really

00:43:26,400 --> 00:43:29,680
compelling

00:43:27,440 --> 00:43:30,480
alternative ways of modeling the

00:43:29,680 --> 00:43:32,720
solution

00:43:30,480 --> 00:43:33,599
and one of the biggest reasons why we

00:43:32,720 --> 00:43:35,920
want to do that

00:43:33,599 --> 00:43:37,440
is as i said it can produce more

00:43:35,920 --> 00:43:38,480
readable code it will produce more

00:43:37,440 --> 00:43:41,599
testable

00:43:38,480 --> 00:43:42,720
and more uh verifiable code like for

00:43:41,599 --> 00:43:44,240
example

00:43:42,720 --> 00:43:46,960
you could you could literally get to the

00:43:44,240 --> 00:43:48,640
point where you could know for sure

00:43:46,960 --> 00:43:50,960
because it's based on math even if you

00:43:48,640 --> 00:43:53,200
don't know the math it's based on math

00:43:50,960 --> 00:43:54,000
and you could know for sure that a piece

00:43:53,200 --> 00:43:56,079
of code will have

00:43:54,000 --> 00:43:57,200
a certain outcome even if you haven't

00:43:56,079 --> 00:43:59,359
run the test suite

00:43:57,200 --> 00:44:01,280
and i just imagine to myself what if i

00:43:59,359 --> 00:44:02,000
could have that level of confidence in

00:44:01,280 --> 00:44:04,079
my code

00:44:02,000 --> 00:44:05,359
that before i even run the test i know

00:44:04,079 --> 00:44:06,720
exactly what it's going to do i know

00:44:05,359 --> 00:44:07,440
what's going to succeed what's going to

00:44:06,720 --> 00:44:10,240
fail

00:44:07,440 --> 00:44:12,160
that's the the offered principle here

00:44:10,240 --> 00:44:13,119
but i think even more than all of those

00:44:12,160 --> 00:44:16,079
benefits

00:44:13,119 --> 00:44:17,839
is that the functional way of thinking

00:44:16,079 --> 00:44:19,680
about our programs to create these tiny

00:44:17,839 --> 00:44:20,720
pieces that compose more cleanly

00:44:19,680 --> 00:44:22,480
together

00:44:20,720 --> 00:44:23,920
what that offers is that once you have

00:44:22,480 --> 00:44:24,800
gotten familiar with those different

00:44:23,920 --> 00:44:27,119
pieces

00:44:24,800 --> 00:44:28,400
those are lego pieces that fit together

00:44:27,119 --> 00:44:30,160
much more cleanly

00:44:28,400 --> 00:44:31,680
than any imperative code we've ever

00:44:30,160 --> 00:44:33,359
written so i don't know about

00:44:31,680 --> 00:44:35,440
people listening but i've always felt

00:44:33,359 --> 00:44:36,400
like man i'm having to fight against my

00:44:35,440 --> 00:44:38,560
program the more

00:44:36,400 --> 00:44:40,160
imperative and the more if statements

00:44:38,560 --> 00:44:42,079
and the more try catches i have to

00:44:40,160 --> 00:44:44,160
wrap around things it gets harder and

00:44:42,079 --> 00:44:46,240
harder to wrangle through the code

00:44:44,160 --> 00:44:48,240
if you're doing functional programming

00:44:46,240 --> 00:44:49,440
the right way and i admit that it takes

00:44:48,240 --> 00:44:50,480
a while to get there but if you're doing

00:44:49,440 --> 00:44:52,880
it the right way

00:44:50,480 --> 00:44:54,400
the further you get into a program the

00:44:52,880 --> 00:44:56,400
easier things get

00:44:54,400 --> 00:44:58,880
because things start to fit together the

00:44:56,400 --> 00:45:01,599
way lego pieces are designed to do so

00:44:58,880 --> 00:45:04,240
so it's really training ourselves to

00:45:01,599 --> 00:45:07,200
move from that more comfortable but

00:45:04,240 --> 00:45:08,880
harder to maintain style of code to a

00:45:07,200 --> 00:45:10,880
less comfortable initially

00:45:08,880 --> 00:45:12,480
but much more easy to maintain and

00:45:10,880 --> 00:45:14,640
verify style of code down

00:45:12,480 --> 00:45:15,680
down the road that's what i hope that

00:45:14,640 --> 00:45:17,200
you get from this talk

00:45:15,680 --> 00:45:19,200
that's what you want to look for those

00:45:17,200 --> 00:45:21,119
problems and then say ah

00:45:19,200 --> 00:45:22,880
i remember that there's a tool that

00:45:21,119 --> 00:45:24,319
looks like that just like if you were

00:45:22,880 --> 00:45:26,160
building a home and you're like i need

00:45:24,319 --> 00:45:27,680
to put a nail in the wall i remember

00:45:26,160 --> 00:45:28,240
that the right tool for that is the

00:45:27,680 --> 00:45:30,640
hammer

00:45:28,240 --> 00:45:32,240
that's what we want to get from this you

00:45:30,640 --> 00:45:34,800
say that i nailed in a hammer with a

00:45:32,240 --> 00:45:34,800
drill today

00:45:34,880 --> 00:45:38,960
hammered in a nail with a drill you know

00:45:37,200 --> 00:45:40,640
sometimes you got it sometimes you got

00:45:38,960 --> 00:45:42,000
to use whatever tool you have available

00:45:40,640 --> 00:45:44,079
to you but ideally

00:45:42,000 --> 00:45:46,160
we want to use the hammer yeah

00:45:44,079 --> 00:45:47,839
definitely and that does lead nicely

00:45:46,160 --> 00:45:49,760
onto another question we've had come in

00:45:47,839 --> 00:45:52,000
when would you choose functional

00:45:49,760 --> 00:45:56,000
programming over any other paradigm

00:45:52,000 --> 00:45:58,480
eg rxjs versus monads

00:45:56,000 --> 00:46:01,599
so it's not an either or it's not

00:45:58,480 --> 00:46:03,839
mutually exclusive rxjs is actually

00:46:01,599 --> 00:46:04,960
in a lot of ways very compatible with

00:46:03,839 --> 00:46:06,880
functional programming

00:46:04,960 --> 00:46:09,280
as a matter of fact in the functional

00:46:06,880 --> 00:46:11,440
light book i talked about in my talk

00:46:09,280 --> 00:46:12,319
which you can get out on on my github to

00:46:11,440 --> 00:46:14,800
the same way you get

00:46:12,319 --> 00:46:15,680
can get the other books in that book i

00:46:14,800 --> 00:46:17,520
have a whole chapter

00:46:15,680 --> 00:46:19,680
talking about applying functional

00:46:17,520 --> 00:46:21,440
principles over time

00:46:19,680 --> 00:46:23,599
and the way we do that is basically

00:46:21,440 --> 00:46:26,079
through observables which is what rx is

00:46:23,599 --> 00:46:28,240
so rx is actually very compatible with

00:46:26,079 --> 00:46:30,240
the way of thinking about functional i

00:46:28,240 --> 00:46:31,920
don't use observables an awful lot

00:46:30,240 --> 00:46:32,480
myself personally but that doesn't mean

00:46:31,920 --> 00:46:34,079
that

00:46:32,480 --> 00:46:35,760
it's it's an either or that you have to

00:46:34,079 --> 00:46:38,880
pick one or the other

00:46:35,760 --> 00:46:40,960
the thing to recognize is that when

00:46:38,880 --> 00:46:42,319
you want to use functional programming

00:46:40,960 --> 00:46:44,800
is when it is

00:46:42,319 --> 00:46:45,599
ever the case that you have a piece of

00:46:44,800 --> 00:46:48,720
code

00:46:45,599 --> 00:46:50,400
that you want to be isolated from any

00:46:48,720 --> 00:46:54,079
other piece of code in other words

00:46:50,400 --> 00:46:57,280
if you're on line 5000 of your program

00:46:54,079 --> 00:46:58,960
and it is an impure function call and it

00:46:57,280 --> 00:47:00,720
references who knows what else from

00:46:58,960 --> 00:47:01,760
other parts of the program to know what

00:47:00,720 --> 00:47:03,760
line 5000

00:47:01,760 --> 00:47:08,000
is doing requires you to mentally

00:47:03,760 --> 00:47:10,079
execute lines one through lines 4999

00:47:08,000 --> 00:47:11,040
to compute the state of the program in

00:47:10,079 --> 00:47:12,960
your head

00:47:11,040 --> 00:47:15,119
so that you can understand and predict

00:47:12,960 --> 00:47:16,800
the outcome of line 5000

00:47:15,119 --> 00:47:18,240
and i don't know about you but i'm not

00:47:16,800 --> 00:47:20,480
particularly good at

00:47:18,240 --> 00:47:21,839
executing javascript in my head that's

00:47:20,480 --> 00:47:23,920
what the computer is good at

00:47:21,839 --> 00:47:25,040
so functional programming offers the

00:47:23,920 --> 00:47:28,160
promise of

00:47:25,040 --> 00:47:30,720
what if line 5000 could be computed

00:47:28,160 --> 00:47:32,240
completely in isolation of anything else

00:47:30,720 --> 00:47:33,280
would that make you a more effective

00:47:32,240 --> 00:47:35,359
programmer

00:47:33,280 --> 00:47:38,160
so i hope i don't sound too glib when i

00:47:35,359 --> 00:47:38,960
say there's almost no code that can't

00:47:38,160 --> 00:47:42,480
benefit

00:47:38,960 --> 00:47:45,359
from that some pieces of code benefit

00:47:42,480 --> 00:47:47,440
better from low level simple things like

00:47:45,359 --> 00:47:49,520
simply making it a pure function call

00:47:47,440 --> 00:47:51,280
some bits of code will benefit from

00:47:49,520 --> 00:47:52,640
using something a bit more exotic and

00:47:51,280 --> 00:47:54,880
involved like a monad

00:47:52,640 --> 00:47:56,400
and some will benefit from patterns that

00:47:54,880 --> 00:47:56,880
quite frankly i don't even understand

00:47:56,400 --> 00:47:58,640
yet

00:47:56,880 --> 00:48:00,480
there's a whole road that i'm still

00:47:58,640 --> 00:48:01,920
headed down trying to learn

00:48:00,480 --> 00:48:03,440
but i don't think there's any code where

00:48:01,920 --> 00:48:04,960
you could say oh you definitely

00:48:03,440 --> 00:48:07,680
shouldn't do that functionally

00:48:04,960 --> 00:48:08,559
even side effects which seem the

00:48:07,680 --> 00:48:10,319
antithesis

00:48:08,559 --> 00:48:12,960
of functional programming can be

00:48:10,319 --> 00:48:14,960
wrangled better if you use the iomo net

00:48:12,960 --> 00:48:16,000
so if you'd asked me this question say

00:48:14,960 --> 00:48:17,599
two years ago

00:48:16,000 --> 00:48:19,680
i probably would have answered it by

00:48:17,599 --> 00:48:21,040
saying well you know anytime i'm going

00:48:19,680 --> 00:48:22,960
to do side effects like

00:48:21,040 --> 00:48:24,240
managing the dom for example i'm

00:48:22,960 --> 00:48:25,280
probably not going to worry too much

00:48:24,240 --> 00:48:26,880
about functional

00:48:25,280 --> 00:48:28,480
and now when you ask me that question

00:48:26,880 --> 00:48:29,200
i'm going to say if i need to do side

00:48:28,480 --> 00:48:31,520
effects

00:48:29,200 --> 00:48:33,599
i now understand that there's a tool

00:48:31,520 --> 00:48:34,319
that's actually well designed for that

00:48:33,599 --> 00:48:37,599
problem

00:48:34,319 --> 00:48:40,000
and that tool is the iomona so it is

00:48:37,599 --> 00:48:40,720
always the case that you will be able to

00:48:40,000 --> 00:48:42,240
learn

00:48:40,720 --> 00:48:43,920
a pattern you may not recognize them

00:48:42,240 --> 00:48:45,680
always off the bat

00:48:43,920 --> 00:48:47,520
but you will be able to learn a pattern

00:48:45,680 --> 00:48:48,960
if you apply yourself to try this you'll

00:48:47,520 --> 00:48:51,359
be able to learn a pattern

00:48:48,960 --> 00:48:52,720
that should be able to address basically

00:48:51,359 --> 00:48:53,680
anything that you run across i don't

00:48:52,720 --> 00:48:55,359
think there's

00:48:53,680 --> 00:48:57,119
very many tasks that you would ever do

00:48:55,359 --> 00:49:00,240
in programming where somebody would say

00:48:57,119 --> 00:49:02,000
definitely not never do functional there

00:49:00,240 --> 00:49:04,960
is often the case the opposite

00:49:02,000 --> 00:49:06,000
where there's a very dogmatic like it

00:49:04,960 --> 00:49:08,880
has to be all

00:49:06,000 --> 00:49:10,880
functional or none and i don't like that

00:49:08,880 --> 00:49:12,240
that dogmatic perspective either

00:49:10,880 --> 00:49:13,920
you can have one line of code that

00:49:12,240 --> 00:49:15,599
benefits from functional programming

00:49:13,920 --> 00:49:17,359
and another line of code that you don't

00:49:15,599 --> 00:49:18,480
have the right tool for or it's not

00:49:17,359 --> 00:49:20,559
appropriate for

00:49:18,480 --> 00:49:22,640
and that's okay because i ultimately

00:49:20,559 --> 00:49:24,160
want you to have the pragmatic balanced

00:49:22,640 --> 00:49:26,000
approach to your code

00:49:24,160 --> 00:49:27,440
that lets you communicate better and

00:49:26,000 --> 00:49:29,280
lets you ship code

00:49:27,440 --> 00:49:30,720
i don't want you to be stuck in the mud

00:49:29,280 --> 00:49:31,599
if you will like oh i can't do it

00:49:30,720 --> 00:49:33,520
perfectly so

00:49:31,599 --> 00:49:36,160
you know don't let perfect be the enemy

00:49:33,520 --> 00:49:37,280
of good pragmatically decide on every

00:49:36,160 --> 00:49:38,720
line of code

00:49:37,280 --> 00:49:40,240
is there something that i know is their

00:49:38,720 --> 00:49:42,800
tool that i know that could make this

00:49:40,240 --> 00:49:45,040
line of code communicate my ideas better

00:49:42,800 --> 00:49:46,079
be more verifiable be more testable be

00:49:45,040 --> 00:49:48,079
more independent

00:49:46,079 --> 00:49:49,760
and if so use the tool and if not don't

00:49:48,079 --> 00:49:51,680
use the tool

00:49:49,760 --> 00:49:52,880
yeah and i think breaking down your code

00:49:51,680 --> 00:49:54,960
into line by line

00:49:52,880 --> 00:49:57,040
like that and looking at it is a very

00:49:54,960 --> 00:49:59,520
good exercise particularly for

00:49:57,040 --> 00:50:01,520
people who are maybe around the junior

00:49:59,520 --> 00:50:04,559
level or even below

00:50:01,520 --> 00:50:06,160
and get get input on it as well yeah

00:50:04,559 --> 00:50:07,040
absolutely we need to be able to look at

00:50:06,160 --> 00:50:09,200
our programs

00:50:07,040 --> 00:50:11,359
and ask questions of our programs

00:50:09,200 --> 00:50:12,960
instead of just like oh it works and i

00:50:11,359 --> 00:50:14,720
don't know why and i'm not curious

00:50:12,960 --> 00:50:17,200
we should ask questions of our program

00:50:14,720 --> 00:50:20,480
hey why does that do what it's doing

00:50:17,200 --> 00:50:22,240
and how do i make it do that even better

00:50:20,480 --> 00:50:24,240
okay so we're running out of time so if

00:50:22,240 --> 00:50:25,359
i could keep you short on this one

00:50:24,240 --> 00:50:27,359
okay and then hopefully we'll have a

00:50:25,359 --> 00:50:30,400
little bit longer one afterwards um

00:50:27,359 --> 00:50:32,400
will native js support monads and other

00:50:30,400 --> 00:50:34,720
structures one day

00:50:32,400 --> 00:50:35,680
do you think um i think it's very

00:50:34,720 --> 00:50:38,960
unlikely

00:50:35,680 --> 00:50:41,200
that native javascript ever grows

00:50:38,960 --> 00:50:42,960
more than the syntactic capabilities

00:50:41,200 --> 00:50:44,240
that it already has so we have functions

00:50:42,960 --> 00:50:46,720
we have closure

00:50:44,240 --> 00:50:48,480
and if you adhere to the principles that

00:50:46,720 --> 00:50:50,079
functional programming requires

00:50:48,480 --> 00:50:51,839
you can do everything that you want to

00:50:50,079 --> 00:50:52,480
do in functional programming that's a

00:50:51,839 --> 00:50:54,079
somewhat

00:50:52,480 --> 00:50:56,000
controversial claim because a lot of

00:50:54,079 --> 00:50:57,520
people would say no no javascript is a

00:50:56,000 --> 00:50:59,440
terrible language to do that in

00:50:57,520 --> 00:51:01,359
i happen to think that javascript native

00:50:59,440 --> 00:51:02,559
core javascript is actually one of the

00:51:01,359 --> 00:51:05,520
best languages

00:51:02,559 --> 00:51:06,079
to express functional principles in in

00:51:05,520 --> 00:51:08,160
part

00:51:06,079 --> 00:51:09,440
in large part because javascript is not

00:51:08,160 --> 00:51:12,640
constrained

00:51:09,440 --> 00:51:13,440
by the same complexities of type based

00:51:12,640 --> 00:51:14,880
languages

00:51:13,440 --> 00:51:17,200
so i actually think rather than being a

00:51:14,880 --> 00:51:19,440
weakness that's a strength of javascript

00:51:17,200 --> 00:51:20,960
in this space that is a controversial

00:51:19,440 --> 00:51:23,040
statement but it's my position

00:51:20,960 --> 00:51:25,200
on it so i do think that native

00:51:23,040 --> 00:51:25,920
javascript already supports the things

00:51:25,200 --> 00:51:27,760
that we want

00:51:25,920 --> 00:51:29,520
and then we simply bring in libraries

00:51:27,760 --> 00:51:30,960
that just like we're bringing in an rx

00:51:29,520 --> 00:51:32,000
to do an observable we can bring in a

00:51:30,960 --> 00:51:33,520
monad library

00:51:32,000 --> 00:51:35,359
i think it's unlikely that they will

00:51:33,520 --> 00:51:37,119
ship these because there will always be

00:51:35,359 --> 00:51:38,559
so many different opinions

00:51:37,119 --> 00:51:40,000
on what it should be called should it be

00:51:38,559 --> 00:51:40,640
changed should it be flat map should it

00:51:40,000 --> 00:51:42,640
be bind

00:51:40,640 --> 00:51:44,559
they'll we'll never be able to agree on

00:51:42,640 --> 00:51:47,440
the actual names of these things

00:51:44,559 --> 00:51:48,960
so the concept can exist with we already

00:51:47,440 --> 00:51:51,280
have the primitives in the language

00:51:48,960 --> 00:51:53,040
the concept can be layered on with user

00:51:51,280 --> 00:51:55,040
land code

00:51:53,040 --> 00:51:56,480
awesome and this is the final one and it

00:51:55,040 --> 00:51:58,079
will have to be very short

00:51:56,480 --> 00:51:59,440
and it might be one that you refuse to

00:51:58,079 --> 00:52:00,480
answer and get people to follow up on

00:51:59,440 --> 00:52:02,880
twitter

00:52:00,480 --> 00:52:04,000
and so somebody here said firstly thanks

00:52:02,880 --> 00:52:07,119
for the clear explanation

00:52:04,000 --> 00:52:09,359
of monadz um they followed along

00:52:07,119 --> 00:52:10,319
on twitter for a little bit and they've

00:52:09,359 --> 00:52:12,160
asked if

00:52:10,319 --> 00:52:14,559
all of the community pushback on

00:52:12,160 --> 00:52:16,880
terminology is discouraging a deeper

00:52:14,559 --> 00:52:20,240
dive into this

00:52:16,880 --> 00:52:23,119
it is absolutely a discouraging

00:52:20,240 --> 00:52:24,640
um kind of thing that i have faced for a

00:52:23,119 --> 00:52:25,680
lot of my career i wanted to learn

00:52:24,640 --> 00:52:27,760
functional programming

00:52:25,680 --> 00:52:29,760
20 years ago when i first heard about it

00:52:27,760 --> 00:52:31,599
and i spent many many years more than a

00:52:29,760 --> 00:52:33,040
decade discouraged by

00:52:31,599 --> 00:52:34,880
oh well you don't know the words and you

00:52:33,040 --> 00:52:36,319
don't you don't know all the notation

00:52:34,880 --> 00:52:36,880
and all of that so you can't really

00:52:36,319 --> 00:52:38,880
learn

00:52:36,880 --> 00:52:40,800
what i'm hoping that i'm doing is

00:52:38,880 --> 00:52:42,640
helping to lay some breadcrumbs

00:52:40,800 --> 00:52:44,319
that help people come along on this

00:52:42,640 --> 00:52:45,839
discussion and

00:52:44,319 --> 00:52:47,040
one of the things that we have to accept

00:52:45,839 --> 00:52:48,000
is that there will be people that are

00:52:47,040 --> 00:52:49,839
challenged by that

00:52:48,000 --> 00:52:51,680
there are people that have are used to

00:52:49,839 --> 00:52:53,680
being the gatekeepers of that

00:52:51,680 --> 00:52:55,200
uh sacred knowledge and i'm trying to

00:52:53,680 --> 00:52:57,119
open this up to a broader of

00:52:55,200 --> 00:52:58,800
audience and conversation so i think

00:52:57,119 --> 00:53:00,800
there is a way but it is not

00:52:58,800 --> 00:53:02,480
a smooth road it can be a very bumpy

00:53:00,800 --> 00:53:04,400
road

00:53:02,480 --> 00:53:06,000
and on that bombshell we are going to

00:53:04,400 --> 00:53:08,240
have to leave it there kyle

00:53:06,000 --> 00:53:10,319
thank you very much for the talk and for

00:53:08,240 --> 00:53:11,599
the amazing q a um they were brilliant

00:53:10,319 --> 00:53:13,280
answers to the questions

00:53:11,599 --> 00:53:14,640
um i'll be in touch about coming to

00:53:13,280 --> 00:53:16,079
cornwall and anybody else who wants to

00:53:14,640 --> 00:53:18,160
join us

00:53:16,079 --> 00:53:19,599
i'm joking and no it was really really

00:53:18,160 --> 00:53:19,920
good thank you very much to everybody

00:53:19,599 --> 00:53:21,839
else

00:53:19,920 --> 00:53:23,200
the next talk is just about to start and

00:53:21,839 --> 00:53:25,520
we will see you here

00:53:23,200 --> 00:53:26,480
in about 20 minutes for the next q a so

00:53:25,520 --> 00:53:29,839
kyle

00:53:26,480 --> 00:53:29,839

YouTube URL: https://www.youtube.com/watch?v=TKJPwRLQwsA


