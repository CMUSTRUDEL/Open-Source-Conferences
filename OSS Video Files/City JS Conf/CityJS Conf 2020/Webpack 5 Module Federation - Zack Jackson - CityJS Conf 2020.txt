Title: Webpack 5 Module Federation - Zack Jackson - CityJS Conf 2020
Publication date: 2020-10-03
Playlist: CityJS Conf 2020
Description: 
	For years, we have never been able to consume or share modules from another standalone application. The nearest we had was externals or DLL Plugin. Both of which are not scalable or sustainable in large scale systems. For those who have built a micro frontend stack, likely understand the challenges. Introducing Module Federation, a feature that I bought for Webpack 5. It allows us to import code just like you would within a monolith. No overhead, no learning curves, and no real deviation from standard engineering practices. We have built a universal system for developers to consume modules of other applications at runtime. Be it server or client. This architecture has been considered a game-changer to Javascript and will change how we build applications in the future. 

Bio
Principal Engineer, specializing in distributed application architecture at scale

Chapters / Excerpts:
Start [00:00:00] 

Intro [00:00:40]
So module Federation aims to solve some challenges that we have in the JavaScript industry industry at large.

Context on Module Federation [00:02:48]
We have, let's say we have some kind of an app that looks something like this and. I want to say, let's say each part of these squares is a separate federated app, or even just the colors are separately.

Existing Options [00:06:54]
We've got native ESM. Some of the bonuses are just the facts of it is there's no build to link parts for encode is natively consumable, but on the flip side, there's no tree shaking. It only works with the ESM.

The Next Step in JavaScript Architecture [00:10:07]
So what we were looking for is something with Goodwill, build performance, good web performance, and a solution to sharing our dependencies.

Terminology [00:10:35]
So let's get down some of the terminology module Federation it's essentially got it. Got its name from Apollo's graph QL Federation,

What is Module Federation [00:16:30]
So what is module Federation? Exactly? It allows us to import code from other builds at runtime, we can share a vendor code dynamically at runtime. 

An Example [00:19:23]
So going into a bit more of an example here, let's say we've got team AB and some dependencies

Container Plugin Deep Dive [00:26:56]
Yeah. So diving a little deeper into our container plugin. What it does is it has exposed modules that it will pretty much create, and it will also have the provided modules that.

Example at Scale [00:32:36]
I can also use import from dropdown at B slash drop down, and I can just use it as a normal synchronous module as well. 

Demo Video [00:33:34] 

Applied Architecture [00:35:05]
So applied architecture, where could, or what could we end up federating?

Another Example [00:35:38] 

Decentralized Routing [00:38:29]
So. That's done through using the federated shell.

Non Webpack Compatibility [00:40:41]

Federation Dashboard [00:41:12]

Find Out More [00:42:25] 

Q&A [00:43:17]

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:18,100 --> 00:00:23,680
[Music]

00:00:22,880 --> 00:00:26,960
all right

00:00:23,680 --> 00:00:28,400
hey everybody um i'm zach jackson and i

00:00:26,960 --> 00:00:30,560
am a principal engineer over at

00:00:28,400 --> 00:00:33,440
lululemon also

00:00:30,560 --> 00:00:34,880
work with the webpack core team and uh

00:00:33,440 --> 00:00:35,440
today i'll be talking about a new

00:00:34,880 --> 00:00:38,719
feature

00:00:35,440 --> 00:00:38,719
called module federation

00:00:38,800 --> 00:00:43,680
and we'll take it away so module

00:00:42,079 --> 00:00:45,520
federation aims to solve

00:00:43,680 --> 00:00:48,000
some challenges that we have in the

00:00:45,520 --> 00:00:50,320
javascript industry industry at large

00:00:48,000 --> 00:00:51,920
and one of them is sharing code is hard

00:00:50,320 --> 00:00:54,719
and it gets much harder at scale

00:00:51,920 --> 00:00:55,120
so if we've ever had deal with two apps

00:00:54,719 --> 00:00:56,800
that

00:00:55,120 --> 00:00:58,480
run separately but they need to share

00:00:56,800 --> 00:01:00,160
something uh we'll have probably

00:00:58,480 --> 00:01:03,840
encountered inconvenience

00:01:00,160 --> 00:01:06,159
npm being slow uh the complexity will

00:01:03,840 --> 00:01:06,880
balloon as you need to share more and

00:01:06,159 --> 00:01:08,720
more

00:01:06,880 --> 00:01:10,000
and any sharing that you actually do is

00:01:08,720 --> 00:01:11,520
usually primitive so

00:01:10,000 --> 00:01:13,439
if we look at something like let's say

00:01:11,520 --> 00:01:15,119
externals that's usually the most common

00:01:13,439 --> 00:01:18,720
way to like share something

00:01:15,119 --> 00:01:22,080
um externals is very

00:01:18,720 --> 00:01:23,439
primitive in in the way that it does it

00:01:22,080 --> 00:01:25,119
because you're very much locked into

00:01:23,439 --> 00:01:28,240
like that top level request

00:01:25,119 --> 00:01:31,680
or um or you just have to do it all

00:01:28,240 --> 00:01:35,119
by hand and uh it's

00:01:31,680 --> 00:01:37,280
at the end of the day not scalable

00:01:35,119 --> 00:01:38,320
the motivation behind module federation

00:01:37,280 --> 00:01:41,680
was really from mid

00:01:38,320 --> 00:01:44,240
to large-scale platforms or businesses

00:01:41,680 --> 00:01:45,119
some a company that really can't operate

00:01:44,240 --> 00:01:47,920
as a monolith

00:01:45,119 --> 00:01:49,439
and just has tons of independent

00:01:47,920 --> 00:01:51,759
applications or the need for

00:01:49,439 --> 00:01:52,799
applications to run stand-alone but also

00:01:51,759 --> 00:01:55,920
run together

00:01:52,799 --> 00:01:57,520
as if they were in a monolithic compiled

00:01:55,920 --> 00:01:59,360
system

00:01:57,520 --> 00:02:00,719
obviously multiple teams looking for

00:01:59,360 --> 00:02:03,200
autonomous workflows

00:02:00,719 --> 00:02:05,040
and a big goal behind module failuration

00:02:03,200 --> 00:02:06,399
was to try and avoid learning curves i

00:02:05,040 --> 00:02:08,640
don't really want you to change your

00:02:06,399 --> 00:02:10,879
development patterns when

00:02:08,640 --> 00:02:12,000
you are using a federated application or

00:02:10,879 --> 00:02:14,879
when you're creating one

00:02:12,000 --> 00:02:14,879
sharing resources

00:02:15,120 --> 00:02:19,760
and some of the other things we want to

00:02:17,280 --> 00:02:22,160
really focus on here is avoiding

00:02:19,760 --> 00:02:24,160
multiple copies of the same library want

00:02:22,160 --> 00:02:25,520
to share our vendor code but still stay

00:02:24,160 --> 00:02:27,760
flexible

00:02:25,520 --> 00:02:29,120
we don't want to have ux drawbacks like

00:02:27,760 --> 00:02:32,480
a full page reflect

00:02:29,120 --> 00:02:34,879
refresh or you know really large

00:02:32,480 --> 00:02:36,560
library downloads because it's

00:02:34,879 --> 00:02:37,840
downloading a whole nother bundle

00:02:36,560 --> 00:02:39,760
and i really don't want to have to

00:02:37,840 --> 00:02:43,760
depend on ci

00:02:39,760 --> 00:02:43,760
to pull together my system

00:02:43,920 --> 00:02:47,920
so let's set a little bit of context

00:02:45,599 --> 00:02:49,599
here um

00:02:47,920 --> 00:02:52,239
we have let's say we have some kind of

00:02:49,599 --> 00:02:55,280
an app that looks something like this

00:02:52,239 --> 00:02:58,879
and i want to

00:02:55,280 --> 00:03:01,760
say let's say each part of these squares

00:02:58,879 --> 00:03:03,519
is a separate federated app or even just

00:03:01,760 --> 00:03:06,000
the colors are separately federated

00:03:03,519 --> 00:03:07,280
you'd have an app made have a header

00:03:06,000 --> 00:03:09,599
dashboard profile

00:03:07,280 --> 00:03:11,280
some pages a sidebar style guide

00:03:09,599 --> 00:03:13,120
components which is maybe in another

00:03:11,280 --> 00:03:15,040
repo deployed on its own

00:03:13,120 --> 00:03:16,319
and data fetching logic which also might

00:03:15,040 --> 00:03:19,840
be in another repo or

00:03:16,319 --> 00:03:22,000
deployed somewhere else and

00:03:19,840 --> 00:03:23,280
the idea is we want to be able to split

00:03:22,000 --> 00:03:25,040
this application in

00:03:23,280 --> 00:03:26,400
various different ways and some of the

00:03:25,040 --> 00:03:27,200
ways that we've outlined here is you've

00:03:26,400 --> 00:03:30,239
got your ui

00:03:27,200 --> 00:03:33,440
you've got styling or you've got

00:03:30,239 --> 00:03:36,640
you know logic and each part should

00:03:33,440 --> 00:03:39,040
ideally in this case be developed by

00:03:36,640 --> 00:03:40,959
a separate team and deployed

00:03:39,040 --> 00:03:41,840
independently so if we look at an app

00:03:40,959 --> 00:03:43,280
like this

00:03:41,840 --> 00:03:45,040
and i want to deploy any of these

00:03:43,280 --> 00:03:46,560
squares independently that starts to get

00:03:45,040 --> 00:03:48,480
a little bit tricky to do

00:03:46,560 --> 00:03:50,080
um and that's really what module

00:03:48,480 --> 00:03:50,879
federation is coming around here to try

00:03:50,080 --> 00:03:53,200
and help us with

00:03:50,879 --> 00:03:54,799
is any of these cubes can be deployed

00:03:53,200 --> 00:03:55,760
independently by another team and they

00:03:54,799 --> 00:03:58,239
can be consumed

00:03:55,760 --> 00:04:01,439
in real time at runtime by any consuming

00:03:58,239 --> 00:04:04,080
application that needs it

00:04:01,439 --> 00:04:06,159
so the problem at a high level is

00:04:04,080 --> 00:04:09,439
nothing really feels smooth

00:04:06,159 --> 00:04:11,840
like we've got something like let's say

00:04:09,439 --> 00:04:12,879
we can create a library the library gets

00:04:11,840 --> 00:04:14,959
split out

00:04:12,879 --> 00:04:16,560
and installed or loaded in you could use

00:04:14,959 --> 00:04:18,799
esi

00:04:16,560 --> 00:04:20,400
or you could use a micro front end and

00:04:18,799 --> 00:04:21,359
route them back into each independent

00:04:20,400 --> 00:04:23,040
app

00:04:21,359 --> 00:04:24,400
but the problem with all these is they

00:04:23,040 --> 00:04:26,479
really require a manual stuff of

00:04:24,400 --> 00:04:28,160
breaking your app apart

00:04:26,479 --> 00:04:29,759
what we're trying to do with say module

00:04:28,160 --> 00:04:32,320
federation here is instead of

00:04:29,759 --> 00:04:33,120
removing pieces of an application we

00:04:32,320 --> 00:04:36,720
actually

00:04:33,120 --> 00:04:40,080
just allow you to import modules from

00:04:36,720 --> 00:04:41,520
a separately compiled app and that's

00:04:40,080 --> 00:04:44,160
really the smoothness that we're trying

00:04:41,520 --> 00:04:46,240
to give and you can kind of do this with

00:04:44,160 --> 00:04:49,120
script loaders or other things today

00:04:46,240 --> 00:04:49,919
um but you lose out on the smoothness

00:04:49,120 --> 00:04:51,520
aspect

00:04:49,919 --> 00:04:53,440
uh you have to learn something new it

00:04:51,520 --> 00:04:55,199
has to be done in a specific way and

00:04:53,440 --> 00:04:56,479
also when the script's loaded doesn't

00:04:55,199 --> 00:04:58,479
necessarily mean that

00:04:56,479 --> 00:05:00,160
the webpack is actually done running and

00:04:58,479 --> 00:05:01,759
making those modules available

00:05:00,160 --> 00:05:03,360
so it does get a little tricky if you're

00:05:01,759 --> 00:05:07,199
trying to do sophisticated

00:05:03,360 --> 00:05:09,759
code sharing like systems

00:05:07,199 --> 00:05:11,039
they're also usually quite brittle

00:05:09,759 --> 00:05:13,600
they're hard to roll out

00:05:11,039 --> 00:05:14,720
and especially when it comes to shared

00:05:13,600 --> 00:05:16,780
dependency updates

00:05:14,720 --> 00:05:18,240
if you say used

00:05:16,780 --> 00:05:19,840
[Music]

00:05:18,240 --> 00:05:21,199
one of these solutions for say your

00:05:19,840 --> 00:05:23,039
microphone ends and you don't want to

00:05:21,199 --> 00:05:25,360
share react among them all

00:05:23,039 --> 00:05:26,080
you could make react a global or an

00:05:25,360 --> 00:05:27,840
external

00:05:26,080 --> 00:05:30,080
but soon as you do that how do you

00:05:27,840 --> 00:05:31,520
upgrade react what happens if the rest

00:05:30,080 --> 00:05:32,639
of the company isn't ready to upgrade

00:05:31,520 --> 00:05:35,360
react

00:05:32,639 --> 00:05:36,960
it's very tedious everyone has to be

00:05:35,360 --> 00:05:39,120
ready for the update to flip

00:05:36,960 --> 00:05:40,960
at exactly the same time so it's still

00:05:39,120 --> 00:05:42,479
not giving us that flexibility that that

00:05:40,960 --> 00:05:45,120
we're quite after

00:05:42,479 --> 00:05:46,960
um and of course you know ux is also

00:05:45,120 --> 00:05:49,440
often impacted just because you're

00:05:46,960 --> 00:05:50,639
forcing the guests to download more data

00:05:49,440 --> 00:05:53,919
more

00:05:50,639 --> 00:05:56,400
javascript or um

00:05:53,919 --> 00:05:58,240
in general how it usually looks is you

00:05:56,400 --> 00:05:59,840
know there's a page refresh in between

00:05:58,240 --> 00:06:01,360
or you're downloading an entirely

00:05:59,840 --> 00:06:02,720
separate single page app and just

00:06:01,360 --> 00:06:05,600
booting it in div

00:06:02,720 --> 00:06:08,720
on a current page which all leads to a

00:06:05,600 --> 00:06:10,800
slower delay to the guest

00:06:08,720 --> 00:06:12,800
we also usually see a lot of code

00:06:10,800 --> 00:06:14,960
duplication and that's mostly because

00:06:12,800 --> 00:06:17,759
um any of the things that we do we

00:06:14,960 --> 00:06:20,960
typically revolve around some form of

00:06:17,759 --> 00:06:22,800
manual process like externals so trying

00:06:20,960 --> 00:06:25,039
to remove that duplication

00:06:22,800 --> 00:06:26,400
the algorithm only does such a good job

00:06:25,039 --> 00:06:29,440
internally and

00:06:26,400 --> 00:06:29,440
it's also very

00:06:29,840 --> 00:06:35,039
manually managed so there's always

00:06:33,120 --> 00:06:36,319
code duplication that we'll usually see

00:06:35,039 --> 00:06:38,000
sneak into these things

00:06:36,319 --> 00:06:39,280
if you built out an in-house solution

00:06:38,000 --> 00:06:41,039
that kind of loading these scripts are

00:06:39,280 --> 00:06:41,680
giving you this kind of micro front-end

00:06:41,039 --> 00:06:44,800
feel

00:06:41,680 --> 00:06:48,000
it's most usually quite complex um and

00:06:44,800 --> 00:06:50,479
also requires this continued maintenance

00:06:48,000 --> 00:06:52,080
and when we get to ssr it's usually an

00:06:50,479 --> 00:06:54,560
even bigger nightmare to deal with when

00:06:52,080 --> 00:06:55,840
we're talking about things at runtime

00:06:54,560 --> 00:06:57,520
so we're going to take a quick look at

00:06:55,840 --> 00:06:59,039
our existing options here we've got

00:06:57,520 --> 00:07:00,800
native esm

00:06:59,039 --> 00:07:02,800
some of the bonuses or just the facts of

00:07:00,800 --> 00:07:05,120
it is there's no build to link parts

00:07:02,800 --> 00:07:06,880
foreign code is natively consumable but

00:07:05,120 --> 00:07:08,800
on the flip side there's no tree shaking

00:07:06,880 --> 00:07:10,560
it only works with the esm

00:07:08,800 --> 00:07:13,280
so we can't get anything like side

00:07:10,560 --> 00:07:16,800
effects styles or assets to be

00:07:13,280 --> 00:07:20,319
optimized and rooted through through esm

00:07:16,800 --> 00:07:23,120
uh and the there's some performance

00:07:20,319 --> 00:07:24,560
issues with it pre-loading has to be

00:07:23,120 --> 00:07:28,319
required there's a high

00:07:24,560 --> 00:07:30,160
rtt and you make a lot of requests

00:07:28,319 --> 00:07:31,520
if we look at the single build which is

00:07:30,160 --> 00:07:32,960
just a normal monolith

00:07:31,520 --> 00:07:34,720
everything's built together which is

00:07:32,960 --> 00:07:36,000
great foreign modules are accessible

00:07:34,720 --> 00:07:38,000
during the build so

00:07:36,000 --> 00:07:40,000
while i'm compiling it i could reach out

00:07:38,000 --> 00:07:42,960
and grab foreign modules

00:07:40,000 --> 00:07:44,960
but that doesn't help me at runtime and

00:07:42,960 --> 00:07:45,440
would still require a full rebuild to

00:07:44,960 --> 00:07:48,160
get

00:07:45,440 --> 00:07:49,280
any module that you want into the system

00:07:48,160 --> 00:07:52,240
um

00:07:49,280 --> 00:07:53,759
the big down draws of our usual single

00:07:52,240 --> 00:07:55,759
monolithic builds is

00:07:53,759 --> 00:07:58,000
any change would require a full full

00:07:55,759 --> 00:08:00,639
deploy the builds get slower

00:07:58,000 --> 00:08:02,000
and they get bottlenecked by teams and

00:08:00,639 --> 00:08:05,039
build pipelines

00:08:02,000 --> 00:08:07,919
and you know deployment priorities

00:08:05,039 --> 00:08:09,919
we have uh multiple apps which they

00:08:07,919 --> 00:08:10,960
can't really be separate so you kind of

00:08:09,919 --> 00:08:13,360
sacrifice this

00:08:10,960 --> 00:08:14,000
shared system at runtime it's

00:08:13,360 --> 00:08:16,960
essentially

00:08:14,000 --> 00:08:18,800
turning you know your normal monolith if

00:08:16,960 --> 00:08:21,039
we look at externals

00:08:18,800 --> 00:08:23,440
parts and when i say parts here i really

00:08:21,039 --> 00:08:26,319
mean like pieces of

00:08:23,440 --> 00:08:27,120
a application um a header could be a

00:08:26,319 --> 00:08:29,599
part

00:08:27,120 --> 00:08:31,120
um you know something like that it's

00:08:29,599 --> 00:08:34,560
kind of what we consider a part or

00:08:31,120 --> 00:08:34,560
separately coded by another team

00:08:34,719 --> 00:08:38,479
parts are you know built separately and

00:08:36,880 --> 00:08:40,719
exposed globally

00:08:38,479 --> 00:08:43,039
which is kind of what we've been using

00:08:40,719 --> 00:08:46,399
for several years with webpack for

00:08:43,039 --> 00:08:49,680
to do something like this uh our apps

00:08:46,399 --> 00:08:50,959
can pretty much be are built to depend

00:08:49,680 --> 00:08:53,680
on externals

00:08:50,959 --> 00:08:55,760
um the ones you have with that is it's

00:08:53,680 --> 00:08:56,240
not really a self-running app as soon as

00:08:55,760 --> 00:08:58,000
you

00:08:56,240 --> 00:09:00,000
introduce externals you introduce

00:08:58,000 --> 00:09:02,800
another file that has to be there

00:09:00,000 --> 00:09:03,360
that if it's not there your app will not

00:09:02,800 --> 00:09:05,279
run

00:09:03,360 --> 00:09:06,640
and it also introduces a central point

00:09:05,279 --> 00:09:09,120
of failure

00:09:06,640 --> 00:09:10,399
some of the downdraws of externals is

00:09:09,120 --> 00:09:11,760
there's no on-demand loading

00:09:10,399 --> 00:09:13,440
capabilities

00:09:11,760 --> 00:09:16,000
uh additional libraries have to be

00:09:13,440 --> 00:09:19,440
created it's not very flexible

00:09:16,000 --> 00:09:22,160
and it's very dependent on external code

00:09:19,440 --> 00:09:24,000
no failsafe we take a look at dll

00:09:22,160 --> 00:09:25,360
plug-in this was a kind of a step in the

00:09:24,000 --> 00:09:26,160
right direction but still not quite

00:09:25,360 --> 00:09:29,760
there

00:09:26,160 --> 00:09:32,240
parts of the parts are built out as dlls

00:09:29,760 --> 00:09:34,000
and the app is built to depend on these

00:09:32,240 --> 00:09:36,720
dlls

00:09:34,000 --> 00:09:38,720
you need to rebuild when parts change

00:09:36,720 --> 00:09:40,720
which can introduce deploy delays

00:09:38,720 --> 00:09:42,880
you need additional dlls to be created

00:09:40,720 --> 00:09:44,399
the whole time and you also need extra

00:09:42,880 --> 00:09:47,519
infrastructure for

00:09:44,399 --> 00:09:49,920
the compile time dependencies

00:09:47,519 --> 00:09:52,240
and yeah again highly dependent on

00:09:49,920 --> 00:09:55,440
external code

00:09:52,240 --> 00:09:56,880
so what we kind of rule out here is

00:09:55,440 --> 00:09:58,640
native esm isn't great for web

00:09:56,880 --> 00:09:59,519
performance a single build is really not

00:09:58,640 --> 00:10:02,480
great for build

00:09:59,519 --> 00:10:04,000
performance and dll or externals is too

00:10:02,480 --> 00:10:07,839
much manual work to actually

00:10:04,000 --> 00:10:09,360
be a real solution

00:10:07,839 --> 00:10:11,200
so what we were looking for is something

00:10:09,360 --> 00:10:12,000
with goodwill build performance good web

00:10:11,200 --> 00:10:14,160
performance

00:10:12,000 --> 00:10:16,880
and a solution to sharing our

00:10:14,160 --> 00:10:20,000
dependencies

00:10:16,880 --> 00:10:21,600
introducing module federation and i

00:10:20,000 --> 00:10:24,480
would say module federation is

00:10:21,600 --> 00:10:27,680
inevitability it is where we are going

00:10:24,480 --> 00:10:30,160
um whether we like it or not the

00:10:27,680 --> 00:10:31,120
this kind of model is just something

00:10:30,160 --> 00:10:33,200
that

00:10:31,120 --> 00:10:35,600
i believe is really the next step in

00:10:33,200 --> 00:10:36,720
javascript architecture

00:10:35,600 --> 00:10:38,640
so let's get down some of the

00:10:36,720 --> 00:10:39,440
terminology module federation it's

00:10:38,640 --> 00:10:42,240
essentially

00:10:39,440 --> 00:10:43,519
uh got it got its name from apollo's

00:10:42,240 --> 00:10:44,880
graphql federation

00:10:43,519 --> 00:10:47,600
mostly because everybody would kind of

00:10:44,880 --> 00:10:50,640
understand what that meant um

00:10:47,600 --> 00:10:52,480
it's it's like a apollo's graph

00:10:50,640 --> 00:10:53,760
federation but it's applied to your

00:10:52,480 --> 00:10:55,600
javascript modules

00:10:53,760 --> 00:10:56,959
and it will work in the browser or in

00:10:55,600 --> 00:10:59,440
node.js which means

00:10:56,959 --> 00:11:00,640
this is a universal system it's not

00:10:59,440 --> 00:11:02,240
about uh

00:11:00,640 --> 00:11:04,480
running browser specific or server

00:11:02,240 --> 00:11:06,880
specific anything that runs the

00:11:04,480 --> 00:11:07,680
javascript runtime environment can

00:11:06,880 --> 00:11:11,040
essentially

00:11:07,680 --> 00:11:12,640
use federation so

00:11:11,040 --> 00:11:14,240
we have a couple other things that we

00:11:12,640 --> 00:11:16,320
refer to in

00:11:14,240 --> 00:11:18,320
a federated app these are kind of

00:11:16,320 --> 00:11:20,320
standard terminologies we use at webpack

00:11:18,320 --> 00:11:23,120
and i use in everything that i do

00:11:20,320 --> 00:11:24,320
we have something called a host so a

00:11:23,120 --> 00:11:27,200
host is essentially

00:11:24,320 --> 00:11:28,959
the first webpack runtime that gets

00:11:27,200 --> 00:11:30,240
initialized on the page so if you had a

00:11:28,959 --> 00:11:32,160
micro front-end stack

00:11:30,240 --> 00:11:33,519
and you had a home page an about page

00:11:32,160 --> 00:11:35,279
something else and all those pages

00:11:33,519 --> 00:11:38,079
really were on separate uh

00:11:35,279 --> 00:11:39,680
note services or or separately built

00:11:38,079 --> 00:11:42,000
apps like microphones

00:11:39,680 --> 00:11:42,959
then the host would be whatever page you

00:11:42,000 --> 00:11:45,200
land on

00:11:42,959 --> 00:11:46,000
um so if i landed on the home micro

00:11:45,200 --> 00:11:49,120
front end

00:11:46,000 --> 00:11:50,800
then the first you know webpack app that

00:11:49,120 --> 00:11:51,519
is going to be there is obviously the

00:11:50,800 --> 00:11:55,680
home

00:11:51,519 --> 00:11:57,440
app so we call that the host

00:11:55,680 --> 00:11:59,120
if i flip to another page and do a page

00:11:57,440 --> 00:12:00,639
reload and that other page is a separate

00:11:59,120 --> 00:12:02,639
build then that page would become the

00:12:00,639 --> 00:12:05,839
host so the host is really not

00:12:02,639 --> 00:12:08,399
dependent on any build it's dependent on

00:12:05,839 --> 00:12:10,399
which which app are you in which one

00:12:08,399 --> 00:12:12,560
runs first

00:12:10,399 --> 00:12:14,160
um so yeah so that's pretty much what we

00:12:12,560 --> 00:12:15,920
would call a host

00:12:14,160 --> 00:12:18,240
then we have something called a remote

00:12:15,920 --> 00:12:20,800
and the remote is essentially

00:12:18,240 --> 00:12:21,839
these other color components in here

00:12:20,800 --> 00:12:25,279
which are being

00:12:21,839 --> 00:12:28,000
pulled in from a remote location um

00:12:25,279 --> 00:12:29,600
we have what we kind of call a remote

00:12:28,000 --> 00:12:31,680
container or under the hood and webpack

00:12:29,600 --> 00:12:35,120
it's called a container

00:12:31,680 --> 00:12:38,079
and what a host is

00:12:35,120 --> 00:12:39,839
doing is essentially attaching itself to

00:12:38,079 --> 00:12:40,399
these remote modules and then pulling

00:12:39,839 --> 00:12:43,120
them in

00:12:40,399 --> 00:12:43,440
so the remote is essentially not this

00:12:43,120 --> 00:12:44,639
thing

00:12:43,440 --> 00:12:46,880
it's the stuff that you're going to get

00:12:44,639 --> 00:12:48,560
from another team's build that's what we

00:12:46,880 --> 00:12:49,519
refer to it as

00:12:48,560 --> 00:12:51,680
then we have something called

00:12:49,519 --> 00:12:53,760
bi-directional host so

00:12:51,680 --> 00:12:55,839
what this pretty much means is that it

00:12:53,760 --> 00:12:58,720
can be both a host or remote

00:12:55,839 --> 00:12:59,360
or it can operate in either mode um if

00:12:58,720 --> 00:13:01,279
you think

00:12:59,360 --> 00:13:03,200
if we compare this to like some older

00:13:01,279 --> 00:13:05,600
tactics at webpack let's say

00:13:03,200 --> 00:13:07,920
you create a library uh if you create a

00:13:05,600 --> 00:13:09,839
library then your build is library

00:13:07,920 --> 00:13:11,760
and if you wanted to create another

00:13:09,839 --> 00:13:13,839
build um to make it like a single page

00:13:11,760 --> 00:13:16,000
app or something that starts itself

00:13:13,839 --> 00:13:17,360
you would have to create another webpack

00:13:16,000 --> 00:13:19,920
target and build that

00:13:17,360 --> 00:13:21,360
so in this scenario module federation

00:13:19,920 --> 00:13:23,040
you don't change anything about your

00:13:21,360 --> 00:13:25,839
build other than using the plugin

00:13:23,040 --> 00:13:27,839
but it can operate in both host or

00:13:25,839 --> 00:13:31,040
remote mode which means that it can

00:13:27,839 --> 00:13:32,959
run standalone and as you can see here i

00:13:31,040 --> 00:13:34,880
would have two separate host apps

00:13:32,959 --> 00:13:36,800
and as you can see from the interchange

00:13:34,880 --> 00:13:38,240
of the arrows we're essentially pulling

00:13:36,800 --> 00:13:40,720
in different components

00:13:38,240 --> 00:13:41,519
from two different live hosts and

00:13:40,720 --> 00:13:46,000
consuming them

00:13:41,519 --> 00:13:48,079
in different ways on each of the hosts

00:13:46,000 --> 00:13:49,839
so then we get into what was kind of

00:13:48,079 --> 00:13:51,680
like the biggest step forward in module

00:13:49,839 --> 00:13:52,560
federation and this came out around beta

00:13:51,680 --> 00:13:54,639
00:13:52,560 --> 00:13:56,399
um and this is the concept of an

00:13:54,639 --> 00:13:59,600
omnidirectional host

00:13:56,399 --> 00:14:01,519
so what this ends up becoming is

00:13:59,600 --> 00:14:03,440
essentially we've got you know three

00:14:01,519 --> 00:14:05,600
hosts or whatever here

00:14:03,440 --> 00:14:08,399
but then all of the dependencies are

00:14:05,600 --> 00:14:11,040
essentially in this little grouping here

00:14:08,399 --> 00:14:12,240
and what it makes everything or what it

00:14:11,040 --> 00:14:15,680
makes everything do is

00:14:12,240 --> 00:14:18,560
they all essentially will act as

00:14:15,680 --> 00:14:20,079
both a remote and a host at once so when

00:14:18,560 --> 00:14:21,920
the host starts itself

00:14:20,079 --> 00:14:23,600
it's only partially aware that it's the

00:14:21,920 --> 00:14:27,120
host application

00:14:23,600 --> 00:14:28,480
but it only after the webpack runtime

00:14:27,120 --> 00:14:30,880
boots and runs does it

00:14:28,480 --> 00:14:33,440
actually figure out what it is so it's

00:14:30,880 --> 00:14:37,120
operating in this omnidirectional mode

00:14:33,440 --> 00:14:40,079
what ability this gives us is that um

00:14:37,120 --> 00:14:41,760
i can use semantic versioning here which

00:14:40,079 --> 00:14:44,320
we have built into module federation and

00:14:41,760 --> 00:14:47,680
it reads it off the installed module

00:14:44,320 --> 00:14:49,120
in your node modules directory and uh i

00:14:47,680 --> 00:14:51,519
could have

00:14:49,120 --> 00:14:53,600
you know let's say i've got a a patch

00:14:51,519 --> 00:14:55,360
version of react a newer patch version

00:14:53,600 --> 00:14:58,320
of react and

00:14:55,360 --> 00:14:59,680
you know a really old copy of react like

00:14:58,320 --> 00:15:02,880
react 15.

00:14:59,680 --> 00:15:05,760
what would happen is where the runtimes

00:15:02,880 --> 00:15:07,360
would essentially negotiate between each

00:15:05,760 --> 00:15:07,839
other before actually kick-starting the

00:15:07,360 --> 00:15:09,760
app

00:15:07,839 --> 00:15:10,959
and figure out who has the best copy of

00:15:09,760 --> 00:15:12,639
react to run

00:15:10,959 --> 00:15:14,079
so if this one's a patch version off

00:15:12,639 --> 00:15:15,839
from that one

00:15:14,079 --> 00:15:17,279
semantic versioning rules would dictate

00:15:15,839 --> 00:15:19,600
webpack will consume

00:15:17,279 --> 00:15:21,519
this one's version of react even if this

00:15:19,600 --> 00:15:23,199
one is the host that i'm visiting

00:15:21,519 --> 00:15:25,279
so we'll just get this module but

00:15:23,199 --> 00:15:27,199
they'll all communicate all these remote

00:15:25,279 --> 00:15:29,120
pieces will communicate in here

00:15:27,199 --> 00:15:31,120
understand who has the best version of

00:15:29,120 --> 00:15:34,079
react for our semantic versioning

00:15:31,120 --> 00:15:35,839
and then they will depend on that copy

00:15:34,079 --> 00:15:38,160
and if something were to go wrong

00:15:35,839 --> 00:15:40,560
in that this mechanism also offers us

00:15:38,160 --> 00:15:42,000
the ability to fall back so if we have a

00:15:40,560 --> 00:15:43,759
missing dependency or for whatever

00:15:42,000 --> 00:15:45,680
reason we can't get it

00:15:43,759 --> 00:15:46,959
we can query anybody else connected to

00:15:45,680 --> 00:15:49,360
our network and ask

00:15:46,959 --> 00:15:51,279
them to please vend this missing file

00:15:49,360 --> 00:15:53,199
module or dependency that another

00:15:51,279 --> 00:15:54,560
application needs

00:15:53,199 --> 00:15:56,560
in the case here was let's say this is

00:15:54,560 --> 00:15:57,680
react 15 and we have two different react

00:15:56,560 --> 00:16:00,079
16s that are

00:15:57,680 --> 00:16:01,440
you know going to be using the latest

00:16:00,079 --> 00:16:04,639
patch version

00:16:01,440 --> 00:16:07,279
what happens to react 15 over here well

00:16:04,639 --> 00:16:08,000
we can create separate share scopes

00:16:07,279 --> 00:16:10,959
within here

00:16:08,000 --> 00:16:12,240
and we could have a react 15 host with

00:16:10,959 --> 00:16:14,880
the react 16

00:16:12,240 --> 00:16:15,839
remote component with say hooks in it

00:16:14,880 --> 00:16:19,279
and it would work

00:16:15,839 --> 00:16:20,639
in this setup um through a couple

00:16:19,279 --> 00:16:22,320
things that we've kind of developed one

00:16:20,639 --> 00:16:24,399
of them is an adapter pattern that we

00:16:22,320 --> 00:16:26,399
manually implement but the mechanisms

00:16:24,399 --> 00:16:29,680
are there to allow us to

00:16:26,399 --> 00:16:29,680
create systems like this

00:16:30,160 --> 00:16:35,759
so what is module federation exactly

00:16:33,759 --> 00:16:36,959
it allows us to import code from other

00:16:35,759 --> 00:16:38,959
builds at runtime

00:16:36,959 --> 00:16:40,160
we can share our vendor code dynamically

00:16:38,959 --> 00:16:42,000
at runtime

00:16:40,160 --> 00:16:43,680
we can deploy independent single page

00:16:42,000 --> 00:16:44,880
apps without needing to redeploy their

00:16:43,680 --> 00:16:47,040
consumers

00:16:44,880 --> 00:16:50,160
we have redundancy and self-healing

00:16:47,040 --> 00:16:53,519
capabilities built into the architecture

00:16:50,160 --> 00:16:56,079
that's essentially the sum up of it

00:16:53,519 --> 00:16:56,720
microfrontends will work like a monolith

00:16:56,079 --> 00:16:58,320
which is

00:16:56,720 --> 00:16:59,680
really really awesome and also this

00:16:58,320 --> 00:17:00,639
solves a lot of issues with server-side

00:16:59,680 --> 00:17:04,559
rendering

00:17:00,639 --> 00:17:06,720
the developer experience is

00:17:04,559 --> 00:17:08,160
improved without compromising our users

00:17:06,720 --> 00:17:10,799
experience

00:17:08,160 --> 00:17:11,919
we also can get evergreen code directly

00:17:10,799 --> 00:17:14,319
from

00:17:11,919 --> 00:17:16,240
each separate build and of course this

00:17:14,319 --> 00:17:16,640
will work in any javascript environment

00:17:16,240 --> 00:17:18,720
which

00:17:16,640 --> 00:17:22,079
makes it very flexible and very easy to

00:17:18,720 --> 00:17:23,600
handle universal applications

00:17:22,079 --> 00:17:25,919
one big thing to call out though module

00:17:23,600 --> 00:17:28,160
federation is not a framework this is a

00:17:25,919 --> 00:17:30,559
this is a piece of webpack that we

00:17:28,160 --> 00:17:33,760
re-architected and redesigned

00:17:30,559 --> 00:17:35,919
and as such it does not do

00:17:33,760 --> 00:17:38,000
any implementation details handling for

00:17:35,919 --> 00:17:40,000
you you need to handle

00:17:38,000 --> 00:17:42,320
whatever you want it to do it gives you

00:17:40,000 --> 00:17:45,679
the ability to require code from

00:17:42,320 --> 00:17:49,520
over-the-wire locations or other builds

00:17:45,679 --> 00:17:52,240
but if you want a framework around it

00:17:49,520 --> 00:17:52,799
you could use something like single spa

00:17:52,240 --> 00:17:54,880
or

00:17:52,799 --> 00:17:56,720
next js which is busy moving to module

00:17:54,880 --> 00:17:59,360
federation or next js which

00:17:56,720 --> 00:18:01,440
with next 10 will be supporting and

00:17:59,360 --> 00:18:03,120
leveraging model federation

00:18:01,440 --> 00:18:04,640
um we will see this coming to angular

00:18:03,120 --> 00:18:07,200
cli pretty soon and i know

00:18:04,640 --> 00:18:08,480
uh jupiter lab already is using this as

00:18:07,200 --> 00:18:10,480
well as storybook is starting to

00:18:08,480 --> 00:18:12,480
experiment with it but

00:18:10,480 --> 00:18:13,600
you know essentially the open source

00:18:12,480 --> 00:18:15,919
projects will

00:18:13,600 --> 00:18:19,039
fill in the framework misses that the

00:18:15,919 --> 00:18:21,120
new capability has

00:18:19,039 --> 00:18:22,960
so looking a little deeper into module

00:18:21,120 --> 00:18:24,559
federation here

00:18:22,960 --> 00:18:28,160
as you can see i touched on it briefly

00:18:24,559 --> 00:18:31,520
before with our host remote setup but

00:18:28,160 --> 00:18:34,240
each app is essentially a separate

00:18:31,520 --> 00:18:35,840
application we have the actual host app

00:18:34,240 --> 00:18:38,720
this is the one that's going to be

00:18:35,840 --> 00:18:40,840
initialized and running it depends on a

00:18:38,720 --> 00:18:43,520
remote container

00:18:40,840 --> 00:18:45,919
which could also be a host

00:18:43,520 --> 00:18:47,039
and this container is depending on a

00:18:45,919 --> 00:18:49,840
nested

00:18:47,039 --> 00:18:51,200
remote so by using this i need to also

00:18:49,840 --> 00:18:53,760
get this

00:18:51,200 --> 00:18:54,880
one of the nice things is webpack the

00:18:53,760 --> 00:18:58,240
way we've designed

00:18:54,880 --> 00:19:01,280
this runtime is

00:18:58,240 --> 00:19:04,240
you don't pay for the rtt so

00:19:01,280 --> 00:19:05,200
when host app one runs and we need

00:19:04,240 --> 00:19:07,360
chunks from here

00:19:05,200 --> 00:19:08,799
or chunks from here those are all done

00:19:07,360 --> 00:19:10,320
in parallel up front

00:19:08,799 --> 00:19:12,240
so as soon as the app boots it knows

00:19:10,320 --> 00:19:12,880
what it needs and it goes and fetches it

00:19:12,240 --> 00:19:14,880
it's not

00:19:12,880 --> 00:19:17,360
discovering them as you go through the

00:19:14,880 --> 00:19:17,840
application so our rtt is really just

00:19:17,360 --> 00:19:19,360
one

00:19:17,840 --> 00:19:21,840
and everything's delivered in a single

00:19:19,360 --> 00:19:21,840
round trip

00:19:23,120 --> 00:19:26,799
so going into a bit more of an example

00:19:25,200 --> 00:19:30,240
here uh let's say we've got

00:19:26,799 --> 00:19:31,760
team a b and some dependencies so team a

00:19:30,240 --> 00:19:34,000
is our application and we're looking at

00:19:31,760 --> 00:19:35,360
this from like a single build view

00:19:34,000 --> 00:19:38,160
and what we're essentially doing is

00:19:35,360 --> 00:19:41,280
we're going to load cro load code across

00:19:38,160 --> 00:19:42,400
teams a and b so team a has an app they

00:19:41,280 --> 00:19:45,919
have a home page

00:19:42,400 --> 00:19:49,360
that home page uses team b's drop down

00:19:45,919 --> 00:19:51,120
and team b's drop down has a natural

00:19:49,360 --> 00:19:53,520
dependence on the arrow icon because

00:19:51,120 --> 00:19:55,360
it's part of the component

00:19:53,520 --> 00:19:57,600
and the drop down itself depends on

00:19:55,360 --> 00:19:59,360
react the home page depends on react

00:19:57,600 --> 00:20:01,120
this login modal which is you know

00:19:59,360 --> 00:20:04,320
dynamically imported

00:20:01,120 --> 00:20:06,000
it depends on you know the component and

00:20:04,320 --> 00:20:07,679
this component actually depends on a

00:20:06,000 --> 00:20:09,840
button from team b

00:20:07,679 --> 00:20:11,120
which all of them depend on react so

00:20:09,840 --> 00:20:11,760
that's kind of what a graph would look

00:20:11,120 --> 00:20:13,760
like from

00:20:11,760 --> 00:20:16,720
team a's perspective they're consuming

00:20:13,760 --> 00:20:19,200
pieces from team b

00:20:16,720 --> 00:20:22,000
now if we look at team b's perspective

00:20:19,200 --> 00:20:24,720
on this they're going to expose

00:20:22,000 --> 00:20:26,799
button and drop down they don't need to

00:20:24,720 --> 00:20:28,559
expose arrow icon because this module

00:20:26,799 --> 00:20:29,440
already requires it and we can look up

00:20:28,559 --> 00:20:31,280
what other dependents

00:20:29,440 --> 00:20:33,039
has inside a webpack and webpack will

00:20:31,280 --> 00:20:35,679
resolve it correctly and get

00:20:33,039 --> 00:20:37,280
the modules that are required for it uh

00:20:35,679 --> 00:20:39,600
and then of course we would mark react

00:20:37,280 --> 00:20:42,400
as shared in other words we intend to

00:20:39,600 --> 00:20:43,120
use the same version or share the same

00:20:42,400 --> 00:20:44,640
or share

00:20:43,120 --> 00:20:48,240
our react version with other

00:20:44,640 --> 00:20:49,760
applications and this is how we prevent

00:20:48,240 --> 00:20:51,679
multiple versions of react errors from

00:20:49,760 --> 00:20:52,080
popping up and it's also how we reduce

00:20:51,679 --> 00:20:54,640
the

00:20:52,080 --> 00:20:57,120
download effort or the the payload that

00:20:54,640 --> 00:20:59,280
you need to download for the user

00:20:57,120 --> 00:21:00,880
so if we start to dig a little deeper

00:20:59,280 --> 00:21:02,640
into the webpack architecture

00:21:00,880 --> 00:21:04,240
what we've got is container reference

00:21:02,640 --> 00:21:05,360
and so container reference is really

00:21:04,240 --> 00:21:08,400
what a host app

00:21:05,360 --> 00:21:08,640
uses um when you import some code from

00:21:08,400 --> 00:21:11,120
us

00:21:08,640 --> 00:21:12,480
our syntax is literally import and it

00:21:11,120 --> 00:21:15,520
can be uh require

00:21:12,480 --> 00:21:16,159
dynamic import or just import from and

00:21:15,520 --> 00:21:19,840
you would go

00:21:16,159 --> 00:21:23,360
import you know whatever from

00:21:19,840 --> 00:21:27,600
and it would be app one slash

00:21:23,360 --> 00:21:30,000
drop down uh or whatever you want

00:21:27,600 --> 00:21:31,600
and when we do that import on the host

00:21:30,000 --> 00:21:32,720
side seeing as there's no module that

00:21:31,600 --> 00:21:33,760
exists because this is all done at

00:21:32,720 --> 00:21:37,120
runtime

00:21:33,760 --> 00:21:39,200
the the host needs to still return a

00:21:37,120 --> 00:21:39,919
module to webpack so that it doesn't

00:21:39,200 --> 00:21:41,840
fail

00:21:39,919 --> 00:21:43,520
so what we create is the container

00:21:41,840 --> 00:21:45,679
reference plugin

00:21:43,520 --> 00:21:47,280
so what this ends up doing is from this

00:21:45,679 --> 00:21:48,880
team in here when i'm going into the

00:21:47,280 --> 00:21:50,640
home page

00:21:48,880 --> 00:21:52,080
and i'm going to go and get this drop

00:21:50,640 --> 00:21:55,039
down remote

00:21:52,080 --> 00:21:55,600
you'll see first i have these dotted

00:21:55,039 --> 00:21:57,280
lines

00:21:55,600 --> 00:21:59,760
here and here and you'll see how my

00:21:57,280 --> 00:22:01,120
arrows are pointing to specific dotted

00:21:59,760 --> 00:22:02,640
lines

00:22:01,120 --> 00:22:04,400
the reason that we have this kind of

00:22:02,640 --> 00:22:06,799
setup here is to showcase

00:22:04,400 --> 00:22:07,679
um how we're able to give you

00:22:06,799 --> 00:22:11,039
synchronous

00:22:07,679 --> 00:22:12,880
imports in an async application so if i

00:22:11,039 --> 00:22:14,480
want hooks it's a really challenging

00:22:12,880 --> 00:22:16,240
thing for me to grab hooks

00:22:14,480 --> 00:22:17,520
in a dynamic import because they need to

00:22:16,240 --> 00:22:18,640
already be there and i can't do that

00:22:17,520 --> 00:22:20,080
inside of a component because the

00:22:18,640 --> 00:22:22,640
component's already running

00:22:20,080 --> 00:22:23,919
so i could use a normal synchronous

00:22:22,640 --> 00:22:26,080
import from

00:22:23,919 --> 00:22:27,760
and what would end up happening here is

00:22:26,080 --> 00:22:29,039
you'll see uh the container reference

00:22:27,760 --> 00:22:31,280
will create

00:22:29,039 --> 00:22:33,360
some kind of a drop-down remote or we

00:22:31,280 --> 00:22:35,600
call them a remote module

00:22:33,360 --> 00:22:37,919
inside of the host and that remote

00:22:35,600 --> 00:22:39,679
module has a special api connection

00:22:37,919 --> 00:22:40,559
interface so it knows how to connect to

00:22:39,679 --> 00:22:43,600
the api

00:22:40,559 --> 00:22:45,039
and get specific things off of it

00:22:43,600 --> 00:22:46,640
one of the cool things here though is

00:22:45,039 --> 00:22:48,720
these dotted lines represent

00:22:46,640 --> 00:22:50,480
async imports so when you have a dynamic

00:22:48,720 --> 00:22:52,320
import

00:22:50,480 --> 00:22:55,120
and what's really cool here is if the

00:22:52,320 --> 00:22:57,440
dropdown is used synchronously

00:22:55,120 --> 00:23:00,080
it will be hoisted up to the nearest

00:22:57,440 --> 00:23:02,080
parent dynamic import that it can find

00:23:00,080 --> 00:23:04,000
which is how we're able to give you this

00:23:02,080 --> 00:23:04,960
as a synchronous import if you want it

00:23:04,000 --> 00:23:07,840
we find the

00:23:04,960 --> 00:23:10,240
the closest async import and we attach

00:23:07,840 --> 00:23:11,840
these additional requirements onto it

00:23:10,240 --> 00:23:13,760
what you'll see uh like down here with

00:23:11,840 --> 00:23:15,679
react is a shared module it also gets

00:23:13,760 --> 00:23:17,520
hoisted up to the top

00:23:15,679 --> 00:23:18,799
and i always put a async import in

00:23:17,520 --> 00:23:22,240
between my entry point

00:23:18,799 --> 00:23:24,080
and the real entry point of the app but

00:23:22,240 --> 00:23:25,919
if we go down here to say button remote

00:23:24,080 --> 00:23:28,720
which is only needed by the login

00:23:25,919 --> 00:23:30,480
modal you'll see we code split and

00:23:28,720 --> 00:23:32,880
dynamic import the login model

00:23:30,480 --> 00:23:33,919
so i can just hoist any synchronous

00:23:32,880 --> 00:23:37,280
imports

00:23:33,919 --> 00:23:39,039
up to this dynamic import so we'll load

00:23:37,280 --> 00:23:40,880
these things only when it's loading the

00:23:39,039 --> 00:23:42,799
login model now of course this is

00:23:40,880 --> 00:23:45,039
assuming you're using require

00:23:42,799 --> 00:23:46,400
and import from if you use a dynamic

00:23:45,039 --> 00:23:48,320
import you then

00:23:46,400 --> 00:23:49,919
the import you know it won't need to go

00:23:48,320 --> 00:23:51,200
to the parent import because it is

00:23:49,919 --> 00:23:53,200
apparent it is a

00:23:51,200 --> 00:23:54,880
dynamic import so it just puts it on

00:23:53,200 --> 00:23:55,440
itself and the app knows how to wait for

00:23:54,880 --> 00:23:56,880
it

00:23:55,440 --> 00:23:58,320
but these are the kind of two tactics

00:23:56,880 --> 00:23:58,799
that we have from container reference

00:23:58,320 --> 00:24:00,640
aspect

00:23:58,799 --> 00:24:03,120
this is what your host again is looking

00:24:00,640 --> 00:24:04,000
for and of course everything else will

00:24:03,120 --> 00:24:06,720
connect out to the

00:24:04,000 --> 00:24:07,360
container itself and the container is

00:24:06,720 --> 00:24:10,960
what

00:24:07,360 --> 00:24:14,000
what will point to um our

00:24:10,960 --> 00:24:15,200
you know team b's remote essentially or

00:24:14,000 --> 00:24:17,520
the remote container

00:24:15,200 --> 00:24:19,600
and all these know how to do is talk to

00:24:17,520 --> 00:24:21,679
this exposed api

00:24:19,600 --> 00:24:23,840
with git initialize and a couple other

00:24:21,679 --> 00:24:25,919
things

00:24:23,840 --> 00:24:27,600
so if we break it down a little bit more

00:24:25,919 --> 00:24:29,360
we'll have container reference plugin

00:24:27,600 --> 00:24:31,679
it creates the remote modules it's used

00:24:29,360 --> 00:24:35,360
by a host and it provides modules

00:24:31,679 --> 00:24:37,120
so we'll see out here it creates little

00:24:35,360 --> 00:24:38,000
async remote modules that know how to

00:24:37,120 --> 00:24:40,159
connect to

00:24:38,000 --> 00:24:41,440
the actual container's interface and

00:24:40,159 --> 00:24:44,000
pull in you know

00:24:41,440 --> 00:24:45,679
modules at runtime and it also might

00:24:44,000 --> 00:24:47,679
share some things so it might have

00:24:45,679 --> 00:24:49,760
react or low dash or a couple other

00:24:47,679 --> 00:24:51,760
things so it will also

00:24:49,760 --> 00:24:54,159
pass out the provided modules things

00:24:51,760 --> 00:24:56,240
that it has to offer

00:24:54,159 --> 00:24:57,600
then you know when anything enters the

00:24:56,240 --> 00:24:59,520
system we also go through

00:24:57,600 --> 00:25:02,240
a version check and it'll start to make

00:24:59,520 --> 00:25:04,240
more sense as uh this graphic builds out

00:25:02,240 --> 00:25:05,600
but we essentially have the consumed

00:25:04,240 --> 00:25:05,919
modules which are things that it would

00:25:05,600 --> 00:25:08,400
be

00:25:05,919 --> 00:25:10,159
taking in they go through semantic

00:25:08,400 --> 00:25:10,880
versioning and then they'll get passed

00:25:10,159 --> 00:25:13,039
into

00:25:10,880 --> 00:25:16,000
this container reference piece and this

00:25:13,039 --> 00:25:17,840
is also all happening at run time so

00:25:16,000 --> 00:25:19,840
prior to what i was showing you before

00:25:17,840 --> 00:25:21,279
this is kind of what it looks like in

00:25:19,840 --> 00:25:24,720
the whole picture when an app

00:25:21,279 --> 00:25:26,240
is running so

00:25:24,720 --> 00:25:28,559
we saw what a container reference looks

00:25:26,240 --> 00:25:29,760
like let's see what a container looks

00:25:28,559 --> 00:25:32,159
like

00:25:29,760 --> 00:25:33,279
so a container is what another team

00:25:32,159 --> 00:25:35,120
would expose to you

00:25:33,279 --> 00:25:37,039
you would take their their container

00:25:35,120 --> 00:25:39,360
entry and

00:25:37,039 --> 00:25:41,360
this is essentially what we end up

00:25:39,360 --> 00:25:44,799
having you'd have container js

00:25:41,360 --> 00:25:48,720
which is a pretty much a very uh

00:25:44,799 --> 00:25:50,720
craftily modified webpack runtime and

00:25:48,720 --> 00:25:52,720
it lo and all that's in this webpack

00:25:50,720 --> 00:25:53,440
runtime is essentially something like

00:25:52,720 --> 00:25:54,799
this code

00:25:53,440 --> 00:25:57,919
it's a little bit more complex than that

00:25:54,799 --> 00:25:59,760
but it's tiny so we're not actually

00:25:57,919 --> 00:26:01,919
downloading anything when i put this on

00:25:59,760 --> 00:26:03,919
the page maybe five kilobytes

00:26:01,919 --> 00:26:05,679
it's only once i actually go and try to

00:26:03,919 --> 00:26:08,000
use the button where i would then

00:26:05,679 --> 00:26:09,200
have the remote module inside of the

00:26:08,000 --> 00:26:11,120
host

00:26:09,200 --> 00:26:12,559
the remote module gets executed and it

00:26:11,120 --> 00:26:15,840
knows to call get

00:26:12,559 --> 00:26:18,080
name and pretty much locate the dynamic

00:26:15,840 --> 00:26:20,000
import or the case that fits whatever

00:26:18,080 --> 00:26:21,440
you're trying to ask it for

00:26:20,000 --> 00:26:23,279
and then it would return that as a

00:26:21,440 --> 00:26:25,279
promise and that's how you would get it

00:26:23,279 --> 00:26:26,960
but the breakdown that we would see here

00:26:25,279 --> 00:26:29,360
is this is its own chunk

00:26:26,960 --> 00:26:30,240
button is its own chunk the drop-down

00:26:29,360 --> 00:26:31,919
has two

00:26:30,240 --> 00:26:34,080
modules in it but it's essentially its

00:26:31,919 --> 00:26:35,760
own chunk and then react is shared so

00:26:34,080 --> 00:26:36,320
it's split out into its own chunk as

00:26:35,760 --> 00:26:37,919
well

00:26:36,320 --> 00:26:40,000
the reason we split it out like that is

00:26:37,919 --> 00:26:42,720
because we don't want to ship react down

00:26:40,000 --> 00:26:43,760
if we're running in omnidirectional mode

00:26:42,720 --> 00:26:45,279
um

00:26:43,760 --> 00:26:47,120
because we don't know if that react is

00:26:45,279 --> 00:26:48,240
actually the right copy so when the app

00:26:47,120 --> 00:26:50,720
starts itself it

00:26:48,240 --> 00:26:52,400
in omnidirectional mode it will start

00:26:50,720 --> 00:26:54,640
not having react with it

00:26:52,400 --> 00:26:56,000
and it will figure out who has the best

00:26:54,640 --> 00:26:59,360
version of react and then

00:26:56,000 --> 00:27:00,559
load or react so

00:26:59,360 --> 00:27:03,520
diving a little deeper into our

00:27:00,559 --> 00:27:06,720
container plug-in what it does is it has

00:27:03,520 --> 00:27:09,120
exposed modules that it will pretty much

00:27:06,720 --> 00:27:10,400
create and it will also have the

00:27:09,120 --> 00:27:13,200
provided modules

00:27:10,400 --> 00:27:14,320
that it will create as well same way

00:27:13,200 --> 00:27:17,440
that we'd have on

00:27:14,320 --> 00:27:19,120
um on our on our reference

00:27:17,440 --> 00:27:21,520
and we also would have the consume

00:27:19,120 --> 00:27:23,840
modules coming in here and we would have

00:27:21,520 --> 00:27:25,039
version checks to make sure that the

00:27:23,840 --> 00:27:26,960
container and the host

00:27:25,039 --> 00:27:28,399
are compatible with each other and

00:27:26,960 --> 00:27:30,559
everything is bust backwards and

00:27:28,399 --> 00:27:32,799
forwards through there

00:27:30,559 --> 00:27:34,960
um all right so if we hop over and now

00:27:32,799 --> 00:27:37,120
this is essentially the full picture

00:27:34,960 --> 00:27:38,080
and you can see how everything comes

00:27:37,120 --> 00:27:40,559
together we've got

00:27:38,080 --> 00:27:42,880
our container over here we have the

00:27:40,559 --> 00:27:46,159
container reference so we've got uh

00:27:42,880 --> 00:27:47,440
the host on on on this side we have our

00:27:46,159 --> 00:27:48,799
remote over here

00:27:47,440 --> 00:27:50,720
and we have this thing called the

00:27:48,799 --> 00:27:53,279
sharescope the sharescope

00:27:50,720 --> 00:27:54,720
is uh really really great because this

00:27:53,279 --> 00:27:55,440
is the magic of how we're actually able

00:27:54,720 --> 00:27:58,080
to share

00:27:55,440 --> 00:28:00,000
modules in between separate webpack

00:27:58,080 --> 00:28:01,760
runtimes or how we're able to load them

00:28:00,000 --> 00:28:03,840
in

00:28:01,760 --> 00:28:05,600
provided modules that go out they first

00:28:03,840 --> 00:28:08,480
get passed into sharescope

00:28:05,600 --> 00:28:09,840
with their versions attached and then

00:28:08,480 --> 00:28:12,640
they get consumed back

00:28:09,840 --> 00:28:13,600
out with another version check happening

00:28:12,640 --> 00:28:15,600
on either side

00:28:13,600 --> 00:28:17,039
so we can determine who has the best

00:28:15,600 --> 00:28:19,520
copy of react now

00:28:17,039 --> 00:28:21,679
vend that copy back to everybody

00:28:19,520 --> 00:28:24,720
regardless if it's my copy of react or a

00:28:21,679 --> 00:28:26,799
different hosts or remotes copy of react

00:28:24,720 --> 00:28:28,480
and the nice thing about sharescope as

00:28:26,799 --> 00:28:29,279
well is you can actually have multiple

00:28:28,480 --> 00:28:31,600
share scopes

00:28:29,279 --> 00:28:32,880
so if you had a app that had several

00:28:31,600 --> 00:28:35,200
different frameworks

00:28:32,880 --> 00:28:36,320
and say you had something like or a

00:28:35,200 --> 00:28:37,840
legacy app even

00:28:36,320 --> 00:28:39,840
you could create a share scope called

00:28:37,840 --> 00:28:40,799
legacy and modern and you could have

00:28:39,840 --> 00:28:43,600
certain

00:28:40,799 --> 00:28:44,000
modules only use certain share scopes so

00:28:43,600 --> 00:28:46,080
they're not

00:28:44,000 --> 00:28:47,039
exposed to the entire apps which lets

00:28:46,080 --> 00:28:50,399
you do things like

00:28:47,039 --> 00:28:51,520
have different versions of react or

00:28:50,399 --> 00:28:54,640
different versions of a shared

00:28:51,520 --> 00:28:57,360
dependency be loaded in and not seen by

00:28:54,640 --> 00:28:59,200
the other apps

00:28:57,360 --> 00:29:00,799
so creating a container we're gonna this

00:28:59,200 --> 00:29:03,440
is pretty much looking at the module

00:29:00,799 --> 00:29:05,279
federation plug-in itself and what each

00:29:03,440 --> 00:29:07,600
key on the module federation plug-in

00:29:05,279 --> 00:29:09,919
actually does when it's running

00:29:07,600 --> 00:29:11,440
so a new module federation plug-in this

00:29:09,919 --> 00:29:12,240
just goes in your webpack config like

00:29:11,440 --> 00:29:14,240
normal

00:29:12,240 --> 00:29:16,240
and this would be to create a container

00:29:14,240 --> 00:29:18,240
or a remote

00:29:16,240 --> 00:29:19,679
i give it a name and i expose some

00:29:18,240 --> 00:29:21,039
things

00:29:19,679 --> 00:29:23,120
this is the public name and then that's

00:29:21,039 --> 00:29:24,960
the internal request so wherever it is

00:29:23,120 --> 00:29:25,520
in the file system versus how i'd want

00:29:24,960 --> 00:29:28,480
to

00:29:25,520 --> 00:29:29,440
import it as in in the host i want to

00:29:28,480 --> 00:29:32,799
import

00:29:29,440 --> 00:29:35,200
tracking system but inside of this

00:29:32,799 --> 00:29:36,880
actual place where it comes from it's

00:29:35,200 --> 00:29:37,279
just you know right there at the top

00:29:36,880 --> 00:29:39,360
level

00:29:37,279 --> 00:29:42,000
but i can still categorize it or shape

00:29:39,360 --> 00:29:44,480
it a specific way

00:29:42,000 --> 00:29:45,600
then if i want to do say sharing modules

00:29:44,480 --> 00:29:46,960
that would be

00:29:45,600 --> 00:29:49,279
that would mean we essentially use

00:29:46,960 --> 00:29:52,320
shared and we would add this as either

00:29:49,279 --> 00:29:53,840
an array of strings or a mixed array

00:29:52,320 --> 00:29:55,679
and in here we can also do things like

00:29:53,840 --> 00:29:57,440
specify react as a singleton or

00:29:55,679 --> 00:29:59,440
specify i want a required version of

00:29:57,440 --> 00:30:02,720
something explicit

00:29:59,440 --> 00:30:03,279
um and you know we can get into more

00:30:02,720 --> 00:30:05,120
advanced

00:30:03,279 --> 00:30:07,279
options like i want to strictly use this

00:30:05,120 --> 00:30:08,640
version i can specify the version that

00:30:07,279 --> 00:30:10,399
it has to have

00:30:08,640 --> 00:30:12,799
versus uh this was just kind of like a

00:30:10,399 --> 00:30:15,200
sim like how npm would kind of work

00:30:12,799 --> 00:30:15,919
and i can also manually say specify an

00:30:15,200 --> 00:30:17,440
import

00:30:15,919 --> 00:30:19,200
my share scope and i could give it

00:30:17,440 --> 00:30:20,799
another name on the share key other than

00:30:19,200 --> 00:30:22,240
the one that it has

00:30:20,799 --> 00:30:23,840
of course consuming from other

00:30:22,240 --> 00:30:26,080
containers same

00:30:23,840 --> 00:30:28,320
plugin you would go through remotes i

00:30:26,080 --> 00:30:30,240
want to call it say analytics and

00:30:28,320 --> 00:30:32,000
this is where i'm going to find it and

00:30:30,240 --> 00:30:33,279
really this is kind of the global name

00:30:32,000 --> 00:30:35,679
that i put it in as but

00:30:33,279 --> 00:30:36,480
after this at symbol it could be http

00:30:35,679 --> 00:30:37,760
url

00:30:36,480 --> 00:30:39,600
so you could go and retrieve these

00:30:37,760 --> 00:30:41,840
things over the wire from other

00:30:39,600 --> 00:30:44,000
containers that are available and it

00:30:41,840 --> 00:30:45,520
will come together

00:30:44,000 --> 00:30:47,679
we can also do you know more advanced

00:30:45,520 --> 00:30:49,760
types of remotes here as well

00:30:47,679 --> 00:30:50,880
how we get them how they're exposed and

00:30:49,760 --> 00:30:52,480
where

00:30:50,880 --> 00:30:54,240
and then pretty much to use module

00:30:52,480 --> 00:30:55,919
federation plug-in it would be

00:30:54,240 --> 00:30:58,799
a combination of any of these three in

00:30:55,919 --> 00:31:01,039
whatever order it makes sense for you

00:30:58,799 --> 00:31:02,159
so looking at a real world copy of this

00:31:01,039 --> 00:31:03,919
we've got a

00:31:02,159 --> 00:31:06,240
module federation plug-in i can see i've

00:31:03,919 --> 00:31:08,080
got app a app b

00:31:06,240 --> 00:31:09,760
the library types that i want to specify

00:31:08,080 --> 00:31:11,840
which you don't really need anymore

00:31:09,760 --> 00:31:14,240
um then the file name i'm going to call

00:31:11,840 --> 00:31:16,159
them both remote entry dot js

00:31:14,240 --> 00:31:18,720
and you can see me pretty much just walk

00:31:16,159 --> 00:31:20,399
through share out some dependencies

00:31:18,720 --> 00:31:22,480
how i want them done what i want to be

00:31:20,399 --> 00:31:23,679
singleton what required versions i want

00:31:22,480 --> 00:31:25,519
on there

00:31:23,679 --> 00:31:27,600
depths is essentially just coming from

00:31:25,519 --> 00:31:29,360
require package.json so i just pull that

00:31:27,600 --> 00:31:29,919
in to get the the exact thing that i

00:31:29,360 --> 00:31:32,480
want

00:31:29,919 --> 00:31:34,799
um it's easy enough way to specify them

00:31:32,480 --> 00:31:36,799
within the advanced api

00:31:34,799 --> 00:31:37,919
and that's pretty much all i really need

00:31:36,799 --> 00:31:40,000
to to use this

00:31:37,919 --> 00:31:42,000
um of course it'll spit out a remote

00:31:40,000 --> 00:31:43,440
entry js and if you're doing something

00:31:42,000 --> 00:31:45,200
like you know app b

00:31:43,440 --> 00:31:48,000
then you would want to take you know in

00:31:45,200 --> 00:31:50,159
my case let's say localhost 3002

00:31:48,000 --> 00:31:51,519
slash remote entry dot js and i would

00:31:50,159 --> 00:31:54,159
want to have that

00:31:51,519 --> 00:31:55,279
in the like html plugin or the html

00:31:54,159 --> 00:31:58,000
template here

00:31:55,279 --> 00:31:59,279
so that i can reference it as app b when

00:31:58,000 --> 00:32:00,399
this app kicks off

00:31:59,279 --> 00:32:02,720
if i don't want to have to like

00:32:00,399 --> 00:32:06,880
statically code them out in the html

00:32:02,720 --> 00:32:07,760
i can just go app b at localhost 3002

00:32:06,880 --> 00:32:09,919
slash

00:32:07,760 --> 00:32:11,440
remote entry dot js and a webpack will

00:32:09,919 --> 00:32:13,039
automatically attach the remote

00:32:11,440 --> 00:32:14,799
container for me

00:32:13,039 --> 00:32:16,240
i have a bunch of examples online so

00:32:14,799 --> 00:32:18,000
anybody's wondering um there's some

00:32:16,240 --> 00:32:19,600
links at the end

00:32:18,000 --> 00:32:21,840
uh and here's what it would look like to

00:32:19,600 --> 00:32:23,840
actually consume this so

00:32:21,840 --> 00:32:25,679
application b i'm gonna get button and

00:32:23,840 --> 00:32:28,240
i'm gonna use uh

00:32:25,679 --> 00:32:29,120
suspense to get this button and that's

00:32:28,240 --> 00:32:30,799
how i would get it

00:32:29,120 --> 00:32:32,000
now to show off another cool thing is

00:32:30,799 --> 00:32:32,880
let's say i want to get the drop down

00:32:32,000 --> 00:32:34,720
from app b

00:32:32,880 --> 00:32:36,080
and i don't want to actually use react

00:32:34,720 --> 00:32:38,080
lazy or suspense

00:32:36,080 --> 00:32:39,679
well i can also use import from drop

00:32:38,080 --> 00:32:41,440
down app b

00:32:39,679 --> 00:32:43,120
drop down and i can just use it as a

00:32:41,440 --> 00:32:47,200
normal synchronous

00:32:43,120 --> 00:32:50,240
uh module as well uh so at scale here's

00:32:47,200 --> 00:32:51,679
the example that you could end up seeing

00:32:50,240 --> 00:32:53,919
and you can see you know we've got a

00:32:51,679 --> 00:32:56,720
design system components nav components

00:32:53,919 --> 00:32:58,080
translations advertising analytics

00:32:56,720 --> 00:33:00,880
internal apps

00:32:58,080 --> 00:33:02,399
admin apps advertiser main welcome apps

00:33:00,880 --> 00:33:04,159
and then you know some piece in the

00:33:02,399 --> 00:33:06,159
middle that several of them consume

00:33:04,159 --> 00:33:07,760
which may consume lower down parts

00:33:06,159 --> 00:33:09,360
but all of these can be deployed or

00:33:07,760 --> 00:33:12,720
managed independently depending on the

00:33:09,360 --> 00:33:16,640
size of your team and who owns what

00:33:12,720 --> 00:33:18,880
so supporting multiple react versions um

00:33:16,640 --> 00:33:20,320
it's tricky but uh it is possible to do

00:33:18,880 --> 00:33:22,000
this um

00:33:20,320 --> 00:33:23,279
through an adapter pattern and this is

00:33:22,000 --> 00:33:24,559
really helpful at scale when you're

00:33:23,279 --> 00:33:26,159
working at a large enterprise where you

00:33:24,559 --> 00:33:28,159
really can't shift off of some of those

00:33:26,159 --> 00:33:29,519
legacy applications or you can't do it

00:33:28,159 --> 00:33:30,559
all at the same time but you don't want

00:33:29,519 --> 00:33:32,320
to compromise

00:33:30,559 --> 00:33:34,320
your ability to move forward on the apps

00:33:32,320 --> 00:33:36,240
that you can

00:33:34,320 --> 00:33:37,760
so i've got a short video here i'm going

00:33:36,240 --> 00:33:39,519
to jump through a little bit of it so we

00:33:37,760 --> 00:33:41,600
get to the interesting parts

00:33:39,519 --> 00:33:45,039
and here pretty much uh it shows there

00:33:41,600 --> 00:33:47,440
i've got react 16.6.3 which is

00:33:45,039 --> 00:33:48,960
pre-react hooks and i'm going to jump

00:33:47,440 --> 00:33:52,720
into another app and you'll see that

00:33:48,960 --> 00:33:55,360
i've got react 16.13

00:33:52,720 --> 00:33:57,360
so now i will go in here and this is my

00:33:55,360 --> 00:33:59,840
modern react component

00:33:57,360 --> 00:34:01,360
uh it has some use effect in here which

00:33:59,840 --> 00:34:03,039
would pretty much throw an error in

00:34:01,360 --> 00:34:05,760
another application

00:34:03,039 --> 00:34:06,240
and what i end up doing with it is i've

00:34:05,760 --> 00:34:08,639
got

00:34:06,240 --> 00:34:10,399
i'm sharing out react dom and i also

00:34:08,639 --> 00:34:12,720
share out react and i give it a new

00:34:10,399 --> 00:34:14,159
share key or a share scope on here to

00:34:12,720 --> 00:34:16,079
load it into a different scope so it

00:34:14,159 --> 00:34:18,480
doesn't conflict with my current

00:34:16,079 --> 00:34:20,320
legacy version of react and then i can

00:34:18,480 --> 00:34:21,599
go into app one which doesn't support

00:34:20,320 --> 00:34:24,639
react hooks

00:34:21,599 --> 00:34:28,320
and i should just be able to

00:34:24,639 --> 00:34:30,079
load it in as something like this

00:34:28,320 --> 00:34:31,760
so that would be a normal one and then

00:34:30,079 --> 00:34:32,879
over here i created something called an

00:34:31,760 --> 00:34:35,280
adapter

00:34:32,879 --> 00:34:36,159
and what my adapter would allow me to do

00:34:35,280 --> 00:34:39,119
is

00:34:36,159 --> 00:34:41,520
it would require the newer version of

00:34:39,119 --> 00:34:42,800
react and mount it inside here so now i

00:34:41,520 --> 00:34:45,200
have

00:34:42,800 --> 00:34:46,240
a non-compatible version of react hooks

00:34:45,200 --> 00:34:49,839
where i'm typing in an

00:34:46,240 --> 00:34:52,320
input and i have a remote

00:34:49,839 --> 00:34:54,480
that's using a modern version of react

00:34:52,320 --> 00:34:58,000
and you can see as i type into

00:34:54,480 --> 00:34:59,920
react legacy or whatever

00:34:58,000 --> 00:35:01,440
you can see a modern copy of react is

00:34:59,920 --> 00:35:02,000
accepting and rendering these things

00:35:01,440 --> 00:35:05,040
without any

00:35:02,000 --> 00:35:08,160
issues actually happening

00:35:05,040 --> 00:35:09,200
so applied architecture where could or

00:35:08,160 --> 00:35:11,760
what could we

00:35:09,200 --> 00:35:13,359
end up federating so a couple things

00:35:11,760 --> 00:35:15,280
that i've done with it already is ui

00:35:13,359 --> 00:35:16,880
code configurations

00:35:15,280 --> 00:35:18,400
business logic server middleware

00:35:16,880 --> 00:35:21,119
translations side effects

00:35:18,400 --> 00:35:22,480
reducers even react context

00:35:21,119 --> 00:35:24,480
authentication modules

00:35:22,480 --> 00:35:25,599
and i've been pushing heavily into

00:35:24,480 --> 00:35:28,160
analytics a b

00:35:25,599 --> 00:35:30,000
tests and tag management where these

00:35:28,160 --> 00:35:32,400
things are now driven by

00:35:30,000 --> 00:35:34,480
webpack and federated systems rather

00:35:32,400 --> 00:35:36,240
than something less efficient

00:35:34,480 --> 00:35:38,880
that doesn't actually gel well with the

00:35:36,240 --> 00:35:40,400
engineering side of an app

00:35:38,880 --> 00:35:43,040
so i've got another little example here

00:35:40,400 --> 00:35:44,720
which is a shared app shell

00:35:43,040 --> 00:35:46,880
i'm i'm gonna skip through this as well

00:35:44,720 --> 00:35:48,079
quite quickly uh but essentially i've

00:35:46,880 --> 00:35:50,880
got

00:35:48,079 --> 00:35:52,560
five different apps loaded in here and

00:35:50,880 --> 00:35:55,839
each app has

00:35:52,560 --> 00:35:58,560
um pretty much just the shell

00:35:55,839 --> 00:35:59,440
wrapping around them and if we jump

00:35:58,560 --> 00:36:01,680
forward a little bit

00:35:59,440 --> 00:36:03,760
i've got some roots over here which is

00:36:01,680 --> 00:36:05,280
going to define dashboard order profile

00:36:03,760 --> 00:36:06,640
you'll also notice in my sidebar of my

00:36:05,280 --> 00:36:09,119
file i've got profile

00:36:06,640 --> 00:36:09,839
dashboard sales a whole bunch of other

00:36:09,119 --> 00:36:11,599
things so

00:36:09,839 --> 00:36:13,200
these are all rooting to specific

00:36:11,599 --> 00:36:16,240
remotes that i've defined

00:36:13,200 --> 00:36:18,000
higher up in the application so

00:36:16,240 --> 00:36:19,280
what i'll end up doing here is if i go

00:36:18,000 --> 00:36:22,320
and look at uh

00:36:19,280 --> 00:36:23,359
the shell or my my app shell system it's

00:36:22,320 --> 00:36:25,200
called the shell

00:36:23,359 --> 00:36:28,000
that's how it exports itself out it

00:36:25,200 --> 00:36:29,920
exposes shell and a special service

00:36:28,000 --> 00:36:31,680
and it also shares you know react and

00:36:29,920 --> 00:36:34,079
react on like usual

00:36:31,680 --> 00:36:35,359
if we look at another one like the

00:36:34,079 --> 00:36:37,680
profile

00:36:35,359 --> 00:36:39,119
micro front end you'll see that it has a

00:36:37,680 --> 00:36:41,200
remote which is the shell

00:36:39,119 --> 00:36:43,040
and it exposes the profile page and

00:36:41,200 --> 00:36:45,599
that's pretty much all it's doing

00:36:43,040 --> 00:36:48,560
and you'll see inside of the profile

00:36:45,599 --> 00:36:51,520
page i actually have the app shell

00:36:48,560 --> 00:36:52,640
as the app using react lazy so what ends

00:36:51,520 --> 00:36:54,720
up happening is

00:36:52,640 --> 00:36:56,640
whenever i land on anything that's not

00:36:54,720 --> 00:36:58,800
localhost 3001

00:36:56,640 --> 00:37:00,079
i'm essentially federating the app shell

00:36:58,800 --> 00:37:02,480
into my current app

00:37:00,079 --> 00:37:03,760
that app shell then federates my current

00:37:02,480 --> 00:37:05,599
app into it

00:37:03,760 --> 00:37:07,440
so it's kind of circular but webpack

00:37:05,599 --> 00:37:08,079
handles this in the graph resolution at

00:37:07,440 --> 00:37:09,040
runtime

00:37:08,079 --> 00:37:10,640
so it doesn't actually have a

00:37:09,040 --> 00:37:12,160
performance overhead but we can create

00:37:10,640 --> 00:37:13,920
these circular structures

00:37:12,160 --> 00:37:15,440
that allow things to import things when

00:37:13,920 --> 00:37:18,960
they're being imported

00:37:15,440 --> 00:37:20,960
from you know other remote locations

00:37:18,960 --> 00:37:22,560
and so i'm just going to jump forward

00:37:20,960 --> 00:37:23,760
the app looks you know more or less

00:37:22,560 --> 00:37:26,800
normal

00:37:23,760 --> 00:37:28,320
and let's get into the actual app itself

00:37:26,800 --> 00:37:30,240
so you'll see i've got a whole bunch of

00:37:28,320 --> 00:37:31,920
tabs open here each tab is the same

00:37:30,240 --> 00:37:33,040
application but each tab is a separate

00:37:31,920 --> 00:37:34,800
webpack build

00:37:33,040 --> 00:37:36,320
so i can go to the profile page you'll

00:37:34,800 --> 00:37:38,880
notice that the profile page

00:37:36,320 --> 00:37:40,320
shows up and i could inspect this we

00:37:38,880 --> 00:37:41,680
could take a quick peek at our network

00:37:40,320 --> 00:37:44,320
and see how it's actually

00:37:41,680 --> 00:37:45,520
handling it and i can jump through here

00:37:44,320 --> 00:37:47,680
to the order service

00:37:45,520 --> 00:37:48,560
which only cost me 9.2 kilobytes to

00:37:47,680 --> 00:37:50,560
download

00:37:48,560 --> 00:37:52,320
and i could jump into the dashboard

00:37:50,560 --> 00:37:55,440
which only cost me an additional

00:37:52,320 --> 00:37:58,480
i think in total i've done 10 megabytes

00:37:55,440 --> 00:38:00,000
or 10 kilobytes of data transfer

00:37:58,480 --> 00:38:01,680
and again this is also running in dev

00:38:00,000 --> 00:38:05,280
mode so even that is quite

00:38:01,680 --> 00:38:08,480
over you know over the top

00:38:05,280 --> 00:38:08,960
but uh you know now i can hop over to

00:38:08,480 --> 00:38:11,119
say

00:38:08,960 --> 00:38:12,480
localhost 3004 and i can do the same

00:38:11,119 --> 00:38:14,079
thing so even though each one of these

00:38:12,480 --> 00:38:14,880
apps is only one thing like maybe the

00:38:14,079 --> 00:38:17,760
dashboard

00:38:14,880 --> 00:38:18,240
or the profile page or whatever i can

00:38:17,760 --> 00:38:20,480
route

00:38:18,240 --> 00:38:22,320
and browse and use this app and you will

00:38:20,480 --> 00:38:24,240
not know that these are separate apps

00:38:22,320 --> 00:38:25,839
running on separate ports

00:38:24,240 --> 00:38:27,520
uh that have nothing to really do with

00:38:25,839 --> 00:38:28,720
each other and that's all thanks to

00:38:27,520 --> 00:38:31,680
module federation

00:38:28,720 --> 00:38:32,640
um so that's done through using the

00:38:31,680 --> 00:38:34,640
federated shell

00:38:32,640 --> 00:38:36,320
so the roots are handled up there so the

00:38:34,640 --> 00:38:36,880
shell is actually handling you know

00:38:36,320 --> 00:38:38,960
nested

00:38:36,880 --> 00:38:40,400
module federation and it's pulling in

00:38:38,960 --> 00:38:41,920
all of these components

00:38:40,400 --> 00:38:43,440
now that might not work for everybody if

00:38:41,920 --> 00:38:45,200
they don't have to continuously redeploy

00:38:43,440 --> 00:38:47,440
their shell to change their roots

00:38:45,200 --> 00:38:48,720
so this is another simple simple example

00:38:47,440 --> 00:38:50,720
if you wanted to say have your own

00:38:48,720 --> 00:38:52,320
decentralized root structures

00:38:50,720 --> 00:38:54,640
and in there you could pretty much have

00:38:52,320 --> 00:38:56,240
you know your local roots

00:38:54,640 --> 00:38:58,880
and then you could get your remote roots

00:38:56,240 --> 00:39:01,040
from app 2 roots or whatever

00:38:58,880 --> 00:39:03,200
and you would pretty much just spread

00:39:01,040 --> 00:39:04,960
operate them into one thing and pass it

00:39:03,200 --> 00:39:06,079
back to something like react router and

00:39:04,960 --> 00:39:09,920
everything would just work

00:39:06,079 --> 00:39:11,680
then after that uh so getting into a

00:39:09,920 --> 00:39:11,920
couple other areas we've got federated a

00:39:11,680 --> 00:39:15,440
b

00:39:11,920 --> 00:39:16,800
tests and uh i use adobe target so i've

00:39:15,440 --> 00:39:19,920
been working a lot with

00:39:16,800 --> 00:39:21,359
with the target implementation so this

00:39:19,920 --> 00:39:22,480
is kind of the modeled architecture that

00:39:21,359 --> 00:39:23,280
i have running in production at the

00:39:22,480 --> 00:39:25,200
moment

00:39:23,280 --> 00:39:27,440
and essentially we have say the main

00:39:25,200 --> 00:39:28,960
site and i've got

00:39:27,440 --> 00:39:31,119
uh on the other side over here i've got

00:39:28,960 --> 00:39:32,400
an a b test repo and all that we really

00:39:31,119 --> 00:39:35,599
do inside of that is

00:39:32,400 --> 00:39:37,440
code up various different variants

00:39:35,599 --> 00:39:38,640
of components or completely new

00:39:37,440 --> 00:39:41,280
experiences

00:39:38,640 --> 00:39:43,359
or it might even just be content changes

00:39:41,280 --> 00:39:45,680
or maybe a change to the

00:39:43,359 --> 00:39:46,720
api hook that we use to go and get

00:39:45,680 --> 00:39:48,560
content

00:39:46,720 --> 00:39:50,079
so it's the same component technically

00:39:48,560 --> 00:39:52,079
but it's wrapped in something that

00:39:50,079 --> 00:39:52,960
modifies the props that gets sent into

00:39:52,079 --> 00:39:55,280
it

00:39:52,960 --> 00:39:57,359
so pretty much when my app starts i can

00:39:55,280 --> 00:39:59,280
do this on the server side i can run out

00:39:57,359 --> 00:40:00,560
and i can get the segment ids of

00:39:59,280 --> 00:40:03,200
whoever's visiting

00:40:00,560 --> 00:40:05,680
a page and then i can have the api

00:40:03,200 --> 00:40:08,160
return the federated experience id

00:40:05,680 --> 00:40:10,160
and then from there webpack the

00:40:08,160 --> 00:40:12,480
federated experience id is pretty much

00:40:10,160 --> 00:40:14,400
the custom piece that we've written that

00:40:12,480 --> 00:40:17,119
allows us to

00:40:14,400 --> 00:40:18,319
with a special react component it allows

00:40:17,119 --> 00:40:20,880
us to control

00:40:18,319 --> 00:40:21,680
webpack um at runtime so we're allowed

00:40:20,880 --> 00:40:23,520
to bus

00:40:21,680 --> 00:40:25,280
uh different experiences in and then

00:40:23,520 --> 00:40:28,240
based on whichever one that comes back

00:40:25,280 --> 00:40:29,359
here it will go into the remote

00:40:28,240 --> 00:40:31,040
federated module

00:40:29,359 --> 00:40:32,800
wherever the deployed location is and it

00:40:31,040 --> 00:40:33,280
will pull in whichever experience that i

00:40:32,800 --> 00:40:38,560
want

00:40:33,280 --> 00:40:42,240
at runtime um and again this can be

00:40:38,560 --> 00:40:44,800
oh okay um all right thank you

00:40:42,240 --> 00:40:46,640
thank you all right so to wrap this all

00:40:44,800 --> 00:40:48,319
up non-webpack compatibility

00:40:46,640 --> 00:40:50,000
we have some support for this we also

00:40:48,319 --> 00:40:50,960
have some support for webpack 4 through

00:40:50,000 --> 00:40:53,040
api shims

00:40:50,960 --> 00:40:55,040
we recently released roll up federation

00:40:53,040 --> 00:40:56,880
which gives partial support there and we

00:40:55,040 --> 00:40:57,359
do actually have a vanilla api for low

00:40:56,880 --> 00:40:59,280
level

00:40:57,359 --> 00:41:01,119
uh for a low level interface into the

00:40:59,280 --> 00:41:02,880
system and that's something that i use

00:41:01,119 --> 00:41:04,560
quite a lot on all the advanced stuff

00:41:02,880 --> 00:41:06,560
but it is available it's not fully

00:41:04,560 --> 00:41:07,920
webpack exclusive you can get other apps

00:41:06,560 --> 00:41:09,760
to consume remotes

00:41:07,920 --> 00:41:11,280
even if they're not webpack based apps

00:41:09,760 --> 00:41:13,359
you'll just have to do a little bit of

00:41:11,280 --> 00:41:15,119
typing um so one of the last things i'll

00:41:13,359 --> 00:41:16,800
touch on is you know as this new

00:41:15,119 --> 00:41:18,319
architecture evolves we're kind of also

00:41:16,800 --> 00:41:19,040
anticipating the need for some toolings

00:41:18,319 --> 00:41:20,400
around this

00:41:19,040 --> 00:41:22,160
so one of the cool pieces we're working

00:41:20,400 --> 00:41:24,000
on is to actually be able to see

00:41:22,160 --> 00:41:25,760
and orchestrate and control your app

00:41:24,000 --> 00:41:27,520
from a dashboard since everything is

00:41:25,760 --> 00:41:28,880
managed at runtime why can't i change

00:41:27,520 --> 00:41:29,760
why do i need to deploy anything to

00:41:28,880 --> 00:41:31,359
change anything

00:41:29,760 --> 00:41:33,599
as long as it was previously deployed

00:41:31,359 --> 00:41:34,000
once so this dashboard lets us see who

00:41:33,599 --> 00:41:36,400
uses

00:41:34,000 --> 00:41:37,760
what and where and how it lets us see

00:41:36,400 --> 00:41:38,480
what versions of everything is used

00:41:37,760 --> 00:41:40,880
across it

00:41:38,480 --> 00:41:42,560
uh choose environments and whatnot it

00:41:40,880 --> 00:41:44,319
shows us which is vended and also the

00:41:42,560 --> 00:41:45,200
version history of what got shared when

00:41:44,319 --> 00:41:48,000
where and how

00:41:45,200 --> 00:41:49,359
um all of our dependencies and in a

00:41:48,000 --> 00:41:51,119
later stage we also have something

00:41:49,359 --> 00:41:53,200
called write mode which actually lets me

00:41:51,119 --> 00:41:55,280
change the versions of my remotes

00:41:53,200 --> 00:41:57,040
so we can have versioned remotes as well

00:41:55,280 --> 00:41:58,880
or just change the versions of

00:41:57,040 --> 00:42:01,119
any of our modules and we don't have to

00:41:58,880 --> 00:42:03,599
deploy anything so it makes rollbacks

00:42:01,119 --> 00:42:05,440
code freezes partial code freezes

00:42:03,599 --> 00:42:06,800
applied at the actual webpack graph

00:42:05,440 --> 00:42:07,760
level instead of doing it at the

00:42:06,800 --> 00:42:11,200
dependency

00:42:07,760 --> 00:42:13,119
or repo level um so last thing would be

00:42:11,200 --> 00:42:15,760
our next steps where we're going

00:42:13,119 --> 00:42:16,640
dashboard versioning control code

00:42:15,760 --> 00:42:19,599
freezing

00:42:16,640 --> 00:42:20,560
hot reloading our servers unit tests

00:42:19,599 --> 00:42:23,760
through federation

00:42:20,560 --> 00:42:25,920
tag manager plugins and you know more

00:42:23,760 --> 00:42:28,640
scope isolation would be pretty cool

00:42:25,920 --> 00:42:30,079
um and yeah since i'm over time i'll

00:42:28,640 --> 00:42:33,119
just wrap it up

00:42:30,079 --> 00:42:35,119
thank you you can scan the qr code or go

00:42:33,119 --> 00:42:36,640
to github.com

00:42:35,119 --> 00:42:38,720
module federation you'll find every

00:42:36,640 --> 00:42:40,960
example that i've got

00:42:38,720 --> 00:42:42,240
as well as module federation.github.io

00:42:40,960 --> 00:42:44,640
which should point you to any

00:42:42,240 --> 00:42:47,119
documentation that i've made available

00:42:44,640 --> 00:42:48,800
in the repos and and what uh whatever

00:42:47,119 --> 00:42:50,880
and of course if you have any questions

00:42:48,800 --> 00:42:52,640
you can feel free to follow me on

00:42:50,880 --> 00:42:59,839
twitter and ask away

00:42:52,640 --> 00:42:59,839
and thank you for having me

00:43:12,770 --> 00:43:19,040
[Music]

00:43:17,200 --> 00:43:20,240
um so that was an amazing talk thank you

00:43:19,040 --> 00:43:21,920
very much

00:43:20,240 --> 00:43:24,480
i will say i'm ever so slightly

00:43:21,920 --> 00:43:26,319
disappointed um when i saw that this was

00:43:24,480 --> 00:43:27,920
about a module federation i got

00:43:26,319 --> 00:43:29,839
all excited that this was going to be

00:43:27,920 --> 00:43:32,240
something star trek like and

00:43:29,839 --> 00:43:34,880
you're going to create a group of

00:43:32,240 --> 00:43:36,560
webpack people to take over the universe

00:43:34,880 --> 00:43:39,119
but apparently not

00:43:36,560 --> 00:43:40,480
well you never know you never know

00:43:39,119 --> 00:43:41,920
webpack kind of is taking over the

00:43:40,480 --> 00:43:43,920
universe a little bit isn't it

00:43:41,920 --> 00:43:46,000
a little bit a little bit it's a good

00:43:43,920 --> 00:43:47,359
start we're at a good start

00:43:46,000 --> 00:43:49,359
speaking of good starts we've already

00:43:47,359 --> 00:43:51,040
had one question coming if anybody

00:43:49,359 --> 00:43:52,480
watching along has got a question to be

00:43:51,040 --> 00:43:55,280
put to zach please do

00:43:52,480 --> 00:43:56,640
drop them into the q a and vote up any

00:43:55,280 --> 00:44:00,560
that you like

00:43:56,640 --> 00:44:02,640
so the first one is i saw ipfs

00:44:00,560 --> 00:44:03,599
on one of your last slides but you were

00:44:02,640 --> 00:44:06,160
running out of time

00:44:03,599 --> 00:44:07,680
can you elaborate on how you see this in

00:44:06,160 --> 00:44:09,839
30 seconds or less

00:44:07,680 --> 00:44:12,000
yes sure so how i see it working with

00:44:09,839 --> 00:44:13,839
ipfs is uh this actually comes from a

00:44:12,000 --> 00:44:15,280
very old system that i wrote back in the

00:44:13,839 --> 00:44:16,240
day before even i think i think it was a

00:44:15,280 --> 00:44:20,000
web pack 2

00:44:16,240 --> 00:44:22,560
era but um the the idea i had was to

00:44:20,000 --> 00:44:23,200
kind of create a cdn using ipfs and end

00:44:22,560 --> 00:44:25,920
up creating

00:44:23,200 --> 00:44:27,440
uh on top of ips fs like another

00:44:25,920 --> 00:44:29,760
database consistency

00:44:27,440 --> 00:44:30,800
system so using like this distributed

00:44:29,760 --> 00:44:33,599
platform i can just

00:44:30,800 --> 00:44:34,960
push this stuff out to the to our end

00:44:33,599 --> 00:44:37,680
users and have them

00:44:34,960 --> 00:44:38,480
do the work of verifying the the data is

00:44:37,680 --> 00:44:40,079
consistent

00:44:38,480 --> 00:44:42,079
and serving it from their browsers

00:44:40,079 --> 00:44:44,720
instead of serving it from my servers

00:44:42,079 --> 00:44:46,319
um anyway as time evolved i wrote module

00:44:44,720 --> 00:44:47,599
federation and i was like wow this could

00:44:46,319 --> 00:44:49,680
because a lot of questions come up

00:44:47,599 --> 00:44:51,440
around redundancy and failover and what

00:44:49,680 --> 00:44:53,280
happens if the remote's offline

00:44:51,440 --> 00:44:54,960
we can put an array of remotes in so if

00:44:53,280 --> 00:44:55,680
they fail they can have a fall over to

00:44:54,960 --> 00:44:58,480
the next

00:44:55,680 --> 00:45:00,560
kind of you know origin on the cdn and

00:44:58,480 --> 00:45:03,520
it just naturally fits really well with

00:45:00,560 --> 00:45:04,079
ipfs so how would work with ipfs is

00:45:03,520 --> 00:45:06,560
probably

00:45:04,079 --> 00:45:08,720
uh have a plug-in that just just uploads

00:45:06,560 --> 00:45:11,040
it to the ipfs servers

00:45:08,720 --> 00:45:12,560
and then um how that would actually hook

00:45:11,040 --> 00:45:14,400
in inside of webpack is there's actually

00:45:12,560 --> 00:45:16,240
already a lot of ipfs plugins out there

00:45:14,400 --> 00:45:18,240
so i'd probably just pull one down

00:45:16,240 --> 00:45:19,680
and alter it slightly but honestly i

00:45:18,240 --> 00:45:21,520
wouldn't even need to do that because we

00:45:19,680 --> 00:45:23,760
would just point to say hey the remote

00:45:21,520 --> 00:45:25,359
is at this ipfs address and that address

00:45:23,760 --> 00:45:26,880
is immutable and won't change and is you

00:45:25,359 --> 00:45:29,359
know bound to your hash

00:45:26,880 --> 00:45:31,599
so um all i would do is instead of it

00:45:29,359 --> 00:45:33,440
being localhost or http whatever

00:45:31,599 --> 00:45:34,800
i would just say hey well the remote is

00:45:33,440 --> 00:45:36,240
ipfs over here

00:45:34,800 --> 00:45:37,920
and essentially i would be pulling it

00:45:36,240 --> 00:45:38,480
all in through just you know distributed

00:45:37,920 --> 00:45:39,839
network

00:45:38,480 --> 00:45:42,400
there wouldn't be any chance of the file

00:45:39,839 --> 00:45:45,839
going missing because the file is

00:45:42,400 --> 00:45:48,960
you know immutable in the graph and

00:45:45,839 --> 00:45:50,800
in the uh whatever it is the the file

00:45:48,960 --> 00:45:53,200
that makes sure all crypto is fine i

00:45:50,800 --> 00:45:55,280
forgot the actual name for it

00:45:53,200 --> 00:45:57,839
the big scary file that should be backed

00:45:55,280 --> 00:45:59,760
up ten times over

00:45:57,839 --> 00:46:01,599
yeah pretty much the i don't know what

00:45:59,760 --> 00:46:03,200
it's called

00:46:01,599 --> 00:46:04,640
but yeah so that's kind of how i see it

00:46:03,200 --> 00:46:06,720
working is you know more or less how you

00:46:04,640 --> 00:46:07,119
would use ipfsa to just upload something

00:46:06,720 --> 00:46:08,800
is just

00:46:07,119 --> 00:46:10,480
what if it's another upload target of

00:46:08,800 --> 00:46:11,440
your deploy and it's kind of your

00:46:10,480 --> 00:46:13,200
fallback or

00:46:11,440 --> 00:46:14,880
you could make it your primary and just

00:46:13,200 --> 00:46:16,240
have like a hostless system

00:46:14,880 --> 00:46:18,480
where you can distribute the stuff

00:46:16,240 --> 00:46:20,480
across a decentralized network

00:46:18,480 --> 00:46:22,240
that is extremely hard to take down and

00:46:20,480 --> 00:46:24,079
then is super resilient and also gets

00:46:22,240 --> 00:46:26,240
super quick depending on the demand for

00:46:24,079 --> 00:46:28,000
traffic

00:46:26,240 --> 00:46:29,280
sounds like the perfect solution for it

00:46:28,000 --> 00:46:32,319
that was a brilliant answer

00:46:29,280 --> 00:46:33,359
brilliant um so somebody's asked already

00:46:32,319 --> 00:46:35,040
if they can

00:46:33,359 --> 00:46:35,839
have your powerpoint um is that

00:46:35,040 --> 00:46:36,640
something that you're going to be

00:46:35,839 --> 00:46:39,520
tweeting out

00:46:36,640 --> 00:46:42,000
or should they re-watch the talk at a

00:46:39,520 --> 00:46:46,240
later date

00:46:42,000 --> 00:46:47,520
um i would say i can tweet out a copy of

00:46:46,240 --> 00:46:49,119
the powerpoint i'll just need to remove

00:46:47,520 --> 00:46:49,599
one of two things and also note that

00:46:49,119 --> 00:46:52,319
like

00:46:49,599 --> 00:46:53,200
the powerpoint's like 50 or 60 slides

00:46:52,319 --> 00:46:54,960
and i took out

00:46:53,200 --> 00:46:56,319
i've hidden a lot of them so if you want

00:46:54,960 --> 00:46:57,040
the powerpoint just open it up and

00:46:56,319 --> 00:46:58,880
you'll see

00:46:57,040 --> 00:47:01,200
all the other content that i skip over

00:46:58,880 --> 00:47:02,720
depending on time uh but a better place

00:47:01,200 --> 00:47:05,839
to get content would be

00:47:02,720 --> 00:47:08,400
finding me on twitter and just get uh

00:47:05,839 --> 00:47:09,680
and or go to a google module federation

00:47:08,400 --> 00:47:12,960
and go to the github

00:47:09,680 --> 00:47:14,960
dot com module federation in there i've

00:47:12,960 --> 00:47:17,359
got every article that i've written or

00:47:14,960 --> 00:47:18,000
links to like all the youtube casts that

00:47:17,359 --> 00:47:20,400
have been done

00:47:18,000 --> 00:47:23,119
interviews people i've worked with talks

00:47:20,400 --> 00:47:25,599
from other webpack founders

00:47:23,119 --> 00:47:26,640
my own screencasts and pretty much a

00:47:25,599 --> 00:47:28,559
central hub on

00:47:26,640 --> 00:47:30,559
advanced usage current usage and of

00:47:28,559 --> 00:47:31,280
course the repo contains i think 30 or

00:47:30,559 --> 00:47:33,280
00:47:31,280 --> 00:47:36,240
different examples of module federation

00:47:33,280 --> 00:47:39,440
including things like max js or spelt or

00:47:36,240 --> 00:47:40,160
angular and ssr and so on wow you've

00:47:39,440 --> 00:47:41,520
gone over

00:47:40,160 --> 00:47:44,079
over and above with that little

00:47:41,520 --> 00:47:45,839
collection of documents and videos

00:47:44,079 --> 00:47:47,599
much better than just the key to success

00:47:45,839 --> 00:47:49,680
is documentation

00:47:47,599 --> 00:47:51,520
especially on new technology that you're

00:47:49,680 --> 00:47:54,319
bringing out definitely

00:47:51,520 --> 00:47:56,000
definitely um speaking of new technology

00:47:54,319 --> 00:47:57,920
this next one is about code sandbox

00:47:56,000 --> 00:48:00,319
which is still fairly new i would say

00:47:57,920 --> 00:48:01,599
and do you think tools like code sandbox

00:48:00,319 --> 00:48:03,760
will adapt this

00:48:01,599 --> 00:48:05,680
to reduce infrastructure costs instead

00:48:03,760 --> 00:48:07,599
of pulling all of the dependencies

00:48:05,680 --> 00:48:10,160
into a container and thank you for that

00:48:07,599 --> 00:48:10,160
one thomas

00:48:10,559 --> 00:48:18,559
um that's a good point i would say

00:48:15,280 --> 00:48:20,240
probably once but then there would have

00:48:18,559 --> 00:48:21,680
to be that mandate of okay everybody

00:48:20,240 --> 00:48:25,040
uses web pack five

00:48:21,680 --> 00:48:27,200
and but if we get to that stage or once

00:48:25,040 --> 00:48:29,440
that stage is commonplace and i think

00:48:27,200 --> 00:48:31,599
the you know we're still in beta but i

00:48:29,440 --> 00:48:33,520
know that we will probably see a rc show

00:48:31,599 --> 00:48:37,040
up sometime in the near future

00:48:33,520 --> 00:48:37,760
so um once we're you know more in the rc

00:48:37,040 --> 00:48:40,079
space

00:48:37,760 --> 00:48:41,359
then what's going to end up happening

00:48:40,079 --> 00:48:43,040
likely is we'll see some of these things

00:48:41,359 --> 00:48:43,440
like i know storybooks already looked at

00:48:43,040 --> 00:48:45,440
uh

00:48:43,440 --> 00:48:47,119
using module federation so that

00:48:45,440 --> 00:48:48,480
deploying your storybook is moving to

00:48:47,119 --> 00:48:49,040
production and that's how the system

00:48:48,480 --> 00:48:50,480
would work

00:48:49,040 --> 00:48:52,160
and you could have catalogs of

00:48:50,480 --> 00:48:53,280
storybooks to aggregate through each

00:48:52,160 --> 00:48:54,960
team

00:48:53,280 --> 00:48:57,119
stuff like code sandbox i could

00:48:54,960 --> 00:48:58,960
definitely see it being used

00:48:57,119 --> 00:49:00,319
or what it would probably start off with

00:48:58,960 --> 00:49:02,559
is i would see

00:49:00,319 --> 00:49:04,319
people using module federation on code

00:49:02,559 --> 00:49:06,079
sandbox instead of actually putting it

00:49:04,319 --> 00:49:07,359
all back together they might just proxy

00:49:06,079 --> 00:49:08,400
in a piece of an app that they've got

00:49:07,359 --> 00:49:10,800
somewhere else

00:49:08,400 --> 00:49:12,240
and demo it there instead of copying the

00:49:10,800 --> 00:49:14,160
code over or having to

00:49:12,240 --> 00:49:16,559
you know ship it to npm just for the

00:49:14,160 --> 00:49:18,880
sake of the example um

00:49:16,559 --> 00:49:20,160
so that's likely where i'd see it going

00:49:18,880 --> 00:49:21,520
code sandbox i would say

00:49:20,160 --> 00:49:23,280
what i'd probably do and what i've done

00:49:21,520 --> 00:49:25,599
with a lot of

00:49:23,280 --> 00:49:26,880
companies or groups or open source you

00:49:25,599 --> 00:49:28,559
know authors is

00:49:26,880 --> 00:49:30,480
i'll try to get hold of them and say hey

00:49:28,559 --> 00:49:32,240
have you heard of this

00:49:30,480 --> 00:49:34,160
give it a shot if you need some help let

00:49:32,240 --> 00:49:34,800
me know i think it could work out well

00:49:34,160 --> 00:49:36,079
so

00:49:34,800 --> 00:49:37,520
since you brought up the idea of code

00:49:36,079 --> 00:49:38,720
sandbox i'll probably try to find out

00:49:37,520 --> 00:49:40,319
who

00:49:38,720 --> 00:49:42,160
how to get in touch with the with the

00:49:40,319 --> 00:49:42,720
people who run it and see if they think

00:49:42,160 --> 00:49:44,000
that

00:49:42,720 --> 00:49:45,760
this is something that could help them

00:49:44,000 --> 00:49:47,359
then if it is i'm more than happy to

00:49:45,760 --> 00:49:49,520
give some time to actually make that a

00:49:47,359 --> 00:49:50,720
reality um i can't remember their names

00:49:49,520 --> 00:49:52,640
but i know they're very active on

00:49:50,720 --> 00:49:54,480
twitter and very open to collaboration

00:49:52,640 --> 00:49:55,760
um as far as i can tell from seeing them

00:49:54,480 --> 00:49:58,400
online

00:49:55,760 --> 00:49:59,520
i know i think it's called blitz or bits

00:49:58,400 --> 00:50:02,240
um

00:49:59,520 --> 00:50:04,319
with a z they do like component

00:50:02,240 --> 00:50:05,040
libraries but like in the clouds you can

00:50:04,319 --> 00:50:07,040
manage your

00:50:05,040 --> 00:50:08,480
components through like a ui i know they

00:50:07,040 --> 00:50:10,480
wrote an article on

00:50:08,480 --> 00:50:11,520
using module or using module federation

00:50:10,480 --> 00:50:13,200
with their system

00:50:11,520 --> 00:50:14,640
and it was pretty cool because it was

00:50:13,200 --> 00:50:16,000
just a library of components you could

00:50:14,640 --> 00:50:17,520
kind of choose what you want

00:50:16,000 --> 00:50:19,200
and they were always evergreen and they

00:50:17,520 --> 00:50:20,880
were decentralized so

00:50:19,200 --> 00:50:23,280
yeah i could definitely see some you

00:50:20,880 --> 00:50:24,559
know other more commercially products

00:50:23,280 --> 00:50:27,760
starting to leverage this

00:50:24,559 --> 00:50:29,280
okay um is a code sandbox demo something

00:50:27,760 --> 00:50:32,720
that you've got in that little

00:50:29,280 --> 00:50:34,960
web page of resources no

00:50:32,720 --> 00:50:36,160
i do not mostly because my bandwidth is

00:50:34,960 --> 00:50:38,240
so constrained that

00:50:36,160 --> 00:50:39,359
like all of my little examples that i

00:50:38,240 --> 00:50:42,800
show are

00:50:39,359 --> 00:50:45,839
just like uh you know from 10 to 12

00:50:42,800 --> 00:50:47,280
at night i'll be have an idea and crash

00:50:45,839 --> 00:50:49,839
it out and then

00:50:47,280 --> 00:50:51,680
ta-da there we go so uh no i don't but

00:50:49,839 --> 00:50:53,440
if anybody wants to try one i will

00:50:51,680 --> 00:50:54,000
happily get hold of you on twitter and

00:50:53,440 --> 00:50:55,359
we can figure

00:50:54,000 --> 00:50:58,400
it out it's purely been there hasn't

00:50:55,359 --> 00:51:00,480
been an ask and i haven't had the uh

00:50:58,400 --> 00:51:01,760
the time okay thomas it sounds like

00:51:00,480 --> 00:51:02,400
there's a way there for you to get

00:51:01,760 --> 00:51:05,440
involved with

00:51:02,400 --> 00:51:06,960
uh webpack module federation in some way

00:51:05,440 --> 00:51:08,800
um speaking of getting involved is this

00:51:06,960 --> 00:51:10,559
something that people can openly

00:51:08,800 --> 00:51:13,599
contribute to at the moment or are we

00:51:10,559 --> 00:51:15,520
a little bit away from that you can

00:51:13,599 --> 00:51:16,720
openly contribute to it but i would say

00:51:15,520 --> 00:51:18,880
that the feature is pretty much

00:51:16,720 --> 00:51:20,319
done and coded yeah um there's like one

00:51:18,880 --> 00:51:21,680
or two outstanding pieces it's been

00:51:20,319 --> 00:51:24,559
about i think

00:51:21,680 --> 00:51:25,359
six months of rebuilding webpack five to

00:51:24,559 --> 00:51:29,119
get it there

00:51:25,359 --> 00:51:31,440
um and yeah i i would say

00:51:29,119 --> 00:51:32,640
if you know webpack's internal apis well

00:51:31,440 --> 00:51:34,319
especially fives

00:51:32,640 --> 00:51:36,000
and there's definitely always room for

00:51:34,319 --> 00:51:38,640
for contribution but

00:51:36,000 --> 00:51:40,000
um i've been you know coding the webpack

00:51:38,640 --> 00:51:42,240
core since webpack one

00:51:40,000 --> 00:51:45,040
and even doing some of this stuff with

00:51:42,240 --> 00:51:47,119
module federation was outside my uh

00:51:45,040 --> 00:51:48,960
my sanity limits and i had to have

00:51:47,119 --> 00:51:50,880
tobias code parts of

00:51:48,960 --> 00:51:52,720
of this because it's pretty hairy in

00:51:50,880 --> 00:51:54,160
there but it's definitely good to read

00:51:52,720 --> 00:51:56,160
and if you want to try and contribute

00:51:54,160 --> 00:51:57,760
then totally do either way it's a great

00:51:56,160 --> 00:51:58,240
learning experience and a great way to

00:51:57,760 --> 00:52:00,720
kind of

00:51:58,240 --> 00:52:01,680
understand more about how webpack works

00:52:00,720 --> 00:52:03,839
under the hood

00:52:01,680 --> 00:52:05,040
okay so probably not somebody's fast

00:52:03,839 --> 00:52:08,240
contribution but

00:52:05,040 --> 00:52:09,280
you are open to it in principle oh yeah

00:52:08,240 --> 00:52:10,880
totally um

00:52:09,280 --> 00:52:12,480
i would say if you're looking for first

00:52:10,880 --> 00:52:14,240
contributions what i do with like some

00:52:12,480 --> 00:52:15,839
engineers at my company and so on

00:52:14,240 --> 00:52:17,839
they want to get involved with it i say

00:52:15,839 --> 00:52:18,079
hey make some tutorials about it you

00:52:17,839 --> 00:52:19,839
know

00:52:18,079 --> 00:52:21,520
it's your first time going through it

00:52:19,839 --> 00:52:22,240
we'll jump on a call we'll do like a

00:52:21,520 --> 00:52:24,559
quick

00:52:22,240 --> 00:52:26,240
you know one of my most basic demos get

00:52:24,559 --> 00:52:27,680
button to load from here and button to

00:52:26,240 --> 00:52:29,200
load over there and have each app

00:52:27,680 --> 00:52:31,680
interchange their buttons

00:52:29,200 --> 00:52:32,640
and then uh you know i'll kind of say

00:52:31,680 --> 00:52:34,640
okay cool

00:52:32,640 --> 00:52:35,680
now that you've got that under your belt

00:52:34,640 --> 00:52:37,040
um

00:52:35,680 --> 00:52:38,800
you know what do you want to build and

00:52:37,040 --> 00:52:39,680
then i'll throw out some ideas on how or

00:52:38,800 --> 00:52:42,079
what or why

00:52:39,680 --> 00:52:43,760
um but that's generally what i would say

00:52:42,079 --> 00:52:45,520
or try something new that's not in my

00:52:43,760 --> 00:52:47,200
examples repo and then pull requests

00:52:45,520 --> 00:52:48,800
back the examples repo

00:52:47,200 --> 00:52:50,400
and that's also a really great way to

00:52:48,800 --> 00:52:52,880
get involved and to show off other

00:52:50,400 --> 00:52:53,760
examples or even refine my existing ones

00:52:52,880 --> 00:52:56,160
because

00:52:53,760 --> 00:52:58,640
i mean it's you know time there's always

00:52:56,160 --> 00:53:00,480
better solutions to whatever i

00:52:58,640 --> 00:53:01,839
you know conjure up in there so if you

00:53:00,480 --> 00:53:03,680
see something better you see something

00:53:01,839 --> 00:53:05,760
you want to fix it's also a good way to

00:53:03,680 --> 00:53:07,359
get involved you know with an official

00:53:05,760 --> 00:53:11,040
module federation

00:53:07,359 --> 00:53:12,880
repo or system awesome um so thomas

00:53:11,040 --> 00:53:14,880
definitely get involved

00:53:12,880 --> 00:53:16,640
so we've got one last question before we

00:53:14,880 --> 00:53:19,280
uh wrap this one up

00:53:16,640 --> 00:53:21,839
if i managed app a and pulled in the

00:53:19,280 --> 00:53:23,839
latest version of a button component

00:53:21,839 --> 00:53:24,960
how do i ensure that i don't break

00:53:23,839 --> 00:53:28,880
someone else's app

00:53:24,960 --> 00:53:30,880
who also depends upon that button

00:53:28,880 --> 00:53:32,240
all right is there a way to test this as

00:53:30,880 --> 00:53:35,440
well

00:53:32,240 --> 00:53:36,319
um yeah okay well uh

00:53:35,440 --> 00:53:38,880
you sure you don't want to be a

00:53:36,319 --> 00:53:38,880
contributor

00:53:39,119 --> 00:53:42,800
so okay i'm serious though yeah so

00:53:41,599 --> 00:53:45,280
testing um

00:53:42,800 --> 00:53:46,559
is a little tricky uh i have not

00:53:45,280 --> 00:53:48,240
actually tried this

00:53:46,559 --> 00:53:50,240
in theory or i haven't tried it in

00:53:48,240 --> 00:53:52,160
practice but i know in theory it'll work

00:53:50,240 --> 00:53:54,559
uh what it would involve is you could do

00:53:52,160 --> 00:53:58,000
unit tests federated unit tests

00:53:54,559 --> 00:54:00,240
make just be built out by webpack

00:53:58,000 --> 00:54:01,760
and pretty much put the dynamic import

00:54:00,240 --> 00:54:03,440
mechanism somewhere in there everything

00:54:01,760 --> 00:54:04,400
else can be synchronous and jess will be

00:54:03,440 --> 00:54:06,079
fine with it

00:54:04,400 --> 00:54:07,680
uh and then you it would essentially

00:54:06,079 --> 00:54:11,440
just would be pulling in

00:54:07,680 --> 00:54:12,880
the test files on demand um

00:54:11,440 --> 00:54:14,160
for doing something like this i would

00:54:12,880 --> 00:54:15,680
say it'd probably be easier to just have

00:54:14,160 --> 00:54:17,200
it locally installed so you're

00:54:15,680 --> 00:54:19,280
because it's all going to run on node

00:54:17,200 --> 00:54:20,800
and i don't really have module streaming

00:54:19,280 --> 00:54:23,040
to a point where i'm going to publicly

00:54:20,800 --> 00:54:25,280
talk about it so you would need the file

00:54:23,040 --> 00:54:26,000
to have disk access to perform your

00:54:25,280 --> 00:54:27,920
testing

00:54:26,000 --> 00:54:29,680
um if you want to do like standard unit

00:54:27,920 --> 00:54:31,760
tests so some of the ideas that i have

00:54:29,680 --> 00:54:32,160
around how you can stop this is one we

00:54:31,760 --> 00:54:34,400
have

00:54:32,160 --> 00:54:36,160
you can't just create versioned remotes

00:54:34,400 --> 00:54:37,280
so your remote could have a version

00:54:36,160 --> 00:54:39,280
attached to it

00:54:37,280 --> 00:54:41,200
and you could then just manage which

00:54:39,280 --> 00:54:43,599
version of the remote gets loaded

00:54:41,200 --> 00:54:44,799
um so if you change any change that

00:54:43,599 --> 00:54:45,680
comes along you could either go

00:54:44,799 --> 00:54:48,400
evergreen or

00:54:45,680 --> 00:54:48,720
managed depending on what you want then

00:54:48,400 --> 00:54:50,480
it's

00:54:48,720 --> 00:54:52,799
you won't break anything else and if you

00:54:50,480 --> 00:54:54,720
do it's only because somebody bumped up

00:54:52,799 --> 00:54:55,520
to a new version kind of like how npm

00:54:54,720 --> 00:54:56,960
would be

00:54:55,520 --> 00:54:58,400
but this could all happen at runtime

00:54:56,960 --> 00:55:00,000
which means you could also control this

00:54:58,400 --> 00:55:01,440
at runtime on the other end

00:55:00,000 --> 00:55:03,599
where i could have something like

00:55:01,440 --> 00:55:05,440
dashboard just change

00:55:03,599 --> 00:55:07,680
the version of where my remote should

00:55:05,440 --> 00:55:08,640
come from and i could just pull in

00:55:07,680 --> 00:55:10,400
different deploys

00:55:08,640 --> 00:55:12,160
you know at will without needing to

00:55:10,400 --> 00:55:14,559
redeploy or do anything with

00:55:12,160 --> 00:55:16,240
like our infrastructure um other than

00:55:14,559 --> 00:55:17,119
you know change who should have what

00:55:16,240 --> 00:55:19,200
right now

00:55:17,119 --> 00:55:20,559
so yeah there's plenty of ways to do it

00:55:19,200 --> 00:55:22,079
um

00:55:20,559 --> 00:55:24,160
i probably should make a video about it

00:55:22,079 --> 00:55:26,720
but i would say another area would be uh

00:55:24,160 --> 00:55:29,839
i i'm using something called like uh

00:55:26,720 --> 00:55:31,440
api like module api contracts

00:55:29,839 --> 00:55:33,200
so when you expose something i don't

00:55:31,440 --> 00:55:35,119
just expose like the vanilla thing and

00:55:33,200 --> 00:55:36,559
i'll usually use this on like context or

00:55:35,119 --> 00:55:40,319
something when i want to share them

00:55:36,559 --> 00:55:43,280
but uh the idea is i want to provide

00:55:40,319 --> 00:55:45,599
a standardized way to just like a

00:55:43,280 --> 00:55:46,880
restful api there's a data contract

00:55:45,599 --> 00:55:48,480
this thing's going to take this and it's

00:55:46,880 --> 00:55:49,839
going to work and if you don't give it

00:55:48,480 --> 00:55:51,680
this it's not going to work

00:55:49,839 --> 00:55:53,280
so when i want to build unit tests what

00:55:51,680 --> 00:55:56,400
you could do as a provider of

00:55:53,280 --> 00:55:58,559
these things you could have a

00:55:56,400 --> 00:56:00,000
you know very simple little kind of

00:55:58,559 --> 00:56:01,599
wrapper that pretty much

00:56:00,000 --> 00:56:03,119
checks yes this is going to work or no

00:56:01,599 --> 00:56:04,960
it's not and then

00:56:03,119 --> 00:56:06,319
the data contract is you need to provide

00:56:04,960 --> 00:56:08,319
things like this this and this

00:56:06,319 --> 00:56:09,920
otherwise it's it's not going to render

00:56:08,319 --> 00:56:11,680
and you can unit test to make sure that

00:56:09,920 --> 00:56:12,480
you don't break the contract that you've

00:56:11,680 --> 00:56:14,720
created

00:56:12,480 --> 00:56:16,079
um it is like one extra step in there

00:56:14,720 --> 00:56:18,960
but if we're looking for that level

00:56:16,079 --> 00:56:19,760
of like security at enterprise and you

00:56:18,960 --> 00:56:20,960
know really want to make sure

00:56:19,760 --> 00:56:24,079
everything's going to work

00:56:20,960 --> 00:56:25,359
then i would say it's a it's a decent

00:56:24,079 --> 00:56:27,920
option to consider

00:56:25,359 --> 00:56:29,760
um but you know there's ways around it i

00:56:27,920 --> 00:56:31,359
personally i don't have too many issues

00:56:29,760 --> 00:56:33,680
with this just because like

00:56:31,359 --> 00:56:35,760
we we manage it relatively well and

00:56:33,680 --> 00:56:37,280
we're also smart about what we use

00:56:35,760 --> 00:56:39,520
so just because you can doesn't mean you

00:56:37,280 --> 00:56:41,680
should so consider

00:56:39,520 --> 00:56:44,079
where federation fits i want to share

00:56:41,680 --> 00:56:47,200
react really bad i have you know

00:56:44,079 --> 00:56:48,960
35 teams and several uh micro front-ends

00:56:47,200 --> 00:56:50,880
so i don't really care about button but

00:56:48,960 --> 00:56:53,040
i really care about the whole page

00:56:50,880 --> 00:56:54,720
so i share at the root level and then i

00:56:53,040 --> 00:56:56,480
share at my dependency level for things

00:56:54,720 --> 00:56:57,119
like the pattern library and stuff like

00:56:56,480 --> 00:56:59,119
that

00:56:57,119 --> 00:57:00,720
um and then if there's one or two custom

00:56:59,119 --> 00:57:02,720
components like let's say i have like a

00:57:00,720 --> 00:57:04,160
checkout add to cart modal

00:57:02,720 --> 00:57:07,440
then i'd like that to live in the

00:57:04,160 --> 00:57:09,040
checkout team who maintains it not in

00:57:07,440 --> 00:57:10,720
some other micro front end just because

00:57:09,040 --> 00:57:12,000
they need to pop up and show it

00:57:10,720 --> 00:57:14,480
and then have the team have to jump

00:57:12,000 --> 00:57:15,920
between two repos one they own and one

00:57:14,480 --> 00:57:18,240
they're only there because they own a

00:57:15,920 --> 00:57:19,200
component um so that's really where i

00:57:18,240 --> 00:57:21,119
try to go with it

00:57:19,200 --> 00:57:22,480
also i would say a big thing is start

00:57:21,119 --> 00:57:24,640
small start safe

00:57:22,480 --> 00:57:26,480
see how it works and then you build up

00:57:24,640 --> 00:57:28,319
things around it um

00:57:26,480 --> 00:57:30,000
but in my experience i really don't

00:57:28,319 --> 00:57:31,760
think that if you're going full swing

00:57:30,000 --> 00:57:33,040
into federated apps i really don't think

00:57:31,760 --> 00:57:34,799
that we're going to have too many issues

00:57:33,040 --> 00:57:36,240
with versioning or testing

00:57:34,799 --> 00:57:38,640
or anything like that because everything

00:57:36,240 --> 00:57:41,520
that i've seen so far it already shows

00:57:38,640 --> 00:57:42,960
very promising that there's not too many

00:57:41,520 --> 00:57:44,720
problems like not too many things we're

00:57:42,960 --> 00:57:47,280
going to be hinged by

00:57:44,720 --> 00:57:48,559
perfect so it shouldn't be a problem but

00:57:47,280 --> 00:57:52,400
in theory

00:57:48,559 --> 00:57:54,880
it's a summary yeah like for unit tests

00:57:52,400 --> 00:57:56,000
shouldn't be a problem in theory module

00:57:54,880 --> 00:57:57,200
contracts you know that would be

00:57:56,000 --> 00:57:58,640
something manual you would come up with

00:57:57,200 --> 00:58:00,640
like a pattern just like

00:57:58,640 --> 00:58:01,680
if you treat it like a restful api then

00:58:00,640 --> 00:58:04,000
okay i

00:58:01,680 --> 00:58:06,319
the module takes props and i have you

00:58:04,000 --> 00:58:08,400
know strict validation on those and

00:58:06,319 --> 00:58:09,599
or whatever and send it to sentry if

00:58:08,400 --> 00:58:11,280
somebody errors it

00:58:09,599 --> 00:58:13,119
or automatically roll back to the

00:58:11,280 --> 00:58:14,400
previous remote because

00:58:13,119 --> 00:58:16,480
you know keep that remote deployed

00:58:14,400 --> 00:58:19,119
somewhere and those patterns take

00:58:16,480 --> 00:58:20,640
very little time to implement once you

00:58:19,119 --> 00:58:22,559
get a feel for module federation which

00:58:20,640 --> 00:58:23,920
is why i say start simple um

00:58:22,559 --> 00:58:25,599
because all of these i was just like oh

00:58:23,920 --> 00:58:28,079
cool well if i you know

00:58:25,599 --> 00:58:29,680
put the remote entry.js on the cdn but

00:58:28,079 --> 00:58:31,280
put it in a folder

00:58:29,680 --> 00:58:32,720
with all the other chunks on the flat

00:58:31,280 --> 00:58:34,720
level then all i need to do is change

00:58:32,720 --> 00:58:36,319
the url of my remote entry

00:58:34,720 --> 00:58:38,480
and it'll just pull in whatever chunks

00:58:36,319 --> 00:58:40,000
it wants at the flat level on the cdm

00:58:38,480 --> 00:58:42,000
which is a really nice way to just flip

00:58:40,000 --> 00:58:44,319
between remotes or version the remotes

00:58:42,000 --> 00:58:46,480
you keep the deploy all on one level if

00:58:44,319 --> 00:58:47,760
they if the modules didn't change the

00:58:46,480 --> 00:58:49,440
hashes will be the same so you get

00:58:47,760 --> 00:58:50,720
higher caching capability

00:58:49,440 --> 00:58:53,119
the only thing you're separating into

00:58:50,720 --> 00:58:56,160
like a human known like

00:58:53,119 --> 00:58:59,280
url format would be the remote entry

00:58:56,160 --> 00:59:00,559
file or the the path to it um you know

00:58:59,280 --> 00:59:03,680
whatever.com

00:59:00,559 --> 00:59:05,040
v 1.1 slash remote entry js and remote

00:59:03,680 --> 00:59:07,440
entry.js just goes to

00:59:05,040 --> 00:59:08,799
whatever.com assets and gets all of its

00:59:07,440 --> 00:59:10,480
chunks off the top level

00:59:08,799 --> 00:59:12,480
so you know there's there's lots of ways

00:59:10,480 --> 00:59:13,520
to safeguard it and also just to start

00:59:12,480 --> 00:59:15,040
experimenting and

00:59:13,520 --> 00:59:16,559
once you try one or two of these things

00:59:15,040 --> 00:59:18,160
you're gonna see oh okay well to do this

00:59:16,559 --> 00:59:18,960
is gonna be pretty easy i would say the

00:59:18,160 --> 00:59:21,280
one area that

00:59:18,960 --> 00:59:23,119
is going to be a little tricky is server

00:59:21,280 --> 00:59:25,119
side pulling those remotes in

00:59:23,119 --> 00:59:28,000
um if you want to do like server-side

00:59:25,119 --> 00:59:29,119
unit tests but we will soon be releasing

00:59:28,000 --> 00:59:30,400
a streamed module

00:59:29,119 --> 00:59:32,640
not through webpack but through the

00:59:30,400 --> 00:59:34,319
module federation group and streaming

00:59:32,640 --> 00:59:35,200
will essentially make node work like it

00:59:34,319 --> 00:59:37,200
does in a browser

00:59:35,200 --> 00:59:39,119
it will go over the internet or over the

00:59:37,200 --> 00:59:40,960
network to download its chunks just like

00:59:39,119 --> 00:59:42,640
a code split browser app would

00:59:40,960 --> 00:59:44,079
except the chunks i'm downloading come

00:59:42,640 --> 00:59:44,960
from separate webpack builds on the

00:59:44,079 --> 00:59:46,559
server as well

00:59:44,960 --> 00:59:47,839
so that gives us a huge unlock because

00:59:46,559 --> 00:59:49,040
now we don't need to worry about where

00:59:47,839 --> 00:59:51,040
is it on the disk

00:59:49,040 --> 00:59:52,720
it's just just like in the browser give

00:59:51,040 --> 00:59:54,559
it a url and it'll get the script

00:59:52,720 --> 00:59:56,880
well that sounds perfect and on that

00:59:54,559 --> 00:59:58,319
amazing feature announcement and we're

00:59:56,880 --> 00:59:58,880
going to have to call time on this i'm

00:59:58,319 --> 01:00:01,200
afraid

00:59:58,880 --> 01:00:02,559
zach where can people find you online if

01:00:01,200 --> 01:00:04,079
they want to follow up on anything

01:00:02,559 --> 01:00:07,200
you've said

01:00:04,079 --> 01:00:09,920
twitter uh twitter github

01:00:07,200 --> 01:00:10,720
all my user handles across everything is

01:00:09,920 --> 01:00:13,280
scripted

01:00:10,720 --> 01:00:14,559
alchemy so you can find me on

01:00:13,280 --> 01:00:17,440
twitter.com

01:00:14,559 --> 01:00:18,720
uh just scripted alchemy or zack jackson

01:00:17,440 --> 01:00:20,160
and that's my central point of

01:00:18,720 --> 01:00:22,640
communication right now

01:00:20,160 --> 01:00:24,480
um so get me on twitter and any

01:00:22,640 --> 01:00:25,520
questions you have i'm pretty open so

01:00:24,480 --> 01:00:26,960
don't be scared

01:00:25,520 --> 01:00:29,119
um i can get lost in a random

01:00:26,960 --> 01:00:31,040
conversation for an hour with somebody

01:00:29,119 --> 01:00:32,960
who just had a simple conversation

01:00:31,040 --> 01:00:35,280
so really like don't be scared you got

01:00:32,960 --> 01:00:36,960
questions half the success of this

01:00:35,280 --> 01:00:38,480
is making sure everybody understands it

01:00:36,960 --> 01:00:39,520
and is comfortable with it and also

01:00:38,480 --> 01:00:41,280
getting your feedback

01:00:39,520 --> 01:00:42,799
because we have the ability to change

01:00:41,280 --> 01:00:45,280
webpack for

01:00:42,799 --> 01:00:45,920
for now so the more feedback that we

01:00:45,280 --> 01:00:47,920
have the

01:00:45,920 --> 01:00:50,240
the more change we can make on the core

01:00:47,920 --> 01:00:52,480
before we actually go into rc

01:00:50,240 --> 01:00:54,160
very wise words zach thank you very much

01:00:52,480 --> 01:00:55,599
for an amazing talk thank you for this

01:00:54,160 --> 01:00:57,760
amazing conversation i think we could

01:00:55,599 --> 01:01:00,079
carry on for hours but unfortunately

01:00:57,760 --> 01:01:02,160
we've got another q a starting shortly

01:01:00,079 --> 01:01:02,960
um zach thank you again and thank you

01:01:02,160 --> 01:01:05,280
for all the time

01:01:02,960 --> 01:01:06,240
you and the team put into webpack i'm

01:01:05,280 --> 01:01:08,640
sure

01:01:06,240 --> 01:01:09,760
most people at this conference use it

01:01:08,640 --> 01:01:12,799
either daily or

01:01:09,760 --> 01:01:16,160
weekly you've saved all of these people

01:01:12,799 --> 01:01:18,400
thousands of hours i'm guessing i hope

01:01:16,160 --> 01:01:20,000
so that's the intent so um yeah

01:01:18,400 --> 01:01:21,520
looking forward if anybody has anything

01:01:20,000 --> 01:01:21,920
wants to mention anything find me on

01:01:21,520 --> 01:01:23,280
twitter

01:01:21,920 --> 01:01:25,680
otherwise thanks for coming and

01:01:23,280 --> 01:01:27,520
listening to to my talk and thank you

01:01:25,680 --> 01:01:30,079
for having me uh to all the hosts

01:01:27,520 --> 01:01:39,839
who are part of this awesome catch you

01:01:30,079 --> 01:01:39,839
soon zach and see you later everyone

01:01:42,079 --> 01:01:44,160

YouTube URL: https://www.youtube.com/watch?v=-ei6RqZilYI


