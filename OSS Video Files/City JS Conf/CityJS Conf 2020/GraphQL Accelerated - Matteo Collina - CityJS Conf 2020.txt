Title: GraphQL Accelerated - Matteo Collina - CityJS Conf 2020
Publication date: 2020-10-03
Playlist: CityJS Conf 2020
Description: 
	GraphQL is a query language that is rapidly gaining wide adoption across the community.
It combines type validation with a query and filtering syntax that makes it easy to get up-and-running with a powerful web API in almost no time. Features like running parallel queries or update-all become much easier, because they are first class citizens of GraphQL. Add to that a vibrant community that keeps creating excellent tooling and documentation,  it’s clear why GraphQL has become so popular with developers

Every abstraction has a cost, and GraphQL is no exception. The added complexity and a new schema format to parse and execute mean new performance bottlenecks. In addition to performance issues, the wrong use of GraphQL can lead to architectural bottlenecks. 

Instead of viewing this as a problem we took this as a challenge.

In this talk we’ll cover what GraphQL is, why it’s great and how we made it run a lot faster on Node.js, in fact *much* faster, using different performance techniques that we have learned in the last few years.
"

Bio
Matteo is Technical Director at NearForm, where he consults for some of the top brands in the world. In 2014, he defended his Ph.D. thesis titled ""Application Platforms for the Internet of Things"". Matteo is a member of the Node.js Technical Steering Committee focusing on streams, diagnostics and http. He is also the author of the fast logger Pino and of the Fastify web framework. Matteo is a renowned international speaker after presenting at more than 50 conferences, including Node.js Interactive, NodeConf.eu, NodeSummit, JSConf.Asia, WebRebels, and JsDay just to name a few. He is also co-author of the book ""Node.js Cookbook, Third Edition"" edited by Packt. In the summer he loves sailing the Sirocco.

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:18,060 --> 00:00:22,720
[Music]

00:00:22,080 --> 00:00:24,800
everyone

00:00:22,720 --> 00:00:27,039
i am mateo kolina and i'm here to talk

00:00:24,800 --> 00:00:28,800
to you today about graphql

00:00:27,039 --> 00:00:30,800
please take a moment to follow me on

00:00:28,800 --> 00:00:31,679
twitter at matukolina i tweet about

00:00:30,800 --> 00:00:33,760
various things

00:00:31,679 --> 00:00:35,280
and so on technology open source

00:00:33,760 --> 00:00:37,120
ramblings i don't know making things

00:00:35,280 --> 00:00:38,960
fast

00:00:37,120 --> 00:00:41,040
note that i'm a technical director at

00:00:38,960 --> 00:00:42,079
near firm so we are a professional

00:00:41,040 --> 00:00:43,680
services company

00:00:42,079 --> 00:00:46,000
based all over the world so if you need

00:00:43,680 --> 00:00:49,280
some help with javascript

00:00:46,000 --> 00:00:50,719
or deployments or architecture software

00:00:49,280 --> 00:00:55,360
architectures whatever

00:00:50,719 --> 00:00:58,239
we are here to help so let's get started

00:00:55,360 --> 00:00:58,719
the topic of today is graphql and making

00:00:58,239 --> 00:01:01,760
it

00:00:58,719 --> 00:01:04,640
fast well first let's take talk a little

00:01:01,760 --> 00:01:07,520
bit about graphql itself

00:01:04,640 --> 00:01:08,880
graphql it was a language is a language

00:01:07,520 --> 00:01:11,840
that was invented by

00:01:08,880 --> 00:01:12,720
facebook to describe their their

00:01:11,840 --> 00:01:15,840
entirety

00:01:12,720 --> 00:01:18,320
of uh their own apis

00:01:15,840 --> 00:01:19,439
and you know we can start from

00:01:18,320 --> 00:01:22,799
describing

00:01:19,439 --> 00:01:26,240
the um how you could model

00:01:22,799 --> 00:01:27,840
facebook using rest with rest which rest

00:01:26,240 --> 00:01:29,840
and http one and so on

00:01:27,840 --> 00:01:31,040
you will do a get to get your facebook

00:01:29,840 --> 00:01:34,320
friends uh

00:01:31,040 --> 00:01:36,799
and these will return a list of

00:01:34,320 --> 00:01:38,479
your friends right you would model you

00:01:36,799 --> 00:01:40,400
will build this type of api if you're

00:01:38,479 --> 00:01:43,520
doing the rest

00:01:40,400 --> 00:01:46,159
but if you just want the names

00:01:43,520 --> 00:01:47,840
what would you do well you will create a

00:01:46,159 --> 00:01:51,200
new endpoint right

00:01:47,840 --> 00:01:53,759
or you might create a

00:01:51,200 --> 00:01:54,320
query parameter with an option i don't

00:01:53,759 --> 00:01:57,040
know

00:01:54,320 --> 00:01:58,000
this is non-standard okay it's actually

00:01:57,040 --> 00:02:01,520
very

00:01:58,000 --> 00:02:02,799
very hard to uh to measure this type of

00:02:01,520 --> 00:02:05,360
to build this type of things in a

00:02:02,799 --> 00:02:08,160
standard way so it's

00:02:05,360 --> 00:02:09,679
one of those problems and this means

00:02:08,160 --> 00:02:13,040
that whenever we are building

00:02:09,679 --> 00:02:14,879
new clients um and

00:02:13,040 --> 00:02:17,360
we need to there's no standard way to

00:02:14,879 --> 00:02:19,520
interact so

00:02:17,360 --> 00:02:21,120
it becomes harder and we need to invent

00:02:19,520 --> 00:02:21,760
the with the invent the wheel the whole

00:02:21,120 --> 00:02:24,480
time

00:02:21,760 --> 00:02:25,040
it turns out that in some long time ago

00:02:24,480 --> 00:02:28,319
i was

00:02:25,040 --> 00:02:32,879
building an api for

00:02:28,319 --> 00:02:34,879
a mobile app that i don't know

00:02:32,879 --> 00:02:36,160
different endpoints for android and ios

00:02:34,879 --> 00:02:37,200
because they wanted the data in

00:02:36,160 --> 00:02:39,760
different ways

00:02:37,200 --> 00:02:41,280
so i don't know but that's what kind of

00:02:39,760 --> 00:02:44,640
happened when if you want to have

00:02:41,280 --> 00:02:46,319
all on the if you want if we add the

00:02:44,640 --> 00:02:48,560
likes

00:02:46,319 --> 00:02:50,080
so we want the friends and the likes so

00:02:48,560 --> 00:02:52,640
choose points to make one

00:02:50,080 --> 00:02:55,440
call or we should we create facebook

00:02:52,640 --> 00:02:57,920
friends and likes

00:02:55,440 --> 00:02:58,560
well graphql was built to solve this

00:02:57,920 --> 00:03:02,840
problem

00:02:58,560 --> 00:03:05,760
graphql was built to enable a more

00:03:02,840 --> 00:03:08,959
responsive communication between

00:03:05,760 --> 00:03:09,840
the front end and the back end of of an

00:03:08,959 --> 00:03:11,760
application

00:03:09,840 --> 00:03:12,959
and it can also work for example great

00:03:11,760 --> 00:03:17,120
on mobile

00:03:12,959 --> 00:03:20,159
on vr on

00:03:17,120 --> 00:03:22,159
and also of course on the web

00:03:20,159 --> 00:03:23,360
so how do we how we build stuff with

00:03:22,159 --> 00:03:26,159
graphql

00:03:23,360 --> 00:03:27,280
well we start with doing a very very

00:03:26,159 --> 00:03:31,519
simple query

00:03:27,280 --> 00:03:34,640
which is we can get the friends

00:03:31,519 --> 00:03:36,400
and we want the friend named mathias and

00:03:34,640 --> 00:03:39,440
we get the name of the friend name

00:03:36,400 --> 00:03:41,920
matthias hello and you know

00:03:39,440 --> 00:03:44,080
this means that we can only select the

00:03:41,920 --> 00:03:47,280
properties that we want to see

00:03:44,080 --> 00:03:50,799
which is great because we can only

00:03:47,280 --> 00:03:51,280
we don't have to given that the user

00:03:50,799 --> 00:03:54,319
send

00:03:51,280 --> 00:03:55,360
us this query to the graphql endpoint we

00:03:54,319 --> 00:03:58,159
don't know

00:03:55,360 --> 00:04:01,040
we could this filtering and removing

00:03:58,159 --> 00:04:02,560
properties that the client will not need

00:04:01,040 --> 00:04:04,159
it's actually something that graphql

00:04:02,560 --> 00:04:08,080
does us for free

00:04:04,159 --> 00:04:11,200
well more more i will talk more or less

00:04:08,080 --> 00:04:12,959
more on that late it does it for free

00:04:11,200 --> 00:04:15,200
in the send that we don't have to code

00:04:12,959 --> 00:04:16,720
any logic and we don't need to build

00:04:15,200 --> 00:04:19,899
anything

00:04:16,720 --> 00:04:22,400
which is pretty great right i love it

00:04:19,899 --> 00:04:26,560
[Music]

00:04:22,400 --> 00:04:28,960
however you know it's uh

00:04:26,560 --> 00:04:30,560
this works because so this works because

00:04:28,960 --> 00:04:32,240
we have defined the types

00:04:30,560 --> 00:04:33,919
so you see we get the friend we have

00:04:32,240 --> 00:04:36,560
name the country of the age

00:04:33,919 --> 00:04:37,840
and we have friends queried that return

00:04:36,560 --> 00:04:40,960
a friend

00:04:37,840 --> 00:04:44,400
pretty neat right uh this means

00:04:40,960 --> 00:04:48,240
that you know this graphql is also self

00:04:44,400 --> 00:04:50,080
explanatory and it's introspectible so

00:04:48,240 --> 00:04:52,240
you can actually query a graphql

00:04:50,080 --> 00:04:53,840
endpoint to know the schema of that

00:04:52,240 --> 00:04:55,440
graphql endpoint

00:04:53,840 --> 00:04:57,120
which is kind of you know you can ask

00:04:55,440 --> 00:04:59,600
graphql to describe itself which is

00:04:57,120 --> 00:04:59,600
pretty cool

00:05:02,000 --> 00:05:06,160
and it's a you win the query you did so

00:05:04,880 --> 00:05:08,160
in

00:05:06,160 --> 00:05:10,160
okay so you define your types and then

00:05:08,160 --> 00:05:13,360
you define your

00:05:10,160 --> 00:05:15,840
your input your qd input and output

00:05:13,360 --> 00:05:16,960
pretty cool you can also ask two things

00:05:15,840 --> 00:05:18,479
at the same time

00:05:16,960 --> 00:05:20,800
so if you want to have mathias and you

00:05:18,479 --> 00:05:23,199
want to have material you can actually

00:05:20,800 --> 00:05:24,720
ask the two things you can access the

00:05:23,199 --> 00:05:28,400
two things in parallel

00:05:24,720 --> 00:05:29,680
you can also specify in names parame

00:05:28,400 --> 00:05:31,520
you can also specify different

00:05:29,680 --> 00:05:32,720
properties you can name those queries

00:05:31,520 --> 00:05:35,199
not the results

00:05:32,720 --> 00:05:36,479
it's pretty great in fact you can even

00:05:35,199 --> 00:05:38,720
have variables

00:05:36,479 --> 00:05:40,400
in there that you can pass in which

00:05:38,720 --> 00:05:43,600
which is which will look like

00:05:40,400 --> 00:05:44,320
you know prepared statements and so you

00:05:43,600 --> 00:05:49,120
can avoid

00:05:44,320 --> 00:05:49,120
you know graphical injections of course

00:05:49,199 --> 00:05:55,120
all of these has created a super rich

00:05:52,639 --> 00:05:58,479
ecosystem in the graphql community

00:05:55,120 --> 00:06:01,840
which is fantastic and because you know

00:05:58,479 --> 00:06:04,000
you can have libraries for all possible

00:06:01,840 --> 00:06:05,280
four possible languages on the backend

00:06:04,000 --> 00:06:08,240
on the front end

00:06:05,280 --> 00:06:10,240
you had we can have you know full

00:06:08,240 --> 00:06:12,639
backhand as a service systems

00:06:10,240 --> 00:06:14,479
that implement graphql so that you don't

00:06:12,639 --> 00:06:15,759
even have to touch the database graphql

00:06:14,479 --> 00:06:17,759
is your database

00:06:15,759 --> 00:06:20,240
um you can build the microservices

00:06:17,759 --> 00:06:22,090
systems with graphql

00:06:20,240 --> 00:06:23,280
you can create

00:06:22,090 --> 00:06:26,000
[Music]

00:06:23,280 --> 00:06:27,520
amazing things and you know you can buy

00:06:26,000 --> 00:06:29,840
graphql systems for

00:06:27,520 --> 00:06:31,199
from every everything everybody or you

00:06:29,840 --> 00:06:35,360
can implement your own in

00:06:31,199 --> 00:06:40,000
java node.js go you name the language

00:06:35,360 --> 00:06:42,720
so it's pretty great well

00:06:40,000 --> 00:06:43,360
because it makes prototyping easy

00:06:42,720 --> 00:06:45,840
because

00:06:43,360 --> 00:06:48,160
you know you can actually quickly

00:06:45,840 --> 00:06:50,639
discover things in graphql

00:06:48,160 --> 00:06:52,400
create your own queries run them and you

00:06:50,639 --> 00:06:53,840
can actually build them things really

00:06:52,400 --> 00:06:56,160
really easily

00:06:53,840 --> 00:06:56,880
well however all this goodness comes at

00:06:56,160 --> 00:07:00,400
a cost

00:06:56,880 --> 00:07:04,479
which is pretty steep to some extent

00:07:00,400 --> 00:07:07,759
one of the key problems is that um

00:07:04,479 --> 00:07:10,560
so just one step back since 2018

00:07:07,759 --> 00:07:12,080
uh several of our customers near from is

00:07:10,560 --> 00:07:12,720
a professional services company as i

00:07:12,080 --> 00:07:16,479
said

00:07:12,720 --> 00:07:19,039
um reached out they started migrating

00:07:16,479 --> 00:07:20,160
from they started migrating from rest to

00:07:19,039 --> 00:07:23,680
graphql

00:07:20,160 --> 00:07:25,199
and they saw that uh graphql their

00:07:23,680 --> 00:07:29,680
graphql implementation

00:07:25,199 --> 00:07:34,319
was underperforming compared to rust

00:07:29,680 --> 00:07:38,160
okay well what can we do here

00:07:34,319 --> 00:07:40,160
now the problem here is that

00:07:38,160 --> 00:07:42,160
so what when we start doing this type of

00:07:40,160 --> 00:07:46,319
things we have our own toolkit

00:07:42,160 --> 00:07:48,639
for uh performance for performance work

00:07:46,319 --> 00:07:50,160
which is called node clinic node clinic

00:07:48,639 --> 00:07:53,280
is a really nice nice

00:07:50,160 --> 00:07:56,240
toolkit that enables us

00:07:53,280 --> 00:07:58,319
to diagnose performance issues so we

00:07:56,240 --> 00:07:59,680
started investigating in their node.js

00:07:58,319 --> 00:08:00,800
application in the client our clients

00:07:59,680 --> 00:08:04,479
node.js application

00:08:00,800 --> 00:08:08,240
why graphql was underperforming

00:08:04,479 --> 00:08:10,639
so we have used for example clinic flame

00:08:08,240 --> 00:08:11,599
which generates with a very very simple

00:08:10,639 --> 00:08:13,840
query

00:08:11,599 --> 00:08:16,240
and which generates a flame graph like

00:08:13,840 --> 00:08:17,360
this and we started using this kind of

00:08:16,240 --> 00:08:20,400
techniques

00:08:17,360 --> 00:08:22,000
to investigate how graphql the graphql

00:08:20,400 --> 00:08:26,000
js implementation the reference

00:08:22,000 --> 00:08:28,000
implementation of graphql was working

00:08:26,000 --> 00:08:30,479
turns out that we have discovered quite

00:08:28,000 --> 00:08:33,360
a few interesting pieces

00:08:30,479 --> 00:08:34,399
first of all for every incoming request

00:08:33,360 --> 00:08:36,479
the server frees

00:08:34,399 --> 00:08:37,839
us to parse the query to produce an

00:08:36,479 --> 00:08:42,719
abstract syntax tree

00:08:37,839 --> 00:08:42,719
and then walk that to execute the query

00:08:42,800 --> 00:08:48,720
wait not just work it once

00:08:45,920 --> 00:08:50,959
it work it twice because it needs to

00:08:48,720 --> 00:08:54,399
first it needs to validate the query

00:08:50,959 --> 00:08:57,440
and then execute it so

00:08:54,399 --> 00:09:00,080
apparently it has two execution that

00:08:57,440 --> 00:09:02,080
needs to happen

00:09:00,080 --> 00:09:03,279
as every performance engineer will tell

00:09:02,080 --> 00:09:07,040
you

00:09:03,279 --> 00:09:10,640
making things fast it's basically

00:09:07,040 --> 00:09:13,440
making things not being executed at all

00:09:10,640 --> 00:09:14,880
so whenever you are doing some any

00:09:13,440 --> 00:09:17,120
bottom-up optimization

00:09:14,880 --> 00:09:19,200
you can actually very quickly see that

00:09:17,120 --> 00:09:21,519
caching is one of your key techniques

00:09:19,200 --> 00:09:23,200
that you can apply almost everywhere so

00:09:21,519 --> 00:09:24,480
that if you have seen those type of

00:09:23,200 --> 00:09:27,200
things before

00:09:24,480 --> 00:09:28,399
you can actually not do the work which

00:09:27,200 --> 00:09:30,399
is fantastic

00:09:28,399 --> 00:09:33,040
because we can actually cache our

00:09:30,399 --> 00:09:36,640
abstracts industries

00:09:33,040 --> 00:09:39,760
well um turns out that i

00:09:36,640 --> 00:09:40,640
since 2016 i've been working on a web

00:09:39,760 --> 00:09:43,839
framework called

00:09:40,640 --> 00:09:47,519
fastify so i have started

00:09:43,839 --> 00:09:48,959
um building an adapter for fastify gql

00:09:47,519 --> 00:09:52,160
back in 2018

00:09:48,959 --> 00:09:54,959
and uh graphql 2018 and in fact you can

00:09:52,160 --> 00:09:58,080
install it using npm install festify gql

00:09:54,959 --> 00:10:00,800
gql it's pretty great and it's neat hey

00:09:58,080 --> 00:10:01,600
great and in fact it's actually very

00:10:00,800 --> 00:10:04,480
simple to use

00:10:01,600 --> 00:10:06,240
you can actually install fastify gql

00:10:04,480 --> 00:10:07,279
create a fastify application and then

00:10:06,240 --> 00:10:10,000
register

00:10:07,279 --> 00:10:12,079
graphql with our fastified gql passing

00:10:10,000 --> 00:10:14,560
in a schema and some resolvers

00:10:12,079 --> 00:10:16,560
it's pretty great you know their solvers

00:10:14,560 --> 00:10:19,839
are if you haven't seen this before

00:10:16,560 --> 00:10:22,720
their solvers are how we

00:10:19,839 --> 00:10:23,839
implement the queries that we're going

00:10:22,720 --> 00:10:26,959
to add

00:10:23,839 --> 00:10:31,279
and it's pretty great right it's simple

00:10:26,959 --> 00:10:34,480
now i've started working on

00:10:31,279 --> 00:10:37,680
and making this run fast how

00:10:34,480 --> 00:10:41,040
well fastify gql user uses a

00:10:37,680 --> 00:10:43,600
least recently used cache lru uh

00:10:41,040 --> 00:10:45,360
to cache stable queries so what is a

00:10:43,600 --> 00:10:46,880
stable query it's a query that we see

00:10:45,360 --> 00:10:48,880
more than once essentially

00:10:46,880 --> 00:10:50,079
so we cache the nuke with the queries

00:10:48,880 --> 00:10:52,800
that the queries that come

00:10:50,079 --> 00:10:53,120
in all the time and so that by caching

00:10:52,800 --> 00:10:56,079
them

00:10:53,120 --> 00:10:57,279
we can avoid uh doing all that expensive

00:10:56,079 --> 00:10:59,279
computation of

00:10:57,279 --> 00:11:01,680
past integrity generating the abstract

00:10:59,279 --> 00:11:02,320
industry and then validating it against

00:11:01,680 --> 00:11:05,120
our schema

00:11:02,320 --> 00:11:05,440
it's a lot of execution in fact these

00:11:05,120 --> 00:11:07,920
can

00:11:05,440 --> 00:11:09,839
actually dramatically improve the

00:11:07,920 --> 00:11:12,160
performance of our application now this

00:11:09,839 --> 00:11:14,399
result might be a little bit old so

00:11:12,160 --> 00:11:15,200
but the difference gap is still there

00:11:14,399 --> 00:11:17,680
those numbers

00:11:15,200 --> 00:11:19,519
have been verified also by others so

00:11:17,680 --> 00:11:21,440
there's a lot of benchmarks out there

00:11:19,519 --> 00:11:22,640
talking about fastify gql and the other

00:11:21,440 --> 00:11:26,480
implementation

00:11:22,640 --> 00:11:26,880
so take it check and verify with your

00:11:26,480 --> 00:11:28,720
own

00:11:26,880 --> 00:11:30,800
but you know you can have a great this

00:11:28,720 --> 00:11:34,399
technique can guarantee you

00:11:30,800 --> 00:11:36,720
huge savings and

00:11:34,399 --> 00:11:38,720
we but then we didn't stop about this in

00:11:36,720 --> 00:11:40,640
public applying this basic caching

00:11:38,720 --> 00:11:42,079
we did additional performance analysis

00:11:40,640 --> 00:11:46,160
using clinic flame

00:11:42,079 --> 00:11:47,120
and it turns out that there were still a

00:11:46,160 --> 00:11:49,200
lot of things

00:11:47,120 --> 00:11:50,639
being executed like there was even the

00:11:49,200 --> 00:11:52,560
execution step

00:11:50,639 --> 00:11:54,160
it's it was hard it was taking a lot of

00:11:52,560 --> 00:11:56,800
time so

00:11:54,160 --> 00:11:58,000
how could we improve it okay how can we

00:11:56,800 --> 00:12:00,560
make it faster

00:11:58,000 --> 00:12:02,000
well we can do all the on the flight

00:12:00,560 --> 00:12:03,680
code generation

00:12:02,000 --> 00:12:05,360
you know how are they will be you take

00:12:03,680 --> 00:12:09,440
the abstract industry

00:12:05,360 --> 00:12:11,440
and you generate some code easy right

00:12:09,440 --> 00:12:12,560
well turns out that there was a library

00:12:11,440 --> 00:12:15,680
ready for that

00:12:12,560 --> 00:12:19,680
which is fantastic um because

00:12:15,680 --> 00:12:19,680
graphql has an enormous

00:12:22,240 --> 00:12:26,560
ecosystem note that when we started

00:12:24,880 --> 00:12:28,480
doing this work this library was not

00:12:26,560 --> 00:12:29,680
there yet we did a talk with our own

00:12:28,480 --> 00:12:32,800
implementation

00:12:29,680 --> 00:12:35,519
and it turns out that they at the

00:12:32,800 --> 00:12:36,720
land was has built a better one and so

00:12:35,519 --> 00:12:39,680
they open sourced it

00:12:36,720 --> 00:12:40,480
and here we go so i'm pretty pleased

00:12:39,680 --> 00:12:43,040
note that

00:12:40,480 --> 00:12:43,839
it this generates the code on the on the

00:12:43,040 --> 00:12:46,240
right side

00:12:43,839 --> 00:12:47,839
of the screen you will see that is the

00:12:46,240 --> 00:12:50,639
generated code from

00:12:47,839 --> 00:12:52,160
uh graphql jit for some very some some

00:12:50,639 --> 00:12:55,440
complicated query

00:12:52,160 --> 00:12:58,079
and however using fql jit

00:12:55,440 --> 00:12:58,959
can actually improve your application

00:12:58,079 --> 00:13:03,360
the execution

00:12:58,959 --> 00:13:06,959
of your graphql queries

00:13:03,360 --> 00:13:09,920
more or less maybe tenfold which is

00:13:06,959 --> 00:13:11,680
great right so yeah you should you

00:13:09,920 --> 00:13:13,920
should definitely

00:13:11,680 --> 00:13:16,000
try it out and see how you can use it

00:13:13,920 --> 00:13:17,760
well you can't use it straight away so

00:13:16,000 --> 00:13:20,000
you need to embed it into your own app

00:13:17,760 --> 00:13:20,880
so fastify gql using our caching

00:13:20,000 --> 00:13:22,880
technique

00:13:20,880 --> 00:13:24,399
and graphqlg to deliver amazing

00:13:22,880 --> 00:13:26,639
performance

00:13:24,399 --> 00:13:29,440
let's look a little bit on how why that

00:13:26,639 --> 00:13:31,680
is gets is

00:13:29,440 --> 00:13:33,200
why that is fast and why compiling it

00:13:31,680 --> 00:13:35,120
can give us great result

00:13:33,200 --> 00:13:36,639
so when you see we see an incoming

00:13:35,120 --> 00:13:37,519
equity if the quit is called we have not

00:13:36,639 --> 00:13:40,240
seen it before

00:13:37,519 --> 00:13:41,680
we need to cache it and interpret but

00:13:40,240 --> 00:13:42,000
then if the query is out if you see

00:13:41,680 --> 00:13:43,600
moved

00:13:42,000 --> 00:13:45,839
more than one time we can actually

00:13:43,600 --> 00:13:47,360
compile it to javascript

00:13:45,839 --> 00:13:51,360
which means working through the absence

00:13:47,360 --> 00:13:53,040
industry and generating the big

00:13:51,360 --> 00:13:54,880
javascript piece that i've shown you in

00:13:53,040 --> 00:13:58,399
the previous slide these

00:13:54,880 --> 00:13:59,680
in turn is actually phenomenal because

00:13:58,399 --> 00:14:01,120
when the quit is still hot the

00:13:59,680 --> 00:14:01,600
javascript function is still out is

00:14:01,120 --> 00:14:04,720
still being

00:14:01,600 --> 00:14:08,079
executed v8 can actually improve it even

00:14:04,720 --> 00:14:09,440
further uh let's talk just a little bit

00:14:08,079 --> 00:14:13,920
about the aggression here

00:14:09,440 --> 00:14:17,600
when v8 sees a new function it takes

00:14:13,920 --> 00:14:19,760
it compiles it to a slow but generic

00:14:17,600 --> 00:14:21,440
binary code because you haven't seen the

00:14:19,760 --> 00:14:22,959
types that are coming in what type of

00:14:21,440 --> 00:14:26,240
objects what type of shapes and so on

00:14:22,959 --> 00:14:28,320
and so forth so

00:14:26,240 --> 00:14:30,079
not super fast but if we scrolling that

00:14:28,320 --> 00:14:33,199
function over and over again

00:14:30,079 --> 00:14:35,279
and it can actually optimize it and it

00:14:33,199 --> 00:14:37,760
takes that slow but generic

00:14:35,279 --> 00:14:38,800
with function with some execution

00:14:37,760 --> 00:14:40,160
metadata about

00:14:38,800 --> 00:14:42,800
what arguments are called how many

00:14:40,160 --> 00:14:44,320
arguments uh what type they are what

00:14:42,800 --> 00:14:47,680
shape and so on so forth

00:14:44,320 --> 00:14:51,199
to and then it optimize it in fastbas

00:14:47,680 --> 00:14:53,440
specific binary code which is great

00:14:51,199 --> 00:14:54,800
which is super fast so we can actually

00:14:53,440 --> 00:14:57,680
get even faster

00:14:54,800 --> 00:14:59,440
than before so when using the our

00:14:57,680 --> 00:15:00,399
graphql jit when using the gt

00:14:59,440 --> 00:15:03,600
implementation

00:15:00,399 --> 00:15:06,880
it's actually even better so

00:15:03,600 --> 00:15:08,560
um so this was kind of

00:15:06,880 --> 00:15:10,639
one of the few reasons that when we

00:15:08,560 --> 00:15:12,800
started using fastified gql

00:15:10,639 --> 00:15:15,279
it has evolved it has grown in fact

00:15:12,800 --> 00:15:16,959
right now it also we have recently added

00:15:15,279 --> 00:15:20,000
some time ago actually last year

00:15:16,959 --> 00:15:22,079
i've added a new feature to talk about

00:15:20,000 --> 00:15:23,760
nested queries nested queries are

00:15:22,079 --> 00:15:26,000
actually one of the key problems when

00:15:23,760 --> 00:15:28,320
implementing graphql solutions

00:15:26,000 --> 00:15:29,519
why let's see that in a second so this

00:15:28,320 --> 00:15:31,680
is the graphical

00:15:29,519 --> 00:15:32,720
web interface which is very typical with

00:15:31,680 --> 00:15:34,720
a typical ide

00:15:32,720 --> 00:15:36,560
web id you can just install inside your

00:15:34,720 --> 00:15:40,000
code instead your app

00:15:36,560 --> 00:15:42,320
and it enables you to diagnose and to

00:15:40,000 --> 00:15:44,639
diagnose and test your graphical queries

00:15:42,320 --> 00:15:45,440
now see that we are running the the dogs

00:15:44,639 --> 00:15:48,480
query

00:15:45,440 --> 00:15:49,360
that um as name and we get the name and

00:15:48,480 --> 00:15:50,800
the owner

00:15:49,360 --> 00:15:52,800
of the we have the name of the dog and

00:15:50,800 --> 00:15:53,199
the name of the owner so what you can

00:15:52,800 --> 00:15:57,199
see

00:15:53,199 --> 00:16:00,320
in normal graphql that you what you do

00:15:57,199 --> 00:16:03,759
is that you are actually

00:16:00,320 --> 00:16:04,720
um you know you you need to fetch all

00:16:03,759 --> 00:16:08,240
this data

00:16:04,720 --> 00:16:10,160
now a normal gradual implement and

00:16:08,240 --> 00:16:11,680
usual graphql implementation that has

00:16:10,160 --> 00:16:14,480
not been optimized

00:16:11,680 --> 00:16:15,440
typically does one query for getting all

00:16:14,480 --> 00:16:17,759
the docs

00:16:15,440 --> 00:16:19,759
but then and queries to getting all the

00:16:17,759 --> 00:16:22,880
owner for all the docs

00:16:19,759 --> 00:16:26,240
this is how typically resolvers works

00:16:22,880 --> 00:16:28,720
which is not um which is a problem right

00:16:26,240 --> 00:16:30,240
because you will if n is too big it will

00:16:28,720 --> 00:16:33,519
explode your databases so

00:16:30,240 --> 00:16:33,920
it would won't work um and so you we're

00:16:33,519 --> 00:16:35,839
going to

00:16:33,920 --> 00:16:39,040
do oneplus and queries it's actually

00:16:35,839 --> 00:16:40,959
very easy to implement this like you

00:16:39,040 --> 00:16:42,079
have almost every graphical

00:16:40,959 --> 00:16:45,360
implementation

00:16:42,079 --> 00:16:47,920
suffer from this problem it can even get

00:16:45,360 --> 00:16:49,120
worse if you go with the nest if you

00:16:47,920 --> 00:16:51,680
nest one more level

00:16:49,120 --> 00:16:54,399
because then you have one query then n

00:16:51,680 --> 00:16:56,560
queries then m queries

00:16:54,399 --> 00:16:57,519
so many queries right for one single

00:16:56,560 --> 00:16:59,600
graph you have

00:16:57,519 --> 00:17:01,360
imagine that in order to to build this

00:16:59,600 --> 00:17:02,959
result we need to call different micro

00:17:01,360 --> 00:17:06,720
services and from different parts of the

00:17:02,959 --> 00:17:08,640
company it's actually very very hard

00:17:06,720 --> 00:17:09,760
in fact we can generalize this and says

00:17:08,640 --> 00:17:14,079
is one plus

00:17:09,760 --> 00:17:14,079
and m times m queries wow

00:17:14,480 --> 00:17:18,160
can get worse because we can even say

00:17:17,039 --> 00:17:21,520
that it's one plus

00:17:18,160 --> 00:17:22,480
and elevated that the at the depth minus

00:17:21,520 --> 00:17:26,160
one queries

00:17:22,480 --> 00:17:29,919
it's a lot of queries

00:17:26,160 --> 00:17:31,520
to our database so well maybe we can do

00:17:29,919 --> 00:17:32,559
something better of course we can do

00:17:31,520 --> 00:17:34,960
something better

00:17:32,559 --> 00:17:37,200
the fade engineers from the the from

00:17:34,960 --> 00:17:39,039
facebook and from the graphql team

00:17:37,200 --> 00:17:40,559
i thought of this pattern called the

00:17:39,039 --> 00:17:43,039
data loader pattern

00:17:40,559 --> 00:17:44,400
which enable us to account to collage

00:17:43,039 --> 00:17:47,840
every single

00:17:44,400 --> 00:17:48,880
all the uh every same thick query into a

00:17:47,840 --> 00:17:51,200
bulk query

00:17:48,880 --> 00:17:51,919
what it what does this mean well this

00:17:51,200 --> 00:17:55,520
means

00:17:51,919 --> 00:17:57,520
that you know when you have the plus n

00:17:55,520 --> 00:17:58,799
in fact in that result instead of doing

00:17:57,520 --> 00:18:01,919
plus and queries

00:17:58,799 --> 00:18:04,640
you will do uh only

00:18:01,919 --> 00:18:05,520
one bulk query with to get all the all

00:18:04,640 --> 00:18:07,360
your

00:18:05,520 --> 00:18:10,320
owners or all your cities or your

00:18:07,360 --> 00:18:12,799
addresses so it's pretty easy

00:18:10,320 --> 00:18:15,039
it's a must have you cannot implement a

00:18:12,799 --> 00:18:16,960
graphql solution a graphql endpoint

00:18:15,039 --> 00:18:19,360
without thinking about the data loader

00:18:16,960 --> 00:18:21,600
pattern otherwise you will have

00:18:19,360 --> 00:18:23,840
significantly significant performance

00:18:21,600 --> 00:18:26,880
issues in your code

00:18:23,840 --> 00:18:29,200
um with data loader you actually go to

00:18:26,880 --> 00:18:30,880
the query so that query so you do one

00:18:29,200 --> 00:18:32,960
query for each level of

00:18:30,880 --> 00:18:34,080
depth in your in your application in

00:18:32,960 --> 00:18:35,919
your application

00:18:34,080 --> 00:18:37,919
in your query which is actually pretty

00:18:35,919 --> 00:18:39,520
great there are a few other modules and

00:18:37,919 --> 00:18:42,799
techniques to limit the depth

00:18:39,520 --> 00:18:45,840
so in reality this can be can be managed

00:18:42,799 --> 00:18:49,440
which is fantastic loving it

00:18:45,840 --> 00:18:52,960
now let's go one step forward we have

00:18:49,440 --> 00:18:54,240
the in fastify gql we also implement

00:18:52,960 --> 00:18:57,440
this pattern

00:18:54,240 --> 00:18:58,400
um same thing but it's actually way way

00:18:57,440 --> 00:19:00,880
easier to use

00:18:58,400 --> 00:19:03,120
than using data order and you can

00:19:00,880 --> 00:19:05,360
instead of just specifying their solvers

00:19:03,120 --> 00:19:07,440
we can also specify a new option called

00:19:05,360 --> 00:19:08,240
loaders which will automatically do it

00:19:07,440 --> 00:19:10,320
for us

00:19:08,240 --> 00:19:11,760
we don't have to do anything just use

00:19:10,320 --> 00:19:14,080
this other pattern you get

00:19:11,760 --> 00:19:16,400
an array of queries instead it's pretty

00:19:14,080 --> 00:19:16,400
great

00:19:17,440 --> 00:19:21,520
last topic before we wrap up it's

00:19:20,000 --> 00:19:24,720
talking about fitter

00:19:21,520 --> 00:19:26,160
the concept of federation apollo has

00:19:24,720 --> 00:19:29,760
defined

00:19:26,160 --> 00:19:33,440
this new concept of graphql federation

00:19:29,760 --> 00:19:36,640
which enables users to developers to

00:19:33,440 --> 00:19:39,600
build a microservice system

00:19:36,640 --> 00:19:41,520
build a graphql endpoint out of little

00:19:39,600 --> 00:19:44,720
microservices each one of them

00:19:41,520 --> 00:19:48,320
serving their own graphql

00:19:44,720 --> 00:19:51,840
endpoint it's pretty great and

00:19:48,320 --> 00:19:52,960
we have also implemented this in fastify

00:19:51,840 --> 00:19:56,240
gql

00:19:52,960 --> 00:19:58,799
and you can easily use it by

00:19:56,240 --> 00:19:59,919
instantiating festive jquestify instance

00:19:58,799 --> 00:20:02,400
with gql

00:19:59,919 --> 00:20:03,760
and specifying a list of services it

00:20:02,400 --> 00:20:05,200
also adds a few features

00:20:03,760 --> 00:20:06,400
that in is not available they they're

00:20:05,200 --> 00:20:09,760
not available in the original

00:20:06,400 --> 00:20:13,600
implementation which for example is um

00:20:09,760 --> 00:20:16,720
subscription support which is great um

00:20:13,600 --> 00:20:19,840
and you can also implement use a fast

00:20:16,720 --> 00:20:21,520
ql to implement services built for a

00:20:19,840 --> 00:20:23,120
federation system

00:20:21,520 --> 00:20:25,919
which is also making them compatible

00:20:23,120 --> 00:20:27,200
with their polar implementation which is

00:20:25,919 --> 00:20:30,640
fantastic

00:20:27,200 --> 00:20:34,559
and you can very easily do them

00:20:30,640 --> 00:20:35,520
by adding the federation metadata and a

00:20:34,559 --> 00:20:39,039
new resolver

00:20:35,520 --> 00:20:40,720
for getting the the reference

00:20:39,039 --> 00:20:43,200
note that i'm using the loaders here

00:20:40,720 --> 00:20:46,960
because i can get a bull query

00:20:43,200 --> 00:20:50,320
of users to get so it's pretty great um

00:20:46,960 --> 00:20:53,280
because it's actually uh fast if i gql

00:20:50,320 --> 00:20:54,080
is focus uh focuses on performance uh we

00:20:53,280 --> 00:20:56,720
have also done

00:20:54,080 --> 00:20:57,840
some uh some benchmarks and some new

00:20:56,720 --> 00:21:01,280
results

00:20:57,840 --> 00:21:04,720
and um you can see

00:21:01,280 --> 00:21:05,280
that we can get almost in a three action

00:21:04,720 --> 00:21:08,400
throughput

00:21:05,280 --> 00:21:10,960
and a quarter of the latency which is

00:21:08,400 --> 00:21:12,000
phenomenal from what from the starting

00:21:10,960 --> 00:21:15,600
point we have

00:21:12,000 --> 00:21:16,400
worked on so um yeah this is this is

00:21:15,600 --> 00:21:19,760
pretty great

00:21:16,400 --> 00:21:23,280
so um the summary of this talk

00:21:19,760 --> 00:21:27,760
is i want to note that uh graphql

00:21:23,280 --> 00:21:31,200
become can become very competitive

00:21:27,760 --> 00:21:34,720
versus building your own rest based

00:21:31,200 --> 00:21:36,799
system and as well as uh

00:21:34,720 --> 00:21:38,559
fastify gql and the festival community

00:21:36,799 --> 00:21:40,640
can help you

00:21:38,559 --> 00:21:41,919
implement that at a bigger scale than

00:21:40,640 --> 00:21:45,679
what you are

00:21:41,919 --> 00:21:49,360
normally would so it's um

00:21:45,679 --> 00:21:52,559
i think it's a it's a pretty good

00:21:49,360 --> 00:21:54,880
tool to have to have on our belt

00:21:52,559 --> 00:21:54,880
and

00:21:55,840 --> 00:21:58,880
i think that's it oh one more thing it's

00:21:58,640 --> 00:22:01,280
a

00:21:58,880 --> 00:22:03,120
checkout fastifying is the the framework

00:22:01,280 --> 00:22:05,280
that i have been demoing

00:22:03,120 --> 00:22:06,720
which is really nice i've been we've

00:22:05,280 --> 00:22:08,080
been working on it for for a while we

00:22:06,720 --> 00:22:11,440
are at major version 3

00:22:08,080 --> 00:22:15,760
and we are part of the openjs

00:22:11,440 --> 00:22:18,640
foundation and uh i would just thank you

00:22:15,760 --> 00:22:20,400
for your time as i said neil from is a

00:22:18,640 --> 00:22:22,080
professional services company we are

00:22:20,400 --> 00:22:23,919
based in ireland

00:22:22,080 --> 00:22:25,440
but we work throughout the globe we are

00:22:23,919 --> 00:22:27,840
on 20

00:22:25,440 --> 00:22:29,600
something nations right now countries

00:22:27,840 --> 00:22:32,000
right now so hey

00:22:29,600 --> 00:22:32,960
and working remotely so if you need any

00:22:32,000 --> 00:22:35,760
help with

00:22:32,960 --> 00:22:36,080
javascript or if you would like to work

00:22:35,760 --> 00:22:39,919
for

00:22:36,080 --> 00:22:41,120
a remote first company in whichever

00:22:39,919 --> 00:22:44,320
country you are

00:22:41,120 --> 00:22:46,559
normally in the european us

00:22:44,320 --> 00:22:47,840
time zone so i'm sorry if the others

00:22:46,559 --> 00:22:51,280
that are not

00:22:47,840 --> 00:22:54,320
in those time zones um but we can

00:22:51,280 --> 00:22:57,200
probably need some help we will be

00:22:54,320 --> 00:22:58,799
recruiting pretty soon if not feel free

00:22:57,200 --> 00:22:59,440
to if you want really want to work with

00:22:58,799 --> 00:23:01,120
us

00:22:59,440 --> 00:23:03,600
and please feel free to reach out

00:23:01,120 --> 00:23:04,559
directly to me or to apply with the

00:23:03,600 --> 00:23:08,559
general application

00:23:04,559 --> 00:23:12,159
on our website um yeah

00:23:08,559 --> 00:23:23,840
thank you all for watching and

00:23:12,159 --> 00:23:23,840
see you next time bye

00:23:26,900 --> 00:23:32,960
[Music]

00:23:31,520 --> 00:23:34,960
so to everyone watching along can you

00:23:32,960 --> 00:23:36,799
start popping your questions into the q

00:23:34,960 --> 00:23:39,840
a panel and we'd love

00:23:36,799 --> 00:23:41,760
to pop them to mateo but

00:23:39,840 --> 00:23:43,760
i believe we do have some to start us

00:23:41,760 --> 00:23:47,120
off

00:23:43,760 --> 00:23:50,720
yep okay so that's right

00:23:47,120 --> 00:23:51,360
hey mateo hey so uh let's start with a

00:23:50,720 --> 00:23:54,400
big one

00:23:51,360 --> 00:23:57,840
uh so with uh with graphql graphql

00:23:54,400 --> 00:24:02,159
has been uh proven great for

00:23:57,840 --> 00:24:05,600
uh apis by some companies

00:24:02,159 --> 00:24:05,919
if you want to put some sort of quotas

00:24:05,600 --> 00:24:08,320
or

00:24:05,919 --> 00:24:09,200
throttling on your api how would you

00:24:08,320 --> 00:24:13,039
approach that

00:24:09,200 --> 00:24:15,039
because uh for people who are not aware

00:24:13,039 --> 00:24:18,960
it is theoretically possible to get most

00:24:15,039 --> 00:24:21,679
of your database with a single query

00:24:18,960 --> 00:24:23,520
so how would you plot things three sides

00:24:21,679 --> 00:24:26,159
of of this

00:24:23,520 --> 00:24:26,799
so there are three sides of these

00:24:26,159 --> 00:24:31,039
problems

00:24:26,799 --> 00:24:34,640
okay there is a quota on the number of

00:24:31,039 --> 00:24:37,760
requests that you are issuing to your

00:24:34,640 --> 00:24:41,279
server which is

00:24:37,760 --> 00:24:45,279
uh in common with rest apis so

00:24:41,279 --> 00:24:46,000
you should have a plugin or a system to

00:24:45,279 --> 00:24:48,559
deal with that

00:24:46,000 --> 00:24:51,200
similar same way in which you deal with

00:24:48,559 --> 00:24:53,120
for your rest apis

00:24:51,200 --> 00:24:54,880
uh which is called goes by into the

00:24:53,120 --> 00:24:57,760
realm of rate limiting

00:24:54,880 --> 00:25:00,080
so this is the first one and we have a

00:24:57,760 --> 00:25:03,360
nice plug-in for that in the fastify

00:25:00,080 --> 00:25:06,960
world so we call fastify

00:25:03,360 --> 00:25:09,279
rate limit which is pretty great

00:25:06,960 --> 00:25:10,240
it also enable and pass into the chart

00:25:09,279 --> 00:25:14,480
so

00:25:10,240 --> 00:25:18,159
and it's a this is a plug-in for

00:25:14,480 --> 00:25:21,600
a general rate limiting on

00:25:18,159 --> 00:25:23,600
incoming requests with based on the

00:25:21,600 --> 00:25:27,039
incoming ip

00:25:23,600 --> 00:25:29,440
this is the first one the

00:25:27,039 --> 00:25:30,640
second one that you need to do and

00:25:29,440 --> 00:25:34,400
fastify gql

00:25:30,640 --> 00:25:37,919
as this is the query depth

00:25:34,400 --> 00:25:40,640
limit so it's a scan

00:25:37,919 --> 00:25:41,760
that in the incoming query it limits the

00:25:40,640 --> 00:25:44,880
maximum depth

00:25:41,760 --> 00:25:45,440
of equity to a certain amount we have

00:25:44,880 --> 00:25:48,000
seen

00:25:45,440 --> 00:25:49,039
that the number of database queries that

00:25:48,000 --> 00:25:52,159
a request can do

00:25:49,039 --> 00:25:52,159
can be limited to

00:25:53,760 --> 00:26:00,960
d queries so the depth of the queen

00:25:57,520 --> 00:26:04,720
so because of that uh limiting the depth

00:26:00,960 --> 00:26:07,279
actually as the limit the amount of

00:26:04,720 --> 00:26:09,120
queries that you're going to issue to

00:26:07,279 --> 00:26:12,240
the database

00:26:09,120 --> 00:26:15,279
the data loader pattern and

00:26:12,240 --> 00:26:19,120
third you must and this is up to you

00:26:15,279 --> 00:26:22,640
developer implement uh

00:26:19,120 --> 00:26:27,120
pagination of your results because

00:26:22,640 --> 00:26:30,159
if you uh returns all the records

00:26:27,120 --> 00:26:34,640
without paginations and limits on your

00:26:30,159 --> 00:26:37,279
uh using an endpoint then it's up to you

00:26:34,640 --> 00:26:37,279
it's your fault

00:26:41,600 --> 00:26:46,400
now a tiny twist to this question so if

00:26:44,400 --> 00:26:49,840
this is a commercial api and

00:26:46,400 --> 00:26:51,840
my customers uh would be paying for that

00:26:49,840 --> 00:26:53,600
i don't want to limit them i want to

00:26:51,840 --> 00:26:56,400
charge them proportionally to

00:26:53,600 --> 00:26:57,600
the resources they're using up uh how

00:26:56,400 --> 00:26:59,679
would you

00:26:57,600 --> 00:27:01,440
approach that this is very hard this is

00:26:59,679 --> 00:27:02,320
a very hard problem so it really depends

00:27:01,440 --> 00:27:05,440
on how much

00:27:02,320 --> 00:27:08,559
your so you can

00:27:05,440 --> 00:27:12,159
depends on what your paying model is

00:27:08,559 --> 00:27:14,880
you can pay per number of graphql

00:27:12,159 --> 00:27:15,840
request you can which is you know you

00:27:14,880 --> 00:27:19,120
can get the word

00:27:15,840 --> 00:27:22,540
out of it so big question you can pay

00:27:19,120 --> 00:27:25,640
for the um

00:27:22,540 --> 00:27:25,640
[Music]

00:27:25,760 --> 00:27:29,600
processing time or something like that

00:27:27,679 --> 00:27:30,640
of the query but that's very hard to

00:27:29,600 --> 00:27:32,159
measure

00:27:30,640 --> 00:27:33,919
because there's a lot of other things

00:27:32,159 --> 00:27:38,480
that can be involved

00:27:33,919 --> 00:27:41,520
so um another way it's uh

00:27:38,480 --> 00:27:44,320
i what i would do is essentially let

00:27:41,520 --> 00:27:48,080
them that people pay by nesting

00:27:44,320 --> 00:27:49,679
so again the the you know even the best

00:27:48,080 --> 00:27:53,200
you can implement your

00:27:49,679 --> 00:27:56,480
query is the number it depth

00:27:53,200 --> 00:27:59,679
of the of the query itself so

00:27:56,480 --> 00:28:02,399
maybe have them paid by depth

00:27:59,679 --> 00:28:04,640
essentially so which means like nested

00:28:02,399 --> 00:28:05,120
resolvers to some extent in in other

00:28:04,640 --> 00:28:08,159
words

00:28:05,120 --> 00:28:11,440
so which is way simpler to count

00:28:08,159 --> 00:28:14,559
to some extent so or

00:28:11,440 --> 00:28:14,559
by other entity

00:28:14,799 --> 00:28:19,200
yeah yeah i'd say just take the money

00:28:16,799 --> 00:28:22,399
off them in any way you can

00:28:19,200 --> 00:28:24,159
well yeah my field returned yeah but you

00:28:22,399 --> 00:28:26,000
know it needs to be simple for people to

00:28:24,159 --> 00:28:29,200
understand what they're paying for

00:28:26,000 --> 00:28:31,840
so um

00:28:29,200 --> 00:28:33,600
you know it's uh and all the systems

00:28:31,840 --> 00:28:35,200
that i'm seeing that are making them pay

00:28:33,600 --> 00:28:37,200
for graphql

00:28:35,200 --> 00:28:39,120
and point their photograph for each

00:28:37,200 --> 00:28:42,559
graphql queries and so on

00:28:39,120 --> 00:28:45,279
they're really pricey like

00:28:42,559 --> 00:28:45,760
really pricing right now from what i've

00:28:45,279 --> 00:28:48,559
seen

00:28:45,760 --> 00:28:50,640
online or something so i've seen a few

00:28:48,559 --> 00:28:53,679
cms online that let you pay for graphql

00:28:50,640 --> 00:28:53,679
equities and that's it

00:28:53,840 --> 00:28:58,000
there's this is those numbers that they

00:28:57,360 --> 00:29:00,240
put there that

00:28:58,000 --> 00:29:02,080
are free tire or the lower in amount

00:29:00,240 --> 00:29:04,480
they're actually very low

00:29:02,080 --> 00:29:05,760
so you know the moment you start pushing

00:29:04,480 --> 00:29:07,600
some traffic through them you would be

00:29:05,760 --> 00:29:10,480
in huge trouble

00:29:07,600 --> 00:29:11,520
what's the reason for the high cost do

00:29:10,480 --> 00:29:15,039
we do we have a

00:29:11,520 --> 00:29:18,640
suspicion oh yeah totally like it again

00:29:15,039 --> 00:29:21,919
running graphql like from

00:29:18,640 --> 00:29:25,520
my understanding run server is

00:29:21,919 --> 00:29:28,159
very very expensive

00:29:25,520 --> 00:29:30,080
it's just it's just a lot of resources

00:29:28,159 --> 00:29:30,480
to pass those queries validators to the

00:29:30,080 --> 00:29:32,799
they

00:29:30,480 --> 00:29:33,840
spoke about this in the talk but a lot

00:29:32,799 --> 00:29:36,960
of things that happens

00:29:33,840 --> 00:29:40,880
on graphql to make things happen

00:29:36,960 --> 00:29:44,080
and the the essentially that cost

00:29:40,880 --> 00:29:46,159
come down at the origin it's more or

00:29:44,080 --> 00:29:47,440
less number of graphql queries per

00:29:46,159 --> 00:29:50,080
server

00:29:47,440 --> 00:29:50,960
that i can handle at any point in time

00:29:50,080 --> 00:29:55,039
and

00:29:50,960 --> 00:29:57,840
if if i'm losing the more i'm losing

00:29:55,039 --> 00:29:59,760
on the more it cost me the more service

00:29:57,840 --> 00:30:03,120
i need the more i need to get

00:29:59,760 --> 00:30:03,600
to be paid for the more cost i have the

00:30:03,120 --> 00:30:06,240
more

00:30:03,600 --> 00:30:07,600
i need to be paid for for it so this is

00:30:06,240 --> 00:30:11,600
one of the

00:30:07,600 --> 00:30:12,640
and the other reason is probably that

00:30:11,600 --> 00:30:17,039
those servers are niche

00:30:12,640 --> 00:30:17,039
to some extent so and

00:30:17,360 --> 00:30:20,880
they solve actually a real problem so if

00:30:20,000 --> 00:30:22,799
you compare

00:30:20,880 --> 00:30:23,919
the cost of those services than the time

00:30:22,799 --> 00:30:25,840
that those services

00:30:23,919 --> 00:30:27,360
save in development time the development

00:30:25,840 --> 00:30:29,840
time that they save

00:30:27,360 --> 00:30:30,880
and like people cost way more than

00:30:29,840 --> 00:30:34,399
servers

00:30:30,880 --> 00:30:35,279
anyway so to be honest it might even be

00:30:34,399 --> 00:30:37,200
fair to pay them

00:30:35,279 --> 00:30:38,399
to pay their price so it really depends

00:30:37,200 --> 00:30:41,360
on your use case

00:30:38,399 --> 00:30:42,140
essentially if you are if you're making

00:30:41,360 --> 00:30:43,600
um

00:30:42,140 --> 00:30:45,520
[Music]

00:30:43,600 --> 00:30:47,520
if the service that you're building is

00:30:45,520 --> 00:30:49,120
uh is going to have some traffic or not

00:30:47,520 --> 00:30:52,559
and it might be worth the investment of

00:30:49,120 --> 00:30:52,559
developing something custom or not

00:30:54,000 --> 00:30:57,360
there's a nice question on the top of

00:30:55,760 --> 00:30:59,840
the q a uh what's

00:30:57,360 --> 00:31:01,679
what is the most common graphql mistake

00:30:59,840 --> 00:31:05,200
you have seen in your experience

00:31:01,679 --> 00:31:08,000
you mentioned one in the talk so it's

00:31:05,200 --> 00:31:10,320
something okay so i i i probably the

00:31:08,000 --> 00:31:13,679
biggest one

00:31:10,320 --> 00:31:16,559
is the one plus n problem

00:31:13,679 --> 00:31:17,360
and i've seen this happening see i've

00:31:16,559 --> 00:31:20,559
seen this

00:31:17,360 --> 00:31:22,480
in in all sort of fashion and know

00:31:20,559 --> 00:31:23,600
that more the most popular

00:31:22,480 --> 00:31:26,080
documentations

00:31:23,600 --> 00:31:29,039
that you can find out there for graphql

00:31:26,080 --> 00:31:31,760
don't mention this problem

00:31:29,039 --> 00:31:34,080
i've seen entire talks about graphql

00:31:31,760 --> 00:31:38,000
don't even mention data loader

00:31:34,080 --> 00:31:41,360
essentially and people just

00:31:38,000 --> 00:31:43,200
you know don't even care and then they

00:31:41,360 --> 00:31:46,720
blows up in their

00:31:43,200 --> 00:31:48,480
those up in their code so um

00:31:46,720 --> 00:31:50,880
some this is the first one to be honest

00:31:48,480 --> 00:31:53,120
is that ninety percent of the time

00:31:50,880 --> 00:31:56,240
versus the rest okay

00:31:53,120 --> 00:31:58,000
uh on the rest that is uh overspecifying

00:31:56,240 --> 00:32:01,120
the number of resolvers

00:31:58,000 --> 00:32:03,120
so essentially in maybe even using

00:32:01,120 --> 00:32:06,799
resolvers for

00:32:03,120 --> 00:32:08,799
uh non-asynchronous work essentially

00:32:06,799 --> 00:32:10,799
that is probably another kind of a

00:32:08,799 --> 00:32:12,080
problem that i've seen that can slow

00:32:10,799 --> 00:32:14,320
people down every time user

00:32:12,080 --> 00:32:15,360
solver you allocate a bunch of promises

00:32:14,320 --> 00:32:16,880
it's a lot of work there's a lot of

00:32:15,360 --> 00:32:18,480
computational work so

00:32:16,880 --> 00:32:21,120
the more you can avoid them the better

00:32:18,480 --> 00:32:21,120
to some extent

00:32:21,600 --> 00:32:26,399
then the last one is

00:32:24,960 --> 00:32:28,960
and this is so funny that i'm going to

00:32:26,399 --> 00:32:30,880
mention because i find it very funny

00:32:28,960 --> 00:32:33,200
it's using afghan when graphql is not

00:32:30,880 --> 00:32:33,200
needed

00:32:33,600 --> 00:32:36,880
so now truly this is the probably one of

00:32:36,320 --> 00:32:40,559
the most

00:32:36,880 --> 00:32:42,320
common mistakes the best moment where

00:32:40,559 --> 00:32:46,159
graphql is used is

00:32:42,320 --> 00:32:48,000
when you have different teams

00:32:46,159 --> 00:32:49,200
and you need a shared language between

00:32:48,000 --> 00:32:51,279
the two teams

00:32:49,200 --> 00:32:53,120
so that they can fix the data the way

00:32:51,279 --> 00:32:54,399
they want and you can produce the data

00:32:53,120 --> 00:32:56,159
the way you need to

00:32:54,399 --> 00:32:57,600
and other people can fight the data the

00:32:56,159 --> 00:32:58,880
way they want so and that can be

00:32:57,600 --> 00:33:02,159
different okay

00:32:58,880 --> 00:33:03,360
and this is the the best use case for

00:33:02,159 --> 00:33:06,240
graphql

00:33:03,360 --> 00:33:06,720
if it's me developing some code that my

00:33:06,240 --> 00:33:11,840
worm

00:33:06,720 --> 00:33:11,840
that i would be using in my front end

00:33:13,120 --> 00:33:19,200
why bother i old school

00:33:16,720 --> 00:33:22,480
if i'm doing a web app old school rest

00:33:19,200 --> 00:33:26,399
is probably 10 times simpler to ship

00:33:22,480 --> 00:33:30,320
and cash and secure and paginate and

00:33:26,399 --> 00:33:34,240
whatever so pragmatism

00:33:30,320 --> 00:33:36,960
it it wins for me over there so

00:33:34,240 --> 00:33:38,000
it really depends on you just covered

00:33:36,960 --> 00:33:42,480
another okay

00:33:38,000 --> 00:33:42,480
cool you see two for one ah

00:33:44,399 --> 00:33:48,000
okay so is there an inflection point i'm

00:33:46,960 --> 00:33:51,120
reading another one

00:33:48,000 --> 00:33:52,240
in terms of scale the app uh where i

00:33:51,120 --> 00:33:54,720
should just

00:33:52,240 --> 00:33:56,799
not consider graphql at all where the

00:33:54,720 --> 00:33:57,519
size of the app will prevent graphql

00:33:56,799 --> 00:33:59,679
patterns from

00:33:57,519 --> 00:34:02,559
ever being performed sorry can you

00:33:59,679 --> 00:34:05,679
repeat the question i'm lost

00:34:02,559 --> 00:34:08,079
uh i'm going to simplify is there

00:34:05,679 --> 00:34:09,119
is there a size of the application i

00:34:08,079 --> 00:34:12,320
think by that

00:34:09,119 --> 00:34:12,639
they meant data and data types uh which

00:34:12,320 --> 00:34:15,679
is

00:34:12,639 --> 00:34:20,079
too big for graphql to ever make it

00:34:15,679 --> 00:34:24,639
i would so

00:34:20,079 --> 00:34:24,639
from my understanding

00:34:27,599 --> 00:34:31,839
there with there has to be but i have

00:34:29,839 --> 00:34:34,720
not seen it yet

00:34:31,839 --> 00:34:35,359
so it's probably massive but on the

00:34:34,720 --> 00:34:36,879
other side

00:34:35,359 --> 00:34:38,720
very important thing you should be using

00:34:36,879 --> 00:34:40,879
graphical jet

00:34:38,720 --> 00:34:42,480
if you're not using fklg then you're a

00:34:40,879 --> 00:34:44,399
big in big trouble so

00:34:42,480 --> 00:34:46,480
yes if you use graphic lg you're

00:34:44,399 --> 00:34:49,119
probably the biggest of the with the way

00:34:46,480 --> 00:34:51,599
graphqlg works the biggest the query is

00:34:49,119 --> 00:34:55,040
the biggest the improvement you have

00:34:51,599 --> 00:34:58,560
so essentially

00:34:55,040 --> 00:35:01,839
um because it does less work

00:34:58,560 --> 00:35:04,800
literally a lot less work

00:35:01,839 --> 00:35:05,680
um if you use graphql gt yes it's it's

00:35:04,800 --> 00:35:07,280
probably

00:35:05,680 --> 00:35:09,119
the the there has to be but it's

00:35:07,280 --> 00:35:11,599
probably very very far away

00:35:09,119 --> 00:35:13,520
with the graphql with normal without

00:35:11,599 --> 00:35:14,320
graphical jit you are in trouble you can

00:35:13,520 --> 00:35:16,960
get in trouble

00:35:14,320 --> 00:35:17,520
way way sooner than that i don't know

00:35:16,960 --> 00:35:20,240
what it

00:35:17,520 --> 00:35:20,240
to give you at

00:35:20,560 --> 00:35:27,440
uh a size in in inches or whatever

00:35:24,800 --> 00:35:28,640
but you know it's uh the rest is like

00:35:27,440 --> 00:35:32,160
you you've got hydrate

00:35:28,640 --> 00:35:35,280
and you should not be boring that's my

00:35:32,160 --> 00:35:38,400
dldr of this question

00:35:35,280 --> 00:35:38,400
it's a good tldr

00:35:40,720 --> 00:35:44,480
i've got a little question of my own and

00:35:42,400 --> 00:35:45,760
this is purely for my own benefit nobody

00:35:44,480 --> 00:35:48,880
else watching along

00:35:45,760 --> 00:35:50,079
i've never used graphql um have you got

00:35:48,880 --> 00:35:53,680
a

00:35:50,079 --> 00:35:56,320
suggested project type for me to

00:35:53,680 --> 00:35:58,160
play around with it with so i'm guessing

00:35:56,320 --> 00:36:00,720
getting a load of blog posts out of

00:35:58,160 --> 00:36:02,160
a graphql database is probably not a

00:36:00,720 --> 00:36:05,359
good use of it

00:36:02,160 --> 00:36:07,359
but what well it is so it is so it is

00:36:05,359 --> 00:36:09,280
and it is not okay so if you need to

00:36:07,359 --> 00:36:12,079
study it just study it and

00:36:09,280 --> 00:36:13,680
play with it the way you want yeah to be

00:36:12,079 --> 00:36:16,800
honest it's fine

00:36:13,680 --> 00:36:18,640
um if you need

00:36:16,800 --> 00:36:21,599
build a domain work on a domain that you

00:36:18,640 --> 00:36:25,520
know because you need to get used

00:36:21,599 --> 00:36:28,960
to how you would model that domain

00:36:25,520 --> 00:36:31,680
so that is kind of the hard part

00:36:28,960 --> 00:36:33,280
so get that hard part done and then you

00:36:31,680 --> 00:36:36,240
were

00:36:33,280 --> 00:36:37,200
you have a smooth sailing and that's

00:36:36,240 --> 00:36:39,760
actually how

00:36:37,200 --> 00:36:40,320
how i would approach it so start with a

00:36:39,760 --> 00:36:43,359
program

00:36:40,320 --> 00:36:44,720
a project that you know a domain that

00:36:43,359 --> 00:36:47,839
you know

00:36:44,720 --> 00:36:49,440
okay that's perfect advice and i think

00:36:47,839 --> 00:36:50,320
on that bombshell we're approaching the

00:36:49,440 --> 00:36:54,079
end of

00:36:50,320 --> 00:36:55,839
this q a session unfortunately but will

00:36:54,079 --> 00:36:57,920
you be sticking around on the tables for

00:36:55,839 --> 00:36:59,920
people to come and find you

00:36:57,920 --> 00:37:01,760
maybe if i understand i'll follow this

00:36:59,920 --> 00:37:03,680
works so

00:37:01,760 --> 00:37:05,040
if you just tell me what i need to click

00:37:03,680 --> 00:37:08,640
yes i have been

00:37:05,040 --> 00:37:12,240
in huge trouble i jumped into luciano

00:37:08,640 --> 00:37:14,320
q a before i made a mess so i am

00:37:12,240 --> 00:37:16,240
a little bit at a loss on on this

00:37:14,320 --> 00:37:19,440
platform so if you tell me to

00:37:16,240 --> 00:37:21,280
where to click i might find one of the

00:37:19,440 --> 00:37:22,720
fairly empty tables and double click on

00:37:21,280 --> 00:37:24,160
that and then you'll join it

00:37:22,720 --> 00:37:26,240
and then other people can come and find

00:37:24,160 --> 00:37:27,680
you can you join me can you can you

00:37:26,240 --> 00:37:28,240
other people will be able to join you

00:37:27,680 --> 00:37:30,720
yeah

00:37:28,240 --> 00:37:32,160
okay perfect yeah let's let's do that

00:37:30,720 --> 00:37:33,520
just send me a link and send me

00:37:32,160 --> 00:37:34,839
something instruction and they will do

00:37:33,520 --> 00:37:38,160
it

00:37:34,839 --> 00:37:38,720
awesome yeah so uh looking forward to

00:37:38,160 --> 00:37:42,240
your

00:37:38,720 --> 00:37:44,079
uh your workshop on friday is it friday

00:37:42,240 --> 00:37:46,480
maybe it's the 17th so i don't know if

00:37:44,079 --> 00:37:51,839
it's friday it should be friday

00:37:46,480 --> 00:37:51,839
yeah it's it's on friday

00:37:54,320 --> 00:37:57,599
i believe there are six tickets left for

00:37:56,079 --> 00:37:59,680
that if i'm correct

00:37:57,599 --> 00:38:00,720
oh really sounds like something you're

00:37:59,680 --> 00:38:03,200
interested in going

00:38:00,720 --> 00:38:05,359
along to now is your time signing i

00:38:03,200 --> 00:38:07,280
think there is

00:38:05,359 --> 00:38:09,599
it's really fun we are talking about

00:38:07,280 --> 00:38:11,200
promises and now they are broken

00:38:09,599 --> 00:38:14,000
and the fact that you're using them

00:38:11,200 --> 00:38:14,000
brown so

00:38:14,160 --> 00:38:17,280
perfect and with that i think we're

00:38:15,760 --> 00:38:18,320
going to have to leave that here because

00:38:17,280 --> 00:38:20,720
we've got the other talk

00:38:18,320 --> 00:38:22,640
just about start so matteo i'd like to

00:38:20,720 --> 00:38:24,160
say a huge thank you again for your talk

00:38:22,640 --> 00:38:26,640
it was absolutely amazing it

00:38:24,160 --> 00:38:27,920
inspired me to dive into graphql i'm

00:38:26,640 --> 00:38:33,119
sure it did for other people

00:38:27,920 --> 00:38:35,680
as well have you got any final departure

00:38:33,119 --> 00:38:35,680
either of you

00:38:36,560 --> 00:38:42,560
use festival it's fast

00:38:40,720 --> 00:38:43,760
get that plug in there right again mateo

00:38:42,560 --> 00:38:45,440
thank you very much for your time we

00:38:43,760 --> 00:38:47,839
really really appreciate it

00:38:45,440 --> 00:38:47,839
bye bye

00:38:48,540 --> 00:38:51,630

YouTube URL: https://www.youtube.com/watch?v=2WEzL8kX2oc


