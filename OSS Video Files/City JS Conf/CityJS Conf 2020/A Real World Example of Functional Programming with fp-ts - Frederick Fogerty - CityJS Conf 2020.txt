Title: A Real World Example of Functional Programming with fp-ts - Frederick Fogerty - CityJS Conf 2020
Publication date: 2020-10-03
Playlist: CityJS Conf 2020
Description: 
	Have you thought about learning Functional Programming, but have been daunted by all the technical jargon? Luckily, in this talk I wonâ€™t be exploring any technical concepts, and instead will be walking through a real-world Javascript project and discussing how we can refactor it to a more functional style using a TS library, fp-ts. We will be using Functors, Monads, Applicative, and more, without having to know what they are or how they work!

At the end of the talk you should be confident to actually write functional code, and not just understand it, in your own projects.

About
imgix - Software Engineer working on OSS

Chapters / Excerpts
Start [00:00:00] 

About Frederick [00:01:10] 

What's in this talk [00:01:55]
I'm first going to briefly go over what FP and FPS it FETs are the kind of benefits and why you should use this functional programming paradigm that is so popular and getting popularity.

FP/FP-TS & Pro's / Con's [00:03:03]

The App [00:08:32]
We've briefly gone through what functional programming is and what if BTS is, and its pros and cons.

Validation [00:13:39]

Promise as a Framework [00:14:20] 
You already know that familiar with promises and functional programming, because I believe with this mapping, then you can go and be more empowered

Task Either [00:17:43]
I've shown you a task either. And there's many other types which I'll get to at the end of the talk. But for now we're gonna use the task either.

Matching [00:19:43]
I thought about these behavior contracts. And that was for a reason we need to make sure that when we're writing functional code, that the functions will be cool and the framework we kind of pushed into always match. So how do you do that? 

Consuming the function in the original API [00:21:00]
Now let's take a look at what it looks like to consume this function in the original API. And so we had this function and what I want to focus on at first is again, the function contracts. 

Suggestions [00:24:06]
Refactoring [00:25:05] And I mentioned that one of the benefits was refactoring and I want to show how that looks like and how the toxicity helped us out.

Closing Thoughts [00:30:16]

Q&A [00:34:32]

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:18,060 --> 00:00:23,840
[Music]

00:00:22,320 --> 00:00:25,840
hello everyone

00:00:23,840 --> 00:00:28,000
and welcome to the talk i wish existed

00:00:25,840 --> 00:00:29,920
three months ago

00:00:28,000 --> 00:00:31,920
why three months ago well let me run you

00:00:29,920 --> 00:00:34,000
through a little story

00:00:31,920 --> 00:00:35,680
i've known about functional programming

00:00:34,000 --> 00:00:37,360
for about three or four years

00:00:35,680 --> 00:00:39,200
i had experience with haskell and f

00:00:37,360 --> 00:00:42,079
sharp and i've dabbled in other

00:00:39,200 --> 00:00:44,480
languages such as purescript

00:00:42,079 --> 00:00:45,440
but i had a pro a project coming up

00:00:44,480 --> 00:00:47,760
about uh

00:00:45,440 --> 00:00:48,960
three months ago that i wanted to use

00:00:47,760 --> 00:00:50,480
functional programming for i thought it

00:00:48,960 --> 00:00:52,800
was a great project

00:00:50,480 --> 00:00:54,879
and i thought let's dive into it the

00:00:52,800 --> 00:00:56,320
thing is it was a typescript project

00:00:54,879 --> 00:00:58,000
and i had no experience with that

00:00:56,320 --> 00:01:00,320
writing functional code

00:00:58,000 --> 00:01:01,039
in javascript or typescript and let me

00:01:00,320 --> 00:01:03,039
say

00:01:01,039 --> 00:01:04,799
the learning experience wasn't great and

00:01:03,039 --> 00:01:06,880
i wish this talk existed

00:01:04,799 --> 00:01:08,640
three months ago to give me a helping

00:01:06,880 --> 00:01:10,799
hand

00:01:08,640 --> 00:01:12,080
first a little bit about me my name is

00:01:10,799 --> 00:01:15,119
fredrick fogerty

00:01:12,080 --> 00:01:17,920
uh i'm a software engineer at imogex uh

00:01:15,119 --> 00:01:18,560
and there i have the the fortunate role

00:01:17,920 --> 00:01:21,520
of

00:01:18,560 --> 00:01:22,799
overseeing a lot of uh sdks a lot of

00:01:21,520 --> 00:01:24,159
different languages a lot of different

00:01:22,799 --> 00:01:25,119
projects were in different languages and

00:01:24,159 --> 00:01:28,000
frameworks

00:01:25,119 --> 00:01:28,960
so i have a pretty good view of the land

00:01:28,000 --> 00:01:30,960
um

00:01:28,960 --> 00:01:32,720
they're based in san francisco right now

00:01:30,960 --> 00:01:35,840
i'm in geneva switzerland

00:01:32,720 --> 00:01:38,079
um and i'm hoping that next time we we

00:01:35,840 --> 00:01:40,240
have this this conference that i can

00:01:38,079 --> 00:01:41,840
make the trip to london and give it to

00:01:40,240 --> 00:01:44,799
your own person

00:01:41,840 --> 00:01:45,600
uh and so my promise to you by the end

00:01:44,799 --> 00:01:48,799
of these

00:01:45,600 --> 00:01:49,840
30 minutes is that if you're

00:01:48,799 --> 00:01:51,280
someone who doesn't really know what

00:01:49,840 --> 00:01:53,360
functional programming is you're going

00:01:51,280 --> 00:01:55,680
to have a good understanding

00:01:53,360 --> 00:01:57,119
of what it is and why it's important and

00:01:55,680 --> 00:01:58,240
if you're looking to actually dive in

00:01:57,119 --> 00:02:00,079
and write some

00:01:58,240 --> 00:02:02,320
functional code in typescript with the

00:02:00,079 --> 00:02:03,680
library fpts

00:02:02,320 --> 00:02:05,840
then you'll have a better understanding

00:02:03,680 --> 00:02:08,879
of how to write actual functional code

00:02:05,840 --> 00:02:12,319
not just what a monad is

00:02:08,879 --> 00:02:12,800
all right so in this talk i'm first

00:02:12,319 --> 00:02:16,480
going to

00:02:12,800 --> 00:02:20,080
briefly go over what fp and fps

00:02:16,480 --> 00:02:22,400
fpts are there kind of benefits and why

00:02:20,080 --> 00:02:24,400
you should use this functional

00:02:22,400 --> 00:02:25,920
programming paradigm that is so popular

00:02:24,400 --> 00:02:30,000
and gaining popularity

00:02:25,920 --> 00:02:33,760
uh every day it seems and also

00:02:30,000 --> 00:02:34,879
what the pros and cons are of using fpts

00:02:33,760 --> 00:02:38,560
specifically

00:02:34,879 --> 00:02:39,920
um and then the second section i'll be

00:02:38,560 --> 00:02:42,319
going over

00:02:39,920 --> 00:02:43,200
an ad prefactoring and with this i'll be

00:02:42,319 --> 00:02:46,080
taking a

00:02:43,200 --> 00:02:46,959
existing application in javascript and

00:02:46,080 --> 00:02:49,920
converting it

00:02:46,959 --> 00:02:50,640
to a functional style and hopefully with

00:02:49,920 --> 00:02:52,800
this

00:02:50,640 --> 00:02:54,640
this is for the people who want to write

00:02:52,800 --> 00:02:56,879
actual fpts code

00:02:54,640 --> 00:02:57,920
uh you could have a deeper understanding

00:02:56,879 --> 00:03:00,560
of how to

00:02:57,920 --> 00:03:02,239
reason about functional code not just

00:03:00,560 --> 00:03:03,200
read an example and try copy that

00:03:02,239 --> 00:03:06,800
example

00:03:03,200 --> 00:03:10,319
all right so functional programming

00:03:06,800 --> 00:03:11,280
first what is it well the analogy i like

00:03:10,319 --> 00:03:14,080
to use

00:03:11,280 --> 00:03:15,440
is that to explain to people who have

00:03:14,080 --> 00:03:16,959
written javascript already and have

00:03:15,440 --> 00:03:19,680
tried typescript

00:03:16,959 --> 00:03:21,280
that when you go from javascript to

00:03:19,680 --> 00:03:25,040
typescript you're essentially

00:03:21,280 --> 00:03:27,280
adding data contracts to your code base

00:03:25,040 --> 00:03:28,799
so what you're saying is this function

00:03:27,280 --> 00:03:31,519
returns this data

00:03:28,799 --> 00:03:33,280
and this function consumes that data and

00:03:31,519 --> 00:03:35,280
the type system can help you ensure

00:03:33,280 --> 00:03:37,040
those contracts are compatible

00:03:35,280 --> 00:03:38,400
and then if you change your contracts

00:03:37,040 --> 00:03:39,599
the type system will help you out and

00:03:38,400 --> 00:03:40,720
say hey look you should probably change

00:03:39,599 --> 00:03:42,080
the other thing as well

00:03:40,720 --> 00:03:44,000
to make sure the data flows around your

00:03:42,080 --> 00:03:47,519
system correctly

00:03:44,000 --> 00:03:50,480
for me one of the benefits of

00:03:47,519 --> 00:03:51,920
functional programming is now we extend

00:03:50,480 --> 00:03:54,239
this contract to not just

00:03:51,920 --> 00:03:56,640
include the data but the behavior and

00:03:54,239 --> 00:03:58,879
how that affects your application

00:03:56,640 --> 00:04:00,560
what that means is instead of just

00:03:58,879 --> 00:04:03,280
saying this function returns

00:04:00,560 --> 00:04:04,720
this data now we're saying this function

00:04:03,280 --> 00:04:06,720
behaves in this way

00:04:04,720 --> 00:04:08,080
this function can throw an error it can

00:04:06,720 --> 00:04:10,480
maybe return a value

00:04:08,080 --> 00:04:11,200
these kinds of things is asynchronous

00:04:10,480 --> 00:04:13,280
and

00:04:11,200 --> 00:04:15,280
then when this other function consumes

00:04:13,280 --> 00:04:17,919
it the type system will help us

00:04:15,280 --> 00:04:18,880
ensure that those function contracts are

00:04:17,919 --> 00:04:20,239
compatible

00:04:18,880 --> 00:04:22,400
some other benefits of functional

00:04:20,239 --> 00:04:24,720
programming is that

00:04:22,400 --> 00:04:27,360
you end up with code which is more

00:04:24,720 --> 00:04:31,520
isolated and testable

00:04:27,360 --> 00:04:34,479
and why this matters is because

00:04:31,520 --> 00:04:36,720
when you're writing oop a common thing

00:04:34,479 --> 00:04:39,040
is you kind of have to

00:04:36,720 --> 00:04:40,400
force yourself to write good isolated

00:04:39,040 --> 00:04:42,000
testable code

00:04:40,400 --> 00:04:43,520
with dependency injection and things

00:04:42,000 --> 00:04:46,320
like this and it

00:04:43,520 --> 00:04:47,600
can seem like you're just pushing a ball

00:04:46,320 --> 00:04:50,560
up to the top of a hill

00:04:47,600 --> 00:04:51,360
and it's kind of teetering that up there

00:04:50,560 --> 00:04:53,040
and then

00:04:51,360 --> 00:04:55,360
at any moment it can kind of just roll

00:04:53,040 --> 00:04:56,479
off what's a term that is thrown around

00:04:55,360 --> 00:04:59,919
a lot of the industry

00:04:56,479 --> 00:05:01,759
is a pit of success and

00:04:59,919 --> 00:05:03,280
functional programming is commonly seen

00:05:01,759 --> 00:05:06,479
as one of

00:05:03,280 --> 00:05:08,160
many pits of successes basically by

00:05:06,479 --> 00:05:09,600
writing your code in a functional style

00:05:08,160 --> 00:05:12,800
using a functional framework

00:05:09,600 --> 00:05:14,960
like fpts you don't really have to do

00:05:12,800 --> 00:05:16,320
much effort to make your ball roll down

00:05:14,960 --> 00:05:19,360
into the pit

00:05:16,320 --> 00:05:20,560
and you have a more a better program as

00:05:19,360 --> 00:05:22,400
a result and you don't have to do too

00:05:20,560 --> 00:05:24,080
much work for it

00:05:22,400 --> 00:05:26,080
it turns out that with functional

00:05:24,080 --> 00:05:28,560
programming i like to think of there

00:05:26,080 --> 00:05:31,440
being three pits of success

00:05:28,560 --> 00:05:33,120
there's isolation correctness and

00:05:31,440 --> 00:05:35,520
testability

00:05:33,120 --> 00:05:36,639
in this talk i'm going to be giving you

00:05:35,520 --> 00:05:39,520
an understanding of why

00:05:36,639 --> 00:05:40,880
of how the kind of correctness uh of

00:05:39,520 --> 00:05:43,360
success is relevant

00:05:40,880 --> 00:05:44,320
but for other pits of successes what i

00:05:43,360 --> 00:05:48,000
recommend you do

00:05:44,320 --> 00:05:51,039
is go watch this talk by mark seaman uh

00:05:48,000 --> 00:05:52,479
call the pits of success he has some

00:05:51,039 --> 00:05:54,320
great explanations in there and you can

00:05:52,479 --> 00:05:55,120
see it's an hour long it's well worth

00:05:54,320 --> 00:05:57,840
the time

00:05:55,120 --> 00:05:58,560
and also any of the other talks are also

00:05:57,840 --> 00:06:00,400
amazing

00:05:58,560 --> 00:06:01,600
seriously go watch them they're great

00:06:00,400 --> 00:06:05,440
now a bit about

00:06:01,600 --> 00:06:07,919
fpts it's a

00:06:05,440 --> 00:06:08,880
a typescript library which has 5k styles

00:06:07,919 --> 00:06:10,400
on github

00:06:08,880 --> 00:06:11,919
and it's the biggest functional

00:06:10,400 --> 00:06:15,120
programming library that

00:06:11,919 --> 00:06:17,919
implements haskell esque types

00:06:15,120 --> 00:06:19,680
this is not like random or low dash this

00:06:17,919 --> 00:06:22,479
is implementing

00:06:19,680 --> 00:06:23,919
types like ethers and task eithers and

00:06:22,479 --> 00:06:24,400
don't worry if that means nothing to you

00:06:23,919 --> 00:06:25,600
yet

00:06:24,400 --> 00:06:28,479
hopefully it will by the end of this

00:06:25,600 --> 00:06:29,840
talk kind of leading on from before

00:06:28,479 --> 00:06:31,440
i like to think of functional

00:06:29,840 --> 00:06:33,680
programming having the benefits with

00:06:31,440 --> 00:06:35,600
things that can fail

00:06:33,680 --> 00:06:37,280
and also it helps you write this code

00:06:35,600 --> 00:06:39,440
because it's replacing

00:06:37,280 --> 00:06:40,639
it's kind of built from real world code

00:06:39,440 --> 00:06:42,080
it wasn't just made up kind of

00:06:40,639 --> 00:06:44,479
theoretically

00:06:42,080 --> 00:06:45,600
these two things allow you to have a

00:06:44,479 --> 00:06:47,280
much better experience when you're

00:06:45,600 --> 00:06:50,960
refactoring your code

00:06:47,280 --> 00:06:52,479
because if you can have these contracts

00:06:50,960 --> 00:06:53,919
these behavior contracts

00:06:52,479 --> 00:06:56,000
and also the fact you're running less

00:06:53,919 --> 00:06:57,840
code means that when you're refactoring

00:06:56,000 --> 00:06:59,520
you have less stuff to check that is

00:06:57,840 --> 00:07:00,720
correct and also the type system helps

00:06:59,520 --> 00:07:02,160
you

00:07:00,720 --> 00:07:04,160
ensure that the stuff you are moving

00:07:02,160 --> 00:07:06,720
around uh is

00:07:04,160 --> 00:07:08,160
working together behaviorally so if you

00:07:06,720 --> 00:07:09,759
move a function underneath another

00:07:08,160 --> 00:07:10,880
function which throws it which returns

00:07:09,759 --> 00:07:13,520
an error state

00:07:10,880 --> 00:07:14,639
you have to handle that and a functional

00:07:13,520 --> 00:07:16,639
programming paradigm

00:07:14,639 --> 00:07:17,919
forces you to do this but it doesn't it

00:07:16,639 --> 00:07:20,000
doesn't make it complicated don't worry

00:07:17,919 --> 00:07:23,360
about that

00:07:20,000 --> 00:07:25,199
it also helps with validation

00:07:23,360 --> 00:07:27,039
isolation and testing it makes functions

00:07:25,199 --> 00:07:29,199
more testable

00:07:27,039 --> 00:07:30,800
a downside for me is that typescript

00:07:29,199 --> 00:07:31,919
wasn't really made for functional

00:07:30,800 --> 00:07:33,680
programming

00:07:31,919 --> 00:07:35,840
i'm not to say that they're not doing

00:07:33,680 --> 00:07:36,960
the best they can but

00:07:35,840 --> 00:07:39,280
when you have a language which is

00:07:36,960 --> 00:07:40,240
designed for functional programming like

00:07:39,280 --> 00:07:41,599
haskell

00:07:40,240 --> 00:07:43,120
the benefit's going to be much more

00:07:41,599 --> 00:07:45,440
significant than in a language like

00:07:43,120 --> 00:07:46,879
javascript where you're kind of just

00:07:45,440 --> 00:07:48,240
putting it in there it wasn't designed

00:07:46,879 --> 00:07:49,680
for it but i still think there are

00:07:48,240 --> 00:07:52,560
benefits to be had

00:07:49,680 --> 00:07:53,440
um and what i think is that if you do

00:07:52,560 --> 00:07:55,039
like

00:07:53,440 --> 00:07:57,680
functional programming when you try this

00:07:55,039 --> 00:07:59,759
out in javascript i would suggest to you

00:07:57,680 --> 00:08:02,160
to

00:07:59,759 --> 00:08:03,520
try out another language like purescript

00:08:02,160 --> 00:08:05,199
or haskell briefly and see

00:08:03,520 --> 00:08:06,800
if it's worth making the complete switch

00:08:05,199 --> 00:08:08,319
obviously it's a bigger investment

00:08:06,800 --> 00:08:10,000
but i like that you can try out

00:08:08,319 --> 00:08:12,639
functional programming in javascript

00:08:10,000 --> 00:08:14,160
with no real cost and for me the biggest

00:08:12,639 --> 00:08:14,800
the biggest downside is your qa team

00:08:14,160 --> 00:08:17,199
might not have

00:08:14,800 --> 00:08:18,080
any work to do you're going to write

00:08:17,199 --> 00:08:19,199
less bugs

00:08:18,080 --> 00:08:20,639
and then your project manager is going

00:08:19,199 --> 00:08:22,080
to come along and say hey give me some

00:08:20,639 --> 00:08:22,720
bugs so i can give it to the qa team in

00:08:22,080 --> 00:08:24,879
there

00:08:22,720 --> 00:08:26,400
and uh they can they can review them and

00:08:24,879 --> 00:08:27,360
fix them

00:08:26,400 --> 00:08:29,280
and they're not going to have any work

00:08:27,360 --> 00:08:30,479
to do because functional programming is

00:08:29,280 --> 00:08:33,039
going to force you

00:08:30,479 --> 00:08:34,560
to write more correct code we've briefly

00:08:33,039 --> 00:08:35,200
gone through what function programming

00:08:34,560 --> 00:08:38,000
is

00:08:35,200 --> 00:08:40,240
and what fpts is and its pros and cons

00:08:38,000 --> 00:08:41,599
and i want to slow down a bit and

00:08:40,240 --> 00:08:44,240
take you through the main part of the

00:08:41,599 --> 00:08:45,279
talk which is talking about our

00:08:44,240 --> 00:08:48,320
application

00:08:45,279 --> 00:08:49,360
uh this is a real world example it's not

00:08:48,320 --> 00:08:51,200
a to-do list

00:08:49,360 --> 00:08:53,600
or just a simple like theoretical

00:08:51,200 --> 00:08:56,000
example i think this example combines

00:08:53,600 --> 00:08:58,800
enough complexity with database calls

00:08:56,000 --> 00:09:00,320
asynchronous work and business logic to

00:08:58,800 --> 00:09:02,800
give you a

00:09:00,320 --> 00:09:04,000
understanding of what writing actual

00:09:02,800 --> 00:09:08,320
functional code

00:09:04,000 --> 00:09:11,519
uh is like in in typescript

00:09:08,320 --> 00:09:12,399
so let's dive in what our application is

00:09:11,519 --> 00:09:13,920
going to do

00:09:12,399 --> 00:09:15,839
is it's going to be an airline

00:09:13,920 --> 00:09:16,959
reservation manager and it's going to

00:09:15,839 --> 00:09:19,279
handle

00:09:16,959 --> 00:09:20,560
a reservation request from the client so

00:09:19,279 --> 00:09:23,040
the client will pass

00:09:20,560 --> 00:09:24,720
a reservation request to the server the

00:09:23,040 --> 00:09:27,360
server will validate this

00:09:24,720 --> 00:09:28,160
json request essentially and will return

00:09:27,360 --> 00:09:30,880
a 422

00:09:28,160 --> 00:09:32,720
if it's invalid if it is valid it will

00:09:30,880 --> 00:09:34,080
try and accept this reservation

00:09:32,720 --> 00:09:35,920
which means that it has to go to the

00:09:34,080 --> 00:09:36,399
database get the existing reservations

00:09:35,920 --> 00:09:39,519
for that

00:09:36,399 --> 00:09:40,320
flight if there's enough capacity on the

00:09:39,519 --> 00:09:42,480
plane

00:09:40,320 --> 00:09:43,839
uh it will save the reservation and

00:09:42,480 --> 00:09:45,760
return onto a one

00:09:43,839 --> 00:09:47,920
otherwise if there's not enough capacity

00:09:45,760 --> 00:09:51,120
it will turn a 403

00:09:47,920 --> 00:09:52,640
what that looks like in code is

00:09:51,120 --> 00:09:54,240
this you can imagine this code's running

00:09:52,640 --> 00:09:57,839
in a sort of functional

00:09:54,240 --> 00:09:59,839
um server uh on on a server somewhere on

00:09:57,839 --> 00:10:01,839
node.js server

00:09:59,839 --> 00:10:03,279
and this is the first line this is the

00:10:01,839 --> 00:10:05,760
function contract

00:10:03,279 --> 00:10:07,200
and what i want to point out here is the

00:10:05,760 --> 00:10:08,959
promise

00:10:07,200 --> 00:10:10,640
the return type so we're returning a

00:10:08,959 --> 00:10:12,480
promise and inside this promise we have

00:10:10,640 --> 00:10:14,959
an http response

00:10:12,480 --> 00:10:16,079
but the thing is we all know promises

00:10:14,959 --> 00:10:17,839
can be rejected

00:10:16,079 --> 00:10:19,440
but we don't express this in our type

00:10:17,839 --> 00:10:22,000
system so

00:10:19,440 --> 00:10:23,440
we have no way of knowing when we

00:10:22,000 --> 00:10:25,600
consume this function

00:10:23,440 --> 00:10:27,279
uh whether it's going to fail or not

00:10:25,600 --> 00:10:28,000
maybe we read the documentation and we

00:10:27,279 --> 00:10:31,200
make a

00:10:28,000 --> 00:10:32,959
best guess when we're writing

00:10:31,200 --> 00:10:34,560
code that's consuming this function or

00:10:32,959 --> 00:10:36,880
consuming any promise

00:10:34,560 --> 00:10:37,680
and we code it kind of with this

00:10:36,880 --> 00:10:40,720
assumption

00:10:37,680 --> 00:10:41,519
uh when we write it but then down the

00:10:40,720 --> 00:10:43,920
track

00:10:41,519 --> 00:10:45,440
um or even because the documentation's

00:10:43,920 --> 00:10:47,600
incorrect

00:10:45,440 --> 00:10:48,959
this promise could reject and we could

00:10:47,600 --> 00:10:51,360
end up

00:10:48,959 --> 00:10:52,480
with a function that errors at runtime

00:10:51,360 --> 00:10:55,680
because we just haven't

00:10:52,480 --> 00:10:57,519
considered all cases because we

00:10:55,680 --> 00:10:58,959
there's been some issues on the way now

00:10:57,519 --> 00:11:02,000
i think you kind of have two ways to

00:10:58,959 --> 00:11:06,000
solve this one

00:11:02,000 --> 00:11:09,440
is that you can write code defensively

00:11:06,000 --> 00:11:11,680
so you end up with

00:11:09,440 --> 00:11:13,440
just try catches or dot catches

00:11:11,680 --> 00:11:16,959
everywhere on your application

00:11:13,440 --> 00:11:19,839
and this just leads to kind of wasted

00:11:16,959 --> 00:11:22,160
code for things that you know can't fail

00:11:19,839 --> 00:11:23,600
and the second way is you kind of just

00:11:22,160 --> 00:11:26,160
trust it and hope for the best and add

00:11:23,600 --> 00:11:28,880
like a catch all

00:11:26,160 --> 00:11:29,519
in the the top level of your application

00:11:28,880 --> 00:11:31,839
but i think

00:11:29,519 --> 00:11:32,640
um this is kind of a little bit of a

00:11:31,839 --> 00:11:34,320
cop-out

00:11:32,640 --> 00:11:35,920
because you can do much better if you

00:11:34,320 --> 00:11:37,200
can handle uh the errors where they

00:11:35,920 --> 00:11:38,640
happen and if you know

00:11:37,200 --> 00:11:40,240
where they happen and you can do this

00:11:38,640 --> 00:11:41,040
easily we're going to find out how we

00:11:40,240 --> 00:11:44,240
can do this

00:11:41,040 --> 00:11:47,360
with functional programming so

00:11:44,240 --> 00:11:48,880
first thing we do we validate the

00:11:47,360 --> 00:11:51,680
request that came in and if it's not

00:11:48,880 --> 00:11:54,839
valid we return a 422

00:11:51,680 --> 00:11:56,399
if it's valid we try and accept that

00:11:54,839 --> 00:11:58,720
reservation

00:11:56,399 --> 00:12:00,959
by sending it to this tri-accept method

00:11:58,720 --> 00:12:03,120
and the reservation manager

00:12:00,959 --> 00:12:04,000
and then this function is going to

00:12:03,120 --> 00:12:07,120
return either

00:12:04,000 --> 00:12:08,959
undefined or reservation undefined if it

00:12:07,120 --> 00:12:10,720
fails if there's no capacity

00:12:08,959 --> 00:12:12,240
and so we handled that undefined by

00:12:10,720 --> 00:12:14,720
returning a 403

00:12:12,240 --> 00:12:15,279
otherwise we returned to a 1 to say that

00:12:14,720 --> 00:12:16,880
the

00:12:15,279 --> 00:12:19,279
creation succeeded the reservation was

00:12:16,880 --> 00:12:20,800
saved successfully

00:12:19,279 --> 00:12:24,399
now let's dive into the try accept

00:12:20,800 --> 00:12:28,000
method this is where a lot more happens

00:12:24,399 --> 00:12:29,120
so here we're saying that we're taking a

00:12:28,000 --> 00:12:31,920
reservation request

00:12:29,120 --> 00:12:33,680
and we're returning a promise i'll look

00:12:31,920 --> 00:12:35,839
at the function contract here again

00:12:33,680 --> 00:12:37,360
because now we've kind of indicated that

00:12:35,839 --> 00:12:38,480
this function can error but we're

00:12:37,360 --> 00:12:41,120
representing this

00:12:38,480 --> 00:12:42,560
as an undefined type and that to me that

00:12:41,120 --> 00:12:44,880
seems like a bit of a hack

00:12:42,560 --> 00:12:46,240
to me it seems like we could lean on the

00:12:44,880 --> 00:12:48,240
type system a little bit better

00:12:46,240 --> 00:12:49,360
to help us along and indicate this is

00:12:48,240 --> 00:12:51,680
actually an error

00:12:49,360 --> 00:12:53,519
in an error state maybe you think of

00:12:51,680 --> 00:12:55,360
returning an error type instead but then

00:12:53,519 --> 00:12:57,600
the consuming code gets messy it has to

00:12:55,360 --> 00:12:59,680
check instant solvent things like this

00:12:57,600 --> 00:13:01,120
it's not the best we can do better than

00:12:59,680 --> 00:13:03,600
this

00:13:01,120 --> 00:13:04,839
but for now let's look at this function

00:13:03,600 --> 00:13:07,760
so first

00:13:04,839 --> 00:13:09,680
we get the reserve seats for that flight

00:13:07,760 --> 00:13:13,040
from the database

00:13:09,680 --> 00:13:14,160
then we check if there's capacity if not

00:13:13,040 --> 00:13:18,480
we return undefined

00:13:14,160 --> 00:13:20,160
as i mentioned and if the capacity

00:13:18,480 --> 00:13:22,480
is sufficient we can create a

00:13:20,160 --> 00:13:26,480
preservation

00:13:22,480 --> 00:13:30,880
cool so that's a first look through the

00:13:26,480 --> 00:13:33,360
promise based code and i want to draw

00:13:30,880 --> 00:13:34,639
attention to an aspect of this code that

00:13:33,360 --> 00:13:37,760
can be improved

00:13:34,639 --> 00:13:39,120
um with a library uh that comes with

00:13:37,760 --> 00:13:40,959
fpts

00:13:39,120 --> 00:13:42,399
i could do a great i could i could go

00:13:40,959 --> 00:13:44,480
through and talk through this but

00:13:42,399 --> 00:13:46,639
i thought i'd leave it best to an

00:13:44,480 --> 00:13:49,199
existing talk by robin paconi

00:13:46,639 --> 00:13:51,120
who explains this concept extremely well

00:13:49,199 --> 00:13:52,480
uh in seven minutes validation

00:13:51,120 --> 00:13:54,399
and honestly you should go check it out

00:13:52,480 --> 00:13:55,839
it's awesome um

00:13:54,399 --> 00:13:57,839
yeah it's type functional programming

00:13:55,839 --> 00:14:01,040
and type scripts with fpts

00:13:57,839 --> 00:14:04,399
back to the promised base code so

00:14:01,040 --> 00:14:07,440
you're probably wondering fred why

00:14:04,399 --> 00:14:10,800
did you write from what

00:14:07,440 --> 00:14:13,279
write the code in a promise-based style

00:14:10,800 --> 00:14:14,800
well i was thinking for a long time

00:14:13,279 --> 00:14:18,000
about the best way

00:14:14,800 --> 00:14:20,800
to create this deep mapping

00:14:18,000 --> 00:14:23,279
uh intuitive mapping between code you

00:14:20,800 --> 00:14:24,720
already know and familiar with promises

00:14:23,279 --> 00:14:27,279
and functional programming because i

00:14:24,720 --> 00:14:29,680
believe with this mapping

00:14:27,279 --> 00:14:31,199
then you can go and be more empowered to

00:14:29,680 --> 00:14:33,600
write functional code yourself

00:14:31,199 --> 00:14:35,600
with a better deeper understanding of it

00:14:33,600 --> 00:14:39,199
and sometimes you have to go backwards

00:14:35,600 --> 00:14:41,839
to go forwards so

00:14:39,199 --> 00:14:43,120
how i'm going to relate this promises to

00:14:41,839 --> 00:14:45,600
functional programming

00:14:43,120 --> 00:14:47,600
is you can think of promises as being a

00:14:45,600 --> 00:14:49,920
framework

00:14:47,600 --> 00:14:50,639
when you write normal code you kind of

00:14:49,920 --> 00:14:52,639
say

00:14:50,639 --> 00:14:55,120
okay let's pass the data around and you

00:14:52,639 --> 00:14:56,959
pass it then around yourself manually

00:14:55,120 --> 00:14:59,199
then when you use promises instead of

00:14:56,959 --> 00:15:01,839
passing the data around yourself

00:14:59,199 --> 00:15:02,560
you just tell from promises what to do

00:15:01,839 --> 00:15:05,680
when data

00:15:02,560 --> 00:15:07,440
exists so you say you call these dot

00:15:05,680 --> 00:15:09,839
then calls and then you just trust

00:15:07,440 --> 00:15:12,480
promises the promise framework to pass

00:15:09,839 --> 00:15:13,600
the data around for you and then if an

00:15:12,480 --> 00:15:15,600
error happens

00:15:13,600 --> 00:15:17,360
you trust the promise to handle that

00:15:15,600 --> 00:15:20,079
error and

00:15:17,360 --> 00:15:21,040
execute either the next catch callback

00:15:20,079 --> 00:15:23,279
you've registered

00:15:21,040 --> 00:15:24,639
or just reject that whole promise so to

00:15:23,279 --> 00:15:26,399
illustrate this in code

00:15:24,639 --> 00:15:28,880
and how this maps to function a

00:15:26,399 --> 00:15:30,880
functional style with fpts

00:15:28,880 --> 00:15:32,320
i've taken the code for the tri-exit

00:15:30,880 --> 00:15:35,839
method you've already seen

00:15:32,320 --> 00:15:38,800
and just reduce it down to the promise

00:15:35,839 --> 00:15:40,240
backbone what we can see here is we're

00:15:38,800 --> 00:15:42,399
getting the reserve seats again

00:15:40,240 --> 00:15:44,160
and then we're chained with.mit.dan

00:15:42,399 --> 00:15:47,519
message

00:15:44,160 --> 00:15:49,680
callback onto that promise

00:15:47,519 --> 00:15:51,440
and the same code written in functional

00:15:49,680 --> 00:15:52,720
style actually looks quite similar

00:15:51,440 --> 00:15:55,440
on the right we have the same code

00:15:52,720 --> 00:15:57,600
written in a functional style

00:15:55,440 --> 00:15:59,040
it's probably a lot to take in at first

00:15:57,600 --> 00:16:01,440
but let's dive through it

00:15:59,040 --> 00:16:03,920
piece by piece so first we're going to

00:16:01,440 --> 00:16:05,759
look at the return types

00:16:03,920 --> 00:16:07,360
on the left we return a promise as

00:16:05,759 --> 00:16:09,440
normal and on the right

00:16:07,360 --> 00:16:10,399
we're returning this thing called a task

00:16:09,440 --> 00:16:14,000
either

00:16:10,399 --> 00:16:17,680
this is something fpts provides for us

00:16:14,000 --> 00:16:20,800
and you import it like so and

00:16:17,680 --> 00:16:21,759
what a task either is is it's a

00:16:20,800 --> 00:16:24,639
combination

00:16:21,759 --> 00:16:26,000
of a task and an ether a task you could

00:16:24,639 --> 00:16:28,240
think of as a promise

00:16:26,000 --> 00:16:30,240
some asynchronous code that never fails

00:16:28,240 --> 00:16:31,600
always succeeds

00:16:30,240 --> 00:16:34,399
and you can think of an either

00:16:31,600 --> 00:16:38,000
representing either a failure state

00:16:34,399 --> 00:16:39,199
or a success state and when we return a

00:16:38,000 --> 00:16:40,560
task either

00:16:39,199 --> 00:16:42,639
it's not going to return those that

00:16:40,560 --> 00:16:43,680
error or that success state directly but

00:16:42,639 --> 00:16:45,920
it's going to wrap us

00:16:43,680 --> 00:16:47,600
wrap it in this type which we can then

00:16:45,920 --> 00:16:50,800
use

00:16:47,600 --> 00:16:52,720
use other functional programming

00:16:50,800 --> 00:16:54,160
functions which are given to us by apts

00:16:52,720 --> 00:16:56,959
to handle

00:16:54,160 --> 00:16:59,120
this newly returned type pretty

00:16:56,959 --> 00:17:02,639
seamlessly

00:16:59,120 --> 00:17:04,000
so back to the code now let's look

00:17:02,639 --> 00:17:07,039
we've looked at the return types now

00:17:04,000 --> 00:17:10,400
let's look at the function bodies

00:17:07,039 --> 00:17:13,679
so what i want to point out here

00:17:10,400 --> 00:17:16,079
on the left is

00:17:13,679 --> 00:17:18,720
that we kind of take a promise that's

00:17:16,079 --> 00:17:22,000
returned from get reserved seats

00:17:18,720 --> 00:17:23,839
and we chain a dot then call onto this

00:17:22,000 --> 00:17:25,600
promise as i mentioned before

00:17:23,839 --> 00:17:27,600
but the key thing is a key difference

00:17:25,600 --> 00:17:30,000
between functional programming and

00:17:27,600 --> 00:17:31,360
promises is that that promise is created

00:17:30,000 --> 00:17:34,400
for us and we just kind of

00:17:31,360 --> 00:17:36,480
use it it's different in functional

00:17:34,400 --> 00:17:38,880
programming because we construct

00:17:36,480 --> 00:17:41,200
that framework for a function ourselves

00:17:38,880 --> 00:17:44,320
manually because we want to have control

00:17:41,200 --> 00:17:46,160
over what type we use i've shown you a

00:17:44,320 --> 00:17:46,960
task either and there's many other types

00:17:46,160 --> 00:17:49,520
which i'll

00:17:46,960 --> 00:17:50,960
get to at the end of the talk but for

00:17:49,520 --> 00:17:51,840
now we're going to use a task either and

00:17:50,960 --> 00:17:54,640
we can think

00:17:51,840 --> 00:17:56,320
of this do function that we also import

00:17:54,640 --> 00:17:58,480
from fbts

00:17:56,320 --> 00:18:00,960
as a constructor we're constructing this

00:17:58,480 --> 00:18:02,160
task either type and then we're chaining

00:18:00,960 --> 00:18:04,640
stuff onto

00:18:02,160 --> 00:18:05,440
that which we've constructed this is

00:18:04,640 --> 00:18:08,000
probably

00:18:05,440 --> 00:18:08,559
a lot to take in so far and there's more

00:18:08,000 --> 00:18:10,960
to come

00:18:08,559 --> 00:18:12,480
so prepare yourselves and there's gonna

00:18:10,960 --> 00:18:13,840
be a lot of learning in the next

00:18:12,480 --> 00:18:16,240
few slides but we're going to go through

00:18:13,840 --> 00:18:17,840
it very slowly so this is the same code

00:18:16,240 --> 00:18:19,120
as before

00:18:17,840 --> 00:18:20,960
but fleshed out a little bit more we're

00:18:19,120 --> 00:18:23,120
going to walk through this step by step

00:18:20,960 --> 00:18:25,120
what you can see is probably added in

00:18:23,120 --> 00:18:27,280
this slide is these strings reserved

00:18:25,120 --> 00:18:29,360
seats and reservation results

00:18:27,280 --> 00:18:30,960
this is another difference between

00:18:29,360 --> 00:18:31,840
promise based code and functional

00:18:30,960 --> 00:18:33,919
programming

00:18:31,840 --> 00:18:34,880
where in promises the data is passed

00:18:33,919 --> 00:18:37,280
down to you

00:18:34,880 --> 00:18:39,679
directly downwards so it's the result of

00:18:37,280 --> 00:18:42,559
one dot then call is passed down to

00:18:39,679 --> 00:18:45,600
the the parameter of the next stop angle

00:18:42,559 --> 00:18:46,960
passed down one by one by one

00:18:45,600 --> 00:18:49,039
functional programming works slightly

00:18:46,960 --> 00:18:52,880
differently and that you can treat these

00:18:49,039 --> 00:18:56,080
as variable assignments you can think

00:18:52,880 --> 00:18:58,400
of this buying reserved seats as

00:18:56,080 --> 00:18:59,760
we're going to do some computation and

00:18:58,400 --> 00:19:00,799
save it in their assertive seats

00:18:59,760 --> 00:19:03,360
variable

00:19:00,799 --> 00:19:04,720
and then we can the task either will

00:19:03,360 --> 00:19:06,720
pass this around for us and functional

00:19:04,720 --> 00:19:08,480
reporting will pass this around for us

00:19:06,720 --> 00:19:11,200
and we can use it wherever we want such

00:19:08,480 --> 00:19:14,000
as in the return

00:19:11,200 --> 00:19:15,679
return call at the bottom by the way the

00:19:14,000 --> 00:19:16,960
dot binds and the dot bind l

00:19:15,679 --> 00:19:18,960
and return these are all come from

00:19:16,960 --> 00:19:21,760
functional programming they're not

00:19:18,960 --> 00:19:22,880
the dot binds you're used to so for

00:19:21,760 --> 00:19:25,919
reserved seats

00:19:22,880 --> 00:19:29,200
the variable assignments what we do is

00:19:25,919 --> 00:19:31,360
we call the skip reserve seats method

00:19:29,200 --> 00:19:33,919
and we save it say the result of that in

00:19:31,360 --> 00:19:36,960
the reserve seats variable

00:19:33,919 --> 00:19:38,720
now i'll take a pause here and

00:19:36,960 --> 00:19:40,480
uh give you a big tip for when you're

00:19:38,720 --> 00:19:43,679
writing function code yourself

00:19:40,480 --> 00:19:46,240
is that always check the types match

00:19:43,679 --> 00:19:47,360
i talked about these behavior contracts

00:19:46,240 --> 00:19:48,720
and that was for a reason

00:19:47,360 --> 00:19:50,799
we need to make sure when we're writing

00:19:48,720 --> 00:19:52,080
functional code that the functions we

00:19:50,799 --> 00:19:55,280
call and the framework we

00:19:52,080 --> 00:19:58,240
have pushed into uh always match

00:19:55,280 --> 00:20:00,480
so how do you do that well in an editor

00:19:58,240 --> 00:20:01,760
like vs code and many other editors you

00:20:00,480 --> 00:20:05,120
can just hover over

00:20:01,760 --> 00:20:08,240
this method call and you'll see that uh

00:20:05,120 --> 00:20:10,720
the method returns a task either and so

00:20:08,240 --> 00:20:12,159
uh they're matching the same thing both

00:20:10,720 --> 00:20:14,559
task eithers

00:20:12,159 --> 00:20:15,440
ignore the te that's just an important

00:20:14,559 --> 00:20:17,919
thing

00:20:15,440 --> 00:20:19,360
next we're going to look at the

00:20:17,919 --> 00:20:20,880
reservation result this is where we do

00:20:19,360 --> 00:20:22,960
the business logic

00:20:20,880 --> 00:20:24,720
so we consume that reserve seeds

00:20:22,960 --> 00:20:26,480
variable which we

00:20:24,720 --> 00:20:27,760
just saved before and then we're doing

00:20:26,480 --> 00:20:28,960
some business logic

00:20:27,760 --> 00:20:30,880
again we'll check if there's enough

00:20:28,960 --> 00:20:33,679
capacity if not

00:20:30,880 --> 00:20:34,400
we create this error and then remember

00:20:33,679 --> 00:20:37,280
what i said

00:20:34,400 --> 00:20:39,120
about we can't just return data we have

00:20:37,280 --> 00:20:40,720
to wrap it in a type

00:20:39,120 --> 00:20:43,600
so we're wrapping this error that we

00:20:40,720 --> 00:20:46,960
return in a left type

00:20:43,600 --> 00:20:49,440
from this call and then

00:20:46,960 --> 00:20:50,159
if there's enough capacity we will just

00:20:49,440 --> 00:20:53,600
create

00:20:50,159 --> 00:20:56,799
the reservation and we'll check again

00:20:53,600 --> 00:20:59,039
uh that the types match and they do um

00:20:56,799 --> 00:21:00,480
this is a task either type so we can

00:20:59,039 --> 00:21:01,840
just return that directly

00:21:00,480 --> 00:21:04,080
now let's take a look at what it looks

00:21:01,840 --> 00:21:06,559
like to consume

00:21:04,080 --> 00:21:08,799
this function in the original api

00:21:06,559 --> 00:21:12,080
handler

00:21:08,799 --> 00:21:13,520
so we have this function and what i want

00:21:12,080 --> 00:21:16,080
to focus on

00:21:13,520 --> 00:21:17,840
first is again the function contracts i

00:21:16,080 --> 00:21:19,360
sound like a broken record but honestly

00:21:17,840 --> 00:21:20,880
it's important

00:21:19,360 --> 00:21:23,280
in this function contract on the first

00:21:20,880 --> 00:21:25,039
line we're returning a promise

00:21:23,280 --> 00:21:26,960
again like before we haven't changed

00:21:25,039 --> 00:21:27,919
anything i think this is really

00:21:26,960 --> 00:21:30,400
important

00:21:27,919 --> 00:21:31,919
that you can when you're starting out

00:21:30,400 --> 00:21:35,360
with functional programming

00:21:31,919 --> 00:21:37,360
you isolate the functional aspects of

00:21:35,360 --> 00:21:38,880
your application from the rest

00:21:37,360 --> 00:21:42,840
so then the consuming code is

00:21:38,880 --> 00:21:44,640
nonetheless this means

00:21:42,840 --> 00:21:46,960
that

00:21:44,640 --> 00:21:48,080
first your colleagues don't have to

00:21:46,960 --> 00:21:50,480
learn what functional programming is

00:21:48,080 --> 00:21:52,240
they can just use your code as normal

00:21:50,480 --> 00:21:53,919
and secondly if you want if you're

00:21:52,240 --> 00:21:56,559
experimenting

00:21:53,919 --> 00:22:00,000
with functional programming you can more

00:21:56,559 --> 00:22:01,760
easily take it away after the fact

00:22:00,000 --> 00:22:02,960
without having to change a lot more code

00:22:01,760 --> 00:22:04,480
it doesn't affect the rest of your

00:22:02,960 --> 00:22:06,400
application

00:22:04,480 --> 00:22:07,600
and so how we do this is we take this

00:22:06,400 --> 00:22:09,600
task either

00:22:07,600 --> 00:22:11,280
and we we pass it to this function

00:22:09,600 --> 00:22:14,000
called promis from te

00:22:11,280 --> 00:22:15,679
on the second line and that will just

00:22:14,000 --> 00:22:18,799
convert a task either to a promise it's

00:22:15,679 --> 00:22:18,799
really quite a simple function

00:22:19,039 --> 00:22:23,200
and we can and this will be included in

00:22:21,440 --> 00:22:26,159
the code examples which i'll look at the

00:22:23,200 --> 00:22:28,880
end of the presentation

00:22:26,159 --> 00:22:29,679
so as before we construct this task

00:22:28,880 --> 00:22:31,360
ether type

00:22:29,679 --> 00:22:32,720
and then we do some computation and we

00:22:31,360 --> 00:22:36,400
save those results

00:22:32,720 --> 00:22:38,080
in variables so we

00:22:36,400 --> 00:22:39,520
first need to validate the request that

00:22:38,080 --> 00:22:42,480
comes in from the client

00:22:39,520 --> 00:22:44,159
so we do this by executing some code and

00:22:42,480 --> 00:22:45,840
saving in reservation request

00:22:44,159 --> 00:22:47,360
what does that code look like well we

00:22:45,840 --> 00:22:49,280
now have this new method

00:22:47,360 --> 00:22:51,600
called validate reservation request

00:22:49,280 --> 00:22:53,440
which will return a task either

00:22:51,600 --> 00:22:55,600
but the thing is this will return just

00:22:53,440 --> 00:22:58,559
any old error it doesn't know about

00:22:55,600 --> 00:23:00,080
us wanting to return http codes so we

00:22:58,559 --> 00:23:01,360
have to change the error type and we do

00:23:00,080 --> 00:23:03,039
this with this function called change

00:23:01,360 --> 00:23:05,200
error type which again will be

00:23:03,039 --> 00:23:06,799
in the code examples this comes from

00:23:05,200 --> 00:23:09,600
fbts

00:23:06,799 --> 00:23:10,640
and that means that if this validate

00:23:09,600 --> 00:23:13,760
reservation request

00:23:10,640 --> 00:23:14,880
fails uh we'll change the error type to

00:23:13,760 --> 00:23:16,880
a 422

00:23:14,880 --> 00:23:18,480
and before passing it to kind of a task

00:23:16,880 --> 00:23:18,880
either backbone which will handle the

00:23:18,480 --> 00:23:22,000
error

00:23:18,880 --> 00:23:23,760
itself and return it to the client and

00:23:22,000 --> 00:23:25,600
if it succeeds we don't do anything we

00:23:23,760 --> 00:23:27,600
just let the result pass through

00:23:25,600 --> 00:23:28,640
and be saved in the reservation request

00:23:27,600 --> 00:23:31,760
variable

00:23:28,640 --> 00:23:35,120
next we consume that reservation request

00:23:31,760 --> 00:23:38,240
in the next bind

00:23:35,120 --> 00:23:39,919
where again we pass this reservation

00:23:38,240 --> 00:23:40,880
request into the tri-accept method as

00:23:39,919 --> 00:23:43,279
before

00:23:40,880 --> 00:23:44,240
and then we want to change the error

00:23:43,279 --> 00:23:45,200
type because again we don't want to

00:23:44,240 --> 00:23:46,799
return that error

00:23:45,200 --> 00:23:49,360
it gives to us we want to change the

00:23:46,799 --> 00:23:50,640
error to be a forbidden

00:23:49,360 --> 00:23:52,640
and so that will be returned to the

00:23:50,640 --> 00:23:56,400
client if it succeeds

00:23:52,640 --> 00:23:58,559
we can just uh pass it on to the return

00:23:56,400 --> 00:24:01,039
uh call the end and since we don't care

00:23:58,559 --> 00:24:02,720
about the actual result of the

00:24:01,039 --> 00:24:04,640
try accept or the reservation that's

00:24:02,720 --> 00:24:07,760
returned we just return it to one

00:24:04,640 --> 00:24:08,559
that's what we do in the last line that

00:24:07,760 --> 00:24:12,400
was a lot

00:24:08,559 --> 00:24:13,120
um now i want to say something at this

00:24:12,400 --> 00:24:15,760
point

00:24:13,120 --> 00:24:17,200
uh if this didn't make sense if i if we

00:24:15,760 --> 00:24:18,080
went through it pretty quickly and which

00:24:17,200 --> 00:24:20,400
we did

00:24:18,080 --> 00:24:23,120
it doesn't make any sense don't worry

00:24:20,400 --> 00:24:25,360
about it at this moment

00:24:23,120 --> 00:24:26,960
what i think you will have understood is

00:24:25,360 --> 00:24:28,400
that kind of intuitive mapping between

00:24:26,960 --> 00:24:30,159
how promises work

00:24:28,400 --> 00:24:32,720
and how functional programming code is

00:24:30,159 --> 00:24:34,559
written and that's what matters

00:24:32,720 --> 00:24:36,080
the code the specific code does not

00:24:34,559 --> 00:24:38,080
matter and

00:24:36,080 --> 00:24:39,360
what i suggest you do is if some of this

00:24:38,080 --> 00:24:43,600
didn't make sense

00:24:39,360 --> 00:24:46,960
i will link the code examples

00:24:43,600 --> 00:24:48,000
from the from this talk at the end of

00:24:46,960 --> 00:24:50,320
the talk

00:24:48,000 --> 00:24:51,200
and uh you can play around with this in

00:24:50,320 --> 00:24:53,360
your own editor

00:24:51,200 --> 00:24:55,679
on the editor i provide and kind of

00:24:53,360 --> 00:24:57,840
hover over and see the types and maybe

00:24:55,679 --> 00:24:59,919
change some code and see how that works

00:24:57,840 --> 00:25:02,240
and play around with it there and kind

00:24:59,919 --> 00:25:04,240
of get a deeper understanding for it

00:25:02,240 --> 00:25:05,919
but for now i think we should crack on

00:25:04,240 --> 00:25:08,799
um

00:25:05,919 --> 00:25:10,159
and i mentioned that one of the benefits

00:25:08,799 --> 00:25:13,600
was refactoring

00:25:10,159 --> 00:25:16,159
and i want to show how that looks like

00:25:13,600 --> 00:25:17,760
and how the type system helps us out so

00:25:16,159 --> 00:25:19,120
let's imagine we're changing this try

00:25:17,760 --> 00:25:21,279
accept method

00:25:19,120 --> 00:25:22,159
from just accepting a capacity as a

00:25:21,279 --> 00:25:24,400
number

00:25:22,159 --> 00:25:25,360
to accepting a function that returns a

00:25:24,400 --> 00:25:27,039
task

00:25:25,360 --> 00:25:29,520
remember we can think of a task as a

00:25:27,039 --> 00:25:31,039
promise that never fails

00:25:29,520 --> 00:25:33,120
so what that looks like in promise based

00:25:31,039 --> 00:25:35,679
code is

00:25:33,120 --> 00:25:38,080
we have the parameter capacity which is

00:25:35,679 --> 00:25:40,559
a function that returns a promise

00:25:38,080 --> 00:25:41,600
and then we consume this by changing

00:25:40,559 --> 00:25:44,640
another dot thing call

00:25:41,600 --> 00:25:46,559
on to the existing promise chain

00:25:44,640 --> 00:25:47,919
uh and we call this git capacity but

00:25:46,559 --> 00:25:49,760
that's past the parameter

00:25:47,919 --> 00:25:51,120
and then you can see the ugliness of

00:25:49,760 --> 00:25:53,760
promises where

00:25:51,120 --> 00:25:54,159
uh we have to pass this data around for

00:25:53,760 --> 00:25:56,720
us

00:25:54,159 --> 00:25:57,919
and this is where the benefits of fp buy

00:25:56,720 --> 00:26:00,799
because all this

00:25:57,919 --> 00:26:02,480
this uh do construction because it

00:26:00,799 --> 00:26:04,480
passes data around for us

00:26:02,480 --> 00:26:06,799
and what this would look like in a

00:26:04,480 --> 00:26:09,520
functional style with fpts

00:26:06,799 --> 00:26:10,960
is this is the tri accept method with

00:26:09,520 --> 00:26:14,880
the change parameter

00:26:10,960 --> 00:26:17,760
uh a function that returns a task and

00:26:14,880 --> 00:26:19,360
we would pass it in uh with a bind call

00:26:17,760 --> 00:26:21,279
and save it and try save it in this

00:26:19,360 --> 00:26:23,760
capacity variable

00:26:21,279 --> 00:26:25,200
now you could think i could probably

00:26:23,760 --> 00:26:26,159
just call this function and it will work

00:26:25,200 --> 00:26:29,679
for me

00:26:26,159 --> 00:26:30,480
unfortunately uh the type system will

00:26:29,679 --> 00:26:32,480
yell at you

00:26:30,480 --> 00:26:33,520
uh it'll give you this kind of cryptic

00:26:32,480 --> 00:26:36,640
error

00:26:33,520 --> 00:26:38,880
um actually it says that the first line

00:26:36,640 --> 00:26:39,840
task is not assignable to task either

00:26:38,880 --> 00:26:42,080
and at this point

00:26:39,840 --> 00:26:43,200
uh especially for writing functional

00:26:42,080 --> 00:26:45,679
code you'll

00:26:43,200 --> 00:26:46,240
start to say is this really worth it am

00:26:45,679 --> 00:26:48,159
i

00:26:46,240 --> 00:26:49,279
am i really getting anything out of this

00:26:48,159 --> 00:26:50,840
and you'll probably look at stack

00:26:49,279 --> 00:26:54,320
overflow for a while

00:26:50,840 --> 00:26:55,600
um and you you might lose some hope but

00:26:54,320 --> 00:26:57,039
please don't lose hope because the

00:26:55,600 --> 00:26:58,960
solution is really simple

00:26:57,039 --> 00:27:00,880
remember what i said before about us

00:26:58,960 --> 00:27:04,000
having to make sure the

00:27:00,880 --> 00:27:06,880
the types match well uh

00:27:04,000 --> 00:27:08,159
if they don't match there's helpers that

00:27:06,880 --> 00:27:10,480
fpcs gives us

00:27:08,159 --> 00:27:12,640
which really makes it easy to to convert

00:27:10,480 --> 00:27:15,760
types from one to the other

00:27:12,640 --> 00:27:18,880
so since git capacity returns a

00:27:15,760 --> 00:27:21,120
task and as before i mentioned that

00:27:18,880 --> 00:27:22,720
a task either is just a combination of

00:27:21,120 --> 00:27:26,000
tasks and either

00:27:22,720 --> 00:27:27,360
we can actually easily bring up this

00:27:26,000 --> 00:27:29,039
task

00:27:27,360 --> 00:27:31,600
into a task either and make it

00:27:29,039 --> 00:27:34,159
compatible with a helper method that's

00:27:31,600 --> 00:27:35,840
given to us from fbts

00:27:34,159 --> 00:27:38,240
there's the import call and we just

00:27:35,840 --> 00:27:40,559
called te.fromtask

00:27:38,240 --> 00:27:41,440
we passed it that getcapacity call and

00:27:40,559 --> 00:27:43,600
it's going to

00:27:41,440 --> 00:27:44,720
handle the the changing of the types for

00:27:43,600 --> 00:27:46,559
us and

00:27:44,720 --> 00:27:48,480
for consuming code it will look and feel

00:27:46,559 --> 00:27:49,840
like a task either but under the hood

00:27:48,480 --> 00:27:52,799
it's actually a task

00:27:49,840 --> 00:27:54,000
then as before we consume this new

00:27:52,799 --> 00:27:57,279
variable

00:27:54,000 --> 00:27:59,840
in the reservation result by adding a

00:27:57,279 --> 00:28:01,279
key to the the parameter list and

00:27:59,840 --> 00:28:03,440
there's no other changes

00:28:01,279 --> 00:28:04,559
cool so that was a quick refactoring and

00:28:03,440 --> 00:28:06,240
i hope i can show you

00:28:04,559 --> 00:28:08,320
i showed you how the type system helps

00:28:06,240 --> 00:28:11,200
us there by pointing out

00:28:08,320 --> 00:28:12,559
where that behavior was incompatible if

00:28:11,200 --> 00:28:16,000
we'd written the same code

00:28:12,559 --> 00:28:16,799
in promises and say we passed we tried

00:28:16,000 --> 00:28:19,760
to error

00:28:16,799 --> 00:28:20,640
um add an error handling handler for

00:28:19,760 --> 00:28:22,559
that with a

00:28:20,640 --> 00:28:24,799
catch for example the type system

00:28:22,559 --> 00:28:27,760
wouldn't help us out at all

00:28:24,799 --> 00:28:29,039
we'd be essentially writing extra code

00:28:27,760 --> 00:28:30,640
that needs to be maintained

00:28:29,039 --> 00:28:32,240
and reasoned about when understanding

00:28:30,640 --> 00:28:34,880
that function which

00:28:32,240 --> 00:28:36,159
doesn't benefit us at all because this

00:28:34,880 --> 00:28:39,440
capacity

00:28:36,159 --> 00:28:41,120
function can never fail and so

00:28:39,440 --> 00:28:43,760
typescript helps us out because it stops

00:28:41,120 --> 00:28:46,080
us writing that extraneous code

00:28:43,760 --> 00:28:46,960
and tells us hey look this can succeed

00:28:46,080 --> 00:28:49,520
always succeed

00:28:46,960 --> 00:28:50,720
don't need to worry about it there's

00:28:49,520 --> 00:28:54,000
also a benefit here

00:28:50,720 --> 00:28:55,039
that if we consume some code say from a

00:28:54,000 --> 00:28:57,200
library

00:28:55,039 --> 00:28:59,039
it gets a lot harder to reason about

00:28:57,200 --> 00:29:00,720
what that code does

00:28:59,039 --> 00:29:02,080
because you didn't write it so you don't

00:29:00,720 --> 00:29:04,240
know if it's going to fail or not how

00:29:02,080 --> 00:29:07,679
they handle errors and things like this

00:29:04,240 --> 00:29:11,039
and fpts makes it super easy

00:29:07,679 --> 00:29:13,440
because we can just see

00:29:11,039 --> 00:29:14,880
what the developer intended and the type

00:29:13,440 --> 00:29:16,480
system will help us

00:29:14,880 --> 00:29:18,640
when we're writing it but also in the

00:29:16,480 --> 00:29:21,360
future

00:29:18,640 --> 00:29:23,600
if the developer who writes a dependency

00:29:21,360 --> 00:29:25,440
changes how that code works

00:29:23,600 --> 00:29:27,039
typescript will tell us hey look now

00:29:25,440 --> 00:29:30,320
this thing can fail

00:29:27,039 --> 00:29:33,760
with the error like before uh

00:29:30,320 --> 00:29:35,200
with this kind of error and

00:29:33,760 --> 00:29:36,880
we can lean on the type system to help

00:29:35,200 --> 00:29:41,200
us out here anyway

00:29:36,880 --> 00:29:43,440
uh let's look briefly um

00:29:41,200 --> 00:29:44,640
at the other things that fp offers i'm

00:29:43,440 --> 00:29:46,880
not going to go through this list

00:29:44,640 --> 00:29:48,880
but in this talk i've only talked about

00:29:46,880 --> 00:29:51,919
tasks and tasks either

00:29:48,880 --> 00:29:54,240
but there's lots of other fp types

00:29:51,919 --> 00:29:55,679
which i'm which are super useful some of

00:29:54,240 --> 00:29:56,960
them have javascript equivalents some of

00:29:55,679 --> 00:29:59,039
them don't

00:29:56,960 --> 00:30:01,120
and this is really where the benefits of

00:29:59,039 --> 00:30:03,039
fp with correctness start to come up

00:30:01,120 --> 00:30:05,840
because you can represent

00:30:03,039 --> 00:30:07,120
lots of different kinds of behaviors in

00:30:05,840 --> 00:30:10,240
your application

00:30:07,120 --> 00:30:11,600
with these types and then your code

00:30:10,240 --> 00:30:13,440
becomes a lot more correct because as a

00:30:11,600 --> 00:30:14,480
consumer you know exactly how these

00:30:13,440 --> 00:30:18,240
functions work

00:30:14,480 --> 00:30:21,760
you're not just assuming all right so

00:30:18,240 --> 00:30:22,080
to close this out i want to talk about

00:30:21,760 --> 00:30:25,600
two

00:30:22,080 --> 00:30:28,720
things firstly i want to talk about

00:30:25,600 --> 00:30:32,000
what you can do right now uh

00:30:28,720 --> 00:30:33,840
and from today onwards so you've watched

00:30:32,000 --> 00:30:36,080
this maybe you've watched this talk

00:30:33,840 --> 00:30:37,279
uh and you're thinking okay i know a bit

00:30:36,080 --> 00:30:40,320
more about fbe

00:30:37,279 --> 00:30:42,080
um and i might use in the future

00:30:40,320 --> 00:30:43,840
uh but if you're a person who watched

00:30:42,080 --> 00:30:46,640
this talk and

00:30:43,840 --> 00:30:48,399
says great i i see this code and i want

00:30:46,640 --> 00:30:51,520
to write fpts tomorrow

00:30:48,399 --> 00:30:55,279
what can i do well

00:30:51,520 --> 00:30:57,120
what i recommend to you is

00:30:55,279 --> 00:30:58,559
uh the best scenario you could be in is

00:30:57,120 --> 00:30:59,519
that you have an upcoming project just

00:30:58,559 --> 00:31:02,799
like i did

00:30:59,519 --> 00:31:04,000
which you could work using fp for

00:31:02,799 --> 00:31:05,840
so it could be a project that's

00:31:04,000 --> 00:31:07,919
sufficiently complicated maybe has some

00:31:05,840 --> 00:31:10,320
database calls

00:31:07,919 --> 00:31:11,760
is asynchronous maybe has some i o or

00:31:10,320 --> 00:31:13,919
just things that can fail

00:31:11,760 --> 00:31:15,519
what i suggest you do is you earmark

00:31:13,919 --> 00:31:19,200
this project

00:31:15,519 --> 00:31:21,919
to use fp4 and then you

00:31:19,200 --> 00:31:22,960
will write code for this project in an

00:31:21,919 --> 00:31:24,399
isolated manner

00:31:22,960 --> 00:31:27,440
which doesn't affect the rest of your

00:31:24,399 --> 00:31:30,080
code base using those function contracts

00:31:27,440 --> 00:31:30,960
and then you can evaluate it with that

00:31:30,080 --> 00:31:33,840
the second

00:31:30,960 --> 00:31:35,440
scenario i think that you could be in is

00:31:33,840 --> 00:31:38,960
maybe you don't have an upcoming project

00:31:35,440 --> 00:31:39,679
but instead you um are maintaining some

00:31:38,960 --> 00:31:42,399
code

00:31:39,679 --> 00:31:43,039
and uh maybe you have some code that

00:31:42,399 --> 00:31:45,279
again is

00:31:43,039 --> 00:31:46,880
complicated enough can fail has daily db

00:31:45,279 --> 00:31:48,559
calls these kind of things

00:31:46,880 --> 00:31:49,919
uh what you can do is start to refactor

00:31:48,559 --> 00:31:51,519
some of that code

00:31:49,919 --> 00:31:53,600
into a functional style and you'll

00:31:51,519 --> 00:31:57,279
probably start to see there's

00:31:53,600 --> 00:31:59,679
places where code can error and

00:31:57,279 --> 00:32:00,720
fail the ways you didn't expect and you

00:31:59,679 --> 00:32:02,720
will end up

00:32:00,720 --> 00:32:04,080
improving that code just by refactoring

00:32:02,720 --> 00:32:05,840
it into fp

00:32:04,080 --> 00:32:07,519
and lastly i want to remind you of the

00:32:05,840 --> 00:32:11,600
big picture here why

00:32:07,519 --> 00:32:13,919
is fp important and at the start

00:32:11,600 --> 00:32:15,279
i mention these things with the pits of

00:32:13,919 --> 00:32:17,440
success

00:32:15,279 --> 00:32:18,960
today we've only had a time to talk

00:32:17,440 --> 00:32:21,440
about the correctness

00:32:18,960 --> 00:32:23,200
pit of success you have to take my word

00:32:21,440 --> 00:32:26,320
for it that these other pits

00:32:23,200 --> 00:32:28,960
isolation and testability really do help

00:32:26,320 --> 00:32:30,640
you write better code

00:32:28,960 --> 00:32:32,000
especially if you're working in a tdz

00:32:30,640 --> 00:32:33,600
style but

00:32:32,000 --> 00:32:35,120
maybe you'll write code first and then

00:32:33,600 --> 00:32:36,799
you test afterwards

00:32:35,120 --> 00:32:38,240
if you write code in a functional style

00:32:36,799 --> 00:32:40,480
you'll find that testing

00:32:38,240 --> 00:32:42,640
that code becomes super easy rather than

00:32:40,480 --> 00:32:43,840
having to refactor it after the point

00:32:42,640 --> 00:32:45,679
if you've tried to do this you

00:32:43,840 --> 00:32:46,960
understand uh what i mean with

00:32:45,679 --> 00:32:50,240
testability

00:32:46,960 --> 00:32:52,000
and again if you are interested

00:32:50,240 --> 00:32:53,440
in these pieces of success i recommend

00:32:52,000 --> 00:32:55,760
you go watch that

00:32:53,440 --> 00:32:57,679
talk by mark seaman functional

00:32:55,760 --> 00:33:00,640
architecture pits of success it really

00:32:57,679 --> 00:33:03,679
goes into this in a lot more detail

00:33:00,640 --> 00:33:04,559
but the purpose of my talk was to give

00:33:03,679 --> 00:33:07,679
you an

00:33:04,559 --> 00:33:09,600
example of real world code in typescript

00:33:07,679 --> 00:33:11,200
and i hope i delivered on that promise

00:33:09,600 --> 00:33:12,640
for you and then you now have more

00:33:11,200 --> 00:33:15,919
confidence in writing

00:33:12,640 --> 00:33:17,200
real-world functional code in typescript

00:33:15,919 --> 00:33:19,519
with fpts

00:33:17,200 --> 00:33:22,960
a little bit about my company i just

00:33:19,519 --> 00:33:25,440
want to mention them i work for imagex

00:33:22,960 --> 00:33:27,440
what we do is we will take images from

00:33:25,440 --> 00:33:29,760
where they're stored on your server

00:33:27,440 --> 00:33:31,279
uh we allow you to change them using

00:33:29,760 --> 00:33:32,000
your parameters and then deliver them to

00:33:31,279 --> 00:33:35,440
your users

00:33:32,000 --> 00:33:36,399
as fast as possible um i also personally

00:33:35,440 --> 00:33:39,600
like the company

00:33:36,399 --> 00:33:41,919
uh they're the team uh

00:33:39,600 --> 00:33:44,320
everyone on the team is super smart and

00:33:41,919 --> 00:33:46,480
um also driven to

00:33:44,320 --> 00:33:47,840
to improve the product and work together

00:33:46,480 --> 00:33:48,880
as a team and they're really good team

00:33:47,840 --> 00:33:50,960
players

00:33:48,880 --> 00:33:53,039
and if you're interested we're offering

00:33:50,960 --> 00:33:56,320
a chance to get three dollars of credit

00:33:53,039 --> 00:33:58,720
um in this country at this conference so

00:33:56,320 --> 00:33:59,919
uh please come to our booth and have a

00:33:58,720 --> 00:34:03,840
talk to us

00:33:59,919 --> 00:34:05,919
uh and otherwise um i'll also be there

00:34:03,840 --> 00:34:06,960
if you wanna come talk about this talk

00:34:05,919 --> 00:34:09,599
and yeah

00:34:06,960 --> 00:34:11,200
that's been my talk and i hope you've

00:34:09,599 --> 00:34:12,960
enjoyed it and please

00:34:11,200 --> 00:34:21,839
enjoy the rest of your conference thank

00:34:12,960 --> 00:34:21,839
you very much

00:34:27,699 --> 00:34:33,839
[Music]

00:34:32,240 --> 00:34:35,839
hey frederick thanks for that that was

00:34:33,839 --> 00:34:37,599
amazing

00:34:35,839 --> 00:34:38,879
thank you so much it's a pleasure to

00:34:37,599 --> 00:34:40,800
give this talk

00:34:38,879 --> 00:34:41,839
um yeah it's great i think functional

00:34:40,800 --> 00:34:43,280
program is one of those things that

00:34:41,839 --> 00:34:45,359
everyone is

00:34:43,280 --> 00:34:46,320
forever interested in but is often kind

00:34:45,359 --> 00:34:48,399
of uh

00:34:46,320 --> 00:34:50,240
impenetrable gets weirdly academic so

00:34:48,399 --> 00:34:52,480
it's great to see that kind of

00:34:50,240 --> 00:34:53,599
accessible and real-world approach to it

00:34:52,480 --> 00:34:55,760
rather than

00:34:53,599 --> 00:34:56,720
um something a bit more up in the air um

00:34:55,760 --> 00:34:58,400
so for everyone

00:34:56,720 --> 00:35:00,640
that's in the chat um if you've got

00:34:58,400 --> 00:35:02,880
questions uh stick them in the q a panel

00:35:00,640 --> 00:35:04,079
we'll put them to frederick uh i'm i'm

00:35:02,880 --> 00:35:05,520
glad to say there's none at the moment

00:35:04,079 --> 00:35:08,480
which means i can ask you my questions

00:35:05,520 --> 00:35:11,760
which is why i was asked to go over it

00:35:08,480 --> 00:35:13,760
um i was curious with the the like

00:35:11,760 --> 00:35:15,200
typescript and functional programming

00:35:13,760 --> 00:35:17,599
seemed to work really nice together

00:35:15,200 --> 00:35:19,200
do you think like strong typing and

00:35:17,599 --> 00:35:19,920
functional go hand in hand or do you

00:35:19,200 --> 00:35:23,040
think

00:35:19,920 --> 00:35:23,040
there's some flexibility there

00:35:23,200 --> 00:35:29,440
um pretty much yeah my

00:35:26,240 --> 00:35:30,800
overalls will be here since you know

00:35:29,440 --> 00:35:33,119
when you shift from that

00:35:30,800 --> 00:35:35,359
type script or type kind of typing type

00:35:33,119 --> 00:35:37,119
system up to a functional system

00:35:35,359 --> 00:35:38,640
you get those the main benefit is the

00:35:37,119 --> 00:35:39,040
behavior contracts this is kind of what

00:35:38,640 --> 00:35:41,119
we're

00:35:39,040 --> 00:35:42,800
really going for and so when you're

00:35:41,119 --> 00:35:44,400
developing you can

00:35:42,800 --> 00:35:46,800
lean on the type system to help you out

00:35:44,400 --> 00:35:50,160
that is really the main benefit when you

00:35:46,800 --> 00:35:52,960
you code in a language like javascript

00:35:50,160 --> 00:35:55,760
um and so i think in in javascript world

00:35:52,960 --> 00:35:59,359
yeah they kind of go hand in hand

00:35:55,760 --> 00:36:00,960
but there are other opportunities to

00:35:59,359 --> 00:36:04,880
use function programming without static

00:36:00,960 --> 00:36:06,960
typing closure has no static types

00:36:04,880 --> 00:36:08,480
and still has a lot of the benefits of

00:36:06,960 --> 00:36:10,400
functional programming

00:36:08,480 --> 00:36:12,640
and also if you kind of want to just go

00:36:10,400 --> 00:36:14,240
for map juice like the lower dash render

00:36:12,640 --> 00:36:15,359
kind of style functional programming

00:36:14,240 --> 00:36:17,440
which is a little bit different that

00:36:15,359 --> 00:36:19,280
also works without typescript but

00:36:17,440 --> 00:36:20,720
for this kind of specific variety you

00:36:19,280 --> 00:36:22,400
know of

00:36:20,720 --> 00:36:24,640
of functional programming you need to

00:36:22,400 --> 00:36:26,640
need a system for it

00:36:24,640 --> 00:36:29,200
and it also gives you all those nice um

00:36:26,640 --> 00:36:31,280
like id integrations where you can

00:36:29,200 --> 00:36:33,200
you can get good suggestions um you

00:36:31,280 --> 00:36:36,800
showed off some of some of the like

00:36:33,200 --> 00:36:39,599
typing support um is there anything like

00:36:36,800 --> 00:36:43,440
is there anything that beneficial from

00:36:39,599 --> 00:36:43,440
fbts in terms of other dev tooling

00:36:44,240 --> 00:36:47,280
uh sorry what was the what was the first

00:36:46,079 --> 00:36:49,520
product question you said

00:36:47,280 --> 00:36:50,400
so you you mentioned that in vs code you

00:36:49,520 --> 00:36:53,440
can get like

00:36:50,400 --> 00:36:54,240
uh your type definitions when you hover

00:36:53,440 --> 00:36:57,119
over a

00:36:54,240 --> 00:36:57,520
hover over type um is there any else is

00:36:57,119 --> 00:36:59,119
there any

00:36:57,520 --> 00:37:00,640
other nice like dev tooling that comes

00:36:59,119 --> 00:37:03,680
through with uh fpt

00:37:00,640 --> 00:37:06,000
uh unfortunately i wouldn't say so

00:37:03,680 --> 00:37:07,359
and i think there was a part of the talk

00:37:06,000 --> 00:37:10,160
i kind of referenced

00:37:07,359 --> 00:37:11,680
robin's talk about validation and this

00:37:10,160 --> 00:37:12,320
is something you can see either of my

00:37:11,680 --> 00:37:14,880
code

00:37:12,320 --> 00:37:16,400
examples which i'll post afterwards or

00:37:14,880 --> 00:37:17,760
you can go watch this talk about

00:37:16,400 --> 00:37:20,000
what that does it's not really dev

00:37:17,760 --> 00:37:20,640
tooling it's a runtime thing basically

00:37:20,000 --> 00:37:23,200
it will

00:37:20,640 --> 00:37:24,160
ensure that any data you pass to it say

00:37:23,200 --> 00:37:26,240
in my example

00:37:24,160 --> 00:37:28,000
the api handler it will validate that

00:37:26,240 --> 00:37:28,560
reservation request for you to a very

00:37:28,000 --> 00:37:31,599
strict

00:37:28,560 --> 00:37:34,640
data kind of structure

00:37:31,599 --> 00:37:35,680
and it does that very very seamlessly i

00:37:34,640 --> 00:37:37,119
will say

00:37:35,680 --> 00:37:38,960
and so that's i guess the one of the

00:37:37,119 --> 00:37:41,599
biggest benefits but yeah the

00:37:38,960 --> 00:37:42,000
the main one is the is the ide support

00:37:41,599 --> 00:37:44,480
and then

00:37:42,000 --> 00:37:45,760
of course the type system that's cool uh

00:37:44,480 --> 00:37:48,320
so we've got some questions coming in

00:37:45,760 --> 00:37:49,680
so um sure any tips on solving the

00:37:48,320 --> 00:37:50,000
problem of leaving behind code that

00:37:49,680 --> 00:37:51,760
future

00:37:50,000 --> 00:37:54,320
devs might not be able to or want to

00:37:51,760 --> 00:37:54,320
refactor

00:37:55,200 --> 00:37:58,640
yeah it's a good question i'm just

00:37:56,960 --> 00:38:00,079
reading it again over on the right hand

00:37:58,640 --> 00:38:05,119
side

00:38:00,079 --> 00:38:05,839
um so i think uh this kind of goes back

00:38:05,119 --> 00:38:08,560
a little bit

00:38:05,839 --> 00:38:09,520
to uh one of my my closing thoughts

00:38:08,560 --> 00:38:11,520
which was

00:38:09,520 --> 00:38:13,040
i think a really good candidate for

00:38:11,520 --> 00:38:16,400
functional code is

00:38:13,040 --> 00:38:17,440
code that is um kind of prone to

00:38:16,400 --> 00:38:19,040
complexity

00:38:17,440 --> 00:38:21,520
lots of errors database calls

00:38:19,040 --> 00:38:24,160
asynchronous this kind of stuff

00:38:21,520 --> 00:38:25,599
um i think if you're kind of worried

00:38:24,160 --> 00:38:27,599
maybe about

00:38:25,599 --> 00:38:29,119
um delta's not willing to kind of

00:38:27,599 --> 00:38:31,200
maintain that code

00:38:29,119 --> 00:38:32,480
i think you should really start with the

00:38:31,200 --> 00:38:33,520
places where it's going to have the most

00:38:32,480 --> 00:38:35,440
benefits

00:38:33,520 --> 00:38:37,119
and then you know the best scenario is

00:38:35,440 --> 00:38:39,040
that they're going to to look at it

00:38:37,119 --> 00:38:41,040
and and go okay this is actually a lot

00:38:39,040 --> 00:38:43,599
cleaner than i would have to do

00:38:41,040 --> 00:38:45,280
um would be able to write myself and

00:38:43,599 --> 00:38:46,480
javascript and they'll kind of see the

00:38:45,280 --> 00:38:47,920
benefits of it but if you're just

00:38:46,480 --> 00:38:48,880
writing a hello world example or

00:38:47,920 --> 00:38:50,320
functional code or

00:38:48,880 --> 00:38:52,240
something like this they're not going to

00:38:50,320 --> 00:38:55,440
intuitively understand it

00:38:52,240 --> 00:38:56,320
um if you've used a library like rxjs

00:38:55,440 --> 00:38:57,920
before

00:38:56,320 --> 00:38:59,680
which kind of does the same thing but

00:38:57,920 --> 00:39:01,280
for reactive programming you also kind

00:38:59,680 --> 00:39:03,680
of understand what i mean

00:39:01,280 --> 00:39:05,359
that if you write if you have to write

00:39:03,680 --> 00:39:06,240
like a you know like an auto complete or

00:39:05,359 --> 00:39:07,839
something

00:39:06,240 --> 00:39:10,480
with normal javascript code that's a

00:39:07,839 --> 00:39:12,240
complete pain and with rxgs it just

00:39:10,480 --> 00:39:14,000
makes it obvious and i think this is the

00:39:12,240 --> 00:39:15,200
kind of thing which if you write it for

00:39:14,000 --> 00:39:17,839
a complex

00:39:15,200 --> 00:39:18,320
uh area a complex part of your of your

00:39:17,839 --> 00:39:20,560
of your

00:39:18,320 --> 00:39:22,240
code base it will just make sense and

00:39:20,560 --> 00:39:23,119
then that'll be the best chance for

00:39:22,240 --> 00:39:25,280
other devs to

00:39:23,119 --> 00:39:26,560
want to maintain it in the future so

00:39:25,280 --> 00:39:28,240
this is like the hook to get them into

00:39:26,560 --> 00:39:29,760
functional you leave behind

00:39:28,240 --> 00:39:31,920
leave behind some functional code in the

00:39:29,760 --> 00:39:34,560
code base the breadcrumbs

00:39:31,920 --> 00:39:35,760
and they come from the dark side exactly

00:39:34,560 --> 00:39:38,720
sounds good to me yeah

00:39:35,760 --> 00:39:41,520
um so the next one have you tried other

00:39:38,720 --> 00:39:44,160
fp to js languages like reason ml

00:39:41,520 --> 00:39:44,160
and rescript

00:39:44,720 --> 00:39:48,240
i haven't um i

00:39:46,940 --> 00:39:50,000
[Music]

00:39:48,240 --> 00:39:51,359
not because i i could have had a look at

00:39:50,000 --> 00:39:52,880
them um

00:39:51,359 --> 00:39:54,880
but not because i don't think they're

00:39:52,880 --> 00:39:56,640
valuable it's just because i want to

00:39:54,880 --> 00:39:57,839
maintain a high amount of compatibility

00:39:56,640 --> 00:40:00,960
with my team

00:39:57,839 --> 00:40:02,560
um and so if i were to i think with any

00:40:00,960 --> 00:40:05,359
big decision you have to make

00:40:02,560 --> 00:40:06,240
is how it's going to work in your

00:40:05,359 --> 00:40:08,560
organization

00:40:06,240 --> 00:40:10,240
and if i were to kind of campaign for

00:40:08,560 --> 00:40:12,960
using a um

00:40:10,240 --> 00:40:14,319
a language like this uh it's not popular

00:40:12,960 --> 00:40:17,440
it doesn't have much support

00:40:14,319 --> 00:40:18,880
uh it's not very stable um

00:40:17,440 --> 00:40:20,480
uh maybe there's some good up issues or

00:40:18,880 --> 00:40:22,800
something like this outstanding and so

00:40:20,480 --> 00:40:24,000
that that that campaign becomes quite

00:40:22,800 --> 00:40:25,760
weak

00:40:24,000 --> 00:40:27,599
but if i can stay inside a language we

00:40:25,760 --> 00:40:29,119
already use and just

00:40:27,599 --> 00:40:30,960
write parts of it in a more functional

00:40:29,119 --> 00:40:33,200
style

00:40:30,960 --> 00:40:34,640
it's not so hard for them to kind of get

00:40:33,200 --> 00:40:38,079
up on board there

00:40:34,640 --> 00:40:39,520
and it actually leads to a experience

00:40:38,079 --> 00:40:40,800
across the whole team which is really

00:40:39,520 --> 00:40:42,240
what i'm going for i'm not

00:40:40,800 --> 00:40:44,000
you know i don't adopt these

00:40:42,240 --> 00:40:45,920
technologies to

00:40:44,000 --> 00:40:47,839
make my life better but to make the kobe

00:40:45,920 --> 00:40:50,480
right better and my teams go better

00:40:47,839 --> 00:40:52,160
yeah so yeah yeah i think um kyle like

00:40:50,480 --> 00:40:54,480
alluded to this yesterday with the

00:40:52,160 --> 00:40:55,920
the talk you gave where it's not it's

00:40:54,480 --> 00:40:58,480
not like all or nothing you can

00:40:55,920 --> 00:41:00,000
start using some some functional

00:40:58,480 --> 00:41:02,720
approaches throughout your code like

00:41:00,000 --> 00:41:04,160
i imagine probably all of us are using

00:41:02,720 --> 00:41:07,040
all of the es6 like

00:41:04,160 --> 00:41:08,160
functional bits from es6 already without

00:41:07,040 --> 00:41:10,000
really thinking about it and

00:41:08,160 --> 00:41:11,839
actually we can start bringing more of

00:41:10,000 --> 00:41:13,440
that in as we go so it's not kind of

00:41:11,839 --> 00:41:14,880
terrifying um

00:41:13,440 --> 00:41:17,040
like jump ship straight into something

00:41:14,880 --> 00:41:17,599
else yeah exactly i think you definitely

00:41:17,040 --> 00:41:21,280
have to be

00:41:17,599 --> 00:41:23,119
quite pragmatic and um boring

00:41:21,280 --> 00:41:24,319
dare i say dare i full functional

00:41:23,119 --> 00:41:26,000
program boring but

00:41:24,319 --> 00:41:27,359
it's boring enough if you do it in

00:41:26,000 --> 00:41:28,640
typescript that it's not going to be a

00:41:27,359 --> 00:41:30,800
big issue hopefully

00:41:28,640 --> 00:41:31,760
yeah so i think at the beginning of your

00:41:30,800 --> 00:41:33,440
talk you mentioned

00:41:31,760 --> 00:41:35,040
um you'd had experience with i think

00:41:33,440 --> 00:41:37,760
haskell and fsharp

00:41:35,040 --> 00:41:38,560
um yeah yeah back in the day yeah okay

00:41:37,760 --> 00:41:41,599
yeah do you think

00:41:38,560 --> 00:41:43,359
that made it easier for you to jump into

00:41:41,599 --> 00:41:45,280
this like do you think learning the kind

00:41:43,359 --> 00:41:48,160
of functional bits

00:41:45,280 --> 00:41:49,280
in a serious functional language was a

00:41:48,160 --> 00:41:51,280
better approach or do you think

00:41:49,280 --> 00:41:53,680
maybe actually is a javascript developer

00:41:51,280 --> 00:41:55,920
this is an item

00:41:53,680 --> 00:41:57,119
i would say it definitely helps me yeah

00:41:55,920 --> 00:41:59,599
definitely help me because

00:41:57,119 --> 00:42:00,480
in those languages you have no option

00:41:59,599 --> 00:42:03,200
and

00:42:00,480 --> 00:42:04,800
also they um because you're writing

00:42:03,200 --> 00:42:06,480
because those languages designed for

00:42:04,800 --> 00:42:07,520
you're writing less code there so the

00:42:06,480 --> 00:42:09,119
learning curve

00:42:07,520 --> 00:42:10,880
is almost easier because you have less

00:42:09,119 --> 00:42:12,240
to understand like if there's just less

00:42:10,880 --> 00:42:14,079
characters on your screen

00:42:12,240 --> 00:42:15,599
there's less there's less stuff going on

00:42:14,079 --> 00:42:18,480
that you have to understand

00:42:15,599 --> 00:42:19,520
so that helps you learn differently um

00:42:18,480 --> 00:42:23,520
and it did help me

00:42:19,520 --> 00:42:26,640
learn this library but i will say that

00:42:23,520 --> 00:42:27,440
um i don't think it's necessarily any

00:42:26,640 --> 00:42:28,720
easier

00:42:27,440 --> 00:42:30,880
if you wanted to start learning

00:42:28,720 --> 00:42:32,319
functional programming uh with

00:42:30,880 --> 00:42:34,480
strategy typescript i think you could

00:42:32,319 --> 00:42:36,000
also have a good experience

00:42:34,480 --> 00:42:37,599
um and this is really one of the reasons

00:42:36,000 --> 00:42:39,680
i created this talk was

00:42:37,599 --> 00:42:41,119
you can kind of come from it from a

00:42:39,680 --> 00:42:42,319
theoretical angle but i think it's also

00:42:41,119 --> 00:42:43,920
really useful to have a

00:42:42,319 --> 00:42:45,440
real world practical example which you

00:42:43,920 --> 00:42:47,440
can follow on with

00:42:45,440 --> 00:42:49,839
say if you watch this on youtube again

00:42:47,440 --> 00:42:52,720
afterwards uh and code along with it

00:42:49,839 --> 00:42:52,720
it will start to

00:42:55,040 --> 00:42:59,839
that's the idea of it that makes sense

00:42:57,040 --> 00:42:59,839
yeah

00:43:00,160 --> 00:43:04,480
yeah totally yeah um i think you've it's

00:43:03,680 --> 00:43:05,920
one of those things

00:43:04,480 --> 00:43:08,079
i've put off fiddling much with

00:43:05,920 --> 00:43:09,200
typescript but i'm a big i love

00:43:08,079 --> 00:43:10,160
functional programming like i played

00:43:09,200 --> 00:43:11,280
around with pearl and high school quite

00:43:10,160 --> 00:43:13,760
a lot i love them

00:43:11,280 --> 00:43:15,440
and i'm now um chafing a bit to jump in

00:43:13,760 --> 00:43:17,200
and play with fpcs it feels like a good

00:43:15,440 --> 00:43:19,760
intro to both of them and

00:43:17,200 --> 00:43:20,560
um yeah like two birds one stone type

00:43:19,760 --> 00:43:23,359
thing

00:43:20,560 --> 00:43:24,880
um so another question from essan was is

00:43:23,359 --> 00:43:25,359
it possible to do something like promise

00:43:24,880 --> 00:43:28,000
all with

00:43:25,359 --> 00:43:28,000
fpts

00:43:30,400 --> 00:43:35,680
yeah there's a straight um comparison if

00:43:33,440 --> 00:43:36,480
if you look on one of the last slides of

00:43:35,680 --> 00:43:39,359
my

00:43:36,480 --> 00:43:40,880
um on my talk i had a comparison of

00:43:39,359 --> 00:43:43,760
types and javascript types

00:43:40,880 --> 00:43:44,880
so there's two ways to do it um you have

00:43:43,760 --> 00:43:48,160
kind of a straight

00:43:44,880 --> 00:43:50,400
uh i just pretty much straight

00:43:48,160 --> 00:43:51,680
uh i could swap to this thing called

00:43:50,400 --> 00:43:54,880
sequence t

00:43:51,680 --> 00:43:58,480
that's all right sequence s which will

00:43:54,880 --> 00:44:00,160
complete these tasks or task either

00:43:58,480 --> 00:44:02,000
simultaneously which is what promised to

00:44:00,160 --> 00:44:04,400
haul does and returns an array

00:44:02,000 --> 00:44:05,839
there's also another type which works

00:44:04,400 --> 00:44:07,680
very similarly except

00:44:05,839 --> 00:44:08,880
it executes all the tasks and tasks it

00:44:07,680 --> 00:44:10,800
does simultaneously

00:44:08,880 --> 00:44:13,040
but stores the result in an object which

00:44:10,800 --> 00:44:14,560
can be nicer depending if you want to

00:44:13,040 --> 00:44:16,720
uh to do it that way that's really cool

00:44:14,560 --> 00:44:19,359
yeah um i'm curious

00:44:16,720 --> 00:44:20,079
i assume you're using this when you work

00:44:19,359 --> 00:44:23,280
was this

00:44:20,079 --> 00:44:24,720
what led to this how did you find like

00:44:23,280 --> 00:44:27,680
bringing the rest of the team along with

00:44:24,720 --> 00:44:28,880
you with starting this this new idea if

00:44:27,680 --> 00:44:32,240
it's if it's the first time you've used

00:44:28,880 --> 00:44:32,240
this in your code base

00:44:34,400 --> 00:44:37,599
that's a great reason i guess we can all

00:44:35,839 --> 00:44:38,560
play this talk to people in our teams to

00:44:37,599 --> 00:44:40,880
explain yeah

00:44:38,560 --> 00:44:40,880
um

00:44:42,880 --> 00:44:49,440
unfortunately um i did i did

00:44:46,079 --> 00:44:52,800
childhood talk recently but um

00:44:49,440 --> 00:44:55,359
i some what some of them had experience

00:44:52,800 --> 00:44:56,720
with uh high school not many uh real

00:44:55,359 --> 00:44:58,480
world experience but at least

00:44:56,720 --> 00:44:59,920
kind of theoretical experience and so

00:44:58,480 --> 00:45:01,839
that was a big leg up

00:44:59,920 --> 00:45:02,960
um otherwise just walking through the

00:45:01,839 --> 00:45:04,560
code so

00:45:02,960 --> 00:45:06,800
i think it's really helpful to have

00:45:04,560 --> 00:45:08,079
someone alongside you to say

00:45:06,800 --> 00:45:09,839
you know you look at this and you go

00:45:08,079 --> 00:45:11,599
what the hell is this thing

00:45:09,839 --> 00:45:13,359
and then you go okay let's break it down

00:45:11,599 --> 00:45:14,720
slowly it looks like a promise it kind

00:45:13,359 --> 00:45:16,480
of works this way

00:45:14,720 --> 00:45:18,319
uh and then having someone there just to

00:45:16,480 --> 00:45:19,280
ask to answer your questions so i just

00:45:18,319 --> 00:45:20,720
sat down with my

00:45:19,280 --> 00:45:21,760
my colleagues and said hey look let's

00:45:20,720 --> 00:45:23,440
run through this if you have any

00:45:21,760 --> 00:45:24,400
questions let me know and we can talk

00:45:23,440 --> 00:45:26,000
through it um

00:45:24,400 --> 00:45:27,440
awesome it sounds like all of us will be

00:45:26,000 --> 00:45:29,440
jumping onto

00:45:27,440 --> 00:45:30,640
fpcs and dragging our teams with us

00:45:29,440 --> 00:45:32,240
which is a good thing

00:45:30,640 --> 00:45:34,079
um thank you so much that was amazing

00:45:32,240 --> 00:45:35,440
talk uh i really really enjoyed it and

00:45:34,079 --> 00:45:38,160
thanks for joining us

00:45:35,440 --> 00:45:38,960
um so we're gonna switch over no no of

00:45:38,160 --> 00:45:41,520
course

00:45:38,960 --> 00:45:42,400
um actually next talks about dino uh for

00:45:41,520 --> 00:45:45,119
anyone in the chat

00:45:42,400 --> 00:45:45,440
um i have a couple of exciting updates

00:45:45,119 --> 00:45:48,800
so

00:45:45,440 --> 00:45:50,160
all zero running a well all of the

00:45:48,800 --> 00:45:51,280
speakers are running these competitions

00:45:50,160 --> 00:45:52,079
if you go around you can get a secret

00:45:51,280 --> 00:45:54,319
code

00:45:52,079 --> 00:45:56,560
and you'll get into a competition to win

00:45:54,319 --> 00:45:59,119
uh some books and some t-shirts

00:45:56,560 --> 00:46:00,000
um also also running what what they've

00:45:59,119 --> 00:46:02,160
tantalisingly

00:46:00,000 --> 00:46:03,760
said to me is a login challenge which

00:46:02,160 --> 00:46:06,000
i'm fascinated about

00:46:03,760 --> 00:46:07,440
uh and you've got the chance to win a 75

00:46:06,000 --> 00:46:08,720
pound amazon gift card

00:46:07,440 --> 00:46:10,560
and there's five of those so you've got

00:46:08,720 --> 00:46:11,599
quite a good chance to win uh so feel

00:46:10,560 --> 00:46:13,599
free to drop in there

00:46:11,599 --> 00:46:15,040
um but maybe let's head back to the

00:46:13,599 --> 00:46:16,480
blacktail channel for the rest frederick

00:46:15,040 --> 00:46:29,839
again thank you so much for your talk

00:46:16,480 --> 00:46:29,839

YouTube URL: https://www.youtube.com/watch?v=-U9HQembktY


