Title: MobX, or: Going from Mutable to Immutable to Reactive State Management -  Michel Weststrate - CityJS
Publication date: 2020-10-03
Playlist: CityJS Conf 2020
Description: 
	"MobX is a state management library that is used across the globe, by companies big and small, such as Microsoft, EA, Netflix, Amazon and so on. The library is renown for its ease of use and lack of boilerplate. 

But also, it is quite magical. Or isn't it? 

And shouldn't we have stopped using mutative data structures by know? Or is the world not just limited to mutable and immutable, and is there a third kind of data structures?

Join this talk to learn about the wonderful world of reactive data structures and the benefits they yield in both developer and runtime efficiency."

Bio
Author of MobX, MobX-State-Tree, Immer and a plethora of smaller packages. On a quest to make programming as natural as possible. React, JavaScript and TypeScript fan. Working at Facebook on Dev tooling

Chapters
Start [00:00:00] 

Mutable Data [00:03:53]

Immutable Data [00:12:54]

Demo [00:14:40] 

Observable Data [00:17:25]

Idiomatic MobX [00:17:48] 

Computations are an orthnogonal render tree [00:21:19] 

Split into small components [00:26:06] 

Decouple doman logic and state from UI [00:27:32] 

Conclusion [00:30:30]

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:18,100 --> 00:00:23,119
[Music]

00:00:22,320 --> 00:00:26,160
hi folks

00:00:23,119 --> 00:00:26,560
evening and welcome to my talk about the

00:00:26,160 --> 00:00:30,240
bad

00:00:26,560 --> 00:00:35,200
ugly and the good or about

00:00:30,240 --> 00:00:36,880
a mutable immutable and observable data

00:00:35,200 --> 00:00:39,760
now you might be familiar with the first

00:00:36,880 --> 00:00:42,399
two those are well known paradigms

00:00:39,760 --> 00:00:42,960
but i'd argue tonight that there's a

00:00:42,399 --> 00:00:45,840
third

00:00:42,960 --> 00:00:46,800
and better paradigm and that is using

00:00:45,840 --> 00:00:50,000
observable data

00:00:46,800 --> 00:00:52,879
or reactive data as i might call it

00:00:50,000 --> 00:00:55,520
and that is what is used in example for

00:00:52,879 --> 00:00:59,840
example view js

00:00:55,520 --> 00:00:59,840
or in this case we're talking about mobx

00:01:00,800 --> 00:01:04,239
and so just for recap and you might

00:01:03,600 --> 00:01:05,920
probably

00:01:04,239 --> 00:01:07,520
be familiar with already but we're going

00:01:05,920 --> 00:01:10,880
to quickly recap on mutable

00:01:07,520 --> 00:01:13,760
and immutable data paradigms and then we

00:01:10,880 --> 00:01:14,400
discuss observable data and i also give

00:01:13,760 --> 00:01:16,880
a

00:01:14,400 --> 00:01:21,200
quick sneak preview on how you can use

00:01:16,880 --> 00:01:21,200
smoking 6 which is about to be released

00:01:22,159 --> 00:01:26,240
um so to kick off this story um i want

00:01:24,799 --> 00:01:29,119
to kick it off with this

00:01:26,240 --> 00:01:29,759
tweet from the gitzer he's quite a

00:01:29,119 --> 00:01:33,119
well-known

00:01:29,759 --> 00:01:35,600
guy so you might uh know him oh did i

00:01:33,119 --> 00:01:37,920
forget to introduce myself by the way

00:01:35,600 --> 00:01:39,119
so my name is michelle westrata i'm the

00:01:37,920 --> 00:01:42,320
author of mobixx

00:01:39,119 --> 00:01:43,680
um and also of immer an immutable data

00:01:42,320 --> 00:01:47,680
library

00:01:43,680 --> 00:01:51,920
and i'm currently working at facebook

00:01:47,680 --> 00:01:52,799
so hi um anyway back to the suite um so

00:01:51,920 --> 00:01:56,159
it's interesting

00:01:52,799 --> 00:01:59,520
interesting one because like

00:01:56,159 --> 00:02:02,719
it's excitement about hooks and context

00:01:59,520 --> 00:02:03,119
and that it's so expressive and that's

00:02:02,719 --> 00:02:07,520
correct

00:02:03,119 --> 00:02:10,800
it is and these are beautiful paradigms

00:02:07,520 --> 00:02:13,520
um but one thing it didn't solve

00:02:10,800 --> 00:02:15,920
which was solved already is efficiently

00:02:13,520 --> 00:02:17,280
rendering applications

00:02:15,920 --> 00:02:19,680
and so that's why in the end he

00:02:17,280 --> 00:02:21,920
concluded no i'm going back to using

00:02:19,680 --> 00:02:22,720
modex basically because i don't have to

00:02:21,920 --> 00:02:26,560
worry about

00:02:22,720 --> 00:02:26,560
optimization anymore

00:02:26,879 --> 00:02:32,640
and so let's explore that story a bit

00:02:30,000 --> 00:02:36,080
further today

00:02:32,640 --> 00:02:37,200
so for today's talk i build a demo

00:02:36,080 --> 00:02:39,200
application

00:02:37,200 --> 00:02:40,560
and it's not like you're difficult to do

00:02:39,200 --> 00:02:41,680
application because like to do

00:02:40,560 --> 00:02:45,200
applications are

00:02:41,680 --> 00:02:49,440
bad demo examples and i'll explain why

00:02:45,200 --> 00:02:51,360
um but this demo it has been order lines

00:02:49,440 --> 00:02:52,800
and habits of exchange rates that apply

00:02:51,360 --> 00:02:55,840
to them

00:02:52,800 --> 00:02:57,360
so in essence pretty straightforward but

00:02:55,840 --> 00:02:59,360
the interesting thing is that

00:02:57,360 --> 00:03:02,000
this demo has a cross-cutting concern

00:02:59,360 --> 00:03:04,800
namely the exchange rate

00:03:02,000 --> 00:03:06,319
so the state we have matches quite

00:03:04,800 --> 00:03:09,200
closely to the

00:03:06,319 --> 00:03:11,360
render tree we have but not entirely so

00:03:09,200 --> 00:03:13,599
for example if we render an order

00:03:11,360 --> 00:03:15,440
line that doesn't specifically and only

00:03:13,599 --> 00:03:17,840
depends on the status of the order line

00:03:15,440 --> 00:03:18,800
it also depends on statement that is

00:03:17,840 --> 00:03:22,000
living somewhere else

00:03:18,800 --> 00:03:23,920
namely the current currency the current

00:03:22,000 --> 00:03:25,599
exchange rate

00:03:23,920 --> 00:03:27,120
so this is a cross-cutting concern and

00:03:25,599 --> 00:03:30,239
as soon as you have those

00:03:27,120 --> 00:03:33,840
things get complicated

00:03:30,239 --> 00:03:36,560
immediately in the current paradigms

00:03:33,840 --> 00:03:37,840
um and other examples of that are like

00:03:36,560 --> 00:03:40,400
using text where

00:03:37,840 --> 00:03:42,319
you want for example change attack and

00:03:40,400 --> 00:03:43,920
then it should update in all places or

00:03:42,319 --> 00:03:45,519
locales

00:03:43,920 --> 00:03:46,959
there's many many examples most

00:03:45,519 --> 00:03:47,840
applications have those cross-cutting

00:03:46,959 --> 00:03:50,640
concerns

00:03:47,840 --> 00:03:51,200
so in essence the state is not a tree

00:03:50,640 --> 00:03:54,799
it's

00:03:51,200 --> 00:03:57,599
rather a graph and so let's model this

00:03:54,799 --> 00:03:59,920
with mutable data first

00:03:57,599 --> 00:04:01,599
and so here we have our demo application

00:03:59,920 --> 00:04:04,720
um we have the order set top

00:04:01,599 --> 00:04:08,319
exchange rates at the bottom and so

00:04:04,720 --> 00:04:11,200
if i toggle something you'll see that's

00:04:08,319 --> 00:04:13,200
like this ui and the boxes you see

00:04:11,200 --> 00:04:16,320
that's the react devtools that

00:04:13,200 --> 00:04:18,079
highlight the rerenders and so i can

00:04:16,320 --> 00:04:19,519
change the exchange rate and we see that

00:04:18,079 --> 00:04:25,040
this properly reflected

00:04:19,519 --> 00:04:25,040
in the ui so how's that modeled

00:04:25,280 --> 00:04:29,919
so here's the application first of all i

00:04:28,320 --> 00:04:30,400
put all the domain logic in a separate

00:04:29,919 --> 00:04:32,800
file

00:04:30,400 --> 00:04:34,400
so here we manage the currencies and we

00:04:32,800 --> 00:04:36,960
manage the orders

00:04:34,400 --> 00:04:38,560
and there's a bunch of straightforward

00:04:36,960 --> 00:04:40,880
updater functions that like change the

00:04:38,560 --> 00:04:44,240
currency change surprise

00:04:40,880 --> 00:04:46,800
add a new order etc nothing really

00:04:44,240 --> 00:04:47,440
super complicated about this um but

00:04:46,800 --> 00:04:50,720
that's like

00:04:47,440 --> 00:04:53,840
i separated the domain logic uh that's

00:04:50,720 --> 00:04:53,840
what i like to do in general

00:04:54,320 --> 00:05:02,800
and then i use to use ref hook basically

00:04:57,919 --> 00:05:04,720
to store the initial state

00:05:02,800 --> 00:05:06,639
and i just hold on to that reference

00:05:04,720 --> 00:05:06,960
like it's useful data so that references

00:05:06,639 --> 00:05:10,880
fell

00:05:06,960 --> 00:05:14,320
forever and then i have the special

00:05:10,880 --> 00:05:15,840
uh use force update hook um which gives

00:05:14,320 --> 00:05:16,240
me a render function which i can call

00:05:15,840 --> 00:05:19,759
which

00:05:16,240 --> 00:05:22,800
forces the uh tree to update

00:05:19,759 --> 00:05:25,840
um it's kind of a heck um but it does

00:05:22,800 --> 00:05:25,840
the job

00:05:26,639 --> 00:05:30,320
so then after that either the ui so

00:05:29,360 --> 00:05:33,520
there's orders

00:05:30,320 --> 00:05:34,800
there's component currencies and in the

00:05:33,520 --> 00:05:36,160
orders component we're in above the

00:05:34,800 --> 00:05:37,360
order lines

00:05:36,160 --> 00:05:39,360
and this is actually the most

00:05:37,360 --> 00:05:41,600
interesting component we will look a lot

00:05:39,360 --> 00:05:43,039
uh too so adrenals the other lines but

00:05:41,600 --> 00:05:44,080
also grabs the currencies from the

00:05:43,039 --> 00:05:47,120
context

00:05:44,080 --> 00:05:49,280
to be able to render that so

00:05:47,120 --> 00:05:51,120
if you profile this application and i

00:05:49,280 --> 00:05:53,120
changed the currency

00:05:51,120 --> 00:05:54,639
uh just one currency the euro we see

00:05:53,120 --> 00:05:58,240
that all the rows

00:05:54,639 --> 00:05:59,280
are rendering and the basic reason for

00:05:58,240 --> 00:06:02,319
that is like

00:05:59,280 --> 00:06:04,240
um when we call this render

00:06:02,319 --> 00:06:06,240
function it basically says like

00:06:04,240 --> 00:06:06,880
something changes application we don't

00:06:06,240 --> 00:06:09,039
know what

00:06:06,880 --> 00:06:10,720
um so good luck with it just re-render

00:06:09,039 --> 00:06:14,160
everything

00:06:10,720 --> 00:06:17,039
so um that's the most naive approach and

00:06:14,160 --> 00:06:20,400
you can see why it is pretty bad um but

00:06:17,039 --> 00:06:23,199
it is kind of our baseline

00:06:20,400 --> 00:06:25,360
and so if you look at the bonuses that

00:06:23,199 --> 00:06:27,759
read under if you if you

00:06:25,360 --> 00:06:30,639
picture that it's basically everything

00:06:27,759 --> 00:06:30,639
the entire tree

00:06:30,880 --> 00:06:36,720
so mutable data is in essence simply

00:06:34,639 --> 00:06:38,000
it's straightforward to write and it's

00:06:36,720 --> 00:06:40,720
also quite

00:06:38,000 --> 00:06:41,840
easy to test actually um it's just like

00:06:40,720 --> 00:06:45,840
a problem is like

00:06:41,840 --> 00:06:47,840
we have no clue what or when to render

00:06:45,840 --> 00:06:49,599
um so that's basically the essential

00:06:47,840 --> 00:06:51,919
problem we try to solve today

00:06:49,599 --> 00:06:53,360
it's like um if you have state um how

00:06:51,919 --> 00:06:55,520
does it affect rendering

00:06:53,360 --> 00:06:56,800
and so we have to answer two questions

00:06:55,520 --> 00:07:00,639
the first one is

00:06:56,800 --> 00:07:03,440
what data what state change and secondly

00:07:00,639 --> 00:07:06,080
where is it relevant which components

00:07:03,440 --> 00:07:08,400
are affected

00:07:06,080 --> 00:07:09,120
and so things get slightly better if you

00:07:08,400 --> 00:07:13,039
take a look at

00:07:09,120 --> 00:07:15,840
immutable data and

00:07:13,039 --> 00:07:17,520
that's quite a common pattern so you

00:07:15,840 --> 00:07:19,599
might be familiar with this um

00:07:17,520 --> 00:07:22,880
but again i'm just going to recap it to

00:07:19,599 --> 00:07:24,800
be able to draw a comparison later on

00:07:22,880 --> 00:07:26,160
so we're going to refactor our

00:07:24,800 --> 00:07:29,520
application

00:07:26,160 --> 00:07:31,360
in such a way that all our functions are

00:07:29,520 --> 00:07:32,720
pure

00:07:31,360 --> 00:07:34,880
and so that they don't mutate that

00:07:32,720 --> 00:07:37,280
anymore rather and they all produce a

00:07:34,880 --> 00:07:40,319
new collection of orders

00:07:37,280 --> 00:07:43,120
with the updates we intend applied

00:07:40,319 --> 00:07:44,000
so we loop over all the orders and we

00:07:43,120 --> 00:07:45,919
spread them out

00:07:44,000 --> 00:07:47,759
and for the relevant order we update the

00:07:45,919 --> 00:07:51,599
price the currency

00:07:47,759 --> 00:07:54,560
uh update um is similar

00:07:51,599 --> 00:07:56,160
and also adding order is now getting the

00:07:54,560 --> 00:07:56,639
old collection spreading it into a new

00:07:56,160 --> 00:07:59,840
one

00:07:56,639 --> 00:07:59,840
with the new one added

00:08:00,160 --> 00:08:05,360
and similar for the currencies we now

00:08:02,400 --> 00:08:07,520
produce in your currency table

00:08:05,360 --> 00:08:08,720
so when we have that that means that we

00:08:07,520 --> 00:08:11,039
no longer needed

00:08:08,720 --> 00:08:14,560
ugly hack to update and we're going to

00:08:11,039 --> 00:08:17,280
properly use a use state

00:08:14,560 --> 00:08:20,639
so we grab the state hook and we pass it

00:08:17,280 --> 00:08:20,639
the same initializer function

00:08:20,800 --> 00:08:24,400
so and then we have to update our event

00:08:23,280 --> 00:08:26,400
handlers

00:08:24,400 --> 00:08:28,080
so our event handlers now are going to

00:08:26,400 --> 00:08:30,319
take a current state

00:08:28,080 --> 00:08:32,320
um call those functions get the new

00:08:30,319 --> 00:08:35,039
state back and store that

00:08:32,320 --> 00:08:35,680
and this will automatically trigger a

00:08:35,039 --> 00:08:39,360
render

00:08:35,680 --> 00:08:41,680
by react now the nice benefit is

00:08:39,360 --> 00:08:44,080
because like all these data structures

00:08:41,680 --> 00:08:45,600
are immutable now

00:08:44,080 --> 00:08:49,600
is that we can start optimizing our

00:08:45,600 --> 00:08:53,120
components by wrapping memo around them

00:08:49,600 --> 00:08:55,839
so we all give them a little memo and

00:08:53,120 --> 00:08:57,040
they're set and there's now one final

00:08:55,839 --> 00:08:59,040
thing we should do

00:08:57,040 --> 00:09:00,560
is that we should also wrap our event

00:08:59,040 --> 00:09:02,720
handlers and use callback

00:09:00,560 --> 00:09:04,160
um otherwise you get new event handler

00:09:02,720 --> 00:09:07,279
every render and that would

00:09:04,160 --> 00:09:10,480
um validate all the memos so

00:09:07,279 --> 00:09:12,800
let's verify so

00:09:10,480 --> 00:09:15,519
everything is still working so we can

00:09:12,800 --> 00:09:15,519
profile this

00:09:15,680 --> 00:09:18,959
so again we change just the euro

00:09:17,920 --> 00:09:20,880
exchange rate

00:09:18,959 --> 00:09:22,160
and what we see now is like not

00:09:20,880 --> 00:09:25,680
everything is varying but

00:09:22,160 --> 00:09:28,640
almost everything most certainly

00:09:25,680 --> 00:09:29,600
all the rows are still rendering even

00:09:28,640 --> 00:09:33,600
the rows that

00:09:29,600 --> 00:09:33,600
don't use the euro exchange rate at all

00:09:33,760 --> 00:09:37,839
and the reason for that is that like

00:09:36,640 --> 00:09:40,560
they still grabbed it

00:09:37,839 --> 00:09:42,240
the currency table from the context and

00:09:40,560 --> 00:09:43,040
that table is new if we update one

00:09:42,240 --> 00:09:46,480
currency

00:09:43,040 --> 00:09:48,959
so they all have to reevaluate

00:09:46,480 --> 00:09:49,519
if that change they'll have to re-render

00:09:48,959 --> 00:09:52,800
basically

00:09:49,519 --> 00:09:56,240
because there's a new currency table so

00:09:52,800 --> 00:09:58,320
um but this is not the end of it because

00:09:56,240 --> 00:09:59,680
again we can optimize it so at this

00:09:58,320 --> 00:10:02,320
moment and this is what

00:09:59,680 --> 00:10:03,760
our update 3 look like we change the

00:10:02,320 --> 00:10:06,000
currencies the currencies

00:10:03,760 --> 00:10:07,279
issues by the order lines so all of them

00:10:06,000 --> 00:10:11,600
have to

00:10:07,279 --> 00:10:15,040
redraw but luckily we can make this

00:10:11,600 --> 00:10:18,000
a bit smarter so

00:10:15,040 --> 00:10:18,880
we can do this by making those

00:10:18,000 --> 00:10:22,240
components

00:10:18,880 --> 00:10:23,680
a little bit more pure so

00:10:22,240 --> 00:10:26,880
so far we grabbed the currencies from

00:10:23,680 --> 00:10:27,600
context but instead we want to get those

00:10:26,880 --> 00:10:29,200
passed in

00:10:27,600 --> 00:10:31,120
to the function so that we go through

00:10:29,200 --> 00:10:32,800
the memo function

00:10:31,120 --> 00:10:34,720
so we want to get them from the parent

00:10:32,800 --> 00:10:36,560
and so rather than grabbing different

00:10:34,720 --> 00:10:39,839
context we're going to

00:10:36,560 --> 00:10:42,320
pass them down so we do a little bit of

00:10:39,839 --> 00:10:42,320
plumbing

00:10:44,000 --> 00:10:50,720
and pass it down here as well

00:10:47,360 --> 00:10:50,720
then it can apply prettier

00:10:51,600 --> 00:10:54,720
and so now we can do something

00:10:53,120 --> 00:10:56,720
interesting because now

00:10:54,720 --> 00:10:58,720
and the thing is passed through memo we

00:10:56,720 --> 00:11:01,519
can make memo a little bit smarter

00:10:58,720 --> 00:11:02,640
and basically tell it to only update if

00:11:01,519 --> 00:11:06,399
a relevant

00:11:02,640 --> 00:11:08,000
currency change so we can skip

00:11:06,399 --> 00:11:10,000
re-rendering even when we receive new

00:11:08,000 --> 00:11:12,320
data if the order is still

00:11:10,000 --> 00:11:13,760
the same object and the currency is

00:11:12,320 --> 00:11:16,880
still the same object

00:11:13,760 --> 00:11:19,120
or if the current sheet change um but

00:11:16,880 --> 00:11:20,640
not the currency we're interested in so

00:11:19,120 --> 00:11:24,079
we we grab the

00:11:20,640 --> 00:11:26,720
grab the exchange rate from the order

00:11:24,079 --> 00:11:29,600
and we compare that with the exchange

00:11:26,720 --> 00:11:31,200
rate in the new currency stable

00:11:29,600 --> 00:11:32,560
and if that's still the same then we can

00:11:31,200 --> 00:11:35,360
still skip rendering even though we've

00:11:32,560 --> 00:11:35,360
got a new table

00:11:37,040 --> 00:11:43,839
and so this was your problem let's

00:11:40,560 --> 00:11:43,839
profile again

00:11:45,920 --> 00:11:51,200
profile again and we recorded one update

00:11:49,200 --> 00:11:53,040
and now we see that like the rows that

00:11:51,200 --> 00:11:54,320
aren't using the euro exchange rates

00:11:53,040 --> 00:11:57,680
didn't really render either

00:11:54,320 --> 00:11:58,800
so that's pretty good um the sad thing

00:11:57,680 --> 00:12:01,760
is though that like

00:11:58,800 --> 00:12:03,680
now the table um that like holds all

00:12:01,760 --> 00:12:05,040
your lines is still rendering and it's

00:12:03,680 --> 00:12:06,959
actually an even expensive more

00:12:05,040 --> 00:12:09,200
expensive component

00:12:06,959 --> 00:12:10,240
but it has to re-render basically to be

00:12:09,200 --> 00:12:13,920
able to pass that

00:12:10,240 --> 00:12:16,000
currency table uh down so

00:12:13,920 --> 00:12:17,920
actually probably optimizing this is

00:12:16,000 --> 00:12:20,399
even more complicated than this so

00:12:17,920 --> 00:12:21,040
what you could do is um create a wrapper

00:12:20,399 --> 00:12:25,680
component

00:12:21,040 --> 00:12:28,720
that like just grabs the currencies

00:12:25,680 --> 00:12:30,000
from the context and pass the id

00:12:28,720 --> 00:12:31,760
of the order line you want to render

00:12:30,000 --> 00:12:34,880
true

00:12:31,760 --> 00:12:38,399
and then have utility component to

00:12:34,880 --> 00:12:40,000
do the memorization and so actually

00:12:38,399 --> 00:12:41,440
probably optimizing this with those

00:12:40,000 --> 00:12:43,760
cross-cutting concerns

00:12:41,440 --> 00:12:46,720
is still pretty tricky if like not all

00:12:43,760 --> 00:12:46,720
your dates are relevant

00:12:49,600 --> 00:12:53,839
so this is basically what we ended up

00:12:52,000 --> 00:12:56,959
with

00:12:53,839 --> 00:13:00,079
um let's um switch paradigms so

00:12:56,959 --> 00:13:01,760
this immutable data stuff um

00:13:00,079 --> 00:13:03,120
it's a bit harder to read and write than

00:13:01,760 --> 00:13:04,959
than the original thing we had

00:13:03,120 --> 00:13:06,880
especially because like

00:13:04,959 --> 00:13:08,800
because you write doesn't match as

00:13:06,880 --> 00:13:10,399
closely your intention anymore like you

00:13:08,800 --> 00:13:10,800
intend to a bit currency but you

00:13:10,399 --> 00:13:14,079
actually

00:13:10,800 --> 00:13:16,480
write an entirely new table

00:13:14,079 --> 00:13:18,800
and but it does allow for many

00:13:16,480 --> 00:13:21,839
optimizations and

00:13:18,800 --> 00:13:24,720
memorization techniques

00:13:21,839 --> 00:13:26,240
so we can get better results with this

00:13:24,720 --> 00:13:28,880
it's it's far far better than using

00:13:26,240 --> 00:13:31,920
mutable data

00:13:28,880 --> 00:13:32,480
um but so when we look at our original

00:13:31,920 --> 00:13:36,480
problem

00:13:32,480 --> 00:13:39,440
um we can determine quite effectively

00:13:36,480 --> 00:13:40,399
what change by doing reference

00:13:39,440 --> 00:13:42,480
comparisons

00:13:40,399 --> 00:13:44,320
um but it's still hard to determine

00:13:42,480 --> 00:13:46,160
where it is relevant and so that's why

00:13:44,320 --> 00:13:48,880
we ended up writing this

00:13:46,160 --> 00:13:50,639
custom function or custom selector so if

00:13:48,880 --> 00:13:52,399
you use for example redix

00:13:50,639 --> 00:13:55,120
to figure out where the chain is

00:13:52,399 --> 00:13:55,120
actually relevant

00:13:55,760 --> 00:14:02,320
so let's go to observable data

00:13:59,839 --> 00:14:05,360
now the idea behind observable data is

00:14:02,320 --> 00:14:07,040
actually pretty straightforward

00:14:05,360 --> 00:14:08,639
it's basically like building

00:14:07,040 --> 00:14:12,079
spreadsheets and so the

00:14:08,639 --> 00:14:14,240
idea is that if you render some data

00:14:12,079 --> 00:14:16,800
if you run some fields of an object you

00:14:14,240 --> 00:14:18,399
subscribe to that field

00:14:16,800 --> 00:14:20,000
um and that means that like in the

00:14:18,399 --> 00:14:22,399
future um

00:14:20,000 --> 00:14:23,760
if one of those if one of those fields

00:14:22,399 --> 00:14:27,120
is going to change

00:14:23,760 --> 00:14:28,959
at that field update will notify

00:14:27,120 --> 00:14:32,000
exactly the observers that were

00:14:28,959 --> 00:14:32,000
listening to the chains

00:14:32,399 --> 00:14:37,600
that might sound a bit complicated it's

00:14:34,560 --> 00:14:40,800
easier to demo actually

00:14:37,600 --> 00:14:42,560
so let's go back to our code and what

00:14:40,800 --> 00:14:43,360
i'm going to do is i'm going to stash

00:14:42,560 --> 00:14:45,920
the changes

00:14:43,360 --> 00:14:47,040
i've made so far from the mutable stuff

00:14:45,920 --> 00:14:50,160
so we're back as a

00:14:47,040 --> 00:14:52,639
musical version because that's an easier

00:14:50,160 --> 00:14:54,959
starting point

00:14:52,639 --> 00:14:56,959
and from here on i really only have to

00:14:54,959 --> 00:14:59,519
make two changes

00:14:56,959 --> 00:15:00,160
and so this is again the ugly hacked

00:14:59,519 --> 00:15:03,040
rendering

00:15:00,160 --> 00:15:05,600
uh these are the uh simple original

00:15:03,040 --> 00:15:08,000
functions we had before

00:15:05,600 --> 00:15:08,720
and so i'm going to import use local

00:15:08,000 --> 00:15:11,519
observable

00:15:08,720 --> 00:15:14,000
and observer from object lite which is

00:15:11,519 --> 00:15:16,079
already installed

00:15:14,000 --> 00:15:17,360
so use local observable that's the one

00:15:16,079 --> 00:15:21,360
i'm going to use to

00:15:17,360 --> 00:15:25,519
basically create an observable object

00:15:21,360 --> 00:15:28,240
local to the component so i again

00:15:25,519 --> 00:15:30,079
give it the same initialization function

00:15:28,240 --> 00:15:33,600
and now i'm going to throw away

00:15:30,079 --> 00:15:33,600
my key re-rendering

00:15:33,759 --> 00:15:36,959
i'm just set and just what you want me

00:15:36,480 --> 00:15:38,959
to do

00:15:36,959 --> 00:15:40,560
i'm rather than applying ml to component

00:15:38,959 --> 00:15:41,360
i'm going to apply observer to a

00:15:40,560 --> 00:15:43,040
component

00:15:41,360 --> 00:15:44,720
and that means that this component will

00:15:43,040 --> 00:15:50,000
automatically subscribe

00:15:44,720 --> 00:15:50,000
to any observables used by its rendering

00:15:51,440 --> 00:15:57,920
so let's rub them

00:15:55,120 --> 00:15:59,519
okay that's all i changed two things and

00:15:57,920 --> 00:16:01,680
i put the mutable state

00:15:59,519 --> 00:16:04,320
in an observable and i've read a bunch

00:16:01,680 --> 00:16:06,720
of observer

00:16:04,320 --> 00:16:10,160
everything still seems to be working so

00:16:06,720 --> 00:16:10,160
i didn't make any mistakes

00:16:11,040 --> 00:16:17,920
okay let's profile this

00:16:14,240 --> 00:16:21,040
so this was the old new

00:16:17,920 --> 00:16:24,079
again just a euro stop profiling

00:16:21,040 --> 00:16:27,120
and ooh this looks good why

00:16:24,079 --> 00:16:31,199
because there's very few things so

00:16:27,120 --> 00:16:34,320
it updates um the exchange rates label

00:16:31,199 --> 00:16:36,160
which makes sense it updates the um

00:16:34,320 --> 00:16:38,320
the turtle component that like shows all

00:16:36,160 --> 00:16:40,800
the uh total amount

00:16:38,320 --> 00:16:42,000
and it updates only two rows the ones

00:16:40,800 --> 00:16:46,160
that use the euro

00:16:42,000 --> 00:16:46,160
and it didn't update any of the variants

00:16:47,920 --> 00:16:51,120
so effectively like with very little

00:16:50,639 --> 00:16:54,000
work

00:16:51,120 --> 00:16:54,720
this is now what our rendering graph um

00:16:54,000 --> 00:16:56,560
looks like

00:16:54,720 --> 00:16:57,839
and it's way way way better than what we

00:16:56,560 --> 00:16:59,360
achieved before

00:16:57,839 --> 00:17:05,280
even though we had to do quite

00:16:59,360 --> 00:17:07,520
complicated stuff there

00:17:05,280 --> 00:17:09,199
and that is because observable data

00:17:07,520 --> 00:17:11,520
solves this problem

00:17:09,199 --> 00:17:12,640
a we know exactly what changed because

00:17:11,520 --> 00:17:15,520
it's like detected

00:17:12,640 --> 00:17:16,160
um on a per field basis and secondly

00:17:15,520 --> 00:17:18,160
because it

00:17:16,160 --> 00:17:20,079
subscribes automatically and we know

00:17:18,160 --> 00:17:22,959
exactly where those changes are relevant

00:17:20,079 --> 00:17:22,959
to which components

00:17:24,640 --> 00:17:28,960
and so observable data is in essence

00:17:26,880 --> 00:17:32,240
pretty straightforward to write

00:17:28,960 --> 00:17:34,080
and read because we just use the same

00:17:32,240 --> 00:17:36,400
apis as we did with the mutable data

00:17:34,080 --> 00:17:36,400
before

00:17:36,559 --> 00:17:40,880
but we get very smart not more rendering

00:17:38,880 --> 00:17:43,760
out of the box

00:17:40,880 --> 00:17:45,520
and also it allows for a very easy

00:17:43,760 --> 00:17:48,160
separation of concerns but i'll discuss

00:17:45,520 --> 00:17:48,160
that later

00:17:48,480 --> 00:17:54,080
first let's take a bit closer look into

00:17:51,679 --> 00:17:56,000
mobix

00:17:54,080 --> 00:17:59,120
so i introduce observables i'm going to

00:17:56,000 --> 00:18:00,559
introduce a few more concepts

00:17:59,120 --> 00:18:02,720
and first of all i'm going to

00:18:00,559 --> 00:18:04,000
restructure what we have for our domain

00:18:02,720 --> 00:18:06,480
jig a little bit

00:18:04,000 --> 00:18:07,039
and what we did so far is um completely

00:18:06,480 --> 00:18:10,080
fine

00:18:07,039 --> 00:18:13,280
um the rest of like this restriction

00:18:10,080 --> 00:18:13,760
is just a personal approach opinion i

00:18:13,280 --> 00:18:17,039
like

00:18:13,760 --> 00:18:20,960
how i like to restructure things

00:18:17,039 --> 00:18:24,799
but mobix doesn't require you to do that

00:18:20,960 --> 00:18:24,799
i just i like it and i will explain why

00:18:26,840 --> 00:18:31,520
um so

00:18:28,880 --> 00:18:33,360
i have um all this wiring with event

00:18:31,520 --> 00:18:34,720
handlers and i have all those individual

00:18:33,360 --> 00:18:37,280
functions set to the updates

00:18:34,720 --> 00:18:38,960
um and i noticed like in big teams and

00:18:37,280 --> 00:18:40,240
these kind of utilities are like quite

00:18:38,960 --> 00:18:42,000
hard to discover

00:18:40,240 --> 00:18:44,640
um it's way easier if you have those

00:18:42,000 --> 00:18:47,840
methods available to the

00:18:44,640 --> 00:18:49,840
objects so i have this genes on my

00:18:47,840 --> 00:18:53,280
clipboard

00:18:49,840 --> 00:18:55,600
and so what i'm going to do is

00:18:53,280 --> 00:18:56,640
i'm going to create some factory

00:18:55,600 --> 00:18:58,880
functions

00:18:56,640 --> 00:19:00,480
that create observables and do that

00:18:58,880 --> 00:19:03,280
rather here in the main place

00:19:00,480 --> 00:19:05,280
than where i did it previously inside

00:19:03,280 --> 00:19:07,440
the components

00:19:05,280 --> 00:19:08,400
so i create a new observable using a new

00:19:07,440 --> 00:19:11,280
api make

00:19:08,400 --> 00:19:12,000
auto observable uh where's a few fields

00:19:11,280 --> 00:19:15,120
i have

00:19:12,000 --> 00:19:16,799
um i make the computation part of the

00:19:15,120 --> 00:19:19,600
object as well by using a

00:19:16,799 --> 00:19:25,840
getter and i expose submit it's surprise

00:19:19,600 --> 00:19:25,840
and set currency

00:19:26,000 --> 00:19:30,160
so these are fields this is together and

00:19:27,760 --> 00:19:31,760
these are the updaters

00:19:30,160 --> 00:19:34,000
right then i close over the currencies

00:19:31,760 --> 00:19:36,080
so that i can compute them

00:19:34,000 --> 00:19:38,000
and then create an order star and which

00:19:36,080 --> 00:19:41,679
has orders which such computation for

00:19:38,000 --> 00:19:44,880
the total amount and a few minutes to

00:19:41,679 --> 00:19:48,799
add some orders and for demo again

00:19:44,880 --> 00:19:52,559
i put some initial orders in there

00:19:48,799 --> 00:19:54,799
um so why did i change this um

00:19:52,559 --> 00:19:56,480
well i like it because it removes the

00:19:54,799 --> 00:19:57,440
responsibility of creating observables

00:19:56,480 --> 00:20:00,400
from the component

00:19:57,440 --> 00:20:01,520
so i'm going to go back to using good

00:20:00,400 --> 00:20:03,120
old use date

00:20:01,520 --> 00:20:05,440
and but now that i don't use the updated

00:20:03,120 --> 00:20:06,799
function i just

00:20:05,440 --> 00:20:08,400
create the state once and then the

00:20:06,799 --> 00:20:09,600
reference is stable because this is

00:20:08,400 --> 00:20:13,200
observable data

00:20:09,600 --> 00:20:15,600
so i never have to replace them

00:20:13,200 --> 00:20:18,799
and so now i throw away all the event

00:20:15,600 --> 00:20:20,960
handlers that's what i like about it

00:20:18,799 --> 00:20:22,000
so rather than passing all those event

00:20:20,960 --> 00:20:26,559
handlers uh

00:20:22,000 --> 00:20:28,640
down what i'm going to do instead

00:20:26,559 --> 00:20:30,480
is i make the api a little bit simpler

00:20:28,640 --> 00:20:33,120
and and

00:20:30,480 --> 00:20:34,000
i'm going to hook up the event handlers

00:20:33,120 --> 00:20:38,799
directly

00:20:34,000 --> 00:20:40,960
um to the methods exposed on the order

00:20:38,799 --> 00:20:43,760
so i can call surprise instead currency

00:20:40,960 --> 00:20:45,440
and i can directly grab the pricing path

00:20:43,760 --> 00:20:47,360
from the order

00:20:45,440 --> 00:20:48,480
and so and if i were using typescript

00:20:47,360 --> 00:20:52,640
here which i normally do

00:20:48,480 --> 00:20:52,640
and this would autocomplete very nicely

00:20:56,080 --> 00:20:59,679
and here for the coins currencies i'm

00:20:58,080 --> 00:21:00,799
even going to directly update them in

00:20:59,679 --> 00:21:02,559
the event handler

00:21:00,799 --> 00:21:05,200
this is really an anti-pattern i just

00:21:02,559 --> 00:21:08,320
show you that it works

00:21:05,200 --> 00:21:12,400
um so yeah um this still works

00:21:08,320 --> 00:21:15,760
it's basically the same um

00:21:12,400 --> 00:21:18,480
so why did i do it um one is um

00:21:15,760 --> 00:21:19,440
to pay attention to a few interesting

00:21:18,480 --> 00:21:22,159
details

00:21:19,440 --> 00:21:22,559
so one is that like um if you think

00:21:22,159 --> 00:21:24,480
about

00:21:22,559 --> 00:21:25,760
state and computations that like

00:21:24,480 --> 00:21:27,360
mutations are like

00:21:25,760 --> 00:21:29,840
kind of a render tree where you like

00:21:27,360 --> 00:21:33,120
render values rather than components

00:21:29,840 --> 00:21:34,080
but it's also a tree that sounds a bit

00:21:33,120 --> 00:21:37,679
fake

00:21:34,080 --> 00:21:42,640
let me draw a picture so

00:21:37,679 --> 00:21:45,679
if you think about the order price

00:21:42,640 --> 00:21:47,280
that um computation depends on three

00:21:45,679 --> 00:21:48,000
values the price of the order the

00:21:47,280 --> 00:21:51,919
currency of

00:21:48,000 --> 00:21:54,320
the uh order and um the exchange rate

00:21:51,919 --> 00:21:56,080
in the currencies table based on that

00:21:54,320 --> 00:21:57,760
currency

00:21:56,080 --> 00:21:59,360
so three observable values that

00:21:57,760 --> 00:22:02,080
influence

00:21:59,360 --> 00:22:03,200
the outputs of price and bounds now

00:22:02,080 --> 00:22:06,240
those computations

00:22:03,200 --> 00:22:07,280
um basically you can see them uh you can

00:22:06,240 --> 00:22:10,720
see this

00:22:07,280 --> 00:22:13,280
diagram as a tree and so what happens

00:22:10,720 --> 00:22:14,240
if one of those chains the computation

00:22:13,280 --> 00:22:16,799
will be run

00:22:14,240 --> 00:22:17,919
a new price and bounce will be computed

00:22:16,799 --> 00:22:21,039
and if that

00:22:17,919 --> 00:22:24,320
changes that will in turn notify the

00:22:21,039 --> 00:22:26,240
component that is rendering the data

00:22:24,320 --> 00:22:28,159
so actively those those intermediate

00:22:26,240 --> 00:22:30,320
computations they become caching points

00:22:28,159 --> 00:22:31,840
for mobix

00:22:30,320 --> 00:22:33,679
and so you can imagine that like for the

00:22:31,840 --> 00:22:35,679
second order and you can draw a

00:22:33,679 --> 00:22:37,039
similar diagram but then there's

00:22:35,679 --> 00:22:39,440
something interesting um

00:22:37,039 --> 00:22:41,280
if we render the total amount of the

00:22:39,440 --> 00:22:43,919
entire order

00:22:41,280 --> 00:22:44,720
that depends on the store that order

00:22:43,919 --> 00:22:48,080
total

00:22:44,720 --> 00:22:51,280
computation and

00:22:48,080 --> 00:22:52,799
so um if those price and pounds

00:22:51,280 --> 00:22:54,880
change but the order tile in the end

00:22:52,799 --> 00:22:56,320
doesn't change it will notify it

00:22:54,880 --> 00:22:58,480
and if you look at this diagram

00:22:56,320 --> 00:22:59,840
backwards so you you start from here

00:22:58,480 --> 00:23:01,760
you see that there's basically a

00:22:59,840 --> 00:23:03,679
dependency tree being built up

00:23:01,760 --> 00:23:05,440
so total rendering depends on the order

00:23:03,679 --> 00:23:07,679
total and

00:23:05,440 --> 00:23:08,559
its output is cached and that in turn

00:23:07,679 --> 00:23:09,919
depends on

00:23:08,559 --> 00:23:12,320
the price and pounds of individual

00:23:09,919 --> 00:23:15,520
orders and those in turn depends on

00:23:12,320 --> 00:23:17,600
the state of the orders so this has a

00:23:15,520 --> 00:23:20,640
few really cool properties

00:23:17,600 --> 00:23:25,600
as i will show you in a few

00:23:20,640 --> 00:23:25,600
more demos so

00:23:26,640 --> 00:23:32,400
imagine and so

00:23:30,960 --> 00:23:34,240
here you can see that like the observer

00:23:32,400 --> 00:23:36,000
is tracking the order

00:23:34,240 --> 00:23:38,000
and that is checking what's happening in

00:23:36,000 --> 00:23:41,520
the order price and the order price

00:23:38,000 --> 00:23:43,520
depends on the currency stable

00:23:41,520 --> 00:23:46,320
enterprise of the order so that's what i

00:23:43,520 --> 00:23:48,480
just showed you in the graph

00:23:46,320 --> 00:23:49,440
so if we profile this and we're going to

00:23:48,480 --> 00:23:52,559
change the

00:23:49,440 --> 00:23:54,159
exchange rate of rupees something

00:23:52,559 --> 00:23:56,640
interesting happens

00:23:54,159 --> 00:23:58,880
because like the rupees is not relevant

00:23:56,640 --> 00:23:58,880
for

00:23:59,039 --> 00:24:05,840
any of those

00:24:02,080 --> 00:24:09,200
order lines no other lines are

00:24:05,840 --> 00:24:12,480
rendering so you see none of them

00:24:09,200 --> 00:24:14,080
are getting re-rendered however after

00:24:12,480 --> 00:24:14,799
that we change in the second click we

00:24:14,080 --> 00:24:16,480
change the

00:24:14,799 --> 00:24:18,720
euro change rate and then we see some

00:24:16,480 --> 00:24:19,360
items rendering so you see really that

00:24:18,720 --> 00:24:21,440
this

00:24:19,360 --> 00:24:24,080
dependency graph is being built up

00:24:21,440 --> 00:24:24,080
dynamically

00:24:26,799 --> 00:24:31,200
and i can give you another example to

00:24:28,799 --> 00:24:33,600
demonstrate that so imagine that we

00:24:31,200 --> 00:24:34,400
don't want to show the exchange rate for

00:24:33,600 --> 00:24:37,520
large orders

00:24:34,400 --> 00:24:38,400
because we rather have our customer

00:24:37,520 --> 00:24:40,720
callers for

00:24:38,400 --> 00:24:42,880
a like a custom quality of a better

00:24:40,720 --> 00:24:45,600
exchange rate

00:24:42,880 --> 00:24:46,400
so that's what we changed now so we made

00:24:45,600 --> 00:24:48,640
this conditional

00:24:46,400 --> 00:24:51,679
so now it will show for the large orders

00:24:48,640 --> 00:24:55,760
um please call us

00:24:51,679 --> 00:24:55,760
so for any order larger than 500.

00:24:56,559 --> 00:25:00,080
so that's what you see um so the

00:24:59,039 --> 00:25:01,919
interesting things now

00:25:00,080 --> 00:25:04,240
if we profile this and we change the

00:25:01,919 --> 00:25:06,080
change rate of the australian dollar

00:25:04,240 --> 00:25:07,919
and you see that like the order line

00:25:06,080 --> 00:25:10,720
even though it's using

00:25:07,919 --> 00:25:11,760
australian dollars it still isn't

00:25:10,720 --> 00:25:13,440
re-rendering

00:25:11,760 --> 00:25:15,200
because like at this point the exchange

00:25:13,440 --> 00:25:16,559
rate doesn't matter it's using as a

00:25:15,200 --> 00:25:18,000
change here right yes

00:25:16,559 --> 00:25:20,480
but like it's not interesting the

00:25:18,000 --> 00:25:20,480
rendering

00:25:20,799 --> 00:25:26,480
and so let's profile this again but

00:25:23,600 --> 00:25:26,480
first lower the price

00:25:26,880 --> 00:25:31,679
and now it changes exchange rate and now

00:25:29,919 --> 00:25:34,720
it is re-rendering automatically

00:25:31,679 --> 00:25:36,400
um so you see this like thanks to doing

00:25:34,720 --> 00:25:38,640
this runtime uh

00:25:36,400 --> 00:25:39,440
this dependency analysis at the runtime

00:25:38,640 --> 00:25:41,279
it's like

00:25:39,440 --> 00:25:42,480
even following any conditional logic you

00:25:41,279 --> 00:25:46,000
might have

00:25:42,480 --> 00:25:47,360
any looping you do and so if we would

00:25:46,000 --> 00:25:49,200
have

00:25:47,360 --> 00:25:50,960
if we would want to express this in like

00:25:49,200 --> 00:25:52,640
that custom comparison function we had

00:25:50,960 --> 00:25:54,640
earlier with immutable data

00:25:52,640 --> 00:25:56,400
that would be pretty challenging like it

00:25:54,640 --> 00:25:58,720
would maybe a lot of work

00:25:56,400 --> 00:26:00,400
and b it's pretty likely that we break

00:25:58,720 --> 00:26:02,960
it in the future

00:26:00,400 --> 00:26:04,480
so i think that's nicely demonstrates um

00:26:02,960 --> 00:26:08,000
why the model is

00:26:04,480 --> 00:26:08,320
superior now if you paid attention to

00:26:08,000 --> 00:26:10,640
them

00:26:08,320 --> 00:26:11,919
so far to the bottom part you might have

00:26:10,640 --> 00:26:13,840
noticed that like if i change the

00:26:11,919 --> 00:26:16,720
exchange rate of one

00:26:13,840 --> 00:26:18,640
currency all of them the entire table

00:26:16,720 --> 00:26:20,480
re-renders

00:26:18,640 --> 00:26:22,000
um now that's a bit stupid but there's a

00:26:20,480 --> 00:26:24,159
clear reason for that

00:26:22,000 --> 00:26:27,520
and that is basically because i'm

00:26:24,159 --> 00:26:29,679
rendering um the entire currencies

00:26:27,520 --> 00:26:30,720
up here so i'm writing the entire

00:26:29,679 --> 00:26:33,919
currencies in one

00:26:30,720 --> 00:26:36,159
uh table so it's

00:26:33,919 --> 00:26:37,679
all rendered by one component and so the

00:26:36,159 --> 00:26:41,120
smallest thing you can re-render then

00:26:37,679 --> 00:26:41,760
is one component so a super simple way

00:26:41,120 --> 00:26:43,840
to make this

00:26:41,760 --> 00:26:46,080
uh more efficient is by simply breaking

00:26:43,840 --> 00:26:48,000
it up in smaller components

00:26:46,080 --> 00:26:50,720
so let's introduce a currency line

00:26:48,000 --> 00:26:52,400
component the text currency table

00:26:50,720 --> 00:26:53,840
remember that it's a stable constant

00:26:52,400 --> 00:26:56,240
reference and

00:26:53,840 --> 00:26:57,600
currently the currency we're interested

00:26:56,240 --> 00:26:59,360
in

00:26:57,600 --> 00:27:00,880
so we map over all the keys in the

00:26:59,360 --> 00:27:02,159
currencies table and we call the

00:27:00,880 --> 00:27:04,320
currency line

00:27:02,159 --> 00:27:06,400
so the only thing we did is now we split

00:27:04,320 --> 00:27:09,600
this into two components

00:27:06,400 --> 00:27:11,679
and now you can try the same thing

00:27:09,600 --> 00:27:12,640
we update one currency and what you see

00:27:11,679 --> 00:27:14,400
immediately is like

00:27:12,640 --> 00:27:16,799
the table doesn't really render anymore

00:27:14,400 --> 00:27:19,120
only at a specific currency

00:27:16,799 --> 00:27:20,799
so if things are not fast enough you can

00:27:19,120 --> 00:27:21,520
always like break them down into smaller

00:27:20,799 --> 00:27:23,440
components

00:27:21,520 --> 00:27:24,880
that makes it that means that like

00:27:23,440 --> 00:27:27,919
smaller parts of the

00:27:24,880 --> 00:27:31,360
ui are individually updatable and

00:27:27,919 --> 00:27:35,039
things will get faster um

00:27:31,360 --> 00:27:36,640
it's that simple and finally um

00:27:35,039 --> 00:27:38,559
and i'm going to talk about this only

00:27:36,640 --> 00:27:41,520
really briefly

00:27:38,559 --> 00:27:42,720
what i like about the separation i just

00:27:41,520 --> 00:27:44,080
made earlier where i

00:27:42,720 --> 00:27:46,080
create those factory functions that

00:27:44,080 --> 00:27:48,240
create observables

00:27:46,080 --> 00:27:50,240
is that it nicely decouples on my domain

00:27:48,240 --> 00:27:53,520
logic and stayed

00:27:50,240 --> 00:27:56,240
for my ui um

00:27:53,520 --> 00:27:58,399
so i don't like having too much logic in

00:27:56,240 --> 00:28:01,279
my ui for a few reasons um

00:27:58,399 --> 00:28:03,919
one is like if you have as much logic as

00:28:01,279 --> 00:28:06,960
possible in life in your domain card

00:28:03,919 --> 00:28:07,760
it's easier to swap frameworks like you

00:28:06,960 --> 00:28:10,320
could

00:28:07,760 --> 00:28:12,159
use this more big stuff if you are with

00:28:10,320 --> 00:28:16,159
lit element or project

00:28:12,159 --> 00:28:17,600
just fine but that's not

00:28:16,159 --> 00:28:19,679
the interesting thing because that's not

00:28:17,600 --> 00:28:21,200
the most likely to happen and it also

00:28:19,679 --> 00:28:22,720
means that you can use this logic if you

00:28:21,200 --> 00:28:24,399
want to expose an api from the backend

00:28:22,720 --> 00:28:26,640
for example like you can literally

00:28:24,399 --> 00:28:28,880
reuse the same code because the state is

00:28:26,640 --> 00:28:31,919
not no longer out by

00:28:28,880 --> 00:28:35,200
organized by components um

00:28:31,919 --> 00:28:38,640
but what i like about this the best

00:28:35,200 --> 00:28:40,399
is testing so the less wiring less

00:28:38,640 --> 00:28:44,880
plumbing you do

00:28:40,399 --> 00:28:49,039
in your ui the easier it is to test

00:28:44,880 --> 00:28:51,279
so i see um your api

00:28:49,039 --> 00:28:52,640
you have on your objects basically as

00:28:51,279 --> 00:28:54,399
another user interface

00:28:52,640 --> 00:28:57,760
a programmable user interface you can

00:28:54,399 --> 00:29:00,559
use from your unit test

00:28:57,760 --> 00:29:02,880
so i talked about this um quite

00:29:00,559 --> 00:29:06,399
extensively in earlier talks um but

00:29:02,880 --> 00:29:07,279
just to give a very brief idea um about

00:29:06,399 --> 00:29:10,880
that

00:29:07,279 --> 00:29:13,840
um is that we can now in a unit test

00:29:10,880 --> 00:29:14,420
and basically do the same thing as we

00:29:13,840 --> 00:29:15,679
did in our

00:29:14,420 --> 00:29:18,080
[Music]

00:29:15,679 --> 00:29:19,840
react components and we create an order

00:29:18,080 --> 00:29:21,279
store and we can do that

00:29:19,840 --> 00:29:23,120
per unit test because it's like super

00:29:21,279 --> 00:29:26,159
cheap

00:29:23,120 --> 00:29:27,679
and we can create some initial data

00:29:26,159 --> 00:29:29,679
and we can immediately make assertions

00:29:27,679 --> 00:29:31,919
on it

00:29:29,679 --> 00:29:33,919
and what i like about this is that like

00:29:31,919 --> 00:29:34,640
i express what user is doing like adding

00:29:33,919 --> 00:29:37,760
an order

00:29:34,640 --> 00:29:38,159
um and i can make insertions on it but i

00:29:37,760 --> 00:29:40,640
can

00:29:38,159 --> 00:29:41,279
search directly on data and i can invoke

00:29:40,640 --> 00:29:44,320
the methods

00:29:41,279 --> 00:29:46,480
um directly on the elements and

00:29:44,320 --> 00:29:47,360
i don't have to assert it in the dom

00:29:46,480 --> 00:29:48,960
tree

00:29:47,360 --> 00:29:50,720
and i don't have to find the right

00:29:48,960 --> 00:29:54,000
button and then trigger an event on it

00:29:50,720 --> 00:29:55,600
to test this stuff um

00:29:54,000 --> 00:29:56,960
and that's nice and the reason i can

00:29:55,600 --> 00:29:58,480
safely do that is because there's a

00:29:56,960 --> 00:30:00,880
little plumbing so if you like

00:29:58,480 --> 00:30:01,600
one unit tested like just make sure that

00:30:00,880 --> 00:30:02,960
like

00:30:01,600 --> 00:30:05,200
different handler squat connects to the

00:30:02,960 --> 00:30:07,600
right methods and so you don't break

00:30:05,200 --> 00:30:08,240
it and then you can test all your logic

00:30:07,600 --> 00:30:11,200
um

00:30:08,240 --> 00:30:12,960
directly against your api as you expose

00:30:11,200 --> 00:30:14,640
for your objects so that's why i like

00:30:12,960 --> 00:30:16,640
using those um

00:30:14,640 --> 00:30:18,080
factory methods and extracting all that

00:30:16,640 --> 00:30:20,080
logic

00:30:18,080 --> 00:30:22,720
and so you can really take it very far

00:30:20,080 --> 00:30:25,440
and build few models and

00:30:22,720 --> 00:30:29,039
even model routing like this and but i

00:30:25,440 --> 00:30:29,039
said and there's other talks about it

00:30:30,159 --> 00:30:33,760
so to conclude

00:30:34,480 --> 00:30:38,960
with observable data we know what change

00:30:37,440 --> 00:30:40,480
and why that's relevant and that's a big

00:30:38,960 --> 00:30:42,240
benefit

00:30:40,480 --> 00:30:43,919
and that means that in the end result is

00:30:42,240 --> 00:30:45,200
that you have like quite straightforward

00:30:43,919 --> 00:30:47,760
go to read and write

00:30:45,200 --> 00:30:49,279
um and you get really smart mind

00:30:47,760 --> 00:30:51,919
stringering um

00:30:49,279 --> 00:30:53,600
which is a lot smarter a lot better

00:30:51,919 --> 00:30:55,039
optimized and probably what you do by

00:30:53,600 --> 00:30:56,559
hand

00:30:55,039 --> 00:30:59,440
and it allows for each separation of

00:30:56,559 --> 00:30:59,440
concerns as well

00:30:59,679 --> 00:31:03,679
and so that's not just a bins of

00:31:02,240 --> 00:31:07,440
individuals

00:31:03,679 --> 00:31:08,960
they believed in this model um because

00:31:07,440 --> 00:31:11,039
i think these are really cool examples

00:31:08,960 --> 00:31:13,679
of applications using mobix

00:31:11,039 --> 00:31:16,559
so battlefield it uses mobix for state

00:31:13,679 --> 00:31:19,519
management and ui

00:31:16,559 --> 00:31:21,440
and so does outlook web access um it's

00:31:19,519 --> 00:31:22,880
heavily running on observables

00:31:21,440 --> 00:31:24,480
and make sure that like if you update

00:31:22,880 --> 00:31:25,919
the title of an email in one place then

00:31:24,480 --> 00:31:26,880
the preview pane gets updated that

00:31:25,919 --> 00:31:29,360
monkey as well

00:31:26,880 --> 00:31:31,360
and that's super neat and there's many

00:31:29,360 --> 00:31:33,360
many more products where you

00:31:31,360 --> 00:31:35,919
can find mobix if you enable the

00:31:33,360 --> 00:31:35,919
devtools

00:31:36,240 --> 00:31:40,559
so i think the cases where observable

00:31:38,080 --> 00:31:42,960
data really shines is when you have like

00:31:40,559 --> 00:31:45,360
very frequently updating data or very

00:31:42,960 --> 00:31:46,799
interactive data

00:31:45,360 --> 00:31:48,799
or where you have like a lot of

00:31:46,799 --> 00:31:50,399
cross-cutting dependencies so where

00:31:48,799 --> 00:31:52,480
one piece of data can be rendered in

00:31:50,399 --> 00:31:53,279
many places and you don't want to mainly

00:31:52,480 --> 00:31:56,399
keep track of

00:31:53,279 --> 00:31:57,760
where it is exactly used and it allows

00:31:56,399 --> 00:32:00,480
some architectural freedom

00:31:57,760 --> 00:32:01,840
um i showed you two quite different ways

00:32:00,480 --> 00:32:04,960
to organize

00:32:01,840 --> 00:32:07,840
a mobix code base um and so that's the

00:32:04,960 --> 00:32:10,080
flexibility it offers as well

00:32:07,840 --> 00:32:11,279
and so with that i want to leave you and

00:32:10,080 --> 00:32:13,679
feel free to

00:32:11,279 --> 00:32:14,720
ask questions later thanks for your

00:32:13,679 --> 00:32:28,980
attention

00:32:14,720 --> 00:32:33,679
see you later

00:32:28,980 --> 00:32:35,840
[Music]

00:32:33,679 --> 00:32:37,360
and so while people are getting their

00:32:35,840 --> 00:32:39,279
questions into the q a

00:32:37,360 --> 00:32:41,120
area and please do everybody watching

00:32:39,279 --> 00:32:42,080
along please pop your questions into q a

00:32:41,120 --> 00:32:44,080
for mikael

00:32:42,080 --> 00:32:45,279
um i'm going to ask you a little bit

00:32:44,080 --> 00:32:47,440
about the workshop

00:32:45,279 --> 00:32:48,720
that you're hosting on wednesday with

00:32:47,440 --> 00:32:50,159
this conference would you like to tell

00:32:48,720 --> 00:32:51,679
us a little bit more about it and what

00:32:50,159 --> 00:32:54,799
people will learn if they

00:32:51,679 --> 00:32:57,760
take part sure

00:32:54,799 --> 00:32:59,360
it's going to be about styleshift uh and

00:32:57,760 --> 00:33:00,159
i think basket does not become like the

00:32:59,360 --> 00:33:04,399
defecto

00:33:00,159 --> 00:33:06,880
tap system in javascript um but what's

00:33:04,399 --> 00:33:07,840
usually hard to grasp uh when learning

00:33:06,880 --> 00:33:11,840
javascript

00:33:07,840 --> 00:33:13,919
is what is the bigger picture how do

00:33:11,840 --> 00:33:15,360
like it's language with many many

00:33:13,919 --> 00:33:17,760
different aspects and like how do

00:33:15,360 --> 00:33:18,720
they relate together um how do you go

00:33:17,760 --> 00:33:22,880
from automatic

00:33:18,720 --> 00:33:26,640
javascript to automatic typescript

00:33:22,880 --> 00:33:28,080
when do you when do you keep your dive

00:33:26,640 --> 00:33:29,760
straight straight and why

00:33:28,080 --> 00:33:31,360
when do you bend the rules a little bit

00:33:29,760 --> 00:33:33,840
like making it

00:33:31,360 --> 00:33:35,600
um practical like how you turn it in a

00:33:33,840 --> 00:33:37,600
big project that's basically

00:33:35,600 --> 00:33:39,440
uh the question i want to answer and

00:33:37,600 --> 00:33:40,320
like getting that mental picture of

00:33:39,440 --> 00:33:43,279
touchscript

00:33:40,320 --> 00:33:45,120
uh basically complete okay so it sounds

00:33:43,279 --> 00:33:47,039
like it's not necessarily for typescript

00:33:45,120 --> 00:33:48,480
beginners but people already using it is

00:33:47,039 --> 00:33:51,919
that right

00:33:48,480 --> 00:33:54,159
um well i do um go through the basics

00:33:51,919 --> 00:33:57,519
first but i did this quite quickly um

00:33:54,159 --> 00:34:00,080
so uh if you did any static language

00:33:57,519 --> 00:34:01,679
uh you can definitely join in um if you

00:34:00,080 --> 00:34:02,399
didn't then doing the touchscreen before

00:34:01,679 --> 00:34:04,000
like

00:34:02,399 --> 00:34:05,679
the first one drives will be a little

00:34:04,000 --> 00:34:07,760
bit trickier

00:34:05,679 --> 00:34:09,839
but you should be able to follow along

00:34:07,760 --> 00:34:11,280
okay well to anybody who wants to join

00:34:09,839 --> 00:34:12,159
in that i believe there are just three

00:34:11,280 --> 00:34:14,079
tickets left

00:34:12,159 --> 00:34:15,679
so go and snap them up quite quickly it

00:34:14,079 --> 00:34:16,320
sounds like it's going to be an amazing

00:34:15,679 --> 00:34:17,919
session

00:34:16,320 --> 00:34:20,399
so we've had a couple of questions come

00:34:17,919 --> 00:34:23,440
in and the first one is

00:34:20,399 --> 00:34:25,280
should i use mob x with or without

00:34:23,440 --> 00:34:28,320
decorators

00:34:25,280 --> 00:34:28,960
good question um so when i originally

00:34:28,320 --> 00:34:31,520
developed

00:34:28,960 --> 00:34:32,960
uh mobx it was like for type 2 only and

00:34:31,520 --> 00:34:34,720
i should have decorated this like five

00:34:32,960 --> 00:34:36,079
years ago already um

00:34:34,720 --> 00:34:38,159
i mean the assumption that they like

00:34:36,079 --> 00:34:39,839
would soon be standardized um

00:34:38,159 --> 00:34:42,159
that didn't happen for the last five

00:34:39,839 --> 00:34:45,200
years so at this point

00:34:42,159 --> 00:34:46,879
um i wouldn't recommend uh using

00:34:45,200 --> 00:34:48,879
decorators especially if you get started

00:34:46,879 --> 00:34:49,919
like they do make the experience uh

00:34:48,879 --> 00:34:52,000
better

00:34:49,919 --> 00:34:54,480
but like you need more a more exotic

00:34:52,000 --> 00:34:58,240
build for them

00:34:54,480 --> 00:34:59,920
so currently in the new official mobix

00:34:58,240 --> 00:35:01,839
we're moving away from recommending

00:34:59,920 --> 00:35:03,680
decorators as doing as a standard way of

00:35:01,839 --> 00:35:05,440
doing things they're still supported but

00:35:03,680 --> 00:35:08,800
we don't promote them anymore in our

00:35:05,440 --> 00:35:10,800
documentation for that reason

00:35:08,800 --> 00:35:12,400
and also a nice benefit from that is

00:35:10,800 --> 00:35:15,680
that it gives us a

00:35:12,400 --> 00:35:16,400
clean cheat in the long term why because

00:35:15,680 --> 00:35:19,520
like the

00:35:16,400 --> 00:35:22,000
standardization process is uh

00:35:19,520 --> 00:35:24,079
still ongoing and like last week

00:35:22,000 --> 00:35:27,040
basically a few days ago a new proposal

00:35:24,079 --> 00:35:27,760
landed for uh tc39 uh two movement

00:35:27,040 --> 00:35:31,040
decorators

00:35:27,760 --> 00:35:34,079
um and so that means like

00:35:31,040 --> 00:35:35,680
but that we don't have any tangled depth

00:35:34,079 --> 00:35:37,599
before we can start adjusting it so at

00:35:35,680 --> 00:35:39,359
this moment i would recommend to not use

00:35:37,599 --> 00:35:41,280
decorators

00:35:39,359 --> 00:35:42,720
okay so no don't use decorators leave

00:35:41,280 --> 00:35:43,520
them alone you have got to paint your

00:35:42,720 --> 00:35:44,880
own house

00:35:43,520 --> 00:35:47,520
i'm sorry we're talking about products

00:35:44,880 --> 00:35:48,000
can't we so we've had another question

00:35:47,520 --> 00:35:50,160
coming

00:35:48,000 --> 00:35:51,760
um this one is about using mobx with

00:35:50,160 --> 00:35:54,560
something other than react

00:35:51,760 --> 00:35:55,839
are there tools available to use mobx on

00:35:54,560 --> 00:35:58,880
the front end together

00:35:55,839 --> 00:36:00,320
with something like vue or smelt oh

00:35:58,880 --> 00:36:03,280
there's some question because like i was

00:36:00,320 --> 00:36:05,280
exactly googling for that question today

00:36:03,280 --> 00:36:07,760
perfect

00:36:05,280 --> 00:36:08,480
so it turns out that there's a lack of

00:36:07,760 --> 00:36:11,520
uh

00:36:08,480 --> 00:36:13,040
community methane typing for both a view

00:36:11,520 --> 00:36:16,720
as well

00:36:13,040 --> 00:36:19,920
so yes you can use modex if you uh or

00:36:16,720 --> 00:36:22,000
sheldon um that being said i don't think

00:36:19,920 --> 00:36:25,280
it offers a lot of failure because like

00:36:22,000 --> 00:36:27,359
both few and swelt offer a

00:36:25,280 --> 00:36:28,640
reactive tracking system which is very

00:36:27,359 --> 00:36:32,480
similar to uh

00:36:28,640 --> 00:36:35,760
opex um so the main benefit of

00:36:32,480 --> 00:36:38,240
mobix is that like it allows you to

00:36:35,760 --> 00:36:39,280
um keep your efficiency system entirely

00:36:38,240 --> 00:36:42,880
decoupled from your

00:36:39,280 --> 00:36:44,320
ui framework um but beyond that

00:36:42,880 --> 00:36:46,400
they basically offer a very similar

00:36:44,320 --> 00:36:49,680
model okay

00:36:46,400 --> 00:36:51,599
so yes there are tools out there but

00:36:49,680 --> 00:36:53,440
you have to figure them out yeah i think

00:36:51,599 --> 00:36:56,480
it's ourselves

00:36:53,440 --> 00:36:59,440
awesome so are there any cons

00:36:56,480 --> 00:37:01,440
of using mobx or reactive architectures

00:36:59,440 --> 00:37:01,920
in general that's been another question

00:37:01,440 --> 00:37:05,839
from

00:37:01,920 --> 00:37:09,440
from eagle um

00:37:05,839 --> 00:37:11,280
i would say not so much but yes there

00:37:09,440 --> 00:37:14,800
are a few

00:37:11,280 --> 00:37:15,520
um so one matches like not every

00:37:14,800 --> 00:37:18,640
application

00:37:15,520 --> 00:37:20,160
is like super suitable for it um so if

00:37:18,640 --> 00:37:22,880
your applications like

00:37:20,160 --> 00:37:24,079
super transactional uh and kind of has

00:37:22,880 --> 00:37:25,760
like a conceptual

00:37:24,079 --> 00:37:27,119
append only system like if you're

00:37:25,760 --> 00:37:29,599
building like a

00:37:27,119 --> 00:37:30,320
uh organizing application or something

00:37:29,599 --> 00:37:32,880
um

00:37:30,320 --> 00:37:33,920
then it doesn't add the value uh it's

00:37:32,880 --> 00:37:36,560
it's basic most

00:37:33,920 --> 00:37:37,359
mostly interesting for applications that

00:37:36,560 --> 00:37:40,000
are very

00:37:37,359 --> 00:37:43,280
current intensive so like you go

00:37:40,000 --> 00:37:46,960
changing records like we did in demo

00:37:43,280 --> 00:37:49,599
or which are very um

00:37:46,960 --> 00:37:51,440
visualized so if you are doing a bridge

00:37:49,599 --> 00:37:52,240
like that has like drag and drop and

00:37:51,440 --> 00:37:54,880
that kind of stuff

00:37:52,240 --> 00:37:57,200
um that typically is hard to do without

00:37:54,880 --> 00:37:59,760
technologies uh like objects

00:37:57,200 --> 00:38:01,440
okay so again it's like we've said in

00:37:59,760 --> 00:38:03,040
other conversations that these things

00:38:01,440 --> 00:38:05,040
are all tools and it's about choosing

00:38:03,040 --> 00:38:08,400
the right tool for the right job

00:38:05,040 --> 00:38:10,079
yeah exactly okay so this one sounds

00:38:08,400 --> 00:38:12,079
like somebody wants to give you a hand

00:38:10,079 --> 00:38:13,200
um what is the best way to start

00:38:12,079 --> 00:38:16,720
contributing to

00:38:13,200 --> 00:38:18,720
mob x just uh channeling on the uh on

00:38:16,720 --> 00:38:20,800
the issue tracker um

00:38:18,720 --> 00:38:24,000
there's always new issues being opened

00:38:20,800 --> 00:38:27,040
uh for new decisions um

00:38:24,000 --> 00:38:28,880
so i i think um

00:38:27,040 --> 00:38:32,079
there's a lot of ps getting words which

00:38:28,880 --> 00:38:33,680
are not coming from me so

00:38:32,079 --> 00:38:36,560
just start somewhere the destructive

00:38:33,680 --> 00:38:39,280
fire and otherwise feel free to uh dm me

00:38:36,560 --> 00:38:42,000
yeah so it's a very approachable package

00:38:39,280 --> 00:38:43,839
for people to start contributing to then

00:38:42,000 --> 00:38:47,440
yeah i think so actually so that's what

00:38:43,839 --> 00:38:48,880
helps so if it isn't then let me know

00:38:47,440 --> 00:38:50,960
well hopefully nobody will get in touch

00:38:48,880 --> 00:38:52,000
about the last bit and just want to get

00:38:50,960 --> 00:38:54,560
in touch giving you a hand

00:38:52,000 --> 00:38:55,920
exactly and so we've actually we're

00:38:54,560 --> 00:38:57,520
running over now but i think we've got

00:38:55,920 --> 00:38:59,839
time just for one more question

00:38:57,520 --> 00:39:01,520
and because there is one here from james

00:38:59,839 --> 00:39:04,960
and how to decide

00:39:01,520 --> 00:39:07,359
mobex state tree or just mob x

00:39:04,960 --> 00:39:08,880
yeah that's a tough question um so

00:39:07,359 --> 00:39:12,240
honestly personally

00:39:08,880 --> 00:39:13,440
uh i prefer more bits uh of my big

00:39:12,240 --> 00:39:15,359
surgery

00:39:13,440 --> 00:39:18,079
so mother extra three is basically a

00:39:15,359 --> 00:39:19,920
very opinionated implementation

00:39:18,079 --> 00:39:21,839
of doing state management on top of mix

00:39:19,920 --> 00:39:24,000
so my general i had like

00:39:21,839 --> 00:39:25,280
two different ways of using mobix uh

00:39:24,000 --> 00:39:28,880
which both work

00:39:25,280 --> 00:39:30,480
unlike if you um don't want to have like

00:39:28,880 --> 00:39:32,320
too much suggestions about like how you

00:39:30,480 --> 00:39:33,920
organize things and you want like a lot

00:39:32,320 --> 00:39:36,079
of features out of the box like

00:39:33,920 --> 00:39:37,040
time traveling and civilization and that

00:39:36,079 --> 00:39:40,160
kind of stuff

00:39:37,040 --> 00:39:44,560
uh validation um demo big stage

00:39:40,160 --> 00:39:46,400
is really great um but personally uh

00:39:44,560 --> 00:39:48,000
does patterns are on my head as well for

00:39:46,400 --> 00:39:49,520
doing those things by hand

00:39:48,000 --> 00:39:51,760
i have a problem with it so i usually

00:39:49,520 --> 00:39:54,400
stick to just one deck

00:39:51,760 --> 00:39:55,119
okay again tool for the right job and

00:39:54,400 --> 00:39:57,359
we've got another

00:39:55,119 --> 00:39:58,400
another late one coming what is your

00:39:57,359 --> 00:40:02,480
opinion for

00:39:58,400 --> 00:40:05,839
hooks um

00:40:02,480 --> 00:40:07,520
that's uh how that sure is in relation

00:40:05,839 --> 00:40:08,240
to my big star in general i think in

00:40:07,520 --> 00:40:11,760
general

00:40:08,240 --> 00:40:13,680
hooks are like really cool

00:40:11,760 --> 00:40:16,400
yeah i quite like them especially how

00:40:13,680 --> 00:40:18,160
nice they compose

00:40:16,400 --> 00:40:19,839
that being said there's a few things i

00:40:18,160 --> 00:40:23,280
don't use them too much for

00:40:19,839 --> 00:40:25,440
for example complicated use effects

00:40:23,280 --> 00:40:26,640
or complexity renderings because i think

00:40:25,440 --> 00:40:28,400
that's easier and

00:40:26,640 --> 00:40:29,760
a little bit so for example if you use

00:40:28,400 --> 00:40:31,920
use effect then you're like

00:40:29,760 --> 00:40:33,680
figure out the dependencies and make

00:40:31,920 --> 00:40:36,880
sure that you have like the uh

00:40:33,680 --> 00:40:39,440
pencils right otherwise yes and juliel

00:40:36,880 --> 00:40:40,880
a modex already can determine it out of

00:40:39,440 --> 00:40:41,920
the box for you what those dependencies

00:40:40,880 --> 00:40:43,920
are so

00:40:41,920 --> 00:40:45,760
for those kind of things i i typically

00:40:43,920 --> 00:40:48,560
still stick to muppets um

00:40:45,760 --> 00:40:49,119
but in essence i think hooks are equal

00:40:48,560 --> 00:40:51,280
uh

00:40:49,119 --> 00:40:53,359
especially composition like things like

00:40:51,280 --> 00:40:54,960
on the u3 site or something that's

00:40:53,359 --> 00:40:56,960
really awesome

00:40:54,960 --> 00:40:58,560
okay and on that note we will have to

00:40:56,960 --> 00:41:00,240
leave it there mikael i want to say

00:40:58,560 --> 00:41:02,079
thank you for your amazing talk

00:41:00,240 --> 00:41:03,040
apologies once again for getting your

00:41:02,079 --> 00:41:05,040
name wrong in

00:41:03,040 --> 00:41:06,319
every way we could have and i want to

00:41:05,040 --> 00:41:08,640
give you a thank you

00:41:06,319 --> 00:41:10,480
from everybody watching who's used mobx

00:41:08,640 --> 00:41:12,160
and has saved them time effort and

00:41:10,480 --> 00:41:13,599
energy so thank you for all the time

00:41:12,160 --> 00:41:21,839
you've put into it

00:41:13,599 --> 00:41:21,839
thanks welcome

00:41:24,800 --> 00:41:26,880

YouTube URL: https://www.youtube.com/watch?v=ZHxFrbK3VB0


