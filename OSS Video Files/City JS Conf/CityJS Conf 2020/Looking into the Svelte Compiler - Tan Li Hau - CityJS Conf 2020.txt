Title: Looking into the Svelte Compiler - Tan Li Hau - CityJS Conf 2020
Publication date: 2020-10-03
Playlist: CityJS Conf 2020
Description: 
	Have you ever wonder how does the Svelte compilation process works?
Have you ever feeling curious and want to read Svelte source code but does not know where to start?

This talk will give you an overview of the Svelte compilation process, from parsing the source code, analyse the code to generating final JavaScript code.

At the end of the talk, you will get a deeper understanding of the Svelte compilation process.

Bio:
Originally from Malaysia, Li Hau is an expert engineer at Shopee, Svelte core member and Babel contributor. He is a polyglot. He speaks English, Chinese, Malay, JavaScript, CSS, and HTML. In his free time, he writes about JavaScript frameworks and tools.

_________________________________________________________________

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_________________________________________________________________

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:18,080 --> 00:00:24,560
[Music]

00:00:22,560 --> 00:00:25,519
modern web frameworks allows us to

00:00:24,560 --> 00:00:28,560
describe our

00:00:25,519 --> 00:00:29,039
ui declaratively as a function of a

00:00:28,560 --> 00:00:31,760
state

00:00:29,039 --> 00:00:33,360
of the application the function can be

00:00:31,760 --> 00:00:35,920
written in a form of templates

00:00:33,360 --> 00:00:38,320
or template like syntax which describes

00:00:35,920 --> 00:00:41,840
exactly how the view should look like

00:00:38,320 --> 00:00:42,879
in all possible states when the state

00:00:41,840 --> 00:00:45,680
change

00:00:42,879 --> 00:00:46,559
the view should change as well we don't

00:00:45,680 --> 00:00:48,879
need to describe

00:00:46,559 --> 00:00:50,000
how the view transition from one to

00:00:48,879 --> 00:00:52,800
another

00:00:50,000 --> 00:00:53,600
we don't need to describe how elements

00:00:52,800 --> 00:00:56,960
are added

00:00:53,600 --> 00:01:00,239
removed or modified modern web

00:00:56,960 --> 00:01:01,440
frameworks do that for us the framework

00:01:00,239 --> 00:01:03,600
magic takes in

00:01:01,440 --> 00:01:04,960
two subsequent views and figure out how

00:01:03,600 --> 00:01:08,320
to transition from one

00:01:04,960 --> 00:01:08,880
to another modern web frameworks like

00:01:08,320 --> 00:01:10,799
react

00:01:08,880 --> 00:01:13,439
and view do that using a technique

00:01:10,799 --> 00:01:15,439
called virtual dom

00:01:13,439 --> 00:01:16,560
to handle all possible scenarios this

00:01:15,439 --> 00:01:19,119
framework magic

00:01:16,560 --> 00:01:21,040
could be very huge in code size and it

00:01:19,119 --> 00:01:22,320
is the independent of the application it

00:01:21,040 --> 00:01:26,000
is supporting

00:01:22,320 --> 00:01:30,320
for react it's 40 kilobyte gzipped

00:01:26,000 --> 00:01:32,640
view 2 is 23 kilobytes view 3 is 10.

00:01:30,320 --> 00:01:35,360
and if your application is simple it

00:01:32,640 --> 00:01:37,439
could disproportionately small

00:01:35,360 --> 00:01:38,799
in terms of code size relative to the

00:01:37,439 --> 00:01:40,960
framework library

00:01:38,799 --> 00:01:42,159
which is shown in a gray portion of the

00:01:40,960 --> 00:01:45,439
chart

00:01:42,159 --> 00:01:47,520
however this doesn't have to be the only

00:01:45,439 --> 00:01:50,240
way of doing things

00:01:47,520 --> 00:01:51,600
what if we could shift all the work done

00:01:50,240 --> 00:01:54,399
in the framework magic

00:01:51,600 --> 00:01:56,320
from runtime to build time we can

00:01:54,399 --> 00:01:57,360
analyze the code and figure out all the

00:01:56,320 --> 00:01:59,759
possible states

00:01:57,360 --> 00:02:00,799
and views and the possible transitions

00:01:59,759 --> 00:02:02,880
between them

00:02:00,799 --> 00:02:04,560
and generates just enough code to do

00:02:02,880 --> 00:02:06,880
just that

00:02:04,560 --> 00:02:07,680
and that's the core idea of svelt the

00:02:06,880 --> 00:02:10,479
svelt

00:02:07,680 --> 00:02:11,200
compilers compiles the swell code into

00:02:10,479 --> 00:02:14,080
optimized

00:02:11,200 --> 00:02:16,319
javascript code that grows linearly

00:02:14,080 --> 00:02:19,120
along with your application

00:02:16,319 --> 00:02:21,360
and today we are going to look into the

00:02:19,120 --> 00:02:23,040
svelte compiler

00:02:21,360 --> 00:02:25,200
don't worry if you're not familiar with

00:02:23,040 --> 00:02:27,599
swelt or compiler

00:02:25,200 --> 00:02:29,280
i'll try my best to avoid the jargons

00:02:27,599 --> 00:02:31,760
and explain the general idea of the

00:02:29,280 --> 00:02:34,400
process

00:02:31,760 --> 00:02:36,239
my name is stanley hau i'm a software

00:02:34,400 --> 00:02:38,239
engineer at shopee

00:02:36,239 --> 00:02:40,720
is an e-commerce platform in southeast

00:02:38,239 --> 00:02:43,040
asia that is based in singapore

00:02:40,720 --> 00:02:44,000
i grew up in a lovely town called penang

00:02:43,040 --> 00:02:45,440
in malaysia

00:02:44,000 --> 00:02:48,080
which has the best street food in

00:02:45,440 --> 00:02:51,519
malaysia such as chagwitio

00:02:48,080 --> 00:02:53,440
stir-fried flat rice noodle roja

00:02:51,519 --> 00:02:55,120
athletic fruit salad with palm sugar

00:02:53,440 --> 00:02:57,360
peanuts and chili dressing

00:02:55,120 --> 00:02:59,200
just don't get me started with food so

00:02:57,360 --> 00:03:00,400
hopefully you guys can come visit

00:02:59,200 --> 00:03:03,519
malaysia after this

00:03:00,400 --> 00:03:05,599
coronavirus pandemic is over

00:03:03,519 --> 00:03:08,720
last but not the least i'm one of the

00:03:05,599 --> 00:03:08,720
maintainers of svelte

00:03:09,200 --> 00:03:13,040
before we start talking about compilers

00:03:11,280 --> 00:03:15,599
for the benefit of those who haven't

00:03:13,040 --> 00:03:17,040
have a chance to take a look into svelt

00:03:15,599 --> 00:03:19,599
let's take a look at house felt

00:03:17,040 --> 00:03:21,360
component looks like

00:03:19,599 --> 00:03:22,640
a spelled component is written in a file

00:03:21,360 --> 00:03:25,440
with a dots felt

00:03:22,640 --> 00:03:27,360
extension each file describes one's

00:03:25,440 --> 00:03:28,720
field component

00:03:27,360 --> 00:03:31,120
you can add a script tag to the

00:03:28,720 --> 00:03:32,000
component the script allows you to

00:03:31,120 --> 00:03:33,360
define a variable

00:03:32,000 --> 00:03:35,519
just like how you would in any

00:03:33,360 --> 00:03:36,480
javascript code and you can add a

00:03:35,519 --> 00:03:38,640
reference

00:03:36,480 --> 00:03:41,360
to the variables into html tags with

00:03:38,640 --> 00:03:41,360
curly brackets

00:03:41,599 --> 00:03:45,280
to add event listener you use on

00:03:44,000 --> 00:03:46,720
directive

00:03:45,280 --> 00:03:49,360
and you can update the variable just

00:03:46,720 --> 00:03:52,159
like this it will automatically update

00:03:49,360 --> 00:03:52,159
it in your dom

00:03:53,439 --> 00:03:57,760
you can add style tag and write some css

00:03:55,840 --> 00:04:00,400
to style your component

00:03:57,760 --> 00:04:02,239
what cool about it is that the css is

00:04:00,400 --> 00:04:05,439
scoped within the component

00:04:02,239 --> 00:04:06,799
so when i say button background rate not

00:04:05,439 --> 00:04:09,360
only the button is written in this

00:04:06,799 --> 00:04:11,120
component file has the background rate

00:04:09,360 --> 00:04:14,400
not the child component not the parent

00:04:11,120 --> 00:04:16,880
component just this component

00:04:14,400 --> 00:04:19,040
now here is one of the most powerful and

00:04:16,880 --> 00:04:22,240
somewhat controversial features felt

00:04:19,040 --> 00:04:23,919
reactive declarations

00:04:22,240 --> 00:04:26,080
here you have double equals to counts

00:04:23,919 --> 00:04:27,759
time two

00:04:26,080 --> 00:04:29,120
with a dollar and a column sign in front

00:04:27,759 --> 00:04:30,880
of the statement

00:04:29,120 --> 00:04:32,240
this means that the variable double is

00:04:30,880 --> 00:04:34,800
always two times

00:04:32,240 --> 00:04:36,240
of count whenever the value of count has

00:04:34,800 --> 00:04:39,360
changed

00:04:36,240 --> 00:04:41,120
the value of double will update as well

00:04:39,360 --> 00:04:43,280
this definitely feels weird in the

00:04:41,120 --> 00:04:45,280
beginning but the more you use it

00:04:43,280 --> 00:04:46,560
you ask yourself why we didn't have this

00:04:45,280 --> 00:04:49,120
earlier

00:04:46,560 --> 00:04:50,800
so here we have one big red button and a

00:04:49,120 --> 00:04:53,600
text of multiply equations

00:04:50,800 --> 00:04:55,199
as well component i'm going to pause

00:04:53,600 --> 00:04:58,240
here for a moment

00:04:55,199 --> 00:05:01,120
and ask you this question how would you

00:04:58,240 --> 00:05:02,720
implement this if you are not allowed to

00:05:01,120 --> 00:05:04,400
use any framework

00:05:02,720 --> 00:05:06,160
and you have to write it in vanilla

00:05:04,400 --> 00:05:07,840
javascript

00:05:06,160 --> 00:05:10,320
so firstly we are going to start with

00:05:07,840 --> 00:05:13,039
the variable declaration

00:05:10,320 --> 00:05:13,520
next we create the text with document

00:05:13,039 --> 00:05:16,560
create

00:05:13,520 --> 00:05:17,600
text node and insert it to the parent we

00:05:16,560 --> 00:05:20,479
can create a button

00:05:17,600 --> 00:05:20,960
using document or create element set a

00:05:20,479 --> 00:05:23,199
text

00:05:20,960 --> 00:05:26,000
add event listeners with add event

00:05:23,199 --> 00:05:28,000
listener and append it to the parent

00:05:26,000 --> 00:05:29,039
to update the text when account is

00:05:28,000 --> 00:05:31,280
updated

00:05:29,039 --> 00:05:32,800
we can create an update function where

00:05:31,280 --> 00:05:36,400
we update the value of double

00:05:32,800 --> 00:05:38,160
and update the content of the text

00:05:36,400 --> 00:05:39,759
and finally for the style tag we can

00:05:38,160 --> 00:05:42,320
create style tag

00:05:39,759 --> 00:05:43,600
with documental correct element set the

00:05:42,320 --> 00:05:46,800
text content

00:05:43,600 --> 00:05:48,560
and then append it to the document head

00:05:46,800 --> 00:05:50,880
to make sure the button only targets

00:05:48,560 --> 00:05:54,240
this button that we just created

00:05:50,880 --> 00:05:56,000
we add a class to the button

00:05:54,240 --> 00:05:57,840
here the class name is random but it

00:05:56,000 --> 00:06:00,479
could be generated based on the hash

00:05:57,840 --> 00:06:02,160
of the style code so you can get

00:06:00,479 --> 00:06:04,720
consistent class name

00:06:02,160 --> 00:06:07,360
in fact if you look at take a look at

00:06:04,720 --> 00:06:09,440
the swell generated js output

00:06:07,360 --> 00:06:11,520
it looks very similar to the code we

00:06:09,440 --> 00:06:13,759
just wrote

00:06:11,520 --> 00:06:15,199
so this is just the code you need to

00:06:13,759 --> 00:06:18,000
write to create a button

00:06:15,199 --> 00:06:20,080
and a text you donate 40 kilobyte

00:06:18,000 --> 00:06:22,560
virtual dom library to recreate the same

00:06:20,080 --> 00:06:24,560
component of course you don't have to

00:06:22,560 --> 00:06:26,880
write all of this yourself

00:06:24,560 --> 00:06:28,240
the field compiler will do it for you it

00:06:26,880 --> 00:06:31,520
will analyze the code

00:06:28,240 --> 00:06:34,560
and generate a code like this one

00:06:31,520 --> 00:06:36,720
and now if you try to choose ssr which

00:06:34,560 --> 00:06:39,360
stands for server side rendering

00:06:36,720 --> 00:06:41,440
as a generated output you can see that

00:06:39,360 --> 00:06:42,319
svelte generates a function that returns

00:06:41,440 --> 00:06:45,360
a string

00:06:42,319 --> 00:06:46,800
composed using template literals this is

00:06:45,360 --> 00:06:48,560
a few orders

00:06:46,800 --> 00:06:50,080
more performance than generating a tree

00:06:48,560 --> 00:06:53,120
object and serializing them

00:06:50,080 --> 00:06:53,120
into html string

00:06:53,599 --> 00:06:57,440
so let's take a few more examples of

00:06:55,360 --> 00:06:58,319
sprout syntax and along the way i hope

00:06:57,440 --> 00:07:02,080
you ask yourself

00:06:58,319 --> 00:07:05,120
this one question how do i convert this

00:07:02,080 --> 00:07:07,120
and write this in plain javascript

00:07:05,120 --> 00:07:08,560
and don't worry you can find this ripple

00:07:07,120 --> 00:07:10,319
on the svelt website

00:07:08,560 --> 00:07:12,319
and you can compare the input and js

00:07:10,319 --> 00:07:15,120
output any way you want

00:07:12,319 --> 00:07:17,759
so to express logics with template

00:07:15,120 --> 00:07:21,520
provides logic block such as if

00:07:17,759 --> 00:07:23,680
a weight and h to reduce the boilerplate

00:07:21,520 --> 00:07:27,520
code for binding a variable to an

00:07:23,680 --> 00:07:29,199
input swell provides the bind directive

00:07:27,520 --> 00:07:32,000
to provide transitions for element

00:07:29,199 --> 00:07:34,880
coming into or out of the dom

00:07:32,000 --> 00:07:36,479
so it provides a transition in out

00:07:34,880 --> 00:07:39,599
directive

00:07:36,479 --> 00:07:41,759
and to compose components so

00:07:39,599 --> 00:07:42,840
provide slots and templates similar to

00:07:41,759 --> 00:07:45,280
the web component

00:07:42,840 --> 00:07:46,720
apis there's so much more i would like

00:07:45,280 --> 00:07:48,720
to share here but

00:07:46,720 --> 00:07:50,800
uh but i have to segue into this file

00:07:48,720 --> 00:07:53,199
compiler because that's the main topic

00:07:50,800 --> 00:07:55,520
of today's talk

00:07:53,199 --> 00:07:56,840
so finally let's take a look at the

00:07:55,520 --> 00:07:59,360
swell

00:07:56,840 --> 00:08:02,479
compiler before that

00:07:59,360 --> 00:08:03,039
how does a compiler works a compiler

00:08:02,479 --> 00:08:04,960
first

00:08:03,039 --> 00:08:07,039
reads through your code and break it

00:08:04,960 --> 00:08:10,240
down into smaller piece

00:08:07,039 --> 00:08:12,160
call tokens and then the compiler goes

00:08:10,240 --> 00:08:14,080
through this list of tokens and arrange

00:08:12,160 --> 00:08:16,800
them into a tree structure

00:08:14,080 --> 00:08:18,000
according to the grammar of the language

00:08:16,800 --> 00:08:20,240
the tree structure

00:08:18,000 --> 00:08:21,440
is what the compiler calls abstract

00:08:20,240 --> 00:08:24,720
syntax 3

00:08:21,440 --> 00:08:27,039
or ast for short

00:08:24,720 --> 00:08:28,160
and ast is a tree representation of the

00:08:27,039 --> 00:08:30,639
input code

00:08:28,160 --> 00:08:31,599
and what the compiler sometimes do is to

00:08:30,639 --> 00:08:34,080
analyze

00:08:31,599 --> 00:08:35,839
apply transformation to the ast using

00:08:34,080 --> 00:08:37,120
three traversal algorithms such as

00:08:35,839 --> 00:08:39,120
deficit

00:08:37,120 --> 00:08:42,479
and finally the compiler generates a

00:08:39,120 --> 00:08:46,240
code output based on the final asd

00:08:42,479 --> 00:08:49,279
in summary a generic compilation process

00:08:46,240 --> 00:08:52,080
involves passing the code to asd

00:08:49,279 --> 00:08:54,320
doing analysis optimization or

00:08:52,080 --> 00:08:58,800
transformation on the ast

00:08:54,320 --> 00:08:58,800
and then generate code out from the ast

00:08:59,200 --> 00:09:04,000
finally let's take a look how swelt

00:09:01,120 --> 00:09:04,000
compiler works

00:09:04,080 --> 00:09:07,839
this field passes the sphero code into

00:09:06,000 --> 00:09:10,640
ast

00:09:07,839 --> 00:09:13,040
swell then analyzes the ast and which we

00:09:10,640 --> 00:09:15,760
will explore in detail later

00:09:13,040 --> 00:09:16,160
with the analysis generates javascript

00:09:15,760 --> 00:09:18,480
code

00:09:16,160 --> 00:09:19,360
depending on the compile target whether

00:09:18,480 --> 00:09:21,839
it's for

00:09:19,360 --> 00:09:23,040
server side rendering ssr or as for the

00:09:21,839 --> 00:09:26,720
browser

00:09:23,040 --> 00:09:28,320
and finally gs and css is generated

00:09:26,720 --> 00:09:31,680
and can be written into file or be

00:09:28,320 --> 00:09:33,519
consumed by your build process

00:09:31,680 --> 00:09:35,600
so let's start from the beginning the

00:09:33,519 --> 00:09:37,760
passing

00:09:35,600 --> 00:09:38,959
here is a spelt component that we are

00:09:37,760 --> 00:09:42,880
going to use throughout

00:09:38,959 --> 00:09:46,800
this talk so we have

00:09:42,880 --> 00:09:50,000
variables each block input binding

00:09:46,800 --> 00:09:52,800
right so spell

00:09:50,000 --> 00:09:54,720
implements its own password it passes

00:09:52,800 --> 00:09:58,080
html syntax

00:09:54,720 --> 00:10:01,839
as well as logic blocks such as if each

00:09:58,080 --> 00:10:04,640
or await because javascript is a very

00:10:01,839 --> 00:10:05,760
fairly complex language whenever spelt

00:10:04,640 --> 00:10:09,360
encounters

00:10:05,760 --> 00:10:11,440
a script tag or clear brackets

00:10:09,360 --> 00:10:13,120
it will hand it over to acorn a

00:10:11,440 --> 00:10:16,399
lightweight javascript parser

00:10:13,120 --> 00:10:16,959
to pass the js contents the same thing

00:10:16,399 --> 00:10:20,560
goes

00:10:16,959 --> 00:10:21,920
with css as well svelte uses css3 to

00:10:20,560 --> 00:10:24,959
pass css content

00:10:21,920 --> 00:10:26,880
in between the style tag

00:10:24,959 --> 00:10:28,880
so through the process swell code is

00:10:26,880 --> 00:10:32,240
broken down into tokens

00:10:28,880 --> 00:10:33,680
and is arranged into svel ast

00:10:32,240 --> 00:10:35,279
and if you're interested to see how

00:10:33,680 --> 00:10:37,399
swell ast looks like

00:10:35,279 --> 00:10:40,000
you can check them out at ast

00:10:37,399 --> 00:10:43,760
explorer.net

00:10:40,000 --> 00:10:46,000
the next step is to analyze the ast

00:10:43,760 --> 00:10:47,839
here our code is already in ast but to

00:10:46,000 --> 00:10:51,440
help visualize the process

00:10:47,839 --> 00:10:54,399
i'm going to show you the original code

00:10:51,440 --> 00:10:54,880
the first thing svelte do is to traverse

00:10:54,399 --> 00:10:58,560
through

00:10:54,880 --> 00:11:01,600
the script ast whenever it encounters

00:10:58,560 --> 00:11:04,959
a variable in this case count we record

00:11:01,600 --> 00:11:04,959
it down to the variable name

00:11:05,200 --> 00:11:12,079
here we record values and double

00:11:09,680 --> 00:11:14,000
the double here in this code is a

00:11:12,079 --> 00:11:16,240
reactive decline variable

00:11:14,000 --> 00:11:18,480
but the vanilla javascript we are

00:11:16,240 --> 00:11:21,120
assigning values to this variable double

00:11:18,480 --> 00:11:23,120
which is not declared anywhere in strict

00:11:21,120 --> 00:11:25,440
mode this is assignment to undeclared

00:11:23,120 --> 00:11:28,480
variable error

00:11:25,440 --> 00:11:30,800
marks this variable double as injected

00:11:28,480 --> 00:11:32,959
so the declaration of the variable will

00:11:30,800 --> 00:11:35,839
be injected later

00:11:32,959 --> 00:11:37,760
other examples of injected variables are

00:11:35,839 --> 00:11:40,839
swelled magic global such as

00:11:37,760 --> 00:11:45,040
dollar props or dollar prefix of a store

00:11:40,839 --> 00:11:47,200
variable here we encounter counts again

00:11:45,040 --> 00:11:49,040
this time it's being referenced instead

00:11:47,200 --> 00:11:51,200
of being assigned to a value

00:11:49,040 --> 00:11:52,079
and it's used to compute the value of

00:11:51,200 --> 00:11:54,000
double

00:11:52,079 --> 00:11:56,160
so we draw a dependency relationship

00:11:54,000 --> 00:11:59,040
between count and double

00:11:56,160 --> 00:12:00,720
so double is depending on count let's

00:11:59,040 --> 00:12:03,920
continue

00:12:00,720 --> 00:12:05,600
here we see data data is not declared at

00:12:03,920 --> 00:12:07,600
the top level scope

00:12:05,600 --> 00:12:09,120
and it as it is within the curly

00:12:07,600 --> 00:12:11,600
brackets block scope

00:12:09,120 --> 00:12:13,920
so we are not going to record it down

00:12:11,600 --> 00:12:15,760
same thing goes with i

00:12:13,920 --> 00:12:18,000
here we encounter double again so we

00:12:15,760 --> 00:12:20,399
mark it as reference

00:12:18,000 --> 00:12:21,680
math a gs global so we're going to

00:12:20,399 --> 00:12:25,839
ignore it

00:12:21,680 --> 00:12:25,839
here values is mutated

00:12:26,000 --> 00:12:31,839
so we reach end of the script the next

00:12:28,160 --> 00:12:34,160
step is to traverse the template ast

00:12:31,839 --> 00:12:35,360
we start from input element which has a

00:12:34,160 --> 00:12:36,959
bind value

00:12:35,360 --> 00:12:39,040
here we are binding the value of the

00:12:36,959 --> 00:12:41,600
input to the variable counts

00:12:39,040 --> 00:12:42,560
so we marked the count as reference from

00:12:41,600 --> 00:12:46,079
templates

00:12:42,560 --> 00:12:48,240
and mutated now we encounter that each

00:12:46,079 --> 00:12:49,920
block

00:12:48,240 --> 00:12:52,240
here we are iterating through the

00:12:49,920 --> 00:12:53,040
variable values and we are using the

00:12:52,240 --> 00:12:56,079
variable

00:12:53,040 --> 00:12:58,639
variable value as each item

00:12:56,079 --> 00:13:00,399
so the template within each block will

00:12:58,639 --> 00:13:03,680
have a new scope

00:13:00,399 --> 00:13:05,600
where values is declared so we mark

00:13:03,680 --> 00:13:07,920
values as the dependency of the each

00:13:05,600 --> 00:13:09,680
block this means that whenever values

00:13:07,920 --> 00:13:11,279
has changed we are going to update each

00:13:09,680 --> 00:13:15,760
block

00:13:11,279 --> 00:13:15,760
and we mark values as reference too

00:13:16,720 --> 00:13:20,639
next we move into the each block and the

00:13:18,880 --> 00:13:23,760
div element here we mark

00:13:20,639 --> 00:13:25,440
value as reference from a template here

00:13:23,760 --> 00:13:26,959
we encounter value again

00:13:25,440 --> 00:13:29,440
and we have reached the end of the

00:13:26,959 --> 00:13:29,440
template

00:13:30,160 --> 00:13:34,000
next well travels through the script

00:13:32,079 --> 00:13:36,880
again this time mainly

00:13:34,000 --> 00:13:38,800
for optimization figuring out which

00:13:36,880 --> 00:13:41,600
variables are not referenced

00:13:38,800 --> 00:13:42,959
and does not needs to be reactive

00:13:41,600 --> 00:13:45,199
similarly

00:13:42,959 --> 00:13:46,639
if a reactive declaration dependencies

00:13:45,199 --> 00:13:48,240
will never change

00:13:46,639 --> 00:13:50,240
by seeing whether their dependencies

00:13:48,240 --> 00:13:52,800
were marked as mutated

00:13:50,240 --> 00:13:54,560
we can mark it as static which will

00:13:52,800 --> 00:13:55,680
generate a more efficient and much

00:13:54,560 --> 00:13:59,839
smaller code

00:13:55,680 --> 00:14:02,720
later on next sphere travels through

00:13:59,839 --> 00:14:04,160
the style so for each selector it will

00:14:02,720 --> 00:14:07,279
determine whether it will match

00:14:04,160 --> 00:14:08,320
any elements in the template and if it

00:14:07,279 --> 00:14:10,240
does

00:14:08,320 --> 00:14:12,079
sphere will add a spelled hash class

00:14:10,240 --> 00:14:15,199
name to the selector

00:14:12,079 --> 00:14:16,320
as well as the match elements

00:14:15,199 --> 00:14:18,320
although this will increase the

00:14:16,320 --> 00:14:20,399
specificity of that selector

00:14:18,320 --> 00:14:23,519
but it will make the selector scoped

00:14:20,399 --> 00:14:25,440
only to the current spell component

00:14:23,519 --> 00:14:27,279
at the end of this step svelte has

00:14:25,440 --> 00:14:30,639
figured all the variables declared

00:14:27,279 --> 00:14:33,360
and the behavior and their relationship

00:14:30,639 --> 00:14:34,399
with this we move on to the rendering

00:14:33,360 --> 00:14:36,320
phase

00:14:34,399 --> 00:14:38,320
this step is where felt will generate

00:14:36,320 --> 00:14:40,320
the javascript code

00:14:38,320 --> 00:14:41,680
there are two different compile targets

00:14:40,320 --> 00:14:44,320
one is for the dom

00:14:41,680 --> 00:14:46,240
for the client side and another is ssr

00:14:44,320 --> 00:14:48,160
for the server side

00:14:46,240 --> 00:14:50,959
let's first take a look at the dom

00:14:48,160 --> 00:14:50,959
render target

00:14:51,360 --> 00:14:54,880
here we have the source code and here is

00:14:54,160 --> 00:14:58,880
the outline

00:14:54,880 --> 00:15:00,800
of the dom output looks like

00:14:58,880 --> 00:15:03,519
so firstly is what i call a fragment

00:15:00,800 --> 00:15:05,920
block the create fragment function

00:15:03,519 --> 00:15:08,639
returns an object that acts as a recipe

00:15:05,920 --> 00:15:10,639
to create the elements in a component

00:15:08,639 --> 00:15:12,160
each method in the recipe object

00:15:10,639 --> 00:15:14,720
represents the stage

00:15:12,160 --> 00:15:15,760
in a component life cycle so here we

00:15:14,720 --> 00:15:18,800
have the c for

00:15:15,760 --> 00:15:22,480
create m for mounting p

00:15:18,800 --> 00:15:25,199
for up date and d for destroy

00:15:22,480 --> 00:15:26,880
next one we have an instance function

00:15:25,199 --> 00:15:29,759
here's where the state and component

00:15:26,880 --> 00:15:31,440
logics goes into

00:15:29,759 --> 00:15:33,120
finally we have the swell component

00:15:31,440 --> 00:15:35,600
class so each

00:15:33,120 --> 00:15:37,839
file component is compiled into a class

00:15:35,600 --> 00:15:40,800
which is the default export

00:15:37,839 --> 00:15:42,560
in the constructor as you can see calls

00:15:40,800 --> 00:15:44,480
the init function

00:15:42,560 --> 00:15:45,600
which takes in the instance and create

00:15:44,480 --> 00:15:48,639
fragment

00:15:45,600 --> 00:15:49,759
function this is how the three different

00:15:48,639 --> 00:15:53,279
pieces of the sphere

00:15:49,759 --> 00:15:55,040
component come together

00:15:53,279 --> 00:15:56,560
now swell walks through the template

00:15:55,040 --> 00:15:59,920
again and starts

00:15:56,560 --> 00:16:03,279
to insert code into the output

00:15:59,920 --> 00:16:04,800
first we have the input element

00:16:03,279 --> 00:16:06,959
we insert instructions to create the

00:16:04,800 --> 00:16:09,199
input element

00:16:06,959 --> 00:16:11,759
mounting the element to the target and

00:16:09,199 --> 00:16:14,000
remove the element

00:16:11,759 --> 00:16:15,839
next we have the binding of input value

00:16:14,000 --> 00:16:17,920
to the count variable

00:16:15,839 --> 00:16:19,040
we need an input handler to listen to

00:16:17,920 --> 00:16:21,680
the input changes

00:16:19,040 --> 00:16:23,040
so we can update the value of the count

00:16:21,680 --> 00:16:25,839
variable

00:16:23,040 --> 00:16:26,800
so here we pull out the variable list

00:16:25,839 --> 00:16:30,399
and we add the input

00:16:26,800 --> 00:16:30,399
handler variable in

00:16:31,519 --> 00:16:35,279
we set the input value based on the

00:16:33,600 --> 00:16:37,920
variable count

00:16:35,279 --> 00:16:40,000
and add events listener for the input

00:16:37,920 --> 00:16:42,079
changes

00:16:40,000 --> 00:16:44,880
which we should remove event listener

00:16:42,079 --> 00:16:47,519
when we destroy the component

00:16:44,880 --> 00:16:48,240
and in the update phase if the count has

00:16:47,519 --> 00:16:50,880
changed

00:16:48,240 --> 00:16:54,480
and we need to update the value of the

00:16:50,880 --> 00:16:54,480
input based on the value of the count

00:16:54,880 --> 00:16:58,959
next we move on to the each block we

00:16:57,920 --> 00:17:01,440
create a new

00:16:58,959 --> 00:17:03,040
fragment block for each block which

00:17:01,440 --> 00:17:04,000
contains the recipe for creating

00:17:03,040 --> 00:17:07,520
elements for

00:17:04,000 --> 00:17:10,799
one each item because in each

00:17:07,520 --> 00:17:11,919
in each block we have we can have a

00:17:10,799 --> 00:17:14,559
child scope

00:17:11,919 --> 00:17:15,039
that defines a variable value so we

00:17:14,559 --> 00:17:17,600
create

00:17:15,039 --> 00:17:19,839
the get each context function to emulate

00:17:17,600 --> 00:17:19,839
that

00:17:23,360 --> 00:17:27,919
here we fast forward through the steps

00:17:25,439 --> 00:17:31,039
where for each element we insert code

00:17:27,919 --> 00:17:33,360
for how we create mount update

00:17:31,039 --> 00:17:34,400
and destroy them if you are interested

00:17:33,360 --> 00:17:36,559
to know the details

00:17:34,400 --> 00:17:40,720
you can check out my series of blog

00:17:36,559 --> 00:17:40,720
called compile swelt in your head

00:17:41,200 --> 00:17:45,840
now we look at how spelt fills up the

00:17:43,919 --> 00:17:48,640
instance function

00:17:45,840 --> 00:17:50,960
in most cases just copies over whatever

00:17:48,640 --> 00:17:53,440
is written in the script tag

00:17:50,960 --> 00:17:54,960
however for reactive declarations they

00:17:53,440 --> 00:17:58,000
were added

00:17:54,960 --> 00:18:00,160
inside the dollar dollar update function

00:17:58,000 --> 00:18:01,440
and for each statement we add an if

00:18:00,160 --> 00:18:04,000
statement to check whether

00:18:01,440 --> 00:18:05,440
the dependency has changed based on the

00:18:04,000 --> 00:18:08,880
dependency relationship

00:18:05,440 --> 00:18:10,400
that we have drawn earlier now we need

00:18:08,880 --> 00:18:13,600
to declare and add those

00:18:10,400 --> 00:18:15,039
injected variables

00:18:13,600 --> 00:18:16,559
and finally we return a list of

00:18:15,039 --> 00:18:18,160
variables that are referenced by the

00:18:16,559 --> 00:18:20,640
template only

00:18:18,160 --> 00:18:22,880
that is count values and input handler

00:18:20,640 --> 00:18:24,320
in this case

00:18:22,880 --> 00:18:26,480
now to make the variables actually

00:18:24,320 --> 00:18:29,200
reactive we instruments the

00:18:26,480 --> 00:18:30,000
dollar invalidate after each assignment

00:18:29,200 --> 00:18:31,760
statements

00:18:30,000 --> 00:18:34,720
so that it will kickstart the next round

00:18:31,760 --> 00:18:34,720
of update cycle

00:18:35,280 --> 00:18:38,400
so here you have it the compile output

00:18:37,360 --> 00:18:41,679
for the dom

00:18:38,400 --> 00:18:42,000
target let's take a quick look at how

00:18:41,679 --> 00:18:43,919
things

00:18:42,000 --> 00:18:46,559
going for compiling the for the

00:18:43,919 --> 00:18:48,400
server-side rendering targets

00:18:46,559 --> 00:18:50,080
the structure of the output for the

00:18:48,400 --> 00:18:51,200
server-side rendering target is much

00:18:50,080 --> 00:18:54,000
simpler

00:18:51,200 --> 00:18:55,840
it is a function that returns a string

00:18:54,000 --> 00:18:56,640
because there won't be any reactivity

00:18:55,840 --> 00:18:59,039
needed in the

00:18:56,640 --> 00:19:00,480
server you can copy over the code

00:18:59,039 --> 00:19:04,160
verbatim

00:19:00,480 --> 00:19:07,440
from the script tag same thing goes with

00:19:04,160 --> 00:19:09,039
reactive declarations

00:19:07,440 --> 00:19:12,400
of course we need to remember to declare

00:19:09,039 --> 00:19:14,880
the injected variable double

00:19:12,400 --> 00:19:16,320
as we traverse through the template we

00:19:14,880 --> 00:19:18,880
add insert strings

00:19:16,320 --> 00:19:20,480
or expressions into the output template

00:19:18,880 --> 00:19:22,640
literal

00:19:20,480 --> 00:19:24,160
for the each block we iterate through

00:19:22,640 --> 00:19:28,320
the variable values

00:19:24,160 --> 00:19:30,960
and return the child elements as string

00:19:28,320 --> 00:19:31,600
and there you go the output of a svelte

00:19:30,960 --> 00:19:34,960
component

00:19:31,600 --> 00:19:34,960
for server-side rendering

00:19:35,520 --> 00:19:38,960
so finally svelte outputs the code in

00:19:38,080 --> 00:19:41,919
javascript

00:19:38,960 --> 00:19:42,960
and css with the code as string as well

00:19:41,919 --> 00:19:45,919
as

00:19:42,960 --> 00:19:48,000
as well as a source map this can be

00:19:45,919 --> 00:19:50,880
written into the file system directly

00:19:48,000 --> 00:19:51,200
or be consumed by a module bundler such

00:19:50,880 --> 00:19:53,919
as

00:19:51,200 --> 00:19:56,240
a roll upswell plug-in for roll-up or

00:19:53,919 --> 00:19:58,320
swell loader for web pack

00:19:56,240 --> 00:20:00,320
so let's review again the spell

00:19:58,320 --> 00:20:03,440
compilation process

00:20:00,320 --> 00:20:05,919
swell passes the code into ast

00:20:03,440 --> 00:20:06,640
run a series of steps to analyze the

00:20:05,919 --> 00:20:09,039
code

00:20:06,640 --> 00:20:10,559
tracks the variables references and

00:20:09,039 --> 00:20:12,559
dependencies

00:20:10,559 --> 00:20:13,919
nance generates the code depending on

00:20:12,559 --> 00:20:15,919
the compile target

00:20:13,919 --> 00:20:17,440
whether it's for the client side or for

00:20:15,919 --> 00:20:19,280
the server side

00:20:17,440 --> 00:20:21,520
and the output of render step is in

00:20:19,280 --> 00:20:23,679
terms of javascript and css

00:20:21,520 --> 00:20:26,960
which can be written into file or

00:20:23,679 --> 00:20:29,840
consumed by your build tools

00:20:26,960 --> 00:20:30,799
and that's all thank you so much for

00:20:29,840 --> 00:20:32,880
listening

00:20:30,799 --> 00:20:34,720
if you'd like to learn more about sveltz

00:20:32,880 --> 00:20:35,600
or if you have any questions about

00:20:34,720 --> 00:20:38,880
svelte

00:20:35,600 --> 00:20:41,440
you can follow me on twitter at lyhotan

00:20:38,880 --> 00:20:43,360
lastly i hope you have fun with the

00:20:41,440 --> 00:20:49,840
talks throughout the conference

00:20:43,360 --> 00:20:49,840
see you

00:20:57,190 --> 00:21:05,280
[Music]

00:21:02,000 --> 00:21:06,400
yeah great uh nice to meet you i'm adam

00:21:05,280 --> 00:21:08,320
um

00:21:06,400 --> 00:21:10,400
i think what i'm supposed to do now is

00:21:08,320 --> 00:21:11,840
uh gather any qa questions

00:21:10,400 --> 00:21:14,320
but thank you very much for your

00:21:11,840 --> 00:21:17,679
presentation amazing to see

00:21:14,320 --> 00:21:21,280
uh the inner workings of of us felt and

00:21:17,679 --> 00:21:23,919
more about asts um my head always

00:21:21,280 --> 00:21:24,960
when i see that stuff thank you um thank

00:21:23,919 --> 00:21:26,000
you so

00:21:24,960 --> 00:21:27,760
i think at this point we should be

00:21:26,000 --> 00:21:28,559
welcoming q a tony i don't know if

00:21:27,760 --> 00:21:31,840
you're in on this

00:21:28,559 --> 00:21:33,280
chat i am i am here but my camera is not

00:21:31,840 --> 00:21:34,640
working for some reason so hopefully

00:21:33,280 --> 00:21:36,480
we'll fix that for the next one time

00:21:34,640 --> 00:21:38,720
that was an amazing talk

00:21:36,480 --> 00:21:39,520
it really explained what's happening to

00:21:38,720 --> 00:21:43,039
me

00:21:39,520 --> 00:21:44,720
um so am i right in sainsbury's another

00:21:43,039 --> 00:21:48,080
framework for us to do awesome things

00:21:44,720 --> 00:21:50,880
with javascript broadly speaking

00:21:48,080 --> 00:21:51,440
yeah yeah that's that's right okay and

00:21:50,880 --> 00:21:54,320
is there

00:21:51,440 --> 00:21:55,919
a reason that i would want to reach for

00:21:54,320 --> 00:21:59,760
over one of the other

00:21:55,919 --> 00:22:00,480
frameworks um you know what what's its

00:21:59,760 --> 00:22:02,720
amazing

00:22:00,480 --> 00:22:03,760
capabilities what's it's a winning

00:22:02,720 --> 00:22:07,120
feature

00:22:03,760 --> 00:22:08,960
um so if you ask about why do you think

00:22:07,120 --> 00:22:11,679
uh why should you choose spell instead

00:22:08,960 --> 00:22:12,640
of other frameworks or other libraries

00:22:11,679 --> 00:22:16,480
um i would say

00:22:12,640 --> 00:22:19,200
first thing is um svelte is um

00:22:16,480 --> 00:22:20,159
it's a compiled uh framework which means

00:22:19,200 --> 00:22:22,400
that um

00:22:20,159 --> 00:22:23,520
basically you don't really get any of

00:22:22,400 --> 00:22:26,960
the spell code

00:22:23,520 --> 00:22:27,600
um not like yeah most of the spell code

00:22:26,960 --> 00:22:30,799
is not

00:22:27,600 --> 00:22:33,600
uh that not downloaded to the user

00:22:30,799 --> 00:22:34,640
right most of it is being uh it's like a

00:22:33,600 --> 00:22:37,120
compiler where

00:22:34,640 --> 00:22:38,720
it tries to analyze your code and then

00:22:37,120 --> 00:22:41,120
generates a very

00:22:38,720 --> 00:22:42,000
small and efficient and optimized code

00:22:41,120 --> 00:22:46,559
that will be sent

00:22:42,000 --> 00:22:49,360
to the user so basically uh

00:22:46,559 --> 00:22:50,000
your code size will grow as uh will

00:22:49,360 --> 00:22:52,799
scale

00:22:50,000 --> 00:22:53,600
linearly as how much you write in your

00:22:52,799 --> 00:22:55,360
code

00:22:53,600 --> 00:22:57,280
right that that's i think that's a very

00:22:55,360 --> 00:23:00,400
big um

00:22:57,280 --> 00:23:02,480
win from compared to other frameworks

00:23:00,400 --> 00:23:03,600
right for example in in other frameworks

00:23:02,480 --> 00:23:05,840
you uh

00:23:03,600 --> 00:23:06,799
you may have just like a hello world but

00:23:05,840 --> 00:23:08,400
if you download

00:23:06,799 --> 00:23:10,559
if you if you look at the browser how

00:23:08,400 --> 00:23:14,240
much code is being downloaded that's

00:23:10,559 --> 00:23:15,600
uh may it may be like a few uh kvs 100

00:23:14,240 --> 00:23:19,520
kvs or 10

00:23:15,600 --> 00:23:21,120
a few tens of kbs right but uh it's film

00:23:19,520 --> 00:23:22,960
you you'll be just because if you are

00:23:21,120 --> 00:23:25,919
just doing a hello world then

00:23:22,960 --> 00:23:26,559
we will be just code that create element

00:23:25,919 --> 00:23:29,200
that

00:23:26,559 --> 00:23:30,000
attacks node that has hello world on on

00:23:29,200 --> 00:23:33,039
your browser

00:23:30,000 --> 00:23:35,360
and that's it so that that's a that's

00:23:33,039 --> 00:23:38,240
the main difference of

00:23:35,360 --> 00:23:38,240
spelt i would say

00:23:42,799 --> 00:23:46,080
thank you very much from igor uh he's

00:23:45,440 --> 00:23:48,320
saying

00:23:46,080 --> 00:23:50,400
woods felt what does felt app have a

00:23:48,320 --> 00:23:51,440
code size advantage overview reactors

00:23:50,400 --> 00:23:53,520
for pretty big

00:23:51,440 --> 00:23:55,919
apps so i mean is i suppose the question

00:23:53,520 --> 00:23:58,159
is is there a size at which

00:23:55,919 --> 00:24:00,000
sort of the overhead of react and view

00:23:58,159 --> 00:24:02,840
and those type that model

00:24:00,000 --> 00:24:04,640
is an advantage over svelt for

00:24:02,840 --> 00:24:07,760
optimization i mean

00:24:04,640 --> 00:24:10,320
yeah so i think we get this a lot um

00:24:07,760 --> 00:24:11,679
and i think recently if you guys are on

00:24:10,320 --> 00:24:15,120
pulling on twitter

00:24:11,679 --> 00:24:16,480
i think um someone someone calculated

00:24:15,120 --> 00:24:19,600
like how

00:24:16,480 --> 00:24:20,559
like um how how big spell code will

00:24:19,600 --> 00:24:23,600
scale

00:24:20,559 --> 00:24:24,640
in proportion to your like um your

00:24:23,600 --> 00:24:27,200
application code

00:24:24,640 --> 00:24:28,080
right so that usually would be like you

00:24:27,200 --> 00:24:30,480
can imagine

00:24:28,080 --> 00:24:32,240
your code size will like the output code

00:24:30,480 --> 00:24:34,880
size that the user will get

00:24:32,240 --> 00:24:35,520
will increase linearly uh with like a

00:24:34,880 --> 00:24:38,080
certain

00:24:35,520 --> 00:24:40,159
gradient and a certain like y intercept

00:24:38,080 --> 00:24:42,480
so so that would be like

00:24:40,159 --> 00:24:43,679
the base of say a framework and then it

00:24:42,480 --> 00:24:46,559
grows linearly

00:24:43,679 --> 00:24:47,520
a certain gradient right and maybe for

00:24:46,559 --> 00:24:51,039
react it will start

00:24:47,520 --> 00:24:51,679
very high and then maybe the gradient

00:24:51,039 --> 00:24:53,440
will be

00:24:51,679 --> 00:24:54,960
the slope of itself maybe it's a bit

00:24:53,440 --> 00:24:57,760
small and

00:24:54,960 --> 00:24:58,480
so so people were conjecting like

00:24:57,760 --> 00:25:00,960
whether that

00:24:58,480 --> 00:25:02,000
like when where is the inflection point

00:25:00,960 --> 00:25:04,480
where two point

00:25:02,000 --> 00:25:06,559
two lines meet and you know react well

00:25:04,480 --> 00:25:07,760
eventually getting a smaller code size

00:25:06,559 --> 00:25:11,919
compared to

00:25:07,760 --> 00:25:14,000
uh spells well that that um

00:25:11,919 --> 00:25:15,039
i can't remember the numbers i'm very

00:25:14,000 --> 00:25:17,279
bad at numbers but

00:25:15,039 --> 00:25:18,400
that is that that will come very very

00:25:17,279 --> 00:25:20,559
late at

00:25:18,400 --> 00:25:22,640
if you have a very very big applications

00:25:20,559 --> 00:25:25,919
which in most cases it's

00:25:22,640 --> 00:25:28,559
you won't reach there because um by the

00:25:25,919 --> 00:25:30,640
time you reach there you would have say

00:25:28,559 --> 00:25:32,400
though optimization such as like code

00:25:30,640 --> 00:25:35,520
splitting and things like that

00:25:32,400 --> 00:25:37,360
which will you know you you may not

00:25:35,520 --> 00:25:39,039
need to load all the codes in your

00:25:37,360 --> 00:25:39,679
browser you can just split based on

00:25:39,039 --> 00:25:42,159
routes and

00:25:39,679 --> 00:25:43,600
per routes usually maybe per page you

00:25:42,159 --> 00:25:45,360
don't really need

00:25:43,600 --> 00:25:47,039
you you won't need you won't reach that

00:25:45,360 --> 00:25:50,159
code size right

00:25:47,039 --> 00:25:53,200
that's right and say um i i'll probably

00:25:50,159 --> 00:25:53,919
find a link so so there's like a study

00:25:53,200 --> 00:25:57,120
there's a code

00:25:53,919 --> 00:25:59,200
samples on how to calculate this and

00:25:57,120 --> 00:26:02,559
probably i'll drop the link in the chat

00:25:59,200 --> 00:26:02,559
and you guys can check that out

00:26:05,120 --> 00:26:08,720
yeah that would be brilliant thank you

00:26:07,120 --> 00:26:10,799
there's another question that's come in

00:26:08,720 --> 00:26:11,120
here which kind of uh leads out from

00:26:10,799 --> 00:26:13,520
that

00:26:11,120 --> 00:26:14,159
does svelte do any beybladifying in

00:26:13,520 --> 00:26:17,440
outbreak okay

00:26:14,159 --> 00:26:22,480
so by default es5 actually

00:26:17,440 --> 00:26:23,200
uh i wouldn't say even es6 it's more of

00:26:22,480 --> 00:26:27,520
like the

00:26:23,200 --> 00:26:29,840
es currents right so we don't process

00:26:27,520 --> 00:26:32,480
but we would like transpile it down to

00:26:29,840 --> 00:26:34,000
es5 or any version of javascript

00:26:32,480 --> 00:26:36,559
we will just based on whatever is

00:26:34,000 --> 00:26:39,200
currently in es so which is

00:26:36,559 --> 00:26:39,679
2020 so in fact if you write something

00:26:39,200 --> 00:26:42,400
say

00:26:39,679 --> 00:26:42,799
yes 2020 such as like optional trainings

00:26:42,400 --> 00:26:45,279
uh

00:26:42,799 --> 00:26:46,080
we will just output as optional change

00:26:45,279 --> 00:26:48,400
right we won't

00:26:46,080 --> 00:26:50,080
we won't do anything so if you want to

00:26:48,400 --> 00:26:51,760
support browsers that doesn't support it

00:26:50,080 --> 00:26:52,799
then you have to pipe the output to a

00:26:51,760 --> 00:26:54,640
label to

00:26:52,799 --> 00:26:57,120
no transport to any type is that you're

00:26:54,640 --> 00:26:57,120
looking for

00:26:57,679 --> 00:27:01,039
what about source mapping just quick

00:26:59,840 --> 00:27:04,320
answer because

00:27:01,039 --> 00:27:06,640
okay um using source mapping from

00:27:04,320 --> 00:27:07,520
sort of compiled code in other libraries

00:27:06,640 --> 00:27:09,120
to

00:27:07,520 --> 00:27:11,200
is that sort of does that fit into the

00:27:09,120 --> 00:27:14,320
same answer

00:27:11,200 --> 00:27:15,679
um okay i'm not really sure i'm getting

00:27:14,320 --> 00:27:18,320
the answer but

00:27:15,679 --> 00:27:20,080
uh whatever you write will you output a

00:27:18,320 --> 00:27:22,240
javascript code and a source map

00:27:20,080 --> 00:27:23,600
right and that would do whatever maybe

00:27:22,240 --> 00:27:25,840
label you're using

00:27:23,600 --> 00:27:27,360
so so you would fix in the source map

00:27:25,840 --> 00:27:28,720
and the javascript code and then do

00:27:27,360 --> 00:27:31,039
another translation

00:27:28,720 --> 00:27:31,840
and like source map will chain and you

00:27:31,039 --> 00:27:35,120
can figure out

00:27:31,840 --> 00:27:35,120
the original

00:27:50,640 --> 00:27:53,760
do you think it's a good do you think um

00:27:52,399 --> 00:27:57,039
svelte is a good

00:27:53,760 --> 00:27:59,760
platform for learning javascript

00:27:57,039 --> 00:28:00,880
generally generally i would think yes

00:27:59,760 --> 00:28:04,480
definitely because

00:28:00,880 --> 00:28:06,720
um except the

00:28:04,480 --> 00:28:08,000
weird label statement like the dollar

00:28:06,720 --> 00:28:10,559
colon sign which is

00:28:08,000 --> 00:28:12,399
not very javascripty but besides that

00:28:10,559 --> 00:28:15,200
everything is javascript right

00:28:12,399 --> 00:28:16,720
uh so we don't support any other we

00:28:15,200 --> 00:28:17,520
don't support code that is not

00:28:16,720 --> 00:28:19,600
javascript

00:28:17,520 --> 00:28:20,640
like the the only case we are using it

00:28:19,600 --> 00:28:22,559
is it's

00:28:20,640 --> 00:28:24,320
uh it's the syntax of javascript right

00:28:22,559 --> 00:28:26,960
the dollar colon sign

00:28:24,320 --> 00:28:28,480
but we use it for other purpose but

00:28:26,960 --> 00:28:29,600
besides that whatever you write is

00:28:28,480 --> 00:28:32,399
javascript

00:28:29,600 --> 00:28:33,360
right it's a yeah it's javascript

00:28:32,399 --> 00:28:35,760
standard javascript

00:28:33,360 --> 00:28:37,360
so uh it's different like if you compare

00:28:35,760 --> 00:28:39,200
to other frameworks say

00:28:37,360 --> 00:28:40,960
i would say like react you may be

00:28:39,200 --> 00:28:44,320
learning about jsx

00:28:40,960 --> 00:28:46,240
which is not quite a javascript syntax

00:28:44,320 --> 00:28:47,679
and i guess if you are new you you may

00:28:46,240 --> 00:28:48,000
not know like the difference between

00:28:47,679 --> 00:28:50,320
them

00:28:48,000 --> 00:28:51,840
and you may confuse but if you are just

00:28:50,320 --> 00:28:53,279
learning javascript and you just want to

00:28:51,840 --> 00:28:56,320
write javascript code

00:28:53,279 --> 00:28:57,039
then yes spelt would be great yeah great

00:28:56,320 --> 00:29:00,240
for it

00:28:57,039 --> 00:29:02,880
and also learning win for that isn't it

00:29:00,240 --> 00:29:04,799
sorry so the online rebel is a win is a

00:29:02,880 --> 00:29:06,960
big win for that sort of learning

00:29:04,799 --> 00:29:08,399
easy yeah ease of coding yes i see a lot

00:29:06,960 --> 00:29:10,720
of people are like you know

00:29:08,399 --> 00:29:11,679
trying like i think people are not

00:29:10,720 --> 00:29:14,240
setting up spell

00:29:11,679 --> 00:29:14,799
locally i i have like maybe a hunch

00:29:14,240 --> 00:29:16,880
about that

00:29:14,799 --> 00:29:18,799
because like everyone is just you know

00:29:16,880 --> 00:29:20,960
trying out spell on the rebel

00:29:18,799 --> 00:29:23,039
learning things and then you know um

00:29:20,960 --> 00:29:24,320
share it and ask questions through the

00:29:23,039 --> 00:29:27,200
ripple

00:29:24,320 --> 00:29:29,360
yeah so uh on tangentially like if

00:29:27,200 --> 00:29:31,039
you're learning html and css

00:29:29,360 --> 00:29:33,919
felt will be very good for you as well

00:29:31,039 --> 00:29:35,760
because um you're just writing html css

00:29:33,919 --> 00:29:37,440
right you're not writing some other

00:29:35,760 --> 00:29:40,640
syntaxes that

00:29:37,440 --> 00:29:44,080
that you know transpile to um

00:29:40,640 --> 00:29:47,120
that creates html right i i because

00:29:44,080 --> 00:29:49,200
i was from react and at some point i i

00:29:47,120 --> 00:29:50,399
almost forget that uh class name

00:29:49,200 --> 00:29:54,559
attribute is not

00:29:50,399 --> 00:29:58,080
uh html so that that takes a while to

00:29:54,559 --> 00:29:58,720
learn about that okay here's another

00:29:58,080 --> 00:30:01,360
question

00:29:58,720 --> 00:30:02,720
um always always gets asked uh can you

00:30:01,360 --> 00:30:05,600
use typescript

00:30:02,720 --> 00:30:06,000
um with with authoring spelled yes you

00:30:05,600 --> 00:30:09,520
can

00:30:06,000 --> 00:30:11,760
um you can um so

00:30:09,520 --> 00:30:13,200
of course but you you can't do it now on

00:30:11,760 --> 00:30:15,919
the spelled rebel because

00:30:13,200 --> 00:30:17,200
um it's not configured yeah i think we

00:30:15,919 --> 00:30:20,799
are working on that

00:30:17,200 --> 00:30:23,600
but if you are if you set it up i think

00:30:20,799 --> 00:30:24,559
uh basically in your vs code i think it

00:30:23,600 --> 00:30:27,200
supports

00:30:24,559 --> 00:30:29,039
uh by default so if you install like the

00:30:27,200 --> 00:30:31,520
extension that does the

00:30:29,039 --> 00:30:32,320
type checking things right it will just

00:30:31,520 --> 00:30:37,840
work

00:30:32,320 --> 00:30:37,840
right yeah

00:30:39,039 --> 00:30:42,480
it will just work those are dangerous

00:30:41,200 --> 00:30:44,240
words

00:30:42,480 --> 00:30:45,679
so that is that new because i understood

00:30:44,240 --> 00:30:48,840
that fault didn't

00:30:45,679 --> 00:30:50,480
initially support typescript yes it was

00:30:48,840 --> 00:30:53,640
just

00:30:50,480 --> 00:30:54,720
i think um article okay

00:30:53,640 --> 00:30:58,960
[Music]

00:30:54,720 --> 00:30:58,960
nice for the typescript people um

00:30:59,120 --> 00:31:02,799
there was another question can you talk

00:31:00,880 --> 00:31:05,200
about the server-side frameworks

00:31:02,799 --> 00:31:06,399
zapper or anything about the sort of i

00:31:05,200 --> 00:31:06,880
just noticed there's a question here

00:31:06,399 --> 00:31:08,159
about

00:31:06,880 --> 00:31:09,840
are there server-side rendering

00:31:08,159 --> 00:31:10,640
frameworks specifically for swelt i know

00:31:09,840 --> 00:31:13,760
there is sap

00:31:10,640 --> 00:31:16,880
or does it support others or

00:31:13,760 --> 00:31:19,760
um so okay so

00:31:16,880 --> 00:31:20,559
if you're just going for like vanilla

00:31:19,760 --> 00:31:22,960
like

00:31:20,559 --> 00:31:24,000
like without and so separate itself is

00:31:22,960 --> 00:31:27,279
like a spell

00:31:24,000 --> 00:31:29,039
application builder if i'm not wrong i

00:31:27,279 --> 00:31:30,559
can't remember the acronym of it

00:31:29,039 --> 00:31:32,399
but basically separate is like an

00:31:30,559 --> 00:31:35,760
opinionated way of building

00:31:32,399 --> 00:31:37,760
spell in both the server side and you

00:31:35,760 --> 00:31:40,080
know hydrated on the client side

00:31:37,760 --> 00:31:41,360
and it comes with a lot of opinionated

00:31:40,080 --> 00:31:43,120
like routing

00:31:41,360 --> 00:31:44,640
uh options and things like that

00:31:43,120 --> 00:31:46,960
pre-fetching and

00:31:44,640 --> 00:31:48,559
yeah a lot of those things but if you

00:31:46,960 --> 00:31:52,080
just want to go vanilla like

00:31:48,559 --> 00:31:54,000
uh you know like smell com there's two

00:31:52,080 --> 00:31:56,159
compiled targets as i mentioned in the

00:31:54,000 --> 00:31:56,799
top that one is for the dom one is for

00:31:56,159 --> 00:32:01,120
ssr

00:31:56,799 --> 00:32:03,679
so you can actually compose spell into

00:32:01,120 --> 00:32:04,480
in a ssr mode like a target to ssr then

00:32:03,679 --> 00:32:08,080
it will

00:32:04,480 --> 00:32:09,039
uh it will be it will compile into like

00:32:08,080 --> 00:32:11,120
a function

00:32:09,039 --> 00:32:13,279
and that function itself you can just

00:32:11,120 --> 00:32:15,760
pass it in to any like

00:32:13,279 --> 00:32:16,880
server frameworks like uh say express

00:32:15,760 --> 00:32:20,080
you can just you know

00:32:16,880 --> 00:32:22,640
have have a middleware or handler that

00:32:20,080 --> 00:32:24,000
takes in a request and then just call

00:32:22,640 --> 00:32:25,600
this function and return whatever is

00:32:24,000 --> 00:32:28,799
written as html string

00:32:25,600 --> 00:32:30,960
um yeah you can just do that uh

00:32:28,799 --> 00:32:32,799
yeah then you you don't have to use

00:32:30,960 --> 00:32:33,760
separate but if you want like the

00:32:32,799 --> 00:32:36,080
routing

00:32:33,760 --> 00:32:37,039
routing uh prefetching and all those

00:32:36,080 --> 00:32:39,360
things then yeah

00:32:37,039 --> 00:32:40,080
you can go for separate and of course

00:32:39,360 --> 00:32:42,480
there's a lot

00:32:40,080 --> 00:32:43,120
so separate is maintained by the spell

00:32:42,480 --> 00:32:44,880
team

00:32:43,120 --> 00:32:47,279
but if you want to go for something else

00:32:44,880 --> 00:32:50,960
i think there's other options out there

00:32:47,279 --> 00:32:54,399
um i i can't really remember all of them

00:32:50,960 --> 00:32:55,440
but yeah i i will definitely link that

00:32:54,399 --> 00:32:57,360
up if yeah

00:32:55,440 --> 00:32:59,200
in the chat yeah i think that'll be cool

00:32:57,360 --> 00:33:01,519
yeah um there are

00:32:59,200 --> 00:33:02,720
a few questions here comparing to other

00:33:01,519 --> 00:33:06,559
frameworks i'm going to read

00:33:02,720 --> 00:33:08,720
all of them uh is svelte similar to vue

00:33:06,559 --> 00:33:11,279
um are they what are the main

00:33:08,720 --> 00:33:13,200
differences between the way

00:33:11,279 --> 00:33:15,279
asphalt compiles code compared to other

00:33:13,200 --> 00:33:16,880
frameworks example angular react i think

00:33:15,279 --> 00:33:18,640
you covered that in your talk

00:33:16,880 --> 00:33:20,159
um and by your experience what is the

00:33:18,640 --> 00:33:21,519
bundle size difference between svelte

00:33:20,159 --> 00:33:23,440
and other frameworks and libraries which

00:33:21,519 --> 00:33:26,080
i think you answered earlier but

00:33:23,440 --> 00:33:26,880
um do you want to answer any of those

00:33:26,080 --> 00:33:31,279
specifically

00:33:26,880 --> 00:33:34,559
or um

00:33:31,279 --> 00:33:38,080
i think you've covered

00:33:34,559 --> 00:33:41,919
that already haven't you yeah so

00:33:38,080 --> 00:33:43,840
that means yeah i'm not very familiar

00:33:41,919 --> 00:33:46,000
with other frameworks to be honest like

00:33:43,840 --> 00:33:49,039
i i i'm not sure whether i

00:33:46,000 --> 00:33:49,919
i mean we misrepresent them like like

00:33:49,039 --> 00:33:52,080
you know comparing

00:33:49,919 --> 00:33:53,679
deal with the spell i'm not really

00:33:52,080 --> 00:33:56,159
familiar with spiel so i can't talk much

00:33:53,679 --> 00:33:56,159
about it

00:33:56,720 --> 00:34:00,320
what about state management then let's

00:33:58,080 --> 00:34:03,360
move on let's talk about svelte like how

00:34:00,320 --> 00:34:04,640
can can you give can you give a short

00:34:03,360 --> 00:34:07,519
answer to on how

00:34:04,640 --> 00:34:09,520
state management works insult and maybe

00:34:07,519 --> 00:34:13,359
how that affects compilation

00:34:09,520 --> 00:34:15,839
okay so by default uh i think

00:34:13,359 --> 00:34:17,359
for for for one spell component you have

00:34:15,839 --> 00:34:19,200
states right like uh

00:34:17,359 --> 00:34:21,440
how you write them is like how you write

00:34:19,200 --> 00:34:22,879
them is to just declare a variable

00:34:21,440 --> 00:34:25,280
in your script tag and then you can just

00:34:22,879 --> 00:34:26,560
use them like they are like states where

00:34:25,280 --> 00:34:28,320
you can you change them

00:34:26,560 --> 00:34:30,320
it will affect your you will update on

00:34:28,320 --> 00:34:32,960
your component

00:34:30,320 --> 00:34:34,960
right but um but beyond the component

00:34:32,960 --> 00:34:37,440
because spell compiles

00:34:34,960 --> 00:34:38,560
component by component right so if you

00:34:37,440 --> 00:34:42,560
want to if you want to share

00:34:38,560 --> 00:34:44,800
things across components then

00:34:42,560 --> 00:34:46,240
then it depends on how the two

00:34:44,800 --> 00:34:48,480
components are

00:34:46,240 --> 00:34:49,839
related in relation with each other

00:34:48,480 --> 00:34:52,240
right you can think that

00:34:49,839 --> 00:34:53,359
in terms of i think view or react or all

00:34:52,240 --> 00:34:55,599
other frameworks

00:34:53,359 --> 00:34:57,520
if it's a parent and child then probably

00:34:55,599 --> 00:35:00,640
you do something like a props

00:34:57,520 --> 00:35:03,359
uh that that works it's well uh if

00:35:00,640 --> 00:35:04,000
they are siblings then probably you can

00:35:03,359 --> 00:35:07,599
uh

00:35:04,000 --> 00:35:10,720
maybe share the poised state up

00:35:07,599 --> 00:35:12,160
or maybe or you can do some also provide

00:35:10,720 --> 00:35:15,520
something called a store

00:35:12,160 --> 00:35:17,920
so store is like a

00:35:15,520 --> 00:35:18,640
i would say like a standalone store

00:35:17,920 --> 00:35:20,400
where

00:35:18,640 --> 00:35:21,760
you can subscribe where you can

00:35:20,400 --> 00:35:24,240
subscribe and

00:35:21,760 --> 00:35:25,280
the subscribe to state changes on the

00:35:24,240 --> 00:35:27,280
store itself

00:35:25,280 --> 00:35:29,359
so both of the components can just

00:35:27,280 --> 00:35:31,280
subscribe to whatever is in the store

00:35:29,359 --> 00:35:32,560
and whenever it's changed it will update

00:35:31,280 --> 00:35:35,280
that too yeah

00:35:32,560 --> 00:35:37,359
and you can change each other any way

00:35:35,280 --> 00:35:41,359
around you want

00:35:37,359 --> 00:35:43,839
yeah um so that that is uh

00:35:41,359 --> 00:35:45,200
out of the box from spell but of course

00:35:43,839 --> 00:35:47,520
you can definitely

00:35:45,200 --> 00:35:48,480
do whatever you want like say you can

00:35:47,520 --> 00:35:50,560
use redux

00:35:48,480 --> 00:35:52,000
no one's stopping you doing that you can

00:35:50,560 --> 00:35:53,760
use uh

00:35:52,000 --> 00:35:55,200
xstate like if you want state machines

00:35:53,760 --> 00:35:58,079
you can use xstates

00:35:55,200 --> 00:35:58,880
or any other state management frameworks

00:35:58,079 --> 00:36:02,000
or maybe

00:35:58,880 --> 00:36:05,040
you like doing reactive uh

00:36:02,000 --> 00:36:07,760
for example rxjs that's okay

00:36:05,040 --> 00:36:09,280
that works well with spell as well so i

00:36:07,760 --> 00:36:13,200
think uh that

00:36:09,280 --> 00:36:16,720
um all of them i mean there's no

00:36:13,200 --> 00:36:18,640
let's say yeah you can use any state

00:36:16,720 --> 00:36:20,400
management frameworks out there that

00:36:18,640 --> 00:36:23,520
and i think they work well with this

00:36:20,400 --> 00:36:25,839
field right

00:36:23,520 --> 00:36:26,560
that's a good answer because yeah i

00:36:25,839 --> 00:36:30,079
think

00:36:26,560 --> 00:36:32,480
i think that's a that that's uh

00:36:30,079 --> 00:36:34,640
that's uh i i mean i was aware of a bit

00:36:32,480 --> 00:36:35,680
of the internals of using scott but i

00:36:34,640 --> 00:36:38,880
wasn't aware that actually

00:36:35,680 --> 00:36:40,240
it was a straightforward swap with redux

00:36:38,880 --> 00:36:42,560
and you could use it

00:36:40,240 --> 00:36:44,160
which makes sense right now yeah because

00:36:42,560 --> 00:36:46,480
i mean redux

00:36:44,160 --> 00:36:48,400
i mean redux is introduced with react

00:36:46,480 --> 00:36:50,240
but it is a storage cell that

00:36:48,400 --> 00:36:52,079
it doesn't really need to be using it

00:36:50,240 --> 00:36:55,280
with react you can use it with

00:36:52,079 --> 00:36:56,800
any other things as well yeah

00:36:55,280 --> 00:36:58,320
i think we need to wrap up questions now

00:36:56,800 --> 00:37:00,079
because the next talk's ready but i

00:36:58,320 --> 00:37:00,800
think uh big round of applause virtual

00:37:00,079 --> 00:37:03,599
one for you

00:37:00,800 --> 00:37:04,640
and uh great talk and thanks very much

00:37:03,599 --> 00:37:07,440
um

00:37:04,640 --> 00:37:08,720
i think the talk is really i'm just if

00:37:07,440 --> 00:37:09,760
someone in the internal check can just

00:37:08,720 --> 00:37:13,520
give us a

00:37:09,760 --> 00:37:16,560
view and i'll handle tony turner youtube

00:37:13,520 --> 00:37:18,480
yeah it's just about to start

00:37:16,560 --> 00:37:20,560
it is just about start time i'd like to

00:37:18,480 --> 00:37:21,280
say a huge thank you for your talk it

00:37:20,560 --> 00:37:23,040
really really

00:37:21,280 --> 00:37:24,720
opened up what felt was to me it was

00:37:23,040 --> 00:37:26,400
something i wasn't really familiar with

00:37:24,720 --> 00:37:27,200
and i'm sure there's a lot of people in

00:37:26,400 --> 00:37:29,440
the audience

00:37:27,200 --> 00:37:30,720
um exactly the same if you've got a one

00:37:29,440 --> 00:37:35,200
sentence answer

00:37:30,720 --> 00:37:37,839
for this question does shoppy use

00:37:35,200 --> 00:37:37,839
something else

00:37:38,720 --> 00:37:45,440
ah and with that we leave this q a

00:37:42,240 --> 00:37:46,960
there oh no

00:37:45,440 --> 00:37:51,839
thank you very much thank you for having

00:37:46,960 --> 00:37:51,839

YouTube URL: https://www.youtube.com/watch?v=zVfd4ou9qaw


