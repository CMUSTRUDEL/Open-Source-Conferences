Title: The Current State of the Data Sharing Economy  - City JS Conf 2019
Publication date: 2019-05-14
Playlist: City JS Conf 2019
Description: 
	Srushtika Neelakantam

In this talk, we'll see what real-time messaging and data streaming means, from the protocol level of applications. We'll also look at various open source tools to implement the real-time messaging architecture to stream data both within and outside of your applications and address the unforeseen challenges involved, with code examples in Node.js and JavaScript. In the end, we'll look the evolution of the data sharing economy, the various protocols, some standardised and some not, all of which you need to know to be at the top of your tech game.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:03,419
so I'm gonna be speaking about the

00:00:01,589 --> 00:00:05,460
current state of the data sharing

00:00:03,419 --> 00:00:07,770
economy I'm sure she can EULA contemn

00:00:05,460 --> 00:00:10,349
and I work as a developer advocate for a

00:00:07,770 --> 00:00:14,969
blue real-time any of you have heard of

00:00:10,349 --> 00:00:19,619
a Blee before cool so for the rest of

00:00:14,969 --> 00:00:21,510
you ABR furs a real you know real-time

00:00:19,619 --> 00:00:22,529
messaging infrastructure as a service

00:00:21,510 --> 00:00:25,050
that you can implement in your

00:00:22,529 --> 00:00:27,750
applications to incorporate real-time or

00:00:25,050 --> 00:00:29,369
live sort of functionality in my spare

00:00:27,750 --> 00:00:31,710
time I also volunteer with the Mozilla

00:00:29,369 --> 00:00:35,160
Foundation and I'm a co-author of web

00:00:31,710 --> 00:00:37,140
via book and in this talk we look at the

00:00:35,160 --> 00:00:39,930
evolution in the communication protocols

00:00:37,140 --> 00:00:42,540
that have that have enabled us to build

00:00:39,930 --> 00:00:44,340
the kind of applications or you know

00:00:42,540 --> 00:00:48,270
we'll the kind of businesses around data

00:00:44,340 --> 00:00:50,460
that are really based on how much time

00:00:48,270 --> 00:00:52,680
the data takes to move from one point to

00:00:50,460 --> 00:00:54,059
the other and you know the kind of

00:00:52,680 --> 00:00:56,940
applications that are completely data

00:00:54,059 --> 00:01:00,359
centric so let's get started

00:00:56,940 --> 00:01:03,000
it all started in late 1980s and 90s

00:01:00,359 --> 00:01:05,250
when you know Sir Tim berners-lee came

00:01:03,000 --> 00:01:07,560
up with invented the world wide web

00:01:05,250 --> 00:01:09,540
enabling any two nodes to speak with

00:01:07,560 --> 00:01:11,460
each other over the Internet even though

00:01:09,540 --> 00:01:15,659
they were geographically you know miles

00:01:11,460 --> 00:01:17,340
apart now obviously in in college or in

00:01:15,659 --> 00:01:18,180
university you would have heard of the

00:01:17,340 --> 00:01:20,310
OSI model

00:01:18,180 --> 00:01:22,590
so let's actually begin from the basics

00:01:20,310 --> 00:01:24,090
bear with me if you are a complete

00:01:22,590 --> 00:01:26,220
master of the things that I'm gonna

00:01:24,090 --> 00:01:27,840
cover in the first few slides but this

00:01:26,220 --> 00:01:30,270
is just to like you know put some

00:01:27,840 --> 00:01:33,180
context for the rest of the discussion

00:01:30,270 --> 00:01:34,740
so obviously with the open systems

00:01:33,180 --> 00:01:37,049
interconnection model or the OSI model

00:01:34,740 --> 00:01:39,030
we have different layers which tell you

00:01:37,049 --> 00:01:40,890
how your applications from the

00:01:39,030 --> 00:01:44,009
application layer in a interact with

00:01:40,890 --> 00:01:46,229
physical web that lets your data

00:01:44,009 --> 00:01:48,420
traverse around the internet and then

00:01:46,229 --> 00:01:49,740
communicate with other applications the

00:01:48,420 --> 00:01:52,470
only thing I'm not gonna bore you with

00:01:49,740 --> 00:01:54,960
the explanation of there all the layers

00:01:52,470 --> 00:01:56,399
but you actually remember when you

00:01:54,960 --> 00:01:58,619
studied this in university did you

00:01:56,399 --> 00:02:00,960
actually remember this you know OSI

00:01:58,619 --> 00:02:01,409
model it was really difficult for me to

00:02:00,960 --> 00:02:03,719
remember

00:02:01,409 --> 00:02:05,040
so our professor networks professor in

00:02:03,719 --> 00:02:06,930
college gave us actually a really good

00:02:05,040 --> 00:02:09,479
way to remember it if you see the first

00:02:06,930 --> 00:02:12,450
you know letters of each of these layers

00:02:09,479 --> 00:02:13,870
it's all forms this which further

00:02:12,450 --> 00:02:17,080
extends to please do not

00:02:13,870 --> 00:02:19,330
Trust salespersons advice not really

00:02:17,080 --> 00:02:21,280
sure how many of you agree with that but

00:02:19,330 --> 00:02:23,440
anyway that's a good way to remember it

00:02:21,280 --> 00:02:26,860
what we are interested to know in this

00:02:23,440 --> 00:02:28,510
sort of OSI model is only the seventh

00:02:26,860 --> 00:02:30,159
layer which is the application model

00:02:28,510 --> 00:02:32,170
which provides us with this network

00:02:30,159 --> 00:02:34,209
services for the applications that we

00:02:32,170 --> 00:02:36,640
build as JavaScript developers and you

00:02:34,209 --> 00:02:38,829
know the services that enable our

00:02:36,640 --> 00:02:40,900
applications to communicate with the

00:02:38,829 --> 00:02:45,910
other you know clients are knows over

00:02:40,900 --> 00:02:47,500
the internet so you know them as the as

00:02:45,910 --> 00:02:50,079
the Internet and you know this

00:02:47,500 --> 00:02:51,910
communication became popular there

00:02:50,079 --> 00:02:54,940
needed to be some kind of set of rules

00:02:51,910 --> 00:02:56,379
standard set of rules that you know all

00:02:54,940 --> 00:03:00,040
of these nodes participating in this

00:02:56,379 --> 00:03:01,810
internet had to adhere with and the most

00:03:00,040 --> 00:03:04,239
standardized here you know the

00:03:01,810 --> 00:03:06,489
standardized communication protocol over

00:03:04,239 --> 00:03:08,109
the Internet is HTTP of course we know

00:03:06,489 --> 00:03:10,090
about it hypertext Transfer Protocol and

00:03:08,109 --> 00:03:12,250
that's that's where it resides in the

00:03:10,090 --> 00:03:15,400
level in layer seven which is very near

00:03:12,250 --> 00:03:17,049
as to where we you know work with the

00:03:15,400 --> 00:03:18,940
different kind of applications so

00:03:17,049 --> 00:03:22,269
actually let's have a quick look I have

00:03:18,940 --> 00:03:24,489
a simple HTTP application and if I show

00:03:22,269 --> 00:03:26,470
you the inspector time we've done this a

00:03:24,489 --> 00:03:28,359
lot of times for our applications to you

00:03:26,470 --> 00:03:30,010
know kind of debug the way our

00:03:28,359 --> 00:03:31,690
application is interacting with over the

00:03:30,010 --> 00:03:33,910
Internet so if I quickly refresh this

00:03:31,690 --> 00:03:35,470
hopefully the Internet is working so

00:03:33,910 --> 00:03:38,319
this is the resource I have requested

00:03:35,470 --> 00:03:40,299
and as you can see you have you know the

00:03:38,319 --> 00:03:42,459
request URL that I have requested the

00:03:40,299 --> 00:03:44,410
different methods HTTP comes with you

00:03:42,459 --> 00:03:46,510
know get put pose all of those things

00:03:44,410 --> 00:03:48,549
which you already aware of the status

00:03:46,510 --> 00:03:50,739
code 200 generally means it is you know

00:03:48,549 --> 00:03:52,870
successful and you can go in that

00:03:50,739 --> 00:03:55,269
details about the different kinds of

00:03:52,870 --> 00:03:57,190
requests and response headers that you

00:03:55,269 --> 00:03:59,260
have you can also look at the timing

00:03:57,190 --> 00:04:00,790
which gives you the you know basically

00:03:59,260 --> 00:04:02,169
latency from the time you send the

00:04:00,790 --> 00:04:04,030
request and the time you got the

00:04:02,169 --> 00:04:06,280
response so if you think about it

00:04:04,030 --> 00:04:08,019
basically HTTP works this way right you

00:04:06,280 --> 00:04:09,760
have a client and the server client

00:04:08,019 --> 00:04:12,430
sends the request the server depending

00:04:09,760 --> 00:04:14,519
on you know if it has the resource or

00:04:12,430 --> 00:04:17,590
the service request it gives back that

00:04:14,519 --> 00:04:19,539
resource in the response or just sends

00:04:17,590 --> 00:04:21,579
back an empty response or just an error

00:04:19,539 --> 00:04:23,380
and then if the two entities want to

00:04:21,579 --> 00:04:25,390
communicate again you set up a whole new

00:04:23,380 --> 00:04:26,900
connection and then the same request and

00:04:25,390 --> 00:04:29,060
response cycles repeat

00:04:26,900 --> 00:04:30,680
now HTTP is stateless so you can't

00:04:29,060 --> 00:04:32,389
really have a preserve the context from

00:04:30,680 --> 00:04:34,550
the previous communication and if you

00:04:32,389 --> 00:04:36,620
wanna you know continuously communicate

00:04:34,550 --> 00:04:39,530
this whole setup needs to be repeated

00:04:36,620 --> 00:04:41,330
all the time so this is all well and

00:04:39,530 --> 00:04:42,560
good for the applications we had back in

00:04:41,330 --> 00:04:45,290
the day when you know there are some

00:04:42,560 --> 00:04:48,740
static hosted resources that you had to

00:04:45,290 --> 00:04:51,350
you know look at for instance say there

00:04:48,740 --> 00:04:53,449
was a business that that learned about

00:04:51,350 --> 00:04:55,010
the advent of Internet and wanted to

00:04:53,449 --> 00:04:57,199
make their business more visible or

00:04:55,010 --> 00:05:00,139
accessible by placing their products or

00:04:57,199 --> 00:05:02,600
placing their catalog over the Internet

00:05:00,139 --> 00:05:04,270
you could click on a button and you

00:05:02,600 --> 00:05:06,440
would send essentially in the back

00:05:04,270 --> 00:05:08,090
background you will be sending a request

00:05:06,440 --> 00:05:09,380
and getting some response back and

00:05:08,090 --> 00:05:11,389
that'll be nicely displayed on the

00:05:09,380 --> 00:05:13,310
webpage so at this point actually let's

00:05:11,389 --> 00:05:15,260
start put together start putting

00:05:13,310 --> 00:05:17,270
together all of this that we're talking

00:05:15,260 --> 00:05:20,210
about on a linear graph so by the end of

00:05:17,270 --> 00:05:22,820
this talk we kind of know where we are

00:05:20,210 --> 00:05:25,699
currently at this evolution of in the of

00:05:22,820 --> 00:05:28,760
the online data sharing economy right so

00:05:25,699 --> 00:05:30,470
as I said as internet came and you know

00:05:28,760 --> 00:05:32,060
they were standardized protocols and you

00:05:30,470 --> 00:05:33,380
had really good ways of you know

00:05:32,060 --> 00:05:34,460
communicating efficient ways of

00:05:33,380 --> 00:05:36,110
communicating over the internet

00:05:34,460 --> 00:05:37,580
businesses thought it would be a good

00:05:36,110 --> 00:05:38,990
idea to you know make their services

00:05:37,580 --> 00:05:41,360
available over the Internet

00:05:38,990 --> 00:05:44,210
they built websites and let their users

00:05:41,360 --> 00:05:46,130
request resources and all kinds of data

00:05:44,210 --> 00:05:48,349
from those websites but then what

00:05:46,130 --> 00:05:50,389
happened this became really popular now

00:05:48,349 --> 00:05:52,490
this was really usable and really

00:05:50,389 --> 00:05:54,410
helpful for the users to like you know

00:05:52,490 --> 00:05:56,510
click a button from the comfort of their

00:05:54,410 --> 00:05:59,090
home and you know I saw access all this

00:05:56,510 --> 00:06:01,940
kind of data and resources right so as

00:05:59,090 --> 00:06:04,789
this happened the people the business is

00:06:01,940 --> 00:06:06,020
hosting the websites quickly realized

00:06:04,789 --> 00:06:07,550
that they had to build more

00:06:06,020 --> 00:06:09,260
functionality on top of the basic

00:06:07,550 --> 00:06:11,479
implementation to deal with the kind of

00:06:09,260 --> 00:06:14,449
traffic that was coming to this website

00:06:11,479 --> 00:06:16,760
so you know they might be they might

00:06:14,449 --> 00:06:18,860
have to deal with how many people are

00:06:16,760 --> 00:06:21,229
coming you know rate limiting some kind

00:06:18,860 --> 00:06:23,060
of you know IP addresses etc so that

00:06:21,229 --> 00:06:26,960
their service basically don't crash and

00:06:23,060 --> 00:06:28,910
then obviously you came up with caching

00:06:26,960 --> 00:06:30,680
mechanism because a lot of these people

00:06:28,910 --> 00:06:32,510
who are requesting some resources were

00:06:30,680 --> 00:06:34,940
requesting for the same kind of set of

00:06:32,510 --> 00:06:36,140
resources a lot of those people so you

00:06:34,940 --> 00:06:37,969
know you could just essentially put a

00:06:36,140 --> 00:06:39,580
caching mechanism in between and just

00:06:37,969 --> 00:06:40,840
duplicate the resources

00:06:39,580 --> 00:06:43,000
that would already Requested without

00:06:40,840 --> 00:06:45,009
disturbing the server all the time even

00:06:43,000 --> 00:06:46,270
for duplicate resources then obviously

00:06:45,009 --> 00:06:48,340
all of these assets that you were

00:06:46,270 --> 00:06:50,379
showing were to be stored somewhere and

00:06:48,340 --> 00:06:51,969
you had the databases which were again

00:06:50,379 --> 00:06:54,039
connected to your server again

00:06:51,969 --> 00:06:56,349
communicating over HTTP and all of that

00:06:54,039 --> 00:06:58,180
sort of thing came up and soon people

00:06:56,349 --> 00:07:00,189
realize this sort of engineering stack

00:06:58,180 --> 00:07:03,009
and the investment and time spent on

00:07:00,189 --> 00:07:05,199
engineering to just make a website and

00:07:03,009 --> 00:07:07,689
its services available online this sort

00:07:05,199 --> 00:07:09,669
of functionality stack was growing and

00:07:07,689 --> 00:07:11,650
growing as you know more people started

00:07:09,669 --> 00:07:13,690
using websites and people realize the

00:07:11,650 --> 00:07:15,430
possibilities that could be done now

00:07:13,690 --> 00:07:17,110
while all of this was happening a couple

00:07:15,430 --> 00:07:19,389
of other people were observing this

00:07:17,110 --> 00:07:21,219
trend and they said hey wait a minute

00:07:19,389 --> 00:07:23,710
this is not just for the one website

00:07:21,219 --> 00:07:25,150
that we are discussing about every

00:07:23,710 --> 00:07:27,190
business that wanted to you know put

00:07:25,150 --> 00:07:29,560
their services online as an application

00:07:27,190 --> 00:07:31,090
or a website was facing the same issues

00:07:29,560 --> 00:07:33,219
and was trying to solve all of those

00:07:31,090 --> 00:07:35,560
functionality layers by implementing

00:07:33,219 --> 00:07:38,469
everything from scratch now as engineers

00:07:35,560 --> 00:07:40,449
we kind of avoid reinventing the wheel

00:07:38,469 --> 00:07:42,550
all the time right so even with all the

00:07:40,449 --> 00:07:44,229
JavaScript frameworks we have we sort of

00:07:42,550 --> 00:07:46,060
have some kind of functionality built in

00:07:44,229 --> 00:07:48,190
that we can use on the fly that's

00:07:46,060 --> 00:07:50,440
exactly what are the people observing

00:07:48,190 --> 00:07:52,210
this trend thought why not implement

00:07:50,440 --> 00:07:54,699
these functional implement this sort of

00:07:52,210 --> 00:07:56,830
functionality once and provide it as a

00:07:54,699 --> 00:07:58,719
service for any company that wants to

00:07:56,830 --> 00:08:01,150
use it and that's sort of when how the

00:07:58,719 --> 00:08:02,830
concept of CDN or content delivery

00:08:01,150 --> 00:08:05,050
network came about where they basically

00:08:02,830 --> 00:08:06,819
took all of this functionality and you

00:08:05,050 --> 00:08:08,620
know provided at a service and not just

00:08:06,819 --> 00:08:10,419
this one website but any sort of you

00:08:08,620 --> 00:08:12,460
know business or application that wanted

00:08:10,419 --> 00:08:14,349
to use these services on top of their

00:08:12,460 --> 00:08:17,289
initial implementation could do that and

00:08:14,349 --> 00:08:20,199
they would be responsible for you know

00:08:17,289 --> 00:08:24,699
managing all of this all of these

00:08:20,199 --> 00:08:25,990
challenges in complexity so this was

00:08:24,699 --> 00:08:29,469
really well right because a lot of

00:08:25,990 --> 00:08:30,550
people then could use these websites and

00:08:29,469 --> 00:08:32,800
the data that was available in the

00:08:30,550 --> 00:08:34,300
website without having to without the

00:08:32,800 --> 00:08:37,000
business and the businesses didn't have

00:08:34,300 --> 00:08:38,469
to worry about you know okay if there

00:08:37,000 --> 00:08:41,620
are so many people coming to my website

00:08:38,469 --> 00:08:44,140
maybe I should worry about ABC rather

00:08:41,620 --> 00:08:46,120
than that now they can really worry

00:08:44,140 --> 00:08:47,680
about what their main focus is which is

00:08:46,120 --> 00:08:49,630
you know creating the data that they

00:08:47,680 --> 00:08:51,610
want to host on the website or creating

00:08:49,630 --> 00:08:52,810
say if it's a merchandise store creating

00:08:51,610 --> 00:08:54,640
the merchandise that they

00:08:52,810 --> 00:08:59,830
actually we'll host on the website later

00:08:54,640 --> 00:09:01,120
on so um you know if we go back to the

00:08:59,830 --> 00:09:04,600
kind of applications that we were

00:09:01,120 --> 00:09:06,520
looking at this is kind of as I said

00:09:04,600 --> 00:09:09,070
this sort of model worked really well

00:09:06,520 --> 00:09:10,960
for static applications or something

00:09:09,070 --> 00:09:12,640
that had to be computed on the fly but

00:09:10,960 --> 00:09:14,350
if you look at the applications that

00:09:12,640 --> 00:09:16,390
we're using now we're more and more

00:09:14,350 --> 00:09:18,040
moving towards the event-driven or

00:09:16,390 --> 00:09:19,810
real-time kind of architecture right

00:09:18,040 --> 00:09:22,420
when something is happening in the real

00:09:19,810 --> 00:09:24,010
world we would like to know using by the

00:09:22,420 --> 00:09:25,930
use of the internet and the internet

00:09:24,010 --> 00:09:29,200
enables us to do that so why not do it

00:09:25,930 --> 00:09:32,380
so let's actually look at I mean if you

00:09:29,200 --> 00:09:33,040
think about HTTP as a protocol solution

00:09:32,380 --> 00:09:34,450
for this

00:09:33,040 --> 00:09:36,900
it doesn't really solve the problem

00:09:34,450 --> 00:09:39,610
right so let's actually consider a

00:09:36,900 --> 00:09:40,990
real-world example where some data is

00:09:39,610 --> 00:09:43,120
changing all the time say Bitcoin

00:09:40,990 --> 00:09:45,850
pricing which changes every few seconds

00:09:43,120 --> 00:09:49,600
so here I have a website which basically

00:09:45,850 --> 00:09:51,430
has does HTTP request to a data provider

00:09:49,600 --> 00:09:53,740
that is providing the price of Bitcoin

00:09:51,430 --> 00:09:55,060
in terms of USD I'm just requesting that

00:09:53,740 --> 00:09:57,130
whatever data was returned I've

00:09:55,060 --> 00:09:59,440
displayed on the website but now I just

00:09:57,130 --> 00:10:01,480
refreshed it before starting this talk

00:09:59,440 --> 00:10:05,260
but by this time it obviously would have

00:10:01,480 --> 00:10:06,820
you know changed again the the best bet

00:10:05,260 --> 00:10:08,770
for me would be to refresh in

00:10:06,820 --> 00:10:11,170
essentially sending a new request and

00:10:08,770 --> 00:10:14,470
you know hoping for some new data to

00:10:11,170 --> 00:10:17,589
arrive so that's how you get it but then

00:10:14,470 --> 00:10:19,589
obviously these the data is changing all

00:10:17,589 --> 00:10:22,390
the time and you need to like you know

00:10:19,589 --> 00:10:25,210
repeat this requests and response cycles

00:10:22,390 --> 00:10:26,350
or all of this cycle all the time which

00:10:25,210 --> 00:10:29,650
is not really efficient because it's

00:10:26,350 --> 00:10:33,130
stateless you need to repeat all the

00:10:29,650 --> 00:10:34,330
header information and everything so one

00:10:33,130 --> 00:10:37,780
thing though which is an improvement

00:10:34,330 --> 00:10:39,160
over HTTP the repetition of HTTP

00:10:37,780 --> 00:10:41,890
requests in response cycles which is

00:10:39,160 --> 00:10:44,890
called poling by the way is long polling

00:10:41,890 --> 00:10:47,589
where you can essentially request

00:10:44,890 --> 00:10:50,050
resource and then let the server wait

00:10:47,589 --> 00:10:52,690
for a little longer before it sends back

00:10:50,050 --> 00:10:54,610
the response hope hoping that it

00:10:52,690 --> 00:10:56,830
actually has some data to return what I

00:10:54,610 --> 00:10:58,839
mean is over here I'm requesting some

00:10:56,830 --> 00:11:00,550
data but in reality it may not have

00:10:58,839 --> 00:11:02,740
changed actually so if I do another

00:11:00,550 --> 00:11:05,350
request is the same you know price that

00:11:02,740 --> 00:11:06,260
is being shown so what I'm doing here is

00:11:05,350 --> 00:11:08,840
just

00:11:06,260 --> 00:11:10,550
request in response cycles repetition

00:11:08,840 --> 00:11:12,020
for no reason because the response

00:11:10,550 --> 00:11:14,120
return is empty because the server

00:11:12,020 --> 00:11:16,490
doesn't have any new data to return so

00:11:14,120 --> 00:11:18,890
with long polling in you can solve that

00:11:16,490 --> 00:11:20,990
bit of complexity where you let the

00:11:18,890 --> 00:11:22,580
server persist the connection for a

00:11:20,990 --> 00:11:24,470
little longer waiting for that data to

00:11:22,580 --> 00:11:26,750
become available and then it sends that

00:11:24,470 --> 00:11:28,490
data back in the response obviously if

00:11:26,750 --> 00:11:30,620
the data is taking forever to load it'll

00:11:28,490 --> 00:11:35,180
come back with an empty response

00:11:30,620 --> 00:11:37,700
anyway now obviously even with long

00:11:35,180 --> 00:11:40,160
polling the kind of applications that we

00:11:37,700 --> 00:11:41,570
are talking about say you know HQ lie HQ

00:11:40,160 --> 00:11:43,460
style applications where you have the

00:11:41,570 --> 00:11:45,470
live quizzes you know location tracking

00:11:43,460 --> 00:11:47,840
that your uber application does for you

00:11:45,470 --> 00:11:49,790
or any kind of like live or real-time

00:11:47,840 --> 00:11:50,900
kind of applications long polling is

00:11:49,790 --> 00:11:52,850
still not the answer you're still

00:11:50,900 --> 00:11:54,710
repeating requests and response cycles

00:11:52,850 --> 00:11:56,480
all the time and if when you're doing it

00:11:54,710 --> 00:11:58,790
at high frequency you can considerably

00:11:56,480 --> 00:12:00,560
see the latency being added to your

00:11:58,790 --> 00:12:03,320
application and most of these real-time

00:12:00,560 --> 00:12:05,660
applications can only you know offered a

00:12:03,320 --> 00:12:07,700
couple of hundred milliseconds worth of

00:12:05,660 --> 00:12:10,880
delay so this is only worsening the

00:12:07,700 --> 00:12:12,800
situation so a new web standard which

00:12:10,880 --> 00:12:14,240
which could you know almost let the

00:12:12,800 --> 00:12:15,920
server somehow initiate the

00:12:14,240 --> 00:12:17,690
communication was required some sort of

00:12:15,920 --> 00:12:19,970
may be bi-directional consistent

00:12:17,690 --> 00:12:23,450
connection that kind of a protocol was

00:12:19,970 --> 00:12:25,490
required enter WebSockets so halfway

00:12:23,450 --> 00:12:29,150
through 2008 WebSockets emerged as an

00:12:25,490 --> 00:12:31,250
idea where which you know by 2011 may

00:12:29,150 --> 00:12:34,280
most of the major browser vendors would

00:12:31,250 --> 00:12:36,320
support but obviously HTTP has been

00:12:34,280 --> 00:12:38,960
around as a standard since the time web

00:12:36,320 --> 00:12:40,490
came about right and if you're if you're

00:12:38,960 --> 00:12:42,860
coming up with this new protocol

00:12:40,490 --> 00:12:44,330
suddenly you can't really expect all of

00:12:42,860 --> 00:12:45,830
the entities that are communicating over

00:12:44,330 --> 00:12:47,870
the Internet to support this new

00:12:45,830 --> 00:12:50,360
protocol so how WebSockets works or

00:12:47,870 --> 00:12:52,160
works is initially it starts off as a

00:12:50,360 --> 00:12:54,080
HTTP request response cycle so you're

00:12:52,160 --> 00:12:56,120
sure everyone knows what you're talking

00:12:54,080 --> 00:12:58,460
about but the only difference being in

00:12:56,120 --> 00:13:00,620
the header information of the request of

00:12:58,460 --> 00:13:02,270
the HTTP request you include in a

00:13:00,620 --> 00:13:04,880
McGrane header which basically means

00:13:02,270 --> 00:13:06,680
that you're asking the other endpoint to

00:13:04,880 --> 00:13:08,720
upgrade the connection to WebSockets and

00:13:06,680 --> 00:13:12,290
if the other endpoint is compliant with

00:13:08,720 --> 00:13:13,940
that protocol the the communication

00:13:12,290 --> 00:13:15,680
would be upgraded to WebSockets which

00:13:13,940 --> 00:13:17,570
means it opens up a full duplex and

00:13:15,680 --> 00:13:19,340
persistent connection full duplex

00:13:17,570 --> 00:13:21,440
meaning now you have both

00:13:19,340 --> 00:13:22,540
your endpoints they're able to

00:13:21,440 --> 00:13:25,610
communicate with each other

00:13:22,540 --> 00:13:27,170
simultaneously in both the directions so

00:13:25,610 --> 00:13:28,910
if you think about it the Bitcoin

00:13:27,170 --> 00:13:31,070
example that we saw the server was the

00:13:28,910 --> 00:13:33,020
entity that actually had access to the

00:13:31,070 --> 00:13:34,700
data that the client was interested in

00:13:33,020 --> 00:13:36,260
but it had no way to initiate a

00:13:34,700 --> 00:13:38,450
communication it had no way to tell the

00:13:36,260 --> 00:13:40,760
client hey I have the data that you need

00:13:38,450 --> 00:13:43,250
it had to wait for the client to request

00:13:40,760 --> 00:13:45,529
for that data only then it could send

00:13:43,250 --> 00:13:47,600
that data as a response but with this it

00:13:45,529 --> 00:13:49,670
has basically there's an open Avenue and

00:13:47,600 --> 00:13:51,560
both of the endpoints can communicate

00:13:49,670 --> 00:13:53,480
with each other anytime they want and

00:13:51,560 --> 00:13:56,000
also the connection is persistent

00:13:53,480 --> 00:13:57,950
meaning it is kept it is started and

00:13:56,000 --> 00:13:59,450
kept open for as long as the application

00:13:57,950 --> 00:14:00,770
is running which could be even

00:13:59,450 --> 00:14:03,320
indefinite for that and for some

00:14:00,770 --> 00:14:05,060
applications so if we now look at

00:14:03,320 --> 00:14:07,610
another example which is the same

00:14:05,060 --> 00:14:09,589
Bitcoin pricing but which implements

00:14:07,610 --> 00:14:12,050
WebSockets under the hood and hopefully

00:14:09,589 --> 00:14:13,730
while and speaking the the price in real

00:14:12,050 --> 00:14:20,270
life updates so you can actually see

00:14:13,730 --> 00:14:22,550
that change well it's not anyway so

00:14:20,270 --> 00:14:24,560
basically what's gonna what was what is

00:14:22,550 --> 00:14:27,830
supposed to happen is if in real life

00:14:24,560 --> 00:14:32,180
the website or the sorry the Bitcoin

00:14:27,830 --> 00:14:34,550
pricing changes it should reflect that

00:14:32,180 --> 00:14:36,710
in the webpage without me needing to

00:14:34,550 --> 00:14:38,930
interact with it in any way whatsoever I

00:14:36,710 --> 00:14:40,610
don't have to refresh the page I don't

00:14:38,930 --> 00:14:42,680
have to you know do any sort of like

00:14:40,610 --> 00:14:49,400
async electric requests within the page

00:14:42,680 --> 00:14:51,530
etc anyway so because WebSockets is

00:14:49,400 --> 00:14:53,060
another communication protocol

00:14:51,530 --> 00:14:56,120
application communication protocol it's

00:14:53,060 --> 00:14:59,500
resides alongside HTTP on the

00:14:56,120 --> 00:15:02,900
application layer in the layer 7 itself

00:14:59,500 --> 00:15:04,760
now WebSockets is not the only real-time

00:15:02,900 --> 00:15:06,350
protocol that you would be needing for

00:15:04,760 --> 00:15:07,700
sort of live or event-driven

00:15:06,350 --> 00:15:10,010
applications there are a lot of other

00:15:07,700 --> 00:15:11,990
you know protocols like we would have

00:15:10,010 --> 00:15:14,570
heard of mqtt which is sort of a

00:15:11,990 --> 00:15:16,610
lightweight equivalent of WebSockets but

00:15:14,570 --> 00:15:19,850
it is because it is lightweight it is

00:15:16,610 --> 00:15:22,459
really more suited for IOT devices or

00:15:19,850 --> 00:15:24,650
battery constrained sensors etc there's

00:15:22,459 --> 00:15:27,560
also concept of service and events where

00:15:24,650 --> 00:15:29,209
you have the server being able to

00:15:27,560 --> 00:15:30,709
communicate directly or push data

00:15:29,209 --> 00:15:31,730
directly to the clients but it's not

00:15:30,709 --> 00:15:35,720
really by desire

00:15:31,730 --> 00:15:37,309
as opposed to WebSockets so what even

00:15:35,720 --> 00:15:38,829
though you have all these kinds of

00:15:37,309 --> 00:15:42,410
protocols available to be used

00:15:38,829 --> 00:15:44,449
WebSockets really majorly covers you

00:15:42,410 --> 00:15:46,779
know maximum number of use cases that

00:15:44,449 --> 00:15:49,399
come when you think about the real time

00:15:46,779 --> 00:15:51,470
world of the real time scenario but

00:15:49,399 --> 00:15:53,179
which protocol that you as a developer

00:15:51,470 --> 00:15:55,549
would use to implement in your

00:15:53,179 --> 00:15:57,139
applications really depends on I mean

00:15:55,549 --> 00:15:58,519
evidently it depends on the kind of

00:15:57,139 --> 00:16:01,069
application you're building if you're

00:15:58,519 --> 00:16:03,079
building something on IOT you would want

00:16:01,069 --> 00:16:04,519
to use mqtt if there's a graph that you

00:16:03,079 --> 00:16:06,679
want to show on a webpage which is

00:16:04,519 --> 00:16:08,179
updating in a live manner due to some

00:16:06,679 --> 00:16:10,369
data changing you would use WebSockets

00:16:08,179 --> 00:16:15,410
so it's all dependent on the use case

00:16:10,369 --> 00:16:18,019
that you have so obviously as everyone

00:16:15,410 --> 00:16:19,850
before me has been mentioning as well we

00:16:18,019 --> 00:16:21,919
as developers do not want to build

00:16:19,850 --> 00:16:24,799
everything from scratch and reinventing

00:16:21,919 --> 00:16:26,749
the wheel is really not useful so unless

00:16:24,799 --> 00:16:28,249
you're wanting to know how WebSockets

00:16:26,749 --> 00:16:30,019
you just like you know trying out

00:16:28,249 --> 00:16:31,249
WebSockets and wanting to know how this

00:16:30,019 --> 00:16:33,919
works from scratch and you know

00:16:31,249 --> 00:16:35,540
basically testing it out or trying it

00:16:33,919 --> 00:16:37,789
out there's no point in implementing

00:16:35,540 --> 00:16:40,339
WebSockets from scratch your best bet if

00:16:37,789 --> 00:16:42,019
you want to you know add real time

00:16:40,339 --> 00:16:43,759
functionality in your applications is

00:16:42,019 --> 00:16:45,199
you could spin up some open-source

00:16:43,759 --> 00:16:47,169
servers and there are so many options

00:16:45,199 --> 00:16:49,730
available in different kinds of

00:16:47,169 --> 00:16:51,949
languages different frameworks etc that

00:16:49,730 --> 00:16:53,480
you could use socket IO is obviously one

00:16:51,949 --> 00:16:56,449
of the most popular ones and I'm a

00:16:53,480 --> 00:16:58,039
couple of you may have used or used it

00:16:56,449 --> 00:17:00,199
as well it is very convenient and easy

00:16:58,039 --> 00:17:02,600
to use in one of the hobby projects that

00:17:00,199 --> 00:17:04,819
you're building but what happens when

00:17:02,600 --> 00:17:06,169
you have you've implemented the basic

00:17:04,819 --> 00:17:09,589
WebSockets or the real time

00:17:06,169 --> 00:17:11,750
functionality and now are wanting to put

00:17:09,589 --> 00:17:13,250
that application in production there are

00:17:11,750 --> 00:17:15,799
a lot of different you know

00:17:13,250 --> 00:17:17,899
functionality bits that are crucial for

00:17:15,799 --> 00:17:21,169
a live or a real-time application to

00:17:17,899 --> 00:17:22,579
work properly at scale which is not just

00:17:21,169 --> 00:17:24,500
solved by a basic WebSocket

00:17:22,579 --> 00:17:26,000
implementation let's look at it by going

00:17:24,500 --> 00:17:28,039
back to the you know evolution graph

00:17:26,000 --> 00:17:30,799
that we had so websites then we're using

00:17:28,039 --> 00:17:32,720
predominantly HTTP they were working

00:17:30,799 --> 00:17:35,659
with rest and CDN solved a lot of you

00:17:32,720 --> 00:17:35,990
know complexity myths and we looked at

00:17:35,659 --> 00:17:38,710
that

00:17:35,990 --> 00:17:40,970
but now web saw the websites or

00:17:38,710 --> 00:17:44,360
applications mobile applications any

00:17:40,970 --> 00:17:44,970
kind of entities would like to be real

00:17:44,360 --> 00:17:46,380
time

00:17:44,970 --> 00:17:47,730
so they're able to communicate with

00:17:46,380 --> 00:17:49,830
other entities over the internet in

00:17:47,730 --> 00:17:51,000
real-time so then they ask their

00:17:49,830 --> 00:17:52,560
engineering teams to build this

00:17:51,000 --> 00:17:54,450
real-time infrastructure which could be

00:17:52,560 --> 00:17:56,640
using one of the open-source tools that

00:17:54,450 --> 00:17:58,260
I just shown but then what happens with

00:17:56,640 --> 00:18:00,390
real-time is you need to implement

00:17:58,260 --> 00:18:02,490
something called fan-out which is you

00:18:00,390 --> 00:18:04,380
know analog is to caching for rest but

00:18:02,490 --> 00:18:06,360
it is really different because with

00:18:04,380 --> 00:18:09,000
caching you have the data you store it

00:18:06,360 --> 00:18:10,560
at some you know intermediate point and

00:18:09,000 --> 00:18:12,510
whenever someone's requesting for that

00:18:10,560 --> 00:18:14,370
they tell you just give it from there

00:18:12,510 --> 00:18:16,500
without disturbing the server but with

00:18:14,370 --> 00:18:18,660
real-time everything happens then in

00:18:16,500 --> 00:18:21,330
there within that millisecond right so

00:18:18,660 --> 00:18:25,410
say I am a publisher and I'm publishing

00:18:21,330 --> 00:18:27,660
some data and that's it I shouldn't be

00:18:25,410 --> 00:18:29,910
worried about the number of people that

00:18:27,660 --> 00:18:31,350
are consuming that data so it should be

00:18:29,910 --> 00:18:33,450
really like a decoupled

00:18:31,350 --> 00:18:35,070
sort of architecture when you think

00:18:33,450 --> 00:18:38,610
about real-time applications and that's

00:18:35,070 --> 00:18:40,200
how it will essentially work without any

00:18:38,610 --> 00:18:42,810
failure so fan-out is basically when I

00:18:40,200 --> 00:18:43,980
publish it is that particular you know

00:18:42,810 --> 00:18:45,630
in a couple of milliseconds it is

00:18:43,980 --> 00:18:47,610
literally duplicated and fanned out to

00:18:45,630 --> 00:18:49,350
all of the subscribers or all of the

00:18:47,610 --> 00:18:50,850
people who want to consume that data and

00:18:49,350 --> 00:18:53,280
then with that obviously comes a

00:18:50,850 --> 00:18:56,400
question of scalability in real time

00:18:53,280 --> 00:18:58,950
architecture it's really you know spiked

00:18:56,400 --> 00:19:00,960
based scalability in one second you may

00:18:58,950 --> 00:19:03,450
have no clients connected at all no

00:19:00,960 --> 00:19:05,130
message is being consumed in say in the

00:19:03,450 --> 00:19:07,560
next couple of seconds you may have like

00:19:05,130 --> 00:19:09,390
a thousand consumers or even a million

00:19:07,560 --> 00:19:10,830
consumers connecting and listening to

00:19:09,390 --> 00:19:13,440
your messages consuming to your messages

00:19:10,830 --> 00:19:15,960
so the the scale changes at such high

00:19:13,440 --> 00:19:18,030
speeds and you can't even afford any

00:19:15,960 --> 00:19:19,710
latency in changing the scale as well

00:19:18,030 --> 00:19:21,690
because then it will affect your whole

00:19:19,710 --> 00:19:23,690
real-time application which is the whole

00:19:21,690 --> 00:19:25,050
point of building it with the least

00:19:23,690 --> 00:19:27,000
latency right

00:19:25,050 --> 00:19:29,130
so that sort of becomes really complex

00:19:27,000 --> 00:19:31,170
to implement now obviously while all

00:19:29,130 --> 00:19:33,450
this was happening in every company that

00:19:31,170 --> 00:19:35,520
wanted to you know incorporate real-time

00:19:33,450 --> 00:19:37,650
or live functionality was building these

00:19:35,520 --> 00:19:39,180
sort of functionality layers on top of

00:19:37,650 --> 00:19:41,610
there you know

00:19:39,180 --> 00:19:43,590
initial architecture some companies

00:19:41,610 --> 00:19:45,360
looked at it and said it's the same

00:19:43,590 --> 00:19:47,010
thing that was happening with CD ends

00:19:45,360 --> 00:19:48,900
that's repeating where we could just

00:19:47,010 --> 00:19:52,440
separate these functionality out and

00:19:48,900 --> 00:19:54,450
provide it as a service so anyone so

00:19:52,440 --> 00:19:54,900
multiple companies can now use this

00:19:54,450 --> 00:19:56,910
service

00:19:54,900 --> 00:19:58,650
the single implementation of all this

00:19:56,910 --> 00:20:00,750
functionality so if not everyone

00:19:58,650 --> 00:20:03,270
goes about milling it from scratch now

00:20:00,750 --> 00:20:05,730
that then came the concept of DSN or

00:20:03,270 --> 00:20:09,990
data stream network which allowed you to

00:20:05,730 --> 00:20:11,760
do this basically data stream network is

00:20:09,990 --> 00:20:14,450
a fairly new concept so if you wanna

00:20:11,760 --> 00:20:17,040
like visualize this it's sort of

00:20:14,450 --> 00:20:18,840
something like an abstraction of a

00:20:17,040 --> 00:20:20,220
distributed systems network because

00:20:18,840 --> 00:20:22,860
obviously you would need a distributed

00:20:20,220 --> 00:20:24,450
system to make sure there's this Caleb

00:20:22,860 --> 00:20:26,250
the kind of scalability that is required

00:20:24,450 --> 00:20:28,470
that is available and the kind of fault

00:20:26,250 --> 00:20:31,020
tolerance and you know a smart rerouting

00:20:28,470 --> 00:20:33,000
of your data that you require for

00:20:31,020 --> 00:20:34,830
real-time applications to work in with

00:20:33,000 --> 00:20:36,810
minimal latency now all of this

00:20:34,830 --> 00:20:39,270
distributed systems architecture in is

00:20:36,810 --> 00:20:42,510
encapsulated and put into like the

00:20:39,270 --> 00:20:44,280
circle which is called DSN to which all

00:20:42,510 --> 00:20:46,320
of your different endpoints front-end

00:20:44,280 --> 00:20:47,850
application servers database anything

00:20:46,320 --> 00:20:49,770
can connect to in sort of a

00:20:47,850 --> 00:20:51,990
plug-and-play fashion which are

00:20:49,770 --> 00:20:53,730
completely decoupled so if my truck is

00:20:51,990 --> 00:20:55,710
connecting to share its location data

00:20:53,730 --> 00:20:57,750
any of the other entities that are

00:20:55,710 --> 00:20:59,940
connecting the truck is not affected by

00:20:57,750 --> 00:21:02,100
it it's all handled by the data stream

00:20:59,940 --> 00:21:03,150
network and that's how you know you

00:21:02,100 --> 00:21:05,220
don't have to deal with all of the

00:21:03,150 --> 00:21:07,350
complexity but if you want to

00:21:05,220 --> 00:21:11,580
incorporate real time in your

00:21:07,350 --> 00:21:14,000
applications now a lot of I think

00:21:11,580 --> 00:21:17,370
majority of the real-time applications

00:21:14,000 --> 00:21:19,050
work with this particular messaging

00:21:17,370 --> 00:21:20,400
architecture called pub/sub or

00:21:19,050 --> 00:21:22,440
publish/subscribe that you would have

00:21:20,400 --> 00:21:24,390
heard of basically what happens here is

00:21:22,440 --> 00:21:26,520
all of the data that is happening that

00:21:24,390 --> 00:21:30,720
is you know moving across in a real-time

00:21:26,520 --> 00:21:32,730
application is is organized in two

00:21:30,720 --> 00:21:34,800
logical units called channels or topics

00:21:32,730 --> 00:21:36,300
and you have the concept of publishers

00:21:34,800 --> 00:21:38,310
who are generating the data and

00:21:36,300 --> 00:21:40,650
publishing data onto one or more of

00:21:38,310 --> 00:21:42,720
these channels and subscribers who are

00:21:40,650 --> 00:21:44,760
consumers of this data and who may be

00:21:42,720 --> 00:21:46,560
you know attaching to one of one or more

00:21:44,760 --> 00:21:48,930
of these channels to consume that kind

00:21:46,560 --> 00:21:50,550
of data and as I said these publishers

00:21:48,930 --> 00:21:52,620
or subscribers are completely decoupled

00:21:50,550 --> 00:21:54,750
and they don't have to worry about any

00:21:52,620 --> 00:21:56,670
of the complexity that comes with

00:21:54,750 --> 00:21:59,100
real-time architecture so let's actually

00:21:56,670 --> 00:22:01,860
have a look at how this happens in

00:21:59,100 --> 00:22:04,920
practice so we know we understand it in

00:22:01,860 --> 00:22:07,560
a better way if possibly if your

00:22:04,920 --> 00:22:10,830
internet is working you could maybe and

00:22:07,560 --> 00:22:12,030
if my internet is working yes so if you

00:22:10,830 --> 00:22:13,800
if you have via mobile

00:22:12,030 --> 00:22:17,190
mobile phones and if your internet is

00:22:13,800 --> 00:22:19,380
working you can go to that URL and try

00:22:17,190 --> 00:22:21,660
and comment something just so we see

00:22:19,380 --> 00:22:23,880
what's gonna happen with the kind of

00:22:21,660 --> 00:22:26,520
pub/sub architecture I've been talking

00:22:23,880 --> 00:22:31,980
about it's go dot a blue dot IO /

00:22:26,520 --> 00:22:39,990
comment I'm gonna wait for a couple of

00:22:31,980 --> 00:22:42,690
seconds great Oprah Winfrey says ran

00:22:39,990 --> 00:22:45,780
can't code anyway so what's happening

00:22:42,690 --> 00:22:48,750
here if you see is I've implemented I've

00:22:45,780 --> 00:22:50,790
used a data stream network in this case

00:22:48,750 --> 00:22:53,250
I have used a Blee which is the data

00:22:50,790 --> 00:22:54,990
stream network provider as well - you

00:22:53,250 --> 00:22:57,180
know incorporate this live functionality

00:22:54,990 --> 00:22:59,970
where I'm connected to all of the people

00:22:57,180 --> 00:23:01,920
who are connected in real time so as you

00:22:59,970 --> 00:23:04,950
can see here I have a channel called

00:23:01,920 --> 00:23:07,050
Commons and basically I have subscribed

00:23:04,950 --> 00:23:08,940
to that Commons channel and displaying

00:23:07,050 --> 00:23:12,870
whatever is coming on that channel in

00:23:08,940 --> 00:23:15,000
this text box that I have and the same

00:23:12,870 --> 00:23:17,220
thing I'm doing here where whenever you

00:23:15,000 --> 00:23:19,110
pick you know hit the post button I'm

00:23:17,220 --> 00:23:22,080
attaching to the same channel and then

00:23:19,110 --> 00:23:23,280
publishing my data to that channel so as

00:23:22,080 --> 00:23:24,780
you can see in this particular

00:23:23,280 --> 00:23:27,390
application the publisher and subscriber

00:23:24,780 --> 00:23:30,570
are both this application but it's not

00:23:27,390 --> 00:23:32,670
necessary to be so it can be completely

00:23:30,570 --> 00:23:34,890
like you know I can have one application

00:23:32,670 --> 00:23:36,810
which is only subscribing I can have one

00:23:34,890 --> 00:23:40,080
application which is only publishing or

00:23:36,810 --> 00:23:42,090
both however or whichever way you like

00:23:40,080 --> 00:23:46,290
it I really hope they have pasta for

00:23:42,090 --> 00:23:49,380
lunch I like it - anyway getting back to

00:23:46,290 --> 00:23:50,820
the presentation one more way of you

00:23:49,380 --> 00:23:54,030
know thinking about pub/sub is kind of

00:23:50,820 --> 00:23:55,650
like subscribing to magazines you tell

00:23:54,030 --> 00:23:57,660
the subscriber or like the magazine

00:23:55,650 --> 00:23:59,910
provider ones that you are interested in

00:23:57,660 --> 00:24:01,590
getting this magazine well not this

00:23:59,910 --> 00:24:03,060
particular magazine but maybe whatever

00:24:01,590 --> 00:24:05,100
magazine that you're interested in and

00:24:03,060 --> 00:24:07,020
that is delivered to you as soon as it

00:24:05,100 --> 00:24:09,030
is available as soon as a new issue is

00:24:07,020 --> 00:24:11,100
available without you needing to go to

00:24:09,030 --> 00:24:14,280
the shop again and again or you know

00:24:11,100 --> 00:24:17,430
asking the publisher or whoever gives

00:24:14,280 --> 00:24:19,470
the magazines again and again right so

00:24:17,430 --> 00:24:21,750
coming back to the evolution of the

00:24:19,470 --> 00:24:23,220
online data sharing economy now this is

00:24:21,750 --> 00:24:25,410
the point where we are at currently

00:24:23,220 --> 00:24:25,770
where we're able to communicate in real

00:24:25,410 --> 00:24:28,200
time

00:24:25,770 --> 00:24:30,240
and we're able to react to the changes

00:24:28,200 --> 00:24:32,370
that are happening in the real world but

00:24:30,240 --> 00:24:34,100
while all of this was happening as you

00:24:32,370 --> 00:24:36,300
can remember a lot of the companies

00:24:34,100 --> 00:24:38,490
realize that the data that they were

00:24:36,300 --> 00:24:41,550
producing was really really high value

00:24:38,490 --> 00:24:43,920
and they thought why not I mean until

00:24:41,550 --> 00:24:45,750
now until this point they were really

00:24:43,920 --> 00:24:48,900
creating applications out of the data

00:24:45,750 --> 00:24:51,510
they had and at one point they decided

00:24:48,900 --> 00:24:53,790
what if we programmatically shared our

00:24:51,510 --> 00:24:56,010
data with other programmers or companies

00:24:53,790 --> 00:24:58,380
so they could process it further and

00:24:56,010 --> 00:25:00,330
make some other amazing applications and

00:24:58,380 --> 00:25:02,340
what's in it for me well I'll charge for

00:25:00,330 --> 00:25:05,010
my data and that's that's the takeaway

00:25:02,340 --> 00:25:06,720
for me right and that with that came the

00:25:05,010 --> 00:25:10,110
advent of application programming

00:25:06,720 --> 00:25:12,030
interfaces or API is where two different

00:25:10,110 --> 00:25:14,280
developer teams or you know companies

00:25:12,030 --> 00:25:16,650
could communicate or could share their

00:25:14,280 --> 00:25:18,030
data programmatically for it to be used

00:25:16,650 --> 00:25:19,830
further on in different kind of

00:25:18,030 --> 00:25:22,050
applications a good way to think of it

00:25:19,830 --> 00:25:24,480
is maybe a company which is you know

00:25:22,050 --> 00:25:27,180
measuring the temperature data all the

00:25:24,480 --> 00:25:29,070
time until now maybe they had you know

00:25:27,180 --> 00:25:31,350
at until some point they had a website

00:25:29,070 --> 00:25:33,180
which when you open showed you the

00:25:31,350 --> 00:25:35,550
current temperature but then what if

00:25:33,180 --> 00:25:37,830
some other company came and said hey you

00:25:35,550 --> 00:25:39,210
know what your data is really nice and I

00:25:37,830 --> 00:25:41,880
would like to build an application for

00:25:39,210 --> 00:25:44,940
iPhone which shows people all kinds of

00:25:41,880 --> 00:25:47,010
like UI animations where you know if it

00:25:44,940 --> 00:25:48,330
is raining it shows it as raining etc

00:25:47,010 --> 00:25:50,400
and I would like to do it but I need

00:25:48,330 --> 00:25:52,620
your data and I can't really access it

00:25:50,400 --> 00:25:54,180
like an end user and that's how you

00:25:52,620 --> 00:25:56,160
would have an API and I'm sure like all

00:25:54,180 --> 00:25:59,310
of us have used API is at some point

00:25:56,160 --> 00:26:02,070
REST API is notice so if you go back to

00:25:59,310 --> 00:26:04,200
this when people realize this they

00:26:02,070 --> 00:26:06,390
obviously started building an API for

00:26:04,200 --> 00:26:08,820
the data that they were providing but

00:26:06,390 --> 00:26:10,950
with however it happens throughout the

00:26:08,820 --> 00:26:13,470
history even with REST API they soon

00:26:10,950 --> 00:26:14,250
started facing a lot of challenges with

00:26:13,470 --> 00:26:16,950
REST API

00:26:14,250 --> 00:26:19,170
analytics was important you have to you

00:26:16,950 --> 00:26:20,970
know really understand how each of these

00:26:19,170 --> 00:26:23,340
developer teams that were your clients

00:26:20,970 --> 00:26:25,170
now are utilizing your REST API s and

00:26:23,340 --> 00:26:27,150
because it is all programmatically done

00:26:25,170 --> 00:26:28,650
you need to implement analytics

00:26:27,150 --> 00:26:30,120
programmatically as well so you have

00:26:28,650 --> 00:26:31,770
different you know numbers being

00:26:30,120 --> 00:26:33,960
generated automatically so you can have

00:26:31,770 --> 00:26:35,460
a look then you have you have to

00:26:33,960 --> 00:26:37,200
implement rate limiting because you

00:26:35,460 --> 00:26:39,210
can't have one developer team hogging

00:26:37,200 --> 00:26:41,100
off all of your resources and

00:26:39,210 --> 00:26:43,200
not letting other other people or other

00:26:41,100 --> 00:26:46,080
developers to consume your API so late

00:26:43,200 --> 00:26:47,909
limiting is another important you know

00:26:46,080 --> 00:26:49,440
functionality to be implemented then

00:26:47,909 --> 00:26:51,149
there's access management obviously you

00:26:49,440 --> 00:26:54,510
have all of this data but you can't have

00:26:51,149 --> 00:26:56,610
all of your clients access the same set

00:26:54,510 --> 00:26:58,710
of data right you have different depth

00:26:56,610 --> 00:27:00,090
of you know security that you can allow

00:26:58,710 --> 00:27:01,500
with the different you know according to

00:27:00,090 --> 00:27:03,179
the commercial agreements you have so

00:27:01,500 --> 00:27:05,240
all this sort of like functionality bits

00:27:03,179 --> 00:27:08,399
were again being implemented by these

00:27:05,240 --> 00:27:10,020
you know engineering teams on top but if

00:27:08,399 --> 00:27:12,000
you again take a step back and think

00:27:10,020 --> 00:27:14,070
about it all the company wanted to do

00:27:12,000 --> 00:27:17,100
was make their data available as REST

00:27:14,070 --> 00:27:20,520
API so other developer teams can utilize

00:27:17,100 --> 00:27:22,770
that data to do anything with it so a

00:27:20,520 --> 00:27:24,720
couple of companies you know realize

00:27:22,770 --> 00:27:25,919
this trend happening and they said it's

00:27:24,720 --> 00:27:29,279
the same thing that has been happening

00:27:25,919 --> 00:27:31,200
let's do the same list I mean provide

00:27:29,279 --> 00:27:33,419
the same solution that was before which

00:27:31,200 --> 00:27:35,940
is to take off these layers of

00:27:33,419 --> 00:27:38,130
functionality put them in a service and

00:27:35,940 --> 00:27:41,700
they call this API management tools

00:27:38,130 --> 00:27:43,409
which I'm sure a lot of us have would

00:27:41,700 --> 00:27:44,820
have used as well which provide all of

00:27:43,409 --> 00:27:46,980
this functionality and it's not just

00:27:44,820 --> 00:27:48,630
like these these are just like example

00:27:46,980 --> 00:27:50,880
functionalities which is really crucial

00:27:48,630 --> 00:27:53,490
but any kind of functionality that you

00:27:50,880 --> 00:27:55,770
must require when you know providing a

00:27:53,490 --> 00:27:58,110
REST API all of that is implemented once

00:27:55,770 --> 00:28:00,090
by a certain service provider which is

00:27:58,110 --> 00:28:02,309
providing an API management tool and

00:28:00,090 --> 00:28:05,039
then any number of companies can utilize

00:28:02,309 --> 00:28:06,840
that one implementation so you don't

00:28:05,039 --> 00:28:10,529
have to if not everyone has to implement

00:28:06,840 --> 00:28:12,600
from scratch right now all of this if

00:28:10,529 --> 00:28:15,870
you see this is where we're currently at

00:28:12,600 --> 00:28:17,880
now this is I think from CBN's to API

00:28:15,870 --> 00:28:20,340
management tools to DSN this is I think

00:28:17,880 --> 00:28:22,529
the current state of the data sharing

00:28:20,340 --> 00:28:25,289
economy is but if you think about it if

00:28:22,529 --> 00:28:27,179
you look at the history everyone kind of

00:28:25,289 --> 00:28:30,480
like follows through what has been

00:28:27,179 --> 00:28:32,549
happening right so obviously we had DSN

00:28:30,480 --> 00:28:35,730
which was real-time equivalent sort of

00:28:32,549 --> 00:28:37,590
equivalent of CD ends but there was a

00:28:35,730 --> 00:28:41,159
possibility now for the people

00:28:37,590 --> 00:28:43,230
generating real-time data to share that

00:28:41,159 --> 00:28:46,980
programmatically as well so people could

00:28:43,230 --> 00:28:48,840
generate you know can basically build

00:28:46,980 --> 00:28:50,820
applications on top of those streams you

00:28:48,840 --> 00:28:52,460
have the concepts of stream sharing

00:28:50,820 --> 00:28:54,080
using which you can share

00:28:52,460 --> 00:28:56,330
streams of data so basically essentially

00:28:54,080 --> 00:28:58,370
like real-time API Zoar real-time

00:28:56,330 --> 00:29:00,050
streams as such so then came real-time

00:28:58,370 --> 00:29:02,180
API is but then if you think about it

00:29:00,050 --> 00:29:04,580
obviously all those sorts of you know

00:29:02,180 --> 00:29:06,260
complexities came forward some of them

00:29:04,580 --> 00:29:08,420
were similar to REST API eyes but some

00:29:06,260 --> 00:29:10,670
of them would really require a

00:29:08,420 --> 00:29:12,320
completely different kind of solution so

00:29:10,670 --> 00:29:14,270
there is analytics to be implemented

00:29:12,320 --> 00:29:16,040
which is the same as that rate-limiting

00:29:14,270 --> 00:29:18,110
can be implemented which is really same

00:29:16,040 --> 00:29:19,610
as REST API but then there's the concept

00:29:18,110 --> 00:29:22,310
of adapters and protocol

00:29:19,610 --> 00:29:23,810
interoperability with REST API HTTP is

00:29:22,310 --> 00:29:25,820
predominantly pretty much the only

00:29:23,810 --> 00:29:27,860
protocol that anyone would be using

00:29:25,820 --> 00:29:29,720
right but with real time API as I said

00:29:27,860 --> 00:29:31,150
there are so many protocols that may

00:29:29,720 --> 00:29:34,160
need to communicate with each other

00:29:31,150 --> 00:29:36,170
sensor working with MQTT may need to

00:29:34,160 --> 00:29:37,970
communicate with a website working with

00:29:36,170 --> 00:29:40,100
WebSockets and all this has to happen

00:29:37,970 --> 00:29:42,710
with minimal latency in real time and

00:29:40,100 --> 00:29:45,500
also you have different kind of you know

00:29:42,710 --> 00:29:48,050
systems say I want to invoke an AWS

00:29:45,500 --> 00:29:50,120
lambda function when some real life

00:29:48,050 --> 00:29:52,160
event happens so I'm gonna I want that

00:29:50,120 --> 00:29:53,960
even trigger to trigger that function so

00:29:52,160 --> 00:29:55,160
you need to build adapters to plug into

00:29:53,960 --> 00:29:57,710
all of these different kinds of systems

00:29:55,160 --> 00:30:00,290
so this is really a complex challenge to

00:29:57,710 --> 00:30:02,210
solve and I think as a lot of people are

00:30:00,290 --> 00:30:03,770
a lot of businesses are realizing that

00:30:02,210 --> 00:30:06,260
they can provide their data streams

00:30:03,770 --> 00:30:07,430
there at this point is when they're

00:30:06,260 --> 00:30:09,860
realizing you know all of these

00:30:07,430 --> 00:30:11,270
complexes he's come forward obviously a

00:30:09,860 --> 00:30:13,790
couple of companies are already

00:30:11,270 --> 00:30:15,830
observing this trend and they they're

00:30:13,790 --> 00:30:18,320
saying ok let's provide this as the

00:30:15,830 --> 00:30:20,650
functionality implemented one so a lot

00:30:18,320 --> 00:30:22,520
of companies can you know work on it

00:30:20,650 --> 00:30:23,150
basically utilize this functionality

00:30:22,520 --> 00:30:24,470
together

00:30:23,150 --> 00:30:26,810
so they don't have to build everything

00:30:24,470 --> 00:30:29,240
from scratch I think that's sort of like

00:30:26,810 --> 00:30:30,980
this whole snapshot of where we were and

00:30:29,240 --> 00:30:33,920
where we are currently at but it it in

00:30:30,980 --> 00:30:35,330
no way says you know would HTTP become

00:30:33,920 --> 00:30:37,730
obsolete because we have all these new

00:30:35,330 --> 00:30:39,440
protocols now no because these are all

00:30:37,730 --> 00:30:40,490
for different kinds of use cases for

00:30:39,440 --> 00:30:42,320
different kinds of applications that

00:30:40,490 --> 00:30:43,940
you're building and the way you want to

00:30:42,320 --> 00:30:45,740
share your data with the other endpoints

00:30:43,940 --> 00:30:48,710
over the Internet if you think about the

00:30:45,740 --> 00:30:51,050
internet now it is full of you know data

00:30:48,710 --> 00:30:53,180
points moving around all the time and if

00:30:51,050 --> 00:30:55,220
you look at the statistics this data is

00:30:53,180 --> 00:30:57,560
only supposed to increase enormously I

00:30:55,220 --> 00:30:59,360
think at this point we really need to

00:30:57,560 --> 00:31:02,240
understand the options that we have to

00:30:59,360 --> 00:31:06,340
share this data online with anyone else

00:31:02,240 --> 00:31:06,340

YouTube URL: https://www.youtube.com/watch?v=0isukey1MYE


