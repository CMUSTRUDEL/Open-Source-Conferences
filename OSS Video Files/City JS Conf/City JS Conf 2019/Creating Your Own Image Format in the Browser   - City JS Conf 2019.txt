Title: Creating Your Own Image Format in the Browser   - City JS Conf 2019
Publication date: 2019-05-14
Playlist: City JS Conf 2019
Description: 
	Trent Willis

The web platform features I’ll cover in this talk (particularly Service Workers) are important topics in the JavaScript community for helping us build performant applications with great user experiences, but they also have some interesting characteristics that we can use to do things that previously weren’t possible in JavaScript.
This talk will encourage us to think about different ways we might be able to leverage these new features while giving a practical example with real code. So even if you are not interested in creating your own image format, you should walk away with some insights into the power and flexibility of the modern web platform.
_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,080
thank you everyone I'm really excited to

00:00:02,370 --> 00:00:05,370
be here with you all today I want to

00:00:04,080 --> 00:00:07,080
start this talk off by asking you all a

00:00:05,370 --> 00:00:11,250
question how many of you have heard of

00:00:07,080 --> 00:00:14,099
atwood's law before okay a surprisingly

00:00:11,250 --> 00:00:15,540
few number of you well I would love for

00:00:14,099 --> 00:00:17,550
those of you that are not familiar with

00:00:15,540 --> 00:00:19,529
it simply states that any application

00:00:17,550 --> 00:00:22,279
that can be written in JavaScript will

00:00:19,529 --> 00:00:26,250
eventually be written in JavaScript

00:00:22,279 --> 00:00:28,500
now when Jeff Atwood said this also

00:00:26,250 --> 00:00:30,029
known as coding horror online it was

00:00:28,500 --> 00:00:31,560
kind of just a funny observation this

00:00:30,029 --> 00:00:34,079
was like 11 years ago that he first

00:00:31,560 --> 00:00:36,390
wrote this but over the years since then

00:00:34,079 --> 00:00:38,399
it has become remarkably accurate right

00:00:36,390 --> 00:00:40,920
weeb right so many applications in

00:00:38,399 --> 00:00:42,120
JavaScript these days our chat

00:00:40,920 --> 00:00:45,239
applications are now written with

00:00:42,120 --> 00:00:47,280
JavaScript our music players and even

00:00:45,239 --> 00:00:49,500
our own development tools that we then

00:00:47,280 --> 00:00:51,930
write more JavaScript with in my opinion

00:00:49,500 --> 00:00:52,680
that's really fascinating but it's not

00:00:51,930 --> 00:00:54,449
just new things

00:00:52,680 --> 00:00:56,969
we can also recreate old-school

00:00:54,449 --> 00:00:59,820
applications like winamp and we can do

00:00:56,969 --> 00:01:04,019
this completely in the browser that's in

00:00:59,820 --> 00:01:05,909
my opinion really marvelous but beyond

00:01:04,019 --> 00:01:07,799
that we can even develop progressive web

00:01:05,909 --> 00:01:09,900
applications now they have native like

00:01:07,799 --> 00:01:13,350
application features such as push

00:01:09,900 --> 00:01:15,450
notifications and offline content but we

00:01:13,350 --> 00:01:17,850
can go even beyond just applications

00:01:15,450 --> 00:01:20,340
themselves and develop runtimes for

00:01:17,850 --> 00:01:22,710
other languages like Java or Ruby in

00:01:20,340 --> 00:01:23,970
JavaScript now I don't know why you

00:01:22,710 --> 00:01:25,710
would actually want to do this I'll do

00:01:23,970 --> 00:01:27,540
the notice a cool experiment but it's

00:01:25,710 --> 00:01:29,130
really awesome it's astounding in my

00:01:27,540 --> 00:01:29,520
opinion what JavaScript can do these

00:01:29,130 --> 00:01:31,680
days

00:01:29,520 --> 00:01:33,900
and that's kind of at the heart of what

00:01:31,680 --> 00:01:36,360
I want to talk about today and it's

00:01:33,900 --> 00:01:39,299
represented by this picture of the

00:01:36,360 --> 00:01:41,009
Magnificent idris elba I'm a huge fan of

00:01:39,299 --> 00:01:42,540
his and I love the show Luthor but

00:01:41,009 --> 00:01:44,250
really what I want you to focus on is

00:01:42,540 --> 00:01:46,979
actually the fact that this image is

00:01:44,250 --> 00:01:49,320
showing up in a web browser at all you

00:01:46,979 --> 00:01:51,060
see this image format is actually in a

00:01:49,320 --> 00:01:53,340
format that's been encrypted so it's not

00:01:51,060 --> 00:01:54,810
a normal PNG which means that by default

00:01:53,340 --> 00:01:58,290
the browser should not be able to

00:01:54,810 --> 00:02:00,240
display this in fact I will go so far as

00:01:58,290 --> 00:02:01,860
to say that if you loaded this up and

00:02:00,240 --> 00:02:04,020
pretty much any other browser other than

00:02:01,860 --> 00:02:05,520
in the application that I had coded you

00:02:04,020 --> 00:02:08,099
would just get an error and it would be

00:02:05,520 --> 00:02:09,750
very confusing and so what I want to

00:02:08,099 --> 00:02:12,060
talk about today is how we can create

00:02:09,750 --> 00:02:13,560
and serve our own custom image formats

00:02:12,060 --> 00:02:15,480
and deliver

00:02:13,560 --> 00:02:18,420
new experiences to users that feel like

00:02:15,480 --> 00:02:19,860
they're native to the browser and so

00:02:18,420 --> 00:02:21,239
well I think this topic is really cool

00:02:19,860 --> 00:02:23,489
in its own right it's going to serve us

00:02:21,239 --> 00:02:25,080
a platform for us to learn about some

00:02:23,489 --> 00:02:28,020
cool new web technologies that are

00:02:25,080 --> 00:02:30,599
available today Before we jump into all

00:02:28,020 --> 00:02:32,550
that though Who am I my name is Trent

00:02:30,599 --> 00:02:34,349
Willis I work at Netflix as a UI

00:02:32,550 --> 00:02:36,959
engineer but more importantly for the

00:02:34,349 --> 00:02:38,310
purposes of this talk today I'm just

00:02:36,959 --> 00:02:40,590
someone that really loves the web and I

00:02:38,310 --> 00:02:42,260
really love javascript mainly because I

00:02:40,590 --> 00:02:45,780
found a lot of freedom and creativity

00:02:42,260 --> 00:02:46,860
with those technologies and I think that

00:02:45,780 --> 00:02:49,380
there's a lot to be found there for

00:02:46,860 --> 00:02:51,030
others as well and what's really

00:02:49,380 --> 00:02:53,400
exciting to me about this particular

00:02:51,030 --> 00:02:55,319
moment in web development history that

00:02:53,400 --> 00:02:57,930
we find ourselves in is that JavaScript

00:02:55,319 --> 00:03:00,390
and the web platform are evolving pretty

00:02:57,930 --> 00:03:02,610
rapidly and that's what spurred this

00:03:00,390 --> 00:03:05,489
talk there's lots of cool stuff out

00:03:02,610 --> 00:03:07,380
there that we can experiment experiment

00:03:05,489 --> 00:03:08,940
with and I found a really interesting

00:03:07,380 --> 00:03:12,720
piece of information about a year ago

00:03:08,940 --> 00:03:14,670
and that is what led to this topic so

00:03:12,720 --> 00:03:16,560
what was that piece of information while

00:03:14,670 --> 00:03:18,359
I was looking at a specification from

00:03:16,560 --> 00:03:20,700
the web hypertext application technology

00:03:18,359 --> 00:03:23,820
working group better known by the

00:03:20,700 --> 00:03:25,230
abbreviation what Wiig and was reading

00:03:23,820 --> 00:03:28,230
their specification for their streams

00:03:25,230 --> 00:03:30,060
API which aims to provide a set of

00:03:28,230 --> 00:03:31,980
interfaces for the web platform to

00:03:30,060 --> 00:03:33,930
interact with streaming data this is

00:03:31,980 --> 00:03:36,450
similar to what is already in nodejs

00:03:33,930 --> 00:03:40,440
like we heard about earlier from Luciano

00:03:36,450 --> 00:03:42,389
but it's native to the web platform what

00:03:40,440 --> 00:03:43,799
was interesting to me though is that in

00:03:42,389 --> 00:03:46,709
reading the spec one of the use cases

00:03:43,799 --> 00:03:48,359
they identify is that if a stream is

00:03:46,709 --> 00:03:49,019
installed inside the fetch hook of a

00:03:48,359 --> 00:03:50,569
service worker

00:03:49,019 --> 00:03:53,250
this would allow developers to

00:03:50,569 --> 00:03:55,290
transparently polyfill new image formats

00:03:53,250 --> 00:03:57,540
and I got my thinking that's pretty

00:03:55,290 --> 00:03:59,850
awesome I had never considered using

00:03:57,540 --> 00:04:02,090
service workers for anything outside of

00:03:59,850 --> 00:04:04,500
normal progressive web app functionality

00:04:02,090 --> 00:04:06,239
and I got even more excited about this

00:04:04,500 --> 00:04:09,060
idea as I thought about how important

00:04:06,239 --> 00:04:14,400
images are for the web right from funny

00:04:09,060 --> 00:04:17,600
memes all the way up to photos of

00:04:14,400 --> 00:04:17,600
influential figures

00:04:18,159 --> 00:04:23,090
photos in my opinion are a really really

00:04:20,780 --> 00:04:24,470
important part of our web experience

00:04:23,090 --> 00:04:25,699
it's how we consume and relate to

00:04:24,470 --> 00:04:27,800
content a lot these days

00:04:25,699 --> 00:04:29,840
I would go so far as to say that without

00:04:27,800 --> 00:04:33,110
photos the web is almost kind of boring

00:04:29,840 --> 00:04:35,900
so wouldn't it be really awesome if we

00:04:33,110 --> 00:04:38,240
could experiment with them try out new

00:04:35,900 --> 00:04:39,979
image formats custom encodings that feel

00:04:38,240 --> 00:04:41,539
like they're native to the browser do

00:04:39,979 --> 00:04:44,330
things with images that we historically

00:04:41,539 --> 00:04:46,759
have not been able to I think so I think

00:04:44,330 --> 00:04:48,289
that's cool but being a pragmatic person

00:04:46,759 --> 00:04:49,940
I also tried to think of a way in which

00:04:48,289 --> 00:04:52,400
we could do this that would provide real

00:04:49,940 --> 00:04:54,199
value real benefits to our users and

00:04:52,400 --> 00:04:56,449
while I was thinking about all these

00:04:54,199 --> 00:04:58,159
ideas I came across another Web API that

00:04:56,449 --> 00:05:01,789
I was relatively unfamiliar with and

00:04:58,159 --> 00:05:04,069
that is the web crypto API which is a

00:05:01,789 --> 00:05:05,840
built-in module in the browser that

00:05:04,069 --> 00:05:08,090
defines methods to allow you to do

00:05:05,840 --> 00:05:11,210
things like encrypt and decrypt data and

00:05:08,090 --> 00:05:16,279
I thought to myself hey that gives me an

00:05:11,210 --> 00:05:18,469
idea it might not be a good idea but

00:05:16,279 --> 00:05:20,960
it's an idea and that is what if we

00:05:18,469 --> 00:05:23,690
combine both of those api's and built an

00:05:20,960 --> 00:05:25,340
encrypted image format in a privacy

00:05:23,690 --> 00:05:26,479
conscious world that seems like

00:05:25,340 --> 00:05:30,740
something that could provide real value

00:05:26,479 --> 00:05:33,529
to folks and I started thinking like

00:05:30,740 --> 00:05:35,839
okay this is cool let's let's do it what

00:05:33,529 --> 00:05:38,060
am I going to name it well I figured it

00:05:35,839 --> 00:05:39,050
should have crypto in the name and the

00:05:38,060 --> 00:05:40,099
first thing that comes to mind these

00:05:39,050 --> 00:05:40,759
days when I think of imagers is

00:05:40,099 --> 00:05:43,180
Instagram

00:05:40,759 --> 00:05:45,560
so I was like I'll name a cryptogram

00:05:43,180 --> 00:05:47,750
about ten minutes after that I decided

00:05:45,560 --> 00:05:49,490
though oh cryptogram already has another

00:05:47,750 --> 00:05:50,659
meaning but I had already created the

00:05:49,490 --> 00:05:54,020
repo and so that's what we're sticking

00:05:50,659 --> 00:05:55,129
with and so for the remainder of this

00:05:54,020 --> 00:05:57,440
talk we're going to talk about how

00:05:55,129 --> 00:05:59,830
exactly I built this implemented an

00:05:57,440 --> 00:06:02,690
encrypted image format in the browser

00:05:59,830 --> 00:06:03,860
before we jumped into the code though we

00:06:02,690 --> 00:06:05,839
need to think about what it is we're

00:06:03,860 --> 00:06:07,490
building we're going to start with an

00:06:05,839 --> 00:06:09,560
encrypted image this is going to

00:06:07,490 --> 00:06:12,949
basically just be a PNG that we ran

00:06:09,560 --> 00:06:14,419
through an encryption algorithm we want

00:06:12,949 --> 00:06:17,240
to be able to display that in the

00:06:14,419 --> 00:06:19,400
browser like any other images using a

00:06:17,240 --> 00:06:22,490
normal image element tag and simply

00:06:19,400 --> 00:06:24,289
specifying a source source path we know

00:06:22,490 --> 00:06:26,209
however that this won't work right now

00:06:24,289 --> 00:06:27,889
because browsers can only display image

00:06:26,209 --> 00:06:30,819
formats they have knowledge of like PNG

00:06:27,889 --> 00:06:34,729
s JPEGs or gay

00:06:30,819 --> 00:06:36,949
and so how do we get around this well we

00:06:34,729 --> 00:06:38,929
need a focus on what the problem is the

00:06:36,949 --> 00:06:40,309
problem is that by the time that data

00:06:38,929 --> 00:06:43,219
reaches the browser the browser doesn't

00:06:40,309 --> 00:06:44,839
know how to interpret that data and so

00:06:43,219 --> 00:06:47,899
we can work around this by using a

00:06:44,839 --> 00:06:50,719
service worker with a service worker

00:06:47,899 --> 00:06:52,580
many of us are probably aware that it's

00:06:50,719 --> 00:06:55,009
how we build progressive or offline web

00:06:52,580 --> 00:06:57,439
apps but what we may not think of them

00:06:55,009 --> 00:06:59,389
as is actually a proxy that kind of sits

00:06:57,439 --> 00:07:01,249
in between as a middleman between our

00:06:59,389 --> 00:07:03,770
applications and all the external

00:07:01,249 --> 00:07:05,360
resources were connecting to but when we

00:07:03,770 --> 00:07:07,539
think of them in this light it becomes a

00:07:05,360 --> 00:07:10,909
lot easier to understand how we might

00:07:07,539 --> 00:07:12,889
polyfill this functionality we need we

00:07:10,909 --> 00:07:14,629
do it by loading the encrypted image

00:07:12,889 --> 00:07:17,389
file and on its way back to the browser

00:07:14,629 --> 00:07:20,749
we transform it into a normal PNG file

00:07:17,389 --> 00:07:22,580
and so what we're going to do is we're

00:07:20,749 --> 00:07:24,979
going to get a dot e PNG and then

00:07:22,580 --> 00:07:26,149
convert it to a dot dot PNG and the

00:07:24,979 --> 00:07:28,999
browser will be none the wiser

00:07:26,149 --> 00:07:29,689
and it'll work hopefully that's the

00:07:28,999 --> 00:07:32,929
high-level idea

00:07:29,689 --> 00:07:34,639
so let's actually build it a note before

00:07:32,929 --> 00:07:36,110
I jump into the code here all of this

00:07:34,639 --> 00:07:37,879
code is going to be available online and

00:07:36,110 --> 00:07:39,139
there's going to be quite a bit of it so

00:07:37,879 --> 00:07:40,819
don't worry about taking thorough notes

00:07:39,139 --> 00:07:42,379
there'll be links out to demos where you

00:07:40,819 --> 00:07:45,110
can look at the source and read all the

00:07:42,379 --> 00:07:48,829
comments that I have in there so just

00:07:45,110 --> 00:07:50,389
buckle in and let's have some fun so to

00:07:48,829 --> 00:07:51,860
get started there are two api's we need

00:07:50,389 --> 00:07:54,139
to be familiar with in terms of service

00:07:51,860 --> 00:07:56,240
workers the first is known as a fetch

00:07:54,139 --> 00:07:57,740
event so the fetch of it is essentially

00:07:56,240 --> 00:07:59,569
at the heart of all service worker

00:07:57,740 --> 00:08:01,729
functionality it is an event that gets

00:07:59,569 --> 00:08:04,069
emitted to a service worker anytime an

00:08:01,729 --> 00:08:05,749
external request gets made on a page

00:08:04,069 --> 00:08:07,579
where that service worker is active so

00:08:05,749 --> 00:08:10,399
essentially if you have a service worker

00:08:07,579 --> 00:08:12,919
any time you make an xhr request a fetch

00:08:10,399 --> 00:08:15,079
request or the browser requests an image

00:08:12,919 --> 00:08:17,269
for an image tag or script for a script

00:08:15,079 --> 00:08:19,099
element you are going to get one of

00:08:17,269 --> 00:08:21,469
these events the event contains a lot of

00:08:19,099 --> 00:08:23,479
information most notably stuff about the

00:08:21,469 --> 00:08:26,269
request such as the URL that it's

00:08:23,479 --> 00:08:27,439
requesting now this by itself doesn't do

00:08:26,269 --> 00:08:29,449
a whole lot for us right we don't want

00:08:27,439 --> 00:08:30,860
to just know that the browser is making

00:08:29,449 --> 00:08:31,850
those requests we want to do something

00:08:30,860 --> 00:08:34,370
with them

00:08:31,850 --> 00:08:36,919
and so we need another method as part of

00:08:34,370 --> 00:08:38,990
this API and that is the respond whiff

00:08:36,919 --> 00:08:41,419
method that is actually on the fetch

00:08:38,990 --> 00:08:43,700
event object we get it allows you to

00:08:41,419 --> 00:08:45,290
take that event and say hey don't

00:08:43,700 --> 00:08:47,450
respond with that original value instead

00:08:45,290 --> 00:08:50,090
respond with this other value and this

00:08:47,450 --> 00:08:51,410
is how offline web apps work we say

00:08:50,090 --> 00:08:53,330
don't respond with the network request

00:08:51,410 --> 00:08:56,570
instead take this cache value I already

00:08:53,330 --> 00:08:58,220
have and respond with that instead so

00:08:56,570 --> 00:09:00,440
with knowledge of these two ie pies

00:08:58,220 --> 00:09:03,620
these two concepts let's write our first

00:09:00,440 --> 00:09:06,110
code we're going to start by registering

00:09:03,620 --> 00:09:07,910
a serviceworker for our application like

00:09:06,110 --> 00:09:09,320
so I like to be obvious with my naming

00:09:07,910 --> 00:09:12,230
so I just name the file serviceworker

00:09:09,320 --> 00:09:13,940
j/s and in that file we're going to

00:09:12,230 --> 00:09:16,700
define an event listener for fetch

00:09:13,940 --> 00:09:18,830
events now by default if we don't do

00:09:16,700 --> 00:09:20,270
anything with this event the browser

00:09:18,830 --> 00:09:21,620
will behave as normal and that's great

00:09:20,270 --> 00:09:25,010
that's what we want it to do for the

00:09:21,620 --> 00:09:26,870
vast majority of use cases but if we get

00:09:25,010 --> 00:09:28,790
a request that is for an encrypted image

00:09:26,870 --> 00:09:31,280
we want to do something else

00:09:28,790 --> 00:09:33,740
now you'll notice in this if statement I

00:09:31,280 --> 00:09:35,810
added a function is encrypted image

00:09:33,740 --> 00:09:37,310
request and that's because one I find it

00:09:35,810 --> 00:09:39,950
makes the code a lot more readable and

00:09:37,310 --> 00:09:42,260
easier to understand but then to these

00:09:39,950 --> 00:09:45,080
checks these conditions can get kind of

00:09:42,260 --> 00:09:46,040
complicated for requests in our case

00:09:45,080 --> 00:09:48,110
however we're going to keep it pretty

00:09:46,040 --> 00:09:49,970
simple we're going to simply check that

00:09:48,110 --> 00:09:52,760
if the request URL ends with the

00:09:49,970 --> 00:09:54,830
extension a PNG if it does then we're

00:09:52,760 --> 00:09:59,180
going to assume it is an encrypted image

00:09:54,830 --> 00:10:00,770
that we're loading and so if we have an

00:09:59,180 --> 00:10:03,110
encrypted image what do we want to do

00:10:00,770 --> 00:10:05,240
next well we want to take that fetch

00:10:03,110 --> 00:10:07,070
event and we want it to respond with a

00:10:05,240 --> 00:10:09,530
new PNG image that we're going to

00:10:07,070 --> 00:10:13,370
generate from that original encrypted

00:10:09,530 --> 00:10:14,930
image request now this is actually

00:10:13,370 --> 00:10:16,280
pretty much all of these serviceworker

00:10:14,930 --> 00:10:17,780
specific code that's in this talk

00:10:16,280 --> 00:10:19,460
everything else we're going to look at

00:10:17,780 --> 00:10:21,860
could be written in the main thread or

00:10:19,460 --> 00:10:23,870
in the serviceworker there's not a lot

00:10:21,860 --> 00:10:28,490
that you need to know in the realm of

00:10:23,870 --> 00:10:29,840
serviceworkers so how do we actually

00:10:28,490 --> 00:10:32,960
implement this function now how do we

00:10:29,840 --> 00:10:35,450
convert a PNG or get a PNG from an

00:10:32,960 --> 00:10:37,640
encrypted image well we need to do a

00:10:35,450 --> 00:10:40,460
couple things first we're going to fetch

00:10:37,640 --> 00:10:43,490
the data from our original request

00:10:40,460 --> 00:10:46,940
then we need to get that data from the

00:10:43,490 --> 00:10:48,380
request as an array buffer when dealing

00:10:46,940 --> 00:10:50,480
with images you often deal with either

00:10:48,380 --> 00:10:52,040
array buffers or arrays of integers

00:10:50,480 --> 00:10:54,920
because they provide for a better

00:10:52,040 --> 00:10:58,310
representation of the image data more so

00:10:54,920 --> 00:11:00,500
than objects or strings usually do and

00:10:58,310 --> 00:11:02,209
so once we have that data we are then

00:11:00,500 --> 00:11:05,060
going to run it through a decrypt

00:11:02,209 --> 00:11:07,610
function which will write in a moment we

00:11:05,060 --> 00:11:09,589
can then turn that decrypted data into a

00:11:07,610 --> 00:11:13,970
new data blob that we can use as a

00:11:09,589 --> 00:11:15,350
response and encode it as a PNG finally

00:11:13,970 --> 00:11:17,770
we construct that new response and

00:11:15,350 --> 00:11:19,820
return it to our respond width method

00:11:17,770 --> 00:11:21,290
now there's a good bit of interesting

00:11:19,820 --> 00:11:23,089
code here but we really want to focus on

00:11:21,290 --> 00:11:25,760
just these two lines because this is

00:11:23,089 --> 00:11:27,680
what actually happens functions as our

00:11:25,760 --> 00:11:30,320
encrypted image format our custom image

00:11:27,680 --> 00:11:32,180
format in fact if we were to change some

00:11:30,320 --> 00:11:34,510
of the variable names and add another

00:11:32,180 --> 00:11:37,190
parameter we actually get a generic

00:11:34,510 --> 00:11:39,500
pluggable way of defining a custom image

00:11:37,190 --> 00:11:42,230
transformation as long as you define a

00:11:39,500 --> 00:11:44,120
transform function that returns to you

00:11:42,230 --> 00:11:48,650
PNG data from the data that you get

00:11:44,120 --> 00:11:50,720
originally it should work so at this

00:11:48,650 --> 00:11:52,910
point let's try to test our code and

00:11:50,720 --> 00:11:57,140
we're going to get this a broken image

00:11:52,910 --> 00:11:58,790
but we also get an error which shows

00:11:57,140 --> 00:12:00,650
that our code is executing in the way we

00:11:58,790 --> 00:12:02,000
expect it to the only problem is is we

00:12:00,650 --> 00:12:04,279
don't have a decrypted data function

00:12:02,000 --> 00:12:06,860
implemented yet and so we're right on

00:12:04,279 --> 00:12:13,070
track everything is breaking just as we

00:12:06,860 --> 00:12:15,430
would expect it to so next we're going

00:12:13,070 --> 00:12:18,380
to implement that decrypt data function

00:12:15,430 --> 00:12:21,200
so we're going to use the web crypto API

00:12:18,380 --> 00:12:22,910
as I alluded to earlier it's at the core

00:12:21,200 --> 00:12:24,740
of the image format here and again there

00:12:22,910 --> 00:12:28,190
are two primary concepts that we need to

00:12:24,740 --> 00:12:30,380
understand about this API the first is

00:12:28,190 --> 00:12:32,209
what's known as the subtle crypto part

00:12:30,380 --> 00:12:33,800
of it and this is actually the namespace

00:12:32,209 --> 00:12:36,050
that you'll find it in in the web

00:12:33,800 --> 00:12:37,910
browser this API provides a set of

00:12:36,050 --> 00:12:39,890
cryptographic primitives for us to do

00:12:37,910 --> 00:12:42,079
things like encrypt and decrypt data but

00:12:39,890 --> 00:12:45,080
then also do things such as sign or

00:12:42,079 --> 00:12:47,660
verify the integrity of that data

00:12:45,080 --> 00:12:50,480
it's named subtle crypto to reflect the

00:12:47,660 --> 00:12:53,210
fact that many of the algorithms that it

00:12:50,480 --> 00:12:55,190
provides have subtle usage requirements

00:12:53,210 --> 00:12:58,190
in order to provide the required

00:12:55,190 --> 00:13:00,740
algorithmic security guarantees in other

00:12:58,190 --> 00:13:01,820
words cryptography in my opinion is very

00:13:00,740 --> 00:13:03,650
fascinating but it's also very

00:13:01,820 --> 00:13:05,660
complicated and if you're going to use

00:13:03,650 --> 00:13:07,940
it as an actual part of your security

00:13:05,660 --> 00:13:09,670
measures you need to understand all the

00:13:07,940 --> 00:13:12,320
implications that go along with it

00:13:09,670 --> 00:13:13,880
however for this talk we are more

00:13:12,320 --> 00:13:15,440
interested in the general concept so I'm

00:13:13,880 --> 00:13:17,570
not going to dive into that stuff too

00:13:15,440 --> 00:13:19,370
much but this is your warning to not

00:13:17,570 --> 00:13:21,380
just use these willy-nilly

00:13:19,370 --> 00:13:24,680
and actually have some sort of plan and

00:13:21,380 --> 00:13:26,090
understanding in place so the second API

00:13:24,680 --> 00:13:29,540
we need to understand as part of this is

00:13:26,090 --> 00:13:31,880
the crypto key a crypto key as you might

00:13:29,540 --> 00:13:35,240
guess represents a key used in all the

00:13:31,880 --> 00:13:36,860
crypto API methods every method requires

00:13:35,240 --> 00:13:38,630
a key because every method has a

00:13:36,860 --> 00:13:40,280
corresponding algorithm and without the

00:13:38,630 --> 00:13:43,520
keys the algorithms are not going to

00:13:40,280 --> 00:13:44,750
work the way you expect it to so with

00:13:43,520 --> 00:13:47,090
those two concepts in mind let's

00:13:44,750 --> 00:13:48,110
actually put this into our code if we go

00:13:47,090 --> 00:13:49,820
back to our function we're going to

00:13:48,110 --> 00:13:52,730
start implementing the decrypted data

00:13:49,820 --> 00:13:56,480
method here we're going to receive our

00:13:52,730 --> 00:13:58,700
encrypted data and then we need to get

00:13:56,480 --> 00:14:00,110
our crypto key for that data I'm not

00:13:58,700 --> 00:14:01,520
going to show how this function is

00:14:00,110 --> 00:14:03,140
implemented I'll leave that as an

00:14:01,520 --> 00:14:04,880
exercise for you all because it's not

00:14:03,140 --> 00:14:06,410
that interesting and short all you

00:14:04,880 --> 00:14:09,230
really need to know is that the key that

00:14:06,410 --> 00:14:11,060
you get needs to be the same key or part

00:14:09,230 --> 00:14:13,130
of the key pair that was used when the

00:14:11,060 --> 00:14:15,370
image was originally encrypted they're

00:14:13,130 --> 00:14:17,540
also not going to be able to decrypt it

00:14:15,370 --> 00:14:19,300
next we're going to define the

00:14:17,540 --> 00:14:22,340
decryption options that we want to use

00:14:19,300 --> 00:14:24,710
here we are using the AES algorithm in

00:14:22,340 --> 00:14:25,430
counter mode or CTR I'll talk more about

00:14:24,710 --> 00:14:27,200
that in a bit

00:14:25,430 --> 00:14:29,300
but for now just know that it requires

00:14:27,200 --> 00:14:31,070
two arguments a counter which is a UN to

00:14:29,300 --> 00:14:34,640
eight array and then a length which

00:14:31,070 --> 00:14:36,680
we're going to specify as 128 now with

00:14:34,640 --> 00:14:39,200
those options we can call the sub the

00:14:36,680 --> 00:14:41,720
crypto subtle dot decrypt method passes

00:14:39,200 --> 00:14:43,580
our algorithm auctions our crypto key

00:14:41,720 --> 00:14:45,290
and then our encrypted data and that's

00:14:43,580 --> 00:14:48,350
going to return to us a promise that

00:14:45,290 --> 00:14:50,720
will resolve with the decrypted data and

00:14:48,350 --> 00:14:53,720
that's pretty much it once we get that

00:14:50,720 --> 00:14:56,780
value returned to our respond with

00:14:53,720 --> 00:14:59,650
function we had earlier it should work

00:14:56,780 --> 00:15:03,020
so here's a quick demo of this in action

00:14:59,650 --> 00:15:04,550
we start with a broken image doesn't

00:15:03,020 --> 00:15:06,890
seem to be working this is because our

00:15:04,550 --> 00:15:11,060
service worker is not enabled but if we

00:15:06,890 --> 00:15:15,200
enable it and reload the page wallah it

00:15:11,060 --> 00:15:17,870
works you can find this demo online at

00:15:15,200 --> 00:15:18,980
cryptogram - naive glitch dummy and so I

00:15:17,870 --> 00:15:21,350
would encourage you to check it out at

00:15:18,980 --> 00:15:23,210
some point it has some interesting

00:15:21,350 --> 00:15:24,890
nuances that I didn't cover fully in

00:15:23,210 --> 00:15:26,780
this talk there are some things that I

00:15:24,890 --> 00:15:28,670
may have gone over kind of fast so it's

00:15:26,780 --> 00:15:31,400
worthwhile to kind of dig into it really

00:15:28,670 --> 00:15:32,570
understand it I looked at mdn quite a

00:15:31,400 --> 00:15:36,410
bit while I was putting this together

00:15:32,570 --> 00:15:38,780
the first time but we have that working

00:15:36,410 --> 00:15:41,000
but it's kind of a naive solution and I

00:15:38,780 --> 00:15:43,100
had mentioned streams earlier and we

00:15:41,000 --> 00:15:45,620
haven't done anything with those yet so

00:15:43,100 --> 00:15:46,970
let's focus on optimizing this push it a

00:15:45,620 --> 00:15:49,970
little bit further see what else the web

00:15:46,970 --> 00:15:52,790
platform can do for us we know that the

00:15:49,970 --> 00:15:54,700
three tenets of good software that are

00:15:52,790 --> 00:15:57,710
often cited are to first make it work

00:15:54,700 --> 00:16:00,140
then make it right and then finally make

00:15:57,710 --> 00:16:02,360
it fast at this point we know our

00:16:00,140 --> 00:16:05,930
polyfill is working and we know that it

00:16:02,360 --> 00:16:07,610
is producing the right results but how

00:16:05,930 --> 00:16:10,100
do we make it fast because it's not

00:16:07,610 --> 00:16:12,500
really that fast right now and the

00:16:10,100 --> 00:16:14,060
reason for that is is in order to

00:16:12,500 --> 00:16:17,150
decrypt any of this data we first have

00:16:14,060 --> 00:16:19,520
to download all of it for small images

00:16:17,150 --> 00:16:21,080
this is fine but for larger images if

00:16:19,520 --> 00:16:23,360
you have to download all the data first

00:16:21,080 --> 00:16:25,070
and then decrypt all of it that means

00:16:23,360 --> 00:16:27,350
you have to hold all of that image in

00:16:25,070 --> 00:16:29,540
memory twice while this process happens

00:16:27,350 --> 00:16:30,650
not to mention there's this huge period

00:16:29,540 --> 00:16:34,580
of time at the beginning where you're

00:16:30,650 --> 00:16:36,440
not doing any work and so this is

00:16:34,580 --> 00:16:38,030
effectively a form of batch processing

00:16:36,440 --> 00:16:39,530
because we wait for all the data to show

00:16:38,030 --> 00:16:43,460
up and then process it in one giant

00:16:39,530 --> 00:16:45,589
batch what could we do to make this

00:16:43,460 --> 00:16:47,630
better well as we might have learned

00:16:45,589 --> 00:16:50,030
earlier in the day we could use stream

00:16:47,630 --> 00:16:54,680
processing instead we can process the

00:16:50,030 --> 00:16:56,240
data as it arrives bit by bit now if you

00:16:54,680 --> 00:16:57,920
weren't here for the talk earlier or

00:16:56,240 --> 00:16:59,480
weren't paying that close of attention

00:16:57,920 --> 00:17:03,440
we're going to recap what that means

00:16:59,480 --> 00:17:05,630
real quick so like before we download

00:17:03,440 --> 00:17:06,890
the data but after we've downloaded a

00:17:05,630 --> 00:17:09,410
small chunk of it we can start to

00:17:06,890 --> 00:17:11,010
process that data and as that process is

00:17:09,410 --> 00:17:12,959
happening we can download more

00:17:11,010 --> 00:17:15,510
and then we simply repeat this process

00:17:12,959 --> 00:17:18,150
until everything is downloaded and all

00:17:15,510 --> 00:17:21,540
of the work has been done and the result

00:17:18,150 --> 00:17:23,069
is that much of the work that we used to

00:17:21,540 --> 00:17:24,660
have to do after we downloaded all the

00:17:23,069 --> 00:17:26,130
data we can now do while we're

00:17:24,660 --> 00:17:28,590
downloading the data and that should

00:17:26,130 --> 00:17:31,110
save us a good chunk of time and not to

00:17:28,590 --> 00:17:32,400
mention save us some memory now this

00:17:31,110 --> 00:17:35,040
won't be the same as not having to do

00:17:32,400 --> 00:17:36,720
any work obviously but it does provide

00:17:35,040 --> 00:17:39,809
and I speed up over the naive solution

00:17:36,720 --> 00:17:42,540
we had before so if that's the idea

00:17:39,809 --> 00:17:44,340
let's see how we would implement it if

00:17:42,540 --> 00:17:46,169
we jump back into our polyfill function

00:17:44,340 --> 00:17:50,130
we can start by changing a few of these

00:17:46,169 --> 00:17:51,840
lines so that instead of returning a PNG

00:17:50,130 --> 00:17:54,120
blob we're actually returning a PNG

00:17:51,840 --> 00:17:54,299
stream let's walk through this real

00:17:54,120 --> 00:17:56,070
quick

00:17:54,299 --> 00:17:58,650
we're going to start by fetching the

00:17:56,070 --> 00:18:00,570
image same as last time nothing's

00:17:58,650 --> 00:18:03,000
changed there and then we're going to

00:18:00,570 --> 00:18:05,580
construct a new transform stream with a

00:18:03,000 --> 00:18:08,750
decrypter object that will implement in

00:18:05,580 --> 00:18:11,370
a moment and then finally we'll call

00:18:08,750 --> 00:18:14,100
pipe through on the response body and

00:18:11,370 --> 00:18:16,169
pipe it through the transform stream now

00:18:14,100 --> 00:18:17,970
this might seem a little odd or esoteric

00:18:16,169 --> 00:18:22,740
to you but the body of a fetch request

00:18:17,970 --> 00:18:25,260
is actually a readable stream this is a

00:18:22,740 --> 00:18:26,910
relatively new addition but it's really

00:18:25,260 --> 00:18:28,320
powerful and what we're doing here is

00:18:26,910 --> 00:18:30,570
essentially saying hey take the response

00:18:28,320 --> 00:18:33,299
body and as all the data for it arrives

00:18:30,570 --> 00:18:35,490
get streamed down by your server run or

00:18:33,299 --> 00:18:37,919
pipe it through this transform method

00:18:35,490 --> 00:18:42,630
and so we get a new stream that

00:18:37,919 --> 00:18:44,490
represents that transform data and

00:18:42,630 --> 00:18:46,530
finally we want to construct a new

00:18:44,490 --> 00:18:49,620
response out of that stream and return

00:18:46,530 --> 00:18:52,260
that to our fetch event so that's the

00:18:49,620 --> 00:18:54,720
gist of what needs to happen and at a

00:18:52,260 --> 00:18:56,190
high level it's kind of readable but all

00:18:54,720 --> 00:18:57,540
this stuff about transform streams might

00:18:56,190 --> 00:18:59,100
be a little confusing because it's a

00:18:57,540 --> 00:19:01,020
very new specification to the browser

00:18:59,100 --> 00:19:04,170
and they actually work differently from

00:19:01,020 --> 00:19:06,810
how streams and nodejs work

00:19:04,170 --> 00:19:09,720
so the streams API still has two primary

00:19:06,810 --> 00:19:11,190
concepts like the node json' and that

00:19:09,720 --> 00:19:14,930
are and those are readable writable

00:19:11,190 --> 00:19:16,920
streams and readable streams as

00:19:14,930 --> 00:19:18,870
mentioned before writable streams

00:19:16,920 --> 00:19:21,000
obviously represent a stream of data

00:19:18,870 --> 00:19:22,920
that you can write to it's kind of your

00:19:21,000 --> 00:19:26,400
destination of where you are sending

00:19:22,920 --> 00:19:29,070
data readable streams are then streams

00:19:26,400 --> 00:19:32,820
of data that you read or access and get

00:19:29,070 --> 00:19:34,980
data out of and so a transform stream is

00:19:32,820 --> 00:19:37,620
just a combination of these two types of

00:19:34,980 --> 00:19:42,390
streams with a function sitting between

00:19:37,620 --> 00:19:43,950
them to transform the data and so you

00:19:42,390 --> 00:19:45,390
can actually construct a transformed

00:19:43,950 --> 00:19:47,760
stream in the browser using both of

00:19:45,390 --> 00:19:50,250
these types of streams and then adding

00:19:47,760 --> 00:19:52,800
some logic to wire them up this however

00:19:50,250 --> 00:19:55,950
is not very fun and it takes a lot of

00:19:52,800 --> 00:19:58,440
overhead and so the spec authors thought

00:19:55,950 --> 00:20:00,300
ahead and said we could provide a better

00:19:58,440 --> 00:20:01,530
abstraction for this and that takes

00:20:00,300 --> 00:20:03,180
place in the transform stream

00:20:01,530 --> 00:20:06,140
constructor and it's through an

00:20:03,180 --> 00:20:08,280
interface known as a transformer a

00:20:06,140 --> 00:20:11,460
transformer is an object that simply

00:20:08,280 --> 00:20:14,430
defines can optionally defined three

00:20:11,460 --> 00:20:17,880
methods those are start transform and

00:20:14,430 --> 00:20:21,000
flush the start method allows us to

00:20:17,880 --> 00:20:22,470
define some state or any pre work that

00:20:21,000 --> 00:20:25,590
we need to do before we start actually

00:20:22,470 --> 00:20:27,630
receiving data the transform method is

00:20:25,590 --> 00:20:30,240
thing called every time we receive a

00:20:27,630 --> 00:20:32,730
chunk of data to process and then we

00:20:30,240 --> 00:20:34,410
finally call flush once we've received

00:20:32,730 --> 00:20:38,340
all of the data and we've got a signal

00:20:34,410 --> 00:20:40,350
that the stream is going to close so

00:20:38,340 --> 00:20:43,230
let's see this in action rather than all

00:20:40,350 --> 00:20:43,860
hypothetical if we take our decryptor

00:20:43,230 --> 00:20:46,260
class

00:20:43,860 --> 00:20:48,480
it's actually an implementation of a

00:20:46,260 --> 00:20:50,820
transformer you'll notice that all these

00:20:48,480 --> 00:20:52,560
methods in the class are async so they

00:20:50,820 --> 00:20:53,640
can return promises which plays really

00:20:52,560 --> 00:20:56,160
nicely with the fact that we're having

00:20:53,640 --> 00:21:00,000
to use the crypto API because all of

00:20:56,160 --> 00:21:01,290
those methods are async as well so in

00:21:00,000 --> 00:21:03,330
our start method we're going to set up a

00:21:01,290 --> 00:21:05,100
counter same as before

00:21:03,330 --> 00:21:06,570
it's a youant eight array and what this

00:21:05,100 --> 00:21:08,970
is actually going to do is allow us to

00:21:06,570 --> 00:21:11,250
count the number of blocks of data that

00:21:08,970 --> 00:21:12,510
we've decrypted this is important when

00:21:11,250 --> 00:21:14,160
we're streaming data because we're not

00:21:12,510 --> 00:21:16,080
going to do all the work at once and so

00:21:14,160 --> 00:21:17,759
we need to track where we're at in the

00:21:16,080 --> 00:21:20,380
process

00:21:17,759 --> 00:21:21,820
then we're going to get our key it's

00:21:20,380 --> 00:21:23,350
going to be the same key for each chunk

00:21:21,820 --> 00:21:26,830
of data that we decrypt so we only need

00:21:23,350 --> 00:21:29,259
to do it once that's it for the start

00:21:26,830 --> 00:21:31,389
method and our transform method we're

00:21:29,259 --> 00:21:33,279
going to start then by getting a chunk

00:21:31,389 --> 00:21:34,690
of data and then we get a controller

00:21:33,279 --> 00:21:38,259
that controls the interactions between

00:21:34,690 --> 00:21:39,580
the input and output streams we're going

00:21:38,259 --> 00:21:42,549
to get the length of that data and

00:21:39,580 --> 00:21:44,889
divide it by 16 the reason we do this is

00:21:42,549 --> 00:21:47,889
because the encryption algorithm we're

00:21:44,889 --> 00:21:51,070
using we specified a length of 128 which

00:21:47,889 --> 00:21:53,679
stands for 128 bits which translates to

00:21:51,070 --> 00:21:55,779
16 bytes and so if we take the length

00:21:53,679 --> 00:21:58,000
divided by 16 and then take the floor of

00:21:55,779 --> 00:21:59,799
that we have the number of full blocks

00:21:58,000 --> 00:22:02,740
of data that are present in our chunk

00:21:59,799 --> 00:22:05,669
and so we can then decrypt that data and

00:22:02,740 --> 00:22:09,460
increment our counter by however many

00:22:05,669 --> 00:22:11,710
blocks we just decrypted unfortunately

00:22:09,460 --> 00:22:12,789
working with un8 arrays is not very easy

00:22:11,710 --> 00:22:15,419
and so you have to write a custom

00:22:12,789 --> 00:22:17,409
function to do this increment for you

00:22:15,419 --> 00:22:20,500
you could go look at the code for it

00:22:17,409 --> 00:22:21,940
it's not very interesting so you can

00:22:20,500 --> 00:22:24,340
find it in the demo once we're done with

00:22:21,940 --> 00:22:25,960
this now the observant among you might

00:22:24,340 --> 00:22:27,909
have noticed that there's potential for

00:22:25,960 --> 00:22:30,549
us to get a length that is not perfectly

00:22:27,909 --> 00:22:33,490
divisible by 16 in which case we can't

00:22:30,549 --> 00:22:35,169
increment our counter by an integer and

00:22:33,490 --> 00:22:37,299
so we have to write a little more code

00:22:35,169 --> 00:22:39,580
to deal with this and that is to simply

00:22:37,299 --> 00:22:41,440
find the remainder of the data that we

00:22:39,580 --> 00:22:43,210
don't that doesn't fit into a perfect

00:22:41,440 --> 00:22:45,429
block and then save it off until the

00:22:43,210 --> 00:22:47,740
next run and the next time we receive

00:22:45,429 --> 00:22:50,639
more data we can then concatenate that

00:22:47,740 --> 00:22:53,409
or prepend it to the new chunk of data

00:22:50,639 --> 00:22:54,399
basically until we get to the end of the

00:22:53,409 --> 00:22:56,320
stream we need to make sure we're

00:22:54,399 --> 00:22:58,299
operating on complete blocks of data

00:22:56,320 --> 00:22:59,889
each time otherwise we're going to lose

00:22:58,299 --> 00:23:03,370
our place and the decryption won't work

00:22:59,889 --> 00:23:05,169
properly so we can collapse all that and

00:23:03,370 --> 00:23:07,629
then we have one last function and that

00:23:05,169 --> 00:23:09,759
is the flush method and here we are

00:23:07,629 --> 00:23:11,649
going to check if we have any leftover

00:23:09,759 --> 00:23:13,179
data from the transform method if we do

00:23:11,649 --> 00:23:14,559
we decrypt it we don't care about

00:23:13,179 --> 00:23:17,860
incrementing anymore because we're at

00:23:14,559 --> 00:23:21,490
the end and then that's it that is our

00:23:17,860 --> 00:23:23,019
streaming implementation and so we're

00:23:21,490 --> 00:23:25,809
going to look at another demo same as

00:23:23,019 --> 00:23:26,910
before this one we start with a broken

00:23:25,809 --> 00:23:29,850
image

00:23:26,910 --> 00:23:33,730
but if we re enable the service worker

00:23:29,850 --> 00:23:35,230
we'll begin to see the image up here but

00:23:33,730 --> 00:23:38,260
I've purposefully slowed it down here so

00:23:35,230 --> 00:23:40,540
that way we see it come in a bit at a

00:23:38,260 --> 00:23:43,030
time you can see all the different

00:23:40,540 --> 00:23:44,530
chunks of data that we're decrypting now

00:23:43,030 --> 00:23:47,680
this image is a pretty large image I

00:23:44,530 --> 00:23:49,840
think it's about 20 Meg's and so it

00:23:47,680 --> 00:23:51,340
seems kind of like it's loading slow but

00:23:49,840 --> 00:23:53,050
if we remove the artificial slowdown

00:23:51,340 --> 00:23:57,970
that I inserted it's actually goes

00:23:53,050 --> 00:23:59,890
pretty quickly which is why I had to

00:23:57,970 --> 00:24:01,210
added the slowdown earlier and this is

00:23:59,890 --> 00:24:02,740
awesome because it shows that we can

00:24:01,210 --> 00:24:04,330
polyfill these custom image formats and

00:24:02,740 --> 00:24:07,510
have them actually be somewhat

00:24:04,330 --> 00:24:09,460
performant so you can find this demo on

00:24:07,510 --> 00:24:13,360
glitch as well at cryptogram - streaming

00:24:09,460 --> 00:24:15,250
glitched at me now I realize we just

00:24:13,360 --> 00:24:17,560
covered a ton of code and a lot of it is

00:24:15,250 --> 00:24:19,330
kind of low level right it's below all

00:24:17,560 --> 00:24:20,980
those frameworks and libraries that

00:24:19,330 --> 00:24:22,360
we're used to working with and that's

00:24:20,980 --> 00:24:25,060
cuz a lot of these things are pretty new

00:24:22,360 --> 00:24:26,410
on the web platform and that's kind of

00:24:25,060 --> 00:24:28,150
the real point of this talk today it

00:24:26,410 --> 00:24:30,130
wasn't necessarily to show that we can

00:24:28,150 --> 00:24:31,540
implement our own image format it's

00:24:30,130 --> 00:24:34,030
really just to show that there's a lot

00:24:31,540 --> 00:24:35,200
of cool stuff we can now do on the web

00:24:34,030 --> 00:24:38,680
platform that was not previously

00:24:35,200 --> 00:24:40,900
possible technologies like streams web

00:24:38,680 --> 00:24:42,640
crypto and service workers provide us

00:24:40,900 --> 00:24:46,210
with a lot of building blocks to build

00:24:42,640 --> 00:24:49,300
really cool and not always practical

00:24:46,210 --> 00:24:51,670
ideas and so as I've been thinking about

00:24:49,300 --> 00:24:53,230
all these technologies and related

00:24:51,670 --> 00:24:54,570
topics over the last year there's a few

00:24:53,230 --> 00:24:56,620
other ideas that I've come into my mind

00:24:54,570 --> 00:24:59,830
so let's talk about those real quick

00:24:56,620 --> 00:25:02,380
before I end for instance what if you

00:24:59,830 --> 00:25:03,910
used web assembly incorporated web

00:25:02,380 --> 00:25:05,860
assembly into those transform streams

00:25:03,910 --> 00:25:08,050
and you got some lightning fast data

00:25:05,860 --> 00:25:09,700
transformations you could then compose

00:25:08,050 --> 00:25:11,710
those together by piping through

00:25:09,700 --> 00:25:13,690
multiple of them you could even

00:25:11,710 --> 00:25:16,150
implement new encryption algorithms or

00:25:13,690 --> 00:25:19,570
decryption algorithms using web assembly

00:25:16,150 --> 00:25:22,220
and have them perform very quickly

00:25:19,570 --> 00:25:25,070
or what if we took that ability to

00:25:22,220 --> 00:25:26,540
intercept requests at runtime and change

00:25:25,070 --> 00:25:28,730
how we think about our development

00:25:26,540 --> 00:25:30,950
workflows all right what if you could

00:25:28,730 --> 00:25:32,900
have streaming compilation for your

00:25:30,950 --> 00:25:34,700
typescript projects at runtime in the

00:25:32,900 --> 00:25:36,680
browser you no longer have to run a

00:25:34,700 --> 00:25:38,150
local build process and instead your

00:25:36,680 --> 00:25:39,050
browser just knows that hey I'm loading

00:25:38,150 --> 00:25:41,030
a typescript file

00:25:39,050 --> 00:25:43,160
I should compile this and then cache the

00:25:41,030 --> 00:25:45,410
result and then only recompile it on the

00:25:43,160 --> 00:25:47,300
next load if it's changed that would be

00:25:45,410 --> 00:25:49,160
awesome I hate running local build

00:25:47,300 --> 00:25:52,700
systems so this would be a really

00:25:49,160 --> 00:25:54,440
awesome feature to me or maybe you could

00:25:52,700 --> 00:25:57,250
completely polyfill extensions to the

00:25:54,440 --> 00:26:00,590
web platform right what if we could load

00:25:57,250 --> 00:26:02,630
HTML files into our JavaScript modules

00:26:00,590 --> 00:26:05,120
and then just reference them like a

00:26:02,630 --> 00:26:06,980
JavaScript object this would be really

00:26:05,120 --> 00:26:07,880
powerful and give us new ways to do

00:26:06,980 --> 00:26:11,450
templating in our JavaScript

00:26:07,880 --> 00:26:12,980
applications well we're talking about ES

00:26:11,450 --> 00:26:14,570
modules why not experiment with being

00:26:12,980 --> 00:26:16,700
able to import assets by their package

00:26:14,570 --> 00:26:19,490
name such as in the package name Maps

00:26:16,700 --> 00:26:20,990
proposal I probably felt this but it's

00:26:19,490 --> 00:26:23,330
now starting the ship in browsers and so

00:26:20,990 --> 00:26:26,360
it may not be super worthwhile to check

00:26:23,330 --> 00:26:28,100
out but the point is it's possible you

00:26:26,360 --> 00:26:30,680
can do a lot of things that you used to

00:26:28,100 --> 00:26:32,330
not be able to and finally what about

00:26:30,680 --> 00:26:34,730
inserting video effects out runtime in

00:26:32,330 --> 00:26:36,500
the browser if you get a stream of video

00:26:34,730 --> 00:26:38,120
data you could transform it and if

00:26:36,500 --> 00:26:40,520
you're using fast transformations

00:26:38,120 --> 00:26:43,580
implemented in web assembly you could

00:26:40,520 --> 00:26:45,980
insert real time effects into those live

00:26:43,580 --> 00:26:49,670
streaming videos that would be

00:26:45,980 --> 00:26:52,550
incredible in my opinion now obviously

00:26:49,670 --> 00:26:54,140
this isn't all the topics all the

00:26:52,550 --> 00:26:55,910
potential things that we could do here

00:26:54,140 --> 00:26:57,380
these are just a few ideas that I've

00:26:55,910 --> 00:26:59,900
been mulling over for the last few

00:26:57,380 --> 00:27:01,460
months and so while today I talked about

00:26:59,900 --> 00:27:03,530
and showed how we can implement our own

00:27:01,460 --> 00:27:05,810
custom image format there's so much more

00:27:03,530 --> 00:27:07,270
that you can do and I really want to

00:27:05,810 --> 00:27:10,120
encourage you all to just have fun

00:27:07,270 --> 00:27:12,950
experiment with some of these new things

00:27:10,120 --> 00:27:15,310
whether it's streams in web crypto or

00:27:12,950 --> 00:27:18,590
just the next generation of ACMA script

00:27:15,310 --> 00:27:21,170
functionality or web components have fun

00:27:18,590 --> 00:27:23,030
these are all setting the stage for us

00:27:21,170 --> 00:27:25,010
to build more ambitious and exciting

00:27:23,030 --> 00:27:27,020
projects than we ever have before in the

00:27:25,010 --> 00:27:28,880
history of the web

00:27:27,020 --> 00:27:30,410
so I'd love to see what you've built

00:27:28,880 --> 00:27:31,730
feel free to hit me up on Twitter with

00:27:30,410 --> 00:27:34,040
that or what you're going to build in

00:27:31,730 --> 00:27:36,620
the future or what your ideas are and go

00:27:34,040 --> 00:27:38,180
forth fulfill Atwoods law right

00:27:36,620 --> 00:27:40,460
everything that you can think of in

00:27:38,180 --> 00:27:44,450
JavaScript thank you

00:27:40,460 --> 00:27:44,450

YouTube URL: https://www.youtube.com/watch?v=ZPxzpbnXiYc


