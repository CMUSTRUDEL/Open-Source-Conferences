Title: The Oracle at Delphi Neither Speaks nor Conceals -  City JS Conf 2019
Publication date: 2019-05-14
Playlist: City JS Conf 2019
Description: 
	Sam Galson 

The "exotic" types of testing that interest me here (fuzz testing, generative testing, property-based testing, metamorphic testing and mutation testing) are not talked about much in the JS community. I believe that is not because they are known to be unhelpful, but rather because little is known about them at all.
 
Libraries to enable these sorts of testing are still immature, but now reaching a point where it is possible for developers to try them out and come to their own opinions about the value of these testing approaches.
 
My aim in this talk is therefore to educate about alternative testing methodologies and encourage the trialling of new tools so that the community can better gauge the value of the techniques they make possible.

_

About Pusher Sessions:

We're bringing the meetup to you. With Sessions, you can watch recordings of top-notch talks from developer meetups -- wherever and whenever you want.

Meetups are a great way to learn from our peers and to keep up with the latest trends and technologies. As developers ourselves, we at Pusher wanted to bring this great content to more people... So we built Sessions. On Sessions, you can watch talks that interest you and subscribe to be notified when new content gets added.

If you run a meetup and want to get involved, kindly get in touch.

_

About Pusher:

Pusher is a hosted service with APIs, developer tools and open source libraries that greatly simplify integrating real-time functionality into web and mobile applications. 

Pusher will automatically scale when required, removing all the pain of setting up and maintaining a secure, real-time infrastructure. 

Pusher is already trusted to do so by thousands of developers and companies like GitHub, MailChimp, the Financial Times, Buffer and many more. 

Getting started takes just a few seconds: simply go to pusher.com and create a free account. Happy hacking!
Captions: 
	00:00:00,030 --> 00:00:04,410
q I do I do actually have an internet

00:00:02,399 --> 00:00:06,029
presence but you have to go kind of far

00:00:04,410 --> 00:00:09,360
back and I can assure you there is some

00:00:06,029 --> 00:00:11,340
weird stuff so maybe don't search but if

00:00:09,360 --> 00:00:13,830
you're interested I'm gonna be talking

00:00:11,340 --> 00:00:17,310
about the Oracle at Delphi neither

00:00:13,830 --> 00:00:19,260
speaks nor conceals and this picture is

00:00:17,310 --> 00:00:22,619
a clue to what this talks actually gonna

00:00:19,260 --> 00:00:24,330
be about if you recognize it but before

00:00:22,619 --> 00:00:27,119
we get into that I'm Sam Golson I work

00:00:24,330 --> 00:00:28,890
for Wildey a software consultancy follow

00:00:27,119 --> 00:00:32,610
me on Twitter read my blog post so I

00:00:28,890 --> 00:00:35,489
tried to make them interesting so what

00:00:32,610 --> 00:00:38,070
this talk is not about Oracle and if you

00:00:35,489 --> 00:00:39,629
recognize the logo below my

00:00:38,070 --> 00:00:43,770
commiserations it's not about that

00:00:39,629 --> 00:00:45,840
either what it is about is something

00:00:43,770 --> 00:00:48,690
called the Oracle problem what is the

00:00:45,840 --> 00:00:50,579
Oracle problem so you might be familiar

00:00:48,690 --> 00:00:52,500
with the term Oracle if you've read

00:00:50,579 --> 00:00:54,960
about cheering machines so in that

00:00:52,500 --> 00:00:56,640
context an Oracle is some piece of

00:00:54,960 --> 00:00:59,430
information that you feed a Turing

00:00:56,640 --> 00:01:01,260
machine which allows it to decide on a

00:00:59,430 --> 00:01:02,940
problem but the key point is that that

00:01:01,260 --> 00:01:04,710
information comes from some source

00:01:02,940 --> 00:01:05,790
outside the Turing machine so the Turing

00:01:04,710 --> 00:01:07,710
machine couldn't have known about it

00:01:05,790 --> 00:01:11,750
which is why it's called an Oracle it's

00:01:07,710 --> 00:01:13,920
also used in the literature on testing

00:01:11,750 --> 00:01:17,159
so we have these things that we call

00:01:13,920 --> 00:01:18,720
test Oracle's and a test Oracle is some

00:01:17,159 --> 00:01:21,900
piece of information that you feed your

00:01:18,720 --> 00:01:23,040
program which allows you is external

00:01:21,900 --> 00:01:24,930
piece of information it's suddenly your

00:01:23,040 --> 00:01:27,210
code doesn't know about but it allows

00:01:24,930 --> 00:01:29,939
you to decide it allows the computer to

00:01:27,210 --> 00:01:31,920
decide whether your test has passed or

00:01:29,939 --> 00:01:35,130
failed so you've probably all written

00:01:31,920 --> 00:01:37,110
thousands of tests like this these are

00:01:35,130 --> 00:01:39,840
this is a test Oracle so there's three

00:01:37,110 --> 00:01:42,659
parts to it there's a bit where you

00:01:39,840 --> 00:01:44,399
create your expectation there's a bit

00:01:42,659 --> 00:01:46,920
where you run the program to generate an

00:01:44,399 --> 00:01:49,280
actual result and then there's a bit

00:01:46,920 --> 00:01:51,869
where you compare so you compare your

00:01:49,280 --> 00:01:57,079
expectation with the result and say did

00:01:51,869 --> 00:02:00,990
that pass or not this is also an Oracle

00:01:57,079 --> 00:02:03,960
anyone recognize this this figure put

00:02:00,990 --> 00:02:06,930
your hand up okay you need to go read

00:02:03,960 --> 00:02:09,479
some ancient Greek this is the Oracle at

00:02:06,930 --> 00:02:12,270
Delphi she was called the Pythia and she

00:02:09,479 --> 00:02:13,770
would sit on a vent of noxious fumes and

00:02:12,270 --> 00:02:18,660
spout forth the probe

00:02:13,770 --> 00:02:24,530
seas of the god Apollo there's lots of

00:02:18,660 --> 00:02:27,780
stories about the Pythia but one of the

00:02:24,530 --> 00:02:29,280
key things about her is what the

00:02:27,780 --> 00:02:31,280
philosopher Heraclitus said which is

00:02:29,280 --> 00:02:34,350
that the God whose Oracle at Delphi

00:02:31,280 --> 00:02:38,460
whose Oracle is at Delphi neither speaks

00:02:34,350 --> 00:02:39,660
nor conceals but gives a sign okay what

00:02:38,460 --> 00:02:42,000
what does he mean by that

00:02:39,660 --> 00:02:43,800
Multi give you an example the the Greeks

00:02:42,000 --> 00:02:46,830
used to illustrate this with the story

00:02:43,800 --> 00:02:49,740
of the the rich King Croesus now Croesus

00:02:46,830 --> 00:02:52,020
was this King in Asia Minor who was very

00:02:49,740 --> 00:02:53,490
interested in Oracle's and he wanted to

00:02:52,020 --> 00:02:55,800
expand his empire so we went to the

00:02:53,490 --> 00:02:59,100
Oracle and said if i invade the persians

00:02:55,800 --> 00:03:01,200
what will happen and the Oracle said if

00:02:59,100 --> 00:03:04,290
you invade the Persian Empire a great

00:03:01,200 --> 00:03:08,490
Empire will fall and of course Croesus

00:03:04,290 --> 00:03:11,940
was like great let's let's go and you

00:03:08,490 --> 00:03:14,070
know the Oracle doesn't speak the Empire

00:03:11,940 --> 00:03:15,690
turned out to be his own and we face a

00:03:14,070 --> 00:03:17,850
similar problem with tests Oracle's

00:03:15,690 --> 00:03:19,890
because our Oracle is only ever a

00:03:17,850 --> 00:03:22,020
partial representation of the system

00:03:19,890 --> 00:03:23,760
that we actually want to test but

00:03:22,020 --> 00:03:26,700
usually we're testing with a single

00:03:23,760 --> 00:03:28,620
input usually we're making a single

00:03:26,700 --> 00:03:32,130
assertion and testing against a single

00:03:28,620 --> 00:03:33,690
output in some cases we don't even know

00:03:32,130 --> 00:03:36,450
what output to expect from our program

00:03:33,690 --> 00:03:38,970
and this is the Oracle problem so what

00:03:36,450 --> 00:03:42,300
can we do about it the answer lies in

00:03:38,970 --> 00:03:45,000
the concept of fuzz put your hand up if

00:03:42,300 --> 00:03:46,110
you know what fuzz testing is Sofer phew

00:03:45,000 --> 00:03:49,580
okay

00:03:46,110 --> 00:03:52,680
if you've used fuzz testing on a

00:03:49,580 --> 00:03:55,080
JavaScript project leave your hand up

00:03:52,680 --> 00:03:57,209
okay three or so what is fuzz testing is

00:03:55,080 --> 00:03:58,950
a fuzzy term itself it encompasses a lot

00:03:57,209 --> 00:04:00,420
of different testing techniques but the

00:03:58,950 --> 00:04:03,000
basic idea behind them all is that

00:04:00,420 --> 00:04:05,850
instead of using it a test Oracle that

00:04:03,000 --> 00:04:07,440
we write we generate them automatically

00:04:05,850 --> 00:04:09,360
which means we can have hundreds or

00:04:07,440 --> 00:04:11,220
thousands of these test Oracle's this

00:04:09,360 --> 00:04:13,200
obviously doesn't solve the Oracle

00:04:11,220 --> 00:04:15,600
problem okay we can never gonna predict

00:04:13,200 --> 00:04:18,180
the future entirely but it's a

00:04:15,600 --> 00:04:21,150
mitigation now there are many kinds of

00:04:18,180 --> 00:04:24,830
fuzzing as I mentioned I'll describe

00:04:21,150 --> 00:04:27,510
what these are but I should explain that

00:04:24,830 --> 00:04:31,830
my reasoning for wanting to do this too

00:04:27,510 --> 00:04:33,120
is that first of all I don't think the

00:04:31,830 --> 00:04:34,650
knowledge around these different kinds

00:04:33,120 --> 00:04:36,630
of testing is that great in the

00:04:34,650 --> 00:04:40,500
JavaScript community compared to in some

00:04:36,630 --> 00:04:42,360
other communities and I genuinely don't

00:04:40,500 --> 00:04:43,830
know exactly why that is I don't know

00:04:42,360 --> 00:04:45,690
why fuzzing hasn't quite caught on in

00:04:43,830 --> 00:04:47,250
JavaScript it could be that it's not

00:04:45,690 --> 00:04:50,250
useful in which case I'm interested in

00:04:47,250 --> 00:04:52,200
hearing opinions on that but there are a

00:04:50,250 --> 00:04:55,080
number of libraries which are started to

00:04:52,200 --> 00:04:57,360
emerge recently which have made various

00:04:55,080 --> 00:04:58,290
styles of this testing possible so I

00:04:57,360 --> 00:04:59,820
think it's worth looking at these

00:04:58,290 --> 00:05:02,490
libraries and evaluating if they are in

00:04:59,820 --> 00:05:04,050
fact useful for JavaScript developers so

00:05:02,490 --> 00:05:06,150
let's have a look and see what these

00:05:04,050 --> 00:05:09,660
kinds of testing actually involved the

00:05:06,150 --> 00:05:10,950
first thing you can do is cheat so you

00:05:09,660 --> 00:05:14,070
can get this thing called the big list

00:05:10,950 --> 00:05:15,660
of naughty strings from github now

00:05:14,070 --> 00:05:18,360
instead of writing one test with a

00:05:15,660 --> 00:05:19,680
string that might instead of writing a

00:05:18,360 --> 00:05:22,860
test to check that say your API

00:05:19,680 --> 00:05:25,560
processes a user called John you can now

00:05:22,860 --> 00:05:27,000
fire hundreds of user names some of them

00:05:25,560 --> 00:05:31,200
containing naughty stuff like

00:05:27,000 --> 00:05:33,750
instructions to drop table and see if

00:05:31,200 --> 00:05:35,070
your API can cope with this there's a

00:05:33,750 --> 00:05:36,990
really easy way to do this you just

00:05:35,070 --> 00:05:38,520
install artillery which is a load

00:05:36,990 --> 00:05:40,560
testing framework and there's this

00:05:38,520 --> 00:05:41,910
plug-in and then artillery you can

00:05:40,560 --> 00:05:44,100
figure with the amyl you just write this

00:05:41,910 --> 00:05:45,540
piece of gamal it says fire at my

00:05:44,100 --> 00:05:46,020
session endpoint a username and a

00:05:45,540 --> 00:05:48,540
password

00:05:46,020 --> 00:05:50,250
but do this hundreds of times and take a

00:05:48,540 --> 00:05:52,830
different naughty string each time you

00:05:50,250 --> 00:05:55,350
do it it's like you like five five

00:05:52,830 --> 00:05:58,950
minutes to set up and the result is you

00:05:55,350 --> 00:06:01,140
can avoid bugs like this so this I don't

00:05:58,950 --> 00:06:03,990
know if you remember this some time ago

00:06:01,140 --> 00:06:05,520
and basically everyone on Twitter kind

00:06:03,990 --> 00:06:07,440
of simultaneously realized they could

00:06:05,520 --> 00:06:11,100
break JIRA if they put an emoji in the

00:06:07,440 --> 00:06:12,480
right field this is one of those rare

00:06:11,100 --> 00:06:15,300
bugs that actually makes the world a

00:06:12,480 --> 00:06:18,330
better place but they could have avoided

00:06:15,300 --> 00:06:20,250
this if they had just set up artillery

00:06:18,330 --> 00:06:24,840
to test with the big list naughty

00:06:20,250 --> 00:06:28,140
strings okay now what about blind

00:06:24,840 --> 00:06:31,110
fuzzing what what blank fuzzing involves

00:06:28,140 --> 00:06:32,340
is this is now not cheating this is true

00:06:31,110 --> 00:06:35,760
fuzzing because we're actually going to

00:06:32,340 --> 00:06:37,050
generate random mutations of some test

00:06:35,760 --> 00:06:39,090
data and we're going to do so blindly

00:06:37,050 --> 00:06:40,889
which means we're going to use various

00:06:39,090 --> 00:06:43,680
strategies to vary the bit

00:06:40,889 --> 00:06:45,270
it's in a kind of a random fashion and

00:06:43,680 --> 00:06:48,870
there's a couple of tools you can use to

00:06:45,270 --> 00:06:52,050
do this redeem sir ends off some of the

00:06:48,870 --> 00:06:55,469
main ones as you can see it's very very

00:06:52,050 --> 00:06:57,029
easy to use the key point is that each

00:06:55,469 --> 00:06:59,129
mutation so here we're just going to

00:06:57,029 --> 00:07:01,650
produce a hundred bits of random data or

00:06:59,129 --> 00:07:03,870
100 mutations of the word hello

00:07:01,650 --> 00:07:05,909
and each mutation has a seed which means

00:07:03,870 --> 00:07:07,289
it's deterministic so if you find one

00:07:05,909 --> 00:07:11,039
that causes a bug you can easily

00:07:07,289 --> 00:07:12,719
recreate it and the output is something

00:07:11,039 --> 00:07:15,090
like this so it doesn't crush the

00:07:12,719 --> 00:07:17,490
terminal so that's good the terminal has

00:07:15,090 --> 00:07:19,080
a nice fullback for displaying bits that

00:07:17,490 --> 00:07:20,479
doesn't understand which is the question

00:07:19,080 --> 00:07:23,520
mark

00:07:20,479 --> 00:07:25,439
okay now the standard way people think

00:07:23,520 --> 00:07:27,240
about fuzzing if they if it is something

00:07:25,439 --> 00:07:29,939
on their radar is it's it's something

00:07:27,240 --> 00:07:32,550
that's useful for testing when we don't

00:07:29,939 --> 00:07:33,930
it's not simply that we want more tests

00:07:32,550 --> 00:07:36,000
Oracle's it's that we don't we can't

00:07:33,930 --> 00:07:37,169
think of a test Oracle at all either

00:07:36,000 --> 00:07:38,430
because we're working with the legacy

00:07:37,169 --> 00:07:40,710
API and we don't know what it's supposed

00:07:38,430 --> 00:07:41,999
to do so how can we test it all we're

00:07:40,710 --> 00:07:44,009
working with something very complicated

00:07:41,999 --> 00:07:45,599
machine learning cryptography where the

00:07:44,009 --> 00:07:49,020
output is just so hard to predict we

00:07:45,599 --> 00:07:51,629
can't really write tests this I think is

00:07:49,020 --> 00:07:53,250
kind of an old-fashioned view about what

00:07:51,629 --> 00:07:56,729
fuzzing is good for there are some

00:07:53,250 --> 00:07:59,610
voices now which is worth pointing out

00:07:56,729 --> 00:08:01,680
as well so the in this model what the

00:07:59,610 --> 00:08:03,060
way you do fuzzing is you fire random it

00:08:01,680 --> 00:08:04,830
put inputs at your application you

00:08:03,060 --> 00:08:06,029
basically watch it for crashes so the

00:08:04,830 --> 00:08:08,779
thing you're monitoring is whether or

00:08:06,029 --> 00:08:11,009
not the application crashes and

00:08:08,779 --> 00:08:12,719
historically this is thought have is

00:08:11,009 --> 00:08:15,449
thought to have been most useful for

00:08:12,719 --> 00:08:18,120
stuff like C where there's a high chance

00:08:15,449 --> 00:08:20,370
of issues managing memory and stuff like

00:08:18,120 --> 00:08:21,479
that cause could cause crashes and

00:08:20,370 --> 00:08:25,229
indeed that is still the main

00:08:21,479 --> 00:08:26,699
application for fuzzing but there's some

00:08:25,229 --> 00:08:29,279
interesting stuff that's been written on

00:08:26,699 --> 00:08:31,649
this by Mozilla who are heavy users of

00:08:29,279 --> 00:08:34,169
fuzzing in particular the value of

00:08:31,649 --> 00:08:36,860
assertions in your code so if you if you

00:08:34,169 --> 00:08:39,539
put lots of assertions in your code and

00:08:36,860 --> 00:08:40,979
then to do the same process you can

00:08:39,539 --> 00:08:42,870
watch for much more interesting things

00:08:40,979 --> 00:08:45,060
than just crashes and you can actually

00:08:42,870 --> 00:08:48,709
use this kind of rampant it random Impa

00:08:45,060 --> 00:08:51,870
testing to uncover business logic false

00:08:48,709 --> 00:08:53,100
how can we do this in in JavaScript well

00:08:51,870 --> 00:08:54,360
of course we can we've got sink dweller

00:08:53,100 --> 00:08:58,800
which is just a very

00:08:54,360 --> 00:09:01,560
simple wrapper for red am sir as you can

00:08:58,800 --> 00:09:05,279
see it works very similarly to x' if we

00:09:01,560 --> 00:09:07,709
set a seed we pass it some data passing

00:09:05,279 --> 00:09:11,880
we're passing in a buffer of hello

00:09:07,709 --> 00:09:13,920
and we just fuzz that hundred times the

00:09:11,880 --> 00:09:15,870
author of sync well that also has made

00:09:13,920 --> 00:09:18,029
this nice plasma maybe module which

00:09:15,870 --> 00:09:20,610
allows you to control where you want the

00:09:18,029 --> 00:09:23,370
fuzzing injected in your application so

00:09:20,610 --> 00:09:25,200
you can insert this file you can wrap

00:09:23,370 --> 00:09:26,370
anything in this further and then

00:09:25,200 --> 00:09:27,930
control whether or not you want the

00:09:26,370 --> 00:09:29,910
fuzzing to actually happen using an

00:09:27,930 --> 00:09:33,779
environment variable okay and the output

00:09:29,910 --> 00:09:35,760
of Radames err it's stuff like this it's

00:09:33,779 --> 00:09:37,290
just interesting to see this because

00:09:35,760 --> 00:09:39,570
it's so different to the app that you

00:09:37,290 --> 00:09:41,519
get from zorth so well it's worth being

00:09:39,570 --> 00:09:43,200
aware of that different fuzzing

00:09:41,519 --> 00:09:45,450
algorithms produce different sorts of

00:09:43,200 --> 00:09:47,850
results now what's the next step up in

00:09:45,450 --> 00:09:50,519
terms of sophistication these things

00:09:47,850 --> 00:09:52,950
called genetic buzzes the oldest and

00:09:50,519 --> 00:09:55,350
most well known of these is AFL which

00:09:52,950 --> 00:09:56,519
stands for American fuzzy lop and what

00:09:55,350 --> 00:09:58,949
does this do that's different

00:09:56,519 --> 00:10:01,709
well it has this very simple algorithm

00:09:58,949 --> 00:10:05,010
where it fees is fee to the first input

00:10:01,709 --> 00:10:07,490
in and then it does an extra thing which

00:10:05,010 --> 00:10:11,670
is it checks whether or not that input

00:10:07,490 --> 00:10:13,589
increased coverage what this means is

00:10:11,670 --> 00:10:16,079
that although it's working in a kind of

00:10:13,589 --> 00:10:17,850
a blind fashion in the way it fuzzes it

00:10:16,079 --> 00:10:19,589
keeps track of those inputs which are

00:10:17,850 --> 00:10:22,110
more likely to reach further into your

00:10:19,589 --> 00:10:24,959
application and therefore more likely to

00:10:22,110 --> 00:10:28,019
discover edge cases so it results in

00:10:24,959 --> 00:10:30,990
much faster results it looks like this

00:10:28,019 --> 00:10:34,079
when you run it now the problem with AFL

00:10:30,990 --> 00:10:35,579
is it was written for C and if you want

00:10:34,079 --> 00:10:37,350
to use it you have to compile your C

00:10:35,579 --> 00:10:39,779
program with some special stuff to get

00:10:37,350 --> 00:10:41,880
the coverage and then you can fuzz it

00:10:39,779 --> 00:10:43,740
with AFL so if you want to use it in

00:10:41,880 --> 00:10:45,300
JavaScript or Python or whatever you

00:10:43,740 --> 00:10:48,990
have to write a separate implementation

00:10:45,300 --> 00:10:51,089
for those languages and there are some

00:10:48,990 --> 00:10:54,480
pretty popular AFL libraries in go a

00:10:51,089 --> 00:10:56,519
effort in rust and even in Python where

00:10:54,480 --> 00:10:59,850
the library there is fairly stable

00:10:56,519 --> 00:11:01,890
definitely usable in JavaScript we don't

00:10:59,850 --> 00:11:03,480
really have one so there is this library

00:11:01,890 --> 00:11:06,779
it's the only one I could find jeaious

00:11:03,480 --> 00:11:08,279
fuzz it kind of works it's a bit buggy I

00:11:06,779 --> 00:11:12,689
think it's a great thing to work

00:11:08,279 --> 00:11:14,819
on to help bring us you know we again

00:11:12,689 --> 00:11:16,110
one of the my main messages in this talk

00:11:14,819 --> 00:11:17,939
is we don't want to let the Python

00:11:16,110 --> 00:11:19,230
Easter's beat us with this kind of stuff

00:11:17,939 --> 00:11:23,189
like if they've got one then we should

00:11:19,230 --> 00:11:24,839
have one too so yeah get to work right

00:11:23,189 --> 00:11:27,180
what's the next step up in

00:11:24,839 --> 00:11:31,259
sophistication again we open our eyes

00:11:27,180 --> 00:11:32,790
we're no longer blind fuzzing this is

00:11:31,259 --> 00:11:36,199
what my parents always taught me I don't

00:11:32,790 --> 00:11:39,480
know if it's true we can use a grammar

00:11:36,199 --> 00:11:42,660
there's a few puzzles that will allow

00:11:39,480 --> 00:11:44,689
you to do this I recommend starting with

00:11:42,660 --> 00:11:46,980
Dharma which is maintained by Mozilla

00:11:44,689 --> 00:11:51,569
grammars look like this so this is a

00:11:46,980 --> 00:11:52,920
complete grammar to specify URL you can

00:11:51,569 --> 00:11:55,230
use this to have your fuzzer

00:11:52,920 --> 00:11:56,459
automatically generates as many URLs as

00:11:55,230 --> 00:11:58,589
you want and you can be sure that

00:11:56,459 --> 00:12:00,569
they'll be valid URLs this is obviously

00:11:58,589 --> 00:12:03,329
going to vastly narrow down the number

00:12:00,569 --> 00:12:05,249
of test cases you need to try at the

00:12:03,329 --> 00:12:06,930
same time it's less likely to discover

00:12:05,249 --> 00:12:08,639
some of those more extreme edge cases

00:12:06,930 --> 00:12:12,629
but it's worth being aware of as a

00:12:08,639 --> 00:12:15,059
strategy but where's our JavaScript okay

00:12:12,629 --> 00:12:17,490
if we can generate URLs why can't we

00:12:15,059 --> 00:12:20,610
just generate JavaScript objects of

00:12:17,490 --> 00:12:23,100
course we can another library by Mozilla

00:12:20,610 --> 00:12:26,309
can help you do this so just various

00:12:23,100 --> 00:12:28,019
helper functions for generating random

00:12:26,309 --> 00:12:29,730
JavaScript objects and this isn't random

00:12:28,019 --> 00:12:32,490
in the sense of fakir or something like

00:12:29,730 --> 00:12:34,500
that if you've used that where it's kind

00:12:32,490 --> 00:12:35,819
of random realistic this is random

00:12:34,500 --> 00:12:39,899
random let's try and break your

00:12:35,819 --> 00:12:45,779
application random it comes out looking

00:12:39,899 --> 00:12:48,029
something like this we can also use this

00:12:45,779 --> 00:12:49,589
library fuzzer and just passing a whole

00:12:48,029 --> 00:12:53,730
object and it will fuzz all the keys on

00:12:49,589 --> 00:12:57,329
that object but once we've got this

00:12:53,730 --> 00:13:00,750
ability to create fuzzy data within

00:12:57,329 --> 00:13:02,459
JavaScript actually a whole new vista of

00:13:00,750 --> 00:13:04,829
the times of kinds of tests we can do

00:13:02,459 --> 00:13:07,620
opens up and we can do this thing called

00:13:04,829 --> 00:13:08,910
generative or property based testing and

00:13:07,620 --> 00:13:11,339
the idea of this is that instead of

00:13:08,910 --> 00:13:15,569
fuzzing some entry point to our

00:13:11,339 --> 00:13:18,959
application like an API or a standard

00:13:15,569 --> 00:13:21,439
input we can actually fuzz individual

00:13:18,959 --> 00:13:21,439
functions

00:13:21,759 --> 00:13:28,040
now property based testing libraries are

00:13:25,819 --> 00:13:30,079
actually core components of various

00:13:28,040 --> 00:13:32,449
different programming languages maybe

00:13:30,079 --> 00:13:35,749
most famously close your or at least

00:13:32,449 --> 00:13:38,089
they talk about it a lot if you look in

00:13:35,749 --> 00:13:39,290
the closure Docs you can find statements

00:13:38,089 --> 00:13:40,999
like this property based generative

00:13:39,290 --> 00:13:42,980
testing is implemented for closure and

00:13:40,999 --> 00:13:44,569
tests that check this proves to be far

00:13:42,980 --> 00:13:48,350
more powerful than manually written

00:13:44,569 --> 00:13:50,720
tests is that okay powerful who knows

00:13:48,350 --> 00:13:53,720
what like what that really means but I

00:13:50,720 --> 00:13:55,279
mean is that true if so shouldn't this

00:13:53,720 --> 00:14:00,619
be something we're looking into in

00:13:55,279 --> 00:14:01,939
JavaScript and again we do have

00:14:00,619 --> 00:14:03,290
libraries for this and they're much

00:14:01,939 --> 00:14:05,360
better they're in a much better state

00:14:03,290 --> 00:14:07,399
than the AFL library I mentioned earlier

00:14:05,360 --> 00:14:08,230
you can actually use them in production

00:14:07,399 --> 00:14:10,879
if you want

00:14:08,230 --> 00:14:13,910
however they nowhere near up to the

00:14:10,879 --> 00:14:18,889
standard of libraries in other languages

00:14:13,910 --> 00:14:20,959
like Python yet here's an example of

00:14:18,889 --> 00:14:23,749
what it looks like so let's say we've

00:14:20,959 --> 00:14:25,100
got this stupid add 10 max function

00:14:23,749 --> 00:14:26,600
where we want to add something unless

00:14:25,100 --> 00:14:28,910
it's more than 10 in which case we'll

00:14:26,600 --> 00:14:30,740
just return 10 but I was so bored by

00:14:28,910 --> 00:14:34,490
this function that I forgot to uncomment

00:14:30,740 --> 00:14:37,399
the line that actually makes it work how

00:14:34,490 --> 00:14:38,809
can we test this we now we're not going

00:14:37,399 --> 00:14:40,699
to test it with a single input we're

00:14:38,809 --> 00:14:42,319
going to test it with a large number of

00:14:40,699 --> 00:14:44,959
random inputs so we're going to need to

00:14:42,319 --> 00:14:48,170
specify the type of those inputs so we

00:14:44,959 --> 00:14:49,910
say gender int gender int and the

00:14:48,170 --> 00:14:52,220
framework we'll just run this loads of

00:14:49,910 --> 00:14:55,160
loads of times and each time we'll run

00:14:52,220 --> 00:14:57,350
our assertion and we can do it in a

00:14:55,160 --> 00:14:58,429
nicer way as well as plugins to work

00:14:57,350 --> 00:15:00,559
with various different testing

00:14:58,429 --> 00:15:02,769
frameworks so all we have to do is we

00:15:00,559 --> 00:15:05,299
can have our ordinary just style test

00:15:02,769 --> 00:15:08,689
just passing a couple of extra arguments

00:15:05,299 --> 00:15:10,279
for our generators and there's a whole

00:15:08,689 --> 00:15:12,860
bunch of different kinds of stuff you

00:15:10,279 --> 00:15:16,360
can generate not just JavaScript types

00:15:12,860 --> 00:15:20,269
but also through subtypes I guess like

00:15:16,360 --> 00:15:21,920
positive or negative integers and you

00:15:20,269 --> 00:15:23,899
can write your own generators if you

00:15:21,920 --> 00:15:25,730
want and it comes with this function

00:15:23,899 --> 00:15:28,370
sample which allows you to sample your

00:15:25,730 --> 00:15:30,559
generator and this is an example of a

00:15:28,370 --> 00:15:32,240
JSON object that it will give you now

00:15:30,559 --> 00:15:33,870
these property based testing libraries

00:15:32,240 --> 00:15:36,900
come with a

00:15:33,870 --> 00:15:40,560
rather clever feature called shrinking

00:15:36,900 --> 00:15:43,400
which was originally written for the

00:15:40,560 --> 00:15:46,230
Haskell property-based testing library

00:15:43,400 --> 00:15:48,470
and what it does is so this is the

00:15:46,230 --> 00:15:51,960
result of the test I showed you earlier

00:15:48,470 --> 00:15:54,180
so it came up with a random input 21 and

00:15:51,960 --> 00:15:56,400
8 and it found that the assertion failed

00:15:54,180 --> 00:15:58,830
what it then did using this shrinking

00:15:56,400 --> 00:16:01,530
technique is it tried various inputs to

00:15:58,830 --> 00:16:03,960
try and work out what the smallest input

00:16:01,530 --> 00:16:05,750
it could give the function was which

00:16:03,960 --> 00:16:08,580
would cause the function to still fail

00:16:05,750 --> 00:16:12,330
then it worked out that anything lower

00:16:08,580 --> 00:16:14,010
than 3 or 8 would fail so 3:08 decides

00:16:12,330 --> 00:16:15,900
is the minimum input and this is

00:16:14,010 --> 00:16:18,840
incredibly useful if you're trying to

00:16:15,900 --> 00:16:21,240
work out what the actual bug is in your

00:16:18,840 --> 00:16:24,450
code so one of the if you want to use

00:16:21,240 --> 00:16:28,140
this one of the annoying things is you

00:16:24,450 --> 00:16:29,460
unless you're using typescript maybe you

00:16:28,140 --> 00:16:33,630
like JavaScript because you don't have

00:16:29,460 --> 00:16:38,450
to write types now you do but if you are

00:16:33,630 --> 00:16:42,650
using some typing then why not just

00:16:38,450 --> 00:16:44,910
infer your generators from your types

00:16:42,650 --> 00:16:46,770
this is the only library I found that

00:16:44,910 --> 00:16:48,270
actually enables you to do this and it's

00:16:46,770 --> 00:16:48,900
for flow I haven't found one for

00:16:48,270 --> 00:16:51,650
typescript

00:16:48,900 --> 00:16:54,090
I'd be curious to know if there is one

00:16:51,650 --> 00:16:56,610
it works like this so you have your flow

00:16:54,090 --> 00:16:58,020
type and it's a babel plugin and it just

00:16:56,610 --> 00:17:01,380
converts it into a function which

00:16:58,020 --> 00:17:02,880
returns a generator for that type so we

00:17:01,380 --> 00:17:04,440
got a person with user name password age

00:17:02,880 --> 00:17:06,720
and this is what it gives us

00:17:04,440 --> 00:17:10,950
this library hasn't been updated in two

00:17:06,720 --> 00:17:13,140
years it's gotten various - dues

00:17:10,950 --> 00:17:15,390
associated with it but I think this is

00:17:13,140 --> 00:17:17,550
an interesting area for people to work

00:17:15,390 --> 00:17:20,930
on there's also this one called jazz for

00:17:17,550 --> 00:17:24,090
joy so you can pass it a joy schema and

00:17:20,930 --> 00:17:25,709
it will use that as a generator so it

00:17:24,090 --> 00:17:28,860
will respect things like your minimum

00:17:25,709 --> 00:17:30,900
and your maximum and it will respect

00:17:28,860 --> 00:17:33,750
various other restrictions you put on

00:17:30,900 --> 00:17:35,190
your joy schema it's not mature and it's

00:17:33,750 --> 00:17:36,720
also not a property based testing

00:17:35,190 --> 00:17:38,160
library it's just a generator so you're

00:17:36,720 --> 00:17:39,480
gonna have to write a custom generator

00:17:38,160 --> 00:17:41,280
for one of the other libraries and plug

00:17:39,480 --> 00:17:42,330
this in if you want to use it but it

00:17:41,280 --> 00:17:47,780
could be a really cool way of testing

00:17:42,330 --> 00:17:47,780
your API endpoints if you use joy

00:17:49,580 --> 00:17:52,760
so writing types is just part of the

00:17:51,710 --> 00:17:54,020
pictures they're actually the really

00:17:52,760 --> 00:17:55,910
hard thing is identifying properties

00:17:54,020 --> 00:17:57,320
because you have to identify properties

00:17:55,910 --> 00:17:59,030
that will hold true no matter whatever

00:17:57,320 --> 00:18:04,420
the no matter what input the function is

00:17:59,030 --> 00:18:06,350
given and that can be a bit tricky

00:18:04,420 --> 00:18:08,840
I'm not going to talk too long about

00:18:06,350 --> 00:18:10,720
this but to give you an example if you

00:18:08,840 --> 00:18:13,460
have an encoder and a decoder functions

00:18:10,720 --> 00:18:14,930
we can just encode and decode and check

00:18:13,460 --> 00:18:16,370
that the output is the same and that's a

00:18:14,930 --> 00:18:18,650
property that's going to be invariant

00:18:16,370 --> 00:18:20,230
but there's various categories you can

00:18:18,650 --> 00:18:24,260
use to help think about this and help

00:18:20,230 --> 00:18:28,040
identify properties right I also want to

00:18:24,260 --> 00:18:31,010
mention this library fast check fast

00:18:28,040 --> 00:18:34,670
check is written by Lee Byron at

00:18:31,010 --> 00:18:37,040
Facebook and it introduces an additional

00:18:34,670 --> 00:18:42,110
feature which is really interesting and

00:18:37,040 --> 00:18:44,750
I think useful so it's called

00:18:42,110 --> 00:18:48,860
model-based tests and it's for testing

00:18:44,750 --> 00:18:52,750
systems that have state such as you eyes

00:18:48,860 --> 00:18:55,100
and what it the way it works is

00:18:52,750 --> 00:18:58,130
basically your random input instead of

00:18:55,100 --> 00:19:00,620
being some kind of data type is an

00:18:58,130 --> 00:19:04,670
operation so you define an operation

00:19:00,620 --> 00:19:06,740
like log login you define a precondition

00:19:04,670 --> 00:19:10,040
for the operation like has to be on the

00:19:06,740 --> 00:19:12,170
login page then you decide define a post

00:19:10,040 --> 00:19:14,630
condition well which is an assertion so

00:19:12,170 --> 00:19:16,310
if I've done this operation then my

00:19:14,630 --> 00:19:20,090
state should reflect the fact that the

00:19:16,310 --> 00:19:21,500
user is logged in and this is great for

00:19:20,090 --> 00:19:23,900
catching those types of bugs that you

00:19:21,500 --> 00:19:25,340
get in you eyes where for example if I

00:19:23,900 --> 00:19:27,380
navigate to the login page and login

00:19:25,340 --> 00:19:29,090
everything's fine but if I go to the

00:19:27,380 --> 00:19:30,830
about page and then to this other page

00:19:29,090 --> 00:19:32,960
and then to the login page for some

00:19:30,830 --> 00:19:36,410
reason I have no idea why now it doesn't

00:19:32,960 --> 00:19:38,270
work because what this will do is take

00:19:36,410 --> 00:19:42,980
your list of operations and create

00:19:38,270 --> 00:19:45,920
random permutations of them and try them

00:19:42,980 --> 00:19:48,380
all and see if any of them break and

00:19:45,920 --> 00:19:51,090
this library might be incorporated into

00:19:48,380 --> 00:19:53,679
just at some point

00:19:51,090 --> 00:19:56,440
okay so what are the problems with these

00:19:53,679 --> 00:19:57,840
Oracle problem solutions the first one

00:19:56,440 --> 00:20:00,280
is they need lots of computing power

00:19:57,840 --> 00:20:03,070
well this isn't so much a problem today

00:20:00,280 --> 00:20:04,990
as a used to be and there are various

00:20:03,070 --> 00:20:07,419
solutions if you really need hardcore

00:20:04,990 --> 00:20:09,880
computing power that last one is

00:20:07,419 --> 00:20:11,890
particularly interesting because they're

00:20:09,880 --> 00:20:14,320
promising a JavaScript implementation of

00:20:11,890 --> 00:20:15,760
AFL but it's a paid service so I don't

00:20:14,320 --> 00:20:17,919
know if it's going to be open source oh

00:20:15,760 --> 00:20:21,490
it's this poses for big open source

00:20:17,919 --> 00:20:24,010
projects and there's a currently private

00:20:21,490 --> 00:20:25,900
service by Microsoft but there's also

00:20:24,010 --> 00:20:28,600
some open source stuff you can look up

00:20:25,900 --> 00:20:31,960
the real problem with these Oracle

00:20:28,600 --> 00:20:33,760
problem solutions is that processing is

00:20:31,960 --> 00:20:36,010
not really well understood as you've

00:20:33,760 --> 00:20:38,620
seen the tooling is kind of Intuit and

00:20:36,010 --> 00:20:40,900
needs work and most significantly the

00:20:38,620 --> 00:20:43,450
payoff is unknown like we really often

00:20:40,900 --> 00:20:45,789
don't know there isn't enough expertise

00:20:43,450 --> 00:20:47,530
within our organisations to say whether

00:20:45,789 --> 00:20:48,909
or not it's worth investing potentially

00:20:47,530 --> 00:20:51,909
a lot of time into setting up these

00:20:48,909 --> 00:20:54,370
various kinds of testing and if you

00:20:51,909 --> 00:20:56,679
think about it what that is is another

00:20:54,370 --> 00:20:59,049
Oracle problem right how do we evaluate

00:20:56,679 --> 00:21:00,460
whether or not our tests how do we test

00:20:59,049 --> 00:21:02,919
whether or not our tests were worthwhile

00:21:00,460 --> 00:21:05,260
okay so it's the Oracle problem Oracle

00:21:02,919 --> 00:21:08,020
problem but this do has a solution that

00:21:05,260 --> 00:21:10,450
solution is mutants there is something

00:21:08,020 --> 00:21:12,909
called mutation testing a mutation

00:21:10,450 --> 00:21:16,270
testing is basically coverage on

00:21:12,909 --> 00:21:18,760
steroids so coverage checks whether or

00:21:16,270 --> 00:21:21,010
not your code has been executed

00:21:18,760 --> 00:21:22,750
crucially it does not test whether or

00:21:21,010 --> 00:21:24,789
not that code has been asserted upon

00:21:22,750 --> 00:21:27,059
which is why it's a notoriously

00:21:24,789 --> 00:21:29,200
unreliable guide to code quality

00:21:27,059 --> 00:21:32,070
mutation testing is designed to do just

00:21:29,200 --> 00:21:34,270
that so how does it work

00:21:32,070 --> 00:21:38,110
instead of mutating your input it

00:21:34,270 --> 00:21:39,789
mutates your actual code so it will do

00:21:38,110 --> 00:21:42,190
stuff like alter return values in your

00:21:39,789 --> 00:21:44,559
functions it will change comparison

00:21:42,190 --> 00:21:47,470
operators to inequality operators and

00:21:44,559 --> 00:21:50,070
then it will check whether the changes

00:21:47,470 --> 00:21:52,750
that it made caused your tests to fail

00:21:50,070 --> 00:21:55,030
if it completely messed up your code

00:21:52,750 --> 00:21:56,440
base and none of your tests fail then

00:21:55,030 --> 00:21:58,740
your tests probably aren't that good I

00:21:56,440 --> 00:22:01,030
think this is a really exciting

00:21:58,740 --> 00:22:02,580
development for some of the tooling and

00:22:01,030 --> 00:22:05,010
testing JavaScript

00:22:02,580 --> 00:22:07,590
and I'd like to see people adopt it so

00:22:05,010 --> 00:22:10,620
we can work out if it's if even this

00:22:07,590 --> 00:22:13,380
mutation testing is useful for the

00:22:10,620 --> 00:22:15,120
JavaScript currently there's only really

00:22:13,380 --> 00:22:18,840
one library which allows you to do it I

00:22:15,120 --> 00:22:21,059
wouldn't say it's mature but it's got

00:22:18,840 --> 00:22:23,640
quite a lot of effort behind it so you

00:22:21,059 --> 00:22:28,350
can use it you can definitely try it out

00:22:23,640 --> 00:22:32,779
now I'd recommend it yeah and let's work

00:22:28,350 --> 00:22:35,920
out whether first testing is worthwhile

00:22:32,779 --> 00:22:39,650
thank you

00:22:35,920 --> 00:22:39,650

YouTube URL: https://www.youtube.com/watch?v=x6zh3HRMl3U


