Title: Django Miniconf: Closing Keynote by Tony Morris
Publication date: 2014-08-09
Playlist: PyCon Australia 2014 Django MiniConf
Description: 
	PyCon Australia is the national conference for users of the Python Programming Language. In August 2014, we're heading to Brisbane to bring together students, enthusiasts, and professionals with a love of Python from around Australia, and all around the World. 

August 1-5, Brisbane, Queensland, Australia
Captions: 
	00:00:03,600 --> 00:00:10,410
duh he's been invited specifically

00:00:06,810 --> 00:00:12,780
because he hates us or possibly hates us

00:00:10,410 --> 00:00:15,059
a little bit I don't know how many of

00:00:12,780 --> 00:00:16,350
you are aware Django Khan has a long

00:00:15,059 --> 00:00:18,960
tradition that stems back to the very

00:00:16,350 --> 00:00:20,880
first django con us of inviting people

00:00:18,960 --> 00:00:22,679
who aren't part of our community to come

00:00:20,880 --> 00:00:24,150
and tell us what we're doing wrong or at

00:00:22,679 --> 00:00:25,529
least what they're doing differently and

00:00:24,150 --> 00:00:28,289
why they don't like us because of it

00:00:25,529 --> 00:00:30,210
that started the very first example that

00:00:28,289 --> 00:00:31,439
was a guy called Cal Henderson who was

00:00:30,210 --> 00:00:32,460
one of the founders of Flickr and he

00:00:31,439 --> 00:00:35,520
gradually literally gave the keynote

00:00:32,460 --> 00:00:37,260
entitled why I hate Django it is worth

00:00:35,520 --> 00:00:38,430
going and watching it's a six year old

00:00:37,260 --> 00:00:40,500
seven year old talk at this point it is

00:00:38,430 --> 00:00:42,090
probably one of the best lectures I've

00:00:40,500 --> 00:00:44,520
ever seen let alone lectures about

00:00:42,090 --> 00:00:46,559
Django it is a fantastic example of a

00:00:44,520 --> 00:00:49,559
will give and talk completely aside from

00:00:46,559 --> 00:00:51,270
anything else so today we've got Toni

00:00:49,559 --> 00:00:52,949
Morrison Toni amorous is very big in the

00:00:51,270 --> 00:00:54,989
local high school and functional

00:00:52,949 --> 00:00:56,879
programming communities and he's here to

00:00:54,989 --> 00:00:59,010
tell us about what we can learn as a

00:00:56,879 --> 00:01:00,420
Python community about what we should

00:00:59,010 --> 00:01:01,739
know about Haskell or we should know

00:01:00,420 --> 00:01:04,110
about functioning functional programming

00:01:01,739 --> 00:01:05,489
and hopefully we can take some of that

00:01:04,110 --> 00:01:08,700
knowledge and work out maybe how we can

00:01:05,489 --> 00:01:15,390
Python a little bit better so Toni Toni

00:01:08,700 --> 00:01:16,560
Morris thank you okay so thank you

00:01:15,390 --> 00:01:21,180
everyone for inviting me to your

00:01:16,560 --> 00:01:22,950
conference I don't hate you so I do

00:01:21,180 --> 00:01:24,840
think we could we could all be doing

00:01:22,950 --> 00:01:27,720
things a lot better so I'm here to tell

00:01:24,840 --> 00:01:31,530
you what how I think you could do data

00:01:27,720 --> 00:01:33,450
so it when I you know when I have a

00:01:31,530 --> 00:01:34,950
disagreement which I think we might what

00:01:33,450 --> 00:01:36,810
I'd like to do is establish the common

00:01:34,950 --> 00:01:38,820
goals the things that we we currently

00:01:36,810 --> 00:01:42,750
agree on so first of all I'd like to do

00:01:38,820 --> 00:01:44,759
that so the goal being I want to arrive

00:01:42,750 --> 00:01:46,890
at an initial result of my programming

00:01:44,759 --> 00:01:49,469
as quickly as possible and I want it to

00:01:46,890 --> 00:01:53,490
work I want my program to work so if we

00:01:49,469 --> 00:01:54,750
agree on this then we are we've got a

00:01:53,490 --> 00:01:57,149
premise on which to start an argument

00:01:54,750 --> 00:02:00,299
okay so and I'm going to demonstrate to

00:01:57,149 --> 00:02:02,280
you that there's certain tools out there

00:02:00,299 --> 00:02:04,229
that are necessary to achieve these

00:02:02,280 --> 00:02:09,539
goals which unfortunately you don't have

00:02:04,229 --> 00:02:11,190
so I'm going to put aside other goals so

00:02:09,539 --> 00:02:13,350
if you say to me but I make lots of

00:02:11,190 --> 00:02:15,060
money doing this or arm it makes me feel

00:02:13,350 --> 00:02:16,410
nice that's good they're just not the

00:02:15,060 --> 00:02:17,430
goals that I want to talk about I just

00:02:16,410 --> 00:02:20,250
want to put that aside

00:02:17,430 --> 00:02:21,629
so I could tell you why Django sucks I

00:02:20,250 --> 00:02:22,950
could sit here and tell you and I think

00:02:21,629 --> 00:02:24,030
the conversation would go something like

00:02:22,950 --> 00:02:25,890
this

00:02:24,030 --> 00:02:29,189
I don't think we be very productive at

00:02:25,890 --> 00:02:32,099
all I would just be sitting here saying

00:02:29,189 --> 00:02:35,129
true things at you and I would be not

00:02:32,099 --> 00:02:36,930
not saying helpful things at you so I'm

00:02:35,129 --> 00:02:38,129
going to switch it a little bit and I'm

00:02:36,930 --> 00:02:40,650
gonna I'm just gonna try and give you

00:02:38,129 --> 00:02:43,980
the tools to work out and answer the

00:02:40,650 --> 00:02:46,349
question for yourself so these are

00:02:43,980 --> 00:02:50,489
hopefully new tools to or if they're not

00:02:46,349 --> 00:02:51,750
if you've seen before that's great that

00:02:50,489 --> 00:02:53,010
there's not there's not that many people

00:02:51,750 --> 00:02:54,780
in the room so if you do have questions

00:02:53,010 --> 00:02:57,659
please let me know along the way it's

00:02:54,780 --> 00:03:00,379
it's sort of a build up of knowledge I'm

00:02:57,659 --> 00:03:04,739
fine to take questions along the way so

00:03:00,379 --> 00:03:09,060
I used to use Python for about four

00:03:04,739 --> 00:03:10,620
weeks I quit while I was there I learned

00:03:09,060 --> 00:03:13,170
about some of the lies that you've been

00:03:10,620 --> 00:03:13,769
told because they were being thrown at

00:03:13,170 --> 00:03:17,939
my head

00:03:13,769 --> 00:03:20,939
by my colleagues so here are some of

00:03:17,939 --> 00:03:22,379
them like having to come to grips with

00:03:20,939 --> 00:03:28,230
Manos just isn't worth it for some

00:03:22,379 --> 00:03:29,940
people this is not even false so there's

00:03:28,230 --> 00:03:31,230
this idea of dichotomous thinking like

00:03:29,940 --> 00:03:33,090
there's this imperative programming

00:03:31,230 --> 00:03:34,440
which is maybe what you think you do and

00:03:33,090 --> 00:03:37,230
in this functional program which is what

00:03:34,440 --> 00:03:39,569
I do that's just CIL's that

00:03:37,230 --> 00:03:41,340
there's actually they they you can do

00:03:39,569 --> 00:03:45,599
both at the same time I'll show you how

00:03:41,340 --> 00:03:47,010
to do that and I asked someone out in

00:03:45,599 --> 00:03:49,919
the hall arm is the real world mutable

00:03:47,010 --> 00:03:51,690
or immutable and and I get one of two

00:03:49,919 --> 00:03:52,680
answers this question it's either yes it

00:03:51,690 --> 00:03:55,290
is mutable and there's absolutely

00:03:52,680 --> 00:03:58,079
confidence in it in this fact and

00:03:55,290 --> 00:04:00,870
there's not sure no one's ever confident

00:03:58,079 --> 00:04:02,909
about the fact that it's immutable I'll

00:04:00,870 --> 00:04:04,849
tell you why that's not true so I

00:04:02,909 --> 00:04:12,419
thought this was funny

00:04:04,849 --> 00:04:13,379
you probably don't but I do so so here's

00:04:12,419 --> 00:04:15,419
what I'm going to do is I'm going to

00:04:13,379 --> 00:04:17,729
tell you what is functional programming

00:04:15,419 --> 00:04:18,930
this is what I do in my job I work for

00:04:17,729 --> 00:04:21,359
an organization called nikto the

00:04:18,930 --> 00:04:24,210
National ICT of Australia just across

00:04:21,359 --> 00:04:26,340
the river I use function programming all

00:04:24,210 --> 00:04:28,200
day my colleagues do I help them do so

00:04:26,340 --> 00:04:30,900
I'm going to tell you about this thing

00:04:28,200 --> 00:04:33,150
called Mon add maybe some of you this

00:04:30,900 --> 00:04:35,340
and if you have I'm sorry about the

00:04:33,150 --> 00:04:36,570
results that you got and I'll tell you

00:04:35,340 --> 00:04:38,460
about functional imperative programming

00:04:36,570 --> 00:04:40,050
just to sort of destroy this dichotomy

00:04:38,460 --> 00:04:41,730
that exists and then I'm going to tell

00:04:40,050 --> 00:04:44,430
you about something that I find really

00:04:41,730 --> 00:04:45,990
useful and if you sort of invest the

00:04:44,430 --> 00:04:47,940
effort to explore it I think you will

00:04:45,990 --> 00:04:50,910
learn that it's very useful to you

00:04:47,940 --> 00:04:55,430
called parametric City so what is

00:04:50,910 --> 00:04:55,430
functional programming well what is it

00:04:55,610 --> 00:04:59,730
what does it mean in principle I like to

00:04:57,960 --> 00:05:00,930
like divide this question into two

00:04:59,730 --> 00:05:02,370
questions and that is what does it

00:05:00,930 --> 00:05:04,620
actually mean in terms of its

00:05:02,370 --> 00:05:06,120
fundamental definition and then what are

00:05:04,620 --> 00:05:08,820
the practical consequences of this

00:05:06,120 --> 00:05:10,740
principle so what does it mean it's

00:05:08,820 --> 00:05:13,740
programming with functions that's quite

00:05:10,740 --> 00:05:16,350
boring however what is a function okay

00:05:13,740 --> 00:05:19,560
so what is what does it even mean to be

00:05:16,350 --> 00:05:22,050
a function so a function relates every

00:05:19,560 --> 00:05:25,170
argument to a result and it does nothing

00:05:22,050 --> 00:05:26,760
else that's what a function does import

00:05:25,170 --> 00:05:28,230
the and nothing else part is an

00:05:26,760 --> 00:05:30,480
absolutely essential part of that

00:05:28,230 --> 00:05:32,550
definition okay so we know what a

00:05:30,480 --> 00:05:33,660
function is and then I'm going to use

00:05:32,550 --> 00:05:36,300
this term called referential

00:05:33,660 --> 00:05:39,900
transparency if you sort of Google you

00:05:36,300 --> 00:05:42,150
might see it abbreviated RT so it says

00:05:39,900 --> 00:05:43,770
it's quite a mouthful I'll demonstrate

00:05:42,150 --> 00:05:46,530
what it means but it says then an

00:05:43,770 --> 00:05:48,210
expression in a program which I've

00:05:46,530 --> 00:05:50,340
labeled expr is referentially

00:05:48,210 --> 00:05:52,650
transparently in all programs call them

00:05:50,340 --> 00:05:54,990
PE all occurrences of that expression

00:05:52,650 --> 00:05:57,360
can be replaced with its value and the

00:05:54,990 --> 00:05:59,730
program remains unchanged that's what

00:05:57,360 --> 00:06:01,080
referentially transparent means and I'm

00:05:59,730 --> 00:06:03,570
going to tie that back to functional

00:06:01,080 --> 00:06:07,530
program in just a minute so here's a

00:06:03,570 --> 00:06:08,970
Python program so it's it's kind of it's

00:06:07,530 --> 00:06:11,310
not like it's just a trivial sort of

00:06:08,970 --> 00:06:12,870
example and so the question is is this

00:06:11,310 --> 00:06:16,170
expression here referentially

00:06:12,870 --> 00:06:18,390
transparent and that is to say can we do

00:06:16,170 --> 00:06:20,190
this can we take this expression and in

00:06:18,390 --> 00:06:23,310
every learn the program replace it with

00:06:20,190 --> 00:06:25,380
its value I think I've got a mistake oh

00:06:23,310 --> 00:06:27,000
no that's right sorry I replaced with

00:06:25,380 --> 00:06:29,010
its value and the program remains

00:06:27,000 --> 00:06:30,650
unchanged and and we if you sort of

00:06:29,010 --> 00:06:32,760
assume that this program goes on forever

00:06:30,650 --> 00:06:34,980
you know for a long time and everywhere

00:06:32,760 --> 00:06:37,290
that X appears we replace it with this

00:06:34,980 --> 00:06:40,020
expression and we ask this question has

00:06:37,290 --> 00:06:42,690
the program change in doing this and if

00:06:40,020 --> 00:06:44,460
the answer's no then that expression is

00:06:42,690 --> 00:06:47,460
referentially transparent

00:06:44,460 --> 00:06:49,440
okay so here's a real example and this

00:06:47,460 --> 00:06:51,810
is this is just a one that I sort of

00:06:49,440 --> 00:06:54,270
wrote and says well this expression here

00:06:51,810 --> 00:06:57,090
is it referentially transparent and that

00:06:54,270 --> 00:07:01,800
is to say no matter what this is can I

00:06:57,090 --> 00:07:03,720
replace X with this expression here did

00:07:01,800 --> 00:07:06,990
the program change and the answer is no

00:07:03,720 --> 00:07:09,570
in fact no matter what I do in this

00:07:06,990 --> 00:07:11,220
print - it could do anything I could you

00:07:09,570 --> 00:07:12,570
know could appear in further down in the

00:07:11,220 --> 00:07:14,460
program and so on as long as I just keep

00:07:12,570 --> 00:07:17,010
replacing it the answer to the question

00:07:14,460 --> 00:07:18,420
has the program change remains no that's

00:07:17,010 --> 00:07:20,820
because this expression is referentially

00:07:18,420 --> 00:07:23,880
transparent so what about this

00:07:20,820 --> 00:07:27,410
expression is it referentially

00:07:23,880 --> 00:07:30,600
transparent did this change the program

00:07:27,410 --> 00:07:32,040
any any guesses it did right it did this

00:07:30,600 --> 00:07:35,730
is not a referentially transparent

00:07:32,040 --> 00:07:38,130
expression it's changed the program so

00:07:35,730 --> 00:07:40,140
the essence of functional program the

00:07:38,130 --> 00:07:42,360
actual definition is the demand that all

00:07:40,140 --> 00:07:45,330
things are referentially transparent so

00:07:42,360 --> 00:07:48,470
back here we have violated the thesis of

00:07:45,330 --> 00:07:50,640
functional programming that's all it is

00:07:48,470 --> 00:07:52,050
I'm sure that if you google that you've

00:07:50,640 --> 00:07:54,900
come up with some things that say that

00:07:52,050 --> 00:07:55,680
other things they're just not true as

00:07:54,900 --> 00:07:59,630
simple as that

00:07:55,680 --> 00:08:01,800
there's so much nonsense out there so

00:07:59,630 --> 00:08:03,750
reference to transparency so I'm now

00:08:01,800 --> 00:08:06,240
gonna just make a claim which is simply

00:08:03,750 --> 00:08:08,370
this idea of referential transparency

00:08:06,240 --> 00:08:10,140
gives us gives rise these other two

00:08:08,370 --> 00:08:12,600
ideas which is equational reasoning and

00:08:10,140 --> 00:08:13,890
modularity okay say if you're going to

00:08:12,600 --> 00:08:15,240
talk to me about modularity you must

00:08:13,890 --> 00:08:16,500
also be talking about referential

00:08:15,240 --> 00:08:21,990
transparency otherwise I'll just think

00:08:16,500 --> 00:08:22,950
you're lying so it's it's independent of

00:08:21,990 --> 00:08:25,620
any programming language

00:08:22,950 --> 00:08:26,940
all right so someone goes well you know

00:08:25,620 --> 00:08:28,890
your functional programming over there

00:08:26,940 --> 00:08:29,940
in Haskell I'm doing my my fancy thing

00:08:28,890 --> 00:08:31,650
over here and some other than not

00:08:29,940 --> 00:08:33,330
Haskell thing it's not true

00:08:31,650 --> 00:08:35,040
I'm you can't do functional programming

00:08:33,330 --> 00:08:36,440
in any language some languages have

00:08:35,040 --> 00:08:39,320
really good support for doing it

00:08:36,440 --> 00:08:41,310
somewhat - just don't

00:08:39,320 --> 00:08:42,540
unfortunately so it's kind of it's

00:08:41,310 --> 00:08:43,650
independent of the language even though

00:08:42,540 --> 00:08:48,690
the language just assist you to get

00:08:43,650 --> 00:08:50,190
there so and yeah I repeat I'm sorry

00:08:48,690 --> 00:08:55,230
about the global result that you might

00:08:50,190 --> 00:08:56,460
get so that there is this question in

00:08:55,230 --> 00:08:58,050
the four weeks that I spent writing

00:08:56,460 --> 00:08:58,410
Python I wanted to know the answer this

00:08:58,050 --> 00:09:00,720
question

00:08:58,410 --> 00:09:02,040
I've spent more time after those four

00:09:00,720 --> 00:09:04,759
weeks trying to answer this question

00:09:02,040 --> 00:09:09,329
does Python help me get to this goal

00:09:04,759 --> 00:09:12,750
no it's simply no and to have the code

00:09:09,329 --> 00:09:14,160
to prove it it's just simply not true

00:09:12,750 --> 00:09:16,500
if anyone tells you they're doing

00:09:14,160 --> 00:09:19,829
functional programming in Python they're

00:09:16,500 --> 00:09:21,660
not telling the truth I don't mean I'd

00:09:19,829 --> 00:09:25,439
like to be debunked on that I've not

00:09:21,660 --> 00:09:26,850
seen it so oh well we can't do equation

00:09:25,439 --> 00:09:29,670
or reasoning or we can't do referential

00:09:26,850 --> 00:09:33,149
transparency in this sort of non-trivial

00:09:29,670 --> 00:09:35,430
way so you've all gone this tool when

00:09:33,149 --> 00:09:36,779
you use Python we've forgotten the

00:09:35,430 --> 00:09:38,430
equation of reasoning of modularity when

00:09:36,779 --> 00:09:41,279
we use Python I'll show you what

00:09:38,430 --> 00:09:43,680
equation or reasoning is in just a

00:09:41,279 --> 00:09:45,930
minute so I'll move on to now what does

00:09:43,680 --> 00:09:52,620
in 1 AD mean has anyone googled the word

00:09:45,930 --> 00:09:54,959
my lad did I say not to I'm sure I have

00:09:52,620 --> 00:10:02,629
said that yes well what was the answer

00:09:54,959 --> 00:10:02,629
you got something like that

00:10:03,660 --> 00:10:10,300
I'm sorry I'll tell you what it means

00:10:07,980 --> 00:10:11,770
I'm not doing it for the purpose of Tony

00:10:10,300 --> 00:10:13,990
what it means I'm doing it to tell you

00:10:11,770 --> 00:10:15,310
that it's a very simple concept and that

00:10:13,990 --> 00:10:17,530
there are examples out there in the

00:10:15,310 --> 00:10:20,590
world that have all this mystique about

00:10:17,530 --> 00:10:22,480
them that are in fact really simple I'm

00:10:20,590 --> 00:10:24,040
gonna put up a challenge here I'm gonna

00:10:22,480 --> 00:10:26,380
I'm gonna claim that I can tell you what

00:10:24,040 --> 00:10:31,870
it is in 10 minutes and you will

00:10:26,380 --> 00:10:33,580
understand it right so a monad is based

00:10:31,870 --> 00:10:37,320
on the principles of abstraction what

00:10:33,580 --> 00:10:39,970
are the principles of abstraction so

00:10:37,320 --> 00:10:42,970
well what we do is we come up with an

00:10:39,970 --> 00:10:44,410
abstraction and then we try and maximize

00:10:42,970 --> 00:10:45,850
the number of instances that satisfy

00:10:44,410 --> 00:10:47,470
that abstraction so we've got this sort

00:10:45,850 --> 00:10:49,390
of general case and we try and maximize

00:10:47,470 --> 00:10:50,860
that then we try and maximize the number

00:10:49,390 --> 00:10:53,890
of operations that we derive from that

00:10:50,860 --> 00:10:55,630
so a good example might be I don't know

00:10:53,890 --> 00:10:57,070
you can compare two elements for

00:10:55,630 --> 00:10:59,530
ordering and there's many many things

00:10:57,070 --> 00:11:01,630
that satisfy this this this interface

00:10:59,530 --> 00:11:03,610
this abstraction and then there's many

00:11:01,630 --> 00:11:04,870
other things many operations that derive

00:11:03,610 --> 00:11:07,210
from that like sorting a list of these

00:11:04,870 --> 00:11:10,240
things so this is this is just a

00:11:07,210 --> 00:11:13,600
principle distraction and we trade off

00:11:10,240 --> 00:11:15,550
okay so if we have like another another

00:11:13,600 --> 00:11:18,400
abstraction like comparing for equality

00:11:15,550 --> 00:11:19,780
all things that compare for ordering can

00:11:18,400 --> 00:11:21,580
be compared for equality but not the

00:11:19,780 --> 00:11:23,380
other way around which means that we

00:11:21,580 --> 00:11:25,630
forego some operations so if you only

00:11:23,380 --> 00:11:26,650
satisfy equality well then you do can't

00:11:25,630 --> 00:11:27,850
sort a list of these things you have

00:11:26,650 --> 00:11:30,670
some other operations so there's this

00:11:27,850 --> 00:11:31,750
sort of contention between the number of

00:11:30,670 --> 00:11:33,850
instances in a number of derived

00:11:31,750 --> 00:11:35,530
operations between abstractions so these

00:11:33,850 --> 00:11:38,710
are just some sort of principles when we

00:11:35,530 --> 00:11:41,080
sit down to derive abstractions kind of

00:11:38,710 --> 00:11:43,030
processes that we go through and the

00:11:41,080 --> 00:11:45,610
goal is through is to avoid repetition

00:11:43,030 --> 00:11:47,140
of work who wants to reverse lists of

00:11:45,610 --> 00:11:48,340
the same thing over and over or sort

00:11:47,140 --> 00:11:50,050
lists of the same thing over and over

00:11:48,340 --> 00:11:56,170
not me

00:11:50,050 --> 00:11:57,580
and unfortunately some people some

00:11:56,170 --> 00:11:58,960
abstractions are just false economies

00:11:57,580 --> 00:12:00,730
they give you no benefit in either

00:11:58,960 --> 00:12:01,990
direction so this should just be thrown

00:12:00,730 --> 00:12:06,490
away this is like the process of

00:12:01,990 --> 00:12:08,410
revision so unfortunately we cannot

00:12:06,490 --> 00:12:10,450
express them and I was having

00:12:08,410 --> 00:12:12,280
conversation out in the hall I'm you

00:12:10,450 --> 00:12:16,270
know hey you know can you show me this

00:12:12,280 --> 00:12:17,230
in c-sharp I don't know I cannot and I

00:12:16,270 --> 00:12:18,430
cannot

00:12:17,230 --> 00:12:21,480
can't do without a static type system

00:12:18,430 --> 00:12:24,250
either it's just simply not practical so

00:12:21,480 --> 00:12:28,390
unfortunately I must now tell you what

00:12:24,250 --> 00:12:31,120
this code means is that okay all right

00:12:28,390 --> 00:12:33,130
so you've probably seen the class

00:12:31,120 --> 00:12:35,710
keyword in other programming languages

00:12:33,130 --> 00:12:38,080
in Haskell it means that it's and it's

00:12:35,710 --> 00:12:39,570
going to give some abstract members so

00:12:38,080 --> 00:12:41,530
like an interface or something and

00:12:39,570 --> 00:12:43,300
basically this is an abstract interface

00:12:41,530 --> 00:12:47,950
with two operations this one here I'll

00:12:43,300 --> 00:12:51,520
pronounce bind okay and it says bind has

00:12:47,950 --> 00:12:57,910
the type given a function from A to F D

00:12:51,520 --> 00:12:59,710
and an F of a return and FB so an

00:12:57,910 --> 00:13:01,270
example might be list given a function

00:12:59,710 --> 00:13:03,760
well we're sorry we're F equals list so

00:13:01,270 --> 00:13:05,500
given a function ate a list of V and a

00:13:03,760 --> 00:13:08,620
list of a return a list of thee what

00:13:05,500 --> 00:13:11,470
would this do for a list well if it's

00:13:08,620 --> 00:13:13,360
got a list of a for every a in the list

00:13:11,470 --> 00:13:15,730
and run this function and get a list of

00:13:13,360 --> 00:13:18,280
B which will give me a list of list of V

00:13:15,730 --> 00:13:20,980
and then collapse it they'll give me a

00:13:18,280 --> 00:13:23,620
list of B and return it so this is

00:13:20,980 --> 00:13:24,850
called the list monad there's a second

00:13:23,620 --> 00:13:26,950
operation which is a trivial one it just

00:13:24,850 --> 00:13:28,480
says given an element given a value put

00:13:26,950 --> 00:13:32,470
it inside the F context put it in the

00:13:28,480 --> 00:13:35,500
list so all the one out abstraction does

00:13:32,470 --> 00:13:38,590
is it's abstracting on the F nests so F

00:13:35,500 --> 00:13:41,200
could be list F could be many of the

00:13:38,590 --> 00:13:43,090
other things here's all these things

00:13:41,200 --> 00:13:45,190
well not all them not even close

00:13:43,090 --> 00:13:47,860
there's millions of them so it could be

00:13:45,190 --> 00:13:50,650
a list or continuations or state or ir

00:13:47,860 --> 00:13:53,350
actions or you know all the different

00:13:50,650 --> 00:13:55,870
possible values for F form on add and we

00:13:53,350 --> 00:13:57,430
get operations that derived from them

00:13:55,870 --> 00:13:59,260
such as this one here is called sequence

00:13:57,430 --> 00:14:05,320
that is given this says given a list of

00:13:59,260 --> 00:14:06,760
F of a then produce an F of list of a so

00:14:05,320 --> 00:14:08,980
I can derive this operation from the

00:14:06,760 --> 00:14:12,520
fact that all F satisfy the Mon add

00:14:08,980 --> 00:14:15,040
interface so even though maybe that's a

00:14:12,520 --> 00:14:16,600
little bit fuzzy at least try to

00:14:15,040 --> 00:14:18,850
understand the motivation here which is

00:14:16,600 --> 00:14:20,560
simply we have an abstraction and we can

00:14:18,850 --> 00:14:22,330
derive many operations from that

00:14:20,560 --> 00:14:23,500
abstraction to save it's repeating code

00:14:22,330 --> 00:14:25,840
for all the other things that that

00:14:23,500 --> 00:14:29,320
things satisfies that's why my nod

00:14:25,840 --> 00:14:30,819
exists so for those who say my nod might

00:14:29,320 --> 00:14:33,249
not be useful for me

00:14:30,819 --> 00:14:36,789
actually saying I like route writing the

00:14:33,249 --> 00:14:38,739
same code over and over again pick one

00:14:36,789 --> 00:14:42,249
of these two is the only thing I can

00:14:38,739 --> 00:14:43,449
respond with so we've seen the

00:14:42,249 --> 00:14:45,669
constraints so that's those two

00:14:43,449 --> 00:14:48,429
operations 1/8 is an abstraction it has

00:14:45,669 --> 00:14:51,639
these two these two operations that must

00:14:48,429 --> 00:14:53,829
be satisfied we've seen the instances or

00:14:51,639 --> 00:14:56,709
we have listed them they you know like

00:14:53,829 --> 00:14:58,629
list and continuations and i/o and state

00:14:56,709 --> 00:15:01,679
passing and so on and in there's

00:14:58,629 --> 00:15:05,319
operations that derive from them and

00:15:01,679 --> 00:15:07,749
this is like a tacit attack on the

00:15:05,319 --> 00:15:10,869
Google results that you'll get these are

00:15:07,749 --> 00:15:12,429
all mixed up okay so I'm onna add is an

00:15:10,869 --> 00:15:14,379
abstraction it saves us from repeating

00:15:12,429 --> 00:15:17,529
code there's nothing to do with Haskell

00:15:14,379 --> 00:15:19,749
by the way I've written this in c-sharp

00:15:17,529 --> 00:15:24,489
it affects the shots got it in there in

00:15:19,749 --> 00:15:26,229
the syntax so here I'm going to give you

00:15:24,489 --> 00:15:27,879
some vocabulary rather than explain

00:15:26,229 --> 00:15:29,109
something so if you google and you come

00:15:27,879 --> 00:15:32,049
across my node you might also come

00:15:29,109 --> 00:15:34,809
across these works you know semigroup

00:15:32,049 --> 00:15:37,269
boy well what's a semigroup load well

00:15:34,809 --> 00:15:39,939
it's just a different trade-off in terms

00:15:37,269 --> 00:15:42,609
of the you know instances versus number

00:15:39,939 --> 00:15:43,720
of derived operations well we can't just

00:15:42,609 --> 00:15:46,239
use in one adds everywhere

00:15:43,720 --> 00:15:47,799
not everything's monad we have to sort

00:15:46,239 --> 00:15:49,749
of forego some things to gain some other

00:15:47,799 --> 00:15:52,269
things semigroup load will help us get

00:15:49,749 --> 00:15:56,229
there and claim one out let's comb on it

00:15:52,269 --> 00:15:57,970
what's coeval mean these are all really

00:15:56,229 --> 00:16:00,069
trivial answers to these questions I'm

00:15:57,970 --> 00:16:03,850
happy to do so by the way like I said

00:16:00,069 --> 00:16:05,229
I'm only just across the river so please

00:16:03,850 --> 00:16:07,919
don't be scared of these words is my

00:16:05,229 --> 00:16:12,029
point I'm that they're helpful words

00:16:07,919 --> 00:16:12,029
friendly cuddly words look at them

00:16:12,459 --> 00:16:22,160
embrace them it'll help you get to your

00:16:15,680 --> 00:16:25,220
solutions so I you know I'm here to sort

00:16:22,160 --> 00:16:26,360
of be a little bit mean so I'm going to

00:16:25,220 --> 00:16:28,399
do that now I'm going to tell you about

00:16:26,360 --> 00:16:30,949
some of the bullcrap here we go

00:16:28,399 --> 00:16:32,059
my eyes of a side effects their name on

00:16:30,949 --> 00:16:33,410
Google mine out I bet you that's their

00:16:32,059 --> 00:16:36,470
right it's there it's in the top ten

00:16:33,410 --> 00:16:39,709
it's gotta be it's for

00:16:36,470 --> 00:16:40,699
functional programming know for doing I

00:16:39,709 --> 00:16:44,449
know

00:16:40,699 --> 00:16:46,399
did you see i/o back there no not only

00:16:44,449 --> 00:16:51,559
it not in the constraint just simply

00:16:46,399 --> 00:16:56,110
supports behind and unit yes they do you

00:16:51,559 --> 00:17:02,120
just didn't notice yes they will and

00:16:56,110 --> 00:17:04,250
that's bullcrap all of it I'm trying to

00:17:02,120 --> 00:17:05,600
arm you here with a vocabulary alright

00:17:04,250 --> 00:17:09,289
so if you do want to go and discover

00:17:05,600 --> 00:17:11,480
these concepts just be aware that that's

00:17:09,289 --> 00:17:12,530
just not true it literally is the thing

00:17:11,480 --> 00:17:14,059
that I just showed you it's that

00:17:12,530 --> 00:17:15,559
abstraction with those two constraints

00:17:14,059 --> 00:17:18,140
with derived operations and derived

00:17:15,559 --> 00:17:20,390
instances it's nothing else it's not a

00:17:18,140 --> 00:17:21,860
mystical thing that you know people

00:17:20,390 --> 00:17:23,750
meditate on the top of mountains of day

00:17:21,860 --> 00:17:30,760
it's none of this stuff it's just an

00:17:23,750 --> 00:17:33,679
abstraction so don't believe them so

00:17:30,760 --> 00:17:34,909
probably can achieve this right how does

00:17:33,679 --> 00:17:36,649
it achieve it well it does duck typing

00:17:34,909 --> 00:17:38,750
you see you know do you support bind if

00:17:36,649 --> 00:17:41,980
it does and if it doesn't then explode

00:17:38,750 --> 00:17:44,960
and so on right this is what Python does

00:17:41,980 --> 00:17:50,360
however you will never see these in

00:17:44,960 --> 00:17:52,370
Python or actually I have seen them I've

00:17:50,360 --> 00:17:54,049
seen people write mine out in Python but

00:17:52,370 --> 00:17:57,049
mine as the first base in abstraction

00:17:54,049 --> 00:17:58,309
it's just you know let's get started

00:17:57,049 --> 00:18:01,039
doing abstraction because there's many

00:17:58,309 --> 00:18:02,149
more right why don't you see them in

00:18:01,039 --> 00:18:05,350
Python I'm just going to leave that

00:18:02,149 --> 00:18:07,419
question with you I I have my answer so

00:18:05,350 --> 00:18:11,559
why don't you see these sort of

00:18:07,419 --> 00:18:11,559
non-trivial abstractions in Python

00:18:14,860 --> 00:18:23,470
functionally imperative programming so

00:18:20,520 --> 00:18:24,820
the goal of this I mean I don't often

00:18:23,470 --> 00:18:26,260
talk about functional imperative

00:18:24,820 --> 00:18:28,049
programming the reason I wanted to all

00:18:26,260 --> 00:18:30,549
about it is because I typed into Google

00:18:28,049 --> 00:18:32,710
functional programming how to you know -

00:18:30,549 --> 00:18:34,510
how do people understand functional

00:18:32,710 --> 00:18:36,910
programming and this dichotomy came up

00:18:34,510 --> 00:18:38,260
that we know there's imperative for a

00:18:36,910 --> 00:18:41,710
gaming this functional programming it's

00:18:38,260 --> 00:18:43,299
not true so I'm going to put a side

00:18:41,710 --> 00:18:47,320
object around programming I don't know

00:18:43,299 --> 00:18:48,520
what it is and neither do you so I'm

00:18:47,320 --> 00:18:52,830
just going to tell you a bit of an actor

00:18:48,520 --> 00:18:55,450
okay so I was in a pub not too long ago

00:18:52,830 --> 00:18:58,470
and I don't remember the details it was

00:18:55,450 --> 00:19:01,630
something like this something like that

00:18:58,470 --> 00:19:04,150
maybe a little bit different but you

00:19:01,630 --> 00:19:08,020
know and I said oh yeah hey going as you

00:19:04,150 --> 00:19:09,460
do and he said functional programming is

00:19:08,020 --> 00:19:10,660
great and all but I only use state where

00:19:09,460 --> 00:19:13,240
it is appropriate you know when the

00:19:10,660 --> 00:19:14,740
problem demands stateful things and I

00:19:13,240 --> 00:19:16,030
hadn't heard this in a long time you

00:19:14,740 --> 00:19:18,190
know I'm in a bit of a bubble over there

00:19:16,030 --> 00:19:21,100
I just do functional programming all day

00:19:18,190 --> 00:19:24,340
and people say that to me this is what

00:19:21,100 --> 00:19:26,470
happens in my brain and there's a reason

00:19:24,340 --> 00:19:31,929
for that and it's because there's no

00:19:26,470 --> 00:19:33,610
such thing it's a projection what about

00:19:31,929 --> 00:19:36,130
those programs that for algorithms that

00:19:33,610 --> 00:19:39,910
demand imperative programming they

00:19:36,130 --> 00:19:41,470
inherently stateful they tell me the

00:19:39,910 --> 00:19:42,660
church-turing thesis tells us that this

00:19:41,470 --> 00:19:45,040
is

00:19:42,660 --> 00:19:46,690
the chair sharing thesis tells us that

00:19:45,040 --> 00:19:48,220
the pure lambda calculus is Turing

00:19:46,690 --> 00:19:50,590
complete every program that you've ever

00:19:48,220 --> 00:19:52,480
written I can go ahead and I can remove

00:19:50,590 --> 00:19:54,850
that inherent state and have exactly the

00:19:52,480 --> 00:19:56,950
same program it's possible in fact

00:19:54,850 --> 00:19:58,210
that's what we do in Haskell we just

00:19:56,950 --> 00:20:00,370
don't do the transition we just start

00:19:58,210 --> 00:20:02,919
off there so there is no such thing as

00:20:00,370 --> 00:20:05,230
inherently stateful so if that came up

00:20:02,919 --> 00:20:08,620
in your top 10 Google results just put

00:20:05,230 --> 00:20:10,090
that one aside it's not true I'm going

00:20:08,620 --> 00:20:14,080
to show you why I'm going to show an

00:20:10,090 --> 00:20:15,460
example so I don't know you know I get

00:20:14,080 --> 00:20:17,679
queried further how do I do that well I

00:20:15,460 --> 00:20:18,610
just do it I just be neat about it I

00:20:17,679 --> 00:20:22,240
don't know the answer to that question

00:20:18,610 --> 00:20:24,370
so my friend who's a little bit I guess

00:20:22,240 --> 00:20:26,980
let's blunt than I am just brought out

00:20:24,370 --> 00:20:28,420
some code and said here here is some

00:20:26,980 --> 00:20:31,180
inherently state

00:20:28,420 --> 00:20:32,170
pure functional programming code but

00:20:31,180 --> 00:20:38,190
then we just started talking about for

00:20:32,170 --> 00:20:41,440
you so um that that's a true story so

00:20:38,190 --> 00:20:43,060
here is an imperative Haskell program is

00:20:41,440 --> 00:20:45,450
a real high school have you got any

00:20:43,060 --> 00:20:49,030
other Haskell compiler installed

00:20:45,450 --> 00:20:55,330
start talking it actually compiles now

00:20:49,030 --> 00:20:58,540
so this says the program is first of all

00:20:55,330 --> 00:21:02,230
read file this one call the result a

00:20:58,540 --> 00:21:04,330
print the result of that file then write

00:21:02,230 --> 00:21:07,630
the file write to the file same file

00:21:04,330 --> 00:21:10,450
this value here and then read the file

00:21:07,630 --> 00:21:12,670
again call it V and then print thee it's

00:21:10,450 --> 00:21:19,350
imperative programming everyone agree

00:21:12,670 --> 00:21:19,350
that's imperative Berger anyone disagree

00:21:20,100 --> 00:21:26,830
okay well is that expression

00:21:23,860 --> 00:21:29,470
referentially transparent now if you

00:21:26,830 --> 00:21:32,050
were as you're not now a believer in a

00:21:29,470 --> 00:21:33,660
this inherently stateful thing you now

00:21:32,050 --> 00:21:36,670
know that the answer to this question is

00:21:33,660 --> 00:21:38,410
that well I don't know because there is

00:21:36,670 --> 00:21:42,970
no such thing as inherently stateful is

00:21:38,410 --> 00:21:46,650
reading a file inherently stateful no is

00:21:42,970 --> 00:21:50,140
the correct answer I've just made it not

00:21:46,650 --> 00:21:51,910
well can I assign a value to it and then

00:21:50,140 --> 00:21:57,250
just use the reuse the value of that did

00:21:51,910 --> 00:21:59,350
the program just change nope in fact I

00:21:57,250 --> 00:22:02,650
can do this for every single program in

00:21:59,350 --> 00:22:03,490
Haskell every single time this is

00:22:02,650 --> 00:22:05,110
important to me

00:22:03,490 --> 00:22:08,080
when I write my production applications

00:22:05,110 --> 00:22:10,900
I must be able to do this it's not true

00:22:08,080 --> 00:22:14,410
in Python right this is the tool that's

00:22:10,900 --> 00:22:16,870
being forgone well it gets even worse

00:22:14,410 --> 00:22:20,110
right so here's some code duplication

00:22:16,870 --> 00:22:20,640
who likes to encourage application not

00:22:20,110 --> 00:22:24,520
me

00:22:20,640 --> 00:22:27,090
so well can I just move this code up

00:22:24,520 --> 00:22:29,650
here and then just replace the the

00:22:27,090 --> 00:22:34,690
expression here with the devalue has the

00:22:29,650 --> 00:22:37,000
program changed nope so functional

00:22:34,690 --> 00:22:39,160
programming is simply they don't repeat

00:22:37,000 --> 00:22:41,710
yourself thisis taken seriously that is

00:22:39,160 --> 00:22:42,190
all it is so either it's just lip

00:22:41,710 --> 00:22:43,539
service

00:22:42,190 --> 00:22:44,919
your functional programming or somewhere

00:22:43,539 --> 00:22:49,629
in between I don't know I wish but

00:22:44,919 --> 00:22:54,190
that's a fact so well don't repeat

00:22:49,629 --> 00:22:56,649
yourself for real what is this yeah not

00:22:54,190 --> 00:23:01,059
on did I say that I take it seriously by

00:22:56,649 --> 00:23:03,759
the way so well we should be able to

00:23:01,059 --> 00:23:05,350
move it so this here is a library

00:23:03,759 --> 00:23:06,970
function I'll just put it there too to

00:23:05,350 --> 00:23:09,279
demonstrate its code but basically I'm

00:23:06,970 --> 00:23:10,629
able to move it up here then this

00:23:09,279 --> 00:23:12,250
library function here says run this

00:23:10,629 --> 00:23:14,649
effect a then this effect B then this

00:23:12,250 --> 00:23:15,909
effect a and it's all pure functional

00:23:14,649 --> 00:23:17,139
because I can replace those expressions

00:23:15,909 --> 00:23:20,080
with their values it's all referentially

00:23:17,139 --> 00:23:27,190
transparent and this is my program this

00:23:20,080 --> 00:23:31,120
is the result okay I am pure functional

00:23:27,190 --> 00:23:32,740
imperative programming here this is the

00:23:31,120 --> 00:23:33,730
part where I say looks of disbelief and

00:23:32,740 --> 00:23:36,879
I'm not sure if everyone is

00:23:33,730 --> 00:23:43,950
understanding it oh god holy but

00:23:36,879 --> 00:23:43,950
hang in there so sure

00:23:48,560 --> 00:23:53,000
I don't argue for a moment that that's

00:23:51,260 --> 00:23:56,990
both functional and imperative but

00:23:53,000 --> 00:24:01,370
what's so special about Haskell so it's

00:23:56,990 --> 00:24:04,220
an excellent question so the the point

00:24:01,370 --> 00:24:09,530
the point of what is special about it is

00:24:04,220 --> 00:24:12,650
that see here how I am I am replacing

00:24:09,530 --> 00:24:14,720
expressions with values here so I'm

00:24:12,650 --> 00:24:16,910
essentially taking this file equals read

00:24:14,720 --> 00:24:18,830
file file and I've just pulled it out of

00:24:16,910 --> 00:24:20,960
here and I've put it up here as its own

00:24:18,830 --> 00:24:23,090
sort of top-level function right so you

00:24:20,960 --> 00:24:24,830
have closures got it well I have

00:24:23,090 --> 00:24:27,620
referential transparency and equational

00:24:24,830 --> 00:24:30,200
reasoning so I can write you have

00:24:27,620 --> 00:24:32,690
closures now this is not closures well

00:24:30,200 --> 00:24:34,010
alright but you are able to call a

00:24:32,690 --> 00:24:35,120
function from you are able to pass a

00:24:34,010 --> 00:24:38,030
function as that argument to another

00:24:35,120 --> 00:24:39,860
function now that's all very nice but

00:24:38,030 --> 00:24:42,440
that's not the point I'm making so I'm

00:24:39,860 --> 00:24:43,910
trying I'll try and clarify so what I've

00:24:42,440 --> 00:24:45,470
done is I've taken this expression that

00:24:43,910 --> 00:24:47,690
used to appear here in here and I've

00:24:45,470 --> 00:24:48,980
moved it out and the program didn't

00:24:47,690 --> 00:24:51,080
change and I'm gonna make it I'm gonna

00:24:48,980 --> 00:24:53,240
make this even clearer I can do this for

00:24:51,080 --> 00:24:54,710
any program so give me any high school

00:24:53,240 --> 00:24:56,390
program just one that you just invented

00:24:54,710 --> 00:24:58,070
just now and I can go and move all of

00:24:56,390 --> 00:25:01,160
this stuff out and I have the same

00:24:58,070 --> 00:25:02,540
program every single time and you can't

00:25:01,160 --> 00:25:05,060
do this unless you're doing pure

00:25:02,540 --> 00:25:07,370
functional programming right I guess the

00:25:05,060 --> 00:25:09,890
I guess an arguments being made that

00:25:07,370 --> 00:25:12,800
this there's something I guess then I'm

00:25:09,890 --> 00:25:14,990
not understanding your thesis ok so good

00:25:12,800 --> 00:25:16,430
which is there seems to be a thesis that

00:25:14,990 --> 00:25:20,210
there is something inherent about

00:25:16,430 --> 00:25:22,220
Haskell that makes this work yeah but I

00:25:20,210 --> 00:25:25,370
don't see that in this example that

00:25:22,220 --> 00:25:26,810
that's true so so that there is

00:25:25,370 --> 00:25:27,770
something inherent in Haskell but

00:25:26,810 --> 00:25:29,270
although that's not the point so the

00:25:27,770 --> 00:25:32,030
inherent thing in Haskell is that this

00:25:29,270 --> 00:25:33,860
is always true so that there's a sort of

00:25:32,030 --> 00:25:35,660
a second question to this and that is

00:25:33,860 --> 00:25:36,830
well what if I use my programming

00:25:35,660 --> 00:25:40,220
language whatever it might be

00:25:36,830 --> 00:25:42,440
in such a way that it's always true be a

00:25:40,220 --> 00:25:44,660
c-sharp or Python or Ruby or whatever

00:25:42,440 --> 00:25:46,100
you want to talk about that that's a

00:25:44,660 --> 00:25:49,760
that's is sort of any a very interesting

00:25:46,100 --> 00:25:51,290
question but so the answer the question

00:25:49,760 --> 00:25:54,890
how is Haskell special is it gives me

00:25:51,290 --> 00:25:57,470
tool support to do this so not only do I

00:25:54,890 --> 00:25:58,850
have the guarantee but when it comes

00:25:57,470 --> 00:26:00,860
time to sort of you know doing state

00:25:58,850 --> 00:26:01,970
passing or i/o actions I have the tool

00:26:00,860 --> 00:26:03,770
support to do it I don't have to

00:26:01,970 --> 00:26:05,630
and all this sort of clumsy boilerplate

00:26:03,770 --> 00:26:07,520
code which I have done in other

00:26:05,630 --> 00:26:09,230
languages just to sort of try and figure

00:26:07,520 --> 00:26:13,520
out how how well that language performs

00:26:09,230 --> 00:26:15,560
in this tone so the the the this this

00:26:13,520 --> 00:26:16,790
idea of replacing expressions with

00:26:15,560 --> 00:26:18,920
values is like I said it's called

00:26:16,790 --> 00:26:20,450
referential transparency or or sometimes

00:26:18,920 --> 00:26:22,430
it's called equational reasoning so just

00:26:20,450 --> 00:26:25,730
replacing equations with values and

00:26:22,430 --> 00:26:27,080
doing it arbitrarily so this thing is

00:26:25,730 --> 00:26:27,800
the important thing to me not not the

00:26:27,080 --> 00:26:29,480
haskell part

00:26:27,800 --> 00:26:31,670
I mean Haskell is nice and all but the

00:26:29,480 --> 00:26:43,040
equational reasoning part is absolutely

00:26:31,670 --> 00:26:46,600
important to me so does that help and

00:26:43,040 --> 00:26:49,040
trying to understand how the how the

00:26:46,600 --> 00:26:51,080
referential transparency is different

00:26:49,040 --> 00:26:57,350
from statelessness or no side effects

00:26:51,080 --> 00:26:58,910
it's absolutely not okay have I tried to

00:26:57,350 --> 00:27:01,130
write an entire program discipline to

00:26:58,910 --> 00:27:03,320
this no have I written a lot of code

00:27:01,130 --> 00:27:05,930
that that has this characteristic yes I

00:27:03,320 --> 00:27:07,640
mean I you know I don't think anyone

00:27:05,930 --> 00:27:09,590
uses pop and then is surprised that the

00:27:07,640 --> 00:27:14,780
data structure changes okay

00:27:09,590 --> 00:27:16,940
so the so again I maybe I'm just not

00:27:14,780 --> 00:27:18,500
clear on your thesis which is so I'll

00:27:16,940 --> 00:27:18,950
just make it fine then you didn't get

00:27:18,500 --> 00:27:22,280
very far

00:27:18,950 --> 00:27:24,080
okay not as far as I would like and sort

00:27:22,280 --> 00:27:25,400
of not even close okay well the I have a

00:27:24,080 --> 00:27:27,160
second question about that book okay

00:27:25,400 --> 00:27:28,760
well I'll defer that sure

00:27:27,160 --> 00:27:30,620
unfortunately I can't hang around for

00:27:28,760 --> 00:27:32,960
too long outside but I would love to

00:27:30,620 --> 00:27:35,120
sort of write some code and muck around

00:27:32,960 --> 00:27:38,410
in the time that I do have so maybe

00:27:35,120 --> 00:27:45,500
after maybe maybe doing that okay

00:27:38,410 --> 00:27:48,230
all right say so yeah like I said it's

00:27:45,500 --> 00:27:49,730
called equation or reasoning the

00:27:48,230 --> 00:27:51,380
equation of reasoning is a necessary

00:27:49,730 --> 00:27:53,180
part certainly of my software

00:27:51,380 --> 00:27:57,020
development if you don't have it I will

00:27:53,180 --> 00:28:00,020
throw it in the bin so I think I've I

00:27:57,020 --> 00:28:02,150
think I've sort of met the goal here

00:28:00,020 --> 00:28:03,830
which is to destroy functional

00:28:02,150 --> 00:28:05,540
imperative programming dichotomy it

00:28:03,830 --> 00:28:07,700
doesn't exist I just did function

00:28:05,540 --> 00:28:12,010
imperative programming and be aware of

00:28:07,700 --> 00:28:12,010
this nonsense

00:28:12,290 --> 00:28:17,790
so punctual programming is just one way

00:28:15,780 --> 00:28:22,350
of doing imperative programming there

00:28:17,790 --> 00:28:25,920
are others so I just want to point out

00:28:22,350 --> 00:28:27,630
and like I said I work for NICTA part of

00:28:25,920 --> 00:28:29,250
my goal is to demonstrate some of the

00:28:27,630 --> 00:28:33,710
you know try and help people understand

00:28:29,250 --> 00:28:36,900
functional programming and in doing so I

00:28:33,710 --> 00:28:39,090
wrote a pure functional random value

00:28:36,900 --> 00:28:39,870
generating library and then I use

00:28:39,090 --> 00:28:42,720
c-sharp

00:28:39,870 --> 00:28:44,880
so basically my goal here was to destroy

00:28:42,720 --> 00:28:47,280
the idea that only this only can be done

00:28:44,880 --> 00:28:48,480
in Haskell if I using c-sharp and to

00:28:47,280 --> 00:28:51,780
destroy the idea that it cannot be done

00:28:48,480 --> 00:28:52,980
at all by writing the most impossible

00:28:51,780 --> 00:28:54,570
thing that is often claimed to be done

00:28:52,980 --> 00:28:56,880
which is random value generation and I

00:28:54,570 --> 00:29:00,270
did it using pure functional program so

00:28:56,880 --> 00:29:03,480
it can be done and I used to work for a

00:29:00,270 --> 00:29:05,700
Java consultancy or you know Java based

00:29:03,480 --> 00:29:08,010
production company actually and we had

00:29:05,700 --> 00:29:10,650
to use databases how to use databases

00:29:08,010 --> 00:29:13,160
you do using neatly how else do you use

00:29:10,650 --> 00:29:17,760
them you do functional programming I

00:29:13,160 --> 00:29:20,520
can't think of any a better way and a

00:29:17,760 --> 00:29:29,460
friend of mine did this once he's bit

00:29:20,520 --> 00:29:31,500
crazier than I am so so when I googled

00:29:29,460 --> 00:29:33,240
it this came up but only a benefits

00:29:31,500 --> 00:29:34,500
enforcing side-effect free code I mean

00:29:33,240 --> 00:29:37,710
that was side-effect free code that you

00:29:34,500 --> 00:29:41,240
just saw what was the cost can anyone

00:29:37,710 --> 00:29:46,650
see it some cost in that code yeah what

00:29:41,240 --> 00:29:48,390
yeah so I'll go back to that code so

00:29:46,650 --> 00:29:51,900
that this is side effect I'll go back to

00:29:48,390 --> 00:29:53,460
the start line just to yeah it's it's

00:29:51,900 --> 00:29:55,500
the mental gymnastics you have to go

00:29:53,460 --> 00:29:57,960
through to formulate a solution in such

00:29:55,500 --> 00:30:00,330
a way that there's no sorry no mental

00:29:57,960 --> 00:30:01,710
gymnastics in that code I want to get to

00:30:00,330 --> 00:30:03,060
the end point where it's coming through

00:30:01,710 --> 00:30:04,710
a function that you're saying well that

00:30:03,060 --> 00:30:07,350
is really just an abstraction of doing X

00:30:04,710 --> 00:30:09,090
then Y then doing X again uh-huh it's

00:30:07,350 --> 00:30:11,100
it's a mental mental gymnastics that

00:30:09,090 --> 00:30:13,410
when someone looks at the last line and

00:30:11,100 --> 00:30:14,730
says what does it do you need to not

00:30:13,410 --> 00:30:16,140
understand all the other stuff that's

00:30:14,730 --> 00:30:18,690
going on and the mental headspace is

00:30:16,140 --> 00:30:22,410
larger than it would be if it was just

00:30:18,690 --> 00:30:23,400
written straight out now that's my

00:30:22,410 --> 00:30:25,260
Christmas Mike we'd have a much longer

00:30:23,400 --> 00:30:27,060
discussion about okay I'm

00:30:25,260 --> 00:30:30,450
I'll address that slightly that's okay I

00:30:27,060 --> 00:30:32,190
agree that if we sat down and I showed

00:30:30,450 --> 00:30:35,160
you this code I just threw it straight

00:30:32,190 --> 00:30:37,470
at you and I said have fun I think it

00:30:35,160 --> 00:30:39,410
would struggle and I vividly remember

00:30:37,470 --> 00:30:43,040
the day that someone did this to me I

00:30:39,410 --> 00:30:45,360
thought they were a bit of an

00:30:43,040 --> 00:30:47,280
and I wouldn't blame you if you thought

00:30:45,360 --> 00:30:51,330
that of me if I were to do this to you

00:30:47,280 --> 00:30:53,010
however they're up there so how do we

00:30:51,330 --> 00:30:54,960
address this issue what can we do about

00:30:53,010 --> 00:30:58,830
that and and the answer is there is tool

00:30:54,960 --> 00:31:00,690
support in order to in order to reason

00:30:58,830 --> 00:31:03,240
about these abstract this abstract code

00:31:00,690 --> 00:31:04,500
and so the answer the question there's

00:31:03,240 --> 00:31:05,880
answers to some questions like do I

00:31:04,500 --> 00:31:07,590
really actually need to understand

00:31:05,880 --> 00:31:09,480
what's underneath and in the rare

00:31:07,590 --> 00:31:11,190
instance that the answer is yes then

00:31:09,480 --> 00:31:14,100
this tool support for it and I think

00:31:11,190 --> 00:31:15,420
that's the best we can do and so the

00:31:14,100 --> 00:31:16,800
thing that I would actually throw at you

00:31:15,420 --> 00:31:18,570
is this tool supporting I go look I

00:31:16,800 --> 00:31:20,160
understand this is this is a bad place

00:31:18,570 --> 00:31:21,870
to be let's get some tool support to

00:31:20,160 --> 00:31:24,240
help you get through and answer the

00:31:21,870 --> 00:31:25,410
questions that you need to answer so of

00:31:24,240 --> 00:31:26,610
course that's not here on this slide

00:31:25,410 --> 00:31:29,850
that there you know there's all this

00:31:26,610 --> 00:31:32,220
tool support to do say but after some

00:31:29,850 --> 00:31:37,800
practice it goes away there's no real

00:31:32,220 --> 00:31:39,930
problem okay it's quick question

00:31:37,800 --> 00:31:42,000
when you said that code doesn't have

00:31:39,930 --> 00:31:43,740
side effects aren't you writing to file

00:31:42,000 --> 00:31:45,900
right there isn't that effect

00:31:43,740 --> 00:31:50,850
that's the best question um the answer

00:31:45,900 --> 00:31:52,550
is no and the reason it's the best

00:31:50,850 --> 00:31:54,660
question because it looks like I am I

00:31:52,550 --> 00:31:56,430
say let me tell you exactly what I'm

00:31:54,660 --> 00:32:00,360
doing what I'm doing here this

00:31:56,430 --> 00:32:01,770
expression here so if you were to use

00:32:00,360 --> 00:32:03,900
this in like sort of more traditional

00:32:01,770 --> 00:32:06,210
programming languages the return type of

00:32:03,900 --> 00:32:07,500
this program here would be strength well

00:32:06,210 --> 00:32:08,850
you know a list of characters or

00:32:07,500 --> 00:32:12,600
something like you know the contents of

00:32:08,850 --> 00:32:15,300
the file in Haskell it's not in Haskell

00:32:12,600 --> 00:32:16,320
or and in fact in when you model these

00:32:15,300 --> 00:32:17,850
things people functionally in any

00:32:16,320 --> 00:32:19,260
language you can actually make these

00:32:17,850 --> 00:32:22,800
things of a different type and that is

00:32:19,260 --> 00:32:24,660
to say they are a program that when run

00:32:22,800 --> 00:32:26,940
through an interpreter which you the

00:32:24,660 --> 00:32:29,190
programmer don't have access to it will

00:32:26,940 --> 00:32:30,750
produce a string and it allows you to

00:32:29,190 --> 00:32:32,010
name that string but it doesn't allow

00:32:30,750 --> 00:32:33,930
you to do anything else other than name

00:32:32,010 --> 00:32:37,020
that string so you must remain in the

00:32:33,930 --> 00:32:38,730
context of producing this thing this in

00:32:37,020 --> 00:32:40,350
this case an i/o program

00:32:38,730 --> 00:32:55,430
so the type of this thing is an i/o

00:32:40,350 --> 00:32:55,430
string so say have you say yeah sure

00:32:55,640 --> 00:33:01,980
alright so the tot say the type of this

00:32:59,490 --> 00:33:04,290
expression here so this little bit down

00:33:01,980 --> 00:33:05,310
here says this expression is of the type

00:33:04,290 --> 00:33:08,130
iostream'

00:33:05,310 --> 00:33:12,090
okay it's not of type string which is to

00:33:08,130 --> 00:33:15,120
say so that there's this sort of string

00:33:12,090 --> 00:33:19,620
concatenation right all right it does

00:33:15,120 --> 00:33:22,740
what you would expect at the type of

00:33:19,620 --> 00:33:24,330
this expression all right now if you

00:33:22,740 --> 00:33:25,890
were using a traditional language this

00:33:24,330 --> 00:33:28,440
will give you an answer Oden so ABC than

00:33:25,890 --> 00:33:32,160
all of this right any ideas what it's

00:33:28,440 --> 00:33:35,430
going to do correct this is a good thing

00:33:32,160 --> 00:33:37,610
that is not a valid program don't give

00:33:35,430 --> 00:33:37,610
me that

00:33:39,950 --> 00:33:46,050
so there are actions all right so this

00:33:42,900 --> 00:33:47,460
is an i/o string but it allows me to

00:33:46,050 --> 00:33:50,460
name this string so there's operations

00:33:47,460 --> 00:33:51,750
on i/o things that allow me to get the

00:33:50,460 --> 00:33:53,340
things out that I'd must make a

00:33:51,750 --> 00:33:56,070
guarantee that I stay within i/o when I

00:33:53,340 --> 00:33:58,020
do that so this whole expression here is

00:33:56,070 --> 00:33:59,760
within i/o this is actually just special

00:33:58,020 --> 00:34:07,340
synthesis do key words just nice syntax

00:33:59,760 --> 00:34:10,530
for dealing with it okay you don't

00:34:07,340 --> 00:34:11,790
the interpreter does and the interpreter

00:34:10,530 --> 00:34:14,010
is somewhere else that you don't have

00:34:11,790 --> 00:34:15,330
access to so basically so just to

00:34:14,010 --> 00:34:16,830
rephrase a little bit we're taking i/o

00:34:15,330 --> 00:34:18,510
programs here's a little one here it

00:34:16,830 --> 00:34:20,400
does read file here's another one here's

00:34:18,510 --> 00:34:22,230
another one is print these are all

00:34:20,400 --> 00:34:24,750
little i/o programs and we're gluing

00:34:22,230 --> 00:34:27,870
them all together in in this sort of way

00:34:24,750 --> 00:34:30,270
to make a new i/o program and that's

00:34:27,870 --> 00:34:32,580
this whole program and then I feed that

00:34:30,270 --> 00:34:34,140
off to some compile or whatever

00:34:32,580 --> 00:34:36,330
something I don't care about and it's

00:34:34,140 --> 00:34:38,610
the thing that decides when to write the

00:34:36,330 --> 00:34:42,090
files and read the files read from files

00:34:38,610 --> 00:34:43,230
so basically you know when it gets all

00:34:42,090 --> 00:34:46,110
the way up to like to the main function

00:34:43,230 --> 00:34:51,060
its type is not void it's tight as I

00:34:46,110 --> 00:34:52,590
ovoid I just handed an i/o program

00:34:51,060 --> 00:34:55,050
and however I've glued all these i/o

00:34:52,590 --> 00:34:56,820
programs together the interpreter that

00:34:55,050 --> 00:35:00,300
that something this hypothetical thing

00:34:56,820 --> 00:35:02,160
decides what to do so all I'm doing is

00:35:00,300 --> 00:35:03,390
gluing i/o programs when I run it it

00:35:02,160 --> 00:35:05,310
will in fact read from the file don't

00:35:03,390 --> 00:35:07,740
get me wrong it's the interpreter doing

00:35:05,310 --> 00:35:09,030
it it's not me the programmer if I

00:35:07,740 --> 00:35:11,330
allowed you to do that you'd be able to

00:35:09,030 --> 00:35:15,450
write that terrible program back there

00:35:11,330 --> 00:35:18,390
that should never exist so there's

00:35:15,450 --> 00:35:27,540
benefits and I'm yet to find the costs

00:35:18,390 --> 00:35:29,040
that are alleged that help III realize

00:35:27,540 --> 00:35:33,210
the difficulty in understanding this in

00:35:29,040 --> 00:35:35,910
sort of the short timeframe fit yeah I

00:35:33,210 --> 00:35:42,590
am out of explanations these are i/o

00:35:35,910 --> 00:35:46,800
programs oh yeah keep doing this so

00:35:42,590 --> 00:35:48,150
right thanks the code unreadable IESA

00:35:46,800 --> 00:35:50,520
that was a that was where I've addressed

00:35:48,150 --> 00:35:53,250
that actually so yeah there's tool

00:35:50,520 --> 00:35:56,990
support I'm so parametric City which is

00:35:53,250 --> 00:36:01,020
my favorite part of all parameter city

00:35:56,990 --> 00:36:02,280
this is I guess where I I don't know you

00:36:01,020 --> 00:36:03,150
might think nasty things about me in

00:36:02,280 --> 00:36:04,740
your head when I tell you what

00:36:03,150 --> 00:36:07,800
parametric cities but I hopefully not so

00:36:04,740 --> 00:36:09,870
there's a guy called Phil Wadler who

00:36:07,800 --> 00:36:15,440
described this idea called theorems for

00:36:09,870 --> 00:36:18,390
free or parameter City when I was 12 so

00:36:15,440 --> 00:36:19,800
types this is a practical on splints and

00:36:18,390 --> 00:36:21,240
that is that types by exploiting

00:36:19,800 --> 00:36:24,360
generalization by exploiting the fact

00:36:21,240 --> 00:36:25,920
that there general give us documentation

00:36:24,360 --> 00:36:29,040
of that code and it cannot go out of

00:36:25,920 --> 00:36:31,770
date isn't that good has anyone had

00:36:29,040 --> 00:36:33,000
documentation go out of date so many

00:36:31,770 --> 00:36:35,910
things have been said about static

00:36:33,000 --> 00:36:40,440
typing this is how many crazy things

00:36:35,910 --> 00:36:41,910
said about it I'm here some so oh yeah

00:36:40,440 --> 00:36:44,130
I'll tell you another anecdote so this

00:36:41,910 --> 00:36:46,980
was actually the reason for the day that

00:36:44,130 --> 00:36:48,840
I quit my job right so you know my

00:36:46,980 --> 00:36:50,670
colleague is gay like he was really

00:36:48,840 --> 00:36:52,410
aggressive in he's going static typing

00:36:50,670 --> 00:36:54,420
is just terrible and I go well why is

00:36:52,410 --> 00:36:59,550
that because you have to write these

00:36:54,420 --> 00:37:01,680
pipes everywhere and I said what so I

00:36:59,550 --> 00:37:03,270
took these Python source file you know I

00:37:01,680 --> 00:37:04,530
asked him what you know why is Python so

00:37:03,270 --> 00:37:09,630
greatness and what caused odd

00:37:04,530 --> 00:37:11,370
did it okay so I took his Python source

00:37:09,630 --> 00:37:15,060
file I mean this isn't the exact file I

00:37:11,370 --> 00:37:17,640
don't remember it and I compiled it cuz

00:37:15,060 --> 00:37:18,990
it's actually valid Haskell what do you

00:37:17,640 --> 00:37:19,620
know is that he actually had written

00:37:18,990 --> 00:37:23,130
Haskell

00:37:19,620 --> 00:37:25,500
it was quite coincidental I thought it

00:37:23,130 --> 00:37:28,230
was quite funny but you know this sort

00:37:25,500 --> 00:37:29,820
of lack of ability to resolve this

00:37:28,230 --> 00:37:33,030
conflict I just there's nothing I could

00:37:29,820 --> 00:37:34,380
do so anyway the point is static typing

00:37:33,030 --> 00:37:36,030
has nothing to do with whether or not

00:37:34,380 --> 00:37:45,360
your type types this is a valid Haskell

00:37:36,030 --> 00:37:47,010
program okay so so the goal is to tell

00:37:45,360 --> 00:37:48,960
you about this advantage by exploiting

00:37:47,010 --> 00:37:50,460
types okay it's not I don't want to

00:37:48,960 --> 00:37:51,990
enter into the static dynamic typing

00:37:50,460 --> 00:37:54,360
debate I want to tell you about a tool

00:37:51,990 --> 00:37:59,460
that comes about by having used static

00:37:54,360 --> 00:38:00,930
types and that's all so here's sort of

00:37:59,460 --> 00:38:02,040
the you know summary of the thesis and

00:38:00,930 --> 00:38:03,210
that is write down a polymorphic

00:38:02,040 --> 00:38:05,270
function on a piece of paper tell me

00:38:03,210 --> 00:38:07,680
it's tight don't tell me the definition

00:38:05,270 --> 00:38:09,090
and I will tell you a theorem that the

00:38:07,680 --> 00:38:10,290
function set of that is to say I'll tell

00:38:09,090 --> 00:38:11,310
you something that the code does I won't

00:38:10,290 --> 00:38:12,540
be able to tell you everything the code

00:38:11,310 --> 00:38:15,090
does I'll just tell you something that

00:38:12,540 --> 00:38:18,480
it does and then there's this thing

00:38:15,090 --> 00:38:21,530
called fast and loose reasoning which

00:38:18,480 --> 00:38:25,320
I'll hand wave over if that's okay so

00:38:21,530 --> 00:38:28,020
here I go this is Haskell syntax and

00:38:25,320 --> 00:38:29,580
this says I'm thinking of a function it

00:38:28,020 --> 00:38:31,770
takes a list of a and it returns a list

00:38:29,580 --> 00:38:34,850
of the same elements a a is generalized

00:38:31,770 --> 00:38:34,850
I'm not telling you what the A's are

00:38:34,880 --> 00:38:42,960
okay and there it is yes it's called

00:38:41,100 --> 00:38:44,730
Universal quantification on the element

00:38:42,960 --> 00:38:47,820
type so the ABA is just universally

00:38:44,730 --> 00:38:49,590
quantified and I can tell you based only

00:38:47,820 --> 00:38:50,970
on this type that everything in the

00:38:49,590 --> 00:38:53,550
result every element in the result

00:38:50,970 --> 00:38:56,550
appears in the input I challenge anyone

00:38:53,550 --> 00:38:58,500
to negate this statement again there is

00:38:56,550 --> 00:39:02,970
a function with this type because of

00:38:58,500 --> 00:39:04,640
that this fact is true two types telling

00:39:02,970 --> 00:39:06,390
me something about the code already I

00:39:04,640 --> 00:39:07,860
know what some of you are thinking

00:39:06,390 --> 00:39:11,160
you're thinking nulls exceptions

00:39:07,860 --> 00:39:13,110
side-effects infinite recursion and so

00:39:11,160 --> 00:39:16,520
on fast and loose reasoning deals with

00:39:13,110 --> 00:39:18,770
this so

00:39:16,520 --> 00:39:20,270
I'll tell you how what if we say what

00:39:18,770 --> 00:39:21,710
does it mean to do fast Lisa reading it

00:39:20,270 --> 00:39:24,109
says if we're in a total language and

00:39:21,710 --> 00:39:26,150
that is languages that don't have Nolan

00:39:24,109 --> 00:39:27,500
side-effects and type case you know is

00:39:26,150 --> 00:39:30,230
it this type of that type and

00:39:27,500 --> 00:39:31,849
typecasting and so on and we expect the

00:39:30,230 --> 00:39:33,680
results to carry over the non total

00:39:31,849 --> 00:39:37,369
languages like Haskell and Python and so

00:39:33,680 --> 00:39:38,540
on and and this paper says it's okay to

00:39:37,369 --> 00:39:41,480
have seen that these things don't exist

00:39:38,540 --> 00:39:44,180
so when I make the statement that this

00:39:41,480 --> 00:39:47,770
fact is true based on this premise I'm

00:39:44,180 --> 00:39:51,130
saying it because it's morally correct

00:39:47,770 --> 00:39:51,130
to do so

00:39:51,290 --> 00:39:57,410
so like this this is a really good paper

00:39:55,609 --> 00:39:58,640
by the way like it you know the puns

00:39:57,410 --> 00:40:01,070
aside it's actually a really awesome

00:39:58,640 --> 00:40:03,140
paper I highly recommend it so that

00:40:01,070 --> 00:40:04,580
means say these values these these

00:40:03,140 --> 00:40:05,720
values that exist in on total languages

00:40:04,580 --> 00:40:07,220
are often called bottom bellies and

00:40:05,720 --> 00:40:09,980
here's the denotation for that it's like

00:40:07,220 --> 00:40:12,020
an upside down tea and it says that we

00:40:09,980 --> 00:40:16,220
can't do these things tight casing

00:40:12,020 --> 00:40:16,970
because key word in Python we can't you

00:40:16,220 --> 00:40:20,839
know what is this

00:40:16,970 --> 00:40:23,330
no nasties so it means that we can

00:40:20,839 --> 00:40:24,859
discard all these and in Haskell we

00:40:23,330 --> 00:40:28,820
don't have any of those anyway we do

00:40:24,859 --> 00:40:30,710
have these and it's because it's a non

00:40:28,820 --> 00:40:32,859
total language and if this is actually a

00:40:30,710 --> 00:40:35,450
property of altering complete systems

00:40:32,859 --> 00:40:39,470
you might argue that why do we care

00:40:35,450 --> 00:40:41,080
about Turing completeness I agree but

00:40:39,470 --> 00:40:46,089
small steps

00:40:41,080 --> 00:40:48,910
say so let's just haskell right

00:40:46,089 --> 00:40:50,480
Haskell's non total it has these things

00:40:48,910 --> 00:40:54,950
we can do better

00:40:50,480 --> 00:40:56,330
so can you invalidate it can anyone

00:40:54,950 --> 00:40:59,270
think of a way to invalidate that right

00:40:56,330 --> 00:41:01,220
so every element in the result appears

00:40:59,270 --> 00:41:03,320
in the input on any function that has

00:41:01,220 --> 00:41:06,650
that type list of a list of a four

00:41:03,320 --> 00:41:10,630
universally quantified a no and is no

00:41:06,650 --> 00:41:13,590
objectors that's strange

00:41:10,630 --> 00:41:16,020
secretly objecting

00:41:13,590 --> 00:41:18,570
so how do we know what the function does

00:41:16,020 --> 00:41:20,460
exactly I didn't tell you what it does

00:41:18,570 --> 00:41:21,630
all I do all I did is tell you one thing

00:41:20,460 --> 00:41:23,340
that it doesn't do that is it doesn't

00:41:21,630 --> 00:41:24,830
have elements that didn't appear in the

00:41:23,340 --> 00:41:28,170
input

00:41:24,830 --> 00:41:29,820
well we write unit tests okay this is

00:41:28,170 --> 00:41:31,980
what we do in non-title languages we

00:41:29,820 --> 00:41:36,420
write unit tests but not you know assert

00:41:31,980 --> 00:41:41,250
that this and that we write this for all

00:41:36,420 --> 00:41:42,990
X if I call function with a with X as a

00:41:41,250 --> 00:41:45,510
single element in the list I get back

00:41:42,990 --> 00:41:47,100
that same list all right so if I just

00:41:45,510 --> 00:41:48,930
get any element I put it in a list on

00:41:47,100 --> 00:41:51,210
its own and call function on it I'll get

00:41:48,930 --> 00:41:52,830
back the same list that holds for all X

00:41:51,210 --> 00:41:56,250
that's the similarly it says for all X

00:41:52,830 --> 00:41:58,890
and then I say for all lists x and y if

00:41:56,250 --> 00:42:01,190
I append x and y so if I just join the

00:41:58,890 --> 00:42:04,080
two lists together then a call function

00:42:01,190 --> 00:42:06,870
this is the same as calling function y

00:42:04,080 --> 00:42:13,470
sorry about that and appending function

00:42:06,870 --> 00:42:15,620
X okay and reminder of the type can

00:42:13,470 --> 00:42:19,640
anyone tell me what this function does

00:42:15,620 --> 00:42:22,680
what does it do it reverses the list

00:42:19,640 --> 00:42:26,310
correct answer it's the only thing it

00:42:22,680 --> 00:42:27,900
can do so when I write Haskell and I

00:42:26,310 --> 00:42:30,300
highly encourage you to try this I'd

00:42:27,900 --> 00:42:32,490
write it tight then I write these two

00:42:30,300 --> 00:42:33,960
statements and then I've completely

00:42:32,490 --> 00:42:36,660
specified the function there is no more

00:42:33,960 --> 00:42:38,010
documentation for me to write this is

00:42:36,660 --> 00:42:39,090
all this is all checked by the way like

00:42:38,010 --> 00:42:40,980
you know there's a type checker to do

00:42:39,090 --> 00:42:42,420
this and then there's a there's a

00:42:40,980 --> 00:42:45,300
machine that'll go through and run all

00:42:42,420 --> 00:42:47,220
these tests correct answer

00:42:45,300 --> 00:42:49,650
excellent so I'll give you some more

00:42:47,220 --> 00:42:51,360
theorems for free this is called a once

00:42:49,650 --> 00:42:53,040
inhabited type there are no tests that

00:42:51,360 --> 00:42:55,920
you can write for this toe what does

00:42:53,040 --> 00:42:57,150
this function do well I'll tell you I'll

00:42:55,920 --> 00:42:58,860
tell you what this syntax means first

00:42:57,150 --> 00:43:00,240
right it says so first of all because

00:42:58,860 --> 00:43:01,830
there's a lowercase these are these are

00:43:00,240 --> 00:43:03,780
universally quantified so so it's for

00:43:01,830 --> 00:43:05,790
all a B and C and it says given a

00:43:03,780 --> 00:43:07,350
function that takes a stew these and a

00:43:05,790 --> 00:43:10,560
function that takes beasts to see return

00:43:07,350 --> 00:43:11,930
a function that takes a s to sees what

00:43:10,560 --> 00:43:14,760
does it do

00:43:11,930 --> 00:43:16,080
well it takes the a in the function that

00:43:14,760 --> 00:43:18,150
it's returning and it puts it into this

00:43:16,080 --> 00:43:19,560
function to get the B puts it in there

00:43:18,150 --> 00:43:22,890
and it gets to C and then it returns

00:43:19,560 --> 00:43:24,360
that it's the only thing it can do so if

00:43:22,890 --> 00:43:25,560
I see this type signature you and I are

00:43:24,360 --> 00:43:27,299
working on a project together right and

00:43:25,560 --> 00:43:28,439
you write this cloak signature

00:43:27,299 --> 00:43:29,599
do I need to come and knock on your door

00:43:28,439 --> 00:43:33,539
and I see what the function doesn't know

00:43:29,599 --> 00:43:35,969
already know what it does it glues those

00:43:33,539 --> 00:43:39,059
two functions together types the

00:43:35,969 --> 00:43:40,349
documentation and I've picked this

00:43:39,059 --> 00:43:43,559
little example here this is an ambiguous

00:43:40,349 --> 00:43:45,119
one so this is this is a pair as you

00:43:43,559 --> 00:43:47,309
probably understand it so given a pair

00:43:45,119 --> 00:43:49,979
of A's universally quantified retain a

00:43:47,309 --> 00:43:52,439
name how many things can this function

00:43:49,979 --> 00:43:54,659
do it's two things can either return

00:43:52,439 --> 00:43:58,189
this one or this one so I'll just write

00:43:54,659 --> 00:43:58,189
one test and I'm finished

00:43:59,899 --> 00:44:07,829
who likes writing for atoms and tests

00:44:02,339 --> 00:44:09,359
come on you know you love it so I do

00:44:07,829 --> 00:44:12,719
want to point out so I'm a bit out of my

00:44:09,359 --> 00:44:15,569
comfort zone here I don't you know I'm

00:44:12,719 --> 00:44:17,249
around a new crowd and I want to point

00:44:15,569 --> 00:44:18,479
out it's something that I feel quite

00:44:17,249 --> 00:44:20,519
strongly about and that is I actually

00:44:18,479 --> 00:44:24,439
think you're all very brave for inviting

00:44:20,519 --> 00:44:26,999
me here to this conference really so

00:44:24,439 --> 00:44:28,739
there's a specific reason so I type this

00:44:26,999 --> 00:44:34,499
into the Google and I got all sad

00:44:28,739 --> 00:44:36,679
because this happened so you know Lisp

00:44:34,499 --> 00:44:40,949
and C++ and Fife and a multi-paradigm

00:44:36,679 --> 00:44:42,209
that you know lies we can do modern

00:44:40,949 --> 00:44:44,219
paradigm and Haskell I just showed that

00:44:42,209 --> 00:44:48,839
I think can't even do functional

00:44:44,219 --> 00:44:51,089
programming it's a lie so that is

00:44:48,839 --> 00:44:53,549
Haskell so some functional programming

00:44:51,089 --> 00:44:56,669
is don't even have this yes they do that

00:44:53,549 --> 00:44:58,859
is actually valid Haskell so the reason

00:44:56,669 --> 00:45:01,919
I think you'll brave it just goes on

00:44:58,859 --> 00:45:04,829
iterate is come on so the reason I think

00:45:01,919 --> 00:45:06,809
you're brave is because this is you know

00:45:04,829 --> 00:45:08,130
if I if I was in this position where I

00:45:06,809 --> 00:45:09,119
was a keen curious person I wanted to

00:45:08,130 --> 00:45:11,639
learn more about functional programming

00:45:09,119 --> 00:45:15,779
and I type this into Google and I saw

00:45:11,639 --> 00:45:17,099
these answers it's you know you've got

00:45:15,779 --> 00:45:19,529
to get through this forest for the trees

00:45:17,099 --> 00:45:21,179
and and to even sort of get through it

00:45:19,529 --> 00:45:23,009
all and have me standing up here bagging

00:45:21,179 --> 00:45:24,569
you all out a little bit I just think

00:45:23,009 --> 00:45:27,359
that's absolutely awesome and just well

00:45:24,569 --> 00:45:29,279
done to all of you but and and like I

00:45:27,359 --> 00:45:33,049
really mean that that's seeking out new

00:45:29,279 --> 00:45:37,619
ideas is what programs all about so I

00:45:33,049 --> 00:45:39,449
just want to tie it up and tell you you

00:45:37,619 --> 00:45:40,920
know what you know I'm gonna stay true

00:45:39,449 --> 00:45:42,510
to the idea that I need to tell you why

00:45:40,920 --> 00:45:45,360
I think you're all doing it wrong which

00:45:42,510 --> 00:45:47,340
is why I was asked to come here so the

00:45:45,360 --> 00:45:50,820
primary purpose of frameworks like

00:45:47,340 --> 00:45:53,430
Django to take disjoint applications

00:45:50,820 --> 00:45:59,160
right so you know they're just disjoint

00:45:53,430 --> 00:46:00,360
and to find their common parts and their

00:45:59,160 --> 00:46:01,890
separate parts there's you know this

00:46:00,360 --> 00:46:06,720
part so dissimilar in the parts that are

00:46:01,890 --> 00:46:09,810
dissimilar for example themes or you

00:46:06,720 --> 00:46:11,160
know MVC or whatever it might be we have

00:46:09,810 --> 00:46:15,030
one thing we have another theme and then

00:46:11,160 --> 00:46:16,590
everything else is the same and I think

00:46:15,030 --> 00:46:18,600
you'll probably agree that when these

00:46:16,590 --> 00:46:20,370
when these leak over come over the

00:46:18,600 --> 00:46:24,720
boundaries there we have bugs and

00:46:20,370 --> 00:46:27,090
maintenance fun hopefully all three of

00:46:24,720 --> 00:46:29,040
that but we were having name for this

00:46:27,090 --> 00:46:31,440
and that's equation or reasoning and

00:46:29,040 --> 00:46:33,270
that is setting aside X you know sub

00:46:31,440 --> 00:46:35,100
programs that are just distinct from

00:46:33,270 --> 00:46:38,220
other sub programs and building them up

00:46:35,100 --> 00:46:40,110
to larger and larger programs so to the

00:46:38,220 --> 00:46:41,730
extent that you have equational

00:46:40,110 --> 00:46:43,140
reasoning is the same extent that you

00:46:41,730 --> 00:46:45,120
have the ability to do this sort of

00:46:43,140 --> 00:46:50,430
delineation of similarities and

00:46:45,120 --> 00:46:52,580
dissimilarities and programs so what do

00:46:50,430 --> 00:46:55,650
we have a watermelon

00:46:52,580 --> 00:46:58,230
we have nothing there is nothing in

00:46:55,650 --> 00:47:01,080
python that that allows me to do

00:46:58,230 --> 00:47:02,790
equation or reasoning at all so into

00:47:01,080 --> 00:47:04,050
this extent I can't answer these

00:47:02,790 --> 00:47:06,770
questions of how to build up smaller

00:47:04,050 --> 00:47:09,540
programs to make larger programs and

00:47:06,770 --> 00:47:12,750
instruct on their similarities and move

00:47:09,540 --> 00:47:14,760
aside their dissimilarities okay what

00:47:12,750 --> 00:47:16,860
about parametric city or abstraction

00:47:14,760 --> 00:47:23,460
where's my mono transformers where are

00:47:16,860 --> 00:47:25,470
they nowhere to be seen and I guess some

00:47:23,460 --> 00:47:26,940
that there's sort of a helpful thing to

00:47:25,470 --> 00:47:29,820
take away from this which is simply if

00:47:26,940 --> 00:47:33,330
you're not sure about why functional

00:47:29,820 --> 00:47:34,890
programming people don't use Django it's

00:47:33,330 --> 00:47:36,270
because it's these tools are lacking

00:47:34,890 --> 00:47:37,800
right it's not because they don't like

00:47:36,270 --> 00:47:39,840
the syntax or anything like that it's

00:47:37,800 --> 00:47:42,300
because these tools which I believe are

00:47:39,840 --> 00:47:47,160
essential and I think others do too I

00:47:42,300 --> 00:47:48,690
simply absent ok so there is a huge

00:47:47,160 --> 00:47:50,520
amount of code that I cannot write

00:47:48,690 --> 00:47:52,440
because I don't have these tools without

00:47:50,520 --> 00:47:54,930
parametric City I pretty much can't go

00:47:52,440 --> 00:47:57,809
very far at all if you look at

00:47:54,930 --> 00:48:00,630
Haskell and this is a common criticism

00:47:57,809 --> 00:48:02,760
you'll see sort of these no Magnificent

00:48:00,630 --> 00:48:05,579
type signatures that will blow your mind

00:48:02,760 --> 00:48:06,930
and hurt my mind too but the reason they

00:48:05,579 --> 00:48:08,880
like this is because they document the

00:48:06,930 --> 00:48:10,170
code when I tell me exactly what it does

00:48:08,880 --> 00:48:11,970
once I sort of goes for all the

00:48:10,170 --> 00:48:14,010
gymnastics to figure it out and I go oh

00:48:11,970 --> 00:48:19,200
that's what it does and that's my day's

00:48:14,010 --> 00:48:21,240
work finished so without these tools I

00:48:19,200 --> 00:48:22,619
can't write any of this code it just

00:48:21,240 --> 00:48:24,089
cannot I can't write it and I don't

00:48:22,619 --> 00:48:30,599
think anyone can because I've not seen

00:48:24,089 --> 00:48:32,130
it have you so if you accept and maybe

00:48:30,599 --> 00:48:33,690
don't and that's okay but if you do

00:48:32,130 --> 00:48:35,309
accept that equation the reasoning power

00:48:33,690 --> 00:48:36,780
matura sitting abstraction are essential

00:48:35,309 --> 00:48:39,000
tools to programming absolutely

00:48:36,780 --> 00:48:41,339
rudimentary you cannot get past first

00:48:39,000 --> 00:48:47,040
base without then you also accept you

00:48:41,339 --> 00:48:48,869
have a watermelon you have nothing so on

00:48:47,040 --> 00:48:50,400
a more constructive note how would I

00:48:48,869 --> 00:48:51,660
diversify and how would I understand

00:48:50,400 --> 00:48:54,839
these tools better how would I learn

00:48:51,660 --> 00:48:56,700
more about them well going you explore

00:48:54,839 --> 00:48:59,609
new programming languages and and so on

00:48:56,700 --> 00:49:01,920
say what if I put there so Agda Eggers a

00:48:59,609 --> 00:49:03,990
total total programming so AG is a total

00:49:01,920 --> 00:49:06,299
programming language that is to say you

00:49:03,990 --> 00:49:08,490
cannot write nonterminating applications

00:49:06,299 --> 00:49:11,099
in Ag dot I'm so every function always

00:49:08,490 --> 00:49:12,450
gives you a result you can't just sort

00:49:11,099 --> 00:49:15,410
of do this infinite recursion thing or

00:49:12,450 --> 00:49:18,150
return nulls or anything not possible

00:49:15,410 --> 00:49:20,280
addresses it has this thing called a

00:49:18,150 --> 00:49:21,750
totality checker as well and there's

00:49:20,280 --> 00:49:24,990
just sort of non total fuel functional

00:49:21,750 --> 00:49:26,609
programming like Haskell so if you would

00:49:24,990 --> 00:49:28,440
like to sort of understand these tools

00:49:26,609 --> 00:49:29,640
and form your own opinions so that you

00:49:28,440 --> 00:49:30,960
can sort of come back one day and go

00:49:29,640 --> 00:49:35,099
well you know what was that guy talking

00:49:30,960 --> 00:49:36,150
about that day crazy good well the

00:49:35,099 --> 00:49:38,280
answer this question is you would

00:49:36,150 --> 00:49:40,349
explore these tools and you would and

00:49:38,280 --> 00:49:41,520
and certainly there's a huge network of

00:49:40,349 --> 00:49:44,670
people that are willing to help you do

00:49:41,520 --> 00:49:46,530
that and to go back to the previous talk

00:49:44,670 --> 00:49:48,119
there's an IRC channel and so on and you

00:49:46,530 --> 00:49:52,530
know we have all the same principles we

00:49:48,119 --> 00:49:55,710
like helping you help yourself our

00:49:52,530 --> 00:49:58,280
families quote quite interesting and a

00:49:55,710 --> 00:49:58,280
little bit true

00:50:01,630 --> 00:50:06,650
sorry yeah it's kind of got a little bit

00:50:04,070 --> 00:50:10,490
mush there isn't it only says I've found

00:50:06,650 --> 00:50:12,620
that quote pythonic means : quote I'm

00:50:10,490 --> 00:50:13,700
ignoring years of academic / industry

00:50:12,620 --> 00:50:15,140
knowledge about programming and

00:50:13,700 --> 00:50:22,280
languages because I don't understand

00:50:15,140 --> 00:50:30,050
them and quote I I think this is sort of

00:50:22,280 --> 00:50:32,380
a well it's a true statement oh yeah so

00:50:30,050 --> 00:50:34,490
if you'd like to read some papers that

00:50:32,380 --> 00:50:37,460
talk about the things that I just spoken

00:50:34,490 --> 00:50:39,080
about here they're quick check is the

00:50:37,460 --> 00:50:40,490
thing that you know those unit tests

00:50:39,080 --> 00:50:42,530
that I was talking about we see an essay

00:50:40,490 --> 00:50:45,170
for all X while Allah quick check this

00:50:42,530 --> 00:50:47,210
quick check paper talks about that and

00:50:45,170 --> 00:50:54,710
that's all thank you very much thanks

00:50:47,210 --> 00:50:55,820
for listening ok thank you very much

00:50:54,710 --> 00:50:57,590
attorney I think we've got some people

00:50:55,820 --> 00:51:05,570
itching to ask questions here so okay

00:50:57,590 --> 00:51:09,460
I'll throw the lines question about no

00:51:05,570 --> 00:51:12,190
tools in Python to help with the

00:51:09,460 --> 00:51:15,860
side-effect free stuff have you done

00:51:12,190 --> 00:51:21,250
much we've twisted Python at all no well

00:51:15,860 --> 00:51:24,650
it sort of goes halfway there we've I

00:51:21,250 --> 00:51:27,230
guess the IO monad is sort of what

00:51:24,650 --> 00:51:29,930
Haskell and twisted sort of have is that

00:51:27,230 --> 00:51:33,530
you have a deferred which you passings

00:51:29,930 --> 00:51:35,000
and deferred whatever if you give it the

00:51:33,530 --> 00:51:36,890
same input it should always return the

00:51:35,000 --> 00:51:40,310
same output because even side-effect

00:51:36,890 --> 00:51:42,140
free so is that sort of stuff going in

00:51:40,310 --> 00:51:43,580
the right direction where if you build

00:51:42,140 --> 00:51:45,230
your applications out of all these

00:51:43,580 --> 00:51:48,590
side-effect free things you get a lot of

00:51:45,230 --> 00:51:51,170
the benefits is that um so like I said I

00:51:48,590 --> 00:51:54,500
haven't I Thanks lights person I haven't

00:51:51,170 --> 00:52:00,680
seen the twisted thing it's been around

00:51:54,500 --> 00:52:02,000
since 2003 so okay sorry I I struggle to

00:52:00,680 --> 00:52:04,550
understand how you would even do the

00:52:02,000 --> 00:52:06,770
Oman it in Python in a way that actually

00:52:04,550 --> 00:52:11,000
gives you all the benefits that's all so

00:52:06,770 --> 00:52:12,440
there are techniques to do it but let's

00:52:11,000 --> 00:52:16,060
assume for a minute that it does in fact

00:52:12,440 --> 00:52:22,490
do it what my question to you is

00:52:16,060 --> 00:52:26,030
what does that do that will you know all

00:52:22,490 --> 00:52:28,640
the syntax that will explode well it yes

00:52:26,030 --> 00:52:32,119
okay you'll need to do read file and

00:52:28,640 --> 00:52:35,720
then you'll have to do something to add

00:52:32,119 --> 00:52:41,630
the result of read file write an adding

00:52:35,720 --> 00:52:43,070
read file itself deferred is entire you

00:52:41,630 --> 00:52:46,580
all you gives a deferred object to which

00:52:43,070 --> 00:52:49,610
isn't about you yet so you have to add

00:52:46,580 --> 00:52:53,150
things on the end because it's a you

00:52:49,610 --> 00:52:57,320
have to add callbacks I guess yes so so

00:52:53,150 --> 00:53:00,080
if I if I sort of translate what I think

00:52:57,320 --> 00:53:03,410
you're saying you're saying that you

00:53:00,080 --> 00:53:05,330
know I can go well you know take take

00:53:03,410 --> 00:53:07,700
the program that reads a file and then

00:53:05,330 --> 00:53:10,369
call its result eighty what did I say I

00:53:07,700 --> 00:53:11,990
want to put ABC on the end of it I'll

00:53:10,369 --> 00:53:14,750
sorry on the start of it and I think I

00:53:11,990 --> 00:53:19,850
have to do one of these ones right there

00:53:14,750 --> 00:53:21,290
is an ABC out there yes so basically I

00:53:19,850 --> 00:53:22,760
have to glue the programs together in

00:53:21,290 --> 00:53:25,070
this way otherwise it just won't work

00:53:22,760 --> 00:53:28,160
yeah cuz anything with side effects well

00:53:25,070 --> 00:53:31,220
I should be that anything with IO side

00:53:28,160 --> 00:53:33,710
effects at least is not a direct value

00:53:31,220 --> 00:53:35,570
but a value at some point in time

00:53:33,710 --> 00:53:37,970
because we have to sort of do that

00:53:35,570 --> 00:53:39,590
because of the single thread of nature

00:53:37,970 --> 00:53:42,320
we can't just go out and spread some do

00:53:39,590 --> 00:53:44,869
all that fun stuff okay yes oh well I

00:53:42,320 --> 00:53:46,490
thank you for that I also submit a

00:53:44,869 --> 00:53:47,150
little bit of skepticism so I have to

00:53:46,490 --> 00:53:51,859
read about it

00:53:47,150 --> 00:53:54,109
thanks yeah so I've never really had a

00:53:51,859 --> 00:53:55,970
lot of problems reading Python code and

00:53:54,109 --> 00:53:59,450
fully understanding what a piece of

00:53:55,970 --> 00:54:01,970
Python code if it's well written does so

00:53:59,450 --> 00:54:03,950
when you described that the type itself

00:54:01,970 --> 00:54:05,750
documents the code the code in itself

00:54:03,950 --> 00:54:08,270
documents the code to me when I read

00:54:05,750 --> 00:54:11,540
Python what never documents is why the

00:54:08,270 --> 00:54:13,220
person decided to do it that way mm-hmm

00:54:11,540 --> 00:54:15,290
I assume that you end up having to use

00:54:13,220 --> 00:54:17,050
other documentation to actually document

00:54:15,290 --> 00:54:20,330
the why which is always to me a lot more

00:54:17,050 --> 00:54:26,840
important what Haskell community just

00:54:20,330 --> 00:54:27,980
use the type know the waiting to

00:54:26,840 --> 00:54:28,600
different questions is probably a little

00:54:27,980 --> 00:54:32,740
bit different

00:54:28,600 --> 00:54:34,720
so why someone did something is is often

00:54:32,740 --> 00:54:38,440
not important but when it does become

00:54:34,720 --> 00:54:39,970
important um then you know people write

00:54:38,440 --> 00:54:42,820
sort of English documentation or

00:54:39,970 --> 00:54:44,500
something like that but it's not it's

00:54:42,820 --> 00:54:47,080
not like the primary thing it's not like

00:54:44,500 --> 00:54:50,680
it's not like the thing to aspire to so

00:54:47,080 --> 00:54:52,690
it's sort of like the default the full

00:54:50,680 --> 00:54:53,890
full free thing you know I you know

00:54:52,690 --> 00:54:55,510
types didn't cover everything out

00:54:53,890 --> 00:54:57,040
testing cover everything we need to

00:54:55,510 --> 00:55:00,400
express some motivation for what's going

00:54:57,040 --> 00:55:02,260
on here because usually that's really

00:55:00,400 --> 00:55:03,490
what it is right so like I can come up

00:55:02,260 --> 00:55:05,650
with some elaborate data structure and

00:55:03,490 --> 00:55:07,720
I'm go here you go and you go why would

00:55:05,650 --> 00:55:09,040
you even do that and if I could motivate

00:55:07,720 --> 00:55:10,330
it if I could say to you look here's a

00:55:09,040 --> 00:55:12,160
problem that that you're familiar with

00:55:10,330 --> 00:55:13,600
and I can connect it to that data

00:55:12,160 --> 00:55:14,950
structure and I can go look this is how

00:55:13,600 --> 00:55:17,350
your problem is solved by this data

00:55:14,950 --> 00:55:18,820
structure I think that's the helpful

00:55:17,350 --> 00:55:21,850
thing and certainly that's the case I

00:55:18,820 --> 00:55:23,650
like we do try to motivate these these

00:55:21,850 --> 00:55:29,950
sort of abstract crazy things that you

00:55:23,650 --> 00:55:32,020
see okay thank you well first of all if

00:55:29,950 --> 00:55:34,960
you think pythons bad you should go into

00:55:32,020 --> 00:55:36,940
the node community at some point love

00:55:34,960 --> 00:55:39,310
all they're doing with languages but

00:55:36,940 --> 00:55:41,320
secondly like so as someone who is

00:55:39,310 --> 00:55:42,940
trained in both kinds of programming and

00:55:41,320 --> 00:55:46,450
my tutor University was a type systems

00:55:42,940 --> 00:55:47,860
theorist it was quite interesting I'm

00:55:46,450 --> 00:55:51,400
curious what your possessive like you

00:55:47,860 --> 00:55:52,600
know as far as I can tell your comment

00:55:51,400 --> 00:55:55,630
on tools is very fascinating because

00:55:52,600 --> 00:55:58,090
like the reason I think procedural and

00:55:55,630 --> 00:56:00,490
Python non-fact on the programming in

00:55:58,090 --> 00:56:02,470
general is popular is that the societal

00:56:00,490 --> 00:56:04,170
tools the reference points the support

00:56:02,470 --> 00:56:06,430
communities are there and the

00:56:04,170 --> 00:56:07,450
instructions therefore imperative

00:56:06,430 --> 00:56:08,620
procedure whatever and call it

00:56:07,450 --> 00:56:10,720
programming much more than it's a

00:56:08,620 --> 00:56:12,460
functional like you know they are

00:56:10,720 --> 00:56:14,770
equivalent at some point and in some

00:56:12,460 --> 00:56:16,750
ways functional Haskell is more

00:56:14,770 --> 00:56:18,310
mathematic you're a total language will

00:56:16,750 --> 00:56:22,330
be lovely that is in fact for some

00:56:18,310 --> 00:56:23,890
reasons do you think that they'll ever

00:56:22,330 --> 00:56:25,780
be a way to functional to break out of

00:56:23,890 --> 00:56:27,640
that mold of being the the site language

00:56:25,780 --> 00:56:29,320
or is it always gonna be like no the

00:56:27,640 --> 00:56:33,160
dominance of our languages is kind of

00:56:29,320 --> 00:56:36,190
fixed from the historical but um yeah ok

00:56:33,160 --> 00:56:38,890
good so these in terms of what what do I

00:56:36,190 --> 00:56:40,570
predict for the future in terms anyway

00:56:38,890 --> 00:56:46,180
to make functional programming more

00:56:40,570 --> 00:56:48,369
more of a well-known year do this but I

00:56:46,180 --> 00:56:51,220
mean the problem with talks like this no

00:56:48,369 --> 00:56:53,470
it's stupid ooh is that like a lot of

00:56:51,220 --> 00:56:55,450
the terms you use especially in

00:56:53,470 --> 00:56:58,030
programming are over loads of imgur it's

00:56:55,450 --> 00:56:59,170
like total bottom other things like that

00:56:58,030 --> 00:57:01,330
like they're all they all had existing

00:56:59,170 --> 00:57:02,740
meanings like I put it to you that

00:57:01,330 --> 00:57:04,119
you're all very brave and we can all

00:57:02,740 --> 00:57:06,070
just sit down and write the code and

00:57:04,119 --> 00:57:07,570
just figure it all I like it I have no

00:57:06,070 --> 00:57:10,720
better answer to let's just do the hard

00:57:07,570 --> 00:57:13,090
work right but yeah do you think there's

00:57:10,720 --> 00:57:14,650
any possibility some point of like you

00:57:13,090 --> 00:57:16,480
know I think there is a possibility for

00:57:14,650 --> 00:57:18,460
a hybrid language a true hybrid language

00:57:16,480 --> 00:57:21,130
between Python and Haskell like that

00:57:18,460 --> 00:57:26,080
they share some similarities like what

00:57:21,130 --> 00:57:29,020
would I take from Python though what no

00:57:26,080 --> 00:57:31,150
seriously like even for educational

00:57:29,020 --> 00:57:32,650
purposes well what would I do like III I

00:57:31,150 --> 00:57:35,140
don't know the answer this question I

00:57:32,650 --> 00:57:38,040
just don't know what I would do I would

00:57:35,140 --> 00:57:40,240
argue the syntax is nicer oh well I

00:57:38,040 --> 00:57:42,070
don't agree but the fact that I don't

00:57:40,240 --> 00:57:44,950
agree I don't actually don't think it's

00:57:42,070 --> 00:57:47,290
consequential like you know did the word

00:57:44,950 --> 00:57:48,700
mana be difficult because of the syntax

00:57:47,290 --> 00:57:50,890
I don't think so I think it's the

00:57:48,700 --> 00:57:52,480
concept it's I think I think we move

00:57:50,890 --> 00:57:54,220
mana as instructions it's the

00:57:52,480 --> 00:57:56,140
mathematics as well like you're assuming

00:57:54,220 --> 00:57:57,880
a very heavy like theoretical background

00:57:56,140 --> 00:58:00,310
and some people come it's from very sort

00:57:57,880 --> 00:58:01,810
of almost a literary or worldview

00:58:00,310 --> 00:58:03,430
background well yeah you come in saying

00:58:01,810 --> 00:58:05,290
like you know I understand how the world

00:58:03,430 --> 00:58:06,510
works how cause and effect happens and

00:58:05,290 --> 00:58:08,470
like there's a different thing like

00:58:06,510 --> 00:58:10,570
theoretical mathematical design I think

00:58:08,470 --> 00:58:12,070
is a different thing sir well I let's

00:58:10,570 --> 00:58:14,080
take them on that example right so the

00:58:12,070 --> 00:58:15,790
only thing I can do is I can try and

00:58:14,080 --> 00:58:18,670
sort of motivate it for you right so I

00:58:15,790 --> 00:58:20,350
can go well you know it's an abstraction

00:58:18,670 --> 00:58:22,390
it has these operations and instances

00:58:20,350 --> 00:58:24,390
and so I think most people are familiar

00:58:22,390 --> 00:58:26,950
with lists and continuations and so on

00:58:24,390 --> 00:58:28,990
the the disconnect part or the part

00:58:26,950 --> 00:58:30,460
that's not going to be familiar is where

00:58:28,990 --> 00:58:31,540
someone goes but why would I use that

00:58:30,460 --> 00:58:32,619
you know tomorrow I'm going to go and

00:58:31,540 --> 00:58:34,900
write this code and I'm not going to see

00:58:32,619 --> 00:58:37,750
my eyes and and the answer this question

00:58:34,900 --> 00:58:39,250
is well you you slowly make the

00:58:37,750 --> 00:58:40,359
connection all right so you go well

00:58:39,250 --> 00:58:41,859
here's one out and here's the problem

00:58:40,359 --> 00:58:43,420
you're solving and notice how this does

00:58:41,859 --> 00:58:44,530
solve it and it briefly sticks in your

00:58:43,420 --> 00:58:46,570
mind for that one minute when you go

00:58:44,530 --> 00:58:47,859
yeah it does and then you just repeat

00:58:46,570 --> 00:58:50,590
this in practice and eventually you

00:58:47,859 --> 00:58:52,270
figure it out and look I've been through

00:58:50,590 --> 00:58:53,950
this process with a lot of people right

00:58:52,270 --> 00:58:55,150
and say they sort of first

00:58:53,950 --> 00:58:56,260
we have to establish a bit of a trust

00:58:55,150 --> 00:58:57,790
and they go you know I trust that you

00:58:56,260 --> 00:59:00,010
know what you're talking about I have no

00:58:57,790 --> 00:59:01,270
idea what you just said but we'll just

00:59:00,010 --> 00:59:03,700
sit down and labour through it with you

00:59:01,270 --> 00:59:06,730
okay let's go and and these connections

00:59:03,700 --> 00:59:10,660
are slowly made and I find that really

00:59:06,730 --> 00:59:12,070
challenging I enjoy it a lot but I just

00:59:10,660 --> 00:59:14,290
had no better answer other than let's

00:59:12,070 --> 00:59:15,880
just go through this labor of getting

00:59:14,290 --> 00:59:18,010
there and making all these connections

00:59:15,880 --> 00:59:19,000
and then make up your own mind I mean

00:59:18,010 --> 00:59:20,980
you can get to the other side and go

00:59:19,000 --> 00:59:23,440
well that was just rubbish I've never

00:59:20,980 --> 00:59:25,150
seen anyone who does that I mean I

00:59:23,440 --> 00:59:26,980
stopped Ottoman programming that hasn't

00:59:25,150 --> 00:59:30,730
it's amazing more practical thing you

00:59:26,980 --> 00:59:33,970
know I I disagree with your reasoning

00:59:30,730 --> 00:59:36,070
that you need those three basic axioms

00:59:33,970 --> 00:59:39,099
to do programming like okay at some

00:59:36,070 --> 00:59:42,450
point I think there is a trade-off much

00:59:39,099 --> 00:59:45,750
like with with abstractions between

00:59:42,450 --> 00:59:48,339
almost like rigorous consistency and

00:59:45,750 --> 00:59:49,540
speed of implementation okay so let's

00:59:48,339 --> 00:59:50,650
try it it off right so here I got

00:59:49,540 --> 00:59:51,820
through it all right now what benefit

00:59:50,650 --> 00:59:52,810
did it gives you just giving me finance

00:59:51,820 --> 00:59:53,980
I throw a little I said there's some of

00:59:52,810 --> 00:59:56,020
it away I can't I'll throw some of it

00:59:53,980 --> 00:59:57,760
away a little bit give me the benefit is

00:59:56,020 --> 00:59:59,710
you can give me a nonzero benefit on all

00:59:57,760 --> 01:00:01,869
I'm all for it let's but it's not direct

00:59:59,710 --> 01:00:03,579
benefit like you don't buy throwing away

01:00:01,869 --> 01:00:06,970
you're not gaining things it's that you

01:00:03,579 --> 01:00:08,349
can you can be it's is that you can be

01:00:06,970 --> 01:00:10,930
more strapped - right at some point

01:00:08,349 --> 01:00:12,970
programs I don't build at my thing like

01:00:10,930 --> 01:00:15,970
in your mind programs are perfect in my

01:00:12,970 --> 01:00:17,140
mind programs are not they're imperfect

01:00:15,970 --> 01:00:20,319
right that's why I need all my tool

01:00:17,140 --> 01:00:21,730
support I know I think it's the

01:00:20,319 --> 01:00:26,109
mathematics engineering difference right

01:00:21,730 --> 01:00:30,390
this question but no and you have a rest

01:00:26,109 --> 01:00:30,390
of it thank you this alright thank you

01:00:33,240 --> 01:00:38,800
so speaking of you know actually I am an

01:00:37,150 --> 01:00:43,210
old static type guy so that on that

01:00:38,800 --> 01:00:45,250
point I'm pre-sold but so the problem I

01:00:43,210 --> 01:00:47,319
think and I may be sort of summarizing

01:00:45,250 --> 01:00:49,690
Andrews point is there's an audience of

01:00:47,319 --> 01:00:51,880
Python programmers here and winsome and

01:00:49,690 --> 01:00:54,130
you come and say you're not programming

01:00:51,880 --> 01:00:56,050
you can't program without these that we

01:00:54,130 --> 01:00:57,849
all sort of look around and go I thought

01:00:56,050 --> 01:00:59,200
I just did yeah you know I thought it we

01:00:57,849 --> 01:01:00,819
I thought I had you know five hundred

01:00:59,200 --> 01:01:04,450
thousand lines a perfectly good working

01:01:00,819 --> 01:01:07,030
Python code so clearly you're presenting

01:01:04,450 --> 01:01:07,599
a benefit but the benefit has to be

01:01:07,030 --> 01:01:10,900
something

01:01:07,599 --> 01:01:13,719
other than your pure you're just you

01:01:10,900 --> 01:01:15,969
know and I'm afraid the kind of what I

01:01:13,719 --> 01:01:18,430
got for anything is that were you know

01:01:15,969 --> 01:01:21,369
we we will breathe better air and you

01:01:18,430 --> 01:01:25,299
know we'll be a higher plane which you

01:01:21,369 --> 01:01:28,989
know and and I am so your message kind

01:01:25,299 --> 01:01:31,119
of wasn't what you know so you know as

01:01:28,989 --> 01:01:32,920
an engineer you know somebody who has to

01:01:31,119 --> 01:01:34,869
you know you know I write comic books

01:01:32,920 --> 01:01:37,930
for a hobby I don't you know I don't

01:01:34,869 --> 01:01:41,979
know I just make money doing this what

01:01:37,930 --> 01:01:42,699
good thing will I get okay and I think

01:01:41,979 --> 01:01:45,130
it's probably the most difficult

01:01:42,699 --> 01:01:49,529
question it's true you're all writing

01:01:45,130 --> 01:01:52,479
thousands of lines of Python programs so

01:01:49,529 --> 01:01:56,499
the best way that I can try to answer it

01:01:52,479 --> 01:01:58,959
is simply take them on out abstraction

01:01:56,499 --> 01:02:01,329
and imagine I just pulled it away from

01:01:58,959 --> 01:02:02,859
you the only thing you could do now is

01:02:01,329 --> 01:02:04,479
just write this same code over and over

01:02:02,859 --> 01:02:06,069
again for like you know the sequence

01:02:04,479 --> 01:02:07,719
function that I had up there you have to

01:02:06,069 --> 01:02:09,940
write it for all the different monitors

01:02:07,719 --> 01:02:12,400
for lists and continuations and so on it

01:02:09,940 --> 01:02:14,130
just be copy paste now I'm not saying

01:02:12,400 --> 01:02:16,959
that that's what you're actually doing

01:02:14,130 --> 01:02:18,489
it's just that when we take this code

01:02:16,959 --> 01:02:21,459
that you are writing and we you know

01:02:18,489 --> 01:02:22,630
call it refactoring or sort of going

01:02:21,459 --> 01:02:26,229
through and finding all the similarities

01:02:22,630 --> 01:02:27,880
and extracting it and so on what what if

01:02:26,229 --> 01:02:29,259
we sort of stick true to that thesis of

01:02:27,880 --> 01:02:30,459
actually just doing this over and over

01:02:29,259 --> 01:02:34,809
and over again what do we have at the

01:02:30,459 --> 01:02:36,640
end and I think you I I think you'll

01:02:34,809 --> 01:02:39,369
find it's actually a lot shorter than

01:02:36,640 --> 01:02:40,779
that you know and which is not the goal

01:02:39,369 --> 01:02:43,690
it's not to be shorter it's just to stop

01:02:40,779 --> 01:02:47,949
repeating the same work over and over so

01:02:43,690 --> 01:02:50,589
so the practical benefit is that that

01:02:47,949 --> 01:02:53,259
thing that took you all week is already

01:02:50,589 --> 01:02:55,150
done someone sort of has written it in a

01:02:53,259 --> 01:02:55,630
library yesterday you know whatever it

01:02:55,150 --> 01:02:57,249
might be

01:02:55,630 --> 01:03:00,430
and it's sort it's like a faster way to

01:02:57,249 --> 01:03:01,989
progress hopefully that that helps a bit

01:03:00,430 --> 01:03:07,150
I realize the difficulty of that

01:03:01,989 --> 01:03:08,259
question I've seen it a lot yeah should

01:03:07,150 --> 01:03:10,900
be a simple question because you said

01:03:08,259 --> 01:03:13,150
you had an answer why don't we have

01:03:10,900 --> 01:03:15,390
these non-trivial abstractions in Python

01:03:13,150 --> 01:03:17,799
oh because you don't have a type system

01:03:15,390 --> 01:03:18,940
no one can write them so if you ask me

01:03:17,799 --> 01:03:21,299
to sit down arrivin the chance of me

01:03:18,940 --> 01:03:23,309
making a mistake is 100 percent

01:03:21,299 --> 01:03:26,579
the chance of someone who is way better

01:03:23,309 --> 01:03:30,690
programmer than iron is still 100% and

01:03:26,579 --> 01:03:33,089
this conjecture that that's why I don't

01:03:30,690 --> 01:03:36,059
I don't know for sure why what where's

01:03:33,089 --> 01:03:37,170
mono transformers I'm pretty sure they

01:03:36,059 --> 01:03:40,109
don't exist what do you want to type it

01:03:37,170 --> 01:03:44,700
into Google I'm pretty sure that's just

01:03:40,109 --> 01:03:46,049
a guess right alright thanks guys say

01:03:44,700 --> 01:03:48,770
thank you very much tiny for some very

01:03:46,049 --> 01:03:48,770
illuminating goods

01:03:55,190 --> 01:03:57,250

YouTube URL: https://www.youtube.com/watch?v=uqsZa36Io2M


