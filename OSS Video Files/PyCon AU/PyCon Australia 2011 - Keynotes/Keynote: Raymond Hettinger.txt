Title: Keynote: Raymond Hettinger
Publication date: 2011-08-25
Playlist: PyCon Australia 2011 - Keynotes
Description: 
	Keynote by Raymond Hettinger.
Captions: 
	00:00:00,890 --> 00:00:09,150
so I get to make the claim of having the

00:00:03,510 --> 00:00:12,809
awesome talk okay so my twitter hashtag

00:00:09,150 --> 00:00:14,759
is at Raymond H so tweet away I will

00:00:12,809 --> 00:00:16,590
look at some point if you want to pass

00:00:14,759 --> 00:00:18,990
some questions along on Twitter I will

00:00:16,590 --> 00:00:21,180
take a look before the end will scan

00:00:18,990 --> 00:00:23,400
through them and answer them and as

00:00:21,180 --> 00:00:25,080
Richard pointed out I'm trying to use

00:00:23,400 --> 00:00:27,060
Twitter in a different way I'm trying to

00:00:25,080 --> 00:00:30,750
send out technical tweets so I challenge

00:00:27,060 --> 00:00:32,340
myself every day or two to try and put

00:00:30,750 --> 00:00:34,620
together something technical and useful

00:00:32,340 --> 00:00:37,530
and to fit it into 140 characters so

00:00:34,620 --> 00:00:43,200
that I don't waste your time and today's

00:00:37,530 --> 00:00:44,340
talk is of what makes Python awesome you

00:00:43,200 --> 00:00:46,530
wouldn't be here if you didn't think the

00:00:44,340 --> 00:00:48,360
Python was an awesome language but then

00:00:46,530 --> 00:00:51,000
I have to raise the question why is it

00:00:48,360 --> 00:00:53,430
awesome and what I did was went around

00:00:51,000 --> 00:00:54,780
to a number of companies I can do a lot

00:00:53,430 --> 00:00:56,250
of consulting and training and I've

00:00:54,780 --> 00:00:58,350
talked to a lot of people and tried to

00:00:56,250 --> 00:01:00,300
collect some survey results back and

00:00:58,350 --> 00:01:04,070
share what are the characteristics of a

00:01:00,300 --> 00:01:07,049
truly awesome language so quick

00:01:04,070 --> 00:01:10,470
introduction here I'm a PSF board member

00:01:07,049 --> 00:01:13,110
I've been a core developer since 2001 I

00:01:10,470 --> 00:01:15,509
put together a lot of tools that you use

00:01:13,110 --> 00:01:18,270
everyday like I've wrote the set objects

00:01:15,509 --> 00:01:20,880
and bitter tools and lots of other

00:01:18,270 --> 00:01:23,270
interesting gizmos the one of the latest

00:01:20,880 --> 00:01:26,430
being the LRU cache in the new chain map

00:01:23,270 --> 00:01:35,930
function and there's my Twitter account

00:01:26,430 --> 00:01:35,930
again all right name an awesome language

00:01:36,290 --> 00:01:48,290
really why readability

00:01:42,680 --> 00:01:50,750
I can read somebody else's code all

00:01:48,290 --> 00:01:51,950
right something makes it great let's see

00:01:50,750 --> 00:01:53,900
if we can figure out because there are

00:01:51,950 --> 00:01:55,550
other awesome languages I contend that

00:01:53,900 --> 00:01:56,900
all of these languages are awesome I

00:01:55,550 --> 00:01:59,150
have programmed in all of them at one

00:01:56,900 --> 00:02:02,390
time or another I've done very little

00:01:59,150 --> 00:02:03,890
programming in Lua and Scala but most of

00:02:02,390 --> 00:02:06,350
these others I've used heavily at one

00:02:03,890 --> 00:02:07,880
time or another and if you have heard of

00:02:06,350 --> 00:02:10,130
them that means that they're awesome

00:02:07,880 --> 00:02:12,470
because there are thousands and

00:02:10,130 --> 00:02:13,430
thousands of languages out there if it's

00:02:12,470 --> 00:02:15,020
gotten to the point where you've heard

00:02:13,430 --> 00:02:17,120
of it it mean that meant that at one

00:02:15,020 --> 00:02:20,450
point in our history it solved a problem

00:02:17,120 --> 00:02:23,660
well a problem that people had and it

00:02:20,450 --> 00:02:25,520
overcame them how does Python get itself

00:02:23,660 --> 00:02:27,530
on this list of Awesome languages what

00:02:25,520 --> 00:02:29,660
makes it special why did I stop

00:02:27,530 --> 00:02:32,150
programming in aachen assembler and Lisp

00:02:29,660 --> 00:02:34,720
insane come to Python it had something

00:02:32,150 --> 00:02:37,400
that made it better what was that stuff

00:02:34,720 --> 00:02:39,950
so I had many language to choose from

00:02:37,400 --> 00:02:42,190
lots are good or in their own way our

00:02:39,950 --> 00:02:45,709
goal is to identify the success factors

00:02:42,190 --> 00:02:47,390
all right so I'm gonna start from a very

00:02:45,709 --> 00:02:48,470
high-level contextual point of view if

00:02:47,390 --> 00:02:50,750
we're going to make a new awesome

00:02:48,470 --> 00:02:52,190
language let's set a good context for it

00:02:50,750 --> 00:02:55,160
and finally get the context factors

00:02:52,190 --> 00:02:57,739
right then we're gonna go in one level

00:02:55,160 --> 00:02:59,720
and say once we've got the context that

00:02:57,739 --> 00:03:01,130
what are the actual characteristics of

00:02:59,720 --> 00:03:02,780
the language that we want because

00:03:01,130 --> 00:03:05,810
there's lots of little design choices

00:03:02,780 --> 00:03:08,269
you can make of just the overall layout

00:03:05,810 --> 00:03:10,040
of a language and then having done that

00:03:08,269 --> 00:03:12,410
we will go into the specifics of what is

00:03:10,040 --> 00:03:15,830
it that python has that other languages

00:03:12,410 --> 00:03:20,120
don't so one of the context factors one

00:03:15,830 --> 00:03:22,370
I think is vital is our license so an

00:03:20,120 --> 00:03:24,350
open-source license and you know the

00:03:22,370 --> 00:03:25,900
time cuido made python lots of people

00:03:24,350 --> 00:03:28,370
were creating languages

00:03:25,900 --> 00:03:30,590
he put his out on the net and let other

00:03:28,370 --> 00:03:33,080
people contribute to it and he made it

00:03:30,590 --> 00:03:34,730
open-source that changed everything when

00:03:33,080 --> 00:03:37,100
I go into some companies now they are

00:03:34,730 --> 00:03:38,690
choosing between Python and languages

00:03:37,100 --> 00:03:40,940
that require a license where they have

00:03:38,690 --> 00:03:43,190
to for every person who runs an

00:03:40,940 --> 00:03:45,350
interpreter they would have to buy a

00:03:43,190 --> 00:03:46,780
unique license Python is free for them

00:03:45,350 --> 00:03:49,750
that's fantastic

00:03:46,780 --> 00:03:51,940
being free and being open source is a

00:03:49,750 --> 00:03:53,800
fantastic thing I tell big companies

00:03:51,940 --> 00:03:57,160
what is the advantage of open source for

00:03:53,800 --> 00:03:59,260
you oh the advantage is if everyone else

00:03:57,160 --> 00:04:01,420
quit using Python tomorrow and went on

00:03:59,260 --> 00:04:03,400
to next cool language X would your

00:04:01,420 --> 00:04:05,830
company be left in the lurch no you can

00:04:03,400 --> 00:04:08,620
recompile Python yourself and add on to

00:04:05,830 --> 00:04:10,900
it and modify it you were not trapped as

00:04:08,620 --> 00:04:12,459
you would be with another tool where you

00:04:10,900 --> 00:04:14,320
don't get the the source code behind it

00:04:12,459 --> 00:04:15,760
I think this was vital so if we're going

00:04:14,320 --> 00:04:19,060
to create a new language we need a good

00:04:15,760 --> 00:04:20,169
open-source license it is vital I think

00:04:19,060 --> 00:04:21,340
for a language not just to be

00:04:20,169 --> 00:04:23,200
open-source but to have commercial

00:04:21,340 --> 00:04:26,140
distributions we have our active state

00:04:23,200 --> 00:04:29,140
and in thaw selling Python why would you

00:04:26,140 --> 00:04:31,060
buy Python if Python is available for

00:04:29,140 --> 00:04:32,860
free the answer is there's some value

00:04:31,060 --> 00:04:34,419
adds that these companies put in they

00:04:32,860 --> 00:04:35,560
roll together other things in their

00:04:34,419 --> 00:04:38,200
distribution like the in thought

00:04:35,560 --> 00:04:40,450
distribution includes tools that's like

00:04:38,200 --> 00:04:42,580
numpy inside pi and lots of things free

00:04:40,450 --> 00:04:44,770
compiled they've made it easy to install

00:04:42,580 --> 00:04:47,590
on your machines in a consistent way

00:04:44,770 --> 00:04:51,460
regardless of your platform they provide

00:04:47,590 --> 00:04:52,600
phone support many big companies what

00:04:51,460 --> 00:04:53,650
are they looking for when they buy

00:04:52,600 --> 00:04:55,990
something why would they pay for

00:04:53,650 --> 00:04:58,229
something they can get for free they

00:04:55,990 --> 00:05:01,169
want a throat to choke somebody to say

00:04:58,229 --> 00:05:03,460
this thing isn't working fix it now and

00:05:01,169 --> 00:05:05,350
so these guys will fix some critical

00:05:03,460 --> 00:05:07,060
bugs for those companies and they

00:05:05,350 --> 00:05:09,669
contribute back to the community I think

00:05:07,060 --> 00:05:11,350
having a commercial side is vital and if

00:05:09,669 --> 00:05:12,940
we had had a license that prohibited the

00:05:11,350 --> 00:05:15,160
commercial side we would have lost this

00:05:12,940 --> 00:05:17,229
this is an enormous benefit from us it

00:05:15,160 --> 00:05:22,210
is why really big companies can adopt

00:05:17,229 --> 00:05:23,919
Python and we've got Zin now all of you

00:05:22,210 --> 00:05:26,440
went to Richard's talk yesterday I

00:05:23,919 --> 00:05:28,229
probably had a mind opening experience

00:05:26,440 --> 00:05:30,850
of what the Zen was all about I've

00:05:28,229 --> 00:05:32,770
thought I internalize in the very first

00:05:30,850 --> 00:05:34,240
time I read it it was only after

00:05:32,770 --> 00:05:35,800
listening to Richards talk that I

00:05:34,240 --> 00:05:38,050
realized there was a lot more to it and

00:05:35,800 --> 00:05:40,150
then I had ever thought about before but

00:05:38,050 --> 00:05:42,610
what is the significance of the Zen from

00:05:40,150 --> 00:05:44,200
a contextual point of view all the core

00:05:42,610 --> 00:05:46,720
developers read this they try and

00:05:44,200 --> 00:05:48,580
internalize it to some degree and we try

00:05:46,720 --> 00:05:50,229
and program in that way and so it makes

00:05:48,580 --> 00:05:51,580
the language much more uniform and

00:05:50,229 --> 00:05:53,320
consistent than the language that

00:05:51,580 --> 00:05:54,580
doesn't have a shared core philosophy it

00:05:53,320 --> 00:05:56,590
almost doesn't matter what this

00:05:54,580 --> 00:05:58,390
philosophy is if you're going to make a

00:05:56,590 --> 00:06:00,070
new language you

00:05:58,390 --> 00:06:01,480
to create a philosophy so that all the

00:06:00,070 --> 00:06:03,040
developers are all marching the same

00:06:01,480 --> 00:06:03,820
line and make pieces that fit together

00:06:03,040 --> 00:06:05,680
really well

00:06:03,820 --> 00:06:09,040
I think Python has done a magnificent

00:06:05,680 --> 00:06:10,810
job for us and the Zen was part of it it

00:06:09,040 --> 00:06:12,640
is part of what makes them the language

00:06:10,810 --> 00:06:14,920
so easy to learn and once you've had

00:06:12,640 --> 00:06:16,870
adopted this mindset you know what to

00:06:14,920 --> 00:06:19,240
expect out of the language I think it's

00:06:16,870 --> 00:06:21,910
fantastic there are other types of Zen

00:06:19,240 --> 00:06:23,860
for other languages pearled values the

00:06:21,910 --> 00:06:26,200
many ways to do it and I don't think

00:06:23,860 --> 00:06:27,820
that is a wrong answer for them you can

00:06:26,200 --> 00:06:31,120
always choose the very best matching

00:06:27,820 --> 00:06:32,710
tool out of many and that is their

00:06:31,120 --> 00:06:34,660
philosophy and they stick with it fairly

00:06:32,710 --> 00:06:36,520
well and it has been a winning strategy

00:06:34,660 --> 00:06:38,140
for us we choose the one way to do it

00:06:36,520 --> 00:06:40,120
it's our philosophy and it's worked well

00:06:38,140 --> 00:06:42,070
for us it almost doesn't matter what the

00:06:40,120 --> 00:06:43,960
philosophy is you need unifying

00:06:42,070 --> 00:06:48,700
principles when you create a new

00:06:43,960 --> 00:06:50,380
language or is then I think a killer

00:06:48,700 --> 00:06:54,310
feature for a language is to have

00:06:50,380 --> 00:06:56,200
community it's fantastic that we you can

00:06:54,310 --> 00:06:58,960
go out to complain Python news groups on

00:06:56,200 --> 00:07:01,660
the Usenet and ask a question Wow there

00:06:58,960 --> 00:07:03,400
are lots of XML packages out there

00:07:01,660 --> 00:07:05,830
here is my particular need in the use

00:07:03,400 --> 00:07:08,590
case can you guys tell me which one is

00:07:05,830 --> 00:07:11,110
the best and experts will chime back in

00:07:08,590 --> 00:07:13,060
ll xml is the fastest for your

00:07:11,110 --> 00:07:15,520
particular need because of your your

00:07:13,060 --> 00:07:16,930
volume Arvika you want you need ease of

00:07:15,520 --> 00:07:18,250
installation so you want to use things

00:07:16,930 --> 00:07:21,640
they're already in the standard library

00:07:18,250 --> 00:07:24,640
we recommend the element tree package

00:07:21,640 --> 00:07:27,100
for example this is a fantastic resource

00:07:24,640 --> 00:07:30,310
there are plenty of other languages that

00:07:27,100 --> 00:07:33,220
are used in companies all over the world

00:07:30,310 --> 00:07:35,560
where the people programming they can

00:07:33,220 --> 00:07:36,940
try and look something up at a book they

00:07:35,560 --> 00:07:39,040
can try and do a little research on the

00:07:36,940 --> 00:07:41,230
net there's no place they can go and

00:07:39,040 --> 00:07:43,120
just ask questions and get answers from

00:07:41,230 --> 00:07:44,800
core developers or other senior

00:07:43,120 --> 00:07:47,290
developers all around the world the

00:07:44,800 --> 00:07:50,890
community is a fantastic reason for

00:07:47,290 --> 00:07:52,870
adopting Python we have a mailing list

00:07:50,890 --> 00:07:54,370
that Python dev mail lists there's

00:07:52,870 --> 00:07:55,870
Python health where you can get

00:07:54,370 --> 00:08:01,690
individual though how many of you know

00:07:55,870 --> 00:08:04,990
about Python he'll fantastic interesting

00:08:01,690 --> 00:08:06,370
about Python he'll is that the kind of

00:08:04,990 --> 00:08:09,010
people who are in this room a lot of you

00:08:06,370 --> 00:08:10,470
will become top-level Python experts in

00:08:09,010 --> 00:08:11,910
a short period of time you

00:08:10,470 --> 00:08:14,760
go on the other side of the help desk

00:08:11,910 --> 00:08:16,050
and volunteer to help men and answer

00:08:14,760 --> 00:08:17,670
questions for people all around the

00:08:16,050 --> 00:08:19,650
world and give them individual help and

00:08:17,670 --> 00:08:21,480
they've really value that it's something

00:08:19,650 --> 00:08:23,700
our language offers that I think very

00:08:21,480 --> 00:08:26,070
few other languages I have and we have a

00:08:23,700 --> 00:08:27,900
to-do list there pike ons showing up

00:08:26,070 --> 00:08:32,820
everywhere I've heard there's one as far

00:08:27,900 --> 00:08:36,890
away as Australia and this little island

00:08:32,820 --> 00:08:38,700
nearby a New Zealand yes

00:08:36,890 --> 00:08:40,050
actually from your point of view those

00:08:38,700 --> 00:08:42,180
things are close but they're propping up

00:08:40,050 --> 00:08:43,919
all over the world and it's fantastic

00:08:42,180 --> 00:08:47,610
and there's Python interest groups

00:08:43,919 --> 00:08:49,980
everywhere I consider these to be

00:08:47,610 --> 00:08:51,060
contextual factors for the success of a

00:08:49,980 --> 00:08:53,760
language we're going to build some

00:08:51,060 --> 00:08:55,680
language we need a rock-solid community

00:08:53,760 --> 00:08:58,080
we need to get license we need

00:08:55,680 --> 00:09:00,570
commercial support but also we need a

00:08:58,080 --> 00:09:02,580
way to exchange packages so for us it's

00:09:00,570 --> 00:09:05,790
a I've heard this pronouncing in many

00:09:02,580 --> 00:09:08,880
ways when my favorite is Pippi so Pippi

00:09:05,790 --> 00:09:12,240
is the repository of packages we're up

00:09:08,880 --> 00:09:13,770
in the 16000 range right now and it's

00:09:12,240 --> 00:09:16,589
fantastic

00:09:13,770 --> 00:09:18,089
they're free you can often when you go

00:09:16,589 --> 00:09:19,589
to solve a problem you can do a search

00:09:18,089 --> 00:09:22,740
of Pippi and find that someone else has

00:09:19,589 --> 00:09:24,570
already solved it if you use pip you can

00:09:22,740 --> 00:09:27,270
install it very quickly by say pip

00:09:24,570 --> 00:09:28,700
install order dick and presto and python

00:09:27,270 --> 00:09:31,950
two five you can have an order dick

00:09:28,700 --> 00:09:35,250
because the code has been back board it

00:09:31,950 --> 00:09:36,660
I think that's fantastic very simple

00:09:35,250 --> 00:09:37,260
installation procedure who thinks that's

00:09:36,660 --> 00:09:42,360
wonderful

00:09:37,260 --> 00:09:43,860
it rocks okay and then every language to

00:09:42,360 --> 00:09:46,080
get on the map has to have a few killer

00:09:43,860 --> 00:09:48,839
apps and success stories why is soap up

00:09:46,080 --> 00:09:52,110
here soap was the first biggest invest

00:09:48,839 --> 00:09:53,760
it is in its time we should all think so

00:09:52,110 --> 00:09:55,920
because we wouldn't be here right now if

00:09:53,760 --> 00:09:58,530
it weren't for the success of soap there

00:09:55,920 --> 00:10:01,050
later successors such as a Django and

00:09:58,530 --> 00:10:02,850
pylons of other web development

00:10:01,050 --> 00:10:05,430
frameworks there's an enormous

00:10:02,850 --> 00:10:06,780
scientific community which would not be

00:10:05,430 --> 00:10:10,950
there if it weren't for Matt fought live

00:10:06,780 --> 00:10:13,650
Syfy and numpy BitTorrent was written in

00:10:10,950 --> 00:10:14,880
pure Python and so there's a wonderful

00:10:13,650 --> 00:10:17,490
success story it was put together in

00:10:14,880 --> 00:10:19,530
very few days if you are into reading

00:10:17,490 --> 00:10:21,060
technical papers the technical

00:10:19,530 --> 00:10:21,690
description of how BitTorrent was put

00:10:21,060 --> 00:10:23,640
together

00:10:21,690 --> 00:10:26,250
and why is design decisions made its

00:10:23,640 --> 00:10:27,930
really eight wonderful papers about an

00:10:26,250 --> 00:10:31,050
hour-long read and it will make you

00:10:27,930 --> 00:10:32,580
smarter and one time BitTorrent

00:10:31,050 --> 00:10:34,760
accounted for fifty percent of the

00:10:32,580 --> 00:10:37,410
traffic on the Internet

00:10:34,760 --> 00:10:41,010
written in pure Python twisted is a

00:10:37,410 --> 00:10:44,100
major success story YouTube was a pure

00:10:41,010 --> 00:10:44,910
Python shop even now they are 99 percent

00:10:44,100 --> 00:10:47,490
pure Python

00:10:44,910 --> 00:10:50,070
I was talking to Friedrich lon he's one

00:10:47,490 --> 00:10:53,040
of the chief architects at YouTube in a

00:10:50,070 --> 00:10:55,520
Python core contributor and he said if

00:10:53,040 --> 00:10:57,660
Google were to fall over dead tomorrow

00:10:55,520 --> 00:11:02,220
the largest search engine in the world

00:10:57,660 --> 00:11:05,280
would be YouTube they upload 15 hours of

00:11:02,220 --> 00:11:07,380
video every second it's a really

00:11:05,280 --> 00:11:11,370
fantastic all written in pure Python

00:11:07,380 --> 00:11:14,370
blender has incorporated Python as its

00:11:11,370 --> 00:11:16,020
embedded scripting language I have to

00:11:14,370 --> 00:11:18,270
remind people didn't get so used to

00:11:16,020 --> 00:11:20,160
using just starting up a Python

00:11:18,270 --> 00:11:21,570
interpreter and typing away and making a

00:11:20,160 --> 00:11:22,770
Python programs they actually forget

00:11:21,570 --> 00:11:25,380
that you can do things the other way

00:11:22,770 --> 00:11:28,590
around you can take some giant C

00:11:25,380 --> 00:11:29,160
application then embed Python inside and

00:11:28,590 --> 00:11:30,660
presto

00:11:29,160 --> 00:11:33,810
that language has a scripting language

00:11:30,660 --> 00:11:35,790
embedded inside it so let's say you had

00:11:33,810 --> 00:11:37,530
a big product you know giant spreadsheet

00:11:35,790 --> 00:11:41,160
you've distributed all over the world

00:11:37,530 --> 00:11:44,130
you got a custom file format called XLS

00:11:41,160 --> 00:11:45,900
or XLS W or something like that and you

00:11:44,130 --> 00:11:47,880
need a scripting language for it you

00:11:45,900 --> 00:11:50,130
could adopt Visual Basic or you could

00:11:47,880 --> 00:11:51,240
embed Python inside and presto Python

00:11:50,130 --> 00:11:53,790
would be the scripting language for

00:11:51,240 --> 00:11:57,120
Excel they could put that in overnight

00:11:53,790 --> 00:11:59,790
it's I think it's a fantastic thing and

00:11:57,120 --> 00:12:02,790
then when 32a a lot of you in here are

00:11:59,790 --> 00:12:04,410
Linux users and Mac users and so we tend

00:12:02,790 --> 00:12:07,170
to forget that 90% of the computers in

00:12:04,410 --> 00:12:09,480
the world are running Windows thanks to

00:12:07,170 --> 00:12:13,920
the efforts of Mark Hammond and the

00:12:09,480 --> 00:12:15,600
win32 dot-com almost every services

00:12:13,920 --> 00:12:17,610
available on Windows is accessible

00:12:15,600 --> 00:12:20,640
through Python and that's a wonderful

00:12:17,610 --> 00:12:23,190
thing and Microsoft does some things

00:12:20,640 --> 00:12:25,620
incredibly well like the comm interface

00:12:23,190 --> 00:12:27,960
is just magical because of comm

00:12:25,620 --> 00:12:30,240
interface one of my very first Python

00:12:27,960 --> 00:12:33,220
programs was that it took me only a few

00:12:30,240 --> 00:12:35,949
minutes to write was I'd link to the

00:12:33,220 --> 00:12:37,839
model for Excel I could ask access it as

00:12:35,949 --> 00:12:40,269
if it were native to Python I didn't

00:12:37,839 --> 00:12:42,639
have to do any dl links and so I grabbed

00:12:40,269 --> 00:12:44,560
some stock symbols off of a spreadsheet

00:12:42,639 --> 00:12:46,029
went out to Yahoo looked up their prices

00:12:44,560 --> 00:12:48,610
and then we populated it back into the

00:12:46,029 --> 00:12:51,040
spreadsheet and computed my enormous

00:12:48,610 --> 00:12:52,509
wealth for the day and from excels point

00:12:51,040 --> 00:12:54,250
of view all I had to do is press the

00:12:52,509 --> 00:12:55,839
button that launched the macro I think

00:12:54,250 --> 00:12:57,939
that's fantastic how did those things

00:12:55,839 --> 00:12:59,680
get linked together did I have to use C

00:12:57,939 --> 00:13:02,649
types or anything no the comm interface

00:12:59,680 --> 00:13:04,449
was fast and clean and pretty much every

00:13:02,649 --> 00:13:06,730
tool that's available in Windows has

00:13:04,449 --> 00:13:08,649
some sort of form of calm access so that

00:13:06,730 --> 00:13:11,139
you can drive it from Excel I think

00:13:08,649 --> 00:13:15,040
that's that's wonderful and then we've

00:13:11,139 --> 00:13:16,800
got folks why are books important most

00:13:15,040 --> 00:13:20,350
of you who's part of Python book before

00:13:16,800 --> 00:13:21,519
ok I think it was essential to your if

00:13:20,350 --> 00:13:24,250
you're learning to have some books

00:13:21,519 --> 00:13:28,300
available a language I really like is Oh

00:13:24,250 --> 00:13:30,100
camel o camel has no books and has made

00:13:28,300 --> 00:13:32,500
it frightening ly difficult to learn

00:13:30,100 --> 00:13:35,199
well and to get different perspectives

00:13:32,500 --> 00:13:36,730
on I've had a couple times but I've got

00:13:35,199 --> 00:13:39,490
the technical documents I could read to

00:13:36,730 --> 00:13:41,139
learn more about o camel but really your

00:13:39,490 --> 00:13:43,990
your lift twisting in the wind I think

00:13:41,139 --> 00:13:46,959
having good books is essential context

00:13:43,990 --> 00:13:49,689
for language so the summary of a context

00:13:46,959 --> 00:13:51,250
is I think in order to get a language up

00:13:49,689 --> 00:13:53,350
and running and make it awesome it has

00:13:51,250 --> 00:13:55,959
to have an open-source license it needs

00:13:53,350 --> 00:13:58,449
commercial backing it needs in or some

00:13:55,959 --> 00:14:00,220
unifying philosophy if it has a

00:13:58,449 --> 00:14:03,399
wonderful inviting community like you

00:14:00,220 --> 00:14:06,399
guys here that will contribute to access

00:14:03,399 --> 00:14:08,559
we need a way of exchanging a work an

00:14:06,399 --> 00:14:11,199
enormous body of our free resources

00:14:08,559 --> 00:14:13,779
available we need a few killer apps and

00:14:11,199 --> 00:14:15,699
success stories we need to access the

00:14:13,779 --> 00:14:17,559
90% of the computers in the world that

00:14:15,699 --> 00:14:20,379
run Windows and we need a few books

00:14:17,559 --> 00:14:22,870
those are the contexts for success that

00:14:20,379 --> 00:14:24,399
makes it possible for Python to be

00:14:22,870 --> 00:14:28,360
awesome if you've done all of those

00:14:24,399 --> 00:14:31,600
things your new language X is on track

00:14:28,360 --> 00:14:34,120
now you've got a new language X you've

00:14:31,600 --> 00:14:36,160
got all these features now you need to

00:14:34,120 --> 00:14:37,750
decide what is what characteristics are

00:14:36,160 --> 00:14:39,339
you going to adopt in your language it's

00:14:37,750 --> 00:14:39,470
a going to be low levels they're going

00:14:39,339 --> 00:14:41,930
to

00:14:39,470 --> 00:14:43,850
high level how is it going to allocate

00:14:41,930 --> 00:14:45,440
memory and that sort of thing let's look

00:14:43,850 --> 00:14:47,840
and see what choices this Python

00:14:45,440 --> 00:14:52,130
language may what qualities of the

00:14:47,840 --> 00:14:54,320
language itself make it awesome I think

00:14:52,130 --> 00:14:57,110
one of its most endearing and wonderful

00:14:54,320 --> 00:14:58,490
qualities is his ease of learning those

00:14:57,110 --> 00:15:01,010
of you who attended Peters class

00:14:58,490 --> 00:15:03,230
yesterday I just had a wonderful

00:15:01,010 --> 00:15:05,420
learning experience his wonderful

00:15:03,230 --> 00:15:07,190
teaching styles delightful to listen to

00:15:05,420 --> 00:15:10,100
but think of how much he learned in

00:15:07,190 --> 00:15:13,520
three hours in three hours a person can

00:15:10,100 --> 00:15:16,760
learn all the internal types list sex

00:15:13,520 --> 00:15:18,290
said six tuples floats stir and yet you

00:15:16,760 --> 00:15:20,630
can learn the control flow structures

00:15:18,290 --> 00:15:22,310
while loops for loops try except if then

00:15:20,630 --> 00:15:26,440
else and then you can learn the basic

00:15:22,310 --> 00:15:28,700
organization tools for aggregating those

00:15:26,440 --> 00:15:30,410
statements of functions classes and

00:15:28,700 --> 00:15:34,100
modules that's possible to learn in

00:15:30,410 --> 00:15:35,570
three hours in a day I can go forward in

00:15:34,100 --> 00:15:36,980
one of my classes I'll make sure that

00:15:35,570 --> 00:15:39,410
you know by the end of the day some

00:15:36,980 --> 00:15:41,720
common Python idioms the methods on the

00:15:39,410 --> 00:15:43,490
most common objects and give you a tour

00:15:41,720 --> 00:15:45,490
of the library and show off the special

00:15:43,490 --> 00:15:48,620
methods that can be taught in one day

00:15:45,490 --> 00:15:51,410
that's fantastic so a problem that we

00:15:48,620 --> 00:15:53,030
don't have now that existed about a

00:15:51,410 --> 00:15:55,670
decade and it goes I've talked to

00:15:53,030 --> 00:15:58,880
companies we're concerned about adopting

00:15:55,670 --> 00:16:00,290
Python as our is our language internally

00:15:58,880 --> 00:16:01,700
because we don't know where we go to get

00:16:00,290 --> 00:16:04,700
a Python programmers they would look

00:16:01,700 --> 00:16:07,070
through job listings and very few people

00:16:04,700 --> 00:16:08,540
listed Python is one of their background

00:16:07,070 --> 00:16:10,400
skill sets they said we don't think

00:16:08,540 --> 00:16:12,590
we'll be able to program get Python

00:16:10,400 --> 00:16:14,480
programmers and I had to change the

00:16:12,590 --> 00:16:17,630
mindset a little bit I said if you need

00:16:14,480 --> 00:16:20,120
good C++ programmers how long does it

00:16:17,630 --> 00:16:22,400
take to grow one from scratch well they

00:16:20,120 --> 00:16:24,380
can take a course then read a couple

00:16:22,400 --> 00:16:26,450
books on it and then start practicing it

00:16:24,380 --> 00:16:30,530
and after two years you can have a

00:16:26,450 --> 00:16:32,240
pretty good C++ programmer or you could

00:16:30,530 --> 00:16:35,420
adopt Java and they could read a book

00:16:32,240 --> 00:16:37,580
take a couple seminars start practicing

00:16:35,420 --> 00:16:40,220
it and after six months you can have a

00:16:37,580 --> 00:16:41,660
pretty decent Java programmer but if you

00:16:40,220 --> 00:16:44,960
give me someone who already knows how to

00:16:41,660 --> 00:16:46,700
program in any language in a week I will

00:16:44,960 --> 00:16:49,010
give you a Python programmer I said

00:16:46,700 --> 00:16:50,900
you've already got them there should be

00:16:49,010 --> 00:16:52,580
no fear of adoption now lots of people

00:16:50,900 --> 00:16:54,800
now Lisp I thought on the resumes and

00:16:52,580 --> 00:16:56,660
companies are less concerned about can I

00:16:54,800 --> 00:16:58,400
find Python programmers but I still have

00:16:56,660 --> 00:17:00,620
to remind them of the selling point is

00:16:58,400 --> 00:17:02,330
if you've got programmers already who

00:17:00,620 --> 00:17:04,610
are smart and know your problem domain I

00:17:02,330 --> 00:17:07,430
can turn them into Python programmers in

00:17:04,610 --> 00:17:09,740
a week internment a really good Python

00:17:07,430 --> 00:17:11,480
programmers in two weeks I think that's

00:17:09,740 --> 00:17:14,030
fantastic that is hard to do with a

00:17:11,480 --> 00:17:15,380
number of other languages and I think

00:17:14,030 --> 00:17:18,500
it's one things makes Python awesome you

00:17:15,380 --> 00:17:20,980
guys like the part fantastic

00:17:18,500 --> 00:17:23,209
all right the rapid development cycle

00:17:20,980 --> 00:17:25,010
when I asked you before what makes

00:17:23,209 --> 00:17:27,890
Python awesome no one mentioned that

00:17:25,010 --> 00:17:29,540
this is fantastic scripting languages

00:17:27,890 --> 00:17:30,440
are unbeatable for their speed of

00:17:29,540 --> 00:17:32,570
development

00:17:30,440 --> 00:17:34,820
my first scripting language was awk I

00:17:32,570 --> 00:17:36,980
love to see at the time I programmed

00:17:34,820 --> 00:17:39,170
lots of see I was I believed in the book

00:17:36,980 --> 00:17:40,370
called born to code and see I thought C

00:17:39,170 --> 00:17:41,810
was the most wonderful thing under the

00:17:40,370 --> 00:17:43,460
Sun because I could do anything with it

00:17:41,810 --> 00:17:46,790
it was structured portable assembly

00:17:43,460 --> 00:17:48,500
language and then I encountered awk and

00:17:46,790 --> 00:17:50,060
my productivity went up by a factor of

00:17:48,500 --> 00:17:51,590
10 I've done weird things with awk I

00:17:50,060 --> 00:17:56,810
wrote a flight simulator and awk for

00:17:51,590 --> 00:17:58,010
example and I've heard this interesting

00:17:56,810 --> 00:18:00,110
there's I have forgotten the phrase for

00:17:58,010 --> 00:18:01,910
it had to do with the distance between

00:18:00,110 --> 00:18:04,310
the thinking of the thought and the

00:18:01,910 --> 00:18:05,150
formation of the code and with all that

00:18:04,310 --> 00:18:07,940
distance

00:18:05,150 --> 00:18:09,560
closed quite a bit as fast as I could

00:18:07,940 --> 00:18:11,270
think thoughts my flight simulator

00:18:09,560 --> 00:18:14,420
should be able to compute these terms

00:18:11,270 --> 00:18:16,370
have taken to account the weight of the

00:18:14,420 --> 00:18:17,720
aircraft though win as fast as I could

00:18:16,370 --> 00:18:19,220
think those thoughts would drip out of

00:18:17,720 --> 00:18:22,760
my fingers onto the page and I would

00:18:19,220 --> 00:18:26,060
have working code I loved on the problem

00:18:22,760 --> 00:18:27,620
was Ock didn't have libraries it didn't

00:18:26,060 --> 00:18:29,360
have internet access was an

00:18:27,620 --> 00:18:30,950
object-oriented and it didn't have

00:18:29,360 --> 00:18:31,970
concurrency things that I needed so I

00:18:30,950 --> 00:18:34,130
started looking for another language

00:18:31,970 --> 00:18:37,220
Python provided that and yet it also

00:18:34,130 --> 00:18:39,530
provided the ability to type fast and

00:18:37,220 --> 00:18:42,050
get code up and running quickly and the

00:18:39,530 --> 00:18:44,980
speed of development is hard for me to

00:18:42,050 --> 00:18:47,480
go to convince people and big companies

00:18:44,980 --> 00:18:49,400
I'll go in and tell them I give them

00:18:47,480 --> 00:18:51,170
some sample problems and say here are

00:18:49,400 --> 00:18:55,550
some tasks how long would it take your

00:18:51,170 --> 00:18:58,179
team to in Java are C++ write this code

00:18:55,550 --> 00:19:00,340
and get it tested and

00:18:58,179 --> 00:19:02,320
I can present on the chancellor well

00:19:00,340 --> 00:19:04,929
this will take a week or this will take

00:19:02,320 --> 00:19:06,249
a day and a half and I'll sit down bang

00:19:04,929 --> 00:19:09,309
out the code for them about 10 minutes

00:19:06,249 --> 00:19:10,990
15 minutes the order of magnitude

00:19:09,309 --> 00:19:12,909
difference in productivity is just

00:19:10,990 --> 00:19:15,460
enormous how quickly you can get good

00:19:12,909 --> 00:19:18,340
code up and running the interactive

00:19:15,460 --> 00:19:21,340
testing as a let people work with their

00:19:18,340 --> 00:19:22,899
tools up the organic growing style means

00:19:21,340 --> 00:19:24,580
that right at the beginning you get

00:19:22,899 --> 00:19:26,679
something up and running and then you

00:19:24,580 --> 00:19:28,600
continue I add to it so that at any

00:19:26,679 --> 00:19:30,100
given time someone can walk in and see

00:19:28,600 --> 00:19:31,749
your running program and say here's what

00:19:30,100 --> 00:19:33,639
it currently does so far and if you're

00:19:31,749 --> 00:19:36,820
practicing chess driven development you

00:19:33,639 --> 00:19:38,769
can say I've implemented these features

00:19:36,820 --> 00:19:40,269
these teacher features are fully tested

00:19:38,769 --> 00:19:41,649
and if you're using docstrings and run

00:19:40,269 --> 00:19:43,809
it through PI doc I already documented

00:19:41,649 --> 00:19:45,340
everything I've done as I was growing at

00:19:43,809 --> 00:19:46,809
real time and if you use tools like

00:19:45,340 --> 00:19:48,009
Sphinx you can combine all those

00:19:46,809 --> 00:19:51,220
together make nice beautiful

00:19:48,009 --> 00:19:52,090
documentation as fast as you develop I

00:19:51,220 --> 00:19:57,309
think that's wonderful

00:19:52,090 --> 00:19:58,960
who thinks that rocks and then for

00:19:57,309 --> 00:20:01,690
people coming from compiled languages is

00:19:58,960 --> 00:20:02,669
hard for them to realize how much more

00:20:01,690 --> 00:20:06,789
productive they get with that

00:20:02,669 --> 00:20:09,220
interactive prompt okay so this is a

00:20:06,789 --> 00:20:10,960
favorite example for me and it was I

00:20:09,220 --> 00:20:12,730
came out of I taught one of David

00:20:10,960 --> 00:20:16,419
Beasley's courses at one point and he

00:20:12,730 --> 00:20:18,249
had this practicum exercise oh they I

00:20:16,419 --> 00:20:19,960
thought was wonderful and I no longer

00:20:18,249 --> 00:20:24,039
let students solve it I solve them for

00:20:19,960 --> 00:20:27,429
it I solve it for them and what I like

00:20:24,039 --> 00:20:29,740
about this is there is a problem

00:20:27,429 --> 00:20:33,490
description that reads something like

00:20:29,740 --> 00:20:36,549
this we need to make some counts of URLs

00:20:33,490 --> 00:20:38,139
of I'm gonna have some log files that

00:20:36,549 --> 00:20:40,360
are spit out by Apache so I have a

00:20:38,139 --> 00:20:42,700
month's worth of log files I keep those

00:20:40,360 --> 00:20:45,909
in a data logs directory and they're all

00:20:42,700 --> 00:20:48,129
gzipped up and I need you to go into

00:20:45,909 --> 00:20:50,710
these Apache log files pull them all up

00:20:48,129 --> 00:20:53,919
and they will list out all the resource

00:20:50,710 --> 00:20:55,899
requests get this resource will get

00:20:53,919 --> 00:20:58,090
another resource and as Apache serves

00:20:55,899 --> 00:21:00,369
them up I need you to scan those files

00:20:58,090 --> 00:21:02,230
find all the get requests find the you

00:21:00,369 --> 00:21:04,690
are the resource that was requested and

00:21:02,230 --> 00:21:07,090
count them all up and then determine

00:21:04,690 --> 00:21:11,049
what are the 20 most common resource

00:21:07,090 --> 00:21:11,559
requests it took me almost three minutes

00:21:11,049 --> 00:21:14,950
to say the

00:21:11,559 --> 00:21:16,629
problem description it didn't take much

00:21:14,950 --> 00:21:18,490
longer to write the code for it and what

00:21:16,629 --> 00:21:21,159
I particularly like is not only how

00:21:18,490 --> 00:21:23,350
short this program is but also how it

00:21:21,159 --> 00:21:25,029
corresponds directly to the business

00:21:23,350 --> 00:21:26,740
logic so that I can explain to somebody

00:21:25,029 --> 00:21:29,740
who is not a Python program of what it

00:21:26,740 --> 00:21:31,659
does until this first line opens a

00:21:29,740 --> 00:21:34,120
counter it's a thing for counting it

00:21:31,659 --> 00:21:36,610
corresponds to the problem description

00:21:34,120 --> 00:21:41,289
of where we say get ready to count

00:21:36,610 --> 00:21:43,090
something see let's loop over all the

00:21:41,289 --> 00:21:46,059
files in the data logs directory the end

00:21:43,090 --> 00:21:47,559
with GZ it took me more words to say

00:21:46,059 --> 00:21:49,899
that in English than it took to say it

00:21:47,559 --> 00:21:51,519
precisely in Python let's liberal all

00:21:49,899 --> 00:21:53,440
the file names in the data logs

00:21:51,519 --> 00:21:56,619
directory that in with cheesy that's

00:21:53,440 --> 00:21:59,710
fantastic next line says for wine and

00:21:56,619 --> 00:22:01,360
gzip open file name ok for line and file

00:21:59,710 --> 00:22:02,740
name that's not in the impressive well

00:22:01,360 --> 00:22:04,539
that takes me a few more lines to do

00:22:02,740 --> 00:22:06,909
that and see and that takes care is

00:22:04,539 --> 00:22:09,159
automatic the universal new line

00:22:06,909 --> 00:22:11,769
handling the whole nine yards oh look at

00:22:09,159 --> 00:22:13,629
this that gzip dot Oakland that's

00:22:11,769 --> 00:22:15,730
wonderful that meant that I didn't have

00:22:13,629 --> 00:22:18,279
to go unzip the files before I read them

00:22:15,730 --> 00:22:20,379
we can read them directly gzip not open

00:22:18,279 --> 00:22:22,690
makes it transparent for us that they

00:22:20,379 --> 00:22:23,499
was actually gzipped I think that's

00:22:22,690 --> 00:22:26,230
fantastic

00:22:23,499 --> 00:22:27,610
so it takes many fewer words to say in

00:22:26,230 --> 00:22:29,499
Python than in English because in

00:22:27,610 --> 00:22:32,019
English we would say all right for each

00:22:29,499 --> 00:22:34,570
of those files go in and unzip them now

00:22:32,019 --> 00:22:36,369
loop over them line by line after having

00:22:34,570 --> 00:22:38,230
parse the line endings take those lines

00:22:36,369 --> 00:22:40,600
and ends and then for each one iterate

00:22:38,230 --> 00:22:42,580
over them many words to say it in

00:22:40,600 --> 00:22:45,669
English much clearer than Python next

00:22:42,580 --> 00:22:49,119
line says search search that line for

00:22:45,669 --> 00:22:51,100
the word get an HTTP and take the

00:22:49,119 --> 00:22:52,929
characters in between those two and

00:22:51,100 --> 00:22:55,080
group them the parentheses being the

00:22:52,929 --> 00:22:58,749
grouping symbol for a regular expression

00:22:55,080 --> 00:23:01,419
if I've got a match let's call that

00:22:58,749 --> 00:23:03,159
group the URL so the URLs the thing

00:23:01,419 --> 00:23:05,499
after the word get and before the word

00:23:03,159 --> 00:23:10,269
HTTP on the lines and the Apache log

00:23:05,499 --> 00:23:12,549
files now that if that URL counted the

00:23:10,269 --> 00:23:15,249
counts plus equal one I can show this

00:23:12,549 --> 00:23:16,749
logic to someone who is not a programmer

00:23:15,249 --> 00:23:19,210
and they can be pretty confident that it

00:23:16,749 --> 00:23:20,830
matches the problem description nothing

00:23:19,210 --> 00:23:24,880
saying you see I keep few of you

00:23:20,830 --> 00:23:26,890
and give me the 20 largest accounts now

00:23:24,880 --> 00:23:28,330
call a preppy print and printed out in a

00:23:26,890 --> 00:23:33,460
beautiful fashion so that we have a nice

00:23:28,330 --> 00:23:35,740
table that says the Adam dot XML of feed

00:23:33,460 --> 00:23:38,200
was the most popular hit followed by

00:23:35,740 --> 00:23:42,429
fave I've con followed by David Beasley

00:23:38,200 --> 00:23:45,269
ZUP fly package I think that's fantastic

00:23:42,429 --> 00:23:50,230
this is not an atypical task for a

00:23:45,269 --> 00:23:53,230
sysadmin ibang is code like this out

00:23:50,230 --> 00:23:54,820
fresh in a glass I have a whole little

00:23:53,230 --> 00:23:56,169
set of problems where I will just bring

00:23:54,820 --> 00:23:57,519
up something it's like pitches a problem

00:23:56,169 --> 00:24:00,309
and I'll just there and code it from

00:23:57,519 --> 00:24:02,500
scratch and it takes me five minutes to

00:24:00,309 --> 00:24:05,049
knock out code like this and as I'm

00:24:02,500 --> 00:24:07,600
going when I type in lay in these lines

00:24:05,049 --> 00:24:09,490
is this for filename in as soon as I've

00:24:07,600 --> 00:24:11,889
written this line I put here a print

00:24:09,490 --> 00:24:13,630
filename and I run it so I know those

00:24:11,889 --> 00:24:15,370
first two lines run okay it successfully

00:24:13,630 --> 00:24:17,320
found the files then when I add this

00:24:15,370 --> 00:24:19,450
line in I print the first line and break

00:24:17,320 --> 00:24:21,549
now I'm successfully finding the first

00:24:19,450 --> 00:24:23,529
line and I showed them as I develop this

00:24:21,549 --> 00:24:25,240
code I'm actually testing each line as I

00:24:23,529 --> 00:24:27,130
run it so that by the time I get to the

00:24:25,240 --> 00:24:29,799
end I'm confident it does exactly what I

00:24:27,130 --> 00:24:32,440
expect and that's fantastic because the

00:24:29,799 --> 00:24:33,970
Java or C++ program or someone who works

00:24:32,440 --> 00:24:36,970
in a compiled language actually build

00:24:33,970 --> 00:24:38,860
the whole thing first then when it in

00:24:36,970 --> 00:24:40,960
then when it didn't work have to go into

00:24:38,860 --> 00:24:42,330
a painful debugging phase who thinks

00:24:40,960 --> 00:24:45,730
that's fantastic

00:24:42,330 --> 00:24:48,279
it's got economy of expression is short

00:24:45,730 --> 00:24:51,250
it was easy to develop I could test as

00:24:48,279 --> 00:24:54,190
we go and I can explain it to a non

00:24:51,250 --> 00:24:55,450
programmer I think that makes the Python

00:24:54,190 --> 00:24:56,649
a fantastic language here's another

00:24:55,450 --> 00:24:59,710
example it's just a little five-minute

00:24:56,649 --> 00:25:02,620
script and this was not a problem that I

00:24:59,710 --> 00:25:04,889
created someone in class I mean looking

00:25:02,620 --> 00:25:07,899
on simple I have an issue I have an

00:25:04,889 --> 00:25:11,500
enormous harddrive several terabytes of

00:25:07,899 --> 00:25:13,630
images as a photographers then many has

00:25:11,500 --> 00:25:16,179
many directory levels and his copied

00:25:13,630 --> 00:25:18,940
files around to and fro and rename them

00:25:16,179 --> 00:25:20,500
as he spends some image editing my nice

00:25:18,940 --> 00:25:22,929
is I've got some duplicates and I'd like

00:25:20,500 --> 00:25:25,120
to find the duplicates he said how would

00:25:22,929 --> 00:25:27,279
tithe on solve that very simply we

00:25:25,120 --> 00:25:30,039
should make a mapping of some signature

00:25:27,279 --> 00:25:32,799
of the content of to all file names that

00:25:30,039 --> 00:25:36,340
match that you know the signature being

00:25:32,799 --> 00:25:37,600
let's describe the image in some way

00:25:36,340 --> 00:25:39,880
that it's unique so that if you have

00:25:37,600 --> 00:25:43,870
renamed the image I can still tell us

00:25:39,880 --> 00:25:47,320
the same image so OS walk lets us loop

00:25:43,870 --> 00:25:49,000
down the directory tree and for the UNIX

00:25:47,320 --> 00:25:52,120
types that's equivalent of the UNIX find

00:25:49,000 --> 00:25:54,880
built-in so I looked in all the

00:25:52,120 --> 00:25:57,880
directories I lived over each filename

00:25:54,880 --> 00:25:59,799
in that directory compute the full file

00:25:57,880 --> 00:26:01,809
name so I have the path to get there why

00:25:59,799 --> 00:26:03,610
do I do that because sometimes you have

00:26:01,809 --> 00:26:05,679
the same file name under two or three

00:26:03,610 --> 00:26:08,409
different directories and so this is

00:26:05,679 --> 00:26:09,549
more a requirement for the users of the

00:26:08,409 --> 00:26:11,590
output they'd like to know

00:26:09,549 --> 00:26:13,480
yes I found duplicates well where were

00:26:11,590 --> 00:26:15,850
they well I should have remembered that

00:26:13,480 --> 00:26:18,370
so we give them the full path I open the

00:26:15,850 --> 00:26:21,659
file read it run it computer a hex

00:26:18,370 --> 00:26:26,799
digest on it and then build myself a

00:26:21,659 --> 00:26:28,809
mapping so that the signature maps to a

00:26:26,799 --> 00:26:31,270
list of file names I just append each

00:26:28,809 --> 00:26:32,919
match and then pretty credit and I'm

00:26:31,270 --> 00:26:34,299
done that was a five minute exercise

00:26:32,919 --> 00:26:38,559
bang bang bang bang was rendered over

00:26:34,299 --> 00:26:40,750
your directory tree and how long does it

00:26:38,559 --> 00:26:41,679
take to run really depends on the size

00:26:40,750 --> 00:26:44,409
of your hard drive

00:26:41,679 --> 00:26:45,730
you got several terabytes it's not the

00:26:44,409 --> 00:26:49,090
Python program that's throwing you up

00:26:45,730 --> 00:26:50,980
it's the the speed limitation here would

00:26:49,090 --> 00:26:53,049
still be the same as this code where had

00:26:50,980 --> 00:26:55,059
been written in C the all of the time

00:26:53,049 --> 00:26:57,610
spent reading a file running a hex

00:26:55,059 --> 00:26:58,090
digest on it then we've heard Python is

00:26:57,610 --> 00:27:01,720
slow

00:26:58,090 --> 00:27:03,460
what is it doing here open of fouling

00:27:01,720 --> 00:27:06,279
and read how do those operations

00:27:03,460 --> 00:27:08,830
actually occur the Credo spend a lot of

00:27:06,279 --> 00:27:11,679
time writing the read built-in no the

00:27:08,830 --> 00:27:13,450
operating system does it for us so we're

00:27:11,679 --> 00:27:15,390
all Python is doing essentially it's

00:27:13,450 --> 00:27:17,120
passing off to

00:27:15,390 --> 00:27:19,950
the operating system the read operation

00:27:17,120 --> 00:27:21,300
meaning that is running at sea speed it

00:27:19,950 --> 00:27:23,220
is not running at Python speed that's

00:27:21,300 --> 00:27:24,660
one line that says read a file which

00:27:23,220 --> 00:27:26,850
hands up to the operating system that

00:27:24,660 --> 00:27:29,730
knows how to read a file I think that's

00:27:26,850 --> 00:27:32,790
fantastic we then take the file we've

00:27:29,730 --> 00:27:35,370
read in and pass it to hex digest hex

00:27:32,790 --> 00:27:37,920
digest is written in C this runs at C

00:27:35,370 --> 00:27:41,340
speed this code would go no faster if

00:27:37,920 --> 00:27:43,640
you wrote this code in C and then with

00:27:41,340 --> 00:27:46,440
dictionaries the fastest thing in Python

00:27:43,640 --> 00:27:49,080
Jim Peters is fond of saying if you

00:27:46,440 --> 00:27:50,520
write some code in Python using

00:27:49,080 --> 00:27:52,950
dictionaries it is a gazillion times

00:27:50,520 --> 00:27:55,350
faster then code written in any other

00:27:52,950 --> 00:27:57,120
language what did he mean by that he

00:27:55,350 --> 00:27:59,130
meant if you're a seat programmer you

00:27:57,120 --> 00:28:00,450
know your computer's optimizing

00:27:59,130 --> 00:28:02,670
everything for you so you tend to do a

00:28:00,450 --> 00:28:04,260
lot of linear searches because it's no

00:28:02,670 --> 00:28:08,160
fun to have to build your own hash map

00:28:04,260 --> 00:28:10,470
out of nothing and so C programmers tend

00:28:08,160 --> 00:28:11,910
to do a lot of linear searches because

00:28:10,470 --> 00:28:13,800
it's a pain they don't have dictionaries

00:28:11,910 --> 00:28:15,990
in their hip pocket well we have an

00:28:13,800 --> 00:28:19,350
optimized data structure a heavily

00:28:15,990 --> 00:28:21,300
optimized data structure and I would

00:28:19,350 --> 00:28:22,920
contend that there are very few of C

00:28:21,300 --> 00:28:25,380
programmers who could go toe-to-toe with

00:28:22,920 --> 00:28:27,570
Tim Peters his Tim sort algorithm is

00:28:25,380 --> 00:28:29,790
close to unbeatable has its own

00:28:27,570 --> 00:28:31,350
Wikipedia page now it's been adopted by

00:28:29,790 --> 00:28:33,240
a number of other languages they are

00:28:31,350 --> 00:28:34,650
modeling their implementations after

00:28:33,240 --> 00:28:36,530
Python because ours is the most

00:28:34,650 --> 00:28:39,210
efficient it thinks that's fantastic

00:28:36,530 --> 00:28:41,460
this code is fast it took me minutes to

00:28:39,210 --> 00:28:43,380
develop it was Laura reliable and the

00:28:41,460 --> 00:28:49,250
only limitation on the speed was really

00:28:43,380 --> 00:28:51,870
as an i/o bound process beauty counts

00:28:49,250 --> 00:28:53,190
readability is the number one most

00:28:51,870 --> 00:28:56,430
mentioned characteristic when I go out

00:28:53,190 --> 00:28:59,340
and say why do you like Python why does

00:28:56,430 --> 00:29:01,500
that matter well one reason it matters

00:28:59,340 --> 00:29:03,180
is it affects your relationship with the

00:29:01,500 --> 00:29:04,890
computers you type all day long I

00:29:03,180 --> 00:29:07,340
enjoyed APL

00:29:04,890 --> 00:29:09,660
I thought APL was an amazing language I

00:29:07,340 --> 00:29:11,850
still think it's an amazing language and

00:29:09,660 --> 00:29:14,610
it inspired many other tools that

00:29:11,850 --> 00:29:17,940
followed or modeled off of APL you still

00:29:14,610 --> 00:29:21,120
see like remnants of it in the itertools

00:29:17,940 --> 00:29:26,460
module in languages like Mathematica and

00:29:21,120 --> 00:29:28,070
maple but it wasn't beautiful and so it

00:29:26,460 --> 00:29:30,120
wasn't joyous the program

00:29:28,070 --> 00:29:31,770
Python is one of those languages where

00:29:30,120 --> 00:29:33,750
I'm talking to somebody to corporation

00:29:31,770 --> 00:29:35,430
see do your programmers go home from

00:29:33,750 --> 00:29:37,590
work and turn on the computer to write

00:29:35,430 --> 00:29:38,850
more programs I'll bet they don't and

00:29:37,590 --> 00:29:40,830
the reason is because their language

00:29:38,850 --> 00:29:41,910
isn't beautiful python is so beautiful

00:29:40,830 --> 00:29:43,050
occasionally when I think of a new

00:29:41,910 --> 00:29:44,610
algorithm or something I wanna play with

00:29:43,050 --> 00:29:46,170
I just fire up an interpreter and write

00:29:44,610 --> 00:29:47,850
some programs are you being paid for

00:29:46,170 --> 00:29:48,620
this no don't for the joy of it it's

00:29:47,850 --> 00:29:52,290
beautiful

00:29:48,620 --> 00:29:55,080
beauty counts another reason it counts

00:29:52,290 --> 00:29:57,210
is when most of our time programming is

00:29:55,080 --> 00:29:58,710
spent not in green field programming but

00:29:57,210 --> 00:30:00,300
in maintaining other people's programs

00:29:58,710 --> 00:30:03,570
and it's really nice to look at a

00:30:00,300 --> 00:30:06,570
beautiful program to be able to to go do

00:30:03,570 --> 00:30:08,670
updates to it one thing I really don't

00:30:06,570 --> 00:30:10,620
enjoy doing is taking other people

00:30:08,670 --> 00:30:12,240
seeker and going in to maintain it but

00:30:10,620 --> 00:30:14,850
other people's Python code I don't mind

00:30:12,240 --> 00:30:17,600
as much the one way to do it is the

00:30:14,850 --> 00:30:19,950
number one mentioned advantage over Perl

00:30:17,600 --> 00:30:21,750
it is just a different philosophy they

00:30:19,950 --> 00:30:23,610
have a different style that one that

00:30:21,750 --> 00:30:27,750
works for them having one way to do it

00:30:23,610 --> 00:30:30,420
why is that important the answer is well

00:30:27,750 --> 00:30:32,190
there are many different idioms you can

00:30:30,420 --> 00:30:33,570
use to solve a problem and all of them

00:30:32,190 --> 00:30:35,310
are good in their own way but if the

00:30:33,570 --> 00:30:37,530
person next to you is using a different

00:30:35,310 --> 00:30:39,360
set of idioms than you use you will find

00:30:37,530 --> 00:30:43,290
his code to be impenetrable and hard to

00:30:39,360 --> 00:30:45,120
maintain what's nice in Python is by

00:30:43,290 --> 00:30:47,550
having one way and preferably one way to

00:30:45,120 --> 00:30:49,470
the obvious way to do things you can go

00:30:47,550 --> 00:30:51,720
look at someone else's code and it tends

00:30:49,470 --> 00:30:53,070
to be readable to you that's fantastic

00:30:51,720 --> 00:30:54,870
for me because I go into company after

00:30:53,070 --> 00:30:56,640
company doing consulting I look at their

00:30:54,870 --> 00:30:58,500
codebase I just make suggestions on how

00:30:56,640 --> 00:31:00,690
to improve its architecture and how they

00:30:58,500 --> 00:31:03,270
can improve their coding styles and it

00:31:00,690 --> 00:31:04,770
what's nice is I get to see how many

00:31:03,270 --> 00:31:06,780
different companies have their code

00:31:04,770 --> 00:31:09,150
bases all these code bases of secret

00:31:06,780 --> 00:31:10,710
they have to sign in da's but what I can

00:31:09,150 --> 00:31:12,360
tell you I see is their code looks

00:31:10,710 --> 00:31:14,190
remarkably the same from company to

00:31:12,360 --> 00:31:16,110
company to company they have completely

00:31:14,190 --> 00:31:18,480
different problem domains but their code

00:31:16,110 --> 00:31:20,010
looks the same you can leave a genomics

00:31:18,480 --> 00:31:21,570
company and go to a high frequency

00:31:20,010 --> 00:31:23,700
trading company and still know how to

00:31:21,570 --> 00:31:24,990
program in that company you can't do

00:31:23,700 --> 00:31:27,030
that in some other languages where the

00:31:24,990 --> 00:31:30,030
styles are so different that's why one

00:31:27,030 --> 00:31:32,370
way to do it matters our interactive

00:31:30,030 --> 00:31:34,830
Paul one of the fantastic things about

00:31:32,370 --> 00:31:36,419
this occasionally I get a chance to hang

00:31:34,830 --> 00:31:38,369
out with our really high-level pipe

00:31:36,419 --> 00:31:41,309
product so I get to hang out with

00:31:38,369 --> 00:31:43,409
Richard and Nick Coghlan and Guido and

00:31:41,309 --> 00:31:46,679
when Tim used to come to the conferences

00:31:43,409 --> 00:31:49,580
we'd go into the Sprint's together now

00:31:46,679 --> 00:31:52,200
these guys are deep deep Python experts

00:31:49,580 --> 00:31:53,879
so if you might ask them a Python

00:31:52,200 --> 00:31:58,049
question would you expect them to know

00:31:53,879 --> 00:31:59,489
off the top of their head no Python

00:31:58,049 --> 00:32:01,200
programmers don't program that way

00:31:59,489 --> 00:32:03,809
I thought programmers don't memorize

00:32:01,200 --> 00:32:05,639
Python all of these guys if I manage

00:32:03,809 --> 00:32:07,139
discussion with Richard he and I would

00:32:05,639 --> 00:32:09,299
sit down and fire up an interpreter and

00:32:07,139 --> 00:32:11,340
we rediscovered the language as we go

00:32:09,299 --> 00:32:12,840
there and Richard would teach me

00:32:11,340 --> 00:32:15,149
something new like yesterday I learned

00:32:12,840 --> 00:32:17,369
that if you rename super in Python 3 it

00:32:15,149 --> 00:32:21,359
doesn't work anymore I didn't know that

00:32:17,369 --> 00:32:23,279
previously we rediscovered the language

00:32:21,359 --> 00:32:25,289
I think this is fantastic and a compiled

00:32:23,279 --> 00:32:27,330
language you can't do that you actually

00:32:25,289 --> 00:32:28,859
have to memorize a substantial chunk of

00:32:27,330 --> 00:32:31,409
the language just to even write hello

00:32:28,859 --> 00:32:34,409
world in C you have to know to do the

00:32:31,409 --> 00:32:37,470
include standard IOH and how to set up

00:32:34,409 --> 00:32:41,249
the main return void and whatnot and

00:32:37,470 --> 00:32:42,690
this format for the printf syntax

00:32:41,249 --> 00:32:44,690
formatting a lot of that has to be

00:32:42,690 --> 00:32:47,879
memorized you can type your code into

00:32:44,690 --> 00:32:49,230
notepad then you run the compiler and it

00:32:47,879 --> 00:32:49,919
tells you what you fail to memorize

00:32:49,230 --> 00:32:51,539
correctly

00:32:49,919 --> 00:32:54,179
the interactive prompt is much more

00:32:51,539 --> 00:32:57,029
productive and we have many interactive

00:32:54,179 --> 00:32:59,669
Trump's VP I thought and ipython are a

00:32:57,029 --> 00:33:02,489
different interactive prompt that

00:32:59,669 --> 00:33:03,809
accesses Python in a way that looks

00:33:02,489 --> 00:33:07,289
different but it's the same under the

00:33:03,809 --> 00:33:08,340
hood what's fantastic about ipython is

00:33:07,289 --> 00:33:10,139
there's a lot of scientists who don't

00:33:08,340 --> 00:33:12,179
like to who don't have a need to write

00:33:10,139 --> 00:33:14,159
programs they're right they're doing

00:33:12,179 --> 00:33:15,809
data analysis and so all of their

00:33:14,159 --> 00:33:17,879
interactions are interactive they fire

00:33:15,809 --> 00:33:20,129
up by pythons they load up this data set

00:33:17,879 --> 00:33:22,799
summarize this data set graph this data

00:33:20,129 --> 00:33:24,509
set filter out these elements now run

00:33:22,799 --> 00:33:26,399
this graph on it now we're in a fast

00:33:24,509 --> 00:33:29,190
Fourier transform on it now graph that

00:33:26,399 --> 00:33:30,809
easier it's an imperative style they're

00:33:29,190 --> 00:33:32,340
telling the data how

00:33:30,809 --> 00:33:34,200
it wants to look differently in what

00:33:32,340 --> 00:33:35,460
they want done with the data they don't

00:33:34,200 --> 00:33:36,929
actually care about the program they

00:33:35,460 --> 00:33:38,429
care about the the graphs that they

00:33:36,929 --> 00:33:41,820
generate in the data analysis they've

00:33:38,429 --> 00:33:45,600
done I think that's fantastic and python

00:33:41,820 --> 00:33:48,389
is a batteries included language which

00:33:45,600 --> 00:33:49,740
is really wonderful and one thing that

00:33:48,389 --> 00:33:51,990
shocks me when I go into corporate

00:33:49,740 --> 00:33:53,850
environments is unlike your own

00:33:51,990 --> 00:33:55,649
environments where I could say here go

00:33:53,850 --> 00:33:57,860
download this an amazing number of

00:33:55,649 --> 00:34:00,779
companies won't let people use USB keys

00:33:57,860 --> 00:34:02,879
might be a virus on it can't download

00:34:00,779 --> 00:34:04,230
software it's really important for them

00:34:02,879 --> 00:34:05,519
thing a batteries included otherwise

00:34:04,230 --> 00:34:07,819
they have to reboot and develop their

00:34:05,519 --> 00:34:10,919
batteries from scratch

00:34:07,819 --> 00:34:12,149
security will be the death of us okay

00:34:10,919 --> 00:34:15,329
and then behind the scenes we have a

00:34:12,149 --> 00:34:17,190
very conservative rate of growth our

00:34:15,329 --> 00:34:19,859
philosophy for core developers used to

00:34:17,190 --> 00:34:21,960
be we read news so that you don't have

00:34:19,859 --> 00:34:24,089
to there are people like me who actually

00:34:21,960 --> 00:34:25,649
like to open up news on the weekend and

00:34:24,089 --> 00:34:27,480
work my way through semi numerical

00:34:25,649 --> 00:34:29,520
algorithms and it's you know it's like

00:34:27,480 --> 00:34:31,980
reading mathematics and there's people

00:34:29,520 --> 00:34:33,869
like me who enjoy it and you get the

00:34:31,980 --> 00:34:36,240
benefit of it and that's why Dex runs so

00:34:33,869 --> 00:34:38,879
fast that's why sets run so fast you get

00:34:36,240 --> 00:34:42,139
the benefit without having to read news

00:34:38,879 --> 00:34:44,609
and so we do complex and sophisticated

00:34:42,139 --> 00:34:46,200
algorithms behind the scenes but we aim

00:34:44,609 --> 00:34:49,169
for a very simple easy to use

00:34:46,200 --> 00:34:50,819
implementation so that's have been

00:34:49,169 --> 00:34:51,990
highly optimized under the hood but the

00:34:50,819 --> 00:34:53,790
learning curve for them is less than

00:34:51,990 --> 00:34:58,650
five minutes I can teach you sets in

00:34:53,790 --> 00:35:00,450
five minutes or less and sig vaulting in

00:34:58,650 --> 00:35:02,880
Python is considered a critical bug we

00:35:00,450 --> 00:35:05,700
will be on top of it just like that if

00:35:02,880 --> 00:35:07,500
you find a way to segfault python

00:35:05,700 --> 00:35:10,050
without intentionally shooting yourself

00:35:07,500 --> 00:35:12,839
in the foot there are ways to if you set

00:35:10,050 --> 00:35:14,670
out to Sigma well if you aim the gun at

00:35:12,839 --> 00:35:16,230
your toe pull a hammer back and say I

00:35:14,670 --> 00:35:19,290
wish my toe to be blown off it is

00:35:16,230 --> 00:35:21,000
possible but we do have safeties on that

00:35:19,290 --> 00:35:21,630
doesn't happen accidentally pi that is

00:35:21,000 --> 00:35:24,660
not the norm

00:35:21,630 --> 00:35:25,589
and then lastly behind the scenes I

00:35:24,660 --> 00:35:28,260
think it's important that we have a

00:35:25,589 --> 00:35:30,420
benevolent dictator somebody to resolve

00:35:28,260 --> 00:35:33,359
design conflicts and whatnot so that in

00:35:30,420 --> 00:35:35,010
the end you were using this is quito's

00:35:33,359 --> 00:35:36,660
language and he just happens to let you

00:35:35,010 --> 00:35:39,960
be using it and that gives it a certain

00:35:36,660 --> 00:35:42,510
uniformity of design

00:35:39,960 --> 00:35:45,000
and one of our other winning

00:35:42,510 --> 00:35:46,740
characteristics is having agreed on some

00:35:45,000 --> 00:35:50,160
protocols so that when someone makes

00:35:46,740 --> 00:35:52,290
some wrappers around various databases

00:35:50,160 --> 00:35:54,930
someone says I wrapped my SQL another

00:35:52,290 --> 00:35:57,059
one says I wrap Postgres but they have

00:35:54,930 --> 00:35:59,359
wrapped it in the same way the answer is

00:35:57,059 --> 00:36:01,109
yes because we defined a db-api

00:35:59,359 --> 00:36:04,140
specification so that you can write a

00:36:01,109 --> 00:36:05,940
Python program that accesses those

00:36:04,140 --> 00:36:07,740
databases later change your mind about

00:36:05,940 --> 00:36:09,000
the database and I have to change any of

00:36:07,740 --> 00:36:10,800
your code you might have to change the

00:36:09,000 --> 00:36:13,589
sequence statements because they have

00:36:10,800 --> 00:36:15,510
different flavors of sequel but the

00:36:13,589 --> 00:36:18,119
Python part of it is the same same thing

00:36:15,510 --> 00:36:20,420
for a hash limit we have the same

00:36:18,119 --> 00:36:23,099
interface for sha-1 as we do for md5

00:36:20,420 --> 00:36:24,930
compression the compress and decompress

00:36:23,099 --> 00:36:29,720
words are the same regardless of whether

00:36:24,930 --> 00:36:32,670
you're using XC gzb zip to RZ live

00:36:29,720 --> 00:36:35,880
whiskey the one ring to bind them all at

00:36:32,670 --> 00:36:37,920
one time we had many many many many web

00:36:35,880 --> 00:36:39,540
servers why because they're pretty darn

00:36:37,920 --> 00:36:41,190
easy to write and at one time we had

00:36:39,540 --> 00:36:43,589
many many many many many many many many

00:36:41,190 --> 00:36:45,329
many web frameworks and they were easy

00:36:43,589 --> 00:36:48,000
to write and each they some of them been

00:36:45,329 --> 00:36:50,400
matched where this group ran on this

00:36:48,000 --> 00:36:52,559
group and this group ran together on

00:36:50,400 --> 00:36:54,690
this group and so the moment you chose

00:36:52,559 --> 00:36:57,210
one side you were very limited on your

00:36:54,690 --> 00:36:59,130
choices the other Philip IV put together

00:36:57,210 --> 00:37:00,809
a massive social effort wasn't just a

00:36:59,130 --> 00:37:03,210
technical effort it was a social effort

00:37:00,809 --> 00:37:05,700
to find what was in common between all

00:37:03,210 --> 00:37:07,500
of those things call the people who made

00:37:05,700 --> 00:37:10,650
them talk to them one at a time and say

00:37:07,500 --> 00:37:12,869
can you add on to don't chit continue to

00:37:10,650 --> 00:37:15,690
support your current users add on this

00:37:12,869 --> 00:37:17,730
extra interface that I call whiskey he

00:37:15,690 --> 00:37:19,680
laid out a spec and it's the one ring to

00:37:17,730 --> 00:37:21,510
bind them all and now you can choose any

00:37:19,680 --> 00:37:28,079
framework with any web server and vice

00:37:21,510 --> 00:37:30,780
versa that's fantastic and file API the

00:37:28,079 --> 00:37:34,079
API doesn't seem that magical open read

00:37:30,780 --> 00:37:36,480
write read line how magic is that oh

00:37:34,079 --> 00:37:39,660
well we can use that same API version

00:37:36,480 --> 00:37:41,849
for Strings and you get c string io R we

00:37:39,660 --> 00:37:44,160
can open a URL and the same words open

00:37:41,849 --> 00:37:45,839
these protocols unified the language and

00:37:44,160 --> 00:37:48,750
make it fairly easy to learn if you

00:37:45,839 --> 00:37:50,400
learn the dumps and loads protocol

00:37:48,750 --> 00:37:52,170
for pickle guess what you already know

00:37:50,400 --> 00:37:53,910
how to do chasing and already know how

00:37:52,170 --> 00:37:57,090
to do Marshall who thinks that's

00:37:53,910 --> 00:37:59,010
fantastic alright so I've described the

00:37:57,090 --> 00:38:01,290
characteristics of a successful language

00:37:59,010 --> 00:38:03,570
but I haven't given you any specifics of

00:38:01,290 --> 00:38:08,430
what makes Python different and I have

00:38:03,570 --> 00:38:10,740
in theory 10 minutes left yeah I just

00:38:08,430 --> 00:38:16,950
borrowed five he's like I knew it was

00:38:10,740 --> 00:38:18,630
five but I said ten and he folded all

00:38:16,950 --> 00:38:20,430
right so these are the high-level

00:38:18,630 --> 00:38:21,750
characteristics of the language it's

00:38:20,430 --> 00:38:23,700
easy to learn we have a rapid

00:38:21,750 --> 00:38:25,620
development cycle economy of expressions

00:38:23,700 --> 00:38:27,870
beautiful one way to do it interactive

00:38:25,620 --> 00:38:29,100
prompt and clear the batteries lots of

00:38:27,870 --> 00:38:30,960
good stuff going on behind the scenes

00:38:29,100 --> 00:38:32,850
and common protocols if you're going to

00:38:30,960 --> 00:38:35,400
build your new language X it should do

00:38:32,850 --> 00:38:37,110
all these things to be successful let's

00:38:35,400 --> 00:38:38,700
look at what we've got in the language

00:38:37,110 --> 00:38:41,160
itself because I've not mentioned one

00:38:38,700 --> 00:38:42,690
line of Python yet of saying this is

00:38:41,160 --> 00:38:45,840
something Python can do that other

00:38:42,690 --> 00:38:47,730
languages don't here's what we got good

00:38:45,840 --> 00:38:49,860
solid foundation using dictionaries in

00:38:47,730 --> 00:38:52,110
list why is it set some of this because

00:38:49,860 --> 00:38:54,900
you can do everything with just dicks

00:38:52,110 --> 00:38:56,100
and list we have offered in the

00:38:54,900 --> 00:38:57,480
collections module many other

00:38:56,100 --> 00:38:59,940
collections that you can use that are

00:38:57,480 --> 00:39:02,430
specialized but if I can teach somebody

00:38:59,940 --> 00:39:04,860
Dixon list they can create data

00:39:02,430 --> 00:39:06,660
structures of arbitrary complexity those

00:39:04,860 --> 00:39:09,240
two are sufficient to solve any problem

00:39:06,660 --> 00:39:11,100
we have automatic memory management

00:39:09,240 --> 00:39:15,180
that's fantastic those of you who have

00:39:11,100 --> 00:39:17,880
ever suffered with pointers leaks and

00:39:15,180 --> 00:39:21,180
writing - previously freed memory and

00:39:17,880 --> 00:39:22,950
whatnot know how much pain is involved

00:39:21,180 --> 00:39:24,840
and how much is safe for those of you

00:39:22,950 --> 00:39:25,950
who just learned Python is your first

00:39:24,840 --> 00:39:27,600
language you probably have no

00:39:25,950 --> 00:39:30,440
appreciation for how much pain other

00:39:27,600 --> 00:39:34,470
people live with we have exceptions

00:39:30,440 --> 00:39:38,100
we've made everything first-class which

00:39:34,470 --> 00:39:40,620
is fantastic if I highly recommend

00:39:38,100 --> 00:39:43,020
reading Jolan software so Joel Spolsky

00:39:40,620 --> 00:39:44,490
has a lot of good advice but he had this

00:39:43,020 --> 00:39:47,510
one article that was wonderful it was

00:39:44,490 --> 00:39:49,650
called can your language do this and

00:39:47,510 --> 00:39:51,420
essentially the article was about

00:39:49,650 --> 00:39:53,190
first-class functions in first class

00:39:51,420 --> 00:39:53,990
classes and the ability to pass them

00:39:53,190 --> 00:39:56,599
around as are

00:39:53,990 --> 00:39:58,490
and he argues heavily in that paper that

00:39:56,599 --> 00:40:00,260
it enables you to have higher-level

00:39:58,490 --> 00:40:02,000
solutions to problem in Abel's you to

00:40:00,260 --> 00:40:03,380
think thoughts that are not possible in

00:40:02,000 --> 00:40:05,599
languages where these things aren't

00:40:03,380 --> 00:40:06,800
first-class and you said basically if

00:40:05,599 --> 00:40:08,690
you don't have them if your language

00:40:06,800 --> 00:40:12,050
can't do this you're using the wrong

00:40:08,690 --> 00:40:13,730
language and you have taken the rain to

00:40:12,050 --> 00:40:16,130
possible solution to problems and throw

00:40:13,730 --> 00:40:17,869
in a huge chunk of them away then we

00:40:16,130 --> 00:40:20,480
have over writable syntax which is now

00:40:17,869 --> 00:40:22,040
fairly common in many languages and

00:40:20,480 --> 00:40:24,650
everybody can override their add

00:40:22,040 --> 00:40:26,390
operator although not everybody can

00:40:24,650 --> 00:40:29,570
override their diet I have a whole talk

00:40:26,390 --> 00:40:32,050
on who owns a diet you guys know the

00:40:29,570 --> 00:40:35,450
answer the question who owns the dot

00:40:32,050 --> 00:40:37,520
matter of fact you do everybody knows

00:40:35,450 --> 00:40:40,070
they own the brackets you know in first

00:40:37,520 --> 00:40:41,599
couple days of programming Python you

00:40:40,070 --> 00:40:44,450
learn there's a magic method under under

00:40:41,599 --> 00:40:46,310
get item under under like I can

00:40:44,450 --> 00:40:48,380
reprogram the brackets and people

00:40:46,310 --> 00:40:50,000
happily reprogram the packets for years

00:40:48,380 --> 00:40:52,820
never realizing they can reprogram the

00:40:50,000 --> 00:40:55,580
dot to you control what the dot does you

00:40:52,820 --> 00:40:57,589
own the dot all right the iterator

00:40:55,580 --> 00:40:59,290
protocol is something fantasticks the

00:40:57,589 --> 00:41:02,210
high-level glue that holds the language

00:40:59,290 --> 00:41:03,440
together what's interesting when I talk

00:41:02,210 --> 00:41:05,869
to companies where there are big Java

00:41:03,440 --> 00:41:08,150
chef says we've got iterators too and so

00:41:05,869 --> 00:41:10,250
the C++ in fact I can write an iterator

00:41:08,150 --> 00:41:13,040
protocol in every language why is it

00:41:10,250 --> 00:41:15,560
special in Python it's special in Python

00:41:13,040 --> 00:41:17,960
because we've made an effort to make

00:41:15,560 --> 00:41:20,619
everything that could possibly be

00:41:17,960 --> 00:41:22,700
iterated follow the iterator protocol

00:41:20,619 --> 00:41:24,290
we've also made everything that could

00:41:22,700 --> 00:41:27,200
possibly consume an iterator use

00:41:24,290 --> 00:41:29,810
iterator protocol and that way you can

00:41:27,200 --> 00:41:32,540
take a string and feed it to set I feed

00:41:29,810 --> 00:41:34,640
that to sort it and what will that do

00:41:32,540 --> 00:41:36,500
that will unify the string eliminate the

00:41:34,640 --> 00:41:39,560
difficult elements and then sort them

00:41:36,500 --> 00:41:42,260
which is interesting because sort was

00:41:39,560 --> 00:41:44,720
written before sets it didn't know that

00:41:42,260 --> 00:41:46,369
that's existed sets were written without

00:41:44,720 --> 00:41:48,290
knowing anything about strings yet these

00:41:46,369 --> 00:41:50,570
things fit together by like Legos so I

00:41:48,290 --> 00:41:52,070
like to use the Lego analysis analogy if

00:41:50,570 --> 00:41:53,630
you've reached under box of Legos and

00:41:52,070 --> 00:41:55,010
take any two pieces and they have these

00:41:53,630 --> 00:41:56,540
little dots on them that are the same

00:41:55,010 --> 00:41:59,510
size and you put them together and the

00:41:56,540 --> 00:42:01,160
Legos fit together now imagine a Lego

00:41:59,510 --> 00:42:02,450
box where they have four or five

00:42:01,160 --> 00:42:04,369
different connect

00:42:02,450 --> 00:42:07,130
sizes and you grab two pieces and they

00:42:04,369 --> 00:42:09,790
didn't just fit together neatly how much

00:42:07,130 --> 00:42:12,740
less useful in less fun what Legos B

00:42:09,790 --> 00:42:14,480
Python has the Lego design our iterators

00:42:12,740 --> 00:42:16,730
of the glue that fit the language

00:42:14,480 --> 00:42:17,869
together and if you expend your mind a

00:42:16,730 --> 00:42:19,849
little bit you can see a relationship

00:42:17,869 --> 00:42:23,030
between how we use iterators and hel

00:42:19,849 --> 00:42:25,550
pipes and filters are used in unix it's

00:42:23,030 --> 00:42:27,260
a winning language feature list

00:42:25,550 --> 00:42:29,089
comprehensions are by far one of the

00:42:27,260 --> 00:42:30,770
most popular features of language when I

00:42:29,089 --> 00:42:32,630
teach people whis comprehensions they

00:42:30,770 --> 00:42:35,720
experience joy as I've been your

00:42:32,630 --> 00:42:37,730
experience Peter alright they're clean

00:42:35,720 --> 00:42:39,320
and beautiful they're divided derived

00:42:37,730 --> 00:42:42,010
from a notation used in mathematics

00:42:39,320 --> 00:42:44,480
they're much more expressive and

00:42:42,010 --> 00:42:45,950
flexible than map filter and reduce the

00:42:44,480 --> 00:42:46,760
traditional functional programming

00:42:45,950 --> 00:42:48,710
operators

00:42:46,760 --> 00:42:53,630
alright here's something we got nobody

00:42:48,710 --> 00:42:55,700
else ain't got as generators generators

00:42:53,630 --> 00:42:59,089
have magical properties they're right

00:42:55,700 --> 00:43:01,010
along and then suddenly they stop they

00:42:59,089 --> 00:43:02,000
remember where they were they remember

00:43:01,010 --> 00:43:04,640
if they're in the middle of the loop

00:43:02,000 --> 00:43:06,470
they remember any pending trying accepts

00:43:04,640 --> 00:43:08,270
they know where they are and a

00:43:06,470 --> 00:43:10,670
successive a calls in Sacre and they

00:43:08,270 --> 00:43:11,839
yield back up and later when you call

00:43:10,670 --> 00:43:13,400
next on them they pick up where they

00:43:11,839 --> 00:43:16,790
left off remembering all the local

00:43:13,400 --> 00:43:18,950
variables and resuming enabling us to do

00:43:16,790 --> 00:43:20,810
powerful co-routine style programming

00:43:18,950 --> 00:43:23,150
there's a lot of wonderful things that

00:43:20,810 --> 00:43:24,800
can be done with generators they can be

00:43:23,150 --> 00:43:27,230
done also with classes but it's very

00:43:24,800 --> 00:43:30,520
hard with classes we've taken problems

00:43:27,230 --> 00:43:32,660
that are really hard to take advanced

00:43:30,520 --> 00:43:35,390
programmers and other languages things

00:43:32,660 --> 00:43:38,150
that you need a hardcore C++ programmer

00:43:35,390 --> 00:43:40,190
to do junior Python programmers can do

00:43:38,150 --> 00:43:42,290
easily put with generators we've been

00:43:40,190 --> 00:43:43,910
things out and generators in seconds

00:43:42,290 --> 00:43:47,210
that take people days and other

00:43:43,910 --> 00:43:50,810
languages I think it's fantastic ok

00:43:47,210 --> 00:43:51,859
another winning feature was we combine

00:43:50,810 --> 00:43:54,740
these great ideas

00:43:51,859 --> 00:43:56,930
we took generators and those were great

00:43:54,740 --> 00:43:58,369
list comprehensions are great how about

00:43:56,930 --> 00:43:59,660
we married the two and see what the

00:43:58,369 --> 00:44:02,060
offspring looks like can we get

00:43:59,660 --> 00:44:04,760
generator expressions say comprehensions

00:44:02,060 --> 00:44:05,450
and disk comps who likes those you're

00:44:04,760 --> 00:44:06,920
fantastic

00:44:05,450 --> 00:44:09,609
who knows what's special about generator

00:44:06,920 --> 00:44:09,609
expressions Oh

00:44:12,550 --> 00:44:17,270
yeah okay so when I teach a class I

00:44:16,100 --> 00:44:19,190
always like to say I'm going to give you

00:44:17,270 --> 00:44:21,260
a pop quiz periodically and I ask you

00:44:19,190 --> 00:44:22,880
the question what is special about this

00:44:21,260 --> 00:44:27,530
feature and the answer is always the

00:44:22,880 --> 00:44:30,800
same I made that that's a Raymond okay

00:44:27,530 --> 00:44:33,980
and decorators they're fantastic they're

00:44:30,800 --> 00:44:36,320
easy on the eyes they're expressive we

00:44:33,980 --> 00:44:37,550
had no idea how great they were going to

00:44:36,320 --> 00:44:39,380
them to be there's this Django project

00:44:37,550 --> 00:44:40,610
that said it needed them there was

00:44:39,380 --> 00:44:42,620
another project that said it would have

00:44:40,610 --> 00:44:45,860
been nice to have and our thought was

00:44:42,620 --> 00:44:46,910
well you could just you know it doesn't

00:44:45,860 --> 00:44:49,130
really do much it's just a little

00:44:46,910 --> 00:44:50,780
syntactic sugar my goodness it

00:44:49,130 --> 00:44:52,970
transformed the language are incredibly

00:44:50,780 --> 00:44:55,040
expressive and it adds a powerful layer

00:44:52,970 --> 00:44:57,710
of composable tools if I had time I

00:44:55,040 --> 00:45:00,590
would show you the Fibonacci example

00:44:57,710 --> 00:45:02,930
where I take an incredibly slow program

00:45:00,590 --> 00:45:06,110
and it make it fast just by adding one

00:45:02,930 --> 00:45:08,480
line at LRU cache what does that do for

00:45:06,110 --> 00:45:11,150
us it takes a traditionally written

00:45:08,480 --> 00:45:14,360
program algorithm and it makes it into a

00:45:11,150 --> 00:45:16,070
dynamic algorithm and it's fantastic so

00:45:14,360 --> 00:45:18,110
that'll be a talk for another day

00:45:16,070 --> 00:45:19,850
the important thing is amazing things

00:45:18,110 --> 00:45:22,100
can be done just by adding decorators in

00:45:19,850 --> 00:45:23,660
front of functions and classes another

00:45:22,100 --> 00:45:24,830
winning feature something that you don't

00:45:23,660 --> 00:45:28,490
get with compiled language is the

00:45:24,830 --> 00:45:29,480
ability to introspect itself I have one

00:45:28,490 --> 00:45:31,610
of the things I like to show off to

00:45:29,480 --> 00:45:33,650
people when I'm teaching the Python is

00:45:31,610 --> 00:45:37,040
the help function I said help

00:45:33,650 --> 00:45:38,510
collections module how does it and

00:45:37,040 --> 00:45:39,620
they're not impressed I said how does

00:45:38,510 --> 00:45:41,780
this work in the other any other

00:45:39,620 --> 00:45:44,360
language how does it work if you type

00:45:41,780 --> 00:45:46,640
man and the name of some function in

00:45:44,360 --> 00:45:48,230
UNIX it goes out and it looks up a

00:45:46,640 --> 00:45:50,270
pre-made txt file and it shows you that

00:45:48,230 --> 00:45:52,910
not very impressive what does it do in

00:45:50,270 --> 00:45:55,520
Python it builds it on the fly it

00:45:52,910 --> 00:45:58,280
respects the code and generates it this

00:45:55,520 --> 00:46:00,830
is not a premade help file and then we

00:45:58,280 --> 00:46:04,580
have the ability to exec and an eval

00:46:00,830 --> 00:46:06,320
these have tended fallen into disuse but

00:46:04,580 --> 00:46:08,360
they are amazingly powerful tools and I

00:46:06,320 --> 00:46:10,490
make I recommend putting them back into

00:46:08,360 --> 00:46:12,710
your toolbox lizard users will tell you

00:46:10,490 --> 00:46:15,020
that's the thing that makes Lisp Lisp

00:46:12,710 --> 00:46:17,690
it's the ability to evaluate itself in a

00:46:15,020 --> 00:46:19,250
language that can evaluate itself has an

00:46:17,690 --> 00:46:21,230
extra layer of capabilities that you

00:46:19,250 --> 00:46:22,920
won't find almost anywhere else go take

00:46:21,230 --> 00:46:24,210
a look at the source code for time

00:46:22,920 --> 00:46:25,620
or take a look at the source code for

00:46:24,210 --> 00:46:29,280
named Tempel you'll see a couple

00:46:25,620 --> 00:46:32,760
excellent uses of X executive L they are

00:46:29,280 --> 00:46:37,290
not simple and then the with statement

00:46:32,760 --> 00:46:40,740
is new technology it's wonderful so in

00:46:37,290 --> 00:46:43,020
the old days they had go twos and then

00:46:40,740 --> 00:46:44,850
they had this idea they said you know

00:46:43,020 --> 00:46:46,770
what we're using the same piece of code

00:46:44,850 --> 00:46:49,920
over and over again and fuss was born

00:46:46,770 --> 00:46:51,360
gosub 50 years ago we got the subroutine

00:46:49,920 --> 00:46:56,190
how important was that for the

00:46:51,360 --> 00:46:58,260
advancement of man hugely important go

00:46:56,190 --> 00:47:00,510
sub to a subroutine and use the same

00:46:58,260 --> 00:47:02,370
piece of code over and over again where

00:47:00,510 --> 00:47:06,420
does it come up I have a programming

00:47:02,370 --> 00:47:08,940
pattern code a be followed by C later I

00:47:06,420 --> 00:47:10,800
have a piece of code where the part in

00:47:08,940 --> 00:47:12,660
the middle is the same as it was the

00:47:10,800 --> 00:47:15,000
first time I take that a factor out the

00:47:12,660 --> 00:47:17,610
code in the middle and I do a go sub to

00:47:15,000 --> 00:47:19,610
make a subroutine out of it it's

00:47:17,610 --> 00:47:22,140
fantastic so the middle of the sandwich

00:47:19,610 --> 00:47:24,270
it's the part that's the same we have

00:47:22,140 --> 00:47:27,030
lots of ways to take tuna and put

00:47:24,270 --> 00:47:28,860
different kinds of bread around it that

00:47:27,030 --> 00:47:31,440
was the subroutine the would statement

00:47:28,860 --> 00:47:33,870
does the opposite the width statement

00:47:31,440 --> 00:47:36,630
says what if the setup code and the

00:47:33,870 --> 00:47:38,400
teardown code are the acquire lock and

00:47:36,630 --> 00:47:39,630
the release car what if that's the part

00:47:38,400 --> 00:47:41,670
that's the same in the part that's

00:47:39,630 --> 00:47:43,080
inside the same has changed so now

00:47:41,670 --> 00:47:44,730
suddenly I have several different types

00:47:43,080 --> 00:47:48,240
I say I'm going to have something online

00:47:44,730 --> 00:47:50,160
and I can put it inside to a various

00:47:48,240 --> 00:47:51,690
types of meat and whatnot it is the

00:47:50,160 --> 00:47:53,610
inverse of the complement to the

00:47:51,690 --> 00:47:55,440
subroutine and I contend that the with

00:47:53,610 --> 00:47:57,600
statement is as important as the

00:47:55,440 --> 00:47:59,970
invention of the subroutine it's going

00:47:57,600 --> 00:48:01,140
to be that useful and it's new enough to

00:47:59,970 --> 00:48:04,050
where you probably have a deeply

00:48:01,140 --> 00:48:06,110
ingrained into your thinking but context

00:48:04,050 --> 00:48:08,280
managers and the would statement are a

00:48:06,110 --> 00:48:10,350
major advance in computer science

00:48:08,280 --> 00:48:12,270
technology you will start to see it in

00:48:10,350 --> 00:48:15,240
other languages the next few years we

00:48:12,270 --> 00:48:17,040
got it first and we have our abstract

00:48:15,240 --> 00:48:19,260
base classes well lots of languages have

00:48:17,040 --> 00:48:19,950
an abstract base classes ours have

00:48:19,260 --> 00:48:22,260
mix-ins

00:48:19,950 --> 00:48:24,000
how long does it take you to write a

00:48:22,260 --> 00:48:26,130
dictionary like object well you just

00:48:24,000 --> 00:48:28,530
might a class the defines get item set

00:48:26,130 --> 00:48:30,030
item delete item in it ER and then

00:48:28,530 --> 00:48:31,230
inherit from the abstract base class and

00:48:30,030 --> 00:48:35,190
you get all the other methods for free

00:48:31,230 --> 00:48:38,430
who thinks that's fantastic all right

00:48:35,190 --> 00:48:40,230
and our winning feature is the

00:48:38,430 --> 00:48:43,200
indentation it contributes to the clean

00:48:40,230 --> 00:48:45,780
uncluttered appearance which would given

00:48:43,200 --> 00:48:47,790
a fantastic example of code in C that

00:48:45,780 --> 00:48:50,340
could cause tremendous headaches because

00:48:47,790 --> 00:48:52,700
the indentation didn't match while

00:48:50,340 --> 00:48:55,830
usually tell a story here of a piece of

00:48:52,700 --> 00:48:57,900
code that took AT&T offline for 8 hours

00:48:55,830 --> 00:49:00,920
in the end they traced it down to an

00:48:57,900 --> 00:49:02,880
indentation error where the indentation

00:49:00,920 --> 00:49:04,350
suggested that the code did something

00:49:02,880 --> 00:49:06,540
different from what it actually did that

00:49:04,350 --> 00:49:08,280
type of error is not possible in Python

00:49:06,540 --> 00:49:09,840
the appearance of the program doesn't

00:49:08,280 --> 00:49:11,400
lie to you about what it does if

00:49:09,840 --> 00:49:13,170
something is indented under the for loop

00:49:11,400 --> 00:49:15,420
it's in the body of the for loop it's

00:49:13,170 --> 00:49:17,490
not indented it's not the parents

00:49:15,420 --> 00:49:20,400
matches the functionality that's

00:49:17,490 --> 00:49:22,320
important all right so summary is we

00:49:20,400 --> 00:49:23,700
have a solid foundation we built on top

00:49:22,320 --> 00:49:25,080
of this and licks we have automatic

00:49:23,700 --> 00:49:26,910
memory management exceptions first-class

00:49:25,080 --> 00:49:28,200
features over editable syntax we've

00:49:26,910 --> 00:49:31,320
glued the language together with the

00:49:28,200 --> 00:49:33,600
delay Lego the uniform the iterator

00:49:31,320 --> 00:49:36,360
protocol we have generators nobody has

00:49:33,600 --> 00:49:38,550
got those except for icon we married the

00:49:36,360 --> 00:49:41,150
two together made gen next we have

00:49:38,550 --> 00:49:43,110
beautiful decorators we can have

00:49:41,150 --> 00:49:45,600
introspect we have abstract base classes

00:49:43,110 --> 00:49:47,250
with mix-ins and the ability to exert

00:49:45,600 --> 00:49:49,620
ourselves and we have the new width

00:49:47,250 --> 00:49:52,080
statement a new technology and beautiful

00:49:49,620 --> 00:49:55,110
indentation I contend that Python is

00:49:52,080 --> 00:49:57,920
awesome do you agree fantastic thank you

00:49:55,110 --> 00:49:57,920

YouTube URL: https://www.youtube.com/watch?v=b_pTxGu2L04


