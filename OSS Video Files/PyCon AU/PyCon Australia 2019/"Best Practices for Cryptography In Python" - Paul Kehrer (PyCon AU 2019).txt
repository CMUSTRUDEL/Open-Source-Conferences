Title: "Best Practices for Cryptography In Python" - Paul Kehrer (PyCon AU 2019)
Publication date: 2019-08-02
Playlist: PyCon Australia 2019
Description: 
	Paul Kehrer

Part of what makes Python great also brings challenges for cryptographic operations that need rigorous control of memory and CPU instructions. In this talk we'll discuss situations where Python is a poor fit as well as ones where it shines and learn how to work around some of the issues.

https://2019.pycon-au.org/talks/best-practices-for-cryptography-in-python

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 2 - 6 2019.

Video licence: CC BY-NC-SA 4.0 - https://creativecommons.org/licenses/by-nc-sa/4.0/

Python, PyCon, PyConAU

Fri Aug  2 14:10:00 2019 at C3.6
Captions: 
	00:00:00,350 --> 00:00:05,460
all right thank you very much so let's

00:00:03,000 --> 00:00:07,170
get started I thank you all very very

00:00:05,460 --> 00:00:08,220
much for finding the actual room I

00:00:07,170 --> 00:00:09,780
wasn't sure if I would actually be able

00:00:08,220 --> 00:00:11,460
to after we got swapped I think it's

00:00:09,780 --> 00:00:13,049
kind of an interesting metaphor for

00:00:11,460 --> 00:00:15,210
Python in general that data science is

00:00:13,049 --> 00:00:20,130
pushing all the rest of us out that's

00:00:15,210 --> 00:00:22,439
okay all right so this talk is going to

00:00:20,130 --> 00:00:24,390
be about best practices for performing

00:00:22,439 --> 00:00:25,769
cryptography and Python and I'd like to

00:00:24,390 --> 00:00:28,640
start out with something a little bit

00:00:25,769 --> 00:00:30,869
unusual which is spoiling the conclusion

00:00:28,640 --> 00:00:34,260
which of course I have to push the right

00:00:30,869 --> 00:00:37,260
buttons that's all right there we go yes

00:00:34,260 --> 00:00:39,329
secure key cryptography is possible in

00:00:37,260 --> 00:00:42,120
Python but as with anything related to

00:00:39,329 --> 00:00:43,980
cryptography there are asterisks how

00:00:42,120 --> 00:00:47,100
many depends on what you're trying to do

00:00:43,980 --> 00:00:48,690
this is a lousy answer but since most of

00:00:47,100 --> 00:00:50,190
this room likely fights with computers

00:00:48,690 --> 00:00:52,070
for a living you should be used to

00:00:50,190 --> 00:00:54,000
disappointment

00:00:52,070 --> 00:00:55,410
now that you've seen the conclusion

00:00:54,000 --> 00:00:57,329
you're all welcome to leave of course

00:00:55,410 --> 00:01:01,649
it's quite warm but if you'd like to

00:00:57,329 --> 00:01:04,949
know why this is true stick around hi

00:01:01,649 --> 00:01:06,479
I'm Paul Cara I'm a principal security

00:01:04,949 --> 00:01:08,549
engineer at a company called trail of

00:01:06,479 --> 00:01:10,950
wits and a core developer for the Python

00:01:08,549 --> 00:01:12,900
cryptographic Authority I spend my days

00:01:10,950 --> 00:01:14,580
reading papers auditing low-level

00:01:12,900 --> 00:01:16,140
cryptographic implementations writing

00:01:14,580 --> 00:01:18,869
Python cryptographic code and other

00:01:16,140 --> 00:01:20,220
really really boring things for those in

00:01:18,869 --> 00:01:21,990
the back who can't easily see me I

00:01:20,220 --> 00:01:28,020
provided a recent selfie on this slide

00:01:21,990 --> 00:01:29,430
as well so we have an agenda today we

00:01:28,020 --> 00:01:32,100
don't have a lot of time and this is a

00:01:29,430 --> 00:01:33,270
very complex topic at the end of this

00:01:32,100 --> 00:01:35,189
talk you should have a reasonable

00:01:33,270 --> 00:01:38,490
understanding of what I mean when I say

00:01:35,189 --> 00:01:39,930
is Python good for cryptography knowing

00:01:38,490 --> 00:01:42,090
the limitations and strengths of this

00:01:39,930 --> 00:01:43,799
language in the context of security

00:01:42,090 --> 00:01:45,360
sensitive software will let you make

00:01:43,799 --> 00:01:48,500
more informed decisions when designing

00:01:45,360 --> 00:01:48,500
and building your projects in the future

00:01:49,040 --> 00:01:53,220
this talk assumes no background

00:01:51,600 --> 00:01:54,869
knowledge about cryptography or the

00:01:53,220 --> 00:01:55,320
implementation details of the Python

00:01:54,869 --> 00:01:57,979
interpreter

00:01:55,320 --> 00:02:00,240
unlike the draft ahead of this at 8 a.m.

00:01:57,979 --> 00:02:02,640
it does however provide an introduction

00:02:00,240 --> 00:02:04,560
to those cryptographic concerns and it

00:02:02,640 --> 00:02:06,210
tries to provide a grounding to users

00:02:04,560 --> 00:02:08,160
without cryptographic or C language

00:02:06,210 --> 00:02:10,020
experience if you have no C language

00:02:08,160 --> 00:02:12,240
experience I'm jealous of you and I

00:02:10,020 --> 00:02:13,950
would love to meet you

00:02:12,240 --> 00:02:15,480
once we've completed that introduction

00:02:13,950 --> 00:02:17,010
we'll run through a thought of exercise

00:02:15,480 --> 00:02:19,230
around implementing some cryptography

00:02:17,010 --> 00:02:21,420
and pure Python briefly talk about risk

00:02:19,230 --> 00:02:23,670
assessment and threat modeling for your

00:02:21,420 --> 00:02:26,100
application discuss the not-so-secret

00:02:23,670 --> 00:02:27,720
superpower thats python has and draw

00:02:26,100 --> 00:02:32,570
some conclusions which you've already

00:02:27,720 --> 00:02:37,080
seen but pretend we have it so what is

00:02:32,570 --> 00:02:38,520
cryptography really well in the presence

00:02:37,080 --> 00:02:40,340
of adversaries we need to be able to

00:02:38,520 --> 00:02:42,120
securely communicate information

00:02:40,340 --> 00:02:44,250
adversaries can be passive or active

00:02:42,120 --> 00:02:45,570
which is to say in a passive context

00:02:44,250 --> 00:02:47,100
they're just listening

00:02:45,570 --> 00:02:48,330
they can also be active which is to say

00:02:47,100 --> 00:02:49,800
they sit in the middle and they want to

00:02:48,330 --> 00:02:51,900
manipulate things maybe they are trying

00:02:49,800 --> 00:02:55,440
to terminate connections maybe they're

00:02:51,900 --> 00:02:57,320
attempting to just flip bytes and screw

00:02:55,440 --> 00:02:59,220
with things you're attempting to do

00:02:57,320 --> 00:03:00,870
communication may be synchronous or

00:02:59,220 --> 00:03:02,820
asynchronous synchronous communication

00:03:00,870 --> 00:03:05,760
in this context is something like TLS

00:03:02,820 --> 00:03:08,070
say HTTP so bad things of that nature or

00:03:05,760 --> 00:03:09,390
in an asynchronous model you may be

00:03:08,070 --> 00:03:10,740
looking at things like signal or

00:03:09,390 --> 00:03:12,450
whatsapp where you're where you're

00:03:10,740 --> 00:03:13,800
attempting to communicate securely and

00:03:12,450 --> 00:03:17,370
you're not actually talking the other

00:03:13,800 --> 00:03:18,990
side at the exact same time information

00:03:17,370 --> 00:03:20,460
is not necessarily a file a lot of

00:03:18,990 --> 00:03:22,560
people tend to think of everything in a

00:03:20,460 --> 00:03:24,810
file based model but actually all the

00:03:22,560 --> 00:03:26,490
information around your communication

00:03:24,810 --> 00:03:28,410
channel is also something you want to

00:03:26,490 --> 00:03:29,430
protect in an ideal world we'd like to

00:03:28,410 --> 00:03:31,440
protect the fact that you're even

00:03:29,430 --> 00:03:32,640
talking to somebody it turns out in the

00:03:31,440 --> 00:03:35,010
way we've designed the Internet that's

00:03:32,640 --> 00:03:36,660
not possible right now but we would very

00:03:35,010 --> 00:03:40,530
much like to hide every bit of metadata

00:03:36,660 --> 00:03:42,060
we possibly can in practice writing

00:03:40,530 --> 00:03:43,670
cryptographic software is difficult

00:03:42,060 --> 00:03:47,700
because you need both algorithms and

00:03:43,670 --> 00:03:49,410
implementations to be secure so a few

00:03:47,700 --> 00:03:50,580
more common forms of cryptography just

00:03:49,410 --> 00:03:52,620
for those of you who may be wondering

00:03:50,580 --> 00:03:53,880
you have symmetric encryption you have

00:03:52,620 --> 00:03:55,530
asymmetric signatures symmetric

00:03:53,880 --> 00:03:58,020
encryption things like a yes asymmetric

00:03:55,530 --> 00:03:59,340
signatures or things like ECDSA RSA

00:03:58,020 --> 00:04:00,780
don't worry about these acronyms I'm

00:03:59,340 --> 00:04:02,460
just gonna throw acronyms to it soup at

00:04:00,780 --> 00:04:02,790
you all day long it doesn't really

00:04:02,460 --> 00:04:05,160
matter

00:04:02,790 --> 00:04:06,630
but then there's also more esoteric

00:04:05,160 --> 00:04:08,580
things that are kind of more interesting

00:04:06,630 --> 00:04:11,070
in the fields of cryptography these days

00:04:08,580 --> 00:04:13,230
like zero knowledge prove our oblivious

00:04:11,070 --> 00:04:15,660
Ram and things of that nature ultimately

00:04:13,230 --> 00:04:16,920
in cryptography any information leakage

00:04:15,660 --> 00:04:18,690
can be problematic

00:04:16,920 --> 00:04:20,700
an attacker may be able to reconstruct

00:04:18,690 --> 00:04:23,040
things that are meant to be secret based

00:04:20,700 --> 00:04:24,120
on information as seemingly mundane as

00:04:23,040 --> 00:04:26,580
how long it took to

00:04:24,120 --> 00:04:28,320
is the message if we assume that the

00:04:26,580 --> 00:04:30,210
abstract algorithm itself doesn't leak

00:04:28,320 --> 00:04:32,729
information then what's left is ensuring

00:04:30,210 --> 00:04:34,560
the concrete implementation is safe thus

00:04:32,729 --> 00:04:36,330
implementing cryptographic algorithms is

00:04:34,560 --> 00:04:41,639
essentially an exercise in eliminating

00:04:36,330 --> 00:04:43,260
information leakage so now that we have

00:04:41,639 --> 00:04:46,199
a workable definition for cryptography

00:04:43,260 --> 00:04:48,120
we need to define the scope we're going

00:04:46,199 --> 00:04:49,770
to focus strictly on implementation

00:04:48,120 --> 00:04:52,370
based issues caused by language level

00:04:49,770 --> 00:04:54,990
restrictions this is an important caveat

00:04:52,370 --> 00:04:56,520
like we don't get to dive into the wild

00:04:54,990 --> 00:04:58,110
world of protocol or algorithmic flaws

00:04:56,520 --> 00:04:59,820
which transcend the language you choose

00:04:58,110 --> 00:05:01,500
they're not relevant to the problems of

00:04:59,820 --> 00:05:03,330
Python they're a problem of the entire

00:05:01,500 --> 00:05:05,220
cryptographic ecosystem they're an

00:05:03,330 --> 00:05:06,990
incredibly cool aspect of cryptography

00:05:05,220 --> 00:05:09,030
discipline and I would happily talk your

00:05:06,990 --> 00:05:10,979
ear about those oh you're off about

00:05:09,030 --> 00:05:19,050
those four days but that's a different

00:05:10,979 --> 00:05:20,850
talk so you want to implement a

00:05:19,050 --> 00:05:24,030
cryptographic algorithm what are we

00:05:20,850 --> 00:05:26,010
going to need well we need low-level

00:05:24,030 --> 00:05:28,200
flow control which will allow us to

00:05:26,010 --> 00:05:29,669
prevent data-dependent branching that's

00:05:28,200 --> 00:05:31,500
kind of a fancy way of just saying that

00:05:29,669 --> 00:05:33,300
we want to make sure that we control the

00:05:31,500 --> 00:05:35,430
way that the processor actually execute

00:05:33,300 --> 00:05:38,160
everything we do we don't have anything

00:05:35,430 --> 00:05:39,660
in the middle that we can avoid we want

00:05:38,160 --> 00:05:41,190
to be able to control the caches that's

00:05:39,660 --> 00:05:42,599
you know in a modern processor you have

00:05:41,190 --> 00:05:44,550
a level one level two and level three

00:05:42,599 --> 00:05:46,020
caches a level one caches actually have

00:05:44,550 --> 00:05:48,120
both the data cache and an instruction

00:05:46,020 --> 00:05:49,530
cache those things are all relevant it

00:05:48,120 --> 00:05:52,080
turns out we even care about things like

00:05:49,530 --> 00:05:55,050
cache lines which is the number of bytes

00:05:52,080 --> 00:05:57,389
read and written to caches at specific

00:05:55,050 --> 00:05:59,430
levels because we don't if we our data

00:05:57,389 --> 00:06:00,930
strides across cache lines then that may

00:05:59,430 --> 00:06:04,500
you introduce timing variability that we

00:06:00,930 --> 00:06:06,180
care about we need to have price precise

00:06:04,500 --> 00:06:08,400
memory allocation in a ratio we need to

00:06:06,180 --> 00:06:10,139
be able to control when we zero it we

00:06:08,400 --> 00:06:11,910
need to be able to control whether or

00:06:10,139 --> 00:06:14,849
not it ever gets swapped to disk we need

00:06:11,910 --> 00:06:18,120
to be able to do effectively anything we

00:06:14,849 --> 00:06:20,070
could possibly can imagine to it we need

00:06:18,120 --> 00:06:21,660
as much speed as we can possibly get you

00:06:20,070 --> 00:06:24,180
will never ever hear anyone in

00:06:21,660 --> 00:06:28,050
cryptography say that was fast enough we

00:06:24,180 --> 00:06:30,090
can stop cryptography is always

00:06:28,050 --> 00:06:31,620
considered overhead and to make sure

00:06:30,090 --> 00:06:34,020
that people use it and to make sure that

00:06:31,620 --> 00:06:36,030
we can use it everywhere it needs to

00:06:34,020 --> 00:06:38,039
have the absolute lowest overhead

00:06:36,030 --> 00:06:39,659
possible in practice

00:06:38,039 --> 00:06:41,520
this means that we want to be able to do

00:06:39,659 --> 00:06:45,169
things like an Aes process multiple

00:06:41,520 --> 00:06:47,219
gigabytes per second per core or in TLS

00:06:45,169 --> 00:06:49,020
Netflix has historically actually

00:06:47,219 --> 00:06:51,689
resisted using TLS for a delivery of

00:06:49,020 --> 00:06:54,930
things because of the 1% CPU overhead

00:06:51,689 --> 00:06:55,889
that it provides so and as you might

00:06:54,930 --> 00:06:57,779
imagine when you're talking about

00:06:55,889 --> 00:06:59,669
hundreds of thousands or millions of CPU

00:06:57,779 --> 00:07:01,469
cores one percent actually ends up being

00:06:59,669 --> 00:07:03,659
a decent amount of money so we want

00:07:01,469 --> 00:07:05,219
processors we'd want processors to be

00:07:03,659 --> 00:07:07,319
faster of course but it turns out that

00:07:05,219 --> 00:07:08,330
since 2006 we don't get that so now we

00:07:07,319 --> 00:07:11,159
need to figure out how to make

00:07:08,330 --> 00:07:12,719
cryptography faster and then of course

00:07:11,159 --> 00:07:14,009
you need an aversion to healthy life

00:07:12,719 --> 00:07:16,199
choices whenever you're doing anything

00:07:14,009 --> 00:07:21,990
in cryptography not a requirement but I

00:07:16,199 --> 00:07:23,069
do highly recommend it so unfortunate

00:07:21,990 --> 00:07:29,939
this means most of this code is written

00:07:23,069 --> 00:07:31,800
in C why well ultimately ubiquity C the

00:07:29,939 --> 00:07:34,080
C ABI is the lingua franca of computing

00:07:31,800 --> 00:07:35,099
if you don't know what an ABI is don't

00:07:34,080 --> 00:07:37,439
worry about it

00:07:35,099 --> 00:07:39,209
and C you compile code into a binary and

00:07:37,439 --> 00:07:40,740
within the binary data is structured in

00:07:39,209 --> 00:07:42,629
a very specific fashion to allow the

00:07:40,740 --> 00:07:43,949
lookup and calling of functions the

00:07:42,629 --> 00:07:46,370
manner in which this is done is called

00:07:43,949 --> 00:07:48,990
the application binary interface or API

00:07:46,370 --> 00:07:50,849
many local languages know how to invoke

00:07:48,990 --> 00:07:52,469
things via the C API and that can be a

00:07:50,849 --> 00:07:54,959
very powerful tool to augment their own

00:07:52,469 --> 00:07:56,519
capabilities pythons included but let's

00:07:54,959 --> 00:07:57,839
again let's pretend I haven't said that

00:07:56,519 --> 00:08:01,259
just yet we don't want to ruin my

00:07:57,839 --> 00:08:02,909
amazing reveals a second cryptography

00:08:01,259 --> 00:08:04,439
cares deeply about speed as we've

00:08:02,909 --> 00:08:06,539
already talked about and C is much

00:08:04,439 --> 00:08:08,279
faster than Python I and many other

00:08:06,539 --> 00:08:10,229
languages for reasons outside the scope

00:08:08,279 --> 00:08:12,180
of this talk for now just know that you

00:08:10,229 --> 00:08:13,979
can do all sorts of things frequently

00:08:12,180 --> 00:08:16,709
very very dangerous ones that can make

00:08:13,979 --> 00:08:18,479
things faster and of course the memory

00:08:16,709 --> 00:08:21,120
and safety industrial complex requires

00:08:18,479 --> 00:08:22,709
CDs to run if we stop writing things in

00:08:21,120 --> 00:08:24,779
memory unsafe languages we'd eliminate

00:08:22,709 --> 00:08:26,969
around 75% of all security

00:08:24,779 --> 00:08:31,889
vulnerabilities and why would we ever

00:08:26,969 --> 00:08:34,229
want to do that so let's go into an

00:08:31,889 --> 00:08:36,750
illustrative example let's talk about

00:08:34,229 --> 00:08:39,089
implementing an asymmetric algorithm the

00:08:36,750 --> 00:08:43,380
most commonly used algorithm here is RSA

00:08:39,089 --> 00:08:45,060
even though it really shouldn't be for

00:08:43,380 --> 00:08:46,920
budding crypto cryptographic engineers

00:08:45,060 --> 00:08:49,380
it is popular since it's so easy to

00:08:46,920 --> 00:08:50,970
implement and your massive mistakes in

00:08:49,380 --> 00:08:51,779
doing so make for a great Horror Story

00:08:50,970 --> 00:08:53,910
once you have more

00:08:51,779 --> 00:08:55,079
experience I won't go into all the ways

00:08:53,910 --> 00:08:56,459
in which this algorithm is dangerous

00:08:55,079 --> 00:08:57,480
right now but I've got some references

00:08:56,459 --> 00:09:00,120
at the end for those of you are

00:08:57,480 --> 00:09:02,249
interested they go into far too much

00:09:00,120 --> 00:09:04,730
depth and have a lot of profanity so

00:09:02,249 --> 00:09:07,199
they're not safe for this conversation

00:09:04,730 --> 00:09:08,999
RSA allows both signing an encryption so

00:09:07,199 --> 00:09:11,220
I put the relevant equations on this

00:09:08,999 --> 00:09:13,740
slide cryptographers are lazy like

00:09:11,220 --> 00:09:15,480
mathematicians so we use non descriptive

00:09:13,740 --> 00:09:17,370
variable names but I'll try to give both

00:09:15,480 --> 00:09:18,870
the name and the variable every time I

00:09:17,370 --> 00:09:22,170
talk about components of these equations

00:09:18,870 --> 00:09:23,759
in this talk so for signing you take a

00:09:22,170 --> 00:09:26,639
message you raise it to the private

00:09:23,759 --> 00:09:28,670
exponent exponent that's M to the D

00:09:26,639 --> 00:09:32,660
whereas D is the private exponent and

00:09:28,670 --> 00:09:36,029
you do that modulo n which is called

00:09:32,660 --> 00:09:38,279
conveniently the modulus the modulus is

00:09:36,029 --> 00:09:40,980
the product of two primes P and Q which

00:09:38,279 --> 00:09:43,079
we'll talk about a little bit later to

00:09:40,980 --> 00:09:45,569
verify message you take the signature

00:09:43,079 --> 00:09:47,459
that's s you raise it to the power of E

00:09:45,569 --> 00:09:51,059
which is of course the public exponent

00:09:47,459 --> 00:09:53,009
of course right and that public exponent

00:09:51,059 --> 00:09:56,129
is selected in a way we'll talk about a

00:09:53,009 --> 00:09:57,329
little bit for the Astra's algorithm all

00:09:56,129 --> 00:09:59,490
these operations are performed as

00:09:57,329 --> 00:10:00,870
integers so when you look at this you

00:09:59,490 --> 00:10:02,430
can actually think of this in terms of

00:10:00,870 --> 00:10:04,980
exactly the classical mathematics that

00:10:02,430 --> 00:10:06,269
you used to you convert your message to

00:10:04,980 --> 00:10:08,490
an integer and then you receive an

00:10:06,269 --> 00:10:09,809
energy signature of course since

00:10:08,490 --> 00:10:11,879
everything in computing is really just

00:10:09,809 --> 00:10:13,920
bits we can of course represent an

00:10:11,879 --> 00:10:15,420
integer as bytes which is how you

00:10:13,920 --> 00:10:16,769
typically see signatures and methods

00:10:15,420 --> 00:10:18,839
messages stone within cryptographic

00:10:16,769 --> 00:10:20,610
api's and in fact if you read

00:10:18,839 --> 00:10:22,290
cryptographic papers commonly you will

00:10:20,610 --> 00:10:25,230
see mathematics that look very similar

00:10:22,290 --> 00:10:27,809
to this you can actually think of that

00:10:25,230 --> 00:10:29,819
almost always as integers being operated

00:10:27,809 --> 00:10:32,009
upon it just so happens that as an

00:10:29,819 --> 00:10:33,720
implementation detail we can operate the

00:10:32,009 --> 00:10:37,889
on these things as opaque bikes byte

00:10:33,720 --> 00:10:38,879
strings and very weird ways so one

00:10:37,889 --> 00:10:40,319
interesting consequence of these

00:10:38,879 --> 00:10:42,209
equations is that a message has a

00:10:40,319 --> 00:10:44,069
maximal length related to the size of

00:10:42,209 --> 00:10:45,240
the key and the signing operation

00:10:44,069 --> 00:10:46,769
requires the private key while the

00:10:45,240 --> 00:10:48,600
verification only requires the public

00:10:46,769 --> 00:10:50,670
key the private key in this particular

00:10:48,600 --> 00:10:52,679
case you can think of as D and the

00:10:50,670 --> 00:10:56,519
public key is actually just N and E

00:10:52,679 --> 00:10:58,079
together this of course is what the

00:10:56,519 --> 00:10:59,399
essence of what makes this an asymmetric

00:10:58,079 --> 00:11:00,689
algorithm right you can perform certain

00:10:59,399 --> 00:11:02,160
operations with only the public

00:11:00,689 --> 00:11:04,670
components and sir topper a shion's only

00:11:02,160 --> 00:11:04,670
with the private

00:11:06,999 --> 00:11:14,660
whoops now so for an RSA encryption as

00:11:12,829 --> 00:11:16,129
opposed to a signature you encrypt using

00:11:14,660 --> 00:11:18,170
the public key and decrypt using the

00:11:16,129 --> 00:11:20,720
private key that is M to the e

00:11:18,170 --> 00:11:22,910
that's message to the Expo to the public

00:11:20,720 --> 00:11:24,649
exponent modulo n gives you the original

00:11:22,910 --> 00:11:29,389
message our sorry gives you the

00:11:24,649 --> 00:11:31,040
ciphertext and C to the D modulo n gives

00:11:29,389 --> 00:11:32,149
you the original message this allows

00:11:31,040 --> 00:11:35,029
anyone with your public key to encrypt

00:11:32,149 --> 00:11:36,949
things that only you could decrypt this

00:11:35,029 --> 00:11:39,259
is actually commonly used in older

00:11:36,949 --> 00:11:41,689
versions of TLS so like when you

00:11:39,259 --> 00:11:42,860
initially do a handshake it was it used

00:11:41,689 --> 00:11:44,839
to be the case that you would take the

00:11:42,860 --> 00:11:46,730
public key from the certificate encrypt

00:11:44,839 --> 00:11:47,779
what was called a premaster secret send

00:11:46,730 --> 00:11:50,749
it back to the server and then the

00:11:47,779 --> 00:11:52,129
server would then decrypt that perform a

00:11:50,749 --> 00:11:53,240
small operation that both sides knew how

00:11:52,129 --> 00:11:54,879
to do and then you would have a master

00:11:53,240 --> 00:11:57,040
secret that you could use to communicate

00:11:54,879 --> 00:11:59,089
that has its own set of problems

00:11:57,040 --> 00:12:00,980
primarily the fact that it's not what's

00:11:59,089 --> 00:12:02,870
called forward secret which is to say

00:12:00,980 --> 00:12:04,730
that if someone captures that public

00:12:02,870 --> 00:12:06,379
that captures the public key and is able

00:12:04,730 --> 00:12:07,759
to derive what that private key would be

00:12:06,379 --> 00:12:08,629
at some point in the future be at ten or

00:12:07,759 --> 00:12:10,610
twenty years from now

00:12:08,629 --> 00:12:12,199
every single bit of traffic that was

00:12:10,610 --> 00:12:14,300
ever captured underneath that will be

00:12:12,199 --> 00:12:15,889
decrypted you can avoid that with some

00:12:14,300 --> 00:12:19,370
other properties that again goes out of

00:12:15,889 --> 00:12:21,769
the out of the subject of this talk okay

00:12:19,370 --> 00:12:23,029
so enough math how do we generate the

00:12:21,769 --> 00:12:25,730
keys we need to perform these equations

00:12:23,029 --> 00:12:27,860
an RSA key is ultimately created from

00:12:25,730 --> 00:12:30,199
just three values two of which we need

00:12:27,860 --> 00:12:31,579
we need to actually create first we pick

00:12:30,199 --> 00:12:34,220
a public exponent which as we remember

00:12:31,579 --> 00:12:39,980
before is called E this value should

00:12:34,220 --> 00:12:41,420
always be 65535 I'm ality computational

00:12:39,980 --> 00:12:42,759
efficiency and resistance to a very

00:12:41,420 --> 00:12:45,949
specific kind of attack

00:12:42,759 --> 00:12:49,009
sometimes people pick 3 or 17 or in one

00:12:45,949 --> 00:12:51,649
memorable instance one but picking

00:12:49,009 --> 00:12:54,019
anything that isn't 65,536 going to make

00:12:51,649 --> 00:12:55,459
me squint very hard at you incidentally

00:12:54,019 --> 00:13:00,829
if you're curious why one is a bad

00:12:55,459 --> 00:13:02,449
choice well I hit spacebar he goes too

00:13:00,829 --> 00:13:05,839
forward that's the it's the power of

00:13:02,449 --> 00:13:08,029
Google Docs so let's click look closely

00:13:05,839 --> 00:13:12,470
at an equation here again what happens

00:13:08,029 --> 00:13:15,769
if E is 1 m to the e that's right

00:13:12,470 --> 00:13:17,360
nothing in this case C would then become

00:13:15,769 --> 00:13:18,200
the same as M and even though the

00:13:17,360 --> 00:13:19,760
algorithm was run

00:13:18,200 --> 00:13:22,040
although the entire cryptographic

00:13:19,760 --> 00:13:23,050
operation was performed the value does

00:13:22,040 --> 00:13:30,800
not change

00:13:23,050 --> 00:13:31,880
oops back to the topic at hand what else

00:13:30,800 --> 00:13:33,800
do we need to know when generating an

00:13:31,880 --> 00:13:37,699
RSA key well we know our public

00:13:33,800 --> 00:13:39,940
excellent public exponent will be 65536

00:13:37,699 --> 00:13:43,310
at a polt but we also need to prevent

00:13:39,940 --> 00:13:45,350
create two primes the p and q they must

00:13:43,310 --> 00:13:47,899
be very large primes typically around

00:13:45,350 --> 00:13:49,750
2048 bit right now and generating the

00:13:47,899 --> 00:13:51,380
involves having both a cryptographically

00:13:49,750 --> 00:13:55,070
cryptographically secure pseudo-random

00:13:51,380 --> 00:13:57,190
number generator c SP rng and a

00:13:55,070 --> 00:13:59,720
probabilistic prime allottee tester oh

00:13:57,190 --> 00:14:00,949
but make sure you run enough iterations

00:13:59,720 --> 00:14:03,260
because it turns out that in an

00:14:00,949 --> 00:14:06,290
adversarial model you can pick you can

00:14:03,260 --> 00:14:08,240
pick composite numbers that's a number

00:14:06,290 --> 00:14:09,649
that's not prime that can fool prime

00:14:08,240 --> 00:14:12,560
allottee testing with insufficient

00:14:09,649 --> 00:14:14,750
duration I know I know I promised to

00:14:12,560 --> 00:14:16,339
keep the scope to implementation level

00:14:14,750 --> 00:14:17,810
problems but cryptography has so many

00:14:16,339 --> 00:14:21,440
delightful places you can fail without

00:14:17,810 --> 00:14:23,300
even knowing it so from P and Q and E

00:14:21,440 --> 00:14:26,420
you derive a host of values like the

00:14:23,300 --> 00:14:28,790
modulus and which is P times Q is all

00:14:26,420 --> 00:14:31,490
the private exponent D which is the

00:14:28,790 --> 00:14:32,810
modular multiplicative inverse but again

00:14:31,490 --> 00:14:36,110
that's not a big deal in this particular

00:14:32,810 --> 00:14:37,640
case and various CRT coefficients CRT is

00:14:36,110 --> 00:14:40,160
the Chinese remainder theorem which

00:14:37,640 --> 00:14:42,230
provides means to highly accelerate the

00:14:40,160 --> 00:14:43,370
operations in RSA they're not required

00:14:42,230 --> 00:14:45,170
but there's the sort of thing that any

00:14:43,370 --> 00:14:46,459
serious RSA implementation will actually

00:14:45,170 --> 00:14:48,350
have and it turns out that they

00:14:46,459 --> 00:14:50,060
themselves are vulnerable to all sorts

00:14:48,350 --> 00:14:52,040
of things like fault attacks that allow

00:14:50,060 --> 00:14:54,430
partial prime with private key recovery

00:14:52,040 --> 00:14:57,610
and all sorts of other terrible things

00:14:54,430 --> 00:14:59,839
so all those things are just in details

00:14:57,610 --> 00:15:02,000
incredibly important finicky details

00:14:59,839 --> 00:15:03,260
that you will get wrong and maybe I

00:15:02,000 --> 00:15:05,029
shouldn't have chosen RSA that were

00:15:03,260 --> 00:15:07,310
worst widely used crypto system in

00:15:05,029 --> 00:15:09,470
existence we didn't even talk about how

00:15:07,310 --> 00:15:10,490
I can't use RSA without special padding

00:15:09,470 --> 00:15:14,600
because it will kill everyone you've

00:15:10,490 --> 00:15:16,310
ever loved any hope to implement these

00:15:14,600 --> 00:15:17,000
equations in Python we really only need

00:15:16,310 --> 00:15:20,079
two things

00:15:17,000 --> 00:15:22,130
big integers and modular exponentiation

00:15:20,079 --> 00:15:23,750
big integers because of these frump

00:15:22,130 --> 00:15:25,190
really big numbers so we need our math

00:15:23,750 --> 00:15:28,060
library to let us make them that big

00:15:25,190 --> 00:15:28,060
without losing precision

00:15:30,210 --> 00:15:33,899
in fact if you look at these equations

00:15:31,410 --> 00:15:34,980
as I said previously you'll see that you

00:15:33,899 --> 00:15:37,279
can just convert everything into an

00:15:34,980 --> 00:15:39,899
energy value and you'll be fine

00:15:37,279 --> 00:15:41,580
modular exponentiation is maybe a little

00:15:39,899 --> 00:15:44,460
bit less obvious but if you look at the

00:15:41,580 --> 00:15:46,440
number above and imagine that being

00:15:44,460 --> 00:15:47,490
exponentiated your intuition likely

00:15:46,440 --> 00:15:49,830
suggests that this might be a

00:15:47,490 --> 00:15:54,290
performance problem what do you suppose

00:15:49,830 --> 00:15:56,310
the number here to the 65,535 might be

00:15:54,290 --> 00:15:58,500
suffice it to say that modular

00:15:56,310 --> 00:16:01,200
exponentiation makes it possible to make

00:15:58,500 --> 00:16:02,520
enormous numbers like this be

00:16:01,200 --> 00:16:04,260
exponentiating without the problem

00:16:02,520 --> 00:16:06,779
becoming computationally intractable I

00:16:04,260 --> 00:16:07,709
would like it noted that I resisted the

00:16:06,779 --> 00:16:09,209
urge to explain how to implement

00:16:07,709 --> 00:16:11,430
constant-time modular exponentiation

00:16:09,209 --> 00:16:12,899
with montgomery ladder here but never

00:16:11,430 --> 00:16:17,520
fear I put a link in the references at

00:16:12,899 --> 00:16:19,560
the end ok so we finally got into some

00:16:17,520 --> 00:16:21,540
actual Python here's what Lex looks like

00:16:19,560 --> 00:16:23,459
when you implement this in Python Python

00:16:21,540 --> 00:16:25,020
supports arbitrarily large integers so

00:16:23,459 --> 00:16:26,839
we're covered there and the built in POW

00:16:25,020 --> 00:16:30,300
function supports modular exponentiation

00:16:26,839 --> 00:16:31,529
job done although it looks like we still

00:16:30,300 --> 00:16:34,020
have a little bit of time left in this

00:16:31,529 --> 00:16:37,560
talks a lot so I guess I'll elaborate a

00:16:34,020 --> 00:16:38,880
bit the problem here and the problem in

00:16:37,560 --> 00:16:40,560
general with this sort of approach is

00:16:38,880 --> 00:16:41,700
that you need to avoid side-channel

00:16:40,560 --> 00:16:43,860
information leakage

00:16:41,700 --> 00:16:45,990
remember I said implementations require

00:16:43,860 --> 00:16:47,370
you to minimize the sort of information

00:16:45,990 --> 00:16:47,970
that anyone can get about the data

00:16:47,370 --> 00:16:49,830
that's in there

00:16:47,970 --> 00:16:51,930
well when performing modular

00:16:49,830 --> 00:16:53,610
exponentiation on large values you can

00:16:51,930 --> 00:16:55,680
leak information about those values via

00:16:53,610 --> 00:16:58,770
this timing variability cryptographic

00:16:55,680 --> 00:17:00,540
libraries in an ideal world and we do

00:16:58,770 --> 00:17:01,860
not live in an ideal world so let's just

00:17:00,540 --> 00:17:03,660
all take that for what it's worth

00:17:01,860 --> 00:17:05,819
carefully build their mathematical

00:17:03,660 --> 00:17:07,319
operations to be constant time

00:17:05,819 --> 00:17:10,230
this means that different data inputs

00:17:07,319 --> 00:17:12,720
given the same length input do not take

00:17:10,230 --> 00:17:15,569
varying amounts of time to process this

00:17:12,720 --> 00:17:17,850
is both difficult to do and not ideal

00:17:15,569 --> 00:17:19,470
for non cryptographic applications after

00:17:17,850 --> 00:17:22,350
all normally you want something as

00:17:19,470 --> 00:17:23,819
complete as fast as possible right you

00:17:22,350 --> 00:17:25,140
don't want it to take longer all the

00:17:23,819 --> 00:17:26,929
time just because a few potential

00:17:25,140 --> 00:17:29,160
operations might be slower than others

00:17:26,929 --> 00:17:31,710
since Python is meant for far more than

00:17:29,160 --> 00:17:33,720
just cryptography its mod X its mod X

00:17:31,710 --> 00:17:36,030
that's just the short way of saying

00:17:33,720 --> 00:17:37,410
modular exponentiation is not written to

00:17:36,030 --> 00:17:39,600
be constant time and so unfortunately

00:17:37,410 --> 00:17:41,160
our elegant RSA implementation here

00:17:39,600 --> 00:17:43,020
using POW is vulnerable to timing

00:17:41,160 --> 00:17:46,600
attacks

00:17:43,020 --> 00:17:48,430
okay so we can't use pal this road

00:17:46,600 --> 00:17:51,610
surely leads somewhere good so let's

00:17:48,430 --> 00:17:54,010
write it ourselves are we going to use

00:17:51,610 --> 00:17:55,630
pythons integers why not they support

00:17:54,010 --> 00:17:57,130
arbitrarily large values which is good

00:17:55,630 --> 00:18:06,480
since for RSA we want these giant

00:17:57,130 --> 00:18:08,800
numbers what's that sign exactly

00:18:06,480 --> 00:18:10,750
unfortunately we can't reasonably access

00:18:08,800 --> 00:18:13,000
the underlying representation of the big

00:18:10,750 --> 00:18:14,980
engineers in Python right Python has an

00:18:13,000 --> 00:18:17,110
underlying mathematical representation

00:18:14,980 --> 00:18:19,150
of what those big big integers are it is

00:18:17,110 --> 00:18:21,310
some allocation of memory that allows

00:18:19,150 --> 00:18:23,170
you to do things within that context but

00:18:21,310 --> 00:18:25,120
we can't access that data from the

00:18:23,170 --> 00:18:26,470
Python side so we're gonna have to

00:18:25,120 --> 00:18:27,790
implement our own mug if we want to

00:18:26,470 --> 00:18:29,770
implement our own modular exponentiation

00:18:27,790 --> 00:18:31,900
we'll need to write our own big int as

00:18:29,770 --> 00:18:33,880
well this may be doable

00:18:31,900 --> 00:18:35,530
although anything you write is executing

00:18:33,880 --> 00:18:36,850
in the Python interpreter so you'll have

00:18:35,530 --> 00:18:38,530
to be careful to avoid all the various

00:18:36,850 --> 00:18:40,330
ways Python may helpfully make your

00:18:38,530 --> 00:18:43,120
apparently branch free code branchy or

00:18:40,330 --> 00:18:44,380
data dependent at this point we've

00:18:43,120 --> 00:18:49,500
strayed pretty far from things Python

00:18:44,380 --> 00:18:52,090
gives us but no matter what a cute dog

00:18:49,500 --> 00:18:54,880
that's probably not a metaphor for the

00:18:52,090 --> 00:18:56,320
situation we find ourselves in assuming

00:18:54,880 --> 00:18:58,450
you manage to build a python-based big

00:18:56,320 --> 00:18:59,940
and modular exponentiation system you

00:18:58,450 --> 00:19:02,170
may now think your problems are solved

00:18:59,940 --> 00:19:04,570
except what about the way python

00:19:02,170 --> 00:19:05,980
allocates memory you can't use byte

00:19:04,570 --> 00:19:08,020
strings because they're immutable

00:19:05,980 --> 00:19:09,700
except of course secretly as performance

00:19:08,020 --> 00:19:10,470
optimizations sometimes they're not in C

00:19:09,700 --> 00:19:12,850
Python

00:19:10,470 --> 00:19:14,740
additionally Python allocates memory and

00:19:12,850 --> 00:19:16,570
large blocks that it gets from the

00:19:14,740 --> 00:19:18,610
operating system this is called slab

00:19:16,570 --> 00:19:20,770
allocation and then it hands those

00:19:18,610 --> 00:19:23,020
pieces out to Python objects as needed

00:19:20,770 --> 00:19:24,610
this is normally fine and in fact it can

00:19:23,020 --> 00:19:26,740
be a performance optimization in certain

00:19:24,610 --> 00:19:28,210
cases but it means is extremely

00:19:26,740 --> 00:19:30,820
difficult to control where copies of

00:19:28,210 --> 00:19:32,110
sensitive data may reside in memory just

00:19:30,820 --> 00:19:33,700
because you let a variable go out of

00:19:32,110 --> 00:19:35,440
scope doesn't mean that memory has been

00:19:33,700 --> 00:19:36,880
zeroed in fact Python does not zero

00:19:35,440 --> 00:19:38,380
memory by default it just throws it back

00:19:36,880 --> 00:19:42,280
into the slab and then you can just get

00:19:38,380 --> 00:19:43,900
another allocation later and Python

00:19:42,280 --> 00:19:46,270
provides no tools for preventing parts

00:19:43,900 --> 00:19:48,070
of memory from being written to swamp in

00:19:46,270 --> 00:19:49,780
C you would use a tool called n lock to

00:19:48,070 --> 00:19:51,220
prevent this now some of this is a

00:19:49,780 --> 00:19:52,580
little bit esoteric at this point

00:19:51,220 --> 00:19:54,259
because a lot of the time you end up

00:19:52,580 --> 00:19:56,779
encrypted swap partitions and other

00:19:54,259 --> 00:19:58,459
things but we're talking strictly in the

00:19:56,779 --> 00:19:59,629
in the realm of what this language gives

00:19:58,459 --> 00:20:03,679
us to prevent us from shooting ourselves

00:19:59,629 --> 00:20:05,299
in the foot so so let's now hand wave

00:20:03,679 --> 00:20:08,179
away everything we've talked about we've

00:20:05,299 --> 00:20:12,049
solved it this all works in Python is it

00:20:08,179 --> 00:20:13,129
production-ready now well still know the

00:20:12,049 --> 00:20:15,919
implementation you've just built is

00:20:13,129 --> 00:20:18,799
going to be extraordinarily slow orders

00:20:15,919 --> 00:20:20,209
of magnitude perhaps five or six orders

00:20:18,799 --> 00:20:24,769
of magnitude faster than the past as

00:20:20,209 --> 00:20:26,779
implementations that exists dope all

00:20:24,769 --> 00:20:28,669
right so this set of problems exists for

00:20:26,779 --> 00:20:29,929
most cryptographic primitives if you try

00:20:28,669 --> 00:20:32,779
and implement them in pure Python it is

00:20:29,929 --> 00:20:34,219
not strictly an RSA problem in fact some

00:20:32,779 --> 00:20:36,379
things are even worse since Python has

00:20:34,219 --> 00:20:37,969
no native way to take advantage of Sim D

00:20:36,379 --> 00:20:40,999
or hardware accelerated instruction sets

00:20:37,969 --> 00:20:43,489
like AES and I PCL no Q to Q and it's at

00:20:40,999 --> 00:20:47,419
etcetera etc but is this really an issue

00:20:43,489 --> 00:20:50,169
let's ask a scientist so professor would

00:20:47,419 --> 00:20:54,409
you say it's time for everyone to panic

00:20:50,169 --> 00:20:58,579
yes I would can so insert your asks

00:20:54,409 --> 00:20:59,839
essential screens here or instead of

00:20:58,579 --> 00:21:01,309
panicking we could figure out which of

00:20:59,839 --> 00:21:05,509
these threats metals matters for your

00:21:01,309 --> 00:21:07,519
use case we've talked a great deal about

00:21:05,509 --> 00:21:09,259
how python is bad at protecting against

00:21:07,519 --> 00:21:11,929
various forms of information leakage in

00:21:09,259 --> 00:21:13,249
that example this may this may make you

00:21:11,929 --> 00:21:14,570
wonder why this fool of a speaker

00:21:13,249 --> 00:21:15,799
started to talk by explaining that he

00:21:14,570 --> 00:21:18,619
works on multiple Python cryptographic

00:21:15,799 --> 00:21:19,999
libraries it's a fair criticism but

00:21:18,619 --> 00:21:21,559
we'll get there shortly

00:21:19,999 --> 00:21:23,329
first of all when you're establishing

00:21:21,559 --> 00:21:24,649
what matters threat modeling your

00:21:23,329 --> 00:21:26,809
application can tell you what you should

00:21:24,649 --> 00:21:28,369
consider in scope as a threat there's a

00:21:26,809 --> 00:21:29,809
talk today at 4:00 p.m. in this room

00:21:28,369 --> 00:21:31,789
about threat modeling the Deathstar

00:21:29,809 --> 00:21:32,749
so if you're not familiar with threat

00:21:31,789 --> 00:21:33,979
modeling you should definitely stick

00:21:32,749 --> 00:21:35,869
around for that there's a variety of

00:21:33,979 --> 00:21:36,950
methods that people use and there's a

00:21:35,869 --> 00:21:39,559
specific one that they're going to go

00:21:36,950 --> 00:21:40,909
through and that talk I highly recommend

00:21:39,559 --> 00:21:42,499
knowing something about how threat

00:21:40,909 --> 00:21:44,659
modeling works it can be very dry but

00:21:42,499 --> 00:21:45,619
it's also just absurdly valuable for

00:21:44,659 --> 00:21:47,869
understanding the security of your

00:21:45,619 --> 00:21:49,579
application so in a highly simplified

00:21:47,869 --> 00:21:51,889
form your threat model may determine

00:21:49,579 --> 00:21:55,219
that the particular use case that you

00:21:51,889 --> 00:21:57,349
have asymmetric encryption does not need

00:21:55,219 --> 00:21:59,289
side-channel protection and thus a pure

00:21:57,349 --> 00:22:01,219
Python solution may actually make sense

00:21:59,289 --> 00:22:02,749
similarly it's possible that both

00:22:01,219 --> 00:22:04,070
performance and side-channel concerns

00:22:02,749 --> 00:22:05,110
don't matter if you're implementing

00:22:04,070 --> 00:22:08,080
something like an offline

00:22:05,110 --> 00:22:10,120
signing system I would love to give

00:22:08,080 --> 00:22:12,100
specific advice here for all possible

00:22:10,120 --> 00:22:14,170
scenarios but cryptography is a nuanced

00:22:12,100 --> 00:22:15,880
discipline and what's secure in one

00:22:14,170 --> 00:22:19,090
situation may be catastrophic ly broken

00:22:15,880 --> 00:22:20,650
in another however when in doubt err on

00:22:19,090 --> 00:22:27,940
the side of using pythons most

00:22:20,650 --> 00:22:31,660
powerfully feature calling the C API all

00:22:27,940 --> 00:22:34,030
right so Python has a rich Fi two

00:22:31,660 --> 00:22:36,340
languages that speak the CA by CA bi

00:22:34,030 --> 00:22:38,440
through CF fi at c-- types and a few

00:22:36,340 --> 00:22:40,960
other tools that allow Python codes to

00:22:38,440 --> 00:22:42,820
leverage this kind of native code this

00:22:40,960 --> 00:22:45,160
brief bridge gives access to every

00:22:42,820 --> 00:22:46,240
feature needed for safe cryptography as

00:22:45,160 --> 00:22:47,980
well as allowing the construction of

00:22:46,240 --> 00:22:50,320
pythonic api's on top of difficult to

00:22:47,980 --> 00:22:51,730
use cryptographic libraries there is

00:22:50,320 --> 00:22:53,890
almost no chance that you are not

00:22:51,730 --> 00:22:56,590
constantly using C when you're writing

00:22:53,890 --> 00:22:59,530
python be that data science be that

00:22:56,590 --> 00:23:01,270
cryptography in general that is a very

00:22:59,530 --> 00:23:03,669
very common thing to see inside the

00:23:01,270 --> 00:23:05,110
context of python it's also the way that

00:23:03,669 --> 00:23:06,400
people end up trying to make it go fast

00:23:05,110 --> 00:23:08,830
when they need the things to be faster

00:23:06,400 --> 00:23:10,299
so almost every serious Python

00:23:08,830 --> 00:23:12,340
cryptographic library is built in this

00:23:10,299 --> 00:23:14,860
fashion the SSL module and standard

00:23:12,340 --> 00:23:17,380
library uses open a Cell cryptography

00:23:14,860 --> 00:23:19,960
itself uses cryptography the library not

00:23:17,380 --> 00:23:23,100
the discipline I apologize we named it

00:23:19,960 --> 00:23:26,410
poorly it uses open SSL BSC FF I

00:23:23,100 --> 00:23:28,960
pineapple uses Lib sodium via CFIB crypt

00:23:26,410 --> 00:23:32,470
uses code that's extracted from open BSD

00:23:28,960 --> 00:23:34,299
etc etc pure Python cryptographic

00:23:32,470 --> 00:23:35,620
libraries do exist but their use is

00:23:34,299 --> 00:23:37,240
typically predicated on deployment

00:23:35,620 --> 00:23:39,460
environments where compiled modules are

00:23:37,240 --> 00:23:41,110
difficult to use this is partially an

00:23:39,460 --> 00:23:43,059
artifact of Python spotty history with

00:23:41,110 --> 00:23:44,350
precompiled binaries in the past several

00:23:43,059 --> 00:23:45,820
years the situation has gotten much

00:23:44,350 --> 00:23:47,710
better with wheels but some challenges

00:23:45,820 --> 00:23:50,080
still remain you can check out olanta

00:23:47,710 --> 00:23:51,790
hash bins talk the black magic of Python

00:23:50,080 --> 00:23:53,799
wheels which was given at PyCon us this

00:23:51,790 --> 00:23:55,690
year or my own much more out of date

00:23:53,799 --> 00:23:58,780
reliably distributing binary modules

00:23:55,690 --> 00:24:01,150
which was given in 2016 for more

00:23:58,780 --> 00:24:03,040
information about these challenges for

00:24:01,150 --> 00:24:03,940
this reason Wi-Fi based cryptography is

00:24:03,040 --> 00:24:06,130
the best answer

00:24:03,940 --> 00:24:07,360
in rare cases it may not be practical

00:24:06,130 --> 00:24:11,230
depending upon your specific deployment

00:24:07,360 --> 00:24:12,520
needs F of I based cryptography has one

00:24:11,230 --> 00:24:13,929
other significant disadvantage that I

00:24:12,520 --> 00:24:15,669
would be remiss if I didn't point out

00:24:13,929 --> 00:24:17,830
since these libraries are typically

00:24:15,669 --> 00:24:18,040
written and see the potential for memory

00:24:17,830 --> 00:24:20,710
and

00:24:18,040 --> 00:24:22,510
safety exists within them it is possible

00:24:20,710 --> 00:24:23,980
to use fi with it with other languages

00:24:22,510 --> 00:24:26,530
such as rust which allows you to compile

00:24:23,980 --> 00:24:28,410
to a CA di but unfortunately the tool

00:24:26,530 --> 00:24:30,660
chains and libraries available are not

00:24:28,410 --> 00:24:32,620
it's widely available and it's not

00:24:30,660 --> 00:24:34,270
basically that the community knowledge

00:24:32,620 --> 00:24:36,760
isn't quite there yet so most of the

00:24:34,270 --> 00:24:37,990
time we're still stuck with Si in

00:24:36,760 --> 00:24:39,550
general the risk of this sort of

00:24:37,990 --> 00:24:40,900
behavior is significantly mitigated

00:24:39,550 --> 00:24:42,460
because you're not directly interacting

00:24:40,900 --> 00:24:44,860
with that library instead the Python

00:24:42,460 --> 00:24:47,380
library you've chosen is wrapping this

00:24:44,860 --> 00:24:49,390
things around wrapping all its magic

00:24:47,380 --> 00:24:50,650
around it right so you've got they there

00:24:49,390 --> 00:24:52,870
that libraries can be responsible for

00:24:50,650 --> 00:24:54,970
allocating the buffers initializing the

00:24:52,870 --> 00:24:56,970
data structures etc but sometimes

00:24:54,970 --> 00:24:58,930
programmers even cryptographic engineers

00:24:56,970 --> 00:25:02,980
perhaps especially cryptographic

00:24:58,930 --> 00:25:04,870
engineers make mistakes the reality of

00:25:02,980 --> 00:25:06,340
low-level Python cryptographic library

00:25:04,870 --> 00:25:08,680
development is that we essentially write

00:25:06,340 --> 00:25:11,550
C in Python and try to wrap the most

00:25:08,680 --> 00:25:14,170
pythonic api's we can so that on top you

00:25:11,550 --> 00:25:16,660
brought the most of pythonic api as we

00:25:14,170 --> 00:25:17,920
can on top so that you the user don't

00:25:16,660 --> 00:25:23,200
have to know what terrible things that

00:25:17,920 --> 00:25:25,720
lurk between at the service so finally a

00:25:23,200 --> 00:25:27,460
quick word on memory if your threat

00:25:25,720 --> 00:25:28,690
model encompasses memory disclosure then

00:25:27,460 --> 00:25:30,580
one of the most common goals is to

00:25:28,690 --> 00:25:33,160
minimize the time a particular secret is

00:25:30,580 --> 00:25:36,310
resident in memory in python this means

00:25:33,160 --> 00:25:38,440
you can't use byte strings that's really

00:25:36,310 --> 00:25:39,820
what it means which is unfortunate

00:25:38,440 --> 00:25:42,010
because there's no way to control the

00:25:39,820 --> 00:25:43,840
zeroing instead you're gonna be forced

00:25:42,010 --> 00:25:45,300
to use byte arrays or other mutable

00:25:43,840 --> 00:25:47,860
objects that support the buffer protocol

00:25:45,300 --> 00:25:49,300
if you find yourself in this situation I

00:25:47,860 --> 00:25:51,190
highly recommend writing a context

00:25:49,300 --> 00:25:52,900
manager to autozero the byte arrays when

00:25:51,190 --> 00:25:54,370
you're done with it cryptography

00:25:52,900 --> 00:25:56,320
supports passing of these types of

00:25:54,370 --> 00:25:57,940
buffers in almost every API and I think

00:25:56,320 --> 00:25:59,200
that might be the only truly actionable

00:25:57,940 --> 00:26:05,200
advice I've given you too so hooray

00:25:59,200 --> 00:26:06,910
oh hey we've seen this slide before so

00:26:05,200 --> 00:26:09,370
secure cryptography is possible in

00:26:06,910 --> 00:26:10,750
Python it does frequently mean that

00:26:09,370 --> 00:26:11,920
Python is what you use to call some

00:26:10,750 --> 00:26:13,930
underlying native code

00:26:11,920 --> 00:26:16,420
now that the cryptographic code itself

00:26:13,930 --> 00:26:18,370
is in Python and threat models are

00:26:16,420 --> 00:26:20,440
critical when you're building secure

00:26:18,370 --> 00:26:22,090
software you're always choosing

00:26:20,440 --> 00:26:24,070
trade-offs so you need to carefully

00:26:22,090 --> 00:26:26,050
consider what you do and do not consider

00:26:24,070 --> 00:26:28,150
to be worth protecting against you

00:26:26,050 --> 00:26:30,190
cannot do everything not with unlimited

00:26:28,150 --> 00:26:33,050
money and certainly not with the amount

00:26:30,190 --> 00:26:35,590
of money that normal people have

00:26:33,050 --> 00:26:37,580
so here the references I promised you I

00:26:35,590 --> 00:26:40,760
there's a variety of things that are

00:26:37,580 --> 00:26:44,450
that run the gamut from profanity-laden

00:26:40,760 --> 00:26:46,220
rants about RSA to the actual first

00:26:44,450 --> 00:26:47,780
paper that talked about what a constant

00:26:46,220 --> 00:26:49,850
time montgomery ladder would be which is

00:26:47,780 --> 00:26:53,420
the squaring an exponential squaring

00:26:49,850 --> 00:26:55,190
method there's a there's a set of people

00:26:53,420 --> 00:26:57,110
who I work with who complain about

00:26:55,190 --> 00:26:58,970
memory on safety on Twitter that I would

00:26:57,110 --> 00:27:02,360
love for you to follow and information

00:26:58,970 --> 00:27:03,860
about Python wheels thank you very much

00:27:02,360 --> 00:27:05,420
for coming I'm happy to take questions

00:27:03,860 --> 00:27:06,680
although I will take this quick

00:27:05,420 --> 00:27:08,060
opportunity to mine people that

00:27:06,680 --> 00:27:09,620
questions have an upward inflection at

00:27:08,060 --> 00:27:11,210
the end and require a response from me

00:27:09,620 --> 00:27:12,410
if you don't have those two things it's

00:27:11,210 --> 00:27:15,460
probably an angry tweet you should

00:27:12,410 --> 00:27:15,460
direct at that Twitter handle

00:27:17,920 --> 00:27:24,410
thank you very much enjoy your mug so do

00:27:23,030 --> 00:27:28,220
we have any questions we can probably

00:27:24,410 --> 00:27:31,570
fit in maybe two or three or they all

00:27:28,220 --> 00:27:37,970
too hard and no one wants to ask them

00:27:31,570 --> 00:27:39,890
nothing at all all right then oh you

00:27:37,970 --> 00:27:42,050
said don't use RSA so what should we use

00:27:39,890 --> 00:27:43,850
instead so it depends upon your specific

00:27:42,050 --> 00:27:46,610
use case but in general the answer would

00:27:43,850 --> 00:27:49,010
be if you can and you don't have weird

00:27:46,610 --> 00:27:52,520
US government restrictions you should be

00:27:49,010 --> 00:27:54,410
using like twisted Edwards 20250 982 509

00:27:52,520 --> 00:27:56,360
for signatures and for encryption you

00:27:54,410 --> 00:27:58,160
should be using its construction called

00:27:56,360 --> 00:28:00,980
EC IES which is at lip to curve

00:27:58,160 --> 00:28:04,190
integrative encryption systems so that's

00:28:00,980 --> 00:28:06,580
those both have less probability of

00:28:04,190 --> 00:28:09,160
screwing up although not zero but the

00:28:06,580 --> 00:28:12,590
general trajectory of cryptographic

00:28:09,160 --> 00:28:15,260
algorithms in this world right now is we

00:28:12,590 --> 00:28:16,730
try and build algorithms themselves that

00:28:15,260 --> 00:28:17,960
are harder to miss implement and then we

00:28:16,730 --> 00:28:20,630
try and build api's that are harder to

00:28:17,960 --> 00:28:23,540
misuse and so we're getting there slowly

00:28:20,630 --> 00:28:30,830
but RSA represents the state of the art

00:28:23,540 --> 00:28:33,160
of the 1970s any last question before we

00:28:30,830 --> 00:28:33,160
go

00:28:36,320 --> 00:28:41,299
do you ever consider a quantum computing

00:28:38,600 --> 00:28:44,419
when you're building like for future

00:28:41,299 --> 00:28:45,950
security so I hate always saying it

00:28:44,419 --> 00:28:47,210
depends on your threat model yes

00:28:45,950 --> 00:28:48,980
sometimes you do have to care about that

00:28:47,210 --> 00:28:50,390
now so it becomes a question of whether

00:28:48,980 --> 00:28:52,220
or not you care about nation-state

00:28:50,390 --> 00:28:54,200
actors and it becomes a question about

00:28:52,220 --> 00:28:57,080
how long you care about your data

00:28:54,200 --> 00:28:59,690
remaining secure so like in the case

00:28:57,080 --> 00:29:02,179
like if you imagine a hypothetical case

00:28:59,690 --> 00:29:03,590
where you have a cut somebody who very

00:29:02,179 --> 00:29:05,720
deeply cares about having something

00:29:03,590 --> 00:29:06,950
remain secure for communication for the

00:29:05,720 --> 00:29:09,500
next 50 years because they're dropping a

00:29:06,950 --> 00:29:11,840
buoy at the bottom of the ocean then

00:29:09,500 --> 00:29:14,240
they may get very much care about being

00:29:11,840 --> 00:29:17,600
able to do what we know is post quantum

00:29:14,240 --> 00:29:19,190
secure algorithms most efficient post

00:29:17,600 --> 00:29:22,789
quantum secure algorithms are currently

00:29:19,190 --> 00:29:23,929
very inefficient space wise so basically

00:29:22,789 --> 00:29:25,700
if we if we have a belief in their

00:29:23,929 --> 00:29:28,250
security then they kind of suck to use

00:29:25,700 --> 00:29:29,630
and so there's most of the research

00:29:28,250 --> 00:29:31,250
right now is around trying to make them

00:29:29,630 --> 00:29:33,140
much more efficient so that you can have

00:29:31,250 --> 00:29:34,880
them in a single round trip of a TCP

00:29:33,140 --> 00:29:35,960
connection or things of that nature if

00:29:34,880 --> 00:29:37,460
you don't have those restrictions then

00:29:35,960 --> 00:29:39,260
there are actually decent things that

00:29:37,460 --> 00:29:43,309
they're usually hash-based that you can

00:29:39,260 --> 00:29:44,690
use right now so there are two more that

00:29:43,309 --> 00:29:48,010
I'm gonna squeeze in and then we all

00:29:44,690 --> 00:29:48,010
have to go so Sara can set up

00:29:48,020 --> 00:29:52,970
you mentioned rust not being ready yet

00:29:50,059 --> 00:29:54,740
is that a lack of crypto libraries on

00:29:52,970 --> 00:29:57,679
the rust side or issues with the

00:29:54,740 --> 00:29:59,149
bindings into Python so rust itself I

00:29:57,679 --> 00:30:01,429
would say is actually very much ready as

00:29:59,149 --> 00:30:04,520
a language it's the world that needs to

00:30:01,429 --> 00:30:06,740
catch up so the being able to invoke

00:30:04,520 --> 00:30:08,600
rust from Python not a problem although

00:30:06,740 --> 00:30:10,399
just utils setup tools don't give you

00:30:08,600 --> 00:30:13,159
rust see stuff for free the way that you

00:30:10,399 --> 00:30:15,590
get that on from GCC clang and so that's

00:30:13,159 --> 00:30:17,149
a little bit of the issue the other part

00:30:15,590 --> 00:30:18,710
of the issue is yes that the like we

00:30:17,149 --> 00:30:20,210
have cryptographic libraries we've been

00:30:18,710 --> 00:30:23,110
building for 25 years that even though

00:30:20,210 --> 00:30:25,399
they have terrible api's have a lot of

00:30:23,110 --> 00:30:26,539
battle testing around them and that

00:30:25,399 --> 00:30:28,370
there's things that we're actually

00:30:26,539 --> 00:30:30,950
willing to trust at least the base level

00:30:28,370 --> 00:30:32,149
cryptographic algorithms we trust and on

00:30:30,950 --> 00:30:34,580
the rust side there's not a lot of that

00:30:32,149 --> 00:30:36,890
just yet it's getting there very rapidly

00:30:34,580 --> 00:30:39,679
but you also have to overcome the

00:30:36,890 --> 00:30:41,210
entrenched opposition of what's appear

00:30:39,679 --> 00:30:42,590
to be millions of programmers who think

00:30:41,210 --> 00:30:45,279
that if you just think really hard you

00:30:42,590 --> 00:30:45,279
can write C well

00:30:45,590 --> 00:30:51,300
so turns out the last question was the

00:30:47,940 --> 00:30:53,800
same question so thank you again to Paul

00:30:51,300 --> 00:30:57,430
and we're going to set Sarah up next

00:30:53,800 --> 00:30:57,430

YouTube URL: https://www.youtube.com/watch?v=HQ5lG-1-c3k


