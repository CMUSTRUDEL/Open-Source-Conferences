Title: "You don't always need NumPy" - Sam Hames (PyCon AU 2019)
Publication date: 2019-08-02
Playlist: PyCon Australia 2019
Description: 
	Sam Hames

The numerical Python ecosystem and communities are mature and powerful, but sometimes we can be too quick to reach for the numerical hammer when simpler options exist. This talk will outline some areas where the numerical stack may not be the best starting point, and survey some alternatives.

https://2019.pycon-au.org/talks/you-dont-always-need-numpy

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 2 - 6 2019.

Video licence: CC BY-NC-SA 4.0 - https://creativecommons.org/licenses/by-nc-sa/4.0/

Python, PyCon, PyConAU

Fri Aug  2 09:30:00 2019 at C3.6
Captions: 
	00:00:00,000 --> 00:00:05,549
marry one to the science and data track

00:00:02,040 --> 00:00:07,500
cap icon just we expect this room to get

00:00:05,549 --> 00:00:10,080
pretty full today so if you could move

00:00:07,500 --> 00:00:11,580
inwards towards the edge of the arm so

00:00:10,080 --> 00:00:13,110
people can actually come and grab a seat

00:00:11,580 --> 00:00:17,039
or not climb over you that would be

00:00:13,110 --> 00:00:18,900
great thank you if you're at the back

00:00:17,039 --> 00:00:20,789
looking for seats we've got a nearly a

00:00:18,900 --> 00:00:28,590
whole roll row free at the front still

00:00:20,789 --> 00:00:30,300
oh thank you

00:00:28,590 --> 00:00:31,730
so we've got a great day plan today

00:00:30,300 --> 00:00:35,790
we've got ten different speakers

00:00:31,730 --> 00:00:37,110
throughout the day and so first up we

00:00:35,790 --> 00:00:40,260
have Sam Haines

00:00:37,110 --> 00:00:42,840
he's a software developer at qts digital

00:00:40,260 --> 00:00:44,489
Observatory he works with Python at the

00:00:42,840 --> 00:00:48,059
intersection of the web data and

00:00:44,489 --> 00:00:51,059
analytics he started a PhD and he might

00:00:48,059 --> 00:00:54,329
finish it one day but he's talking about

00:00:51,059 --> 00:00:56,760
why you don't always need numpy so it's

00:00:54,329 --> 00:01:04,769
controversial maybe about looking

00:00:56,760 --> 00:01:07,560
forward to it thank you Sam I hope this

00:01:04,769 --> 00:01:09,119
isn't controversial I was aiming I was

00:01:07,560 --> 00:01:11,400
working very very hard to make sure it

00:01:09,119 --> 00:01:15,420
wasn't controversial little suggestions

00:01:11,400 --> 00:01:17,460
little things little changes so yeah

00:01:15,420 --> 00:01:19,380
that's all you don't always need numpy

00:01:17,460 --> 00:01:21,780
or sci-fi or tensorflow are pandas or

00:01:19,380 --> 00:01:22,920
all of the other very very exciting

00:01:21,780 --> 00:01:25,140
things that are happening in the

00:01:22,920 --> 00:01:26,820
numerical Python community every time I

00:01:25,140 --> 00:01:28,470
look up something there's a link to some

00:01:26,820 --> 00:01:31,470
other package I've never seen before and

00:01:28,470 --> 00:01:33,240
I'm like oh that looks cool what does

00:01:31,470 --> 00:01:35,070
this do and then I'm looking at the X or

00:01:33,240 --> 00:01:36,990
a dogs and wondering maybe I should

00:01:35,070 --> 00:01:41,280
refactor some stuff and then three hours

00:01:36,990 --> 00:01:44,520
it going this talk is also a bit of a

00:01:41,280 --> 00:01:46,920
reflection for me because I first used

00:01:44,520 --> 00:01:49,439
Python 12 years ago now it was in the

00:01:46,920 --> 00:01:51,689
university course the course was about

00:01:49,439 --> 00:01:53,820
numerical simulation so my entries to

00:01:51,689 --> 00:01:55,500
Python was numerical Python it was

00:01:53,820 --> 00:01:57,119
solving ordinary differential equations

00:01:55,500 --> 00:01:59,100
and partial differential equations in

00:01:57,119 --> 00:02:01,110
bayson that's where I started Python

00:01:59,100 --> 00:02:04,560
done a lot of other things since then

00:02:01,110 --> 00:02:07,439
and I still use numerical stuff within

00:02:04,560 --> 00:02:08,879
Python but this talk has been a bit of

00:02:07,439 --> 00:02:10,229
Earth has ended up being a bit of

00:02:08,879 --> 00:02:13,080
reflection on that time and some of the

00:02:10,229 --> 00:02:13,920
things I've learned so I want to start

00:02:13,080 --> 00:02:16,920
wait

00:02:13,920 --> 00:02:20,370
stating two things which I hope they're

00:02:16,920 --> 00:02:22,650
not controversial or the first one is an

00:02:20,370 --> 00:02:24,780
approximation so if the first is that

00:02:22,650 --> 00:02:26,610
number I when I say numpy I'm gonna say

00:02:24,780 --> 00:02:28,260
numb by a numerical Python ecosystem

00:02:26,610 --> 00:02:31,230
interchangeably which isn't really

00:02:28,260 --> 00:02:35,040
accurate but for the purposes of this

00:02:31,230 --> 00:02:37,110
talk just imagine they're the same the

00:02:35,040 --> 00:02:39,420
second thing is that numerical Python is

00:02:37,110 --> 00:02:41,370
a subset of Python the Python is not one

00:02:39,420 --> 00:02:43,050
community it's many communities and they

00:02:41,370 --> 00:02:46,290
tend to overlap there's we there's lots

00:02:43,050 --> 00:02:47,820
of stuff going on so one of the things

00:02:46,290 --> 00:02:49,560
we should remember is that numerical

00:02:47,820 --> 00:02:51,030
pipe the whole world is not numerical

00:02:49,560 --> 00:02:59,160
pythons there's other things going on in

00:02:51,030 --> 00:03:01,350
Python too so one of the I think when

00:02:59,160 --> 00:03:03,810
you're working on numerical computation

00:03:01,350 --> 00:03:06,090
and stuff it's very very easy to get

00:03:03,810 --> 00:03:08,010
stuck where your whole world is a single

00:03:06,090 --> 00:03:09,120
equation it's the coursing at the middle

00:03:08,010 --> 00:03:10,650
of your problem it's the machine

00:03:09,120 --> 00:03:12,630
learning algorithm you're working on

00:03:10,650 --> 00:03:15,269
it's the ordinary differential equation

00:03:12,630 --> 00:03:17,250
you're solving this is a little bit

00:03:15,269 --> 00:03:19,380
myopic we get we it's very very easy to

00:03:17,250 --> 00:03:20,970
end up getting stuck just in that part

00:03:19,380 --> 00:03:22,290
of the problem for getting that you

00:03:20,970 --> 00:03:24,329
actually need to do a whole bunch of

00:03:22,290 --> 00:03:25,680
other stuff too like you've got a load

00:03:24,329 --> 00:03:27,840
data from disk at some point you've

00:03:25,680 --> 00:03:29,790
probably got some config files somewhere

00:03:27,840 --> 00:03:32,100
you might have different experimental

00:03:29,790 --> 00:03:35,040
settings you might need to do a whole

00:03:32,100 --> 00:03:36,630
bunch of other stuff besides that and

00:03:35,040 --> 00:03:38,160
then once you're done all the numerical

00:03:36,630 --> 00:03:39,480
stuff you probably have to make a chart

00:03:38,160 --> 00:03:42,030
or a graph all you need to write the

00:03:39,480 --> 00:03:44,190
results to a database or spit out a file

00:03:42,030 --> 00:03:48,570
to give to somebody else or a

00:03:44,190 --> 00:03:51,209
spreadsheet for somebody else so this

00:03:48,570 --> 00:03:57,269
isn't the whole world it's really this

00:03:51,209 --> 00:03:58,739
is the fun part even if you're lucky and

00:03:57,269 --> 00:04:01,049
you just get to worry about the numbers

00:03:58,739 --> 00:04:04,530
eventually somebody comes to you and

00:04:01,049 --> 00:04:06,209
makes you forces you out of that domain

00:04:04,530 --> 00:04:07,980
maybe you've built something useful in

00:04:06,209 --> 00:04:10,980
somebody says well can we have a Web API

00:04:07,980 --> 00:04:12,390
around that or maybe this time series

00:04:10,980 --> 00:04:13,769
prediction stuff is really cool let's

00:04:12,390 --> 00:04:16,530
build a interactive JavaScript

00:04:13,769 --> 00:04:19,169
visualization and run it daily and give

00:04:16,530 --> 00:04:22,530
it to somebody important to click on

00:04:19,169 --> 00:04:24,060
things when you hit a situation like

00:04:22,530 --> 00:04:26,010
this suddenly you've got more than one

00:04:24,060 --> 00:04:28,050
more than the numerical don't

00:04:26,010 --> 00:04:29,550
to worry about so when we're writing

00:04:28,050 --> 00:04:32,640
your miracle Python we need to remember

00:04:29,550 --> 00:04:34,020
that the rest of Python exists the rest

00:04:32,640 --> 00:04:39,900
of the world exists the rest of the

00:04:34,020 --> 00:04:41,580
problem also exists and as when we when

00:04:39,900 --> 00:04:43,920
we hit these other problem demands that

00:04:41,580 --> 00:04:46,560
we end up with a bit of friction I mean

00:04:43,920 --> 00:04:48,450
it could be as simple as you're used to

00:04:46,560 --> 00:04:50,190
working with Conda but the web service

00:04:48,450 --> 00:04:51,540
you need to integrate with all of their

00:04:50,190 --> 00:04:52,890
deployment pipeline uses Pip and

00:04:51,540 --> 00:04:57,870
suddenly you have to care about the

00:04:52,890 --> 00:04:59,880
differences between Pip and Conda the

00:04:57,870 --> 00:05:03,840
numerical Python stack tends to be very

00:04:59,880 --> 00:05:05,550
very complicated the packaging ecosystem

00:05:03,840 --> 00:05:07,320
has come a very very long way and it

00:05:05,550 --> 00:05:09,990
tends to be a lot smoother now than it

00:05:07,320 --> 00:05:11,760
used to be but the complexity is still

00:05:09,990 --> 00:05:13,770
there there's still new ways for things

00:05:11,760 --> 00:05:15,830
to break lots of things weird things can

00:05:13,770 --> 00:05:20,250
happen

00:05:15,830 --> 00:05:22,740
and on top of all of that numerical

00:05:20,250 --> 00:05:25,830
Python is a different idiom to other

00:05:22,740 --> 00:05:29,880
types of Python I remember the first

00:05:25,830 --> 00:05:31,440
time I I was at a job at my last job I

00:05:29,880 --> 00:05:33,150
was working with some very experienced

00:05:31,440 --> 00:05:36,780
developers who tend to focus on web

00:05:33,150 --> 00:05:41,370
problems i ported an algorithm that was

00:05:36,780 --> 00:05:43,320
plain old Python numpy so arrays instead

00:05:41,370 --> 00:05:45,360
of dictionaries and things like that I

00:05:43,320 --> 00:05:48,080
thought it was perfectly reasonable

00:05:45,360 --> 00:05:51,180
idiomatic numpy or a numerical Python I

00:05:48,080 --> 00:05:51,840
got some funny looks because it it was

00:05:51,180 --> 00:05:54,060
different

00:05:51,840 --> 00:05:56,250
it wasn't what they were used to like

00:05:54,060 --> 00:05:58,470
any numerical platform tends to be flat

00:05:56,250 --> 00:05:59,790
where like it's a different shape in the

00:05:58,470 --> 00:06:04,400
editor you look at it and good this is

00:05:59,790 --> 00:06:09,300
not what I'm used to I think a more

00:06:04,400 --> 00:06:11,250
fundamental problem is that the

00:06:09,300 --> 00:06:13,230
practical part of running computational

00:06:11,250 --> 00:06:15,030
stuff is hard so we spend a lot of time

00:06:13,230 --> 00:06:18,000
trying to squeeze our problem demands

00:06:15,030 --> 00:06:21,510
into to what we can actually do with our

00:06:18,000 --> 00:06:23,850
machine a lot of numerical workers well

00:06:21,510 --> 00:06:27,600
how do I actually represent this as an

00:06:23,850 --> 00:06:29,460
array what does this array mean so when

00:06:27,600 --> 00:06:31,140
you're working in the numerical Python

00:06:29,460 --> 00:06:33,750
lens you do have this you've got this

00:06:31,140 --> 00:06:35,970
conceptual stuff on top as well as well

00:06:33,750 --> 00:06:39,260
as all of the practical differences

00:06:35,970 --> 00:06:39,260
between different parts of Python

00:06:39,629 --> 00:06:46,389
for example so this is a in text

00:06:44,709 --> 00:06:48,489
analytics applications it's very common

00:06:46,389 --> 00:06:51,899
to use a bag of words representation so

00:06:48,489 --> 00:06:54,729
if we have a document which is a single

00:06:51,899 --> 00:06:57,159
phrase the cat sat on the mat a bag of

00:06:54,729 --> 00:06:58,689
words representation is we count the

00:06:57,159 --> 00:07:01,149
number of times each word occurs in the

00:06:58,689 --> 00:07:03,279
document and we represent those codes so

00:07:01,149 --> 00:07:07,389
we could do this in base Python as a

00:07:03,279 --> 00:07:09,909
dictionary so the occurs twice cat

00:07:07,389 --> 00:07:13,179
occurs once and so on if we try and

00:07:09,909 --> 00:07:15,579
represent this as an array we end up

00:07:13,179 --> 00:07:18,639
with a layer of indirection so in the

00:07:15,579 --> 00:07:20,919
array we have a convention that the 0th

00:07:18,639 --> 00:07:22,359
column represents the word the first

00:07:20,919 --> 00:07:23,889
column represents the word cat the

00:07:22,359 --> 00:07:26,199
second column represents the words that

00:07:23,889 --> 00:07:29,039
and so on so we need to maintain a

00:07:26,199 --> 00:07:31,089
lookup table between our numerical

00:07:29,039 --> 00:07:35,139
representation of the problem and our

00:07:31,089 --> 00:07:40,389
actual problem domain so in this case

00:07:35,139 --> 00:07:42,069
like I'm not gonna care that columns 673

00:07:40,389 --> 00:07:43,389
is something meaningful in this data set

00:07:42,069 --> 00:07:46,769
I want to know what it actually means in

00:07:43,389 --> 00:07:46,769
terms of the documents that I'm studying

00:07:50,219 --> 00:07:58,739
so given that I'm gonna make five small

00:07:55,239 --> 00:08:01,839
suggestions I'm gonna state upfront that

00:07:58,739 --> 00:08:03,909
the keyword is you don't always need an

00:08:01,839 --> 00:08:05,319
umpire you can want it there are some

00:08:03,909 --> 00:08:07,809
very good reasons to use it and there

00:08:05,319 --> 00:08:11,379
are lots of problems where it would be

00:08:07,809 --> 00:08:13,869
ridiculous not to use it but numpy isn't

00:08:11,379 --> 00:08:15,519
everything so I'm gonna make these

00:08:13,869 --> 00:08:17,139
suggestions in the context that maybe

00:08:15,519 --> 00:08:19,229
they'll help you make things a little

00:08:17,139 --> 00:08:21,699
bit easier for yourself they'll make you

00:08:19,229 --> 00:08:23,439
your work a little bit faster a little

00:08:21,699 --> 00:08:27,899
bit easier to explain to other people a

00:08:23,439 --> 00:08:27,899
little bit easier to work across domains

00:08:29,639 --> 00:08:34,779
and of course like any suggestion you

00:08:33,219 --> 00:08:36,759
should take them with a grain of salt

00:08:34,779 --> 00:08:38,679
pay attention to your particular context

00:08:36,759 --> 00:08:41,249
your particular team your particular

00:08:38,679 --> 00:08:41,249
problem

00:08:42,630 --> 00:08:48,160
so the very first suggestion is I'm

00:08:45,550 --> 00:08:51,310
gonna make is remember pythons inbuilt

00:08:48,160 --> 00:08:54,880
data structures these are really really

00:08:51,310 --> 00:08:56,470
good they're not necessarily the best if

00:08:54,880 --> 00:08:58,090
your domain is numbers but for

00:08:56,470 --> 00:08:59,920
everything else they are very very good

00:08:58,090 --> 00:09:01,600
and they're very well optimized they're

00:08:59,920 --> 00:09:03,310
the foundation of everything going on in

00:09:01,600 --> 00:09:04,810
Python so if something is it's very

00:09:03,310 --> 00:09:12,220
unlikely that something is going to be

00:09:04,810 --> 00:09:14,170
broken in these I'm just gonna refresh

00:09:12,220 --> 00:09:16,300
your memory

00:09:14,170 --> 00:09:18,970
I like reminders of the basic things

00:09:16,300 --> 00:09:21,220
because I always forget I forget so much

00:09:18,970 --> 00:09:22,690
stuff but I keep having to look up and

00:09:21,220 --> 00:09:23,980
then somebody reminds me and then I look

00:09:22,690 --> 00:09:25,330
at code I wrote four years ago and

00:09:23,980 --> 00:09:28,870
realized I've already actually done it I

00:09:25,330 --> 00:09:32,110
just forgotten so a list a list invite

00:09:28,870 --> 00:09:34,440
them and the example list in this case

00:09:32,110 --> 00:09:36,790
has the numbers one two three and order

00:09:34,440 --> 00:09:38,940
those are base paths and integers not

00:09:36,790 --> 00:09:42,940
number integers there's a difference

00:09:38,940 --> 00:09:44,230
which I'm not going to go into lists

00:09:42,940 --> 00:09:47,140
have the property that it's really easy

00:09:44,230 --> 00:09:48,430
to put stuff on the end of them and take

00:09:47,140 --> 00:09:50,530
stuff off the end of them so if you are

00:09:48,430 --> 00:09:53,230
accumulating something over time like a

00:09:50,530 --> 00:09:55,180
series of results this is a faster way

00:09:53,230 --> 00:09:56,890
this is a way to do it if you need to do

00:09:55,180 --> 00:09:59,650
anything else with lists like check

00:09:56,890 --> 00:10:01,330
membership then it's going to be for the

00:09:59,650 --> 00:10:03,850
time will be proportional to the size of

00:10:01,330 --> 00:10:05,350
the list so if you problem domain is

00:10:03,850 --> 00:10:07,480
pure numbers you may probably don't want

00:10:05,350 --> 00:10:08,170
to use a list but listen Python are

00:10:07,480 --> 00:10:09,970
general-purpose

00:10:08,170 --> 00:10:13,270
and they're fast when you're considering

00:10:09,970 --> 00:10:14,770
that they deal with Python objects you

00:10:13,270 --> 00:10:17,580
can have a list of whatever Python

00:10:14,770 --> 00:10:17,580
objects you like

00:10:20,160 --> 00:10:28,180
the second one is sets like mathematical

00:10:26,110 --> 00:10:33,190
sets but they're holding Python objects

00:10:28,180 --> 00:10:36,450
so in the example set here has the same

00:10:33,190 --> 00:10:39,700
numbers as in the previous example list

00:10:36,450 --> 00:10:43,450
adding deleting and checking membership

00:10:39,700 --> 00:10:46,269
of a set is all very fast in Python on

00:10:43,450 --> 00:10:52,170
average there's a lot hidden in that on

00:10:46,269 --> 00:10:52,170
average you we're not gonna go into that

00:10:52,470 --> 00:10:56,410
one of the really nice things about

00:10:54,370 --> 00:10:58,540
Python sets is that because they they

00:10:56,410 --> 00:11:00,910
can hold arbitrary Python object almost

00:10:58,540 --> 00:11:02,680
all Python objects there's I think I'll

00:11:00,910 --> 00:11:05,320
talk about in a minute but they also

00:11:02,680 --> 00:11:08,560
have a very natural expression of set

00:11:05,320 --> 00:11:10,000
operations which as far as I'm aware is

00:11:08,560 --> 00:11:12,310
actually you can do all these things

00:11:10,000 --> 00:11:14,320
quickly and numpy but it's not as nice

00:11:12,310 --> 00:11:18,250
as well this is a set it has this

00:11:14,320 --> 00:11:21,490
behavior this conceptual thing an array

00:11:18,250 --> 00:11:27,279
of numbers is you can pretend it's a set

00:11:21,490 --> 00:11:31,390
but it's not a set dictionaries have

00:11:27,279 --> 00:11:33,279
very similar properties as sets adding

00:11:31,390 --> 00:11:35,079
deleting and checking membership are

00:11:33,279 --> 00:11:37,630
really fast but you can also have a

00:11:35,079 --> 00:11:39,790
payload value for every key in there and

00:11:37,630 --> 00:11:41,560
you can iterate through items keys and

00:11:39,790 --> 00:11:46,480
values different Wow whatever you need

00:11:41,560 --> 00:11:48,730
to do for your particular problem the

00:11:46,480 --> 00:11:53,230
last one I'm going to mention is tuples

00:11:48,730 --> 00:11:56,410
so I the only thing you you can't put

00:11:53,230 --> 00:11:59,470
mutable objects or I'm probably gonna

00:11:56,410 --> 00:12:05,079
get this wrong ask the Python developers

00:11:59,470 --> 00:12:06,310
the details the things you put in sets

00:12:05,079 --> 00:12:08,290
and dictionaries need to be hashable

00:12:06,310 --> 00:12:10,300
lists are not hashable because they can

00:12:08,290 --> 00:12:13,570
change so if you need to put something

00:12:10,300 --> 00:12:15,160
like metadata or other things you need

00:12:13,570 --> 00:12:17,560
to use a tuple tuples are immutable

00:12:15,160 --> 00:12:20,620
they're fixed size they don't take up a

00:12:17,560 --> 00:12:22,570
lot of space but you can't modify them

00:12:20,620 --> 00:12:25,810
as easily tuples work really well for

00:12:22,570 --> 00:12:27,519
things like metadata to descriptions so

00:12:25,810 --> 00:12:29,290
if you've got some combination of

00:12:27,519 --> 00:12:31,839
experimental conditions a good

00:12:29,290 --> 00:12:32,820
descriptor of them might be a tuple of

00:12:31,839 --> 00:12:34,890
all of the

00:12:32,820 --> 00:12:38,970
bits and pieces of that experimental

00:12:34,890 --> 00:12:41,190
condition and I mention them because you

00:12:38,970 --> 00:12:43,920
can't have a set of lists but you can't

00:12:41,190 --> 00:12:45,420
have a set of tuples or you can have the

00:12:43,920 --> 00:12:54,470
keys of your dictionary being tuples

00:12:45,420 --> 00:12:58,800
which is very handy so beyond the basic

00:12:54,470 --> 00:13:05,160
Python data structures don't forget you

00:12:58,800 --> 00:13:06,900
can glue them together in moderation one

00:13:05,160 --> 00:13:08,790
advantage of this is that the semantics

00:13:06,900 --> 00:13:10,080
of combining things is a lot easier for

00:13:08,790 --> 00:13:11,640
people to understand because they

00:13:10,080 --> 00:13:13,140
already know well I know how a set works

00:13:11,640 --> 00:13:15,540
so if I've got a set of these other

00:13:13,140 --> 00:13:17,960
objects that's less thinking I already

00:13:15,540 --> 00:13:21,150
know what this thing does

00:13:17,960 --> 00:13:22,530
feel free to nest or combine things in

00:13:21,150 --> 00:13:31,050
ways that make sense for your particular

00:13:22,530 --> 00:13:33,900
problem this gets even better when you

00:13:31,050 --> 00:13:36,120
consider the fancy thing the fancier

00:13:33,900 --> 00:13:38,280
data structures in that are built into

00:13:36,120 --> 00:13:40,230
the standard library so if you haven't

00:13:38,280 --> 00:13:43,800
ever come across default Dixson counters

00:13:40,230 --> 00:13:45,750
before they are great they save a lot of

00:13:43,800 --> 00:13:47,400
time there are a lot of things you can

00:13:45,750 --> 00:13:49,350
just you don't have to think about

00:13:47,400 --> 00:13:51,900
anymore you just go this is the default

00:13:49,350 --> 00:13:53,850
date of lists and then you don't need to

00:13:51,900 --> 00:13:56,280
worry about whether the key is already

00:13:53,850 --> 00:13:57,660
in the dictionary or whether appending

00:13:56,280 --> 00:13:59,250
is going to fail or all those other

00:13:57,660 --> 00:14:02,130
things you can just make it happen it

00:13:59,250 --> 00:14:05,010
simplifies your code a lot

00:14:02,130 --> 00:14:08,400
this makes composition a lot easier and

00:14:05,010 --> 00:14:11,340
you're still using standard library and

00:14:08,400 --> 00:14:12,960
standard data data structures so most

00:14:11,340 --> 00:14:14,460
other programmers are gonna at least

00:14:12,960 --> 00:14:20,760
have some understanding of what's going

00:14:14,460 --> 00:14:22,080
on I'm also going to point out two

00:14:20,760 --> 00:14:24,330
things that you may not have come across

00:14:22,080 --> 00:14:28,860
before in the standard library there is

00:14:24,330 --> 00:14:31,200
a priority queue implementation in the

00:14:28,860 --> 00:14:34,410
form of hick heap queue it keeps your

00:14:31,200 --> 00:14:35,670
priority queue in a list I mentioned

00:14:34,410 --> 00:14:38,010
this one in particular because a lot of

00:14:35,670 --> 00:14:41,820
algorithmic optimization relies on some

00:14:38,010 --> 00:14:45,120
kind of sorted prior or priority queue

00:14:41,820 --> 00:14:46,600
being built in built as you go along to

00:14:45,120 --> 00:14:48,460
make things go faster like lots of

00:14:46,600 --> 00:14:51,360
algorithms that go from N squared n log

00:14:48,460 --> 00:14:53,770
n use some kind of Q like that or heat

00:14:51,360 --> 00:14:55,930
the other thing is the bisect module

00:14:53,770 --> 00:14:58,690
which is standard bisection search but

00:14:55,930 --> 00:15:01,060
it's in the standard library so you can

00:14:58,690 --> 00:15:03,250
do lots of interesting things like with

00:15:01,060 --> 00:15:08,580
that if you're working with data that is

00:15:03,250 --> 00:15:08,580
sorted or is required to remain sorted

00:15:12,750 --> 00:15:19,410
the last one I want to in terms of pure

00:15:16,570 --> 00:15:22,060
Python the last one I want to mention is

00:15:19,410 --> 00:15:23,680
generators in streaming so in numerical

00:15:22,060 --> 00:15:25,990
Python land I think there's this kind of

00:15:23,680 --> 00:15:27,190
implicit assumption that everything

00:15:25,990 --> 00:15:28,870
you're gonna do is gonna fit in memory

00:15:27,190 --> 00:15:32,250
you don't have to worry about memory

00:15:28,870 --> 00:15:36,250
she's a problem you just got enough rent

00:15:32,250 --> 00:15:41,500
you're not gonna run out but eventually

00:15:36,250 --> 00:15:44,530
you do run out like this this is a cheap

00:15:41,500 --> 00:15:47,200
laptop it has 16 gig of ram and I kinda

00:15:44,530 --> 00:15:53,860
regret not going up from there

00:15:47,200 --> 00:15:55,660
just because another side effect of this

00:15:53,860 --> 00:15:57,250
assumption that everything is memory is

00:15:55,660 --> 00:16:00,250
in memory is that just everybody just

00:15:57,250 --> 00:16:02,110
gets used to work of going oh ok it's

00:16:00,250 --> 00:16:03,490
the data frame I'm sorry it's a CSV file

00:16:02,110 --> 00:16:04,690
I'm gonna read it into it I'm just gonna

00:16:03,490 --> 00:16:06,280
read it into a panda's data frame

00:16:04,690 --> 00:16:08,740
doesn't matter what you're actually

00:16:06,280 --> 00:16:10,300
gonna do with it afterwards like if

00:16:08,740 --> 00:16:12,340
you're doing aggregations and group bys

00:16:10,300 --> 00:16:13,600
and sorting and time series there that

00:16:12,340 --> 00:16:15,160
makes sense but if you're then just

00:16:13,600 --> 00:16:16,630
gonna iterate through all the rows of

00:16:15,160 --> 00:16:18,760
the data frame one at a time and do

00:16:16,630 --> 00:16:26,410
something else maybe that's not the best

00:16:18,760 --> 00:16:28,320
way I've seen pandas read CSV a lot it's

00:16:26,410 --> 00:16:31,900
a really nice function it just works

00:16:28,320 --> 00:16:33,460
until that really big file is bigger

00:16:31,900 --> 00:16:35,350
than your machine can handle and then

00:16:33,460 --> 00:16:38,830
you have to start doing not so fun

00:16:35,350 --> 00:16:40,060
things generally everything is a pain

00:16:38,830 --> 00:16:42,910
when you start running into memory

00:16:40,060 --> 00:16:44,320
pressure and you have to work around it

00:16:42,910 --> 00:16:46,450
and there are lots of ways to work

00:16:44,320 --> 00:16:53,560
around it but why go to the effort if

00:16:46,450 --> 00:16:56,670
you don't have to so in this first

00:16:53,560 --> 00:16:56,670
example I have for this

00:16:56,860 --> 00:17:01,579
first one creates reads the dot

00:16:59,959 --> 00:17:03,079
everything into a data frame then does

00:17:01,579 --> 00:17:05,089
some arbitrary function to all the

00:17:03,079 --> 00:17:10,370
raising the data frame it's nice it's

00:17:05,089 --> 00:17:11,780
simple it's understandable but suddenly

00:17:10,370 --> 00:17:14,299
we have everything in memory and maybe

00:17:11,780 --> 00:17:15,770
we don't need it there in the second

00:17:14,299 --> 00:17:17,870
example we're just going to go through

00:17:15,770 --> 00:17:19,490
the files line by line we're gonna load

00:17:17,870 --> 00:17:21,289
a load a line by memory do the

00:17:19,490 --> 00:17:23,959
processing on that line move on to the

00:17:21,289 --> 00:17:26,480
next thing we don't need the whole file

00:17:23,959 --> 00:17:29,179
in memory that's file command we as big

00:17:26,480 --> 00:17:30,830
as we like we're we're limited by hard

00:17:29,179 --> 00:17:41,030
drive space melt by memory space in the

00:17:30,830 --> 00:17:43,820
second line and the the implicit magic

00:17:41,030 --> 00:17:45,740
here is that four line in F is a

00:17:43,820 --> 00:17:48,020
generator it's not loading all of the

00:17:45,740 --> 00:17:50,960
data into memory it's just going to go

00:17:48,020 --> 00:17:52,669
through one line at a time we can make

00:17:50,960 --> 00:17:54,559
that a bit more explicit with list and

00:17:52,669 --> 00:17:59,659
generate by comparing list and generator

00:17:54,559 --> 00:18:06,169
comprehensions so in the first case if

00:17:59,659 --> 00:18:09,200
we try to do something to every line in

00:18:06,169 --> 00:18:11,360
the file it's going to do all of that

00:18:09,200 --> 00:18:13,580
computation in one here it's gonna store

00:18:11,360 --> 00:18:15,409
everything in a single potentially giant

00:18:13,580 --> 00:18:19,220
list in memory before it moves on to the

00:18:15,409 --> 00:18:20,450
next step on the second line all I've

00:18:19,220 --> 00:18:24,770
done is replace the list comprehension

00:18:20,450 --> 00:18:29,570
with the generator comprehension do

00:18:24,770 --> 00:18:37,070
something is not evaluated until later

00:18:29,570 --> 00:18:39,409
on the nice thing about generators is

00:18:37,070 --> 00:18:40,789
that you can express you can compose

00:18:39,409 --> 00:18:42,470
them so you can make you can feed the

00:18:40,789 --> 00:18:44,330
result of one generator into another

00:18:42,470 --> 00:18:46,159
generator into another generator so

00:18:44,330 --> 00:18:48,380
suddenly what looks like some funky

00:18:46,159 --> 00:18:52,010
processing can just become a stream and

00:18:48,380 --> 00:18:54,169
a lazily evaluated stream at that so for

00:18:52,010 --> 00:18:56,419
this problem we only need to worry about

00:18:54,169 --> 00:18:57,860
the memory of one line at a time not the

00:18:56,419 --> 00:19:00,429
amount of memory we need to hold the

00:18:57,860 --> 00:19:00,429
whole results

00:19:06,480 --> 00:19:20,970
so taking a break from Python itself and

00:19:14,090 --> 00:19:22,760
looking a little bit broader maybe you

00:19:20,970 --> 00:19:25,200
shouldn't be trying to do that in Python

00:19:22,760 --> 00:19:27,330
maybe you're making your life harder by

00:19:25,200 --> 00:19:30,390
not using all the other infrastructure

00:19:27,330 --> 00:19:31,830
you have available maybe putting your

00:19:30,390 --> 00:19:36,330
daughter and a daughter base is a good

00:19:31,830 --> 00:19:38,670
idea the nice thing about databases is

00:19:36,330 --> 00:19:41,940
that generally all of the hot

00:19:38,670 --> 00:19:43,590
operational problems like is the data

00:19:41,940 --> 00:19:46,680
backed up how do i back it up how do i

00:19:43,590 --> 00:19:48,870
replicate it is the dot is is the

00:19:46,680 --> 00:19:50,400
daughter's integrity still sorry does

00:19:48,870 --> 00:19:55,530
the data still have the required

00:19:50,400 --> 00:19:57,150
integrity does every are all foreign are

00:19:55,530 --> 00:20:00,390
all the constraints that should be on

00:19:57,150 --> 00:20:01,980
this data still valid it's just so it's

00:20:00,390 --> 00:20:05,730
a solved problem you don't need to think

00:20:01,980 --> 00:20:08,370
about it I wish I had learned databases

00:20:05,730 --> 00:20:11,820
and SQL earlier because I realized when

00:20:08,370 --> 00:20:13,740
I learned it that I'd read John's like

00:20:11,820 --> 00:20:17,400
three times in three different contexts

00:20:13,740 --> 00:20:22,010
and I didn't need to that wasn't that

00:20:17,400 --> 00:20:22,010
was cool and sad all at the same time

00:20:24,620 --> 00:20:28,860
also SQLite is in the Python standard

00:20:27,270 --> 00:20:36,120
library so you can't say you don't have

00:20:28,860 --> 00:20:39,930
a database I think the single biggest

00:20:36,120 --> 00:20:43,080
thing that SQLite does is that it is

00:20:39,930 --> 00:20:45,690
still has durable transactions so you

00:20:43,080 --> 00:20:47,130
can rely on it to keep your data once

00:20:45,690 --> 00:20:48,420
you've committed that transaction and

00:20:47,130 --> 00:20:51,390
you don't have to worry about partial

00:20:48,420 --> 00:20:54,270
States a lot of the time the hard part

00:20:51,390 --> 00:20:56,430
about long-running computations is being

00:20:54,270 --> 00:20:58,050
able to resume them and having save

00:20:56,430 --> 00:21:00,060
states and resume points so you don't

00:20:58,050 --> 00:21:02,340
have to worry about your three week long

00:21:00,060 --> 00:21:04,250
computation dying in the middle

00:21:02,340 --> 00:21:09,620
SQLite just gives you the nice

00:21:04,250 --> 00:21:11,640
transactional guarantees for free plus

00:21:09,620 --> 00:21:13,530
personally I think SQL is a very

00:21:11,640 --> 00:21:16,150
productive language for a specific

00:21:13,530 --> 00:21:19,809
subset of data problem so

00:21:16,150 --> 00:21:23,080
I I would much rather use SQL than

00:21:19,809 --> 00:21:28,510
pandas I'm sorry please don't hold that

00:21:23,080 --> 00:21:30,130
against me on top of that there are a

00:21:28,510 --> 00:21:31,900
lot of databases out there there are a

00:21:30,130 --> 00:21:34,059
lot of domain-specific databases there

00:21:31,900 --> 00:21:40,809
are a lot of domain-specific extensions

00:21:34,059 --> 00:21:43,210
for databases so if if you can push some

00:21:40,809 --> 00:21:44,650
of the hard problem onto something else

00:21:43,210 --> 00:21:46,210
in your stack maybe you should consider

00:21:44,650 --> 00:21:48,190
that maybe you don't need to solve

00:21:46,210 --> 00:21:51,640
everything in memory and numeric in

00:21:48,190 --> 00:21:53,740
numberland so if you go to graph or a

00:21:51,640 --> 00:21:56,740
network problem you could put any neo4j

00:21:53,740 --> 00:22:00,789
for example full-text search either your

00:21:56,740 --> 00:22:04,330
relational database or elasticsearch GIS

00:22:00,789 --> 00:22:06,960
maybe you want ice grass plus post juice

00:22:04,330 --> 00:22:09,370
I think that's how you pronounce it

00:22:06,960 --> 00:22:10,720
I've already said I like relational

00:22:09,370 --> 00:22:15,640
models you can probably figure that out

00:22:10,720 --> 00:22:19,059
so I won't ever think that one lastly I

00:22:15,640 --> 00:22:23,169
think that analytical databases like my

00:22:19,059 --> 00:22:26,830
name TV and click house and the hosted

00:22:23,169 --> 00:22:28,929
alternatives like bigquery and redshift

00:22:26,830 --> 00:22:30,880
and the other AWS one whose name I can't

00:22:28,929 --> 00:22:32,890
remember right now our a really really

00:22:30,880 --> 00:22:35,590
nice complement to the numerical Pithom

00:22:32,890 --> 00:22:37,840
stack because if you've got it in a

00:22:35,590 --> 00:22:40,600
database you can separate the concerns a

00:22:37,840 --> 00:22:42,490
lot and then your numerical Python stuff

00:22:40,600 --> 00:22:44,169
maybe only needs to worry about a subset

00:22:42,490 --> 00:22:46,480
of the dot or a subset of the problem

00:22:44,169 --> 00:22:47,950
and you can simplify your life by only

00:22:46,480 --> 00:22:50,970
pulling out what you need instead of

00:22:47,950 --> 00:22:50,970
pulling in everything

00:22:56,150 --> 00:23:00,289
another recommendation I want to make or

00:22:58,460 --> 00:23:01,370
another suggestion is that maybe you

00:23:00,289 --> 00:23:04,990
should have a quick look to see if

00:23:01,370 --> 00:23:09,770
there's a smaller toss specific library

00:23:04,990 --> 00:23:13,580
if your domain happens to fit in integer

00:23:09,770 --> 00:23:15,260
it sets you probably want to be using

00:23:13,580 --> 00:23:16,669
roaring bitmaps anyway there are

00:23:15,260 --> 00:23:19,880
actually like three or four different

00:23:16,669 --> 00:23:22,159
wrappers for the C library you will

00:23:19,880 --> 00:23:24,650
probably not build software that is

00:23:22,159 --> 00:23:26,240
better than that you will not build

00:23:24,650 --> 00:23:28,490
anything faster than that I don't I

00:23:26,240 --> 00:23:30,980
think this is as close as it gets to CPU

00:23:28,490 --> 00:23:33,140
to making the most of modern CPUs so if

00:23:30,980 --> 00:23:37,880
if you happen to have bits a bit set

00:23:33,140 --> 00:23:39,799
problem you want to use that there's

00:23:37,880 --> 00:23:45,529
also a sorted container library which

00:23:39,799 --> 00:23:47,000
has lots of interesting data structures

00:23:45,529 --> 00:23:48,409
in there with different kinds of sorting

00:23:47,000 --> 00:23:49,880
for different kinds of problems so maybe

00:23:48,409 --> 00:23:53,510
that can make your life easier just by

00:23:49,880 --> 00:23:55,720
using that instead of pulling in the big

00:23:53,510 --> 00:23:55,720
guns

00:24:00,020 --> 00:24:11,140
I guess to kind of wrap up I realize I

00:24:08,630 --> 00:24:14,090
put those in the wrong order I think I

00:24:11,140 --> 00:24:15,290
think the first wrapping up point should

00:24:14,090 --> 00:24:16,760
be don't be afraid to mix and match

00:24:15,290 --> 00:24:18,650
you're not constrained to solve

00:24:16,760 --> 00:24:20,210
everything in numpy or sci-fi or

00:24:18,650 --> 00:24:22,400
scikit-learn you can bring in the rest

00:24:20,210 --> 00:24:24,170
of Latin too because you've already got

00:24:22,400 --> 00:24:26,000
a big chunk of it the standard library

00:24:24,170 --> 00:24:30,290
is very good the base data structure is

00:24:26,000 --> 00:24:32,929
a very good don't don't force yourself

00:24:30,290 --> 00:24:34,910
into just the numerical domain you can

00:24:32,929 --> 00:24:40,610
you can use other stuff too you're

00:24:34,910 --> 00:24:43,130
allowed and I guess the other thing is

00:24:40,610 --> 00:24:43,850
that I don't think when you've made the

00:24:43,130 --> 00:24:46,429
decision

00:24:43,850 --> 00:24:47,660
you've evaluated your problem even when

00:24:46,429 --> 00:24:52,250
yeah this is actually a numerical

00:24:47,660 --> 00:24:54,040
problem this is I mean I it's gonna take

00:24:52,250 --> 00:24:57,590
me so much longer to do it any other way

00:24:54,040 --> 00:25:00,260
if you build that go for it go deep how

00:24:57,590 --> 00:25:03,590
number even numpy as the base of the

00:25:00,260 --> 00:25:05,090
library has so many cool functions just

00:25:03,590 --> 00:25:08,510
write the documentation when you find

00:25:05,090 --> 00:25:11,630
the cool one also just if somebody wants

00:25:08,510 --> 00:25:14,630
to explain the Einstein summation stuff

00:25:11,630 --> 00:25:17,000
in num play I would really like that

00:25:14,630 --> 00:25:27,550
because I have tried and failed a few

00:25:17,000 --> 00:25:27,550
times and I can use some help thank you

00:25:33,200 --> 00:25:37,340
thank you Sam do we have any questions

00:25:35,450 --> 00:25:43,460
were about five minutes left for

00:25:37,340 --> 00:25:45,200
questions okay I got a question to start

00:25:43,460 --> 00:25:50,000
them um

00:25:45,200 --> 00:25:51,470
so part of your talk was saying yeah you

00:25:50,000 --> 00:25:53,210
don't need to go straight into numpy

00:25:51,470 --> 00:25:56,930
pandas etc he just used to base

00:25:53,210 --> 00:25:59,090
libraries but at least in my personal

00:25:56,930 --> 00:26:01,670
experience like I started off - that way

00:25:59,090 --> 00:26:04,250
going deep into base libraries and I did

00:26:01,670 --> 00:26:08,390
way too much terrible stuff with it how

00:26:04,250 --> 00:26:09,620
do you help a beginner mate had that

00:26:08,390 --> 00:26:17,270
knowledge when to transition to

00:26:09,620 --> 00:26:19,460
something fancier so I was gonna say it

00:26:17,270 --> 00:26:22,010
depends but that's really not a useful I

00:26:19,460 --> 00:26:23,810
did I think it one part is the

00:26:22,010 --> 00:26:25,910
background like is this a beginner

00:26:23,810 --> 00:26:29,120
software developer is this a beginner

00:26:25,910 --> 00:26:30,680
data scientist is this a PhD student

00:26:29,120 --> 00:26:33,710
working in a particular problem domain

00:26:30,680 --> 00:26:35,270
for a particular purpose and I think the

00:26:33,710 --> 00:26:44,690
answers for all of those people are

00:26:35,270 --> 00:26:45,650
different and to be honest I think it's

00:26:44,690 --> 00:26:48,430
one of those things where you're going

00:26:45,650 --> 00:26:53,180
to be wrong half the time anyway so I

00:26:48,430 --> 00:26:55,880
think it's worthwhile to go maybe the

00:26:53,180 --> 00:26:57,670
advice would be trust your gut after

00:26:55,880 --> 00:26:59,660
evaluating the options

00:26:57,670 --> 00:27:01,610
remembering that the options for there

00:26:59,660 --> 00:27:03,110
is probably the main talk the point I

00:27:01,610 --> 00:27:06,500
want you to take away is that there are

00:27:03,110 --> 00:27:08,090
there is the option to not use this not

00:27:06,500 --> 00:27:09,980
saying you shouldn't use it because you

00:27:08,090 --> 00:27:12,110
probably do want to use it most in lots

00:27:09,980 --> 00:27:13,430
of cases but if you remember that there

00:27:12,110 --> 00:27:15,020
are other options there are other things

00:27:13,430 --> 00:27:17,330
out there there are the Python

00:27:15,020 --> 00:27:20,860
communities idioms length packages and

00:27:17,330 --> 00:27:23,720
so on I would definitely trust your gut

00:27:20,860 --> 00:27:26,630
after after thinking about the other

00:27:23,720 --> 00:27:29,240
options which again is not very useful

00:27:26,630 --> 00:27:31,450
advice but you ask the hard question

00:27:29,240 --> 00:27:31,450
first

00:27:33,610 --> 00:27:39,830
hello yeah so you mentioned like lists

00:27:37,340 --> 00:27:42,200
and dictionaries and things like that so

00:27:39,830 --> 00:27:47,029
I guess a really long dictionary could

00:27:42,200 --> 00:27:49,159
be like and yeah panda series is going

00:27:47,029 --> 00:27:51,590
through either of those like a massive

00:27:49,159 --> 00:27:54,860
one for example which is more efficient

00:27:51,590 --> 00:27:56,690
and on the large scale and or always

00:27:54,860 --> 00:27:58,129
people always say that pandas and

00:27:56,690 --> 00:28:00,139
umpires like super efficient and then

00:27:58,129 --> 00:28:04,669
the other stuff like lists for example

00:28:00,139 --> 00:28:07,009
would be not so efficient it's it

00:28:04,669 --> 00:28:09,440
depends a lot on the exact problem like

00:28:07,009 --> 00:28:11,570
if you're just looking up a single thing

00:28:09,440 --> 00:28:15,019
in a single dictionary it's probably not

00:28:11,570 --> 00:28:19,639
actually worth benchmarking if you're

00:28:15,019 --> 00:28:21,739
doing lots of lookups you probably yeah

00:28:19,639 --> 00:28:23,690
that's a really I think because the

00:28:21,739 --> 00:28:25,129
problem with the numeric we're doing

00:28:23,690 --> 00:28:27,200
that kind of comparison is that it's

00:28:25,129 --> 00:28:29,299
very very toss specific what is the most

00:28:27,200 --> 00:28:32,960
appropriate and also I think if you're

00:28:29,299 --> 00:28:34,580
at the point where you're going doing

00:28:32,960 --> 00:28:36,409
that panda benchmarking you always need

00:28:34,580 --> 00:28:38,119
to tie it back to what is the actual

00:28:36,409 --> 00:28:40,309
problem I'm solving does it matter if

00:28:38,119 --> 00:28:42,619
this takes five microseconds instead of

00:28:40,309 --> 00:28:44,629
one microsecond maybe it doesn't if

00:28:42,619 --> 00:28:47,960
you're doing that look up trillions of

00:28:44,629 --> 00:28:50,179
times then it really does matter and I'd

00:28:47,960 --> 00:28:51,679
probably say that the better answer

00:28:50,179 --> 00:28:55,070
there is to figure out what's the actual

00:28:51,679 --> 00:28:58,279
problem and the objective of that first

00:28:55,070 --> 00:29:01,090
before you worry about tech choices like

00:28:58,279 --> 00:29:01,090
okay well thanks

00:29:04,659 --> 00:29:13,130
hi nice talk I really liked it but you

00:29:08,600 --> 00:29:16,130
talked about loading big big files and

00:29:13,130 --> 00:29:20,390
using generators on the other hand there

00:29:16,130 --> 00:29:23,720
is a memory map function that doesn't

00:29:20,390 --> 00:29:28,039
load the file at once you have you have

00:29:23,720 --> 00:29:31,669
any insight is there any difference in

00:29:28,039 --> 00:29:34,250
speed between making generators and

00:29:31,669 --> 00:29:36,649
loading files with the memory map

00:29:34,250 --> 00:29:38,240
functions any significant difference

00:29:36,649 --> 00:29:39,649
I couldn't comment on significant

00:29:38,240 --> 00:29:41,600
differences I would say that there's a

00:29:39,649 --> 00:29:44,059
pretty big conceptual difference in the

00:29:41,600 --> 00:29:45,559
wood when you're talking about memory

00:29:44,059 --> 00:29:47,210
mapping things suddenly you're actually

00:29:45,559 --> 00:29:49,520
you're working around a limitation of

00:29:47,210 --> 00:29:51,140
your machine rather than there's a

00:29:49,520 --> 00:29:52,669
there's a conceptual overhead to even

00:29:51,140 --> 00:29:54,770
formulating your problem in that way

00:29:52,669 --> 00:29:56,510
which maybe you don't even have to think

00:29:54,770 --> 00:29:58,159
about with the generators because I

00:29:56,510 --> 00:30:01,760
think sometimes the real constraint is

00:29:58,159 --> 00:30:03,049
programmer time and document the amount

00:30:01,760 --> 00:30:04,520
of time you have to read documentation

00:30:03,049 --> 00:30:06,649
and pass that knowledge on to your team

00:30:04,520 --> 00:30:10,010
rather than how long this is I mean

00:30:06,649 --> 00:30:11,840
there are probably some cases where you

00:30:10,010 --> 00:30:14,840
have to memory map because a generator

00:30:11,840 --> 00:30:24,140
is gonna be too slow if I if that also

00:30:14,840 --> 00:30:25,850
answers your question thanks Sam for a

00:30:24,140 --> 00:30:27,890
wonderful talk I just had a question

00:30:25,850 --> 00:30:30,559
regarding dump I that I find it much

00:30:27,890 --> 00:30:32,270
easier to do element wise comparisons

00:30:30,559 --> 00:30:34,669
like element wise operations when I'm

00:30:32,270 --> 00:30:37,520
dealing with building masks and multiple

00:30:34,669 --> 00:30:40,640
masks to filter out my data and I just

00:30:37,520 --> 00:30:43,850
find functions like env logical and and

00:30:40,640 --> 00:30:45,830
logical or quite a lot easier yeah if

00:30:43,850 --> 00:30:49,730
you have anything else any alternatives

00:30:45,830 --> 00:30:51,440
or it's not really the way to go it

00:30:49,730 --> 00:30:54,950
sounds like that's the right solution

00:30:51,440 --> 00:30:56,059
for your problem within the base data

00:30:54,950 --> 00:31:01,159
structures I don't think there's

00:30:56,059 --> 00:31:02,809
anything quite the same maybe list

00:31:01,159 --> 00:31:08,149
comprehensions or generate a

00:31:02,809 --> 00:31:09,799
comprehension but yeah I mean it's it

00:31:08,149 --> 00:31:11,240
also sounds like you know you know what

00:31:09,799 --> 00:31:12,590
your problem is and it sounds like it's

00:31:11,240 --> 00:31:15,200
a really really good fit for a numerical

00:31:12,590 --> 00:31:16,800
domains that you probably don't need to

00:31:15,200 --> 00:31:21,300
look too hard

00:31:16,800 --> 00:31:23,100
and other options which is good I think

00:31:21,300 --> 00:31:23,640
there was one more question if we've got

00:31:23,100 --> 00:31:25,650
time

00:31:23,640 --> 00:31:27,990
no unfortunately we are out of time now

00:31:25,650 --> 00:31:29,370
but I'm sure you can find Sam in the

00:31:27,990 --> 00:31:31,710
morning tea break which is what's

00:31:29,370 --> 00:31:34,260
happening now and just as a small

00:31:31,710 --> 00:31:40,829
preciate and giving a talk

00:31:34,260 --> 00:31:40,829

YouTube URL: https://www.youtube.com/watch?v=qSug56Gwly0


