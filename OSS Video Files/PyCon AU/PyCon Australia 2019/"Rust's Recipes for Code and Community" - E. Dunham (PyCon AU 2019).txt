Title: "Rust's Recipes for Code and Community" - E. Dunham (PyCon AU 2019)
Publication date: 2019-08-02
Playlist: PyCon Australia 2019
Description: 
	E. Dunham

In some ways, a browser engine seems to have little in common with a web
framework. But both are ambitious software projects, approached by large
groups of diverse people trying and sometimes failing to cooperate,
collaborate, and code together. This talk shares firsthand observations,
collected over 3 years of working within the Rust and Servo teams at Mozilla
as well as volunteering on the Rust Community Team, about what all developers
can learn from Rust's approaches to the universal challenges of code and
community.

https://2019.pycon-au.org/talks/rust-s-recipes-for-code-and-community

PyCon AU, the national Python Language conference, is on again this August in Sydney, at the International Convention Centre, Sydney, August 2 - 6 2019.

Video licence: CC BY-NC-SA 4.0 - https://creativecommons.org/licenses/by-nc-sa/4.0/

Python, PyCon, PyConAU

Fri Aug  2 09:15:00 2019 at C3.3
Captions: 
	00:00:00,530 --> 00:00:08,000
and with that we'd like to announce our

00:00:04,620 --> 00:00:10,969
invited speaker Emily Dunham

00:00:08,000 --> 00:00:14,099
she said DevOps engineer at Mozilla and

00:00:10,969 --> 00:00:15,599
has been doing it has been doing a bunch

00:00:14,099 --> 00:00:18,480
of rust development over the last couple

00:00:15,599 --> 00:00:21,410
of years but today she's going to talk

00:00:18,480 --> 00:00:25,260
about the community that are similar to

00:00:21,410 --> 00:00:29,550
that's similar or possibly different in

00:00:25,260 --> 00:00:31,679
the rust ecosystem and now you might ask

00:00:29,550 --> 00:00:35,399
what the similarities there well

00:00:31,679 --> 00:00:37,860
browsers are rather huge projects to

00:00:35,399 --> 00:00:40,079
build so our web frameworks as we all

00:00:37,860 --> 00:00:42,420
know from the tango community and yeah I

00:00:40,079 --> 00:00:44,610
think I guess we're going to learn a lot

00:00:42,420 --> 00:01:04,710
of things from what the rest community

00:00:44,610 --> 00:01:06,840
does around community thank you so I've

00:01:04,710 --> 00:01:08,880
got links to my Twitter and to the

00:01:06,840 --> 00:01:10,290
slides here in the slides before we

00:01:08,880 --> 00:01:12,570
begin I also would like to acknowledge

00:01:10,290 --> 00:01:14,250
the guard all of the eora nation the

00:01:12,570 --> 00:01:16,080
traditional custodians of this land and

00:01:14,250 --> 00:01:17,040
pay my respects to the elders both past

00:01:16,080 --> 00:01:20,909
and present

00:01:17,040 --> 00:01:24,210
so DevOps sysadmin call it what you will

00:01:20,909 --> 00:01:27,570
I'm an Oregonian who writes Python to

00:01:24,210 --> 00:01:30,680
make servers go so why am I in Australia

00:01:27,570 --> 00:01:33,270
talking to django people about rust I

00:01:30,680 --> 00:01:35,610
last touched Django about a decade ago

00:01:33,270 --> 00:01:37,650
at a point in the project where the less

00:01:35,610 --> 00:01:40,110
like a newspaper you were the harder it

00:01:37,650 --> 00:01:42,030
was to use and all I'll say about that

00:01:40,110 --> 00:01:44,369
is the project I was on had nothing in

00:01:42,030 --> 00:01:47,430
common with newspapers the rest part of

00:01:44,369 --> 00:01:49,380
my career comes in when in 2015 I left

00:01:47,430 --> 00:01:51,930
University to take a job as the sole

00:01:49,380 --> 00:01:54,450
DevOps engineer for Mozilla research I

00:01:51,930 --> 00:01:56,369
spent the following three years embedded

00:01:54,450 --> 00:01:58,680
within the rest and servo teams they're

00:01:56,369 --> 00:02:00,659
lowering the organization's diplomas per

00:01:58,680 --> 00:02:03,180
capita keeping the servers running

00:02:00,659 --> 00:02:05,310
picking up grad school terms like ray Fi

00:02:03,180 --> 00:02:07,469
and elide from casual conversation and

00:02:05,310 --> 00:02:09,360
generally enjoying a backstage pass

00:02:07,469 --> 00:02:12,690
behind the scenes of these

00:02:09,360 --> 00:02:13,800
world-changing projects so servo is an

00:02:12,690 --> 00:02:16,500
experimental browser

00:02:13,800 --> 00:02:18,240
yes that really is the logo created to

00:02:16,500 --> 00:02:20,550
explore the possibilities that rust

00:02:18,240 --> 00:02:22,500
opens up without the burden of the total

00:02:20,550 --> 00:02:25,410
backwards compatibility that Firefox has

00:02:22,500 --> 00:02:27,720
to carry and rust is the language that

00:02:25,410 --> 00:02:29,430
stack overflows developer survey rated

00:02:27,720 --> 00:02:32,220
third most loved when it came out in

00:02:29,430 --> 00:02:35,370
2015 and first most loved every single

00:02:32,220 --> 00:02:36,990
year since then last year I moved out of

00:02:35,370 --> 00:02:39,180
research to pursue my career goals

00:02:36,990 --> 00:02:40,860
elsewhere in Mozilla but my time with

00:02:39,180 --> 00:02:42,540
rust has permanently improved my

00:02:40,860 --> 00:02:45,180
vocabulary of solutions to common

00:02:42,540 --> 00:02:46,950
open-source software challenges I'm here

00:02:45,180 --> 00:02:48,720
to share some of my observations about

00:02:46,950 --> 00:02:50,490
how rusts code has shaped the community

00:02:48,720 --> 00:02:52,830
how the community has shaped the code

00:02:50,490 --> 00:02:54,900
and the questions that rust has answered

00:02:52,830 --> 00:02:56,940
which you should probably be asking too

00:02:54,900 --> 00:02:58,470
I hope you can forgive me if I also

00:02:56,940 --> 00:03:01,680
accidentally teach you a little bit of

00:02:58,470 --> 00:03:03,840
useful rest along the way so rusts

00:03:01,680 --> 00:03:06,000
original author Graydon began work on

00:03:03,840 --> 00:03:08,490
the languages foundations around 2010

00:03:06,000 --> 00:03:10,260
his motivation was the difficulties that

00:03:08,490 --> 00:03:11,850
he and his colleagues faced when

00:03:10,260 --> 00:03:14,850
developing Mozilla's gecko browser

00:03:11,850 --> 00:03:17,370
engine in C++ countless feature

00:03:14,850 --> 00:03:20,370
additions and removals later rust 1.0

00:03:17,370 --> 00:03:22,410
stable came out in May of 2015 we

00:03:20,370 --> 00:03:23,880
celebrate rusts birthday on May 15th

00:03:22,410 --> 00:03:26,520
often with cake because we're a bunch of

00:03:23,880 --> 00:03:28,620
nerds project quantum one of the more

00:03:26,520 --> 00:03:31,020
Herculean efforts in Firefox is history

00:03:28,620 --> 00:03:33,690
was about trying to improve gecko by

00:03:31,020 --> 00:03:34,200
porting rust code from servo and it

00:03:33,690 --> 00:03:36,570
worked

00:03:34,200 --> 00:03:38,730
Firefox has shipped with rust components

00:03:36,570 --> 00:03:40,650
since 2017 so if you're viewing your

00:03:38,730 --> 00:03:42,840
Django site and Firefox you're probably

00:03:40,650 --> 00:03:46,050
running some rust without even realizing

00:03:42,840 --> 00:03:48,000
it if you ask where rusts name came from

00:03:46,050 --> 00:03:49,860
you'll get a different answer every time

00:03:48,000 --> 00:03:50,850
you ask someone especially from the

00:03:49,860 --> 00:03:53,430
people who could be credited with

00:03:50,850 --> 00:03:56,310
originating it but the mascot is just

00:03:53,430 --> 00:03:57,990
Ferris a rust ation just like the

00:03:56,310 --> 00:04:00,600
language of human users call themselves

00:03:57,990 --> 00:04:02,600
this habit of punishingly funny names

00:04:00,600 --> 00:04:04,980
extends throughout the community

00:04:02,600 --> 00:04:07,470
although the cute mascot definitely

00:04:04,980 --> 00:04:09,270
helps rusts technical appeal is it

00:04:07,470 --> 00:04:12,150
simultaneous emphasis on both

00:04:09,270 --> 00:04:14,250
performance and safety neither speed nor

00:04:12,150 --> 00:04:16,140
safety offered by a language is novel on

00:04:14,250 --> 00:04:17,370
its own before rust

00:04:16,140 --> 00:04:19,770
the language is best for writing

00:04:17,370 --> 00:04:21,330
performant code would basically hand you

00:04:19,770 --> 00:04:23,490
a cannon and let you point it wherever

00:04:21,330 --> 00:04:25,380
you want it including your own feet if

00:04:23,490 --> 00:04:26,420
you read the right books you might learn

00:04:25,380 --> 00:04:28,190
some rules for writing

00:04:26,420 --> 00:04:30,890
safe code but those rules usually

00:04:28,190 --> 00:04:31,970
started with so remember every place in

00:04:30,890 --> 00:04:34,670
your entire code base where you've

00:04:31,970 --> 00:04:36,140
referenced this value and then and the

00:04:34,670 --> 00:04:38,210
languages didn't care whether on purpose

00:04:36,140 --> 00:04:38,750
or by accident you disregarded those

00:04:38,210 --> 00:04:40,850
rules

00:04:38,750 --> 00:04:42,680
there were also languages designed to

00:04:40,850 --> 00:04:45,230
help users write provably safe and

00:04:42,680 --> 00:04:47,090
correct code but well you know how the

00:04:45,230 --> 00:04:49,400
most secure server is the one that you

00:04:47,090 --> 00:04:51,740
power off and lock in a bank vault the

00:04:49,400 --> 00:04:53,780
languages that prioritize safety above

00:04:51,740 --> 00:04:56,090
everything else were historically too

00:04:53,780 --> 00:04:57,470
slow for production use and sometimes

00:04:56,090 --> 00:04:59,600
they refuse to deal with real-world

00:04:57,470 --> 00:05:00,500
challenges like networking and file i/o

00:04:59,600 --> 00:05:03,020
at all

00:05:00,500 --> 00:05:04,670
rust gets around this contradiction by

00:05:03,020 --> 00:05:07,010
doing it's a verification at compile

00:05:04,670 --> 00:05:08,930
time so once you're safe rest code is

00:05:07,010 --> 00:05:11,450
able to compile it's guaranteed to be

00:05:08,930 --> 00:05:13,070
free from undefined behavior instead of

00:05:11,450 --> 00:05:15,110
asking people to remember all these

00:05:13,070 --> 00:05:16,610
rules for writing safe code the computer

00:05:15,110 --> 00:05:18,650
enforces them for you

00:05:16,610 --> 00:05:21,110
computers are way better at cute than

00:05:18,650 --> 00:05:24,080
humans at keeping track of hundreds of

00:05:21,110 --> 00:05:25,970
things at once so the lesson that I've

00:05:24,080 --> 00:05:28,040
taken away from rusts in each in the

00:05:25,970 --> 00:05:30,410
ecosystem that I try to apply to other

00:05:28,040 --> 00:05:32,330
projects is how useful it can be to find

00:05:30,410 --> 00:05:33,890
intersections between problems or

00:05:32,330 --> 00:05:36,440
projects that haven't been fully

00:05:33,890 --> 00:05:38,600
explored when people who focused on safe

00:05:36,440 --> 00:05:40,940
languages and people who focused on fast

00:05:38,600 --> 00:05:42,320
languages teamed up they managed to

00:05:40,940 --> 00:05:45,980
create something that was better than

00:05:42,320 --> 00:05:47,690
either of those alone and rusts founders

00:05:45,980 --> 00:05:49,550
weren't content to just address the

00:05:47,690 --> 00:05:51,590
apparent dichotomy between code safety

00:05:49,550 --> 00:05:52,820
and performance they also set up their

00:05:51,590 --> 00:05:55,190
community in a way that addresses

00:05:52,820 --> 00:05:56,990
incompatibilities between humans I'm

00:05:55,190 --> 00:05:59,030
sure you've noticed in your own

00:05:56,990 --> 00:06:01,130
communities there are some individuals

00:05:59,030 --> 00:06:04,790
who just won't be content unless they

00:06:01,130 --> 00:06:06,500
can communicate a certain way and there

00:06:04,790 --> 00:06:08,170
are others who won't be content unless

00:06:06,500 --> 00:06:11,150
they can avoid that kind of

00:06:08,170 --> 00:06:12,830
communication our solution to that

00:06:11,150 --> 00:06:14,690
problem is rusts code of conduct

00:06:12,830 --> 00:06:16,670
defining what behaviors are desirable

00:06:14,690 --> 00:06:18,800
when working with and when working on

00:06:16,670 --> 00:06:21,260
the language and what behaviors result

00:06:18,800 --> 00:06:22,880
in warnings and then removal this was

00:06:21,260 --> 00:06:25,040
originally a controversial decision

00:06:22,880 --> 00:06:26,960
people were accustomed to communities

00:06:25,040 --> 00:06:29,150
where whoever got there first forgot to

00:06:26,960 --> 00:06:31,760
set the culture and scare off anyone who

00:06:29,150 --> 00:06:33,710
disagreed with them whereas in rust the

00:06:31,760 --> 00:06:35,780
leaders were explicitly choosing the

00:06:33,710 --> 00:06:38,390
values that they wanted rather than just

00:06:35,780 --> 00:06:38,920
letting it happen people who disapproved

00:06:38,390 --> 00:06:40,780
of the ko

00:06:38,920 --> 00:06:42,370
of conduct were certain that refusing to

00:06:40,780 --> 00:06:44,140
accept contributions from those who

00:06:42,370 --> 00:06:47,140
violated the rules would hurt the

00:06:44,140 --> 00:06:49,240
project I can't necessarily blame them

00:06:47,140 --> 00:06:50,800
for thinking that it's easy to assume

00:06:49,240 --> 00:06:52,720
that the amount of contribution that

00:06:50,800 --> 00:06:55,270
each individual can bring to a project

00:06:52,720 --> 00:06:57,490
is somehow fixed so taking one

00:06:55,270 --> 00:07:00,130
contributor away might reduce the total

00:06:57,490 --> 00:07:01,660
amount of work that gets done if all of

00:07:00,130 --> 00:07:03,370
the people who wanted to violate the

00:07:01,660 --> 00:07:05,230
Community Guidelines just packed up

00:07:03,370 --> 00:07:08,320
their keyboards and went home what would

00:07:05,230 --> 00:07:10,330
we be left with rusts big experiment

00:07:08,320 --> 00:07:11,890
with a code of conduct has shown me that

00:07:10,330 --> 00:07:13,990
excluding the people who make a

00:07:11,890 --> 00:07:15,820
community hostile doesn't earth it and

00:07:13,990 --> 00:07:18,400
might actually help the quality of the

00:07:15,820 --> 00:07:20,290
codebase the contributors who remain are

00:07:18,400 --> 00:07:22,090
able to collaborate better and get more

00:07:20,290 --> 00:07:24,400
done in a way that more than makes up

00:07:22,090 --> 00:07:25,930
for their slightly smaller numbers the

00:07:24,400 --> 00:07:27,640
guidelines aren't hurting the codebase

00:07:25,930 --> 00:07:29,410
but instead they're protecting our

00:07:27,640 --> 00:07:32,050
ability to build and pass on our

00:07:29,410 --> 00:07:33,850
understanding of it I've watched the

00:07:32,050 --> 00:07:35,830
code of conduct succeed but I very

00:07:33,850 --> 00:07:37,900
personally don't think that this means

00:07:35,830 --> 00:07:40,060
everyone else has to go apply exactly

00:07:37,900 --> 00:07:42,100
the same rules to their project

00:07:40,060 --> 00:07:43,870
I think the code of conduct is just one

00:07:42,100 --> 00:07:46,540
of many potential ways to handle

00:07:43,870 --> 00:07:48,070
incompatibilities between humans it is

00:07:46,540 --> 00:07:49,570
one of the most successful techniques

00:07:48,070 --> 00:07:51,700
for keeping an open-source community

00:07:49,570 --> 00:07:53,110
healthy that I've personally seen but

00:07:51,700 --> 00:07:54,430
that doesn't guarantee that there

00:07:53,110 --> 00:07:57,250
couldn't be something better down the

00:07:54,430 --> 00:07:59,200
road so watching those first three years

00:07:57,250 --> 00:08:01,030
of stable rust play out from my

00:07:59,200 --> 00:08:03,070
immersion in both the compiler team and

00:08:01,030 --> 00:08:05,200
the servo browser engine give me a new

00:08:03,070 --> 00:08:07,660
appreciation of how the habits of a

00:08:05,200 --> 00:08:09,520
project's first developers shaped the

00:08:07,660 --> 00:08:12,160
whole future of that project and of

00:08:09,520 --> 00:08:14,200
every project downstream from it the

00:08:12,160 --> 00:08:15,310
first tutorials and example programs in

00:08:14,200 --> 00:08:17,470
the language are written by the author

00:08:15,310 --> 00:08:19,390
the first users ideas of the language

00:08:17,470 --> 00:08:21,910
are shaped by the idioms and preferences

00:08:19,390 --> 00:08:23,380
expressed in that early code I watched

00:08:21,910 --> 00:08:25,540
how it was the people who were really

00:08:23,380 --> 00:08:27,520
passionate about the languages promise

00:08:25,540 --> 00:08:29,440
and ideals who built the libraries and

00:08:27,520 --> 00:08:31,210
then people who agreed with the way that

00:08:29,440 --> 00:08:34,360
those libraries were doing things who

00:08:31,210 --> 00:08:36,760
used them as dependencies users who

00:08:34,360 --> 00:08:38,460
found the idioms intolerable didn't

00:08:36,760 --> 00:08:40,990
stick around to become experts

00:08:38,460 --> 00:08:42,430
fortunately for us the first developers

00:08:40,990 --> 00:08:44,380
thought quite carefully about their

00:08:42,430 --> 00:08:46,000
values and intentionally selected

00:08:44,380 --> 00:08:48,700
processes that furthered both their

00:08:46,000 --> 00:08:50,860
technical and cultural goals they also

00:08:48,700 --> 00:08:51,800
tried to avoid placing filters that they

00:08:50,860 --> 00:08:53,990
didn't need

00:08:51,800 --> 00:08:56,060
hostile community or mandatory in-person

00:08:53,990 --> 00:08:57,649
meetings can needlessly filter out

00:08:56,060 --> 00:08:58,339
contributors who could have made a huge

00:08:57,649 --> 00:09:01,580
impact

00:08:58,339 --> 00:09:03,769
if you'd been accessible to them so

00:09:01,580 --> 00:09:06,050
since so many tech habits seem to be

00:09:03,769 --> 00:09:07,850
inherited from upstream tools let's take

00:09:06,050 --> 00:09:09,290
a quick tour of how the compiler gets

00:09:07,850 --> 00:09:11,930
built so you can learn some things about

00:09:09,290 --> 00:09:13,279
rest land as a whole how do they add a

00:09:11,930 --> 00:09:15,769
new feature to the compiler

00:09:13,279 --> 00:09:17,630
well first they talk about it for the

00:09:15,769 --> 00:09:19,910
kind of long-form asynchronous

00:09:17,630 --> 00:09:22,160
conversation that most projects will use

00:09:19,910 --> 00:09:25,490
email lists for rust has chosen

00:09:22,160 --> 00:09:28,100
discourse forums and github issues these

00:09:25,490 --> 00:09:30,320
technologies beat email because of their

00:09:28,100 --> 00:09:32,540
mutable history rusts moderation team

00:09:30,320 --> 00:09:34,970
members are able to silently remove an

00:09:32,540 --> 00:09:37,190
unacceptable post they're not forced to

00:09:34,970 --> 00:09:39,589
choose between engaging with the troll

00:09:37,190 --> 00:09:42,860
or leaving the post there and making it

00:09:39,589 --> 00:09:44,510
look like it was tolerated moderators

00:09:42,860 --> 00:09:46,579
with the power to alter history in this

00:09:44,510 --> 00:09:49,010
way have earned the users trust that

00:09:46,579 --> 00:09:51,260
they won't abuse the power and those few

00:09:49,010 --> 00:09:53,420
users who truly can't stand the idea of

00:09:51,260 --> 00:09:56,570
anyone having those permissions haven't

00:09:53,420 --> 00:09:58,760
stuck around so this is a way that a

00:09:56,570 --> 00:10:00,680
careful choice of technology choosing

00:09:58,760 --> 00:10:02,000
forums that can be moderated in a way

00:10:00,680 --> 00:10:05,720
that supports our Community Guidelines

00:10:02,000 --> 00:10:07,520
has strengthened the project it's now

00:10:05,720 --> 00:10:09,170
simple changes to the compiler are made

00:10:07,520 --> 00:10:11,630
directly by pull requests to the rest

00:10:09,170 --> 00:10:13,700
repos but more substantial changes need

00:10:11,630 --> 00:10:16,250
consensus from the rest teams and also

00:10:13,700 --> 00:10:18,020
input from the users substantial changes

00:10:16,250 --> 00:10:20,480
go through the RFC or request for

00:10:18,020 --> 00:10:22,100
comment process you fork the RFC's repo

00:10:20,480 --> 00:10:24,770
you copy the template you fill it out

00:10:22,100 --> 00:10:26,720
and then you make a pull request with

00:10:24,770 --> 00:10:29,029
your language change idea then the

00:10:26,720 --> 00:10:31,490
appropriate rest sub team is assigned to

00:10:29,029 --> 00:10:32,690
triage it and everyone in the whole

00:10:31,490 --> 00:10:35,510
community and really on the whole

00:10:32,690 --> 00:10:37,850
internet can come to your PR and discuss

00:10:35,510 --> 00:10:39,320
and debate the pros and cons of it when

00:10:37,850 --> 00:10:41,060
the assigned sub team thinks the

00:10:39,320 --> 00:10:43,459
discussion is wrapping up they decide on

00:10:41,060 --> 00:10:45,230
a disposition will we merge it will we

00:10:43,459 --> 00:10:47,510
close it or will we postpone it for

00:10:45,230 --> 00:10:50,390
later and then they place the RFC into a

00:10:47,510 --> 00:10:52,579
10-day final comment period when anyone

00:10:50,390 --> 00:10:55,450
who thinks that their use case really

00:10:52,579 --> 00:10:57,490
wasn't considered by the disposition can

00:10:55,450 --> 00:10:59,980
and what they think the team needs to

00:10:57,490 --> 00:11:02,770
know so this combination of public

00:10:59,980 --> 00:11:04,570
discussion plus expert teams ultimately

00:11:02,770 --> 00:11:06,180
condensing the discussion into their

00:11:04,570 --> 00:11:08,560
idea of what's best for the language

00:11:06,180 --> 00:11:10,450
balances our need for openness and

00:11:08,560 --> 00:11:12,310
inclusion on the one hand with the need

00:11:10,450 --> 00:11:15,220
to arrive at decisions instead of just

00:11:12,310 --> 00:11:17,080
arguing forever on the other watching

00:11:15,220 --> 00:11:19,060
rust-red this line between getting

00:11:17,080 --> 00:11:20,860
voices heard and also getting decisions

00:11:19,060 --> 00:11:23,140
made has informed the way I look at

00:11:20,860 --> 00:11:25,360
other open-source communities if you

00:11:23,140 --> 00:11:27,460
discuss too much you can look for ways

00:11:25,360 --> 00:11:28,840
to wrap up conversations even when

00:11:27,460 --> 00:11:31,450
there's not a hundred percent agreement

00:11:28,840 --> 00:11:34,240
but what happens when a community swings

00:11:31,450 --> 00:11:35,860
too far toward the decisiveness end what

00:11:34,240 --> 00:11:37,630
if it feels like decisions are just

00:11:35,860 --> 00:11:40,750
getting handed down from above and the

00:11:37,630 --> 00:11:42,010
contributors are feeling ignored well to

00:11:40,750 --> 00:11:43,930
take a step back and explain some

00:11:42,010 --> 00:11:46,390
context for the way that rust faced this

00:11:43,930 --> 00:11:48,280
challenge in rust it is teams and not

00:11:46,390 --> 00:11:51,190
individuals that have the final say and

00:11:48,280 --> 00:11:53,740
whether or not to accept an RFC now the

00:11:51,190 --> 00:11:55,690
team structure is mostly amazing it's

00:11:53,740 --> 00:11:57,760
great because it allows team members to

00:11:55,690 --> 00:11:59,410
take breaks or even retire without

00:11:57,760 --> 00:12:01,420
causing a huge interruption to the

00:11:59,410 --> 00:12:03,430
languages development the structure

00:12:01,420 --> 00:12:05,590
helps team members mentor those who've

00:12:03,430 --> 00:12:07,780
newly joined and allows others to fill

00:12:05,590 --> 00:12:09,340
in the gaps when someone leaves rust

00:12:07,780 --> 00:12:11,740
people struggle with burnout just like

00:12:09,340 --> 00:12:13,330
anyone else in tech but from my own

00:12:11,740 --> 00:12:16,510
experience serving on and ultimately

00:12:13,330 --> 00:12:18,310
retiring from rusts community team I can

00:12:16,510 --> 00:12:20,530
tell you that burnout is a whole lot

00:12:18,310 --> 00:12:22,600
easier to cope with when you know that

00:12:20,530 --> 00:12:26,440
you can step back without hurting the

00:12:22,600 --> 00:12:28,540
project however the flipside is that

00:12:26,440 --> 00:12:30,670
teams can look like these scary or

00:12:28,540 --> 00:12:33,220
biased little cabal's from the outside

00:12:30,670 --> 00:12:35,350
they meet something mysterious happens a

00:12:33,220 --> 00:12:38,110
decision pops out barring no resemblance

00:12:35,350 --> 00:12:40,300
to the preceding debate rust used to

00:12:38,110 --> 00:12:42,040
have that problem but we addressed it

00:12:40,300 --> 00:12:44,680
with what we called a no new rationale

00:12:42,040 --> 00:12:47,020
rule it basically says that whether the

00:12:44,680 --> 00:12:49,330
team decides to merge close or postpone

00:12:47,020 --> 00:12:51,580
the RFC the reason for the team's

00:12:49,330 --> 00:12:55,630
decision has to have been something that

00:12:51,580 --> 00:12:57,790
was already publicly discussed this rule

00:12:55,630 --> 00:12:59,950
sets a standard from when a proposal has

00:12:57,790 --> 00:13:02,380
been discussed enough and it clearly

00:12:59,950 --> 00:13:04,960
communicates to users how teams balance

00:13:02,380 --> 00:13:06,340
debate with decisiveness it's important

00:13:04,960 --> 00:13:07,710
for contributors to feel like their

00:13:06,340 --> 00:13:09,390
participation in

00:13:07,710 --> 00:13:13,290
discussion mattered and wasn't just

00:13:09,390 --> 00:13:16,350
thrown out so having clear public and

00:13:13,290 --> 00:13:18,300
consistent rules for how we handle rfcs

00:13:16,350 --> 00:13:20,520
is actually quite a lot like having

00:13:18,300 --> 00:13:21,810
clear concrete and consistent standards

00:13:20,520 --> 00:13:23,940
for judging candidates when you're

00:13:21,810 --> 00:13:25,920
hiring it helps ensure that the

00:13:23,940 --> 00:13:28,080
selections you make are based on

00:13:25,920 --> 00:13:30,180
technical merit instead of on the bias

00:13:28,080 --> 00:13:33,900
of whoever or whatever group is making

00:13:30,180 --> 00:13:36,030
the decision so you've landed your RFC

00:13:33,900 --> 00:13:37,770
and now the code implementing its

00:13:36,030 --> 00:13:39,990
suggestions is allowed to be merged into

00:13:37,770 --> 00:13:42,330
rust all of the code that comes into the

00:13:39,990 --> 00:13:44,700
compiler does through those so through

00:13:42,330 --> 00:13:46,470
pull requests on github once someone

00:13:44,700 --> 00:13:48,270
gives an approving review on a pull

00:13:46,470 --> 00:13:50,400
request saying yeah this implements the

00:13:48,270 --> 00:13:52,770
thing that the RFC said it would a bot

00:13:50,400 --> 00:13:54,510
called Bors will run the repos tests

00:13:52,770 --> 00:13:56,700
against the state of the tree with the

00:13:54,510 --> 00:13:59,580
patch applied it then automatically

00:13:56,700 --> 00:14:01,470
lands the PR if the tests all pass this

00:13:59,580 --> 00:14:03,210
was years before github rolled out

00:14:01,470 --> 00:14:05,250
similar features that we started doing

00:14:03,210 --> 00:14:07,560
it and Boris really helped lessen the

00:14:05,250 --> 00:14:10,710
burden of code review for all of rusts

00:14:07,560 --> 00:14:12,540
developers so when a computer would be

00:14:10,710 --> 00:14:14,790
better at doing part of a task than a

00:14:12,540 --> 00:14:16,950
human whether that task is checking for

00:14:14,790 --> 00:14:18,990
use after free in the compiler or

00:14:16,950 --> 00:14:20,760
running a test like Boris does risk

00:14:18,990 --> 00:14:24,090
makes the computer and not the human do

00:14:20,760 --> 00:14:25,890
the work every six weeks new beta and

00:14:24,090 --> 00:14:27,600
stable rest versions ship although the

00:14:25,890 --> 00:14:29,520
features in them have been individually

00:14:27,600 --> 00:14:31,260
tested by Bors we're still not totally

00:14:29,520 --> 00:14:33,300
certain what that combination of

00:14:31,260 --> 00:14:34,680
features is actually gonna do what if

00:14:33,300 --> 00:14:36,810
some difference in the behavior wasn't

00:14:34,680 --> 00:14:38,400
included in the test suite yet how can

00:14:36,810 --> 00:14:40,190
we tell what really changed between the

00:14:38,400 --> 00:14:42,450
old compiler version and the new one

00:14:40,190 --> 00:14:44,490
rust answers that question through a

00:14:42,450 --> 00:14:46,860
computational brute force approach a

00:14:44,490 --> 00:14:49,650
tool called crater discovers all the

00:14:46,860 --> 00:14:52,140
rest code can find on crates do the rest

00:14:49,650 --> 00:14:54,960
package registry it takes each package

00:14:52,140 --> 00:14:57,600
in turn it compiles that crate with the

00:14:54,960 --> 00:14:59,760
old compiler and it records the output

00:14:57,600 --> 00:15:01,470
that the old tool chain gives when it

00:14:59,760 --> 00:15:03,660
compiles that crate then it takes the

00:15:01,470 --> 00:15:05,700
same crate again compiles that same

00:15:03,660 --> 00:15:07,680
crate with the new compiler and notes

00:15:05,700 --> 00:15:10,200
what output the new compiler yielded

00:15:07,680 --> 00:15:12,300
then you can diff those two outputs and

00:15:10,200 --> 00:15:14,220
any difference at all means that some

00:15:12,300 --> 00:15:16,290
feature that people are using got

00:15:14,220 --> 00:15:18,510
changed sometimes the changes were

00:15:16,290 --> 00:15:20,190
intentional but other times they were an

00:15:18,510 --> 00:15:21,660
accidental side-effect of some

00:15:20,190 --> 00:15:24,750
nation of factors that we didn't have

00:15:21,660 --> 00:15:26,190
tests for why would you ask humans to

00:15:24,750 --> 00:15:27,720
predict the side effects of a big old

00:15:26,190 --> 00:15:30,090
change set when you could make a

00:15:27,720 --> 00:15:33,210
computer actually find those differences

00:15:30,090 --> 00:15:35,190
for you our human solving any problems

00:15:33,210 --> 00:15:36,720
in your current projects that would be

00:15:35,190 --> 00:15:40,500
better addressed by just making the

00:15:36,720 --> 00:15:41,970
computer to it so the final piece of

00:15:40,500 --> 00:15:44,010
culture from the rest compilers

00:15:41,970 --> 00:15:45,480
development that I've seen propagated

00:15:44,010 --> 00:15:48,000
through its projects is a certain

00:15:45,480 --> 00:15:49,830
delight in documentation the quality of

00:15:48,000 --> 00:15:52,050
rusts books is a point of pride for

00:15:49,830 --> 00:15:54,690
those who work on the language and a new

00:15:52,050 --> 00:15:56,640
feature often isn't well regarded as

00:15:54,690 --> 00:15:58,350
truly finished until it's documented

00:15:56,640 --> 00:16:01,200
enough for users to start incorporating

00:15:58,350 --> 00:16:03,270
it in their own code the cultural value

00:16:01,200 --> 00:16:05,340
of clear documentation shows up in the

00:16:03,270 --> 00:16:07,170
code too there are times when the

00:16:05,340 --> 00:16:09,660
compiler forces you to spell out exactly

00:16:07,170 --> 00:16:12,150
what you meant not because it needs you

00:16:09,660 --> 00:16:15,180
to tell it but so that you can see that

00:16:12,150 --> 00:16:16,950
later so that's a handful of things to

00:16:15,180 --> 00:16:18,570
expect from project cultures descended

00:16:16,950 --> 00:16:20,190
from the rest compiler look for

00:16:18,570 --> 00:16:22,260
familiarity with working in small teams

00:16:20,190 --> 00:16:24,420
or committees a balance between public

00:16:22,260 --> 00:16:26,280
debate and definitive decision-making

00:16:24,420 --> 00:16:29,040
willingness to invest in good

00:16:26,280 --> 00:16:30,780
documentation and this enthusiasm for

00:16:29,040 --> 00:16:34,770
transferring work from humans to

00:16:30,780 --> 00:16:36,960
machines wherever possible these values

00:16:34,770 --> 00:16:38,700
can get diluted by other constraints as

00:16:36,960 --> 00:16:40,440
they're passed along into libraries and

00:16:38,700 --> 00:16:42,210
then into projects using those libraries

00:16:40,440 --> 00:16:44,280
but they're always there if you look for

00:16:42,210 --> 00:16:46,470
them I think it's worth looking around

00:16:44,280 --> 00:16:48,150
your own projects as well to spot the

00:16:46,470 --> 00:16:50,430
ways in which upstream developers

00:16:48,150 --> 00:16:52,410
influenced your culture maybe it's in a

00:16:50,430 --> 00:16:54,030
positive way by demonstrating the

00:16:52,410 --> 00:16:55,980
benefits of some technique that you use

00:16:54,030 --> 00:16:57,840
extensively or maybe it's in a negative

00:16:55,980 --> 00:17:00,150
way because their choices deterred

00:16:57,840 --> 00:17:04,319
contributors who held some conflicting

00:17:00,150 --> 00:17:06,089
ideal to the languages so we are using

00:17:04,319 --> 00:17:08,400
this great process to build a language

00:17:06,089 --> 00:17:10,770
but what is the language itself good for

00:17:08,400 --> 00:17:13,199
rust might be a good choice for your

00:17:10,770 --> 00:17:15,810
project if you need a fast and memory

00:17:13,199 --> 00:17:18,720
safe language and you're using an LLVM

00:17:15,810 --> 00:17:21,360
supported architecture rusts ability to

00:17:18,720 --> 00:17:23,520
compile efficient code is built on the

00:17:21,360 --> 00:17:25,620
work that the LLVM or low-level virtual

00:17:23,520 --> 00:17:27,300
machine authors have put in the rust

00:17:25,620 --> 00:17:30,420
compiler emits an intermediate

00:17:27,300 --> 00:17:31,230
representation which LLVM transforms

00:17:30,420 --> 00:17:33,539
into an

00:17:31,230 --> 00:17:35,399
executable for the target platform that

00:17:33,539 --> 00:17:37,649
you're building your code for by

00:17:35,399 --> 00:17:40,679
cooperating rather than competing with

00:17:37,649 --> 00:17:43,590
the LLVM ecosystem both projects win

00:17:40,679 --> 00:17:45,480
rust gets the benefits of LLVM s work

00:17:43,590 --> 00:17:48,929
and years of testing and support for

00:17:45,480 --> 00:17:51,059
obscure platforms and LLVM gets bug

00:17:48,929 --> 00:17:53,760
reports and fixes from people who are

00:17:51,059 --> 00:17:55,700
using features of its more aggressively

00:17:53,760 --> 00:17:58,590
than anyone has ever used before and

00:17:55,700 --> 00:18:00,450
that's not even touching on the time and

00:17:58,590 --> 00:18:03,090
the energy that we've saved by not

00:18:00,450 --> 00:18:07,049
trying to write a project like LLVM

00:18:03,090 --> 00:18:08,610
again from scratch so if you start

00:18:07,049 --> 00:18:10,230
looking for a rest version to install

00:18:08,610 --> 00:18:11,820
you'll find that you have this

00:18:10,230 --> 00:18:13,620
smorgasbord of choices

00:18:11,820 --> 00:18:16,350
would you like stable beta or nightly

00:18:13,620 --> 00:18:18,960
regular rest or the 2018 edition flavor

00:18:16,350 --> 00:18:21,179
for a language that tries to be easy to

00:18:18,960 --> 00:18:23,610
use why are they confusing it with all

00:18:21,179 --> 00:18:26,070
these choices right from the start well

00:18:23,610 --> 00:18:28,049
every project sees different kinds of

00:18:26,070 --> 00:18:30,450
users through its lifecycle because a

00:18:28,049 --> 00:18:32,220
brand new project has totally different

00:18:30,450 --> 00:18:33,750
benefits to offer to its users than

00:18:32,220 --> 00:18:36,450
something that's made it to enterprise

00:18:33,750 --> 00:18:38,340
scale at first the users that you get

00:18:36,450 --> 00:18:40,139
our early adopters they're the people

00:18:38,340 --> 00:18:42,120
with the time and initiative to play

00:18:40,139 --> 00:18:43,679
with any old brand new technology that

00:18:42,120 --> 00:18:45,149
strikes their fancy just because it's

00:18:43,679 --> 00:18:48,480
fun to make the computer do what they

00:18:45,149 --> 00:18:50,190
say and then as your project grows the

00:18:48,480 --> 00:18:52,350
first adventurers make useful and

00:18:50,190 --> 00:18:54,120
impressive things and those attract just

00:18:52,350 --> 00:18:56,010
regular users who are looking for a

00:18:54,120 --> 00:19:00,149
reliable tool with some certain feature

00:18:56,010 --> 00:19:02,190
that they need eventually if a project

00:19:00,149 --> 00:19:04,380
or language gets really big it also

00:19:02,190 --> 00:19:06,750
needs legacy support for decades

00:19:04,380 --> 00:19:08,970
governments and corporations adopt the

00:19:06,750 --> 00:19:11,429
products that users within them selected

00:19:08,970 --> 00:19:13,710
and even an annual release cycle can be

00:19:11,429 --> 00:19:15,600
too fast for them to keep up with with

00:19:13,710 --> 00:19:18,570
all of those different sets of needs in

00:19:15,600 --> 00:19:21,570
play which group is the one that gets

00:19:18,570 --> 00:19:23,669
what they want well as with the speed

00:19:21,570 --> 00:19:25,799
and safety trade-offs rust answer to

00:19:23,669 --> 00:19:28,529
that apparent contradiction is how about

00:19:25,799 --> 00:19:30,299
all of them the stable channel of rest

00:19:28,529 --> 00:19:31,980
represents the set of features that the

00:19:30,299 --> 00:19:33,720
project has committed to supporting long

00:19:31,980 --> 00:19:35,700
term the beta channel contains

00:19:33,720 --> 00:19:37,950
candidates for inclusion into stable and

00:19:35,700 --> 00:19:39,450
nightly is a bunch of experimental stuff

00:19:37,950 --> 00:19:41,159
that we're not even sure yet whether

00:19:39,450 --> 00:19:44,100
it's going to be possible to stabilize

00:19:41,159 --> 00:19:44,850
eventually culturally restate ins are

00:19:44,100 --> 00:19:46,770
trained to use

00:19:44,850 --> 00:19:48,240
stable if you can and you only switch

00:19:46,770 --> 00:19:50,130
over to beta or nightly if you need

00:19:48,240 --> 00:19:53,130
something that's not available in stable

00:19:50,130 --> 00:19:55,350
so this structure of channel definitions

00:19:53,130 --> 00:19:57,690
helps streamline communication about

00:19:55,350 --> 00:20:00,000
features implicitly answering questions

00:19:57,690 --> 00:20:02,310
like will this feature still be here in

00:20:00,000 --> 00:20:03,870
the next release or should I expect this

00:20:02,310 --> 00:20:07,260
to just work or might it be a little

00:20:03,870 --> 00:20:09,510
rough around the edges at first the plan

00:20:07,260 --> 00:20:11,280
for rust was that every stable version

00:20:09,510 --> 00:20:14,400
should be backwards compatible to every

00:20:11,280 --> 00:20:14,970
other stable version back to 1.0 forever

00:20:14,400 --> 00:20:17,460
and ever

00:20:14,970 --> 00:20:19,230
but as the language matured we kept

00:20:17,460 --> 00:20:21,510
finding places where you could get this

00:20:19,230 --> 00:20:22,830
huge usability improvement if only you

00:20:21,510 --> 00:20:24,510
could make a little tweak to the

00:20:22,830 --> 00:20:28,350
backwards compatibility just take that

00:20:24,510 --> 00:20:30,750
one thing out so crushed under this pile

00:20:28,350 --> 00:20:33,450
of dependencies we built an escape hatch

00:20:30,750 --> 00:20:35,340
that escaped from being stuck with the

00:20:33,450 --> 00:20:37,080
usability drawbacks of backwards

00:20:35,340 --> 00:20:39,480
compatibility came in the form of

00:20:37,080 --> 00:20:41,700
additions each new addition is allowed

00:20:39,480 --> 00:20:43,440
to remove backwards compatibility from

00:20:41,700 --> 00:20:45,420
the previous one when the authors need

00:20:43,440 --> 00:20:48,180
to do so to improve other aspects of the

00:20:45,420 --> 00:20:50,190
language so like channels additions are

00:20:48,180 --> 00:20:51,930
a social device for communicating to

00:20:50,190 --> 00:20:55,530
users and other developers what to

00:20:51,930 --> 00:20:57,210
expect from a given rust additions are a

00:20:55,530 --> 00:20:58,830
positive outcome from a time when we

00:20:57,210 --> 00:21:01,470
didn't think of everything at the start

00:20:58,830 --> 00:21:04,290
of a project but we used the established

00:21:01,470 --> 00:21:06,090
processes for discussing and designing

00:21:04,290 --> 00:21:08,820
and implementing changes to the language

00:21:06,090 --> 00:21:10,740
to retrofit additions in a backwards

00:21:08,820 --> 00:21:14,850
compatible way that met the conflicting

00:21:10,740 --> 00:21:16,650
needs of various users so this is all

00:21:14,850 --> 00:21:18,690
sounding great right let's jump on this

00:21:16,650 --> 00:21:23,190
bandwagon and rewrite all of our code in

00:21:18,690 --> 00:21:25,950
rust please don't please don't form any

00:21:23,190 --> 00:21:28,440
established projects rewriting it in any

00:21:25,950 --> 00:21:30,390
language at all would be disastrous for

00:21:28,440 --> 00:21:33,180
both your reliability and your release

00:21:30,390 --> 00:21:35,670
schedule one of the most valuable skills

00:21:33,180 --> 00:21:38,700
of rusts leadership team is the ability

00:21:35,670 --> 00:21:39,930
to say no no our community is not the

00:21:38,700 --> 00:21:42,480
place you're looking for if you want to

00:21:39,930 --> 00:21:44,010
behave like this know the trade-offs

00:21:42,480 --> 00:21:45,870
that would be required to add that

00:21:44,010 --> 00:21:47,880
feature are not something that will

00:21:45,870 --> 00:21:50,520
benefit the language at this time in

00:21:47,880 --> 00:21:53,250
order to attain its vision any project

00:21:50,520 --> 00:21:55,940
needs to get good at saying no to trends

00:21:53,250 --> 00:21:57,600
that take it further away from its goals

00:21:55,940 --> 00:21:59,980
but

00:21:57,600 --> 00:22:02,170
sometimes you find a point where your

00:21:59,980 --> 00:22:03,820
current language or framework is just

00:22:02,170 --> 00:22:06,670
overburdened by the demands you've

00:22:03,820 --> 00:22:09,100
placed on it don't immediately throw the

00:22:06,670 --> 00:22:11,320
whole thing out see if you can refactor

00:22:09,100 --> 00:22:13,780
the hard part into a few separate

00:22:11,320 --> 00:22:16,630
functions with clear expectations about

00:22:13,780 --> 00:22:18,400
their inputs and outputs and then try

00:22:16,630 --> 00:22:19,870
rewriting just those functions in a

00:22:18,400 --> 00:22:21,730
language that might be better suited to

00:22:19,870 --> 00:22:24,280
their needs yeah that language might be

00:22:21,730 --> 00:22:26,380
rest and use FFI or foreign function

00:22:24,280 --> 00:22:29,020
interface to embed the improved versions

00:22:26,380 --> 00:22:30,490
in your original codebase you might be

00:22:29,020 --> 00:22:32,170
able to keep all of the work you've

00:22:30,490 --> 00:22:34,570
invested in the rest of the project

00:22:32,170 --> 00:22:36,160
while refactoring a former bottleneck

00:22:34,570 --> 00:22:39,910
into a language better suited to

00:22:36,160 --> 00:22:41,830
handling so what might using rust look

00:22:39,910 --> 00:22:44,230
like from the perspective of someone who

00:22:41,830 --> 00:22:46,930
just wants to fi2 it and speed up some

00:22:44,230 --> 00:22:49,330
hot code well first you'll need a rest

00:22:46,930 --> 00:22:51,070
compiler the easy way to install and run

00:22:49,330 --> 00:22:53,650
rusts locally is a tool called rest up

00:22:51,070 --> 00:22:57,160
you can get it at rest up RS we like our

00:22:53,650 --> 00:22:59,860
RS domains if you'd prefer if you don't

00:22:57,160 --> 00:23:01,840
want to curl it read it execute it like

00:22:59,860 --> 00:23:03,520
any other script that you might have

00:23:01,840 --> 00:23:04,810
written yourself you can download a

00:23:03,520 --> 00:23:06,520
release directly from a standalone

00:23:04,810 --> 00:23:08,460
installer or you can even compile it

00:23:06,520 --> 00:23:11,170
yourself whatever makes you happy

00:23:08,460 --> 00:23:13,300
anyways to find published binaries and

00:23:11,170 --> 00:23:15,670
libraries to run and use you can look on

00:23:13,300 --> 00:23:18,100
rusts package repository crates dot io

00:23:15,670 --> 00:23:20,560
and on github when you start writing

00:23:18,100 --> 00:23:22,420
rust you also might want features like

00:23:20,560 --> 00:23:24,940
syntax highlighting an auto completion

00:23:22,420 --> 00:23:27,370
in your favorite editor you can check

00:23:24,940 --> 00:23:29,710
our we IDE yet calm for the status of

00:23:27,370 --> 00:23:32,050
rust support in various editors the rest

00:23:29,710 --> 00:23:34,480
language server the RLS that we released

00:23:32,050 --> 00:23:36,730
in 2017 exposes an intermediate

00:23:34,480 --> 00:23:39,430
representation of rust code to editors

00:23:36,730 --> 00:23:41,740
and gives a single interface for the

00:23:39,430 --> 00:23:43,750
compiler team to test and maintain for

00:23:41,740 --> 00:23:46,690
supporting all of the different editors

00:23:43,750 --> 00:23:48,490
so if your editor isn't supported you

00:23:46,690 --> 00:23:51,550
can add rest functionality for it

00:23:48,490 --> 00:23:53,850
without creating extra work for the rest

00:23:51,550 --> 00:23:57,700
compiler team to have to keep track of

00:23:53,850 --> 00:23:59,590
so let's say we found part of a Python

00:23:57,700 --> 00:24:01,270
app maybe it's part of your Django site

00:23:59,590 --> 00:24:02,110
that's just doing something really

00:24:01,270 --> 00:24:04,510
slowly

00:24:02,110 --> 00:24:05,560
I've contrived an example so just

00:24:04,510 --> 00:24:07,030
pretend with me

00:24:05,560 --> 00:24:09,160
that we're doing a site for people who

00:24:07,030 --> 00:24:10,770
are into numerology and we're gonna find

00:24:09,160 --> 00:24:13,200
their lucky digit

00:24:10,770 --> 00:24:15,090
by summing up all of the digits of all

00:24:13,200 --> 00:24:17,640
of the integers up to some big number to

00:24:15,090 --> 00:24:18,870
get the lucky digit for that number you

00:24:17,640 --> 00:24:20,580
can get all of the code I'm going to

00:24:18,870 --> 00:24:22,980
show you a little bit of code it's not

00:24:20,580 --> 00:24:24,690
too scary it's in a big font from github

00:24:22,980 --> 00:24:28,020
right there if you'd rather read it on

00:24:24,690 --> 00:24:29,670
your screen and then on mine so I

00:24:28,020 --> 00:24:31,920
invented this problem because it can

00:24:29,670 --> 00:24:34,470
force your CPU to meditate for a rather

00:24:31,920 --> 00:24:36,240
long time on rather large numbers while

00:24:34,470 --> 00:24:38,250
also yielding an output that we can

00:24:36,240 --> 00:24:41,520
check for correctness by hand on the

00:24:38,250 --> 00:24:43,590
small numbers so I've written this

00:24:41,520 --> 00:24:45,990
little numerology thing in Python some

00:24:43,590 --> 00:24:47,430
note pi has some code that does the

00:24:45,990 --> 00:24:49,380
thing that our imaginary website would

00:24:47,430 --> 00:24:51,810
how is it going to perform on large

00:24:49,380 --> 00:24:53,880
inputs I wrote a little script gets

00:24:51,810 --> 00:24:55,740
timer dot pi in the repo that compares

00:24:53,880 --> 00:24:58,260
the time before and after the code runs

00:24:55,740 --> 00:25:00,240
not super precise turns out it doesn't

00:24:58,260 --> 00:25:01,950
need to be here's a graph that's going

00:25:00,240 --> 00:25:04,230
to confirm your intuition when the

00:25:01,950 --> 00:25:06,030
inputs get big the times get bad the

00:25:04,230 --> 00:25:08,070
inputs get bigger the times get better

00:25:06,030 --> 00:25:09,840
with no end in sight if you're really

00:25:08,070 --> 00:25:11,940
good at math you might be able to change

00:25:09,840 --> 00:25:13,140
what algorithm you're using to find a

00:25:11,940 --> 00:25:15,720
better one instead of this naive

00:25:13,140 --> 00:25:17,850
solution but let's say that this is a

00:25:15,720 --> 00:25:20,430
problem that we can't just math our way

00:25:17,850 --> 00:25:22,350
out of so if we're seeing performance

00:25:20,430 --> 00:25:24,480
like this what can we do about it

00:25:22,350 --> 00:25:26,820
well we've already done the first step

00:25:24,480 --> 00:25:28,800
where we factor out the hot code the

00:25:26,820 --> 00:25:30,510
difficult or the slow bits the heavy

00:25:28,800 --> 00:25:33,000
lifting that the primary language isn't

00:25:30,510 --> 00:25:35,940
handling so well into its own couple of

00:25:33,000 --> 00:25:38,070
functions next let's try writing that

00:25:35,940 --> 00:25:40,410
exact same pair of functions in rust

00:25:38,070 --> 00:25:41,910
let's see if the compiler optimizations

00:25:40,410 --> 00:25:45,840
are better at math than I am

00:25:41,910 --> 00:25:48,240
they totally are so here we have our

00:25:45,840 --> 00:25:50,580
Python from before on the left and some

00:25:48,240 --> 00:25:52,890
equivalent rest code on the right they

00:25:50,580 --> 00:25:54,960
look almost identical there are a few

00:25:52,890 --> 00:25:57,960
places where rust demands that you state

00:25:54,960 --> 00:25:59,550
explicitly what you meant and Python is

00:25:57,960 --> 00:26:02,790
happy to let you take a guess and

00:25:59,550 --> 00:26:04,800
figures it'll be close enough but on the

00:26:02,790 --> 00:26:07,170
whole it's a familiar structure with

00:26:04,800 --> 00:26:09,210
familiar control flow I'll bet you can

00:26:07,170 --> 00:26:11,340
look at this rest code and tell me what

00:26:09,210 --> 00:26:15,540
it does just about as well as you could

00:26:11,340 --> 00:26:17,760
explain to me that same Python one of

00:26:15,540 --> 00:26:19,860
rusts big differences from Python is the

00:26:17,760 --> 00:26:22,620
white spaces only matter to separate

00:26:19,860 --> 00:26:24,809
tokens scopes enclosed by curry

00:26:22,620 --> 00:26:26,940
braces and semicolons terminating

00:26:24,809 --> 00:26:29,340
expressions serve the purpose for which

00:26:26,940 --> 00:26:32,220
Python uses spaces or cabs and new lines

00:26:29,340 --> 00:26:34,050
this irrelevance of whitespace makes it

00:26:32,220 --> 00:26:37,620
possible to format rest code in an

00:26:34,050 --> 00:26:39,510
almost unbounded number of ways but most

00:26:37,620 --> 00:26:42,210
of these ways are almost impossible to

00:26:39,510 --> 00:26:44,610
read when you want to write idiomatic

00:26:42,210 --> 00:26:47,700
rest use the tools rest formats felt

00:26:44,610 --> 00:26:49,680
like that and Clippy rest format will

00:26:47,700 --> 00:26:52,260
format your code for you into standard

00:26:49,680 --> 00:26:54,240
indentation and Clippy is actually

00:26:52,260 --> 00:26:56,130
helpful we're just like that about names

00:26:54,240 --> 00:26:57,510
Clippy will suggest other improvements

00:26:56,130 --> 00:27:01,850
what else are you going to name a tool

00:26:57,510 --> 00:27:04,350
that suggests fixes for you by using

00:27:01,850 --> 00:27:06,150
opinionated tools to standardize the

00:27:04,350 --> 00:27:08,700
spike Shetty stuff like how are we gonna

00:27:06,150 --> 00:27:10,950
format our code we have more human brain

00:27:08,700 --> 00:27:12,570
power left over to do the interesting

00:27:10,950 --> 00:27:15,000
parts like worrying about the actual

00:27:12,570 --> 00:27:16,679
logic I know that in Python that

00:27:15,000 --> 00:27:18,780
decision has been made for you but maybe

00:27:16,679 --> 00:27:20,640
you have an analogous debate where you

00:27:18,780 --> 00:27:22,920
can just pick a solution that's

00:27:20,640 --> 00:27:25,679
tolerable to everyone automate that

00:27:22,920 --> 00:27:27,600
solution and then move on to whatever it

00:27:25,679 --> 00:27:30,900
was that you were avoiding by arguing

00:27:27,600 --> 00:27:33,210
about those details so to help the

00:27:30,900 --> 00:27:35,220
compiler enforce the safety promises

00:27:33,210 --> 00:27:37,440
that it makes our rest functions have

00:27:35,220 --> 00:27:40,830
tight signatures at their starts these

00:27:37,440 --> 00:27:44,100
say for instance I will take an input of

00:27:40,830 --> 00:27:46,710
the name something and the type use 64

00:27:44,100 --> 00:27:49,920
that for an unsigned 64 bit in you can

00:27:46,710 --> 00:27:51,420
look up the types on the repo and while

00:27:49,920 --> 00:27:53,280
you're starting out you can just copy

00:27:51,420 --> 00:27:56,880
them from example code it'll probably be

00:27:53,280 --> 00:27:58,830
okay and I promise I'll give you a back

00:27:56,880 --> 00:28:01,800
of type of the thing after the arrow so

00:27:58,830 --> 00:28:03,059
another unsigned 64 bit end so you can

00:28:01,800 --> 00:28:05,490
also just not promise you'll give

00:28:03,059 --> 00:28:07,200
anything back that's cool too so it

00:28:05,490 --> 00:28:08,850
wouldn't be technically impossible to

00:28:07,200 --> 00:28:10,830
get the compiler to figure out some of

00:28:08,850 --> 00:28:12,840
these types from context but it turns

00:28:10,830 --> 00:28:15,510
out that humans find it helpful to be

00:28:12,840 --> 00:28:17,010
reminded of what they plan to do what

00:28:15,510 --> 00:28:19,860
they plan to take in and what they plan

00:28:17,010 --> 00:28:22,620
to give back so just because it's

00:28:19,860 --> 00:28:24,090
possible to automate some tasks doesn't

00:28:22,620 --> 00:28:27,150
mean it would necessarily make life

00:28:24,090 --> 00:28:29,280
easier forcing people to write down what

00:28:27,150 --> 00:28:30,840
they meant rather than just guessing

00:28:29,280 --> 00:28:33,390
what they meant from what they said is

00:28:30,840 --> 00:28:34,400
one of the best ways to catch accidental

00:28:33,390 --> 00:28:36,470
mismatches

00:28:34,400 --> 00:28:39,890
between what the programmer intended and

00:28:36,470 --> 00:28:41,720
what they actually wrote so rusts first

00:28:39,890 --> 00:28:44,180
but first biggest difference from Python

00:28:41,720 --> 00:28:47,780
of course is that rest code containing

00:28:44,180 --> 00:28:49,700
undefined behavior cannot be compiled no

00:28:47,780 --> 00:28:51,560
matter how sure the author was that

00:28:49,700 --> 00:28:54,890
their code was right the compiler

00:28:51,560 --> 00:28:57,290
steadfastly refuses to omit any part of

00:28:54,890 --> 00:29:00,050
a finished program until the whole thing

00:28:57,290 --> 00:29:02,360
passes all of its checks I've personally

00:29:00,050 --> 00:29:04,370
noticed a level of humility in expert

00:29:02,360 --> 00:29:06,500
rust programmers that's rarely matched

00:29:04,370 --> 00:29:08,720
in other language communities I think

00:29:06,500 --> 00:29:10,760
maybe being told no by the compiler

00:29:08,720 --> 00:29:13,420
dozens or even hundreds of times a day

00:29:10,760 --> 00:29:15,470
when they were sure they were right

00:29:13,420 --> 00:29:18,740
changes a bit of their certainty about

00:29:15,470 --> 00:29:20,720
their own perspectives so you'll see

00:29:18,740 --> 00:29:23,480
here that I introduced a bug there I

00:29:20,720 --> 00:29:25,280
didn't tell it that I wanted that value

00:29:23,480 --> 00:29:28,540
to be able to be changed and then I

00:29:25,280 --> 00:29:31,730
tried to change it and it's like hey you

00:29:28,540 --> 00:29:34,640
you didn't you know you might have

00:29:31,730 --> 00:29:36,230
wanted to make that mutable so don't be

00:29:34,640 --> 00:29:38,630
afraid of rust errors if you're playing

00:29:36,230 --> 00:29:40,160
with it we really want them to help you

00:29:38,630 --> 00:29:44,270
and if you find an error that does

00:29:40,160 --> 00:29:46,880
mislead you that is a bug so on the one

00:29:44,270 --> 00:29:48,920
hand this perfectionism rearranges the

00:29:46,880 --> 00:29:51,830
development process from write it then

00:29:48,920 --> 00:29:54,050
run it to debug it to more like write it

00:29:51,830 --> 00:29:56,360
then debug it then rewrite it then debug

00:29:54,050 --> 00:29:58,190
it then research what's going on and

00:29:56,360 --> 00:30:00,710
then debug it and then swear at it a bit

00:29:58,190 --> 00:30:02,450
and then debug it and then maybe cry and

00:30:00,710 --> 00:30:05,870
then debug it and then you finally run

00:30:02,450 --> 00:30:08,660
it but once your code does compile

00:30:05,870 --> 00:30:11,150
you know that it's free from undefined

00:30:08,660 --> 00:30:12,560
behavior you know that if you promised

00:30:11,150 --> 00:30:14,630
you'd give a certain type back from a

00:30:12,560 --> 00:30:16,540
function there is no path through that

00:30:14,630 --> 00:30:19,400
function that would yield any other type

00:30:16,540 --> 00:30:21,650
so pretty cool we've got the same code

00:30:19,400 --> 00:30:22,160
in rust that we had in Python what comes

00:30:21,650 --> 00:30:24,140
next

00:30:22,160 --> 00:30:25,910
do we have to rewrite the whole rest of

00:30:24,140 --> 00:30:29,920
the app in rust to take advantage of the

00:30:25,910 --> 00:30:32,720
speed ups you know the answer here No

00:30:29,920 --> 00:30:34,400
most established languages Python

00:30:32,720 --> 00:30:36,890
included do have foreign function

00:30:34,400 --> 00:30:38,870
interface that's meant for calling C

00:30:36,890 --> 00:30:41,630
code kind of like how you'd call any

00:30:38,870 --> 00:30:43,280
other function so we're gonna fib to the

00:30:41,630 --> 00:30:45,830
interpreter just a little bit but it's

00:30:43,280 --> 00:30:46,759
gonna be okay in our Python code we're

00:30:45,830 --> 00:30:49,219
gonna say

00:30:46,759 --> 00:30:52,279
I have the C dynamically linked library

00:30:49,219 --> 00:30:55,129
for you so we're gonna import C DLL from

00:30:52,279 --> 00:30:57,769
C types we're going to load the library

00:30:55,129 --> 00:31:00,349
that we wrote and then we're gonna call

00:30:57,769 --> 00:31:02,029
the function from within the library so

00:31:00,349 --> 00:31:04,249
the boilerplate up at the start I

00:31:02,029 --> 00:31:06,440
inherited it from Alex Crichton's FFI

00:31:04,249 --> 00:31:08,269
examples repo and I think that it

00:31:06,440 --> 00:31:10,129
probably makes the names right so that

00:31:08,269 --> 00:31:11,629
this works on Mac or Windows I don't

00:31:10,129 --> 00:31:14,599
personally run either of those systems

00:31:11,629 --> 00:31:16,969
so I've only tested it on Linux but this

00:31:14,599 --> 00:31:19,539
is all that we will need in Python to

00:31:16,969 --> 00:31:22,759
load the rest once we get the rest ready

00:31:19,539 --> 00:31:24,229
now all the rest side there are a couple

00:31:22,759 --> 00:31:26,449
of extra steps that we're gonna make

00:31:24,229 --> 00:31:29,119
just to make sure that rest emits a

00:31:26,449 --> 00:31:30,919
binary that looks like a C DLL to the

00:31:29,119 --> 00:31:32,929
rest of the world I've done them here

00:31:30,919 --> 00:31:35,239
the function needs to be public and

00:31:32,929 --> 00:31:37,519
external so that it's exposed in the

00:31:35,239 --> 00:31:39,769
library after compilation and we also

00:31:37,519 --> 00:31:41,239
specify to a compiler that we're kind of

00:31:39,769 --> 00:31:43,909
try and make it look like C once it's

00:31:41,239 --> 00:31:46,219
compiled and we give the compiler the no

00:31:43,909 --> 00:31:48,079
mangle directive which tells it hey I'm

00:31:46,219 --> 00:31:50,539
gonna need this function to keep having

00:31:48,079 --> 00:31:52,909
the same name in the compiled library so

00:31:50,539 --> 00:31:54,529
I know you could optimize it so much you

00:31:52,909 --> 00:31:56,029
call it like three or something but

00:31:54,529 --> 00:31:58,399
please don't do that this time around

00:31:56,029 --> 00:32:00,589
now that we've nicely asked our compiler

00:31:58,399 --> 00:32:03,169
not to mangle our function we're also

00:32:00,589 --> 00:32:04,669
gonna edit our cargo Tamil which is

00:32:03,169 --> 00:32:07,909
directives to the build system and

00:32:04,669 --> 00:32:10,279
package manager that says we're going to

00:32:07,909 --> 00:32:13,279
use a 20-18 edition here and we're gonna

00:32:10,279 --> 00:32:15,559
be compiling a dynamic library so now

00:32:13,279 --> 00:32:18,619
all we got to do is run cargo build and

00:32:15,559 --> 00:32:20,959
that puts makes the shared object files

00:32:18,619 --> 00:32:22,909
and puts them into a target folder which

00:32:20,959 --> 00:32:27,259
conveniently is right where we told the

00:32:22,909 --> 00:32:29,059
Python to look for them so with that we

00:32:27,259 --> 00:32:30,709
can ask my poor little laptop to

00:32:29,059 --> 00:32:32,899
contemplate the lucky digits of some

00:32:30,709 --> 00:32:35,389
bogglingly large numbers and compare how

00:32:32,899 --> 00:32:37,509
long the Python on its own takes versus

00:32:35,389 --> 00:32:40,219
the Python that's letting rest help out

00:32:37,509 --> 00:32:42,679
for tiny little inputs they're pretty

00:32:40,219 --> 00:32:44,719
close with the native Python maybe even

00:32:42,679 --> 00:32:46,190
a smidgen faster because it doesn't have

00:32:44,719 --> 00:32:48,169
the overhead of calling out to some

00:32:46,190 --> 00:32:50,359
other library but when the inputs get

00:32:48,169 --> 00:32:52,489
larger all this timing is just run on my

00:32:50,359 --> 00:32:54,139
laptop and nothing super scientific but

00:32:52,489 --> 00:32:56,389
that's because the differences on large

00:32:54,139 --> 00:32:57,739
inputs are so big we really don't need

00:32:56,389 --> 00:32:58,650
to care if the measurements are accurate

00:32:57,739 --> 00:33:00,660
down below might

00:32:58,650 --> 00:33:03,420
second or even to the nearest second

00:33:00,660 --> 00:33:05,400
when we get up there so sometimes speed

00:33:03,420 --> 00:33:07,770
ups like this are just a testament to

00:33:05,400 --> 00:33:09,720
the rest compiler or LLVM being better

00:33:07,770 --> 00:33:12,180
at some clever math trick than you are

00:33:09,720 --> 00:33:15,780
but even a clever math trick is still a

00:33:12,180 --> 00:33:19,110
speed-up so remember these are both

00:33:15,780 --> 00:33:21,150
Python programs that I'm timing the only

00:33:19,110 --> 00:33:23,850
difference between the fast one and the

00:33:21,150 --> 00:33:26,400
slow one is that the fast one recognized

00:33:23,850 --> 00:33:28,950
its limitations and asked for help when

00:33:26,400 --> 00:33:31,230
it needed it and me personally as a

00:33:28,950 --> 00:33:33,270
DevOps who only got about halfway into

00:33:31,230 --> 00:33:34,980
the first CS degree before deciding a

00:33:33,270 --> 00:33:37,440
job would be a better choice than more

00:33:34,980 --> 00:33:39,450
school debt I was really glad to be

00:33:37,440 --> 00:33:43,800
using Python for everything but the

00:33:39,450 --> 00:33:46,230
maths in this FFI demo remember that

00:33:43,800 --> 00:33:48,690
familiarity to you is a strength that a

00:33:46,230 --> 00:33:51,210
tool can have if you can personally

00:33:48,690 --> 00:33:52,710
build things better and faster with your

00:33:51,210 --> 00:33:56,040
favorite tool than with something else

00:33:52,710 --> 00:33:58,140
that tool is better for you and any

00:33:56,040 --> 00:34:00,060
language any tool is going to sound

00:33:58,140 --> 00:34:02,160
great when you focus on the challenges

00:34:00,060 --> 00:34:03,930
that it solved well rather than those

00:34:02,160 --> 00:34:07,230
that are still figuring out rest

00:34:03,930 --> 00:34:09,179
included we've toured a variety of rusts

00:34:07,230 --> 00:34:10,980
technical and social implementations

00:34:09,179 --> 00:34:14,640
that address the interface between

00:34:10,980 --> 00:34:17,460
software and humanity today and like

00:34:14,640 --> 00:34:21,000
rest your language and project cannot be

00:34:17,460 --> 00:34:22,830
everything for everyone your answers to

00:34:21,000 --> 00:34:26,040
these questions will be different from

00:34:22,830 --> 00:34:29,490
rusts answers but a lot of the questions

00:34:26,040 --> 00:34:30,720
might very well be the same so I hope

00:34:29,490 --> 00:34:32,190
that throughout the rest of this

00:34:30,720 --> 00:34:34,260
conference we can continue the

00:34:32,190 --> 00:34:36,060
conversation about how to combine the

00:34:34,260 --> 00:34:40,429
strengths that different technologies

00:34:36,060 --> 00:34:40,429
have to offer thank you

00:34:45,190 --> 00:34:48,650
[Music]

00:34:48,669 --> 00:34:53,810
Thank You Emily Thank You Emily that was

00:34:51,830 --> 00:34:57,830
wonderful as a token of appreciation

00:34:53,810 --> 00:34:59,990
that we have these Python max for ages

00:34:57,830 --> 00:35:04,270
already did some new design every year

00:34:59,990 --> 00:35:04,270

YouTube URL: https://www.youtube.com/watch?v=TW7PxyrCBR0


